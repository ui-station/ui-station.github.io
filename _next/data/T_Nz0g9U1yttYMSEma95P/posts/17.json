{"pageProps":{"posts":[{"title":"Diffable Data Source를 사용한 다중 필터 컬렉션 뷰 생성 방법","description":"","date":"2024-06-23 01:30","slug":"2024-06-23-CreatingaMulti-FilterCollectionViewwithDiffableDataSource","content":"\n## iOS 프로덕션 코드에서 복잡한 UI 변경 사항을 확인하는 개념 증명\n\n저스트 잇 테이크어웨이 닷컴의 확장으로 음식 뿐만 아니라 식료품 및 다양한 다른 제품도 제공하기 위해 카테고리 및 하위 카테고리에서 선택 및 세부 사항을 걸러내는 새로운 UI를 구현해야 했습니다.\n\n![이미지](/assets/img/2024-06-23-CreatingaMulti-FilterCollectionViewwithDiffableDataSource_0.png)\n\n요구 사항:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 사용자는 첫 번째 캐로셀에서 하나의 카테고리만 선택할 수 있습니다. 항상 기본 카테고리가 선택됩니다.\n- 카테고리를 선택하면 두 번째 캐로셀에 모든 가능한 옵션이 표시되며 사용자는 여러 옵션을 선택할 수 있습니다.\n- 첫 번째와 두 번째 캐로셀에서 선택한 선택 사항을 반영하는 여러 섹션이 추가되어, 항목 간의 선택이 가능한 컬렉션 뷰가 만들어졌습니다.\n\n제품 코드를 구현하는 데 큰 노력이 필요하여, 우리는 제품에 코드를 구현하기 전에 간단한 증명 프로젝트를 사용하기로 결정했습니다.\n\n이 튜토리얼의 코드는 iOS에서 복잡한 사용자 인터페이스를 만들기 위한 증명 프로젝트로 사용되었습니다. 우리가 달성한 최종 목표는 그림에서 UI를 구현하는 것이었습니다.\n\n# 증명 프로젝트의 중요성\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n개념 증명 (Proof of Concept, PoC)은 개발 과정에서 중요한 단계입니다. 이를 통해 개발자들은 아이디어와 구현의 실행 가능성을 전체 개발에 앞서 더 작은 규모로 테스트할 수 있습니다.\n\nPoC를 만들면 잠재적인 문제를 빠르게 식별하고 가정을 검증하며 다양한 디자인 선택지를 탐색할 수 있습니다.\n\n이 방법을 통해 우량하고 효과적인 해결책만을 추구하여 시간과 자원을 절약할 수 있습니다.\n\n이 자습서에서 PoC는 최신 컬렉션 뷰 기술을 사용하여 복잡한 UI 요구사항을 관리하는 방법을 보여주며, 추가 개발을 위한 견고한 기반을 제공합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n현실 세계 시나리오에서는 식당 API를 사용하여 데이터를 가져와 컬렉션 뷰에 표시하지만, 이 튜토리얼에서는 개 API를 사용하여 개념을 설명하고 즐거운 시간을 가질 겁니다!\n\n![이미지](https://miro.medium.com/v2/resize:fit:1200/1*96GQ1GHslcj5tvtG6uwAeg.gif)\n\n이 튜토리얼에서는 UICollectionViewDiffableDataSource 및 UICollectionViewCompositionalLayout을 사용하여 여러 필터링 가능한 섹션을 포함하는 컬렉션 뷰를 만드는 방법을 안내합니다. 이 설정을 보여주기 위해 MultiFilterViewController 클래스를 사용할 것입니다.\n\n# 단계 1: 데이터 모델 정의하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n데이터 모델을 정의하여 컬렉션 뷰에서 섹션과 항목을 나타낼 수 있도록 해보세요. 이 모델들은 Hashable 프로토콜을 준수해야 합니다. 이 예시에서는 세 가지 데이터 모델을 정의합니다: Category, Breed, Image. Content 구조체는 컬렉션 뷰에 표시될 섹션 유형과 항목을 정의합니다.\n\n```swift\nstruct Category: Hashable {\n    let name: String\n    let range: ClosedRange<String>\n    let isSelected: Bool\n}\n\nstruct Breed: Hashable {\n    let breed: String\n    let apiKey: String\n    let isSelected: Bool\n}\n\nstruct Image: Hashable {\n    let url: URL\n}\n\nstruct Content {\n    enum SectionType: Int, Hashable {\n        case category\n        case breed\n        case images\n    }\n\n    struct Section: Hashable {\n        var id: String\n        var type: SectionType\n    }\n\n    enum Item: Hashable {\n        case category(Category)\n        case breed(Breed)\n        case image(Image)\n\n        func hash(into hasher: inout Hasher) {\n            switch self {\n            case .category(let item):\n                hasher.combine(item.hashValue)\n            case .breed(let item):\n                hasher.combine(item.hashValue)\n            case .image(let image):\n                hasher.combine(image)\n            }\n        }\n    }\n}\n```\n\n우리는 세 가지 종류의 섹션을 가지고 있습니다: category, breed, images. 각 섹션에는 고유한 식별자와 유형이 있습니다. Item 열거형은 각 섹션 내 항목을 나타냅니다. hash(into:) 메서드는 각 항목이 고유하게 식별되도록 구현되어 있습니다.\n\n# Step 2: 뷰 컨트롤러 설정하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n뷰 컨트롤러 MultiFilterViewController을 생성하고 해당 속성을 정의하세요.\n\n```js\nclass MultiFilterViewController: UIViewController {\n\n    static let sectionHeaderElementKind = \"section-header-element-kind\"\n\n    var collectionView: UICollectionView!\n    var collectionViewLayout: UICollectionViewCompositionalLayout!\n\n    // 데이터를 가져오는 서비스\n    let service: APIServing = Service()\n\n    // 데이터를 관리하는 ViewModel\n    let viewModel = SectionViewModel()\n\n    var dataSource: UICollectionViewDiffableDataSource<Content.Section, Content.Item>?\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        updateInBackground()\n    }\n\n    init() {\n        super.init(nibName: nil, bundle: nil)\n        self.setupView()\n        self.setupConstraints()\n        self.dataSource = self.makeDataSource()\n    }\n\n    required init?(coder: NSCoder) {\n        fatalError(\"구현되지 않았습니다\")\n    }\n}\n```\n\n데이터를 가져오는 \"service\" 속성과 데이터를 관리하는 \"viewModel\" 속성을 정의했습니다. 또한 \"dataSource\" 속성을 사용하여 UICollectionViewDiffableDataSource를 통해 컬렉션 뷰 데이터 소스를 관리합니다. 컬렉션 뷰 레이아웃은 UICollectionViewCompositionalLayout을 사용하여 정의되었습니다.\n\n# 단계 3: 뷰 및 제약 조건 설정\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n컬렉션 뷰를 초기화하고 구성하여 레이아웃을 설정하고 필요한 셀 및 보조 뷰를 등록합니다.\n\n```js\nextension MultiFilterViewController {\n    func setupView() {\n        collectionViewLayout = buildCompositionalLayout()\n        collectionView = UICollectionView(frame: .zero, collectionViewLayout: collectionViewLayout)\n        collectionView.translatesAutoresizingMaskIntoConstraints = false\n        collectionView.allowsMultipleSelection = true\n        collectionView.delegate = self\n        view.backgroundColor = .white\n        title = \"Dog Breeds\"\n        view.addSubview(collectionView)\n    }\n\n    func setupConstraints() {\n        NSLayoutConstraint.activate([\n            collectionView.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor),\n            collectionView.bottomAnchor.constraint(equalTo: view.safeAreaLayoutGuide.bottomAnchor),\n            collectionView.leadingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.leadingAnchor),\n            collectionView.trailingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.trailingAnchor),\n        ])\n    }\n}\n```\n\n이 단계에서는 컬렉션 뷰를 설정하고 뷰 컨트롤러의 뷰에 추가합니다. 또한 컬렉션 뷰가 전체 화면을 채우도록 제약 조건을 정의합니다.\n\n# 단계 4: 셀 및 보조 뷰 등록하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여러 항목 유형에 대한 셀 등록 및 섹션 헤더에 대한 보충 뷰 등록을 정의합니다.\n\n```js\nextension MultiFilterViewController {\n\n    private func createLevelOneCellRegistration() -> UICollectionView.CellRegistration<LevelOneCollectionViewCell, Category> {\n        UICollectionView.CellRegistration<LevelOneCollectionViewCell, Category> { [weak self] (cell, indexPath, item) in\n            cell.item = item\n            cell.icon = indexPath.row.isMultiple(of: 2) ? UIImage(systemName: \"pawprint\") : UIImage(systemName: \"pawprint.fill\")\n            if item.isSelected {\n                self?.collectionView.selectItem(at: indexPath, animated: false, scrollPosition: [])\n            }\n        }\n    }\n\n    private func createLevelTwoCellRegistration() -> UICollectionView.CellRegistration<LevelTwoCollectionViewCell, Breed> {\n        UICollectionView.CellRegistration<LevelTwoCollectionViewCell, Breed> { [weak self] (cell, indexPath, item) in\n            cell.item = item.breed\n            Task { @MainActor in\n                guard let self else { return }\n                if let url = try await self.viewModel.randomImageURL(for: item, service: self.service) {\n                    cell.image = try await ImageManager.shared.getImage(for: url)\n                } else {\n                    cell.image = UIImage(systemName: \"pawprint\")\n                }\n            }\n            cell.position = indexPath.item\n            if item.isSelected {\n                self?.collectionView.selectItem(at: indexPath, animated: false, scrollPosition: [])\n            }\n        }\n    }\n\n    private func createCardCellRegistration() -> UICollectionView.CellRegistration<CardCollectionViewCell, Image> {\n        UICollectionView.CellRegistration<CardCollectionViewCell, Image> { (cell, indexPath, item) in\n            Task { @MainActor in\n                cell.image = try await ImageManager.shared.getImage(for: item.url)\n            }\n        }\n    }\n\n    private func headerRegistration() -> UICollectionView.SupplementaryRegistration<SectionTitleView> {\n        UICollectionView.SupplementaryRegistration\n        <SectionTitleView>(elementKind: MultiFilterViewController.sectionHeaderElementKind) { [weak self] (supplementaryView, string, indexPath) in\n            guard let section = self?.dataSource?.sectionIdentifier(for: indexPath.section) else { return }\n            supplementaryView.label.text = section.id\n            supplementaryView.backgroundColor = .white\n        }\n    }\n}\n```\n\n이 단계에서는 Category, Breed 및 Image와 같은 다양한 항목 유형에 대한 셀 등록을 정의합니다. 또한 섹션 헤더에 대한 보충 뷰 등록을 정의합니다. 셀 등록은 적절한 데이터와 이미지로 셀을 구성합니다. 보충 뷰 등록은 섹션 식별자를 기반으로 섹션 제목을 설정합니다.\n\n# 단계 5: 데이터 소스 구성\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음 단계에서는 `UICollectionViewDiffableDataSource`를 사용하여 diffable 데이터 소스를 생성합니다. 서로 다른 항목 유형에 대한 셀 프로바이더와 섹션 헤더를 위한 보충 뷰 프로바이더를 제공합니다. 셀 프로바이더는 항목 유형에 따라 적절한 셀을 대기열에서 꺼내옵니다. 그리고 보충 뷰 프로바이더는 섹션 헤더 뷰를 대기열에서 꺼내옵니다.\n\n# 단계 6: Compositional Layout 구축\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이번 단계에서는 컬렉션 뷰의 구성 레이아웃을 정의합니다. 섹션 제공자는 각 섹션의 레이아웃을 섹션 타입에 따라 반환합니다. 참고: dataSource를 사용하여 섹션 식별자를 검색하고 섹션 타입에 따라 레이아웃을 작성합니다.\n\n# 단계 7: 데이터 가져오기 및 업데이트하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n뷰 모델에서 데이터를 가져와 diffable 데이터 소스의 snapshot을 업데이트하는 update() 메서드를 정의합니다.\n\n```js\nextension MultiFilterViewController {\n    func update() async throws {\n        let sections = try await viewModel.fetchData(service: service)\n        var snapshot = NSDiffableDataSourceSnapshot<Content.Section, Content.Item>()\n        let sectionKeys = sections.keys.sorted { section0, section1 in\n            guard section0.type == section1.type else { return section0.type.rawValue < section1.type.rawValue }\n            return section0.id < section1.id\n        }\n        for sectionKey in sectionKeys {\n            if let items = sections[sectionKey] {\n                snapshot.appendSections([sectionKey])\n                snapshot.appendItems(items, toSection: sectionKey)\n            }\n        }\n        dataSource?.apply(snapshot, animatingDifferences: true, completion: {\n            print(\"Apply snapshot completed!\")\n        })\n    }\n\n    func updateInBackground() {\n        Task {\n            do {\n                try await update()\n            } catch {\n                print(error)\n            }\n        }\n    }\n}\n```\n\n이 단계에서는 fetchData() 메서드를 사용하여 뷰 모델에서 데이터를 검색하고 섹션 및 항목으로 스냅샷을 만듭니다. 그런 다음 스냅샷을 데이터 소스에 적용하여 컬렉션 뷰를 업데이트합니다.\n\n# 단계 8: 델리게이트 메서드를 사용한 선택 처리\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nUICollectionViewDelegate 메서드를 구현하여 항목 선택 및 선택 해제를 처리합니다.\n\n```js\nextension MultiFilterViewController: UICollectionViewDelegate {\n    func collectionView(_ collectionView: UICollectionView, shouldDeselectItemAt indexPath: IndexPath) -> Bool {\n        guard let item = dataSource?.itemIdentifier(for: indexPath) else { return false }\n        switch item {\n        case .category(let item):\n            return item.name != viewModel.selectedCategory\n        case .breed:\n            return true\n        case .image:\n            return true\n        }\n    }\n\n    func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {\n        guard let item = dataSource?.itemIdentifier(for: indexPath) else { return }\n        switch item {\n        case .category(let item):\n            collectionView.selectOneIndexInSection(at: indexPath, animated: true)\n            viewModel.selectCategory(category: item.name)\n            updateInBackground()\n        case .breed(let breed):\n            viewModel.toggleBreed(breed: breed.breed)\n            updateInBackground()\n        case .image(let image):\n            print(image)\n        }\n    }\n\n    func collectionView(_ collectionView: UICollectionView, didDeselectItemAt indexPath: IndexPath) {\n        guard let item = dataSource?.itemIdentifier(for: indexPath) else { return }\n        switch item {\n        case .category(let category):\n            print(category)\n        case .breed(let breed):\n            viewModel.toggleBreed(breed: breed.breed)\n            updateInBackground()\n        case .image(let image):\n            print(image)\n        }\n    }\n}\n```\n\n이 단계에서는 항목 선택 및 해제를 처리하기 위해 UICollectionViewDelegate 메서드를 구현했습니다. shouldDeselectItemAt 메서드를 사용하여 항목 유형에 따라 특정 항목의 선택 해제를 방지합니다. didSelectItemAt 메서드는 항목 선택을 처리하고 뷰 모델을 그에 맞게 업데이트합니다. didDeselectItemAt 메서드는 항목 해제를 처리하고 뷰 모델을 업데이트합니다.\n\n컬렉션 뷰에서 여러 항목을 선택할 수 있도록 여러 선택이 가능하도록 설정했습니다. 이는 섹션 내에서 여러 항목을 선택할 수 있도록 하기 위해 각 항목 유형에 대한 선택 및 선택 해제 로직을 처리해야 한다는 것을 의미합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n경고: UICollectionView를 구성 레이아웃을 사용하도록 마이그레이션할 때 UICollectionViewDelegate가 업데이트되지 않은 모델을 참조하는 경우가 있습니다. UICollectionView의 진실의 원천은 diffable 데이터 소스이며 섹션 및 항목을 참조하는 데 사용해야 합니다. 이를 하지 않으면 앱 충돌이 발생할 수 있습니다.\n\n우리는 비용을 들여 배웠습니다. UICollectionViewDelegate가 UICollectionViewDiffableDataSource를 포함하는 클래스에 구현되어야 하며 올바르지 않은 모델을 참조하는 것을 방지해야 합니다. 항상 dataSource?.itemIdentifier(for: indexPath) 및 dataSource?.sectionIdentifier(for: section)을 사용하여 항목과 섹션을 참조하고 UICollectionView에서 직접 검색하지 않도록 해야 합니다.\n\n# 단계 9: 선택 관리를 위한 도우미 메서드 추가\n\n섹션 내에서 선택 및 선택 해제를 처리하는 도우미 메서드를 추가하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```swift\nextension UICollectionView {\n    func deselectAllInSection(section: Int, animated: Bool) {\n        guard let selectedIndexesInSection = indexPathsForSelectedItems?\n            .filter({  $0.section == section }) else { return }\n        for index in selectedIndexesInSection {\n            deselectItem(at: index, animated: animated)\n        }\n    }\n\n    func selectOneIndexInSection(at indexPath: IndexPath, animated: Bool) {\n        deselectAllInSectionExcept(at: indexPath, animated: animated)\n        selectItem(at: indexPath, animated: animated, scrollPosition: [])\n    }\n\n    private func deselectAllInSectionExcept(at indexPath: IndexPath, animated: Bool) {\n        guard let selectedIndexesInSection = indexPathsForSelectedItems?\n            .filter({  $0.section == indexPath.section && $0.row != indexPath.row }) else { return }\n        for index in selectedIndexesInSection {\n            deselectItem(at: index, animated: animated)\n        }\n    }\n}\n```\n\n# 요약\n\n이제 UICollectionViewDiffableDataSource와 UICollectionViewCompositionalLayout을 사용하여 여러 필터링 가능한 섹션을 관리하는 MultiFilterViewController를 만들었습니다. 이 설정을 통해 동적이고 효율적인 데이터 업데이트와 유연한 항목 선택 및 선택 해제 처리가 가능해졌습니다. UICollectionView의 진리의 원천은 UICollectionViewDiffableDataSource이며, 항목 및 섹션을 참조할 때 사용해야 한다는 것을 배웠습니다. 이 자습서의 소스 코드는 여기에서 찾을 수 있습니다.\n\n# 참고문헌\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- Collection View 레이아웃의 진보\n- UI 데이터 소스의 진보\n- 현대적인 Collection Views 구현\n\nJust Eat Takeaway.com에서 채용 중입니다! 함께 일하고 싶으신가요? 지금 지원하세요.\n","ogImage":{"url":"/assets/img/2024-06-23-CreatingaMulti-FilterCollectionViewwithDiffableDataSource_0.png"},"coverImage":"/assets/img/2024-06-23-CreatingaMulti-FilterCollectionViewwithDiffableDataSource_0.png","tag":["Tech"],"readingTime":17},{"title":" Jetpack Compose vs 전통적 안드로이드 반응형 UI를 위한 대결 ","description":"","date":"2024-06-23 01:29","slug":"2024-06-23-JetpackComposevsTraditionalAndroidTheBattleforResponsiveUIs","content":"\n![이미지](/assets/img/2024-06-23-JetpackComposevsTraditionalAndroidTheBattleforResponsiveUIs_0.png)\n\n# Jetpack Compose:\n\n- 적응형 레이아웃:\n\n  - 의미: Jetpack Compose는 다양한 화면 크기 및 방향에 매끄럽게 적응하는 레이아웃을 만들도록 권장합니다.\n  - 방법: fillMaxWidth, fillMaxHeight 및 padding과 같은 수정자를 사용하여 사용 가능한 공간에 따라 레이아웃 속성을 동적으로 조정합니다. 또한 Modifier.weight(f)를 사용하여 공간, 높이, 너비 또는 자식 Composables의 크기를 비례적으로 분배할 수 있습니다.\n\n- 예시:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\nColumn(\n    modifier = Modifier.fillMaxSize().padding(16.dp)\n) {\n    Row {\n      Text(text = \"안녕하세요!\", modifier = Modifier.weight(1f))\n      Text(text = \"컴포즈!\", modifier = Modifier.weight(1f))\n    }\n}\n```\n\n- 왜 중요한가요?: 적응형 레이아웃으로 여러 기기(소형 폰부터 대형 태블릿까지)에서 앱이 멋지게 보입니다.\n\n2. Compose의 ConstraintLayout:\n\n- 무엇인가요?: ConstraintLayout은 UI 요소 간의 관계를 정의할 수 있는 강력한 레이아웃 매니저입니다.\n- 어떻게 사용하나요?: 아래 예시에서 text1과 text2는 Text Composable에 할당된 레이아웃 ID이며, top.linkTo(text1.bottom)을 사용하여 요소를 text1 아래에 배치할 수 있습니다.\n- 예시:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\nConstraintLayout(Modifier.fillMaxSize()) {\n    val (text1, text2) = createRefs()\n    Text(\"Top\", modifier = Modifier.constrainAs(text1) {\n        top.linkTo(parent.top)\n    })\n    Text(\"Bottom\", modifier = Modifier.constrainAs(text2) {\n        top.linkTo(text1.bottom)\n    })\n}\n```\n\n- 왜 멋진가요: ConstraintLayout은 복잡한 UI 배열을 간소화하고 태블릿 및 휴대전화 모두에서 반응성을 보장합니다.\n\n3. 창 크기 클래스:\n\n- 이것들은 무엇인가요: 창 크기 클래스는 다양한 화면 크기(작은, 중간, 큰 등)를 나타냅니다.\n- 어떻게 사용하나요: LocalConfiguration.current.screenLayout를 통해 창 크기 클래스에 액세스할 수 있습니다.\n- 예시:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\nval screenSize = LocalConfiguration.current.screenLayout\nwhen (screenSize) {\n    Configuration.SCREENLAYOUT_SIZE_SMALL -> // 작은 화면 처리\n    Configuration.SCREENLAYOUT_SIZE_NORMAL -> // 일반 화면 처리\n    // 기타 경우\n}\n```\n\n- 이유: 특정 차원을 하드코딩하지 않고 사용 가능한 공간에 기반하여 사용자 인터페이스를 맞춤화할 수 있습니다. 💃🏽🕺🏿\n\n# 전통적인 안드로이드 개발:\n\n- 리소스 한정자:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 무엇인가요: 자원 한정자를 사용하면 다양한 화면 크기와 밀도에 대해 다른 레이아웃을 제공할 수 있습니다.\n- 사용 방법: 레이아웃-작은, 레이아웃-큰 등과 같은 자원 폴더를 만들고 레이아웃 파일을 해당 폴더에 배치합니다. OS에서 기기 사양에 따라 어떤 레이아웃 파일을 inflate 할지 결정합니다.\n- 예시:\n\n```java\nres/\n    layout/\n        activity_main.xml\n    layout-large/\n        activity_main.xml (큰 화면에 최적화된 파일)\n```\n\n- 왜 중요한가요: 자원 한정자는 다양한 기기들 사이에서 일관된 UI를 보장합니다.\n\n2. 뷰 내 ConstraintLayout:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 무엇인가요: ConstraintLayout은 평평한 뷰 계층 구조로 복잡한 UI 레이아웃을 만들 수 있게 해줍니다 😊\n- 어떻게 사용하나요: 아래 XML은 두 개의 TextView 요소를 포함하는 ConstraintLayout을 정의합니다. 첫 번째 TextView는 부모의 시작에 고정되고 위쪽과 정렬됩니다. 두 번째 TextView는 첫 번째 TextView의 오른쪽에 위치하며 위쪽으로 정렬됩니다. 이 레이아웃은 두 개의 TextView가 ConstraintLayout 내에서 수평으로 인접하도록 보장합니다.\n- 예시:\n\n```js\n<androidx.constraintlayout.widget.ConstraintLayout\n  xmlns:android=\"http://schemas.android.com/apk/res/android\"\n  android:layout_width=\"match_parent\"\n  android:layout_height=\"match_parent\"\n>\n  <TextView\n    android:id=\"@+id/textView1\"\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"첫 번째 TextView\"\n    app:layout_constraintStart_toStartOf=\"parent\"\n    app:layout_constraintTop_toTopOf=\"parent\"\n  />\n\n  <TextView\n    android:id=\"@+id/textView2\"\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"두 번째 TextView\"\n    app:layout_constraintStart_toEndOf=\"@+id/textView1\"\n    app:layout_constraintTop_toTopOf=\"parent\"\n  />\n</androidx.constraintlayout.widget.ConstraintLayout>\n```\n\n- 그들이 필수적인 이유: 모든 중첩된 레이아웃은 레이아웃 계산 중 추가적인 처리 시간을 소모합니다. ConstraintLayout은 뷰 간의 유연한 관계를 조성하고 중첩된 뷰 그룹을 최소화하여 전체 성능을 크게 향상시킵니다.\n\n반응형 Android 레이아웃을 개발하는 것은 다양한 화면 크기에 일관된 사용자 경험을 제공하기 위해 중요합니다. 다른 기기에서 레이아웃을 확인하여 예상치 못한 문제를 파악하는 것을 기억해 주세요. 그리고 위 Lonely T-Rex 이미지가 궁금하다면 - 그것은 구글 크롬 오프라인 게임으로, Jetpack Compose를 이용해 만들어진 것입니다 👍🏽 구글 플레이에서 다운로드하고 리뷰를 남겨서 이상한 알고리즘을 돕는 데 도움을 주세요 🚀📱\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n🗣️: 문의해 주세요\nLinkedIn: [링크드인 프로필](https://www.linkedin.com/in/raphael-c-8b43612b6/)\n\n감사합니다,\nRC\n","ogImage":{"url":"/assets/img/2024-06-23-JetpackComposevsTraditionalAndroidTheBattleforResponsiveUIs_0.png"},"coverImage":"/assets/img/2024-06-23-JetpackComposevsTraditionalAndroidTheBattleforResponsiveUIs_0.png","tag":["Tech"],"readingTime":6},{"title":"Jetpack Glance - 알아두어야 할 주요 기능 및 장점","description":"","date":"2024-06-23 01:28","slug":"2024-06-23-JetpackGlance","content":"\n## 안드로이드에서 아름다운 위젯을 만드는 Compose 방법\n\n![image](/assets/img/2024-06-23-JetpackGlance_0.png)\n\n여러 해 동안 위젯은 안드로이드 경험의 중요한 부분이었습니다. 그러나 이를 만들고 유지하는 것은 종종 괴로운 과정이었습니다. 전통적인 방법은 복잡할 수 있으며 명확한 설명 없이 예상치 못한 동작이 발생할 수 있습니다.\n\n여기서 Jetpack Glance가 혁신적인 새로운 방식으로 등장하여 문제를 해결합니다. Jetpack Compose의 선언적 UI의 강점을 활용하여 Glance는 위젯 개발을 간소화하고 더 쉽고 즐겁게 안드로이드 애플리케이션용 아름다운 기능적 위젯을 만드는데 도움을 줍니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n최근에 출시된 Jetpack Glance 1.1.0에 대해 얘기해볼까요? 이번 릴리즈는 위젯 개발을 간편하게 해줄 수 있는 잠재력에 대해 특별한 관심을 불러일으키는군요. 그래서 저는 Glance의 기능을 직접 경험해보기로 결심했습니다. 이 기능들을 시험해보기 위해, 저는 내 책 앱을 위한 위젯을 만들기로 했습니다. 이 위젯은 사용자 데이터에 접근하고 마지막으로 읽은 책을 계속할 수 있는 편리한 단축키를 제공하기 위해 Glance의 기능을 활용할 것입니다.\n\n개발 프로세스에 대해 자세히 살펴보고 전체적인 실습 경험을 위해 직접 위젯을 만들어보겠습니다.\n\n# 구조 정의\n\n어떠한 프로젝트라도 시작하기 전에 필요한 종속성을 설정하는 것부터 시작해야 합니다. 이 경우, 두 가지 주요 Jetpack Glance 라이브러리를 활용할 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n[버전]\n\nglance = \"1.1.0\"\n...\n\n[라이브러리]\n\nglance-appwidget = { group = \"androidx.glance\", name = \"glance-appwidget\", version.ref = \"glance\" }\nglance-material = { group = \"androidx.glance\", name = \"glance-material3\", version.ref = \"glance\" }\n...\n```\n\n의존성이 설정된 상태에서 이제 코드 자체에 집중할 수 있습니다.\n\n코드 구성 및 재사용성을 증진하기 위해 위젯 전용 패키지를 별도로 생성하기로 결정했습니다. 이 접근 방식을 통해 위젯 관련 코드를 단일하고 명확한 위치에 그룹화할 수 있습니다.\n\n저희 Glance 위젯 개발은 MyBooksAppWidget과 MyBooksAppWidgetReceiver 두 가지 핵심 클래스를 설정하는 데서 시작됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- MyBooksAppWidget: 이 클래스는 GlanceAppWidget을 상속받습니다 (나의 경우에는 의존성 주입을 위해 Koin을 사용합니다. 선호하는 것을 선택할 수 있습니다). 이 클래스 안에서 위젯의 레이아웃을 정의할 것입니다.\n\n```js\nclass MyBooksAppWidget : GlanceAppWidget(), KoinComponent {\n...\n}\n```\n\n- MyBooksAppWidgetReceiver: 이 클래스는 GlanceAppWidgetReceiver를 상속받으며 위젯 인스턴스 (MyBooksAppWidget)의 초기화를 담당합니다.\n\n```js\nclass MyBooksAppWidgetReceiver : GlanceAppWidgetReceiver() {\n    override val glanceAppWidget: GlanceAppWidget = MyBooksAppWidget()\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nxml 디렉토리에 새 리소스 파일을 만들어야 합니다 (저의 경우 my_book_widget_info로 이름 짓겠습니다). 이 파일은 위젯의 구성을 나타내며 홈 화면에서의 동작과 외관을 정의하는 다양한 속성을 제공합니다.\n\n```js\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<appwidget-provider xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:resizeMode=\"horizontal|vertical\"\n    android:updatePeriodMillis=\"3600000\"\n    android:minHeight=\"50dp\"\n    android:minWidth=\"100dp\"\n    android:minResizeHeight=\"50dp\"\n    android:minResizeWidth=\"50dp\"\n    android:widgetCategory=\"home_screen\"\n    android:configure=\"com.stefanoq21.mybooks.MainActivity\"\n    android:widgetFeatures=\"configuration_optional|reconfigurable\"\n    android:previewImage=\"@drawable/widget_preview\"\n    android:maxResizeHeight=\"512dp\"\n    android:maxResizeWidth=\"512dp\"\n    android:targetCellWidth=\"2\"\n    android:targetCellHeight=\"1\"\n    android:initialLayout=\"@layout/glance_default_loading_layout\"\n    android:description=\"@string/widget_picker_description\"\n    >\n</appwidget-provider>\n```\n\n이제 주요 속성들을 살펴보고 사용자 경험에 어떻게 기여하는지 알아보겠습니다.\n\n- 최소/최대/조정 가능 폭 및 높이는 위젯의 경계를 정의하고 홈 페이지에서 어떻게 조절될 수 있는지를 나타냅니다.\n- initialLayout은 위젯이 데이터를 앱 로직이나 데이터베이스에서 검색하는 동안 표시될 레이아웃을 정의합니다. 이 임시 레이아웃은 사용자가 데이터 검색 과정 중에 빈 공간을 보지 않도록 플레이스홀더 역할을 합니다. glance_default_loading_layout를 사용하면 Glance 자체에서 제공하는 표준 로딩 화면을 활용할 수 있습니다.\n- previewImage 및 description은 위젯이 픽커 내에서 어떻게 보여질지를 정의합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-06-23-JetpackGlance_1.png\" />\n\nGlance 위젯의 기본 구조를 설정하는 마지막 단계는 AndroidManifest.xml 파일 내에서 수신기 클래스를 등록하는 것입니다. 이 등록 프로세스는 Android 시스템에 위젯 수신기의 존재를 알리고, 해당 브로드캐스트를 수신하여 위젯 업데이트를 트리거할 수 있도록합니다.\n\n```js\n<receiver\n  android:name=\".widget.MyBooksAppWidgetReceiver\"\n  android:exported=\"true\"\n  android:label=\"@string/widget_receiver_label\"\n>\n  <intent-filter>\n    <action android:name=\"android.appwidget.action.APPWIDGET_UPDATE\" />\n  </intent-filter>\n\n  <meta-data\n    android:name=\"android.appwidget.provider\"\n    android:resource=\"@xml/my_book_widget_info\"\n  />\n</receiver>\n```\n\n핵심 구조를 확립했으므로 이제 위젯의 레이아웃 생성에 집중해 보겠습니다. Glance를 사용하면 다양한 시나리오에 대응하는 적응형 레이아웃을 디자인할 수 있습니다. 이러한 적응성은 데이터 수신 및 홈 화면에서 사용자가 선택한 크기에 따라 위젯이 표시를 조정함을 보장합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 적응형 레이아웃\n\nMyBooksAppWidget 클래스는 위젯의 시각적 모습을 결정하는 중요한 역할을 합니다.\n\n여기에서는 레이아웃을 사용자 정의해야 하는 두 가지 중요한 오버라이드가 있습니다:\n\nsizeMode: 이것은 위젯이 홈 화면의 사용 가능한 공간에 따라 크기를 어떻게 관리하는지 제어합니다. Glance는 세 가지 옵션을 제공합니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- SizeMode.Single: 위젯은 크기가 고정되어 있으며 크기 변경에 반응하지 않습니다.\n- SizeMode.Exact: 위젯은 시스템에서 모든 크기 업데이트를 받아들여 완전히 동적 레이아웃 조정이 가능합니다.\n- SizeMode.Responsive: 이 모드는 위젯이 적응해야 할 특정 크기를 정의하도록 허용하여 더 많은 제어를 제공합니다.\n\n내 예시에서는 SizeMode.Responsive를 선택하고 ICON_SQUARE, SMALL_SQUARE, MEDIUM_SQUARE라는 크기를 지정했습니다. 이를 통해 위젯이 사용 가능한 공간에 따라 레이아웃을 조정하고 서로 다른 크기에 대해 다른 내용이나 레이아웃을 표시할 수 있습니다.\n\n```js\nclass MyBooksAppWidget : GlanceAppWidget(), KoinComponent {\n\n    companion object {\n        internal val ICON_SQUARE = DpSize(50.dp, 50.dp)\n        internal val SMALL_SQUARE = DpSize(100.dp, 100.dp)\n        internal val MEDIUM_SQUARE = DpSize(150.dp, 150.dp)\n    }\n\n    override val sizeMode = SizeMode.Responsive(\n        setOf(\n            ICON_SQUARE,\n            SMALL_SQUARE,\n            MEDIUM_SQUARE,\n        )\n    )\n...\n```\n\nprovideGlance 함수는 위젯의 시각적 표현의 핵심을 형성합니다. 여기에서 Jetpack Compose 컴포저블을 사용하여 실제 레이아웃을 정의할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\n...\n 재정의 suspend fun provideGlance(context: Context, id: GlanceId) {\n        val repository: DatabaseRepository by inject()\n        provideContent {\n            val book by repository.getLastOpenedLibraryItemFlow().collectAsState(null)\n            GlanceTheme {\n                if (book != null) {\n                    BookState(\n                        book!!, onClick =\n                        actionStartActivity(\n                            Intent(context.applicationContext, MainActivity::class.java)\n                                .setAction(Intent.ACTION_VIEW)\n                                .setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP)\n                                .setData(\"https://com.stefanoq21.mybooks/ReaderEpub/${book!!.bookId}\".toUri())\n                        )\n                    )\n                } else {\n                    ZeroState(\n                       onClick =\n                        actionStartActivity(\n                            Intent(context.applicationContext, MainActivity::class.java)\n                                .setAction(Intent.ACTION_VIEW)\n                                .setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP)\n                        )\n                    )\n                }\n            }\n        }\n    }\n```\n\n제공된 코드 조각은 귀하의 Glance 위젯 기능의 두 가지 주요 측면을 보여줍니다:\n\n- 조건부 레이아웃: 데이터가 있는 경우 (BookState)와 데이터가 없는 경우 (ZeroState)를 위한 두 가지 다른 레이아웃을 구현했습니다. 이를 통해 위젯이 다른 시나리오에서 사용자에게 적절한 피드백을 제공합니다.\n- 액션: onClick 매개변수로 전달된 액션들. 하나의 액션은 MainActivity를 실행하고, 다른 하나는 Jetpack Compose Navigation의 딥 링킹 기능을 활용하여 앱 내의 특정 화면으로 이동합니다. 이를 통해 위젯에서 앱의 관련 부분으로 원활하게 전환할 수 있습니다.\n\nZeroState 컴포저블은 표시할 관련 데이터가 없을 때 위젯에 표시되는 플레이스홀더 레이아웃으로 작동합니다. 이 시나리오는 사용자가 책을 읽기 전에 위젯을 추가한 경우에 발생합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\nimport androidx.glance.Button\nimport androidx.glance.GlanceModifier\nimport androidx.glance.GlanceTheme\nimport androidx.glance.ImageProvider\nimport androidx.glance.LocalSize\nimport androidx.glance.action.Action\nimport androidx.glance.action.clickable\nimport androidx.glance.appwidget.components.Scaffold\nimport androidx.glance.appwidget.components.TitleBar\nimport androidx.glance.layout.Alignment\nimport androidx.glance.layout.Box\nimport androidx.glance.layout.fillMaxSize\n\n@Composable\nfun ZeroState(onClick: Action) {\n    val size = LocalSize.current\n    if (size.width <= ICON_SQUARE.width) {\n        IconDimension(onClick)\n    } else {\n        Scaffold(\n            titleBar = {\n                TitleBar(\n                    startIcon = ImageProvider(R.drawable.ic_launcher_foreground),\n                    textColor = GlanceTheme.colors.onSurface,\n                    title = LocalContext.current.getString(R.string.widget_title),\n                )\n            },\n            backgroundColor = GlanceTheme.colors.widgetBackground,\n            modifier = GlanceModifier.fillMaxSize().clickable(onClick),\n        ) {\n            Box(modifier = GlanceModifier.fillMaxSize(), contentAlignment = Alignment.Center) {\n                Button(\n                    text = LocalContext.current.getString(R.string.start_reading),\n                    onClick = onClick\n                )\n            }\n        }\n    }\n}\n```\n\nGlance는 위젯에 대해 특별히 설계된 별도의 조합 기능을 제공한다는 점을 강조하기 위해 이 코드 조각에 import 문이 포함되어 있습니다.\n\nZeroState 조합은 Glance의 적응형 레이아웃을 만들어 사용 가능한 공간에 따라 프레젠테이션을 조정하는 능력을 보여줍니다. 이를 통해 사용자가 선택한 크기와 관계없이 위젯이 유용하고 정보 전달이 되도록합니다. 너비를 기준으로하면, 더 작은 크기에는 IconDimension 구성요소를 조건부로 렌더링하고, 보다 복잡한 레이아웃에서는 제목 표시줄과 버튼과 같은 구성요소를 조건부로 렌더링합니다.\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/1*ukJec6XVolL-uwNf9VbUhQ.gif\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nBookState 코움파서블은 ZeroState의 기반을 두고 있습니다. 사용자가 현재 읽고 있는 책 또는 최근 상호 작용한 책에 대한 정보를 표시하는 데 사용됩니다. ZeroState와 유사하게 버튼은 충분한 수직 공간이 있을 때에만 표시됩니다. 이는 레이아웃이 균형을 유지하고 시각적 혼란을 피하기 위해 보장합니다.\n\n```kotlin\n@Composable\nfun BookState(book: LibraryItem, onClick: Action) {\n    val size = LocalSize.current\n    if (size.width <= MyBooksAppWidget.ICON_SQUARE.width) {\n        IconDimension(onClick)\n    } else {\n        Scaffold(\n            backgroundColor = GlanceTheme.colors.widgetBackground,\n            modifier = GlanceModifier.fillMaxSize().clickable(onClick)\n        ) {\n            Column(\n                modifier = GlanceModifier.fillMaxSize()\n                    .padding(bottom = 8.dp),\n                verticalAlignment = Alignment.Vertical.CenterVertically,\n                horizontalAlignment = Alignment.Horizontal.CenterHorizontally,\n            ) {\n                Text(\n                    text = book.title,\n                    style = TextStyle(\n                        fontWeight = FontWeight.Bold,\n                        fontSize = 16.sp,\n                        color = (GlanceTheme.colors.onSurface),\n                    ),\n                )\n                if (size.height >= MyBooksAppWidget.MEDIUM_SQUARE.height) {\n                    Spacer(GlanceModifier.size(16.dp))\n                    Button(\n                        text = LocalContext.current.getString(R.string.widget_with_state_button),\n                        onClick = onClick\n                    )\n                }\n            }\n        }\n    }\n}\n```\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/1*WqumbHh4UZoC8ewJXXcvCw.gif\" />\n\n# 위젯 업데이트\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nGlance는 위젯 구성(my_book_widget_info)에서 정의된 간격에 따라 위젯 업데이트를 관리하지만 즉시 업데이트를 원하는 경우가 있을 수 있습니다.\n\nGlance는 이 수동 업데이트를 수행하는 편리한 방법을 제공합니다. 앱 로직 내부에서 MyBooksAppWidget().updateAll(context)를 간단히 호출하면 됩니다. 이 방법은 Glance에게 사용자 홈 화면의 위젯 모든 인스턴스를 업데이트하도록 지시하여 최신 정보를 반영합니다.\n\n# 위젯 홍보하기\n\n가치 있는 Glance 위젯을 만드는 것은 첫 번째 단계일 뿐입니다. 사용자가 이를 발견하고 활용할 수 있도록하기 위해서는 효과적인 홍보 전략을 구현하는 것이 중요합니다.\n내 앱에서는 현재 책을 다시 읽을 수 있도록 도와주는 위젯을 개발했습니다. 그러나 사용자가 이를 찾아보기 위해 위젯 목록을 활발히 찾아보지 않을 수도 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그래서 앱의 특정 지점에 위젯을 홍보하는 함수를 정의할 수 있습니다.\n\n```js\nfun promoteWidget(context: Context) {\n    val appWidgetManager = AppWidgetManager.getInstance(context)\n    val myProvider = ComponentName(context, MyBooksAppWidgetReceiver::class.java)\n    if (appWidgetManager.isRequestPinAppWidgetSupported) {\n        appWidgetManager.requestPinAppWidget(myProvider, null, null)\n    }\n}\n```\n\n만약 기기가 requestPinAppWidget 메소드를 지원하고 사용자 시스템이 허용한다면, 코드는 시스템에서 제공하는 하단 시트를 트리거할 것입니다. 해당 하단 시트는 사용자에게 위젯에 대해 안내하고 집 화면에 직접 추가할 수 있는 옵션을 제공할 것입니다. 이 접근 방식은 위젯 발견을 위한 매끄럽고 사용자 친화적인 경험을 제공합니다.\n\n결과물은 다음과 같을 것입니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![JetpackGlance_2](/assets/img/2024-06-23-JetpackGlance_2.png)\n\n# 결론\n\n이 기사는 Glance 위젯을 만드는 과정을 안내했습니다. 우리는 위젯의 기본 구조를 설정하는 과정을 탐구하고, 다양한 시나리오에 대한 레이아웃을 정의하며, 사용자 상호작용을 처리하는 방법을 이해했습니다. 추가로, 위젯을 홍보하고 사용자의 채택을 촉진하는 전략을 탐구했습니다.\n\n이 지식을 활용하여 자신만의 Glance 위젯을 만들어 보세요! 다양한 기능을 실험하고 어떻게 앱과 사용자에게 이점을 줄 수 있는지 탐색해보세요. 기억하세요, 핵심은 가치를 제공하고 훌륭한 사용자 경험을 제공하는 데 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n친구야! 댓글을 자유롭게 공유해 주세요. 또는 LinkedIn에서 연락해도 괜찮아요.\n\n좋은 하루 보내세요!\n","ogImage":{"url":"/assets/img/2024-06-23-JetpackGlance_0.png"},"coverImage":"/assets/img/2024-06-23-JetpackGlance_0.png","tag":["Tech"],"readingTime":16},{"title":"뉴욕 타임즈 크로스워드에 손글씨 인식 적용 실험","description":"","date":"2024-06-23 01:26","slug":"2024-06-23-ExperimentingwithHandwritingRecognitionforTheNewYorkTimesCrossword","content":"\n![이미지](/assets/img/2024-06-23-ExperimentingwithHandwritingRecognitionforTheNewYorkTimesCrossword_0.png)\n\n작성자: 샤픽 쿠라이쉬\n\n## 소개\n\n2023년 MakerWeek에서 시작된 뉴욕 타임스 매년 개최하는 해커톤에서 iOS 및 안드로이드 모바일 엔지니어들이 각 플랫폼에서 뉴욕 타임스 크로스워드 앱에 직접 손으로 쓰는 기능을 탐구했습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n참여한 실험의 안드로이드 엔지니어로서 안드로이드 크로스워즈에 On Device ML을 구현하면서 플랫폼별 경험을 기대하고 있습니다.\n\n참고: 이 탐색은 아직 출시되지 않은 후속 기능을 위한 것입니다.\n\n## 초기 설정 및 요구 사항\n\n![이미지](/assets/img/2024-06-23-ExperimentingwithHandwritingRecognitionforTheNewYorkTimesCrossword_1.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n뉴욕 타임스 크로스워드는 앱에 내장된 사용자 정의 소프트웨어 키보드를 갖고 있어요. 사용자가 키보드에서 글자를 입력하면 해당 사각형에 나타나요.\n\n손으로 쓰기를 가능하게 하기 위해, 우리가 먼저 해야 한 것은 실제로 사용자가 스타일러스나 손가락을 통해 텍스트를 수동으로 입력할 수 있도록 하는 것이었어요. 우리는 미니와 데일리 모두의 크로스워드 사각형마다 가져가서 '스케치박스'라고 불리는 사용자 정의 구성 요소로 변환했어요. 이 구성 요소는 사용자가 화면에 쓸 때 손가락이나 스타일러스로 그린 각 획을 캡처하고, 터치 및 드래그 이벤트를 감지하여 그린 글자 획을 표시하도록 특별히 설계되었어요.\n\n우리의 스케치박스가 캔버스로부터 얻은 결과 글자 픽셀을 캡처한 후, 그 데이터를 우리의 선택한 기계 학습 알고리즘에 전송할 수 있었어요.\n\n## 연필 타이밍\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-06-23-ExperimentingwithHandwritingRecognitionforTheNewYorkTimesCrossword_2.png\" />\n\n실제 필기 감지에 들어가기 전에, 섬세하지만 중요한 한 가지를 다룰 필요가 있습니다.\n\n사용자가 스케치박스에 쓰다 보면, 보통 손가락이나 스타일러스를 캔버스에서 떼곤 합니다, 특히 K, A, H 등과 같은 글자를 완성할 때 더욱 그렇습니다. 이것은 사용자가 각 획 사이에 정확히 언제 필기를 끝냈는지를 결정해야 한다는 것을 의미합니다. 예를 들어, 만약 사용자가 \"K\"의 줄기를 입력하면, 필기 도구를 캔버스에서 뗄 때 이 글자가 무엇일지 바로 감지하려고 하면 \"I\"로 해석될 수 있습니다.\n\n그렇다면 우리는 획 사이에서 얼마나 기다려야 할까요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저희 초기 구현에서는 뮤텍스와 유사한 입력 잠금 시스템 개념을 도입했습니다. 각 스트로크 사이에는 특정 조건에 따라 500에서 1000밀리초 사이의 값 실험을 진행했습니다. 스타일러스 잠금을 오랫동안 기다리고 싶지는 않았는데, 그렇게 되면 사용자 입력 경험이 떨어지고 버벅거릴 수 있습니다.\n\n이것은 우리가 필기 메커니즘을 설계할 때 고려해야 했던 많은 복잡성 중 하나이며, 향후 수정할 수 있는 부분입니다.\n\n## 데이터 준비, 조건부 및 정규화\n\n이미지를 텍스트로 변환하기 전에, 다양한 디바이스에서 다른 화면 크기와 해상도의 글자들이 입력되는 것을 고려해야 했습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n알고리즘이 정확한 학습을 위해 필요한 데이터의 가장 간단한 형태를 얻는 것을 포함한 중요한 전처리 단계가 포함되어 있습니다. 이미지 데이터의 경우 비필수적인 잡음과 \"주저하는 지오메트리\"를 제거하는 것을 의미합니다. 우리는 문자 데이터를 축소 및 이진화하고, 그런 다음 128x128 크기의 원시 입력 문자를 훨씬 작고 효율적이며 간소화된 28x28 이미지로 변환했습니다.\n\n![image](/assets/img/2024-06-23-ExperimentingwithHandwritingRecognitionforTheNewYorkTimesCrossword_3.png)\n\n그런 다음에야 우리는 라스터화된 캔버스 이미지 데이터를 우리의 교차 이력 앱이 이해하는 실제 문자로 어떻게 번역하는지에 대해 최종적으로 논의할 수 있었습니다.\n\n필기 인식은 광학 문자 인식(OCR) 내의 클래식한 기계 학습 과제입니다. 특히 1998년 Yann LeCun 박사의 LeNet-5 아키텍처로, Modified National Institute of Standards and Technology (MNIST) 데이터셋에서 digit 인식이 크게 향상되었습니다. MNIST 데이터셋에는 1부터 9까지의 다양한 숫자 변형이 수천개 포함되어 있으며, digit 인식의 대표적인 표준 데이터베이스입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 만들려고 했던 시스템의 고수준 아키텍처 다이어그램입니다:\n\n![아키텍처 다이어그램](/assets/img/2024-06-23-ExperimentingwithHandwritingRecognitionforTheNewYorkTimesCrossword_5.png)\n\n선택한 기계 학습 알고리즘은 문자 데이터를 인식 클러스터로 가장 잘 분리해주도록 의도되었습니다. 아래에서 이상적인 형태로 구분한다면 시스템이 사용자가 'A'를 입력하려는지, 예를 들어 'C'를 입력하려는지 쉽게 판단할 수 있게 되었을 것입니다. 이러한 목적을 달성할 수 있도록 우리는 다층 합성곱 신경망 아키텍처를 사용하기로 결정하기 전에 여러 다른 옵션들을 탐색했습니다. 여기에서는 그에 대해 자세히 다루지 않겠습니다. 결과적으로, 우리가 선택한 Deep Convolutional Neural Network 아키텍처는 임무에 충분히 부합한다는 것을 입증했습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/assets/img/2024-06-23-ExperimentingwithHandwritingRecognitionforTheNewYorkTimesCrossword_6.png)\n\n## 딥 컨볼루션 네트워크 구축하기\n\n깊은 CNN(컨볼루션 신경망)은 현대 이미지 기반 머신 러닝 시스템의 중추입니다. 이미지 데이터의 일부를 검토하고 학습 메커니즘을 사용하여 중요한 특징을 지능적으로 찾아 이미지를 식별하고 분류하는 데 도움이 되는 특수한 종류의 신경망입니다.\n\n![이미지](/assets/img/2024-06-23-ExperimentingwithHandwritingRecognitionforTheNewYorkTimesCrossword_7.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 예시에서 보면, 신경망은 새의 입력 이미지를 받아와 새와 관련된 다양한 질적 요소에 해당하는 구조물을 탐지합니다. 이는 프로그램을 처음부터 설계하기 어려운 사람이 이미지의 일부분이 빽, 눈, 부리의 가장자리, 내부 부리 기하학 등과 같은 다양한 특징을 감지할 수 있습니다.\n\n가장 중요한 특징을 사용하여, 이는 새를 보고 어떤 종류의 새인지 판별할 수 있습니다. 또한, 새가 날아가거나 바라보는 방향과 같은 것들도 판별할 수 있습니다 - 단, 네트워크가 적절하게 훈련되어 있어야 합니다. 우리는 사용자가 우리의 크로스워드 앱에 입력하는 글자들에도 같은 원리를 적용합니다.\n\n기본 CNN은 다음 기본적인 레이어들의 조합으로 이루어져 있습니다. 이러한 구조물을 지능적으로 혼합하여 적절한 매개변수와 함께 사용하면, 우리가 감지하지 못하는 이미지 요소는 거의 없습니다:\n\n- 합성곱 레이어는 모델이 특징을 자동으로 추출할 수 있도록 합니다\n- 맥스 풀링 레이어는 Conv 레이어에서 얻은 특징을 좁힙니다\n- ReLU 레이어는 비선형성을 도입하고 복잡한 패턴 구별을 가능하게 합니다\n- 드롭아웃 레이어는 네트워크의 과적합을 완화합니다\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-06-23-ExperimentingwithHandwritingRecognitionforTheNewYorkTimesCrossword_8.png\" />\n\n## TensorFlow Lite 및 모델 적재\n\n모델을 구축하는 것 외에도, 이를 기기에 전달하는 방법을 찾아야 했습니다. 저희는 Python으로 컴파일된 머신러닝 모델을 안드로이드 또는 iOS 기기에 설치하는 데 사용되는 모바일 프레임워크인 TensorFlow Lite를 선택했습니다.\n\n<img src=\"/assets/img/2024-06-23-ExperimentingwithHandwritingRecognitionforTheNewYorkTimesCrossword_9.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-06-23-뉴욕타임스크로스워드의필체인식실험_10.png\" />\n\n우리가 모델에 만족했을 때, 저희는 .tflite 파일로 컴파일하고 애플리케이션 안에 넣어서, 십자말 퍼즐 정사각형에서 오는 글씨 쓰기 이벤트를 청취하는 데 사용할 샤운트를 만들었습니다. 우리는 최종 결과에 만족할 때까지 서로 다른 모델과 구성을 여러 번 반복하여, 오직 100KB 가량의 학습된 파일로 변해 반영되었습니다 - 여기서는 공간을 고려해야 하는 모바일 애플리케이션에 적합합니다.\n\n## 숫자 인식\n\n전체 글자인식 문제에 접근하기 전, 우리는 간단히 시작하고 넘어갈 것으로 숫자인식 문제를 해결하기로 결정했습니다. 아래의 핵심 코드 섹션은 우리가 구현한 기본 CNN 설정을 제공합니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-06-23-ExperimentingwithHandwritingRecognitionforTheNewYorkTimesCrossword_11.png\" />\n\n## 첫 번째 Digit Based CNN 모델 실패: 무엇이 잘못되었을까요?\n\n<img src=\"/assets/img/2024-06-23-ExperimentingwithHandwritingRecognitionforTheNewYorkTimesCrossword_12.png\" />\n\nMNIST에서 얻은 풍부한 교육 데이터에도 불구하고, 우리의 인식 결과는 좋지 않았습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n훈련 데이터가 \"너무 완벽하다\"라고 판단했습니다. 숫자는 서로의 작은 변형만 있었고, 대부분은 상자의 중앙에 있었습니다.\n\n이 방법은 사람들이 교차 워드 퍼즐 칸에 데이터를 입력하는 방식이 아닙니다. 사람들은 서로 다른 필기 스타일과 문자를 칸 안팎에 비스듬히 배치하는 방법을 가지고 있습니다.\n\n해결하기 위해 잘 알려진 머신러닝 기술인 데이터 증강을 사용해야 했습니다.\n\n데이터 증강은 훈련 데이터의 비스듬하고 왜곡된 버전을 자동으로 생성하여 수동 조정과 비틀음이 필요하지 않도록 합니다. 이를 통해 초기 데이터 세트의 다양한 변형을 가능하게 하며 문자의 크게 비중심 버전을 포함할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Experimenting with Handwriting Recognition for The New York Times Crossword](/assets/img/2024-06-23-ExperimentingwithHandwritingRecognitionforTheNewYorkTimesCrossword_13.png)\n\n데이터 증강 기술을 적용하여, 우리는 데이터셋을 수천 개에서 중심에서 벗어나는 작은 이동, 회전, 확대/축소(어파인 변환 이라고도 함) 등을 적용하여 100만 개 이상의 샘플로 확장했습니다.\n\n## 숫자에 대한 데이터 증강 된 모델 성공\n\n![Experimenting Handwriting Recognition for The New York Times Crossword](/assets/img/2024-06-23-ExperimentingwithHandwritingRecognitionforTheNewYorkTimesCrossword_14.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 표를 마크다운 형식으로 변경하십시오.\n\n## 풀 브론 글자 인식으로 이동하기\n\n![image](/assets/img/2024-06-23-ExperimentingwithHandwritingRecognitionforTheNewYorkTimesCrossword_15.png)\n\n숫자 인식이 크로스워드에서 크게 개선되었다는 것을 확인할 수 있습니다. 이는 우리 작업에서의 중요한 성과입니다!\n\n이제 우리는 숫자를 해결했으니 다음 단계는 글자를 해결하는 것이었습니다. 이에는 26개의 소문자, 26개의 대문자 및 모든 변형이 포함됩니다. 이제 열 개의 숫자를 다루는 것이 아니라 62개의 문자를 처리해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nEMNIST 데이터세트 (데이터 소스: http://arxiv.org/abs/1702.05373)를 사용할 수 있어요. 이는 MNIST 세트의 확장 버전으로, 문자뿐만 아니라 숫자와 구두점까지 포함하고 있어요. 이를 통해 모델을 더 잘 훈련할 수 있어요.\n\n그러나 향상된 데이터세트를 사용하더라도 숫자에 특화된 모델만으로는 우리의 요구를 충족시키기에는 충분하지 않아요. 이는 직관적으로 놀랍지 않아요. 왜냐하면 숫자 인식 모델은 강력하지만, 문자를 보는 데 도입된 문자 구조의 확장된 다양성에 대해 충분히 \"지능적\"이지 않기 때문이죠.\n\n## 매개변수 최적화를 통한 모델의 하이퍼 강화\n\n우리 모델의 성능을 높이기 위해, 우리는 네트워크에 훨씬 더 많은 깊이를 추가했어요. 또한, 증강된 훈련/검증 데이터의 무작위 하위 집합을 사용하여 다양성을 확보하기 위해 Stratified K-Fold 교차 검증을 사용했어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리의 레이어가 최적으로 설계되었는지 확인하기 위해 무작위 매개변수 검색과 향상된 통계적 테스트를 사용했습니다. 이를 통해 모델의 최적 하이퍼파라미터를 찾는 데 성공했습니다. 이는 이전에 올바른 매개변수를 추측했던 우리의 전략보다 발전된 것으로 나타났습니다.\n\n테스트 단계에서 우리는 증강된 EMNIST 데이터셋에서 약 91%의 평균 검증 정확도를 달성했습니다. 이는 우리 모델이 작동할 것이라는 신뢰를 주었습니다.\n\n마침내: 성공!\n\n![이미지](/assets/img/2024-06-23-ExperimentingwithHandwritingRecognitionforTheNewYorkTimesCrossword_16.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n기계 학습 모델 구축의 풍경을 탐험한 긴 여정 끝에 우리는 드디어 작동하는 크로스워드 모델에 도착했어요. 이는 정말 흥미로운 일이었죠. 우수한 결과를 이루었지만, 완벽한 크로스워드 경험을 위해 아직 해야 할 일이 많습니다. 부분적 글자 처리 및 불규칙한 간격으로 띄워진 글자들도 다루어야 합니다.\n\n## 결론\n\n안드로이드 크로스워드 앱에 필기 인식 기능을 구현하는 것은 실험적인 맥락에서도 흥미진진한 모험이었습니다. 필기 인식 외에도 “스크립 투 지우기” 감지와 같은 상호 작용 기능, 앱 내 자기 학습 메커니즘 가능성과 On-Device ML이 게임 앱에서 여는 다양한 문을 통해 가능성이 있습니다.\n\n새로운 기술과 기존 제품에 대한 강화를 실험해 볼 기회를 가지는 것은 타임즈에서 엔지니어로 일하는 것이 독특하고 가치 있는 이유의 핵심입니다. 우리는 언젠가 현재 사용자들을 위한 게임 경험을 강화하고 새 구독자를 유치하는 기능으로 발전시키는 날이 오기를 희망합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n샤피크 쿠라이시는 뉴욕 타임스의 게임 팀에서 시니어 안드로이드 엔지니어로 일하고 있어요. 그는 머신 러닝과 인공 지능에 열정을 가지고 있어요. 업무 외에는 기타 연주, 글쓰기, 그리고 독특한 실험을 하는 것을 즐기고 있어요.\n","ogImage":{"url":"/assets/img/2024-06-23-ExperimentingwithHandwritingRecognitionforTheNewYorkTimesCrossword_0.png"},"coverImage":"/assets/img/2024-06-23-ExperimentingwithHandwritingRecognitionforTheNewYorkTimesCrossword_0.png","tag":["Tech"],"readingTime":13},{"title":"안드로이드에서 공유 ViewModel의 내부 메커니즘 이해하기","description":"","date":"2024-06-23 01:24","slug":"2024-06-23-TheInternalMechanismofSharedViewModelinAndroid","content":"\n![이미지](/assets/img/2024-06-23-TheInternalMechanismofSharedViewModelinAndroid_0.png)\n\n# 안드로이드에서의 Shared ViewModel이란 무엇인가요?\n\n안녕하세요! 여러분은 앱의 다양한 부분을 데이터를 계속 주고받는 모든 번거로움 없이 동기화하는 방법을 궁금해 하신 적이 있나요? 그려면 Shared ViewModel을 소개할게요. 이는 앱 구성 요소를 위한 그룹 채팅처럼 작동합니다. 개별 메시지를 주고받는 대신에 모두가 자동으로 함께 유지됩니다. 정말 편리하죠?\n\n# Shared ViewModel은 어떻게 작동하나요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n당신이 서프라이즈 파티를 준비하고 있다고 상상해보세요. 여러 명의 친구들(당신의 조각들)이 계획에 대한 변경 사항마다 각각에게 전화를 걸지 않고도 업데이트를 유지해야 합니다. 이 때 공유된 ViewModel이 등장합니다. 이는 모두가 동일한 페이지에 머무를 수 있도록하는 마스터 파티 플래너와 같은 역할을 합니다.\n\n## 단계 1: 마스터 플래너(ViewModelProvider)\n\nViewModelProvider은 마스터 파티 플래너와 같습니다. 파티 세부 정보(ViewModel)를 요청하면 이미 계획이 있는지 확인합니다. 있으면 제공하고, 그렇지 않으면 새로운 계획을 작성합니다.\n\n다음은 ViewModel을 가져오는 방법입니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nval viewModel = ViewModelProvider(requireActivity()).get(SharedViewModel::class.java)\n```\n\nrequireActivity()을 사용하면 ViewModel이 해당 activity의 모든 fragment들 사이에서 공유됩니다. 이는 파티 준비 위원회 전체를 위한 한 곳의 중앙 그룹 채팅을 가지는 것과 같습니다.\n\n## 단계 2: 저장 공간 (ViewModelStore)\n\n뒷면에는 모든 계획(ViewModels)이 보관되는 저장 공간(ViewModelStore)이 있습니다. 이 방은 활동의 수명주기에 묶여 있습니다. 따라서 활동이 살아있는 한 계획은 안전하게 보관됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 단계 3: 계획의 수호자(ViewModelStoreOwner)\n\nViewModelStoreOwner은 보관실의 열쇠 소유자와 같습니다. 활동(Activity) 및 프래그먼트(Fragment)는 이 인터페이스를 구현하며, 공유된 계획에 접근할 수 있도록 보장합니다.\n\n다음은 활동에서의 사용 예시입니다:\n\n```java\npublic class MainActivity extends AppCompatActivity implements ViewModelStoreOwner {\n    private ViewModelStore mViewModelStore = new ViewModelStore();\n\n    @Override\n    public ViewModelStore getViewModelStore() {\n        return mViewModelStore;\n    }\n\n    @Override\n    protected void onDestroy() {\n        super.onDestroy();\n        mViewModelStore.clear(); // 활동이 종료될 때 ViewModelStore를 비움\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 단계 4: 모두가 최신 상태 유지하기 (데이터 공유)\n\n모든 조각들이 동일한 그룹 채팅(ViewModel)의 일부이기 때문에 어떠한 변경 사항이 있더라도 자동으로 최신 상태를 유지합니다. 각 친구에게 개별적으로 전화할 필요가 없습니다.\n\n실제 작동 방식은 다음과 같습니다:\n\n```js\nclass SharedViewModel : ViewModel() {\n    val data = MutableLiveData<String>()\n}\n\nclass FirstFragment : Fragment() {\n    private lateinit var viewModel: SharedViewModel\n\n    override fun onCreateView(\n        inflater: LayoutInflater, container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): View? {\n        viewModel = ViewModelProvider(requireActivity()).get(SharedViewModel::class.java)\n        viewModel.data.observe(viewLifecycleOwner, Observer { data ->\n            // 새 데이터로 UI 업데이트\n        })\n        return inflater.inflate(R.layout.fragment_first, container, false)\n    }\n}\n\nclass SecondFragment : Fragment() {\n    private lateinit var viewModel: SharedViewModel\n\n    override fun onCreateView(\n        inflater: LayoutInflater, container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): View? {\n        viewModel = ViewModelProvider(requireActivity()).get(SharedViewModel ::class.java)\n        viewModel.data.observe(viewLifecycleOwner, Observer { data ->\n            // 새 데이터로 UI 업데이트\n        })\n        return inflater.inflate(R.layout.fragment_second, container, false)\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nFirstFragment이 viewModel.data를 업데이트하면, SecondFragment도 업데이트를 받습니다. 마치 한 친구가 그룹 채팅에 글을 올리면 모두가 즉시 메시지를 받는 것처럼 동작합니다.\n\n# 요약\n\n그래서 Shared ViewModel의 마법입니다! ViewModelProvider, ViewModelStore, ViewModelStoreOwner를 사용하여 추가 노력 없이 모든 fragment를 동기화 상태로 유지합니다. 항상 모두가 같은 페이지에 있는지 확인하는 수퍼 체계적인 파티 플래너가 있는 것처럼 동작합니다. 추가 질문이 있거나 더 깊이 파고들고 싶으시면 언제든지 알려주세요. 즐거운 코딩하세요! 😊\n","ogImage":{"url":"/assets/img/2024-06-23-TheInternalMechanismofSharedViewModelinAndroid_0.png"},"coverImage":"/assets/img/2024-06-23-TheInternalMechanismofSharedViewModelinAndroid_0.png","tag":["Tech"],"readingTime":5},{"title":"Coroutines, RxJava, Executor 뭐가 더 빠를까 각 작업별 성능 비교","description":"","date":"2024-06-23 01:21","slug":"2024-06-23-WhatisfasterandinwhichtasksCoroutinesRxJavaExecutor","content":"\n<img src=\"/assets/img/2024-06-23-WhatisfasterandinwhichtasksCoroutinesRxJavaExecutor_0.png\" />\n\n저는 가끔 다중 스레딩 프레임워크 중 어떤 것이 제일 빠른지 궁금했던 적이 있었어요. 어느 날 운명이 저를 이 질문을 조사하도록 이끌었죠. 만약 여러분도 궁금하시다면, 전 테스트를 해보고 비교한 결과를 여러분과 공유해 보았습니다.\n\n# 문제\n\n우선, 왜 이를 해보게 되었는지부터 알아봅시다. 제게는 간단한 작업이 있었어요: 수백 개의 콜백을 호출하는 시스템이 있었죠. 모든 콜백은 가능한 빨리 완료되어야 했죠.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n각 콜백에 소요되는 복잡성이나 시간을 알지 못했어요. 콜백은 객체를 생성하거나 서버나 데이터베이스에 긴 요청을 할 수도 있어요. 이 경우에는 데이터베이스나 서버에 요청하기 때문에 멀티스레딩을 사용해야 하죠.\n\n이 문제를 해결하려고 할 때, 어떤 상황에서 어떤 멀티스레딩 프레임워크가 더 빠른지 정확히 모르는 것을 깨달았어요.\n\n# 동기부여\n\n하지만 당장 떠오르는 질문이 있죠: \"아직 아무도 테스트해보지 않은 건가요?\" 의외로 제 요구사항을 충족시키는 테스트를 찾을 수 없었어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n일부 테스트는 Rx 대 Coroutines와 같이 두 기술 간의 간단한 비교였습니다. 다른 일부는 내 의견으로는 너무 구체적한 테스트 케이스를 가졌는데, 예를 들어 산술 연산이나 데이터베이스 요청만을 테스트하는 것 등이 그러했습니다.\n\n어쨌든, 이에 대해 매우 만족스럽지 않았고 나만의 테스트를 하기로 결정했습니다.\n\n멀티스레드 프레임워크의 모든 사용 사례를 커버할 수는 없다는 것은 합리적입니다. 내 작업과 관련이 있는 것들만 테스트할 것입니다... 그래서 이게 완벽한 테스트가 아니지만 꽤 철저할 것입니다.\n\n# 도구\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n측정 도구로 시작해 봅시다. 안드로이드 개발자이기 때문에 안드로이드 도구를 사용하겠습니다. 이론적으로는 컴퓨터에서 JVM에서 멀티스레딩 테스트를 실행하는 것이 안드로이드 장치에서 실행하는 것과 다를 수 있지만, 실제로는 큰 차이가 없으며 전체 테스트 결과에 영향을 미치지 않습니다.\n\n그리고 안드로이드 장치에서 코드 성능을 테스트하기 위해 사용할 수 있는 Jetpack Microbenchmark 도구가 있습니다.\n\nMicrobenchmark 측정 테스트는 보통의 인스트루먼테이션 테스트와 유사하지만, 차이점은 BenchmarkRule이라는 특정 Rule을 사용한다는 것뿐입니다.\n\n```js\n@get:Rule\nval benchmarkRule = BenchmarkRule()\n\n@Test\nfun sampleTest() {\n   benchmarkRule.measureRepeated {\n       // 여기에서 측정할 것입니다\n   }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n결과적으로 실행에 대한 정보가 포함된 JSON을 얻게 됩니다: 최소 및 최대 시간, 그리고 가장 중요한 중앙값 시간.\n\n```js\n    \"benchmarks\": [\n        {\n            \"name\": \"sampleTest\",\n            \"params\": {},\n            \"className\": \"com.test.benchmark.ExampleBenchmark\",\n            \"totalRunTimeNs\": 85207217833,\n            \"metrics\": {\n                \"timeNs\": {\n                    \"minimum\": 9.82149833E8,\n                    \"maximum\": 1.019338584E9,\n                    \"median\": 1.004151917E9,\n                    \"runs\": [...]\n                },\n                \"allocationCount\": {\n                    \"minimum\": 324.0,\n                    \"maximum\": 324.0,\n                    \"median\": 324.0,\n                    \"runs\": [...]\n                }\n            },\n            \"sampledMetrics\": {},\n            \"warmupIterations\": 3200,\n            \"repeatIterations\": 5000,\n            \"thermalThrottleSleepSeconds\": 0\n        }\n    ]\n```\n\n이 JSON은 반복 횟수, 객체 할당 횟수 등을 포함한 기타 정보를 담고 있습니다. 현재는 이것이 우선 순위가 아닙니다.\n\n# 벤치마크 테스트 케이스\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n프레임워크 간 주요 차이점은:\n\n- 단일 스레드 생성에 소요되는 시간\n- 프레임워크가 작업을 효율적이고 빠르게 스레드 간에 분배할 수 있는 능력\n\n우리는 이러한 프레임워크 간 차이를 평가하기 위해 테스트 케이스 결과를 탐색할 것입니다.\n\n이제 우리는 무엇을 테스트하고 싶은지 결정해야 합니다. 테스트 데이터부터 시작해봅시다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 테스트 데이터\n\n별거 아닌 거에요. 0부터 99까지 범위의 100개 항목을 포함하는 ArrayList를 만들어봤어요.\n\n```kotlin\nprivate fun createTestList(): List<Int> {\n   return List(100) { it }\n}\n```\n\n그런 다음 각 항목에 대해 몇 가지 작업을 수행할 거예요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 테스트 케이스를 살펴보겠습니다.\n\n# 단일 스레드\n\n단일 스레드 테스트 케이스부터 시작해 보죠. 이러한 테스트 케이스의 결과를 비교할 때는 프레임워크가 단일 스레드를 생성하는 데 걸리는 시간을 주의 깊게 살펴볼 것입니다. 하나의 스레드만 있는 경우, 프레임워크가 스레드를 초기화하고 생성하는 데 걸리는 시간을 확인할 수 있습니다.\n\n## 직접 호출\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n첫 번째 테스트 케이스는 간단히 메서드를 직접 호출하는 것입니다. 어떤 프레임워크도 사용하지 않습니다.\n\n```kotlin\n@Test\nfun directInvoke() {\n   val list = createTestList()\n   benchmarkRule.measureRepeated {\n       list.forEach { action(it) }\n   }\n}\n```\n\n## RxJava\n\n두 번째 테스트 케이스는 Rx입니다. Completable 내에서 작업을 수행할 것입니다. 각 작업에 대해 별도의 Completable이 생성될 것입니다. Scheduler는 모든 작업이 단일 스레드에서 실행되도록 보장하는 Scheduler.single이 될 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그리고 작업 완료를 기다려야 하기 때문에 결과 Completable에서 blockingAwait를 호출합니다.\n\n```kotlin\n@Test\nfun rxOne() {\n   val list = createTestList()\n   val scheduler = Schedulers.single()\n   benchmarkRule.measureRepeated {\n       val completables = list.map {\n           Completable.fromAction {\n               action(it)\n           }.subscribeOn(scheduler)\n       }\n       Completable.merge(completables).blockingAwait()\n   }\n}\n```\n\n## 코틀린 코루틴\n\n어딜 가나 젊고 유망한 코틀린 코루틴 프레임워크가 없었던 우리들이 어디에 있겠어요? 코루틴이 실행될 때까지 기다리려면 async를 통해 작업을 실행하고 완료를 기다리기 위해 await을 사용합니다. 따라서 각 작업을 위한 별도의 코루틴이 있을 것입니다. 모든 것을 단일 스레드에서 실행하도록 하려면 단순히 runBlocking을 사용하면 됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kt\n@Test\nfun coroutineOne() {\n   val list = createTestList()\n   benchmarkRule.measureRepeated {\n       runBlocking {\n           list.map {\n               async {\n                   action(it)\n               }\n           }.forEach { it.await() }\n       }\n   }\n}\n```\n\n## Kotlin Flow\n\nFlow에서 비교해보겠습니다. 코루틴과 Rx를 직접적으로 비교하는 것은 좋은 방법이 아닐 수 있습니다. 둘 다 다른 방식으로 사용되고 다른 개념을 적용하기 때문에 멀티쓰레딩과 관련이 있다고 해도 다릅니다.\n\n각 액션에 대한 Flow를 생성하고 모두 결합한 다음 간단히 수집합니다. 각 액션에 대해 별도의 Flow가 있을 것입니다. 한편, 디스패처를 어디에도 지정하지 않았기 때문에 모든 작업이 동일한 스레드에서 수행됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\n@Test\nfun flowOne() {\n   val list = createTestList()\n   benchmarkRule.measureRepeated {\n       runBlocking {\n           val flows = list.map {\n               flow {\n                   val result = action(it)\n                   emit(result)\n               }\n           }\n           flows.merge().collect()\n       }\n   }\n}\n```\n\n# 스레드 수는 CPU 스레드 수와 같음\n\n물론, 한 스레드만 사용하는 것은 최선의 선택처럼 보이지 않습니다. 왜냐하면 멀티스레딩을 위한 프레임워크가 있기 때문이죠.\n\n스레드 풀에 있는 스레드 수가 CPU 스레드 수와 같은 상황을 고려해 봅시다. 이상적으로는 이러한 테스트 케이스의 결과를 비교하여 두 번째 차이(프레임워크가 작업을 효율적으로 빠르게 스레드 간에 분배하는 능력)를 볼 수 있습니다. 각 작업에 대해 충분한 스레드가 없기 때문에 프레임워크가 그런 작업들을 어쨌든 분배해야 하게 될 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n프로세서 코어 간 작업의 균등한 분배를 기대해서는 안 됩니다. 운영 체제와 CPU가 결정하는 것은:\n\n- 무엇이 실행되는지,\n- 언제 실행되는지,\n- 누가 실행하는지입니다.\n\n현대의 \"큰\" CPU는 SMT/HyperThreading을 사용하여 각 CPU 코어마다 여러 논리 스레드를 생성할 수 있습니다. CPU 코어는 독립적으로 명령을 실행할 수 있는 물리적 단위입니다. 반면 스레드는 한 코어에서 실행할 수 있는 논리적 소프트웨어 단위입니다. 또한 이동형 CPU와 최신 인텔 CPU는 다양한 유형의 CPU 코어를 사용합니다. 대형 코어는 복잡한 작업에 적합하며, 중형 및 절전 코어는 성능에서 상당히 차이가 있습니다.\n\n그래서, 우리는 이 풀을 적은 수의 스레드를 갖는 풀로 간주할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nCPU 쓰레드 수를 결정하는 훌륭한 방법이 있어요:\n\n```js\nRuntime.getRuntime().availableProcessors();\n```\n\n제 테스트 기기에서는 이 값이 여덟이에요.\n\n## RxJava\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nRx를 시작해보겠습니다. Rx에는 원하는 동작을 구현하는 Scheduler.Computation이 있어요. 사실 코드는 단일 스레드를 사용할 때와 똑같이 유지됩니다. 유일한 차이점은 각 개별 Completable에 대해 Scheduler.computation()을 사용하여 subscribeOn을 만든다는 것이에요.\n\n```kotlin\n@Test\nfun rxCPU() {\n   val list = createTestList()\n   val scheduler = Schedulers.computation()\n   benchmarkRule.measureRepeated {\n       val completables = list.map {\n           Completable.fromAction {\n               action(it)\n           }.subscribeOn(scheduler)\n       }\n       Completable.merge(completables).blockingAwait()\n   }\n}\n```\n\n## Kotlin 코루틴\n\n이제 코루틴을 살펴보죠. Dispatchers.Default라는 것을 가지고 있어요. 해당 문서에는:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n기본적으로 \"병렬성\"의 최대 수준은 CPU 코어 수와 동일합니다. 우리가 필요한 것이 바로 그겁니다.\n\n코드는 싱글 코어 버전과 유사합니다. 이제 액션들은 Dispatchers.Default 내부에서 withContext를 사용하여 실행됩니다.\n\n```js\n@Test\nfun coroutineCPU() {\n   val list = createTestList()\n   val dispatcher = Dispatchers.Default\n   benchmarkRule.measureRepeated {\n       runBlocking {\n           list.map {\n               async {\n                   withContext(dispatcher) {\n                       action(it)\n                   }\n               }\n           }.forEach { it.await() }\n       }\n   }\n}\n```\n\n하지만 중요한 세부 사항이 있습니다... Dispatchers.Default를 좀 더 자세히 살펴보면이 생성자를 찾을 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\n내부 객체 DefaultScheduler는 SchedulerCoroutineDispatcher를 상속합니다(\n   CORE_POOL_SIZE, MAX_POOL_SIZE,\n   IDLE_WORKER_KEEP_ALIVE_NS, DEFAULT_SCHEDULER_NAME\n)\n```\n\nCPU 스레드 수인 CORE_POOL_SIZE와 MAX_POOL_SIZE(이 경우 200만이라고합니다) 두 개의 상수를 전달하는 것이 의심스럽습니다.\n\n더 자세히 조사해보니 이러한 변수들은 CoroutineScheduler를 만들기 위해 사용된다는 것을 알 수 있습니다.\n\n```kotlin\nprivate fun createScheduler() = CoroutineScheduler(\n   corePoolSize, maxPoolSize, idleWorkerKeepAliveNs, schedulerName\n)\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그리고 문서에는 다음과 같이 나와 있습니다:\n\n그래서 Dispatchers.Default는 CPU 스레드 수에 제한 받지 않습니다.\n\nDispatchers.Default와 Scheduler.Computation을 직접 비교하는 것은 잘못된 접근입니다. 경우에 따라 Dispatchers.Default는 추가적인 스레드를 사용할 수 있습니다. 다행히 문서는 비교를 더 공정하게 하기 위한 정보도 제공합니다. 단순히 LimitingDispatcher를 사용하면 됩니다. 이를 위해 Dispatchers.Default의 limitedParallelism 메서드를 CPU 스레드 수와 함께 호출하면 됩니다.\n\n```js\n@Test\nfun coroutineCPULimit() {\n   val list = createTestList()\n   val threadCount = Runtime.getRuntime().availableProcessors()\n   val dispatcher = Dispatchers.Default.limitedParallelism(threadCount)\n   benchmarkRule.measureRepeated {\n       runBlocking {\n           list.map {\n               async {\n                   withContext(dispatcher) {\n                       action(it)\n                   }\n               }\n           }.forEach { it.await() }\n       }\n   }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 코틀린 Flow\n\nflow에 대해 동일한 작업을 합시다. Dispatchers.Default를 사용하세요.\n\n```js\n@Test\nfun flowCPU() {\n   val list = createTestList()\n   val dispatcher = Dispatchers.Default\n   benchmarkRule.measureRepeated {\n       runBlocking {\n           val flows = list.map {\n               flow {\n                   val result = action(it)\n                   emit(result)\n               }.flowOn(dispatcher)\n           }\n           flows.merge().collect()\n       }\n   }\n}\n```\n\n그리고 제한을 두고 Dispatchers.Default를 사용하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n@Test\nfun flowCPULimit() {\n   val list = createTestList()\n   val threadCount = Runtime.getRuntime().availableProcessors()\n   val dispatcher = Dispatchers.Default.limitedParallelism(threadCount)\n   benchmarkRule.measureRepeated {\n       runBlocking {\n           val flows = list.map {\n               flow {\n                   val result = action(it)\n                   emit(result)\n               }.flowOn(dispatcher)\n           }\n           flows.merge().collect()\n       }\n   }\n}\n```\n\n## Java Executor\n\n코루틴의 모든 복잡성을 탐구해야 했기 때문에, 이러한 복잡성을 사용해볼까요? 따라서 Executor를 사용해보려고 합니다.\n\n먼저, Executors.newFixedThreadPool을 사용하여 Executor를 생성해 보겠습니다. 이렇게 함으로써, 단순히 쓰레드 수로 제한된 Executor가 생성되며, 우리의 경우에는 CPU 코어의 수입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nmeasureRepeated 메소드 이전에 Executor를 생성하니 Executor를 만드는 것은 쉬운 작업이 아닙니다. 그런 다음, 작업을 수행하는 Executor에서 submit을 호출합니다. 완료를 기다리기 위해 get 메소드를 사용해 보겠습니다.\n\n```js\n@Test\nfun executorFixedCPU() {\n   val list = createTestList()\n   val threadCount = Runtime.getRuntime().availableProcessors()\n   val executorService = Executors.newFixedThreadPool(threadCount)\n   benchmarkRule.measureRepeated {\n       val futures = list.map { executorService.submit { action(it) } }\n       futures.forEach { it.get() }\n   }\n}\n```\n\nExecutors.newWorkStealingPool 메소드를 사용하여 관심 있는 두 번째 유형의 Executor를 생성할 것입니다. 실제로, 이 또한 제한된 수의 스레드로 Executor를 생성합니다. 그러나 메소드 이름에 \"Stealing\"이 포함된 것은 우연이 아닙니다. 이 Executor의 스레드는 현재 스레드가 비어 있어 다른 스레드에게 큐에 대기 중인 작업이 있는 경우 현재 스레드가 idle 상태가 되었을 때 다른 스레드로부터 작업을 훔칠 수 있습니다. 이는 최종적으로 공통 큐를 비울 수 있도록 도와줄 수 있습니다.\n\n코드적으로는 이전과 동일합니다. 단, Executor를 만드는 방법이 다를 뿐입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\n@Test\nfun executorStealCPU() {\n   val list = createTestList()\n   val threadCount = Runtime.getRuntime().availableProcessors()\n   val executorService = Executors.newWorkStealingPool(threadCount)\n   benchmarkRule.measureRepeated {\n       val futures = list.map { executorService.submit { action(it) } }\n       futures.forEach { it.get() }\n   }\n}\n```\n\n# 각 작업에 대한 스레드\n\n이제 거의 무제한(실제로는 많은 수, 많다고 할 정도)으로 스레드를 할당하는 가능성을 탐색해 보겠습니다. 100개의 작업만 있기 때문에 100개의 스레드를 할당할 수 있습니다. 더 이상 필요하지 않습니다.\n\n## RxJava\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nRx를 시작합니다. Scheduler.io는 이러한 역할을 맡습니다. Scheduler.io에는 스레드 캐시가 있습니다. 사용 가능한 빈 스레드가 있다면 캐시에서 하나를 가져옵니다. 그렇지 않으면 새로운 스레드를 생성합니다. 코드는 Scheduler.computation과 동일하지만 다른 스케줄러를 사용합니다.\n\n```js\n@Test\nfun rxIo() {\n   val list = createTestList()\n   val scheduler = Schedulers.io()\n   benchmarkRule.measureRepeated {\n       val completables = list.map {\n           Completable.fromAction {\n               action(it)\n           }.subscribeOn(scheduler)\n       }\n       Completable.merge(completables).blockingAwait()\n   }\n}\n```\n\n## Kotlin 코루틴\n\n코루틴에서 유사한 작업은 Dispatchers.IO의 책임이므로 익숙한 코드에 삽입하기만 하면 됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\n@Test\nfun coroutineIo() {\n   val list = createTestList()\n   val dispatcher = Dispatchers.IO\n   benchmarkRule.measureRepeated {\n       runBlocking {\n           list.map {\n               async {\n                   withContext(dispatcher) {\n                       action(it)\n                   }\n               }\n           }.forEach { it.await() }\n       }\n   }\n}\n```\n\n## Kotlin Flow\n\nRepeat the same for Flow.\n\n```kotlin\n@Test\nfun flowIo() {\n   val list = createTestList()\n   val dispatcher = Dispatchers.IO\n   benchmarkRule.measureRepeated {\n       runBlocking {\n           val flows = list.map {\n               flow {\n                   val result = action(it)\n                   emit(result)\n               }.flowOn(dispatcher)\n           }\n           flows.merge().collect()\n       }\n   }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 자바 Executor\n\n안타깝게도 Executor는 그다지 좋은 API가 없어요. 따라서 우리는 그에게 100개의 스레드를 할당할 거예요. 100개의 작업만 있으면 충분하니까 더 많이 필요하지 않을 거에요.\n\n```kotlin\n@Test\nfun executorFixedIo() {\n   val list = createTestList()\n   val executorService = Executors.newFixedThreadPool(100)\n   benchmarkRule.measureRepeated {\n       val futures = list.map { executorService.submit { action(it) } }\n       futures.forEach { it.get() }\n   }\n}\n```\n\nnewWorkStealingPool도 같은 방식으로 할 거에요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\n@Test\nfun executorStealIo() {\n   val list = createTestList()\n   val executorService = Executors.newWorkStealingPool(100)\n   benchmarkRule.measureRepeated {\n       val futures = list.map { executorService.submit { action(it) } }\n       futures.forEach { it.get() }\n   }\n}\n```\n\n이것은 모든 테스트 케이스를 프레임워크별로 나열한 표입니다.\n\n<img src=\"/assets/img/2024-06-23-WhatisfasterandinwhichtasksCoroutinesRxJavaExecutor_1.png\" />\n\n그리고 마지막으로, 테스트를 실행합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 테스트\n\n하하, 조금 속았죠. 먼저, 행동의 카테고리를 고려해 봅시다.\n\n이 중에 단 5가지가 있습니다:\n\n- 산술 — 간단한 산술 연산;\n- listsManipulation — 객체 조작;\n- 저장 — 저장소와의 작업 시뮬레이션;\n- 네트워크 — 네트워크와의 작업 시뮬레이션;\n- 혼합 — 이전 스크립트 모두의 조합, 원본 작업에서 행동의 복잡성을 알 수 없기 때문에.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n간단한 것부터 시작해 봅시다.\n\n# 산술\n\n제가 여러분에게 상기시키고 싶은 점은 0부터 99까지의 각 항목에 대해 작업을 수행할 것이라는 것입니다. 이 경우 연산을 조금 더 복잡하게 만들기 위해 숫자를 Float로 변환하고 해당 숫자를 그 자신의 값의 제곱으로 올립니다. 0의 제곱부터 99의 제곱까지입니다. 물론 어느 시점에서는 Float의 한계에 도달하겠지만, 괜찮습니다.\n\n```js\nprivate fun arithmetic(seed: Int): Int {\n   return seed.toFloat().pow(seed.toFloat()).toInt()\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n일반적으로, 이 범주로 분류할 수 있는 작업에는 생성자를 사용하여 객체를 생성하거나 속성에 액세스하는 것이 포함됩니다. 이러한 작업은 완료하는 데 오랜 시간이 걸리지 않습니다.\n\n결과는 무엇인가요?\n\n![그림](/assets/img/2024-06-23-WhatisfasterandinwhichtasksCoroutinesRxJavaExecutor_2.png)\n\n예상대로, directInvoke가 최고의 결과를 보였습니다. 가장 가까운 경쟁 상대보다 70배 빨랐습니다. 이는 이러한 작업이 매우 간단하며 멀티스레딩 프레임워크를 사용하는 데 추가적인 오버헤드가 작업 자체 비용의 10배 더 높을 수 있다는 이치를 따랐기 때문입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그러나 뜻밖의 충격은 두 번째와 세 번째 자리에서 일어났습니다. 두 자리 다 Executors로 고정된 스레드 수를 가진 것들이었어요. 처음에는 directInvoke가 제일일 것으로 예상했는데, 그 다음에는 단일 스레드의 테스트 케이스, 그리고 CPU, 그리고 마지막으로 IO가 실행될 것으로 기대했어요. 그런데 고정된 스레드 수를 가진 Executors가 이러한 로직을 완전히 무너뜨리는 모습을 볼 수 있었어요. 한편으로는 Executors.newWorkStealingPool을 이용하여 만든 Executor는 \"무한\" 스레드 수를 가질 때 성능이 더 좋아 보입니다.\n\nDispatchers.Default를 한정하고 한정하지 않았을 때의 시간이 다른 것을 볼 수 있습니다. 그래서 한정을 한 이유가 있습니다.\n\n하나의 동작을 처리하는 데 가장 많은 오버헤드를 가진 것은 Flow입니다. 모든 경쟁자들보다 느립니다. 그리고 코루틴은 한 스레드에서 Rx보다 나은 경우가 있지만, 스레드 수가 증가할수록 Rx가 선두 주자로 우뚝 서는 것을 볼 수 있습니다.\n\n요약하면, 이 카테고리의 동작에서 directInvoke가 가장 효과적임을 알 수 있습니다. 따라서 이러한 작업에는 멀티스레딩 프레임워크를 사용하지 않는 것이 더 나은 방법입니다. 대신에 하나의 스레드나 적은 수의 스레드를 가진 풀을 사용하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 리스트 조작\n\n자, 이제 더 복잡한 내용을 살펴보겠습니다 — 객체 조작입니다. 객체를 리스트에 추가하면 객체를 다루기가 더 쉬워집니다. 이 카테고리의 작업에는 예를 들어 POJO 매핑이 포함될 수 있습니다.\n\n작업 내에서 우리는 매개변수로 받은 숫자와 같은 크기를 갖는 새로운 리스트를 만들기만 하면 됩니다. 다음으로 몇 가지 작업을 수행하고, 리스트를 맵으로 변환한 다음 다시 몇 가지 작업을 수행한 후 이 컬렉션을 필터링합니다... 일반적으로 리스트를 조작합니다.\n\n이곳에서의 복잡성 기본은 실제 작업 그 자체가 아닙니다. 이것은 정규 불변 리스트이며, 시퀀스가 아닙니다. 이것은 각 작업 후 새로운 리스트가 생성된다는 것을 의미합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\nprivate fun listsManipulation(seed: Int): Int {\n    List(seed) { it }\n        .map { it.toFloat() }\n        .map { it + 0.3f }\n        .associateBy { it.toString() }\n        .mapValues { it.value * it.value }\n        .filter { it.value > 5f }\n    return seed\n}\n```\n\n어땠어요?\n\n![image](/assets/img/2024-06-23-WhatisfasterandinwhichtasksCoroutinesRxJavaExecutor_3.png)\n\ndirectInvoke는 빠르게 선두에서 물러났어요. 객체 조작 같은 기본 작업조차 어려움이 있군요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nExecutor를 생성하여 리드가 됩니다. Executors.newWorkStealingPool을 사용하면 더 효율적입니다. 간단한 대안인 Executors.newFixedThreadPool보다 더욱 효율적입니다.\n\nRx는 조금 앞으로 나아갑니다. 앞에는 Scheduler.computation이 있습니다. 원칙적으로 이 작업에 대한 우선 선택지입니다. 왜냐하면 더 적은 자원을 사용하기 때문입니다.\n\n단일 스레드 테스트 케이스는 목록의 끝에 있지만, directInvoke는 여전히 중간에 남아 있습니다.\n\nflowCPU와 coroutineCPU는 목록의 맨 아래에 있습니다. 이러한 테스트 케이스들은 CPU 코어의 수와 같은 수의 스레드를 가지고 있으며 제한이 없습니다. 테스트를 다시 실행했지만 결과는 동일했습니다. 버그가 있을 수 있다고 생각하여 코루틴을 업데이트했지만 변한 점은 없습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n총론적으로, 이 복잡성 수준에서 CPU 테스트 케이스가 실행 시간 측면에서 IO보다 빠릅니다.\n\n# 저장공간\n\n데이터베이스나 작은 파일에 액세스하는 것은 블로킹 작업이기 때문에 단순히 스레드를 휴면 상태로 두기만 하면 됩니다. 휴면 시간은 500에서 1,490 마이크로초 또는 0.5에서 1.5 밀리초 사이입니다. 그러나 흔한 Thread.sleep 메서드는 \"바쁜 대기(busy waiting)\"로 인해 정확하지 않은 결과를 나타냅니다. 그래서 LockSupport.parkNanos를 사용하여 스레드를 휴면 상태로 만들겠습니다.\n\n```js\nprivate fun storage(seed: Int): Int {\n   val timeInMicroseconds = 500 + 10 * seed.toLong()\n   LockSupport.parkNanos(TimeUnit.MICROSECONDS.toNanos(timeInMicroseconds))\n   return seed\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n마침내 결과가 나왔어요.\n\n![image](/assets/img/2024-06-23-WhatisfasterandinwhichtasksCoroutinesRxJavaExecutor_4.png)\n\nIO 테스트 케이스를 먼저 실행한 후 CPU를 실행하고 마지막으로 싱글 스레드를 실행했어요. 텍스트북에서 직접 나온 것처럼 들리죠? \"IO 스레드 풀이 IO 작업에 가장 좋아요.\"\n\nrxIO 테스트 케이스가 flowsIO 및 coroutinesIO보다 더 빠르다는군요. 아마 쓰레드를 생성하는 데 필요한 자원이 가장 적게 사용되는 것 같아요만... 그런 작업에서는 그렇게 중요한 점은 아니에요. 차이는 딱 한 밀리초뿐이에요. 프레임워크 간의 구별은 거의 사라진 것 같아요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 네트워크\n\n음, 네트워크 케이스를 테스트하지 않을 수가 없어요. 모든 것은 이전 테스트랑 똑같죠. 이번에는 쓰레드가 잠시 동안 0에서 99밀리초 사이에 쉬도록 만들었어요. 이 테스트에서는 \"바쁜 대기\"에 의한 지연이 더 이상 중요한 역할을 하지 않아요. 그래서 우리는 Thread.sleep을 사용할 거예요.\n\n```js\nprivate fun network(seed: Int): Int {\n   TimeUnit.MILLISECONDS.sleep(seed.toLong())\n   return seed\n}\n```\n\n다음 결과에 주의하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 테이블 태그를 Markdown 형식으로 변경하십시오.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\nprivate fun mixed(seed: Int): Int {\n   return when {\n       seed % 5 == 0 -> network(seed)\n       seed % 3 == 0 -> storage(seed)\n       seed % 2 == 0 -> listsManipulation(seed)\n       else -> arithmetic(seed)\n   }\n}\n```\n\n가장 오랜 시간이 걸리는 작업은 코드에서 확인할 수 있듯이 90밀리초입니다.\n\n그래서 여기에 결과가 있습니다.\n\n![Image](/assets/img/2024-06-23-WhatisfasterandinwhichtasksCoroutinesRxJavaExecutor_6.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n일반적으로, 세 개의 블록으로 분할하는 패턴이 동일하게 나타납니다: IO, CPU, One.\n\n차이점은 Executors.newWorkStealingPool로 생성된 Executor가 작은 작업들을 추가하여 선두를 선점한다는 것입니다. 이는 작업을 \"도둑질\"하기 때문으로 보입니다.\n\n# 결론\n\n파일 시스템과 네트워크 작업을 처리할 때는 멀티스레딩의 역할이 거의 사라진 것을 알 수 있습니다. 대부분의 멀티스레딩 사용은 IO 작업을 위한 것입니다. 따라서 성능을 기반으로한 멀티스레딩 프레임워크 선택은 이상합니다. 편의성 및 중요한 요소 등의 기준을 바탕으로 선택하는 것이 더 나을 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그러나 0.5밀리초 동안 스레드를 차단하는 것보다 더 간단한 작업을 수행한다면 작은 스레드 풀을 사용하는 것이 좋습니다. 예를 들어 CPU 코어 수를 풀의 크기로 사용할 수 있습니다.\n\nExecutors와 Rx는 이러한 작업에 가장 적합합니다.\n\n예외는 산술, 객체 생성 등과 같이 매우 간단한 작업에 해당합니다. 이러한 경우에는 모든 작업을 완료하는 데 필요한 시간보다 프레임워크에 의한 스레드 생성에 필요한 시간이 더 많이 걸리므로 멀티스레딩을 사용하지 않는 것이 좋습니다.\n\n문제를 해결하기 위해 제가 따랐던 단계는 다음과 같습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 모든 간단한 작업을 별도의 작업 풀에 분리하여 directInvoke를 사용하여 실행했습니다.\n- 다른 모든 작업은 Dispatchers.IO를 사용하여 코루틴에서 실행되었는데, 이는 동기 및 비동기 코드를 동시에 작성하기 쉽게 해줬습니다.\n\n그리고 어떻게 생각하세요? 현재 어떤 프레임워크를 사용하고 있나요?\n","ogImage":{"url":"/assets/img/2024-06-23-WhatisfasterandinwhichtasksCoroutinesRxJavaExecutor_0.png"},"coverImage":"/assets/img/2024-06-23-WhatisfasterandinwhichtasksCoroutinesRxJavaExecutor_0.png","tag":["Tech"],"readingTime":30},{"title":"초보자를 위한 안드로이드에서 C C 사용하는 방법 총정리","description":"","date":"2024-06-23 01:19","slug":"2024-06-23-UsingCCinAndroidAComprehensiveGuideForBeginners","content":"\n## 안드로이드 개발\n\n![이미지](/assets/img/2024-06-23-UsingCCinAndroidAComprehensiveGuideForBeginners_0.png)\n\n안드로이드 개발자로서, 우리는 아름다운 UI 및 기능을 구축하기 위해 Java 또는 Kotlin을 사용해 왔습니다. 앱 개발부터 실행까지 안드로이드 전체 스택은 JVM 및 Java-스러운 기능을 중심으로 돌아갑니다. 리눅스 커널을 제외하고, Java는 C로 작성되어 있는데요.\n\n프로그래밍 언어인 Java는 앱 개발을 위한 최적의 선택지로 만들어 주는 많은 우수한 기능을 갖추고 있습니다. 가상 머신 실행으로 플랫폼 독립적이며, JIT 컴파일된, 멀티 스레딩 지원이 가능하며, 프로그래머에게 표현력이 뛰어나고 간단한 구문을 제공합니다. 플랫폼에 대한 중립적인 특성으로 인해 Java 패키지는 CPU 아키텍처에 따라 이식 가능하며, 이는 라이브러리 개발을 용이하게 하고 플러그인, 빌드 도구 및 유틸리티 패키지의 전반적인 생태계를 높일 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n특정 기능의 수와 성능 사이에는 상충 관계가 있습니다. 어셈블리와 같은 언어는 메모리 및 실행 오버헤드가 가장 적지만 프로그래머 관점에서는 가장 적은 수의 기능을 제공합니다. 계층을 올라가면서 C 및 C++과 같은 언어는 하드웨어에 더 가까운 위치를 유지하면서 좋은 기능 집합을 제공합니다. 그 위에는 플랫폼 의존성을 완전히 제거하기 위해 가상 머신을 사용하는 Java와 Python과 같은 언어들이 있습니다. 이러한 언어로 작성된 프로그램은 많은 오버헤드가 발생하지만 개발자에게는 천국입니다.\n\n## 누군가가 Android 프로젝트에서 C/C++ 지원이 필요한 이유는 무엇인가요?\n\n위에서의 토론에도 나와 있듯이, 우리 시스템에서는 성능이 개발자 친화성보다 더 중요하기 때문에 우리의 관심을 '네이티브 언어'인 C/C++로 이동시킵니다. 네이티브 코드의 역할과 성능 개선에 대해 이해할 수 있는 몇 가지 예를 살펴보겠습니다.\n\n- 그래픽, 렌더링 및 상호작용: 사용자 인터페이스를 개발하고 매력적으로 보이게 만드는 작업은 Jetpack Compose와 같은 고수준 프레임워크에서는 간단한 작업으로 보일 수 있습니다. 하지만 픽셀 수준에서는 그림자의 강도, 조명 모드 및 객체의 질감을 계산하기 위해 수천 개의 계산이 수행됩니다. 이러한 계산은 벡터와 행렬과 같은 선형 대수 구조 및 해당 연산을 많이 사용합니다. 터치 상호작용을 처리할 때는 명령을 클릭, 더블 클릭, 드래그 또는 스와이프 제스처로 구분해야 하므로 많은 계산이 필요합니다. 이러한 계산은 하드웨어에 더 가까운 언어에서 수행하는 것이 더 나은데 추가적인 최적화가 가능합니다.\n- 머신 러닝: C/C++의 역할은 PyTorch 및 TensorFlow와 같은 인기있는 프레임워크의 코드베이스의 주요 부분이 C/C++로 작성되어 있음으로써 쉽게 이해됩니다. TensorFlow는 C++로 작성된 연산을 사용하고 Python 코드에서 이러한 연산을 사용하기 위한 래퍼(인터페이스)를 제공합니다. C++의 채택은 선형 대수 연산, 병렬 처리에 사용되는 CUDA 코드베이스가 수년 전에 작성되었고 많은 시험을 거쳐 왔기 때문에 명백합니다. Python은 TensorFlow의 인터페이스 중 하나로 사용되며, C/C++ 작업을 깔끔하고 간편하게 만들어주어 비 프로그래머 사용자에게 편리합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![image](/assets/img/2024-06-23-UsingCCinAndroidAComprehensiveGuideForBeginners_1.png)\n\nMany such systems uphold performance compromising readability and some other factors. Next, we’ll have a short discussion on Instruction Set Architectures (ISAs) and how program execution changes with changing CPU architectures.\n\n# Understanding How C++ Is Integrated in Android Apps\n\n![image](/assets/img/2024-06-23-UsingCCinAndroidAComprehensiveGuideForBeginners_2.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 그림에서 안드로이드에서 C/C++ 코드를 사용하는 방법에 대해 나와 있습니다. 여기에는 C/C++ 코드용 빌드 프로세스와 Java/Kotlin 코드용 또 다른 독립적인 빌드 프로세스가 있습니다. 이 블로그에서는 C/C++ 코드 빌드 프로세스에 중점을 두고 코드가 함수 호출을 위해 JVM과 어떻게 통신하는지 살펴볼 것입니다.\n\n먼저 C/C++ 및 Java 프로그램이 컴파일되는 간단한 개요를 살펴볼 것이며, 주로 C/C++ 컴파일의 플랫폼별 특성을 강조할 것입니다. 그 다음, C/C++과 Java 코드 간의 접착제 역할을 하는 JNI에 대해 논의할 것입니다. 빌드 프로세스의 가장 하단 구성 요소인 CMake, 공유 라이브러리 및 ABI에 대한 논의로 마무리할 것입니다.\n\n자, 시작해봅시다 🚀\n\n## 1. C++ 및 Java 프로그램의 컴파일\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n➡️ C++은 컴파일된 언어로, 소스 코드가 실행 가능한 이진 코드로 변환됩니다. 실행 파일에는 소스 프로그램의 이진 버전, 필요한 상수 및 라이브러리 코드가 포함되어 있습니다.\n\n➡️ 이 실행 파일은 운영 체제의 구성 요소인 로더에 의해 구문 분석되며, 프로그램의 실행을 위해 메모리를 할당하고 실행 파일에서 명령을 읽습니다. 예를 들어, hello-world C++ 프로그램이 Ubuntu에서 사용 가능한 g++로 컴파일되었다면, x86 또는 x86_64 명령 세트를 이해하는 한 다른 Linux 배포판에서도 실행될 것입니다.\n\n➡️ 모바일 기기는 arm 또는 arm64 명령 세트로 작동하기 때문에 x86용으로 컴파일된 프로그램은 작동하지 않습니다. 두 실행 파일은 로더가 보는 것과 같이 완전히 다른 언어로 작성되어 있기 때문입니다.\n\n![이미지](/assets/img/2024-06-23-UsingCCinAndroidAComprehensiveGuideForBeginners_3.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Android Architecture](/assets/img/2024-06-23-UsingCCinAndroidAComprehensiveGuideForBeginners_4.png)\n\nAndroid 기기는 주로 네 가지 아키텍처에서 작동할 수 있습니다 - arm64-v8a, armeabi-v7a, x86 및 x86_64. ARM 기반 프로세서에서 사용되는 arm- 아키텍처는 대부분의 Android 휴대폰에서 사용되며, Intel 또는 AMD 프로세서에 사용되는 x86- 기반 아키텍처는 Windows 에뮬레이터와 Chromebook에 사용됩니다.\n\n## Java\n\n➡️ 만약 어느 시점에 Java를 배웠다면, 동영상이나 블로그에서 자주 강조되는 특징 중 하나는 플랫폼 독립성 또는 한 번 작성하고 어디서든 실행하는 것입니다. 소스 코드를 기계 의존적 실행 형식으로 변환하는 대신 Java는 코드를 중간 표현 (IR)으로 변환합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n➡️ IR은 플랫폼에 독립적이며, x86 또는 arm 플랫폼에서 생성된 IR은 명령어 세트의 차이에 관곧하게 동일합니다. IR은 플랫폼 의존 구성 요소인 Java 가상 머신에 의해 구문 분석되며, 해당 가상 머신은 IR에서 명령어를 읽어서 기존 CPU에서 실행합니다. JVM은 IR을 처리하고 동시에 기존 CPU에서 명령어를 실행하기 때문에 플랫폼에 독립적이 아닙니다.\n\n➡️ JVM은 거의 모든 CPU 아키텍처에서 실행되고, 생성된 IR이 플랫폼에 독립적이기 때문에 모든 플랫폼에 작성된 Java 코드를 실행할 수 있습니다. 유일한 종속성은 대상 기기에 JVM이 설치되어 있어야 한다는 것입니다.\n\n## Android ART와 DEX 바이트코드\n\n운영 체제로서 Android는 Java 코드를 실행하기 위해 표준 JVM을 사용하지 않습니다. 패키지된 애플리케이션인 APK에는 DEX 파일(.class 파일과 유사)과 네이티브 코드 및 리소스가 포함되어 있습니다. DEX 파일은 실행 전에 OS에 의해 네이티브 실행 코드로 미리 컴파일되어 사용자가 앱을 열 때 빠르게 인스턴스화될 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 2. JNI을 사용하여 C++ 소스 코드 래핑하기\n\nJNI 또는 Java Native Interface는 JVM과 네이티브 코드(C, C++ 또는 어셈블리 코드) 간의 통신을 쉽게 할 수 있게 해주는 프레임워크입니다. 일반적으로 말해, 이는 외부 함수 인터페이스(FFI)를 제공하여 다른 언어로 작성된 코드가 주로 함수 호출을 통해 다른 언어로 작성된 코드와 통신할 수 있게 합니다. Java 소스 코드는 C++ 모듈에 존재하는 함수 정의를 찾아서 JVM에서 사용할 수 있도록 플래그를 달게 합니다.\n\nJNI에는 jclass, jobject, jfloat, jstring 등과 같은 클래스들이 있으며, 이들은 각각 C++에서 해당하는 자바 원시 자료형 (클래스, 객체, float 및 String)을 나타냅니다. 예를 들어 C++에서 정의된 JNI 함수는 다음과 같습니다.\n\n```cpp\n// C++ 소스 파일\nextern \"C\" JNIEXPORT jstring JNICALL\nJava_com_projects_ml_samplecppdemo_MainActivity_compute(\n        JNIEnv* env,\n        jobject instance ,\n        jstring message ,\n        jlong length\n) {\n    // 메소드 블록이 여기에 위치합니다\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nMainActivity에서 Kotlin 함수 compute에 해당하는 것이 존재할 것입니다.\n\n```kotlin\n// Kotlin 소스 파일\nexternal fun compute(message: String, length: Long): String\n```\n\nMainActivity.kt를 컴파일하는 동안, JVM은 코드에서 선언한 compute 함수의 정의를 찾아야 합니다. 정의는 C++ 소스 파일 안에 포함되어 있기 때문에, Java 프로그램에 이를 어떻게 제공할까요? 우리는 C++ 코드를 컴파일하고, JVM이 JNI 함수의 정의를 찾을 수 있는 공유 라이브러리로 패키징합니다.\n\n## 3. CMake과 Android NDK\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-06-23-UsingCCinAndroidAComprehensiveGuideForBeginners_5.png\" />\n\n## Android NDK and Toolchains\n\n저희는 Windows, macOS 또는 Linux 기반 운영 체제에서 Android 앱을 개발합니다. 이러한 시스템 대부분은 Android 특정 ARM 아키텍처를 보유하고 있지 않으며 Android 기기에서 코드를 컴파일하는 것은 불가능합니다. 그렇다면 모바일 폰에서 사용하는 Android 특정 ARM 아키텍처를 위해 코드를 어떻게 컴파일할까요?\n\n<img src=\"/assets/img/2024-06-23-UsingCCinAndroidAComprehensiveGuideForBeginners_6.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n안녕하세요! Android NDK(안드로이드 네이티브 개발 키트)를 사용하고 있습니다. 이 키트는 Android-ARM 라이브러리 및 실행 파일을 x86 또는 다른 arm 장치(애플 실리콘 또는 라즈베리 파이)에서 빌드하기 위한 컴파일러 및 링커를 제공합니다. 이렇게 다른 타겟(예: Android-ARM)을 위해 코드를 빌드하는 프로세스는 현재 다른 타겟(예: x86_64)을 실행 중인 시스템에서 이루어지는 교차 컴파일이라고 합니다. 그래서, Windows 기기에서 Android NDK의 컴파일러를 사용하여 앱을 위한 공유 라이브러리를 빌드할 수 있습니다. 이 라이브러리는 ARM 기기인 모바일 장치에서 완벽하게 실행될 것입니다.\n\nAndroid NDK에는 CMake에게 사용할 컴파일러를 알려주는 CMAKE_TOOLCHAIN_FILE이 존재합니다. 위키피디아에 따르면, 툴체인은 복잡한 소프트웨어 개발 작업을 수행하거나 소프트웨어 제품을 만들기 위해 사용되는 프로그래밍 도구의 모음입니다. Android NDK는 다양한 Android API 레벨을 위해 다양한 툴체인을 제공하여 C/C++ 프로그램을 빌드하고 컴파일할 수 있습니다.\n\n## CMake란 무엇인가요?\n\n간단한 C++ hello-world 프로그램을 컴파일한다면, 대부분의 리눅스 배포판에 미리 설치된 GNU의 g++ 컴파일러를 사용했을 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```bash\ng++ main.cpp -o main\n```\n\n➡️ 하나의 소스 파일 main.cpp의 경우, 하나의 명령어로 작업을 처리할 수 있어요. 더 큰 코드베이스는 여러 모듈과 많은 C/C++ 소스 파일을 포함하고 있을 수 있는데, 이들은 공유 혹은 정적 라이브러리로 컴파일하거나 빌드해야 합니다. 해당 코드베이스의 의존성들, 즉 다른 C++ 프로젝트들도 잘 통합되어야 해요. 이런 방대한 코드베이스는 컴파일에 많은 시간이 소요될 거예요.\n\n➡️ 이러한 문제들에 대처하기 위해 GNU의 Make 도구를 사용할 수 있는데, 이는 여러 대상을 관리하거나 증분 빌드, 헤더 파일 포함 및 다양한 언어 지원 기능을 제공해줘요. 따라서 컴파일을 위해 여러 명령어를 실행하는 대신, 단일 Make 스크립트가 효율적으로 컴파일을 수행할 거예요.\n\n```bash\ncmake_minimum_required(VERSION 3.22.1)\n\nproject(\"samplecppdemo\")\n\n# CMake에게 주어진 소스 파일 native-lib.cpp에 대한 공유 라이브러리(.so)를 빌드하도록 지시합니다.\n# native-lib.cpp에는 JNI 함수도 포함되어 있어요.\nadd_library(\n        ${CMAKE_PROJECT_NAME}\n        SHARED\n        native-lib.cpp)\n\n# CMake은 현재 빌드에 다른 라이브러리를 링크할 수도 있어요.\n# android와 log는 각각 안드로이드 특정 루틴과 로깅을 제공하기 위해 사용됩니다.\ntarget_link_libraries(\n        ${CMAKE_PROJECT_NAME}\n        android\n        log)\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n➡️ CMake는 컴파일러에 독립적인 방법으로 Make 스크립트를 생성할 수 있으며, 의존성, 헤더 및 컴파일 시에 링크해야 하는 다른 라이브러리를 추가할 수 있는 고유한 구문을 갖고 있습니다. CMake은 Gradle과 유사하여 둘 다 빌드 시스템입니다.\n\n간단히 읽으려면 이 스택오버플로우 답변을 참조하세요: 코드를 컴파일하기 위해 Makefile과 CMake 중 어떤 것을 사용해야 하는지에 대한 차이는 무엇인가요?\n\n# 4. 공유 라이브러리와 ABI\n\n➡️ C/C++ 코드의 컴파일은 실행 파일 또는 라이브러리 중 하나의 이진 표현물을 생성할 수 있습니다. 실행 파일에는 실행이 시작되는 main 함수의 주소와 ELF 형식을 따르는 추가적인 세부 정보가 포함되어 있습니다. 라이브러리는 다른 프로그램에서 호출할 수 있는 함수를 제공하며, 프로그램의 오브젝트 코드와 라이브러리를 링크하여 사용됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-06-23-UsingCCinAndroidAComprehensiveGuideForBeginners_7.png\" />\n\n➡️ 안드로이드에서 C/C++ 파일은 .so (shared object) 확장자로 끝나는 공유 라이브러리로 컴파일됩니다. 이러한 라이브러리는 (2)에서 extern으로 표시된 JNI 함수를 노출합니다. JVM은 .so 파일의 코드를 검토하고 해당 기능의 이진 코드를 장치에서 실행하기 위해 사용할 수 있습니다.\n\n➡️ 소스 코드와 라이브러리 코드 간의 상호 작용은 이진 레벨에서 발생하므로 일반적으로 응용 프로그램 바이너리 인터페이스 (ABI)를 통해 발생합니다. 반대로 응용 프로그램 프로그래밍 인터페이스 (API)는 컴파일이 발생하기 전 소스 코드 수준에서 이러한 상호 작용을 용이하게 합니다.\n\nABI에 대한 직관적인 설명을 보려면 LinkedIn 게시물을 확인해보세요. 두 개의 소프트웨어 조각이 소스 코드에서 통신해야 하는 경우 API를 사용합니다. 만약 두 이진 모듈이 통신하려면 어떻게 해야할까요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 결론\n\nJVM은 이제 공유 라이브러리에 노출된 함수에 액세스할 수 있으며, OS가 필요에 따라 실행합니다.\n\n이 기사가 흥미로웠고 새로운 것을 배우셨기를 바랍니다. 아래 댓글에 궁금한 점이나 제안을 공유해 주세요. 즐거운 하루 되세요!\n","ogImage":{"url":"/assets/img/2024-06-23-UsingCCinAndroidAComprehensiveGuideForBeginners_0.png"},"coverImage":"/assets/img/2024-06-23-UsingCCinAndroidAComprehensiveGuideForBeginners_0.png","tag":["Tech"],"readingTime":13},{"title":"KMM에서 Proto DataStore 마법을 해제하는 방법","description":"","date":"2024-06-23 01:17","slug":"2024-06-23-UnlockingProtoDataStoreMagicinKMM","content":"\n<img src=\"/assets/img/2024-06-23-UnlockingProtoDataStoreMagicinKMM_0.png\" />\n\n모바일 개발의 빠르게 진화하는 세계에서 Kotlin Multiplatform Mobile (KMM)은 안드로이드 및 iOS 애플리케이션을 위한 공유 코드를 작성할 수 있게 해줍니다. 중요한 도전 중 하나는 안드로이드의 SharedPreference나 iOS의 NSUserDefaults와 같은 효율적이고 신뢰할 수 있는 키-값 데이터 저장 솔루션을 찾는 것입니다. 이 글에서는 강력하고 타입 안전한 솔루션 Proto DataStore를 KMM 프로젝트에 통합하는 방법을 탐구합니다.\n\n# DataStore\n\nJetpack DataStore는 프로토콜 버퍼를 사용하여 키-값 쌍 또는 형식화된 객체를 저장할 수 있는 데이터 저장 솔루션입니다. DataStore는 Kotlin 코루틴과 Flow를 사용하여 데이터를 비동기적으로, 일관되게 및 트랜잭션 처리할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nDataStore은 두 가지 다른 구현을 제공합니다:\n\n- Preferences DataStore는 키를 사용하여 데이터를 저장하고 액세스합니다. 이 구현은 미리 정의된 스키마가 필요하지 않으며 형식 안전성을 제공하지 않습니다.\n- Proto DataStore는 사용자 정의 데이터 유형의 인스턴스로 데이터를 저장합니다. 이 구현은 프로토콜 버퍼를 사용하여 스키마를 정의해야 하지만 형식 안전성을 제공합니다.\n\nGoogle이 이제 DataStore Multiplatform을 출시했습니다!\n\n이 문서에서는 KMM에 Proto DataStore를 구현하여 Protocol Buffer를 활용할 것입니다. KMM에서 Protocol Buffer를 사용하기 위해 Wire를 사용했습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 전체 코드\n\n# 단계별 구현\n\n- app/build.gradle.kts 파일에 DataStore 종속성 추가\n\n```js\ncommonMain.dependencies {\n  // 다른 종속성들\n  implementation(\"androidx.datastore:datastore-core-okio:1.1.1\")\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- app/build.gradle.kts 파일에 Wire Gradle 플러그인을 추가해주세요.\n\n```js\nplugins {\n  // 다른 플러그인들\n  id(\"com.squareup.wire\") version \"5.0.0-alpha03\"\n}\n```\n\n- app/build.gradle.kts 파일에 Wire Gradle 설정을 추가해주세요.\n\n```js\nwire {\n    kotlin {}\n    sourcePath {\n        srcDir(\"src/commonMain/proto\")\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- src/commonMain/proto 디렉토리 아래 preference_data.proto 파일을 생성해주세요\n\n![아이미지](/assets/img/2024-06-23-UnlockingProtoDataStoreMagicinKMM_1.png)\n\n```js\n// preference_data.proto 파일\n\nsyntax = \"proto3\";\n\npackage com.areeb.proto_datastore_kmm;\n\nmessage PreferenceData {\n  int32 counter = 1;\n}\n```\n\n- PreferenceData에 대한 Protocol Buffer 직렬화기를 생성해주세요\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kt\n// commonMain 안에 있습니다\n// PreferenceSerializer.kt\n\nobject PreferenceSerializer : OkioSerializer<PreferenceData> {\n    override val defaultValue: PreferenceData\n        get() = PreferenceData()\n\n    override suspend fun readFrom(source: BufferedSource): PreferenceData {\n        try {\n            return PreferenceData.ADAPTER.decode(source)\n        } catch (exception: IOException) {\n            throw Exception(exception.message ?: \"Serialization Exception\")\n        }\n    }\n\n    override suspend fun writeTo(t: PreferenceData, sink: BufferedSink) {\n        sink.write(t.encode())\n    }\n}\n```\n\n- 각 플랫폼(여기서 안드로이드 및 iOS)을 위한 Proto DataStore 인스턴스를 생성합니다\n\n```kt\n// commonMain 안에 있습니다\n// DataStore.kt\n\ninternal const val DATA_STORE_FILE_NAME = \"proto_datastore.preferences_pb\"\n\nexpect fun getDataStore(): DataStore<PreferenceData>\n\nfun createDataStore(\n    fileSystem: FileSystem,\n    producePath: () -> Path\n): DataStore<PreferenceData> =\n    DataStoreFactory.create(\n        storage = OkioStorage(\n            fileSystem = fileSystem,\n            producePath = producePath,\n            serializer = PreferenceSerializer,\n        ),\n    )\n```\n\n```kt\n// androidMain 안에 있습니다\n// ProtoDataStore.kt\n\nactual fun getDataStore(): DataStore<PreferenceData> {\n    val content = requireNotNull(AndroidPlatformContextProvider.context)\n    val producePath = { content.filesDir.resolve(DATA_STORE_FILE_NAME).absolutePath.toPath() }\n\n    return createDataStore(fileSystem = FileSystem.SYSTEM, producePath = producePath)\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\n// iosMain 내부\n// ProtoDataStore.kt\n\n실제 getDataStore() 함수:\n\nactual fun getDataStore(): DataStore<PreferenceData> {\n    @OptIn(ExperimentalForeignApi::class)\n    val producePath = {\n        val documentDirectory: NSURL? = NSFileManager.defaultManager.URLForDirectory(\n            directory = NSDocumentDirectory,\n            inDomain = NSUserDomainMask,\n            appropriateForURL = null,\n            create = false,\n            error = null,\n        )\n        requireNotNull(documentDirectory).path + \"/$DATA_STORE_FILE_NAME\"\n    }\n\n    return createDataStore(fileSystem = FileSystem.SYSTEM, producePath = { producePath().toPath() })\n}\n```\n\n- DataStore를 사용하여 키-값 쌍을 가져오고 저장합니다.\n\n```kotlin\n// commonMain 내부\n// Preference.kt\n\nPreference 인터페이스:\n\ninterface Preference {\n    suspend fun updateCounter()\n    fun getCounter(): Flow<Int>\n}\n\nPreferenceImpl 클래스:\n\nPreferenceImpl(private val dataStore: DataStore<PreferenceData> = getDataStore()) :\n    Preference {\n\n    override suspend fun updateCounter() {\n        dataStore.updateData { data ->\n            data.copy(counter = data.counter + 1)\n        }\n    }\n\n    override fun getCounter(): Flow<Int> {\n        return dataStore.data.map { data ->\n            data.counter\n        }\n    }\n}\n```\n\n- Compose Multiplatform에서 DataStore 사용법\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\n@Composable\n@Preview\nfun App() {\n    MaterialTheme {\n        val composableScope = rememberCoroutineScope()\n        val preference: Preference = remember { PreferenceImpl() }\n        val counter by preference.getCounter().collectAsState(initial = 0)\n\n        Column(\n            Modifier.fillMaxSize(),\n            horizontalAlignment = Alignment.CenterHorizontally,\n            verticalArrangement = Arrangement.Center,\n        ) {\n            Button(\n                onClick = {\n                    composableScope.launch {\n                        preference.updateCounter()\n                    }\n                },\n            ) {\n                Text(\"Click me! Counter: $counter\")\n            }\n        }\n    }\n}\n```\n\n결과\n\n<img src=\"https://miro.medium.com/v2/resize:fit:648/1*LLMohc4VOkcL1wdhGDjp_Q.gif\" />\n\n<img src=\"https://miro.medium.com/v2/resize:fit:600/1*myxIzIctkEZvgk81vKV0-w.gif\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래 코멘트에 여러분의 제안과 개선 사항을 남겨주세요. 편안한 마음으로 연락해주세요!\n\nLinkedIn에서 저와 연결해보세요.\n","ogImage":{"url":"/assets/img/2024-06-23-UnlockingProtoDataStoreMagicinKMM_0.png"},"coverImage":"/assets/img/2024-06-23-UnlockingProtoDataStoreMagicinKMM_0.png","tag":["Tech"],"readingTime":8},{"title":"Compose를 통해 유연한 컴포넌트 만드는 방법","description":"","date":"2024-06-23 01:16","slug":"2024-06-23-CreatingflexiblecomponentsinCompose","content":"\n어떠한 개발에서도, 디자이너들이 또 다른 변형이 필요하다며 당신이 막 완성한 컴포넌트에 또 다른 변형을 요구하는 경우가 종종 있습니다. 이 새로운 컴포넌트가 이전 것들을 모두 망가뜨릴지도 확실하지 않은 상황이죠. 오늘은 Compose를 사용하여 유연한 컴포넌트를 만드는 원칙에 대해 이야기해보고, 앞으로를 생각하며 아름답게 구현해보려 합니다.\n\n# 입력 데이터\n\n가장 기초적인 시작부터 시작해봅시다. 여러분의 프로젝트에는 세 가지 다른 컴포넌트가 있다고 상상해보세요. 하지만 이 모든 것들은 한 가지 엔티티인 - 특정 타입의 연락처 사람을 대표합니다. 이번 예제에서, 우리는 셋의 변형을 가지게 될 것입니다:\n![그림](/assets/img/2024-06-23-CreatingflexiblecomponentsinCompose_0.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![image1](/assets/img/2024-06-23-CreatingflexiblecomponentsinCompose_1.png)\n\n![image2](/assets/img/2024-06-23-CreatingflexiblecomponentsinCompose_2.png)\n\n# ContactFullNameView\n\n우선 주어진 레이아웃의 구조를 이해해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-06-23-CreatingflexiblecomponentsinCompose_3.png\" />\n\n```js\nRow {\n  Image\n  Text\n}\n```\n\n가장 간단한 형태이며 내부에 컴포넌트가 있는 행(Row)일 뿐이라 특별한 점은 없습니다.\n\n코드를 정리한 후 결과물은 다음과 같습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n@Preview 주석으로 이를 커버해보겠습니다. 결과를 확인하고 비교할 수 있습니다.\n\n```js\n@Preview\n@Composable\nprivate fun ContactFullNameV1ViewPreview() = ReusableComponentsTheme {\n    ContactFullNameV1View(\n        imageUrl = \"https://images.stockcake.com/public/1/b/e/1be26278-b679-47a6-b17a-f3a66bc3db92_large/elegant-senior-portrait-stockcake.jpg\",\n        fullName = \"Eleanor Pena\",\n        modifier = Modifier\n            .fillMaxWidth()\n            .background(MaterialTheme.colorScheme.surface),\n    )\n}\n```\n\n그러나 첫 미리보기 이후에 문제가 발생합니다. - 폰이나 에뮬레이터에서 미리보기를 실행하지 않고 결과를 보는 방법이 필요합니다. 또한 코드에 링크를 유지하면 심지어 @Preview에도 크게 멋지지 않습니다. 여기서 @Composable 함수를 만드는 접근 방식을 변경해야 합니다.\n\n![이미지](/assets/img/2024-06-23-CreatingflexiblecomponentsinCompose_4.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n원칙적으로 유연한 구성 요소를 만들려고 하면 작업 중인 모델에서 어느 정도 추상화해야 합니다.\n\n```js\n@Composable\nfun ContactFullNameV2View(\n    imagePainter: Painter,\n    fullName: String,\n    modifier: Modifier = Modifier,\n)\n```\n\nPainter 클래스 유형에 대한 참조를 변경함으로써 세 가지 작업을 동시에 해결할 수 있습니다. @Preview에서 결과를 보는 것, 특정 링크를 통해 기기에서 이미지를 볼 수 있는 것(원하는 경우), 실제 @Composable에서 이미지를 로드하는 것에 대한 완전한 제어를 갖는 것입니다.\n\n```js\n@Preview\n@Composable\nfun ContactFullNameV2ViewPreview() = ReusableComponentsTheme {\n    ContactFullNameV2View(\n        imagePainter = when {\n            LocalInspectionMode.current -> painterResource(id = R.drawable.eleanor_pena)\n            else -> rememberAsyncImagePainter(model = \"https://images.stockcake.com/public/1/b/e/1be26278-b679-47a6-b17a-f3a66bc3db92_large/elegant-senior-portrait-stockcake.jpg\")\n        },\n        fullName = \"Eleanor Pena\",\n        modifier = Modifier\n            .fillMaxWidth()\n            .background(MaterialTheme.colorScheme.surface),\n    )\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-06-23-CreatingflexiblecomponentsinCompose_5.png\" />\n\n# ContactActionsView\n\n<img src=\"/assets/img/2024-06-23-CreatingflexiblecomponentsinCompose_6.png\" />\n\n우리가 새로 만들 컴포넌트의 대략적인 구조를 한 번 더 정의해 봅시다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\nRow {\n  Image\n  Column {\n    Text\n    Text\n  }\n  IconButton\n  IconButton\n  IconButton\n}\n```\n\n디자인과 비교한 후에는 약간 변경될 것이지만, 본질은 같을 것입니다. 이전 컴포넌트와 비교하여 새 필드를 추가하고 작업 버튼을 도입했습니다. 우리가 가진 지식을 활용하여 이 기능을 정확하게 설명합니다. 추가 변경 사항에는 여백 및 컨테이너 자체의 최소 크기도 포함됩니다.\n\n```kotlin\n@Composable\nfun ContactActionsV1View(\n    imagePainter: Painter,\n    fullName: String,\n    modifiedTime: String,\n    modifier: Modifier = Modifier,\n    onChatClicked: () -> Unit = {},\n    onMainClicked: () -> Unit = {},\n    onCallClicked: () -> Unit = {},\n)\n```\n\n![Image](/assets/img/2024-06-23-CreatingflexiblecomponentsinCompose_7.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# ContactDetailsView\n\n![ContactDetailsView](/assets/img/2024-06-23-CreatingflexiblecomponentsinCompose_8.png)\n\n우리는 방금 이 버튼들을 추가했는데, 이제 제거해야 해요... 디자이너 분들! 컴포넌트의 구조를 다시 생각해 봐요.\n\n```js\nRow {\n  Image\n  Column {\n    Text\n    Text\n    Row {\n      Image\n      Text\n    }\n  }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여기에도 특별한 것은 없습니다. 텍스트와 새로운 사진이 초기 버전에 추가된 간단한 레이아웃입니다. 차이점은 여백, 컨테이너의 최소 크기 및 연락처 사진의 정렬에 있습니다.\n\n```kotlin\n@Composable\nfun ContactDetailsV1View(\n    imagePainter: Painter,\n    managerPainter: Painter,\n    title: String,\n    fullName: String,\n    modifiedTime: String,\n    modifier: Modifier = Modifier,\n)\n```\n\n![이미지](/assets/img/2024-06-23-CreatingflexiblecomponentsinCompose_9.png)\n\n# 프랑켄슈타인의 몬스터 만들기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n마음에 떠오를 수 있는 첫 번째 아이디어는 우리 컴포넌트에 존재하는 모든 매개변수를 수집하고 모든 것을 할 수 있고 모든 것을 아는 하나의 매우 크고 강력한 @Composable을 만드는 것입니다. 그러나 이런 이리저리 섞인 것을 조립하는 동안 코드에 나타나는 여러 when 조건들을 발견할 수 있습니다. 이런 조건들이 대량으로 존재하는 것은 무언가 잘못되었음을 나타낼 수 있습니다. 여기서 단점은 특정 구성에서 우리 컴포넌트와 논리적으로 관련이 없는 많은 매개변수에 대한 접근이며, 또한 컴포넌트의 불안정성입니다. 새로운 요구사항이 들어오면 기존의 유연성으로는 원하는 기능을 추가하는 데 충분하지 않을 수 있습니다.\n\n```kotlin\n@Composable\nfun ContactViewV1(\n    imagePainter: Painter,\n    managerPainter: Painter?,\n    title: String?,\n    fullName: String,\n    modifiedTime: String?,\n    modifier: Modifier = Modifier,\n    onChatClicked: (() -> Unit)? = null,\n    onMainClicked: (() -> Unit)? = null,\n    onCallClicked: (() -> Unit)? = null,\n) {\n    Row(\n        modifier = modifier\n            .sizeIn(\n                minHeight = when {\n                    title.isNullOrBlank() && modifiedTime.isNullOrBlank() -> 56.dp\n                    !title.isNullOrBlank() -> 72.dp\n                    else -> 88.dp\n                },\n            )\n            .padding(\n                horizontal = 16.dp,\n                vertical = when {\n                    title.isNullOrBlank() && modifiedTime.isNullOrBlank() -> 8.dp\n                    else -> 16.dp\n                },\n            ),\n        horizontalArrangement = Arrangement.spacedBy(\n            space = 16.dp,\n        ),\n    ) {\n\n    ... other stuff ...\n}\n```\n\n# 이론\n\n높은 사용자 정의를 목표로 하는 새로운 컴포넌트를 구축할 때에는 정교하게 계획하여 무언가를 추가하거나 완전히 독특한 외관을 만들 때 고통을 최소화하는 것이 중요합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n컴포넌트 구성의 첫 번째 규칙은 @Composable의 첫 번째 선택적 매개변수로 Modifier를 사용하는 것입니다. 이 가이드라인은 우리가 컴포넌트를 외부에서 제어할 수 있도록 해주기 때문에 중요합니다. 두 번째 Modifier를 추가해야 한다면, 함수 구조를 재검토하는 것이 좋습니다. 각 함수는 하나의 Modifier만 포함해야 한다는 가이드라인이 있어 잠재적인 함수 디자인 문제를 나타냅니다. 따라서 해당 Modifier는 루트 @Composable에만 적용되어야 합니다.\n\n컴포넌트는 UI 및 기능을 표현하는 다양한 메커니즘을 가질 수 있습니다. 필수 매개변수는 함수의 핵심 내용을 정의하고 기본값을 가지면 안 됩니다. 미리 정의된 값이 있는 선택적 매개변수는 컴포넌트에서 사용할 수도, 사용하지 않을 수도 있는 선택적 수정 사항으로 작용합니다.\n\n선택적 값을 선언하는 방법을 고려하는 것도 중요합니다. Nullable은 기능이 사용되거나 완전히 생략될 수 있다는 것을 의미합니다. 빈 구현은 기능이 필수적이지만 빈 값을 또는 사용자 정의 로직을 사용할 수 있다는 것을 의미합니다. 기본값은 비-nullable이어야 하고 명확하게 이해돼야 합니다.\n\n컴포넌트 스타일을 처리할 때, 일부 매개변수는 함수 본문 내에 남겨둘 수 있습니다. 단, 이 매개변수가 간단하고 명확하다면입니다. 그러나 보다 복잡한 컴포넌트의 경우 그룹화하는 것이 좋습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여러 논리적 블록으로 구성된 컴포넌트의 경우, 이러한 블록들은 슬롯이라고 명명됩니다. 이 접근 방식은 표준 구현을 사용하거나 우리의 필요에 맞게 확장적으로 사용할 수 있도록 유연성을 제공합니다.\n\n총괄적으로, 필수 항목을 다루었습니다. 나머지는 이후에 계속해서 다룰 것입니다.\n\n# 아름다움을 창조하다\n\n우선, 컴포넌트를 논리적으로 슬롯으로 나눕니다. 여기서 매우 명확합니다. 로고 슬롯, 정보 슬롯 및 액션 슬롯이 있습니다. 우리는 이를 기반으로 구조를 만들겠습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```html\n<img src=\"/assets/img/2024-06-23-CreatingflexiblecomponentsinCompose_10.png\" />\n\n항상 전체 이름과 연락처 사진이 있으므로 이러한 데이터는 @Composable 함수의 필수\n매개변수로 사용할 수 있습니다. 사진의 경우 Painter를 전달하여 나중에 외부에서\n사진 로드를 제어하고 @Preview에서 결과를 미리 볼 수 있게합니다. 또한 구성 요소의\n구조를 대략적으로 스케치하고 모든 슬롯을 비워 둡시다. @Composable private fun\nContactView( leadingPainter: Painter, title: String, modifier: Modifier =\nModifier, leadingView: @Composable RowScope.() -> Unit = {}, content:\n@Composable ColumnScope.() -> Unit = {}, trailingView: (@Composable RowScope.()\n-> Unit)? = null, ) { Row( modifier = modifier .sizeIn( minHeight =\nDp.Unspecified, ) .padding( horizontal = 16.dp, vertical = Dp.Unspecified, ),\nhorizontalArrangement = Arrangement.spacedBy( space = 16.dp, ), ) {\nleadingView.invoke(this) Column( modifier = Modifier\n.align(Alignment.CenterVertically), ) { content.invoke(this) }\ntrailingView?.invoke(this) } } 첫 번째 슬롯을 살펴보고 있습니다. 여기서 사진은\n항상 존재하며 정렬만 변경되므로 이러한 매개변수를 함수에 남겨두기로 하였습니다.\n그 외의 모든 것은 일정합니다.\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\n@Composable\nfun RowScope.ContactLeadingView(\n    imagePainter: Painter,\n    headerAlignment: Alignment.Vertical,\n) {\n    Image(\n        painter = imagePainter,\n        contentDescription = \"연락처 이미지\",\n        modifier = Modifier\n            .requiredSize(40.dp)\n            .clip(CircleShape)\n            .align(\n                alignment = headerAlignment,\n            ),\n    )\n}\n```\n\n두 번째 슬롯에는 미래 호환성을 보장하기 위해 제목이라는 필수 매개변수가 하나 있습니다. 이렇게 하면 성과 이름 이외의 정보를 전달해도 구조가 변경되지 않습니다.\n\n```kotlin\n@Composable\nfun ColumnScope.ContactContentView(\n    title: String,\n    header: String? = null,\n    subtitle: String? = null,\n    managerPainter: Painter? = null,\n) {\n    if (!header.isNullOrBlank()) { ... }\n\n    Text(\n        text = title,\n        color = MaterialTheme.colorScheme.onSurface,\n        style = MaterialTheme.typography.bodyMedium,\n    )\n\n    Row(\n        modifier = Modifier,\n        horizontalArrangement = Arrangement.spacedBy(\n            space = 8.dp,\n        ),\n    ) {\n        if (managerPainter != null) { ... }\n        if (!subtitle.isNullOrBlank()) { ... }\n    }\n}\n```\n\n세 번째 슬롯은 세 가지 다른 콜백을 포함하는 작업을 포함할 것입니다. 여기서는 존재 여부를 제어할 수 있도록 각각을 nullable로 표시했습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n@Composable\nfun RowScope.ContactActionsView(\n    onChatClicked: (() -> Unit)? = null,\n    onMainClicked: (() -> Unit)? = null,\n    onCallClicked: (() -> Unit)? = null,\n) {\n    Row(\n        modifier = Modifier\n            .align(Alignment.CenterVertically),\n    ) { ... }\n}\n```\n\n모든 슬롯을 조립하고 이를 함수의 기초로 선언한 후 결과적으로 구조는 다음과 같아야 합니다:\n\n```js\n@Composable\nprivate fun ContactView(\n    leadingPainter: Painter,\n    title: String,\n    modifier: Modifier = Modifier,\n    config: ContactViewConfig = ContactViewDefaults.config(),\n    leadingView: @Composable RowScope.() -> Unit = {\n        ContactLeadingView(\n            imagePainter = leadingPainter,\n            headerAlignment = config.headerAlignment,\n        )\n    },\n    content: @Composable ColumnScope.() -> Unit = {\n        ContactContentView(\n            title = title,\n        )\n    },\n    trailingView: (@Composable RowScope.() -> Unit)? = null,\n)\n```\n\n이 구조에서 새로운 추가 요소는 컴포넌트의 다양한 설정을 제어하는 ContactViewConfig입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n테이블 태그를 마크다운 형식으로 변경해주세요.\n\n```js\n// 이렇게 하지 마세요\n@Immutable\nclass ContactViewConfig internal constructor(\n    internal val minHeight: Dp,\n    internal val verticalPadding: Dp,\n    internal val headerAlignment: Alignment.Vertical,\n)\n\nobject ContactViewDefaults {\n\n    @Composable\n    fun config(\n        minHeight: Dp = 56.dp,\n        verticalPadding: Dp = 8.dp,\n        headerAlignment: Alignment.Vertical = Alignment.CenterVertically,\n    ): ContactViewConfig = ContactViewConfig(\n        minHeight = minHeight,\n        verticalPadding = verticalPadding,\n        headerAlignment = headerAlignment,\n    )\n}\n```\n\n자, 이제 구성 가능하고 작동하는 @Preview가 있는 컴포넌트가 준비되었습니다.\n\n다음에는 기본 기능을 확장하기 위해 기본 함수 위에 추가 컴포넌트를 작성할 수 있습니다. 선택 사항으로 간단한 타입 대신 도메인 클래스를 사용할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\n@Composable\nfun FullNameContactView(\n    imagePainter: Painter,\n    fullName: String,\n    modifier: Modifier = Modifier,\n) {\n    ContactView(\n        leadingPainter = imagePainter,\n        title = fullName,\n        modifier = modifier,\n    )\n}\n```\n\n```kotlin\n@Composable\nfun ActionsContactView(\n    imagePainter: Painter,\n    fullName: String,\n    modifiedTime: String,\n    modifier: Modifier = Modifier,\n    onChatClicked: (() -> Unit)? = null,\n    onMainClicked: (() -> Unit)? = null,\n    onCallClicked: (() -> Unit)? = null,\n) {\n    ContactView(\n        leadingPainter = imagePainter,\n        title = fullName,\n        modifier = modifier,\n        config = ContactViewDefaults.config(\n            minHeight = 72.dp,\n            verticalPadding = 16.dp,\n        ),\n        content = {\n            ContactContentView(\n                title = fullName,\n                subtitle = modifiedTime,\n            )\n        },\n        trailingView = {\n            ContactActionsView(\n                onChatClicked = onChatClicked,\n                onMainClicked = onMainClicked,\n                onCallClicked = onCallClicked,\n            )\n        },\n    )\n}\n```\n\n```kotlin\n@Composable\nfun DetailsContactView(\n    imagePainter: Painter,\n    managerPainter: Painter,\n    title: String,\n    fullName: String,\n    modifiedTime: String,\n    modifier: Modifier = Modifier,\n) {\n    ContactView(\n        leadingPainter = imagePainter,\n        title = fullName,\n        modifier = modifier,\n        config = ContactViewDefaults.config(\n            minHeight = 88.dp,\n            verticalPadding = 16.dp,\n            headerAlignment = Alignment.Top,\n        ),\n        content = {\n            ContactContentView(\n                title = fullName,\n                header = title,\n                subtitle = modifiedTime,\n                managerPainter = managerPainter,\n            )\n        },\n    )\n}\n```\n\n# 일부 결론\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n@Preview를 살펴보면 컴포넌트 사이에는 차이가 거의 없을 것입니다. 코드적으로도 거의 차이가 없을 것입니다. 유연한 기능과 설정을 가진 컴포넌트는 세 가지 다른 독립적인 함수만큼의 코드 라인을 차지할 것입니다. 이 글이 유연한 컴포넌트를 작성하는 방법에 대해 더 잘 이해하는 데 도움이 되었으면 좋겠습니다. 더 많은 개발을 위해 필요시 이 비디오와 코드를 살펴보시기를 권장합니다.\n\n![Creating flexible components in Compose](/assets/img/2024-06-23-CreatingflexiblecomponentsinCompose_11.png)\n","ogImage":{"url":"/assets/img/2024-06-23-CreatingflexiblecomponentsinCompose_0.png"},"coverImage":"/assets/img/2024-06-23-CreatingflexiblecomponentsinCompose_0.png","tag":["Tech"],"readingTime":18},{"title":"Shadowfax 안드로이드 앱 40 더 빠르게 만드는 방법","description":"","date":"2024-06-23 01:14","slug":"2024-06-23-MakingShadowfaxAndroidApp40faster","content":"\n![Image](/assets/img/2024-06-23-MakingShadowfaxAndroidApp40faster_0.png)\n\n# 1. 목표 설정\n\n모바일 앱 성능에는 모든 밀리초가 중요합니다. 앱이 빨리 로드될수록 사용자가 머물 가능성이 높아집니다.\n\n매일 10만 명 이상의 DAU를 보유한 Shadowfax Rider 앱은 앱이 실행되는 데 약 3.5초가 걸리는 문제에 직면했습니다!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n목표는 다음과 같이이 시간을 단축하는 것이었습니다:\n\n- 90 백분위에는 2 초\n- 중간 사용자에 대해 800ms\n\n## 2. 앱 시작 시간 측정\n\nFirebase에 따르면 앱 시작 시간은 런처에서 앱이 시작되어 첫 번째 액티비티의 `onResume()` 메서드가 호출 될 때까지의 지속 시간입니다. 이 기간은 다음과 같이 logcat에도 보고됩니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여기에서 더 많은 정보를 읽을 수 있습니다. Firebase에서 Startup 시간이 진실의 근원이었습니다.\n\n만약 onResume이 호출된 후 어떤 시점에 앱이 완전히 로드된 것으로 간주한다면 (지도가 완전히 그려진 후와 같이), 해당 시점을 시스템 및 Firebase에 Activity.reportFullyDrawn()으로 보고할 수 있습니다.\n\n만약 Perfetto를 사용하고 있다면, 나중에 그에 대해 자세히 설명하겠습니다.\n\n# 3. 자세히 들여다보기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n앱의 시작 시간을 기간별로 분해하기 위해 Firebase 성능 라이브러리의 @trace 어노테이션을 app 클래스의 onCreate() 함수, BaseActivity 및 MainActivity의 onCreate() & onStart()에 추가했어요. 기본적으로 모든 것을 최상위 수준에서 측정하므로 주요 원인을 파악하고 거기서부터 드릴다운합니다.\n\n![이미지](/assets/img/2024-06-23-MakingShadowfaxAndroidApp40faster_1.png)\n\nMain 및 Base 액티비티 이외에도 앱 클래스가 앱 시작 시간의 30%를 차지했기 때문에 2가지 작업을 수행했어요:\n\n# 3.1 라이브러리 및 콘텐츠 제공자 지연 로드 (-10% 시작 시간)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n애플리케이션 클래스는 일반적으로 많은 라이브러리를 초기화합니다. 필요하지 않은 라이브러리는 앱 시작 시 즉시 초기화하는 대신 백그라운드에서 초기화하도록 변경했습니다. Content Provider가 있다면 Startup 라이브러리를 사용하여 그것들을 나중에 로딩할 수도 있습니다.\n\n다음은 몇 가지 SDK를 백그라운드 스레드에서 초기화하는 방법입니다:\n\n```js\nclass MyApp : Application() {\n    @AddTrace(name = \"backgroundInitializationsTrace\")\n    private fun performBackgroundInitializations() {\n        runWithLooper {\n            // 메인 스레드에서 초기화가 필요하지 않은 SDK 초기화\n        }\n    }\n}\n\nobject MyUtils {\n    // 백그라운드 스레드에서 초기화를 위한 유틸리티 함수\n    fun runWithLooper(runnable: Runnable) {\n        val threadHandler = HandlerThread(\"Thread${System.currentTimeMillis()}\")\n        try {\n            threadHandler.start()\n            val handler = Handler(threadHandler.looper)\n            handler.post {\n                runnable.run()\n            }\n        } catch (e: OutOfMemoryError) {\n            firebaseCrashlytics.recordException(e)\n            runWithinMainLooper(runnable)\n        }\n    }\n    // 대체 방법\n    fun runWithinMainLooper(mainThread: Runnable) {\n        val handler = Handler(Looper.getMainLooper())\n        handler.post {\n            mainThread.run()\n        }\n    }\n}\n```\n\n# 3.2 베이스라인 프로필 (-7% 시작 시간)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nGoogle은 첫 번째 앱 시작 시간을 개선하기 위해 기본 프로필을 설정하는 것을 권장합니다. 전체 앱 시작 시간이 7% 향상되었음을 확인했습니다. 실제 결과는 다를 수 있지만 꼭 시도해 보세요.\n\n그래서 우리는 좋은 시작을 했지만 더 심층적으로 파헤쳐야 했습니다.\n\n### 4. Perfetto 사용하기\n\n안드로이드 스튜디오에서 시스템 추적을 실행하여 각 함수의 수행 시간을 측정할 수 있으며, 그런 다음 앱을 실행하고 추적을 Perfetto 비주얼라이저에 로드할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nAndroid Studio에 내장된 프로파일러를 사용할 수 있지만, Perfetto가 더 나은 탐색 및 세부 정보를 제공합니다.\n\n시스템 추적 방법은 여기에 있지만 앱 실행 시간을 프로파일링하려면 앱을 보통 실행하지 마세요. 다음과 같이 해야 합니다:\n\n- 정확한 결과를 얻기 위해 앱의 릴리스 빌드 변형을 선택하세요. 디버그 빌드 대신\n- Android Studio의 실행 버튼 근처에 있는 3점 메뉴를 클릭하세요\n- 그런 다음 \"오버헤드 낮은 상태로 앱 프로파일링\"을 선택하여 앱을 실행하세요\n- 이제 앱이 완전히 로드될 때까지 대기한 후 녹화를 중지하세요\n- 마지막으로 Profiler의 저장 아이콘을 사용하여 추적을 내보낸 다음 Perfetto Web UI로 가져오세요\n\n<img src=\"/assets/img/2024-06-23-MakingShadowfaxAndroidApp40faster_2.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n퍼페토에 추적 파일을 로드하면 화면에 수많은 색상이 나타나더라도 놀라지 마세요. 그 모든 것을 다룰 필요는 없습니다.\n\n# 4.1 퍼페토에서 시작 시간 지표 찾기\n\n![이미지](/assets/img/2024-06-23-MakingShadowfaxAndroidApp40faster_3.png)\n\n“startup”을 검색하면 앱 시작 시간의 시각화를 볼 수 있습니다. 초록 막대를 클릭한 후 키보드에서 ‘M’을 누르세요. 이렇게 하면 그 막대의 시작과 끝을 표시할 수 있습니다. 지금은 이에만 집중하고 나머지는 그냥 잡음입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 4.2 원인을 찾아보세요\n\n지금 시작 시간 막대 아래에 패키지 이름을 찾아 확장하세요. 그래프의 표시된 영역에만 집중하고 메인 스레드를 보세요. x축에 각 함수의 지속 시간이 나올 것이며, y축에 중첩된 막대가 있는 경우 중첩된 함수를 의미합니다.\n\n먼저 수평으로 긴 막대부터 살펴보세요. 그 막대가 가장 많이 소요된 시간을 나타낼 것입니다. 예상보다 시간이 더 많이 소요된 함수가 어떤 것인지 확인하고 기록해보세요. 그런 다음 상위 4~5개의 주범을 최적화할 수 있을 것입니다.\n\n![그래프](/assets/img/2024-06-23-MakingShadowfaxAndroidApp40faster_4.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n프레임은 16밀리초 내에 렌더링되어야 60fps를 달성할 수 있어요\n\n팁: WASD 키를 사용하여 이동하세요. perfetto UI에 대해 더 읽고 싶다면 여기를 확인해보세요. 문서는 약간 오래되었지만 핵심 원칙은 같아요.\n\n# 5. 토끼굴에 들어가다\n\n긴 지속 시간을 가진 함수들이 있을 수 있지만 결과물이 없을 수도 있어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저기요, 이 BaseActivity의 onResume() 메서드가 엄청 길어요. 하지만 이 그래프만으로는 무엇이 시간을 차지하는지 알 수 없어요.\n\n마지막 부분에야 전체 시간의 1/4를 차지하는 중첩 함수가 보이네요.\n\n그럼 이제 어떻게 해볼까요?\n\n![이미지](/assets/img/2024-06-23-MakingShadowfaxAndroidApp40faster_5.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n트레이싱을 더 추가해야 돼요. 자바 및 코틀린에서 사용 가능한 트레이싱 라이브러리로 쉽게 할 수 있어요. 자세한 내용은 여기를 참조할 수 있지만 코드 일부를 살펴봐요:\n\n```js\nclass MyClass {\n  fun foo(pika: String) {\n    trace(\"MyClass.foo\") {\n    // 기존의 함수 로직이 여기에 있어요...\n    }\n  }\n}\n```\n\n이제 MyClass.foo가 Perfetto에 나타날 거예요. 따라서 디버그 중인 함수 내 모든 중첩 함수에 대한 트레이싱을 추가한 후 트레이스를 다시 기록하고 Perfetto에서 분석해보세요. 각 라이프사이클 함수에 대해 이 과정을 계속 반복하세요.\n\n![이미지](/assets/img/2024-06-23-MakingShadowfaxAndroidApp40faster_6.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 6. 우리의 솔루션\n\n이 연습을 통해 매우 명확한 근본 원인과 목표를 얻었습니다. 이제 각 원인을 하나씩 해결할 때가 왔습니다. Perfetto와 SysTrace의 관측을 바탕으로 다음과 같은 다양한 최적화가 실행되었습니다:\n\n## 6.1. 홈 화면 레이아웃 최적화 (-15% 시작 시간)\n\nConstraintLayout으로 뷰를 중첩하지 않고 hidden views 대신 viewstubs를 사용하여 최대 600ms까지 감소하였습니다. 이 접근 방식은 기본적으로 숨겨져 있고 사용자 상호작용 후에만 표시되는 뷰의 불필요한 측정 및 확장을 방지합니다. view stubs에 대해 더 알아보기.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n200~300 밀리초가 걸리는 mapView가 onResume()이 호출된 후에 init으로 이동되었기 때문에 핵심 UI에서 주문 수와 상태를 표시한 후에 로드됩니다.\n\n```js\nprivate fun HomeFragment.lazyLoadMap() {\n  Handler(Looper.getMainLooper()).post {\n    // 이 Runnable은 메인 스레드가 HomeFrag를 확장한 후에만 실행됩니다.\n    initMap()\n  }\n}\n```\n\n# 6.2 MainActivity 최적화하기 (-5% 시작 시간)\n\n반복된 성능 테스트에서 LinearLayout이 Fragment에 대한 컨테이너로만 사용되는 MainActivity에서 ConstraintLayout보다 성능이 더 우수했습니다. 실제로 LinearLayout으로 변경하면 MainActivity가 특히 웜 스타트에서 2배 더 빨리 시작되었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 6.3 MainActivity SDK들의 지연 로딩(-10% 시간)\n\n퍼페토는 MainActivity에서 초기화되는 단일 3rd party SDK가 onCreate() 지속 시간의 70%를 차지하고 있다는 것을 보여주었습니다. 우리는 앱 시작 시 즉시 필요하지 않았기 때문에 백그라운드에서 이를 지연로딩하기 시작했습니다.\n\n## 7. 실제 성능 결과\n\n이러한 솔루션을 여러 릴리스를 통해 출시한 뒤, 시작 시간의 90분위가 3.5초에서 거의 2초 미만으로 점진적으로 개선되어, 놀라운 42%의 감소를 보았습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![image](/assets/img/2024-06-23-MakingShadowfaxAndroidApp40faster_7.png)\n\n더 많은 병목 현상을 찾고 앱 속도를 높이는 데 노력하고 있습니다. 이를 통해 파트너들이 더 생산적일 수 있도록 돕고 있습니다.\n\n프레펫토를 사용하여 병목 현상을 발견하는 것은이 프로젝트에 있어 중요했으며, 각 문제를 해결함으로써 얼마나 많은 성능 향상을 이끌어낼 수 있는지를 알기에 자신감을 갖게 되었습니다.\n\n앱 시작 시간을 개선하는 데 도움을 준 Burhan & Vishnu에게 감사드립니다.\n","ogImage":{"url":"/assets/img/2024-06-23-MakingShadowfaxAndroidApp40faster_0.png"},"coverImage":"/assets/img/2024-06-23-MakingShadowfaxAndroidApp40faster_0.png","tag":["Tech"],"readingTime":10}],"page":"17","totalPageCount":113,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true}