{"pageProps":{"posts":[{"title":"Java 경험 개발자 선도 개발자 인터뷰 질문 목록 이 기사에서 10개 이상의 회사 질문이 다루어집니다","description":"","date":"2024-05-18 15:12","slug":"2024-05-18-JavaExperienceDeveloperLeadDeveloperInterviewQuestionsListInthisarticlemorethan10companiesquestioniscovered","content":"\n![이미지](/assets/img/2024-05-18-JavaExperienceDeveloperLeadDeveloperInterviewQuestionsListInthisarticlemorethan10companiesquestioniscovered_0.png)\n\n참고: Java/Spring boot는 한 기사에서 다루기에 매우 방대한 기술 스택이지만, 저는 현재까지 받은 모든 인터뷰 질문을 최대한 포함하려고 노력했습니다. 따라서 여러분도 동일한 것을 참고하여 본인의 준비 상황을 점검할 수 있습니다. 모든 질문에 대한 해결책을 제공하기 위해 다른 기사를 작성해 달라면, 댓글에 귀중한 의견을 남겨주세요.\n\nQuestions\n\n![이미지](/assets/img/2024-05-18-JavaExperienceDeveloperLeadDeveloperInterviewQuestionsListInthisarticlemorethan10companiesquestioniscovered_1.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n질문 1: 스트림 API를 통해 동시 수정을 시뮬레이션하는 방법은 무엇인가요?\n\n질문 2: 병렬 스트림을 위해 열리는 스레드의 수는 얼마이고, 병렬 스트림은 내부적으로 어떻게 작동하나요?\n\n질문 3: Executor는 쓰레드 풀 Executor의 내부 작업에 대해 어떻게 쓰레드가 활성화되거나 종료되었는지 확인하나요?\n\n질문 4: JAVA 메모리 모델에 대해 간략히 설명해 주실 수 있나요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nQuestion 5: JDK 8에서 pegmen의 변경 사항은 무엇인가요? (PermGen과 Meta)\n\nQuestion 6: 일반 REST 서비스와 Restful WS(웹 서비스)의 차이는 무엇인가요?\n\nQuestion 7: 다양한 종류의 Http 메소드는 무엇이 있고 그 차이는 무엇인가요?\n\nQuestion 8: DDOS(서비스 거부) 공격이란 무엇이며, 이를 어떻게 애플리케이션에서 방지할 수 있을까요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n질문 9: 메소드 참조(Method Reference)와 함수형 인터페이스에 대해 설명해주세요.\n\n질문 10: 자바 8에서 기본/정적 메소드에 대한 오버라이드 규칙을 정의해주세요.\n\n질문 11: 주로 JAVA 디자인 패턴과 관련된 질문입니다.\n생성 디자인 패턴\ni) 싱글턴(Singleton)\nii) 빌더(Builder)\niii) 팩토리(Factory)\niv) 프로토타입(Prototype)\n\n구조 디자인 패턴\ni) 어댑터(Adaptor)\nii) 브릿지(Bridge)\niii) 프록시(Proxy)\niv) 데코레이터(Decorator)\n\n행위 디자인 패턴\ni) 책임 연쇄(Chain of Responsibility)\nii) 옵저버(Observer)\niii) 전략(Strategy)\n\n질문 12: API를 어떻게 보안할 것인가요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n질문 13: hashcode()와 equals()에 대해 간단히 설명해 주세요. 이어지는 질문은 사용자 지정 객체를 사용할 때 둘 중 하나만 재정의하고 다른 하나는 재정의하지 않았을 때의 상황을 어떻게 이해하시겠습니까?\n\n질문 14: HashMap과 HashSet의 내부 작업 방식은 무엇인가요?\n\n질문 15: 스프링 부트 마이크로서비스 프로젝트에서 캐시를 활성화하는 방법이 무엇이며, 동일한 기능을 구현하기 위해 사용할 수 있는 어노테이션은 무엇이 있나요?\n\n질문 16: Kafka의 작동 방식과 Kafka 사용 시 컨슈머 그룹이 무엇인지 설명해 주세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n질문 17: 귀하의 마이크로서비스 애플리케이션을 설계하는 데 어떤 디자인 패턴을 사용했는지 알려주세요. 주로\ni) 서킷 브레이커\nii) 사가\niii) CQRS\niv) 이중 커밋\n\n질문 18: 데이터베이스 샤딩이란?\n\n질문 19: (RDBMS) SQL과 NoSQL의 차이점은 무엇인가요?\n\n질문 20: Apache Spark는 무엇이며, Spring Boot 애플리케이션에서 Apache Spark의 사용 용도는 무엇인가요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n질문 21: 스프링 부트 마이크로서비스 애플리케이션에서 traceId와 span Id는 무엇이며, 이러한 식별자의 사용 목적은 무엇인가요?\n\n질문 22: 스프링 부트에서 웹플럭스(webflux)와 모노(mono)가 무엇인가요?\n\n질문 23: 사용자 정의 불변 클래스를 어떻게 생성하시겠습니까? 후속 질문으로 String이 불변 클래스임을 코드 조각으로 증명할 수 있나요?\n\n질문 24: 컬렉션 클래스의 시간/공간 복잡성과 내부 데이터 구조의 이름을 나열해 주실 수 있나요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n질문 25 : 귀하의 애플리케이션에서 사용한 모든 동시 컬렉션 클래스 및 Java 8 이후 컬렉션 클래스의 개선 사항은 무엇인가요?\n\n질문 26 : 자바 8에서 IO에 대한 모든 개선 사항은 무엇인가요?\n\n질문 27 : 스프링 부트에서 자동 구성을 활성화하고 비활성화하는 방법은 무엇인가요?\n\n질문 28 : 액추에이터의 사용 목적은 무엇이며, 같은 것을 어떻게 사용자 정의할 수 있나요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n질문 29 : 사용자 정의 어노테이션을 어떻게 만드나요?\n\n질문 30 : 쿠버네티스를 사용하는 이유와 쿠버네티스의 클러스터, 노드, POD 등에 대해 설명해주실래요?\n\n질문 31 : 응용 프로그램 내구성을 위해 어떤 것을 사용하실 건가요?\n\n질문 32 : 테이블에 이름, id 열이 있는 데이터베이스 테이블이 있다면 짝수 행을 찾는 쿼리를 작성해주세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n질문 33 : Arrays.sort(..)와 Collections.sort(..)에서 사용되는 알고리즘의 이름은 무엇인가요?\n\n질문 34 : serialVersionUID를 왜 사용하나요?\n\n질문 35 : 스프링에서 순환 종속성(cyclic dependency)을 어떻게 방지할 수 있나요?\n\n질문 36 : 도커 이미지의 크기를 줄일 수 있을까요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n질문 37: 싱글톤 클래스를 어떻게 파괴할 수 있나요? 싱글 객체 생성 전략은 무엇인가요?\n\n질문 38: 깊은 복사와 얕은 복사는 무엇이며 Cloanable 인터페이스의 사용 예시는 무엇인가요?\n\n질문 39: 객체 생성에 생성자 대신 빌더 디자인 패턴을 사용하는 이유는 무엇인가요?\n\n질문 40: Spring Boot에서 HTTP 메소드 유형 변경 없이 두 가지 모호한 URL을 작동하게 하는 방법은 무엇인가요? URL을 변경하지 않고도 변경을 수락하지 않을 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n문제 41 : 애플리케이션 배포 구조는 어떻습니까?\n\n문제 42 : CompletableFuture의 사용법을 설명해주세요.\n\n문제 43 : Java 8에서 String.join(….)의 사용법은?\n\n코딩 문제\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-05-18-JavaExperienceDeveloperLeadDeveloperInterviewQuestionsListInthisarticlemorethan10companiesquestioniscovered_2.png\" />\n\n질문 1 : 문자열 목록에서 중복 문자를 찾는 프로그램을 작성하십시오. Java 스트림만 허용됩니다.\n\n질문 2 : 주어진 문자열에서 중복 요소와 해당 발생을 찾으십시오. Java 스트림만 허용됩니다.\n\n질문 3 : 0과 1의 배열이 있습니다. 모든 0은 왼쪽에 모든 1은 오른쪽에 위치하도록 유지하십시오.\n예 : Integer array[] =[1,1,0,1,0] - 출력 : [0,0,1,1,1]\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nQuestion 4: 주어진 입력에서 연속된 숫자 시퀀스를 찾으세요. 모든 가능한 테스트를 제공해 주세요.\n예시: 입력 1 2 3 5 9 a 6 7 8 4 @ -5 -7 -3 -2 -1\n결과:\n1 2 3\n6 7 8\n-3 -2 -1\n\nQuestion 5: 주어진 맵에서 N번째로 높은 연봉을 찾으세요. Java 8 스트림 솔루션이 허용됩니다.\n예시:\n학생은 이름과 연봉을 가지고 있습니다.\n맵은 Map`String, Student`와 같이 될 것입니다.\n\nQuestion 6: N명의 학생 목록이 주어지며, 각 학생은 M과목에 대해 점수가 있습니다. 각 학생은 인덱스 값으로 표시됩니다. 선생님 Ms. Margaret은 모든 학생에 대해 1과목의 점수를 무시해야 합니다. 이를 위해 각 학생의 최하 점수를 무시하기로 결정합니다. 여러분의 임무는 그 과목을 찾고, 다른 모든 과목에서 각 학생이 얻은 총점을 계산하여 마지막으로 각 학생이 얻은 총 점수 배열을 반환하는 데 도움을 주는 것입니다.\n입력 사양:\ninput1:\n학생 수를 나타내는 정수 값 N\ninput2:\n과목 수를 나타내는 정수 값 M\ninput3:\n각 과목의 모든 학생의 점수를 포함하는 크기가 N’M인 2-D 정수 배열입니다.\n출력 사양:\n각 학생의 총 점수를 과목 점수를 차감한 후 반환하는 크기가 N인 정수 배열을 반환합니다.\n입력:\n3 5\n75 76 65 87 87\n78 76 68 56 89\n67 87 78 77 65\n결과:\n325 299 296\n\nQuestion 7: JAVA 스트림을 사용하여 주어진 문자열에서 고유한 요소를 찾는 프로그램을 작성하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nQuestion 8: 주어진 문자열에서 첫 번째로 반복되지 않는 요소를 Java Streams로 찾는 프로그램을 작성해주세요.\n\nQuestion 9: 요소가 중복될 수 있는 배열에서 두 번째로 높은 요소를 찾는 프로그램을 Java 8 Stream으로 해결해주세요.\n\nQuestion 10: 주어진 문자열에서 처음으로 반복되는 요소/문자를 Java Streams로 찾는 프로그램을 작성해주세요.\n\nQuestion 11: 주어진 배열에서 가장 긴 문자열을 찾는 프로그램을 작성해주세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nQuestion 12: 배열에서 2로 시작하는 모든 요소를 Stream API를 사용하여 찾는 Java 프로그램을 작성하십시오.\n\nQuestion 13: 식 문자열 'exp'가 주어졌을 때, 주어진 식에서 \" ' \", \" ' \", \" ( \", \" ) \", \" [ \", \" ] \"의 쌍과 순서가 올바른지 확인하는 프로그램을 작성하십시오.\n\n예시:\n\n```java\npublic class CodingProblem13 {\n public static void main(String[] args) {\n  String inputString = \"[(]{}{[()()]()}\"; // 이 문자열이 균형 잡힌 괄호 문자열인지 확인해야 함\n  System.out.println(\"Result:::\" + isBalancedInput(inputString));\n }\n\n private static String isBalancedInput(String input) {\n  Deque<Character> stack = new ArrayDeque<>();\n  for (int i = 0; i < input.length(); i++) {\n    if (!(input.charAt(i) == '}' || input.charAt(i) == ']' || input.charAt(i) == ')')) {\n      stack.push(input.charAt(i));\n    }\n\n    if ((input.charAt(i) == '}' || input.charAt(i) == ']' || input.charAt(i) == ')')) {\n      if (stack.isEmpty()) {\n        return \"Not Balanced \";\n      }\n      char top = stack.pop();\n\n      if ((input.charAt(i) == ')' && top != '(') || (input.charAt(i) == ']' && top != '[') || (input.charAt(i) == '}' && top != '{')) {\n        return \"Not Balanced \";\n      }\n    }\n  }\n  return stack.isEmpty() ? \"Balanced\" : \"Not Balanced \";\n }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 문서를 읽어 주셔서 감사합니다. 동일한 내용에 대한 소준하고 유익한 피드백/제안을 제공해 주시면 감사하겠습니다.\n\n면접 준비와 인터뷰에 행운이 있기를 바랍니다................\n\n이 문서에 박수를 잊지 마세요.\n\n또 다른 지식 공유 콘텐츠를 살펴볼 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-05-18-JavaExperienceDeveloperLeadDeveloperInterviewQuestionsListInthisarticlemorethan10companiesquestioniscovered_0.png"},"coverImage":"/assets/img/2024-05-18-JavaExperienceDeveloperLeadDeveloperInterviewQuestionsListInthisarticlemorethan10companiesquestioniscovered_0.png","tag":["Tech"],"readingTime":11},{"title":"소프트웨어 품질 보증  데이터베이스와의 시스템 통합 검증 방법","description":"","date":"2024-05-18 15:10","slug":"2024-05-18-SoftwarequalityassuranceHowtoverifysystemintegrationwithdatabases","content":"\n![이미지](/assets/img/2024-05-18-SoftwarequalityassuranceHowtoverifysystemintegrationwithdatabases_0.png)\n\n소프트웨어 개발의 성공에는 테스트가 중요합니다. 소프트웨어 엔지니어들은 대부분의 시간을 자동화된 테스트 작성에 할애합니다. 비교적으로, 비즈니스 로직 개발에 소요되는 시간은 그리 많지 않습니다.\n\n테스트는 소프트웨어 전달에서 중요한 역할을 하므로, 테스팅 지식은 소프트웨어 엔지니어로서의 채용 면접에서 표준 질문이 되었습니다. 가끔 지원자 중 일부는 데이터베이스 통합의 품질을 어떻게 보증할지에 대해 대답하지 못하는 경우가 있습니다.\n\n데이터베이스는 대부분의 시스템에서 중요한 구성 요소입니다. 데이터베이스와 통신하기 위한 일반적인 설계 패턴은 액세스 요청을 SQL 쿼리로 변환하기 위한 데이터 액세스 계층을 갖는 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 다이어그램은 API 엔드포인트, 비즈니스 로직 및 데이터 액세스를 별도의 레이어로 분리하는 전통적인 디자인 패턴을 보여줍니다. 비즈니스 로직은 데이터 액세스 레이어에 의존하여 데이터베이스에서 읽기/쓰기 작업을 수행합니다.\n\n![이미지](/assets/img/2024-05-18-SoftwarequalityassuranceHowtoverifysystemintegrationwithdatabases_1.png)\n\n테스트할 때, 데이터 액세스 레이어의 SQL 쿼리가 올바른지 어떻게 확인할까요?\n\n최근 취업 면접에서 소프트웨어 엔지니어와 이야기를 나눴습니다. 몇 년의 경험이 있더라도 자동화된 테스트가 표준적인 실천 방법이 되었음에도 불구하고 데이터 액세스 레이어에 대한 통합 테스트를 어떻게 구현하는지 알지 못하는 사람들도 있음을 깨달았습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우선, 통합 테스트는 단위 테스트와 유사합니다. 테스트 범위는 예를 들어 데이터 액세스 레이어와 같은 단일 컴포넌트에 집중됩니다. 그러나 차이점은 단위 테스트에서 하는 것처럼 가짜 데이터베이스를 만들 수 없다는 것입니다. 대신, 독립 실행형 데이터베이스 엔진을 시작하여 데이터베이스와 상호 작용을 확인해야 합니다.\n\n![이미지](/assets/img/2024-05-18-SoftwarequalityassuranceHowtoverifysystemintegrationwithdatabases_2.png)\n\n이 글에서 데이터 액세스 레이어에 대한 자동화된 테스트를 구현하는 2가지 다른 방법을 공유하겠습니다. 작업 방식을 더 잘 이해하도록 샘플 코드는 스프링 프레임워크를 사용하지 않고 모두 일반 자바 코드로 작성되어 있습니다.\n\n# 샘플 데이터 스키마\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n직원 레코드의 간단한 데이터베이스 스키마를 기반으로 한 통합 테스트의 구현을 보여드리겠습니다. 직원 레코드에는 다음과 같은 데이터 필드가 포함되어 있습니다: 고유 식별자, 이름, 급여 및 부서.\n\n```js\nCREATE TABLE EMPLOYEE (\n   id int,\n   name varchar(255),\n   department varchar(255),\n   salary decimal(14,2),\n   primary key (id)\n);\n```\n\n다음과 같은 함수를 제공하는 데이터 액세스 레이어가 있습니다:\n\n- 직원 레코드 삽입\n- ID에 따른 직원 레코드 검색\n- 부서에 따른 직원 레코드 검색\n- 부서별 평균 급여 검색\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nGitHub 레포지토리의 전체 소스 코드는 다음 링크를 참조해 주세요 (https://github.com/gavinklfong/data-access-layer-test-demo).\n\n# 내부 메모리 데이터베이스\n\n이 아이디어는 컴포넌트가 테스트하는 데 연결할 수 있는 일회용 데이터베이스를 시작하는 것입니다. 가벼운 내부 메모리 데이터베이스 엔진을 실행하는 것은 통합 테스트를 신속하게 실행하는 빠른 방법입니다. 이는 데이터베이스가 디스크의 읽기/쓰기 없이 메모리에서만 작동하기 때문에 빠릅니다. 테스트 실행이 끝나면 데이터베이스를 파기하고 버릴 수 있습니다.\n\nH2 데이터베이스는 인기 있는 내부 메모리 데이터베이스입니다. H2 데이터베이스를 활성화하려면 Maven의 pom.xml에 이 의존성을 추가하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nH2 데이터베이스에서 테스트를 실행하는 것은 정말 편리합니다. 데이터베이스 시작업이 필요 없습니다. JDBC 연결 문자열 jdbc:h2:mem:testdb;DB_CLOSE_DELAY=-1;MODEL=MYSQL을 사용하여 데이터베이스 연결을 생성하면 H2 데이터베이스가 자동으로 시작됩니다.\n\n다음 2가지 매개변수로 인메모리 데이터베이스가 생성된 것을 알 수 있습니다:\n\n- DB_CLOSE_DELAY=-1 — JVM이 종료될 때까지 데이터베이스를 유지하려면 이 매개변수가 필요합니다.\n- MODEL=MYSQL — 실제 환경에서 사용되는 MYSQL과 SQL 구문을 호환되게 만듭니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n테스트 시나리오에서 데이터베이스는 일반적으로 모두 공유되며, 데이터베이스 연결은 정적 멤버로 설정되어 있습니다. 처음에는 직원 테이블을 생성하는 schema.sql을 실행합니다.\n\n이 예에서는 경량 라이브러리 JDBI를 사용하여 데이터베이스 연결 및 쿼리 실행을 합니다.\n\n```js\nclass EmployeeDaoInMemoryH2Test {\n\n   // 인메모리 데이터베이스에 연결\n   private static final Jdbi jdbi = Jdbi\n           .create(\"jdbc:h2:mem:testdb;DB_CLOSE_DELAY=-1;MODE=MYSQL\");\n\n   private EmployeeDao employeeDao;\n\n   @BeforeAll\n   static void setupAll() {\n       // 테이블 설정\n       jdbi.withHandle(handle ->\n               handle.createScript(ClasspathSqlLocator\n                        .removingComments().getResource(\"schema.sql\"))\n                        .execute()\n       );\n   }\n\n   @BeforeEach\n   void setup() {\n       employeeDao = new EmployeeDao(jdbi);\n\n       // 클린업 및 테스트 데이터 다시 삽입\n       jdbi.withHandle(handle ->\n               handle.createScript(ClasspathSqlLocator\n                        .removingComments().getResource(\"employee.sql\"))\n                        .execute()\n       );\n   }\n\n\n// ... 테스트 시나리오 ...\n\n}\n```\n\n각 테스트 시나리오 시작 전에 data.sql이 실행되어 직원 테이블의 모든 레코드가 정리되고 테스트 레코드가 다시 삽입됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nDELETE FROM EMPLOYEE;\n\nINSERT INTO EMPLOYEE(id, name, department, salary)\n  VALUES (1, 'Rueben Hardy', 'FINANCE', 1291.8);\nINSERT INTO EMPLOYEE(id, name, department, salary)\n  VALUES (2, 'Frank Dunlap', 'FINANCE', 10025.3);\nINSERT INTO EMPLOYEE(id, name, department, salary)\n  VALUES (3, 'Anna Melendez', 'FINANCE', 8773.13);\nINSERT INTO EMPLOYEE(id, name, department, salary)\n  VALUES (4, 'Joan Riggs', 'OPERATION', 6597.89);\nINSERT INTO EMPLOYEE(id, name, department, salary)\n  VALUES (5, 'April Davidson', 'OPERATION', 1563.19);\nINSERT INTO EMPLOYEE(id, name, department, salary)\n  VALUES (6, 'Molly Woodward', 'MARKETING', 10442.24);\nINSERT INTO EMPLOYEE(id, name, department, salary)\n  VALUES (7, 'Roisin Noble', 'MARKETING', 7288.92);\nINSERT INTO EMPLOYEE(id, name, department, salary)\n  VALUES (8, 'Abdullahi Morse', 'MARKETING', 1635.55);\nINSERT INTO EMPLOYEE(id, name, department, salary)\n  VALUES (9, 'Gina Shepard', 'SALES', 7703);\nINSERT INTO EMPLOYEE(id, name, department, salary)\n  VALUES (10, 'Cecil Burch', 'SALES', 3422.67);\n```\n\n스키마와 테스트 데이터가 준비되면, 테스트 시나리오 구현은 직관적일 것입니다. 결과를 확인하려면 직관적인 SQL을 사용하는 것이 좋습니다.\n\n# 데이터 설정 및 테스트 결과 확인 방법\n\n데이터 액세스 계층이 테스트 중이므로, 데이터 액세스 계층의 시스템 동작이 완전히 테스트되기 전에는 보장되지 않습니다. 따라서, 데이터 설정 및 확인은 데이터 액세스 계층의 메서드를 호출하는 대신 직접적인 SQL을 사용하여 수행해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그러므로 데이터베이스 테스트 데이터 설정은 데이터 액세스 계층의 insertEmployee()를 사용하는 대신 SQL 스크립트 파일로 수행됩니다.\n\n또한, 데이터 액세스 계층의 insertEmployee()를 확인하는 것이 더 좋은 방법은 일반 SQL을 사용하는 것입니다. 아래 예시는 getEmployeeById()를 호출하여 삽입된 직원 레코드를 확인하는 것은 좋은 방법이 아닙니다. 이는 getEmployeeById()가 정상 작동하는지 알 수 없기 때문입니다. 레코드 검색 함수에 잠재적인 결함이 있는 경우 정확하지 않은 테스트 결과를 생성할 수 있습니다.\n\n```js\n@Test\nvoid testInsertEmployee() {\n   Employee newEmployee = Employee.builder()\n           .id(99)\n           .name(\"Gina Bond\")\n           .department(\"MARKETING\")\n           .salary(new BigDecimal(\"3425.5\"))\n           .build();\n\n   // 새 직원 입력 테스트\n   assertThat(employeeDao.insertEmployee(newEmployee)).isEqualTo(1);\n\n   // 이것은 좋은 방법이 아닙니다\n   // getEmployeeById()를 사용하여 삽입된 레코드 확인\n   assertThat(employeeDao.getEmployeeById(99))\n          .isNotEmpty()\n          .contains(newEmployee);\n}\n```\n\n대안으로, 새로 삽입된 레코드를 검색하기 위한 일반 SQL을 사용하는 것이 더 안전한 방법입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n@Test\nvoid testInsertEmployee() {\n   Employee newEmployee = Employee.builder()\n           .id(99)\n          .name(\"Gina Bond\")\n           .department(\"MARKETING\")\n           .salary(new BigDecimal(\"3425.5\"))\n           .build();\n\n   assertThat(employeeDao.insertEmployee(newEmployee)).isEqualTo(1);\n\n   // verify test result using plain SQL\n   Optional<Employee> insertedRecord = jdbi.withHandle(handle ->\n           handle.createQuery(\"SELECT id, name, department, salary \" +\n                           \"FROM EMPLOYEE \" +\n                           \"WHERE id = :id\")\n                   .bind(\"id\", 99)\n                   .mapToBean(Employee.class)\n                   .findOne());\n\n   assertThat(insertedRecord).isNotEmpty()\n           .contains(newEmployee);\n}\n```\n\n# 도커 컨테이너 내의 실제 데이터베이스\n\nH2 데이터베이스가 지원하는 MySQL 호환 모델에도 불구하고, 시스템 동작은 아직 실제 MySQL 데이터베이스와 완전히 동일하지는 않습니다. MySQL 데이터베이스와 진지하게 테스트를 하려면 도커 컨테이너 내에서 MySQL 데이터베이스를 이용하는 것이 합리적인 선택입니다.\n\n이 개념은 인메모리 데이터베이스 사용과 유사합니다. 데이터베이스를 메모리에서 실행하는 대신, 도커 컨테이너에서 데이터베이스를 생성합니다. 그런 다음 테스트가 완료되면 컨테이너를 정지하고 제거합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n도커 컨테이너에서 데이터베이스를 실행함으로써 목표 데이터베이스에 대한 데이터 액세스 레이어를 테스트할 수 있는 이점을 누릴 수 있어요. 이는 시스템 동작이 실제 환경의 데이터베이스에 가까워짐을 의미합니다.\n\nTestcontainers는 도커 컨테이너를 테스트하기 위한 간편한 방법을 제공하는 멋진 라이브러리에요. MySQL 컨테이너를 실행하기 위해 Maven pom.xml에 이 종속성을 추가하세요.\n\n```js\n<dependency>\n  <groupId>org.testcontainers</groupId>\n  <artifactId>mysql</artifactId>\n  <scope>test</scope>\n</dependency>\n```\n\n각 테스트 시나리오마다 MySQL 데이터베이스를 시작하는 것은 가능하지만, 새로운 도커 컨테이너를 각 시나리오 전에 시작해야 하므로 권장하지 않아요. 도커 컨테이너는 시작하는 데 훨씬 더 오랜 시간이 걸리기 때문에 컴퓨팅 성능에 따라 약 4~5초가 소요될 수 있어요. 그리고 각 시나리오 전에 새 도커 컨테이너를 시작해야 한다면 10가지 테스트 시나리오를 실행하는 데 약 50초가 소요될 수 있어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n테스트 요구사항이 특별하지 않다면, 일반적인 관행은 MySQL 도커 컨테이너를 시작하고 모든 테스트 시나리오가 동일한 데이터베이스를 공유하도록하는 것입니다.\n\n따라서 MySQLContainer는 정적 멤버로 정의됩니다. 초기 스크립트인 schema.sql을 지정하여 컨테이너가 실행된 직후 employee 테이블이 생성됩니다.\n\n컨테이너 라이프사이클을 관리하기 위해 JUnit 어노테이션 @BeforeAll을 사용하여 컨테이너를 시작합니다. 모든 테스트 시나리오가 완료된 후 @AfterAll을 사용하여 컨테이너를 중지하고 각 테스트 시나리오 전에 데이터를 재설정합니다.\n\n```js\nclass EmployeeDaoMySQLTestContainersTest {\n\n  private static final MySQLContainer<?> MYSQL_CONTAINER =\n           new MySQLContainer<>(DockerImageName.parse(\"mysql:latest\"))\n                   .withInitScript(\"schema.sql\");\n\n  private Jdbi jdbi;\n\n  private EmployeeDao employeeDao;\n\n  @BeforeAll\n  static void beforeAll() {\n     MYSQL_CONTAINER.start();\n  }\n\n  @AfterAll\n  static void afterAll() {\n     MYSQL_CONTAINER.stop();\n  }\n\n  @BeforeEach\n  void setup() {\n     jdbi = Jdbi.create(MYSQL_CONTAINER.getJdbcUrl(),\n             MYSQL_CONTAINER.getUsername(), MYSQL_CONTAINER.getPassword());\n\n     employeeDao = new EmployeeDao(jdbi);\n\n     jdbi.withHandle(handle ->\n         handle.createScript(ClasspathSqlLocator\n                 .removingComments().getResource(\"employee.sql\"))\n                 .execute()\n  );\n}\n\n// 테스트 시나리오 ...\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n컨테이너의 라이프사이클 관리를 간소화하기 위해 testcontainers 라이브러리는 @Testcontainers와 @Container 어노테이션을 제공합니다.\n\nJUnit 5에서 testcontainers를 지원하기 위해 다음 의존성을 추가해주세요.\n\n```js\n<dependency>\n  <groupId>org.testcontainers</groupId>\n  <artifactId>junit-jupiter</artifactId>\n  <scope>test</scope>\n</dependency>\n```\n\n테스트 클래스에 @Testcontainers를 넣고 MySQLContainer에 @Container를 추가하면, @BeforeAll 및 @AfterAll을 사용하여 컨테이너를 시작 및 중지할 필요가 없어집니다. 컨테이너는 자동으로 시작되며, 모든 테스트 시나리오가 완료된 후에 중지됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```java\n@Testcontainers\nclass EmployeeDaoMySQLTestContainersAnnotationTest {\n\n   @Container\n   private static final MySQLContainer<?> MYSQL_CONTAINER =\n           new MySQLContainer<>(DockerImageName.parse(\"mysql:latest\"))\n                   .withInitScript(\"schema.sql\");\n\n     @BeforeEach\n     Private setup() {\n\n      }\n\n   // … test scenarios …\n}\n```\n\n# 마지막으로\n\n통합 테스트와 단위 테스트는 같은 개념을 공유하지만, 두 유형 모두 일부 의존성에 대한 모의/스터브화된 특정 수준의 구성요소에 중점을 둡니다.\n\n그러나 데이터베이스를 사용한 통합 테스트는 약간 다릅니다. 올바른 테스트를 수행하기 위해 실제 데이터베이스 엔진이 필요합니다. 이 글은 테스트를 원활하게 실행하기 위해 스키마 설정이 포함된 일회용 데이터베이스를 생성하는 방법에 대한 간략한 개요와 기술을 제공합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음 GitHub 저장소(https://github.com/gavinklfong/data-access-layer-test-demo)를 참조하시면 전체 소스 코드를 확인하실 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-05-18-SoftwarequalityassuranceHowtoverifysystemintegrationwithdatabases_0.png"},"coverImage":"/assets/img/2024-05-18-SoftwarequalityassuranceHowtoverifysystemintegrationwithdatabases_0.png","tag":["Tech"],"readingTime":14},{"title":"자바 프로젝트를 업그레이드해보세요","description":"","date":"2024-05-18 15:08","slug":"2024-05-18-UpgradeYourJavaProject","content":"\n안녕 친구들,\n\n오늘의 글에서는 Java 프로젝트를 업그레이드하는 과정과 그 과정에서 마주칠 수 있는 일반적인 문제와 그 해결책에 대해 이야기하고 싶습니다. 우선가장 먼저, 그러한 업그레이드 프로세스 중에 종종 발생하는 기본 문제들에 대해 다뤄보겠습니다. 이러한 문제들은 각 프로젝트의 독특한 성격 때문에 일반적인 해결책이 없을 수 있지만, 이해하고 작업 계획을 수립함으로써 더 효과적으로 이러한 문제를 해결할 수 있습니다.\n\nJava 프로젝트를 업그레이드할 때 취해야 할 단계는 다음과 같습니다:\n\n![UpgradeYourJavaProject_0](/assets/img/2024-05-18-UpgradeYourJavaProject_0.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nIDE 버전 확인: 통합 개발 환경(IDE)이 Java 버전 업그레이드를 지원하는지 확인하세요. IDE의 컴파일러 설정에서이 정보를 일반적으로 찾을 수 있으며 IDE가 컴파일 할 수있는 Java 버전을 보여줍니다. 그러나 IDE가 Java 21 SDK를 제공한다고하여 해당 버전을 지원하거나 컴파일에 사용한다는 의미는 아닙니다. 프로젝트가 컴파일될 Java 버전을 개별적으로 확인하는 것이 중요합니다.\n\n![이미지](/assets/img/2024-05-18-UpgradeYourJavaProject_1.png)\n\n확장 프로그램 확인: 현재 IDE가 적합하지 않은 경우에는 적절한 IDE 버전을 찾은 후 이전 IDE에서 사용한 확장 프로그램이 새 IDE에서 사용 가능한지 확인하세요. 이러한 확장 프로그램이 업그레이드할 Java 버전을 지원하는지 확인하십시오. 그렇지 않은 경우 대안적인 솔루션을 탐색해야 할 수도 있습니다.\n\n![이미지](/assets/img/2024-05-18-UpgradeYourJavaProject_2.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n프로젝트 의존성: 모든 것이 정리되고, 프로젝트가 깨끗한 상태라면, 순환 의존성 문제가 발생할 수 있습니다. 프로젝트 A는 프로젝트 B에 의존할 수 있고, 그 프로젝트 B는 다시 프로젝트 C에 의존할 수 있으며, C도 A에 의존할 경우 순환 의존성이 발생합니다. 이러한 경우에는 소매를 걷어 올리고 이러한 의존성을 정리해야 합니다. 시작점으로 모든 다른 프로젝트에 독립적인 핵심 프로젝트를 생성하는 것이 도움이 될 수 있지만, 너무 많은 것으로 넘치지 않도록 주의해야 합니다.\n\n![UpgradeYourJavaProject_3](/assets/img/2024-05-18-UpgradeYourJavaProject_3.png)\n\n코드 리뷰: 기존 코드베이스가 업그레이드할 Java 버전과 호환되는지 확인하기 위해 철저한 코드 리뷰를 수행하세요. 희귀하지만, 제거된 라이브러리나 수정된 메서드와 같은 문제가 발생할 수 있습니다. ChatGPT와 같은 도구를 사용하여 코드를 적절하게 조정하는 데 도움을 받을 수 있습니다.\n\n![UpgradeYourJavaProject_4](/assets/img/2024-05-18-UpgradeYourJavaProject_4.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n의존성 관리: 모든 것을 정리한 후에, 업그레이드할 Java 버전과 호환되는지 확인해야 할 제3자 API를 사용하는지 확인해야 합니다. 그렇지 않으면 호환되는 대체품을 찾아야 할 수 있으며, 때로는 어려운 과제가 될 수 있습니다.\n\n![이미지](/assets/img/2024-05-18-UpgradeYourJavaProject_5.png)\n\n마지막으로 이러한 단계를 완료한 후 최종 테스트를 수행하고 프로젝트를 운영 환경에 배포하여 프로세스를 마무리합니다. 이 단계는 실제 시스템과 새로 업그레이드된 시스템의 신뢰성, 성능 및 장점 사이의 불일치를 다루는 것이 어려울 수 있습니다.\n\n이러한 단계를 따르고 어려움을 평가하여 스스로의 로드맵을 작성할 수 있습니다. 이 프로세스는 종종 일회성 일 수 있으므로 세심한 계획 및 실행이 중요합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n행운을 빕니다!\n","ogImage":{"url":"/assets/img/2024-05-18-UpgradeYourJavaProject_0.png"},"coverImage":"/assets/img/2024-05-18-UpgradeYourJavaProject_0.png","tag":["Tech"],"readingTime":4},{"title":"스페인 항공사 이베리아, 얼굴 인식 시스템 시범운영","description":"","date":"2024-05-17 20:20","slug":"2024-05-17-SpanishcarrierIberiatrialsfacialrecognitionsystem","content":"\n<img src=\"/assets/img/2024-05-17-SpanishcarrierIberiatrialsfacialrecognitionsystem_0.png\" />\n\n지난 금요일에는 스페인 항공사 이베리아의 얼굴 인식 시스템 론칭 행사에 참석했어요. 이 시스템은 탑승구 및 탑승 절차에 액세스하기 위한 것으로, 현재는 마드리드-바르셀로나 노선을 테스트 중이에요.\n\n얼굴 인식 기술은 이미 많은 공항에서 보편화되어 있어요. 저는 두바이의 스마트 게이트를 여러 해 동안 사용해 왔고, 이를 통해 공항 이동 중 승객들에게 편의를 제공하고 있어요. 이번 사례에서는 승객들의 신원을 공항 내에서 확인하고 탑승하는 데 제공하는 반면에, 스페인의 에나 공항 당국이 생체 인식 데이터를 보관하는 것이 조건으로 요구될 거 예요. 서비스 약관에 따르면, 이 데이터는 공항 내에서 승객 신원을 확인하는 데 사용되며 탑승 후에 삭제될 거에요.\n\n이 프로세스는 상대적으로 간단하며, 이베리아 앱에서 시작할 수 있어요. 사용자 프로필 아이콘을 찾아 오른쪽 상단에 위치한 메뉴에서 아래로 스크롤할 때, 마지막에서 두 번째 옵션인 \"얼굴 인식\"을 찾을 수 있어요. 서비스 약관을 수락한 후, 사용자는 신분증의 뒷면을 스캔하고, 그 위의 RFID 칩을 읽어야 해요(이 과정 중에서 가장 어려운 부분으로, 폰의 뒷면을 문서 주변으로 움직여 센서가 읽을 수 있도록 해야 해요), 그리고 셀카를 찍어야 해요. 현재 이 작업은 아이폰에서만 가능하며 나중에 안드로이드에서도 이용할 수 있을 거에요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n사용자는 앱에서 탑승권을 받으면 생체 인식 액세스와 연결해야 합니다. 이를 통해 보안 필터와 탑승 게이트에서 특별한 액세스를 사용할 수 있습니다. 이베리아 항공은 얼굴 인식을 이용한 탑승 게이트 6개를 갖고 있습니다 (J46, J50, J52, J54, J56, J58). 또한 체크인 지역에는 기업선과 비즈니스용 키오스크 2대, 보안 필터에 생체 인식 게이트 4대 (주 출입구 2대, 에어 셔틀 1대, 패스트트랙 1대)를 운영하고 있습니다. 바르셀로나 엘 프라트 공항에서는 생체 인식 탑승 게이트 (A02)와 보안 필터에 게이트 2대, 그리고 체크인 지역에 키오스크 1대를 운영하고 있습니다.\n\n이 시스템은 탑승권 대신 얼굴을 스캔하며 탑승 게이트에서 신분증이나 여권을 보일 필요가 없게 됩니다. 그러나 여권 또는 신분증을 지참해야 하는 것은 여전히 필수입니다. 탑승 시, 생체 인식 액세스를 가진 승객은 특별한 요구 사항을 갖춘 승객 및 1등급 승객(또는 이후 자유롭게 탑승 가능) 다음으로 즉시 탑승할 수 있습니다.\n\n생체 인식 액세스는 완전히 선택 사항이며, 수많은 승객들이 해당 서비스를 정기적으로 사용하는 마드리드-바르셀로나 에어 셔틀에서 시도 중입니다. 이 아이디어는 전 세계의 다른 공항들이 시행하고 있는 것처럼 공항 전체로 시스템을 확대하는 것입니다.\n","ogImage":{"url":"/assets/img/2024-05-17-SpanishcarrierIberiatrialsfacialrecognitionsystem_0.png"},"coverImage":"/assets/img/2024-05-17-SpanishcarrierIberiatrialsfacialrecognitionsystem_0.png","tag":["Tech"],"readingTime":2},{"title":"지금 우리가 디스토피아로 향하고 있을까요","description":"","date":"2024-05-17 20:18","slug":"2024-05-17-AreWeHeadingTowardsaDystopia","content":"\n<img src=\"/assets/img/2024-05-17-AreWeHeadingTowardsaDystopia_0.png\" />\n\n이틀 전, 2024 Google I/O 컨퍼런스에서 Google은 새로운 도구인 Illuminate를 선보였어. 이 AI 도구는 학술 논문을 입력으로 받아들여 인간과 구별할 수 없는 실제 음성과 함께 오디오 토론을 생성할 수 있어. 이것은 음성 AI의 발전을 보여주는 한 예일 뿐이야.\n\nAI와의 커뮤니케이션이 더 자연스럽고 인간적으로 변하면서 AI와 인간을 구분하기가 거의 불가능해지고 있어. AI 전문가로서 저는 미래에 대해 궁금하면서 동시에 걱정스러워해. 곧, AI 챗봇이 우릴 쓰기만 하는 것이 아니라 우리와 대화를 나눌 거야. 미래에 전화 상대가 우리가 생각하는 사람인지 아니면 AI 복제물인지 어떻게 구분할 수 있을까?\n\n중국에서는 일부 TV 프로그램에서 진행자의 클론을 만들어 휴가 중에 대신하고 있어. 두 달 전 우크라이나 인플루언서가 자신의 클론이 중국에 러시아 제품을 판다는 것을 보고 신고했어. 다음으로 어떤 수준이 있을까? 우리 자신의 클론을 만들어 번거로운 전화를 처리하게 하거나, 비서 역할을 수행하게 하거나, 심지어는 면접까지 진행하게 할 수 있을까? 우리의 상담사가 ChatGPT의 지식, pi.ai의 공감능력, 그리고 Google의 실제 음성 생성 능력을 갖춘 AI 에이전트가 될까?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n왜 AI를 상담사로 선택해야 할까요? 왜냐하면 AI는 항상 접근 가능하며, 낮과 밤을 가리지 않고 언제든지 이야기할 수 있습니다. 우리의 걱정에 대해 최적의 조언을 받을 수 있으며, 시간당이 아닌 토큰 단위로 과금되어 가장 합리적인 가격으로 제공됩니다.\n\n![이미지](/assets/img/2024-05-17-AreWeHeadingTowardsaDystopia_1.png)\n\n이러한 솔루션이 완벽하게 구현되면 하나의 질문이 남습니다: 우리는 여전히 우리의 인간적 정체성을 유지할 수 있을까요, 아니면 우리 모두가 동일한 성격으로 수렴할까요?\n\nAI 전문가로서, 저는 트렌드를 주의 깊게 관찰하고 있으며 AI가 가져다주는 기회에 흥분하고 있습니다. 그러나 AI 도구에 적합한 작업과 인간이 해야 하는 작업을 구별해야 합니다. 비록 AI가 완벽하게 수행하더라도 우리 인간에 의해 수행되어야 할 작업이 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nAI에 대해 가장 우려되는 측면 중 하나는 데이터 개인정보 보호입니다. 당신이 입력하거나 말하는 매 말은 몇 초 내에 처리되며, 당신에 대한 추론을 도출하는 모델을 활성화합니다: 당신이 좋아하는 것, 무엇을 살 것이며, 다음에 무엇을 말할 것인지 등을 파악합니다.\n\n좋은 소식은 모든 사람이 동일한 도구를 사용하여 데이터를 수집하고 텍스트를 작성하는데 사용한다는 것입니다(예: ChatGPT 및 유사한 도구). 미래에는 예측을 건너뛰고 도구에 직접 물어볼 수도 있을지도 모릅니다.\n\nAI 분야에서의 인상적인 발전은 우리를 The Truman Show와 같은 가짜 현실에 접근시키는데, 여기서 AI가 우리의 모든 작업을 처리하고 우리의 사고와 의사 결정까지 돌보게 할 수 있습니다. 우리에게 남은 것은 먹기, 자기, 숨기뿐인 것일까요? 더구나 당신의 목소리를 완벽하게 복제하는 이러한 도구들은 보안 문제를 야기시킬 수 있습니다. 누군가의 목소리를 복제하면 그 사람의 신원 도용도 쉽게 이루어집니다.\n\n어떤 연구소에서 이미 성취되었든지, 곧 당신도 몇 가지 예시만 가지고도 특정 행동을 하는 사람의 포토리얼리스틱 비디오를 생성할 수 있을 것입니다. 이로 인한 위험은 상상할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그런 도구들은 영화 생성에 대한 멋진 선택으로 들리죠. 유명 배우들의 얼굴 또는 심지어 여러분과 친구들의 영화를 주인공으로 삼는 아이디어도 참 좋은데, 때로는 아니죠. DALL-E2와 같은 모델들은 이미 무작위 얼굴을 사용한 영화 제작을 허용하고 있어요.\n\n요약하자면, AI 기술의 발전은 틀림없이 인상적이지만, 무시할 수 없는 윤리적이고 실용적인 문제들을 동반하고 있어요. 인간과 AI 사이의 경계가 희미해지고, 우리의 정체성과 개인정보에 대한 질문들을 던지고 있어요. 신원 도용이나 가짜 현실 생성과 같은 남용 가능성은 상당한 위험을 야기합니다. 앞으로 나아가면서, AI에 적합한 작업과 인간이 갖고 있어야 할 영역을 신중하게 고려하는 것이 중요합니다. AI의 미래는 큰 기회를 품고 있지만, 경계 감각, 책임감, 그리고 우리를 독특하게 만드는 것을 보존하기 위한 헌신이 필요합니다.\n\n참고: 이 기사가 마음에 드셨다면 — 내용은 저의 것이며, chatGPT 4o에서의 일부 복사 편집 지원, 이미지 DALL-E.\n","ogImage":{"url":"/assets/img/2024-05-17-AreWeHeadingTowardsaDystopia_0.png"},"coverImage":"/assets/img/2024-05-17-AreWeHeadingTowardsaDystopia_0.png","tag":["Tech"],"readingTime":4},{"title":"당신의 Git 히스토리 정리하기","description":"","date":"2024-05-17 20:17","slug":"2024-05-17-SanitisingYourGitHistory","content":"\n2005년에 창설된 이후 Git은 버전 관리 시스템(VCS)의 왕으로 부상했습니다. 빠르고 간단하며 분산 속성을 갖춘 Git은 두 대 혁신적인 클라우드 VCS 제공업체인 GitHub와 GitLab의 채택과 함께 다른 VCS를 대체했습니다.\n\n하지만 좋은 도구도 사용자가 어떻게 관리하는지에 달려 있습니다. 특히 적절한 검토와 강제 사항이 없이 여러 사용자들이 Git 저장소에 기여할 때, 대용량 파일이 많아지며 지나치게 복잡해지는 저장소가 만들어질 수 있습니다. 이는 다른 사용자들이 저장소를 복제하거나 CI 파이프라인을 실행할 때 더 큰 지연을 야기할 수 있습니다.\n\n더 나쁜 상황으로는, 암호와 같은 민감한 파일이 실수로 커밋되어 역사 속에 깊숙이 들어가 있고, 새로운 커밋을 통해 간단히 삭제할 수 없을 수도 있습니다.\n\nGit을 처음 사용하는 경우, 계속하기 전에 여기에서 Git 소개를 읽어보세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-05-17-SanitisingYourGitHistory_0.png\" />\n\n# Git 히스토리 이해하기\n\nGit(또는 다른 VCS)의 아름다움은 버전 내역에 있습니다. 그것이 Git에서 썩은 부분을 정리해야 할 때 발생하는 어려움 역시 그런 아름다움에 속합니다. Git에 실수로 커밋한 큰 파일을 예로 들어보죠.\n\n<img src=\"/assets/img/2024-05-17-SanitisingYourGitHistory_1.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 이 큰 파일은 feature 브랜치 1에서 처음 소개되었고 사용자 1에 의해 마스터 브랜치로 병합되었습니다.\n- 마스터 브랜치는 사용자 2에 의해 feature 브랜치 2로 쪼개졌습니다.\n- 사용자 1은 나중에 실수를 발견하여 큰 파일을 삭제하고 다시 마스터 브랜치로 병합했습니다.\n- 그러나 무심코 남아 있는 사용자 2의 feature 브랜치 2에 여전히 큰 파일이 있고, 사용자 2는 자신의 기능을 해결한 후에도 큰 파일을 마스터 브랜치로 다시 병합합니다.\n\n실수로 커밋할 때나 마스터 브랜치와 같은 공통 브랜치로 병합할 때 복잡성을 볼 수 있습니다. 사용자 2가 feature 2를 커밋하지 않아도 사용자 1이 삭제하고 새 커밋으로 병합한 후에도 큰 파일은 여전히 히스토리에 유지됩니다.\n\n따라서 해당 큰 파일을 제거하려면 원격 저장소의 모든 브랜치의 Git 히스토리를 완전히 지워야 합니다. 또한 제거한 후 로컬 복사본이 있는 다른 개발자들에게 알려주어서 그 파일을 삭제하고 제거 후 다시 저장소를 클론하도록 해야 합니다.\n\n# Git 히스토리 프로파일링\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저장소의 Git 기록은 숨겨진 폴더 .git에 저장됩니다. 로컬로 저장소의 사본을 복제하고 다음 명령을 실행하여 그 크기를 빠르게 확인할 수 있습니다. 이 Git 기록이 약 416Mb임을 알 수 있습니다.\n\n```js\ncd .git\ndu -d 1 -h\n\n416M ./objects\n4.0K ./info\n 12K ./logs\n 60K ./hooks\n8.0K ./refs\n416M .\n```\n\nGit을 프로파일링하는 훌륭한 도구는 git-sizer라는 도구를 사용하는 것입니다. MacOS에서는 brew를 사용하여 설치할 수 있습니다. 다른 운영 체제를 사용하는 경우, GitHub 릴리스 페이지에서 설치 파일을 다운로드할 수 있습니다. (아래 링크를 참조해주세요).\n\n```js\nbrew install git-sizer\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저장소로 이동해서 다음 명령어를 실행해주세요.\n\n```js\ncd your/git/repository\ngit-sizer --verbose\n```\n\n이 명령어를 실행하면 Git 기록의 명확한 프로필을 확인할 수 있어요. 저장소의 크기 및 최적화해야 할 관심 수준을 확인할 수 있습니다. 이 경우에는 기록 중 대부분의 저장소가 블롭으로 저장되어 있는 것을 확인할 수 있어요. 블롭은 Git-LFS (Large File Storage)나 다른 저장 영역(예: AWS S3)에 저장해야 합니다.\n\n```js\n블롭 처리 중: 1368개\n트리 처리 중: 1957개\n커밋 처리 중: 518개\n트리에 해당하는 커밋: 518개\n주석이 달린 태그 처리 중: 1개\n참조 처리 중: 24개\n| 이름                         | 값        | 관심 수준                         |\n| ---------------------------- | --------- | ------------------------------ |\n| 전체 저장소 크기             |           |                                |\n| * 커밋                      |           |                                |\n|   * 총 개수                  |   518     |                                |\n|   * 총 크기                 |   158 KiB |                                |\n| * 트리                      |           |                                |\n|   * 총 개수                  |  1.96 k   |                                |\n|   * 총 크기                 |   686 KiB |                                |\n|   * 총 트리 항목 수         |  17.7 k   |                                |\n| * 블롭                      |           |                                |\n|   * 총 개수                  |  1.37 k   |                                |\n|   * 총 크기                 |   453 MiB |                                |\n| * 주석이 달린 태그           |           |                                |\n|   * 개수                    |     1     |                                |\n| * 참조                      |           |                                |\n|   * 개수                    |    24     |                                |\n|     * 브랜치                |     1     |                                |\n|     * 태그                  |    15     |                                |\n|     * 원격 추적 참조         |     8     |                                |\n|                              |           |                                |\n| 가장 큰 객체들               |           |                                |\n| * 커밋                      |           |                                |\n|   * 최대 크기             [1] |   771 B   |                                |\n|   * 최대 부모 수          [2] |     2     |                                |\n| * 트리                      |           |                                |\n|   * 최대 엔트리 수        [3] |    23     |                                |\n| * 블롭                      |           |                                |\n|   * 최대 크기             [4] |   430 MiB | !!!!!!!!!!!!!!!!!!!!!!!!!!!!!! |\n|                              |           |                                |\n| 기록 구조                    |           |                                |\n| * 최대 기록 깊이            |   346     |                                |\n| * 최대 태그 깊이        [5] |     1     |                                |\n|                              |           |                                |\n| 가장 큰 체크아웃들           |           |                                |\n| * 디렉터리 수          [6] |   108     |                                |\n| * 최대 경로 깊이       [7] |     9     |                                |\n| * 최대 경로 길이       [7] |   134 B   | *                              |\n| * 파일 수              [3] |   283     |                                |\n| * 파일 총 크기        [8] |   442 MiB |                                |\n| * 심볼릭 링크 수       [9] |     1     |                                |\n| * 서브모듈 수         [10] |     2     |                                |\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# Git 히스토리 삭제하기\n\n프로파일링 후 지우고 싶은 내용에 대한 명확한 아이디어가 생겼으니, Git 히스토리에서 해당 내용을 삭제해 보겠습니다. 이를 위해 git-filter-repo라는 Python 도구를 설치해야 합니다 (아래 링크를 참조하세요). 나중에 필요할 때를 대비해 참조용 원격 origin을 목록에 표시해 두세요.\n\n```js\n# 설치\npip install git-filter-repo\n\n# 원격 origin 목록 표시\ngit remote -v\n>> origin git@gitlab.com:jake/test.git (fetch)\n>> origin git@gitlab.com:jake/test.git (push)\n```\n\n여기에 파일이나 텍스트를 삭제하는 몇 가지 일반적인 예시 명령어를 포함했습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 특정한 절대 파일 이름을 가진 파일을 삭제하는 방법\n- (\\*)를 사용하여 특정 유형의 모든 파일을 삭제하는 방법\n- 실수로 패스워드를 커밋한 경우와 같이 파일이나 스크립트에서 특정 텍스트를 대체하는 방법.\n\n```js\n# 파일 삭제\ngit filter-repo --invert-paths --path 'myfilename.jpg' --force\n\n# 글로브(*)를 사용하여 모든 파일 삭제\ngit filter-repo --invert-paths --path-glob '*.jpg' --force\ngit filter-repo --invert-paths --path-glob '*.jpg' --path-glob '*.png' --force\n\n# \"mypassword\"를 \"REPLACED\"로 대체하는 방법\ngit filter-repo --replace-text <(echo \"mypassword==>REPLACED\") --force\n```\n\n이전에 삭제한 것이 더 이상 남아 있지 않은지 확인하여 버전이나 브랜치를 검사하여 정상 작동하는지 확인할 수 있습니다.\n\n완료되면 정리된 복사본을 원격 저장소에 푸시할 수 있습니다. 이 도구는 안전상의 이유로 git 원격 URL을 자동으로 제거합니다. 따라서 다시 추가해야 합니다. 그런 다음 기존 브랜치를 원격에 강제로 푸시할 수 있습니다. 다른 브랜치가 있는 경우 체크아웃하여 그것들도 푸시해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n# git filter-repo를 실행한 후 원격 저장소를 다시 추가하세요\ngit remote add origin git@gitlab.com:jake/test.git\n\n# 원격 저장소로 푸시하세요\ngit push --set-upstream origin main --force\n\n# 다른 브랜치가 있으면 변경사항을 푸시하세요\ngit checkout <branch>\ngit push --set-upstream origin <branch> --force\n```\n\n# 주의사항\n\n각 Git 버전은 Git 해시라는 고유한 ID를 가지고 있습니다. git-filter-repo나 기타 도구를 사용하여 Git 히스토리의 커밋을 변경하면 해시가 변경됩니다.\n\nGit 해시는 병합/풀 요청, Git 태그 또는 릴리스와 같은 VCS 플랫폼에서 참조로 사용됩니다. 이들은 작동하지 않고 특히 Git 히스토리에서 깊숙이 포함된 것을 제거하고 싶은 경우 문제가 될 수 있습니다. 중요하다면 저장소의 복사본을 만드는 것이 좋습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 요약\n\ngit-sizer와 git-filter-repo는 Git 히스토리를 프로파일링하고 정리하는 데 사용되는 인기 있는 신뢰할 수 있는 오픈 소스 도구입니다. 이러한 도구를 사용하면 필요에 따라 간편하게 리포지토리의 상태를 확인하고 정리하여 유지할 수 있습니다.\n\n# 참고\n","ogImage":{"url":"/assets/img/2024-05-17-SanitisingYourGitHistory_0.png"},"coverImage":"/assets/img/2024-05-17-SanitisingYourGitHistory_0.png","tag":["Tech"],"readingTime":10},{"title":"해커의 마음 - Recon 마인드 맵","description":"","date":"2024-05-17 20:16","slug":"2024-05-17-TheHackersMind-ReconMindmap","content":"\nBy Tahir Mujawar, 인증된 윤리적 해커 및 사이버 보안 연구원\n\n![이미지](/assets/img/2024-05-17-TheHackersMind-ReconMindmap_0.png)\n\n안녕하세요 👋 사이버 모험가 여러분! 여기 타히르 무자와르입니다. 사이버 보안의 복잡성을 탐험하는 전략적 안내서인 Recon Mind map을 소개합니다. 정교하게 제작된 이 지도는 각 하위 도메인, 기술 식별 및 콘텐츠 발견을 통해 우리를 안내하는 설계도입니다. 함께 사이버 공간의 비밀을 발견하고 Recon Mind map과 함께 더 안전한 디지털 프론티어를 개척해 봅시다.\n\nRecon은 정보 수집뿐만 아니라 통찰력, 선견지달력 및 보이지 않는 위협에 대항하는 촉매의 역할을 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nRecon Mind Map을 만드는 목적은 학습을 체계적으로 진행하는 데 있습니다. 온라인으로 다양한 자료가 풍부하게 제공되지만, 나와 같은 열정적인 사람들은 종종 어디에 초점을 맞춰야 할지 판별하기 어렵다고 느낍니다. Recon Mind Map은 웹 애플리케이션 탐색에 필수적인 모든 주요 주제를 아우르며, 학습 여정에서 명확성과 방향성을 제공합니다.\n\nRecon Mind Map은 다음과 같은 요소들을 포함합니다:\n\n1. 토폴로지 맵핑\n\n- NetBrain\n- NetCrunch\n- SolarWinds\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n2. 방화벽 식별\n\n- WafW00f\n- Nmap NSE\n\n3. 로드 밸런서\n\n- lbd\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n4. ASN\n\n- bgp.he.net\n- Hacker Target\n- Amass\n\n5. CIDR Range\n\n- Asn Lookup\n- Mapcidr\n- Amass Intel\n- ipaddressguide.com\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n6. IP 블록 / 서브넷\n\n- viewdns\n- MxTools\n- whois.arin.net\n- whoxy\n- who.is\n- lopseg\n- shodan.io\n\n7. IP 주소\n\n오픈 포트, 서비스, 버전\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- Masscan\n- Naabu\n- Rustscan\n- Nmap\n- Sandmap\n- Scan Cannon\n\n8. Cloud\n\n- Home Lister Directory\n\n## \\* Horizontal / Acquisitions Enumeration\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- WhoisXMLAPI\n- CrunchBase\n- Wikipedia\n- ChatGpt\n\n## 수직열거\n\n수동 열거:\n\n- 수동 소스\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 지피노\n- 아매스\n- 서브파인더\n- 서브리스트\n- 에셋파인더\n- 원포올\n- 파인도메인\n- 크로벳\n- 노크파이\n- 깃허브-서브도메인\n\n2. 인증서 로그\n\n- crt.sh\n- tls.bufferover.run\n\n3. 재귀적 열거\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 수동 소스\n\n## \\* 활성화 목록\n\n- DNS 무차별 강제 공격\n\n- Puredns\n- Cewl\n- FFUF\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n2. 순열\n\n- 고타토르\n\n3. JS / 소스 코드 스크랩핑\n\n- 링크파인더\n- 겟제이에스\n- 고스파이더\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n4. Google Analytics\n\n- Analytics Relationships\n\n5. TLS, CNAME 프로빙\n\n- Cero\n- httpx\n- dnsx\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n6. VHOST 프로빙\n\n- 가상 호스트 스캐너\n- 호스트 헌터\n\n7. 웹 프로빙\n\n- Unimap\n- httpx\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- Whatweb\n- Wappalyzer\n- Netcraft\n- Builtwith\n- Fingerprintx\n- Retire.JS\n\n1. URLs\n\n- GAU\n- Linx\n- Waybackurl\n- hakrawler\n- Gospider\n- URLgrab\n\n2. Parameters\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- Param-Miner\n- x8\n- Parameth\n- Arjun\n- Github-Endpoints\n\n### 3. JS Enumeration\n\n- Secret Finder\n- JS Recon\n- Link Finder\n- Wayback URLs\n- JS Scan\n\n### 4. Directory & File Enumeration\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- FFUF\n- Dirb\n- Gobuster\n- DirSearch\n- WFuzz\n\n5. Google FU\n\n- Trufflehog\n- GitDorker\n- githound\n- GitGrabber\n- GitLeakes\n- Repo-Supervisor\n\n- S3 Scanner\n- S3 Bucket Finder\n- GrayHatWarfare\n- Lazy S3\n- AWS Bucket Dump\n- CloudBrute\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- Wpscan\n- CMSmap\n- Joomscan\n\n- OSINT Framework\n- theHarvester\n- Recon-ng\n- Maltego\n- MOSINT\n- SpiderFoot\n\n- EyeWitness\n- LazyShot\n- Aquatone\n- Web shot\n- Eyeballer\n\n위에 언급한 마인드 맵이 있어요. 더 잘 보기 위해서는 중간 앱을 사용하거나 컴퓨터/노트북에서 여세요. PNG 파일을 받으려면 LinkedIn에서 연락 주세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nC\nonnect me on LinkedIn\n\nResearching takes considerable time. If you found this helpful, a Like, share, or follow would be greatly appreciated. Your support fuels our cyber journey!\n\nHappy Hacking! Bye Bye Hackers 👋\n\n![TheHackersMind ReconMindmap](/assets/img/2024-05-17-TheHackersMind-ReconMindmap_1.png)\n","ogImage":{"url":"/assets/img/2024-05-17-TheHackersMind-ReconMindmap_0.png"},"coverImage":"/assets/img/2024-05-17-TheHackersMind-ReconMindmap_0.png","tag":["Tech"],"readingTime":8},{"title":"중간 과정 프롬프트를 Shorten으로 개선하세요","description":"","date":"2024-05-17 20:14","slug":"2024-05-17-ImproveYourMidjourneyPromptsWithshorten","content":"\n<img src=\"/assets/img/2024-05-17-ImproveYourMidjourneyPromptsWithshorten_0.png\" />\n\n미드절니(Midjourney)는 상세하고 현실적인 AI 생성 이미지로 유명합니다. 그러나 미드절니의 모델이 당신이 제시한 프롬프트를 정확히 생성하는 것은 도전일 수 있습니다.\n\n예를 들어, 이 기사의 제목 이미지의 경우 저는 리본을 가로지르는 낡은 가위를 요청했습니다. 그러나 받은 이미지는 모두 리본 근처를 떠도는 가위의 이미지입니다.\n\n/shorten 명령어는 프롬프트를 분석하는 유용한 도구입니다. 미드절니의 알고리즘이 프롬프트를 해석하는 방식을 파악하고, 원하는 이미지를 만들기에 더 적합한 더 짧은 프롬프트를 제안해줍니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 기사에서 Midjourney Discord 인터페이스에서 `/shorten` 명령어가 어떻게 작동하는지 알게 될 것입니다. 그런 다음 두 가지 예제를 통해 안내해 드리겠습니다:\n\n- 복잡한 장면을 /shorten 명령어로 분석하여 prompt를 개선하기\n- prompt의 길이를 80% 줄이기\n\n## /shorten 명령어 동작\n\nMidjourney 봇은 프롬프트를 단어 또는 짧은 구문으로 구성된 토큰으로 분할합니다. 그런 다음 이러한 토큰과 교육 데이터의 연관성을 기반으로 이미지를 작성합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n직감과는 반대로 간결하고 간결한 프롬프트가 긴 설명보다 더 나은 성능을 발휘할 수 있다고 합니다. Midjourney는 시적인 언어와 과도한 설명이 이미지에 예상치 못한 객체들이 나타나게 할 수 있다고 설명합니다.\n\n사용자들은 Discord 채팅 인터페이스에서 /imagine 키워드로 이미지 프롬프트를 제공하고 알고리즘은 4가지 가능한 이미지 그리드를 생성합니다. 이들은 더 세부적으로 다듬을 수 있으며, 섬세하고 창의적인 업스케일링 및 인페인팅을 통해 더 발전시킬 수 있습니다.\n\n/imagine 와 마찬가지로, /shorten 도 Discord의 Midjourney 봇 채널에서 호출할 수 있습니다. 이것은 내 제목 이미지 프롬프트를 분석한 결과입니다:\n\n![2024-05-17-ImproveYourMidjourneyPromptsWithshorten_1.png](/assets/img/2024-05-17-ImproveYourMidjourneyPromptsWithshorten_1.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n사용자에게 추가 옵션이 두 가지 더 있어요:\n\n- 해당 버튼을 클릭하여 다섯 가지 중 한 가지 단축 이미지 프롬프트를 기반으로 이미지를 생성합니다.\n- 각 토큰에 할당된 중요도를 표시하려면 “세부 정보 보기”를 클릭합니다.\n\n후자의 경우 Midjourney 봇은 각 토큰에 할당한 가중치를 반환합니다. 더 높은 가중치를 가진 토큰은 더 중요하다고 간주됩니다.\n\n알고리즘은 이미지 구성 요소와 각각의 색상, 스타일에 중점을 둡니다. 구성은 덜 중요한 것으로 보이며 리본에 쓰인 단어의 설명도 마찬가지입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 가족 모습\n\n다음에는 /shorten 명령어를 사용하여 가족 모습을 만드는 데 도움을 받겠어요. 네 개의 이미지 그리드 중에서, 주어진 프롬프트와 가장 일치하는 이미지를 항상 선택했어요.\n\n저는 Midjourney에게 아늑한 가족 모습을 만들어 달라고 요청했어요. 그 가족 구성원들과 애완동물의 자세한 설명, 각자의 직업, 이미지에서의 위치를 포함하여 구체적으로 설명했고, 이미지 스타일은 사실적인 것으로 지정했어요.\n\n![가족 모습](/assets/img/2024-05-17-ImproveYourMidjourneyPromptsWithshorten_2.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n생성된 장면에는 요청한 모든 객체들이 포함되어 있지만, 구성이 예상대로 되지는 않았어요. 예를 들어, 부엌 카운터 위에 있는 태비 고양이 한 마리 대신 바닥에 두 마리가 있었어요. 바닥에는 장난감이 있지만, 아이들이 그것들과 놀고 있지는 않았어요. 하지만 정말 당황한 건 창문의 아랫부분이 빠져있던 거에요.\n\n/shorten을 사용하여 Midjourney 봇이 제 원래 프롬프트를 분석한 결과를 제공해 주었어요. 봇은 가장 중요한 단어들을 굵은 글꼴로 강조했어요.\n\n분석 결과 사람들과 애완동물이 중요하게 여겨졌어요. 그러나 프롬프트의 가장 관련된 부분은 설정이에요: 사실적이고, 환한, 아침, 가족, ... 흥미로운 점은 모피 색상 \"태비\"가 고양이 자체보다 훨씬 중요하게 여겨졌다는 것인데요 - 아마도 \"태비\" 객체를 요청했을 때 \"고양이\"가 자동으로 추론된다는 힌트일지도 모르겠어요?\n\n봇은 또한 프롬프트를 다섯 가지 요약된 버전으로 제안했어요. 그것들은 프롬프트의 인식에 따라 중요한 부분을 포착하고 적절하지 않은 세부사항은 제외한 것으로 보입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음 패널에서는 \"사실적인, 화창한 아침 가족 장면, 부엌에서 스무디를 준비하는 여성, 두 아이, 장난감 자동차로 뒤덮인 바닥. 태비 고양이, 과일, 커튼\"에서 \"사실적인, 화창한, 가족, 스무디\"로 줄어든 프롬프트에 대한 이미지가 보입니다.\n\n제가 만들고 싶은 장면과 일치하는 줄어든 프롬프트는 찾지 못했습니다. 알고리즘을 구성에 더 집중하도록 하기 위해, 스타일보다는 구성에 더 집중하게끔 아래의 수정된 프롬프트를 만들기로 결정했습니다.\n\n더 이상 사진을 사실적으로 요구하지 않고, 태비 고양이와 다른 물건들이 바닥이 아니라 카운터 위에 놓이도록 요청합니다. 이것이 스타일보다 더 중요하다고 생각했기 때문입니다.\n\n![이미지](/assets/img/2024-05-17-ImproveYourMidjourneyPromptsWithshorten_3.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 시적인 언어 줄이기\n\n다음 예시에서, 저는 시적이고 화려한 이미지 프롬프트를 만들 수 있도록 ChatGPT의 도움을 받았습니다:\n\n미드저니 봇이 이를 줄였습니다.\n\n이것은 총 5개 중 3번째 프롬프트였지만, 그 이후로는 포도와 키위가 사라지기 시작했습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음 패널은 두 프롬프트를 나란히 비교한 것을 보여줍니다. 원본 38단어 중 8단어만 남은 단축된 프롬프트는 장면을 충실하게 재구성합니다.\n\n![이미지](/assets/img/2024-05-17-ImproveYourMidjourneyPromptsWithshorten_4.png)\n\n## 결론\n\n첫 번째 복잡한 프롬프트 예제에서, /shorten 명령어와 Midjourney 봇이 제공한 단축된 프롬프트는 내 문제를 직접 해결하지 못했습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n`/shorten`와 상호 작용하면 알고리즘을 더 잘 이해할 수 있었어요. 각 토큰에 부여하는 가중치를 알면, 지나치게 강조된 단어를 제외하고 다른 곳에서 설명을 개선할 수 있었어요.\n\n예를 들어, 알고리즘이 \"사실적인\"과 \"스무디\"라는 단어에 이렇게 중요성을 부여할 것이라고는 상상하지 못했을 겁니다. 그 이미지를 만드는 과정에서 그 단어들이 장면을 잡아내는 데 꼭 필요하지 않은 것을 깨달았어요.\n\n보다 간단한 두 번째 장면에서는 /shorten을 사용하여 원래 프롬프트의 장황한 언어를 줄일 수 있었어요. 구성 요소는 훨씬 짧은 프롬프트로 보존되었어요.\n\n저는 /shorten 명령을 Midjourney 봇과의 소통 수단으로 생각해요. 어쨌든, 이것은 어떻게 특정 이미지를 생성하는지 설명해 주지 않아요. 각 토큰의 가중치를 알고 있으면, 사용자는 생성된 장면이 그들의 원래 아이디어와 일치할 때까지 프롬프트를 조정해 나갈 수 있어요.\n","ogImage":{"url":"/assets/img/2024-05-17-ImproveYourMidjourneyPromptsWithshorten_0.png"},"coverImage":"/assets/img/2024-05-17-ImproveYourMidjourneyPromptsWithshorten_0.png","tag":["Tech"],"readingTime":7},{"title":"중간 과정 스타일 참조 코드를 위한 상위 10개 컬렉션","description":"","date":"2024-05-17 20:12","slug":"2024-05-17-Top10collectionsforMidjourneystylereferencecodes","content":"\nMidjourney 스타일 참조 코드가 소개된 이후로 취미로 삼는 이들은 열정적으로 sref 랜덤 접미사 매개변수를 활용하여 다양한 스타일을 발견하고 활용하고 있어요.\n\n커뮤니티의 집합된 노력으로 무수히 많은 Midjourney 스타일이 시험되었고, 그 결과 다양한 품질의 스타일이 드러났어요. 저는 개인적으로 첫 1000개의 스타일 코드를 조사한 결과, 많은 스타일이 하위 수준이었고 이상하고 구식이며 흠집이 많은 그리고 저품질의 만화 스타일을 냈다는 것을 발견했어요. 그 수많은 스타일들은 압도적일 수 있으며, 보석을 찾기 위해서는 인내가 필요해요.\n\n일부 Midjourney 사용자들은 끊임없이 Discord에서 스크립트를 실행하여 스타일을 생성하고 시험하고 있어요. 이는 조금 집착적일 수도 있지만, 스타일 코드가 전부가 아니라는 것을 기억하는 것이 중요해요. 고품질 이미지 생성은 프롬프트 작성의 기본에 많이 의존하게 됩니다.\n\nMidjourney 애호가들의 헌신 덕분에 방대한 양의 스타일 코드가 편집되어, 이 과정은 급속히 가속화되고 있어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n얼마 전에는 처음 300개 스타일 코드만 보았는데, 이제는 3,000개가 넘었습니다. Midjourney가 공식적으로 오픈 소스 sref 사전 생성 계획을 발표했기 때문에 우리가 직접 sref를 찾을 필요가 없게 될 때가 머지 않았습니다.\n\n제 개인적인 검색을 토대로, 지금까지 가장 좋은 Midjourney sref 컬렉션을 선별했습니다.\n\n# 1. AI IQ 포털\n\nMidjourney 영향력 있는 인플루언서 Alie Jules가 만든 AI IQ 포털은 매일 새로운 스타일 참조 (sref)를 업데이트하는 웹사이트입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n미래의 업데이트를 통해 sref 코드를 스타일, 색상 등으로 분류하게 될 예정이며, 선호하는 스타일을 쉽게 찾을 수 있게 될 것입니다. 이 사이트를 즐겨찾기에 추가하여 계속해서 업데이트를 확인해주세요.\n\n![이미지](/assets/img/2024-05-17-Top10collectionsforMidjourneystylereferencecodes_0.png)\n\n링크: [https://aiiqportal.com/midjourney-style-reference-codes/](https://aiiqportal.com/midjourney-style-reference-codes/)\n\n# 2. Tatiana Tsiguleva의 콜렉션\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n디자이너 Tatiana Tsiguleva는 Gumroad에서 무료로 다운로드할 수 있는 그녀의 검증된 srefs의 PDF를 제공합니다. 가격으로 \"0\"을 입력하고 \"이것을 원합니다\"를 클릭하여 비용없이 다운로드하실 수 있습니다.\n\n[이미지](/assets/img/2024-05-17-Top10collectionsforMidjourneystylereferencecodes_1.png)\n\n링크: https://aig.gumroad.com/l/sref\n\n# 3. Dogan Ural의 컬렉션\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n디자이너 Dogan Ural은 현재 트위터 기여를 기반으로 30번의 업데이트를 통해 Notion에 Midjourney 스타일 코드의 선별된 목록을 편집하여 표시했습니다.\n\n![이미지](/assets/img/2024-05-17-Top10collectionsforMidjourneystylereferencecodes_2.png)\n\n링크: [https://doganural.notion.site/530d40d0f4bb4fd1bdb0aab216c5b4d4?v=f56817e5ea3d40da89b7e1163b099040](https://doganural.notion.site/530d40d0f4bb4fd1bdb0aab216c5b4d4?v=f56817e5ea3d40da89b7e1163b099040)\n\n# 4. Charlie Q의 Magical Sref 라이브러리\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nCharlie Q의 스타일 라이브러리에서 300가지 Midjourney 스타일 코드를 요약했어요. 더 많은 내용이 곧 출시될 예정이에요. 사용하기 편리한 디자인은 이미지를 클릭하면 sref 코드를 표시해줘요.\n\n![이미지](/assets/img/2024-05-17-Top10collectionsforMidjourneystylereferencecodes_3.png)\n\n링크: [여기를 클릭하세요](https://sites.google.com/charlottequinndesigns.com/cqs-sref-library/mj-6-codes)\n\n# 5. GeniArt의 PDF 컬렉션\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n니코는 Midjourney 열정가인, 프랑스어 웹사이트 geniart.fr를 만들어 Midjourney 주변의 커뮤니티를 구축했습니다.\n\n최근에는 1000개의 스타일 코드 컬렉션을 PDF 형식으로 편집했습니다. PDF는 조잡하지만 각 테이블 헤더 셀에는 10개의 스타일 코드가 포함되어 있어 사용하기에는 문제가 없습니다.\n\n링크: [코드 다운로드](https://geniart.fr/upload/OrderedEntropy/OrderedEntropy_canvas_sref-style-codes.pdf)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 6. 에스레프 랜덤 채굴 링크\n\nDiscord 사용자 \"P-Logic\"은 매개변수 --v 6.0 --ar 16:9 --sw 1000 --sref random을 사용하여 11 세트의 스타일 코드를 테스트하고 Midjourney 커뮤니티와 공유했습니다.\n\n[![이미지](/assets/img/2024-05-17-Top10collectionsforMidjourneystylereferencecodes_5.png)]\n\n링크: [https://discord.com/channels/662267976984297473/1238405277670178816](https://discord.com/channels/662267976984297473/1238405277670178816)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 7. 브리에르 씨의 컬렉션\n\n미드저니 열정가인 브리에르 씨는 노션에 수백 가지의 스타일 코드를 모아두었습니다. 이 코드들은 sref 랜덤에 기반한 임의로 생성된 코드들로, 숫자적인 순서가 아닙니다.\n\n![이미지](/assets/img/2024-05-17-Top10collectionsforMidjourneystylereferencecodes_6.png)\n\n링크: [https://mrdelabruyere.notion.site/Midjourney-Style-Reference-43bf1f17ed9c4042a6f3b115c9dd1b39](https://mrdelabruyere.notion.site/Midjourney-Style-Reference-43bf1f17ed9c4042a6f3b115c9dd1b39)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 8. Sevenstyles\n\n트위터 Midjourney 영향력 있는 사용자 브래드\\_7S는 처음 4,000개의 sref를 테스트하고 집계하여 Sevenstyles 사이트에 공유했습니다. 이 코드들은 각각 1,000개씩 4개의 분할로 나누어져 있습니다.\n\n![Sevenstyles](/assets/img/2024-05-17-Top10collectionsforMidjourneystylereferencecodes_7.png)\n\n코드에 액세스하려면 사이트에서 zip 파일을 다운로드하세요. 압축을 풀면 실제 다운로드 링크를 찾을 수 있습니다. 이 링크를 브라우저에 복사하여 써드파티 다운로드 사이트로 이동할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-05-17-Top10collectionsforMidjourneystylereferencecodes_8.png\" />\n\n서드 파티 사이트가 고트래픽으로 다운로드 제한이 있을 수 있으므로 문제가 발생하면 새벽에 다시 다운로드를 시도해보세요. 각 zip 패키지는 대략 600MB 크기이며 해당 스타일 샘플 이미지와 스타일 코드가 포함된 텍스트 파일이 포함되어 있습니다.\n\n링크: [Seven Styles](https://sevenstyles.com/b/sevenstyles/)\n\n# 9. Collection by CreatorImpact\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n웨이드 맥매스터 디자이너가 그의 웹사이트에 'Midjourney' 스타일 코드 컬렉션을 만들었습니다. 이 컬렉션에는 처음 300개 스타일 코드와 몇 가지 무작위 코드가 포함되어 있습니다.\n\n![Midjourney Style Codes](/assets/img/2024-05-17-Top10collectionsforMidjourneystylereferencecodes_9.png)\n\n링크: [Midjourney V6 스타일 코드를 위한 참조](https://creatorimpact.com/project/midjourney-v6-style-codes-for-sref/)\n\n# 10. 요시히코 나리타의 컬렉션\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n일본을 좋아하는 YoshihikoNarita가 Notion에 첫 350개의 sref 코드를 요약하여 컬렉션을 만들었습니다.\n\n![image](/assets/img/2024-05-17-Top10collectionsforMidjourneystylereferencecodes_10.png)\n\n링크: [여기를 클릭하여 이동](https://tarry-blob-de9.notion.site/be0b2afd80944a5686c48d6ab33f8d88)\n\n# 요약하자면\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n코드가 40억 개가 넘는 sref가 있습니다. 이를 정리하거나 모으는 것은 끝이없는 것처럼 느껴질 수 있습니다. 모든 코드가 모두의 취향에 맞을 수는 없고, 모든 스타일이 일상적으로 사용하기에 적합한 것은 아닙니다.\n\n다른 사람과 공유된 스타일 코드를 발견하면 이를 살펴보고 디스코드에서 테스트하여 여러분의 필요에 맞는지 확인한 후 컬렉션에 추가하세요.\n\nsref 코드는 스타일 경향을 나타내지만 이미지 품질을 결정하는 유일한 요소는 아닙니다. 효과적인 프롬프트와 다른 접미사 매개변수를 결합하는 것이 중요합니다.\n\n- by 公众号：二阶导\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n💡관심이 있으신가요? 저의 Midjourney 컬렉션으로 깊은 내용을 살펴보세요.\n\n## 기사가 마음에 드셨나요?\n\n만약 마음에 드셨다면:\n\n- 댓글 남기기\n- 업데이트 팔로우하기\n- 무료 이메일 알림 받기\n","ogImage":{"url":"/assets/img/2024-05-17-Top10collectionsforMidjourneystylereferencecodes_0.png"},"coverImage":"/assets/img/2024-05-17-Top10collectionsforMidjourneystylereferencecodes_0.png","tag":["Tech"],"readingTime":9},{"title":"NodePiece 노드 ID에서 토큰으로","description":"","date":"2024-05-17 20:06","slug":"2024-05-17-NodePieceFromNodeIDstoTokens","content":"\n그래프 임베딩에 대한 혁신적인 접근\n\n![이미지](/assets/img/2024-05-17-NodePieceFromNodeIDstoTokens_0.png)\n\n# 소개\n\n자연어 처리(NLP) 및 대형 언어 모델(LLM)에 대한 관심과 발전이 급증한 것은 잘 알려져 있습니다. “토큰화” 및 “트랜스포머”와 같은 용어들이 어디서든 볼 수 있을 정도입니다. 그러나 그래프 신경망(GNN) 및 특히 지식 그래프 임베딩이라는 또다른 강력한 분야는 전문가들을 제외하고는 훨씬 인기가 적습니다. 이러한 기술들은 추천 시스템에서 링크 예측, 노드 분류 등 다양한 애플리케이션 영역에서 강력한 솔루션을 제공합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nGNN 세계에서 주목할 만한 기술 중 하나는 NodePiece 토큰화인데, 이견에 따르면 많은 주의를 필요로 합니다. 이 접근 방식은 그래프 신경망의 기능성을 향상시키기 위해 자연어 처리(NLP)에서 여러 개념을 도입한 새로운 방법론입니다. 이 기술은 유니버셜 \"토큰\" 집합을 사용하여 그래프 내 노드를 표현합니다. 이 접근 방식은 미리 정의된 ID 어휘가 필요 없어져 노드의 좀 더 적응적인 표현을 가능케 하며 모델이 다양한 그래프에 대해 일반화할 수 있는 능력을 향상시킵니다.\n\n잠재력이 커도 NodePiece 토큰화 방법론은 널리 다뤄지지 않는데, 예를 들어 LLMs와 같이요. 이 블로그 글은 NodePiece 토큰화를 명쾌하고 직관적으로 설명하며, 기존 구현이 매우 복잡하고 이미 구현된 라이브러리에 내장되어 있어 학습이 어려운 점을 감안하여 실용적인 Python 구현을 제공합니다.\n\n이 글을 마치면 다음을 이해할 수 있을 것입니다:\n\n1. NodePiece 토큰화의 기본 개념들을 파악할 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n2. 이 기술의 근간과 원칙을 이해하세요.\n\n3. Python에서 NodePiece 토큰화의 기본 버전을 구현하는 기술을 익히세요.\n\n저의 Github에서 Jupyter 노트북 및 토큰화 및 모델을 담은 모듈을 찾을 수 있습니다.\n\n이 포스트는 꽤 길기 때문에 섹션 및 하위 섹션의 간단한 개요입니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n제목 1: 건설 블록의 마법\n\n1.1. NLP 세계 - 역사 요약: 이 섹션은 자연어 처리의 진화를 강조하며 Word2Vec 및 GloVe와 같은 기본 알고리즘에 초점을 맞춥니다.\n1.2. 트랜스포머 토크나이저의 출현: NLP 모델의 효율성과 유연성에 미치는 트랜스포머 기반 토큰화의 중요한 영향을 논의합니다.\n1.3. 그래프 세계: NLP 토큰화 개념을 그래프 신경망에 적용하는 잠재력을 탐구하여 NodePiece를 위한 무대를 마련합니다.\n\n제목 2: NodePiece 알고리즘\n\n2.1. 기여 및 출처: NodePiece 모델을 소개하며 새로움과 NLP로부터 영감을 얻은 주요 출처에 집중합니다.\n2.2. 기본 개념: NodePiece 모델의 핵심 구성 요소를 설명하며 그래프 노드의 토큰화 방법을 소개합니다.\n2.3. 위치적 특징: NodePiece가 노드의 공간적 위치를 선택된 기준점에 상대적으로 어떻게 활용하는지 설명합니다.\n2.4. 관계적 특징: NodePiece가 노드가 참여하는 관계 유형을 어떻게 파악하는지 상세히 설명합니다.\n2.5. 독특한 지문 - 직관: NodePiece가 위치적 및 관계적 특징을 결합하여 독특한 노드 임베딩을 만드는 방식에 대한 직관적 설명을 제공합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### 파트 3: 형식적 정의\n\n3.1. Set-Based Form: 노드를 앵커, 거리 및 관계의 집합을 통해 표현하는 프로세스를 형식화합니다.\n3.2. 앵커, 거리 및 관계의 내장: NodePiece가 벡터 표현으로 변환하는 집합의 방법을 설명합니다.\n3.3. 부호화: 노드 정보를 단일 벡터로 압축하는 부호화 프로세스를 설명합니다.\n3.4. 이것으로 무엇을 할까요?: NodePiece 임베딩이 그래프 신경망에서의 잠재적인 응용 및 이점에 대해 논의합니다.\n\n### 파트 4: 간소화된 구현\n\n4.1. 전체 개요: 교육 목적을 위해 설계된 NodePiece의 간소화된 버전을 소개합니다.\n4.2. 데이터: 데모에 사용된 데이터셋을 설명하며, 실용성을 위해 관리 가능한 하위 집합의 선택을 강조합니다.\n4.3. 토큰화: 간소화된 모델 내에서 NodePiece의 토큰화 프로세스를 설명합니다.\n4.4. 앵커 선택: 구현에서 앵커 노드를 선택하는 방법을 상세히 설명합니다.\n4.5. K개 최근 앵커까지의 거리 구성: 모델이 노드에서 가장 가까운 앵커까지의 거리를 계산하는 방법을 설명합니다.\n4.6. 관계적 컨텍스트 추출: 노드의 관계적 컨텍스트를 식별하고 내장하는 프로세스를 설명합니다.\n4.7. 특성 행렬: 토큰화 및 컨텍스트 추출 결과를 특성 행렬 형태로 강조합니다.\n4.8. 전체 모델 정의: 모델 아키텍처 및 구성 요소에 대해 포괄적으로 살펴봅니다.\n4.9. TransE 모델 훈련: 지식 그래프 임베딩 작업에 NodePiece 임베딩을 사용하여 TransE 모델 훈련에 대해 논의합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 파트1: 빌딩 블록의 마법\n\n## NLP 세계 — 역사 소개\n\nNLP의 발전을 되짚어보면 초기 단계는 단어 임베딩, 어근 추출 및 토크나이제이션과 같은 방법론들에 의해 주도되었습니다. Church(2017)와 Brochier 등(2019)과 같은 선구적인 알고리즘들이 Word2Vec 및 GloVe와 같은 표준을 설정하며, 비교적 간단한 절차하에서 작동했습니다:\n\n1. 큰 텍스트 말뭉치를 편집하십시오.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n2. 토큰화, 표제어 추출 및 유사한 기술을 통해 전처리합니다.\n\n3. 처리된 단어를 고유한 ID로 매핑하는 임베딩 조회를 구축합니다.\n\n그러나 이 접근 방식은 공간을 많이 차지하고 계산 비용이 많이 드는 방식이었습니다.\n\n예를 들어, 임베딩 행렬이 다음과 같이 정의된 경우를 고려해보겠습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![NodePieceFromNodeIDstoTokens](/assets/img/2024-05-17-NodePieceFromNodeIDstoTokens_1.png)\n\n어휘 크기(V) 및 임베딩 크기(E)였습니다. 어휘 크기가 100,000이고 임베딩 크기가 300인 경우, 리소스에 상당한 수요를 일으키는 30 백만개의 부동 소수점을 할당해야 합니다.\n\n## 트랜스포머 토크나이저의 등장\n\n트랜스포머 및 그와 관련된 토큰화 방법의 도입이 이 분야를 혁신적으로 변화시켰습니다. Byte-Pair Encoding (BPE) (Sennrich et al., 2016)과 같은 기술은 부분 단어 또는 알파벳과 같은 건설 블록에 유사한 개념을 도입하여 토큰화 프로세스를 혁신적으로 개선했습니다. 이러한 부분 단어 또는 토큰은 전체 단어보다 더 간결하면서도 보다 보편적이며, 다양한 언어에 적용될 수 있고 새로운 어휘를 순차적으로 도입할 수 있도록 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래와 같이 표시됩니다. 해당 표현은 전통적인 방법에서는 단어를 분리하여 각각 임베딩을 할당할 것이지만, 현대적인 토크나이저는 서브워드로 분할할 수 있습니다.\n\n```js\n[CLS]\nmodern\ntoken\n##izer\n##s\nrevolution\n##ized\nthe\nway\n,\nhow\nwe\nprocess\ntext\nthese\ndays\n[SEP]\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이는 \"tokenizer\"와 같은 각 새로운 단어에 대한 고유한 ID가 필요하지 않게되어 \"token\"과 \"##izers\"가 이미 어휘에 있는 상태로 다른 단어의 표현을 구성할 수 있게 해줍니다. 이는 임베딩 메모리 공간을 절약하면서 가능하게 합니다.\n\n## 그래프의 세계\n\n그래프 처리 및 지식 그래프 추론의 분야에서는 현대 NLP 토큰화에 사용되는 개념과 유사한 개념을 받아들이는 과정이 느리게 진행되어 왔습니다. TransE (Bordes et al., 2013) 및 RotatE (Sun et al., 2019)와 같은 지식 그래프 추론을 위한 전통적인 알고리즘은 대부분 엔티티와 관계를 고유한 임베딩에 매핑하는 데 의존해 왔습니다. 이 접근 방식은 간단하지만 메모리 집약적이며, 각 엔티티 및 관계는 임베딩 공간 내에서 고유한 식별자를 필요로 합니다 — 마치 word2vec이나 기존 NLP 솔루션에서의 단어들처럼!\n\nTransE, RotatE 및 유사한 모델에 대해 더 알고 싶은 분은 Medium.com의 게시물을 강력히 추천합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 기사는 이러한 모델 뒤에 있는 원칙들에 대해 포괄적인 개요를 제공합니다.\n\n그래프 도메인 내에서 확장 가능하고 효과적인 솔루션을 찾는 것은 오랜 시간이 걸리지만 결과가 있었습니다. 노드피스(NodePiece)는 이 맥락에서의 선도적인 알고리즘 중 하나로 등장했으며, NLP 토큰화 기술의 발전에서 많은 영감을 받았습니다. 최신 토큰화 기술의 원칙을 그래프 구조에 적용함으로써, 노드피스는 그래프 엔티티와 관계를 표현하는 새로운 방법을 제공하며, 지식 그래프 도메인에서 더 많은 메모리 효율적이고 일반화 가능한 모델을 향한 중요한 발전을 이룩했습니다.\n\n# 파트 2: 노드피스 알고리즘\n\n## 기여와 출처\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n노드피스 알고리즘은 대규모 지식 그래프에 대한 합성 및 매개변수 효율적인 표현에 중점을 둔 지식 그래프 임베딩 분야에서의 중요한 발전을 대표합니다. \"NodePiece: Compositional and parameter-efficient representations of large knowledge graphs\" (Galkin et al., 2021) 논문에서 소개된 이 방법은 널리 사용되는 Python 라이브러리인 PyKeen에 통합되어 있습니다.\n\nPyKeen 구현은 아래에서 찾을 수 있습니다:\n\n게다가, 논문 기여자들에 의해 작성된 구현은 GitHub에서 접근 가능하며, 원본 코드베이스를 더 탐구하려는 분들을 위해 제공됩니다:\n\n이론적 관점에서 노드피스에 대한 포괄적이고 접근성 있는 소개를 위해, 원문의 공헌자 중 한 명인 Michael Galkin이 작성한 Medium 블로그 게시물 \"NodePiece: Tokenizing Knowledge Graphs\"를 읽어보시기를 권장합니다. 이 기사는 알고리즘에 대한 귀중한 심층적인 통찰을 제공하여 개발자들로부터 직접 얻은 통찰을 제공합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n마이클 갈킨의 블로그 게시물 'NodePiece: 지식그래프의 토큰화'는 NodePiece 알고리즘에 대한 깊은 설명으로 두루 짚고 있으며, 그 중 하나인 창조자에 의해 저술되었습니다. 이는 원래의 학술 논문을 넘어서 모델을 이해하려는 사람들에게 좋은 자료입니다.\n\n## 기본 개념\n\nNodePiece 알고리즘은 지식 그래프 내 개체마다 고유 식별자를 할당하는 전통적 요구사항에서 벗어나, 대신 기본적인 구성 요소의 조합을 통해 개체를 나타냅니다. NLP의 토큰화 개념과 유사점을 그리며, 이러한 구성 요소는 다음과 같습니다:\n\n1. 위치 특성: 지정된 앵커 노드에 대한 노드의 근접성.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n2. 관계 특성: 노드가 포함된 관계 유형\n\n## 위치 특성\n\n노드는 미리 정한 일련의 기준 앵커 노드들까지의 거리로 특성화됩니다. 이러한 앵커 노드를 선택하는 방법은 가장 연결된 노드를 선택하거나 클러스터링 알고리즘을 사용하거나 심지어 무작위 선택과 같은 선택 옵션을 포함합니다.\n\n선택 기술에 관계없이 근본적인 원칙은 간단합니다. 각 노드는 K개의 가장 가까운 앵커 노드까지의 거리에 의해 정의됩니다. 전략적인 앵커 노드 선택을 통해 가장 가까운 앵커에 대한 근접성이 각 노드에 대한 고유한 \"지문\"을 제공하는 높은 가능성이 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음 예시를 통해 이 개념을 설명해 보겠습니다:\n\n![NodePieceFromNodeIDstoTokens_2](/assets/img/2024-05-17-NodePieceFromNodeIDstoTokens_2.png)\n\n아래 표는 각 노드에서 앵커까지의 거리를 요약한 것입니다:\n\n![NodePieceFromNodeIDstoTokens_3](/assets/img/2024-05-17-NodePieceFromNodeIDstoTokens_3.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 관계형 기능\n\n이질적인 지식 그래프에서 엣지는 노드 간의 다양한 관계 유형을 캡슐화합니다. NodePiece 알고리즘은 이러한 관계를 노드 표현의 중요한 구성 요소로 활용하여 각 노드의 컨텍스트와 그래프 내에서의 연결성을 풍부하게 합니다. 관계형 기능이 어떻게 통합되는지 설명하기 위해, 우리의 이전 예제를 다시 살펴보고 확장하겠습니다. 이번에는 관계 유형을 포함하여:\n\n![노드의 관계형 기능](/assets/img/2024-05-17-NodePieceFromNodeIDstoTokens_4.png)\n\n각 노드의 관계를 다음의 표로 요약할 수 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![NodePieceFromNodeIDstoTokens_5](/assets/img/2024-05-17-NodePieceFromNodeIDstoTokens_5.png)\n\nOr with counting each relation type:\n\n![NodePieceFromNodeIDstoTokens_6](/assets/img/2024-05-17-NodePieceFromNodeIDstoTokens_6.png)\n\nProbably you see now, where it is going…\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 독특한 지문 — 직감\n\nNodePiece 알고리즘의 본질은 각 노드에 대한 일관된 표현인 위치 및 관계형 두 가지 다른 기능을 종합하는 능력에 있습니다. 이 과정은 가장 가까운 앵커 노드와 노드가 참여하는 관계 유형을 연결하여 노드의 고유한 \"지문\"이라는 단일 벡터를 얻게 됩니다.\n\n이 과정을 개념화하기 위해 다음 단순화된 스키마를 통해 노드 2를 나타내는 것을 고려해보세요:\n\n![NodePieceFromNodeIDstoTokens_7](/assets/img/2024-05-17-NodePieceFromNodeIDstoTokens_7.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 파트 3: 형식적인 정의\n\nNodePiece 알고리즘 코딩을 시작하기 전에 언급할 중요한 세부 정보가 몇 가지 있습니다. 예를 들어:\n\n1. 선택적 앵커 사용: 모든 노드의 표현에 모든 앵커가 관련이 있는 것은 아닙니다. 가장 가까운 k개의 앵커만이 각 노드에 임베딩하기 위해 고려됩니다.\n\n2. 관계 추출: 마찬가지로, 노드의 관계적 문맥은 즉시 외부 관계 중에서 샘플링을 통해 파생되며, 각 노드당 최대 m개의 관계로 제한됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n3. 연결 끊김 처리: 노드가 연결이 끊겼거나 특정 앵커나 관계에 대한 링크가 없는 경우 — 특별한 [DISCONNECTED] 토큰이 사용됩니다. 이는 NLP 시나리오에서의 `OOV` (out-of-vocabulary) 토큰과 유사합니다.\n\n이제 수학 시간입니다.\n\nNodePiece에 대한 입력이 무엇인지 시작해 봅시다:\n\n![NodePieceFromNodeIDstoTokens_8.png](/assets/img/2024-05-17-NodePieceFromNodeIDstoTokens_8.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNodePiece는 다음과 같이 설계되었음을 알 수 있습니다:\n\n1. 지식 그래프 - 특정 관계(R)에 속하는 에지(E)로 연결된 노드(N)의 모음으로 표현됩니다.\n\n2. 선택된 앵커 노드 (A) - 이들은 각 노드의 \"지문\" 표현의 일부가 될 것입니다.\n\n3. 관계 (R) 및 앵커 (A)는 모델의 어휘 (V)를 형성합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n4. 논문에서 언급했듯이, 모든 노드에 대해 모든 앵커를 사용할 필요는 없으므로 k개의 앵커가 샘플링됩니다.\n\n5. 관계에도 같은 원칙이 적용됩니다. 각 노드에 대해 m개의 관계만이 샘플링됩니다.\n\n## 집합 기반 형태\n\n우리가 가지고 있는 핵심 요소들로부터, 그래프 내 각 노드의 고유한 \"지문\"에 대한 형식적인 정의로 이어질 수 있습니다. 이 지문은 세 가지 구성 요소로 나뉩니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n1. 앵커 세트: 모든 앵커(A) 집합에서 임의로 선택된 k개의 앵커입니다.\n\n2. 앵커 거리: 노드에 대해 결정된 k개 가장 가까운 앵커까지의 최단 경로 거리입니다. 앵커에 도달할 수 없는 경우, 해당 거리는 미리 정의된 \"마법 값\"으로 표시됩니다. (-1 또는 다른 토큰과 같이)\n\n3. 관계적 맥락: 노드를 위해 샘플링된 m개의 직접 외부 관계 중 일부로, 즉시 관계적 환경을 포함합니다.\n\n형식적으로 표현하면, 정점 집합 V의 각 노드 u에 대한 표현은 다음과 같이 설명할 수 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![2024-05-17-NodePieceFromNodeIDstoTokens_9.png](/assets/img/2024-05-17-NodePieceFromNodeIDstoTokens_9.png)\n\n원본 논문의 저자들은 거리에 positional encoding을 적용하여 각 거리를 차원 d의 벡터로 매핑하는 것을 옹호합니다. 이 접근 방식은 임베딩의 의도된 차원을 유지하는 것을 보장합니다.\n\n![2024-05-17-NodePieceFromNodeIDstoTokens_10.png](/assets/img/2024-05-17-NodePieceFromNodeIDstoTokens_10.png)\n\n앵커 및 해당 거리에 대해 임베딩 조회 전략이 제안됩니다. 이는 각 앵커 id(예: 앵커=0)가 임베딩 행렬의 특정 행에 연결되며, 거리에 대해서도 동일한 방식으로 적용됨을 의미합니다(예: 거리=1은 embedding 1에 해당). 이 방법은 각 노드의 그래프 내 고유한 서명의 위치 및 관계적 측면을 효율적이고 의미 있게 인코딩하는 데 도움이 됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n고려해야 할 점은 기존 방법에서 사용되는 고유 노드 ID의 인구보다 앵커 수와 앵커 거리가 훨씬 작다는 것이다!\n\n## 앵커, 거리, 관계의 임베딩\n\n방정식 (1)으로 구분된 세트의 변환을 통해 임베딩을 통한 벡터 표현으로 포함된 기본 단계가 여러 단계 포함됩니다 (텍스트와 방정식을 섞는 Medium.com의 제한으로 인해 아래 부분은 이미지로 게시되었습니다).\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Node representation matrix](/assets/img/2024-05-17-NodePieceFromNodeIDstoTokens_12.png)\n\nAfter that, authors sum vectors related to anchors, so that the matrix node representation is as follows:\n\n![Node representation matrix](/assets/img/2024-05-17-NodePieceFromNodeIDstoTokens_13.png)\n\n## Encoding\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n방정식 (3)에 나온 행렬은 각 노드 u에 대해 해당 인코더(MLP 또는 Transformer)를 적용하여 벡터로 변환을 용이하게 합니다. 이것은 원래 연구에서 발표된 것처럼 진행됩니다.\n\n이 인코더는 행렬을 각 노드에 대한 \"펼쳐진\" 벡터 표현으로 변환하여 복잡한 관계 및 위치 정보를 간결한 형태로 요약합니다.\n\n아래는 이 인코딩 프로세스를 실제 예제로 설명하는 목적으로 노드 2에 대한 표현을 고려해 봅시다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- Anchor를 0부터 시작하는 식별자로 할당하므로 id(Anchor 1) = 0 및 id(Anchor 2) = 1입니다.\n\n- 관계는 유사하게 식별자가 부여되어 id(r1) = 0, id(r2) = 1, id(r3) = 2 등입니다.\n\n- 거리는 id(dist=1) = 0, id(dist=2) = 1, id(dist=3) = 2 등과 같은 방식으로 인덱싱됩니다.\n\n- k=m=2인 경우 각 노드에 대해 두 개의 Anchor와 두 개의 관계가 샘플링됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n주어진 매핑을 가정하고 차원 공간 d = 3인 경우, 방정식 (2)에 따른 표현은 다음과 같이 나타납니다:\n\n![image1](/assets/img/2024-05-17-NodePieceFromNodeIDstoTokens_15.png)\n\n![image2](/assets/img/2024-05-17-NodePieceFromNodeIDstoTokens_16.png)\n\n\\*0부터 세는 것을 기억하세요 :) id(r1) = 0, id(Anchor1) = 0, 등등 :).\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/assets/img/2024-05-17-NodePieceFromNodeIDstoTokens_17.png)\n\n그 후, 각 앵커, 거리, 그리고 관계에 d-차원 임베딩이 적용됩니다. 이들은 크기 d의 벡터로 매핑됩니다. 예를 들어, d=3인 경우, 앵커, 거리, 그리고 관계에 대한 결과 행렬은 방정식 (2)와 일치하는 다음과 같을 수 있습니다:\n\n![이미지](/assets/img/2024-05-17-NodePieceFromNodeIDstoTokens_18.png)\n\n물론 각 행렬의 값은 예시입니다 — 실제 모델에서는 아마 무작위 숫자들이 될 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n앵커와 관련된 벡터를 합한 후에 방정식(3)에 정해진대로 연결하면 다음과 같이 유도됩니다:\n\n![image](/assets/img/2024-05-17-NodePieceFromNodeIDstoTokens_19.png)\n\n이러한 과정은 인코딩이 각 노드에 대해 앵커, 거리 및 관계 데이터의 복잡한 배열을 통합하고 단순화하여 다운스트림 그래프 처리 작업에 즉시 사용할 수 있도록 만드는 능력을 보여줍니다.\n\n## 어떻게 활용할까요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n지금부터 사용자는 분류, 클러스터링 등과 같은 하위 작업을 진행할 수 있습니다.\n\n각 노드의 표현은 이제 일반적인 특성처럼 사용할 수 있는 평면 벡터입니다.\n\n노드의 고유한 특성을 캡처해야 합니다. 즉, 그래프 내에서의 위치, 관계 등을 포함해야 합니다.\n\n논문 자체에서는 NodePiece 알고리즘의 기본적인 최적화, 트릭 및 개선 사항들이 여러 가지 언급되어 있지만, 이 간소화된 설명에서는 나머지 부분을 건너 뜁했습니다. 자세한 내용에 관심이 있다면 원본 논문을 꼭 읽어보시기를 강력히 권장합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 파트 4: 단순화된 구현\n\n## 개요\n\n노드피스 알고리즘의 기존 구현인 원본 논문의 저자들이 제공하고 있는 PyKeen 라이브러리 내의 버전들은 포괄적이지만 복잡합니다. 이러한 버전들은 성능 및 기존 프레임워크 내 통합을 최적화한 것이지만, 응용 프로그램 개발에 유용할 수 있지만, 알고리즘의 이론적 기초와 실제 코드 표현 사이의 개념적 공통점을 명확히하는데 어려움을 줄 수 있습니다. 이러한 복잡성은 알고리즘을 이해하려는 사람들에게 어려움을 줄 수 있습니다.\n\n교육용으로 맞춤화된 구현의 제한된 가용성과 알고리즘의 기본 메커니즘을 이해하고자 하는 사람들을 위한 것이 아닌 알고리즘에 대해 더 깊이있게 이해하려는 사람들을 위한 간소화된 NodePiece의 버전을 개발하기로 선택했습니다. 이 버전은 명확성과 확장성을 염두에 두고 설계되었으며, 최적화와 프레임워크별 고려사항을 초과하는 부담 없이 알고리즘의 기본 메커니즘을 이해하려는 개인들에게 더 접근성 있는 진입점을 제공합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위 간소화된 구현은 두 가지 주요 구성 요소로 구성되어 있습니다:\n\n1. Tokenization Module: 이 코드 세그먼트는 앵커 및 관계를 선택하고 노드 표현을 구성하는 데 책임이 있으며 앵커, 관계 및 거리에 대한 식별자로 노드 표현을 정렬합니다. 이는 방정식(1)에서 설명된 프로세스와 일치하며, 노드의 앵커와의 관계 및 다양한 관계에 참여함으로써 노드의 고유한 \"지문\"을 생성하는 초기 단계를 총망라합니다.\n\n2. Models Module: 이 부분은 식별자를 벡터 공간에 포함시키고 예측 모델을 구축하는 작업을 수행합니다. 이는 NodePiece 알고리즘의 후속 단계를 구현하는 것으로, 노드의 추상적인 표현을 밀집 벡터 표현으로 변환하고 이를 하류 기계 학습 작업에서 활용할 수 있게 합니다.\n\n## 데이터\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n실습 목적으로 이 튜토리얼은 FB15k-237 데이터셋의 작은 하위 집합을 활용할 것입니다. 데이터셋의 축소판을 사용하는 이유는 실용성에 있습니다: 로컬에서 전체 데이터셋에 모델을 학습하는 데에는 시간이 많이 소요될 수 있습니다. 이 하위 집합은 결과 그래프가 일관되고 연결되어 있으며 전체 데이터셋의 구조적 무결성과 관계 복잡성을 유지하도록 꼼꼼히 만들어졌습니다. 이 방식을 통해 NodePiece 알고리즘을 빠르고 통찰력 있게 탐구할 수 있으며, 단순화된 구현을 더 관리하기 쉬운 규모로 실험하고 확장할 수 있습니다.\n\n저희 축소된 데이터셋은 다음과 같은 구성 요소로 이루어져 있습니다:\n\n1. 훈련 데이터셋 — 123,816 개의 삼중 세트.\n\n2. 검증 데이터셋 — 402 개의 삼중 세트.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n3. 테스트 데이터셋 — 224개의 삼중 세트가 있습니다.\n\n4. 237가지 고유한 관계 유형이 있습니다.\n\n## 토큰화\n\n이제 그래프를 토큰화할 시간입니다. 우리는 단순화된 NodePiece 논리를 사용하는 사용자 정의 함수를 사용할 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 내용을 다음과 같이 번역하겠습니다.\n\n전체 데이터셋에서:\n\n- 30개의 앵커를 선택합니다.\n- 각 노드에 대해 20개의 가장 가까운 앵커를 선택합니다.\n- 각 노드에 대해 10가지 관계를 선택합니다.\n\n## 앵커 선정\n\n앵커 선정 함수를 시작해보겠습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\ndef degree_anchor_select(g: nx.Graph, n_anchors: int|float = 0.1) -> Tuple[List[int], Dict[int, int]]:\n    \"\"\"앵커 선택 방법으로, 용이한 경중에 따라 기초합니다. 가장 간단한 휴리스틱에 기초하여\n    이 그래프 내에서 가장 많은 노드와 연결되는 것으로 가정하고 노드의 최고 차수를 가진 노드를\n    앵커로 선택합니다.\n\n    매개변수\n    ----------\n    g : nx.Graph\n        Networkx 그래프입니다.\n    n_anchors : int | float, 선택사항\n        선택할 앵커의 수로, 기본값은 0.1입니다.\n        int일 경우 - 선택할 앵커 수입니다.\n        float일 경우 - 앵커로 선택할 노드의 비율입니다.\n\n    반환값\n    -------\n    Tuple[List[int], Dict[int, int]]\n        1. 앵커 노드 목록입니다.\n        2. 앵커 노드를 해당 ID로 매핑한 딕셔너리입니다. 앵커 ID는 [0, n_anchors) 범위 내에 있습니다.\n    \"\"\"\n    if type(n_anchors) == float:\n        n_anchors = int(g.number_of_nodes() * n_anchors)\n\n    degrees = sorted(g.degree, key=lambda x: x[1], reverse=True)\n    anchor_2_id = {}\n    anchors = []\n    for i, (node, _) in enumerate(degrees[:n_anchors]):\n        anchors.append(node)\n        anchor_2_id[node] = i\n\n    return anchors, anchor_2_id\n```\n\n`degree_anchor_select` 함수는 이 작업에 대해 직관적이면서도 효과적인 방법을 보여줍니다. 노드의 차수를 앵커 선택 기준으로 활용합니다. 이 방법은 높은 차수를 갖는 노드가 더 많은 연결을 의미하므로 해당 그래프의 다양한 부분에 연결될 가능성이 높기 때문에 최적의 앵커로 간주합니다. 함수가 작동하는 방식을 단계별로 살펴보겠습니다:\n\n1. 입력 매개변수: 함수는 NetworkX 그래프 `g`와 `n_anchors` 매개변수를 받습니다. `n_anchors` 매개변수는 선택할 앵커의 수를 지정하며, 이 값은 그래프의 노드 중 일정 비율(기본값은 0.1 또는 10%)을 앵커로 지정할 경우에 float로 지정하거나 원하는 앵커 수를 정수로 지정할 수 있습니다.\n\n2. 차수 계산 및 정렬: 함수는 그래프 내 각 노드의 차수를 계산합니다. 그런 다음, 노드들을 차수에 따라 내림차순으로 정렬하여 앵커로 선택할 때 높은 차수의 노드를 우선하여 고려합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n3. ID 매핑 앵커: 선택된 각 앵커 노드를 0부터 시작하는 고유 식별자에 매핑하는 anchor_2_id 사전이 초기화됩니다. 이 매핑은 NodePiece 토큰화 프로세스의 이후 단계에서 앵커 노드를 효율적으로 식별하고 활용할 수 있게 합니다.\n\n4. 반환 값: 이 함수는 선택된 앵커 노드의 목록과 anchor_2_id 사전을 포함하는 튜플을 반환합니다. 목록에는 앵커로 선택된 노드들이 포함되며, 사전은 이러한 앵커 노드와 할당된 ID 사이의 매핑을 제공하여 노드 표현 구성 시에 직접 참조할 수 있게 합니다.\n\n## K개 가까운 앵커까지의 거리 구축\n\n다음으로, 각 노드에서 K개 가까운 앵커 노드까지의 최단 경로 거리를 계산하는 함수를 구축할 예정입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\ndef build_distance_to_k_nearest_anchors(\n        G: nx.Graph,\n        anchors: List[int],\n        anchor2id: dict,\n        k_closest_anchors: int = 15,\n        use_closest: bool = True) -> Tuple[np.ndarray, np.ndarray, int]:\n    \"\"\"그래프의 각 노드에 대해 k개 가장 가까운 앵커까지의 거리를 계산합니다.\n\n    매개변수\n    ----------\n    G : nx.Graph\n        네트워크x 그래프.\n    anchors : List[int]\n        앵커 노드 목록.\n    anchor2id : dict\n        앵커에서 id로의 매핑.\n    k_closest_anchors : int, optional\n        각 노드에서 선택할 k개 가장 가까운 앵커의 수, 기본값은 15\n    use_closest : bool, optional\n        가장 가까운 앵커를 사용해야 하는지 또는 모두 사용해야 하는지 여부, 기본값은 True\n\n    반환값\n    -------\n    Tuple[np.ndarray, np.ndarray, int]\n        다음으로 구성된 튜플:\n        1. 노드와 앵커 사이의 거리 행렬. 형태: (노드 수, 앵커 수).\n        2. 노드와 앵커 id 행렬. 형태: (노드 수, 앵커 수).\n        3. 그래프 내의 최대 거리. 거리 인코딩/임베딩에 사용될 것입니다.\n    \"\"\"\n    node_distances = {i: [] for i in range(G.number_of_nodes())}\n    for a in tqdm(anchors):\n        for node, dist in nx.shortest_path_length(G, source=a).items():\n            node_distances[node].append((a, dist))\n\n    node2anchor_dist = np.zeros((G.number_of_nodes(), len(anchors)))\n    node2anchor_idx = np.zeros((G.number_of_nodes(), len(anchors)))\n    unreachable_anchor_token = len(anchors)\n    node2anchor_idx.fill(unreachable_anchor_token)\n\n    max_dist = 0\n\n    for node, distances in tqdm(node_distances.items()):\n        indices_of_anchors = sorted(distances, key=lambda x: x[1])[:k_closest_anchors] if use_closest else node_distances[node]\n        for i, (anchor, dist) in enumerate(indices_of_anchors):\n            anchor_id = anchor2id[anchor]\n            node2anchor_dist[node, anchor_id] = dist\n\n            node2anchor_idx[node, i] = anchor_id\n            if dist > max_dist:\n                max_dist = dist\n    unreachable_anchor_indices = node2anchor_idx == unreachable_anchor_token\n    node2anchor_dist[unreachable_anchor_indices] = max_dist + 1\n    return node2anchor_dist, node2anchor_idx, max_dist\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n3. 거리 및 인덱스 행렬의 인구: 이 함수는 각 노드의 앵커까지의 거리를 정렬하여 각 노드에 대해 가장 가까운 k개의 앵커를 선택합니다. 선택된 앵커까지의 거리와 인덱스는 각각의 배열에 저장됩니다. 이 과정에서 max_dist 변수는 관측된 최대 거리를 반영하도록 업데이트되어, 도달할 수 없는 앵커는 이 최대값을 초과하는 거리로 표시됩니다 (max_dist +1 - \"마법 OOV 토큰\" :)).\n\n4. 도달할 수 없는 앵커 처리: 앵커에 대한 경로가 없어 도달할 수 없는 노드의 경우 거리가 max_dist + 1로 설정됩니다. 이 조정은 node2anchor_idx의 unreachable_anchor_token과 일치하는 인덱스를 식별하여 해당하는 node2anchor_dist 항목을 이 증가된 최대 거리로 설정함으로써 이뤄집니다. 이 메커니즘은 효과적으로 일부 앵커로부터 격리된 노드를 처리하며, 그래프 내에서 연결되지 않은 구성 요소의 가능성을 인정하여 NodePiece 표현의 무결성을 유지합니다.\n\n5. 반환 값: 함수는 노드마다 가장 가까운 앵커 지점에 대한 포용도를 제공하는 node2anchor_dist 거리 행렬, 앵커 인덱스 행렬 node2anchor_idx 및 max_dist 값을 포함하는 튜플을 반환함으로써 마무리됩니다. 이러한 출력은 NodePiece 임베딩을 구성하는 기초를 제공하여 각 노드의 근접성에 대한 종합적인 매핑을 제공합니다.\n\n## 관계적 컨텍스트 추출\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음 단계는 각 노드에 대한 관련 컨텍스트를 추출하는 것입니다.\n\n```js\ndef sample_rels(pyg_g: pyg_data.Data, max_rels: int = 50) -> th.Tensor:\n    \"\"\"각 노드에 대해 m개의 외부 관계를 샘플링합니다. 노드의 관계가 m보다 적은 경우, 특수 토큰으로 출력을 채웁니다.\n\n    매개변수\n    ----------\n    pyg_g : pyg_data.Data\n        PyTorch Geometric 그래프.\n    max_rels : int, optional\n        사용할 관계의 최대 수, 기본값은 50입니다.\n\n    반환\n    -------\n    th.Tensor\n        각 노드에 대한 관계 행렬. 형태: (노드 수, max_rels).\n        각 행은 특정 노드에 해당하며, 각 열은 관계(ID)에 해당합니다.\n    \"\"\"\n    rels_matrix = []\n    missing_rel_token = pyg_g.edge_type.max() + 1\n    for node in tqdm(range(pyg_g.num_nodes)):\n        node_edges = pyg_g.edge_index[0] == node\n        node_edge_types = pyg_g.edge_type[node_edges].unique()\n        num_edge_types = len(node_edge_types)\n\n        if num_edge_types < max_rels:\n            pad = th.ones(max_rels - num_edge_types, dtype=th.long) * missing_rel_token\n            padded_edge_types = th.cat([node_edge_types, pad])\n            padded_edge_types = padded_edge_types.sort()[0]\n        else:\n            sampled_edge_types = th.randperm(num_edge_types)[:max_rels]\n            padded_edge_types = node_edge_types[sampled_edge_types].sort()[0]\n        rels_matrix.append(padded_edge_types)\n    return th.stack(rels_matrix)\n```\n\n1. 초기화: 함수는 PyTorch Geometric (PyG) 그래프 객체 pyg_g와 선택적으로 최대 관계 수를 결정하는 max_rels 매개변수를 필요로 합니다. 기본값은 50입니다. 모든 노드의 관계 데이터를 보유할 빈 리스트 rels_matrix가 준비되어 있습니다. 또한, 주어진 노드에 대한 관계가 없음을 나타내는 missing_rel_token이 정의되며, 사실상 다음 \"어휘 외\" 토큰으로 작동합니다. 이 토큰은 그래프에서 발견된 가장 큰 관계 ID보다 1 큰 값으로 설정됩니다.\n\n2. 고유 관계 탐색: 각 노드에 대해 고유한 외부 엣지 유형(관계)을 찾습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n3. 관계 수 확인: 그래프의 각 노드에 대해, 이 함수는 노드에 연결된 모든 고유한 발신 관계 유형(엣지 유형)을 식별합니다.\n\n4. 관계 수 조정: 노드의 고유한 관계 수가 max_rels 임계값보다 작을 경우, 관계 목록에 누락된 관계 토큰을 추가하여 지정된 최대값에 도달하도록 패딩 처리됩니다. 이는 모든 노드에서 관계적 문맥의 길이를 균일하게 유지합니다.\n\n반대로, 노드가 max_rels로 허용하는 관계 유형보다 많이 연결된 경우, 제한에 맞게 일부가 무작위로 선택됩니다. 이 무작위 샘플링은 세부 정보와 계산 효율성 사이의 균형 유지에 필요한 것을 나타냅니다.\n\n4. 관계 정렬 및 저장: 각 노드에 대한 샘플링된(또는 추가된) 관계는 일관된 순서를 유지하도록 정렬됩니다. 정렬된 목록은 그래프 전체에 대한 포괄적인 관계적 문맥 저장소를 점진적으로 구축하기 위해 rels_matrix에 추가됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n6. 텐서 변환 및 결과 반환: 모든 노드에 대한 관계적 맥락 추출이 완료되면 rels_matrix 목록이 PyTorch 텐서로 변환됩니다. 이 텐서는 (num_nodes x max_rels) 모양을 가지며, 각 노드의 관계적 맥락을 구조화되고 기계가 읽을 수 있는 형식으로 체계적으로 나타냅니다.\n\n## 기능 행렬\n\n모든 작업이 완료되면 세 개의 행렬이 남습니다:\n\n1. anchor_distances — 각 노드에서 K 개 가장 가까운 앵커까지의 거리. 차원: N 노드 x K 앵커.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n2. anchor_hashes— 각 노드의 K 개 가장 가까운 앵커의 인덱스. 차원: N 노드 x K 앵커.\n\n3. rel_hashes — 각 노드의 관계적 맥락. 차원: N 노드 x M 관계.\n\n## 전체 모델 정의\n\n이 연습에서는 좀 더 간단하면서 효과적인 지식 그래프 임베딩 모델인 TransE로 피벗합니다. 원래 논문은 RotatE를 사용했지만 — 좀 더 복잡한 모델 — TransE는 그래프 내에서 관계를 임베딩하는 기본 측면에 초점을 맞춘 단순화된 접근 방식을 제공합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nTransE는 헤드 노드, 관계 및 테일 노드로 구성된 트리플릿을 평가하는 방식으로 작동합니다. 이는 헤드와 테일 노드 사이에 지정된 관계가 존재할 확률을 나타내는 likelihood 점수를 할당합니다. 모델의 목적은 실제 트리플릿을 인공적으로 생성된(변형된) 트리플릿과 구별하기 위해 설계된 손실 함수의 최적화에 담겨 있습니다.\n\n마크다운 형식으로 표를 변경하겠습니다:\n\n![이미지 1](/assets/img/2024-05-17-NodePieceFromNodeIDstoTokens_20.png)\n\n![이미지 2](/assets/img/2024-05-17-NodePieceFromNodeIDstoTokens_21.png)\n\n의사 코드로 작성하면 다음과 같습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nfor (head, relation, tail) in data:\n    head_embed = EMBED(head)\n    rel_embed = EMED(relation)\n    tail_embed = EMBED(tail)\n    score = -1 * [(head_embed + rel_embed) - tail_embed]\n    return score\n```\n\nWe return -1 x score as we want to minimize the score, and maximize the likelihood of the triplet.\n\nWhen interacting with NodePiece embeddings, TransE gets interesting when it comes to embedding head and tail nodes.\n\nTransE embedding in this case will perform several steps. For each head or tail node:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n1. 가장 가까운 앵커 인덱스를 가져와서 포함하세요.\n\n2. 가장 가까운 앵커까지의 거리를 가져와서 포함하세요.\n\n3. 관계적 맥락을 가져와서 포함하세요.\n\n4. 방정식 (3)에 따라서: 앵커 ID 임베딩과 거리 임베딩을 더해주고, 관계 임베딩과 연결하여 하나의 벡터로 연결하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n5. 이 벡터를 인코더(MLP 또는 Transformer)를 통해 최종 임베딩을 얻기 위해 전달합니다.\n\n우리의 구현은 다음과 같이 보일 것입니다 - 이 절차는 각 헤드 및 테일 노드에 대해 호출됩니다:\n\n```js\n    def embed_node(self, node: th.Tensor, closest_anchors, anchor_distances, rel_hash):\n\n        # Dim: (N x K) values are anchor ids --> (N x K x D)\n        anchor_embed = self.anchor_embed(closest_anchors[node])\n\n        # Dim: (N x K) values are anchor distances --> (N x K x D)\n        anchor_distances_embed = self.anchor_distances_embed(anchor_distances[node])\n\n        # Dim: (N x M) values are relation types --> (N x M x D)\n        rel_embed = self.rel_emb(rel_hash[node])\n\n        # Dim: (N x K x D)\n        combined_anchor_embed = anchor_embed + anchor_distances_embed\n\n        # N x (K + M) x D\n        stacked_embed = th.cat([combined_anchor_embed, rel_embed], dim=1)\n        N, anchors_plus_rel, hidden_channels = stacked_embed.shape\n\n        # reshape: (N x (K + M) x D) --> (N x (K + M) * D)\n        flattened_embed = stacked_embed.view(N, anchors_plus_rel * hidden_channels)\n\n        # N x (K + M) * D --> N x O\n        lin_out = self.lin_layer(flattened_embed)\n\n        return lin_out\n```\n\n1. anchor_embed는 앵커 해시에 대한 임베딩 조회입니다. 가중치 행렬의 차원은 ((K 앵커 + 1) x D 임베딩 크기)입니다. (N x K) 앵커 해시 행렬을 가져와 (N x K x D) 텐서를 반환합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n2. anchor_distances_embed은 앵커 거리를 위한 임베딩 조회입니다. 가중치 행렬은 ((최대 거리 +1) x D 임베딩 크기)의 차원을 가집니다. (N x K) 크기의 앵커 거리 행렬을 가져와 (N x K x D) 텐서를 반환합니다.\n\n3. rel_embed은 관계 해시를 위한 임베딩 조회입니다. 가중치 행렬은 ((고유 관계 +1) x D 임베딩 크기)의 차원을 가집니다. (N x M) 크기의 관계 해시 행렬을 가져와 (N x M x D) 텐서를 반환합니다.\n\n## TransE 모델 학습\n\n이제 TransE 모델을 준비하고, PyTorch Lightning으로 래핑하여 FB15k-237 데이터 하위 집합에서 훈련할 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nuse_swa = True\nswa_lr = 0.05\n\npyg.seed_everything(111)\n\nparams = models.KGModelParams(\nnum_nodes=train_data_orig.num_nodes,\nnum_relations=train_features.n_rels+1,\nembedding_dim=200,\nmax_distance=max_distance+1,\nhidden_sizes=(400,),\nnum_anchors=train_features.n_anchors,\ntop_m_relations=train_features.m_relations,\ndevice=device,\nkg_model_type=models.ModelType.TransE,\ndrop_prob=0.2\n)\n\nmodel_pl = models.NodePiecePL(\nparams,\nlr=5e-2,\ntrain_features=train_features,\nval_features=val_features)\n\n저희가 인스턴스화한 모델은 다음과 같습니다:\n\nNodePieceTransE(\n(anchor_embed): Embedding(31, 200)\n(anchor_distances_embed): Embedding(13, 200)\n(rel_emb): Embedding(238, 200)\n\n(lin_layer): Sequential(\n(0): BatchNorm(8000)\n(1): Linear(in_features=8000, out_features=400, bias=True)\n(2): LeakyReLU(negative_slope=0.01)\n(3): Dropout(p=0.2, inplace=False)\n(4): Linear(in_features=400, out_features=200, bias=True)\n)\n)\n\n이전에 설명한 이론 부분과 완벽하게 일치합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n첫 번째로는 기준 성능을 얻기 위해 모델을 어떤 학습도 하기 전에 유효성 검사 집합을 사용하여 모델을 평가할 것입니다. 결과는... 음... 예상대로 :)\n\n```js\n┏━━━━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\n┃      검증 메트릭      ┃       데이터로더 0        ┃\n┡━━━━━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━━━━┩\n│    val_hits_at_k_epoch    │            0.0            │\n│    val_mean_rank_epoch    │   0.0005408872966654599   │\n└───────────────────────────┴───────────────────────────┘\n```\n\nHits@k(10) = 0.0이며 올바른 tail의 평균 순위는 매우 낮습니다. 이는 모델이 아직 학습되지 않았기 때문에 예상된 결과입니다.\n\n모델 학습에 시간을 투자한 후에는 학습 이후의 성능을 확인하기 위해 모델을 평가할 수 있습니다. 체크포인트 콜백이 사용되었으므로 모든 반복 중에서 최상의 모델을 선택할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nHits@k 및 평균 순위 메트릭에서 상당한 향상이 있음을 볼 수 있을 것입니다.\n\n```js\n┏━━━━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\n┃      Validate metric      ┃       DataLoader 0        ┃\n┡━━━━━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━━━━┩\n│    val_hits_at_k_epoch    │    0.3240000009536743     │\n│    val_mean_rank_epoch    │    0.2862264811992645     │\n└───────────────────────────┴───────────────────────────┘\n```\n\n실제로, 예측 품질이 향상되었음을 확인할 수 있습니다. 물론, 이러한 작은 데이터 세트에 대해서도 실행하는 데 상당한 시간이 소요될 수 있습니다. 저는 1개의 GPU(T4), 16GB RAM 및 8개 가상 코어를 사용하는 Lightning.ai 플랫폼을 사용했고, 계산에 약 30분이 걸렸습니다.\n\n규모를 감을 수 있도록 말씀드리면, 원래 논문에서는 훨씬 큰 데이터 세트를 사용했으며, 학습에 GPU로 몇 시간이 걸렸습니다. 논문의 표 10에서 한 실험은 400번의 epoch와 1,000개의 앵커로 7시간이 소요되었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 결론\n\n이 블로그 포스트에서는 NodePiece에 대해 자세히 알아보았습니다. NodePiece는 자연어 처리를 위해 사용되는 Transformer의 토크나이제이션 기법에서 영감을 받은 그래프 신경망의 혁신적인 접근 방식입니다. Transformer의 토크나이저가 텍스트를 관리 가능한 조각으로 분해하여 텍스트 분석을 혁신했던 것처럼, NodePiece는 그래프에 유사한 개념을 적용합니다. 그래프의 다양한 부분을 나타내기 위해 기본 요소 또는 \"토큰\"의 집합을 사용하여 복잡한 네트워크를 쉽게 처리할 수 있게 합니다.\n\nNodePiece가 거대하고 복잡한 그래프에서 노드를 나타내는 도전에 대응하기 위해 Transformer에서 사용되는 토크나이제이션 전략에서 아이디어를 빌렸다는 전반적인 내용을 시작으로 하였습니다. 이 접근 방식은 NodePiece가 노드의 본질과 관계를 효율적으로 포착할 수 있도록 하며, 각 노드를 명시적으로 식별할 필요가 없기 때문에(아이디를 통해서), 링크 예측, 노드 분류 등과 같은 작업에 대한 중요한 장점을 제공합니다.\n\n또한 NodePiece의 이론적 배경에 대해 다루었는데, 그래프 내에서 노드의 관계와 위치에 집중함으로써 노드를 유연하고 일반화된 방식으로 표현하는 방법을 설명했습니다. 이것은 노드의 표현을 단순화하고 모델이 다양한 그래프에서 학습하고 적응하는 능력을 향상시킵니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n마침내, 교육적 목적을 고려하여 설계된 NodePiece 모델의 간소화된 구현을 소개했습니다. 이 구현은 NodePiece가 어떻게 작동하며 현실 세계의 그래프 신경망 작업에 어떻게 적용될 수 있는지를 이해하기 쉽도록 개념을 세분화했습니다.\n\n이 소개가 유용하게 느껴지길 바라며, 여러분의 그래프 프로젝트에서 NodePiece 토큰화를 활용할 수 있기를 기대합니다!\n\n이 이야기를 읽어주셔서 감사드립니다.\n\n# 참고문헌\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- Bordes, A., Usunier, N., Garcia-Duran, A., Weston, J., & Yakhnenko, O. (2013). 다중 관계 데이터 모델링을 위한 임베딩 번역. 신경 정보 처리 시스템 발전, 26. https://proceedings.neurips.cc/paper/2013/hash/1cecc7a77928ca8133fa24680a88d2f9-Abstract.html\n- Brochier, R., Guille, A., & Velcin, J. (2019). 노드 표현을 위한 글로벌 벡터. 월드 와이드 웹 컨퍼런스, 2587–2593. https://doi.org/10.1145/3308558.3313595\n- Church, K. W. (2017). Word2Vec. 자연어 공학, 23(1), 155–162.\n- Galkin, M., Denis, E., Wu, J., & Hamilton, W. L. (2021). Nodepiece: 대규모 지식 그래프의 구성적 및 매개 효율적 표현. arXiv Preprint arXiv:2106.12144.\n- Sennrich, R., Haddow, B., & Birch, A. (2016). 드문 단어의 신경 기계 번역 : 서브워드 단위(arXiv:1508.07909; 버전 5). arXiv. https://doi.org/10.48550/arXiv.1508.07909\n- Sun, Z., Deng, Z.-H., Nie, J.-Y., & Tang, J. (2019). RotatE: 복소 공간내 관계 회전에 의한 지식 그래프 임베딩(arXiv:1902.10197; 버전 1). arXiv. https://doi.org/10.48550/arXiv.1902.10197\n\n# 친근한 마음으로 안내합니다 💬\n\nIn Plain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 다음에도 놓치지 마세요:\n\n- 작가를 박수와 팔로우해 주세요 ️👏️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼 방문: Stackademic | CoFeed | Venture | Cubed\n- PlainEnglish.io에서 더 많은 콘텐츠를 만나보세요\n","ogImage":{"url":"/assets/img/2024-05-17-NodePieceFromNodeIDstoTokens_0.png"},"coverImage":"/assets/img/2024-05-17-NodePieceFromNodeIDstoTokens_0.png","tag":["Tech"],"readingTime":42}],"page":"106","totalPageCount":113,"totalPageGroupCount":6,"lastPageGroup":13,"currentPageGroup":5},"__N_SSG":true}