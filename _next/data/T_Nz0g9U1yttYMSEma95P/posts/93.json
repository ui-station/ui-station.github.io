{"pageProps":{"posts":[{"title":"NVIDIA Jetson Nano에서 Intel RealSense Depth Camera를 사용하여 ROS2 Humble를 활용하기","description":"","date":"2024-05-18 19:15","slug":"2024-05-18-NVIDIAJetsonNanowithIntelRealSenseDepthCameraUsingROS2Humble","content":"\n<img src=\"/assets/img/2024-05-18-NVIDIAJetsonNanowithIntelRealSenseDepthCameraUsingROS2Humble_0.png\" />\n\n이 튜토리얼에서는 NVIDIA Jetson Nano와 Intel RealSense Depth Camera를 ROS2 Humble을 사용하여 어떻게 연결하는지 살펴볼 것입니다. 이 설정은 실시간 인식 및 처리 기능이 필요한 로봇 응용 프로그램에 강력합니다. Jetson Nano는 RealSense 카메라에서 데이터를 처리하는 데 필요한 계산 성능을 제공하며, ROS2 Humble은 로봇 소프트웨어 개발과 관리를 위한 견고한 프레임워크를 제공합니다.\n\n<img src=\"/assets/img/2024-05-18-NVIDIAJetsonNanowithIntelRealSenseDepthCameraUsingROS2Humble_1.png\" />\n\n# Prerequisites\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n시작하기 전에 다음 구성 요소가 있는지 확인하십시오:\n\n- NVIDIA Jetson Nano 운영 체제 이미지가 설치된 Ubuntu 20.04\n- Intel RealSense Depth Camera (예: D435i)\n- Jetson Nano에 설치된 ROS2 Humble\n- RealSense 카메라를 Jetson Nano에 연결하기 위한 USB 3.0 케이블\n- 필요한 패키지를 다운로드하기 위한 인터넷 연결\n\nROS2 RealSense 패키지 설치\n\n```js\nsudo apt install ros-humble-realsense2-camera\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nRealSense 노드를 시작해주세요:\n\nRealSense 노드를 시작하는 런치 파일을 만들어 보세요. 새로운 파일 realsense_launch.py를 만들어 주세요:\n\n```python\nfrom launch import LaunchDescription\nfrom launch_ros.actions import Node\n\ndef generate_launch_description():\n    return LaunchDescription([\n        Node(\n            package='realsense2_camera',\n            executable='realsense2_camera_node',\n            name='realsense2_camera',\n            output='screen',\n            parameters=[{\n                'enable_depth': True,\n                'enable_infra1': True,\n                'enable_infra2': True,\n                'enable_color': True,\n            }],\n        ),\n    ])\n```\n\n란치 파일을 실행하세요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<table>\n    <tr>\n        <td>![이미지](/assets/img/2024-05-18-NVIDIAJetsonNanowithIntelRealSenseDepthCameraUsingROS2Humble_2.png)</td>\n    </tr>\n</table>\n\n```js\nros2 launch your_package_name realsense_launch.py\n```\n\nrqt에서 데이터 시각화:\n\n![이미지](/assets/img/2024-05-18-NVIDIAJetsonNanowithIntelRealSenseDepthCameraUsingROS2Humble_3.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nrqt에 RealSense 데이터 추가하기:\n\n![이미지](/assets/img/2024-05-18-NVIDIAJetsonNanowithIntelRealSenseDepthCameraUsingROS2Humble_4.png)\n\n- 새로운 DepthCloud 표시 추가 및 토픽을 /camera/depth/color/points로 설정합니다.\n- 이미지 표시 추가 및 토픽을 /camera/color/image_raw로 설정합니다.\n\n![이미지](/assets/img/2024-05-18-NVIDIAJetsonNanowithIntelRealSenseDepthCameraUsingROS2Humble_5.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n깊이 이미지\n\n![깊이 이미지](https://miro.medium.com/v2/resize:fit:1400/1*lqW7eh_9bQwt7jdi9FNFDg.gif)\n\n# 깊이 이미지란?\n\n깊이 이미지는 각 픽셀이 카메라에서 씬 내 객체까지의 거리를 나타내는 회색조 이미지입니다. 색상 정보를 포함하는 일반적인 RGB 이미지와 달리, 깊이 이미지는 깊이 정보를 인코딩하여 환경의 3D 구조를 인식할 수 있게 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 주요 주제 및 메시지\n\nROS 2에서 RealSense 카메라의 깊이 이미지는 특정 토픽, 보통은 /camera/depth/image_raw에 발행됩니다. 깊이 이미지의 메시지 유형은 sensor_msgs/Image입니다. 주요 요소를 살펴보겠습니다:\n\n- 토픽: /camera/depth/image_raw\n- 메시지 유형: sensor_msgs/Image\n\n## sensor_msgs/Image 메시지\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nsensor_msgs/Image 메시지에는 여러 필드가 포함되어 있지만, 깊이 이미지에 가장 관련있는 필드는 다음과 같습니다:\n\n- header: 타임스탬프와 좌표 프레임 정보를 포함하는 표준 ROS 메시지 헤더입니다.\n- height: 이미지의 높이(픽셀 단위).\n- width: 이미지의 너비(픽셀 단위).\n- encoding: 이미지 데이터의 인코딩 유형, 예를 들어 16비트 무부호 단일 채널 이미지의 경우 16UC1입니다.\n- is_bigendian: 이미지 데이터가 빅엔디안 바이트 순서로 저장되어 있는지 여부.\n- step: 바이트 단위의 전체 행 길이.\n- data: 바이트 배열로 저장된 실제 픽셀 데이터.\n\n## 깊이 이미지 처리\n\n깊이 이미지는 애플리케이션에 따라 다양한 방식으로 처리할 수 있습니다. 일반적인 작업은 다음과 같습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 객체 감지 및 인식: 3D 모양에 기반하여 객체를 식별하고 분류합니다.\n- 장애물 피하기: 로봇의 경로에서 장애물을 감지하고 피하기 위해 깊이 정보를 활용합니다.\n- 3D 매핑: 내비게이션 목적으로 환경의 3D 지도를 작성합니다.\n\n# 결론\n\n위 단계를 따라서 NVIDIA Jetson Nano가 ROS2 Humble을 사용하여 Intel RealSense Depth Camera와 연결되어 있어야 합니다. 이 설정은 내비게이션, 객체 감지 등을 위해 실시간 깊이 및 색상 데이터를 활용하여 다양한 로봇 응용 프로그램에 매우 유용합니다. 로봇 시스템의 능력을 확장하기 위해 다양한 ROS2 노드 및 패키지를 실험해보세요.\n\n문제가 발생하거나 추가 질문이 있으시면 아래에 댓글을 남겨 주세요!\n","ogImage":{"url":"/assets/img/2024-05-18-NVIDIAJetsonNanowithIntelRealSenseDepthCameraUsingROS2Humble_0.png"},"coverImage":"/assets/img/2024-05-18-NVIDIAJetsonNanowithIntelRealSenseDepthCameraUsingROS2Humble_0.png","tag":["Tech"],"readingTime":6},{"title":"라즈베리 파이 5에서 VSCode 서버 다시 시도하기","description":"","date":"2024-05-18 19:13","slug":"2024-05-18-TryingtheVSCodeServeragainontheRaspberryPI5","content":"\n<img src=\"/assets/img/2024-05-18-TryingtheVSCodeServeragainontheRaspberryPI5_0.png\" />\n\n지난 번에 우리가 이에 대해 이야기했을 때는 Raspberry PI 5가 없었고, VSCode Server의 버전은 4.0.2였습니다. 전체 경험은 성공적이지 못했고, 실제 작업에 적합하지 않았습니다. VSCode가 느리게 실행되었고, 빌드 시간도 더욱 더 걸렸습니다. 특히 러스트와 같은 언어에 대해서는 그러했습니다. 따라서 우리는 더 나은 하드웨어를 기다리는 실험을 종료했습니다. 운좋게도, 오늘 기다리던 하드웨어가 마침내 출시되었습니다: Raspberry PI 5.\n\nRaspberry PI 4보다 최대 세 배 빠른 속도로 벤치마킹된 새로운 Raspberry PI는 개인용 코딩 및 빌딩 워크스테이션으로 강력한 경쟁자가 되리라 약속합니다. 이에 더해 더 많은 RAM, 더 높은 I/O 대역폭 및 더 나은 GPU를 제공하여 모든 것이 성공을 향해 나아가는 것으로 보입니다. 우리는 마침내 우리의 홈 VSCode Server를 가질 수 있을까요? 알아보겠습니다!\n\n## VSCode Server 설치 및 구성하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Trying the VSCode Server again on the Raspberry Pi](/assets/img/2024-05-18-TryingtheVSCodeServeragainontheRaspberryPI5_1.png)\n\nVSCode Server도 업데이트되었습니다. 현재 버전 4.20.0에 도달했습니다. 이번에는 지난 시험한 버전보다 많은 개선 사항을 갖춘 VSCode 1.85.1이 실행됩니다. 그래서 이번에는 이전과 마찬가지로 curl을 사용하여 공식 페이지에서 그것을 받아봅시다. 이번에는 여러분도 이미 알다시피 Fedora가 아직 Raspberry PI 5를 지원하지 않는 커널을 사용하고 있기 때문에 Ubuntu를 위한 Debian 패키지를 사용하겠습니다:\n\n```bash\n#curl -fOL https://github.com/coder/code-server/releases/download/v4.20.0/code-server_4.20.0_arm64.deb\n#sudo apt install ./code-server_4.20.0_arm64.deb\n```\n\n그럼 시작해봅시다!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-05-18-TryingtheVSCodeServeragainontheRaspberryPI5_2.png\" />\n\n설치 후에 우리가 해야 할 일은 잘 알려진 아래 명령어를 실행하여 VSCode 서버를 활성화하는 것뿐입니다:\n\n```js\n#sudo systemctl start code-server@ubuntu\n#sudo systemctl enable code-server@ubuntu\n```\n\n@ubuntu 부분은 서버를 실행할 사용자를 가리킵니다. 이 경우에는 ubuntu인데요, 라즈베리 파이 서버 사용자를 반영하도록 변경해도 상관 없습니다. 서버는 이제 기본 포트 8080에서 실행되지만, ~/config/code-server/config.yaml 파일을 편집하여 해당 포트 및 다른 설정을 변경할 수 있습니다. 예를 들어, 저는 포트를 변경하고 로그인 암호를 제거했습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래에서 볼 수 있듯이, 우리는 IP 주소를 변경하여 네트워크의 모든 클라이언트에서 10000번 포트로의 연결을 허용하도록 했습니다. 또한 인증을 비활성화하여 기본 비밀번호에서 변경했습니다. 비밀번호를 추가하려면 다음을 사용합니다:\n\n```js\nbind-addr: 0.0.0.0:10000\nauth: password\npassword: password-hash\ncert: false\n```\n\n비밀번호 해시는 mkpasswd를 사용해서 얻을 수 있습니다. 비밀번호를 입력하라고 요청하며, 해시를 복사하여 위의 비밀번호 필드에 붙여넣습니다. 이것이 모든 구성 단계입니다. 이제 브라우저로 넘어가봅시다!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 브라우저에서 Visual Studio Code 실행하기\n\n![이미지](/assets/img/2024-05-18-TryingtheVSCodeServeragainontheRaspberryPI5_4.png)\n\n위의 스크린샷에서 볼 수 있듯이, 우리가 해야 할 일은 네트워크 내의 어떤 브라우저에서라도 Raspberry PI에 있는 IP 주소로 접근하고, VSCode Server가 실행 중인 올바른 포트인 경우(우리의 경우 10000)를 제공해주면 됩니다. 이제 즉시 브라우저 창을 새로고침하면, Raspberry PI 4에서 VSCode가 훨씬 빠르게로드됩니다. 심지어 이미 LDAP 서버를 포함한 많은 네트워크 서비스가 실행 중이지만요. 터미널을 열고 rust를 설치해봅시다:\n\n![이미지](/assets/img/2024-05-18-TryingtheVSCodeServeragainontheRaspberryPI5_5.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 스크린샷에 나오는 명령어는 rustup을 설치하는 기본 명령어입니다: curl --proto `=https` --tlsv1.2 -sSf https://sh.rustup.rs | sh. 이 명령어는 라즈베리 파이 5 VSCode 서버에 rust를 설정해줍니다:\n\n![라즈베리 파이 5 VSCode 서버 재시도](/assets/img/2024-05-18-TryingtheVSCodeServeragainontheRaspberryPI5_6.png)\n\n라즈베리 파이 5의 와이파이 속도가 향상된 것을 알립니다. Rust를 다운로드하는 과정이 로컬 머신에서 실행하는 것과 더 닮았습니다. 그럼에도 불구하고, 설치 과정은 기대보다 느립니다. 물론, 제 최신 세대 인텔 i7 데스크탑과 비교하면 공평하지 않지만, 이 작은 라즈베리 파이 5도 아직 데스크톱 속도에 도달하기 위해 많은 것을 해야 한다는 것을 보여줍니다. 그럼에도 불구하고, 경험은 실제로 라즈베리 파이보다 빨랐습니다. 3배 빠른가요? 정말 그렇지는 않았지만, 라즈베리 파이 4에서 약 10분 정도 걸릴 작업이 라즈베리 파이 5에서는 약 4분 정도 소요되었습니다. 확실한 향상이었습니다.\n\n하지만, 일반적이고 작은 웹 서버와 같은 몇 가지 종속성을 사용하여 rust 프로젝트를 작성하고 빌드하는 작업을 해보죠. 그러기 위해 우리는 projects라는 새 폴더를 만들어서 브라우저에서 VSCode를 열고 터미널을 실행하여 cargo new web-test --bin을 실행하세요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<table>\n  <tr>\n    <td><img src=\"/assets/img/2024-05-18-TryingtheVSCodeServeragainontheRaspberryPI5_7.png\" /></td>\n  </tr>\n</table>\n\n이제 해당 폴더를 열어 봅시다:\n\n<table>\n  <tr>\n    <td><img src=\"/assets/img/2024-05-18-TryingtheVSCodeServeragainontheRaspberryPI5_8.png\" /></td>\n  </tr>\n</table>\n\n프로젝트를 컴파일해 보겠습니다. 먼저 rust-analyzer 확장 프로그램을 설치하여 VSCode에서 rust 언어를 완전히 지원받을 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/assets/img/2024-05-18-TryingtheVSCodeServeragainontheRaspberryPI5_9.png)\n\nLLDB 디버거도 설치할 겁니다. 이를 통해 러스트 프로그램을 디버깅할 수 있어요:\n\n![이미지](/assets/img/2024-05-18-TryingtheVSCodeServeragainontheRaspberryPI5_10.png)\n\n사실, Raspberry PI 4에 비해 VSCode 익스텐션 설치가 훨씬 빠른 것 같아요. 그것들은 로컬 데스크톱에서 설치하는 것과 똑같아요. 전체 경험은 로컬에서 VSCode를 실행하는 것 같아요. 다시 F5를 누르면 다음으로 linker cc를 찾을 수 없다는 에러가 나올 거에요. 그래서 sudo apt install build-essential을 사용해서 build-essential 패키지를 설치해볼까요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![다운로드 속도가 빠르고 설치 속도는 조금 느립니다. 하지만 라즈베리 파이 5는 여전히 1분 이내에 모든 것을 설치하는 데 성공합니다. 이번에는 F5를 누르면 정말로 프로젝트를 컴파일하고 디버그합니다. 마침내. 러스트 서버를 실행해 봅시다!](/assets/img/2024-05-18-TryingtheVSCodeServeragainontheRaspberryPI5_11.png)\n\n## 작은 러스트 웹 서버 만들기\n\n![다운로드 속도가 빠르고 설치 속도는 조금 느립니다. 하지만 라즈베리 파이 5는 여전히 1분 이내에 모든 것을 설치하는 데 성공합니다. 이번에는 F5를 누르면 정말로 프로젝트를 컴파일하고 디버그합니다. 마침내. 러스트 서버를 실행해 봅시다!](/assets/img/2024-05-18-TryingtheVSCodeServeragainontheRaspberryPI5_12.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n지금까지 우리는 안정적으로 1%에서 3%의 CPU 사용량과 겨우 1.2GB의 RAM 사용량을 유지하고 있어요. 이라고 느껴질 수 있지만, 라즈베리 파이 5는 8GB의 사용 가능한 RAM을 가지고 있어요. 라즈베리 파이 4에서는 이미 이것이 고난일이었죠:\n\n![이미지1](/assets/img/2024-05-18-TryingtheVSCodeServeragainontheRaspberryPI5_13.png)\n\n그럼, 정적 파일을 제공하는 간단한 웹 서버를 준비해뒀어요:\n\n![이미지2](/assets/img/2024-05-18-TryingtheVSCodeServeragainontheRaspberryPI5_14.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nrust-analyzer가 작업을 수행하는 동안 actix 종속성을 다운로드하고 컴파일하며 소스 코드를 색인화하는 과정에서 4코어 ARM CPU에서 발생하는 전형적인 노동의 결과를 확인할 수 있습니다. 하지만 이는 라즈베리 파이 5가 쉽게 처리할 수 없는 것은 없습니다. 웹 경험은 여전히 부드럽고 자동 완성은 여전히 즉각적으로 응답합니다:\n\n![이미지1](/assets/img/2024-05-18-TryingtheVSCodeServeragainontheRaspberryPI5_15.png)\n\n또한 전형적인 index.html 파일을 준비했습니다:\n\n![이미지2](/assets/img/2024-05-18-TryingtheVSCodeServeragainontheRaspberryPI5_16.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 웹 서버를 구축하고 실행해 보려고 합니다. 우리 손가락을 교차하고 cargo build를 실행해 보세요. actix web 라이브러리는 이미 인상적인 수의 종속성을 필요로 하지만, Raspberry PI 5는 이 모든 것을 빠르게 처리합니다:\n\n![이미지](/assets/img/2024-05-18-TryingtheVSCodeServeragainontheRaspberryPI5_17.png)\n\n지금 세 분은 꽤 오랜 시간으로 느껴질 수 있지만, 말해 드릴게요. 저는 웹 프로젝트를 만들 때 Raspberry PI 4에서 러스트로 빌드했을 때 쉽게 10분씩 썼습니다. 저에게는 이미 이는 압도적인 승리입니다. 더 구체적인 비교를 해보면, 저의 평균 AMD Ryzen 5 3000 노트북은 이 일을 완료하는 데 약 한 시간 반 정도 걸리는 반면, 동시에 많은 일을 실행 중이기는 하지만요. 하지만, 합당하게 말해서, Raspberry PI 5는 상황을 감안할 때 충분히 좋은 일을 하고 있습니다. 그리고 Raspberry PI 4보다 훨씬 더 훌륭한 일을 합니다.\n\n정말 인상적입니다. Raspberry PI 4는 홈 네트워크 코딩 서버로 사용하기에 적합하지 않았고, 단 몇 분만 지나도 Raspberry PI 5가 이 상황을 어떻게 처리하는지 완전히 만족스럽다고 할 수 있습니다. 대규모 자원을 사용하는 복잡한 빌드 프로세스로 알려진 러스트 프로그램을 빌드하고 실행하는 것은 매우 쉽고 로컬에서 실행하는 것 같은 느낌이 듭니다. 이게 최고의 칭찬이에요. Raspberry PI 4에서 서버가 제한적이고 중단되는 느낌이 들었던 것과는 달리, 이번에는 서버로 인해 제한받거나 방해받는 느낌이 들지 않습니다. 이 실험을 성공으로 인정하고 계속하여 실험을 진행하기 위해 VSCode Server 구동 상태로 두겠습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이것은 대형 태블릿을 사용하여 코딩 및 이전에 거부되었던 가정 네트워크의 다른 리소스를 활용할 수 있는 훌륭한 시나리오를 열어줍니다. 이 멋진 여정을 함께 해 줘서 감사하고, 다음에 또 만나요!\n","ogImage":{"url":"/assets/img/2024-05-18-TryingtheVSCodeServeragainontheRaspberryPI5_0.png"},"coverImage":"/assets/img/2024-05-18-TryingtheVSCodeServeragainontheRaspberryPI5_0.png","tag":["Tech"],"readingTime":10},{"title":"라즈베리 파이 웹사이트 만들기","description":"","date":"2024-05-18 19:11","slug":"2024-05-18-CreatingaRaspberryPIWebsite","content":"\n아래는 메인 시리즈 \"Hackable Lego Train\"의 미니 파트입니다.\n\n다음은 메인 시리즈를 확인할 수 있는 링크입니다:\n\nHackable Lego Train | Part 1 | Stux | 작성자: Stux | 2024년 5월 | Medium\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-05-18-CreatingaRaspberryPIWebsite_1.png\" />\n\n프로젝트의 아이디어는 열차 해킹을 시뮬레이션하고 운영 기술 환경에서 취약한 애플리케이션과 관련된 전반적인 사이버 위험을 보여주는 것입니다.\n\n그러니까 PI에 간단한 웹사이트를 만든 방법에 대해 설명해드릴게요.\n\n전체적인 단계는 다음과 같습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 새로운 OS(Kali)로 Pi 이미지 다시 만들기\n- Pi에서 SSH 활성화\n- 웹 사이트를 위한 폴더 디렉토리 생성\n- 웹 사이트를 위한 파일 구성\n- 웹 사이트에 로깅 추가\n\n시작해 보세요!\n\n주 컴퓨터에서 라즈베리 파이 이미지 소프트웨어를 다운로드하고 설치하세요.\n\n라즈베리 파이 OS — 라즈베리 파이\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Creating a Raspberry PI Website Image 2](/assets/img/2024-05-18-CreatingaRaspberryPIWebsite_2.png)\n\n라즈베리 파이에 Kali를 설치하고 싶었어요.\n\n- 저는 Kali를 잘 알고 있고 손에 익숙해요.\n- 이 프로젝트 이외에도 네트워크 침투 분야에서 다른 계획이 있어요.\n- 어차피 해킹 프로젝트니까 나에게 가장 쉽게 만들어야겠죠 :)\n\n![Creating a Raspberry PI Website Image 3](/assets/img/2024-05-18-CreatingaRaspberryPIWebsite_3.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n호스트 컴퓨터에 PI SD 카드를 넣어주세요. 그리고 카드에 Kali를 WRITE해주세요.\n\n작업이 끝나면 SD 카드를 PI에 다시 넣고 부팅해주세요.\n\n원하는 방식으로 Kali를 설정하고 따라가보세요.\n\n로그인하세요!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여기서부터는 SSH를 사용해서 작업을 계속합니다. 그래서 셸 명령어에 익숙하신 것 같아요.\n\n![CreatingaRaspberryPIWebsite_4](/assets/img/2024-05-18-CreatingaRaspberryPIWebsite_4.png)\n\n새 시스템에 SSH로 접속한 후, 먼저 웹사이트 디렉토리 구조를 만들고 싶어요.\n\n![CreatingaRaspberryPIWebsite_5](/assets/img/2024-05-18-CreatingaRaspberryPIWebsite_5.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 제 예시입니다:\n\n```js\nbig_cabooses/\n│\n├── static/\n│   └── css/\n│       └── styles.css\n│   └── images/\n│       └── background.jpg\n├── templates/\n│   └── index.html\n├── app.py\n└── train_schedule.py\n```\n\napp.py 파일을 편집하여 다음 내용을 추가하십시오:\n\n```js\nfrom flask import Flask, render_template\nfrom train_schedule import get_train_schedule\n\napp = Flask(__name__)\n\n@app.route('/')\ndef home():\n    schedule = get_train_schedule()\n    return render_template('index.html', schedule=schedule)\n\nif __name__ == '__main__':\n    app.run(debug=True)\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\ndef get_train_schedule():\n    return [\n        {\"time\": \"07:00 AM\", \"train\": \"천년비행선\", \"destination\": \"타투인\"},\n        {\"time\": \"09:00 AM\", \"train\": \"데스스타\", \"destination\": \"엔도어\"},\n        {\"time\": \"11:00 AM\", \"train\": \"X-윙\", \"destination\": \"야빈 4\"},\n        {\"time\": \"01:00 PM\", \"train\": \"TIE 전투기\", \"destination\": \"호스\"},\n        {\"time\": \"03:00 PM\", \"train\": \"제국 셔틀\", \"destination\": \"코르서캔트\"},\n        {\"time\": \"05:00 PM\", \"train\": \"슬레이브 1\", \"destination\": \"카미노\"},\n        {\"time\": \"07:00 PM\", \"train\": \"나부 스타파이터\", \"destination\": \"나부\"},\n    ]\n```\n\ntemplates/index.html 수정:\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Big Cabooses</title>\n    <link\n      rel=\"stylesheet\"\n      href=\"{{ url_for('static', filename='css/styles.css') }}\"\n    />\n  </head>\n  <body>\n    <div class=\"background\"></div>\n    <div class=\"content\">\n      <h1>Big Cabooses 열차 일정</h1>\n      <table>\n        <thead>\n          <tr>\n            <th>시간</th>\n            <th>열차</th>\n            <th>목적지</th>\n          </tr>\n        </thead>\n        <tbody>\n          {% for entry in schedule %}\n          <tr>\n            <td>{{ entry.time }}</td>\n            <td>{{ entry.train }}</td>\n            <td>{{ entry.destination }}</td>\n          </tr>\n          {% endfor %}\n        </tbody>\n      </table>\n    </div>\n  </body>\n</html>\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nstatic/css/styles.css 파일에 다음 내용을 입력해주세요:\n\n```js\nbody, html {\n    height: 100%;\n    margin: 0;\n    font-family: Arial, sans-serif;\n}\n\n.background {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    background-image: url(\"../images/background.jpg\");\n    background-size: cover;\n    background-position: center;\n    z-index: -1;\n    opacity: 0.5;\n}\n\n.content {\n    position: relative;\n    z-index: 1;\n    padding: 20px;\n    background-color: rgba(255, 255, 255, 0.8);\n    border-radius: 10px;\n    max-width: 600px;\n    margin: auto;\n    top: 50%;\n    transform: translateY(-50%);\n    text-align: center;\n}\n\ntable {\n    width: 100%;\n    border-collapse: collapse;\n}\n\nth, td {\n    padding: 10px;\n    border: 1px solid #ddd;\n    text-align: left;\n}\n\nth {\n    background-color: #f2f2f2;\n}\n```\n\nstatic/background.jpg의 경로에 매력적인 배경 이미지를 업로드해주세요.\n\nChatGPT를 이용하여 스스로 이미지를 만들 수 있게 위해서 돈을 지불했어요. 여러분도 자금이 있으시다면 강력히 추천합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n웹사이트를 시작하세요!\n\n```js\nsudo python3 app.py\n```\n\n브라우저를 열고 127.0.0.1:5000으로 이동하세요\n\nBUTTT!!!!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리는 로깅을 추가하고 내부 네트워크의 다른 컴퓨터에서 액세스할 수 있는 기능을 추가하길 원해요.\n\n이를 위해 하나 해야 할 일은 우리의 app.py 파일을 변경하는 것뿐입니다:\n\n```js\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=5000, debug=True)\n```\n\n반드시 \"host=\"에 PI의 IP를 넣어 주세요!!!!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 웹 사이트에 로그 파일을 기록하려고 합니다. app.py 파일에 이 모든 내용을 추가해 보겠습니다:\n\n```python\nfrom flask import Flask, render_template\nfrom train_schedule import get_train_schedule\nimport logging\n\napp = Flask(__name__)\n\n# 로깅 설정\nlogging.basicConfig(filename='app.log', level=logging.DEBUG,\n                    format='%(asctime)s %(levelname)s %(name)s %(threadName)s : %(message)s')\n\n@app.route('/')\ndef home():\n    app.logger.info(\"홈 페이지에 접근했습니다.\")\n    schedule = get_train_schedule()\n    return render_template('index.html', schedule=schedule)\n\n@app.route('/error')\ndef error():\n    app.logger.error(\"이것은 오류 예제입니다.\")\n    return \"오류 예제\", 500\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=5000, debug=True)\n```\n\n이제 /big-cabooses/ 메인 디렉토리에 app.log라는 파일이 생기게 됩니다.\n\n그런 다음, 간단한 접속 로그가 포함된 스타워즈 테마의 레고 기차 웹 사이트를 만들었습니다. 함께 빌드하는 과정을 즐겼습니다!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n어떤 질문이든 하시거나 도움이 필요하시면 언제든지 메시지를 보내주세요. 즐겁게 즐기세요! 이것을 하면서 몇 번 굳었지만, 마침내 성공적으로 해냈고 결과물을 좋아합니다. -Stux\n","ogImage":{"url":"/assets/img/2024-05-18-CreatingaRaspberryPIWebsite_0.png"},"coverImage":"/assets/img/2024-05-18-CreatingaRaspberryPIWebsite_0.png","tag":["Tech"],"readingTime":9},{"title":"라즈베리 파이로 쿠버네티스 클러스터 구축 가이드","description":"","date":"2024-05-18 19:08","slug":"2024-05-18-AGuidetoBuildingaKubernetesClusterwithRaspberryPis","content":"\n몇 년 전에 라즈베리 파이에서 Kubernetes 클러스터를 세팅했었어요. 당시 라즈베리 파이의 ARM 아키텍처는 몇 가지 어려움을 야기했죠. ARM을 지원하는 애플리케이션을 찾는 건 어려운 과제였는데, 그래서 필요한 애플리케이션과 컨테이너를 직접 빌드해야 했던 적이 많았어요.\n\n그런데 그 이후로 상황이 크게 개선되었어요! 새로운 64비트 라즈베리 파이 OS의 등장과 ARM의 저렴함으로 클라우드 배포에 많이 사용되는 산업에서의 인기 상승으로, 라즈베리 파이 클러스터 구축이 훨씬 간단해졌어요. 저는 클러스터를 다시 구축하기로 결정했고, 64비트 OS 및 최신 버전의 Kubernetes와 Docker로 업데이트했어요.\n\n여러분이 자체 라즈베리 파이 Kubernetes 클러스터를 설정하는 방법에 대한 가이드를 작성했어요. 집에서 클러스터를 구축하는 여정에 유용하길 바랍니다! 🚀\n\n# 요구 사항\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n클러스터를 설정하기 위해서는 하드웨어가 필요합니다. 필요한 것들은 다음과 같아요:\n\n- 라즈베리 파이(저는 4 모델 B를 사용했어요)\n- SD 카드 1장 / 라즈베리 파이\n- 이더넷 케이블 1개 / 라즈베리 파이\n- 라우터 및/또는 네트워크 스위치\n- USB 허브\n- (선택 사항) 케이스\n\n이 안내서는 Kubernetes 1.26.6, Docker 24.0.2 및 라즈베리 파이 Lite(64비트) 불자이에 맞춰 작성되었어요.\n\n# OS 설정\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n첫 번째 단계는 모든 Raspberry Pi에 OS를 설정해야 합니다. 그렇지 않으면 Raspberry Pi는 기본적으로 부팅할 시스템이 없습니다.\n\nRaspberry Pi Imager를 다운로드하십시오. 이 편리한 애플리케이션은 Raspberry Pi의 다운로드와 플래싱에 사용됩니다. 이 가이드에서는 Raspberry Pi OS (Debian의 파생 버전)의 64비트 헤드리스 버전을 사용할 것입니다.\n\n최신 Raspberry Pi와 호환되는지 확인한 후에 SD 카드를 플래싱해야 합니다.\n\n![Raspberry Pi Imager](/assets/img/2024-05-18-AGuidetoBuildingaKubernetesClusterwithRaspberryPis_0.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nSD 카드를 선택하고 OS를 플래싱하기 시작하세요. 모든 SD 카드에 대해 이 작업을 완료할 때까지 반복해주세요.\n\n## SSH 활성화 및 기본 사용자 생성\n\n각 Pi를 원격으로 구성할 수 있게끔 SSH를 설정해야 합니다.\n\nSSH를 활성화하려면 SD 카드의 부트 파티션에 확장자 없이 ssh라는 빈 파일을 생성하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n로그인 사용자를 설정하기 위해, SD 카드의 부팅 파티션에 userconf라는 파일을 생성하세요. 이 파일은 'name':'encrypted-password'로 구성된 텍스트 한 줄을 포함해야 합니다. 로그인 사용자로 노드를 사용했지만 원하는 대로 사용하셔도 됩니다.\n\nencrypted-password를 생성하려면 다음 명령을 OpenSSL과 함께 실행하세요:\n\n```js\necho '{password}' | openssl passwd -6 -stdin\n```\n\n파일을 저장하고 SD 카드를 제거하세요. 그리고 라즈베리 파이에 SD 카드를 삽입하고 전원을 켜세요. 개인 네트워크의 라우터나 네트워크 스위치에 연결되어 있는지 확인하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 첫 번째 부팅 및 초기 구성\n\n라즈베리 파이의 IP를 얻어야 합니다. 이를 위해 라우터를 확인할 수 있습니다. 제 경우, OpenWrt를 사용하며 DHCP 설정에서 기억하기 쉬운 정적 IP를 만듭니다.\n\n![image](/assets/img/2024-05-18-AGuidetoBuildingaKubernetesClusterwithRaspberryPis_1.png)\n\n첫 번째 노드에 SSH로 연결합니다. 이 노드는 클러스터의 제어 평면을 실행하는 마스터 노드가 됩니다. 라즈베리 파이로 터널링한 후에 설정을 시작할 수 있습니다!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음 명령어를 사용하여 사용자를 sudo 그룹에 추가해주세요.\n\n```js\nsudo usermod -aG sudo node\n```\n\n이제 rasp-config를 업데이트하여 node 사용자로 자동 부팅하도록 설정해봅시다.\n\n```js\nsudo raspi-config\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*XG-oT3YeryzngA-Xv3JY9w.gif)\n\n“System Options” → “Boot / Auto Login” 으로 이동하여 “Console Autologin”을 선택해주세요.\n\n# Docker & Kubernetes 초기 설정\n\n기본적으로 cgroup 메모리 옵션이 비활성화되어 있으므로 Docker가 메모리 사용량을 제한할 수 있도록 업데이트해야 합니다. /boot/cmdline.txt를 열고 cgroup_enable=memory cgroup_memory=1을 추가해주세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 우리의 apt 저장소를 업데이트하고 Kubernetes 저장소를 포함시킬 차례입니다.\n\n```js\ncurl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add -\necho \"deb http://apt.kubernetes.io/ kubernetes-xenial main\" | sudo tee -a /etc/apt/sources.list.d/kubernetes.list\nsudo apt update && sudo apt upgrade -y\n```\n\nDocker 설치:\n\n```js\ncurl -sSL https://get.docker.com | sh\nsudo usermod -aG docker node\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nKubernetes 1.20부터는 dockershim이 폐기되고 있습니다. Mirantis에서 제공하는 cri-dockerd라는 클러스터용 오픈 소스 CRI를 사용할 수 있습니다. cri-dockerd를 설치하고 서비스를 설정하려면 다음 명령을 실행하세요:\n\n```js\nwget https://github.com/Mirantis/cri-dockerd/releases/download/v0.3.4/cri-dockerd-0.3.4.arm64.tgz\ntar -xvzf cri-dockerd-0.3.4.arm64.tgz\nsudo mv cri-dockerd/cri-dockerd /usr/bin/cri-dockerd\nsudo chmod +x /usr/bin/cri-dockerd\nwget https://raw.githubusercontent.com/Mirantis/cri-dockerd/master/packaging/systemd/cri-docker.service\nwget https://raw.githubusercontent.com/Mirantis/cri-dockerd/master/packaging/systemd/cri-docker.socket\nsudo mv cri-docker.service /etc/systemd/system/\nsudo mv cri-docker.socket /etc/systemd/system/\nsudo systemctl enable cri-docker.service\nsudo systemctl enable cri-docker.socket\nsudo systemctl start cri-docker.service\nsudo systemctl start cri-docker.socket\n```\n\nKubernetes 스케줄러를 위해 노드에서 swap을 비활성화하는 것이 권장됩니다.\n\n```js\nsudo apt-get update && sudo apt-get install dphys-swapfile && sudo dphys-swapfile swapoff && sudo dphys-swapfile uninstall && sudo systemctl disable dphys-swapfile\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만약 cri-dockerd 설정에 문제가 발생하면, 이 안내서를 확인해보세요. 처음에 작성했을 때와 달라진 사항이 있을 수 있어요.\n\n마지막으로, Kubernetes를 설치해봅시다!\n\n```js\nsudo apt install -y kubelet=1.26.6-00 kubeadm=1.26.6-00 kubectl=1.26.6-00\nsudo apt-mark hold kubelet kubeadm kubectl\n```\n\n이 가이드에서는 모든 것이 1.26.6에서 작동하는지 테스트했어요. 1.24 이전 버전은 정상적으로 작동하지 않을 거예요. 이러한 패키지를 업데이트되지 않도록 표시할 거에요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n차선으로, 랜처 랩스에서 만든 k3s는 가벼운 옵션으로 좋은 선택일 것입니다. 그 중 일부 장점은 작은 실행 파일 크기, 매우 낮은 자원 요구 사항 및 ARM용으로 최적화되어 있다는 것입니다. 이 가이드에서는 이를 테스트해보지 않았지만, 이후에 비슷한 설정이 될 것으로 생각합니다.\n\n이제 클러스터를 초기화할 시간입니다. 이를 위해 InitConfiguration 및 ClusterConfiguration 설정이 포함된 파일을 만들겠습니다.\n\n```js\napiVersion: kubeadm.k8s.io/v1beta3\nbootstrapTokens:\n- groups:\n  - system:bootstrappers:kubeadm:default-node-token\n  token: {token}\n  usages:\n  - signing\n  - authentication\nkind: InitConfiguration\nlocalAPIEndpoint:\n  advertiseAddress: 10.0.0.100\n  bindPort: 6443\nnodeRegistration:\n  criSocket: unix:///var/run/cri-dockerd.sock\n  imagePullPolicy: IfNotPresent\n  name: node-0\n---\napiVersion: kubeadm.k8s.io/v1beta3\nkind: ClusterConfiguration\nnetworking:\n  podSubnet: \"10.244.0.0/16\" # --pod-network-cidr\n```\n\n이 파일에는 마스터 노드의 설정이 포함되어 있습니다. criSocket이 cri-dockerd를 사용하고, 나중에 네트워크 CIDR을 설정해두었음을 주목하십시오.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 노드에서 제어 평면을 초기화하려면 다음을 실행하세요.\n\n```js\nsudo kubeadm init --config kubeadm-config.yaml\n```\n\n이 명령은 새 노드를 클러스터에 추가하는 설정 및 kube-config를 설정하는 방법을 보여줍니다.\n\n명령에서 지시하는 방법에 따라 kube-config를 설정하고, 워크스테이션에 kube-config와 가입 명령을 복사하고 저장하세요. 나중에 필요할 것이니까요!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 클러스터 네트워킹\n\n이제 클러스터에서 네트워킹을 설정해야 합니다. Pod들이 노드 간에 서로 통신할 수 있도록 하려면 네트워크 플러그인 (CNI 또는 컨테이너 네트워크 인터페이스로도 불림)이 필요합니다.\n\n네트워크 플러그인은 IP 주소 할당, DNS 해결 및 네트워크 격리와 같은 기능을 Pod에 제공합니다.\n\n우리는 이를 위해 Flannel을 사용할 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n마스터 노드에서 다음을 실행해 주세요.\n\n```js\nkubectl apply -f https://github.com/flannel-io/flannel/releases/latest/download/kube-flannel.yml\n```\n\n그게 다에요! 이제 마스터 노드가 완료되었으니, 클러스터에 새 노드를 추가하기 시작할 수 있어요. 이전에 출력된 조인 명령을 기억하고 있나요? 이제 그것이 필요할 거에요.\n\n# 클러스터에 새로운 노드 추가하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n클러스터에 새 노드를 추가하는 것은 꽤 간단합니다. 많은 노드를 추가하는 경우에는 tmux와 같은 도구를 사용하여 세션 명령을 다중화하는 것이 좋습니다.\n\n\"첫 번째 부팅 및 초기 설정\"을 완료하고 \"도커 및 쿠버네티스 초기 설정\"을 진행하세요. 서로 다른 Kubernetes 구성 요소를 설치하는 단계 이후에 작업을 중지하세요. 이 시점에서 이전에 실행한 kubeadm join 명령을 실행해야 합니다. cri-socket 및 node-name 옵션을 포함하여 실행해 주세요.\n\n```js\nsudo kubeadm join 10.0.0.100:6443 --token {token} --discovery-token-ca-cert-hash {hash} --cri-socket unix:///var/run/cri-dockerd.sock --node-name {name}\n```\n\n이제 마스터 노드에서 클러스터를 모니터링하고 모든 노드가 클러스터에 가입하는지 확인하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n> kubectl get nodes를 watch합니다.\n이제 귀하의 클러스터가 사용할 준비가 되었습니다! 그러나 SSH를 통해가 아닌 워크스테이션에서 액세스하고 싶을 것입니다. 컴퓨터에서 이전에 설정한 kube-config를 설정할 수 있습니다.\n\n기본 kube-config는 관리자 권한을 부여하며 다른 사람과 공유해서는 안됩니다.\n\n먼저 프로필에 구성을 내보냅니다.\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nexport KUBECONFIG=~/.kube/config\n```\n\n컨텍스트 설정:\n\n```js\nkubectl config use-context kubernetes-admin@kubernetes\n```\n\n이제 원격으로 클러스터에 액세스할 수 있어야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n> kubectl cluster-info\n쿠버네티스 제어 평면이 https://10.0.0.100:6443 에서 실행 중입니다.\nCoreDNS이 https://10.0.0.100:6443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy 에서 실행 중입니다.\n\n더 많은 디버깅 및 진단을 위해 'kubectl cluster-info dump'를 사용하세요.\n```\n\n# 도구 설정\n\n이제 밴자이라 클러스터를 일반에서 멋지게 업그레이드해 봅시다. 새 응용 프로그램을 쉽게 배포하고 클러스터를 모니터링할 수 있는 몇 가지 널리 사용되는 도구를 설정해 보겠습니다. 여기서 ArgoCD, Prometheus 및 Grafana 설치 방법을 안내하겠습니다! 이 세 가지 오픈소스 프로젝트가 우리의 클러스터를 다음 수준으로 끌어올립니다.\n\n계속하기 전에, 이러한 도구들에 대한 모든 설정 변경 사항을 추적하기 위한 원격 git 저장소를 만들어 보시기를 권장합니다. 특히 ArgoCD를 사용할 때, 각 도구나 추가 응용 프로그램을 배포할 때마다 거기를 통해 추가합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# ArgoCD\n\n각 도구에 대해 Helm을 리소스 템플릿팅 도구로 사용할 것입니다. 최신 버전(또는 적어도 Helm v3)을 설치하고 ArgoCD 저장소를 추가해 봅시다.\n\n```js\nhelm repo add argo https://argoproj.github.io/argo-helm\n```\n\nValues 파일을 생성하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```yaml\nserver:\n  serviceType: NodePort\n  httpNodePort: 30080\n  httpsNodePort: 30443\n```\n\n이 파일은 차트의 설정 중 하나를 재정의하는 데 사용할 수 있습니다. 이 경우에는 서비스를 ClusterIP 대신 NodePort로 실행하도록 변경하고 있습니다. 이렇게 하면 클러스터에서 지정한 포트를 외부에서 엑세스할 수 있도록 하여 리버스 프록시를 사용하지 않고도 개인 네트워크에서 해당 서비스에 액세스할 수 있습니다.\n\n서비스를 설치하십시오.\n\n```js\nhelm install argocd -n argocd -f values.yaml argo/argocd\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그럼 관리자 사용자의 기본 암호를 가져와야 합니다.\n\n```js\nkubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath=\"{.data.password}\" | base64 -d\n```\n\nOpenWrt를 사용하고 있기 때문에 클러스터에 호스트 이름 항목을 설정하고 https://cluster.home:30443에서 로그인 페이지에 액세스할 수 있습니다.\n\n![그림](/assets/img/2024-05-18-AGuidetoBuildingaKubernetesClusterwithRaspberryPis_2.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nArgoCD에 로그인하고, 곧 돌아올게요.\n\n![image](/assets/img/2024-05-18-AGuidetoBuildingaKubernetesClusterwithRaspberryPis_3.png)\n\n# Prometheus\n\n우리는 클러스터에 대한 정보 수집을 위해 타임 시리즈 메트릭 서버로 Prometheus를 사용할 거에요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n설치하기 전에 Prometheus가 쿼리 데이터를 저장할 지속적인 볼륨을 설정해야 합니다. 집 클러스터에서는 예비 USB 드라이브를 사용하기로 결정했지만 원하는 것을 연결하여 사용할 수 있습니다.\n\n마스터 노드에서 볼륨을 설정한 단계는 다음과 같습니다. 우리의 볼륨을 위한 경로를 만들고 실수를 막기 위해 변경 사항을 반영해야 할 fstab의 백업을 만듭니다.\n\n```js\nsudo mkdir /mnt/usb\nsudo cp /etc/fstab /etc/fstab.bak\n```\n\n장치를 연결한 다음 fstab을 변경 내용과 함께 수정합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n/dev/sda1 /mnt/usb vfat defaults,uid=youruid,gid=yourgid,dmask=002,fmask=113 0 0\n\n이제 우리 노드 사용자의 사용자 및 그룹 설정으로 장치를 마운트합니다.\n\nsudo mount -o uid=youruid,gid=yourgid,dmask=002,fmask=113 /dev/sdX1 /mnt/usb\n\n이제 우리는 PersistentVolume과 PersistentVolumeChain을 가진 Kubernetes 자원을 생성하려고 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```yaml\napiVersion: v1\nkind: PersistentVolume\nmetadata:\n  name: prometheus-usb-pv\n  labels:\n    type: local\nspec:\n  storageClassName: manual\n  capacity:\n    storage: {device의 크기}Gi\n  accessModes:\n    - ReadWriteOnce\n  persistentVolumeReclaimPolicy: Retain\n  hostPath:\n    path: \"/mnt/usb\"\n---\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: prometheus-usb-pvc\nspec:\n  storageClassName: manual\n  accessModes:\n    - ReadWriteOnce\n  resources:\n    requests:\n      storage: {device의 크기}Gi\n```\n\n만약 git 리포지토리를 사용 중이라면, 이 파일들을 template 디렉토리 안에 새로운 Helm Chart에 위치시켜주세요. 다음 단계를 따라 계속 진행해봐요.\n\n이제 프로메테우스와 함께 차트를 설정해봅시다.\n\n```bash\nhelm create prometheus\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nChart.yaml에 Prometheus subchart를 종속성으로 추가해주세요.\n\n```yaml\ndependencies:\n  - name: prometheus\n    version: 22.7.0\n    repository: https://prometheus-community.github.io/helm-charts\n```\n\n이제 새 PV 및 PVC를 사용하도록 구성을 설정하고, 일부 권한을 수정하고 서버를 마스터 노드에만 배포하도록 확인할 수 있습니다.\n\n```yaml\nprometheus:\n  alertmanager:\n    enabled: false\n  prometheus-pushgateway:\n    enabled: false\n  configmapReload:\n    prometheus:\n      enabled: false\n  server:\n    nodeSelector:\n      kubernetes.io/hostname: { master node }\n    securityContext:\n      runAsUser: { userid }\n      runAsNonRoot: true\n      runAsGroup: { groupid }\n      fsGroup: { fsid }\n    persistentVolume:\n      enabled: true\n      existingClaim: \"prometheus-usb-pvc\"\n      volumeName: \"prometheus-usb-pv\"\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n일부 추가 서비스를 비활성화합니다. 예를 들어 alertmanager, pushgateway, 그리고 configmapreload가 이에 해당합니다. 필요한 경우 다른 시간에 이를 활성화할 수 있습니다. 비정상적으로 행동하는 경우 알림을 받을 수 있는 유용한 도구인 Alert Manager입니다.\n\n이제 ArgoCD로 돌아가 \"새 앱\"을 만들어보겠습니다. Prometheus라는 이름의 앱을 만들고 깃 레포지토리를 소스로 추가하고 경로를 선택하세요. Grafana도 나중에 이 작업을 해야하므로 서로 다른 경로에 유지하세요.\n\n![Image](/assets/img/2024-05-18-AGuidetoBuildingaKubernetesClusterwithRaspberryPis_4.png)\n\n생성한 사용자 정의 설정을 설정할 값 파일을 선택한 다음 앱을 생성하세요. 수동으로 동기화하도록 지정한 경우 동기화가 필요할 때 이를 수행해야 합니다. 이것은 업그레이드할 때 사용하거나 수동으로 릴리스하고자 할 때 유용합니다. 그 외에는 홈 프로젝트에 가장 적합한 CD용 자동 동기화 방법이 유용합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Grafana](https://miro.medium.com/v2/resize:fit:1400/1*Ice0ZJGARkN6BdzAl1nGDQ.gif)\n\n마찬가지로 Prometheus와 비슷하게, git 레포지토리에서 새로운 Helm 차트를 생성하는 것부터 시작해보세요.\n\n```js\nhelm create grafana\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n헬름 리포지토리를 추가해주세요.\n\n```js\nhelm repo add grafana https://grafana.github.io/helm-charts\nhelm repo update\n```\n\n리포지토리를 통해 차트를 업데이트하세요.\n\n```js\ndependencies:\n  - name: grafana\n    version: 6.57.4\n    repository: https://grafana.github.io/helm-charts\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nvalues.yaml 파일을 추가해주세요.\n\n```js\ngrafana: service: enabled: true;\ntype: NodePort;\nnodePort: 30180;\n```\n\n그런 다음 이전과 같이 ArgoCD를 통해 Grafana를 추가해주세요. 동기화를 진행하고 이제 두 개가 모두 실행 중이어야 합니다.\n\n<img src=\"/assets/img/2024-05-18-AGuidetoBuildingaKubernetesClusterwithRaspberryPis_5.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nGrafana를 사용하려면 관리자 비밀번호를 먼저 얻어야 합니다.\n\n```js\nkubectl get secret --namespace monitoring grafana -o jsonpath=\"{.data.admin-password}\" | base64 --decode ; echo\n```\n\n출력에서 나온 관리자 사용자 이름과 비밀번호로 로그인해주세요.\n\n![이미지](/assets/img/2024-05-18-AGuidetoBuildingaKubernetesClusterwithRaspberryPis_6.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 Prometheus 데이터 원본을 추가해 보겠습니다. Prometheus 서비스 URL은 모니터링을 설정한 네임스페이스인 클러스터에서 http://prometheus-server.monitoring.svc.cluster.local로 접근할 수 있습니다. \"Administration\" → \"Data sources\" → \"Add new data source\" 아래로 이동한 다음 URL을 추가하고 \"Save & Test\"를 클릭하여 확인할 수 있습니다.\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*VphOqjzSh30E4dKrnf2Q2A.gif)\n\n만약 우리 클러스터의 상태를 간단히 확인하고 싶다면 Grafana Labs에서 제공하는 대시보드를 사용할 수 있습니다. 이를 통해 우리 클러스터에서 사용되는 리소스에 대한 간단한 뷰를 확인할 수 있을 것입니다.\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*AIw7esBCtaz5koK_uJTU-w.gif)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 다음 단계\n\n## 사용자 정의 Docker 이미지\n\n당신의 클러스터를 운영하는 중요한 단계로, 공개 Docker.io 레지스트리에 없는 컨테이너나 사용자 정의 컨테이너를 배포할 수 있게 됩니다. 클러스터에 많은 컨테이너를 배포할 계획이라면, 무료 티어 Docker Hub의 제한을 피하기 위해 개인 컨테이너 레지스트리를 설정하는 것을 권장합니다. 이는 GCP의 Artifacts Repository와 같은 클라우드 공급업체나 Harbor와 같은 오픈 소스 docker 저장소로 구현할 수 있습니다.\n\n## 클러스터 자동화\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 안내서는 교육 목적이나 소규모 개인 클러스터를 관리할 때 이상적인 Kubernetes 클러스터 설정에 대한 수동 방법을 제공합니다. 그러나 프로덕션 클러스터를 배포하거나 이 안내서의 범위를 벗어나는 작업을 수행할 경우, Ansible과 같은 자동화 도구를 활용하는 것을 권장합니다. 이렇게하면 더 효율적이고 확장 가능하며 관리하기 쉬운 배포가 가능합니다.\n\n# 결론\n\nKubernetes 클러스터를 설정하는 것은 쉽지 않을 수 있지만 한 번 완료되면 일반적인 독립형 서버를 뛰어넘는 확장 가능한 환경을 제공하는 장점이 있습니다.\n\nRaspberry Pi는 비용이 저렴하고 전력 소비가 낮은 옵션이지만, 더 큰 응용 프로그램에 대한 확장성이 여전히 제한되어 있습니다. Kubernetes 클러스터의 장점은 동일한 하드웨어만 실행하는 것에 제한받지 않는다는 것입니다. 새로운 노드를 추가함으로써 다양한 하드웨어를 혼합하여 필요에 맞게 Raspberry Pi나 서버와 같은 다양한 하드웨어를 조합할 수 있습니다!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그것이 좋은 시작점이 되었기를 바랍니다. 읽어 주셔서 감사합니다!\n","ogImage":{"url":"/assets/img/2024-05-18-AGuidetoBuildingaKubernetesClusterwithRaspberryPis_0.png"},"coverImage":"/assets/img/2024-05-18-AGuidetoBuildingaKubernetesClusterwithRaspberryPis_0.png","tag":["Tech"],"readingTime":23},{"title":"러스트 앱을 여러 아키텍처용으로 크로스 컴파일하기","description":"","date":"2024-05-18 19:07","slug":"2024-05-18-Cross-compileyourRustappformultiplearchitectures","content":"\n<img src=\"/assets/img/2024-05-18-Cross-compileyourRustappformultiplearchitectures_0.png\" />\n\nRust는 앱 개발을 위한 포맷부터 문서 작성까지 포괄적인 도구를 갖춘 신속하고 견고한 언어입니다. 그러나 컴파일된 언어이므로 다양한 아키텍처 간 호환성을 보장하기 위해 추가적인 노력이 필요합니다. 다행히 Rust는 이를 개발자들을 위해 간소화했습니다. 오늘은 Rust로 기본적인 HTTP 서버 애플리케이션을 작성하고 ARMv7 프로세서용으로 크로스 컴파일하여 네트워크 연결을 통해 STM32MP1 보드에 배포하는 방법에 대해 살펴볼 것입니다.\n\n# 준비물\n\n크로스 컴파일 작업을 시작하기 전에, 특정 사전 준비물이 갖추어져 있어야 합니다. 계속 진행하기 전에 다음 사항을 확인하세요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- Rust이 컴퓨터에 설치되어 있습니다.\n- 당신은 싱글보드 컴퓨터 또는 컴퓨터와 다른 아키텍처를 가진 장치를 사용하고 있습니다. (저는 STM32MP1을 사용하지만 라즈베리파이, 비글본 또는 다른 장치를 사용할 수 있습니다)\n- 싱글보드 컴퓨터에서 리눅스 배포판이 실행 중입니다.\n- 당신은 보드의 IP 주소를 알고 있으며 SSH를 통해 연결할 수 있는 능력을 가지고 있습니다.\n\n# 안녕하세요, 새로운 Arch!\n\n먼저 Rust 프로젝트가 포함될 디렉토리를 생성합니다. 가장 간단한 방법은 원하는 이름으로 빈 폴더를 수동으로 생성한 다음 (예: mkdir hello-new-arch), 해당 폴더로 이동하여 cargo init --bin을 실행하는 것입니다. 이 명령은 실행 가능한 (바이너리) \"hello new arch\" 애플리케이션을 위한 모든 필요한 소스 파일을 생성합니다. 터미널에서 cargo run으로 앱을 컴파일하고 실행하면 모든 것이 잘 작동하면 터미널에 \"Hello, world!\" 메시지가 출력됩니다.\n\n이제 백그라운드에서 실행되는 간단한 HTTP 서버를 생성할 준비가 되었습니다. Rust는 이 작업을 수행하기 위한 여러 우수한 옵션을 제공합니다. 저는 이 작업을 수행하기 위해 Axum을 선호합니다. 이는 이전 프로젝트에서의 경험과 Tokio 비동기 런타임 팀과의 관련성으로 인해입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n먼저 Cargo.toml 파일에 필요한 종속성을 추가해야 합니다.\n\n```js\n[package]\nname = \"hello-new-arch\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\naxum = \"0.7.2\"\ntokio = { version = \"1.35.0\", features = [\"full\"] }\n```\n\n다음으로 Axum GitHub 저장소에서 'hello-world' 예제 애플리케이션을 복제합니다. 그 후에는 작은 수정만 필요합니다.\n\n저희가 가장 크게 변경하는 부분은 127.0.0.1:3000에 바인딩하는 대신에 실제로 물리적 네트워크 인터페이스 상에서 노출되지 않는 루프백 주소인 0.0.0.0:3000에 바인딩한다는 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리는 이제 로컬에서 cargo run을 통해 다시 실행하고 모든 것이 잘 작동하면 터미널에 \"listening on...\" 메시지를 볼 수 있습니다. 그런 다음 브라우저 탭을 열어 http://localhost:3000/으로 이동하여 \"Hello from another architecture!\" 헤더가 포함된 페이지가 제공되는지 확인합니다.\n\n# 크로스 컴파일 단계!\n\n현재, 우리 앱을 보드에 업로드하려고 하면 실행할 수 없다는 것을 알게 될 것입니다. 이 문제는 우리 프로그램이 보드의 아키텍처와 호환되지 않는 x86 프로세서용으로 컴파일되었기 때문에 발생합니다.\n\nRust를 크로스 컴파일하려면 보드에서 사용 중인 아키텍처를 확인해야 합니다. 한 번 결정되면, 현재 Rust 툴체인에 적합한 타겟 플랫폼을 설치해야 합니다. Rust는 Tier1, Tier2 및 Tier3 수준으로 분류된 많은 아키텍처에 대한 광범위한 지원을 제공합니다. 이러한 티어 간의 차이점에 대한 포괄적인 이해를 위해 문서를 참조하십시오.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n예를 들어, 제 STM32MP1 보드에는 ARMv7 32비트 프로세서가 탑재되어 있습니다. 공식 Rust 책에 따르면, 이 구성을 위한 필수 대상은 armv7-unknown-linux-gnueabihf입니다. 대략적으로, 선택한 대상 구성 요소는 다음과 같은 의미를 갖습니다:\n\n- armv7: 대상 프로세서에 사용할 아키텍처인 ARM v7\n- unknown: 사용할 서브 아키텍처; 여기서는 기본 옵션을 의미함\n- linux: 대상 운영 체제\n- gnueabihf: 대상 ABI; gnu는 실행 중에 일부 기능에 GNU C 라이브러리(이른바 libc로도 알려짐)를 의존한다는 것을 의미하며, hf는 하드웨어 부동 소수점 연산을 지원한다는 것을 의미함\n\n이 특정 대상을 위해 Rust를 구성하려면 다음 명령을 실행하세요:\n\n```js\nrustup target add armv7-unknown-linux-gnueabihf\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 이 명령어를 사용하여 교차 컴파일을 시도해 봅시다:\n\n```js\ncargo build --release --target=armv7-unknown-linux-gnueabihf\n```\n\n그러나 잠시 후에 다음과 유사한 오류가 발생할 가능성이 있습니다:\n\n```js\nerror: linking with `cc` failed: exit code: 1\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n2진 파일이 성공적으로 컴파일되었지만 링킹 실패가 발생했습니다. 이 문제가 발생하는 이유는 우리 개발 머신에서 Cargo가 x86 바이너리나 호스트 시스템의 특정 아키텍처를 위해 구성된 cc 및 ld에 의존하기 때문입니다. 이로 인해 ARM 바이너리를 조립할 필요한 지식이 부족합니다. 이 작업에 더 적합한 링커를 사용하도록 Cargo를 안내해야 합니다. 또한 ARM 아키텍처와 관련된 컴파일 또는 링크 작업을 처음 시도하는 경우 필요한 도구를 아직 설치하지 않았을 가능성이 높습니다. 이 문제를 해결하려면 Ubuntu에서 다음 명령을 사용하십시오:\n\n```js\nsudo apt install gcc-arm-linux-gnueabihf\n```\n\n이제 ARM에 적합한 링커와 컴파일러를 설치하고, 'arm-linux-gnueabihf-gcc' 명령어를 호출하여 테스트해보겠습니다(인수 없이 호출하면 즉시 종료됨).\n\n그러나 Cargo가 바이너리의 링킹 단계에서 이를 활용하도록하려면 안내가 필요합니다. 이를 위해 ./.cargo/config라는 새 파일을 만들어 다음 내용을 입력해야 합니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n[target.armv7-unknown-linux-gnueabihf]\nlinker = \"arm-linux-gnueabihf-gcc\"\n\n이렇게 하면 ARM-specific 버전의 gcc를 사용하여 armv7-unknown-linux-gnueabihf Rust target을 위해 컴파일된 이진 파일을 링킹하는데 cargo가 지시됩니다.\n\n## http-server를 시도해봅시다\n\n좋아요, 이제 보드의 아키텍처에 맞는 올바른 컴파일 설정을 성공적으로 설정했으니, 여러 단계를 고려하여 프로세스를 간소화하기 위해 셸 파일을 스크립팅하는 것이 좋겠네요. 이 스크립트는 배포 워크플로를 자동화하여 실행을 더 쉽게 할 것입니다. 동일한 디렉토리에 deploy.rs라는 이름의 텍스트 파일을 생성하고 다음 콘텐츠를 추가합니다. 각 명령어의 기능에 대한 명확성을 위해 주석도 추가했어요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그러면 chmod +x ./deploy.rs와 같은 명령으로 스크립트를 실행 가능하게 만들어 줍니다. 그러면 ./deploy를 통해 직접 실행할 수 있습니다. 이제 바로 시도해 볼 수 있고, 만약 deploy 스크립트에 매개변수를 올바르게 작성했다면, 서버에서 \"listening on 'your board ip address'\"라는 로그 라인을 마침내 볼 수 있게 됩니다. 이는 서버가 최종적으로 대상 보드에서 올바르게 실행되고 있음을 의미합니다!\n\n웹 서버에 액세스하려면 브라우저 탭을 열고 http://'your_board_ip_address':3000으로 이동하면 됩니다. 이제 이 익숙한 웹 페이지가 보드에서 직접 제공되고 있습니다. 접근성을 확인하기 위해 다른 기기(같은 네트워크에 연결된 스마트폰 등)에서 접속을 시도할 수 있습니다.\n\n이 프로그램이 프로덕션에 즉시 적합한 것은 아닙니다. SSH 세션을 종료한 후에도 계속 작동되도록 보장하려면 지속적인 실행을 지원하는 시스템을 구현해야 할 수도 있습니다. 이러한 개선 사항 및 조정 사항은 향후 기사에서 다룰 수도 있습니다.\n\n# 결론\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n관찰해 보았을 때, 크로스 컴파일은 인내와 해당 하드웨어에 대한 이해가 필요합니다. 그러나 러스트의 생태계와 관련 도구를 활용하면, 처음에 예상했던 것보다 덜 어려울 수 있습니다. 독자 여러분, 감사합니다!\n","ogImage":{"url":"/assets/img/2024-05-18-Cross-compileyourRustappformultiplearchitectures_0.png"},"coverImage":"/assets/img/2024-05-18-Cross-compileyourRustappformultiplearchitectures_0.png","tag":["Tech"],"readingTime":7},{"title":"라즈베리 파이에 Tailscale VPN을 통해 SSH하기","description":"","date":"2024-05-18 19:06","slug":"2024-05-18-SSHIntoRaspberryPiwithTailscaleVPN","content":"\n<img src=\"/assets/img/2024-05-18-SSHIntoRaspberryPiwithTailscaleVPN_0.png\" />\n\n요즘 연결된 세상에서 원격으로 기기에 액세스하는 것은 많은 기술 애호가와 전문가들에게 필수적인 요소가 되었습니다. 집에서 프로젝트를 작업하는 취미 요원이든, 여러 기기를 관리하는 IT 전문가이든, 안전한 원격 액세스가 중요합니다. 이러한 목적에 가장 적합한 도구 중 하나가 Tailscale입니다.\n\nTailscale은 기기 간의 안전한 네트워크를 생성하는 과정을 간소화하는 망 VPN 서비스입니다. Tailscale을 사용하면 전 세계 어디에서나 Raspberry Pi에 쉽게 액세스할 수 있으며, 마치 동일한 로컬 네트워크에 있는 것처럼 사용할 수 있습니다. 이 튜토리얼에서는 Raspberry Pi에 Tailscale을 설정하여 외부 네트워크에서 SSH로 액세스하는 방법을 안내하겠습니다. Raspberry Pi와 Mac에서의 설치 과정을 다루고, 기기 인증 방법을 보여드리며, SSH 연결을 설정하는 방법을 시연하겠습니다. 참고로 Windows 사용자들의 단계는 비슷합니다.\n\n나머지 부분을 읽기 전에 아직 채널을 구독하지 않았다면 반드시 구독하고 지원해주세요!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 구독하기:\n\nYouTube\n\n# 후원하기:\n\n[Buy Me a Coffee](https://www.buymeacoffee.com/mmshilleh)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nUpWork에서 저를 고용하여 IoT 프로젝트를 구축하세요:\n\n[https://www.upwork.com/freelancers/~017060e77e9d8a1157](https://www.upwork.com/freelancers/~017060e77e9d8a1157)\n\n# 단계 1: 라즈베리 파이에 Tailscale 설정하기\n\n라즈베리 파이 업데이트: 모든 패키지가 최신 상태인지 확인하려면 Raspberry Pi를 업데이트하세요. 터미널을 열고 다음을 실행하세요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nsudo apt update\nsudo apt upgrade -y\n```\n\nTailscale 설치: 먼저 Tailscale을 설치하세요. 라즈베리 파이에 Tailscale 레포지토리를 추가해야 합니다:\n\n```js\ncurl -fsSL https://pkgs.tailscale.com/stable/raspbian/buster.gpg | sudo apt-key add -\ncurl -fsSL https://pkgs.tailscale.com/stable/raspbian/buster.list | sudo tee /etc/apt/sources.list.d/tailscale.list\n```\n\n패키지 목록을 업데이트하고 Tailscale을 설치하세요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nsudo apt update\nsudo apt install tailscale\n```\n\nTailscale를 시작하세요: 설치가 완료되면 Tailscale 서비스를 시작합니다.\n\n```js\nsudo tailscale up\n```\n\nRaspberry Pi를 Tailscale 계정으로 인증하기 위해 안내에 따라 따라하세요. 이를 위해 웹 브라우저에서 Tailscale 계정으로 로그인하고 장비를 인가해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 단계 2: 맥에서 Tailscale 설정하기\n\n- Tailscale 다운로드: Tailscale 웹사이트를 방문하여 Mac 버전의 Tailscale을 다운로드합니다.\n- Tailscale 설치: 다운로드한 파일을 열고 설치 지침에 따릅니다.\n- 맥 인증: 응용 프로그램 폴더에서 Tailscale을 열고 Tailscale 계정으로 로그인합니다. 이렇게 하면 맥이 Tailscale 네트워크에 추가됩니다.\n\n# 단계 3: SSH를 통해 라즈베리 파이에 연결하기\n\n라즈베리 파이의 Tailscale IP 찾기: 라즈베리 파이에서 다음을 실행하세요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\ntailscale ip -4\n```\n\n이 명령을 실행하면 Raspberry Pi의 Tailscale IP 주소(예: 100.x.x.x)가 표시됩니다.\n\n라즈베리 파이로 SSH 연결하기: 맥에서 터미널을 열고 다음 명령을 사용하여 라즈베리 파이로 SSH 연결할 수 있습니다.\n\n```js\nssh pi@<tailscale-ip>\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이전 단계에서 얻은 IP 주소로 `tailscale-ip`를 대체하세요. 예를 들어:\n\n```js\nssh pi@100.64.0.1\n```\n\n처음 연결하는 경우 호스트를 알려진 호스트 목록에 추가하라는 메시지가 나타날 수 있습니다. yes를 입력하고 Enter 키를 누르세요.\n\nWindows 사용자를 위한 참고: Windows 기기에 Tailscale을 설정하는 단계는 Mac과 유사합니다. Tailscale 웹사이트에서 Tailscale 설치 파일을 다운로드하고 설치한 다음 Tailscale 계정으로 로그인하세요. 그런 다음 PuTTY나 Windows 터미널과 같은 SSH 클라이언트를 사용하여 Raspberry Pi에 Tailscale IP를 사용하여 SSH로 연결하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 결론\n\nTailscale을 사용하면 라즈베리 파이에 안전한 원격 액세스를 쉽고 효율적으로 설정할 수 있습니다. 이 튜토리얼에서 안내된 단계를 따라하면 어디에서나 라즈베리 파이를 쉽게 관리할 수 있습니다. Mac이든 Windows를 사용하든 Tailscale의 원활한 통합 덕분에 원격 SSH 액세스가 간편해집니다. 해킹을 즐기세요!\n","ogImage":{"url":"/assets/img/2024-05-18-SSHIntoRaspberryPiwithTailscaleVPN_0.png"},"coverImage":"/assets/img/2024-05-18-SSHIntoRaspberryPiwithTailscaleVPN_0.png","tag":["Tech"],"readingTime":5},{"title":"내 친구들과 화해하기","description":"","date":"2024-05-18 19:04","slug":"2024-05-18-MendingMyMends","content":"\n## 직접 만들기\n\n![이미지](/assets/img/2024-05-18-MendingMyMends_0.png)\n\n내 책상은 언제나 진행 중인 재봉틀 프로젝트로 가득 차 있어요. 스커트를 만드느라 시간을 보내다가 스타일이 변하면 나중에 바꾸기도 해요. 내 옷장과 재봉틀 기술이 끊임없이 발전하고, 때로는 옷이 여러 차례 다시 책상 위에 놓일 때도 있어요. 이 재봉틀의 장점을 받아들이고, 때로는 즐기는 법을 배우고 있어요.\n\n한 날, 특히 영감을 받아서 옷장을 뒤적여 두 개의 스커트와 두 개의 셔츠를 꺼냈어요 — 모두 옷장 뒷부분에 쑤시고 더 이상 사용하지 않는 옷들이었죠. 그 셔츠들은 예전에 좋아했던 아이템들인데, 이제는 날 어울리지 않는 것 같아요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n스커트는 제가 처음 바느질을 배우던 시절의 예입니다. 지금 생각하면 매우 부끄러운데요.\n\n![2024-05-18-MendingMyMends_1.png](/assets/img/2024-05-18-MendingMyMends_1.png)\n\n이들은 맞지 않아요 — 어느 부분에서는 너무 작고, 다른 부분에서는 너무 큽니다. 실이 사방으로 튀어나오고, 꿰매는 바늘이 자꾸 풀립니다. 제게는 바느질 실력이 발전하는 과정을 보여주는 증거라고 자신합니다. 앞으로 더 나아질 거라고 믿어요!\n\n![2024-05-18-MendingMyMends_2.png](/assets/img/2024-05-18-MendingMyMends_2.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n상의는 간단히 고쳤어요. 너무 헐렁하고 조임이 필요했어요. 소매를 잘라낸 부분을 안으로 돌려야 했고, 가장자리에 수작업으로 디테일을 추가했어요.\n\n![이미지](/assets/img/2024-05-18-MendingMyMends_3.png)\n\n그러나 보라색 스커트는 전면적인 재작업이 필요했어요. 끊임없이 고민했어요: 스커트 위에 패치워크를 해야 할까요? 라일락 색의 부분을 드러나게 해야 할까요? 고무 허리띠를 추가해야 할까요, 아니면 끈을 유지해야 할까요?\n\n![이미지](/assets/img/2024-05-18-MendingMyMends_4.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n의심이 많이 들 때, 제 쓰레기 더미를 뒤져보았고, 몇 년 전에 받은 스카프 조각들이 부르는 것 같았어요. 항상 그 무늬와 색상을 좋아했고, 몇 년 동안 홈 데코용으로 사용해왔는데, 형광등의 강한 빛을 부드럽게 만들어 주었죠.\n\n![스카프 조각](/assets/img/2024-05-18-MendingMyMends_5.png)\n\n장식물로서의 역할을 은퇴한 후, 스커트의 멋진 장식물이 될 수 있을 것 같아서 파란 색 띠를 제거하기 시작했어요. 이 프로젝트는 아직 진행 중이에요. 어떻게 진행할지, 제가 좋아하는 부분(원단의 색감)을 보존하고 옷 전체의 맞지 않는 부분을 어떻게 해결할지에 대해 고민하고 있어요. 결론에 도달할 것이라고 희망하지만, 그 전까진 이 스커트가 제 바느질 책상 위에서 살아갈 거예요.\n\n![진행 중인 스커트 프로젝트](/assets/img/2024-05-18-MendingMyMends_6.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n엉망으로 되어있었던 분홍 꽃무늬 스커트 부분에 대한 해결책을 찾았어요! 다시 한 번 내 재료파일이 영감의 원천이 되었네요. 측면의 좁음은 베개케이스에서 나온 꽃무늬 원단을 추가해 해결했어요. 옷의 모양이 돋보이도록 하기 위해 상단에서 좁아서 하단에서 넓게 원단을 조각해 주었어요.\n\n![이미지](/assets/img/2024-05-18-MendingMyMends_7.png)\n\n그리고 이상한 회색 넥타이 대신에 대차넘친 테이블보가 남아있던 원단을 추가하기로 결정했어요. 이러한 유형의 기하학적 디자인은 남미 안데스 지역에서 전통적이에요. 이 지역이나 대륙의 원주민은 아니지만, 지역 문화의 한 측면을 내 소소한 수선에 포함시키는 것이 좋은 느낌이에요.\n\n스커트와 셔츠가 어떻게 변했는지 확인해보세요. 사진을 찍을 때 뇌리를 조금 놀려야만 틸라가 나와준달까요, 그래도 빅 틸라가 동의했다고 생각하고 싶어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![2024-05-18-MendingMyMends_8](/assets/img/2024-05-18-MendingMyMends_8.png)\n\n저의 몇 가지 성공 경험 뒤에 제 옷장을 뒤져보니 자주색 스커트가 보였어요. 저는 이 스커트에 고무 밴드를 추가하고 아마 아래쪽에 다른 하나의 층을 더할 예정입니다. 거짓 프러티코트처럼 어떤 층을 더할 생각입니다. 프러티코트에 사용될 소재는 현재 뜨는 구식 침대 시트에서 나온 것일 겁니다.\n\n![2024-05-18-MendingMyMends_9](/assets/img/2024-05-18-MendingMyMends_9.png)\n\n이 글을 쓰는 시점에서 자주색 스커트는 완성되지 않았어요. 느린 패션의 특성인데요 - 모든 부분이 시간이 걸리는 건 사실입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여러 순간을 반영하는 변경 사항을 만드는 데 소요된 시간으로, 각 수선은 모든 의복이 정말 독특하며 기계와 손으로 세워진 추억을 가지고 있다는 것을 필요로 합니다. 계속 진행 중인 삶의 기억이 그 안에 담겨 있죠.\n","ogImage":{"url":"/assets/img/2024-05-18-MendingMyMends_0.png"},"coverImage":"/assets/img/2024-05-18-MendingMyMends_0.png","tag":["Tech"],"readingTime":5},{"title":"여름 피부를 빛나게 하는 각질 제거","description":"","date":"2024-05-18 19:03","slug":"2024-05-18-ExfoliatingforSummerGlow","content":"\n여름에 우리 피부는 땀과 기름을 더 처리해야 합니다, 특히 더운 다습한 날씨에서는 모공이 막힌 기름진 피부를 초래합니다. 땀, 선크림, 염소소독약, 소금물 등이 흔하며, 이에 대비하여 거품을 내는 세안제와 SPF가 들어간 가벼운 보습제를 사용하는 스킨케어 루틴이 필요합니다. 개선된 각질 제거는 여름 피부 문제에 효과적으로 대처하기 위해 필수적입니다.\n\n# 각질 제거\n\n미국 피부과학회에서 \"피부의 외부층에서 죽은 피부세포를 제거하는 과정\"으로 정의한 각질 제거는 세포 회전율, 재생 및 콜라겐 생성을 돕는다. 젊고 반짝이는 피부를 유지하는 데 중요한 단계입니다. 각질 제거의 혜택은 그 이상이며, 각질 제거는 모공을 열어 여드름을 예방하고 부드럽고 매끄러운 피부를 유지하는 데 도움이 됩니다. 정기적인 각질 제거는 다른 스킨케어 제품의 흡수를 향상시키고 그 효능을 극대화합니다.\n\n여름에는 귀한 각질 제거가 더욱 필수적이며, 죽은 피부세포를 빠르게 제거하여 피부의 홍조를 유지할 뿐만 아니라 더 효과적인 탈부각을 보장하여 피부의 생기를 유지합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 엑스폴리에이션의 두 가지 주요 방법이 있습니다\n\n화학적 방법 & 물리적 방법 (또는 기계적 방법)\n\n## 화학적 엑스폴리에이션\n\n화학적 엑스폴리에이션은 AHAs나 BHAs와 같은 산 또는 효소를 사용하여 피부 속까지 깊이 스며들고 부드럽습니다. 알려진 AHAs로는 젖산 및 글리콜산 등이 있으며, 미세 주름, 주름, 모공, 그리고 피부 톤 불균일을 개선합니다. 살리실릭산 또는 버들나무 껍질 추출물과 같은 BHAs는 여드름, 블랙헤드, 화이트헤드, 그리고 햇볕으로부터 온 피부 손상의 외관을 향상시킵니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 물리적 각질제거\n\n물리적 각질제거는 도구나 수동으로 이루어집니다.\n\n- 전문가가 실시하는 물리적 각질제거 방법에는 뎌마플레닝(dermaplaning)과 마이크로더마브레이젼(microdermabrasion) 등의 절차가 포함됩니다.\n- 집에서 사용할 수 있는 수동 각질제거제로는 스펀지, 브러시, 또는 모래, 설탕, 호호바 비드, 커피 찌꺼기 등이 있습니다.\n\n피부가 얇거나 민감한 경우 화학적 각질제거제가 가장 적합할 수 있지만, 꼭 미리 패치 테스트를 해보세요!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 여름에 안전하고 효과적인 각질 제거: 완벽한 결과를 위한 팁\n\n- 먼저, 피부 타입에 맞는 올바른 각질 제거제를 선택하세요.\n  지성 피부인 경우 물리 각질 제거제를 선택하세요.\n  건성 피부인 경우 더 부드러운 효소(화학) 각질 제거제를 선택하세요. 복합성 피부는 두 가지 타입을 사용하는 것이 좋습니다. 항상 패치 테스트를 먼저 해보세요.\n- 여름에는 부드럽지만 효과적으로 미지근하고 효생한 각질 제거제를 선택하세요.\n- DIY 스크럽에 대해 확인해보세요. 자연 및 유기농 성분을 사용한 많은 레시피를 찾을 수 있으며 도움이 될 수 있습니다.\n- 이어서 정기적으로 각질을 제거하세요. 이렇게 하면 피부를 부드럽게 유지하고 다른 스킨케어 제품이 더 잘 작용할 수 있습니다.\n- 각질 제거 후 피부가 햇볕에 민감해지므로 특히 자외선차단제와 SPF 30 이상의 보습제를 사용하세요. 부드러운 자외선 차단제를 사용하세요.\n- 민감도와 자극이 발생할 수 있는 지나친 각질 제거를 피하세요. 화학 치료 후에 각질 제거를 건너뛰고 물리적이든 화학적이든 각질 제거제를 사용할 때 항상 피부에 부드럽게 행동하세요.\n\n이러한 팁으로 여름에 반짝이는 피부를 만들어 보세요!\n\n내가 자연 치료 건의를 나누기 위해 여기 있습니다. 만약 이 기사를 좋아하셨다면 새로운 제안에 대한 알림을 받으려면 팔로우하고 구독하지를 잊지 마세요.\n","ogImage":{"url":"/assets/img/2024-05-18-ExfoliatingforSummerGlow_0.png"},"coverImage":"/assets/img/2024-05-18-ExfoliatingforSummerGlow_0.png","tag":["Tech"],"readingTime":3},{"title":"ALTRAD8UD-1L2T에 GPU를 사용할 수 있도록 하는 빠른 업데이트","description":"","date":"2024-05-18 19:02","slug":"2024-05-18-AquickupdateonALTRAD8UD-1L2TmakingitworkwithGPU","content":"\n동일한 주제에 대한 다른 기사들:\n\n- 첫 번째: ASRock Rack ALTRAD8UD-1L2T (Ampere Altra)의 첫 인상\n- 두 번째 (이 기사): ALTRAD8UD-1L2T에 대한 빠른 업데이트 (GPU와 함께 작동시키기)\n\n# 소개\n\n이것은 Ampere Altra 보드에 대한 첫 인상의 빠른 업데이트일 것입니다. 그래서 그림은 게시글의 어딘가에서 찍은 것이 아니라 제 고양이 중 한 마리와 함께 있을 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n모든 것이 도착할 때까지 기다리는 동안 서버를 구축하고 있어요 (샤시를 구하고 보드의 절반 가격을 내지 않아도 시간이 걸릴 것 같아서...); 아파트에 있는 랜덤한 PCIe 장치를 연결해서 작동시키려고 노력하고 있어요. 당연히 먼저 시도할 것은 GPU에요.\n\n솔직히 말해서 많지는 않아요. HDMI/DP 또는 DVI 출력만 합리적으로 사용할 수 있는 몇 개가 있어요. 그러나 Altra에서 게임을 할 기회를 갖고 싶다면 몇 가지 선택지가 있어요:\n\n- RX 550 — 오래 동안 amdgpu에서 지원된 Polaris입니다; 또한 DCN의 Floating Point 명령 같은 특별한 것은 없어서 비교적 좋은 호환성을 가지고 있어요.\n- RX 5700은 채굴 랙에서 뽑아낸 것일 가능성이 높은 싸게 구한 버전이에요; 랜덤한 시스템에 꽂아도 충분히 좋아요. 작동 상태이지만 얼마나 오래 갈지는 모르겠어요. 이 카드는 DCN을 사용하고 있어요.\n- Intel Arc 750 — RX 5700와 성능적으로 대체로 비슷한 양호한 GPU인 것 같아서 가져왔어요. 상대적으로 좋은 RayTracing을 가지고 있고, Intel은 Linux(x86/x86-64)에서 잘 작동한다는 신뢰를 가지고 있어요.\n\n# RX 550\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nRX550은 지루하지만 제대로 작동하는 것 같아요:\n\n스크린샷의 품질이 떨어져서 죄송해요; 저는 싸고 간단한 USB-HDMI 캡처 카드를 사용해서 찍었어요. 그리고 제가 곧 글을 쓸 계획은 없었기 때문에, 제가 누군가에게 보여준 여러 종류의 메시지에서 이 스크린샷을 얻었어요.\n\n해당하는 커널은 기본 커널을 실행하고 있어요, 그래서 거기서 아무것도 바꾸지 않았어요.\n\n# RX 5700\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n실행하는 것은 훨씬 더 어려웠어요. 먼저, 6.1 커널은 ARM에서 FP 레지스터를 저장하지 않는다(잘못 기억했다면 고쳐주세요), 이는 DCN 1.0 이상을 지원하는 카드에서 필요합니다. 더욱이, Ampere Altra에는 PCIe에 관한 버그가 있어서 일부 장치가 작동하지 않습니다. 이를 \"Ampere Altra erratum #82288 PCIE_65\"라고 부르며, 이미 일부 Linux 배포판에 통합되어 있습니다. 이 문제에 대한 커뮤니티 포럼에서 토론이 진행 중입니다.\n\n만약 그 패치를 적용하지 않으면, amdgpu가 카드를 초기화하지 못할 것입니다. 6.9-rc6 커널(내가 시도한 가장 최신 버전)을 사용해도 다음과 같은 메시지가 표시됩니다:\n\n때로는 부팅이 되기는 하지만, 그래픽 오류나 시스템 멈춤이 발생할 수 있습니다.\n\n하지만 패치를 적용하면 잘 작동합니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Image](/assets/img/2024-05-18-AquickupdateonALTRAD8UD-1L2TmakingitworkwithGPU_0.png)\n\n# Intel Arc 750\n\n이건 웃긴 게 한 가지 있어요. 그 이유는 인텔 i915 커널 드라이버가 비-x86 장치에서 동작하지 않기 때문이에요. 그들은 최근 GPU에 더 맞춰진 새로운 Xe 커널 드라이버를 업스트림으로 올리기 시작했어요. 하지만, Altra에서 그것을 사용하려고 하면, 기본적으로 다음과 같은 결과를 얻을거에요:\n\n조금 더 찾아보았더니, 초기화하고 이미지를 출력하는 지저분한 해킹을 발견했어요 (2D만 가능하며, 더 복잡한 메사 부분이 있을 수도 있어요):\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/assets/img/2024-05-18-AquickupdateonALTRAD8UD-1L2TmakingitworkwithGPU_1.png)\n\n어떤 부분을 효과적으로 주석 처리했나요? 설명에 따르면 intel_vga_reset_io_mem은 VGA Console이라는 모듈과 호환성을 보장하기 위한 함수인데, 해당 모듈이 사용하는 레지스터를 건드리지 않으면 락업이 발생한다고 합니다. 그 함수가 하는 일에 대해 자세히 설명하는 주석이 있습니다. 그러나 (오래된 플랫폼 중 하나를 제외하고는) ARM에서는 VGA Console이 작동하지 않습니다. 따라서 테스트를 위해 주석 처리해도 무방할 것입니다.\n\n그렇게 하면, 어느 정도 시간이 지난 후 (특히 drm 디버그 로깅이 활성화된 상태에서는 드라이버가 초기화되기까지 일정 시간이 소요됩니다):\n\n![이미지](/assets/img/2024-05-18-AquickupdateonALTRAD8UD-1L2TmakingitworkwithGPU_2.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n사진을 받았어요! ARM에서 실행 중인 인텔 GPU의 HDMI 출력!\n\n여전히 3D가 없는 이유는 두 가지 때문입니다:\n\n- debian 테스팅에 포함된 Mesa의 업그레이드된 버전이 필요합니다 (지난 기사 이후로 테스팅으로 업그레이드했습니다).\n- Xe를 처리하는 i915 갈리움 드라이버가 x86/x86-64 전용으로 표시되어 있습니다. 그래서 이것을 작동시키는 것이 매우 어려울 것입니다 (특히 저는 mesa 코드베이스에 익숙하지 않기 때문에).\n\n변경: 리눅스에서 인텔 GPU를 사용한 지 얼마 되지 않아서 Xe와 인텔 Arc가 여전히 i915로 처리된다는 잘못된 인상을 가지고 있었습니다. 실제로는 더 최신 iris 드라이버에 의해 처리됩니다. 그래서 여기에서 말한 내용은 무시해 주세요.\n\n하지만 승리는 승리입니다. 작은 승리라도요. 이제 위에 있는 수정을 upstream으로 할 필요가 있고, 솔직히 어떤 종류의 패치가 거기서 허용될지 확실하지 않습니다. 현재 제 추측은 CONFIG_VGA_CONSOLE에 빨간불을 켜면 괜찮을 것 같지만, 우리가 보겠죠.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 같은 날 나중에 업데이트\n\nDebian에서 ARM에 intel-specific 라이브러리를 활성화하지 않기 때문에 libdrm을 다시 컴파일하는 데 몇 시간을 보냈습니다. 또한, debian-testing의 mesa도 오래되었고 거기서 Xe는 x86/x86-64 아키텍처로 제한되어 있어서 24.1.0-rc에서는 aarch64로 컴파일할 때 기본 드라이버 목록으로만 작동해야 할 것이지만 RayTracing을 제외하고, 그것은 다른 이야기입니다. 그런데 결국 아무것도 작동하지 않게 되었습니다.\n\ngdm을 시작하려고 시도하면 바로 다음과 같이 오류가 발생하고:\n\n\"guc ids might be different\"라는 메시지가 표시되고 결국 다음과 같은 메시지로 잠겨 버립니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n커서가 렌더링되어 있었지요.\n\n포기하려던 찰나, 그러던 중에 오류를 찾아보기로 결정하였어요. Xe 개발자들의 자동화 시스템에서도 해당 오류가 발견되었다는 것을 알게 되었어요. 그들의 저장소에서 일부 패치가 드라이버를 전반적으로 더 안정적으로 만들었다는 것을 발견했죠. 그래서 저는 그들의 브랜치를 가져오기로 결정했어요 (커널 6.10을 위한 drm-next일 것으로 예상됩니다) 그리고 이게 작동하는지 확인해 보기로 했어요.\n\n다시 컴파일한 후에 (그리고 이전의 패치를 다시 적용한 후), 이게... 전혀 작동하지 않았어요. 동일한 메시지로 드라이버가 실패했죠: \"여러 번의 정지가 발생하고 있습니다.\"\n\nBIOS 설정을 좀 만져보고(일부 조작설정이 작동하거나 꺼지는 점을 발견했어요) 저는 또 기억했어요, 해당 커널에 앰페어의 PCIe 버그 수정을 다시 적용하지 않았다는 점을요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그 후에 GDM을 시작했어요...\n\n![image](/assets/img/2024-05-18-AquickupdateonALTRAD8UD-1L2TmakingitworkwithGPU_3.png)\n\n그리고 멈췄어요. 하지만 드라이버가 실험적이라고 생각해서 다시 시도하기로 결정했어요. 이번에는 더 멀리 갔고 OpenGL이 작동 중이라는 멋진 스크린샷을 얻었어요.\n\n![image](/assets/img/2024-05-18-AquickupdateonALTRAD8UD-1L2TmakingitworkwithGPU_4.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n실제로이 업데이트를 쓰는 동안 바로 내 옆에 놓여져 있었고 아직도 고장 나지 않았어요. 빠르지는 않지만 실험용 드라이버에서 기대할 수 있는 것입니다.\n\n이제 아마도 Mesa 빌드 시스템 변경 사항을 upstream하고 몇 가지 버그 보고를 더 제출해야 할 것 같아요...\n\n업데이트: upstreamd해야 할 유일한 변경 사항은 AArch64용 intel-rt를 활성화하는 것뿐이고, 다른 변경 사항들은 Debian이 Mesa를 빌드하는 방식과 관련이 있어서 upstream Mesa와는 무관합니다.\n\n# 결론 대신\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그저 현 상황에 대한 간단한 노트입니다. 저는 정말로 Ampere가 언젠가 PCIe 버그에 대한 해결책을 업스트림으로 올릴 것이고 사람들이 자체 커널 빌드를 유지할 필요가 없게 될 것을 희망합니다. 그것이 아직 완료되지 않았다는 것은 저를 놀라게 합니다.\n\n만약 그 기사를 읽은 이유가 고양이의 사진을 보기 위해서라면, 여기 있습니다:\n\n![cat](/assets/img/2024-05-18-AquickupdateonALTRAD8UD-1L2TmakingitworkwithGPU_5.png)\n","ogImage":{"url":"/assets/img/2024-05-18-AquickupdateonALTRAD8UD-1L2TmakingitworkwithGPU_0.png"},"coverImage":"/assets/img/2024-05-18-AquickupdateonALTRAD8UD-1L2TmakingitworkwithGPU_0.png","tag":["Tech"],"readingTime":8},{"title":"부담갖지 마세요 여러분의 부활절 브런치나 뷔페를 한층 더 특별하게 만들어보세요","description":"","date":"2024-05-18 19:00","slug":"2024-05-18-ElevateYourEasterBrunchorBuffet","content":"\n## DIY/EASTER/FOOD\n\n![Easter Brunch Buffet](/assets/img/2024-05-18-ElevateYourEasterBrunchorBuffet_0.png)\n\n부활절 브런치나 뷔페에 어울리는 센터피스가 필요하신가요? 분명히 다른 이들로부터 다양한 반응을 얻을 수 있는 아이디어를 제공해 드리겠습니다.\n\n이걸 단계별로 보여드릴 테니 걱정 마세요. 빠르고 쉽고 비용 효율적인 방법입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n옛날 존슨 앤 웨일스 조리예술 학교에 다녀갔을 때 졸업식마다 그랜드 뷔페가 열렸어요. 주방 브리게이드 모두가 참여했던 행사였죠.\n\n저는 그런 이벤트 중 하나가 열리던 시기에 가르드 망제 클래스를 수강했어요. 제 강사는 버지니아의 역사적인 챔버린 호텔의 주발실대행 쉐프였죠.\n\n가르드 망제 수업에서는 간식, 파테, 테린, 샤르쿠트리, 그리고 애스픽 등을 가르쳤어요. 애스픽은 제가 가장 싫어했던 것이었고, 졸업 후로는 결코 다시 만들지 않았고 앞으로도 만들지 않을 거예요.\n\n![](/assets/img/2024-05-18-ElevateYourEasterBrunchorBuffet_1.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n셰프가 나에게 장식된 프레처 포, 프랑스 마카롱, 그리고 올 두브르 사이즈 크림 퍼프를 만들어 보라고 시키셨어요.\n\n이 강사님께서는 프레젠테이션에 큰 관심을 가지셨어요. 제가 어깨 너머를 쳐다볼 때마다 땀을 흘리곤 했답니다. 챔버린 호텔은 타이드워터 지역에서 가장 엄선된 품질의 일요일 브런치로 유명했어요.\n\n대부분의 음식은 트레이와 접시에 제공되어 조금 지루하다고 생각했어요.\n\n저렇게 강사님을 감명 시킬 수 있는 방법이 있을까요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이때쯤, 나는 취미로 스테인드 글라스도 만들고 있었어. 내 디저트를 높이는 아이디어는 결혼식 케이크에 사용되는 윌튼 케이크 분리기와 기둥에서 왔어.\n\n나는 손가락 디저트를 유리 탑 위에 배열하고 신선한 꽃과 함께 유리 탑 위에 서고 싶다고 생각했어.\n\n내가 할당된 자리에 내 탑을 만들고 나니, 강사가 다가와 나를 보며 미소를 지었어; 그는 절대 웃지 않았었어. 그는 내가 만든 것에 감명을 받아 전체 그랜드 뷔페의 주요 초점으로 방 중앙에 재조합해달라고 했어.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그는 후에 그 아이디어를 베끼고 Chamberlin의 일요일 브런치에서 사용했어요.\n\n“A”를 받았어요.\n\n지난 몇 년 동안 여러 행사를 위해 이것들을 만들었고, 항상 멋진 평가를 받았어요.\n\n나는 반사 품질이 마음에 들어 유리에서 거울로 바꿨어요. 사실, 거울은 음식 대회에서 자주 사용돼요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n약속한 대로 여기에 당신만의 뷔페 센터피스를 만드는 단계별 가이드가 있어요.\n\n![이미지](/assets/img/2024-05-18-ElevateYourEasterBrunchorBuffet_3.png)\n\n## 첫 번째 단계\n\n바닥 레벨로 20인치 x 24인치의 경사면이 있는 유리 거울을 사용했어요. 지역 홈센터에서 $19.95에 구입했어요. 상단 두 레벨에는 12인치 정사각형 거울을 사용했어요. 한 상자에 여섯 개가 들어있어서 $12뿐이에요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n컵보드에서 네 개의 캔을 꺼내 첫 번째 레벨을 만들어 보세요. 거울의 뒷면에 부드러운 코팅이 스크래치되는 것을 막기 위해 나프킨이나 덕트 테이프를 사용해봐요.\n\n![image](/assets/img/2024-05-18-ElevateYourEasterBrunchorBuffet_4.png)\n\n## 두 번째 단계\n\n이제 수프캔을 숨겨야 해요. 이를 위한 방법은 정말 다양해요. 저는 패스텔 테이블보로 바닥 주변에 펴고 1.99달러짜리 국산에서 사온 데이지꽃을 사용했어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n베이스는 단지 당신의 상상력에 의해서만 제한됩니다.\n\n테이블 위에 베이스 미러를 직접 놓을 수 있지만, 저는 어떤 종류의 장식적 기반으로 작은 높이를 부여하는 것을 선호합니다.\n\n## 세 번째 단계\n\n첫 번째 레벨에 네 개의 기둥으로 tall Weck jars를 사용했습니다. 이들을 적합한 장식물로 채울 수 있습니다. 부활절 달걀, 솔방울과 가을 잎, 꽃, 크리스마스 호랑가시, 선택할 수 있는 것은 끝이 없고 재미있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n현지 달러 상점에는 유리 기둥 및 내부에 넣을 수 있는 다양한 물건들이 많습니다. 와인 잔이 잘 작동합니다.\n\n저는 첫 번째 레벨에는 병을 사용하는 것을 선호하고 상단 레벨에는 와인 잔을 선호합니다. 아래쪽이 무거우면서 위쪽이 가볍고 공기가 많은 것이 대칭적이고 테이퍼링된 룩에 더 잘 맞습니다.\n\n다음 거울 레벨을 4개의 장식된 기둥 위에 놓으세요.\n\n## 단계 네\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-05-18-ElevateYourEasterBrunchorBuffet_5.png\" />\n\n와인 잔 안에 꽃이나 원하는 것을 넣을 수 있어요.\n\n와인 잔 위에 마지막 단계를 추가하세요.\n\n어떤 아기 샤워 행사에서는 유아용 나무 블록을 필라로 붙여서 한쪽에는 \"baby\", 다른 한쪽에는 \"girl\"이라고 썼어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이스터를 위해 나는 맨 위에 튤립 꽃병을 추가했어요. 그러나 최종 상단 장식에 매우 창의적일 수 있어요.\n\n졸업 파티를 위해 프레임된 사진을 사용할 수 있어요. 이 예에서는 우리 아들의 사진, 경조 파티를 위한 커플 사진을 사용할 수도 있어요.\n\n한 번은 5차 감시등을 총괄 지휘관 은퇴 파티의 최종 상단 조각으로 사용했어요. 건전지 작동 티 라이트가 달린 미니어처 모형을 사용했어요.\n\n첫 번째 층에는 여러 번 Wilton 웨딩 케이크 분수기를 사용했어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n지금은 타워가 완성되었으며, 음식만 추가하면 됩니다.\n\n이 타워는 손으로 먹는 음식, 디저트 타워, 치즈 & 크래커, 혹은 샐러미에 대해 훌륭한 작품입니다.\n\n![이미지1](/assets/img/2024-05-18-ElevateYourEasterBrunchorBuffet_6.png)\n\n![이미지2](/assets/img/2024-05-18-ElevateYourEasterBrunchorBuffet_7.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저는 대사관, 상원의원, 그리고 해군 중장들을 위해 이렇게 만들었습니다. 하지만 이것들은 생일 파티, 교회 모임, 소규모 자선 행사, 그리고 집에서의 휴일 행사에서도 즐깁니다.\n\n읽어 주셔서 감사합니다. 여러분에게 조금이나마 아이디어와 영감을 주어 자신만의 타워와 뷔페 센터피스를 만드는 데 도움이 되었으면 좋겠어요.\n\n참배신 요리장군이 하늘에서 저를 내려다보고 계셨으면 좋겠어요. 그분은 저에게 많은 것을 알려 주셨고, 아마 저도 그분께 무언가 가르쳐 드렸을지도 모르겠어요.\n\n![이미지](/assets/img/2024-05-18-ElevateYourEasterBrunchorBuffet_8.png)\n","ogImage":{"url":"/assets/img/2024-05-18-ElevateYourEasterBrunchorBuffet_0.png"},"coverImage":"/assets/img/2024-05-18-ElevateYourEasterBrunchorBuffet_0.png","tag":["Tech"],"readingTime":7}],"page":"93","totalPageCount":113,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":4},"__N_SSG":true}