{"pageProps":{"posts":[{"title":"Firebase로 안드로이드 애플리케이션에서 안전한 SMS 인증 방법","description":"","date":"2024-06-27 19:22","slug":"2024-06-27-SecureSMSVerificationinAndroidApplicationswithFirebase","content":"\n![이미지](/assets/img/2024-06-27-SecureSMSVerificationinAndroidApplicationswithFirebase_0.png)\n\n안녕하세요! 이 기사에서는 안드로이드 애플리케이션에서 Firebase의 SMS 인증 기능을 사용하여 사용자 인증하는 방법을 단계별로 설명하겠습니다. SMS 인증은 사용자의 전화번호를 확인하고 안전한 로그인을 보장하는 효과적인 방법입니다. 이 예에서는 프로젝트를 만들고 필요한 모든 단계를 거칠 것입니다.\n\n# 1. Firebase 프로젝트 만들기\n\n## Firebase 콘솔 설정\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nFirebase 콘솔에 로그인해 주세요:\n\n- Firebase 콘솔로 이동합니다.\n- Google 계정으로 로그인합니다.\n\n## 새 프로젝트 만들기:\n\n- Firebase 콘솔에서 “프로젝트 추가” 버튼을 클릭합니다.\n- 프로젝트 이름을 입력하고 “계속”을 클릭합니다.\n- Google 애널리틱스를 활성화하라는 요청이 표시될 수 있습니다. 원하는 옵션을 선택하고 “계속”을 클릭합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 프로젝트 설정 완료:\n\n- 프로젝트 생성 프로세스가 완료되면 “프로젝트 관리” 버튼을 클릭하여 프로젝트 페이지로 이동합니다.\n- App Check 옵션을 활성화하고 이 섹션에서 앱을 등록합니다. Firebase App Check를 활성화하여 Play Integrity API를 사용하면 앱의 보안을 강화하고 Firebase 서비스에 대한 무단 액세스를 방지할 수 있습니다.\n\n# 2. Firebase에 Android 앱 추가하기\n\nFirebase에 앱 추가하기:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 프로젝트 페이지에서 상단의 \"프로젝트 개요\" 섹션에서 Android 아이콘을 클릭하세요.\n- 패키지 이름 (예: com.ek.firebasesmssample), 앱 별명 및 SHA-1 인증서 지문을 입력해주세요. SHA-1 인증서 지문을 얻으려면 다음 단계를 따라주세요:\n- Android Studio에서 터미널을 열고 다음 명령을 입력하세요:\n\n```js\nkeytool -list -v -keystore ~/.android/debug.keystore -alias androiddebugkey -storepass android -keypass android\n```\n\n- 출력에서 SHA1 값이 인증서 지문입니다.\n- \"앱 등록\" 버튼을 클릭하세요.\n\n## Google 서비스 JSON 파일 다운로드하기:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- google-services.json 파일을 다운로드하여 Android 프로젝트의 앱 디렉토리에 추가해주세요.\n\n## 3. Firebase SDK를 프로젝트에 추가하기\n\nGradle 파일 구성하기:\n\n- 프로젝트 수준의 build.gradle 파일에 다음 라인을 추가해주세요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nclasspath 'com.google.gms:google-services:4.3.3'\n```\n\n다음 라인을 앱 수준의 build.gradle 파일에 추가하세요:\n\n```js\napply plugin: 'com.google.gms.google-services'\n\ndependencies {\n    implementation platform('com.google.firebase:firebase-bom:26.1.0')\n    implementation 'com.google.firebase:firebase-auth'\n    implementation 'com.google.firebase:firebase-analytics'\n}\n```\n\n# 4. Firebase 인증 활성화하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n인증 설정하기:\n\n- Firebase 콘솔의 왼쪽 메뉴에서 \"인증\" 섹션으로 이동합니다.\n- \"로그인 방법\" 탭을 클릭합니다.\n- 전화 번호 로그인 방법을 찾아 \"활성화\"를 클릭합니다.\n- 선택적으로 메시지 템플릿을 사용자 정의할 수 있습니다.\n- \"저장\" 버튼을 클릭합니다.\n\n# 5. 안드로이드 애플리케이션 코딩\n\n## 프로젝트 구조 및 UI 디자인\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우선, 안드로이드 프로젝트를 만들고 필요한 파일을 설정하세요.\n\nactivity_login.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:orientation=\"vertical\"\n    android:gravity=\"center\"\n    android:padding=\"16dp\">\n\n    <TextView\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"SMS 인증을 위한 전화번호를 입력하세요.\"\n        android:textSize=\"12sp\" />\n\n    <com.google.android.material.textfield.TextInputLayout\n        android:id=\"@+id/phone_number_layout\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:layout_marginTop=\"128dp\">\n\n        <EditText\n            android:id=\"@+id/phone_number_input\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"wrap_content\"\n            android:hint=\"전화번호\"\n            android:inputType=\"phone\" />\n    </com.google.android.material.textfield.TextInputLayout>\n\n    <Button\n        android:id=\"@+id/login_button\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:layout_marginTop=\"48dp\"\n        android:paddingVertical=\"12dp\"\n        android:textSize=\"16sp\"\n        android:textColor=\"@color/white\"\n        android:backgroundTint=\"@color/red\"\n        android:text=\"로그인 →\" />\n\n</LinearLayout>\n```\n\nLoginActivity.kt\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 LoginActivity 클래스를 만들고 아래 코드를 추가해주세요:\n\n```js\nimport android.os.Bundle\nimport android.text.Editable\nimport android.text.TextWatcher\nimport android.util.Log\nimport android.widget.Button\nimport android.widget.EditText\nimport android.widget.Toast\nimport androidx.appcompat.app.AppCompatActivity\nimport androidx.core.widget.doAfterTextChanged\nimport com.google.android.material.textfield.TextInputLayout\nimport com.google.firebase.FirebaseApp\nimport com.google.firebase.FirebaseException\nimport com.google.firebase.appcheck.FirebaseAppCheck\nimport com.google.firebase.appcheck.playintegrity.PlayIntegrityAppCheckProviderFactory\nimport com.google.firebase.auth.FirebaseAuth\nimport com.google.firebase.auth.PhoneAuthCredential\nimport com.google.firebase.auth.PhoneAuthProvider\nimport java.util.concurrent.TimeUnit\nimport java.util.regex.Pattern\n\nclass LoginActivity : AppCompatActivity() {\n\n    private lateinit var phoneNumberInput: EditText\n    private lateinit var loginButton: Button\n    private lateinit var phoneNumberLayout: TextInputLayout\n\n    private lateinit var auth: FirebaseAuth\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_login)\n\n        phoneNumberInput = findViewById(R.id.phone_number_input)\n        loginButton = findViewById(R.id.login_button)\n        phoneNumberLayout = findViewById(R.id.phone_number_layout)\n\n        auth = FirebaseAuth.getInstance()\n        FirebaseApp.initializeApp(this)\n        val firebaseAppCheck = FirebaseAppCheck.getInstance()\n        firebaseAppCheck.installAppCheckProviderFactory(\n            PlayIntegrityAppCheckProviderFactory.getInstance()\n        )\n        phoneNumberInput.addTextChangedListener(object : TextWatcher {\n            private var current = \"\"\n            override fun afterTextChanged(s: Editable?) {\n                if (s.toString() != current) {\n                    phoneNumberInput.removeTextChangedListener(this)\n\n                    val cleanString = s.toString().replace(\" \", \"\").replace(\"+90\", \"\")\n                    val formatted = cleanString.chunked(3).joinToString(\" \")\n\n                    if (cleanString.length > 6) {\n                        val part1 = cleanString.substring(0, 3)\n                        val part2 = cleanString.substring(3, 6)\n                        val part3 = cleanString.substring(6)\n                        current = \"+90 $part1 $part2$part3\"\n                    } else {\n                        current = \"+90 $formatted\"\n                    }\n\n                    phoneNumberInput.setText(current)\n                    phoneNumberInput.setSelection(current.length)\n\n                    phoneNumberInput.addTextChangedListener(this)\n                }\n            }\n\n            override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {}\n\n            override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {}\n        })\n\n        loginButton.setOnClickListener {\n            val phoneNumber = phoneNumberInput.text.toString()\n            if (isValidPhoneNumber(phoneNumber)) {\n                startPhoneNumberVerification(phoneNumber)\n            } else {\n                Toast.makeText(this, \"Please enter a valid phone number\", Toast.LENGTH_SHORT).show()\n            }\n        }\n    }\n\n    private fun isValidPhoneNumber(phoneNumber: String): Boolean {\n        val pattern = Pattern.compile(\"^\\\\+?[1-9]\\\\d{1,14}\\$\")\n        return pattern.matcher(phoneNumber.replace(\" \", \"\")).matches()\n    }\n\n    private fun startPhoneNumberVerification(phoneNumber: String) {\n        val callbacks = object : PhoneAuthProvider.OnVerificationStateChangedCallbacks() {\n\n            override fun onVerificationCompleted(credential: PhoneAuthCredential) {\n                // 인증이 성공했을 때 실행되는 콜백입니다.\n                // 여기에서 로그인 작업을 수행할 수 있습니다.\n                signInWithPhoneAuthCredential(credential)\n            }\n\n            override fun onVerificationFailed(e: FirebaseException) {\n                // 인증이 실패했을 때 실행되는 콜백입니다.\n                // 오류 메시지를 표시합니다.\n                Log.e(\"onVerificationFailed\", e.message ?: \"오류가 발생했습니다\")\n            }\n\n            override fun onCodeSent(\n                verificationId: String,\n                token: PhoneAuthProvider.ForceResendingToken\n            ) {\n                Log.e(\"onCodeSent\", \"verificationId: $verificationId\")\n                // 인증 코드가 전송될 때 실행되는 콜백입니다.\n                // 수신한 코드를 사용하여 자격 증명을 생성할 수 있습니다.\n                val credential = PhoneAuthProvider.getCredential(verificationId, \"123456\")\n                signInWithPhoneAuthCredential(credential)\n            }\n        }\n\n        // 핸드폰 번호와 콜백을 사용하여 인증 프로세스 시작\n        PhoneAuthProvider.getInstance().verifyPhoneNumber(\n            phoneNumber, // 핸드폰 번호\n            60, // 시간 제한\n            TimeUnit.SECONDS, // 시간 제한 단위\n            this, // 액티비티 (또는 프래그먼트)\n            callbacks\n        )\n    }\n\n    private fun signInWithPhoneAuthCredential(credential: PhoneAuthCredential) {\n        auth.signInWithCredential(credential)\n            .addOnCompleteListener(this) { task ->\n                if (task.isSuccessful) {\n                    // 로그인 성공\n                    val user = task.result?.user\n                    val uid = user?.uid // 사용자 ID\n                    val phoneNumber = user?.phoneNumber // 핸드폰 번호\n                    val providerId = user?.providerId // 제공자 ID\n\n                    sendUserToBackend(uid)\n                } else {\n                    Log.e(\"signInWithCredential\", \"signInWithCredential:failure\", task.exception)\n                    // 로그인 실패\n                }\n            }\n    }\n\n    private fun sendUserToBackend(uid: String?) {\n        Log.e(\"sendUserToBackend\", \"UID: $uid\")\n        // 이 함수는 사용자의 UID를 백엔드로 전송하는 데 사용할 수 있습니다.\n    }\n}\n```\n\n`startPhoneNumberVerification` 메서드에서 전화번호 확인 프로세스 중 발생하는 이벤트들이 `onVerificationCompleted`, `onVerificationFailed`, `onCodeSent`와 같은 콜백을 사용하여 정의되어 있습니다.\n\n`signInWithPhoneAuthCredential` 메서드는 Firebase 인증을 사용하여 로그인 작업을 수행합니다. 확인이 성공적일 경우, 사용자 정보를 가져와 백엔드로 전송할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Secure SMS Verification in Android Applications with Firebase](/assets/img/2024-06-27-SecureSMSVerificationinAndroidApplicationswithFirebase_1.png)\n\n위 모든 단계를 완료한 후에는 Firebase로부터 SMS를 수신할 것입니다. SMS를 통해 받은 코드를 입력하면 signInWithPhoneAuthCredential 메서드가 이를 확인하고 응용 프로그램 흐름이 계속됩니다.\n\n# 결론\n\n본 문서에서 안내한 단계를 따라 Android 애플리케이션에서 Firebase를 사용하여 안전한 SMS 확인을 구현할 수 있게 됩니다. 이 방법은 사용자 인증의 보안성을 향상시키는데 그치지 않고 사용자들에게 원활한 로그인 경험을 제공합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nSMS 인증을 구현하면 무단 액세스가 크게 줄어들고, 앱에 로그인할 수 있는 것은 정당한 사용자뿐이라는 것을 보장할 수 있습니다. 또한 Firebase의 강력한 기능과 쉬운 통합을 통해, 인증 및 보안을 관리하는 강력한 도구로 활용할 수 있습니다.\n\n# 참고 자료\n\n- Firebase 문서\n- Google Play 무결성 API\n- SHA-1 인증서 지문\n- Firebase용 Gradle 구성\n\n참고: 개발 단계에서 Google이 자동으로 reCaptcha 서비스를 활성화할 수 있으며, SMS 인증을 수행하는 동안 reCaptcha 화면을 볼 수 있습니다. 주제에서 벗어나지 않도록 자세히 다루지 않았습니다. 더 자세한 정보는 여기에서 확인할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNote-2: 현재 Firebase를 통해 보내는 메시지 템플릿을 사용자 정의하는 것은 불가능합니다. 사용자 정의 메시지 유형을 사용하려면 다른 공급업체를 사용해야 합니다.\n\n이 기사가 안드로이드 애플리케이션에서 Firebase를 사용하여 SMS 인증을 구현하는 데 도움이 되기를 바랍니다. 궁금한 점이 있거나 추가 지원이 필요하면 아래에 댓글을 남기세요.\n\n![image](https://miro.medium.com/v2/resize:fit:1200/0*vvlpXIMRKoxTUlrJ.gif)\n","ogImage":{"url":"/assets/img/2024-06-27-SecureSMSVerificationinAndroidApplicationswithFirebase_0.png"},"coverImage":"/assets/img/2024-06-27-SecureSMSVerificationinAndroidApplicationswithFirebase_0.png","tag":["Tech"],"readingTime":14},{"title":"Swift를 사용한 iOS 클린 아키텍처 구현 방법","description":"","date":"2024-06-27 19:21","slug":"2024-06-27-CleanArchitectureiniOSwithSwift","content":"\n\n# 클린 아키텍처 소개\n\n클린 아키텍처는 로버트 C. 마틴 (아저씨 밥)이 개발한 설계 패턴으로, 소프트웨어 애플리케이션의 테스트 가능성, 유지 관리성, 확장성을 향상시키고 각 요소 간 명확한 역할 분리를 제공하는 것을 목표로 합니다. 코드를 서로 다른 층으로 구성하여 서로의 의존성을 줄이고 비즈니스 로직이 사용자 인터페이스나 데이터 액세스와 같은 외부 요소에 독립적으로 유지되도록 합니다.\n\n# 클린 아키텍처의 층\n\n1. 엔티티: 외부 변경에 독립적인 핵심 비즈니스 객체와 규칙을 표현합니다.\n2. 유스 케이스 (상호작용자): 애플리케이션의 비즈니스 로직을 포함하며, 엔티티로부터 데이터 흐름을 조율합니다.\n3. 인터페이스 어댑터: 유스 케이스에서 사용자 인터페이스나 다른 시스템이 이해할 수 있는 형식으로 데이터를 변환합니다.\n4. 프레임워크 및 드라이버: 외부 라이브러리, UI 구성 요소, 데이터베이스 및 기타 시스템이 포함됩니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 예제 사용 사례\n\n간단한 예제를 살펴보겠습니다. 노트 앱이 있습니다. 새로운 노트를 추가하는 사용 사례에 중점을 둘 것입니다.\n\n# 엔티티\n\n```js\nstruct Note {\n    let id: UUID\n    let title: String\n    let content: String\n}\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 사용 사례\n\n```js\nprotocol AddNoteUseCase {\n    func execute(note: Note)\n}\n\nclass AddNoteInteractor: AddNoteUseCase {\n    private let noteRepository: NoteRepository\n\n    init(noteRepository: NoteRepository) {\n        self.noteRepository = noteRepository\n    }\n\n    func execute(note: Note) {\n        noteRepository.add(note: note)\n    }\n}\n```\n\n# 인터페이스 어댑터\n\n```js\nprotocol NoteRepository {\n    func add(note: Note)\n}\n\nclass NoteRepositoryImpl: NoteRepository {\n    private var notes = [Note]()\n    \n    func add(note: Note) {\n        notes.append(note)\n    }\n}\n```  \n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# Frameworks and Drivers\n\n```js\nclass NotesViewController: UIViewController {\n    private let addNoteUseCase: AddNoteUseCase\n    \n    init(addNoteUseCase: AddNoteUseCase) {\n        self.addNoteUseCase = addNoteUseCase\n        super.init(nibName: nil, bundle: nil)\n    }\n    \n    required init?(coder: NSCoder) {\n        fatalError(\"init(coder:) has not been implemented\")\n    }\n    \n    func onAddNoteButtonTapped() {\n        let note = Note(\n            id: UUID(),\n            title: \"Sample Note\",\n            content: \"This is a sample note.\"\n        )\n        addNoteUseCase.execute(note: note)\n    }\n}\n```\n\n# Advantages of Clean Architecture\n\n1. Separation of Concerns: 각 계층은 명확한 역할을 하므로 코드의 복잡성이 줄어듭니다.\n2. Testability: 비즈니스 로직은 사용자 인터페이스나 데이터 계층과 독립적으로 테스트할 수 있습니다.\n3. Maintainability: 한 계층의 변경이 다른 계층에 미치는 영향이 최소화되어 코드베이스를 유지보수하기 쉽게 만듭니다.\n4. Scalability: 아키텍처는 애플리케이션의 성장과 복잡성을 잘 지원합니다.\n5. Flexibility: 비즈니스 로직에 영향을 미치지 않고 구현을 쉽게 교체할 수 있습니다(예: 데이터베이스나 UI 프레임워크 변경).\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 클린 아키텍처의 단점\n\n1. 초기 복잡성: 아키텍처를 설정하는 데 추가적인 노력과 이해가 필요해 소규모 프로젝트에는 압도적일 수 있습니다.\n2. 오버헤드: 간단한 애플리케이션의 경우, 추가된 레이어가 불필요한 오버헤드를 발생시킬 수 있습니다.\n3. 학습 곡선: 개발자는 클린 아키텍처의 원칙과 실천 방법을 이해해야 하며, 이는 학습 곡선이 필요할 수 있습니다.\n\n# 클린 아키텍처 구현을 위한 최상의 실천 방법\n\n1. 천천히 시작하기: 특히 기존 코드베이스를 리팩토링할 경우 클린 아키텍처 원칙을 점진적으로 도입하세요.\n2. SOLID 원칙 준수: 디자인이 클린 아키텍처를 보완하는 SOLID 원칙을 준수하도록 확인하세요.\n3. 의존성 주입 사용: 의존성을 주입하여 레이어 간 결합을 줄입니다.\n4. UI 레이어를 얇게 유지: UI는 데이터 표시 및 사용자 상호작용만 처리하도록 하고 최소한의 로직을 포함시키세요.\n5. 테스트 작성: 클린 아키텍처의 테스트 용이성을 활용하여 유증분 및 엔티티에 대한 단위 테스트를 작성하세요.\n6. 문서화: 새로운 개발자가 아키텍처를 이해하는 데 도움이 될 명확한 문서를 유지하세요.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 결론\n\nClean Architecture은 iOS 애플리케이션에서 코드를 체계적으로 구성하는 견고한 프레임워크를 제공하여 관심의 분리, 테스트 가능성 및 유지 관리성을 촉진합니다. 일부 복잡성을 도입하지만 장기적인 이점은 확장 가능하고 유지 보수 가능한 애플리케이션을 구축하기 위한 가치 있는 접근법입니다. 최고의 실천 방법을 따르고 트레이드오프를 이해하여 개발자들은 Clean Architecture를 효과적으로 활용하여 Swift로 고품질 iOS 앱을 만들 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-27-CleanArchitectureiniOSwithSwift_0.png"},"coverImage":"/assets/img/2024-06-27-CleanArchitectureiniOSwithSwift_0.png","tag":["Tech"],"readingTime":5},{"title":"DatabaseSample 온라인 라이브러리를 사용한 데이터베이스 생성 및 원하는 쿼리 언어와 함께 코드 자동 생성으로 importexport 작업 수행 방법","description":"","date":"2024-06-27 19:20","slug":"2024-06-27-CreatingadatabasewiththedesiredquerylanguagewiththeDatabaseSampleonlinelibraryperformingimportexportoperationsbyautomaticallygeneratingthecodesofthecreateddatabase","content":"\n\n<img src=\"/assets/img/2024-06-27-CreatingadatabasewiththedesiredquerylanguagewiththeDatabaseSampleonlinelibraryperformingimportexportoperationsbyautomaticallygeneratingthecodesofthecreateddatabase_0.png\" />\n\n# DATABASESAMPLE ONLINE LIBRARY란?\n\nDatabaseSample Online Library는 다양한 오픈 소스 데이터베이스 샘플을 제공하는 온라인 라이브러리입니다. 우리의 목표는 개발자, 연구자 및 데이터베이스 관리 및 분석에 관심 있는 사람들을 위한 리소스를 제공하는 것입니다. 동시에, 샌드박스를 통해 우리의 데이터베이스를 설계함으로써 원하는만큼의 테이블을 생성할 수 있으며, 이러한 테이블을 자동으로 생성된 원하는 쿼리 언어로 가져오고 내보낼 수 있습니다. 또한 인공지능 지원 자동 데이터베이스 생성 옵션이 있습니다. 우리가 원하는 데이터베이스에 대해 인공지능에 세부 설명을 제공함으로써, 인공지능은 해당 테이블과 함께 원하는 데이터베이스를 생성하여 제시할 수 있습니다. 페이지 상단의 검색 창을 사용하여 특정 데이터베이스 샘플을 이름, 유형 또는 키워드로 검색할 수 있습니다. 또한 관련 샘플을 발견하기 위해 데이터베이스 페이지를 탐색할 수 있습니다.\n\n<img src=\"/assets/img/2024-06-27-CreatingadatabasewiththedesiredquerylanguagewiththeDatabaseSampleonlinelibraryperformingimportexportoperationsbyautomaticallygeneratingthecodesofthecreateddatabase_1.png\" />\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 온라인으로 SANDBOX를 통해 새로운 데이터베이스를 만드는 단계:\n\n![이미지](/assets/img/2024-06-27-CreatingadatabasewiththedesiredquerylanguagewiththeDatabaseSampleonlinelibraryperformingimportexportoperationsbyautomaticallygeneratingthecodesofthecreateddatabase_2.png)\n\nDatabaseSample를 통해 새로운 데이터베이스를 만들려면 먼저 오른쪽 상단의 시작하기 탭을 클릭하십시오. 그럼 SANDBOX 페이지로 리디렉션됩니다. SANDBOX는 무엇인지 설명한다면, 사용자가 가상 환경에서 자체 데이터베이스를 안전하게 만들고 보관할 수 있도록 합니다. 가상화된 데이터베이스는 일반적으로 공개되지 않습니다. 사용자별로 지정됩니다. 사용자에게 격리된 환경을 제공합니다. 일반적인 정의에 따르면, SANDBOX 페이지는 샘플 데이터범이 나열되고, 데이터베이스를 가져오고, 새 데이터베이스를 만드는 섹션입니다. 새 데이터베이스는 '새 데이터베이스' 옵션을 클릭하여 만들 수 있습니다. 이를 통해 쿼리를 실행하고 데이터베이스 작업을 테스트하며, 로컬 데이터베이스 인스턴스를 설정할 필요 없이 데이터를 살펴볼 수 있습니다.\n\n원하는 쿼리 언어로 데이터베이스 코드를 작성하고, 데이터베이스가 자동으로 생성됩니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-06-27-CreatingadatabasewiththedesiredquerylanguagewiththeDatabaseSampleonlinelibraryperformingimportexportoperationsbyautomaticallygeneratingthecodesofthecreateddatabase_3.png\" />\n\n새로운 데이터베이스를 만들려면 데이터베이스 이름을 왼쪽 상단에 입력하세요.\n\n<img src=\"/assets/img/2024-06-27-CreatingadatabasewiththedesiredquerylanguagewiththeDatabaseSampleonlinelibraryperformingimportexportoperationsbyautomaticallygeneratingthecodesofthecreateddatabase_4.png\" />\n\n# 데이터베이스 테이블 추가하기:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 관계형 데이터베이스 테이블이 나열된 섹션입니다. 추가된 테이블은 쿼리 언어(DBML, PostgreSQL, MYSQL 및 MSSQL)를 사용하여 자동 코드 생성기로 내보내기 탭에서 사용할 수 있습니다. 그리고 원하는 데이터베이스 쿼리 언어로 코드를 작성하여 테이블을 자동으로 생성할 수 있습니다. 삭제할 테이블도 Clear 탭을 사용해 삭제할 수 있습니다. 테이블을 저장하는 옵션이 있습니다. 새 테이블을 만들려면 \"Add table\" 탭을 클릭하세요. 그런 다음 하나 이상의 필드를 추가하려면 \"Add field after\" 옵션을 클릭할 수 있습니다. 추가할 필드는 중요도 순서에 따라 \"Move up\" 또는 \"Move Down\"으로 정렬할 수 있습니다. 관련 필드는 \"Remove field\" 옵션으로 삭제할 수 있습니다. 테이블을 삭제하려면 \"Delete table\"을 사용하세요. \"Commit\"을 클릭한 후 테이블을 생성합니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![Image 8](/assets/img/2024-06-27-CreatingadatabasewiththedesiredquerylanguagewiththeDatabaseSampleonlinelibraryperformingimportexportoperationsbyautomaticallygeneratingthecodesofthecreateddatabase_8.png)\n\n![Image 9](/assets/img/2024-06-27-CreatingadatabasewiththedesiredquerylanguagewiththeDatabaseSampleonlinelibraryperformingimportexportoperationsbyautomaticallygeneratingthecodesofthecreateddatabase_9.png)\n\n![Image 10](/assets/img/2024-06-27-CreatingadatabasewiththedesiredquerylanguagewiththeDatabaseSampleonlinelibraryperformingimportexportoperationsbyautomaticallygeneratingthecodesofthecreateddatabase_10.png)\n\nTo import any table into the database, we can first create our own tables automatically in our virtual environment by writing the relevant codes in any query language. We can import on 4 query languages as shown in the picture below.\n\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![Opening Image 1](/assets/img/2024-06-27-CreatingadatabasewiththedesiredquerylanguagewiththeDatabaseSampleonlinelibraryperformingimportexportoperationsbyautomaticallygeneratingthecodesofthecreateddatabase_11.png)\n\n![Opening Image 2](/assets/img/2024-06-27-CreatingadatabasewiththedesiredquerylanguagewiththeDatabaseSampleonlinelibraryperformingimportexportoperationsbyautomaticallygeneratingthecodesofthecreateddatabase_12.png)\n\n![Opening Image 3](/assets/img/2024-06-27-CreatingadatabasewiththedesiredquerylanguagewiththeDatabaseSampleonlinelibraryperformingimportexportoperationsbyautomaticallygeneratingthecodesofthecreateddatabase_13.png)\n\n# OPEN SOURCE DATABASE EXAMPLES:\n\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-06-27-CreatingadatabasewiththedesiredquerylanguagewiththeDatabaseSampleonlinelibraryperformingimportexportoperationsbyautomaticallygeneratingthecodesofthecreateddatabase_14.png\" />\n\n<img src=\"/assets/img/2024-06-27-CreatingadatabasewiththedesiredquerylanguagewiththeDatabaseSampleonlinelibraryperformingimportexportoperationsbyautomaticallygeneratingthecodesofthecreateddatabase_15.png\" />\n\n여기에는 데이터베이스 샘플 온라인 라이브러리에서 유용할 만한 여러 유형의 오픈 소스 데이터베이스 예시가 있습니다. 데이터베이스를 원하는 대로 변경하거나 프로젝트에 정확히 적용할 수 있습니다. 더 많은 오픈 소스 데이터베이스 예시를 보려면 https://databasesample.com/databases를 방문해주세요.\n\n이 글에서는 DatabaseSample 온라인 라이브러리에 관한 많은 정보를 전달하려고 노력했습니다. 읽어 주셔서 감사합니다. 만약 이 기사가 유용하다고 생각된다면 아래의 박수 버튼을 눌러보시는 건 어떨까요? 😉\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 자료:","ogImage":{"url":"/assets/img/2024-06-27-CreatingadatabasewiththedesiredquerylanguagewiththeDatabaseSampleonlinelibraryperformingimportexportoperationsbyautomaticallygeneratingthecodesofthecreateddatabase_0.png"},"coverImage":"/assets/img/2024-06-27-CreatingadatabasewiththedesiredquerylanguagewiththeDatabaseSampleonlinelibraryperformingimportexportoperationsbyautomaticallygeneratingthecodesofthecreateddatabase_0.png","tag":["Tech"],"readingTime":7},{"title":"Ruby on Rails에서 다형성 연관 관계를 사용하는 방법","description":"","date":"2024-06-27 19:17","slug":"2024-06-27-PolymorphicAssociationsinRubyonRails","content":"\n\n폴리모픽 연관은 루비 온 레일즈의 강력한 기능 중 하나로, 한 모델이 하나 이상의 다른 모델에 단일 연관을 사용하여 속할 수 있게 합니다. 이는 단일 모델이 다른 여러 모델과 폴리모픽 인터페이스를 통해 연관될 수 있음을 의미합니다. 이 기능은 특히 한 모델이 여러 유형의 엔터티에 속할 수 있는 경우에 유용합니다.\n\n## 폴리모픽 연관이란 무엇인가요?\n\n폴리모픽 연관은 단일 연관을 사용하여 모델이 여러 다른 모델을 참조할 수 있게 합니다. 예를 들어, Comment 모델이 Post 모델 또는 Photo 모델에 속할 수 있는 시나리오를 고려해보세요. 각 모델에 대해 별도의 연관을 생성하는 대신, 폴리모픽 연관을 사용하여 이를 달성할 수 있습니다.\n\n다음은 루비 온 레일즈에서 폴리모픽 연관을 정의하는 방법입니다:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 모델 생성하기\n\n먼저 필요한 모델을 생성하세요. 이 예시에서는 Post, Photo, 그리고 Comment 모델을 만들겠습니다.\n\n```js\nrails generate model Post title:string body:text\nrails generate model Photo title:string url:string\nrails generate model Comment body:text commentable:references{polymorphic}\n```\n\n2. 관계 정의하기\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음에는 모델에서 연관 관계를 정의하세요. Comment 모델에서는 commentable이라는 다형 엔티티에 속한다고 지정하십시오.\n\n```ruby\n# app/models/comment.rb\nclass Comment < ApplicationRecord\n  belongs_to :commentable, polymorphic: true\nend\n```\n\nPost 및 Photo 모델에서 다형 관계를 통해 많은 comments를 가지고 있다고 지정하세요.\n\n```ruby\n# app/models/post.rb\nclass Post < ApplicationRecord\n  has_many :comments, as: :commentable\nend\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```ruby\n# app/models/photo.rb\nclass Photo < ApplicationRecord\n  has_many :comments, as: :commentable\nend\n```\n\n3. 데이터베이스 마이그레이션\n\n데이터베이스 스키마를 업데이트하려면 마이그레이션을 실행하세요.\n\n```shell\nrails db:migrate\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음은 다형성 연관을 사용하는 방법을 안내합니다. 이제 이를 애플리케이션에서 사용할 수 있습니다. 예시를 살펴보겠습니다:\n\n- 포스트에 댓글 생성하기:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\npost = Post.create(title: '내 글', body: '이것이 글의 내용입니다.')\ncomment = post.comments.create(body: '이것은 글에 대한 댓글입니다.')\n```\n\n- 사진에 댓글 작성하기:\n\n```js\nphoto = Photo.create(title: '내 사진', url: 'http://example.com/photo.jpg')\ncomment = photo.comments.create(body: '이것은 사진에 대한 댓글입니다.')\n```\n\n- 댓글 가져오기:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n특정 게시물이나 사진에 대한 댓글을 가져올 수 있어요:\n\n```js\npost.comments # 게시물에 대한 모든 댓글을 반환합니다\nphoto.comments # 사진에 대한 모든 댓글을 반환합니다\n```\n\n- 댓글 가능한 객체에 접근하기:\n\n댓글에서 부모 객체(게시물이나 사진)에도 접근할 수 있어요.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\ncomment = Comment.first\ncomment.commentable # 댓글과 연관된 게시물 또는 사진을 반환합니다\n```\n\n## 다형성 연관의 장점\n\n- 유연성: 다형성 연관은 단일 모델이 여러 다른 모델에 속할 수 있도록하여 유연성을 제공합니다. 이로 인해 여러 연관이 필요한 것을 줄이고 코드베이스를 간단하게 만듭니다.\n- 중복 감소: 단일 연관을 사용함으로써 중복되는 코드와 데이터베이스 열을 피할 수 있어서 더 깔끔하고 유지보수가 쉬운 코드베이스를 얻을 수 있습니다.\n- 유지보수가 쉬움: 관리해야 할 연관이 적어지면 코드베이스를 유지보수하고 업데이트하는 일이 더 쉬워집니다.\n\n## 결론\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n루비 온 레일스의 다형성 연관은 코드베이스를 단순화하고 하나 이상의 유형의 엔티티에 속할 수 있는 모델 처리 시 더 큰 유연성을 제공할 수 있는 강력한 기능입니다. 이 글에서 안내된 단계를 따라가면 레일스 애플리케이션에서 다형성 연관을 효과적으로 구현하고 이점을 활용할 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-27-PolymorphicAssociationsinRubyonRails_0.png"},"coverImage":"/assets/img/2024-06-27-PolymorphicAssociationsinRubyonRails_0.png","tag":["Tech"],"readingTime":5},{"title":"제어문을 더 스마트하게 if-else를 피하는 고급 기법과 대안 ","description":"","date":"2024-06-27 19:16","slug":"2024-06-27-Avoidingif-elseAdvancedApproachesandAlternatives","content":"\n\n<img src=\"/assets/img/2024-06-27-Avoidingif-elseAdvancedApproachesandAlternatives_0.png\" />\n\n대부분의 개발자들은 다양한 상황에 대비하기 위해 if-else 문을 사용합니다. 그럼에도 불구하고, 추가적인 비즈니스 요구 사항을 이러한 연쇄에 넣으면 코드를 필요 이상으로 복잡하게 만들 수도 있고 오류가 발생할 수 있습니다. 우리는 시스템의 견고성을 보장할 뿐만 아니라 예상치 못한 상황에서도 쉽게 업데이트할 수 있도록 솔루션을 만들겠다는 것이 좋습니다. 이렇게 하면 우리의 코드는 앞으로 우리를 위해 적합하고 쉽게 적응할 수 있을 것입니다.\n\n이 글에서는 Java를 사용하여 간단한 계산기에서 연산을 처리하는 다양한 방법을 탐색할 것입니다. 우리의 코드에서 수학 연산(덧셈, 뺄셈, 곱셈, 나눗셈)의 처리를 개선하는 것이 목표입니다. 운영 유형과 두 피연산자를 포함하는 요청을 받는 계산기 예제를 사용하여 if-else, switch, 전략 패턴과 같은 여러 접근 방식을 분석하고 구현해볼 것입니다. 각 방법의 개념과 이점을 설명하는 데 중점을 둘 것입니다.\n\n## 요청 구조\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n먼저, 서로 다른 접근 방식을 보여주기 위해 사용될 요청 구조를 정의해 봅시다.\n\n```java\npublic class CalculationRequest {\n private final Operation operation;\n private final int first;\n private final int second;\n\n // 생성자, 게터, 세터\n}\n\nenum Operation{\n  ADD,\n  SUBTRACTION,\n  DIVISION,\n  MULTIPLICATION;  \n}\n```\n\n# If-Else 문\n\nIf-else 문은 프로그래밍에서 조건을 처리하는 가장 간단하고 널리 사용되는 구성 중 하나입니다. 이들은 특정 조건이 충족되었는지에 따라 특정 코드 블록을 실행할 수 있도록 합니다. 계산기의 맥락에서, if-else 문은 덧셈, 뺄셈, 곱셈 및 나눗셈과 같은 다양한 작업을 처리하는 데 사용될 수 있습니다. 다음 예제는 이러한 작업을 수행하기 위해 if-else 문을 사용하는 방법을 보여줍니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\npublic static Integer calculate(CalculationRequest request) {\n var first = request.getFirst();\n var second = request.getSecond();\n var operation = request.getOperation();\n \nif (Operation.ADD.equals(operation)) {\n   return first + second;\n } else if (Operation.SUBTRACTION.equals(operation)) {\n   return first - second;\n } else if (Operation.DIVISION.equals(operation)) {\n   if (second == 0) {\n     throw new IllegalArgumentException(\"Can't be zero\");\n   }\n   return first / second;\n } else if (Operation.MULTIPLICATION.equals(operation)) {\n   return first * second;\n } else {\n   throw new IllegalStateException(\"Operation not found\");\n }\n}\n```\n\n장점:\n\n- 단숨함: 이해하고 구현하기 쉽습니다.\n- 명확함: 각 조건에서 무슨 일이 벌어지는지 명확히 보여줍니다.\n\n단점:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 유지보수: 로직을 변경하려면 여러 곳에서 수정해야 하므로 오류 발생 가능성이 높아집니다. 예를 들어, 새로운 작업이 추가된다면 if-else 체인에 다른 조건을 추가해야 하므로 조건을 놓칠 가능성이 커집니다. 다양한 곳에서의 변경 사항은 코드의 디버깅과 테스트를 복잡하게 만듭니다.\n- 확장성: 새로운 작업을 추가하려면 기존 코드를 수정해야 하므로 SOLID의 개방/폐쇄 원칙(OCP)을 위반합니다. 각각의 새로운 조건은 기존 코드를 수정해야 하므로 유연성이 줄어들고 변경에 견고하지 못해집니다. 이는 장기적으로 기술적 부채가 증가하고 코드 품질이 저하될 수 있습니다.\n\n# Switch 문\n\n일부 경우에는 if-else 체인 대비 switch 문이 더 가독성이 좋고 편리할 수 있습니다. 코드를 더 잘 구조화할 수 있으며 긴 조건 체인을 피할 수 있습니다. switch 문을 사용하는 것을 고려해 봅시다.\n\n```js\npublic static Integer calculate(CalculationRequest request) {\n var first = request.getFirst();\n var second = request.getSecond();\n var operation = request.getOperation();\n\nreturn switch (operation) {\n   case ADD -> first + second;\n   case SUBTRACTION -> first - second;\n   case DIVISION -> {\n       if (second == 0) {\n       throw new IllegalArgumentException(\"Can't be zero\");\n     }\n     yield first / second;\n   }\n   case MULTIPLICATION -> first * second;\n };\n}\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n장점:\n\n- 가독성: 긴 if-else 체인과 비교하여 구조화된 형태로 코드가 되어 더 조밀하고 쉽게 읽을 수 있습니다.\n- 간소화: 서로 다른 경우들을 명확히 분리하여 코드를 더 깔끔하게 만듭니다.\n\n단점:\n\n- 확장성: if-else와 마찬가지로 새로운 작업을 추가하려면 기존 코드를 변경해야 하므로 SOLID 원칙 중 개방/폐쇄 원칙을 위반합니다.\n- 유연성: switch 문은 다른 방법보다 유연성이 떨어질 수 있습니다. 예를 들어 복잡한 논리나 상태를 쉽게 통합하지 못할 수 있습니다. 이는 더 복잡한 처리가 필요한 고급 사용 사례에 적합하지 않게 만듭니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 전략 패턴\n\n전략 패턴은 알고리즘 패밀리를 정의하고 각각을 캡슐화하여 교체가 가능하도록 하는 것을 허용합니다. 이를 통해 클라이언트는 코드를 변경하지 않고 다른 알고리즘을 사용할 수 있습니다. 계산기의 경우, 각 연산(덧셈, 뺄셈, 곱셈, 나눗셈)은 별도의 전략으로 표현될 수 있습니다. 이는 새로운 연산을 기존 코드를 변경하지 않고 추가할 수 있어 확장성과 유지보수성을 향상시킵니다.\n\n장점:\n\n- 확장성: 기존 코드를 변경하지 않고 새로운 전략을 쉽게 추가할 수 있습니다. 이는 미래에 지원이나 추가되어야 하는 새 기능을 처리해야 하는 상황에서 특히 유용합니다.\n- SOLID 지원: 이 패턴은 단일 책임 원칙(SRP)을 지원합니다. 각 전략은 특정 연산에 대해 책임이 있습니다. 또한 개방/폐쇄 원칙(OCP)을 지원하며 새 전략을 추가할 때 기존 클래스를 변경하지 않아도 됩니다.\n- 유연성: 알고리즘은 적절한 전략을 대체하여 런타임에 쉽게 변경할 수 있습니다. 이로써 시스템이 더 유연하고 변화하는 요구 사항에 적응할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n단점:\n- 복잡성: 여러 전략을 구현할 때 코드에 추가적인 복잡성을 더할 수 있습니다. 클래스 수가 증가하면 프로젝트 관리가 어려워질 수 있습니다.\n\n다양한 구현 옵션을 살펴보겠습니다:\n\n## Enum\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 예시에서는 추상 apply 메소드를 가진 Operation enum을 만듭니다. 각 enum 요소는 이 메소드의 구현에 대응합니다. 이를 통해 각 작업의 로직을 별도의 열거 요소로 캡슐화하여 코드를 보다 구조화되고 유지보수 가능하게 만듭니다.\n\n```java\npublic enum Operation {\n    ADD {\n        @Override\n        Integer apply(int first, int second) {\n            return first + second;\n        }\n    },\n    SUBTRACTION {\n        @Override\n        Integer apply(int first, int second) {\n            return first - second;\n        }\n    },\n    DIVISION {\n        @Override\n        Integer apply(int first, int second) {\n            if (second == 0) {\n                throw new IllegalArgumentException(\"Can't be zero\");\n            }\n            return first / second;\n        }\n    },\n    MULTIPLICATION {\n        @Override\n        Integer apply(int first, int second) {\n            return first * second;\n        }\n    };\n\n  abstract Integer apply(int first, int second);\n}\n```\n\n사용법:\n\n```java\npublic static Integer calculate(CalculationRequest request) {\n    var first = request.getFirst();\n    var second = request.getSecond();\n    var operation = request.getOperation();\n\n    return operation.apply(first, second);\n}\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 객체 지도\n\nOperationStrategy 인터페이스는 각 작업에 구현되어야 하는 apply 메서드를 정의하여 모든 작업에 대한 단일 계약을 생성하고, 새로운 전략을 간편하게 추가할 수 있도록 합니다.\n\n```js\npublic interface OperationStrategy { \n Integer apply(int first, int second); \n}\n```\n\n각 작업은 OperationStrategy 인터페이스를 구현하는 별도의 클래스로 구현됩니다. 각 클래스는 해당 작업을 수행하기 위해 apply 메서드를 구현합니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```java\nclass AddOperationStrategy implements OperationStrategy {\n    @Override\n    public Integer apply(int first, int second) {\n        return first + second;\n    }\n}\n\nclass SubtractionOperationStrategy implements OperationStrategy {\n    @Override\n    public Integer apply(int first, int second) {\n        return first - second;\n    }\n}\n\nclass DivisionOperationStrategy implements OperationStrategy {\n    @Override\n    public Integer apply(int first, int second) {\n        if (second == 0) {\n            throw new IllegalArgumentException(\"Can't be zero\");\n        }\n        return first / second;\n    }\n}\n\nclass MultiplicationOperationStrategy implements OperationStrategy {\n    @Override\n    public Integer apply(int first, int second) {\n        return first * second;\n    }\n}\n```\n\nSTRATEGY_OBJECT_MAP이라는 맵을 만들어 Operation 열거형의 값들을 키로, 대응하는 OperationStrategy 구현체들을 값으로 가지게 했습니다. 이를 통해 각 연산에 필요한 전략을 빠르게 찾아서 사용할 수 있습니다.\n\n```java\npublic static final Map<Operation, OperationStrategy> STRATEGY_OBJECT_MAP =\n            Map.ofEntries(\n                    Map.entry(Operation.ADD, new AddOperationStrategy()),\n                    Map.entry(Operation.SUBTRACTION, new SubtractionOperationStrategy()),\n                    Map.entry(Operation.DIVISION, new DivisionOperationStrategy()),\n                    Map.entry(Operation.MULTIPLICATION, new MultiplicationOperationStrategy())\n            );\n```\n\n이 메소드는 맵으로부터 필요한 전략을 찾아 apply 메소드를 호출하여 연산을 수행합니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\npublic static Integer calculate(CalculationRequest request) {\n    var first = request.first();\n    var second = request.second();\n    var operation = request.operation();\n\n    return STRATEGY_OBJECT_MAP.get(operation).apply(first, second);\n}\n```\n\n## 함수 맵\n\n이 방법은 각 연산을 위한 함수형 인터페이스를 사용하고 키는 연산이고 값은 함수인 맵을 생성합니다. 이를 통해 각 전략에 대해 별도의 클래스를 생성할 필요없이 코드를 더 간단하고 조밀하게 만들 수 있습니다.\n\n```js\npublic static final Map<Operation, BiFunction<Integer, Integer, Integer>> STRATEGY_FUNCTION_MAP;\n\nstatic {\n    STRATEGY_FUNCTION_MAP = Map.ofEntries(\n        Map.entry(Operation.ADD, (first, second) -> first + second),\n        Map.entry(Operation.SUBTRACTION, (first, second) -> first - second),\n        Map.entry(Operation.DIVISION, (first, second) -> {\n            if (second == 0) {\n                throw new IllegalArgumentException(\"Can't be zero\");\n            }\n            return first / second;\n        }),\n        Map.entry(Operation.MULTIPLICATION, (first, second) -> first * second)\n    );\n}\npublic static Integer calculate(CalculationRequest request) {\n    var first = request.getFirst();\n    var second = request.getSecond();\n    var operation = request.getOperation();\n    \n    return STRATEGY_FUNCTION_MAP.get(operation).apply(first, second);\n}\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n함수 맵을 사용하는 것은 각각 별도의 클래스를 만들지 않고 일련의 작업을 빠르고 쉽게 구현해야 할 때 좋은 선택입니다. 그러나 더 복잡한 시나리오의 경우 객체 전략이 더 적합합니다.\n\n# 결론\n\n각 접근 방식에는 장단점이 있습니다. if-else 및 switch 문은 간단하고 사용하기 쉽지만 조건이 증가함에 따라 관리하기 어려워집니다. 새로운 작업을 추가할 때 기존 코드를 변경하지 않고 처리해 주는 모든 작업이 어렵습니다.\n\n반면에 전략 패턴은 작업을 처리하는 더 효율적이고 유연한 방식을 제공합니다. SOLID 원칙을 따르므로 기존 코드를 방해하지 않고 새로운 작업을 손쉽게 도입할 수 있습니다. 이는 유지보수 및 확장이 용이한 코드로 이어지며 새로운 비즈니스 요구에 쉽게 적응할 수 있습니다. 처음에는 약간 복잡해 보일 수 있지만, 강력하고 유연하며 확장 가능한 코드 기반에서 얻는 이점을 발견하게 되어 그가 그것이 그만한 가치가 있다는 것을 알게 될 것입니다.","ogImage":{"url":"/assets/img/2024-06-27-Avoidingif-elseAdvancedApproachesandAlternatives_0.png"},"coverImage":"/assets/img/2024-06-27-Avoidingif-elseAdvancedApproachesandAlternatives_0.png","tag":["Tech"],"readingTime":12},{"title":"iOS에서 멀티스레딩 사용하는 방법 안내","description":"","date":"2024-06-23 23:54","slug":"2024-06-23-GuidetoMultithreadinginiOS","content":"\n혹시 PR 댓글로 \"이것은 주요 큐에 들어가지 않는다\" 또는 비슷한 내용을 받았는데 왜 그런지 전혀 모르겠다고요? 이 기사가 딱 맞는 거에요!\n\n저희 모두가 디버그 네비게이터를 보면서 스택 트레이스를 살펴보며 꽤 많은 시간을 보냈다고 확신합니다. 스택 트레이스는 우리 프로그램을 실행하는 과정에서 실행된 스레드들의 백트레이스에 불과합니다. 스레드는 독립적으로 실행할 수 있는 명령어 집합이라고 볼 수 있습니다.\n\n모든 응용 프로그램에는 최소한 하나의 스레드, 즉 주요 스레드가 있습니다. 이것은 스레드 계층 구조에서 가장 높은 위치에 있는 스레드로, 다른 스레드들에게 작업을 위임할 수 있습니다. 주요 스레드가 여러 다른 백그라운드 스레드에 작업을 위임하는 것을 우리는 멀티스레딩이라고 부릅니다. 멀티스레딩은 단순히 여러 스레드에서 작업을 동시에 수행하여 애플리케이션의 성능을 개선하는 것입니다.\n\n![가이드 이미지](/assets/img/2024-06-23-GuidetoMultithreadinginiOS_0.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n단일 코어 프로세서에서는 시간 조각내기로 동시성을 달성할 수 있지만 멀티스레딩과 동시성은 1950년대 멀티코어 프로세서가 등장하면서 인기를 얻었습니다. 단일 코어 프로세서와 달리 멀티코어 프로세서는 시간 조각내기에 관련된 문맥 전환 없이 병렬로 여러 스레드를 실행할 수 있습니다. 복수 스레드를 실행하는 이 능력을 사용하지 않으면 리소스를 최적으로 활용하지 않는다는 것을 의미하며 결과적으로 성능이 저하될 수 있습니다. 그리고 여기에서 Grand Central Dispatch(GCD)가 등장합니다.\n\n# Grand Central Dispatch란?\n\niOS 애플리케이션을 개발한 적이 있다면 멀티스레딩을 사용하고 있음을 깨닫겠지만 (스택 추적이 그 증거입니다!), 실제로 스레드와 상호 작용하지는 않는 것을 알게 될 것입니다. 이는 GCD가 이를 백그라운드에서 처리하기 때문입니다. GCD는 어떤 스레드가 어떤 작업을 실행할지 관리하는 책임이 있는데, 우리는 단지 실행해야 할 작업을 지정하기만 하면 됩니다. 이는 GCD가 시스템 수준에서 작동하고 시스템의 리소스, 리소스를 최적으로 활용할 수 있는 방법, 그리고 효율적으로 작업을 수행할 수 있는 방법을 더 잘 알고 있기 때문입니다.\n\nGCD는 디스패치 대기열 또는 일반적으로 대기열이라고도 하는 일부 관리하며, 여기에 우리의 작업을 올리고 예약하고 나중에 스레드 풀 내에서 실행할 수 있도록 분배합니다. 이 디스패치 대기열은 \"직렬\"일 수도 있고(즉, 작업을 순차적으로 실행), \"동시적\"일 수도 있고 작업을 병렬로 실행할 수 있습니다. 앞서 언급했듯이 동시성은 더 나은 성능으로 이어지므로 병행 대기열을 더 자주 사용할 것을 권장합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# DispatchQueue.main.what…?\n\n메인 대기열(main queue)은 애플리케이션의 주 스레드에서 작업을 실행하는 GCD에서 제공하는 전역적으로 사용 가능한 시리얼 대기열입니다.\n\n하지만 주 스레드를 차단한다는 것은 무엇을 의미할까요? 그리고 이것이 사용자 경험에 실제로 영향을 미칠까요? 이미 알고 있듯이 주 스레드는 UI를 업데이트하는 데 사용됩니다. 이는 매우 리소스 집약적인 작업입니다. 대부분의 기기들이 이 작업을 매 초마다 여러 번 수행하기 때문에, 심지어 소수 초의 지연도 UI가 얼마나 부드러울지에 영향을 줄 수 있습니다. 애플리케이션이 UI를 여러 번 그릴 수 있게 하려면 필요한 리소스가 있어야 하는데, 만약 주 스레드에서 불필요한 작업을 수행한다면 이것은 불가능합니다.\n\n이를 피하기 위해, 주 대기열 외에도 GCD는 백그라운드 대기열로도 알려지는 여러 전역 대기열을 제공합니다. 이 대기열은 주 스레드에 속하지 않는 작업, 즉 UI 업데이트가 아닌 모든 작업을 수행하는 데 사용됩니다!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n예를 들어, 특정 상태에 따라 애니메이션을 표시해야 하는 경우가 있습니다. 특정 동작을 반환하는 함수가 있습니다. 주요 대기열에서 애니메이션을 가져와 표시하는 대신, 전역 백그라운드 스레드에서 애니메이션을 가져오고 주요 스레드에서만 애니메이션을 표시하는 것이 합리적입니다.\n\n```js\nDispatchQueue.global(qos: .userInteractive).async { [weak self] in\n  // 상태에 따라 애니메이션 가져오기\n  // 주요 스레드를 차단하지 않도록 전체 백그라운드 스레드에서\n  let animation = getAnimation(status)\n  DispatchQueue.main.async { [weak self] in\n    // UI 업데이트이므로 주요 스레드에 애니메이션 표시\n    self?.showAnimation(animation)\n  }\n}\n```\n\n그리고 DispatchQueue.main.async에서 async는 무엇을 의미할까요? GCD는 동기적 또는 비동기적 방식으로 작업을 디스패치할 수 있습니다. sync를 사용하면 작업 실행을 완료한 후에만 호출자 함수에 제어를 반환합니다. 반면, async를 사용하면 작업 실행을 시작하고 호출자에게 즉시 제어를 반환하여 스레드를 차단하지 않고 실행합니다. 일반적으로 API 호출이나 CPU 집약적 작업을 수행할 때 async를 사용합니다. 또한, 주요 스레드에 대해 async를 사용했던 것처럼, 요구 사항에 따라 DispathQueue.global().async 또는 sync를 사용할 수 있습니다.\n\n# 그렇다면 왜 Operation Queues가 필요할까요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nGCD는 멀티스레딩을 가능하게 하는 저수준 API인 것을 알고 있죠. 반면에 Operation queues는 GCD 위에서 구축된 추상화입니다. 이를 통해 우리는 작업에 우선 순위를 추가하고 그들 사이에 의존성을 설정할 수 있습니다. 디스패치 큐가 순수한 FIFO라면, operation queues는 그렇지 않습니다. 또한, 디스패치 큐가 직렬 또는 병렬일 수 있는 것을 기억하죠? Operation queues는 항상 병렬입니다. 우리는 의존성을 정의함으로써 특정 시퀀스를 설정할 수도 있지만, 순수하게 순차적일 수는 없습니다.\n\nOperation queues를 구현하기 위해 OperationQueue 또는 NSOperatioQueue 클래스를 사용하고, 이러한 큐에 추가된 작업 또는 연산에는 Operation 또는 NSOperation 클래스를 사용합니다. 이러한 연산들은 디스패치 큐 작업과 마찬가지로 독립적으로 실행할 수 있는 명령의 단위입니다.\n\nOperation queues의 실질적인 장점은 무엇일까요? 이러한 작업을 GCD로도 구현할 수는 없을까요?\n\n- 다른 작업의 결과에 따라 작업을 수행해야 할 때, 디스패치 큐의 FIFO 동작을 극복하기 위해 operation queues를 사용할 수 있습니다.\n- 디스패치 큐는 우선순위를 설정할 수 없습니다. 작업에 우선순위를 정해야 하는 경우에는 operation queues를 사용해야 합니다.\n- Operation queues를 사용하면 이미 예약된 작업을 취소할 수 있습니다. GCD는 투명성 면에서 유명하지 않기 때문에 이는 디스패치 큐로는 쉽게 구현할 수 없습니다. 우회 방법은 있지만 GCD로는 이것을 하는 좋은 방법이 없습니다. 또한, 한번 디스패치 큐에서 작업이 실행을 시작하면 중지할 수 없습니다. Operation queues는 이미 실행 중인 작업을 강제로 중지하지는 않지만, 취소된 프로퍼티를 true로 설정합니다. 각각의 작업에는 준비, 실행, 완료 상태가 있습니다. 완료가 true로 설정되면 실행이 성공적으로 완료된 것입니다. 작업과 연결된 완료 블록이 있다면, 완료 플래그가 설정될 때 실행됩니다. 그러나 취소된 작업의 경우, 완료 플래그가 설정되기 전에 취소 플래그가 설정됩니다. 따라서 완료 블록을 적절히 수정하여 필요한 경우 취소된 시나리오를 처리할 수 있습니다. 이것은 GCD로는 불가능한 일입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 작업 대기열이 동작하는 예시입니다.\n\n```swift\nimport Foundation\nlet queue = OperationQueue()\nqueue.maxConcurrentOperationCount = 3\n\nlet op1 = BlockOperation(block: {\n  print(\"op1 실행 중\")\n})\n\nlet op2 = BlockOperation(block: {\n  print(\"op2 실행 중\")\n})\n\nlet op3 = BlockOperation(block: {\n  print(\"op3 실행 중\")\n})\nlet op4 = BlockOperation(block: {\n  print(\"op4 실행 중\")\n})\n\nop4.queuePriority = .veryHigh\nop1.addDependency(op2)\n\nqueue.addOperation(op1)\nqueue.addOperation(op2)\nqueue.addOperation(op3)\nqueue.addOperation(op4)\nqueue.waitUntilAllOperationsAreFinished()\n```\n\n그리고 이로써 마무리합니다. 이것은 GCD와 Operation Queues를 사용한 스위프트에서의 멀티스레딩에 대한 간단한 소개였습니다. 읽어 주셔서 감사합니다. 질문이 있으시면 언제든지 물어보세요. 피드백은 언제나 환영이니 댓글을 남겨주세요!\n","ogImage":{"url":"/assets/img/2024-06-23-GuidetoMultithreadinginiOS_0.png"},"coverImage":"/assets/img/2024-06-23-GuidetoMultithreadinginiOS_0.png","tag":["Tech"],"readingTime":6},{"title":"SwiftUI에서 다양한 그리드 뷰를 만드는 방법 종합 가이드","description":"","date":"2024-06-23 23:53","slug":"2024-06-23-VariousKindsofGridViewsinSwiftUIAComprehensiveGuide","content":"\n# LazyVGrid 그리고 LazyHGrid\n\nSwiftUI에서는 LazyVGrid 또는 LazyHGrid 뷰를 사용하여 반응형 그리드 뷰를 만들 수 있습니다. 만약 세로 그리드를 원한다면 LazyVGrid 뷰를 사용하고, 가로 그리드를 원한다면 LazyHGrid 뷰를 사용할 수 있습니다. 이러한 뷰들을 사용하면 다양한 화면 크기와 방향에 적응하는 항목 그리드를 생성할 수 있습니다.\n\nLazyVGrid\n\n그리드를 표시하는 가장 좋은 방법 중 하나는 적응형 열을 사용하는 것입니다. 화면 크기에 따라 자동으로 자식 요소를 적응시킵니다. SwiftUI를 사용하여 반응형 그리드 뷰를 생성하는 예시는 다음과 같습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```swift\nimport SwiftUI\n\nstruct ContentView: View {\n\n    private var data  = Array(1...20)\n    private let adaptiveColumn = [\n        GridItem(.adaptive(minimum: 150))\n    ]\n\n    var body: some View {\n\n        ScrollView{\n            LazyVGrid(columns: adaptiveColumn, spacing: 20) {\n                ForEach(data, id: \\.self) { item in\n                    Text(String(item))\n                        .frame(width: 150, height: 150, alignment: .center)\n                        .background(Color.blue)\n                        .cornerRadius(10)\n                        .foregroundColor(Color.white)\n                        .font(.title)\n                }\n            }\n\n        } .padding()\n    }\n}\n\n#Preview {\n    ContentView()\n}\n```\n\n출력:\n\n<img src=\"/assets/img/2024-06-23-VariousKindsofGridViewsinSwiftUIAComprehensiveGuide_0.png\" />\n\n.adaptive(minimum: 150) 으로 설정하면 가능한 한 많은 항목을 행당 씩, 각각 150포인트의 최소 크기를 사용하여 그리드에 맞게 설정하고 있다는 뜻입니다. 다양한 화면 사이즈에서 각 열에 표시되는 항목 수가 다르게 표시됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nLazyVGrid에서 adaptive() 크기 수정자 외에도 fixed()이나 flexible() 크기 수정자와 같은 다른 수정자들을 사용할 수 있습니다.\n\nflexible() 크기 수정자\n\n각 열의 항목 수를 제어하려면 flexible() 크기 수정자를 사용할 수 있습니다.\n\n```js\nimport SwiftUI\n\nstruct ContentView: View {\n\n    private var data = Array(1...20)\n    private let flexibleColumn = [\n\n        GridItem(.flexible(minimum: 100, maximum: 200)),\n        GridItem(.flexible(minimum: 100, maximum: 200)),\n        GridItem(.flexible(minimum: 100, maximum: 200))\n    ]\n\n    var body: some View {\n\n        ScrollView {\n            LazyVGrid(columns: flexibleColumn, spacing: 20) {\n                ForEach(data, id: \\.self) { item in\n                    Text(String(item))\n                        .frame(width: 100, height: 100, alignment: .center)\n                        .background(Color.blue)\n                        .cornerRadius(10)\n                        .foregroundColor(.white)\n                        .font(.title)\n                }\n            }\n        }\n        .padding()\n    }\n}\n\n# 미리보기 {\n    ContentView()\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래와 같이 사용 가능합니다:\n\n<img src=\"/assets/img/2024-06-23-VariousKindsofGridViewsinSwiftUIAComprehensiveGuide_1.png\" />\n\nflexible() modifier를 사용하면 각 열의 항목 수를 제어할 수 있습니다. 그러나 뷰의 최소 크기를 수용할만큼 충분한 공간이 없는 경우 항목이 겹칠 수 있습니다.\n\nfixed() 크기 수정자\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만약 고정 크기의 열을 가진 LazyVGrid를 만들고 싶다면, 각 열에 .fixedSize() 수정자를 사용할 수 있습니다. 아래는 고정된 열을 가진 LazyVGrid를 생성하는 예시입니다:\n\n```swift\nimport SwiftUI\n\nstruct ContentView: View {\n\n    private var data = Array(1...20)\n    private let fixedColumn = [\n        GridItem(.fixed(100)),\n        GridItem(.fixed(100)),\n        GridItem(.fixed(100))\n    ]\n\n    var body: some View {\n\n        ScrollView {\n            LazyVGrid(columns: fixedColumn, spacing: 20) {\n                ForEach(data, id: \\.self) { item in\n                    Text(String(item))\n                        .frame(width: 100, height: 100, alignment: .center)\n                        .background(Color.blue)\n                        .cornerRadius(10)\n                        .foregroundColor(.white)\n                        .font(.title)\n                }\n            }\n        }\n    }\n}\n\nstruct ContentView_Previews: PreviewProvider {\n    static var previews: some View {\n        ContentView()\n    }\n}\n```\n\n출력:\n\n<img src=\"/assets/img/2024-06-23-VariousKindsofGridViewsinSwiftUIAComprehensiveGuide_2.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여기에서는 각 그리드 항목이 고정된 크기를 가지는 LazyVGrid를 만들었습니다. 열의 크기와 외관을 사용자 지정하여 특정 요구 사항에 맞출 수 있습니다.\n\nLazyHGrid\n\n그리드 항목을 수평으로 표시하려면 LazyHGrid를 사용할 수 있습니다. 이는 LazyVGrid와 정확히 같이 작동하지만 화면에 먼저 행을 맞추려고 합니다. 다음은 반응형 LazyHGrid 뷰를 사용하는 예시입니다.\n\n```js\nimport SwiftUI\n\n구조체 ContentView: View {\n\n    private var data = Array(1...20)\n    private let gridRows = [\n        GridItem(.adaptive(minimum: 150))\n\n    ]\n    var body: some View {\n\n        ScrollView(.horizontal) {\n            LazyHGrid(rows: gridRows, spacing: 20) {\n                ForEach(data, id: \\.self) { item in\n                    Text(String(item))\n                        .frame(width: 100, height: 100, alignment: .center)\n                        .background(.blue)\n                        .cornerRadius(10)\n                        .foregroundColor(.white)\n                        .font(.title)\n                }\n            }\n        }\n    }\n}\n\n#Preview {\n    ContentView()\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래 출력 내용을 참고해주세요:\n\n<img src=\"/assets/img/2024-06-23-VariousKindsofGridViewsinSwiftUIAComprehensiveGuide_3.png\" />\n\n앱을 실행하면, 컨텐츠를 처음에는 위에서 아래로 채우려고 하다가 모든 항목이 들어갈 수 없으면 수평 스크롤이 가능해집니다. ScrollView에서는 수평 스크롤을 가능하게 하려면 .horizontal modifier를 포함해야 합니다.\n\nLazyVGrid와 같이 .fixed() 및 .flexible() modifier를 사용할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n게으른 그리드 뷰는 SwiftUI가 그들을 표시해야 할 때에만 자식 뷰를 생성합니다. 따라서, 메모리 최적화에 좋습니다.\n\n# 그리드 뷰\n\niOS 13에서 소개된 LazyVGrid 및 LazyHGrid입니다. iOS 16에서 Apple은 SwiftUI에서 Grid 뷰를 소개했습니다. 이제, 이미 Lazy Grid가 있기 때문에 그것이 불필요하거나 중복된 것으로 생각할 수도 있습니다. 그러나 Grid 뷰에 익숙해지면, 여러분의 인식이 바뀔 것입니다.\n\nGrid 뷰는 자식 뷰를 2차원 레이아웃으로 정렬합니다. 이를 통해 뷰를 테이블과 유사한 구조로 정리할 수 있습니다. HTML 테이블이나 어떤 테이블에 익숙하다면, SwiftUI를 사용하여 동일한 결과를 얻을 수 있습니다. 셀이나 열을 병합하거나, 빈 셀을 만들거나, 셀 간격을 설정하거나, 정렬을 제어하는 등의 작업을 할 수 있습니다. Grid 뷰는 복잡한 UI 개발에 강력한 도구를 제공합니다. 배울 것이 많습니다. 시작해보죠!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음은 GridView의 매우 기본적인 예제입니다:\n\n```js\nimport SwiftUI\n\nstruct ContentView: View {\n    var body: some View {\n\n        Grid ( horizontalSpacing: 20, verticalSpacing: 20 ) {\n            GridRow {\n                Text(\"R1, C1\")\n                Text(\"R1, C2\")\n            }\n            GridRow {\n                Text(\"R2, C1\")\n                Text(\"R2, C2\")\n            }\n        }\n    }\n}\n\n#Preview {\n    ContentView()\n}\n```\n\n결과:\n\n<img src=\"/assets/img/2024-06-23-VariousKindsofGridViewsinSwiftUIAComprehensiveGuide_4.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n가로 간격: 20, 세로 간격: 20으로 셀 간격을 사용했습니다.\n\n그리드 열\n\n그리드 뷰에 표시하려는 행 수를 제어하는 GridRow입니다. GridRow 내의 각 항목은 열 항목을 나타냅니다. 서로 다른 열 수로 행을 생성할 수 있습니다. 그렇게 하면 그리드가 행에 더 적은 열이있는 경우 자동으로 빈 셀을 행 끝에 추가합니다. 다음은 예시입니다:\n\n```js\nimport SwiftUI\n\nstruct ContentView: View {\n    var body: some View {\n\n        Grid {\n            GridRow {\n                Text(\"행 1\")\n                ForEach(0..<3) { _ in Circle().foregroundColor(.red) }\n            }\n            GridRow {\n                Text(\"행 2\")\n                ForEach(0..<5) { _ in Circle().foregroundColor(.green) }\n            }\n            GridRow {\n                Text(\"행 3\")\n                ForEach(0..<4) { _ in Circle().foregroundColor(.mint) }\n            }\n        }\n    }\n}\n\n#Preview {\n    ContentView()\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 표 태그를 Markdown 형식으로 변경한 내용입니다.\n\n<img src=\"/assets/img/2024-06-23-VariousKindsofGridViewsinSwiftUIAComprehensiveGuide_5.png\" />\n\n각 행이 다른 열의 수를 가질 때, 최대 열 수와 동일하게 맞추기 위해 빈 셀이 추가된 것을 관찰할 수 있습니다.\n\nGrid 너비와 높이:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그리드의 너비와 높이는 해당 자식 뷰에 따라 증가합니다.\n\n- 그리드는 열의 모든 셀의 너비를 가장 넓은 셀에 맞춥니다.\n- 그리드는 특정 행의 가장 키가 큰 셀에 맞춰 전체 행의 높이를 설정합니다.\n\n그리드 내부의 뷰 확장\n\nGridRow 없이 그리드 뷰 내에 항목을 추가하면 전체 열을 확장합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```swift\nimport SwiftUI\n\nstruct ContentView: View {\n    var body: some View {\n\n        Grid(horizontalSpacing: 20, verticalSpacing: 20) {\n            GridRow {\n                Text(\"R1, C1\")\n                Text(\"R1, C2\")\n            }\n            Text(\"This will expand into full column\").font(.title)\n            GridRow {\n                Text(\"R2, C1\")\n                Text(\"R2, C2\")\n            }\n        }\n\n    }\n}\n\n# Preview {\n    ContentView()\n}\n```\n\n결과:\n\n<img src=\"/assets/img/2024-06-23-VariousKindsofGridViewsinSwiftUIAComprehensiveGuide_6.png\" />\n\n빈 셀\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만약 셀을 건너뛰고 어떤 뷰도 보여주고 싶지 않다면, Color.clear.gridCellUnsizedAxes([.horizontal, .vertical])를 사용하여 빈 셀을 추가할 수 있어요.\n\n여기 예시가 있어요:\n\n```swift\nimport SwiftUI\n\nstruct ContentView: View {\n    var body: some View {\n\n        Grid {\n            GridRow {\n                ForEach(0..<3) { _ in Circle().foregroundColor(.red) }\n            }\n            GridRow {\n                Circle().foregroundColor(.green)\n                Color.clear.gridCellUnsizedAxes([.horizontal, .vertical])\n                Circle().foregroundColor(.green)\n            }\n            GridRow {\n                ForEach(0..<3) { _ in Circle().foregroundColor(.mint) }\n            }\n        }\n    }\n}\n\n#Preview {\n    ContentView()\n}\n```\n\n결과:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Various kinds of GridView in SwiftUI - A Comprehensive Guide](/assets/img/2024-06-23-VariousKindsofGridViewsinSwiftUIAComprehensiveGuide_7.png)\n\n병합된 셀\n\n하나의 뷰가 두 개 이상의 열을 차지하도록 하려면 gridCellColumns(\\_:) 수정자를 사용하여 지정할 수 있습니다.\n\n```swift\nimport SwiftUI\n\nstruct ContentView: View {\n    var body: some View {\n\n        Grid {\n            GridRow {\n                ForEach(0..<3) { _ in Circle().foregroundColor(.red) }\n            }\n            GridRow {\n                Circle().foregroundColor(.green)\n                Text(\"2개의 셀 공간을 차지합니다\")\n                    .gridCellColumns(2)\n                    .font(.title)\n            }\n            GridRow {\n                ForEach(0..<3) { _ in Circle().foregroundColor(.mint) }\n            }\n        }\n\n    }\n}\n\n#Preview {\n    ContentView()\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 표 태그를 Markdown 형식으로 변경한 것입니다.\n\n<img src=\"/assets/img/2024-06-23-VariousKindsofGridViewsinSwiftUIAComprehensiveGuide_8.png\" />\n\n그리드 뷰는 모든 자식 뷰를 한꺼번에 렌더링합니다. 앱의 성능을 높이려면 LazyHGrid나 LazyVGrid를 사용할 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-06-23-VariousKindsofGridViewsinSwiftUIAComprehensiveGuide_0.png"},"coverImage":"/assets/img/2024-06-23-VariousKindsofGridViewsinSwiftUIAComprehensiveGuide_0.png","tag":["Tech"],"readingTime":14},{"title":"iOS 172 출시  꼭 알아야 할 27가지 중요한 사항","description":"","date":"2024-06-23 23:50","slug":"2024-06-23-iOS172Released27ThingsYouNEEDToKnow","content":"\n<img src=\"/assets/img/2024-06-23-iOS172Released27ThingsYouNEEDToKnow_0.png\" />\n\niOS 17.2가 오늘 드디어 공개되었습니다. 이번 iOS 17.x 업데이트는 다른 업데이트와는 다르답니다. 그만큼 많은 업데이트가 결합된 것보다 훨씬 크기 때문이에요.\n\n이번에는 여러분의 삶을 상당히 쉽게 만들어 줄 매우 유용한 새로운 기능이 수십 개 포함되어 있어요.\n\niOS 17.2에 대해 알아야 할 새로운 27가지 사항에 대해 소개해 드릴게요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n1 — 새로운 저널 앱\n새로운 Apple Music 변경 사항\n2 — 협업 플레이리스트\n3 — 즐겨 찾는 노래를 위한 독점 플레이리스트\n4 — 새로운 포커스 필터\n새로운 메시지 변경 사항\n5 — 메시지에 스티커 추가하는 새로운 방법\n6 — 당신의 Memoji 아바타를 위한 본체 선택\n7 — 세 가지 새로운 Memoji 포즈\n8 — iCloud로 메시지 강제 동기화\n9 — 그룹 채팅에서 최신 메시지로 이동하는 화살표\n새로운 위젯\n10 — 4가지 새로운 홈 화면 위젯\n11 — 새롭게 디자인된 잠금 화면 위젯\n새로운 Siri 변경 사항\n12 — 지리에 대해 더 많은 지식을 갖는 Siri\n13 — 전화 통화 시 어떤 앱을 사용할지 묻는 Siri\n새로운 연락처 변경 사항\n14 — FaceTime (및 전화)에서 이름과 사진 공유\n15 — 차단된 연락처가 FaceTime에 참여할 때 경고\n새로운 Apple TV 앱 변경 사항\n16 — 멋진 아이콘 재디자인\n17 — 새로운 버튼 — '정보' 및 '다음에 재생'\n새로운 UI 및 UX 변경 사항\n18 — 알람 울리는 UI 개선\n19 — 온라인 비디오 시청을 위한 UI 개선\n20 — 개인화된 공간 음향을 위한 간단한 프로세스\n21 — 근처 공유를 통한 지갑 패스 공유\n22 — iPhone 13 및 14 모델에 대한 Qi2 지원\n23 — 사미 키보드 지원\n24 — 날씨에서 강수량 총계\n25 — 앱 스토어 카테고리\n26 — Safari가 이전 기간을 기억하여 기록을 지우는 간편한 방법\n27 — AppleCare 및 보증이 이제 '커버리지'로 변경됨\n\n# #1. 새로운 저널 앱\n\n저널은 iOS 17과 함께 WWDC23에서 소개된 애플의 최신 앱입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nJournal이라는 이름에서 알 수 있듯이, 이 애플의 일기 앱은 당신의 일상 활동으로부터 지적 제안을 받을 수 있는 기능과 영감을 주는 프롬프트와 같이 과거에는 없던 기능이 있습니다.\n\n## 내용에 대한 자세한 정보를 보려면 이것을 읽어보세요\n\n# 새로운 Apple Music 변경 사항\n\n## #2. 협업 재생 목록\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\niOS 17.2 Beta 3까지 Apple이 협업 재생 목록 - 스포티파이와 아마존 뮤직이 여러 년간 보유해 온 혁신적인 기능을 보여 주었습니다.\n\n하지만 안타깝게도 iOS 17.2 공식 릴리즈에는 아직 이 기능이 포함되지 않았어요. 그래도, 궁금하시면 아래 설명을 확인해보세요.\n\n(재생 목록을 협업 모드로 변경하려면, 상단 오른쪽 모서리에 있는 아이콘을 탭하세요:\n\n![이미지 변경](/assets/img/2024-06-23-iOS172Released27ThingsYouNEEDToKnow_2.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이는 재생목록 링크를 공유하고 친구들이 참여할 수 있도록 허용하며, 재생목록에 곡을 추가, 삭제, 재정렬, 편집하고 노래에 이모지로 반응할 수 있습니다.\n\n카플레이에서는 승객이 곡을 추가할 수 있도록 SharePlay를 사용할 수 있습니다. 이 기능은 Apple Music 구독이 필요하지 않습니다.\n\n<img src=\"/assets/img/2024-06-23-iOS172Released27ThingsYouNEEDToKnow_3.png\" />\n\n최고의 파트,\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 참여하기 전에 협력자를 승인할 수 있습니다.\n- 참여할 수 있는 사람 수에 제한이 없습니다.\n\n하지만 안타깝게도, 플레이리스트 링크는 7일 후에 만료되며, 그때 새로운 링크를 생성하여 더 많은 사람들을 위해 사용해야 합니다.\n\n## #3. 즐겨듣는 노래 전용 플레이리스트\n\n이제 즐겨듣는 모든 노래가 별도의 플레이리스트인 'Favourite Songs ⭐️'로 모아집니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/assets/img/2024-06-23-iOS172Released27ThingsYouNEEDToKnow_4.png)\n\n노래 목록에서 일반적인 방법으로 곡을 삭제할 수 없습니다. 유일한 방법은 좋아요를 취소하는 것뿐입니다.\n\n## #4. 새로운 포커스 필터\n\nApple Music의 은밀 모드가 있습니다 — 바로 포커스 필터 형태로요. 설명해 드릴게요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n설정으로 이동하세요 ⚙️ `컨트롤 센터 🌙` 선택 `필터 추가` 음악을 선택하고 '들은 음악'을 토글하세요.\n\n<img src=\"/assets/img/2024-06-23-iOS172Released27ThingsYouNEEDToKnow_5.png\" />\n\n이제, 활성화된 포커스 상태에서 재생하는 음악은\n\n- 추천 및 믹스에 영향을 미치지 않습니다.\n- 최근 재생 목록에 표시되지 않습니다.\n- 다른 사람들에게 Apple Music에서 표시되지 않습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n간단히 말해, 이것은 Apple Music의 익명 모드입니다.\n\n누군가에게 iPhone을 빌려 음악을 듣도록 할 때에도 사용할 수 있어요. 그러면 그 사람의 선택이 여러분의 추천에 영향을 미치지 않아요.\n\n# 새로운 메시지 변경사항\n\n## #5. 메시지에 스티커 추가하는 새로운 방법\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아이메시지에 스티커를 붙일 수 있는 방법은 이미 알고 계실 거예요. 메시지 위에 드래그하여 스티커를 놓으면 스티커가 붙습니다. 아래와 같이요:\n\n![image](/assets/img/2024-06-23-iOS172Released27ThingsYouNEEDToKnow_6.png)\n\n애플은 iOS 17.2에서 이 프로세스를 조금 더 쉽게 만들었어요.\n\n- 메시지를 간단히 햅틱한 상태로 누르고,\n- '스티커 추가'를 탭하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/assets/img/2024-06-23-iOS172Released27ThingsYouNEEDToKnow_7.png)\n\n- 선호하는 스티커를 선택하고,\n\n그리고 완료되었습니다.\n\n## #6. Memoji 아바타를 위한 몸을 선택하세요\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 Memoji 아바타의 몸을 선택할 수 있어요.\n\n다음은 모든 가능한 섹션입니다:\n\n![Memoji](/assets/img/2024-06-23-iOS172Released27ThingsYouNEEDToKnow_8.png)\n\n## #7. 새로운 세 가지 Memoji 포즈\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n내 Memoji의 의류와 몸을 변경하던 중, 세 가지 새로운 포즈를 발견했어요:\n\n![image](/assets/img/2024-06-23-iOS172Released27ThingsYouNEEDToKnow_9.png)\n\n하지만 아직 스티커로 추가되지 않았어요.\n\n## #8. 메시지를 iCloud에 강제 동기화하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\niOS 17.2에서 Apple은 메시지를 iCloud에 강제 동기화할 수 있는 기능을 추가했어요. 메시지와 관련된 정보는 이제 '메시지' 대신 'iCloud 메시지'로 변경되었어요 (설정 ⚙️ `your_name` iCloud ☁️).\n\n메시지를 강제로 동기화하려면,\n\n- 'iCloud 메시지'로 들어가세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![image](/assets/img/2024-06-23-iOS172Released27ThingsYouNEEDToKnow_10.png)\n\n- tap on Sync Now.\n\nYou may also wanna choose to keep your messages for 30 days, 1 year, or Forever in ‘Keep Messages’.\n\n## #9. Catch-Up Arrow for Group Chat\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n애플이 드디어 Messages에 Catch-Up 화살표를 추가했어요 (WWDC23에서 언급된 기능이에요).\n\n![Catch-Up arrow](/assets/img/2024-06-23-iOS172Released27ThingsYouNEEDToKnow_11.png)\n\n이를 탭하면 놓친 긴 그룹 대화의 첫 메시지로 바로 이동할 수 있어요 — 그러니 이제 더 이상 메시지를 스스로 스크롤해야 할 필요가 없어요.\n\n# 새로운 위젯\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 10. 홈 화면 위젯이 4개 추가되었습니다\n\n3개의 새로운 날씨 위젯과 1개의 새로운 시계 위젯이 있습니다. 이것들:\n\n![이미지](/assets/img/2024-06-23-iOS172Released27ThingsYouNEEDToKnow_12.png)\n\n첫 세 가지 위젯은\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 세부 사항: 강수 확률, 자외선 지수, 바람 등을 확인하세요.\n- 일일 날씨 예보: 특정 위치의 현재 날씨 조건과 일일 날씨 예보를 확인하세요.\n- 일출 및 일몰: 해당 위치의 곧 오는 일출 및 일몰을 확인하세요.\n\n네 번째 위젯은 현재 시간을 표시하는 디지털 시계입니다.\n\n## 11.1 Lock Screen 위젯 개편\n\niOS 17.2 베타에서 Weather의 Lock Screen Wind 위젯이 새로운 모양을 받았습니다. 🌬️\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 iOS 17.1에서 이랬다:\n\n![iOS 17.1](/assets/img/2024-06-23-iOS172Released27ThingsYouNEEDToKnow_13.png)\n\niOS 17.2 Beta에서는 더 정확한 방향을 나타내기 위해 아날로그 방식으로 변경되었습니다.\n\n![iOS 17.2 Beta](/assets/img/2024-06-23-iOS172Released27ThingsYouNEEDToKnow_14.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그러나 iOS 17.2의 공개 릴리스에서는 iOS 17.1의 잠금 화면 바람 위젯으로 다시 변환되었습니다.\n\n# 새로운 Siri 변경 사항\n\n## #12. Siri가 지리적으로 더 높아졌어요\n\n- 고도:\n  iOS 17.1에서 Siri에게 고도를 물었더니 \"흥미로운 질문\"이라고 대답했어요 (좋은 회피, Siri). 그러나 iOS 17.2에서는 정확한 고도를 알려주고 있어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![image](/assets/img/2024-06-23-iOS172Released27ThingsYouNEEDToKnow_15.png)\n\n- ETA (예상 도착 시간):\n  Apple Maps로 어떤 장소로 이동 중이라면 (죄송해요 Google), 도착 예정 시간(ETA)을 알고 싶다면, 이제 Siri에게 간단히 물어볼 수 있어요.\n\n![image](/assets/img/2024-06-23-iOS172Released27ThingsYouNEEDToKnow_16.png)\n\n## #13. 전화 걸 때 어떤 앱을 사용할지 묻는 Siri\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n옛날에는 Siri에게 전화할 대상을 요청하면 자동으로 전화 앱을 사용하도록 설정되었습니다.\n\n하지만 만약 카카오톡이나 페이스타임과 같은 다른 앱을 통화에 사용하고 싶다면 어떻게 해야 할까요? 명확히 언급해야 했습니다.\n\n하지만 iOS 17.2에서 Siri는 전화 앱이 아닌 다른 앱을 선호하는지 확인하기 위해 노력할 것입니다.\n\n![iOS 17.2](/assets/img/2024-06-23-iOS172Released27ThingsYouNEEDToKnow_17.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 새로운 연락처 변경 내용\n\n## #14. FaceTime(그리고 전화)에서 이름과 사진 공유\n\n'이름과 사진 공유'는 새로운 기능이 아닙니다. 수 년 동안 iOS에 있던 기능입니다.\n\niMessage나 FaceTime을 통해 채팅하거나 대화하는 상대방에게 Apple ID 이름과 프로필 사진을 공개하거나 비공개로 유지할 수 있게 해줍니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n하지만 이제 iOS 17.1까지는 해당 설정을 설정 메뉴의 메시지 💬에서만 조정할 수 있었습니다 ⚙️.\n\n하지만 이제는 메시지 💬, 페이스타임 📹, 전화 📞에서도 조정할 수 있습니다. 모두 3가지에서 가능합니다.\n\n<img src=\"/assets/img/2024-06-23-iOS172Released27ThingsYouNEEDToKnow_18.png\" />\n\n## #15. 차단된 연락처가 페이스타임에 참가할 때 알림\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\niOS 17.2의 코드에는 차단된 연락처가 참여하는 FaceTime 통화에 대해 Apple이 경고할 수 있다는 내용이 나와요.\n\n![링크](/assets/img/2024-06-23-iOS172Released27ThingsYouNEEDToKnow_19.png)\n\n이런 기능은 누군가로부터 스토킹을 받고 싶지 않은 사용자들을 위해 Apple이 브라보 프라이버시 조치를 취한 것이에요.\n\n# 새로운 Apple TV 앱 변경 사항\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 16. 멋진 아이콘 재디자인\n\niOS 17.1의 TV 앱의 이전 하단 바를 살펴보세요:\n\n<img src=\"/assets/img/2024-06-23-iOS172Released27ThingsYouNEEDToKnow_20.png\" />\n\n이제 iOS 17.2에서 재디자인된 아이콘을 살펴보세요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![image](/assets/img/2024-06-23-iOS172Released27ThingsYouNEEDToKnow_21.png)\n\n변경 사항:\n\n- '지금보기' 탭이 '홈'으로 이름이 변경되었으며 아이콘이 직사각형 모양으로 바뀌었습니다.\n- '(TV+) 오리지널' 탭은 이제 'Apple TV+'로 이름이 변경되었고, 아이콘도 unboxed로 바뀌었습니다.\n- '라이브러리' 아이콘에 플레이 버튼이 추가되었습니다.\n\n## #17. 새 버튼 - '정보' 및 '다음에'\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n영화나 시리즈를 시청할 때, 아래에 두 개의 새 버튼이 표시됩니다:\n\n![Info 버튼](/assets/img/2024-06-23-iOS172Released27ThingsYouNEEDToKnow_22.png)\n\n- 정보:\n  콘텐츠 설명, 장르, 상영 시간을 보여주며, 비디오를 처음부터 재생하고 세부 정보를 확인할 수 있는 버튼이 있습니다.\n\n![Details 버튼](/assets/img/2024-06-23-iOS172Released27ThingsYouNEEDToKnow_23.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 다음에:\n  완전히 시청하지 않은 비디오를 보여줍니다. 계속 재생하고 싶을 것으로 기대합니다.\n\n![2024-06-23-iOS172Released27ThingsYouNEEDToKnow_24](/assets/img/2024-06-23-iOS172Released27ThingsYouNEEDToKnow_24.png)\n\n# 새로운 UI 및 UX 변경\n\n## #18. 알람 울림을 위한 UI 전면 개편\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이것은 작지만 멋지고 칭찬할 만한 UI 변경 사항입니다.\n\nDynamic Island을 사용하면서 알람이 울릴 때 iPhone을 사용하고 있다고 가정해 봅시다.\n\niOS 17.1까지는 이것이 그 UI였습니다(아주 단순한 UI):\n\n`![iOS 17.1 Old UI](/assets/img/2024-06-23-iOS172Released27ThingsYouNEEDToKnow_25.png)`\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n하지만 iOS 17.2에서 알람 시계가 흔들립니다 (긴급함을 느끼게 만듭니다):\n\n![알람 시계](https://miro.medium.com/v2/resize:fit:1400/1*9qbFme4APd2xa9Oc_yNZ7A.gif)\n\n## #19. 온라인 비디오 시청을 위한 새롭게 디자인된 UI\n\n저는 YouTube를 애플리케이션에서가 아니라 Safari에서 시청합니다. 왜일까요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 글의 #1에서 두 가지 이유를 설명했어요 →\n\n어쨌든, iOS 17.2의 전체 화면 비디오 UI가 변경되었다는 걸 발견했어요. 이전 UI는 다음과 같았어요:\n\n<img src=\"/assets/img/2024-06-23-iOS172Released27ThingsYouNEEDToKnow_26.png\" />\n\n하지만 요즘은,\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래 오른쪽에 있는 AirPlay 그림이 왼쪽 상단으로 이동합니다.\n세 점 메뉴 내의 재생 속도가 표시됩니다.\n\n현재 모습은 다음과 같습니다:\n\n![image](/assets/img/2024-06-23-iOS172Released27ThingsYouNEEDToKnow_27.png)\n\n# #20. 개인화된 공간 오디오를 위한 간단한 프로세스\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n개인 맞춤형 공간 오디오 설정은 조금 귀찮은 작업일 수 있어요.\n\n- 먼저 얼굴 전체를 회전시켜 스캔해야 해요.\n- 그런 다음 왼쪽으로 돌아가면서 자신을 스캔해야 해요.\n- 그리고 오른쪽으로 돌아가면서 또 다시 스캔을 해야 해요.\n\n긴 과정이죠... 하지만 애플에서 이제 더 간단하게 했어요.\n\n이제 왼쪽으로 돌아가면서 얼굴을 한 번 스캔하고, 그리고 오른쪽으로 돌아가는 것만 하면 돼요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*CXhjvWRyxxUHbLpr1uT2ZQ.gif)\n\n이미 공간 오디오를 설정했다면 다시 설정할 필요가 없다는 것을 유념하세요.\n\n```js\n설정에서 공간 오디오 설정하기 ⚙️\n• AirPods_이름 🎧\n• 또는 소리 및 햅틱 🔊\n```\n\n# #21. 근처 공유를 통해 지갑 패스 공유하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\niOS 17에서 Apple은 NameDrop을 통해 연락처를 공유하고 두 대의 iPhone을 두드려 파일을 공유하는 혁신적인 기능을 선보였어요.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1000/1*Nb3TsvnFTVCnyjD_hP6swA.gif)\n\n또한 iOS 17.2에서는 탑승권 및 영화 티켓과 같은 지갑 패스로 확장되었어요. 이제 동일한 방법으로 이들을 공유할 수 있어요.\n\n## 22. iPhone 13 및 14 모델용 Qi2 지원\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아이폰 15 시리즈는 이미 Qi2 무선 충전을 지원합니다.\n\nIOS 17.2부터 Apple은 이전 두 시리즈인 13 및 14에도 Qi2 표준 무선 충전을 추가했습니다. 이로써 맥세이프 가격을 지불하지 않고 맥세이프 속도로 충전이 가능해졌습니다.\n\n멋지죠?\n\n# 23. 사미 키보드 지원\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n애플이 사미어를 위한 8개의 새 키보드를 선보였어요.\n\n![이미지](/assets/img/2024-06-23-iOS172Released27ThingsYouNEEDToKnow_28.png)\n\n```js\n설정 ⚙️ < 일반 ⚙️ < 키보드 < 키보드 < 새 키보드 추가... 에서 사미어 키보드를 설정하세요.\n```\n\n# #24. 날씨에서 강수량\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n날씨 앱에 새로운 하위 섹션이 추가되었습니다. Precipitation Totals(시간별 예측 섹션).\n\n여기에는 다음이 표시됩니다.\n\n- 지난 24시간 강수량 및\n- 다음 24시간 예상 강수량.\n\n![이미지](/assets/img/2024-06-23-iOS172Released27ThingsYouNEEDToKnow_29.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# #25. App Store의 카테고리\n\n앱 스토어가 멋진 새로운 디자인을 채택했어요.\n\nApps 또는 Games 섹션을 탭하면 이제 상단에 카테고리를 표시하는 내비게이션 바가 나타나요:\n\n![image](/assets/img/2024-06-23-iOS172Released27ThingsYouNEEDToKnow_30.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n마크다운 형식으로 표를 변경하면 빠르게 스크롤하여 관심 있는 항목을 탭할 수 있습니다.\n\n이 기능은 이전에 아케이드에서만 제공되었었는데 (이것을 몰랐다면 지금 확인하세요), 이제 앱 및 게임에서도 제공됩니다.\n\n# #26. 사파리가 이전 시간대를 기억하여 히스토리 삭제\n\n사파리 히스토리를 정기적으로 삭제하는 경우, 여러분을 위한 (약간) 유용한 기능이 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n사파리(Safari)는 이제 당신이 히스토리를 지운 시간대를 기억합니다.\n\n![image](/assets/img/2024-06-23-iOS172Released27ThingsYouNEEDToKnow_31.png)\n\n예를 들어, '오늘'을 선택했다고 가정해 봅시다.\n다음에 히스토리를 지우러 오면, '오늘'이 이미 선택되어 있을 것입니다.\n\n하지만, 매번 히스토리를 지우려고 노력하는 대신에 왜 개인 탐색을 시도해보지 않으시겠어요? 더 안전하고 누구도 당신이 뭘 둘러봤는지 모를 거예요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# #27. 보증은 이제 '애플케어 & 보증'으로 변경되었습니다\n\n‘보증’은 모든 Apple 장치 및 보증 내용을 나열하는 섹션으로, 새로워진 이름과 위치로 바뀌었습니다.\n\n이전에는 설정 ⚙️ `일반 ⚙️` 정보에서 확인할 수 있었지만 이제 설정 ⚙️ ` 일반 ⚙️`으로 이동하였습니다. 한 걸음 더 간단해졌어요.\n\n<img src=\"/assets/img/2024-06-23-iOS172Released27ThingsYouNEEDToKnow_32.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n및 이제는 AppleCare 및 보증으로 불립니다.\n\n## iOS 17 정말 멋지지 않나요?\n\n## iOS 17의 250여 가지 새로운 기능: 편집본 (항상 업데이트):\n\n## 마침내,\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만약 새로운 iOS 및 Mac 앱을 탐험하는 것을 좋아한다면 (저처럼), Setapp 구독을 고려해보세요. 매월 $9.99에 약 240여개의 멋진 앱을 이용할 수 있습니다. 이 앱들은 개별로 구매했을 때 수백 달러가 들 것이죠.\n\n- Setapp 여정을 시작할 수 있는 제 제휴 링크를 사용해보세요! (30일 무료 체험 가능)\n- Setapp에 있는 제 무료 70여가지 최고의 macOS 앱 목록을 받아보세요.\n\n새로운 이야기를 발행할 때마다 알림을 받기 위해 420여명과 함께 참여하세요!\n","ogImage":{"url":"/assets/img/2024-06-23-iOS172Released27ThingsYouNEEDToKnow_0.png"},"coverImage":"/assets/img/2024-06-23-iOS172Released27ThingsYouNEEDToKnow_0.png","tag":["Tech"],"readingTime":23},{"title":"처음으로 Kotlin Multiplatform KMM 프로젝트를 Android Studio에서 빌드하는 방법","description":"","date":"2024-06-23 23:47","slug":"2024-06-23-FirstKotlinMultiplatformKMMprojecttobuildinAndroidStudio","content":"\n![이미지](/assets/img/2024-06-23-FirstKotlinMultiplatformKMMprojecttobuildinAndroidStudio_0.png)\n\n코틀린 멀티플랫폼(KMP)은 코틀린 프로그래밍 언어의 기능으로, 개발자가 단일 코드베이스를 사용하여 Android, iOS, JavaScript 및 JVM과 같은 여러 플랫폼에서 실행할 수 있는 코드를 작성할 수 있게 해줍니다.\n\n이 방식은 코드 재사용을 극대화하고 중복을 줄이기 위한 것으로, 공통 로직을 다른 플랫폼 간에 공유하면서 필요한 경우에 플랫폼별 코드를 사용할 수 있도록 합니다.\n\n# Kotlin 멀티플랫폼의 장점\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 코드 재사용성: 공통 로직을 한 번 작성하고 여러 플랫폼에서 재사용하여 코드 중복 및 유지 보수 노력을 줄입니다.\n- 일관성: 동일한 코드베이스를 공유함으로써 다양한 플랫폼에서 일관된 동작을 보장합니다.\n- 생산성: 비즈니스 로직 및 기타 UI 이외의 구성 요소를 공유하여 개발 속도를 높입니다.\n- 유연성: 공유 코드베이스를 유지한 채 필요에 따라 플랫폼별 API 및 라이브러리를 사용합니다.\n\n이제 코드 작성을 시작하고 Android Studio에서 KMM 프로젝트가 어떻게 작동하는지 확인해보겠습니다.\n\n- Android Studio에 KMM 플러그인을 추가하고 플러그인이 추가되도록 IDE를 재시작합니다.\n\n![KMM project in Android Studio](/assets/img/2024-06-23-FirstKotlinMultiplatformKMMprojecttobuildinAndroidStudio_1.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n2. 안녕하세요! 안드로이드 스튜디오에서 새로운 KMM 앱을 만들고 있습니다. 프로젝트 구조가 아래와 같이 보일 것입니다.\n\n![프로젝트 구조](/assets/img/2024-06-23-FirstKotlinMultiplatformKMMprojecttobuildinAndroidStudio_2.png)\n\n3. KMM 프로젝트의 shared 폴더는 코드 재사용성, 일관성, 효율적인 개발 목표를 달성하는 데 근본적인 역할을 합니다. 비즈니스 로직을 중앙 집중화하여 중복을 줄이고 유지보수를 간소화함으로써 더 나은 협업을 도모하고 플랫폼 간 일관된 동작을 보장합니다. 공유 코드를 활용함으로써 개발자들은 더 효율적이고 적은 리소스로 견고하고 기능이 풍부한 애플리케이션을 개발할 수 있습니다.\n\n![공유 폴더](/assets/img/2024-06-23-FirstKotlinMultiplatformKMMprojecttobuildinAndroidStudio_3.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n4. 리소스 및 이미지를 추가하기 위해 The IceRock Moko 라이브러리(Mobile Kotlin)를 사용할 예정입니다. 이 라이브러리는 Kotlin Multiplatform Mobile (KMM) 애플리케이션 개발을 간편하게 하는 데 사용되는 라이브러리 및 도구 세트입니다. 이러한 라이브러리는 iOS 및 Android를 위한 공유 코드 작성을 지원하여 개발자가 효율적으로 크로스 플랫폼 모바일 애플리케이션을 생성할 수 있도록 합니다. IceRock Moko는 네트워크 요청, 리소스, MVVM 아키텍처, 권한 처리 등과 같은 모바일 개발의 다양한 측면을 다루는 다양한 라이브러리를 제공합니다.\n\n5. build.gradle.kts (:shared) 업데이트\n\n```js\nplugins {\n    kotlin(\"multiplatform\")\n    id(\"com.android.library\")\n    id(\"dev.icerock.mobile.multiplatform-resources\")\n}\n\nkotlin {\n    android {\n        compilations.all {\n            kotlinOptions {\n                jvmTarget = \"1.8\"\n            }\n        }\n    }\n    task(\"testClasses\")\n\n    listOf(\n        iosX64(),\n        iosArm64(),\n        iosSimulatorArm64()\n    ).forEach {\n        it.binaries.framework {\n            baseName = \"shared\"\n            isStatic = true\n            export(\"dev.icerock.moko:resources:0.22.3\")\n            export(\"dev.icerock.moko:graphics:0.9.0\")\n        }\n    }\n\n    sourceSets {\n        val commonMain by getting {\n            dependencies {\n                api(\"dev.icerock.moko:resources:0.22.3\")\n            }\n        }\n\n       val  commonTest by getting {\n           dependencies{\n               implementation(libs.kotlin.test)\n           }\n        }\n        val androidMain by getting\n        val iosX64Main by getting\n        val iosArm64Main by getting\n        val iosSimulatorArm64Main by getting\n        val iosMain by creating {\n            dependsOn(commonMain)\n            iosX64Main.dependsOn(this)\n            iosArm64Main.dependsOn(this)\n            iosSimulatorArm64Main.dependsOn(this)\n        }\n        val iosX64Test by getting\n        val iosArm64Test by getting\n        val iosSimulatorArm64Test by getting\n    }\n}\n\nandroid {\n    namespace = \"com.tokai.mobile.coffeeworld\"\n    compileSdk = 34\n    defaultConfig {\n        minSdk = 24\n    }\n    compileOptions {\n        sourceCompatibility = JavaVersion.VERSION_1_8\n        targetCompatibility = JavaVersion.VERSION_1_8\n    }\n}\nmultiplatformResources {\n    multiplatformResourcesPackage = \"com.tokai.mobile.coffeeworld\"\n    multiplatformResourcesClassName = \"SharedRes\"\n}\n```\n\n6. build.gradle.kts(:androidApp) 업데이트\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n플러그인 {\n    id(\"com.android.application\")\n    kotlin(\"android\")\n}\n\nandroid {\n    namespace = \"com.tokai.mobile.coffeeworld.android\"\n    compileSdk = 34\n    defaultConfig {\n        applicationId = \"com.tokai.mobile.coffeeworld.android\"\n        minSdk = 24\n        targetSdk = 34\n        versionCode = 1\n        versionName = \"1.0\"\n    }\n    buildFeatures {\n        compose = true\n    }\n    composeOptions {\n        kotlinCompilerExtensionVersion =\"1.4.4\"\n    }\n    packaging {\n        resources {\n            excludes += \"/META-INF/{AL2.0,LGPL2.1}\"\n        }\n    }\n    buildTypes {\n        getByName(\"release\") {\n            isMinifyEnabled = false\n        }\n    }\n    compileOptions {\n        sourceCompatibility = JavaVersion.VERSION_1_8\n        targetCompatibility = JavaVersion.VERSION_1_8\n    }\n    kotlinOptions {\n        jvmTarget = \"1.8\"\n    }\n}\n\ndependencies {\n    implementation(projects.shared)\n    implementation(\"androidx.compose.ui:ui-tooling:1.6.8\")\n    implementation(\"androidx.compose.ui:ui-tooling-preview:1.6.8\")\n    implementation(\"androidx.compose.foundation:foundation:1.4.4\")\n    implementation(\"androidx.compose.material:material:1.4.0\")\n    implementation(\"androidx.activity:activity-compose:1.7.0\")\n    implementation(\"org.jetbrains.kotlin:kotlin-test:1.8.10\")\n    implementation(\"androidx.compose.material3:material3:1.1.2\")\n}\n```\n\n7. build.gradle.kts(CoffeeWorld)를 업데이트 합니다\n\n```js\n플러그인 {\n    // 동일한 플러그인 버전을 모든 서브 모듈에서 사용하기 위한 트릭\n    id(\"com.android.application\").version(\"8.0.1\").apply(false)\n    id(\"com.android.library\").version(\"8.0.1\").apply(false)\n    kotlin(\"android\").version(\"1.8.10\").apply(false)\n    kotlin(\"multiplatform\").version(\"1.8.10\").apply(false)\n}\nbuildscript {\n    dependencies {\n        classpath(\"dev.icerock.moko:resources-generator:0.22.3\")\n    }\n}\n\ntasks.register(\"clean\", Delete::class) {\n    delete(rootProject.buildDir)\n}\n```\n\nAndroid Studio에서 프로젝트를 다시 빌드하세요\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n8. 안드로이드 스튜디오에서 다음 버전들이 언급되었습니다.\n\n```js\nagp = \"8.0.1\";\nkotlin = \"1.8.10\";\ncompose = \"1.4.4\";\n```\n\n```js\ndistributionBase=GRADLE_USER_HOME\ndistributionPath=wrapper/dists\ndistributionUrl=https\\://services.gradle.org/distributions/gradle-8.0-bin.zip\nzipStoreBase=GRADLE_USER_HOME\nzipStorePath=wrapper/dists\n```\n\n9. 이제 공유 폴더인 commonMain 내 KMM 프로젝트에서 문자열 파일을 만들어 보겠습니다. resources라는 새 디렉토리를 만들었고, MR/base 및 MR/de를 만들었습니다. 영어 및 독일어 언어용 두 개의 문자열 파일을 생성했습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-06-23-FirstKotlinMultiplatformKMMprojecttobuildinAndroidStudio_4.png\" />\n\nMR/base/strings.xml\n\n```js\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<resources>\n    <string name=\"hello_world\">안녕 세계</string>\n    <string name=\"hello_x\">안녕 %s</string>\n</resources>\n```\n\nMR/de/strings.xml\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<resources>\n    <string name=\"hello_world\">Hallo Welt</string>\n    <string name=\"hello_x\">Hallo %s</string>\n</resources>\n```\n\n10. shared 폴더 아래 iosMain과 androidMain에 String.kt 파일을 추가합니다.\n\n![image](/assets/img/2024-06-23-FirstKotlinMultiplatformKMMprojecttobuildinAndroidStudio_5.png)\n\niosMain/Strings.kt\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n패키지 com.tokai.mobile.coffeeworld\n\nimport dev.icerock.moko.resources.StringResource\nimport dev.icerock.moko.resources.desc.Resource\nimport dev.icerock.moko.resources.desc.StringDesc\nimport dev.icerock.moko.resources.format\n\n실제 클래스 Strings() {\n    실제로 fun get(id: StringResource, args: List<Any>): String {\n        return if (args.isEmpty()) {\n            StringDesc.Resource(id).localized()\n        } else {\n            id.format(*args.toTypedArray()).localized()\n        }\n    }\n}\n```\n\nandroidMain/Strings.kt\n\n```js\n패키지 com.tokai.mobile.coffeeworld\n\nimport android.content.Context\nimport dev.icerock.moko.resources.StringResource\nimport dev.icerock.moko.resources.desc.Resource\nimport dev.icerock.moko.resources.desc.StringDesc\nimport dev.icerock.moko.resources.format\n\n실제 클래스 Strings(private val context: Context) {\n    실제로 fun get(id: StringResource, args: List<Any>): String {\n        return if (args.isEmpty()) {\n            StringDesc.Resource(id).toString(context = context)\n        } else {\n            id.format(*args.toTypedArray()).toString(context)\n        }\n    }\n}\n```\n\n11. 이제 프로젝트를 다시 빌드하고 KMM 프로젝트의 공용 폴더인 commonMain/resources/MR/images 경로에 이미지를 추가합니다. 이미지를 추가한 후 프로젝트를 다시 빌드합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/assets/img/2024-06-23-FirstKotlinMultiplatformKMMprojecttobuildinAndroidStudio_6.png)\n\n12. 이제 androidApp 내의 MainActivity에서 코드를 업데이트하고 프로젝트를 실행합니다.\n\n```js\nimport android.os.Bundle\nimport androidx.activity.ComponentActivity\nimport androidx.activity.compose.setContent\nimport androidx.compose.foundation.Image\nimport androidx.compose.foundation.layout.Arrangement\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.material3.*\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.platform.LocalContext\nimport androidx.compose.ui.res.painterResource\nimport androidx.compose.ui.tooling.preview.Preview\nimport com.tokai.mobile.coffeeworld.Greeting\nimport com.tokai.mobile.coffeeworld.SharedRes\nimport com.tokai.mobile.coffeeworld.Strings\nimport dev.icerock.moko.resources.StringResource\n\nclass MainActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            MyApplicationTheme {\n                Surface(\n                    modifier = Modifier.fillMaxSize(),\n                    color = MaterialTheme.colorScheme.background\n                ) {\n                    Column(\n                        modifier = Modifier.fillMaxSize(),\n                        verticalArrangement = Arrangement.Center,\n                        horizontalAlignment = Alignment.CenterHorizontally\n                    ) {\n                        Image(\n                            painter = painterResource(\n                                id = com.tokai.mobile.coffeeworld.R.drawable.coffee\n                            ),\n                            contentDescription = null\n                        )\n                        Text(\n                            text = stringResource(\n                                id = SharedRes.strings.hello_world\n                            )\n                        )\n                        Text(\n                            text = stringResource(\n                                id = SharedRes.strings.hello_x,\n                                \"Parita\"\n                            )\n                        )\n                    }\n                }\n            }\n        }\n    }\n}\n\n@Composable\nfun stringResource(id: StringResource, vararg args: Any): String {\n    return Strings(LocalContext.current).get(id, args.toList())\n}\n\n@Composable\nfun GreetingView(text: String) {\n    Text(text = text)\n}\n\n@Preview\n@Composable\nfun DefaultPreview() {\n    MyApplicationTheme {\n        GreetingView(\"Hello, Android!\")\n    }\n}\n```\n\n13. 결과물은 다음과 같이 보일 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![image](/assets/img/2024-06-23-FirstKotlinMultiplatformKMMprojecttobuildinAndroidStudio_7.png)\n\n# 이 프로젝트의 Github 링크: https://github.com/paritadey/CoffeeWorld\n\nKMM에서의 다음 코딩 세트로 돌아오겠습니다. 그 동안 즐거운 코딩하세요!!\n","ogImage":{"url":"/assets/img/2024-06-23-FirstKotlinMultiplatformKMMprojecttobuildinAndroidStudio_0.png"},"coverImage":"/assets/img/2024-06-23-FirstKotlinMultiplatformKMMprojecttobuildinAndroidStudio_0.png","tag":["Tech"],"readingTime":14},{"title":"iOS 앱을 위한 UI 디자인 완벽 가이드","description":"","date":"2024-06-23 23:44","slug":"2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps","content":"\n<img src=\"/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_0.png\" />\n\niOS 앱을 위한 UI 디자인을 만드는 포괄적인 가이드를 공유하고 싶어요. 이 가이드는 우리가 애플 가이드라인과 일관성을 유지하면서 고품질 디자인을 만들기 위해 알아야 하는 필수 주제를 다룹니다.\n\n구성:\n\n- 레이아웃 및 그리드\n- 색상\n- 타이포그래피\n- 아이콘\n- 컴포넌트\n- 전환\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 레이아웃과 그리드\n\nFigma에서 iPhone용 다양한 아트보드 크기를 찾을 수 있고, 디자인을 위해 어떤 것을 선택해야 하는지 고민할 수 있습니다. 하지만 코드 수준에서 XCode는 자동으로 선택한 기기에 따라 레이아웃을 조정해줍니다. 따라서 가장 인기 있는 iPhone의 아트보드 크기를 선택하고, 이 모델의 레이아웃 사양을 고려하여 UI를 설계할 수 있습니다.\n\n아래 이미지는 iPhone 14 Pro의 레이아웃 영역과 사양을 보여줍니다.\n\n![iPhone 14 Pro Layout](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_1.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n☝️ 버튼 및 컨트롤과 같은 UI 요소는 상태 표시줄과 홈 인디케이터 영역에 가려지지 않는 영역에만 배치해야 합니다. 이렇게 하면 iOS 시스템 요소와의 상호 작용에 방해가 되지 않습니다.\n\n그리드는 콘텐츠를 구조적으로 배열하는 데 도움이 됩니다. 일반적으로 반응형 웹사이트 디자인에 사용되지만, 모바일 앱에서도 유용합니다.\n\n모바일 앱을 위한 그리드 정의 방법:\n\n- 화면 위에 요소를 정확히 배치하기 위해 8포인트 그리드를 생성합니다.\n- 좌우 여백을 16포인트의 최소 크기로 정의하세요. 이것은 iOS의 표준입니다.\n- 필요에 맞게 최적의 열 수를 정의하세요. 16포인트의 거터 크기가 가장 일반적이지만, 더 작거나 큰 거터 크기를 정의해야 한다면, 스트레치 그리드에서는 거터 크기가 열 너비에 영향을 미치므로, 거터 크기가 클수록 열 너비가 작아집니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n👉 이 멋진 기사를 확인해보세요! 여기서 모바일 그리드에 대해 더 배울 수 있어요.\n\n![image](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_2.png)\n\n# 색상\n\niOS에는 활력, 접근성 설정 및 외형 모드에 자동으로 적응되는 시스템 및 의미론적 색상이 정의되어 있어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n시멘틱 컬러는 목적을 설명하는 이름을 가진 색상입니다. 각 시멘틱 컬러에는 기본, 보조, 제3의 색상 변형이 있어서 등급에 따라 콘텐츠를 구분하는 데 사용됩니다. 예를 들어, 기본 배경에 대한 사용자 정의 색상을 정의하려면 색상 이름을 앱은 브랜드/앱의 약어이며 PrimaryBackground는 색상의 시멘틱 이름입니다. 사용자 지정 색상의 이름은 iOS 시스템 색상과 같아서는 안 됨을 언급할 가치가 있습니다.\n\n![image](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_3.png)\n\n🎨 애플의 가이드라인을 고려하여 사용자 정의 색상 팔레트를 만드는 방법을 살펴보겠습니다.\n\n## 기본 색상\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n앱의 개성을 전달하는 데 기본적인 색상이 중요합니다. 이것은 팔레트의 기본 색상입니다. 대부분의 화면과 구성 요소에서 자주 표시되는 이 색상은 주요 작업을 나타내는 데 사용됩니다. 특정 UI 요소를 강조하거나 탭, 누름과 같은 상호 작용을 위한 UI 상태를 나타내는 데 주요 색상 쉐이드를 사용할 수도 있습니다.\n\nFigma에서 색상 쉐이드를 생성하려면 이 플러그인을 사용할 수 있습니다.\n\n![이미지](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_4.png)\n\n![이미지](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_5.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 보조 및 강조 색상\n\n보조 색상은 주요 색상을 지원하고 디자인에 깊이와 다양성을 더합니다.\n\n![보조 색상](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_6.png)\n\n보조 색상 외에도 \"강조\" 색상 용어를 만날 수 있습니다. 강조 색상은 중요한 조치 및 컨트롤을 강조하는 데 사용되는 보조 색상의 일부로 고려할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n강조색은 다음에 가장 적합합니다:\n\n- 슬라이더 및 스위치와 같은 선택 컨트롤\n- 선택된 텍스트 강조\n- 진행 표시 막대\n- 링크 및 헤드라인\n\n기본 색을 보완하는 보조 색상을 찾으려면 Coolors와 같은 색 구성 생성기를 사용해보세요. 일반적으로 앱에는 1개의 주요 색상, 1-2개의 보조 색상 및 1-3개의 강조색이 있어야 합니다.\n\n![이미지](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_7.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 채우기 색상\n\niOS에서는 채우기 색상이 UI 요소에 사용되며, 이를 통해 배경 색상이 나타납니다. 채우기 색상은 동일한 색상 값을 공유하지만 각 색상 변형마다 다양한 불투명도 수준을 갖고 있습니다.\n\niOS 채우기 색상 변형:\n\n- 기본 채우기 색상 — 슬라이더의 트랙과 같은 얇고 작은 모양에 사용됩니다.\n- 보조 채우기 색상 — 스위치의 배경과 같은 중간 크기의 모양에 사용됩니다.\n- 제 3위 채우기 색상 — 입력 필드, 검색 바 또는 버튼과 같은 큰 모양에 사용됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![image 8](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_8.png)\n\n![image 9](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_9.png)\n\n## 배경색상\n\niOS는 콘텐츠 및 요소의 그룹화를 구분하기 위해 배경색상의 색상 변형을 정의합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 전반적인 뷰의 기본적인 배경을 위한 기본(primary).\n- 전반적인 뷰 내에서 콘텐츠나 요소들을 그룹화하기 위한 보조(secondary).\n- 보조 요소 내에서 콘텐츠나 요소들을 그룹화하기 위한 제3 단계(tertiary).\n\n![이미지](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_10.png)\n\n![이미지](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_11.png)\n\n## 레이블 색상\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n라벨 색상에는 주요, 보조, 제 3 및 제 4 등급의 색상 변형이 있습니다. 중요도 수준에 따라 색상은 해당 투명도 수준을 갖습니다.\n\n![이미지](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_12.png)\n\n- 주요 레이블 색상은 사용자에게 강조해야 할 중요한 텍스트나 콘텐츠를 강조하는 데 사용됩니다. 예를 들어, 제목 및 헤드라인, 내비게이션 막대 페이지의 레이블, 양식에서의 필드 레이블 또는 입력 컨트롤에 주요 색상을 사용할 수 있습니다.\n- 보조 레이블 색상은 자막이나 지원 정보를 표시하는 데 사용됩니다. 보조 레이블은 양식과 입력 필드에서 필드나 입력 컨트롤에 대한 추가 컨텍스트나 지시사항을 제공하기 위해 사용될 수 있으며, 목록이나 테이블에서 목록이나 테이블 항목에 대한 보조 정보와 세부 정보를 표시하는 데 사용됩니다.\n- 제 3 등급 레이블 색상은 더 중요하지 않은 텍스트나 콘텐츠를 표시하는 데 사용됩니다. 더 이상 필수가 아닌 보충 정보나 앱 사용자의 이해에 필수적이지 않은 세부 정보를 표시하기 위해 사용됩니다.\n\n![이미지](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_13.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 구분선 색상\n\n구분선은 콘텐츠 그룹을 시각적으로 구분하는 데 사용되는 가는 수평 선입니다. 표 뷰, 컬렉션 뷰 및 사용자 인터페이스의 다른 부분에서 시각적 계층 구조를 만들고 사용자가 콘텐츠의 구조를 이해하는 데 도움이 되도록 자주 사용됩니다.\n\niOS에서는 불투명도 수준을 가진 Separator 및 불투명 선 (일반 선) 두 가지 유형의 구분선 색상을 정의합니다.\n\n![image](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_14.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_15.png\" />\n\n## 기능적인 색상\n\n기능적인 색상은 요소의 상태나 상태를 나타내거나 사용자에게 맥락이나 메시지를 제공하는 데 사용됩니다.\n\n기능적인 색상에 대한 지침:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 성공 상태: 성공 상태를 나타내기 위해 녹색이 자주 사용됩니다. 이는 작업이 성공적으로 완료되었거나 양식이 올바르게 작성되었음을 나타내는 데 사용될 수 있습니다.\n- 경고 상태: 노랑 또는 주황색이 경고 상태를 나타내는 데 흔히 사용됩니다. 이는 사용자에게 잠재적인 문제를 경고하거나 필수 조치가 아직 완료되지 않았음을 나타내는 데 사용될 수 있습니다.\n- 오류 상태: 빨강은 오류 상태를 나타내는 데 자주 사용됩니다. 이는 텍스트 또는 배경 색상, 또는 아이콘이나 버튼과 같은 요소에 사용될 수 있습니다.\n\n![이미지](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_16.png)\n\n![이미지](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_17.png)\n\n## 색상 관리\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n많은 Figma 플러그인이 있어서 색상 관리에 도움이 되는데요:\n\n- Color Palette Generator는 제공하는 단일 색상을 기반으로 색 팔레트를 생성합니다.\n- Color Contrast Checker는 두 색상 사이의 대조 비율을 확인하여 색상 선택이 접근성 지침을 준수하는지 확인하는 데 도움을 줍니다.\n- Colorblind Simulator을 사용하면 특정 유형의 색상 시각 결여를 가진 사람이 볼 때 디자인을 확인할 수 있습니다. 이를 통해 디자인이 모든 사용자에게 접근 가능한지 확인할 수 있습니다.\n- Dark Mode Magic을 사용하면 생성한 Light 테마를 기반으로 Dark 테마를 생성할 수 있습니다.\n\n# Typography\n\nApple은 San Francisco와 New York과 같은 내장된 글꼴 모음을 가지고 있습니다.\nSan Francisco에는 SF Pro를 포함한 여러 가지 변형이 있으며, SF Pro는 해당 글꼴의 표준 버전입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n원하는 경우 사용자 정의 글꼴을 계속 사용할 수 있습니다. 몇 가지 고려해야 할 사항이 있습니다:\n\n- 글꼴이 가독성이 좋도록 해야 합니다. 가독성에 영향을 미치는 요소에는 문자 인식, 선 두께(문자를 구성하는 선의 두께), 트래킹(글자 간격), 리딩(줄 간격), 글꼴 크기 및 글꼴 스타일이 있습니다.\n- 모바일 앱에서 최대 두 가지 글꼴을 사용하여 간단하고 조화로운 인터페이스를 유지하는 것이 좋습니다.\n- 글꼴이 서로 어떻게 보왁 주위서 상치하는지를 고려하는 것이 중요합니다. 서로 너무 비슷한 글꼴 유형을 결합하는 것을 피해야 하며, 그렇지 않으면 서로 구별하기 어려울 수 있습니다.\n\nGoogle Fonts를 사용하여 다른 글꼴 조합을 미리보기하는 것을 고려해보세요. 또한 Figma가 제작한 준비된 Google 글꼴 유형 조합 팔레트를 사용할 수도 있습니다.\n\n## 글꼴 스타일 및 글꼴 크기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다양한 글꼴 크기와 굵기를 사용하여 제목, 헤딩, 본문 텍스트 및 캡션이란 텍스트 스타일을 구분합니다. 기본적으로 iOS에는 Large Title, Title 1, Title 2 등과 같은 미리 정의된 텍스트 스타일이 있습니다. 이러한 텍스트 스타일마다 기본 글꼴 크기와 다이나믹 타입 크기가 부여됩니다.\n\n다이나믹 타입은 iOS의 기능 중 하나로, 사용자가 앱 내 텍스트의 글꼴 크기를 조절할 수 있습니다. 사용자 정의 글꼴을 사용하려는 경우 기본 글꼴 크기뿐만 아니라, 다이나믹 타입 크기도 코드 수준에서 정의되어야 사용자가 텍스트의 글꼴 크기를 조절할 수 있도록 보장해야 합니다.\n\n사용자 정의 글꼴 스타일에 대해 기본 글꼴 크기를 선택하는 가이드로 다음 표를 고려해 보세요.\n\n![표](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_18.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 텍스트 레이아웃\n\n트래킹과 리딩은 최적의 가독성과 가시성을 위해 텍스트 레이아웃을 세밀하게 조정할 수 있는 필수적인 텍스트 속성입니다.\n\n트래킹은 글자 사이의 간격을 의미합니다. CSS에서는 \"letter-spacing\"으로 불리며, 트래킹과 letter-spacing은 동의어입니다.\n\n리딩은 텍스트 줄 사이의 간격을 말합니다. Figma와 CSS에서는 이 속성을 \"line-height\"라고 합니다. 줄 간격을 늘리거나 줄이는 것은 가독성을 향상시키는 데 도움이 될 수 있습니다. 리딩은 텍스트 기준선부터 측정됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n👉 추적 및 리딩에 대한 몇 가지 팁:\n\n- 가독성을 높이려면 리딩을 증가시키세요. Figma는 가독성 있는 텍스트를 얻기 위한 최소한의 라인 높이로서 글꼴 크기의 1.125배(112.5%)로 설정할 것을 권장합니다. 그러나 값은 글꼴에 따라 다를 수 있습니다. 예를 들어, Apple은 본문 텍스트(SF Pro 글꼴)를 위한 리딩을 129%(22 pt)로 최소값으로 정의합니다. 그러나 긴 문단의 텍스트에 대한 좋은 가독성을 얻고 싶은 경우 141%(24 pt)로 리딩을 증가시키는 것을 권장합니다.\n\n![이미지](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_19.png)\n\n- 좋은 가독성을 유지하려면 폰트 크기에 대한 추적 값을 너무 높거나 너무 낮게 사용하는 것을 피하는 것이 좋습니다. 시스템 글꼴의 최적 추적 값을 설명하는 Apple의 추적 테이블을 참고할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_20.png\" />\n\n# 아이콘\n\n아이콘은 인터페이스 항목, 작업 및 상태의 의미를 전달해야 하는 그래픽 요소입니다. 효과적인 아이콘은 사용자에게 간단하고 익숙하며 이해하기 쉬워야 합니다.\n\niOS에는 iOS 앱에서 사용할 수 있는 벡터 아이콘(SF Symbols) 세트가 제공됩니다. 여기 SF Symbols를 찾을 수 있는 Figma 파일이 있습니다. 또한 SF Symbols를 편집하고 사용자 정의하는 방법에 대한 상세한 비디오도 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\niOS 앱에서 아이콘을 사용할 때 몇 가지 팁:\n\n- 사용자 정의 아이콘을 사용하려면 일관된 스타일, 크기 및 두께를 유지하는지 확인하세요.\n\n![Custom Icons](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_21.png)\n\n- 아이콘의 명암비를 테스트하세요. W3C에 따르면 아이콘과 같은 \"그래픽 객체\"는 적어도 3:1의 명암비를 가져야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_22.png)\n\n- 아이콘이 한눈에 알아볼 수 없으면 가능한 경우 텍스트 레이블을 추가하세요. 아래 예시에서 Headspace가 텍스트 레이블이 없다면, 왼쪽 아이콘(Today)의 의미를 빠르게 이해하기 어려울 수 있습니다.\n\n![이미지](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_23.png)\n\n- 모든 표준 화면에서 작동할 수 있도록 SVG와 같은 벡터 형식의 아이콘을 사용하세요. 1배 해상도의 표준 화면과 2배, 3배 고해상도의 레티나 디스플레이에 모두 작동해야 합니다.\n- 아이콘은 가독성이 있고 탭하기 쉬워야 합니다.\n- 일반 탭 바 아이콘의 크기는 적어도 25x25pt이어야 하며, 내비게이션 바의 아이콘은 20x20 또는 30x30pt가 될 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\niOS 아이콘에 대한 자세한 정보는 Apple의 문서를 확인해보세요.\n\n# 구성 요소\n\niOS에는 다양한 종류의 구성 요소 라이브러리가 있습니다. 이들을 모두 문서에서 찾을 수 있습니다. 여기서는 거의 모든 iOS 모바일 앱에서 찾을 수 있는 가장 인기 있는 세 가지 구성 요소 — 목록, 탭 바 및 네비게이션 바 — 에 대해 다루고, 각각에 대한 최선의 방법을 강조하고 싶습니다.\n\n## 목록과 표\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아이템의 컬렉션을 표시하는 방법으로 목록과 표가 있습니다. 이 아이템들은 텍스트, 아이콘/이미지 또는 텍스트와 선택 컨트롤의 조합일 수 있습니다.\n\n![Image 1](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_24.png)\n\n![Image 2](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_25.png)\n\n최선의 방법들\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 배경 전체에 다른 색상을 사용하여 배경과 콘텐츠 그룹 간의 시각적 대조를 만드세요.\n\n![Image](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_26.png)\n\n- 테이블 콘텐츠를 논리적 그룹으로 분할하고 시각적으로 구분할 수 있도록 제목을 추가하세요. 이렇게 하면 사용자가 테이블에서 특정 항목을 쉽게 찾을 수 있습니다.\n\n![Image](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_27.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n마크다운 형식으로 테이블 태그를 변경해주세요.\n\n- 표 태그는 유사한 글꼴 스타일을 제목과 행 제목에 사용하지 마세요. 그렇게 하면 사용자가 컨텐츠 그룹을 구별하기 어려워질 수 있습니다.\n\n![image](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_28.png)\n\n## 탭 바\n\n탭 바는 앱 내에서 다른 뷰로 전환할 수 있게 해주는 전역 탐색 컨트롤입니다. 각 탭은 의미 있고 설명적이어야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n**최상의 방법**\n\n- \"Home\" 또는 \"Overview\"와 같은 단일 탭에 관련 없는 콘텐츠를 그룹화하는 것을 피하세요. 예를 들어, 아래 이미지는 \"Home\" 탭이 \"검색\", \"즐겨찾기\", \"친구\"와 같은 관련 없는 기능을 결합한 것을 보여줍니다. 이는 사용자가 필요한 것을 찾기 어렵게 만듭니다. 이러한 문제를 해결하기 위해 핵심 기능과 섹션을 식별하여 콘텐츠를 각각 다른 탭으로 분리하고 관련된 콘텐츠만 그룹화하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 테이블 태그를 Markdown 형식으로 변경해주세요.\n\n![Image](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_31.png)\n\n## 내비게이션 바\n\n내비게이션 바는 앱의 계층 구조를 통해 탐색할 수 있는 탐색 컨트롤입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_32.png)\n\n최상의 사용법\n\n- 네비게이션 바에 너무 많은 작업을 추가하는 것은 인터페이스를 지저분하게 만듭니다.\n\n![이미지](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_33.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 네비게이션 바와 필터, 세그먼트 컨트롤 등과 같은 다른 요소 간에 충분한 대조가 있는지 확인합니다.\n\n![이미지](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_34.png)\n\n# 전환\n\n전환은 한 뷰 또는 뷰 세트의 외관을 다른 것으로 변경하는 방법입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/1*-TfC1w0q9QTAExsVkopbGg.gif\" />\n\niOS는 일련의 표준 전환 스타일을 제공합니다. 사용자가 적응하는 데 추가 노력을 필요로 하는 것을 방지하기 위해 사용자 정의 애니메이션을 생성하려면 iOS 표준 스타일을 따르도록 확인하십시오. 그렇지 않으면 사용자 만족도가 감소할 수 있습니다.\n\n기억해야 할 권장 사항:\n\n- 사용자에게 혼란을 야기할 수 있는 복잡하거나 화려한 전환을 사용하지 마세요.\n- 일관된 지속 시간과 타임팅을 사용하여 사용자에게 부드럽고 연속적인 경험을 제공하세요.\n- 사용자의 주의를 산만하게 하는 너무 빠르거나 너무 느린 전환을 사용하지 마세요.\n- 코드 수준에서, 사용자 지정 전환은 \"모션 줄이기\"가 꺼져 있을 때 접근성 설정에 응답할 수 있도록 해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n코드 없이 사용자 정의 전환을 만들 수 있는 몇 가지 도구:\n\n- LottieFiles\n- ProtoPie\n- Flow\n\n# 결론\n\n이 글이 도움이 되었기를 바랍니다. 주제에 대한 피드백이나 제안이 있으면 기쁠 것입니다!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n👉 새 YouTube 채널 구독해보세요! UX/UI 디자인 통찰과 팁에 관한 영상을 만나보세요.\n\nLinkedIn에서 연락 주시거나 Twitter에서 팔로우해주세요. 감사합니다!\n","ogImage":{"url":"/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_0.png"},"coverImage":"/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_0.png","tag":["Tech"],"readingTime":20}],"page":"3","totalPageCount":113,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true}