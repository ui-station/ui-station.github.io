{"pageProps":{"posts":[{"title":"맥OS에서 RVM 설치하기 단계별로","description":"","date":"2024-05-17 17:46","slug":"2024-05-17-InstallRVMinmacOSstepbystep","content":"\n오직 나 한테만 말하고 싶어서 죄송한데, 덕분에 글쓰기를 멈출 수가 없어 😛\n\n# 필수 준비물\n\n- Homebrew 🍺\n\n# 시작해봅시다!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n1. GnuPG 설치\n\n```bash\n$ brew install gnupg\n```\n\n2. GPG 키 설치 (첫 번째 방법 또는 두 번째 방법 중 선택)\n\n2.1 첫 번째 방법\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n$ gpg --keyserver hkp://pool.sks-keyservers.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3 7D2BAF1CF37B13E2069D6956105BD0E739499BDB\n\n2.2 Second way\n\n$ gpg --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3 7D2BAF1CF37B13E2069D6956105BD0E739499BDB\n\n3. Install RVM\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n$ \\curl -sSL https://get.rvm.io | bash\n```\n\n4. 콘솔에서 감사 메시지 🙏를 받게 됩니다.\n\n5. 모든 터미널을 종료하세요.\n\n6. 새 터미널을 열고 이겼어요! 해보세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n$ rvm 리스트\n```\n\n7. 이 메시지가 나타납니다.\n\n```js\n# 아직 rvm 루비가 설치되지 않았습니다. 'rvm 도움말 설치'를 시도해보세요.\n```\n\n8. 2.7.1과 같은 몇 가지 루비 버전을 설치하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 예전 버전인 2.3.1 등을 사용하고 싶다면 아래 팁 항목을 확인해주세요 😉\n- 버전 3 이상을 사용하고 싶다면 아래 루비 버전 3+에 대한 참고사항을 확인해주세요 😁\n\n```bash\n$ rvm install 2.7.1\n```\n\n9. 설치가 완료된 후 사용 가능한 루비 버전을 확인해보세요.\n\n```bash\n$ rvm list\nruby-2.7.1 [ x86_64 ]\n# 기본 루비가 설정되지 않았습니다. 'rvm alias create default <ruby>'를 시도해보세요.\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n10. 기본 루비 버전을 만듭니다\n\n```js\n$ rvm alias create default 2.7.1\n```\n\n11. 그게 다에요! 즐겨주세요 🎉\n\n# 팁 💡\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n루비의 이전 버전을 사용하는 경우, openssl과 관련된 아래와 같은 오류 메시지가 발생할 수 있습니다.\n\n```\n\n/Users/pagorn/.rvm/src/rubygems-3.0.8/lib/rubygems/core_ext/kernel_require.rb:54:in `require': cannot load such file -- openssl (LoadError)\n\n따라서, rvm에서 openssl을 설치한 다음 이 openssl을 사용하여 이전 버전의 루비를 설치해야 합니다.\n\n$ rvm pkg install openssl\n$ rvm install 2.3.1 --with-openssl-dir=$HOME/.rvm/usr\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# Ruby 버전 3+에 대한 참고 사항\n\n루비 v3를 설치할 때는 특정 openssl 위치를 지정해야 할 수 있습니다.\n\n설치하기 전에 openssl 위치를 확인해주세요.\n\n- 위치 A\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n$ ls /usr/local/opt | grep openssl\nopenssl\nopenssl@1.1\nopenssl@3\nopenssl@3.1\n```\n\n```js\n$ rvm install ruby-3.1.0 --with-openssl-dir=/usr/local/opt/openssl@3.1\n```\n\n- 위치 B\n\n```js\n$ ls /opt/homebrew/opt | grep openssl\nopenssl\nopenssl@1.1\nopenssl@3\nopenssl@3.1\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n$ rvm install ruby-3.1.0 --with-openssl-dir=/opt/homebrew/opt/openssl@3.1\n```\n\n# 참고 자료\n\n- https://formulae.brew.sh/formula/gnupg\n- https://rvm.io/\n- https://stackoverflow.com/questions/54895263/how-to-install-gpg2-via-homebrew\n- https://github.com/rvm/rvm/issues/4607#issuecomment-619422100\n- https://github.com/rvm/rvm/issues/4607#issuecomment-621343322\n- https://mac.install.guide/homebrew/3.html\n","ogImage":{"url":"/assets/img/2024-05-17-InstallRVMinmacOSstepbystep_0.png"},"coverImage":"/assets/img/2024-05-17-InstallRVMinmacOSstepbystep_0.png","tag":["Tech"],"readingTime":5},{"title":"왜 PEDAC를 좋아하지 않을 수도 있을 것입니다","description":"","date":"2024-05-17 17:44","slug":"2024-05-17-WhyYouWontLikePEDAC","content":"\n## PEDAC는 정말 어렵죠. 그렇다고 말했어요.\n\n![image](/assets/img/2024-05-17-WhyYouWontLikePEDAC_0.png)\n\n시간 낭비 같아요.\n직관적이지 않고 어색하게 느껴져요.\n배울 수 없는 것처럼 느껴져요.\n\n최소한 처음에는 이런 느낌입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n본문을 마칠 즈음, 저는 PEDAC 및 문제 해결 과정 전체에 대해 학습하는 동안 동기부여를 잃은 사람들, 정체감을 느끼는 사람들, \"연기자 증후군\"에 대한 새로운 동기 부여를 주고 PEDAC에 대한 진정한 감사함과 개선 팁을 제공하기를 희망합니다.\n\n## 이 기사에서는 다음과 같은 내용을 다룰 것입니다:\n\n- 시작과 현재의 차이\n- 학습에 어려움을 겪는 이유 및 극복 방법\n- 동기를 유지하고 더 효과적으로 학습하는 데 도움이 된 정신적 변화\n- 코딩 자체보다 그것을 사랑하는 방법 (결국 빠르게 학습하고 더 나은 문제 해결자가 되는 데 도움이 될 것입니다)\n\n# 개인 이야기:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저는 현재 Launch School이라는 온라인 커리큘럼에 등록되어 있습니다. 이 학교는 견고한 문제 해결 프로세스를 개발하는 데 큰 중점을 둡니다. 그들은 여러분이 프로세스를 개발하는 데 도움을 주는 PEDAC라는 프레임워크를 소개합니다.\n\nLaunch School을 시작하기 한 해 전에 프로그래밍 기초를 공부했었지만, 문제 해결에는 전혀 손 대지 못했습니다. Code Wars의 초급 연습 문제를 시도해보지만 해결하지 못했죠.\n\n이는 매우 흐뭇했고, 다른 사람들 대부분이 이러한 \"쉬운\" 질문들을 해결할 수 있다는 것을 알면서 상처받았습니다. 1년 넘는 공부 끝에 한 문제도 거의 해결하지 못했기 때문이죠. 그러나 문제 해결 프로세스에 주력한 후에는 이제 초보자 및 중급 수준의 많은 문제들을 자신 있게 쉽게 해결할 수 있게 되었습니다.\n\n이 일은 단 몇 주 만에 일어난 일입니다. 만약 자신감을 잃고 이 보기 어렵고 복잡한 문제들을 쉽게 해결할 수 있는 사람으로 스스로 그릴 수 없다면 — 두려워하지 마세요, 왜냐하면 몇 달 전에 저도 그 똑같은 고비를 넘었기 때문이죠.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/assets/img/2024-05-17-WhyYouWontLikePEDAC_1.png)\n\n# 이 공부가 어색하게 느껴지는 이유\n\n내가 소속된 동료들 중 대부분이 불편해하는 가장 큰 문제 중 하나는 공포의 \"Hack 'n' Slash\" 접근 방식입니다.\n\n이 문제를 지적하면서도, 우리는 여전히 의도적이거나 계획적인 다른 방식을 취하는 것을 싫어합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n왜 그럴까요?\n\n## 익숙하지 않아서 생산성이 떨어지는 기분이 들어요.\n\n지금까지 대부분의 문제는 복잡도가 낮았습니다. 당장 들어가서 코딩을 시작할 수 있어요. 더 흥미롭고 당신이 더 빨리 성취감을 느끼게 되죠.\n\n지금까지의 경험은 이랬어요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n가장 빨리 작업을 완료하는 데 도움이 되는 방법이죠... 지금까지는요.\n\n문제를 시작할 때 문제 자체에 대해 생각하고 긴 해결책을 쓰는 것은 지금까지 우리가 문제를 해결해 오던 방식과 대립됩니다.\n\n이것도 완전히 이해가 가죠. 처음에는 기본 개념과 언어 능숙도를 개발하는 데 중점을 두죠. 새로운 개념을 실용적인 방식으로 학습하기 위해 기본적이고 쉬운 문제를 해결해야 합니다.\n\n이것이 'PEDAC 학습에 마찰력을 일으키는 데 기여하는 몇 가지를 한다고 생각합니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 더 쉬운 문제들은 보통 나에게 보상을 더 빨리 줬어. 나는 해결책에 더 빨리 도달했어.\n- 이는 향후 소프트웨어 엔지니어링 문제에 필요한 해결책과 기술에 대한 기대감을 형성할 수 있어요.\n\n정신적 변화:\n\n- PEDAC가 일반적으로 더 효율적인 방법이라는 것을 상기해봐, 비록 그렇게 느껴지지 않아도. 문제의 난이도가 증가할수록 더욱 참된 이치가 된다.\n- 문제 해결에 걸리는 시간에 대한 기대를 재조정해봐. 문제가 어려워질수록 문제 해결에 필요한 시간이 증가한다. 이것은 정상적이야.\n- 기억해, 당신이 PEDAC를 더 효율적으로 여기는 아이디어를 받아들일 때까지 첫 번째 여러 문제와 시도에서 이런 느낌을 가질 것이라는 걸 기억해봐. 감정에도 불구하고 과정을 믿어봐.\n- 이런 느낌들은 좋은 징조일 수 있어. 당신이 배우고 있고 당신의 두뇌가 문제 해결 머신이 되도록 재배열되고 있는 신호야. 당신의 두뇌는 변하고 변화는 노력을 필요로해. 어느 정도의 정신적 마찰을 겪을 것으로 예상돼.\n\n## 지루하고 동기부여가 되지 않는 느낌을 받을지도 모르지만... 이것은 변할 수 있어요!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n지금까지 학습 과정은 매우 간단해 왔어요:\n\n- 새로운 개념을 배우고 개념 모델을 개발합니다.\n- 구문과 새로운 용어를 암기합니다.\n- 배운 개념을 기초 문제로 테스트합니다.\n- 문제를 해결하면 치즈를 얻게 돼요 🧀\n\n![이미지](/assets/img/2024-05-17-WhyYouWontLikePEDAC_2.png)\n\n우리는 초기에는 치즈를 더 자주 먹고 쉽게 먹어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n런치 스쿨 커리큘럼에서 말하는 대로, 문제를 해결하는 유일한 방법은 없으며 PEDAC는 단지 당신만의 문제 해결 과정을 찾기 위한 지침일 뿐입니다.\n\n새로운 수업은 이전과 같은 경험이 아닙니다.\n그것은 규칙이나 메타모델 또는 외워야 하는 문법이 아닙니다. 오히려 당신이 운동을 하며 개발해야 하는 근육과 유사합니다.\n\n이 새로운 수업은 기억력과 정의보다는 내면적 사색, 검토 및 실험을 더 필요로 합니다.\n\n처음에는 개념 또는 용어를 손에 익힌 것을 알 수 있었던 때입니다. 그때 당신은 그 정의를 정확히 알고 코드에서 예제를 보여주고 이해할 수 있을 때였습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nPEDAC를 이해했다고 어떻게 알 수 있을까요?\n\n그 답변은 확실하지 않습니다. 현재 이해와 비교할 문서나 코드 예제가 없습니다. 구문에서 PEDAC를 식별할 수 있는 코드 예제가 없습니다.\n\n이는 최종 목표가 조금 덜 확실하기 때문에 두려울 수 있습니다.\n\n\"내가 이것을 알고 있다는 것을 어떻게 알까요?\"\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n처음으로 PEDAC를 배우려고 시도했을 때 저는 매우 동기 부여가 떨어지고 사기가 떨어지는 느낌을 받았어요. 보상이 명확하지 않았고, 내가 진행 중인지 알 수 없는 것 같았어요.\n\n내가 본 것은 다른 사람들이 자신들만의 방법으로 문제를 효율적으로 해결하는 모습 뿐이었는데, 한 번에 \"이게 바로 네가 해야 하는 방법이야, 여기가 정의야\" 라는 순간을 찾지 못했어요. 이로 인해 PEDAC는 당신과 맞지 않는 것인 것 처럼 느껴질 수 있고, 그것을 이해하기 어려울 수 있어요.\n\n기본 사고 변경:\n\n- \"이게 바로 네가 해야 하는 방법이야\" 순간을 찾으려 하지 마세요. PEDAC는 시간이 지나면서 발견하는 것이며, 야생에서 찾아낼 수 있는 것이 아닙니다.\n- 진행 중이지 않다는 느낌을 받을 것입니다. 그건 정상적인 것이니 마음에 두세요.\n- PEDAC는 운동과 같습니다. x 개의 팔 굽혀 펴기를 하고 근육이 붙는 것이 아닙니다. 하루하루 변화를 알아차리지 못할 것입니다. 하지만 꾸준하게 계속하면 언젠가는 당신도 멋진 프로그래머가 될 거에요 💪\n- 문제를 이전처럼 빠른 속도로 해결하는 보상은 받지 못할 것입니다. 그러나 문제들이 어려워지면(좋은 치즈처럼) 더 큰 보상을 받을 수 있습니다. 단지 좀 더 빈도가 낮을 뿐이에요.\n- 꾸준하게 하고 프로세스를 신뢰하세요. 당신은 진전하고 있어요!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/assets/img/2024-05-17-WhyYouWontLikePEDAC_3.png)\n\n## \"어떻게 하면 PEDAC을 좋아할 수 있을까요?\"\n\n상상하기 어렵지만, 언젠간 그렇게 될 거예요.\n결국, 당신도 PEDAC를 정말 좋아하게 될 거예요.\n\n언젠가는 이런 변화가 올 거라는 것에 대해 알고 있는 것이 때로는 동기부여를 유지하는 데 도움이 되었어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## PEDAC을 코딩할 때의 \"안전한 장소\"로 생각해보세요\n\n버그와 오류는 코딩을 시작할 때 발생합니다.\n\n코딩 전 단계는 실수와 논리 오류를 만드는 안전한 장소입니다. 처음에 모든 것을 완벽하게 이해할 필요는 없고, 첫 시도에서 로직을 완벽하게 이해해야 하는 것도 중요하지 않습니다. 중요한 것은 과정에 대해 의식적이고 의도적이라는 것입니다.\n\n코딩 도중에 해결 방법을 코딩하다가 터미널에서 오류 메시지를 읽기만으로 해결할 수 없는 오류를 마주했을 때 가장 싫은 상황이라고 할 수 있습니다. 논리 오류를 수정하는 것은 문법 오류나 타입 오류를 고치는 것보다 어려운 작업입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n지금은 와닿지 않을 수 있지만, PEDAC를 더 자주 사용함으로써 더 많이 이해할 수 있게 될 거에요.\n\n## 더 큰 그림을 기억하고 여러분이 여기 있는 이유를 기억하세요\n\n코딩을 하는 것이 재미있게 만드는 주요한 부분은 코드를 입력하는 것이 아니라 문제 해결이라는 것을 스스로 상기하세요.\n\n쉬운 문제에 코드를 작성하는 것은 지루해질 수 있어요. 최적으로 도전적인 문제에 코드를 작성하는 것이 즐거움을 느끼는 때입니다. 문제 해결에 열중할 때 (심지어 힘들 때도) 코드 편집기 바깥에 무슨 일이 일어나고 있는지 생각하지 않는다는 것을 주목하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이게 당연한 것 같지만, 학습하고 문제 해결하는 걸 즐기는 걸 생각해봐. 그래야 현재에 더 집중할 수 있을 거야. 이걸 알면 당신의 난관을 이해하는 데 도움이 될 거야.\n\n큰 그림을 보면, 이전과 똑같은 일을 하고 있지만 세부사항이 다를 뿐이야.\n\n그리고 난관에 부딪히는 건 문제가 아님을 알아둬, 이는 아마도 새로운 방식으로 최적의 도전을 받고 있는 신호에 불과할 거야. 새로운 문제와 새로운 세부사항이 있지만 궁극적으로는 여전히 당신을 지탱하는 문제 해결이야.\n\n언제나 글쓰기를 개선하려고 노력하고 있어, 그래서 이 글에 동의하든 반대하든, 도움이 되었든 그렇지 않았든 당신의 피드백을 정말로 감사히 받겠어.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저도 다른 사람들이 PEDAC를 배우면서 느낀 경험을 듣고 싶어요. 댓글을 남기거나 제 소셜 미디어로 DM을 보내도 괜찮아요.\n\n도움이 되었으면 좋겠어요! 행복한 PEDAC 공부 되세요 👨‍💻\n","ogImage":{"url":"/assets/img/2024-05-17-WhyYouWontLikePEDAC_0.png"},"coverImage":"/assets/img/2024-05-17-WhyYouWontLikePEDAC_0.png","tag":["Tech"],"readingTime":9},{"title":"자바 SpringBoot를 사용한 JSON 스키마 유효성 검사기","description":"","date":"2024-05-17 17:43","slug":"2024-05-17-JSONSchemaValidatorusingJavaSpringBoot","content":"\n## Json 스키마란 무엇인가요?\n\nJSON Schema은 선언적 언어입니다. 이는 우리 서비스에 특정한 json 구조를 정의하고 유효성을 검사합니다. 주어진 json 데이터에 대한 표준 구조로 여러 시스템에서 사용할 수 있습니다. 자세한 내용은 여기를 참조하세요: what-is-jsonschema?\n\n## Json 스키마를 사용하는 이유는 무엇인가요?\n\n대부분의 경우, 서비스에서 들어오는 json을 유효성 검사하는 것이 필요합니다. 간단한 json은 속성에 제약 조건을 적용하여 POJO 또는 모델에 매핑할 때 유효성을 검사할 수 있습니다. 그러나 때로는 json이 복잡하여 이러한 제약 조건을 사용하여 모든 필드를 유효성을 검사할 수 없는 경우가 있습니다. JsonSchema를 사용하면 표준화된 구조를 사용하여 복잡한 json을 유효성을 검사할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 내용:\n\nSpringBoot와 Json Schema를 사용하는 단계별 가이드입니다. 이를 위해 networknt 라이브러리를 사용할 것입니다. 단계를 거친 후에는 테스트를 위해 수신된 json에 대한 몇 가지 시나리오가 있습니다.\n\n참고: 이 문서는 SpringBoot와 JsonSchema의 사용을 위한 것입니다. 이는 JsonSchema의 일부 기능 및 사용법에 대해 가르치기 위한 것입니다.\n\n## 1. SpringBoot 웹 애플리케이션을 생성하세요: https://start.spring.io/\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![image](/assets/img/2024-05-17-JSONSchemaValidatorusingJavaSpringBoot_0.png)\n\n알림: spring-boot 및 java의 모든 버전 및 프로젝트 유형을 선택할 수 있습니다.\n\n## 2. pom.xml 또는 build.gradle에 종속성 추가.\n\n```js\n<--\npom.xml\nhttps://mvnrepository.com/artifact/com.networknt/json-schema-validator\n-->\n<dependency>\n  <groupId>com.networknt</groupId>\n  <artifactId>json-schema-validator</artifactId>\n  <version>1.4.0</version>\n</dependency>\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n// build.gradle\n// https://mvnrepository.com/artifact/com.networknt/json-schema-validator\nimplementation 'com.networknt:json-schema-validator:1.4.0'\n```\n\n## 3. 리소스 유효성 검사 JSON 파일을 생성합니다.\n\n```js\n{\n \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n    \"title\": \"Order Event\",\n    \"description\": \"예제용 주문 이벤트 스키마\",\n    \"required\": [\"order_id\", \"total_price\", \"products\" ],\n    \"properties\": {\n       \"order_id\": {\n          \"type\": \"string\"\n        },\n        \"event\": {\n          \"enum\": [\"PLACED\", \"DELIVERED\", \"RETURNED\"],\n          \"type\": \"string\"\n        },\n        \"total_price\": {\n         \"type\": \"number\",\n             \"minimum\": 0\n     },\n        \"products\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"additionalProperties\": true,\n        \"required\": [\"product_id\", \"price\"],\n        \"minItems\": 1,\n        \"properties\": {\n          \"product_id\": {\n            \"type\": \"string\"\n          },\n          \"price\": {\n            \"type\": \"number\",\n            \"minimum\": 0\n          },\n          \"quantity\": {\n            \"type\": \"integer\"\n          }\n        }\n      }\n    }\n   }\n}\n```\n\n## 4. JsonSchema 빈을 생성합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n호출자 메서드에서는 JsonSchema 객체를 직접 생성할 수 있지만, 빈을 생성하고 사용하는 것을 권장합니다.\n\n```java\n@Configuration\npublic class AppConfiguration {\n    private static final String SCHEMA_VALIDATION_FILE = \"validation.json\";\n\n    @Bean\n    public JsonSchema jsonSchema() {\n        return JsonSchemaFactory\n                .getInstance( SpecVersion.VersionFlag.V7 )\n                .getSchema( getClass().getResourceAsStream( SCHEMA_VALIDATION_FILE ) );\n    }\n}\n```\n\n## 5. JsonSchema 사용법\n\n이제 JsonSchema 객체를 사용해보겠습니다. JsonNode를 매개변수로 사용하는 메서드가 있는 Service 클래스를 만들겠습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```java\n@Slf4j\n@Service\npublic class JsonSchemaValidationService{\n\n  @Autowired\n  private JsonSchema jsonSchema;\n\n  public String validateJson(JsonNode jsonNode){\n\n    Set<ValidationMessage> errors = jsonSchema.validate(jsonNode);\n    //if errors have a single miss match, there would be a value in the errors set.\n    if(errors.isEmpty()){\n      //event is valid.\n      log.info(\"event is valid\");\n    }else{\n        //event is in_valid.\n      log.info(\"event is invalid\");\n     }\n      return errors.toString();\n  }\n}\n```\n\n## 6. Create a Rest Controller.\n\n```java\nimport com.fasterxml.jackson.databind.JsonNode;\n@RestController\npublic class JsonSchemaController {\n    @Autowired\n    private JsonSchemaValidationService service;\n\n    @PostMapping(\"/validate\")\n    public String validateEvent( @RequestBody JsonNode jsonNode ){\n       return service.validateJson(jsonNode);\n    }\n}\n```\n\n## 7. Start the SpringBoot Application and start sending requests.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 모든 것이 준비되었으니, 즐겨 사용하는 클라이언트를 사용하여 코드를 테스트할 수 있습니다. 저는 PostMan을 사용하고 있어요. 아래에서 유효한 이벤트로 시작해보겠습니다.\n\n```js\n# 유효한 데이터\ncurl --location 'localhost:8080/validate' \\\n--header 'Content-Type: application/json' \\\n--data '{\n  \"order_id\":\"order134\",\n   \"event\": \"PLACED\",\n   \"products\": [\n     {\n       \"product_id\": \"product_1\",\n        \"price\":20.5,\n       \"quantity\":2\n     }\n   ],\n   \"total_price\": 41\n}'\n```\n\n응답:\n\n```js\n[];\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n# order id 없는 페이로드\ncurl --location 'localhost:8080/validate' \\\n--header 'Content-Type: application/json' \\\n--data '{\n   \"event\": \"PLACED\",\n   \"products\": [\n     {\n       \"product_id\": \"product_1\",\n        \"price\":20.5,\n       \"quantity\":2\n     }\n   ],\n   \"total_price\": 41\n}'\n```\n\n응답 :\n\n```js\n[$.order_id: 필수 항목이지만 누락되었습니다]\n```\n\n```js\n# order id 없는 페이로드\ncurl --location 'localhost:8080/validate' \\\n--header 'Content-Type: application/json' \\\n--data '{\n\"order_id\":\"order134\",\n   \"event\": \"PLACED\",\n   \"total_price\": 41\n}'\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n[$.products: is missing but it is required]\n```\n\n```js\n# order id가 없는 payload\ncurl --location 'localhost:8080/validate' \\\n--header 'Content-Type: application/json' \\\n--data '{\n \"order_id\" : \"order_123\",\n   \"event\": \"PLACED\",\n   \"products\": [\n\n   ],\n   \"total_price\": 41\n}'\n```\n\n응답 :\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n[$.products: 배열에는 최소 1개의 항목이 있어야 합니다.]\n```\n\n<img src=\"/assets/img/2024-05-17-JSONSchemaValidatorusingJavaSpringBoot_1.png\" />\n","ogImage":{"url":"/assets/img/2024-05-17-JSONSchemaValidatorusingJavaSpringBoot_0.png"},"coverImage":"/assets/img/2024-05-17-JSONSchemaValidatorusingJavaSpringBoot_0.png","tag":["Tech"],"readingTime":8},{"title":"국영세대 ZGC로 일시 중지 시간을 제어하세요","description":"","date":"2024-05-17 17:41","slug":"2024-05-17-BendingpausetimestoyourwillwithGenerationalZGC","content":"\nZ Garbage Collector 세대의 놀라운 혜택과 그리 놀라운 혜택.\n\nDanny Thomas가 쓴 JVM 에코시스템 팀의 기사\n\n![GenerationalZGC](/assets/img/2024-05-17-BendingpausetimestoyourwillwithGenerationalZGC_0.png)\n\n최신 장기 지원 릴리스인 JDK는 Z Garbage Collector를 위한 세대 지원을 제공합니다. Netflix는 주요 이유로 동시 가비지 수집의 중요한 혜택을 인한 것으로, JDK 21 및 그 이후부터 G1에서 Generational ZGC로 기본 전환했습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저희 핵심 스트리밍 비디오 서비스 중 절반 이상이 Generational ZGC와 JDK 21에서 실행 중이에요. 이제 제 경험과 얻은 혜택에 대해 이야기할 때가 좋아졌네요. Netflix에서 Java를 어떻게 사용하는지 궁금하시다면, Paul Bakker의 강연인 'Netflix가 정말로 Java를 사용하는 방법'이 좋은 시작점이 될 거예요.\n\n# Tail Latency 감소\n\n저희 GRPC와 DGS 프레임워크 서비스에서 GC 일시 중단은 Tail Latency의 중요한 원인 중 하나에요. 특히 GRPC 클라이언트와 서버에서는 시간 초과로 인한 요청 취소가 재시도, 헤징 및 폴백과 같은 신뢰성 기능과 상호작용하죠. 이러한 에러마다 요청이 취소되어 재시도되는 것인데, 이런 감소로 인해 전체 서비스 트래픽이 더욱 줄어들었어요:\n\n![이미지](/assets/img/2024-05-17-BendingpausetimestoyourwillwithGenerationalZGC_1.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n잦은 일시 정지의 소음을 제거하면 실제 지연 원천을 식별할 수 있어서 그렇지 않으면 소음에 감춰져 있을 수 있습니다. 최대 일시 중지 시간 이상치는 상당히 중요할 수 있습니다:\n\n![image](/assets/img/2024-05-17-BendingpausetimestoyourwillwithGenerationalZGC_2.png)\n\n# 효율\n\n평가 결과가 매우 유망하게 나타난 후에도 ZGC의 채택을 교환할 것으로 예상했습니다: 스토어 및 로드 버리어, 스레드 로컬 핸드셰이크에서 수행되는 작업 및 응용프로그램 자원 경합으로 인한 GC로 인해 약간의 응용프로그램 처리량이 줄어드는 경우. 우리는 그것을 수용 가능한 교환이라고 생각했는데, 일시 정지를 피함으로써 그 부가적인 오버헤드보다 더 큰 이점을 제공했습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n사실 우리의 서비스와 아키텍처에 대해 조사한 결과, 그러한 교환이 없다는 것을 발견했습니다. 특정 CPU 활용 목표에 대해 ZGC는 G1과 비교했을 때 평균 및 P99 대기 시간을 개선하면서 CPU 활용률도 동등하거나 더 나아진다는 것을 알 수 있었습니다.\n\n우리가 관찰한 많은 서비스에서 요청률, 요청 패턴, 응답 시간 및 할당률의 일관성이 ZGC를 도와주지만, ZGC가 덜 일관된 워크로드를 처리하는 능력도 뛰어나다는 것을 확인했습니다 (물론 예외는 있습니다; 자세한 내용은 아래에서 다루겠습니다).\n\n# 운영의 간편함\n\n서비스 소유자들은 종종 너무 긴 일시 중지 시간에 대한 질문이나 튜닝 도움을 요청합니다. 우리는 주기적으로 많은 양의 힙 데이터를 새로 고치는 여러 프레임워크를 보유하고 있어서 외부 서비스 호출을 효율적으로 피하기 위해 이를 사용합니다. 힙 데이터의 주기적 갱신으로 G1을 깜짝놀라게 하는 이러한 작업은 기본 일시 중지 시간 목표를 크게 넘는 이상값에 이르게 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 Markdown 형식으로 테이블을 변환한 것입니다.\n\n| Feature                | Description                                                                                                                                                                         |\n| ---------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Generational ZGC       | Improved CPU utilization by nearly 10% compared to G1 for the same workload.                                                                                                        |\n| Hollow library         | Used by half of the streaming video services for on-heap metadata, which led to the removal of array pooling mitigations and saved hundreds of megabytes of memory for allocations. |\n| Operational simplicity | ZGC's heuristics and defaults require no explicit tuning to achieve optimal results. Allocation stalls are rare and shorter than with G1.                                           |\n| Memory overhead        | The long-lived on-heap data was the main reason we previously avoided non-generational ZGC, but generational ZGC helped improve the situation significantly.                        |\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n힙의 압축된 참조를 잃어버리기 때문에 64비트 객체 포인터가 필요한 색상 포인터 때문에 32G의 힙에서 압축된 참조를 잃어버리는 것이 가비지 콜렉터 선택의 주요 요소가 될 것으로 예상했습니다.\n\n우리는 그것이 스탑-더-월드 GC들에 대해 중요한 고려 사항이긴 하지만, 작은 힙에서라도 할당 속도의 증가가 효율성과 운영 개선에 의해 상쇄된다는 점을 발견했습니다. 오라클의 Erik Österlund씨에게 감사드립니다. 동시 가비지 콜렉터에 있어서 색상 포인터의 직관적이지 않은 이점을 설명해 준 덕분에 우리는 초기 계획보다 ZGC를 더 폭넓게 평가하게 되었습니다.\n\n대부분의 경우 ZGC는 응용 프로그램에 더 많은 메모리를 일관되게 제공할 수도 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nZGC는 힙 크기의 3%에 대한 고정 오버헤드가 있어 G1보다 더 많은 원시 메모리를 필요로 합니다. 몇 가지 예외를 제외하고는 더 많은 여유 공간을 위해 최대 힙 크기를 낮출 필요가 없었으며, 그것들은 평균 이상의 원시 메모리 요구가 있는 서비스들이었습니다.\n\n참조 처리는 또한 ZGC에서 주요 콜렉션 시에만 수행됩니다. 직접 바이트 버퍼의 할당 해제에 특히 주의를 기울였지만, 지금까지는 영향을 볼 수 없었습니다. 이 참조 처리의 차이로 JSON 쓰레드 덤프 지원에서 성능 문제가 발생했지만, 이것은 프레임워크가 실수로 각 요청마다 사용되지 않는 ExecutorService 인스턴스를 생성하여 발생한 특이한 상황입니다.\n\n# Transparent huge pages\n\nZGC를 사용하지 않더라도 거대 페이지를 사용해야 할 것입니다. 투명 거대 페이지가 그들을 사용하는 가장 편리한 방법입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nZGC는 힙에 대해 공유 메모리를 사용하며, 많은 Linux 배포판에서는 shmem_enabled를 'never'로 설정하여 -XX:+UseTransparentHugePages를 사용하는 경우 ZGC가 거대 페이지를 사용하지 못하게 만듭니다.\n\n이렇게 변경된 부분을 제외하고 아무런 변경 없이 배포된 서비스가 있습니다. shmem_enabled가 'never'에서 'advise'로 변경되면 CPU 사용률이 저하되었습니다.\n\n아래는 기본 구성입니다:\n\n![이미지](/assets/img/2024-05-17-BendingpausetimestoyourwillwithGenerationalZGC_4.png)\n\n저희의 기본 구성:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 힙의 최소 및 최대를 같은 크기로 설정합니다.\n- -XX:+UseTransparentHugePages -XX:+AlwaysPreTouch을 구성합니다.\n- 다음과 같은 transparent_hugepage 구성을 사용합니다:\n\n```js\necho madvise | sudo tee /sys/kernel/mm/transparent_hugepage/enabled\necho advise | sudo tee /sys/kernel/mm/transparent_hugepage/shmem_enabled\necho defer | sudo tee /sys/kernel/mm/transparent_hugepage/defrag\necho 1 | sudo tee /sys/kernel/mm/transparent_hugepage/khugepaged/defrag\n```\n\n# 어떤 워크로드가 적합하지 않았나요?\n\n가장 좋은 가비지 컬렉터는 없습니다. 각각은 가비지 컬렉터의 목표에 따라 콜렉션 처리량, 응용프로그램 대기 시간 및 자원 이용을 교환합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nG1 대비 ZGC에서 더 나은 성능을 보인 작업 부하들은 대부분 처리량을 중심으로 한 경향이 있습니다. 매우 변덕스러운 할당 속도와 예측할 수 없는 기간 동안 객체를 보유하는 장기 실행 작업들이 포함되어 있습니다.\n\n한 가지 주목할만한 예시는 매우 변덕스러운 할당 속도와 많은 수의 고수명 객체를 가진 서비스였는데, 이는 G1의 일시 중지 시간 목표와 오래된 영역 수집 휴리스틱에 특히 적합했습니다. G1이 ZGC가 처리하지 못한 GC 사이클의 비생산적인 작업을 피할 수 있게 해주었습니다.\n\n기본적으로 ZGC로 전환함으로써 응용프로그램 소유자들이 가비지 수집기의 선택에 대해 고민할 수 있는 좋은 기회가 제공되었습니다. G1을 기본으로 사용하던 여러 배치/준비 계산 사례들이 병렬 수집기로부터 더 나은 처리량을 얻었을 것입니다. 대규모 준비 계산 작업에서는 G1 대비 응용프로그램 처리량이 6~8% 향상되어 배치 시간이 한 시간 단축되는 것을 확인할 수 있었습니다.\n\n# 직접 해보세요!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n가정과 기대를 의심하지 않으면, 우리는 10년 동안 우리의 운영 기본 설정 중 가장 영향력 있는 변화 중 하나를 놓치게 될 수 있습니다. 우리는 여러분께 직접 제너레이셔널 ZGC를 시도해 보라고 권장합니다. 여러분에게 우리가 놀란 만큼 놀라운 경험을 줄 수도 있습니다.\n","ogImage":{"url":"/assets/img/2024-05-17-BendingpausetimestoyourwillwithGenerationalZGC_0.png"},"coverImage":"/assets/img/2024-05-17-BendingpausetimestoyourwillwithGenerationalZGC_0.png","tag":["Tech"],"readingTime":9}],"page":"113","totalPageCount":113,"totalPageGroupCount":6,"lastPageGroup":13,"currentPageGroup":5},"__N_SSG":true}