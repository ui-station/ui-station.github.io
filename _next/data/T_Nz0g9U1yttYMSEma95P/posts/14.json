{"pageProps":{"posts":[{"title":"GSoC 2024 두 번째 주  FHIR 안드로이드 애플리케이션에 위치 통합하기","description":"","date":"2024-06-23 20:58","slug":"2024-06-23-GSoC2024Week2IntegratingLocationstoFHIRAndroidApplication","content":"\n안녕하세요 여러분! 👋\n\n모두가 행복한 한 주를 보내고 계시기를 바랍니다! 🌈 이번주는 저희 어플리케이션에 위치 기능을 통합하는 작업을 진행하면서 모험 가득한 한 주였어요. 이제 사용자들은 지정된 위치를 동기화하고 특정 위치를 선택하며 선택한 위치에 환자를 등록할 수 있어요. 자세한 내용을 알아보도록 하겠습니다! 🚀\n\n<img src=\"/assets/img/2024-06-23-GSoC2024Week2IntegratingLocationstoFHIRAndroidApplication_0.png\" />\n\n# 🌍 안드로이드 FHIR 어플리케이션에 위치 동기화하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n안녕하세요! 안드로이드 FHIR SDK의 엔진 라이브러리를 사용하여 FHIR 리소스를 로컬에 저장하고 서버와 동기화하고 있어요. OpenMRS는 위치 데이터를 FHIR 리소스로 저장하며, Download Work Manager의 구현에 URL 경로를 추가하기만 하면 됐어요.\n\n🔗 OpenMRS 위치 URL: Location?\\_summary=data&\\_tag=Login+Location\n\n나중에 한 번의 커밋에서 위치 URL을 첫 번째 인덱스로 이동했어요. 이 변경으로 위치가 먼저 로드되어 사용자가 환자 및 만남 데이터가 동기화되는 동안 선택할 수 있도록 되었어요. 효율성이 승리했네요! 🏆 이 변경 사항은 여기 커밋에서 확인할 수 있어요.\n\n# 📱 위치 선택 화면 만들기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n먼저, 홈 화면에서 선택 위치 화면으로 이동할 수 있는 옵션을 추가했어요. 🏠\n\n![이미지](/assets/img/2024-06-23-GSoC2024Week2IntegratingLocationstoFHIRAndroidApplication_1.png)\n\n선택 위치 화면은 현재 위치 세부 정보를 CardView에 보여주며, 드롭다운 메뉴를 통해 위치를 선택할 수 있도록 멋진 디자인으로 구성되어 있어요. 위치를 선택하면 현재 위치 세부 정보가 업데이트됩니다.\n\n이 세부 사항들은 앱 전체에서 쉽게 액세스하기 위해 데이터 저장소 환경 설정에 저장돼요. Location.id와 Location.name 두 가지가 모두 필요에 맞게 저장돼요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n처음에는 간단한 드롭다운을 계획했었지만, 멋진 멘토들의 통찰력 덕분에 사용자들이 수백 개의 위치를 가질 수 있다는 것을 깨달았어요. 그래서 최대한 편리하도록 드롭다운을 필터링 가능하게 만들었어요! 🛠️\n\n📝 이 변경 사항을 위한 커밋:\n\n- LocationViewModel 생성\n- 위치 POC의 초기 통합.\n\n# 🧭 앱 전반에 걸쳐 현재 위치 정보 통합하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리 멘토들의 소중한 안내 덕분에, 환자 등록 화면의 사이드 패널과 맨 위에 위치 정보를 추가했어요. 이 정보를 여러 곳에서 확인할 수 있으니 사용자들에게 정말 편리하고 저장된 데이터를 재확인할 수 있게 도와줘요. 🔍\n\n이제 사용자가 위치를 선택하기 전까지는 환자를 추가하는 네비게이션이 차단되어요. 또한 등록된 환자의 FHIR 환자 자원에는 사용자가 선택한 위치 자원이 포함될 거예요. 🎯\n\n📝 이 변경 사항에 대한 커밋 내역:\n\n- 등록된 새 환자를 차단하는 로직을 통합함\n- 위치 화면에 현재 위치를 추가함\n- (기능) 환자 추가 화면에 현재 위치 추가함\n- (기능) 첫 설정: 환자 자원 저장 시 현재 위치를 추가함\n- (기능) 첫 설정: 사이드 패널에 현재 위치 추가함.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 🔮 다음 주 계획\n\n다음 주 일정은 다음과 같습니다:\n\n- 🧪 서버와 동기화하여 위치 데이터 저장 로직을 구현하고 유효성을 검사합니다.\n- ✨ MVP 1의 구현을 정리하고 MVP 2의 구현을 시작합니다.\n\n함께 해 주셔서 정말 감사합니다! 여러분의 지원은 저에게 큰 힘이 됩니다. 더 많은 업데이트를 기대해 주세요. 코딩을 즐기세요! 🎉👩‍💻👨‍💻 Frederic Deniger, Jose Francisco, Pedro Sousa, ICRC 팀 및 OpenMRS 팀께 소중한 지도를 해 준 데에 박수를 보냅니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n읽어 주셔서 감사합니다! 언제든지 건강 관련, 풀 스택 개발, FHIR, OpenMRS 안드로이드, Open Health Stack, 노래 추천 등과 관련된 모든 것에 대해 저에게 연락하실 수 있습니다! 🎵\n\nLinkedIn이나 OpenMRS Talk에서 저를 찾아보고 GitHub에서 제 프로젝트를 확인해보세요.\n","ogImage":{"url":"/assets/img/2024-06-23-GSoC2024Week2IntegratingLocationstoFHIRAndroidApplication_0.png"},"coverImage":"/assets/img/2024-06-23-GSoC2024Week2IntegratingLocationstoFHIRAndroidApplication_0.png","tag":["Tech"],"readingTime":4},{"title":"안드로이드 유닛 테스트 101 초보자를 위한 가이드","description":"","date":"2024-06-23 20:57","slug":"2024-06-23-UnitTestingforAndroidABeginnersGuide","content":"\n유닛 테스트는 소프트웨어 개발의 중요한 단계입니다. 이것은 Test Driven Development (TDD)라고 불리는 개발 패러다임을 가져옵니다. 이러한 테스트는 일반적으로 애플리케이션의 비즈니스 로직을 테스트합니다.\n\n# 왜 우리는 유닛 테스트를 작성할까요?\n\n- 우리는 실수를 할 수 있습니다.\n- 우리의 코드가 작동되기를 원합니다.\n- 더 빠르게 개발하고 더 많은 확신과 더 적은 회귀를 가지기를 원합니다.\n\n안드로이드 및 일반적으로 다양한 모바일 플랫폼에서 앱 테스트는 어려울 수 있습니다. 유닛 테스트를 구현하고 테스트 주도 개발(TDD)의 원칙을 따르는 것은 종종 직관에 어긋날 수 있습니다. 그럼에도 불구하고 테스트는 중요하며 당연하게 여기거나 무시해서는 안 됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n한 번 유닛 테스트의 기본 사항으로 이동해 보죠. 안드로이드에서 유당 테스트라고 하면 떠오르는 몇 가지 기본 사항부터 시작해보겠습니다.\n\n# 패키지 구조\n\n새로운 안드로이드 프로젝트를 생성하면 기본적으로 다음 세 가지 소스 세트를 얻게 됩니다. 이들은 다음과 같습니다:\n\n![Unit Testing for Android - A Beginner's Guide](/assets/img/2024-06-23-UnitTestingforAndroidABeginnersGuide_0.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- main: 앱 코드가 포함되어 있습니다.\n- androidTest: 인스트루먼티드 테스트로 알려진 테스트가 포함되어 있습니다.\n- test: 로컬 테스트로 알려진 테스트가 포함되어 있습니다.\n\n로컬 테스트와 인스트루먼티드 테스트의 차이점은 실행되는 방식에 있습니다.\n\n# 로컬 테스트 (test 소스 세트)\n\n이러한 테스트는 개발 컴퓨터의 JVM에서 로컬로 실행되며 에뮬레이터나 물리적 장치가 필요하지 않습니다. 이로 인해 실행 속도가 빠르지만, 신뢰성은 낮아 실제와 다르게 동작할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# Instrumented tests (androidTest source set)\n\n이러한 테스트는 실제 또는 에뮬레이션된 Android 장치에서 실행되므로 실제 세계에서 발생할 사항을 반영하지만 훨씬 느립니다.\n\n# Test runner\n\n테스트 실행기는 테스트를 실행하는 JUnit 구성 요소입니다. 테스트 실행기가 없으면 테스트가 실행되지 않습니다. JUnit에서는 자동으로 제공되는 기본 테스트 실행기가 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nAndroid Studio를 사용하면 클래스를 테스트하는 테스트를 생성할 수 있는 도구를 제공합니다. 테스트할 클래스를 마우스 오른쪽 버튼으로 클릭하고 Generate ` Test를 선택하세요.\n\n<img src=\"/assets/img/2024-06-23-UnitTestingforAndroidABeginnersGuide_1.png\" />\n\nTest를 클릭한 후에는 Test 클래스를 생성할 수 있습니다.\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/assets/img/2024-06-23-UnitTestingforAndroidABeginnersGuide_2.png)\n\n테스트 클래스에서 사용하는 몇 가지 주석을 살펴봅시다.\n\n- @Test: 이 주석은 메서드를 테스트 케이스로 표시하는 데 사용됩니다. @Test 주석은 Java 컴파일러에게 클래스를 컴파일할 때 메서드를 테스트 케이스로 실행하도록 알려줍니다.\n- @Before: 이 주석은 메서드를 설정 메서드로 표시하는 데 사용됩니다. @Before 주석은 Java 컴파일러에게 클래스의 각 테스트 케이스 전에 메서드를 실행하도록 알려줍니다. 각 테스트 케이스가 실행되기 전에 테스트 환경을 설정하는 데 유용합니다.\n- @After: 이 주석은 메서드를 소멸 메서드로 표시하는 데 사용됩니다. @After 주석은 Java 컴파일러에게 클래스의 각 테스트 케이스 후에 메서드를 실행하도록 알려줍니다. 각 테스트 케이스가 실행된 후 테스트 환경을 정리하는 데 유용합니다.\n- @Ignore: 이 주석은 메서드를 무시된 테스트 케이스로 표시하는 데 사용됩니다. @Ignore 주석은 Java 컴파일러에게 메서드를 테스트 케이스로 실행하지 말도록 알려줍니다. 아직 실행할 준비가 안 된 테스트 케이스를 일시적으로 무시하는 데 유용합니다.\n\n단언문은 테스트의 핵심입니다. 코드 문장으로, 코드나 앱이 예상대로 작동했는지 확인합니다. 이 경우, 단언문은 assertEquals(4, 2 + 2)로 4가 2 + 2와 같은지를 확인합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 테스트 전략\n\n가독성이 좋은 테스트를 작성하는 몇 가지 다른 전략이 있습니다. 방금 작성한 테스트에서 이 두 가지 전략이 모두 보여집니다.\n\n## 주어진 상황, When, Then\n\n테스트의 구조를 생각하는 한 가지 방법은 주어진 상황, When, Then 테스트 니모닉을 따르는 것입니다. 이를 통해 테스트를 세 부분으로 나눌 수 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 주어진: 테스트에 필요한 객체 및 앱 상태를 설정하십시오. 이 테스트에서 \"주어진\" 부분이 무엇인가요.\n- 실행: 테스트 중인 객체에 대해 실제로 작업을 수행하십시오.\n- 결과: 이 부분은 실제로 작업을 수행할 때 일어나는 일을 확인하는 곳으로, 테스트가 통과했는지 실패했는지 확인합니다. 보통 여러 assert 함수 호출이 포함됩니다.\n\n주의해 주실 점은 \"준비, 실행, 확인\" (AAA) 테스트 니모닉이 유사한 개념이라는 것입니다.\n\n```js\n@Test\nfun getUserProfile_givenUserId_returnUser() {\n    // 주어진\n    val userId = 1\n    val user = User(userId,\"\",\"TestUser\")\n    // 실행\n    doReturn(Observable.just(user)).`when`(webservice).getMyProfile(userId)\n    presenter.getUserProfile(anyString())\n    // 결과\n    verify(profileView).render(ProfileState.DataState(user))\n}\n```\n\n# 종속성 구성\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n일반적으로 종속성을 추가할 때 구현을 사용합니다. 앱을 세계와 공유할 준비가 되면, 테스트 코드나 앱의 종속성을 APK의 크기를 부풀리지 않는 것이 가장 좋습니다. Gradle 구성을 사용하여 라이브러리가 주 코드 또는 테스트 코드에 포함되어야 하는지 지정할 수 있습니다.\n\n가장 일반적인 구성은 다음과 같습니다:\n\n- implementation—이 종속성은 테스트 소스 세트를 포함한 모든 소스 세트에서 사용할 수 있습니다.\n- testImplementation—이 종속성은 테스트 소스 세트에서만 사용할 수 있습니다.\n- androidTestImplementation—이 종속성은 androidTest 소스 세트에서만 사용할 수 있습니다.\n\n# 테스트 더블들\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 문제의 해결책은 리포지토리를 테스트할 때 실제 네트워킹 또는 데이터베이스 코드를 사용하지 말고 대신 테스트 더블을 사용해야 합니다. 테스트 더블은 테스트를 위해 특별히 작성된 클래스의 버전을 말합니다. 이것은 테스트에서 사용되는 클래스의 실제 버전을 대체하는 것을 목적으로 합니다. 이는 스턴트 배우가 위험한 액션을 대신하는 것처럼 테스트 더블이 스턴트에 특화된 배우인 것과 유사합니다.\n\n다음은 일부 테스트 더블의 유형입니다:\n\n## 가짜(Fake)\n\n클래스의 \"작동\" 구현을 갖는 테스트 더블이지만 테스트에는 적합하지만 프로덕션에는 적합하지 않은 방식으로 구현되어 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 목\n\n호출된 메소드를 추적하는 테스트 더블(Mock)입니다. 그런 다음 메소드가 올바르게 호출되었는지에 따라 테스트를 통과하거나 실패합니다. 객체를 모의(Mock)하면 해당 클래스의 빈 구현이 생성됩니다.\n\n# 네이밍 규칙\n\n테스트의 이름은 해당 테스트가 무엇을 하는지 이해하는 데 도움이 되어야 합니다. 네이밍 규칙은 다음과 같이 보여야 합니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n**subjectUnderTest_actionOrInput_resultState**\n\n- Subject under test is the method or class that is being tested (getUserProfile).\n- Next is the action or input (givenUserId).\n- Finally you have the expected result (returnUser).\n\n**Pro Tip**\n\nWhen you have repeated setup code for multiple tests, you can use the @Before annotation to create a setup method and remove repeated code.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 기사를 읽어 주셔서 감사합니다. 도움이 되었다면 아래 👏을 클릭해서 기사를 칭찬해주세요. 제게 매우 큰 의미가 됩니다. 댓글이나 트위터, 링크드인을 통해 연락 주시면 감사하겠습니다. 코딩 즐기시고 즐거운 시간 보내세요!\n\n커피 사주세요 ☕\n","ogImage":{"url":"/assets/img/2024-06-23-UnitTestingforAndroidABeginnersGuide_0.png"},"coverImage":"/assets/img/2024-06-23-UnitTestingforAndroidABeginnersGuide_0.png","tag":["Tech"],"readingTime":8},{"title":"안드로이드 앱에서 URL로 썸네일 또는 로고 가져오는 방법","description":"","date":"2024-06-23 20:56","slug":"2024-06-23-FetchThumbnailorLogofromAnyURLinYourAndroidApp","content":"\n이 기사에서는 안드로이드 애플리케이션에서 주어진 URL에서 섬네일이나 로고를 가져와서 표시하는 방법을 안내하겠습니다. 네트워크 요청에는 Retrofit, HTML 파싱에는 Jsoup, 이미지 로딩에는 Glide를 사용할 예정입니다.\n\n# 특징\n\n- 주어진 URL에서 HTML 콘텐츠를 가져옵니다.\n- HTML을 파싱하여 섬네일이나 로고 URL을 추출합니다.\n- Glide를 사용하여 가져온 이미지를 표시합니다.\n- 섬네일이나 로고를 찾을 수 없는 경우 기본 로고로 대체합니다.\n\n# 사용 사례\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 앱은 다음과 같은 여러 시나리오에 유용할 수 있어요:\n\n- 메시지나 소셜 미디어 앱에서 공유된 URL에 미리보기 이미지 표시하기.\n- 콘텐츠 집계 앱에서 블로그 글이나 기사의 썸네일 표시하기.\n- 북마크 관리자에서 링크와 관련된 로고나 이미지를 가져와 표시하기.\n\n# 시작하기\n\n# 요구 사항\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 안드로이드 스튜디오\n- 코틀린\n- 인터넷 연결\n\n# 종속성\n\n다음 종속성을 build.gradle.kts 파일에 추가해주세요:\n\n```js\nimplementation(\"com.squareup.retrofit2:retrofit:2.9.0\");\nimplementation(\"com.squareup.retrofit2:converter-scalars:2.9.0\");\nimplementation(\"org.jsoup:jsoup:1.13.1\");\nimplementation(\"com.github.bumptech.glide:glide:4.11.0\");\nkapt(\"com.github.bumptech.glide:compiler:4.11.0\");\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 사용 방법\n\n- 저장소를 복제합니다:\n\n  bash\n  git clone https://github.com/WalidAhmed90/Fetch-Thumbnail-or-Logo-in-Android-App.git\n  cd Fetch-Thumbnail-or-Logo-in-Android-App\n\n2. Android Studio에서 프로젝트를 엽니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n3. 안드로이드 기기 또는 에뮬레이터에서 프로젝트를 빌드하고 실행하세요.\n\n4. URL을 입력하고 \"썸네일 생성\" 버튼을 클릭하여 썸네일이나 로고를 가져와 표시하세요.\n\n# 코드 개요\n\n## API 서비스\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nApiService 인터페이스는 URL에서 HTML 콘텐츠를 가져오는 메서드를 정의합니다:\n\n```js\ninterface ApiService {\n    @GET\n    suspend fun fetchHtml(@Url url: String): String\n}\n```\n\n## 썸네일 가져오기\n\nfetchThumbnail 함수는 HTML 콘텐츠를 가져와 썸네일이나 로고를 찾아 Glide를 사용하여 보여줍니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\nfun fetchThumbnail(url: String) {\n        mBinding.progress.visibility = View.VISIBLE\n        val retrofit = Retrofit.Builder()\n            .baseUrl(\"https://example.com/\")  // 가짜 기본 URL, 덮어쓰기될 예정\n            .client(OkHttpClient())\n            .addConverterFactory(ScalarsConverterFactory.create())\n            .build()\n\n        val apiService = retrofit.create(ApiService::class.java)\n\n        CoroutineScope(Dispatchers.IO).launch {\n            try {\n                val html = apiService.fetchHtml(url)\n                Log.d(\"HTML_CONTENT\", html) // 가져온 HTML 내용 로깅\n\n                val document = Jsoup.parse(html)\n                val metaTags = document.select(\"meta[property=og:image], meta[name=twitter:image]\")\n\n                var thumbnailUrl: String? = null\n                for (metaTag in metaTags) {\n                    val content = metaTag.attr(\"content\")\n                    if (content.isNotEmpty()) {\n                        thumbnailUrl = content\n                        break\n                    }\n                }\n\n                if (thumbnailUrl == null) {\n                    val mainImage: Element? = document.select(\"table.infobox img\").first()\n                    mainImage?.let {\n                        thumbnailUrl = \"https:${it.attr(\"src\")}\"\n                    }\n                }\n\n                // 썸네일 이미지를 찾을 수 없는 경우 도메인 로고로 대체\n                if (thumbnailUrl == null) {\n                    val domain = Uri.parse(url).host ?: \"\"\n                    thumbnailUrl = \"https://logo.clearbit.com/$domain\"\n                }\n\n                if (thumbnailUrl != null) {\n                    launch(Dispatchers.Main) {\n                        mBinding.progress.visibility = View.GONE\n                        Glide.with(this@MainActivity)\n                            .load(thumbnailUrl)\n                            .into(mBinding.thumbnailImage)\n                    }\n                } else {\n                    mBinding.progress.visibility = View.GONE\n                    Log.d(\"THUMBNAIL\", \"이미지를 찾을 수 없습니다.\")\n                }\n            } catch (e: Exception) {\n                e.printStackTrace()\n                mBinding.progress.visibility = View.GONE\n            }\n        }\n    }\n```\n\n## Layout\n\nactivity_main.xml 레이아웃 파일은 다음과 같이 UI 구성요소를 정의합니다:\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<layout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    xmlns:tools=\"http://schemas.android.com/tools\">\n\n    <data>\n\n    </data>\n\n    <androidx.constraintlayout.widget.ConstraintLayout\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n  >\n\n        <LinearLayout\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"match_parent\"\n            android:orientation=\"vertical\"\n            android:padding=\"16dp\"\n            app:layout_constraintBottom_toBottomOf=\"parent\"\n            app:layout_constraintEnd_toEndOf=\"parent\"\n            app:layout_constraintStart_toStartOf=\"parent\"\n            app:layout_constraintTop_toTopOf=\"parent\"\n            tools:context=\".MainActivity\">\n\n            <EditText\n                android:id=\"@+id/urlInput\"\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"wrap_content\"\n                android:textColor=\"@color/grey\"\n                android:layout_marginTop=\"20dp\"\n                android:hint=\"URL 입력\" />\n\n            <Button\n                android:id=\"@+id/generateButton\"\n                android:layout_width=\"wrap_content\"\n                android:layout_height=\"wrap_content\"\n                android:layout_marginTop=\"10dp\"\n                android:text=\"썸네일 생성\" />\n\n            <ImageView\n                android:id=\"@+id/thumbnailImage\"\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"wrap_content\"\n                android:adjustViewBounds=\"true\"\n                android:contentDescription=\"썸네일\"\n                android:layout_marginTop=\"10dp\"\n                android:scaleType=\"fitCenter\"\n                android:visibility=\"visible\" />\n\n            <com.google.android.material.progressindicator.CircularProgressIndicator\n                android:id=\"@+id/progress\"\n                android:layout_width=\"wrap_content\"\n                android:layout_height=\"wrap_content\"\n                app:indicatorColor=\"@color/green\"\n                android:indeterminate=\"true\"\n                android:layout_gravity=\"center_horizontal\"\n                android:visibility=\"gone\"\n                />\n\n        </LinearLayout>\n\n\n    </androidx.constraintlayout.widget.ConstraintLayout>\n</layout>\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 기여하기\n\n문제를 발견하거나 개선 제안이 있는 경우 문제를 열거나 풀 요청을 제출해주세요.\n\n# 결과:\n\n![Output](https://miro.medium.com/v2/resize:fit:1200/1*606E5BSXDVXR6xuwV6sFSg.gif)\n","ogImage":{"url":"/assets/img/2024-06-23-FetchThumbnailorLogofromAnyURLinYourAndroidApp_0.png"},"coverImage":"/assets/img/2024-06-23-FetchThumbnailorLogofromAnyURLinYourAndroidApp_0.png","tag":["Tech"],"readingTime":9},{"title":"루비와 OpenSSL의 미스터리한 이야기","description":"","date":"2024-06-23 20:55","slug":"2024-06-23-ThecuriouscaseofRubyandOpenSSL","content":"\n![image](/assets/img/2024-06-23-ThecuriouscaseofRubyandOpenSSL_0.png)\n\n만약 당신이 컴퓨터에 익숙한 사용자라면, 토런트를 통해 게임을 다운로드하고 크랙을 사용하거나 라이브러리를 설치하는 경우와 같이 일부 상황에서는 오류를 만날 수밖에 없습니다. 그럴 때 여러 웹사이트를 찾아다니거나 여러 YouTube 동영상을 보며 해결책을 찾는 긴 여정을 겪게 될 수 있습니다. 그런 상황에서는 당신의 노력이 가치 있는지 의심하게 될 수도 있지만, 결국 그 문제를 해결했을 때의 기분은 정말로 훌륭합니다. 제 경험을 들어보면 PC용 콜 오브 듀티 블랙 옵스 II를 수정하거나 Wii의 임의의 CD를 허용하기 위해 크랙을 적용하거나 Arch Linux를 설치하는 등 여러 번 이런 상황을 겪었습니다. 그리고 지금은 Ruby용 webauthn 젬을 설치하는 과정에서 OpenSSL 오류를 해결하고 있습니다. StackOverflow의 답변을 여러 개 찾아보고 관련 블로그 글을 여러 개 읽은 결과, 처음에는 문제 해결에 실패했지만 약 한 시간을 투자한 끝에 성공했습니다. 비슷한 문제가 다시 발생할 경우를 대비해 나의 해결책을 문서로 남겨두기로 했습니다.\n\nwebauthn을 설치하려고 하는 과정에서 에러 메시지가 나왔습니다. sudo gem install webauthn 명령을 입력하자 다음과 같은 응답이 왔습니다: ERROR: While executing gem ... (Gem::Exception) Unable to require openssl, install OpenSSL and rebuild ruby (preferred) or use non-HTTPS sources..\n\n두 가지 잠재적인 해결책을 살펴보았습니다. 먼저, 몇몇 온라인 소스에서 제안한 대로 기본 Ruby를 제거하고 다시 설치해보기로 결정했습니다. rvm remove ruby-2.6.10 명령을 사용하여 버전을 성공적으로 제거했지만 rvm install ruby-2.6.10 --with-openssl-dir=`/usr/local/opt/openssl` 명령을 사용하여 재설치하려고 시도했을 때 추가 문제가 발생했습니다. Ruby를 설치했지만 webauthn을 설치하려고 할 때 문제가 지속되었습니다. 나중에 Ruby gem을 업데이트해야 문제를 해결할 수 있다는 것을 발견했습니다. sudo gem update --system 명령을 사용하여 시도했지만 또 다른 오류가 발생했습니다: ruby: No such file or directory -- setup.rb (LoadError). 여러 해결책을 조사한 끝에 gem install rubygems-update --source http://production.s3.rubygems.org/ update_rubygems와 같은 방법으로 시도해도 문제를 해결할 수 없었습니다. 결국 다시 Ruby를 제거하고 brew install을 통해 설치하니 gem을 성공적으로 업데이트할 수 있었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nOpenSSL 오류를 해결하면서 루비와 비슷한 방법을 시도하기로 결정했습니다. homebrew를 사용하여 OpenSSL 1.0을 설치하기로 결정해서 brew install rbenv/tap/openssl@1.0을 실행했고, 이전 버전의 OpenSSL을 참조하여 루비를 다시 설치했습니다: rvm reinstall 2.6.10 --with-openssl-dir=`/usr/local/opt/openssl@1.0`. 놀랍게도 작동했습니다! 이것이 제 첫 번째 해결책이었고, 이 아이디어를 제공해준 데 대해 감사를 표합니다.\n\n그러나 OpenSSL 오류를 해결한 뒤 webauthn을 설치하려고 시도할 때 추가 오류가 발생했습니다: ERROR: While executing gem ... (Gem::FilePermissionError) You don`t have write permissions for the /System/Library/Frameworks/Ruby.framework/Versions/2.6/usr/lib/ruby/gems/2.6.0 directory.. 조사를 한 결과, 이는 Mac의 미리 설치된 Ruby 버전에 직접 gem을 설치하는 것에 대한 Apple의 제한 때문이었음을 알게 되었습니다. 좀 더 깊이 파고들어 알아보니 Apple이 macOS의 10.15 버전인 Catalina에서 macOS에 내장된 각종 스크립트 언어 런타임을 공식으로 사용 중단했다는 것을 알게 되었습니다. macOS Catalina 10.15 릴리스 노트에서 관련 정보를 찾아볼 수 있습니다. 더 깊이 조사한 결과 두 번째 해결책을 찾게 되었습니다.\n\n루비 2.6.10을 사용하는 것이 내가 겪은 문제들의 근본 원인이었음을 알게 되었습니다. 이 문제를 해결하기 위해 최신 버전의 루비를 설치하여, rvm install ruby-3.2.1을 실행하고, sudo gem install webauthn으로 webauthn을 설치했습니다. 어려움 없이 작동했고, 다음 메시지가 표시되었습니다: Done installing documentation for openssl-signature_algorithm, bindata, tpm-key_attestation, jwt, safety_net_attestation, cbor, cose, awrence, android_key_attestation, webauthn after 1 seconds. 10 gems installed.\n\n전반적으로 상당히 흥미로운 오류였으며 해결하는 것이 즐거웠습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 부가 정보:\n\n- 때때로, RVM이 이상하게 행동할 수 있습니다. 그냥 삭제하고 다시 설치하세요. rm -rf ~/.rvm를 입력한 후, curl -L https://get.rvm.io | bash -s stable을 실행하세요.\n- 젬을 설치할 때 경로를 제공해야 합니다. 이렇게: sudo gem install -n /usr/local/bin GEM_NAME. 이걸 매번 하기 귀찮다면, 먼저 이렇게 하세요: echo \"gem: -n/usr/local/bin\" `` ~/.gemrc. 다음에는 그냥 sudo gem install GEM_NAME을 실행하세요.\n","ogImage":{"url":"/assets/img/2024-06-23-ThecuriouscaseofRubyandOpenSSL_0.png"},"coverImage":"/assets/img/2024-06-23-ThecuriouscaseofRubyandOpenSSL_0.png","tag":["Tech"],"readingTime":4},{"title":"리트코드 두 수 더하기 문제 해결 - 루비 솔루션 완벽 가이드","description":"","date":"2024-06-23 20:53","slug":"2024-06-23-SolvingtheAddTwoNumbersProblemonLeetCodeRubySolutionsWalkthrough","content":"\n<img src=\"/assets/img/2024-06-23-SolvingtheAddTwoNumbersProblemonLeetCodeRubySolutionsWalkthrough_0.png\" />\n\n# 소개\n\nLeetCode의 'Add Two Numbers' 문제는 두 개의 음이 아닌 정수를 나타내는 비어 있지 않은 두 연결 리스트를 더하는 것을 포함합니다. 각 목록의 숫자는 역순으로 저장되어 있으며, 각 노드에는 한 자리 숫자가 포함되어 있습니다. 이 작업은 두 숫자를 더하고 합계를 연결 리스트로 반환하는 것입니다.\n\nRuby는 간결한 구문과 동적 기능으로 이 문제를 효율적으로 해결하는 여러 가지 방법을 제공합니다. 이 안내서에서는 'Add Two Numbers' 문제를 해결하기 위한 4가지 Ruby 솔루션을 살펴보겠습니다. 이 가이드의 끝에서 각 방법의 메커니즘과 효율성, 효과에 대한 이해를 얻게 될 것입니다. 코드 주석 및 각 방법에 대한 자세한 단계별 설명은 결론 이후에 제공됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 문제 설명\n\n```js\n# 단일 연결 리스트에 대한 정의\n# class ListNode\n#     attr_accessor :val, :next\n#     def initialize(val = 0, _next = nil)\n#         @val = val\n#         @next = _next\n#     end\n# end\n```\n\n## 루비에서의 함수 시그니처:\n\n```js\n# @param {ListNode} l1\n# @param {ListNode} l2\n# @return {ListNode}\ndef add_two_numbers(l1, l2)\n\nend\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 예시 1:\n\n<img src=\"/assets/img/2024-06-23-SolvingtheAddTwoNumbersProblemonLeetCodeRubySolutionsWalkthrough_1.png\" />\n\n- 입력: l1 = [2,4,3], l2 = [5,6,4]\n- 출력: [7,0,8]\n- 설명: 342 + 465 = 807.\n\n## 예시 2:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 입력: l1 = [0], l2 = [0]\n- 출력: [0]\n\n## 예제 3:\n\n- 입력: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\n- 출력: [8,9,9,9,0,0,0,1]\n\n## 제약 조건\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 각 연결 목록의 노드 수는 [1, 100] 범위 내에 있습니다.\n- 0 ≤ Node.val ≤ 9\n- 목록이 선행 0이 없는 숫자를 나타낸다는 것이 보장됩니다.\n\n# 해법 1: 전달하는 접근 방법 및 캐리 처리\n\n이 간단한 접근 방법은 두 연결 목록을 반복하며 해당하는 숫자를 더하고, 9보다 큰 합계에 대해 캐리를 처리하는 것을 포함합니다.\n\n## 루비 코드:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\ndef add_two_numbers(l1, l2)\n    dummy = ListNode.new(0)\n    current = dummy\n    carry = 0\n\n    while l1 || l2\n        x = l1 ? l1.val : 0\n        y = l2 ? l2.val : 0\n        sum = carry + x + y\n        carry = sum / 10\n        current.next = ListNode.new(sum % 10)\n        current = current.next\n        l1 = l1.next if l1\n        l2 = l2.next if l2\n    end\n\n    current.next = ListNode.new(carry) if carry > 0\n    dummy.next\nend\n```\n\n## 시간 및 공간 복잡도\n\n- 시간 복잡도: O(n). 이 알고리즘은 연결 리스트 l1과 l2를 정확히 한 번씩 훑습니다. 각 반복에서 각 목록에서 하나의 노드를 처리하고 고정량의 작업(덧셈, carry 처리 및 노드 생성)을 수행합니다. 따라서 시간 복잡도는 긴 목록의 길이에 대해 선형입니다.\n- 공간 복잡도: O(n). 공간 복잡도는 결과 연결 리스트를 저장하는 데 필요한 공간에 의해 결정됩니다. 합의 각 자릿수에 대해 새로운 노드가 생성되므로 공간 복잡도는 결과 목록의 길이에 비례하며 O(n)입니다. carry, dummy 및 current와 같은 변수에 사용하는 보조 공간은 상수(O(1))입니다. 그러나 새로운 연결 리스트가 전체 O(n) 공간 복잡도에 기여합니다.\n\n# Solution 2: 재귀적 접근\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 접근 방식은 재귀를 사용하여 숫자와 올림을 처리하며, 더 작은 재귀 호출로 반복 논리를 단순화합니다.\n\n## 루비 코드:\n\n```js\ndef add_two_numbers(l1, l2, carry = 0)\n    return ListNode.new(carry) if l1.nil? && l2.nil? && carry > 0\n    return nil if l1.nil? && l2.nil?\n\n    sum = carry\n    sum += l1.val if l1\n    sum += l2.val if l2\n\n    result = ListNode.new(sum % 10)\n    result.next = add_two_numbers(l1 ? l1.next : nil, l2 ? l2.next : nil, sum / 10)\n    result\nend\n```\n\n## 시간 및 공간 복잡도\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 시간 복잡도: O(n). 반복적인 방법과 유사하게, 재귀적인 해결책은 입력 리스트의 각 노드를 한 번씩 처리합니다. 각 재귀 호출은 하나의 숫자 더하기를 처리하고 l1 및 l2의 다음 노드로 진행하며, 시간 복잡도는 더 긴 리스트의 길이에 비례하여 선형적입니다.\n- 공간 복잡도: O(n). 공간 복잡도에는 새 연결 리스트와 재귀 호출 스택에 필요한 공간이 모두 포함됩니다. 각 재귀 호출은 스택 공간을 소비하므로 재귀 깊이가 더 긴 리스트의 길이와 동일하기 때문에 재귀 깊이가 O(n)이 되어 O(n) 공간 복잡도가 발생합니다. 또한 결과를 저장하기 위해 생성된 새 연결 리스트가 O(n) 공간 복잡도에 기여합니다. 따라서, 호출 스택과 새 연결 리스트에 대한 총 공간 복잡도는 O(n)입니다.\n\n# Solution 3: Using Enumerators for Clean Iteration\n\n이 접근 방식은 루비의 enumerators를 활용하여 연결된 리스트를 반복하는 코드를 더 깔끔하고 관용적으로 만듭니다.\n\n## 루비 코드:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\ndef add_two_numbers(l1, l2)\n    dummy = ListNode.new(0)\n    current = dummy\n    carry = 0\n\n    e1 = to_enum(l1)\n    e2 = to_enum(l2)\n\n    loop do\n        begin\n            x = e1.next\n        rescue StopIteration\n            x = ListNode.new(0)\n        end\n\n        begin\n            y = e2.next\n        rescue StopIteration\n            y = ListNode.new(0)\n        end\n\n        sum = carry + x.val + y.val\n        carry = sum / 10\n        current.next = ListNode.new(sum % 10)\n        current = current.next\n\n        break if x.next.nil? && y.next.nil? && carry.zero?\n    end\n\n    current.next = ListNode.new(carry) if carry > 0\n    dummy.next\nend\n\ndef to_enum(node)\n    Enumerator.new do |yielder|\n        while node\n            yielder << node\n            node = node.next\n        end\n    end\nend\n```\n\n## 시간 복잡도와 공간 복잡도\n\n- 시간 복잡도: O(n). 이 알고리즘은 입력 연결 리스트의 각 노드를 정확히 한 번씩 처리합니다. 각 노드마다 상수 시간의 작업(덧셈, carry 처리 및 노드 생성)을 수행합니다. Enumerators의 사용은 각 노드가 더 긴 목록의 길이에 비례하는 선형 시간 내에 처리된다는 사실을 변경하지 않습니다.\n- 공간 복잡도: O(n). 공간 복잡도는 결과 연결 리스트를 저장하는 데 필요한 공간에 의해 결정됩니다. 합의 각 자릿수마다 새로운 노드가 생성되므로 공간 복잡도는 결과 목록의 길이에 비례하며 O(n)입니다. carry, dummy 및 current와 같은 변수에 사용된 보조 공간은 상수(O(1))이지만 새로운 연결 리스트가 전체적인 O(n) 공간 복잡도를 차지합니다. Enumerators의 사용은 최소한의 오버헤드를 추가하며 공간 복잡도에 중대한 영향을 미치지 않습니다.\n\n# 솔루션 4: 입력 리스트의 위치 수정을 통한 해결 방법\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n긴 입력 목록의 노드를 변경하여 결과 목록을 만드는 추가 노드를 생성하지 않고 재사용하는 방식으로 처리합니다.\n\n## 루비 코드:\n\n```js\ndef add_two_numbers(l1, l2)\n    carry = 0\n    head = l1\n    prev = nil\n\n    while l1 && l2\n        sum = l1.val + l2.val + carry\n        carry = sum / 10\n        l1.val = sum % 10\n        prev = l1\n        l1 = l1.next\n        l2 = l2.next\n    end\n\n    if l2\n        prev.next = l2\n        l1 = l2\n    end\n\n    while l1\n        sum = l1.val + carry\n        carry = sum / 10\n        l1.val = sum % 10\n        prev = l1\n        l1 = l1.next\n    end\n\n    if carry > 0\n        prev.next = ListNode.new(carry)\n    end\n\n    head\nend\n```\n\n## 시간 및 공간 복잡도\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 시간 복잡도: O(n). 이 알고리즘은 입력 연결 리스트의 각 노드를 정확히 한 번 처리하므로, 긴 리스트의 길이에 비례하여 선형 시간 복잡도를 갖습니다.\n- 공간 복잡도: O(1). 알고리즘은 결과를 위해 추가 공간을 할당하지 않고 기존 노드를 그대로 수정하므로, 공간 복잡도는 상수입니다. 사용되는 추가 공간은 몇 가지 보조 변수(carry, prev, head) 뿐이며 입력 크기에 따라 달라지지 않습니다.\n\n# 결론 및 비교\n\n분석 결과, 네 가지 루비 메서드의 시간 복잡도는 모두 유사하며, 각각 입력 연결 리스트를 한 번만 순회하는 작업이 포함되어 있습니다. 결과 연결 리스트 및 carry를 처리하는 전략에 따라 솔루션 간 공간 복잡도가 달라집니다.\n\n## 솔루션 1: Carry 처리를 포함한 반복적 방법\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 장점: 직관적이고 이해하기 쉽습니다. 두 숫자의 덧셈을 처리하는 데 효율적으로 작동하며 리스트를 반복하고 루프 내에서 캐리를 처리합니다. 논리가 명확하고 간단하여 구현 및 디버깅이 쉽습니다.\n- 단점: 결과를 저장하기 위해 새 연결 리스트를 생성해야 하므로 O(n) 공간 복잡성을 가집니다. 이 방법은 인플레이스 수정 솔루션보다 공간을 덜 효율적으로 사용합니다.\n\n## 솔루션 2: 재귀적 접근\n\n- 장점: 명확하고 간결한 해결책을 제공합니다. 반복 논리를 더 작은 조각으로 나누어 처리하는 재귀 호출을 통해 단순화합니다. 코드가 깨끗하고 이해하기 쉬워 재귀를 선호하는 사람들에게 좋은 선택입니다.\n- 단점: 재귀 스택으로 인해 공간 복잡성이 높아져 O(n)의 공간을 사용할 수 있습니다. 이는 매우 큰 입력 크기에 대한 제약으로, 스택 오버플로우 문제를 일으킬 수 있습니다.\n\n## 솔루션 3: 깔끔한 반복을 위한 열거자 사용\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 장점: Ruby의 enumerators를 활용하여 더 깔끔하고 관용적인 접근을 제공합니다. 명시적인 확인이 줄어들고 반복을 우아하게 처리합니다. 이 해결책은 Ruby의 고수준 구조를 이해하는 사람들에게 적합합니다.\n- 단점: 첫 번째 해결책에 비해 약간 더 복잡한 논리를 요구하며 Ruby의 enumerators에 대한 숙련도가 필요합니다. 공간 복잡도는 새로운 연결 리스트를 만들어야 하기 때문에 O(n)으로 유지됩니다.\n\n## 솔루션 4: 입력 리스트의 자리수 수정\n\n- 장점: 이 해결책은 입력 리스트의 노드를 그 자리에서 수정하여 공간을 가장 효율적으로 활용합니다. 기존 노드를 재사용하고 추가적인 노드를 만들지 않음으로써 O(1)의 고정된 공간 복잡도를 달성합니다. 메모리 소비를 과도하게 막으면서 대량의 입력 크기를 처리하기에 이상적입니다.\n- 단점: 자리수 수정을 위한 논리는 더 복잡하며 노드 포인터와 값에 대한 주의 깊은 처리가 필요합니다. 다른 해결책들에 비해 오류 발생 가능성이 높고 디버깅하기 어려울 수 있습니다.\n\n## 요약\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 해결책 1: 캐리 처리를 포함한 반복적 접근은 간단함과 효율성 사이의 균형을 제공하여 문제를 이해하는 데 좋은 시작점이 될 수 있습니다.\n- 해결책 2: 재귀적 접근은 명확하고 간결한 해결책을 제공하지만 큰 입력에 대해 더 높은 공간 복잡성을 가집니다.\n- 해결책 3: 깨끗한 반복을 위한 Enumerators 사용은 Ruby의 고수준 구조를 활용하여 더 깔끔한 접근을 제공하지만 반복적인 접근과 동일한 공간 복잡성을 가집니다.\n- 해결책 4: 입력 리스트의 내부 수정은 가장 공간을 효율적으로 활용할 수 있으며 큰 입력 크기에 적합하지만 더 신중한 구현이 필요합니다.\n\n네 개의 해결책 모두 장단점이 있지만, 공간 효율성 면에서 해결책 4가 최적의 선택으로 돋보입니다. 입력 리스트를 그대로 수정함으로써 메모리 사용량을 최소화하고, 대규모 데이터셋을 다룰 때 특히 유리합니다. 그러나 더 세심한 구현 방식이 필요합니다. 포인터 관리와 내부 수정에 익숙한 사람들에게는 자원을 가장 효율적으로 사용할 수 있는 해결책 4를 추천합니다.\n\n- LeetCode — 두 수 더하기\n- Ruby 문서\n\n읽어 주셔서 감사합니다! 이 안내서가 도움이 되었다면, 하이라이트를 주거나 박수를 치거나 답글을 달거나 Twitter/X를 통해 연결해 주시면 정말 감사하겠습니다. 이는 매우 감사히 받아들이며, 이와 같은 콘텐츠를 계속 무료로 제공하는 데 도움이 됩니다!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n제 다른 Leetcode Walkthrough 목록도 확인해보세요:\n\n- Two Sum 문제\n- Palindrome Number 문제\n\n# 주석이 달린 코드 및 단계별 설명\n\n## 솔루션 1: 캐리 처리를 포함한 반복적 접근\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 방법은 두 연결 리스트를 반복하면서 해당하는 숫자를 합쳐서 9보다 큰 경우를 위해 캐리를 관리합니다. 결과를 저장하기 위해 새로운 연결 리스트를 만듭니다. 이 방법은 구현하고 이해하기 쉽기 때문에 직관적입니다. 두 리스트를 동시에 탐색하면 모든 숫자가 정확하게 처리되며 존재하는 경우 최종 캐리도 처리합니다.\n\n```js\ndef add_two_numbers(l1, l2)\n    dummy = ListNode.new(0)  # 결과 리스트의 헤드 역할을 할 더미 노드 생성\n    current = dummy  # 결과 리스트를 구축하기 위한 포인터 초기화\n    carry = 0  # 캐리 초기화\n\n    while l1 || l2  # 두 리스트가 모두 완전히 처리될 때까지 순회\n        x = l1 ? l1.val : 0  # l1의 현재 노드 값 또는 l1이 nil인 경우 0 반환\n        y = l2 ? l2.val : 0  # l2의 현재 노드 값 또는 l2가 nil인 경우 0 반환\n        sum = carry + x + y  # 현재 값과 캐리의 합 계산\n        carry = sum / 10  # 캐리 업데이트\n        current.next = ListNode.new(sum % 10)  # 숫자 값으로 새 노드 생성하고 결과 리스트에 연결\n        current = current.next  # 결과 리스트의 다음 노드로 이동\n        l1 = l1.next if l1  # l1이 있으면 l1의 다음 노드로 이동\n        l2 = l2.next if l2  # l2가 있으면 l2의 다음 노드로 이동\n    end\n\n    current.next = ListNode.new(carry) if carry > 0  # 나머지 캐리가 있는 경우, 해당 값을 갖는 새 노드 생성\n    dummy.next  # 결과 리스트의 헤드 반환\nend\n```\n\n단계별 설명\n\n- 단계 1: 결과 리스트의 헤드로 사용할 더미 노드와 결과 리스트를 구축하기 위한 현재 포인터를 초기화합니다. 캐리를 0으로 초기화합니다.\n- 단계 2: l1 및 l2를 동시에 탐색합니다.\n- 단계 3: 현재 노드의 값(x 및 y)을 추출합니다. 리스트가 완전히 순회된 경우, 값으로 0을 사용합니다.\n- 단계 4: x, y 및 캐리의 합을 계산합니다.\n- 단계 5: 합을 10으로 나누어 캐리를 업데이트합니다.\n- 단계 6: 값이 sum % 10인 새 노드를 만들고 결과 리스트에 연결합니다.\n- 단계 7: 현재 포인터를 새 노드로 이동합니다.\n- 단계 8: l1 및 l2 포인터를 다음 노드로 이동합니다(존재하는 경우).\n- 단계 9: 반복문을 종료한 후, 남은 캐리가 있는지 확인합니다. 있다면 해당 값을 갖는 새 노드를 만들고 결과 리스트에 연결합니다.\n- 단계 10: 결과 리스트의 헤드로 더미 노드의 다음을 반환합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 해결 방법 2: 재귀 접근 방식\n\n이 방법은 숫자 및 캐리의 덧셈을 처리하기 위해 재귀를 사용하여 반복 논리를 작은 재귀 호출로 분해하여 단순화합니다. 재귀를 사용하면 덧셈 과정을 효율적으로 처리하므로 코드가 간결하고 명확해집니다. 이 함수는 각 재귀 호출에서 각 입력 목록의 하나의 숫자를 처리하고 이들을 캐리와 함께 더한 다음 다음 노드로 진행합니다. 이 방법은 상태를 관리하기 위해 호출 스택을 효과적으로 활용하여 재귀를 선호하는 사람들에게 좋은 선택입니다.\n\n```js\ndef add_two_numbers(l1, l2, carry = 0)\n    return ListNode.new(carry) if l1.nil? && l2.nil? && carry > 0  # 기본 사례: 모두 nil이면서 캐리 값이 있는 경우 빈 노드를 반환\n    return nil if l1.nil? && l2.nil?  # 기본 사례: 모두 nil이면서 캐리 값이 없는 경우 빈 노드를 반환\n\n    sum = carry  # 캐리 값으로 시작\n    sum += l1.val if l1  # l1의 현재 노드 값 추가(현재 노드가 있는 경우)\n    sum += l2.val if l2  # l2의 현재 노드 값 추가(현재 노드가 있는 경우)\n\n    result = ListNode.new(sum % 10)  # 숫자 값으로 새 노드 생성\n    result.next = add_two_numbers(l1 ? l1.next : nil, l2 ? l2.next : nil, sum / 10)  # 다음 노드 및 캐리로 재귀 호출\n    result  # 결과 노드 반환\nend\n```\n\n단계별 설명\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 단계 1: 기본 경우: l1과 l2가 모두 nil이고 캐리가 없는 경우 nil을 반환합니다.\n- 단계 2: 현재 노드(l1 및 l2)와 캐리의 값들을 더합니다.\n- 단계 3: 합과 새로운 캐리를 계산합니다.\n- 단계 4: 합 % 10 값을 갖는 새로운 노드를 생성합니다.\n- 단계 5: 새로운 캐리를 전달하여 l1과 l2의 다음 노드로 재귀적으로 함수를 호출합니다.\n- 단계 6: 재귀 호출 결과를 새로운 노드의 다음에 연결합니다.\n- 단계 7: 새롭게 생성된 노드를 반환합니다.\n\n## 솔루션 3: 깨끗한 반복을 위한 Enumerators 사용\n\n이 접근 방식은 Ruby의 Enumerators를 활용하여 링크드 리스트를 반복하면서 코드를 더 깔끔하고 Ruby다운 방식으로 만듭니다. Enumerators는 명시적인 루프를 피하고 코드를 더 읽기 쉽게 만들어주는 Ruby스러운 반복 처리 방식을 제공합니다. Enumerators를 사용함으로써이 솔루션은 각 숫자가 올바르게 합산되고 처리되도록 하고 불필요하게 새 노드를 생성하지 않고 리스트를 탐색하고 캐리를 관리하는 과정을 간소화합니다.\n\n```js\ndef add_two_numbers(l1, l2)\n    dummy = ListNode.new(0)  # 결과 리스트의 헤드로 사용할 더미 노드를 만듭니다\n    current = dummy  # 결과 리스트를 구성하는 포인터를 초기화합니다\n    carry = 0  # 캐리를 초기화합니다\n\n    e1 = to_enum(l1)  # l1에 대한 이너레이터를 생성합니다\n    e2 = to_enum(l2)  # l2에 대한 이너레이터를 생성합니다\n\n    loop do\n        begin\n            x = e1.next  # e1에서 다음 값 가져오기\n        rescue StopIteration\n            x = ListNode.new(0)  # e1이 소진된 경우 0 사용\n        end\n\n        begin\n            y = e2.next  # e2에서 다음 값 가져오기\n        rescue StopIteration\n            y = ListNode.new(0)  # e2가 소진된 경우 0 사용\n        end\n\n        sum = carry + x.val + y.val  # 현재 값 및 캐리의 합 구하기\n        carry = sum / 10  # 캐리 업데이트\n        current.next = ListNode.new(sum % 10)  # 숫자 값으로 새 노드 생성하고 결과 리스트에 연결\n        current = current.next  # 결과 리스트의 다음 노드로 이동\n\n        break if x.next.nil? && y.next.nil? && carry.zero?  # 두 리스트가 모두 소진되고 캐리가 남아있지 않은 경우 반복문 종료\n\n    end\n\n    current.next = ListNode.new(carry) if carry > 0  # 남아 있는 캐리가 있으면 이를 위한 새 노드 생성\n    dummy.next  # 결과 리스트의 헤드 반환\nend\n\ndef to_enum(node)\n    Enumerator.new do |yielder|\n        while node\n            yielder << node  # 각 노드를 반환합니다\n            node = node.next  # 다음 노드로 이동합니다\n        end\n    end\nend\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n단계별 설명\n\n- 단계 1: 연결 리스트를 열거자(enumerator)로 변환하는 helper method인 to_enum을 생성합니다.\n- 단계 2: 결과 리스트의 머리 역할을 하는 더미(dummy) 노드와 결과 리스트를 구성할 현재 포인터를 초기화합니다. 그리고 carry를 0으로 초기화합니다.\n- 단계 3: 열거자 e1과 e2를 사용하여 l1과 l2를 반복(iterate)합니다.\n- 단계 4: e1과 e2에서 다음 값을 가져오려 시도합니다. 열거자가 소진된 경우 해당 값을 0으로 취급합니다.\n- 단계 5: 현재 값과 carry의 합을 계산합니다.\n- 단계 6: 합을 10으로 나누어 carry를 업데이트합니다.\n- 단계 7: sum % 10의 값으로 새 노드를 생성하고 이를 결과 리스트에 연결합니다.\n- 단계 8: 현재 포인터를 새 노드로 이동합니다.\n- 단계 9: 두 열거자가 모두 소진되고 carry가 남아있지 않은 경우 루프를 탈출합니다.\n- 단계 10: 루프를 탈출한 후 남은 carry가 있는지 확인합니다. 있다면 carry 값을 가진 새 노드를 만들고 결과 리스트에 연결합니다.\n- 단계 11: 결과 리스트의 머리를 나타내는 더미 노드의 다음을 반환합니다.\n\n## 솔루션 4: 입력 리스트의 장소를 변경하여 수정\n\n이 솔루션은 입력 리스트 중 긴 쪽의 노드를 그대로 수정하여 노드를 재사용하고 결과 리스트의 추가 노드를 생성하는 것을 피합니다. 기존 노드를 직접 업데이트함으로써 공간 사용을 최소화하고 O(1)의 상수 공간 복잡도를 달성합니다. 이 방법은 노드 포인터와 값들을 정확하게 처리하여 올바른 결과를 보장하기 위해 주의 깊은 처리가 필요합니다. 메모리 소비를 줄이면서 효율성을 유지하므로 대량의 입력 크기를 다루는 데 특히 유리합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\ndef add_two_numbers(l1, l2)\n    carry = 0  # 캐리를 0으로 초기화합니다.\n    head = l1   # l1의 헤드부터 시작합니다.\n    prev = nil  # 이전 포인터를 초기화합니다.\n\n    while l1 && l2  # 두 리스트를 모두 탐색합니다.\n        sum = l1.val + l2.val + carry  # 현재 값과 캐리의 합을 계산합니다.\n        carry = sum / 10  # 캐리를 업데이트합니다.\n        l1.val = sum % 10  # l1의 현재 노드 값을 업데이트합니다.\n        prev = l1  # 이전 포인터를 이동합니다.\n        l1 = l1.next  # l1의 다음 노드로 이동합니다.\n        l2 = l2.next  # l2의 다음 노드로 이동합니다.\n    end\n\n    if l2  # l2가 더 긴 경우, 나머지 l2를 l1에 추가합니다.\n        prev.next = l2\n        l1 = l2\n    end\n\n    while l1  # 더 긴 리스트의 나머지 부분을 처리합니다.\n        sum = l1.val + carry  # 현재 값과 캐리의 합을 계산합니다.\n        carry = sum / 10  # 캐리를 업데이트합니다.\n        l1.val = sum % 10  # 현재 노드 값을 업데이트합니다.\n        prev = l1  # 이전 포인터를 이동합니다.\n        l1 = l1.next  # 다음 노드로 이동합니다.\n    end\n\n    if carry > 0  # 남은 캐리가 있는 경우, 끝에 새 노드를 추가합니다.\n        prev.next = ListNode.new(carry)\n    end\n\n    head  # 수정된 리스트의 헤드를 반환합니다.\nend\n```\n\n단계별 설명\n\n- 단계 1: 캐리를 0으로 초기화하고 l1의 시작 부분을 head로 설정합니다. 이전 노드를 추적하기 위해 prev를 사용합니다.\n- 단계 2: l1과 l2를 반복하여 각 노드 쌍에 대해:\n  - 노드 값 및 캐리의 합을 계산합니다.\n  - l1의 노드 값을 sum % 10으로 업데이트합니다.\n  - carry를 sum / 10으로 업데이트합니다.\n  - prev를 l1으로 이동한 다음 l1과 l2를 다음 노드로 이동합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 단계 3: l2가 더 긴 경우, l2의 나머지 부분을 l1에 추가하고 l1을 계속 처리합니다.\n- 단계 4: 더 긴 목록에 남아있는 노드를 계속 처리하고, 노드 값을 및 캐리를 업데이트합니다.\n- 단계 5: 모든 노드를 처리한 후에도 캐리가 남아있는 경우, 캐리 값으로 새 노드를 끝에 추가합니다.\n- 단계 6: 수정된 목록의 헤드를 반환합니다.\n","ogImage":{"url":"/assets/img/2024-06-23-SolvingtheAddTwoNumbersProblemonLeetCodeRubySolutionsWalkthrough_0.png"},"coverImage":"/assets/img/2024-06-23-SolvingtheAddTwoNumbersProblemonLeetCodeRubySolutionsWalkthrough_0.png","tag":["Tech"],"readingTime":20},{"title":"Rails 7에서 Sidekiq Gem을 사용한 백그라운드 작업 처리 Part-I","description":"","date":"2024-06-23 20:52","slug":"2024-06-23-ProcessingBackgroundJobsUsingSidekiqGeminRails7Part-I","content":"\n<img src=\"/assets/img/2024-06-23-ProcessingBackgroundJobsUsingSidekiqGeminRails7Part-I_0.png\" />\n\n레일즈 개발자로서, 백엔드 개발자들이 거의 모든 시간에 수행하는 일로 비동기적으로 백그라운드에서 실행되는 코드를 작성하는 것은 매우 흔한 작업입니다.\n\n예를 들어, 새로운 고객에게 환영 이메일을 보내거나 수천 건의 레코드를 통해 복잡한 계산을 위해 백그라운드 처리를 사용합니다.\n\n다행히도, 모든 무거운 작업을 처리하고 간단한 인터페이스를 제공하여 우리의 시간을 아낄 수 있는 도구들이 있습니다. 그 중 하나인 Sidekiq를 살펴보겠습니다!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# Sidekiq이란 무엇인가요?\n\nSidekiq은 루비 온 레일즈(Ruby on Rails) 애플리케이션을 위한 인기 있는 백그라운드 작업 처리 라이브러리입니다. Sidekiq은 주요 요청-응답 주기(main request-response cycle)에서 시간이 많이 소요되는 작업들을 간편하고 효율적으로 처리할 수 있는 방법을 제공합니다.\n\nSidekiq이 의존하는 세 가지 주요 구성 요소가 있습니다:\n\n- Redis\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nSidekiq은 작업자에 의해 처리되는 작업을 저장하는 데 메모리 데이터 저장소인 Redis를 사용합니다.\n\n클라이언트\n\n백그라운드에서 처리되는 작업을 생성하는 Ruby 또는 Rails 프로세스입니다.\n\n서버\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 작업은 Redis 대기열에서 작업을 가져와 실행하는 데 책임이 있어요.\n\n너무 많은 텍스트인가요? 지금 무언가를 만들어보죠!\n\n## 전제 조건\n\n언급했듯이 Sidekiq는 백그라운드 작업을 대기열에 넣기 위해 Redis에 의존합니다. 따라서 로컬에 Redis 서버가 실행 중인지 확인해주세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 단계 1\n\n새 프로젝트를 만들거나 이미 설정된 프로젝트가 있다면이 단계를 건너 뛰세요.\n\n```js\n$ rails new sidekiq_tutorial\n```\n\n# 단계 2\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 프로젝트 안으로 들어오신 것을 환영합니다:\n\n```js\n$ bundle add sidekiq\n```\n\n# 단계 3\n\n이제, 새 작업을 생성하고 Sidekiq 워커로 푸시할 준비가 되었습니다. 새 작업을 생성해봅시다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n$ rails generate sidekiq:job my_first_job\n```\n\n여기에 원하는 내용을 입력하고 app/sidekiq/my_first_job.rb과 테스트 파일이 생성됩니다. 작업 파일의 내용을 다음과 같이 편집해 봅시다:\n\n```js\nclass MyFirstJob\n  include Sidekiq::Job\n\n  def perform(name,age)\n    puts \"나는 #{name}이고, 나이가 #{age}살인 첫 작업을 실행 중입니다.\"\n    #여기에는 다른 유효한 루비/레일스 코드를 넣을 수 있어요!\n  end\nend\n```\n\n여기서는 콘솔에 텍스트를 로깅하긴 하지만, 여기에서는 거의 모든 유효한 코드를 실행할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 작업을 실행하기 전에 Redis가 올바르게 구성되어 있는지 확인해야 합니다.\n\n## Redis 구성\n\n이 작업을 실행하기 전에 Redis가 올바르게 구성되어 있는지 확인해야 합니다.\n\n두 가지 방법이 있습니다. 하나는 REDIS_URL 환경 변수(`dotenv-rails gem`을 사용하여)를 사용하는 방법이며, 더 복잡한 설정이 필요한 경우에는 config/initializers에 있는 sidekiq.rb 파일을 만들 수 있습니다.\n\n### .env 파일 사용하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nREDIS_URL=redis://redis.example.com:7372/0\n```\n\n## config/initializers/sidekiq.rb 파일을 사용하기\n\n```js\nSidekiq.configure_server do |config|\n  config.redis = { url: 'redis://redis.example.com:7372/0' }\nend\n\nSidekiq.configure_client do |config|\n  config.redis = { url: 'redis://redis.example.com:7372/0' }\nend\n```\n\n참고: Redis와 연결하려면 위의 설정 중 하나를 사용해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만약 당신이 Docker에 능숙하다면, 간단한 Redis 컨테이너를 사용하여 Redis를 실행하고 Rails 앱과 연결할 수 있습니다.\n\n# 작업을 대기열에 넣기\n\nRails 콘솔에서 작업을 실행해 봅시다:\n\n```js\n$ rails c\n\n3.0.0 :001 > MyFirstJob.perform_async \"Affan\", 31\n=> \"5a4c435ddd2295a6104c8fcb\"\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n작업이 성공적으로 생성되었습니다.\n\n# 작업 실행하기\n\n이제 작업이 대기열에 들어 있으므로 Sidekiq 워커를 실행하여 작업을 실행해야 합니다. 다른 터미널 창을 열고 다음을 실행하세요:\n\n```js\n$ bundle exec sidekiq\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n모든 것이 잘 작동되면 다음과 같은 내용을 볼 수 있을 거예요.\n\n![image](/assets/img/2024-06-23-ProcessingBackgroundJobsUsingSidekiqGeminRails7Part-I_1.png)\n\n작업을 마치면 ctrl+c를 사용하여 워커를 종료할 수 있어요.\n\n# 결론\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 튜토리얼의 첫 번째 부분에서는 Sidekiq에 대해 어떻게 백그라운드 작업을 처리하는지, 새로운 Rails 프로젝트에서 간단한 작업을 만드는 방법에 대해 설명했습니다. 또한 Sidekiq를 Rails 앱에 연결하는 구성 옵션에 대해 알아보았습니다. 다음 이야기의 2부에서는 이 주제와 관련된 고급 내용에 대해 논의할 예정입니다 :)\n","ogImage":{"url":"/assets/img/2024-06-23-ProcessingBackgroundJobsUsingSidekiqGeminRails7Part-I_0.png"},"coverImage":"/assets/img/2024-06-23-ProcessingBackgroundJobsUsingSidekiqGeminRails7Part-I_0.png","tag":["Tech"],"readingTime":7},{"title":"튜토리얼 Windows Ruby on Rails  SQLite 시작하는 방법","description":"","date":"2024-06-23 20:51","slug":"2024-06-23-TUTORIALWindowsGetstartedwithRubyonRailsSQLite","content":"\n안녕하세요! 🙂 이 직선적인 튜토리얼에서는 루비 온 레일즈 + sqlite3 설치 방법을 안내해 드릴 거에요.\n\n## 루비 설치하기\n\n- 이 URL에서 루비 + Devkit 설치 프로그램을 다운로드하세요. 여기서는 선호하는 버전을 선택할 수 있어요. 이 튜토리얼을 작성한 날짜를 기준으로 최신 안정화 버전은 이 URL에서 사용 가능해요.\n- 설치 프로그램을 실행하세요. 모든 옵션을 선택하고 계속 다음을 눌러 설치를 진행하세요.\n- 설치가 완료되면 터미널이 열리고 MSYS2 설치에 대해 묻습니다. 그냥 Enter 키를 누르면 기본 설정으로 설치됩니다.\n- MSYS2 설치가 완료되면 다시 Enter 키를 눌러 터미널을 닫으세요.\n\n## 루비젬 설치하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- RubyGems(루비의 패키지 관리 프레임워크)를 이 URL에서 다운로드하세요(ZIP 형식 파일 받기). 이 튜토리얼 작성 시점을 기준으로, 최신 안정 버전이 이 URL에서 제공됩니다.\n- 방금 다운로드한 파일을 압축 해제하고 해당 폴더에서 터미널을 열어주세요.\n- 다음 명령어를 입력하세요: ruby setup.rb.\n- 작업이 완료되면 터미널을 닫고 다른 터미널을 열어주세요.\n\n## RAILS 설치하기\n\n- 다음 명령어를 입력하세요: gem install -V rails. 이 명령은 호환되는 최신 버전의 Rails를 설치합니다.\n- 작업이 완료되면, Rails가 설치되어 있어야 합니다. Rails 버전을 확인하려면 rails -v 명령을 실행하세요. 오류가 발생하면 설치가 올바르게 이루어지지 않았다는 것을 의미합니다.\n\n## BUNDLER 설치하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 이제 'gem install -V bundler' 명령을 실행해주세요. Bundler는 필요한 정확한 젬 및 버전을 추적하고 설치하여 Ruby 프로젝트에 일관된 환경을 제공합니다.\n\n## SQLITE3 설치\n\n- 마지막 단계는 'gem install -V sqlite3'을 실행하는 것입니다.\n\n## PSYCH 설치\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- gem install psych 명령어를 실행해주세요. --platform=ruby를 꼭 붙여주셔야 합니다.\n- 다음 단계로 넘어가시기 전에 설치가 완료될 때까지 기다려주세요.\n\n## 첫 번째 프로젝트 만들기\n\n- 첫 번째 레일즈 프로젝트를 만들려면 프로젝트를 저장할 위치로 이동하세요. 예: cd desktop.\n- NameOfProject로 레일즈 프로젝트를 생성하기 위해 rails new NameOfProject를 입력하세요. 이 명령어는 많은 파일을 생성하고 프로젝트의 종속성을 설치합니다.\n\n잘 동작하기를 바래요 :)\n","ogImage":{"url":"/assets/img/2024-06-23-TUTORIALWindowsGetstartedwithRubyonRailsSQLite_0.png"},"coverImage":"/assets/img/2024-06-23-TUTORIALWindowsGetstartedwithRubyonRailsSQLite_0.png","tag":["Tech"],"readingTime":3},{"title":"Ruby on Rails 7에서 Javascript 및 Bootstrap 에셋 번들링 하는 방법","description":"","date":"2024-06-23 20:50","slug":"2024-06-23-JavascriptBootstrapAssetBundlinginRubyonRails7","content":"\n최근 몇 달 동안 (2023년 초반) 저는 Ruby on Rails를 통해 프론트엔드 웹 개발을 배우고 있는 중이에요. 그리고 지금까지 정말 멋진 여정이었어요. 그런데 프로젝트에 자산 (자바스크립트 및 CSS 라이브러리)을 넣는 방법에 몇 가지 변화가 있었던데, 이는 초보자에게는 조금 어려울 수 있어요.\n\n이번 시간 동안 많은 검색을 해본 결과, Ruby on Rails 포럼에서 해당 질문에 대한 포스트를 찾았어요. 그리고 여기서 4가지 방법으로 프로젝트에 자산을 로드하는 방법을 설명하겠어요. 또한 내가 발견한 몇 가지 결과물도 이 가이드에서 설명하려고 해요. 이 결과물은 대부분 David Heinemeier Hansson (또는 커뮤니티에서는 DHH로 알려진)의 유튜브 튜토리얼에서 나온 것들이에요. 그는 Ruby on Rails 창시자이기도 하죠.\n\n# 무슨 일이 일어나고 있지?\n\nRuby on Rails는 Ruby로 작성된 프레임워크로, 웹 애플리케이션 개발을 많이 도와줘요 (프론트엔드 및 백엔드 모두, 즉: HTML, Javascript, CSS, 그리고 데이터베이스 및 URI 경로 통합이요). Ruby로 HTML과 Javascript를 작성할 수도 있지만, 서버를 시작하고 브라우저에서 사이트를 볼 때는 HTML만이 기본적으로 렌더링될 뿐이에요. 따라서, 우리는 사용하고 싶은 자바스크립트 및 라이브러리, 그리고 사용자 정의 CSS와 CSS 라이브러리를 프로젝트에 컴파일할 방법이 필요해요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n부트스트랩(버튼이나 네비게이션 바와 같은 스타일이 적용된 컴포넌트를 제공하는 CSS 라이브러리)을 제 프로젝트에 번들링하려고 노력했는데, 때로는 CSS 라이브러리가 제대로 로드되지 않아 사이트가 90년대 페이지처럼 순수 HTML로 렌더링되고, 대부분의 경우 CSS 라이브러리가 로드되더라도 상호작용(예: 네비게이션 바 축소 메뉴 확장)에 반응하지 않았습니다. 이는 Bootstrap이 작동하기 위해 필요한 JavaScript가 제대로 로드되지 않음을 의미합니다.\n\n또한 대부분의 자습서들이 작동하지 않아서 무엇이 문제인지 정말로 이해하기로 결심했습니다.\n\n마지막으로 이 게시물에서 설명한대로, 이 목표를 달성하는 네 가지 방법을 발견했습니다(2023년 3월 현재, Ruby On Rails 7 기준):\n\n- 이전 방식(7버전 이전) : 스프로켓 및 젬을 통해 부트스트랩을 수동으로 번들링하는 방식;\n- Webpacker 젬 사용: 이 젬은 자바스크립트 Webpack, Node 및 yarn을 랩핑합니다. JavaScript ES6부터는 번역이 더 이상 필요하지 않으며 이 젬은 폐지되었고 shakapacker 젬으로 대체되었습니다. 해당 젬의 GitHub에 따르면 :\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n참고: HMR은 Hot Module Reloading의 약자로, 코드를 편집할 때 사이트가 자동으로 다시로드됩니다.\n\n- 새로운 방법 #1: Rails 7 Importmaps를 사용하는 방법: 단일 파일 importmap.rb에 가져오기를 정의합니다. 이 파일은 코드를 JS 및 CSS로 변환하고 이 파일들을 번들링합니다.\n- 새로운 방법 #2: Rails 7 JS 번들링 및 CSS 번들링 gems를 사용하는 방법: 이를 새 프로젝트에 선언하거나 기존 프로젝트에 추가하고, esbuild 및 yarn (또는 다른 도구를 선택할 수도 있음)를 사용하여 CSS 파일을 변환하고 번들링합니다.\n\n포럼에서 설명한대로, rails pipeline은 세 가지 작업을 수행합니다: 변환(다른 확장자를 .js 및 .css로 변환), 번들링(모든 파일을 하나의 .js 및 .css 파일로 결합하여 브라우저에서 작동하도록 함), 그리고 파일 다이제스팅(파일을 해싱하고 브라우저 캐시를 가능하게하며 개발중 캐시를 무효화해 코드 변경이 브라우저 캐시에 덮어씌워지지 않도록 합니다). Sprockets는 모든 세 가지를 실행했었기 때문에 옵션 #1이 작동하지만, importmaps 또는 js/css 번들링 gems를 사용하는 경우 첫 2단계만 수행하고 다이제스팅은 sprockets에 남깁니다.\n\n# 튜토리얼\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n레일즈 7은 이미 importmaps를 사용할 수 있도록 사전 구성되어 있습니다. 따라서 importmap 및 번들링 젬 방식을 설명하고 있어요. 번들링 젬 방식은 다음 튜토리얼에서 소개될 예정입니다.\n\n# Importmaps 튜토리얼\n\n- 레일즈를 사용하여 새 앱을 시작하세요. [앱이름]으로 rails new [appname];\n\n![이미지](/assets/img/2024-06-23-JavascriptBootstrapAssetBundlinginRubyonRails7_0.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-06-23-JavascriptBootstrapAssetBundlinginRubyonRails7_1.png\" />\n\n우리가 볼 수 있듯이, Rails 7은 이미 우리를 위해 스프라켓(4)을 설정하고 importmaps(1)를 설치하며, 메인 HTML 파일(2)에서 사용하고, 우리의 import JS 파일을 스프라켓 매니페스트.js에 연결하고(3 및 4), 필요하다면 CDN을 통해 CSS 및 JS 파일을 핀(import)할(importmap) 수 있도록 명령 줄에서 importmap 명령을 활성화합니다.\n\n- 부트스트랩의 경우, 우리는 젬 튜토리얼을 따릅니다: Gemfile에서 부트스트랩 젬을 가져와 sprockets-rails이 사용되는지 확인합니다. 젬은 루비 라이브러리이며, Rails는 rubygems.org에서 이를 로드합니다. 우리의 모든 젬은 Gemfile에 선언됩니다.\n\n<img src=\"/assets/img/2024-06-23-JavascriptBootstrapAssetBundlinginRubyonRails7_2.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![screenshot1](/assets/img/2024-06-23-JavascriptBootstrapAssetBundlinginRubyonRails7_3.png)\n\n- Change the application.css extension to .scss and replace the file contents by @import \"bootstrap\"\n\n![screenshot2](/assets/img/2024-06-23-JavascriptBootstrapAssetBundlinginRubyonRails7_4.png)\n\n- Add bootstrap and popper to importmap (popper is required by bootstrap to show popovers, like the dropdown on our navbar)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Image 1](/assets/img/2024-06-23-JavascriptBootstrapAssetBundlinginRubyonRails7_5.png)\n\n![Image 2](/assets/img/2024-06-23-JavascriptBootstrapAssetBundlinginRubyonRails7_6.png)\n\n- Add Bootstrap (and popper) to be precompiled in our assets.rb\n\n![Image 3](/assets/img/2024-06-23-JavascriptBootstrapAssetBundlinginRubyonRails7_7.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 번들 설치를 통해 gems를 설치하세요 (또는 단축키 번들)\n\n![이미지1](/assets/img/2024-06-23-JavascriptBootstrapAssetBundlinginRubyonRails7_8.png)\n\n만약 rails 서버를 통해 앱을 시작하면 (또는 단축키 rails s를 사용하면), 레일즈 페이지가 표시됩니다:\n\n![이미지2](/assets/img/2024-06-23-JavascriptBootstrapAssetBundlinginRubyonRails7_9.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리 앱에 페이지를 추가하려면 controllers(home/index)을 생성합니다. 레일즈 generate controllers home index(단축어로는 rails g)를 사용하세요. 이 명령어는 home_controller(관례에 따라 지어지는 새로운 컨트롤러)와 index 액션을 생성합니다.\n\n![이미지1](/assets/img/2024-06-23-JavascriptBootstrapAssetBundlinginRubyonRails7_10.png)\n\n![이미지2](/assets/img/2024-06-23-JavascriptBootstrapAssetBundlinginRubyonRails7_11.png)\n\n정말 멋지죠! 하지만 이 페이지를 루트(localhost:3000/)로 설정하려면 routes.rb에서 변경하면 됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 Markdown 형식으로 변환되었습니다.\n\n![이미지](/assets/img/2024-06-23-JavascriptBootstrapAssetBundlinginRubyonRails7_12.png)\n\n원래 우리는 Rails에게 앱의 루트가 home 컨트롤러이고 인덱스라는 액션에 있다고 말합니다. 이제 rails s로 서버를 재시작하고 브라우저를 엽니다:\n\n![이미지](/assets/img/2024-06-23-JavascriptBootstrapAssetBundlinginRubyonRails7_13.png)\n\nBootstrap이 작동하는지 확인하기 위해 우리는 부트스트랩 사이트에서 데모 네비게이션 바를 새로운 *navbar.html.erb 파일에 복사합니다 (이름 앞의 *는 중요합니다!)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Image](/assets/img/2024-06-23-JavascriptBootstrapAssetBundlinginRubyonRails7_14.png)\n\n그리고 이를 app/views/shared 폴더에 넣어주세요 (views 폴더 안에 shared 폴더를 만드세요).\n\n우리의 \\_navbar.html.erb는 부분(partial)이라고 불립니다: 이것은 우리의 html의 일부, 컴포넌트로 렌더링됩니다. 또한, 우리 Rails 프로젝트의 \"html\" 파일들은 실제로 순수한 html이 아니라 특별한 .html.erb (Embedded Ruby) 확장자를 사용합니다. 이렇게 하면 우리는 HTML 코드 안에 Ruby 코드를 삽입할 수 있습니다.\n\nApplication.html.erb로 이동하여 render_partial에 우리의 부분을 추가해보세요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Screenshot 1](/assets/img/2024-06-23-JavascriptBootstrapAssetBundlinginRubyonRails7_15.png)\n\nyield는 컨트롤러에서 요청한 페이지를 렌더링하는 특별한 단어입니다. 이 방법을 사용하면 전체 HTML에 application.html.erb 헤더와 네비게이션 바가 모든 페이지에 포함되며, yield는 요청한 페이지(이 경우 루트)를 렌더링합니다:\n\n![Screenshot 2](/assets/img/2024-06-23-JavascriptBootstrapAssetBundlinginRubyonRails7_16.png)\n\n부트스트랩 네비게이션 바가 성공적으로 로드되었지만 드롭다운 메뉴 클릭이 작동하지 않습니다. sprockets에게 부트스트랩에 필요한 Javascript를 번들하도록 알려야 합니다. javascript/application.js 파일에 누락된 require를 추가해줍니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-06-23-JavascriptBootstrapAssetBundlinginRubyonRails7_17.png\" />\n\n<img src=\"/assets/img/2024-06-23-JavascriptBootstrapAssetBundlinginRubyonRails7_18.png\" />\n\n이제 모든 것이 잘 작동합니다!\n\n이 간단한 튜토리얼로 도움이 되었기를 바랍니다. Rails는 웹 애플리케이션을 개발하는 데 많은 도움이 되며, 여러분도 사용하면 좋겠네요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래에서 뵙겠습니다!\n\n## 유용한 링크:\n\n- Rails 포럼, 포스트 및 제 답변;\n- Bootstrap Rubygems 설치 및 Bootstrap gem의 깃허브;\n","ogImage":{"url":"/assets/img/2024-06-23-JavascriptBootstrapAssetBundlinginRubyonRails7_0.png"},"coverImage":"/assets/img/2024-06-23-JavascriptBootstrapAssetBundlinginRubyonRails7_0.png","tag":["Tech"],"readingTime":10},{"title":"RSpec 매처와 기대 설정 방법","description":"","date":"2024-06-23 20:48","slug":"2024-06-23-RSpecMatchersandExpectations","content":"\n![이미지](/assets/img/2024-06-23-RSpecMatchersandExpectations_0.png)\n\n버그가 없는 코드를 작성하는 것은 끝이 없는 전투입니다. 가장 경험 많은 개발자라도 모든 예외 상황과 잠재적인 문제를 잡는 데 어려움을 겪습니다. 그러나 올바른 도구와 기술을 활용하면 소프트웨어의 신뢰성을 크게 향상시킬 수 있습니다.\n\n# RSpec Expectations 탐색\n\nRSpec의 expectations는 Ruby 웹 어플리케이션을 테스트하는 강력한 도구입니다. 전통적인 어설션과 달리 expectations는 조합성, 자동 부정, 가독성 향상 및 더 유용한 에러 메시지를 제공합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 기대하는 요소\n\n기대는 세 가지 주요 부분으로 구성됩니다:\n\n- Subject: 일반적으로 루비 클래스의 인스턴스인 테스트 대상 객체입니다.\n- Matcher: 예상되는 동작을 지정하고 통과/실패 논리를 제공하는 객체입니다.\n- 사용자 정의 실패 메시지(선택 사항): 기대가 실패할 때 추가적인 문맥을 제공하기 위한 사용자 정의 메시지입니다.\n\n여기 예시가 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 주제\n\nsubject = Course.new(name: \"루비 입문\")\n\n# 매처 및 사용자 정의 실패 메시지를 사용한 예상\n\nexpect(subject.name).to eq(\"루비 입문\"), \"과정 이름이 일치해야 함\"\n\n# 매처 구성\n\n다양한 방법으로 매처를 조합하여 복잡한 동작을 정밀하게 지정할 수 있습니다:\n\n- 다른 매처에 매처 전달하기:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nexpect(subject.lessons).to start_with(an_object_having_attributes(title: \"Ruby Basics\"))\n```\n\n2. Embedding matchers in Arrays and Hashes:\n\n```js\nexpected_student = {\n  name: \"John Doe\",\n  enrolled_courses: an_object_having_attributes(name: a_string_starting_with(\"Introduction\"))\n}\nexpect(subject.students).to include(expected_student)\n```\n\n3. Combining matchers with logical operators:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nexpect(subject.grading_system).to be_present & match(/letter|numeric/)\n```\n\n## 전통적인 단언문보다 RSpec의 장점\n\n전통적인 단언문과는 달리, RSpec의 기대치는 다음과 같은 장점을 제공합니다:\n\n- 개선된 가독성: 구문은 자연어에 더 가깝기 때문에 테스트를 읽고 이해하기 쉽습니다.\n- 결합성: 매처를 결합하여 더 복잡한 단언문을 만들 수 있으며 명확성을 잃지 않습니다.\n- 더 나은 오류 메시지: 테스트가 실패할 때 RSpec은 디버깅을 더 쉽게 만드는 자세한 메시지를 제공합니다.\n- 자동 부정: .not_to 또는 .to_not를 사용하면 부정이 더 직관적이며 테스트의 표현력을 향상시킵니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 생성된 예제 설명\n\nMatchers는 자체적으로 설명을 제공하여 RSpec이 예제에 대한 가독성있는 설명을 생성할 수 있게 합니다. 이는 중복을 줄이고 테스트를 미래를 대비하여 더 견고하게 만드는 데 도움이 될 수 있습니다.\n\n```js\nRSpec.describe Course, \"#enrolled_students\" do\n  subject { Course.new(name: \"Introduction to Ruby\") }\n\n  it { is_expected.to have_attributes(enrolled_students: be_empty) }\n  it { should_not have_attributes(enrolled_students: include(an_object_having_attributes(name: \"John Doe\"))) }\nend\n```\n\n출력은 다음과 같이 표시됩니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nCourse#enrolled_students\nshould have attributes enrolled_students: []\nshould not have attributes enrolled_students: [#<name: \"John Doe\">]\n\nWhile generated descriptions are convenient, use them judiciously. They can be misleading if your setup code changes, and one-liner specs can sometimes\nbe harder to read and maintain.\n\n# Exploring RSpec’s Matchers for Your App\n\nRSpec offers a wide range of built-in matchers to help you write expressive and robust tests.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 기본 일치자\n\n이러한 일치자는 문자열, 숫자 및 부울과 같은 기본 데이터 유형을 처리합니다. 예를 들어, 학생의 이름이 특정 값과 일치하는지 테스트하려면:\n\n```js\nstudent = Student.new(name: \"John Doe\")\nexpect(student.name).to eq(\"John Doe\")\n```\n\n# 컬렉션 일치자\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nRSpec은 배열이나 해시와 같은 컬렉션과 함께 작업하는 여러 매처를 제공합니다. 특정 요소가 컬렉션에 포함되어 있는지 확인하려면 include를 사용할 수 있습니다:\n\n```js\nenrolled_courses = [\n  { name: \"Ruby Basics\", credits: 3 },\n  { name: \"Web Development\", credits: 5 }\n]\n\nexpect(enrolled_courses).to include(\n  an_object_having_attributes(name: \"Ruby Basics\")\n)\n```\n\nmatch 매처는 깊게 중첩된 데이터 구조에 유용하며, 배열 요소나 해시 값에 대해 어떤 수준에서든 매처를 대체할 수 있습니다.\n\n# 블록 매처\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n가끔은 코드 블록의 동작을 테스트해야 할 때가 있습니다. 예를 들어, 예외가 발생하는지 확인하거나 메소드가 블록에 제어를 양보하는지 확인하는 것입니다. 이런 시나리오에는 RSpec의 블록 매처들이 유용합니다.\n\n```js\nexpect { course.enroll(nil) }.to raise_error(ArgumentError)\n\nexpect { |block| course.lessons.each(&block) }.to yield_successive_args(\n  [\"Lesson 1\", 1],\n  [\"Lesson 2\", 2]\n)\n```\n\n# 조합된 매처들\n\nRSpec의 장점 중 하나는 매처들을 조합할 수 있다는 것입니다. 이를 통해 복잡한 동작을 정확하게 지정할 수 있습니다. 논리 연산자를 사용하여 매처를 결합하거나, 하나의 매처를 다른 매처로 전달하거나, 매처를 데이터 구조 안에 포함시킬 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nexpect(course.lessons).to all(\n  have_attributes(duration: a_value_between(30, 90))\n    .and(start_with(\"Lesson\"))\n)\n```\n\n# 간단한 설명\n\nRSpec expectations은 조합성, 가독성 및 자세한 오류 메시지를 제공합니다. 복잡한 조건을 정확하게 지정하기 위해 matcher composition을 사용하세요.\n\n기본 데이터 유형의 경우 등가성 및 진실성 matcher를 사용하세요. include, match 및 contain_exactly로 컬렉션을 확인하세요. 예외와 블록 matcher를 사용하여 코드 동작을 테스트하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n일치자를 중첩하여 배치하거나 데이터 구조에 삽입하여 논리 연산자를 사용하여 작성하세요. 엄격한 동등성보다는 유연한 일치자를 선택하세요. 가독성을 높이기 위해 별칭 및 사용자 정의 메시지를 사용하세요.\n","ogImage":{"url":"/assets/img/2024-06-23-RSpecMatchersandExpectations_0.png"},"coverImage":"/assets/img/2024-06-23-RSpecMatchersandExpectations_0.png","tag":["Tech"],"readingTime":7},{"title":"2024년 최신 가이드 Rails 프로젝트에 Swagger UI 설정하는 방법","description":"","date":"2024-06-23 20:47","slug":"2024-06-23-HowtoSetUpSwaggerUIforRailsProject2024Edition","content":"\n![이미지](/assets/img/2024-06-23-HowtoSetUpSwaggerUIforRailsProject2024Edition_0.png)\n\n명확하고 상호작용이 가능한 API 문서 작성은 유지보수 가능하고 접근성 있는 웹 서비스를 개발하는 중요한 부분입니다. Swagger UI는 개발자를 위한 동적 문서 인터페이스로서, Ruby on Rails 프로젝트에 통합하면 개발자 경험을 크게 향상시킬 수 있습니다. 이 글에서는 Grape API를 위한 인기 있는 gem인 grape-swagger와 RSpec API 문서 작성을 위한 gem인 rswag를 사용하여 Swagger UI를 설정하는 과정을 자세히 설명합니다.\n\n---\n\n# 해결책 1: 일반적인 Rails 프로젝트용\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nCordyline은 Progressive Documentation 아이디어를 가진 새로운 프로젝트에요.\n\n## 단계 1: Cordyline 설치\n\nCordyline 공식 웹사이트를 방문해서 미리 만들어진 gem 앱을 다운로드하세요.\n\n## 단계 2: 통합\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n루비 온 레일즈 프로젝트를 선택하고 번들 설치를 실행해주세요.\n\n(base) 컨트롤러에 도우미 모듈을 추가해주세요.\n\n```js\nclass ApplicationController < ActionController::API\n include Cordyline::DocGen\nend\n```\n\n## 단계 3: 첫 번째 문서 작성\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n컨트롤러의 모든 동작에서는 docto 메서드를 사용하여 문서 주석을 작성하세요.\n\n```js\nclass WelcomeController\n  doc \"인사 엔드포인트, 아무 동작 없음\" do\n    detail \"일부 세부 정보\"\n  end\n\n  def index\n  end\nend\n```\n\n## 단계 4: Swagger 문서 호스팅\n\n아래 라인을 routes.rb 파일에 추가하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```ruby\nrequire 'cordyline/web'\n\nTestApp::Application.routes.draw do\n  mount Cordyline::Web => '/team_doc' # 또는 다른 경로\nend\n```\n\n이제 팀은 배포된 웹사이트에서 /team_doc/index.html 경로로 Swagger 문서에 액세스할 수 있습니다.\n\n# 해결책 2: Grape API에 대한 설명\n\nGrape는 루비용 REST와 유사한 API 마이크로 프레임워크로, Rack에서 실행하거나 Rails와 같은 기존 웹 애플리케이션 프레임워크와 함께 사용할 수 있도록 설계되었습니다. Grape-swagger는 Grape API에 대한 자동 생성된 문서를 제공합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 단계 1: grape-swagger 설치하기\n\nGemfile에 grape-swagger를 추가하고 프로젝트에 추가하려면 번들 설치를 실행하세요:\n\n```js\ngem 'grape-swagger'\n```\n\n그리고 실행하세요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n번들 설치\n```\n\n## 단계 2: grape-swagger 구성\n\ngrape-swagger를 위한 초기 설정을 해보세요:\n\n```js\n# config/initializers/swagger.rb\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nif defined?(Grape)\n  GrapeSwaggerRails.options.url      = \"/api/swagger_doc\"\n  GrapeSwaggerRails.options.app_name = \"MyApp\"\n  GrapeSwaggerRails.options.app_url  = \"/\"\nend\n```\n\n## 단계 3: API 엔티티 및 문서 정의\n\ngrape-swagger가 문서화할 수 있도록 API 엔티티를 정의해야 합니다:\n\n```js\n# app/api/entities/my_entity.rb\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n모듈 API\n  모듈 엔티티\n    클래스 MyEntity < Grape::Entity\n      expose :id, documentation: { type: 'Integer', desc: '엔티티의 ID' }\n      # ... 추가 코드 ...\n    end\n  end\nend\n```\n\n## 단계 4: 스웨거 엔드포인트 추가\n\nAPI 베이스 클래스에서 스웨거 설명 라우트를 추가하여 스웨거 JSON을 제공할 수 있도록 합니다:\n\n```js\n# app/api/base.rb\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```ruby\nclass API::Base < Grape::API\n  add_swagger_documentation\nend\n```\n\n## 단계 5: Swagger 문서 보기\n\n이제 http://localhost:3000/swagger로 이동하여 Swagger UI에 액세스할 수 있습니다.\n\n# 해결 방법 3: RSpec 사용하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nrswag은 API 테스트에 기반하여 자동으로 Swagger 호환 API 문서를 생성하는 데 RSpec과 통합됩니다.\n\n## 단계 1: rswag-specs 설치\n\nGemfile에 rswag-specs를 추가하고 설치하세요:\n\n```js\ngem 'rswag-specs'\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그리고 다음을 실행해 주세요:\n\n```js\nbundle install\n```\n\n## 단계 2: 구성 및 파일 생성\n\nRSwag 생성기를 실행하여 API 사양을 위한 초기 구성 및 디렉터리를 생성하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nrails g rswag:install\n```\n\n## 단계 3: Swagger DSL을 사용하여 요청 스펙 작성하기\n\n스펙 파일을 생성하고 RSwag의 DSL을 사용하여 엔드포인트를 테스트하고 문서화하세요:\n\n```js\n# spec/integration/my_api_spec.rb\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```ruby\nrequire 'swagger_helper'\ndescribe 'My API' do\n  path '/my_api/endpoint' do\n    ...\n    get 'Retrieves something' do\n      produces 'application/json'\n      response '200', 'successful' do\n        schema type: :object,\n               properties: {\n                 id: { type: :integer }\n               },\n               required: ['id']\n        # Your test code goes here\n      end\n    end\n  end\nend\n```\n\n## 단계 4: RSwag UI로 API 문서에 액세스하기\n\nRSwag는 http://localhost:3000/api-docs에서 액세스할 수 있는 Swagger UI를 제공합니다. 이 UI는 직접 작성한 사양을 반영합니다.\n","ogImage":{"url":"/assets/img/2024-06-23-HowtoSetUpSwaggerUIforRailsProject2024Edition_0.png"},"coverImage":"/assets/img/2024-06-23-HowtoSetUpSwaggerUIforRailsProject2024Edition_0.png","tag":["Tech"],"readingTime":7}],"page":"14","totalPageCount":113,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true}