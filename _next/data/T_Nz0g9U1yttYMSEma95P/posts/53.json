{"pageProps":{"posts":[{"title":"모듈화된 단일 모놀리스의 보안을 OAuth2와 Spring Security로 확보하기","description":"","date":"2024-05-27 15:50","slug":"2024-05-27-SecuringModularMonolithwithOAuth2andSpringSecurity","content":"\n<img src=\"/assets/img/2024-05-27-SecuringModularMonolithwithOAuth2andSpringSecurity_0.png\" />\n\n제1부: Spring Boot 및 도메인 주도 설계를 사용하여 모듈식 단일체 응용 프로그램 구축\n\n제2부: Spring Modulith를 사용하여 모듈식 단일체 응용 프로그램 개선\n\n제3부: Hexagonal Architecture를 활용한 모듈식 단일체에서 도메인 중심 사고 채택\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n모듈화된 모노리틱 코드베이스에서는 각 기능이 다른 모듈과 순환 종속성이 없는 모듈에 구현되어야 합니다. 그러나 보안과 같은 교차 관심사가 적용되어야 할 때, 보안 관련 코드는 어디에 배치해야 할까요? 각 모듈에 있어야 할까요? 아니면 별도의 모듈이어야 할까요? 함께 알아보겠습니다.\n\n이전 블로그에서 우리는 도서관 애플리케이션을 개발했습니다. 이 애플리케이션에서 사용자는 책을 대출할 수 있습니다. 그러나 보안이 없으면 어플리케이션을 사용하는 대여자를 식별할 방법이 없고 다른 사람이 대출한 책을 대출하는지 확신할 수 없습니다. 올바른 동작을 보장하기 위해 인증 및 권한 부여 규칙을 추가하려고 합니다. 우리는 애플리케이션을 보호하기 위해 OAuth2 프로토콜을 사용할 것입니다.\n\n## OAuth2 / OIDC 프로토콜\n\n코드 구조와 모듈 조직에 대한 토론에 앞서, OAuth2에 대한 간단한 개요부터 살펴보겠습니다. 이미 알고 계시다면 이 섹션을 건너뛰어도 됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nOAuth2를 이해할 수 있는 많은 훌륭한 리소스들이 있기 때문에 여기에서는 세부적인 내용을 다루지 않겠습니다. 대신 OAuth2를 활용한 솔루션을 설계하는 방법에 대해 이야기하려고 합니다.\n\nOAuth2로 해야 할 세 가지 중요한 사항은 \"인가 서버(Authorization Server)\", \"리소스 서버(Resource Server)\", 그리고 \"클라이언트(Client)\"입니다. 클라이언트는 일반적으로 웹 애플리케이션의 UI로 사용되지만 Terraform 제공자나 자동화를 위한 CI/CD 파이프라인, 그리고 테스트를 위한 Postman이나 Insomnia일 수도 있습니다. 리소스 서버는 리소스를 제공하는 백엔드 API를 나타냅니다. 우리의 경우에는 이를 \"도서관 어플리케이션\"으로 정의할 수 있습니다. 중요한 점은 리소스 서버가 사용자의 인증 및 관리 책임이 없다는 것입니다. 이 역할을 하는 것은 인가 서버입니다.\n\nOAuth2 솔루션을 구축할 때 가장 중요한 구성 요소는 인가 서버입니다. 사용자 관리 및 사용자 자격 증명을 보관하는 역할을 합니다. 인가 서버를 선택하는 것은 중요한 결정입니다. SaaS를 구축 중이라면 Auth0나 Okta와 같은 SaaS 솔루션을 선택할 수 있습니다. 자체 호스팅(또는 온프레미스)해야 하는 경우 Keycloak을 선택할 수 있습니다. 또는 Spring Authorization Server를 사용하여 직접 구축할 수도 있지만, 거의 항상 좋은 아이디어는 아닙니다. 우리의 구현에는 Keycloak을 선택할 것입니다.\n\nUI가 없는 경우, 이 흐름을 사용하여 API를 테스트할 수 있습니다: 클라이언트(Postman이나 Insomnia)는 사용자를 인증하고 액세스 토큰을 획득하기 위해 인가 서버(Keycloak)를 호출합니다. 이 액세스 토큰을 사용하면 클라이언트가 리소스 서버(도서관 어플리케이션)의 데이터에 액세스할 수 있습니다. 이는 Authorization Code Flow로도 알려져 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 스프링 시큐리티를 사용한 OAuth2\n\n이제 우리 애플리케이션이 OAuth2 플로우에서 리소스 서버로 작동한다는 것을 이해했으니, pom.xml에 관련 의존성을 포함해야 합니다.\n\n```js\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-security</artifactId>\n</dependency>\n\n<dependency>\n  <groupId>org.springframework.security</groupId>\n  <artifactId>spring-security-oauth2-resource-server</artifactId>\n</dependency>\n\n<!-- JWT를 다루기 위한 의존성 -->\n<dependency>\n  <groupId>org.springframework.security</groupId>\n  <artifactId>spring-security-oauth2-jose</artifactId>\n</dependency>\n```\n\n그 다음으로, OAuth2 리소스 서버를 활성화 하기 위해 스프링 시큐리티를 구성합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n@Configuration\n@EnableMethodSecurity\npublic class LibraryWebSecurityConfiguration {\n\n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity security) throws Exception {\n\n        return security\n                .authorizeHttpRequests(http -> http\n                        .requestMatchers(\"/swagger-ui/**\", \"/v3/api-docs/**\").permitAll()\n                        .anyRequest().authenticated())\n                .oauth2ResourceServer(oauth2 ->\n                        oauth2.jwt(jwtConfigurer ->\n                                jwtConfigurer.jwtAuthenticationConverter(new KeycloakJwtAuthenticationConverter())\n                        )\n                ).build();\n    }\n}\n```\n\n`oauth2.jwt()` 함수는 액세스 토큰에 대한 Json Web Tokens (JWT) 사용을 나타냅니다. 이를 통해 사용자의 역할을 액세스 토큰에서 Spring Security의 내부 Granted Authorities로 추출하는 사용자 정의 컨버터를 사용합니다.\n\n또한 우리는 리소스 서버가 JWT 토큰을 특정 인가 서버로 유효성 검사하도록 설정해야 합니다. 이는 application.yaml 파일에서 구성할 수 있습니다.\n\n```yaml\nspring:\n  security:\n    oauth2:\n      resourceserver:\n        jwt:\n          issuer-uri: http://localhost:8083/realms/library\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 보안을 위한 새로운 모듈\n\n<img src=\"/assets/img/2024-05-27-SecuringModularMonolithwithOAuth2andSpringSecurity_1.png\" />\n\n보안과 관련된 클래스를 관리하기 위해 User Account라는 새 모듈을 소개하려고 합니다. 이 모듈에는 UserAccount라는 인증된 사용자를 나타내는 도메인 모델이 포함될 것입니다. 다른 모듈들은 UserAccount를 참조하여 자신만의 내부 표현에 매핑할 수 있습니다. Borrow 모듈에는 Patron이, Catalog 모듈에는 Staff가 될 것입니다.\n\n```js\n.\n└── example/\n    ├── borrow\n    ├── catalog\n    ├── useraccount/\n    │   ├── web/\n    │   │   ├── Authenticated.java\n    │   │   └── AuthenticatedUserArgumentResolver.java\n    │   ├── KeycloakJwtAuthenticationConverter.java\n    │   └── UserAccount.java\n    └── LibraryWebSecurityConfiguration.java\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n대출 및 카탈로그 모듈은 현재 인증된 사용자의 세부 정보를 가져와 관련 도메인 모델과 매핑하는 데 사용자 계정 모듈을 사용합니다. 새로운 기능을 위한 미래 모듈도 해당 모듈을 사용할 가능성이 높습니다. 이는 사용자 계정 모듈을 공유 모듈로 만들어줍니다. Spring Modulith는 모듈을 공유로 지정할 수 있는 방법을 제공합니다.\n\nMarkdown 형식의 테이블로 변환하면 다음과 같습니다.\n\n| 모듈     | 설명                                                                     |\n| -------- | ------------------------------------------------------------------------ |\n| 대출     | 사용자 계정 모듈을 사용하여 현재 승인된 사용자의 세부 정보를 가져옵니다. |\n| 카탈로그 | 사용자 계정 모듈을 사용하여 현재 승인된 사용자의 세부 정보를 가져옵니다. |\n\n@SpringBoot 애플리케이션 클래스에 @Modulithic 어노테이션을 설정하고 공유 모듈을 정의할 수 있습니다. 이렇게 하면 Spring Modulith가 항상 사용자 계정 모듈을 부트스트랩하도록 할 수 있습니다.\n\n## 모듈에서 인증된 사용자 식별하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n인증된 사용자는 UserAccount 레코드로 모델링됩니다. 사용자 세부 정보를 영속화할 필요가 없기 때문에 이를 집계로 정의하지 않습니다. 사용자, 역할 및 자격 증명의 참 소스는 Keycloak입니다.\n\n```js\n/**\n * 사용자 계정을 나타내는 모델입니다.\n * 아직 필요가 없기 때문에 집계로 이동되지 않았습니다.\n */\npublic record UserAccount(String firstName,\n                          String lastName,\n                          String email,\n                          List<String> roles) {}\n```\n\n대출 모듈에서 홀드를 배치할 때, 인증된 사용자를 알아야 하며, 컨트롤러의 Patron 모델과 매핑해야 합니다. 이 작업은 사용자 정의 어노테이션 @Authenticated로 수행됩니다. 사용자 지정 HandlerMethodArgumentResolver를 사용하여 컨트롤러 메서드에 자동으로 UserAccount를 주입할 수 있습니다.\n\n```js\n@PostMapping(\"/borrow/holds\")\nResponseEntity<HoldDto> holdBook(@RequestBody HoldRequest request, @Authenticated UserAccount userAccount) {\n    var command = new Hold.PlaceHold(new Book.Barcode(request.barcode()), LocalDate.now(), new PatronId(userAccount.email()));\n    var holdDto = circulationDesk.placeHold(command);\n    return ResponseEntity.ok(holdDto);\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n사용자 계정은 새로운 PatronId(userAccount.email())와 매핑되어 있습니다. CirculationDesk 서비스는 인증 방식에 대한 지식 없이 특정 Patron만을 다룹니다.\n\n## 권한 부여 대 비즈니스 규칙\n\n새로운 두 가지 비즈니스 요구 사항이 있습니다:\n\n- 도서관 직원만이 카달로그에 새 책을 추가할 수 있습니다.\n- 다른 회원이 대출한 책을 대출할 수 없습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 요구 사항을 도메인 모델에 매핑해 봅시다. 현재 Library Staff 구성원에 대한 모델이 없습니다. 이를 ROLE_STAFF 역할을 갖는 인증된 사용자로 정의할 수 있습니다. 두 번째 요구 사항은 이미 있는 도메인 모델인 Patron으로 모델에 변경이 필요하지 않습니다.\n\n첫 번째 요구 사항은 RBAC(Role-Based Access Control)의 간단한 경우입니다. Spring Security의 Method Security @PreAuthorize 주석을 사용하여 구현할 수 있습니다.\n\n```java\n@PreAuthorize(\"hasRole('STAFF')\")\n@PostMapping(\"/catalog/books\")\nResponseEntity<BookDto> addBookToInventory(@RequestBody AddBookRequest request) {\n    var bookDto = books.addToCatalog(request.title(), new Barcode(request.catalogNumber()), request.isbn(), request.author());\n    return ResponseEntity.ok(bookDto);\n}\n```\n\n사용자의 역할은 JWT 토큰에서 식별됩니다. 역할이 어느 클레임에서 사용 가능할지는 인가 서버가 결정합니다. 저희의 경우 Keycloak에서는 realm*access.roles[] 클레임에서 역할을 사용할 수 있습니다. Spring Security가 역할로 인식하려면 역할에는 기본적으로 ROLE* 접두사가 있어야 하지만, GrantedAuthorityDefaults를 사용하여 변경할 수도 있습니다. 토큰 처리 중에 각 역할을 GrantedAuthority로 변환합니다. Authorization 결정을 내릴 때 AccessDecisionManager에 의해 이러한 권한이 읽힙니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n두 번째 요구 사항이 더 흥미롭습니다. 권한 규칙인지 비즈니스 규칙인지 어떻게 판단해야 할까요? 리소스에 대한 액세스를 설명하고 있기 때문에 권한 규칙으로 보이지만, 반대로 도메인의 기능을 설명하고 있기 때문에 비즈니스 규칙으로도 볼 수 있습니다. 그렇다면 이를 어떻게 구현해야 할까요?\n\n권한 규칙으로써 요구 사항을 구현할 수 없는 이유는 해당 도메인 모델의 속성을 확인해야하기 때문입니다. 이 경우, Hold 객체가 올바른 Patron에 의해 보유되어 있는지 확인해야 합니다. 따라서 RBAC(Role-Based Access Control) 대신 ABAC(Attributed-Based Access Control)이 필요합니다. Spring Security에는 ABAC을 내장 지원하지 않으므로 직접 구현해야 합니다.\n\n반면, 이 요구 사항을 도메인의 비즈니스 제약 조건으로 처리한다면 도메인 모델이나 서비스에서 확인할 수 있습니다. ABAC보다 간단한 해결책을 택하는 경우, 비즈니스 규칙 확인을 선택하겠습니다.\n\n```js\npublic CheckoutDto checkout(Hold.Checkout command) {\n\n    var hold = holds.findById(command.holdId())\n            .orElseThrow(() -> new IllegalArgumentException(\"Hold not found!\"));\n\n    if (!hold.isHeldBy(command.patronId())) {\n        throw new IllegalArgumentException(\"Hold belongs to a different patron\");\n    }\n\n    return CheckoutDto.from(\n            hold.checkout(command)\n                    .then(holds.save)\n                    .then(eventPublisher.bookCheckedOut)\n    );\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n인증 규칙이 복잡해지면 비즈니스 규칙과 중첩될 수 있습니다. 일반적으로 인가 규칙은 \"누가 무엇에 액세스할 수 있는지\"에 관심이 있으며, 비즈니스 규칙은 \"시스템 및 도메인의 동작\"에 관심이 있습니다. 인가 주변에 복잡한 규칙이 많다면, 모든 정책을 한 곳에 모아 쉽게 관리할 수 있는 ABAC 솔루션을 구축하는 것이 좋은 아이디어일 수 있습니다.\n\n## 인증 플로우 트리거\n\nUI가 없으므로 Insomnia(REST 클라이언트)를 사용하여 라이브러리 애플리케이션 및 OAuth2로의 인증을 테스트할 것입니다. 그러나 먼저 애플리케이션을 시작해야 합니다. 이 작업은 docker compose를 사용하여 쉽게 할 수 있습니다.\n\n애플리케이션의 최신 코드는 여기에서 확인할 수 있습니다: https://github.com/xsreality/spring-modulith-with-ddd/tree/part-4-authentication. 로컬에서 코드를 확인하고 mvn spring-boot:build-image를 실행하여 애플리케이션의 로컬 도커 이미지를 빌드해보세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n도커 컴포즈를 실행하여 Keycloak과 애플리케이션을 시작하세요. 이 Keycloak은 realm이라는 이름의 렘을 미리 구성했으며 ROLE_STAFF 역할 및 두 사용자인 john.wick@continental.com 및 winston@continental.com을 정의했습니다. Winston은 도서관 직원입니다. 두 계정의 암호는 \"password\"입니다.\n\n우리의 realm 라이브러리에 대한 인가 서버 메타데이터는 http://localhost:8083/realms/library/.well-known/openid-configuration에서 확인할 수 있습니다. authorization_endpoint 및 token_endpoint와 같은 두 엔드포인트가 필요한 Authorization Code 플로우가 있습니다.\n\n![이미지](/assets/img/2024-05-27-SecuringModularMonolithwithOAuth2andSpringSecurity_2.png)\n\n다음으로 Insomnia를 설정하여 OAuth2 플로우를 트리거합니다. 아래 스크린샷에 따라 설정을 선택하고 토큰을 가져옵니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-05-27-SecuringModularMonolithwithOAuth2andSpringSecurity_3.png\" />\n\n인증 코드 플로우로 인해 Insomnia가 Keycloak의 로그인 페이지로 리디렉트됩니다. 자격 증명을 입력하고 코드를 엑세스 토큰으로 교환하려면 로그인하세요. 이 토큰은 그런 다음 자원 서버를 Bearer 토큰으로 호출하는 데 사용됩니다. Spring Security는 토큰을 디코딩하고 Keycloak에서 서명을 유효성 검사하고 iss 클레임을 유효성 검사하며 역할을 권한으로 매핑하는 데 신경 씁니다.\n\n## OAuth2의 통합 테스트\n\nSpring Security OAuth2 플로우를 JWT로 통합 테스트하는 아이디어는 전체 OAuth 플로우를 건너뛰고(결국 복잡하기 때문에 서명을 유효성 검사하는 것이 테스트의 중점이 아님) 대신 목킷 JWT를 사용하여 인증 후의 비즈니스 로직을 테스트하는 것입니다. 권한 관점에서는 유효한 인증된 사용자가 나타나므로 권한 규칙을 테스트하기가 쉽습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n첫 번째 요구 사항을 테스트해 보겠습니다. 카탈로그에 책을 추가하는 테스트를 하려면 역할 ROLE_STAFF가 포함된 JWT 토큰이 필요합니다.\n\n먼저 mockMvc 객체를 Spring Security를 사용하도록 구성해야 합니다.\n\n```js\n@BeforeEach\nvoid setUp() {\n    this.mockMvc = MockMvcBuilders.webAppContextSetup(context)\n            .apply(springSecurity())\n            .build();\n}\n```\n\n역할 ROLE_STAFF를 가진 인증된 사용자를 시뮬레이션하기 위해 권한을 포함한 가짜 JWT 토큰을 생성합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n@Test\nvoid addBookToCatalogSucceedsWithStaff() throws Exception {\nmockMvc.perform(post(\"/catalog/books\")\n.with(jwt().authorities(new SimpleGrantedAuthority(\"ROLE_STAFF\")))\n.contentType(MediaType.APPLICATION_JSON)\n.content(\"\"\"\n{\n\"title\": \"Sapiens\",\n\"catalogNumber\": \"12345\",\n\"isbn\": \"9780062316097\",\n\"author\": \"Yuval Noah Harari\"\n}\n\"\"\"))\n.andExpect(status().isOk())\n.andExpect(jsonPath(\"$.id\").exists())\n            .andExpect(jsonPath(\"$.catalogNumber.barcode\", equalTo(\"12345\")))\n.andExpect(jsonPath(\"$.isbn\", equalTo(\"9780062316097\"))\n            .andExpect(jsonPath(\"$.author.name\", equalTo(\"Yuval Noah Harari\"));\n\n만약 역할이 없는 경우 403 Access Denied 응답이 반환되며, 헤더에는 WWW-Authenticate:\"Bearer error=\"insufficient_scope\", error_description=\"The request requires higher privileges than provided by the access token.\", error_uri=\"https://tools.ietf.org/html/rfc6750#section-3.1\"\"가 포함됩니다.\n\n두 번째 요구 사항에서는 대출 모듈은 인증된 사용자의 이메일 주소에서 Patron을 식별합니다. 따라서 가짜 JWT 토큰에는 이메일 클레임이 필요합니다. 이 작업은 쉽게 할 수 있습니다.\n\n@Test\nvoid checkoutBookRestCall() throws Exception {\nmockMvc.perform(post(\"/borrow/holds/018dc74a-4830-75cf-a194-5e9815727b02/checkout\")\n.with(jwt().jwt(jwt -> jwt.claim(\"email\", \"john.wick@continental.com\"))))\n.andExpect(jsonPath(\"$.holdId\", equalTo(\"018dc74a-4830-75cf-a194-5e9815727b02\"))\n            .andExpect(jsonPath(\"$.patronId\", equalTo(\"john.wick@continental.com\"))\n.andExpect(jsonPath(\"$.dateOfCheckout\").exists());\n}\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 발급자 URI 대 JWK Set URI\n\nOAuth2 사양의 주요 요구 사항 중 하나는 권한 부여 서버의 발급자 URI(Authorization Server Metadata 응답의 발급자)와 토큰의 발급자 클레임(iss 클레임)이 일치해야 한다는 것입니다. application.yaml에 발급자 URI가 구성되어 있는 경우, Spring Security가 Authorization Server Metadata를 호출하고 JWK Set URI를 포함한 여러 URL을 찾습니다. 이 URI는 토큰의 서명을 확인하기 위한 공개 서명 키를 반환합니다.\n\n이 흐름의 문제는 리소스 서버가 외부 사용자용 URL에서 권한 부여 서버에 연락해야 한다는 것입니다. 이러한 서버가 API 게이트웨이 또는 역방향 프록시 뒤에 있으면 요청이 게이트웨이에 전송되고 다시 돌아와야 하므로 비효율적입니다.\n\n이 문제를 해결하는 한 가지 방법은 application.yaml 대신 JWK Set URI를 직접 구성하는 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```yaml\nspring:\n  security:\n    oauth2:\n      resourceserver:\n        jwt:\n          jwk-set-uri: http://keycloak:8080/realms/library/protocol/openid-connect/certs\n```\n\n이 설정은 Spring Security가 인증 서버 메타데이터를 호출하는 것을 건너뛰고 토큰의 서명을 확인하기 위해 JWK Set URI를 직접 호출하도록 만듭니다. API 게이트웨이 뒤에서 JWK Set URI는 통신용으로만 사용되기 때문에 내부 URL일 수 있습니다.\n\n## 결론\n\nSpring Security에 대해 더 말할 수 있는 부분이 많이 있습니다. 그러나 이 블로그에서는 Spring Security 관련 코드가 모듈식 모놀리스 코드베이스에 어떻게 들어 맞는지 살펴보았습니다. 또한 Spring Security를 사용하여 OAuth2 플로우를 구현하고 설정을 통합 테스트했습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만약 코드를 확인하고 실행해보고 싶다면 아래를 확인해보세요.\n","ogImage":{"url":"/assets/img/2024-05-27-SecuringModularMonolithwithOAuth2andSpringSecurity_0.png"},"coverImage":"/assets/img/2024-05-27-SecuringModularMonolithwithOAuth2andSpringSecurity_0.png","tag":["Tech"],"readingTime":18},{"title":"자바에서의 가비지 컬렉션","description":"","date":"2024-05-27 15:48","slug":"2024-05-27-GarbageCollectionInJava","content":"\n## 자바에서 쓰레기 수거가 이뤄지는 방식에 대한 기본적인 설명\n\n![이미지](/assets/img/2024-05-27-GarbageCollectionInJava_0.png)\n\n# 가비지 컬렉션이란?\n\n변수를 선언하는 것은 프로그래머로서 생활의 일부입니다. 변수를 사용하는 것은 코드의 재사용성을 향상시키는 것뿐만 아니라 코드의 가독성을 크게 향상시키고, 이는 결국 코드의 유지보수성을 높이는 데 큰 도움이 됩니다. 또한 선언된 변수가 일정 공간을 차지하고 특정 범위와 연결되어 있다는 것은 비밀이 아닙니다. 최적화된 메모리 관리를 위해 JVM이 이러한 객체들이 더 이상 필요하지 않을 때 제거하거나 파괴하는 것이 합리적입니다. 이렇게 \"원치 않는\" 변수들을 제거하는 프로세스를 가비지 컬렉션이라고 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 자바에서의 가비지 컬렉션\n\nC, C++와 같은 언어에서는 가비지 컬렉션을 애플리케이션 개발자의 책임으로 간주됩니다. 이러한 언어에서는 쓰레기를 수동으로 처리하는 명시적 도구가 있습니다. 반면에 Java에서는 JVM이 가비지 컬렉션을 자동으로 처리합니다. JVM은 힙 메모리에서 언제 어디서 GC를 트리거할지 결정하는 일련의 프로세스를 거칩니다. 자바 개발자로서, 가비지 컬렉션의 기본 원리와 힙 메모리의 섹션을 이해하는 것이 매우 중요합니다. 이는 우리가 메모리를 효율적으로 사용하는 자바 애플리케이션을 개발하는 데 큰 도움이 될 것입니다.\n\n## 가비지 컬렉션에 포함된 단계\n\n자바 가비지 컬렉션은 일반적으로 2단계로 수행됩니다. 마크 단계와 스윕 단계입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n마크 단계: 마크 단계에서는 객체를 참조될 수 있는지 여부에 따라 두 가지 방식으로 분류합니다. 참조된 객체는 여전히 사용 중이며 범위에서 벗어나지 않은 객체입니다. 참조되지 않은 객체는 응용 프로그램에서 더 이상 필요하지 않은 객체입니다. 참조되지 않는 객체는 가비지 수집을 위해 \"표시\"됩니다.\n\n스윕 단계: 스윕 단계에서는 \"표시\"된 객체가 삭제되거나 지워집니다. 게다가 때로는 힙(heap)에서 메모리 압축(Mark-compact 알고리즘)이라고 하는 작업도 초기화됩니다. 이 과정을 통해 남아 있는 객체가 연속된 메모리에 남아 있도록 메모리가 다시 할당됩니다. 이 과정을 통해 JVM이 새로 생성된 객체에 순차적으로 메모리를 할당할 수 있습니다. 메모리 압축 프로세스의 세부 내용은 이 글의 범위를 벗어나므로 생략하겠습니다.\n\n효율적인 가비지 수집을 유지하기 위해 JVM이 따르는 일부 가비지 수집 전략이 있습니다. 가장 흔한 전략은 세대별 가비지 수집 전략입니다.\n\n## 세대별 가비지 수집 전략\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여기서는 일반적으로 사용되는 가장 흔한 가비지 컬렉션 형태인 세대별 가비지 컬렉션 전략을 탐구해 볼 거에요. 세대별 가비지 컬렉션은 주로 2가지 주된 이유로 선호됩니다.\n\n- 메모리에 할당된 객체가 더 많아질수록 표시, 정리, 그리고 압축 과정이 굉장히 비효율적해집니다. 이는 표시, 정리, 그리고 압축하는 데 소요되는 시간을 증가시키고 극도로 큰 GC 시간을 야기할 수 있습니다.\n- 분석 결과 자바 애플리케이션의 대부분 객체가 수명이 짧다는 것을 입증하였습니다.\n\n위에서 언급된 이유들 때문에, GC 프로세스를 더 효율적으로 만들기 위해 자바의 힙 메모리는 세그먼트 또는 세대로 분할됩니다.\n\n![가비지컬렉션](/assets/img/2024-05-27-GarbageCollectionInJava_1.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n젊은 세대:\n\n젊은 세대는 세 지역으로 나뉩니다. 에덴 공간, 생존자 공간 제로(S0) 및 생존자 공간 원(S1). 우리는 응용 프로그램 부팅 시 가비지 컬렉션 프로세스를 논의해 보겠습니다.\n\n처음에는 생성된 모든 객체가 에덴 공간에 채워집니다. 생존자 공간(S0 및 S1)은 모두 비어 있을 것입니다. 에덴 공간이 가득 차면 소규모 가비지 컬렉션 주기가 트리거됩니다. 에덴 공간의 모든 참조되지 않은 객체가 삭제되고 모든 참조된 객체가 S0로 이동됩니다. 이것이 gc(0)입니다. 이어지는 가비지 컬렉션 주기에서 에덴 공간 및 S0 공간의 모든 참조된 객체가 S1로 이동됩니다. 이후 모든 참조되지 않은 객체가 삭제됩니다. gc(1) 이후의 객체 할당은 다음과 같이 보일 것입니다.\n\n![image](/assets/img/2024-05-27-GarbageCollectionInJava_2.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위 이미지에서 볼 수 있듯이 모든 GC 주기마다 객체의 나이가 1씩 증가합니다. 나이가 특정 임계값에 도달하면 객체들은 힙 메모리의 다음 섹션으로 이동됩니다. 또한 모든 마이너 GC는 Stop the world 이벤트입니다. 이는 응용 프로그램 스레드가 GC가 완료될 때까지 중지된다는 것을 의미합니다. 일반적으로 마이너 GC는 메이저 GC와 비교했을 때 소요 시간이 더 적습니다.\n\n늙은 세대\n\n결국 객체의 연령이 특정 임계값에 도달하면 젊은 세대에서늙은 세대로 이동됩니다. 언젠가는 오래된 세대도 채워집니다. 오래된 세대가 가득 차고 정리되어야 할 때 메이저 GC가 트리거됩니다.\n\n메이저 GC와 마이너 GC의 차이점\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nMinor GC와 Major GC의 주요 차이 중 하나는 Minor GC와 Major GC가 완료되는 데 걸리는 시간입니다. Major GC는 Minor GC와 마찬가지로 멈춤 현상(stop the world) 이벤트이지만 Major GC를 완료하는 데 걸리는 시간은 모든 활성 객체를 포함하기 때문에 Minor GC보다 훨씬 많이 소요됩니다. Major GC를 완료하는 데 필요한 시간은 주요 GC 공간이 증가할수록 선형적으로 증가하며 공간이 많을수록 메모리 압축에 더 많은 시간이 소요됩니다. 이는 응답 시간을 우선시하는 응용 프로그램에서 주요 GC의 빈도를 낮게 유지해야 한다는 것을 의미합니다. 또한 주요 GC의 멈춤 현상 이벤트의 길이는 사용 중인 GC 유형에 따라 달라집니다.\n\n**Full GC**\n\n자바 가비지 컬렉션에서 Full GC란 young generation과 old generation GC가 모두 트리거되는 경우입니다. full garbage collection은 Minor GC나 Major GC보다 훨씬 더 많은 시간이 소요됩니다. Full GC가 발생하는 이유는 여러 가지가 있을 수 있습니다. 그 중 몇 가지 이유는 다음과 같습니다:\n\n- Heap 공간이 가득 차는 경우: 모든 Java 힙 메모리가 고갈되기 전에 Full GC가 발생할 수 있습니다. 이는 일련의 영역을 연속으로 찾아야 하는 필요로 인해 발생할 수 있습니다.\n- 영역 크기 변경: 메모리 수요에 따라 영역 크기(영구 또는 올드)가 변경되면 일반적으로 Full GC에 의해 영역 변경 크기가 시작됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## Metaspace\n\n힙 메모리의 일부였고 전체 가비지 수집에 포함되었던 추가 메모리 세그먼트가 있습니다. 이 메모리 세그먼트를 영구 세대(Permanent generation)라고 했습니다. Java 8에서 영구 세대는 Metaspace로 변경되었으며 힙 메모리에서 분리되었습니다. Metaspace의 주요 이유는 클래스 메타데이터를 저장하는 것입니다. 클래스가 더 많은 공간을로드하고 메타데이터를 저장해야 할 경우 Metaspace는 자동으로 증가하는 기능을 갖추고 있습니다.\n\nJava 가비지 컬렉션을 이해하는 것은 자바 애플리케이션을 보다 효율적으로 만들기 위해 매우 중요하며 시스템에서 잠재적인 메모리 누수를 해결하고 문제 해결하는 데 도움이 됩니다.\n","ogImage":{"url":"/assets/img/2024-05-27-GarbageCollectionInJava_0.png"},"coverImage":"/assets/img/2024-05-27-GarbageCollectionInJava_0.png","tag":["Tech"],"readingTime":6},{"title":"WhatsApp의 감시 소프트웨어 거물에 대한 승리 페가수스의 격퇴","description":"","date":"2024-05-23 18:55","slug":"2024-05-23-WhatsAppsVictoryOverSpywareTitantheTakedownofPegasus","content":"\nWhatsApp은 Meta가 소유한 메신저 앱으로, 매우 강력한 감청 소프트웨어를 만드는 이스라엘 회사인 NSO 그룹에 대한 주요 법적 싸움에서 승리했습니다. 미국 판사는 NSO 그룹에게 Pegasus, 그들의 가장 유명한 감청 소프트웨어뿐만 아니라 다른 감시 도구들의 코드를 WhatsApp에 전달하도록 명령했습니다. WhatsApp은 2019년 NSO의 감청 소프트웨어가 사용되어 1,400명의 사용자를 감시했다는 사실을 발견한 이후 제기한 소송의 일환입니다.\n\nPegasus는 모든 전화로 침투하고 소유자의 동의 없이 통화, 이메일, 사진, 위치 및 개인 메시지에 접근할 수 있는 도구입니다. NSO 그룹은 이 소프트웨어를 주로 정부에 판매하고 있으며, 이는 여러 국가에서 활동가, 기자 및 기타 사람들을 대상으로 사용되었습니다. NSO는 제품이 범죄를 bek이하고 국가 안보를 보호하는 데 사용된다고 주장했지만, 그 사용은 심각한 개인정보와 인권 우려를 불러일으켰습니다.\n\n판사의 결정은 NSO 그룹이 WhatsApp과 감청 소프트웨어가 어떻게 작동하는지에 대한 세부 정보를 공유해야 하지만 고객을 공개하거나 서버에 대한 구체적인 정보를 공개할 필요는 없다는 것을 의미합니다. 이 판결은 WhatsApp이 불법 감시로부터 사용자들을 보호하는 데 큰 도약이 될 것으로 보입니다. 이스라엘 정부에 의해 엄격히 규제되고, 바이든 행정부에 의해 미국 국가안보에 위협으로 지목된 NSO 그룹은 이 법정 결정에 대해 의견을 제시하지 않았습니다. 이 사안은 아직 진행 중입니다.\n\n![WhatsApp의 스파이웨어 거인 NSO 그룹 격파 - 2024년 5월 23일](/assets/img/2024-05-23-WhatsAppsVictoryOverSpywareTitantheTakedownofPegasus_0.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 배경 및 관련 당사자\n\n이 분쟁은 WhatsApp Inc.와 Facebook Inc. (원고)가 NSO Group Technologies Limited (피고)에 대한 소송으로, 불법 접근 및 스파이웨어 유포에 관한 주장에 초점을 맞추고 있습니다. Facebook 소유의 메시징 서비스 인 WhatsApp은 이스라엘 기술 기업인 NSO Group이 특정 WhatsApp 사용자를 감시하기 위해 악성 소프트웨어를 유포하는 것을 비난합니다.\n\n본 사건은 디지털 개인 정보 보호, 사이버 보안 및 권한 없이 개인에 대해 사용되는 정부 감시 기술의 함의에 대한 매우 중요한 우려 사안을 제기합니다. 이는 전세계적인 디지털 통신에서 이러한 기술의 사용을 어떻게 대처하고 잠재적으로 규제해야 하는 법적 구조에 대한 중요한 선례를 제공합니다.\n\n# 법적 주장 및 주장들\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nWhatsApp과 Facebook이 NSO 그룹에게 WhatsApp 플랫폼을 불법적으로 사용하여 스파이웨어를 배포했다는 주장을 중심으로 한 법적 주장 및 항의가 돌아가고 있습니다. 이 주장들은 다음과 같습니다:\n\n- Computer Fraud and Abuse Act (CFAA)의 위반. 연방 법률인 이 법은 컴퓨터 및 네트워크에 대한 무단 접근을 금지하며, NSO 그룹이 허가 없이 WhatsApp 서버에 접근하여 스파이웨어를 주입했다는 것을 시사합니다.\n- 캘리포니아의 Comprehensive Computer Access and Fraud Act. CFAA와 유사하지만 주의 수준에서, 이 법은 캘리포니아 내에서의 무단 컴퓨터 접근 및 데이터 도용을 대상으로 하며, WhatsApp은 NSO 그룹의 행동이 무단 접근 및 사용에 속한다고 주장합니다.\n- 계약 위반. WhatsApp은 NSO Group가 WhatsApp의 이용 약관을 위반했다고 주장하며, 해당 약관은 플랫폼의 오용을 엄격히 금지하고 악성 소프트웨어 사용을 포함합니다.\n- Chattels 침입. 이 공통 법적 책임은 타인의 개인 재산 소유를 방해하는 것을 포함합니다. WhatsApp은 NSO의 스파이웨어가 개인 정보를 침해하는 뿐만 아니라 자체 소프트웨어 및 사용자 장치에 영향을 미쳐 chattels 침입에 해당한다고 주장합니다.\n\n<img src=\"/assets/img/2024-05-23-WhatsAppsVictoryOverSpywareTitantheTakedownofPegasus_1.png\" />\n\n# Richmark 요인 분석\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n리치마크 팩터(Richmark Corp. v. Timber Falling Consultants (1991))에 대한 분석은 법원 판결에서 특히 외국 법률이나 당사자가 관련된 경우에 어떤 발견 요청이 강제적으로 이루어져야 하는지를 평가하는 방법론적 접근을 포함합니다. 다음은 이 접근 방식에 대한 요약입니다:\n\n- 정보의 중요성. 법원은 우선 요청된 문서 또는 정보가 조사 또는 소송에 얼마나 중요한지를 고려합니다. 이는 요청된 정보가 사건 결과를 결정하는 데 중요하거나 관련 문제를 이해하는 데 중요할 수 있는지를 평가하는 것을 의미합니다.\n- 요청의 구체성. 법원은 발견 요청이 얼마나 상세하고 명확한지를 살펴봅니다. 요청은 너무 포괄적이거나 모호해서는 안 되며, 필요한 정보를 명확히 지정하여 발견 과정이 효율적이고 사건과 관련이 있는지를 보장해야 합니다.\n- 정보의 출처. 법원은 요청된 정보나 문서가 미국에서 발생했는지를 고려합니다. 이 요소는 국제 분쟁 또는 외국 법이 발견 과정에 영향을 미칠 때 특히 관련이 있습니다.\n- 대안의 가용성. 필요한 정보를 얻는 다른 방법이 덜 부담스럽거나 논란적일 수 있는지 여부를 고려합니다. 다른 소스에서 정보를 찾거나 침입적이지 않은 방법을 통해 정보를 얻는 것을 의미할 수 있습니다.\n- 준수 또는 부적응의 영향. 법원은 발견 요청에 대해 준수하거나 그렇지 않을 때의 결과를 평가합니다. 이는 부적응이 미국의 중요한 이익을 약화시킬 수 있는지 또는 준수가 어떻게 해당 정보가 위치한 주의 이익에 영향을 미칠 수 있는지를 고려하는 것을 포함합니다.\n\n이러한 요인들을 해당 사례에 적용할 때, 법원은 정보 공개의 필요성과 국제 법적 규범을 존중하면서 관련 당사자에게 주는 부담을 균형있게 고려합니다. 특히, 소송에 대한 요청의 중요성과 요청의 구체성에 중점을 둡니다.\n\n![WhatsApp의 스파이어 타이탄 격파로 승리: 페가수스의 철퇴](/assets/img/2024-05-23-WhatsAppsVictoryOverSpywareTitantheTakedownofPegasus_2.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 발견 준수 및 국제적 고려사항\n\n법원 판결의 발견 준수 및 국제적 고려사항 부분은 국제적인 법과 다양한 국가의 당사자들이 관련된 경우 발견 요청을 시행하는 도중의 어려움과 법률적 미묘함을 중심으로 하고 있습니다:\n\n- 법원은 미국 및 이스라엘 법에 따라 발견 요청을 준수해야 하는 피고들의 의무를 검토했습니다. 다양한 제약 조건에도 불구하고, 법원은 모든 발견에 대한 완전한 면제를 부여하지 않기로 결정했으나 특정 기준에 따라 일부 면제를 허용했으며, 외국 법에 대한 검토를 고려한 조합 기준을 강조했습니다.\n- 외국 법이 발견 명령의 불이행을 변명할 수 있는 범위를 결정할 때, 법원은 Richmark 판결의 두 가지 주요 요소에 초점을 맞췄습니다 (이전 섹션에서 다룬 내용): 소송에 대해 요구된 문서나 정보의 중요성과 발견 요청의 명확성입니다. 법원은 필요한 정보 및 구체적으로 명시된 정보만이 발견 대상이 되도록 하여, 피고들에 대한 부담을 줄이면서도 원고들이 중요한 증거에 접근할 수 있도록 하려고 했습니다.\n- 법원은 발견 범위에 대해 몇 가지 핵심적인 결정을 내렸습니다: (i) 스파이웨어 제작: 피고들에게 주장된 스파이웨어의 버전 및 기능을 제작하도록 요구했습니다. WhatsApp 서버를 대상으로 하는 또는 WhatsApp을 이용하는 관련 스파이웨어가 모두 포함되어야 한다는 내용을 명시했습니다; (ii) 클라이언트 신원: 법원은 피고들의 제3자 클라이언트 (즉, 스파이웨어를 사용한 사람들)의 신원을 공개할 필요가 없다고 결정했습니다. 이유는 이러한 제3자가 취한 행동을 이해하기 위해서는 그들의 구체적인 신분을 알 필요가 없다고 판단했기 때문입니다. 피고들이 스파이웨어 남용의 각 혐의에 대한 역할이 조사될 수 있다면 충분하다는 것이었습니다; (iii) 서버 아키텍처: 법원은 피고들의 서버 아키텍처에 대한 구체적인 정보가 현재 소송 단계에서 필요하지 않다고 결론 내렸습니다. 이 결정은 주장된 스파이웨어의 전체 기능을 이해하는 것이 (공개되어야 하는) 원고들의 목적을 위해 서버 설정의 기술적 세부사항에 심층적으로 파고들 필요는 없다는 판단에 기반하고 있습니다.\n\n# 법원의 동의에 관한 판결\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n법원은 발견 절차 및 사건 관리와 관련된 여러 동의 관련 움직임에 대한 주요 판결을 내렸습니다:\n\n- 원고의 발견 강요 동의서 (Dkt. 236). 이 동의서는 대부분 수락되었으나 일부는 거부되었습니다. 법원은 Richmark 요소에서 제공된 지침에 따라 원고들이 제출한 특정 정보 요청의 중요성과 구체성을 인정했습니다. 구체적으로, 법원은 사건과 관련이 있는 악성 소프트웨어의 버전 및 기능에 대한 정보를 제공하도록 피고인들에게 요구했습니다. 그러나 이 동의서는 완전히 수락되지 않았으며, 일부 요청은 너무 넓거나 충분히 구체적이지 않거나 강제 발견의 입김 임계값을 충족하지 않았을 가능성이 있습니다.\n- 피고인의 발견 강요 동의서 (Dkt. 240). 이 동의서는 거부되었습니다. 피고인들은 제3자 증인 (시민 연구소)와 관련된 원고들의 의사 소통 및 피고인 소프트웨어를 통해 타깃으로 지정된 사용자들의 식별과 관련된 내부 문서를 요청했습니다. 법원은 피고인들이 이러한 요청이 사건의 소송 또는 방어에 따라 Rule 26(b)(1)에 따라 관련성을 입증하지 않았다고 판단했습니다.\n- 피고인의 사건 관리 일정으로부터의 해방을 위한 동의서 (Dkt. 265). 이 동의서는 수락되었으며, 피고인들에게 발견 마감일과 요약 판결 및 재판의 연장 마감일을 약 6개월 동안 허용했습니다. 이 동의서를 수락한 법원의 결정은 사건에 수반된 복잡성을 인지하며, 검토될 정보의 양이나 관할 지역 간 조정의 어려움 등을 고려했을 가능성이 있습니다.\n- 봉인 동의서 (Dkt. 235, 239, 249, 257, 260, 264, 272, 276). 당사자들이 제출한 모든 봉인 동의서가 수락되었습니다. 이는 법원에 제출된 특정 문서나 정보가 비공개로 유지되어 공개되지 않을 것을 의미하며, 이는 일반적으로 개인 정보 보호 문제 또는 해당 문서에 포함된 정보의 민감성 때문일 가능성이 큽니다.\n\n<img src=\"/assets/img/2024-05-23-WhatsAppsVictoryOverSpywareTitantheTakedownofPegasus_3.png\" />\n\n# 디지털 감시와 사이버 보안에 대한 함의\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 문제의 핵심은 근본적인 질문이 있습니다: 미국인들은 외국 기관, 특히 이스라엘 회사에서 동의 없이 감시를 받고 싶어 할까요? 이는 사람들의 개인 정보 보호권과 디지털 세계에서 넘어가는 보이지 않는 경계에 대한 심오한 우려에 관련이 있습니다.\n\n미국의 법률 체계와 정부는 갈림길에 서 있습니다. 사람들이 어떤 사회에서 살고 싶은지 심사숙고해야 합니다. 그들은 개인 정보 보호를 희생하려 할까요? 아니면 우리의 허락을 받기 전까지 보이지 않음을 포함한 자유를 믿나요?\n\n미국의 법적 구조는 발전해야 합니다. 사람들이 위협에 대비하면서, 동의 없이 (특히 외국에서의) 감시가 일반적인 행태가 되지 않도록 보장해야 합니다.\n\n#면책 조항\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 기사에 제공된 정보는 정보 및 교육 목적으로만 제공되는 것이며, 법률 자문이나 법률 자문 대체로 사용되어서는 안 됩니다. 본문의 정확성과 완전성을 보증하기 위해 노력했지만, 법률 원칙과 규정은 관할 지역과 구체적 상황에 따라 상당히 다를 수 있음을 감안해야 합니다. 따라서 이 기사는 결정적인 법적 자료나 법적 판단의 기초로 사용해서는 안 됩니다. 독자들은 각각의 사례가 상세하고 맞춤화된 법률 분석을 필요로 할 수 있으므로 법률 문제나 사안에 관해 자격 있는 변호사와 상담하기를 강력히 권고합니다.\n\n본문에서 제공된 정보를 전적으로 의존하고 변호사의 전문 자문을 구하지 않으면 의도하지 않은 법적 결과나 오해를 초래할 수 있습니다. 이 기사의 저자나 발행인은 잠재적인 오류나 생략에 대한 책임을 인정하지 않으며, 그 내용이나 사용으로 인해 발생한 손실, 부상, 또는 손해에 대해서도 책임을 지지 않습니다. 여기에 제공된 정보는 독자와 저자 또는 발행인 간의 변호사-의뢰인 관계를 설정하지 않습니다.\n","ogImage":{"url":"/assets/img/2024-05-23-WhatsAppsVictoryOverSpywareTitantheTakedownofPegasus_0.png"},"coverImage":"/assets/img/2024-05-23-WhatsAppsVictoryOverSpywareTitantheTakedownofPegasus_0.png","tag":["Tech"],"readingTime":9},{"title":"프라이버시 보호를 위한 라이드 헤일링의 필요성","description":"","date":"2024-05-23 18:53","slug":"2024-05-23-WhyWeNeedPrivacy-PreservingRide-Hailing","content":"\n![Why We Need Privacy-Preserving Ride-Hailing](/assets/img/2024-05-23-WhyWeNeedPrivacy-PreservingRide-Hailing_0.png)\n\n요즘 세상에서 개인 데이터의 프라이버시와 보안을 보장하는 것은 점점 중요해지고 있어요. 사용자들은 더 자주 불법적 접근과 이용으로부터 개인 정보를 보호하는 것에 대해 걱정하고 있어요. 디지턀 확장은 우리가 공유하는 데이터 양을 증가시키고 동시에 데이타 유출이나 남용의 위험을 안겨줘요. 사회 네트워킹 앱들이 사용자들의 비밀 정보를 주로 수확하는 주범으로 예상되지만, 그것에는 일리가 있어요. 동시에 거의 모든 현대 스마트폰에 포함된 앱 그룹 중 하나인 라이드헤일링 서비스 앱들은 종종 고려에서 제외되기도 해요.\n\n우버, 겟, 카비피 등의 서비스들은 최근 몇 년간 우리 일상생활의 필수 요소가 되었어요. 쉽게 이동할 수 있는 편리한 교통 수단을 제공함으로써 일상생활을 용이하게 만들어줘요. 안타깝게도, 우리는 이러한 앱들이 우리에 대해 얼마나 많은 정보를 알고 있을지, 그 정보를 어떻게 활용할 수 있는지 생각하기 흔치 않아요. 이 글에서는 라이드헤일링 서비스가 사용자에 대해 얼마나 많은 것을 알고 있을 수 있는지, 완전히 개인적인 라이드헤일링의 중요성을 인식해야하는 이유에 대해 고찰해보려고 해요.\n\n예를 들어, 앨리스가 M 도시에서 일하고 C 회사에 다니고 있다고 가정해봅시다. 그녀의 일정은 유연해요: 일주일 중 절반은 사무실에서 보내고 나머지 절반은 카페나 집에서 보내요. M 도시에는 비슷한 라이드헤일링 서비스가 몇 개 있어요. 앨리스는 도시 안에서 다니는 다양한 방법을 사용하며 대중 교통을 이용하기도 하고 라이드헤일링 서비스를 선호하기도 해요. 그중 약 절반의 이동은 우버나 비슷한 서비스를 이용해요. 이동수단을 선택할 때 앨리스의 주요 고려 사항은 비용과 시간이에요. 따라서 그녀는 매번 여러 앱에서 여행 비용을 비교하고 이 정보를 기반으로 결정을 내려요. 앨리스 사례를 토대로 일반적인 라이드헤일링 서비스가 사용자에 대해 어떤 정보를 알 수 있는지 알아보려고 해요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## **앨리스에 대해 우버가 알고 있는 정보는 무엇인가요?**\n\n가장 첫 번째이자 가장 명백한 측면은 우버 서비스를 통해 이루어진 각 여행마다 회사가 앨리스의 픽업, 드롭오프 및 여행 시간과 함께 도중 정차지에 대한 데이터를 수신한다는 것입니다. 심지어 이 단계에서도 서비스에 의해 수집된 정보가 상당히 민감함을 알 수 있습니다. 처음에는 다른 서비스를 사용하는 것이 더 많은 익명성 또는 더 나은 개인 정보 보호에 기여할 것으로 보일 수 있습니다. 그러나 사실은 아닙니다. 여행을 위한 최적의 서비스를 결정하기 전에 앨리스는 여러 서비스의 애플리케이션에서 여행 비용을 확인하고 이로써 출발지와 도착지를 공유합니다.\n\n어떤 일이 벌어지든 각 요청은 앨리스의 계획된 여행에 대한 정보를 서비스에 제공합니다. 따라서 앨리스가 여행을 위해 선택한 서비스에 상관없이, 해당 정보를 수집함으로써 각각의 서비스는 그녀가 어디에서 출발했고 어디로 가거나 계획했는지 알 수 있습니다.\n\n앨리스의 여행 이력은 단지 빙산의 일각에 불과합니다. 왜냐하면 이러한 데이터를 기반으로, 숙박업체는 훨씬 중요한 정보에 접근할 수 있기 때문입니다. 여행 이력으로부터 정확히 어떤 정보를 얻을 수 있는지 살펴보도록 하겠습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nAlice의 집과 사무실 주소: Alice의 경우, 가장 흔한 목적지는 집 주소와 일하는 회사의 사무실 주소일 것입니다.\n\nAlice가 일하는 회사: Alice의 사무실 주소를 아는 경우, 라이드헤일링 서비스는 Alice가 일하는 회사를 높은 확률로 결정할 수 있습니다. 주소가 특정 회사를 가리키는 경우 문제가 즉시 해결되지만, 주소가 멀티 오피스 센터에 속하는 경우, Alice가 일하는 회사를 직접적으로 식별하는 것이 불가능할 수도 있습니다. 그러나 라이드헤일링 서비스는 해당 주소에 가능한 회사 목록을 가지고 있으며 추가로 공개된 정보를 활용하여 회사 후보군을 크게 좁힐 수 있습니다. 이러한 정보에는 근무 시간, 주말 근무 일정 등이 포함될 수 있습니다. 게다가, 일정을 기반으로 하여 일부 경우에는 심지어 Alice의 회사 내 직위를 결정할 수도 있습니다.\n\nAlice가 집을 떠나는 시간과 돌아오는 시간: 움직임 이력을 알고 있는 라이드헤일링 서비스는 Alice가 다른 날짜에 집을 떠나는 시간과 돌아오는 시간을 알 수 있습니다.\n\nAlice의 근무 일정: 앞선 두 가지 점을 유도하여, 라이드헤일링 서비스는 쉽게 Alice의 근무 일정을 결정할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n앨리스가 도시를 떠난 시기와 기간: 앨리스가 일시적으로 도시를 떠난 시기에 대한 정보를 추출하는 것은 꽤 간단합니다. 이는 특정 기간 동안의 여행이 전혀 없음을 확인함으로써 종종 확인됩니다. 공항으로부터 이동하거나 돌아오는 여행을 통해 추가적인 확실성을 얻을 수도 있습니다. 또한 많은 라이드헤일링 서비스가 다른 도시와 국가에서 운영되고 있으므로, 해당 서비스들은 앨리스의 여행 방향 또한 파악할 수 있습니다.\n\n앨리스의 사회적 관계망: 앨리스의 사회적 관계망에 속한 사람들도 라이드헤일링 서비스를 사용한다고 가정해보겠습니다. 이는 라이드헤일링 서비스가 앨리스뿐만 아니라 그녀의 사회적 관계망에 대한 데이터에 접근할 수 있다는 것을 의미합니다. 앨리스와 다른 사람들의 여행 이력 중 겹치는 부분을 분석함으로써 앨리스가 만날 가능성이 높은 사람들을 식별할 수 있습니다. 예를 들어 X일에 앨리스가 Y 식당으로 여행을 한다고 가정해봅시다. 동시간대에 거의 동일한 위치로 향하는 N개의 여행을 볼 수 있습니다. 이 정보만으로는 앨리스가 이들 중 누구와 만나는지 판단하는 것은 어렵습니다. 그러나 동시간대와 장소에 도착한 N명과 다른 이야기에서의 겹치는 부분을 찾아볼 수 있습니다. 앨리스를 만나기 위해 여행한 사람들이 더 많은 이러한 겹침을 가지고 있을 가능성이 매우 높습니다.\n\n기업 간 커뮤니케이션 그래프: 이전 포인트에서의 정보를 사용하고, 어떤 참가자가 어떤 기업의 이익을 대표하는지 알아낸다면, 서로 다른 회사 간의 커뮤니케이션 그래프를 구성할 수 있습니다. 이 그래프는 종종 매우 민감한 정보를 포함할 수 있습니다.\n\n회사 내부 정보만으로 라이드헤일링 서비스에게 제공되는 정보의 일부에 불과합니다. 그러나 회사 내부 정보 외에도 소셜 네트워크 및 기타 온라인 자원에 게시된 공개 정보에 접근할 수 있다는 점을 감안하면, 이 목록은 상당히 확장될 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n많은 국가에서 정부 기관들이 라이드헤일링 서비스의 활동을 밀접히 모니터하고 여정에 대한 모든 정보에 대한 접근을 요구하는 것은 우연이 아닙니다.\n\n## 완벽한 프라이빗 라이드헤일링을 구축하는 열쇠로서의 FHE\n\nFully Homomorphic Encryption (FHE)은 사용자들의 완전한 프라이버시를 보장하면서 라이드헤일링 분야를 혁신할 잠재력을 지닌 암호화 기술입니다. FHE를 사용하면 라이드헤일링 서비스가 여행 자료를 공개하지 않고도 승객 데이터를 처리할 수 있습니다. 이는 이러한 서비스가 전통적인 라이드헤일링 애플리케이션과 유사하게 작동하더라도 모든 사용자 데이터가 완전히 암호화되어 서비스 자체조차도 볼 수 없게 되는 것을 의미합니다. 이 접근 방식은 사용자들에게 안전하고 기밀성이 보장되는 환경을 조성해줍니다. 사용자들의 개인 정보가 라이드헤일링 서비스를 이용하는 동안 안전하게 보호되어 있습니다. 궁극적으로 FHE는 교통 산업에서 더욱 안전하고 개인 정보 보호에 중점을 둔 혁신을 이끌어낼 수 있습니다. 이러한 고급 암호화 기술을 채택함으로써, 라이드헤일링 회사들은 사용자들과 보다 더 큰 신뢰를 구축하고 데이터 프라이버시에 새로운 기준을 제시할 수 있습니다.\n\n라이드헤일링은 FHE가 프라이버시를 강화하는 데 상당한 기여를 할 수 있는 한 가지 예시일 뿐입니다. 우리는 페어 매스(Fair Math)에서 이 기술을 보다 쉽게 적용할 수 있도록 노력하고 있습니다.\n","ogImage":{"url":"/assets/img/2024-05-23-WhyWeNeedPrivacy-PreservingRide-Hailing_0.png"},"coverImage":"/assets/img/2024-05-23-WhyWeNeedPrivacy-PreservingRide-Hailing_0.png","tag":["Tech"],"readingTime":6},{"title":"암호로 코딩하기 암호화된 데이터 구조 및 알고리즘","description":"","date":"2024-05-23 18:50","slug":"2024-05-23-CodinginCipherEncryptedDataStructuresandAlgorithms","content":"\n![이미지](/assets/img/2024-05-23-CodinginCipherEncryptedDataStructuresandAlgorithms_0.png)\n\nFully Homomorphic Encryption (FHE)이라는 혁신적인 방식을 소개합니다. FHE은 암호화된 데이터를 해독하지 않고도 데이터에 대한 계산을 수행할 수 있는 방법을 제공합니다. 이는 데이터 상의 연산을 수행하면서 완전한 개인 정보 보호를 유지할 수 있음을 의미합니다. FHE은 사후 양자 암호화 방법을 활용하여 암호화된 데이터가 클라우드나 블록체인과 같은 공개 네트워크에서 안전하게 유지되도록 합니다.\n\n이 시리즈 기사에서는 바이너리 검색 트리, 정렬 알고리즘, 그리고 동적 프로그래밍 기술과 같은 전통적인 데이터 구조 및 알고리즘을 FHE를 활용해 암호화된 영역에서 구현하는 방법을 탐구합니다. 데이터셋에서 완전히 암호화된 상태로 이진 검색을 수행하거나, 원시 형태로 보이지 않는 데이터를 정렬하면서 데이터의 개인 정보 보호와 안전성이 절대로 위협받지 않도록 보장할 수 있습니다.\n\nFHE가 어떻게 기본 수준에서 작동하는지와 데이터 보안 및 알고리즘 설계에 미치는 영향에 대해 깊이 파고들 것입니다. 이 시리즈에서는 실제 응용 프로그램 및 사기 탐지, 지불 등을 포함한 이런 암호화된 알고리즘을 구현할 때 개발자가 직면하는 잠재적인 도전에 대해 탐구할 것입니다. 이것은 보안을 향상시키는 데 그치는 것이 아니라, 데이터와 상호 작용하는 방식을 재고하고 소프트웨어 개발에서 가능한 범위를 넓히는 데 관한 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n경험 많은 개발자이거나 암호화된 컴퓨팅 개념에 익숙하지 않은 분이라도, 이 기사는 고급 암호 기술을 프로그래밍 프로젝트에 통합하는 방법에 대한 통찰력을 제공할 것입니다. 함께 이 여행을 떠나서 암호로 코딩하는 잠재력을 발견해 보세요. 일상 데이터 연산을 안전하고 개인정보 보호를 위한 계산으로 변환하여 안전한 디지털 혁신의 새 시대를 열어보겠습니다.\n\n# 완전가환암호 기본\n\nFHE(Fully Homomorphic Encryption)에서 암호문에서 수행할 수 있는 주요 연산은 덧셈과 곱셈입니다. 이 연산들은 더 복잡한 연산의 기본 요소로 사용됩니다. 예를 들어, 두 개의 암호화된 값을 더할 수 있으며, 복호화된 결과는 원래 평문 값의 합이 될 것입니다. 이러한 기본 연산의 조합을 사용하여 복잡한 계산을 구성할 수 있으며, 이를 통해 알고리즘 및 기능을 암호화된 데이터에서 실행할 수 있습니다. 예를 들어, 두 입력 값 x와 y를 사용하여 x + x _ y를 계산하는 함수 F가 있다고 가정해 봅시다. 이 함수의 수학적 표현은 F(x, y) = x + x _ y로 작성될 수 있으며, 또한 회로로 표현할 수 있습니다. 즉, 직접 비순환 그래프입니다:\n\n![Image](/assets/img/2024-05-23-CodinginCipherEncryptedDataStructuresandAlgorithms_1.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 소음\n\nFHE를 사용하면 암호화된 데이터에서 연산을 수행할 수 있지만, 암호문 내의 소음 증가라는 추가적인 어려움이 동반됩니다. 이는 적절하게 관리되지 않으면 결국 복호화 오류로 이어질 수 있습니다. FHE 스키마에서는 각 암호문에 일정량의 보안을 보장하는 소음이 포함됩니다. 이 소음은 처음에는 작지만 암호문에 수행되는 연산이 늘어날수록 증가합니다. 덧셈 연산을 수행할 때 소음은 비교적 작지만, 곱셈을 할 때는 두 암호문의 소음이 곱해져서 증가합니다. 결과적으로, 두 개의 소음 레벨 n1과 n2를 가진 암호문을 곱할 때 결과 암호문의 소음은 n1 \\* n2로 근사될 수 있거나 n1 또는 n2만큼보다 훨씬 빨리 증가하는 함수가 됩니다.\n\n![이미지](/assets/img/2024-05-23-CodinginCipherEncryptedDataStructuresandAlgorithms_2.png)\n\nFHE 스키마의 소음을 관리하는 몇 가지 방법이 있지만, 글의 분량을 고려하여 주된 초점은 부스트래핑이라는 소음 감소 기술에 있습니다. 부스트래핑은 암호문의 소음 수준을 줄이고, 따라서 소음 예산을 회복시키고 더 많은 연산을 가능하게 합니다. 본질적으로, 부스트랩은 복호화 및 다시 암호화 알고리즘을 순환 암호화적으로 적용합니다. 이는 FHE 스키마의 전체 복호화 회로를 암호화된 함수로 평가해야 한다는 것을 필요로 합니다. 결과는 이전과 동일한 평문을 나타내지만 소음이 줄어든 새로운 암호문입니다. 부스트랩은 FHE에서 무제한으로 암호화된 데이터에 대한 연산을 허용하는 중요한 기술입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 이론에서 실제로\n\nFHE를 탐색하는 첫 걸음을 내딛기 위해, fhe-studio.com에서 찾을 수 있는 오픈 소스 IDE에 있는 미리 만들어진 회로를 살펴볼 수 있습니다. 이 IDE는 Concrete FHE 라이브러리를 기반으로 합니다. Concrete의 FHE 스키마(TFHE 스키마의 변형)는 이진 기반으로, 각 비트가 개별적으로 암호화됩니다. 구현은 개발자의 예시를 사용하여 정수당 비트 수를 자동으로 선택합니다. 또한 Concrete는 자동 노이즈 관리를 허용하여 복잡성을 크게 감소시키고 초보 사용자에게 더 많은 접근성을 제공합니다. 이제 2개의 숫자를 더하는 간단한 회로를 살펴봅시다:\n\n```js\nfrom concrete import fhe\n\n#1. 회로 정의\ndef add(x, y):\n    return x + y\n\n# 2. 회로 컴파일\ncompiler = fhe.Compiler(add, {\"x\": \"encrypted\", \"y\": \"clear\"})\n\n# 정수에 사용할 비트 수를 결정하기 위한 예시\ninputset = [(2, 3), (0, 0), (1, 6), (7, 7), (7, 1)]\ncircuit = compiler.compile(inputset)\n\n# 3. 테스트\nx = 4\ny = 4\n\n# clear evaluation (암호화되지 않음)\nclear_evaluation = add(x, y)\n\n# 데이터 암호화, 암호화된 회로 실행, 결과 복호화\nhomomorphic_evaluation = circuit.encrypt_run_decrypt(x, y)\n\nprint(x, \"+\", y, \"=\", clear_evaluation, \"=\", homomorphic_evaluation)\n```\n\n그런 다음 컴파일러는 이 회로를 MLIR 형식으로 컴파일하며, 컴파일이 완료되면 사용자에게 표시됩니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nmodule {\n  func.func @main(%arg0: !FHE.eint<4>, %arg1: i5) -> !FHE.eint<4> {\n    %0 = \"FHE.add_eint_int\"(%arg0, %arg1) : (!FHE.eint<4>, i5) -> !FHE.eint<4>\n    return %0 : !FHE.eint<4>\n  }\n}\n```\n\n회로가 컴파일되면 FHE 보관고에 추가하여 다른 사람들이 동일한 암호화된 계산을 수행할 수 있는 회로를 공유할 수 있습니다.\n\n![image](/assets/img/2024-05-23-CodinginCipherEncryptedDataStructuresandAlgorithms_3.png)\n\n# FHE Operations\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nIDE에서 사용되는 FHE 스키마는 기본적으로 다음 작업을 지원합니다:\n\n1. 더하기\n2. 곱하기\n3. 비트 추출 (모든 비트가 개별적으로 암호화되기 때문)\n4. 테이블 조회\n\n처음 세 가지는 매우 직관적이지만, 마지막은 주의가 필요합니다. 아래 예시를 살펴봅시다:\n\n```js\ntable = fhe.LookupTable([2, -1, 3, 0])\n\n@fhe.compiler({\"x\": \"encrypted\"})\ndef f(x):\n    return table[x]\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n일반적인 테이블처럼 작동합니다. x=0 이라면 f = 2이며, 나머지도 동일합니다: f(1) = -1; f(2) = 3; f(3) = 0.\n\n테이블 조회는 매우 유연합니다. 덧셈, 뺄셈, 비암호화 값과의 곱셈, 텐서 조작 작업을 제외한 모든 작업 및 일부 기본 작업으로 구성된 몇 가지 작업은 테이블 조회로 변환됩니다. 이러한 작업은 Concrete가 여러 작업을 지원하도록 하지만 사용량이 많기 때문에 비용이 많이 듭니다. 정확한 비용은 많은 변수(사용된 하드웨어, 오류 확률 등)에 따라 달라지지만 다른 작업에 비해 항상 훨씬 비싸지므로 가능한 한 피해야 합니다. 항상 완전히 피하는 것이 항상 가능한 것은 아니지만 일부를 다른 기본 작업과 교체하여 총 테이블 조회 수를 줄이려고 해야 합니다.\n\n# IF Operator / Branching\n\nIF 연산자는 FHE에 기본적으로 포함되어 있지 않으며, 산술적 방법으로 사용해야 합니다. 다음 예제를 살펴보겠습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nif a > 0:\n    c = 4\nelse:\n    c = 5\n```\n\nFHE에서는 데이터를 직접적으로 볼 수 없기 때문에 모든 분기를 주의 깊게 다뤄야 합니다. 따라서 코드는 하나는 0이고, 다른 하나는 1인 두 식의 합이 됩니다:\n\n```js\nflag = a > 0 # 1 또는 0을 나타냄\nc = 4 * flag + 5 * (1 - flag)\n```\n\nFHE에서 0은 네이티브가 아님을 기억하세요. 가장 간단한 구현 방법은 look-up table을 사용하는 것입니다. 양수 변수 a가 2비트라고 가정하면, a가 0인 경우를 제외한 모든 (4) 결과에 대해 a` 0이 됩니다. a의 두 비트의 모든 결과에 대한 테이블을 구성할 수 있습니다: '0,1,1,1'. 그럼 회로는 다음과 같을 것입니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\ntable = fhe.LookupTable([0, 1, 1, 1])\n\n@fhe.compiler({\"a\": \"encrypted\"})\ndef f(a):\n    flag = table[a] # a > 0, for 2bit a\n    return 4 * flag + 5 * (1 - flag)\n```\n\n중요한 점은 a가 2비트 이상으로 커진다면 해당 룩업 테이블의 크기가 매우 빠르게 증가하여 회로의 평가 키 크기가 증가할 수 있다는 것입니다. Concrete FHE 구현에서 이 접근 방식은 비교 연산자의 기본 기능입니다. 예를 들어, 다음 회로를 보겠습니다:\n\n```js\nfrom concrete import fhe\n\n@fhe.compiler({\"x\": \"encrypted\"})\ndef less_then_21(x):\n    return x < 21\n\ninputset = [1, 31]\n\ncircuit = less_then_21.compile(inputset)\n\n# 결과는 5비트 정수\nx = 19\nhomomorphic_evaluation = circuit.simulate(x)\nprint(f\"homomorphic_evaluation = {homomorphic_evaluation}\")\n```\n\n컴파일하고 MLIR(컴파일된 회로)를 검사하면 생성된 룩업 테이블을 관찰할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nmodule {\n  func.func @main(%arg0: !FHE.eint<5>) -> !FHE.eint<1> {\n    %c21_i6 = arith.constant 21 : i6\n    %cst = arith.constant dense<[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]> : tensor<32xi64>\n    %0 = \"FHE.apply_lookup_table\"(%arg0, %cst) : (!FHE.eint<5>, tensor<32xi64>) -> !FHE.eint<1>\n    return %0 : !FHE.eint<1>\n  }\n}\n```\n\n# 덧셈을 사용하여 두 숫자 비교\n\nFHE를 사용하여 두 이진 숫자를 비교하는 방법은 간단한 산술을 사용하여 효율적으로 수행할 수 있습니다. 뺄셈을 사용하여 두 이진 수를 비교하는 방법은 이진 산술의 특성을 활용합니다. 핵심 아이디어는 두 숫자를 빼면 결과 및 작업 중에 설정된 특정 플래그(프로세서의 carry 플래그와 같은)을 기반으로 상대적인 크기에 대한 정보가 드러난다는 것입니다.\n\n이진 뺄셈에서 A가 B보다 크거나 같으면 결과가 양수입니다. B가 더 크면 결과가 음수이며 carry 플래그가 1이됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-05-23-CodinginCipherEncryptedDataStructuresandAlgorithms_4.png\" />\n\n여기서 의미하는 것은 A가 B라면 carry=1이고 그렇지 않으면 0이라는 것입니다. 우리는 오른쪽에서 왼쪽으로 캐리 비트를 계산해야 하며 마지막 케리가 최종 결과가 됩니다. FHE 계산을 가속화하기 위해 각 비트에 대해 1+ A - B를 계산하여 이를 양수로 만들 수 있습니다. 이 예제는 잔여값을 저장하기 위해 단지 2개의 비트만 필요합니다. 그런 다음 (``)으로 캐리 비트를 2칸 왼쪽으로 이동시키고 잔여값을 더합니다. 모든 결과의 총 수는 8개가 되며, 우리는 이를 룩업 테이블과 함께 사용하여 다음 캐리 비트를 출력할 수 있습니다. 이 회로에서와 같이요.\n\n```js\n# 두 숫자는 비트 배열로 표시되어야 합니다\n# ---------------------------\n# 0 0000 -> 1 개 더 적습니다 (1+0-1), 캐리 비트 설정\n# 1 0001 -> 0, 동일 (1+1-1) 또는 (1+0-0)\n# 2 0010 -> 0, 크거나 같습니다 (1+1-0)\n# 3 0100 -> 0 (존재하지 않음)\n# 캐리 비트 설정\n# 5 1000 -> 1\n# 6 1100 -> 1\n# 7 1010 -> 1\n# 8 1010 -> 1\n\nfrom concrete import fhe\n\ntable = fhe.LookupTable([1,0,0,0,1,1,1,1])\n\n# 결과는 작으면 1, 그렇지 않으면 0\n@fhe.compiler({\"x\": \"encrypted\", \"y\": \"encrypted\"})\ndef fast_comparision(x, y):\n    carry = 0\n\n    # 모든 비트에 대해\n    for i in range(4):\n        s = 1 + x[i] - y[i]\n        # 2칸 왼쪽으로 이동 (carry << 4)\n        carry4 = carry*4 + s\n        carry = table[carry4]\n\n    return curry\n\ninputset = [([0,1, 1, 1], [1,0, 1,1])]\n\ncircuit = fast_comparision.compile(inputset)\n\nhomomorphic_evaluation = circuit.simulate([1,0,1, 0], [1,0,0,0])\nprint(\"homomorphic_evaluation =\", homomorphic_evaluation)\n```\n\n이 방법은 이전 예제와 같이 룩업 테이블을 사용하는 것보다 계산적으로 훨씬 더 비쌉니다. 그러나 여기서는 메모리복잡성이 낮습니다. 왜냐하면 룩업 테이블은 단지 8개의 값을 가지고 있기 때문에 평가 키가 작아집니다. 그리고 예상대로, 아무것도 완벽하지 않습니다. 메모리 사용량 대 CPU 사용량 및 선택한 방법에 따라 키 크기 사이의 교환이 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 정렬\n\n버블 정렬을 살펴보겠습니다. 이는 간단한 비교 기반 정렬 알고리즘이며, 정렬할 목록을 반복적으로 확인하면서 인접한 항목 쌍을 비교하고 순서가 잘못된 경우에는 교환합니다. 이 알고리즘은 작은 요소들이 각 반복에서 목록의 맨 위(배열의 시작)로 올라가고, 큰 요소들이 각 반복에서 목록의 맨 아래(배열의 끝)로 가라앉는다는 특징 때문에 이름이 지어졌습니다.\n\n```js\nfrom concrete import fhe\nimport numpy as np\n\n@fhe.compiler({\"in_array\": \"encrypted\"})\ndef bubble_sort(in_array):\n    for i in range(len(in_array)):\n        for j in range(len(in_array)-1):\n            a = in_array[j]\n            b = in_array[j+1]\n            flag = a > b\n            # if a > b then swap the values\n            in_array[j] = flag * b + (1-flag) * a\n            in_array[j+1] = flag * a + (1-flag) * b\n\n    return in_array\n\ninputset = [[3,0,0,0]]\ncircuit = bubble_sort.compile(inputset)\n\ntest = [3,2,0,1]\ntest_clear = test.copy()\ntest_fhe = test.copy()\n\nclear_evaluation = bubble_sort(test_clear)\n\n#homomorphic_evaluation = circuit.encrypt_run_decrypt(test_fhe)\nhomomorphic_evaluation = circuit.simulate(test_fhe)\n\nprint(test, \"=> \", clear_evaluation, \"=>\", homomorphic_evaluation)\n```\n\n버블 정렬은 속도가 꽤 느리지만 [O(n²)] 매우 메모리 효율적입니다 [O(1)]. 더 CPU 효율적인 알고리즘을 원한다면 병합 정렬을 사용할 수 있습니다. 이는 목록을 더 작고 더 관리하기 쉬운 부분(이상적으로는 개별 요소까지)으로 분할하고, 이러한 부분들을 정렬한 다음 올바른 순서대로 다시 병합하는 원리에 기반합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Coding in Cipher: Encrypted Data Structures and Algorithms](/assets/img/2024-05-23-CodinginCipherEncryptedDataStructureandAlgorithms_5.png)\n\n머지 소트는 O(n log n)의 복잡도를 가지며, 대규모 데이터 세트에 대해 가장 효율적인 정렬 알고리즘 중 하나입니다. 그러나 공간 복잡도는 O(n)으로, 임시 병합 과정에 대한 배열 크기에 비례하는 추가 공간이 필요합니다.\n\n# 동적 프로그래밍\n\n동적 프로그래밍은 복잡한 문제를 더 간단한 하위 문제로 분해하여 각 하위 문제를 한 번만 해결하여 해결하는 방법입니다. 아이디어는 더 작은 하위 문제를 효율적으로 해결할 수 있다면 이러한 해결책을 사용하여 더 큰 문제에 대처할 수 있다는 것입니다. 피보나치 수열을 예로 들어보겠습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n피보나치 수열은 각 수가 이전 두 수의 합인 수열로, 일반적으로 0과 1로 시작합니다. 수열은 보통 0, 1, 1, 2, 3, 5, 8, 13과 같이 이어집니다. 동적 프로그래밍을 사용하여 n번째 피보나치 수를 구할 때, 무분별한 재귀 접근보다 중복 계산을 피하므로 효율적일 수 있습니다.\n\n![이미지](/assets/img/2024-05-23-CodinginCipherEncryptedDataStructuresandAlgorithms_6.png)\n\n위 그림을 보면 F(6)를 구하기 위해 F(5)와 F(4) 두 개의 하위 문제를 재귀적으로 해결해야 합니다. 해결 방법이 겹치는 것을 알 수 있으므로 F(4)의 계산이 나무의 왼쪽과 오른쪽 모두에서 발생합니다. 당연히 각 고유 결과를 캐시하고 한 번만 계산해야 합니다. 그러면 나무가 매우 단순해질 것입니다. 이 접근 방식을 메모이제이션이라고 합니다.\n\n![이미지](/assets/img/2024-05-23-CodinginCipherEncryptedDataStructuresandAlgorithms_7.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nFully Homomorphic Encryption (FHE)의 맥락에서는 기본 특성과 보안 제약으로 인해 일반적으로 메모이제이션을 사용할 수 없습니다. FHE는 암호화된 데이터에서 작업을 수행할 수 있도록 허용하기 때문에 실제 데이터 값은 계산 중에 숨겨진 상태로 유지됩니다.\n\n동적 프로그래밍의 다른 접근 방식은 타뷸레이션이라고 불립니다. 타뷸레이션은 작은 하위 문제부터 해결하고 그 해결책을 사용하여 더 큰 문제의 해결책을 구축하는 하향식 접근 방식입니다. 이 방법은 FHE에 특히 효과적인데, 이는 비재귀적인 특성을 가지고 있기 때문입니다. 타뷸레이션은 각 단계에서 현재 값을 업데이트하는 테이블을 사용합니다. 이 예시에서는 첫 번째 요소가 0이 되어야하고 두 번째 요소가 1이 되어야하는 기본 조건을 만족하는 6개 요소의 테이블을 초기화합니다. 그런 다음 나머지 요소는 0으로 초기화됩니다: [0,1,0,0,0,0]. 그런 다음, 왼쪽에서 오른쪽으로 진행합니다.\n\n![image](/assets/img/2024-05-23-CodinginCipherEncryptedDataStructuresandAlgorithms_8.png)\n\n이 글은 암호화 데이터 구조 및 알고리즘에 관한 시리즈의 시작을 알립니다. 다음에는 Fully Homomorphic Encryption (FHE) 영역에서 그래프 및 트리, 머신 러닝 및 인공 지능 사용에 대해 탐구할 것입니다. 그 후에는 금융 산업 내에서의 실제 응용 프로그램을 살펴볼 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 코딩을 암호화로 변환하시겠어요?\n\nFHE-Studio.com에서 오픈 소스 IDE를 활용하여 암호화된 데이터 구조 및 알고리즘의 세계를 더 깊이 탐험해 보세요. 프로젝트를 최고 수준의 보안 프로토콜로 강화하거나 소프트웨어 개발에서의 데이터 프라이버시 다음 세대에 대해 궁금하다면, FHE Studio는 FHE 세계로의 무료이며 오픈 소스 게이트웨이입니다. 회로를 개발하고 시험하고 공유하며 동료로부터 피드백을 받아 보세요!\n\n전문적인 전문 지식을 찾고 계신가요? FHE Studio의 팀은 완전 홈모픽 암호화를 기존 프로젝트에 통합하거나 귀하의 요구에 맞게 맞춤형 새로운 암호화된 솔루션을 개발하는 데 도와드릴 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 우리를 지원해주세요\n\n만약 우리 프로젝트에서 가치를 발견했다면, 우리를 지원하는 것을 고려해보세요. 우리는 FHE-Studio를 열려 있고 접근 가능하게 유지하기로 맹세했으며, 모든 기여가 프로젝트를 확장하는 데 도움이 됩니다.\n\n# 참고 자료\n\n- FHE-STUDIO.COM, 오픈 소스 FHE IDE\n\n2. FHE Studio 문서 및 소스, https://github.com/artifirm\n3. Concrete FHE 컴파일러: https://docs.zama.ai/concrete\n4. Concrete ML은 Fully Homomorphic Encryption (FHE)를 기반으로 하는 오픈 소스 개인 정보 보호 기계 학습 프레임워크입니다. https://docs.zama.ai/concrete-ml\n5. Microsoft SEAL, 오픈 소스 FHE 라이브러리 https://www.microsoft.com/en-us/research/project/microsoft-seal/\n6. HELib, FHE 라이브러리 https://github.com/homenc/HElib\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저자의 이미지가 아닌 경우를 제외하고, 모든 이미지는 저자에 의해 제공되었습니다.\n","ogImage":{"url":"/assets/img/2024-05-23-CodinginCipherEncryptedDataStructuresandAlgorithms_0.png"},"coverImage":"/assets/img/2024-05-23-CodinginCipherEncryptedDataStructuresandAlgorithms_0.png","tag":["Tech"],"readingTime":17},{"title":"독일인과 개인정보 보호 복잡한 일이죠","description":"","date":"2024-05-23 18:49","slug":"2024-05-23-Germansandprivacyitscomplicated","content":"\n<img src=\"/assets/img/2024-05-23-Germansandprivacyitscomplicated_0.png\" />\n\nPetaPixel에서 강력히 추천하는 기사인 “Germany vs Google: How Street View won the privacy battle in Europe’s most private country”는 종종 수업에서 논의하는 문제를 탐구합니다. (특히 독일 학생들의 규칙적인 참여 덕분에 활기찬 토론이 일어나곤 합니다): 독일에서 구글 스트리트 뷰가 처음에 사용 불가능했던 이유는 많은 독일인들이 자신들의 거리와 집을 찍는 카메라가 달린 차량을 반대하자 픽셀화를 요청하여 제품을 사용할 수 없게 만들었기 때문입니다.\n\n작년 6월, 구글은 독일에서 서비스를 재개했고, 이번에는 긍정적으로 받아들여졌습니다. 이는 사회 전반에서의 놀라운 태도 변화였습니다: 어느 시점부터 세계의 모든 도시에 대한 품질 좋은 지도의 이점에 대한 일정한 집단적 반성과 인식으로 독일인들은 초반에 과도하게 반응한 것을 깨달았는데, 이는 현재까지도 그 나라의 개인 정보 보호와 관련이 있는 복잡한 역사적 선례들의 맥락에서 이루어졌습니다.\n\n저는 1933년 2월 27일 독일 의회가 방화된 후 나치당에 의해 공표된 청와대의 인민과 국가 보호를 위한 청원으로 알려진 라이히슈타그의 불령에 대해 이야기하고 있습니다. 도이츠 태통법에서 규정된 권리를 폐지했고, 도이츠 태통법을 반대하는 개인을 체포할 수 있도록 했으며 나치 반대 출판물을 금지할 수 있도록 했습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n유감스럽게도 테이블 태그를 마크다운 형식으로 변경해주세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n간단히 말해서, 우리는 매우 흥미로운 변화를 목격하고 있습니다. 이 변화는 개인 정보 보호에 관한 중요한 논쟁을 이해하는 데 필수적이며, 수업에서 여러 차례 논의해왔습니다.\n","ogImage":{"url":"/assets/img/2024-05-23-Germansandprivacyitscomplicated_0.png"},"coverImage":"/assets/img/2024-05-23-Germansandprivacyitscomplicated_0.png","tag":["Tech"],"readingTime":2},{"title":"Nym 위임 프로그램 20 롤링 등록이 지금 열렸어요","description":"","date":"2024-05-23 18:48","slug":"2024-05-23-NymDelegationsProgram20Rollingregistrationsnowopen","content":"\n## Nym 대표 프로그램의 다음 세대가 여기 있습니다!\n\n믹스넷은 사용자들에게 고급 개인 정보 보호를 제공할 수 있을 때에만 노드들이 잘 작동한다면 가능합니다.\n\n![이미지](/assets/img/2024-05-23-NymDelegationsProgram20Rollingregistrationsnowopen_0.png)\n\nNym 대표 프로그램은 노드 성능을 인센티브화하고 보상이 커뮤니티 서비스 제공 업체로 돌아갈 수 있도록 설계되었습니다. 게다가, 노드는 이상적으로 지리적으로 분산되어 있어야 하며, 이는 대표하지 않은 지역의 운영자들에 대한 토큰 인센티브를 통해 촉진될 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n믿을 만한 성능을 자랑하는 안정적인 노드들은 님 재무부로부터 위임을 받을 수 있습니다. 이는 새로운 노드들이 빈번하게 활성 집합에 참여하고 빠르게 수익을 창출할 수 있도록 도와줄 뿐만 아니라 지리 및 VPS의 탈중앙화, 서비스 품질, 공정한 노드 매개변수에 대한 네트워크 전반적인 인센티브도 제공합니다.\n\n지난 1년 전에 시작된 프로그램은 진화했습니다. 최근에 출시된 Squad Wealth Fund를 통해 이제는 분산화와 커뮤니티 기여를 위한 자금 지원을 추진하고 있습니다. 현재의 위임 금액은 노드 당 25만 NYM이며, Delegations Program을 위해 님 재무부에서 총 3200만 NYM을 지원할 예정입니다.\n\n오늘을 기준으로, Delegations Program이 다시 등록을 받고 있습니다. 큰 변화는 이번 신청 절차가 지속적인 마감 기한을 갖게 된다는 것입니다. 아래에는 새로운 시스템의 모든 세부 정보와 노드 운영자, 위임자 또는 그렇게 되고자 하는 경우 알아두어야 할 중요한 변경 사항이 모두 나와 있습니다.\n\n# 등록\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n등록 양식이나 마감일이 더 이상 없습니다. 새롭게 만들어진 맞춤형 인터페이스(Pawnflake와 ExploreNym의 협조로)를 통해 등록이 계속 열려 있습니다. 귀하의 노드를 여기에 등록해 주세요.\n\n중요 사항: 이전에 귀하의 노드가 이미 위임을 받은 경우, 5월 30일 이전에 재등록해야 합니다. 그렇지 않으면 위임을 잃게 되고 다시 대기열에 참여해야 합니다.\n\n# 대기열 시스템\n\n위임 프로그램이 한 번에 지원할 수 있는 노드의 수에 제한이 있습니다. 노드를 등록하면 대기열에 추가됩니다. 여유 슬롯이 생기면 대기열이 자동으로 채워집니다. 다시 등록할 필요가 없습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 대기열 우선순위\n\n대기열 순서는 기술적으로 선착순이지만, 노드는 전체 네트워크의 필요에 관련된 특정 이유로 우선권을 갖을 수 있습니다. 이는 다음을 포함할 수 있습니다:\n\n- 부대나 커뮤니티 기여자가 운영하는 노드\n- 특히 견고한 하드웨어 사양을 갖춘 노드\n- 유리한 매개변수를 가진 노드\n- 다른 노드가 적은 국가에 위치한 노드\n- 사회적 가치를 위한 노드\n\n어떤 경우에는 노드가 우선순위에서 제외될 수도 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 다른 노드가 많이 있는 국가에 위치한\n- 일반적인 VPS 제공업체에서 운영 중\n\n이 규칙들이 정해져 있는 것은 아닙니다. 우선 순위는 시간이 지남에 따라 발전하고 지속적으로 커뮤니티와 네트워크의 필요에 따라 결정될 것입니다. Nym은 항상 여러분의 피드백을 기다리며 진행 상황, 커뮤니티 영향 및 운영에 대한 피드백을 듣고 싶어합니다.\n\n# 기준\n\n가장 최신 기준은 언제든지 등록 페이지에서 확인하실 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/assets/img/2024-05-23-NymDelegationsProgram20Rollingregistrationsnowopen_1.png)\n\n# 하드웨어 사양\n\n가장 최근의 바이너리 릴리스를 사용할 때, 필요한 최소 하드웨어 사양이 변경되었습니다. 새로운 사양은 다음과 같습니다:\n\n- CPU: 4 코어\n- 메모리: 4 GB\n- 저장 공간: 40 GB\n- 연결: IPv4, IPv6, TCP/IP, UDP\n- 대역폭: 1 Tb\n- 포트 속도: 1 Gbps\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n중요 안내: 모든 노드는 이제 이 최소 사양을 충족해야 합니다. 이미 위임을 받은 노드라 하더라도 이 사양을 충족하지 못하는 경우, 문제를 해결하도록 2024년 5월 30일 이전에 주의해주셔야 합니다. 그렇지 않으면 위임을 잃을 수 있습니다.\n\n# 프로그램 관련 통신 변경 사항\n\n위임 프로그램과 관련된 업데이트는 전체 노드 운영자 커뮤니티에 중요한 내용이며, 이 프로그램 멘토 및 참가자들로부터 많은 것을 배울 수 있습니다. 따라서 위임 프로그램 참가자를 위한 전용 매트릭스 공간은 폐쇄됩니다. 이제 프로그램과 관련된 모든 통신은 Nym 커뮤니티 매트릭스 서버의 Node Operators 채널에서 공개적으로 공유될 것입니다. 이에는 다음이 포함됩니다:\n\n- 매주 진행 상태, 우선순위 변경 포함\n- 위임, 비위임 및 프로그램에서의 제외에 관련된 조치 및 설명\n- 프로그램 기준 변경(등록 페이지에서 실시간으로도 업데이트됨)\n- 우선화 규칙 변경, 즉 우수/비우수 국가 변경\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 멘토십의 변화\n\n모든 공개 통신과 함께, NSL 대표단 프로그램 멘토십은 노드 운영자 멘토십으로 진화하게 되었습니다. 멘토들은 모든 노드 운영자들을 돕고 다음과 같은 책임을 맡게 됩니다:\n\n- 바이너리 릴리스, 뉴스, 문서의 최신 정보를 파악하는 것\n- 노드 운영자 채널을 관리하고 다른 사람들이 기술 문제와 질문에 도움을 받을 수 있도록 하는 것\n- 대표단 프로그램에 관련된 질문에 대해 커뮤니티를 지원하는 것\n\n# 앞으로 기대되는 일들\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNym 커뮤니티에게 다가오는 몇 달은 바쁘고 흥미로운 시간이 될 것입니다. Nym 알파 테스트 NymVPN을 시장에 선보이는 첫 상용 제품으로 Nym 믹스넷 상에서 작동합니다. 이 개인 정보 보호 도구가 작동하려면 Nym 노드 운영자 네트워크는 탈중앙화되고 분산된 방식으로 성장해야 합니다. 그러나 무엇보다도, Nym은 노드에게 유기적이고 잘 인센티브화되어야 하며, 커뮤니티가 고품질 서비스를 제공하도록 장려해야 합니다.\n\n#Nym 커뮤니티에 가입하세요\n\nDiscord // Telegram // Element // Twitter\n\n#개인 정보 보호는 함께 할 때 가치가 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n영어 // 중국어 // 러시아어 // 터키어 // 베트남어 // 일본어 // 프랑스어 // 스페인어 // 포르투갈어 // 한국어\n","ogImage":{"url":"/assets/img/2024-05-23-NymDelegationsProgram20Rollingregistrationsnowopen_0.png"},"coverImage":"/assets/img/2024-05-23-NymDelegationsProgram20Rollingregistrationsnowopen_0.png","tag":["Tech"],"readingTime":6},{"title":"싸워라 웹 스크레이퍼를 상대로 맞선다 - Rust를 이용하여","description":"","date":"2024-05-23 18:46","slug":"2024-05-23-FightingbackTurningtheTablesonWebScrapersUsingRust","content":"\n웹 취약점을 스캔하는 사람들을 괴롭히고 싶은 적이 있나요? 저는 분명히 그랬어요. 이것은 저가 그들을 처벌하는 방법을 찾은 이야기입니다. 그리고 Rust를 사용하여 개선하고, 그리고 밴을 이용해 내 웹 서버를 멈춘 이야기입니다.\n\n# 단계 0: 짜증남\n\n좋아요, 만약 어떤 규모의 웹사이트를 운영해 보셨다면, 액세스 로그를 확인해 보면 곧 여러분의 웹사이트와는 상관없는 요청이 많이 들어온다는 사실을 발견하실 겁니다. 많은 요청 중에는 /wp-login.php, /.env 및 /.git/config 등과 같은 경로를 보는 것들도 많이 있습니다. 큰 회사들도 마찬가지입니다. 이겈 기회로 활용할 수는 없을까요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 단계 1: 지옥의 문을 찾아서\n\n물론 가능해요! 우리 짜증나는 봇 친구들을 괴롭힐 방법을 찾던 중, HellPot이라는 HTTP 허니팟을 발견했어요. 이 허니팟은 웹사이트를 스크랩하려는 봇들을 충돌시키기 위해 만들어졌는데, 단순히 봇들이 요청한 것을 제공해주면 되요. HellPot에 지정된 경로(예: /wp-login.php)로 HTTP 요청을 보내면, 프리드리히 니체의 \"비극의 탄생(헬레니즘과 비관론)\"에서 나오는 웹사이트처럼 보이는 데이터의 영원한 스트림을 만날 거예요. 우리는 robots.txt에 동일한 경로를 넣어서 bingbot이 몇 메가바이트/초의 속도로 니체를 경험하는 걸 피할 거예요.\n\n어떻게 가능한 걸까요? HTTP 응답이 스트림이 될 수 있다는 걸 알았죠. 보통 이건 큰 파일을 전송할 때 사용돼요. 우리의 목적에 이것은 아주 좋아요: 우리는 같은 응답에서 계속 생성만 하면 되요, 스트림을 끊지 않고 계속해서 \"완료!\"라고 말하지 않아도 돼요.\n\n그래서 뭐? 일단 아래 몇 가지를 고려해 봐요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 대부분의 웹 스크래퍼는 제대로 작성되지 않은 스크립트입니다.\n- 대부분의 웹 스크래퍼는 클라우드 인스턴스에서 실행됩니다.\n- 이러한 인스턴스에서는 메모리와 저장 공간이 제한됩니다.\n- 대역폭도 제한됩니다.\n\n그렇다면 shiddy_wp_scraper.py가 데이터를 끊임없이 보내는 웹사이트에 연결하면 어떻게 될까요? 일반적으로 그냥 데이터를 가져올 겁니다! 그리고 메모리보다 더 많은 기가바이트의 데이터를 가져오면, 운영 체제는 일반적으로 일부 프로세스가 종료되어야 한다고 판단하고, 배란방광! 웹 스크래퍼가 한 대 캐시트가 됩니다. 그러면 그것을 설정한 사람이 자동 재시작을 추가하는 것을 잊었으면 바로 희망할 수 있습니다.\n\n그러나 프로세스는 반드시 충돌하지 않아도 됩니다. 그러나 다른 옵션도 재미있습니다:\n\n- 디스크에 저장하기(디스크가 가득 찰 때 결국 충돌할 것입니다!)\n- 대역폭 요금 부과(이에 대해 과금되는 경우)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n참고: 여러분이 사용 중인 연결이 미터링되는 경우나 대역폭이 제한되어 있는 경우에는 이를 권장하지 않습니다. 웹 스크레이핑 해커들보다 더 많은 것을 잃을 수 있으니까요!\n\n# 단계 2: 지옥에서 더 뜨겁게 달군다\n\n저는 HellPot을 사용하여 웹 스크레이퍼를 무너뜨리는 것을 정말 즐기는데, 전체 프로세스에 개인적인 접촉이 덜한 것 같아서 조금 아쉬웠어요. 제가 HellPot에 일부 기여를 했지만, Go는 제 첫 번째 언어가 아니었고, 원하는 기능이 부족했어요. 그렇다면 뭘 했을까요? 당연히 Rust로 다시 작성했죠.\n\n약간의 Rust 해킹 뒤에, 저는 crates.io에 pandoras_pot을 게시했어요. 기본 원칙은 같아요: 요청, 연결, 쿨레이드를 마시고, 무너뜨리기. 하지만 원하는 멋진 기능 몇 가지를 추가하는 자유도를 가져서 제가 원했던 기능을 더했어요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 성능이 더 좋아졌어요. 결국, Rust는 엄청나게 빠르고 안전해요!\n- 데이터를 생성하는 더 많은 방법이 있어요. 정적 파일을 계속해서 보내거나, 마르코프 체인 출력 대신 랜덤 문자열을 보내는 것도 좋아요 (마르코프 체인을 지원하는 내 마르코프 체인 라이브러리 markovish도 있어요).\n- 당신이 사용자로서 고통의 근원을 제공할 수 있어요. 니체를 좋아하지 않으세요? 칸트는 어떠세요? 어제의 신문? 삼 학년 때 크러쉬에게 보낸 사랑의 편지?\n- 건강 포트도 있어요. 이제 인스턴스 간에 활성 로드 밸런싱을 할 수 있어요. 이제 봇들은 러지안 룰렛을 할 수 있어요: 이들은 겸손한 출력을 가진 라즈베리 파이에 연결하거나, 심지어 가장 강력한 봇도 부술 수 있는 LED가 달린 게이밍 컴퓨터에 연결할 수 있어요. LED 몬스터가 오프라인이라면 로드 밸런서는 대신 Pi를 선택할 거에요!\n- 최대 동시 스트림 양 및 속도 제한과 같은 남용 방지 기능도 있어요.\n\n판도라스 팟을 반복해서 개선했더니, 이제 만족할만한 수준에 도달했다고 생각해요. 물론 여러분도 직접 시도해볼 수 있어요! README에는 전체 설정 가이드가 포함되어 있어요.\n\n![웹 스크랩러를 상대로 싸워 살인하려면](/assets/img/2024-05-23-FightingbackTurningtheTablesonWebScrapersUsingRust_0.png)\n\n# 단계 3: 밴으로 웹 서버 살인하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그래서 잘 되는 것 같았어요? 정말 좋았어요! 정말 많은 봇들이 데이터를 다운로드하는 것을 좋아하는 것으로 밝혀졌어요. 여기에 들어오는 연결의 멋진 그래프를 넣을 수 있던 곳이죠. 우리에게는 유용했던 점이지만, 결국 3년 전 식료품점 주차장에서 산 쓰레기 e-머신이 웹 서버로 사용되고 있던 것이 움직이는 밴 안에서의 여정을 즐기지 못했다는 사실을 깨달았어요. 누가 그런걸 예상했을까요? 제 정신을 회복할 수 있을 것 같지만, 하드 드라이브는 물리적으로 회복할 수 없을 것 같아요. 그리고 아니요, 저는 접속 로그를 백업하지 않았어요. 저장 공간을 절약하기 위해서 소실될 리 없는 것에 대해서만 백업을 예약했거든요.\n\n하지만 몇 가지 스크린샷과 관찰 결과가 있어요! 다음은 전에 pandoras_pot으로부터의 연결을 나열하기 위해 만든 (매우 빠르고 더러운) 통계 페이지의 스크린샷이에요:\n\n![이미지](/assets/img/2024-05-23-FightingbackTurningtheTablesonWebScrapersUsingRust_1.png)\n\n우선, 대부분의 연결은 공용 클라우드 제공업체에서 온 것이에요. 트래픽의 많은 부분이 Tor 네트워크를 통해 전송되었다고 의심했지만, 가장 많은 트래픽을 소비하는 IP 주소들 확인 결과 그 중 아무것도 Tor 네트워크로 연결되지 않았어요. 일부는 스스로 “비공개”이고 “익명”이라고 자처하는 클라우드 제공업체에서 왔어요. 아마도 NSA의 허니팟일 수도 있고, 진짜일 수도 있어요. 여기에서 링크하지는 않을 거에요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n또 다른 흥미로운 관찰은 많은 연결 다운로드 용량이 2GB, 3GB 또는 0.5GB와 같은 좋은 숫자 부근에 끝나는 것입니다. 봇들이 이를 다운로드 제한으로 설정한 것일 수 있지만, 이를 높게 설정한 이유는 없습니다. 아마도 이것은 클라우드 제공 업체의 메모리 한도일 수도 있습니다. 대형 클라우드 제공 업체 중 하나를 확인하면 RAM이 가격 결정 요소 중 하나인 것을 볼 수 있으며, 이들은 주로 이와 같은 깔끔한 짝수로 제공됩니다. 나는 단순히 봇들이 '청춘의 슬픔'에서 텍스트로 메모리를 모두 채워서 충돌하고, 그 후에 희망적으로 보다 깨달은 개인이 되는 프로세스라고 생각합니다.\n\n또한 많은 봇들이 30초의 시간제한을 가지고 있음을 알았는데, 성능에 초점을 맞추는 것은 합리적입니다. pandoras_pot은 30초 안에 일부 봇을 충돌시키기 위해 노력해야 합니다. 이는 완전히 불가능한 일이 아닙니다. 인터넷 연결 및 하드웨어에 따라 100MB/s 이상의 속도에 도달하는 것이 쉽게 가능하기 때문입니다 (이는 토스터기 또는 주전자와 비슷한 성능을 가진 옛날 e-machine에서 수행된 것이며, 훨씬 높은 속도로 진행될 수 있습니다). 암호화 및 압축이 큰 영향을 미친다는 점을 주목해야 합니다. 압축에 대해 언급하자면, 악의적인 요청에 Zip 폭탄으로 응답하는 사람들이 있는 것으로 보입니다. 아마도 향후 기능일지도 모릅니다?\n\n# 단계 4: 미래를 위한 아이디어\n\n자, 재미있었죠. 이제 대부분 잘못 구성된 웹사이트에 접속하는 봇들을 충돌시킬 수 있습니다. 그러나 더 나아갈 수 있을까요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nContact Us란 상자를 웹사이트에 넣어 본 적이 있는 사람은 늘 reCAPTCHA를 통과하는 일부 봇이 있다는 것을 알 것입니다 (특히 구현 시에 절약을 한다면). 그런데, \"제출\" 버튼은 단지 서버로 요청을 보내는 것뿐이죠. 다른 곳으로 향한다면 안타까울 테니까요...\n\n의심스러운 트래픽을 재설정하는 것도 가능합니다. AbuseIPDB에서 들어오는 요청을 즉시 재지정하는 방법은 어떨까요?\n\n참고: IP 주소를 맹목적으로 재지정하지 마세요. 어떤 사람들은 무료 인터넷에 액세스하려면 Tor가 필요합니다. 또 다른 사람들은 ISP로부터 다른 사람들과 공용 주소를 공유하도록 강요받습니다.\n\n# 결론\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n웹사이트를 설정할 때 많은 사람이 방문할 것입니다. 그 중 대부분은 사람이 아닙니다. 대부분은 무해하지만 실제로 .env 파일을 공개 웹사이트에 포함시켰다면 곤란한 상황에 처할 수도 있습니다.\n\n어떤 사람들은 더 나은 봇을 만들어 pandoras_pot을 탐지할 수 있다고 지적할 수 있습니다. 이는 사실이지만, 그렇게까지 해야 할 필요가 있을까요? Pandora_pot을 사용하지 않는 사람들에게 조금 농담을 치는 것이 어떨까요? 여기서 우리가 장점을 가지고 있습니다: pandoras_pot은 구성을 사용하여 응답의 모양을 변경할 수 있습니다. 이것은 코드에서 탐지하는 것보다 훨씬 쉽습니다. 다른 사람들도 pandoras_pot을 사용하여 자신만의 구성을 만든다면 피하는 것이 어려워집니다.\n\n요약하자면: 친절하게 대해주세요, /robots.txt를 존중해주세요, 그렇지 않으면 영원한 결과를 받게 될 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-05-23-FightingbackTurningtheTablesonWebScrapersUsingRust_0.png"},"coverImage":"/assets/img/2024-05-23-FightingbackTurningtheTablesonWebScrapersUsingRust_0.png","tag":["Tech"],"readingTime":8},{"title":"HTTP 파라미터 오염을 통한 오픈 리다이렉트","description":"","date":"2024-05-23 18:46","slug":"2024-05-23-Open-RedirectThroughHTTPParameterPollution","content":"\n안녕하세요 여러분, 어떠세요?\n\n제 친구\nSaigo\n의 요청으로, 예전에 신고한 Open-Redirect에 대한 설명을 작성 중입니다. 실제로 큰 영향을 미치지는 않았지만요.\n\n![Open-Redirect](/assets/img/2024-05-23-Open-RedirectThroughHTTPParameterPollution_0.png)\n\n# 버그 발견\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저번 글에서 오픈 리다이렉션에 대해 설명한 적이 있죠. 그럼 바로 실습으로 넘어가 보겠습니다. 테스트할 대상은 redacted.com이라고 지칭하겠습니다. 로그인 URL의 next 파라미터에 절대 URL이 전달되고 있다는 점을 발견했습니다:\n\n```js\nhttps://redacted.com/login.php?next=https://redacted.com/account.php\n```\n\n처음에는 next 파라미터를 http://evil.com으로 변경해 보았지만 실패했어요. 그래서 HTTP 파라미터 오염을 테스트하기로 결정했습니다. PHP로 구축된 사이트였기 때문에 파라미터의 마지막 등장이 일반적으로 우선권을 가집니다. 따라서 제가 만든 최종 URL은 다음과 같습니다:\n\n```js\nhttps://redacted.com/login.php?next=https://redacted.com/account.php?next=http://evil.com\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n로그인 후 http://evil.com으로 성공적으로 리디렉션되었습니다.\n\n감사합니다!\n","ogImage":{"url":"/assets/img/2024-05-23-Open-RedirectThroughHTTPParameterPollution_0.png"},"coverImage":"/assets/img/2024-05-23-Open-RedirectThroughHTTPParameterPollution_0.png","tag":["Tech"],"readingTime":2},{"title":"자바스크립트 파일 분석으로 여러 버그를 발견하는 방법","description":"","date":"2024-05-23 18:45","slug":"2024-05-23-HowAnalyzingJavaScriptFilesCanUncoverMultipleBugs","content":"\n![image](/assets/img/2024-05-23-HowAnalyzingJavaScriptFilesCanUncoverMultipleBugs_0.png)\n\nالسَّلاَمُ عَلَيْكُمْ وَرَحْمَةُ اللهِ وَبَرَكَاتُه\n\nPeace be upon you, and the mercy of Allah, and His blessings\n\nHello World !\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n4월 2일, 특정 타겟 BBP에 대한 정찰을 시작했어요. 유감스럽게도 이 글을 쓰는 시점까지 그들은 공개 공개 요청에 대답하지 않았습니다. 그래서 나는 그것을 '삭제됨'이라고 부를 것이에요.\n\n나는 주요 도메인을 선택했어요. 그 곳은 게시물 작성, 댓글 남기기, 그리고 플랫폼 내에서 사용자에게 메시지 보내기와 같은 기능을 갖춘 소셜 웹사이트였어요. 그리고 수동 테스트를 시작했어요.\n\n프로세스 중 어느 시점에서 메인 JS 파일로 이동하여 로컬로 다운로드했어요. 아마 뭔가 발견할 수 있을 것 같아서 그 파일을 읽어보기 위해서 말이에요!\n\nJS 코드가 약 220k 라인이었는데, 그냥 \"아니, 내가 이겨.\"라고 생각했어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Image](/assets/img/2024-05-23-HowAnalyzingJavaScriptFilesCanUncoverMultipleBugs_1.png)\n\n당연히 전체를 다 읽을 생각은 없었습니다 (아닌 걸까요?). 그 대상의 버그를 찾아 큰 회사나 공개 버그 바운티 프로그램에서 버그를 발견하는 두려움을 극복하기로 했습니다.\n\n그래서 나는 JS 파일을 정신적으로 섹션으로 나누었습니다. 매일 웹사이트를 수동으로 테스트하고 지루해지면 JS 파일의 일부를 읽어 나가기로 했습니다.\n\n그 결과 그 대상에 대한 몇 개의 서브도메인 코드를 발견할 수 있었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nvar i = t(97871),\n        e = t(42868),\n        g = t(20737),\n        _ = t(38717),\nfunction f(s, r) {\n            (this.appService = s),\n              (this.responseService = r),\n              (this.clientDomains = {\n                1111: [\n                  \"webqa.redacted.com\",\n                  \"localhost:4200\",\n                  \"localhost:4000\",\n                ],\n                \"32 chars id smth idk fr!\": [\n                  \"qc-dashboard.rs.zz.redacted.com\",\n                  \"domain-website-something.redacted.com\",\n                ],\n                \"something-Redacted\": [\n                  \"place-dashboard.website.domain.redacted.com\",\n                  \"employee-site-testing.redacted.com\",\n                ],\n              });\n```\n\n이 중에서 webqa Redacted com만 작동 중이었습니다. 그것은 웹 품질 보증 사이트였습니다. 원래 테스트하던 사이트의 복제본이었지만 프로덕션 웹 사이트에 라이브로 이동하기 전에 테스트 중인 몇 가지 새로운 기능이 포함되어 있었습니다. 코드 기반은 거의 동일했습니다. 추가 탐색을 위해 주요 JS 파일을 다운로드했지만 차이가 거의 없었습니다.\n\n스테이징 사이트의 사이트맵에서 흥미로운 사실을 알게 되었습니다. 그들이 아마도 테스트하고 있는 보안 문제에 대한 참조 번호가 포함되어 있었습니다.\n\n<img src=\"/assets/img/2024-05-23-HowAnalyzingJavaScriptFilesCanUncoverMultipleBugs_2.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그러한 환경에서는 개발자들이 중요한 버그를 테스트할 가능성이 높아지며, 공격자에게 기회의 창을 제공할 수 있습니다. 공격자는 웹 사이트를 모니터링하여 심각한 버그가 스테이징 환경에 도입될 때까지 기다린 다음 해당 버그를 프로덕션 웹 사이트에서 잠재적으로 악용할 수 있습니다.\n\n저는 모니터링할 수 있지만 중복되지 않을까 생각했습니다.\n\n\"(당신이 아니라면 다른 사람이 보고할 수도 있습니다)\"\n\n저는 CVSS 3.1로 높은 중요도로 보고했습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n테이블 태그를 Markdown 형식으로 변경해주세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n테이블 태그를 마크다운 형식으로 변경해주세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nX/Twitter에서 저를 팔로우하세요: [https://twitter.com/L0daW](https://twitter.com/L0daW)\n","ogImage":{"url":"/assets/img/2024-05-23-HowAnalyzingJavaScriptFilesCanUncoverMultipleBugs_0.png"},"coverImage":"/assets/img/2024-05-23-HowAnalyzingJavaScriptFilesCanUncoverMultipleBugs_0.png","tag":["Tech"],"readingTime":5}],"page":"53","totalPageCount":113,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":2},"__N_SSG":true}