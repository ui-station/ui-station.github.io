{"pageProps":{"posts":[{"title":"데이터 레이크하우스를 위한 엔드 투 엔드 데이터 엔지니어링 Airflow, Minio, Kafka, Apache Spark, Apache Flink, 그리고 Elasticsearch  PART 2","description":"","date":"2024-05-18 16:15","slug":"2024-05-18-EndtoEndDataEngineeringforDataLakehousewithAirflowMinioKafkaApacheSparkApacheFlinkandElasticsearchPART2","content":"\n<img src=\"/assets/img/2024-05-18-EndtoEndDataEngineeringforDataLakehousewithAirflowMinioKafkaApacheSparkApacheFlinkandElasticsearchPART2_0.png\" />\n\n지난 섹션에서는 데이터 레이크하우스에 대한 중요한 세부 정보, 즉 무엇, 어떻게, 왜 현대 데이터 엔지니어링에서 중요한지에 대해 논의했습니다. 놓치셨다면 여기에서 확인할 수 있어요!\n\n이번 섹션에서는 이번 시리즈 전체를 통해 작업할 시스템의 아키텍처에 대해 논의할 예정입니다.\n\nAWS를 사례로 현대 데이터 엔지니어링과 클라우드를 활용한 경우, 몇 가지 액터가 S3 버킷에 데이터를 넣어 처리를 시작하고 복잡한 분석을 개발할 수 있습니다. 그러나 이 인프라를 계속 사용할수록 상황이 약간 모호해질 수 있고 비용 문제가 커질 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 아키텍처를 좀 더 자세히 살펴봐요; Airflow, Python, Java 또는 파일 업로드와 같은 몇 가지 액터들이 데이터를 Bronze 레이어/저장소에 저장해요. S3 버킷에 데이터를 업로드하는 것은 본질적으로 무료이기 때문에 이는 비용이 전혀 들지 않아요.\n\n![architecture](/assets/img/2024-05-18-EndtoEndDataEngineeringforDataLakehousewithAirflowMinioKafkaApacheSparkApacheFlinkandElasticsearchPART2_1.png)\n\n비디오 워크스루에 관심 있는 분들은 여기를 따라 갈 수 있어요:\n\n더 흥미로운 점은 이러한 서비스 위에 구축된 추가 서비스들의 사용이에요. AWS Glue Crawler와 같은 서비스가 여기에 속하며, 데이터 파일을 구조화된 데이터베이스와 테이블로 변환하는 데 사용돼요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n크롤러를 만든 후에는 두 가지 주요 옵션이 있습니다. 특정 간격에서 크롤러를 실행하도록 예약하거나 수동으로 계속해서 트리거하는 것입니다.\n\nAWS 문서에 따르면 AWS Glue 작업의 최소 예약 시간은 5분이며, 이는 더 낮은 대기 시간 처리 요구사항이 있을 경우 도착 시 목적이 무산되는 것을 의미합니다. 안타깝지만!\n\n![이미지](/assets/img/2024-05-18-EndtoEndDataEngineeringforDataLakehousewithAirflowMinioKafkaApacheSparkApacheFlinkandElasticsearchPART2_2.png)\n\n그러나 기다려보세요, 탈출할 수 있는 방법이 있습니다...맞습니다, AWS Lambda입니다! Lambda는 크롤러를 트리거하거나 처리를 자체적으로 처리함으로써 도움을 주는 다양한 기능을 제공할 수 있으며, 이로 인해 아래 아키텍처로 이어집니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-05-18-EndtoEndDataEngineeringforDataLakehousewithAirflowMinioKafkaApacheSparkApacheFlinkandElasticsearchPART2_3.png\" />\n\n음... 이 문제를 해결하면서 또 다른 흥미로운 비용 측면이 발생했네요! 람다 및 첫 해 동안의 무료 티어(첫 해에 대한 요금 면제)에서 사용된 컴퓨팅 시간에 대해 요금이 부과되지만, 함수에 대한 첫 1백만 요청은 무료이며 그 이후 요청에 대해서는 요청 당 0.0000002달러가 청구됩니다. 이 가격은 여러 함수가 여러 버킷에 대해 실시간 변환을 수행하고 있을 때는 이상적으로 보이지만, 그런 경우에는 그렇게 저렴해 보이지 않습니다.\n\n데이터 레이크하우스 아키텍처에 대해 자세히 이야기하기 전에 현재 구현이 실제로 어떻게 보이는지 살펴보겠습니다.\n\n# S3 버킷 설정\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nAWS 계정이 있으면 검색 메뉴에서 S3를 검색하고 선택한 지역에 S3 버킷을 만들면 됩니다. 저는 버킷 이름으로 codewithyu를 선택했습니다.\n\n![image](/assets/img/2024-05-18-EndtoEndDataEngineeringforDataLakehousewithAirflowMinioKafkaApacheSparkApacheFlinkandElasticsearchPART2_4.png)\n\n생성 후에는 버킷에 파일을 업로드하고 Glue Crawler를 생성하여 파일을 처리할 수 있습니다. 버킷에 taxi_project라는 이름의 폴더를 만들어 파일을 업로드할 것입니다.\n\n![image](/assets/img/2024-05-18-EndtoEndDataEngineeringforDataLakehousewithAirflowMinioKafkaApacheSparkApacheFlinkandElasticsearchPART2_5.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# AWS Glue을 사용하여 데이터베이스 및 테이블 생성하기\n\n택시 프로젝트에서 파일 업로드를 완료하면 다음 단계는 AWS Glue로 이동하여 새 크롤러를 추가하는 것입니다.\n\n![image](/assets/img/2024-05-18-EndtoEndDataEngineeringforDataLakehousewithAirflowMinioKafkaApacheSparkApacheFlinkandElasticsearchPART2_6.png)\n\n해야 할 일은 크롤러에 이름을 지정하고 데이터 원본을 선택하고 출력을 데이터베이스로 설정하는 것뿐입니다 (데이터베이스가 없는 경우 생성할 수 있는 옵션이 있습니다). 그럼 테이블이 자동으로 채워질 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![image](/assets/img/2024-05-18-EndtoEndDataEngineeringforDataLakehousewithAirflowMinioKafkaApacheSparkApacheFlinkandElasticsearchPART2_7.png)\n\n![image](/assets/img/2024-05-18-EndtoEndDataEngineeringforDataLakehousewithAirflowMinioKafkaApacheSparkApacheFlinkandElasticsearchPART2_8.png)\n\n![image](/assets/img/2024-05-18-EndtoEndDataEngineeringforDataLakehousewithAirflowMinioKafkaApacheSparkApacheFlinkandElasticsearchPART2_9.png)\n\nFinally, here are the full properties of the crawler:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![screenshot 1](/assets/img/2024-05-18-EndtoEndDataEngineeringforDataLakehousewithAirflowMinioKafkaApacheSparkApacheFlinkandElasticsearchPART2_10.png)\n\n스크린샷에서 볼 수 있듯이, 출력 및 스케줄링에서는 출력이 \"On Demand\"로 설정되어 있습니다. 특정 간격에서 작업을 실행하려는 경우 CRON 표현식을 사용해야 합니다 (자세한 내용은 crontab.guru를 방문하세요).\n\n이 단계가 완료되면 다음으로 크롤러를 실행해야 합니다.\n\n![screenshot 2](/assets/img/2024-05-18-EndtoEndDataEngineeringforDataLakehousewithAirflowMinioKafkaApacheSparkApacheFlinkandElasticsearchPART2_11.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# AWS Lambda 통합\n\n크롤러를 성공적으로 만들고 완료까지 성공적으로 실행했으므로, 다음 단계는 버킷에 새 파일이 업로드될 때 크롤러를 트리거하는 것입니다. 이를 달성하는 두 가지 방법이 있습니다. 하나는 AWS Lambda 자체를 통해이를 수행하는 것이고, 다른 하나는 S3를 통해 수행하는 것입니다.\n\n## AWS Lambda 통합 — Lambda\n\nLambda를 통해 이를 통합하려면 Lambda 서비스로 이동하고 새 함수를 생성해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래와 같이 표 태그를 마크다운 형식으로 변경해주세요.\n\n<img src=\"/assets/img/2024-05-18-EndtoEndDataEngineeringforDataLakehousewithAirflowMinioKafkaApacheSparkApacheFlinkandElasticsearchPART2_12.png\" />\n\n이 작업을 완료하려면 함수를 생성한 후 해당 람다 함수에 부여해야 할 권한을 추가해야 합니다.\n\n<img src=\"/assets/img/2024-05-18-EndtoEndDataEngineeringforDataLakehousewithAirflowMinioKafkaApacheSparkApacheFlinkandElasticsearchPART2_13.png\" />\n\n권한을 부여하려면 설정 탭으로 이동하여 필요한 권한을 선택하실 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![image1](/assets/img/2024-05-18-EndtoEndDataEngineeringforDataLakehousewithAirflowMinioKafkaApacheSparkApacheFlinkandElasticsearchPART2_14.png)\n\nIn my case, I have added `AmazonS3FullAccess` and `AWSGlueConsoleFullAccess` permissions to the role attached to the function.\n\n![image2](/assets/img/2024-05-18-EndtoEndDataEngineeringforDataLakehousewithAirflowMinioKafkaApacheSparkApacheFlinkandElasticsearchPART2_15.png)\n\n## Writing the Lambda Function Code\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n체크리스트가 거의 완성되어서, 다음 단계는 S3 버킷에서 PUT 이벤트가 발생할 때 트리거될 람다 코드를 작성하는 것입니다.\n\n우리의 경우, 복잡한 변환 작업을 수행하지 않고 감지된 이벤트마다 크롤러를 실행하는 것이 필요합니다.\n\n```js\nimport json\nimport boto3\n\n# AWS 클라이언트 초기화\nglue = boto3.client('glue')\ns3 = boto3.client('s3')\n\ndef lambda_handler(event, context):\n    # S3 이벤트에서 버킷 이름과 파일 키 가져오기\n    bucket_name = event['Records'][0]['s3']['bucket']['name']\n    file_key = event['Records'][0]['s3']['object']['key']\n\n    # Glue 크롤러 이름 지정\n    crawler_name = 'taxi_crawler'\n\n    # Glue 크롤러 시작\n    try:\n        response = glue.start_crawler(Name=crawler_name)\n        print(f'Glue 크롤러 {crawler_name}이(가) 성공적으로 시작되었습니다.')\n    except Exception as e:\n        print(f'Glue 크롤러 {crawler_name} 시작 중 오류 발생: {e}')\n        raise e\n```\n\n이 함수를 Test 및 새 이벤트 생성을 선택하여 테스트할 수 있습니다. 템플릿에서 S3 아래 putTestEvent를 선택하면 다음과 같은 템플릿이 나타납니다. 버킷 이름 및 폴더를 나의 S3 버킷 및 폴더에 연결하도록 이름을 업데이트했습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```json\n{\n  \"Records\": [\n    {\n      \"eventVersion\": \"2.0\",\n      \"eventSource\": \"aws:s3\",\n      \"awsRegion\": \"us-east-1\",\n      \"eventTime\": \"1970-01-01T00:00:00.000Z\",\n      \"eventName\": \"ObjectCreated:Put\",\n      \"userIdentity\": {\n        \"principalId\": \"EXAMPLE\"\n      },\n      \"requestParameters\": {\n        \"sourceIPAddress\": \"127.0.0.1\"\n      },\n      \"responseElements\": {\n        \"x-amz-request-id\": \"EXAMPLE123456789\",\n        \"x-amz-id-2\": \"EXAMPLE123/5678abcdefghijklambdaisawesome/mnopqrstuvwxyzABCDEFGH\"\n      },\n      \"s3\": {\n        \"s3SchemaVersion\": \"1.0\",\n        \"configurationId\": \"testConfigRule\",\n        \"bucket\": {\n          \"name\": \"codewithyu\",\n          \"ownerIdentity\": {\n            \"principalId\": \"EXAMPLE\"\n          },\n          \"arn\": \"arn:aws:s3:::codewithyu\"\n        },\n        \"object\": {\n          \"key\": \"taxi_test/filename.parquet\",\n          \"size\": 1024,\n          \"eTag\": \"0123456789abcdef0123456789abcdef\",\n          \"sequencer\": \"0A1B2C3D4E5F678901\"\n        }\n      }\n    }\n  ]\n}\n```\n\n작업을 완료한 후에는 호출을 선택하고 크롤러가 실행 중인지 확인하세요. 이제 크롤러가 실행되기 시작했을 것으로 예상됩니다.\n\n## S3와 Lambda 연결\n\nLambda를 S3에 연결하려면 Configuration 및 Trigger를 클릭하고 Add Trigger를 선택하여 새 트리거를 추가할 수 있습니다. taxi_project/ 접두사를 추가하는 것을 잊지 마세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Image 1](/assets/img/2024-05-18-EndtoEndDataEngineeringforDataLakehousewithAirflowMinioKafkaApacheSparkApacheFlinkandElasticsearchPART2_16.png)\n\nOnce done, click Add and you're all set!\n\n![Image 2](/assets/img/2024-05-18-EndtoEndDataEngineeringforDataLakehousewithAirflowMinioKafkaApacheSparkApacheFlinkandElasticsearchPART2_17.png)\n\nOnce a file is uploaded to the taxi_project folder, the taxi_crawler should be automatically triggered.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음 기사에서는 비용 효율적인 새로운 데이터 레이크하우스 아키텍처를 살펴볼 것입니다.\n\n# 그리고 마지막으로!\n\n아래 주제 중에 관심 있는 주제가 있다면:\n\n- Python\n- 데이터 엔지니어링\n- 데이터 분석\n- 데이터 과학\n- SQL\n- 클라우드 플랫폼 (AWS/GCP/Azure)\n- 기계 학습\n- 인공 지능\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n모든 플랫폼에서 제 프로필을 좋아하고 팔로우해 주세요:\n\n- Github: airscholar\n- Twitter: @YusufOGaniyu\n- LinkedIn: Yusuf Ganiyu\n- Youtube: CodeWithYu\n- Medium: Yusuf Ganiyu\n\nLinkedIn, X, Medium 및 YouTube에서 매일 컨텐츠를 정기적으로 공유하고 있어요.\n\n데이터 엔지니어링 여정을 가속화하려면 Data Mastery Lab를 꼭 확인해 주세요!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n안녕하세요! 제 미디엄 팔로우를 통해 저와 소통해주세요:\n\n# Stackademic 🎓\n\n끝까지 읽어주셔서 감사합니다. 떠나시기 전에:\n\n- 좋아요도 눌러주시고 작가를 팔로우해주세요! 👏\n- 다음 링크를 통해 팔로우할 수 있습니다: X | LinkedIn | YouTube | Discord\n- 다른 플랫폼도 방문해보세요: In Plain English | CoFeed | Venture | Cubed\n- 알고리즘 콘텐츠를 다루는 블로깅 플랫폼에 지쳤나요? Differ를 시도해보세요\n- Stackademic.com에서 더 많은 콘텐츠를 확인할 수 있습니다\n","ogImage":{"url":"/assets/img/2024-05-18-EndtoEndDataEngineeringforDataLakehousewithAirflowMinioKafkaApacheSparkApacheFlinkandElasticsearchPART2_0.png"},"coverImage":"/assets/img/2024-05-18-EndtoEndDataEngineeringforDataLakehousewithAirflowMinioKafkaApacheSparkApacheFlinkandElasticsearchPART2_0.png","tag":["Tech"],"readingTime":13},{"title":"서버리스 애플리케이션을 효과적으로 테스트하세요","description":"","date":"2024-05-18 16:11","slug":"2024-05-18-Effectivelytestyourserverlessapplications","content":"\n서버리스로 이동하는 것은 다른 종류의 아키텍처와 마찬가지로 장단점이 있습니다. 클라우드에 코드만 전달하고 서버를 사용자로부터 추상화하는 아이디어는 몇몇 사람들에게 게임 체인저가 될 수 있습니다. 그러나 이 비교적 새로운 종류의 기술은 대면에서 많은 놀라운 기능을 제공하지만 그 함의는 상당합니다.\n\nAWS에서 서버리스 솔루션을 구현해보기 시작하는 모든 개발자의 가장 핵심적인 질문은 이것입니다:\n\n![이미지](/assets/img/2024-05-18-Effectivelytestyourserverlessapplications_0.png)\n\nExpress 또는 Django와 같은 서버풀 프레임워크로부터 API를 작성하는 전통적인 배경에서 온 백엔드 개발자라면, nodemon, python manage.py runserver 또는 개발 프로세스 중에 컨테이너 볼륨을 활용한다면 docker-compose up -d와 같은 해당하는 핫 리로딩 기능에 익숙할 것입니다. 그러나 서버리스에서는 전통적인 백엔드의 개발자 경험을 완전히 포괄하거나 유사한 핫 리로딩 기능이 없다는 것을 알 수 있을 겁니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n서버리스 솔루션을 구현하는 주요 이유 중 하나는 서버리스가 클라우드에 구축되기 때문에 개발자들에게 다소 독특한 경험을 제공한다는 것입니다. AWS Lambda 및 AWS의 모든 다른 서버리스 서비스들은 로컬 환경이 아닌 클라우드에서 최적의 작동을 합니다. 그러나 이러한 이념은 일부 사람들에게는 꽤 문제가 될 수 있습니다.\n\n그렇고 그렇지 않습니다. 서버리스에서는 클라우드에서 자체적인 순간적인 환경을 만들 수 있는 능력을 가지고 있습니다. 클라우드 컴퓨팅의 일반적인 요금 체계는 사용한 만큼만 지불해야 한다는 것입니다. 그러나 서버리스에서는 일정한 범위내에서 이는 사실이지만, 더 정확히 말하면 요금 체계를 정의하는 것은 최종 사용자가 사용한만큼만 지불해야 한다는 것입니다. 따라서, 서버리스의 요금 체계를 통해 클라우드에서 환경을 생성하고 소멸시킬 때 비용이 거의 발생하지 않습니다.\n\n클라우드에 자체 개발 환경을 배포할 수 있는 것은 제품 환경을 모방하는 데 매우 유리합니다. 그러나 여전히 모든 코드 변경마다 배포해야 한다는 것이 거부 사항으로 느껴질 수 있습니다. Serverless Framework나 AWS CDK와 같은 기존 IaC(Infrastructure as Code) 솔루션에서 서버리스를 사용하고 있다면, 가장 짜증나는 피드백 루프에 익숙할 지도 모릅니다.\n\n위에서 언급한 대로 클라우드에 임시 개발 환경을 배포하는 것은 코드가 예상대로 작동한다는 확신을 얻는 장점이 있습니다. 생산 환경으로 전송될 때의 동작도 마찬가지일 것입니다. 이 과정은 의심의 여지 없이 최적의 결과를 제공할 것이지만, 여전히 코드 변경마다 배포하고 각 개발자에게 클라우드 환경 접근을 허용해야 한다는 번거로움이 있습니다. 또한 각 배포는 애플리케이션의 크기에 따라 약 3~10분이 소요됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 느립고 번거로운 피드백 루프를 개선하기 위한 노력이 있었습니다. Serverless Framework의 서버리스 오프라인과 같은 기능은 로컬에서 API 게이트웨이 및 람다 함수를 에뮬레이트할 수 있게 해줍니다. 이 기능을 통해 개발 프로세스를 확실히 가속화할 수 있습니다. 그러나 이 기능은 API 게이트웨이 및 람다 함수를 에뮬레이트하는 데로 제한되어 있습니다. DynamoDB, SQS, SNS 또는 S3와 같은 다른 서버리스 서비스를 에뮬레이트할 수 있는 다른 플러그인들도 있지만, 이를 설정하려면 상당한 운영 오버헤드가 필요합니다. 현재의 로컬 에뮬레이터는 클라우드 환경을 완벽하게 모방할 수 없습니다. 로컬 환경은 생산 환경을 완벽하게 반영하지 못할 수 있어 동작 및 보안 구성에서 차이가 발생할 수 있습니다. 이 접근 방식은 \"내 컴퓨터에서는 작동하는데 실제 환경에서는 작동하지 않는다\"는 부정적인 결과를 가져올 수 있습니다.\n\n다른 예시로 AWS CDK의 cdk watch가 있습니다. AWS CDK는 완전히 단기적인 환경을 채택합니다. serverless offline 기능과 유사한 sam invoke local 같은 기능을 갖고 있지만, cdk watch는 로컬에서 Lambda 함수의 코드 변경 사항을 감지하고 해당 변경 사항만 배포합니다. 이 접근 방식은 피드백 루프를 완전히 새로 만들진 않지만 개발자 경험을 향상시킵니다. 서버리스 응용 프로그램 전체를 다시 배포하는 대신 코드가 변경된 Lambda 함수만 다시 배포하여 배포 속도를 높여줍니다(그러나 핫 리로딩만큼 빠르지는 않습니다). 그리고 터미널에서 스택내 Lambda 함수의 모든 CloudWatch 로그를 감시할 수 있습니다. AWS Management Console을 여는 번거로움 없이 콘솔에서 모든 로그를 확인할 수 있습니다.\n\n이 접근 방식은 우수한 개발자 경험과 최적의 결과를 위한 한 걸음입니다. 그러나 배포 대기 시간은 여전히 기존 백엔드와 비교했을 때 핫 리로딩만큼 빠르지 않아 전통적인 백엔드에 비해 여전히 생산성 저하 요인으로 여길 사람이 많습니다.\n\n서버리스 프레임워크나 AWS CDK와 같은 인프라스트럭처 코드 솔루션을 사용하는 것이 강력히 권고됩니다. 둘 중 하나를 선택하는 것은 크게 중요하지 않습니다. 이전 질문에 대한 대답으로, 코드 변경 시마다 재배포해야 할 경우, 이미 서버리스 프로젝트에서 이러한 IaC 솔루션을 사용하고 있다고 가정됩니다. 더 자세한 답변을 드리자면, 서버리스 응용 프로그램을 테스트하려면 여러분이 인프라 설정을 조정한 코드 변경마다 배포해야 하지만, Lambda 함수를 각 코드 변경마다 다시 배포할 필요가 없습니다. 이는 테스트를 통해 가능합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 서버리스 애플리케이션을 테스트해야 하는 이유\n\n서버리스 애플리케이션에 대한 테스트를 생성하는 것은 로컬에서 해당 애플리케이션을 실행하는 또 다른 방법입니다. 개발자 경험, 생산성 및 코드 확신 사이의 완벽한 균형을 제공합니다. 이렇게 하면 프로덕션 환경으로 코드를 전달할 때 코드 확신을 얻을 때 개발자 경험을 희생할 필요가 없게 됩니다. 두 마리 토끼를 모두 잡을 수 있습니다!\n\n여기서 소개할 테스트 유형은 \"remocal testing\"입니다. 로컬 코드(람다 함수 코드)를 원격/배포된 AWS 서비스와 테스트할 것입니다. 이는 일시적 환경의 사용과 동시에 로컬 코드 호출을 활용합니다. 따라서 제안하는 피드백 루프는 다음과 같습니다:\n\n일찍 봤을 때, 이전의 피드백 루프와 비교했을 때 큰 차이는 없습니다. 그러나 이 방법은 더 빠르며 동시에 로컬 코드가 클라우드에서 작동할 것임을 더 많은 코드 확신을 제공합니다. 왜 그런 걸까요? 클라우드에서의 배포 단계가 다른 단계보다 자주 실행되지 않기 때문입니다. 이 단계는 본래 람다 함수 이외에 필요한 서비스를 배포하는 것으로, 예를 들어 DynamoDB 테이블이나 S3 버킷과 같은 서비스가 있겠습니다. 그러고나면 다시, 우리의 로컬 코드는 클라우드에서 이러한 배포된 서비스들을 대상으로 테스트됩니다. 이는 프로덕션 환경에 더 가까운 근사치를 제공합니다. 최종적으로, 여러분이 자주 만나게 될 피드백 루프는 아래와 같을 것입니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 제안된 피드백 루프는 전통적인 백엔드와 매우 유사한 것이 아닌가요?\n\n로컬 코드가 작동하려면 기존 AWS 리소스에 의존하므로 전체 서버리스 애플리케이션을 배포해야 하는 경우는 다음과 같습니다:\n\n- 새로운 DynamoDB 테이블, S3 버킷 또는 람다 함수 이외에 필요한 서비스를 사용할 때.\n- 엔드 투 엔드 테스트를 수행할 준비가 된 경우.\n\n위 질문에 대한 답은 명백한 \"아니요\"입니다. 같은 것이 아니에요. 전체 서버리스 애플리케이션을 배포하는 데는 규모나 필요한 리소스의 수에 따라 5~10분이 걸릴 수 있습니다. 단일 람다 함수의 오타로 인해 다시 배포해야 할 경우를 상상해 보세요. 그럼 여러분은 변경 사항이 반영되고 함수의 동작을 테스트할 수 있도록 5~10분을 기다려야 합니다. 끔찍하죠? 반면 로컬 테스트는 실행되는 테스트의 양에 따라 최대 1분 정도 소요될 수 있어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n게다가, 전통적인 백앤드를 지원하는 핫 리로딩과 유사한 동작을 원한다면, Jest와 같은 현대 테스트 프레임워크는 이미 파일의 변경을 감시하고 상호작용하며 테스트를 실행하는 watch 모드를 갖고 있습니다. 따라서 로컬 람다 함수 코드에서 코드 변경이 발생하자마자, 테스트 프레임워크가 해당 코드 변경과 관련된 모든 테스트를 자동으로 실행합니다.\n\n# 구현해야 할 테스트 유형은 무엇인가요?\n\n![2024-05-18-Effectivelytestyourserverlessapplications_1.png](/assets/img/2024-05-18-Effectivelytestyourserverlessapplications_1.png)\n\n이 질문에 대한 대답은 특정 유형의 테스트가 여러분에게 제공하는 투자 수익에 따라 실제로 달려있습니다. 서버리스 시스템이나 아마도 다른 분산 시스템에서 가치가 큰 테스트 유형은 통합 테스트입니다. 위의 테스트 허니콤을 참조할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/assets/img/2024-05-18-Effectivelytestyourserverlessapplications_2.png)\n\n테스트의 양 또는 테스트 커버리지에 대해서는 얘기하지 않습니다. 중요한 것은 테스트가 어떤 투자 수익(Return of Investment)을 제공하는지입니다. 서버리스 유형의 아키텍처와 마이크로서비스를 촉진하는 경우, 통합 테스트를 구현하는 것이 더 많은 의미를 갖습니다. 왜냐하면 복잡성의 많은 부분이 람다 코드 외부에 존재하기 때문입니다. 마이크로서비스를 테스트하는 가장 좋은 방법은 코드가 다른 서비스와 상호 작용하는 방식을 테스트하는 것입니다.\n\n엔드투엔드 테스트는 애플리케이션 전체를 시작부터 끝까지 테스트합니다. 이는 최적의 수익을 제공하지만 실행하는 데 시간이 오래 걸리기 때문에 이러한 유형의 테스트의 투자 수익은 상당히 낮습니다. 반면, 유닛 테스트는 람다 함수의 도메인 로직을 처리할 수 있기 때문에 대부분 낮은 수익과 투자 수익을 제공할 것으로 예상됩니다. 유닛 테스트는 데이터베이스 레이어 및 다른 서비스와의 모든 상호 작용을 가짜로 만들어 가치를 거의 제공하지 않습니다.\n\n# 실전 예제\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-05-18-Effectivelytestyourserverlessapplications_3.png\" />\n\n다음 REST API를 구현하여 블로그 게시물과 해당 테스트를 생성해 봅시다. 이 예시에서는 Serverless Framework를 내 선택의 IaC로 사용했습니다. 따라서 동일하게 따라갈 수 있는 저장소는 여기에서 찾을 수 있습니다:\n\n## 사전 준비사항\n\n- AWS 프로필 구성: export AWS_PROFILE=`you-profile-name`\n- 의존성 설치: npm install\n- serverless 애플리케이션 배포: npm run sls -- deploy --stage `your-ephemeral-environment-name`. 꼭! `your-ephemeral-environment-name`을 본인의 임시 환경 이름으로 변경하지 않도록 주의해 주세요.\n- 당신만의 .env.`your-ephemeral-environment-name`을 생성하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음은 환경 파일의 형식이어야 합니다.\n\n```js\nAPI_BASE_URL = XXX;\nBLOG_POSTS_TABLE = XXX;\nAWS_REGION = XXX;\n```\n\n이러한 환경 변수의 값을 AWS Management Console 또는 Serverless Framework에서 제공하는 플러그인을 통해 얻을 수 있습니다.\n\n## 제안된 피드백 루프\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n테이블 태그를 마크다운 형식으로 변경하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 통합 테스트는 지역 Lambda 함수 코드(const handler = require(“@src/functions/createBlogPost).handler)를 가리키고 있습니다. 람다 함수가 클라우드에 배포된 것이 아닙니다. 따라서 우리가 통합 테스트를 실행할 때, 지역 람다 함수 코드가 실행되지만 그 모든 DynamoDB 작업은 클라우드의 DynamoDB 테이블로 전송됩니다. 이것은 원격 테스팅입니다. 여기서 지역 코드(이 경우 우리의 지역 람다 함수)가 원격/배포된 AWS 서비스(이 경우 DynamoDB 테이블)에 대해 테스트됩니다.\n\n다음은 통합 테스트를 실행하는 단계입니다:\n\n- export STAGE=`your-ephemeral-environment-name`. 이는 .env.`your-ephemeral-environment-name`을 참조하기 위함입니다.\n- npm run integration-test\n\n![테스트 이미지](/assets/img/2024-05-18-Effectivelytestyourserverlessapplications_4.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 Lambda 함수를 편집하고 싶다면, 얼마든지 해보세요! 블로그 게시물의 제목과 내용 이외에도 스니펫 필드와 같은 다른 필드를 저장할 수도 있습니다. 스니펫 필드는 내용의 처음 50자를 보여주거나 created_at 및 updated_at 필드를 추가할 수도 있습니다. 간단히 테스트를 다시 실행하여 코드 동작을 확인해보세요. 배포하고 3분에서 5분을 기다리지 않아도 코드 동작을 확인할 수 있습니다.\n\n게다가, 자신의 IDE에서 스텝 디버거를 사용해보는 것도 좋아요. 이것들은 서버리스 애플리케이션을 테스트하는 큰 장점 중 일부일 뿐입니다. 속도와 민첩성을 제공하여 Lambda 코드를 개발하고 향상된 생산성을 실현할 수 있습니다.\n\n## 통합 테스트의 주의사항\n\n통합 테스트는 우리가 원하던 속도와 생산성을 제공하지만, 전체 사용자 여정을 완전히 다루지는 못한다는 점을 유의해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 질문에 대한 답변은 전제 조건으로 수행한 단계 중 하나이며, AWS 프로필을 내보낼 때 수행한 요소 중 하나입니다. 로컬 람다 코드는 현재 AWS 프로필의 AWS 자격 증명을 가정합니다.\n\n네, 무서운 것 맞죠? 그래서 로컬 람다 코드 작성 시 주의해야 합니다. 그러나 우리가 로컬 람다 코드를 클라우드로 배포할 때는 이와 같은 경우가 아닙니다. 람다 함수는 항상 기본 실행 역할을 가정합니다. Serverless Framework는 이를 추상화하는 데 훌륭한 작업을 하지만, 여전히 Lambda 함수가 다른 서비스와 통신하려면 특정 권한을 추가해야 합니다. serverless.yml에서 람다 함수를 만드는 방법을 살펴보세요:\n\n```js\n## serverless.yml\n\n...\n\nfunctions:\n  createBlogPost:\n    handler: src/functions/createBlogPost.handler\n    environment:\n      BLOG_POSTS_TABLE: !Ref BlogPostsTable\n    iamRoleStatements:\n      - Effect: Allow\n        Action:\n          - dynamodb:PutItem\n        Resource: !GetAtt BlogPostsTable.Arn\n    events:\n      - httpApi: \"POST /blogposts\"\n\n...\n```\n\n만약 람다 함수에 dynamodb:PutItem 권한을 부여해야 한다는 것을 명시하지 않으면, 클라우드의 람다 함수가 지정된 DynamoDB 테이블에 PutItem 작업을 호출할 권한이 없다는 오류가 발생할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이는 우리의 통합 테스트에서 찾지 못한 것입니다. 그래서 우리는 엔드 투 엔드 테스트라는 다른 유형의 테스트를 시도합니다. 이 create blog post 기능의 엔드 투 엔드 테스트는 다음과 같습니다:\n\n```js\n// __tests__/test_cases/e2e/createBlogPost.test.ts\n\nrequire(\"dotenv\").config({\n path: `.env.${process.env.STAGE}`,\n});\nimport axios from \"axios\";\nconst chance = require(\"chance\").Chance();\n\ndescribe(\"When we call POST /blogposts\", () => {\n it(\"should create a new item\", async () => {\n  console.log(`API_BASE_URL: ${process.env.API_BASE_URL}`);\n\n  const title = chance.sentence({ words: 5 });\n  const content = chance.paragraph();\n  let response;\n\n  try {\n   response = await axios.post(\n    `${process.env.API_BASE_URL}/blogposts`,\n    {\n     title,\n     content,\n    },\n    {\n     headers: {\n      \"Content-Type\": \"application/json\",\n      Authorization: \"test\",\n     },\n    }\n   );\n  } catch (error: any) {\n   console.error(error);\n  }\n\n  expect(response).toBeDefined();\n\n  if (response) {\n   expect(response.status).toBe(201);\n   expect(response.data.data.title).toBe(title);\n   expect(response.data.data.content).toBe(content);\n  }\n });\n});\n```\n\n먼저, 엔드 투 엔드 테스트가 작동하려면 먼저 람다 함수를 클라우드에 배포해야 한다는 사실을 알아두는 것이 중요합니다. 위의 코드에서 보듯이, 클라우드의 람다 함수를 호출하는데 이 람다 함수의 API 엔드포인트를 통해 호출되며, 해당 엔드포인트는 POST /blogposts입니다. 로컬 람다 함수 코드가 아닙니다.\n\n다음은 우리의 e2e 테스트를 실행하는 단계입니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 애플리케이션을 배포하세요: npm run sls -- deploy --stage `당신의-임시환경이름`\n- export STAGE=`당신의-임시환경이름`. 이것은 .env.`당신의-임시환경이름`을 참조하기 위한 것입니다.\n- npm run e2e-test\n\n![효과적으로 서버리스 애플리케이션을 테스트하는 방법](/assets/img/2024-05-18-Effectivelytestyourserverlessapplications_5.png)\n\n엔드 투 엔드 테스트는 API가 제대로 작동하는지 확인하는 데 많은 가치를 줄 수 있습니다. 그러나 우리가 e2e 테스트에 의존하기만 한다면 생산성이 크게 감소할 것입니다. 왜냐하면 앞서 설명한대로 매 코드 변경마다 배포해야 하기 때문에 개발자 경험을 향상시키는 목적을 반감시키게 됩니다.\n\n# 다음 단계와 결론\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 예시를 보면 단위 테스트가 없다는 것을 알 수 있습니다. 신중한 고려 끝에, createBlogPost 람다 함수에 대한 단위 테스트를 만드는 것은 전혀 가치가 없다는 결론에 도달했습니다. 단순히 요청 본문을 가져와 해당 값을 데이터베이스에 저장하는 것뿐입니다. 그 안에 사용자 정의나 복잡한 로직이 전혀 없었기 때문입니다.\n\n그러나 우리 람다 함수의 이 코드 블록이 우리에게 단위 테스트를 작성해야 한다는 필요성을 알려준다고 주장할 수 있습니다:\n\n```js\n...\n\n const requestBody = JSON.parse(event.body || \"{}\");\n const title = requestBody.title;\n const content = requestBody.content;\n\n if (!title || !content) {\n  return {\n   statusCode: 400,\n   body: JSON.stringify({\n    message: \"Title and content are required\",\n   }),\n   headers: {\n    \"Content-Type\": \"application/json\",\n   },\n  };\n }\n\n...\n```\n\n그렇습니다, 제가 동의합니다. 이 코드 블록은 제목과 내용 필드가 없는지 확인하고 오류를 반환합니다. 이 코드 블록에 대한 단위 테스트를 작성하면 테스트 커버리지를 향상시킬 것이 확실합니다. 그러나 방금 전 언급했듯이 투자 수익에 관한 문제입니다. API Gateway 및 DynamoDB 테이블 관련 테스트가 즉시 필요한 \"블로그 글 작성\" 전체 구현의 다른 영역이 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n서버리스로의 전환은 특히 기존의 전통적인 단일 구조 모델에 익숙한 개발자들에게 중요한 패러다임 변화를 의미합니다. 확장 가능성, 비용 효율성 및 운영 효율성의 매력을 제공하면서도, 응용 프로그램이 디자인, 배포 및 관리되는 방식에 근본적인 변화를 요구합니다. 이 전환의 초기 단계는 상태 없는 컴퓨팅, 이벤트 주도 아키텍처 및 제3자 서비스 및 API 통합과 같은 복잡성을 다루면서 특히 어려울 수 있습니다. 이러한 급격한 학습 곡선은 필수적이며 학습 및 실험에 시간과 자원을 투자해야 합니다.\n\n서버리스 솔루션을 구현하려고 노력한 모든 사람들은 이러한 문제를 모두 경험했으며, 제 자신도 개발자 경험을 개선하기 위해 몇 달의 연구와 개발을 진행했습니다. 서버리스는 정말 아름답고 당연히 계속 사용될 것입니다. 특히 중소기업 (MSMEs)을 위한 서버리스는 비용 효율적인 인프라 유형일 수 있지만, 여전히 완전히 새로운 개발자 경험을 받아들일 수 있는 학습 곡선이 존재합니다.\n\n결론적으로, 초기 장벽에도 불구하고, 서버리스 아키텍처를 숙달하는 여정은 매우 보람 있을 수 있습니다. MSMEs의 경우, 확장성, 비용 절감 및 신속한 혁신 능력 측면에서 수익이 명백합니다. 기술이 성숙해지고 주변 커뮤니티가 성장함에 따라, 아마도 현재의 피드백 루프가 이러한 전환을 용이하게 만들고 동시에 현재의 개발자 경험을 향상시킬 수 있을지도 모릅니다. 따라서, 초기 도전은 중요하지 않더라도, 장기적으로는 서버리스 컴퓨팅의 혜택이 기업이 클라우드를 활용해 디지털 전환 계획을 추진하는데 매력적인 선택지로 만듭니다.\n","ogImage":{"url":"/assets/img/2024-05-18-Effectivelytestyourserverlessapplications_0.png"},"coverImage":"/assets/img/2024-05-18-Effectivelytestyourserverlessapplications_0.png","tag":["Tech"],"readingTime":16},{"title":"AWS CloudFormation을 활용한 간편한 CICD 배포 설정 설정","description":"","date":"2024-05-18 16:09","slug":"2024-05-18-StreamlinedAWSCICDDeploymentwithCloudFormation","content":"\n<img src=\"/assets/img/2024-05-18-StreamlinedAWSCICDDeploymentwithCloudFormation_0.png\" />\n\n# CI/CD란 무엇인가요?\n\nCI 및 CD는 지속적 통합(Continuous Integration) 및 지속적 전달/지속적 배포(Continuous Delivery/Continuous Deployment)를 의미합니다. CI/CD 파이프라인은 소프트웨어 전달 프로세스를 자동화하여 코드 빌드, 테스트 실행, 새로운 소프트웨어 버전의 안전한 배포와 같은 작업을 포함합니다. 자동화는 인적 오류를 줄이고 소프트웨어 릴리스 프로세스에서 일관성을 보장하기 위한 것입니다.\n\n# 시작하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 기사의 목표는 AWS를 사용하여 애플리케이션을 구축, 테스트 및 배포하는 과정을 실제 예제를 통해 안내하는 것입니다.\n\n다음은 배포하는 애플리케이션에 맞게 조정된 단계입니다. 구체적으로 Java Spring MVC 웹 애플리케이션 (Java 버전 17)입니다.\n\n사용된 AWS 서비스 -\n\n- EC2\n- S3\n- VPC\n- CodeCommit\n- CodeBuild\n- CodeDeploy\n- CodePipeline\n- CloudFormation\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# AWS 아키텍처 다이어그램\n\n![AWS Architecture Diagram](/assets/img/2024-05-18-StreamlinedAWSCICDDeploymentwithCloudFormation_1.png)\n\n# 시작해봅시다\n\n## 단계 1: CodeCommit\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nAWS CodeCommit은 사용자가 소스 코드 및 자산을 안전하고 확장 가능하게 저장, 관리 및 버전 관리할 수 있도록 하는 AWS의 관리형 소스 제어 서비스입니다. 이는 GitHub이 하는 것과 마찬가지로 작동합니다.\n\n![이미지](/assets/img/2024-05-18-StreamlinedAWSCICDDeploymentwithCloudFormation_2.png)\n\n## 단계 2: AWS IAM에서 git 자격 증명 설정하기.\n\n‘AWS CodeCommit을 위한 HTTPS Git 자격 증명’ 섹션에서 ‘자격 증명 생성’을 클릭하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n더 나아가, 이 자격 증명을 다운로드하고, Git 자격 증명을 입력하라는 메시지가 표시됩니다. 앞서 다운로드한 사용자 이름과 비밀번호를 입력하세요.\n\n## 3단계: 프로젝트를 CodeCommit 저장소에 커밋하십시오\n\n저장소를 복제할 디렉터리로 이동합니다. 다음 명령을 실행하세요:\n\n```js\ngit clone <your-codecommit-repo-clone-https-url>\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n로컬 브랜치에서 CodeCommit 리포지토리로 변경 사항을 푸시하려면 다음 명령을 사용하세요:\n\n```js\ngit push origin master\n```\n\nCodeCommit 리포지토리로 변경 사항이 제대로 푸시되었는지 확인해주세요.\n\n![이미지](/assets/img/2024-05-18-StreamlinedAWSCICDDeploymentwithCloudFormation_3.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 단계 4: S3 버킷 생성\n\n버킷 이름을 입력하고 버킷을 생성하고자 하는 지역을 선택하십시오. 이 버킷에 대한 블록 공개 액세스 설정 섹션에서 모든 공개 액세스 차단 상자를 해제하십시오. 다른 설정은 그대로 두고 '버킷 만들기'를 클릭하여 버킷을 생성하십시오.\n\n![이미지](/assets/img/2024-05-18-StreamlinedAWSCICDDeploymentwithCloudFormation_4.png)\n\n버킷이 성공적으로 생성되었는지 확인하십시오.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Step 5: CodeBuild](/assets/img/2024-05-18-StreamlinedAWSCICDDeploymentwithCloudFormation_5.png)\n\nAs you can see our S3 bucket has been successfully created. Now, let’s dive into our AWS CodeBuild service\n\n![Step 5: CodeBuild](/assets/img/2024-05-18-StreamlinedAWSCICDDeploymentwithCloudFormation_6.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nAWS CodeBuild 서비스로 이동하여 아래와 같이 빌드 프로젝트를 생성하세요. 원하는 프로젝트 이름을 지정해주세요.\n\n![CodeBuild 프로젝트 생성](/assets/img/2024-05-18-StreamlinedAWSCICDDeploymentwithCloudFormation_7.png)\n\n이제 소스 제공자로 AWS CodeCommit을 선택하여 프로젝트 파일을 CodeCommit 저장소에 저장했기 때문에 해당 저장소를 드롭다운 옵션으로 선택하세요.\n\n![CodeCommit 저장소 선택](/assets/img/2024-05-18-StreamlinedAWSCICDDeploymentwithCloudFormation_8.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n환경 설정을 기본값으로 유지하십시오.\n\n다음으로 새 서비스 역할을 선택하고 다른 설정은 그대로 유지하십시오.\n\n![이미지](/assets/img/2024-05-18-StreamlinedAWSCICDDeploymentwithCloudFormation_9.png)\n\n빌드 사양에서는 buildspec.yml 파일을 사용할 것입니다. buildspec 파일의 이름을 지정하십시오.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n참고: buildspec.yml 파일은 CodeCommit 리포지토리에 저장되어 있어야 합니다.\n\n![이미지](/assets/img/2024-05-18-StreamlinedAWSCICDDeploymentwithCloudFormation_10.png)\n\n아래는 우리 프로젝트에서 사용한 buildspec.yml 파일입니다:\n\n```js\nversion: 0.2\n\nphases:\n  install:\n    runtime-versions:\n      java: corretto17\n  pre_build:\n    commands:\n      - echo \"Maven 종속성 설치 중...\"\n      - mvn clean install -DskipTests=true\n  build:\n    commands:\n      - echo \"Spring MVC 애플리케이션 빌드 중...\"\n      - mvn package\n  post_build:\n    commands:\n      - echo \"빌드가 성공적으로 완료되었습니다!\"\nartifacts:\n  files:\n    - target/*.war\n    - scripts/*.sh\n    - appspec.yml\n  discard-paths: yes\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 아티팩트 섹션에서 아티팩트 유형으로 Amazon S3를 선택하고 \"Bucket Name\" 아래에서 생성한 버킷 이름을 선택하세요. 또한 버킷 내에서 빌드 아티팩트를 저장할 폴더 이름을 지정해주세요.\n\n참고: 아티팩트 패키징은 .zip으로 사용하세요.\n\n아래는 테이블 태그입니다.\n\n<img src=\"/assets/img/2024-05-18-StreamlinedAWSCICDDeploymentwithCloudFormation_11.png\" />\n\n나머지 구성은 기본값으로 남겨두고 \"빌드 프로젝트 생성\"을 클릭하세요. \"빌드 프로젝트 생성\"을 클릭하면 새 인터페이스로 리디렉션되어 프로젝트 빌드를 시작할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/assets/img/2024-05-18-StreamlinedAWSCICDDeploymentwithCloudFormation_12.png)\n\n빌드 시작을 클릭하면 빌드 프로세스가 시작됩니다.\n\n![이미지](/assets/img/2024-05-18-StreamlinedAWSCICDDeploymentwithCloudFormation_13.png)\n\n빌드 소요 시간은 buildspec.yml 파일의 구성에 따라 다를 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-05-18-StreamlinedAWSCICDDeploymentwithCloudFormation_14.png\" />\n\n프로젝트가 성공적으로 빌드되었습니다. 모든 단계에서 성공 상태가 확인되었습니다. 빌드가 성공적으로 완료되었습니다!\n\n이제 빌드 아티팩트가 S3 버킷에 저장되었는지 확인해 봅시다.\n\n<img src=\"/assets/img/2024-05-18-StreamlinedAWSCICDDeploymentwithCloudFormation_15.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저희 빌드 아티팩트는 이제 \"cloud-project-codebuild-1.zip\"라는 폴더 아래 버킷에 안전하게 저장되어 있습니다. 이 지정된 버킷은 프로젝트 후속 단계에서 아티팩트를 배포하는 믿을 수 있는 저장소 역할을 할 것입니다.\n\n## 단계 6: 인프라 구축 설정\n\nAWS CloudFormation 템플릿의 도움으로 인프라를 시작했습니다. 자동화를 통해 품질을 향상시키고 비용을 절감하며 유연성을 향상시킬 수 있습니다. 원한다면 수동으로 리소스를 시작할 수도 있습니다.\n\n다음 링크로 CFT를 확인할 수 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n노트: 위 템플릿으로 리소스를 출시하는 경우에는 반드시 AMI ID, 역할 및 기타 매핑을 사용하도록 해주세요.\n\n![Image 16](/assets/img/2024-05-18-StreamlinedAWSCICDDeploymentwithCloudFormation_16.png)\n\n![Image 17](/assets/img/2024-05-18-StreamlinedAWSCICDDeploymentwithCloudFormation_17.png)\n\n![Image 18](/assets/img/2024-05-18-StreamlinedAWSCICDDeploymentwithCloudFormation_18.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n스택이 성공적으로 시작되었고 모든 리소스가 준비되었습니다.\n\n## 단계 7: CodeDeploy\n\nCodeDeploy를 시작하려면 먼저 2가지 역할을 생성해야 합니다.\n\n- CodeDeploy 역할: 기본 CodeDeploy 권한\n- EC2를 위한 역할: AWSCodeDeployFullAccess 또는 EC2RoleForCodeDeploy AWS 관리 정책을 역할에 부여하세요. 이제 이 역할을 이전에 시작한 EC2 인스턴스에 부여하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-05-18-StreamlinedAWSCICDDeploymentwithCloudFormation_19.png\" />\n\n<img src=\"/assets/img/2024-05-18-StreamlinedAWSCICDDeploymentwithCloudFormation_20.png\" />\n\nCodeDeploy는 기본적으로 appspec.yml이라는 YAML 파일을 사용하며 소스 코드 루트에서 찾을 수 있습니다. 파일 참조는 여기에 있습니다.\n\n```yaml\nversion: 0.0\nos: Linux\n\nfiles:\n  - source: /\n    destination: /home/ec2-user/server\n\npermissions:\n  - object: /\n    pattern: \"**\"\n    owner: ec2-user\n    group: ec2-user\n\nhooks:\n  BeforeInstall:\n    - location: server_clear.sh\n      timeout: 300\n      runas: ec2-user\n  AfterInstall:\n    - location: fix_privileges.sh\n      timeout: 300\n      runas: ec2-user\n  ApplicationStart:\n    - location: server_start.sh\n      timeout: 20\n      runas: ec2-user\n  ApplicationStop:\n    - location: server_stop.sh\n      timeout: 20\n      runas: ec2-user\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nThe appspec.yml file uses shell scripts to manage the hooks. You can find these scripts here.\n\nNext, navigate to the CodeDeploy service and create an application by specifying the application name.\n\n![Image 1](/assets/img/2024-05-18-StreamlinedAWSCICDDeploymentwithCloudFormation_21.png)\n\n![Image 2](/assets/img/2024-05-18-StreamlinedAWSCICDDeploymentwithCloudFormation_22.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n어플리케이션이 생성된 후에 이제 배포 그룹을 만듭니다. 배포 그룹에 이름을 지정하세요.\n\n![image](/assets/img/2024-05-18-StreamlinedAWSCICDDeploymentwithCloudFormation_23.png)\n\n이제 코드 배포 권한을 가진 역할을 선택하여 AWS CodeDeploy가 대상 인스턴스에 액세스할 수 있도록 합니다.\n\n배포 유형 선택중:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 변경 대상: 수정 사항이 적용될 때 애플리케이션이 잠시 오프라인 상태가 됩니다.\n- Blue/Green (선호): 수정 사항이 적용된 새 인스턴스가 시작되는 동안 이전 인스턴스는 여전히 사용자에게 서비스를 제공합니다. 여기서 업데이트는 다운타임 없이 이루어집니다.\n\n우리가 시작하는 애플리케이션은 그다지 중요하지 않으며 잠시 오프라인 상태가 되는 몇 초의 다운타임을 견딜 수 있기 때문에 In-Place 배포 방식을 선택할 것입니다.\n\n<img src=\"/assets/img/2024-05-18-StreamlinedAWSCICDDeploymentwithCloudFormation_24.png\" />\n\n배포 설정에서 다른 구성은 기본 설정으로 유지합니다. 이제 배포 그룹을 생성하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![image1](/assets/img/2024-05-18-StreamlinedAWSCICDDeploymentwithCloudFormation_25.png)\n\n이제 \"배포 생성\"을 클릭하여 전진하세요. 모든 설정은 그대로 두고 아래 그림과 같이 리비전 유형만 선택하세요.\n\n참고: S3에 저장된 artifact의 URI를 복사하여 리비전 위치로 사용합니다.\n\n![image2](/assets/img/2024-05-18-StreamlinedAWSCICDDeploymentwithCloudFormation_26.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 출발할 준비가 되었습니다. 배포를 시작하세요.\n\n![image](/assets/img/2024-05-18-StreamlinedAWSCICDDeploymentwithCloudFormation_27.png)\n\n성공했습니다! 내 애플리케이션이 EC2 인스턴스에 배포되고 Auto Scaling 그룹에 의해 스케일링되었습니다. ALB DNS를 통해 애플리케이션에 액세스할 수 있습니다.\n\n## 단계 8: CodePipeline\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nAWS 콘솔의 CodePipeline으로 이동하여 \"파이프라인 생성\"을 클릭하세요.\n\n![이미지](/assets/img/2024-05-18-StreamlinedAWSCICDDeploymentwithCloudFormation_28.png)\n\nCodeCommit 리포지토리, CodeBuild 프로젝트 및 CodeDeploy 응용 프로그램을 언급하여 파이프라인을 생성하세요.\n\n![이미지](/assets/img/2024-05-18-StreamlinedAWSCICDDeploymentwithCloudFormation_29.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n모든 단계가 성공적으로 완료된 후, 엔드포인트 URL을 방문해주세요. 여러분의 웹 애플리케이션이 이제 라이브 상태여야 합니다.\n\n축하드립니다! 여러분은 원활한 최고급 AWS CICD 파이프라인을 성취하셨습니다 🔥\n\n# 결론\n\n이 글에서는 AWS와 CloudFormation을 사용하여 Java-17 Maven 애플리케이션의 CI/CD 파이프라인을 설정하고 최적화하는 과정을 살펴보았습니다. 빌드, 테스트 및 배포 단계를 자동화함으로써 더 효율적이고 안정적이며 확장 가능한 배포 프로세스를 구현했습니다. 이는 인간 에러 가능성을 줄일뿐만 아니라 소프트웨어 전달에 일관된 접근 방식을 보장합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저희 프로젝트에서 소중한 협업을 해준 Mohit Jaiswal에게 감사의 말씀을 전하고 싶습니다. 함께 작업함으로써 배포 프로세스를 효율적으로 간소화하고 응용 프로그램을 최고 품질 기준으로 전달할 수 있었습니다.\n\n읽어주셔서 감사합니다! 이 안내서가 여러분이 AWS와 CloudFormation을 활용하여 CI/CD를 마스터하는 데 도움이 되기를 바라며, 궁금한 점이나 피드백이 있으시면 아래 댓글을 남겨주세요.\n\n즐거운 배포되시길 바랍니다!\n","ogImage":{"url":"/assets/img/2024-05-18-StreamlinedAWSCICDDeploymentwithCloudFormation_0.png"},"coverImage":"/assets/img/2024-05-18-StreamlinedAWSCICDDeploymentwithCloudFormation_0.png","tag":["Tech"],"readingTime":16},{"title":"블로그 포스트 제목 스타일로 번역하겠습니다프론트엔드 개발자입니다 위 문구를 친근한 톤으로 한국어로 번역하겠습니다프론트엔드 개발자 번역 부므타운 플레이테스팅","description":"","date":"2024-05-18 16:05","slug":"2024-05-18-BoomtownPlaytesting","content":"\n<img src=\"/assets/img/2024-05-18-BoomtownPlaytesting_0.png\" />\n\n함께 게임을 즐기면 좋겠어요. 함께 하는 게임은 제 삶에서 소중한 관계의 기반이에요. 제 인생에서 사랑하는 모든 사람들과는 어떤 방식으로든 함께할 수 있는 게임이 있어요. 몇 시간을 함께 게임하면서 보낸 사람들 중에서 제가 알고 소중히 여기는 사람들이 많아요. 몇 년 전에 한 게임을 통해 시작된 우정은 앞으로 몇십 년 동안 이어질 거예요. 싫어하는 사람들조차도 게임을 함께 했다면 공통분모를 찾을 수 있어요. 저는 게임을 다른 사람과 함께 즐기는 것을 자유롭게 할 수 있기 때문에 게임을 디자인하는 이유 중 하나인 것 같아요.\n\n나에게 있어서 쓰는 것과 게임을 디자인하는 것의 차이는 외로움 때문이에요. 쓰는 것은 홀로 하는 작업인데, 계속해서 새로운 이유를 찾아 다른 사람들과 공유할 수밖에 없어요. 하지만 게임 디자인은 본래 다른 사람들과 함께 하는 활동이에요. \"내 글 좀 읽어줄래?\" 어휴! 그 말이 입에서 부끄러울 정도에요. 하지만 \"함께 게임 좀 할까요?\" 이제 그건 흥미진진한 시간을 약속하는 거고, 함께 춤추고, 공동체로 존재할 수 있는 방법이에요.\n\n게임은 사람들이 플레이할 때만 존재하고, 가끔은 게임 디자인의 기능은 이미 플레이된 게임을 기록하는 것이라고 주장하기도 해요 — 내 머릿속에서만 플레이했다 해도요. 일부 사람은 플레이테스팅에 대해 비판을 품지만, 저는 그것을 즐기죠. 다른 사람들과 함께 게임을 할 기회가 어디서도 얻을 수 없는 독특한 경험이기 때문이죠. 테이블의 필요에 맞게 게임을 바꾸는 것을 게임을 살아 숨쉬는 존재로서 직접 경험하는 아름다운 기회가 또 있을까요? 디자이너들에게 플레이테스트를 추천하는 건 최종 작품의 품질을 향상시킨다는 것 때문은 아니에요 (잘 활용한다면 물론, 그게 가치 있는 도구이긴 해요) 다만 그것이 정말 재미있어서 그래요!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n나는 13살 때부터 사용해 온 플레이 테스트 방법이 있습니다. 이 방법은 친구 Eclipse가 이 방법에 대한 글을 올리면서 그 가치와 역할에 대해 제 주의를 환기시켰을 때까지는 전혀 눈에 띄지 않는 방법인데요. 저는 이를 '커뮤니티 플레이테스팅'이라고 생각하고 있어요.\n\n![이미지](/assets/img/2024-05-18-BoomtownPlaytesting_1.png)\n\n본 글에서는 커뮤니티 플레이테스팅에 대해 설명하고, 플레이테스팅 방법으로 사용하는 내 생각을 소개하고, 최상의 실행 방법에 대한 조언, 그리고 흔히 발생하는 몇 가지 함정을 피하는 방법에 대해 이야기하려 합니다.\n\n# 커뮤니티 플레이테스팅이란?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n금이 강에서 발견되었습니다. 견습광부들은 눈앞이 반짝이며 도착합니다. 시내 주변에 집들이 솟아납니다. 상점 주인들은 물건을 옮기느라 서둘러합니다. 모든 사람들은 두 달 후에는 온 동네가 황무지가 될 것을 알지만, 현재는 살아있습니다. 커뮤니티 플레이테스팅은 매우 비슷한 프로젝트입니다. 특정 게임에 대한 플레이테스팅과 피드백만을 위해 만들어진 임시 커뮤니티 공간입니다. 이 커뮤니티 공간은 당신의 번창하는 마을, 활동과 흥분이 넘치는 곳이며 결국 가라앉을 겁니다.\n\n디지털 시대에 번창하는 마을을 만드는 여러 가지 방법이 있습니다. 2024년에는 디스코드 서버를 추천하겠지만, 페이스북 그룹, 포럼, 서브레딧 또는 심지어 이상한 캠핑 원정대도 사용할 수 있습니다. 선택한 매체는 게임 디자이너의 편안함과 매체에 대한 익숙함, 그리고 문제가 있는 번창하는 마을의 크기에 따라 달라집니다. 당신의 번창하는 마을이 평범한 테이블톱 팀이라면 그룹 채팅이 충분할 수도 있습니다.\n\n임시이자 집중된 번창하는 마을을 유지하는 것이 중요합니다. 이곳은 직접적으로 당신이 작업 중인 게임과 관련이 없는 다른 게임과 그들의 디자인을 위한 공간이 아닙니다. 디스코드 서버를 만드는 경우, 부주제 채널, 표출용 채널 및 밈 채널을 피하세요. 이것은 보다 넓은 커뮤니티의 중심지가 아니며, 정서 지원을 찾는 곳이나 게임 디자인 축제의 장소가 아닙니다. 이것은 기능을 갖춘 공간이며, 기능이 완료되면 그 공간은 버려질 수 있습니다.\n\n번창하는 마을은 당신의 게임을 위한 커뮤니티입니다. 친구와 플레이 파트너를 초대하세요 (그들이 항상 함께하진 않을 수 있으니 이해하세요!), 팬들을 초대하세요, 당신과 같은 작업을 하는 사람들을 초대하세요. 공간 안 모두가 당신의 이익을 생각하며 게임을 최고로 만들고자 하는 열망을 갖고 있고, 당신이 함께 플레이하고 싶은, 프로젝트에 열정적인 사람들입니다. 그들은 성심성의, 동정심, 흥분으로 당신이 만드는 모든 것에 참여할 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n**Boom Town**은 플레이테스트 및 반복에 사용되는 공간입니다. 게임을 자주 실행하고 커뮤니티가 본인의 게임을 실행할 수 있도록 권한을 부여하며 실험적인 아이디어를 시험해보라고 사람들을 격려하세요. 게임을 거의 당신만큼 잘 알고 있는 사람들로 가득 찬 방에서 아이디어를 교환하고 까다로운 설명을 해결하는 데 도움을 받으세요. 플레이스토밍 세션을 진행해보세요. 경험 많은 플레이테스터들과 음성 통화를 통해 아직 규칙을 만들지 않은 게임 부분을 다루며 새로운 메카닉을 어떻게 새롭게 만들 수 있는지 보세요.\n\n**Boom Town**이 가장 잘 작동할 때, 게임 내 아이디어를 반복하고 핵심 메카닉을 정제하며 게임 기능을 탐색하는 강력한 엔진으로 작동할 수 있습니다. 게임이 어떠해야 하는지에 대한 당신의 개념을 도전할 초기 시청자로서, 게임이 가장 중요한 본질로 정제되도록 이 과정을 통해 개선할 수 있습니다.\n\n# 커뮤니티 플레이테스팅과의 나의 역사\n\n저는 태보이기(TTRPG)에 손 대기도 전에 라이브 액션 롤플레이(LARP) 디자이너였습니다. 14살 때, Wayfinder Experience를 통해 거대한 인원들을 위한 LARP를 운영하며 전문 스텝과 제작 예산을 가졌습니다. 이러한 LARP는 모두 원샷이었고, 기계적 중첩이 있었지만 플레이테스트를 할 능력이 없었습니다. 한 번 운영한 후 버리고, 좋은 아이디어를 다음 것으로 가져갔습니다. 플레이테스트의 부재는 베타 리딩 및 피드백을 받아야 했지만, 실제로 게임을하지 않았습니다. 어떻게요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이른바 구글 문서의 초기 버전은 20명 이상의 다른 사람들의 메모들로 얽힌 엉망진창이었습니다. 구글 문서의 기능으로 댓글이 추가되기 전에는 친구마다 자신의 텍스트를 나타내기 위한 다른 색상을 선택했고, 게임 텍스트의 각 단락 아래에서 효과에 대해 논의하는 긴 대화를 나누었습니다. 나는 고등학교에 진학할 때, 이 무지개 교환이 곧 긴 코멘트 스레드와 이벤트를 준비하는 스태프와의 그룹 채팅으로 대체되었습니다.\n\n이것은 내 작업에 대한 엄격한 피드백을 받아들이기 시작한 첫 번째 순간이었습니다. 제작 스태프는 4주 동안 일하고 카페인, 니코틴, 벌레 살충제로 에너지를 보충하는 사람들보다 게임 메커닉에 더 냉정한 사람이 없습니다. 그래서 저에게 내 게임에 대해 코멘트를 남겨주도록 요청하는 비즈니스 파트너인 그래비라는 이유가 있습니다. 아름답고 지적인 여성이 나에게 비판적인 태도를 취하는 유일한 방법이니까요.\n\n게임 주변의 계속된 소란이 제 창조적 프로세스의 핵심입니다. 주변의 사람들이 피드백을 제공하면 제게는 필요합니다. 난립한 피드백 속에서 내가 사용할 수 있는 것을 찾아내야 합니다. 테이블탑 게임으로 이동하면서도 이 같은 과정을 플레이테스터들과 함께 진행했습니다. 게임이 완성될 때까지 수백 시간을 게임하는 것이 가능했기 때문에 플레이테스트저에게 수백 시간을 투자하게 되어 제 도움을 받았습니다. 게임의 크기와 복잡성에 따라 2부분으로 나누어 처리했습니다. 작은 게임 중 많은 것이 Possum Creek Patreon을 통해 커뮤니티로부터 플레이테스트 받습니다. 이 방법은 나에게 적합합니다. 작은 게임을 개발할 때는 친구들에게 아이디어를 계속해서 개인적으로 보내거나, Creekside 커뮤니티 센터 채널에서 이야기를 나누지만, 그것은 Boom Town 구조가 필요하지 않습니다.\n\n현재 내 열정적인 프로젝트는 The Seven-Part Pact라는 확장형 시뮬레이션 위자드 게임입니다. 게임의 구조에 많은 경험이 있는 플레이테스터들이 필요합니다. 압력이 많은 부분을 감지하고 약한 부분을 탐색할 수 있기 때문입니다. 나에게 수개월이나 몇 년이 걸릴 대규모 게임이며, 그래서 Boom Town은 장기적으로 유용할 것입니다. 그리고 이것은 이상하며, 소셜 미디어의 굶주린 입에 바로 던질 경우 많은 실험 없이는 분리될 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저는 특정한 친구들과 Patreon 서버에 관심 있는 사람들을 함께 모아 'Boom Town'을 건설했어요. 현재 이 곳은 80명 이상의 대규모 커뮤니티이며, 누출되는 정보나 흘러들어오는 동안에 계속해서 성장하고 있어요. 저는 제게 게임 플레이테스트를 진행하는 사람들에게 서버로 자신의 친구를 초대하도록 허용하고 있어요. 이 서버에는 다음과 같은 채널들이 있어요:\n\n- #general 채널: 게임에 대한 널리 토의를 할 수 있는 공간입니다.\n- #questions 채널: 특정 규칙이 어떻게 작동하는지 의심스러울 때 질문하는 곳입니다.\n- #feedback 채널: 플레이 경험을 게시할 수 있는 곳입니다.\n- 플레이테스트를 조직할 수 있는 채널. (Seven-Part Pact의 경우, 실제 플레이테스트, 온라인 음성 플레이테스트, 포스트 형식의 플레이테스트로 구분됩니다.)\n- 게임 특정 채널(주문법 아이디어나 특정 위자드 주변 토론을 위한 채널 등), 당연히 다른 게임들에 대해서는 다를 수 있어요.\n- 제 자신이 사용하는 세 가지 \"읽기 전용\" 채널, 변경 사항을 게시하는 #to-do 채널, 플레이테스트용 게임 최신 복사본을 포함하는 #resources 채널, 문서에 대한 변경 사항을 게시하는 #updates 채널이 있어요.\n\n또한, 서버 목적에 대한 목표를 설명하고 커뮤니티 행동에 관한 일부 기준을 설정할 수 있는 행동 강령 채널을 마련하는 것을 장려해요. 저는 Patreon Discord의 행동 강령을 사용하고 있기 때문에 이 채널을 포함하지 않기로 결정했어요.\n\n모든 디자이너는 자신만의 구조를 필요로 할 것이며, 누구든지 자신의 공간을 원하는 대로 디자인할 수 있어요. 이것은 Seven-Part Pact에 대해서 제가 발견한 방식이며, 미래 플레이테스트를 위해서는 다르게 구조화할 것이지만요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 플레이테스트에 대한 비고\n\n일부 디자이너들은 플레이테스트를 좋아하지 않거나 플레이테스트가 필요하지 않다고 말합니다. 사실은, 아무것도 필요하지 않고 삶 자체가 큰 롤러코스터인 것 같아요. 작은 게임, 무료 게임, 실험용 게임, 가사 게임 — 이런 게임들은 거대한 전통적인 책과 같이 플레이테스트가 필요하지 않아요. 하지만, 어떤 게임이 플레이테스트를 거치지 않았다는 걸 느낄 수 있어요. 가끔 게임을 하다가 디자이너가 의도한 것과는 다른 명백한 오류를 만나면서, 이런 문제가 발견되었다면 아마도 이 게임은 좀 더 흥미로웠을 것 같다는 생각이 들어요. 이런 실용적인 이유로 플레이테스트를 하는 거죠; 게임에 대한 대화들을 예상하고 이런 순간을 예상할 수 있게 해줘요. 또 하나의 이유는 당신의 게임에 플레이테스트를 하는 것이 좋다는 거에요: 이상적으로, 당신의 게임은 당신에게 재미있어야 해요. 만약 당신에게 재미있지 않다면, 누구에게 재미있는 건지, 그리고 그들이 대신 플레이테스트해주길 원할까요?\n\n# 커뮤니티 플레이테스트에 대한 조언\n\n## 커뮤니티 관리는 기술입니다\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n나는 어떻게 커뮤니티 플레이테스팅 공간을 운영하는 데 편안함을 느끼는 이유는 커뮤니티가 어떻게 작동하는지에 익숙하고 10년 이상의 커뮤니티 관리 경험이 있기 때문입니다. 이 분야가 익숙하지 않다면, 처음부터 커뮤니티를 시작하는 데 시간과 노력이 필요할 것입니다. 사람들은 처음에 말을 꺼리고 사회적 규범이 확립될 때 충돌이 있을 것입니다. 이를 해결할 수 있는 몇 가지 방법이 있어요!\n\n- 토론을 촉진하세요. 답글을 받지 못하더라도 업데이트를 계속해서 올려주세요. 게임을 운영하고 사람들을 끌어들인 다음 게임 후에 구체적인 플레이테스팅 질문으로 텍스트 대화를 유도하세요. 게임과 관련된 밈을 게시하세요. 모두가 게임을 하지 않을 때 체계적인 결과를 얻을 수 없다고 약속할 순 없지만, 그럼에도 불구하고 공간에서 가치 있는 것을 얻으려 노력하세요.\n- 다른 커뮤니티를 활용하세요. Boom Town의 대부분이 다른 커뮤니티 출신이라면 그 커뮤니티 규범을 명시적인 기준으로 활용하세요. 새로운 회원들이 이미 확립된 커뮤니티 규범에 적응하도록 Boom Town을 이 다른 공간의 확장판으로 대해주세요. 서로 알고 있는 사람들이나 게임을 통해 서로 알게 되는 사람들은 창의적인 초점을 유지하여 공간을 운영할 수 있어요.\n\n여전히 갈등과 불일치가 있을 거에요. 작업 환경에 초점을 맞추는 공간이라면 사회적 모임 공간이 아닌 경우, 그런 상황을 최소화할 수 있을 거에요. 공간의 목표를 사람들에게 상기시키고 사회적인 문제가 서버를 지배하지 못하도록 하세요. 우리는 예술을 더 나게 만들기 위해 여기에 있는 거잖아요! 커뮤니티 회원들이 바보 같은 연애를 하고 싶다면, 그 에너지를 DM으로 옮기라고 알려주세요.\n\n## 당신이 디자이너이지, 그들은 아닙니다\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n커뮤니티 플레이테스팅 공간에서 작업할 때는 받는 피드백과 응답의 폭풍에 압도당하기 쉽습니다. 게임에 투자한 사람들이 있을 것이고, 그들은 게임이 어떻게 되어야 하는지에 대한 강력한 조언을 가지고 있을 것입니다. 그들은 자신들의 소중한 게임 메커니즘이 제거될 때 슬퍼하고, 플레이테스터들을 만족시키기 위해 모든 것을 희생하는 유혹을 느낄 수도 있습니다.\n\n여러분은 디자이너입니다. 그들이 원하지 않는 한 모든 아이디어에 대해 \"아니오\"라고 말하세요. 그들의 소중한 것을 제거하고 여러분의 것을 지키기 위해 열심히 싸우세요. 커뮤니티 플레이테스팅은 여러분을 끌어올리고 과정을 명확하게 해줄 때 성공합니다. 그것이 의견의 폭풍에 여러분을 물에 빠트릴 때 실패합니다. 결국, 그들은 여러분의 게임을 플레이함으로써 여러분에게 도움을 주고 그들의 열정을 보는 것은 아름다울지라도, 여러분은 그들에게 아무 것도 갚지 않아도 됩니다. 게임을 가능한 한 최고로 만드는 데 집중하고 커뮤니티를 게임을 연마하는 수단으로 활용하세요. 지배하지 말고요.\n\n## 질문, 판단하는 게 아니에요\n\n유용한 커뮤니티 플레이테스팅은 일반적인 플레이테스팅 조언에서 나온 것인데, 공간 내 사람들의 수의 증가로 인해 더욱 향상됩니다. 게임의 새롭고 연약한 부분을 제시할 때, 가정하고 판단하는 것 대신 질문하고 탐구하는 문화를 만드세요. 누군가 처음으로 텍스트를 보는 경우, 그들은 그것이 어떻게 작동하는지에 대한 많은 질문을 가질 수 있지만, 실행해보기 전에는 그것이 어떻게 느껴지는지 알 수 없습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n특정한 피드백을 제공하기 위해 사용할 수 있는 도구는 대화를 중재하는 데 도움이 될 수 있습니다. 저는 피드백을 위해 Liz Lerman의 Critical Response Process를 수정한 것을 선호합니다.\n\n비슷하게...\n\n## 감정은 유효합니다, 조언은 아닙니다\n\n플레이테스트, 사용자 경험 디자인 및 베타 리딩에 대한 다른 기사에서 이미 다뤄졌지만, 여기서 간단히 설명하겠습니다. 게임 중에 플레이테스터가 감정적 경험을 한다면, 그들이 경험한 감정은 정확하고 유효합니다. 그러나 플레이테스터가 감정에 대해 어떻게 대처해야 하는지 제안하는 것은 아닐 수 있습니다. 플레이테스터가 자신의 클래스 능력이 부족하다고 불만스럽게 느낀다면, 해답은 반드시 능력을 강화하는 것이 아니라 다른 클래스를 약화시키거나 적을 약화시키거나 메카닉을 변경하는 것일 수도 있습니다. 게임은 종종 복잡한 기계처럼 느껴지는데, 누군가가 제대로 연기를 들이대기는 하지만 종종 그 연기의 원인을 올바르게 분명히 알 수 없거나 심지어 그 연기가 나쁜 것인지조차 잘못 알고 있는 경우가 많습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 버블에 갇히지 마세요\n\n언젠가는 게임을 커뮤니티 내에서 지옥 같이 플레이테스트했을 때가 올 거에요. 이제 외부로 나가서 실제 세계에서 게임이 어떻게 작동하는지 확인할 시간입니다. 이제 이전에 한 번도 플레이하지 않은 사람들과 게임을 진행해보세요. 다른 사람이 게임을 진행하는 것을 조용히 감시해 보세요. 게임을 사용할 사람들에게 건네 주고, 게임을 어떻게 하는지 시도하도록 보세요. 무슨 일을 해야 할지 알아보려고 하는 사람들을 지켜보세요. '붐 타운'은 고스킬 고참여 플레이어를 만드는 데 유용하지만, 처음 인상이나 새로운 플레이어의 직감을 평가하는 데는 좋지 않아요. 게임이 준비되면 한 번 시험해보고, 이러한 관찰을 커뮤니티에 가져가서 게임이 어떻게 자체적으로 높을 수 있는지 확인하세요.\n\n# 마무리\n\n'붐 타운'은 일시적인 공간이에요; 커뮤니티를 영원히 운영하고 싶지 않을 거예요. 게임이 끝나면(아마도 itch.io에 업로드하거나 크라우드펀딩을 하면서), '붐 타운'을 종료하기 시작하세요. 사람들이 만족할 수 있도록 대단한 최종 세션 하나 또는 둘 정도를 진행하세요. 사람들이 연락처를 교환하고 다른 서버에서 연락하도록 장려하세요. 게임에 특히 열정적인 사람이 있다면, 별도의 팬 스페이스를 만들 것을 권장하세요. 모두가 당신에게 자신의 이름을 제공할 방법을 제공하며, 최종 게임에서 그들에게 크레딧을 줄 수 있도록 하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n게임을 더 이상 플레이테스트할 필요가 없을 때가 오면, Boom Town을 종료할 수 있어요... 다음 게임이 나올 때까지요.\n\n이 글은 Creekside 커뮤니티 센터의 친절함과 지원 덕분에 가능했어요. 저희와 함께 계곡에서 독점 기사와 게임을 즐겨보세요. 새 콘텐츠를 먼저 만나보고, 앞서 언급된 일곱 부 Pact Boomtown 플레이테스트 서버에 접속하세요.\n","ogImage":{"url":"/assets/img/2024-05-18-BoomtownPlaytesting_0.png"},"coverImage":"/assets/img/2024-05-18-BoomtownPlaytesting_0.png","tag":["Tech"],"readingTime":12},{"title":"대형 미국 게임 개발팀이 점점 사라지고 있습니다","description":"","date":"2024-05-18 16:04","slug":"2024-05-18-LargeAmericanGameDevTeamsAreGoingExtinct","content":"\n![LargeAmericanGameDevTeamsAreGoingExtinct](/assets/img/2024-05-18-LargeAmericanGameDevTeamsAreGoingExtinct_0.png)\n\n미국 기반의 대규모 게임 개발 팀 시대가 접어들고 있습니다.\n\n일부 사람들은 이를 믿기 싫어합니다. 그것은 이해할 만한 일입니다. 가끔 획기적인 변화의 순간을 경험하고 있다는 느낌을 깨닫지 못할 수도 있습니다. 그렇지만 여기 우리는 \"흥미로운 시대\"에 몸 담고 있습니다. 그리고 여러 요소가 있지만, 핵심은 미국에서 AAA 게임을 만드는 데 사람들이 너무 오래 걸린다는 것입니다.\n\n게임 개발자들은 프로세스와 도구에 대해 보수적이라고 유명합니다. 옛 방식이 잘 돌아간다고 말합니다. 그래서 왜 그것을 바꿔야 하냐고 물을 수 있습니다. 그래서 대규모 게임을 다루기 위한 혁신적인 새 도구를 받아들이는 대신, 더 많은 사람을 추가합니다. 이로써 매월 소요량이 늘어납니다. 이 큰 팀들은 구식의 관리 구조와 프로세스에 의해 엉망으로 운영됩니다. 이로써 개발 시간이 더 길어집니다. 이 두 가지 값을 곱하면 문제를 볼 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이전에 돈이 싸고 소비자들이 모든 것을 샀을 때는 이 모델이 지속 가능했습니다. 그러나 그 시대는 지나갔습니다. 인플레이션이 계속해서 증가하고 있으므로 지역 개발의 투자 수익률은 계속해서 감소하고 있습니다. 그러나 불변적으로 달러는 국제 시장에서 강하며, 따라서 저렴한 곳에서 개발하는 투자 수익률은 계속해서 증가하고 있습니다.\n\n요점은 명백합니다: 우리 지역 개발자 인구는 줄어들 것이며, 나머지는 적응해야 할 것입니다. 우리가 이해하고 기회를 잡을 수 있는 기회가 있지만, 그 전에 우리는 먼저 일이 영원히 변화되었다는 것을 받아들여야 합니다.\n\n한 출판사가 말하는 \"대규모 게임 개발이 스스로 무너지고 있다\"라고 하면 나는 믿는다. 왜냐하면 출판사가 세계에서 가장 비싼 지역에서 AAA를 개발하고 있는 동안, 세르비아의 AAA 개발자는 비용의 20%만 지불하지만 품질은 100%입니다.\n\n스튜디오 대표가 말하는 \"게임 제작 방식이 실패하고 있다\"라고 하면 나는 믿는다. 왜냐하면 폐쇄된 대부분의 스튜디오가 미국, 캐나다 및 영국에 있기 때문입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n한 주가 지난 후에 Microsoft가 그러한 영토에 위치한 스튜디오를 폐쇄하자, 폴란드에 하나를 열었습니다. 저는 놀라지 않아요, 왜냐하면 폴란드의 삶의 비용은 캘리포니아의 거의 50%나 적고, 개발자들도 아주 훌륭하기 때문이죠.\n\n누군가를 탓하는 것은 도움이 되지 않을 거에요. 하지만 새로운 현실을 받아들이는 것이 중요할 수 있어요. 그리고 그때 기회를 찾을 수 있어요.\n\n역사적으로, 미국의 산업 강점은 기술 혁신과 새로운 것을 추구하기 위해 옛 방식을 버릴 수 있는 능력이 포함되어 왔어요.\n\n저는 그것이 우리에게 나아갈 길을 가리킨다고 생각해요. 우리 자신만으로 거시경제 상황에 대처할 수 없으므로, 개발 시간의 투자수익률(ROI)을 높여 우리의 소규모 경제적 입지를 개선해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nAI가 해결책인가요? 저는 그것이 일부라고 생각해요. 하지만 보다 넓은 시각은 과거의 엄격한 사고를 버리고 적응해야 한다는 것입니다. 그렇지 않으면 우리는 나갈 길에 자신을 발견할 위험이 있어요.\n","ogImage":{"url":"/assets/img/2024-05-18-LargeAmericanGameDevTeamsAreGoingExtinct_0.png"},"coverImage":"/assets/img/2024-05-18-LargeAmericanGameDevTeamsAreGoingExtinct_0.png","tag":["Tech"],"readingTime":3},{"title":"Godot을 평가하며","description":"","date":"2024-05-18 16:02","slug":"2024-05-18-OnEvaluatingGodot","content":"\n메가 크리트에서 진행한 내부 게임잼을 3주 동안 마무리했어요. 이번 게임잼은 Godot 엔진을 평가하기 위한 것이었어요.\n\n# 엔진 변경의 이유는?\n\n미래에서 오신 분들을 위해, 2023년 9월 12일 유니티가 런타임 요금을 발표했고 10일 후에 일부 요금을 철회했어요. 그 사이 기간 동안 혼란이 생겼는데, 이미 출시된 게임에 이 요금이 적용되는지 여부가 불분명했고, 런타임 요금의 정의가 모호했으며, 이 요금이 어떻게 감지되는지에 대한 우려가 있었고, 그들은 github 이용 약관(TOS) 페이지를 폐지했어요.\n\n유니티는 나중에 이 github 페이지의 트래픽이 충분치 않아 제거한다고 밝히면서, 이 방법으로 TOS를 투명하게 유지한다는 것이 충분한 관심을 끌지 못했다고 말했어요. ???\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/assets/img/2024-05-18-OnEvaluatingGodot_0.png)\n\n유니티는 불필요하게 이상한 후속 진술과 소극적인 설명을 더욱 깊게 파고들었고, 그들의 직원들은 다른 사람들처럼 혼란스러워하며 모두를 진정시키려고 최선을 다하고 있었습니다. 그것은 대재앙이었습니다.\n\n초기 문제에 대해 더 읽어보거나 여기에 이어지는 내용을 확인할 수 있습니다.\n\n유니티가 한 일은 정말 어리석은 일이었어요. 저는 그 엔진을 별로 좋아하지도 않아요. IPO 이후에 그들이 수수료를 부과하고 그들의 버그가 더 심해진 컴포넌트를 고치지 않는 이 \"커뮤니티를 위한\" 엔진이라고 말하면서 나는 매우 독립적인 인디 게임 개발자인데 말이죠.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n메가 크릿 팀과 저는 약 일주일간 고돗을 평가한 후 어떠한 함정이 있는지 살펴보기 위해 두 주 동안 게임을 만드는 것이 가장 좋을 것으로 결정했습니다. \"고돗으로 그런 건 안 된다\"라든지 아키텍처적인 함정과 같은 것들이죠. 만약 창조자가 ECS에 대해 과도하게 열정적이라면 누가 알겠습니까?\n\n# 그런데 왜 Godot일까요?\n\n게임 엔진을 선택할 때 제가 고려하는 몇 가지 요구 사항이 있습니다. 가장 먼저 떠오르는 것들은 다음과 같습니다:\n\n- 라이브러리 이상: SDL과 LWJGL에서 일한 경험이 있으므로 좀 더 안내를 받고 싶습니다. 자원을 로드하고 해제하거나 글꼴 처리, 디스플레이 처리에 대한 몇 가지 내부 API가 있으면 좋겠습니다. 그것들을 작성하기 싫어요; 게임을 만들고 싶어요!\n- 정적 유형 언어: 확실히 시각적 스크립팅, 드래그 앤 드롭만 가능한 편집기, 동적 스크립팅 같은 것은 싫어요. C++, C, #Objective-C, Java를 알고 있지만 Python과 JavaScript를 알긴 하지만 그저 제겐 지저분하게 느껴집니다. 이 언어들로 작성하는 코드가 아니라, 회사 내에서 모든 것을 정적으로 변수 유형을 지정할 수 있는 세상이 어디 있겠어요? 내 토끼가 어디에 똥을 누르는 것을 강요하는데도 적용할 수 없는데 말이죠.\n- 커뮤니티: Godot은 열정적인 대안으로 느껴집니다. 인기가 많다는 것은 더 일반적인 문제가 해결되고 토론되는 것을 의미합니다. 난 똑머니 없어요. 빠르게 문제를 해결할 수 없다면 무언가를 비틀어서 넣고 넘어가는데, 여전히 프로젝트에 대해 고품질로 느껴지는 솔루션을 찾고 구현하는 것을 선호할 거예요. 저희는 소규모로 운영되기 때문에 휠을 재발명할 필요가 없어요. 제가 직접 체적 구름을 구현하려 하겠냐구요? 저도 싫어요.\n- 포팅: 나만의 포팅을 하고 싶어요! 'Slay the Spire'에는 LibGDX를 선택한 이유가 PC, Mac 및 Linux에서 실행할 수 있었기 때문이죠. 네, JavaVM에서 실행되며 여러 문제가 있지만 한 번 작성하고 어디서나 실행할 수 있는 거 아니겠어요? 아니요. 콘솔에서는 돌아가지 않고 Mac과 Windows 업데이트가 계속 문제가 되죠. 어쨌든, 포팅은 어려운 일이지만 Godot은 W4Games가 포팅 도구를 개발 중이고, 다른 회사들도 콘솔용으로 포팅을 진행 중이죠! 아주 멋지죠. 스위치용 Brotato와 Cassette Beasts 👀!?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n게임 엔진을 선택하는 또 다른 이유도 있습니다. 일반 엔진 속도, 업데이트 정기성, 사용하기 즐거운 인터페이스, 소유주/설립자가 John Riccitiello-itis의 징후를 보이는지 여부 등이 있습니다.\n\n그래서 Godot은 이러한 요구 사항을 충족시켰고, C#도 지원한다고 합니다. 멋져요. 게임을 만들어 봅시다.\n\n# 댄싱 듀얼리스트(Dancing Duelists)는 무엇인가요?\n\n음, 바로 앞에서 이야기한 젬 게임입니다! 코어 프레임워크에 너무 많은 요리사가 몰리는 것을 원치 않아서 젬에 추가적으로 한 주를 더 투자하여 우리의 프로그래머 한 명이 \"큰 포트\" 작업을 시작하게 되었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Game content pipeline](/assets/img/2024-05-18-OnEvaluatingGodot_1.png)\n\nSo we worked on a deckbuilding autobattler because it’s familiar and it has a lot of bits and bobs which tend to be the types of games that we like making (content-heavy, deterministic).\n\n# Game Content Pipeline\n\nI think unlike most companies, we’re a design-first company AND both of our game designers (myself and Anthony) are technically proficient so we’re able to circumvent the making of several tools.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n유니티에서 작업할 때도 우리는 Prefab을 콘텐츠로 만들거나 콘텐츠 데이터를 저장하는 수단으로 Scriptable Objects를 사용하는 것에 반대했습니다. 왜냐하면 우리는 IDE를 사용하는 것이 훨씬 빠르다고 생각하기 때문이죠. 우리는 코드에서 정의/매개변수를 찾아가거나 강력한 검색 기능을 사용하며 엔진이 코드 라인을 가리킴으로써 버그를 해결하는 것이 더 쉽다고 생각합니다.\n\n이 콘텐츠-코드 아키텍처는 Slay the Spire와 같은 게임에서 사용하는 방식이며, 카드 게임을 만들어 보았을 때 Godot에서도 완벽하게 작동했습니다.\n\n프로그래밍에 대해 두려워하는 비전공 디자이너라면 아래 내용을 살펴보세요. 우리가 Backflip이라는 카드를 구현하는 방법입니다. 저는 이 방법이 인스펙터나 특별한 데이터 형식을 사용하는 것보다 더 효율적이라고 생각합니다. 하지만 개인의 선호에 따라 다를 수 있습니다.\n\n```js\npublic sealed class Backflip : CardModel\n{\n    public override string Title => \"Backflip\";\n    public override string Description => \"Deal 2 damage.\\nGain 2 HP.\";\n    protected override string PortraitPath => \"backflip.png\";\n\n    public override async Task OnPlay(FighterClashState owner, FighterClashState target)\n    {\n        await FighterCmd.Damage(target, 2, owner, this);\n        await FighterCmd.GainHp(owner, 2, owner);\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n게임 콘텐츠를 실행하기 전에 화면 간 로직, UI, 애니메이션, VFX, 오디오, 폰트 등을 위한 프레임워크를 설정해야 했습니다. 이것은 대부분의 시간을 잠에서 차지했어요. 대부분의 엔진들에서는 매니저, 팩토리 설정, 게임 내에서 경합 조건을 방지하는 최적의 방법이 있기 때문에 게임 콘텐츠를 통합하고 문제 해결하는 과정을 가능한 즐겁게 만들어야 합니다.\n\n# 화면 및 객체\n\n화면을 로드하고 언로드하는 것을 싫어해요. 불필요하게 느리며, 이해하기 어려운 방식으로 \"정리\"되며, 서로 다른 데이터를 전달하기 위한 흥미로운 방법을 고민해야 합니다. 2D 게임처럼 작은 것을 로드하고 언로드해야 할 경우, 소수의 에셋을 언로드하고 새로운 것을 로드할 수 있어요. 자신감이 있다면 미리 비동기로 로드할 수도 있어요. Unity와 Godot은 여기에서 유연하며, 부모/자식 관계로 객체를 시각화하고 씬 다시로드를 사용하지 않도록 할 수 있어요. 현대적인 게임 엔진의 장점 중 하나에요. 때로는 객체를 놓고 가끔 씬 트리의 시각화 없이 빼먹을 때도 있어요. 그리고 Unity에는 씬과 프리팹이 있어요.\n\nGodot에서는 씬과 프리팹이 하나로 통합되어 tscn 형식으로 되어 있고 git과 호환되어요. 정말 대단하죠. 우리를 괴롭히는 Unity YAML이 있다는 것을 생각하게 했고, perforce가 실제로 유용한지에 대해 고민하게 했죠 (사실은 아니에요). 지옥 같은 프리팹 병합의 날들은 사라졌어요. 하지만 씬에서 많은 변경 사항이 있는 경우 약간의 문제가 생길 수 있어요. 그래도 큰 문제는 없어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 장면 내의 객체를 노드라고 합니다. 따라서 GameObject은 노드입니다. 많은 컴포넌트를 연결할 수는 없지만 대부분의 요구 사항을 처리해 주는 노드의 확장이 많이 있습니다. 그렇지 않다면, 기본 노드 클래스 위에 자체적으로 작성해야 합니다. 나는 심중지기적이어서 이것은 괜찮습니다. Unity의 프랑켄슈타인 구성 요소로 가득 찬 GameObject들은 항상 나를 불안하게 만들었습니다. 하루 종일 인스펙터를 스크롤해야 하는 것은 고통스럽습니다. 이것은 논란이 될 수도 있지만, 전체 모니터를 사용하여 비디오 게임을 만들고 싶고, 빠르고 아름답고 alt-tab을 그리 많이 누르기 싫습니다.\n\n그럼에도 불구하고 때로는 노드의 다양한 노브를 조작해야 하지만, 각 노드의 제한된 매개변수들이 우리를 체크하도록 유지한다는 것을 발견했습니다.\n\n# UI 레이아웃\n\n노드에 관해서 말씀드리자면, 부모 노드로의 조합 및 다양한 지점에 고정시키는 것은 게임 UI를 배치하고 다양한 종횡비와 화면 크기에 대한 호환성을 향상시키는 현대적인 방법입니다. 자체 엔진을 개발하는 개발자들이 UI 작업을 싫어하는 이유가, 이러한 종류의 시스템을 구현하고 싶어하지 않기 때문입니다. 이것은 귀찮으며, 게임이 더 이상 이상한 종횡비를 지원할 때 아무것도 달성한 기분이 들지 않습니다.\n\nUnity와 Godot은 회전 중심, 고정점 및 다양한 컨테이너가 있어서 항목을 목록이나 그리드로 구성하는 데 도움이 됩니다. 때로는 매우 혼란스러울 수 있습니다. 특정 변수가 잠겨있을 때는 매우 매우 명확해야 한다고 생각합니다. 그러나 그렇지 않습니다. 최악의 경우에는 \"당신의 부모가 당신에게 화난 것이기 때문에 그렇게 할 수 없습니다.\"라는 메시지가 표시됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n요기에는 학습 곡선이 있어서 Unity가 UI Toolkit을 통해 전체를 다시 설계하기로 결정했어요. 기본적으로 비디오 게임에서 UI를 만드는 것은 앞으로 영원히 재앙이 될 것입니다. 왜냐하면 UI를 만드는 것을 즐기는 사람은 우리와 같이 6명 정도밖에 없고 Unity를 이끄는 사람은 아마도 프론트엔드 웹 개발자일 가능성이 높아요. 이제 모든 인디 개발자들이 그들의 방식을 배워야 한다는 점에 대해 애도를 표합니다.\n\n어쨌든, Godot과 Unity 모두 UI를 위한 특수 노드들이 좋지 않아요. 맞아요. 그것들은 항상 좋지 않았고 앞으로도 그대로일 겁니다. 게임에는 많은 복잡한 UI 문제가 있으며 일반적인 템플릿을 빌리면 게임이 엉망이 될 거예요. UI는 사용자 인터페이스의 줄임말입니다. 플레이어가 인터페이스(게임)와 상호 작용하는 방식을 의미합니다.\n\n새로운 개발자들은 기본값을 사용할 거에요. 버튼이 색상을 거의 눈에 띄지 않게 변경했을 때 \"아, 그건 게을러서 UI를 만드는 Unity 게임이구나.\" 마우스 커서가 실제로 텍스트의 벡터 모양에 닿아야만 글자 위로 커서를 올렸을 때 감지되는 경우? \"아, 그건 플래시 게임이야.\" 2023년에 어떻게 플래시 게임을 하는 거죠?\n\n그뿐만 아니라 Unity의 추악한 \"Font\" 구성 요소, 기본 버튼 및 UI 컨트롤에 대해 언급하기도 싫어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![2024-05-18-OnEvaluatingGodot_2](/assets/img/2024-05-18-OnEvaluatingGodot_2.png)\n\nTextMeshPro는 정말 대단해요. 그것이 그립네요. 제발, 자동 크기 조정된 최소/최대 설정 글꼴 텍스트를 깔끔한 직사각형 가운데 정렬할 수 있게 해주세요. 우리는 예쁜 텍스트를 만들기 위해 직접 스크립트를 작성해야 했어요. 폰트와 텍스트에 대해 매우 신경 써요.\n\n![2024-05-18-OnEvaluatingGodot_3](/assets/img/2024-05-18-OnEvaluatingGodot_3.png)\n\n그래도, Godot에서 MSDF를 볼 수 있어 기쁘네요. 멋진 기술이죠! 모서리가 너무 날카롭고 크기를 잘 조절해요. 그들이 전혀 작동하지 않을 때가 제외하고요 😢\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/assets/img/2024-05-18-OnEvaluatingGodot_4.png)\n\n# 실제로 C#을 지원합니까?\n\n어떨 때는 C#에서 특정 API에 접근할 수 없을 수도 있습니다. 시장에서 오브젝트를 찾기 어려울 수도 있습니다. 코드를 컴파일할 때 항상 업데이트되거나 불안정할 수도 있습니다. 아마도 워크플로우가 좋지 않아서 IDE에서 Godot 편집기로 alt-tab을 누를 때마다 스크립트를 10초씩 컴파일해야 하는지도 모릅니다. 이러한 것들은 GDScript의 전도자가 C# 이야기를 할 때 제 무리한 두려움 중 일부였습니다.\n\n위에서 언급한 것도 있고 다시 한 번 언급하겠습니다. 저는 정적 타입 언어를 좋아합니다. 이러한 허물없는 동적 타입 var 를 원하지 않으며, 이 부분을 아무도 변경할 수 없습니다. 명시적이고 명백한 방식을 좋아합니다. 관련성이 있다면, 우리는 CSV 대신 JSON을 사용합니다. 같은 원리입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 C# 통합에 기분이 좋아지고 있습니다. 제가 선택한 IDE(JetBrains Rider)를 사용하는 설정이 쉬웠어요. 자동 완성이 잘 되고 IDE에서 게임을 기본적으로 실행할 수 있어 좋았어요. 게임을 Godot으로 전환하고 실행할 때 빠릅니다. 정말 빠르죠. Unity에서 항상 꿈에서도 괴로웠던 5~10초간의 \"스크립트 컴파일 중...\" 팝업도 사라졌습니다.\n\n# 빠른가요? 네\n\n스크립트 컴파일 하는 것이 없어지고 Godot은 Unity보다 훨씬 가볍습니다. 고급 그래픽이나 멋진 조명 기술을 다루려고 한다면 정말 대답을 드릴 수 없어요. 하지만 쉐이더, 입자 시스템, 재질 등을 다룰 수 있어요. 아마 가장 최신 기술은 아니겠지만... 전 밝은 장난감보다는... 독립 개발자니까요.\n\nGodot은 작고 게임을 실행하고 매개 변수를 변경하고 다시 실행하는 등 디버그 도구를 계속 사용하지 않고 게임을 실행하는 느낌이 좋아요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n게임이 실행 중일 때 반영되는 노드들의 변화도 가능해요! 유니티를 배우면서 \"와, 이거 너무 현대적이다.\" 라는 순간이 있었는데, Godot에서도 이것이 잘 동작하고 있다는 것을 보니 기뻤어요. Unity와 비교하면 몇 가지 제한 사항이 있지만 전반적으로 정말 멋진 기능들이에요.\n\n속도에 관한 이야기로 돌아와서, 프로젝트를 열 때 더 빨라지고 작동에 어떤 바보같은 인증도 필요하지 않아요. 프로젝트를 실행하는 속도도 더 빨라졌어요. 스크립트 작업 흐름도 더 빠르고 빌드를 내보내는 것도 더 빨라요. 정말 빠르죠!\n\n부록으로, 인터넷에서 raycast2d의 성능에 대한 불만이 있었어요. 많이 사용할 계획이라면 조금 관련 정보를 좀 더 찾아보길 권해요.\n\n# TexturePacking/TextureAtlas/SpriteAtlas\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n좀 아쉽네요. 그게 전부에요. 적어도 TexturePacker로 생성된 파일을 읽을 수 있어서 다행이에요(세 번째 자료 압축 도구의 이름). 약간 짜즯다고 생각하시겠지만요. 하지만 유니티는 매번 게임을 실행할 때마다 패킹을 해야 한다니까, 실은 그것도 바보 같아요. 아마 어디든 이 작업 흐름이 이렇게 훌륭하지 않은 것일지도 몰라요?\n\nNinePatch 텍스처는 TextureAtlases로 설정하는 게 좀 귀찮아요. 그렇게 복잡한 문제는 아닌 것 같아서, 아마 기능 요청을 제출해볼까 합니다.\n\n# Dancing Duelists 디자인 미스\n\n그럼, Dancing Duelists로 돌아가서요. 프로젝트 범위를 줄이고 제한을 도입하여 시간 제약으로 완전히 탐구하지 못한 게임 디자인 영역 및 제한 사항을 살펴보려고 생각했습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 덱이 너무 무작위로 설정됩니다: 초기 디자인은 플레이어가 원하는 순서대로 덱을 설정하여 플레이하도록 허용했습니다. 덱은 맨 위부터 자동으로 플레이됩니다. 이는 진정성 있는 사용자 경험을 만들기 위해 심각한 작업이 필요하며 균형을 맞춰야 할 많은 복잡성을 도입합니다. 우리는 게임을 빠르게 플레이테스트할 수 있는 것으로 기대하지 않았기 때문에 문제가 될 수 있는 콘텐츠를 반복적으로 플레이테스트 세션을 실행하여 개선할 수 없었습니다. 이러한 무작위성은 점수판을 더 간단하게 유지합니다.\n- 턴 순서 문제: 누가 먼저 움직일까요? 동점이면 어떻게 할까요? 멀티플레이라면 누가 먼저 가야 할까요? 속도 스텟? 동전 던지기? 당신이 먼저 가고 그들이 먼저 가는 것은 어떨까요? 솔직히 이것은 자동전투게임에서 공정성을 위해 해결해야 할 복잡한 문제입니다. 따라서 우리는 항상 플레이어가 먼저 가는 PvE 게임을 선택했습니다. 위에서 언급한 것처럼, 이는 것을 간단하게 만들지만 게임이 얇아지게 됩니다.\n- 비슷한 빌드: 이상적으로는 각 전투용 파이터마다 맞춤식 카드 풀을 만들어서 2-4가지 일반 아키타입을 향해 빌드할 수 있도록 할 것입니다. 우리는 멀티풀, 공유 풀, 그리고 아마도 보석 시스템에도 비슷한 것을 사용할 수 있게 만들 것입니다. 이렇게 많은 콘텐츠를 만들고 균형을 맞추고, 이러한 아키타입을 탐험하는 것은 거대한 작업일 것입니다. 죄송하지만, 이번 점수판에는 이번 점프를 위한 여러 카드가 들어 있습니다.\n\n더 많은 제약 사항이 있지만, 이러한 절하로 인해 짧은 시간 안에 게임을 출시할 수 있었던 것 같습니다. 게임이 전체 잠재력을 발휘하지 못하는 것은 안타깝지만, 게임 엔진을 탐색하기 위해 실행한 점프에 너무 감정적으로 연연하지 않는 것이 좋습니다.\n\n# 멀티플레이어?! 아쉽게도\n\n자동전투게임이 일반적으로 멀티플레이어 여부에 대해 좀 많이 고민했습니다. 그러나 몇 가지 디자인 문제를 해결하지 못했기 때문에 결국 그것에 대해 진전할 수 없었습니다. 이는 게임을 플레이하고 덱을 저장한 다음 이러한 덱과 대결해야 한다는 것을 의미했습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n플레이 테스트에서 이 데이터를 얻는 것은 예상보다 순조롭지 않아서 일부 자동화를 구축했어요. 아마도 \"머신 런어지?\", \"AI?\", \"신경망 뭐라뭐라?\"라고 묻고 계실지도 모르겠네요. 대답은 정말이지 그렇지 않아요. 우리가 사용한 건 무차별 공격이었어요. 이게 괜찮았던 이유는 게임이 \"턴 순서 문제\"로 비대칭이며, 각 전투 시작 시 덱이 무작위로 섞이는 것이 많은 변화를 준다는 것이죠.\n\n우리는 Godot이 빠르게 작동한다고 말했지만, 그에 비해 용량을 적게 차지한다는 것도 중요합니다.\n\n그래서 우리는 무차별 공격으로 카드를 선택하게 하고, 그것들을 우리가 만든 작은 플레이어 덱과 싸우게 했어요. 그들이 이기면 해당 덱을 저장하고 게임에 다시 통합시켰죠. 우리는 각 라운드 당 전투별 대략 20개의 고유한 덱을 원했고, 결국 약 1,200개의 고유한 상대를 만들어냈어요. 이들은 플레이어가 만든 덱을 이기는 최소 강도 요구 사항을 충족합니다. 말이 많아 보일 수 있지만, 파일 크기는 2MB에 불과해요. 이런 덱들은 JSON 파일로 저장돼요. 여기 예시 파일이 있습니다: jazzy_jasper_R2_1697423308.json\n\n```js\n{\n “name”: “player”,\n “round”: 2,\n “strength”: 3,\n “autogenerated”: true,\n “character”: “CHARACTER_MODEL.JAZZY_PACIFIST”,\n “trinkets”: [\n “TRINKET_MODEL.CIRCULAR_BREATHING”,\n “TRINKET_MODEL.GOTHIC_WARDROBE”\n ],\n “cards”: [\n “CARD_MODEL.GROOVE”,\n “CARD_MODEL.GROOVE”,\n “CARD_MODEL.GROOVE”,\n “CARD_MODEL.SMOOTH_SOLO”,\n “CARD_MODEL.POLYRHYTHM”,\n “CARD_MODEL.HEADSHOT”,\n “CARD_MODEL.LEG_DAY”,\n “CARD_MODEL.ASTEROID”,\n “CARD_MODEL.FIRE_BLAST”,\n “CARD_MODEL.MOONWALK”,\n “CARD_MODEL.ALACRITY”\n ]\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n최종적으로 우리는 현재 전투사와 승리할 때마다 난이도가 증가하는 것을 도입하기 위해 의도된 강도 변수를 활용하지 않았습니다.\n\n# 마무리\n\n해냈어요! 딱 3주 만에 여러분이 지금 이곳에서 다운로드하고 플레이할 수 있는 실제 비디오 게임을 만들었어요: https://megacrit.itch.io/dancing-duelists\n\n![이미지](/assets/img/2024-05-18-OnEvaluatingGodot_5.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n입력, SDK 통합, 종횡비 처리, 로컬라이제이션, 하드웨어 호환성, 써드 파티 플러그인(Spine2D와 FMOD을 사용합니다), 그리고 수정 가능성과 같은 더 많은 주제가 더 있지만, 좋은 비디오 게임을 만드는 것은 단거리 경주가 아니라 장거리 마라톤이에요. 그럼, 여기서 마무리 지을게요. 전 하느님(Godot 전문가)은 아니지만, 진짜 2D 비디오 게임을 만들기 위한 도구는 있는 것 같아요.\n","ogImage":{"url":"/assets/img/2024-05-18-OnEvaluatingGodot_0.png"},"coverImage":"/assets/img/2024-05-18-OnEvaluatingGodot_0.png","tag":["Tech"],"readingTime":16},{"title":"게임 산업의 현황  우리는 재미를 희생하고 있다","description":"","date":"2024-05-18 16:00","slug":"2024-05-18-TheLandscapeofGamingHaveWeSacrificedFunforPower","content":"\n## 게임\n\n<img src=\"/assets/img/2024-05-18-TheLandscapeofGamingHaveWeSacrificedFunforPower_0.png\" />\n\n지난 주말에는 다가오는 플레이스테이션 5 Pro와 그 사양에 관한 정보들이 유출되었습니다. 지금까지 하드웨어 측면에서는 유망한 모습을 보이고 있으며, 여기에 몇 가지 세부 정보가 있습니다:\n\n- PS5보다 45% 빠른 렌더링\n- 2–3배의 레이 트레이싱 (어떤 경우에는 4배)\n- 33.5 테라플롭\n- PSSR (플레이스테이션 스펙트럴 슈퍼 리졸루션 업스케일링) 업스케일링/안티앨리어싱 솔루션\n- 미래 SDK 버전에서 8K 해상도 지원 예정\n- 맞춤형 머신 러닝 아키텍처\n- 8비트 연산의 300 TOPS / 16비트 부동 소수점의 67 TFLOPS를 지원하는 AI 가속기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그러나 이러한 유출물에 대한 토론이 진행될수록, 게이밍 커뮤니티는 언제나 대화에 끼어든 주제로 회귀했습니다: 그래픽입니다. 계속해서 모든 전형적인 용어들이 던져지기 시작했고, “레이 트레이싱,” “해상도 향상,” “4K 업스케일링” 등이 있죠. 결국 모든 것이 마무리될 때, 나는 자신에게 묻지 않을 수 없었습니다. “게임은 게임 자체가 아닌 다른 모든 것에 대해 언제부터 됐을까?”\n\n그때 깨달았습니다. 연산 능력과 그래픽 주변의 대화 뿐만 아니라, 우리가 더 이상 언급하지 않는 것들도 게임의 의미를 왜곡시켰다는 것을요. 그래서 최근에 나는 게임이 어떻게 즐거웠는지 상기시키기 위해 몇몇 옛 콘솔을 꺼내들었습니다. Nintendo 64, Sega Genesis, 그리고 PlayStation 2를 번갈아가며 사용한 뒤 현재 세대로 돌아가보니 빈틈을 느꼈고, 그것이 왜 그런지 탐구하고 싶어졌습니다.\n\n![이미지](/assets/img/2024-05-18-TheLandscapeofGamingHaveWeSacrificedFunforPower_1.png)\n\n# 그래픽 대 게임플레이\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n내 기억 속 여행의 첫 절반에서는 닌텐도 64와 세가 제네시스에서 시작했어요. 페이퍼 마리오, Destruction Derby, Virtua Fighter, Virtua Cop이 어릴 적에 가장 좋아했던 게임들 중 일부였어요. 그중에서도 페이퍼 마리오가 가장 잘 나이 들었다고 말할 수밖에 없어요. 다른 게임들도 그래픽적으로 매력적이었지만, 이틀에 처음 틀어본 것은 분명히 충격적인 경험이었어요.\n\n사실, 처음 이 게임들을 플레이할 때, 어린 시절에 어떻게 이 나사구멍 모양의 화면들이 내 주의를 끈 것이었는지 혼란스러웠던 기억이 떠올랐어요. 하지만, 이 게임들이 만들어진 시대에 있어서는 최고 수준이었습니다. 그리고 아마도 비디오 게임을 처음 탐험했던 어린이로서, 우리는 매우 즐거움을 느꼈던 것 같아요. 모든 게 새로운 경험이라서 각 게임은 지난 것과 다르게 느껴졌어요.\n\n하지만 지금 봤을 때, 우리는 게임이 영화적 경험으로 발전하는 기술을 마스터하고 있지만, 내면의 어린이에게 매력을 주었던 것에 대한 개선은 없는 것 같아요. 세계는 아름답게 보이고 호쾌한 이야기를 전달할 수 있지만, 조종기의 다른 끝에 있는 플레이어가 재미를 느끼지 못한다면, 무슨 의미가 있을까요? 저는 현대의 대부분의 게임이 단지 플레이어를 다음 컷씬으로 이끌어주는 역할만 하고 중간에 하는 일이 별로 없는 것 같다고 말할 수도 있겠어요.\n\n게임은 일상에서 벗어나는 수단으로 기능해야 하지만, 어떤 식으로 우리는 인생의 현실주의를 포착하고 아이러니하게도 그 또러자지 않은 면도 담아냈어요. 이상하게 들릴지 모르지만, 나는 90년대와 2000년 초반의 타이틀들에서 현대 기술에 의해 향상된 것보다 더 많은 재생 가치를 발견했어요. 오늘날 수백만 달러를 벌어온 AAA 개발자들이 과거의 낮은 해상도와 낡은 게임플레이 메커니즘을 향찰할 때 사람들이 뭔가를 갖게 되는 것을 어떻게 다루는 것인지에 대해 무엇을 말해줄까요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![The Landscape of Gaming: Have We Sacrificed Fun for Power](/assets/img/2024-05-18-TheLandscapeofGamingHaveWeSacrificedFunforPower_2.png)\n\n# DLC vs Cheat Codes\n\n게임의 다른 요소 중 우리가 이제 거의 인정하지 않는 것은 치트 코드입니다. 제가 가장 먼저 기억하는 것 중 하나는 할아버지와 할머니와 함께 가게에 갈 때마다 노트북과 펜을 가져가는 것이었습니다. 각 여행은 내가 갖고 있는 게임을 위한 치트를 전담하는 특별한 페이지가 있는 잡지를 찾을 기회였죠. 시간이 흘러감에 따라, 잡지에서 멀어져 SuperCheats, CheatPlanet과 같은 웹사이트, 그리고 GameShark나 Action Replay와 같은 기기로 나아갔습니다.\n\n안타깝게도, 위, 위, 아래, 아래, 왼쪽, 오른쪽, 왼쪽, 오른쪽, B, A, start를 계속 누르는 시절은 사라졌습니다. 대신, 지금 우리가 가지고 있는 것은 DLC와 마이크로트랜잭션 형태의 기업적인 탐욕입니다. 이는 좋지 않은 게임 플레이 문제를 더 악화시킵니다. 게임을 완전히 개발하는 수고를 왜 해야 하나요? 완성된 게임과 동일한 가격으로 누락된 부분을 플레이어들에게 요금을 부과할 수도 있잖아요. 캐릭터 팩에 19.99달러, 확장에 39.99달러, 심지어 시즌 패스에 59.99달러를 지불할 수 있습니다. 사람들은 이러한 관행에 익숙해졌으니, 왜 안 하겠습니까?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n결과적으로 게임 산업은 사람들이 최소한의 것을 전달하기 위해 지불할 의사가 있는 점을 이용했습니다. 비록 사기는 아닌 것 같아요, 전체적으로 말이죠. 치트 코드는 원래 개발자들이 디버깅과 플레이 테스트를 더 쉽게 할 수 있도록 고안된 방법이었어요. 그 시절에는 개발자 키트도 조금 더 비쌌기 때문에, 무한한 돈, 무한한 체력, 그리고 비밀 게임 내 도구와 같은 것들은 보통 그냥 남아 있는 코드였어요.\n\n지금은 개발 과정이 더 효율적으로 진행되고 있기 때문에 치트 코드를 포함할 이유가 사실상 없습니다. 그럼에도 불구하고, 숨겨진 개발자 코드의 자유로움에서 그것을 유료로 판매하는 상품으로 재패키징하는 과정을 보면 정말 실망스럽습니다. DLC를 통해 기업들이 얼마나 많은 수익을 올리든, 여전히 혁신적인 것을 제공하지 못하는 점은 더 나쁘다고 할 수 있겠네요.\n\n# 싱글 플레이어 vs 온라인 멀티플레이어\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n마침내, 싱글 플레이어와 멀티플레이어 게임이 어떤식으로 서로 경쟁하는지에 대한 대화를 가졌어요. 기술이 발전함에 따라, 우리는 전 세계 사람들과 연결할 수 있는 능력도 향상되었죠. 레트로 게임 세션을 마무리하면서, 나는 혼자서 게임을 하는 시절을 생각해봤어요. 어릴 적에는 친구가 많지 않아서 자주 혼자 편안함을 찾아야 했지만, 선택할 게임 옵션으로 인해 어렸을 때 지루할 틈이 없다는 것을 말할 수 있어요.\n\n소닉 어드벤처 2, 킹덤 하츠, 파이널 판타지 X, 제트 리: 라이즈 투 아너, 혹은 콜로서스의 그림자와 같은 게임들, 항상 플레이할 게 있었죠. 하지만 이 게임들을 특별하게 만든 것은 다른 사람들이 내 옆에 없어도 즐길 수 있다는 것이죠. 이들 세계는 나 혼자서도 공유하고 완전히 감상할 수 있는 점이 매력적이었습니다.\n\n그러나 이러한 몰입 수준은 온라인 연결성이 더 많아지면서 뒷전을 밟고 있어요. 이제, 상황은 조금 달라졌는데, 당신은 혼자 게임을 하거나 가장 친한 친구들과 분할 화면 옆에 있는 것이 아닙니다. 온라인으로 연결되어, 전 세계 랭킹리스트와 게임하며, 특정 타입의 파티가 필요할 때도 있죠.\n\n이제 대부분의 게임은 공유 경험을 만들고 우리를 더 많은 사람들과 연결시키기 위해 만들어집니다. 기존의 싱글 플레이어 콘텐츠가 채워지기 어려운 것이 현실이 되고 있어요. 현재 언제든 연결될 수 있는 수십 명이나 수백 명의 플레이어들이 새로운 엔터테인먼트가 되었습니다. 그 결과, 우리는 게이머들 사이에 독선적이고 운동장에서 하지 말아야 할 행동들이 급증하고 있는 것을 보게 되었는데, 이는 게임이 탈출 수단으로서의 역할을 한층 더 약화시키고 있어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 결론\n\n게임 산업에서 변화가 일어나고 있다는 것은 의심할 여지가 없지만, 그겪는 변화가 좋은 방향으로 나아가고 있는지에 대해서는 말할 수 없어요. 기술은 한 가지 방향으로만 발전하고 있고, 개발자들이 뿌리로 돌아가지 않는다면 게임의 품질이 더욱 떨어질 것이라고 보고 있어요. 개인적으로, 우리는 지금 당장에는 콘솔의 유틸리티를 극대화할 필요가 없는 지점에 도달했다고 생각해요. 우리는 최신 하드웨어의 성능에 대한 대화를 줄이고, 게임 자체가 제공할 수 있는 즐거움에 초점을 맞추어야 한다고 봐요.\n\n이에 대해 다른 사람들의 의견을 듣고 싶어요. 콘솔의 유틸리티에 집중하는 것이 게임의 즐거움을 빼앗았다고 생각하시나요? 그래픽 최적화를 할 필요가 없다고 생각하시나요? DLC 개념에 대한 여러분의 의견은 무엇인가요? 온라인 게임이 싱글 플레이어 게임에 부정적인 영향을 미치고 있다고 생각하시나요?\n\n이에 대한 대화를 계속 이어가고 싶으시다면, 이 글에 댓글을 남겨주세요. 또는, 게임, 기술 및 DCU 관련 모든 것에 대한 저의 의견을 얻고 싶다면 'Keith Price' 채널을 구독해주세요!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 참고 자료\n\nKamil S. (2018년 7월 14일). 슈퍼 닌텐도 엔터테인먼트 시스템 - 컨트롤러. https://unsplash.com/photos/selective-focus-photography-of-snes-controller-13W6AqIKV_I 에서 확인\n\nOnur Binay. (2021년 12월 31일). 노트북에서 비디오 게임을 하는 사람. https://unsplash.com/photos/a-person-playing-a-video-game-on-a-laptop-auf3GwpVaOM 에서 확인\n\nSean Do. (2018년 8월 16일). 컴퓨터를 사용하여 fps 게임을 하는 사람. https://unsplash.com/photos/person-using-computer-playing-fps-game-EHLd2utEf68 에서 확인\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nTom Henderson. (2024년 3월 17일). EXCLUSIVE — 더 많은 플레이스테이션 5 프로 사양 상세 내용. https://insider-gaming.com/playstation-5-pro-more-specs/에서 확인하실 수 있습니다.\n\nVitalii Khodzinskyi. (2023년 5월 3일). 비디오 게임 컨트롤러의 근접 촬영. https://unsplash.com/photos/a-close-up-of-a-video-game-controller-FXlVXYTU-0s에서 확인하실 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-05-18-TheLandscapeofGamingHaveWeSacrificedFunforPower_0.png"},"coverImage":"/assets/img/2024-05-18-TheLandscapeofGamingHaveWeSacrificedFunforPower_0.png","tag":["Tech"],"readingTime":8},{"title":"당신의 첫 번째 플랫포머 게임을 Godot에서 만들어보세요","description":"","date":"2024-05-18 15:58","slug":"2024-05-18-MakeyourfirstPlatformergameinGodot","content":"\n# 소개\n\n안녕하세요! 이 블로그는 Godot을 사용하여 간단한 플랫포머 게임을 만드는 방법을 소개하고 있어요! Godot은 사용자 친화적 인터페이스와 포괄적인 게임 개발 기능으로 유명한 견고한 게임 엔진이에요. 그러나 게임 개발에 뛰어들기는 쉽지 않아요. 특히 초보자에게는 물 속에서 숨 쉬는 것 같은 느낌일지도 모르죠. 하지만 걱정 마세요! 이 여행을 시작하며 Godot의 기본원리를 탐구하고, 작동 방식을 이해하며, 플레이어 캐릭터, 게임 세계를 만들고 플레이어를 도전할 제약 조건을 구현해볼 거에요. 함께 게임을 만들며 배움을 즐겁게 만들어봐요!\n\n# Godot 재정리\n\nGodot은 직관적인 인터페이스를 제공해 환경을 설계하고, 플레이어 캐릭터를 만들고, 애니메이션을 구현할 수 있는 다재다능한 게임 엔진이에요. Godot은 파이썬과 유사한 스크립팅 언어인 Gdscript를 사용해 새로운 이용자들에게 접근하기 쉽게 해줘요. Godot에서는 모든 요소가 노드로 표현돼요. 플레이어 캐릭터든, 오디오 소스든, 게임 개체든, 모두 씬 내에 구성된 노드들이에요. 게다가 씬들은 서로 중첩하여 복잡한 레벨 디자인과 상호 작용을 할 수 있어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저희 게임은 세 가지 필수 구성 요소로 구성되어 있습니다:\n\n- 플레이어 → 우리의 주요 캐릭터를 대표합니다.\n- 세계 → 플레이어가 이동하고 상호 작용하는 곳\n- 킬존 → 플레이어 이동을 제한하는 도전적인 영역\n\n누군가가 도약하는 것을 막는 것처럼, 우리 게임의 제한은 흥미와 도전을 더합니다. 예를 들어, 우리는 플레이어가 공허로 떨어졌을 때 플레이어의 죽음과 리스폰을 어떻게 처리할지 살펴볼 것입니다. 아래 인포그래픽은 장면, 노드 및 중첩 기능에 대한 시각적 개요를 제공합니다.\n\n<img src=\"/assets/img/2024-05-18-MakeyourfirstPlatformergameinGodot_0.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 미리보기\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*CwIotC0mkJa6RKpamFXY2w.gif)\n\n# 설정\n\n우선적으로, 여기서 Godot을 다운로드합니다. 이 프로젝트에 사용된 에셋은 Kenney의 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nGodot을 시작하고 +새로 만들기 버튼을 클릭하고 프로젝트 이름을 입력합니다. 그런 다음 폴더 만들기를 클릭하고 프로젝트 경로를 지정합니다. 마지막으로 만들기 및 편집 버튼을 클릭합니다.\n\n![이미지](/assets/img/2024-05-18-MakeyourfirstPlatformergameinGodot_1.png)\n\nFileSystem에 assets, scripts 및 scenes라는 3개의 폴더를 생성합니다. 이제 Kenney에서 다운로드한 에셋을 assets 폴더로 드래그 앤 드롭할 수 있습니다.\n\n![이미지](/assets/img/2024-05-18-MakeyourfirstPlatformergameinGodot_2.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 플레이어 씬 만들기\n\n플레이어를 배치할 게임 환경이 필요합니다. 게임 씬을 구축하기 위해 새 노드 만들기 아래에 있는 2D 씬 옵션을 선택하고 game으로 이름을 바꿉니다. 파일을 scenes 폴더에 저장하세요.\n\n이제 플레이어 씬을 만들어 봅시다. 이를 위해 + 아이콘을 클릭하여 새 씬을 생성합니다. 플레이어의 루트 노드는 CharacterBody2D가 될 것입니다. 새 노드를 추가하려면 Cmd(Ctrl)+A를 누르고 CharacterBody2D를 검색하세요. 이는 스크립트에 의해 이동되는 캐릭터용으로 특별화된 2D 물리 바디입니다.\n\n![이미지](/assets/img/2024-05-18-MakeyourfirstPlatformergameinGodot_3.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-05-18-MakeyourfirstPlatformergameinGodot_4.png\" />\n\n이제 플레이어에 그래픽을 추가해야 합니다. 이를 위해 Cmd(Ctrl)+A를 눌러 AnimatedSprite2D를 검색한 후 생성을 클릭하세요. 비디오의 단계에 따라 애니메이션된 플레이어를 씬에 추가하세요. 가로 및 세로 타일은 타일맵의 크기에 따라 조정되어야 함을 유의하세요.\n\n그 후에 CharacterBody2D에 노드에 모양이 없어 다른 노드와 충돌하거나 상호작용할 수 없으며 노드에 노란색 경고 표시가 나타납니다. 이를 해결하기 위해 물리 노드를 추가하여 물리 엔진이 작동할 수 있는 노드를 추가해야 합니다. 새 노드를 추가하려면 Cmd(Ctrl)+A를 눌러 CollisionShape2D를 검색하세요. 인스펙터에서 모양 버튼을 클릭하여 모양을 정의하고 캐릭터에 적합한 모양을 선택하세요. 저는 캡슐 모양을 사용합니다. 필요에 따라 크기를 조정하고 씬을 저장하세요.\n\n<img src=\"/assets/img/2024-05-18-MakeyourfirstPlatformergameinGodot_5.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 플레이어를 게임에 넣으려면 플레이어 씬을 게임 씬으로 끌어다 놓기만 하면 됩니다. 제어하고 표시되는 내용을 보려면 카메라를 추가해야 합니다. 이를 위해 Cmd(Ctrl)+A를 누르고 카메라를 검색하세요. 생성을 클릭하고 게임에서 보이고 싶은 영역을 조정하세요.\n\n![이미지](/assets/img/2024-05-18-MakeyourfirstPlatformergameinGodot_6.png)\n\n변경 사항을 저장하고 실행 버튼을 클릭하여 게임을 시작하고 캐릭터를 볼 수 있습니다.\n\n![이미지](/assets/img/2024-05-18-MakeyourfirstPlatformergameinGodot_7.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n플레이어가 이동하지 않네요 :(\n이 문제를 해결하려면 플레이어 노드를 열고 필터 막대 옆에있는 Attach new script 버튼을 클릭하세요. 기본 템플릿을 선택한 상태로 유지한 채, 경로에서 스크립트 폴더를 선택하고 생성을 클릭하세요.\n\n기본 템플릿을 사용하면 플레이어가 화살표 키와 스페이스바를 사용하여 좌우로 이동하고 점프할 수 있게됩니다. 캐릭터 속도와 점프 속도는 스크립트 내에서 이 값을 변경하여 조절할 수 있습니다.\n\n이제 게임을 재시작하세요!\n\n캐릭터가 바로 떨어진 것이 보이나요? 이는 플레이어가 서 있을 땅이 없기 때문입니다! 플레이어는 이제 준비가 되었으니, 세계를 생성해봅시다!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 월드 씬 만들기\n\n이제 플레이어가 서 있을 실제 지면을 만들고 있기 때문에 타일맵을 사용합니다. 배경은 간단히 배경 이미지를 씬으로 드래그 앤 드롭하여 추가합니다. 비디오를 따라가며 세계를 만들어 보세요.\n\n카메라가 플레이어를 따라가도록 만드려면, 카메라2D 노드를 플레이어 노드로 드래그하기만 하면 됩니다. 게임의 가장 아래 부분에서 카메라 중앙까지의 거리를 측정하고, 해당 수치를 카메라 인스펙터의 하한 제한에 추가하여 카메라가 아래쪽으로 빈 공간을 표시하지 않도록 합니다.\n\n# 킬존 만들기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n킬존을 생성하려면, 인스펙터에서 캐릭터의 충돌 레이어를 1에서 2로 변경합니다. 이렇게 하면 캐릭터가 새 레이어에 배치되어 킬존 영역을 캐릭터에게만 할당할 수 있습니다.\n\n![킬존 만들기](/assets/img/2024-05-18-MakeyourfirstPlatformergameinGodot_8.png)\n\n킬존을 만드는 방법은 비디오를 따라하면 됩니다. 주요 단계는 킬존이라는 Area2D 씬을 만들고, 이를 게임에 추가한 다음, worldBoundary와 충돌 모양을 만들어 캐릭터가 경계를 넘어서면 캐릭터를 죽이는 부분입니다. 경계는 작아 보이지만 무한히 이어집니다. 죽이고 다시 생성하는 부분은 스크립트에서 처리됩니다.\n\n킬존에 사용된 스크립트:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 마무리\n\n축하해요! 우리는 Godot을 사용하여 게임 개발의 흥미로운 세계로 첫 걸음을 내딛었어요. 간단한 플랫포머를 만들면서 노드, 씬 그리고 GDScript로 스크립팅하는 기본 개념을 다뤘어요.\n\n기억해요, 게임 개발은 코딩만큼 반복과 배움의 과정이에요. 게임 개발의 세계는 광활하고 다채롭고, 각 프로젝트를 통해 뛰어남에 한 걸음 가까워져요. 이 블로그가 유익하게 느껴졌으면 좋겠어요. 언제든지 피드백과 제안을 기다리고 있어요.\n\n즐거운 코딩하시고, 여러분의 게임이 만드는 과정이 플레이하는 것만큼 즐거워지길 바래요!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 참고 자료\n\nGodot 문서\nBrackeys Godot 초보자 튜토리얼\n","ogImage":{"url":"/assets/img/2024-05-18-MakeyourfirstPlatformergameinGodot_0.png"},"coverImage":"/assets/img/2024-05-18-MakeyourfirstPlatformergameinGodot_0.png","tag":["Tech"],"readingTime":8},{"title":"내부 데이터 제품을 데이터 엔지니어로서 고려하는 방법","description":"","date":"2024-05-18 15:56","slug":"2024-05-18-HowtothinkaboutInternalDataProductsasaDataEngineer","content":"\n# 나에 대해\n\n안녕하세요! 저는 휴고 루입니다. 런던에서 M&A 업무를 시작으로 JUUL로 이직하여 데이터 엔지니어링에 빠져들었습니다. 잠시 금융 분야로 돌아온 후, 런던 소재 핀테크 기업 Codat에서 데이터 부서를 이끌었습니다. 지금은 Orchestra의 CEO입니다. Orchestra는 데이터 팀이 데이터를 안정적이고 효율적으로 프로덕션 환경에 배포할 수 있도록 도와주는 데이터 릴리스 파이프라인 도구입니다. 🚀\n\n우리의 Substack와 내부 블로그도 꼭 확인해주세요! ⭐️\n\n# 소개\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n현재는 데이터 팀 인원의 급격한 감소와 데이터에서 가치 추출 능력의 감소 때문에 Data Products이 현재 핫한 주제입니다. 데이터를 제품으로 생각하거나 \"데이터를 제품처럼 취급하기\"는 데이터를 이해하고 관리하며 데이터 엔지니어링 팀이 비즈니스를 위해 생산하는 Data Products의 속도와 수용을 향상시키는 인기있는 접근 방식입니다.\n\n이 기사에서는 데이터 엔지니어로써 내부 데이터 제품을 어떻게 생각해야 하는지에 대해 알아볼 것입니다. 데이터 제품에 관한 몇 가지 일반적인 질문에 답하고, 여러분이 처음 데이터 제품을 만드는 것에 대해 어떻게 생각하는지 보여줄 것입니다.\n\n# 데이터 제품이란?\n\n다양한 강연, 소셜 미디어 게시물, 블로그 게시물 및 사고 리더십 자료들을 제외하고 데이터 제품은 본질적으로 간단한 개념입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아이디어는 이중으로 이루어져 있어요. 첫 번째는 데이터에 제품 관리 원칙을 적용하는 것입니다. 작업 방식이 있습니다. 아래에 나열된 아이디어의 예시는 다음과 같아요:\n\n- 왜부터 시작하기\n- 문제를 이해하기\n- 열심히 집중하기\n- 팀에 권한 부여하기\n- 불확실성 수용하기\n- 입력, 출력, 결과 및 학습 균형 맞추기\n- 반복, 반복, 반복\n\n위의 원칙들을 보면, 이것들은 전형적인 데이터 엔지니어 직무 설명에서 보는 것과 매우 다릅니다 (우리가 고민하는 이유가 분명합니다).\n\n두 번째 아이디어는 데이터를 다른 사람에게 제공하는 서비스로 보는 대신에 제품으로 취급하는 것입니다. 이것은 Moody's나 Factset과 같은 기업에게는 훨씬 더 많은 의미를 갖게 됩니다. 그들의 시장은 데이터를 판매하는 것이기 때문에 이것은 훨씬 더 명확합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n거의 모든 기업이 데이터 기업이 되고 있다는 말에 흥분을 느낄 수 있지만, 대부분의 경우에는 현실적이지 않거나 지속할 수 없는 것입니다. 따라서 더 큰 데이터 제품 흥행은 내부 데이터 제품에 집중되어 있거나 비즈니스의 다른 이해 관계자들을 위해 데이터 엔지니어링 팀이 하는 일에 대해 생각하는 것입니다.\n\n이에 대해 중점을 두게 될 것입니다.\n\n# 내부 데이터 제품의 측면\n\n## 제품으로서의 데이터를 고려하기 전에\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 데이터 팀은 서비스 데스크로 운영되며 요청을 수락합니다.\n- 데이터 팀이 제공하는 것: 테이블, 대시보드, 가끔 예측 모델\n- 데이터 팀이 하지 않는 것: 비즈니스와 논의하는 일\n\n## 데이터를 제품으로 보고나서\n\n- 데이터 팀은 이해관계자들과 적 pressing한 비즈니스 문제를 해결하기 위해 미리 소통합니다.\n- 데이터 팀은 비즈니스 이해관계자와 함께 끝단 요구사항을 이루고자 하는 시각에서 이해합니다(데이터 테이블? 대시보드? 다른 것? 조합?).\n- 데이터 팀은 데이터 자산 이상을 만들어내며, 내부 마케팅 활동에 참여하고, 교육 세션을 운영하며, 문서 작성하고, 경보를 활성화하며, 설명 영상을 제작합니다 등.\n- 데이터 팀은 데이터 제품의 성능을 모니터링하고 이를 우선순위 설정에 활용합니다.\n\n이것이 잠재적으로 흥미로운 데이터 제품의 \"작업 방식\" 변화입니다. 자원소모가 더 많을 수 있지만, 더 적으면 더 나은 것이고, 자가 서비스 분석이 신화라면, 이 접근 방식은 많은 데이터 팀에게 더 나은 옵션일 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 데이터 제품 예시\n\n이것을 예시로 살펴봅시다.\n\n내부 소프트웨어 제품의 사용량을 보여주는 대시보드가 데이터 제품의 한 예입니다.\n\n- 최종 사용자: 제품 팀\n- 문제: 로드맵 결정을 위한 사용량 트렌드 이해 및 오류 디버깅\n- 해결책: 관련 정보가 담긴 대시보드, 그러나 특정 오류에 대한 관련 이해 관계자에 대한 자동 슬랙 알림도 함께 제공. 누가 무엇을 제어하는지에 관한 Confluence 문서화\n- 추가 기능: 전송된 알림 수, 대시보드 사용량, 및 파이프라인 비용 추적\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n오케스트라에서는 \"데이터 제품이란 무엇을 의미하는가\"에 대한 의미에서, 우리가 이 중 하나를 가지고 있으며, 바로 위에 설명된 것과 똑같습니다.\n\n우리에게는 대시보드가 있습니다:\n\n![대시보드 이미지](/assets/img/2024-05-18-HowtothinkaboutInternalDataProductsasaDataEngineer_0.png)\n\n의사 결정이 필요할 때 이해관계자들을 알리기 위한 알림이 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n`<img src=\"/assets/img/2024-05-18-HowtothinkaboutInternalDataProductsasaDataEngineer_1.png\" />`\n\n내부 데이터 제품에 대한 생각 방식으로써 데이터 엔지니어링자로서 어떻게 고려해야 하는지에 대한 내용입니다.\n\n그리고 데이터 제품의 사용은 면밀히 모니터링됩니다:\n\n`<img src=\"/assets/img/2024-05-18-HowtothinkaboutInternalDataProductsasaDataEngineer_2.png\" />`\n\n이러한 기능 집합과 서비스 데스크 스타일 메인에서 변경되는 프로세스는 데이터 제품 주도 접근 방식과 표준 데이터 기능 접근 방식의 차이입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 데이터 제품을 만드는 방법은 무엇인가요?\n\n뭐든 많은 일처럼 보이죠? 결국 아무도와 대화하지 않고 문서화되지 않은 테이블을 작성하는 것이 위의 모든 것보다 훨씬 빠를 것입니다!\n\n하지만 시작할 때는 덜이 더 좋습니다. 데이터 제품 후보를 고를 때 사용하는 기준은 다음과 같습니다.\n\n## 고가치\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n고가치 사용 사례를 선택하세요. 이상적으로 첫 번째 데이터 제품은 중요한 사람에게 중요한 기능을 제공하거나 중요한 문제를 해결해야 합니다. 초기 단계부터 데이터 제품의 가치를 증명하는 데 중요합니다.\n\n## 간편함\n\n구현하기 쉬운 파이프라인을 선택해 보세요. 이곳에서 하지 말아야 할 좋지 않은 예는 마케팅 프로젝트입니다. 마케팅 데이터는 알려진 바와 같이 복잡하며 다양한 곳에서 가져옵니다. 마케팅 ROI를 계산하는 것은 간단하지 않습니다.\n\n더 나은 예는 간단한 제품 사용 대시보드나 영업팀을 위한 지능형 분석이 될 수 있습니다. 후자의 예에서는 일반적으로 소수의 소스에서 데이터를 추출하여 내부 데이터 제품을 구축하는 원형 과정을 단순화할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 격리\n\n이것은 단순성과 얽혀 있지만, 매우 목표를 정확히 설정하거나 독립적인 사용 사례를 선택하면 데이터 제품을 다른 파이프라인과 독립적으로 제공할 수 있습니다. 이렇게 하면 종속성이 적어지므로 속도가 높아집니다. 예를 들어, 특정하지만 중요한 데이터가 될 수 있습니다.\n\n## 친숙함\n\n이상적으로는, 사람들이 익숙한 파이프라인을 선택해야 합니다. 이렇게 하면 결과물에 대한 이해도가 높으며 기대하는 이해 관계자가 무엇을 기대하는지에 대한 확신이 생깁니다. 이렇게 하면 더 빨리 제공할 수 있습니다(무엇을 제공하는지 알기 때문에)만 일반적인 가치를 빠르게 추가할 수도 있습니다(가치 있는 것으로 이미 알고 있는 것을 보강하게 됩니다). 다른 한편으로는, 완전히 새로운 일을 하지 않도록 노력해보세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 참여 독려\n\n비즈니스 다른 곳에서 어떤 지지를 받고 있는 것을 선택하는 것이 좋습니다. 데이터 제품의 수용률을 향상시키는 것 뿐만 아니라 더 접근 가능한 소스로부터 피드백을 수집하는 데도 도움이 됩니다. \"데이터 제품을 공개하자\" 라는 것이 마침내 실망스러운 피드백만 받아들이고 대상 시청자로부터 신뢰를 잃는 것을 원하지 않을 것입니다.\n\n## 생성적 인공지능 및 AI 제품에 대한 참고\n\n생성적 인공지능이 이 구조에 매우 잘 맞는 것을 알 수 있을 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nAI Chatbot와 같은 제품은 데이터 파이프라인을 통해 활성화됩니다. 비구조적 데이터를 수집하고 Generative AI를 사용하여 정리한 다음 이를 임베딩으로 변환할 수 있습니다.\n\n이러한 임베딩은 ChatBot에서 사용됩니다.\n\n전체적으로 Generative AI 제품은 데이터 파이프라인과 Chatbot으로 구성됩니다. 이 경우 사용량 모니터링은 ChatBot이 상호 작용하는 정도를 확인해야 하기 때문에 조금 더 복잡하지만 데이터 파이프라인의 비용 요소를 모니터링하는 것은 거의 동일합니다!\n\n# 결론\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 기사에서는 데이터 제품 주변에 왜 관심이 쏠렸는지와 그 의미에 대해 논의했습니다. 모든 기업이 데이터 기업으로 발전하는 것이 아니라 데이터 팀이 비즈니스 이해관계자를 위해 어떻게 일하는지에 초점을 맞추었습니다.\n\n우리는 데이터 제품을 만드는 것이 현재의 작업 방식에서 벗어난 것으로 보인다는 것을 알았습니다. 이는 좀 더 서비스 중심적인 방식입니다. 데이터 제품 마인드셋으로 전환하는 것은 \"문제 해결 티켓을 완료하기\"에 더 많은 노력이 필요하지만, 이는 더 나은 최종 제품을 만들어내며 데이터로부터 더 큰 가치를 창출할 수 있게 됩니다.\n\n마지막으로, 갈등을 선택하는 것이 중요하며 단순함, 참여, 격리 정도 및 친숙함과 같은 요소가 데이터 제품의 성공에 영향을 줄 수 있다는 것을 알게 되었습니다.\n\n더 자세히 이야기하거나 생각을 나누고 싶다면 언제든지 알려주세요! DM은 열려 있어요 🌲\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 오케스트라에 대해 더 알아보기\n\n오케스트라는 데이터를 최대한 인간적으로 가치를 뽑아내는 플랫폼입니다. 또한 다양한 사용 사례와 솔루션에 대한 해결책을 제공하는 기능이 풍부한 조정 도구입니다. [우리의 문서](https://example.com)를 확인해보세요. 그리고 우리의 통합을 확인해보세요 - 우리가 관리하기 때문에 여러분은 파이프라인을 즉시 시작할 수 있습니다. 저희는 오케스트라 팀과 게스트 작가들이 함께 쓴 [블로그](https://example.com)와 조금 더 심도 있는 내용을 다룬 [화이트페이퍼](https://example.com)도 갖추고 있습니다.\n","ogImage":{"url":"/assets/img/2024-05-18-HowtothinkaboutInternalDataProductsasaDataEngineer_0.png"},"coverImage":"/assets/img/2024-05-18-HowtothinkaboutInternalDataProductsasaDataEngineer_0.png","tag":["Tech"],"readingTime":9},{"title":"폐기 포맷되지 않은 혐오 이메일이 인기 있는 Nodejs 프로젝트에 충분했다","description":"","date":"2024-05-18 15:55","slug":"2024-05-18-DecommissionedAnUnformattedHateEmailWasEnoughtForAPopularNodejsProject","content":"\n![Image](/assets/img/2024-05-18-DecommissionedAnUnformattedHateEmailWasEnoughtForAPopularNodejsProject_0.png)\n\n# 시간이 부족하며 사용되지 않는 이유와 엄청난 이메일이 LDAPjs의 주요 관리자를 폐지하게 했습니다. 사람들은 언제 코드를 서식 지정하는 법을 배울까요?\n\n제임스 서머스는 여러 중요한 프로젝트를 유지하는 데 있어 Node.js 광 범주 커뮤니티에서 가장 존경받는 인물 중 한 명입니다.\n\n여러분이 확실히 알고 있는 이 프로젝트들 중 하나인 Fastify, 가벼운 Node.js 웹 서버 또는 Pino, 빠른 JSON 로거 외에도 PL/JSON의 핵심 관리자로 활동했습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그는 미국 Clayton State University에서 수학 학사 학위를 받았어요.\n\n2019년 8월부터는 다른 Node.js 보석인 LDAPjs를 유지하고 있어요.\n\nLDAP는 통신 프로토콜이에요.\n\n서버 또는 프린터와 같은 장치를 발견하고 연결하기 위해 많은 조직에서 널리 사용되는 표준이에요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nLDAPjs는 Node.js를 위한 프로토콜 구현체입니다. 이를 통해 JavaScript 개발자들은 LDAP를 쉽게 활용하여 서비스를 구축할 수 있습니다.\n\nLDAPjs를 사용하는 회사 및 프로젝트로는 시게이트, Tracktr, Infiscal, Homarr, OpenSign, 아마존 등이 있습니다.\n\n이 목록은 일부이며 더 많은 회사와 프로젝트가 있습니다.\n\n이 프로젝트는 성공적이고 폭넓게 사용되는 오픈 소스 프로젝트로, 1.6천 개의 스타, 402 개의 포크 및 68명의 기여자가 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n오늘은 아쉽게도 제임스 서머스가 프로젝트를 아카이브하기로 결정했어요. 이는 해당 상태에서 새로운 기여를 받지 않지만 여전히 온라인에서 이용 가능한 것을 의미합니다.\n\n아마도 오래되었거나 전혀 사용되지 않았을 것이라고 생각했어요. 하지만 실제로 사용 중이며 활발히 개발되고 있어요. 최신 버전은 2023년 12월에 나온 것으로 오랜 기간 동안 안정적으로 운영되는 프로젝트에게 자연스럽죠.\n\n그렇다면 무슨 일이 있었을까요?\n\n프로젝트의 공식 페이지에 가면 프로젝트 폐지의 이유를 확인할 수 있어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이것들은 세 가지 주요 문제로 요약됩니다:\n\n- 핵심 유지관리자가 시간이 부족합니다.\n- 그는 더 이상 사용하지 않을 위치에 있습니다.\n- 혐오 메일을 받았습니다.\n\n첫 두 가지 포인트는 먼저 논의할 가치가 있습니다. 제임스는 이 프로젝트를 자신의 회사에서 필요할 때 개발했습니다. 하지만 그는 그것이 필요하지 않는 다른 회사로 이직했기 때문에 더 이상 발전시키는 목적이 없습니다.\n\n이해할 만한 상황입니다. 그는 어떤 기능은 완성하는 데 전체 근무 주를 소요할 것이라고 적었습니다. 이는 그가 감당할 수 없는 시간이라고 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그것도 물론 합리적이에요. 교육을 받은 전문가가 어떤 대가도 받지 않는 프로젝트에 시간을 투자하는 이유가 뭐죠?\n\n기업을 위해 오픈 소스 프로젝트를 유지하고 있는 것보다 더 재미있는 여가 활동이 많이 있어요.\n\n놀랍기는 한데, 이 회사들이 LDAPjs 개발자가 이용하는 프로젝트에 시간을 할애할 수 있도록 돈을 지불하지 않았다는 점이에요.\n\n프로젝트에 대한 안타까운 순간이기는 하지만, 모든 다른 프로젝트들과 마찬가지로 James와 다른 기여자들이 몇 년 동안 프로젝트에 기여한 노고를 감사히 여기는 좋은 순간이기도 해요. 우리는 James와 세계 곳곳의 수백 명의 개발자들이 많은 오픈 소스 프로젝트를 봉사하는 것을 기억해야 해요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n주목받는 개발자들은 종종 오픈 소스 프로젝트에서 무료로 일하면서 헤드라인까지 이르지 않습니다. 하지만 그들은 이것을 의미 있는 일로 생각하기 때문입니다.\n\n안타깝게도, 모든 사람이 이를 알고 인정하려고 하거나 예의범절을 유지하려고 하는 것은 아닙니다.\n\n제임스는 LDAPjs 프로젝트를 사용하는 데 문제가 있어 한 사람에 의해 공격당했습니다. 이메일은 모든 기준을 크게 넘어서기 때문에 인용하지 않겠습니다.\n\n제임스에게는 그 이메일이 충분했습니다. 그는 해당 이메일을 언급하여 프로젝트의 해지 원인 중 하나로 언급했습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이해하기 쉽네요. 그는 몇 년 동안 많은 도구로 넓은 커뮤니티와 회사를 지원하기 위해 열심히 일해왔어요. 그는 보상도 받지 않고 인정받지도 않았어요. 결국 그저 악플 이메일을 받게 되었어요.\n\n기술적으로 가장 엄청난 점은 그가 코드를 서식을 맞추는 데 신경쓰지 않았다는 것이죠:\n\n![디렉토리](/assets/img/2024-05-18-DecommissionedAnUnformattedHateEmailWasEnoughtForAPopularNodejsProject_1.png)\n\n그 이메일의 엄청난 부분보다 더 많은 이야기를 하는군요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그게 우리가 정말 알아야 할 모든 정보에요. LDAPjs가 폐지되었지만, 제임스는 새로운 담당자나 조직이 프로젝트를 안정적이고 안전한 방식으로 이어갈 수 있는지 올바르게 검증할 수 있다면 프로젝트를 좋은 손에 맡길 준비가 되어 있다고 말했어요.\n\n그리고 온라인 상태인 프로젝트는 여전히 사용할 수 있고 또한 포크를 개발할 수도 있어요.\n\n이는 LDAPjs 사용자들이 안전하다는 뜻이지만, 중요한 오픈 소스 프로젝트가 이러한 중요한 기여자를 잃지 않았으면 하는 바람도 있어요.\n\n내가 사용하는 프로젝트의 유지 보수자들에게 인정의 이메일을 보내볼까 생각 중이에요. 그들에게 하루를 만들어줄 수 있을 거에요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n테이블 태그를 마크다운 형식으로 변경해주세요.\n","ogImage":{"url":"/assets/img/2024-05-18-DecommissionedAnUnformattedHateEmailWasEnoughtForAPopularNodejsProject_0.png"},"coverImage":"/assets/img/2024-05-18-DecommissionedAnUnformattedHateEmailWasEnoughtForAPopularNodejsProject_0.png","tag":["Tech"],"readingTime":6}],"page":"102","totalPageCount":113,"totalPageGroupCount":6,"lastPageGroup":13,"currentPageGroup":5},"__N_SSG":true}