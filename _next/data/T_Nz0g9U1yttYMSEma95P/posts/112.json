{"pageProps":{"posts":[{"title":"시대를 초월한 이야기 현대 개발자를 위한 Chronos v14","description":"","date":"2024-05-17 18:02","slug":"2024-05-17-AtaleasoldastimeforthemoderndeveloperChronosv14","content":"\n![Chronos](/assets/img/2024-05-17-AtaleasoldastimeforthemoderndeveloperChronosv14_0.png)\n\n안녕하세요! Chronos, 강력한 모니터링 및 경보 도구가 큰 업데이트를 받았어요! 14.0 버전에서 여러 가지 새로운 기능과 개선 사항을 소개했답니다. 더 좋은 경험을 위해 업데이트 내용을 살펴보세요.\n\n처음 사용하는 분들을 위해, Chronos는 엔지니어들이 애플리케이션을 원할하게 유지하기 위해 서버 통신을 모니터링하는 데 도움을 주는 도구에요. Chronos는 도커 및 쿠버네티스와 같은 컨테이너화된 및 컨테이너화되지 않은 마이크로서비스의 건강 상태와 웹 트래픽을 면밀히 모니터링하는 종합적인 개발자 도구에요. REST API나 gRPC를 통해 서비스 간 통신을 하든, Chronos가 전부 책임져 줄 거예요. Chronos는 로컬 또는 Amazon Web Services (AWS)에 호스팅된 환경에서도 완벽하게 작동해요. 게다가 실시간 데이터 모니터링과 슬랙 또는 이메일을 통한 자동 알림 기능도 구비되어 있어요.\n\n지금 바로 확인해보세요!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![image](https://miro.medium.com/v2/resize:fit:1200/1*R9Hj0YK1ws5Z8GaqZpp-Fg.gif)\n\n그래서 무슨 변화가 있나요?\n\n- 원클릭 데모\n\n- 예제 버튼을 클릭하면 Chronos가 추적하는 각 서비스에 대한 예시를 즉시 생성합니다. 이러한 서비스와 관련된 실시간 지표와 모니터링 데이터를 볼 수 있습니다. 이 예시에서는 Chronos의 기능을 보여주며, 사용자가 데모 어플리케이션을 처음부터 설정하는 번거로움 없이 앱 사용에 집중할 수 있습니다.\n- 추상적인 문서를 읽는 대신 Chronos의 작동 방식을 시각적으로 확인할 수 있습니다. 이를 통해 사용자들이 Chronos가 모니터링하는 핵심 지표를 이해하고 서비스가 어떻게 상호작용하고 의존하는지 볼 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n2. 향상된 문서화\n\n- 우리는 설치 및 시작 지침을 개선하여 찾기 쉽고 따르기 쉽게 만들었습니다. 숙련된 사용자든 초보자든, 우리의 업데이트된 문서의 명확성과 사용성을 평가하실 것입니다.\n- 이 버전에는 크로노스를 설치하고 사용하기 쉽게 만들기 위한 업데이트된 설치 및 시작 지침도 포함되어 있습니다.\n\n3. 버그 수정 및 구문 업데이트\n\n- 몇 가지 성가신 버그를 해결하고 코드베이스를 조직화하여 더 나은 개발 환경을 보장했습니다. 게다가 MUI(Material-UI)도 최신화하여 가장 세련되고 최고의 사용자 경험을 제공합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1200/1*Ic1xhrBEhWSOUu4VlIA1Pg.gif\" />\n\n지금 바로 해보세요!\n\nChronos 14.0의 매력을 놓치지 마세요. 시작하려면:\n\n- GitHub의 최신 README 지침을 따르세요.\n- npm 패키지를 설치하세요.\n- 모니터링을 위해 메트릭을 활성화하는 예시 버튼을 탐험해보세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n테이블 태그를 Markdown 형식으로 변경하십시오.\n\n| 이름          | LinkedIn | GitHub |\n| ------------- | -------- | ------ |\n| Michael Tagg  | 링크드인 | 깃허브 |\n| Sofia Sarhiri | 링크드인 | 깃허브 |\n| Ted Pham      | 링크드인 | 깃허브 |\n| Stephen Yang  | 링크드인 | 깃허브 |\n\n위에 있는 테이블을 Markdown 형식으로 변경하였습니다.\n","ogImage":{"url":"/assets/img/2024-05-17-AtaleasoldastimeforthemoderndeveloperChronosv14_0.png"},"coverImage":"/assets/img/2024-05-17-AtaleasoldastimeforthemoderndeveloperChronosv14_0.png","tag":["Tech"],"readingTime":3},{"title":"기술 면접에서 돛을 올리고 싶나요 제발, 제발 용어를 설명해주세요","description":"","date":"2024-05-17 18:02","slug":"2024-05-17-WantToAceThatTechJobInterviewPleasePleaseExplainYourJargon","content":"\n## 좌절한 오랜 면접관의 유용한 전술\n\n![이미지](/assets/img/2024-05-17-WantToAceThatTechJobInterviewPleasePleaseExplainYourJargon_0.png)\n\n소프트웨어 엔지니어링 분야는 매우 광범위하고 다양하기 때문에 동일한 회사의 동일한 하위 분야에서 일하는 엔지니어조차 서로 낯선 기술 용어를 설명해야 할 때가 있습니다. 제 분야에서는 때로는 제가 미쳤다고 생각하는 과학자가 쓴 API 문서를 읽고 있는 듯한 느낌을 받을 때도 있습니다. 따라서 어떤 취업 면접에서도, 면접관이 사용하는 용어의 절반이 이해하지 못할 것으로 예상됩니다.\n\n저는 소프트웨어 엔지니어 및 엔지니어매니저로서 20년의 경력을 가진 입장에서 75회 이상의 채용 면접을 진행했으며, 이 작은 하나의 문제가 저를 화나게 만들었습니다: 지원자가 낯선 용어를 설명하지 못할 때. 여기서 말하는 '용어'란 기술 이름, 기업 내부 용어, 그리고 아크로니뮹들을 말합니다.¹\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저는 현재 Yelp에서 행동 면접을 진행하고 있습니다. 저는 iOS 엔지니어이며, 대부분의 지원자들이 아니지만, 여러분의 회복력, 대인 관계 기술, 감성 지능 등을 평가하는 데 제게 장애물이 되어선 안 되겠죠. 이러한 질을 알아보기 위해 이전 학교나 업무 경험에 대해 물어보게 되는데, 여러분의 설명하지 않은 용어로 당황스러워질 때가 있어요. 가령, \"... Kinesis에서 실행 중인 Kubelet 컨테이너 내의 Kafka 커넥터...\" 같은 말을 하면, 그 순간 제게는 완전히 외국어가 되죠.\n\n그리고, 제 개인적인 의견으로는, 아마 Yelp에서는 몇 가지 용어를 설명하지 않아도 누구도 여러분을 비난하지는 않을 것 같아요. 그런 용어에 대해 추후 질문하면 되니까요! 하지만 이해하지 못하는 것에 대해 무시하면 제 마음 한 조각이 조금 무너집니다.\n\n적어도 어쩔 수 없이 어느 정도의 용어를 사용해야 하니까, 이에 대한 도움이 되는 일부 팁에 대해 이야기해봅시다.\n\n# 용어 설명을 위한 전술\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 면접관을 미리 조사하세요\n\n면접을 볼 사람을 미리 알고 있다면 온라인에서 그들을 찾아보세요(LinkedIn 등). 적어도 그들이 어떤 사람인지 대략적으로 알 수 있을 겁니다. 예를 들어 안드로이드 개발자인데, 면접관이 온전히 리눅스를 수정하여 와이파이 고양이 급식기를 만든 경력이 있다면 모든 것을 설명해야 할 필요가 있다고 가정해보세요.\n\n## 면접관에게 당신을 방해하도록 권유하세요\n\n복잡한 설명을 시작하기 전에 \"내 말이 통하지 않으면 언제든지 방해해주세요\"라고 시작할 수 있습니다. 적은 개선이긴 하지만, 특히 면접관이 수동 청취 방식으로 변경하는 경우에 좋은 방법입니다. 저와 같이 경험이 많은 면접관은 이해 못 할 것을 떠들어서 시간을 낭비하지 않게 하기 위해 언제든지 당신을 방해할 겁니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 인터뷰어가 혼란스러워하는 것을 미리 예측하거나 알아차리세요\n\n가끔 인터뷰어의 비언어적 단서에 집중하기가 어려울 수 있다는 걸 알겠어요. 이미 수많은 일이 벌어지고 있지요. 긴장하고, 마지막 질문에 대한 답변을 제대로 했는지 궁금해하고, 방에 잠금을 걸지 않고 들어온 고양이 키블스로 인해 주위에 위협적으로 서서히 다가오는 이 애옹이가 당신의 시선에 영향을 준다면서 키보드 위로 뛰어 올라가서 카메라 화면에 들어오는 모습 말입니다.\n\n저라면 상황을 고려하고 여유를 부려줄 거예요, 그리고 당신의 고양이에게 인사를 하는건 좋아할 거예요. 그래도, 인터뷰어가 혼란에 빠졌을 때 민감하게 대처하면 더 좋은 인상을 남길 거예요. 그럴 때는 한 발 물러나서 피드백을 요청하세요. “X를 설명해야 할까요?” 또는 “그게 이해되나요?”와 같은 질문은 효과적으로 의사소통하고 감정 지능을 과시하는 데 큰 도움이 될 거예요.\n\n비언어적 단서를 읽는 전문가가 아니더라도, 말하려는 내용이 약간이라도 특수하다면 물어보세요. “...아, 잠깐, k3s Kubernetes on Talos에 대해 얼마나 알고 있는가요?”\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 인터뷰어가 명확한 설명을 요청하면 다시 조정해보세요\n\n나처럼 경험이 많은 인터뷰어는 이해하지 못할 때 중단하고 명확한 설명을 요청합니다. 내가 당신의 특정 분야나 주제를 이해하지 못한다고 상기시킬 수도 있어요.\n\n개인적으로, 처음 몇 번의 실수를 용서해줍니다. 다시 말하지만, 인터뷰는 스트레스 받는 일이에요! 대화에서 \"음\"과 \"어\"가 좋아하는 단어로 바뀌는 걸 누가 알았을까요? 그럼에도 불구하고, 당신은 내가 중단하는 것과 혼란스러운 표정을 감안하지 않고 계속 이어나가면, 적어도 두 번째 주요 관심사로 내 인터뷰 노트에 남을 가능성이 높아집니다.\n\n인터뷰어가 당신을 방해한다면, 혼란스럽게 하지 마세요. 한 숨 돌리고 다시 집중하고, 나머지 인터뷰에서 설명하는 방법을 재조정해보세요. 이 전략은 너무 당연하고 쉽다고 느껴질 수 있지만, 취직 면접의 압력속에서 상기시키는 것이 중요합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 마무리 맺으며\n\n저는 정기적으로 \"기술 커뮤니케이션\"이라는 행동 인터뷰를 진행하고 거의 아무도 핵심 용어를 설명하거나 논의 중인 주제에 대한 내 전문성을 물어보지 않습니다. \"커뮤니케이션\"이라는 단어가 인터뷰 제목에 들어가 있다고요! 심지어 제 평가 기준에는 용어를 설명하지 않는 문제에 대해 간략히 언급합니다.\n\n하지만, 명확하게 설명해 주면서 필요할 때마다 설명을 요청하더라도 상관 없습니다. 그렇게 하면 인터뷰에서 커뮤니케이션 측면에서는 괜찮을 겁니다. 그냥 말하고 싶은 건, 혼란을 느낄 것을 예상하거나 감지하고 첫 단추부터 풀어나간다면 보다 한결같고 현명해 보일 것이라는 거예요.\n\n당신의 용어를 설명하는 것은 당신의 생각을 전달하는 데 큰 도움이 되며, 명확한 커뮤니케이션이 모든 것을 높이는 기본 기술입니다. 취업 인터뷰에서 잘 커뮤니케이션한다면 다른 모든 것이 자연스럽게 잘 맞춰질 겁니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n---\n\n¹ OMG = Oh My God; sometimes Oh-My-God (faster); sometimes even Oh-My-Gawd in certain cultural contexts.\n\n² I made that up; I have no idea if that’s a feasible or reasonable server stack. I’m an iOS Engineer, damn it. Don’t @ me.\n\n³ Oh man, tech names are weird. [Watch more about it here!](https://www.youtube.com/watch?v=y8OnoxKotPQ)\n\nDisclosure: This article was reviewed and vetted by Yelp’s public relations and recruiting teams for accuracy.\n","ogImage":{"url":"/assets/img/2024-05-17-WantToAceThatTechJobInterviewPleasePleaseExplainYourJargon_0.png"},"coverImage":"/assets/img/2024-05-17-WantToAceThatTechJobInterviewPleasePleaseExplainYourJargon_0.png","tag":["Tech"],"readingTime":5},{"title":"플러터 맵 시작하기","description":"","date":"2024-05-17 17:59","slug":"2024-05-17-GettingStartedwithFlutterMap","content":"\n<img src=\"/assets/img/2024-05-17-GettingStartedwithFlutterMap_0.png\" />\n\n몇 일 전에, 각 나라에서 입력된 단어의 번역을 보여주는 앱을 만들어보기로 한 아이디어를 갖게 되었습니다. 나는 언어가 지리적으로 어떻게 발전하고 변하는지를 확인하고 싶었습니다.\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*UIc4JVMEX-FV6U4DJkI2Pg.gif)\n\n이전에 모바일 앱을 만들어본 적이 없었고 지도를 다룬 적도 없지만, 어쨌든 한 번 시도해 보고 싶었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여러 코드 베이스에 의존하지 않고 iOS, Android 및 Web으로 코드를 컴파일할 수있는 능력은 Flutter로 개발하기로 결정했던 이유였습니다. Flutter에는 다양한 라이브러리가 있어 시작하기 쉬울 것이라고 생각했기 때문이죠.\n\nFlutter Map은 매우 사용자 정의 가능한 맵 위젯을 제공하는 Flutter용 오픈 소스 패키지입니다. Flutter Map을 사용하면 개발자들은 플러터 애플리케이션에서 상호 작용하는 맵을 만들 수 있으며, 마커, 다각형, 폴리 라인, 및 타일 레이어와 같은 기능을 포함할 수 있습니다.\n\n위에서 몇 가지 단어를 강조 했음을 보실 수 있습니다. 이것이 나의 문제가 시작된 시점이었습니다. Flutter를 배우는 것이 가장 큰 도전일 것으로 생각했었지만, 맵이 실제로 어떻게 작동하는 지를 배우는 것이 조금 더 까다로웠습니다. 그러나 그 이유를 설명하기 전에, Flutter Map을 사용하여 맵을 표시하는 것이 그 유일한 목적인 앱을 만들어 봅시다.\n\n# 단계 1: 맵 표시하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n첫 번째로 구현한 화면입니다. 살짝 놀 수 있는 간단한 지도입니다. 확대 및 축소 및 이동하면, 지도가 자동으로 조정되어 적용한 확대 정도에 따라 더 많거나 더 적은 정보를 표시합니다.\n\n지도를 표시하는 것은 다음 위젯을 구현하는 것만큼 쉽습니다:\n\n```js\nreturn Scaffold(\n      body: Stack(\n        children: [\n          FlutterMap(\n            options: MapOptions(\n              center: LatLng(51.509364, -0.128928),\n              zoom: 3.2,\n            ),\n            children: [\n              TileLayer(\n                  urlTemplate: 'https://tile.openstreetmap.org/{z}/{x}/{y}.png',\n                  userAgentPackageName: 'com.example.app',\n              ),\n            ],\n          ),\n        ],\n      ),\n    );\n```\n\n이렇게 하면 다음과 같은 화면이 나타납니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*Jy9dt5a-0eCznLHubosUdA.gif)\n\n정말 멋지죠? 제가 방금 내 첫 번째 앱을 만들었어요, 하지만 어떻게 만든 건지는 잘 모르겠어요.\n\n그래서 한 발 물러서서 방금 복사하여 붙여넣은 코드를 분석해 봅시다. 체계적인 방법으로, Flutter Map의 문서에서 가져온 코드를 분석해 봅시다.\n\n## 플러터의 기본 원리 이해하기 (플러터에 익숙하다면 이 부분은 건너뛰세요)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위젯 구성을 보면 Scaffold로 구성된 것을 볼 수 있습니다. Scaffold의 본문은 Stack이며 자식은 FlutterMap입니다.\n\n```js\nreturn Scaffold(\n      body: Stack(\n        children: [\n          FlutterMap(\n            [...]\n          ),\n        ],\n      ),\n    );\n```\n\nFlutter에서 모든 것은 위젯이며, 위젯은 완전한 앱을 만들기 위해 결합할 수 있는 작은 UI 조각입니다. Flutter에서 앱을 개발하는 것은 레고 세트를 조립하는 것과 비슷합니다. 조각을 하나씩 쌓아가는 것입니다.\n\n만약 Stack 내에 여러 자식이 있다면, 실제 스택처럼 위로 쌓인 상태로 표시될 것입니다. 만약 Stack 위젯 대신에 Row나 Column을 사용했다면, 그들의 자식은 이름대로 표시될 것입니다. 단순히 위젯을 조작하여 앱에서 원하는 대로 표시되도록 조정하면 됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n실제로, 이 간단한 애플리케이션에서는 FlutterMap 위젯 뒤에 Stack과 Scaffold 위젯이 필요하지 않았습니다. FlutterMap 위젯만 반환했다면 결과는 동일했을 것입니다.\n\n```js\nreturn FlutterMap(\n      [...]\n);\n```\n\n## FlutterMap으로 돌아가기\n\nFlutterMap 위젯은 Flutter Map 라이브러리에서 제공됩니다. 옵션과 자식들로 구성되어 있는 것을 볼 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n옵션을 통해 위젯에게 이 맵을 런던 (51.509364, -0.128928)을 중심으로 초기화하고 줌 레벨을 3.2로 설정하고 싶다고 알려줍니다.\n\n우리 자식들은 맵의 레이어입니다. 이 예제에서는 Open Street Maps에서 맵 이미지를 가져오는 Tile Layer 하나만 필요합니다.\n\n## 타일 서버 URL\n\nTileLayer를 주목하면 urlTemplate이라는 매개변수 중 하나를 볼 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nTileLayer(\n    urlTemplate: 'https://tile.openstreetmap.org/{z}/{x}/{y}.png',\n    userAgentPackageName: 'com.example.app',\n),\n```\n\n이러한 종류의 URL을 \"타일 서버 URL\"이라고 합니다. 많은 맵 타일 공급 업체가 맵 타일을 매핑 소프트웨어에 전달하기 위해 사용하는 표준 형식입니다. URL에서 'z', 'x', 'y' 자리 표시자는 각각 타일의 줌 레벨, X 좌표 및 Y 좌표를 지정하는 데 사용됩니다. 맵이 표시될 때 매핑 소프트웨어는 현재 보이는 화면을 표시하는 데 필요한 각 타일에 대해 타일 서버 URL에 요청을 보냅니다.\n\n다음은 포르투갈 전체를 표시하는 두 개의 타일입니다:\n\n<img src=\"/assets/img/2024-05-17-GettingStartedwithFlutterMap_1.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![그림](/assets/img/2024-05-17-GettingStartedwithFlutterMap_2.png)\n\n우리의 지도는 실제로 옆에 배치된 여러 정적 이미지를 기반으로 생성됩니다. 주변을 돌아다니며 확대 및 축소할 때, 앱은 지도 화면을 메우기 위해 타일 서버 URL에서 새 이미지를 가져옵니다.\n\n## 다른 타일 서버 URL 제공업체\n\n타일 서버 URL에 대한 학습이 나를 다음 문제로 이끌었습니다. Open Street Maps는 확대할수록 너무 많은 정보를 표시합니다. 정치적 국경, 국가 이름, 도로, 강... 이 모든 정보는 내 번역을 알아보기 힘들게 만들 것입니다. 이들을 제거해야 했습니다. 그러나 이미지가 정적이기 때문에 OpenStreetMaps에서 제공하는 타일 서버를 사용할 수 없었습니다. 다른 것을 찾아야 했습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n구글 검색을 통해 여러 지도 제공업체를 찾을 수 있었어요. 유료도 있고 무료도 있더라구요.\n\n저는 간단한 것을 찾았어요. 국가의 테두리가 있는 세계지도를 원했어요. 제가 원한 것에 제일 가까운 것은 \"Toner\"라는 이름의 Tile Server를 제공하는 Stamen Design이었어요. 그들은 여섯 가지 다른 스타일을 제공하고 있고, 그 중 하나는 라벨이 없는 배경만 있는 스타일이었어요. 제가 필요했던 것과 가깝더라구요.\n\n![이미지](/assets/img/2024-05-17-GettingStartedwithFlutterMap_3.png)\n\n\"배경\" 스타일인 것이 제게 딱 맞았어요. 그래서 Tile Server URL을 얻었어요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nmd\n\n```js\nhttps://stamen-tiles.a.ssl.fastly.net/toner-background/{z}/{x}/{y}.png\n```\n\n그리고 위젯의 urlTemplate을 교체함으로써 즉시 결과를 확인할 수 있습니다:\n\n```js\nFlutterMap(\n  options: MapOptions(\n    center: LatLng(51.509364, -0.128928),\n    zoom: 3.2,\n  ),\n  children: [\n    TileLayer(\n      urlTemplate: 'https://stamen-tiles.a.ssl.fastly.net/toner-background/{z}/{x}/{y}.png',\n      userAgentPackageName: 'com.example.app',\n    ),\n  ],\n);\n```\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/1*_PqsB8kI_Por68rMI0jUzA.gif\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 단계 2: 지도에 레이블 표시하기\n\n내 아이디어는 단어를 입력하면 해당 단어의 번역을 각 나라의 언어로 보여주는 앱을 만드는 것입니다. 이제 지도가 표시되었으므로 특정 좌표에 레이블을 표시하는 방법을 찾아야 했습니다.\n\n## 지도 레이어\n\n이전 단락을 다시 살펴봅시다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저희 지도는 서로 겹쳐진 레이어로 구성되어 있어요. 이전 예제에서는 TileLayer 하나만 필요했지만, Flutter Map 라이브러리에는 MarkerLayer, PolygonLayer, PolylineLayer, CircleLayer, 그리고 AttributionLayer와 같은 다른 유형의 레이어가 있어요.\n\n## PolygonLayer\n\nPolygon 레이어는 지도 위에 다각형을 표시하는 데 사용돼요. 함께 살펴볼까요?\n\n```js\nPolygonLayer(\n  polygonCulling: false,\n  polygons: [\n    Polygon(\n      points: [\n        LatLng(36.95, -9.5),\n        LatLng(42.25, -9.5),\n        LatLng(42.25, -6.2),\n        LatLng(36.95, -6.2),\n      ],\n      color: Colors.blue.withOpacity(0.5),\n      borderStrokeWidth: 2,\n      borderColor: Colors.blue,\n      isFilled: true\n    ),\n  ],\n)\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 예제는 지도상에 하나 이상의 다각형을 표시하는 데 사용되는 PolygonLayer 위젯을 생성하고 있습니다.\n\nPolygonLayer 위젯은 다각형 객체 목록을 polygons 매개변수로 사용합니다. 이 경우 목록에 정의된 다각형이 하나뿐입니다.\n\n다각형 클래스는 지도 상의 다각형을 정의하는 데 사용되며, 다각형의 모양, 위치 및 모양을 정의하는 데 여러 매개변수가 필요합니다.\n\npolygonCulling 매개변수는 뷰어 영역에서 완전히 벗어난 다각형을 제거할지 여부를 지정하는 부울 값입니다. false로 설정하면 지도의 뷰어 영역에서 벗어나더라도 모든 다각형이 렌더링됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 예제에서는 다각형이 points 매개변수로 정의되는데, 이는 다각형의 꼭지점을 정의하는 LatLng 객체의 목록입니다. color 매개변수는 다각형의 채우기 색상을 지정합니다. 이 경우, 우리는 포르투갈 위에 사각형을 배치하고 있습니다. 실제로 어떻게 보이는지 확인해보세요:\n\n![Image](https://miro.medium.com/v2/resize:fit:1400/1*yqz4hBmE_hlbFu5LCjXmrQ.gif)\n\n## PolylineLayer\n\n```js\nPolylineLayer(\n  polylines: [\n    Polyline(\n      points: [\n        LatLng(38.73, -9.14), // 리스본, 포르투갈\n        LatLng(51.50, -0.12), // 런던, 영국\n        LatLng(52.37, 4.90), // 암스테르담, 네덜란드\n      ],\n      color: Colors.blue,\n      strokeWidth: 2,\n    ),\n  ],\n)\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위 예제는 PolylineLayer 위젯을 생성하는데 사용되며, 이 위젯은 지도 상에 하나 이상의 폴리라인을 표시하는 데 사용됩니다.\n\nPolylineLayer 위젯은 polylines 매개변수로 Polyline 객체들의 목록을 가져옵니다. 이 경우에는 목록에 정의된 폴리라인이 하나뿐입니다.\n\nPolyline 클래스는 지도 상의 폴리라인을 정의하는 데 사용되며, 폴리라인의 모양, 위치, 외형을 정의하는 데 여러 매개변수를 가져옵니다.\n\n이 예제에서 Polyline은 points 매개변수로 정의되는데, 이는 폴리라인의 꼭지점을 정의하는 LatLng 객체들의 목록입니다. color 매개변수는 폴리라인의 색상을 지정합니다. 따라서 우리는 포르투갈, 잉글랜드, 네덜란드의 수도를 연결하는 선을 그리고 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![CircleLayer](https://miro.medium.com/v2/resize:fit:1400/1*sA7zHaI8crg5nLnLCz5xDg.gif)\n\n## CircleLayer\n\n```js\nCircleLayer(\n  circles: [\n    CircleMarker(\n      point: LatLng(52.2677, 5.1689), // 't Gooi의 중심\n      radius: 5000,\n      useRadiusInMeter: true,\n      color: Colors.red.withOpacity(0.3),\n      borderColor: Colors.red.withOpacity(0.7),\n      borderStrokeWidth: 2,\n    )\n  ],\n)\n```\n\n위의 예제는 한 개 이상의 원을 지도상에 표시하는 데 사용되는 CircleLayer 위젯을 생성합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nCircleLayer 위젯은 circles 매개변수로 CircleMarker 객체의 리스트를 가져옵니다. 이 경우에는 리스트에 정의된 원이 하나뿐입니다.\n\nCircleMaker 클래스는 맵 상에 원을 정의하는 데 사용되며, 원의 모양, 위치 및 모양을 정의하는 데 여러 매개변수를 사용합니다.\n\n이 예제에서 CircleMarker는 point 매개변수로 정의되어 있으며, 이는 LatLng 객체로 맵 상의 마커 위치를 지정합니다. color 매개변수는 원의 색상을 지정하고, radius 매개변수는 원의 크기를 나타냅니다.\n\n저희는 네덜란드의 't Gooi 지역 위에 반지름 5km인 원을 그리고 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/1*BQu45aeiixZQD744zeWvVw.gif\" />\n\n## MarkerLayer\n\n마커 레이어는 가장 간단한 레이어입니다. 특정 좌표에 위젯을 표시하는 데 사용합니다. 한번 살펴보죠:\n\n```js\nMarkerLayer(\n    markers: [\n        Marker(\n          point: LatLng(51.509364, -0.128928),\n          width: 80,\n          height: 80,\n          builder: (context) => FlutterLogo(),\n        ),\n    ],\n)\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 예시에서는 지도에 하나 이상의 마커를 표시하는 데 사용되는 MarkerLayer 위젯을 생성합니다.\n\nMarkerLayer 위젯은 markers 매개변수로 Marker 객체들의 목록을 받습니다. 이 경우 목록에는 하나의 마커만 정의되어 있습니다.\n\nMarker 클래스는 지도에 표시할 마커를 정의하는 데 사용되며, 마커의 위치, 크기 및 모양을 정의하는 데 여러 매개변수를 사용합니다.\n\n이 예시에서는 Marker가 point 매개변수로 정의되어 있으며, 이는 LatLng 객체로서 지도상의 마커 위치를 지정합니다. 너비와 높이 매개변수는 마커의 크기를 픽셀로 지정하고, builder 매개변수는 마커의 외관을 정의하기 위해 Widget을 반환하는 함수를 사용합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 예시에서 빌더 함수는 FlutterLogo 위젯을 사용하여 포인트 매개변수로 지정된 위치, 즉 런던에 Flutter 로고를 표시합니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*Yt7KTM6Pf91zvsyzRiGBgQ.gif)\n\n# 지도에 단어 배치하기\n\n이전에 말한대로, 제 목표는 지도에 단어를 배치하는 것이며, MarkerLayer가 그에 대한 완벽한 해결책입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n마커를 만들기 전에 텍스트 위젯을 만들어 보겠습니다. 먼저 스타일을 설정해 봅시다:\n\n```js\nTextStyle getDefaultTextStyle() {\n  return const TextStyle(\n    fontSize: 12,\n    backgroundColor: Colors.black,\n    color: Colors.white,\n  );\n}\n```\n\n이 메소드는 글꼴 크기, 배경 색상 및 글꼴 색상을 정의하는 TextStyle 객체를 반환합니다. 다음과 같은 방식으로 사용될 것입니다:\n\n```js\nContainer buildTextWidget(String word) {\n  return Container(\n      alignment: Alignment.center,\n      child: Text(\n          word,\n          textAlign: TextAlign.center,\n          style: getDefaultTextStyle()\n      )\n  );\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n텍스트 위젯은 단어를 텍스트로받아 Container 위젯 내에 배치됩니다.\n\n```js\nMarker buildMarker(LatLng coordinates, String word) {\n  return Marker(\n      point: coordinates,\n      width: 100,\n      height: 12,\n      builder: (context) => buildTextWidget(word)\n  );\n}\n```\n\nbuildTextWidget 함수는 buildMarker 함수 내에서 호출되어 MarkerLayer 위젯의 하위인 Markers를 생성합니다. 이들은 배치될 좌표와 표시할 단어로 생성됩니다.\n\n```js\nMarkerLayer(\n  markers: [\n    buildMarker(LatLng(39.3999, -8.2245), \"Amor\"), // Portugal\n    buildMarker(LatLng(55.3781, -3.4360), \"Love\"), // England\n    buildMarker(LatLng(46.2276, 2.2137), \"Aimer\"), // France\n    buildMarker(LatLng(52.1326, 5.2913), \"Liefde\"), // Netherlands\n    buildMarker(LatLng(51.1657, 10.4515), \"Liebe\"), // Germany\n  ],\n)\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그리고 마지막으로:\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*RmUkKINlQ1WSTGEalOVkcQ.gif)\n\n# 결론\n\n이야기에서 우리는 지도가 렌더링되는 기본 원리와 Tile 서버에 관련된 몇 가지 가능성을 배웠습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n또한, 우리는 지도가 어떻게 레이어로 나누어지는지 학습하고, 이를 활용하여 특정 좌표에 마커, 폴리곤, 폴리라인 및 원을 배치하는 방법도 배웠어요.\n\n마무리로, 우리는 실제 예제를 통해 지도 위의 특정 국가에 텍스트 레이블을 표시하는 방법을 배웠어요.\n\n# 다음은 무엇인가요?\n\n저는 플러터와의 여정이 막 시작된 것 뿐이에요. 이것은 제가 만들고 있는 첫 번째 앱의 표면에 불과해요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음 이야기에서는 사용자가 단어를 입력하고 해당 단어를 여러 언어로 번역하여 지도에 표시하는 방법을 소개할 거에요.\n\n또한, 지도를 더 고급스럽게 다루는 방법도 알려드릴 거예요. 예를 들어 확대 및 축소할 때 레이블 크기를 늘리거나 줄이는 방법, 또한 지도를 제어하기 위해 제스처 대신 버튼을 사용하는 지도 컨트롤러를 구현하는 방법에 대해서 보여드릴 거에요.\n\n계속 주목해 주세요!\n\n# 최종 앱\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n테이블 태그를 Markdown 형식으로 변경해보세요.\n\n| Header 1 | Header 2 |\n| -------- | -------- |\n| Cell 1   | Cell 2   |\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n글을 쓰는 데에는 시간과 노력이 들어갑니다. 저는 글쓰기를 사랑하고 지식을 나누는 것을 좋아하지만 물론 청구서도 내야 합니다. 제 작품을 좋아하신다면 Buy Me a Coffee를 통해 후원해 주시기를 부탁드립니다: [https://www.buymeacoffee.com/RaphaelDeLio](https://www.buymeacoffee.com/RaphaelDeLio)\n\n또는 비트코인을 보내주셔도 됩니다: 1HjG7pmghg3Z8RATH4aiUWr156BGafJ6Zw\n\n# 소셜 미디어에서 나를 팔로우해요\n\n저와 함께 플러터의 세계로 더 깊게 파고들어보세요! 주요 소셜 플랫폼에서 제 여정을 팔로우하여 독점 콘텐츠, 팁, 그리고 토론에 참여해보세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nTwitter | LinkedIn | YouTube | Instagram\n","ogImage":{"url":"/assets/img/2024-05-17-GettingStartedwithFlutterMap_0.png"},"coverImage":"/assets/img/2024-05-17-GettingStartedwithFlutterMap_0.png","tag":["Tech"],"readingTime":19},{"title":"iOS에서 Apple Maps를 사용하여 배송 앱 실시간 추적 구현","description":"","date":"2024-05-17 17:57","slug":"2024-05-17-DeliveryapplivetrackingimplementationusingAppleMapsiniOS","content":"\nUIKit 및 MapKit을 사용하여 Apple 지도에서 라이브 추적 구현을 성취했습니다.\n\n[GitHub Repo](https://github.com/VSofficial/Zomato-Live-tracking-Clone-iOS-)\n\n[YouTube](https://www.youtube.com/shorts/Qzi_vZw4p4Q)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n지도에서 MKAnnoatation을 사용하여 사용자 정의 주석(맵 마커)을 정의하는 것으로 시작해 봅시다.\n\n```js\nclass CustomAnnotation: NSObject, MKAnnotation {\n    var coordinate: CLLocationCoordinate2D\n    var title: String?\n    private let pathCoordinates: [CLLocationCoordinate2D]\n\n    init(coordinates: [CLLocationCoordinate2D], title: String?) {\n        self.coordinate = coordinates.first ?? CLLocationCoordinate2D(latitude: 0, longitude: 0)\n        self.title = title\n        self.pathCoordinates = coordinates\n        super.init()\n    }\n}\n```\n\n그런 다음 맵에서 마커의 사용자 정의 뷰(심볼)를 생성합니다.\n\n```js\n// 지도의 주석용 사용자 정의 뷰\npublic class CustomAnnotationView: MKAnnotationView {\n    override init(annotation: MKAnnotation?, reuseIdentifier: String?) {\n        super.init(annotation: annotation, reuseIdentifier: reuseIdentifier)\n        self.image = UIImage(named: \"delivery\")\n    }\n\n    required init?(coder aDecoder: NSCoder) {\n        fatalError(\"init(coder:) has not been implemented\")\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 우리가 MKMapViewDelegate를 사용하여 맵에 사용자 정의 주석을 구현하는 부분으로 넘어가 봅시다.\n\n```swift\nextension ViewController: MKMapViewDelegate {\n\n    func mapView(_ mapView: MKMapView, viewFor annotation: MKAnnotation) -> MKAnnotationView? {\n        guard let annotation = annotation as? CustomAnnotation else {\n            return nil\n        }\n        let identifier = \"CustomAnnotationView\"\n        var annotationView = mapView.dequeueReusableAnnotationView(withIdentifier: identifier) as? MKPinAnnotationView\n\n        if annotationView == nil {\n            annotationView = MKPinAnnotationView(annotation: annotation, reuseIdentifier: identifier)\n            annotationView?.canShowCallout = true\n        } else {\n            annotationView?.annotation = annotation\n        }\n        return annotationView\n    }\n}\n```\n\n다음으로 리다라를 따라가며\n\n```swift\nextension ViewController {\n    func mapView(_ mapView: MKMapView, rendererFor overlay: MKOverlay) -> MKOverlayRenderer {\n        if overlay is MKPolyline {\n            let renderer = MKPolylineRenderer(overlay: overlay)\n            renderer.strokeColor = UIColor.systemTeal\n            renderer.lineWidth = 6\n            return renderer\n        }\n        return MKOverlayRenderer(overlay: overlay)\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 코드는 지도에 이동 (배송) 경로를 포함하는 스트로크 라인을 보여주는 데 도움이 됩니다.\n\n이제, 주요 기능이 구현된 섹션으로 이동해 보겠습니다.\n\n```js\n// MapKit에서 지도의 주요 구성\n    private func configureMap() {\n        mapView.delegate = self\n\n        let pathCoordinates = [\n            CLLocationCoordinate2D(latitude: Double(startLatitude)!, longitude: Double(startLongitude)!),\n            CLLocationCoordinate2D(latitude: Double(endLatitude)!, longitude: Double(endLongitude)!),\n        ]\n\n        let annotation = CustomAnnotation(coordinates: pathCoordinates, title: \"Moving Pins\")\n        mapView.addAnnotation(annotation)\n\n        let regionRadius: CLLocationDistance = 350\n        let region = MKCoordinateRegion(center: pathCoordinates.first!, latitudinalMeters: regionRadius, longitudinalMeters: regionRadius)\n\n        let request = MKDirections.Request()\n        request.source = MKMapItem(placemark: MKPlacemark(coordinate: pathCoordinates[0]))\n        request.destination = MKMapItem(placemark: MKPlacemark(coordinate: pathCoordinates[1]))\n        request.transportType = .automobile\n\n        let directions = MKDirections(request: request)\n        directions.calculate { (response, error) in\n            guard let route = response?.routes.first else {\n                if let error = error {\n                    print(\"방향을 가져오는 중 에러 발생: \\(error.localizedDescription)\")\n                }\n                return\n            }\n            self.mapView.addOverlay(route.polyline)\n            self.addPinAndFollowRoute(route: route, duration: TimeInterval(self.timedVariable))\n        }\n        mapView.setRegion(region, animated: true)\n    }\n\n    // 배달원용 경로 따르는 알고리즘\n    func addPinAndFollowRoute(route: MKRoute, duration: TimeInterval) {\n        let pin = MKPointAnnotation()\n        pin.coordinate = route.polyline.coordinate\n        mapView.addAnnotation(pin)\n\n        var elapsedTime: TimeInterval = 0.0\n        let totalDuration = duration\n        let pointCount = route.polyline.pointCount\n\n        Timer.scheduledTimer(withTimeInterval: 0.01, repeats: true) { timer in\n            elapsedTime += 0.01\n\n            if elapsedTime >= totalDuration {\n                self.showAlert()\n                self.ordertitle.text = \"주문 배달 완료!! 🎉🎉 \"\n                timer.invalidate()\n                return\n            }\n\n            let fraction = elapsedTime / totalDuration\n            let index = Int(fraction * Double(pointCount - 1))\n\n            if index < pointCount - 1 {\n                let startCoordinate = route.polyline.points()[index].coordinate\n                let endCoordinate = route.polyline.points()[index + 1].coordinate\n                let interpolatedCoordinate = self.interpolateCoordinate(startCoordinate, endCoordinate, fraction)\n\n                UIView.animate(withDuration: 0.01) { // 부드러운 이동을 위한 애니메이션 시간 감소\n                    pin.coordinate = interpolatedCoordinate\n                }\n            }\n        }\n    }\n\n    func interpolateCoordinate(_ start: CLLocationCoordinate2D, _ end: CLLocationCoordinate2D, _ fraction: Double) -> CLLocationCoordinate2D {\n        let lat = start.latitude + (end.latitude - start.latitude) * fraction\n        let lon = start.longitude + (end.longitude - start.longitude) * fraction\n        return CLLocationCoordinate2D(latitude: lat, longitude: lon)\n    }\n\n    // 주문 배달 메시지\n    func showAlert() {\n          let alert = UIAlertController(title: \"주문 배달 완료\", message: \"식사를 즐기세요\", preferredStyle: .alert)\n          let okAction = UIAlertAction(title: \"확인\", style: .default) { _ in\n              // 필요하다면 확인 작업 처리\n          }\n          alert.addAction(okAction)\n          present(alert, animated: true, completion: nil)\n      }\n\n}\n```\n\npathCoordinates는 시작 및 끝 위치의 좌표를 정의합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```swift\nregion 변수는 우리의 배송 위치가 위치한 지역만 표시하는 데 사용됩니다.\n\nfunc addPinAndFollowRoute(route: MKRoute, duration: TimeInterval)\n\n위의 함수는 경로를 따라가는 데 사용됩니다. 여행을 완료하는 데 필요한 시간과 경로를 정의할 수 있습니다.\n\nvar errorMessage: String?\nvar startLatitude: String = \"0\"\nvar startLongitude: String = \"0.0\"\nvar endLatitude: String = \"0.0\"\nvar endLongitude: String = \"0.0\"\nvar timedVariable: Int = 1\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위 변수들은 ViewController에 정의되어 있으며 하드 코딩된 값이나 API 응답에서 가져온 값으로 수정할 수 있습니다.\n\nconfigureMap() 내에서 route의 정의 (이미 위 코드에 포함되어 있음)\n\n```js\nguard let route = response?.routes.first else {\n                if let error = error {\n                    print(\"Error getting directions: \\(error.localizedDescription)\")\n                }\n                return\n            }\n```\n\n그리고 여기서 우리 애플리케이션이 완료됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nGitHub 저장소 및 YouTube 비디오를 첨부했어요. 코드베이스와 애플리케이션 데모를 확인해보세요!\n","ogImage":{"url":"/assets/img/2024-05-17-DeliveryapplivetrackingimplementationusingAppleMapsiniOS_0.png"},"coverImage":"/assets/img/2024-05-17-DeliveryapplivetrackingimplementationusingAppleMapsiniOS_0.png","tag":["Tech"],"readingTime":9},{"title":"Swift 6를 위한 내 앱 준비하기","description":"","date":"2024-05-17 17:56","slug":"2024-05-17-PreparingMyAppforSwift6","content":"\n![2024-05-17-PreparingMyAppforSwift6_0](/assets/img/2024-05-17-PreparingMyAppforSwift6_0.png)\n\n# \"Swift 6 모드\"가 뭔가요?\n\nSwift 6는 더 이상 2023년에 출시되지 않을 것으로 Doug Gregor가 Swift 언어 워크그룹에서 명확히 밝혔습니다. 그러나 애플이 이미 Swift 6 일부 기능을 5.8에서 제공했다는 것을 알고 계셨나요? 네, 사실입니다. 이전에 Xcode 14.3로 제공된 Swift 일부 기능은 기본적으로 비활성화되어 있습니다. Swift 6 출시 시에 다시 활성화될 예정이며, 출시까지 한 해 이상 소요될 수도 있습니다.\n\n이러한 기능은 Swift에 몇 가지 파괴적인 변화를 소개합니다. 예를 들어, 널리 알려진 API의 이름을 바꾸거나 동작을 조정하거나, 컴파일러에 새로운 안전성 확인을 추가하는 식입니다. 그러나 이러한 변경 사항을 코드 기반을 개선하기 위해 언젠가는 모두 활성화될 것이며, 우리는 이러한 변경 사항과 잘 호환되도록 프로젝트를 업데이트해야 할 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n내 프로젝트에서 모든 기능을 켜는 것이 좋을 것 같아요. 그러면 코드베이스에 어떤 변경 사항이 있는지 확인할 수 있거든. 물론, BareSlashRegexLiterals와 같은 새로운 기능도 활용할 수 있죠. /.../와 같은 정규식 리터럴 구문을 간결하게 사용할 수 있게 해주는 것이죠.\n\n다행히도, Swift 5.8부터 이러한 옵션을 활성화하는 통합된 방법이 생겼어요. 다른 Swift Flags에서 -enable-upcoming-feature를 Swift에 전달하기만 하면 되는데요. 이걸 Xcode 프로젝트의 빌드 설정에서 제공해주면 되요. 하지만 사용 가능한 기능을 알아야 하기도 해요. 그런데 좋은 개요를 제공하는 곳을 찾기 어려웠어요. 이 통합 옵션을 도입한 제안에는 그러한 목록이 포함되어 있지만, 나중에 추가된 새로운 옵션들과 같은 것이 업데이트되지 않아요. 예를 들어 SE-0384와 같은 것도 그렇죠. 그래서 현재 모든 지원되는 옵션 목록을 신뢰할 수 있는 곳이 어디에 있는지 아시는 분?\n\nSwift는 오픈 소스이기 때문에 가장 신뢰할 수 있는 곳은 Swift GitHub 저장소네요! UPCOMING_FEATURE라는 이름의 Swift 진화 제안 번호와 해당하는 Swift 버전이 포함된 Features.def 파일이 있어요:\n\n```js\nUPCOMING_FEATURE(ConciseMagicFile, 274, 6);\nUPCOMING_FEATURE(ForwardTrailingClosures, 286, 6);\nUPCOMING_FEATURE(BareSlashRegexLiterals, 354, 6);\nUPCOMING_FEATURE(ExistentialAny, 335, 6);\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음은 각 항목에 대한 간단한 설명이 포함된 옵션입니다:\n\n- ConciseMagicFile:\n  #file을 #filePath가 아닌 #fileID로 변경합니다.\n- ForwardTrailingClosures:\n  후방 스캔 일치 규칙을 제거합니다.\n- ExistentialAny:\n  존재 타입에 대해 any를 필요로 합니다.\n- BareSlashRegexLiterals:\n  /.../ 정규식 리터럴 구문을 사용할 수 있게 합니다.\n\n왜인지 두 옵션이 없어 보입니다 (조사 중):\n\n- StrictConcurrency:\n  완전한 동시성 검사 수행합니다.\n- ImplicitOpenExistentials:\n  추가 사례에서 암시적 열기를 수행합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n나중에 더 많은 옵션이 함께 제공됩니다. 예를 들어 ImportObjcForwardDeclarations가 있습니다.\n\n내 코드를 적절한 동시성 지원을 위해 추가로 확인하기로 결정했기 때문에 -warn-concurrency도 전달하기로 선택했습니다(실제로 작동한다면 StrictConcurrency와 동일해야 합니다) 그리고 -enable-actor-data-race-checks를 전달하기로 했습니다.\n\n# 내 프로젝트 이전하기\n\n내 프로젝트에서 나와 같이 5.8 옵션 모두를 활성화하고 싶다면, 다음 텍스트 블록을 복사(⌘C)하여 Xcode 프로젝트의 \"Build Settings\" 탭으로 이동하고 \"Other Swift Flags\"를 검색한 다음 해당 옵션을 에디터에서 선택하고 붙여넣기(⌘V)하십시오:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n//:configuration = Debug\nOTHER_SWIFT_FLAGS = -enable-upcoming-feature BareSlashRegexLiterals -enable-upcoming-feature ConciseMagicFile -enable-upcoming-feature ExistentialAny -enable-upcoming-feature ForwardTrailingClosures -enable-upcoming-feature ImplicitOpenExistentials -enable-upcoming-feature StrictConcurrency -warn-concurrency -enable-actor-data-race-checks\n\n//:configuration = Release\nOTHER_SWIFT_FLAGS = -enable-upcoming-feature BareSlashRegexLiterals -enable-upcoming-feature ConciseMagicFile -enable-upcoming-feature ExistentialAny -enable-upcoming-feature ForwardTrailingClosures -enable-upcoming-feature ImplicitOpenExistentials -enable-upcoming-feature StrictConcurrency -warn-concurrency -enable-actor-data-race-checks\n\n//:completeSettings = some\nOTHER_SWIFT_FLAGS\n```\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/0*Klutl2JrkB5biMDB.gif\" />\n\n만약 저와 같이 SwiftPM 모듈화된 앱을 사용하거나 Swift 패키지를 작업 중이라면, 각 타겟에 .enableUpcomingFeature의 배열을 swiftSettings를 통해 전달해야 할 필요가 있습니다:\n\n```js\nlet swiftSettings: [SwiftSetting] = [\n   .enableUpcomingFeature(\"BareSlashRegexLiterals\"),\n   .enableUpcomingFeature(\"ConciseMagicFile\"),\n   .enableUpcomingFeature(\"ExistentialAny\"),\n   .enableUpcomingFeature(\"ForwardTrailingClosures\"),\n   .enableUpcomingFeature(\"ImplicitOpenExistentials\"),\n   .enableUpcomingFeature(\"StrictConcurrency\"),\n   .unsafeFlags([\"-warn-concurrency\", \"-enable-actor-data-race-checks\"]),\n]\n\nlet package = Package(\n   // ...\n   targets: [\n      // ...\n      .target(\n         name: \"MyTarget\",\n         dependencies: [/* ... */],\n         swiftSettings: swiftSettings\n      ),\n      // ...\n   ]\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n파일 상단에 있는 도구 버전을 5.8로 업그레이드하는 것을 잊지 마세요:\n\n```js\n// swift-tools-version:5.8\n```\n\n그 이유는 Swift가 프로젝트 대상에 지정한 옵션을 자동으로 프로젝트에 가져온 모듈로 전달하지 않기 때문입니다. 이것은 좋은 뉴스입니다. 왜냐하면 이렇게 함으로써 프로젝트에 포함하는 Swift 패키지를 조정할 필요가 없으며 여전히 앱 코드에서 이러한 기능을 사용할 수 있습니다. 그리고 그 반대도 마찬가지입니다. 패키지 작성자는 이러한 기능을 프로젝트에 적용할 수 있고, 이로 인해 소비되는 프로젝트의 코드에 영향을 미치지 않습니다.\n\n이것들을 켜고 빌드한 후에 네가지 유형의 문제를 발견했습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n1. 몇 군데에 any 키워드를 추가해야 했는데 Xcode가 Fix-It으로 도와주었어요:\n\n![이미지 1](/assets/img/2024-05-17-PreparingMyAppforSwift6_1.png)\n\n![이미지 2](/assets/img/2024-05-17-PreparingMyAppforSwift6_2.png)\n\n2. 어떤 이유로 .sheet 수정자가 있는 뷰들에 대해 많은 오류를 받았어요. 에러 메시지에는 \"Generic parameter `Content` could not be inferred\"와 \"Missing argument for parameter `content` in call\"이란 내용이 있었죠. 이 메시지들은 그리 도움이 되지 않았어요. 그래서 일단 .sheet 내용을 Textview로 대체해봤지만 도움이 되지 않았어요. 그래서 한 가지씩 선택 옵션을 끄다가 ForwardTrailingClosures를 끈 채로 에러가 없어지는 것을 확인하고 그대로 끈 채로 유지했어요. 미래의 Swift 버전에서 더 나은 에러 메시지가 생성되어 이 문제가 해결될 것을 희망하고 있어요. 급한 일은 아니니까요. 나중에 수정할 수 있을 거예요. 현재 조사할 시간이 없습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![PreparingMyAppforSwift6_3](/assets/img/2024-05-17-PreparingMyAppforSwift6_3.png)\n\n3. 일부 함수를 TCA WithViewStore를 반환하도록 표시해야 했는데, 다시 한 번, Xcode가 Fix-It으로 도와주었습니다.\n\n![PreparingMyAppforSwift6_4](/assets/img/2024-05-17-PreparingMyAppforSwift6_4.png)\n\n4. 많은 곳에서 \"Non-sendable type '…' passed in call to main actor-isolated function cannot cross actor boundary\"라는 경고가 표시되어서, 이러한 타입들을 Sendable 프로토콜을 준수하도록 만들었습니다 (Sendable에 대해 자세히 알아보세요).\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nRemafoX 앱에 약 35,000줄의 Swift 코드가 있는데, 나머지는 모두 잘 빌드되었다. 전체 프로세스는 내 시간의 3시간 미만이 걸렸어요.\n\n이제 내 프로젝트는 Swift의 미래를 대비해서 준비된 상태입니다 🎉 그리고 새로운 Regex 리터럴 기능을 사용할 수 있어요 (let regex = /._@._/). 또한, 나중에 Swift 6로 마이그레이션해야 할 새 코드를 도입할 수 없어요, 바로 오류를 받게 될 거니까. 💯\n\n귀하는 어떠세요? 귀하의 프로젝트에서는 어떤 예정된 기능을 사용하고 싶으신가요?\n","ogImage":{"url":"/assets/img/2024-05-17-PreparingMyAppforSwift6_0.png"},"coverImage":"/assets/img/2024-05-17-PreparingMyAppforSwift6_0.png","tag":["Tech"],"readingTime":8},{"title":"독일 텔레콤 디지털 iOS 개발자 인터뷰 경험","description":"","date":"2024-05-17 17:55","slug":"2024-05-17-DeutscheTelekomdigitalIosdeveloperInterviewExperience","content":"\n<img src=\"/assets/img/2024-05-17-DeutscheTelekomdigitalIosdeveloperInterviewExperience_0.png\" />\n\n- 첫 번째 라운드\n\n아이폰 및 Swift 기초에 관련된 25개의 객관식 문제로 이루어진 온라인 테스트였어요.\n\n2. 사무실에서의 면접\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nRound 1: 기술 면접\n\nQ: struct와 class의 차이점은 무엇인가요? 왜 struct는 가볍고 성능이 좋은가요?\n\nQ: Swift에서의 메모리 할당은 어떻게 이루어지나요?\n\nQ: 코드 예시와 함께 클로저에 대해 설명해주세요\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음은 한국어로 번역된 정보입니다:\n\nQ: 클래스 및 구조체 출력 질문\n\nQ: 클로저 이스케이핑\nQ: 알 수 없는 변수\n\nQ: final 및 static은 무엇인가요?\n\nQ: iOS에서 프레임워크와 모듈은 무엇인가요?\nQ: 프로토콜과 델리게이트\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nRound 2: 기술 면접\nQ: 클래스 대 구조체\nQ: 구조체가 가벼운 이유\nQ: Combine 프레임워크란 무엇인가요?\nQ: 프로토콜 기반 프로그래밍이 무엇인가요?\nQ: Swift UI의 기본\nQ: MVVM\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nQ: 제품에 관한 기본 앱을 디자인해 보세요. 한 화면에는 모든 제품의 목록이 표시되고, 다른 화면에는 제품의 상세 내용이 표시되어야 합니다. (MVVM)\n\nQ: 프로토콜 및 델리게이트\n\nQ: 동시성, 멀티스레딩\n\nQ: 글로벌 비동기 및 동기 출력 질문\nQ: async await 키워드\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n**라운드 3: 관리직 면접**\n\n그걸로 선택되지 않았어요 😭\n","ogImage":{"url":"/assets/img/2024-05-17-DeutscheTelekomdigitalIosdeveloperInterviewExperience_0.png"},"coverImage":"/assets/img/2024-05-17-DeutscheTelekomdigitalIosdeveloperInterviewExperience_0.png","tag":["Tech"],"readingTime":3},{"title":" 2024년에는 Captcha를 버리는 게 좋을 것 같아요 ","description":"","date":"2024-05-17 17:53","slug":"2024-05-17-ItsAboutTimeToDitchCaptchaIn2024","content":"\n<img src=\"/assets/img/2024-05-17-ItsAboutTimeToDitchCaptchaIn2024_0.png\" />\n\n## 매년 77,600채의 주택을 건설할 수 있을 것입니다. 하지만 우리가 캡차를 푸는 데 시간을 낭비하고 있습니다. 여러 해 동안 캡차는 계속해서 우리의 시간과 돈을 낭비하고 있습니다. 2024년은 캡차를 완전히 없애는 좋은 해가 될 것입니다.\n\n# 캡차와 프린터는 같습니다\n\n요 며칠 동안 약간 연기한 온라인 작업을 처리해야 했습니다. 그 중 하나는 더 이상 필요하지 않은 뉴스레터 구독 취소였습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그 날 나의 마지막 일이었고 5분 안에 끝내야 했다. 이메일에서 제공된 링크를 통해 회사 웹사이트로 이동했다.\n\n구독 취소를 위해 계정에 로그인하고 이메일 구독을 비활성화하기 위해 체크 상자를 클릭해야 했다. 5분 안에 완료할 수있는 완벽한 작업이었다.\n\n로그인 페이지에서 난 로봇이 아닌 것을 확인하기 위한 captcha를 마주했다. 서둘러야 했기 때문에 나는 보행로가 보이는 모든 사진을 클릭했다.\n\n불행하게도 하나를 놓쳤다. 그래서 내가 치과 방문을 하기 전에 그 마지막 작업을 끝내야 했기 때문에 사진을 빠르게 클릭하기 시작했다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n놀랍게도 더 많은 사진이 제시되었고, 한번 클릭한 후에도 끊임없이 더 나오더라구요. 나는 몇 분 동안 계속 보다가 결국 그날은 그만두기로 했습니다.\n\n거의 프린터처럼, 캡차는 당신이 서둘고 있는 걸 느낀답니다.\n\n# 캡차가 탄생한 이유\n\n컴퓨터 과학에서 나의 주요 연구 분야는 인간 중심의 계산과 소셜 미디어였어요. 오늘날 두 분야가 구현된 방식은 저를 실망스럽게 만들죠.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n캡차의 시작은 흥미로웠어요. 위키피디아에 따르면:\n\n알고리즘이 무언가를 처리할 수 없을 때 우리는 그 작업을 사람들에게 분배하는 것을 의미합니다. HBC는 처리되어야 하는 방대한 양의 처리를 위한 꿈의 도래였어요.\n\n![이미지](/assets/img/2024-05-17-ItsAboutTimeToDitchCaptchaIn2024_1.png)\n\n캡차가 탄생한 후 HBC의 실용적 구현으로 바로 나왔어요. 한편으로, 사람들은 사진에 있는 항목을 분류하여 동일한 작업을 수행하는 AI를 교육하는 데 도움이 되었어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n반면, 캡차는 일정 수준의 안전성을 제공했습니다. 당시에는 봇이 캡차를 해결할 수 없을 것으로 예상되었기 때문입니다.\n\n그래서 1997년에 에란 레셰프, 길리 라아난, 에일론 솔라가 특허를 획득한 캡차는 모두에게 유익해 보였습니다. 이 아이디어는 훌륭했고, 원 저자들은 캡차를 발명함으로써 좋은 일을 했습니다.\n\n그러나 14년 뒤에 우리는 캡차가 다른 방향으로 나아간 것을 볼 수 있습니다. 어디로 향하는지 살펴보겠습니다!\n\n# 매년 77,600가구가 캡차 때문에 주택을 지을 수 없게 됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n2021년에는 인류가 매일 총 500년을 CAPTCHA 해결에 낭비했습니다. 이를 이해하려면 매년 182,000년, 320억 달러 (해당 시간에 대한 미국 평균 수입 기준)을 낭비한 것입니다.\n\n그 금액으로 미국에 77,600 가구를 위한 주택을 지을 수 있었을 것입니다... 매년 마다.\n\n![이미지](/assets/img/2024-05-17-ItsAboutTimeToDitchCaptchaIn2024_2.png)\n\n이 충격적인 숫자는 우리가 CAPTCHA로 인해 얼마나 많은 시간과 돈을 잃는지를 보여줍니다. 이러한 숫자들은 가정과 평균에 따라 작아지거나 커질 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리는 인간으로서 캡차에 상당한 시간을 낭비하는 사실이 있습니다. 한 사람당 몇 초에서 5분 정도밖에 안 걸리지만, 시간이 누적됩니다.\n\n# 캡차는 이제 더 이상 인간과 봇을 구별하지 못합니다\n\n게다가, 우리는 이로 인해 무언가를 얻는 것도 아닙니다. 2021년, 3년 전에 Nikolay Pankov가 이 문장으로 캡차에 대해 요약한 기사를 썼습니다:\n\n캡차는 고의적으로 온라인 자원을 봇과 나쁜 행위자로부터 보호해야 합니다. 그 목표는 자원 사용을 제한하는 것입니다. 만약 봇이 페이지를 방문하면, 회사가 지불해야 하는 소중한 전송을 사용하게 됩니다. 우리는 봇이 웹사이트를 방문하는 것을 원하지 않습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n공동으로 스타벅스에서 커피를 사지 않은 돈을 모아온 모든 저축을 산다는 DDOS 공격도 말할 것도 없죠.\n\n![image](/assets/img/2024-05-17-ItsAboutTimeToDitchCaptchaIn2024_3.png)\n\n그렇지만 여러 해 동안 알고 있듯이, CAPTCHA는 그 퍼즐을 해결하지 못합니다. AI나 인간 지원으로 쉽게 해결할 수 있는데, 또한 다른 사람에게 CAPTCHA 퍼즐 해결을 아웃소싱한 봇들도 있었습니다.\n\n어떤 봇은 서비스에 링크가 포함된 댓글을 게시하려고 했지만, 웹사이트가 그것을 CAPTCHA로 해결하라고 요청했습니다. 그래서 봇은 해커가 운영하는 약간 유용한 앱 또는 웹사이트의 방문자에게 동일한 퍼즐을 제시했습니다. 그렇게 해커들은 HBC를 해결하는 솔루션을 빠르게 구현하기로 결정했습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n소캡차는 아무런 보호를 제공하지 않아요. 방문자가 사람인지 봇인지 구별할 수 없는 경우가 매우 오래 지속됩니다.\n\n# 소캡차가 사람들을 차별합니다\n\n소캡차가 사람들을 차별한다는 보고가 많습니다. 예를 들어 시각장애인은 오디오 캡차를 해결하는 데 어려움을 겪습니다(오디오 캡차가 제공된다면). 이것은 실제로 새로운 현상이 아닙니다. 우리는 적어도 2019년부터 지금까지 여러 해 동안 알고 있습니다.\n\n또한 국적, 인종, 위치 등에 따라 소캡차가 사람들을 차별할 수 있는 여러 방법이 있습니다. 이는 잘 알려지지 않은 사실입니다. 예를 들어 택시를 지목해야 하는 경우, 다른 나라의 사진이 제시된다면 어려움을 겪을 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이미지 태그를 Markdown 형식으로 변경합니다.\n\n![이미지](/assets/img/2024-05-17-ItsAboutTimeToDitchCaptchaIn2024_4.png)\n\n테렌스 에덴(Terence Eden)은 2017년 다음과 같이 요약했습니다:\n\n모든 것을 고려해도, 왜 우리는 여전히 캡차를 해결해야 하는 걸까요?\n\n# 기업들이 캡차를 단지 자신들의 이익을 위해 사용합니다\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n모든 것은 돈으로 연결돼 있어요. Captcha는 사람 중심의 계산을 하고 실제 문제(인간과 로봇을 구분하는 것)를 해결하기 위해 고안되었어요.\n\n핵심 기능에서 실패하더라도, 여전히 사람 중심의 계산에 사용되고 있어요.\n\nAI 모델은 어떤 보도가 어떻게 생겼는지 모르죠. 기업은 AI에 사진과 설명을 공급해야 해요. 많은 양을 처리하면...\n\n수백만 번의 반복을 통해 AI는 최종적으로 보도와 고양이를 구분할 수 있게 되는 거예요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이를 달성하기 위해 AI 모델을 구축하는 기업들은 이러한 AI 모델을 훈련시키기 위해 사람들로부터 대규모의 분류 데이터베이스를 수집해야 합니다.\n\n요약하면:\n\n- captcha는 문제를 해결하지 못함 (인간과 봇을 구별할 수 없음)\n- captcha의 인류에 미치는 비용은 엄청나다 (매년 77,600채의 주택)\n- captcha 솔루션을 제공하는 기업만 혜택을 받음\n\n그래서 2024년에는 captcha를 전혀 사용해야 할지에 대한 의문이 많이 제기됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n오직 1%의 사람들만 이렇게 긴 글을 끝까지 읽습니다. 축하해요! 여러분과 기술에 대해 이야기를 나눌 수 있어서 기쁩니다. 여러분은 제가 가장 좋아하는 사람들이에요. 구독해 주시면 연락할 수 있기를 바래요!\n\n그런데, 대단하시네요! 기술에 정말 관심이 많으시군요! 'Summon The JSON'이라는 카드 게임을 디자인했어요. 우연히도 맞췄네요! 지금 주문할 수 있습니다!\n\n기술을 좋아하시나요? 소셜 미디어에서 클랩, 구독, 좋아요와 공유해 주세요!\n\nTom Smykowski를 따르는 14,000명의 개발자 중 하나가 되어보세요! 매월 $5에 모든 Medium 기사에 액세스할 수 있고, Tom은 기술에 대해 더 많이 작성할 수 있습니다! 지금 멤버가 되세요!\n","ogImage":{"url":"/assets/img/2024-05-17-ItsAboutTimeToDitchCaptchaIn2024_0.png"},"coverImage":"/assets/img/2024-05-17-ItsAboutTimeToDitchCaptchaIn2024_0.png","tag":["Tech"],"readingTime":8},{"title":"과다 고용이 모든 사람들을 위한 시장을 망치고 있다","description":"","date":"2024-05-17 17:51","slug":"2024-05-17-OverEmploymentIsRuiningtheMarketforEveryone","content":"\n![2024-05-17-OverEmploymentIsRuiningtheMarketforEveryone_0](/assets/img/2024-05-17-OverEmploymentIsRuiningtheMarketforEveryone_0.png)\n\n팬데믹이 시작되었을 때 대다수가 원격으로 일해야 했을 때, 두 가지를 깨달았어요:\n\n- 내가 많은 여유 시간을 가지고 있다는 것을 깨달았어요 (내 직장은 그리 높은 수요가 없는 것 같았어요).\n- 그리고 한 직장으로는 무슨 일이 생길지 모른다는 것을 깨달았어요 (심지어 안정적인 기업도 재정적 문제가 있었어요).\n\n지루했고 미래에 대해 불안했으며 온라인으로 돈을 벌기 위한 새로운 방법을 시도해봐도 완전히 생산적이라고 느끼지 않았어요. 그래서 저는 이전 직장은 유지하면서 다른 정규직을 찾기로 결심했어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n몇 달 후에 현지 은행에서 새 팀을 구축하기 위한 로봇을 만들기 시작했다는 연락을 받았어요. 회사가 새로운 팀을 만들면 진정한 책임이 없다고 하는 게 큰 장점이었어요.\n\n그 덕분에 한동안 문제 없이 두 직장을 할 수 있었어요.\n\n그런데 두 번째 직장이 점차 더 많은 책임을 요구하기 시작하자, 처음 직장에 소홀해지기 시작했어요. 그래서 결국, 나름의 이유로 처음의 직장을 그만두고 더 잘 주는 새 직장에 집중하기로 결정했어요.\n\n나에게 초과 근무는 새로운 경험을 살아보기 위한 몇 달의 기간이었어요. 이덕분에 도덕적으로 옳지 않았고(그건 알고 있어요), 마지막으로는 그냥 제게는 아니었다는 생각이 드네요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n하지만 많은 사람들에게는 이게 새로운 일상이 되어가고 있어요.\n\n그들은 두 개가 아니라 세 개, 네 개, 막상 여섯 개의 일을 동시에 하고 있습니다. 자신의 능력으로 수많은 돈을 벌어들이며, 회사들을 속이고는 하지만 각 회사에서 4~6시간씩 일할만한 충분한 능력이 있다고 생각합니다.\n\n하지만 무엇보다도, 이러한 이기주의로 인해 시장을 망치고 있는 것이죠.\n\n# 왜 과다 고용이 모두를 위해 시장을 망치고 있는지에 대한 이유.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n전 세계에는 100,000명의 프로그래머가 있고 150,000개의 취업 기회가 있다면, 이 직업에서 승진할 수 있는 새로운 방법이 항상 있을 것입니다.\n\n과잉 고용이 인기를 얻기 전에 많은 회사들이 소프트웨어 엔지니어에게 유혹적인 급여와 보상을 제공했습니다. 연봉이 40만 달러, 무제한 휴가, 그리고 무수히 많은 무료 기술들이 제공되었습니다.\n\n그러나 이러한 급여와 보상이 점점 줄어들고 있는 것 같습니다.\n\n지금은 8년 이상 경력을 가진 시니어 풀 스택 개발자에게 월 4,500달러 (연 54,000달러), 부서 전체를 담당하는 팀 리더에게는 7,000달러를 요구하는 회사들도 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아무도 모르는 기술 (.NET Core 또는 React/Angular 중 하나)만 알고 시장에 처음 발을 디딘 사람에 대한 초기 급여는 과거에는 좀 낮은 수준이었습니다.\n\n팀 리더들은 연봉으로 적어도 $120,000를 받았습니다.\n\n하지만 요즘 회사들은 사람들이 필요로 한다는 사실을 알고 있기 때문에, 그들은 아무런 망설임 없이 유혹적인 제안을 합니다.\n\n![image](/assets/img/2024-05-17-OverEmploymentIsRuiningtheMarketforEveryone_1.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이런 일이 발생하는 이유는 많은 시니어 개발자들이 월 수입이 $7000에서 $15,000인 중간급 업무를 찾기로 결정하여 많이 일하지 않아도 일을 할 수 있다고 판단했기 때문입니다. 비록 수입이 적을지라도 추가 수입이기 때문입니다.\n\n따라서 이제 모집업체와 기업들은 반값에 충분히 좋은 인재를 구할 수 있다는 것을 알게 되었습니다.\n\n중간급 직급의 사람들이 첫 직장을 가지면서 빛을 발휘할 수 있도록 주니어 포지션을 차지하기 시작했습니다. 시니어들은 주요 포지션을 유지하면서 빠르게 작업할 수 있는 중간급 포지션을 차지하기 시작했습니다. 일자리가 없는 사람들은 더 이상 제안이 없기 때문에 시니어 포지션을 저렴한 가격에 차지하기 시작했습니다.\n\n지금은 더 이상 주니어 개발자를 위한 포지션이 없습니다. 현재 진입하는 사람들은 뛰어난 실력을 증명하지 않는 한 일자리를 얻기 어려울 것입니다. 왜냐하면 사람들이 나타나는 것을 차지하고 있기 때문이죠.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n150,000 개의 제안 중 60,000 명에 의해 모두 차지되어 40,000 명은 일자리가 없어서 빌을 갚기 위해 어떤 급여라도 받아들이고 있습니다.\n\n최악인 점은 두 개의 직장을 가진 대부분의 사람들이 사실은 두 번째 직장이 필요하지 않다는 것입니다.\n\n# 안타까운 현실은 대부분의 사람들이 욕심 때문에 두 개의 직장을 가지고 있다는 점이죠, 필요 때문은 아닙니다.\n\n안타까운 사실은 이미 좋은 급여를 받는 기술직 종사자들이 가장 많이 과로한 상태라는 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n두 개의 직장을 얻기 전에 수입이 훌륭했어요. 모든 빌을 지불하고 매달 월급의 적어도 40%를 저축할 수 있었죠. 저는 여분의 시간이 있었고 더 많은 돈을 벌 수 있는 쉬운 방법이기 때문에 두 개의 일을 가지기로 결정했어요.\n\n두 개의 직장과 사이드 허슬로 인해 엄마에게 거의 현금으로 집을 사줄 수 있었어요. 또한 포르쉐를 샀고 순자산을 극대화했어요.\n\n난 가족을 부양할 필요도, 상환할 대출도 없었고 큰 질병에 대비할 필요도 없었어요; 난 그저 탐욕스러웠을 뿐이었어요.\n\n내가 알고 있는 주위 사람들 중 두 개의 직장을 한 사람들은 비슷한 이유에서 그랬어요. 그들은 두 번째 직장을 얻었고 부유한 수입에 익숙해졌기 때문이었어요. 듣은 몇 가지 이유는:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- \"리쿠루터가 연락을 주었고, 경험을 얻기 위해서 '예'라고 했어요.\"\n- \"직장 안정성을 원해요\" (현재 직장에서 문제가 없어요).\n- \"대출없이 저택을 짓고 싶어요\" (이 말을 한 사람은 다섯 개의 일을 하며, 현금으로 집을 짓았어요).\n- \"저축을 희생하지 않고도 사치를 누리고 싶어요.\"\n- \"일찍 은퇴하고 싶어요.\"\n\n이 모두가 실제로 필요한 게 없어요.\n\n그들은 그저 고액 연봉으로 최고의 삶을 살고 있어요.\n\n하지만 다른 직업은 누군가의 가족을 먹여살릴 전업직이 될 수도 있어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n시장이 정말 힘든 이유는 일자리 제공보다 일할 필요가 있는 개발자가 더 많기 때문입니다.\n\n# 가장 최악인 점은 이 문제를 해결하기 거의 불가능하다는 것입니다.\n\n문제를 해결하는 쉬운 방법이 없다는 것이 문제입니다.\n\n만약 회사가 원격 근무자의 현재 성과에 만족하고 있다면, 그들이 다른 일자리를 가지고 있다고 의심할 방법이 없습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n많은 기업들이 사무실로 복귀하기로 결정했습니다. 한 사람이 하나의 직장만 가지고 있는지 확인할 수 있기 때문입니다. 그러나 이는 누구에게나 불가능합니다. 특히 실제 장소를 가지고 있는 비용 때문에 그렇습니다.\n\n다른 기업들은 직원이 활발히 일하고 있는지 확인하기 위해 카메라를 켠 채로 끊임없는 회의를 진행합니다. 그러나 이는 직원들이 지치게 만듭니다.\n\n우리 나라에는 의무적인 실업 보험이 있습니다. 만약 어떤 사람이 해고당한다면, 회사는 해당 사람이 그곳에서 근무한 기간에 따라 최대 6개월 동안의 급여를 지급해야 합니다. 이를 통해 사람들이 다른 직장을 얻을 때까지 충분한 돈을 확보할 수 있습니다.\n\n하지만 이는 사람들이 다른 선택지를 찾는 것을 막지는 못했습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n모든 것은 결국 각 개인의 도덕성과 몇 년 동안 이런 방식으로 일한 후에 얼마나 지친 것인지에 달려 있을 것입니다.\n\n개인적으로는 그렇게 다시는 하지 않을 것입니다. 둘 다 경험해 봤기 때문입니다. 두 개의 일을 가진 사람이었을 때와 두 번째 일을 찾아다닐 때 운이 좋지 못했던 일없는 사람이었을 때, 이 두 경험이 모두 나에게 좋지 않았습니다.\n\n하지만 이미 늦었습니다. 그 행동으로 인해 우리는 시장을 망쳤습니다. 이제는 한 가지 직장과 기술로 7,000달러를 벌기 위해 두 개의 일이 필요하며, 한 때 한 개의 일과 기술로 그 급여를 받았던 시절을 떠올리면 우리는 불만을 터뜨릴 수 없습니다. 충분히 요구할 수 없습니다. 나타나는 대로 받아들여야 합니다.\n\n이 모든 일이 벌어진 이유는 초과 수요 때문이라기보다는 더 많은 노동자가 있는 것 때문은 아닙니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n지금은 일자리 시장이 매우 어렵기 때문에 두 개 이상의 직장을 가지고 있는 사람들이 많기 때문입니다.\n\n세네이어 개발자들은 세 명의 일을 하고 있어, 중간 단계에 있던 사람들은 이전처럼 문제를 해결할 수 없게 되었습니다. 우리는 이제 주니어 직책이 더 이상 없어서, 시장에 진입하고 싶은 사람들은 충분히 좋다는 것을 보여주거나 사무실에 가기를 원하는 것을 보여줘야 합니다.\n\n우리는 현실을 받아들여야 합니다. 더 이상 요구할 수 있는 입장에 있지 않습니다. 왜냐하면 두 개의 일을 가지고 있는 사람들은 돈을 계속 벌 수 있도록 어떤 연봉이든 받아들입니다.\n\n저는 두 개의 일을 하는 것을 후회합니다. 더 많은 돈을 버는 대신에 정신 건강과 휴식을 희생한 것 같아요. 결국 두 개의 일 중 하나에서 성과가 나빠졌습니다. 더 열심히 공부했다면, 두 곳에서 일하지 않고 더 나은 위치에 있을 수 있지 않았을까 싶어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n하지만 이미 너무 늦었어요. 두 개의 일을 가지는 것이 너무 보편화되어서 많은 사람들의 성장 기회를 망쳤어요.\n\n과다 고용이 시장을 망친 거예요.\n\n제 글을 놓치지 마세요; 제 이메일 목록에 가입해주세요.\n","ogImage":{"url":"/assets/img/2024-05-17-OverEmploymentIsRuiningtheMarketforEveryone_0.png"},"coverImage":"/assets/img/2024-05-17-OverEmploymentIsRuiningtheMarketforEveryone_0.png","tag":["Tech"],"readingTime":9},{"title":"자신의 디바이스와 함께 Gradle 관리 디바이스를 사용하는 방법","description":"","date":"2024-05-17 17:48","slug":"2024-05-17-HowtouseGradleManagedDeviceswithyourowndevices","content":"\n<img src=\"/assets/img/2024-05-17-HowtouseGradleManagedDeviceswithyourowndevices_0.png\" />\n\n요즘 Google은 안드로이드 Gradle 플러그인을 위한 새로운 기능, Firebase Test Lab for Gradle Managed Devices를 소개했어요. 이 기능은 Gradle Managed Devices API를 사용하여 테스트를 Gradle이 실행되는 동일한 기계가 아니라 Firebase Test Lab(유료 기능) 내에서 원격 가상 또는 물리 장치에서 시작합니다. 이 기사에서는 해당 기능과 Firebase Test Lab과 같은 방식으로 테스트를 원격으로 시작하기 위해 자체 디바이스 팜을 사용하는 방법, 그리고 여러 장치 간에 실행을 병렬화하는 방법에 대해 다룰 거예요.\n\n# Gradle Managed Devices\n\n처음에는 Gradle Managed Devices가 안드로이드 Gradle 플러그인에게 에뮬레이터의 생성, 시작 및 종료 과정을 위임하는 목적으로 출시되었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nandroid {\ntestOptions {\nmanagedDevices {\ndevices {\nregister(\"pixel2api30\", com.android.build.api.dsl.ManagedVirtualDevice) {\ndevice = \"Pixel 2\"\napiLevel = 30\nsystemImageSource = \"aosp\"\n}\n}\n}\n}\n}\n\n위의 구성을 사용하면 pixel2api30Check 작업을 통해 UI 테스트를 실행할 수 있으며, 기기를 연결하거나 에뮬레이터를 실행할 필요가 없습니다. 이 테스트 실행 환경은 다양한 기계에서 동일합니다.\n\n<img src=\"/assets/img/2024-05-17-HowtouseGradleManagedDeviceswithyourowndevices_1.png\" />\n\n# Firebase Test Lab\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n파이어베이스 테스트 랩을 통한 Gradle Managed Devices는 Android Dev Summit 2022에서 최근 소개된 새로운 기능입니다. 이제 Gradle에서 바로 테스트 랩에서 UI 테스트를 실행할 수 있어서 명령줄 도구나 웹 UI를 사용할 필요가 없어졌어요.\n\n```js\nplugins {\n    id 'com.google.firebase.testlab'\n}\n\nandroid {\n    testOptions {\n        managedDevices {\n            devices {\n                register(\"pixel2api30\", com.google.firebase.testlab.gradle.ManagedDevice) {\n                    device = \"Pixel2\"\n                    apiLevel = 30\n                }\n            }\n        }\n    }\n}\n```\n\n<img src=\"/assets/img/2024-05-17-HowtouseGradleManagedDeviceswithyourowndevices_2.png\" />\n\n우리 자신의 장치로도 같은 작업을 할 수 있을까요? 함께 알아봐요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 커스텀 디바이스 구현\n\n여러분이 아시다시피, 저희는 com.android.build.api.dsl.ManagedVirtualDevice 또는 com.google.firebase.testlab.gradle.ManagedDevice를 사용하고 있는데, 이 둘 모두 com.android.build.api.dsl.Device 인터페이스를 구현하고 있습니다. 그래서 우리가 직접 커스텀한 디바이스를 구현하려고 하면 어떻게 될까요?\n\n필요한 Gradle 코드, 플러그인 등을 모두 추가할 새 모듈을 만들어봅시다. buildSrc 폴더를 사용하거나 새로운 included build를 생성하여 할 수 있습니다. 여기서는 새로운 Gradle 플러그인을 생성하는 과정에 대해서는 다루지 않겠지만, 관련 정보는 공식 문서나 저의 다른 글에서 찾아볼 수 있습니다.\n\n새로 생성한 Gradle 플러그인 모듈에서 MyDevice를 선언하고 해당 디바이스를 애플리케이션 모듈의 build.gradle에서 사용해보세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n인터페이스 MyDevice : Device\n```\n\n```js\nandroid {\n    testOptions {\n        managedDevices {\n            devices {\n                register(\"myDevice\", MyDevice) {}\n            }\n        }\n    }\n}\n```\n\n프로젝트를 동기화하려고 하면 다음 예외가 발생합니다: 이 컨테이너에서 MyDevice를 생성할 수 없습니다. 이것은 android.testOptions.managedDevices.devices 컨테이너가 MyDevice를 인스턴스화할 방법을 모르기 때문입니다. 왜냐하면 MyDevice가 인터페이스이기 때문입니다.\n\n그렇다면 Android Gradle 플러그인은 이 문제를 어떻게 관리할까요? com.android.build.api.dsl.ManagedVirtualDevice를 검색하면 다음 코드를 찾을 수 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\ndslServices.polymorphicDomainObjectContainer(Device::class.java).apply {\n    registerBinding(\n        com.android.build.api.dsl.ManagedVirtualDevice::class.java,\n        com.android.build.gradle.internal.dsl.ManagedVirtualDevice::class.java\n    )\n}\n```\n\nregisterBinding을 사용하면 플러그인은 컨테이너에 com.android.build.api.dsl.ManagedVirtualDevice 유형의 어떤 것을 추가하려고 시도하는 API 클라이언트가 있을 때 내부 클래스 com.android.build.gradle.internal.dsl.ManagedVirtualDevice를 사용하도록 지시하는 것입니다. 컨테이너는 ManagedVirtualDevice 클래스의 인스턴스를 생성하고 해당 인스턴스를 register 메소드의 람다에 제공할 것입니다.\n\n동일한 작업을 하기 위해 MyDevice를 구현하는 추상 클래스와 사용자 지정 Gradle 플러그인이 필요하며 해당 플러그인을 프로젝트에 적용해야 합니다.\n\n```js\ninternal abstract class MyDeviceImpl(\n    private val name: String,\n): MyDevice {\n    override fun getName(): String = name\n}\n\nclass MyDevicePlugin : Plugin<Project> {\n    override fun apply(target: Project) {\n        target.plugins.withType(AndroidBasePlugin::class.java) {\n            target.extensions.configure(CommonExtension::class.java) {\n                it.testOptions.managedDevices.devices.registerBinding(\n                    MyDevice::class.java,\n                    MyDeviceImpl::class.java,\n                )\n            }\n        }\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nplugins {\n    id `my-device-plugin`\n}\n\nandroid {\n    testOptions {\n        managedDevices {\n            devices {\n                register(\"myDevice\", MyDevice) {}\n            }\n        }\n    }\n}\n```\n\n그래서 다시 동기화를 시도하여 다른 예외를 확인해 봅시다:\n\n```js\nCaused by: java.lang.IllegalStateException: 지원되지 않는 관리형 장치 유형:\n class com.bumble.devicefarm.plugin.device.farm.DeviceFarmImpl_Decorated\n at com.android.build.gradle.internal.TaskManager.createTestDevicesForVariant(TaskManager.kt:1905)\n```\n\n스택 추적을 따라가보면, gradle.properties에 android.experimental.testOptions.managedDevices.customDevice=true를 추가해야 하며 MyDevice는 ManagedDeviceTestRunnerFactory를 구현해야 한다는 것을 알 수 있습니다. 따라서 더 자세히 조사해 보겠습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\n내부 추상 클래스 MyDeviceImpl(\n  private val name: String\n) : MyDevice, ManagedDeviceTestRunnerFactory {\n\n  override fun getName(): String = name\n\n  override fun createTestRunner(\n    project: Project,\n    workerExecutor: WorkerExecutor,\n    useOrchestrator: Boolean,\n    enableEmulatorDisplay: Boolean\n  ): ManagedDeviceTestRunner =\n    MyDeviceTestRunner()\n\n}\n```\n\n팩토리 자체에는 중요한 값이 없습니다. 반환되는 클래스 ManagedDeviceTestRunner이 더 흥미로운 부분입니다.\n\n```kotlin\ninterface ManagedDeviceTestRunner {\n\n  // 모든 테스트 케이스가 통과되면 true를 반환합니다. 그렇지 않으면 false를 반환합니다.\n  fun runTests(\n    managedDevice: Device,\n    runId: String,\n    outputDirectory: File,\n    coverageOutputDirectory: File,\n    additionalTestOutputDir: File?,\n    projectPath: String,\n    variantName: String,\n    testData: StaticTestData,\n    additionalInstallOptions: List<String>,\n    helperApks: Set<File>,\n    logger: Logger\n  ): Boolean\n\n}\n```\n\nrunTests 메서드는 각 Gradle 모듈에 대해 호출되며, 테스트를 실행하는 데 사용할 수 있는 많은 데이터가 포함되어 있습니다. 여기서 testData를 사용하여 APK를 가져와 설치하고, 계장을 통해 테스트를 실행할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# Instrumentation\n\n안녕하세요! 안드로이드 스튜디오에서 테스트를 실행하는 방법은 대부분 우리가 잘 알고 있습니다. 테스트 이름 근처의 실행 버튼을 클릭하거나 Gradle을 통해 connectedAndroidTest를 실행하는 방법이 있죠. 이제 이러한 도구 없이도 어떻게 테스트를 실행할 수 있는지 알아봅시다.\n\n이 두 가지 접근 방법은 디바이스에서 am instrument 명령을 사용합니다. 이 명령은 ADB를 통해 실행됩니다. 더 자세한 내용은 공식 문서를 참고해보세요.\n\n```js\nadb shell am instrument -w <test_package_name>/<runner_class>\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n테스트를 실행하려면 runTests 메서드에서 동일한 작업을 해야 합니다. ADB 작업을 수행하기 위해 mobile.dev의 dadb 라이브러리를 사용할 것입니다. 이 라이브러리를 사용하면 ADB 실행 파일을 이용하지 않고 ADB 프로토콜을 통해 디바이스에 직접 연결할 수 있습니다. 이렇게 하면 작업 속도가 향상되며 편리하게 사용할 수 있습니다. 관련 블로그 포스트에서 이에 대해 자세히 읽을 수 있습니다.\n\nrunTests 메서드 내에서 Dadb를 사용하여 로컬 에뮬레이터에 연결하고 APK를 설치하고 테스트를 실행해보겠습니다.\n\n```kotlin\noverride fun runTests(...): Boolean {\n    // 로컬 에뮬레이터에 연결\n    Dadb.create(\"localhost\", 5555).use { dadb ->\n        // 애플리케이션 APK 설치\n        val apks = testData.testedApkFinder.invoke(DadbDeviceConfigProvider(dadb))\n        // 라이브러리 모듈인 경우 비워둡니다.\n        if (apks.isNotEmpty()) {\n            // 앱 번들을 지원하기 위해 여러 개의 APK 설치 사용\n            dadb.installMultiple(apks)\n        }\n        // 계기 APK 설치\n        dadb.install(testData.testApk)\n\n        // 테스트 실행\n        dadb.shell(\"am instrument -w ${testData.applicationId}/${testData.instrumentationRunner}\")\n    }\n    return true\n}\n```\n\nrunTests 메서드와 StaticTestData 클래스에는 많은 매개변수가 있습니다. 단순화를 위해 모든 것이 작동하는 데 필요한 최소한의 세트만 사용할 것입니다. 다음과 같은 것을 사용할 것입니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- testData.testedApkFinder는 필요한 애플리케이션 APK를 가져오기 위해 사용됩니다. 라이브러리 모듈의 경우 빈 목록을 반환합니다. App Bundle에서 적절한 APK 목록을 제공하기 위해 DeviceConfigProvider를 받습니다.\n- testData.testApk은 androidTest 폴더에서 코드를 포함하는 instrumentation APK입니다.\n- testData.applicationId는 instrument 명령으로 실행해야 하는 애플리케이션 ID입니다.\n- testData.instrumentationRunner는 build.gradle 파일에서 지정한 androidx.test.runner.AndroidJUnitRunner와 같은 테스트 러너입니다.\n\n일단 사용자 정의 DeviceConfigProvider의 구현은 건너뜁니다. 이는 dadb.shell(\"getptop name\").output과 같은 다수의 속성에 대해 locale, 화면 밀도, 언어, 지역 및 ABI를 가져오도록 단순히 호출할 뿐입니다. 프로젝트 저장소에서 구현 세부 정보를 확인할 수 있습니다.\n\n지금까지 다음 구조를 구현했습니다:\n\n![image](/assets/img/2024-05-17-HowtouseGradleManagedDeviceswithyourowndevices_3.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 결과 가져오기\n\nrunTests 메서드는 모든 테스트가 통과되면 true를 반환해야 하지만, 지금은 항상 true를 반환합니다. 계기 결과를 얻기 위해 조금 더 파고들어야 합니다.\n\n기본적으로 명령줄에서 am instrument를 실행하려고 하면 실패 사항과 최종 결과만을 볼 수 있습니다. 더 많은 정보를 표시하려면 -r 및 -m 두 가지 플래그가 있습니다. 첫 번째는 결과를 텍스트 스트림으로 반환하고, 두 번째는 프로토콜 버퍼 스트림으로 반환합니다(API `= 26에서만 지원됨). 간단히 하기 위해 지금은 두 번째를 사용하겠습니다.\n\nAndroid Gradle 플러그인은 RemoteAndroidTestRunner.StatusReporterMode.PROTO_STD 열거형을 사용하여 am instrument에서 원시 데이터를 수용할 수 있는 IInstrumentationResultParser 인스턴스를 만듭니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\nval mode = RemoteAndroidTestRunner.StatusReporterMode.PROTO_STD\nval parser = mode.createInstrumentationResultParser(runId, emptyList())\n\nDadb.create(host, port).use { dadb ->\n    ...\n    dadb\n        .openShell(\"am instrument -w ${mode.amInstrumentCommandArg} $arguments ${testData.applicationId}/${testData.instrumentationRunner}\")\n        .use { stream ->\n            while (true) {\n                val packet: AdbShellPacket = stream.read()\n                if (packet is AdbShellPacket.Exit) break\n                parser.addOutput(packet.payload, 0, packet.payload.size)\n            }\n            parser.flush()\n        }\n    ...\n}\n```\n\n이번에는 shell 메서드 대신 openShell 메서드를 사용합니다. 이 메서드는 Protocol Buffers 스트림인 원시 데이터 스트림에 액세스할 수 있도록 해줍니다. 이 데이터는 IInstrumentationResultParser로 전달됩니다.\n\n# HTML 및 XML 보고서 및 암시적인 예상\n\nIInstrumentationResultParser는 테스트와 상태에 대해 청취자들에게 알립니다. emptyList()를 전달했을 것을 알 수 있습니다. 어떤 파서를 사용해야 할지 고려해보겠습니다. 몇 가지 사전 제작된 구현이 있지만, Android Gradle 플러그인이 ManagedVirtualDevice를 실행할 때 사용하는 com.android.build.gradle.internal.testing.CustomTestRunListener를 사용해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\nval xmlWriterListener = CustomTestRunListener(\n    name,\n    projectPath,\n    variantName,\n    LoggerWrapper(logger),\n)\nxmlWriterListener.setReportDir(outputDirectory)\nxmlWriterListener.setHostName(\"localhost:5555\")\n...\nval parser = mode.createInstrumentationResultParser(runId, listOf(xmlWriterListener))\n...\nreturn !xmlWriterListener.runResult.hasFailedTests()\n```\n\nCustomTestRunListener은 XmlTestRunListener를 확장하고 Android Gradle 플러그인, TeamCity 또는 여러분께 사용될 수 있는 테스트의 XML 보고서를 작성할 것입니다.\n\n만약 CustomTestRunListener로 보고서를 생성하지 않고 myDeviceDebugAndroidTest를 실행하려고 하면, com.android.build.gradle.internal.tasks.ManagedDeviceInstrumentationTestResultAggregationTask에서 예외로 실패할 것입니다. 적어도 TEST-로 시작하는 하나의 XML 보고서를 생성할 것으로 예상합니다. 그리고 CustomTestRunListener야말로 이를 강요합니다. 이 작업은 XML과 HTML 보고서를 생성할 것이며, 아래 스크린샷에서 확인할 수 있습니다:\n\n![스크린샷](/assets/img/2024-05-17-HowtouseGradleManagedDeviceswithyourowndevices_4.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 CustomTestRunListener를 사용하여 runTests 메서드에서 적절한 값을 반환할 수 있습니다. hasFailedTests 메서드에 액세스할 수 있기 때문입니다.\n\n# 원격 실행\n\nDadb.create를 사용할 때 localhost뿐만 아니라 모든 IP 주소를 전달할 수도 있습니다. 이는 코드를 사용하여 원격 에뮬레이터나 장치에서 테스트를 실행할 수 있다는 것을 의미합니다. 이를 위해 MyDevice를 설정 가능하게 만들 수 있습니다.\n\n```js\ninterface MyDevice : Device {\n\n    @get:Input\n    val host: Property<String>\n\n    @get:Input\n    val port: Property<Int>\n\n}\n\ninternal abstract class MyDeviceImpl(\n    private val name: String,\n) : RemoteDevice, ManagedDeviceTestRunnerFactory {\n\n    init {\n        // 기본 매개변수\n        host.convention(\"localhost\")\n        port.convention(5555)\n    }\n\n    ...\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nregister(\"remoteDevice\", MyDevice) {\n    it.host = \"192.168.3.4\"\n    it.port = 43617\n}\n```\n\n그런 다음 `Dadb.create(managedDevice.host.get(), managedDevice.port.get())`를 사용하세요.\n\n![이미지](/assets/img/2024-05-17-HowtouseGradleManagedDeviceswithyourowndevices_5.png)\n\n주의 깊게 읽는 독자는 이미 코드 없이 이를 수행할 수 있다는 것을 올바르게 알아차릴 수 있을 것입니다. 원격 장치를 adb 장치 목록에 표시하려면 adb connect IP:PORT를 호출하기만 하면 된다는 것이 충분하며, Android Studio 드롭다운 메뉴 안에서도 바로 확인할 수 있습니다. Gradle Managed Devices로 할 수 없는 테스트 디버깅을 할 수도 있습니다. 그러나 이러한 점을 수행할 수 있다는 것은 다음 단계에 중요한 요소입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 병렬 실행\n\n기본적으로 테스트를 실행할 때 한 번에 한 장치에서만 실행됩니다. 여러 장치나 에뮬레이터에서 테스트를 병렬로 실행할 수 있는 기능이 있다면 좋을텐데요. 좋은 소식은 그런 방법을 찾았다는 것입니다.\n\nAndroidJUnitRunner은 테스트를 샤드(shard)로 분할하여 하나의 샤드를 실행하는 기능을 지원합니다. 예를 들어, am instrument -w -e numShards 2 -e shardIndex 0는 두 개의 테스트 중 첫 번째 테스트를 실행하고, -e shardIndex 1은 두 개의 테스트 중 두 번째 테스트를 실행합니다.\n\n하지만 이를 실제로 활용하려고 하면 다음과 같은 내용이 나타날 것입니다 (출처):\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n#!/usr/bin/env bash\n./gradlew assembleAndroidTest\npids=\nenv ANDROID_SERIAL=emulator-5554 ./gradlew \\\n    connectedAndroidTest \\\n    -Pandroid.testInstrumentationRunnerArguments.numShards=2 \\\n    -Pandroid.testInstrumentationRunnerArguments.shardIndex=0 \\\n    -PtestReportsDir=build/testReports/shard0 \\\n    -PtestResultsDir=build/testResults/shard0 \\\n    &\npids+=\" $!\"\nenv ANDROID_SERIAL=emulator-5556 ./gradlew \\\n    connectedAndroidTest \\\n    -Pandroid.testInstrumentationRunnerArguments.numShards=2 \\\n    -Pandroid.testInstrumentationRunnerArguments.shardIndex=1 \\\n    -PtestReportsDir=build/testReports/shard1 \\\n    -PtestResultsDir=build/testResults/shard1 \\\n    &\npids+=\" $!\"\nwait $pids || { echo \"there were errors\" >&2; exit 1; }\nexit 0\n```\n\n이 방법은 ‘편리’에서는 거리가 먼 방법이며, 많은 매개변수를 사용하여 두 connectedAndroidTest 작업을 병렬로 실행하고 결과를 수동으로 병합한 후 TeamCity와 같은 곳에 보고해야 합니다.\n\nGradle Managed Devices는 android.experimental.androidTest.numManagedDeviceShards=`number_of_shards`와 같은 옵션을 통해 테스트 샤딩을 지원하지만, ManagedVirtualDevice에서만 작동합니다. 우리의 경우에는 자체적으로 관리하는 장치들과 함께 샤딩을 사용하고 싶습니다.\n\nGradle Managed Devices에서는 Device 추상화를 사용합니다. 이 추상화는 전체로 표현되는 여러 장치를 구현할 수 있습니다. 새로운 장치 유형을 소개하고 장치로 등록합시다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\n인터페이스 MultipleDevices : Device {\n\n    @get:Input\n    val devices: ListProperty<String>\n\n}\n```\n\n```kotlin\nandroid {\n    testOptions {\n        managedDevices {\n            devices {\n                register(\"multipleDevices\", com.example.MultipleDevices) {\n                    it.devices.add(\"localhost:5555\")\n                    it.devices.add(\"localhost:5557\")\n                }\n            }\n        }\n    }\n}\n```\n\nADB와 관련된 모든 것은 AdbRunner 클래스로 추출되었고 새 매개변수 ShardInfo(index, total)가 추가되었습니다. ShardInfo의 매개변수는 dadb.openShell(“am instrument”) 실행에 그대로 추가됩니다.\n\n이제 테스트를 병렬로 실행하도록 ManagedDeviceTestRunner를 구현해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\noverride fun runTests(...): Boolean {\n\n    val devices = managedDevice.devices.get().map {\n        // \"host:port\"를 Pair<String, Int>로 분리\n        val split = it.split(':')\n        split[0] to split[1].toInt()\n    }\n\n    val threadPool = Executors.newCachedThreadPool()\n\n    val futures = devices.mapIndexed { index, (host, port) ->\n        threadPool.submit(Callable {\n            val runner = AdbRunner(\n                host = host,\n                port = port,\n                shardInfo = AdbRunner.ShardInfo(\n                    index = index,\n                    total = devices.size,\n                ),\n            )\n            val result = runner.run(\n                // 각 디바이스에 대해 고유한 이름을 사용하여 독립적인 XML 보고서를 생성해야 합니다.\n                name = \"${managedDevice.name}-${host}-${port}\",\n                runId = runId,\n                outputDirectory = outputDirectory,\n                projectPath = projectPath,\n                variantName = variantName,\n                testData = testData,\n                logger = logger,\n            )\n            result\n        })\n    }\n\n    val success = futures.all { it.get() }\n\n    threadPool.shutdown()\n\n    return success\n}\n```\n\n주의해야 할 사항:\n\n- ThreadPool을 사용하고 있는데, 이는 Gradle에서 좋지 않은 방법입니다. 대신 WorkerExecutor를 사용해야 합니다. ManagedDeviceTestRunnerFactory의 매개변수에서 사용 가능한 WorkerExecutor 인스턴스를 얻을 수 있습니다. 현재 사용하지 않는 이유는 StaticTestData가 직렬화되지 않아 별도의 직렬화 가능한 데이터 홀더로 속성을 복사하여 WorkerExecutor에 전달하고 싶지 않기 때문입니다.\n- 이름은 각 shard에 대해 고유해야 합니다. CustomTestRunListener에 이름을 전달하여 파일 이름에 이름이 포함된 XML 보고서가 생성됩니다. 모든 XML 보고서는 나중에 모아져 병합되므로 어떤 테스트가 어떤 디바이스에서 실행되었는지 확인할 수 있습니다.\n\n<img src=\"/assets/img/2024-05-17-HowtouseGradleManagedDeviceswithyourowndevices_6.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n샤딩은 매우 중요하며 많은 UI 테스트 케이스에서 도움이 됩니다. 샘플 레파지토리에서는 라이브러리와 어플리케이션 모듈을 준비했는데, 두 모듈 모두 100개의 UI 테스트가 있습니다. 한 모듈에서 테스트를 실행하는 데 약 1분 10초가 걸립니다. 그러므로 두 모듈을 함께 실행하는 데는 약 2분 33초가 소요됩니다. 같은 테스트 스위트를 MultipleDevices에서 실행하면 약 1분 31초만에 완료됩니다. — 필요한 시간의 거의 절반입니다.\n\n```js\n  에뮬레이터 수  시간\n ----------- -----------\n  1           2분 33초\n  2           1분 31초\n  3           43초\n```\n\n<img src=\"/assets/img/2024-05-17-HowtouseGradleManagedDeviceswithyourowndevices_7.png\" />\n\n# 병렬 원격 실행\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n비록 이렇게 급격한 개선이 있었지만, 하나의 문제에서는 자유로울 수 없습니다: 로컬에서 에뮬레이터를 실행해야 하기 때문에, 개발자 노트북의 자원을 많이 소비합니다.\n\n이 문제를 해결하기 위해 수십 개의 에뮬레이터를 호스팅할 서버를 만들어 HTTP API를 다음과 같이 가지게 만들어보죠:\n\n```js\nGET /lease?devices=%number%\n\n200 OK\n[\n    {\n        host: \"10.10.0.3\",\n        port: 5555,\n        release_key: \"ab34fd2d158f9\"\n    },\n    ...\n]\n\nPOST /release\n[ \"ab34fd2d158f9\", ... ]\n\n200 OK\n```\n\n해당 서버는 우리만 사용할 수 있는 단말기나 에뮬레이터의 집합을 반환하며, 해당 API 호출로 이들을 해제할 때까지만 사용할 수 있습니다. 이를 \"장치 브로커\"라고 부르도록 합시다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n디바이스 브로커는 개발자뿐만 아니라 CI(지속적인 통합)에도 혜택을 줍니다. 일반적인 CI 흐름은 앱을 빌드하고 에뮬레이터에서 테스트를 실행하는 것입니다. 이 두 단계는 CPU 및 메모리를 많이 사용하는 작업이므로 이러한 작업을 병렬로 수행할 수도 있습니다. 에뮬레이터를 다른 서버로 외부위탁함으로써 빌드 서버는 앱을 빌드하고 테스트 결과를 확인하는 데에 자원을 공유하는 대신 집중할 수 있게 됩니다.\n\nGradle 쪽의 구현은 상당히 간단하며 MultipleDevices와 유사한 모양입니다.\n\n```js\ninterface DeviceFarm : Device {\n\n    @get:Input\n    val shards: Property<Int>\n\n}\n\nclass DeviceBroker {\n\n    fun lease(amount: Int): Collection<Device> {\n        TODO(\"디바이스를 얻기 위한 네트워크 요청을 만듭니다. 이용 가능한 디바이스가 없는 경우 대기해야 합니다.\")\n    }\n\n    fun release(devices: Collection<Device>) {\n        TODO(\"다른 사용자를 위해 디바이스를 해제하기 위한 네트워크 요청을 만듭니다.\")\n    }\n\n    class Device(\n        val host: String,\n        val port: Int,\n        val releaseToken: String,\n    )\n\n}\n\ninternal class DeviceFarmTestRunner : ManagedDeviceTestRunner {\n\n    override fun runTests(...): Boolean {\n        val broker = DeviceBroker()\n        val devices = broker.lease(managedDevice.shards.get())\n\n        devices.forEachIndexed { shardIndex, device ->\n            ...\n        }\n\n        broker.release(devices)\n\n        return success\n    }\n\n}\n```\n\n![이미지](/assets/img/2024-05-17-HowtouseGradleManagedDeviceswithyourowndevices_8.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 결과\n\n우리는 Gradle Managed Devices와 통합하기 위한 사용자 정의 장치를 구현하는 방법에 대해 조사했습니다. 장치는 우리가 원하는 것으로 뒷받침될 수 있는 추상화입니다: 단일 장치 또는 에뮬레이터, 로컬 또는 Firebase Test Lab과 같은 웹 서비스에 원격으로 호스팅되거나 브로커 서비스가 있는 사용자 정의 장치 팜 등이 될 수 있습니다. 단일 장치의 경우에는 ADB를 통해 직접 adb connect를 사용하여 연결할 수 있으므로 실질적인 혜택이 없습니다(디버거를 연결하는 기능과 같은 기능을 손실하지 않으면서). 그러나 여러 원격 장치에 뒷받침된 장치를 구현함으로써 개발자의 노트북 및 CI 빌드 서버의 계산 리소스를 할당할 수 있습니다. 또한 샤딩 기능을 사용하여 테스트 실행을 병렬화하고, 2대의 장치를 사용할 경우 테스트 실행 속도를 2배 높일 수 있습니다.\n\n코드는 저장소에서 사용할 수 있지만, 이것은 개념 증명으로 의도된 대로 프로덕션에서 사용되는 것이 아님을 명심하십시오. 코드는 조직에서 이 접근 방식을 도입하는 데 큰 도움이 될 수 있습니다. 구현 세부사항은 귀하의 인프라에 크게 의존합니다. 마지막으로 코드 자체는 오류에 강건하지 않으며 더 신뢰할 수 있는 방식으로 다시 작성해야 합니다.\n\n질문이 있으시면 아래의 코멘트 섹션에서 자유롭게 물어봐 주세요.\n","ogImage":{"url":"/assets/img/2024-05-17-HowtouseGradleManagedDeviceswithyourowndevices_0.png"},"coverImage":"/assets/img/2024-05-17-HowtouseGradleManagedDeviceswithyourowndevices_0.png","tag":["Tech"],"readingTime":25},{"title":"3DraftCode  Retrofit","description":"","date":"2024-05-17 17:47","slug":"2024-05-17-3DraftCodeRetrofit","content":"\n<img src=\"/assets/img/2024-05-17-3DraftCodeRetrofit_0.png\" />\n\n# Retrofit이란 무엇인가요?\n\nRetrofit은 안드로이드 개발에서 네트워킹을 위해 사용되는 인기 있는 라이브러리 또는 종속성 중 하나입니다. 이는 RESTful 서비스와 상호 작용하는 데 사용하는 고수준 인터페이스를 제공하여 웹 서비스와 API로 HTTP 요청을 보내는 과정을 단순화합니다. Retrofit을 사용하면 API 엔드포인트와 JSON 응답을 나타내는 데이터 모델을 간단하고 선언적인 방식으로 정의할 수 있습니다. 또한 네트워크 요청, JSON 데이터의 직렬화 및 역직렬화와 같은 작업을 처리하여 개발자가 안드로이드 애플리케이션에서 웹 서버와 RESTful API를 소비하는 것이 더 쉽도록합니다. 전반적으로 Retrofit은 안드로이드 앱에서 네트워크 작업을 처리하는 간편함, 효율성 및 유연성으로 널리 사용됩니다.\n\n# 왜 Retrofit을 사용해야 할까요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nRetrofit은 Android 개발에서 네트워크 작업을 처리하는 우선적인 선택으로 여겨지는 몇 가지 이점을 제공합니다:\n\n- 간편함: Retrofit은 API 엔드포인트를 정의하고 상호 작용하기 위한 깨끗하고 직관적인 인터페이스를 제공하여 네트워크 요청을 만드는 과정을 간소화합니다.\n- 유형 안정성: Retrofit은 API 인터페이스 정의를 기반으로 유형 안전한 HTTP 클라이언트를 생성합니다. 이는 개발자로서 HTTP 요청 및 응답에 대한 컴파일 시간 유효성 검사를 제공하여 데이터 유형이 잘못된 경우나 필드가 누락된 경우의 런타임 오류 가능성을 줄입니다.\n- 쉬운 통합: Retrofit은 Android 생태계의 다른 인기 있는 라이브러리들과 원활하게 통합됩니다. 예를 들어 JSON 직렬화/역직렬화를 위한 Gson이나 Moshi, 그리고 비동기 작업 처리를 위한 RxJava나 Kotlin 코루틴 등을 사용할 수 있습니다.\n- 효율성: Retrofit은 성능을 최적화하여 네트워크 리소스를 효율적으로 사용합니다. 요청/응답 캐싱, 연결 풀링, 비동기 요청 실행 등의 기능을 지원하여 빠르고 반응성이 좋은 애플리케이션을 만드는 데 도움을 줍니다.\n- 유연성: Retrofit은 다양한 사용 사례와 요구 사항에 적응하기 위한 다양한 사용자 정의 옵션을 제공합니다. HTTP 헤더, 요청 타임아웃, 오류 처리 메커니즘, 로깅 수준 등을 필요에 맞춰 구성할 수 있습니다.\n\n# Retrofit을 사용해야 하는 경우?\n\nRetrofit이 제공하는 다양한 이점을 고려하면, 네트워크 작업 및 RESTful API와 작업할 때마다 Retrofit을 사용해야 한다고 생각합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# Retrofit 예제?\n\n여기서 Retrofit을 사용하는 방법을 공유할게요.\n\n1. Android 프로젝트에 Retrofit 추가하기 (build.gradle)\n\n```js\ndependencies {\n    implementation 'com.squareup.retrofit2:retrofit:2.9.0'\n    implementation 'com.squareup.retrofit2:converter-gson:2.9.0' // JSON 직렬화/역직렬화를 위해\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n2. 데이터 클래스 정의\n\nJSON 응답 API를 기반으로 데이터 클래스를 정의하세요.\n\n```kotlin\ndata class User(\n    val id: Int,\n    val name: String,\n    val username: String,\n    val email: String\n)\n```\n\n3. API 인터페이스 정의\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\n인터페이스 ApiService {\n\n    @GET(\"users/{id}\")\n    fun getUserById(@Path(\"id\") userId: Int): Call<User>\n\n}\n```\n\n4. Retrofit 인스턴스 생성\n\n기본 URL을 구성하고 JSON 파싱을 위한 컨버터 팩토리를 추가하려면 Retrofit 인스턴스를 설정하십시오.\n\n```kotlin\nobject ApiClient {\n    private const val BASE_URL = \"https://jsonplaceholder.typicode.com/\"\n\n    val retrofit: Retrofit = Retrofit.Builder()\n        .baseUrl(BASE_URL)\n        .addConverterFactory(GsonConverterFactory.create())\n        .build()\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n5. 네트워크 요청 만들기\n\n여기에서 Retrofit을 사용하여 Activity에서 네트워크 요청을 할 수 있습니다.\n\n```kotlin\nclass MainActivity : AppCompatActivity() {\n\n    private lateinit var apiService: ApiService\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n\n        apiService = ApiClient.retrofit.create(ApiService::class.java)\n\n        getUserById(userId: 1)\n    }\n\n    private fun getUserById(userId: Int) {\n        val call = apiService.getUserById(userId)\n        call.enqueue(object : Callback<User> {\n            override fun onResponse(call: Call<User>, response: Response<User>) {\n                if (response.isSuccessful) {\n                    val user = response.body()\n                    Log.d(\"MainActivity\", \"User: $user\")\n                } else {\n                    Log.e(\"MainActivity\", \"Request failed: ${response.errorBody()}\")\n                }\n            }\n\n            override fun onFailure(call: Call<User>, t: Throwable) {\n                Log.e(\"MainActivity\", \"Network request failed\", t)\n            }\n        })\n    }\n}\n```\n\n6. Manifest에 권한을 추가하는 것을 잊지 마세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n<uses-permission android:name=\"android.permission.INTERNET\" />\n```\n\n자세한 내용은 Retrofit 공식 페이지를 확인해보세요.\n","ogImage":{"url":"/assets/img/2024-05-17-3DraftCodeRetrofit_0.png"},"coverImage":"/assets/img/2024-05-17-3DraftCodeRetrofit_0.png","tag":["Tech"],"readingTime":6}],"page":"112","totalPageCount":113,"totalPageGroupCount":6,"lastPageGroup":13,"currentPageGroup":5},"__N_SSG":true}