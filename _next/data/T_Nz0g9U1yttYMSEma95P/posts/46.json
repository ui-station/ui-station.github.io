{"pageProps":{"posts":[{"title":"Swft Data로 SwiftUI 어플리케이션 개발하기","description":"","date":"2024-05-27 18:02","slug":"2024-05-27-BuildingSwiftUIApplicationswithSwiftData","content":"\n![Image](/assets/img/2024-05-27-BuildingSwiftUIApplicationswithSwiftData_0.png)\n\n# Swift UI는 Swift Data를 시작하는 가장 쉬운 방법입니다\n\n- Swift UI와의 완벽한 통합\n- 간편한 구성\n- 데이터 자동 가져오기 및 뷰 업데이트\n\n# Swift Data 소개\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n표를 마크다운 형식으로 변경해 주세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\n@Model\nclass Category {\n\n  @Attribute(.unique) var name: String\n  var imageName: String\n\n  init(name: String,\n       imageName: String = \"rupeesign.circle\",\n       type: CategoryType) {\n    self.name = name\n    self.imageName = imageName\n  }\n\n}\n```\n\n## Using the model macro\n\nModifies all stored properties\n\n@Model\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 강력한 새로운 스위프트 매크로\n- 코드로 스키마 정의하기\n- 모델 유형에 스위프트 데이터 기능 추가하기\n\n속성을 어떻게 추론할지 제어합니다.\n\n@Attributes\n\n- 속성에서 추론된 속성\n- 기본 값 유형 지원\n- 구조체, 열거형, Codable 및 값 유형의 컬렉션과 같은 복잡한 값 유형의 지원\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n@관계\n\n- 관계는 참조 유형에서 유추됩니다.\n- 다른 모델 유형\n- 모델 유형의 컬렉션\n\n@Transient로 속성 제외\n\n더 많은 정보: Swift Data로 스키마 모델링하기 (WWDC 2023)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 데이터 작업하기\n\n## 모델 컨테이너\n\n- 영속성 백엔드\n- 구성에 맞게 사용자 지정\n- 스키마 마이그레이션 옵션 제공\n\n```js\n.modelContainer(for: Category.self) { result in\n    // TODO: - 결과 처리\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 모델 컨텍스트\n\n- 업데이트 추적\n- 모델 가져오기\n- 변경 내용 저장\n- 변경 내용 취소\n\n![이미지](/assets/img/2024-05-27-BuildingSwiftUIApplicationswithSwiftData_1.png)\n\n더 많은 정보: SwiftData에 대한 깊은 탐구 (WWDC 2023)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# SwiftUI와 통합\n\nSwiftData는 SwiftUI를 염두에 두고 만들어졌으며 함께 사용하는 것이 더 쉽습니다.\n\n뷰 수정자\n\n- 씬 및 뷰 수정자 활용\n- .modelContainer로 데이터 구성\n- SwiftUI 환경 전체에 전파됨\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n@Query Property Wrapper\n\n```swift\n@Query var categories: [Category]\nvar body: some View {\n List(categories) { category in\n  NavigationLink(category.name, destination: CategoryView(category))\n }\n}\n```\n\nSwiftData와 SwiftUI가 함께 작동하여 기본 데이터가 변경될 때 뷰에 실시간 업데이트를 제공하며 결과를 수동으로 새로 고침할 필요가 없습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n변경 사항 관찰\n\n@Published를 사용할 필요가 없습니다. SwiftUI는 관찰 대상 속성을 자동으로 새로 고칩니다.\n\n추가 정보: SwiftData(WWDC 2023)를 활용하여 앱을 개발해보세요.\n\n# 자동 지속성\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nSwiftData는 사용자 모델로 사용자 지정 스키마를 빌드하고 효율적으로 필드를 기반 저장소에 매핑합니다. SwiftData가 관리하는 객체는 필요할 때 데이터베이스에서 가져오고 추가 작업없이 적절한 시점에 자동으로 저장됩니다. 또한 ModelContext API를 사용하여 완전한 제어를 할 수도 있습니다.\n\n# CloudKit 동기화\n\n데이터는 DocumentGroup을 사용하여 파일로 저장하고 iCloud Drive를 통해 동기화하거나 CloudKit을 사용하여 장치간 데이터 동기화를 할 수 있습니다.\n\n# Core Data와 호환 가능\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nSwiftData는 Core Data의 검증된 저장 아키텍처를 사용하므로 동일한 기본 저장소를 사용하여 동일한 앱에서 둘 다 사용할 수 있습니다. 준비가 되면 Xcode가 Core Data 모델을 SwiftData와 함께 사용할 클래스로 변환할 수 있습니다.\n\n# 참고:\n","ogImage":{"url":"/assets/img/2024-05-27-BuildingSwiftUIApplicationswithSwiftData_0.png"},"coverImage":"/assets/img/2024-05-27-BuildingSwiftUIApplicationswithSwiftData_0.png","tag":["Tech"],"readingTime":6},{"title":"iOS에서 Compose Multiplatform을 사용하는 앱 이제 베타 - 2024년 개발자 인사이트","description":"","date":"2024-05-27 18:00","slug":"2024-05-27-AppsusingComposeMultiplatformoniOSnowbetain2024developerinsights","content":"\nCompose Multiplatform for iOS가 오늘 공식적으로 베타로 승격되었어요, 하지만 기업들이 이미 장기간 생산에 성공적으로 사용하고 있어요! 몇몇 애플리케이션을 살펴보죠. iOS에서 Compose Multiplatform (비공식적으로 CMP로 약칭)를 사용한 경험을 설명해 달라고 여러 개발자들에게 물었더니 다음과 같은 이야기를 들었어요.\n\n이것은 2023년에 Kotlin Multiplatform(KMP)을 사용하는 인기 애플리케이션들을 따르는 다음 단계이며, (포브스와 볼트와 같은) 더 많은 애플리케이션이 가입했지만, 이 게시물에서는 사용자 인터페이스를 공유하는 애플리케이션에 중점을 두었어요.\n\n안드로이드와 iOS 버전 모두의 공개 애플리케이션에 대한 링크가 포함되어 있어요, 그래서 직접 시도해 볼 수 있어요(그리고 혹시 머티리얼 리플을 발견할 수 있을지도 😉).\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 인스타박스 (내부 앱)\n\n스웨덴 물류 회사 인스타박스의 개발자들은 수천 명의 사용자가 사용하는 내부 iOS 앱을 SwiftUI로 개발하기 시작했습니다. 그러나 iOS에서 실행되는 Compose 데모를 보고 프로토타입을 만들어 CTO에게 보여줬고, CTO가 좋아해서 계속해서 작업을 진행했습니다. 이미 Kotlin Multiplatform을 사용하여 앱을 구조화했기 때문에 그들은 단 두 주만에 프로토타입을 만들었습니다.\n\n2023년 8월 Talking Kotlin 팟캐스트 에피소드에서 개발자들은 CMP와 함께 작업하는 선택과 프로세스에 대해 설명했습니다. 개발자들은 KMP와 함께 네이티브 API가 간단하게 사용될 수 있고, \"그냥 [공통으로] 파일을 옮길 수 있다\"는 점이 Kotlin Multiplatform의 장점이라고 특히 만족하고 있습니다.\n\n인스타비 개발자 요한네스 스벤손\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nKotlinConf 2024에서 \"Compose Multiplatform on mobile at Instabee for over a year\"이라는 주제로 발표가 있을 예정입니다. 녹화가 준비되면 이 기사를 업데이트하겠습니다.\n\n스스로 다시 써야 했던 가장 큰 것은 탐색이었습니다. 그 당시에는 아직 멀티플랫폼이 아니었지만, 주요 개발자인 Johannes는 현재 멀티플랫폼 Compose Navigation을 곧 채택할 것으로 말했습니다. 현재 앱은 일부 커스텀 코드(예: 백 제스처 처리)와 함께 Voyager를 사용하여 탐색 중입니다.\n\n# Markaz (1M+)\n\n![이미지](/assets/img/2024-05-27-AppsusingComposeMultiplatformoniOSnowbetain2024developerinsights_1.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 앱을 통해 사용자들은 온라인으로 제품을 구매하고 판매할 수 있어요. 비즈니스 로직부터 UI까지 Kotlin 코드를 공유해요. 이 앱은 파키스탄 시장을 대상으로 하고 있기 때문에 모든 국가에서 이용 가능하지 않을 수 있어요. 최근 업데이트에서는 iOS의 백 스와이프 제스처가 추가되었어요. 또한, Compose Multiplatorm에서 기본적으로 제공되는 iOS 룩 앤 필을 통해 네이티브 스크롤링과 같은 기능을 사용할 수 있어요.\n\n마르카즈(Markaz) 개발자 카시프(Me\\nhmood)\n\nApp Store: https://apps.apple.com/pk/app/markaz-resell-and-earn-money/id6470020517 Play Store: https://play.google.com/store/apps/details?id=com.markaz.app\n\n# Wrike (1M+)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-05-27-AppsusingComposeMultiplatformoniOSnowbetain2024developerinsights_2.png\" />\n\n오늘 KotlinConf에서 발표된 소식입니다: Wrike가 iOS에서 앱의 캘린더 부분에 Compose를 사용하고 있습니다. 리드 개발자는 키노트 비디오에서 다음과 같이 말했습니다 (게시물 맨 아래에 링크가 있습니다):\n\nWrike 기술 담당자 Alex Askerov\n\nApp Store: [여기를 클릭하여 App Store에서 확인하세요](https://apps.apple.com/ms/app/wrike-work-as-one/id890048871)\nPlay Store: [여기를 클릭하여 Play Store에서 확인하세요](https://play.google.com/store/apps/details?id=com.wrike)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## Campus (100K+)\n\n![Campus app](/assets/img/2024-05-27-AppsusingComposeMultiplatformoniOSnowbetain2024developerinsights_3.png)\n\n캠퍼스 - 수업 일정 (원래 이름: Кампус - Расписание занятий)은 대학생들을 위한 앱으로, 수업 일정을 추적하는 데 사용됩니다. 이 앱은 주로 네이티브이지만 \"과목\" 섹션(앱의 두 번째 탭)에서 Compose Multiplatform을 사용합니다. 개발자는 2023년 중반 CMP를 통합했는데, 이는 알파 상태에 도달한 직후입니다.\n\nIceRock (캠퍼스 개발자)의 CTO인 Aleksey Mikhailov\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n앱 스토어: [https://apps.apple.com/ru/app/кампус-расписание-занятий/id1534975833](https://apps.apple.com/ru/app/кампус-расписание-занятий/id1534975833)  \n플레이 스토어: [https://play.google.com/store/apps/details?id=ru.dewish.campus](https://play.google.com/store/apps/details?id=ru.dewish.campus)\n\n# Ashampoo Photo Organizer (예정)\n\n![이미지](/assets/img/2024-05-27-AppsusingComposeMultiplatformoniOSnowbetain2024developerinsights_4.png)\n\nAshampoo Photos의 iOS 첫 버전은 SwiftUI로 작성되었습니다. Compose Multiplatform이 사용 가능해지자 개발자는 개발 방향을 변경했습니다. 현재 작성 중인 이 포스트에서 새 버전은 Compose UI로 구축되어 테스트 중이며 아직 사용할 수 없습니다. 그러나 Compose Multiplatform이 모바일 플랫폼뿐만 아니라 Windows(그리고 곧 MacOS)에서도 실행되므로 소프트웨어를 [여기](https://www.ashampoo.com/photo-organizer)에서 사용할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아샴푸 개발자 Stefan Oltmann님\n\n앱스토어: 곧 공개 예정\n플레이 스토어: https://play.google.com/store/apps/details?id=com.ashampoo.photos\n\n# 오픈 소스: KotlinConf (5천 명 이상), Twine RSS Reader (1만 명 이상) 및 FindTravelNow\n\n이 목록의 마지막 세 개의 앱은 오픈 소스입니다! 정확히 어떻게 구축되었는지 궁금하다면 꼭 확인해보세요. 먼저 공식 KotlinConf 앱부터 차례로 살펴보겠습니다!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![image](/assets/img/2024-05-27-AppsusingComposeMultiplatformoniOSnowbetain2024developerinsights_5.png)\n\nKotlinConf  \nApp Store: [link](https://apps.apple.com/us/app/kotlinconf/id1299196584)  \nPlay Store: [link](https://play.google.com/store/apps/details?id=com.jetbrains.kotlinconf)  \nSource code: [link](https://github.com/JetBrains/kotlinconf-app)\n\nThen Twine, which is an RSS reader with 10K+ downloads:\n\n![image](/assets/img/2024-05-27-AppsusingComposeMultiplatformoniOSnowbetain2024developerinsights_6.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nTwine — RSS 리더\n앱 스토어: [링크](https://apps.apple.com/us/app/twine-rss-reader/id6465694958)\n플레이 스토어: [링크](https://play.google.com/store/apps/details?id=dev.sasikanth.rss.reader)\n소스 코드: [링크](https://github.com/msasikanth/twine)\n\n그리고 마지막으로, FindTravelNow은 전 세계에서 저렴한 항공권을 찾기 위한 \"메타서치 여행 애플리케이션\"입니다:\n\n![이미지](/assets/img/2024-05-27-AppsusingComposeMultiplatformoniOSnowbetain2024developerinsights_7.png)\n\nFindTravelNow\n앱 스토어: [링크](https://apps.apple.com/gr/app/findtravelnow/id6471192930)\n플레이 스토어: [링크]https://play.google.com/store/apps/details?id=com.travelapp.findtravelnow)\n소스 코드: [링크](https://github.com/mirzemehdi/FindTravelNow-KMM)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 마무리\n\n이 라운드업이 크로스 플랫폼 개발로 나아가고 싶어하는 분들에게 영감을 주기를 바랍니다. 일반적으로 Kotlin Multiplatform처럼, 만약 시도해보고 중단하려고 한다면 멀티플랫폼 부분을 더 나아가지 않기로 결정해도 항상 작동하는 현대적인 Android 앱을 가지고 계실 것입니다.\n\n시작하는 방법에 대한 더 많은 정보를 얻으려면 JetBrains 사이트를 확인해보세요: https://www.jetbrains.com/lp/compose-multiplatform/ 그리고 오늘의 KotlinConf 키노트에서 Compose iOS 베타 발표를 확인해보세요.\n\n이 기사의 핵심 개발자 및 커뮤니티에 유용한 정보를 제공해 준 분들에게 특별히 감사드립니다 🚀.\n","ogImage":{"url":"/assets/img/2024-05-27-AppsusingComposeMultiplatformoniOSnowbetain2024developerinsights_0.png"},"coverImage":"/assets/img/2024-05-27-AppsusingComposeMultiplatformoniOSnowbetain2024developerinsights_0.png","tag":["Tech"],"readingTime":8},{"title":"배터리 사가, 아이폰15 프로 맥스","description":"","date":"2024-05-27 17:58","slug":"2024-05-27-ThebatterysagatheiPhone15ProMax","content":"\n![2024-05-27-ThebatterysagatheiPhone15ProMax_0.png](/assets/img/2024-05-27-ThebatterysagatheiPhone15ProMax_0.png)\n\n# 또 다른 하루 또 다른 이야기\n\n나와 내 iPhone 15 Pro Max에게는 이상한 한 주가 지났어요.\n\n나에게는 이번 주에 두 번 모험했습니다! 나 자신을 은둔자로 묘사하려는 것이 아닌데, 본성상 나는 외로운 사람이라서 이 콘텐츠 창작 일은 나에게 완벽해요. 스스로 쓰고 편집하는 데 많은 시간을 보낼 수 있지만, 그로 인해 자리에 머무르는 습관을 낳아요. 올해 스튜디오에서 너무 멀리 나가지 않았다는 것을 깨달았기 때문에, 이번 주에는 그것을 바꾸고 살짝 변화를 주기로 결정했어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n일자별 계획은 콘텐츠 중심으로 구성되어 있었고, 주로 iPhone 15 Pro Max에 많이 의존했습니다. 정기적으로 저를 읽는다면 삼성 S24 울트라를 구매할 생각이 있었음을 아실 것입니다. 그 제품에 흥미를 느꼈지만, 무엇보다도 콘텐츠가 필요했기 때문에 그 제품을 더욱 탐내게 되었습니다!\n\n하지만 그때에 깨달았죠. 제게 가장 소중한 것, 즉 내가 가장 즐기는 것에 집중하라는 것을요 - 바로 내 iPhone 15 Pro Max에요.\n\n작년 안드로이드를 살펴보고 사용한 후, 그것이 나에게 충분하지 않다는 것을 알았어요. 나는 결코 아이폰 사용자이며, 이번에 사용 중인 아이폰은 내가 사용하고 소유한 제품 중 최고의 제품이라고 생각해요. 늘 이 제품을 적극 지지해 왔죠. 그래서 거의 6개월이 지난 이번 주에는 이 제품과 함께 몇 마일을 달려보기로 결정했어요.\n\n이번 주 초에는 윈저, 이튼, 배터시를 방문했고, 오늘은... 오늘은 저는 런던의 웨스트 엔드에서 막 돌아왔습니다. 수도시 거리를 돌아다니며 보낸 멋진 날이었고, 애플 대리점 두 곳 - 애플 리젠트 스트리트와 애플 나이츠브리지 두 곳도 방문한 날이었답니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![iPhone 15 Pro Max](/assets/img/2024-05-27-ThebatterysagatheiPhone15ProMax_1.png)\n\n# 아이폰 15 Pro Max - 프로일까요?\n\n오늘의 여행은 배터리 수명에 집중하기로 한 것이었습니다.\n\n이번 주 초에 우연히 배터리가 주인공이 되었습니다. 그 날은 그저 멋진 비디오와 사진 몇 장을 찍기 위해 나갔는데 — 제가 한 것 같다고 생각합니다. 그러나 집에서 8시간을 벗어나서 폰을 그 의도대로 사용한 결과, 결국 집에 왔을 때 배터리가 거의 다 닳아 있었습니다. 저는 20%만 남았죠.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nPro Max모델은 iPhone 중에서 가장 큰 배터리를 가지고 있어서 Pro라 불리며, 프로 작업을 수행할 수 있다는 의미입니다.\n\n지난 주에 운이 없었을 수도 있겠다 싶었는데, 오늘은 다시 확인해보기로 했습니다. 그때 그때일까요, 아니면 이것이 정상인가요? iPhone 15 Pro Max에서 기대해도 되는 성능인가요?\n\n![이미지](/assets/img/2024-05-27-ThebatterysagatheiPhone15ProMax_2.png)\n\n# 계속해서 이어짐\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저번 여행 이야기를 쓴 후 누군가가 전력 소비 데이터를 살펴보라고 제안해주었어요! 정말 좋은 조언이었어요 — 감사합니다!\n\n가장 많은 전력을 사용한 것은 카메라 (당연한 일이겠지만!)으로 25%였고, 사진은 20%를 차지했어요 (찍은 사진을 확인하고 보는 동안이겠죠) 그리고 이상하게도 홈 & 잠금 화면이 14%를 차지했어요. 아마 정말 어리석은 말을 하는 것 같지만... 잠금 화면이 전원을 그래서 소모하는 건 어떻게 된 일일까요 — 아마 항상 켜진 디스플레이 기능을 켜 둔 것 때문이겠죠...\n\n저는 오전 11시 이전에 99%의 배터리로 집을 떠났어요 — 오늘은 분명 더 나은 결과를 얻을 수 있을 거예요...\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 너무 가까워\n\n나는 항상 내가 살고 있는 곳과 런던이 얼마나 가까운지를 잊곤 해요.\n\n모터웨이를 한 시간 운전해서 가니, 가장 흥겹고 활기찬 도시 중 하나에 도착했어요.\n\n차에서 내려서 iPhone으로 사진을 찍기 시작했어요. Mac의 사진 앱을 보니 오늘은 200장 가까운 사진과 영상을 찍은 것 같아요. 어디를 바라보아도 또 다른 사진 촬영 기회가 있었어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![The Battery Saga - the iPhone 15 Pro Max](/assets/img/2024-05-27-ThebatterysagatheiPhone15ProMax_4.png)\n\n# 일에 착수하기\n\n주요 광각 24mm 렌즈의 모든 초점 거리를 시험해보기로 했다. 일주일 전에 이를 조사하기 시작했지만, 런던의 모든 명소를 둘러보면서 정말 카메라를 즐길 수 있을 것이라고 생각했다.\n\n아래에 유명한 피카딜리 서커스 광고판의 몇 장의 사진이 있다. 첫 번째 사진은 1배 확대 24mm로 촬영한 것이고, 두 번째 사진은 5배 확대 120mm로 촬영한 것이다. 이미지를 200%로 확대해도 매우 많은 선명함이 유지되며, 점이 놀랍게 날카로운 것을 알 수 있다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/assets/img/2024-05-27-ThebatterysagatheiPhone15ProMax_5.png)\n\n![이미지](/assets/img/2024-05-27-ThebatterysagatheiPhone15ProMax_6.png)\n\n집을 나온 지 4시간이 조금 넘었는데 배터리 상태가 54%로 괜찮았어요. 하지만 이번 주에 배우게 된 것으로 보아 이 부분이 중요한 전환점인 것 같아요. 약 50% 정도까지 괜찮아 보이다가 부터 뚝 떨어지기 시작합니다. 오늘 하루 배터리 상태를 맹수처럼 살펴봐야겠어요.\n\n![이미지](/assets/img/2024-05-27-ThebatterysagatheiPhone15ProMax_7.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이번 주까지는 5배 줌 기능을 많이 사용하지 않았어요. 일상생활에서는 별로 필요 없는데, 오늘 같은 날에는 정말 그 밋밋함에서 벗어나야 할 때입니다. 첫 번째 1배 24mm 샷으로 내가 얼마나 떨어져 있었는지 조금 감을 잡을 수 있어요. RAF 폭격기 기억비의 뾰족한 봉우리를 5배 줌으로 얼마나 잘 찾아냈는지 볼 수 있죠. 인상적네요.\n\n![이미지](/assets/img/2024-05-27-ThebatterysagatheiPhone15ProMax_8.png)\n\n![이미지](/assets/img/2024-05-27-ThebatterysagatheiPhone15ProMax_9.png)\n\n이번 주 런던에서 시험해보지 못한 것 중 하나는 120mm 렌즈의 디지털 줌 기능이었어요. 기억하세요, 저는 5배 줌 초심자라구요!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![2024-05-27-ThebatterysagatheiPhone15ProMax_10.png](/assets/img/2024-05-27-ThebatterysagatheiPhone15ProMax_10.png)\n\n![2024-05-27-ThebatterysagatheiPhone15ProMax_11.png](/assets/img/2024-05-27-ThebatterysagatheiPhone15ProMax_11.png)\n\n여기서 문제가 시작됩니다.\n\n사과 로고 주변에는 120mm에서도 조리개 ƒ2.8/80 ISO, 셔터 속도 1/100으로 심하게 고스트링이 나타납니다. 하지만 400mm까지 확대하면 (ƒ2.8/ 50 ISO) 사용할 수 없을 정도로 심해집니다 — 이때의 셔터 속도는 이제 1/148이었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n제가 다른 이야기에서 언급했지만, iPhone의 배경에서 행해지는 기기 내 계산 보정을 살펴볼 때 메타데이터에 흥미로워하곤 합니다. 사진을 촬영할 때마다 올바른 설정을 계산해 주는데, 이것에 대해 우리는 한 번도 생각해보지 않았습니다. 그 결과는 대체로 훌륭합니다. 메인 24mm 카메라의 세 개의 초점 거리는 특히 인상적합니다.\n\n오늘은 드디어 롱 노출 설정과 함께 놀아보는 것을 기억했어요. 이에 대해 많은 통제권이 없어 보이지만, 얻게 되는 것이 전부입니다. 하지만 이것으로 재미있는 시간을 가질 수 있을 것 같아요. 아, 그리고 루프 비디오로 변환할 수도 있어서 정말 멋진 효과를 줄 수 있어요...\n\n![이미지](/assets/img/2024-05-27-ThebatterysagatheiPhone15ProMax_12.png)\n\n# 최종 생각\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\niPhone 15 Pro Max를 정말 탐험하기 시작한 시간을 가졌어서 기뻐요. S24 Ultra를 사서 빠르고 싸게 클릭만 하는 것이 아니라 이미 가지고 있는 것에 더 투자해봤어요.\n\n활동적으로 즐거운 경험이었어요 — 밖으로 나가서 즐기는 것 뿐만 아니라 창작자로서의 자아를 발견하는 것도요. 이번 주까지는 대중 앞에서 녹화하는 걸 싫어했는데, 이제는 그것이 직업의 일부인 것 같다는 생각이 들어요.\n\n또한 iPhone에 대해 더 깊이 알아가는 것 또한 즐거웠어요. 6개월 동안 주머니 안에 넣어두었는데, 이제야 시작해서 무엇이 가능한지 알아가기 시작한 것 같아요. 어떻게 이런 것들에 대해 몰랐을까요?\n\n하지만...그 모든 좋은 점들에도 아직은 오래 지속되는 걱정이 있어요. 지난 주에 두 번이나 Pro Max를 이용해 보았는데, 두 번 모두 거의 하루를 버텨내지 못했네요. 그 50% 문제가 실재하는 것 같아요. 약 2시간 만에 54%에서 17%로 떨어지는 것을 볼 수 있어요. 그리고 그 동안 중 일부 시간 동안 iPhone은 차 안에 있어서 음악을 스트리밍 할 뿐이었어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그래도 배터리 문제는 한쪽에 두고 — 이제 내 15 Pro Max에서 정말 많은 것을 얻고 있는 느낌을 받고 있고, 정말 즐기고 있어요.\n\n200개가 넘는 생산성 앱을 한 곳에서 쉽게 확인해 보고 싶다면 SetApp을 확인해보세요. 정말 멋지답니다 — 매월 한 번의 요금으로 Bartender, CleanShot X, Paste, iStat Menus, BetterTouchTool과 같이 멋진 앱을 고를 수 있어요. 한 번 시도해보고 30일 무료 사용해 보고 싶다면 제 제휴 링크를 클릭해서 살펴보세요. 어떤 앱이 제일 마음에 드는지 알려주세요.\n\n2024년 2월 18일에 https://talkingtechandaudio.com에서 최초 게시된 글입니다.\n","ogImage":{"url":"/assets/img/2024-05-27-ThebatterysagatheiPhone15ProMax_0.png"},"coverImage":"/assets/img/2024-05-27-ThebatterysagatheiPhone15ProMax_0.png","tag":["Tech"],"readingTime":9},{"title":"일곱 가지 데모로 이해하는 코루틴 스코프, 컨텍스트 및 작업","description":"","date":"2024-05-27 17:54","slug":"2024-05-27-SevendemostounderstandcoroutinesscopecontextandJobs","content":"\n코루틴을 이해하는 것은 패턴을 배우는 것이 아니라 구동 원리를 보는 것에서 나옵니다.\n\n저번 포스트에서 안드로이드의 일반적인 코루틴 패턴을 해체하여 그 원리를 살펴보았습니다. 우리가 파고들수록, 모든 것을 가로지르는 세 가지 개념인 context, scopes, 그리고 Job이 있는 것을 보게 되었습니다.\n\n그래서, 코루틴이 무엇이며, 올바르게 활용하는 데 중요한 열쇠라고 생각됩니다.\n\n이를 염두에 두고, 그 세 가지를 살펴볼까요? 함께 재미있게 알아봅시다. 😉\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n(\\* 약간의 유머가 있었어요)\n\n# 데모 1: 코루틴을 실행하고 잊어버리기\n\n코루틴 스코프는 코루틴을 넣는 상자입니다. 그들을 제한하는 목적으로 존재합니다.\n\n코루틴을 취소하고 싶을 때 유용함을 알 수 있습니다 — 그냥 상자를 파괴하면, 상자 안의 모든 코루틴이 취소됩니다. 이것은 훌륭한 기능입니다. 왜냐하면 코루틴을 계속 추적할 필요가 없다는 것을 의미합니다. 그들의 생명주기는 \"상자\"에 의해 관리됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n구체적인 예를 들어보겠습니다. 아래는 클릭할 때 배경색이 변경되는 버튼입니다:\n\n![button](https://miro.medium.com/v2/resize:fit:1200/1*Xb48gAvABkH5LBhRstBB_g.gif)\n\n이전 글에서 while(true)이 안전한 이유에 대해 설명했습니다. 다른 상황에서는 끔찍한 상황이겠지만요. 하지만 더 흥미로운 부분이 있는데요!\n\n...바로 이겁니다: 9번 라인에서 코루틴을 간단히 실행시켰는데, 그냥 넘어갔습니다. 왜냐하면 해당 스코프에 안전하게 실행시켰기 때문입니다. 이 경우 rememberCoroutineScope()를 사용해 스코프를 얻었습니다. RandomColourButton이 화면에서 제거되면 해당 스코프가 취소되며 실행된 코루틴도 취소됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n환경에서 스레드만 있는 개발자에게 온다면, 코루틴이 얼마나 큰 진전인지 과장할 수 없을 정도로 중요합니다. 스레드를 시작하고 그냥 두는 것은 상상도 못할 정도로 중요하지요. 모두를 꼼꼼하게 추적해야 하며, 이를 제대로 처리하지 않으면 이상한 버그와 자원 누수가 발생할 수 있습니다.\n\n# 데모 2: launch()된 코루틴 취소하기\n\n위 코드에서처럼 scope.launch '...'로 코루틴을 시작할 때, 실행 중인 코루틴을 나타내는 Job이 생성됩니다.\n\nJob.cancel()을 사용하여 해당 코루틴을 취소할 수 있습니다 (부모 스코프나 그 안의 다른 코루틴에는 영향을 주지 않음).\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 코드로 인해 번쩍이는 버튼이 2초 후에 번쩍임이 멈춥니다. 첫 번째 coroutine의 Job을 저장하고, 지연 후에 이를 취소하기 위해 두 번째 coroutine을 시작합니다.\n\n# 데모 3: coroutine 내에서 coroutine 시작하기\n\nJob은 하위 Job을 가질 수도 있습니다. 하위 Job을 만드는 간단한 방법은 단순히 coroutine 내에서 'launch'를 사용하는 것입니다.\n\nJob이 취소되면 모든 하위 Job들도 함께 취소됩니다. 번쩍이는 버튼을 사용하여 해당 예제를 살펴보겠습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이번에는 카운트를 증가시키는 또 다른 코루틴을 추가했습니다:\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1200/1*ESBEwgreP7EpxnqXm4cF9A.gif\" />\n\n랜덤 색상을 선택하는 코루틴의 자식으로 증가하는 카운트를 세는 코루틴이 시작됩니다:\n\n번쩍임이 멈추면 카운트도 멈추는 것을 주목해보세요. 이는 12번 줄에서 시작된 코루틴이 10번 줄에서 시작된 코루틴의 자식이기 때문입니다. 부모가 지연 후에 취소되면 자식도 함께 취소됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n코루틴의 세계에서, 이 부모-자식 관계를 규제하는 법칙들(코루틴을 잃어버리지 않도록 보장하는 동일한 법칙들)은 구조화된 동시성이라고 합니다.\n\n# 데모 4: 컨텍스트에서 코루틴을 실행하고 작업을 지정하는 방법\n\nJob에 코루틴을 실행할 다른 방법도 있습니다. launch 또는 async 호출에서 Job을 지정할 수 있습니다:\n\n```js\nlaunch(myJob) {\n  ...\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n당연히 이 작업은 당신에게 달려 있습니다. 필요할 때 myJob을 주의 깊게 추적하여 이 코루틴의 생명 주기를 올바르게 제한해야 합니다.\n\n이것이 동작하는 이유는 launch에 전달하는 인수가 CoroutineContext이며, 그 중에 job이 있는 요소이기 때문입니다.\n\n코루틴 컨텍스트는 코루틴에 대한 메타데이터의 집합에 불과합니다. 이는 해당 코루틴에 대한 Job, 이름 및 디스패처를 포함합니다. 이는 코루틴이 어떻게 실행될지 코루틴 라이브러리에 설명하는 코루틴에 부착된 수하물 태그로 생각할 수 있습니다.\n\n# 데모 5: 다른 스레드 풀로 코루틴 시작하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\"‘luggage tags’ 중 하나인 이 메타데이터는 코루틴에 첨부됩니다. 디스패처는 코루틴이 실행될 스레드나 스레드 풀을 결정하기 위해 사용됩니다.\n\n따라서 위와 같은 방법을 사용하여 IO 디스패처의 스레드 풀에서 코루틴을 시작할 수 있습니다:\n\n```js\nlaunch(Dispatchers.IO) {\n  ...\n}\n```\n\n이는 디스패처를 Dispatchers.IO로 설정하는 코루틴 콘텍스트를 생성함으로써 작동합니다.\"\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 데모 6: 기타 코루틴 시작 옵션 (및 조합)\n\n또는, 코루틴 컨텍스트의 요소를 더하여 plus 연산자를 사용할 수 있습니다. 다음은 \"boo\"라는 코루틴을 IO 디스패처 스레드 풀에 새 작업으로 시작하는 방법입니다:\n\n```js\nlaunch(Dispatchers.IO + Job() + CoroutineName(\"boo\")) {\n  ...\n}\n```\n\n이 방법으로 코루틴 컨텍스트를 생성할 때 언급하지 않은 요소는 부모의 컨텍스트에서 상속됩니다. 즉, Dispatchers.IO에서 실행 중인 코루틴에서 Job()을 시작하면 시작된 하위 코루틴도 Dispatchers.IO에서 실행됩니다. 이는 하위 코루틴의 컨텍스트 디스패처가 부모로부터 상속되었기 때문입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 데모 7: 코루틴 스코프 사용하기 — 그리고 그로 인해 발생하는 일들\n\n지금까지 확인한 내용은 다음과 같습니다:\n\n- 데모 1: 코루틴 스코프는 코루틴을 넣을 수 있는 수명 제한 컨테이너입니다.\n- 데모 3: 코루틴 Job은 코루틴을 넣을 수 있는 수명 제한 컨테이너입니다.\n\n음. 그럼 차이는 무엇인가요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n사실, 차이가 없다는 것을 발견했습니다. 왜냐하면:\n\n...코루틴 라이브러리 코드에서 볼 수 있듯이:\n\n```js\npublic interface CoroutineScope {\n    public val coroutineContext: CoroutineContext\n}\n```\n\n그럼에도 불구하고, 본질적으로 같은 것에 대해 별도의 타입과 전체적으로 다른 이름을 가지고 있는 이유는 무엇일까요? 코틀린 언어의 전 프로젝트 리드인 로만 엘리자로프는 선박이 \"로프\"에 대해 여러 다른 이름을 가지고 있는 것과 유사성을 들어줍니다. 왜냐하면 그들은 사용에 따라 명명되기 때문입니다. 해저고리는 주요 돛을 올리기 위한 로프이고, 다운할은 그것을 내리기 위한 로프이며, 샤트는 돛을 다루기 위한 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n비유적으로 말하면, 코루틴 범위는 특정 유형의 코루틴 컨텍스트로 기명됩니다. 이는 코루틴의 수명을 제한하고 제어하는 데 사용됩니다.\n\n실제로는 코루틴 범위는 특정 라이프사이클에 연결된 작업(Job)을 갖게 됩니다:\n\n- viewModelScope는 뷰 모델이 지워질 때 작업이 취소됩니다.\n- rememberCoroutineScope()는 컴포지션을 떠나는 시점에 작업이 취소됩니다.\n- viewLifecycleOwner.lifecycleScope은 Android View의 라이프사이클이 종료될 때 작업이 취소됩니다.\n\n그리고 이어서 이어지죠.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그래서 우리는 모두 데모 1로 돌아가서, 코루틴을 scope 내에 배치하면 안전하게 실행 및 무시할 수 있다는 것을 알 수 있었습니다. 이는 scope가 관련된 라이프사이클에 바운드된 Job을 가지고 있기 때문입니다.\n\n# 요약하자면...\n\n코루틴 컨텍스트, 스코프 및 Job의 개념은 코루틴을 사용하는 데 중요한 부분을 차지합니다. 우리는 컨텍스트가 코루틴과 관련된 메타데이터 목록과 같으며, 옵저버들에 정보를 제공하고 디스패처에게 실행 방법을 알려주는 것과 같다는 것을 보았습니다. 우리는 Job이 실행 중인 코루틴을 나타내며, 다른 코루틴에 대해 부모 역할을 할 수 있다는 것을 알았습니다. 그리고 이를 통해 코루틴 스코프를 이해할 수 있습니다. 즉, 부모 Job이 있는 컨텍스트입니다.\n\n도움이 되었으면 좋겠습니다. 계속해서 궁금한 점을 아래에 질문해 주세요!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nTom Colvin은 20년 동안 소프트웨어 아키텍처를 담당해오고 있으며, 특히 안드로이드 작업을 좋아합니다. 그는 모바일 앱 전문가인 Apptaura의 공동 창업자이며, 컨설팅 기반으로 활동하고 있습니다.\n","ogImage":{"url":"/assets/img/2024-05-27-SevendemostounderstandcoroutinesscopecontextandJobs_0.png"},"coverImage":"/assets/img/2024-05-27-SevendemostounderstandcoroutinesscopecontextandJobs_0.png","tag":["Tech"],"readingTime":9},{"title":"특정 지역 자원 및 잘못된 로컬라이제이션 - 안드로이드","description":"","date":"2024-05-27 17:53","slug":"2024-05-27-RegionspecificresourcesandbrokenlocalizationAndroid","content":"\n![이미지](/assets/img/2024-05-27-RegionspecificresourcesandbrokenlocalizationAndroid_0.png)\n\n이 기사의 일환으로, 우리 애플리케이션에서 로컬라이제이션 지원을 망가뜨린 리소스 구성에 대한 최근 경험을 설명하겠습니다.\n\n프랑스어 번역에서 망가진 부분의 샘플은 다음과 같습니다.\n\n우리의 클라이언트 애플리케이션은 라이브러리를 사용하여 이 UI에 노출됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음은 라이브러리 개발자들이 문자열 리소스를 넣은 파일들입니다 👇\n\n- strings.xml\n- 🇨🇦 strings.xml (fr-rCA)\n\n![이미지](/assets/img/2024-05-27-RegionspecificresourcesandbrokenlocalizationAndroid_1.png)\n\n👆에서 보듯이, 프랑스어 문자열을 캐나다 지역을 대상으로 하는 파일에 넣었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리 애플리케이션에는 지역별이 아닌 프랑스어 문자열이 공통 파일에 저장되어 있어요👇\n\n![이미지](/assets/img/2024-05-27-RegionspecificresourcesandbrokenlocalizationAndroid_2.png)\n\n앱 수준 build.gradle에 다음 구성을 추가하기 전에 예상대로 작동했습니다\n\nKotlin\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n안드로이드 {\n    defaultConfig {\n        ...\n        resourceConfigurations.addAll(listOf(\"en\", \"fr\"))\n    }\n}\n```\n\n그루비\n\n```js\n안드로이드 {\n    defaultConfig {\n        ...\n        resConfigs \"en\", \"fr\"\n         // 또는\n        resourceConfigurations += [\"en\", \"fr\"]\n    }\n}\n```\n\n# 이 설정은 무엇을 하는 건가요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## Android 개발자 문서에서의 정의\n\n사용되지 않는 대체 리소스 제거 👇\n\n이 방법의 주요 이점은 애플리케이션에 필요하지 않은 모든 리소스를 제거할 수 있다는 것입니다.\n\n이 시점에서 우리 케이스에서 프랑스어 지원이 깨졌다는 이유를 이해하셨으면 좋겠습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저희 애플리케이션에는 두 가지 리소스만 필요하다는 구성이 추가되었습니다.👇\n\n```js\nresConfigs \"en\", \"fr\"\n         // 또는\nresourceConfigurations += [\"en\", \"fr\"]\n```\n\n이에 따라 Resource Shrinker는 fr-rCA 🇨🇦 리소스를 제거하고 애플리케이션에서는 [“en”, “fr”] 리소스만 사용할 수 있게 되었습니다.\n\n# 문제를 해결해보는 시간입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 빠르게 이 문제를 해결하기 위해 몇 가지 옵션이 있습니다:\n\n1st\n\n- build.gradle을 업데이트하여 fr-rCA 🇨🇦 리소스를 제거하지 않도록합니다.\n\n```js\nandroid {\n    defaultConfig {\n        ...\n        resConfigs \"en\", \"fr\", \"fr-rCA\"\n        // 또는\n        resourceConfigurations += [\"en\", \"fr\", \"fr-rCA\"]\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 2nd\n\n- 대안으로, 도서관을 제어하고 지역별 자원을 사용하고 싶지 않은 경우, 모든 지역에서 액세스할 수 있는 파일로 이동할 수 있습니다.\n\n# 함께 연결해요\n\nhttps://www.linkedin.com/in/navczydev/\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 참고문헌\n","ogImage":{"url":"/assets/img/2024-05-27-RegionspecificresourcesandbrokenlocalizationAndroid_0.png"},"coverImage":"/assets/img/2024-05-27-RegionspecificresourcesandbrokenlocalizationAndroid_0.png","tag":["Tech"],"readingTime":4},{"title":"적응형 컴포즈 레이아웃","description":"","date":"2024-05-27 17:51","slug":"2024-05-27-AdaptiveComposeLayouts","content":"\n## 모든 창 크기에 대한 흥미로운 소식\n\n![이미지](/assets/img/2024-05-27-AdaptiveComposeLayouts_0.png)\n\n올해 구글 I/O는 흥미로운 발표들로 가득 찼는데, AI 분야뿐만 아니라 (물론 그것도 하이라이트였지만) 적응형 레이아웃을 구축하기 위한 Jetpack Compose의 발전에 중점을 둔 것이 나에게는 핵심적인 교훈이었습니다. 안드로이드는 스마트폰뿐만 아니라 태블릿, 폴더블폰, 대형 화면 등으로 확장되고 있어서 다양한 형태 요소에 적응하는 앱을 개발하는 것이 더 중요해지고 있습니다.\n\n이전에 내가 이전 게시물에서 창 크기 클래스를 사용하여 반응형 레이아웃을 탐구했습니다. 그러나 Jetpack Compose의 흥미로운 새로운 발전으로 인해 해당 주제를 다시 살펴보게 되었습니다. WindowSizeClass의 새로운 구현뿐만 아니라 사용법을 간단하게 하는 새로운 Composable 함수들도 새롭게 나왔습니다. 또한 일반적인 레이아웃 동작을 단순화하는 새로운 Composable 함수들도 나왔는데, 사용자 정의 함수가 필요 없어졌습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n많은 내용을 다뤄야 하니까, 첫 번째 주요 측면으로 넘어가 볼까요? WindowSizeClass의 새로운 구현을 살펴봅시다. 이해를 돕기 위해, 제 이전 글에서의 구현을 이전해 보겠습니다. 원하신다면 확인해보세요.\n\n## WindowSizeClass의 이전\n\nGradle 파일을 업데이트하는 것부터 시작해봅시다. 이전 종속성을 제거하고 새롭게 개선된 구현을 위한 새로운 것을 추가할 겁니다.\n\n```js\n[versions]\nadaptive = \"1.0.0-beta01\"\n...\n[libraries]\n\n-- androidx-material3-windowSizeClass = { group = \"androidx.compose.material3\", name = \"material3-window-size-class\" }\nandroidx-adaptive = { module = \"androidx.compose.material3.adaptive:adaptive\", version.ref = \"adaptive\" }\n...\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nGradle 종속성을 업데이트한 후 이제 이전 WindowSizeClass 구현에 의존했던 코드 섹션을 이주해 보겠습니다. 예를 들어, 창 크기에 따라 동적으로 열의 수를 결정하는 코드가 있다면 다음과 같이 업데이트할 수 있습니다:\n\n```js\nval windowWidthSize = currentWindowAdaptiveInfo().windowSizeClass.windowWidthSizeClass\n\nval columns = when (windowWidthSize) {\n       WindowWidthSizeClass.COMPACT -> 1\n       WindowWidthSizeClass.MEDIUM -> 2\n       else -> 3\n}\n```\n\n업데이트가 함수 변경을 넘어 이동했다는 것을 알 수 있습니다! 주요 개선 사항 중 하나는 composable 함수 내에서 windowSizeClass를 직접 가져올 수 있는 능력입니다. 이제 activity를 통해 액세스할 필요 없이 이를 가져올 수 있습니다. 즉, 앱 전반에 걸쳐 창 크기 클래스를 매개변수로 전달할 필요가 없어졌습니다! 이것은 더 깨끗한 코드를 위한 중요한 발전입니다.\n\n## NavigationSuiteScaffold\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n윈도우 크기 클래스 이주를 다루었으니, 이제는 새로운 구성 가능 함수를 살펴봅시다. 먼저, NavigationSuiteScaffold가 등장합니다. 이 중요한 구성 가능 함수는 창 크기에 따라 하단 탐색 표시줄, 탐색 레일 및 서랍 사이를 전환할 때 사용자 정의 논리가 필요 없도록 해줍니다.\n\n이전 글에서는 탐색 요소 전환을 위한 사용자 정의 솔루션 구축을 탐구했습니다. 이제 NavigationSuiteScaffold가 이 프로세스를 간단하게 하는 방법을 살펴보겠습니다. 이 새로운 함수를 사용하여 동일한 결과를 얻는 방법은 다음과 같습니다:\n\n```js\n...\nNavigationSuiteScaffold(\n        modifier = Modifier,\n        navigationSuiteItems = {\n\n            bottomNavigationItems.forEach { bottomBarElement ->\n\n                val selected =\n                    currentScreen.instanceOf(bottomBarElement.screen::class)\n\n                item(\n                    icon = bottomBarElement.icon,\n                    selected = selected,\n                    alwaysShowLabel = true,\n                    label = {\n                        Text(\n                            text = stringResource(id = bottomBarElement.title),\n                            style = MaterialTheme.typography.labelMedium.copy(\n                                textAlign = TextAlign.Center,\n                                fontWeight = FontWeight.Normal\n                            ),\n                            maxLines = 1\n                        )\n                    },\n                    onClick = {\n                        if (!selected) {\n                                NavigationEvent.OnNavigateBottomBar(\n                                    bottomBarElement.screen\n                                )\n                        }\n                    }\n                )\n            }\n        }\n\n    ) {\n        Scaffold() { innerPadding ->\n            MainNavHost(\n                modifier = Modifier.padding(innerPadding),\n            )\n        }\n    }\n```\n\n이 단일 구현은 현재 창 크기에 따라 적절한 탐색 경험을 제공하도록 자동으로 동작합니다. 이는 작은 화면의 경우 하단 표시줄과 큰 화면의 경우 탐색 레일과 같은 요소 간에 전환하는 적절한 탐색 경험을 제공합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그러나 더 맞춤화된 접근을 선호하는 분들을 위해 NavigationSuiteScaffold는 NavigationSuiteType을 통해 유연성을 제공합니다. 여러분은 해당 스캐폴드 내에서 사용자 정의 동작을 매끄럽게 통합하여 스마트폰의 가로 모드에서도 네비게이션 레일과 같은 요소를 사용할 수 있습니다.\n\n```js\n...\nval adaptiveInfo = currentWindowAdaptiveInfo()\nval customNavSuiteType = with(adaptiveInfo) {\n            if (windowSizeClass.windowWidthSizeClass == WindowWidthSizeClass.EXPANDED) {\n                NavigationSuiteType.NavigationRail\n            } else {\n                NavigationSuiteScaffoldDefaults.calculateFromAdaptiveInfo(adaptiveInfo)\n            }\n}\n\nNavigationSuiteScaffold(\n        modifier = Modifier,\n        layoutType = customNavSuiteType,\n        navigationSuiteItems = {\n...\n```\n\n동일한 원칙이 특정 시나리오에서 네비게이션을 완전히 숨기고 싶은 경우에도 적용됩니다.\n\n```js\n...\nval adaptiveInfo = currentWindowAdaptiveInfo()\n    val customNavSuiteType = with(adaptiveInfo) {\n         when {\n            !shouldShowBottomBar -> {\n                NavigationSuiteType.None\n            }\n            windowSizeClass.windowWidthSizeClass == WindowWidthSizeClass.EXPANDED -> {\n                NavigationSuiteType.NavigationRail\n            }\n            else -> {\n                NavigationSuiteScaffoldDefaults.calculateFromAdaptiveInfo(adaptiveInfo)\n            }\n        }\n    }\n...\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## ListDetailPaneScaffold\n\n안녕하세요, 또 다른 강력한 Composable인 ListDetailPaneScaffold를 살펴보겠습니다. 이 함수는 화면 크기가 큰 경우 두 개의 화면(또는 패널로 표시)을 옆에 나란히 표시하고 싶을 때 이상적입니다. 주요 장점 중 하나는 단일 패널을 표시하거나 이중 패널 레이아웃을 활용하든 내부 내비게이션을 자동으로 처리한다는 점입니다. 이것은 개발을 간소화할 뿐만 아니라 창 크기에 관계없이 부드러운 사용자 경험을 보장합니다.\n\n```js\n[versions]\nmaterial3AdaptiveNavigationSuiteAndroid = \"1.3.0-beta01\"\n...\n[libraries]\n\nandroidx-material3-adaptive-navigation-suite-android = { group = \"androidx.compose.material3\", name = \"material3-adaptive-navigation-suite-android\", version.ref = \"material3AdaptiveNavigationSuiteAndroid\" }\n...\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nGradle 종속성을 사용하여 코드를 업데이트할 수 있습니다.\n\n```js\n val navigator = rememberListDetailPaneScaffoldNavigator<String>()\n\n    BackHandler(navigator.canNavigateBack()) {\n        navigator.navigateBack()\n    }\n\n    ListDetailPaneScaffold(\n        directive = navigator.scaffoldDirective,\n        value = navigator.scaffoldValue,\n        listPane = {\n            AnimatedPane {\n                HomeScreen(\n                    onClickOnItem = {\n                        navigator.navigateTo(\n                            ListDetailPaneScaffoldRole.Detail,\n                            it\n                        )\n                    }\n                )\n            }\n        },\n        detailPane = {\n            AnimatedPane {\n                navigator.currentDestination?.content?.let {\n                    ZoomBookInitScreen(book = it.id)\n                }\n            }\n        },\n    )\n```\n\n이름에서 알 수 있듯이 navigator는 패널 내에서의 네비게이션을 관리하는 역할을 합니다. 이는 상세 패널로 이동하거나, 단일 패널 모드에서 백 네비게이션을 처리하는 것을 포함합니다. 또한 상세 패널로 전달된 데이터 객체를 포함합니다. 특히, Parcelable인 경우 사용자 정의 객체도 공유할 수 있습니다.\n\nWindowSizeClass와 함께 ListDetailPaneScaffold를 사용하여 현재 창 크기에 기반한 동작을 맞춤화할 수 있습니다. 예를 들어 (스크린샷에서 볼 수 있듯이) 단일 패널 모드에서만 뒤로 화살표와 같은 요소를 조건부로 표시할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\nval windowWidthSize = currentWindowAdaptiveInfo().windowSizeClass.windowWidthSizeClass\nval backVisible = when (windowWidthSize) {\n    WindowWidthSizeClass.EXPANDED -> false\n    else -> true\n}\n```\n\n이 수준의 제어는 모든 다양한 디바이스 크기에서 정교한 사용자 경험을 보장합니다.\n\n## SupportingPaneScaffold\n\n새로운 적응형 레이아웃 기능을 탐색하기 위해 SupportingPaneScaffold를 간단히 살펴보겠습니다. 이 구성 요소는 핵심 기능인 탐색 관리와 창 내용 표시를 ListDetailPaneScaffold와 유사한 점을 가지고 있습니다. 하지만 SupportingPaneScaffold는 주요 콘텐츠 창과 오른쪽에 있는 더 작은 \"보조\" 창을 함께 사용하는 경우에 맞게 설계되었습니다. 이는 보조 콘텐츠가 주요 콘텐츠를 보완하거나 부가 정보를 제공하지만 동일한 화면 공간이 필요하지 않은 상황에 이상적입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n프로젝트에서 SupportingPaneScaffold을 구현하려면 ListDetailPaneScaffold에서 얻은 지식을 기반으로 활용할 수 있습니다. 더 깊은 이해를 위해 젯팩 코믹스의 공식 문서를 여기에 남겨 두겠습니다.\n\n# 결론\n\n본 문서를 통해 Google I/O 2024에서 젯팩 코믹스를 사용한 적응형 레이아웃 구축의 흥미로운 발전을 확인하였습니다. 새로운 WindowSizeClass 구현은 액세스 및 사용을 간단하게 만들어주며, NavigationSuiteScaffold, ListDetailPaneScaffold 및 SupportingPaneScaffold와 같은 강력한 조합 가능 함수들은 다양한 화면 크기와 형태 요인을 통해 탐색 및 콘텐츠 표현을 간소화하는 접근 방식을 제공합니다.\n\n이러한 새로운 기능은 Android 애플리케이션을 위한 정말로 반응적이고 사용자 친화적인 경험을 만들 수 있게 해줍니다. 적응형 레이아웃을 위한 최상의 실천 방법을 준수하고 이러한 도구들을 수용함으로써, 앱이 지속적으로 진화하는 Android 생태계에 매끄럽게 적응하여 모든 기기의 사용자에게 탁월한 경험을 제공할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n의견을 자유롭게 공유해주시거나, 원하신다면 LinkedIn에서 연락 주셔도 좋습니다.\n\n좋은 하루되세요!\n","ogImage":{"url":"/assets/img/2024-05-27-AdaptiveComposeLayouts_0.png"},"coverImage":"/assets/img/2024-05-27-AdaptiveComposeLayouts_0.png","tag":["Tech"],"readingTime":11},{"title":"앱 테마 변경하기  접근성 맞춤 설정하기","description":"","date":"2024-05-27 17:50","slug":"2024-05-27-ChangeAppThemePersonalizingAccessibility","content":"\n<img src=\"/assets/img/2024-05-27-ChangeAppThemePersonalizingAccessibility_0.png\" />\n\n이전 두 개의 게시물로 시작한 개인화 접근성 주제를 이어가고 있어요. 아래 링크에서 확인할 수 있어요:\n\n- 설정으로 개인화 접근성\n- 아이콘과 레이블 전환 - 개인화 접근성\n\n이전 게시물에서 설명한 것처럼, 일반적으로 개인화는 접근성을 개선하는 열쇠가 될 수 있다는 것과 아이콘과 레이블을 숨기거나 표시하는 설정을 추가하는 구체적인 예시를 제시했어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 블로그 포스트에서는 구체적인 예시를 계속 다루겠습니다. 앱의 테마를 변경할 수 있는 설정을 추가할 것입니다. 사용자는 시스템 설정을 따르는 것(기본값), 밝은 테마, 어두운 테마, 고대비 색상 테마 중에서 선택할 수 있습니다. 함께 알아보겠습니다.\n\n# 왜?\n\n가끔 사용자들은 핸드폰의 테마와 다른 테마로 앱을 사용하고 싶어합니다. 저는 개인적으로 모든 것을 어두운 모드로 사용하지만, 제게는 사용하기 어려운 색상이 들어간 어두운 테마를 가진 몇몇 앱을 만난 적이 있습니다. 너무 많은 대비가 있는 경우도 있고, 때로는 너무 적은 경우도 있습니다. 그런 경우에는 밝은 테마로 변경하고 싶었습니다. 일반적으로 그런 옵션이 없어서 그 앱을 포기했거나, 필요할 때 최소한 사용했습니다.\n\n그래서 사용자에게 제어력을 주는 것이 중요합니다. 이런 종류의 설정을 위한 최소 옵션은 시스템 기본값, 밝은 테마, 어두운 테마입니다. 하지만 고대비 테마는 어떨까요? 왜 추가해야 하며 누가 필요로 할까요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 고대비 테마\n\n고대비 테마는 더 높은 대비를 가진 색상으로 이루어진 색상 팔레트를 가지고 있습니다. 구체적인 예로는 Windows 7 이후에 개발된 Windows 고대비 모드가 있습니다. 안드로이드는 고대비 텍스트를 설정할 수 있는 기능을 제공하지만, 그것은 텍스트에만 적용됩니다.\n\nWebAIM은 2018년에 저시력 사용자들을 대상으로 설문조사를 실시해, 응답자 중 51.4% (n=248)가 고대비 모드를 사용했다고 나타냈습니다. 저시력 사용자는 고대비 테마를 필요로 하는 큰 그룹 중 하나지만, 다른 사람들도 필요할 수 있습니다. 예를 들어, 편두통을 앓는 사람이나 아일린 증후군을 가진 사람, 또는 일부 언어 장애를 가진 사람들도 고대비 테마를 통해 혜택을 받을 수 있습니다. 또한 고대비 모드는 눈에 좋은 햇빛 속에서 모두에게 유용할 수 있습니다.\n\n# 어떻게?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n앱 테마를 변경할 수 있는 기능을 추가하는 흐름은 이전 블로그 게시물의 레이블 및 아이콘과 유사합니다. 설정 화면에 설정을 추가하고 설정 값을 데이터 저장소에 저장한 다음 앱에서 해당 값을 사용하여 어떤 테마를 표시할지 결정합니다.\n\n먼저 설정 화면부터 시작해보겠습니다. 테마를 선택할 수 있는 섹션과 선택할 수 있는 옵션을 추가하고 싶습니다. 리스트에는 시스템 기본, 다크 테마, 라이트 테마 및 고대비 테마 네 가지 옵션이 포함되어 있습니다. 예시에서 색상이 표시됩니다:\n\n![테마 선택 화면](/assets/img/2024-05-27-ChangeAppThemePersonalizingAccessibility_1.png)\n\n## 데이터 저장하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n먼저, 이전 블로그 게시물에서 설정 저장에 사용한 설정 데이터 저장소에 키-값 쌍을 추가하려고 합니다. 이전 블로그 게시물에서 언급했듯이, 블로그 게시물을 단순하게 유지하기 위해 데이터 저장소는 SettingsRepository에서 정의되고 상호 작용됩니다.\n\n네 가지 옵션이 있기 때문에 이 경우에는 간단한 부울 값이 작동하지 않습니다. 코드에서는 테마에 대해 미리 정의된 값들을 사용하고자 하므로, 테마에 대한 옵션을 모두 포함하는 enum 클래스를 만들고 시스템 기본값으로 null을 사용합니다.\n\n```js\n// ThemeExt.kt\n\nenum class Theme {\n    Dark,\n    Light,\n    HighContrast;\n}\n```\n\n데이터 저장소는 enum 값들을 저장할 수 없으므로, enum을 문자열로 변환하고 다시 변환할 방법이 필요합니다. 문자열로 변환하는 부분은 쉽습니다 - toString() 함수를 사용할 수 있습니다. 다른 변환에 대해서는 도우미 함수를 정의해야 합니다. enum 클래스에 추가해보겠습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\nenum class Theme {\n    ...\n\n    companion object {\n        fun from(value: String?): Theme? {\n            return when (value) {\n                Dark.name -> Dark\n                Light.name -> Light\n                HighContrast.name -> HighContrast\n                else -> null\n            }\n        }\n    }\n}\n```\n\n이 메서드에서는 주어진 값과 일치하는 테마 이름이 무엇인지 확인합니다. 또한, 일치하는 것이 없을 때의 기본 케이스는 null입니다 - 일치하는 것이 없으면 시스템 기본값으로 가정하고 값을 null로 설정합니다.\n\n이제 데이터 스토어에 테마를 저장하기 위한 모든 준비가 되었습니다. 먼저 값을 읽기 위한 flow를 추가해 보겠습니다:\n\n```kotlin\n// SettingsRepository.kt\n\nprivate object PreferencesKeys {\n    ...\n    val colorTheme = stringPreferencesKey(\"color_theme\")\n}\n\nval colorThemeFlow: Flow<Theme?> = dataStore.data\n    .map {\n        Theme.from(it[PreferencesKeys.colorTheme])\n    }\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그럼, 먼저 preferences 키 오브젝트에 preferences 키를 추가합니다. 플로우를 위해 데이터 스토어에서 값을 읽은 다음, 앞서 정의한 Theme.from()을 사용하여 문자열을 Theme-enum으로 파싱합니다.\n\n값을 편집하기 위해 다음과 같은 함수를 정의합니다:\n\n```kotlin\n// SettingsRepository.kt\n\nsuspend fun setColorScheme(theme: Theme?) {\n    dataStore.edit { preferences ->\n        preferences[PreferencesKeys.colorTheme] = theme.toString()\n    }\n}\n```\n\n이 함수에서는 enum의 문자열 값을 정의한 preference 키를 사용하여 데이터 저장소에 설정합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음으로 할 일은 SettingsViewModel을 업데이트하는 것입니다. 먼저, 테마 값을 저장할 Mutable State Flow를 추가하고 UI에서 사용합니다:\n\n```kotlin\n// SettingsViewModel.kt\n\nprivate var _colorScheme =\n    MutableStateFlow<Theme?>(Theme.Dark)\nval colorScheme = _colorScheme.asStateFlow()\n```\n\n그런 다음, 리포지토리에서 값을 읽고 setColorScheme 함수를 사용할 수 있도록 함수를 정의합니다:\n\n```kotlin\n// SettingsViewModel.kt\n\nprivate fun getColorScheme() {\n    viewModelScope.launch {\n        settingsRepository.colorThemeFlow.collect {\n            _colorScheme.value = it\n        }\n    }\n}\n\nfun setColorScheme(theme: Theme?) {\n    viewModelScope.launch {\n        settingsRepository.setColorScheme(theme)\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n마지막으로 앱을 열 때 초기값을 얻기 위해 init 블록에서 getColorScheme()을 호출하는 것입니다:\n\n```js\n// SettingsViewModel.kt\n\ninit {\n    ...\n    getColorScheme()\n}\n```\n\n## 설정 화면\n\n지난 게시물과 마찬가지로 SettingsViewModel에서 값을 사용하는 방법을 보여주지는 않겠지만, 접근성 및 의미론적인 관점에서 몇 가지 사항을 언급하고 싶습니다: 각 색상 옵션은 선택 가능한 변경자를 가져야하며, 색상 옵션을 감싸는 구성 요소는 selectableGroup()-변경자를 가져야합니다. 내 코드에서 이러한 것들은 다음과 같습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n부모 컴포넌트에서 다음을 사용하고 있어요:\n\n```js\n// SettingsScreen.kt\n\nColumn(\n    modifier = Modifier.selectableGroup(),\n) {\n    colorOptions.map { option ->\n        ...\n    }\n}\n```\n\n이 작업이 왜 이루어지는지 더 알고 싶다면, 제 블로그 게시물인 젯팩 콤포즈에서 Modifier를 활용하여 Android 접근성 향상하기를 확인해보세요.\n\n## UI에 대한 테마 변경\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n최종 단계는 테마의 저장된 값 사용하여 해당 값을 업데이트하는 것입니다. 저장된 값에 따라 테마를 설정하는 로직을 추가해야 합니다.\n\n실제 테마 정의는 이 블로그 포스트의 범위를 벗어납니다. 저는 어두운, 밝은 및 고대비 테마에 대한 색상을 정의했고 코드에서 이를 사용할 것입니다.\n\nTheme.kt 파일에서 애플리케이션 테마의 기본 구현에 추가적인 확인을 추가해봅시다:\n\nAppTheme 코파서블에 Theme 유형의 선택적 매개변수를 추가하고 해당 값을 사용하여 MaterialTheme 구성 요소에 설정할 색상을 결정합니다. 테마가 null이 아닌 경우 값을 기준으로 색상을 설정하고, null이면 시스템의 기본 색상을 사용해야 합니다. 이를 위해 isSystemInDarkTheme 값을 확인하여 색상을 설정합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n마지막으로, 앱의 루트가 정의된 MainActivity에서 우리는 저장된 테마의 값을 읽은 다음 그 값을 AppTheme-composable에 전달합니다:\n\n```js\n// MainActivity.kt\n\nval theme = settingsViewModel.colorScheme.collectAsState()\n\nAppTheme(theme = theme.value) { ... }\n```\n\n그리고 이러한 변경 사항들로 설정에서 선택했을 때 다음 테마들을 볼 수 있게 될 것입니다:\n\n# 마무리\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 블로그 글에서는 앱에서 사용자가 테마를 선택할 수 있도록 설정을 추가하여 사용자가 소프트웨어의 테마를 결정하는 방법을 살펴보았어요. 제공되는 테마는 밝은 테마, 어두운 테마, 고대비 테마 또는 시스템의 기본 테마를 따를 수 있어요.\n\n당신의 앱에 테마 선택기를 구현해 보셨나요? 지금까지 고대비 테마를 경험해 보신 적이 있나요? 앞으로 다룰 수 있는 접근성 설정 유형에 대한 아이디어가 있으신가요?\n\n# 블로그 글 내 링크\n\n- 설정으로 접근성 개인화하기\n- 아이콘과 레이블을 토글하기 — 접근성 개인화\n- WebAIM\n- Jetpack Compose에서 Modifier로 안드로이드 접근성 향상하기\n","ogImage":{"url":"/assets/img/2024-05-27-ChangeAppThemePersonalizingAccessibility_0.png"},"coverImage":"/assets/img/2024-05-27-ChangeAppThemePersonalizingAccessibility_0.png","tag":["Tech"],"readingTime":9},{"title":"안녕하세요 이번 Android 스택 주간 소식입니다  Issue126","description":"","date":"2024-05-27 17:49","slug":"2024-05-27-AndroidStackWeeklyIssue126","content":"\n<img src=\"/assets/img/2024-05-27-AndroidStackWeeklyIssue126_0.png\" />\n\n# 기사\n\n## Jetpack Compose에서 공유 요소 전환으로 부드러운 탐색 경험\n\n안드로이드 앱에서 매끄러운 내비게이션 경험을 만들기 위해 Jetpack Compose에서 공유 요소 전환이 어떻게 구현되는지 배우세요. 이 안내서에는 설정, 종속성 및 코드 예시가 포함되어 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## Compose 컴파일러 보고서의 무난한 분석\n\nJetpack Compose 컴파일러 보고서를 쉽게 분석하여 안드로이드 앱의 성능을 최적화하는 방법을 알아보세요.\n\n## 접근성을 위한 앱 테마 개인화\n\n사용자가 빛, 어둠 및 고대비 옵션을 포함한 테마를 사용자 정의할 수 있도록 함으로써 앱 접근성을 향상시키는 방법을 배워보세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 안드로이드 뷰에 예측 후진 구현 로드맵\n\n안드로이드 앱에서 뷰를 사용하여 예측 후진 애니메이션을 통합하는 단계에 대해 설명하는 블로그 포스트입니다.\n\n## 안드로이드에서 효과적인 캐싱 전략\n\n안드로이드 앱을 위한 다양한 캐싱 전략을 탐색하며 API 캐싱에 초점을 맞춥니다. 이 글은 Cache Only, Network Only, Network First 및 여러 Cache First 전략과 같은 다양한 접근 방식에 대해 논의합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 토끼굴 속으로: 성능 최적화 통찰\n\n안드로이드 앱 개발에서 성능 최적화의 미묘한 점들을 로맹 가이와 함께 살펴보세요.\n\n**협찬**\n\n**라이브러리 및 자원**\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## ComposeGuard\n\nJetpack Compose에서 regression을 감지하는 Gradle 플러그인입니다.\n\n# Videos\n\n## 안드로이드 앱 경험을 향상시키는 3가지 방법: Edge to Edge, Predictive Back, 그리고 Glance\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 더 빠르게 만들기 - Android Developers Backstage\n\n## Jetpack Compose UI를 쉽게 디버깅하세요!\n\n## Google의 새로운 스크린샷 테스팅 프레임워크를 Compose에 어떻게 사용할 수 있을까요?\n\n## Stream SDK로 안드로이드 비디오 통화 앱 만들기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 다음 주간 소식을 위한 링크를 추천해주세요\n\n의겈이나 피드백을 환영합니다!\n\n제안하고 싶은 내용이나 의견이 있으시면 Canopas Twitter 계정 @canopas_eng 로 연락주시고, 다음 주간에 고려해 드리겠습니다.\n","ogImage":{"url":"/assets/img/2024-05-27-AndroidStackWeeklyIssue126_0.png"},"coverImage":"/assets/img/2024-05-27-AndroidStackWeeklyIssue126_0.png","tag":["Tech"],"readingTime":3},{"title":"Terraform을 활용한 Multi-Cloud 관리 마스터하기","description":"","date":"2024-05-27 17:46","slug":"2024-05-27-MasteringMulti-CloudManagementwithTerraform","content":"\n<img src=\"/assets/img/2024-05-27-MasteringMulti-CloudManagementwithTerraform_0.png\" />\n\n여러 공개 클라우드(Azure, AWS, GCP 등)를 사용하면 유연성을 제공하고 비용을 최적화하며 벤더 락인을 줄일 수 있습니다. 그러나 다양한 클라우드 플랫폼 간에 인프라 및 서비스를 관리하는 것은 어렵습니다.\n\n테라폼을 통해 일관되고 자동화된 멀티 클라우드 관리가 가능한지 알아봅시다. 이 포함사항은 멀티 클라우드 아키텍처, 테라폼 추상화, 프로비저닝, 거버넌스, 네트워킹, 배포 패턴, 테스팅, 그리고 Azure 및 GCP 전반적인 모니터링입니다.\n\n# 개요\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음 주제를 다룰 것입니다:\n\n- 테라폼을 사용한 멀티 클라우드 아키텍처\n- 인프라 차이점 추상화\n- 리소스 프로비저닝 및 의존성 관리\n- 정책 강화 및 거버넌스\n- 네트워킹 토폴로지와 연결\n- 블루-그린, 카나리아, 멀티 리전 배포 패턴\n- 통합 테스트 및 목 객체(Mock) 사용\n- 중앙 집중식 로깅, 메트릭 및 관찰 가능성\n\n이 코드 예제들은 테라폼을 사용해 Azure와 GCP로 인프라 및 서비스를 배포하는 방법을 보여줍니다. 이는 테라폼을 일관된 추상화 계층으로 사용하여 실제 멀티 클라우드 관리를 보여줍니다.\n\n# 멀티 클라우드 아키텍처\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n기본적인 멀티 클라우드 아키텍처는 Terraform을 사용하면 다음과 같이 보입니다:\n\nTerraform은 여러 클라우드 계정에 인프라를 프로비저닝하고 플랫폼 간의 차이를 추상화합니다. 상태는 원격으로 저장되며 계정 간에 공유됩니다.\n\n멀티 클라우드 아키텍처를 위한 몇 가지 주요 디자인 원칙:\n\n- 차이 추상화 — 공급자별 논리를 최소화하고 차이를 추상화 뒤에 숨깁니다\n- 환경 모듈화 — 환경 및 구성 요소별로 모듈화된 파일로 구성을 분리합니다\n- 표준화된 네이밍 — 쉽게 연관을 확인하기 위해 클라우드 간에 일관된 네이밍 체계 사용\n- 정책 캡슐화 — 정책 및 거버넌스 규칙을 모듈화된 재사용 가능한 파일에 유지합니다\n- 상태 중앙화 — 원격 상태를 사용하여 서비스 및 클라우드 전체의 상태를 공유합니다\n- 공유 서비스 추출 — ID, DNS, CDN과 같은 공유 서비스를 한 번 빌드하고 재사용합니다\n- 파이프라인 통합 — 모든 클라우드 대상으로 배포하는 표준 CI/CD 파이프라인 사용\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이러한 원칙을 따라서, 여러 대상 클라우드 간에 일관성있는 이동 가능한 구성을 구축할 수 있습니다.\n\n그 다음으로, Terraform이 클라우드 간의 차이를 추상화하는 데 어떻게 도움을 주는지 살펴보겠습니다.\n\n# 인프라 추상화\n\nTerraform의 강점 중 하나는 클라우드 플랫폼 간의 차이를 추상화하는 균일한 추상화 계층을 제공할 수 있는 능력입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n예를 들어, Azure 대 GCP에서 MySQL 데이터베이스 프로비저닝:\n\nAzure\n\n```js\nresource \"azurerm_mysql_server\" \"db\" {\n  name                = \"mysqlserver\"\n  location            = \"eastus\"\n  resource_group_name = azurerm_resource_group.rg.name\n```\n\n```js\n  sku {\n    name     = \"B_Gen5_2\"\n    capacity = 2\n  }\n}\nresource \"azurerm_mysql_database\" \"db\" {\n  name                = \"mydatabase\"\n  resource_group_name = azurerm_resource_group.rg.name\n  server_name         = azurerm_mysql_server.db.name\n  charset             = \"utf8\"\n  collation           = \"utf8_unicode_ci\"\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nGCP\n\n```js\nresource \"google_sql_database_instance\" \"db\" {\n  name             = \"mysql-instance\"\n  database_version = \"MYSQL_5_7\"\n  region           = \"us-central1\"\n```\n\n```js\n  settings {\n    tier = \"db-f1-micro\"\n  }\n}\nresource \"google_sql_database\" \"database\" {\n  name     = \"my-database\"\n  instance = google_sql_database_instance.db.name\n}\n```\n\nTerraform의 리소스 유형은 일관된 인터페이스를 제공하기 위해 기본 API 차이를 추상화합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 추상화는 대규모 변경없이 클라우드 간에 쉽게 전환할 수 있도록 도와줍니다. 필요한 경우 각 클라우드 공급업체에 맞게 엣지에서 맞춤 설정할 수 있습니다.\n\n테라폼이 다중 클라우드 추상화를 제공하는 주요 분야 몇 가지:\n\n- 컴퓨팅 — 가상 머신, 컨테이너, 쿠버네티스, 스케일링\n- 네트워크 — 서브넷, 라우팅, 보안 그룹, 로드 밸런싱\n- 스토리지 — 블롭, 디스크, 데이터베이스\n- 아이덴티티 — 역할, 권한, 액세스 제어\n- 인프라스트럭처 — DNS, VPN, 규칙, 정책\n\n최대한 다중 클라우드 추상화를 활용하여 구성을 작성하면 이동성이 높아집니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 프로비저닝 및 의존성\n\n여러 클라우드 인프라를 프로비저닝할 때 가장 좋은 방법은 리소스를 의존성 레이어로 구조화하는 것입니다.\n\n상위 수준의 구성은 하위 수준의 구성을 의존합니다. 예를 들어:\n\n테라폼을 사용할 때, depends_on 속성을 사용하여 리소스 의존성을 명시적으로 정의하세요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n리소스 \"azurerm_subnet\" \"public\" {\n#...\n}\n\n리소스 \"azurerm_network_interface\" \"nic\" {\n#...\nsubnet_id = azurerm_subnet.public.id\n}\n리소스 \"azurerm_virtual_machine\" \"main\" {\n#...\n\nnetwork_interface_ids = [\nazurerm_network_interface.nic.id,\n]\ndepends_on = [\nazurerm_network_interface.nic\n]\n}\n\n테라폼은 리소스 간 종속성을 분석하고 변경 사항을 올바른 순서로 적용합니다.\n\n멀티 클라우드 환경에서의 종속성에 대한 팁:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 공통 빌딩 블록을 기본 모듈에 네트워크와 같은 것으로 포함시킵니다.\n- 독립적인 구성 요소를 계층별로 분리합니다.\n- 암시적이어도 `depends_on`을 명시적으로 정의합니다.\n- 데드락을 일으키는 종속성 순환이 있는지 확인합니다.\n- 종속성 순서대로 계획하고 적용합니다.\n\n자원 종속성을 올바르게 설정하는 것이 여러 클라우드에서 원활한 프로비저닝을 위해 중요합니다.\n\n# 정책 집행과 거버넌스\n\n기관 정책과 규정 준수 요구사항을 강제하는 것은 여러 클라우드 관리에 있어 중요합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음은 운용 규칙의 몇 가지 예시입니다:\n\n- VM 유형 제한\n- 데이터 주권을 위한 지역 및 존 제어\n- 태깅 규칙과 표준 설정\n- 네트워킹 노출 제한\n- 암호화 요구 사항 강제\n- 고위험 자원 사용 제한\n\n테라폼을 통해 정책 강제를 활성화할 수 있습니다:\n\n변수\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n허용된 값 제한:\n\n```js\nvariable \"region\" {\n  type    = string\n  default = \"us-east-1\"\n}\n```\n\n```js\nresource \"aws_db_instance\" \"db\" {\n  region = var.region # us-east-1만 허용됩니다\n}\n```\n\n모듈\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n친구야, 모듈 내에서 지배 논리를 캡슐화하고 재사용하세요:\n\n```js\nmodule \"server\" {\n  source = \"./modules/certified_server\"\n# 인증된 서버는 합리적인 기본값을 설정합니다\n}\n```\n\nSentinel 정책\n\n리소스를 제한하는 대상 정책을 적용하십시오:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\naws_instance_disallowed_type = rule {\n  all aws_instance as _, instance {\n    instance.instance_type is not in [\"t2.micro\", \"t3.micro\"]\n  }\n}\n```\n\n이러한 메커니즘은 구성에 직접 규제를 포함하여 규정 준수를 쉽게 만듭니다.\n\n# 네트워킹 토폴로지\n\n다양한 클라우드 간 네트워크 연결성을 관리하는 것은 복잡성을 증가시킵니다. 일부 하이브리드 클라우드 네트워크 토폴로지는 다음과 같습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n테이블 형식을 Markdown 형식으로 변경하실래요.\n\n| Pairing                                                                                   |\n| ----------------------------------------------------------------------------------------- |\n| Connect cloud regions to on-prem data centers. Useful for migration and hybrid workloads. |\n\n| Hub-and-Spoke                                                                                    |\n| ------------------------------------------------------------------------------------------------ |\n| Central hub VPC with connectivity to multiple cloud spokes. Enables transitivity between spokes. |\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n메시\n\n클라우드 간 사이트 간 VPN이 구성된 완전히 메시된 네트워크입니다. 지역 간 직접 통신을 제공합니다.\n\n테라폼은 terraform-provider-aws, terraform-provider-azurerm 및 유사한 네트워킹 제공업체를 통해 이러한 네트워크 토폴로지를 조정하는 것을 단순화합니다.\n\n예를 들어, AWS에서 Azure로 사이트 간 VPN을 생성하는 방법:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n# AWS 측\n리소스 \"aws_customer_gateway\" \"gw\" {\n  bgp_asn    = 65002\n  ip_address = \"172.0.0.1\"\n  type       = \"ipsec.1\"\n}\n```\n\n```js\n리소스 \"aws_vpn_connection\" \"main\" {\n  vpn_gateway_id      = aws_vpn_gateway.vgw.id\n  customer_gateway_id = aws_customer_gateway.gw.id\n  type                = \"ipsec.1\"\n  static_routes_only  = true\n  tunnel1_ike_versions   = [\"ikev2\"]\n  tunnel2_ike_versions   = [\"ikev2\"]\n  tunnel1_phase1_dh_group_numbers = [31]\n  tunnel2_phase1_dh_group_numbers = [31]\n}\n# Azure 측\n리소스 \"azurerm_local_network_gateway\" \"lgw\" {\n  name                = \"aws-conn\"\n  resource_group_name = azurerm_resource_group.rg.name\n  location            = azurerm_resource_group.rg.location\n  gateway_address = aws_customer_gateway.gw.ip_address\n  address_space     = [\"172.16.0.0/16\"]\n}\n리소스 \"azurerm_virtual_network_gateway_connection\" \"main\" {\n  name                       = \"aws-conn\"\n  resource_group_name        = azurerm_resource_group.rg.name\n  location                   = azurerm_resource_group.rg.location\n  type                       = \"IPsec\"\n  virtual_network_gateway_id = azurerm_virtual_network_gateway.vgw.id\n  local_network_gateway_id   = azurerm_local_network_gateway.lgw.id\n  shared_key = aws_vpn_connection.main.tunnel1_preshared_key\n\n  ipsec_policy {\n    dh_group         = \"DHGroup31\"\n    ike_encryption   = \"AES256\"\n    ike_integrity    = \"SHA256\"\n    ipsec_encryption = \"AES256\"\n    ipsec_integrity  = \"SHA256\"\n    pfs_group        = \"PFS31\"\n    sa_datasize      = 536870912\n  }\n}\n```\n\n이 방법을 통해 멀티 클라우드에 일관된 방식으로 전체 연결 구성을 정의할 수 있습니다.\n\n# 배포 패턴\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여러 클라우드로 배포할 때 블루-그린, 카나리아, 다중 지역과 같은 패턴을 사용하면 관리가 간단해질 수 있어요.\n\n블루-그린\n\n블루-그린은 새 버전을 병렬로 배포한 다음 트래픽을 원자적으로 전환합니다. 이는 롤백 및 점진적인 롤아웃 기능을 제공합니다.\n\n예시:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n# 파란 환경\nmodule \"blue_env\" {\n  source = \"./env\"\n  color  = \"blue\"\n}\n```\n\n```js\n# 초록 환경\nmodule \"green_env\" {\n  source = \"./env\"\n  color  = \"green\"\n  # 처음에는 트래픽이 없음\n  traffic_weight = 0\n}\n# 트래픽 분할기\nresource \"aws_lb\" \"main\" {\n  # 100%의 트래픽을 파란 쪽에 보냅니다.\n}\n```\n\n그런 다음 로드 밸런서를 통해 점진적으로 파란 색에서 초록 색으로 트래픽을 이동합니다.\n\n카나리아\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n파란색-초록색처럼 변경되지만 처음에는 일부 사용자에게만 공개됩니다.\n\n```js\nmodule \"prod_env\" {\n  source = \"./env\"\n```\n\n```js\n  # 대부분의 트래픽이 본 프로덕션 환경으로 이동합니다.\n}\nmodule \"canary_env\" {\n  source = \"./env\"\n  # 소수의 트래픽이 canary로 이동합니다.\n  traffic_weight = 0.1\n}\n```\n\nMulti-Region\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n고가용성 및 낮은 대기 시간을 위해 여러 지역에 리소스를 프로비저닝합니다.\n\n예를 들어:\n\n```js\n# 서부 지역\nmodule \"west\" {\n  source = \"./region\"\n  providers = {\n    azurerm.west = azurerm.west\n  }\n}\n```\n\n```js\n# 동부 지역\nmodule \"east\" {\n  source = \"./region\"\n  providers = {\n    azurerm.east = azurerm.east\n  }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그럼 DNS와 로드 밸런싱을 사용하여 전 세계적으로 분산하세요.\n\n이러한 패턴은 멀티 클라우드 배포를 간단하게 해줍니다. 모듈 재사용은 일관성을 도와줍니다.\n\n# 통합 테스트\n\n여러 클라우드에 걸친 배포를 유효성 검사하려면 자동화된 통합 테스트가 필요합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n테라폼을 사용한 멀티 클라우드 테스팅을 위한 몇 가지 최상의 방법:\n\n- 인프라 테스트 — terraform plan 및 terraform show를 사용하여 올바른 구성의 리소스를 검증합니다.\n- 프로비저닝 테스트 — 처음부터 일회용 테스트 환경을 배포합니다.\n- 실패 테스트 — 종료된 인스턴스와 같은 실패를 시뮬레이션합니다.\n- 서비스 테스트 — 목업을 사용하여 서비스 접근성과 동작을 유효성 검사합니다.\n\n예를 들어, 일회용 테스트 환경을 생성하는 방법:\n\n```js\nmodule \"test_env\" {\n  source = \"./env\"\n  providers = {\n    aws = aws.test\n  }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n테이블 태그를 Markdown 형식으로 변경해주세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다양한 환경에서 배포를 유효성 검사하려면 자동화된 테스트가 필요합니다.\n\nTerraform을 사용하는 몇 가지 권장사항:\n\n- 사용 및 폐기 가능한 테스트 환경 프로비저닝\n- 리소스 구성 검증\n- 다양한 장애 시나리오 시뮬레이션\n- 의존성에 대한 모의 테스트 사용\n\n예시:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nmodule \"test_env\" {\n  source = \"./env\"\n```\n\n```js\n  # AWS 계정 자격 증명 테스트\n}\nresource \"null_resource\" \"check_connectivity\" {\n  provisioner \"local-exec\" {\n    command = \"ping.exe -n 3 ${module.test_env.ip}\"\n  }\n}\n```\n\n이렇게 하면 안전하게 변경 사항을 테스트할 수 있는 격리된 환경이 생성됩니다.\n\n다른 예시:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 성능 테스트를 위해 과거 트래픽을 다시 재생합니다.\n- 종료된 인스턴스와 같은 결함을 주입합니다.\n- 결정론적 테스트를 위해 외부 서비스를 스텁 처리합니다.\n\n자동화된 테스트는 구성 요소를 리팩토링할 때 자신감을 유지하는 데 중요합니다.\n\n## 가시성\n\n이질적인 클라우드 간 로그, 지표 및 추적에 대한 가시성을 확보하는 것은 어렵습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n테라폼을 사용하면 관측 가능성 데이터를 공유 플랫폼에 집계할 수 있습니다:\n\n로그 기능\n\n```js\nresource \"aws_cloudwatch_log_group\" \"app\" {\n  name = \"/aws/lambda/app\"\n}\nresource \"azurerm_monitor_diagnostic_setting\" \"app\" {\n  name               = \"diag\"\n  target_resource_id = azurerm_function_app.app.id\n  log_analytics_workspace_id = azurerm_log_analytics_workspace.main.id\n  log {\n    category = \"FunctionAppLogs\"\n    enabled  = true\n  }\n}\nresource \"google_logging_project_sink\" \"app\" {\n  name        = \"app-sink\"\n  destination = google_storage_bucket.logs.name\n}\n```\n\nSplunk와 같은 도구에서 로그를 중앙 집계하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n메트릭\n\n```js\n리소스 \"signalfx_detector\" \"지연시간\" {\n  이름 = \"높은 지연시간\"\n  프로그램_텍스트 = <<-EOF\n    A = 데이터('지연시간', 필터=필터('클라우드', '*') and 필터('환경', '*')).게시(label='A')\n    B = (A).합계(by=['클라우드', '환경']).게시(label='B')\n    detect(when(B > 1000, '5m')).게시('높은 지연시간!')\n  EOF\n}\n```\n\nDatadog와 같은 플랫폼에서 메트릭을 통합해보세요.\n\n트레이싱\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nmodule \"opentelemetry\" {\n  source = \"./opentelemetry\"\n  providers = {\n    aws = aws\n    azure = azurerm\n    google = google\n  }\n}\n```\n\n일반적인 형식으로 OpenTelemetry을 사용하면 추적을 쉽게 연결할 수 있어요.\n\n테라폼을 사용하면 다양한 플랫폼 사이에서 공유 관찰 패턴을 구축할 수 있어요.\n\n# 예시: 멀티-클라우드 웹 애플리케이션\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n실제로 멀티 클라우드 웹 애플리케이션을 Terraform으로 배포하는 실제 사례를 살펴봅시다.\n\nAWS ECS 및 Azure Container Instances (ACI)의 클러스터 전체에 애플리케이션 인프라를 배포할 것입니다. 글로벌 로드 밸런서가 트래픽을 플랫폼 간에 분배할 것입니다.\n\n네트워킹\n\n먼저, AWS VPC와 Azure VNet을 연결해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n# AWS VPC 및 서브넷\nresource \"aws_vpc\" \"main\" {\n  cidr_block = \"10.1.0.0/16\"\n}\n```\n\n```js\nresource \"aws_subnet\" \"public\" {\n  vpc_id = aws_vpc.main.id\n  cidr_block = \"10.1.1.0/24\"\n}\n# Azure VNet\nresource \"azurerm_virtual_network\" \"main\" {\n  name                = \"app-network\"\n  address_space       = [\"10.2.0.0/16\"]\n}\nresource \"azurerm_subnet\" \"public\" {\n  name                 = \"public-subnet\"\n  resource_group_name  = azurerm_resource_group.main.name\n  virtual_network_name = azurerm_virtual_network.main.name\n  address_prefixes     = [\"10.2.1.0/24\"]\n}\n```\n\nVPC 피어링을 통해 이들을 연결하십시오:\n\n```js\n# AWS 쪽 피어링\nresource \"aws_vpc_peering_connection\" \"peer\" {\n  vpc_id      = aws_vpc.main.id\n  peer_vpc_id = azurerm_virtual_network.main.id\n  auto_accept = true\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n# Azure 측 피어링\nresource \"azurerm_virtual_network_peering\" \"peer\" {\n  name                      = \"peer-aws\"\n  resource_group_name       = azurerm_resource_group.main.name\n  virtual_network_name      = az\n```\n\n컴퓨팅\n\nAzure Container Instances 배포:\n\n```js\nresource \"azurerm_container_group\" \"app\" {\n  name                = \"app-aci\"\n  location            = azurerm_resource_group.main.location\n  resource_group_name = azurerm_resource_group.main.name\n  ip_address_type     = \"public\"\n  dns_name_label      = \"app-aci\"\n  os_type             = \"Linux\"\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n  container {\n    name   = \"app\"\n    image  = \"myapp:v1\"\n    cpu    = \"1\"\n    memory = \"1\"\n    ports {\n      port     = 80\n      protocol = \"TCP\"\n    }\n  }\n```\n\n아마존 ECS 클러스터 및 서비스:\n\n```js\nresource \"aws_ecs_cluster\" \"main\" {\n  name = \"myapp-cluster\"\n}\n```\n\n```js\nresource \"aws_ecs_service\" \"web\" {\n  name            = \"web\"\n  cluster         = aws_ecs_cluster.main.id\n  task_definition = aws_ecs_task_definition.app.arn\n  desired_count   = 3\n  launch_type     = \"FARGATE\"\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n로드 밸런싱\n\n각 클라우드에 백엔드가 있는 글로벌 로드 밸런서를 배포하십시오:\n\n```js\nresource \"aws_lb\" \"web\" {\n  name               = \"myapp-lb\"\n  internal           = false\n\n  subnets = [\n    aws_subnet.public.id\n  ]\n}\n```\n\n```js\nresource \"azurerm_lb\" \"web\" {\n  name                = \"myapp-lb\"\n  location            = azurerm_resource_group.main.location\n  resource_group_name = azurerm_resource_group.main.name\n\n  frontend_ip_configuration {\n    name                 = \"public\"\n    public_ip_address_id = azurerm_public_ip.main.id\n  }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nMarkdown 포맷으로 DNS\n\n로드 밸런서를 통해 단일 도메인을 라우팅합니다:\n\n```js\nresource \"aws_route53_zone\" \"main\" {\n  name = \"myapp.com\"\n}\n```\n\n```js\nresource \"aws_route53_record\" \"webapp\" {\n  zone_id = aws_route53_zone.main.id\n  name    = \"webapp.myapp.com\"\n  type = \"CNAME\"\n  ttl  = \"300\"\n  records = [aws_lb.web.dns_name]\n}\nresource \"azurerm_dns_cname_record\" \"webapp\" {\n  name                = \"webapp\"\n  zone_name           = azurerm_dns_zone.main.name\n  resource_group_name = azurerm_resource_group.main.name\n  ttl                 = 300\n  record              = azurerm_lb.web.fqdn\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이는 웹 애플리케이션을 다중 클라우드에서 실행하기 위한 핵심 인프라를 제공하며, 로드 밸런싱과 DNS를 통해 연결됩니다.\n\n테라폼 추상화는 우리에게 클라우드 플랫폼 간에 일관된 방식으로 아키텍처를 표현할 수 있는 기회를 제공합니다. 배포를 확장하고 필요에 따라 데이터베이스, 객체 저장소 및 캐시와 같은 추가 구성 요소를 추가할 수 있습니다.\n\n# 결론\n\n이 블로그에서는 테라폼을 사용하여 다중 클라우드 인프라, 네트워킹, 배포, 테스트 및 모니터링을 관리하는 패턴과 모범 사례를 다루었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 추상화 — 추상화된 공급자 및 리소스를 사용하여 이식 가능한 구성물 생성\n- 모듈 — 복잡한 구성 요소를 재사용 가능한 모듈로 캡슐화\n- 상태 — 협업 가능하도록 원격 상태 저장\n- 네트워킹 — VPC와 VNET 간의 연결성 조정\n- 배포 — 블루-그린, 카나리아, 다중 지역 패턴 사용\n- 테스트 — 테스트 환경의 자동 프로비저닝\n- 가시성 — 로그, 메트릭 및 추적을 중앙 집중화\n\n테라폼은 각종 공용 클라우드, 개인 데이터 센터 및 SaaS 환경에서 인프라를 프로비저닝하고 관리하기 위한 일관된 워크플로우를 제공합니다. 이 가이드에서 다룬 패턴을 사용하면 다양한 API, 플랫폼 및 토폴로지를 연결하여 다중 클라우드 자동화 및 오케스트레이션을 더 쉽게 구현할 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-05-27-MasteringMulti-CloudManagementwithTerraform_0.png"},"coverImage":"/assets/img/2024-05-27-MasteringMulti-CloudManagementwithTerraform_0.png","tag":["Tech"],"readingTime":24},{"title":"GitOps와 Kubernetes, Terraform, Gitlab 그리고 FluxCD","description":"","date":"2024-05-27 17:43","slug":"2024-05-27-GitOpswithKubernetesTerraformGitlabandFluxCD","content":"\n<img src=\"/assets/img/2024-05-27-GitOpswithKubernetesTerraformGitlabandFluxCD_0.png\" />\n\n# 소개:\n\n이 블로그 포스트에서는 테라폼, gitlab, fluxcd 및 kustomize를 사용하여 엔드 투 엔드 gitops 워크플로를 설계하는 방법에 대해 논의하려고 합니다.\n\n그러나 구현 세부 정보에 대해 깊이 파고들기 전에, gitops가 다루는 문제 설명과 테라폼이 어떻게 관련되는지에 대해 이해해 봅시다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# GitOps의 무엇과 왜\n\n현재 우리가 인프라를 구축하는 방식을 살펴보면 대부분의 경우 인프라를 코드로 구축하거나 적어도 대부분의 클라우드 인프라가 그러한 방식으로 구축됩니다. 인프라를 코드로 사용하는 것의 하나의 어려움은 코드베이스가 성장하고 더 많은 사람들이 개발 프로세스에 참여함에 따라 코드베이스를 유지하는 것이 어려워진다는 것입니다.\n\n이것이 바로 gitops가 나타나는 곳입니다. 핵심적으로 gitops는 git을 활용하여 인프라 코드의 코드 베이스를 유지하고 설정을 대상 환경에 자동으로 매칭하는 방식을 사용합니다. 이러한 방식으로 우리는 이전보다 빠르게 배포할 수 있을 뿐만 아니라 시간이 지남에 따라 무엇이 변경되었는지 완전한 기록이 있기 때문에 이전보다 빨리 오류를 감지하고 복구할 수 있습니다.\n\n# GitOps에 대한 Terraform 선택이유\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n지금쯤이면 terraform이 어떻게 관련되며 어떻게 도움이 되는지 궁금해할 수 있습니다. 이전 섹션에서는 구성을 매치하는 자동화된 방법에 대해 이야기했습니다. 일반적인 Kubernetes 환경에서는 fluxcd와 같은 도구를 사용하여 이를 수행합니다. 그러나 이러한 추가 구성과 설정이 필요합니다. 여기서 terraform이 등장합니다. terraform을 사용하면 인프라를 구축할 뿐만 아니라 flux와 같은 도구를 설치하고 구성할 수도 있습니다. 이렇게 하면 한 번에 Kubernetes 클러스터를 구축하고 flux를 부트스트랩하며 그에 따라 gitops 워크플로우를 설정할 수 있습니다. 이렇게 하면 처음부터 완전히 기능적인 gitops 워크플로우가 구축됩니다.\n\n## 도구 개요:\n\n## FluxCD:\n\nFlux는 Kubernetes 클러스터를 구성 소스(예: Git 저장소)와 동기화하고 새 코드를 배포할 때 구성을 자동으로 업데이트하는 도구입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# Gitlab:\n\nGitLab은 응용 프로그램 빌드 및 릴리스 프로세스를 자동화하는 데 도움이되는 CI/CD 도구입니다.\n\n# Terraform:\n\nTerraform을 사용하면 선언적 구성 언어를 사용하여 가상 머신, 네트워크, 저장소 및 기타 클라우드 서비스와 같은 인프라 리소스를 정의하고 프로비저닝할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 우리가 만들 것:\n\n해결책에서는 nginx 앱을 eks 클러스터에 배포하고, flux를 사용하여 eks 클러스터에 대한 배포를 관리하며, 인프라 프로비저닝 및 flux 부트스트랩 구성을 위해 terraform을 사용합니다.\n\n# 설정\n\n# 준비 사항:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n1) AWS 계정\n2) Gitlab 클라우드 계정 / 자체 호스팅된 Gitlab\n3) 로컬 시스템에 설치된 최신 버전의 Terraform\n\n# 환경 설정:\n\n## AWS 설정:\n\nECR Repository 생성\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nAWS ECR 레지스트리에 로그인합니다.\n\n```bash\naws ecr get-login-password | docker login --username AWS --password-stdin <aws_account_id>.dkr.ecr.<region>.amazonaws.com\n```\n\nDocker Hub에서 Nginx 이미지를 가져옵니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n도커 pull nginx:latest\n```\n\n당신의 ECR 저장소에 Nginx 이미지를 태그하기\n\n```js\n도커 tag nginx:latest <aws_account_id>.dkr.ecr.<region>.amazonaws.com/nginx-repo:0.0.1\n```\n\n이미지를 ECR 저장소에 푸시하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n도커 푸시 <aws_account_id>.dkr.ecr.<region>.amazonaws.com/nginx-repo:0.0.1\n```\n\n## Gitlab 설정\n\nPAT 토큰 생성\n\n```js\n- GitLab 인스턴스에 로그인하세요\n- 프로필 아이콘을 클릭하세요\n- 환경설정을 클릭한 후에 접근 토큰을 클릭하세요\n- 토큰의 이름을 입력하고 만료 날짜를 설정하세요\n- 그 다음에 api 라는 scopes 아래의 첫 번째 확인란을 선택하세요\n- 개인 접근 토큰 만들기를 클릭한 후에 토큰을 표시하세요\n- 토큰을 저장하세요.\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n프로젝트 설정:\n\n```js\n- gitlab의 클라우드 인스턴스에서 새 프로젝트 버튼을 클릭합니다.\n- 빈 프로젝트 생성을 클릭합니다.\n- 프로젝트 이름을 제공합니다 (나중에 사용할 이름을 메모해 둡니다).\n- 프로젝트 URL 옆의 드롭 다운에서 그룹 이름을 선택하고,\n   이 그룹 이름을 나중에 사용할 것이니 메모해 둡니다.\n- 프로젝트를 위한 이름을 제공합니다.\n- 가시성을 선택합니다.\n- 프로젝트를 저장합니다.\n- 코드 버튼을 클릭하고, https용 github URL을 복사하여\n  나중에 필요할 때를 대비하여 URL을 메모해 둡니다.\n```\n\n## Terraform 설정\n\nTerraform 구성 및 스니펫을 사용하여 인프라를 구축하기 전에 아래 명령어를 사용하여 AWS 자격 증명을 설정해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nAWS 자격 증명 설정\n\n```js\n% export AWS_ACCESS_KEY_ID=\"anaccesskey\"\n% export AWS_SECRET_ACCESS_KEY=\"asecretkey\"\n% export AWS_REGION=\"us-west-2\"\n```\n\n위 설정을 완료한 후 로컬 환경에서 gitlab 토큰을 설정해야 합니다. 아래 섹션에서 그 방법을 안내하겠습니다. gitlab 설정 섹션에서 pat 토큰 섹션에서 복사한 토큰을 붙여넣어주세요.\n\nGitLab 토큰 설정 (Linux/MacOS)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nexport GITLAB_TOKEN=<Gitlab 설정에서 저장한 토큰>\n```\n\nWindows\n\n```js\n$env: GITLAB_TOKEN = \"<Gitlab 설정에서 저장한 토큰>\";\n```\n\n# 안내:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 데모 레포지토리 복제\n\n```js\ngit clone https://gitlab.com/devops5480719/devops-samples.git\n```\n\n그런 다음 인프라 디렉토리로 이동하세요\n\n```js\ncd devops-samples/gitops-gitlab/infra/\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n디렉토리 안으로 들어가시면 아래의 파일과 폴더를 찾을 수 있어요.\n\n```js\n├── config_files\n│   ├── app-nginx.yml\n│   ├── ecr-sync.yml\n│   └── nginx.yml\n├── main.tf\n├── variables.tf\n└── versions.tf\n```\n\n안에 config_files라는 폴더가 있고, 몇 개의 terraform 파일도 있어요.\n\n우선 terraform 파일들을 자세히 살펴보도록 해봐요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 변수 구성\n\n먼저 변수 구성을 살펴봅시다.\n\nvariables.tf\n\n```js\nvariable \"gitlab_group\" {\n  type = string\n  default = <gitlab 그룹의 이름>\n}\n\nvariable \"gitlab_project\" {\n  type = string\n  default = <gitlab 프로젝트의 이름>\n}\n\nvariable \"aws_region\" {\n  type = string\n  default = <리소스를 배포할 AWS 지역의 이름>\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위 코드 조각에서 기본 값 대신에 gitlab 섹션에서 이전에 복사한 이름이있는 gitlab_group으로 대체하십시오. gitlab_project에 대해서도 마찬가지입니다.\n\naws_region으로는 리소스를 배포할 지역을 선택하십시오.\n\n## 공급자 구성\n\n이제 versions.tf 파일에서 공급자 구성을 살펴봅시다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n변수.tf 파일에는 인증 및 권한 부여를 위한 각 프로바이더 블록의 필수 구성 및 필수 제공자가 포함되어 있습니다.\n\n버전.tf\n\n```js\nrequired_providers {\n    flux = {\n      source  = \"fluxcd/flux\"\n      version = \">= 1.0.0\"\n    }\n    gitlab = {\n      source  = \"gitlabhq/gitlab\"\n      version = \">=15.10.0\"\n    }\n    aws = {\n      source  = \"hashicorp/aws\"\n      version = \">= 5.0\"\n    }\n    kubernetes = {\n      source  = \"hashicorp/kubernetes\"\n      version = \">= 2.16.1\"\n    }\n  }\n}\nprovider \"gitlab\" {\n  base_url = \"https://gitlab.com/api/v4/\"\n}\nprovider \"flux\" {\n  kubernetes = {\n    host                   = module.eks.endpoint\n    cluster_ca_certificate = base64decode(module.eks.cluster_ca_certificate)\n    exec = {\n      api_version = \"client.authentication.k8s.io/v1beta1\"\n      args        = [\"eks\", \"get-token\", \"--cluster-name\", var.cluster_name]\n      command     = \"aws\"\n    }\n  }\n  git = {\n    url = \"ssh://git@gitlab.com/${data.gitlab_project.this.path_with_namespace}.git\"\n    ssh = {\n      username    = \"git\"\n      private_key = tls_private_key.flux.private_key_pem\n    }\n    branch = \"main\"\n  }\n}\n```\n\n## 리소스 구성:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n자원 구성을 살펴보겠습니다.\n\nVPC 구성\n\nmain.tf\n\n```js\nmodule \"vpc\" {\n  source = \"terraform-aws-modules/vpc/aws\"\n  name = \"flux-vpc\"\n  cidr = \"10.0.0.0/16\"\n  azs = [\"<aws-region>a\", \"<aws-region>b\", \"<aws-region>c\"]\n  private_subnets = [\"10.0.1.0/24\", \"10.0.2.0/24\", \"10.0.3.0/24\", \"10.0.4.0/24\", \"10.0.5.0/24\", \"10.0.6.0/24\"]\n  public_subnets = [\"10.0.101.0/24\", \"10.0.102.0/24\", \"10.0.103.0/24\"]\n  enable_nat_gateway = true\n  enable_vpn_gateway = false\n  single_nat_gateway = true\n  public_subnet_tags = {\n    \"kubernetes.io/role/elb\" = \"1\"\n  }\n  tags = {\n    Terraform = \"true\"\n    Environment = \"dev\"\n  }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nEKS 구성\n\nEKS를 위해 아래 리소스를 정의할 것입니다.\n\n- EKS 클러스터\n- kubeconfig를 컨텍스트에 추가하기 위한 Null 리소스\n\nmain.tf\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n모듈 \"eks\" {\nsource = \"terraform-aws-modules/eks/aws\"\nversion = \"~> 20.0\"\ncluster_name = \"flux-cluster\"\ncluster_version = \"1.29\"\ncluster_endpoint_private_access = true\ncluster_endpoint_public_access = true\ncloudwatch_log_group_retention_in_days = 7\ncloudwatch_log_group_class = \"INFREQUENT_ACCESS\"\ncluster_enabled_log_types = [\"api\"]\nvpc_id = module.vpc.vpc_id\nsubnet_ids = module.vpc.private_subnets\ncluster_addons = {\ncoredns = {\nmost_recent = true\n}\nkube-proxy = {\nmost_recent = true\n}\naws-ebs-csi-driver = {\nmost_recent = true\n}\neks-pod-identity-agent = {\nmost_recent = true\n}\nvpc-cni = {\nmost_recent = true\n}\n}\neks_managed_node_group_defaults = {\nami_type = \"AL2_x86_64\"\ndisk_size = 50\ninstance_types = [\"t3.large\"]\ncapacity_type = \"SPOT\"\nupdate_config = {\nmax_unavailable_percentage = 100\n}\n}\neks_managed_node_groups = {\nps-cluster-sample = {\nmin_size = 1\ndesired_size = 1\nmax_size = 4\ninstance_types = [\"t3.large\"]\ncapacity_type = \"SPOT\"\n}\n}\nenable_cluster_creator_admin_permissions = false\naccess_entries = {\nadmin_sso = {\nkubernetes_groups = []\nprincipal_arn = \"<arn of the role or the user to which you want to grant admin privileges>\"\npolicy_associations = {\nClusterAdmin = {\npolicy_arn = \"arn:aws:eks::aws:cluster-access-policy/AmazonEKSClusterAdminPolicy\"\naccess_scope = {\ntype = \"cluster\"\n}\n}\nEKSAdmin = {\npolicy_arn = \"arn:aws:eks::aws:cluster-access-policy/AmazonEKSAdminPolicy\"\naccess_scope = {\ntype = \"cluster\"\n}\n}\n}\n}\n}\n}\nresource \"null_resource\" \"update_kubeconfig\" {\ntriggers = {\neks_cluster_id = module.eks.cluster_id\n}\nprovisioner \"local-exec\" {\ncommand = \"aws eks update-kubeconfig --name ${module.eks.cluster_name} --region ${var.aws_region}\"\n}\n}\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n자바스크립트\n리소스 \"tls_private_key\" \"flux\" {\n  depends_on = [module.eks, module.vpc, null_resource.update_kubeconfig]\n  algorithm   = \"ECDSA\"\n  ecdsa_curve = \"P256\"\n}\n데이터 \"gitlab_project\" \"this\" {\n  path_with_namespace = \"${var.gitlab_group}/${var.gitlab_project}\"\n}\n리소스 \"gitlab_deploy_key\" \"this\" {\n  depends_on = [module.eks, module.vpc]\n  project  = data.gitlab_project.this.id\n  title    = \"Flux\"\n  key      = tls_private_key.flux.public_key_openssh\n  can_push = true\n}\n리소스 \"flux_bootstrap_git\" \"this\" {\n  depends_on = [gitlab_deploy_key.this, module.eks, module.vpc, null_resource.update_kubeconfig]\n  path = \"clusters/${module.eks.cluster_name}\"\n  components_extra = [\"image-reflector-controller\",\"image-automation-controller\"]\n}\n로컬 {\n  yaml_files = fileset(\"${path.module}/config_files\", \"*.yml\")\n  yaml_content = { for file in local.yaml_files : file => file(\"${path.module}/config_files/${file}\") }\n}\n리소스 \"gitlab_repository_file\" \"yaml_files\" {\n  depends_on = [flux_bootstrap_git.this, null_resource.update_kubeconfig]\n  for_each = local.yaml_content\n  project = data.gitlab_project.this.id // 새 프로젝트를 생성한 경우 기존 프로젝트나 gitlab_project.example_project.id의 프로젝트 ID를 사용하십시오.\n  file_path = \"clusters/${module.eks.cluster_name}/${each.key}\"\n  content   = base64encode(each.value)\n  commit_message = \"added flux image configs\"\n  branch    = \"main\"\n}\n```\n\n위의 코드 조각에서는 flux_bootstrap_git 리소스에 image-reflector-controller 및 image-automation-controller라는 두 가지 추가 컴포넌트를 추가하고 있습니다.\n\n이 두 컨트롤러는 ECR 리포지토리에서 태그를 가져오거나 업데이트할 책임을 질 것입니다.\n\nflux가 이 작업을 수행하려면 복제 데모 리포지토리의 config_files 폴더에서 찾을 수 있는 몇 가지 추가 구성 요소를 정의해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n├── config_files\n│ ├── app-nginx.yml\n│ ├── ecr-sync.yml\n│ └── nginx.yml\n├── main.tf\n├── variables.tf\n└── versions.tf\n\n이제 이 파일들 각각을 살펴보고 그 내용을 살펴보겠습니다. 우선 app-nginx.yaml 파일부터 시작해봅시다.\n\napp-nginx.yaml\n\n```yaml\n---\napiVersion: v1\nkind: Secret\nmetadata:\n  name: nginx-auth-pat\n  namespace: flux-system\ntype: Opaque\ndata:\n  password: < gitlab 토큰을 base64로 인코딩 된 문자열 >\n  username: < 사용자 이름을 base64로 인코딩 된 문자열 >\n---\napiVersion: source.toolkit.fluxcd.io/v1\nkind: GitRepository\nmetadata:\n  name: nginx\n  namespace: flux-system\nspec:\n  interval: 1m0s\n  ref:\n    branch: main\n  url: <gitlab_repo_url>\n  secretRef:\n    name: nginx-auth-pat\n---\napiVersion: kustomize.toolkit.fluxcd.io/v1\nkind: Kustomization\nmetadata:\n  name: nginx\n  namespace: flux-system\nspec:\n  prune: true\n  interval: 1m0s\n  path: \"./app/nginx/environments/production\"\n  sourceRef:\n    kind: GitRepository\n    name: nginx\n---\napiVersion: image.toolkit.fluxcd.io/v1beta2\nkind: ImageRepository\nmetadata:\n  name: nginx\n  namespace: flux-system\nspec:\n  image: <aws-account-id>.dkr.ecr.<region>.amazonaws.com/<image name>\n  interval: 1m0s\n  secretRef:\n    name: ecr-credentials\n---\napiVersion: image.toolkit.fluxcd.io/v1beta2\nkind: ImagePolicy\nmetadata:\n  name: nginx\n  namespace: flux-system\nspec:\n  imageRepositoryRef:\n    name: nginx\n  policy:\n    semver:\n      range: 0.0.x\n---\napiVersion: image.toolkit.fluxcd.io/v1beta1\nkind: ImageUpdateAutomation\nmetadata:\n  name: nginx\n  namespace: flux-system\nspec:\n  interval: 1m0s\n  sourceRef:\n    kind: GitRepository\n    name: nginx\n  git:\n    checkout:\n      ref:\n        branch: main\n    commit:\n      author:\n        email: flux@example.com\n        name: flux\n      messageTemplate: \"{range .Updated.Images}{println .}{end}\"\n    push:\n      branch: main\n  update:\n    path: ./clusters/flux-cluster/nginx.yml\n    strategy: Setters\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위 구성에서는 아래 구성 요소를 정의했습니다:\n\n- Secret: 우리는 gitlab 설정 섹션에서 만든 base64로 인코딩된 pat 토큰 및 gitlab의 git repo에 대한 사용자 이름을 정의했습니다. 사용자 이름은 terraform의 provider 섹션 구성에 따라 'git'을 사용했습니다.\n- GitRepository: 이는 flux가 yaml 파일을 폴링할 gitlab 리포지토리 URL입니다. 이는 gitlab 설정 섹션에서 만든 파일입니다.\n- ImageRepository: 특정 태그 집합을 스캔하고 저장할 리포지토리를 정의했습니다.\n- ImagePolicy: 이미지 리포지토리에서 \"latest\" 이미지를 선택하는 규칙을 정의합니다.\n- ImageUpdateAutomation: 동일한 네임스페이스 내의 이미지 정책 객체를 기반으로 git 리포지토리를 업데이트할 자동화 프로세스를 정의합니다.\n\nImageUpdateAutomation 아래 파일에서, flux가 이미지 태그를 업데이트할 경로를 .spec.update.path 아래 ./clusters/flux-cluster/nginx.yml로 정의했습니다. 이것은 flux에 이미지 태그를 업데이트할 위치를 알려줍니다.\n\n위 구성 이후에는 또한 ecr 동기화 파일을 정의해야 합니다. 이 파일은 ecr에 대한 인증을 자동화하고 이미지 자동화 컨트롤러가 ecr 리포지토리에서 이미지 태그를 가져올 수 있도록 합니다. 아래 파일은 매 6시간마다 ecr에서 인증하는 데 필요한 권한을 가진 크론 작업을 설정하고 비밀 정보를 업데이트합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```yaml\nkind: Role\napiVersion: rbac.authorization.k8s.io/v1\nmetadata:\n  name: ecr-credentials-sync\n  namespace: flux-system\nrules:\n  - apiGroups: [\"\"]\n    resources:\n      - secrets\n    verbs:\n      - get\n      - create\n      - patch\n---\nkind: RoleBinding\napiVersion: rbac.authorization.k8s.io/v1\nmetadata:\n  name: ecr-credentials-sync\n  namespace: flux-system\nsubjects:\n  - kind: ServiceAccount\n    name: ecr-credentials-sync\nroleRef:\n  kind: Role\n  name: ecr-credentials-sync\n  apiGroup: \"\"\n---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: ecr-credentials-sync\n  namespace: flux-system\n  # Uncomment and edit if using IRSA\n  # annotations:\n  #   eks.amazonaws.com/role-arn: <role arn>\n---\napiVersion: batch/v1\nkind: CronJob\nmetadata:\n  name: ecr-credentials-sync\n  namespace: flux-system\nspec:\n  suspend: false\n  schedule: 0 */6 * * *\n  failedJobsHistoryLimit: 1\n  successfulJobsHistoryLimit: 1\n  jobTemplate:\n    spec:\n      template:\n        spec:\n          serviceAccountName: ecr-credentials-sync\n          restartPolicy: Never\n          volumes:\n            - name: token\n              emptyDir:\n                medium: Memory\n          initContainers:\n            - image: amazon/aws-cli\n              name: get-token\n              imagePullPolicy: IfNotPresent\n              # You will need to set the AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY environment variables if not using\n              # IRSA. It is recommended to store the values in a Secret and load them in the container using envFrom.\n              # envFrom:\n              # - secretRef:\n              #     name: aws-credentials\n              env:\n                - name: REGION\n                  value: us-east-1 # change this if ECR repo is in a different region\n              volumeMounts:\n                - mountPath: /token\n                  name: token\n              command:\n                - /bin/sh\n                - -ce\n                - aws ecr get-login-password --region ${REGION} > /token/ecr-token\n          containers:\n            - image: ghcr.io/fluxcd/flux-cli:v0.25.2\n              name: create-secret\n              imagePullPolicy: IfNotPresent\n              env:\n                - name: SECRET_NAME\n                  value: ecr-credentials\n                - name: ECR_REGISTRY\n                  value: <account id>.dkr.ecr.<region>.amazonaws.com # fill in the account id and region\n              volumeMounts:\n                - mountPath: /token\n                  name: token\n              command:\n                - /bin/sh\n                - -ce\n                - |-\n                  kubectl create secret docker-registry $SECRET_NAME \\\n                    --dry-run=client \\\n                    --docker-server=\"$ECR_REGISTRY\" \\\n                    --docker-username=AWS \\\n                    --docker-password=\"$(cat /token/ecr-token)\" \\\n                    -o yaml | kubectl apply -f -\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 1\n  template:\n    spec:\n      containers:\n        - name: nginx\n          image: <aws-account-id>.dkr.ecr.<aws-region>.amazonaws.com/nginx:0.0.0 # {\"$imagepolicy\": \"flux-system:nginx\"}\n```\n\n위의 두 줄 # '\"$imagepolicy\": \"flux-system:nginx\"' 는 flux-system이 네임스페이스이고 nginx가 이미지 정책의 이름임을 나타내는 표식입니다. 이는 app-nginx.yml 파일에서 정의된 자동화 구성과 일치해야 합니다.\n\n이 작은 단편은 flux에게 컨테이너 이미지를 업데이트할 때 사용해야 하는 정책을 알려줍니다.\n\n이 모든 파일은 이것을 적용하기 위해 flux 폴더로 복사되어 메인.tf 파일의 아래 코드 단편을 통해 eks 클러스터에 적용될 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nlocals {\n  yaml_files = fileset(\"${path.module}/config_files\", \"*.yml\")\n  yaml_content = { for file in local.yaml_files : file => file(\"${path.module}/config_files/${file}\") }\n}\nresource \"gitlab_repository_file\" \"yaml_files\" {\n  depends_on = [flux_bootstrap_git.this, null_resource.update_kubeconfig]\n  for_each = local.yaml_content\n  project = data.gitlab_project.this.id // Use the project ID of an existing project or gitlab_project.example_project.id if you created a new project\n  file_path = \"clusters/${module.eks.cluster_name}/${each.key}\"\n  content   = base64encode(each.value)\n  commit_message = \"added flux image configs\"\n  branch    = \"main\"\n}\n```\n\n# 배포:\n\n그 다음 아래 명령어를 실행하여 Terraform 초기화를 수행하십시오.\n\n```js\nterraform init\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그럼 진행되는 모든 리소스를 확인하려면 plan 명령어를 실행해주세요.\n\n```js\nterraform plan\n```\n\n그 다음에는 테라폼 설정을 적용할 수 있어요.\n\n```js\nterraform apply --auto-approve\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래 Terraform이 다음 작업을 수행할 것입니다.\n\n```js\nVPC 및 지원 리소스 생성\nEKS 클러스터 및 지원 리소스 생성\nEKS와 함께 Flux를 부트스트랩하고 모든 구성 및 애플리케이션 파일을 GitLab 저장소에 저장\n```\n\nTerraform 실행이 완료되면 아래 명령을 실행하세요.\n\n```js\nkubectl get po -n flux-system\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래의 Flux 구성 요소가 모두 실행 중인 것을 확인해야 합니다.\n\n```js\nNAME                                           READY   STATUS    RESTARTS   AGE\nhelm-controller-5f7457c9dd-6svk8               1/1     Running   0          40s\nimage-automation-controller-79447887bb-blqp4   1/1     Running   0          40s\nimage-reflector-controller-65df777f5c-nrgsx    1/1     Running   0          40s\nkustomize-controller-5f58d55f76-tpgs6          1/1     Running   0          40s\nnotification-controller-685bdc466d-mp46f       1/1     Running   0          40s\nsource-controller-86b8b57796-vl2fp             1/1     Running   0          39s\n```\n\n이제 모든 구성 요소가 실행 중이므로, ecr 비밀 cron 작업이 실행되었는지 확인해보겠습니다. 터미널에서 다음 명령을 실행하세요.\n\n```js\nkubectl get cronjob -n flux-system\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래 출력을 얻어야 합니다.\n\n```js\nNAME                   SCHEDULE      SUSPEND   ACTIVE   LAST SCHEDULE   AGE\necr-credentials-sync   0/1 * * * *   False     0        51초           2분 42초\n```\n\n이제 flux-system 네임스페이스에 시크릿이 있는지 확인해 보겠습니다. 아래 출력이 표시되어야 합니다:\n\n```js\nk get secret -n flux-system\n\nNAME              TYPE                             DATA   AGE\necr-credentials   kubernetes.io/dockerconfigjson   1      3분 7초\nflux-system       Opaque                           3      5분 39초\nnginx-auth-pat    Opaque                           2      4분 19초\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 출력에서 확인할 수 있듯이 ecr-credentials라는 시크릿이 있습니다.\n\n이제 ecr을 확인해 봅시다.\n\n이제 flux 이미지 컨트롤러가 우리의 ecr 저장소에서 태그를 가져올 수 있는지 확인해 보겠습니다.\n\n```js\nflux get image all\nNAME                   LAST SCAN                       SUSPENDED       READY   MESSAGE\nimagerepository/nginx   2024-05-23T16:55:46+05:30       False           True    successful scan: found 2 tags\nNAME                    LATEST IMAGE                                                    READY   MESSAGE\nimagepolicy/nginx       <aws-account-id>.dkr.ecr.<aws-region>.amazonaws.com/nginx:0.0.1       True    '<aws-account-id>.dkr.ecr.<aws-region>.amazonaws.com/nginx'의 최신 이미지 태그가 0.0.1로 해결되었습니다\nNAME                            LAST RUN                        SUSPENDED       READY   MESSAGE\nimageupdateautomation/nginx     2024-05-23T16:55:39+05:30       False           True    레포지토리가 최신 상태입니다\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 출력에서 볼 수 있듯이, 이미지 정책은 ECR에서 최신 이미지 태그를 스캔하고 가져왔습니다.\n\n이제 아래 명령을 사용하여 배포에 동일한 업데이트가 반영되었는지 확인해봅시다:\n\n```js\nkubectl get deployment nginx-deployment -o=jsonpath='{.spec.template.spec.containers[*].image}' | awk -F '[:@]' '{print $1, $2}'\n```\n\n아래는 우리가 얻은 출력입니다. 이미지가 업데이트된 것을 확인할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n<aws-account-id>.dkr.ecr.<aws-region>.amazonaws.com/nginx:0.0.1\n```\n\n이제 깃랩 쪽으로 이동하여 플럭스가 필요한 변경 사항을 수행했는지 확인해보세요.\n\nUI를 통해 레포지토리의 커밋 히스토리를 확인하거나 레포지토리를 복제한 후 아래 명령어를 실행할 수 있습니다.\n\n아래 명렁어를 실행해보세요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```bash\ngit log --author=\"flux\" --since=\"today 00:00\" --until=\"today 23:59\" --pretty=format:\"%h %s\" -- clusters/flux-cluster/nginx.yml\n```\n\n아래는 출력된 내용입니다:\n\n```bash\n85e5b48 <aws-account-d>.dkr.ecr.<aws-region>.amazonaws.com/nginx:0.0.1\n```\n\n위의 출력에서 확인할 수 있듯이 flux가 nginx.yml 파일에서 임의의 이미지 번호에서 실제 태그로 이미지를 업데이트했으며, 동일한 업데이트가 배포에서 수행되었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이미지의 새로운 버전을 푸시해보고 flux가 자동으로 업데이트되는지 확인해봐요.\n\nECR 저장소에 Nginx 이미지를 태그해보세요.\n\n```js\ndocker tag nginx:latest <aws_account_id>.dkr.ecr.<region>.amazonaws.com/nginx-repo:0.0.2\n```\n\n이제 아래 명령어를 사용하여 배포가 정상적으로 업데이트되었는지 확인해보세요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 표시되는 출력 값 입니다:\n\n```bash\n<aws-account-id>.dkr.ecr.<aws-region>.amazonaws.com/nginx:0.0.2\n```\n\n# 결론\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그래서 결론적으로, 우리는 flux, gitlab, terraform, kubernetes를 사용하여 gitops 워크플로우를 설정했고, 새 이미지를 컨테이너 저장소에 푸시할 때마다 flux가 배포를 관리할 것입니다.\n\n# 참고 자료:\n\nFlux 문서: [https://fluxcd.io/flux/](https://fluxcd.io/flux/)\n","ogImage":{"url":"/assets/img/2024-05-27-GitOpswithKubernetesTerraformGitlabandFluxCD_0.png"},"coverImage":"/assets/img/2024-05-27-GitOpswithKubernetesTerraformGitlabandFluxCD_0.png","tag":["Tech"],"readingTime":30}],"page":"46","totalPageCount":113,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":2},"__N_SSG":true}