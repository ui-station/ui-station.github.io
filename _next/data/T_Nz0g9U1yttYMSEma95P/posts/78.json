{"pageProps":{"posts":[{"title":"새 차 인스타그램 캡션","description":"","date":"2024-05-20 19:05","slug":"2024-05-20-newcarinstagramcaption","content":"\n# 새 차 인스타그램 캡션 Top 101+ - (재미있는 차 명언 및 상태)\n\n어떤 순간 당신이 꿈꿔왔던 차를 샀다는 상황에 처해본 적이 있나요? 그 순간은 꿈 이상이에요. 오랜 시간동안 준비를 하고 있었을지도 모르지만, 자신의 차를 받는 그 날, 구름 아홉 개 위에 있는 듯한 기분이 들어요! 그때 우리는 순간을 남기고 새 차를 데리고 셀카를 찍고 그것을 셀피 명언과 새 차 인스타그램 캡션으로 올려요.\n\n새 차 게시물을 위한 최고의 차 명언을 찾고 계신가요? 여기 새 차 명언 및 캡션에 대한 멋진 명언 몇 가지를 소개해 드릴게요. 우리의 가치 있는 새 차 캡션 컬렉션으로 인스타에 포스팅하면 친구, 형제자매 및 친척들의 관심을 끌 수 있을 거에요.\n\n자신의 수고로 구매한 새 차는 여전히 우리 많은 사람들에게 꿈일 거예요. 차는 모두에게 그저 차뿐만이 아니라 감정이고, 가족 구성원이기도 해요. 차는 우리가 좋은 순간과 슬픈 순간을 지나면서 지원해 준답니다. 차는 계속 우리와 함께인 한 우리의 모든 기쁜 순간과 슬픈 순간을 지켜봐 주지요. 그래서 당연히 우리는 우리의 차에 애착을 가지게 되죠.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n안녕하세요, 새 차를 산 사람들이 얼마나 행복하고 설레는지 잘 알잖아요...\n\n우리 삶에서 이렇게 소중한 순간을 위해 새로운 차에 대한 게시물을 작성해야 합니다. 그래서 Instagram 캡션, Whatsapp 상태 또는 Facebook 이야기로 게시할 수 있는 다양한 새로운 차 상태를 모았어요.\n\n그래서 여러분이 새 차를 구매한 그 순간을 더 즐겁게 만들어줄 완벽한 새 차 캡션을 찾아보아요...\n\n그리고 왜냐면 끝내주게 잘했으니까요. 소중한 차를 얻었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n당신의 꿈의 차를 사는 것은 분명히 삶에 즐거움과 성취감을 더해줍니다.\n\n그래서 오늘 이 포스트에서는 몇 가지 최고의 새로운 자동차 인스타그램 캡션과 상태를 공유하기로 결정했습니다.\n\n그리고 물론, 우리는 이 완벽한 캡션들이 당신이 IG에 공유할 콘텐츠에 마지막 손길을 더해준다는 것을 알고 있습니다.\n\n일부 캡션은 격려적이며 다른 일부는 새로운 차량에 대한 당신의 사랑을 정의합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 포스트 속으로 깊게 들어가 봅시다.\n\n- “침묵 속에서 열심히 일하고 새 차가 소리를 내도록 해봅시다.”\n- “물건을 위해 기도하지 않아요, 원하는 것을 위해 일해봐요.”\n- “차를 시작하고 그걸 타보세요.”\n- “차를 느껴보고, 운전해보고, 그리고 보여주세요.”\n- “당신의 차는 당신의 태도입니다. 어디든 가기 전에 입어봐요.”\n- “나는 이 새로운 레이디인 내 새 차에 반했어요.”\n- “꿈을 따르지 마세요... 꿈을 통제하세요...!!!”\n- “보통 물건에 이름을 붙이지 않지만, 당신을 산 후에는 당신을 내 태도라고 불러도 되겠네요.”\n- “사람들이 당신을 쫒을 건데요, 당신이 오늘 꿈을 쫒는다면.”\n- “오래된 차를 살아도 되지만, 일생안에 그 차를 몰 것은 안돼요.”\n\n![이미지](/assets/img/2024-05-20-newcarinstagramcaption_0.png)\n\n- “차는 당신의 삶을 바꾸지 않겠지만, 분명히 당신의 태도는 바꿀 거예요.”\n- “내 차는 내 자존심이고, 난 그것을 잃지 않을 거예요.”\n- “질투하지 마세요, 친구들. 여러 쇼룸에서 구매할 수도 있답니다.”\n- “차를 잘 돌보지 못한다면 산지 말아주세요.”\n- “이 아름다움을 보세요.”\n- “차를 잘 다뤄주면 결코 문제를 일으키지 않을 거예요.”\n- “모든 차가 필요한 음료수인 엔진 오일.”\n- “운전 좌석에 앉아 운전하는 건 행복한 일이에요.”\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 이 Instagram 자기 소개글은 자립심으로 가득 찬 「새로운 차를 위한 310가지 이해하기 쉬운 Instagram 자기 소개글」도 읽어보세요.\n\n- “새 차의 향기는 믿기 힘들 정도로 신비로워.”\n- “사람들은 인스타그램에 새 차 상태를 게시하고 다른 사람에게 자랑을 떨거들죠... 저는 다른 것을 믿어요.”\n- “차를 탄다면 긍정적인 태도를 갖고 있어야 해.”\n- “한 남자는 일생동안 차를 사려고 노력해.”\n- “많은 사람에게 새 차를 구매하는 것은 큰 꿈이야.”\n- “이건 그냥 차가 아니야, 나에게 감정이야.”\n- “운전하고 먹고 자고 반복해.”\n- “나에게 행운의 새 차 날.”\n- “어릴 적 꿈이 오늘 이뤄지는 날, 드디어 가족을 위해 새 차를 살 거야.”\n- “이 세상 모든 것이 계속해서 업그레이드 중... 우리 차도 업그레이드하자.”\n- “아름다움의 정확한 의미를 알아? 내 차를 한 번만 보면 알 거야.”\n- “집 안의 야수.”\n- “처음뵙자마자 사랑에 빠진다는 건 믿지 않았지만... 내 차가 반론을 증명했어.”\n- “부르릉 부르릉! 부르릉 부르릉! 내 차가 온다!”\n- “내 아름다움과 함께 길을 떠나는 시간이야.”\n- “눈을 믿을 수 없어, 진짜 네가 집에 들어왔다는 게.”\n- “이제 영원히 네 것이야.”\n- “우리 차에는 많은 기억이 담겨있어.”\n\n# 동기 충만한 New Car Instagram 자기 소개글\n\n- 침착하게 운전해\n- 사랑을 위해 기도하지 않아도 돼, 차를 위해 기도해\n- 엔진을 켜고 가속해\n- 먹고, 자고, 드리프트, 반복\n- 꿈을 쫓는 건 좋지만, 꿈을 운전하는 건 더 좋아\n- 다른 사람들에게 계획을 얘기하지 말고, 성과를 보여줘\n- 남자의 가장 비싼 취미\n- 새 차는 당신의 삶은 바꾸지 못할지 몰라도 태도는 바꿔줘\n- 끌어당김의 법칙은 진짜야. 이 아름다운 차를 운전하는 모습을 상상해왔다가 마침내 꿈이 이루어짐을 말할 수 없어\n- 당신이 타는 차에 관한 게 중요한 게 아니야, 어떻게 운전하는지가 중요해\n- 남자는 한 달 동안 여자친구를 좋아하지만, 일 년 동안 아내를 사랑하지만, 차는 영원히 좋아해\n- 성공 모드로 전환해\n- 야수를 해방시키다\n- 여자를 끌어당기기 위해 “새 차 인테리어” 라는 향수를 뿌리고 다녀\n- 컬렉션에 새롭게 추가\n- 꿈에 나오는 스포츠카를 찾을 수 없어서 직접 만들었어\n- 새 차의 향기는 행복\n- 우리 새로운 바퀴에 완전히 반해\n- 남자들은 여자를 좋아하지만, 그보다 더 자동차를 좋아해\n- 새 주인에게는 많이 변한 게 없지만, 정말 멋져 보이기 시작했어\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\ngta 5 DP 및 이미지\n\n# 인스타그램을 위한 최고의 새로운 차 캡션:\n\n- 가치 있는 것은 쉽게 얻을 수 없습니다\n- 이 차에 대한 내 사랑을 표현할 수 없어\n- 그 차는 완벽했고, 이것은 나를 기쁘게 해주었어\n- 인상적이고 아름다운 내 새로운 (— 당신의 차 이름을 넣으세요)\n- 나를 알고 있다면, 차고에 새롭게 추가된 것에 얼마나 흥분하는지 알 것이다\n- 첫 어른 단계\n- 오늘 일어난 일, 많은 노력이 들었지만 이것이 보람 있었어\n- 내 첫 번째 어른의 구매\n- 도로를 달릴 때가 왔어\n- 얼마나 비싼지 모르겠지만, 새로운 차에 정말 열광하고 있어\n- 내 사랑 차가 도착했어\n- 정말 내 것이라고 믿을 수 없어\n- 아무도 너를 위해 이것을 사주지 않아, 넌 스스로 얻어야 해\n- 우리가 타는 차가 우리에 대해 많은 것을 말해\n- 나는 이 현실을 창조했고, 너도 할 수 있어\n- 잘, 개처럼 짖지는 않지만.....새 차처럼 경적을 울린다\n- 비프 비프, 나 여자가 새 지프를 샀어\n- 보고 싶다, 좋아한다, 원한다, 얻었다. 내 새로운 차와 함께 새로운 모험을 시작할 준비가 돼 있어\n- 내가 달리는 걸 보면 사람들은 욕한다\n- 지면은 지고 태어나면 이기는 법\n- 그 새 차 냄새 ❤️❤️\n- 불가능을 이겨내고 번호를 올리며 겸손해지기\n- 열심히 일하고 겸손해지고 일어나자\n- 꿈꾸지 말고, 그것을 운전해보자\n- 나의 집에 이렇게 드디어 도착한 것을 보라..... 그리고 인정하건대, 나는 원하던 것을 기다릴 가치가 있었다\n- 나는 라크에 있을지 모르겠지만, 부족할지도 모르지만, 이것은 내 새로운 차야\n- 판매원이 말했다 \"차는 그 주인처럼 섹시하다\"\n- 인생은 지루한 차를 타기에는 너무 짧다\n- 나에게, 나로부터, 행복한 새 차의 날!!\n- 새로운 것 중에도 좋은 것들이 있어, 특히 새 차 냄새\n- 나의 첫 어린 시절 꿈이 이루어졌어..... 마침내, 내가 가지고 싶던 새 차를 가졌다\n- 최근 인생은 나에게 많은 어려움을 던졌지만, 그것을 바꿔 좋은 일로 만들기 위해 노력할 거야 그리고 나의 (당신의 차 이름을 넣으세요)에 인사해\n\n# 인스타그램을 위한 차 인용문\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 마음속에서 느껴보세요 ….. 믿어보고, 무엇보다도 그것이 당신의 것이 될 수 있다고 믿어보세요\n- 채찍을 고정시키고, 버터컵\n- 인생은 업그레이드에 관한 모든 것, 내 차를 업그레이드해야 해\n- 조용한 움직임, 시끄러운 결과\n- 사나이와 그의 차 사이의 사랑은 그 느낌을 경험한 이들에게만 이해될 수 있어요... 차를 사랑하는 사람만 알 수 있는 것이죠\n- \"아름다운\"이라는 말은 이 기계의 화려함을 표현하는 데 부족하죠\n- 차를 주차한 후, 차를 돌아보지 않는다면, 당신은 잘못된 차를 소유하고 계십니다\n- 핸드폰을 확인하는 것을 잊게 만드는 열정을 찾아보세요\n- 차를 좋아하는 여성들은 이상한 것이 아니에요, 그들은 신으로부터 받은 선물이죠\n- 차고에서 차를 돌보면 차는 당신을 돌볼 거에요\n- 연인에게 사랑을 담은 좋은 밤 이미지와 함께 왓츠앱을 위한 야경\n","ogImage":{"url":"/assets/img/2024-05-20-newcarinstagramcaption_0.png"},"coverImage":"/assets/img/2024-05-20-newcarinstagramcaption_0.png","tag":["Tech"],"readingTime":7},{"title":"SQL 전문가처럼 쓰기 실생활 시나리오에서 소개되는 고급 기술","description":"","date":"2024-05-20 19:03","slug":"2024-05-20-WritingSQLLikeaProAdvancedTechniquesShowcasedinaReal-LifeScenario","content":"\n## Google의 BigQuery를 사용하여 고급 SQL 기술을 활용하여 두 개의 히스토리 테이블을 병합하는 방법\n\n![이미지1](/assets/img/2024-05-20-WritingSQLLikeaProAdvancedTechniquesShowcasedinaReal-LifeScenario_0.png)\n\n![이미지2](/assets/img/2024-05-20-WritingSQLLikeaProAdvancedTechniquesShowcasedinaReal-LifeScenario_1.png)\n\n지난 주, Analytics Engineer인 Arnaud Stephan이 고급 사용 사례에 대해 도움을 요청했는데, 그것은 매우 흥미로운 것으로 발견했습니다. 그의 도움을 받기 위해 몇 시간을 보낸 후, 블로그 글 주제로 적합하다고 생각했고, 이 고급 실제 문제를 공개적으로 논의하고 관련 코드를 게시할 수 있는지 허락을 요청했습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n자, 함께 Google BigQuery에서 고급 SQL 실전을 준비해 보시죠!\n\n(참고: 개인 정보 보호를 위해 ID 및 값은 더미로 대체했습니다.)\n\n저자 소개:\n\nSQL 및 빅 데이터 분야에서 12년 이상 경력을 가진 프리랜서 분석 엔지니어 / 데이터 플랫폼 엔지니어입니다. 복잡한 SQL/DataFrame 주제를 다루는 것을 좋아하며, SQL로 풀지 못하는 어려운 문제에 막혔다면 언제든 도움을 요청해 주세요. 도와드릴 수도 있을 거예요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 문제\n\n먼저 상황을 이해하기 위해 맥락을 제공해 드리겠습니다: 식료품 소매업체에서 다수의 상품을 다수의 가게에서 판매하고 있습니다. 각 가게 내의 각 상품에 대해 해당 상품의 가격 이력을 추적하고 있습니다. 이러한 데이터는 다음과 같이 표 형식으로 표시된 sell_price_history 테이블에 포함되어 있습니다:\n\n![테이블 이미지](/assets/img/2024-05-20-WritingSQLLikeaProAdvancedTechniquesShowcasedinaReal-LifeScenario_2.png)\n\n그러나 각 가게는 어떤 상품에 대해 프로모션을 생성할 수도 있습니다. 이 경우, 프로모션 값은 원래의 상품 가격을 대체합니다. promotion_history라는 두 번째 테이블에 해당 데이터가 포함되어 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-05-20-WritingSQLLikeaProAdvancedTechniquesShowcasedinaReal-LifeScenario_3.png\" />\n\n그 다음 문제는 다음과 같습니다. 이벤트 테이블 두 개를 하나의 테이블로 병합하여 각 기사에 대한 가격 이력 및 프로모션 효과를 제공하는 단일 테이블을 얻고 싶습니다.\n\n다시 말해, 우리가 원하는 기대 결과는 다음과 같아야 합니다:\n\n<img src=\"/assets/img/2024-05-20-WritingSQLLikeaProAdvancedTechniquesShowcasedinaReal-LifeScenario_4.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n더 시각적인 설명을 위해, 두 개의 이벤트 범위를 설명하는 표를 병합하려고 합니다.\n\n![table](/assets/img/2024-05-20-WritingSQLLikeaProAdvancedTechniquesShowcasedinaReal-LifeScenario_5.png)\n\n# (잘못된) 해결책\n\n조금 더 생동감 있게 만들기 위해 문제 해결 과정을 안내해 드리겠습니다. 각 표를 \"이벤트 타임라인\"의 형태로 분해하고 두 타임라인을 병합하여 공백을 채워야 한다는 생각이 들었습니다. 지금은 조금 흐릿해 보일 수 있지만, 문제 해결을 시작할 때도 그랬습니다. 걱정하지 마세요. 곧 더 명확해질 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n단계 1: 데이터 공유\n\n문제를 해결하는 방법에 대해 생각하기 전에 나는 두 테이블을 결합하고 shop_id와 article_id로 데이터를 그룹화했습니다. 아래와 같이:\n\n![image](/assets/img/2024-05-20-WritingSQLLikeaProAdvancedTechniquesShowcasedinaReal-LifeScenario_6.png)\n\nBigQuery에서 중첩 구조에 익숙하지 않은 분들을 위해 처음에는 약간 어색할 수 있지만, 데이터 구조가 어떻게 구성되어 있는지에 대한 상세한 설명을 제공하겠습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![SQL](/assets/img/2024-05-20-WritingSQLLikeaProAdvancedTechniquesShowcasedinaReal-LifeScenario_7.png)\n\n이 방식을 선호하는 이유는 여러 가지입니다:\n\n- 간단함: 각 기사의 데이터를 함께 두면 한 행을 기준으로 추론할 수 있습니다.\n- 성능: 미리 그룹화하면 수행할 모든 계산이 행 수준에서 이루어집니다. MapReduce에 익숙한 사람들에게는 Map 단계만 있을 뿐이며 Reduce도 Shuffle도 없습니다. 일반적으로 가장 리소스 집약적인 부분인 Shuffle이 없습니다.\n  BigQuery에서는 이것이 \"핵심\"은 아니지만, 쿼리 가격은 처리된 양이 아닌 읽은 데이터 양에만 기반합니다. 다른 엔진에서는 중요할 수 있으며, 저는 코드를 최적화하는 것을 좋아합니다.\n- 저장 효율성: shop_id 및 article_id가 각 줄마다 반복되지 않으므로 이 표현은 동일한 양의 정보를 위해 더 적은 저장 공간을 차지합니다. 이러한 것은 이와 같은 장난감 데이터세트에서 큰 의미가 없지만, 예상을 얻기 위해 말씀드리면, 두 개의 입력 테이블의 총 크기는 720b이지만 (동일한 정보를 포함하는) 출력 테이블의 크기는 412b에 불과했습니다. 이를 수십억 행으로 곱하면 가격 차이를 알 수 있을 것입니다.\n\n주요 단점은 대부분의 사람들이 이에 익숙하지 않아서 적절하게 쿼리하는 방법을 배우는 데 약간의 노력이 필요할 수 있으며, 많은 메타데이터 도구(데이터 카달로그, 데이터 차이 등)가 아직 중첩 구조를 잘 지원하지 않는다는 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그만 이야기하고 넘어가볼게요. 그 주제만으로도 전체 기사를 쓸 가치가 있는 정도니까, 이제 작업으로 돌아갈게요.\n\n단계 2: 두 개의 히스토리 병합하기\n\n다음으로, 두 개의 히스토리 테이블을 다음과 같이 합칩니다:\n\n![테이블 이미지](/assets/img/2024-05-20-WritingSQLLikeaProAdvancedTechniquesShowcasedinaReal-LifeScenario_8.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nStep 3: 비어 있는 칸 채우기\n\n마침내, 우리는 last_value 윈도우 함수를 사용하여 이벤트 주문에서 마지막 비어 있지 않은 값을 유지하고, 혹시 NULL을 채우는 데 사용합니다.\n\n![image](/assets/img/2024-05-20-WritingSQLLikeaProAdvancedTechniquesShowcasedinaReal-LifeScenario_9.png)\n\n이 결과는 우리가 찾고 있는 결과처럼 보이지만, 똑똑한 독자라면 이미 이것이 실제로 잘못되었다는 것을 발견했을 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n왜 이 작업이 작동하지 않는지:\n\n프로모션들이 중단 없이 계속됐다면 이 작업이 잘 작동했을 겁니다. 그러나 우리의 입력 데이터를 더 자세히 살펴보면 이렇게 되지 않았음을 알 수 있습니다. 첫 번째와 두 번째 프로모션 사이에 중단이 있습니다. 이 중단은 이전 스크린샷에서는 보이지 않습니다. 파란색으로 강조된 줄에서 확인할 수 있습니다.\n\n![Screenshot](/assets/img/2024-05-20-WritingSQLLikeaProAdvancedTechniquesShowcasedinaReal-LifeScenario_10.png)\n\n# 올바른 해결책\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제, 이전 (잘못된) 솔루션이 어떻게 수정될 수 있는지 보겠습니다. 무엇이 일어나는지에 대한 더 자세한 설명이 포함되어 있습니다.\n\n단계 1: 데이터 공동 배치 [수정할 내용 없음]\n\n단계 1은 준비 단계였습니다. 그대로 유지할 수 있습니다.\n\n단계 2: 날짜 범위를 타임라인으로 변환하고 병합하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리가 두 개의 타임라인을 병합하는 직감은 좋았지만, 날짜 범위가 연속되지 않을 수 있다는 사실을 놓치고 있었어요. 이 문제를 해결하기 위해 우리가 먼저 이룰 첫 번째 단계는 \"시작일부터 종료일까지\"의 날짜 범위로 이루어진 \"히스토리\"를 정보의 손실 없이 단순히 이벤트만 있는 이벤트 타임라인으로 변환하는 것이에요.\n\n다음과 같이 스키매틱하게 보이겠죠:\n\n![이미지](/assets/img/2024-05-20-WritingSQLLikeaProAdvancedTechniquesShowcasedinaReal-LifeScenario_11.png)\n\n여기서 \"누락된\" 값들은 마법의 숫자인 -1로 표시되었어요. 이것은 3단계에서 윈도우 함수인 last_value(… ignore nulls)를 사용할 때 NULL과 같은 방식으로 처리하지 않기를 원하기 때문이에요. 아마도 이것은 코드 스멜일지 모르겠지만, 이 기사의 단순성을 위해 이대로 유지할 거에요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 작업이 완료되면 두 개의 타임라인을 다음과 같이 UNION과 함께 병합할 것입니다:\n\n![image](/assets/img/2024-05-20-WritingSQLLikeaProAdvancedTechniquesShowcasedinaReal-LifeScenario_12.png)\n\n그러면 코드는 어떻게 되는 걸까요? 일단 프로모션에만 초점을 맞춰 봅시다. 첫 번째 단계는 다음 이벤트의 \"start_datetime\"을 검색하는 것입니다. 이것은 불연속성이 언제 있는지 감지하는 데 도움이 될 것입니다:\n\n```js\nSELECT\n  ...\n  ARRAY(\n    SELECT AS STRUCT\n      *,\n      LAG(start_datetime) OVER (ORDER BY start_datetime DESC) as next_event_datetime\n    FROM UNNEST(promotion_history)\n    ORDER BY start_datetime\n  ) as promotion_history,\n  ...\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n두 번째 단계는 이렇게 비연속성이 발생할 때마다 새 이벤트를 도입하는 것으로 구성되어 있어요:\n\n```js\nSELECT\n  ...\n  ARRAY (\n    SELECT AS STRUCT\n      promotion_value,\n      start_datetime,\n    FROM UNNEST(promotion_history)\n    UNION ALL\n    SELECT AS STRUCT\n      -1 as promotion_value,\n      end_datetime,\n    FROM UNNEST(promotion_history)\n    WHERE end_datetime < next_event_datetime OR next_event_datetime IS NULL\n  ) as events\n  ...\n```\n\n여일은 이전에 누락된 \"종료 이벤트\"를 다시 도입하는 부분입니다:\n\n<img src=\"/assets/img/2024-05-20-WritingSQLLikeaProAdvancedTechniquesShowcasedinaReal-LifeScenario_13.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n모든 것을 다시 합치면 다음과 같은 쿼리가 나옵니다:\n\n![Query](/assets/img/2024-05-20-WritingSQLLikeaProAdvancedTechniquesShowcasedinaReal-LifeScenario_14.png)\n\n단계 3: 공백 채우기 + 매직 값 대체\n\n이제 이 작업이 완료되었으므로, 단계 3에서 이전 쿼리를 사용하여 우리가 원하는 결과와 거의 비슷한 결과를 얻을 수 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nlast_value(… ignore nulls)라는 창 함수를 사용하면 빈 칸을 채울 수 있고, lead라는 창 함수를 사용하여 end_dates를 검색하여 date ranges를 다시 형성할 수 있습니다.\n\n이제 해야 할 일은 매직 값인 -1과 \"\"을 제거하기 위해 데이터를 정리하는 것 뿐입니다:\n\n![이미지](/assets/img/2024-05-20-WritingSQLLikeaProAdvancedTechniquesShowcasedinaReal-LifeScenario_15.png)\n\nprice_with_promotion_included를 계산하는 최종 쿼리를 실행하고 결과를 평평하게 만들기 위해 마지막으로 unnest를 수행합니다(shop_id 및 article_id가 모든 행마다 반복되어 나타남).\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그게 다야, 끝났어!\n\n# 결론\n\n우리는 우리가 원한 것을 4 또는 5 단계로 계산하는 데 성공했어요. 처음에는 간단해 보이지만 SQL로 하는 것이 꽤 까다로운 것 중 하나라고 생각해요. 이런 문제는 순수 SQL로 로직을 작성하는 것 대비 사용자 정의 함수(UDF)을 다른 언어(Python, Scala, Javascript 또는 무엇이든)로 작성하는 걸 고려해볼만한 고급 변환의 예시에요. UDF는 코드를 보다 일반적이고 안전하게 만든다는 장점이 있지만(단위 테스트로), 순수 SQL 대비 효율성이 떨어지며 더 비용이 많이 듭니다.\n\n연습으로, 만약 실습을 원한다면, 이 연습을 다음 변형 중 하나로 다시 써보는 것을 추천해요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 이 값을 마술 값으로 사용하지 않고 다시 작성해보세요.\n  (힌트: \"ON\" 또는 \"OFF\" 값을 취할 수 있는 event_status 열을 추가하십시오.)\n- ARRAYS 또는 STRUCT를 사용하지 않고 다시 작성해보세요.\n  (힌트: 이것은 충분히 가능하지만, 창은 추가적인 \"PARTITION BY shop_id, article_id\"를 필요로 할 수 있습니다.)\n- 선호하는 dbt와 유사한 도구를 사용하여 다시 작성하십시오.\n  (이 게시물을 대부분의 사람들이 이해할 수 있도록 dbt를 사용하지 않았습니다.)\n- 완전히 일반적인 방식으로 작성하려고 해보세요: 쿼리는 입력 테이블의 열 수에 관계없이 작동해야 하며, 쿼리를 업데이트하지 않고 새로운 열을 입력 테이블에 추가해도 계속 작동해야 합니다.\n  (힌트: 순수 SQL에서 이것이 가능한지 확신하지는 못하지만 제가 시도해본 결과 BigQuery는 NULL을 복잡한 유형으로 자동으로 캐스팅하지 못하는 것으로 나타났습니다. 그러나 bigquery-dataframes 또는 bigquery-frames로 이 작업을 수행하는 것은 멋진 도전이 될 수 있습니다.)\n- 데이터프레임을 사용하면 최종적으로 여러 히스토리 테이블에서 자동으로 작동하는 완전히 일반적인 변환을 만드는 것도 가능할 것입니다.\n\n마지막으로, 배열을 다루는 방법에 대해 더 알고 싶다면 BigQuery 문서의 멋진 페이지를 참고하고, 그 주제에 대해 더 많은 기사를 보고 싶다면 댓글을 남겨주시면 감사하겠습니다.\n\n오늘은 여기까지입니다. 읽어 주셔서 감사합니다! 이 글을 쓰는 데 즐거움을 느끼신 만큼 즐겁게 읽으셨기를 바랍니다.\n\n이 글에서 사용된 쿼리 전체(CTE로 다시 작성한 것)와 설명 그래프가 함께 제공됩니다. 코드 및 데이터 샘플은 여기에서 확인하실 수 있습니다. 즐겁게 ;-)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 링크\n\n이 기사에서 공유된 모든 링크가 여기 있습니다:\n\n- python-bigquery-dataframes: BigQuery에서 실행되는 Python 기반 DataFrames의 Google 공식 프로젝트입니다.\n- bigquery-frames: BigQuery에서 실행되는 Python 기반 DataFrames의 제 개인 프로젝트입니다.\n- Google BigQuery 문서: 배열 작업.\n- 해당 기사 코드가 있는 Git gist.\n","ogImage":{"url":"/assets/img/2024-05-20-WritingSQLLikeaProAdvancedTechniquesShowcasedinaReal-LifeScenario_0.png"},"coverImage":"/assets/img/2024-05-20-WritingSQLLikeaProAdvancedTechniquesShowcasedinaReal-LifeScenario_0.png","tag":["Tech"],"readingTime":13},{"title":"MySQL에서 CHAR vs VARCHAR 이해하기 포괄적인 안내","description":"","date":"2024-05-20 19:01","slug":"2024-05-20-UnderstandingCHARvsVARCHARinMySQLAComprehensiveGuide","content":"\n![Understanding CHAR vs VARCHAR in MySQL: A Comprehensive Guide](/assets/img/2024-05-20-UnderstandingCHARvsVARCHARinMySQLAComprehensiveGuide_0.png)\n\n데이터베이스를 디자인할 때, 마주치게 될 중요한 결정 중 하나는 열에 적합한 데이터 유형을 선택하는 것입니다. 텍스트 데이터의 경우, MySQL은 두 가지 주요 옵션인 CHAR과 VARCHAR을 제공합니다. 두 유형 모두 문자열을 저장하는 데 사용되지만, 저장 및 성능에 상당한 영향을 미칠 수 있는 독특한 특성을 갖고 있습니다. 이 글은 CHAR과 VARCHAR 간의 차이점을 살펴봅니다.\n\n# 1- CHAR과 VARCHAR은 무엇인가요?\n\n## CHAR 데이터 유형\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nCHAR은 \"character\"을 나타내며 고정 길이의 문자열을 저장하는 데 사용됩니다. CHAR 데이터 유형을 사용하여 열을 정의할 때 문자열의 고정된 길이를 지정합니다. 실제 문자열 길이에 관계없이 MySQL은 항상 지정된 전체 길이를 사용합니다.\n\n```js\nCREATE TABLE example (\n    char_col CHAR(10)\n);\n```\n\n## VARCHAR 데이터 유형\n\n```js\nCREATE TABLE example (\n    varchar_col VARCHAR(10)\n);\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 2- 저장소 차이점\n\n## CHAR 저장\n\n- 고정 길이: CHAR 열은 항상 지정된 길이를 사용합니다.\n- 패딩: 더 짧은 문자열은 공백으로 채워집니다.\n- 고정 길이 데이터에 효율적: 길이가 항상 일정한 데이터를 저장하는 데 이상적입니다 (예: 국가 코드, 고정 길이 코드).\n\n## VARCHAR 저장\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 가변 길이: VARCHAR 열은 실제 문자열 길이에 필요한 만큼의 공간만 사용합니다.\n- 길이 바이트: 문자열의 길이를 저장하기 위해 추가적으로 1 또는 2바이트를 사용합니다(255까지의 길이에는 1바이트, 65,535까지의 길이에는 2바이트).\n\n## 3- 성능 고려사항\n\n## CHAR 성능\n\n- 빠른 액세스: CHAR 열은 고정 길이를 갖기 때문에 데이터에 빠르게 액세스할 수 있습니다.\n- 간단한 패딩: 공백으로 패딩을 하면 몇 가지 작업을 간단하게 할 수 있지만, 후행 공백을 제거하기 위해 추가 처리가 필요할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## VARCHAR 성능\n\n- 공간 효율성: VARCHAR 열은 가변 길이 데이터에 대해 더 공간 효율적이어서 I/O 작업이 감소하므로 성능이 향상될 수 있습니다.\n- 단편화: 시간이 지남에 따라 VARCHAR 열의 업데이트는 단편화로 이어질 수 있어 성능이 저하될 수 있습니다.\n\n가변 길이 데이터에 적합: 길이가 다양한 데이터(e.g., 이름, 주소)를 저장하는 데 적합합니다.\n\n# 4- 일반적으로\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n'value' 값을 'mysql'로 저장하는 데는 VARCHAR(5) 또는 VARCHAR(200) 열에 저장하는 경우에 관계없이 동일한 공간이 사용됩니다. 그러나 더 짧은 VARCHAR 열을 선택하는 것이 주목할 만한 장점을 제공합니다. VARCHAR(200)과 같이 더 큰 VARCHAR 열의 경우, MySQL은 내부 값 저장을 위해 고정 크기의 메모리 청크를 할당하는 경향이 있어 메모리를 과다 소비할 위험이 있습니다. 이 메모리 팽창은 정렬이나 인메모리 임시 테이블 관련 작업 및 온 디스크 임시 테이블을 사용하는 파일 정렬 중에 특히 문제가 될 수 있습니다. 따라서 필요한 공간만 할당하는 것이 현명합니다.\n\n또한 VARCHAR(5) 대신 CHAR(5)을 사용할 때, 인덱싱에 대한 잠재적 이점을 강조할 가치가 있습니다. CHAR 열의 고정 길이 특성은 가변 길이 VARCHAR 열보다 빠른 인덱스 조회를 용이하게 합니다. 이 장점은 인덱스 크기가 더 작고 예측 가능하여 전반적인 쿼리 성능을 향상시키는 시나리오에서 특히 두드러집니다.\n\n다음 기사에서는 열거형에 대해 깊이 논의할 예정입니다.\n","ogImage":{"url":"/assets/img/2024-05-20-UnderstandingCHARvsVARCHARinMySQLAComprehensiveGuide_0.png"},"coverImage":"/assets/img/2024-05-20-UnderstandingCHARvsVARCHARinMySQLAComprehensiveGuide_0.png","tag":["Tech"],"readingTime":4},{"title":"온라인으로 SQL 연습할 수 있는 최고의 9개 웹사이트","description":"","date":"2024-05-20 18:59","slug":"2024-05-20-TheBest9WebsitestoPracticeSQLOnline","content":"\n![Best Platforms to Practice SQL](/assets/img/2024-05-20-TheBest9WebsitestoPracticeSQLOnline_0.png)\n\n이 기사에서는 SQL을 연습할 수 있는 최상의 9개 웹 사이트를 탐색하여 데이터, 예제 및 안내가 풍부한 플랫폼을 제공하여 쉽게 사용할 수 있도록 도와드리겠습니다.\n\n아시다시피 SQL 또는 구조화된 질의 언어는 데이터베이스와 상호 작용하기 위한 프로그래밍 언어입니다. 대부분의 데이터베이스가 SQL을 지원하는 표준 방법이며, SQL은 데이터 분석가, 데이터 과학자 및 소프트웨어 엔지니어 등 기술 산업에서 가장 필요로 하는 기술 중 하나입니다.\n\n# SQL 연습하기에 최적인 플랫폼\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nSQL 연습을 하고 싶다면 여러 훌륭한 플랫폼들이 있습니다. 여기 몇 가지 추천 플랫폼이 있어요:\n\n# SQL 연습의 이유\n\n플랫폼을 살펴보기 전에, SQL 연습의 이점을 이해하는 것이 중요합니다:\n\n- 기술 발전: SQL 숙련은 데이터 관련 직업에서 중요한 기본 기술입니다. SQL을 연습하면 데이터를 효과적으로 관리하고 분석할 수 있는 능력이 향상됩니다.\n- 문제 해결: SQL을 사용하면 데이터를 추출, 변환 및 조작할 수 있습니다. 정기적인 연습은 실제 데이터 문제에 대처하는 능력을 키우며 문제 해결 능력을 갖추게 해줍니다.\n- 직업 발전: 다양한 직업 분야에서 SQL 전문 지식이 높은 수요를 받습니다. 데이터 분석가, 웹 개발자 또는 데이터베이스 관리자가 되고자 한다면, SQL 숙련은 경쟁 우위를 제공할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# SQL 실습을 위한 최고의 플랫폼\n\nSQL 실습을 도와드리기 위해, 다양한 기술 수준을 고려한 SQL 실습을 위한 최고의 플랫폼 목록을 정리해보았어요:\n\n## 1. SQLZoo (초보자를 위한 친구)\n\n- 웹사이트: SQLZoo\n- 기술 수준: 초보부터 중급까지\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nSQLZoo는 초보자에게 이상적인 시작점이에요. 상호작용하는 SQL 튜토리얼과 연습 문제가 구조화되어 제공돼요. 웹 브라우저에서 SQL 쿼리를 직접 연습할 수 있어요. 다양한 SQL 주제를 다루는 튜토리얼을 통해 자신의 속도에 맞춰 발전할 수 있어요.\n\n예시: SQLZoo는 'WORLD 데이터베이스에서 SELECT하기'라는 초보자용 튜토리얼을 제공해요. 이를 통해 전 세계 국가에 대한 데이터를 쿼리하여 기본적인 SQL SELECT 문을 연습할 수 있어요.\n\n```js\n-- 예시 SQL 쿼리\nSELECT name, price\nFROM company\nWHERE type = 'mobile';\n```\n\n멋진 기능들:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 대화식 학습: 읽기만 하는 것이 아니라 실제로 하는 과정을 통해 SQL을 배울 수 있습니다.\n- 초급부터 고급까지 가르침: SQL을 간단한 것부터 더 복잡한 것까지 다룹니다.\n\n장점:\n\n- 초보자에게 좋음: SQL에 처음이라면 여기서 시작하기 좋습니다.\n- 즉각적인 피드백: 제대로 하고 있는지 틀리고 있는지 알려줍니다.\n- 다양하게 다룸: SQL에 관련된 많은 것들을 배울 수 있습니다.\n\n단점:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 실제 데이터베이스 사용 안 함: 실제 데이터베이스를 사용하지 않기 때문에 실제 업무를 하는 것과는 다르다.\n- 실용성이 떨어짐: SQL이 실제 세계에서 어떻게 사용되는지를 느끼지 못할 수 있습니다.\n\n## 2. 코드카데미 (초보자 친화적)\n\n- 웹사이트: 코드카데미 SQL 코스\n- 기술 수준: 초보자\n\n코드카데미는 초보자를 위한 대화식 SQL 코스를 제공합니다. 이 코스에는 즉각적인 피드백이 제공되는 실습 코딩 문제가 포함되어 있어 SQL을 단계별로 쉽게 배우고 연습할 수 있습니다. 여기 초보자를 위한 연습문제의 샘플 코드가 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n예시: 데이터베이스에서 특정 정보를 검색하여 SQL을 연습할 수 있습니다. 예를 들어, 테이블인 employees에서 데이터를 추출하는 방법을 배울 수 있습니다:\n\n```js\n-- 예시 SQL 쿼리\nSELECT fst_name, lst_name, title\nFROM empls\nWHERE dept = 'sales';\n```\n\n멋진 기능들:\n\n- 상호작용적인 연습: 사용하기 편리한 온라인 환경에서 SQL을 연습할 수 있습니다.\n- 진행 상황 추적: 당신의 진행 상황을 감시합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n장점:\n\n- 직접 해보며 배우는 학습 방식: 듣기만 하는 것이 아니라 경험을 통해 배울 수 있습니다.\n- 쉽게 따라갈 수 있는 구성: 수업이 쉽게 따라갈 수 있는 방식으로 구성되어 있습니다.\n- 즐겁게 사용할 수 있음: 학습을 즐겁게 만들기 위해 디자인되었습니다.\n\n단점:\n\n- 초보자를 위한 것이라 어려운 내용은 없음: 이미 SQL을 잘 알고 있는 경우에는 너무 기본적일 수 있습니다.\n- 유료 기능: 일부 고급 기능은 유료 구독이 필요할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 3. SQLFiddle (중급)\n\n- 웹사이트: SQLFiddle\n- 난이도: 중급\n\nSQLFiddle은 다양한 데이터베이스 시스템에서 SQL 쿼리를 작성하고 실행할 수 있는 웹 기반 도구입니다. 이 플랫폼은 실제 세계에서 SQL을 연습하기에 완벽한 도구입니다. 다음은 샘플 사용 사례입니다:\n\n예시: SQLFiddle을 사용하여 MySQL, PostgreSQL 또는 SQLite와 같은 다른 SQL 데이터베이스 시스템을 실험해볼 수 있습니다. 예를 들어, 테이블을 생성하고 데이터를 삽입하는 것과 같은 작업을 할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n-- 예제 SQL 쿼리\nCREATE TABLE studs (\nid INT AUTO_INCREMENT,\nname VARCHAR(50),\nage INT\n);\n\nINSERT INTO studs (name, age)\nVALUES ('Dave', 25), ('Jane', 28), ('Gill', 22);\n\n멋진 기능들:\n\n- 다양한 시스템에서 테스트: MySQL 및 PostgreSQL과 같은 다양한 시스템에서 SQL을 연습할 수 있습니다.\n- 현실적인 느낌: 마치 실제 데이터베이스와 놀고 있는 것 같습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n장점:\n\n- 실제 시스템에서 배우기: 다양한 데이터베이스에서 SQL 작동 방식을 알 수 있습니다.\n- 작업 공유: SQL을 다른 사람들에게 보여주고 도움 요청할 수 있습니다.\n- 즉각적인 결과 확인: 쿼리를 실행한 후 빠르게 결과를 확인할 수 있습니다.\n\n단점:\n\n- 학습 자료 부족: 기초부터 배우기보다는 실습에 더 적합합니다.\n- 초보자에게는 좋지 않음: SQL에 초심자라면 어려울 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 4. 해커랭크 (중급에서 고급)\n\n- 웹사이트: 해커랭크 SQL 도전과제\n- 난이도: 중급에서 고급\n\n해커랭크는 중급자 및 고급 학습자들에 적합한 SQL 도전과제 및 대회 시리즈를 제공합니다. 도전과제는 다양한 SQL 주제를 다루며, 여러분은 여러분의 기술을 자랑할 수 있는 뱃지를 얻을 수 있습니다. 좀 더 고급 예제를 살펴보겠습니다:\n\n예시: 해커랭크 도전과제에는 특정 부서의 직원들의 평균 급여를 계산하는 등 복잡한 SQL 쿼리가 자주 포함됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n-- 예시 SQL 쿼리\nSELECT department, AVG(salary) as average_salary\nFROM employees\nGROUP BY department\nHAVING AVG(salary) > 50000;\n```\n\n멋진 기능:\n\n- 도전과 대회: SQL 문제가 있는 게임과 비슷합니다.\n- 포인트 획득: 포인트를 획득하고 실력을 자랑할 수 있습니다.\n\n장점:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 재미있는 학습: 게임처럼 재미있고 계속 진행할 수 있습니다.\n- 다른 사람과 대화하기: 다른 사람과 대화를 나누고 질문을 하며 배울 수 있습니다.\n- 모든 수준을 위한: 모든 사람을 위한 쉬운 것부터 어려운 도전까지 있습니다.\n\n단점:\n\n- 어려운 도전: 어떤 도전은 정말 어려울 수 있으므로 새로운 사람은 곤경에 처할 수 있습니다.\n- 튜토리얼 부족: 문제 해결에 중점을 두어 SQL을 처음부터 배우는 데는 도움이 부족합니다.\n\n## 5. LeetCode (고급)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 웹사이트: LeetCode SQL 문제\n- 난이도: 고급\n\nLeetCode은 SQL 문제를 포함한 코딩 과제로 유명합니다. 이러한 과제는 SQL 기술을 고급 수준으로 향상시키고자 하는 사람들에게 안성맞춤입니다. 이 플랫폼은 커뮤니티 토론과 솔루션을 제공하기도 합니다. 아래는 고급 SQL 과제의 예시입니다:\n\n예시: LeetCode 과제에는 데이터 조작과 집계와 같은 복잡한 작업이 포함될 수 있습니다. 예를 들어 데이터베이스에서 두 번째로 높은 급여를 찾는 것과 같은 작업이 있을 수 있습니다.\n\n```js\n-- 예시 SQL 쿼리\nSELECT DISTINCT Salary as SecondHighestSalary\nFROM Employee\nORDER BY Salary DESC\nLIMIT 1 OFFSET 1;\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n멋진 기능들:\n\n- SQL 퍼즐: SQL로 퍼즐을 푸는 것처럼 재미있게 공부할 수 있어요.\n- 다른 사람들로부터 배우기: 다른 사람들이 문제를 어떻게 해결하는지 살펴보세요.\n\n장점:\n\n- 고급 내용: SQL을 정말 잘하고 싶다면 좋은 자료에요.\n- 사람들과 대화: 다른 사람들이 하는 것을 보고 배울 수 있어요.\n- 면접 준비에 좋아요: 일부 질문들은 취업 면접 준비에 도움이 됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n**단점:**\n\n- 초보자에게는 어려울 수 있어요: SQL을 처음 시작하는 경우 정말 어려울 수 있어요.\n- 학습량이 많지 않아요: 문제 해결에 초점을 맞추는데, 단계별 학습은 아닙니다.\n\n## 6. W3Schools SQL 튜토리얼 (초보자 친화적)\n\n- 웹사이트: W3Schools SQL 튜토리얼\n- 기술 수준: 초보자\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nW3Schools는 포괄적이고 초보자 친화적인 SQL 튜토리얼을 제공합니다. 상호작용하는 예제와 연습 문제를 포함하여 SQL을 체계적으로 연습할 수 있습니다. 이 튜토리얼은 다양한 SQL 주제를 다루므로 초보자에게 유용한 자료입니다. 간단한 쿼리의 예시를 살펴보겠습니다:\n\n예시: 튜토리얼에서 테이블에서 데이터를 검색하는 방법을 학습하여 SQL을 연습할 수 있습니다. 예를 들어 \"customers\"라는 테이블에서 데이터를 선택하는 방법을 배울 수 있습니다.\n\n```js\n-- 예시 SQL 쿼리\nSELECT * FROM customers;\n```\n\n멋진 기능:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 실제 데이터베이스: 당신은 직업처럼 자신만의 데이터베이스를 설정합니다.\n- 경험을 통한 학습: 당신은 실제 데이터베이스를 통해 연습하면서 배웁니다.\n\n장점:\n\n- 실전 실습: 실제 직업에서 작업하는 것과 가장 유사합니다.\n- 시스템 선택의 자유: MySQL 또는 PostgreSQL과 같은 데이터베이스를 선택할 수 있습니다.\n- 누구에게나 좋은 선택: SQL을 처음 시작하거나 이미 알고있는 사람이라면 이 기능을 사용할 수 있습니다.\n\n단점:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 설치하기 어려울 수 있어요: 새로 오신 분들에게 진짜 데이터베이스를 설정하는 것은 조금 까다로울 수 있어요.\n- 단계별 학습이 없어요: 연습에 초점을 맞춘 내용이라서 자신의 방식을 찾아야 해요.\n\n## 7. SQLBolt (대화식)\n\n- 웹사이트: SQLBolt\n- 기술 수준: 중급\n\n이전에 언급했던 SQLBolt는 초심자뿐만 아니라 중급자와 고급자를 위한 SQL 자습서도 제공해요. 진행하면서 JOIN 작업과 서브쿼리를 포함한 더 복잡한 연습으로 넘어갈 수 있어요. 중급 수준 쿼리의 예시는 다음과 같아요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n예시: 테이블에서 SQL JOIN 작업을 수행하는 방법을 배워 SQL을 연습할 수 있어요. 예를 들어, \"주문\"과 \"고객\"이라는 두 관련 테이블에서 데이터를 검색할 수 있어요.\n\n```js\n-- 예제 SQL 쿼리\nSELECT customers.name, orders.product\nFROM customers\nJOIN orders ON customers.customer_id = orders.customer_id;\n```\n\n멋진 기능들:\n\n- 다양한 레슨: SQL에 대해 많은 것을 배울 수 있어요.\n- 실습해보기: 실제 코딩 편집기에서 연습하는 것과 같아요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n장점:\n\n- 많은 것을 배울 수 있어요: 기초부터 고급 내용까지 배울 수 있어요.\n- 배우는 대로 실습할 수 있어요: 배우는 곳에서 바로 실습하기 쉬워요.\n- 체계적이고 간단해요: 수업이 따라가기 쉽고 명확해요.\n\n단점:\n\n- 실제 데이터베이스가 아니에요: 실제 데이터베이스와는 많이 다르게 실습하지 않아요.\n- 배워야 할 것이 많아요: 몇몇 사람은 모든 수업이 너무 많이 느껴질 수도 있어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 8. Mode Analytics (Advanced)\n\n- Website: Mode Analytics\n- Skill Level: Advanced\n\nMode Analytics는 데이터 분석과 탐색에 중점을 둔 심화 SQL 튜토리얼을 제공합니다. 깊이 있는 데이터 분석과 시각화를 위해 SQL을 활용하고 싶은 사용자들을 위해 설계되었습니다. 복잡한 쿼리와 데이터 조작을 연습할 수 있습니다. 다음은 심화 SQL 쿼리의 예시입니다:\n\n예시: SQL을 활용하여 시계열 데이터를 플로팅하거나 대화형 대시보드를 생성하는 등 고급 데이터 시각화를 연습할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n-- 데이터 시각화를 위한 예시 SQL 쿼리\nSELECT date, revenue\nFROM sales_data\nGROUP BY date\nORDER BY date;\n```\n\n멋진 기능:\n\n- 데이터 분석에 초점: 데이터 분석을 위해 SQL을 사용하는 것이 핵심입니다.\n- 데이터 시각화: 데이터를 차트와 대시보드로 변환할 수 있습니다.\n\n장점:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 고급 데이터 분석: 데이터를 깊이 분석하는 방법을 배우고 싶다면 좋은 선택입니다.\n- 유용한 기술: 실제 세계 의사결정에 데이터를 활용하는 방법을 배울 수 있습니다.\n- 분석가에게 유용: 데이터를 다루고 싶어하는 사람들에게 이 코스가 좋습니다.\n\n단점:\n\n- 초보자에게는 부적합: 시작 단계라면 너무 어려울 수 있습니다.\n- 모든 SQL에 적합하지 않음: 특히 데이터베이스에 대한 모든 SQL 항목을 배우기에는 부적합합니다.\n\n## 9. SQL Pad (중급에서 고급)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 웹사이트: SqlPad\n- 기술 수준: 중급에서 고급\n\nStrataScratch는 방대한 라이브러리를 보유한 대화식 SQL 플랫폼을 제공합니다. 실제 세계 SQL 도전 과제를 다수 보유하고 있어 SQL 실력을 향상시키고자 하는 사용자들에게 적합합니다. 다양한 영역에서 실제 데이터 문제에 대처하며 SQL을 연습할 수 있습니다. 아래는 고급 도전 과제의 예시입니다:\n\n예시: 높은 수준의 도전을 통해 쿼리 성능 최적화나 데이터셋 분석을 통해 실행 가능한 통찰을 얻을 수 있습니다.\n\n```js\n-- 데이터 분석을 위한 예시 SQL 쿼리\nSELECT product_category, AVG(revenue) as avg_revenue\nFROM sales_data\nGROUP BY product_category\nHAVING AVG(revenue) > 1000\nORDER BY avg_revenue DESC;\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n멋진 기능:\n\n- 현실적인 문제: 여러 직업의 실제 데이터 문제를 해결할 수 있습니다.\n- 실습하기로 배우기: SQL을 실제로 사용하면서 능숙해질 수 있습니다.\n\n장점:\n\n- 현실적인 문제 해결: 데이터와 관련된 실제 문제를 해결하는 방법을 배울 수 있습니다.\n- 다양한 문제 유형: 다양한 유형의 연습 문제가 많이 제공됩니다.\n- 업무에 적합: 데이터 작업을 원한다면, 이는 좋은 연습이 될 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n단점:\n\n- 초보자용이 아님: SQL을 막 배우기 시작하는 경우, 너무 어려울 수 있습니다.\n- 유료 콘텐츠도 존재: 모든 기능을 사용하려면 비용을 지불해야 할 수도 있습니다.\n\n기억하세요, 플랫폼의 선택은 당신의 실력 수준과 특정 SQL 학습 목표에 달려 있습니다. 이 플랫폼 각각은 SQL 학습과 연습에 대한 독특한 접근 방식을 제공하므로, 당신의 요구사항과 선호도에 가장 잘 맞는 것을 찾아보세요. 즐거운 SQL 연습하세요!\n\n## 10. 당신의 로컬 데이터베이스 (실용적인 방법)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 기술 수준: 모든 수준\n\n실제 경험을 위해 MySQL, PostgreSQL 또는 SQLite와 같은 소프트웨어를 사용하여 로컬 데이터베이스를 설정해 보는 것을 고려해보세요. 이 실전 실습을 통해 데이터베이스를 생성하고 데이터를 로드하고 쿼리를 실행할 수 있습니다. 다음은 실용적인 예시입니다:\n\n예시: 로컬 데이터베이스에서 간단한 테이블을 만들고 데이터를 삽입할 수 있습니다:\n\n```js\n-- 예시 SQL 쿼리\nCREATE TABLE products (\n    product_id INT PRIMARY KEY,\n    product_name VARCHAR(50),\n    price DECIMAL(10, 2)\n);\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```sql\nINSERT INTO products (product_id, product_name, price)\nVALUES (1, '위젯', 19.99), (2, '가젯', 29.99), (3, '두다드', 9.99);\n```\n\n# SQL 실습 플랫폼 사용 방법\n\nSQL 프로그래밍 기술을 시험해 볼 수 있는 가장 좋은 방법은 기초부터 시작해 점차 어려운 연습 문제로 나아가는 것입니다. 연습할 때 플랫폼이 제공하는 피드백에 주의를 기울이는 것이 중요합니다. 이 피드백은 강점과 약점을 판별하는 데 도움을 주고, 실수로부터 배울 수 있도록 도와줍니다.\n\nSQL 실습을 위한 몇 가지 추가 팁은 다음과 같습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 정기적으로 연습하세요. 더 많이 연습할수록 SQL을 잘 할 수 있게 될 것입니다.\n- 다양한 자원을 활용하세요. 다양한 SQL 연습 자료가 있으니 여러 가지를 시도해보는 것을 두려워하지 마세요.\n- 스스로를 도전하세요. 실수를 해도 두려워하지 마세요. 더 어려운 연습문제에 도전할수록 SQL을 더 잘하게 될 것입니다.\n- 도움을 받으세요. 특정 연습문제에 막혔다면 친구, 멘토, 또는 온라인 포럼에서 도움을 요청하는 것을 두려워하지 마세요.\n\n# 결론\n\nSQL 연습은 여러분의 경력에 가치 있는 투자이며, 이 튜토리얼에서 소개된 플랫폼들은 다양한 난이도에 맞춰 제공됩니다. 초보자 친화적인 옵션부터 시작하여 고급 도전까지 진행하고, 실제 프로젝트에 스킬을 적용하는 것을 잊지 마세요. 연습을 통해 자신감을 쌓고 SQL 사용자로 능숙해질 것입니다. 즐거운 쿼리하세요!\n","ogImage":{"url":"/assets/img/2024-05-20-TheBest9WebsitestoPracticeSQLOnline_0.png"},"coverImage":"/assets/img/2024-05-20-TheBest9WebsitestoPracticeSQLOnline_0.png","tag":["Tech"],"readingTime":18},{"title":"모두 처리해야 해요  DuckDB가 데이터를 마스터하는 방법을 포켓몬 트레이너처럼 소개합니다","description":"","date":"2024-05-20 18:56","slug":"2024-05-20-GottaprocessemallDuckDBmastersyourdatalikeaPokmontrainer","content":"\n## DuckDB을 데이터 처리 도구로 사용하는 실용적인 예제\n\n- 소개\n- API 개요\n  - 포켓몬 가져오기\n  - 포켓몬 세부 정보 가져오기\n- 프로젝트 설정\n- 데모 1: 간단한 선택\n- 데모 2: API에서 JSON 읽기\n- 데모 3: Unnest\n- 데모 4: 세부 정보 가져오는 UDF\n- 데모 5: 목록 표현식\n- 데모 6: DuckDB를 Pandas로 변환하고 다시 변환하기\n- 데모 7: 데이터 유지 및 로드\n- 결론\n\n# 소개\n\n캉토 지방을 탐험하여 놀라운 생물을 포획하고 훈련하는 포켓몬 트레이너가 되는 꿈을 꾸어 본 적이 있나요? 90년대에 Game Boy에서 포켓몬 레드 버전과 포켓몬 블루 버전을 즐길 때, 제가 확실히 꾸었던 꿈입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n포켓몬 비디오 게임 시리즈가 시간이 지남에 따라 얼마나 인기 있어졌고 지금도 그랬는지 정말 놀라운 일이에요. 마치 비디오 게임 산업에서 떠오르는 별처럼 말이죠. 그 얘기를 하자면: DuckDB, 진행 중인 SQL 분석 엔진, 지난 몇 년간 데이터 엔지니어링 커뮤니티에서 떠오르는 별처럼 인기를 끌었어요.\n\n[이미지](/assets/img/2024-05-20-GottaprocessemallDuckDBmastersyourdatalikeaPokmontrainer_0.png)\n\n마치 포켓몬 트레이너가 전투를 위해 완벽한 팀을 선택하는 것처럼, 경험이 풍부한 데이터 엔지니어는 작업에 적합한 올바른 도구를 선택하는 중요성을 알아요. 본 문서를 통해 DuckDB가 여러분의 도구 상자에 완벽한 도구가 될 이유를 보여드리고 싶어요.\n\nDuckDB는 큰 데이터베이스와 매끄럽게 통합되어 인메모리 및 영속적 저장 솔루션 사이의 원활한 전환을 도와줘요. 마치 어떤 도전이든 쉽게 적응하는 다재다능한 포켓몬과 같죠. 작은 데이터 세트를 빠르게 분석해야 한다면? DuckDB는 여러분의 마초크, 쉽게 과업을 수행할 준비가 돼 있어요. 더 강력한 처리가 필요한 대규모 데이터 세트와 작업하고 있다면? DuckDB는 마샴으로 변신하여 과중한 분석을 위해 외부 데이터베이스에 매끄럽게 연결할 수 있어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nDuckDB를 설치하기 쉽고 휴대용이며 오픈 소스입니다. SQL 방언 측면에서 기능이 풍부하고 CSV, Parquet 및 JSON과 같은 다양한 형식을 기준으로 데이터를 가져오고 내보낼 수 있습니다. 또한 Pandas 데이터프레임과 원활하게 통합되어 데이터 조작 스크립트에서 강력한 데이터 조작 도구로 사용할 수 있습니다.\n\n다음 장에서는 DuckDB를 사용하여 Pokémon API를 활용해 데이터를 처리하는 방법을 예시로 살펴보며 강력한 기능을 보여줄 것입니다.\n\n![이미지](/assets/img/2024-05-20-GottaprocessemallDuckDBmastersyourdatalikeaPokmontrainer_1.png)\n\n## API 개요\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n포켓몬 API는 포켓몬 비디오 게임 시리즈와 관련된 JSON 데이터에 대한 RESTful API 인터페이스를 제공합니다. 이 API를 사용하면 포켓몬, 그들의 기술, 능력, 유형 등에 대한 정보를 소비할 수 있습니다.\n\n이 기사는 주로 DuckDB 기능에 초점을 맞춰야 하므로 일부 엔드포인트만 사용할 것입니다. 개요를 얻기 위해 curl과 jq를 사용하여 관련 엔드포인트를 탐색해 보겠습니다. jq를 잘 모르는 경우, 이것은 터미널에서 JSON을 필터링, 수정 또는 간단히 형식화하는 많은 기능을 가진 경량 CLI JSON 프로세서입니다. macOS를 사용하고 Homebrew를 사용 중이라면 brew install jq를 통해 jq를 설치할 수 있습니다.\n\n## 포켓몬 가져오기\n\n```js\ncurl -s https://pokeapi.co/api/v2/pokemon/ | jq .\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n{\n  \"count\": 1302,\n  \"next\": \"https://pokeapi.co/api/v2/pokemon/?offset=20&limit=20\",\n  \"previous\": null,\n  \"results\": [\n    {\n      \"name\": \"bulbasaur\",\n      \"url\": \"https://pokeapi.co/api/v2/pokemon/1/\"\n    },\n    {\n      \"name\": \"ivysaur\",\n      \"url\": \"https://pokeapi.co/api/v2/pokemon/2/\"\n    },\n    ...\n```\n\n![Gotta Process Em All: DuckDB masters your data like a Pokémon trainer](/assets/img/2024-05-20-GottaprocessemallDuckDBmastersyourdatalikeaPokmontrainer_2.png)\n\n## 포켓몬 세부 정보 가져오기\n\n```js\ncurl -s https://pokeapi.co/api/v2/pokemon/bulbasaur | jq .\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```json\n{\n  \"abilities\": [\n    {\n      \"ability\": {\n        \"name\": \"overgrow\",\n        \"url\": \"https://pokeapi.co/api/v2/ability/65/\"\n      },\n      \"is_hidden\": false,\n      \"slot\": 1\n    },\n    ...\n  ],\n  \"base_experience\": 64,\n  ...\n```\n\n![Screenshot](/assets/img/2024-05-20-GottaprocessemallDuckDBmastersyourdatalikeaPokmontrainer_3.png)\n\n# 프로젝트 설정\n\n새로운 Python 프로젝트를 만들기 시작합니다. 이를 위해 새 폴더를 만듭니다. 이 폴더 내에서 내장된 venv 모듈을 사용하여 가상 환경을 생성합니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nmkdir duckdb-pokemon\ncd duckdb-pokemon\npython -m venv .venv\nsource .venv/bin/activate\n```\n\n마지막 명령으로 가상 환경을 활성화했습니다. 이는 현재 터미널 세션에서는 시스템 전역 Python 대신 가상 Python을 사용한다는 의미입니다. 이것은 다음에 설치할 종속성을 프로젝트 내에서 격리시키려는 우리의 목적상 중요합니다. 다음 단계는 모든 요구 사항을 설치하는 것입니다:\n\n```js\npip install duckdb\npip install pandas\npip install requests\n```\n\n여기까지 준비가 되었습니다. 다음 장에서는 포켓몬 API를 활용한 DuckDB의 일부 기능을 살펴볼 것입니다. 이 코드를 프로젝트 내의 Python 파일로 복사하여 실행할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 데모 1: 간단한 선택\n\n첫 번째 데모는 시작하는 방법이 얼마나 간단한지 보여줍니다. DuckDB를 pip install duckdb로 설치한 후에는 직접 가져와서 SQL 문을 실행할 수 있습니다. 복잡한 데이터베이스 설정이나 다른 요구 사항이 없습니다. 광고대로, 이것은 빠른 내장형 분석용 데이터베이스입니다.\n\n```js\nimport duckdb\n\nduckdb.sql(\"SELECT 42\").show()\n```\n\n이 코드를 실행하면 예상한 출력인 하나의 열과 하나의 행이 포함된 값 42를 가진 테이블을 얻을 수 있습니다. 이는 삶, 우주, 그리고 모든 것에 대한 궁극적인 질문의 답입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n┌───────┐\n│  42   │\n│ int32 │\n├───────┤\n│    42 │\n└───────┘\n```\n\n# 데모 2: API로부터 JSON 읽기\n\n이제 상황이 급속하게 변화할 것이니, 포켓몬볼을 준비해두세요. 일반적으로 API에서 JSON 데이터를 가져올 때, requests.get을 시작으로 클라이언트 로직을 구현하여 데이터를 데이터베이스에로드하거나 Pandas와 같은 데이터 처리 프레임워크를 사용할 수 있습니다. 다음 예제는 당신을 확실히 놀라게 할 것입니다. 우리는 데이터를 가져와 SQL을 사용하여 직접 테이블로 만들 것입니다.\n\n```js\nimport duckdb\n\nduckdb.sql(\"\"\"\n    CREATE TABLE pokemon AS\n    SELECT *\n    FROM read_json_auto('https://pokeapi.co/api/v2/pokemon?limit=1000');\n\n    SELECT * FROM pokemon;\n\"\"\").show()\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nread_json_auto를 사용하면 JSON 데이터를로드하는 가장 간단한 방법을 사용할 수 있습니다. 이는 JSON 리더를 자동으로 구성하고 데이터에서 열 유형을 파생합니다.\n\n위의 코드는 API의 해당 응답에 따라 네 개의 열이 있는 테이블을 제공합니다. 즉: count, next, previous, results이며, results는 구조체의 목록이며 각 구조체는 이름과 URL이 포함된 포켓몬으로 구성됩니다.\n\n유연성은 DuckDB가 정말 빛나는 곳입니다. DuckDB는 여러분의 신속한 피카츄이며 JSON 데이터를로드하는 것은 단지 한 가지 예입니다. CSV 파일이나 심지어 하이브 파티셔닝이 있는 Parquet 파일에서 데이터를 읽을 수도 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nSELECT *\nFROM read_parquet(\"some_table/*/*/*.parquet\", hive_partitioning = true);\n```\n\n또는 Pandas 데이터프레임에서 데이터를 직접 읽어보세요:\n\n```js\nimport pandas as pd\nimport duckdb\n\ndf = pd.DataFrame({\"some_values\" : [42, 7411, 4]})\nprint(duckdb.query(\"SELECT SUM(some_values) FROM df\").to_df())\n```\n\n하지만 일단은 포켓몬으로 계속해 봅시다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 데모 3: Unnest\n\n이전 예제에서 결과, 즉 실제 포켓몬은 모두 한 행과 열 안에 구조체 목록 형식으로 있습니다. 그러나 추가 처리를 위해 각 포켓몬 당 하나의 행을 원합니다. 이를 위해 unnest 함수를 사용할 수 있습니다.\n\n```js\nimport duckdb\n\nduckdb.sql(\"\"\"\n    CREATE TABLE pokemon AS\n    SELECT unnest(results) AS pokemon\n    FROM read_json_auto('https://pokeapi.co/api/v2/pokemon?limit=1000');\n\n    SELECT\n        pokemon.name,\n        pokemon.url\n    FROM pokemon;\n\"\"\").show()\n```\n\n포켓몬 당 한 행씩 이름 및 URL이 포함된 결과를 얻을 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n┌──────────────┬─────────────────────────────────────────┐\n│     name     │                   url                   │\n│   varchar    │                 varchar                 │\n├──────────────┼─────────────────────────────────────────┤\n│ bulbasaur    │ https://pokeapi.co/api/v2/pokemon/1/    │\n│ ivysaur      │ https://pokeapi.co/api/v2/pokemon/2/    │\n│ venusaur     │ https://pokeapi.co/api/v2/pokemon/3/    │\n│    ·         │                   ·                     │\n│    ·         │                   ·                     │\n│ baxcalibur   │ https://pokeapi.co/api/v2/pokemon/998/  │\n│ gimmighoul   │ https://pokeapi.co/api/v2/pokemon/999/  │\n│ gholdengo    │ https://pokeapi.co/api/v2/pokemon/1000/ │\n├──────────────┴─────────────────────────────────────────┤\n│ 1000 rows (20 shown)                         2 columns │\n└────────────────────────────────────────────────────────┘\n```\n\n# 데모 4: 세부 정보 가져오기를 위한 UDF\n\n피카츄를 라이츄로 진화시킬 수 있을까요? 물론 가능합니다! 이전 예제의 결과를 사용하면, url이라는 열을 가지고 있어 각 포켓몬에 대한 더 많은 세부 정보를 얻기 위해 요청해야 합니다. read_json_auto와 같은 함수는 테이블 수준 함수이기 때문에 각 행에 적용할 수 없습니다.\n\nDuckDB는 Python과 완벽하게 통합되어 있어 열에 있는 각 url 값에 대해 간단히 Python 함수를 호출할 수 있는 방법이 있습니다. 이는 다른 데이터베이스 시스템에서 알 수 있는 사용자 정의 함수(UDF)와 유사합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nAPI로부터 데이터를 가져오기 위해 파이썬 함수를 정의해야 합니다:\n\n```python\nimport requests\n\ndef get(url):\n    return requests.get(url).text\n```\n\n그런 다음 DuckDB에 등록해야 합니다:\n\n```python\nfrom duckdb.typing import VARCHAR\n\nduckdb.create_function(\"get\", get, [VARCHAR], VARCHAR)\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\ncreate_function을 사용할 때는 SQL 스크립트에서 UDF에 참조할 이름을 지정해야 합니다. 또한 호출할 실제 Python 함수와 매개변수 유형 및 반환 유형 목록을 전달해야 합니다.\n\n그런 다음 SQL에서 다음과 같이 사용할 수 있습니다:\n\n```js\njson(get(pokemon.url)) AS details\n```\n\n다시 말해, 우리는 포켓몬 목록에서 각 pokemon.url에 대해 Python 함수 get을 호출합니다. 우리가 얻는 것은 JSON 응답 텍스트이며, json 함수를 사용하여 적절한 유형의 결과를 얻습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음은 스스로 시도해볼 수 있는 최종 코드입니다:\n\n```js\nimport duckdb\nimport requests\nfrom duckdb.typing import VARCHAR\n\n\ndef get(url):\n    return requests.get(url).text\n\n\nduckdb.create_function(\"get\", get, [VARCHAR], VARCHAR)\nduckdb.sql(\"\"\"\n    CREATE TABLE pokemon AS\n    SELECT unnest(results) AS pokemon\n    FROM read_json_auto('https://pokeapi.co/api/v2/pokemon?limit=10');\n\n    WITH base AS (\n        SELECT\n            pokemon.name AS name,\n            json(get(pokemon.url)) AS details\n        FROM pokemon\n    )\n    SELECT *\n    FROM base;\n\"\"\").show()\n```\n\n각 포켓몬에 대해 API를 호출하므로 실행에 몇 초가 걸릴 수 있습니다. 결과는 이름과 모든 세부 정보가 JSON으로 표시된 테이블입니다.\n\n<img src=\"/assets/img/2024-05-20-GottaprocessemallDuckDBmastersyourdatalikeaPokmontrainer_5.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 데모 5: 리스트 컴프리헨션\n\n파이썬의 리스트 컴프리헨션은 제가 가장 좋아하는 기능 중 하나에요. DuckDB에서도 리스트 컴프리헨션을 사용할 수 있어요! 우리의 목표는 세부 정보를 추가 처리하여 개별 열로 추출하는 것이에요. 하지만 모든 세부 정보가 아니라, 포켓몬의 ID, 이름, 키, 그리고 무게만 추출할 거에요.\n\n또한 포켓몬이 사용할 수 있는 능력들을 능력 이름으로 이루어진 간단한 리스트로 줄이고 다른 열에 저장할 거에요.\n\nSQL을 더 읽기 쉽게 만들기 위해, 우리는 공통 테이블 표현식 (CTE)도 사용할 거예요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\nimport duckdb\nimport requests\nfrom duckdb.typing import VARCHAR\n\ndef get(url):\n    return requests.get(url).text\n\nduckdb.create_function(\"get\", get, [VARCHAR], VARCHAR)\nduckdb.sql(\"\"\"\n    CREATE TABLE pokemon AS\n    SELECT unnest(results) AS pokemon\n    FROM read_json_auto('https://pokeapi.co/api/v2/pokemon?limit=10');\n\n    WITH base AS (\n        SELECT\n            pokemon.name AS name,\n            json(get(pokemon.url)) AS details\n        FROM pokemon\n    ), pokemon_details AS (\n        SELECT\n            details.id,\n            name,\n            details.abilities::STRUCT(ability STRUCT(name VARCHAR, url VARCHAR), is_hidden BOOLEAN, slot INTEGER)[] AS abilities,\n            details.height,\n            details.weight\n        FROM base\n    )\n    SELECT\n        id,\n        name,\n        [x.ability.name FOR x IN abilities] AS abilities,\n        height,\n        weight\n    FROM pokemon_details;\n\"\"\").show()\n```\n\nCTE인 pokemon_details가 필요한 세부 정보를 추출합니다. 그러나 여기에는 한 가지 숨겨진 기능이 더 있습니다: 현재 details 열의 abilities가 JSON 유형이지만 리스트 표현식에는 실제 목록 유형이 필요합니다. 다음 문으로:\n\n```python\ndetails.abilities::STRUCT(ability STRUCT(name VARCHAR, url VARCHAR), is_hidden BOOLEAN, slot INTEGER)[] AS abilities,\n```\n\nabilities의 유형을 구조 목록으로 변환합니다. 각 구조에는 더 자세한 정보를 위해 능력 이름과 URL뿐만 아니라, 숨겨진 플래그와 슬롯 번호를 포함하는 또 다른 구조가 포함됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n지금 능력은 목록이므로 SQL에서 목록 표현을 적용할 수 있습니다. 이는 기본적으로 파이썬의 목록 표현과 동일하게 작동합니다. 따라서 다음 SQL 코드를 사용해보세요:\n\n```js\n[x.ability.name FOR x IN abilities] AS abilities,\n```\n\n이를 통해 각 포켓몬이 사용할 수 있는 각 능력의 이름만 포함된 새 목록을 만듭니다.\n\n```js\n| id   | name       | abilities               | height | weight |\n|------|------------|-------------------------|--------|--------|\n| 1    | bulbasaur  | [overgrow, chlorophyll] | 7      | 69     |\n| 2    | ivysaur    | [overgrow, chlorophyll] | 10     | 130    |\n| 3    | venusaur   | [overgrow, chlorophyll] | 20     | 1000   |\n| 4    | charmander | [blaze, solar-power]    | 6      | 85     |\n| 5    | charmeleon | [blaze, solar-power]    | 11     | 190    |\n| 6    | charizard  | [blaze, solar-power]    | 17     | 905    |\n| 7    | squirtle   | [torrent, rain-dish]    | 5      | 90     |\n| 8    | wartortle  | [torrent, rain-dish]    | 10     | 225    |\n| 9    | blastoise  | [torrent, rain-dish]    | 16     | 855    |\n| 10   | caterpie   | [shield-dust, run-away] | 3      | 29     |\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 데모 6: DuckDB에서 Pandas로 그리고 다시 되돌아 오기\n\n지금쯤이면 DuckDB가 휴대용 분석 데이터베이스뿐만 아니라 다양한 데이터 조작 도구임이 분명해졌을 것입니다.\n\nDuckDB의 핵심은 SQL 기반 작업과 Pandas와 같은 다른 데이터 처리 도구 간에 원활한 통합을 제공합니다. 이 독특한 기능은 데이터 처리 스크립트 내에서 서로 다른 기술 간에 쉽게 전환할 수 있도록 가능하게 합니다.\n\n전혀 SQL에서 데이터 처리를 하거나 Pandas나 NumPy와 같은 전형적인 라이브러리를 사용하여 Python 스크립트 내에서 데이터 정제를 완전히 구현하는 대신, 복잡한 데이터베이스 통합 설정이 필요 없이 이러한 환경 간을 전환할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n지금까지의 예제를 기반으로, Pandas를 사용하여 추가 처리를 수행하고 싶다고 가정해 봅시다. DuckDB를 사용하면 SQL 쿼리의 결과를 데이터프레임으로 쉽게 내보낼 수 있습니다. .df() 함수를 사용하면 됩니다.\n\n또한 DuckDB를 사용하면 Pandas 데이터프레임에서 직접 데이터를 쿼리할 수도 있습니다!\n\n```python\nimport duckdb\nimport requests\nfrom duckdb.typing import VARCHAR\n\ndef get(url):\n    return requests.get(url).text\n\nduckdb.create_function(\"get\", get, [VARCHAR], VARCHAR)\n\n# DuckDB에서 작업 시작\ndf = duckdb.sql(\"\"\"\n    CREATE TABLE pokemon AS\n    SELECT unnest(results) AS pokemon\n    FROM read_json_auto('https://pokeapi.co/api/v2/pokemon?limit=10');\n\n    WITH base AS (\n        SELECT\n            pokemon.name AS name,\n            json(get(pokemon.url)) AS details\n        FROM pokemon\n    ), pokemon_details AS (\n        SELECT\n            details.id,\n            name,\n            details.abilities::STRUCT(ability STRUCT(name VARCHAR, url VARCHAR), is_hidden BOOLEAN, slot INTEGER)[] AS abilities,\n            details.height,\n            details.weight\n        FROM base\n    )\n    SELECT\n        id,\n        name,\n        [x.ability.name FOR x IN abilities] AS abilities,\n        height,\n        weight\n    FROM pokemon_details;\n\"\"\").df()\n\n# Pandas에서 데이터 처리 계속\ndf_agg = df.explode(\"abilities\").groupby(\"abilities\", as_index=False).agg(count=(\"id\", \"count\"))\n\n# DuckDB로 돌아가기\nduckdb.sql(\"\"\"\n    SELECT abilities AS ability, count\n    FROM df_agg\n    ORDER BY count DESC\n    LIMIT 8;\n\"\"\").show()\n```\n\n위 코드는 다음 결과를 출력합니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n┌─────────────┬───────┐\n│   능력       │ 개수  │\n│   varchar   │ int64 │\n├─────────────┼───────┤\n│ blaze       │     3 │\n│ chlorophyll │     3 │\n│ overgrow    │     3 │\n│ rain-dish   │     3 │\n│ solar-power │     3 │\n│ torrent     │     3 │\n│ run-away    │     1 │\n│ shield-dust │     1 │\n└─────────────┴───────┘\n```\n\n앞서 언급한 대로, .df()를 사용하면 SQL 결과를 Pandas 데이터프레임으로 얻을 수 있습니다. 그런 다음 다음과 같이 추가적인 변환을 적용할 수 있습니다.\n\n```js\ndf_agg = df\n  .explode(\"abilities\")\n  .groupby(\"abilities\", (as_index = False))\n  .agg((count = (\"id\", \"count\")));\n```\n\n그리고 df_agg 변수에 저장된 데이터프레임을 SQL에서 사용할 수 있습니다. 처음 보았을 때 정말 놀랐던 부분이죠.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```sql\nSELECT abilities AS ability, count\nFROM df_agg\nORDER BY count DESC\nLIMIT 8;\n```\n\n데이터 처리 도구로 DuckDB가 좋은 도구인 이유는 어떤 접착 코드도 추가하지 않기 때문입니다.\n\n# 데모 7: 데이터 유지 및 로드\n\n매번 실행할 때마다 API를 호출하는 것은 가장 효율적인 해결책은 아닙니다. 물론 결과를 기다리는 동안 맛있는 커피 한 잔을 마실 수 있는 기회를 제공하지만, DuckDB는 데이터를 유지할 수도 있습니다. 예를 들어 데이터를 파일로 직렬화하여 파일 시스템에 저장할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 예제를 다음 코드와 함께 확장해 봅시다:\n\n```js\n# 판다스에서 데이터 처리 계속하기\ndf_agg = df.explode(\"abilities\").groupby(\"abilities\", as_index=False).agg(count=(\"id\", \"count\"))\n\n# 데이터 유지하기\nwith duckdb.connect(database=\"pokemon.db\") as conn:\n    conn.sql(\"\"\"\n        DROP TABLE IF EXISTS pokemon_abilities;\n        CREATE TABLE pokemon_abilities AS\n        SELECT abilities AS ability, count\n        FROM df_agg\n        ORDER BY count DESC;\n    \"\"\")\n```\n\n우리는 pokemon.db라는 파일에 연결을 열고 데이터를 저장합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다른 스크립트에서 데이터를로드하고 사전 처리 된 데이터에 액세스 할 수 있습니다:\n\n```js\nimport duckdb\n\n# 데이터 로드\nwith duckdb.connect(database=\"pokemon.db\") as conn:\n    conn.sql(\"\"\"\n        SELECT * FROM pokemon_abilities;\n    \"\"\").show()\n```\n\n<img src=\"/assets/img/2024-05-20-GottaprocessemallDuckDBmastersyourdatalikeaPokmontrainer_7.png\" />\n\n# 결론\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nDuckDB은 데이터 처리 도전에서 강력한 동료로 나타났습니다. Pandas 데이터프레임과 고급 분석 SQL 기능과의 매끄러운 통합을 제공하여 자원 제한적 환경에서 분석 작업에 적합함을 강조했습니다.\n\n[Github](https://github.com/vojay-dev/duckdb-pokemon)에서 모든 데모를 찾을 수 있어요! 🪄\n\nDuckDB가 함께하면 금방 성공적인 포켓몬 트레이너가 될 거에요!\n\n<img src=\"/assets/img/2024-05-20-GottaprocessemallDuckDBmastersyourdatalikeaPokmontrainer_8.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n경험을 공유해주시고 즐거운 독서를 즐기세요!\n","ogImage":{"url":"/assets/img/2024-05-20-GottaprocessemallDuckDBmastersyourdatalikeaPokmontrainer_0.png"},"coverImage":"/assets/img/2024-05-20-GottaprocessemallDuckDBmastersyourdatalikeaPokmontrainer_0.png","tag":["Tech"],"readingTime":22},{"title":"프리즈마 101 프리즈마 이해를 위한 초보자 안내서","description":"","date":"2024-05-20 18:55","slug":"2024-05-20-PRISMA101Abeginnersguidetounderstandprisma","content":"\n<img src=\"/assets/img/2024-05-20-PRISMA101Abeginnersguidetounderstandprisma_0.png\" />\n\n# 소개\n\nNode.js나 TypeScript 환경에서 데이터베이스를 다룬 적이 있다면, Prisma에 대해 들어봤을 것입니다. Prisma는 데이터베이스 관리와 상호작용을 간소화하는 도구입니다. 하지만 Prisma가 정확히 무엇인지, 어떤 일을 하며 왜 사용해야 하는지 알고 계신가요? ORM이 무엇인지도 궁금하신가요? 이 글을 읽은 후에는 이러한 질문들에 대한 답을 알게 될 것입니다.\n\n# Prisma란 무엇인가요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n프리즈마는 데이터베이스 작업을 할 때 개발자 경험을 향상시키는 Node.js 및 TypeScript ORM입니다. 직관적인 데이터 모델, 자동 마이그레이션, 타입 안전성 및 자동 완성을 통해 데이터베이스를 쉽게 관리하고 상호 작용할 수 있게 해줍니다.\n\n# Prisma는 다음으로 구성됩니다:\n\n- Prisma Client: Node.js 및 TypeScript용 자동 생성 및 타입 안전한 쿼리 빌더.\n- Prisma Migrate: 선언적 데이터 모델링 및 마이그레이션 시스템.\n- Prisma Studio: 데이터베이스에서 데이터를 보고 편집할 수 있는 GUI입니다.\n\n# 프리즈마가 하는 일이 무엇인가요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n지금까지 프리즈마가 애플리케이션과 데이터베이스 사이에서 중재자로 작용한다는 것을 알게 되었습니다. 이것은 주요 기능을 강조합니다:\n\n- 스키마 정의: 프리즈마 스키마 파일에서 데이터 모델을 정의합니다.\n- 데이터베이스 연결: 스키마 파일을 사용하여 선호하는 데이터베이스에 연결합니다.\n- 쿼리 작성: 쿼리 빌더로 Prisma Client를 사용합니다.\n- 마이그레이션: 프리즈마 마이그레이트를 사용하여 데이터베이스 마이그레이션을 자동으로 생성 및 적용합니다.\n- 데이터 관리: 사용자 친화적 인터페이스를 통해 데이터를 상호 작용하기 위해 Prisma Studio를 사용합니다.\n\n# ORM이란 무엇인가요?\n\nORM(Object-Relational Mapping)은 데이터베이스와 객체지향 방식으로 상호 작용할 수 있도록 해주는 프로그래밍 기술입니다. 더 간단하게 말하면 ORM은 데이터를 애플리케이션 코드와 데이터베이스와 같은 호환되지 않는 유형 시스템 사이에서 번역합니다. 이는 원시 SQL 쿼리를 작성하지 않고 익숙한 프로그래밍 개념을 사용하여 데이터베이스 작업을 할 수 있음을 의미합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 프리즈마를 사용해야 하는 이유\n\n프리즈마를 사용해야 하는 이유:\n\n- 개발자 생산성: 프리즈마를 사용하면 데이터베이스 관리에 신경 쓰지 않고 멋진 기능을 구축하는 데 더 많은 시간을 할애할 수 있습니다. 마치 모든 지루한 작업을 처리해 주는 개인 비서가 있는 것과 같습니다.\n- 타입 안전성: 프리즈마를 사용하면 타입 안전한 쿼리를 얻을 수 있어 런타임 오류가 줄어듭니다.\n- 자동 마이그레이션: 프리즈마 Migrate를 사용하면 데이터베이스 스키마를 시간이 지남에 따라 쉽게 변경할 수 있으며 마이그레이션을 자동으로 처리합니다.\n- 더 나은 디버깅: 타입 안전한 프리즈마 클라이언트는 매우 설명이 잘 된 오류를 생성하여 코드의 디버깅을 매우 쉽게 만듭니다.\n- 커뮤니티와 지원: 프리즈마에는 활발한 커뮤니티와 방대한 문서가 있어 쉽게 학습하고 도움을 받을 수 있습니다.\n\n# 프리즈마 ORM이 어떻게 작동하는지 궁금하신가요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n프리즈마 스키마 파일에서 시작됩니다. 여기서 데이터 모델을 정의하고 데이터베이스 연결을 구성합니다.\n간단한 예시를 보여드리겠습니다:\n\n![프리즈마 코드](/assets/img/2024-05-20-PRISMA101Abeginnersguidetounderstandprisma_1.png)\n\n위 코드에서 세 가지를 구성했습니다:\n\n- Generator: 프리즈마 클라이언트 생성을 원한다는 것을 나타냅니다.\n- Data source: 데이터베이스 연결 (환경 변수와 함께).\n- Data model: 애플리케이션 모델을 정의합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n프리즈마 스키마의 모델은 데이터베이스의 테이블을 나타냅니다. 이 모델은 프리즈마 클라이언트 API에서 쿼리를 위한 기초를 제공합니다. 예를 들어, 위에서 정의한 User 모델을 사용하면 사용자에 대한 CRUD(Create, Read, Update, Delete) 작업을 쉽게 수행할 수 있습니다.\n\n# 프리즈마 클라이언트\n\n프리즈마 클라이언트는 스키마 파일을 기반으로 생성됩니다. 이를 사용하면 쿼리를 타입 안전하게 작성할 수 있어 익숙한 JavaScript/TypeScript 구문을 사용하여 데이터베이스와 상호 작용할 수 있습니다. 아래는 프리즈마 클라이언트를 사용하는 방법 예시입니다:\n\n![프리즈마 클라이언트 예시](/assets/img/2024-05-20-PRISMA101Abeginnersguidetounderstandprisma_2.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# Prisma Migrate\n\n프리즈마 마이그레이트는 시간이 지남에 따라 데이터베이스 스키마를 발전시키는 데 도움을 줍니다. 프리즈마 스키마 파일에서 스키마 변경 사항을 정의하고, 프리즈마 마이그레이트가 해당 SQL 마이그레이션 스크립트를 자동으로 생성해 줍니다. 이를 통해 데이터베이스 스키마가 코드와 동기화되도록 보장할 수 있습니다.\n\n# Prisma Studio\n\n프리즈마 스튜디오는 사용하기 편리한 인터페이스를 제공하여 데이터와 상호 작용할 수 있습니다. 코드를 작성하지 않고도 데이터를 볼 수 있고 편집하고 관리할 수 있습니다. 데이터를 검사하거나 업데이트할 때 유용할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 결론\n\nPrisma는 Node.js와 TypeScript에서 데이터베이스 작업을 할 때 개발자 경험을 크게 향상시키는 강력한 ORM입니다. 우리는 Prisma가 어떻게 워크플로우를 최적화하고 데이터베이스 상호작용을 견고하고 오류 없이 만들어낼 수 있는지 살펴보았습니다.\n\n이해한 바에 따라 이제 Prisma의 세계에 뛰어들어 빠르게 멋진 것들을 구축해보세요. 즐거운 코딩되시길 바랍니다!\n","ogImage":{"url":"/assets/img/2024-05-20-PRISMA101Abeginnersguidetounderstandprisma_0.png"},"coverImage":"/assets/img/2024-05-20-PRISMA101Abeginnersguidetounderstandprisma_0.png","tag":["Tech"],"readingTime":5},{"title":"제목 Gemini LLM, Python, FastAPI, Pydantic, RAG 등을 활용한 AI 기반 영화 퀴즈 만들기","description":"","date":"2024-05-20 18:50","slug":"2024-05-20-CreateanAI-DrivenMovieQuizwithGeminiLLMPythonFastAPIPydanticRAGandmore","content":"\n## 파이썬을 이용한 VertexAI를 통한 Gemini 기초 알아보기, FastAPI로 API 생성, Pydantic을 이용한 데이터 유효성 검사 및 Retrieval-Augmented Generation (RAG) 기초\n\n이 글에서는 다양한 기술을 이용하여 LLM을 활용한 웹 애플리케이션을 만들기 위한 기본 사항을 공유합니다: Python, FastAPI, Pydantic, VertexAI 등을 사용합니다.\n\n고지: 본 프로젝트에서는 The Movie Database의 데이터를 사용하고 있습니다. 이 API는 비상업적 목적으로 사용할 수 있으며, 디지털 밀레니엄 저작권법 (DMCA)을 준수합니다. TMDB 데이터 사용에 대한 자세한 정보는 공식 FAQ를 참조해주세요.\n\n# 목차\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 영감\n- 시스템 아키텍처\n- 검색 증가 생성 (RAG) 이해\n- Poetry를 사용한 Python 프로젝트\n- FastAPI로 API 생성\n- Pydantic을 사용한 데이터 유효성 검사 및 품질\n- httpx를 사용한 TMDB 클라이언트\n- VertexAI에서 Gemini LLM 클라이언트\n- Jinja로 모듈식 프롬프트 생성기\n- 프론트엔드\n- API 예시\n- 결론\n\n이 지식을 공유하는 가장 좋은 방법은 실용적인 예제를 통해 하는 것입니다. 따라서 여러 측면을 다루기 위해 제 프로젝트 Gemini Movie Detectives를 사용할 것입니다. 이 프로젝트는 구글 AI 해커톤 2024의 일부로 만들어졌습니다. 현재 이 글을 쓰는 동안에도 해당 해커톤이 진행 중입니다.\n\n![이미지](/assets/img/2024-05-20-CreateanAI-DrivenMovieQuizwithGeminiLLMPythonFastAPIPydanticRAGandmore_0.png)\n\nGemini Movie Detectives는 VertexAI를 통해 Gemini Pro 모델의 파워를 활용하여 최신 영화 데이터를 활용하여 재미있는 퀴즈 게임을 만드는 것을 목표로 한 프로젝트입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n프로젝트의 일부는 Docker를 사용하여 배포할 수 있도록하고 실시간 버전을 만드는 것이었습니다. 직접 확인해보세요: movie-detectives.com. 이것은 단순한 프로토 타입이므로 예상치 못한 문제가 발생할 수 있습니다. 또한, GCP와 VertexAI를 사용함으로써 발생할 수 있는 비용을 제어하기 위해 일부 제한을 추가해야 했습니다.\n\n이 프로젝트는 완전히 오픈 소스로, 두 개의 별도 리포지토리로 나뉘어 있습니다:\n\n- 🚀 백엔드용 Github 리포지토리: https://github.com/vojay-dev/gemini-movie-detectives-api\n- 🖥️ 프론트엔드용 Github 리포지토리: https://github.com/vojay-dev/gemini-movie-detectives-ui\n\n이 글의 중점은 백엔드 프로젝트와 그 배경 개념에 있습니다. 그러므로 프론트엔드 및 해당 구성 요소에 대해 간략히 설명합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음 동영상에서는 프로젝트와 그 구성 요소에 대한 개요를 제공합니다:\n\n# 영감\n\n열정적인 게이머로 자라고 이제는 데이터 엔지니어로 일하며, 게임과 데이터의 교차점에 항상 매료되어 왔습니다. 이 프로젝트에서는 내 가장 큰 열정인 게임과 데이터를 결합했습니다. 90년대에는 항상 재밌게 즐겼던 You Don’t Know Jack 비디오 게임 시리즈, 유머와 문제 해결의 멋진 결합으로 오로지 즐겁게 놀 뿐만 아니라 어떤 것을 배우기도 했었습니다. 일반적으로 게임을 교육 목적으로 활용하는 개념 또한 나를 매료시키는 것입니다.\n\n2023년, 나는 아이들과 청소년 대상으로 게임 개발을 가르치는 워크샵을 진행했습니다. 그들은 충돌 탐지 뒤에 숨은 수학적 개념에 대해 배웠지만, 모든 것이 게임의 맥락으로 풀렸기 때문에 즐거워했습니다. 게임이 거대한 시장뿐만 아니라 지식 공유에도 큰 잠재력이 있다는 것을 깨달았습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 프로젝트인 영화 탐정(Movie Detectives)은 제가 Gemini 및 AI 전반의 매력을 보여주고 귀하고 유익한 퀴즈 및 교육 게임을 만들어내는데 어떻게 활용할 수 있는지, 또한 게임 디자인이 이러한 기술에서 이익을 얻는 방법을 소개합니다.\n\nGemini LLM에 정확하고 최신의 영화 메타데이터를 제공함으로써 Gemini의 질문의 정확성을 보장할 수 있었습니다. 이는 실시간 메타데이터를 활용하여 쿼리를 풍부하게 하는 Retrieval-Augmented Generation (RAG) 방법론이 없으면 잘못된 정보가 전파될 위험이 있기 때문에 중요한 측면입니다. AI를 이용할 때 일반적으로 치명적인 함정 중 하나입니다.\n\n또 다른 혁신은 Jinja 템플릿을 사용하여 만든 모듈식 프롬프트 생성 프레임워크에 있습니다. 이는 게임 디자인을 위한 스위스 아미 나이프를 소유하고 있는 것과 같습니다. 이를 통해 쇼 마스터의 개성을 손쉽게 바꾸어 게임 경험을 맞춤 설정할 수 있습니다. 그리고 언어 모듈을 통해 퀴즈를 다양한 언어로 번역하는 것은 간단하며 비용이 드는 번역 프로세스를 제거할 수 있습니다.\n\n비즈니스적인 관점에서 이를 고려하면, 고가의 번역 프로세스가 필요 없이 더 많은 고객에게 도달할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n비즈니스적인 측면에서, 이 모듈화는 어렵지 않게 언어 장벽을 초월하며 더 넓은 고객층에 문을 열어줍니다. 또한 저는 이 모듈들의 변혁적인 힘을 직접 체험해 보았습니다. 기본 퀴즈 마스터에서 아재 농담 퀴즈 마스터로 변경하는 것은 정말 재미있는 경험이었어요. 이 프로젝트의 다재다능성에 대한 입증이자, You Don’t Know Jack의 전성기에 대한 향수로운 인사입니다.\n\n# 시스템 아키텍처\n\n자세한 내용에 앞서, 어떻게 애플리케이션이 구축되었는지에 대한 개요를 살펴봐요.\n\n기술 스택: 🚀 백엔드\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- Python 3.12 + FastAPI API 개발\n- TMDB 통합을 위한 httpx\n- 모듈식 프롬프트 생성을 위한 Jinja 템플릿\n- 데이터 모델링 및 유효성 검사를 위한 Pydantic\n- 의존성 관리를 위한 Poetry\n- 배포를 위한 Docker\n- 영화 데이터를 위한 TMDB API\n- 퀴즈 질문 생성 및 답변 평가를 위한 VertexAI 및 Gemini\n- 코드 포매터 및 린터로서 Ruff와 함께 pre-commit 훅\n- Github Actions를 사용하여 모든 푸시마다 테스트 및 린터 자동 실행\n\n기술 스택: 🖥️ 프론트엔드\n\n- 프론트엔드 프레임워크로 VueJS 3.4 사용\n- 프론트엔드 툴링을 위해 Vite 사용\n\n이 어플리케이션은 외부 API (TMDB)에서 최신 영화 메타데이터를 가져온 후 다양한 모듈 (성격, 언어, ...)로 기반을 둔 프롬프트를 구축하고, 이 메타데이터로 프롬프트를 보강하여 사용자가 올바른 제목을 추측해야 하는 영화 퀴즈를 이니셜라이징하도록 Gemini를 사용합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n백엔드 인프라는 FastAPI와 Python으로 구축되었으며, 실시간 메타데이터를 활용하여 쿼리를 보강하는 Retrieval-Augmented Generation (RAG) 방법론을 적용했습니다. 백엔드는 Jinja 템플릿을 활용하여 프롬프트 생성을 기본, 개성 및 데이터 향상 템플릿으로 모듈화하며, 정확하고 매력적인 퀴즈 질문을 생성할 수 있도록 합니다.\n\n프론트엔드는 Vue 3와 Vite로 구동되며, 효율적인 프론트엔드 개발을 위해 daisyUI와 Tailwind CSS를 활용합니다. 이러한 도구들은 사용자에게 매끄럽고 현대적인 인터페이스를 제공하여 백엔드와의 원활한 상호작용을 지원합니다.\n\n영화 탐정들에서는 퀴즈 답변이 언어 모델 (LLM)에 의해 해석되어 동적 점수 매기기와 맞춤형 응답이 가능해집니다. 이는 게임 디자인 및 개발에서 LLM과 RAG를 통합하는 잠재력을 선보이며, 진정한 개별화된 게임 경험을 제공합니다. 뿐만 아니라, LLM을 활용하여 매력적인 퀴즈 트리비아 또는 교육 게임을 만드는 잠재력을 보여줍니다. 또한, 퍼스널리티나 언어를 추가하거나 변경하는 것은 더 많은 Jinja 템플릿 모듈을 추가하는 것만큼 쉽습니다. 개발자에게 노력을 줄이고 게임 경험을 변경하는 데 큰 도움이 됩니다.\n\n<img src=\"/assets/img/2024-05-20-CreateanAI-DrivenMovieQuizwithGeminiLLMPythonFastAPIPydanticRAGandmore_1.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n개요에서 보듯이, Retrieval-Augmented Generation (RAG)은 백엔드의 중요한 아이디어 중 하나입니다. 이 특별한 패러다임을 더 자세히 살펴보겠습니다.\n\n# Retrieval-Augmented Generation (RAG) 이해하기\n\n대형 언어 모델 (LLM) 및 AI 영역에서 점점 인기를 얻고 있는 패러다임 중 하나가 Retrieval-Augmented Generation (RAG)입니다. 그러나 RAG가 무엇을 함유하고 있으며, AI 개발 영역에 어떤 영향을 미치는지 알아볼까요?\n\n본질적으로, RAG는 외부 데이터를 통합하여 LLM 시스템을 강화하여 예측을 풍부하게 합니다. 이는 LLM에 관련 컨텍스트를 전달해서 프롬프트의 추가 요소로 사용한다는 것을 의미합니다. 하지만 어떻게 관련 컨텍스트를 찾을까요? 일반적으로, 해당 데이터는 벡터 검색이나 전용 벡터 데이터베이스를 통해 자동으로 검색될 수 있습니다. 벡터 데이터베이스는 유사한 데이터에 대한 쿼리를 빠르게 수행할 수 있도록 데이터를 저장하는 방식으로 특히 유용합니다. 그런 다음 LLM은 쿼리와 검색된 문서를 기반으로 출력을 생성합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n상상해 보세요: 주어진 프롬프트에 따라 텍스트를 생성할 수 있는 LLM이 있는 상황을 생각해보세요. RAG는 최신 영화 데이터와 같은 외부 소스에서 추가적인 컨텍스트를 주입함으로써 생성된 텍스트의 관련성과 정확도를 높이는 한 걸음 더 나아간 기술입니다.\n\nRAG의 주요 구성 요소를 살펴보죠:\n\n- LLMs: LLMs는 RAG 워크플로우의 중추 역할을 합니다. 이 모델들은 방대한 양의 텍스트 데이터로 훈련되어 있어 인간과 유사한 텍스트를 이해하고 생성할 수 있는 능력을 갖추고 있죠.\n- 컨텍스트 풍부화를 위한 벡터 인덱스: RAG의 중요한 측면 중 하나는 벡터 인덱스의 사용입니다. 이 인덱스는 LLM이 이해할 수 있는 형식으로 텍스트 데이터의 임베딩을 저장하며, 생성 프로세스 중 관련 정보를 효율적으로 검색할 수 있게 해줍니다. 프로젝트의 맥락에서는 영화 메타데이터베이스일 것입니다.\n- 검색 프로세스: RAG는 주어진 컨텍스트나 프롬프트를 기반으로 관련 문서나 정보를 검색하는 과정을 포함합니다. 이러한 검색된 데이터는 LLM에 대한 추가적인 입력으로 작용하여 이해력을 보충하고 생성된 응답의 품질을 향상시킵니다. 이는 특정 영화에 관련된 모든 관련 정보를 알아내고 연결하는 것을 의미할 수 있습니다.\n- 생성된 출력물: LLM과 검색된 컨텍스트로부터 획득한 결합된 지식을 기반으로 시스템이 응답을 생성합니다. 이를 통해 생성된 텍스트는 일관성을 유지할 뿐만 아니라 문맥적으로 관련이 있어 강화된 데이터 덕분에 생성됩니다.\n\n젬니미 영화 탐정 프로젝트에서는 프롬프트가 The Movie Database의 외부 API 데이터로 보강되지만, RAG는 일반적으로 이러한 프로세스를 단순화하기 위해 벡터 인덱스의 사용을 포함합니다. 보다 복잡한 문서와 향상된 데이터 양을 사용한다는 점이 다릅니다. 따라서 이러한 인덱스는 시스템을 빠르게 관련 외부 소스로 안내하는 안내표 같은 역할을 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 프로젝트에서는 LLM 능력을 증진시키는 외부 데이터의 강점을 증명하며, 기본 아이디어를 보여줌으로써 RAG의 미니 버전을 소개합니다.\n\n보다 일반적으로 RAG는 퀴즈나 교육 게임을 만들 때 Gemini와 같은 LLM을 사용할 때 매우 중요한 개념입니다. 이 개념은 잘못된 질문을 하거나 사용자의 답변을 잘못 해석하는 위험을 피할 수 있습니다.\n\n다음은 프로젝트 중 하나에 RAG를 적용할 때 도움이 될 수 있는 오픈 소스 프로젝트 목록입니다:\n\n- txtai: 시맨틱 검색, LLM 조작 및 언어 모델 워크플로우를 위한 All-in-one 오픈 소스 임베딩 데이터베이스.\n- LangChain: LangChain은 대형 언어 모델 (LLMs)을 활용한 애플리케이션을 개발하기 위한 프레임워크입니다.\n- Qdrant: 다음 세대 AI 애플리케이션을 위한 벡터 검색 엔진.\n- Weaviate: 강력하고 빠르며 확장 가능한 클라우드 원본 벡터 데이터베이스 인 Weaviate.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n물론, LLM 기반 응용 프로그램에 대한이 접근 방식의 잠재적 가치가 있으므로 오픈 소스 및 클로즈 소스 대체품이 더 많이 있지만, 이러한 것들을 사용하면 주제에 대한 연구를 시작할 수있을 것입니다.\n\n# Poetry 이용한 Python 프로젝트\n\n주요 개념이 명확해지면 프로젝트가 어떻게 생성되었고 일반적으로 종속성이 관리되는 방법을 조금 더 자세히 살펴 보겠습니다.\n\nPoetry가 도와줄 수있는 세 가지 주요 작업은 빌드, 게시 및 추적입니다. 종속성을 관리하기 위한 결정론적인 방법을 가지고, 프로젝트를 공유하고 종속성 상태를 추적하는 것이 아이디어입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Create an AI-Driven Movie Quiz with GeminiLL, MPython, FastAPI, Pydantic, RAG, and more](/assets/img/2024-05-20-CreateanAI-DrivenMovieQuizwithGeminiLLMPythonFastAPIPydanticRAGandmore_2.png)\n\n시를 사용하면 가상 환경을 쉽게 생성할 수 있어요. 기본적으로 시는 시스템 내의 중앙 폴더에 가상 환경을 만들어요. 그러나 저와 같이 프로젝트 폴더 내에서 가상 환경을 사용하길 원한다면 간단한 설정 변경이 필요해요:\n\n```js\npoetry config virtualenvs.in-project true\n```\n\n이제 poetry new를 사용하여 새 Python 프로젝트를 생성할 수 있어요. 시는 시스템의 기본 Python과 연결된 가상 환경을 만들어 줄 거예요. 이를 pyenv와 결합하면 특정 버전을 사용하여 프로젝트를 만드는 유연한 방법을 얻을 수 있어요. 또는 Poetry에 직접 사용할 Python 버전을 알려줄 수도 있어요: poetry env use /full/path/to/python.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n새 프로젝트가 있다면, poetry add를 사용하여 해당 프로젝트에 종속성을 추가할 수 있어요.\n\n이를 통해, Gemini 영화 탐정 프로젝트를 위해 프로젝트를 만들었어요:\n\n```js\npoetry config virtualenvs.in-project true\npoetry new gemini-movie-detectives-api\n\ncd gemini-movie-detectives-api\n\npoetry add 'uvicorn[standard]'\npoetry add fastapi\npoetry add pydantic-settings\npoetry add httpx\npoetry add 'google-cloud-aiplatform>=1.38'\npoetry add jinja2\n```\n\n프로젝트에 대한 메타데이터와 해당 버전과 함께의 종속성은 poetry.toml 및 poetry.lock 파일에 저장돼요. 제가 추가로 종속성을 추가한 후에는, 프로젝트를 위한 다음과 같은 poetry.toml이 생성되었어요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n[tool.poetry]\nname = \"gemini-movie-detectives-api\"\nversion = \"0.1.0\"\ndescription = \"Use Gemini Pro LLM via VertexAI to create an engaging quiz game incorporating TMDB API data\"\nauthors = [\"Volker Janz <volker@janz.sh>\"]\nreadme = \"README.md\"\n\n[tool.poetry.dependencies]\npython = \"^3.12\"\nfastapi = \"^0.110.1\"\nuvicorn = {extras = [\"standard\"], version = \"^0.29.0\"}\npython-dotenv = \"^1.0.1\"\nhttpx = \"^0.27.0\"\npydantic-settings = \"^2.2.1\"\ngoogle-cloud-aiplatform = \">=1.38\"\njinja2 = \"^3.1.3\"\nruff = \"^0.3.5\"\npre-commit = \"^3.7.0\"\n\n[build-system]\nrequires = [\"poetry-core\"]\nbuild-backend = \"poetry.core.masonry.api\"\n\n# FastAPI로 API 만들기\n\nFastAPI는 빠른 API 개발을 가능하게 하는 Python 프레임워크입니다. 오픈 표준을 바탕으로 구축되어 새로운 구문을 익힐 필요 없이 매끄러운 경험을 제공합니다. 자동 문서 생성, 견고한 유효성 검사, 통합된 보안을 통해 FastAPI는 개발을 간소화하고 동시에 우수한 성능을 보장합니다.\n\n<img src=\"/assets/img/2024-05-20-CreateanAI-DrivenMovieQuizwithGeminiLLMPythonFastAPIPydanticRAGandmore_3.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n젬니니 무비 디텍티브 프로젝트용 API를 구현하는 중에, 저는 단순히 Hello World 응용 프로그램에서 시작하여 그것을 확장했어요. 이렇게 시작할 수 있어요:\n\n```js\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get(\"/\")\ndef read_root():\n    return {\"Hello\": \"World\"}\n```\n\n프로젝트 폴더 내의 .venv/ 가상 환경을 유지하고 uvicorn을 사용한다고 가정하면, 코드 변경을 테스트하기 위해 다시 시작할 필요 없이 리로드 기능이 활성화된 API를 시작하는 방법은 다음과 같아요:\n\n```js\nsource .venv/bin/activate\nuvicorn gemini_movie_detectives_api.main:app --reload\ncurl -s localhost:8000 | jq .\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만약 아직 jq를 설치하지 않았다면 지금 설치하는 것을 적극 추천합니다. 나중에 나는 이 멋진 JSON 스위스 아미 나이프에 대해 다룰 수도 있을 것입니다. 여기에 응답이 어떻게 보이는지 알아봅시다:\n\n![이미지](/assets/img/2024-05-20-CreateanAI-DrivenMovieQuizwithGeminiLLMPythonFastAPIPydanticRAGandmore_4.png)\n\n여기서 필요에 따라 API 엔드포인트를 개발할 수 있습니다. 예를 들어 Gemini Movie Detectives에서 영화 퀴즈를 시작하는 API 엔드포인트 구현은 다음과 같습니다:\n\n```js\n@app.post('/quiz')\n@rate_limit\n@retry(max_retries=settings.quiz_max_retries)\ndef start_quiz(quiz_config: QuizConfig = QuizConfig()):\n    movie = tmdb_client.get_random_movie(\n        page_min=_get_page_min(quiz_config.popularity),\n        page_max=_get_page_max(quiz_config.popularity),\n        vote_avg_min=quiz_config.vote_avg_min,\n        vote_count_min=quiz_config.vote_count_min\n    )\n\n    if not movie:\n        logger.info('could not find movie with quiz config: %s', quiz_config.dict())\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail='No movie found with given criteria')\n\n    try:\n        genres = [genre['name'] for genre in movie['genres']]\n\n        prompt = prompt_generator.generate_question_prompt(\n            movie_title=movie['title'],\n            language=get_language_by_name(quiz_config.language),\n            personality=get_personality_by_name(quiz_config.personality),\n            tagline=movie['tagline'],\n            overview=movie['overview'],\n            genres=', '.join(genres),\n            budget=movie['budget'],\n            revenue=movie['revenue'],\n            average_rating=movie['vote_average'],\n            rating_count=movie['vote_count'],\n            release_date=movie['release_date'],\n            runtime=movie['runtime']\n        )\n\n        chat = gemini_client.start_chat()\n\n        logger.debug('starting quiz with generated prompt: %s', prompt)\n        gemini_reply = gemini_client.get_chat_response(chat, prompt)\n        gemini_question = gemini_client.parse_gemini_question(gemini_reply)\n\n        quiz_id = str(uuid.uuid4())\n        session_cache[quiz_id] = SessionData(\n            quiz_id=quiz_id,\n            chat=chat,\n            question=gemini_question,\n            movie=movie,\n            started_at=datetime.now()\n        )\n\n        return StartQuizResponse(quiz_id=quiz_id, question=gemini_question, movie=movie)\n    except GoogleAPIError as e:\n        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=f'Google API error: {e}')\n    except Exception as e:\n        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=f'Internal server error: {e}')\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 코드 안에는 이미 백엔드의 주요 구성 요소 세 가지가 포함되어 있습니다:\n\n- tmdb_client: 내가 구현한 클라이언트로, The Movie Database (TMDB)에서 데이터를 가져 오는 데 사용됩니다.\n- prompt_generator: Jinja 템플릿을 기반으로 모듈식 프롬프트를 생성하는 데 도움이 되는 클래스입니다.\n- gemini_client: Google Cloud의 VertexAI를 통해 Gemini LLM과 상호 작용하는 클라이언트입니다.\n\n나중에 이러한 구성 요소를 자세히 살펴보겠지만, 먼저 FastAPI 사용에 대한 더 많은 유용한 통찰력을 살펴보겠습니다.\n\nFastAPI는 HTTP 메서드와 데이터를 백엔드로 전달하는 것을 정의하는 것이 정말 쉽습니다. 특정 함수의 경우 POST 요청이 예상되므로 새 퀴즈를 생성합니다. 이를 post 데코레이터를 사용하여 수행할 수 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\n@app.post('/quiz')\n```\n\n또한, 요청에 몇 가지 데이터가 포함되어 JSON 형식으로 전송될 것으로 예상합니다. 이 경우, JSON으로 QuizConfig의 인스턴스를 기대하고 있습니다. 나는 단순히 Pydantic의 BaseModel 클래스를 서브클래스로 정의한 QuizConfig를 API 함수에 전달하면 FastAPI가 나머지를 처리해줄 것이다.\n\n```python\nclass QuizConfig(BaseModel):\n    vote_avg_min: float = Field(5.0, ge=0.0, le=9.0)\n    vote_count_min: float = Field(1000.0, ge=0.0)\n    popularity: int = Field(1, ge=1, le=3)\n    personality: str = Personality.DEFAULT.name\n    language: str = Language.DEFAULT.name\n# ...\ndef start_quiz(quiz_config: QuizConfig = QuizConfig()):\n```\n\n또한, 두 개의 사용자 정의 데코레이터를 알아챌 수 있을 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n@rate_limit\n@retry(max_retries=settings.quiz_max_retries)\n\n이것들은 중복 코드를 줄이기 위해 구현한 것입니다. API 함수를 래핑하여 오류가 발생한 경우 함수를 재시도하고 하루에 시작할 수 있는 영화 퀴즈의 전역 속도 제한을 소개합니다.\n\n또 내가 개인적으로 좋아한 것은 FastAPI와 함께 하는 오류 처리입니다. 간단히 HTTPException을 발생시키고 원하는 상태 코드를 지정하면 사용자가 원하는 조건에 맞는 영화를 찾을 수 없는 경우와 같이 적절한 응답을 받게 됩니다:\n\n```js\nraise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail='No movie found with given criteria')\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여기서, 지니 마블 디텍티브와 FastAPI를 사용하여 API를 만드는 개요를 갖게 될 것입니다. 주의할 점은 모든 코드가 오픈 소스이므로 Github의 API 저장소를 자유롭게 살펴볼 수 있습니다.\n\n# Pydantic을 사용한 데이터 유효성 검사 및 품질\n\n오늘날 AI/ML 프로젝트의 주요 도전 과제 중 하나는 데이터 품질입니다. 그러나 이것은 모델 훈련이나 예측에 사용되는 데이터셋을 준비하는 ETL/ELT 파이프라인에만 해당되는 것은 아닙니다. AI/ML 애플리케이션 자체에도 적용됩니다. 예를 들어 Python을 사용하면 대부분 동적 타입이지만 데이터 유효성을 검사하는 기본적인 방법으로 사용할 때 Python은 데이터 유효성 검사에 태만한 면이 있습니다.\n\n그래서 이 프로젝트에서는 FastAPI와 Python의 강력한 데이터 유효성 검사 라이브러리인 Pydantic을 결합했습니다. 목표는 API를 가볍고 데이터 품질 및 유효성 검사 측면에서 엄격하고 강력하게 만드는 것이었습니다. 예를 들어, 평범한 사전 대신 영화 디텍티브 API는 Pydantic에서 제공하는 BaseModel에서 상속된 사용자 정의 클래스를 엄격하게 사용합니다. 이겢은 예시로 퀴즈를 위한 구성입니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nclass QuizConfig(BaseModel):\n    vote_avg_min: float = Field(5.0, ge=0.0, le=9.0)\n    vote_count_min: float = Field(1000.0, ge=0.0)\n    popularity: int = Field(1, ge=1, le=3)\n    personality: str = Personality.DEFAULT.name\n    language: str = Language.DEFAULT.name\n```\n\n이 예제는 올바른 유형뿐만 아니라 실제 값에 대한 추가 유효성 검사도 보장됩니다.\n\n더욱이 최신 Python 기능, 예를 들어 StrEnum을 사용하여 특정 유형(예: 성격)을 구별합니다:\n\n```js\nclass Personality(StrEnum):\n    DEFAULT = 'default.jinja'\n    CHRISTMAS = 'christmas.jinja'\n    SCIENTIST = 'scientist.jinja'\n    DAD = 'dad.jinja'\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n또한, 사용자 지정 데코레이터를 정의하여 중복 코드를 피합니다. 예를 들어, 다음 데코레이터는 GCP 비용을 관리하기 위해 오늘의 퀴즈 세션 수를 제한합니다:\n\n```js\ncall_count = 0\nlast_reset_time = datetime.now()\n\ndef rate_limit(func: callable) -> callable:\n    @wraps(func)\n    def wrapper(*args, **kwargs) -> callable:\n        global call_count\n        global last_reset_time\n\n        # 날짜가 변경되었을 경우 호출 횟수를 초기화합니다.\n        if datetime.now().date() > last_reset_time.date():\n            call_count = 0\n            last_reset_time = datetime.now()\n\n        if call_count >= settings.quiz_rate_limit:\n            raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail='일일 한도 도달')\n\n        call_count += 1\n        return func(*args, **kwargs)\n\n    return wrapper\n```\n\n그런 다음 관련 API 함수에 간단히 적용됩니다:\n\n```js\n@app.post('/quiz')\n@rate_limit\n@retry(max_retries=settings.quiz_max_retries)\ndef start_quiz(quiz_config: QuizConfig = QuizConfig()):\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n최신 Python 기능과 FastAPI, Pydantic 또는 Ruff와 같은 라이브러리의 조합은 백엔드를 더 간결하게 만들어주지만 여전히 매우 안정적이며 특정 데이터 품질을 보장하여 LLM(언어 모델) 출력이 예상대로 나오도록 합니다.\n\n# httpx를 사용한 TMDB 클라이언트\n\nTMDB 클라이언트 클래스는 httpx를 사용하여 TMDB API에 대한 요청을 수행합니다.\n\nhttpx는 Python 라이브러리 세계에서 주목받는 존재입니다. 오랫동안 HTTP 요청을 수행하는 데 사용되었던 requests에 대안으로 httpx가 제공됩니다. 그 중요한 강점 중 하나는 비동기 기능입니다. httpx를 사용하면 동시에 여러 요청을 처리할 수 있는 코드를 작성할 수 있어, HTTP 상호작용이 많은 응용 프로그램에서 상당한 성능 향상을 기대할 수 있습니다. 게다가 httpx는 requests와의 넓은 호환성을 지향하여 개발자가 더 쉽게 익힐 수 있게 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n젬니미 무비 디텍티브 서비스에서는 주로 두 가지 요청이 있어요:\n\n- get_movies: 특정 설정(평균 투표 수 등)에 기반하여 랜덤 영화 목록을 가져옵니다.\n- get_movie_details: 퀴즈에 사용할 특정 영화의 세부 정보를 가져옵니다.\n\n외부 요청 양을 줄이기 위해 뒷 부분의 함수는 lru_cache 데코레이터를 사용합니다. 이는 \"Least Recently Used cache\"의 약자로, 함수 호출의 결과를 캐시하여 같은 입력이 다시 발생하면 함수가 결과를 다시 계산할 필요가 없게 합니다. 대신, 캐시된 결과를 반환하며, 특히 계산 비용이 많이 드는 함수의 경우 프로그램 성능을 크게 향상시킬 수 있습니다. 이 경우에는 1024개의 영화 세부 정보를 캐시하므로, 두 플레이어가 동일한 영화를 받을 경우 요청을 다시 보낼 필요가 없어요:\n\n```js\n@lru_cache(maxsize=1024)\ndef get_movie_details(self, movie_id: int):\n    response = httpx.get(f'https://api.themoviedb.org/3/movie/{movie_id}', headers={\n        'Authorization': f'Bearer {self.tmdb_api_key}'\n    }, params={\n        'language': 'en-US'\n    })\n\n    movie = response.json()\n    movie['poster_url'] = self.get_poster_url(movie['poster_path'])\n\n    return movie\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nTMDB(The Movie Database)의 데이터에 액세스하는 것은 비상업적 용도로 무료입니다. API 키를 생성하고 요청을 시작할 수 있습니다.\n\n# Gemini LLM 클라이언트와 VertexAI\n\nGemini를 통해 VertexAI를 사용하기 위해서는 VertexAI가 활성화된 Google Cloud 프로젝트와 충분한 액세스 권한을 가진 서비스 계정 및 해당 JSON 키 파일이 필요합니다.\n\n![이미지](/assets/img/2024-05-20-CreateanAI-DrivenMovieQuizwithGeminiLLMPythonFastAPIPydanticRAGandmore_5.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n신규 프로젝트를 생성한 후 APIs 및 서비스로 이동하십시오. API 및 서비스 활성화 - VertexAI API를 검색하여 활성화합니다.\n\n![이미지](/assets/img/2024-05-20-CreateanAI-DrivenMovieQuizwithGeminiLLMPythonFastAPIPydanticRAGandmore_6.png)\n\n서비스 계정을 생성하려면 IAM 및 관리자로 이동하십시오. 서비스 계정 - 서비스 계정 생성을 선택합니다. 적절한 이름을 선택한 다음 다음 단계로 이동합니다.\n\n![이미지](/assets/img/2024-05-20-CreateanAI-DrivenMovieQuizwithGeminiLLMPythonFastAPIPydanticRAGandmore_7.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 계정에 미리 정의된 역할 Vertex AI 사용자를 할당해주세요.\n\n![image](/assets/img/2024-05-20-CreateanAI-DrivenMovieQuizwithGeminiLLMPythonFastAPIPydanticRAGandmore_8.png)\n\n마지막으로, '새 사용자 - 키 - 키 추가 - 새 키 생성 - JSON'을 클릭하여 JSON 키 파일을 생성하고 다운로드할 수 있습니다. 이 파일이 있으면 준비 완료입니다.\n\n![image](/assets/img/2024-05-20-CreateanAI-DrivenMovieQuizwithGeminiLLMPythonFastAPIPydanticRAGandmore_9.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nGoogle의 Gemini와 Python을 사용하여 VertexAI를 통해 작업을 시작하려면 다음과 같이 프로젝트에 필요한 종속성을 추가해야 합니다:\n\n```js\npoetry add 'google-cloud-aiplatform>=1.38'\n```\n\n이제 JSON 키 파일을 사용하여 vertexai를 가져와 초기화할 수 있습니다. 또한 새로 출시된 Gemini 1.5 Pro 모델과 같은 모델을 로드하고 다음과 같이 채팅 세션을 시작할 수 있습니다:\n\n```js\nimport vertexai\nfrom google.oauth2.service_account import Credentials\nfrom vertexai.generative_models import GenerativeModel\n\nproject_id = \"my-project-id\"\nlocation = \"us-central1\"\n\ncredentials = Credentials.from_service_account_file(\"credentials.json\")\nmodel = \"gemini-1.0-pro\"\n\nvertexai.init(project=project_id, location=location, credentials=credentials)\nmodel = GenerativeModel(model)\n\nchat_session = model.start_chat()\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 chat.send_message()를 사용하여 모델에 프롬프트를 전송할 수 있습니다. 그러나 데이터 조각들로 응답을 받게 되므로, 간단한 도우미 함수를 사용하는 것을 추천합니다. 이렇게 하면 단순히 전체 응답을 하나의 문자열로 받게 됩니다:\n\n```js\ndef get_chat_response(chat: ChatSession, prompt: str) -> str:\n    text_response = []\n    responses = chat.send_message(prompt, stream=True)\n    for chunk in responses:\n        text_response.append(chunk.text)\n    return ''.join(text_response)\n```\n\n이제 전체 예제는 이렇게 보일 수 있습니다:\n\n```js\nimport vertexai\nfrom google.oauth2.service_account import Credentials\nfrom vertexai.generative_models import GenerativeModel, ChatSession\n\nproject_id = \"my-project-id\"\nlocation = \"us-central1\"\n\ncredentials = Credentials.from_service_account_file(\"credentials.json\")\nmodel = \"gemini-1.0-pro\"\n\nvertexai.init(project=project_id, location=location, credentials=credentials)\nmodel = GenerativeModel(model)\n\nchat_session = model.start_chat()\n\n\ndef get_chat_response(chat: ChatSession, prompt: str) -> str:\n    text_response = []\n    responses = chat.send_message(prompt, stream=True)\n    for chunk in responses:\n        text_response.append(chunk.text)\n    return ''.join(text_response)\n\n\nresponse = get_chat_response(\n    chat_session,\n    \"How to say 'you are awesome' in Spanish?\"\n)\nprint(response)\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n젠티미니가 다음과 같은 응답을 제공했습니다:\n\n![Gemini Response](/assets/img/2024-05-20-CreateanAI-DrivenMovieQuizwithGeminiLLMPythonFastAPIPydanticRAGandmore_10.png)\n\n저도 젠티미니의 의견에 동의합니다:\n\n이를 사용할 때 또 다른 팁: send_message 함수의 generation_config 매개변수를 통해 생성 구성을 설정할 수도 있습니다. 예를 들어:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\ngeneration_config = {\n  temperature: 0.5,\n};\n\nresponses = chat.send_message(\n  prompt,\n  (generation_config = generation_config),\n  (stream = True)\n);\n```\n\n저는 Gemini Movie Detectives에서 온도를 0.5로 설정하기 위해 이것을 사용하고 있습니다. 이는 최상의 결과를 제공했습니다. 이 문맥에서 온도란 무엇이죠? 바로 Gemini가 생성하는 응답이 얼마나 창의적인지를 나타냅니다. 이 값은 0.0과 1.0 사이여야 하며, 1.0에 가까울수록 더 많은 창의성을 의미합니다.\n\n프롬프트를 보내고 Gemini에서 받은 응답을 분석하여 관련 정보를 추출하는 것 이외에 중요한 도전 과제 중 하나입니다.\n\n프로젝트에서 배운 점 중 하나는:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n예를 들어, Gemini의 질문 프롬프트에는 다음 지침이 포함되어 있습니다:\n\n```js\n귀하의 답변은 반드시 세 줄로만 이루어져야 합니다! 다음 템플릿을 엄격히 준수하여 세 줄로만 회신해야 합니다:\n질문: <귀하의 질문>\n힌트 1: <참가자를 돕기 위한 첫 번째 힌트>\n힌트 2: <보다 쉽게 제목을 얻기 위한 두 번째 힌트>\n```\n\n쓸데없는 방식은, Question:으로 시작하는 줄을 찾아 응답을 구문 분석하는 것입니다. 그러나 독일어와 같은 다른 언어를 사용하면, 응답은 Antwort:으로 시작합니다.\n\n대신, 구조와 주요 기호에 집중하세요. 이 답변은 다음과 같이 읽어주세요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 테이블 태그를 Markdown 형식으로 변경하실수 있나요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그 외에도, 저는 Gemini 클라이언트를 구성 가능한 클래스로 래핑했습니다. 전체 구현은 Github에서 오픈 소스로 확인하실 수 있어요.\n\n# Jinja를 활용한 모듈식 프롬프트 생성기\n\n프롬프트 생성기는 Jinja2 템플릿 파일을 결합하고 렌더링하여 모듈식 프롬프트를 생성하는 클래스입니다.\n\n질문을 생성하는 하나의 기본 템플릿과 답변을 평가하는 하나의 기본 템플릿이 있습니다. 그 외에도 최신 영화 데이터로 프롬프트를 보강하는 메타데이터 템플릿이 있습니다. 더 나아가, 언어 및 성격 템플릿이 있으며, 각 옵션에 대한 템플릿 파일이 있는 별도의 폴더로 구성되어 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-05-20-CreateanAI-DrivenMovieQuizwithGeminiLLMPythonFastAPIPydanticRAGandmore_11.png\" />\n\nJinja2를 사용하면 템플릿 상속과 같은 고급 기능을 사용할 수 있습니다. 이는 메타데이터에 사용됩니다.\n\n이를 통해 이 구성 요소를 더 많은 인물과 언어 옵션으로 확장하고 더 이상의 오픈 소스 프로젝트로 추출하여 다른 Gemini 프로젝트에서도 사용할 수 있습니다.\n\n# 프론트엔드\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n젬니니 무비 디텍티브 프론트엔드는 네 가지 주요 구성 요소로 나뉘어 있으며, vue-router를 사용하여 이들 간에 이동합니다.\n\n홈 컴포넌트는 환영 메시지를 단순히 표시합니다.\n\n퀴즈 컴포넌트는 퀴즈 자체를 표시하고 fetch를 통해 API와 통신합니다. 퀴즈를 생성하려면, 원하는 설정으로 api/quiz로 POST 요청을 보내고, 백엔드는 사용자 설정을 기반으로 무작위 영화를 선택하고 모듈식 프롬프트 생성기를 사용하여 프롬프트를 만들고, 젬니를 사용하여 질문과 힌트를 생성하여 최종적으로 모든 것을 컴포넌트로 다시 반환하여 퀴즈를 렌더링할 수 있도록 합니다.\n\n게다가 각 퀴즈는 백엔드에서 세션 ID가 할당되고 제한된 LRU 캐시에 저장됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n디버깅 목적으로이 구성 요소는 api/sessions 엔드포인트에서 데이터를 가져옵니다. 이는 캐시에서 모든 활성 세션을 반환합니다.\n\n이 구성 요소는 서비스에 대한 통계를 표시합니다. 그러나 지금까지 표시된 데이터 카테고리는 퀴즈 한도뿐입니다. VertexAI 및 GCP 사용 비용을 제한하기 위해 퀴즈 세션의 일일 한도가 있으며, 다음 날 첫 퀴즈로 재설정됩니다. 데이터는 api/limit 엔드포인트에서 검색됩니다.\n\n![이미지](/assets/img/2024-05-20-CreateanAI-DrivenMovieQuizwithGeminiLLMPythonFastAPIPydanticRAGandmore_12.png)\n\n# API 예제\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n당연히 프론트엔드를 사용하여 애플리케이션과 상호작용하는 것이 좋지만, API만 사용하여도 가능합니다.\n\n다음 예제는 Santa Claus / Christmas 성격을 이용해 API를 통해 퀴즈를 시작하는 방법을 보여줍니다:\n\n```js\ncurl -s -X POST https://movie-detectives.com/api/quiz \\\n  -H 'Content-Type: application/json' \\\n  -d '{\"vote_avg_min\": 5.0, \"vote_count_min\": 1000.0, \"popularity\": 3, \"personality\": \"christmas\"}' | jq .\n```\n\n```js\n{\n  \"quiz_id\": \"e1d298c3-fcb0-4ebe-8836-a22a51f87dc6\",\n  \"question\": {\n    \"question\": \"Ho ho ho, this movie takes place in a world of dreams, just like the dreams children have on Christmas Eve after seeing Santa Claus! It's about a team who enters people's dreams to steal their secrets. Can you guess the movie? Merry Christmas!\",\n    \"hint1\": \"The main character is like a skilled elf, sneaking into people's minds instead of houses. \",\n    \"hint2\": \"I_c_p_i_n \"\n  },\n  \"movie\": {...}\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 예시는 퀴즈 언어를 변경하는 방법을 보여줍니다:\n\n```js\ncurl -s -X POST https://movie-detectives.com/api/quiz \\\n  -H 'Content-Type: application/json' \\\n  -d '{\"vote_avg_min\": 5.0, \"vote_count_min\": 1000.0, \"popularity\": 3, \"language\": \"german\"}' | jq .\n```\n\n```js\n{\n  \"quiz_id\": \"7f5f8cf5-4ded-42d3-a6f0-976e4f096c0e\",\n  \"question\": {\n    \"question\": \"Stellt euch vor, es gäbe riesige Monster, die auf der Erde herumtrampeln, als wäre es ein Spielplatz! Einer ist ein echtes Urviech, eine Art wandelnde Riesenechse mit einem Atem, der so heiß ist, dass er euer Toastbrot in Sekundenschnelle rösten könnte. Der andere ist ein gigantischer Affe, der so stark ist, dass er Bäume ausreißt wie Gänseblümchen. Und jetzt ratet mal, was passiert? Die beiden geraten aneinander, wie zwei Kinder, die sich um das letzte Stück Kuchen streiten! Wer wird wohl gewinnen, die Riesenechse oder der Superaffe? Das ist die Frage, die sich die ganze Welt stellt! \",\n    \"hint1\": \"Der Film spielt in einer Zeit, in der Monster auf der Erde wandeln.\",\n    \"hint2\": \"G_dz_ll_ vs. K_ng \"\n  },\n  \"movie\": {...}\n}\n```\n\n그리고 API 호출을 통해 퀴즈에 대답하는 방법입니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\ncurl -s -X POST https://movie-detectives.com/api/quiz/84c19425-c179-4198-9773-a8a1b71c9605/answer \\\n  -H 'Content-Type: application/json' \\\n  -d '{\"answer\": \"Greenland\"}' | jq .\n```\n\n```js\n{\n  \"quiz_id\": \"84c19425-c179-4198-9773-a8a1b71c9605\",\n  \"question\": {...},\n  \"movie\": {...},\n  \"user_answer\": \"Greenland\",\n  \"result\": {\n    \"points\": \"3\",\n    \"answer\": \"Congratulations! You got it! Greenland is the movie we were looking for. You're like a human GPS, always finding the right way!\"\n  }\n}\n```\n\n# 결론\n\n기본 프로젝트를 완료한 후에 모듈형 프롬프트 접근 방식으로 더 많은 퍼스널리티와 언어를 추가하는 것이 쉬웠습니다. 이것은 게임 디자인 및 개발을 위한 가능성을 열어준 것에 감명받았습니다. 다른 퍼스널리티를 추가함으로써 순수한 영화 교육 게임에서 코미디 퀴즈 \"You Don't Know Jack\"과 같은 게임으로 한 분 내에 게임을 변경할 수 있었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그리고 여기서 마무리입니다! 이제 여러분은 자신만의 LLM을 활용한 웹 애플리케이션을 만들 준비가 되었어요.\n\n영감을 받았지만 시작점이 필요하다면 어떻게 시작할지 궁금하신가요? Gemini Movie Detectives 프로젝트의 오픈 소스 코드를 확인해보세요:\n\n- 🚀 백엔드의 Github 저장소: https://github.com/vojay-dev/gemini-movie-detectives-api\n- 🖥️ 프론트엔드의 Github 저장소: https://github.com/vojay-dev/gemini-movie-detectives-ui\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nAI 기반 애플리케이션의 미래는 밝으며, 당신이 페인트붓을 쥐고 있습니다! 함께 놀라운 것을 만들어봅시다. 그리고 쉬는 시간이 필요하다면 https://movie-detectives.com/을 자유롭게 이용해보세요!\n","ogImage":{"url":"/assets/img/2024-05-20-CreateanAI-DrivenMovieQuizwithGeminiLLMPythonFastAPIPydanticRAGandmore_0.png"},"coverImage":"/assets/img/2024-05-20-CreateanAI-DrivenMovieQuizwithGeminiLLMPythonFastAPIPydanticRAGandmore_0.png","tag":["Tech"],"readingTime":37},{"title":"Git-활성화된 패브릭 워크스페이스 사용을 위한 최상의 실천법","description":"","date":"2024-05-20 18:48","slug":"2024-05-20-BestPracticesforUsingGit-EnabledFabricWorkspaces","content":"\n효율적으로 데이터 파이프라인을 관리하는 것은 원활한 개발, 테스트 및 배포 프로세스를 보장하기 위한 중요한 요소입니다. Microsoft Fabric 작업 공간과 Git을 통합하면 이러한 파이프라인을 효과적으로 관리할 수 있습니다. 데이터 아키텍트 및 엔지니어로 전환하기 전에 다양한 소프트웨어 프로젝트에서 CI/CD를 활용하는 데 중점을 둔 소프트웨어 엔지니어였습니다. 이 게시물은 Git을 활용한 Fabric 작업 공간의 최선의 실천 방법을 이해하기 위해 그림을 활용한 나의 해석에 대해 다룹니다.\n\n![Diagram](/assets/img/2024-05-20-BestPracticesforUsingGit-EnabledFabricWorkspaces_0.png)\n\n이 그림은 Azure DevOps와 Microsoft Fabric 간의 통합을 개발 환경에서 제품 환경까지의 흐름을 보여줍니다.\n\n## Azure DevOps (Git)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n• Main Branch: 안정적인 릴리스를 위한 메인 브랜치입니다.\n\n• Develop Branch: 지속적인 개발을 위한 주요 브랜치입니다.\n\n• Feature Branches: 특정 기능 개발을 위한 브랜치입니다.\n\n## Microsoft Fabric (Workspaces)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 릴리스 파이프라인: 다양한 환경(개발, 스테이징, 프로덕션)으로의 릴리스를 관리합니다.\n- 개발 작업 공간: 개별 개발자 환경.\n\n# 최상의 실천 방법\n\n이것들은 대규모 또는 복잡한 Microsoft Fabric 프로젝트를 유지하는 데 도움이 되는 주요 배운 점입니다.\n\n## 브랜칭 전략\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n파이프라인, 노트북, 리포트, 데이터 웨어하우스, 레이크하우스 등을 작업할 수 있는 Fabric \"개발자\"들이 git을 배워야 합니다. 나는 많은 데이터 엔지니어가 분석가나 DBA 경로에서 왔다는 것을 경험상 알기에, git을 배우는 것이 어려울 수 있다는 걸 알고 있어요. 이들의 경력 초창기에 git을 배우지 않은 경우가 많았습니다. 그러나 특히 Microsoft Fabric에서 큰 프로젝트를 수행하는 경우에는 협업을 위해 git이 필수적입니다.\n\n기능 브랜치: 각 개발자는 자신의 기능이나 버그 수정을 위해 개발 브랜치의 브랜치를 만듭니다. Fabric을 네이티브로 사용하는 경우, \"MJ의 프로젝트 A 작업 공간\"과 같이 개인 작업 공간에 이를 연결할 수 있습니다. 작성 시점 기준으로 \"내 작업 공간\"을 Git으로 활성화할 수는 없으므로, 이를 위해 새로운 작업 공간을 할당해야 합니다. Power BI 리포트와 같은 경우 개발자가 Power BI 데스크톱을 사용하는 경우, 이 접근법 또한 작동하며 Fabric 작업 공간에 독립적입니다.\n\n개발 브랜치: 새로운 기능을 통합하고 본 브랜치로 병합하기 전에 테스트하는 데에 이 브랜치를 사용하세요. 개발자가 실수로 이 브랜치에 푸시하거나 풀 리퀘스트 없이 수정하지 못하도록 브랜치 정책을 구현해야 합니다. 이 프로세스는 다른 개발자의 작업을 배포하기 전에 누군가가 검토해야 한다는 것을 강제합니다.\n\n본 브랜치: 이 브랜치를 제품용 코드의 진리의 원천으로 유지하세요. 여기에는 안정적이고 테스트된 코드만 병합해야 합니다. 나중에 변경 내용을 롤백해야 하는 경우를 대비해 나중을 위해 충분한 태깅 전략을 사용하세요. 보너스로, 메인 브랜치에 유지된 히스토리가 두 가지다 하더라도 릴리스#1과 릴리스#75를 분리하는 릴리스 태그를 구현하는 것도 좋은 연습입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n메인 브랜치가 패브릭 워크스페이스에서 git을 사용할 수 없는 것에 유의해주세요. 워크스페이스에 연결된 브랜치는 개발 브랜치 뿐입니다. 다음 섹션에서 이에 대해 더 설명하겠습니다.\n\n## 패브릭 Git 통합\n\nMicrosoft 패브릭 워크스페이스(파워 BI 워크스페이스 포함)는 git 통합을 지원합니다. 현재는 Azure DevOps만 지원하고 있으며, GitHub 통합을 기다리고 있습니다.\n\n이를 위해 워크스페이스 설정을 클릭하고 \"Git 통합\" 탭으로 이동하세요. 이를 Azure DevOps에 연결하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![image1](/assets/img/2024-05-20-BestPracticesforUsingGit-EnabledFabricWorkspaces_1.png)\n\n통합을 위해 git 폴더를 추가하는 것을 추천하지 않습니다. Fabric는 분석을 위해 통합된 프로젝트로 표현되어야 합니다. 이는 응용 프로그램 소스 코드, 데이터베이스 스크립트 등을 저장소에 추가할 계획인 경우 복잡해지기 때문입니다. 이는 지원되지만, 개발자들이 Azure DevOps와 Fabric git 간에 컨텍스트 전환이 필요할 때 혼란스러울 수 있습니다.\n\n즉, 모든 이러한 파일들:\n\n![image2](/assets/img/2024-05-20-BestPracticesforUsingGit-EnabledFabricWorkspaces_2.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래와 같이 Azure DevOps 저장소에서 테이블 태그가 표시됩니다:\n\n![2024-05-20-BestPracticesforUsingGit-EnabledFabricWorkspaces_3.png](/assets/img/2024-05-20-BestPracticesforUsingGit-EnabledFabricWorkspaces_3.png)\n\n## 작업 공간 관리\n\n![2024-05-20-BestPracticesforUsingGit-EnabledFabricWorkspaces_4.png](/assets/img/2024-05-20-BestPracticesforUsingGit-EnabledFabricWorkspaces_4.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이미 이전에 언급한대로, 개발자들은 기능 브랜치를 워크스페이스에 연결합니다. 이 방식의 단점 또는 \"불편함\"은 개발자들이 새로운 기능을 개발할 때 이 프로세스를 반복해야 한다는 점입니다. 미래에는 \"원 클릭 워크스페이스 생성\" 기능이 있으면 더 원할텐데, 이 기능은 일시적인 워크스페이스를 의도한 것입니다. 그러나 반대로, 보통 기능 개발에는 몇 일이 걸리기 때문에 매주 한두 번 이 프로세스를 수행해야 한다는 것은 익숙해지면 나쁘지 않습니다.\n\n![이미지](/assets/img/2024-05-20-BestPracticesforUsingGit-EnabledFabricWorkspaces_5.png)\n\n기능 브랜치에서의 풀 리퀘스트가 개발 브랜치로 병합되면, Fabric에서 개발 워크스페이스로 동기화됩니다. 이 워크스페이스는 여러 개발자들 사이에서 \"놀이터\"로 공유됩니다. 여기서 개발자들은 여기서 실험하고 실수를 할 수 있으며, 엔드 투 엔드 파이프라인과 보고서가 어떻게 나타나는지 확인할 수 있습니다. 대부분의 경우, 이 워크스페이스는 개발자가 액세스 권한을 갖고 있는 데이터 소스에도 연결됩니다.\n\n여기서 Git과 릴리스 관리 간의 분리선이 깨지게 됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 릴리스 관리\n\n![이미지](/assets/img/2024-05-20-BestPracticesforUsingGit-EnabledFabricWorkspaces_6.png)\n\n가장 먼저 눈에 띄는 것은 스테이징과 프로덕션 워크스페이스가 Git에 연결되어 있지 않다는 점입니다. 이 접근 방식을 선택한 이유에는 여러 가지 이유가 있습니다.\n\n- 개발과 배포의 역할과 책임을 분리하기 위함입니다. 2~3명의 개발자로 구성된 팀에서는 큰 문제가 아니지만 대규모 팀에서는 더 나은 접근 방식일 수 있습니다. 모든 사람이 누가 어떤 플랫폼 및 기능에 액세스 권한이 있는지 잘 알 수 있기 때문에 관리자들이 특정 정책 및 액세스를 관리하는 데 도움이 됩니다.\n- \"비개발자\"는 Git을 사용할 필요가 없습니다. 대규모 조직에서는 이해관계자 및 임원과 같은 다른 역할이 Git을 사용할 필요가 없을 수 있습니다. 그러나 반대로 보고서를 보고 권한을 행사하고 싶어할 것입니다. 이 접근 방식은 이러한 시나리오에서 잘 작동합니다.\n- 승인 시나리오. 스테이징 및 프로덕션으로의 릴리스 승인을 위해 누군가가 Git을 통해 확인할 필요가 없습니다. 대규모 조직에서는 적절한 릴리스 프로세스가 있지만 이 방식의 장점은 사실 \"매니저\"나 승인자가 개발자가 브랜치를 병합하는 대신 버튼을 클릭할 수 있다는 것입니다. 감사 추적은 관리자 X가 배포를 승인했음을 말할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-05-20-BestPracticesforUsingGit-EnabledFabricWorkspaces_7.png\" />\n\n## 요약 및 도전 과제\n\n어떤 방식이든 의견이 갈리는 점이 있고, 이는 제가 다룬 대규모 Fabric 구현에 적합한 방식입니다. 이 방법이 가장 적합하지 않은 시나리오도 있습니다:\n\n- 소규모 팀 (모든 작업을 하는 2명의 개발자)\n- 멀티테넌시, 즉 스테이징과 프로덕션에 서로 다른 도메인이 있는 경우 (Entra ID). 이는 더 복잡한 기업 내 관계에도 적용됩니다.\n- Azure DevOps에 액세스할 수 없는 경우 (당연히)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n요약하면, 이 방법은 팀으로 작업하고 협업하는 데 도움이 되기 위해 Microsoft fabric 작업 공간에 Git를 활용하는 접근 방식입니다. 주요 강조점은 다음과 같습니다:\n\n- 각 개발자는 자체 기능 브랜치와 Fabric 작업 공간에서 작업해야 합니다.\n- 개발 브랜치를 사용하여 기능 브랜치를 병합하고 동료 검토를 촉진합니다. 그런 다음 개발 브랜치를 Fabric의 개발 작업 공간에 동기화합니다.\n- Fabric 배포 파이프라인에서 배포를 수행하며 Git의 범위를 벗어납니다. 그러나 어떤 프로덕션 릴리스든 버전 관리 목적을 위해 메인 브랜치에도 태깅 및 표시되도록 해야 합니다.\n\n이 다이어그램의 더 간단한 버전도 있습니다. 여기에는 메인 브랜치만 사용합니다. 이는 좋은 시작점이 될 수도 있습니다.\n\n![다이어그램](/assets/img/2024-05-20-BestPracticesforUsingGit-EnabledFabricWorkspaces_8.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 방법에 대해 어떻게 생각하시나요? 놓친 부분이 있나요? 더 좋은 대안이 있다고 생각하시나요? 댓글로 알려주세요.\n","ogImage":{"url":"/assets/img/2024-05-20-BestPracticesforUsingGit-EnabledFabricWorkspaces_0.png"},"coverImage":"/assets/img/2024-05-20-BestPracticesforUsingGit-EnabledFabricWorkspaces_0.png","tag":["Tech"],"readingTime":8},{"title":"실시간 데이터 파이프라인 구축하기","description":"","date":"2024-05-20 18:45","slug":"2024-05-20-BuildingaReal-TimeDataPipeline","content":"\n## 카프카(Kafka), 폴라스(Polars), 델타 레이크(Delta Lake)를 활용한 실시간 분석\n\n데이터 엔지니어라면 언젠가는 실시간 데이터에 대한 비즈니스 요구사항을 직면해야 할 것입니다. 이는 빨리 오겠다는 것이 확실합니다. 실시간 데이터 처리는 기업이 신속하게 정보 기반 결정을 내릴 수 있도록 필수적으로 중요해지고 있으며, 아파치 카프카는 확장 가능하고 오류 허용성 있는 실시간 데이터 파이프라인을 구축하기 위한 인기 있는 플랫폼으로 부상했습니다.\n\n이 기사에서는 카프카, 폴라스, 델타 레이크를 사용하여 실시간 데이터 파이프라인을 만드는 방법을 실제로 보여드리겠습니다. 그리 어렵지 않습니다! 자신도 이를 시도할 수 있는 코드는 여기에서 확인하실 수 있습니다. 유용하다고 느끼신다면 ⭐️을 주세요.\n\n기술적인 기사가 될 예정이니, 코드 스니펫이 많이 포함될 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 따라오기 시작하기 위해 설정해야 할 사항\n\n시작하기 위해 몇 가지 구성 요소를 설정해 두었습니다:\n\nKafka 브로커: Docker Compose를 사용하여 Kafka와 Zookeeper 컨테이너를 실행했습니다. docker-compose.yml 파일에는 필요한 서비스와 구성이 정의되어 있습니다. 이에 대해 자세히 다루지는 않겠습니다. 이 파일은 어디에서든 다운로드할 수 있는 기본적인 docker-compose.yml입니다. 데이터 엔지니어링 팀이 Kafka 환경을 관리하는 것으로 간주하지 않겠습니다. 당신이 담당하고 있는 플랫폼 또는 데브옵스 팀이 그 역할을 맡고 있을 것이라고 가정하겠습니다.\n\n발행자: Python 스크립트인 publisher.py를 만들었습니다. 이 스크립트는 일련의 csv 파일에 저장된 샘플 데이터를 Kafka 주제에 발행합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n구독자님: 새로운 Python 스크립트인 subscriber.py를 만들었어요. 이 스크립트는 Kafka 토픽에서 메시지를 가져와 Polars를 사용하여 Delta 테이블에 쓰는 역할을 해요.\n\n질문: 추가적으로 한 가지 더, query.py라는 마지막 Python 스크립트를 만들었어요. 이 스크립트는 Delta 테이블에 포함된 데이터를 가져와 조인하고, 조인된 데이터를 포함한 데이터프레임을 화면에 출력합니다.\n\n매개변수: Python 스크립트 내에 설정 매개변수를 저장하는 대신 toml 파일을 사용했어요. 이렇게 하면 매개변수를 변경하고 싶어도 코드를 손대지 않아도 돼요.\n\n# 단순히 실행만 하려면\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n원하는 부분으로 건너뛰고 싶으세요? 알겠어요! 여기 실행하는 순서입니다:\n\n먼저 Kafka 브로커를 실행하려면 Docker가 설치되어 있어야 합니다. 메인 폴더 내에서 docker-compose up을 실행할 수 있어요. 먼저 몇 가지 파일을 다운로드해야 하며, 그 후에 프로세스들이 시작되면 화면에 많은 텍스트가 표시될 거예요:\n\n![이미지](/assets/img/2024-05-20-BuildingaReal-TimeDataPipeline_0.png)\n\n그 다음으로, publisher용 새 터미널 세션을 열고, subscriber용 또 다른 터미널 세션을 열어 보세요. Docker 컨테이너를 설정하지는 않았지만, 이들을 독립적인 Docker 컨테이너로 설정할 방법에 대해 알아보고 싶다면 이 기사를 확인해 보세요. 대신, 새로운 가상 Python 환경을 만들어서 그 안에 설치할 걸 권장드려요. python3 -m venv venv로 가상 환경을 생성한 다음 venv/bin/activate를 입력하여 새로운 가상 환경으로 전환하고, requirements.txt에 정의된 필수 패키지를 pip install -r로 설치하시면 됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n모든 준비가 완료되었습니다. 먼저 터미널 창에서 subscriber.py를 실행한 후, 준비가 되면 publisher.py를 실행하세요. publisher에서 전송된 마이크로 배치를 볼 수 있으며, 동시에 subscriber가 실시간으로 수신하는 것을 볼 수 있을 겁니다. 그러나 subscriber와 publisher를 올바른 순서로 로드해야 합니다. subscriber가 준비되기 전에 publisher가 모두 보내버리는 일이 없도록 주의하세요. 이 경량 데모에서는 보관 기간을 설정하지 않았으니 주의해주세요.\n\n아래 스크린샷을 보면, 왼쪽에 publisher가 있고 오른쪽에 subscriber가 있는 분할 된 터미널이 있습니다. 왼쪽에서 전송되는 일괄처리된 데이터를 보고, 오른쪽에서는 개별 레코드가 처리되는 것을 볼 수 있습니다.\n\n![Publisher 및 Subscriber 스크린샷](/assets/img/2024-05-20-BuildingaReal-TimeDataPipeline_1.png)\n\n모든 레코드가 전송된 후에는 publisher가 연결을 종료할 것입니다. subscriber는 프로세스가 종료될 때까지 계속 수신 대기 상태에 머무를 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n마지막 단계는 query.py 파일을 실행하여 다른 화면을 로드하고 쿼리 결과를 확인하는 것입니다. 화면에 DataFrame이 출력되는데, 이겇이 우리의 작업 결과입니다. 이러한 csv 파일 각각이 Kafka를 통해 Delta 테이블로 이동되었으며, 이제 올바른 데이터 유형과 필드 이름을 가진 단일 DataFrame으로 변환되었습니다. 필요하다면, 발행물을 시작하는 동시에 실행할 수 있으며, 여러 번 실행하면 데이터가 흐르는 것을 확인할 수 있습니다.\n\n![이미지](/assets/img/2024-05-20-BuildingaReal-TimeDataPipeline_2.png)\n\n여기까지입니다! 몇 개의 csv 파일을 Kafka를 통해 마이크로 배치로 로드한 다음 이를 Delta 테이블로 다운스트림으로 스트리밍했습니다. 그 후 데이터를 쿼리하고 변환하여 직원, 부서, 고객, 판매 일자, 판매 지역 및 판매 금액을 모두 포함한 단일 DataFrame으로 통합했습니다.\n\n만약 궁금하시다면, 각 테이블의 기본 키를 기반으로 파일을 로드하기 위해 병합 프로세스를 사용했습니다. 그래서 데이터를 변경하고 다시로드하면 Delta 테이블에서 데이터를 우아하게 업데이트할 수 있습니다. 아래에서 csv에서 Finance 부서 레코드를 FinTech로 변경하고 두 번째로 실행했더니 어떻게 변경되는지 확인해보세요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/assets/img/2024-05-20-BuildingaReal-TimeDataPipeline_3.png)\n\n계속 읽어 보면 어떻게 작동하는지 알 수 있어요...\n\n# 발행자\n\n발행자 스크립트는 데이터를 Kafka로 보내는 데 사용됩니다. 전체 파일은 여기에서 찾을 수 있어요. 일부 구성을 설정한 후, 파일을 시작하는 지점인 아래쪽에서 여정을 시작해요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nif __name__ == \"__main()\":\n    producer = create_producer(bootstrap_servers)\n\n    try:\n        process_files_and_send(producer, topics, batch_size)\n    finally:\n        producer.close()\n```\n\n카프카 프로듀서를 producer로 인스턴스화하고 서버 세부 정보를 전달했습니다. 그런 다음 파일을 처리하려고 시도하고 완료되면 연결을 닫습니다. 간단하죠! 이제 파일의 맨 위로 돌아가서 각 함수를 하나씩 작업할 수 있습니다.\n\n## create_producer\n\n```js\ndef create_producer(bootstrap_servers):\n    return KafkaProducer(\n        bootstrap_servers=bootstrap_servers,\n        value_serializer=lambda v: json.dumps(v).encode(\"utf-8\")\n    )\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여기에는 그다지 많은 내용이 없어요. 저는 단순히 KafkaProducer를 함수로 래핑하여 제 개인적인 것으로 만들었어요. 서버 세부 정보를 전달하고, 매개변수인 v를 취하고 해당 매개변수로 전달된 내용을 JSON으로 변환하는 람다 함수를 사용했어요. 그 JSON은 UTF-8로 인코딩되어요. 많은 데이터 처리 함수가 문자열 대신 바이트 형식의 데이터를 예상하기 때문에 이것은 필수적입니다.\n\n## send_messages\n\n```js\ndef send_messages(producer, topic, messages):\n    try:\n        for message in messages:\n            producer.send(topic, value=message)\n        producer.flush()\n        logging.info(f\"Batch of messages sent to topic '{topic}'.\")\n    except Exception as e:\n        logging.error(f\"Failed to send messages to topic '{topic}'. Error: {e}\")\n```\n\n저는 아직 클래스를 사용하지 않았기 때문에 다음에 이것을 설정하고 있어요. 실제로 사용될 때 미리 로드되고 준비되어 있어야 해요. 여기서는 Kafka로 데이터를 전송하려고 노력해요. 각 메시지마다 Kafka Producer를 사용하고 메시지를 주제로 보내요. 그런 다음 보낸 것을 기록하거나 필요한 경우 발생한 오류를 기록해 내용이 잘못됐는지 조사할 수 있어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## process_files_and_send\n\n```js\ndef process_files_and_send(producer, topics, batch_size):\n    for topic in topics:\n        try:\n            with open(f\"{raw_path}/{topic}.csv\", encoding=\"utf-8-sig\") as csvfile:\n                csvreader = csv.DictReader(csvfile)\n                batch = []\n\n                for rows in csvreader:\n                    batch.append(rows)\n                    if len(batch) >= batch_size:\n                        send_messages(producer, topic, batch)\n                        batch = []\n\n                # Send any remaining messages in the last batch\n                if batch:\n                    send_messages(producer, topic, batch)\n\n        except FileNotFoundError:\n            logging.error(f\"File not found: {raw_path}/{topic}.csv\")\n        except Exception as e:\n            logging.error(f\"Error processing file for topic '{topic}': {e}\")\n```\n\n여기가 번잡한 부분이고, 데이터를 보내는 작업을 마치게 될 거야.\n\n제가 프로듀서를 맨 처음에 인스턴스화할 때 전달하고, 토픽들도 함께 전달해주는 함수를 만들었어요. 그런 다음 각 토픽을 순회하면서 처리해요. 각 토픽은 csv 파일과 관련이 있기 때문에, 먼저 파일을 열려고 시도하는 거죠.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n배치 크기를 입력 매개변수로 정의했다는 것을 알 수 있을 겁니다. 이건 정말 필수적인 것은 아니지만, csv 파일에서 데이터를 가져오는 대신에 웹페이지나 다른 스트리밍 서비스에서 가져오는 것이 아니기 때문에, 메시지를 배치로 묶어서 그룹으로 보내고 싶었습니다. 이렇게 하면 작업이 빨라집니다. 저는 toml 파일 내에서 배치 크기를 10으로 설정했는데, 이는 사실상 한 번에 csv 파일의 10줄에 해당합니다.\n\n그런 다음 각 행을 배치에 추가하면서 배치 한도에 도달할 때까지 작업을 수행한 후 데이터를 전송하고 배치를 비웁니다. 작업을 마치면 마지막 메시지로 배치를 정리합니다 (남은 레코드가 5개만 남았을 수 있지만, 그래도 모두 보내고 싶습니다).\n\n마지막으로, raw 파일을 찾을 수 없는 경우나 발생할 수 있는 기타 일반적인 오류에 대한 오류 처리가 있습니다.\n\n이것이 publisher.py 파일의 내용입니다. 이해가 되시겠나요? 이제 subscriber.py 파일로 넘어가 봅시다!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 구독자\n\n구독자는 Kafka 주제를 청취하고, 새 레코드를 발견했을 때 특정 작업을 수행하는 데 사용됩니다. 이 경우, 해당 레코드의 내용을 가져와 Delta 테이블에 저장합니다. 여기서 전체 코드를 찾을 수 있는 코드를 통해 코드를 하나씩 살펴보겠습니다.\n\n```js\nif __name__ == \"__main__\":\n    consumer = create_consumer(topics, bootstrap_servers)\n    for message in consumer:\n        process_message(message.topic, message.value)\n```\n\n발행자와 비슷하게, 첫 번째로 하는 일은 주제 및 서버 세부 정보를 구성 변수로 제공하고, 이를 전달하여 소비자를 인스턴스화하는 것입니다. 그런 다음 소비한 각 메시지를 처리합니다. 간단하지요. 하지만 함수별로 좀 더 자세히 살펴보겠습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 소비자 생성\n\n```js\ndef create_consumer(topics, bootstrap_servers):\n    return KafkaConsumer(\n        *topics,\n        bootstrap_servers = bootstrap_servers,\n        value_deserializer = lambda v: json.loads(v.decode(\"utf-8\"))\n```\n\n우리 Python의 진입점에서 첫 번째 줄은 소비자를 인스턴스화하는 것이었습니다. 이것은 기본적으로 KafkaConsumer의 래퍼일 뿐입니다. 퍼블리셔와 다른 것은 아무 것도 하지 않습니다.\n\n## 메시지 처리\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\ndef process_message(topic, data):\n    df = pl.from_records([data])\n    delta_table_path = f\"{delta_path}/{topic}\"\n    if not os.path.exists(delta_table_path):\n        write_delta_table(df, delta_table_path, \"insert\")\n    else:\n        merge_into_delta_table(df, delta_table_path)\n```\n\n메시지를 받을 때마다 그것을 처리하는 방법을 알아야 합니다. 저는 여기서 두 가지 방법을 선택했습니다. 먼저 Delta 테이블이 저장된 경로를 가져와 해당 경로가 존재하는지 확인합니다. 경로가 존재하지 않으면 새 레코드를 삽입하기 위해 insert 매개변수를 사용하여 write_delta_table 함수를 호출합니다. 그러나 경로가 이미 존재한다면, merge_into_delta_table 함수를 호출합니다. 이를 통해 데이터를 여러 번로드할 수 있게 하면서 단순히 테이블을 점점 더 크게 만들지 않습니다. 이미 변경된 기존 항목을 업데이트하고 새 레코드만 추가합니다.\n\n이러한 함수들을 좀 더 자세히 살펴봅시다.\n\n## write_delta_table\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\ndef write_delta_table(df, path, mode):\n    try:\n        df.write_delta(target=path, mode=mode)\n        logging.info(f\"{mode.capitalize()}ed message to Delta table: {df}\")\n    except Exception as e:\n        logging.error(f\"Failed to {mode} message to Delta table: {df}\")\n        logging.error(f\"Error: {e}\")\n```\n\n테이블 태그를 마크다운 형식으로 변경해주시기 바랍니다.\n\n여기서는 DataFrame, 주제 경로, 그리고 모드(삽입)를 간단히 전달하고 네이티브 Polars 기능을 사용하여 Delta 테이블에 작성합니다. 작업이 성공했음을 로그에 남기거나 실패했을 때 오류를 캡처하여 조사할 수 있도록 합니다.\n\n## merge_into_delta_table\n\n여기에는 조금 더 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\ndef merge_into_delta_table(df, path):\n    try:\n        df.write_delta(\n            target=path, mode=\"merge\",\n            delta_merge_options={\n                \"predicate\": \"s.id = t.id\",\n                \"source_alias\": \"s\",\n                \"target_alias\": \"t\",\n            }\n        ).when_matched_update_all().when_not_matched_insert_all().execute()\n        logging.info(f\"Merged message to Delta table: {df}\")\n    except Exception as e:\n        logging.error(f\"Failed to merge message to Delta table: {df}\")\n        logging.error(f\"Error: {e}\")\n```\n\n여기에서 모드를 전달하지 않아도 됩니다. 왜냐하면 모드가 \"merge\"로 설정될 것이라는 것을 알기 때문입니다. 제 모든 테이블에는 id라는 동일한 이름을 가진 기본 키가 있으므로 한 번 정의하고 이 함수를 완전히 재사용하기 쉽습니다. 일치하는 경우 데이터가 업데이트되고, 일치하지 않는 경우 데이터가 삽입됩니다. 이것이 기본적으로 upsert입니다. 성공과 실패를 여전히 기록했습니다.\n\n여기가 파이프라인의 전부입니다. 정말 간단합니다. 데이터를 게시하고 데이터를 구독하여 디스크에 저장합니다. 다음에는 해당 데이터를 쿼리하고 모든 것을 함께 가져오는 DataFrame을 가져오는 방법을 살펴볼 것입니다.\n\n# 쿼리\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 시점에서 Kafka는 더 이상 사용되지 않습니다. 모든 것이 Delta 테이블에 있으며 쿼리만 필요합니다. 전체 코드는 여기에 있습니다. Delta 테이블을 각각 데이터프레임 집합으로 불러오기 시작했습니다:\n\n```js\nclient = pl.read_delta(f\"{delta_path}/client\")\ndepartment = pl.read_delta(f\"{delta_path}/department\")\nemployee = pl.read_delta(f\"{delta_path}/employee\")\nsale = pl.read_delta(f\"{delta_path}/sale\")\n```\n\nclient와 employee 데이터프레임에는 first_name과 last_name 속성이 같습니다. 데이터프레임 이름 외에는 구별할 요소가 없습니다. 각각에 first_name과 last_name을 붙여 공백을 구분자로 사용한 새로운 속성을 추가하고 적절히 이름을 지었습니다. 이렇게 하면 두 데이터프레임을 하나의 데이터프레임으로 결합할 때 무엇이 무엇인지 알 수 있습니다:\n\n```js\nclient = client.with_columns(\n  pl\n    .concat_str([\"first_name\", \"last_name\"], (separator = \" \"))\n    .alias(\"client_name\")\n);\n\nemployee = employee.with_columns(\n  pl\n    .concat_str([\"first_name\", \"last_name\"], (separator = \" \"))\n    .alias(\"employee_name\")\n);\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n직원 DataFrame에는 department_id라는 추가 속성이 포함되어 있습니다. 이를 사용하여 직원과 부서를 함께 결합한 새 DataFrame을 생성할 수 있어요:\n\n```js\nemployee_dept = employee\n  .join(\n    department,\n    (left_on = \"department_id\"),\n    (right_on = \"id\"),\n    (how = \"inner\")\n  )\n  .select([\"id\", \"employee_name\", \"department_id\", \"department\"]);\n```\n\n직원 DataFrame을 기반으로, 부서 DataFrame과 조인을 생성했는데, 직원 DataFrame의 department_id와 부서 DataFrame의 id를 일치하는 조인 조건으로 지정했어요. 모든 직원이 부서를 가져야 하기 때문에 INNER JOIN을 조인 유형으로 선택했고, 이후 유지할 속성을 선택했어요.\n\n마지막으로, 한 마지막 문장으로 모두 함께 결합할 수 있어요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\ncomplete = sale\n  .join(employee_dept, (left_on = \"employee_id\"), (right_on = \"id\"))\n  .join(client, (left_on = \"client_id\"), (right_on = \"id\"), (how = \"inner\"))\n  .select(\n    pl.col(\"id\").str.to_integer(),\n    pl.col(\"employee_name\"),\n    pl.col(\"department\"),\n    pl.col(\"client_name\"),\n    pl.col(\"date\").str.to_date(\"%d/%m/%Y\"),\n    pl.col(\"region\"),\n    pl.col(\"sale\").str.to_decimal(2)\n  );\n```\n\n저는 sale DataFrame에서 시작하여 방금 생성한 employee_dept DataFrame에 조인을 수행합니다. 이제 이는 sale, employee 및 department를 결합하는 것입니다. 그런 다음 client DataFrame을 다시 조인한 다음 원하는 속성을 선택합니다. 그러나 이 경우 데이터 유형을 변경했습니다. 데이터는 csv를 통해 가져온 것이기 때문에 원래 데이터 유형이 없었습니다. 따라서 id는 정수이어야 한다고 지정했습니다. 날짜는 날짜 유형이어야 하며, 형식을 지정했으며, sale 속성이 두 자리 소수점(달러 및 센트)인 것을 지정했습니다.\n\n마지막 단계는 결과를 출력하는 것입니다:\n\n<img src=\"/assets/img/2024-05-20-BuildingaReal-TimeDataPipeline_4.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 결론\n\n본 글에서는 Kafka, Polars, 그리고 Delta Lake를 활용하여 실시간 데이터 파이프라인을 구축하는 방법을 살펴보았습니다. 메시지 스트리밍을 위해 Kafka를 활용하고, 데이터 처리를 위해 Polars를 사용하며, 안정적인 저장소로 Delta Lake를 활용하여 확장 가능하고 오류 허용성 있는 데이터 파이프라인을 만들 수 있습니다.\n\n저장소의 코드 샘플은 파이프라인의 기본 설정과 기능을 보여줍니다. 데이터 보존 정책 구성, S3 객체 저장소에 데이터 보관, 다른 시스템과 통합하는 등 특정 요구 사항에 맞게 코드를 확장하고 사용자화할 수 있습니다.\n\n이 아키텍처를 채택함으로써 기업은 실시간 데이터를 효율적으로 처리하고 분석하여 데이터 기반 결정을 내리고 신속하게 변화에 대응할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 글이 유용했길 바랍니다. 만약 그렇다면 👏 한 번 눌러주시겠어요? 그리고 더 보고 싶으면 구독해주세요. 매주 한 두 편의 글을 업로드하고 있어요.\n","ogImage":{"url":"/assets/img/2024-05-20-BuildingaReal-TimeDataPipeline_0.png"},"coverImage":"/assets/img/2024-05-20-BuildingaReal-TimeDataPipeline_0.png","tag":["Tech"],"readingTime":18},{"title":"제목 Python, Jinja2 및 NiceGUI를 사용하여 독특한 Gemini AI-챗봇 만들기","description":"","date":"2024-05-20 18:41","slug":"2024-05-20-CreateyourownGeminiAI-chatbotwithatwistusingPythonJinja2andNiceGUI","content":"\n## 파이썬을 사용하여 베르텍스AI를 통해 Gemini의 기본 사항을 알아보고 NiceGUI를 사용하여 웹 UI를 만들며 모듈식 프롬프트를 구성하는 Jinja2를 사용하는 방법\n\n![이미지](/assets/img/2024-05-20-CreateyourownGeminiAI-chatbotwithatwistusingPythonJinja2andNiceGUI_0.png)\n\n본문에서는 Python, NiceGUI, Jinja2 및 VertexAI를 사용하여 LLM 기반 웹 애플리케이션을 만들어보겠습니다. 이 프로젝트를 처음부터 만드는 방법과 기본 개념의 개요를 얻을 수 있습니다.\n\n먼저 🚀 기술 스택에 대한 간단한 개요로 시작해 보겠습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- Python 3.12\n- NiceGUI를 사용하여 파이썬으로 프론트엔드를 코딩합니다.\n- 의존성 관리를 위해 Poetry 사용\n- 모듈식 프롬프트 생성을 위해 Jinja2 템플릿 사용\n\n# Poetry를 사용한 프로젝트 설정\n\n우리는 Python에서 의존성 관리와 패키징을 위한 도구인 Poetry를 사용하여 프로젝트를 생성하고 의존성을 어떻게 관리하는지 살펴볼 것입니다.\n\nPoetry가 도와줄 수 있는 세 가지 주요 작업은 빌드, 게시 및 추적입니다. 의존성을 관리하고 프로젝트를 공유하며 의존성 상태를 추적할 수 있는 결정론적인 방법이 되는 것이 아이디어입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n시, Poetry는 가상 환경을 생성하는 작업도 담당합니다. 기본적으로 시스템 내의 중앙 폴더에 위치하는데요. 하지만 저와 같이 프로젝트 관련 가상 환경을 프로젝트 폴더 내에 가지고 싶다면, 간단한 설정 변경이 필요합니다:\n\n```js\npoetry config virtualenvs.in-project true\n```\n\nPoetry new를 사용하여 새로운 Python 프로젝트를 만들 수 있습니다. 이 작업은 시스템의 기본 Python과 링크되는 가상 환경이 생성됩니다. 이것을 pyenv와 결합하면 특정 버전을 사용하는 프로젝트를 유연하게 만들 수 있습니다. 또한, Poetry에 직접 사용할 Python 버전을 알려줄 수도 있습니다: poetry env use /full/path/to/python.\n\n새 프로젝트를 생성하면, poetry add로 종속성을 추가할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n새 프로젝트를 만들어 시작해봐요:\n\n```js\npoetry config virtualenvs.in-project true\npoetry new my-gemini-chatbot\ncd my-gemini-chatbot\n```\n\n프로젝트에 대한 메타데이터 및 해당 버전과 종속성은 .toml 및 .lock 파일에 저장됩니다.\n\n<img src=\"/assets/img/2024-05-20-CreateyourownGeminiAI-chatbotwithatwistusingPythonJinja2andNiceGUI_1.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 시작하기 위해 필요한 종속성을 추가해 봅시다:\n\n```js\npoetry add 'google-cloud-aiplatform>=1.38'\npoetry add 'nicegui'\n```\n\n# NiceGUI를 사용한 기본 웹 UI\n\nNiceGUI는 웹 브라우저용 그래픽 사용자 인터페이스(GUI)를 만들 수 있게 해주는 Python 라이브러리입니다. 초보자들도 빠르게 시작할 수 있지만, 고급 사용자들을 위한 맞춤 설정 옵션도 풍부하게 제공합니다. 웹 뷰는 Quasar Framework를 기반으로 하며, 다양한 구성 요소를 제공합니다. 그리고 이는 TailwindCSS를 사용하기 때문에 NiceGUI 페이지에서도 직접 TailwindCSS 클래스를 사용할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n특히 나에게는 백엔드 소프트웨어 개발에서 온 데이터 엔지니어로써, Python을 사용하여 작은 웹 UI를 만드는 것은 좋은 방법입니다. 물론 더 복잡한 프론트엔드에 대해서는 충분한 해결책이 되지 않을 수도 있지만, 범위가 상대적으로 작다면 빠르게 결과를 확인할 수 있습니다. NiceGUI를 사용하면 Python 코드에 집중할 수 있습니다. 왜냐하면 NiceGUI가 모든 웹 개발 작업을 처리하기 때문입니다.\n\nNiceGUI는 버튼, 슬라이더, 텍스트 상자와 같은 일반적인 UI 구성 요소를 사용하고 유연한 레이아웃을 사용하여 페이지에 배열합니다. 이러한 구성 요소는 Python 코드의 데이터와 연결될 수 있어 데이터가 변경될 때 인터페이스가 자동으로 업데이트됩니다. 또한 응용 프로그램의 외관을 필요에 맞게 스타일링할 수도 있습니다.\n\n이 작업 방식을 설명하는 가장 쉬운 방법은 직접 보여주는 것입니다. 그래서 최소 예제를 만들기 시작해 봅시다.\n\n내 경우에는 내 모듈의 main.py (내 경우 my_gemini_chatbot)를 생성합니다. 이 파일은 모든 어플리케이션과 프론트엔드 로직에 사용될 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음 코드로 간단한 레이블이 포함된 페이지를 얻을 수 있습니다:\n\n```js\nfrom nicegui import ui\n\nui.label('Hello NiceGUI!')\nui.run()\n```\n\n<img src=\"/assets/img/2024-05-20-CreateyourownGeminiAI-chatbotwithatwistusingPythonJinja2andNiceGUI_2.png\" />\n\n애플리케이션을 실행하면 포트 8080에서 사용할 수 있습니다. 또한 스크립트를 실행할 때 페이지가 자동으로 열립니다. 이것이 페이지가 보이는 방법입니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-05-20-CreateyourownGeminiAI-chatbotwithatwistusingPythonJinja2andNiceGUI_3.png\" />\n\n축하합니다: 순수 Python으로 만든 첫 프론트엔드 😉.\n\n# 챗봇 웹 UI 준비\n\n다음 단계는 우리 챗봇을 위한 웹 UI를 준비하는 것입니다. 물론, 위의 예제보다는 조금 더 복잡할 것이지만 NiceGUI를 사용하여 컴포넌트를 배치하는 기본 아이디어를 알면 더 쉬워질 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n먼저 몇 가지 레이아웃 기본 사항을 이해해야 합니다. 컴포넌트가 페이지 상에 배치되는 방식을 제어하는 여러 가지 방법이 있습니다. 일반적인 방법 중 하나는 그리드 레이아웃인데, 우리는 이를 사용할 것입니다.\n\nNiceGUI에서 우리는 다음과 같이 그리드를 생성할 수 있습니다:\n\n```js\nfrom nicegui import ui\n\nwith ui.grid(columns=16).classes(\"w-3/4 place-self-center gap-4\"):\n    ui.markdown(\"# 🚀 My Gemini Chatbot\").classes(\"col-span-full\")\n\nui.run()\n```\n\n이를 하나씩 분해하여 더 잘 이해해 봅시다. ui.grid(columns=16)은 16개의 열로 분할된 그리드 레이아웃을 초기화합니다. 이들은 모두 동일한 너비를 갖습니다. 이것은 그리드의 실제 너비에 대해 아무 말도 하지 않으며 그리드가 몇 개의 열로 나눠질지만을 지정합니다. 16개의 열로, 우리는 충분한 유연성을 얻을 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리는 .classes를 통해 사용자 정의 TailwindCSS 클래스를 추가할 수 있습니다. 여기서 우리는 그리드에 3가지 클래스를 추가했습니다:\n\n- w-3/4: 그리드는 항상 브라우저 전체 너비의 3/4을 차지해야 합니다.\n- place-self-center: 그리드 자체가 브라우저 창 가운데에 위치해야 합니다.\n- gap-4: 그리드 내 요소 사이에는 4개의 픽셀 간격이 있어야 합니다.\n\n위 예시에서는 그리드 안에 요소 하나를 배치했습니다:\n\n```js\nwith ui.grid(columns=16).classes(\"w-3/4 place-self-center gap-4\"):\n    ui.markdown(\"# 🚀 My Gemini Chatbot\").classes(\"col-span-full\")\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위에서 확인할 수 있듯이, 우리는 다시 col-span-full이라는 사용자 정의 클래스를 할당했습니다. 이는 NiceGUI에게 이 요소가 첫 번째 행의 모든 사용 가능한 열을 사용해야 함을 알려줍니다. 우리의 경우: 모든 16열을 사용합니다.\n\n모든 열의 양에 대한 클래스가 있으므로 첫 번째 요소에 col-span-10을 할당하고 두 번째 요소에 col-span-6을 할당하여 한 행에 2개의 요소를 채울 수도 있습니다.\n\n<img src=\"/assets/img/2024-05-20-CreateyourownGeminiAI-chatbotwithatwistusingPythonJinja2andNiceGUI_4.png\" />\n\n이 지식을 바탕으로 우리의 챗봇에 필요한 모든 요소를 추가할 수 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\nfrom nicegui import ui\n\nwith ui.grid(columns=16).classes(\"w-3/4 place-self-center gap-4\"):\n    ui.markdown(\"# 🚀 우리의 Gemini 챗봇\").classes(\"col-span-full\")\n    ui.input(label=\"프롬프트\").classes(\"col-span-10\")\n    ui.select(\n        options=[\"기본\", \"산타 클로스\"],\n        value=\"기본\",\n        label=\"성격 선택\"\n    ).classes(\"col-span-6\")\n    ui.button(\"Gemini로 전송\").classes(\"col-span-full\")\n\n    with ui.card().classes(\"col-span-full\"):\n        ui.markdown(\"## Gemini 응답\")\n        ui.separator()\n        ui.label(\"Gemini에 프롬프트를 보내고 응답을 여기서 확인하세요.\")\n\nui.run()\n```\n\n위의 코드는 다음과 같은 웹 UI를 만들어냅니다:\n\n<img src=\"/assets/img/2024-05-20-CreateyourownGeminiAI-chatbotwithatwistusingPythonJinja2andNiceGUI_5.png\" />\n\nPython으로 완전히 작성된 UI로는 꽤 괜찮은 결과가 나온 것 같네요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 기본 기능 추가하기\n\n우리의 다음 작업은 기본 기능을 추가하는 것입니다. 아직 VertexAI나 Gemini와 상호 작용하지는 않겠지만, Gemini로 전송 버튼을 클릭하면 사용자 입력을 반영하는 알림이 표시되도록 기능을 추가하려고 합니다.\n\n중요한 개념 하나를 설명해 드리겠습니다: 우리의 프론트엔드는 우리 Python 스크립트의 한 인스턴스에 의해 제공됩니다. 이제 사용자 입력을 전역 변수에 저장하고 있는데, 동시에 챗봇을 사용하고 있는 다른 사용자가 다른 값을 제출한다고 상상해 보십시오. 그러면 첫 번째 사용자의 값이 덮어쓰여지기 때문에 재밌지만 예상치 못한 동작이 발생할 것입니다.\n\n최근 NiceGUI에서는 이러한 상황을 다루기 위해 '저장소' 기능을 소개했습니다. 이는 데이터 지속성을 위한 간단한 메커니즘으로, 클라이언트 측에 데이터를 저장하는 것과 서버 측에 데이터를 저장하는 것을 포함한 다섯 가지 내장 저장 유형을 기반으로 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그러나 저장소 기능은 페이지 빌더의 컨텍스트에서만 사용할 수 있습니다. 기본적으로 이것은 다음을 의미합니다: 메인 스크립트에서 웹 페이지를 간단히 코딩하는 대신, 각 페이지마다 함수로 래핑합니다. 우리는 한 페이지만 가지고 있으므로 하나의 함수만 필요합니다: index(). 그런 다음 해당 함수가 메인 인덱스 페이지인 /로 정의된 페이지를 나타낸다고 NiceGUI에 알리기 위해 데코레이터를 사용합니다.\n\n이제 페이지 데코레이터를 사용하면 저장소 기능도 사용할 수 있습니다. 간단한 클라이언트 측 저장소를 사용할 것입니다. 이를 위해 nicegui에서 app을 가져와야하며, 다음과 같이 사전 기반 저장소인 app.storage.client에 액세스할 수 있습니다.\n\nNiceGUI의 또 다른 기능으로 데이터 작업을 쉽게 만들어주는 기능이 있습니다. 그 방법은 입력 요소를 변수에 바인딩하는 것입니다. 이렇게 함으로써 사용자 프롬프트를위한 입력 요소를 앞서 언급한 클라이언트 저장소에 저장된 변수에 바인딩할 수 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nui.input((label = \"Prompt\"))\n  .bind_value(app.storage.client, \"prompt\")\n  .classes(\"col-span-10\");\n```\n\n이제 입력 요소의 값은 항상 다음과 같이 액세스할 수 있습니다: app.storage.client.get(\"personality\").\n\n그리고 NiceGUI는 버튼 및 기타 요소에 on_click 매개변수를 정의할 수 있도록 합니다. 이 매개변수는 일반 Python 함수에 대한 참조를 취합니다. 이렇게 하면 웹 애플리케이션을 상호 작용 가능하게 할 수 있습니다.\n\n먼저 send() 함수를 소개하겠습니다. 나중에 Gemini LLM과 상호 작용하기 위해 사용할 것입니다. 현재 입력 양식의 현재 입력 값을 사용자에게 간단히 보여줄 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nfrom nicegui import ui, app\n\ndef send():\n    prompt = app.storage.client.get(\"prompt\")\n    personality = app.storage.client.get(\"personality\")\n    ui.notify(\n        f\"Prompt: {prompt}, Personality: {personality}\",\n        type=\"info\"\n    )\n\n@ui.page('/')\ndef index():\n    with ui.grid(columns=16).classes(\"w-3/4 place-self-center gap-4\"):\n        ui.markdown(\"# 🚀 My Gemini Chatbot\").classes(\"col-span-full\")\n        ui.input(label=\"Prompt\").bind_value(app.storage.client, \"prompt\").classes(\"col-span-10\")\n        ui.select(\n            options=[\"Default\", \"Santa Claus\"],\n            value=\"Default\",\n            label=\"Personality\"\n        ).bind_value(app.storage.client, \"personality\").classes(\"col-span-6\")\n        ui.button(\"Send to Gemini\", on_click=send).classes(\"col-span-full\")\n\n        with ui.card().classes(\"col-span-full\"):\n            ui.markdown(\"## Gemini Response\")\n            ui.separator()\n            ui.label(\"Send your prompt to Gemini and see the response here.\")\n\nui.run()\n```\n\n이제 사용자가 \"Send to Gemini\" 버튼을 클릭할 때마다, 입력 요소의 값이 표시되는 send() 함수를 통해 알림이 표시됩니다.\n\n![image](/assets/img/2024-05-20-CreateyourownGeminiAI-chatbotwithatwistusingPythonJinja2andNiceGUI_6.png)\n\n# Jinja2를 활용한 모듈화된 프롬프트들\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n시간이 되었어요! 🌪️ 사용자 프롬프트를 Gemini에 단순히 전송하는 대신, 사용자 입력을 기반으로 모듈식 프롬프트를 구성할 거에요. 그러면 프롬프트에 개성 부분을 프로그래밍적으로 추가해서 AI가 선택한 사용자에 따라 다른 성격으로 응답할 수 있어요.\n\nJinja2는 파이썬을 위한 템플릿 엔진이에요. Jinja2는 다양한 영역에서 동적 콘텐츠를 생성하는 데 도움이 되죠. 이는 로직과 표현을 분리하여 깨끗하고 유지보수 가능한 코드베이스를 유지할 수 있게 해줘요.\n\nJinja2는 다음과 같은 핵심 개념을 사용해요:\n\n- 템플릿: 사용 사례에 따라 내용이 포함된 텍스트 파일 (예: HTML, 설정 파일, SQL 쿼리).\n- 환경: 템플릿 구성을 관리해요 (예: 구분자, 자동 이스케이핑).\n- 변수: 이중 중괄호 ('' 변수 '')를 사용하여 템플릿에 삽입돼요.\n- 블록: '% ... %' 태그로 정의돼요 (예: 반복, 조건문을 위한) 제어 흐름.\n- 주석: 코드 가독성을 위해 '# ... #'로 묶여 있어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nJinja2은 웹 개발에서 많이 사용되지만, 동적 콘텐츠를 생성하는 데 유용하기 때문에 Airflow와 같은 다른 경우에도 사용됩니다.\n\n이 프로젝트에서는 특정 인격과 사용자 프롬프트로 대체되는 변수를 포함하는 일반 템플릿을 정의하는 데 사용할 것입니다. 이렇게 하면 Python 코드가 깔끔하게 유지되고 쉽게 확장할 수 있는 모듈식 솔루션을 갖게 됩니다. 스포일러: 나중에 매우 재미있는 인격을 소개할 예정입니다.\n\nJinja2를 사용하기 전에 프로젝트 의존성에 추가해야 합니다. Poetry를 사용하고 있으므로 다음을 통해 수행할 수 있습니다:\n\n```js\npoetry add jinja2\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리는 템플릿을 저장할 폴더도 필요합니다. 좋은 기본 사례는 모듈 폴더에 templates라는 폴더를 추가하는 것입니다. 그러니 이 경우에는:\n\n```js\nmkdir my_gemini_chatbot/templates\n```\n\n<img src=\"/assets/img/2024-05-20-CreateyourownGeminiAI-chatbotwithatwistusingPythonJinja2andNiceGUI_7.png\" />\n\nJinja2를 사용하려면 환경을 설정해야 합니다. 위에서 설명한 대로, 환경은 일반 템플릿 구성을 관리합니다. 우리는 간단하게 유지하고 Jinja2가 우리의 폴더에서 템플릿을 찾도록 만들겠습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nenv = Environment(\nloader=PackageLoader(\"my_gemini_chatbot\"),\nautoescape=select_autoescape()\n)\n\n이제 템플릿을 준비할 시간입니다. templates/ 폴더 내에 prompt.jinja, default.jinja 및 santaclaus.jinja 세 개의 파일을 생성하십시오. default.jinja 파일은 비워두세요. 기본 펄스널리티는 Gemini의 정상 동작일 것이므로요.\n\n![image](/assets/img/2024-05-20-CreateyourownGeminiAI-chatbotwithatwistusingPythonJinja2andNiceGUI_8.png)\n\n다음 내용을 prompt.jinja 템플릿에 추가해 봅시다. 이것은 기본 템플릿입니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n{ 성격 }\n\n{ 프롬프트 }\n\n이제, santaclaus.jinja에 다음 내용을 추가하여 산타클로스 성격을 정의해 봅시다:\n\n```js\n당신은 산타클로스이며 크리스마스를 사랑합니다. 당신의 답변에는 크리스마스와 관련된 사실과 퀴즈를 최대한 추가해 보세요. 또한 답변을 항상 엄격하게 \"Ho ho ho\"로 시작하고 \"메리 크리스마스\"로 끝내세요. 당신은 진정한 크리스마스 애호가입니다.\n```\n\n빠른 알림: 웹 UI에는 성격을 선택하는 select 요소가 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nui.select(\n  (options = [\"Default\", \"Santa Claus\"]),\n  (value = \"Default\"),\n  (label = \"성격\")\n)\n  .bind_value(app.storage.client, \"personality\")\n  .classes(\"col-span-6\");\n```\n\n작은 도우미 함수를 사용하겠습니다. 이 함수는 선택한 값을 템플릿 파일로 매핑합니다:\n\n```js\ndef get_personality_file(value):\n    match value:\n        case \"Default\":\n            return \"default.jinja\"\n        case \"Santa Claus\":\n            return \"santaclaus.jinja\"\n        case _:\n            return \"default.jinja\"\n```\n\n이제 이 도우미 함수와 Jinja2 환경의 get_template 기능을 사용하여 템플릿을 사용한 프롬프트를 만들 수 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\nfrom jinja2 import Environment, PackageLoader, select_autoescape\nfrom nicegui import ui, app\n\n\nenv = Environment(\n    loader=PackageLoader(\"my_gemini_chatbot\"),\n    autoescape=select_autoescape()\n)\n\n\ndef get_personality_file(value):\n    match value:\n        case \"Default\":\n            return \"default.jinja\"\n        case \"Santa Claus\":\n            return \"santaclaus.jinja\"\n        case _:\n            return \"default.jinja\"\n\n\ndef send():\n    user_prompt = app.storage.client.get(\"prompt\")\n    personality = app.storage.client.get(\"personality\")\n\n    personality_template = env.get_template(get_personality_file(personality))\n    prompt_template = env.get_template(\"prompt.jinja\")\n\n    prompt = prompt_template.render(\n        prompt=user_prompt,\n        personality=personality_template.render()\n    )\n\n    ui.notify(\n        f\"Prompt: {prompt}\",\n        type=\"info\"\n    )\n\n\n@ui.page('/')\ndef index():\n    with ui.grid(columns=16).classes(\"w-3/4 place-self-center gap-4\"):\n        ui.markdown(\"# 🚀 My Gemini Chatbot\").classes(\"col-span-full\")\n        ui.input(label=\"Prompt\").bind_value(app.storage.client, \"prompt\").classes(\"col-span-10\")\n        ui.select(\n            options=[\"Default\", \"Santa Claus\"],\n            value=\"Default\",\n            label=\"Personality\"\n        ).bind_value(app.storage.client, \"personality\").classes(\"col-span-6\")\n        ui.button(\"Send to Gemini\", on_click=send).classes(\"col-span-full\")\n\n        with ui.card().classes(\"col-span-full\"):\n            ui.markdown(\"## Gemini Response\")\n            ui.separator()\n            ui.label(\"Send your prompt to Gemini and see the response here.\")\n\n\nui.run()\n```\n\n지금 \"Send to Gemini\"을 클릭하면 Jinja2 템플릿을 기반으로 만든 모듈화된 프롬프트를 볼 수 있습니다.\n\n<img src=\"/assets/img/2024-05-20-CreateyourownGeminiAI-chatbotwithatwistusingPythonJinja2andNiceGUI_9.png\" />\n\n# VertexAI를 통해 Gemini LLM 통합하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n젬니아이(GeminiAI)를 사용하기 위해서는 VertexAI를 통해 Gemini에 연결하려면, VertexAI가 활성화된 Google Cloud 프로젝트와 충분한 액세스 권한을 가진 서비스 계정 및 해당 계정의 JSON 키 파일이 필요합니다.\n\n![](/assets/img/2024-05-20-CreateyourownGeminiAI-chatbotwithatwistusingPythonJinja2andNiceGUI_10.png)\n\n새 프로젝트를 생성한 후, APIs 및 서비스 - `API 및 서비스 활성화 -` VertexAI API 검색 - ` 활성화로 이동합니다.\n\n![](/assets/img/2024-05-20-CreateyourownGeminiAI-chatbotwithatwistusingPythonJinja2andNiceGUI_11.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n서비스 계정을 생성하려면 IAM 및 관리 - 서비스 계정 - 서비스 계정 만들기로 이동하십시오. 적절한 이름을 선택하고 다음 단계로 이동하십시오.\n\n![이미지](/assets/img/2024-05-20-CreateyourownGeminiAI-chatbotwithatwistusingPythonJinja2andNiceGUI_12.png)\n\n이제 계정에 미리 정의된 역할 Vertex AI 사용자를 할당하는지 확인하십시오.\n\n![이미지](/assets/img/2024-05-20-CreateyourownGeminiAI-chatbotwithatwistusingPythonJinja2andNiceGUI_13.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n마침내 새로운 사용자 → 키 → 키 추가 → 새 키 생성 → JSON을 클릭하여 JSON 키 파일을 생성하고 다운로드할 수 있습니다. 이 파일이 있으면 사용할 준비가 된 것입니다.\n\n![이미지](/assets/img/2024-05-20-CreateyourownGeminiAI-chatbotwithatwistusingPythonJinja2andNiceGUI_14.png)\n\nJSON 자격 증명 키 파일을 준비하고 프로젝트 내에 저장한 후에는 VertexAI를 초기화할 수 있습니다.\n\n```js\ncredentials = service_account.Credentials.from_service_account_file(\n  \"gcp-vojay-gemini.json\"\n);\nvertexai.init(\n  (project = \"vojay-329716\"),\n  (location = \"us-central1\"),\n  (credentials = credentials)\n);\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 VertexAI를 통해 모델을 로드할 수 있어요. 저희는 Gemini Pro 모델을 사용할 거예요.\n\n```js\nmodel = GenerativeModel(\"gemini-pro\");\n```\n\n이 모델은 대화를 시작하는 start_chat 함수를 제공해요. 이 함수는 Gemini에 데이터를 보내는 send_message 함수를 가진 Chat 객체를 반환해요. 여기서 generation config 매개변수를 조정할 수도 있어요. 여기서는 기본값을 사용할 거예요. Gemini로부터의 응답을 스트리밍하기 때문에, 전체 채팅 응답을 받기 위해 도우미 함수를 사용할 거에요:\n\n```js\ndef get_chat_response(chat, prompt):\n    text_response = []\n    responses = chat.send_message(prompt, stream=True)\n    for chunk in responses:\n        text_response.append(chunk.text)\n    return ''.join(text_response)\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그럼 이 정도면 괜찮네요. 우리는 준비된 프롬프트와 VertexAI가 초기화된 상태이며, 채팅 응답을 가져오는 도우미 함수를 사용하여 마침내 Gemini를 통합할 수 있게 되었어요.\n\n클라이언트 스토리지에서 변수에 바인딩된 레이블을 추가할 것이고, 이 레이블은 Gemini 응답을 저장하고 렌더링하는 데 사용될 거에요:\n\n```js\nui.label().bind_text(app.storage.client, \"response\");\n```\n\n이제 첫 번째 버전이 준비되었습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nimport vertexai\nfrom google.oauth2 import service_account\nfrom jinja2 import Environment, PackageLoader, select_autoescape\nfrom nicegui import ui, app\nfrom vertexai.generative_models import GenerativeModel\n\ncredentials = service_account.Credentials.from_service_account_file(\n    \"../gcp-vojay-gemini.json\"\n)\nvertexai.init(project=\"vojay-329716\", location=\"us-central1\", credentials=credentials)\n\nenv = Environment(\n    loader=PackageLoader(\"my_gemini_chatbot\"),\n    autoescape=select_autoescape()\n)\n\nmodel = GenerativeModel(\"gemini-pro\")\n\n\ndef get_chat_response(chat, prompt):\n    text_response = []\n    responses = chat.send_message(prompt, stream=True)\n    for chunk in responses:\n        text_response.append(chunk.text)\n    return ''.join(text_response)\n\n\ndef get_personality_file(value):\n    match value:\n        case \"Default\":\n            return \"default.jinja\"\n        case \"Santa Claus\":\n            return \"santaclaus.jinja\"\n        case _:\n            return \"default.jinja\"\n\n\ndef send():\n    user_prompt = app.storage.client.get(\"prompt\")\n    personality = app.storage.client.get(\"personality\")\n\n    personality_template = env.get_template(get_personality_file(personality))\n    prompt_template = env.get_template(\"prompt.jinja\")\n\n    prompt = prompt_template.render(\n        prompt=user_prompt,\n        personality=personality_template.render()\n    )\n\n    ui.notify(\"Sending to Gemini...\", type=\"info\")\n    chat = model.start_chat()\n    response = get_chat_response(chat, prompt)\n    ui.notify(\"Received response...\", type=\"info\")\n\n    app.storage.client[\"response\"] = response\n\n\n@ui.page('/')\ndef index():\n    with ui.grid(columns=16).classes(\"w-3/4 place-self-center gap-4\"):\n        ui.markdown(\"# 🚀 My Gemini Chatbot\").classes(\"col-span-full\")\n        ui.input(label=\"Prompt\").bind_value(app.storage.client, \"prompt\").classes(\"col-span-10\")\n        ui.select(\n            options=[\"Default\", \"Santa Claus\"],\n            value=\"Default\",\n            label=\"Personality\"\n        ).bind_value(app.storage.client, \"personality\").classes(\"col-span-6\")\n        ui.button(\"Send to Gemini\", on_click=send).classes(\"col-span-full\")\n\n        with ui.card().classes(\"col-span-full\"):\n            ui.markdown(\"## Gemini Response\")\n            ui.separator()\n            ui.label().bind_text(app.storage.client, \"response\")\n\n\nui.run()\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![GeminiAI Chatbot](/assets/img/2024-05-20-CreateyourownGeminiAI-chatbotwithatwistusingPythonJinja2andNiceGUI_16.png)\n\n# AI가 바에 들어가다\n\n저는 아빠가 된 이후로, 가능한 경우에 아빠 농담을 해주는 기회를 즐기고 있어요. 이 장에서는 Jinja2를 사용한 모듈식 접근 방법과 NiceGUI를 사용한 간단한 웹 UI의 이점을 설명하고 싶어 합니다.\n\n새로운 개성을 소개해보죠. dadjokes.jinja와 같이 다른 파일 옆에 새로운 템플릿 파일을 만들어 다음 내용을 추가하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n넌 자랍니다. 하지만, 거의 모든 문장에 아빠 농담을 추가해야 합니다. 답변에 가능한 한 많은 아빠 농담을 넣고, 입력과 관련된 농담을 만드려고 노력해주세요. 또한, 답변에 많은 이모지를 추가하고 싶어 금을 참지 못할 겁니다. 😉👨‍👧‍👦\n\n이를 실행하기 위해 우리는 우리의 도우미 함수인 get_personality_file을 확장해야 합니다. 👨‍💻\n\n```js\ndef get_personality_file(value):\n    match value:\n        case \"Default\":\n            return \"default.jinja\"\n        case \"Santa Claus\":\n            return \"santaclaus.jinja\"\n        case \"Dad Jokes\":\n            return \"dadjokes.jinja\"\n        case _:\n            return \"default.jinja\" 😄\n```\n\n그리고 우리의 입력 요소에 새 옵션을 추가하여 사용자가 새로운 옵션을 선택할 수 있도록 합시다. 🎁🧔\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nui.select(\n  (options = [\"기본\", \"산타 클로스\", \"아빠 Jokes\"]),\n  (value = \"기본\"),\n  (label = \"성격\")\n)\n  .bind_value(app.storage.client, \"personality\")\n  .classes(\"col-span-6\");\n```\n\n이제 해보기 전에 한 가지 더 구현해 봅시다. 다크 모드를 도입해 보겠습니다! NiceGUI를 사용하면 이 작업이 매우 간단합니다. ui.dark_mode()를 통해 UI 모드를 전환하기 위한 disable 및 enable 두 가지 함수를 제공하는 dark 객체를 얻을 수 있습니다. 그리드 접근 방식과 함께 사용하여 \"젬니니로 전송\" 버튼 옆에 UI 모드를 전환하는 두 개의 버튼을 쉽게 배치할 수 있습니다. 다음과 같이 코드 작성하세요:\n\n```js\nui.button(\"젬니니로 전송\", (on_click = send)).classes(\"col-span-8\");\n\ndark = ui.dark_mode();\nui.button(\"라이트 UI\", (on_click = dark.disable)).classes(\"col-span-4\");\nui.button(\"다크 UI\", (on_click = dark.enable)).classes(\"col-span-4\");\n```\n\n\"젬니니로 전송\" 버튼이 col-span-full 클래스 대신 col-span-8 클래스를 사용하고 있음을 알 수 있습니다. 또한 16개 열의 그리드를 사용하므로 바로 옆에 각각 col-span-4를 사용하여 두 개의 새로운 버튼을 추가할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n표를 Markdown 형식으로 바꾸는 방법은 다음과 같아요:\n\n| Function    | Description       |\n| ----------- | ----------------- |\n| ui.run()    | 애플리케이션 실행 |\n| ui.page()   | 페이지 만들기     |\n| ui.button() | 버튼 생성         |\n\n위와 같이 수정하시면 Markdown 형식으로 표를 작성할 수 있어요!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아빠로서 이걸 승인합니다 😂.\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*9xgCK0hrAI4XznUwk44o-w.gif)\n\n# 결론\n\n농담은 농담이고, 이 글을 통해 Gemini LLM을 기반으로 자체 AI 챗봇을 만들고 VertexAI와 함께 파이썬을 사용하여 NiceGUI로 간단한 웹 UI를 만드는 방법을 배웠습니다. Jinja2 템플릿을 사용하여, 이 비교적 짧은 예제조차도 확장하기 쉬운 모듈식 AI 애플리케이션을 제공했습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![GeminiAI Chatbot](/assets/img/2024-05-20-CreateyourownGeminiAI-chatbotwithatwistusingPythonJinja2andNiceGUI_18.png)\n\n파이썬, Jinja2 및 NiceGUI를 사용하면 VertexAI의 Gemini LLM과 상호 작용하는 사용자 친화적 인터페이스를 구축할 수 있습니다. 이를 통해 교육용 챗봇부터 재미있는 개성 기반 챗 체험까지 다양한 창의적인 응용 프로그램이 가능해집니다.\n\n이 블로그 글이 여러분들에게 VertexAI의 잠재력을 탐험하고 자체 AI 애플리케이션을 구축해보는데 영감을 줬기를 희망합니다.\n\n즐기고, 지시를 따르는 데 서툰 AI를 무엇이라고 부를까요? — 절망적 절자 없는 반란자.\n","ogImage":{"url":"/assets/img/2024-05-20-CreateyourownGeminiAI-chatbotwithatwistusingPythonJinja2andNiceGUI_0.png"},"coverImage":"/assets/img/2024-05-20-CreateyourownGeminiAI-chatbotwithatwistusingPythonJinja2andNiceGUI_0.png","tag":["Tech"],"readingTime":29}],"page":"78","totalPageCount":113,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":3},"__N_SSG":true}