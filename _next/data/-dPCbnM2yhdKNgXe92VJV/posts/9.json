{"pageProps":{"posts":[{"title":"SwiftUI 놀라운 UI 프레임워크의 매력 ","description":"","date":"2024-06-23 21:34","slug":"2024-06-23-SwiftUIWhataBeauty","content":"\n안녕하세요 여러분! 🎉\n\niOS 개발 여정을 함께 공유해 드릴 것에 흥분되고 있어요. 최근에 SwiftUI를 사용하여 애플리케이션을 개발했는데, 정말 멋진 경험이었어요!\n\n# 앱 소개\n\n이 앱은 초보자들이 다양한 프로그래밍 언어의 기초를 배울 수 있도록 설계되었어요. 다음을 포함합니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 자원 허브: 기본 사항을 학습하기 위한 포괄적인 자료 제공\n- 대화식 퀴즈: 여러 번 풀어서 학습을 강화할 수 있는 퀴즈로 지식을 테스트해보세요.\n- 다국어 지원: 현재 앱은 세 가지 다른 프로그래밍 언어에 대한 자습서를 제공합니다.\n\n아직 앱을 앱 스토어에 출시하지는 않았지만, 코드를 확인하고 피드백을 주시면 정말 감사하겠습니다. 앱을 계속 개선하고 확장하는 데 여러분의 통찰력은 귀중합니다.\n\n# 확인해보세요!\n\n여기에 제 프로젝트의 GitHub 링크가 있습니다. 코드를 살펴보고 앱을 시도해보시고 생각을 나눠주세요!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n피드백과 제안을 기다리고 있어요. 즐거운 코딩하세요! 🚀\n","ogImage":{"url":"/assets/img/2024-06-23-SwiftUIWhataBeauty_0.png"},"coverImage":"/assets/img/2024-06-23-SwiftUIWhataBeauty_0.png","tag":["Tech"],"readingTime":2},{"title":"MVVM 아키텍처에서 필드 검증하는 방법 초보자를 위한 가이드","description":"","date":"2024-06-23 21:32","slug":"2024-06-23-FieldValidationinMVVMArchitectureABeginersGuide","content":"\n<img src=\"/assets/img/2024-06-23-FieldValidationinMVVMArchitectureABeginersGuide_0.png\" />\n\n# 소개\n\n현대 앱 개발 분야에서 사용자 입력이 유효하고 안전한지 확인하는 것은 중요합니다. 특히 사용자 등록 프로세스에서 이는 매우 중요해집니다. MVVM(Model-View-ViewModel)과 같은 아키텍처 패턴에 진입하는 초보자들에게는 필드 유효성 검사를 포함하는 것이 어렵게 느껴질 수 있습니다. 이 문서는 특별히 이러한 목적을 위해 디자인된 코드 조각의 실제 예제를 사용하여 이 프로세스를 명확하게 설명하는 것을 목표로 합니다.\n\n# MVVM 아키텍처 이해하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n필드 유효성 검사의 구체적인 내용에 대해 들어가기 전에 MVVM 아키텍처를 간단히 살펴보겠습니다. MVVM은 Model-View-ViewModel의 약자입니다. GUI(그래픽 사용자 인터페이스) 개발을 비즈니스 로직 또는 백엔드 로직(데이터 모델)과 분리하는 구조적 디자인 패턴입니다. 'View'는 UI를 나타내며, 'ViewModel'은 공개 속성과 명령을 노출하는 뷰의 추상화입니다. 'Model'은 데이터 및 경우에 따라 비즈니스 로직을 나타냅니다.\n\n# MVVM에서의 유효성 검사 프로세스\n\n인포그래픽은 앱 개발에서 Model-View-ViewModel (MVVM) 패턴 내에서 사용자 데이터 유효성 검사가 어떻게 발생하는지를 설명합니다. 이 프로세스에서 주요 단계는 다음과 같습니다:\n\n![Field Validation in MVVM Architecture](/assets/img/2024-06-23-FieldValidationinMVVMArchitectureABeginersGuide_1.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 뷰:\n\n- 사용자들이 등록 양식 필드에 데이터를 입력합니다.\n- 텍스트 필드 같은 시각적 요소가 사용자 입력을 수집합니다.\n\n## 뷰와 ViewModel 간 통신:\n\n- 뷰에 입력된 데이터는 ViewModel로 전달됩니다.\n- 이는 데이터 바인딩을 통해하거나 ViewModel에서 메소드를 호출함으로써 이루어질 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## ViewModel:\n\n- ViewModel은 받은 데이터를 처리합니다.\n- 데이터 유효성 검사는 ValidationFieldsHelper와 같은 메서드를 사용하여 수행됩니다.\n- ViewModel은 유효성 검사 결과에 따라 어떤 작업을 수행할지 결정합니다 (예: 등록 버튼 활성화).\n\n## ViewModel에서 View로의 통신:\n\n- ViewModel은 유효성 검사 결과를 View로 다시 보냅니다.\n- 이 결과를 바탕으로 View는 UI를 업데이트할 수 있습니다. 예를 들어 텍스트 필드의 테두리 색상을 변경(오류는 빨강, 올바른 입력은 초록)하거나 오류 메시지를 표시할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 모델:\n\n- 성공적인 검증 후, ViewModel은 모델과 상호 작용하여 사용자 데이터를 저장하거나 다른 비즈니스 로직과 관련된 작업을 수행할 수 있습니다.\n\n# 필드 유효성 검사\n\n필드 유효성 검사는 사용자 등록 프로세스에서 필수적입니다. 사용자가 입력한 데이터가 처리되거나 저장되기 전에 특정 기준을 충족시켜야 함을 보장합니다. 이는 보안을 향상시키는데 그치지 않고 사용자 오류를 미리 잡아내고 사용자를 올바르게 안내하여 사용자 경험을 향상시킵니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```swift\n구조 ValidationFieldsHelper {\n\n    static func isValidName(_ name: String) -> Bool {\n        let namePredicate = NSPredicate(format:\"SELF MATCHES %@\", \"^[a-zA-Z ]+$\")\n        return namePredicate.evaluate(with: name)\n    }\n\n    static func isValidEmail(_ email: String) -> Bool {\n        let emailPredicate = NSPredicate(format:\"SELF MATCHES %@\", \"[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,}\")\n        return emailPredicate.evaluate(with: email)\n    }\n\n    static func isValidPassword(_ password: String) -> Bool {\n        let passwordRegex = \"^(?=.*[A-Za-z])(?=.*\\\\d)(?=.*[@$!%*?&])[A-Za-z\\\\d@$!%*?&]{8,}$\"\n        let passwordPredicate = NSPredicate(format:\"SELF MATCHES %@\", passwordRegex)\n        return passwordPredicate.evaluate(with: password)\n    }\n\n    static func isValidAge(_ age: String) -> Bool {\n        let ageRegex = \"^[0-9]{1,2}$\"\n        let agePredicate = NSPredicate(format:\"SELF MATCHES %@\", ageRegex)\n        return agePredicate.evaluate(with: age)\n    }\n}\n```\n\nSwift의 ValidationFieldsHelper 구조는 필드 유효성 검사를 위한 정적 메서드를 사용하여 코드 조직화와 가독성을 높입니다. 구조체는 인스턴스 생성 없이 관련 기능을 캡슐화하는 방법을 제공하며, 이는 유효성 검사와 같은 상태가 없는 유틸리티 함수에 이상적입니다. 정적 메서드를 사용하면 이러한 유틸리티 함수를 쉽게 재사용하고 애플리케이션 전반에 액세스할 수 있게 합니다. 이들은 코드에 네임스페이스와 유사한 구조를 제공하여 충돌을 방지하고 단순함을 유지합니다. 이 접근 방식을 통해 애플리케이션에서 효율적이고 명확한 유효성 검사 프로세스를 구현할 수 있습니다.\n\n# MVVM의 모델: UserRegistrationModel\n\n## 모델의 역할 이해\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nMVVM 아키텍처에서 Model은 어플리케이션의 데이터와 비즈니스 로직을 나타냅니다. 사용자 등록에 대한 맥락에서 UserRegistrationModel은 사용자 등록과 관련된 모든 정보를 보유하는 데이터 구조 역할을 합니다.\n\n## UserRegistrationModelProtocol\n\n```swift\nprotocol UserRegistrationModelProtocol: Codable {\n    var id: Int? { get }\n    var username: String? { get }\n    var email: String? { get }\n    var firstName: String? { get }\n    var lastName: String? { get }\n    var gender: String? { get }\n    var image: String? { get }\n    var token: String? { get }\n    var age: String? { get }\n\n    var asData: Data? { get }\n}\n```\n\n목적: 사용자 등록 모델에 필요한 속성과 기능을 개요화하는 프로토콜을 정의합니다. Codable을 준수하면 데이터의 직렬화와 역직렬화가 쉬워집니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n주요 기능: asData 계산 속성이 특히 주목할 만합니다. 이는 모델 인스턴스를 Data로 쉽게 변환하는 편리한 방법을 제공하며, 네트워크 통신이나 로컬 저장에 유용합니다.\n\n## Encodable에 대한 확장\n\n```swift\nextension Encodable {\n    var asData: Data? {\n        try? JSONEncoder().encode(self)\n    }\n}\n```\n\n기능: Encodable에 대한 이 확장은 준수하는 모든 타입이 자신을 손쉽게 Data로 변환할 수 있습니다. JSON 인코딩을 처리하기 위한 유용한 유틸리티입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 사용자 등록 모델 구조체\n\n```swift\nstruct UserRegistrationModel: UserRegistrationModelProtocol {\n    var id: Int?\n    var username: String?\n    var email: String?\n    var firstName: String?\n    var lastName: String?\n    var gender: String?\n    var image: String?\n    var token: String?\n    var age: String?\n}\n```\n\n구현: 이 구조체는 UserRegistrationModelProtocol을 구현합니다. 사용자를 등록하는 데 필요한 속성을 모두 포함하고 있습니다. 사용자 이름, 이메일, 성, 성, 등이 포함됩니다.\n\n유연성: 프로토콜을 준수함으로써 UserRegistrationModel은 일관성과 확장성을 보장하여, 미래에 쉬운 수정이나 확장이 가능합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# MVVM 아키텍처의 ViewModel: RegistrationViewModel\n\nUserRegistrationModel 구조체를 검토한 후, 이러한 유효성 검사 메서드가 RegistrationViewModel 클래스를 통해 MVVM 아키텍처에 통합되는 방법을 살펴보겠습니다. 이 클래스는 UI와 데이터 로직 및 유효성 규칙을 연결하는 데 중요한 역할을 합니다.\n\n## 개요\n\n```js\nclass RegistrationViewModel {\n\n    private var userFirstName = \"\"\n    private var userLastName = \"\"\n    private var userEmail = \"\"\n    private var userPassword = \"\"\n    private var userAge = \"\"\n\n    var isUserFirstNameValid: ((Bool) -> ())!\n    var isUserLastNameValid: ((Bool) -> ())!\n    var isUserEmailValid: ((Bool) -> ())!\n    var isUserPasswordValid: ((Bool) -> ())!\n    var isUserAgeValid: ((Bool) -> ())!\n\n    func setUpUserFirstName(userFirstName: String) {\n        self.userFirstName = userFirstName\n        ValidationFieldsHelper.isValidName(userFirstName) ? isUserFirstNameValid(true) : isUserFirstNameValid(false)\n    }\n\n    func setUpUserLastName(userLastName: String) {\n        self.userLastName = userLastName\n        ValidationFieldsHelper.isValidName(userLastName) ? isUserLastNameValid(true) : isUserLastNameValid(false)\n    }\n\n    func setUpUserEmail(userEmail: String) {\n        self.userEmail = userEmail\n        ValidationFieldsHelper.isValidEmail(userEmail) ? isUserEmailValid(true) : isUserEmailValid(false)\n    }\n\n    func setUpUserPassword(userPassword: String) {\n        self.userPassword = userPassword\n        ValidationFieldsHelper.isValidPassword(userPassword) ? isUserPasswordValid(true) : isUserPasswordValid(false)\n    }\n\n    func setUpUserAge(userAge: String) {\n        self.userAge = userAge\n        ValidationFieldsHelper.isValidAge(userAge) ? isUserAgeValid(true) : isUserAgeValid(false)\n    }\n\n    func isValidRegistration() -> Bool {\n        return ValidationFieldsHelper.isValidName(userFirstName) &&\n        ValidationFieldsHelper.isValidName(userLastName) &&\n        ValidationFieldsHelper.isValidEmail(userEmail) &&\n        ValidationFieldsHelper.isValidPassword(userPassword) &&\n        ValidationFieldsHelper.isValidAge(userAge)\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n작동 방법: 예를 들어 해당 메소드는 userFirstName 속성을 설정한 다음 ValidationFieldsHelper.isValidName을 사용하여 입력을 유효성 검사합니다. 결과에 따라 isUserFirstNameValid 클로저를 호출하며 이름의 유효성을 나타내는 부울 값을 전달합니다.\n\n이 패턴은 userLastName, userEmail, userPassword 및 userAge와 같은 다른 속성에 대해서도 반복되며 각 입력이 유효성을 검사하도록 보장합니다. 마지막 메소드는 각 사용자 정보 필드의 유효성을 검사하기 위해 ValidationFieldsHelper 메소드를 사용합니다. 등록 프로세스를 진행하기 전에 모든 필드가 유효한지 확인합니다.\n\n# MVVM 아키텍처에서 ViewController의 역할\n\nMVVM 아키텍처에서 ViewController는 View 레이어로 작동합니다. 사용자에게 데이터를 제공하고 사용자 상호작용을 처리하는 것이 그 역할입니다. 사용자 등록 예제의 문맥에서 RegistrationViewController은 사용자 입력을 유효성 검사하고 피드백을 제공하기 위해 RegistrationViewModel과 상호작용합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 필드 액션 설정하기\n\nRegistrationViewController에서 여러 입력 필드의 액션을 설정하는 방법을 알아봅시다:\n\n```js\nprivate func fieldActions() {\n\n        firstNameTextField.addAction(UIAction(handler: { [ weak self ] _ in\n            guard let self = self else { return }\n            let newUserFirstName = self.firstNameTextField.text ?? \"\"\n            self.viewModel.setUpUserFirstName(userFirstName: newUserFirstName)\n        }), for: .editingDidEnd)\n\n        lastNameTextField.addAction(UIAction(handler: { [ weak self ] _ in\n            guard let self = self else { return }\n            let newUserLastName = self.lastNameTextField.text ?? \"\"\n            self.viewModel.setUpUserLastName(userLastName: newUserLastName)\n        }), for: .editingDidEnd)\n\n        emailTextField.addAction(UIAction(handler: { [ weak self ] _ in\n            guard let self = self else { return }\n            let newUserEmail = self.emailTextField.text ?? \"\"\n            self.viewModel.setUpUserEmail(userEmail: newUserEmail)\n        }), for: .editingDidEnd)\n\n        passwordTextField.addAction(UIAction(handler: { [ weak self ] _ in\n            guard let self = self else { return }\n            let newUserPassword = self.passwordTextField.text ?? \"\"\n            self.viewModel.setUpUserPassword(userPassword: newUserPassword)\n        }), for: .editingDidEnd)\n\n        ageTextField.addAction(UIAction(handler: { [ weak self ] _ in\n            guard let self = self else { return }\n            let newUserAge = self.ageTextField.text ?? \"\"\n            self.viewModel.setUpUserAge(userAge: newUserAge)\n        }), for: .editingDidEnd)\n    }\n```\n\n각 액션은 텍스트 변경이나 선택 변경과 같은 사용자 상호작용에 연결되어 있습니다. 이러한 액션들은 ViewModel의 적절한 설정 메서드(setUpUserFirstName, setUpUserEmail 등)를 호출하여 입력 데이터를 업데이트하고 유효성을 검사합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n작동 방식: 사용자가 이메일 필드 편집을 완료하면 해당 동작이 텍스트를 캡처하여 ViewModel로 보내어 유효성을 검사한 후 UI를 업데이트합니다.\n\n## 필드 유효성 검사 처리\n\nfieldsValidation 메서드는 ViewModel과 클로저 바인딩을 설정합니다. 이러한 클로저는 ViewModel이 각 필드의 유효성을 검사할 때 호출됩니다.\n\n```js\nprivate func fieldsValidation() {\n\n     viewModel.isUserFirstNameValid = { [weak self] isUserFirstNameValid in\n        if isUserFirstNameValid {\n            self?.firstNameTextField.layer.borderColor = UIColor.green.cgColor\n        } else {\n            self?.firstNameTextField.layer.borderColor = UIColor.red.cgColor\n            if self?.firstNameTextField.text?.isEmpty ?? true {\n                self?.firstNameTextField.layer.borderColor = UIColor.lightGray.cgColor\n            }\n        }\n    }\n\n    viewModel.isUserLastNameValid = { [weak self] isUserLastNameValid in\n        if isUserLastNameValid {\n            self?.lastNameTextField.layer.borderColor = UIColor.green.cgColor\n        } else {\n            self?.lastNameTextField.layer.borderColor = UIColor.red.cgColor\n            if self?.lastNameTextField.text?.isEmpty ?? true {\n                self?.lastNameTextField.layer.borderColor = UIColor.lightGray.cgColor\n            }\n        }\n    }\n\n    viewModel.isUserEmailValid = { [weak self] isUserEmailValid in\n        if isUserEmailValid {\n            self?.emailTextField.layer.borderColor = UIColor.green.cgColor\n        } else {\n            self?.emailTextField.layer.borderColor = UIColor.red.cgColor\n            self?.showAlert(message: \"유효하지 않은 이메일 주소입니다. 유효한 이메일을 입력해주세요.\")\n            if self?.emailTextField.text?.isEmpty ?? true {\n                self?.emailTextField.layer.borderColor = UIColor.lightGray.cgColor\n            }\n        }\n    }\n\n    viewModel.isUserPasswordValid = { [weak self] isUserPasswordValid in\n        if isUserPasswordValid {\n            self?.passwordTextField.layer.borderColor = UIColor.green.cgColor\n        } else {\n            self?.passwordTextField.layer.borderColor = UIColor.red.cgColor\n            self?.showAlert(message: \"유효하지 않은 비밀번호입니다. 최소 8자 이상이어야 하며 대문자, 숫자, 특수 문자가 하나 이상 포함되어야 합니다.\")\n            if self?.passwordTextField.text?.isEmpty ?? true {\n                self?.passwordTextField.layer.borderColor = UIColor.lightGray.cgColor\n            }\n        }\n    }\n\n    viewModel.isUserAgeValid = { [weak self] isUserAgeValid in\n        if isUserAgeValid {\n            self?.ageTextField.layer.\n            borderColor = UIColor.green.cgColor\n        } else {\n            self?.ageTextField.layer.borderColor = UIColor.red.cgColor\n            self?.showAlert(message: \"유효하지 않은 나이입니다. 유효한 나이를 입력해주세요.\")\n            if self?.ageTextField.text?.isEmpty ?? true {\n                self?.ageTextField.layer.borderColor = UIColor.lightGray.cgColor\n            }\n        }\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n각 클로저는 UI를 업데이트하여 유효성 상태를 반영합니다. 예를 들어, 이메일이 유효하지 않은 경우 이메일 텍스트 필드의 테두리 색상을 빨간색으로 변경하고 경고 메시지를 표시합니다.\n\n# 결론: iOS 앱에서 견고한 필드 유효성 검사를 위해 MVVM 채용\n\n요약하자면, MVVM 아키텍처를 활용하여 iOS 앱에서 필드 유효성 검사를 구현하는 복잡성을 탐험한 우리의 여정은 체계적이고 효율적인 앱 개발 접근 방식을 보여줍니다. 이 기사는 견고한 유효성 검사 시스템을 만드는 구체적인 내용을 다루며, ValidationFieldsHelper 구조체로부터 시작하여 동적 RegistrationViewModel을 거쳐 상호작용하는 RegistrationViewController까지 진행합니다.\n\n이 문맥에서 MVVM 아키텍처의 사용은 그 강점을 부각시킵니다: 관심사 분리, 코드 유지 관리성 향상 및 테스트 용이성 개선. 사용자 인터페이스(View), 비즈니스 로직(ViewModel) 및 데이터 처리(Model)를 분리함으로써 디버깅을 간소화하고 확장 가능한 앱 개발이 가능한 모듈화된 설계를 달성합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 접근 방식에서 주요 포인트는 다음과 같습니다:\n\n- 구조화된 유효성 검사 로직: 유효성 검사 로직을 전용 구조에 캡슐화하면 재사용성과 명확성이 보장됩니다. 이 방법은 코드를 더 잘 구성할 뿐만 아니라 어플리케이션 전반에 쉽게 접근할 수 있게 합니다.\n- 반응성과 사용자 친화적 인터페이스: 사용자 경험을 고려한 View 구성 요소는 즉시 유효성 검사 결과를 반영하여 사용자가 순조롭게 등록 프로세스를 진행할 수 있도록 안내합니다.\n- 동적 데이터 처리: ViewModel은 View와 Model 사이의 통로 역할을 하며 데이터 유효성 검사, 사용자 상호 작용 및 비즈니스 로직을 동적으로 처리하는 방법을 제공합니다.\n- 확장성과 유연성: 이 모듈식 접근 방식은 앱의 검사 로직을 확장하거나 새로운 기능을 통합하는 등 앱의 쉬운 업데이트와 수정을 가능하게 합니다.\n- 시각적 표현: 이 기사와 함께 제작된 개념적이고 추상적인 이미지들은 시각적 매력을 증진시키는 뿐만 아니라 논의된 개념을 더 명확하게 이해할 수 있게 합니다.\n\n결론적으로, iOS 앱 개발에서 필드 유효성 검사에 MVVM 패턴을 적용하면 포괄적이고 실용적인 프레임워크가 제공됩니다. 이 방식은 현대적인 개발 관행과 일치하여 깔끔하고 테스트 가능하며 유지 보수가 용이한 코드를 강조합니다. 소프트웨어 개발의 진화하는 본질을 보여주는 것으로, 아키텍처와 디자인 패턴이 효율적이고 사용자 친화적이며 견고한 애플리케이션을 개발하는 데 핵심적인 역할을 하는 것을 확인할 수 있습니다.\n\n테스트 프로젝트는 DolphinLogin에서 확인할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 피드백 및 협업 개선\n\n이 기사를 마무리하면서 건설적인 비판과 협업 개선의 가치를 강조하고 싶습니다. 코딩 세계는 공유된 지식과 다양한 시각에서 번영합니다. 따라서 더 경험이 많은 개발자들의 제안, 비평 및 향상을 진심으로 환영합니다. 여러분의 통찰력과 기여는 이 접근 방식을 상당히 다듬고 발전시킬 수 있으며, 이는 전체 개발자 커뮤니티에 큰 혜택을 줄 수 있습니다. 주의와 소중한 피드백에 감사드립니다!\n","ogImage":{"url":"/assets/img/2024-06-23-FieldValidationinMVVMArchitectureABeginersGuide_0.png"},"coverImage":"/assets/img/2024-06-23-FieldValidationinMVVMArchitectureABeginersGuide_0.png","tag":["Tech"],"readingTime":18},{"title":"Swift에서 검색 필드 플레이스홀더에 애니메이션 텍스트 전환 구현하는 방법","description":"","date":"2024-06-23 21:31","slug":"2024-06-23-ImplementingAnimatedTextTransitionsforSearchFieldPlaceholderinSwift","content":"\n![animated text transition](https://miro.medium.com/v2/resize:fit:1200/1*iAxDbK5Cno82BIy7Kf6p4A.gif)\n\n이 프로젝트의 목표는 검색 필드의 자리 표시자를 위한 텍스트 애니메이션 전환을 가지는 것입니다. 자리 표시자의 일부가 전환과 함께 한 번에 업데이트되는 것입니다.\n\n![search field placeholder](/assets/img/2024-06-23-ImplementingAnimatedTextTransitionsforSearchFieldPlaceholderinSwift_0.png)\n\n시작하기 전에 검색 아이콘을 가진 텍스트 필드를 추가해 보겠습니다. 위에서 \"magnifyingglass\"라는 시스템 이미지를 사용하고 있습니다. 패딩을 추가하려면 특정 프레임의 뷰에 이미지를 추가하여 이를 텍스트 필드의 \"왼쪽 뷰\" 속성에 추가할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n// 검색 필드 설정\nsearchField = UITextField()\nsearchField.borderStyle = .roundedRect\nsearchField.translatesAutoresizingMaskIntoConstraints = false\nsearchField.textColor = UIColor.gray.withAlphaComponent(0.5)\nsearchField.tintColor = UIColor.gray.withAlphaComponent(0.5)\nsearchField.becomeFirstResponder()\n\n// 검색 아이콘 이미지 뷰 생성\nlet searchIcon = UIImageView(image: UIImage(systemName: \"magnifyingglass\"))\nsearchIcon.tintColor = .gray\nsearchIcon.contentMode = .scaleAspectFit\n\n// 이미지 뷰에 패딩 추가\nlet paddingView = UIView(frame: CGRect(x: 0, y: 0, width: 30, height: 30))\nsearchIcon.frame = CGRect(x: 5, y: 5, width: 20, height: 20)\npaddingView.addSubview(searchIcon)\n\n// 이미지 뷰를 텍스트 필드의 왼쪽 뷰로 설정\nsearchField.leftView = paddingView\nsearchField.leftViewMode = .always\n\n// 검색 필드에 액션 추가\nsearchField.addTarget(\nself,\naction: #selector(textFieldDidChange),\nfor: .editingChanged\n)\n\n이제 전환 문자열 역할을 하는 문자열을 포함하는 뷰를 추가해 봅시다. 여기서는 세 개의 레이블이 추가되어 하나는 정적 텍스트를 가져야하며, 다른 두 레이블은 전환과 함께 계속 업데이트됩니다.\n\n이미지 참조: ![이미지](/assets/img/2024-06-23-ImplementingAnimatedTextTransitionsforSearchFieldPlaceholderinSwift_1.png)\n\n'Label1'은 'Search for'라는 정적 레이블이고, 'Label1' 및 'Label2'는 현재 레이블 및 다음 레이블로 작동하여 현재 문자열과 현재 문자열 뒤에 나오는 문자열 즉, 현재 문자열 이후에 나오는 문자열을 저장합니다. 문자열을 업데이트하고 애니메이션하는 방법은 다음과 같습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```swift\n// 문자열 목록\nvar strings = [\"\\'음식\\'\", \"\\'음식점\\'\", \"\\'식료품\\'\", \"\\'음료수\\'\", \"\\'빵\\'\", \"\\'피자\\'\", \"\\'비리야니\\'\", \"\\'버거\\'\", \"\\'바지\\'\", \"\\'국수\\'\", \"\\'수프\\'\", \"\\'샌드위치\\'\", \"\\'비스킷\\'\", \"\\'초콜릿\\'\"]\n\n@objc func updateLabels() {\n    if index < strings.count {\n        // 단계 1: 문자열 할당\n        nextLabel.text = strings[index]\n        nextLabel.alpha = 0\n        nextLabel.transform = CGAffineTransform(translationX: 0, y: searchView.frame.height / 2)\n\n        // 단계 2: 전환 효과를 주기 위해 애니메이션 적용\n        UIView.animate(withDuration: 1.0, delay: 0, options: .curveEaseOut, animations: {\n            self.currentLabel.alpha = 0\n            self.currentLabel.transform = CGAffineTransform(translationX: 0, y: -self.searchView.frame.height / 2)\n            self.nextLabel.alpha = 1\n            self.nextLabel.transform = .identity\n        }, completion: { _ in\n            // 단계 3: 라벨 로직\n            // 라벨 교체\n            self.currentLabel.text = self.nextLabel.text\n            self.currentLabel.alpha = 1\n            self.currentLabel.transform = .identity\n\n            // 다음 라벨 초기화\n            self.nextLabel.alpha = 0\n            self.nextLabel.transform = CGAffineTransform(translationX: 0, y: self.searchView.frame.height / 2)\n        })\n        // 단계 4: 인덱스 증가\n        index += 1\n    } else {\n        // 모든 문자열이 표시된 경우 타이머 무효화\n        timer?.invalidate()\n    }\n}\n```\n\n- nextLabel의 텍스트를 현재 문자열로 설정합니다. 또한 알파를 0으로 설정하여(투명하게 함) 검색 뷰 아래로 이동하도록 번역 변환을 적용합니다.\n- UIView.animate를 사용하여 애니메이션을 수행합니다. 애니메이션 중에:\n\n- currentLabel이 페이드 아웃되고 위로 이동합니다.\n- nextLabel이 페이드 인하여 원래 위치로 이동합니다.\n\n3. 완료 블록에서 라벨의 텍스트를 교환하고 알파와 번역을 재설정합니다. 이렇게 하면 currentLabel이 다음 문자열을 위해 준비되고 nextLabel이 다음 전환을 위해 재설정됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n라벨이 어떻게 업데이트되는지 확인해 봅시다. 여기에서는 타이머를 사용합니다. 타이머는 설정된 간격이 지나면 타겟 객체로 지정된 메시지를 전송합니다.\n라벨이 업데이트되도록 메서드를 초기화하고 타이머를 설정해야 합니다.\n\n```js\nfunc animateListOfLabels() {\n    currentLabel.text = strings[index-1]\n    nextLabel.alpha = 0\n    timer?.invalidate()\n    timer = Timer.scheduledTimer(\n            timeInterval: 2,\n            target: self,\n            selector: #selector(updateLabels),\n            userInfo: nil,\n            repeats: true\n    )\n}\n```\n\nanimateListOfLabels 함수는 라벨의 애니메이션 순서를 관리하는 데 중요합니다. 이 함수는 다음을 보장합니다:\n\n- currentLabel이 올바른 텍스트로 설정됩니다.\n- nextLabel이 숨겨지고 애니메이션을 위해 준비됩니다.\n- 이전 타이머가 충돌을 피하기 위해 무효화됩니다.\n- 라벨을 매 2초마다 업데이트하는 새로운 타이머가 설정되어 부드러운 전환 효과를 가능하게 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 설정은 각 문자열이 부드러운 전환과 함께 순차적으로 표시되는 레이블 목록을 애니메이션화하는 깔끔하고 제어된 방법을 제공합니다.\n\n저희의 구현에서는 텍스트 필드가 업데이트될 때 타이머가 일시 중지되고, 텍스트 필드가 다시 비어 있을 때 다시 시작됩니다. 여기에 \"stopTimer\" 및 \"resumeTimer\" 메서드가 있습니다.\n\n```js\n// 실행 중인 타이머 무효화\nfunc stopTimer() {\n    timer?.invalidate()\n}\n\n// 타이머 재개\nfunc resumeTimer() {\n    currentLabel.text = strings[index-1]\n    timer = Timer.scheduledTimer(\n        timeInterval: 2,\n        target: self,\n        selector: #selector(updateLabels),\n        userInfo: nil,\n        repeats: true\n    )\n}\n\n// 텍스트필드의 editingChanged 동작 실행\n@objc func textFieldDidChange() {\n    if let text = searchField.text, !text.isEmpty {\n        searchView.isHidden = true\n        stopTimer()\n    } else {\n        searchView.isHidden = false\n        resumeTimer()\n    }\n}\n```\n\n- \"resumeTimer\" 함수는 일시 중단 후 레이블의 애니메이션 시퀀스를 다시 시작하는 데 필수적입니다. 이는 다음 사항을 보장합니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 현재 레이블 (currentLabel)은 이전에 표시된 문자열을 표시하도록 설정됩니다.\n- 새 타이머가 생성되어 일정 간격으로 updateLabels 메서드를 호출하여 텍스트의 부드러운 전환을 계속합니다.\n\n올바른 설정으로 타이머를 재개함으로써, 이 기능은 애니메이션된 텍스트 전환의 연속성과 부드러움을 유지하여 사용자 경험을 향상시킵니다. 애니메이션이 중단된 지점부터 이어서 재개함으로써, 사용자들이 애니메이션을 자연스럽게 이어가도록 도와줍니다.\n\n2. stopTimer 함수는 타이머를 일시 중지하거나 완전히 중지해야 하는 상황에서 필수적입니다.\n\n3. textFieldDidChange 함수는 앱 내 반응이 빠르고 사용자 친화적인 경험을 보장하는 데 중요한 역할을 합니다.\n   텍스트 필드 내용에 따라 검색 뷰를 동적으로 표시하거나 숨기며, 텍스트 필드 내용에 따라 타이머를 제어함으로써 부드럽고 직관적인 사용자 상호 작용을 가능하게 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n애니메이션 검색 필드와 텍스트 전환을 구현하는 주요 이점은 다음과 같아요\n\n- 사용자 참여도 향상\n- 가독성 향상\n- 사용자 경험 개선\n- 효율적인 정보 표시\n- 섬세한 사용자 지원\n\n여기서 코드의 완전한 버전을 찾을 수 있어요. 이 기능을 확인하려면 GitHub에서 클론해보세요.\n\n감사합니다!!! 😃\n","ogImage":{"url":"/assets/img/2024-06-23-ImplementingAnimatedTextTransitionsforSearchFieldPlaceholderinSwift_0.png"},"coverImage":"/assets/img/2024-06-23-ImplementingAnimatedTextTransitionsforSearchFieldPlaceholderinSwift_0.png","tag":["Tech"],"readingTime":8},{"title":"아이폰 개발, 이제 시작해보세요 초보자를 위한 단계별 성공 가이드","description":"","date":"2024-06-23 21:29","slug":"2024-06-23-HowtoLearniOSDevelopmentAStep-By-StepGuideforBeginnerstoSucceed","content":"\n작성자: May Ly, Agile 소프트웨어 엔지니어, TribalScale\n\n![이미지](/assets/img/2024-06-23-HowtoLearniOSDevelopmentAStep-By-StepGuideforBeginnerstoSucceed_0.png)\n\n## 📫 구독하려면 여기를 클릭하세요.\n\n## 💬 다음 디지털 프로젝트, 스타트업 또는 TribalScale에 관한 질문이 있으신가요? 저희 전문가 중 한 명과 채팅해보려면 여기를 클릭하세요!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![그림1](/assets/img/2024-06-23-HowtoLearniOSDevelopmentAStep-By-StepGuideforBeginnerstoSucceed_1.png)\n\n![그림2](/assets/img/2024-06-23-HowtoLearniOSDevelopmentAStep-By-StepGuideforBeginnerstoSucceed_2.png)\n\n저는 현재 TribalScale에서 iOS 개발자로 일하고 있습니다. 여기서는 클라이언트의 iOS 앱을 유지보수하고 기능을 추가하며 레거시 Objective-C 코드를 Swift로 전환하는 작업을 하고 있어요! 처음에 이 프로젝트를 맡았을 때 iOS 경험이 많이 없었지만, 이를 계기로 iOS 개발을 빠르게 익히기로 했습니다. 그래서 iOS의 기본을 빠르게 배우고, 내가 직접 앱을 만들어 적용해 보는 등의 노력을 했어요!\n\n저는 2주 만에 iOS의 기본을 파악할 수 있었습니다. 지금 돌이켜보면, 그 짧은 시간 동안 적용한 프로세스가 많았지만, 나중에 배우게 된 많은 중요한 iOS 개념들도 있었어요. 그래서 제 경험을 되짚어가며, 처음부터 iOS를 배운다면 어떻게 시작할지에 대해 6단계 요약을 작성해 보았어요. 내가 했던 것처럼 iOS 경험이 부족하고 빠르게 iOS를 배우고 싶다면, 이 방법이 도움이 될 지도 몰라요!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 단계 1: XCode 다운로드\n\nXCode를 다운로드하세요! XCode는 애플의 통합 개발 환경으로, iOS를 포함한 모든 애플 플랫폼용 앱을 만들기 위한 도구를 제공합니다. XCode에서는 앱을 편집하고 관리하며, 시뮬레이터를 사용하여 앱을 확인하고, 인터페이스 빌더를 사용하여 앱의 모양을 디자인할 수 있습니다. XCode는 앱 스토어에서 무료로 다운로드할 수 있거나 이 링크에서 찾을 수도 있어요!\n\nXCode를 다운로드하고 실행한 후 몇 가지를 살펴보세요:\n\n- 새 프로젝트 만들기: 새로운 iOS Swift 프로젝트를 만들고 AppDelegate, SceneDelegate, ViewController 및 Main XIB 파일과 같은 기본 파일을 살펴보세요.\n- 플랫폼 살펴보기: XCode 인터페이스를 탐험해보세요. 프로젝트 네비게이터를 포함한 다양한 패널과 창이 있습니다. 여기에서는 파일을 추가하거나 삭제할 수 있고, 코드를 작성할 수 있는 소스 코드 편짡기, 선택한 항목과 관련된 추가 정보를 제공하는 유틸리티 영역이 포함되어 있습니다. 디버깅 패널이나 하단에 있는 터미널과 같은 다른 기능도 살펴볼 수 있습니다.\n- 인터페이스 빌더: XCode의 인터페이스 빌더를 사용하여 앱의 UI를 디자인하고 사용자 정의하세요. 프로젝트에 연관된 스토리보드 또는 XIB 파일(\"Main\" 파일)을 열어 UI 요소를 추가하고 레이아웃을 정렬하고 속성을 조정해보세요.\n- 빌드 및 실행: Xcode 툴바에서 \"빌드 및 실행\" 또는 \"재생\" 버튼을 클릭하여 코드를 컴파일하고 iPhone 시뮬레이터에서 앱을 실행하세요. 이를 통해 앱의 현재 상태를 확인할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nXCode에 대해 더 자세히 다루는 멋진 튜토리얼이 있어요.\n\n실제 코딩을 해보기 전까지 XCode에 대해 배울 수 있는 한계가 있겠죠 — 그래서 그 다음 단계인 스텝 2로 넘어가 보겠습니다!\n\n## 스텝 2: Swift 배우기\n\nSwift는 애플이 2014년 도입한 애플리케이션 개발에 효과적이면서 현대적인 언어로, 애플의 플랫폼에서 애플리케이션을 개발하기 위한 언어입니다. 제가 현재 작업 중인 앱 때문에 실제로 Swift보다 이전에 애플이 개발한 다른 iOS 프로그래밍 언어인 Objective-C를 배웠어요. iOS 개발에 대한 좋은 기반이 되었지만, 요즘에는 더 현대적이고 인기 있는 언어인 Swift를 먼저 배우는 것이 더 좋습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n하지만, 새로운 프로그래밍 언어를 배우는 방법은 여러 가지가 있습니다. 내 경험상으로는, 초보자를 위한 간단한 자습서를 찾을 때 언제나 먼저 Youtube를 참고합니다 (그리고 무료입니다 🤩). 만약 Youtube가 아니라면, 간단한 구글 검색으로 무수히 많은 Swift 코스를 온라인에서 찾을 수 있습니다. 아래에 몇 가지 좋은 자료를 링크했습니다!\n\n[SwiftUI 100 Days Challenge](https://www.hackingwithswift.com/100/swiftui)\n\nSwift를 배우면서 내 경험상 유용한 몇 가지 팁은 다음과 같습니다:\n\n- 어떤 자습서나 코스를 공부할 때는 단순히 시청하고 메모를 하는 것이 아닌 튜토리얼과 함께 코딩하는 것이 가장 좋습니다. 적극적으로 연습하고 내용에 집중하여 자신감과 기억력을 키우는 것이 중요합니다.\n- 특정 주제에 더 깊게 파고들어야 할 때는 언제든지 애플의 공식 Swift 문서를 참고할 수 있습니다. 'The Swift Programming Language' 가이드는 언어의 기능, 구문 및 개념에 대한 포괄적인 개요를 제공합니다.\n- ChatGPT는 개념을 이해하고 특정 질문에 답변하며 지침을 제공하는 데 최상의 도구입니다. 코드 일부를 붙여 넣더라도 각각의 줄을 상세히 설명해줍니다! AI를 최대한 활용하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![2024-06-23-HowtoLearniOSDevelopmentAStep-By-StepGuideforBeginnerstoSucceed_3.png](/assets/img/2024-06-23-HowtoLearniOSDevelopmentAStep-By-StepGuideforBeginnerstoSucceed_3.png)\n\n# 단계 3: 프로젝트 선택\n\n이제 프로그래밍 지식을 실제 앱에 적용할 때입니다! 초보자로서, 현재의 기술 수준으로 합리적으로 달성할 수 있는 간단한 앱 아이디어부터 시작하는 것이 중요합니다. 복수의 복잡한 기능이나 백엔드를 필요로하는 과도한 야심찬 프로젝트는 피하세요. 학습에 집중할 수 있도록 매우 적은 기능을 포함하는 아이디어를 찾으세요.\n\n제가 말하는 간단한 것은 정말 간단한 것을 의미합니다. 당신의 아이디어는 작동을 위해 500줄 이하의 코드만 필요하며, 거기서 추가 기능을 더할 수 있습니다! 시작하기에 좋은 몇 가지 예시는 다음과 같습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- Randomizer/Generator: 사용자가 제공한 맥락에 따라 무작위 결과를 생성하는 앱입니다. 레스토랑, 농담, 색상 등에서 생성된 결과는 API에서 나올 수도 있고 앱에 하드코딩될 수 있습니다.\n- 전쟁 카드 게임: 두 플레이어가 서로 카드 덱에서 카드를 순서대로 공개하여 경쟁하는 클래식 \"전쟁\" 카드 게임입니다. 순위가 더 높은 카드를 가진 플레이어가 라운드를 이기고 두 장을 모아갑니다.\n- 할 일 목록: 사용자가 할 일을 추가, 편집 및 삭제할 수 있는 기본 할 일 목록 앱입니다. 할 일을 완료로 표시하거나 알림 설정과 같은 기능이 포함되어 있습니다.\n\n최종적으로 당신이 원하는 것을 만들 수 있습니다 - 세상은 너의 껍데기입니다! 주변을 탐구하고 당신에게 흥미로울만한 다른 API나 앱 아이디어가 있는지 살펴보세요. 예를 들어, 나의 매우 첫 번째 프로젝트는 두 개의 고양이 API를 사용한 Cat App이었습니다. 구현한 세 가지 기능은 다음과 같습니다:\n\n- CatFact.Ninja API에서 생성된 10가지 고양이 사실\n- TheCatAPI에서 선택한 견종의 여러 이미지를 표시하는 고양이 종 선택기\n- UIStepper를 사용한 매우 기본적인 고양이 카운터\n\n<img src=\"/assets/img/2024-06-23-HowtoLearniOSDevelopmentAStep-ByStepGuideforBeginnerstoSucceed_4.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 프로젝트는 Objective-C와 Swift로 모두 작성되었으며 완성하는 데 며칠이 걸렸고 약 400줄의 코드가 포함되어 있습니다. 사용자 정의 사용자 인터페이스를 만들거나 API에서 데이터를 가져오는 등 다양한 개념을 다룬 것이 좋은 프로젝트 선택이었습니다. 앞으로 앱 아이디어를 선택하면 이러한 다음 단계를 따라가며 개발을 시작할 수 있겠어요!\n\n# 단계 4: UIKit 및 Interface Builder 탐색\n\nUIKit은 애플이 제공하는 프레임워크로, 해당 플랫폼에서 사용자 인터페이스(UI)를 개발하기 위한 것입니다. 이는 응용 프로그램의 시각적 요소를 생성하고 관리하며 사용자 상호 작용을 처리하는 데 필요한 클래스, 프로토콜 및 도구 세트를 제공합니다.\n\nUIKit을 사용하기 위해 XCode의 Interface Builder를 탐색해보아야 합니다. Interface Builder는 시각적 환경으로, 개발자들이 애플리케이션 인터페이스를 설계, 사용자 정의하고 프로토타입을 만드는 데 필요한 코드를 많이 작성하지 않고도 쉽게 작업할 수 있도록 돕는 도구입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 iOS 학습 여정에서 앱의 화면을 디자인하기 위해 Interface Builder를 사용하세요. 예를 들어, 저는 다양한 화면으로 나누어진 여러 컨트롤러를 가지고, 테이블 뷰, 컬렉션 뷰, 버튼, 피커 등의 다양한 UIKit 요소를 담았습니다. 이러한 요소들은 정보를 표시하거나 사용자 상호작용을 처리하는 데 필요했습니다.\n\n![image](/assets/img/2024-06-23-HowtoLearniOSDevelopmentAStep-By-StepGuideforBeginnerstoSucceed_5.png)\n\n캔버스에 UIKit 요소를 추가한 후, 코드와 연결하여 기능을 추가하는 방법을 배우고, 요소를 프로그래밍적으로 조작할 수 있습니다. 이때 Step 2에서 Swift 학습을 활용하여 로직을 작성하여 작동하는 UI 구성 요소를 만들 수 있습니다!\n\n처음에 UIKit를 탐험하는 것은 많은 기능을 배워야 해서 겁내기 쉬울 수 있습니다. 초보자로서, 여러분의 첫 번째 앱 작업 시 반드시 다루어야 할 기본 개념은 다음과 같습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- UIKit 요소들: 프로젝트에 추가하여 외형을 사용자 정의하고 색상, 글꼴, 크기 및 기타 시각 속성을 조정하여 UIKit 요소의 다양성을 경험해보세요. 실제로 깊이 있는 이해를 위해 몇 가지 컴포넌트를 살펴보세요:\n- 뷰 컨트롤러: 뷰 컨트롤러를 사용하여 뷰의 표현과 동작, 사용자 상호작용 처리 및 응용 프로그램의 흐름을 조절하세요. 뷰 컨트롤러의 존재 여부를 다양한 단계에서 호출되는 viewDidLoad()와 같은 라이프사이클 메서드를 이해하여 설정 수행, UI 업데이트, 이벤트에 적절히 응답하세요.\n- UITableView와 UICollectionView: UITableView와 UICollectionView의 사용법을 살펴보세요. 이들은 데이터 목록과 격자를 표시하는 핵심 컴포넌트입니다. 데이터 소스와 델리게이트를 구현하는 방법, 외형 사용자 정의, 사용자 상호작용 처리, 셀 재사용 효율적으로 관리하는 방법을 배우세요.\n- 컨트롤 요소: UIButtons, UITextFields, UISwitches와 같은 다양한 컨트롤 요소를 사용하여 앱과 상호작용할 수 있도록 합니다.\n- IBOutlets 및 IBActions: 뷰 컨트롤러에서 UI 요소와 코드 간 연결을 설정하세요. IBOutlets을 사용하여 프로그래밍 방식으로 요소에 액세스하고 사용자 상호작용에 대한 응답을 트리거하기 위한 메서드를 정의하는 데 IBActions을 사용하세요.\n- Auto Layout: UI 요소 간의 제약 조건을 정의하는 Auto Layout을 탐험하세요. 화면 크기, 방향 및 장치 특성에 대응하도록 보장하는 것이 목적입니다.\n- 탐색 및 Segues: Segues를 추가하여 뷰 컨트롤러 간 이동 및 전환을 관리하세요. 앱 내의 서로 다른 화면 간의 흐름과 탐색을 허용합니다. 인터페이스 빌더에서 Segues를 설정하고 뷰 컨트롤러 간에 데이터를 전달하는 방법을 이해하세요.\n\nUIKit 및 인터페이스 빌더를 배우기 위해서는 실험이 필수적이라는 것을 기억하세요. 간단한 표시부터 시작하여 도구와 개념에 익숙해지면서 점점 더 복잡한 것을 추가해보세요.\n\n# 단계 5: API 작업하기\n\nUIKit, 인터페이스 빌더 및 Swift 프로그래밍에 좀 더 익숙해지면 — API 작업을 배우는 것을 추천합니다. API(응용 프로그램 프로그래밍 인터페이스)는 서로 다른 소프트웨어 응용 프로그램이 통신하고 상호 작용할 수 있도록 하는 규칙과 프로토콜의 집합입니다. 다른 시스템 간에 데이터를 요청하고 교환하는 방법, 데이터 형식 및 규칙을 정의합니다. 당신의 개인 프로젝트에 통합할 수 있는 몇 가지 무료이면서 쉬운 사용법의 멋진 API 예제를 여기에서 확인하세요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 포켓몬 API: https://pokeapi.co/\n- 개 API: https://dog.ceo/dog-api/\n- 마블 API: https://developer.marvel.com/\n- 날씨 API: https://openweathermap.org/api\n\n![image](/assets/img/2024-06-23-HowtoLearniOSDevelopmentAStep-By-StepGuideforBeginnerstoSucceed_6.png)\n\n이전에 내가 앱에 고양이 사실, 품종 및 이미지를 가져오기 위해 두 가지 Cat API를 사용했다고 언급했다. 이를 위해 Objective-C/Swift 코드로 응답을 받고 데이터를 처리하는 간단한 네트워킹 레이어를 만들었다. 이제 온라인에서 API를 찾고 Swift로 API 통합의 기본을 배우고 반환된 데이터를 적절히 표시하세요. 초보자로서 다룰 주제 몇 가지는 다음과 같습니다:\n\n- API 기본 사항: API, HTTP, RESTful 아키텍처 및 JSON 데이터 형식의 개념을 숙지하세요. HTTP 메서드(GET, POST 등), 엔드포인트, 요청 헤더 및 응답 코드에 대해 알아보세요.\n- URLSession 및 URLResponse: Apple이 제공하는 네트워킹 프레임워크인 URLSession의 기본을 이해하세요. URLRequests를 사용하여 데이터를 가져오는 실험을 해보세요.\n- 응답 데이터 처리: API에서 받은 응답 데이터를 처리하는 다양한 방법을 탐구하세요. JSON 데이터를 구문 분석하고 Codable을 사용하여 Swift 객체로 디코딩하고 이미지와 같은 특정 유형의 데이터를 처리하는 방법을 배우세요.\n- 비동기 프로그래밍: 네트워크 요청의 비동기적인 성격에 대해 학습하고 URLSession을 완료 핸들러와 함께 사용하여 동시 작업을 효율적으로 관리하는 방법에 대해 알아보세요. 백그라운드/주 스레드 및 디스패치 그룹과 같은 개념을 검토하세요.\n- 오류 처리: API 요청 중 발생할 수 있는 오류 처리하는 방법을 이해하세요. 다양한 유형의 오류 및 적절한 오류 처리 메커니즘을 구현하는 방법에 대해 배우세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nAPI와 작업하는 법을 배우는 것은 모든 개발자에게 중요한 기술입니다. 서버에서 데이터를 가져오는 방법을 익히면 iOS 개발 기술을 향상시킬 뿐만 아니라 앱의 기능을 향상시키기 위한 무제한의 데이터에 액세스할 수 있습니다!\n\n# 단계 6: 계속 연습하기\n\n이 iOS 개발 학습 계획의 마지막 단계 - 그리고 저도 현재 진행 중인 단계는 계속해서 연습하고 더 많은 실무 경험을 쌓는 것입니다! 직접 앱을 만들거나 소프트웨어 개발자로 일하는 등 다양한 경험을 통해 더 복잡한 주제에 더 깊이 파고들고 최대한 자신을 도전해보세요.\n\n마지막으로, 하늘은 무궁무진하며 이것은 여러분의 iOS 여정의 시작일 뿐입니다! 누구에게나 앱 스토어의 다음 대히트를 만들거나 꿈꾸던 iOS 개발자 직업을 얻을 능력이 있습니다. 계속 열심히 노력하면 곧 iOS 개발의 달인이 될 것입니다! 행운을 빕니다!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n`<img src=\"/assets/img/2024-06-23-HowtoLearniOSDevelopmentAStep-By-StepGuideforBeginnerstoSucceed_7.png\" />`\n\n메이는 현재 iOS 개발에 전념 중인 TribalScale의 애자일 소프트웨어 엔지니어입니다. 그녀의 열정은 개발 프로젝트에서 다른 사람들과 협력하고 프로그래밍, 다양한 기술 스택 및 클라우드 기술에 대한 지식을 확장하는 데 있습니다. 업무 시간 외에는 체육관에 가거나, 배구를 즐기거나, 친구와 가족과 함께 시간을 보내면서 즐겁게 보냅니다.\n\nTribalScale은 기업이 디지털 시대에 적응하고 번영할 수 있도록 돕는 글로벌 혁신 기업입니다. 우리는 팀과 프로세스를 변혁시키고 최고 수준의 디지털 제품을 만들며 혁신적인 스타트업을 창출합니다. 저희에 대해 자세히 알아보고 싶다면 공식 웹사이트를 방문해주세요. 트위터, 링크드인, 페이스북에서도 연락해보세요!\n","ogImage":{"url":"/assets/img/2024-06-23-HowtoLearniOSDevelopmentAStep-By-StepGuideforBeginnerstoSucceed_0.png"},"coverImage":"/assets/img/2024-06-23-HowtoLearniOSDevelopmentAStep-By-StepGuideforBeginnerstoSucceed_0.png","tag":["Tech"],"readingTime":12},{"title":"제18장 CompactMapValues 사용 방법 Swift","description":"","date":"2024-06-23 21:28","slug":"2024-06-23-Chapter18CompactMapValues","content":"\nCompactMapValues 개요\n\n![이미지](/assets/img/2024-06-23-Chapter18CompactMapValues_0.png)\n\ncompactMapValues 함수는 Swift에서 제공되는 고차 함수로, 사전(Dictionary)의 값을 변환하고 결과적으로 발생하는 nil 값을 제거합니다.\n\n이 함수는 주어진 클로저를 사전의 각 값에 적용하고, nil이 아닌 결과만을 포함하는 새로운 사전을 반환합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 함수는 사전(Dictionary)에서 데이터를 정리하고 변환할 때 특히 유용합니다. 여기서는 유효하지 않거나 누락된 값들을 걸러내면서 기존 값들을 변환하는 작업을 할 수 있습니다.\n\n예시:\n\n```js\nlet data: [String: String] = [\"name\": \"Alice\", \"age\": \"25\", \"height\": \"five-five\"]\nlet numericData = data.compactMapValues { Int($0) }\nprint(numericData) // 결과: [\"age\": 25]\n```\n\n설명:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- let data: [String: String] = [\"name\": \"Alice\", \"age\": \"25\", \"height\": \"five-five\"] : 문자열 키와 값으로 구성된 딕셔너리를 정의합니다.\n- let numericData = data.compactMapValues { Int($0) }: compactMapValues 함수를 사용하여 딕셔너리의 값을 변환하며, 각 값을 정수로 변환을 시도합니다.\n- 변환에 실패하면 nil 값을 제거합니다.\n- print(numericData): 결과 딕셔너리 [\"age\": 25]를 출력합니다.\n\n실행 시간 복잡도: compactMapValues 함수의 시간 복잡도는 O(n)이며, 여기서 \\( n \\)은 딕셔너리의 요소 수입니다.\n\n이 복잡성은 함수가 각 값에 대해 정확히 한 번 처리하기 때문에 발생합니다.\n\n실제 사용 사례\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n사용자 입력의 Dictionary를 정리하고 변환하기 위해 CompactMapValues를 사용하기:\n\n```js\nlet userInputs: [String: String] = [\"username\": \"david\", \"age\": \"twenty-five\", \"score\": \"42\", \"height\": \"170\"]\nlet validData = userInputs.compactMapValues { Int($0) }\nprint(validData) // 출력은 [\"score\": 42, \"height\": 170] 입니다.\n```\n\n해설:\n\n- let userInputs: [String: String] = [\"username\": \"john_doe\", \"age\": \"twenty-five\", \"score\": \"42\", \"height\": \"170\"]: string 키와 사용자 입력을 나타내는 값으로 이루어진 Dictionary를 정의합니다.\n- let validData = userInputs.compactMapValues ' Int($0) ': compactMapValues 함수를 사용하여 Dictionary의 값을 변환하며 각 값을 정수로 변환을 시도합니다.\n- 변환에 실패하면 nil 값이 제거됩니다.\n- print(validData): 결과인 딕셔너리 [\"score\": 42, \"height\": 170]를 출력합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n주석: compactMapValues 함수는 특히 사용자 입력이나 외부 소스에서 가져온 데이터와 같이 유효하지 않거나 숫자가 아닌 값이 포함될 수 있는 경우에 딕셔너리를 변환하고 정리하는 데 특히 유용합니다.\n\ncompactMapValues를 사용하면 기존 값의 변환과 함께 유효하지 않은 항목을 걸러내어 단일하고 표현력 있는 문장으로 처리할 수 있습니다.\n\n결론\n\ncompactMapValues 함수는 Swift에서 강력한 고차 함수로, 딕셔너리의 값들을 변환하고 정리하여 nil 결과를 제거할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n시간 복잡도가 O(n)인 이것은 데이터 클리닝 및 변환 작업을 효율적으로 수행하는 방법을 제공합니다.\n\n이것은 예정된 무료 eBook 중 일부이며, 1분 만에 스위프트 데이터 구조 및 알고리즘 마스터하기를 시작하세요. Beginner Swift에서 구독하세요.\n","ogImage":{"url":"/assets/img/2024-06-23-Chapter18CompactMapValues_0.png"},"coverImage":"/assets/img/2024-06-23-Chapter18CompactMapValues_0.png","tag":["Tech"],"readingTime":4},{"title":"iOS 개발에서 Deep Link와 Universal Link 차이점 이해하기","description":"","date":"2024-06-23 21:27","slug":"2024-06-23-DeepLinksandUniversalLinksiniOSdevelopment","content":"\n# 이것은 인기 있는 iOS 인터뷰 질문입니다: Swift에서 Deep Linking과 Universal Linking 간의 주요 차이점을 설명해주세요. 차이를 알고 있는 것이 좋습니다.\n\n가끔 앱에서 처리할 수 있는 추가 작업이 필요할 때가 있습니다. 사용자에게 중요한 정보를 알리기 위해 푸시 알림을 사용할 수 있습니다. 그러나 앱을 시작하거나 데이터를 iOS 앱으로 전달하는 다른 방법도 있습니다. 오늘은 Deep Link와 Universal Link 간의 주요 차이점을 알려드리려고 합니다. Swift에서 어떻게 작동하는지 그리고 iOS 기기에서 어떻게 처리될 수 있는지 살펴보겠습니다.\n\nDeep Link와 Universal Link를 사용하면 이메일(비밀번호 변경 링크), 텍스트 메시지 또는 웹사이트에서 앱을 시작할 수 있습니다.\n\n앱 내에서 사용할 수 있는 추가 데이터를 포함할 수 있습니다. 링크를 통해 사용자에게 제공될 특정 뷰를 시작할 수 있습니다. 로그인, 비밀번호 변경 및 기타 작업을 자동화하는 데 매우 유용할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n물론 딥 링크와 유니버설 링크 모두 제한 사항과 취약점이 있습니다.\n\n## 딥 링크\n\n딥 링크의 주요 기능은 구현이 쉽다는 것입니다.\n\n백엔드 변경이나 새로운 엔드포인트 매핑이 필요하지 않습니다. 앱에 딥 링크를 추가하는 것은 시간이 많이 소요되지 않습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n하지만 사용 허가를 요청하거나 Android에서 문제가 발생하는 것과 같은 단점도 있습니다. Deep link는 주로 iOS용으로 설계되었기 때문에 이러한 문제가 발생할 수 있습니다.\n\n다른 한편으로는 Apple은 새로운 iOS 버전에서 Deep link를 사용하지 않도록 권장하고 있습니다. 또한 보안 문제로 인해 Deep link 사용을 권장하지 않습니다.\n\n# Deep links in Swift apps: Implementing URL Schemes\n\n위 내용을 염두에 두며, Swift 앱에서 Deep link를 구현하는 방법은 무엇인가요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-06-23-DeepLinksandUniversalLinksiniOSdevelopment_0.png\" />\n\n먼저 사용하려는 앱 스키마를 추가해야 합니다. 이를 위해 Xcode의 프로젝트 설정으로 이동한 다음 Info로 이동하세요. URL 유형이라는 섹션에서 새 URL 스키마를 추가할 수 있습니다. com.myAppAddress와 같은 URL 스킴을 포함해야 합니다.\n\n이를 추가한 후 우리의 애플리케이션이 인식할 수 있는 간단한 URL 링크를 만들 수 있습니다. com.myAppAddress로 시작하고 ://myProfile과 같이 이어져야 합니다.\n\n다음과 같이:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\ncom.myAppAddress://reset_password com.myAppAddress://open_custom_view_controller\n\n이것은 쉬웠어요. 이제 이 프로필들을 구현해야 합니다. 이를 AppDelegate 또는 SceneDelegate를 통해 할 수 있습니다. 우리의 코드는 이렇게 보일 것입니다:\n\n```js\nlet myUrlScheme = “com.myAppAddress”\n```\n\n```js\nfunc application(_ app: UIApplication, open url: URL,\n                 options: [UIApplicationOpenURLOptionsKey : Any] = [:]) -> Bool {\n    if let scheme = url.scheme,\n        scheme.localizedCaseInsensitiveCompare(myUrlScheme) == .orderedSame,\n        let view = url.host {\n        var parameters: [String: String] = [:]\n        URLComponents(url: url, resolvingAgainstBaseURL: false)?.queryItems?.forEach {\n            parameters[$0.name] = $0.value\n        }\n        redirect(to: view, with: parameters)\n    }\n    return true\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nURL을 출력하면 다음과 같이 나옵니다:\n\nurl.scheme = \"com.myAppAddress\" url.host = \"open_custom_view_controller\" (또는 \"://\" 이후에 추가될 내용)\n\nURL 스키마를 통해 매개변수를 추가할 수도 있습니다 (위의 코드를 참고하세요).\n\n이 능력 덕분에 링크로부터 특정 정보를 가져올 수 있습니다. 예를 들어 비밀번호를 재설정하고 싶다면, 다음과 같은 링크가 될 것입니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 표를 Markdown 형식으로 변경해주세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제, 웹 사이트와 앱 간 협력을 처리하기 위해 Apple이 현재 홍보하는 유니버설 링크로 넘어갑시다. 이것들은 보안이 더 우수하지만 구현이 더 어렵습니다.\n\n링크를 생성하는 방법에도 차이가 있습니다. 우리는 앱 구현과 특정 URL 링크뿐만 아니라 서버 측에 특정 JSON 파일을 생성 및 유지해야 합니다.\n\n![Universal Links](/assets/img/2024-06-23-DeepLinksandUniversalLinksiniOSdevelopment_1.png)\n\n# 유니버설 링크: iOS 앱에 JSON 추가\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nApple의 요구 사항으로 인해 JSON 파일을 작성해야합니다. 예를 들어:\n\n```js\n{\n    “applinks”: {\n        “apps”: [],\n        “details”: [\n            {\n                “appID”: “teamID.appID.specific.address”,\n                “paths”: [“*”],\n            }\n        ]\n    }\n}\n```\n\n위에서 보듯이, appID 필드에는 두 요소가 필요합니다:\n\n- 앱의 teamID,\n- 그리고 앱의 appID.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그러므로 teamID가 123456이고 appID가 com.myApp인 경우, JSON 파일에서 사용되는 결과는 123456.com.myApp가 될 것입니다.\n\npaths 필드에서는 iOS 앱에서 처리될 경로를 추가할 수 있습니다. URL Schemes의 host와 같습니다. Apple은 더 많은 기능을 제공합니다. paths에서는 특정 문자열을 포함/제외할 수 있는 정규식 솔루션을 구현할 수 있습니다.\n\n서버 측에 JSON 파일을 추가한 후에는 앱으로 이동해야 합니다.\n\n먼저 프로젝트 설정에서 새로운 능력을 추가해야 합니다. Associated domains에 대해 이야기합니다. 활성화한 후에는 링크를 처리하는 URL을 추가해야 합니다. 예를 들어, app links:myApp.com과 같습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 작업이 완료되면 Safari에서 URL 주소를 클릭하면 우리 앱이 시작됩니다.\n\n이제 딥 링크와 마찬가지로 수신된 링크를 처리해야 합니다. AppDelegate로 이동해보겠습니다. 새 함수를 추가해야 합니다.\n\n```swift\npublic func application(_ application: UIApplication,\n                        continue userActivity: NSUserActivity,\n                        restorationHandler: @escaping ([Any]?) -> Void) -> Bool {\n    if let url = userActivity.webpageURL {\n        var view = url.lastPathComponent\n        var parameters: [String: String] = [:]\n        URLComponents(url: url, resolvingAgainstBaseURL: false)?.queryItems?.forEach {\n            parameters[$0.name] = $0.value\n        }\n        redirect(to: view, with: parameters)\n    }\n    return true\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# iOS에서의 깊고 범용적인 링크: 각주\n\n보시다시피, URL Scheme과 유사하게, 본 솔루션에서는 앱에서 사용할 수 있는 매개변수가 있습니다. 하지만 이와 별도로, 유니버셜 링크와 URL Scheme의 주요 차이점은 전자가 사용자가 앱을 설치하지 않은 경우에도 사용할 수 있다는 것입니다. 그 경우에는 Safari가 링크를 열게 됩니다. 이는 기본 랜딩 페이지로 이어질 수도 있고, 우리 앱을 다운로드하기 위한 AppStore로 리디렉션될 수도 있습니다.\n\nSwift 앱에서의 깊고 범용 링크에 도움이 될 수 있는 이 간단한 자습서가 도움이 되기를 바랍니다. 궁금한 사항이나 우려 사항이 있으면 언제든지 연락해 주세요!\n","ogImage":{"url":"/assets/img/2024-06-23-DeepLinksandUniversalLinksiniOSdevelopment_0.png"},"coverImage":"/assets/img/2024-06-23-DeepLinksandUniversalLinksiniOSdevelopment_0.png","tag":["Tech"],"readingTime":8},{"title":"Swift의 모던 동시성 프로그래밍 Async Await와 Alamofire 활용 방법","description":"","date":"2024-06-23 21:26","slug":"2024-06-23-ModernConcurrencyinSwiftAsyncAwaitAlamofire","content":"\n![이미지](/assets/img/2024-06-23-ModernConcurrencyinSwiftAsyncAwaitAlamofire_0.png)\n\n안녕하세요! 모두 다시 만나서 반가워요! 이번 달에는 async/await에 대해 배운 내용을 Alamofire 네트워크 라이브러리에 적용해볼 거에요. 이 시리즈의 첫 번째 부분을 아직 읽지 못했다면, 여기서 잠시 멈추시고 읽어보시는 걸 강력히 추천드려요. 이렇게 하면 속도를 낼 수 있어요.\n\n# Alamofire란 무엇인가요?\n\nAlamofire는 iOS 개발 커뮤니티에서 널리 사용되는 네트워크 라이브러리로, 네트워크 요청을 처리하는 우아한 솔루션을 제공해요. 아마도 이미 Alamofire와 iOS 개발에서의 사용법에 익숙하실 거예요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# Alamofire을 사용한 Async-Await 구현\n\n첫 번째 부분에서 배운 개념들을 Alamofire로 통합하고, 작업 실행 및 오류 처리에 초점을 맞춥니다. 또한, 액터가 어떻게 병렬성 관리를 향상시킬 수 있는지 살펴볼 것입니다.\n\n## 네트워크 매니저 생성\n\n다음은 Alamofire를 사용하여 API 요청을 초기화하는 기본 코드 스니펫입니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n// Alamofire를 사용하여 API 요청을 수행하는 코드 조각입니다.\nclass NetworkManager {\n    func request<T: Decodable>(\n        method: HTTPMethod,\n        url: String,\n        headers: [String: String],\n        params: Parameters?,\n        of type: T.Type,\n        completion: @escaping (Result<T, Error>) -> Void\n    ) {\n        // 인코딩 설정\n        var encoding: ParameterEncoding = JSONEncoding.default\n        switch method {\n        case .post:\n            encoding = JSONEncoding.default\n        case .get:\n            encoding = URLEncoding.default\n        default:\n            encoding = JSONEncoding.default\n        }\n\n        AF.request(\n            url,\n            method: method,\n            parameters: params,\n            encoding: encoding,\n            headers: HTTPHeaders(headers)\n        ).responseDecodable(of: type) { response in\n            switch response.result {\n            case let .success(data):\n                completion(.success(data))\n\n            case let .failure(error):\n                completion(.failure(error))\n            }\n        }\n    }\n}\n```\n\n이제 이 함수에 async-await을 적용해 보겠습니다:\n\n```js\n// Async-await을 사용하여 API 요청을 수행하는 코드 조각입니다.\nclass NetworkManager {\n    func request<T: Decodable>(\n        method: HTTPMethod,\n        url: String,\n        headers: [String: String],\n        params: Parameters?,\n        of type: T.Type\n    ) async throws -> T {\n        // 인코딩 설정\n        var encoding: ParameterEncoding = JSONEncoding.default\n        switch method {\n        case .post:\n            encoding = JSONEncoding.default\n        case .get:\n            encoding = URLEncoding.default\n        default:\n            encoding = JSONEncoding.default\n        }\n\n        // 반드시 continuation을 한 번만 재개해야 합니다.\n        return try await withCheckedThrowingContinuation { continuation in\n            AF.request(\n                url,\n                method: method,\n                parameters: params,\n                encoding: encoding,\n                headers: HTTPHeaders(headers)\n            ).responseDecodable(of: type) { response in\n                switch response.result {\n                case let .success(data):\n                    continuation.resume(returning: data)\n\n                case let .failure(error):\n                    continuation.resume(throwing: error)\n                }\n            }\n        }\n    }\n}\n```\n\n하지만 여기서 멈추지 않고, 더 나아가서 actor를 도입하여 접근 방식을 더욱 세련되게 만들 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 배우자들 소개\n\n배우들은 여러 스레드 간에 안전하게 상태를 공유하기 위해 사용할 수 있는 동시적인 객체 유형입니다. 배우들은 코드를 연속적으로 실행한다는 것이 보장되어 있어서, 동시적인 응용 프로그램에서 공유 상태를 관리하는 데 이상적입니다.\n\nasync/await를 사용하여 배우들을 사용하려면, 간단히 배우를 async로 선언하고, 배우의 async 메서드를 호출하기 위해 await를 사용하면 됩니다.\n\n```js\n// 배우 사용을 보여주는 코드 스니펫\n배우 NetworkManager {\n    func request<T: Decodable>(\n        method: HTTPMethod,\n        url: String,\n        headers: [String: String],\n        params: Parameters?,\n        of type: T.Type\n    ) async throws -> T {\n        // 인코딩 설정\n        var encoding: ParameterEncoding = JSONEncoding.default\n        switch method {\n        case .post:\n            encoding = JSONEncoding.default\n        case .get:\n            encoding = URLEncoding.default\n        default:\n            encoding = JSONEncoding.default\n        }\n\n        // 계속을 정확히 한 번만 재개해야 합니다.\n        return try await withCheckedThrowingContinuation { continuation in\n            AF.request(\n                url,\n                method: method,\n                parameters: params,\n                encoding: encoding,\n                headers: HTTPHeaders(headers)\n            ).responseDecodable(of: type) { response in\n                switch response.result {\n                case let .success(data):\n                    continuation.resume(returning: data)\n\n                case let .failure(error):\n                    continuation.resume(throwing: error)\n                }\n            }\n        }\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n네트워크 매니저가 이제 async 액터로 변경되었으므로 안전하고 동시성 있는 방식으로 상호 작용하는 방법을 소개합니다:\n\n```js\n// 코드의 어딘가.\nlet network = NetworkManager()\n\n...\n\nfunc getPeople() async -> Result<ApiPeopleResponse, Error> {\n    do {\n        // API 요청 보내기\n        let response = try await network.request(method: .get, url: \"https://swapi.dev/api/people\", headers: [:], params: [:], of: ApiPeopleResponse.self)\n        return .success(response)\n    } catch {\n        return .failure(error)\n    }\n}\n\n...\n\n// 코드 어딘가에서 비동기 함수 getPeople 호출합니다.\nlet result = await getPeople()\nswitch result {\ncase .success(let response):\n    // 여기에서 데이터 응답 처리\n    break\n\ncase .failure(let error):\n    // 실패한 응답 처리.\n    print(\"불러오기 실패: \\(error.localizedDescription)\")\n    break\n}\n```\n\n아래는 async/await와 함께 작업(tasks)을 활용하는 방법을 간단히 살펴봅니다:\n\n```js\n// async/await와 Task를 함께 사용하는 예제\nfunc getPeople(completion: @escaping (Result<ApiPeopleResponse, Error>) -> Void) {\n    Task {\n        do {\n            // API 요청 보내기\n            let response = try await network.request(method: .get, url: \"https://swapi.dev/api/people\", headers: [:], params: [:], of: ApiPeopleResponse.self)\n            await MainActor.run {\n                completion(.success(response))\n            }\n        } catch {\n            await MainActor.run {\n                completion(.failure(error))\n            }\n        }\n    }\n}\n\n...\n\n// 코드 어딘가에서 완료 함수인 getPeople 호출합니다.\ngetPeople { result in\n    switch result {\n    case .success(let response):\n        // 여기에서 데이터 응답 처리\n        break\n    case .failure(let error):\n        // 실패한 응답 처리.\n        print(\"불러오기 실패: \\(error.localizedDescription)\")\n        break\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 결론\n\nSwift에서의 Async/await는 깔끔하고 유지보수 가능한 비동기 코드 작성을 위한 가능성을 열어줍니다. 이 글을 통해 우리는 이러한 기능에 대해 더 깊게 파고들어 보았고, 에러 처리, 취소, 그리고 중요한 동시성과 같은 고급 기능에 초점을 맞췄습니다. 이러한 개념을 Alamofire와 통합하면 iOS 애플리케이션의 성능과 신뢰성을 향상시킬 수 있습니다. 항상 강조하듯이, 연습이 중요하니 여러분들의 프로젝트에서 이러한 개념을 실험해보는 것을 적극 권장합니다.\n\nActor와 task의 사용은 공유 리소스 관리와 효율적인 동시 작업 실행에 대한 우리의 이해를 더욱 확고하게 만들어줍니다. 앞으로 나아가면서 이 경험이 우리에게 계속 더 나은 iOS 개발의 최신 동향을 탐색하고 통합하는 데 영감을 줄 것입니다. 이를 통해 우리의 기술과 애플리케이션이 최신 기술과 함께 선도적인 위치를 유지할 수 있도록 하세요.\n\n![이미지](/assets/img/2024-06-23-ModernConcurrencyinSwiftAsyncAwaitAlamofire_1.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\niOS 엔지니어링에 대한 더 많은 통찰을 기대해주세요! 코딩을 즐기며 행복하게 일하세요! 🌟👩‍💻👨‍💻📱\n","ogImage":{"url":"/assets/img/2024-06-23-ModernConcurrencyinSwiftAsyncAwaitAlamofire_0.png"},"coverImage":"/assets/img/2024-06-23-ModernConcurrencyinSwiftAsyncAwaitAlamofire_0.png","tag":["Tech"],"readingTime":9},{"title":"Swift 동시성 메모리 관리에서 Task Cancellation과 Weak Self의 비교","description":"","date":"2024-06-23 21:25","slug":"2024-06-23-SwiftConcurrencyTaskCancellationvsWeakSelfforMemoryManagement","content":"\n![Image](/assets/img/2024-06-23-SwiftConcurrencyTaskCancellationvsWeakSelfforMemoryManagement_0.png)\n\nSwift 개발에 관련해서, 메모리 관리를 이해하는 것은 복잡한 퍼즐을 해결하는 것과 같습니다. 이러한 퍼즐의 핵심에는 클로저와 비동기 작업을 처리하는 동안 메모리 누수에 빠지지 않는 것이라는 도전이 있습니다. 많은 개발자들이 리테인 싸이클을 피하는 데 사용해온 약한 참조(weak self) 개념은 클로저에서 탁월한 해결책이었습니다. 하지만 Swift의 동시성 모델, 특히 Task에서 이 실천이 원활하게 이어지는지 궁금할 것입니다. 실용적인 코드 예제와 통찰을 통해, 효율적인 Swift 프로그래밍을 위한 길을 밝혀보겠습니다.\n\n# 다루는 주제\n\n- 클로저에서 왜 weak self가 필요하며, 사용하지 않으면 어떻게 되는지?\n- Task 블록에서도 실제로 weak self가 필요한가?\n- Swift 동시성을 사용할 때 리테인 싸이클을 피하기 위해 어떤 조치를 취할 수 있는가?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 주요 포인트\n\n- 클로저에서의 순환 참조와 약한 self 사용의 중요성을 이해하세요.\n- 비동기 작업이 self를 강하게 캡처하면 작업 블록도 순환 참조를 생성할 수 있습니다.\n- 컴파일러는 클로저와 달리 작업 블록에서 명시적 self 사용을 요구하지 않습니다.\n- 약한 self에만 의존하지 않고 메모리를 효율적으로 관리할 대안으로 작업 취소를 사용할 수 있습니다.\n- 비동기 작업을 다룰 때 ViewModel에서 순환 참조를 방지하기 위해 작업 취소를 구현하세요.\n\n# 클로저에서의 'Weak Self' 딜레마\n\n약한 self의 필요성을 이해하려면 먼저 Swift에서 클로저의 세계로 들어가 보겠습니다. 클로저는 참조 타입이며 강하게 인스턴스(예: self)를 캡처하고 유지할 수 있습니다. 이로 인해 잠재적인 순환 참조가 발생할 수 있습니다. 이는 객체가 self를 참조하는 클로저를 소유하고, 그 클로저가 객체 자체에 의해 소유되는 경우 발생하여 서로 해제될 수 없는 루프를 만듭니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n전통적인 시나리오:\n\n```swift\nclass Repository {\n    func remoteAPICallWithClosure(onComplete: @escaping (String) -> Void) {\n        DispatchQueue.main.asyncAfter(deadline: .now() + 4) {\n            onComplete(\"완료\")\n        }\n    }\n}\n\nclass SomeBigViewModel {\n    private let repository = Repository()\n    private var result = \"\"\n\n    func doSomethingWithClosure() {\n        repository.remoteAPICallWithClosure { apiResult in\n            self.result = apiResult\n        }\n    }\n}\n```\n\n이제 SomeBigViewModel의 인스턴스를 생성하고 doSomethingWithClosure을 호출한 후에 해당 인스턴스를 해제하려고 시도합니다:\n\n```swift\nvar vm: SomeBigViewModel? = SomeBigViewModel()\nvm?.doSomethingWithClosure()\nvm = nil\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n작업이 시작됩니다. 그러나 deint print 문은 즉시 나타나지 않을 것입니다. 이는 유지 주기(순환 참조)를 나타냅니다:\n\n```js\n작업이 시작됨\n```\n\n## 주기(순환 참조) 파괴하기\n\n우리의 클로저에서 [weak self]를 사용하여 유지 주기를 피하고 SomeBigViewModel이 해제되도록 할 수 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nfunc doSomethingWithClosure() {\n    print(\"작업이 시작되었습니다.\")\n    repository.remoteAPICallWithClosure { [weak self] apiResult in\n        guard let self = self else { return }\n        self.result = apiResult\n        print(\"API 결과를 받았습니다.\")\n    }\n}\n```\n\n코드를 수정하고 다시 실행한 후, 출력 결과는 예상대로 `deinit`이 호출되어 순환 참조가 해제된다는 것을 확인합니다:\n\n```js\n작업이 시작되었습니다.\nSomeBigViewModel이 해제되고 있습니다.\n```\n\n# Swift의 병행성 모델: Task와의 사례\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nSwift의 동시성 모델 소개로 Task에 대한 유사한 질문이 제기됩니다: 여전히 순환 참조를 방지하기 위해 weak self를 사용해야 할까요?\n\n다음 비동기 작업을 고려해보세요.\n\n```swift\nfunc doSomething() {\n    print(\"비동기 작업 시작됨\")\n    Task {\n        do {\n            let result = try await repository.remoteAPICall()\n        } catch {\n            print(error)\n        }\n    }\n}\n```\n\n여기서 weak self를 사용하지 않으면, `Task`이 `self`을 강하게 캡처하면서 인스턴스가 작업이 완료되기 전에 해제되어야 하는 순환 참조가 발생합니다. 클로저와는 달리, 컴파일러는 여기서 명시적인 `self` 사용을 요구하지 않기 때문에 weak self이 모든 비동기 작업에서 필수적인지에 대한 의문이 생깁니다. 놀랍게도, 대안 전략으로 작업 취소라는 것이 있기 때문에 weak self가 모든 비동기 작업에서 꼭 필요하지는 않습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 작업 취소: 전략적 접근\n\n모든 비동기 작업에 일반적으로 `weak self`를 적용하는 대신 개발자들은 작업 취소를 더 적절한 전략으로 생각할 수 있습니다. 작업이 더 이상 필요하지 않을 때 해당 작업을 취소함으로써 `self`를 직접 관리하지 않고도 잠재적인 유지 사이클을 방지할 수 있습니다.\n\n## 작업 취소 단순화:\n\n```swift\npublic extension Task {\n    func store(in set: inout Set<AnyCancellable>) {\n        set.insert(AnyCancellable(cancel))\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 확장 프로그램은 작업 수명주기 관리를 간소화하여 집단 작업 취소를 용이하게 합니다.\n\n## ViewModel에서 작업 취소 활용:\n\n```js\n@MainActor\nclass SomeBigViewModel {\n    private let repository = Repository()\n    private var cancellableBag = Set<AnyCancellable>()\n\n    deinit {\n        print(\"deinit called\")\n    }\n\n    func send(_ action: Action) {\n        switch action {\n            case .viewWillDisappear:\n                cancellableBag.removeAll()\n        }\n    }\n\n    private func doSomething() {\n        print(\"async operation started\")\n        Task {\n            do {\n                let result = try await repository.remoteAPICall()\n            } catch {\n                print(error)\n            }\n        }\n        .store(in: &cancellableBag)\n    }\n}\n```\n\n작업 취소를 사용하면 ViewModel이 해제될 때 작업도 취소되어 명시적으로 `weak self`를 사용하지 않아도 보존 사이클을 방지합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n비동기 작업이 시작되었습니다\nSomeBigViewModel이 해제 중입니다\n```\n\n더 섬세한 작업 취소 제어를 원하는 개발자를 위해 다음 패턴을 적용할 수 있습니다:\n\n이 접근 방식을 사용하면 비동기 작업의 ViewModel 관리가 보다 구조적이고 효율적으로 되며, 기본적으로 약한 self에 의존하는 것보다 전략적인 작업 취소로서 보류 중인 사이클을 피할 수 있습니다.\n\n이 기사를 즐겼다면, Medium에 Clap으로 사랑을 보여주시고 의견을 자유롭게 공유해주세요. 이와 유사한 통찰력을 얻고 싶다면, Medium에서 저를 팔로우하고 LinkedIn 및 Twitter에서 저와 연락하십시오. 함께 더 많은 기술 토론에 참여해 봅시다!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nMedium | LinkedIn | Twitter\n","ogImage":{"url":"/assets/img/2024-06-23-SwiftConcurrencyTaskCancellationvsWeakSelfforMemoryManagement_0.png"},"coverImage":"/assets/img/2024-06-23-SwiftConcurrencyTaskCancellationvsWeakSelfforMemoryManagement_0.png","tag":["Tech"],"readingTime":7},{"title":"확률 도전 과제 50선 파트 31 생일 짝짓기 문제해결 방법","description":"","date":"2024-06-23 21:23","slug":"2024-06-23-50ChallengingProblemsinProbabilityPart31BirthdayPairings","content":"\n안녕하세요! 최근에 확률 관련 문제에 흥미를 느끼기 시작했어요. 프레드릭 모스텔러(Frederick Mosteller)의 “Fifty Challenging Problems in Probability with Solutions”라는 책을 발견했는데, 이 중에 있는 문제들을 토론하는 시리즈를 만들면 재미있을 것 같아요. 이 문제들은 면접 질문으로 나올 수 있는 매력적인 문제들이에요. 각 게시물은 1개의 문제만을 다루며, 총 50부작의 시리즈가 될 거에요. 함께 해서 두뇌를 활성화해봐요 🧠!\n\n## 문제:\n\n생일이 같은 두 사람이 있다는 확률이 1/2를 초과하는 데 필요한 최소한의 사람 수는 얼마입니까?\n\n(출생 연도는 일치할 필요가 없습니다. 2월 29일은 가능한 생일로 고려하지 않아도 됩니다. 다른 365일은 모두 동등한 가능성의 생일입니다.)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-06-23-50ChallengingProblemsinProbabilityPart31BirthdayPairings_0.png\" />\n\n## 해결 방안:\n\n(해결 방안은 곧 업로드됩니다. 풀었다면 멋져요! 답을 댓글로 공유해도 좋아요! 😊)\n\n힌트: 아무도 같은 생일이 없는 확률을 계산하는 것부터 시작하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 시리즈의 다른 문제들도 확인해보세요:\n\n읽어 주셔서 감사합니다! :)\n","ogImage":{"url":"/assets/img/2024-06-23-50ChallengingProblemsinProbabilityPart31BirthdayPairings_0.png"},"coverImage":"/assets/img/2024-06-23-50ChallengingProblemsinProbabilityPart31BirthdayPairings_0.png","tag":["Tech"],"readingTime":2},{"title":"Swift에서 클로저 사용하는 방법 - 완벽 가이드","description":"","date":"2024-06-23 21:23","slug":"2024-06-23-AGuideToClosuresInSwift","content":"\n![Closure](/assets/img/2024-06-23-AGuideToClosuresInSwift_0.png)\n\n스위프트에서 클로저는 코드에서 전달하고 사용할 수 있는 자체 포함 블록 기능입니다. 클로저는 함수와 유사하지만 구문 최적화가 있으며 주변 컨텍스트에서 변수 및 상수에 대한 참조를 캡처하고 저장할 수 있습니다. 이 동작은 클로저가 동작을 캡슐화하고 값을 전달하는 데 강력하게 만듭니다.\n\n클로저는 다양한 시나리오에서 사용할 수 있습니다. 이 글에서는 다음과 같은 내용을 배우게 됩니다:\n\n- 인수 및 반환 값으로서\n- 정렬 및 필터링을 위해\n- 비동기 작업\n- 값 캡처\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 인수 및 반환 값으로서의 클로저:\n\n클로저는 함수 및 메소드에 인수로 전달될 수 있으며, 함수에서 반환하거나 변수 또는 속성에 저장할 수도 있습니다.\n\n예시:\n\n```js\n// 클로저를 인수로 전달하는 함수\nfunc performOperation(on a: Int, and b: Int, operation: (Int, Int) -> Int) -> Int {\n    return operation(a, b)\n}\n\n// 다양한 연산을 위한 클로저 표현 정의\nlet addClosure: (Int, Int) -> Int = { $0 + $1 }\nlet subtractClosure: (Int, Int) -> Int = { $0 - $1 }\nlet multiplyClosure: (Int, Int) -> Int = { $0 * $1 }\n\nlet resultAdd = performOperation(on: 5, and: 3, operation: addClosure) // 결과: 8\nlet resultSubtract = performOperation(on: 10, and: 4, operation: subtractClosure) // 결과: 6\nlet resultMultiply = performOperation(on: 6, and: 2, operation: multiplyClosure) // 결과: 12\n\nprint(resultAdd, resultSubtract, resultMultiply)\n\n// 클로저를 반환하는 함수\nfunc makeMultiplier(factor: Int) -> (Int) -> Int {\n    return { number in\n        return number * factor\n    }\n}\n\nlet double = makeMultiplier(factor: 2)\nlet triple = makeMultiplier(factor: 3)\n\nlet resultDouble = double(5) // 결과: 10\nlet resultTriple = triple(4) // 결과: 12\n\nprint(resultDouble, resultTriple)\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 예제에서는 performOperation이라는 함수를 정의합니다. 이 함수는 두 정수와 산술 연산을 나타내는 클로저를 받습니다. 이 함수는 제공된 클로저를 두 정수에 적용합니다.\n\n또한 makeMultiplier라는 함수를 정의합니다. 이 함수는 클로저를 반환합니다. 반환된 클로저는 인수를 지정된 인수로 곱합니다.\n\n그런 다음, 덧셈, 뺄셈 및 곱셈을 위한 다른 클로저 표현식을 만듭니다. 이러한 클로저를 performOperation의 인수로 전달하고, 반환된 makeMultiplier의 클로저를 사용하여 숫자를 2배와 3배로 만듭니다.\n\n# Sorting and Filtering:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n테이블 태그를 마크다운 형식으로 변경해 주세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```swift\nstruct Person {\n    var name: String\n    var age: Int\n}\n\nlet people = [\n    Person(name: \"Alice\", age: 28),\n    Person(name: \"Bob\", age: 22),\n    Person(name: \"Charlie\", age: 35)\n]\n\n// 나이 기준으로 정렬하는 클로저 사용\nlet sortedByAge = people.sorted { (person1, person2) in\n    return person1.age < person2.age\n}\n\nprint(sortedByAge)\n// 결과: [Person(name: \"Bob\", age: 22), Person(name: \"Alice\", age: 28), Person(name: \"Charlie\", age: 35)]\n\n```\n\n이 예제에서는 sorted(by:) 메서드가 각 Person 인스턴스의 age 속성을 기준으로 people 배열을 정렬하는 클로저를 사용합니다.\n\n2. 클로저로 필터링:\n\n클로저를 사용하여 특정 조건에 따라 배열에서 요소를 필터링할 수도 있습니다. filter(\\_:) 메서드를 사용하여, 필터링된 결과에 포함되어야 하는지 여부를 나타내는 Boolean 값을 반환하는 클로저를 제공할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n예시:\n\n```js\nlet numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n// 클로저를 사용하여 짝수만 필터링하는 예시\nlet evenNumbers = numbers.filter { number in\n    return number % 2 == 0\n}\n\nprint(evenNumbers) // 출력: [2, 4, 6, 8, 10]\n```\n\n본 예시에서는 filter(\\_:) 메서드가 클로저를 사용하여 numbers 배열에서 홀수를 필터링하는 방법을 보여줍니다.\n\n# 비동기 작업:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n클로저는 네트워크 요청이나 애니메이션과 같은 비동기 작업에서 완료 핸들러로 자주 사용됩니다.\n\n비동기 예시: 네트워크 요청\n\n```swift\nfunc fetchData(completion: @escaping (Result<Data, Error>) -> Void) {\n    // 네트워크 요청 지연 시간 시뮬레이션\n    DispatchQueue.global().asyncAfter(deadline: .now() + 2) {\n        if Bool.random() { // 성공 또는 실패를 랜덤하게 시뮬레이션\n            let data = Data(\"샘플 데이터\".utf8)\n            completion(.success(data))\n        } else {\n            let error = NSError(domain: \"com.example\", code: 1, userInfo: nil)\n            completion(.failure(error))\n        }\n    }\n}\n\n// 클로저를 사용하여 fetchData 함수 호출\nfetchData { result in\n    switch result {\n    case .success(let data):\n        print(\"받은 데이터:\", data)\n    case .failure(let error):\n        print(\"에러:\", error)\n    }\n}\n```\n\n이 예시에서 fetchData 함수는 지연 후 완료되는 네트워크 요청을 시뮬레이션합니다. 네트워크 요청이 완료되면 실행되는 클로저(completion)를 인자로 받습니다. 클로저는 성공(가져온 데이터와 함께) 또는 실패(에러와 함께)를 나타내는 Result 타입을 갖습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n비동기 예제: 애니메이션\n\n```js\nimport UIKit\n\nUIView.animate(withDuration: 0.5, animations: {\n    // 애니메이션할 UI 속성 업데이트\n    someView.alpha = 0.0\n}) { _ in\n    // 이 클로저는 애니메이션이 완료될 때 실행됩니다\n    someView.removeFromSuperview()\n}\n```\n\n이 예제에서는 UIView.animate(withDuration:animations:completion:) 함수를 사용하여 뷰의 알파 속성을 애니메이션화합니다. animations로 전달된 클로저는 애니메이션 변경을 정의하며, completion 클로저는 애니메이션이 완료되면 실행됩니다.\n\n# 값 캡처하기:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n클로저는 주변 컨텍스트에서 변수와 상수에 대한 참조를 캡처하고 저장할 수 있습니다. 이는 클로저 내부에서 상태를 유지하는 데 유용할 수 있습니다.\n\n예시:\n\n```js\nfunc makeIncrementer(incrementAmount: Int) -> () -> Int {\n    var total = 0\n\n    let incrementer: () -> Int = {\n        total += incrementAmount\n        return total\n    }\n\n    return incrementer\n}\n\nlet incrementByTwo = makeIncrementer(incrementAmount: 2)\nprint(incrementByTwo()) // Prints: 2\nprint(incrementByTwo()) // Prints: 4\n\nlet incrementByFive = makeIncrementer(incrementAmount: 5)\nprint(incrementByFive()) // Prints: 5\nprint(incrementByFive()) // Prints: 10\n\nprint(incrementByTwo()) // Prints: 6\n```\n\n이 예시에서 makeIncrementer 함수는 주변 컨텍스트에서 total 변수를 캡처하는 클로저인 incrementer를 반환합니다. 반환된 클로저는 캡처된 total을 지정된 incrementAmount만큼 증가시킵니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nmakeIncrementer(incrementAmount: 2)을 호출하면 incrementByTwo 클로저를 얻게 됩니다. incrementByTwo()를 호출할 때마다 총합이 2씩 증가하고 업데이트된 값이 반환됩니다.\n\n비슷하게, makeIncrementer(incrementAmount: 5)를 호출하면 총합을 5씩 증가시키는 incrementByFive 클로저를 얻게 됩니다.\n\n클로저는 생성될 때 값을 캡처합니다. 이는 각 캡처된 값이 클로저 인스턴스에 고유하다는 것을 의미합니다. 이 예시에서 incrementByTwo와 incrementByFive는 각각 고유한 캡처된 총합 값을 갖습니다.\n\n클로저에서 값들을 캡처하는 것은 상태를 유지하고 컨텍스트를 기억하는 동작을 만들 수 있게 해줍니다. 이러한 특성으로 인해 클로저는 다양한 프로그래밍 시나리오에 강력한 도구가 됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 문법:\n\n스위프트에서 클로저의 기본 문법은 다음과 같습니다:\n\n```js\nlet closureName: (파라미터들) -> 반환타입 = { // 클로저 내용 }\n```\n\n두 정수를 더하는 클로저의 예시:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```swift\nlet addClosure: (Int, Int) -> Int = { (a, b) in\n    return a + b\n}\n\nlet result = addClosure(5, 3) // 결과는 8이 될 것입니다\n```\n\n클로저는 그들의 타입을 유추할 수 있는 경우에 더 간결한 형식으로 작성할 수 있습니다:\n\n```swift\nlet addClosure = { (a: Int, b: Int) in\n    return a + b\n}\n\nlet result = addClosure(5, 3)\n```\n\n더 간결하게도:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nlet addClosure: (Int, Int) -> Int = { $0 + $1 }\n\nlet result = addClosure(5, 3)\n```\n\n클로저는 주변 컨텍스트에서 값들을 캡쳐할 수 있어요.\n\n예를들어:\n\n```js\nfunc makeIncrementer(incrementAmount: Int) -> () -> Int {\n    var total = 0\n    let incrementer: () -> Int = {\n        total += incrementAmount\n        return total\n    }\n    return incrementer\n}\n\nlet incrementByTwo = makeIncrementer(incrementAmount: 2)\nprint(incrementByTwo()) // 2 출력\nprint(incrementByTwo()) // 4 출력\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 예시에서 증가자 클로저는 주변 함수 컨텍스트에서 total 변수와 incrementAmount 매개변수를 캡처합니다.\n\n이 게시물을 즐기셨다면 공유하고 클랩도 부탁드려요👏🏻👏🏻👏🏻👏🏻👏🏻\n\n또한 아래 연락처로 연락하실 수도 있어요📲\n\nLinkedIn\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래에서 제 코드를 확인할 수 있어요👇🏻\n\nGitHub\n\n잘 읽었나요?\n\n의견, 질문 또는 추천이 있으면 자유롭게 아래 댓글 섹션에 남겨주세요💬\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n💁🏻‍♀️ 즐거운 코딩하세요!\n\n감사합니다 😊\n","ogImage":{"url":"/assets/img/2024-06-23-AGuideToClosuresInSwift_0.png"},"coverImage":"/assets/img/2024-06-23-AGuideToClosuresInSwift_0.png","tag":["Tech"],"readingTime":11}],"page":"9","totalPageCount":110,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true}