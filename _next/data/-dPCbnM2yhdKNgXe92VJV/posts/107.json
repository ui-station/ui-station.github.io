{"pageProps":{"posts":[{"title":"데이터 엔지니어링을 위한 데이터베이스 스키마 디자인 필수 주의 사항과 최선의 방법들","description":"","date":"2024-05-17 19:05","slug":"2024-05-17-DatabaseSchemaDesignforDataEngineeringEssentialPitfallsandBestPractices","content":"\n<img src=\"/assets/img/2024-05-17-DatabaseSchemaDesignforDataEngineeringEssentialPitfallsandBestPractices_0.png\" />\n\n현재 데이터 중심의 세계에서 데이터베이스 스키마 디자인은 데이터 엔지니어링, 분석 및 전반적인 비즈니스 인텔리전스에 중요한 역할을 합니다. 애플리케이션 개발자로서, 스키마 디자인은 애플리케이션 요구 사항을 충족시키는 것뿐만 아니라 조직 전체에서 데이터 이전, 분석 및 활용을 효율적으로 가능하게 하는 데 중요하다는 것을 이해하는 것이 중요합니다. 이 기사를 쓰게 된 동기는 데이터 엔지니어로서 다양한 과제를 직면했을 때 일시적인 스키마 디자인이 데이터 접근성과 사용성을 방해했던 경험에서 비롯됩니다. 일반적인 함정을 해결하고 최상의 방법을 채택함으로써 견고하고 확장 가능한 데이터 인프라를 만들 수 있습니다. 이 협력적인 노력은 데이터 엔지니어, 데이터 분석가, 데이터 과학자, 애플리케이션 개발자의 참여를 포함하여 데이터 활용의 모든 측면이 고려되도록 합니다. 함께 이러한 필수적인 통찰력을 탐색하여 스키마 디자인을 개선하고 데이터의 전체 잠재력을 발휘해 보세요.\n\n# 소개\n\n## 데이터 엔지니어링을 위한 데이터베이스 스키마 디자인 개요\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n강력하고 효율적인 데이터베이스 스키마를 설계하는 것은 모든 애플리케이션에 대한 중요한 작업입니다. 그러나 데이터 엔지니어링에 관련하여는 데이터를 데이터 웨어하우스로 효과적으로 전송하고 분석 및 머신러닝(ML)용으로 활용할 수 있도록 하는 추가적인 고려사항이 필요합니다. 이에는 다양한 데이터 전송 방법을 이해하고 잠재적인 문제점을 예측하며, 애플리케이션 및 데이터 소비 요구 사항과 일치하는 최상의 방법을 채택하는 것이 포함됩니다.\n\nAI 및 ML이 더 중요해지는 가운데, 데이터베이스에 저장된 데이터에 쉽게 액세스하고 활용할 수 있는 능력은 데이터 분석과 데이터 과학에 더 중요해집니다. AI 및 ML 모델은 대량의 고품질 데이터에 의존합니다. 효과적인 스키마 설계는 데이터가 AI 및 ML 워크플로에 얼마나 매끄럽게 통합될 수 있는지에 직접적인 영향을 미치며, 더 나은 의사결정, 예측 분석 및 자동화를 지원합니다.\n\n## 스키마 설계 시 데이터 전송을 고려하는 중요성\n\n데이터베이스 스키마 설계의 주요 도전 중 하나는 데이터가 데이터 웨어하우스로 효율적으로 전송될 수 있는지를 보장하는 것입니다. 잘못 설계된 스키마는 데이터 추출, 변환 및 로딩(ETL) 프로세스에서 상당한 어려움을 야기할 수 있으며, 성능 병목 현상과 데이터 불일치로 이어질 수 있습니다. 따라서 데이터 전송 요구 사항을 고려하여 스키마를 설계하는 것이 중요하며, 원활하고 효율적인 데이터 파이프라인을 가능케 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 애플리케이션 개발자의 책임 범위를 넘어선 부분\n\n일반적으로 애플리케이션 개발자들은 주로 애플리케이션의 즉각적인 요구 사항에 주안점을 두곤 합니다. 그러나 데이터 엔지니어, 데이터 분석가, 데이터 과학자들이 데이터를 활용할 방식을 고려하는 것도 중요합니다. 이 종합적인 관점은 데이터가 다양한 분석 및 과학적 목적에 대해 쉽게 접근 가능하고 활용 가능하도록 보장합니다. 개발자들은 다른 이해관계자들과 협력하여 그들의 데이터 요구 사항을 파악하고 데이터베이스 스키마가 해당 요구를 지원함을 확실히 해야 합니다.\n\n이러한 보다 광범위한 고려 사항을 고려함으로써 애플리케이션 개발자들은 자신들의 애플리케이션 요구 사항뿐만 아니라 조직 전체에서의 효율적인 데이터 전송 및 사용을 용이하게 하는 데이터베이스 스키마를 설계할 수 있습니다. 이는 더 효과적인 데이터 엔지니어링, 더 나은 분석, 그리고 궁극적으로 더 명확한 비즈니스 의사 결정으로 이어집니다.\n\n# 데이터베이스에서 데이터 웨어하우스로의 데이터 전송 유형\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다양한 종류의 데이터 전송 방법을 이해하는 것은 데이터 크기, 업데이트 빈도 및 조직의 특정 요구 사항에 기초하여 적절한 방법을 선택하는 데 중요합니다. 응용 프로그램 개발자는 효율적인 데이터 전송을 용이하게 하는 스키마를 설계하기 위해 이러한 기술에 대해 인식해야 합니다. 여기에서는 데이터 전송의 주요 유형, 장단점 및 각 접근 방식에 대한 고려 사항을 탐색해봅니다.\n\n## 전체 테이블 전송\n\n설명: 전체 테이블이 데이터 웨어하우스로 전송됩니다.\n\n장점:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 다른 방법들에 비해 구현이 간단합니다.\n- 변경 사항을 추적하기 위한 복잡한 논리가 필요하지 않습니다.\n- 데이터 웨어하우스가 전송 시점에 테이블의 완전한 스냅숏을 보유하도록 보장합니다.\n\n단점:\n\n- 대량의 데이터 전송으로 대형 테이블에 비효율적입니다.\n- 전송 중에 성능 병목 현상을 유발할 수 있으며, 특히 테이블이 매우 큰 경우에 해당합니다.\n\n사용 사례: 변경 빈도가 낮은 소규모에서 중규모의 테이블이나 자주 변경되지 않는 테이블에 적합합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n**고려 사항:**\n\n- 성능 병목 현상을 피하기 위해 테이블 크기를 관리할 수 있는 수준으로 유지해야 합니다.\n- 테이블 크기가 크지 않다면, SELECT \\* FROM '테이블'과 같이 간단한 쿼리를 사용하여 데이터를 추출할 수 있습니다.\n- 자동 증가 정수 고유 키가 있는 대규모 테이블의 경우, 정수 인덱스의 범위를 사용하여 테이블을 청킹하여 전체 테이블을 효율적으로 전달할 수 있습니다. 이는 Apache Spark와 같은 분산 처리를 가능하게 합니다.\n\n## 부분 테이블 점진적 전송\n\n설명: 특정 기준(일반적으로 타임스탬프 열)에 따라 새로운 레코드 또는 업데이트된 레코드만 전송됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n장점:\n\n- 대량이거나 자주 업데이트되는 테이블에 효율적인 데이터 전송 양을 줄입니다.\n- 전송 과정에서 데이터베이스 부하를 최소화합니다.\n\n단점:\n\n- 변경 사항을 정확히 추적해야 합니다.\n- 신뢰할 수 있는 타임스탬프 데이터와 인덱싱에 의존합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n표태그로부터 Markdown 형식으로 변경하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n설명: 테이블에만 발생한 변경 사항(삽입, 업데이트, 삭제)을 캡처하고 전송합니다.\n\n장점:\n\n- 실시간 데이터 동기화.\n- 동적 데이터에 매우 효율적인 최소한의 데이터 전송 양.\n- 데이터 웨어하우스가 항상 최신 변경 사항과 동기화됨을 보장.\n\n단점:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- CDC를 시작하기 전에 day-0 데이터를 준비하는 것이 까다로울 수 있습니다; 전체 테이블을 데이터 웨어하우스에 미리로드해야 합니다. 초기 스냅샷과 CDC 시작 사이에 간격이 생기면 데이터가 누락될 수 있습니다.\n- 듀플리케이션 또는 들어오는 데이터를 기존 데이터와 일치시키는 것은 계산적 및 재정적으로 소모적일 수 있습니다.\n- CDC 유지 관리는 복잡하고 지속적인 노력이 필요할 수 있습니다.\n\n사용 사례: 데이터베이스와 데이터 웨어하우스 간에 거의 실시간 데이터 동기화가 필요한 시스템에 적합합니다.\n\n고려 사항:\n\n- 데이터베이스 트리거, 로그 기반 캡처 또는 제3자 도구와 같은 CDC 메커니즘을 구현하여 이 프로세스를 용이하게 합니다.\n- 데이터의 초기 전체 로드가 CDC 프로세스와 정확하게 동기화되어 데이터 불일치를 방지하도록 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## Zero-ETL: 신흥 개념\n\nZero-ETL은 전통적인 추출, 변환 및 로드 (ETL) 프로세스의 필요성을 줄이거나 제거하여 시스템 간 데이터에 직접 액세스할 수 있도록 하는 것을 목표로 합니다. 이 접근 방식은 데이터 워크플로우를 간소화할 수 있지만 전통적인 데이터 전송 방법에서 마주하는 도전 과제와 유사한 문제점을 제기할 수도 있습니다.\n\n예시: BigQuery 페더레이티드 쿼리: BigQuery에서 Cloud Spanner 및 Cloud SQL의 데이터를 직접 쿼리할 수 있어 데이터 이동의 필요성을 줄여줍니다.\n\n제한사항 및 고려 사항:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 데이터 유형 호환성: 시스템 간에 모든 데이터 유형이 호환되지 않아 직접 접근이 복잡해집니다.\n- 복잡한 데이터 유형: 데이터베이스에서 복잡한 데이터 유형을 사용하면 Zero-ETL 솔루션을 효과적으로 활용하는 것이 어려워질 수 있습니다.\n- 문제에 직면하기: Zero-ETL은 대형 테이블과 점진적 데이터 전송의 어려움과 같은 기존 방법과 유사한 문제에 직면할 수 있습니다.\n\nZero-ETL은 데이터 엔지니어링의 흥미로운 발전을 대표하며, 더 간소하고 효율적인 데이터 워크플로우를 제공하는 잠재력을 제시합니다. 그러나 아직 신흥 컨셉이며 모든 사용 사례와 기술적 도전에 완전히 대응하지 못할 수 있습니다.\n\n## 데이터 전송 방법에 대한 마지막 생각\n\n적절한 유형의 데이터 전송 방법을 선택하는 것은 조직의 특정 요구 사항과 제약 조건에 따라 다릅니다. 전체 테이블을 전송하는 것은 비교적 간단할 수 있지만 대량 데이터셋과 잘 맞지 않을 수 있습니다. 부분 테이블을 점진적으로 전송하는 것은 성능과 효율성 사이의 균형을 제공하며, CDC는 복잡성에 대한 대가로 실시간 동기화를 제공합니다. Zero-ETL은 데이터 액세스를 단순화하는 유망한 접근 방식이지만 데이터 유형 호환성과 시스템 기능을 신중히 고려해야 합니다. 이러한 방법과 그 영향을 이해함으로써 응용 프로그램 개발자는 각 이해관계자의 요구 사항을 충족하는 더 효과적이고 적응 가능한 데이터 파이프라인을 설계할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 스키마 설계에서 자주 발생하는 함정 및 최상의 실천 방법\n\n데이터베이스 스키마를 효과적으로 설계하려면 일반적인 함정과 그들을 피하는 최상의 실천 방법을 이해해야 합니다. 여기에서는 이러한 함정과 해당하는 최상의 실천 방법에 대해 논의하여 응용 프로그램 개발자들이 이러한 개념을 더 잘 이해할 수 있도록 상세한 설명과 맥락을 제공합니다. 이러한 함정은 겹치지 않는 독립적인 문제를 다루는 데 조직화됩니다.\n\n## Timestamp 열이 부족한 경우\n\n함정: 테이블에 timestamp 열 (created_at, updated_at)을 포함하지 않으면 변경을 추적하고 데이터를 점진적으로 전송하는 것이 어려워질 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n데이터 전송에 미치는 영향: 이 문제는 특히 부분적인 테이블 증분 전송 및 변경 데이터 캡처(CDC) 방법에 대해 문제가 됩니다. 타임스탬프가 없으면 새로 추가되거나 업데이트된 레코드를 식별하는 것이 어렵기 때문에 효율적인 데이터 추출 프로세스가 어려워집니다.\n\n베스트 프랙티스: 항상 타임스탬프 열을 포함하고 인덱싱되어 있는지 확인하세요. 이렇게 하면 시간 범위를 기반으로 하는 효율적인 증분 데이터 추출이 가능해지며, 데이터 동기화와 역사적 분석이 쉬워집니다.\n\n예시: created_at 및 updated_at 열이 없는 판매 테이블이 있다고 가정해 보겠습니다. 마지막 전송 이후에 추가되거나 업데이트된 레코드만 전송해야 한다면, 타임스탬프 없이는 이러한 레코드를 식별할 방법이 없습니다. 이러한 열을 포함하면 타임스탬프를 기반으로 새로운 레코드나 업데이트된 레코드를 질의할 수 있어 증분 전송을 용이하게 할 수 있습니다.\n\n## 부적절한 인덱싱\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n비폴: 잘못된 또는 누락된 인덱스는 쿼리 성능이 떨어지며 데이터 추출 및 전송 효율성을 떨어뜨릴 수 있습니다.\n\n데이터 전송에 미치는 영향: 모든 유형의 데이터 전송(전체 테이블, 점진적 및 CDC)은 인덱싱이 부족하면 성능이 떨어질 수 있습니다. 인덱싱이 부족한 테이블은 쿼리를 위해 전체 테이블 스캔이 필요하며, 이로 인해 추출 시간이 길어지고 리소스 사용량이 증가할 수 있습니다.\n\n모베스트 프랙티스: 쿼리에서 자주 사용되는 열에 대한 적절한 인덱싱 전략을 구현하십시오. 특히 필터링 및 조인 작업에 관여하는 열에 대해 인덱스를 추가하는 것이 좋습니다.\n\n예: 고객 ID 및 이메일 주소를 기반으로 하는 자주 발생하는 쿼리가 있는 고객 테이블이 있다고 가정해 보겠습니다. 이러한 열에 인덱스가 없으면 각 쿼리마다 전체 테이블을 스캔해야 하므로 성능이 저하됩니다. customer_id 및 email에 인덱스를 추가하면 이러한 쿼리의 속도를 크게 향상시켜 데이터 추출 효율성을 개선할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 효율적인 고유 식별자 부재\n\n주의 사항: 효율적인 고유 식별자(예: 정수형 고유 키)가 없는 테이블은 데이터 전송 및 동기화에 문제를 일으킬 수 있습니다.\n\n데이터 전송에 미치는 영향: 이는 점진적으로 부분적인 테이블 이전 및 CDC 방법에 대한 중대한 문제입니다. 고유 식별자는 변경 사항을 추적하고 전송 중 데이터 일관성을 보장하는 데 필수적입니다.\n\n귀하의 모법: 신뢰성 있는 데이터 동기화 및 추출을 용이하게 하기 위해 각 테이블이 자동 증가 정수형 키와 같은 효율적인 고유 식별자를 갖도록 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n예시: Cloud Spanner에서 정수형 대신 문자열 유형의 고유 키를 사용하면 대규모 테이블의 점진적 추출 및 병렬 처리가 제한될 수 있어서 대량 데이터 처리를 효율적으로 다루는 데 어려움을 겪을 수 있습니다. 자동 증가 정수 키를 사용하면 이 과정을 간단히 할 수 있습니다.\n\n## 복잡한 데이터 유형의 사용\n\n함정: JSON, 배열 또는 사용자 정의 유형과 같은 복잡한 데이터 유형을 활용하면 데이터 추출 및 변환의 용이성이 저하될 수 있습니다.\n\n데이터 전송에 미치는 영향: 이 문제는 모든 데이터 전송 유형에 영향을 미치며, 이러한 유형을 처리하는 복잡성 때문에 데이터 추출, 변환 및 데이터 웨어하우스로 데이터 로드가 어려워집니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nBest Practice: 가능한 한 간단하고 원자적인 데이터 유형을 사용하세요. 보다 복잡한 데이터의 경우, 이러한 유형을 효율적으로 처리할 수 있는 도구와 프로세스가 있는지 확인해야 합니다.\n\n예: JSON 객체로 고객 선호도를 저장하는 것은 응용 프로그램에 편리할 수 있지만, 데이터 추출과 분석이 복잡해질 수 있습니다. 그 대신에 이 정보를 저장하기 위해 구조화된 테이블을 사용해, 쿼리하고 전송하기 쉽도록 만드는 것을 고려해보세요.\n\n## 비정규화된 데이터\n\n위험: 비정규화된 테이블은 데이터 중복과 저장 요구 사항 증가로 이어질 수 있어, 데이터 관리와 전송이 복잡해질 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n데이터 전송에 미치는 영향: 전체 테이블 및 증분 전송의 경우 특히 문제가 됩니다. 비정규화된 데이터는 전송되는 데이터의 양과 복잡성을 증가시켜 비효율성을 야기할 수 있습니다.\n\n최상의 실천 방법: 중복을 줄이고 데이터 무결성을 향상시키기 위해 필요한 경우 정규화 원칙을 적용하십시오. 그러나 과도한 정규화는 복잡한 조인 및 성능 저하를 야기할 수 있으므로 성능 고려와 균형을 유지해야 합니다.\n\n예시: 주문마다 반복되는 주소 정보를 포함한 비정규화된 고객 테이블을 고객 및 주소 테이블로 분리하여 중복을 줄이고 데이터 무결성을 향상시킬 수 있습니다. 그러나 정규화가 쿼리를 과도하게 복잡하게 만들고 성능에 영향을 주지 않도록 주의해야 합니다.\n\n## 데이터 파티셔닝을 무시하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n문제점: 파티션화되지 않은 대형 테이블은 쿼리 성능을 느리게 만들 수 있고 데이터 추출 프로세스를 복잡하게 만들 수 있습니다.\n\n데이터 전송에 미치는 영향: 이는 대규모 데이터 세트를 처리할 때 특히 모든 데이터 전송 유형에 영향을 줍니다. 파티션화의 부족은 성능 병목 현상과 증가된 자원 사용을 초래할 수 있습니다.\n\n최선의 방법: 쿼리 성능을 향상시키고 데이터 추출을 더욱 관리하기 쉽게 하기 위해 테이블 파티션화를 구현하세요.\n\n예시: 대규모 판매 테이블을 날짜별로 파티션화하면 최근 데이터에 대한 빠른 쿼리와 오래된 데이터의 쉬운 관리가 가능해집니다. 이는 성능을 향상시키고 점진적 데이터 추출을 더 효율적으로 만듭니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 데이터 소비 요구 사항을 무시하는 경우\n\n난관: 애플리케이션 개발자들이 데이터 엔지니어링 및 분석에서 데이터 사용 방법을 무시하고 애플리케이션 요구 사항에만 집중한다.\n\n데이터 전송에 미치는 영향: 이는 모든 데이터 전송 유형에 영향을 미친다. 데이터 엔지니어와 분석가의 요구 사항을 무시하면 비효율적인 데이터 모델이 만들어지며 데이터 추출과 분석이 복잡해질 수 있다.\n\n최선의 실천 방법: 스키마 디자인 중 데이터 엔지니어와 분석가의 요구 사항을 고려하여 데이터가 효율적으로 소비되고 분석될 수 있도록 하는 것이 좋다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n예시: 데이터 과학자가 데이터를 쿼리하는 방법을 고려하지 않고 스키마를 설계하면 비효율적인 조인 및 복잡한 쿼리가 발생하여 분석이 느려지고 자원 사용량이 증가할 수 있습니다. 데이터 사용자와 협력하여 요구 사항을 이해하고 이에 맞게 스키마를 설계해보세요.\n\n## 전달되지 않은 스키마 변경 사항\n\n주의사항: 데이터 소비자와 협의 없이 고유 키 유형을 변경하는 등 스키마 요소를 수정하는 것은 기존 데이터 파이프라인을 망가뜨릴 수 있습니다.\n\n데이터 전송에 미치는 영향: 특히 점진적으로 일부 테이블을 전송하거나 CDC 방법을 사용하는 경우, 스키마 변경은 데이터 추출 및 동기화 프로세스를 방해할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n**최선의 방법**: 애플리케이션 개발자와 데이터 소비자 간의 의사소통을 촉진하여 스키마 변경 시 모든 이해관계자의 요구사항을 고려합니다.\n\n**예시**: MySQL에서 Google Cloud Spanner로 이전하고 정수 형식의 고유 키를 문자열 형식으로 변경하는 동안 증분 데이터 추출 프로세스가 중단되었습니다. 모든 스키마 변경 사항이 모든 이해관계자와 협의되었음을 확인하세요.\n\n## 미래 데이터베이스 이전을 위한 계획\n\n**주의할 점**: 애플리케이션 개발자들은 종종 미래 데이터베이스 이전을 고려하지 않고 스키마를 설계하는데, 이는 데이터 파이프라인과 데이터 소비에 영향을 줄 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n데이터 전송에 미치는 영향: 이는 모든 유형의 데이터 전송에 영향을 줄 수 있으며, 향후 이주 및 업데이트를 더 어렵고 방해할 수 있습니다.\n\n최선의 실천 방법: 잠재적인 미래의 데이터베이스 마이그레이션을 고려하고 해당 마이그레이션이 데이터 파이프라인 및 데이터 소비에 미치는 영향을 고려하십시오. 기술 및 인프라 변화에 대응할 수 있는 스키마를 설계하세요.\n\n예: MySQL에서 다른 데이터베이스 시스템으로 쉽게 마이그레이션할 수 있는 스키마를 설계하면 지속성을 확보하고 데이터 파이프라인에 발생하는 장애 가능성을 줄일 수 있습니다. 이는 표준화된 데이터 유형을 사용하고 마이그레이션을 복잡하게 만드는 데이터베이스별 기능을 피함으로써 이루어집니다.\n\n## 데이터 수용 용량 관리 및 전송 전략 적응하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n잘못된 점: 데이터 성장에 대한 계획을 세우지 않으면 데이터 전송과 처리에 어려움이 생길 수 있으며 데이터 양이 증가할수록 이러한 문제가 심화될 수 있습니다.\n\n데이터 전송에 미치는 영향: 이는 모든 데이터 전송 유형에 영향을 미치며 특히 데이터 양이 늘어날수록 더 큰 영향을 줄 수 있습니다. 계획을 세우지 않으면 데이터 전송 프로세스가 비효율적이고 자원을 많이 소모하는 경향이 있습니다.\n\n권장 사항: 데이터 성장을 고려하고 데이터 크기가 증가함에 따라 전송 전략을 조정하세요. 간단한 전체 테이블 전송부터 시작하여 필요에 따라 점진적으로 로드하거나 CDC로 전환하세요.\n\n예시: 'table'에서 SELECT \\* FROM을 사용하여 처음에는 작은 테이블을 전송할 수 있지만 테이블이 커지면 증분 로드 또는 CDC를 사용하여 증가된 데이터 양을 효율적으로 처리해야 합니다. 데이터 성장에 맞게 전송 전략을 정기적으로 검토하고 업데이트하여 확장 가능성을 보장하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n일반적인 함정을 다루고 최선의 방법을 채택함으로써 응용 프로그램 개발자들은 효율적인 데이터 전송 및 분석을 지원하는 데이터베이스 스키마를 설계할 수 있습니다. 이 종합적인 접근 방식은 데이터 인프라가 견고하고 확장 가능하며 다양한 비즈니스 요구를 지원할 준비가 되어 있는지를 보장합니다.\n\n# 결론\n\n응용 프로그램 개발자로서 데이터베이스 스키마 설계가 데이터 활용에 미치는 중요한 영향을 인식하는 것이 중요합니다. 스키마를 설계하는 것은 단순히 응용 프로그램의 즉각적인 요구사항을 충족하는 데 그치는 것이 아니라, 데이터가 데이터베이스에서 데이터 웨어하우스로 전송되는 방식 및 비즈니스 인텔리전스에 효과적으로 분석되고 활용되는 데 중추적인 역할을 합니다.\n\n본 문서에서 다룬 함정과 해결책은 스키마 설계를 개선하기 위한 가치 있는 힌트와 지침을 제공하며, 모든 이해관계자들에게 데이터에 더 쉽게 접근하고 활용할 수 있도록 돕습니다. 이러한 일반적인 함정을 최선의 방법으로 해결함으로써 효율적인 데이터 전송, 동기화 및 분석을 보장하고, 이로써 더 견고하고 확장 가능한 데이터 인프라로 이어집니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그러나 이러한 함정을 인식하고 대응하는 것은 해결책의 일부에 불과합니다. 다부서간 협업의 중요성은 강조할 수 없을 만큼 큽니다. 스키마를 효과적으로 설계하는 것은 데이터와 그 활용 방법을 설계하는 것을 의미합니다. 이를 위해 데이터 엔지니어, 데이터 분석가, 데이터 과학자, 그리고 응용프로그램 개발자들의 입장과 협력이 필요합니다. 다부서간 노력은 스키마 설계 과정 중 모든 잠재적 문제와 요구 사항이 고려되도록 합니다. 응용프로그램 개발자들은 애플리케이션 요구 사항을 이해하면서 다른 기능들의 데이터 요구 사항을 이해함으로써 이 협력 노력에서 중요한 역할을 합니다. 이러한 협력을 통해 아니면 발생할 문제들을 미리 예방하여 데이터를 더욱 접근하고 사용 가능하게 만들 수 있습니다.\n\n요약하면, 데이터베이스 스키마를 설계하는 것은 데이터 설계의 중요한 부분입니다. 데이터베이스 내의 데이터를 비즈니스 목적으로 어떻게 활용하고 해제할지를 이해하는 것을 의미합니다. 응용프로그램 개발자들은 애플리케이션 측면에 초점을 맞추는 것뿐만 아니라 스키마 설계가 데이터 엔지니어링, 분석 및 전반적인 비즈니스 지능에 미치는 영향을 고려해야 합니다. 최고의 모범 사례를 채택하고 협력적인 환경을 유지함으로써 조직은 다양한 비즈니스 요구 사항을 지원하고 보다 나은 의사 결정과 혁신을 이끌 수 있는 데이터 인프라를 구축할 수 있습니다. 오늘날의 데이터 중심 세계에서 데이터의 최대 잠재력을 발휘하는 데 핵심적인 접근 방식입니다.\n","ogImage":{"url":"/assets/img/2024-05-17-DatabaseSchemaDesignforDataEngineeringEssentialPitfallsandBestPractices_0.png"},"coverImage":"/assets/img/2024-05-17-DatabaseSchemaDesignforDataEngineeringEssentialPitfallsandBestPractices_0.png","tag":["Tech"],"readingTime":18},{"title":"런던 마라톤의 역사를 데이터로 만나보세요","description":"","date":"2024-05-17 19:02","slug":"2024-05-17-TheHistoryoftheLondonMarathonToldbytheData","content":"\n![이미지](/assets/img/2024-05-17-TheHistoryoftheLondonMarathonToldbytheData_0.png)\n\n몇 달 전, 저는 미국 마라톤과 관련된 이십 년의 데이터를 탐구하는 일련의 기사를 작성했습니다.\n\n그 시리즈의 일부로, 저는 미국에서 열리는 세 개의 세계 마라톤 메이저인 보스턴, 시카고, 뉴욕에 대해 깊이 파헤쳤습니다.\n\n당시 일부 독자들은 런던 마라톤의 역사에 대해 물었지만, 제 초점은 미국 마라톤에 있었습니다. 이는 편의상 그랬다고 할 수 있습니다. 미국 마라톤에 대한 데이터에 쉽게 접근할 수 있었지만 전 세계의 레이스에 대한 데이터를 수집하는 것은 더 어려워지고 있었기 때문입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n하지만 제 할 일 목록에 있었어요. 그리고 지난 주말에 런던 마라톤이 열려서, 마침내 이를 처리하기에 좋은 시기인 것 같아요.\n\n그렇다면 데이터는 런던 마라톤의 역사와 지난 몇 십 년간 어떻게 변화했는지에 대해 우리에게 무엇을 말해줄까요?\n\n# 사용 데이터는 무엇인가요?\n\n이 분석에서는 Athlinks의 데이터를 사용했습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그들의 데이터베이스에는 2001년부터 시작된 런던 마라톤 개인 결과가 포함되어 있습니다. 런던 마라톤 웹사이트에는 일부 오래된 경주 결과가 있지만, 해당 결과는 2014년부터의 것만 있습니다.\n\n저는 Athlinks에서 각 참가자의 성별, 나이 및 완주 시간을 수집한 후, Python의 Pandas 패키지를 사용하여 데이터를 분석하였습니다.\n\n나이가 보고된 방식에 일관성이 없는 것이 있었습니다. 많은 해에 걸쳐, 참가자의 나이를 해당 연령 그룹의 시작으로 내림하여 기재한 것으로 보입니다. 20대의 참가자는 18세(18~39세 범위)로 보고되었습니다. 그래서 저는 참가자들을 40세 미만부터 시작해서 5년 단위 연령 그룹을 거쳐 80세 이상까지 범주화했습니다.\n\n2006년의 데이터에는 뭔가 이상한 것이 있는 것으로 보입니다. 40대의 참가자들이 40세로 보고되어, 그들은 40세 이하 연령 그룹에 포함된 것으로 보입니다. 그래서 해당 연도의 연령 데이터 옆에 정신적인 별표를 해 주세요. 그러나 나머지 연도는 신뢰할 만한 것으로 보입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 데이터를 통해 몇 가지 질문을 탐색해 볼 수 있어요:\n\n- 이 경주가 몇 년 동안 어떻게 성장했나요?\n- 러너들의 연령과 성별과 같은 인구 통계가 어떻게 변화했나요?\n- 러너들이 더 빠르거나 느려졌거나, 아니면 비슷했는지?\n\n그러면 자세히 알아보도록 할게요.\n\n# 시간이 흘러 필드가 어떻게 변화했는가\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n현대 런던 마라톤의 첫 대회는 1981년에 열렸어요.\n\n주최자들은 뉴욕 시티 마라톤에서 영감을 받았어요 — 작은 대회에서 대규모 참가 이벤트로의 전환을 주도한 데서 따왔으니까 적절한 선택이었죠.\n\n런던은 Polytechnic Marathon과 함께 자체적인 풍부한 마라톤 역사를 가지고 있어요. 그러나 대부분의 오래된 마라톤과 같이 몇 백 명 이상은 참여하지 않는 작은 이벤트였어요.\n\n런던 마라톤은 이를 바꿨어요. 첫 런던 마라톤에는 6,000명 이상의 러너가 완주했고, 1980년대를 통해 대규모로 성장했어요. 단 두 번째 해에만 뉴욕보다 많은 완주자가 있었답니다. 비록 뉴욕이 가장 큰 마라톤의 왕관을 되찾았지만, 그 이후 런던은 전 세계에서 가장 큰 레이스 중 하나가 되었어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 마라톤의 성장\n\n따라서 이 맥락을 고려하면 데이터를 자세히 살펴보겠습니다.\n\n매년 몇 명이 런던 마라톤을 완주하나요? 그리고 2001년 이후로 그 수는 어떻게 변했나요?\n\n지난 스무 해 동안에는 완주자 수가 조금씩 늘고 있는 것을 볼 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n2001년에는 거의 30,000명의 참가자가 있었습니다. 몇 년 동안 변동이 있지만, 2019년까지 꾸준히 증가하다가 레이스가 40,000명을 초과하는 성장이 이루어졌습니다.\n\n그 성장세는 2020년에 코로나19로 중단되었습니다. 세계적으로 일시 중단된 이 시기에도 런던에서는 60명의 엘리트 선수들을 위한 소규모 이벤트가 열렸지만, 대규모 마라톤은 개최되지 않아서 차트에서는 빠져 있습니다.\n\n하지만 2021년에는 빠르게 회복되었고, 2023년까지는 2019년에 세운 이전 최고 기록을 훌쩍 넘는 종료자 수를 기록했습니다. 레이스는 거의 50,000명에 이르는 종료자를 기록했는데, 이는 세계에서 가장 큰 마라톤 대회 목록 상위에 위치하게 됐습니다.\n\n## 여성 참가자 증가\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n런던 마라톤에 여성이 처음으로 참가한 것은 있었지만, 여성들의 러닝은 아직 어린 나이였습니다. 여성 이벤트가 올림픽에 포함된 것은 1984년에 이루어졌죠.\n\n80년대와 90년대를 통해, 마라톤은 여전히 남성들에 의해 주도되었지만, 천천히 변화하기 시작했습니다. 지난 20년 동안, 여성들의 마라톤 참가는 급격하게 증가했습니다.\n\n이런 변화가 런던에서는 어떻게 나타났을까요?\n\n위 시각화 자료는 완주자 수를 보여줍니다 — 빨간 막대는 남성을, 초록 막대는 여성을 나타냅니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n청색 선은 여성 참가자들이 차지하는 비율을 나타냅니다.\n\n초반에는 남성이 압도적이었습니다. 2001년에는 마친 참가자들 중 23%만 여성이었습니다.\n\n하지만 여성 수는 2001년의 약 6,000명에서 상당히 증가했습니다. 2010년에는 거의 두 배로 늘었습니다. 2023년에는 세 배가 넘게 증가했고, 여성 참가자 수가 20,000명을 처음으로 넘어섰습니다.\n\n이 기간 동안 백분율도 지속적으로 증가했습니다. 2019년 이후 상대적으로 안정되어 왔으며, 최근 몇 년 동안은 완주자의 약 40%가 여성이었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n레전드에서 '여성'을 클릭하면 해당 막대를 숨기고 분야의 남성 부분을 격리할 수 있습니다. 흥미로운 점은 지난 20년간의 남성 완주자 수가 꾸준히 유지되어 왔다는 것입니다.\n\n2023년에는 28,000명이 넘는 남성 완주자가 발생한 급증이 있었지만, 나머지 시기는 20,000명에서 25,000명 사이로 변동했습니다. 본질적으로 경주의 성장은 거의 모두 여성들로부터 왔습니다.\n\n## 분야의 점차적 그레이징\n\n보스턴 마라톤의 데이터를 분석할 때, 러너들이 나이를 먹고 있다는 것을 알게 되었습니다. 이 패턴은 다른 경주에서도 나타나고 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n런던에서도 비슷한 일이 일어나고 있나요?\n\n이 차트에서 각 색상은 서로 다른 연령 그룹의 완주자 수를 나타냅니다. 연령 그룹은 가장 어린 사람(40세 미만)이 왼쪽에 있고 가장 나이 많은 사람(80세 이상)이 오른쪽에 있습니다.\n\n이전에 언급한 대로, 2006년의 소스 데이터에 문제가 있습니다. 그러므로 그곳에서 보이는 이상치를 무시하십시오. 러너들의 연령이 결과 집합에서 잘못 표시되었기 때문일 가능성이 높습니다.\n\n드롭다운 메뉴를 사용하여 남성과 여성을 번갈아 선택할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n남성들 중에서, 조깅을 하는 총 인원은 (2023년을 제외하고) 크게 변하지 않았어요.\n\n40대 초반의 남성(보라색) 인원은 처음 몇 년 동안 늘어났다가, 이후에는 4,000명 정도에서 안정되는 것으로 보입니다. 다만, 다른 연령 그룹(45-49세 이상)은 시간이 흐를수록 계속해서 늘어나는 추세입니다.\n\n여성들 중에서는, 2001년부터 2023년까지 전체 참가자 수가 계속해서 늘어나면서, 상대적인 변화를 파악하기 어려워요. 중장년 러너들이 더 많아지고 있지만, 20대와 30대 러너들도 늘어나고 있어요.\n\n그래프의 대체 버전은 각 연령 그룹을 전체 성별 인원의 백분율로 표시하고 있어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여기서 젊은 남성의 비율이 천천히 감소하는 것과 비교하여 45세 이상의 남성 비율이 천천히 증가하는 것이 더 쉽게 볼 수 있어요.\n\n여성 중에서는 변화가 더 극심해요. 초기에는 여성 중 3분의 2가 40세 미만이에요. 하지만 마지막에는 이 비율이 50%에 가까워지고, 모든 연령 그룹에서 증가했어요.\n\n이 변화는 코로나 이후에 더욱 확대됐어요. 2023년에는 여성 중 10% 이상이 55세 이상이었는데, 2001년에는 5% 미만이었어요.\n\n이러한 변화를 볼 수 있는 한 가지 방법은 각 연령 그룹 중 여성 비율을 그래프로 나타내어 시간이 지남에 따라 어떻게 변하는지 보는 것이에요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n조건부 분석에 대한 그래프와 같이 여기서 빨간색은 남성을 나타내고 초록색은 여성을 나타냅니다. 파란색은 여성 참가자의 백분율을 보여줍니다. 다른 점은 연령 그룹별로 분리되어 있다는 것입니다. 슬라이더를 드래그하거나 재생 버튼을 눌러 시간이 지남에 따라 어떻게 변하는지 살펴볼 수 있습니다.\n\n시간이 지남에 따라 여성 백분율이 증가하지만 언제나 젊은 연령 그룹 중에서 더 높습니다. 그러나 시간이 흐름에 따라 차이가 상당히 줄어듭니다.\n\n2019년까지, 20대, 30대, 40대 및 50대의 참가자들 간의 차이가 훨씬 줄어들었습니다. 2023년으로 빨리 이동하면, 이러한 연령 그룹 모두 유사한 비율을 가지고 있습니다 — 남성 60%와 여성 40% 정도입니다.\n\n시간이 지남에 따라 남성과 여성 사이의 참가자들 간의 균형이 더 맞추어졌지만, 변화가 되기 까지는 최고 연령 그룹에 따라 따라잡는 시간이 필요했습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 런던 마라톤의 완주 시간\n\n마침내, 완주 시간은 어떻게 변화했나요?\n\n런던은 악명높은 빠른 코스이며, 한 개 이상의 세계 신기록이 세워졌습니다.\n\n## 역대 우승자들\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래 시각화는 매년 남성 (빨강)과 여성 (녹색)의 우승 시간을 그래프로 표시합니다.\n\n남성들 중에는 약간의 하향 트렌드가 있습니다. 초기에는 남성 우승자들이 모두 2:06에서 2:07 범위에 있었습니다. 2008년 이후 대부분의 우승자들이 2:05 또는 더 빨리 완주했지만 더디게 완주한 해도 몇 해 있었습니다.\n\n남성 중에서 가장 빠른 시간은 2023년에 있었는데, 켈빈 킵툼이 2:01:25로 완주했습니다.\n\n한편, 여성은 2003년에 최고의 시간을 보였습니다. 그 해, 폴라 래드클리프가 2:15:25로 우승했습니다. 그녀는 2019년까지 계속되는 세계 신기록을 세웠습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그 경주에서 여자 엘리트 선수들은 레드클리프를 자극하여 그러한 뛰어난 시간을 선보이도록 돕는 남성 페이서들과 함께 출발했습니다. 이 종류의 경주가 올해 읽었을 수도 있는 “혼성”과 “여성 전용” 세계 기록 사이의 차이의 이유입니다. 2003년 경주 중계를 여기서 시청할 수 있습니다.\n\n최근 몇 년간 여자 우승자는 종종 2:17부터 2:18 정도의 시간대에 올랐습니다 — 많은 해보다는 빠르지만 레드클리프의 2003년 시간보다는 빠르지 않습니다.\n\n## 총 평균 완주 시간\n\n하지만 우리는 일반인이고, 로마 마라톤에서 우승하는 것은 아닙니다. 더 흥미로운 질문은 그들 뒤의 일반 대중들 사이에서 무슨 일이 벌어지고 있는지입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 그래프는 경기장의 세 지점에서의 완주 시간을 보여줍니다 — 90번째 백분위수 (다른 선수들보다 90% 이상 빠른 선수), 75번째 백분위수 (다른 선수들보다 75% 이상 빠른 선수), 그리고 중앙값(팩의 중간에 있는 선수).\n\n전체 필드를 보는 것은 속임수가 될 수 있습니다. 왜냐하면 인구 통계의 급격한 변화가 평균 시간에 영향을 미칠 수 있기 때문입니다.\n\n하지만 이 그래프가 보여주는 것은 2018년에 날씨가 얼마나 나빴는지라는 것입니다. 그 해가 기록상으로 가장 더운 경주였고, 2007년도 그다지 뒤떨어지지 않았습니다. 이 두 해에 그래프가 솟은 이유가 분명히 그것 때문일 것입니다.\n\n## 성별을 고려한 경우\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n결과를 성별로 세분화하면 가능한 추세를 식별할 수 있어요. 나이는 여전히 잠재적으로 혼동을 줄 수 있는 변수이지만, 인구통계학적 변화 중 가장 큰 변화가 성별 사이에서 일어났어요.\n\n세 줄은 동일한 장소를 나타내지만, 이 시각적으로 빨간 점은 남성이고 초록 점은 여성이에요.\n\n특히 더 빠른 남성들 중에서 시간이 개선되고 있어요. 최고의 여성 선수들 중에서는 약간의 개선이 있지만, 느린 여성 선수들 중에서는 트렌드가 보이지 않는 것 같아요.\n\n## 나이의 느려짐을 고려하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그럼 만약 연령과 성별로 모두 자세히 살펴본다면 어떨까요?\n\n이 시각적 자료를 통해 여성들의 세 가지 포지션을 왼쪽에서, 남성들의 세 가지 포지션을 오른쪽에서 확인할 수 있습니다. 그러나 위쪽의 버튼들을 사용하여 결과를 연령 그룹으로 필터링할 수 있습니다.\n\n젊은 남성들 중에서는 최근 몇 년 동안 시간이 분명히 개선되었습니다. 마지막에는 상위 10%가 3시간 15분에서 3시간 20분 아래로 개선되었습니다. 젊은 여성들도 약간 개선되었는데, 특히 2012년부터 개선되었습니다. 마지막에는 상위 10%가 3시 30분대에 마칩니다.\n\n연령 그룹이 높아짐에 따라 40대와 50대에서 약간의 하향 추세가 보입니다. 그 이상으로 올라가면 약간 무작위로 보이기 시작합니다. 그때 연령 그룹이 충분히 작아서 매년 안정적인 관계가 되기 힘들 수도 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만약 이 시간들을 미국 메이저 대회인 보스턴, 뉴욕, 그리고 시카고의 시간과 비교한다면, 런던의 시간들은 보스턴과 시카고 사이에 위치하게 될 거에요. 보스턴의 시간들은 런던의 것보다 빠르며(아마도 더 많은 예선 참가자 수에 의해), 그러나 런던의 시간들은 시카고의 것보다 빠르죠.\n\n하지만 조금 이상한 것은 2019년 이후에는 큰 차이가 없다는 거에요. 대부분의 대규모 미국 대회에서는 이 지점에서 시간이 크게 단축되었거든요. 저는 항상 대량 시장에 슈퍼 슈즈가 확산되고 있다는 것이 이 현상을 촉진하고 있다고 가정했었어요.\n\n하지만 이 효과는 런던에는 존재하지 않는 것으로 보여요.\n\n# 런던 2024는 어디에 속할까요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그래서 그것이 역사이자 기반이 되었습니다.\n\n이제 지난 스물 해간 동안 런던에서 어떤 변화가 있었는지를 알게 되었으니, 이번 해 레이스의 데이터를 자세히 살펴보겠습니다.\n\n올해 참가자가 더 많아졌을까요? 성별로 더 균형을 이루었을까요? 참가자들은 더 나이가 많아졌을까요?\n\n해당 분석 결과는 일주일 후쯤 다시 확인해주세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만약 위에 대한 관심이 있다면 — 또는 다른 말로 말해, 마라톤에 관한 데이터 중심 이야기에 관심이 있다면 — 이메일 업데이트를 받기 위해 구독하는 것을 잊지 마세요.\n\n저는 열렬한 러너이자 데이터 애호가입니다. 올해의 보스턴 마라톤은 컷오프 타임 때문에 놓쳤지만, 2025년에는 거기 참가하기를 희망하고 있습니다. 제가 무슨 활동을 하는지 계속해서 따라갈 수 있는 방법은 다음과 같습니다:\n\n- 저의 훈련에 대한 소식을 들으려면 Running with Rock을 팔로우하세요.\n- 마라톤 훈련 계획 선택에 대한 이 팁들을 읽어보세요.\n- Strava에서 저를 쫓아보세요.\n","ogImage":{"url":"/assets/img/2024-05-17-TheHistoryoftheLondonMarathonToldbytheData_0.png"},"coverImage":"/assets/img/2024-05-17-TheHistoryoftheLondonMarathonToldbytheData_0.png","tag":["Tech"],"readingTime":14},{"title":"Read the Docs 트래픽 분석을 위해 Vizro-AI를 활용한 재사용 가능한 대시보드를 구축했어요","description":"","date":"2024-05-17 19:00","slug":"2024-05-17-IBuiltaReusableDashboardforReadtheDocsTrafficAnalyticsUsingVizro-AI","content":"\n## (50 줄 미만의 코드로)\n\n<img src=\"/assets/img/2024-05-17-IBuiltaReusableDashboardforReadtheDocsTrafficAnalyticsUsingVizro-AI_0.png\" />\n\n이 글에서는 기술 작성자로서 유지 관리하는 문서의 트래픽 데이터를 시각화하기 위해 대시보드를 구축하는 방법을 설명하겠습니다. 디자인 스킬이 부족하고 파이썬 경험이 제한적이어서 유지하는 문서의 영향과 사용량을 보여주기 위한 간단하고 로우코드 접근 방식이 필요했습니다. 이것은 오픈 소스 솔루션인 비즈로(Vizro)를 로우코드 대시보드의 템플릿으로 사용하고, 비즈로-AI(Vizro-AI)를 통해 생성적 AI로 개별 차트를 구축하는 것으로 나타났습니다.\n\n## 요약?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만약 당신이 바로 시작하고 싶다면, 내 GitHub 레포지토리에서 대시보드에 대한 Jupyter Notebook 코드를 찾을 수 있어.\n\n## Read the Docs 대시보드 프로젝트\n\n만약 나와 같이 Read the Docs (RTD)를 사용하여 오픈 소스 문서 프로젝트를 관리한다면, 아마도 프로젝트 대시보드에서 지난 90일치의 트래픽 데이터를 CSV 형식으로 다운로드할 수 있는 것을 발견했을 것입니다. 대시보드에는 페이지 뷰 합계 차트도 표시되어 있습니다, 아래와 같은 차트가 있죠.\n\n![RTD Traffic Chart](/assets/img/2024-05-17-IBuiltaReusableDashboardforReadtheDocsTrafficAnalyticsUsingVizro-AI_1.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n추가적인 시각적 출력을 위해 Google Analytics (GA)를 활용할 수 있습니다. 그러나 일부 프로젝트에서는 유럽 연합(EU)에서 특히 논란이 되는 일반 데이터 보호 규정(GDPR)과의 준수 때문에 GA를 사용하지 않기를 선호하기도 합니다.\n\n## 코드 및 데이터 가져오기\n\n아래 예시에서 사용된 가짜 CSV 트래픽 데이터는 저희 프로젝트의 트래픽을 비공개로 유지하기 위해 OpenAI의 도움을 받아 생성한 것입니다. 이 가짜 데이터는 진짜 RTD 데이터와 동일한 필드를 가지고 있어서 RTD 대시보드에서 다운로드한 데이터로 대시보드를 다운로드하고 사용할 수 있습니다.\n\n예시를 직접 실행하려면 가짜 데이터(또는 직접 다운로드한 데이터)와 Jupyter Notebook 코드가 필요합니다. 이는 기본 수준에서 쉽게 진행할 수 있지만 보다 고급 사용자는 확장할 수 있습니다. 개선된 버전을 만드신 경우 알려주시면 감사하겠습니다!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# Vizro와 Vizro-AI란 무엇인가요?\n\nVizro는 Plotly와 Dash를 기반으로 한 프레임워크로, 사용자 정의 대시보드 레이아웃을 지정하기 위해 구성 접근법을 사용합니다. Vizro 대시보드는 Vizro와 별도로 구성된 Vizro-AI가 생성한 차트로 채울 수 있습니다. Vizro-AI는 시각화 프로세스를 단순화하기 위해 생성적 AI를 활용하는 독립적인 패키지입니다.\n\n이 예에서, 저는 데이터와 자연어 지시사항을 제공했고, Vizro-AI가 Python 코드를 생성하고 요청한 차트를 생성했습니다. 이것은 저에게 쓰기 작업을 하는 측면에서 잘 작동했습니다. 왜냐하면 저는 프론트엔드 디자인 기술이 없고 Plotly를 잘 모르기 때문입니다. 하지만 OpenAI로부터 적절한 생성적 AI 프롬프트를 작성하고 차트를 얻는 것도 즐거운 일이라고 생각합니다.\n\n## Vizro-AI 설정하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n노트북 코드를 실행하기 전에 Vizro-AI를 Python 3.9 이상의 가상 환경 안에 설정해야 합니다. pip install vizro_ai 명령을 사용하여 패키지를 설치해주세요.\n\n다음으로 OpenAI에 접속하기 위해 API 키가 필요합니다. 계정이 없다면 먼저 생성하고, 무료 버전을 사용할 수 없기 때문에 모델을 이용하기 위해 일부 크레딧을 구매해야 합니다. API 키를 생성하고 환경에 추가하여 코드를 통해 OpenAI에 성공적으로 호출할 수 있게 해주세요. OpenAI 문서에 간단한 지침이 있고, Vizro-AI LLM 설정 가이드에도 이 과정이 포함되어 있습니다.\n\n## 차트 생성\n\n이 시점에서 주피터 노트북을 열어 첫 차트를 만들거나, 제 저장소에서 노트북을 열어 내가 작성한 코드를 차례로 살펴보고, RTD 데이터(또는 제공한 가짜 데이터)를 pandas DataFrame에 불러와주세요. 아래 코드에서는 df로 이름을 지었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래 코드는 Vizro-AI에 요청을 제출하여 Read the Docs 프로젝트 대시보드의 차트와 유사한 차트를 생성하는 방법을 보여줍니다. 이 차트는 날짜별 조회수를 보여주며 문서의 안정 버전과 최신 버전으로 데이터를 분할하여 두 개의 추적 값으로 나뉩니다:\n\nVizro-AI는 \"가장 최신 및 안정 버전의 각 날짜별 조회 수 행을 결합한 후 가장 최신 및 안정 버전의 조회수를 비교하는 선 그래프를 그리세요\"라는 자연어 쿼리와 데이터프레임을 모델에 전달합니다. 위 예제에서는 gpt-4 모델을 지정했습니다. Vizro-AI는 가격이 낮고 더 빠른 답변을 제공하기 위해 기본적으로 gpt-3.5-turbo를 사용하지만, 가장 정교한 차트 제공이 불가능합니다. 그래서 명시적으로 gpt-4 모델을 사용할 것을 요청했습니다.\n\n차트 출력은 데이터 및 쿼리 제출 시점에서 OpenAI로부터 받은 출력에 따라 달라집니다. explain=True 매개변수는 Vizro-AI에게 결과 차트 생성 방식을 설명하도록 요청하며, 해당 설명은 쥬피터 노트북에서 출력되며 show() 명령어에 의해 표시되는 차트와 함께 표시됩니다.\n\nVizro-AI가 제공하는 인사이트 텍스트는 트래픽 데이터 조작 방법을 설명합니다. 코드 섹션은 코드 스니펫이 요청된 선 그래프를 생성하는 방법에 따라 표시됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-05-17-IBuiltaReusableDashboardforReadtheDocsTrafficAnalyticsUsingVizro-AI_2.png\" />\n\n아래에 표시된 차트는 다음과 같습니다:\n\n<img src=\"/assets/img/2024-05-17-IBuiltaReusableDashboardforReadtheDocsTrafficAnalyticsUsingVizro-AI_3.png\" />\n\n## 더 많은 차트 만들기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nVizro-AI가 제공하는 코드를 활용하여 추가 차트를 작성했습니다. 다음과 같이 교통량을 자세히 설명하는 몇 가지 차트를 작성했습니다.\n\nVizro-AI가 데이터를 조작하고 차트를 생성하는 코드를 생성해 주어서 작업을 간편하게 해 주었습니다. 차트 자체만으로 유용하며, 더욱 유용한 것은 이를 조합하여 한 화면에 통합된 대시보드를 만드는 것입니다.\n\n## Vizro 대시보드 만들기\n\nVizro-AI 코드와 동일한 Jupyter Notebook에서 Vizro를 사용할 수 있습니다. Vizro 설명서에 설명된대로 pip install vizro를 수행해 주세요. 여기에는 차트 생성이 없는 간단한 대시보드의 구조를 위한 코드가 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 시점에서 두 가지 옵션이 있습니다:\n\n- 대시보드를 생성할 때마다 Vizro-AI를 사용하여 차트를 생성합니다.\n- Vizro-AI가 반환한 Python 코드를 직접 Plotly로 호출합니다.\n\n첫 번째 옵션은 더 적은 코드를 필요로 하지만 반환 속도가 느리고 더 비싸며, Vizro-AI를 사용하여 OpenAI를 호출하기 때문에 더 많은 비용이 소요됩니다. 두 번째 옵션은 더 빠르지만 코드 조작이 더 많이 필요합니다.\n\n다음은 대시보드 코드를 포함하는 셀입니다. 이 코드는 Vizro-AI를 통해 호출하는 함수를 사용하여 첫 번째 옵션을 보여줍니다. (자신의 실행을 계획하고 있다면, 이 코드를 실행하려면 내 레포지토리의 노트북을 사용하고 데이터를 로드하고 Vizro-AI에 대한 호출 설정을 설정하는 셀을 실행해야 합니다):\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n약간 다른 버전을 제공해본다. 여기서 두 번째 옵션을 사용하여 차트 중 하나를 생성했다. Plotly 조작은 제한되어 있어서 Python 코드를 약간 수정하여 라인의 색을 변경했다. (여러분이 직접 실행하려는 경우, 내 저장소의 노트북을 사용하고 데이터를 로드하고 차트 생성 함수를 설정하는 셀을 실행했는지 확인하세요).\n\n자신만의 Read the Docs 데이터로 대시보드를 시도해보기 위해 주피터 노트북을 다운로드할 수 있어요. 제가 제공한 가짜 데이터로 만든 대시보드는 다음과 같이 보입니다.\n\n제 동료 중 한 명(Nadija 감사합니다!)가 제게 팁을 줬어요. 대시보드를 노트북에서 실행한 다음 다음과 같이 선택한 포트를 보고 별도의 브라우저 창에서 볼 수 있다고 해요:\n\n```js\nVizro().build(dashboard).run(port=8006) # 브라우저에서 localhost8006\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n또 다른 방법(Anthony 님 감사합니다!)으로, 위의 두 번째 대시보드 예제에서 보여 드린 대로, 대시보드를 보기 위한 클릭 가능한 링크를 생성할 수 있습니다:\n\n```js\nVizro()\n  .build(dashboard)\n  .run((jupyter_mode = \"external\"));\n```\n\n# 마무리\n\n이 예에서는 Vizro-AI를 사용하여 문서 트래픽을 시각화하기 위한 Plotly 차트를 생성하고, 그 차트를 Vizro 대시보드에 구축하는 방법을 보여드렸습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만약 데이터 과학과 파이썬 기술이 있고 디자인에 재능이 있다면, Plotly와 Dash로 대시보드를 구축하는 도전에 도전해 보고 싶을 것입니다. 하지만 이런 기술이 없는 사람들에게는 OpenAI를 활용하여 위와 같은 결과물을 얻을 수 있다는 것이 정말 큰 변화입니다. 이제 50줄 정도의 코드로 Read the Docs 트래픽 데이터에 대한 유용한 시각화를 얻었습니다. 전문적으로 보이며 확장 가능하고 상대적으로 쉽게 공유할 수 있습니다. 추가적인 노력으로 필터, 매개변수 또는 별도의 탐색 가능한 페이지와 같은 사용자 정의 기능을 추가하여 더 개선할 수 있습니다.\n\n더 나아가, 동료들과 협업하여 대시보드 코드를 다른 Read the Docs 프로젝트에 맞게 수정할 수 있습니다. 프로젝트를 쉽게 설명하기 위해 주피터 노트북을 사용했지만, 이 방식은 파이썬 스크립트에서도 잘 작동하여 쉽게 공유하고 버전 관리를 할 수 있습니다. 또한 대시보드를 배포하여 동료들이 코드를 실행하지 않고 직접 액세스할 수도 있습니다.\n\n저희 팀은 이제 하루만에 기술 작가에 의해 구축된 문서 영향을 추적하는 데 유용하고 사용할 수 있는 대시보드를 소유하고 있습니다. 더 바랄 것이 무엇이 있을까요?\n\n이 글을 작성하는 동안 여러 차례 리뷰 피드백을 주신 동료들, 특히 Nadija와 Anna 그리고 Joe에게 감사드립니다.\n","ogImage":{"url":"/assets/img/2024-05-17-IBuiltaReusableDashboardforReadtheDocsTrafficAnalyticsUsingVizro-AI_0.png"},"coverImage":"/assets/img/2024-05-17-IBuiltaReusableDashboardforReadtheDocsTrafficAnalyticsUsingVizro-AI_0.png","tag":["Tech"],"readingTime":9},{"title":"마이크로소프트의 응용 프로그램 업데이트 접근 방식의 문제가 윈도우 PC에 혼란을 야기합니다","description":"","date":"2024-05-17 18:58","slug":"2024-05-17-MicrosoftsFlawedApproachtoAppUpdatesWreaksHavoconWindowsPCs","content":"\n![image](/assets/img/2024-05-17-MicrosoftsFlawedApproachtoAppUpdatesWreaksHavoconWindowsPCs_0.png)\n\n안녕하세요! WinRAR을 설치해 두셨나요? PC가 취약할 수 있습니다. 이 문제의 근본은 Windows 8로 돌아갑니다.\n\nChris Hoffman 작성\n\n여전히 적극적으로 악용되고 있는 방대한 보안 결함을 가진 WinRAR은 자동 업데이트를 지원하지 않는 많은 Windows 애플리케이션 중 하나입니다. 개발자는 전 세계적으로 5억 개 이상의 WinRAR 설치를 자랑하며, 따라서 수억 대의 PC가 오늘날 악성 ZIP 파일로부터 취약할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n2023년에 세계에서 가장 인기 있는 데스크톱 운영 체제가 설치된 응용 프로그램을 쉽게 업데이트할 수 있는 방법을 제공하지 않는다니, 어떻게 된 일인가요?\n\nWindows 업데이트는 보안 패치를 설치하지만 여기서 그치고 있어요. 다운로드한 많은 응용 프로그램은 스스로 업데이트를 수행하지만 일부는 업데이트를 확인할 생각조차 못 합니다. Microsoft가 Windows 8을 만드느라 많은 시간을 낭비하고 나서 그 이후 Windows 10으로 넘어가며 거의 모든 Windows 사용자가 원하지 않았던 유형의 애플리케이션을 위한 스토어를 구축하려고 했으면, PC 사용자는 현명한 결정을 할 수 있었을 것입니다. Windows 스토어에 대해 잃어버린 십 년이었죠.\n\n# WinRAR이 공격 받고 스스로 업데이트하지 않아요\n\n파일 아카이빙 프로그램 WinRAR의 결함은 특수하게 디자인된 ZIP 아카이브를 다운로드하고 열면 공격자가 PC에서 원하는 코드를 실행할 수 있다는 것을 의미합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n공격자들이 2023년 초부터 이 버그를 악용해왔습니다. WinRAR 개발사 RARLAB은 8월에 이 취약점을 수정한 업데이트를 출시했지만, 수개월 후에도 여전히 이 버그에 대해 언급 중입니다. 왜냐하면 정부 지원 사이버 범죄 조직을 포함한 기관들이 여전히 이를 악용하고 있기 때문입니다. 이는 구글의 위협 분석 그룹에 따르면 \"여러 국가의 그룹들\"이라고 합니다.\n\n문제는요: WinRAR은 자동으로 업데이트되지 않습니다. 심지어 업데이트를 확인하고 사용자에게 중요한 보안 업데이트가 가능하다고 알리지도 않습니다. 많은 사람들이 오래된 업데이트되지 않은 버전의 WinRAR을 사용하고 있으며 이 패치를 설치하지 않을 것입니다. 새로운 PC를 구입하고 다시 설치할 때에만 안전한 버전의 WinRAR을 얻을 것입니다. 소망하기를 그들이 악의적인 ZIP 파일을 열지 않았으면 좋겠네요.\n\n# WinRAR이 자동 업데이트되지 않는 이유는?\n\n그렇다면 왜 자동 업데이트 기능이 없는 걸까요? 저는 RARLAB에 연락을 취해보았고 WinRAR 개발자인 Eugene Roshall은 Windows가 웹사이트에서 다운로드한 데스크톱 앱을 자동으로 업데이트할 수 있는 방법을 제공하지 않는다고 말했습니다. \"모든 개발자는 모든 보안 및 기술적 문제를 고려하여 바퀴를 다시 발명해야 합니다.\"\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n로샬은 RARLAB이 업데이트 알림을 구현하는 것을 고려해 왔지만 기업 시스템 관리자들이 이 아이디어를 좋아하지 않고 사용자 컴퓨터에 팝업 알림이 나타나는 대신 소프트웨어 업데이트에 대해 중앙 집중식 접근을 선호한다고 말했습니다.\n\n하지만 RARLAB은 어쨌든 이 기능을 추가할 수도 있으며 해당 회사는 \"Avast, Kaspersky 및 기타 업데이트 프로그램과 긴밀히 협력하고 있다\"고 말했습니다.\n\n평균적인 Windows PC의 업데이트 상황은 정말 난잡합니다. 어도비, 구글, PC 제조업체 및 다른 개발자들로부터 별도의 업데이트 서비스를 가질 가능성이 매우 높습니다. 그것이 작동하더라도 각 개발자에게는 고통이 될 뿐만 아니라 CPU 및 메모리 자원을 소모하는 많은 불필요한 백그라운드 프로세스가 있습니다.\n\n저는 개인적으로 항상 7-Zip을 선호해 왔지만, 그것도 내장된 업데이트 확인기가 없습니다!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 윈도우 8 문제의 시작\n\n윈도우 8에 '앱 스토어'가 포함될 예정이라고 처음 들었을 때, 저는 흥분했습니다.\n\n데스크톱 리눅스에 대한 경험이 있는 사람으로서, 제가 가장 좋아하는 것 중 하나는 패키지 관리자입니다. 리눅스에서는 개발자 웹사이트에서 각 애플리케이션을 다운로드하는 대신 패키지 관리자를 통해 애플리케이션을 얻습니다. 업데이트가 나오면 패키지 관리자가 업데이트를 찾아 설치해줍니다. 중앙에서 관리되며 한 애플리케이션이 모든 애플리케이션 업데이트를 확인하고 설치합니다.\n\n2011년 마이크로소프트 빌드에서 최초로 발표된 Windows Store는 윈도우 8에서 그런 종류의 경험을 제공할 수 있었을 것입니다. 그러나 마이크로소프트는 새로운 '메트로 앱'을 위한 새로운 스토어만을 제공하기로 결정했습니다. (그러나 개발자들은 전통적인 데스크톱 앱에 대한 목록을 게시하고 직접 PC 사용자를 웹사이트로 이동할 수 있었습니다.)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그보다 나쁜 것은, Windows 8 스토어가 한 때 사기 가득했다는 것이었습니다. \"VLC\" 같은 것을 검색하면 VLC를 다운로드할 위치를 보여주는 애플리케이션을 지불하라는 저금급한 결과물들로 가득찼습니다. 이 문제를 강조한 첫 번째 사람은 아니었지만, 2014년에 이 사기에 대해 강조한 것은 어디서나 Windows 사용자들의 불만을 대변했습니다. 결국, Microsoft는 2015년에 스토어를 개선하기로 약속하며 일반인들의 압력에 반응했습니다.\n\n# Microsoft은 Windows 10에서 시간을 낭비했습니다\n\nWindows 10은 Windows 8의 많은 문제를 해결했지만, 여전히 Microsoft의 불명확한 앱 전략의 피해자였습니다.\n\nWindows 10이 출시된 시점에도 스토어는 \"Universal Windows Platform\" 애플리케이션만 허용했습니다. 이것은 합리적이지 않았습니다. 그때쯤에는 Windows Phone이 사라졌으므로, 유니버설 플랫폼은 데스크톱 PC, Xbox 및 HoloLens가 되는 것인가요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nWindows 8과 Windows 10에서 PC 사용자들은 상점을 무시하도록 훈련을 받았습니다.\n\n# Windows 11은 너무 늦게 나왔습니다\n\n좋은 소식은 Windows 11이 이를 뒤집었다는 것입니다. 네, Windows 8 출시 9년 후에 마이크로소프트가 마침내 전통적인 Windows 데스크톱 애플리케이션을 데스크톱 PC 운영 체제의 앱 스토어에서 허용해야 한다고 결정했습니다.\n\n이제 개발자들은 전통적인 Windows 데스크톱 앱을 Windows 스토어에 넣을 수 있으며, PC 사용자들은 전통적인 Windows 데스크톱 앱을 설치할 수 있습니다. 스토어를 통해 응용프로그램을 중앙 집중식으로 업데이트할 수 있습니다. 하지만 우리는 다 무시하도록 훈련되었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n더 나쁜 것은 최신 Windows 11 PC에서 앱 스토어를 둘러보다가 스토어에 있는 VLC 같은 앱들이 \"제공 및 업데이트한 사람\"이라고 되어 있는 걸 발견했어요. 그래서 스토어에서 앱을 설치해도, 해당 앱이 여전히 자체 업데이트를 설치할 확률이 높아요.\n\n진짜 안타까운 일이에요. 새 PC를 설정하고 모든 앱을 자동으로 설치할 수 있으면 좋겠고요. 몇십 년 전 데스크톱 리눅스에서 할 수 있었던 것처럼 앱을 업데이트할 수 있는 단일 장소가 있으면 더 좋겠죠.\n\n# 전문가들은 다른 옵션을 가지고 있어요\n\n전문가들은 소프트웨어 업데이터 유틸리티나 winget, Chocolatey 같은 패키지 매니저를 활용할 수 있어요. 그러나 일반 Windows PC 사용자들은 여전히 웹사이트에서 프로그램을 다운로드하고 설치하고 있어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n차트 태그를 마크다운 형식으로 변경해 주세요.\n\n벌써 윈도우 데스크톱에서 이 문제들을 해결하는 최선의 방법이 스토어인지는 아마도 아닐 거예요. 하지만 만약 마이크로소프트가 지난 10년 동안 스토어를 진지하게 대하고 일반 PC 사용자와 그들이 실제로 사용하는 애플리케이션을 위해 사용할 만한 수준으로 만들려고 노력했다면, 우리는 해결책에 훨씬 가까웠을 거에요.\n\n적어도 윈도우 11은 RAR, 7Z 및 다른 아카이브 형식에 대한 내장 지원을 얻었기 때문에 WinRAR 및 7-Zip과 같은 애플리케이션을 업데이트하는 걱정 없이 제거할 수 있게 됐어요. 제 생각에는 그것이 발전이에요.\n\n원문 게시 위치: https://www.pcmag.com.\n","ogImage":{"url":"/assets/img/2024-05-17-MicrosoftsFlawedApproachtoAppUpdatesWreaksHavoconWindowsPCs_0.png"},"coverImage":"/assets/img/2024-05-17-MicrosoftsFlawedApproachtoAppUpdatesWreaksHavoconWindowsPCs_0.png","tag":["Tech"],"readingTime":7},{"title":"윈도우 컨셉트 저니 - wow64windll Wow64 콘솔 및 Win32 API 기록","description":"","date":"2024-05-17 18:57","slug":"2024-05-17-TheWindowsConceptJourneywow64windllWow64ConsoleandWin32APILogging","content":"\n일반적으로 \"wow64.dll\"(Win32 콘솔 및 Win32 API 로깅)은 WOW64에서 사용되는 동적 링크 라이브러리입니다. \"%windir%\\system32\\wow64win.dll\"에 위치한 64비트 이진 파일입니다. 이 DLL 파일은 Microsoft에 의해 디지털로 서명되었습니다.\n\n요약하면, \"wow64win.dll\"은 \"win32k.sys\" 진입점 함수들을 제공합니다(https://learn.microsoft.com/en-us/windows/win32/winprog64/wow64-implementation-details). 따라서 이는 \"win32k.sys\"에서 노출된 관련 시스콜을 호출하기 위해 사용됩니다(\"NtGdi*\" 또는 \"NtUser*\"로 시작되는 것과 같은 것들) — 아래 스크린샷에서 보여지는 대로(무료 버전의 IDA를 사용하여 캡처했습니다).\n\n마지막으로, DLL의 특성을 고려하면 원래 파일 이름은 \"wow64lg2.dll\"임을 알 수 있습니다 — 아래 스크린샷에서도 확인할 수 있습니다. 또한, \"wow64.dll\" (https://medium.com/@boutnaru/the-windows-concept-journey-wow64-dll-win32-emulation-on-nt64-8ff99ec32c43)은 \"wow64win.dll\"에 종속되어 있습니다. 따라서 일반적으로 user32.dll을 로드하지 않는 \"비 Windows 서브시스템\" 프로세스에서도로드될 수 있습니다(https://wbenny.github.io/2018/11/04/wow64-internals.html).\n\n다음 글에서 뵙겠습니다;-) 트위터에서 팔로우할 수 있으세요 — @boutnaru (https://twitter.com/boutnaru). 또한 다른 글을 읽고 싶으시면 미디엄에서 확인 가능합니다 — https://medium.com/@boutnaru. 무료 eBook은 https://TheLearningJourneyEbooks.com에서 찾을 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![2024-05-17-TheWindowsConceptJourneywow64windllWow64ConsoleandWin32APILogging_0.png](/assets/img/2024-05-17-TheWindowsConceptJourneywow64windllWow64ConsoleandWin32APILogging_0.png)\n","ogImage":{"url":"/assets/img/2024-05-17-TheWindowsConceptJourneywow64windllWow64ConsoleandWin32APILogging_0.png"},"coverImage":"/assets/img/2024-05-17-TheWindowsConceptJourneywow64windllWow64ConsoleandWin32APILogging_0.png","tag":["Tech"],"readingTime":2},{"title":"여러분은 핫 코너를 제대로 활용하지 않고 있어요 이전에 아무도 말해주지 않은 꿀팁","description":"","date":"2024-05-17 18:54","slug":"2024-05-17-YoureUnderutilizingHotCornersHacksNobodyToldYouBefore","content":"\n맥 macOS의 핫 코너 기능이 정말 소홀히 다루어지고 있는 기능이에요. 왜냐하면 이렇게 말할 수 있어요:\n\n- 몇몇 사람들은 이 기능이 존재한다는 것을 알지만, 거의 사용하지 않아요.\n- 몇몇 사람들은 이 기능이 존재조차 모르고 있어요. (기본적으로 아래 오른쪽 모서리로 스와이프하면 퀵 노트를 열 수 있다는 건 알지만요)\n\n핫 코너를 통해 맥 화면의 네 구석 중 아무 쪽 모서리로도 포인터를 스와이프하여 10가지 사전 정의된 작업 중 하나를 실행할 수 있어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이것들은 10가지 사전 정의된 작업입니다:\n\n![image](/assets/img/2024-05-17-YoureUnderutilizingHotCornersHacksNobodyToldYouBefore_1.png)\n\n(‘—’는 아무 행동도 없음을 나타냄.)\n\n시스템 설정 ⚙️ `데스크톱 및 독 🖥️` 핫 코너에서 핫 코너를 원하시는대로 구성할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n(설정에 깊이 들어갈 필요가 있나요? 네, 따라서 직접 해당 페이지로 이동하는 이 바로 가기를 사용해보세요. 이 URL을 사용합니다: x-apple.systempreferences:com.apple.Desktop-Settings.extension?HotCorners)\n\n자, 여기 제임스라는 사용자의 핫코너 구성입니다:\n\n![이미지](/assets/img/2024-05-17-YoureUnderutilizingHotCornersHacksNobodyToldYouBefore_2.png)\n\n그러므로 그에게는(swiping towards)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 왼쪽 상단 모서리는 아무 기능도 하지 않습니다.\n- 왼쪽 하단 모서리에서는 현재 애플리케이션 창들이 표시됩니다.\n- 오른쪽 상단 모서리를 클릭하면 알림 센터가 열립니다.\n- 오른쪽 하단 모서리를 클릭하면 바탕 화면이 표시됩니다.\n\n잘 했어요, 제임스는 생산성을 위해 이러한 핫 코너 구성을 설정했어요. 그것을 즐기고 있어요.\n\n그러나 불행하게도 일할 때 활성 모서리 중 하나에 포인터가 닿으면 의도치 않게 이를 자주 작동시키고 있어요.\n\n생산성을 위해 만든 구성이 실제로 그것을 방해하고 있다는 것이 그에게 거슬리는 문제입니다. 그는 심지어 핫 코너를 공백으로 되돌리고 싶다고 생각한 적도 있었어요 — 그런데 이 꿀팁을 몰라서 그랬던 게죠:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# \"수정자 키\"를 설정하여 의도하지 않은 핫 코너 트리거 방지하기\n\n이것은 위장된 기능입니다 — 하지만 더 많은 사람들이 실제로 핫 코너를 사용할 것이라고 생각합니다.\n\n핫 코너를 구성할 때... 예를 들어 데스크톱으로 설정한다고 가정해 보세요. '데스크톱'을 클릭할 때 ⌘를 누르고 있는지 확인해 보세요. 그러면 이렇게 보이게 됩니다:\n\n![이미지](/assets/img/2024-05-17-YoureUnderutilizingHotCornersHacksNobodyToldYouBefore_3.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 의미는 데스크톱을 활성화시키기 위해서는 ⌘을 누른 채로 포인터를 그 모서리쪽으로 스와이프해야 합니다 (보통의 스와이프는 작동하지 않습니다).\n\n이것은 대부분의 의도하지 않은 트리거를 방지할 수 있습니다. ⌘을 누르고 포인터를 모서리쪽으로 스와이프는 매우 낮은 확률이기 때문입니다.\n\n사용할 수 있는 모든 수정자 키는 무엇인가요?\n\n- Shift ⇧\n- Control ⌃\n- Option ⌥\n- Command ⌘\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n알지만?\n무심코 트리거가 작동할 확률을 거의 0으로 줄이기 위해 두 개 이상의 수정자 키를 함께 사용하는 것도 좋을지 몰라요:\n\n![이미지](/assets/img/2024-05-17-YoureUnderutilizingHotCornersHacksNobodyToldYouBefore_4.png)\n\n멋지죠?\n\n# 이제, 프로 사용자를 위한 꿀팁 (그리고 그 중요성)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n1. 터미널을 통한 핫 코너 구성\n2. 쉬운 핫 코너 구성을 위해 이 오토메이터 앱을 가져다 쓰세요\n3. 핫 코너 프로필 작성, 내보내기, 적용하기\n4. 프로필 작성을 쉽게 하는 오토메이터 앱\n\n# 1. 터미널을 통한 핫 코너 구성\n\n나는 개발자이며 CLI(명령줄) 도구를 UI를 가진 도구보다 항상 선호합니다. 왜냐하면 CLI를 사용하면 내가 하는 일에 대해 더 많은 제어를 할 수 있고 더 CPU 효율적입니다.\n\n그래서 여기에 제가 터미널 명령어를 사용하여 핫 코너를 구성하는 방법이 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 예를 들어,\n\n아래 명령어는 bottom-left 핫 코너를 수정 없이 Mission Control로 설정합니다.\n\n```js\ndefaults write com.apple.dock wvous-bl-corner -int 2;\ndefaults write com.apple.dock wvous-bl-modifier -int 0;\nkillall Dock\n```\n\n하지만 어떻게 해야 할까요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 명령어의 각 부분을 설명합니다...\n\n`defaults write com.apple.dock`는 지정된 구성을 도크 설정에 쓰는 것입니다 (핫코너는 내부적으로 도크에 연결되어 있습니다).\n\n`wvous`는 macOS에서 핫코너를 설정하고 구성하는 데 사용되는 키입니다. 이 두 가지는 모든 핫코너 명령에 공통적입니다.\n\n- `bl`은 왼쪽 아래를 나타내며, 마찬가지로,\n- `br`은 오른쪽 아래를 나타내며,\n- `tr`은 오른쪽 위를 나타내며,\n- `tl`은 왼쪽 위를 나타냅니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n코너는 작업을 실행하도록 코너를 구성하고 있어요.\n\n모디파이어는 코너에 모디파이어를 설정하도록 합니다 (말했듯이, ⇧, ⌃, ⌥, ⌘를 모디파이어로 사용할 수 있어요). 당연히 작업이 없는 코너에 모디파이어를 설정하는 것은 쓸모가 없죠.\n\n코너 뒤에 -int 2를 넣으면 미션 컨트롤을 실행하도록 코너를 설정하는 거에요.\n\n여기 각 작업에 연관된 정수들이 있어요:\n• 0, 1: 아무 작업 안 함\n• 2: 미션 컨트롤 (이거 사용해봤죠?)\n• 3: 애플리케이션 창\n• 4: 데스크탑\n• 5: 화면 보호기 시작\n• 6: 화면 보호기 비활성화\n• 7: 대시보드 (macOS 카탈리나부터 중단)\n• 10: 디스플레이를 절전 모드로 전환\n• 11: 런치패드\n• 12: 알림 센터\n• 13: 화면 잠금\n• 14: 빠른 노트\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n-int `integer` 명령어를 사용하면 Hot Corner 작업에 수정자를 설정할 수 있어요. 이 경우 0은 수정자가 없음을 의미해요.\n\n```js\n각 수정자와 조합에 대응되는 정수는 다음과 같아요:\n•  131072: Shift (⇧)\n•  262144: Control (⌃)\n•  524288: Option (⌥)\n• 1048576: Command (⌘)\n조합을 사용하려면 각 키에 해당하는 정수를 더해주면 돼요.\n•  393216: Shift+Control (⇧+⌃)\n•  655360: Shift+Option (⇧+⌥)\n• 1179648: Shift+Command (⇧+⌘)\n•  786432: Control+Option (⌃+⌥)\n• 1310720: Control+Command (⌃+⌘)\n• 1572864: Option+Command (⌥+⌘)\n•  917504: Shift+Control+Option (⇧+⌃+⌥)\n• 1441792: Shift+Control+Command (⇧+⌃+⌘)\n• 1703936: Shift+Option+Command (⇧+⌥+⌘)\n• 1835008: Control+Option+Command (⌃+⌥+⌘)\n• 1966080: Shift+Control+Option+Command (⇧+⌃+⌥+⌘)\n```\n\nkillall Dock 명령은 Dock(및 Hot Corner)을 가장 최신 변경 사항을 적용하여 새로고침해요.\n\n## 더 나은 이해를 위한 예제 명령어 (‘killall Dock’를 제외한)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 왼쪽 위 모서리를 미션 컨트롤로 설정하려면:\n\n```js\ndefaults write com.apple.dock wvous-tl-corner -int 2;\ndefaults write com.apple.dock wvous-tl-modifier -int 0\n```\n\n- 오른쪽 위 모서리를 Command(⌘) 키와 함께 데스크톱으로 설정하려면:\n\n```js\ndefaults write com.apple.dock wvous-tr-corner -int 4;\ndefaults write com.apple.dock wvous-tr-modifier -int 1048576\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- Shift+Command (⇧+⌘)를 사용하여 왼쪽 하단 모서리를 시작 화면 보호기로 설정하십시오:\n\n```js\ndefaults write com.apple.dock wvous-bl-corner -int 5;\ndefaults write com.apple.dock wvous-bl-modifier -int 1179648\n```\n\n### #2. Hot Corners 설정을 쉽게 할 수 있는 Automator 앱 훔쳐보기\n\n당신의 고통을 이해합니다 —\n터미널을 통해 Hot Corners를 구성하는 것은 시스템 설정에서 직접 수행하는 것보다 훨씬 어렵고 복잡합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그래서 이 Automator 앱(Hot Corners Configurator)을 만들었습니다. 이 앱을 사용하면 작업이 10배 쉬워집니다. (앱이 작동하지 않는 경우에는 다시 시도하기 전에 Hot Corners에 무작위 조치를 할당하세요.)\n\n한 번 더 James의 Hot Corners 구성을 살펴보겠습니다. (이제는 수식어를 사용합니다):\n\n![James' Hot Corners Configuration](/assets/img/2024-05-17-YoureUnderutilizingHotCornersHacksNobodyToldYouBefore_5.png)\n\n그리고 이것이 Automator 앱을 실행했을 때 나타나는 화면입니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Screenshot](/assets/img/2024-05-17-YoureUnderutilizingHotCornersHacksNobodyToldYouBefore_6.png)\n\nIt displays the names of all the four corners along with their Action and Modifier info.\n\nIt also contains an additional option — ‘CLEAR ALL HOT CORNERS’ — that can clear all corners of their actions and (obviously) modifiers.\n\nJames wants to configure his empty top-left corner to open Launchpad with the modifier as Control (⌃). So he selects TOP-LEFT ↖, and sees this:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-05-17-YoureUnderutilizingHotCornersHacksNobodyToldYouBefore_7.png\" />\n\n이제 '런치패드'를 선택하면 다음과 같은 화면이 표시됩니다:\n\n<img src=\"/assets/img/2024-05-17-YoureUnderutilizingHotCornersHacksNobodyToldYouBefore_8.png\" />\n\n여기서 'Control, ⌃'를 선택하고 OK를 클릭합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 새로운 액션 및 수정자는 macOS 시스템 설정에서 구성됩니다. 확인하려면 핫 코너를 시도해보거나 앱을 다시 시작하여 변경 사항이 반영되는지 확인할 수 있습니다:\n\n![이미지](/assets/img/2024-05-17-YoureUnderutilizingHotCornersHacksNobodyToldYouBefore_9.png)\n\n이게 다에요. 이제 터미널이나 시스템 설정을 통해 핫 코너를 구성하는 게 더 편한 것 같지 않나요?\n\n## 앱의 AppleScript 코드를 보고 싶으세요? 여기를 클릭하시면 별지에서 내려갈 수 있어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# #3. 핫 코너 프로필 만들기, 내보내기 및 적용\n\n만약 생산성에 집착하고 있다면, 이미 다양한 핫 코너 프로필을 만들고 사용하고 있는 꿈을 꾸고 있을지도 모릅니다. 예를 들어\n\n- 프로필 1 (작업용): 화면 왼쪽 하단을 누르면 데스크톱으로 이동,\n- 프로필 2 (가정용): 화면 왼쪽 하단을 누르면 스크린 보호기가 실행됩니다.\n\n일반적으로 말해 - 하루 종일 사용할 핫 코너 구성의 다양한 프로필을 만들 수 있어야 합니다. 한 번 프로필을 적용하면, 기존의 모든 구성이 새로운 구성으로 대체되어야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저는 여러분이 이를 달성하는 데 도움을 드릴게요.\n\n디스크탑을 프로필을 저장할 기본 폴더로 사용해 보세요 (cd desktop을 사용해주세요). 이미 만들고 있는 프로필을 위해 핫 코너를 설정했다고 가정하고...\n\n아래 명령어를 사용해서 myProfile이란 이름의 프로필로 설정을 저장해보세요:\n\n```js\ndefaults read com.apple.dock | grep wvous > myProfile.txt\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n내Profile.txt 파일이 데스크톱에 생성될 것입니다. 제 프로필을 위해 그 안에 있는 내용은 다음과 같습니다(참고용):\n\n```js\n    \"wvous-bl-corner\" = 3;\n    \"wvous-bl-modifier\" = 1048576;\n    \"wvous-br-corner\" = 4;\n    \"wvous-br-modifier\" = 1179648;\n    \"wvous-tl-corner\" = 0;\n    \"wvous-tl-modifier\" = 0;\n    \"wvous-tr-corner\" = 12;\n    \"wvous-tr-modifier\" = 262144;\n```\n\n이 파일에는 네 개의 Hot Corners에 대한 작업 및 수정자가 포함되어 있습니다.\n\n이제 새 프로필(이름을 myNewProfile로 지정합시다)을 위해 이전에 제공한 Automator 앱을 사용하여 서로 다른 Hot Corner 구성을 설정할 수 있을 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n안녕하세요! 모든 프로필을 안전한 장소에 저장하고 원할 때 적용하세요. 그런데 어떻게 적용하죠?\n\n다음 명령어를 사용하세요:\n\n```js\ndefaults write com.apple.dock wvous-<corner_name>-corner -int <integer>;\ndefaults write com.apple.dock wvous-<corner_name>-modifier -int <integer>;\nkillall Dock\n```\n\n그냥 `corner_name`과 `integer`를 해당 값으로 대체하세요. 각 모서리마다 한 번씩 해야 합니다 (총 네 번). 그러면 전체 프로필이 적용됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이해합니다 — 다시 어려워졌네요. 그래서 여기 Automator 앱이 있어요. 프로필 관련 작업이 쉽게 이루어집니다.\n\n이 앱 이름은 Profiles Configurator입니다. 어때요!\n\n토글되면, 새 프로필을 만들 건지 기존 프로필을 적용할 건지 선택하라는 창이 표시됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![image](/assets/img/2024-05-17-YoureUnderutilizingHotCornersHacksNobodyToldYouBefore_10.png)\n\n## '새 프로필 생성'을 선택하면:\n\n새 프로필의 이름을 지정하라는 메시지가 나타납니다.\n\n![image](/assets/img/2024-05-17-YoureUnderutilizingHotCornersHacksNobodyToldYouBefore_11.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n클릭 OK할 때 프로필이 \"Hot Corner Profiles\"라는 데스크톱 폴더에 저장되고 현재 핫 코너 구성이 포함됩니다.\n\n프로필 이름을 비워 놓으면 다시 시도하라는 메시지가 표시됩니다.\n\n❗️안타깝게도 해결하려고 많은 노력을 기울였지만 해내지 못한 버그가 있습니다:\n프로필 이름을 숫자로 끝내면 저장은 성공하지만 적용하는 동안 오류가 발생할 수 있습니다(Profile2, Profile15). 그러나 이름 \"사이\"에 숫자를 넣는 것(Ex: Profile2A)은 가능합니다.\n\n## '기존 프로필 적용'을 선택하는 경우:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n모든 기존 프로필이 표시됩니다\n\n![프로필 이미지](/assets/img/2024-05-17-YoureUnderutilizingHotCornersHacksNobodyToldYouBefore_12.png)\n\n선호하는 프로필을 선택하고 확인을 클릭하세요. 이제 확인할 수 있습니다:\n\n![프로필 이미지](/assets/img/2024-05-17-YoureUnderutilizingHotCornersHacksNobodyToldYouBefore_13.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n한 번 Apply Profile을 클릭하면 선택한 프로필에 따라 Hot Corners가 구성됩니다.\n\n## 주의할 점\n\n- 아직 아이디어를 이해하지 못했다면, 프로필을 친구들에게 내보내거나 가져올 수 있습니다.\n- 기존 프로필이 없는 상황에서 '기존 프로필 적용'을 선택하면 프로필을 만들도록 요구받게 됩니다:\n\n![image](/assets/img/2024-05-17-YoureUnderutilizingHotCornersHacksNobodyToldYouBefore_14.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 어플리케이션의 AppleScript 코드를 보고 싶으세요? 별지의 해당 부분으로 스크롤 다운하는 건 어때요?\n\n자, 그러면 이 Automator 앱을 어떻게 찾아내시나요? 만족스러우세요? 하루에 얼마나 자주 사용하고 싶으신가요?\n\n답변 주시면 알려주세요!\n\n## 터미널 명령어에 열광하시나요? 그렇다면 이 이야기들을 읽는 걸 즐기실 거에요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 마지막으로,\n\n새로운 iOS 및 Mac 앱을 탐험하는 것을 좋아한다면(저와 같이요), Setapp에 가입해 보세요. 월 $9.99에 240개가 넘는 놀라운 앱들을 선별하여 이용할 수 있습니다. 개별 구매 시 수백 달러가 필요한 앱들을 저렴하게 이용할 수 있어요.\n\n- Setapp 여행을 시작하려면 제 제휴 링크를 사용하세요! (30일간 무료로 이용 가능)\n- Setapp에서 제가 선정한 100개가 넘는 Ultimate macOS Apps 목록을 무료로 받아보세요.\n\n새로운 스토리를 게시할 때마다 알림을 받기 위해 460명이 넘는 다른 구독자들과 함께 참여하세요!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 부록\n\n## Hot Corners Configurator를 위한 AppleScript 코드\n\n```js\non extractNumber(inputString)\n    set AppleScript's text item delimiters to \"=\"\n    set stringItems to text items of inputString\n    set numberString to item 2 of stringItems\n    set AppleScript's text item delimiters to \"\"\n    set trimmedNumberString to trimSpaces(numberString)\n    return trimmedNumberString as integer\nend extractNumber\n\non trimSpaces(inputString)\n    return text 2 thru -2 of (inputString as text)\nend trimSpaces\n\non getCorner(cornerString)\n    set text item delimiters to \" [\"\n    set resultString to item 1 of text items of cornerString\n    set text item delimiters to AppleScript's text item delimiters\n    return resultString\nend getCorner\n\non getModifier(modifierString, whichPart)\n    set text item delimiters to \",\"\n    set resultString to modifierString\n    if resultString contains \",\" then\n        set resultString to item whichPart of text items of resultString\n    end if\n    set text item delimiters to AppleScript's text item delimiters\n    return resultString\nend getModifier\n\nset actionMappings to {¬\n    \"No Action\", 1, ¬\n    \"Mission Control\", 2, ¬\n    \"Application Windows\", 3, ¬\n    \"Desktop\", 4, ¬\n    \"Start Screen Saver\", 5, ¬\n    \"Disable Screen Saver\", 6, ¬\n    \"Put Display to Sleep\", 10, ¬\n    \"Launchpad\", 11, ¬\n    \"Notification Centre\", 12, ¬\n    \"Lock Screen\", 13, ¬\n    \"Quick Note\", 14 ¬\n}\n\nset modifierMappings to {¬\n    \"No Modifier\", 0, ¬\n    \"Shift,⇧\", 131072, ¬\n    \"Control,⌃\", 262144, ¬\n    \"Option,⌥\", 524288, ¬\n    \"Command,⌘\", 1048576, ¬\n    \"Shift+Control,⇧+⌃\", 393216, ¬\n    \"Shift+Option,⇧+⌥\", 655360, ¬\n    \"Shift+Command,⇧+⌘\", 1179648, ¬\n    \"Control+Option,⌃+⌥\", 786432, ¬\n    \"Control+Command,⌃+⌘\", 1310720, ¬\n    \"Option+Command,⌥+⌘\", 1572864, ¬\n    \"Shift+Control+Option,⇧+⌃+⌥\", 917504, ¬\n    \"Shift+Control+Command,⇧+⌃+⌘\", 1441792, ¬\n    \"Shift+Option+Command,⇧+⌥+⌘\", 1703936, ¬\n    \"Control+Option+Command,⌃+⌥+⌘\", 1835008, ¬\n    \"Shift+Control+Option+Command,⇧+⌃+⌥+⌘\", 1966080 ¬\n}\n\nset shellCommand to \"defaults read com.apple.dock | grep wvous\"\nset hotCornersInfo to do shell script shellCommand\nset linesList to paragraphs of hotCornersInfo\n\non getActionString(actionValue, actionMappings)\n    repeat with i from 1 to length of actionMappings by 2\n        if item (i + 1) of actionMappings is actionValue then\n            return item i of actionMappings\n        end if\n    end repeat\n    if actionValue is 0 then\n        return \"No Action\"\n    end if\nend getActionString\n\non getModifierString(modifierValue, modifierMappings)\n    repeat with i from 1 to length of modifierMappings by 2\n        if item (i + 1) of modifierMappings is modifierValue then\n            return item i of modifierMappings\n        end if\n    end repeat\n    return \"No Modifier\"\nend getModifierString\n\nrepeat with lineNext in linesList\n    if lineNext contains \"bl-corner\" then\n        set blCorner to getActionString(extractNumber(lineNext), actionMappings)\n    else if lineNext contains \"bl-modifier\" then\n        set blModifier to getModifierString(extractNumber(lineNext), modifierMappings)\n    else if lineNext contains \"br-corner\" then\n        set brCorner to getActionString(extractNumber(lineNext), actionMappings)\n    else if lineNext contains \"br-modifier\" then\n        set brModifier to getModifierString(extractNumber(lineNext), modifierMappings)\n    else if lineNext contains \"tl-corner\" then\n        set tlCorner to getActionString(extractNumber(lineNext), actionMappings)\n    else if lineNext contains \"tl-modifier\" then\n        set tlModifier to getModifierString(extractNumber(lineNext), modifierMappings)\n    else if lineNext contains \"tr-corner\" then\n        set trCorner to getActionString(extractNumber(lineNext), actionMappings)\n    else if lineNext contains \"tr-modifier\" then\n        set trModifier to getModifierString(extractNumber(lineNext), modifierMappings)\n    end if\nend repeat\n\nset cornerOptions to {\"TOP-LEFT ↖            [ACTION: \" & tlCorner & \", MODIFIER: \" & getModifier(tlModifier, 2) & \"]\", ¬\n    \"TOP-RIGHT ↗          [ACTION: \" & trCorner & \", MODIFIER: \" & getModifier(trModifier, 2) & \"]\", ¬\n    \"BOTTOM-LEFT ↙    [ACTION: \" & blCorner & \", MODIFIER: \" & getModifier(blModifier, 2) & \"]\", ¬\n    \"BOTTOM-RIGHT ↘ [ACTION: \" & brCorner & \", MODIFIER: \" & getModifier(brModifier, 2) & \"]\", ¬\n    \"CLEAR ALL HOT CORNERS\"}\n\nset selectedCorner to choose from list cornerOptions with prompt \"코너를 선택하세요:\" without multiple selections allowed and empty selection allowed\n\nif selectedCorner is not false then\n    set selectedCorner to item 1 of selectedCorner as text\n    if selectedCorner is \"CLEAR ALL HOT CORNERS\" then\n        set corners to {\"tl\", \"tr\", \"bl\", \"br\"}\n        repeat with currentCorner in corners\n            do shell script \"defaults write com.apple.dock wvous-\" & currentCorner & \"-corner -int 0\"\n            do shell script \"defaults write com.apple.dock wvous-\" & currentCorner & \"-modifier -int 0\"\n        end repeat\n\n        do shell script \"killall Dock\"\n\n    else\n        set selectedCornerAbbreviation to \"\"\n        if selectedCorner contains \"TOP-LEFT ↖\" then\n            set selectedCornerAbbreviation to \"tl\"\n        else if selectedCorner contains \"TOP-RIGHT ↗\" then\n            set selectedCornerAbbreviation to \"tr\"\n        else if selectedCorner contains \"BOTTOM-LEFT ↙\" then\n            set selectedCornerAbbreviation to \"bl\"\n        else if selectedCorner contains \"BOTTOM-RIGHT ↘\" then\n            set selectedCornerAbbreviation to \"br\"\n        end if\n\n        set cornerActions to {\"No Action\", ¬\n            \"Mission Control\", ¬\n            \"Application Windows\", ¬\n            \"Desktop\", ¬\n            \"Start Screen Saver\", ¬\n            \"Disable Screen Saver\", ¬\n            \"Put Display to Sleep\", ¬\n            \"Launchpad\", ¬\n            \"Notification Centre\", ¬\n            \"Lock Screen\", ¬\n            \"Quick Note\"}\n\n        set chosenAction to choose from list cornerActions with prompt \"선택한 코너의 액션을 선택하세요: \" & getCorner(selectedCorner) default items {\"No Action\"} without multiple selections allowed and empty selection allowed\n\n        if chosenAction is not false then\n            if (count of chosenAction) > 0 then\n                set selectedActionText to item 1 of chosenAction\n                if selectedActionText is not \"No Action\" then\n                    set selectedActionValue to 0\n                    repeat with i from 1 to length of actionMappings by 2\n                        if item i of actionMappings is selectedActionText then\n                            set selectedActionValue to item (i + 1) of actionMappings\n                            exit repeat\n                        end if\n                    end repeat\n\n                    if selectedActionValue is not 0 then\n                        set modifierOptions to {}\n                        repeat with i from 1 to length of modifierMappings by 2\n                            set end of modifierOptions to item i of modifierMappings\n                        end repeat\n\n                        set chosenModifier to choose from list modifierOptions with prompt \"선택한 코너의 모디파이어를 선택하세요: \" & getCorner(selectedCorner) default items {\"No Modifier\"} without multiple selections allowed and empty selection allowed\n\n                        if chosenModifier is not false then\n                            if (count of chosenModifier) > 0 then\n                                set selectedModifierText to item 1 of chosenModifier\n                                set selectedModifierValue to 0\n\n                                repeat with i from 1 to length of modifierMappings by 2\n                                    if item i of modifierMappings is selectedModifierText then\n                                        set selectedModifierValue to item (i + 1) of modifierMappings\n                                        exit repeat\n                                    end if\n                                end repeat\n\n                                set actionCommand to \"defaults write com.apple.dock wvous-\"\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```\n\nJavaScript 코드입니다. 함수와 변수를 정의하고 사용자 선택에 따라 프로필을 생성하거나 적용합니다. 조건문과 반복문을 사용하여 프로필 파일을 읽고 해당하는 설정을 적용합니다.\n","ogImage":{"url":"/assets/img/2024-05-17-YoureUnderutilizingHotCornersHacksNobodyToldYouBefore_0.png"},"coverImage":"/assets/img/2024-05-17-YoureUnderutilizingHotCornersHacksNobodyToldYouBefore_0.png","tag":["Tech"],"readingTime":26},{"title":"제목 v058 몬아크의 심볼 검색 기능으로 글쓰기 역량 향상하기","description":"","date":"2024-05-17 18:53","slug":"2024-05-17-v058EnhanceyourwritingwithSymbolSearchinMonarch","content":"\n<img src=\"/assets/img/2024-05-17-v058EnhanceyourwritingwithSymbolSearchinMonarch_0.png\" />\n\n손으로 쓰는 것과 타자 입력의 주요 차이점 중 하나는 기호를 손으로 훨씬 쉽게 쓸 수 있다는 것입니다. 왜냐하면 키보드에는 이미 훨씬 더 자주 필요한 키들이 가득하기 때문이죠.\n\n실제로 맥에서 특정 키보드 조합을 눌러 기호를 입력할 수 있습니다. 이음대는 ⌥+마이너스이고, 점 목록은 ⌥+8입니다. 문제는 뭐지요? 그게 제가 기억하는 모든 것입니다. 수천 개의 기호가 있고, 그 모든 것이나 아주 몇 가지를 기억하려고 노력하려는 것은 현실적이지 않습니다.\n\n이제 Monarch로 그럴 필요가 없습니다! 앱을 열고 이모지를 찾을 때와 같이 탐색을 시작할 수 있습니다. 가장 좋은 점은 특정 기호를 찾기 어렵거나 그들을 위한 시스템 이름을 기억하는 데 어려움을 겪는다면... 더는 그럴 필요가 없다는 것입니다! 이모지처럼 Monarch는 ⌘+E를 사용하여 기호의 이름을 원하는 대로 바꿀 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다른 메시지에서는 심볼을 사용하지는 않지만, 종종 심볼이 메시지를 더 잘 전달하거나 간결하게 표현할 때, 또는 설명서를 작성할 때 전문적으로 제시해주기도 합니다.\n\nMonarch은 곧 v1.0을 출시할 예정이므로, 평생 라이선스를 획득하려면 빨리 움직여야 합니다! 무료로 30일간 사용해보세요 (신용카드 필요 없음).\n\n# 학생 할인\n\n학생 할인(25% 할인)을 받으려면 학생 이메일(rmdashrfv@hey.com)로 직접 연락해주세요. 뉴욕시 소재 학교에 재학 중인 학생들은 버전 0.x에 40% 할인 혜택을 받을 수 있습니다. 버전 1.0은 우리가 예상하기 전에 여기 있을 것입니다!\n","ogImage":{"url":"/assets/img/2024-05-17-v058EnhanceyourwritingwithSymbolSearchinMonarch_0.png"},"coverImage":"/assets/img/2024-05-17-v058EnhanceyourwritingwithSymbolSearchinMonarch_0.png","tag":["Tech"],"readingTime":2},{"title":"쉘 스크립트를 여전히 작성해야 하는 이유","description":"","date":"2024-05-17 18:51","slug":"2024-05-17-WhyYouShouldStillWriteShellScripts","content":"\n고전적 접근 방식에 대한 현대적인 사례.\n\n![이미지](/assets/img/2024-05-17-WhyYouShouldStillWriteShellScripts_0.png)\n\n솔직히 말해서, grep -o `Response Code:.*` | cut -f 3 -d ` ` | sort | uniq -c | sort -h 3을 지켜보는 것은 고오급한 Kubernetes Operator를 사용하여 일어나는 것만큼 흥미롭지 않습니다. 많은 소프트웨어 전문가들, 시스템 관리자의 건강한 비율을 포함하여 긴 셸 스크립트를 보는 것은 공포와 혼란의 조합으로 인식합니다. 그러나 나는 현대 엔지니어가 갖춰야 할 유용한 기술 중 하나로 셸 스크립트를 편안하게 작성하고 한 줄 기반으로 만드는 능력을 주장합니다.\n\n대학 시절에 스크립팅 수업을 들었습니다. 수업의 처음 몇 주는 Perl로 넘어가기 전에 셸의 기본 사항을 배우는 데 집중했습니다. 우스꽝스럽게도, 지금은 이 매우 같은 강의를 가르치지만 내용은 Perl에서 Python으로 변화했습니다. 불가피하게, 나의 학생들은 저와 같은 어려움을 겪습니다: 셸 구문은 난해하고 혼란스럽고 기억하기 어려운 것들입니다. 그것은 단순히 \"오래된\" 느낌이 들어서, 첫 번째 셸 스크립트를 작성하는 것은 어둠 속에서 헤매고 있는 것과 같은 느낌입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n시간이 흐르면서 저는 쉘을 매우 강력한 기능과 풍부한 역사를 가진 도구로 칭찬하게 되었습니다. 쉘 스크립트를 작성하는 방법을 배우는 것은 아마도 여러분이 익숙한 것과는 다르게 사용자 친화적이지 않을 수도 있습니다. 특히 Python이나 Go와 같은 언어에서 오신 경우에는 더 그렇습니다. 그러나 나는 모두가 쉘 스크립팅 능력을 키우는 데 시간을 쏟는 것이 매우 값진 일이라고 생각합니다.\n\n아래에는 파일을 열 때 #!/bin/bash라는 구문을 보고 신경 쓰이는 경우 고려해 볼 다섯 가지 이유가 있습니다:\n\n## Reason 1: Containers Demand It\n\n컨테이너는 현재 워크로드를 배포하는 표준 방식입니다. 동의하든 그렇지 않든, 쿠버네티스 열풍에 흔들리지 않았더라도 환경에서 컨테이너화된 워크로드를 배포 중인 가능성은 높습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n바이너리 엔트리포인트에 의존하는 컨테이너를 빌드할 수 있지만, 보통 컨테이너는 시작 스크립트를 실행합니다. 이는 실행 시간 구성을 제한하는 기회를 제공합니다. 고품질 쉘 스크립트를 작성하면 컨테이너 엔트리포인트의 품질을 향상시켜 컨테이너 이미지 사용자에게 강력한 실행 시간 구성을 제공할 수 있습니다. 이는 오류 확인부터 자격 증명 또는 구성 매개변수를 자동으로 생성하는 것과 같은 더 복잡한 구성까지 모두 포함됩니다.\n\n게다가: 엔트리포인트 스크립트를 POSIX 쉘(#!/bin/sh)로만 제한하는 방법을 배우면 컨테이너 이미지에서 Bash를 제거하고 그 크기와 공격 표면을 줄일 수 있습니다.\n\n# 공식 MariaDB 컨테이너는 623줄의 도커 엔트리포인트 쉘 스크립트를 사용합니다.\n\n$ podman exec -it mariadb wc -l /usr/local/bin/docker-entrypoint.sh\n623 /usr/local/bin/docker-entrypoint.sh\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n로그 및 추적 프로젝트는 대략 백만 개 정도가 있어요. 왜 그럴까요? 로깅은 도전적입니다, 특히 분산 마이크로서비스 세계에서요. 멋진 추적 도구와 로그 집계 서비스는 훌륭하지만 종종 명령줄에서 찾을 수 있는 그 유연성을 제공하지 못할 때가 많아요. 저는 파이프된 명령어 한 줄을 작성하는 것이 대부분의 로깅 시스템 UI를 헤매는 것보다 빠르다고 생각해요.\n\nGUI를 버리지 않는 것을 추천하지 않아요. 오히려 그게 유용해요. 텍스트 데이터를 그래픽 인터페이스와 명령줄 모두에서 탐색하는 것이 유용하기 때문이죠. 내 전형적인 워크플로우는 로깅 UI(예: 키바나)를 사용하여 관심 있는 로그로 대략적으로 필터링한 다음 로그 메시지를 다운로드하여 쉽게 구문 분석하기 위해 셸 유틸리티를 사용하는 것입니다. 원하는 것을 더 잘 알게 되면 실제 쿼리가 있는 대시보드를 작성하게 될 거예요.\n\n생산 문제를 디버깅할 때도 아마 당신은 당신의 서버나 쿠버네티스 클러스터에 앉아 있을 거예요. 장애 발생 시 분 단위가 중요할 때 몇 번의 키 입력으로 바로 이론을 테스트하는 것이 절대적으로 중요합니다. 문제가 심각해서 로그 수집 자체가 고장났을 수도 있고, 아니면 터미널과 로깅 도구 간의 컨텍스트 전환을 계속할 여유가 없을 수도 있어요. 그 어떤 경우에도, 단순한 한 줄짜리 명령어를 만들어 내는 데 익숙해서 다행할 것입니다.\n\n배우는 곡선은 있지만, 쉘에서 사용 가능한 많은 유틸리티로 편안해지면 쉘 명령어를 사용하여 데이터를 \"탐색\"하는 것이 훨씬 쉽다는 것을 알게 되실 거예요. 필요한 데이터를 빠르게 반환하는 작은 스크립트 라이브러리를 점차적으로 구축할 수 있을 거예요. 제가 가장 좋아하는 것 중 하나는 제 Nginx 로그를 구문 분석하고 서버를 공격하는 상위 10개 IP 주소를 알려주는 간단한 Bash 한 줄짜리입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n$ cut -f 1 -d ' ' /var/log/nginx/access.log | sort | uniq -c | sort -hr | head -n 10\n     38 65.108.66.11\n     20 91.240.118.252\n     18 194.110.115.68\n     17 3.234.236.64\n     11 190.117.58.32\n     11 172.56.209.241\n     11 165.225.233.21\n     10 95.161.221.0\n     10 85.173.195.175\n     10 37.79.10.45\n```\n\n# Reason 3: 어떤 (텍스트) 데이터 형식이든\n\n우리가 일상적으로 다루는 대부분의 데이터는 텍스트 형식입니다: 애플리케이션 데이터, 설정 파일, 로그 메시지 등등. 이러한 데이터나 로그 집계 플랫폼에서 이 데이터를 다루는 것은 데이터의 형식(또는 스키마)에 대해 신중한 고려를 요구합니다. 이는 장기적인 저장 및 검색을 위해 이상적인 선택입니다: 데이터 형식을 이해하는 것은 복잡한 데이터를 효율적으로 저장하고 쿼리하는 데 중요합니다.\n\n하지만 당신은 아마도 데이터를 탐색하는 데 편의를 제공하는 방식으로 빠르고 쉽게 데이터를 다루고 싶어하는 상황에 직면해 본 적이 있을 것입니다. 아직 다루고 있는 데이터의 구조나 형식에 대해 이해하고 있지 않을 수도 있습니다. 이를 이해하려는 과정에 있을 수도 있고, 특정 데이터의 일부를 빠르게 쿼리하거나 변환하고 싶을 수도 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n쉘(shell)이 빛을 발하는 작업들이에요! 대부분의 쉘 도구들은 텍스트의 구조에 대해 크게 신경 쓰지 않고 원시 텍스트와 직접 작동합니다. 임의로 형식이 지정되지 않은 텍스트 파일에서 모두 dev를 prod로 변경하고 싶다면, 쉘이 도움이 될 거예요. JSON이나 YAML과 같은 구조화된 데이터 형식을 이미 사용하고 있다면, jq나 yq와 같은 도구를 사용해서 이러한 형식과 함께 작업할 수 있어요.\n\n```js\n# 개발용 구성 파일\n$ cat /tmp/sample.json\n{\n    \"Environment\": \"dev\",\n    \"Database\": {\n        \"Host\": \"dev.example.com\"\n    },\n    \"AppName\": \"iot-dev\",\n    \"CacheShards\": [\n        \"east1-cache-dev-1\",\n        \"east1-cache-dev-2\",\n        \"east1-cache-dev-3\"\n    ]\n}\n\n# Sed는 JSON, YAML, XML 또는 다른 형식이든 상관하지 않아요.\n# 텍스트이면 됩니다!\n$ sed -s 's/dev/prod/g' /tmp/sample.json\n{\n    \"Environment\": \"prod\",\n    \"Database\": {\n        \"Host\": \"prod.example.com\"\n    },\n    \"AppName\": \"iot-prod\",\n    \"CacheShards\": [\n        \"east1-cache-prod-1\",\n        \"east1-cache-prod-2\",\n        \"east1-cache-prod-3\"\n    ]\n}\n```\n\n# 이유 4: 자동화를 지지합니다\n\n자동화는 소프트웨어 엔지니어부터 운영 전문가에 이르기까지 모두의 책임이에요. 소프트웨어 분야에서 일하고 있다면 이미 자동화의 이점을 잘 알고 있고, 아마도 자동화된 몇 가지 프로세스를 진정으로 자랑스럽게 자동화했을 거예요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n셸 스크립트는 존재하는 자동화 방식 중 가장 일반적이고 간단하며 기본적인 유형 중 하나입니다. Ansible, Puppet, Chef, Kubernetes 및 기타 도구들이 나오기 전에는 셸만 있었습니다. 옛날의 시스템 관리자들은 사용자 관리부터 보안 감사까지 모든 것을 다루기 위해 스크립트를 작성했습니다. 이러한 프로세스를 자동화하기 위해 다른 도구를 배울 필요가 없었기 때문에 셸은 시스템과 상호 작용하는 유일한 방법이었죠.\n\n이러한 형태의 자동화를 이해하는 것은 그저 향수에 젖은 연습을 하는 것 이상입니다. 종종 복잡한 프로세스를 자동화하기 위해서는 간단한 셸 스크립트만으로 충분할 수 있습니다. 게다가 많은 자동화 플랫폼들은 이미 강력한 셸 스크립트의 래퍼일 뿐입니다. 셸 스크립트를 작성하고 읽는 방법을 이해하는 것은 자동화 기초에 대한 더 나은 이해를 제공받게 되며, 복잡한 문제를 간단한 방식으로 해결하는 데 도움이 될 것입니다.\n\n# 이유 5: 모든 곳에서 존재하는 기술\n\n현대 컴퓨팅 세계의 현실은 대부분의 기업이 이종 컴퓨팅 워크로드를 실행한다는 것입니다: 가상 머신, 컨테이너, 물리적 호스트 등이 있습니다. 워크로드는 클라우드, 온프레미스 및 엣지에서 실행됩니다. 우수한 엔지니어들은 이러한 환경을 횡단하여 편안하게 작업할 수 있어서 자신을 다른 사람들과 구분지을 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n하지만 최신 데이터 처리 또는 로그 분석 도구가 없어서 간소화된 컨테이너 애플리케이션 문제 해결에 어려움이 있을 때는 어떻게 해야 할까요? 새로운 팀(또는 직장)으로 옮겨갔을 때 새 역할에서 사용하는 도구체인이 완전히 다를 경우에는 어떻게 해야 할까요?\n\n기본적인 셸 스크립트 작성에 능숙하다면 걱정할 필요가 없습니다. 완전히 다른 환경의 원격 시스템에 로그인하여 로그 데이터를 캡처하거나 자동화된 결함 해결 기능을 동일하게 수행할 수 있습니다. 이런 셸 스크립트를 작성하여 산업 분야에서 계속 발전시키는 경력을 쌓을 수 있습니다. 셸은 시간에 걸쳐 검증되어왔으며, 업계에서의 시간 동안 그것이 성과를 거두는 것을 발견하게 될 것입니다.\n\n# 결론\n\n작은 셸 스크립트도구 상자를 구축하세요. 퇴사할 때 멋진 Kubernetes 오퍼레이터, 놀라운 Kibana 대시보드 또는 멋진 커맨드 라인 도구를 가져갈 수 없을 수도 있습니다. 또한 그것은 간단히 기억에서 재구성하기에 너무 복잡할 수도 있습니다. 그러나 다음 회사에서는 셸이 포함된 시스템이 있을 것이며, 그럼에도 불구하고 당신이 익숙하고 쉽게 어떤 작업이든 수행할 수 있다는 것을 확신할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n확실하게 말씀드리자면: 쉘 스크립트 작성에는 제약과 도전이 있습니다. 하지만 그에 대한 논의는 다음에 하도록 하죠. 그래도 컨테이너 엔트리포인트를 파헤치는 과정에서 #!/bin/sh를 보게 된다고 두려워하지 마세요. 구문과 스타일에 익숙해지면, 강력한 쉘 스크립트가 소프트웨어 전문가로써 우리의 삶을 더 쉽게 만든다는 점을 감사히 여기게 될 거에요.\n","ogImage":{"url":"/assets/img/2024-05-17-WhyYouShouldStillWriteShellScripts_0.png"},"coverImage":"/assets/img/2024-05-17-WhyYouShouldStillWriteShellScripts_0.png","tag":["Tech"],"readingTime":8},{"title":"리눅스 68에서 사용자 정의 시스템 호출 만들기","description":"","date":"2024-05-17 18:49","slug":"2024-05-17-CreateCustomSystemCallonLinux68","content":"\n여태껏 사용자 정의 시스템 호출을 만들어보고 싶으셨나요? 과제를 위해서든, 즐거움을 위해서든, 또는 커널에 대해 더 많이 배우기 위해서든, 시스템 호출은 우리 시스템에 대해 더 많이 알아갈 수 있는 멋진 방법입니다.\n\n# 이 안내에 따를 이유는?\n\n이 주제에 대한 다양한 안내서가 있지만, 커널 개발 속도의 문제 때문에 문제가 발생합니다. 대부분의 안내서들은 오래되었고 다양한 오류를 발생시키기 때문에, 저는 이 포스트를 오류를 경험하고 그것들을 해결한 후에 작성하게 되었습니다 :)\n\n## 커널 컴파일을 위한 시스템 설정\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nRed Hat / Fedora / Open Suse 기반 시스템에서는 아래와 같이 간편하게 실행할 수 있어요.\n\n```bash\nsudo dnf builddep kernel\nsudo dnf install kernel-devel\n```\n\nDebian / Ubuntu 기반 시스템에서는\n\n```bash\nsudo apt-get install build-essential vim git cscope libncurses-dev libssl-dev bison flex\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 커널 가져오기\n\n커널 소스 트리를 복제하세요. 특히 6.8 브랜치를 복제할 것이지만, 지침은 커널 개발자가 프로세스를 변경할 때까지 최신 브랜치에서도 작동해야 합니다.\n\n```js\ngit clone --depth=1 --branch v6.8 https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git\n```\n\n이상적으로, 복제된 버전은 현재 사용 중인 커널 버전과 같거나 더 높아야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n현재 커널 버전은 다음 명령어를 통해 확인할 수 있어요\n\n```bash\nuname -r\n```\n\n## 새로운 시스템 호출 생성\n\n다음을 수행해주세요\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\ncd linux\nmake mrproper\nmkdir hello\ncd hello\ntouch hello.c\ntouch Makefile\n```\n\n이 명령은 다운로드한 커널 소스 코드 내에 \"hello\"라는 폴더를 만들고, 그 안에 hello.c(시스템 호출 코드)와 Makefile(컴파일 규칙) 두 개의 파일을 생성합니다.\n\n좋아하는 텍스트 편집기에서 hello.c를 열고 다음 코드를 넣어주세요.\n\n```js\n#include <linux/kernel.h>\n#include <linux/syscalls.h>\n\nSYSCALL_DEFINE0(hello) {\n    pr_info(\"Hello World\\n\");\n    return 0;\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n커널 로그에 \"Hello World\"가 출력됩니다.\n\n우리는 단순히 프린트만 할 것이기 때문에 n=0을 사용합니다.\n\n이제 다음을 Makefile에 추가해주세요\n\nobj-y := hello.o\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제\n\n```js\ncd ..\ncd include/linux/\n```\n\n이 디렉토리 안에서 \"syscalls.h\" 파일을 열고 다음을 추가하세요.\n\n```js\nasmlinkage long sys_hello(void)\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-05-17-CreateCustomSystemCallonLinux68_0.png\" />\n\n이것은 이전에 만든 syscall 함수에 대한 프로토타입입니다.\n\n커널 루트 내의 \"Kbuild\" 파일을 열고 (cd ../..) 맨 아래에 다음을 추가하십시오.\n\n```js\nobj-y += hello/\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 우리가 포함한 새 폴더도 컴파일하도록 커널 빌드 시스템에 지시합니다.\n\n이 작업이 완료되면, 아키텍처별 테이블에 시스콜 항목도 추가해 주어야 합니다.\n\n각 CPU 아키텍처는 특정 시스콜을 가질 수 있으며, 우리의 시스콜이 어떤 아키텍처를 위해 만들어졌는지 알려주어야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nx86_64 아키텍처에서 파일은\n\n```js\narch / x86 / entry / syscalls / syscall_64.tbl;\n```\n\n빈번호를 사용하고 테이블 주석에서 금지된 번호를 사용하지 않도록 유의하여 시스콜 항목을 추가하세요.\n\n제가 사용 가능한 번호 중 462번이 비어 있어서 새 항목을 다음과 같이 추가했습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n462 공통 안녕 sys_hello\n```\n\n<img src=\"/assets/img/2024-05-17-CreateCustomSystemCallonLinux68_2.png\" />\n\n여기서 462은 우리의 시스템 호출에 매핑되며 두 아키텍처에 대해 공통인 sys_hello로 명명된 hello 시스템 호출의 진입 함수(entry function)입니다.\n\n## 새 커널을 컴파일하고 설치하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음 명령을 실행하십시오.\n\n주의: 이 안내를 따르더라도 시스템의 안전, 보안, 무결성과 안정성을 보장하지 않습니다. 여기 나열된 모든 지침은 제 경험이며 귀하의 시스템에서의 결과를 대표하지 않습니다. 조심히 주의하여 진행하십시오.\n\n이제 법적인 부분은 끝냈으니, 계속해봅시다 ;)\n\n```js\ncp /boot/config-$(uname -r) .config\nmake olddefconfig\nmake -j $(nproc)\nsudo make -j $(nproc) modules_install\nsudo make install\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n현재 부팅된 커널의 구성 파일을 복사하고, 빌드 시스템에 동일한 값을 사용하도록 요청하여 기본값을 설정합니다. 그런 다음 nproc에 의해 주어진 코어 수에 따라 병렬 처리를 사용하여 커널을 빌드합니다. 이후 사용자 정의 커널을 설치합니다 (자체 책임으로).\n\n커널 컴파일에는 많은 시간이 소요되므로 커피 한 잔 또는 10잔을 마시며 터미널에서 스크롤되는 텍스트 줄을 즐기세요.\n\n시스템 속도에 따라 몇 시간이 걸릴 수 있으므로 실제 소요 시간이 다를 수 있습니다. 이 단계에서 열이 치기도 할 수 있으니 온도를 확인하려면 팬이 소리를 지를 수도 있습니다 (내 경우에도 그렇었어요).\n\n## 재미있는 부분, 새로운 시스템 호출 사용\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 시스템 호출이 우리의 커널에 통합되었으니 시스템을 재부팅하고 부팅 중에 grub에서 새로운 커스텀 커널을 선택해주세요\n\n![image](/assets/img/2024-05-17-CreateCustomSystemCallonLinux68_3.png)\n\n부팅 후 시스템 호출을 사용하는 C 프로그램을 작성해봅시다.\n\n다음 내용을 가진 파일 \"test.c\"를 생성하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n#include <stdio.h>\n#include <sys/syscall.h>\n#include <unistd.h>\nint main(void) {\n  printf(\"%ld\\n\", syscall(462));\n  return 0;\n}\n```\n\n당신이 테이블에서 시스템 콜에 대해 선택한 번호로 462을 대체하세요.\n\n프로그램을 컴파일하고 실행하세요.\n\n```js\nmake test\nchmod +x test\n./test\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n모두 정상적으로 진행되면, 터미널에서 \"0\"을 출력하고 시스콜 출력이 커널 로그에 표시됩니다.\n\n다음 명령어를 사용하여 로그에 액세스하세요.\n\n```bash\nsudo dmesg | tail\n```\n\n그러면 원하는 시스템 콜 메시지가 출력된 것을 확인할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만약 성공적으로 수행했다면 축하드려요 🎉 좋아요와 댓글이 있다면 감사하겠습니다 :) 꼭 여러분의 이야기를 공유해 주세요 :D\n\n다시 한 번 아래 사항을 기억해 주세요:\n\n- 커널을 컴파일하는 데 많은 시간이 걸립니다.\n- 새로 컴파일한 커널은 상당한 용량을 차지하므로 저장 공간 확인이 필요합니다.\n- 리눅스 커널은 코드 변경이 빠르게 이뤄집니다.\n","ogImage":{"url":"/assets/img/2024-05-17-CreateCustomSystemCallonLinux68_0.png"},"coverImage":"/assets/img/2024-05-17-CreateCustomSystemCallonLinux68_0.png","tag":["Tech"],"readingTime":9},{"title":"악용하지 말아야 할 멋진 Swift 기능들","description":"","date":"2024-05-17 18:48","slug":"2024-05-17-ThecoolSwiftfeaturesthatyoushouldnotabuse","content":"\n![ThecoolSwiftfeaturesthatyoushouldnotabuse](/assets/img/2024-05-17-ThecoolSwiftfeaturesthatyoushouldnotabuse_0.png)\n\niOS 개발자로서, 나는 많은 기존 코드에서 작업하거나 몇 가지 Swift 기능을 시도해 본 적이 있습니다. 그들을 사용하거나 악용 당하는 것을 보면서, 적어도 조심스럽게 사용해야 할 상위 6개의 Swift 언어 기능을 공유하고, 왜 그것들을 팀에서 금지해야 할지 생각했습니다. 간단히 살펴보겠습니다. 동의하지 않거나 다른 예제가 있는 경우 댓글에서 공유해주세요 💬.\n\n# .init() 인스턴스화\n\n.init()을 사용하는 것은 처음 봤을 때 몇 가지 경우에 편리할 수 있지만 (클래스/구조체 이름 바꿀 때 노이즈가 적음), 코드 검토 및 유지보수 시 가독성이 저하됩니다. 코드 검토에서는 호출자로 이동하여 객체의 유형을 확인해야 하며, 유지보수 중에는 객체를 확인하려면 이동해야 합니다. 팀의 생산성을 높이기 위해 사용하지 않아야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n//To avoid ❌\nlet example = .init(title: \"title\")\n//To prefer ✅\nlet example = Example(title: \"title\")\n```\n\nSwiftlint을 사용하면 이 좋은 규칙을 강제로 적용할 수 있어요.\nSwiftlint를 사용하신다면, 프로젝트에서 사용해야 하는 최상의 Swiftlint 설정에 관한 기술적인 문서를 작성했어요 ⬇️\n\n# $0, $1, 등...\n\n$0는 매우 편리하지만 코드 리뷰에서는 코드를 덜 가독성 있게 만들 수 있어요(이 게시물이 말합니다).\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n// ❌를 피하기 위해\nnumbers.sort { $0 > $1 }\n// ✅를 선호하기 위해\nnumbers.sort { leftNumber, rightNumber in leftNumber > rightNumber }\n\n# 서브스크립트\n\n서브스크립트 기능은 처음 봤을 때 매우 매력적으로 보입니다:\n\n```js\nstruct TimesTable {\n    let multiplier: Int\n\n    subscript(index: Int) -> Int {\n        return multiplier * index\n    }\n}\n\nlet table = TimesTable(multiplier: 3)\nlet result = table[5]  // 결과 = 15\nprint(result)\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n서브스크립트가 그렇게 나쁘지는 않지만 테이블[5]을 읽는 일반적인 개발자들은 테이블이 배열이라고 생각하고 다섯 번째 항목에 접근하려는 것으로 생각할 것입니다. 이는 바로 그게 아니기 때문에 코드 리뷰나 파일 간, 모듈 간 사용 시 가독성이 떨어집니다. 논리적인 코드 난독화는 피해야 합니다. 이겪하고자 하는 점이 명확하지 않아서 널리 사용되지 않는 것 때문에 이것을 추천하지는 않습니다.\n\n# 확장(Extensions) 남용\n\n확장은 가독성과 모듈화를 높입니다. 디자인 상, 보호기능이 없는 특성이며 난잡한 코드나 불필요한 사용 또는 안티패턴으로 이어질 수 있습니다.\n\n먼저, 이 규칙을 활성화하지 않았다면, 활성화해야 합니다. 이 규칙은 확장의 일부 불필요한 사용을 감지합니다. 예를 들어, ViewController의 델리게이트를 같은 파일에서 확장을 사용해 구현하지만 어떤 프로토콜 준수 제한도 없거나 그러한 것을 분할하는 경우 등을 감지합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nclass MyViewController: UIViewController{\n  private var IBOutlet textfield: UITextField\n\n  textfield.delegate = self\n...\n}\n\n// To Avoid❌\nextension UIViewController: UITextViewDelegate {\n\n}\n```\n\n올바르지 않은 SOLID 확장 사용 예시:\n\n```js\ncontainer.register(Buyable.self, NetworkManager())\n\nclass NetworkManager {\n  var user: User\n}\n\nprotocol Buyable {\n  func canBuy() -> Bool\n}\n\nIn Buy.swift\nextension NetworkManager: Buyable {\n  @Inject var cart: CartStore\n\n  func canBuy() -> Bool {\n    if cart.hasEnough { return true} else { return false }\n    //we can still access to user here...\n  }\n\n}\n\nclass CartViewModel {\n  @Inject var buy: Buyable // Illusion to have a Buyable\n\n  func addItem() {\n    if buy.canBuy() { /* */ }\n\n  }\n\n}\n```\n\n우리는 Buyable이 Buy 객체의 프로토콜일 수 있다는 환상을 갖고 있지만, 전혀 그렇지 않습니다. 이를 서로 다른 파일에 걸쳐 사용하면서 매우 지저분한데다가 혼란스럽습니다. 하지만... 작동합니다. (코틀린에서는 이렇게 하는 것이 불가능합니다).\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# Property wrappers\n\n테이블 태그를 Markdown 형식으로 변경하면 다음과 같습니다.\n\nI love them, for writing cross native code, property wrappers is an awesome feature. First usecase from the swift community was to use them for improving the usage of Injection (like Swinject), can lead to read source code like a dagger-hilt style and it’s the equivalent of the delegated properties in Kotlin. But like Kotlin, it has the same drawbacks: readability / logic obfuscation / spagetthi architecture.\n\n```js\n@propertyWrapper\nstruct Sanitized {\n    private(set) var value: String = \"\"\n\n    var wrappedValue: String {\n        get { value }\n        set { value = newValue.trimmingCharacters(in: .whitespacesAndNewlines) }\n    }\n\n    init(wrappedValue initialValue: String) {\n        self.wrappedValue = initialValue\n    }\n}\n\nstruct User {\n    @Sanitized var username: String\n}\n\n// Exemple d'utilisation\nvar user = User(username: \"   Chris   \")\nuser.\nprint(user.username) // Output: \"Chris\"\n```\n\nHow can we really use this as a business rule implementation? If we want to add additional features to our string, we will have to add them inside our Sanitized property wrapper or write them outside to maintain a single responsibility principle. Why isn`t Sanitized a function of your User? It may create inconsistency. Property wrappers should be used wisely and could be replaced by small extensions 💡.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 게터/세터 재정의\n\n이것은 정사각형/속성 감싸기와 거의 비슷합니다. didSet의 사용은 로직을 혼란스럽게 만들 수 있으며 이해하기 어렵게 만들 수 있습니다:\n\n```js\nstruct Temperature {\n    var celsiusValue: Double {\n        didSet {\n            print(\"무슨 일이 일어났어요\")\n        }\n    }\n\n    init(celsiusValue: Double) {\n        self.celsiusValue = celsiusValue\n    }\n}\n\nvar temp = Temperature(celsiusValue: 20)\ntemp.celsiusValue = 25\n//무슨 일이 일어났어요\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이건 명백해 보일지 모르지만 때로는 강제 언래핑 할 때 어떻게 해야할지 모르겠어요 (그리고 이것이 꼭 멋진 기능은 아닐 수 있어요) - 함수 호출이 확실히 동작할 것이라고 가정하는 것이 유혹스러울 수 있습니다 (하지만 옵셔널 값을 반환할 수도 있어요). 그렇다면, 만약 여러분의 코드가 아니라면 결국 실패할 수 있는 가능성을 가정해야 해요. 예를 들면:\n\n```js\n// SPM에서 UIFont를 로드하려고 하는 경우\nregisterFont(\"font.ttf\") // font가 로드된 것으로 가정합니다\n\n// ❌ 하지마세요\nlet font = UIFont(name: \"font.ttf\")!\n\n// 하세요\nguard let font = UIFont(name: \"font.ttf\") else {\n    Crashlytics.record(\"font.ttf failed to be registered\") // 충돌을 모니터링합니다\n    return // 또는 fatalError() 또는 기본 폰트를 인스턴스화하세요\n}\n```\n\n# 결론\n\n고급 언어 기능 사용은 라이브러리나 구조적인 프레임워크/사용자 정의 아키텍처를 사용하는 것과 유사합니다: 현명하게 사용되어야 하며, 팀으로 수용되어야 합니다. 새로운 프로젝트에 참여하는 새로운 사람이 이 코드 라인을 읽었을 때, 쉽게 이해할 수 있는지 아닌지 고려해야 합니다. 학습은 함의하거나 빛나는 새로운 기능을 남용하지 않는 시점을 인식하거나 더 전통적인 방식으로 돌아가야 하는 시점을 받아들이는 것 또한 포함됩니다 😀.\n","ogImage":{"url":"/assets/img/2024-05-17-ThecoolSwiftfeaturesthatyoushouldnotabuse_0.png"},"coverImage":"/assets/img/2024-05-17-ThecoolSwiftfeaturesthatyoushouldnotabuse_0.png","tag":["Tech"],"readingTime":8}],"page":"107","totalPageCount":110,"totalPageGroupCount":6,"lastPageGroup":10,"currentPageGroup":5},"__N_SSG":true}