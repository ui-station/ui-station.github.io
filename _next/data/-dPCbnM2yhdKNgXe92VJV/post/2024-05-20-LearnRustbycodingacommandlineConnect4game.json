{"pageProps":{"post":{"title":"Rust로 코딩하는 커맨드 라인 Connect 4 게임 배우기","description":"","date":"2024-05-20 16:00","slug":"2024-05-20-LearnRustbycodingacommandlineConnect4game","content":"\n![Rust Connect 4](/assets/img/2024-05-20-LearnRustbycodingacommandlineConnect4game_0.png)\n\n안녕하세요! 이번 글에서는 Rust가 어떻게 우리가 Connect 4의 간단한 버전을 만들며 명령줄 응용 프로그램을 작성하는 데 도움이 되는지 살펴볼 거에요.\n\n최근 Rust를 배우는 도전에 도전했고, 제 자신의 조언을 따르기 위해 개인 프로젝트에서 Rust를 사용해 손을 더럽히며 배운 것을 정리하려고 노력하고 있어요. Connect 4는 아주 좋은 도전 과제에요. 오후 하루 동안 코딩할 수 있는 것은 간단하지만 잘 하려면 약간의 생각이 필요한 복잡한 문제이죠.\n\n여기 제 마지막 결과물이 포함된 Rust 플레이그라운드가 있어요. 아래에서는 거기에 이르기까지 취한 정확한 단계를 살펴볼 거에요. 따라오고 싶으시면 Rust가 설치되어 있는지 확인한 후 터미널에서 `cargo new rust_connect_4_tutorial`을 실행해서 프로젝트를 열고 좋아하는 편집기에서 src/main.rs로 이동해서 시작해봐요!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n혹은 비디오를 통해 학습하는 것을 선호한다면, 해당 튜토리얼의 비디오 버전을 확인해보세요:\n\n# 우리의 타입 정의하기\n\nRust에서 시작하는 가장 좋은 방법 중 하나는 종종 우리의 타입을 정의하는 것이므로, 우리는 정확히 그것을 할 것입니다!\n\n먼저, 게임에 사용할 보드를 정의해 보겠습니다. Connect 4의 클래식 버전은 7개의 슬롯이 가로로 있고 6개의 슬롯이 세로로 있기 때문에, 이들 정수를 상수로 저장하고, 그 상수를 사용하여 두 차원 배열의 길이를 정의하는 데 사용할 수 있습니다. Board 타입으로 정의합니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```rust\nconst BOARD_WIDTH: usize = 7;\nconst BOARD_HEIGHT: usize = 6;\n\ntype Board = [[u8; BOARD_WIDTH]; BOARD_HEIGHT];\n```\n\n플레이어를 추적할 방법이 필요할 것입니다. 이를 enum으로 구현할 수 있습니다. 우리는 두 명의 플레이어만 지원하지만, 한 명의 피스가 없는 슬롯을 나타내는 None 변형과 게임이 무승부로 끝날 때 처리하는 데 유용할 것입니다.\n\n```rust\n#[derive(Clone, Copy, Debug, PartialEq)]\n#[repr(u8)]\nenum Player {\n    One = 1,\n    Two = 2,\n    None = 0,\n}\n```\n\n위에서는 나중에 유용할 몇 가지 트레잇을 구현하기 위해 derive를 사용하고, enum의 메모리 레이아웃을 제어하기 위해 repr을 사용했습니다. 가능한 모든 값을 알기 때문에 u8로 제한할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음으로, 우리는 게임을 나타내는 struct를 만들 것입니다. 여기에는 추적해야 할 모든 상태가 포함될 것입니다.\n\n```javascript\nstruct Game {\n    current_move: u8,\n    current_player: Player,\n    board: Board,\n    is_finished: bool,\n    winner: Player,\n}\n```\n\ncurrent_move는 플레이어가 선택한 열을 나타내는 정수입니다. 우리에게는 승자 필드가 있지만, 게임이 비김으로 끝날 때 별도로 is_finished 부울도 유용할 것입니다!\n\n마지막으로, Game에 대한 기본 함수를 구현할 것입니다. 이 함수에는 초기 상태가 포함될 것입니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```rust\nimpl Game {\n    fn default() -> Game {\n        Game {\n            current_move: 0,\n            current_player: Player::One,\n            board: [\n                [0, 0, 0, 0, 0, 0, 0],\n                [0, 0, 0, 0, 0, 0, 0],\n                [0, 0, 0, 0, 0, 0, 0],\n                [0, 0, 0, 0, 0, 0, 0],\n                [0, 0, 0, 0, 0, 0, 0],\n                [0, 0, 0, 0, 0, 0, 0],\n            ],\n            is_finished: false,\n            winner: Player::None,\n        }\n    }\n}\n```\n\n보드에 대해 조금 이야기해 봅시다. 여기서 0은 빈 칸을 나타내며, 1은 Player One이 차지한 칸을 나타내고, 2는 Player Two가 차지한 칸을 나타냅니다.\n\nBOARD_WIDTH와 BOARD_HEIGHT를 사용하여 동적으로 생성할 수도 있었지만, 코드를 작성하는 동안 전체 배열을 보는 것이 도움이 되는 시각적 도구라는 것을 발견했습니다. 같은 이유로, 정수가 아닌 Player 열거형을 사용하지 않았습니다. 텍스트가 더 많아지면 코드를 한눈에 이해하기 어려워지기 때문입니다.\n\n이 방법의 (약간의) 단점은 나중에 정수를 Player로 변환해야 한다는 것입니다. 하지만 Player에 from_int 함수를 구현함으로써 쉽게 해결할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n구현 Player {\n    fn from_int(int: u8) -> Player {\n        match int {\n            1 => Player::One,\n            2 => Player::Two,\n            _ => Player::None,\n        }\n    }\n}\n```\n\n# 보드 표시\n\n디버깅을 위해, 보드를 시각화하는 좋은 방법을 빠르게 코드화하는 것이 도움이 될 것입니다. 명령줄에 출력하기 위해 크레이트를 사용하는 대신에 간단한 색을 나타내기 위해 16진수 이스케이프 문자열을 사용할 것입니다.\n\n```js\nconst RESET: str = \"\\x1b[0m\";\nconst ORANGE: str = \"\\x1b[93m\";\nconst RED: str = \"\\x1b[0;31m\";\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래의 코드에서는 맵을 사용하여 Connect 4 토큰과 유사한 이모지로 슬롯을 변환할 것입니다. 게임이 종료되면 우승자를 발표하는 좋은 장소로 보입니다.\n\n```js\nimpl Game {\n    // 다른 함수들\n\n    fn display_board(&self) {\n        println!(\"{}--------------------{}\", ORANGE, RESET);\n        println!(\"{}CONNECT 4 (Move {}){}\", ORANGE, self.current_move, RESET);\n        println!(\"{}--------------------{}\", ORANGE, RESET);\n\n        for row in self.board {\n            let row_str: String = row\n                .iter()\n                .map(|&cell| match cell {\n                    1 => \"🔴\",\n                    2 => \"🟡\",\n                    _ => \"⚫\",\n                })\n                .collect::<Vec<&str>>()\n                .join(\" \");\n\n            println!(\"{}\", row_str);\n        }\n\n        println!(\"{}--------------------{}\", ORANGE, RESET);\n\n        if self.is_finished {\n            match self.winner {\n                Player::One => println!(\"{}🔴 Player 1이 승리했습니다!{}\", ORANGE, RESET),\n                Player::Two => println!(\"{}🟡 Player 2가 승리했습니다!{}\", ORANGE, RESET),\n                Player::None => println!(\"{}무승부입니다!{}\", ORANGE, RESET),\n            }\n\n            println!(\"{}--------------------{}\", ORANGE, RESET);\n        }\n    }\n}\n```\n\n우리는 이것을 언제든지 메인 함수 내에서 호출하여 보드의 상태를 확인할 수 있습니다.\n\n```js\nfn main() {\n    let mut game = Game::default();\n    game.display_board();\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n조금 지루하지만 수를 두지 않고는 재미가 없죠. 그래서 이제 수를 두는 방법을 프로그래밍해 봅시다!\n\n# 수 두기\n\n우리의 play_move 함수를 첫 번째로 살펴보면, 이 함수는 이차원 배열에서 올바른 항목을 변경하고, 수를 증가시킨 다음 현재 플레이어를 변경해야 합니다.\n\n```rust\nimpl Game {\n    // other functions\n\n    fn play_move(&mut self, column: usize) {\n        if let Some(row) = (0..BOARD_HEIGHT)\n            .rev()\n            .find(|&row| self.board[row][column] == 0)\n        {\n            self.board[row][column] = self.current_player as u8;\n\n            self.current_move += 1;\n\n            self.current_player = match self.current_player {\n                Player::One => Player::Two,\n                _ => Player::One,\n            };\n        }\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 if let 코드에서는 열의 맨 아래부터 시작하여 하나씩 올라가면서 빈 칸을 찾을 때까지 진행합니다. 빈 칸을 찾으면 그 위치에 현재 플레이어를 나타내는 정수로 변경하고, 현재 이동을 증가시킨 후 match 표현식을 사용하여 플레이어를 변경합니다.\n\n이 시점에서 코드를 통해 움직임을 실행하고 터미널에서 결과를 확인할 수 있습니다:\n\n```js\nfn main() {\n    let mut game = Game::default();\n\n    game.play_move(3);\n    game.play_move(3);\n    game.play_move(4);\n    game.play_move(3);\n\n    game.display_board();\n}\n```\n\n# 오류 처리\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n지금까지 우리는 보드 바깥으로 이동을 시도하는 잠재적인 오류를 처리하지 않고 있습니다. 따라서 세 가지 가능한 오류를 처리해 봅시다:\n\n- 제공된 열이 허용 범위를 벗어납니다.\n- 제공된 열이 이미 가득 찼습니다.\n- 게임이 끝났습니다.\n\n(사용자 입력을 받기 시작하면 추가적인 오류 처리가 필요할 것입니다. 나중에 처리하겠습니다.)\n\n세 가지 오류 유형을 포함한 enum을 만들어 봅시다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nenum MoveError {\n    GameFinished,\n    InvalidColumn,\n    ColumnFull,\n}\n```\n\n우리는 에러를 명령줄에 출력하기를 원하기 때문에, 우리의 에러 메시지를 포함하는 사용자 정의 Display 트레이트를 구현해야 합니다. 예를 들어:\n\n```js\nimpl std::fmt::Display for MoveError {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        match self {\n            MoveError::ColumnFull => write!(f, \"column is full\"),\n            MoveError::InvalidColumn => write!(f, \"column must be between 1 and 7\"),\n            MoveError::GameFinished => write!(f, \"game is already finished\"),\n        }\n    }\n}\n```\n\n이제 이를 사용하여 play_move 함수를 수정할 수 있습니다. 이제 우리는 움직임이 성공적이면 아무것도 반환하지만, 그렇지 않은 경우 에러가 반환되는 Result enum을 반환합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```rust\nimpl Game {\n    // 다른 함수들\n\n    fn play_move(&mut self, column: usize) -> Result<(), MoveError> {\n        if self.is_finished {\n            return Err(MoveError::GameFinished);\n        }\n\n        if column >= BOARD_WIDTH {\n            return Err(MoveError::InvalidColumn);\n        }\n\n        if let Some(row) = (0..BOARD_HEIGHT)\n            .rev()\n            .find(|&row| self.board[row][column] == 0)\n        {\n            self.board[row][column] = self.current_player as u8;\n        } else {\n            return Err(MoveError::ColumnFull);\n        }\n\n        self.current_move += 1;\n\n        self.current_player = match self.current_player {\n            Player::One => Player::Two,\n            _ => Player::One,\n        };\n\n        Ok(())\n    }\n}\n```\n\n디버깅을 위해 이제 play_move의 결과를 인쇄할 수 있으며, 예상치 못한 입력이 있는 경우 enum으로부터 에러를 볼 수 있습니다.\n\n우리가 여기에 있는 동안, 명령줄에 에러 메시지를 인쇄하는 도우미 함수를 추가해 봅시다.\n\n```rust\nimpl Game {\n    // 다른 함수들\n\n    fn display_error(&self, error: String) {\n        self.display_board();\n        println!(\"{}에러: {}{}\", RED, error, RESET);\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 게임에서 승리했는지 계산하기\n\n누군가가 이겼는지 확인하기 위해 2차원 배열을 여러 방향으로 탐색해야 합니다. 이 Leetcode 스타일 문제는 재미있는 도전이었고, 결과물을 얻기까지 몇 번 시도해야 했어요.\n\n누군가가 4칸을 연달아 얻을 수 있는 네 가지 방향이 있어요:\n\n- 수평,\n- 수직,\n- 역 슬래시 대각선 (왼쪽 위에서 오른쪽 아래로),\n- 순방향 슬래시 대각선 (왼쪽 아래에서 오른쪽 위로).\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n게시판의 모든 슬롯을 반복하여 네 방향 중 하나에서 테스트할 수 있습니다. (게시판이 작기 때문에 무차별 대입 방식을 사용하는 것이 부담이 되지 않습니다. 그러나 더 나은 방법이 있는지 궁금합니다!)\n\n게시판의 주어진 슬롯에서 시작합니다. 플레이어의 토큰이 들어있는 경우, 첫 번째 방향으로 한 단계 이동합니다. 이 새로운 슬롯도 같은 토큰을 포함하는 경우, 이 방향으로 또 다른 단계를 이동합니다. 이를 반복하여 같은 토큰이 있는 네 개의 슬롯을 찾을 때까지 진행합니다. 그렇지 않으면 다른 방향으로 이동합니다.\n\n각 방향은 정수들의 튜플로 나타낼 수 있습니다 - 행당 거리에 대한 값과 열당 거리에 대한 값 하나씩 - 이 정보를 배열에 저장할 수 있습니다.\n\n```js\nlet directions = [\n  (0, 1), // 가로\n  (1, 0), // 세로\n  (1, 1), // 대각선 (왼쪽 위에서 오른쪽 아래)\n  (-1, 1), // 대각선 (왼쪽 아래에서 오른쪽 위)\n];\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 튜플들이 무엇을 나타내는지 알려드릴게요:\n\n- 수평으로 이동하려면 행은 변하지 않고(0), 열만 변해야 합니다(1).\n- 수직으로 이동하려면 행이 변해야 하고(1), 열은 변하지 않아야 합니다(0).\n- 역 슬래시 대각선으로 이동하려면 행과 열이 둘 다 증가해야 합니다(1, 1).\n- 마지막으로, 슬래시 대각선으로 이동하려면 열은 증가하고 행은 감소해야 합니다(-1, 1).\n\n각 방향의 모든 슬롯을 테스트하려면 아래와 같이 세 개의 루프가 필요합니다.\n\n```rust\nimpl Game {\n    // 다른 함수들\n\n    fn calculate_winner(&mut self) -> Player {\n        for row in 0..BOARD_HEIGHT {\n            for col in 0..BOARD_WIDTH {\n                let cell = self.board[row][col];\n\n                if cell != 0 {\n                    let directions = [\n                        (0, 1),  // 수평\n                        (1, 0),  // 수직\n                        (1, 1),  // 대각선 (왼쪽 위에서 오른쪽 아래로)\n                        (-1, 1), // 대각선 (왼쪽 아래에서 오른쪽 위로)\n                    ];\n\n                    for (row_step, col_step) in directions {\n                        // TODO - 주어진 방향으로 보드를 탐색하고\n                        // 승자를 찾았다면 해당 플레이어를 반환하세요\n                    }\n                }\n            }\n        }\n        Player::None\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리는 연속 카운트를 유지하고 — 4에 도달하면 승자가 나온 것을 알 수 있습니다.\n\n그럼, 최종 중첩된 루프에서는 시작 토큰부터 슬롯별로 이동을 시도할 것입니다. 그때까지…\n\n- 시작 토큰과 다른 토큰을 만날 때 (그러한 경우 루프를 종료합니다);\n- 보드의 가장자리에 도달할 때 (그러한 경우 루프를 종료합니다);\n- 동일한 토큰의 4연속을 만날 때 (그러한 경우 게임을 종료하고 승자를 지정합니다).\n\n```js\nimpl Game {\n    // 다른 함수들\n\n    fn calculate_winner(&mut self) -> Player {\n        for row in 0..BOARD_HEIGHT {\n            for col in 0..BOARD_WIDTH {\n                let cell = self.board[row][col];\n\n                if cell != 0 {\n                    let directions = [\n                        (0, 1),  // 가로\n                        (1, 0),  // 세로\n                        (1, 1),  // 대각선 (왼쪽 위에서 오른쪽 아래로)\n                        (-1, 1), // 대각선 (왼쪽 아래에서 오른쪽 위로)\n                    ];\n\n                    for (row_step, col_step) in directions {\n                        let mut consecutive_count = 1;\n                        let mut r = row as isize + row_step;\n                        let mut c = col as isize + col_step;\n\n                        while r >= 0\n                            && r < BOARD_HEIGHT as isize\n                            && c >= 0\n                            && c < BOARD_WIDTH as isize\n                        {\n                            if self.board[r as usize][c as usize] == cell {\n                                consecutive_count += 1;\n\n                                if consecutive_count == 4 {\n                                    self.is_finished = true;\n                                    return Player::from_int(cell);\n                                }\n                            } else {\n                                break;\n                            }\n                            r += row_step;\n                            c += col_step;\n                        }\n                    }\n                }\n            }\n        }\n\n        Player::None\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리는 이동 횟수가 일곱 미만인 경우 이러한 확인 작업을 수행하지 않고 최적화를 조금 추가할 수 있습니다. 그때까지는 게임에서 이기는 것이 불가능하기 때문입니다. 그래서 함수 맨 위에 이를 추가해 봅시다:\n\n```js\nif self.current_move < 7 {\n    return Player::None;\n}\n```\n\n그리고 보드가 가득 찼지만 승자가 없는 경우(즉, 무승부인 경우)에 게임을 종료로 표시해야 합니다. 이를 반환문 위에 추가해 줍시다:\n\n```js\nif self.current_move >= BOARD_HEIGHT as u8 * BOARD_WIDTH as u8 {\n    self.is_finished = true;\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n마지막으로, 새로운 calculate_winner 함수를 play_move 함수에 추가할 수 있습니다. 이번에는 아무것도 반환하는 대신, 성공인 Result enum을 반환하거나 실패인 경우에는 오류를 반환합니다.\n\n```js\nimpl Game {\n    // 다른 함수들\n\n    fn play_move(&mut self, column: usize) -> Result<(), MoveError> {\n        if self.is_finished {\n            return Err(MoveError::GameFinished);\n        }\n\n        if column >= BOARD_WIDTH {\n            return Err(MoveError::InvalidColumn);\n        }\n\n        if let Some(row) = (0..BOARD_HEIGHT)\n            .rev()\n            .find(|&row| self.board[row][column] == 0)\n        {\n            self.board[row][column] = self.current_player as u8;\n            self.current_move += 1;\n        } else {\n            return Err(MoveError::ColumnFull);\n        }\n\n        let calculated_winner = self.calculate_winner();\n\n        if calculated_winner != Player::None {\n            self.winner = calculated_winner;\n        } else {\n            self.current_player = match self.current_player {\n                Player::One => Player::Two,\n                _ => Player::One,\n            };\n        }\n\n        Ok(())\n    }\n}\n```\n\n우리의 Connect 4 게임 엔진이 완성되었습니다! 사용자로부터 입력을 받는 방법만 남았습니다...\n\n# 사용자 입력 받기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리 명령 줄 게임의 마지막 부분에서는 주 함수로 돌아가 사용자 입력을 읽을 수 있도록 할 것입니다.\n\n먼저, Rust의 표준 I/O 라이브러리를 가져오겠습니다.\n\n```js\nuse std::io;\n```\n\n사용자 입력을 읽는 논리는 다음과 같이 보일 수 있습니다. 여기서는 컴퓨터와 달리 0이 아닌 1부터 시작하여 카운트하게 됩니다!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nlet mut user_move = String::new();\n\nio::stdin()\n    .read_line(&mut user_move)\n    .expect(\"Failed to read line\");\n\nlet user_move: usize = match user_move.trim().parse() {\n    Ok(num) => {\n        if num < 1 || num > BOARD_WIDTH as u8 {\n            game.display_error(MoveError::InvalidColumn.to_string());\n            continue;\n        } else {\n            num\n        }\n    }\n    Err(err) => {\n        game.display_error(err.to_string());\n        continue;\n    }\n};\n\nmatch game.play_move(user_move - 1) {\n    Ok(_) => {\n        game.display_board();\n    }\n    Err(err) => {\n        game.display_error(err.to_string());\n    }\n}\n```\n\n먼저, 우리는 빈 문자열을 정의한 뒤 사용자로부터 텍스트를 받기 위해 stdin 메소드를 사용합니다.\n\n다음으로 이 입력을 구문 분석을 시도합니다. 다음 중 하나라도 해당하는 경우 오류를 표시합니다:\n\n- 구문 분석이 실패하는 경우 (예: 입력이 숫자가 아닌 경우).\n- 구문 분석이 성공하지만 숫자가 원하는 범위를 벗어난 경우.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만약 오류가 표시되지 않는다면, 우리는 선택한 수를 둘 것입니다. 그러나 해당 시나리오에서 오류가 발생할 수도 있으므로, 그런 경우에는 오류를 표시할 것입니다.\n\n그러나 위의 코드는 한 번만 실행됩니다. 게임이 끝날 때까지 루프를 실행해야 합니다. 아래는 그 반복문을 추가한 main 함수와 사용자를 도와줄 몇 가지 유용한 메시지입니다:\n\n```js\nfn main() {\n    let mut game = Game::default();\n    game.display_board();\n\n    while !game.is_finished {\n        println!(\"\\n\");\n\n        match game.current_player {\n            Player::One => println!(\"플레이어 1\"),\n            Player::Two => println!(\"플레이어 2\"),\n            _ => (),\n        };\n\n        println!(\"1부터 7 사이의 열을 입력하세요:\");\n\n        let mut user_move = String::new();\n        io::stdin()\n            .read_line(&mut user_move)\n            .expect(\"라인을 읽는 데 실패했습니다\");\n\n        let user_move: usize = match user_move.trim().parse() {\n            Ok(num) => {\n                if num < 1 || num > 7 {\n                    game.display_error(MoveError::InvalidColumn.to_string());\n                    continue;\n                } else {\n                    num\n                }\n            }\n            Err(err) => {\n                game.display_error(err.to_string());\n                continue;\n            }\n        };\n\n        match game.play_move(user_move - 1) {\n            Ok(_) => {\n                game.display_board();\n            }\n            Err(err) => {\n                game.display_error(err.to_string());\n            }\n        }\n    }\n}\n```\n\n# 여러 판을 플레이하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n마지막으로, 사용자가 게임을 끝내면 게임을 다시 시작할 수 있도록 추가 코드를 추가하고 싶어요. 매번 실행 파일을 다시 시작해야 하는 번거로움은 피하고 싶으니까요!\n\n이를 위해 새로운 루프를 만들 것입니다. 이전과 동일한 방법을 사용하여 사용자의 입력을 읽을 수 있습니다. \"R\"을 누르면 새 게임을 시작하고, \"Q\"를 누르면 루프를 중단하고 코드를 끝까지 실행합니다.\n\n```js\nfn main() {\n    let mut game = Game::default();\n    game.display_board();\n\n    loop {\n        while !game.is_finished {\n            // 코드 변경 없음\n        }\n\n        println!(\"Press 'R' to restart or 'Q' to quit the game.\");\n\n        let mut user_input = String::new();\n\n        io::stdin()\n            .read_line(&mut user_input)\n            .expect(\"Failed to read line\");\n\n        match user_input.trim() {\n            \"R\" | \"r\" => {\n                game = Game::default();\n                game.display_board();\n            }\n            \"Q\" | \"q\" => {\n                println!(\"Quitting...\");\n                break;\n            }\n            _ => game.display_error(\"잘못된 입력\".to_string()),\n        }\n    }\n}\n```\n\n마지막으로, 차례 사이에 터미널을 지우기 위한 ASCII 이스케이프 코드를 사용할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nfn clear_screen(&self) {\n    print!(\"{}[2J\", 27 as char);\n}\n```\n\n게임 보드를 표시할 때마다 이 작업을 수행할 수 있습니다.\n\n```js\nfn display_board(&self) {\n    self.clear_screen();\n\n    // 코드 변경 없음\n}\n```\n\n# 모두 함께 가져오기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그것이 커넥트 4의 간단한 명령줄 게임을 위해 필요한 모든 것입니다! 이 작업 중인 파일을 사용하는 작동 버전을 시험하려면 Rust 플레이그라운드를 확인해보세요.\n\n우리가 지금까지 만든 전체 파일은 아래와 같습니다:\n\n```js\nuse std::io;\n\nconst RESET: &str = \"\\x1b[0m\";\nconst ORANGE: &str = \"\\x1b[93m\";\nconst RED: &str = \"\\x1b[0;31m\";\n\nconst BOARD_WIDTH: usize = 7;\nconst BOARD_HEIGHT: usize = 6;\n\ntype Board = [[u8; BOARD_WIDTH]; BOARD_HEIGHT];\n\n#[derive(Clone, Copy, Debug, PartialEq)]\n#[repr(u8)]\nenum Player {\n    One = 1,\n    Two = 2,\n    None = 0,\n}\n\nimpl Player {\n    fn from_int(int: u8) -> Player {\n        match int {\n            1 => Player::One,\n            2 => Player::Two,\n            _ => Player::None,\n        }\n    }\n}\n\n#[...]\n\n# 결론\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n지금까지 따라오셨다면 프로젝트를 더 나아가고 싶을 것입니다. 여러 게임을 거치면서 승리를 추적해 볼 수도 있고, 어떨까요? 어플리케이션을 웹 서버로 전환하여 웹사이트가 HTTP를 통해 Connect 4를 플레이할 수 있게끔 만들어 보는 것은 어떤가요?\n\n이번 명령줄 어플리케이션을 Rust로 개발하는 방법에 대한 유용하고 재미있는 통찰력으로 여기시길 바랍니다. 아직 Rust 여행을 시작한 지 얼마 되지 않았기 때문에, 어떠한 비평이나 더 많은 Rust 다운 방식으로 어플리케이션을 작성하는 아이디어가 있다면 꼭 알려주세요. 함께 고민해보고 싶습니다.\n```\n","ogImage":{"url":"/assets/img/2024-05-20-LearnRustbycodingacommandlineConnect4game_0.png"},"coverImage":"/assets/img/2024-05-20-LearnRustbycodingacommandlineConnect4game_0.png","tag":["Tech"],"readingTime":24},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p><img src=\"/assets/img/2024-05-20-LearnRustbycodingacommandlineConnect4game_0.png\" alt=\"Rust Connect 4\"></p>\n<p>안녕하세요! 이번 글에서는 Rust가 어떻게 우리가 Connect 4의 간단한 버전을 만들며 명령줄 응용 프로그램을 작성하는 데 도움이 되는지 살펴볼 거에요.</p>\n<p>최근 Rust를 배우는 도전에 도전했고, 제 자신의 조언을 따르기 위해 개인 프로젝트에서 Rust를 사용해 손을 더럽히며 배운 것을 정리하려고 노력하고 있어요. Connect 4는 아주 좋은 도전 과제에요. 오후 하루 동안 코딩할 수 있는 것은 간단하지만 잘 하려면 약간의 생각이 필요한 복잡한 문제이죠.</p>\n<p>여기 제 마지막 결과물이 포함된 Rust 플레이그라운드가 있어요. 아래에서는 거기에 이르기까지 취한 정확한 단계를 살펴볼 거에요. 따라오고 싶으시면 Rust가 설치되어 있는지 확인한 후 터미널에서 <code>cargo new rust_connect_4_tutorial</code>을 실행해서 프로젝트를 열고 좋아하는 편집기에서 src/main.rs로 이동해서 시작해봐요!</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>혹은 비디오를 통해 학습하는 것을 선호한다면, 해당 튜토리얼의 비디오 버전을 확인해보세요:</p>\n<h1>우리의 타입 정의하기</h1>\n<p>Rust에서 시작하는 가장 좋은 방법 중 하나는 종종 우리의 타입을 정의하는 것이므로, 우리는 정확히 그것을 할 것입니다!</p>\n<p>먼저, 게임에 사용할 보드를 정의해 보겠습니다. Connect 4의 클래식 버전은 7개의 슬롯이 가로로 있고 6개의 슬롯이 세로로 있기 때문에, 이들 정수를 상수로 저장하고, 그 상수를 사용하여 두 차원 배열의 길이를 정의하는 데 사용할 수 있습니다. Board 타입으로 정의합니다:</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">const</span> BOARD_WIDTH: <span class=\"hljs-type\">usize</span> = <span class=\"hljs-number\">7</span>;\n<span class=\"hljs-keyword\">const</span> BOARD_HEIGHT: <span class=\"hljs-type\">usize</span> = <span class=\"hljs-number\">6</span>;\n\n<span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">Board</span> = [[<span class=\"hljs-type\">u8</span>; BOARD_WIDTH]; BOARD_HEIGHT];\n</code></pre>\n<p>플레이어를 추적할 방법이 필요할 것입니다. 이를 enum으로 구현할 수 있습니다. 우리는 두 명의 플레이어만 지원하지만, 한 명의 피스가 없는 슬롯을 나타내는 None 변형과 게임이 무승부로 끝날 때 처리하는 데 유용할 것입니다.</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-meta\">#[derive(Clone, Copy, Debug, PartialEq)]</span>\n<span class=\"hljs-meta\">#[repr(u8)]</span>\n<span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title class_\">Player</span> {\n    One = <span class=\"hljs-number\">1</span>,\n    Two = <span class=\"hljs-number\">2</span>,\n    <span class=\"hljs-literal\">None</span> = <span class=\"hljs-number\">0</span>,\n}\n</code></pre>\n<p>위에서는 나중에 유용할 몇 가지 트레잇을 구현하기 위해 derive를 사용하고, enum의 메모리 레이아웃을 제어하기 위해 repr을 사용했습니다. 가능한 모든 값을 알기 때문에 u8로 제한할 수 있습니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>다음으로, 우리는 게임을 나타내는 struct를 만들 것입니다. 여기에는 추적해야 할 모든 상태가 포함될 것입니다.</p>\n<pre><code class=\"hljs language-javascript\">struct <span class=\"hljs-title class_\">Game</span> {\n    <span class=\"hljs-attr\">current_move</span>: u8,\n    <span class=\"hljs-attr\">current_player</span>: <span class=\"hljs-title class_\">Player</span>,\n    <span class=\"hljs-attr\">board</span>: <span class=\"hljs-title class_\">Board</span>,\n    <span class=\"hljs-attr\">is_finished</span>: bool,\n    <span class=\"hljs-attr\">winner</span>: <span class=\"hljs-title class_\">Player</span>,\n}\n</code></pre>\n<p>current_move는 플레이어가 선택한 열을 나타내는 정수입니다. 우리에게는 승자 필드가 있지만, 게임이 비김으로 끝날 때 별도로 is_finished 부울도 유용할 것입니다!</p>\n<p>마지막으로, Game에 대한 기본 함수를 구현할 것입니다. 이 함수에는 초기 상태가 포함될 것입니다:</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">impl</span> <span class=\"hljs-title class_\">Game</span> {\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">default</span>() <span class=\"hljs-punctuation\">-></span> Game {\n        Game {\n            current_move: <span class=\"hljs-number\">0</span>,\n            current_player: Player::One,\n            board: [\n                [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>],\n                [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>],\n                [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>],\n                [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>],\n                [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>],\n                [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>],\n            ],\n            is_finished: <span class=\"hljs-literal\">false</span>,\n            winner: Player::<span class=\"hljs-literal\">None</span>,\n        }\n    }\n}\n</code></pre>\n<p>보드에 대해 조금 이야기해 봅시다. 여기서 0은 빈 칸을 나타내며, 1은 Player One이 차지한 칸을 나타내고, 2는 Player Two가 차지한 칸을 나타냅니다.</p>\n<p>BOARD_WIDTH와 BOARD_HEIGHT를 사용하여 동적으로 생성할 수도 있었지만, 코드를 작성하는 동안 전체 배열을 보는 것이 도움이 되는 시각적 도구라는 것을 발견했습니다. 같은 이유로, 정수가 아닌 Player 열거형을 사용하지 않았습니다. 텍스트가 더 많아지면 코드를 한눈에 이해하기 어려워지기 때문입니다.</p>\n<p>이 방법의 (약간의) 단점은 나중에 정수를 Player로 변환해야 한다는 것입니다. 하지만 Player에 from_int 함수를 구현함으로써 쉽게 해결할 수 있습니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-js\">구현 <span class=\"hljs-title class_\">Player</span> {\n    fn <span class=\"hljs-title function_\">from_int</span>(<span class=\"hljs-attr\">int</span>: u8) -> <span class=\"hljs-title class_\">Player</span> {\n        match int {\n            <span class=\"hljs-number\">1</span> => <span class=\"hljs-title class_\">Player</span>::<span class=\"hljs-title class_\">One</span>,\n            <span class=\"hljs-number\">2</span> => <span class=\"hljs-title class_\">Player</span>::<span class=\"hljs-title class_\">Two</span>,\n            <span class=\"hljs-function\"><span class=\"hljs-params\">_</span> =></span> <span class=\"hljs-title class_\">Player</span>::<span class=\"hljs-title class_\">None</span>,\n        }\n    }\n}\n</code></pre>\n<h1>보드 표시</h1>\n<p>디버깅을 위해, 보드를 시각화하는 좋은 방법을 빠르게 코드화하는 것이 도움이 될 것입니다. 명령줄에 출력하기 위해 크레이트를 사용하는 대신에 간단한 색을 나타내기 위해 16진수 이스케이프 문자열을 사용할 것입니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">RESET</span>: str = <span class=\"hljs-string\">\"\\x1b[0m\"</span>;\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">ORANGE</span>: str = <span class=\"hljs-string\">\"\\x1b[93m\"</span>;\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">RED</span>: str = <span class=\"hljs-string\">\"\\x1b[0;31m\"</span>;\n</code></pre>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>아래의 코드에서는 맵을 사용하여 Connect 4 토큰과 유사한 이모지로 슬롯을 변환할 것입니다. 게임이 종료되면 우승자를 발표하는 좋은 장소로 보입니다.</p>\n<pre><code class=\"hljs language-js\">impl <span class=\"hljs-title class_\">Game</span> {\n    <span class=\"hljs-comment\">// 다른 함수들</span>\n\n    fn <span class=\"hljs-title function_\">display_board</span>(<span class=\"hljs-params\">&#x26;self</span>) {\n        println!(<span class=\"hljs-string\">\"{}--------------------{}\"</span>, <span class=\"hljs-variable constant_\">ORANGE</span>, <span class=\"hljs-variable constant_\">RESET</span>);\n        println!(<span class=\"hljs-string\">\"{}CONNECT 4 (Move {}){}\"</span>, <span class=\"hljs-variable constant_\">ORANGE</span>, self.<span class=\"hljs-property\">current_move</span>, <span class=\"hljs-variable constant_\">RESET</span>);\n        println!(<span class=\"hljs-string\">\"{}--------------------{}\"</span>, <span class=\"hljs-variable constant_\">ORANGE</span>, <span class=\"hljs-variable constant_\">RESET</span>);\n\n        <span class=\"hljs-keyword\">for</span> row <span class=\"hljs-keyword\">in</span> self.<span class=\"hljs-property\">board</span> {\n            <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">row_str</span>: <span class=\"hljs-title class_\">String</span> = row\n                .<span class=\"hljs-title function_\">iter</span>()\n                .<span class=\"hljs-title function_\">map</span>(|&#x26;cell| match cell {\n                    <span class=\"hljs-number\">1</span> => <span class=\"hljs-string\">\"🔴\"</span>,\n                    <span class=\"hljs-number\">2</span> => <span class=\"hljs-string\">\"🟡\"</span>,\n                    <span class=\"hljs-function\"><span class=\"hljs-params\">_</span> =></span> <span class=\"hljs-string\">\"⚫\"</span>,\n                })\n                .<span class=\"hljs-property\">collect</span>::&#x3C;<span class=\"hljs-title class_\">Vec</span>&#x3C;&#x26;str>>()\n                .<span class=\"hljs-title function_\">join</span>(<span class=\"hljs-string\">\" \"</span>);\n\n            println!(<span class=\"hljs-string\">\"{}\"</span>, row_str);\n        }\n\n        println!(<span class=\"hljs-string\">\"{}--------------------{}\"</span>, <span class=\"hljs-variable constant_\">ORANGE</span>, <span class=\"hljs-variable constant_\">RESET</span>);\n\n        <span class=\"hljs-keyword\">if</span> self.<span class=\"hljs-property\">is_finished</span> {\n            match self.<span class=\"hljs-property\">winner</span> {\n                <span class=\"hljs-title class_\">Player</span>::<span class=\"hljs-function\"><span class=\"hljs-params\">One</span> =></span> println!(<span class=\"hljs-string\">\"{}🔴 Player 1이 승리했습니다!{}\"</span>, <span class=\"hljs-variable constant_\">ORANGE</span>, <span class=\"hljs-variable constant_\">RESET</span>),\n                <span class=\"hljs-title class_\">Player</span>::<span class=\"hljs-function\"><span class=\"hljs-params\">Two</span> =></span> println!(<span class=\"hljs-string\">\"{}🟡 Player 2가 승리했습니다!{}\"</span>, <span class=\"hljs-variable constant_\">ORANGE</span>, <span class=\"hljs-variable constant_\">RESET</span>),\n                <span class=\"hljs-title class_\">Player</span>::<span class=\"hljs-function\"><span class=\"hljs-params\">None</span> =></span> println!(<span class=\"hljs-string\">\"{}무승부입니다!{}\"</span>, <span class=\"hljs-variable constant_\">ORANGE</span>, <span class=\"hljs-variable constant_\">RESET</span>),\n            }\n\n            println!(<span class=\"hljs-string\">\"{}--------------------{}\"</span>, <span class=\"hljs-variable constant_\">ORANGE</span>, <span class=\"hljs-variable constant_\">RESET</span>);\n        }\n    }\n}\n</code></pre>\n<p>우리는 이것을 언제든지 메인 함수 내에서 호출하여 보드의 상태를 확인할 수 있습니다.</p>\n<pre><code class=\"hljs language-js\">fn <span class=\"hljs-title function_\">main</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">let</span> mut game = <span class=\"hljs-title class_\">Game</span>::<span class=\"hljs-title function_\">default</span>();\n    game.<span class=\"hljs-title function_\">display_board</span>();\n}\n</code></pre>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>조금 지루하지만 수를 두지 않고는 재미가 없죠. 그래서 이제 수를 두는 방법을 프로그래밍해 봅시다!</p>\n<h1>수 두기</h1>\n<p>우리의 play_move 함수를 첫 번째로 살펴보면, 이 함수는 이차원 배열에서 올바른 항목을 변경하고, 수를 증가시킨 다음 현재 플레이어를 변경해야 합니다.</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">impl</span> <span class=\"hljs-title class_\">Game</span> {\n    <span class=\"hljs-comment\">// other functions</span>\n\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">play_move</span>(&#x26;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>, column: <span class=\"hljs-type\">usize</span>) {\n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">Some</span>(row) = (<span class=\"hljs-number\">0</span>..BOARD_HEIGHT)\n            .<span class=\"hljs-title function_ invoke__\">rev</span>()\n            .<span class=\"hljs-title function_ invoke__\">find</span>(|&#x26;row| <span class=\"hljs-keyword\">self</span>.board[row][column] == <span class=\"hljs-number\">0</span>)\n        {\n            <span class=\"hljs-keyword\">self</span>.board[row][column] = <span class=\"hljs-keyword\">self</span>.current_player <span class=\"hljs-keyword\">as</span> <span class=\"hljs-type\">u8</span>;\n\n            <span class=\"hljs-keyword\">self</span>.current_move += <span class=\"hljs-number\">1</span>;\n\n            <span class=\"hljs-keyword\">self</span>.current_player = <span class=\"hljs-keyword\">match</span> <span class=\"hljs-keyword\">self</span>.current_player {\n                Player::One => Player::Two,\n                _ => Player::One,\n            };\n        }\n    }\n}\n</code></pre>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>위의 if let 코드에서는 열의 맨 아래부터 시작하여 하나씩 올라가면서 빈 칸을 찾을 때까지 진행합니다. 빈 칸을 찾으면 그 위치에 현재 플레이어를 나타내는 정수로 변경하고, 현재 이동을 증가시킨 후 match 표현식을 사용하여 플레이어를 변경합니다.</p>\n<p>이 시점에서 코드를 통해 움직임을 실행하고 터미널에서 결과를 확인할 수 있습니다:</p>\n<pre><code class=\"hljs language-js\">fn <span class=\"hljs-title function_\">main</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">let</span> mut game = <span class=\"hljs-title class_\">Game</span>::<span class=\"hljs-title function_\">default</span>();\n\n    game.<span class=\"hljs-title function_\">play_move</span>(<span class=\"hljs-number\">3</span>);\n    game.<span class=\"hljs-title function_\">play_move</span>(<span class=\"hljs-number\">3</span>);\n    game.<span class=\"hljs-title function_\">play_move</span>(<span class=\"hljs-number\">4</span>);\n    game.<span class=\"hljs-title function_\">play_move</span>(<span class=\"hljs-number\">3</span>);\n\n    game.<span class=\"hljs-title function_\">display_board</span>();\n}\n</code></pre>\n<h1>오류 처리</h1>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>지금까지 우리는 보드 바깥으로 이동을 시도하는 잠재적인 오류를 처리하지 않고 있습니다. 따라서 세 가지 가능한 오류를 처리해 봅시다:</p>\n<ul>\n<li>제공된 열이 허용 범위를 벗어납니다.</li>\n<li>제공된 열이 이미 가득 찼습니다.</li>\n<li>게임이 끝났습니다.</li>\n</ul>\n<p>(사용자 입력을 받기 시작하면 추가적인 오류 처리가 필요할 것입니다. 나중에 처리하겠습니다.)</p>\n<p>세 가지 오류 유형을 포함한 enum을 만들어 봅시다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-js\">enum <span class=\"hljs-title class_\">MoveError</span> {\n    <span class=\"hljs-title class_\">GameFinished</span>,\n    <span class=\"hljs-title class_\">InvalidColumn</span>,\n    <span class=\"hljs-title class_\">ColumnFull</span>,\n}\n</code></pre>\n<p>우리는 에러를 명령줄에 출력하기를 원하기 때문에, 우리의 에러 메시지를 포함하는 사용자 정의 Display 트레이트를 구현해야 합니다. 예를 들어:</p>\n<pre><code class=\"hljs language-js\">impl <span class=\"hljs-attr\">std</span>::<span class=\"hljs-attr\">fmt</span>::<span class=\"hljs-title class_\">Display</span> <span class=\"hljs-keyword\">for</span> <span class=\"hljs-title class_\">MoveError</span> {\n    fn <span class=\"hljs-title function_\">fmt</span>(&#x26;self, <span class=\"hljs-attr\">f</span>: &#x26;mut <span class=\"hljs-attr\">std</span>::<span class=\"hljs-attr\">fmt</span>::<span class=\"hljs-title class_\">Formatter</span>&#x3C;<span class=\"hljs-string\">'_>) -> std::fmt::Result {\n        match self {\n            MoveError::ColumnFull => write!(f, \"column is full\"),\n            MoveError::InvalidColumn => write!(f, \"column must be between 1 and 7\"),\n            MoveError::GameFinished => write!(f, \"game is already finished\"),\n        }\n    }\n}\n</span></code></pre>\n<p>이제 이를 사용하여 play_move 함수를 수정할 수 있습니다. 이제 우리는 움직임이 성공적이면 아무것도 반환하지만, 그렇지 않은 경우 에러가 반환되는 Result enum을 반환합니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">impl</span> <span class=\"hljs-title class_\">Game</span> {\n    <span class=\"hljs-comment\">// 다른 함수들</span>\n\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">play_move</span>(&#x26;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>, column: <span class=\"hljs-type\">usize</span>) <span class=\"hljs-punctuation\">-></span> <span class=\"hljs-type\">Result</span>&#x3C;(), MoveError> {\n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">self</span>.is_finished {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_ invoke__\">Err</span>(MoveError::GameFinished);\n        }\n\n        <span class=\"hljs-keyword\">if</span> column >= BOARD_WIDTH {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_ invoke__\">Err</span>(MoveError::InvalidColumn);\n        }\n\n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">Some</span>(row) = (<span class=\"hljs-number\">0</span>..BOARD_HEIGHT)\n            .<span class=\"hljs-title function_ invoke__\">rev</span>()\n            .<span class=\"hljs-title function_ invoke__\">find</span>(|&#x26;row| <span class=\"hljs-keyword\">self</span>.board[row][column] == <span class=\"hljs-number\">0</span>)\n        {\n            <span class=\"hljs-keyword\">self</span>.board[row][column] = <span class=\"hljs-keyword\">self</span>.current_player <span class=\"hljs-keyword\">as</span> <span class=\"hljs-type\">u8</span>;\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_ invoke__\">Err</span>(MoveError::ColumnFull);\n        }\n\n        <span class=\"hljs-keyword\">self</span>.current_move += <span class=\"hljs-number\">1</span>;\n\n        <span class=\"hljs-keyword\">self</span>.current_player = <span class=\"hljs-keyword\">match</span> <span class=\"hljs-keyword\">self</span>.current_player {\n            Player::One => Player::Two,\n            _ => Player::One,\n        };\n\n        <span class=\"hljs-title function_ invoke__\">Ok</span>(())\n    }\n}\n</code></pre>\n<p>디버깅을 위해 이제 play_move의 결과를 인쇄할 수 있으며, 예상치 못한 입력이 있는 경우 enum으로부터 에러를 볼 수 있습니다.</p>\n<p>우리가 여기에 있는 동안, 명령줄에 에러 메시지를 인쇄하는 도우미 함수를 추가해 봅시다.</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">impl</span> <span class=\"hljs-title class_\">Game</span> {\n    <span class=\"hljs-comment\">// 다른 함수들</span>\n\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">display_error</span>(&#x26;<span class=\"hljs-keyword\">self</span>, error: <span class=\"hljs-type\">String</span>) {\n        <span class=\"hljs-keyword\">self</span>.<span class=\"hljs-title function_ invoke__\">display_board</span>();\n        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"{}에러: {}{}\"</span>, RED, error, RESET);\n    }\n}\n</code></pre>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h1>게임에서 승리했는지 계산하기</h1>\n<p>누군가가 이겼는지 확인하기 위해 2차원 배열을 여러 방향으로 탐색해야 합니다. 이 Leetcode 스타일 문제는 재미있는 도전이었고, 결과물을 얻기까지 몇 번 시도해야 했어요.</p>\n<p>누군가가 4칸을 연달아 얻을 수 있는 네 가지 방향이 있어요:</p>\n<ul>\n<li>수평,</li>\n<li>수직,</li>\n<li>역 슬래시 대각선 (왼쪽 위에서 오른쪽 아래로),</li>\n<li>순방향 슬래시 대각선 (왼쪽 아래에서 오른쪽 위로).</li>\n</ul>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>게시판의 모든 슬롯을 반복하여 네 방향 중 하나에서 테스트할 수 있습니다. (게시판이 작기 때문에 무차별 대입 방식을 사용하는 것이 부담이 되지 않습니다. 그러나 더 나은 방법이 있는지 궁금합니다!)</p>\n<p>게시판의 주어진 슬롯에서 시작합니다. 플레이어의 토큰이 들어있는 경우, 첫 번째 방향으로 한 단계 이동합니다. 이 새로운 슬롯도 같은 토큰을 포함하는 경우, 이 방향으로 또 다른 단계를 이동합니다. 이를 반복하여 같은 토큰이 있는 네 개의 슬롯을 찾을 때까지 진행합니다. 그렇지 않으면 다른 방향으로 이동합니다.</p>\n<p>각 방향은 정수들의 튜플로 나타낼 수 있습니다 - 행당 거리에 대한 값과 열당 거리에 대한 값 하나씩 - 이 정보를 배열에 저장할 수 있습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">let</span> directions = [\n  (<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>), <span class=\"hljs-comment\">// 가로</span>\n  (<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>), <span class=\"hljs-comment\">// 세로</span>\n  (<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>), <span class=\"hljs-comment\">// 대각선 (왼쪽 위에서 오른쪽 아래)</span>\n  (-<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>), <span class=\"hljs-comment\">// 대각선 (왼쪽 아래에서 오른쪽 위)</span>\n];\n</code></pre>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>이 튜플들이 무엇을 나타내는지 알려드릴게요:</p>\n<ul>\n<li>수평으로 이동하려면 행은 변하지 않고(0), 열만 변해야 합니다(1).</li>\n<li>수직으로 이동하려면 행이 변해야 하고(1), 열은 변하지 않아야 합니다(0).</li>\n<li>역 슬래시 대각선으로 이동하려면 행과 열이 둘 다 증가해야 합니다(1, 1).</li>\n<li>마지막으로, 슬래시 대각선으로 이동하려면 열은 증가하고 행은 감소해야 합니다(-1, 1).</li>\n</ul>\n<p>각 방향의 모든 슬롯을 테스트하려면 아래와 같이 세 개의 루프가 필요합니다.</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">impl</span> <span class=\"hljs-title class_\">Game</span> {\n    <span class=\"hljs-comment\">// 다른 함수들</span>\n\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">calculate_winner</span>(&#x26;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>) <span class=\"hljs-punctuation\">-></span> Player {\n        <span class=\"hljs-keyword\">for</span> <span class=\"hljs-variable\">row</span> <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">0</span>..BOARD_HEIGHT {\n            <span class=\"hljs-keyword\">for</span> <span class=\"hljs-variable\">col</span> <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">0</span>..BOARD_WIDTH {\n                <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">cell</span> = <span class=\"hljs-keyword\">self</span>.board[row][col];\n\n                <span class=\"hljs-keyword\">if</span> cell != <span class=\"hljs-number\">0</span> {\n                    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">directions</span> = [\n                        (<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>),  <span class=\"hljs-comment\">// 수평</span>\n                        (<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>),  <span class=\"hljs-comment\">// 수직</span>\n                        (<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>),  <span class=\"hljs-comment\">// 대각선 (왼쪽 위에서 오른쪽 아래로)</span>\n                        (-<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>), <span class=\"hljs-comment\">// 대각선 (왼쪽 아래에서 오른쪽 위로)</span>\n                    ];\n\n                    <span class=\"hljs-title function_ invoke__\">for</span> (row_step, col_step) <span class=\"hljs-keyword\">in</span> directions {\n                        <span class=\"hljs-comment\">// TODO - 주어진 방향으로 보드를 탐색하고</span>\n                        <span class=\"hljs-comment\">// 승자를 찾았다면 해당 플레이어를 반환하세요</span>\n                    }\n                }\n            }\n        }\n        Player::<span class=\"hljs-literal\">None</span>\n    }\n}\n</code></pre>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>우리는 연속 카운트를 유지하고 — 4에 도달하면 승자가 나온 것을 알 수 있습니다.</p>\n<p>그럼, 최종 중첩된 루프에서는 시작 토큰부터 슬롯별로 이동을 시도할 것입니다. 그때까지…</p>\n<ul>\n<li>시작 토큰과 다른 토큰을 만날 때 (그러한 경우 루프를 종료합니다);</li>\n<li>보드의 가장자리에 도달할 때 (그러한 경우 루프를 종료합니다);</li>\n<li>동일한 토큰의 4연속을 만날 때 (그러한 경우 게임을 종료하고 승자를 지정합니다).</li>\n</ul>\n<pre><code class=\"hljs language-js\">impl <span class=\"hljs-title class_\">Game</span> {\n    <span class=\"hljs-comment\">// 다른 함수들</span>\n\n    fn <span class=\"hljs-title function_\">calculate_winner</span>(&#x26;mut self) -> <span class=\"hljs-title class_\">Player</span> {\n        <span class=\"hljs-keyword\">for</span> row <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">0.</span>.<span class=\"hljs-property\">BOARD_HEIGHT</span> {\n            <span class=\"hljs-keyword\">for</span> col <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">0.</span>.<span class=\"hljs-property\">BOARD_WIDTH</span> {\n                <span class=\"hljs-keyword\">let</span> cell = self.<span class=\"hljs-property\">board</span>[row][col];\n\n                <span class=\"hljs-keyword\">if</span> cell != <span class=\"hljs-number\">0</span> {\n                    <span class=\"hljs-keyword\">let</span> directions = [\n                        (<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>),  <span class=\"hljs-comment\">// 가로</span>\n                        (<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>),  <span class=\"hljs-comment\">// 세로</span>\n                        (<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>),  <span class=\"hljs-comment\">// 대각선 (왼쪽 위에서 오른쪽 아래로)</span>\n                        (-<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>), <span class=\"hljs-comment\">// 대각선 (왼쪽 아래에서 오른쪽 위로)</span>\n                    ];\n\n                    <span class=\"hljs-keyword\">for</span> (row_step, col_step) <span class=\"hljs-keyword\">in</span> directions {\n                        <span class=\"hljs-keyword\">let</span> mut consecutive_count = <span class=\"hljs-number\">1</span>;\n                        <span class=\"hljs-keyword\">let</span> mut r = row <span class=\"hljs-keyword\">as</span> isize + row_step;\n                        <span class=\"hljs-keyword\">let</span> mut c = col <span class=\"hljs-keyword\">as</span> isize + col_step;\n\n                        <span class=\"hljs-keyword\">while</span> r >= <span class=\"hljs-number\">0</span>\n                            &#x26;&#x26; r &#x3C; <span class=\"hljs-variable constant_\">BOARD_HEIGHT</span> <span class=\"hljs-keyword\">as</span> isize\n                            &#x26;&#x26; c >= <span class=\"hljs-number\">0</span>\n                            &#x26;&#x26; c &#x3C; <span class=\"hljs-variable constant_\">BOARD_WIDTH</span> <span class=\"hljs-keyword\">as</span> isize\n                        {\n                            <span class=\"hljs-keyword\">if</span> self.<span class=\"hljs-property\">board</span>[r <span class=\"hljs-keyword\">as</span> usize][c <span class=\"hljs-keyword\">as</span> usize] == cell {\n                                consecutive_count += <span class=\"hljs-number\">1</span>;\n\n                                <span class=\"hljs-keyword\">if</span> consecutive_count == <span class=\"hljs-number\">4</span> {\n                                    self.<span class=\"hljs-property\">is_finished</span> = <span class=\"hljs-literal\">true</span>;\n                                    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Player</span>::<span class=\"hljs-title function_\">from_int</span>(cell);\n                                }\n                            } <span class=\"hljs-keyword\">else</span> {\n                                <span class=\"hljs-keyword\">break</span>;\n                            }\n                            r += row_step;\n                            c += col_step;\n                        }\n                    }\n                }\n            }\n        }\n\n        <span class=\"hljs-title class_\">Player</span>::<span class=\"hljs-title class_\">None</span>\n    }\n}\n</code></pre>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>우리는 이동 횟수가 일곱 미만인 경우 이러한 확인 작업을 수행하지 않고 최적화를 조금 추가할 수 있습니다. 그때까지는 게임에서 이기는 것이 불가능하기 때문입니다. 그래서 함수 맨 위에 이를 추가해 봅시다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">if</span> self.<span class=\"hljs-property\">current_move</span> &#x3C; <span class=\"hljs-number\">7</span> {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Player</span>::<span class=\"hljs-title class_\">None</span>;\n}\n</code></pre>\n<p>그리고 보드가 가득 찼지만 승자가 없는 경우(즉, 무승부인 경우)에 게임을 종료로 표시해야 합니다. 이를 반환문 위에 추가해 줍시다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">if</span> self.<span class=\"hljs-property\">current_move</span> >= <span class=\"hljs-variable constant_\">BOARD_HEIGHT</span> <span class=\"hljs-keyword\">as</span> u8 * <span class=\"hljs-variable constant_\">BOARD_WIDTH</span> <span class=\"hljs-keyword\">as</span> u8 {\n    self.<span class=\"hljs-property\">is_finished</span> = <span class=\"hljs-literal\">true</span>;\n}\n</code></pre>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>마지막으로, 새로운 calculate_winner 함수를 play_move 함수에 추가할 수 있습니다. 이번에는 아무것도 반환하는 대신, 성공인 Result enum을 반환하거나 실패인 경우에는 오류를 반환합니다.</p>\n<pre><code class=\"hljs language-js\">impl <span class=\"hljs-title class_\">Game</span> {\n    <span class=\"hljs-comment\">// 다른 함수들</span>\n\n    fn <span class=\"hljs-title function_\">play_move</span>(&#x26;mut self, <span class=\"hljs-attr\">column</span>: usize) -> <span class=\"hljs-title class_\">Result</span>&#x3C;(), <span class=\"hljs-title class_\">MoveError</span>> {\n        <span class=\"hljs-keyword\">if</span> self.<span class=\"hljs-property\">is_finished</span> {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Err</span>(<span class=\"hljs-title class_\">MoveError</span>::<span class=\"hljs-title class_\">GameFinished</span>);\n        }\n\n        <span class=\"hljs-keyword\">if</span> column >= <span class=\"hljs-variable constant_\">BOARD_WIDTH</span> {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Err</span>(<span class=\"hljs-title class_\">MoveError</span>::<span class=\"hljs-title class_\">InvalidColumn</span>);\n        }\n\n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">let</span> <span class=\"hljs-title class_\">Some</span>(row) = (<span class=\"hljs-number\">0.</span>.<span class=\"hljs-property\">BOARD_HEIGHT</span>)\n            .<span class=\"hljs-title function_\">rev</span>()\n            .<span class=\"hljs-title function_\">find</span>(<span class=\"hljs-params\">|&#x26;row| self.board[row][column] == <span class=\"hljs-number\">0</span></span>)\n        {\n            self.<span class=\"hljs-property\">board</span>[row][column] = self.<span class=\"hljs-property\">current_player</span> <span class=\"hljs-keyword\">as</span> u8;\n            self.<span class=\"hljs-property\">current_move</span> += <span class=\"hljs-number\">1</span>;\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Err</span>(<span class=\"hljs-title class_\">MoveError</span>::<span class=\"hljs-title class_\">ColumnFull</span>);\n        }\n\n        <span class=\"hljs-keyword\">let</span> calculated_winner = self.<span class=\"hljs-title function_\">calculate_winner</span>();\n\n        <span class=\"hljs-keyword\">if</span> calculated_winner != <span class=\"hljs-title class_\">Player</span>::<span class=\"hljs-title class_\">None</span> {\n            self.<span class=\"hljs-property\">winner</span> = calculated_winner;\n        } <span class=\"hljs-keyword\">else</span> {\n            self.<span class=\"hljs-property\">current_player</span> = match self.<span class=\"hljs-property\">current_player</span> {\n                <span class=\"hljs-title class_\">Player</span>::<span class=\"hljs-function\"><span class=\"hljs-params\">One</span> =></span> <span class=\"hljs-title class_\">Player</span>::<span class=\"hljs-title class_\">Two</span>,\n                <span class=\"hljs-function\"><span class=\"hljs-params\">_</span> =></span> <span class=\"hljs-title class_\">Player</span>::<span class=\"hljs-title class_\">One</span>,\n            };\n        }\n\n        <span class=\"hljs-title class_\">Ok</span>(())\n    }\n}\n</code></pre>\n<p>우리의 Connect 4 게임 엔진이 완성되었습니다! 사용자로부터 입력을 받는 방법만 남았습니다...</p>\n<h1>사용자 입력 받기</h1>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>우리 명령 줄 게임의 마지막 부분에서는 주 함수로 돌아가 사용자 입력을 읽을 수 있도록 할 것입니다.</p>\n<p>먼저, Rust의 표준 I/O 라이브러리를 가져오겠습니다.</p>\n<pre><code class=\"hljs language-js\">use <span class=\"hljs-attr\">std</span>::io;\n</code></pre>\n<p>사용자 입력을 읽는 논리는 다음과 같이 보일 수 있습니다. 여기서는 컴퓨터와 달리 0이 아닌 1부터 시작하여 카운트하게 됩니다!</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">let</span> mut user_move = <span class=\"hljs-title class_\">String</span>::<span class=\"hljs-title function_\">new</span>();\n\n<span class=\"hljs-attr\">io</span>::<span class=\"hljs-title function_\">stdin</span>()\n    .<span class=\"hljs-title function_\">read_line</span>(&#x26;mut user_move)\n    .<span class=\"hljs-title function_\">expect</span>(<span class=\"hljs-string\">\"Failed to read line\"</span>);\n\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">user_move</span>: usize = match user_move.<span class=\"hljs-title function_\">trim</span>().<span class=\"hljs-title function_\">parse</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-title class_\">Ok</span>(num) => {\n        <span class=\"hljs-keyword\">if</span> num &#x3C; <span class=\"hljs-number\">1</span> || num > <span class=\"hljs-variable constant_\">BOARD_WIDTH</span> <span class=\"hljs-keyword\">as</span> u8 {\n            game.<span class=\"hljs-title function_\">display_error</span>(<span class=\"hljs-title class_\">MoveError</span>::<span class=\"hljs-title class_\">InvalidColumn</span>.<span class=\"hljs-title function_\">to_string</span>());\n            <span class=\"hljs-keyword\">continue</span>;\n        } <span class=\"hljs-keyword\">else</span> {\n            num\n        }\n    }\n    <span class=\"hljs-title class_\">Err</span>(err) => {\n        game.<span class=\"hljs-title function_\">display_error</span>(err.<span class=\"hljs-title function_\">to_string</span>());\n        <span class=\"hljs-keyword\">continue</span>;\n    }\n};\n\nmatch game.<span class=\"hljs-title function_\">play_move</span>(<span class=\"hljs-params\">user_move - <span class=\"hljs-number\">1</span></span>) {\n    <span class=\"hljs-title class_\">Ok</span>(_) => {\n        game.<span class=\"hljs-title function_\">display_board</span>();\n    }\n    <span class=\"hljs-title class_\">Err</span>(err) => {\n        game.<span class=\"hljs-title function_\">display_error</span>(err.<span class=\"hljs-title function_\">to_string</span>());\n    }\n}\n</code></pre>\n<p>먼저, 우리는 빈 문자열을 정의한 뒤 사용자로부터 텍스트를 받기 위해 stdin 메소드를 사용합니다.</p>\n<p>다음으로 이 입력을 구문 분석을 시도합니다. 다음 중 하나라도 해당하는 경우 오류를 표시합니다:</p>\n<ul>\n<li>구문 분석이 실패하는 경우 (예: 입력이 숫자가 아닌 경우).</li>\n<li>구문 분석이 성공하지만 숫자가 원하는 범위를 벗어난 경우.</li>\n</ul>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>만약 오류가 표시되지 않는다면, 우리는 선택한 수를 둘 것입니다. 그러나 해당 시나리오에서 오류가 발생할 수도 있으므로, 그런 경우에는 오류를 표시할 것입니다.</p>\n<p>그러나 위의 코드는 한 번만 실행됩니다. 게임이 끝날 때까지 루프를 실행해야 합니다. 아래는 그 반복문을 추가한 main 함수와 사용자를 도와줄 몇 가지 유용한 메시지입니다:</p>\n<pre><code class=\"hljs language-js\">fn <span class=\"hljs-title function_\">main</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">let</span> mut game = <span class=\"hljs-title class_\">Game</span>::<span class=\"hljs-title function_\">default</span>();\n    game.<span class=\"hljs-title function_\">display_board</span>();\n\n    <span class=\"hljs-keyword\">while</span> !game.<span class=\"hljs-property\">is_finished</span> {\n        println!(<span class=\"hljs-string\">\"\\n\"</span>);\n\n        match game.<span class=\"hljs-property\">current_player</span> {\n            <span class=\"hljs-title class_\">Player</span>::<span class=\"hljs-function\"><span class=\"hljs-params\">One</span> =></span> println!(<span class=\"hljs-string\">\"플레이어 1\"</span>),\n            <span class=\"hljs-title class_\">Player</span>::<span class=\"hljs-function\"><span class=\"hljs-params\">Two</span> =></span> println!(<span class=\"hljs-string\">\"플레이어 2\"</span>),\n            <span class=\"hljs-function\"><span class=\"hljs-params\">_</span> =></span> (),\n        };\n\n        println!(<span class=\"hljs-string\">\"1부터 7 사이의 열을 입력하세요:\"</span>);\n\n        <span class=\"hljs-keyword\">let</span> mut user_move = <span class=\"hljs-title class_\">String</span>::<span class=\"hljs-title function_\">new</span>();\n        <span class=\"hljs-attr\">io</span>::<span class=\"hljs-title function_\">stdin</span>()\n            .<span class=\"hljs-title function_\">read_line</span>(&#x26;mut user_move)\n            .<span class=\"hljs-title function_\">expect</span>(<span class=\"hljs-string\">\"라인을 읽는 데 실패했습니다\"</span>);\n\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">user_move</span>: usize = match user_move.<span class=\"hljs-title function_\">trim</span>().<span class=\"hljs-title function_\">parse</span>(<span class=\"hljs-params\"></span>) {\n            <span class=\"hljs-title class_\">Ok</span>(num) => {\n                <span class=\"hljs-keyword\">if</span> num &#x3C; <span class=\"hljs-number\">1</span> || num > <span class=\"hljs-number\">7</span> {\n                    game.<span class=\"hljs-title function_\">display_error</span>(<span class=\"hljs-title class_\">MoveError</span>::<span class=\"hljs-title class_\">InvalidColumn</span>.<span class=\"hljs-title function_\">to_string</span>());\n                    <span class=\"hljs-keyword\">continue</span>;\n                } <span class=\"hljs-keyword\">else</span> {\n                    num\n                }\n            }\n            <span class=\"hljs-title class_\">Err</span>(err) => {\n                game.<span class=\"hljs-title function_\">display_error</span>(err.<span class=\"hljs-title function_\">to_string</span>());\n                <span class=\"hljs-keyword\">continue</span>;\n            }\n        };\n\n        match game.<span class=\"hljs-title function_\">play_move</span>(<span class=\"hljs-params\">user_move - <span class=\"hljs-number\">1</span></span>) {\n            <span class=\"hljs-title class_\">Ok</span>(_) => {\n                game.<span class=\"hljs-title function_\">display_board</span>();\n            }\n            <span class=\"hljs-title class_\">Err</span>(err) => {\n                game.<span class=\"hljs-title function_\">display_error</span>(err.<span class=\"hljs-title function_\">to_string</span>());\n            }\n        }\n    }\n}\n</code></pre>\n<h1>여러 판을 플레이하기</h1>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>마지막으로, 사용자가 게임을 끝내면 게임을 다시 시작할 수 있도록 추가 코드를 추가하고 싶어요. 매번 실행 파일을 다시 시작해야 하는 번거로움은 피하고 싶으니까요!</p>\n<p>이를 위해 새로운 루프를 만들 것입니다. 이전과 동일한 방법을 사용하여 사용자의 입력을 읽을 수 있습니다. \"R\"을 누르면 새 게임을 시작하고, \"Q\"를 누르면 루프를 중단하고 코드를 끝까지 실행합니다.</p>\n<pre><code class=\"hljs language-js\">fn <span class=\"hljs-title function_\">main</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">let</span> mut game = <span class=\"hljs-title class_\">Game</span>::<span class=\"hljs-title function_\">default</span>();\n    game.<span class=\"hljs-title function_\">display_board</span>();\n\n    loop {\n        <span class=\"hljs-keyword\">while</span> !game.<span class=\"hljs-property\">is_finished</span> {\n            <span class=\"hljs-comment\">// 코드 변경 없음</span>\n        }\n\n        println!(<span class=\"hljs-string\">\"Press 'R' to restart or 'Q' to quit the game.\"</span>);\n\n        <span class=\"hljs-keyword\">let</span> mut user_input = <span class=\"hljs-title class_\">String</span>::<span class=\"hljs-title function_\">new</span>();\n\n        <span class=\"hljs-attr\">io</span>::<span class=\"hljs-title function_\">stdin</span>()\n            .<span class=\"hljs-title function_\">read_line</span>(&#x26;mut user_input)\n            .<span class=\"hljs-title function_\">expect</span>(<span class=\"hljs-string\">\"Failed to read line\"</span>);\n\n        match user_input.<span class=\"hljs-title function_\">trim</span>(<span class=\"hljs-params\"></span>) {\n            <span class=\"hljs-string\">\"R\"</span> | <span class=\"hljs-string\">\"r\"</span> => {\n                game = <span class=\"hljs-title class_\">Game</span>::<span class=\"hljs-title function_\">default</span>();\n                game.<span class=\"hljs-title function_\">display_board</span>();\n            }\n            <span class=\"hljs-string\">\"Q\"</span> | <span class=\"hljs-string\">\"q\"</span> => {\n                println!(<span class=\"hljs-string\">\"Quitting...\"</span>);\n                <span class=\"hljs-keyword\">break</span>;\n            }\n            _ => game.<span class=\"hljs-title function_\">display_error</span>(<span class=\"hljs-string\">\"잘못된 입력\"</span>.<span class=\"hljs-title function_\">to_string</span>()),\n        }\n    }\n}\n</code></pre>\n<p>마지막으로, 차례 사이에 터미널을 지우기 위한 ASCII 이스케이프 코드를 사용할 수 있습니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-js\">fn <span class=\"hljs-title function_\">clear_screen</span>(<span class=\"hljs-params\">&#x26;self</span>) {\n    print!(<span class=\"hljs-string\">\"{}[2J\"</span>, <span class=\"hljs-number\">27</span> <span class=\"hljs-keyword\">as</span> char);\n}\n</code></pre>\n<p>게임 보드를 표시할 때마다 이 작업을 수행할 수 있습니다.</p>\n<pre><code class=\"hljs language-js\">fn <span class=\"hljs-title function_\">display_board</span>(<span class=\"hljs-params\">&#x26;self</span>) {\n    self.<span class=\"hljs-title function_\">clear_screen</span>();\n\n    <span class=\"hljs-comment\">// 코드 변경 없음</span>\n}\n</code></pre>\n<h1>모두 함께 가져오기</h1>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>그것이 커넥트 4의 간단한 명령줄 게임을 위해 필요한 모든 것입니다! 이 작업 중인 파일을 사용하는 작동 버전을 시험하려면 Rust 플레이그라운드를 확인해보세요.</p>\n<p>우리가 지금까지 만든 전체 파일은 아래와 같습니다:</p>\n<pre><code class=\"hljs language-js\">use <span class=\"hljs-attr\">std</span>::io;\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">RESET</span>: &#x26;str = <span class=\"hljs-string\">\"\\x1b[0m\"</span>;\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">ORANGE</span>: &#x26;str = <span class=\"hljs-string\">\"\\x1b[93m\"</span>;\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">RED</span>: &#x26;str = <span class=\"hljs-string\">\"\\x1b[0;31m\"</span>;\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">BOARD_WIDTH</span>: usize = <span class=\"hljs-number\">7</span>;\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">BOARD_HEIGHT</span>: usize = <span class=\"hljs-number\">6</span>;\n\ntype <span class=\"hljs-title class_\">Board</span> = [[u8; <span class=\"hljs-variable constant_\">BOARD_WIDTH</span>]; <span class=\"hljs-variable constant_\">BOARD_HEIGHT</span>];\n\n#[<span class=\"hljs-title function_\">derive</span>(<span class=\"hljs-title class_\">Clone</span>, <span class=\"hljs-title class_\">Copy</span>, <span class=\"hljs-title class_\">Debug</span>, <span class=\"hljs-title class_\">PartialEq</span>)]\n#[<span class=\"hljs-title function_\">repr</span>(u8)]\nenum <span class=\"hljs-title class_\">Player</span> {\n    <span class=\"hljs-title class_\">One</span> = <span class=\"hljs-number\">1</span>,\n    <span class=\"hljs-title class_\">Two</span> = <span class=\"hljs-number\">2</span>,\n    <span class=\"hljs-title class_\">None</span> = <span class=\"hljs-number\">0</span>,\n}\n\nimpl <span class=\"hljs-title class_\">Player</span> {\n    fn <span class=\"hljs-title function_\">from_int</span>(<span class=\"hljs-attr\">int</span>: u8) -> <span class=\"hljs-title class_\">Player</span> {\n        match int {\n            <span class=\"hljs-number\">1</span> => <span class=\"hljs-title class_\">Player</span>::<span class=\"hljs-title class_\">One</span>,\n            <span class=\"hljs-number\">2</span> => <span class=\"hljs-title class_\">Player</span>::<span class=\"hljs-title class_\">Two</span>,\n            <span class=\"hljs-function\"><span class=\"hljs-params\">_</span> =></span> <span class=\"hljs-title class_\">Player</span>::<span class=\"hljs-title class_\">None</span>,\n        }\n    }\n}\n\n#[...]\n\n# 결론\n\n&#x3C;!-- ui-station 사각형 -->\n<span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">ins</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"adsbygoogle\"</span>\n<span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">\"display:block\"</span>\n<span class=\"hljs-attr\">data-ad-client</span>=<span class=\"hljs-string\">\"ca-pub-4877378276818686\"</span>\n<span class=\"hljs-attr\">data-ad-slot</span>=<span class=\"hljs-string\">\"7249294152\"</span>\n<span class=\"hljs-attr\">data-ad-format</span>=<span class=\"hljs-string\">\"auto\"</span>\n<span class=\"hljs-attr\">data-full-width-responsive</span>=<span class=\"hljs-string\">\"true\"</span>></span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">ins</span>></span></span>\n<span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">script</span>></span><span class=\"javascript\">\n(adsbygoogle = <span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">adsbygoogle</span> || []).<span class=\"hljs-title function_\">push</span>({});\n</span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">script</span>></span></span>\n\n지금까지 따라오셨다면 프로젝트를 더 나아가고 싶을 것입니다. 여러 게임을 거치면서 승리를 추적해 볼 수도 있고, 어떨까요? 어플리케이션을 웹 서버로 전환하여 웹사이트가 <span class=\"hljs-variable constant_\">HTTP</span>를 통해 <span class=\"hljs-title class_\">Connect</span> <span class=\"hljs-number\">4</span>를 플레이할 수 있게끔 만들어 보는 것은 어떤가요?\n\n이번 명령줄 어플리케이션을 <span class=\"hljs-title class_\">Rust</span>로 개발하는 방법에 대한 유용하고 재미있는 통찰력으로 여기시길 바랍니다. 아직 <span class=\"hljs-title class_\">Rust</span> 여행을 시작한 지 얼마 되지 않았기 때문에, 어떠한 비평이나 더 많은 <span class=\"hljs-title class_\">Rust</span> 다운 방식으로 어플리케이션을 작성하는 아이디어가 있다면 꼭 알려주세요. 함께 고민해보고 싶습니다.\n</code></pre>\n</body>\n</html>\n"},"__N_SSG":true}