{"pageProps":{"post":{"title":"iOS SwiftUI 프로젝트에서 MVVM으로 적용하는 Clean Architecture","description":"","date":"2024-06-19 14:01","slug":"2024-06-19-TheCleanArchitecturewithMVVMintheiOSSwiftUIProject","content":"\n![Clean Architecture](/assets/img/2024-06-19-TheCleanArchitecturewithMVVMintheiOSSwiftUIProject_0.png)\n\nClean architecture는 Robert C. Martin(명칭: Uncle Bob)이 소개한 소프트웨어 디자인 원칙입니다. Hexagonal Architecture, Onion Architecture, Screaming Architecture 등 소프트웨어 아키텍처에 대한 몇 가지 아이디어가 있었습니다. 이러한 아키텍처들의 주요 개념은 관심사의 분리입니다.\n\n이 기사에서는 클린 아키텍처를 논의하고, 데모 프로젝트를 통해 iOS SwiftUI 앱에 Clean Architecture와 MVVM을 적용하는 방법을 살펴볼 것입니다.\n\n# 클린 아키텍처\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![그림](/assets/img/2024-06-19-TheCleanArchitecturewithMVVMintheiOSSwiftUIProject_1.png)\n\n위 그래프에서 확인할 수 있듯이, 원들은 소프트웨어의 서로 다른 영역을 나타냅니다. 가장 바깥쪽 층은 소프트웨어의 가장 낮은 수준이며, 깊이 들어갈수록 소프트웨어의 수준이 높아집니다. 내부 층은 외부 층에 대해 아무것도 알지 못합니다. 보통, 층이 깊어질수록 해당 층은 변하기 적은 경향이 있습니다.\n\n클린 아키텍처의 주요 규칙은 내부 층에서 외부 층으로의 의존성을 갖지 않는 것입니다. 의존성은 외부 층에서 내부 층으로 연결되어야 합니다. 바깥쪽에서 안쪽으로 향하는 화살표가 의존성 규칙입니다.\n\n클린 아키텍처에는 다양한 층이 있으며, 그룹화한 후에 프레젠테이션, 도메인 및 데이터 층 세 개로 구분할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-06-19-TheCleanArchitecturewithMVVMintheiOSSwiftUIProject_2.png\" />\n\n## 표현 계층\n\n이 계층은 View와 ViewModel로 구성되어 있습니다. View는 하나 이상의 사용 사례를 실행하는 ViewModel에 의해 조정됩니다. 표현 계층은 도메인 계층에만 의존합니다.\n\n## 도메인 계층\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이것은 가장 안쪽 레이어입니다. 이 레이어에는 Entities, Use cases 및 Repository interfaces가 포함되어 있습니다. 이 레이어는 다른 레이어에 종속적이지 않습니다. 따라서 이 레이어는 재사용이 가능하고 테스트하기 쉽습니다. 또한 비즈니스 로직이 여기에 작성됩니다.\n\n## 데이터 레이어\n\n이 레이어에는 리포지토리 구현 및 데이터 소스가 포함되어 있습니다. 리포지토리는 데이터 소스로부터 데이터를 조정하는 역할을 합니다. 데이터 소스는 원격 또는 로컬(예: 코어 데이터)일 수 있습니다. 데이터 레이어는 도메인 레이어에 종속됩니다. 이 레이어에서는 네트워크 JSON 데이터를 도메인 모델로 매핑할 수 있습니다.\n\n## 의존성 방향과 데이터 흐름\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n인터페이스(UI)는 ViewModel(프리젠터)에서 메서드를 호출합니다. ViewModel은 Use Case를 실행하고, Use Case는 데이터를 가져오기 위해 Repository를 호출합니다. Repository는 네트워크나 영구 저장 DB에서 데이터를 가져옵니다. 데이터는 다시 UI로 흐르고, 여기서 데이터를 보여줍니다.\n\n이 흐름은 다음과 같습니다:\n\n인터페이스(UI) - ViewModel(프리젠터) - Use Case(도메인) - Repository(데이터)\n\n이 흐름은 Clean Architecture의 종속성 규칙을 위배합니다. 종속성 규칙에 따르면, 가장 내부에 있는 도메인 레이어는 가장 바깥에 있는 데이터 레이어에 종속되어서는 안 됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n도메인 계층(Use Case)이 사용 사례(도메인 계층)부터 직접적으로 의존하는 대신, 사용 사례는 저장소 인터페이스/프로토콜에 의존하게 됩니다. 이 저장소 프로토콜은 도메인 계층 안에 존재할 것입니다. 이렇게 함으로써 우리는 흐름의 방향을 뒤집을 수 있습니다. 이 뒤집힌 방향이 어떻게 이뤄지는지 자세히 이해해 봅시다:\n\n![이미지](/assets/img/2024-06-19-TheCleanArchitecturewithMVVMintheiOSSwiftUIProject_3.png)\n\n의존성 역전은 데이터 계층과 도메인 계층 간에 발생합니다. 도메인 계층 내부에 저장소 인터페이스가 있기 때문에 데이터 계층은 저장소 인터페이스를 위해 도메인 계층에 의존하게 됩니다. 도메인 계층에서 인터페이스가 변경된다면 데이터 계층도 그에 따라 변경될 것입니다. 여기서는 의존성 방향이 역전되어 있습니다.\n\n인터페이스는 더 높은 수준(도메인에서)에서 결정되고 해당 수준의 클래스(사용 사례)가 이에 의존하므로 추상화에 의존하게 됩니다. 게다가 하위 수준 클래스(저장소) 구현은 더 높은 수준에서 정의된 인터페이스에 의존하므로 세부 사항은 이제 추상화에 의존하게 됩니다. 이것이 바로 의존성 역전의 원칙입니다. 기억하세요, 소프트웨어의 내부 원이 더 높은 수준의 소프트웨어 수준이므로 도메인 계층은 데이터 계층보다 높은 수준에 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그래서, 흐름이 다음과 같이 됩니다:\n\n프레젠테이션 레이어 — `도메인 레이어` — 데이터 레이어\n\n이론은 여기까지! 이제 각 레이어와 MVVM을 예제 프로젝트 및 샘플 코드를 통해 이해하는 시간입니다.\n\n# 예제 프로젝트 — ProductClean\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이것은 공개 API에서 제품 목록을 가져와 목록으로 표시하는 간단한 iOS 애플리케이션입니다. 목록에서 각 항목을 클릭하면 제품 세부 정보 페이지로 이동합니다. 이 프로젝트는 MVVM과 Clean 아키텍처를 사용하여 구축되었습니다. SwiftUI를 사용하여 UI를 구현했습니다.\n\nClean 아키텍처는 구성 요소 간의 역할 분리를 위해 사용되었고 MVVM과 Clean 아키텍처를 함께 사용하여 UI와 프리젠터 사이의 역할을 분리했습니다.\n\n앱의 HLD (고수준 설계) 및 폴더 구조를 살펴보겠습니다:\n\nHLD를 통해 이 앱에는 제품이라는 단일 모듈이 있음을 알 수 있습니다. 필요한 경우 여러 모듈을 가질 수 있습니다. 예를 들어, 이 앱에 로그인 및 결제 기능을 추가하려면 로그인 및 결제 모듈을 추가할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저희는 세 개의 레이어를 가지고 있다는 것을 알고 있어요. 각 레이어를 자세히 살펴볼게요:\n\n## 프레젠테이션 레이어\n\n프레젠테이션 레이어 = ViewModel(프레젠터) + View(UI)\n\n프레젠테이션 레이어에는 ProductListView와 ProductListViewModel이 포함되어 있어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nProductListView\n\nProductListView는 비즈니스 로직(Use cases)에 대한 접근이 없고 데이터 조작과 관련된 코드도 포함하고 있지 않아요. 오직 ViewModel에만 접근할 수 있어요. 따라서 뷰는 재사용성이 높아지고 교체가 가능해져요.\n\n뷰는 ViewModel에 제품 데이터를 가져오도록 요청하고 ViewModel에서 제품 배열을 관찰해요. 제품 배열을 받으면 해당 데이터를 목록에서 표시해요.\n\n```js\nimport SwiftUI\n\nstruct ProductListView<ViewModel>: View where ViewModel: ProductListViewModelProtocol {\n\n    @ObservedObject private var viewModel: ViewModel\n    init(viewModel: ViewModel) {\n        self.viewModel = viewModel\n    }\n\n    var body: some View {\n        NavigationStack {\n            if viewModel.shouldShowLoader() {\n                ProgressView()\n                    .progressViewStyle(.circular)\n            } else {\n                ProductListLayout(items: viewModel.products)\n                    .overlay {\n                        if viewModel.isError {\n                            ErrorView(errorTitle: AppConstant.errorTitle, errorDescription: viewModel.error) {\n                                Task {\n                                    await fetchProducts()\n                                }\n                            }\n                        }\n                    }\n                    .navigationTitle(viewModel.title)\n            }\n        }\n        .task {\n            await fetchProducts()\n        }\n    }\n\n    private func fetchProducts() async {\n        await viewModel.fetchProducts()\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n참고: @ObservedObject 프로퍼티 래퍼는 뷰 내에 observable 유형인 ViewModel을 저장하는 데 사용됩니다.\n\nProductListViewModel\n\nProductListViewModel은 어떤 UI 프레임워크도 import하지 않습니다. 따라서 재사용 가능해집니다. 이는 ProductListViewModelProtocol을 준수하며 ViewModel을 모의(mock)할 수 있고 테스트할 수 있도록 합니다.\n\n```js\nimport Foundation\n\nprotocol ProductListViewModelProtocol: ObservableObject {\n    var products: [ProductListItemViewModel] { get set }\n    var isError: Bool { get }\n    var error: String { get }\n    var isEmpty: Bool { get }\n    var title: String { get }\n    func shouldShowLoader() -> Bool\n    func fetchProducts() async\n}\n\nfinal class ProductListViewModel: ProductListViewModelProtocol {\n\n    @Published var products: [ProductListItemViewModel] = []\n    @Published var isError: Bool = false\n    @Published var error: String = \"\"\n    var isEmpty: Bool { return products.isEmpty }\n    var title: String = AppConstant.productListTitle\n    private let productListUseCase: ProductListUseCase!\n\n    init(useCase: ProductListUseCase) {\n        self.productListUseCase = useCase\n    }\n\n    /// This method fetches products and catches error if any\n    @MainActor func fetchProducts() async {\n        do {\n            let productList = try await productListUseCase.fetchProductList()\n            self.products = self.transformFetchedProducts(products: productList)\n            self.isError = false\n        } catch {\n            self.isError = true\n            if let networkError = error as? NetworkError {\n                self.error = networkError.description\n            } else {\n                self.error = error.localizedDescription\n            }\n        }\n    }\n\n    /// This method maps Product to ProductListItemViewModel\n    /// - Parameter products: array of Product\n    /// - Returns: array of ProductListItemViewModel\n    private func transformFetchedProducts(products: [ProductDomainListDTO]) -> [ProductListItemViewModel] {\n        products.map { ProductListItemViewModel(id: $0.productId,\n                                           title: $0.title,\n                                           description: $0.description,\n                                                price: $0.price.getAmountWithCurrency(),\n                                                category: $0.category.capitalized,\n                                           image: $0.thumbnail) }\n    }\n\n    /// This method checks if the loader should be shown or not\n    /// - Returns: True if there the product array is empty and error is not there\n    func shouldShowLoader() -> Bool {\n        return (isEmpty && !isError)\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nProductListViewModel은 제품 배열, 오류 및 기타 정보를 저장하기 위해 ObservableObject 프로토콜을 준수합니다. ProductListViewModel 내부의 속성에는 뷰에서 액세스되기 때문에 뷰가 업데이트되는 @Published 속성 래퍼가 추가되었습니다. 따라서 @Published 속성 (제품, isError 등) 중 하나가 변경되면 뷰가 업데이트됩니다.\n\nfetchProducts 함수에 @MainActor 속성이 사용되면 해당 작업이 주 스레드에서 실행됨을 보장합니다. fetchProducts 함수 내부에서 @Published 속성이 업데이트되는 것을 볼 수 있습니다. 이러한 속성이 뷰에서 사용되고 이러한 속성이 변경될 때 뷰가 업데이트된다는 것을 알고 있습니다. 뷰(UI)가 주 스레드에서 업데이트되기를 원합니다.\n\n## MVVM\n\nMVVM(Mode-View-ViewModel)은 ViewModel이 뷰와 모델 사이에서 중재자 역할을 하는 디자인 패턴입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![image](/assets/img/2024-06-19-TheCleanArchitecturewithMVVMintheiOSSwiftUIProject_4.png)\n\n뷰모델은 UI 프레임워크를 가져오지 않기 때문에 재사용 가능하고 테스트할 수 있습니다. 하나의 뷰모델에 대해 서로 다른 뷰 구현을 사용할 수 있습니다. 예를 들어, 같은 뷰모델에 대해 UIKit 또는 SwiftUI 뷰를 사용할 수 있습니다.\n\n위에서 논의한 대로 데이터 바인딩에는 ObservableObject 프로토콜을 사용했지만 다른 데이터 바인딩 방법도 사용할 수 있습니다. 예를 들어 델리게이트, 클로저, 알림, 구독자/발행자 등이 있습니다.\n\n저희 프로젝트에서 MVVM은 UI와 프리젠터 간의 관심을 분리하는 데 사용되었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 도메인 레이어\n\n도메인 레이어 = 유스 케이스 + 엔티티 + 리포지토리 인터페이스\n\n도메인 레이어는 ProductListUseCase, ProductDomainListDTO(엔티티) + ProductListRepository 프로토콜로 이루어져 있어요.\n\n특정 모듈의 요구 사항에 따라 여러 개의 유스 케이스가 있을 수 있고, 하나의 유스 케이스가 다른 유스 케이스에 의존할 수 있어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 계층은 Use Case에 쓰인 응용 프로그램 비즈니스 규칙 때문에 가장 중요한 계층입니다. 우리는 Use Case를 보기만 해도 응용 프로그램이 무엇을 하는지 이해할 수 있습니다. 이것을 Screaming Architecture라고 합니다.\n\nProductListUseCase\n\nProductListUseCase는 fetchProductList 함수를 포함하는 ProductListUseCase 프로토콜을 준수합니다. 이는 저장소에 접근하고 저장소로부터 제품 목록 데이터를 불러옵니다.\n\n```js\nimport Foundation\n\nprotocol ProductListUseCase {\n    func fetchProductList() async throws -> [ProductDomainListDTO]\n}\n\nfinal class DefaultProductListUseCase: ProductListUseCase {\n\n    private let repository: ProductListRepository\n\n    init(repository: ProductListRepository) {\n        self.repository = repository\n    }\n\n    func fetchProductList() async throws -> [ProductDomainListDTO] {\n        try await repository.fetchProductList()\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nProductListRepositoryProtocol\n\n도메인 레이어에는 ProductListRepositoryProtocol이 포함되어 있고 ProductListUseCase는 직접 repository 대신 ProductListRepositoryProtocol에 종속되어 있습니다. 따라서 의존성 방향이 역전되었습니다. 위의 의존성 방향 및 데이터 흐름 섹션에서 이미 자세히 논의한 바 있습니다.\n\n```js\nprotocol ProductListRepository {\n    func fetchProductList() async throws -> [ProductDomainListDTO]\n}\n```\n\n참고: ProductListRepositoryProtocol은 의존성 역전에 사용됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nProductDomainListDTO\n\nProductDomainListDTO는 도메인 데이터 전송 객체(DTO)로, 중간 객체로 작동하고 개체를 프레젠테이션 레이어에서 사용할 모델로 변환하는 역할을 담당합니다.\n\n```js\nimport Foundation\n\nstruct ProductDomainListDTO {\n    let productId: Int\n    let title: String\n    let description: String\n    let price: Double\n    var category: String\n    let thumbnail: String\n}\n```\n\n## 데이터 레이어\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n데이터 레이어 = 리포지토리 구현 + 서비스 / 데이터 저장소\n\n데이터 레이어는 DefaultProductListRepository(리포지토리 구현)와 ProductListService로 구성되어 있습니다.\n\nDefaultProductListRepository\n\nDefaultProductListRepository는 ProductListService에 액세스하고 서비스로부터 제품 데이터를 가져와 도메인으로 데이터를 반환하는 fetchProductList 함수를 갖고 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```swift\nimport Foundation\n\nfinal class DefaultProductListRepository: ProductListRepository {\n\n    private let service: ProductListService\n\n    init(service: ProductListService) {\n        self.service = service\n    }\n\n    func fetchProductList() async throws -> [ProductDomainListDTO] {\n        try await service.fetchProductListFromNetwork().products.map { $0.toDomain() }\n    }\n}\n```\n\n참고: 앱이 오프라인 지원을 하는 경우 ProductListRepository에 영속 데이터 저장소 (예: CoreData)가 주입됩니다. 먼저 리포지토리는 캐시된 데이터가 있는지 영구 저장소에서 확인하고, 캐시된 데이터를 도메인 모델로 매핑하여 데이터가 있으면 도메인에 반환합니다. 그런 다음 서비스에게 네트워크에서 데이터를 가져 오도록 요청합니다. 데이터를 가져온 후 리포지토리는 새 데이터로 영구 저장소를 업데이트하고, 도메인 모델로 매핑하여 도메인 계층에 데이터를 반환합니다.\n\nProductListService\n\nProductListService는 네트워크에서 제품 데이터를 가져 오는 fetchProductListFromNetwork 함수 내에서 사용되는 apiDataService에 액세스 권한이 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nimport Foundation\n\nprotocol ProductListService {\n    func fetchProductListFromNetwork() async throws -> ProductPageDataListDTO\n}\n\nfinal class DefaultProductListService: ProductListService {\n\n    private let apiDataService: DataTransferService\n\n    init(apiDataService: DataTransferService) {\n        self.apiDataService = apiDataService\n    }\n\n    func fetchProductListFromNetwork() async throws -> ProductPageDataListDTO {\n        let productListNetworkRequest = DefaultNetworkRequest(path: APIEndpoint.products,method: .get)\n        return try await apiDataService.request(request: productListNetworkRequest)\n    }\n}\n```\n\n## 네트워크\n\n여기서 URLSession을 사용하여 실제 API 호출이 발생합니다. 먼저 EndPoint와 HTTPMethod를 제공하여 첫 번째 네트워크 요청을 생성합니다. 그런 다음 URL 요청이 생성됩니다. URL 요청을 사용하여 데이터를 가져옵니다. 에러가 발생하면 에러를 처리합니다. 또한 Decodable을 사용하여 데이터를 매핑합니다.\n\n```js\nimport Foundation\n\nprotocol DataTransferService {\n    func request<T: Decodable>(request: NetworkRequest) async throws -> T\n}\n\nfinal class DefaultDataTransferService: DataTransferService {\n\n    private let networkManager: NetworkManager\n    init(networkManager: NetworkManager) {\n        self.networkManager = networkManager\n    }\n\n    /// 네트워크 매니저에서 데이터를 가져와 decode 메서드를 사용하여 데이터를 디코딩하는 메서드입니다.\n    /// - Parameter request: 네트워크 요청\n    /// - Returns: Decodable 유형의 객체\n    func request<T>(request: NetworkRequest) async throws -> T where T : Decodable {\n        let data = try await networkManager.fetch(request: request)\n        return try decode(data: data)\n    }\n\n    /// JSONDecoder를 사용하여 데이터를 디코딩하는 메서드입니다.\n    /// - Parameter data: 데이터\n    /// - Returns: Decodable 유형의 객체\n    func decode<T>(data: Data) throws -> T where T : Decodable {\n        do {\n            let decodedData = try JSONDecoder().decode(T.self, from: data)\n            return decodedData\n        } catch {\n            throw NetworkError.unableToDecode\n        }\n    }\n}\n\nimport Foundation\n\nprotocol NetworkSessionManager {\n    func request(with config: NetworkConfigurable, request: NetworkRequest) async throws -> (Data?, URLResponse?)\n}\nprotocol NetworkManager {\n    func fetch(request: NetworkRequest) async throws -> Data\n}\n\nfinal class DefaultNetworkManager: NetworkManager {\n\n    private let config: NetworkConfigurable\n    private let sessionManager: NetworkSessionManager\n\n    init(config: NetworkConfigurable,\n        sessionManager: NetworkSessionManager = DefaultNetworkSessionManager()) {\n        self.config = config\n        self.sessionManager = sessionManager\n    }\n\n    /// 세션 매니저에서 데이터를 가져오고 데이터 및 응답을 유효성 검사하는 메서드입니다.\n    /// - Parameter request: 네트워크 요청\n    /// - Returns: 데이터\n    func fetch(request: NetworkRequest) async throws -> Data {\n        let (data, response) = try await sessionManager.request(with: config, request: request)\n        guard let response = response as? HTTPURLResponse else { throw NetworkError.noResponse }\n        if response.statusCode != 200 { throw NetworkError.failed }\n        guard let data = data else { throw NetworkError.noData }\n        return data\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n노트: 네트워크 관련된 더 많은 코드는 예시 프로젝트의 네트워킹 폴더에 있습니다.\n\n# 의존성 주입 (DI)\n\n의존성 주입은 객체가 자체적으로 만들지 않고 필요로 하는 다른 객체들을 받는 프로그래밍 기법입니다.\n\n우리의 예시 프로젝트에서는 AppDIContainer라는 클래스를 만들었는데, 이 클래스에는 apiDataTransferService가 포함되어 있습니다. 이 apiDataTransferService 객체는 Product 모듈을 생성하는 데 필요합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```swift\nimport Foundation\n\nfinal class AppDIContainer {\n\n    lazy private var apiDataTransferService: DataTransferService = {\n        let config = ApiDataNetworkConfig(baseURL: AppConfiguration.baseURL)\n        let sessionManager = DefaultNetworkSessionManager(session: SharedURLSession.shared)\n        let networkManager = DefaultNetworkManager(config: config, sessionManager: sessionManager)\n        return DefaultDataTransferService(networkManager: networkManager)\n    }()\n\n    lazy var productListView: ProductListView = {\n        let productsModule = ProductsModule(apiDataTransferService: apiDataTransferService)\n        return productsModule.generateProductListView()\n    }()\n}\n```\n\n참고: 우리는 의존성 주입으로 apiDataTransferService를 Product Module에 전달하고 있습니다.\n\n# 결론\n\n클린 아키텍처는 매우 확장 가능하고 테스트 가능하며 유지보수 가능한 소프트웨어를 구축하는 데 도움을 줍니다. 각 계층이 특정 역할을 가지고 다른 부분과 격리되도록 응용 프로그램을 여러 계층으로 분리하여 관련성을 제공합니다. 이는 재사용성의 가능성을 높이고 비즈니스 요구 사항 및 경쟁 시장의 변화에 대응할 수 있도록 보장합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n읽어 주셔서 감사합니다. 연락 기다리겠습니다!\n\n좋은 코딩하세요 :)\n\n![image](https://miro.medium.com/v2/resize:fit:200/1*bdto5WbUfHzG7AuZXY3aGA.gif)\n\n링크드인에서 연결해요.\n","ogImage":{"url":"/assets/img/2024-06-19-TheCleanArchitecturewithMVVMintheiOSSwiftUIProject_0.png"},"coverImage":"/assets/img/2024-06-19-TheCleanArchitecturewithMVVMintheiOSSwiftUIProject_0.png","tag":["Tech"],"readingTime":22},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p><img src=\"/assets/img/2024-06-19-TheCleanArchitecturewithMVVMintheiOSSwiftUIProject_0.png\" alt=\"Clean Architecture\"></p>\n<p>Clean architecture는 Robert C. Martin(명칭: Uncle Bob)이 소개한 소프트웨어 디자인 원칙입니다. Hexagonal Architecture, Onion Architecture, Screaming Architecture 등 소프트웨어 아키텍처에 대한 몇 가지 아이디어가 있었습니다. 이러한 아키텍처들의 주요 개념은 관심사의 분리입니다.</p>\n<p>이 기사에서는 클린 아키텍처를 논의하고, 데모 프로젝트를 통해 iOS SwiftUI 앱에 Clean Architecture와 MVVM을 적용하는 방법을 살펴볼 것입니다.</p>\n<h1>클린 아키텍처</h1>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p><img src=\"/assets/img/2024-06-19-TheCleanArchitecturewithMVVMintheiOSSwiftUIProject_1.png\" alt=\"그림\"></p>\n<p>위 그래프에서 확인할 수 있듯이, 원들은 소프트웨어의 서로 다른 영역을 나타냅니다. 가장 바깥쪽 층은 소프트웨어의 가장 낮은 수준이며, 깊이 들어갈수록 소프트웨어의 수준이 높아집니다. 내부 층은 외부 층에 대해 아무것도 알지 못합니다. 보통, 층이 깊어질수록 해당 층은 변하기 적은 경향이 있습니다.</p>\n<p>클린 아키텍처의 주요 규칙은 내부 층에서 외부 층으로의 의존성을 갖지 않는 것입니다. 의존성은 외부 층에서 내부 층으로 연결되어야 합니다. 바깥쪽에서 안쪽으로 향하는 화살표가 의존성 규칙입니다.</p>\n<p>클린 아키텍처에는 다양한 층이 있으며, 그룹화한 후에 프레젠테이션, 도메인 및 데이터 층 세 개로 구분할 수 있습니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<img src=\"/assets/img/2024-06-19-TheCleanArchitecturewithMVVMintheiOSSwiftUIProject_2.png\">\n<h2>표현 계층</h2>\n<p>이 계층은 View와 ViewModel로 구성되어 있습니다. View는 하나 이상의 사용 사례를 실행하는 ViewModel에 의해 조정됩니다. 표현 계층은 도메인 계층에만 의존합니다.</p>\n<h2>도메인 계층</h2>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>이것은 가장 안쪽 레이어입니다. 이 레이어에는 Entities, Use cases 및 Repository interfaces가 포함되어 있습니다. 이 레이어는 다른 레이어에 종속적이지 않습니다. 따라서 이 레이어는 재사용이 가능하고 테스트하기 쉽습니다. 또한 비즈니스 로직이 여기에 작성됩니다.</p>\n<h2>데이터 레이어</h2>\n<p>이 레이어에는 리포지토리 구현 및 데이터 소스가 포함되어 있습니다. 리포지토리는 데이터 소스로부터 데이터를 조정하는 역할을 합니다. 데이터 소스는 원격 또는 로컬(예: 코어 데이터)일 수 있습니다. 데이터 레이어는 도메인 레이어에 종속됩니다. 이 레이어에서는 네트워크 JSON 데이터를 도메인 모델로 매핑할 수 있습니다.</p>\n<h2>의존성 방향과 데이터 흐름</h2>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>인터페이스(UI)는 ViewModel(프리젠터)에서 메서드를 호출합니다. ViewModel은 Use Case를 실행하고, Use Case는 데이터를 가져오기 위해 Repository를 호출합니다. Repository는 네트워크나 영구 저장 DB에서 데이터를 가져옵니다. 데이터는 다시 UI로 흐르고, 여기서 데이터를 보여줍니다.</p>\n<p>이 흐름은 다음과 같습니다:</p>\n<p>인터페이스(UI) - ViewModel(프리젠터) - Use Case(도메인) - Repository(데이터)</p>\n<p>이 흐름은 Clean Architecture의 종속성 규칙을 위배합니다. 종속성 규칙에 따르면, 가장 내부에 있는 도메인 레이어는 가장 바깥에 있는 데이터 레이어에 종속되어서는 안 됩니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>도메인 계층(Use Case)이 사용 사례(도메인 계층)부터 직접적으로 의존하는 대신, 사용 사례는 저장소 인터페이스/프로토콜에 의존하게 됩니다. 이 저장소 프로토콜은 도메인 계층 안에 존재할 것입니다. 이렇게 함으로써 우리는 흐름의 방향을 뒤집을 수 있습니다. 이 뒤집힌 방향이 어떻게 이뤄지는지 자세히 이해해 봅시다:</p>\n<p><img src=\"/assets/img/2024-06-19-TheCleanArchitecturewithMVVMintheiOSSwiftUIProject_3.png\" alt=\"이미지\"></p>\n<p>의존성 역전은 데이터 계층과 도메인 계층 간에 발생합니다. 도메인 계층 내부에 저장소 인터페이스가 있기 때문에 데이터 계층은 저장소 인터페이스를 위해 도메인 계층에 의존하게 됩니다. 도메인 계층에서 인터페이스가 변경된다면 데이터 계층도 그에 따라 변경될 것입니다. 여기서는 의존성 방향이 역전되어 있습니다.</p>\n<p>인터페이스는 더 높은 수준(도메인에서)에서 결정되고 해당 수준의 클래스(사용 사례)가 이에 의존하므로 추상화에 의존하게 됩니다. 게다가 하위 수준 클래스(저장소) 구현은 더 높은 수준에서 정의된 인터페이스에 의존하므로 세부 사항은 이제 추상화에 의존하게 됩니다. 이것이 바로 의존성 역전의 원칙입니다. 기억하세요, 소프트웨어의 내부 원이 더 높은 수준의 소프트웨어 수준이므로 도메인 계층은 데이터 계층보다 높은 수준에 있습니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>그래서, 흐름이 다음과 같이 됩니다:</p>\n<p>프레젠테이션 레이어 — <code>도메인 레이어</code> — 데이터 레이어</p>\n<p>이론은 여기까지! 이제 각 레이어와 MVVM을 예제 프로젝트 및 샘플 코드를 통해 이해하는 시간입니다.</p>\n<h1>예제 프로젝트 — ProductClean</h1>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>이것은 공개 API에서 제품 목록을 가져와 목록으로 표시하는 간단한 iOS 애플리케이션입니다. 목록에서 각 항목을 클릭하면 제품 세부 정보 페이지로 이동합니다. 이 프로젝트는 MVVM과 Clean 아키텍처를 사용하여 구축되었습니다. SwiftUI를 사용하여 UI를 구현했습니다.</p>\n<p>Clean 아키텍처는 구성 요소 간의 역할 분리를 위해 사용되었고 MVVM과 Clean 아키텍처를 함께 사용하여 UI와 프리젠터 사이의 역할을 분리했습니다.</p>\n<p>앱의 HLD (고수준 설계) 및 폴더 구조를 살펴보겠습니다:</p>\n<p>HLD를 통해 이 앱에는 제품이라는 단일 모듈이 있음을 알 수 있습니다. 필요한 경우 여러 모듈을 가질 수 있습니다. 예를 들어, 이 앱에 로그인 및 결제 기능을 추가하려면 로그인 및 결제 모듈을 추가할 수 있습니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>저희는 세 개의 레이어를 가지고 있다는 것을 알고 있어요. 각 레이어를 자세히 살펴볼게요:</p>\n<h2>프레젠테이션 레이어</h2>\n<p>프레젠테이션 레이어 = ViewModel(프레젠터) + View(UI)</p>\n<p>프레젠테이션 레이어에는 ProductListView와 ProductListViewModel이 포함되어 있어요.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>ProductListView</p>\n<p>ProductListView는 비즈니스 로직(Use cases)에 대한 접근이 없고 데이터 조작과 관련된 코드도 포함하고 있지 않아요. 오직 ViewModel에만 접근할 수 있어요. 따라서 뷰는 재사용성이 높아지고 교체가 가능해져요.</p>\n<p>뷰는 ViewModel에 제품 데이터를 가져오도록 요청하고 ViewModel에서 제품 배열을 관찰해요. 제품 배열을 받으면 해당 데이터를 목록에서 표시해요.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">SwiftUI</span>\n\nstruct <span class=\"hljs-title class_\">ProductListView</span>&#x3C;<span class=\"hljs-title class_\">ViewModel</span>>: <span class=\"hljs-title class_\">View</span> where <span class=\"hljs-title class_\">ViewModel</span>: <span class=\"hljs-title class_\">ProductListViewModelProtocol</span> {\n\n    @<span class=\"hljs-title class_\">ObservedObject</span> private <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">viewModel</span>: <span class=\"hljs-title class_\">ViewModel</span>\n    <span class=\"hljs-title function_\">init</span>(<span class=\"hljs-params\">viewModel: ViewModel</span>) {\n        self.<span class=\"hljs-property\">viewModel</span> = viewModel\n    }\n\n    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">body</span>: some <span class=\"hljs-title class_\">View</span> {\n        <span class=\"hljs-title class_\">NavigationStack</span> {\n            <span class=\"hljs-keyword\">if</span> viewModel.<span class=\"hljs-title function_\">shouldShowLoader</span>(<span class=\"hljs-params\"></span>) {\n                <span class=\"hljs-title class_\">ProgressView</span>()\n                    .<span class=\"hljs-title function_\">progressViewStyle</span>(.<span class=\"hljs-property\">circular</span>)\n            } <span class=\"hljs-keyword\">else</span> {\n                <span class=\"hljs-title class_\">ProductListLayout</span>(<span class=\"hljs-attr\">items</span>: viewModel.<span class=\"hljs-property\">products</span>)\n                    .<span class=\"hljs-property\">overlay</span> {\n                        <span class=\"hljs-keyword\">if</span> viewModel.<span class=\"hljs-property\">isError</span> {\n                            <span class=\"hljs-title class_\">ErrorView</span>(<span class=\"hljs-attr\">errorTitle</span>: <span class=\"hljs-title class_\">AppConstant</span>.<span class=\"hljs-property\">errorTitle</span>, <span class=\"hljs-attr\">errorDescription</span>: viewModel.<span class=\"hljs-property\">error</span>) {\n                                <span class=\"hljs-title class_\">Task</span> {\n                                    <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">fetchProducts</span>()\n                                }\n                            }\n                        }\n                    }\n                    .<span class=\"hljs-title function_\">navigationTitle</span>(viewModel.<span class=\"hljs-property\">title</span>)\n            }\n        }\n        .<span class=\"hljs-property\">task</span> {\n            <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">fetchProducts</span>()\n        }\n    }\n\n    private func <span class=\"hljs-title function_\">fetchProducts</span>() <span class=\"hljs-keyword\">async</span> {\n        <span class=\"hljs-keyword\">await</span> viewModel.<span class=\"hljs-title function_\">fetchProducts</span>()\n    }\n}\n</code></pre>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>참고: @ObservedObject 프로퍼티 래퍼는 뷰 내에 observable 유형인 ViewModel을 저장하는 데 사용됩니다.</p>\n<p>ProductListViewModel</p>\n<p>ProductListViewModel은 어떤 UI 프레임워크도 import하지 않습니다. 따라서 재사용 가능해집니다. 이는 ProductListViewModelProtocol을 준수하며 ViewModel을 모의(mock)할 수 있고 테스트할 수 있도록 합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Foundation</span>\n\nprotocol <span class=\"hljs-title class_\">ProductListViewModelProtocol</span>: <span class=\"hljs-title class_\">ObservableObject</span> {\n    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">products</span>: [<span class=\"hljs-title class_\">ProductListItemViewModel</span>] { get set }\n    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">isError</span>: <span class=\"hljs-title class_\">Bool</span> { get }\n    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">error</span>: <span class=\"hljs-title class_\">String</span> { get }\n    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">isEmpty</span>: <span class=\"hljs-title class_\">Bool</span> { get }\n    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">title</span>: <span class=\"hljs-title class_\">String</span> { get }\n    func <span class=\"hljs-title function_\">shouldShowLoader</span>() -> <span class=\"hljs-title class_\">Bool</span>\n    func <span class=\"hljs-title function_\">fetchProducts</span>() <span class=\"hljs-keyword\">async</span>\n}\n\nfinal <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ProductListViewModel</span>: <span class=\"hljs-title class_\">ProductListViewModelProtocol</span> {\n\n    @<span class=\"hljs-title class_\">Published</span> <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">products</span>: [<span class=\"hljs-title class_\">ProductListItemViewModel</span>] = []\n    @<span class=\"hljs-title class_\">Published</span> <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">isError</span>: <span class=\"hljs-title class_\">Bool</span> = <span class=\"hljs-literal\">false</span>\n    @<span class=\"hljs-title class_\">Published</span> <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">error</span>: <span class=\"hljs-title class_\">String</span> = <span class=\"hljs-string\">\"\"</span>\n    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">isEmpty</span>: <span class=\"hljs-title class_\">Bool</span> { <span class=\"hljs-keyword\">return</span> products.<span class=\"hljs-property\">isEmpty</span> }\n    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">title</span>: <span class=\"hljs-title class_\">String</span> = <span class=\"hljs-title class_\">AppConstant</span>.<span class=\"hljs-property\">productListTitle</span>\n    private <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">productListUseCase</span>: <span class=\"hljs-title class_\">ProductListUseCase</span>!\n\n    <span class=\"hljs-title function_\">init</span>(<span class=\"hljs-params\">useCase: ProductListUseCase</span>) {\n        self.<span class=\"hljs-property\">productListUseCase</span> = useCase\n    }\n\n    <span class=\"hljs-comment\">/// This method fetches products and catches error if any</span>\n    @<span class=\"hljs-title class_\">MainActor</span> func <span class=\"hljs-title function_\">fetchProducts</span>() <span class=\"hljs-keyword\">async</span> {\n        <span class=\"hljs-keyword\">do</span> {\n            <span class=\"hljs-keyword\">let</span> productList = <span class=\"hljs-keyword\">try</span> <span class=\"hljs-keyword\">await</span> productListUseCase.<span class=\"hljs-title function_\">fetchProductList</span>()\n            self.<span class=\"hljs-property\">products</span> = self.<span class=\"hljs-title function_\">transformFetchedProducts</span>(<span class=\"hljs-attr\">products</span>: productList)\n            self.<span class=\"hljs-property\">isError</span> = <span class=\"hljs-literal\">false</span>\n        } <span class=\"hljs-keyword\">catch</span> {\n            self.<span class=\"hljs-property\">isError</span> = <span class=\"hljs-literal\">true</span>\n            <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">let</span> networkError = error <span class=\"hljs-keyword\">as</span>? <span class=\"hljs-title class_\">NetworkError</span> {\n                self.<span class=\"hljs-property\">error</span> = networkError.<span class=\"hljs-property\">description</span>\n            } <span class=\"hljs-keyword\">else</span> {\n                self.<span class=\"hljs-property\">error</span> = error.<span class=\"hljs-property\">localizedDescription</span>\n            }\n        }\n    }\n\n    <span class=\"hljs-comment\">/// This method maps Product to ProductListItemViewModel</span>\n    <span class=\"hljs-comment\">/// - Parameter products: array of Product</span>\n    <span class=\"hljs-comment\">/// - Returns: array of ProductListItemViewModel</span>\n    private func <span class=\"hljs-title function_\">transformFetchedProducts</span>(<span class=\"hljs-attr\">products</span>: [<span class=\"hljs-title class_\">ProductDomainListDTO</span>]) -> [<span class=\"hljs-title class_\">ProductListItemViewModel</span>] {\n        products.<span class=\"hljs-property\">map</span> { <span class=\"hljs-title class_\">ProductListItemViewModel</span>(<span class=\"hljs-attr\">id</span>: $0.<span class=\"hljs-property\">productId</span>,\n                                           <span class=\"hljs-attr\">title</span>: $0.<span class=\"hljs-property\">title</span>,\n                                           <span class=\"hljs-attr\">description</span>: $0.<span class=\"hljs-property\">description</span>,\n                                                <span class=\"hljs-attr\">price</span>: $0.<span class=\"hljs-property\">price</span>.<span class=\"hljs-title function_\">getAmountWithCurrency</span>(),\n                                                <span class=\"hljs-attr\">category</span>: $0.<span class=\"hljs-property\">category</span>.<span class=\"hljs-property\">capitalized</span>,\n                                           <span class=\"hljs-attr\">image</span>: $0.<span class=\"hljs-property\">thumbnail</span>) }\n    }\n\n    <span class=\"hljs-comment\">/// This method checks if the loader should be shown or not</span>\n    <span class=\"hljs-comment\">/// - Returns: True if there the product array is empty and error is not there</span>\n    func <span class=\"hljs-title function_\">shouldShowLoader</span>() -> <span class=\"hljs-title class_\">Bool</span> {\n        <span class=\"hljs-keyword\">return</span> (isEmpty &#x26;&#x26; !isError)\n    }\n}\n</code></pre>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>ProductListViewModel은 제품 배열, 오류 및 기타 정보를 저장하기 위해 ObservableObject 프로토콜을 준수합니다. ProductListViewModel 내부의 속성에는 뷰에서 액세스되기 때문에 뷰가 업데이트되는 @Published 속성 래퍼가 추가되었습니다. 따라서 @Published 속성 (제품, isError 등) 중 하나가 변경되면 뷰가 업데이트됩니다.</p>\n<p>fetchProducts 함수에 @MainActor 속성이 사용되면 해당 작업이 주 스레드에서 실행됨을 보장합니다. fetchProducts 함수 내부에서 @Published 속성이 업데이트되는 것을 볼 수 있습니다. 이러한 속성이 뷰에서 사용되고 이러한 속성이 변경될 때 뷰가 업데이트된다는 것을 알고 있습니다. 뷰(UI)가 주 스레드에서 업데이트되기를 원합니다.</p>\n<h2>MVVM</h2>\n<p>MVVM(Mode-View-ViewModel)은 ViewModel이 뷰와 모델 사이에서 중재자 역할을 하는 디자인 패턴입니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p><img src=\"/assets/img/2024-06-19-TheCleanArchitecturewithMVVMintheiOSSwiftUIProject_4.png\" alt=\"image\"></p>\n<p>뷰모델은 UI 프레임워크를 가져오지 않기 때문에 재사용 가능하고 테스트할 수 있습니다. 하나의 뷰모델에 대해 서로 다른 뷰 구현을 사용할 수 있습니다. 예를 들어, 같은 뷰모델에 대해 UIKit 또는 SwiftUI 뷰를 사용할 수 있습니다.</p>\n<p>위에서 논의한 대로 데이터 바인딩에는 ObservableObject 프로토콜을 사용했지만 다른 데이터 바인딩 방법도 사용할 수 있습니다. 예를 들어 델리게이트, 클로저, 알림, 구독자/발행자 등이 있습니다.</p>\n<p>저희 프로젝트에서 MVVM은 UI와 프리젠터 간의 관심을 분리하는 데 사용되었습니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h2>도메인 레이어</h2>\n<p>도메인 레이어 = 유스 케이스 + 엔티티 + 리포지토리 인터페이스</p>\n<p>도메인 레이어는 ProductListUseCase, ProductDomainListDTO(엔티티) + ProductListRepository 프로토콜로 이루어져 있어요.</p>\n<p>특정 모듈의 요구 사항에 따라 여러 개의 유스 케이스가 있을 수 있고, 하나의 유스 케이스가 다른 유스 케이스에 의존할 수 있어요.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>이 계층은 Use Case에 쓰인 응용 프로그램 비즈니스 규칙 때문에 가장 중요한 계층입니다. 우리는 Use Case를 보기만 해도 응용 프로그램이 무엇을 하는지 이해할 수 있습니다. 이것을 Screaming Architecture라고 합니다.</p>\n<p>ProductListUseCase</p>\n<p>ProductListUseCase는 fetchProductList 함수를 포함하는 ProductListUseCase 프로토콜을 준수합니다. 이는 저장소에 접근하고 저장소로부터 제품 목록 데이터를 불러옵니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Foundation</span>\n\nprotocol <span class=\"hljs-title class_\">ProductListUseCase</span> {\n    func <span class=\"hljs-title function_\">fetchProductList</span>() <span class=\"hljs-keyword\">async</span> throws -> [<span class=\"hljs-title class_\">ProductDomainListDTO</span>]\n}\n\nfinal <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DefaultProductListUseCase</span>: <span class=\"hljs-title class_\">ProductListUseCase</span> {\n\n    private <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">repository</span>: <span class=\"hljs-title class_\">ProductListRepository</span>\n\n    <span class=\"hljs-title function_\">init</span>(<span class=\"hljs-params\">repository: ProductListRepository</span>) {\n        self.<span class=\"hljs-property\">repository</span> = repository\n    }\n\n    func <span class=\"hljs-title function_\">fetchProductList</span>() <span class=\"hljs-keyword\">async</span> throws -> [<span class=\"hljs-title class_\">ProductDomainListDTO</span>] {\n        <span class=\"hljs-keyword\">try</span> <span class=\"hljs-keyword\">await</span> repository.<span class=\"hljs-title function_\">fetchProductList</span>()\n    }\n}\n</code></pre>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>ProductListRepositoryProtocol</p>\n<p>도메인 레이어에는 ProductListRepositoryProtocol이 포함되어 있고 ProductListUseCase는 직접 repository 대신 ProductListRepositoryProtocol에 종속되어 있습니다. 따라서 의존성 방향이 역전되었습니다. 위의 의존성 방향 및 데이터 흐름 섹션에서 이미 자세히 논의한 바 있습니다.</p>\n<pre><code class=\"hljs language-js\">protocol <span class=\"hljs-title class_\">ProductListRepository</span> {\n    func <span class=\"hljs-title function_\">fetchProductList</span>() <span class=\"hljs-keyword\">async</span> throws -> [<span class=\"hljs-title class_\">ProductDomainListDTO</span>]\n}\n</code></pre>\n<p>참고: ProductListRepositoryProtocol은 의존성 역전에 사용됩니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>ProductDomainListDTO</p>\n<p>ProductDomainListDTO는 도메인 데이터 전송 객체(DTO)로, 중간 객체로 작동하고 개체를 프레젠테이션 레이어에서 사용할 모델로 변환하는 역할을 담당합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Foundation</span>\n\nstruct <span class=\"hljs-title class_\">ProductDomainListDTO</span> {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">productId</span>: <span class=\"hljs-title class_\">Int</span>\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">title</span>: <span class=\"hljs-title class_\">String</span>\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">description</span>: <span class=\"hljs-title class_\">String</span>\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">price</span>: <span class=\"hljs-title class_\">Double</span>\n    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">category</span>: <span class=\"hljs-title class_\">String</span>\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">thumbnail</span>: <span class=\"hljs-title class_\">String</span>\n}\n</code></pre>\n<h2>데이터 레이어</h2>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>데이터 레이어 = 리포지토리 구현 + 서비스 / 데이터 저장소</p>\n<p>데이터 레이어는 DefaultProductListRepository(리포지토리 구현)와 ProductListService로 구성되어 있습니다.</p>\n<p>DefaultProductListRepository</p>\n<p>DefaultProductListRepository는 ProductListService에 액세스하고 서비스로부터 제품 데이터를 가져와 도메인으로 데이터를 반환하는 fetchProductList 함수를 갖고 있습니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-keyword\">import</span> Foundation\n\n<span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DefaultProductListRepository</span>: <span class=\"hljs-title class_\">ProductListRepository</span> {\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">let</span> service: <span class=\"hljs-type\">ProductListService</span>\n\n    <span class=\"hljs-keyword\">init</span>(<span class=\"hljs-params\">service</span>: <span class=\"hljs-type\">ProductListService</span>) {\n        <span class=\"hljs-keyword\">self</span>.service <span class=\"hljs-operator\">=</span> service\n    }\n\n    <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">fetchProductList</span>() <span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">throws</span> -> [<span class=\"hljs-type\">ProductDomainListDTO</span>] {\n        <span class=\"hljs-keyword\">try</span> <span class=\"hljs-keyword\">await</span> service.fetchProductListFromNetwork().products.map { <span class=\"hljs-variable\">$0</span>.toDomain() }\n    }\n}\n</code></pre>\n<p>참고: 앱이 오프라인 지원을 하는 경우 ProductListRepository에 영속 데이터 저장소 (예: CoreData)가 주입됩니다. 먼저 리포지토리는 캐시된 데이터가 있는지 영구 저장소에서 확인하고, 캐시된 데이터를 도메인 모델로 매핑하여 데이터가 있으면 도메인에 반환합니다. 그런 다음 서비스에게 네트워크에서 데이터를 가져 오도록 요청합니다. 데이터를 가져온 후 리포지토리는 새 데이터로 영구 저장소를 업데이트하고, 도메인 모델로 매핑하여 도메인 계층에 데이터를 반환합니다.</p>\n<p>ProductListService</p>\n<p>ProductListService는 네트워크에서 제품 데이터를 가져 오는 fetchProductListFromNetwork 함수 내에서 사용되는 apiDataService에 액세스 권한이 있습니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Foundation</span>\n\nprotocol <span class=\"hljs-title class_\">ProductListService</span> {\n    func <span class=\"hljs-title function_\">fetchProductListFromNetwork</span>() <span class=\"hljs-keyword\">async</span> throws -> <span class=\"hljs-title class_\">ProductPageDataListDTO</span>\n}\n\nfinal <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DefaultProductListService</span>: <span class=\"hljs-title class_\">ProductListService</span> {\n\n    private <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">apiDataService</span>: <span class=\"hljs-title class_\">DataTransferService</span>\n\n    <span class=\"hljs-title function_\">init</span>(<span class=\"hljs-params\">apiDataService: DataTransferService</span>) {\n        self.<span class=\"hljs-property\">apiDataService</span> = apiDataService\n    }\n\n    func <span class=\"hljs-title function_\">fetchProductListFromNetwork</span>() <span class=\"hljs-keyword\">async</span> throws -> <span class=\"hljs-title class_\">ProductPageDataListDTO</span> {\n        <span class=\"hljs-keyword\">let</span> productListNetworkRequest = <span class=\"hljs-title class_\">DefaultNetworkRequest</span>(<span class=\"hljs-attr\">path</span>: <span class=\"hljs-title class_\">APIEndpoint</span>.<span class=\"hljs-property\">products</span>,<span class=\"hljs-attr\">method</span>: .<span class=\"hljs-property\">get</span>)\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">try</span> <span class=\"hljs-keyword\">await</span> apiDataService.<span class=\"hljs-title function_\">request</span>(<span class=\"hljs-attr\">request</span>: productListNetworkRequest)\n    }\n}\n</code></pre>\n<h2>네트워크</h2>\n<p>여기서 URLSession을 사용하여 실제 API 호출이 발생합니다. 먼저 EndPoint와 HTTPMethod를 제공하여 첫 번째 네트워크 요청을 생성합니다. 그런 다음 URL 요청이 생성됩니다. URL 요청을 사용하여 데이터를 가져옵니다. 에러가 발생하면 에러를 처리합니다. 또한 Decodable을 사용하여 데이터를 매핑합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Foundation</span>\n\nprotocol <span class=\"hljs-title class_\">DataTransferService</span> {\n    func request&#x3C;<span class=\"hljs-attr\">T</span>: <span class=\"hljs-title class_\">Decodable</span>>(<span class=\"hljs-attr\">request</span>: <span class=\"hljs-title class_\">NetworkRequest</span>) <span class=\"hljs-keyword\">async</span> throws -> T\n}\n\nfinal <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DefaultDataTransferService</span>: <span class=\"hljs-title class_\">DataTransferService</span> {\n\n    private <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">networkManager</span>: <span class=\"hljs-title class_\">NetworkManager</span>\n    <span class=\"hljs-title function_\">init</span>(<span class=\"hljs-params\">networkManager: NetworkManager</span>) {\n        self.<span class=\"hljs-property\">networkManager</span> = networkManager\n    }\n\n    <span class=\"hljs-comment\">/// 네트워크 매니저에서 데이터를 가져와 decode 메서드를 사용하여 데이터를 디코딩하는 메서드입니다.</span>\n    <span class=\"hljs-comment\">/// - Parameter request: 네트워크 요청</span>\n    <span class=\"hljs-comment\">/// - Returns: Decodable 유형의 객체</span>\n    func request&#x3C;T>(<span class=\"hljs-attr\">request</span>: <span class=\"hljs-title class_\">NetworkRequest</span>) <span class=\"hljs-keyword\">async</span> throws -> T where T : <span class=\"hljs-title class_\">Decodable</span> {\n        <span class=\"hljs-keyword\">let</span> data = <span class=\"hljs-keyword\">try</span> <span class=\"hljs-keyword\">await</span> networkManager.<span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-attr\">request</span>: request)\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">try</span> <span class=\"hljs-title function_\">decode</span>(<span class=\"hljs-attr\">data</span>: data)\n    }\n\n    <span class=\"hljs-comment\">/// JSONDecoder를 사용하여 데이터를 디코딩하는 메서드입니다.</span>\n    <span class=\"hljs-comment\">/// - Parameter data: 데이터</span>\n    <span class=\"hljs-comment\">/// - Returns: Decodable 유형의 객체</span>\n    func decode&#x3C;T>(<span class=\"hljs-attr\">data</span>: <span class=\"hljs-title class_\">Data</span>) throws -> T where T : <span class=\"hljs-title class_\">Decodable</span> {\n        <span class=\"hljs-keyword\">do</span> {\n            <span class=\"hljs-keyword\">let</span> decodedData = <span class=\"hljs-keyword\">try</span> <span class=\"hljs-title class_\">JSON</span>Decoder().<span class=\"hljs-title function_\">decode</span>(T.<span class=\"hljs-property\">self</span>, <span class=\"hljs-attr\">from</span>: data)\n            <span class=\"hljs-keyword\">return</span> decodedData\n        } <span class=\"hljs-keyword\">catch</span> {\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-title class_\">NetworkError</span>.<span class=\"hljs-property\">unableToDecode</span>\n        }\n    }\n}\n\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Foundation</span>\n\nprotocol <span class=\"hljs-title class_\">NetworkSessionManager</span> {\n    func <span class=\"hljs-title function_\">request</span>(<span class=\"hljs-keyword\">with</span> <span class=\"hljs-attr\">config</span>: <span class=\"hljs-title class_\">NetworkConfigurable</span>, <span class=\"hljs-attr\">request</span>: <span class=\"hljs-title class_\">NetworkRequest</span>) <span class=\"hljs-keyword\">async</span> throws -> (<span class=\"hljs-title class_\">Data</span>?, <span class=\"hljs-title class_\">URLResponse</span>?)\n}\nprotocol <span class=\"hljs-title class_\">NetworkManager</span> {\n    func <span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-attr\">request</span>: <span class=\"hljs-title class_\">NetworkRequest</span>) <span class=\"hljs-keyword\">async</span> throws -> <span class=\"hljs-title class_\">Data</span>\n}\n\nfinal <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DefaultNetworkManager</span>: <span class=\"hljs-title class_\">NetworkManager</span> {\n\n    private <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">config</span>: <span class=\"hljs-title class_\">NetworkConfigurable</span>\n    private <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">sessionManager</span>: <span class=\"hljs-title class_\">NetworkSessionManager</span>\n\n    <span class=\"hljs-title function_\">init</span>(<span class=\"hljs-params\">config: NetworkConfigurable,\n        sessionManager: NetworkSessionManager = DefaultNetworkSessionManager()</span>) {\n        self.<span class=\"hljs-property\">config</span> = config\n        self.<span class=\"hljs-property\">sessionManager</span> = sessionManager\n    }\n\n    <span class=\"hljs-comment\">/// 세션 매니저에서 데이터를 가져오고 데이터 및 응답을 유효성 검사하는 메서드입니다.</span>\n    <span class=\"hljs-comment\">/// - Parameter request: 네트워크 요청</span>\n    <span class=\"hljs-comment\">/// - Returns: 데이터</span>\n    func <span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-attr\">request</span>: <span class=\"hljs-title class_\">NetworkRequest</span>) <span class=\"hljs-keyword\">async</span> throws -> <span class=\"hljs-title class_\">Data</span> {\n        <span class=\"hljs-keyword\">let</span> (data, response) = <span class=\"hljs-keyword\">try</span> <span class=\"hljs-keyword\">await</span> sessionManager.<span class=\"hljs-title function_\">request</span>(<span class=\"hljs-attr\">with</span>: config, <span class=\"hljs-attr\">request</span>: request)\n        guard <span class=\"hljs-keyword\">let</span> response = response <span class=\"hljs-keyword\">as</span>? <span class=\"hljs-title class_\">HTTPURLResponse</span> <span class=\"hljs-keyword\">else</span> { <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-title class_\">NetworkError</span>.<span class=\"hljs-property\">noResponse</span> }\n        <span class=\"hljs-keyword\">if</span> response.<span class=\"hljs-property\">statusCode</span> != <span class=\"hljs-number\">200</span> { <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-title class_\">NetworkError</span>.<span class=\"hljs-property\">failed</span> }\n        guard <span class=\"hljs-keyword\">let</span> data = data <span class=\"hljs-keyword\">else</span> { <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-title class_\">NetworkError</span>.<span class=\"hljs-property\">noData</span> }\n        <span class=\"hljs-keyword\">return</span> data\n    }\n}\n</code></pre>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>노트: 네트워크 관련된 더 많은 코드는 예시 프로젝트의 네트워킹 폴더에 있습니다.</p>\n<h1>의존성 주입 (DI)</h1>\n<p>의존성 주입은 객체가 자체적으로 만들지 않고 필요로 하는 다른 객체들을 받는 프로그래밍 기법입니다.</p>\n<p>우리의 예시 프로젝트에서는 AppDIContainer라는 클래스를 만들었는데, 이 클래스에는 apiDataTransferService가 포함되어 있습니다. 이 apiDataTransferService 객체는 Product 모듈을 생성하는 데 필요합니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-keyword\">import</span> Foundation\n\n<span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AppDIContainer</span> {\n\n    <span class=\"hljs-keyword\">lazy</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> apiDataTransferService: <span class=\"hljs-type\">DataTransferService</span> <span class=\"hljs-operator\">=</span> {\n        <span class=\"hljs-keyword\">let</span> config <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">ApiDataNetworkConfig</span>(baseURL: <span class=\"hljs-type\">AppConfiguration</span>.baseURL)\n        <span class=\"hljs-keyword\">let</span> sessionManager <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">DefaultNetworkSessionManager</span>(session: <span class=\"hljs-type\">SharedURLSession</span>.shared)\n        <span class=\"hljs-keyword\">let</span> networkManager <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">DefaultNetworkManager</span>(config: config, sessionManager: sessionManager)\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-type\">DefaultDataTransferService</span>(networkManager: networkManager)\n    }()\n\n    <span class=\"hljs-keyword\">lazy</span> <span class=\"hljs-keyword\">var</span> productListView: <span class=\"hljs-type\">ProductListView</span> <span class=\"hljs-operator\">=</span> {\n        <span class=\"hljs-keyword\">let</span> productsModule <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">ProductsModule</span>(apiDataTransferService: apiDataTransferService)\n        <span class=\"hljs-keyword\">return</span> productsModule.generateProductListView()\n    }()\n}\n</code></pre>\n<p>참고: 우리는 의존성 주입으로 apiDataTransferService를 Product Module에 전달하고 있습니다.</p>\n<h1>결론</h1>\n<p>클린 아키텍처는 매우 확장 가능하고 테스트 가능하며 유지보수 가능한 소프트웨어를 구축하는 데 도움을 줍니다. 각 계층이 특정 역할을 가지고 다른 부분과 격리되도록 응용 프로그램을 여러 계층으로 분리하여 관련성을 제공합니다. 이는 재사용성의 가능성을 높이고 비즈니스 요구 사항 및 경쟁 시장의 변화에 대응할 수 있도록 보장합니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>읽어 주셔서 감사합니다. 연락 기다리겠습니다!</p>\n<p>좋은 코딩하세요 :)</p>\n<p><img src=\"https://miro.medium.com/v2/resize:fit:200/1*bdto5WbUfHzG7AuZXY3aGA.gif\" alt=\"image\"></p>\n<p>링크드인에서 연결해요.</p>\n</body>\n</html>\n"},"__N_SSG":true}