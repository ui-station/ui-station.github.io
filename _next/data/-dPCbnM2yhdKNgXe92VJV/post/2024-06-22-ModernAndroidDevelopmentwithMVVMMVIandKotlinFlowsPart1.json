{"pageProps":{"post":{"title":"MVVM, MVI 및 Kotlin Flows를 활용한 최신 안드로이드 개발  Part 1","description":"","date":"2024-06-22 22:37","slug":"2024-06-22-ModernAndroidDevelopmentwithMVVMMVIandKotlinFlowsPart1","content":"\n## 안드로이드 MVI 아키텍처의 심층 탐구\n\n<img src=\"/assets/img/2024-06-22-ModernAndroidDevelopmentwithMVVMMVIandKotlinFlowsPart1_0.png\" />\n\n앱 개발 프로세스를 개선하고 스트림라인하는 방법을 찾느라 고심 중인 안드로이드 개발자이신가요? Kotlin flows를 사용하여 MVVM 및 MVI 아키텍처 패턴을 결합하는 것을 들어보았지만 그것이 어떻게 도움이 될 수 있는지 또는 어디서 시작해야 하는지 확실하지 않으신가요? 이 기사는 여러분을 위해 특별히 작성되었습니다.\n\n안드로이드 개발에 있어서 올바른 아키텍처 패턴을 선택하는 것이 얼마나 중요한지 우리 모두 알고 있습니다. 이는 관리 가능한 프로젝트와 완전한 엉망인 프로젝트 사이의 차이를 의미할 수 있습니다. 이미 MVVM (Model-View-ViewModel) 및 MVI (Model-View-Intent) 패턴에 대해 알고 계실 것으로 생각됩니다. 각각에는 강점과 약점이 있습니다. MVVM은 데이터 바인딩과 표시 상태 관리에서 빛을 발하며, MVI는 단방향 데이터 흐름과 강력한 상태 관리로 빛을 발합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n하지만 이 두 강력한 패턴을 결합하여 안드로이드 개발에 더 강력한 접근 방식을 만들 수 있다고 말했다면 어떨까요? 바로 Kotlin flows를 사용하여 MVVM과 MVI 간의 원활한 통합을 제공하는 방법을 이 글에서 살펴보겠습니다.\n\n# MVC 대 MVI\n\n결합된 방식에 대해 자세히 살펴보기 전에 먼저 MVC (Model-View-Controller)와 MVI의 핵심 원칙을 이해해 보겠습니다.\n\n## MVC란 무엇인가요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nMVC 패턴에서 Model은 데이터와 비즈니스 로직을 나타내고, View는 UI를 렌더링하는 역할을 하며, Controller는 Model과 View 사이에서 중개자 역할을 하며, 사용자 입력을 처리하고 Model과 View를 업데이트합니다.\n\n![Image](/assets/img/2024-06-22-ModernAndroidDevelopmentwithMVVMMVIandKotlinFlowsPart1_1.png)\n\n다음은 안드로이드에서 Model-View-Controller (MVC) 아키텍처를 구현하는 예시입니다:\n\nModel 파일 이름은 UserModel.kt:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\ndata class User(val id: String, val name: String, val email: String)\n\nclass UserModel {\n    private val users: MutableList<User> = mutableListOf()\n\n    fun addUser(user: User) {\n        users.add(user)\n    }\n\n    fun getUsers(): List<User> {\n        return users.toList()\n    }\n}\n```\n\nUserModel 클래스는 Model을 나타내며 사용자 목록을 관리합니다.\n\n컨트롤러는 UserController.kt 입니다:\n\n```kotlin\nclass UserController(private val userView: UserView) {\n\n    private val userModel = UserModel()\n\n    // 모델 조작\n    fun addUser(name: String, email: String) {\n        val user = User(UUID.randomUUID().toString(), name, email)\n        userModel.addUser(user)\n\n        val users = userModel.getUsers()\n        updateView(users)\n    }\n\n    private fun updateView(users: List<User>) {\n        // 뷰에서 UI를 업데이트하는 적절한 메서드 호출\n        userView.displayUsers(users)\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nThe UserController 클래스는 Controller 역할을 하며 사용자 상호작용을 처리하고 Model을 업데이트합니다. 또한 Model의 변경 사항에 따라 UI를 업데이트하기 위해 View와 통신합니다.\n\n뷰는 MvcActivity.kt에서 제공됩니다:\n\n```js\ninterface UserView {\n    fun displayUsers(users: List<User>)\n}\n\nclass MvcActivity : AppCompatActivity(), UserView {\n    private lateinit var userAdapter: UserAdapter\n    private lateinit var binding: ActivityMvcBinding\n    private lateinit var controller: UserController\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        binding = ActivityMvcBinding.inflate(layoutInflater)\n        setContentView(binding.root)\n        setupRecyclerView()\n\n        // 컨트롤러 생성\n        controller = UserController(this)\n\n        binding.addUserButton.setOnClickListener {\n            val name = binding.nameEditText.text.toString()\n            val email = binding.emailEditText.text.toString()\n            // 사용자 입력 전송\n            controller.addUser(name, email)\n        }\n    }\n\n    override fun displayUsers(users: List<User>) {\n        // 사용자 목록을 표시하기 위해 UI 업데이트\n        userAdapter.setUsers(users)\n    }\n\n    private fun setupRecyclerView() {\n        // 코드가 간결하게 유지될 수 있도록 주석 처리됨\n    }\n}\n```\n\nMvcActivity 클래스는 View를 나타내며 UI를 표시하는 역할을 담당합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## MVI란 무엇인가요?\n\n![image](/assets/img/2024-06-22-ModernAndroidDevelopmentwithMVVMMVIandKotlinFlowsPart1_2.png)\n\nMVI 패턴은 Model-View-Controller (MVC) 패턴의 변형으로 생각될 수 있습니다. Model-View-Intent (MVI)의 주요 아이디어는 사용자 인터페이스를 구축하기 위한 반응적이고 기능적 접근 방식을 제공하는 것입니다. 이는 Model-View-Controller (MVC) 아키텍처와 유사합니다.\n\n## MVI는 어떻게 작동하나요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nMVI에서 기본 개념은 동일하지만 보다 반응적이고 기능적인 프로그래밍 스타일을 강조합니다. Model을 직접 변경하거나 View를 업데이트하는 대신, MVI는 사용자 의도를 불변의 데이터 구조 (Intents)로 캡처하고 단방향 데이터 흐름을 통해 이를 처리하는 데 초점을 맞춥니다. 이러한 흐름은 일반적으로 세 가지 주요 구성 요소로 구성됩니다:\n\n- Model: 응용 프로그램의 현재 상태를 나타냅니다. Model은 변경할 수 없습니다. Model은 의도를 처리하고 Model의 새 버전을 생성함으로써 업데이트됩니다.\n- View: 현재 Model 상태를 기반으로 UI를 렌더링하는 역할을 합니다. View는 수동적이며 Model이 변경될 때마다 업데이트를 수신합니다.\n- Intent: 사용자 작업 또는 의도를 나타내며, View에서 Model을 업데이트하기 위해 전송됩니다. Intents는 사용자가 수행하려는 작업을 설명하는 일반적으로 간단한 데이터 구조입니다.\n\n![이미지](/assets/img/2024-06-22-ModernAndroidDevelopmentwithMVVMMVIandKotlinFlowsPart1_3.png)\n\nMVI 패턴은 엄격한 단방향 데이터 흐름을 강제합니다. 데이터는 의도에서 모델로, 그리고 모델에서 뷰로 흐릅니다. 이렇게 하면 앱의 동작 및 상태에 대한 추론이 더 쉬워지며 구성 요소 간 부작용이나 종속성이 없기 때문에 유지보수가 쉽습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## MVC에서 MVI로 변환하기:\n\n위의 코드를 MVI 아키텍처로 어떻게 변경할 수 있는지 알아봅시다. 먼저 두 가지 추가 클래스를 추가해야 합니다. 뷰 내에서 사용자 관련 데이터의 현재 상태를 나타내는 UserViewState 클래스를 소개했습니다. UserIntent sealed 클래스는 사용자 의도를 나타내는 다양한 의도를 정의합니다. 예를 들어 사용자를 추가하는 것입니다.\n\n```js\ndata class UserViewState(val users: List<User>)\n\nsealed class UserIntent {\n    data class AddUser(val name: String, val email: String) : UserIntent()\n    // GetUsers와 같은 다른 사용자 의도도 추가할 수 있습니다.\n}\n```\n\nUserController와 UserView 인터페이스를 제거할 수 있습니다. 또한 UserModel 클래스를 변경하여 현재 뷰 상태를 유지하고 사용자 의도를 처리하며 사용자 상태를 업데이트할 수 있습니다. UserModel은 Kotlin Coroutines Flow를 사용하여 반응적일 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nclass UserModel {\n    // 애플리케이션의 현재 뷰 상태를 유지합니다\n    private val _userViewState: MutableStateFlow<UserViewState> = MutableStateFlow(UserViewState(emptyList()))\n    // 다른 뷰들과 뷰 상태를 공유하여 핫 플로우로 제공합니다\n    val userViewState = _userViewState.asStateFlow()\n\n    // processUserIntents에서 사용할 현재 뷰 상태를 얻습니다\n    private fun currentViewState(): UserViewState {\n        return _userViewState.value\n    }\n\n    // 뷰로부터 사용자 의도를 처리합니다\n    fun processUserIntents(userIntent: UserIntent) {\n        when (userIntent) {\n            is UserIntent.AddUser -> {\n                val user = User(UUID.randomUUID().toString(), userIntent.name, userIntent.email)\n                val newViewState = currentViewState().copy(users = currentViewState().users + user)\n                _userViewState.value = newViewState\n            }\n            /*\n            * 다른 사용자 의도(예: 사용자 목록 가져오기)도 여기서 처리할 수 있습니다\n            * */\n        }\n    }\n}\n```\n\nuserViewState는 사용자 뷰 상태를 핫 플로우로 공유합니다. 핫 플로우는 활성 구독자 여부와 관계없이 값을 방출합니다. 핫 플로우는 구독자 여부와 상관없이 계속 업데이트를 방출하는 공유 상태를 유지합니다. 새로운 구독자가 참여하면 최신 값 및 이후의 업데이트를 수신합니다. asStateFlow() 함수는 MutableSharedFlow를 StateFlow로 변환하며, 얻어진 StateFlow는 최신 값 유지 및 구독자 활동 여부에 관계없이 업데이트를 방출하는 핫 플로우로 간주될 수 있습니다.\n\n그리고 View 부분에 대한 변경사항은 다음과 같습니다:\n\n```js\nclass MviActivity : AppCompatActivity() {\n    private lateinit var userAdapter: UserAdapter\n    private lateinit var binding: ActivityMviBinding\n    private val model = UserModel()\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        binding = ActivityMviBinding.inflate(layoutInflater)\n        setContentView(binding.root)\n        setupRecyclerView()\n\n        binding.addUserButton.setOnClickListener {\n            val name = binding.nameEditText.text.toString()\n            val email = binding.emailEditText.text.toString()\n\n            // 사용자 의도를 생성하고 모델에 전달합니다\n            val userIntent = UserIntent.AddUser(name, email)\n            model.processUserIntents(userIntent)\n        }\n\n        // UI가 뷰 상태 변경을 관찰합니다\n        model.userViewState\n            .onEach { userViewState ->\n                renderUserViewState(userViewState)\n            }\n            .launchIn(lifecycleScope)\n    }\n\n    private fun renderUserViewState(userViewState: UserViewState) {\n        // 사용자 목록을 표시하기 위해 UI를 업데이트합니다\n        userAdapter.setUsers(userViewState.users)\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nMviActivity에서는 onEach를 사용하여 상태 플로우를 관찰하고 renderUserViewState()를 호출하여 UI를 업데이트합니다.\n\n수정된 코드로 다시 다이어그램을 살펴봅시다. 코드를 다이어그램의 각 부분에 매핑하는 방법을 살펴봅시다:\n\n![Diagram](/assets/img/2024-06-22-ModernAndroidDevelopmentwithMVVMMVIandKotlinFlowsPart1_4.png)\n\n위 다이어그램에서 사용자는 OnClick 등의 액션을 트리거할 수 있습니다. 이러한 액션들은 인텐트로 파싱되어 모델에 전달될 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n모델에서 processUserIntentsexecutes는 전달된 Intent에 기반한 로직을 실행하며, 이 경우 UserIntent.AddUser를 받아 새로운 상태를 생성합니다:\n\n```js\nval newViewState = currentViewState().copy(users = currentViewState().users + user)\n_userViewState.value = newViewState\n```\n\ncopy()는 기존 객체와 동일한 속성을 가진 새 객체를 생성하는 Kotlin 함수입니다. 이 경우 currentViewState().copy()는 현재 뷰 상태와 동일한 속성을 가진 새 UserViewState 객체를 생성합니다.\n\nusers = currentViewState().users + user 부분은 새로운 뷰 상태의 users 속성을 업데이트해야 함을 명시합니다. 요약하자면, 이 두 줄의 코드는 현재 뷰 상태의 복사본을 만들어 사용자 목록에 새로운 사용자가 추가된 새로운 뷰 상태 객체를 생성합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n뷰 부분에서 새 상태가 생성될 때마다 MviActivity가 변경 사항을 observe합니다.\n\n```js\nmodel.userViewState\n  .onEach { userViewState ->\n      renderUserViewState(userViewState)\n  }\n  .launchIn(lifecycleScope)\n```\n\n그리고 renderUserViewState(userViewState)를 사용하여 사용자에게 상태를 표시합니다. 반응형 프로그래밍과 Kotlin Coroutine 플로우 덕분에 가능해졌습니다.\n\n# 다음은 무엇인가요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음 시리즈에서는 MVVM 아키텍처를 MVI와 비교하고 이러한 아키텍처를 더 깊이 파헤쳐 양쪽에서 최상의 결과를 얻을 수 있는 방법에 대해 살펴볼 것입니다. 기대해주세요!\n","ogImage":{"url":"/assets/img/2024-06-22-ModernAndroidDevelopmentwithMVVMMVIandKotlinFlowsPart1_0.png"},"coverImage":"/assets/img/2024-06-22-ModernAndroidDevelopmentwithMVVMMVIandKotlinFlowsPart1_0.png","tag":["Tech"],"readingTime":12},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<h2>안드로이드 MVI 아키텍처의 심층 탐구</h2>\n<img src=\"/assets/img/2024-06-22-ModernAndroidDevelopmentwithMVVMMVIandKotlinFlowsPart1_0.png\">\n<p>앱 개발 프로세스를 개선하고 스트림라인하는 방법을 찾느라 고심 중인 안드로이드 개발자이신가요? Kotlin flows를 사용하여 MVVM 및 MVI 아키텍처 패턴을 결합하는 것을 들어보았지만 그것이 어떻게 도움이 될 수 있는지 또는 어디서 시작해야 하는지 확실하지 않으신가요? 이 기사는 여러분을 위해 특별히 작성되었습니다.</p>\n<p>안드로이드 개발에 있어서 올바른 아키텍처 패턴을 선택하는 것이 얼마나 중요한지 우리 모두 알고 있습니다. 이는 관리 가능한 프로젝트와 완전한 엉망인 프로젝트 사이의 차이를 의미할 수 있습니다. 이미 MVVM (Model-View-ViewModel) 및 MVI (Model-View-Intent) 패턴에 대해 알고 계실 것으로 생각됩니다. 각각에는 강점과 약점이 있습니다. MVVM은 데이터 바인딩과 표시 상태 관리에서 빛을 발하며, MVI는 단방향 데이터 흐름과 강력한 상태 관리로 빛을 발합니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>하지만 이 두 강력한 패턴을 결합하여 안드로이드 개발에 더 강력한 접근 방식을 만들 수 있다고 말했다면 어떨까요? 바로 Kotlin flows를 사용하여 MVVM과 MVI 간의 원활한 통합을 제공하는 방법을 이 글에서 살펴보겠습니다.</p>\n<h1>MVC 대 MVI</h1>\n<p>결합된 방식에 대해 자세히 살펴보기 전에 먼저 MVC (Model-View-Controller)와 MVI의 핵심 원칙을 이해해 보겠습니다.</p>\n<h2>MVC란 무엇인가요?</h2>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>MVC 패턴에서 Model은 데이터와 비즈니스 로직을 나타내고, View는 UI를 렌더링하는 역할을 하며, Controller는 Model과 View 사이에서 중개자 역할을 하며, 사용자 입력을 처리하고 Model과 View를 업데이트합니다.</p>\n<p><img src=\"/assets/img/2024-06-22-ModernAndroidDevelopmentwithMVVMMVIandKotlinFlowsPart1_1.png\" alt=\"Image\"></p>\n<p>다음은 안드로이드에서 Model-View-Controller (MVC) 아키텍처를 구현하는 예시입니다:</p>\n<p>Model 파일 이름은 UserModel.kt:</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-kotlin\"><span class=\"hljs-keyword\">data</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">User</span>(<span class=\"hljs-keyword\">val</span> id: String, <span class=\"hljs-keyword\">val</span> name: String, <span class=\"hljs-keyword\">val</span> email: String)\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">UserModel</span> {\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">val</span> users: MutableList&#x3C;User> = mutableListOf()\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">addUser</span><span class=\"hljs-params\">(user: <span class=\"hljs-type\">User</span>)</span></span> {\n        users.add(user)\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">getUsers</span><span class=\"hljs-params\">()</span></span>: List&#x3C;User> {\n        <span class=\"hljs-keyword\">return</span> users.toList()\n    }\n}\n</code></pre>\n<p>UserModel 클래스는 Model을 나타내며 사용자 목록을 관리합니다.</p>\n<p>컨트롤러는 UserController.kt 입니다:</p>\n<pre><code class=\"hljs language-kotlin\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">UserController</span>(<span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">val</span> userView: UserView) {\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">val</span> userModel = UserModel()\n\n    <span class=\"hljs-comment\">// 모델 조작</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">addUser</span><span class=\"hljs-params\">(name: <span class=\"hljs-type\">String</span>, email: <span class=\"hljs-type\">String</span>)</span></span> {\n        <span class=\"hljs-keyword\">val</span> user = User(UUID.randomUUID().toString(), name, email)\n        userModel.addUser(user)\n\n        <span class=\"hljs-keyword\">val</span> users = userModel.getUsers()\n        updateView(users)\n    }\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">updateView</span><span class=\"hljs-params\">(users: <span class=\"hljs-type\">List</span>&#x3C;<span class=\"hljs-type\">User</span>>)</span></span> {\n        <span class=\"hljs-comment\">// 뷰에서 UI를 업데이트하는 적절한 메서드 호출</span>\n        userView.displayUsers(users)\n    }\n}\n</code></pre>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>The UserController 클래스는 Controller 역할을 하며 사용자 상호작용을 처리하고 Model을 업데이트합니다. 또한 Model의 변경 사항에 따라 UI를 업데이트하기 위해 View와 통신합니다.</p>\n<p>뷰는 MvcActivity.kt에서 제공됩니다:</p>\n<pre><code class=\"hljs language-js\">interface <span class=\"hljs-title class_\">UserView</span> {\n    fun <span class=\"hljs-title function_\">displayUsers</span>(<span class=\"hljs-attr\">users</span>: <span class=\"hljs-title class_\">List</span>&#x3C;<span class=\"hljs-title class_\">User</span>>)\n}\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MvcActivity</span> : <span class=\"hljs-title class_\">AppCompatActivity</span>(), <span class=\"hljs-title class_\">UserView</span> {\n    private lateinit <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">userAdapter</span>: <span class=\"hljs-title class_\">UserAdapter</span>\n    private lateinit <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">binding</span>: <span class=\"hljs-title class_\">ActivityMvcBinding</span>\n    private lateinit <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">controller</span>: <span class=\"hljs-title class_\">UserController</span>\n\n    override fun <span class=\"hljs-title function_\">onCreate</span>(<span class=\"hljs-params\">savedInstanceState: Bundle?</span>) {\n        <span class=\"hljs-variable language_\">super</span>.<span class=\"hljs-title function_\">onCreate</span>(savedInstanceState)\n        binding = <span class=\"hljs-title class_\">ActivityMvcBinding</span>.<span class=\"hljs-title function_\">inflate</span>(layoutInflater)\n        <span class=\"hljs-title function_\">setContentView</span>(binding.<span class=\"hljs-property\">root</span>)\n        <span class=\"hljs-title function_\">setupRecyclerView</span>()\n\n        <span class=\"hljs-comment\">// 컨트롤러 생성</span>\n        controller = <span class=\"hljs-title class_\">UserController</span>(<span class=\"hljs-variable language_\">this</span>)\n\n        binding.<span class=\"hljs-property\">addUserButton</span>.<span class=\"hljs-property\">setOnClickListener</span> {\n            val name = binding.<span class=\"hljs-property\">nameEditText</span>.<span class=\"hljs-property\">text</span>.<span class=\"hljs-title function_\">toString</span>()\n            val email = binding.<span class=\"hljs-property\">emailEditText</span>.<span class=\"hljs-property\">text</span>.<span class=\"hljs-title function_\">toString</span>()\n            <span class=\"hljs-comment\">// 사용자 입력 전송</span>\n            controller.<span class=\"hljs-title function_\">addUser</span>(name, email)\n        }\n    }\n\n    override fun <span class=\"hljs-title function_\">displayUsers</span>(<span class=\"hljs-params\">users: List&#x3C;User></span>) {\n        <span class=\"hljs-comment\">// 사용자 목록을 표시하기 위해 UI 업데이트</span>\n        userAdapter.<span class=\"hljs-title function_\">setUsers</span>(users)\n    }\n\n    private fun <span class=\"hljs-title function_\">setupRecyclerView</span>(<span class=\"hljs-params\"></span>) {\n        <span class=\"hljs-comment\">// 코드가 간결하게 유지될 수 있도록 주석 처리됨</span>\n    }\n}\n</code></pre>\n<p>MvcActivity 클래스는 View를 나타내며 UI를 표시하는 역할을 담당합니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h2>MVI란 무엇인가요?</h2>\n<p><img src=\"/assets/img/2024-06-22-ModernAndroidDevelopmentwithMVVMMVIandKotlinFlowsPart1_2.png\" alt=\"image\"></p>\n<p>MVI 패턴은 Model-View-Controller (MVC) 패턴의 변형으로 생각될 수 있습니다. Model-View-Intent (MVI)의 주요 아이디어는 사용자 인터페이스를 구축하기 위한 반응적이고 기능적 접근 방식을 제공하는 것입니다. 이는 Model-View-Controller (MVC) 아키텍처와 유사합니다.</p>\n<h2>MVI는 어떻게 작동하나요?</h2>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>MVI에서 기본 개념은 동일하지만 보다 반응적이고 기능적인 프로그래밍 스타일을 강조합니다. Model을 직접 변경하거나 View를 업데이트하는 대신, MVI는 사용자 의도를 불변의 데이터 구조 (Intents)로 캡처하고 단방향 데이터 흐름을 통해 이를 처리하는 데 초점을 맞춥니다. 이러한 흐름은 일반적으로 세 가지 주요 구성 요소로 구성됩니다:</p>\n<ul>\n<li>Model: 응용 프로그램의 현재 상태를 나타냅니다. Model은 변경할 수 없습니다. Model은 의도를 처리하고 Model의 새 버전을 생성함으로써 업데이트됩니다.</li>\n<li>View: 현재 Model 상태를 기반으로 UI를 렌더링하는 역할을 합니다. View는 수동적이며 Model이 변경될 때마다 업데이트를 수신합니다.</li>\n<li>Intent: 사용자 작업 또는 의도를 나타내며, View에서 Model을 업데이트하기 위해 전송됩니다. Intents는 사용자가 수행하려는 작업을 설명하는 일반적으로 간단한 데이터 구조입니다.</li>\n</ul>\n<p><img src=\"/assets/img/2024-06-22-ModernAndroidDevelopmentwithMVVMMVIandKotlinFlowsPart1_3.png\" alt=\"이미지\"></p>\n<p>MVI 패턴은 엄격한 단방향 데이터 흐름을 강제합니다. 데이터는 의도에서 모델로, 그리고 모델에서 뷰로 흐릅니다. 이렇게 하면 앱의 동작 및 상태에 대한 추론이 더 쉬워지며 구성 요소 간 부작용이나 종속성이 없기 때문에 유지보수가 쉽습니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h2>MVC에서 MVI로 변환하기:</h2>\n<p>위의 코드를 MVI 아키텍처로 어떻게 변경할 수 있는지 알아봅시다. 먼저 두 가지 추가 클래스를 추가해야 합니다. 뷰 내에서 사용자 관련 데이터의 현재 상태를 나타내는 UserViewState 클래스를 소개했습니다. UserIntent sealed 클래스는 사용자 의도를 나타내는 다양한 의도를 정의합니다. 예를 들어 사용자를 추가하는 것입니다.</p>\n<pre><code class=\"hljs language-js\">data <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">UserViewState</span>(val <span class=\"hljs-attr\">users</span>: <span class=\"hljs-title class_\">List</span>&#x3C;<span class=\"hljs-title class_\">User</span>>)\n\nsealed <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">UserIntent</span> {\n    data <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AddUser</span>(val <span class=\"hljs-attr\">name</span>: <span class=\"hljs-title class_\">String</span>, val <span class=\"hljs-attr\">email</span>: <span class=\"hljs-title class_\">String</span>) : <span class=\"hljs-title class_\">UserIntent</span>()\n    <span class=\"hljs-comment\">// GetUsers와 같은 다른 사용자 의도도 추가할 수 있습니다.</span>\n}\n</code></pre>\n<p>UserController와 UserView 인터페이스를 제거할 수 있습니다. 또한 UserModel 클래스를 변경하여 현재 뷰 상태를 유지하고 사용자 의도를 처리하며 사용자 상태를 업데이트할 수 있습니다. UserModel은 Kotlin Coroutines Flow를 사용하여 반응적일 수 있습니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">UserModel</span> {\n    <span class=\"hljs-comment\">// 애플리케이션의 현재 뷰 상태를 유지합니다</span>\n    private val <span class=\"hljs-attr\">_userViewState</span>: <span class=\"hljs-title class_\">MutableStateFlow</span>&#x3C;<span class=\"hljs-title class_\">UserViewState</span>> = <span class=\"hljs-title class_\">MutableStateFlow</span>(<span class=\"hljs-title class_\">UserViewState</span>(<span class=\"hljs-title function_\">emptyList</span>()))\n    <span class=\"hljs-comment\">// 다른 뷰들과 뷰 상태를 공유하여 핫 플로우로 제공합니다</span>\n    val userViewState = _userViewState.<span class=\"hljs-title function_\">asStateFlow</span>()\n\n    <span class=\"hljs-comment\">// processUserIntents에서 사용할 현재 뷰 상태를 얻습니다</span>\n    private fun <span class=\"hljs-title function_\">currentViewState</span>(): <span class=\"hljs-title class_\">UserViewState</span> {\n        <span class=\"hljs-keyword\">return</span> _userViewState.<span class=\"hljs-property\">value</span>\n    }\n\n    <span class=\"hljs-comment\">// 뷰로부터 사용자 의도를 처리합니다</span>\n    fun <span class=\"hljs-title function_\">processUserIntents</span>(<span class=\"hljs-params\">userIntent: UserIntent</span>) {\n        when (userIntent) {\n            is <span class=\"hljs-title class_\">UserIntent</span>.<span class=\"hljs-property\">AddUser</span> -> {\n                val user = <span class=\"hljs-title class_\">User</span>(<span class=\"hljs-variable constant_\">UUID</span>.<span class=\"hljs-title function_\">randomUUID</span>().<span class=\"hljs-title function_\">toString</span>(), userIntent.<span class=\"hljs-property\">name</span>, userIntent.<span class=\"hljs-property\">email</span>)\n                val newViewState = <span class=\"hljs-title function_\">currentViewState</span>().<span class=\"hljs-title function_\">copy</span>(users = <span class=\"hljs-title function_\">currentViewState</span>().<span class=\"hljs-property\">users</span> + user)\n                _userViewState.<span class=\"hljs-property\">value</span> = newViewState\n            }\n            <span class=\"hljs-comment\">/*\n            * 다른 사용자 의도(예: 사용자 목록 가져오기)도 여기서 처리할 수 있습니다\n            * */</span>\n        }\n    }\n}\n</code></pre>\n<p>userViewState는 사용자 뷰 상태를 핫 플로우로 공유합니다. 핫 플로우는 활성 구독자 여부와 관계없이 값을 방출합니다. 핫 플로우는 구독자 여부와 상관없이 계속 업데이트를 방출하는 공유 상태를 유지합니다. 새로운 구독자가 참여하면 최신 값 및 이후의 업데이트를 수신합니다. asStateFlow() 함수는 MutableSharedFlow를 StateFlow로 변환하며, 얻어진 StateFlow는 최신 값 유지 및 구독자 활동 여부에 관계없이 업데이트를 방출하는 핫 플로우로 간주될 수 있습니다.</p>\n<p>그리고 View 부분에 대한 변경사항은 다음과 같습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MviActivity</span> : <span class=\"hljs-title class_\">AppCompatActivity</span>() {\n    private lateinit <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">userAdapter</span>: <span class=\"hljs-title class_\">UserAdapter</span>\n    private lateinit <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">binding</span>: <span class=\"hljs-title class_\">ActivityMviBinding</span>\n    private val model = <span class=\"hljs-title class_\">UserModel</span>()\n\n    override fun <span class=\"hljs-title function_\">onCreate</span>(<span class=\"hljs-params\">savedInstanceState: Bundle?</span>) {\n        binding = <span class=\"hljs-title class_\">ActivityMviBinding</span>.<span class=\"hljs-title function_\">inflate</span>(layoutInflater)\n        <span class=\"hljs-title function_\">setContentView</span>(binding.<span class=\"hljs-property\">root</span>)\n        <span class=\"hljs-title function_\">setupRecyclerView</span>()\n\n        binding.<span class=\"hljs-property\">addUserButton</span>.<span class=\"hljs-property\">setOnClickListener</span> {\n            val name = binding.<span class=\"hljs-property\">nameEditText</span>.<span class=\"hljs-property\">text</span>.<span class=\"hljs-title function_\">toString</span>()\n            val email = binding.<span class=\"hljs-property\">emailEditText</span>.<span class=\"hljs-property\">text</span>.<span class=\"hljs-title function_\">toString</span>()\n\n            <span class=\"hljs-comment\">// 사용자 의도를 생성하고 모델에 전달합니다</span>\n            val userIntent = <span class=\"hljs-title class_\">UserIntent</span>.<span class=\"hljs-title class_\">AddUser</span>(name, email)\n            model.<span class=\"hljs-title function_\">processUserIntents</span>(userIntent)\n        }\n\n        <span class=\"hljs-comment\">// UI가 뷰 상태 변경을 관찰합니다</span>\n        model.<span class=\"hljs-property\">userViewState</span>\n            .<span class=\"hljs-property\">onEach</span> { userViewState ->\n                <span class=\"hljs-title function_\">renderUserViewState</span>(userViewState)\n            }\n            .<span class=\"hljs-title function_\">launchIn</span>(lifecycleScope)\n    }\n\n    private fun <span class=\"hljs-title function_\">renderUserViewState</span>(<span class=\"hljs-params\">userViewState: UserViewState</span>) {\n        <span class=\"hljs-comment\">// 사용자 목록을 표시하기 위해 UI를 업데이트합니다</span>\n        userAdapter.<span class=\"hljs-title function_\">setUsers</span>(userViewState.<span class=\"hljs-property\">users</span>)\n    }\n}\n</code></pre>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>MviActivity에서는 onEach를 사용하여 상태 플로우를 관찰하고 renderUserViewState()를 호출하여 UI를 업데이트합니다.</p>\n<p>수정된 코드로 다시 다이어그램을 살펴봅시다. 코드를 다이어그램의 각 부분에 매핑하는 방법을 살펴봅시다:</p>\n<p><img src=\"/assets/img/2024-06-22-ModernAndroidDevelopmentwithMVVMMVIandKotlinFlowsPart1_4.png\" alt=\"Diagram\"></p>\n<p>위 다이어그램에서 사용자는 OnClick 등의 액션을 트리거할 수 있습니다. 이러한 액션들은 인텐트로 파싱되어 모델에 전달될 수 있습니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>모델에서 processUserIntentsexecutes는 전달된 Intent에 기반한 로직을 실행하며, 이 경우 UserIntent.AddUser를 받아 새로운 상태를 생성합니다:</p>\n<pre><code class=\"hljs language-js\">val newViewState = <span class=\"hljs-title function_\">currentViewState</span>().<span class=\"hljs-title function_\">copy</span>(users = <span class=\"hljs-title function_\">currentViewState</span>().<span class=\"hljs-property\">users</span> + user)\n_userViewState.<span class=\"hljs-property\">value</span> = newViewState\n</code></pre>\n<p>copy()는 기존 객체와 동일한 속성을 가진 새 객체를 생성하는 Kotlin 함수입니다. 이 경우 currentViewState().copy()는 현재 뷰 상태와 동일한 속성을 가진 새 UserViewState 객체를 생성합니다.</p>\n<p>users = currentViewState().users + user 부분은 새로운 뷰 상태의 users 속성을 업데이트해야 함을 명시합니다. 요약하자면, 이 두 줄의 코드는 현재 뷰 상태의 복사본을 만들어 사용자 목록에 새로운 사용자가 추가된 새로운 뷰 상태 객체를 생성합니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>뷰 부분에서 새 상태가 생성될 때마다 MviActivity가 변경 사항을 observe합니다.</p>\n<pre><code class=\"hljs language-js\">model.<span class=\"hljs-property\">userViewState</span>\n  .<span class=\"hljs-property\">onEach</span> { userViewState ->\n      <span class=\"hljs-title function_\">renderUserViewState</span>(userViewState)\n  }\n  .<span class=\"hljs-title function_\">launchIn</span>(lifecycleScope)\n</code></pre>\n<p>그리고 renderUserViewState(userViewState)를 사용하여 사용자에게 상태를 표시합니다. 반응형 프로그래밍과 Kotlin Coroutine 플로우 덕분에 가능해졌습니다.</p>\n<h1>다음은 무엇인가요?</h1>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>다음 시리즈에서는 MVVM 아키텍처를 MVI와 비교하고 이러한 아키텍처를 더 깊이 파헤쳐 양쪽에서 최상의 결과를 얻을 수 있는 방법에 대해 살펴볼 것입니다. 기대해주세요!</p>\n</body>\n</html>\n"},"__N_SSG":true}