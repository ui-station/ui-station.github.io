{"pageProps":{"post":{"title":"LSTM 시계열 예측에서 흔히 발생하는 오류를 수정하는 방법","description":"","date":"2024-05-18 19:35","slug":"2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting","content":"\r\nLSTM을 시계열 예측에 사용할 때, 사람들은 흔히 범할 수 있는 함정에 빠지곤 합니다. 이를 설명하기 위해서는 회귀자와 예측자의 작동 방식을 살펴볼 필요가 있습니다. 예측 알고리즘은 시계열 데이터를 다루는 방법을 아래와 같이 보여줍니다:\r\n\r\n![How a forecasting algorithm works](/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_0.png)\r\n\r\n한편, 회귀 문제는 다음과 같이 보일 것입니다:\r\n\r\n![How a regression problem looks](/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_1.png)\r\n\r\n<!-- ui-station 사각형 -->\r\n\r\n<ins class=\"adsbygoogle\"\r\nstyle=\"display:block\"\r\ndata-ad-client=\"ca-pub-4877378276818686\"\r\ndata-ad-slot=\"7249294152\"\r\ndata-ad-format=\"auto\"\r\ndata-full-width-responsive=\"true\"></ins>\r\n\r\n<script>\r\n(adsbygoogle = window.adsbygoogle || []).push({});\r\n</script>\r\n\r\nLSTM이 회귀기이므로 시계열을 회귀 문제로 변환해야 합니다. 이를 수행하는 여러 방법이 있지만, 이 섹션에서는 창(Window) 및 다중 단계(Multi-Step) 방법에 대해 설명하고, 어떻게 작동하는지와 특히 이를 활용할 때 발생할 수 있는 일반적인 실수를 피하는 방법에 대해 논의할 것입니다.\r\n\r\n창 방법(Window Method)에서, 시계열은 이전 각 시간 단계의 값과 결합되어 창이라고 불리는 가상 특성으로 되어 있습니다. 여기서 창 크기가 3인 창이 있습니다:\r\n\r\n![창 방법 이미지](/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_2.png)\r\n\r\n다음 함수는 단일 시계열에서 창 방법 데이터 세트를 생성합니다. 사용자는 이전 값의 수(보통 look back이라고 함)를 선택해야 합니다. 결과 데이터 세트에는 대각선 반복이 있으며, look-back 값에 따라 샘플의 수가 달라집니다:\r\n\r\n<!-- ui-station 사각형 -->\r\n\r\n<ins class=\"adsbygoogle\"\r\nstyle=\"display:block\"\r\ndata-ad-client=\"ca-pub-4877378276818686\"\r\ndata-ad-slot=\"7249294152\"\r\ndata-ad-format=\"auto\"\r\ndata-full-width-responsive=\"true\"></ins>\r\n\r\n<script>\r\n(adsbygoogle = window.adsbygoogle || []).push({});\r\n</script>\r\n\r\n```js\r\ndef window(sequences, look_back):\r\n    X, y = [], []\r\n    for i in range(len(sequences)-look_back-1):\r\n        x = sequences[i:(i+look_back)]\r\n        X.append(x)\r\n        y.append(sequences[i + look_back])\r\n    return np.array(X), np.array(y)\r\n```\r\n\r\n이제 결과를 살펴보겠습니다. 모델을 훈련한 후에는 테스트 세트에서 테스트됩니다. 다양한 소스와 튜토리얼에서는 비슷한 방법을 사용하여 결과를 컴파일하는 것을 제안했습니다. 그러나 나중에 설명할 것처럼 이 방법은 신빙성이 없습니다. 그럼 지금은 코드와 결과가 어떻게 보이는지 살펴보겠습니다:\r\n\r\n```js\r\nlook_back = 3\r\nX, y = window(ts_data, look_back)\r\n\r\n# 훈련-테스트 분할\r\ntrain_ratio = 0.8\r\ntrain_size = int(train_ratio * len(ts_data))\r\nX_train, X_test = X[:train_size-look_back], X[train_size-look_back:]\r\ny_train, y_test = y[:train_size-look_back], y[train_size-look_back:]\r\n\r\n# LSTM 모델 생성 및 훈련\r\nmodel = Sequential()\r\nmodel.add(LSTM(units=72, activation='tanh', input_shape=(look_back, 1)))\r\nmodel.add(Dense(1))\r\nmodel.compile(loss='mean_squared_error', optimizer='Adam', metrics=['mape'])\r\n\r\nmodel.fit(x=X_train, y=y_train, epochs=500, batch_size=18, verbose=2)\r\n\r\n# 예측 생성\r\nforecasts = model.predict(X_test)\r\nlstm_fits = model.predict(X_train)\r\n\r\n# 메트릭스 계산\r\nmape = mean_absolute_percentage_error(y_test, forecasts)\r\nr2 = r2_score(y_train, lstm_fits)\r\n\r\n# 날짜 초기화\r\ndate_range = pd.date_range(start='1990-01-01', end='2023-09-30', freq='M')\r\n\r\n# 맞춤 값에 원래 시계열과 맞추기 위한 비어있는 값 추가\r\nfits = np.full(train_size, np.nan)\r\nfor i in range(train_size-look_back):\r\n    fits[i+look_back] = lstm_fits[i]\r\n\r\n# 실제값, 맞춤값, 예측값 플롯\r\nplt.figure(figsize=(10, 6))\r\nplt.plot(date_range, ts_data, label='Actual', color='blue')\r\nplt.plot(date_range[:train_size], fits, label='Fitted', color='green')\r\nplt.plot(date_range[train_size:], forecasts, label='Forecast', color='red')\r\nplt.title('FSC - Short - Passengers\\nOne Step Forward Forecast')\r\nplt.xlabel('Date')\r\nplt.ylabel('Passengers')\r\nplt.legend()\r\nplt.text(0.05, 0.05, f'R2 = {r2*100:.2f}%\\nMAPE = {mape*100:.2f}%', transform=plt.gca().transAxes, fontsize=12)\r\nplt.grid(True)\r\nplt.show()\r\n```\r\n\r\n<img src=\"/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_3.png\" />\r\n\r\n<!-- ui-station 사각형 -->\r\n\r\n<ins class=\"adsbygoogle\"\r\nstyle=\"display:block\"\r\ndata-ad-client=\"ca-pub-4877378276818686\"\r\ndata-ad-slot=\"7249294152\"\r\ndata-ad-format=\"auto\"\r\ndata-full-width-responsive=\"true\"></ins>\r\n\r\n<script>\r\n(adsbygoogle = window.adsbygoogle || []).push({});\r\n</script>\r\n\r\n문제: 결과는 훌륭해 보입니다. 그러나 샘플 테스트 세트를 살펴보면 특이한 결함이 보입니다:\r\n\r\n![이미지](/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_4.png)\r\n\r\n예를 들어 y9를 생성하는 데에는 y8이 입력으로 사용되었습니다. 훈련에는 사용되지 않았지만 미래 값을 포함하는 것은 이상합니다. 왜냐하면 우리는 미래의 시점을 예측하고 있기 때문입니다.\r\n\r\n해결책: 직접적으로 이전 값을 예측 값으로 대체하는 반복적 테스트 세트를 사용하면 이 문제를 해결할 수 있습니다. 이러한 배치 방식에서 모델은 자체 예측에 기반을 둔다. 일반적인 예측 알고리즘과 유사합니다.\r\n\r\n<!-- ui-station 사각형 -->\r\n\r\n<ins class=\"adsbygoogle\"\r\nstyle=\"display:block\"\r\ndata-ad-client=\"ca-pub-4877378276818686\"\r\ndata-ad-slot=\"7249294152\"\r\ndata-ad-format=\"auto\"\r\ndata-full-width-responsive=\"true\"></ins>\r\n\r\n<script>\r\n(adsbygoogle = window.adsbygoogle || []).push({});\r\n</script>\r\n\r\n아래 루프에서 다음을 수행합니다:\r\n\r\n```js\r\n# 반복적인 예측 및 대체\r\nfor i in range(len(X_test)):\r\n    forecasts[i] = model.predict(X_test[i].reshape(1, look_back, 1))\r\n    if i != len(X_test)-1:\r\n        X_test[i+1,look_back-1] = forecasts[i]\r\n        for j in range(look_back-1):\r\n            X_test[i+1,j] = X_test[i,j+1]\r\n```\r\n\r\n결과는 완벽하지는 않지만 적어도 정허하다고 할 수 있습니다:\r\n\r\n<!-- ui-station 사각형 -->\r\n\r\n<ins class=\"adsbygoogle\"\r\nstyle=\"display:block\"\r\ndata-ad-client=\"ca-pub-4877378276818686\"\r\ndata-ad-slot=\"7249294152\"\r\ndata-ad-format=\"auto\"\r\ndata-full-width-responsive=\"true\"></ins>\r\n\r\n<script>\r\n(adsbygoogle = window.adsbygoogle || []).push({});\r\n</script>\r\n\r\n<img src=\"/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_6.png\" />\r\n\r\n다중 단계 방법은 창 방법과 유사하지만 더 많은 대상 단계를 갖습니다. 다음은 두 개의 전방 단계의 샘플입니다:\r\n\r\n<img src=\"/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_7.png\" />\r\n\r\n사실, 이 방법에서 사용자는 n_steps_in과 n_steps_out을 선택해야 합니다. 다음 코드는 단순 시계열을 다중 단계 LSTM 훈련을 위해 준비된 데이터 세트로 변환합니다:\r\n\r\n<!-- ui-station 사각형 -->\r\n\r\n<ins class=\"adsbygoogle\"\r\nstyle=\"display:block\"\r\ndata-ad-client=\"ca-pub-4877378276818686\"\r\ndata-ad-slot=\"7249294152\"\r\ndata-ad-format=\"auto\"\r\ndata-full-width-responsive=\"true\"></ins>\r\n\r\n<script>\r\n(adsbygoogle = window.adsbygoogle || []).push({});\r\n</script>\r\n\r\n```js\r\n# 단변량 시퀀스를 다단계로 샘플링하기\r\ndef split_sequences(sequences, n_steps_in, n_steps_out):\r\n X, y = list(), list()\r\n for i in range(len(sequences)):\r\n     # 해당 패턴의 끝을 찾음\r\n     end_ix = i + n_steps_in\r\n     out_end_ix = end_ix + n_steps_out\r\n     # 시퀀스를 벗어나는지 확인\r\n     if out_end_ix > len(sequences):\r\n         break\r\n     # 패턴의 입력 및 출력 부분 수집\r\n     seq_x, seq_y = sequences[i:end_ix], sequences[end_ix:out_end_ix]\r\n     X.append(seq_x)\r\n     y.append(seq_y)\r\n return np.array(X), np.array(y)\r\n```\r\n\r\n이제, 특성 뿐만 아니라 타겟도 대각선 반복을 가지고 있어 시계열과 비교하려면 그들을 평균화하거나 예측 중 하나를 선택해야 합니다. 아래 코드에서는 첫 번째, 마지막 및 평균 예측의 결과가 생성되며, 그에 이어 플롯이 제시됩니다. 여기서 첫 번째 예측은 한 달 전 예측을 의미하며, 마지막 예측은 12개월 전 예측을 의미합니다.\r\n\r\n```js\r\nn_steps_in = 12\r\nn_steps_out = 12\r\n\r\nX, y = split_sequences(ts_data, n_steps_in, n_steps_out)\r\nX = X.reshape(X.shape[0], X.shape[1], 1)\r\ny = y.reshape(y.shape[0], y.shape[1], 1)\r\n\r\n# 훈련 및 테스트 세트 분리\r\ntrain_ratio = 0.8\r\ntrain_size = int(train_ratio * len(ts_data))\r\nX_train, X_test = X[:train_size-n_steps_in-n_steps_out+1], X[train_size-n_steps_in-n_steps_out+1:]\r\ny_train = y[:train_size-n_steps_in-n_steps_out+1]\r\ny_test = ts_data[train_size:]\r\n\r\n# LSTM 모델 생성 및 훈련\r\nmodel = Sequential()\r\nmodel.add(LSTM(units=72, activation='tanh', input_shape=(n_steps_in, 1)))\r\nmodel.add(Dense(units=n_steps_out))\r\nmodel.compile(loss='mean_squared_error', optimizer='Adam', metrics=['mape'])\r\n\r\nmodel.fit(x=X_train, y=y_train, epochs=500, batch_size=18, verbose=2)\r\n\r\n# 예측 생성\r\nlstm_predictions = model.predict(X_test)\r\nlstm_fitted = model.predict(X_train)\r\n\r\nforecasts = [np.diag(np.fliplr(lstm_predictions), i).mean() for i in range(0, -lstm_predictions.shape[0], -1)]\r\nfits = [np.diag(np.fliplr(lstm_fitted), i).mean() for i in range(lstm_fitted.shape[1]+n_steps_in - 1, -lstm_fitted.shape[0], -1)]\r\nforecasts1 = lstm_predictions[n_steps_out-1:,0]\r\nfits1 = model.predict(X)[:train_size-n_steps_in,0]\r\nforecasts12 = lstm_predictions[:,n_steps_out-1]\r\nfits12 = lstm_fitted[:,n_steps_out-1]\r\n\r\n# Metric\r\nav_mape = mean_absolute_percentage_error(y_test, forecasts)\r\nav_r2 = r2_score(ts_data[n_steps_in:train_size], fits[n_steps_in:])\r\none_mape = mean_absolute_percentage_error(y_test[:-n_steps_out+1], forecasts1)\r\none_r2 = r2_score(ts_data[n_steps_in:train_size], fits1)\r\ntwelve_mape = mean_absolute_percentage_error(y_test, forecasts12)\r\ntwelve_r2 = r2_score(ts_data[n_steps_in+n_steps_out-1:train_size], fits12)\r\n\r\ndate_range = pd.date_range(start='1990-01-01', end='2023-09-30', freq='M')\r\n\r\n# 실제, 적합 결과 및 예측을 플롯\r\nplt.figure(figsize=(10, 6))\r\nplt.plot(date_range, ts_data, label='Actual', color='blue')\r\nplt.plot(date_range[:train_size], fits, label='Fitted', color='green')\r\nplt.plot(date_range[train_size:], forecasts, label='Forecast', color='red')\r\nplt.title('FSC - Short - Passengers\\n. LSTM 12 Month Average Forecast')\r\nplt.xlabel('Date')\r\nplt.ylabel('Passengers')\r\nplt.legend()\r\nplt.text(0.05, 0.05, f'R2 = {av_r2*100:.2f}%\\nMAPE = {av_mape*100:.2f}%', transform=plt.gca().transAxes, fontsize=12)\r\nplt.grid(True)\r\nplt.show()\r\n\r\nplt.figure(figsize=(10, 6))\r\nplt.plot(date_range, ts_data, label='Actual', color='blue')\r\nplt.plot(date_range[n_steps_in:train_size], fits1, label='Fitted', color='green')\r\nplt.plot(date_range[train_size:-n_steps_out+1], forecasts1, label='Forecast', color='red')\r\nplt.title('FSC - Short - Passengers\\n LSTM 1 Month in advance Forecast')\r\nplt.xlabel('Date')\r\nplt.ylabel('Passengers')\r\nplt.legend()\r\nplt.text(0.05, 0.05, f'R2 = {one_r2*100:.2f}%\\nMAPE = {one_mape*100:.2f}%', transform=plt.gca().transAxes, fontsize=12)\r\nplt.grid(True)\r\nplt.show()\r\n\r\nplt.figure(figsize=(10, 6))\r\nplt.plot(date_range, ts_data, label='Actual', color='blue')\r\nplt.plot(date_range[n_steps_in+n_steps_out-1:train_size], fits12, label='Fitted', color='green')\r\nplt.plot(date_range[train_size:], forecasts12, label='Forecast', color='red')\r\nplt.title('FSC - Short - Passengers\\n LSTM 12 Months in advance Forecast')\r\nplt.xlabel('Date')\r\nplt.ylabel('Passengers')\r\nplt.legend()\r\nplt.text(0.05, 0.05, f'R2 = {twelve_r2*100:.2f}%\\nMAPE = {twelve_mape*100:.2f}%', transform=plt.gca().transAxes, fontsize=12)\r\nplt.grid(True)\r\nplt.show()\r\n```\r\n\r\n이슈: 창 메서드와 동일한 문제가 여기에도 있습니다:\r\n\r\n<!-- ui-station 사각형 -->\r\n\r\n<ins class=\"adsbygoogle\"\r\nstyle=\"display:block\"\r\ndata-ad-client=\"ca-pub-4877378276818686\"\r\ndata-ad-slot=\"7249294152\"\r\ndata-ad-format=\"auto\"\r\ndata-full-width-responsive=\"true\"></ins>\r\n\r\n<script>\r\n(adsbygoogle = window.adsbygoogle || []).push({});\r\n</script>\r\n\r\n![이미지](/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_8.png)\r\n\r\n해상도: 창 법과 비슷한 방법을 사용할 수 있습니다. 그러나 n_steps_out을 test_size와 동일하게 선택할 수도 있습니다. 이렇게 하면 테스트 세트가 하나로 축소됩니다:\r\n\r\n![이미지](/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_9.png)\r\n\r\n다음 함수는 이를 정확히 수행합니다. 이 함수는 시계열, 학습 크기 및 샘플 수를 사용합니다. 이 버전은 다른 예측 알고리즘과 비교할 수 있기 때문에 comparable로 이름 지었습니다:\r\n\r\n<!-- ui-station 사각형 -->\r\n\r\n<ins class=\"adsbygoogle\"\r\nstyle=\"display:block\"\r\ndata-ad-client=\"ca-pub-4877378276818686\"\r\ndata-ad-slot=\"7249294152\"\r\ndata-ad-format=\"auto\"\r\ndata-full-width-responsive=\"true\"></ins>\r\n\r\n<script>\r\n(adsbygoogle = window.adsbygoogle || []).push({});\r\n</script>\r\n\r\n```js\r\ndef split_sequences_comparable(sequences, n_samples, train_size):\r\n # 단계\r\n n_steps_out = len(sequences) - train_size\r\n n_steps_in = train_size - n_steps_out - n_samples + 1\r\n # 끝 세트\r\n X_test = sequences[n_samples + n_steps_out - 1:train_size]\r\n X_forecast = sequences[-n_steps_in:]\r\n X, y = list(), list()\r\n for i in range(n_samples):\r\n     # 이 패턴의 끝을 찾습니다\r\n     end_ix = i + n_steps_in\r\n     out_end_ix = end_ix + n_steps_out\r\n     # 패턴의 입력 및 출력 부분을 수집합니다\r\n     seq_x, seq_y = sequences[i:end_ix], sequences[end_ix:out_end_ix]\r\n     X.append(seq_x)\r\n     y.append(seq_y)\r\n return np.array(X), np.array(y), np.array(X_test), np.array(X_forecast), n_steps_in, n_steps_out\r\n```\r\n\r\n이 함수에서는 단계 수가 이미 고정되었기 때문에 샘플 수와 훈련 크기는 사용자가 선택하도록 하고, 최대 가능한 단계 수를 계산하도록 결정했습니다. 아래는 실행된 코드와 그 결과입니다:\r\n\r\n```js\r\nn_samples = 12\r\ntrain_size = 321\r\nX_train, y_train, X_test, X_forecast, n_steps_in, n_steps_out = split_sequences_comparable(ts_data, n_samples, train_size)\r\ny_test = ts_data[train_size:]\r\n\r\n# Reshaping\r\nX_train = X_train.reshape(X_train.shape[0], X_train.shape[1], 1)\r\nX_test = X_test.reshape(X_test.shape[1], X_test.shape[0], 1)\r\ny_train = y_train.reshape(y_train.shape[0], y_train.shape[1])\r\ny_test = y_test.reshape(y_test.shape[1], y_test.shape[0], 1)\r\n\r\n# LSTM 모델 생성 및 훈련\r\nmodel = Sequential()\r\nmodel.add(LSTM(units=154, activation='tanh', input_shape=(n_steps_in, 1)))\r\nmodel.add(Dense(units=n_steps_out))\r\nmodel.compile(loss='mean_squared_error', optimizer='Adam', metrics=['mape'])\r\n\r\nmodel.fit(x=X_train, y=y_train, epochs=500, batch_size=18, verbose=2)\r\n\r\n# 예측\r\nlstm_predictions = model.predict(X_test)\r\npredictions = lstm_predictions.reshape(lstm_predictions.shape[1])\r\nlstm_fitted = model.predict(X_train)\r\nfits = [np.diag(np.fliplr(lstm_fitted), i).mean() for i in range(lstm_fitted.shape[1]+n_steps_in - 1, -lstm_fitted.shape[0], -1)]\r\n\r\n# 메트릭스\r\nmape = mean_absolute_percentage_error(y_test, predictions)\r\nr2 = r2_score(ts_data[n_steps_in:train_size], fits[n_steps_in:])\r\n\r\n# 실제, 적합 및 예측 플롯\r\nplt.figure(figsize=(10, 6))\r\nplt.plot(date_range, ts_data, label='Actual', color='blue')\r\nplt.plot(date_range[:train_size], fits, label='Fitted', color='green')\r\nplt.plot(date_range[train_size:], predictions, label='Forecast', color='red')\r\nplt.title('FSC - Short - Passengers\\n12 Sample Comparable LSTM Forecast')\r\nplt.xlabel('Date')\r\nplt.ylabel('Passengers')\r\nplt.legend()\r\nplt.text(0.05, 0.05, f'R2 = {r2*100:.2f}%\\nMAPE = {mape*100:.2f}%\\', transform=plt.gca().transAxes, fontsize=12)\r\nplt.grid(True)\r\nplt.show()\r\n```\r\n\r\n<img src=\"/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_10.png\" />\r\n\r\n<!-- ui-station 사각형 -->\r\n\r\n<ins class=\"adsbygoogle\"\r\nstyle=\"display:block\"\r\ndata-ad-client=\"ca-pub-4877378276818686\"\r\ndata-ad-slot=\"7249294152\"\r\ndata-ad-format=\"auto\"\r\ndata-full-width-responsive=\"true\"></ins>\r\n\r\n<script>\r\n(adsbygoogle = window.adsbygoogle || []).push({});\r\n</script>\r\n\r\n지금까지 우리가 얻은 결과는 가장 신뢰할만한 것입니다. 그러나 제가 개발한 혁신적인 방법을 사용하면 더 나은 결과를 얻을 수 있습니다. 이 방법은 나중에 시리즈에서 (순환 방법) 자세히 설명하겠습니다. 먼저 LSTM 네트워크의 하이퍼파라미터를 조정하는 방법에 대해 설명하겠습니다.\r\n\r\nLSTM은 모든 시간 단계를 특성으로 집계하기 때문에 시계열 데이터가 모든 이러한 방법에서 손실됩니다. 나중에 시리즈에서 (인코더/디코더 방법) 시계열 입력의 구조를 유지하는 다른 방법을 사용할 것입니다.\r\n\r\n계속 주목해 주세요!\r\n","ogImage":{"url":"/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_0.png"},"coverImage":"/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_0.png","tag":["Tech"],"readingTime":15},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p>LSTM을 시계열 예측에 사용할 때, 사람들은 흔히 범할 수 있는 함정에 빠지곤 합니다. 이를 설명하기 위해서는 회귀자와 예측자의 작동 방식을 살펴볼 필요가 있습니다. 예측 알고리즘은 시계열 데이터를 다루는 방법을 아래와 같이 보여줍니다:</p>\n<p><img src=\"/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_0.png\" alt=\"How a forecasting algorithm works\"></p>\n<p>한편, 회귀 문제는 다음과 같이 보일 것입니다:</p>\n<p><img src=\"/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_1.png\" alt=\"How a regression problem looks\"></p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>LSTM이 회귀기이므로 시계열을 회귀 문제로 변환해야 합니다. 이를 수행하는 여러 방법이 있지만, 이 섹션에서는 창(Window) 및 다중 단계(Multi-Step) 방법에 대해 설명하고, 어떻게 작동하는지와 특히 이를 활용할 때 발생할 수 있는 일반적인 실수를 피하는 방법에 대해 논의할 것입니다.</p>\n<p>창 방법(Window Method)에서, 시계열은 이전 각 시간 단계의 값과 결합되어 창이라고 불리는 가상 특성으로 되어 있습니다. 여기서 창 크기가 3인 창이 있습니다:</p>\n<p><img src=\"/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_2.png\" alt=\"창 방법 이미지\"></p>\n<p>다음 함수는 단일 시계열에서 창 방법 데이터 세트를 생성합니다. 사용자는 이전 값의 수(보통 look back이라고 함)를 선택해야 합니다. 결과 데이터 세트에는 대각선 반복이 있으며, look-back 값에 따라 샘플의 수가 달라집니다:</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-js\">def <span class=\"hljs-title function_\">window</span>(sequences, look_back):\r\n    X, y = [], []\r\n    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-title function_\">range</span>(<span class=\"hljs-title function_\">len</span>(sequences)-look_back-<span class=\"hljs-number\">1</span>):\r\n        x = sequences[<span class=\"hljs-attr\">i</span>:(i+look_back)]\r\n        X.<span class=\"hljs-title function_\">append</span>(x)\r\n        y.<span class=\"hljs-title function_\">append</span>(sequences[i + look_back])\r\n    <span class=\"hljs-keyword\">return</span> np.<span class=\"hljs-title function_\">array</span>(X), np.<span class=\"hljs-title function_\">array</span>(y)\n</code></pre>\n<p>이제 결과를 살펴보겠습니다. 모델을 훈련한 후에는 테스트 세트에서 테스트됩니다. 다양한 소스와 튜토리얼에서는 비슷한 방법을 사용하여 결과를 컴파일하는 것을 제안했습니다. 그러나 나중에 설명할 것처럼 이 방법은 신빙성이 없습니다. 그럼 지금은 코드와 결과가 어떻게 보이는지 살펴보겠습니다:</p>\n<pre><code class=\"hljs language-js\">look_back = <span class=\"hljs-number\">3</span>\r\nX, y = <span class=\"hljs-title function_\">window</span>(ts_data, look_back)\r\n\r\n# 훈련-테스트 분할\r\ntrain_ratio = <span class=\"hljs-number\">0.8</span>\r\ntrain_size = <span class=\"hljs-title function_\">int</span>(train_ratio * <span class=\"hljs-title function_\">len</span>(ts_data))\r\nX_train, X_test = X[:train_size-look_back], X[train_size-<span class=\"hljs-attr\">look_back</span>:]\r\ny_train, y_test = y[:train_size-look_back], y[train_size-<span class=\"hljs-attr\">look_back</span>:]\r\n\r\n# <span class=\"hljs-variable constant_\">LSTM</span> 모델 생성 및 훈련\r\nmodel = <span class=\"hljs-title class_\">Sequential</span>()\r\nmodel.<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-title function_\">LSTM</span>(units=<span class=\"hljs-number\">72</span>, activation=<span class=\"hljs-string\">'tanh'</span>, input_shape=(look_back, <span class=\"hljs-number\">1</span>)))\r\nmodel.<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-title class_\">Dense</span>(<span class=\"hljs-number\">1</span>))\r\nmodel.<span class=\"hljs-title function_\">compile</span>(loss=<span class=\"hljs-string\">'mean_squared_error'</span>, optimizer=<span class=\"hljs-string\">'Adam'</span>, metrics=[<span class=\"hljs-string\">'mape'</span>])\r\n\r\nmodel.<span class=\"hljs-title function_\">fit</span>(x=X_train, y=y_train, epochs=<span class=\"hljs-number\">500</span>, batch_size=<span class=\"hljs-number\">18</span>, verbose=<span class=\"hljs-number\">2</span>)\r\n\r\n# 예측 생성\r\nforecasts = model.<span class=\"hljs-title function_\">predict</span>(X_test)\r\nlstm_fits = model.<span class=\"hljs-title function_\">predict</span>(X_train)\r\n\r\n# 메트릭스 계산\r\nmape = <span class=\"hljs-title function_\">mean_absolute_percentage_error</span>(y_test, forecasts)\r\nr2 = <span class=\"hljs-title function_\">r2_score</span>(y_train, lstm_fits)\r\n\r\n# 날짜 초기화\r\ndate_range = pd.<span class=\"hljs-title function_\">date_range</span>(start=<span class=\"hljs-string\">'1990-01-01'</span>, end=<span class=\"hljs-string\">'2023-09-30'</span>, freq=<span class=\"hljs-string\">'M'</span>)\r\n\r\n# 맞춤 값에 원래 시계열과 맞추기 위한 비어있는 값 추가\r\nfits = np.<span class=\"hljs-title function_\">full</span>(train_size, np.<span class=\"hljs-property\">nan</span>)\r\n<span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-title function_\">range</span>(train_size-look_back):\r\n    fits[i+look_back] = lstm_fits[i]\r\n\r\n# 실제값, 맞춤값, 예측값 플롯\r\nplt.<span class=\"hljs-title function_\">figure</span>(figsize=(<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">6</span>))\r\nplt.<span class=\"hljs-title function_\">plot</span>(date_range, ts_data, label=<span class=\"hljs-string\">'Actual'</span>, color=<span class=\"hljs-string\">'blue'</span>)\r\nplt.<span class=\"hljs-title function_\">plot</span>(date_range[:train_size], fits, label=<span class=\"hljs-string\">'Fitted'</span>, color=<span class=\"hljs-string\">'green'</span>)\r\nplt.<span class=\"hljs-title function_\">plot</span>(date_range[<span class=\"hljs-attr\">train_size</span>:], forecasts, label=<span class=\"hljs-string\">'Forecast'</span>, color=<span class=\"hljs-string\">'red'</span>)\r\nplt.<span class=\"hljs-title function_\">title</span>(<span class=\"hljs-string\">'FSC - Short - Passengers\\nOne Step Forward Forecast'</span>)\r\nplt.<span class=\"hljs-title function_\">xlabel</span>(<span class=\"hljs-string\">'Date'</span>)\r\nplt.<span class=\"hljs-title function_\">ylabel</span>(<span class=\"hljs-string\">'Passengers'</span>)\r\nplt.<span class=\"hljs-title function_\">legend</span>()\r\nplt.<span class=\"hljs-title function_\">text</span>(<span class=\"hljs-number\">0.05</span>, <span class=\"hljs-number\">0.05</span>, f<span class=\"hljs-string\">'R2 = {r2*100:.2f}%\\nMAPE = {mape*100:.2f}%'</span>, transform=plt.<span class=\"hljs-title function_\">gca</span>().<span class=\"hljs-property\">transAxes</span>, fontsize=<span class=\"hljs-number\">12</span>)\r\nplt.<span class=\"hljs-title function_\">grid</span>(<span class=\"hljs-title class_\">True</span>)\r\nplt.<span class=\"hljs-title function_\">show</span>()\n</code></pre>\n<img src=\"/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_3.png\">\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>문제: 결과는 훌륭해 보입니다. 그러나 샘플 테스트 세트를 살펴보면 특이한 결함이 보입니다:</p>\n<p><img src=\"/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_4.png\" alt=\"이미지\"></p>\n<p>예를 들어 y9를 생성하는 데에는 y8이 입력으로 사용되었습니다. 훈련에는 사용되지 않았지만 미래 값을 포함하는 것은 이상합니다. 왜냐하면 우리는 미래의 시점을 예측하고 있기 때문입니다.</p>\n<p>해결책: 직접적으로 이전 값을 예측 값으로 대체하는 반복적 테스트 세트를 사용하면 이 문제를 해결할 수 있습니다. 이러한 배치 방식에서 모델은 자체 예측에 기반을 둔다. 일반적인 예측 알고리즘과 유사합니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>아래 루프에서 다음을 수행합니다:</p>\n<pre><code class=\"hljs language-js\"># 반복적인 예측 및 대체\r\n<span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-title function_\">range</span>(<span class=\"hljs-title function_\">len</span>(X_test)):\r\n    forecasts[i] = model.<span class=\"hljs-title function_\">predict</span>(X_test[i].<span class=\"hljs-title function_\">reshape</span>(<span class=\"hljs-number\">1</span>, look_back, <span class=\"hljs-number\">1</span>))\r\n    <span class=\"hljs-keyword\">if</span> i != <span class=\"hljs-title function_\">len</span>(X_test)-<span class=\"hljs-number\">1</span>:\r\n        X_test[i+<span class=\"hljs-number\">1</span>,look_back-<span class=\"hljs-number\">1</span>] = forecasts[i]\r\n        <span class=\"hljs-keyword\">for</span> j <span class=\"hljs-keyword\">in</span> <span class=\"hljs-title function_\">range</span>(look_back-<span class=\"hljs-number\">1</span>):\r\n            X_test[i+<span class=\"hljs-number\">1</span>,j] = X_test[i,j+<span class=\"hljs-number\">1</span>]\n</code></pre>\n<p>결과는 완벽하지는 않지만 적어도 정허하다고 할 수 있습니다:</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<img src=\"/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_6.png\">\n<p>다중 단계 방법은 창 방법과 유사하지만 더 많은 대상 단계를 갖습니다. 다음은 두 개의 전방 단계의 샘플입니다:</p>\n<img src=\"/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_7.png\">\n<p>사실, 이 방법에서 사용자는 n_steps_in과 n_steps_out을 선택해야 합니다. 다음 코드는 단순 시계열을 다중 단계 LSTM 훈련을 위해 준비된 데이터 세트로 변환합니다:</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-js\"># 단변량 시퀀스를 다단계로 샘플링하기\r\ndef <span class=\"hljs-title function_\">split_sequences</span>(sequences, n_steps_in, n_steps_out):\r\n X, y = <span class=\"hljs-title function_\">list</span>(), <span class=\"hljs-title function_\">list</span>()\r\n <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-title function_\">range</span>(<span class=\"hljs-title function_\">len</span>(sequences)):\r\n     # 해당 패턴의 끝을 찾음\r\n     end_ix = i + n_steps_in\r\n     out_end_ix = end_ix + n_steps_out\r\n     # 시퀀스를 벗어나는지 확인\r\n     <span class=\"hljs-keyword\">if</span> out_end_ix > <span class=\"hljs-title function_\">len</span>(sequences):\r\n         <span class=\"hljs-keyword\">break</span>\r\n     # 패턴의 입력 및 출력 부분 수집\r\n     seq_x, seq_y = sequences[<span class=\"hljs-attr\">i</span>:end_ix], sequences[<span class=\"hljs-attr\">end_ix</span>:out_end_ix]\r\n     X.<span class=\"hljs-title function_\">append</span>(seq_x)\r\n     y.<span class=\"hljs-title function_\">append</span>(seq_y)\r\n <span class=\"hljs-keyword\">return</span> np.<span class=\"hljs-title function_\">array</span>(X), np.<span class=\"hljs-title function_\">array</span>(y)\n</code></pre>\n<p>이제, 특성 뿐만 아니라 타겟도 대각선 반복을 가지고 있어 시계열과 비교하려면 그들을 평균화하거나 예측 중 하나를 선택해야 합니다. 아래 코드에서는 첫 번째, 마지막 및 평균 예측의 결과가 생성되며, 그에 이어 플롯이 제시됩니다. 여기서 첫 번째 예측은 한 달 전 예측을 의미하며, 마지막 예측은 12개월 전 예측을 의미합니다.</p>\n<pre><code class=\"hljs language-js\">n_steps_in = <span class=\"hljs-number\">12</span>\r\nn_steps_out = <span class=\"hljs-number\">12</span>\r\n\r\nX, y = <span class=\"hljs-title function_\">split_sequences</span>(ts_data, n_steps_in, n_steps_out)\r\nX = X.<span class=\"hljs-title function_\">reshape</span>(X.<span class=\"hljs-property\">shape</span>[<span class=\"hljs-number\">0</span>], X.<span class=\"hljs-property\">shape</span>[<span class=\"hljs-number\">1</span>], <span class=\"hljs-number\">1</span>)\r\ny = y.<span class=\"hljs-title function_\">reshape</span>(y.<span class=\"hljs-property\">shape</span>[<span class=\"hljs-number\">0</span>], y.<span class=\"hljs-property\">shape</span>[<span class=\"hljs-number\">1</span>], <span class=\"hljs-number\">1</span>)\r\n\r\n# 훈련 및 테스트 세트 분리\r\ntrain_ratio = <span class=\"hljs-number\">0.8</span>\r\ntrain_size = <span class=\"hljs-title function_\">int</span>(train_ratio * <span class=\"hljs-title function_\">len</span>(ts_data))\r\nX_train, X_test = X[:train_size-n_steps_in-n_steps_out+<span class=\"hljs-number\">1</span>], X[train_size-n_steps_in-n_steps_out+<span class=\"hljs-number\">1</span>:]\r\ny_train = y[:train_size-n_steps_in-n_steps_out+<span class=\"hljs-number\">1</span>]\r\ny_test = ts_data[<span class=\"hljs-attr\">train_size</span>:]\r\n\r\n# <span class=\"hljs-variable constant_\">LSTM</span> 모델 생성 및 훈련\r\nmodel = <span class=\"hljs-title class_\">Sequential</span>()\r\nmodel.<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-title function_\">LSTM</span>(units=<span class=\"hljs-number\">72</span>, activation=<span class=\"hljs-string\">'tanh'</span>, input_shape=(n_steps_in, <span class=\"hljs-number\">1</span>)))\r\nmodel.<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-title class_\">Dense</span>(units=n_steps_out))\r\nmodel.<span class=\"hljs-title function_\">compile</span>(loss=<span class=\"hljs-string\">'mean_squared_error'</span>, optimizer=<span class=\"hljs-string\">'Adam'</span>, metrics=[<span class=\"hljs-string\">'mape'</span>])\r\n\r\nmodel.<span class=\"hljs-title function_\">fit</span>(x=X_train, y=y_train, epochs=<span class=\"hljs-number\">500</span>, batch_size=<span class=\"hljs-number\">18</span>, verbose=<span class=\"hljs-number\">2</span>)\r\n\r\n# 예측 생성\r\nlstm_predictions = model.<span class=\"hljs-title function_\">predict</span>(X_test)\r\nlstm_fitted = model.<span class=\"hljs-title function_\">predict</span>(X_train)\r\n\r\nforecasts = [np.<span class=\"hljs-title function_\">diag</span>(np.<span class=\"hljs-title function_\">fliplr</span>(lstm_predictions), i).<span class=\"hljs-title function_\">mean</span>() <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-title function_\">range</span>(<span class=\"hljs-number\">0</span>, -lstm_predictions.<span class=\"hljs-property\">shape</span>[<span class=\"hljs-number\">0</span>], -<span class=\"hljs-number\">1</span>)]\r\nfits = [np.<span class=\"hljs-title function_\">diag</span>(np.<span class=\"hljs-title function_\">fliplr</span>(lstm_fitted), i).<span class=\"hljs-title function_\">mean</span>() <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-title function_\">range</span>(lstm_fitted.<span class=\"hljs-property\">shape</span>[<span class=\"hljs-number\">1</span>]+n_steps_in - <span class=\"hljs-number\">1</span>, -lstm_fitted.<span class=\"hljs-property\">shape</span>[<span class=\"hljs-number\">0</span>], -<span class=\"hljs-number\">1</span>)]\r\nforecasts1 = lstm_predictions[n_steps_out-<span class=\"hljs-number\">1</span>:,<span class=\"hljs-number\">0</span>]\r\nfits1 = model.<span class=\"hljs-title function_\">predict</span>(X)[:train_size-n_steps_in,<span class=\"hljs-number\">0</span>]\r\nforecasts12 = lstm_predictions[:,n_steps_out-<span class=\"hljs-number\">1</span>]\r\nfits12 = lstm_fitted[:,n_steps_out-<span class=\"hljs-number\">1</span>]\r\n\r\n# <span class=\"hljs-title class_\">Metric</span>\r\nav_mape = <span class=\"hljs-title function_\">mean_absolute_percentage_error</span>(y_test, forecasts)\r\nav_r2 = <span class=\"hljs-title function_\">r2_score</span>(ts_data[<span class=\"hljs-attr\">n_steps_in</span>:train_size], fits[<span class=\"hljs-attr\">n_steps_in</span>:])\r\none_mape = <span class=\"hljs-title function_\">mean_absolute_percentage_error</span>(y_test[:-n_steps_out+<span class=\"hljs-number\">1</span>], forecasts1)\r\none_r2 = <span class=\"hljs-title function_\">r2_score</span>(ts_data[<span class=\"hljs-attr\">n_steps_in</span>:train_size], fits1)\r\ntwelve_mape = <span class=\"hljs-title function_\">mean_absolute_percentage_error</span>(y_test, forecasts12)\r\ntwelve_r2 = <span class=\"hljs-title function_\">r2_score</span>(ts_data[n_steps_in+n_steps_out-<span class=\"hljs-number\">1</span>:train_size], fits12)\r\n\r\ndate_range = pd.<span class=\"hljs-title function_\">date_range</span>(start=<span class=\"hljs-string\">'1990-01-01'</span>, end=<span class=\"hljs-string\">'2023-09-30'</span>, freq=<span class=\"hljs-string\">'M'</span>)\r\n\r\n# 실제, 적합 결과 및 예측을 플롯\r\nplt.<span class=\"hljs-title function_\">figure</span>(figsize=(<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">6</span>))\r\nplt.<span class=\"hljs-title function_\">plot</span>(date_range, ts_data, label=<span class=\"hljs-string\">'Actual'</span>, color=<span class=\"hljs-string\">'blue'</span>)\r\nplt.<span class=\"hljs-title function_\">plot</span>(date_range[:train_size], fits, label=<span class=\"hljs-string\">'Fitted'</span>, color=<span class=\"hljs-string\">'green'</span>)\r\nplt.<span class=\"hljs-title function_\">plot</span>(date_range[<span class=\"hljs-attr\">train_size</span>:], forecasts, label=<span class=\"hljs-string\">'Forecast'</span>, color=<span class=\"hljs-string\">'red'</span>)\r\nplt.<span class=\"hljs-title function_\">title</span>(<span class=\"hljs-string\">'FSC - Short - Passengers\\n. LSTM 12 Month Average Forecast'</span>)\r\nplt.<span class=\"hljs-title function_\">xlabel</span>(<span class=\"hljs-string\">'Date'</span>)\r\nplt.<span class=\"hljs-title function_\">ylabel</span>(<span class=\"hljs-string\">'Passengers'</span>)\r\nplt.<span class=\"hljs-title function_\">legend</span>()\r\nplt.<span class=\"hljs-title function_\">text</span>(<span class=\"hljs-number\">0.05</span>, <span class=\"hljs-number\">0.05</span>, f<span class=\"hljs-string\">'R2 = {av_r2*100:.2f}%\\nMAPE = {av_mape*100:.2f}%'</span>, transform=plt.<span class=\"hljs-title function_\">gca</span>().<span class=\"hljs-property\">transAxes</span>, fontsize=<span class=\"hljs-number\">12</span>)\r\nplt.<span class=\"hljs-title function_\">grid</span>(<span class=\"hljs-title class_\">True</span>)\r\nplt.<span class=\"hljs-title function_\">show</span>()\r\n\r\nplt.<span class=\"hljs-title function_\">figure</span>(figsize=(<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">6</span>))\r\nplt.<span class=\"hljs-title function_\">plot</span>(date_range, ts_data, label=<span class=\"hljs-string\">'Actual'</span>, color=<span class=\"hljs-string\">'blue'</span>)\r\nplt.<span class=\"hljs-title function_\">plot</span>(date_range[<span class=\"hljs-attr\">n_steps_in</span>:train_size], fits1, label=<span class=\"hljs-string\">'Fitted'</span>, color=<span class=\"hljs-string\">'green'</span>)\r\nplt.<span class=\"hljs-title function_\">plot</span>(date_range[<span class=\"hljs-attr\">train_size</span>:-n_steps_out+<span class=\"hljs-number\">1</span>], forecasts1, label=<span class=\"hljs-string\">'Forecast'</span>, color=<span class=\"hljs-string\">'red'</span>)\r\nplt.<span class=\"hljs-title function_\">title</span>(<span class=\"hljs-string\">'FSC - Short - Passengers\\n LSTM 1 Month in advance Forecast'</span>)\r\nplt.<span class=\"hljs-title function_\">xlabel</span>(<span class=\"hljs-string\">'Date'</span>)\r\nplt.<span class=\"hljs-title function_\">ylabel</span>(<span class=\"hljs-string\">'Passengers'</span>)\r\nplt.<span class=\"hljs-title function_\">legend</span>()\r\nplt.<span class=\"hljs-title function_\">text</span>(<span class=\"hljs-number\">0.05</span>, <span class=\"hljs-number\">0.05</span>, f<span class=\"hljs-string\">'R2 = {one_r2*100:.2f}%\\nMAPE = {one_mape*100:.2f}%'</span>, transform=plt.<span class=\"hljs-title function_\">gca</span>().<span class=\"hljs-property\">transAxes</span>, fontsize=<span class=\"hljs-number\">12</span>)\r\nplt.<span class=\"hljs-title function_\">grid</span>(<span class=\"hljs-title class_\">True</span>)\r\nplt.<span class=\"hljs-title function_\">show</span>()\r\n\r\nplt.<span class=\"hljs-title function_\">figure</span>(figsize=(<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">6</span>))\r\nplt.<span class=\"hljs-title function_\">plot</span>(date_range, ts_data, label=<span class=\"hljs-string\">'Actual'</span>, color=<span class=\"hljs-string\">'blue'</span>)\r\nplt.<span class=\"hljs-title function_\">plot</span>(date_range[n_steps_in+n_steps_out-<span class=\"hljs-number\">1</span>:train_size], fits12, label=<span class=\"hljs-string\">'Fitted'</span>, color=<span class=\"hljs-string\">'green'</span>)\r\nplt.<span class=\"hljs-title function_\">plot</span>(date_range[<span class=\"hljs-attr\">train_size</span>:], forecasts12, label=<span class=\"hljs-string\">'Forecast'</span>, color=<span class=\"hljs-string\">'red'</span>)\r\nplt.<span class=\"hljs-title function_\">title</span>(<span class=\"hljs-string\">'FSC - Short - Passengers\\n LSTM 12 Months in advance Forecast'</span>)\r\nplt.<span class=\"hljs-title function_\">xlabel</span>(<span class=\"hljs-string\">'Date'</span>)\r\nplt.<span class=\"hljs-title function_\">ylabel</span>(<span class=\"hljs-string\">'Passengers'</span>)\r\nplt.<span class=\"hljs-title function_\">legend</span>()\r\nplt.<span class=\"hljs-title function_\">text</span>(<span class=\"hljs-number\">0.05</span>, <span class=\"hljs-number\">0.05</span>, f<span class=\"hljs-string\">'R2 = {twelve_r2*100:.2f}%\\nMAPE = {twelve_mape*100:.2f}%'</span>, transform=plt.<span class=\"hljs-title function_\">gca</span>().<span class=\"hljs-property\">transAxes</span>, fontsize=<span class=\"hljs-number\">12</span>)\r\nplt.<span class=\"hljs-title function_\">grid</span>(<span class=\"hljs-title class_\">True</span>)\r\nplt.<span class=\"hljs-title function_\">show</span>()\n</code></pre>\n<p>이슈: 창 메서드와 동일한 문제가 여기에도 있습니다:</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p><img src=\"/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_8.png\" alt=\"이미지\"></p>\n<p>해상도: 창 법과 비슷한 방법을 사용할 수 있습니다. 그러나 n_steps_out을 test_size와 동일하게 선택할 수도 있습니다. 이렇게 하면 테스트 세트가 하나로 축소됩니다:</p>\n<p><img src=\"/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_9.png\" alt=\"이미지\"></p>\n<p>다음 함수는 이를 정확히 수행합니다. 이 함수는 시계열, 학습 크기 및 샘플 수를 사용합니다. 이 버전은 다른 예측 알고리즘과 비교할 수 있기 때문에 comparable로 이름 지었습니다:</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-js\">def <span class=\"hljs-title function_\">split_sequences_comparable</span>(sequences, n_samples, train_size):\r\n # 단계\r\n n_steps_out = <span class=\"hljs-title function_\">len</span>(sequences) - train_size\r\n n_steps_in = train_size - n_steps_out - n_samples + <span class=\"hljs-number\">1</span>\r\n # 끝 세트\r\n X_test = sequences[n_samples + n_steps_out - <span class=\"hljs-number\">1</span>:train_size]\r\n X_forecast = sequences[-<span class=\"hljs-attr\">n_steps_in</span>:]\r\n X, y = <span class=\"hljs-title function_\">list</span>(), <span class=\"hljs-title function_\">list</span>()\r\n <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-title function_\">range</span>(n_samples):\r\n     # 이 패턴의 끝을 찾습니다\r\n     end_ix = i + n_steps_in\r\n     out_end_ix = end_ix + n_steps_out\r\n     # 패턴의 입력 및 출력 부분을 수집합니다\r\n     seq_x, seq_y = sequences[<span class=\"hljs-attr\">i</span>:end_ix], sequences[<span class=\"hljs-attr\">end_ix</span>:out_end_ix]\r\n     X.<span class=\"hljs-title function_\">append</span>(seq_x)\r\n     y.<span class=\"hljs-title function_\">append</span>(seq_y)\r\n <span class=\"hljs-keyword\">return</span> np.<span class=\"hljs-title function_\">array</span>(X), np.<span class=\"hljs-title function_\">array</span>(y), np.<span class=\"hljs-title function_\">array</span>(X_test), np.<span class=\"hljs-title function_\">array</span>(X_forecast), n_steps_in, n_steps_out\n</code></pre>\n<p>이 함수에서는 단계 수가 이미 고정되었기 때문에 샘플 수와 훈련 크기는 사용자가 선택하도록 하고, 최대 가능한 단계 수를 계산하도록 결정했습니다. 아래는 실행된 코드와 그 결과입니다:</p>\n<pre><code class=\"hljs language-js\">n_samples = <span class=\"hljs-number\">12</span>\r\ntrain_size = <span class=\"hljs-number\">321</span>\r\nX_train, y_train, X_test, X_forecast, n_steps_in, n_steps_out = <span class=\"hljs-title function_\">split_sequences_comparable</span>(ts_data, n_samples, train_size)\r\ny_test = ts_data[<span class=\"hljs-attr\">train_size</span>:]\r\n\r\n# <span class=\"hljs-title class_\">Reshaping</span>\r\nX_train = X_train.<span class=\"hljs-title function_\">reshape</span>(X_train.<span class=\"hljs-property\">shape</span>[<span class=\"hljs-number\">0</span>], X_train.<span class=\"hljs-property\">shape</span>[<span class=\"hljs-number\">1</span>], <span class=\"hljs-number\">1</span>)\r\nX_test = X_test.<span class=\"hljs-title function_\">reshape</span>(X_test.<span class=\"hljs-property\">shape</span>[<span class=\"hljs-number\">1</span>], X_test.<span class=\"hljs-property\">shape</span>[<span class=\"hljs-number\">0</span>], <span class=\"hljs-number\">1</span>)\r\ny_train = y_train.<span class=\"hljs-title function_\">reshape</span>(y_train.<span class=\"hljs-property\">shape</span>[<span class=\"hljs-number\">0</span>], y_train.<span class=\"hljs-property\">shape</span>[<span class=\"hljs-number\">1</span>])\r\ny_test = y_test.<span class=\"hljs-title function_\">reshape</span>(y_test.<span class=\"hljs-property\">shape</span>[<span class=\"hljs-number\">1</span>], y_test.<span class=\"hljs-property\">shape</span>[<span class=\"hljs-number\">0</span>], <span class=\"hljs-number\">1</span>)\r\n\r\n# <span class=\"hljs-variable constant_\">LSTM</span> 모델 생성 및 훈련\r\nmodel = <span class=\"hljs-title class_\">Sequential</span>()\r\nmodel.<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-title function_\">LSTM</span>(units=<span class=\"hljs-number\">154</span>, activation=<span class=\"hljs-string\">'tanh'</span>, input_shape=(n_steps_in, <span class=\"hljs-number\">1</span>)))\r\nmodel.<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-title class_\">Dense</span>(units=n_steps_out))\r\nmodel.<span class=\"hljs-title function_\">compile</span>(loss=<span class=\"hljs-string\">'mean_squared_error'</span>, optimizer=<span class=\"hljs-string\">'Adam'</span>, metrics=[<span class=\"hljs-string\">'mape'</span>])\r\n\r\nmodel.<span class=\"hljs-title function_\">fit</span>(x=X_train, y=y_train, epochs=<span class=\"hljs-number\">500</span>, batch_size=<span class=\"hljs-number\">18</span>, verbose=<span class=\"hljs-number\">2</span>)\r\n\r\n# 예측\r\nlstm_predictions = model.<span class=\"hljs-title function_\">predict</span>(X_test)\r\npredictions = lstm_predictions.<span class=\"hljs-title function_\">reshape</span>(lstm_predictions.<span class=\"hljs-property\">shape</span>[<span class=\"hljs-number\">1</span>])\r\nlstm_fitted = model.<span class=\"hljs-title function_\">predict</span>(X_train)\r\nfits = [np.<span class=\"hljs-title function_\">diag</span>(np.<span class=\"hljs-title function_\">fliplr</span>(lstm_fitted), i).<span class=\"hljs-title function_\">mean</span>() <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-title function_\">range</span>(lstm_fitted.<span class=\"hljs-property\">shape</span>[<span class=\"hljs-number\">1</span>]+n_steps_in - <span class=\"hljs-number\">1</span>, -lstm_fitted.<span class=\"hljs-property\">shape</span>[<span class=\"hljs-number\">0</span>], -<span class=\"hljs-number\">1</span>)]\r\n\r\n# 메트릭스\r\nmape = <span class=\"hljs-title function_\">mean_absolute_percentage_error</span>(y_test, predictions)\r\nr2 = <span class=\"hljs-title function_\">r2_score</span>(ts_data[<span class=\"hljs-attr\">n_steps_in</span>:train_size], fits[<span class=\"hljs-attr\">n_steps_in</span>:])\r\n\r\n# 실제, 적합 및 예측 플롯\r\nplt.<span class=\"hljs-title function_\">figure</span>(figsize=(<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">6</span>))\r\nplt.<span class=\"hljs-title function_\">plot</span>(date_range, ts_data, label=<span class=\"hljs-string\">'Actual'</span>, color=<span class=\"hljs-string\">'blue'</span>)\r\nplt.<span class=\"hljs-title function_\">plot</span>(date_range[:train_size], fits, label=<span class=\"hljs-string\">'Fitted'</span>, color=<span class=\"hljs-string\">'green'</span>)\r\nplt.<span class=\"hljs-title function_\">plot</span>(date_range[<span class=\"hljs-attr\">train_size</span>:], predictions, label=<span class=\"hljs-string\">'Forecast'</span>, color=<span class=\"hljs-string\">'red'</span>)\r\nplt.<span class=\"hljs-title function_\">title</span>(<span class=\"hljs-string\">'FSC - Short - Passengers\\n12 Sample Comparable LSTM Forecast'</span>)\r\nplt.<span class=\"hljs-title function_\">xlabel</span>(<span class=\"hljs-string\">'Date'</span>)\r\nplt.<span class=\"hljs-title function_\">ylabel</span>(<span class=\"hljs-string\">'Passengers'</span>)\r\nplt.<span class=\"hljs-title function_\">legend</span>()\r\nplt.<span class=\"hljs-title function_\">text</span>(<span class=\"hljs-number\">0.05</span>, <span class=\"hljs-number\">0.05</span>, f<span class=\"hljs-string\">'R2 = {r2*100:.2f}%\\nMAPE = {mape*100:.2f}%\\', transform=plt.gca().transAxes, fontsize=12)\r\nplt.grid(True)\r\nplt.show()\n</span></code></pre>\n<img src=\"/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_10.png\">\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>지금까지 우리가 얻은 결과는 가장 신뢰할만한 것입니다. 그러나 제가 개발한 혁신적인 방법을 사용하면 더 나은 결과를 얻을 수 있습니다. 이 방법은 나중에 시리즈에서 (순환 방법) 자세히 설명하겠습니다. 먼저 LSTM 네트워크의 하이퍼파라미터를 조정하는 방법에 대해 설명하겠습니다.</p>\n<p>LSTM은 모든 시간 단계를 특성으로 집계하기 때문에 시계열 데이터가 모든 이러한 방법에서 손실됩니다. 나중에 시리즈에서 (인코더/디코더 방법) 시계열 입력의 구조를 유지하는 다른 방법을 사용할 것입니다.</p>\n<p>계속 주목해 주세요!</p>\n</body>\n</html>\n"},"__N_SSG":true}