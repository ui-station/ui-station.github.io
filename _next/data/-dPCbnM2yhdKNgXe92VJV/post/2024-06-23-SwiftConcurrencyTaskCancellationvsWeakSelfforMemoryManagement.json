{"pageProps":{"post":{"title":"Swift 동시성 메모리 관리에서 Task Cancellation과 Weak Self의 비교","description":"","date":"2024-06-23 21:25","slug":"2024-06-23-SwiftConcurrencyTaskCancellationvsWeakSelfforMemoryManagement","content":"\n![Image](/assets/img/2024-06-23-SwiftConcurrencyTaskCancellationvsWeakSelfforMemoryManagement_0.png)\n\nSwift 개발에 관련해서, 메모리 관리를 이해하는 것은 복잡한 퍼즐을 해결하는 것과 같습니다. 이러한 퍼즐의 핵심에는 클로저와 비동기 작업을 처리하는 동안 메모리 누수에 빠지지 않는 것이라는 도전이 있습니다. 많은 개발자들이 리테인 싸이클을 피하는 데 사용해온 약한 참조(weak self) 개념은 클로저에서 탁월한 해결책이었습니다. 하지만 Swift의 동시성 모델, 특히 Task에서 이 실천이 원활하게 이어지는지 궁금할 것입니다. 실용적인 코드 예제와 통찰을 통해, 효율적인 Swift 프로그래밍을 위한 길을 밝혀보겠습니다.\n\n# 다루는 주제\n\n- 클로저에서 왜 weak self가 필요하며, 사용하지 않으면 어떻게 되는지?\n- Task 블록에서도 실제로 weak self가 필요한가?\n- Swift 동시성을 사용할 때 리테인 싸이클을 피하기 위해 어떤 조치를 취할 수 있는가?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 주요 포인트\n\n- 클로저에서의 순환 참조와 약한 self 사용의 중요성을 이해하세요.\n- 비동기 작업이 self를 강하게 캡처하면 작업 블록도 순환 참조를 생성할 수 있습니다.\n- 컴파일러는 클로저와 달리 작업 블록에서 명시적 self 사용을 요구하지 않습니다.\n- 약한 self에만 의존하지 않고 메모리를 효율적으로 관리할 대안으로 작업 취소를 사용할 수 있습니다.\n- 비동기 작업을 다룰 때 ViewModel에서 순환 참조를 방지하기 위해 작업 취소를 구현하세요.\n\n# 클로저에서의 'Weak Self' 딜레마\n\n약한 self의 필요성을 이해하려면 먼저 Swift에서 클로저의 세계로 들어가 보겠습니다. 클로저는 참조 타입이며 강하게 인스턴스(예: self)를 캡처하고 유지할 수 있습니다. 이로 인해 잠재적인 순환 참조가 발생할 수 있습니다. 이는 객체가 self를 참조하는 클로저를 소유하고, 그 클로저가 객체 자체에 의해 소유되는 경우 발생하여 서로 해제될 수 없는 루프를 만듭니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n전통적인 시나리오:\n\n```swift\nclass Repository {\n    func remoteAPICallWithClosure(onComplete: @escaping (String) -> Void) {\n        DispatchQueue.main.asyncAfter(deadline: .now() + 4) {\n            onComplete(\"완료\")\n        }\n    }\n}\n\nclass SomeBigViewModel {\n    private let repository = Repository()\n    private var result = \"\"\n\n    func doSomethingWithClosure() {\n        repository.remoteAPICallWithClosure { apiResult in\n            self.result = apiResult\n        }\n    }\n}\n```\n\n이제 SomeBigViewModel의 인스턴스를 생성하고 doSomethingWithClosure을 호출한 후에 해당 인스턴스를 해제하려고 시도합니다:\n\n```swift\nvar vm: SomeBigViewModel? = SomeBigViewModel()\nvm?.doSomethingWithClosure()\nvm = nil\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n작업이 시작됩니다. 그러나 deint print 문은 즉시 나타나지 않을 것입니다. 이는 유지 주기(순환 참조)를 나타냅니다:\n\n```js\n작업이 시작됨\n```\n\n## 주기(순환 참조) 파괴하기\n\n우리의 클로저에서 [weak self]를 사용하여 유지 주기를 피하고 SomeBigViewModel이 해제되도록 할 수 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nfunc doSomethingWithClosure() {\n    print(\"작업이 시작되었습니다.\")\n    repository.remoteAPICallWithClosure { [weak self] apiResult in\n        guard let self = self else { return }\n        self.result = apiResult\n        print(\"API 결과를 받았습니다.\")\n    }\n}\n```\n\n코드를 수정하고 다시 실행한 후, 출력 결과는 예상대로 `deinit`이 호출되어 순환 참조가 해제된다는 것을 확인합니다:\n\n```js\n작업이 시작되었습니다.\nSomeBigViewModel이 해제되고 있습니다.\n```\n\n# Swift의 병행성 모델: Task와의 사례\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nSwift의 동시성 모델 소개로 Task에 대한 유사한 질문이 제기됩니다: 여전히 순환 참조를 방지하기 위해 weak self를 사용해야 할까요?\n\n다음 비동기 작업을 고려해보세요.\n\n```swift\nfunc doSomething() {\n    print(\"비동기 작업 시작됨\")\n    Task {\n        do {\n            let result = try await repository.remoteAPICall()\n        } catch {\n            print(error)\n        }\n    }\n}\n```\n\n여기서 weak self를 사용하지 않으면, `Task`이 `self`을 강하게 캡처하면서 인스턴스가 작업이 완료되기 전에 해제되어야 하는 순환 참조가 발생합니다. 클로저와는 달리, 컴파일러는 여기서 명시적인 `self` 사용을 요구하지 않기 때문에 weak self이 모든 비동기 작업에서 필수적인지에 대한 의문이 생깁니다. 놀랍게도, 대안 전략으로 작업 취소라는 것이 있기 때문에 weak self가 모든 비동기 작업에서 꼭 필요하지는 않습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 작업 취소: 전략적 접근\n\n모든 비동기 작업에 일반적으로 `weak self`를 적용하는 대신 개발자들은 작업 취소를 더 적절한 전략으로 생각할 수 있습니다. 작업이 더 이상 필요하지 않을 때 해당 작업을 취소함으로써 `self`를 직접 관리하지 않고도 잠재적인 유지 사이클을 방지할 수 있습니다.\n\n## 작업 취소 단순화:\n\n```swift\npublic extension Task {\n    func store(in set: inout Set<AnyCancellable>) {\n        set.insert(AnyCancellable(cancel))\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 확장 프로그램은 작업 수명주기 관리를 간소화하여 집단 작업 취소를 용이하게 합니다.\n\n## ViewModel에서 작업 취소 활용:\n\n```js\n@MainActor\nclass SomeBigViewModel {\n    private let repository = Repository()\n    private var cancellableBag = Set<AnyCancellable>()\n\n    deinit {\n        print(\"deinit called\")\n    }\n\n    func send(_ action: Action) {\n        switch action {\n            case .viewWillDisappear:\n                cancellableBag.removeAll()\n        }\n    }\n\n    private func doSomething() {\n        print(\"async operation started\")\n        Task {\n            do {\n                let result = try await repository.remoteAPICall()\n            } catch {\n                print(error)\n            }\n        }\n        .store(in: &cancellableBag)\n    }\n}\n```\n\n작업 취소를 사용하면 ViewModel이 해제될 때 작업도 취소되어 명시적으로 `weak self`를 사용하지 않아도 보존 사이클을 방지합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n비동기 작업이 시작되었습니다\nSomeBigViewModel이 해제 중입니다\n```\n\n더 섬세한 작업 취소 제어를 원하는 개발자를 위해 다음 패턴을 적용할 수 있습니다:\n\n이 접근 방식을 사용하면 비동기 작업의 ViewModel 관리가 보다 구조적이고 효율적으로 되며, 기본적으로 약한 self에 의존하는 것보다 전략적인 작업 취소로서 보류 중인 사이클을 피할 수 있습니다.\n\n이 기사를 즐겼다면, Medium에 Clap으로 사랑을 보여주시고 의견을 자유롭게 공유해주세요. 이와 유사한 통찰력을 얻고 싶다면, Medium에서 저를 팔로우하고 LinkedIn 및 Twitter에서 저와 연락하십시오. 함께 더 많은 기술 토론에 참여해 봅시다!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nMedium | LinkedIn | Twitter\n","ogImage":{"url":"/assets/img/2024-06-23-SwiftConcurrencyTaskCancellationvsWeakSelfforMemoryManagement_0.png"},"coverImage":"/assets/img/2024-06-23-SwiftConcurrencyTaskCancellationvsWeakSelfforMemoryManagement_0.png","tag":["Tech"],"readingTime":7},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p><img src=\"/assets/img/2024-06-23-SwiftConcurrencyTaskCancellationvsWeakSelfforMemoryManagement_0.png\" alt=\"Image\"></p>\n<p>Swift 개발에 관련해서, 메모리 관리를 이해하는 것은 복잡한 퍼즐을 해결하는 것과 같습니다. 이러한 퍼즐의 핵심에는 클로저와 비동기 작업을 처리하는 동안 메모리 누수에 빠지지 않는 것이라는 도전이 있습니다. 많은 개발자들이 리테인 싸이클을 피하는 데 사용해온 약한 참조(weak self) 개념은 클로저에서 탁월한 해결책이었습니다. 하지만 Swift의 동시성 모델, 특히 Task에서 이 실천이 원활하게 이어지는지 궁금할 것입니다. 실용적인 코드 예제와 통찰을 통해, 효율적인 Swift 프로그래밍을 위한 길을 밝혀보겠습니다.</p>\n<h1>다루는 주제</h1>\n<ul>\n<li>클로저에서 왜 weak self가 필요하며, 사용하지 않으면 어떻게 되는지?</li>\n<li>Task 블록에서도 실제로 weak self가 필요한가?</li>\n<li>Swift 동시성을 사용할 때 리테인 싸이클을 피하기 위해 어떤 조치를 취할 수 있는가?</li>\n</ul>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h1>주요 포인트</h1>\n<ul>\n<li>클로저에서의 순환 참조와 약한 self 사용의 중요성을 이해하세요.</li>\n<li>비동기 작업이 self를 강하게 캡처하면 작업 블록도 순환 참조를 생성할 수 있습니다.</li>\n<li>컴파일러는 클로저와 달리 작업 블록에서 명시적 self 사용을 요구하지 않습니다.</li>\n<li>약한 self에만 의존하지 않고 메모리를 효율적으로 관리할 대안으로 작업 취소를 사용할 수 있습니다.</li>\n<li>비동기 작업을 다룰 때 ViewModel에서 순환 참조를 방지하기 위해 작업 취소를 구현하세요.</li>\n</ul>\n<h1>클로저에서의 'Weak Self' 딜레마</h1>\n<p>약한 self의 필요성을 이해하려면 먼저 Swift에서 클로저의 세계로 들어가 보겠습니다. 클로저는 참조 타입이며 강하게 인스턴스(예: self)를 캡처하고 유지할 수 있습니다. 이로 인해 잠재적인 순환 참조가 발생할 수 있습니다. 이는 객체가 self를 참조하는 클로저를 소유하고, 그 클로저가 객체 자체에 의해 소유되는 경우 발생하여 서로 해제될 수 없는 루프를 만듭니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>전통적인 시나리오:</p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Repository</span> {\n    <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">remoteAPICallWithClosure</span>(<span class=\"hljs-params\">onComplete</span>: <span class=\"hljs-keyword\">@escaping</span> (<span class=\"hljs-type\">String</span>) -> <span class=\"hljs-type\">Void</span>) {\n        <span class=\"hljs-type\">DispatchQueue</span>.main.asyncAfter(deadline: .now() <span class=\"hljs-operator\">+</span> <span class=\"hljs-number\">4</span>) {\n            onComplete(<span class=\"hljs-string\">\"완료\"</span>)\n        }\n    }\n}\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SomeBigViewModel</span> {\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">let</span> repository <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">Repository</span>()\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> result <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">\"\"</span>\n\n    <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">doSomethingWithClosure</span>() {\n        repository.remoteAPICallWithClosure { apiResult <span class=\"hljs-keyword\">in</span>\n            <span class=\"hljs-keyword\">self</span>.result <span class=\"hljs-operator\">=</span> apiResult\n        }\n    }\n}\n</code></pre>\n<p>이제 SomeBigViewModel의 인스턴스를 생성하고 doSomethingWithClosure을 호출한 후에 해당 인스턴스를 해제하려고 시도합니다:</p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-keyword\">var</span> vm: <span class=\"hljs-type\">SomeBigViewModel</span>? <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">SomeBigViewModel</span>()\nvm<span class=\"hljs-operator\">?</span>.doSomethingWithClosure()\nvm <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">nil</span>\n</code></pre>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>작업이 시작됩니다. 그러나 deint print 문은 즉시 나타나지 않을 것입니다. 이는 유지 주기(순환 참조)를 나타냅니다:</p>\n<pre><code class=\"hljs language-js\">작업이 시작됨\n</code></pre>\n<h2>주기(순환 참조) 파괴하기</h2>\n<p>우리의 클로저에서 [weak self]를 사용하여 유지 주기를 피하고 SomeBigViewModel이 해제되도록 할 수 있습니다:</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-js\">func <span class=\"hljs-title function_\">doSomethingWithClosure</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">\"작업이 시작되었습니다.\"</span>)\n    repository.<span class=\"hljs-property\">remoteAPICallWithClosure</span> { [weak self] apiResult <span class=\"hljs-keyword\">in</span>\n        guard <span class=\"hljs-keyword\">let</span> self = self <span class=\"hljs-keyword\">else</span> { <span class=\"hljs-keyword\">return</span> }\n        self.<span class=\"hljs-property\">result</span> = apiResult\n        <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">\"API 결과를 받았습니다.\"</span>)\n    }\n}\n</code></pre>\n<p>코드를 수정하고 다시 실행한 후, 출력 결과는 예상대로 <code>deinit</code>이 호출되어 순환 참조가 해제된다는 것을 확인합니다:</p>\n<pre><code class=\"hljs language-js\">작업이 시작되었습니다.\n<span class=\"hljs-title class_\">SomeBigViewModel</span>이 해제되고 있습니다.\n</code></pre>\n<h1>Swift의 병행성 모델: Task와의 사례</h1>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>Swift의 동시성 모델 소개로 Task에 대한 유사한 질문이 제기됩니다: 여전히 순환 참조를 방지하기 위해 weak self를 사용해야 할까요?</p>\n<p>다음 비동기 작업을 고려해보세요.</p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">doSomething</span>() {\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"비동기 작업 시작됨\"</span>)\n    <span class=\"hljs-type\">Task</span> {\n        <span class=\"hljs-keyword\">do</span> {\n            <span class=\"hljs-keyword\">let</span> result <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">try</span> <span class=\"hljs-keyword\">await</span> repository.remoteAPICall()\n        } <span class=\"hljs-keyword\">catch</span> {\n            <span class=\"hljs-built_in\">print</span>(error)\n        }\n    }\n}\n</code></pre>\n<p>여기서 weak self를 사용하지 않으면, <code>Task</code>이 <code>self</code>을 강하게 캡처하면서 인스턴스가 작업이 완료되기 전에 해제되어야 하는 순환 참조가 발생합니다. 클로저와는 달리, 컴파일러는 여기서 명시적인 <code>self</code> 사용을 요구하지 않기 때문에 weak self이 모든 비동기 작업에서 필수적인지에 대한 의문이 생깁니다. 놀랍게도, 대안 전략으로 작업 취소라는 것이 있기 때문에 weak self가 모든 비동기 작업에서 꼭 필요하지는 않습니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h1>작업 취소: 전략적 접근</h1>\n<p>모든 비동기 작업에 일반적으로 <code>weak self</code>를 적용하는 대신 개발자들은 작업 취소를 더 적절한 전략으로 생각할 수 있습니다. 작업이 더 이상 필요하지 않을 때 해당 작업을 취소함으로써 <code>self</code>를 직접 관리하지 않고도 잠재적인 유지 사이클을 방지할 수 있습니다.</p>\n<h2>작업 취소 단순화:</h2>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">extension</span> <span class=\"hljs-title class_\">Task</span> {\n    <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">store</span>(<span class=\"hljs-params\">in</span> <span class=\"hljs-params\">set</span>: <span class=\"hljs-keyword\">inout</span> <span class=\"hljs-type\">Set</span>&#x3C;<span class=\"hljs-type\">AnyCancellable</span>>) {\n        <span class=\"hljs-keyword\">set</span>.insert(<span class=\"hljs-type\">AnyCancellable</span>(cancel))\n    }\n}\n</code></pre>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>이 확장 프로그램은 작업 수명주기 관리를 간소화하여 집단 작업 취소를 용이하게 합니다.</p>\n<h2>ViewModel에서 작업 취소 활용:</h2>\n<pre><code class=\"hljs language-js\">@<span class=\"hljs-title class_\">MainActor</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SomeBigViewModel</span> {\n    private <span class=\"hljs-keyword\">let</span> repository = <span class=\"hljs-title class_\">Repository</span>()\n    private <span class=\"hljs-keyword\">var</span> cancellableBag = <span class=\"hljs-title class_\">Set</span>&#x3C;<span class=\"hljs-title class_\">AnyCancellable</span>>()\n\n    deinit {\n        <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">\"deinit called\"</span>)\n    }\n\n    func <span class=\"hljs-title function_\">send</span>(<span class=\"hljs-params\">_ action: Action</span>) {\n        <span class=\"hljs-keyword\">switch</span> action {\n            <span class=\"hljs-keyword\">case</span> .<span class=\"hljs-property\">viewWillDisappear</span>:\n                cancellableBag.<span class=\"hljs-title function_\">removeAll</span>()\n        }\n    }\n\n    private func <span class=\"hljs-title function_\">doSomething</span>(<span class=\"hljs-params\"></span>) {\n        <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">\"async operation started\"</span>)\n        <span class=\"hljs-title class_\">Task</span> {\n            <span class=\"hljs-keyword\">do</span> {\n                <span class=\"hljs-keyword\">let</span> result = <span class=\"hljs-keyword\">try</span> <span class=\"hljs-keyword\">await</span> repository.<span class=\"hljs-title function_\">remoteAPICall</span>()\n            } <span class=\"hljs-keyword\">catch</span> {\n                <span class=\"hljs-title function_\">print</span>(error)\n            }\n        }\n        .<span class=\"hljs-title function_\">store</span>(<span class=\"hljs-attr\">in</span>: &#x26;cancellableBag)\n    }\n}\n</code></pre>\n<p>작업 취소를 사용하면 ViewModel이 해제될 때 작업도 취소되어 명시적으로 <code>weak self</code>를 사용하지 않아도 보존 사이클을 방지합니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-js\">비동기 작업이 시작되었습니다\n<span class=\"hljs-title class_\">SomeBigViewModel</span>이 해제 중입니다\n</code></pre>\n<p>더 섬세한 작업 취소 제어를 원하는 개발자를 위해 다음 패턴을 적용할 수 있습니다:</p>\n<p>이 접근 방식을 사용하면 비동기 작업의 ViewModel 관리가 보다 구조적이고 효율적으로 되며, 기본적으로 약한 self에 의존하는 것보다 전략적인 작업 취소로서 보류 중인 사이클을 피할 수 있습니다.</p>\n<p>이 기사를 즐겼다면, Medium에 Clap으로 사랑을 보여주시고 의견을 자유롭게 공유해주세요. 이와 유사한 통찰력을 얻고 싶다면, Medium에서 저를 팔로우하고 LinkedIn 및 Twitter에서 저와 연락하십시오. 함께 더 많은 기술 토론에 참여해 봅시다!</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>Medium | LinkedIn | Twitter</p>\n</body>\n</html>\n"},"__N_SSG":true}