{"pageProps":{"post":{"title":"테라폼을 이용한 AWS 인프라 배포와 앤서블을 이용한 구성 설정","description":"","date":"2024-06-19 13:24","slug":"2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible","content":"\n# 소개:\n\n현재의 동적 클라우드 컴퓨팅 환경에서는 인프라 프로비저닝을 자동화하는 것이 확장성, 신뢰성, 및 비용 효율성을 원하는 기관들에게 필수적입니다. Terraform은 오픈 소스 인프라 코드 도구로, 선언적 구성 파일을 사용하여 인프라를 정의하고 관리할 수 있도록 팀에게 권한을 부여합니다. 이 블로그에서는 Terraform이 AWS 인프라 구성 요소의 배포를 체계적이고 효율적으로 간소화하는 방법을 탐색해보겠습니다.\n\n# 프로젝트 개요:\n\n우리 Terraform 프로젝트는 가상 사설 클라우드(VPC), 보안 그룹, Amazon Machine Image(AMI), Elastic Block Store(EBS) 볼륨, 및 EC2 인스턴스로 구성된 AWS 인프라 스택의 배포를 자동화하는 데 초점을 맞춥니다. Terraform의 모듈식이자 반복 가능한 구성을 활용하여 환경 간 일관성과 신뢰성을 보장하고, 수동 개입과 인적 오류를 최소화합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 상세 단계:\n\n## 1. AWS CLI 설치하기:\n\n- 먼저 로컬 컴퓨터에 AWS CLI를 설치해야 합니다.\n- 다음 링크를 따라 AWS CLI를 설치하세요:\n\n![AWS CLI 설치 링크](/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_0.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- AWS CLI를 이곳에서 다운로드하여 계정에 구성하세요.\n- 또는 Linux 버전을 선택하여 설치할 수도 있습니다.\n- 이를 위해 계정에 IAM 사용자를 만들어야 합니다.\n\n![이미지1](/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_1.png)\n\n![이미지2](/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_2.png)\n\n- 현재는 관리자 액세스를 제공하지만 좋은 실천 방법은 아닙니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_3.png](/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_3.png)\n\n![2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_4.png](/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_4.png)\n\n- 보안 자격 증명에서 \"액세스 키 생성\" 옵션을 클릭하여 액세스 키 및 비밀 키를 생성하고 둘 다 복사합니다.\n\n![2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_5.png](/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_5.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- Access Key ID에 액세스 키를 붙여 넣고, Secret Access Key ID에 비밀 키를 입력해주세요. 그리고 설정하고 싶은 기본 지역도 지정해주세요.\n\n## 2. Terraform 초기화하기.\n\n- main.tf 파일을 생성하고, 제공자(provider) 구성을 거기에 입력해주세요.\n\n```js\n# main.tf\n\n# Provider configuration\nprovider \"aws\" {\n  region = \"us-west-1\"\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 그럼 아래 명령어를 입력해주세요.\n\n```js\nterraform.exe init\n```\n\n## 3. VPC 생성:\n\n우리는 VPC 구성을 정의합니다. CIDR 블록을 포함하여 네트워크 구조의 기반을 마련합니다. 이는 AWS 환경 내에서 격리되고 안전한 통신을 제공합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 이 프로젝트 전체에 대해 동일한 main.tf 파일을 사용할 것입니다.\n\n```js\n# main.tf\n\nresource \"aws_vpc\" \"vpc\"{\n        cidr_block = \"192.168.0.0/16\"\n\n        tags = {\n                Name = \"Terraform_VPC\"\n        }\n}\n```\n\n## 4. 서브넷 생성:\n\n- 이제 서브넷 구성을 정의합니다. 이 구성에는 공용 서브넷과 사설 서브넷이 모두 포함됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n# main.tf\n\n변수 \"aws_azs\"를 정의합니다. 여기에는 public 서브넷의 가용 영역이 저장됩니다. 그리고 public 서브넷의 CIDR 블록을 저장하는 다른 변수를 만듭니다.\n\n그런 다음 각 가용 영역에 2개의 public 서브넷을 만듭니다.\n- length 함수는 주어진 목록, 맵 또는 문자열의 길이를 결정합니다. 목록이나 맵이 주어지면 해당 컬렉션의 요소 수가 결과로 나옵니다.\n- element() 함수는 목록에서 특정 인덱스의 요소를 검색합니다. 사용 사례: 목록에서 특정 요소에 액세스하는 것은 해당 인덱스를 기준으로 목록에서 특정 리소스나 매개변수를 선택하려고 할 때 유용합니다.\n- count.index 객체는 count 내의 현재 인스턴스의 인덱스를 나타냅니다. 인덱스는 0부터 시작하며, count가 4인 리소스가 있으면 count.index 객체는 0, 1, 2 및 3이 됩니다.\n- 그런 다음 private 서브넷을 만드는 동일한 단계를 반복합니다.\n\n## 5. Internet-Gateway 및 Route-table 생성:\n\n이제 public 서브넷에 인터넷에 연결할 Internet-Gateway를 만들 것입니다. 이를 위해 라우팅 테이블도 생성하여 경로를 만들어야 합니다.\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n# main.tf\n\nresource \"aws_internet_gateway\" \"igw\" {\n        vpc_id = aws_vpc.vpc.id\n        tags = {\n                Name = \"terrform-vpc-igw\"\n        }\n}\n\nresource \"aws_route_table\" \"second-rt\" {\n        vpc_id = aws_vpc.vpc.id\n        route {\n                cidr_block = \"0.0.0.0/0\"\n                gateway_id = aws_internet_gateway.igw.id\n        }\n\n        tags = {\n                Name = \"Public-route-table\"\n        }\n}\n\nresource \"aws_route_table_association\" \"public-subnets-asso\" {\n        count = length(var.public_subnet_cidrs)\n        subnet_id = element(aws_subnet.public_subnets[*].id, count.index)\n        route_table_id = aws_route_table.second-rt.id\n}\n```\n\n- 여기서, 먼저 VPC 내에서 인터넷 게이트웨이를 생성합니다.\n- 그런 다음 인터넷 게이트웨이를 통해 안전한 인터넷 연결을 가능하게 하는 라우트를 생성하는 라우트 테이블을 만듭니다.\n- 그런 다음 이 라우트 테이블과 공용 서브넷을 연결해야합니다.\n\n## 6. 보안 그룹 구성:\n\nEC2 인스턴스로의 들어오고 나가는 트래픽을 제어하기 위해 보안 그룹 규칙을 지정합니다. 이렇게 하면 사전 정의된 규칙 세트에 따라 액세스를 제한하여 네트워크 보안이 강화되며 잠재적인 보안 취약점을 완화할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nresource \"aws_security_group\" \"sg\" {\n    name        = \"terraform_sg\"\n    description = \"This security group is for terraform practice\"\n    vpc_id      = aws_vpc.vpc.id\n\n    tags = {\n        Name = \"terraform_vg\"\n    }\n}\n\nresource \"aws_vpc_security_group_ingress_rule\" \"sg_in_rule\" {\n    security_group_id = aws_security_group.sg.id\n    cidr_ipv4        = \"0.0.0.0/0\"\n    from_port        = 80\n    ip_protocol      = \"tcp\"\n    to_port          = 80\n}\n\nresource \"aws_vpc_security_group_ingress_rule\" \"sg_in_rule2\" {\n    security_group_id = aws_security_group.sg.id\n    cidr_ipv4        = \"0.0.0.0/0\"\n    from_port        = 22\n    ip_protocol      = \"tcp\"\n    to_port          = 22\n}\n\nresource \"aws_vpc_security_group_egress_rule\" \"sg_eg_rule\" {\n    security_group_id = aws_security_group.sg.id\n    cidr_ipv4         = \"0.0.0.0/0\"\n    ip_protocol       = \"-1\" # semantically equivalent to all ports\n}\n```\n\n- 먼저 VPC 내에서 보안 그룹을 만듭니다.\n- 그런 다음 보안 그룹에 대한 인바운드 규칙을 정의하여 클라이언트가 포트 80 및 22에 도달할 수 있도록 허용합니다.\n- 그런 다음 아무 포트에서 어디로든 연결을 허용하는 보안 그룹에 대한 아웃바운드 규칙을 정의합니다.\n\n## 7. 데이터 소스를 활용한 AMI 구성:\n\nTerraform의 데이터 소스를 활용하여 지정된 필터에 따라 기존 AWS AMI에 대한 정보를 가져올 수 있습니다. 이러한 필터는 지역, 운영 체제 및 아키텍처와 같은 미리 정의된 것으로 구성됩니다. 이는 EC2 인스턴스에 가장 적합한 AMI를 동적으로 선택함으로써 배포 간의 호환성 및 일관성을 보장합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\ndata \"aws_ami\" \"rhel9\" {\n        most_recent = true\n\n        owners = [\"309956199498\"] // Red Hat의 계정 ID.\n\n        filter {\n                name   = \"architecture\"\n                values = [\"x86_64\"]\n        }\n\n        filter {\n                name   = \"root-device-type\"\n                values = [\"ebs\"]\n        }\n\n        filter {\n                name   = \"virtualization-type\"\n                values = [\"hvm\"]\n        }\n\n        filter {\n                name   = \"name\"\n                values = [\"RHEL-9.*\"]\n        }\n}\n```\n\n- 데이터 소스는 외부 시스템이나 기존 리소스에서 정보를 조회하고 해당 정보를 Terraform 구성에 통합하는 데 사용됩니다.\n\n## 8. EC2 인스턴스 프로비저닝:\n\n인스턴스 유형, 키페어, 보안 그룹을 포함한 EC2 인스턴스 구성을 정의합니다. Terraform은 VPC 내에서 EC2 인스턴스를 프로비저닝하여 지정된 구성을 준수하면서 연결성과 리소스 격리를 보장합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```json\n파일 이름 : main.tf\n```\n\n## 3. EC2 인스턴스 생성 :\n\n이 코드는 Terraform을 사용하여 AWS EC2 인스턴스를 생성하는 예시입니다. 우리는 AMI ID, 인스턴스 유형, 키 이름, 서브넷 ID, 보안 그룹 ID 등을 정의하고 있습니다. 이를 통해 인프라스트럭처 스택에 EC2 인스턴스를 통합할 수 있습니다. 태그를 지정하여 리소스를 식별할 수도 있습니다.\n\n## 테이블\n\n| 제목                | 설명                            |\n| ------------------- | ------------------------------- |\n| AMI                 | data.aws_ami.rhel9.id           |\n| 유형                | \"t2.micro\"                      |\n| 키 이름             | \"IAM_California\"                |\n| 서브넷 ID           | aws_subnet.public_subnets[0].id |\n| VPC 보안 그룹 ID    | aws_security_group.sg.id        |\n| 퍼블릭 IP 주소 연결 | true                            |\n\n태그 :\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 이제 새로운 EBS 볼륨을 생성했습니다. 중요한 점은 ec2 인스턴스와 ebs 볼륨이 동일한 가용 영역에 있어야 한다는 것입니다. 그렇지 않으면 서로 연결할 수 없습니다.\n\n## 10. EBS 볼륨 연결\n\n이제 다음 단계는 새로 생성한 ebs 볼륨을 ec2 인스턴스에 연결하는 것입니다.\n\n```js\nresource \"aws_volume_attachment\" \"ebs_attach\" {\n        device_name = \"/dev/xvdb\"\n        volume_id = aws_ebs_volume.EBS.id\n        instance_id = aws_instance.ec2-1.id\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 11. 공용 IP 주소 출력:\n\n마지막으로, 테라폼의 출력 기능을 사용하여 프로비저닝된 EC2 인스턴스의 공용 IP 주소를 표시합니다. 이는 관리자와 최종 사용자 모두가 인스턴스에 쉽게 액세스하고 관리할 수 있도록 합니다.\n\n```js\noutput \"ec2_instance_ip\" {\n        value = aws_instance.ec2-1.public_ip\n}\n```\n\n## 12. 테라폼 파일 적용하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n지금은 여태까지 AWS 인프라를 만든 main.tf 파일을 적용할 것입니다.\n\n```js\nterraform.exe apply\n```\n\n![AWS Infrastructure Deployment](/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_6.png)\n\n- 먼저 전체 계획을 알려줍니다. 그렇지 않으면 계획을 보는 별도의 명령어가 있습니다. 즉, terraform.exe plan\n- 계획을 알려준 후에는 앞으로 진행하고 AWS 클라우드에 적용할 것인지 물어봅니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![AWS Infrastructure Deployment with Terraform and Configuration with Ansible 7](/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_7.png)\n\n![AWS Infrastructure Deployment with Terraform and Configuration with Ansible 8](/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_8.png)\n\n# Let’s Go on our AWS Console to verify this deployment.\n\n## VPC ARCHITECTURE:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_9](/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_9.png)\n\n![AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_10](/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_10.png)\n\n## SECURITY GROUP :\n\n![AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_11](/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_11.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## EC2-INSTANCE :\n\n![EC2-INSTANCE](/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_12.png)\n\n# Ansible Configuration Management:\n\n인프라가 프로비저닝된 후에는 프로비저닝된 인스턴스 내에서 Ansible을 사용하여 구성 관리 작업으로 신속하게 전환합니다. Ansible은 우리에게 idempotent playbooks 및 모듈을 사용하여 복잡한 구성 작업을 자동화할 수 있는 기능을 제공하여 효율적이고 확장 가능한 인프라 관리를 가능하게 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저희 프로젝트는 Terraform과 Ansible을 완벽하게 통합하여 일관된 배포 파이프라인을 구축합니다. Terraform은 인프라 스택의 기반을 마련하는 데 도움을 주고, Ansible은 프로비전된 인스턴스를 구성하여 그들이 그 의도한 목적을 위해 완전히 기능하고 최적화되도록 보장합니다.\n\n## EC2-인스턴스 구성을 위한 Ansible의 실용적인 단계:\n\n- ANSIBLE 인벤토리:\n\n```js\nvim / etc / ansible / hosts;\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\\<img src=\"/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_13.png\" />\n\n2. REQUIRED MODULES 설치하기.\n\n```js\nansible-galaxy collections install community.general\nansible-galaxy collections install posix\n```\n\n3. ANSIBLE-PLAYBOOK:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nvim <file-name>.yml\n```\n\n![AWS Infrastructure Deployment with Terraform and Configuration with Ansible](/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_14.png)\n\n![AWS Infrastructure Deployment with Terraform and Configuration with Ansible](/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_15.png)\n\n![AWS Infrastructure Deployment with Terraform and Configuration with Ansible](/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_16.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```yaml\n- hosts: all\n  become: yes\n  tasks:\n    - name: \"파티션 생성\"\n      community.general.parted:\n        device: \"/dev/xvdb\"\n        name: \"GPT\"\n        number: 1\n        part_end: \"1GiB\"\n        fs_type: \"ext4\"\n        state: present\n        label: \"gpt\"\n        unit: GiB\n\n    - name: \"중요 명령어 실행\"\n      command:\n        cmd: \"udevadm settle\"\n      register: cmd\n\n    - debug:\n        var: cmd\n\n    - command:\n        cmd: \"lsblk\"\n      register: cmd2\n\n    - debug:\n        var: cmd2\n\n    - name: \"파티션 포맷\"\n      community.general.filesystem:\n        fstype: ext4\n        dev: \"/dev/xvdb1\"\n\n    - name: \"웹 서버 설치\"\n      package:\n        name: \"httpd\"\n        state: present\n\n    - name: \"마운트된 볼륨과 연결\"\n      ansible.posix.mount:\n        path: \"/var/www/html\"\n        src: \"/dev/xvdb1\"\n        state: mounted\n        fstype: ext4\n\n    - name: \"데몬 다시로드\"\n      command:\n        cmd: \"systemctl daemon-reload\"\n\n    - command:\n        cmd: \"lsblk\"\n      register: cmd3\n\n    - debug:\n        var: cmd3\n\n    - name: \"인덱스 파일을 웹 서버로 복사\"\n      ansible.builtin.copy:\n        src: \"index.html\"\n        dest: \"/var/www/html/index.html\"\n\n    - name: \"서버 재시작\"\n      service:\n        name: \"httpd\"\n        state: \"started\"\n```\n\n## 이 Playbook은 다음을 수행할 수 있습니다:\n\n- 우리가 연결한 볼륨인 /dev/xvdb에 파티션 생성.\n- ext4 유형으로 새로 생성된 파티션 포맷.\n- 시스템에 아파치 웹 서버 설치.\n- 아파치 루트 문서인 /var/www/html에 파티션을 마운트.\n- 로컬 시스템의 인덱스 파일을 대상 시스템의 루트 문서에 복사.\n- 아파치 서비스 시작.\n\n## ANSIBLE PLAYBOOK 실행하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nansible-playbook <file-name>.yml\n```\n\n![Image](/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_17.png)\n\n![Image](/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_18.png)\n\n## 웹 서버가 성공적으로 시작되었는지 확인해 봅시다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![AWS Infrastructure Deployment with Terraform and Configuration with Ansible](/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_19.png)\n\n# 결론:\n\n요약하면, Terraform과 Ansible의 통합은 AWS 인프라 자동화에서 강력한 패러다임 변화를 나타냅니다. 인프라 프로비저닝에 Terraform을 활용하고 구성 관리에는 Ansible을 활용함으로써, 조직은 클라우드 배포에서 전례 없는 민첩성, 확장성 및 신뢰성을 달성할 수 있습니다. 이 통합 접근 방식을 통해 팀은 DevOps 성숙도로 나아가는 여정을 가속화하고 클라우드 자동화의 모든 잠재력을 발휘할 수 있습니다.\n\n오늘 Terraform과 Ansible의 힘을 받아 AWS 인프라 배포 및 구성 워크플로를 혁신하세요! 🚀🔧\n","ogImage":{"url":"/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_0.png"},"coverImage":"/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_0.png","tag":["Tech"],"readingTime":19},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<h1>소개:</h1>\n<p>현재의 동적 클라우드 컴퓨팅 환경에서는 인프라 프로비저닝을 자동화하는 것이 확장성, 신뢰성, 및 비용 효율성을 원하는 기관들에게 필수적입니다. Terraform은 오픈 소스 인프라 코드 도구로, 선언적 구성 파일을 사용하여 인프라를 정의하고 관리할 수 있도록 팀에게 권한을 부여합니다. 이 블로그에서는 Terraform이 AWS 인프라 구성 요소의 배포를 체계적이고 효율적으로 간소화하는 방법을 탐색해보겠습니다.</p>\n<h1>프로젝트 개요:</h1>\n<p>우리 Terraform 프로젝트는 가상 사설 클라우드(VPC), 보안 그룹, Amazon Machine Image(AMI), Elastic Block Store(EBS) 볼륨, 및 EC2 인스턴스로 구성된 AWS 인프라 스택의 배포를 자동화하는 데 초점을 맞춥니다. Terraform의 모듈식이자 반복 가능한 구성을 활용하여 환경 간 일관성과 신뢰성을 보장하고, 수동 개입과 인적 오류를 최소화합니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h1>상세 단계:</h1>\n<h2>1. AWS CLI 설치하기:</h2>\n<ul>\n<li>먼저 로컬 컴퓨터에 AWS CLI를 설치해야 합니다.</li>\n<li>다음 링크를 따라 AWS CLI를 설치하세요:</li>\n</ul>\n<p><img src=\"/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_0.png\" alt=\"AWS CLI 설치 링크\"></p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<ul>\n<li>AWS CLI를 이곳에서 다운로드하여 계정에 구성하세요.</li>\n<li>또는 Linux 버전을 선택하여 설치할 수도 있습니다.</li>\n<li>이를 위해 계정에 IAM 사용자를 만들어야 합니다.</li>\n</ul>\n<p><img src=\"/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_1.png\" alt=\"이미지1\"></p>\n<p><img src=\"/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_2.png\" alt=\"이미지2\"></p>\n<ul>\n<li>현재는 관리자 액세스를 제공하지만 좋은 실천 방법은 아닙니다.</li>\n</ul>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p><img src=\"/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_3.png\" alt=\"2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_3.png\"></p>\n<p><img src=\"/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_4.png\" alt=\"2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_4.png\"></p>\n<ul>\n<li>보안 자격 증명에서 \"액세스 키 생성\" 옵션을 클릭하여 액세스 키 및 비밀 키를 생성하고 둘 다 복사합니다.</li>\n</ul>\n<p><img src=\"/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_5.png\" alt=\"2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_5.png\"></p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<ul>\n<li>Access Key ID에 액세스 키를 붙여 넣고, Secret Access Key ID에 비밀 키를 입력해주세요. 그리고 설정하고 싶은 기본 지역도 지정해주세요.</li>\n</ul>\n<h2>2. Terraform 초기화하기.</h2>\n<ul>\n<li>main.tf 파일을 생성하고, 제공자(provider) 구성을 거기에 입력해주세요.</li>\n</ul>\n<pre><code class=\"hljs language-js\"># main.<span class=\"hljs-property\">tf</span>\n\n# <span class=\"hljs-title class_\">Provider</span> configuration\nprovider <span class=\"hljs-string\">\"aws\"</span> {\n  region = <span class=\"hljs-string\">\"us-west-1\"</span>\n}\n</code></pre>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<ul>\n<li>그럼 아래 명령어를 입력해주세요.</li>\n</ul>\n<pre><code class=\"hljs language-js\">terraform.<span class=\"hljs-property\">exe</span> init\n</code></pre>\n<h2>3. VPC 생성:</h2>\n<p>우리는 VPC 구성을 정의합니다. CIDR 블록을 포함하여 네트워크 구조의 기반을 마련합니다. 이는 AWS 환경 내에서 격리되고 안전한 통신을 제공합니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<ul>\n<li>이 프로젝트 전체에 대해 동일한 main.tf 파일을 사용할 것입니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\"># main.<span class=\"hljs-property\">tf</span>\n\nresource <span class=\"hljs-string\">\"aws_vpc\"</span> <span class=\"hljs-string\">\"vpc\"</span>{\n        cidr_block = <span class=\"hljs-string\">\"192.168.0.0/16\"</span>\n\n        tags = {\n                <span class=\"hljs-title class_\">Name</span> = <span class=\"hljs-string\">\"Terraform_VPC\"</span>\n        }\n}\n</code></pre>\n<h2>4. 서브넷 생성:</h2>\n<ul>\n<li>이제 서브넷 구성을 정의합니다. 이 구성에는 공용 서브넷과 사설 서브넷이 모두 포함됩니다.</li>\n</ul>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-js\"># main.<span class=\"hljs-property\">tf</span>\n\n변수 <span class=\"hljs-string\">\"aws_azs\"</span>를 정의합니다. 여기에는 public 서브넷의 가용 영역이 저장됩니다. 그리고 public 서브넷의 <span class=\"hljs-variable constant_\">CIDR</span> 블록을 저장하는 다른 변수를 만듭니다.\n\n그런 다음 각 가용 영역에 <span class=\"hljs-number\">2</span>개의 public 서브넷을 만듭니다.\n- length 함수는 주어진 목록, 맵 또는 문자열의 길이를 결정합니다. 목록이나 맵이 주어지면 해당 컬렉션의 요소 수가 결과로 나옵니다.\n- <span class=\"hljs-title function_\">element</span>() 함수는 목록에서 특정 인덱스의 요소를 검색합니다. 사용 사례: 목록에서 특정 요소에 액세스하는 것은 해당 인덱스를 기준으로 목록에서 특정 리소스나 매개변수를 선택하려고 할 때 유용합니다.\n- count.<span class=\"hljs-property\">index</span> 객체는 count 내의 현재 인스턴스의 인덱스를 나타냅니다. 인덱스는 <span class=\"hljs-number\">0</span>부터 시작하며, count가 <span class=\"hljs-number\">4</span>인 리소스가 있으면 count.<span class=\"hljs-property\">index</span> 객체는 <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span> 및 <span class=\"hljs-number\">3</span>이 됩니다.\n- 그런 다음 private 서브넷을 만드는 동일한 단계를 반복합니다.\n\n## <span class=\"hljs-number\">5.</span> <span class=\"hljs-title class_\">Internet</span>-<span class=\"hljs-title class_\">Gateway</span> 및 <span class=\"hljs-title class_\">Route</span>-table 생성:\n\n이제 public 서브넷에 인터넷에 연결할 <span class=\"hljs-title class_\">Internet</span>-<span class=\"hljs-title class_\">Gateway</span>를 만들 것입니다. 이를 위해 라우팅 테이블도 생성하여 경로를 만들어야 합니다.\n</code></pre>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-js\"># main.<span class=\"hljs-property\">tf</span>\n\nresource <span class=\"hljs-string\">\"aws_internet_gateway\"</span> <span class=\"hljs-string\">\"igw\"</span> {\n        vpc_id = aws_vpc.<span class=\"hljs-property\">vpc</span>.<span class=\"hljs-property\">id</span>\n        tags = {\n                <span class=\"hljs-title class_\">Name</span> = <span class=\"hljs-string\">\"terrform-vpc-igw\"</span>\n        }\n}\n\nresource <span class=\"hljs-string\">\"aws_route_table\"</span> <span class=\"hljs-string\">\"second-rt\"</span> {\n        vpc_id = aws_vpc.<span class=\"hljs-property\">vpc</span>.<span class=\"hljs-property\">id</span>\n        route {\n                cidr_block = <span class=\"hljs-string\">\"0.0.0.0/0\"</span>\n                gateway_id = aws_internet_gateway.<span class=\"hljs-property\">igw</span>.<span class=\"hljs-property\">id</span>\n        }\n\n        tags = {\n                <span class=\"hljs-title class_\">Name</span> = <span class=\"hljs-string\">\"Public-route-table\"</span>\n        }\n}\n\nresource <span class=\"hljs-string\">\"aws_route_table_association\"</span> <span class=\"hljs-string\">\"public-subnets-asso\"</span> {\n        count = <span class=\"hljs-title function_\">length</span>(<span class=\"hljs-keyword\">var</span>.<span class=\"hljs-property\">public_subnet_cidrs</span>)\n        subnet_id = <span class=\"hljs-title function_\">element</span>(aws_subnet.<span class=\"hljs-property\">public_subnets</span>[*].<span class=\"hljs-property\">id</span>, count.<span class=\"hljs-property\">index</span>)\n        route_table_id = aws_route_table.<span class=\"hljs-property\">second</span>-rt.<span class=\"hljs-property\">id</span>\n}\n</code></pre>\n<ul>\n<li>여기서, 먼저 VPC 내에서 인터넷 게이트웨이를 생성합니다.</li>\n<li>그런 다음 인터넷 게이트웨이를 통해 안전한 인터넷 연결을 가능하게 하는 라우트를 생성하는 라우트 테이블을 만듭니다.</li>\n<li>그런 다음 이 라우트 테이블과 공용 서브넷을 연결해야합니다.</li>\n</ul>\n<h2>6. 보안 그룹 구성:</h2>\n<p>EC2 인스턴스로의 들어오고 나가는 트래픽을 제어하기 위해 보안 그룹 규칙을 지정합니다. 이렇게 하면 사전 정의된 규칙 세트에 따라 액세스를 제한하여 네트워크 보안이 강화되며 잠재적인 보안 취약점을 완화할 수 있습니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-js\">resource <span class=\"hljs-string\">\"aws_security_group\"</span> <span class=\"hljs-string\">\"sg\"</span> {\n    name        = <span class=\"hljs-string\">\"terraform_sg\"</span>\n    description = <span class=\"hljs-string\">\"This security group is for terraform practice\"</span>\n    vpc_id      = aws_vpc.<span class=\"hljs-property\">vpc</span>.<span class=\"hljs-property\">id</span>\n\n    tags = {\n        <span class=\"hljs-title class_\">Name</span> = <span class=\"hljs-string\">\"terraform_vg\"</span>\n    }\n}\n\nresource <span class=\"hljs-string\">\"aws_vpc_security_group_ingress_rule\"</span> <span class=\"hljs-string\">\"sg_in_rule\"</span> {\n    security_group_id = aws_security_group.<span class=\"hljs-property\">sg</span>.<span class=\"hljs-property\">id</span>\n    cidr_ipv4        = <span class=\"hljs-string\">\"0.0.0.0/0\"</span>\n    from_port        = <span class=\"hljs-number\">80</span>\n    ip_protocol      = <span class=\"hljs-string\">\"tcp\"</span>\n    to_port          = <span class=\"hljs-number\">80</span>\n}\n\nresource <span class=\"hljs-string\">\"aws_vpc_security_group_ingress_rule\"</span> <span class=\"hljs-string\">\"sg_in_rule2\"</span> {\n    security_group_id = aws_security_group.<span class=\"hljs-property\">sg</span>.<span class=\"hljs-property\">id</span>\n    cidr_ipv4        = <span class=\"hljs-string\">\"0.0.0.0/0\"</span>\n    from_port        = <span class=\"hljs-number\">22</span>\n    ip_protocol      = <span class=\"hljs-string\">\"tcp\"</span>\n    to_port          = <span class=\"hljs-number\">22</span>\n}\n\nresource <span class=\"hljs-string\">\"aws_vpc_security_group_egress_rule\"</span> <span class=\"hljs-string\">\"sg_eg_rule\"</span> {\n    security_group_id = aws_security_group.<span class=\"hljs-property\">sg</span>.<span class=\"hljs-property\">id</span>\n    cidr_ipv4         = <span class=\"hljs-string\">\"0.0.0.0/0\"</span>\n    ip_protocol       = <span class=\"hljs-string\">\"-1\"</span> # semantically equivalent to all ports\n}\n</code></pre>\n<ul>\n<li>먼저 VPC 내에서 보안 그룹을 만듭니다.</li>\n<li>그런 다음 보안 그룹에 대한 인바운드 규칙을 정의하여 클라이언트가 포트 80 및 22에 도달할 수 있도록 허용합니다.</li>\n<li>그런 다음 아무 포트에서 어디로든 연결을 허용하는 보안 그룹에 대한 아웃바운드 규칙을 정의합니다.</li>\n</ul>\n<h2>7. 데이터 소스를 활용한 AMI 구성:</h2>\n<p>Terraform의 데이터 소스를 활용하여 지정된 필터에 따라 기존 AWS AMI에 대한 정보를 가져올 수 있습니다. 이러한 필터는 지역, 운영 체제 및 아키텍처와 같은 미리 정의된 것으로 구성됩니다. 이는 EC2 인스턴스에 가장 적합한 AMI를 동적으로 선택함으로써 배포 간의 호환성 및 일관성을 보장합니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-js\">data <span class=\"hljs-string\">\"aws_ami\"</span> <span class=\"hljs-string\">\"rhel9\"</span> {\n        most_recent = <span class=\"hljs-literal\">true</span>\n\n        owners = [<span class=\"hljs-string\">\"309956199498\"</span>] <span class=\"hljs-comment\">// Red Hat의 계정 ID.</span>\n\n        filter {\n                name   = <span class=\"hljs-string\">\"architecture\"</span>\n                values = [<span class=\"hljs-string\">\"x86_64\"</span>]\n        }\n\n        filter {\n                name   = <span class=\"hljs-string\">\"root-device-type\"</span>\n                values = [<span class=\"hljs-string\">\"ebs\"</span>]\n        }\n\n        filter {\n                name   = <span class=\"hljs-string\">\"virtualization-type\"</span>\n                values = [<span class=\"hljs-string\">\"hvm\"</span>]\n        }\n\n        filter {\n                name   = <span class=\"hljs-string\">\"name\"</span>\n                values = [<span class=\"hljs-string\">\"RHEL-9.*\"</span>]\n        }\n}\n</code></pre>\n<ul>\n<li>데이터 소스는 외부 시스템이나 기존 리소스에서 정보를 조회하고 해당 정보를 Terraform 구성에 통합하는 데 사용됩니다.</li>\n</ul>\n<h2>8. EC2 인스턴스 프로비저닝:</h2>\n<p>인스턴스 유형, 키페어, 보안 그룹을 포함한 EC2 인스턴스 구성을 정의합니다. Terraform은 VPC 내에서 EC2 인스턴스를 프로비저닝하여 지정된 구성을 준수하면서 연결성과 리소스 격리를 보장합니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-json\">파일 이름 <span class=\"hljs-punctuation\">:</span> main.tf\n</code></pre>\n<h2>3. EC2 인스턴스 생성 :</h2>\n<p>이 코드는 Terraform을 사용하여 AWS EC2 인스턴스를 생성하는 예시입니다. 우리는 AMI ID, 인스턴스 유형, 키 이름, 서브넷 ID, 보안 그룹 ID 등을 정의하고 있습니다. 이를 통해 인프라스트럭처 스택에 EC2 인스턴스를 통합할 수 있습니다. 태그를 지정하여 리소스를 식별할 수도 있습니다.</p>\n<h2>테이블</h2>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th>제목</th><th>설명</th></tr></thead><tbody><tr><td>AMI</td><td>data.aws_ami.rhel9.id</td></tr><tr><td>유형</td><td>\"t2.micro\"</td></tr><tr><td>키 이름</td><td>\"IAM_California\"</td></tr><tr><td>서브넷 ID</td><td>aws_subnet.public_subnets[0].id</td></tr><tr><td>VPC 보안 그룹 ID</td><td>aws_security_group.sg.id</td></tr><tr><td>퍼블릭 IP 주소 연결</td><td>true</td></tr></tbody></table>\n<p>태그 :</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<ul>\n<li>이제 새로운 EBS 볼륨을 생성했습니다. 중요한 점은 ec2 인스턴스와 ebs 볼륨이 동일한 가용 영역에 있어야 한다는 것입니다. 그렇지 않으면 서로 연결할 수 없습니다.</li>\n</ul>\n<h2>10. EBS 볼륨 연결</h2>\n<p>이제 다음 단계는 새로 생성한 ebs 볼륨을 ec2 인스턴스에 연결하는 것입니다.</p>\n<pre><code class=\"hljs language-js\">resource <span class=\"hljs-string\">\"aws_volume_attachment\"</span> <span class=\"hljs-string\">\"ebs_attach\"</span> {\n        device_name = <span class=\"hljs-string\">\"/dev/xvdb\"</span>\n        volume_id = aws_ebs_volume.<span class=\"hljs-property\">EBS</span>.<span class=\"hljs-property\">id</span>\n        instance_id = aws_instance.<span class=\"hljs-property\">ec2</span>-<span class=\"hljs-number\">1.</span>id\n}\n</code></pre>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h2>11. 공용 IP 주소 출력:</h2>\n<p>마지막으로, 테라폼의 출력 기능을 사용하여 프로비저닝된 EC2 인스턴스의 공용 IP 주소를 표시합니다. 이는 관리자와 최종 사용자 모두가 인스턴스에 쉽게 액세스하고 관리할 수 있도록 합니다.</p>\n<pre><code class=\"hljs language-js\">output <span class=\"hljs-string\">\"ec2_instance_ip\"</span> {\n        value = aws_instance.<span class=\"hljs-property\">ec2</span>-<span class=\"hljs-number\">1.</span>public_ip\n}\n</code></pre>\n<h2>12. 테라폼 파일 적용하기</h2>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>지금은 여태까지 AWS 인프라를 만든 main.tf 파일을 적용할 것입니다.</p>\n<pre><code class=\"hljs language-js\">terraform.<span class=\"hljs-property\">exe</span> apply\n</code></pre>\n<p><img src=\"/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_6.png\" alt=\"AWS Infrastructure Deployment\"></p>\n<ul>\n<li>먼저 전체 계획을 알려줍니다. 그렇지 않으면 계획을 보는 별도의 명령어가 있습니다. 즉, terraform.exe plan</li>\n<li>계획을 알려준 후에는 앞으로 진행하고 AWS 클라우드에 적용할 것인지 물어봅니다.</li>\n</ul>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p><img src=\"/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_7.png\" alt=\"AWS Infrastructure Deployment with Terraform and Configuration with Ansible 7\"></p>\n<p><img src=\"/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_8.png\" alt=\"AWS Infrastructure Deployment with Terraform and Configuration with Ansible 8\"></p>\n<h1>Let’s Go on our AWS Console to verify this deployment.</h1>\n<h2>VPC ARCHITECTURE:</h2>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p><img src=\"/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_9.png\" alt=\"AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_9\"></p>\n<p><img src=\"/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_10.png\" alt=\"AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_10\"></p>\n<h2>SECURITY GROUP :</h2>\n<p><img src=\"/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_11.png\" alt=\"AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_11\"></p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h2>EC2-INSTANCE :</h2>\n<p><img src=\"/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_12.png\" alt=\"EC2-INSTANCE\"></p>\n<h1>Ansible Configuration Management:</h1>\n<p>인프라가 프로비저닝된 후에는 프로비저닝된 인스턴스 내에서 Ansible을 사용하여 구성 관리 작업으로 신속하게 전환합니다. Ansible은 우리에게 idempotent playbooks 및 모듈을 사용하여 복잡한 구성 작업을 자동화할 수 있는 기능을 제공하여 효율적이고 확장 가능한 인프라 관리를 가능하게 합니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>저희 프로젝트는 Terraform과 Ansible을 완벽하게 통합하여 일관된 배포 파이프라인을 구축합니다. Terraform은 인프라 스택의 기반을 마련하는 데 도움을 주고, Ansible은 프로비전된 인스턴스를 구성하여 그들이 그 의도한 목적을 위해 완전히 기능하고 최적화되도록 보장합니다.</p>\n<h2>EC2-인스턴스 구성을 위한 Ansible의 실용적인 단계:</h2>\n<ul>\n<li>ANSIBLE 인벤토리:</li>\n</ul>\n<pre><code class=\"hljs language-js\">vim / etc / ansible / hosts;\n</code></pre>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>&#x3C;img src=\"/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_13.png\" /></p>\n<ol start=\"2\">\n<li>REQUIRED MODULES 설치하기.</li>\n</ol>\n<pre><code class=\"hljs language-js\">ansible-galaxy collections install community.<span class=\"hljs-property\">general</span>\nansible-galaxy collections install posix\n</code></pre>\n<ol start=\"3\">\n<li>ANSIBLE-PLAYBOOK:</li>\n</ol>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-js\">vim &#x3C;file-name>.<span class=\"hljs-property\">yml</span>\n</code></pre>\n<p><img src=\"/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_14.png\" alt=\"AWS Infrastructure Deployment with Terraform and Configuration with Ansible\"></p>\n<p><img src=\"/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_15.png\" alt=\"AWS Infrastructure Deployment with Terraform and Configuration with Ansible\"></p>\n<p><img src=\"/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_16.png\" alt=\"AWS Infrastructure Deployment with Terraform and Configuration with Ansible\"></p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-yaml\"><span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">hosts:</span> <span class=\"hljs-string\">all</span>\n  <span class=\"hljs-attr\">become:</span> <span class=\"hljs-literal\">yes</span>\n  <span class=\"hljs-attr\">tasks:</span>\n    <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">\"파티션 생성\"</span>\n      <span class=\"hljs-attr\">community.general.parted:</span>\n        <span class=\"hljs-attr\">device:</span> <span class=\"hljs-string\">\"/dev/xvdb\"</span>\n        <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">\"GPT\"</span>\n        <span class=\"hljs-attr\">number:</span> <span class=\"hljs-number\">1</span>\n        <span class=\"hljs-attr\">part_end:</span> <span class=\"hljs-string\">\"1GiB\"</span>\n        <span class=\"hljs-attr\">fs_type:</span> <span class=\"hljs-string\">\"ext4\"</span>\n        <span class=\"hljs-attr\">state:</span> <span class=\"hljs-string\">present</span>\n        <span class=\"hljs-attr\">label:</span> <span class=\"hljs-string\">\"gpt\"</span>\n        <span class=\"hljs-attr\">unit:</span> <span class=\"hljs-string\">GiB</span>\n\n    <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">\"중요 명령어 실행\"</span>\n      <span class=\"hljs-attr\">command:</span>\n        <span class=\"hljs-attr\">cmd:</span> <span class=\"hljs-string\">\"udevadm settle\"</span>\n      <span class=\"hljs-attr\">register:</span> <span class=\"hljs-string\">cmd</span>\n\n    <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">debug:</span>\n        <span class=\"hljs-attr\">var:</span> <span class=\"hljs-string\">cmd</span>\n\n    <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">command:</span>\n        <span class=\"hljs-attr\">cmd:</span> <span class=\"hljs-string\">\"lsblk\"</span>\n      <span class=\"hljs-attr\">register:</span> <span class=\"hljs-string\">cmd2</span>\n\n    <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">debug:</span>\n        <span class=\"hljs-attr\">var:</span> <span class=\"hljs-string\">cmd2</span>\n\n    <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">\"파티션 포맷\"</span>\n      <span class=\"hljs-attr\">community.general.filesystem:</span>\n        <span class=\"hljs-attr\">fstype:</span> <span class=\"hljs-string\">ext4</span>\n        <span class=\"hljs-attr\">dev:</span> <span class=\"hljs-string\">\"/dev/xvdb1\"</span>\n\n    <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">\"웹 서버 설치\"</span>\n      <span class=\"hljs-attr\">package:</span>\n        <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">\"httpd\"</span>\n        <span class=\"hljs-attr\">state:</span> <span class=\"hljs-string\">present</span>\n\n    <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">\"마운트된 볼륨과 연결\"</span>\n      <span class=\"hljs-attr\">ansible.posix.mount:</span>\n        <span class=\"hljs-attr\">path:</span> <span class=\"hljs-string\">\"/var/www/html\"</span>\n        <span class=\"hljs-attr\">src:</span> <span class=\"hljs-string\">\"/dev/xvdb1\"</span>\n        <span class=\"hljs-attr\">state:</span> <span class=\"hljs-string\">mounted</span>\n        <span class=\"hljs-attr\">fstype:</span> <span class=\"hljs-string\">ext4</span>\n\n    <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">\"데몬 다시로드\"</span>\n      <span class=\"hljs-attr\">command:</span>\n        <span class=\"hljs-attr\">cmd:</span> <span class=\"hljs-string\">\"systemctl daemon-reload\"</span>\n\n    <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">command:</span>\n        <span class=\"hljs-attr\">cmd:</span> <span class=\"hljs-string\">\"lsblk\"</span>\n      <span class=\"hljs-attr\">register:</span> <span class=\"hljs-string\">cmd3</span>\n\n    <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">debug:</span>\n        <span class=\"hljs-attr\">var:</span> <span class=\"hljs-string\">cmd3</span>\n\n    <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">\"인덱스 파일을 웹 서버로 복사\"</span>\n      <span class=\"hljs-attr\">ansible.builtin.copy:</span>\n        <span class=\"hljs-attr\">src:</span> <span class=\"hljs-string\">\"index.html\"</span>\n        <span class=\"hljs-attr\">dest:</span> <span class=\"hljs-string\">\"/var/www/html/index.html\"</span>\n\n    <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">\"서버 재시작\"</span>\n      <span class=\"hljs-attr\">service:</span>\n        <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">\"httpd\"</span>\n        <span class=\"hljs-attr\">state:</span> <span class=\"hljs-string\">\"started\"</span>\n</code></pre>\n<h2>이 Playbook은 다음을 수행할 수 있습니다:</h2>\n<ul>\n<li>우리가 연결한 볼륨인 /dev/xvdb에 파티션 생성.</li>\n<li>ext4 유형으로 새로 생성된 파티션 포맷.</li>\n<li>시스템에 아파치 웹 서버 설치.</li>\n<li>아파치 루트 문서인 /var/www/html에 파티션을 마운트.</li>\n<li>로컬 시스템의 인덱스 파일을 대상 시스템의 루트 문서에 복사.</li>\n<li>아파치 서비스 시작.</li>\n</ul>\n<h2>ANSIBLE PLAYBOOK 실행하기</h2>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-js\">ansible-playbook &#x3C;file-name>.<span class=\"hljs-property\">yml</span>\n</code></pre>\n<p><img src=\"/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_17.png\" alt=\"Image\"></p>\n<p><img src=\"/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_18.png\" alt=\"Image\"></p>\n<h2>웹 서버가 성공적으로 시작되었는지 확인해 봅시다.</h2>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p><img src=\"/assets/img/2024-06-19-AWSInfrastructureDeploymentwithTerraformandConfigurationwithAnsible_19.png\" alt=\"AWS Infrastructure Deployment with Terraform and Configuration with Ansible\"></p>\n<h1>결론:</h1>\n<p>요약하면, Terraform과 Ansible의 통합은 AWS 인프라 자동화에서 강력한 패러다임 변화를 나타냅니다. 인프라 프로비저닝에 Terraform을 활용하고 구성 관리에는 Ansible을 활용함으로써, 조직은 클라우드 배포에서 전례 없는 민첩성, 확장성 및 신뢰성을 달성할 수 있습니다. 이 통합 접근 방식을 통해 팀은 DevOps 성숙도로 나아가는 여정을 가속화하고 클라우드 자동화의 모든 잠재력을 발휘할 수 있습니다.</p>\n<p>오늘 Terraform과 Ansible의 힘을 받아 AWS 인프라 배포 및 구성 워크플로를 혁신하세요! 🚀🔧</p>\n</body>\n</html>\n"},"__N_SSG":true}