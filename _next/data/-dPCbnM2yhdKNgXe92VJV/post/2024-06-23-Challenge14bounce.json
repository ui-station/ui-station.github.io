{"pageProps":{"post":{"title":"Challenge 14 바운스 방법 이해 및 구현","description":"","date":"2024-06-23 00:59","slug":"2024-06-23-Challenge14bounce","content":"\n쿠버네티스 서비스: 생각했던 대로 항상 작동하지 않을 수 있어요.\n\n쿠버네티스에서는 서비스가 존재하지 않아요: IP 주소나 포트를 수신하는 프로세스가 없어요. 대신, 쿠버네티스는 고급 네트워크 규칙을 사용하여 로드 밸런서를 모방해요.\n\n기본적으로, 이러한 네트워크 규칙은 Kube-proxy가 관리하는 iptables 규칙을 사용해요.\n\n하지만, Cilium으로 작성된 eBPF를 사용하는 대안이 있어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\"왜 \"표준\" 로드 밸런서를 사용하지 않는 거죠?\n\n이것은 주로 단일 고장 지점의 문제를 극복하기 위해 설계되었습니다. 각 노드에 규칙이 기입되어 있기 때문에, 단일 구성 요소의 고장이 전체 클러스터에 영향을 미칠 가능성이 적습니다.\n\n그러나 이것은 흥미로운(그리고 예상치 못한) 결과를 초래할 수 있습니다.\n\n세 개의 노드와 두 개의 팟이 있는 다음 클러스터를 고려해보세요.\"\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-06-23-Challenge14bounce_0.png\" />\n\n외부 트래픽에 파드를 노출하는 NodePort 서비스가 있습니다.\n\nNodePort로 요청을 보내면, 해당 트래픽이 동일 노드의 파드 2에 도착할 확률은 얼마인가요?\n\n- 트래픽은 항상 파드 2에 도착합니다\n- 트래픽이 파드 2에 도착할 확률은 50% 입니다\n- 트래픽이 파드 2에 도착할 확률은 33% 입니다\n- 위의 어느 것도 아닙니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 해결책\n\n왜 그런지 이해하려면 Kube-proxy가 노드에 전달 규칙을 설정하는 방식을 살펴봐야 합니다 (예: iptables, ipvs, eBPF 등).\n\nNodePort를 생성하면 클러스터의 각 노드가 30000~32767 범위의 포트를 노출합니다. 30000번 포트로 가정해 보겠습니다.\n\n`노드 IP`:30000으로 curl 요청을 발행하면 무슨 일이 일어날까요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nIP 헤더의 대상 IP 주소는 Kubernetes에 서비스가 존재하지 않기 때문에 다시 작성됩니다(그리고 그들은 트래픽을 리디렉션하고 전달하는 규칙의 모음일 뿐입니다).\n\n두 개의 파드 중 하나가 대상으로 선택되고, 트래픽이 해당 팟에 도달할 수 있습니다.\n\n그래서 각 팟은 트래픽을 받을 확률이 50%입니다.\n\n이는 클러스터에 있는 어느 노드에서 클러스터를 받았는지에 관계없이 발생합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n하지만, 토론할 가치가 있는 두 가지 흥미로운 경계 사례가 있습니다:\n\n- 팟이 없는 노드를 만나면 여전히 트래픽이 팟 1 또는 팟 2로 리디렉션됩니다.\n- 팟 2를 포함한 두 번째 노드를 만나면 트래픽이 여전히 다른 팟으로 이동할 수 있습니다.\n\n이 두 경우 모두 현재 노드는 트래픽을 처리하지 않으며, 추가적인 홉이 발생합니다.\n\n이것이 낭비라고 생각할 수 있지만, 이는 타협점입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n특정 테이블 태그를 마크다운 형식으로 변경하시면 추가 hop이 발생하여 포드 간에 우수한 인트라 클러스터 로드 밸런싱을 할 수 있거나 항상 서비스를 구성하여 현재 노드의 포드로 트래픽을 전달하도록 설정할 수 있습니다.\n\n대기시간이 향상되지만 요청을 부분적으로 로드 밸런싱할 수 있기 때문에 다른 포드보다 연결 수가 더 많은 포드를 얻을 수도 있습니다.\n\n이 내용이 마음에 드셨다면 아래 내용도 좋아하실 수 있습니다:\n\n- Learnk8s에서 운영하는 Kubernetes 강좌.\n- 매주 발행하는 Learn Kubernetes Weekly 뉴스레터.\n- 20주 동안 게시한 20가지 Kubernetes 개념 시리즈.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 링크\n\n리소스 할당에 대해 더 자세히 알고 싶다면, 다음 자료를 꼭 확인해보세요:\n\n- [kubernetes service에 핑을 보낼 수 없는 이유](https://medium.com/@danielepolencic/learn-why-you-cant-ping-a-kubernetes-service-dec88b55e1a3)\n- [kubernetes 네트워크 패킷](https://learnk8s.io/kubernetes-network-packets)\n","ogImage":{"url":"/assets/img/2024-06-23-Challenge14bounce_0.png"},"coverImage":"/assets/img/2024-06-23-Challenge14bounce_0.png","tag":["Tech"],"readingTime":4},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p>쿠버네티스 서비스: 생각했던 대로 항상 작동하지 않을 수 있어요.</p>\n<p>쿠버네티스에서는 서비스가 존재하지 않아요: IP 주소나 포트를 수신하는 프로세스가 없어요. 대신, 쿠버네티스는 고급 네트워크 규칙을 사용하여 로드 밸런서를 모방해요.</p>\n<p>기본적으로, 이러한 네트워크 규칙은 Kube-proxy가 관리하는 iptables 규칙을 사용해요.</p>\n<p>하지만, Cilium으로 작성된 eBPF를 사용하는 대안이 있어요.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>\"왜 \"표준\" 로드 밸런서를 사용하지 않는 거죠?</p>\n<p>이것은 주로 단일 고장 지점의 문제를 극복하기 위해 설계되었습니다. 각 노드에 규칙이 기입되어 있기 때문에, 단일 구성 요소의 고장이 전체 클러스터에 영향을 미칠 가능성이 적습니다.</p>\n<p>그러나 이것은 흥미로운(그리고 예상치 못한) 결과를 초래할 수 있습니다.</p>\n<p>세 개의 노드와 두 개의 팟이 있는 다음 클러스터를 고려해보세요.\"</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<img src=\"/assets/img/2024-06-23-Challenge14bounce_0.png\">\n<p>외부 트래픽에 파드를 노출하는 NodePort 서비스가 있습니다.</p>\n<p>NodePort로 요청을 보내면, 해당 트래픽이 동일 노드의 파드 2에 도착할 확률은 얼마인가요?</p>\n<ul>\n<li>트래픽은 항상 파드 2에 도착합니다</li>\n<li>트래픽이 파드 2에 도착할 확률은 50% 입니다</li>\n<li>트래픽이 파드 2에 도착할 확률은 33% 입니다</li>\n<li>위의 어느 것도 아닙니다.</li>\n</ul>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h1>해결책</h1>\n<p>왜 그런지 이해하려면 Kube-proxy가 노드에 전달 규칙을 설정하는 방식을 살펴봐야 합니다 (예: iptables, ipvs, eBPF 등).</p>\n<p>NodePort를 생성하면 클러스터의 각 노드가 30000~32767 범위의 포트를 노출합니다. 30000번 포트로 가정해 보겠습니다.</p>\n<p><code>노드 IP</code>:30000으로 curl 요청을 발행하면 무슨 일이 일어날까요?</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>IP 헤더의 대상 IP 주소는 Kubernetes에 서비스가 존재하지 않기 때문에 다시 작성됩니다(그리고 그들은 트래픽을 리디렉션하고 전달하는 규칙의 모음일 뿐입니다).</p>\n<p>두 개의 파드 중 하나가 대상으로 선택되고, 트래픽이 해당 팟에 도달할 수 있습니다.</p>\n<p>그래서 각 팟은 트래픽을 받을 확률이 50%입니다.</p>\n<p>이는 클러스터에 있는 어느 노드에서 클러스터를 받았는지에 관계없이 발생합니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>하지만, 토론할 가치가 있는 두 가지 흥미로운 경계 사례가 있습니다:</p>\n<ul>\n<li>팟이 없는 노드를 만나면 여전히 트래픽이 팟 1 또는 팟 2로 리디렉션됩니다.</li>\n<li>팟 2를 포함한 두 번째 노드를 만나면 트래픽이 여전히 다른 팟으로 이동할 수 있습니다.</li>\n</ul>\n<p>이 두 경우 모두 현재 노드는 트래픽을 처리하지 않으며, 추가적인 홉이 발생합니다.</p>\n<p>이것이 낭비라고 생각할 수 있지만, 이는 타협점입니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>특정 테이블 태그를 마크다운 형식으로 변경하시면 추가 hop이 발생하여 포드 간에 우수한 인트라 클러스터 로드 밸런싱을 할 수 있거나 항상 서비스를 구성하여 현재 노드의 포드로 트래픽을 전달하도록 설정할 수 있습니다.</p>\n<p>대기시간이 향상되지만 요청을 부분적으로 로드 밸런싱할 수 있기 때문에 다른 포드보다 연결 수가 더 많은 포드를 얻을 수도 있습니다.</p>\n<p>이 내용이 마음에 드셨다면 아래 내용도 좋아하실 수 있습니다:</p>\n<ul>\n<li>Learnk8s에서 운영하는 Kubernetes 강좌.</li>\n<li>매주 발행하는 Learn Kubernetes Weekly 뉴스레터.</li>\n<li>20주 동안 게시한 20가지 Kubernetes 개념 시리즈.</li>\n</ul>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h1>링크</h1>\n<p>리소스 할당에 대해 더 자세히 알고 싶다면, 다음 자료를 꼭 확인해보세요:</p>\n<ul>\n<li><a href=\"https://medium.com/@danielepolencic/learn-why-you-cant-ping-a-kubernetes-service-dec88b55e1a3\" rel=\"nofollow\" target=\"_blank\">kubernetes service에 핑을 보낼 수 없는 이유</a></li>\n<li><a href=\"https://learnk8s.io/kubernetes-network-packets\" rel=\"nofollow\" target=\"_blank\">kubernetes 네트워크 패킷</a></li>\n</ul>\n</body>\n</html>\n"},"__N_SSG":true}