{"pageProps":{"post":{"title":"요청당 스레드 VS WebFlux VS 가상 스레드 최신 비교","description":"","date":"2024-06-22 22:10","slug":"2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads","content":"\n# 개요\n\n이 분석은 전통적인 명령형 코딩의 성능을 차단된 스레드와 비교하면서 REST 서비스에서 HTTP 요청을 처리하는 두 가지 접근 방식을 비교합니다: 반응형 프레임워크인 Spring-WebFlux와 Spring 3.2에서 최근 소개된 가상 스레드. 우리는 WebFlux의 논블로킹 기능을 구체적으로 검토하고 가상 스레드에서 제공되는 내장 논블로킹 기능과 어떻게 비교되는지 살펴볼 것입니다.\n\n# 사용 사례\n\n세 가지 서비스가 동일한 기능을 수행하며 사용하는 프레임워크만 다릅니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_0.png)\n\n# 테스트 준비\n\n- 사용한 머신: AWS t3.micro (2 vCPU, 1 GiB RAM) 및 Amazon Linux 2023.\n- 사용한 HTTP 클라이언트: ThreadPerRequest 및 VirtualThread의 RestClient, WebFlux의 WebClient.\n- Spring Boot 버전: 3.2.0\n- Java 버전: v21\n- 부하 테스트에 사용한 도구: jMeter 및 VisualVM\n\n# 측정 매개변수\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래 기준을 사용하여 성능을 측정하고 접근법/프레임워크를 평가할 예정이에요:\n\n- 더 높은 처리량 값은 더 나은 성능을 나타냅니다.\n- 더 낮은 99백분위수 지연 시간은 더 나은 성능을 나타냅니다.\n- 최적의 리소스 활용은 더 나은 성능을 나타냅니다.\n\n# 로드 테스트 성능\n\n# 0번째 로드 테스트\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n사용자 수: 150\n램프업: 10\n지속 시간: 100초\n\n## 기계 성능\n\n![이미지 1](/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_1.png)\n\n![이미지 2](/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_2.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![ThreadPerRequestVSWebFluxVSVirtualThreads_3](/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_3.png)\n\n## ThroughPut\n\n![ThreadPerRequestVSWebFluxVSVirtualThreads_4](/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_4.png)\n\n![ThreadPerRequestVSWebFluxVSVirtualThreads_5](/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_5.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Latency](/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_6.png)\n\n![Chart 1](/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_7.png)\n\n![Chart 2](/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_8.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_9.png\" />\n\n# 1’st LoadTest\n\n사용자: 200\n램프업: 10\n지속시간: 100초\n\n## 기계 성능\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 Markdown 형식으로 변환한 텍스트입니다.\n\n![image1](/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_10.png)\n\n![image2](/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_11.png)\n\n![image3](/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_12.png)\n\n## ThroughPut\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![ThreadPerRequestVSWebFluxVSVirtualThreads_13](/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_13.png)\n\n![ThreadPerRequestVSWebFluxVSVirtualThreads_14](/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_14.png)\n\n![ThreadPerRequestVSWebFluxVSVirtualThreads_15](/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_15.png)\n\n## Latency\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![image 16](/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_16.png)\n\n![image 17](/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_17.png)\n\n![image 18](/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_18.png)\n\n# 2’th LoadTest\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n사용자: 300\nRampUp: 10\n지속 시간: 100초\n\n## 기계 성능\n\n![이미지 1](/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_19.png)\n\n![이미지 2](/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_20.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![ThroughPut](/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_22.png)\n\n![Image](/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_23.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![](/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_24.png)\n\n## Latency\n\n![](/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_25.png)\n\n![](/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_26.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_27.png\" />\n\n# 3번째 부하 테스트\n\n사용자 수: 500명\n램프업: 10초\n지속 시간: 100초\n\n## 기계 성능\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![그림 28](/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_28.png)\n\n![그림 29](/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_29.png)\n\n![그림 30](/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_30.png)\n\n## 처리량\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 Markdown 형식으로 표시한 내용입니다.\n\n![Image 1](/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_31.png)\n\n![Image 2](/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_32.png)\n\n![Image 3](/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_33.png)\n\n## Latency\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Image 1](/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_34.png)\n\n![Image 2](/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_35.png)\n\n![Image 3](/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_36.png)\n\n# Summary\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_37.png\" />\n\n위 테스트 결과를 토대로 제 개인적인 관찰을 통해 얻은 결론을 아래에 소개합니다. 이것은 제 개인적인 의견일 뿐입니다.\n\n- 동시 요청 수가 증가할수록 WebFlux가 처리량 측면에서 ThreadPerRequest와 Virtual Threads 모델보다 우수함을 보여줍니다.\n- 지연 시간 측면에서도 WebFlux가 약간 향상됩니다. 다만 처리량만큼 명확하게 드러나지는 않습니다.\n- 그러나 WebFlux의 지연 시간은 다른 모델의 간헐적인 짧은 피크와는 달리 안정적입니다.\n- CPU 사용량 측면에서, WebFlux는 저하되는 부하에서 ThreadPerRequest와 Virtual Threads보다 더 많은 CPU를 소비하는 경향이 있습니다. 그러나 부하가 증가할수록 WebFlux 간의 CPU 사용량은 비교 가능해집니다.\n- 힙 활용 측면에서도 ThreadPerRequest와 Virtual Threads가 더 많은 메모리를 사용하는 것으로 나타납니다.\n\n이러한 테스트 결과를 토대로 WebFlux가 우세함을 입증했습니다! 그러나 이 문서는 WebFlux를 Virtual Threads보다 우선시하도록 밀어붙이고자 하는 것이 아닙니다. 선택은 특정 프로젝트와 팀이 반응형 접근 방식에 친숙한지에 따라 다를 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_0.png"},"coverImage":"/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_0.png","tag":["Tech"],"readingTime":10},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<h1>개요</h1>\n<p>이 분석은 전통적인 명령형 코딩의 성능을 차단된 스레드와 비교하면서 REST 서비스에서 HTTP 요청을 처리하는 두 가지 접근 방식을 비교합니다: 반응형 프레임워크인 Spring-WebFlux와 Spring 3.2에서 최근 소개된 가상 스레드. 우리는 WebFlux의 논블로킹 기능을 구체적으로 검토하고 가상 스레드에서 제공되는 내장 논블로킹 기능과 어떻게 비교되는지 살펴볼 것입니다.</p>\n<h1>사용 사례</h1>\n<p>세 가지 서비스가 동일한 기능을 수행하며 사용하는 프레임워크만 다릅니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p><img src=\"/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_0.png\" alt=\"이미지\"></p>\n<h1>테스트 준비</h1>\n<ul>\n<li>사용한 머신: AWS t3.micro (2 vCPU, 1 GiB RAM) 및 Amazon Linux 2023.</li>\n<li>사용한 HTTP 클라이언트: ThreadPerRequest 및 VirtualThread의 RestClient, WebFlux의 WebClient.</li>\n<li>Spring Boot 버전: 3.2.0</li>\n<li>Java 버전: v21</li>\n<li>부하 테스트에 사용한 도구: jMeter 및 VisualVM</li>\n</ul>\n<h1>측정 매개변수</h1>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>아래 기준을 사용하여 성능을 측정하고 접근법/프레임워크를 평가할 예정이에요:</p>\n<ul>\n<li>더 높은 처리량 값은 더 나은 성능을 나타냅니다.</li>\n<li>더 낮은 99백분위수 지연 시간은 더 나은 성능을 나타냅니다.</li>\n<li>최적의 리소스 활용은 더 나은 성능을 나타냅니다.</li>\n</ul>\n<h1>로드 테스트 성능</h1>\n<h1>0번째 로드 테스트</h1>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>사용자 수: 150\n램프업: 10\n지속 시간: 100초</p>\n<h2>기계 성능</h2>\n<p><img src=\"/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_1.png\" alt=\"이미지 1\"></p>\n<p><img src=\"/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_2.png\" alt=\"이미지 2\"></p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p><img src=\"/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_3.png\" alt=\"ThreadPerRequestVSWebFluxVSVirtualThreads_3\"></p>\n<h2>ThroughPut</h2>\n<p><img src=\"/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_4.png\" alt=\"ThreadPerRequestVSWebFluxVSVirtualThreads_4\"></p>\n<p><img src=\"/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_5.png\" alt=\"ThreadPerRequestVSWebFluxVSVirtualThreads_5\"></p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p><img src=\"/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_6.png\" alt=\"Latency\"></p>\n<p><img src=\"/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_7.png\" alt=\"Chart 1\"></p>\n<p><img src=\"/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_8.png\" alt=\"Chart 2\"></p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<img src=\"/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_9.png\">\n<h1>1’st LoadTest</h1>\n<p>사용자: 200\n램프업: 10\n지속시간: 100초</p>\n<h2>기계 성능</h2>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>아래는 Markdown 형식으로 변환한 텍스트입니다.</p>\n<p><img src=\"/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_10.png\" alt=\"image1\"></p>\n<p><img src=\"/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_11.png\" alt=\"image2\"></p>\n<p><img src=\"/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_12.png\" alt=\"image3\"></p>\n<h2>ThroughPut</h2>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p><img src=\"/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_13.png\" alt=\"ThreadPerRequestVSWebFluxVSVirtualThreads_13\"></p>\n<p><img src=\"/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_14.png\" alt=\"ThreadPerRequestVSWebFluxVSVirtualThreads_14\"></p>\n<p><img src=\"/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_15.png\" alt=\"ThreadPerRequestVSWebFluxVSVirtualThreads_15\"></p>\n<h2>Latency</h2>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p><img src=\"/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_16.png\" alt=\"image 16\"></p>\n<p><img src=\"/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_17.png\" alt=\"image 17\"></p>\n<p><img src=\"/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_18.png\" alt=\"image 18\"></p>\n<h1>2’th LoadTest</h1>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>사용자: 300\nRampUp: 10\n지속 시간: 100초</p>\n<h2>기계 성능</h2>\n<p><img src=\"/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_19.png\" alt=\"이미지 1\"></p>\n<p><img src=\"/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_20.png\" alt=\"이미지 2\"></p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p><img src=\"/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_22.png\" alt=\"ThroughPut\"></p>\n<p><img src=\"/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_23.png\" alt=\"Image\"></p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p><img src=\"/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_24.png\" alt=\"\"></p>\n<h2>Latency</h2>\n<p><img src=\"/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_25.png\" alt=\"\"></p>\n<p><img src=\"/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_26.png\" alt=\"\"></p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<img src=\"/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_27.png\">\n<h1>3번째 부하 테스트</h1>\n<p>사용자 수: 500명\n램프업: 10초\n지속 시간: 100초</p>\n<h2>기계 성능</h2>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p><img src=\"/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_28.png\" alt=\"그림 28\"></p>\n<p><img src=\"/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_29.png\" alt=\"그림 29\"></p>\n<p><img src=\"/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_30.png\" alt=\"그림 30\"></p>\n<h2>처리량</h2>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>아래는 Markdown 형식으로 표시한 내용입니다.</p>\n<p><img src=\"/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_31.png\" alt=\"Image 1\"></p>\n<p><img src=\"/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_32.png\" alt=\"Image 2\"></p>\n<p><img src=\"/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_33.png\" alt=\"Image 3\"></p>\n<h2>Latency</h2>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p><img src=\"/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_34.png\" alt=\"Image 1\"></p>\n<p><img src=\"/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_35.png\" alt=\"Image 2\"></p>\n<p><img src=\"/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_36.png\" alt=\"Image 3\"></p>\n<h1>Summary</h1>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<img src=\"/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_37.png\">\n<p>위 테스트 결과를 토대로 제 개인적인 관찰을 통해 얻은 결론을 아래에 소개합니다. 이것은 제 개인적인 의견일 뿐입니다.</p>\n<ul>\n<li>동시 요청 수가 증가할수록 WebFlux가 처리량 측면에서 ThreadPerRequest와 Virtual Threads 모델보다 우수함을 보여줍니다.</li>\n<li>지연 시간 측면에서도 WebFlux가 약간 향상됩니다. 다만 처리량만큼 명확하게 드러나지는 않습니다.</li>\n<li>그러나 WebFlux의 지연 시간은 다른 모델의 간헐적인 짧은 피크와는 달리 안정적입니다.</li>\n<li>CPU 사용량 측면에서, WebFlux는 저하되는 부하에서 ThreadPerRequest와 Virtual Threads보다 더 많은 CPU를 소비하는 경향이 있습니다. 그러나 부하가 증가할수록 WebFlux 간의 CPU 사용량은 비교 가능해집니다.</li>\n<li>힙 활용 측면에서도 ThreadPerRequest와 Virtual Threads가 더 많은 메모리를 사용하는 것으로 나타납니다.</li>\n</ul>\n<p>이러한 테스트 결과를 토대로 WebFlux가 우세함을 입증했습니다! 그러나 이 문서는 WebFlux를 Virtual Threads보다 우선시하도록 밀어붙이고자 하는 것이 아닙니다. 선택은 특정 프로젝트와 팀이 반응형 접근 방식에 친숙한지에 따라 다를 수 있습니다.</p>\n</body>\n</html>\n"},"__N_SSG":true}