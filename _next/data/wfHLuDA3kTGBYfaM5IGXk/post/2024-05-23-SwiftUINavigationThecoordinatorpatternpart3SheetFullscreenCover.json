{"pageProps":{"post":{"title":"SwiftUI 네비게이션 - 코디네이터 패턴 - 파트 3 시트, FullscreenCover","description":"","date":"2024-05-23 13:10","slug":"2024-05-23-SwiftUINavigationThecoordinatorpatternpart3SheetFullscreenCover","content":"\n![이미지](/assets/img/2024-05-23-SwiftUINavigationThecoordinatorpatternpart3SheetFullscreenCover_0.png)\n\n이 글은 이전 글들을 이어서 작성되었으며, 그 위에 쌓아 올릴 것입니다.\nSwiftUI 네비게이션 파트 1 — 푸시 네비게이션\nSwiftUI 네비게이션 파트 2 — 알림\n\n이 글에서는 Sheets 및 FullscreenCovers을 동시에 다룰 것이며, 이들은 동일한 방식으로 구현됩니다.\n\n시작해 봅시다! 이전 글들에서는 결정적 목적지로 조정하기 위해 Routes를 사용했습니다. 그러나 SwiftUI는 어떻게 이루어지는 걸까요?\n뷰 계층 구조의 루트에 있는 NavigationStack에 대한 네비게이션 경로에 대한 바인딩이 있습니다. Apple의 문서 예제를 살펴보겠습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nNavigationStack(path: $presentedParks) {\n    List(parks) { park in\n        NavigationLink(park.name, value: park)\n    }\n    .navigationDestination(for: Park.self) { park in\n        ParkDetails(park: park)\n    }\n}\n```\n\n우리는 NavigationStack 라는 뷰가 있습니다. 이 뷰를 통해 일부 데이터 유형의 바인딩을 통해 .navigationDestination이라는 뷰 수정자에서 제공된 뷰로 이동할 수 있습니다 🤔 어떻게 보면 흥미로운 것 같네요.\n\n그럼 이 뷰 수정자가 무엇인지 궁금하죠? 프레임워크 문서에서 더 자세히 살펴봐 봅시다.\n\n```js\n/// 스택에 한 개 이상의 네비게이션 대상 수정자를 추가할 수 있습니다.\n/// 여러 데이터 유형을 표시해야 하는 경우 스택에 네비게이션 대상 수정자를 여러 개 추가할 수 있습니다.\n///\n/// \"List\" 또는 \"LazyVStack\"과 같은 \"lazy\" 컨테이너 내부에 네비게이션 대상 수정자를 넣지 마세요.\n/// 이러한 컨테이너는 화면에 렌더링할 때 필요한 경우에만 자식 뷰를 생성합니다.\n/// 항상 네비게이션 대상 수정자를 이러한 컨테이너 외부에 추가하여 네비게이션 스택이 대상을 항상 볼 수 있도록 하세요.\n///\n/// - Parameters:\n///   - data: 이 대상이 일치하는 데이터의 유형입니다.\n///   - destination: 스택의 네비게이션 상태에 유형 'data'의 값을 포함하고 있을 때 표시할 뷰를 정의하는 뷰 빌더입니다.\n///     클로저는 데이터 값을 나타내는 하나의 인수를 사용합니다.\npublic func navigationDestination<D, C>(for data: D.Type, @ViewBuilder destination: @escaping (D) -> C) -> some View where D : Hashable, C : View\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n뭐 이건 Data.Type을 받아들이는 ViewModifier인데, 그런 다음에 destination이라고 불리는 클로저가 주입되는데, 이 클로저는 hashable해야 할 that Data.Type의 인스턴스를 주입하고 구체적인 View를 반환해야 해요...... 그렇죠. 😵\n\n또 다른 것은 .navigationDestination(\\_:)이 NavigationStack 내부의 View에 적용되어야 하며, NavigationStack의 범위 외부에 적용할 수 없다는 것을 주의해야 해요. 🤔\n\n뷰 계층 구조를 통해 데이터를 상위 뷰로 전파하는 유사한 시그니처를 가진 다른 것이 있어요. 이것이 바로 데이터를 뷰의 부모에게 전달하는 데 사용되는 PreferenceKeys입니다!\n\nPreferenceKeys를 사용하여 .navigationDestination(\\_:)이 NavigationStack에 하는 것처럼 내비게이션 목적지를 전달할 수 있을까요?\n우리는 곧 알게 될 거예요!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n시트 및 풀스크린 커버의 ViewModifier를 검사해 봅시다.\n\n```js\n    public func sheet<Item, Content>(item: Binding<Item?>, onDismiss: (() -> Void)? = nil, @ViewBuilder content: @escaping (Item) -> Content) -> some View where Item : Identifiable, Content : View\n\n    public func fullScreenCover<Item, Content>(item: Binding<Item?>, onDismiss: (() -> Void)? = nil, @ViewBuilder content: @escaping (Item) -> Content) -> some View where Item : Identifiable, Content : View\n```\n\n이들은 서로 거의 동일하며 navigationDestination(\\_:)과도 매우 유사합니다. 주요 차이점은 나타낼 아이템에 대한 바인딩이 Hashable 대신 Identifiable을 준수해야 하며 전달할 수 있는 선택적인 onDismiss 클로저가 있는 것입니다.\n\nRoutes도 Identifiable을 준수하도록 만들어 보겠습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nenum FirstTabCoordinatorRoute: Codable, Hashable, Identifiable { // <-- Identifiable\n    var id: String { String(describing: self) }\n\n    case detailView\n    case secondDetailView(String)\n}\n```\n\n이제 루트를 처리하는 ViewModifier를 만들어야 합니다. navigationDestination(_:)가 어떻게 작동하는지 더 잘 이해하려고 했고, navigationDestination(_:)와 동일하게 목적지를 뷰 계층 구조로 전달할 수 있는 방법을 재현해 볼 수 있을지 생각했습니다.\n\n내가 알기로는 뷰 계층 구조로 데이터를 전송하는 유일한 방법은 PreferenceKeys이니까 그것부터 시작하겠습니다.\n그러나 몇 가지 기준이 있습니다. 어떤 경로에 대해서도 작동하고 다른 경로에 대한 모든 목적지를 해결할 수 있어야합니다. 이 기준으로 인해 타입 지워를 사용해야 합니다. 다음과 같이 PreferenceKeys를 생성해 봅시다.\n\n```js\nstruct SheetFactoryKey: PreferenceKey {\n    static var defaultValue: [String: NavigationViewFactory] = [:]\n    static func reduce(value: inout [String: NavigationViewFactory], nextValue: () -> [String: NavigationViewFactory]) { value.merge(nextValue()) { $1 } } // reduce all into one value (dictionary)\n}\n\nstruct CoverFactoryKey: PreferenceKey {\n    static var defaultValue: [String: NavigationViewFactory] = [:]\n    static func reduce(value: inout [String: NavigationViewFactory], nextValue: () -> [String: NavigationViewFactory]) { value.merge(nextValue()) { $1 } }\n}\n\nextension View {\n    public func sheetDestination<D,C>(for data: D.Type, @ViewBuilder sheet: @escaping (D) -> C) -> some View where D: Identifiable & Hashable, C : View  {\n        preference(key: SheetFactoryKey.self, value: [String(describing: data): NavigationViewFactory(data, sheet)]) // <- Here we set the key to the data type's description! and pass our view factory\n    }\n\n    public func coverDestination<D,C>(for data: D.Type, @ViewBuilder cover: @escaping (D) -> C) -> some View where D: Identifiable & Hashable, C : View  {\n        preference(key: CoverFactoryKey.self, value: [String(describing: data): NavigationViewFactory(data, cover)])\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n네비게이션 목적지()가 sheetDestination()와 coverDestination() 선호 키 모두 호출자의 모든 값을 하나의 [String: NavigationViewFactory] 사전으로 줄입니다.\n\n기본적으로 여러 Coordinator가 있는 경우 각각이 자체 경로 유형을 위해 sheetDestination() 선호 키를 사용합니다. 이것은 PreferenceKeys에서 보내진 모든 값들을 하나의 사전으로 병합/줄이고, 문자열 키를 사용하여 작업하는 데이터 유형에 대한 식별자로 사용할 수 있습니다. 따라서 뷰 계층 구조를 통해 전달된 대응하는 예상 값에 접근할 수 있습니다. 이 값은 해당 목적지를 반환하는 데 도움이 됩니다.\n\n여기에는 데이터 유형을 설명하는 ID와 AnyView를 반환하는 타입 지워진 NavigationViewFactory가 있습니다.\nAnyView는 SwiftUI에서 제공되는 타입 지워진 뷰 래퍼로 성능에 부담이 있으므로 절약해서 사용해야 합니다. 그러나 한 번에 하나의 시트나 커버만 표시할 수 있기 때문에 수용할만한 것으로 보입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNavigationController로 다시 가서 코드를 추가해 봅시다.\n\n```js\n@Observable final class NavigationController {\n    var navigationPath = NavigationPath()\n    var alertPath = AlertPath()\n    var sheetPath: SheetPath = .init() // <- SheetPath를 생성해 봅시다\n    var coverPath: CoverPath = .init() // <- CoverPath를 생성해 봅시다\n\n    func presentSheet<T>(_ route: T, onDismiss: (() -> Void)? = nil)  where T: Codable & Identifiable & Hashable  {\n        sheetPath.setSheet(route, onDismiss: onDismiss)\n    }\n\n    func presentCover<T>(_ route: T, onDismiss: (() -> Void)? = nil)  where T: Codable & Identifiable & Hashable  {\n        coverPath.setCover(route, onDismiss: onDismiss)\n    }\n}\n\n// Sheet\nstruct SheetPath: Identifiable {\n    var id: String { sheet?.id ?? UUID().uuidString } // <- 현재 sheet의 id를 사용합니다.\n    var sheet: SheetContainer?\n\n    mutating func setSheet<T>(_ sheet: T, onDismiss: (() -> Void)? = nil) where T: Codable & Identifiable & Hashable  {\n        self.sheet = SheetContainer(sheet, onDismiss: onDismiss)\n    }\n}\n\nstruct SheetContainer: Identifiable {\n    let id: String\n    let sheet: Any\n    let onDismiss: (() -> Void)?\n\n    init<T>(_ sheet: T, onDismiss: (() -> Void)? = nil) where T: Codable & Identifiable & Hashable  {\n        self.id = String(describing: T.self)\n        self.sheet = sheet\n        self.onDismiss = onDismiss\n    }\n}\n\n// Fullscreen Cover\nstruct CoverPath: Identifiable {\n    var id: String { cover?.id ?? UUID().uuidString }\n    var cover: CoverContainer?\n\n    mutating func setCover<T>(_ cover: T, onDismiss: (() -> Void)? = nil) where T: Codable & Identifiable & Hashable  {\n        self.cover = CoverContainer(cover, onDismiss: onDismiss)\n    }\n}\n\nstruct CoverContainer: Identifiable {\n    let id: String\n    let cover: Any\n    let onDismiss: (() -> Void)?\n\n    init<T>(_ cover: T, onDismiss: (() -> Void)? = nil) where T: Codable & Identifiable & Hashable  {\n        self.id = String(describing: T.self)\n        self.cover = cover\n        self.onDismiss = onDismiss\n    }\n}\n```\n\n이 두 가지 구현 사항은 기본적으로 동일하며 같은 컨테이너, 경로, 함수 뷰 수정자 등을 사용하고 열거형 PresentationMode를 추가하여 sheet와 cover를 구분할 수 있는 case를 추가할 수 있습니다. 그러나 일관성을 유지하기 위해 이 예제에서는 이들을 분리해 두었습니다. 또한 SwiftUI가 이후에 여러 개의 sheet/cover를 지원한다면 별도로 처리하고자 할 수도 있습니다. 선택은 당신에게 맡깁니다. 지금까지 어떤 것들을 얻었나요?\n\n- NavigationController에는 이제 sheet 및 fullScreenCover에 대한 경로가 있습니다.\n- 우리는 데이터 작업의 구체적인 유형을 지우기 위해 타입 이레이저를 사용하지만, 우리가 수용할 수 있는 유형으로만 컨테이너를 초기화할 수 있도록 하여, 지워진 타입 값은 일종의 Identifiable, Hashable 및 Codable 유형이 되도록 보장합니다.\n- 또한, 해당 데이터 유형의 설명을 Identifiable 준수를위한 식별자로 저장하여 우리의 뷰 팩토리 콜백 딕셔너리에서 구분할 수 있도록 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여전히 함께 계신다니 너무 기쁘네요! 이제 모든 것을 함께 연결해보려 합니다.\n\n이제 시트를 표시하는 ViewModifier를 만들어야 합니다.\n\n```js\nextension View {\n    func sheet(for sheetPath: Binding<SheetPath>) -> some View {\n        modifier(SheetModifier(sheetPath: sheetPath))\n    }\n\n    func cover(for data: Binding<CoverPath>, onDismiss: (() -> Void)? = nil) -> some View {\n        modifier(CoverModifier(data: data))\n    }\n}\n\nstruct SheetModifier: ViewModifier {\n    @Binding var sheetPath: SheetPath\n    @State private var factories: [String: NavigationViewFactory] = [:]\n    private let onDismiss: (() -> Void)?\n\n    init(sheetPath: Binding<SheetPath>) {\n        self._sheetPath = sheetPath\n        self.onDismiss = sheetPath.wrappedValue.sheet?.onDismiss\n    }\n\n    func body(content: Content) -> some View {\n        content\n            .onPreferenceChange(SheetFactoryKey.self) { factories = $0 }\n            .sheet(item: _sheetPath.sheet, onDismiss: sheetPath.sheet?.onDismiss, content: { factories[sheetPath.id]?.factory($0.sheet) })\n    }\n}\n\nstruct CoverModifier: ViewModifier {\n    @Binding var data: CoverPath\n    @State private var factories: [String: NavigationViewFactory] = [:]\n    private let onDismiss: (() -> Void)?\n\n    init(data: Binding<CoverPath>) {\n        self._data = data\n        self.onDismiss = data.wrappedValue.cover?.onDismiss\n    }\n\n    func body(content: Content) -> some View {\n        content\n            .onPreferenceChange(CoverFactoryKey.self) { factories = $0 }\n            .fullScreenCover(item: _data.cover, onDismiss: data.cover?.onDismiss, content: { factories[data.id]?.factory($0.cover) })\n    }\n}\n```\n\n이게 뭐하는 거야? 모든 .sheetDestination()를 사용하는 코디네이터는 경로에 해당하는 코디네이션 함수를 뷰 계층 구조에 전달합니다. 그리고 sheetPath에 값을 설정하면 동일한 데이터 유형에 대한 viewFactory를 추출하고 데이터 인스턴스를 주입하여 메서드를 호출하여 대상을 반환할 것입니다. 모두 어떻게 함께 작동하는지 예제를 살펴봅시다.\n\n```js\nenum FirstTabCoordinatorRoute: Codable, Hashable, Identifiable {\n    var id: String { String(describing: self) }\n    ... 이전 경로들\n\n    case sheet // 선택 사항으로 연결된 값 전달 가능\n    case cover\n}\n\n@Observable final class FirstTabCoordinator: Coordinator {\n    ... 이전 코드\n\n    @ViewBuilder @MainActor var rootView: some View {\n        let viewModel = FirstViewModel(self)\n        FirstView(viewModel)\n            .navigationDestination(for: Route.self, destination: coordinate(_:))\n            .sheetDestination(for: Route.self, sheet: coordinate(_:))\n            .coverDestination(for: Route.self, cover: coordinate(_:))\n    }\n\n    func presentSheet(onDismiss: (() -> Void)? = nil) {\n        navigationController.presentSheet(Route.sheet, onDismiss: onDismiss)\n    }\n\n    func presentCover(onDismiss: (() -> Void)? = nil) {\n        navigationController.presentCover(Route.cover, onDismiss: onDismiss)\n    }\n\n    @ViewBuilder @MainActor func coordinate(_ route: Route) -> some View {\n        switch route {\n            ... 이전 경로들\n\n            case .sheet: SomeBranchedView()\n            case .cover: SomeCoverView()\n        }\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n와, 정말 깔끔하네요!\nrootView 계산 속성 내에서 PreferenceKeys를 설정하여 모든 정보가 코디네이터의 Route.Types를 해결하는 데 필요한 정보를 코디네이트(coordinates) 함수로 보냅니다. 이 함수는 특정 코디네이터가 좌표를 맡은 모든 뷰를 생성합니다. 🤔 꽤 괜찮죠.\n\n```js\nstruct CoordinatedView<C: Coordinator>: View {\n    private let coordinator: C\n\n    init(_ coordinator: C) {\n        self.coordinator = coordinator\n    }\n\n    var body: some View {\n        @Bindable var navigationController = coordinator.navigationController\n        NavigationStack(path: $navigationController.navigationPath) {\n            coordinator.rootView\n        }\n        .sheet(for: $navigationController.sheetPath)\n        .cover(for: $navigationController.coverPath)\n        .alert(for: $navigationController.alertPath)\n    }\n}\n```\n\n마지막으로 루트 CoordinatedView에 sheet 또는 cover를 적용하는 방법에 대해 다음과 같이 살펴보겠습니다. 이것도 꽤 깔끔하네요 😉\n\n그러니까 이 경우를 위해 우리의 view와 viewModel을 검사해봅시다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```swift\nstruct FirstView: View {\n    let viewModel: FirstViewModel\n\n    var body: some View {\n        VStack {\n            Text(\"First View\")\n            Button(\"상세 화면으로 이동\") {\n                viewModel.didTapButton()\n            }\n        }\n    }\n}\n\n@Observable class FirstViewModel {\n\n    private let coordinator: FirstTabCoordinator\n\n    init(coordinator: FirstTabCoordinator) {\n        self.coordinator = coordinator\n    }\n\n    func didTapButton() {\n        coordinator.presentSheet {\n          // closure called onDismiss\n        }\n    }\n}\n```\n\n우리의 뷰는 didTapButton 이외에 무슨 일이 벌어지고 있는지 알 수 없습니다.\n\nℹ️ 또한 다른 필요한 수식어(modifier)들이 coordinate() 함수에서 반환되기 전에 뷰에 적용될 수 있습니다.\n\n예를 들어, 시트에 presentationDetents를 적용하려면. 그리고 뷰 내부에서 심지어 그것에 대해 알 필요조차 없을 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n@Observable final class FirstTabCoordinator: Coordinator {\n    ... 이전 코드\n\n    @ViewBuilder @MainActor func coordinate(_ route: Route) -> some View {\n        switch route {\n         ... 이전 루트\n\n        case .sheet: SomeBranchedView().presentationDetents([.medium, .large]) // 시트를 반으로 크기 조정하고 드래그 액션 등을 허용합니다.\n        case .cover: SomeCoverView()\n        }\n    }\n}\n```\n\n지금은 여기까지입니다.\n\n이 글에서 어떤 통찰을 얻으셨다면 좋겠네요. 피드백이나 개선 제안이 있다면 알려주세요. 이 글이 가치 있다고 느끼신다면 공유해주세요!\n\n즐거운 코딩하세요!\n","ogImage":{"url":"/assets/img/2024-05-23-SwiftUINavigationThecoordinatorpatternpart3SheetFullscreenCover_0.png"},"coverImage":"/assets/img/2024-05-23-SwiftUINavigationThecoordinatorpatternpart3SheetFullscreenCover_0.png","tag":["Tech"],"readingTime":16},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p><img src=\"/assets/img/2024-05-23-SwiftUINavigationThecoordinatorpatternpart3SheetFullscreenCover_0.png\" alt=\"이미지\"></p>\n<p>이 글은 이전 글들을 이어서 작성되었으며, 그 위에 쌓아 올릴 것입니다.\nSwiftUI 네비게이션 파트 1 — 푸시 네비게이션\nSwiftUI 네비게이션 파트 2 — 알림</p>\n<p>이 글에서는 Sheets 및 FullscreenCovers을 동시에 다룰 것이며, 이들은 동일한 방식으로 구현됩니다.</p>\n<p>시작해 봅시다! 이전 글들에서는 결정적 목적지로 조정하기 위해 Routes를 사용했습니다. 그러나 SwiftUI는 어떻게 이루어지는 걸까요?\n뷰 계층 구조의 루트에 있는 NavigationStack에 대한 네비게이션 경로에 대한 바인딩이 있습니다. Apple의 문서 예제를 살펴보겠습니다:</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title class_\">NavigationStack</span>(<span class=\"hljs-attr\">path</span>: $presentedParks) {\n    <span class=\"hljs-title class_\">List</span>(parks) { park <span class=\"hljs-keyword\">in</span>\n        <span class=\"hljs-title class_\">NavigationLink</span>(park.<span class=\"hljs-property\">name</span>, <span class=\"hljs-attr\">value</span>: park)\n    }\n    .<span class=\"hljs-title function_\">navigationDestination</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">for</span>: Park.self</span>) { park <span class=\"hljs-keyword\">in</span>\n        <span class=\"hljs-title class_\">ParkDetails</span>(<span class=\"hljs-attr\">park</span>: park)\n    }\n}\n</code></pre>\n<p>우리는 NavigationStack 라는 뷰가 있습니다. 이 뷰를 통해 일부 데이터 유형의 바인딩을 통해 .navigationDestination이라는 뷰 수정자에서 제공된 뷰로 이동할 수 있습니다 🤔 어떻게 보면 흥미로운 것 같네요.</p>\n<p>그럼 이 뷰 수정자가 무엇인지 궁금하죠? 프레임워크 문서에서 더 자세히 살펴봐 봅시다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">/// 스택에 한 개 이상의 네비게이션 대상 수정자를 추가할 수 있습니다.</span>\n<span class=\"hljs-comment\">/// 여러 데이터 유형을 표시해야 하는 경우 스택에 네비게이션 대상 수정자를 여러 개 추가할 수 있습니다.</span>\n<span class=\"hljs-comment\">///</span>\n<span class=\"hljs-comment\">/// \"List\" 또는 \"LazyVStack\"과 같은 \"lazy\" 컨테이너 내부에 네비게이션 대상 수정자를 넣지 마세요.</span>\n<span class=\"hljs-comment\">/// 이러한 컨테이너는 화면에 렌더링할 때 필요한 경우에만 자식 뷰를 생성합니다.</span>\n<span class=\"hljs-comment\">/// 항상 네비게이션 대상 수정자를 이러한 컨테이너 외부에 추가하여 네비게이션 스택이 대상을 항상 볼 수 있도록 하세요.</span>\n<span class=\"hljs-comment\">///</span>\n<span class=\"hljs-comment\">/// - Parameters:</span>\n<span class=\"hljs-comment\">///   - data: 이 대상이 일치하는 데이터의 유형입니다.</span>\n<span class=\"hljs-comment\">///   - destination: 스택의 네비게이션 상태에 유형 'data'의 값을 포함하고 있을 때 표시할 뷰를 정의하는 뷰 빌더입니다.</span>\n<span class=\"hljs-comment\">///     클로저는 데이터 값을 나타내는 하나의 인수를 사용합니다.</span>\npublic func navigationDestination&#x3C;D, C>(<span class=\"hljs-keyword\">for</span> <span class=\"hljs-attr\">data</span>: D.<span class=\"hljs-property\">Type</span>, @<span class=\"hljs-title class_\">ViewBuilder</span> <span class=\"hljs-attr\">destination</span>: @escaping (D) -> C) -> some <span class=\"hljs-title class_\">View</span> where D : <span class=\"hljs-title class_\">Hashable</span>, C : <span class=\"hljs-title class_\">View</span>\n</code></pre>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>뭐 이건 Data.Type을 받아들이는 ViewModifier인데, 그런 다음에 destination이라고 불리는 클로저가 주입되는데, 이 클로저는 hashable해야 할 that Data.Type의 인스턴스를 주입하고 구체적인 View를 반환해야 해요...... 그렇죠. 😵</p>\n<p>또 다른 것은 .navigationDestination(_:)이 NavigationStack 내부의 View에 적용되어야 하며, NavigationStack의 범위 외부에 적용할 수 없다는 것을 주의해야 해요. 🤔</p>\n<p>뷰 계층 구조를 통해 데이터를 상위 뷰로 전파하는 유사한 시그니처를 가진 다른 것이 있어요. 이것이 바로 데이터를 뷰의 부모에게 전달하는 데 사용되는 PreferenceKeys입니다!</p>\n<p>PreferenceKeys를 사용하여 .navigationDestination(_:)이 NavigationStack에 하는 것처럼 내비게이션 목적지를 전달할 수 있을까요?\n우리는 곧 알게 될 거예요!</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>시트 및 풀스크린 커버의 ViewModifier를 검사해 봅시다.</p>\n<pre><code class=\"hljs language-js\">    public func sheet&#x3C;<span class=\"hljs-title class_\">Item</span>, <span class=\"hljs-title class_\">Content</span>>(<span class=\"hljs-attr\">item</span>: <span class=\"hljs-title class_\">Binding</span>&#x3C;<span class=\"hljs-title class_\">Item</span>?>, <span class=\"hljs-attr\">onDismiss</span>: (() -> <span class=\"hljs-title class_\">Void</span>)? = nil, @<span class=\"hljs-title class_\">ViewBuilder</span> <span class=\"hljs-attr\">content</span>: @escaping (<span class=\"hljs-title class_\">Item</span>) -> <span class=\"hljs-title class_\">Content</span>) -> some <span class=\"hljs-title class_\">View</span> where <span class=\"hljs-title class_\">Item</span> : <span class=\"hljs-title class_\">Identifiable</span>, <span class=\"hljs-title class_\">Content</span> : <span class=\"hljs-title class_\">View</span>\n\n    public func fullScreenCover&#x3C;<span class=\"hljs-title class_\">Item</span>, <span class=\"hljs-title class_\">Content</span>>(<span class=\"hljs-attr\">item</span>: <span class=\"hljs-title class_\">Binding</span>&#x3C;<span class=\"hljs-title class_\">Item</span>?>, <span class=\"hljs-attr\">onDismiss</span>: (() -> <span class=\"hljs-title class_\">Void</span>)? = nil, @<span class=\"hljs-title class_\">ViewBuilder</span> <span class=\"hljs-attr\">content</span>: @escaping (<span class=\"hljs-title class_\">Item</span>) -> <span class=\"hljs-title class_\">Content</span>) -> some <span class=\"hljs-title class_\">View</span> where <span class=\"hljs-title class_\">Item</span> : <span class=\"hljs-title class_\">Identifiable</span>, <span class=\"hljs-title class_\">Content</span> : <span class=\"hljs-title class_\">View</span>\n</code></pre>\n<p>이들은 서로 거의 동일하며 navigationDestination(_:)과도 매우 유사합니다. 주요 차이점은 나타낼 아이템에 대한 바인딩이 Hashable 대신 Identifiable을 준수해야 하며 전달할 수 있는 선택적인 onDismiss 클로저가 있는 것입니다.</p>\n<p>Routes도 Identifiable을 준수하도록 만들어 보겠습니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-js\">enum <span class=\"hljs-title class_\">FirstTabCoordinatorRoute</span>: <span class=\"hljs-title class_\">Codable</span>, <span class=\"hljs-title class_\">Hashable</span>, <span class=\"hljs-title class_\">Identifiable</span> { <span class=\"hljs-comment\">// &#x3C;-- Identifiable</span>\n    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">id</span>: <span class=\"hljs-title class_\">String</span> { <span class=\"hljs-title class_\">String</span>(<span class=\"hljs-attr\">describing</span>: self) }\n\n    <span class=\"hljs-keyword\">case</span> detailView\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-title function_\">secondDetailView</span>(<span class=\"hljs-title class_\">String</span>)\n}\n</code></pre>\n<p>이제 루트를 처리하는 ViewModifier를 만들어야 합니다. navigationDestination(<em>:)가 어떻게 작동하는지 더 잘 이해하려고 했고, navigationDestination(</em>:)와 동일하게 목적지를 뷰 계층 구조로 전달할 수 있는 방법을 재현해 볼 수 있을지 생각했습니다.</p>\n<p>내가 알기로는 뷰 계층 구조로 데이터를 전송하는 유일한 방법은 PreferenceKeys이니까 그것부터 시작하겠습니다.\n그러나 몇 가지 기준이 있습니다. 어떤 경로에 대해서도 작동하고 다른 경로에 대한 모든 목적지를 해결할 수 있어야합니다. 이 기준으로 인해 타입 지워를 사용해야 합니다. 다음과 같이 PreferenceKeys를 생성해 봅시다.</p>\n<pre><code class=\"hljs language-js\">struct <span class=\"hljs-title class_\">SheetFactoryKey</span>: <span class=\"hljs-title class_\">PreferenceKey</span> {\n    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">defaultValue</span>: [<span class=\"hljs-title class_\">String</span>: <span class=\"hljs-title class_\">NavigationViewFactory</span>] = [:]\n    <span class=\"hljs-keyword\">static</span> func <span class=\"hljs-title function_\">reduce</span>(<span class=\"hljs-params\">value: inout [<span class=\"hljs-built_in\">String</span>: NavigationViewFactory], nextValue: () -> [<span class=\"hljs-built_in\">String</span>: NavigationViewFactory]</span>) { value.<span class=\"hljs-title function_\">merge</span>(<span class=\"hljs-params\">nextValue()</span>) { $1 } } <span class=\"hljs-comment\">// reduce all into one value (dictionary)</span>\n}\n\nstruct <span class=\"hljs-title class_\">CoverFactoryKey</span>: <span class=\"hljs-title class_\">PreferenceKey</span> {\n    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">defaultValue</span>: [<span class=\"hljs-title class_\">String</span>: <span class=\"hljs-title class_\">NavigationViewFactory</span>] = [:]\n    <span class=\"hljs-keyword\">static</span> func <span class=\"hljs-title function_\">reduce</span>(<span class=\"hljs-params\">value: inout [<span class=\"hljs-built_in\">String</span>: NavigationViewFactory], nextValue: () -> [<span class=\"hljs-built_in\">String</span>: NavigationViewFactory]</span>) { value.<span class=\"hljs-title function_\">merge</span>(<span class=\"hljs-params\">nextValue()</span>) { $1 } }\n}\n\nextension <span class=\"hljs-title class_\">View</span> {\n    public func sheetDestination&#x3C;D,C>(<span class=\"hljs-keyword\">for</span> <span class=\"hljs-attr\">data</span>: D.<span class=\"hljs-property\">Type</span>, @<span class=\"hljs-title class_\">ViewBuilder</span> <span class=\"hljs-attr\">sheet</span>: @escaping (D) -> C) -> some <span class=\"hljs-title class_\">View</span> where <span class=\"hljs-attr\">D</span>: <span class=\"hljs-title class_\">Identifiable</span> &#x26; <span class=\"hljs-title class_\">Hashable</span>, C : <span class=\"hljs-title class_\">View</span>  {\n        <span class=\"hljs-title function_\">preference</span>(<span class=\"hljs-attr\">key</span>: <span class=\"hljs-title class_\">SheetFactoryKey</span>.<span class=\"hljs-property\">self</span>, <span class=\"hljs-attr\">value</span>: [<span class=\"hljs-title class_\">String</span>(<span class=\"hljs-attr\">describing</span>: data): <span class=\"hljs-title class_\">NavigationViewFactory</span>(data, sheet)]) <span class=\"hljs-comment\">// &#x3C;- Here we set the key to the data type's description! and pass our view factory</span>\n    }\n\n    public func coverDestination&#x3C;D,C>(<span class=\"hljs-keyword\">for</span> <span class=\"hljs-attr\">data</span>: D.<span class=\"hljs-property\">Type</span>, @<span class=\"hljs-title class_\">ViewBuilder</span> <span class=\"hljs-attr\">cover</span>: @escaping (D) -> C) -> some <span class=\"hljs-title class_\">View</span> where <span class=\"hljs-attr\">D</span>: <span class=\"hljs-title class_\">Identifiable</span> &#x26; <span class=\"hljs-title class_\">Hashable</span>, C : <span class=\"hljs-title class_\">View</span>  {\n        <span class=\"hljs-title function_\">preference</span>(<span class=\"hljs-attr\">key</span>: <span class=\"hljs-title class_\">CoverFactoryKey</span>.<span class=\"hljs-property\">self</span>, <span class=\"hljs-attr\">value</span>: [<span class=\"hljs-title class_\">String</span>(<span class=\"hljs-attr\">describing</span>: data): <span class=\"hljs-title class_\">NavigationViewFactory</span>(data, cover)])\n    }\n}\n</code></pre>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>네비게이션 목적지()가 sheetDestination()와 coverDestination() 선호 키 모두 호출자의 모든 값을 하나의 [String: NavigationViewFactory] 사전으로 줄입니다.</p>\n<p>기본적으로 여러 Coordinator가 있는 경우 각각이 자체 경로 유형을 위해 sheetDestination() 선호 키를 사용합니다. 이것은 PreferenceKeys에서 보내진 모든 값들을 하나의 사전으로 병합/줄이고, 문자열 키를 사용하여 작업하는 데이터 유형에 대한 식별자로 사용할 수 있습니다. 따라서 뷰 계층 구조를 통해 전달된 대응하는 예상 값에 접근할 수 있습니다. 이 값은 해당 목적지를 반환하는 데 도움이 됩니다.</p>\n<p>여기에는 데이터 유형을 설명하는 ID와 AnyView를 반환하는 타입 지워진 NavigationViewFactory가 있습니다.\nAnyView는 SwiftUI에서 제공되는 타입 지워진 뷰 래퍼로 성능에 부담이 있으므로 절약해서 사용해야 합니다. 그러나 한 번에 하나의 시트나 커버만 표시할 수 있기 때문에 수용할만한 것으로 보입니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>NavigationController로 다시 가서 코드를 추가해 봅시다.</p>\n<pre><code class=\"hljs language-js\">@<span class=\"hljs-title class_\">Observable</span> final <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">NavigationController</span> {\n    <span class=\"hljs-keyword\">var</span> navigationPath = <span class=\"hljs-title class_\">NavigationPath</span>()\n    <span class=\"hljs-keyword\">var</span> alertPath = <span class=\"hljs-title class_\">AlertPath</span>()\n    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">sheetPath</span>: <span class=\"hljs-title class_\">SheetPath</span> = .<span class=\"hljs-title function_\">init</span>() <span class=\"hljs-comment\">// &#x3C;- SheetPath를 생성해 봅시다</span>\n    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">coverPath</span>: <span class=\"hljs-title class_\">CoverPath</span> = .<span class=\"hljs-title function_\">init</span>() <span class=\"hljs-comment\">// &#x3C;- CoverPath를 생성해 봅시다</span>\n\n    func presentSheet&#x3C;T>(_ <span class=\"hljs-attr\">route</span>: T, <span class=\"hljs-attr\">onDismiss</span>: (() -> <span class=\"hljs-title class_\">Void</span>)? = nil)  where <span class=\"hljs-attr\">T</span>: <span class=\"hljs-title class_\">Codable</span> &#x26; <span class=\"hljs-title class_\">Identifiable</span> &#x26; <span class=\"hljs-title class_\">Hashable</span>  {\n        sheetPath.<span class=\"hljs-title function_\">setSheet</span>(route, <span class=\"hljs-attr\">onDismiss</span>: onDismiss)\n    }\n\n    func presentCover&#x3C;T>(_ <span class=\"hljs-attr\">route</span>: T, <span class=\"hljs-attr\">onDismiss</span>: (() -> <span class=\"hljs-title class_\">Void</span>)? = nil)  where <span class=\"hljs-attr\">T</span>: <span class=\"hljs-title class_\">Codable</span> &#x26; <span class=\"hljs-title class_\">Identifiable</span> &#x26; <span class=\"hljs-title class_\">Hashable</span>  {\n        coverPath.<span class=\"hljs-title function_\">setCover</span>(route, <span class=\"hljs-attr\">onDismiss</span>: onDismiss)\n    }\n}\n\n<span class=\"hljs-comment\">// Sheet</span>\nstruct <span class=\"hljs-title class_\">SheetPath</span>: <span class=\"hljs-title class_\">Identifiable</span> {\n    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">id</span>: <span class=\"hljs-title class_\">String</span> { sheet?.<span class=\"hljs-property\">id</span> ?? <span class=\"hljs-title function_\">UUID</span>().<span class=\"hljs-property\">uuidString</span> } <span class=\"hljs-comment\">// &#x3C;- 현재 sheet의 id를 사용합니다.</span>\n    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">sheet</span>: <span class=\"hljs-title class_\">SheetContainer</span>?\n\n    mutating func setSheet&#x3C;T>(_ <span class=\"hljs-attr\">sheet</span>: T, <span class=\"hljs-attr\">onDismiss</span>: (() -> <span class=\"hljs-title class_\">Void</span>)? = nil) where <span class=\"hljs-attr\">T</span>: <span class=\"hljs-title class_\">Codable</span> &#x26; <span class=\"hljs-title class_\">Identifiable</span> &#x26; <span class=\"hljs-title class_\">Hashable</span>  {\n        self.<span class=\"hljs-property\">sheet</span> = <span class=\"hljs-title class_\">SheetContainer</span>(sheet, <span class=\"hljs-attr\">onDismiss</span>: onDismiss)\n    }\n}\n\nstruct <span class=\"hljs-title class_\">SheetContainer</span>: <span class=\"hljs-title class_\">Identifiable</span> {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">id</span>: <span class=\"hljs-title class_\">String</span>\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">sheet</span>: <span class=\"hljs-title class_\">Any</span>\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">onDismiss</span>: (() -> <span class=\"hljs-title class_\">Void</span>)?\n\n    init&#x3C;T>(_ <span class=\"hljs-attr\">sheet</span>: T, <span class=\"hljs-attr\">onDismiss</span>: (() -> <span class=\"hljs-title class_\">Void</span>)? = nil) where <span class=\"hljs-attr\">T</span>: <span class=\"hljs-title class_\">Codable</span> &#x26; <span class=\"hljs-title class_\">Identifiable</span> &#x26; <span class=\"hljs-title class_\">Hashable</span>  {\n        self.<span class=\"hljs-property\">id</span> = <span class=\"hljs-title class_\">String</span>(<span class=\"hljs-attr\">describing</span>: T.<span class=\"hljs-property\">self</span>)\n        self.<span class=\"hljs-property\">sheet</span> = sheet\n        self.<span class=\"hljs-property\">onDismiss</span> = onDismiss\n    }\n}\n\n<span class=\"hljs-comment\">// Fullscreen Cover</span>\nstruct <span class=\"hljs-title class_\">CoverPath</span>: <span class=\"hljs-title class_\">Identifiable</span> {\n    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">id</span>: <span class=\"hljs-title class_\">String</span> { cover?.<span class=\"hljs-property\">id</span> ?? <span class=\"hljs-title function_\">UUID</span>().<span class=\"hljs-property\">uuidString</span> }\n    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">cover</span>: <span class=\"hljs-title class_\">CoverContainer</span>?\n\n    mutating func setCover&#x3C;T>(_ <span class=\"hljs-attr\">cover</span>: T, <span class=\"hljs-attr\">onDismiss</span>: (() -> <span class=\"hljs-title class_\">Void</span>)? = nil) where <span class=\"hljs-attr\">T</span>: <span class=\"hljs-title class_\">Codable</span> &#x26; <span class=\"hljs-title class_\">Identifiable</span> &#x26; <span class=\"hljs-title class_\">Hashable</span>  {\n        self.<span class=\"hljs-property\">cover</span> = <span class=\"hljs-title class_\">CoverContainer</span>(cover, <span class=\"hljs-attr\">onDismiss</span>: onDismiss)\n    }\n}\n\nstruct <span class=\"hljs-title class_\">CoverContainer</span>: <span class=\"hljs-title class_\">Identifiable</span> {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">id</span>: <span class=\"hljs-title class_\">String</span>\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">cover</span>: <span class=\"hljs-title class_\">Any</span>\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">onDismiss</span>: (() -> <span class=\"hljs-title class_\">Void</span>)?\n\n    init&#x3C;T>(_ <span class=\"hljs-attr\">cover</span>: T, <span class=\"hljs-attr\">onDismiss</span>: (() -> <span class=\"hljs-title class_\">Void</span>)? = nil) where <span class=\"hljs-attr\">T</span>: <span class=\"hljs-title class_\">Codable</span> &#x26; <span class=\"hljs-title class_\">Identifiable</span> &#x26; <span class=\"hljs-title class_\">Hashable</span>  {\n        self.<span class=\"hljs-property\">id</span> = <span class=\"hljs-title class_\">String</span>(<span class=\"hljs-attr\">describing</span>: T.<span class=\"hljs-property\">self</span>)\n        self.<span class=\"hljs-property\">cover</span> = cover\n        self.<span class=\"hljs-property\">onDismiss</span> = onDismiss\n    }\n}\n</code></pre>\n<p>이 두 가지 구현 사항은 기본적으로 동일하며 같은 컨테이너, 경로, 함수 뷰 수정자 등을 사용하고 열거형 PresentationMode를 추가하여 sheet와 cover를 구분할 수 있는 case를 추가할 수 있습니다. 그러나 일관성을 유지하기 위해 이 예제에서는 이들을 분리해 두었습니다. 또한 SwiftUI가 이후에 여러 개의 sheet/cover를 지원한다면 별도로 처리하고자 할 수도 있습니다. 선택은 당신에게 맡깁니다. 지금까지 어떤 것들을 얻었나요?</p>\n<ul>\n<li>NavigationController에는 이제 sheet 및 fullScreenCover에 대한 경로가 있습니다.</li>\n<li>우리는 데이터 작업의 구체적인 유형을 지우기 위해 타입 이레이저를 사용하지만, 우리가 수용할 수 있는 유형으로만 컨테이너를 초기화할 수 있도록 하여, 지워진 타입 값은 일종의 Identifiable, Hashable 및 Codable 유형이 되도록 보장합니다.</li>\n<li>또한, 해당 데이터 유형의 설명을 Identifiable 준수를위한 식별자로 저장하여 우리의 뷰 팩토리 콜백 딕셔너리에서 구분할 수 있도록 합니다.</li>\n</ul>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>여전히 함께 계신다니 너무 기쁘네요! 이제 모든 것을 함께 연결해보려 합니다.</p>\n<p>이제 시트를 표시하는 ViewModifier를 만들어야 합니다.</p>\n<pre><code class=\"hljs language-js\">extension <span class=\"hljs-title class_\">View</span> {\n    func <span class=\"hljs-title function_\">sheet</span>(<span class=\"hljs-keyword\">for</span> <span class=\"hljs-attr\">sheetPath</span>: <span class=\"hljs-title class_\">Binding</span>&#x3C;<span class=\"hljs-title class_\">SheetPath</span>>) -> some <span class=\"hljs-title class_\">View</span> {\n        <span class=\"hljs-title function_\">modifier</span>(<span class=\"hljs-title class_\">SheetModifier</span>(<span class=\"hljs-attr\">sheetPath</span>: sheetPath))\n    }\n\n    func <span class=\"hljs-title function_\">cover</span>(<span class=\"hljs-keyword\">for</span> <span class=\"hljs-attr\">data</span>: <span class=\"hljs-title class_\">Binding</span>&#x3C;<span class=\"hljs-title class_\">CoverPath</span>>, <span class=\"hljs-attr\">onDismiss</span>: (() -> <span class=\"hljs-title class_\">Void</span>)? = nil) -> some <span class=\"hljs-title class_\">View</span> {\n        <span class=\"hljs-title function_\">modifier</span>(<span class=\"hljs-title class_\">CoverModifier</span>(<span class=\"hljs-attr\">data</span>: data))\n    }\n}\n\nstruct <span class=\"hljs-title class_\">SheetModifier</span>: <span class=\"hljs-title class_\">ViewModifier</span> {\n    @<span class=\"hljs-title class_\">Binding</span> <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">sheetPath</span>: <span class=\"hljs-title class_\">SheetPath</span>\n    @<span class=\"hljs-title class_\">State</span> private <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">factories</span>: [<span class=\"hljs-title class_\">String</span>: <span class=\"hljs-title class_\">NavigationViewFactory</span>] = [:]\n    private <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">onDismiss</span>: (() -> <span class=\"hljs-title class_\">Void</span>)?\n\n    <span class=\"hljs-title function_\">init</span>(<span class=\"hljs-params\">sheetPath: Binding&#x3C;SheetPath></span>) {\n        self.<span class=\"hljs-property\">_sheetPath</span> = sheetPath\n        self.<span class=\"hljs-property\">onDismiss</span> = sheetPath.<span class=\"hljs-property\">wrappedValue</span>.<span class=\"hljs-property\">sheet</span>?.<span class=\"hljs-property\">onDismiss</span>\n    }\n\n    func <span class=\"hljs-title function_\">body</span>(<span class=\"hljs-attr\">content</span>: <span class=\"hljs-title class_\">Content</span>) -> some <span class=\"hljs-title class_\">View</span> {\n        content\n            .<span class=\"hljs-title function_\">onPreferenceChange</span>(<span class=\"hljs-params\">SheetFactoryKey.self</span>) { factories = $0 }\n            .<span class=\"hljs-title function_\">sheet</span>(<span class=\"hljs-attr\">item</span>: _sheetPath.<span class=\"hljs-property\">sheet</span>, <span class=\"hljs-attr\">onDismiss</span>: sheetPath.<span class=\"hljs-property\">sheet</span>?.<span class=\"hljs-property\">onDismiss</span>, <span class=\"hljs-attr\">content</span>: { factories[sheetPath.<span class=\"hljs-property\">id</span>]?.<span class=\"hljs-title function_\">factory</span>($0.<span class=\"hljs-property\">sheet</span>) })\n    }\n}\n\nstruct <span class=\"hljs-title class_\">CoverModifier</span>: <span class=\"hljs-title class_\">ViewModifier</span> {\n    @<span class=\"hljs-title class_\">Binding</span> <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">data</span>: <span class=\"hljs-title class_\">CoverPath</span>\n    @<span class=\"hljs-title class_\">State</span> private <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">factories</span>: [<span class=\"hljs-title class_\">String</span>: <span class=\"hljs-title class_\">NavigationViewFactory</span>] = [:]\n    private <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">onDismiss</span>: (() -> <span class=\"hljs-title class_\">Void</span>)?\n\n    <span class=\"hljs-title function_\">init</span>(<span class=\"hljs-params\">data: Binding&#x3C;CoverPath></span>) {\n        self.<span class=\"hljs-property\">_data</span> = data\n        self.<span class=\"hljs-property\">onDismiss</span> = data.<span class=\"hljs-property\">wrappedValue</span>.<span class=\"hljs-property\">cover</span>?.<span class=\"hljs-property\">onDismiss</span>\n    }\n\n    func <span class=\"hljs-title function_\">body</span>(<span class=\"hljs-attr\">content</span>: <span class=\"hljs-title class_\">Content</span>) -> some <span class=\"hljs-title class_\">View</span> {\n        content\n            .<span class=\"hljs-title function_\">onPreferenceChange</span>(<span class=\"hljs-params\">CoverFactoryKey.self</span>) { factories = $0 }\n            .<span class=\"hljs-title function_\">fullScreenCover</span>(<span class=\"hljs-attr\">item</span>: _data.<span class=\"hljs-property\">cover</span>, <span class=\"hljs-attr\">onDismiss</span>: data.<span class=\"hljs-property\">cover</span>?.<span class=\"hljs-property\">onDismiss</span>, <span class=\"hljs-attr\">content</span>: { factories[data.<span class=\"hljs-property\">id</span>]?.<span class=\"hljs-title function_\">factory</span>($0.<span class=\"hljs-property\">cover</span>) })\n    }\n}\n</code></pre>\n<p>이게 뭐하는 거야? 모든 .sheetDestination()를 사용하는 코디네이터는 경로에 해당하는 코디네이션 함수를 뷰 계층 구조에 전달합니다. 그리고 sheetPath에 값을 설정하면 동일한 데이터 유형에 대한 viewFactory를 추출하고 데이터 인스턴스를 주입하여 메서드를 호출하여 대상을 반환할 것입니다. 모두 어떻게 함께 작동하는지 예제를 살펴봅시다.</p>\n<pre><code class=\"hljs language-js\">enum <span class=\"hljs-title class_\">FirstTabCoordinatorRoute</span>: <span class=\"hljs-title class_\">Codable</span>, <span class=\"hljs-title class_\">Hashable</span>, <span class=\"hljs-title class_\">Identifiable</span> {\n    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">id</span>: <span class=\"hljs-title class_\">String</span> { <span class=\"hljs-title class_\">String</span>(<span class=\"hljs-attr\">describing</span>: self) }\n    ... 이전 경로들\n\n    <span class=\"hljs-keyword\">case</span> sheet <span class=\"hljs-comment\">// 선택 사항으로 연결된 값 전달 가능</span>\n    <span class=\"hljs-keyword\">case</span> cover\n}\n\n@<span class=\"hljs-title class_\">Observable</span> final <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">FirstTabCoordinator</span>: <span class=\"hljs-title class_\">Coordinator</span> {\n    ... 이전 코드\n\n    @<span class=\"hljs-title class_\">ViewBuilder</span> @<span class=\"hljs-title class_\">MainActor</span> <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">rootView</span>: some <span class=\"hljs-title class_\">View</span> {\n        <span class=\"hljs-keyword\">let</span> viewModel = <span class=\"hljs-title class_\">FirstViewModel</span>(self)\n        <span class=\"hljs-title class_\">FirstView</span>(viewModel)\n            .<span class=\"hljs-title function_\">navigationDestination</span>(<span class=\"hljs-attr\">for</span>: <span class=\"hljs-title class_\">Route</span>.<span class=\"hljs-property\">self</span>, <span class=\"hljs-attr\">destination</span>: <span class=\"hljs-title function_\">coordinate</span>(<span class=\"hljs-attr\">_</span>:))\n            .<span class=\"hljs-title function_\">sheetDestination</span>(<span class=\"hljs-attr\">for</span>: <span class=\"hljs-title class_\">Route</span>.<span class=\"hljs-property\">self</span>, <span class=\"hljs-attr\">sheet</span>: <span class=\"hljs-title function_\">coordinate</span>(<span class=\"hljs-attr\">_</span>:))\n            .<span class=\"hljs-title function_\">coverDestination</span>(<span class=\"hljs-attr\">for</span>: <span class=\"hljs-title class_\">Route</span>.<span class=\"hljs-property\">self</span>, <span class=\"hljs-attr\">cover</span>: <span class=\"hljs-title function_\">coordinate</span>(<span class=\"hljs-attr\">_</span>:))\n    }\n\n    func <span class=\"hljs-title function_\">presentSheet</span>(<span class=\"hljs-params\">onDismiss: (() -> Void)? = nil</span>) {\n        navigationController.<span class=\"hljs-title function_\">presentSheet</span>(<span class=\"hljs-title class_\">Route</span>.<span class=\"hljs-property\">sheet</span>, <span class=\"hljs-attr\">onDismiss</span>: onDismiss)\n    }\n\n    func <span class=\"hljs-title function_\">presentCover</span>(<span class=\"hljs-params\">onDismiss: (() -> Void)? = nil</span>) {\n        navigationController.<span class=\"hljs-title function_\">presentCover</span>(<span class=\"hljs-title class_\">Route</span>.<span class=\"hljs-property\">cover</span>, <span class=\"hljs-attr\">onDismiss</span>: onDismiss)\n    }\n\n    @<span class=\"hljs-title class_\">ViewBuilder</span> @<span class=\"hljs-title class_\">MainActor</span> func <span class=\"hljs-title function_\">coordinate</span>(_ <span class=\"hljs-attr\">route</span>: <span class=\"hljs-title class_\">Route</span>) -> some <span class=\"hljs-title class_\">View</span> {\n        <span class=\"hljs-keyword\">switch</span> route {\n            ... 이전 경로들\n\n            <span class=\"hljs-keyword\">case</span> .<span class=\"hljs-property\">sheet</span>: <span class=\"hljs-title class_\">SomeBranchedView</span>()\n            <span class=\"hljs-keyword\">case</span> .<span class=\"hljs-property\">cover</span>: <span class=\"hljs-title class_\">SomeCoverView</span>()\n        }\n    }\n}\n</code></pre>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>와, 정말 깔끔하네요!\nrootView 계산 속성 내에서 PreferenceKeys를 설정하여 모든 정보가 코디네이터의 Route.Types를 해결하는 데 필요한 정보를 코디네이트(coordinates) 함수로 보냅니다. 이 함수는 특정 코디네이터가 좌표를 맡은 모든 뷰를 생성합니다. 🤔 꽤 괜찮죠.</p>\n<pre><code class=\"hljs language-js\">struct <span class=\"hljs-title class_\">CoordinatedView</span>&#x3C;<span class=\"hljs-attr\">C</span>: <span class=\"hljs-title class_\">Coordinator</span>>: <span class=\"hljs-title class_\">View</span> {\n    private <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">coordinator</span>: C\n\n    <span class=\"hljs-title function_\">init</span>(<span class=\"hljs-params\">_ coordinator: C</span>) {\n        self.<span class=\"hljs-property\">coordinator</span> = coordinator\n    }\n\n    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">body</span>: some <span class=\"hljs-title class_\">View</span> {\n        @<span class=\"hljs-title class_\">Bindable</span> <span class=\"hljs-keyword\">var</span> navigationController = coordinator.<span class=\"hljs-property\">navigationController</span>\n        <span class=\"hljs-title class_\">NavigationStack</span>(<span class=\"hljs-attr\">path</span>: $navigationController.<span class=\"hljs-property\">navigationPath</span>) {\n            coordinator.<span class=\"hljs-property\">rootView</span>\n        }\n        .<span class=\"hljs-title function_\">sheet</span>(<span class=\"hljs-attr\">for</span>: $navigationController.<span class=\"hljs-property\">sheetPath</span>)\n        .<span class=\"hljs-title function_\">cover</span>(<span class=\"hljs-attr\">for</span>: $navigationController.<span class=\"hljs-property\">coverPath</span>)\n        .<span class=\"hljs-title function_\">alert</span>(<span class=\"hljs-attr\">for</span>: $navigationController.<span class=\"hljs-property\">alertPath</span>)\n    }\n}\n</code></pre>\n<p>마지막으로 루트 CoordinatedView에 sheet 또는 cover를 적용하는 방법에 대해 다음과 같이 살펴보겠습니다. 이것도 꽤 깔끔하네요 😉</p>\n<p>그러니까 이 경우를 위해 우리의 view와 viewModel을 검사해봅시다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">FirstView</span>: <span class=\"hljs-title class_\">View</span> {\n    <span class=\"hljs-keyword\">let</span> viewModel: <span class=\"hljs-type\">FirstViewModel</span>\n\n    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> {\n        <span class=\"hljs-type\">VStack</span> {\n            <span class=\"hljs-type\">Text</span>(<span class=\"hljs-string\">\"First View\"</span>)\n            <span class=\"hljs-type\">Button</span>(<span class=\"hljs-string\">\"상세 화면으로 이동\"</span>) {\n                viewModel.didTapButton()\n            }\n        }\n    }\n}\n\n<span class=\"hljs-meta\">@Observable</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">FirstViewModel</span> {\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">let</span> coordinator: <span class=\"hljs-type\">FirstTabCoordinator</span>\n\n    <span class=\"hljs-keyword\">init</span>(<span class=\"hljs-params\">coordinator</span>: <span class=\"hljs-type\">FirstTabCoordinator</span>) {\n        <span class=\"hljs-keyword\">self</span>.coordinator <span class=\"hljs-operator\">=</span> coordinator\n    }\n\n    <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">didTapButton</span>() {\n        coordinator.presentSheet {\n          <span class=\"hljs-comment\">// closure called onDismiss</span>\n        }\n    }\n}\n</code></pre>\n<p>우리의 뷰는 didTapButton 이외에 무슨 일이 벌어지고 있는지 알 수 없습니다.</p>\n<p>ℹ️ 또한 다른 필요한 수식어(modifier)들이 coordinate() 함수에서 반환되기 전에 뷰에 적용될 수 있습니다.</p>\n<p>예를 들어, 시트에 presentationDetents를 적용하려면. 그리고 뷰 내부에서 심지어 그것에 대해 알 필요조차 없을 수 있습니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-js\">@<span class=\"hljs-title class_\">Observable</span> final <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">FirstTabCoordinator</span>: <span class=\"hljs-title class_\">Coordinator</span> {\n    ... 이전 코드\n\n    @<span class=\"hljs-title class_\">ViewBuilder</span> @<span class=\"hljs-title class_\">MainActor</span> func <span class=\"hljs-title function_\">coordinate</span>(_ <span class=\"hljs-attr\">route</span>: <span class=\"hljs-title class_\">Route</span>) -> some <span class=\"hljs-title class_\">View</span> {\n        <span class=\"hljs-keyword\">switch</span> route {\n         ... 이전 루트\n\n        <span class=\"hljs-keyword\">case</span> .<span class=\"hljs-property\">sheet</span>: <span class=\"hljs-title class_\">SomeBranchedView</span>().<span class=\"hljs-title function_\">presentationDetents</span>([.<span class=\"hljs-property\">medium</span>, .<span class=\"hljs-property\">large</span>]) <span class=\"hljs-comment\">// 시트를 반으로 크기 조정하고 드래그 액션 등을 허용합니다.</span>\n        <span class=\"hljs-keyword\">case</span> .<span class=\"hljs-property\">cover</span>: <span class=\"hljs-title class_\">SomeCoverView</span>()\n        }\n    }\n}\n</code></pre>\n<p>지금은 여기까지입니다.</p>\n<p>이 글에서 어떤 통찰을 얻으셨다면 좋겠네요. 피드백이나 개선 제안이 있다면 알려주세요. 이 글이 가치 있다고 느끼신다면 공유해주세요!</p>\n<p>즐거운 코딩하세요!</p>\n</body>\n</html>\n"},"__N_SSG":true}