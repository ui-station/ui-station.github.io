{"pageProps":{"post":{"title":"Swift에서 weak와 unowned의 차이점 예제 포함","description":"","date":"2024-06-22 23:14","slug":"2024-06-22-DifferencesbetweenweakandunownedinSwiftwithexamples","content":"\n<img src=\"/assets/img/2024-06-22-DifferencesbetweenweakandunownedinSwiftwithexamples_0.png\" />\n\n# 소개\n\nSwift에서는 메모리 관리가 ARC(Automatic Reference Counting)를 통해 이루어집니다. weak 및 unowned 참조의 주요 개념을 이해하는 것은 메모리 누수와 강한 참조 순환을 방지하는 데 매우 중요합니다. 이러한 참조들이 어떻게 다르며 올바르게 사용하는 방법을 알아보겠습니다.\n\n# weak 참조\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n약한 참조는 한 객체가 다른 객체 없이 존재할 수 있을 때 사용됩니다. 이는 객체의 참조 카운트를 증가시키지 않아 강력한 참조 순환을 방지하는 데 도움이 됩니다.\n\n약한 참조의 특징:\n\n- 가리키는 객체가 해제될 수 있기 때문에 항상 옵셔널 변수(var)로 선언됩니다. 이 경우에 참조는 nil이 됩니다.\n- 델리게이트와 클로저를 사용할 때 메모리 누수를 방지하는 데 특히 유용합니다.\n\n약한 참조를 사용한 예시:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```swift\nclass Department {\n    var manager: Employee?\n\n    deinit {\n        print(\"Department is being deinitialized\")\n    }\n}\n\nclass Employee {\n    weak var department: Department?\n\n    deinit {\n        print(\"Employee is being deinitialized\")\n    }\n}\n\nvar department: Department? = Department()\nvar manager: Employee? = Employee()\n\ndepartment?.manager = manager\nmanager?.department = department\n\ndepartment = nil\nmanager = nil\n// Prints: \"Employee is being deinitialized\" and then \"Department is being deinitialized\"\n\n```\n\n이 예시에서, Department와 Employee간의 연결을 끊음으로써 메모리 누수를 피할 수 있습니다.\n\n## 클로저에서 weak 사용\n\n클로저에서 weak를 사용하는 것은 강한 참조 순환을 방지하기 위해 종종 필요한데, 특히 클로저가 self, 즉 클래스 인스턴스를 캡처할 때입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nViewController 클래스는 비동기 작업을 수행하는 클래스입니다. 이 작업이 완료된 후에 코드가 실행되도록 하고, 동시에 강한 참조 순환에 의한 메모리 누수를 방지해야 합니다.\n\nweak 키워드를 사용한 예시:\n\n```js\nclass ViewController: UIViewController {\n    var dataLoader: DataLoader?\n\n    func fetchData() {\n        dataLoader?.loadData(completion: { [weak self] result in\n            guard let self = self else { return }\n\n            switch result {\n            case .success(let data):\n                self.updateUI(with: data)\n            case .failure(let error):\n                self.showErrorMessage(error)\n            }\n        })\n    }\n\n    private func updateUI(with data: Data) {\n        // 사용자 인터페이스 업데이트\n    }\n\n    private func showErrorMessage(_ error: Error) {\n        // 에러 메시지 표시\n    }\n}\n\nclass DataLoader {\n    func loadData(completion: @escaping (Result<Data, Error>) -> Void) {\n        // 데이터 로드 코드\n    }\n}\n```\n\n위 예시에서:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- ViewController에는 DataLoader의 loadData 메서드를 호출하는 fetchData 메서드가 있습니다.\n- loadData에 전달된 클로저 내에서 [weak self]를 사용하여 ViewController의 인스턴스인 self에 강한 참조를 방지합니다. 이는 DataLoader가 클로저를 오랫동안 유지할 수 있기 때문에 중요합니다. 예를 들어 비동기 작업 중에 발생할 수 있습니다.\n- 클로저 내에서 self에 안전하게 액세스하기 위해 guard let self = self else 'return'을 사용합니다. 만약 ViewController가 클로저가 실행되기 전에 해제되면 self는 nil이 되어 클로저 내의 코드가 실행되지 않아 잠재적인 오류나 충돌을 방지합니다.\n\n# unowned 참조\n\nunowned 참조는 weak와 유사하지만 두 가지 주요 차이점이 있습니다: 옵셔널이 아니며, 가리키는 객체가 해제될 때 nil이 되지 않습니다.\n\n## unowned 참조의 특징:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 다른 객체가 해제되기 전까지 한 객체를 해제하지 않을 때 사용됩니다.\n- 객체가 해제된 후 비소유 참조에 접근하면 충돌이 발생합니다.\n- 상수(let)와 함께만 작동합니다.\n\n비소유 참조를 사용한 예시:\n\n```js\nclass Customer {\n    let name: String\n    var card: CreditCard?\n\n    init(name: String) {\n        self.name = name\n    }\n\n    deinit {\n        print(\"\\(name) 해제 중\")\n    }\n}\n\nclass CreditCard {\n    let number: UInt64\n    unowned let customer: Customer\n\n    init(number: UInt64, customer: Customer) {\n        self.number = number\n        self.customer = customer\n    }\n\n    deinit {\n        print(\"카드 #\\(number) 해제 중\")\n    }\n}\n\nvar john: Customer? = Customer(name: \"John\")\njohn!.card = CreditCard(number: 1234_5678_9012_3456, customer: john!)\n\njohn = nil\n// 출력: \"John 해제 중\" 그리고 \"카드 #1234567890123456 해제 중\"\n```\n\n여기서 Customer가 해제된 후 관련된 CreditCard 객체도 해제되어 메모리 누수를 방지합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 약한 참조와 미소유 참조 비교\n\n- 선언: 약한 참조는 항상 옵셔널이지만, 미소유 참조는 상수로 값이 옵셔널이 아닙니다.\n- 강한 참조 순환: 둘 다 강한 참조 순환을 방지하지만, 각각 다른 상황에서 사용됩니다.\n- 안전성: 약한 참조는 객체가 해제될 때 자동으로 nil이 되어 안전합니다. 미소유 참조는 객체가 파괴되면 크래시가 발생할 수 있습니다. 무엇을 하는지 잘 알아야 합니다.\n\n# 결론\n\nSwift에서 약한 참조와 미소유 참조의 차이를 이해하는 것은 안전하고 효율적인 메모리 관리를 위해 중요합니다. 두 참조 사이의 선택은 애플리케이션의 구조와 객체 간 관계에 따라 다릅니다. 항상 메모리 누수를 확인하여 신뢰성과 성능을 보증할 수 있도록 코드를 테스트하세요.\n","ogImage":{"url":"/assets/img/2024-06-22-DifferencesbetweenweakandunownedinSwiftwithexamples_0.png"},"coverImage":"/assets/img/2024-06-22-DifferencesbetweenweakandunownedinSwiftwithexamples_0.png","tag":["Tech"],"readingTime":6},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<img src=\"/assets/img/2024-06-22-DifferencesbetweenweakandunownedinSwiftwithexamples_0.png\">\n<h1>소개</h1>\n<p>Swift에서는 메모리 관리가 ARC(Automatic Reference Counting)를 통해 이루어집니다. weak 및 unowned 참조의 주요 개념을 이해하는 것은 메모리 누수와 강한 참조 순환을 방지하는 데 매우 중요합니다. 이러한 참조들이 어떻게 다르며 올바르게 사용하는 방법을 알아보겠습니다.</p>\n<h1>weak 참조</h1>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>약한 참조는 한 객체가 다른 객체 없이 존재할 수 있을 때 사용됩니다. 이는 객체의 참조 카운트를 증가시키지 않아 강력한 참조 순환을 방지하는 데 도움이 됩니다.</p>\n<p>약한 참조의 특징:</p>\n<ul>\n<li>가리키는 객체가 해제될 수 있기 때문에 항상 옵셔널 변수(var)로 선언됩니다. 이 경우에 참조는 nil이 됩니다.</li>\n<li>델리게이트와 클로저를 사용할 때 메모리 누수를 방지하는 데 특히 유용합니다.</li>\n</ul>\n<p>약한 참조를 사용한 예시:</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Department</span> {\n    <span class=\"hljs-keyword\">var</span> manager: <span class=\"hljs-type\">Employee</span>?\n\n    <span class=\"hljs-keyword\">deinit</span> {\n        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Department is being deinitialized\"</span>)\n    }\n}\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Employee</span> {\n    <span class=\"hljs-keyword\">weak</span> <span class=\"hljs-keyword\">var</span> department: <span class=\"hljs-type\">Department</span>?\n\n    <span class=\"hljs-keyword\">deinit</span> {\n        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Employee is being deinitialized\"</span>)\n    }\n}\n\n<span class=\"hljs-keyword\">var</span> department: <span class=\"hljs-type\">Department</span>? <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">Department</span>()\n<span class=\"hljs-keyword\">var</span> manager: <span class=\"hljs-type\">Employee</span>? <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">Employee</span>()\n\ndepartment<span class=\"hljs-operator\">?</span>.manager <span class=\"hljs-operator\">=</span> manager\nmanager<span class=\"hljs-operator\">?</span>.department <span class=\"hljs-operator\">=</span> department\n\ndepartment <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">nil</span>\nmanager <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">nil</span>\n<span class=\"hljs-comment\">// Prints: \"Employee is being deinitialized\" and then \"Department is being deinitialized\"</span>\n\n</code></pre>\n<p>이 예시에서, Department와 Employee간의 연결을 끊음으로써 메모리 누수를 피할 수 있습니다.</p>\n<h2>클로저에서 weak 사용</h2>\n<p>클로저에서 weak를 사용하는 것은 강한 참조 순환을 방지하기 위해 종종 필요한데, 특히 클로저가 self, 즉 클래스 인스턴스를 캡처할 때입니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>ViewController 클래스는 비동기 작업을 수행하는 클래스입니다. 이 작업이 완료된 후에 코드가 실행되도록 하고, 동시에 강한 참조 순환에 의한 메모리 누수를 방지해야 합니다.</p>\n<p>weak 키워드를 사용한 예시:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ViewController</span>: <span class=\"hljs-title class_\">UIViewController</span> {\n    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">dataLoader</span>: <span class=\"hljs-title class_\">DataLoader</span>?\n\n    func <span class=\"hljs-title function_\">fetchData</span>(<span class=\"hljs-params\"></span>) {\n        dataLoader?.<span class=\"hljs-title function_\">loadData</span>(<span class=\"hljs-attr\">completion</span>: { [weak self] result <span class=\"hljs-keyword\">in</span>\n            guard <span class=\"hljs-keyword\">let</span> self = self <span class=\"hljs-keyword\">else</span> { <span class=\"hljs-keyword\">return</span> }\n\n            <span class=\"hljs-keyword\">switch</span> result {\n            <span class=\"hljs-keyword\">case</span> .<span class=\"hljs-title function_\">success</span>(<span class=\"hljs-keyword\">let</span> data):\n                self.<span class=\"hljs-title function_\">updateUI</span>(<span class=\"hljs-attr\">with</span>: data)\n            <span class=\"hljs-keyword\">case</span> .<span class=\"hljs-title function_\">failure</span>(<span class=\"hljs-keyword\">let</span> error):\n                self.<span class=\"hljs-title function_\">showErrorMessage</span>(error)\n            }\n        })\n    }\n\n    private func <span class=\"hljs-title function_\">updateUI</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">with</span> data: Data</span>) {\n        <span class=\"hljs-comment\">// 사용자 인터페이스 업데이트</span>\n    }\n\n    private func <span class=\"hljs-title function_\">showErrorMessage</span>(<span class=\"hljs-params\">_ error: <span class=\"hljs-built_in\">Error</span></span>) {\n        <span class=\"hljs-comment\">// 에러 메시지 표시</span>\n    }\n}\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DataLoader</span> {\n    func <span class=\"hljs-title function_\">loadData</span>(<span class=\"hljs-params\">completion: @escaping (Result&#x3C;Data, <span class=\"hljs-built_in\">Error</span>>) -> Void</span>) {\n        <span class=\"hljs-comment\">// 데이터 로드 코드</span>\n    }\n}\n</code></pre>\n<p>위 예시에서:</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<ul>\n<li>ViewController에는 DataLoader의 loadData 메서드를 호출하는 fetchData 메서드가 있습니다.</li>\n<li>loadData에 전달된 클로저 내에서 [weak self]를 사용하여 ViewController의 인스턴스인 self에 강한 참조를 방지합니다. 이는 DataLoader가 클로저를 오랫동안 유지할 수 있기 때문에 중요합니다. 예를 들어 비동기 작업 중에 발생할 수 있습니다.</li>\n<li>클로저 내에서 self에 안전하게 액세스하기 위해 guard let self = self else 'return'을 사용합니다. 만약 ViewController가 클로저가 실행되기 전에 해제되면 self는 nil이 되어 클로저 내의 코드가 실행되지 않아 잠재적인 오류나 충돌을 방지합니다.</li>\n</ul>\n<h1>unowned 참조</h1>\n<p>unowned 참조는 weak와 유사하지만 두 가지 주요 차이점이 있습니다: 옵셔널이 아니며, 가리키는 객체가 해제될 때 nil이 되지 않습니다.</p>\n<h2>unowned 참조의 특징:</h2>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<ul>\n<li>다른 객체가 해제되기 전까지 한 객체를 해제하지 않을 때 사용됩니다.</li>\n<li>객체가 해제된 후 비소유 참조에 접근하면 충돌이 발생합니다.</li>\n<li>상수(let)와 함께만 작동합니다.</li>\n</ul>\n<p>비소유 참조를 사용한 예시:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Customer</span> {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">name</span>: <span class=\"hljs-title class_\">String</span>\n    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">card</span>: <span class=\"hljs-title class_\">CreditCard</span>?\n\n    <span class=\"hljs-title function_\">init</span>(<span class=\"hljs-params\">name: <span class=\"hljs-built_in\">String</span></span>) {\n        self.<span class=\"hljs-property\">name</span> = name\n    }\n\n    deinit {\n        <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">\"\\(name) 해제 중\"</span>)\n    }\n}\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">CreditCard</span> {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">number</span>: <span class=\"hljs-title class_\">UInt64</span>\n    unowned <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">customer</span>: <span class=\"hljs-title class_\">Customer</span>\n\n    <span class=\"hljs-title function_\">init</span>(<span class=\"hljs-params\">number: UInt64, customer: Customer</span>) {\n        self.<span class=\"hljs-property\">number</span> = number\n        self.<span class=\"hljs-property\">customer</span> = customer\n    }\n\n    deinit {\n        <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">\"카드 #\\(number) 해제 중\"</span>)\n    }\n}\n\n<span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">john</span>: <span class=\"hljs-title class_\">Customer</span>? = <span class=\"hljs-title class_\">Customer</span>(<span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"John\"</span>)\njohn!.<span class=\"hljs-property\">card</span> = <span class=\"hljs-title class_\">CreditCard</span>(<span class=\"hljs-attr\">number</span>: <span class=\"hljs-number\">1234_5678_9012_3456</span>, <span class=\"hljs-attr\">customer</span>: john!)\n\njohn = nil\n<span class=\"hljs-comment\">// 출력: \"John 해제 중\" 그리고 \"카드 #1234567890123456 해제 중\"</span>\n</code></pre>\n<p>여기서 Customer가 해제된 후 관련된 CreditCard 객체도 해제되어 메모리 누수를 방지합니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h2>약한 참조와 미소유 참조 비교</h2>\n<ul>\n<li>선언: 약한 참조는 항상 옵셔널이지만, 미소유 참조는 상수로 값이 옵셔널이 아닙니다.</li>\n<li>강한 참조 순환: 둘 다 강한 참조 순환을 방지하지만, 각각 다른 상황에서 사용됩니다.</li>\n<li>안전성: 약한 참조는 객체가 해제될 때 자동으로 nil이 되어 안전합니다. 미소유 참조는 객체가 파괴되면 크래시가 발생할 수 있습니다. 무엇을 하는지 잘 알아야 합니다.</li>\n</ul>\n<h1>결론</h1>\n<p>Swift에서 약한 참조와 미소유 참조의 차이를 이해하는 것은 안전하고 효율적인 메모리 관리를 위해 중요합니다. 두 참조 사이의 선택은 애플리케이션의 구조와 객체 간 관계에 따라 다릅니다. 항상 메모리 누수를 확인하여 신뢰성과 성능을 보증할 수 있도록 코드를 테스트하세요.</p>\n</body>\n</html>\n"},"__N_SSG":true}