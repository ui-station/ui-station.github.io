{"pageProps":{"post":{"title":"Angular ControlValueAccessor를 사용하여 커스텀 타임시트 입력 만드는 방법","description":"","date":"2024-06-30 21:50","slug":"2024-06-30-CreateatimesheetcustominputinAngularwithControlValueAccessor","content":"\n\n\n![Image](/assets/img/2024-06-30-CreateatimesheetcustominputinAngularwithControlValueAccessor_0.png)\n\n# 소개\n\nAngular로 개발을 시작할 때, 매주 시간표를 작성하는 여러 입력 필드를 만들어야 하는 작업에서 어려움을 겪었습니다.\n\n주요 문제는 흔히 쓰이는 HH:MM 형식의 시간표 항목들을 계산을 위한 소수점 숫자 형식으로 계속 변환해야 했다는 점이었습니다. 또한 백엔드에서 받은 소수점 숫자를 다시 HH:MM 형식으로 변환하여 페이지 로드 중에 항목을 채우는 역 문제도 해결해야 했습니다.\n\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n처음에는 RxJs를 사용하여 문제를 해결했습니다. 그러나 이제 Angular 기능에 대해 더 자신감을 가지고 있으므로, 제 의견으로는 더 나은 캡슐화와 관심사 분리를 보장하는 다른 접근 방식을 시도해 보았습니다. 이 접근 방식은 ControlValueAccessor 인터페이스를 활용하여 사용자 정의 입력을 생성하고 사용자 정의 반응형 컨트롤을 만드는 것을 포함합니다.\n\n# ControlValueAccessor: 개요 및 구현된 메서드\n\nControlValueAccessor 인터페이스는 사용자 정의 폼 컨트롤과 Angular의 반응형 폼 API간의 통신을 가능하게 하는 네 가지 메서드를 구현할 필요가 있습니다. 이러한 메서드는 다음과 같습니다:\n\n- writeValue(newControlValue) → 이 메서드는 Angular 반응형 FormControl의 값이 변경될 때마다 호출됩니다. 그 목적은 모델에서 값이 업데이트되었음을 사용자 정의 컨트롤에 알리고, 뷰에 반영되어야 하는 경우에 호출됩니다. 예를 들어, writeValue() 메서드는 폼 컨트롤을 처음 초기화할 때 호출되거나(parentControl = new FormControl`number`(0, [Validators.required]) 또는 parentControl.setValue(4)와 같이 호출될 때 호출됩니다.\n- registerOnChange(fn) → 저의 의견으로는, 이 인터페이스에서 가장 이해하기 어려운 메서드입니다. FormControl이 처음 생성될 때, registerOnChange(fn)이 인수(fn이라는 관례적인 이름)와 함께 호출됩니다. 이 인수는 뷰에서 모델로 값이 변경되었음을 알리기 위해 호출해야 하는 함수입니다. 명확하게 하기 위해, 대부분의 경우 사용자 정의 폼 컨트롤에서 다음 단계를 구현해야 합니다:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 클래스 속성 내부에 fn 변수를 저장하여 나중에 사용자가 뷰의 입력 값을 업데이트할 때 호출할 수 있습니다.\n- 사용자가 값을 변경할 때 중단하는 로직을 구현합니다.\n- 이전에 저장한 클래스 속성에서 fn을 호출하여 새 값을 저장하도록 Angular FormControl에 통신합니다. 아래 예제를 참조하세요:\n\n```js\nexport class MyCustomInput implements ControlValueAccessor {\n//...other methods\n\n//onChange는 사용자가 값을 업데이트할 때 저장할 클래스 속성입니다.\nonChange!: (value: yourInputType) => void;\n\n//단계 1\nregisterOnChange(fn) {\n  this.onChange = fn;\n}\n\n//단계 2 (템플릿의 이벤트 바인딩)\nonUserInput(newUserValue: T) {\n  //단계 3\n  this.onChange(newUserValue);\n}\n```\n\n- registerOnTouched(fn) → registerOnChange()가 어떻게 작동하는지 이해하면, 이것도 아주 쉽습니다. 비슷하게 동작합니다: fn 콜백을 등록하고 클래스 속성에 저장한 다음, 부모 FormControl에 사용자 정의 컨트롤이 터치되었음을 통보하기 위해 호출합니다.\n- setDisableState(isDisabled) → 이 메서드의 구현은 선택 사항입니다. 부모 FormControl의 상태가 DISABLED와 다른 상태 사이에서 변경될 때마다(INVALID일지라도 컨트롤이 활성화된 것을 기억하세요), 이 메서드가 호출됩니다. 인수 isDisabled는 true일 때 부모 컨트롤의 disable() 함수가 호출될 때, false일 때 enable()이 호출될 때로 설정된 부울입니다.\n\n# ControlValueAccessor의 내 구현: 타임시트 입력\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 ControlValueAccessor가 어떻게 작동하는지 명확히 이해했으니 코드가 어떻게 동작하는지 확인해 봅시다. 제안 사항이 있으면 댓글로 알려주세요:\n\n```js\n//timehseet.component.ts\n  implements ControlValueAccessor, OnDestroy, AfterViewInit\n{\n  readonly #timeEntryRegex = /[0-2]*[0-9]+:[0-5]{1}([0-9]{1})?/;\n  #destroy: Subject<void> = new Subject();\n  #injector = inject(Injector);\n  #parentControl!: AbstractControl | null;\n\n  invalidClasses = input<string[]>();\n\n  innerControl = new FormControl<string>('', { updateOn: 'blur' });\n\n  isInvalid = false;\n  isDisabled = false;\n  isTouched = false;\n\n  onTouch: (() => void) | undefined;\n\n  writeValue(timeEntry: number | null): void {\n    this.innerControl.setValue(this.fromFloatToString(timeEntry));\n  }\n\n  registerOnChange(fn: any): void {\n    this.innerControl.valueChanges\n      .pipe(\n        takeUntil(this.#destroy),\n        tap(() => {\n          this.isTouched = true;\n          this.onTouch && this.onTouch();\n        }),\n        map((rawEntry) => this.convertEntry(rawEntry))\n      )\n      .subscribe((formattedEntry) => {\n        this.innerControl.setValue(\n          this.fromFloatToString(formattedEntry) || '',\n          {\n            emitEvent: false,\n          }\n        );\n\n        fn(formattedEntry);\n      });\n  }\n\n  registerOnTouched(fn: any): void {\n    this.onTouch = fn;\n  }\n\n  setDisabledState(isDisabled: boolean): void {\n    isDisabled ? this.innerControl.disable() : this.innerControl.enable();\n  }\n\n  markAsTouched() {\n    this.isTouched = true;\n    this.#parentControl?.updateValueAndValidity({\n      onlySelf: true,\n    });\n    this.onTouch && this.onTouch();\n  }\n\n  ngOnDestroy(): void {\n    this.#destroy.next();\n    this.#destroy.complete();\n  }\n\n  ngAfterViewInit(): void {\n    this.#parentControl = this.#injector.get(NgControl).control;\n\n    this.#parentControl?.statusChanges\n      .pipe(\n        takeUntil(this.#destroy),\n        filter(() => this.isTouched),\n        map((status) => status === 'INVALID'),\n        filter((isInvalid) => isInvalid !== this.isInvalid)\n      )\n      .subscribe((isInvalid: boolean) => {\n        this.isInvalid = isInvalid;\n      });\n  }\n\n  private convertEntry(rawEntry: string | null): number | null {\n    //문자열을 숫자로 변환하는 메서드. 유효한 경우에만 변환합니다.\n    //그렇지 않으면 null을 반환합니다.\n  }\n\n  private fromStringToFloat(timesheetEntry: string) {\n    //....\n  }\n\n  private fromFloatToString(entryHours: number | null) {\n   //...\n  }\n}\r\n```\n\n```js\n<!-- timesheet.component.html-->\n<input\n  [ngClass]=\"isInvalid ? invalidClasses() : ''\"\n  type=\"text\"\n  class=\"form-control\"\n  (blur)=\"markAsTouched()\"\n  [formControl]=\"innerControl\"\n/>\r\n```\n\n# 메모\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n보시다시피, 저는 기본적으로 timesheet entry의 텍스트 형식을 처리하는 inner FormControl을 생성했습니다.\n\n- 모델로부터 새로운 값이 도착하고 writeValue() 함수가 호출되면, fromFloatToString() 유틸리티 함수를 통해 값을 변환한 후 innerControl에 새 값을 설정합니다.\n- 사용자가 timesheet entry를 입력하면, 모든 가능한 입력 형식을 고려하여 float로 변환을 시도하고 (유효한 경우 3, 3:00, 3.0), formattedEntry 변수를 생성합니다. 그런 다음 innerControl 값을 HH:MM 형식으로 새로 생성된 값으로 설정하고 (입력된 값이 유효하지 않은 경우 빈 문자열로), 동시에 fn(formattedEntry)를 호출하여 formattedEntry에 의해 생성된 실수 번호를 가진 parentControl의 값을 업데이트하도록 부모 컨트롤을 통지합니다.\n- 코드에서 볼 수 있듯이, 이 경우에는 OnChange 함수를 저장하지 않습니다. 이는 구독 내부에서 매번 호출할 수 있기 때문입니다.\n- customInput의 providers 배열에 다음 코드를 추가하는 것을 잊지 마세요:\n\n```js\n@Component({\n  selector: 'app-timesheet-input',\n  standalone: true,\n  imports: [ReactiveFormsModule, NgClass],\n  templateUrl: './timesheet-input.component.html',\n  styleUrl: './timesheet-input.component.css',\n  providers: [\n    {\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => TimesheetInputComponent),\n      multi: true,\n    },\n  ],\n})\n```\n\n이 코드를 추가하면 사용자 정의 구성 요소가 formControlName 지시문을 받도록 설정됩니다. 사용자 정의 formControl의 DI에 대한 자세한 정보는 이 리소스를 확인해주세요.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 최종 결과\n\n프로젝트의 완전한 버전을 보고 싶다면, 제 StackBlitz를 확인해보세요.\n\n# 감사의 말\n\n이 간단하지만 중요한 프로젝트의 코드 가독성과 효율성을 향상시키는 데 도움을 주신 팔리오 비온디와 그의 텔레그램 커뮤니티에 특별히 감사드립니다.","ogImage":{"url":"/assets/img/2024-06-30-CreateatimesheetcustominputinAngularwithControlValueAccessor_0.png"},"coverImage":"/assets/img/2024-06-30-CreateatimesheetcustominputinAngularwithControlValueAccessor_0.png","tag":["Tech"],"readingTime":8},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p><img src=\"/assets/img/2024-06-30-CreateatimesheetcustominputinAngularwithControlValueAccessor_0.png\" alt=\"Image\"></p>\n<h1>소개</h1>\n<p>Angular로 개발을 시작할 때, 매주 시간표를 작성하는 여러 입력 필드를 만들어야 하는 작업에서 어려움을 겪었습니다.</p>\n<p>주요 문제는 흔히 쓰이는 HH:MM 형식의 시간표 항목들을 계산을 위한 소수점 숫자 형식으로 계속 변환해야 했다는 점이었습니다. 또한 백엔드에서 받은 소수점 숫자를 다시 HH:MM 형식으로 변환하여 페이지 로드 중에 항목을 채우는 역 문제도 해결해야 했습니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>처음에는 RxJs를 사용하여 문제를 해결했습니다. 그러나 이제 Angular 기능에 대해 더 자신감을 가지고 있으므로, 제 의견으로는 더 나은 캡슐화와 관심사 분리를 보장하는 다른 접근 방식을 시도해 보았습니다. 이 접근 방식은 ControlValueAccessor 인터페이스를 활용하여 사용자 정의 입력을 생성하고 사용자 정의 반응형 컨트롤을 만드는 것을 포함합니다.</p>\n<h1>ControlValueAccessor: 개요 및 구현된 메서드</h1>\n<p>ControlValueAccessor 인터페이스는 사용자 정의 폼 컨트롤과 Angular의 반응형 폼 API간의 통신을 가능하게 하는 네 가지 메서드를 구현할 필요가 있습니다. 이러한 메서드는 다음과 같습니다:</p>\n<ul>\n<li>writeValue(newControlValue) → 이 메서드는 Angular 반응형 FormControl의 값이 변경될 때마다 호출됩니다. 그 목적은 모델에서 값이 업데이트되었음을 사용자 정의 컨트롤에 알리고, 뷰에 반영되어야 하는 경우에 호출됩니다. 예를 들어, writeValue() 메서드는 폼 컨트롤을 처음 초기화할 때 호출되거나(parentControl = new FormControl<code>number</code>(0, [Validators.required]) 또는 parentControl.setValue(4)와 같이 호출될 때 호출됩니다.</li>\n<li>registerOnChange(fn) → 저의 의견으로는, 이 인터페이스에서 가장 이해하기 어려운 메서드입니다. FormControl이 처음 생성될 때, registerOnChange(fn)이 인수(fn이라는 관례적인 이름)와 함께 호출됩니다. 이 인수는 뷰에서 모델로 값이 변경되었음을 알리기 위해 호출해야 하는 함수입니다. 명확하게 하기 위해, 대부분의 경우 사용자 정의 폼 컨트롤에서 다음 단계를 구현해야 합니다:</li>\n</ul>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<ul>\n<li>클래스 속성 내부에 fn 변수를 저장하여 나중에 사용자가 뷰의 입력 값을 업데이트할 때 호출할 수 있습니다.</li>\n<li>사용자가 값을 변경할 때 중단하는 로직을 구현합니다.</li>\n<li>이전에 저장한 클래스 속성에서 fn을 호출하여 새 값을 저장하도록 Angular FormControl에 통신합니다. 아래 예제를 참조하세요:</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyCustomInput</span> implements <span class=\"hljs-title class_\">ControlValueAccessor</span> {\n<span class=\"hljs-comment\">//...other methods</span>\n\n<span class=\"hljs-comment\">//onChange는 사용자가 값을 업데이트할 때 저장할 클래스 속성입니다.</span>\nonChange!: <span class=\"hljs-function\">(<span class=\"hljs-params\">value: yourInputType</span>) =></span> <span class=\"hljs-keyword\">void</span>;\n\n<span class=\"hljs-comment\">//단계 1</span>\n<span class=\"hljs-title function_\">registerOnChange</span>(<span class=\"hljs-params\">fn</span>) {\n  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">onChange</span> = fn;\n}\n\n<span class=\"hljs-comment\">//단계 2 (템플릿의 이벤트 바인딩)</span>\n<span class=\"hljs-title function_\">onUserInput</span>(<span class=\"hljs-params\">newUserValue: T</span>) {\n  <span class=\"hljs-comment\">//단계 3</span>\n  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">onChange</span>(newUserValue);\n}\n</code></pre>\n<ul>\n<li>registerOnTouched(fn) → registerOnChange()가 어떻게 작동하는지 이해하면, 이것도 아주 쉽습니다. 비슷하게 동작합니다: fn 콜백을 등록하고 클래스 속성에 저장한 다음, 부모 FormControl에 사용자 정의 컨트롤이 터치되었음을 통보하기 위해 호출합니다.</li>\n<li>setDisableState(isDisabled) → 이 메서드의 구현은 선택 사항입니다. 부모 FormControl의 상태가 DISABLED와 다른 상태 사이에서 변경될 때마다(INVALID일지라도 컨트롤이 활성화된 것을 기억하세요), 이 메서드가 호출됩니다. 인수 isDisabled는 true일 때 부모 컨트롤의 disable() 함수가 호출될 때, false일 때 enable()이 호출될 때로 설정된 부울입니다.</li>\n</ul>\n<h1>ControlValueAccessor의 내 구현: 타임시트 입력</h1>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>이제 ControlValueAccessor가 어떻게 작동하는지 명확히 이해했으니 코드가 어떻게 동작하는지 확인해 봅시다. 제안 사항이 있으면 댓글로 알려주세요:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">//timehseet.component.ts</span>\n  implements <span class=\"hljs-title class_\">ControlValueAccessor</span>, <span class=\"hljs-title class_\">OnDestroy</span>, <span class=\"hljs-title class_\">AfterViewInit</span>\n{\n  readonly #timeEntryRegex = <span class=\"hljs-regexp\">/[0-2]*[0-9]+:[0-5]{1}([0-9]{1})?/</span>;\n  #<span class=\"hljs-attr\">destroy</span>: <span class=\"hljs-title class_\">Subject</span>&#x3C;<span class=\"hljs-keyword\">void</span>> = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Subject</span>();\n  #injector = <span class=\"hljs-title function_\">inject</span>(<span class=\"hljs-title class_\">Injector</span>);\n  #parentControl!: <span class=\"hljs-title class_\">AbstractControl</span> | <span class=\"hljs-literal\">null</span>;\n\n  invalidClasses = input&#x3C;string[]>();\n\n  innerControl = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">FormControl</span>&#x3C;string>(<span class=\"hljs-string\">''</span>, { <span class=\"hljs-attr\">updateOn</span>: <span class=\"hljs-string\">'blur'</span> });\n\n  isInvalid = <span class=\"hljs-literal\">false</span>;\n  isDisabled = <span class=\"hljs-literal\">false</span>;\n  isTouched = <span class=\"hljs-literal\">false</span>;\n\n  <span class=\"hljs-attr\">onTouch</span>: (<span class=\"hljs-function\">() =></span> <span class=\"hljs-keyword\">void</span>) | <span class=\"hljs-literal\">undefined</span>;\n\n  <span class=\"hljs-title function_\">writeValue</span>(<span class=\"hljs-attr\">timeEntry</span>: number | <span class=\"hljs-literal\">null</span>): <span class=\"hljs-keyword\">void</span> {\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">innerControl</span>.<span class=\"hljs-title function_\">setValue</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">fromFloatToString</span>(timeEntry));\n  }\n\n  <span class=\"hljs-title function_\">registerOnChange</span>(<span class=\"hljs-attr\">fn</span>: any): <span class=\"hljs-keyword\">void</span> {\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">innerControl</span>.<span class=\"hljs-property\">valueChanges</span>\n      .<span class=\"hljs-title function_\">pipe</span>(\n        <span class=\"hljs-title function_\">takeUntil</span>(<span class=\"hljs-variable language_\">this</span>.#destroy),\n        <span class=\"hljs-title function_\">tap</span>(<span class=\"hljs-function\">() =></span> {\n          <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">isTouched</span> = <span class=\"hljs-literal\">true</span>;\n          <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">onTouch</span> &#x26;&#x26; <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">onTouch</span>();\n        }),\n        <span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">rawEntry</span>) =></span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">convertEntry</span>(rawEntry))\n      )\n      .<span class=\"hljs-title function_\">subscribe</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">formattedEntry</span>) =></span> {\n        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">innerControl</span>.<span class=\"hljs-title function_\">setValue</span>(\n          <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">fromFloatToString</span>(formattedEntry) || <span class=\"hljs-string\">''</span>,\n          {\n            <span class=\"hljs-attr\">emitEvent</span>: <span class=\"hljs-literal\">false</span>,\n          }\n        );\n\n        <span class=\"hljs-title function_\">fn</span>(formattedEntry);\n      });\n  }\n\n  <span class=\"hljs-title function_\">registerOnTouched</span>(<span class=\"hljs-attr\">fn</span>: any): <span class=\"hljs-keyword\">void</span> {\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">onTouch</span> = fn;\n  }\n\n  <span class=\"hljs-title function_\">setDisabledState</span>(<span class=\"hljs-attr\">isDisabled</span>: boolean): <span class=\"hljs-keyword\">void</span> {\n    isDisabled ? <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">innerControl</span>.<span class=\"hljs-title function_\">disable</span>() : <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">innerControl</span>.<span class=\"hljs-title function_\">enable</span>();\n  }\n\n  <span class=\"hljs-title function_\">markAsTouched</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">isTouched</span> = <span class=\"hljs-literal\">true</span>;\n    <span class=\"hljs-variable language_\">this</span>.#parentControl?.<span class=\"hljs-title function_\">updateValueAndValidity</span>({\n      <span class=\"hljs-attr\">onlySelf</span>: <span class=\"hljs-literal\">true</span>,\n    });\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">onTouch</span> &#x26;&#x26; <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">onTouch</span>();\n  }\n\n  <span class=\"hljs-title function_\">ngOnDestroy</span>(): <span class=\"hljs-keyword\">void</span> {\n    <span class=\"hljs-variable language_\">this</span>.#destroy.<span class=\"hljs-title function_\">next</span>();\n    <span class=\"hljs-variable language_\">this</span>.#destroy.<span class=\"hljs-title function_\">complete</span>();\n  }\n\n  <span class=\"hljs-title function_\">ngAfterViewInit</span>(): <span class=\"hljs-keyword\">void</span> {\n    <span class=\"hljs-variable language_\">this</span>.#parentControl = <span class=\"hljs-variable language_\">this</span>.#injector.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-title class_\">NgControl</span>).<span class=\"hljs-property\">control</span>;\n\n    <span class=\"hljs-variable language_\">this</span>.#parentControl?.<span class=\"hljs-property\">statusChanges</span>\n      .<span class=\"hljs-title function_\">pipe</span>(\n        <span class=\"hljs-title function_\">takeUntil</span>(<span class=\"hljs-variable language_\">this</span>.#destroy),\n        <span class=\"hljs-title function_\">filter</span>(<span class=\"hljs-function\">() =></span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">isTouched</span>),\n        <span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">status</span>) =></span> status === <span class=\"hljs-string\">'INVALID'</span>),\n        <span class=\"hljs-title function_\">filter</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">isInvalid</span>) =></span> isInvalid !== <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">isInvalid</span>)\n      )\n      .<span class=\"hljs-title function_\">subscribe</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">isInvalid: boolean</span>) =></span> {\n        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">isInvalid</span> = isInvalid;\n      });\n  }\n\n  private <span class=\"hljs-title function_\">convertEntry</span>(<span class=\"hljs-attr\">rawEntry</span>: string | <span class=\"hljs-literal\">null</span>): number | <span class=\"hljs-literal\">null</span> {\n    <span class=\"hljs-comment\">//문자열을 숫자로 변환하는 메서드. 유효한 경우에만 변환합니다.</span>\n    <span class=\"hljs-comment\">//그렇지 않으면 null을 반환합니다.</span>\n  }\n\n  private <span class=\"hljs-title function_\">fromStringToFloat</span>(<span class=\"hljs-params\">timesheetEntry: string</span>) {\n    <span class=\"hljs-comment\">//....</span>\n  }\n\n  private <span class=\"hljs-title function_\">fromFloatToString</span>(<span class=\"hljs-params\">entryHours: number | <span class=\"hljs-literal\">null</span></span>) {\n   <span class=\"hljs-comment\">//...</span>\n  }\n}\n</code></pre>\n<pre><code class=\"hljs language-js\">&#x3C;!-- timesheet.<span class=\"hljs-property\">component</span>.<span class=\"hljs-property\">html</span>-->\n<span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">input</span>\n  [<span class=\"hljs-attr\">ngClass</span>]=<span class=\"hljs-string\">\"isInvalid ? invalidClasses() : ''\"</span>\n  <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"text\"</span>\n  <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"form-control\"</span>\n  (<span class=\"hljs-attr\">blur</span>)=<span class=\"hljs-string\">\"markAsTouched()\"</span>\n  [<span class=\"hljs-attr\">formControl</span>]=<span class=\"hljs-string\">\"innerControl\"</span>\n/></span></span>\n</code></pre>\n<h1>메모</h1>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>보시다시피, 저는 기본적으로 timesheet entry의 텍스트 형식을 처리하는 inner FormControl을 생성했습니다.</p>\n<ul>\n<li>모델로부터 새로운 값이 도착하고 writeValue() 함수가 호출되면, fromFloatToString() 유틸리티 함수를 통해 값을 변환한 후 innerControl에 새 값을 설정합니다.</li>\n<li>사용자가 timesheet entry를 입력하면, 모든 가능한 입력 형식을 고려하여 float로 변환을 시도하고 (유효한 경우 3, 3:00, 3.0), formattedEntry 변수를 생성합니다. 그런 다음 innerControl 값을 HH:MM 형식으로 새로 생성된 값으로 설정하고 (입력된 값이 유효하지 않은 경우 빈 문자열로), 동시에 fn(formattedEntry)를 호출하여 formattedEntry에 의해 생성된 실수 번호를 가진 parentControl의 값을 업데이트하도록 부모 컨트롤을 통지합니다.</li>\n<li>코드에서 볼 수 있듯이, 이 경우에는 OnChange 함수를 저장하지 않습니다. 이는 구독 내부에서 매번 호출할 수 있기 때문입니다.</li>\n<li>customInput의 providers 배열에 다음 코드를 추가하는 것을 잊지 마세요:</li>\n</ul>\n<pre><code class=\"hljs language-js\">@<span class=\"hljs-title class_\">Component</span>({\n  <span class=\"hljs-attr\">selector</span>: <span class=\"hljs-string\">'app-timesheet-input'</span>,\n  <span class=\"hljs-attr\">standalone</span>: <span class=\"hljs-literal\">true</span>,\n  <span class=\"hljs-attr\">imports</span>: [<span class=\"hljs-title class_\">ReactiveFormsModule</span>, <span class=\"hljs-title class_\">NgClass</span>],\n  <span class=\"hljs-attr\">templateUrl</span>: <span class=\"hljs-string\">'./timesheet-input.component.html'</span>,\n  <span class=\"hljs-attr\">styleUrl</span>: <span class=\"hljs-string\">'./timesheet-input.component.css'</span>,\n  <span class=\"hljs-attr\">providers</span>: [\n    {\n      <span class=\"hljs-attr\">provide</span>: <span class=\"hljs-variable constant_\">NG_VALUE_ACCESSOR</span>,\n      <span class=\"hljs-attr\">useExisting</span>: <span class=\"hljs-title function_\">forwardRef</span>(<span class=\"hljs-function\">() =></span> <span class=\"hljs-title class_\">TimesheetInputComponent</span>),\n      <span class=\"hljs-attr\">multi</span>: <span class=\"hljs-literal\">true</span>,\n    },\n  ],\n})\n</code></pre>\n<p>이 코드를 추가하면 사용자 정의 구성 요소가 formControlName 지시문을 받도록 설정됩니다. 사용자 정의 formControl의 DI에 대한 자세한 정보는 이 리소스를 확인해주세요.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h1>최종 결과</h1>\n<p>프로젝트의 완전한 버전을 보고 싶다면, 제 StackBlitz를 확인해보세요.</p>\n<h1>감사의 말</h1>\n<p>이 간단하지만 중요한 프로젝트의 코드 가독성과 효율성을 향상시키는 데 도움을 주신 팔리오 비온디와 그의 텔레그램 커뮤니티에 특별히 감사드립니다.</p>\n</body>\n</html>\n"},"__N_SSG":true}