{"pageProps":{"posts":[{"title":"Vim-포비아 극복하기 나의 구원 이야기","description":"","date":"2024-05-20 17:59","slug":"2024-05-20-OvercomingVim-PhobiaMyJourneyofRedemption","content":"\n## 편집기 이야기뿐만이 아니라 우리와 같은 사람들 이야기\n\n![Image](/assets/img/2024-05-20-OvercomingVim-PhobiaMyJourneyofRedemption_0.png)\n\n히히... 이제 시작해볼까요. 저는 거의 10년 동안 코딩을 해 왔어요. 그리고 하루의 3분의 2를 그렇게 보내는 사람에게는 도구가 중요합니다. 과거를 회상하며 산책을 할까요? 이 글은 다를 거에요.\n\n# 2010년 초반쯤 — 메모장 등급\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Overcoming Vim Phobia: My Journey of Redemption](/assets/img/2024-05-20-OvercomingVim-PhobiaMyJourneyofRedemption_1.png)\n\n젊고 당황한 감자로 시작했던 단순한 자바 개발을 배우기 위해 노트패드++ 에 얽매이고 있었어요. 그때, 편집기가 무엇인지조차 이해하지 못했어요. 저에게는 추가 버튼이 있는 노트패드 같았죠.\n\n그때의 초점은 프로그래밍 학습이었고, DX (개발 경험)는 신경 쓰지 않았어요. 유일하게 흥미로웠던 것은 플러그인을 사용하여 코드를 실행할 수 있다는 것이었어요. 백분을 누르는 것만으로 코드를 실행할 수 있는 기능은 일반 노트패드에서 작성하고 윈도우 명령 프롬프트에서 실행하는 것보다 큰 장점을 제공했죠.\n\n## 주요 포인트\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 코드를 함께 작성하고 실행할 수 있는 곳이 있다면 좋겠어요.\n\n# 두 해 뒤 — Eclipse\n\n이제 나름대로 몇 가지 언어로 코드를 작성할 수 있게 되었어요. 읽고 있던 책 중 하나에서는 다음으로 유용한 것을 추천했는데, 그건 Eclipse였어요. Eclipse는 제 마음에 꼭 들어맞았죠. 처음으로, 툴체인이 중독성을 띠기 시작했어요. Java Swing 앱을 코드로 작성하고 빌드하고 실행하는 즐거움을 느낄 수 있었는데, 빌드 및 실행 시스템에 대해 깊게 들어가지 않아도 되는 건, 정말로... 좋았어요.\n\n인터넷이 크지 않았기 때문에 종종 오프라인 문서를 참고하고 해결책을 찾았어요. 때로는 지루했지만, 다른 방법이 없었거든요. 처음으로, 이 소프트웨어가 이전 것처럼 동작하지 않는 이유가 무엇인지 궁금해졌어요. 아니요, 그때는 아직 IDE라는 단어를 알지 못했어요. 그저 Java가 30억 대의 장치에서 작동하기 때문에, Java를 잘 알아야 한다는 것만 알 뿐이었어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 요점\n\n- 소프트웨어가 설정 작업을 대신 처리할 수 있다면 더 좋습니다.\n- 소프트웨어가 다음으로 무엇을 작성해야 하는지 안내해 준다면 더 좋습니다.\n\n# 2014년 — 리눅스와 VI를 만나다\n\n![이미지](/assets/img/2024-05-20-OvercomingVim-PhobiaMyJourneyofRedemption_2.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n친구야, 나는 이번에 새로운 파란색 노트북을 구입했어. 스티커에는 \"Ubuntu\"라고 써 있더라고. 이게 뭐죠? 나의 백업된 윈도우 DVD와 그 뒷면에 써 있는 활성화 키는 어디로 갔지? 학교 도서관에 가봤는데, 유닉스 책을 읽으면서 너무 즐거움을 느꼈어. 그래서 영원히 리눅스로 옮겨가기로 했어 (그때부터 윈도우 따위는 손 대지 않았지).\n\n인터넷에서 이상한 사람들이 왜 항상 랜덤한 설정 파일을 VI 라는 걸로 편집하라고 추천하는지 이해가 안 가. 누가 하늘 위에 계신 신이 이런 끔찍한 vi라는 무언가를 열고, 파일을 찾아가서 거기로 진입하겠어?\n\n안타깝게도, 대학 커리큘럼 중 일부였기 때문에 써야 했지. 다행히도 'i'를 누르면 vi가 \"보통\"이 되더라고. 너무 싫어서 교수님께서 터미널에서 코딩을 하는 것으로 오해하게 gedit 설정을 작성했어.\n\n## 주요 포인트\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 제품/결과를 강요하지 마세요. 아이디어를 제시하고 사람들이 공감하는지 확인해보세요.\n- 모든 개발자는 Linux를 사용해야 합니다. 예외 없이. (저의 개인적인 의견: macOS도 Linux 배포판으로 고려합니다.)\n\n# 2017 — 코딩의 숭고한 예술\n\n![이미지](/assets/img/2024-05-20-OvercomingVim-PhobiaMyJourneyofRedemption_3.png)\n\n이제 모든 것이 모양을 잡기 시작했습니다. 저는 웹 개발자로의 직업 전환이 결정되었습니다. 자주 작은 유틸리티 앱을 만들었습니다. 다시 그 책을 살펴보니 스브라임(Sublime)이 다음 빛나는 것이라고 나왔습니다. 아호이! 저는 준비되었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n나의 마음에 아주 가까운 느낌이 드는게 있어. JSON 설정이었는데, 설정 파일에서 일주일 내내 설정을 바꾸느라 시간을 보냈지. USB 드라이브에 JSON 파일을 복사해서 친구의 컴퓨터를 내 것처럼 만든 게 마치 마법 같은 경험이었어. Lowkey dotfiles, hehehe.\n\n그 순간, 내 Sublime은 보통 Sublime 사용자들에게는 다른 애플리케이션처럼 보였어. 오늘날에도 나는 하드코어 ricing 팬이야 (소프트웨어를 커스터마이징하는 멋진 용어지). 그리고 네, Sublime을 구매하라는 팝업이 떠도 나에게는 면역이야. 예전의 Winrar처럼 말이야.\n\n## 중요한 점\n\n- Sublime은 할 수 있는 것들에 비해 빠르게 동작했어.\n- \"실패한\" 유일한 이유는 VS Code가 비슷한 제안을 했고, 기업 후원을 받았으며 훌륭한 커뮤니티 지원이었어. 개발자들은 VS Code로 이동했고, 개인적으로 사용하지 않는 소프트웨어에 대한 도구 개발은 없어졌어. Vim은 Sublime의 강력함에는 미치지 못하지만 (강력한 GUI), 커뮤니티는 Vim에 고수했고 시간이 지나면서 놀라운 툴이 되었어.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 2019 - VS Code의 부상\n\n![이미지](/assets/img/2024-05-20-OvercomingVim-PhobiaMyJourneyofRedemption_4.png)\n\n내가 오래된 것 같아서 진지해지기 시작한 것 같았어요. 서브라임 텍스트는 이제 손바닥처럼 익숙했습니다. 모든 키 바인딩과 설정 옵션이 내 머리 속에 살았죠. 제 작업 흐름에 맞게 잘 사용자 지정된 다양한 확장 프로그램 또한 말이죠.\n\n그 때, 서브라임 설정 폴더를 잃는 것이 노트북 자체보다 더 걱정이었습니다. 농담이죠, 그때쯤엔 이미 git를 알고 있었어요. 사무실에서는 VS Code로 작업하라는 안내가 왔기 때문에 다른 선택지가 없었습니다. 한 달 동안 세밀하게 조정했어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n결국 나는 내가 만들어 놓은 프랑켄슈타인의 몬스터가 어떤 것인지 궁금해졌다. 그것은 서브라임처럼 보였고 서브라임이 비주얼 스튜디오 코드와 결혼한 것 같이 응답했으며 예전 친구인 이클립스처럼 무겁게 시작했다. 가장 최악인 부분은 시니어 개발자가 내 컴퓨터에서 디버깅을 시도할 때마다 나를 혼내주었다. 흔한 해커 문제야, 큰 문제 아니지.\n\n비주얼 스튜디오 코드를 좋아하는 한 가지는 제로 설정 확장 생태계다. 코드를 작성하는 동안 내부에서 스마트하게 느껴졌다. 스브라임이 갖고 있지 않은 무언가가 느껴졌다. 현재까지 비주얼 스튜디오 코드가 내가 가장 선호하는 코딩 소프트웨어다. 무언가가 코딩될 수 있다면 결국 비주얼 스튜디오 코드에 들어갈 것이다. 나는 그것이 에맥스의 현대 버전 같다고 느낀다.\n\n명시적 타입과 동적 타입 언어의 차이를 직접 경험했다. 그때 루비 온 레일즈에서 작업했고 동적 타입 언어는 어떤 편집기에게나 악몽이다. 나를 쏴라, 하지만 나는 루비, 파이썬, 자바스크립트 등을 싫어한다. 매일 코드를 작성하기는 하지만 하나의 이유로 인해 그것을 싫어한다. 아마도 그 한 이유 때문에 때때로 젯브레인즈 문을 두드린다.\n\n## 주요 포인트\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- VS Code은 만능 에디터가 되고 싶었고, 커뮤니티가 그것을 실현시켰습니다.\n- 그 핵심은 엄격하고 신중하게 설계되었으며, 사람들은 그 위에 원하는 것을 만들어 냅니다.\n- 그 축복은 동시에 저주가 됩니다. 누구나 쉽게 무엇이든 작성할 수 있기 때문에, 사람들은 많은 사고 없이 코딩을 하고, 이후 VS Code가 느리다고 원망하는 경우가 많습니다.\n\n# 2021 — 이런, 완벽주의 문제가 조금 있습니다\n\n![image](/assets/img/2024-05-20-OvercomingVim-PhobiaMyJourneyofRedemption_5.png)\n\n\"이 OCD 같은 게 뭐야?\"라고 묻는다면요? 그것은 사물이 어떻게 되어야 하는지에 너무 엄격하다는 상태입니다. \"와, 그건 좋은 일이네\"라고 할지언정, 테이블의 모서리가 노트북과 맞지 않는다면, 불안함이 느껴질 겁니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n또, 난 빨리 산만해지는 편이라 집중할 수 있는 환경이 필요해. 위 이미지를 얻기 위해 이 기사를 떠났다가, 이 미미가 나온 영화에 대해 읽고 다시 돌아왔어. 좋아, 멋지다, 우리 지금 같은 페이지에 있네. 보다시피, 결국 우리는 그렇게 다르지 않아!\n\n나는 실내와 실외 환경 모두를 너무 깔끔하게 좋아해. 이 페이지 맨 아래에 있는 스크린샷을 확인해봐; 애플리케이션 창에는 가까운 아이콘이 하나도 없다. 글자 간격부터 팝업의 안쪽 패딩까지, 모든 것이 작동 요소야. 솔직히 말해서, 이런 일을 하면 행복해지는 것 같아. \"유닉스 라이싱\"을 검색해보면 놀라게 될 거야.\n\n다른 한편으로 말하면, 말 그대로 다른 한 손으로, 글자와 화살표 사이를 계속 뛰어다니는 것이 원인으로 손목 통증을 겪기 시작했어. 일주일에 80시간을 그냥 끙끙대며 보내다 보니 이런 작은 장점이 따라오네. 😅\n\n손목 통증에 대해 구글링을 하던 중, 재미있게도 컴퓨터에서 Vim(-mode)을 사용하는 것이 한 가지 팁으로 나왔어. 미묘한 VI가, 그것이 같은 것임을 이해하지 못했었어. 열어보기 전까지는 그것에 대해 어느 정도 혐오감을 느꼈었지.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n서버 작업을 할 때는 Nano를 사용했어요. 후에 Micro로 옮겼는데, 그게 VS Code의 바인딩에 더 가까웠어요. 저의 대의 적인 Vi를 피하기 위해 모든 노력을 기울였다가 깨닫게 되었죠. 제가 사용하는 모든 툴이 이상한 Sublime과 VS Code의 혼합된 키 바인딩을 가지고 있다는 걸요.\n\n이런! 저 자신이 싫어져요. 다른 사람의 컴퓨터에서도 순수 버전을 실행하고 있는 그 소프트웨어를 사용하지 못하죠. 터미널을 사용하지 않는 생각을 지지하고 오랜 시간이 흐른 만큼, awk, sed, grep 등에 대한 제 감사함을 모두 잊어버렸죠. 변화가 필요했어요; 이 부정 안에 살 수 없었어요.\n\n## 주요 포인트\n\n- 당신이 즐기는 일을 하세요. 현실적인 문제들에 대한 추상화와는 상관없이 말이에요.\n- 모든 사람들이 부정 속에 시간을 보내죠. 깨달은 후에라면 문제가 없는 거죠.\n- (gnu-) 리눅스의 코어 도구들을 배우세요. 장기적인 이점을 이해하게 될 거에요. 예를 들어, grep과 sed를 계속 사용했다면 검색과 대체에 훨씬 더 좋아졌을 텐데요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 2022 — Vim 몽션 채택하기\n\n![이미지](/assets/img/2024-05-20-OvercomingVim-PhobiaMyJourneyofRedemption_6.png)\n\n나는 Vim을 사용하기로 결심했습니다. 제 특정 업무 흐름에 대해 어떤 것이 더 나은지는 아니라고 생각하지만, VS Code에 대한 의존성을 깨고 싶었기 때문입니다.\n\n나는 일할 때 Vim으로 전환이 불가능하다는 것을 알고 있었습니다. 그래서, VS Code에서 Vim 바인딩을 사용하는 중간 지점으로 타협했습니다. Ben Awad라는 유튜버 덕분에 Vim을 채택하기 위한 이 평화로운 길을 보여줘서 고마웠습니다. 그는 어떻게 나는 정말 빠르게 이동할 뿐인데, 그가 마법처럼 랜덤한 장소로 순간이동할 수 있는지 항상 궁금했습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n안전을 위해 나는 내 사무실 프로젝트 폴더 모두에서 자동으로 끌 것이다. 당시 Vim에서 특별히 놀랍게 느껴지는 것은 없었는데, VS Code에 대한 유사한 바로 가기를 떠올렸기 때문에 그랬다. 그러나 둘 사이의 지속적인 격렬한 싸움이 어려워지고 있었다. 해가 끝날 즈음에는 Vim 키바인딩을 사용해 VS Code에서 술술 풀어나갈 수 있었다. 사용한 지 거의 1년이 지난 후, 나는 이제 생산적이고 기능적인 이점을 보게 되었다.\n\n## 주요 포인트\n\n- 실용적이고, 당신 이눔! 뛰기 전에 걷는 법을 배우세요.\n- 다른 사람들이 빛나는 것을 이루려는 유혹은 좋은 동기부여다. 개인적인 의지력만으로는 미개척된 영역을 탐험하기에 충분하지 않다. 우리는 이 과정을 가속하기 위해 일부 로켓 연료가 필요하다.\n\n# 2023 — 마지막 이주\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Overcoming Vim Phobia](/assets/img/2024-05-20-OvercomingVim-PhobiaMyJourneyofRedemption_7.png)\n\nVim을 언젠가 제거하고 Vim으로 이동할 것 같다는 생각을 했던 것은 정말 어리석은 일이었습니다. 비슷하게 이동할 수 있어서 그런 줄로만 알고 있었지만, 사실 저는 VS Code를 하는 데 Vim 바인딩을 사용하고 있었을 뿐이었어요. 전체적인 작업 방식이 여전히 부족했습니다. 알게 된 건 몇 가지 키보드 단축키 뿐이었습니다.\n\n그래도 제가 이사를 했죠. 어느 날 프로젝트에서 몇 가지 단어를 찾아 바꿔야 했는데, 할 수 없어서 결국은 다시 돌아왔어요. 그때부터 VS Code는 제 정체성이 되었습니다. VS Code에서 코드를 빠르게 작성해 나가는데 능란했고, 친구들도 그것을 알고 있었죠. 그래서 Vim 대신 다시 VS Code로 자리를 잡았습니다.\n\nVim 열정가들이 하는 것을 내가 할 수 있다는 것에 기쁘기는 했지만, 여전히 편안한 영역에 갇혀있다는 것을 알고 있었어요. 문제는 하이브리드 키바인딩으로 VS Code를 사용하고 있었는데, 이젠 그것마저 다른 것으로 대체했다는 겁니다. 그런 해결책이 어떤 걸까요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다행히도 나는 얼마 전 사무실 프로젝트 작업에서 쉬는 시간을 얻었고, 이것이 내 설정을 전환할 기회라는 것을 깨달았다. Sublime에서 VS Code로 이동하는 데 어려움이 없었음을 깨달았는데, 이는 기쁜 과정이었다. Neovim에서 작업을 시작했고, 음, 고통스러웠지만 계획이 있었다. 뭐가 그리워질 때마다 \"Neovim 문서를 읽고 추가\"할 것이라고 생각했다.\n\n기본 들여쓰기 크기부터 파일 트리, 언어 서버까지 모든 것을 다루었다. 이전에는 ThePrimeagen의 Neovim 설정에 대한 YouTube 비디오를 보고 그것이 나를 너무 압도해서 나만의 설정에 대해 생각하는 것을 일주일 동안 중단해야 했다. 😂\n\n## 주요 포인트\n\n- 유빙 이론을 인정하라. 사람들은 뜨는 것에 끌리고 기반을 만들고 이해하는 데 필요한 작업에 대해 생각하지 않는다. 내 제안은 간단하다면 존중하는 것!\n- 최종 전환을 위한 내 가장 큰 동기부여 요인은 소프트웨어로서 Vim을 둘러싼 멋진 요소였다. 아래 스크린샷에서 볼 수 있는 것은 터미널 창의 텍스트 뿐이며, 이미지나 실제 버튼, 어떠한 종류의 GUI도 없다. 그들은 심지어 진짜 아이콘도 아니라고 한다. 정말 어렵다. 글꼴이나 크기조차 변경할 수 없다고 상상해보라. 모든 것이 검정색 터미널 창에서 텍스트를 신중하게 다루는 것이다. 그것을 만든 사람들에 대한 존경이 나를 이어나가게 한다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 오늘\n\nNeovim으로 전환한 지금은 전혀 다르게 느껴지지 않아요. 이미 Vim 바인딩을 익힌 상태여서, 외관만 바뀐 것 뿐이에요. 하지만 좋은 점은 이 동작들이 어떻게 작동하는지 이해한다는 거예요. 인라인 에러 메시지가 어떻게 표시되는지, 이 멋진 자동 완성이 어디서 나오는지, 각 줄이 어떻게 포맷팅되는지 등을 알아요. 되돌아보면 VS Code나 그 확장 기능의 소스 코드를 엿볼 수도 있었겠지만, 당시에는 사용하기만 하고 배우지 않는 태도였죠.\n\n가장 큰 변화는 소프트웨어를 소비자가 아닌 빌더의 마음가짐으로 바라보게 된 것이에요. 이제 무엇인가 보면, 어떻게 만들지 고민하는 게 아니라 어떻게 사용할지 생각해요.\n\n# 코딩 세팅 몇 개 스냅샷\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Image 8](/assets/img/2024-05-20-OvercomingVim-PhobiaMyJourneyofRedemption_8.png)\n\n![Image 9](/assets/img/2024-05-20-OvercomingVim-PhobiaMyJourneyofRedemption_9.png)\n\n![Image 10](/assets/img/2024-05-20-OvercomingVim-PhobiaMyJourneyofRedemption_10.png)\n\n![Image 11](/assets/img/2024-05-20-OvercomingVim-PhobiaMyJourneyofRedemption_11.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-05-20-OvercomingVim-PhobiaMyJourneyofRedemption_12.png\" />\n\n<img src=\"/assets/img/2024-05-20-OvercomingVim-PhobiaMyJourneyofRedemption_13.png\" />\n\n아쉽게도 모든 화면과 유틸리티를 보여드릴 순 없지만, 만약 여러분이 이 설정을 좋아하신다면, 모든 것을 처음부터 어떻게 설정했는지에 대한 글을 쓸 수 있어요. 터미널과 Vim 커스터마이징의 기초에 관한 자세한 튜토리얼이죠. 원하신다면 댓글을 남겨주세요.\n\n제 설정을 사용하고 싶으신가요? 저의 도트파일을 깃허브에서 클론하세요: https://github.com/sameer1612/.dotfiles\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 자주 묻는 질문\n\n- Vim을 사용하면 개발자로서 능력이 향상됩니까?\n  — 네, 확실하게 개선될 거예요.\n- 전환하기 어렵습니까?\n  — 꽤 쉬워요. 몇백 가지의 키 바인딩만 있지요, ㅋㅋ (저는 이를 30분 안에 모두 배우는 초월적 비법이 있어요)\n- 왜 중요한가요? 그냥 편집기일 뿐인데요. 제 일은 그 안에 쓴 것으로 완성됩니다.\n  — 엔지니어가 되고 싶습니까, 아니면 작가가 되고 싶나요. 빠르게 결정하세요! 엔지니어를 선택한 것은 다행이에요. 이제 다시 생각해보세요: 당신이 일상 업무에서 추상화된 엔지니어링의 기본을 얼마나 많이 알고 있는가요? 근본이 약한 엔지니어가 되길 원하지 않으시죠?\n- 시작하기가 너무 어렵습니다. 잡을 수 있을까요?\n  — 2년이 걸렸고, 여러 차례 그만 두었습니다. 처음부터 다시 시작하여 점진적으로 기능을 추가할 때만 성공했어요. 이제 이건 당신의 자녀입니다. 당신은 이에 대해 나쁜 말을 할 일이 없을 거예요. 자신의 관심사를 선택하지 않습니다. 노력한 것에 관심을 갖게 됩니다.\n\n<img src=\"/assets/img/2024-05-20-OvercomingVim-PhobiaMyJourneyofRedemption_14.png\" />\n\n# 연결하고 싶으세요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n[\nLinked\nIn\n](LinkedIn)\n\n[\nWebsite\n](Website)\n","ogImage":{"url":"/assets/img/2024-05-20-OvercomingVim-PhobiaMyJourneyofRedemption_0.png"},"coverImage":"/assets/img/2024-05-20-OvercomingVim-PhobiaMyJourneyofRedemption_0.png","tag":["Tech"],"readingTime":15},{"title":"데이터 안전하게 보호되고 있나요 솔루션 소개 명칭 Lockdown","description":"","date":"2024-05-20 17:57","slug":"2024-05-20-IsYourDataSafeIntroducingaSolutionItsCalledLockdown","content":"\n![Lockdown](/assets/img/2024-05-20-IsYourDataSafeIntroducingaSolutionItsCalledLockdown_0.png)\n\n소개:  \n오늘날의 디지털 환경에서는 민감한 데이터를 보호하는 것이 이전보다 더 중요합니다. “Lockdown”은 귀하의 소중한 정보를 보호하기 위해 설계된 강력하면서도 사용자 친화적인 데이터 암호화 도구를 소개합니다. Lockdown을 사용하여 비즈니스에서 고객 기록을 처리하거나 개인 파일을 보호하는 경우에도 데이터를 쉽게 암호화하여 기밀성과 무결성을 보장할 수 있습니다.\n\n주요 기능:\n\n- 견고한 암호화: Linux 통합 키 설정 (LUKS) 표준을 사용하여 디스크 암호화에 강력한 보안을 제공합니다.\n- 사용하기 쉬운 인터페이스: Lockdown은 간단한 명령줄 인터페이스를 제공하여 암호화 및 복호화 작업을 직관적이고 쉽게 수행할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n사용 사례:\n\n- 기업 보안 강화: Lockdown은 고가의 기업용 솔루션에 투자하지 않고도 데이터 보호 조치를 강화하려는 기업들에게 비용 효율적인 대안으로 제공됩니다.\n- 비즈니스 데이터 보호: Lockdown은 민감한 고객 정보, 재무 기록 및 독점 데이터를 보호하려는 기업에 이상적입니다.\n- 개인 정보 보호: 개인들은 Lockdown을 사용하여 개인 파일을 암호화하여 민감한 문서, 사진 및 기타 데이터의 개인 정보 보호와 기밀 보호를 확보할 수 있습니다.\n\n시작하기:\nLockdown은 오픈 소스로 GitHub에서 제공됩니다. [GitHub 저장소]를 방문하여 소스 코드를 탐색하고 프로젝트에 기여하거나 최신 릴리스를 다운로드하세요. Lockdown을 사용하면 데이터 보안을 제어하고 가장 중요한 것을 보호할 수 있습니다.\n\n계속해서 주목해 주세요!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저는 'Lockdown'을 완벽하게 만들어 강력하고 사용자 친화적인 데이터 암호화 도구로 발전시키고 있습니다. 개발이 진행됨에 따라 블로그에서 업데이트와 튜토리얼을 공유할 예정입니다.\n\n한편, 오늘부터 데이터 보안을 제어할 수 있습니다!\n\n요약:\nLockdown은 사용자가 데이터를 쉽고 효과적으로 암호화하여 무단 접근과 잠재적인 데이터 유출로부터 안전하게 보호합니다. 비즈니스 소유자, 개발자 또는 개인 정보 보호에 민감한 개인이든, Lockdown은 귀하의 정보의 기밀성과 무결성을 보장하는 데 필요한 도구를 제공합니다.\n\nGitHub 저장소:\nGitHub에서 Lockdown을 살펴보세요: [GitHub 저장소]\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n작성자 소개:\n\n안녕하세요! 저는 디지턈 자산을 안전하게 보호하고 사이버 보안을 강화하는 보안 애호가인 Akilesh입니다. 온라인 존재를 강화하는 통찰을 얻으려면 [LinkedIn]에서 저와 연락하세요!\n","ogImage":{"url":"/assets/img/2024-05-20-IsYourDataSafeIntroducingaSolutionItsCalledLockdown_0.png"},"coverImage":"/assets/img/2024-05-20-IsYourDataSafeIntroducingaSolutionItsCalledLockdown_0.png","tag":["Tech"],"readingTime":3},{"title":"sh와 Bash의 차이점","description":"","date":"2024-05-20 17:56","slug":"2024-05-20-WhatstheDifferenceBetweenshandBash","content":"\n<img src=\"/assets/img/2024-05-20-WhatstheDifferenceBetweenshandBash_0.png\" />\n\n# 1. 개요\n\n이 튜토리얼에서는 sh와 Bash 간의 차이점과 제공하는 기능에 대해 알아볼 것입니다. 마지막으로 쓸 쉘에 대해 논의할 것입니다.\n\n# 2. 쉘이란 무엇인가요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n쉘은 사용자가 명령을 입력하고 해석한 다음 처리하기 위해 운영 체제로 전달하는 컴퓨터 프로그램입니다. 따라서 사용자와 운영 체제 사이의 인터페이스 역할을 하며 사용자가 컴퓨터와 상호 작용할 수 있게 해줍니다. 쉘과 상호 작용하기 위해서는 gnome-terminal, konsole 또는 st와 같은 터미널 에뮬레이터가 필요합니다.\n\n대부분의 리눅스 기반 운영 체제에는 적어도 하나의 쉘 프로그램이 제공됩니다. 쉘 프로그램은 대부분 Dash, Bash 또는 둘 다일 것입니다.\n\n## 2.1. 현재 사용 중인 쉘\n\n우리는 /etc/passwd 파일을 grep을 사용해서 간단히 읽어 현재 사용 중인 쉘을 확인할 수 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n$ grep $USER /etc/passwd\nhey:x:1000:998::/home/hey:/bin/bash\n```\n\n- 그렙 명령은 패턴과 읽을 파일을 예상합니다.\n- $USER 환경 변수는 현재 로그인한 사용자로 확장됩니다.\n- /etc/passwd 파일은 사용자 계정 정보를 저장합니다.\n\n해당 명령을 실행하여 기본 셸이 bash 임을 확인할 수 있습니다. 따라서 터미널 에뮬레이터를 사용할 때는 우리의 명령이 bash에 의해 해석될 것입니다.\n\n# 2.2. 설치된 셸\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저희가 현재 설치된 모든 셸을 확인하려면 /etc/shells 파일을 읽어보면 됩니다:\n\n```bash\n$ cat /etc/shells\n# 유효한 로그인 셸의 경로\n# 자세한 내용은 shells(5)를 참조하세요.\n```\n\n```bash\n/bin/sh\n/bin/bash\n/bin/dash\n```\n\n저희는 기계에 셸이 세 개 설치되어 있는 것을 확인할 수 있습니다. 기술적으로, 두 개의 셸만 있지만 다음 섹션에서 그 이유를 알아볼 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 3. sh\n\nsh은 또한 Bourne Shell로 알려져 있으며 POSIX 표준에 따라 정의된 UNIX 유사 시스템용 명령 프로그래밍 언어입니다. sh는 키보드 또는 파일(일반적으로 스크립트 파일이라고 함)에서 입력을 받을 수 있습니다. 대부분의 Linux 시스템에서는 원래 Bourne Shell, dash 및 ksh와 같은 프로그램을 통해 구현됩니다.\n\n# 3.1. POSIX 시스템의 sh\n\nPOSIX는 IEEE에서 정의한 표준 군으로, 공급 업체들이 운영 체제를 호환되도록 만들기 위한 것입니다. 이것은 우리가 일련의 지침을 따라 다중 운영 체제를 위한 크로스 플랫폼 소프트웨어를 개발할 수 있도록 도와줍니다. sh는 이러한 표준을 준수합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n대부분의 Linux 시스템에서 sh은 Bourne Shell의 실제 구현으로의 심볼릭 링크입니다. 다음 명령을 통해 확인할 수 있습니다:\n\n```js\n$ file -h /bin/sh\n/bin/sh: symbolic link to dash\n```\n\n우리는 /bin/sh가 dash에 심볼릭 링크된 것을 볼 수 있습니다. 이는 Debian 기반 배포판에서 사용되는 POSIX 호환 쉘입니다. 쉘 스크립트에서는 #!/bin/sh를 첫 번째 줄에 넣을 수 있는데, 이렇게 하면 dash에서 실행됩니다:\n\n```js\n#!/bin/sh\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\necho Hello, World!\n```\n\n스크립트는 #!/bin/sh 라인이 가리키는 대로 실행됩니다. 우리의 경우에는 dash가 될 것입니다. 따라서 우리의 스크립트는 POSIX 표준을 준수하기 때문에 다른 POSIX 호환 운영 체제로 이식할 수 있습니다.\n\n## 3.2. 흔한 실수\n\n대부분의 셸 스크립트는 첫 번째 줄에 #!/bin/sh를 가지고 있지만, /bin/sh가 Bourne 호환 셸을 가리키는 심볼릭 링크일 수 없다는 점을 알아야 합니다. 때로는 스크립트 작성자들이 /bin/sh가 /bin/bash 또는 /bin/dash를 가리킨다고 가정하지만, 이러한 것은 필수적이지 않을 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n따라서 스크립트를 작성하고 실행하기 전에 /bin/sh의 유형을 확인하는 것이 좋은 실천입니다.\n\n## 4. Bash\n\nsh와 마찬가지로 Bash(Bourne Again Shell)는 명령어 언어 처리기이자 쉘입니다. 대부분의 Linux 배포판에서 기본 로그인 쉘이며 sh의 기능을 지원하면서 그 이상의 확장 기능을 제공하는 sh의 상위 집합입니다. 그러나 대부분의 명령은 sh에서와 유사하게 작동합니다.\n\nBash가 출시된 이후, Linux 운영 체제의 사실상 표준 쉘로 사용되어 왔습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 4.1. Bash를 POSIX 규격 셸로 사용하기\n\n오랜 시간 동안 /bin/sh은 /bin/bash로 링크되어 있었습니다. 시간이 지남에 따라 bash는 더 많은 기능과 확장 기능을 개발했는데, 이 중 일부는 POSIX 표준을 준수하지 않았습니다. 그 결과, 대부분의 Linux 배포판에서는 더 이상 옵션으로 사용되지 않았고, 다른 POSIX 규격 셸이 대신 사용되었습니다.\n\n그러나 여전히 Bash를 POSIX 규격 모드에서 사용할 수 있으며, 이를 다음과 같이 bash 명령에 --posix 플래그를 사용하여 호출할 수 있습니다:\n\n```bash\n$ bash --posix\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n대안으로 Bash 스크립트를 POSIX 표준에 맞게 조정할 수도 있습니다:\n\n```js\n#!/bin/bash\n```\n\n```js\nset -o posix\necho Hello, World\n```\n\nset 명령어는 스크립트 내에서 옵션을 활성화하는데, 이 경우에는 스크립트를 POSIX 모드로 실행하게 됩니다. 따라서 FreeBSD 및 UNIX와 같은 다른 운영 체제에서도 스크립트를 사용할 수 있게 만들어줍니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 4.2. 특징\n\nBash는 현대적인 프로그래밍 언어와 많이 닮은 많은 유연성과 구문을 제공합니다. Bash에서 소개된 몇 가지 주목할만한 기능은 다음과 같습니다:\n\n- `TAB` 키를 사용하여 빠르게 명령을 완전할 수 있는 명령행 완성\n- `Up` 화살표 키 또는 `CTRL-R`을 사용하여 이전에 실행한 명령을 빠르게 검색하는 명령 히스토리\n- 외부 프로그램을 사용하지 않고 산술 평가\n- 문자열 인덱스와 배열을 만들 수 있는 연상 배열\n- 명령행 편집을 위한 키보드 단축키\n- 수정 가능성을 통해 Bash가 제공하는 기본 프레젠테이션을 수정할 수 있습니다\n\n# 4.3. Bash 스크립트 작성\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nBash는 파일에서 명령어를 읽을 수도 있습니다. 첫 번째 줄에 #!/bin/bash Shebang을 지정한 후에 스크립트를 작성합니다:\n\n```shell\n#!/bin/bash\n```\n\n```shell\n# 숫자가 짝수인지 홀수인지 확인\nread -p \"숫자를 입력하세요: \" number\nif [ `expr $number % 2` -eq 0 ]; then\n    echo \"${number}은(는) 짝수입니다\"\nelse\n    echo \"${number}은(는) 홀수입니다\"\nfi\n```\n\n스크립트 파일을 저장하고 실행 가능하도록 만들어주세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```sh\n$ chmod +x is_even.sh\n$ ./is_even\n숫자를 입력하세요: 13\n13는 홀수입니다\n```\n\n이 스크립트는 대부분의 리눅스 배포판에서 실행할 수 있지만, FreeBSD에서 동일한 스크립트를 실행하면 문제가 발생할 수 있습니다.\n\n# 5. 어떤 것을 사용해야 할까요?\n\n두 쉘 모두 유용하며, 다른 상황에서 활용할 수 있습니다. 예를 들어, sh를 사용하면 스크립트를 여러 시스템 간에 호환되게 할 수 있습니다. 반면에 Bash는 유연한 구문과 더 매력적인 기능을 제공하기 때문에 선택할 수도 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그래도 휴대성과 호환성에 대해 걱정한다면 Bash를 사용하여 순수한 POSIX 모드에서 실행할 수 있습니다. 또한, sh 스크립트를 작성하면 대부분 변경하지 않고 Bash에서 실행될 것입니다. 왜냐하면 Bash는 sh와 하위 호환성이 있기 때문입니다.\n\n# 6. 결론\n\n본 문서에서는 셸 프로그램의 개요와 시스템에 현재 설치된 쉘을 어떻게 찾을 수 있는지 살펴보았습니다. 그리고 Bash와 sh 사이의 차이점과 기능 그리고 POSIX와의 일치에 대해 알아보았습니다.\n","ogImage":{"url":"/assets/img/2024-05-20-WhatstheDifferenceBetweenshandBash_0.png"},"coverImage":"/assets/img/2024-05-20-WhatstheDifferenceBetweenshandBash_0.png","tag":["Tech"],"readingTime":8},{"title":"리눅스의 단일 용도 철학이 실패할 때 NFS","description":"","date":"2024-05-20 17:54","slug":"2024-05-20-WhentheLinuxsingle-purposephilosophyfailsNFS","content":"\n![2024-05-20-WhentheLinuxsingle-purposephilosophyfailsNFS_0](/assets/img/2024-05-20-WhentheLinuxsingle-purposephilosophyfailsNFS_0.png)\n\n오픈 소스 세계에는 오랜 역사를 가진 도전할 수 없는 공리가 있습니다: 최고의 애플리케이션은 작고 하나의 목적을 가지고 있어야 합니다. 사진에서 배경을 제거하는 도구가 필요하다면, 사진을 받아 배경이 없는 사진을 출력하는 간단한 터미널 프로그램이 있어야 합니다. 파일 이름을 변경하여 타임 스탬프를 추가하고 싶다면, 파일을 받아 이름이 변경된 파일을 출력하는 작은 터미널 프로그램이 있어야 합니다. 이렇게 하면 배경을 제거하고 사진에 타임 스탬프를 추가하려면 프로그램을 연결하여 Linux 셸에서 새로운 도구를 만들 수 있습니다.\n\n다양한 도구로 이루어진 도구상자를 받아 작업을 완료하는 데 사용할 수 있습니다. 작업은 매우 복잡할 수 있어도 도구상자에 있는 어떤 도구 하나만으로는 해결할 수 없을 수도 있습니다. 도구들은 심지어 그것을 다루기 위해 설계되지 않았을 수도 있습니다. 그러나 결합하면 도구를 만든 사람들이 생각하지 못한 새로운 것을 얻을 수 있습니다. 조금의 창의력을 발휘하여 복잡한 작업을 처리할 수 있게 됩니다. 이것이 Linux의 단일 목적 철학입니다.\n\n또 다른 유명한 Linux 철학은 모든 것은 파일이라는 것입니다. 이들은 함께 가기 때문에 만약 모든 것이 파일이라면, 파일에 일반적으로 적용되는 모든 도구를 모든 것에 적용할 수 있습니다. 네트워크 리소스는 파일 명령을 사용하여 읽고, 프로세스 간 통신은 파일로 처리되며, Linux 프로세스에는 고유한 가상 파일 시스템이 있으며, 네트워크 공유도 물리적 파일 시스템처럼 마운트됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 맞게 했나요?\n\n<img src=\"/assets/img/2024-05-20-WhentheLinuxsingle-purposephilosophyfailsNFS_1.png\" />\n\n이것은 작고 사소한 도구를 쌓고 결합하여 얼마나 멀리 갈 수 있는지를 보여줍니다. 단순한 파일 읽기 프로그램을 만들고, 그것을 어디에나 적용합니다. 모든 극단을 도전함으로써, 전체 세계에 걸쳐 단일 물리적 입력 및 출력을 가진 통합 분산 운영 체제를 만들어낼 수도 있습니다.\n\n이겪어보기에는 멋져 보이지만, 개발자는 작고 간단한 범용 파일 읽기 프로그램을 작성했으니 일이 끝났다고 생각하며 스스로를 칭찬할 수 있겠지만, 지나치게 나아가면 또 다른 철학, 이번에는 원치 않는 철학으로 전환될 수 있습니다: 모든 것이 모두로 가듯이. 나는 공구상자를 열고 렌치, 망치, 작은 삽, 가위를 찾아내어 생각합니다. “많은 못이 있으니 망치가 최선일 것입니다”. 정원에 꽃들에 물을 주어야 한다는 사실을 무시하더라도, 망치 위에 물을 들어올리며 균형을 맞춰주어 모은 물방울이 떨어지지 않도록 조심스럽게 운반할 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n리눅스 세계에서는 이런 일반화로 많은 헷갈림을 일으키기도 했죠. 모든 사람들을 위해 모든 것을 되게 하려다 보니 복잡한 파일 구조가 나타나고, 최신 기능을 계속 지원하다 보니 90년대에 처음 설계된 파일에 잘 매치되지 않는 기능이 포함되었죠.\n\n예를 들어, 파일 공유에 대해 알아보겠습니다.\n\n![이미지](/assets/img/2024-05-20-WhentheLinuxsingle-purposephilosophyfailsNFS_2.png)\n\n리눅스 시스템에서 네이티브 파일 공유는 NFS(Network File System)로 이루어집니다. 목적은 무엇일까요? 간단하고 독특합니다: 네트워크에서 파일을 공유하는 것. 구현 방식은 어떨까요? 개별적인 목적을 가졌습니다: 오로지 공유만. 이는 네트워크를 통해 공유 폴더를 다른 컴퓨터의 로컬 파일 시스템으로 마운트할 수 있도록 합니다. 이후에는 로컬 리눅스가 다른 파일과 마찬가지로 공유를 관리합니다. 그때에는 이 정도면 충분했죠.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n구현? 믿기 힘들지만, 여기에 있습니다. NFS는 마운트 가능한 형식으로 공유물을 게시하는 것만 다루게 됩니다. 내 서버에 당신이 필요로 하는 파일이 있으므로, 나는 NFS를 구성하여 그것을 게시하고 당신은 마운트 명령을 사용하여 그것을 당신의 끝에 로드할 수 있게 될 것입니다. 모든 것이 쉬워 보이고 사소해 보입니다.\n\n하지만 파일들은 중요한 소유자 및 권한과 같은 메타 정보를 지니고 있습니다. 내 서버의 파일에게 일련의 사용자에 응답하도록 구성되어 있는데, 그것이 해당 컴퓨터에서 찾는 다른 사용자 집합과도 작동해야 한다고 말하는 것은 어떻게 해야 할까요? 보통 그렇게 하지 않습니다. 파일을 공유할 때, 작동할 사용자도 함께 공유합니다. 그러나 NFS의 경우는 그렇지 않습니다. NFS의 경우, 한 컴퓨터가 다른 컴퓨터에서 파일을 마운트할 수 있도록 허용하는 것이 유일한 목적이었습니다. 사용자는 다른 사람의 문제입니다.\n\n## 사용자를 어떻게 다루는가요?\n\n![이미지](/assets/img/2024-05-20-WhentheLinuxsingle-purposephilosophyfailsNFS_3.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n파일이 정확히 동일한 권한으로 내 컴퓨터로 이동했습니다. 파일 소유자는 사용자 1000입니다? 당신의 컴퓨터에서도 동일할 것입니다. 내 컴퓨터에서 소유자가 1000인가 radu? 그럼 당신 컴퓨터에서는 소유자 1000이 누구인가요? 잘 모르겠어요. 그리고 NFS는 신경 쓰지 않았죠. 이것은 내가 자신의 사용자 1000을 만들고 다른 컴퓨터에서 공유를 마운트하고 그 파일에 대해 마치 내 파일인 것처럼 조작할 수 있다는 것을 의미합니다. 이것은 주요 보안 취약성이며 쉽게 악용할 수 있는 문제이며 중요한 결과를 초래할 수 있는 것입니다.\n\n단순성은 문제를 만들었습니다. 두 가지 해결책이 있는 문제: 전체 네트워크의 모든 사용자를 제어하거나(인터넷이 종종 전체 네트워크인 때가 있으므로 항상 할 수 없을 수도 있음) 사용자를 \"매핑\"함으로써 복잡성을 회피할 수 있습니다. 사용자 매핑이란 원격 액세스를 로컬 시스템의 기존 및 잘 구성된 사용자로 간주하는 것을 의미합니다. 예를 들어, 사용자 1000이 특정 공유를 마운트하면 그들의 모든 요청을 파일에 대한 잘 알려진 권한을 갖는 로컬 사용자 2000에서 오는 것으로 해석합니다.\n\n파일 공유 도구를 번거롭게 하고 싶지 않습니다. 그냥 파일을 공유하려고 하는 것뿐입니다. 사용자는 상관없어야 합니다. 사용자는 운영 체제에 의해 처리되어야하며 나에 의해 처리되어서는 안 됩니다. 그래서 나는 사용자에 대해 거짓말을 하고 다른 것으로 만들어버립니다. 나는 무능함을 다른 문제로 대체하고 있는지 궁금해하지 않습니다. 모든 것이 망치인데, 망치가 필요합니다. 아직 망치를 다루고 있는지 궁금해할까요? 아니요, 그냥 망치를 사용하고 싶어합니다. 그래서 새로운 종류의 망치로 작업하기 위해 망치를 보강합니다.\n\n로컬 파일은 로컬 사용자와 같지 않기 때문에 네트워크 파일도 같지 않습니다. 네트워크 파일은 많은 질문에 대답하는 객체입니다. 이 파일은 무엇이며, 내용은 무엇이며, 작업 권한은 무엇이며, 로컬 컴퓨터에서 파일이 얼마나 떨어져 있는지, 현재 파일에 작업 중인 협업자가 있는지, 서버에서 파일 편집을 위해 파일이 잠기는 사람은 누군지, 이 파일을 누구에게 제공할 수 있는지, 공유 만료일이 언제인지 등의 질문에 답하게 됩니다. 모든 이러한 정보는 일반 파일 메타데이터에 기록되지 않습니다. 이 모든 것이 파일 공유 시스템인 이 경우 NFS의 역할입니다. 그러나 NFS는 이 모든 것을 할 수 없었습니다. 이는 파일이 불충분하다는 의미는 아니지만 확실히 NFS를 만들어 냈습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## NFS와 SMB 비교\n\n![이미지](/assets/img/2024-05-20-WhentheLinuxsingle-purposephilosophyfailsNFS_4.png)\n\n한편에선, Windows 세계에서 Microsoft는 자체 공유 시스템인 SMB를 구현했습니다. 물론, 이것은 모든 Linux 사용자들에게 혐오를 사랑하는 NFS에 '야만인'으로 여겨졌습니다. 그러나 SMB는 단일 목적의 유틸리티로 설계되지 않았습니다. 사용자, 잠금, 충돌 해결 및 협업까지 주의 깊게 고려되었습니다. Windows에는 파일이 아닌 객체으로 실용적이고 유용한 계층적 설명을 가진 모든 필요한 정보를 포착하는 공유물이었습니다.\n\nSMB에는 각자의 사용자 집합이 있었습니다. 파일을 얻고 싶다면, 적절한 자격 증명으로 SMB 서버에 로그인해야 했습니다. 이 자격 증명은 정확히 본인이 어떤 액세스 권한을 갖고 어디까지 갈 수 있는지를 정의했습니다. 그리고 네트워크 전체에서 통일된 사용자 시스템이 필요하지 않았습니다. 물론 가능하다면 Active Directory 서버로 사용할 수도 있었지만, 필수는 아니었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n하지만 통합 사용자 시스템에 대해 조금 이야기해 봅시다. NFS가 사용자를 공유하기 위한 의미 있게 사용하려면 왜 네트워크에 구현하지 않을까요? 네트워크에서 동일한 사용자 집합을 가지려면 식별 서버가 필요합니다. 네트워크에서 Linux 로그인을 대신하는 간단한 LDAP 구현을 사용하거나 각 Linux 시스템에 수동으로 구성해야 하지만 Windows 또는 Mac과 호환되지 않는 LDAP 구현을 사용할 수 있습니다. 또는 모든 것을 포함하지만 로그인 프로세스 전체를 대신하는 무거운 시스템을 사용하여 모든 디바이스 및 사용자를 등록할 수 있습니다.\n\n이 두 가지는 가정용 네트워크에 대한 지나치게 과도한 해결책으로, 항상 사용할 수 없는 전문 시스템 관리자가 필요합니다. 그리고 관리만이 아니라 사용자들도 무엇을 할 수 있는지와 로그인 서버에서 관리되는 것에 대해 학습해야 합니다. 파일을 공유하려는 가정용 네트워크에는 극도로 복잡합니다. 그리고 LDAP 솔루션이 핸드폰에서도 작동하지 않는다는 점을 언급해야 합니다. 클라우드 플랫폼과도 작동하지 않습니다. 다시 말해, 클라우드 플랫폼은 자체 공유 및 로그인 시스템을 구현하기 때문입니다.\n\n같은 단일 용도 철학으로부터 고통 받은 것이 뭘까요? FTP입니다. 다시 인터넷을 통해 파일을 공유하는데 보안이나 인증이 전혀 없었습니다. 아시다시피, FTP는 실패하고 더 이상 사용되지 않습니다. 이를 여러 다른 파일 공유 시스템으로 대체되었는데, 가장 쉬운 것이 SSHFS이며, SSH의 파일 액세스 엔진입니다. SSHFS가 할 수 있는 다른 것이 뭘까요? 안전하고 보안된 로컬 네트워크 파일 공유입니다. 그런데 어떻게 하죠? SMB와 마찬가지로 서버 구성 사용자로 네트워크 서버에 로그인하여 실행합니다.\n\n이 기사를 읽어 주셔서 감사합니다. 맨 위에 면책 조항을 추가하고 싶었는데, 저는 Linux이나 단일 용도 철학에 아무런 문제가 없다는 것을 알려드리고 싶었습니다. 그것은 가능한 곳에 적용될 때 좋은 것입니다. 그러나 잘 맞지 않는 작업에 도구를 재해석하면 기회를 놓치게 됩니다. 오늘날에도 Linux에서 선호되는 공유 시스템은 주로 경험이 부족한 사용자를 위해 SMB입니다. 읽어 주셔서 감사하고 다음에 또 방문해 주시기를 바랍니다!\n","ogImage":{"url":"/assets/img/2024-05-20-WhentheLinuxsingle-purposephilosophyfailsNFS_0.png"},"coverImage":"/assets/img/2024-05-20-WhentheLinuxsingle-purposephilosophyfailsNFS_0.png","tag":["Tech"],"readingTime":8},{"title":"2024년을 위한 딥 러닝을 위한 멀티 GPU 리눅스 머신 설정하기","description":"","date":"2024-05-20 17:53","slug":"2024-05-20-HowtoSetupaMulti-GPULinuxMachineforDeepLearningin2024","content":"\n## 다중 GPU로 딥 러닝\n\n![image](/assets/img/2024-05-20-HowtoSetupaMulti-GPULinuxMachineforDeepLearningin2024_0.png)\n\n딥 러닝 모델(특히 LLMs)이 점점 커지면, GPU 메모리(VRAM)가 더 많이 필요해집니다. 로컬에서 이들을 개발하고 사용하기 위해 다중 GPU 머신을 구축하거나 획득하는 것은 첫 번째 도전일 뿐입니다. 대부분의 라이브러리와 애플리케이션은 기본적으로 단일 GPU만 사용합니다. 따라서 머신에는 다중 GPU 설정을 활용할 수 있는 적절한 드라이버와 라이브러리가 필요합니다.\n\n본 기사는 중요한 라이브러리를 갖춘 Nvidia 다중 GPU(Linux) 머신을 설정하는 방법에 대한 가이드를 제공합니다. 이를 통해 실험에 소요되는 시간을 아낄 수 있고 개발을 시작하는 데 도움이 될 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n마지막으로, 딥러닝을 위한 멀티 GPU 설정을 활용할 수 있는 인기 있는 오픈 소스 라이브러리로의 링크가 제공됩니다.\n\n## 대상\n\n딥러닝을 시작하기 위해 CUDA Toolkit, PyTorch 및 Miniconda를 설치하여 exllamaV2 및 torchtune과 같은 프레임워크를 사용할 것입니다.\n\n©️ 이 이야기에서 언급된 모든 라이브러리 및 정보는 오픈 소스이거나 공개적으로 사용 가능합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 시작하기\n\n![그림](/assets/img/2024-05-20-HowtoSetupaMulti-GPULinuxMachineforDeepLearningin2024_1.png)\n\n터미널에서 nvidia-smi 명령어를 사용하여 기계에 설치된 GPU 수를 확인하십시오. 설치된 GPU의 목록이 출력되어야 합니다. 만약 명령어가 작동하지 않거나 불일치가 있는 경우 먼저 해당 Linux 버전용 Nvidia 드라이버를 설치하십시오. nvidia-smi 명령어가 기계에 설치된 모든 GPU 목록을 출력하도록 확인하십시오.\n\n이 페이지를 따라 설치하지 않은 경우 Nvidia 드라이버를 설치하십시오:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우분투 22.04에 NVIDIA 드라이버를 설치하는 방법 - Linux 자습서 - Linux 구성 학습 - (출처: linuxconfig.org)\n\n## 단계 1 CUDA-Toolkit 설치하기\n\n💡 usr/local/cuda-xx 경로에 기존 CUDA 폴더가 있는지 확인하세요. 해당 폴더가 있다면 CUDA의 버전이 이미 설치된 것입니다. 원하는 CUDA 툴킷이 이미 설치되어 있는 경우 (터미널에서 nvcc 명령으로 확인하실 수 있습니다.) 다음 단계인 단계 2로 이동해주세요.\n\nPyTorch 라이브러리용 필요한 CUDA 버전을 확인하세요: 로컬에서 시작하기 | PyTorch (저희는 CUDA 12.1을 설치하고 있습니다)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nCUDA Toolkit 12.1 Downloads | NVIDIA Developer 에 방문하여 CUDA 12.1을 설치하기 위한 Linux 명령어를 얻을 수 있어요 (OS 버전과 해당하는 “deb (local)” 설치 프로그램 유형을 선택).\n\n![이미지](/assets/img/2024-05-20-HowtoSetupaMulti-GPULinuxMachineforDeepLearningin2024_2.png)\n\n선택한 옵션에 따라 기본 설치 프로그램의 터미널 명령어가 나타날 거에요. CUDA 툴킷을 설치하려면 해당 명령어를 Linux 터미널에서 복사하여 붙여넣기하여 실행하세요. 예를 들어, x86_64 Ubuntu 22 용으로 다음 명령어를 실행하려면 다운로드 폴더에서 터미널을 열고 다음 명령어를 실행하세요:\n\n```js\nwget https://developer.download.nvidia.com/compute/cuda/repos/ubuntu2204/x86_64/cuda-ubuntu2204.pin\nsudo mv cuda-ubuntu2204.pin /etc/apt/preferences.d/cuda-repository-pin-600\nwget https://developer.download.nvidia.com/compute/cuda/12.1.0/local_installers/cuda-repo-ubuntu2204-12-1-local_12.1.0-530.30.02-1_amd64.deb\nsudo dpkg -i cuda-repo-ubuntu2204-12-1-local_12.1.0-530.30.02-1_amd64.deb\nsudo cp /var/cuda-repo-ubuntu2204-12-1-local/cuda-*-keyring.gpg /usr/share/keyrings/\nsudo apt-get update\nsudo apt-get -y install cuda\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n⚠️ CUDA 툴킷을 설치하는 동안, 설치 프로그램이 커널 업데이트를 요구할 수 있습니다. 터미널에서 커널 업데이트를 요청하는 팝업이 나타나면 esc 버튼을 눌러 취소하세요. 이 단계에서는 커널을 업데이트하지 마세요! — 이렇게 하면 Nvidia 드라이버가 손상될 수 있습니다 ☠️.\n\n설치 후 리눅스 머신을 다시 시작하세요. nvcc 명령이 여전히 작동하지 않을 것입니다. CUDA 설치를 PATH에 추가해야 합니다. 나노 편집기를 사용하여 .bashrc 파일을 엽니다.\n\n```js\nnano /home/$USER/.bashrc\n```\n\n.bashrc 파일 맨 아래로 스크롤하여 다음 두 줄을 추가하세요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nexport PATH=\"/usr/local/cuda-12.1/bin:$PATH\"\nexport LD_LIBRARY_PATH=\"/usr/local/cuda-12.1/lib64:$LD_LIBRARY_PATH\"\n```\n\n💡 참고로 설치된 CUDA 버전에 맞게 cuda-12.1을 필요에 따라 cuda-xx로 변경할 수 있습니다. 여기서 'xx'는 CUDA 버전을 나타냅니다.\n\n변경 사항을 저장하고 nano 편집기를 닫으려면:\n\n```js\n변경 사항 저장 - 키보드에서 다음을 누르세요:\n\nctrl + o             --> 저장\n엔터 또는 리턴 키     --> 변경 사항 수락\nctrl + x             --> 편집기 닫기\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n터미널을 닫고 다시 열어주세요. 그러면 nvcc --version 명령을 실행하면 설치된 CUDA 버전이 터미널에 표시될 겁니다.\n\n## 단계 2 - Miniconda 설치\n\nPyTorch를 설치하기 전에 Miniconda를 설치하고, 그 안에 PyTorch를 설치하는 것이 좋습니다. 또한 각 프로젝트마다 새로운 Conda 환경을 만드는 것이 편리합니다.\n\nDownloads 폴더에서 터미널을 열고 다음 명령을 실행하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```bash\nmkdir -p ~/miniconda3\nwget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh -O ~/miniconda3/miniconda.sh\nbash ~/miniconda3/miniconda.sh -b -u -p ~/miniconda3\nrm -rf ~/miniconda3/miniconda.sh\n```\n\n# initiate conda\n\n```bash\n~/miniconda3/bin/conda init bash\n~/miniconda3/bin/conda init zsh\n```\n\n터미널을 닫고 다시 열어주세요. 이제 conda 명령어를 사용할 수 있어요.\n\n## 단계-3 PyTorch 설치하기\n\n(선택 사항) — 프로젝트용 새로운 conda 환경을 생성하세요. `environment-name`을 원하는 이름으로 바꿀 수 있어요. 일반적으로 제 프로젝트 이름으로 지정해요. 💡 프로젝트 작업 전후에 conda activate `environment-name` 및 conda deactivate `environment-name` 명령어를 사용할 수 있어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nconda create -n <environment-name> python=3.11\n\n# 환경 활성화\nconda activate <environment-name>\n```\n\nCUDA 버전에 맞게 PyTorch 라이브러리를 설치하세요. 아래 명령어는 우리가 cuda-12.1에 설치한 것입니다:\n\n```js\npip3 install torch torchvision torchaudio\n```\n\n위 명령어는 PyTorch 설치 가이드 — 로컬에서 시작 | PyTorch 에서 확인할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![PyTorch Installation](/assets/img/2024-05-20-HowtoSetupaMulti-GPULinuxMachineforDeepLearningin2024_3.png)\n\nPyTorch을 설치한 후 터미널에서 PyTorch에서 볼 수 있는 GPU의 수를 확인하세요.\n\n```python\npython\n\n>> import torch\n>> print(torch.cuda.device_count())\n8\n```\n\n이 명령은 시스템에 설치된 GPU의 수를 출력해야 합니다 (내 경우엔 8개), 그리고 nvidia-smi 명령에 나열된 GPU 수와 일치해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n바로 시작해도 괜찮아요! 여러 개의 GPU를 활용하는 딥 러닝 프로젝트에 대해 작업할 준비가 되었어요 🥳.\n\n# 다음 단계는? Multi-GPU 설정을 활용한 딥 러닝 프로젝트로 시작해보세요 (LLMs)\n\n1. 🤗 시작하려면 Hugging Face에서 인기 있는 모델을 복제해보세요:\n\n2. 💬 추론에 대한 설치 (LLM 모델 사용)를 위해 exllamav2를 별도의 환경에 복제하고 설치하세요. 이렇게 하면 모든 GPU가 사용되어 더 빠른 추론이 가능합니다: (자세한 튜토리얼은 제 미디엄 페이지를 확인하세요)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n3. 👨‍🏫 파인 튜닝이나 훈련을 위해 torchtune을 복제하고 설치할 수 있습니다. 지침을 따라 모델을 전체 미세 조정하거나 Lora 미세 조정할 수 있습니다. GPU를 최대한 활용하세요: (자세한 튜토리얼은 내 미디엄 페이지를 확인해주세요)\n\n# 결론\n\n이 안내서는 다중 GPU 딥 러닝에 필요한 기계 설정을 안내해줍니다. 이제 torchtune과 같은 다중 GPU를 활용하는 모든 프로젝트에 대해 작업을 시작할 수 있습니다. 빠른 개발을 위한 torchtune과 exllamaV2의 자세한 튜토리얼을 기대해주세요.\n","ogImage":{"url":"/assets/img/2024-05-20-HowtoSetupaMulti-GPULinuxMachineforDeepLearningin2024_0.png"},"coverImage":"/assets/img/2024-05-20-HowtoSetupaMulti-GPULinuxMachineforDeepLearningin2024_0.png","tag":["Tech"],"readingTime":9},{"title":"프론트엔드를 위한 백엔드BFF 패턴 - 왜 이를 알아야 할까요","description":"","date":"2024-05-20 17:51","slug":"2024-05-20-BackendforfrontendBFFpatternwhydoyouneedtoknowit","content":"\n일반적인 문제는 모바일 앱에 API를 통합해야 할 때 발생합니다. 기존 시스템에 모바일 앱을 만들어야 하는 경우를 상상해보죠. 이 시스템은 API를 제공하여 웹 클라이언트만을 위한 단일 솔루션이었습니다.\n\n![이미지](/assets/img/2024-05-20-BackendforfrontendBFFpatternwhydoyouneedtoknowit_0.png)\n\n고객의 아이디어는 새로운 모바일 앱에만 국한되지 않습니다. 음성 어시스턴트와 저희 API를 사용할 3rd party 서비스도 고려 중입니다. 그래서 이 문제는 한 API가 이러한 종류의 클라이언트를 모두 지원해야 하며, 그들의 요구 사항과 유지 보수에 신경 써야 한다는 것입니다.\n\n![이미지](/assets/img/2024-05-20-BackendforfrontendBFFpatternwhydoyouneedtoknowit_1.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이러한 경우에 도움이 될 수 있는 해결책은 Backend For Frontend 패턴입니다.\n\n# Backend for Frontend (BFF) 디자인 패턴\n\n사용자를 대상으로 한 응용 프로그램을 두 구성 요소로 고려해야 합니다. 클라이언트 측 응용 프로그램은 보안 범위 외부에 위치하고 서버 측 구성 요소 (BFF)는 보안 범위 내부에 위치합니다. BFF는 API 게이트웨이 패턴의 변형이지만 각 클라이언트 유형별로 마이크로서비스와 각 클라이언트 간의 추가 계층을 제공합니다. 단일 진입점 대신 여러 게이트웨이를 소개합니다. 이를 통해 모바일, 웹, 데스크톱, 음성 비서 등 각 클라이언트의 요구를 대상으로 하는 맞춤형 API를 갖고 하나의 공간에 모두 모아두었을 때 발생하는 부풀림을 줄일 수 있습니다. 아래 이미지는 작동 방식을 설명합니다.\n\n![백엔드 포 프론트엔드(BFF) 패턴](/assets/img/2024-05-20-BackendforfrontendBFFpatternwhydoyouneedtoknowit_2.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 친구를 위한 최상의 API 만드는 방법\n\n저희의 클라이언트와 그의 Web API로 돌아와 봅시다. 모바일 관점에서 중요한 데이터 일부만 사용하는 레거시 XML 기반 솔루션일 수 있습니다. BFF를 사용하면 중요한 데이터를 추출하고 더 나은 형식(예: JSON)으로 변환할 수 있습니다. 특정 앱 화면이나 기능에 전용 엔드포인트를 만들고 필요한 데이터를 제공하는 것도 좋은 방법입니다. 예를 들어 아래 이미지에서 녹색 및 노란색 부분이 레거시 API에서 별도로 추출될 수 있음을 보여줍니다. 왜냐하면 다른 모바일 앱 화면이 필요로하기 때문이죠.\n\n![이미지](/assets/img/2024-05-20-BackendforfrontendBFFpatternwhydoyouneedtoknowit_3.png)\n\n여기에서 이 단계에 대한 몇 가지 제안을 찾으실 수 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- UI/UX에 중점을 두고 필요한 데이터에 집중하세요.\n- 처음부터 모든 것을 일반화하려고 하지 마세요. 이렇게 하면 그 컴포넌트가 여러 조직에서 사용되며 많은 사람들이 기여하고자 할 수 있습니다.\n- 특정 기능보다는 일반적인 사용 전략보다 먼저 사용하세요. 이것이 한 클라이언트에 특화된 깔끔한 API를 유지하는 가장 좋은 방법입니다.\n- 3법칙을 따르세요.\n\n# BFF의 이유\n\n백엔드와 프론트엔드의 분리는 UI/UX에 중점을 두기 때문에 프론트엔드 팀이 고유한 요구사항을 제공하는 전용 백엔드 팀을 가질 수 있어 시장 진입 시간을 단축시킵니다. 한 프론트엔드의 새로운 기능 릴리스가 다른 프론트엔드에 영향을 미치지 않습니다.\n\n우리는 API를 훨씬 쉽게 유지하고 수정할 수 있으며, 심지어 특정 프론트엔드를 위한 API 버전 관리를 제공할 수 있습니다. 이는 사용자가 앱을 즉시 업데이트하지 않는 모바일 앱 관점에서 큰 이점입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n프론트엔드와 백엔드 측면에서 시스템을 단순화해봅시다. 타협이 필요하지 않습니다.\n\nBFF는 불필요하거나 민감한 데이터를 프론트엔드 애플리케이션 인터페이스로 전송하기 전에 숨길 수 있어서, 3rd party 서비스를 위한 키 및 토큰을 BFF에서 저장하고 사용할 수 있습니다.\n\n포맷된 데이터를 프론트엔드로 전송할 수 있어 로직을 최소화할 수 있습니다.\n\n이에 더불어 성능 향상과 모바일에 대한 최적화 기회를 제공해줍니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# BFF를 프로젝트에 소개하는 방법\n\n우리 예시에서는 모바일 클라이언트 전용 BFF를 생성하여 시작했으며, 첫 번째 버전에서 웹 클라이언트는 동일한 레거시 API를 사용했습니다. 이 단계는 기존 시스템의 리팩토링 없이 하나의 BFF만 다루기 때문에 보통 작은 단계입니다. 릴리스 후에는 유지 및 개발 관점에서 고객 및 다른 팀 (백엔드, 다른 프론트엔드 팀)에게 그 이점을 보여줄 수 있습니다. 이 경우, 레거시 API 전처리 및 변환과 관련된 전체 부분이 성능 관점에서 별도의 마이크로서비스로 추출되었습니다. 레거시 단일체 시스템과 API의 미래 리팩토링 요구가 이 추출의 또 다른 이유였습니다.\n\n![이미지](/assets/img/2024-05-20-BackendforfrontendBFFpatternwhydoyouneedtoknowit_4.png)\n\n그 다음 단계는 기존 프론트엔드를 위한 전체 BFF 구조였습니다. 아래 그림에서 각각의 마이크로서비스 유형과 사용법을 보여주는 도표를 확인해주세요:\n\n- 파란색은 리팩토링 중인 모노리스 시스템 위에 위치한 레이어들입니다.\n- 녹색은 두 BFF에서 동시에 사용되는 서비스입니다.\n- 반면, 노란색은 배포 관점에서 중복되어 각각의 BFF에 전용으로 제공되며 더 나은 성능을 제공합니다.\n- 빨간색은 모바일 BFF 전용이며, 알림, 메시지 큐 등과 같은 모바일에 특화된 솔루션을 제공합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![BFF Pattern](/assets/img/2024-05-20-BackendforfrontendBFFpatternwhydoyouneedtoknowit_5.png)\n\n# BFF에서의 용납력\n\n용납력은 BFF의 가장 중요한 기능으로, 클라이언트(프론트엔드)에서의 대부분의 문제를 BFF 계층에서 처리할 수 있게 해줍니다. 어떠한 마이크로서비스 변경이 발생해도 비상 배포 없이 모든 BFF에서 제어할 수 있습니다. 모바일 애플리케이션의 업데이트는 스토어에서 동시에 진행되어야 하는 쉬운 작업이 아닙니다. 리뷰와 같은 추가 시간이 필요하며, 때로는 결과가 예상치 못한 거절일 수도 있습니다. BFF 솔루션을 통해 클라이언트(프론트엔드)별로 버전 관리와 하위 호환성을 개별적으로 다룰 수 있습니다. 전체 용납력 및 해당 전략은 BFF 계층에서 처리하고 관리할 수 있습니다. 예를 들어, 저희 시스템에서는 각 모바일 클라이언트마다 별도의 BFF를 도입하여 한 클라이언트에 문제가 발생해도 시스템 전체에 영향을 미치는 문제를 피할 수 있습니다. 자가 DDoS를 실행하는 등의 문제가 있는 경우 해당 BFF를 시스템에서 분리하고 영향을 받지 않으면서 내부 문제를 조사할 수 있습니다. 이는 제3자 서비스를 위해 특별히 설계된 BFF에 대한 좋은 전략입니다.\n\n![BFF Pattern](/assets/img/2024-05-20-BackendforfrontendBFFpatternwhydoyouneedtoknowit_6.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# BFF를 사용하는 시점은?\n\n다른 패턴들처럼, BFF를 애플리케이션에 사용하는 것은 문맥과 따라야 하는 아키텍처에 따라 다릅니다.\n\n앞단(front-end) 하나만 제공하는 애플리케이션의 경우, 서버 측에서 상당한 양의 집계 작업이 요구될 때에만 Backend For Frontend가 의미가 있을 것으로 생각됩니다. 그래도 그런 경우라도 API 게이트웨이 개념을 사용할 수 있습니다. BFF 스타일은 프론트엔드 유형의 수를 늘릴 계획이 있을 때 고려할 수 있습니다.\n\n애플리케이션이 특정 프론트엔드 인터페이스를 위해 최적화된 백엔드를 개발해야 하거나, 클라이언트가 백엔드에서 집계를 필요로 하는 데이터를 소비해야 하는 경우, BFF는 확실히 적합한 선택지입니다. 물론, 추가 BFF 서비스를 배포하는 비용이 높다면 재고해야 할 수도 있지만, 대부분의 경우에 BFF가 제공할 수 있는 관심사 분리는 상당히 매력적인 제안으로 여겨질 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 결론\n\nBackend For Frontend은 개발자와 더 중요한 사용자 및 사용자 경험을 염두에 두고 만들어진 디자인 패턴입니다. 이는 고객을 만나고 상호 작용하고 서비스하는 애플리케이션의 증가에 대한 대답으로, 다양하고 계속 변화하는 필요를 충족하면서 일관성을 유지합니다.\n\n# Droidcon Berlin의 BFF에 관한 비디오\n\n# 다음 기사\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nhttps://medium.com/mobilepeople/bff-backend-is-a-friend-for-frontend-pros-and-cons-71857725fe7f\n","ogImage":{"url":"/assets/img/2024-05-20-BackendforfrontendBFFpatternwhydoyouneedtoknowit_0.png"},"coverImage":"/assets/img/2024-05-20-BackendforfrontendBFFpatternwhydoyouneedtoknowit_0.png","tag":["Tech"],"readingTime":7},{"title":"Swift에서의 관점 지향 프로그래밍","description":"","date":"2024-05-20 17:49","slug":"2024-05-20-Aspect-OrientedProgramminginSwift","content":"\n<img src=\"/assets/img/2024-05-20-Aspect-OrientedProgramminginSwift_0.png\" />\n\n# 소개\n\nAspect-oriented programming (AOP로 앞으로 표기함)은 코드 베이스에 교차하는 관심사를 확장 가능한 방식으로 추가하는 것에 관한 것입니다.\n\n\"Aspect Oriented Programming\"이라는 용어를 처음 만났던 그 때를 아직 기억합니다. 많은 시간이 흘렀고, Swift가 아직 존재하지 않았으며, 우리는 기쁘게 Objective-C 코드를 작성하고 있었습니다. ARAnalytics는 AOP 패러다임을 채택하여 코드 베이스 전반에 걸쳐 분석을 추가하는 것을 간단하게 한 최초의 라이브러리 중 하나였습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n코드를 더 자세히 살펴보면 Objective-C에서 AOP를 구현하는 것이 Peter Steinberger가 그의 Aspects 라이브러리에서 언급한 것처럼 메소드 스위즐링을 구현하는 것이라는 것을 알 수 있어요.\n\nObjective-C와는 달리 Swift는 메시지를 가로채고 실행 중에 동작을 변경할 기능이 많지 않은 엄격하고 정적으로 타입이 지정된 언어에요. 실제로는, 이것은 우리의 코드에 교차 관심을 적용하는 영향을 최소화하기 위해 좋은 디자인의 기초를 설정해야 한다는 의미에요. 우리는 두 가지 주요 구성요소가 필요할 거에요:\n\n- 지연 바인딩을 적용하고 필요에 따라 기반이 되는 구현을 변경할 수 있도록 하는 종속성 주입 기능이 필요해요.\n- 런타임에서 우리가 원하는 동작을 변경할 수 있도록 해주는 가로채기 디자인 패턴인 데코레이터 패턴이 필요해요.\n\n시작해봐요!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# Swift에서의 AOP: 좋은 디자인을 향해서\n\n우리 애플리케이션을 모델링하는 매우 일반적인 접근 방식은 특정 도메인 모델 주변의 모든 기능을 번들로 묶는 단일 “store/repository/service/aggregate”를 가지는 것입니다. 만약 애플리케이션이 할 일을 관리하는 것이라면, 어떤 형식의 “TodoService”가 있을 것입니다. 만약 TV 프로그램을 관리하는 앱이라면, “ShowService”가 있을 것입니다. 아이디어를 얻으셨죠. 이러한 접근 방식은 많은 중간 규모의 앱에 대해 완벽하게 유효한 것이지만, 다른, 더 복잡한 애플리케이션에는 문제가 될 수 있습니다. 소프트웨어의 대부분은 마찬가지로 모든 것이 의존합니다.\n\n다음과 같이 보이는 ShowService를 상상해보십시오:\n\n```js\nprotocol ShowService {\n    func allShows() async -> [Show]\n    func allEpisodes(for show: Show) async -> [Episode]\n    func markEpisodeAsWatched(episode: Episode) async\n    func markShowAsWatched(_ show: Show, until episode: Episode?) async\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리가 말했던 대로 소프트웨어의 대부분은 주관적이며 특정 맥락에 따라 토론의 여지가 있음에도 불구하고, 우리를 안내하는 \"원칙\"들이 있으면 좋습니다. 그 원칙들은 보통 SOLID 원칙들입니다.\n\n## ISP 위반\n\n대부분의 대규모 인터페이스와 마찬가지로, ShowService가 인터페이스 분리 원칙을 위반할 가능성이 매우 높습니다. 이는 클라이언트가 필요하지 않은 메서드를 구현하도록 강제함으로써 나타납니다. 특히 목업을 구현할 때 XCTFail과 같은 메서드들을 사용하여 이를 확인하는 것이 매우 흔합니다.\n\n```js\nstruct ShowServiceMock: ShowService {\n    var shows: [Show]\n\n    func allShows() -> [Show] {\n        shows\n    }\n\n    func allEpisodes(for show: Show) -> [Episode] {\n        XCTFail(\"호출되지 않아야 함\")\n        return []\n    }\n\n    func markEpisodeAsWatched(episode: Episode) {\n        XCTFail(\"호출되지 않아야 함\")\n    }\n\n    func markShowAsWatched(_ show: Show, until episode: Episode?) {\n        XCTFail(\"호출되지 않아야 함\")\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## SRP 위반\n\nISP를 위반할 때, SRP를 위반하는 일도 상당히 흔합니다. SRP는 응집성과 한 가지 이유로만 변경해야 한다는 것과 관련이 있습니다. ShowService 인터페이스에 있는 메서드 수가 늘어날수록, 그 응집성과 SRP를 유지하기가 더욱 어려워질 것입니다.\n\n## OCP 위반\n\nTV 프로그램과 관련된 새로운 기능을 추가하려면 ShowService에 새로운 메서드를 추가해야 하며, 서비스의 모든 구현이 그 변경 사항을 수용하고 컴파일 오류를 수정해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 큰 인터페이스는 병목 현상을 유발하기 쉽습니다\n\n하루의 끝에 이렇게 큰 인터페이스를 갖고 있다면, 해당 도메인 모델과 관련된 새로운 동작을 추가할 때 병목 현상이 발생할 것입니다. 어떠한 새로운 변경이라도 앱 전체에서 컴파일 오류 및 다시 컴파일을 유발합니다. 좋은 소프트웨어 디자인의 한 가지 주의사항은 자주 변경되지 않는 모듈에 의존하는 것입니다. 우리의 의존성 그래프에서 잎 모듈은 가장 안정된 것이어야 합니다. 왜냐하면 그들이 변경될 때마다 전체 그래프가 다시 컴파일되도록 강제할 것입니다. ShowService를 더 자세히 살펴보면, 매우 빈번하게 변경되는 매우 불안정한 모듈에 전체 앱이 의존한다는 점을 알 수 있습니다. 그런 해롭은 일종의 재앙이네요 😅. 참고로, 이러한 병목 현상은 백엔드 및 마이크로서비스 아키텍처에서도 매우 흔히 발생하며, \"엔티티 서비스 안티패턴(The Entity Service Antipattern)\"이라고 불립니다.\n\n## 첫 번째 접근 방식: CQRS\n\n첫 번째 접근 방식은 큰 인터페이스를 읽기와 쓰기를 위한 두 가지 구분된 인터페이스로 분리하는 것입니다. 이를 Command Query Responsibility Segregation(CQRS)이라고 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```bash\n// 읽기\nprotocol ShowQueryService {\n    func allShows() async -> [Show]\n    func allEpisodes(for show: Show) async -> [Episode]\n}\n\n// 쓰기\nprotocol ShowCommandService {\n    func markEpisodeAsWatched(episode: Episode) async\n    func markShowAsWatched(_ show: Show, until episode: Episode?) async\n}\n```\n\n보통 이렇게 분리하는 것이 읽기와 쓰기에 필요한 기능이 매우 다르기 때문에 합리적입니다. 예를 들어 상태를 변경할 때(쓰기)만 적용되는 보안 정책이 있을 수 있습니다.\n\n하지만 상상할 수 있듯이, 이것은 큰 개선이 아닙니다. 변경의 영향을 더 잘 제한했지만 여전히 자주 변경될 두 가지 \"큰 인터페이스\"가 존재합니다. 더 좋은 방법이 있을 수 있습니다.\n\n## 두 번째 접근 방법: 작은 서비스\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n당신이 깨끗한 아키텍처와 유즈 케이스로 작업하는 데 익숙하다면, 이것들이 정확히 그것입니다.\n\n일부 장단점이 있습니다. 각 메서드 당 프로토콜을 갖는 것은 인터페이스의 폭발을 일으킬 수 있습니다. 그러나 이것은 이전에 이야기한 일부 SOLID 원칙을 준수하는 주요 이점도 가지고 있습니다. 이제 ISP(인터페이스 분리 원칙)를 준수하고 있고 아마도 SRP(단일 책임 원칙)을 준수하고 있을 것입니다. 또한 새로운 기능을 추가할 때는 새로운 튜플(인터페이스, 구현)을 만들기만 하면 되므로 코드를 많이 수정하거나 재컴파일하는 영향을 최소화할 수 있습니다. 그러니 전체가 나쁜 것만은 아닙니다. 기억하세요, 모든 것은 의존합니다. 소프트웨어는 모든 것이 트레이드오프에 관한 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n하지만 \"Aspects\"에 대해 생각해보면, 필요한 각 측면마다 프로토콜 당 하나의 구현을 해야 합니다. 예를 들어 \"로그 기록 Aspect\"를 구현하려면 AllShowsLoggingService와 MarkShowAsWatchedLoggingService 등이 필요합니다. 그래서 우리 앱에서 관심사를 구현하는 데 적합한 방법이 아닌 것 같습니다.\n\n세 번째, 마지막 방법으로 가봅시다.\n\n## 세 번째 방법: 통합된 서비스 인터페이스\n\nAOP를 확장 가능한 방식으로 구현하려면 \"aspects\"를 적용할 모든 서비스에 대해 단일 인터페이스/시마가 필요합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n프로토콜 Service<Input, Output> {\n    associatedtype Input\n    associatedtype Output\n\n    func callAsFunction(input: Input) async throws -> Output\n}\n```\n\n편의성을 위해 다음도 추가해 봅시다.\n\n```js\nextension Service where Input == Void{\n    func callAsFunction() async throws -> Output {\n        try await callAsFunction(input: ())\n    }\n}\n```\n\n단일 인터페이스를 가지고 있어, 다음과 같은 것을 할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\nclass AllShowsService: Service {\n    suspend operator fun invoke(input: Void): List<Show> {\n        // Implementation...\n    }\n}\n\nclass MarkShowAsWatchedService: Service {\n    suspend operator fun invoke(input: Pair<Show, Episode?>) {\n        // Implementation...\n    }\n}\n\ntypealias AllShowsServiceType = Service<Void, List<Show>>\ntypealias MarkShowAsWatchedServiceType = Service<Pair<Show, Episode?>, Void>\n\nclass ViewModel<AllShowsService: AllShowsServiceType, MarkShowAsWatchedService: MarkShowAsWatchedServiceType> {\n    private val allShowsService: AllShowsService\n    private val markShowAsWatchedService: MarkShowAsWatchedService\n\n    init(allShowsService: AllShowsService, markShowAsWatchedService: MarkShowAsWatchedService) {\n        this.allShowsService = allShowsService\n        this.markShowAsWatchedService = markShowAsWatchedService\n    }\n\n    suspend fun markAllShowsAsWatchedButtonTapped() {\n        try {\n            val allShows = allShowsService(Void)\n            coroutineScope {\n                allShows.map { show ->\n                    launch {\n                        markShowAsWatchedService(Pair(show, null))\n                    }\n                }\n            }\n        } catch (e: Exception) {\n            println(\"Some error happened $error\")\n        }\n    }\n}\n```\n\n지금은 ViewModel을 생성할 때 두 개의 입력값을 주입하면 됩니다:\n\n- Service`Void, [Show]`\n- Service`(show: Show, episode: Episode?), Void`\n\nService가 단일 인터페이스이기 때문에 앱 전체의 모든 서비스에 적용할 수 있는 각 측면마다 인터페이스의 구현만 있으면 됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그러면 몇 가지를 구현해 보겠습니다! 확인하시겠지만, 모든 측면은 데코레이터 패턴을 따라 매우 유사합니다.\n\n## 로깅 측면\n\n서비스에 몇 가지 로깅 기능을 추가하는 것은 매우 일반적이고 유용한 측면입니다. 다음과 같이 간단히 구현할 수 있습니다:\n\n```js\nclass LoggingService<Decoratee: Service>: Service {\n    typealias Input = Decoratee.Input\n    typealias Output = Decoratee.Output\n\n    let decoratee: Decoratee\n\n    init(decoratee: Decoratee) {\n        self.decoratee = decoratee\n    }\n\n    func callAsFunction(input: Input) async throws -> Output {\n        let output = try await decoratee(input: input)\n        dump(output)\n        return output\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 프리미엄 사용자 측면\n\n애플리케이션에서 매우 유용한 교차 기능 중 하나는 사용자가 프리미엄 사용자인 경우에만 일부 작업을 수행할 수 있도록 허용하는 것일 수 있습니다. 사용자가 프리미엄 사용자인지 여부를 확인하는 방법을 추상화하기 위해 간단한 `async` 함수를 주입하여 PremiumService 데코레이터를 다음과 같이 만들 수 있습니다:\n\n```js\nclass PremiumService<Decoratee: Service>: Service {\n    struct Error: Swift.Error {}\n\n    typealias Input = Decoratee.Input\n    typealias Output = Decoratee.Output\n\n    let decoratee: Decoratee\n    let isPremiumUser: () async -> Bool\n\n    init(decoratee: Decoratee, isPremiumUser: @escaping () async -> Bool) {\n        self.decoratee = decoratee\n        self.isPremiumUser = isPremiumUser\n    }\n\n    func callAsFunction(input: Input) async throws -> Output {\n        guard await isPremiumUser() else {\n            throw Error()\n        }\n        return try await decoratee(input: input)\n    }\n}\n```\n\n## 캐싱 측면\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n또 다른 일반적인 측면은 캐싱 또는 메모이제이션입니다. 단순히 서비스 입력을 해시 가능한 것으로 제한하고 출력을 Codable로 정의함으로써 모든 서비스에 대해 구현할 수 있습니다.\n\n```js\nprivate(set) var cache: [AnyHashable: Data] = [:]\n\nclass CachingService<Decoratee: Service>: Service where Decoratee.Output: Codable, Decoratee.Input: Hashable {\n    typealias Input = Decoratee.Input\n    typealias Output = Decoratee.Output\n\n    let decoratee: Decoratee\n\n    init(decoratee: Decoratee) {\n        self.decoratee = decoratee\n    }\n\n    func callAsFunction(input: Input) async throws -> Output {\n        if let cachedData = cache[input] {\n            return try JSONDecoder().decode(Output.self, from: cachedData)\n        }\n\n        let output = try await decoratee(input: input)\n        cache[input] = try JSONEncoder().encode(output)\n        return output\n    }\n}\n```\n\n## 지연 측면\n\n네트워크 링크 조절기(Network Link Conditioner)는 다양한 유형의 네트워크 상황을 시뮬레이션하고 인터넷 연결을 매우 나쁘게 만드는 매우 유용한 도구입니다. 우리는 여기에 측면(Aspect)을 활용하여 정확히 그것을 할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nclass DelayService<Decoratee: Service>: Service {\n    typealias Input = Decoratee.Input\n    typealias Output = Decoratee.Output\n\n    let decoratee: Decoratee\n    let duration: UInt64\n\n    init(decoratee: Decoratee, nanoseconds duration: UInt64) {\n        self.decoratee = decoratee\n        self.duration = duration\n    }\n\n    func callAsFunction(input: Input) async throws -> Output {\n        try await Task.sleep(nanoseconds: duration)\n        return try await decoratee(input: input)\n    }\n}\n```\n\n또는 예를 들어 항상 오류를 강제할 수 있는 다른 측면을 추가할 수도 있습니다.\n\n## 측면은 조립 가능합니다.\n\n모든 측면을 준비한 후에는 간단히 뷰 모델을 수정하여 필요한 서비스 유형을 주입하고 여러 측면으로 꾸밀 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nlet viewModel = ViewModel( allShowsService: DelayService(decoratee: LoggingService(decoratee: AllShowsService()), nanoseconds: 5 * NSEC_PER_SEC), markShowAsWatchedService: LoggingService(decoratee: MarkShowAsWatchedService()) )\n```\n\n이렇게 보시다시피 서로 다른 측면을 연쇄시켰습니다. 조립 가능한 요소들이죠.\n\n하지만 중요한 점은 데코레이터 추가는 어플리케이션의 메인 모듈에서 할 수 있다는 것입니다. 여기서 전체 오브젝트 그래프를 구성할 것으로 가정하고, 일종의 구성 루트 패턴을 통해 서비스의 동작을 변경할 수 있습니다. 이렇게 함으로써, 모듈 중 어느 것도 건드리거나 다시 컴파일할 필요 없이 서비스의 행동을 변경할 수 있게 됩니다.\n\n## 편의성\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n데코레이터를 연결하는 것은 조금 귀찮을 수 있지만, 확장 기능을 활용하여 작업성을 개선하고 더 관용적으로 조합할 수 있습니다.\n\n```js\nextension Service {\n    var withLogging: LoggingService<Self> {\n        LoggingService(decoratee: self)\n    }\n\n    func withDelay(nanoseconds duration: UInt64) -> DelayService<Self> {\n        DelayService(decoratee: self, nanoseconds: duration)\n    }\n}\n\n// 이렇게 하는 대신\nDelayService(decoratee: LoggingService(decoratee: AllShowsService()), nanoseconds: 5 * NSEC_PER_SEC),\n\n// 이제 이렇게 할 수 있습니다\nAllShowsService()\n    .withLogging\n    .withDelay(nanoseconds: 5 * NSEC_PER_SEC)\n```\n\n## 데코레이터 자동화\n\nSourcery는 많은 보일러플레이트 코드를 자동화하는 훌륭한 메타프로그래밍 도구입니다. 데코레이터는 이 도구를 적용하기에 좋은 후보입니다. 특히 동일한 측면을 많은 다른 인터페이스에 적용하려는 경우에 유용합니다. 여기를 확인해보세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 결론\n\n이러한 작업에 Objective-C의 동적 특성이 그립다는 것은 사실이지만, Swift에서 쉽게 AOP를 적용할 수 있는 런타임 지원의 부족은 좋은 설계 원칙을 적용하여 해결할 기회로 보고 있습니다.\n\nAOP를 활성화하는 것이 코드를 더 좋게 만든다는 보장은 없습니다. 마찬가지로 테스트 가능한 코드를 가지고 있다고 해서 좋은 코드라는 보장도 없습니다. 오히려 반대의 경우가 더 맞습니다. 코드를 테스트할 수 없는 것은 문제입니다. 테스트할 수 있는 것이라고 해서 그게 무조건 좋은 것은 아닙니다. AOP도 비슷한 맥락에서 볼 수 있습니다.\n\n우리는 코드에서 AOP 기능을 활성화하기 위한 흥미로운 연습을 했습니다. 하지만 우리가 추가한 복잡성을 잊어서는 안 됩니다. 미래에 더 잘 적응하기 위해 추가된 복잡성과 느슨한 결합 사이의 균형을 찾는 것은 개발자로서 가장 어려운 일 중 하나입니다. 이 글은 그저 도구에 불과합니다. 항상 올바른 도구를 올바르게 사용하세요.\n","ogImage":{"url":"/assets/img/2024-05-20-Aspect-OrientedProgramminginSwift_0.png"},"coverImage":"/assets/img/2024-05-20-Aspect-OrientedProgramminginSwift_0.png","tag":["Tech"],"readingTime":16},{"title":"Swift에서 SOLID 원칙에 대한 예제","description":"","date":"2024-05-20 17:46","slug":"2024-05-20-SOLIDprinciplesinSwiftwithexamples","content":"\n위 문서의 향상된 버전을 확인하세요. 향상된 구문 강조와 최신 업데이트가 모두 포함된 개인 블로그에서 확인할 수 있습니다! 피드백과 참여를 환영하며 앞으로의 콘텐츠 제작을 지원해주세요:\n\n# (S) 단일 책임 원칙\n\n단일 책임 원칙(SRP)은 각 엔티티가 단 하나의 작업이나 문제 해결만을 담당해야 한다는 원칙을 말합니다.\n\n일반적으로 SRP를 따르지 않고 코드를 작성하는 예시를 살펴보겠습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nimport Foundation\n\n구조체 처리기 {\n\n    개인 처리기\n\n    함수 처리() {\n\n        // 사람 데이터 가져오기\n        let personAsData = 가져오기()\n\n        // 데이터를 필요한 객체로 파싱\n        let person = 파싱(personAsData)\n\n        // 개인 객체 지역적으로 저장\n        저장하기(person)\n    }\n\n    사적 함수 가져오기() -> 데이터 {\n        \"\"\"\n        {\n            \"name\": \"Shubham Bakshi\",\n            \"age\": 28,\n            \"canTakeANapAnywhere\": true\n\n        }\n        \"\"\".data(using: .utf8)!\n    }\n\n    사적 함수 파싱(_ data: Data) -> 개인 {\n        try! JSONDecoder().decode(개인.self, from: data)\n    }\n\n    사적 함수 저장하기(_ person: 개인) {\n        UserDefaults.standard.set(person, forKey: \"person\")\n    }\n\n}\n\n구조체 개인: Codable {\n    let name: String\n    let age: Int\n    let canTakeANapAnywhere: Bool\n}\n```\n\n우리의 SRP가 깨진 부분은 Handler 엔티티 자체 내에서 모든 작업을 수행하고 있기 때문에 이를 각각의 엔티티로 분리하고 따로 처리해야 합니다. 이제 SRP를 따르는 코드를 살펴보겠습니다:\n\n```js\nimport Foundation\n\n구조체 처리기 {\n\n    개인 가져오기: 가져오기 핸들러\n    개인 파싱: 변환 핸들러\n    개인 저장: 저장 핸들러\n\n    이달함수(init: FetchHandler, ParseHandler, SaveHandler) {\n        self.fetchHandler = fetchHandler\n        self.parseHandler = parseHandler\n        self.saveHandler = saveHandler\n    }\n\n    함수 처리() {\n\n        // 사람 데이터 가져오기\n        let personAsData = fetchHandler.fetch()\n\n        // 데이터를 필요한 객체로 파싱\n        let person = parseHandler.parse(personAsData)\n\n        // 개인 객체 지역적으로 저장\n        saveHandler.save(person)\n    }\n\n}\n\n구조체 가져오기 핸들러 {\n\n    함수 가져오기() -> 데이터 {\n        \"\"\"\n        {\n            \"name\": \"Shubham Bakshi\",\n            \"age\": 28,\n            \"canTakeANapAnywhere\": true\n\n        }\n        \"\"\".data(using: .utf8)!\n    }\n\n}\n\n구조체 변환 핸들러 {\n\n    함수 파싱(_ data: Data) -> 개인 {\n        try! JSONDecoder().decode(개인.self, from: data)\n    }\n\n}\n\n구조체 저장 핸들러 {\n\n    함수 저장(_ person: 개인) {\n        UserDefaults.standard.set(person, forKey: \"person\")\n    }\n\n}\n\n구조체 개인: Codable {\n    let name: String\n    let age: Int\n    let canTakeANapAnywhere: Bool\n}\n```\n\nSRP는 다음과 같은 이점을 제공합니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 더 높은 응집력\n- 코드 중복 가능성 감소\n- 부풀어 오른 클래스 감소\n- 테스트 및 유지 관리가 용이\n- 여러 책임이 분리되어 코드가 깔끔해짐\n\n# (O) 개방-폐쇄 원칙\n\n개방-폐쇄 원칙(OCP)은 엔티티가 확장에 대해 열려 있지만 수정에 대해서는 닫혀 있어야 한다는 것을 말합니다. 이는 클래스가 기존 코드를 수정하지 않고 쉽게 확장 가능해야 함을 의미합니다.\n\n처음에는 정의가 모순적으로 들릴 수 있지만 규모에 맞게 이 원칙을 따르기 시작하면 더 많은 의미를 갖게 됩니다. 이 원칙을 정말로 좁혀보면: 클래스를 만들고 확장할 수 있지만 원본 클래스를 수정할 수 없습니다. 이렇게하는 이유는:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 다른 사람이 클래스를 작성했고 여기에 기능을 추가하거나 변경을 해야 할 때 원래 작성자에게 계속 변경을 요청해야 하거나 직접 변경해야 할 수 있었습니다. 이제 원 작성자는 기능이 작동하도록 작성한 모든 코드에 대해 다른 생각 과정을 가질 수 있습니다.\n- 게다가 클래스는 더 많은 관심사(또는 간단히 기능)를 통합(또는 단순히 추가)할 수 있는데, 이는 SRP를 깨뜨릴 수 있습니다.\n\n위에서 SRP가 활성화된 예에서 고려해보겠습니다. 여기에서는 사용자 개체를 UserDefaults에 저장했지만 이제 CoreData에도 저장하려고 합니다. 우리의 go-to 접근법은 다음과 같습니다:\n\n```js\nimport Foundation\n\nstruct Handler {\n\n    private let fetchHandler: FetchHandler\n    private let parseHandler: ParseHandler\n    private let saveHandler: SaveHandler\n\n    init(fetchHandler: FetchHandler, parseHandler: ParseHandler, saveHandler: SaveHandler) {\n        self.fetchHandler = fetchHandler\n        self.parseHandler = parseHandler\n        self.saveHandler = saveHandler\n    }\n\n    func handle() {\n\n        // 사용자 데이터 가져오기\n        let personAsData = fetchHandler.fetch()\n\n        // 데이터를 필요한 개체로 구문 분석\n        let person = parseHandler.parse(personAsData)\n\n        // 사용자 개체를 UserDefaults에 로컬로 저장\n        saveHandler.saveToUserDefaults(person)\n\n        // 사용자 개체를 CoreData에 로컬로 저장\n        saveHandler.saveToCoreData(person)\n    }\n\n}\n\nstruct FetchHandler {\n\n    func fetch() -> Data {\n        \"\"\"\n        {\n            \"name\": \"Shubham Bakshi\",\n            \"age\": 28,\n            \"canTakeANapAnywhere\": true\n\n        }\n        \"\"\".data(using: .utf8)!\n    }\n\n}\n\nstruct ParseHandler {\n\n    func parse(_ data: Data) -> Person {\n        try! JSONDecoder().decode(Person.self, from: data)\n    }\n\n}\n\nstruct SaveHandler {\n\n    func saveToUserDefaults(_ person: Person) {\n        UserDefaults.standard.set(person, forKey: \"person\")\n    }\n\n    func saveToCoreData(_ person: Person) {\n        // CoreData에 데이터를 저장하는 매우 복잡한 코드\n    }\n\n}\n\nstruct Person: Codable {\n    let name: String\n    let age: Int\n    let canTakeANapAnywhere: Bool\n}\n```\n\n이는 우리가 철저히 테스트하고 나중에 배포한 save-to-User-Defaults의 원래 구현을 변경하고 있어 OCP를 깨뜨립니다. OCP를 수용하기 위해 클래스를 통해 상속을 사용하거나 우리 스위프트 개발자가 사용하기를 사랑하는 단순히 프로토콜 준수를 사용할 수 있습니다!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\nimport Foundation\n\nstruct Handler {\n\n    private let fetchHandler: FetchHandler\n    private let parseHandler: ParseHandler\n    private let saveHandler: PersistenceHandler\n\n    init(fetchHandler: FetchHandler, parseHandler: ParseHandler, saveHandler: PersistenceHandler) {\n        self.fetchHandler = fetchHandler\n        self.parseHandler = parseHandler\n        self.saveHandler = saveHandler\n    }\n\n    func handle() {\n\n        // 사람 데이터 가져오기\n        let personAsData = fetchHandler.fetch()\n\n        // 데이터 구문 분석하여 필요한 객체로 변환\n        let person = parseHandler.parse(personAsData)\n\n        // 사람 객체를 로컬에 저장\n        saveHandler.save(person)\n    }\n\n}\n\nstruct FetchHandler {\n\n    func fetch() -> Data {\n        \"\"\"\n        {\n            \"name\": \"Shubham Bakshi\",\n            \"age\": 28,\n            \"canTakeANapAnywhere\": true\n\n        }\n        \"\"\".data(using: .utf8)!\n    }\n\n}\n\nstruct ParseHandler {\n\n    func parse(_ data: Data) -> Person {\n        try! JSONDecoder().decode(Person.self, from: data)\n    }\n}\n\nprotocol PersistenceType {\n    func save(_ person: Person)\n}\n\nstruct UserDefaultsPersistenceHandler: PersistenceType {\n\n    func save(_ person: Person) {\n        UserDefaults.standard.set(person, forKey: \"person\")\n    }\n}\n\nstruct CoreDataPersistenceHandler: PersistenceType {\n\n    func save(_ person: Person) {\n        // Core data에 데이터를 저장하기 위한 매우 포괄적인 코드\n    }\n}\n\nstruct PersistenceHandler {\n\n    let userDefaultsPersistenceHandler: UserDefaultsPersistenceHandler\n    let coreDataPersistenceHandler: CoreDataPersistenceHandler\n\n    init(userDefaultsPersistenceHandler: UserDefaultsPersistenceHandler, coreDataPersistenceHandler: CoreDataPersistenceHandler) {\n        self.userDefaultsPersistenceHandler = userDefaultsPersistenceHandler\n        self.coreDataPersistenceHandler = coreDataPersistenceHandler\n    }\n\n    func save(_ person: Person) {\n        userDefaultsPersistenceHandler.save(person)\n        coreDataPersistenceHandler.save(person)\n    }\n}\n\nstruct Person: Codable {\n    let name: String\n    let age: Int\n    let canTakeANapAnywhere: Bool\n}\n```\n\n만약 프로토콜 준수를 사용하고 싶지 않다면, 클래스를 통해 상속을 사용하여 동일한 결과를 달성할 수 있습니다:\n\n```kotlin\nimport Foundation\n\nstruct Handler {\n\n    private let fetchHandler: FetchHandler\n    private let parseHandler: ParseHandler\n    private let saveHandler: ModifiedSaveHandler\n\n    init(fetchHandler: FetchHandler, parseHandler: ParseHandler, saveHandler: ModifiedSaveHandler) {\n        self.fetchHandler = fetchHandler\n        self.parseHandler = parseHandler\n        self.saveHandler = saveHandler\n    }\n\n    func handle() {\n\n        // 사람 데이터 가져오기\n        let personAsData = fetchHandler.fetch()\n\n        // 데이터 구문 분석하여 필요한 객체로 변환\n        let person = parseHandler.parse(personAsData)\n\n        // 사람 객체를 로컬에 저장\n        saveHandler.save(person)\n    }\n\n}\n\nstruct FetchHandler {\n\n    func fetch() -> Data {\n        \"\"\"\n        {\n            \"name\": \"Shubham Bakshi\",\n            \"age\": 28,\n            \"canTakeANapAnywhere\": true\n\n        }\n        \"\"\".data(using: .utf8)!\n    }\n\n}\n\nstruct ParseHandler {\n\n    func parse(_ data: Data) -> Person {\n        try! JSONDecoder().decode(Person.self, from: data)\n    }\n\n}\n\nclass SaveHandler {\n\n    func save(_ person: Person) {\n        UserDefaults.standard.set(person, forKey: \"person\")\n    }\n\n}\n\nfinal class ModifiedSaveHandler: SaveHandler {\n\n    override func save(_ person: Person) {\n        super.save(person)\n\n        // Core data에 데이터를 저장하기 위한 매우 포괄적인 코드\n    }\n\n}\n\nstruct Person: Codable {\n    let name: String\n    let age: Int\n    let canTakeANapAnywhere: Bool\n}\n```\n\nOCP의 이점은 다음과 같을 수 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 코드를 유지 및 검토하는 것이 쉽습니다.\n- 추상화 및 다형성의 사용을 촉진합니다.\n- 이미 테스트되고 배포 준비가 된 기존 코드를 수정할 수 없도록 하므로 잠재적 버그를 줄이는 데 도움이 됩니다.\n\n# (L) 리스코프 치환 원칙\n\n솔직히 말해서, 리스코프 치환 원칙(LSK)은 처음에는 아마도 가장 혼란스러운 원칙 중 하나일지도 모릅니다!\n\n그것이 실제로 말하는 것은 슈퍼클래스의 객체는 해당 서브클래스의 객체로 교체할 수 있어야 하는데 프로그램의 정확성에 영향을 미치지 않아야한다는 것입니다. LSK는 단순히 추가 단계를 통한 상속이라고 볼 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n상기한 예시를 사용하여 LSK(Liskov Substitution Principle)를 설명하는 것이 어렵고 혼란스러울 수 있으므로 다른 간단한 예시를 사용하겠습니다. 또한, 이미 해당 내용이 인터넷에 널리 퍼져 있고 때로는 혼란스러울 수 있기 때문에 사각형과 정사각형 예시를 사용하지 않겠습니다.\n\n```js\nimport Foundation\n\nclass Bird {\n    func fly() {\n        print(\"I can fly\")\n    }\n}\n\nfinal class Duck: Bird {\n    /// ✅ Duck은 날 수 있는 새이므로 LSP를 따릅니다.\n}\n\nfinal class Ostrich: Bird {\n    /// ❌ 사실 타조는 새이지만 날지 못하므로 LSP를 위반합니다.\n}\n```\n\n그렇다면 이 문제를 어떻게 해결할까요? 우리는 날 수 있는 새를 위한 별도의 클래스를 만듭니다:\n\n```js\nimport Foundation\n\nclass Bird {\n\n}\n\nclass FlyingBird: Bird {\n    func fly() {\n        print(\"I can fly\")\n    }\n}\n\nfinal class Duck: FlyingBird {\n    /// ✅ Duck은 날 수 있는 새이므로 LSP를 따릅니다.\n}\n\nfinal class Ostrich: Bird {\n    /// ✅ 타조는 이제 날 필요가 없으므로 LSP를 따릅니다.\n    /// (그리고 이제는 다른 일에 집중할 수 있게 되었죠,\n    /// 예를 들어 사람 뒤를 더 빠르게 쫓아가서 겁을 줄 수 있는 방법에 대해)\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nLSP의 이점은 다음과 같습니다:\n\n- 코드는 유연하고 모듈식으로 유지됩니다.\n- 코드 중복을 줄입니다.\n\n# (I) 인터페이스 분리 원칙\n\n인터페이스 분리 원칙(ISP)은 클라이언트가 사용하지 않는 인터페이스를 강제로 구현하거나 클라이언트가 사용하지 않는 메서드에 의존하도록 강요해서는 안된다는 것을 명시합니다. 간단히 말하면, 하나의 뚱뚱한 인터페이스(또는 프로토콜) 대신에 많은 작은 인터페이스를 사용하여 제공하는 메서드에 기반을 둔다는 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nISP(Interface Segregation Principle)은 SRP(Single Responsibility Principle)와 비슷하지만, SRP는 일반적으로 구조체/클래스에 적용되고, ISP는 프로토콜에 적용됩니다.\n\n위의 샘플에서 Bird 예시를 사용하여 ISP를 설명할 수 있지만, 프로토콜(또는 다른 언어에서의 인터페이스)을 사용하여 우리의 entity가 하나 이상의 프로토콜을 준수할 수 있도록 할 것입니다:\n\n```js\nimport Foundation\n\nprotocol Bird {\n\n    func fly()\n\n    func swim()\n\n    func mimic()\n}\n\nfinal class Duck: Bird {\n    /// ❌ Duck는 날 수 있고 헤엄칠 수 있지만 모방할 수는 없으므로 ISP를 위반함\n}\n\nfinal class Parrot: Bird {\n    /// ❌ Parrot은 날 수 있고 모방할 수 있지만 헤엄쳐갈 수는 없으므로 ISP를 위반함\n}\n\nfinal class Penguin: Bird {\n    /// ❌ Penguin은 헤엄칠 수 있지만 날 수 없으며 모방할 수도 없으므로 ISP를 위반함\n}\n```\n\n이 문제를 해결하기 위해 Bird 프로토콜을 하위 프로토콜로 분리하여 각 메서드를 수용할 수 있도록 합니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```swift\nimport Foundation\n\nprotocol FlyingBird {\n    func fly()\n}\n\nprotocol SwimmingBird {\n    func swim()\n}\n\nprotocol MimickingBird {\n    func mimic()\n}\n\nfinal class Duck: FlyingBird, SwimmingBird {\n    /// ✅ Follows ISP since duck can fly and swim without needing to mimic\n}\n\nfinal class Parrot: FlyingBird, MimickingBird {\n    /// ✅ Follows ISP since parrot can fly and mimic without needing to swim\n}\n\nfinal class Penguin: SwimmingBird {\n    /// ✅ Follows ISP since penguin can swim without needing to fly or mimic\n}\n```\n\nISP의 장점은 다음과 같습니다:\n\n- 더 집중된 및 일관된 인터페이스\n- 불필요한 종속성을 피할 수 있음\n- 단일 부풀린 인터페이스를 피할 수 있음\n- 결합을 촉진함\n\n# (D) 의존성 역전 원칙 (Dependency Inversion principle)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n의존 역전 원칙(Dependency Inversion Principle, DIP)은 고수준 모듈이 저수준 모듈에 의존하지 않아야 하며, 둘 다 추상화에 의존해야 한다고 설명합니다. 간단하게 말하면: 구성원은 구상체(concretions)가 아닌 추상화(abstractors)에 의존해야 한다는 것이죠.\n\n이렇게 함으로써 코드가 가능한한 작은 표면적 영역에 의존하도록 보장됩니다. 실제로 코드 자체에 의존하지 않고, 단지 그 코드가 어떻게 행동해야 하는지를 정의하는 계약에만 의존하게 됩니다. 이렇게 함으로써 코드의 한 부분에 오류가 발생해도 다른 의존하는 부분에서 코드가 연쇄적으로 망가지는 결과를 막을 수 있습니다.\n\nDIP는 OCP와 꽤 비슷하게 들리지만 예시로서도 OCP의 예시를 사용할 수 있을 정도이기도 합니다. 그러나 여기서는 다른 예시를 사용하겠습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 예제는 DIP(Dependency Inversion Principle)를 위반합니다. Payment 클래스는 CreditCardPayment과 강하게 결합되어 있으며, 이는 고수준 모듈인 Payment 클래스가 저수준 모듈인 CreditCardPayment에 의존하고 있음을 의미합니다. DIP에 따르면 추상화/프로토콜에 의존해야 합니다.\n\n```js\nimport Foundation\n\nprotocol PaymentMethod {\n    func pay(_ amount: Double)\n}\n\nstruct DebitCardPayment: PaymentMethod {\n    func pay(_ amount: Double) { }\n}\n\nstruct CreditCardPayment: PaymentMethod {\n    func pay(_ amount: Double) { }\n}\n\nstruct ApplePayPayment: PaymentMethod {\n    func pay(_ amount: Double) { }\n}\n\nstruct Payment {\n\n    private let paymentMethod: PaymentMethod\n\n    init(method: PaymentMethod) {\n        paymentMethod = method\n    }\n\n    func makePayment(of amount: Double) {\n        paymentMethod.pay(amount)\n    }\n}\n\nlet creditCardPaymentMethod = CreditCardPayment()\n\nlet payment = Payment(method: creditCardPaymentMethod)\npayment.makePayment(of: 500)\n```\n\nDIP의 장점:\n\n- 결합 감소를 장려함\n- 코드를 보다 유연하고 재사용 가능하며, 민첩하게 만듦\n- 구성 요소 간의 계약을 정의하기 위해 인터페이스 또는 프로토콜 사용을 장려함\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n모두를 종합하자면, 앱에 SOLID 원칙을 통합하는 것에는 많은 이점이 있습니다:\n\n- 코드를 이해, 유지 및 확장하기 쉽게 만들어줍니다.\n- 엔티티의 책임이 적을수록, 엔티티를 변경할 때 코드가 깨지는 가능성이 줄어듭니다.\n- 더 확장 가능하고 테스트하기 쉬운 코드를 작성할 수 있습니다.\n- 코드를 리팩터링하는데 더 적은 복잡성으로 도와줍니다.\n- 딱 맞는 수준의 결합을 사용할 수 있도록 도와줍니다 - 함께 있어야 할 것들은 함께 두고, 분리되어야 하는 것들은 분리합니다.\n\n여기까지, 여러분! 즐거운 코딩하세요!\n\nLinkedIn에서 저와 연결해보세요 👱🏻 또는 다른 채널로 연락할 수 있습니다 📬\n","ogImage":{"url":"/assets/img/2024-05-20-SOLIDprinciplesinSwiftwithexamples_0.png"},"coverImage":"/assets/img/2024-05-20-SOLIDprinciplesinSwiftwithexamples_0.png","tag":["Tech"],"readingTime":16},{"title":"새로운 iOS 18 기능으로 iPhone 사용 방법이 혁신됩니다","description":"","date":"2024-05-20 17:45","slug":"2024-05-20-NewiOS18FeaturesReimagineHowYouInteractWithYouriPhone","content":"\n![image](/assets/img/2024-05-20-NewiOS18FeaturesReimagineHowYouInteractWithYouriPhone_0.png)\n\n우리 모두가 알고 있는 대로, 애플은 항상 기술을 모든 사람들에게 접근 가능하게 만드는 선두에 서 있습니다.\n\n분명히 시청 또는 청각 장애를 가진 사람들이 아이폰으로 어떻게 삶이 더 편해진다고 칭찬하는 소셜 미디어 포스트나 비디오를 보았을 겁니다.\n\niOS 18에서는 아이폰이 그들의 삶을 더욱 쉽게 만든 새로운 접근성 기능이 많이 소개되었습니다. 이 기능들은 iOS 업데이트와 개발자 베타 버전 공식 발표 한 달 전에 도입되었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n하지만 흥미로운 점은 이것들이 일반적인 접근성 기능이 아니라는 것입니다; iPhone에 추가된 몇 가지 멋진 기능은 청각이나 시각 장애를 가진 사람뿐만 아니라 모두에 의해 활용될 수 있습니다.\n\n눈으로 iPhone을 제어하거나, 좋아하는 노래의 비트를 진동을 통해 느끼거나, 자주 사용하는 앱을 사용자 정의 사운드로 실행하는 것에 대해 얘기하고 있습니다.\n\nTony Stark가 할 것 같은 소리가 날 수도 있지만, 이 모든 것이 iOS 18 업데이트의 일환으로 소개된 최신 기능으로 이루어져 있습니다.\n\n이 게시물에서는 Apple이 개발한 가장 흥미로운 새로운 접근성 기능에 대해 자세히 살펴보고, iPhone 경험을 더 직관적이고 개인화된, 재미있는 것으로 만드는 방법에 대해 알아볼 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n시작해봅시다!\n\n## 눈으로 iPhone을 제어하세요 (눈폰? 👀)\n\niOS 18은 iPhone과 상호 작용하는 방식을 바꿀 것이며, 업데이트의 일부로 제공되는 새로운 눈 추적 기능이 그 대표적인 예시입니다.\n\n이 기능은 신체적 장애를 가진 사람들을 고려하여 설계되었으며, 눈을 움직이는 것만으로 iPhone이나 iPad를 제어할 수 있습니다. 네, 정말 매우 놀라운 일이죠.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 작동 방식입니다:\n\n해당 기능 자체는 미래 지향적이고 복잡해 보일 수 있지만, 실제로는 놀랍도록 간단합니다. 따라서 iPhone의 전면 카메라가 모션 추적을 수행하고 화면에서 동작으로 변환하는 모든 작업을 처리합니다.\n\n아마 iPhone의 카메라가 항상 켜져 있고 개인 정보에 대해 걱정하실 수 있겠지만 걱정하지 마세요. 이 모든 작업은 기기 내에서 이루어지므로 데이터가 누구와도 공유되지 않기 때문에 Apple을 포함한 누구에게도 개인 정보가 노출되는 우려가 없습니다.\n\n![iOS 18 새로운 기능으로 아이폰과 상호 작용하는 방식을 새롭게 정의](/assets/img/2024-05-20-NewiOS18FeaturesReimagineHowYouInteractWithYouriPhone_1.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n하지만, 흥미로운 점은 이 눈 추적 기능이 접근성에 관한 것뿐만 아니라 일상 업무에 손쉽게 활용할 수 있는 게임 체인저가 될 수 있다는 점입니다. 말 그대로, 당신은 팔을 올리지 않아도 잠재적으로 인스타그램 피드를 스크롤하거나, 이메일에 답장하거나, 비디오를 건너뛸 수도 있어요.\n\n가장 좋은 점은 추가 하드웨어 없이 iPadOS 및 iOS 앱 전체에서 매끄럽게 작동한다는 것입니다. 이는 카메라나 앱 스토어와 같은 시스템 앱부터 노트, 알림 및 캘린더와 같은 생산성 앱에 이르기까지 모든 것과 함께 사용할 수 있다는 것을 의미해요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\niOS 18에서는 새로운 '음악 햅틱스' 기능이 소개됩니다. 아이폰의 알림을 위해 진동하는 기술이죠. 다만 이번에는 좋아하는 노래의 소리를 진동으로 번역해줄 거예요. 아이폰이 바지 주머니에 있을 때는 활성화하지 않도록 주의하세요. (물론, 그런 스타일이라면 활성화해도 좋지요!)\n\n이 기능의 가장 좋은 점은 일부 곡에만 제한되지 않는다는 것입니다. Apple은 음악 햅틱스가 Apple Music 카탈로그의 수백만 곡과 함께 작동하도록 설계되었다고 언급했습니다. 또한 Apple은 음악 햅틱스를 API로 제공할 예정이라고 밝혔는데, 곧 Spotify나 YouTube Music 같은 앱에서도 볼 수 있을 겁니다.\n\n저는 이 기능이 스트리밍 및 비디오 앱에 도입되어, 폭발이나 싸움 장면과 같은 장면에서 손에 멋진 진동 효과를 줄 수 있기를 희망합니다. 하지만 우선 너무 앞서서 생각해보지는 말아요. 이것이 배터리 수명에도 영향을 줄 것이라고 확신합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n하지만, 이 기능을 통해 음악을 새로운 차원에서 경험하고, 아마도 비디오까지도 즐길 수 있게 될 거예요. 아이폰에서 이 기능을 시도해 보고, 슬픈 노래를 들을 때 내 손과 내 마음에 미치는 효과를 느껴보고 싶네요.\n\n## 안녕 시리, 너 해고야\n\n세계 여러 사람들이 사용하는 iPhone의 기능인 음성 제어가 iOS 18 업데이트에서 크게 개선됩니다.\n\n실제로 음성 제어 기능에 추가되는 것은 두 가지입니다. 첫 번째는 보컬 단축키(Vocal Shortcuts)로, 기본 '애리시리' 깨우는 문구를 원하는 사용자 정의 문구로 바꿀 수 있게 해줍니다. (네, '자비스'로 바꿀 수 있어요)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 새로운 업데이트를 통해 좋아하는 앱을 실행하거나 스마트 홈 장치를 제어하거나 Siri와 함께 하던 모든 작업을 더 자연스럽고 개인적인 명령어로 수행할 수 있게 될 거예요.\n\n신기한 기능이나 재미있는 파티 트릭 이상으로, 음성 단축키는 실제로 말능력에 어려움을 겪는 사람들에게 아이폰을 더 접근 가능하게 해줄 수 있어요. 업데이트에 추가된 두 번째 중요한 기능은 '이상 발화 감지'라는 동반 기능입니다.\n\n이 기능은 기기 내 기계 학습을 사용하여 다양한 발화 패턴에 자동적으로 적응하게 됩니다. 이는 척수성 마비나 ALS와 같은 질병을 앓는 사람들에게 큰 혜택이 될 거예요. 이들은 종종 Siri와 같은 전통적인 음성 비서에게 자신을 이해시키기 어려워 하지만, 솔직히 말하면 Siri는 기본적으로 누구든지 이해하는 데 어려움을 겪죠.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n농담은 빼면서도, Apple이 개인 맞춤형 음성 인식으로 나아가는 것은 접근성에 대한 중요한 진전이며, 인공 지능이 기술을 모든 사람에게 포용적이고 사용자 친화적으로 만드는 방법의 좋은 예입니다.\n\n삼성과 구글과 같은 다른 대기업들이도 이에 합류하고 그러한 기능을 자사 기기에 구현하기를 희망합니다. 그저 가짜 달 사진 찍기나 흔히 알려진 이미지 생성과 같은 획기적인 기능뿐만 아니라 말이죠.\n\n## 멀미와 작별하기 🤢\n\n움직이는 차량 내에서 핸드폰을 사용하려고 할 때 거부감을 느낀 적이 없으면 부러워요. 이동 중에 핸드폰을 사용하려고 할 때 너무 불편한 느낌 중 하나일 것입니다. 여행할 때 가장 최악의 느낌 중 하나인데, 자주 지루하고, 토할 것 같은 욕구를 느낄 때 핸드폰을 사용할 수조차 없으니까요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\niOS 18 업데이트에서 소개된 이 새로운 접근성 기능 '차량 동작 안내'에 대해 무척 기대되는 이유를 설명한 것입니다. 이미 제 개인적으로 가장 선호하는 기능이기도 한데요.\n\n이 기능이 어떻게 동작하는지 설명하기 전에 멀미가 어떻게 발생하는지 설명하겠습니다. 멀미는 주로 보는 것과 느끼는 것 사이의 불일치로 인해 발생합니다. 눈은 정적인 화면에 집중되어 있지만 몸은 움직임을 느끼기 때문에 메스꺼움이 발생할 수 있습니다.\n\niOS 18의 '차량 동작 안내' 기능은 iPhone 화면 가장자리에 애니메이션 점을 표시하여 이 간극을 메우고자 합니다. 이러한 점들은 자동차의 움직임과 동기화되게 약간 움직이며, 뇌에 시각적인 참조점을 제공하여 몸이 경험하는 것과 일치하는 것을 제공합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그게 간단한 개념처럼 들릴 수 있지만 실제로 매우 효과적일 수 있어요. iPhone이나 iPad의 내장 센서를 사용하여, Vehicle Motion Cues는 자동으로 차량 이동 감지하고 그에 따라 활성화되는 기능이에요. 심지어 자동으로 켜지도록 설정할 수 있어서 여행할 때마다 그것에 대해 생각할 필요가 없어요.\n\n저에게는 iOS 18에서 가장 흥미로운 새로운 기능 중에서도 이것이 터무니없이 흥미로워요. 제 요구 사항에 딱 맞춰져 있는 것 같아서 기쁘고요. 이제 멀리 가는 차 안에서도 메스꺼움을 느끼지 않고 핸드폰을 사용할 수 있다는 게 너무 설레고요. 많은 사람들에게 영향을 미치는 문제에 대처하면서 창의적으로 생각해 주신 애플에게 감사드리고 싶어요. 이런 기능을 만들어낸 애플 직원은 아마도 멀미를 하지 않을까 싶어요.\n\n## 약간의 다른 작은 개선사항 ✨\n\n위에서 언급한 새롭고 흥미로운 기능 이외에도, iOS 18에는 iPhone에 미치는 큰 향상을 가져다주는 몇 가지 다른 작은 접근성 기능이 포함되어 있어서 많은 사람들이 그것을 감사히 받아들일 것이라고 확신해요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n보이스오버 사용자들은 새로운 목소리, 사용자 정의 가능한 음성 로터, 그리고 Mac에서 키보드 단축키를 맞춤 설정할 수 있는 기능과 함께 개인화와 제어를 더욱 즐길 수 있게 되었습니다.\n\n새로운 리더 모드를 제공하는 확대기 옵션을 통해 텍스트를 더욱 읽기 쉽게 만들 수 있으며, 감지 모드에 쉽게 접근하여 사용자들이 주변 환경을 더 편리하게 탐색할 수 있게 됩니다.\n\n<img src=\"/assets/img/2024-05-20-NewiOS18FeaturesReimagineHowYouInteractWithYouriPhone_3.png\" />\n\n더불어, 라이브 스피치 사용자들은 새로운 카테고리와 라이브 캡션과의 원활한 통합을 통해 혜택을 받게 되며, 운동 기능 장애가 있는 사용자들을 위해 새롭고 개선된 가상 트랙패드가 아이폰을 탐색하는 편리한 방법을 제공합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n마침내, 보이스 컨트롤이 업그레이드되어 사용자 정의 어휘와 복잡한 단어를 더 잘 인식하여 더 많은 사람들에게 유용해졌습니다.\n\niOS 18 업데이트에서 도입되는 가장 멋진 기능과 가장 혁명적인 접근성 기능에 대해 저와 같이 흥분하고 계시길 바랍니다.\n\n물론, 우리가 보았듯이 이러한 기능은 장애를 가진 사람들만을 위한 것이 아닙니다. 이것들은 우리가 아이폰과 아이패드와 상호 작용하는 방식을 혁신할 수 있으며, 일상적인 작업을 더 쉽고 직관적으로, 아마 더 재미있게 만들 수 있습니다.\n\n차 안에서 전화를 받거나 사용할 때 멀미하지 않고 휴대폰을 사용할 수 있는 가능성에 개인적으로 열광하지만, 또한 다른 사람들이 이러한 기능을 활용하는 방법을 보는 것도 기대됩니다. 눈으로 전화를 제어하거나 음악을 손으로 느끼거나 사용자 정의 음성 명령을 만드는 것, iOS 18에는 우리 모두를 위한 것이 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래 댓글 섹션에서 어떤 기능을 제일 기대하고 시도해보고 싶은지 알려주세요! 만약 이러한 기능을 활용하는 새로운 방법을 발견하면 공유도 해주세요. 흥미로운 사용 사례를 발견하는 것을 기대할게요!\n\n만약 워크플로에 새로운 유용한 앱을 발견하고 추가하는 것을 좋아한다면, 맥과 아이폰 앱 스토어인 Setapp을 정말 좋아하실 것입니다. 이 앱 스토어는 200개 이상의 프리미엄 앱을 단일 월 구독료 9.99달러로 이용할 수 있습니다.\n\n아래 내 제휴 링크를 사용하여 Setapp을 30일간 무료로 이용해보세요! 'usefultech' 코드를 사용하여 혜택을 받으실 수 있습니다.\n\n아래 링크를 통해 Setapp의 200여 개 프리미엄 앱을 30일간 무료로 이용하고 동시에 제 블로그를 직접 지원해주세요!\n","ogImage":{"url":"/assets/img/2024-05-20-NewiOS18FeaturesReimagineHowYouInteractWithYouriPhone_0.png"},"coverImage":"/assets/img/2024-05-20-NewiOS18FeaturesReimagineHowYouInteractWithYouriPhone_0.png","tag":["Tech"],"readingTime":10},{"title":"월마트 소프트웨어 엔지니어 III - IOS IN3 면접 경험","description":"","date":"2024-05-20 17:44","slug":"2024-05-20-WalmartSoftwareEngineerIIIIOSIN3InterviewExperience","content":"\n![image](/assets/img/2024-05-20-WalmartSoftwareEngineerIIIIOSIN3InterviewExperience_0.png)\n\n안녕하세요, 모두 여러분. 최근에 월마트 글로벌 테크에서 소프트웨어 엔지니어 III — IOS 직책에 대한 면접을 보았어요. 총 3차론의 기술 면접이 모두 같은 날에 예정되었어요. 전체 면접 경험에 대해 자세히 말씀드릴게요.\n\n## 어떻게 지원했나요?\n\n링크드인에서 채용 담당자가 회사 내에서 열린 직책에 관해 나에게 연락했어요. 그 기회에 관심이 있었고, 채용 담당자에게 해당 직책에 관심이 있다고 답변했어요. 그런 다음 면접이 5일 후에 예정되었어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 면접 라운드.\n\n## 라운드 1: 자료 구조와 알고리즘 라운드.\n\n이 라운드는 월마트의 소프트웨어 엔지니어가 진행했습니다. 면접관은 먼저 자기 소개를 하고 제 소개를 요청한 후 면접 문제로 넘어갔어요. 첫 번째 문제는 Best Time to Buy and Sell Stock라는 leetcode 쉬운 문제였습니다. 저는 O(n²) 시간 복잡도의 방법을 설명했고, 이후 O(n) 시간 복잡도의 방법을 설명했습니다. 면접관은 후자에 납득하고 코딩을 요처했어요. 그 후, 두 번째 문제인 Buy Two Chocolates라는 leetcode 쉬운 문제를 설명하고 O(n²) 시간 복잡도 및 O(n) 시간 복잡도로 접근하여 코딩했습니다. 면접관은 제 방법을 좋아하셨고 모든 테스트 케이스를 통과하는 것을 확인했어요. 그리고 면접관은 추가로 2개 대신 \"n\" 개의 초콜릿을 추가하라는 요구사항을 제시했습니다. 저는 최소 힙을 사용할 것을 말했고 면접관은 코드를 작성해보라고 했지만 시간적 제약으로 인해 소화하지 못했습니다.\n\n면접은 60분 동안 진행되었고 피드백은 전반적으로 긍정적이었으며 두 번째 라운드를 위해 인사 담당자로부터 전화를 받았습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 라운드 2: Swift/iOS 라운드\n\n이번 라운드는 월마트의 소프트웨어 엔지니어가 진행했습니다. 인터뷰어가 먼저 자기소개를 한 후, 나에게 나의 소개를 요청했습니다. 나는 자신을 소개하고 나서 인터뷰 질문으로 넘어갔습니다. 질문은 다음과 같습니다.\n\n- 구조체 vs 클래스.\n- 프로토콜: 델리게이션, 프로토콜 내 메서드 건너뛰기 또는 무시하기.\n- 클로저: 탈출 클로저 vs 비탈출 클로저.\n- ARC: 약한 참조, 미소유 참조, 강한 참조.\n- 메인 스레드와 백그라운드 스레드.\n- MVVM vs MVC 아키텍처.\n- 싱글턴 클래스.\n- Swift에서의 제네릭.\n- 오픈 vs 퍼블릭 액세스 제어.\n- iOS의 애플리케이션 및 뷰 라이프사이클.\n\n나는 질문의 약 95%에 대답할 수 있었습니다. 인터뷰는 60분 동안 진행되었습니다. 전체적으로 피드백은 긍정적이었고, 다음 라운드를 위해 인사담당자로부터 전화를 받았습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## Round 3: 채용 담당자 라운드\n\n이 라운드는 월마트의 시니어 엔지니어링 매니저가 진행했습니다. 그는 안드로이드 개발 분야 출신이었습니다. 인터뷰어는 자신을 소개하고, 그 후에 저에게 자기 소개를 부탁했습니다. 저는 제 소개를 하고, 그 후에 바로 질문들이 시작되었습니다. 질문은 다음과 같았어요.\n\n- 전환 이유는 무엇인가요?\n- iOS 앱이 잘 작동하는 것을 어떻게 보장할 건가요?\n- 이전 조직에서 내가 한 기여는?\n- 현재 조직에서 좋지 않은 점 2가지는 무엇인가요?\n- 네이티브 앱이 하이브리드보다 더 나은 이유는 무엇인가요?\n\n그런 다음에 제가 질문이 있는지 물었고, 저는 회사 문화, 앱 아키텍처 등에 관한 일부 질문을 했습니다. 인터뷰는 약 45분 동안 이어졌어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n전체적으로 이번 라운드는 꽤 잘 진행된 것 같아요. 그러나 면접 중에 몇 가지를 실수한 것 같고, 대답하는 내용에 대해 확신이 없는 부분이 있었어요. 이번 라운드 이후에 리쿠루터로부터 소식을 전혀 듣지 못했어요.\n\n그래서 이것이 제 면접 경험에 대한 이야기에요. 난이도는 5점 중 3점으로 평가할 수 있을 것 같아요. 그들로부터 추가 소식을 아직 받지 못했어요.\n\n# 결론과 배울 점\n\n- iOS 라운드를 위해 Swift와 Apple 문서에서 모든 것을 알고 있어야 해요.\n- DSA 라운드를 위해 leet code 쉬운, 중급 문제에 대비해야 해요.\n- Hiring Manager 라운드에 대비해 항상 아주 잘 준비됐어야 해요. 설득력 있는 대답을 준비하고 항상 자신감 있어야 해요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 아무 것이나 있으면, 저와 연락하세요: [링크드인 프로필](https://www.linkedin.com/in/kapil-shanbhag)\n\n## 감사합니다!\n","ogImage":{"url":"/assets/img/2024-05-20-WalmartSoftwareEngineerIIIIOSIN3InterviewExperience_0.png"},"coverImage":"/assets/img/2024-05-20-WalmartSoftwareEngineerIIIIOSIN3InterviewExperience_0.png","tag":["Tech"],"readingTime":4}],"page":"84","totalPageCount":116,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":4},"__N_SSG":true}