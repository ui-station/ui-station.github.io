{"pageProps":{"posts":[{"title":"게임 메카닉의 원자론","description":"","date":"2024-05-27 16:48","slug":"2024-05-27-AtomicTheoryofGameMechanics","content":"\n![Atomic Theory of Game Mechanics](/assets/img/2024-05-27-AtomicTheoryofGameMechanics_0.png)\n\n2차 패턴 언어 게임 디자인의 2판에서, 게임 메카닉에 초점을 맞춘 고급 패턴 연습을 제시할 것입니다. 두 가지 모두 중요하고 구분됩니다. 이러한 연습의 구조는 이전 섹션보다 더 고급입니다. 이 중 많은 연습이 그룹이 수행하는 것이 가장 좋고, 개인에게는 매우 어려우며 시간이 많이 소요됩니다. 여기서 메카닉에 초점을 둔 것도 중요한데, 과거 연습의 언어를 사용하여 메카닉 기반 패턴과 기능적 패턴을 유도하는 과정이 구별됩니다. 이러한 패턴의 씨앗을 선택할 때 개념적 설계 작업을 더 많이 수행해야 하며, 연습 자체는 더 고급 분석적 설계를 요구합니다.\n\n디자인 패턴은 게임 디자인의 여러 다양한 측면에 적용할 수 있음을 보셨습니다. Adams와 Dormans의 작업은 이러한 아이디어를 게임 시스템에 성공적으로 적용했습니다. 그들의 패턴은 게임 메카닉: 고급 게임 디자인에서 발견되는데, 물론 메카닉에 초점을 맞추고 있습니다. 그들의 언어는 게임 시스템을 경제로 보고 해당 구현에 경제학 원리를 적용하는 주로 상위 수준의 일반 시스템 패턴을 서술합니다. 그 접근 방식은 가치 있는데, 저는 이후에 이러한 프레임워크 중 일부를 채택합니다. 그러나 Jesse Schell의 언어로 렌즈 또는 방법을 제시하여 다양한 추상화 수준과 구체성에서 게임 메카닉 패턴을 제시할 계획입니다.\n\n저는 노스이스턴 대학에서 사용하도록 개발 중인 '게임 메카닉 및 시스템 디자인' 강의용으로 게임 메카닉을 조사하기 시작했을 때, 게임 메카닉의 폭넓지만 전혀 철저하지 않은 목록을 작성하는 것부터 시작했습니다. 이 목록에는 다음과 같은 것들이 포함되어 있었습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 뛰기\n- 점프\n- 공격\n\n이런 것들은 표면적으로는 간단해 보이지만, 조금 더 신중히 살펴보면 더 복잡해 보입니다. 예를 들어, 걷기와 뛰기 사이에는 어떤 차이가 있는가요? 뛰기에는 대시가 포함됩니까? 점프에는 더블 점프나 공중 대시가 포함되나요? 뛰기는 점프와 어떻게 상호 작용하나요? 이러한 것들이 2D, 3D, 일인칭, 혹은 등각 게임에서는 어떻게 다른가요?\n\n그래서 나는 이 목록을 반복하여 각각을 세부적으로 분해하여 구성 요소를 파악했습니다. 결국 훨씬 더 긴 목록이 되었습니다. 그런데 심지어 그 중 하나를 살펴보니 더 작은 기계적 구성 요소들로 이루어져 있다는 것을 알게 되었습니다. 어느 순간에는 '움직임 벡터', '지면 마찰', 중력과 같은 것들을 설명할 정도로 미세한 '기계적 구성 요소'들로 이루어진 목록이 생겼습니다.\n\n나에게는 이것들이 단일한 기계적 요소를 설명하기에는 충분하지 않아 보였으며, 최상위 수준에서는 '움직임'이나 '전투'와 같은 것들이 기계적으로 만들어진 시스템으로 이루어진 것처럼 개별적인 기계적 요소가 아니라는 것이 보였습니다. 따라서, 이 모든 것은 기계적 설계의 계층 구조를 시사한다고 보았습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n가장 높은 수준에서 게임 시스템이 있습니다; 이들은 게임플레이의 완전한 부분을 설명합니다; Ori and the Blind Forest에서의 이동이나 Doom Eternal에서의 전투와 같은 것을 생각해보세요. 이러한 시스템은 더 단순하지만 더 집중된 Compound Mechanics로 분해됩니다​​. Doom Eternal의 총 쏘기나 Ori에서의 점프와 같은 것입니다. 이러한 Compound Mechanics는 Atomic Mechanics의 모음으로 구성되어 있습니다; 이들은 매우 구별되고 제한적인데요, Ori에서의 한 번의 점프나 Doom Eternal의 조준과 같은 것입니다. 이 Atomic Mechanics은 더 자세히 분해 될 수 있지만, 그것들의 서브-원자적 부품은 한 가지 메카닉을 설명하지 않으며, 매개변수에 더 가까워집니다. 이러한 매개변수의 개념은 더 많은 고민을 필요로 합니다. 매개변수는 것을 측정하며, 변수에 저장하고 적용합니다. 이것은 Adam과 Dormans가 경제적으로 초점을 맞춘 패턴 언어에 설명한 자원과 비슷해 보입니다. 여기서 제가 설명하는 패러다임에서, 이러한 자원은 Atomic Mechanics이 서로 상호 작용하여 Compound Mechanics을 형성하고, Compound Mechanics이 Game Systems을 형성하는 방식이 됩니다. 이 전체 과정을 거치는 이점은 이제 이러한 자원, Atomic 및 Compound Mechanics, 그리고 Game Systems를 팔로우하게 될 패턴 생성 연습에서 씨앗으로 사용할 수 있다는 것입니다. Atomic Mechanic을 지배하는 패턴을 생성하거나, Compound Mechanic 또는 Game System의 형성을 안내하거나, 자원의 효과를 설명하는 패턴을 만들 수 있습니다. 이러한 패턴은 그 자체로 유용할 뿐만 아니라, 특정 게임의 복잡한 디자인 문제를 설명하는 패턴 언어를 작성할 수 있는 구조를 제공하기 시작합니다. 다음 몇 개의 기사에서는 이러한 메카닉 패턴 연습 중 일부를 소개하고, 언어의 형성과 구조에 어떻게 그 특성을 활용할 수 있는지에 대해 논의할 것입니다.\n","ogImage":{"url":"/assets/img/2024-05-27-AtomicTheoryofGameMechanics_0.png"},"coverImage":"/assets/img/2024-05-27-AtomicTheoryofGameMechanics_0.png","tag":["Tech"],"readingTime":4},{"title":"직장 스트레스가 비용 손해를 야기하고 있습니다 이를 줄이는 5가지 전략을 소개합니다","description":"","date":"2024-05-27 16:46","slug":"2024-05-27-WorkplaceStressIsCostingYouHereAre5StrategiesToReduceIt","content":"\n![Workplace Stress](/assets/img/2024-05-27-WorkplaceStressIsCostingYouHereAre5StrategiesToReduceIt_0.png)\n\n일은 우리 삶의 큰 부분입니다. 잘 하면 기쁨의 원천이 될 수 있습니다. 그러나 처리가 잘못되면 종종 스트레스, 불안 및 불만을 일으킬 수 있습니다.\n\n일에서 약간의 스트레스를 피하기는 불가능하며, 노력할 필요도 없습니다. 결국 모든 스트레스가 나쁜 것은 아닙니다. 종종, 가치 있는 일을 하고 있다는 신호를 보여줍니다. 가치를 추가하고 영향을 창출하는 데 관심이 있는 것을 보여줍니다. 스트레스는 당신을 활력 있게 만들어 일어나는 일을 성취할 노력을 기울일 수 있도록 해줄 수도 있습니다.\n\n그러나 만약 스트레스로 인해 기능 저하가 되었다면 어떻게 해야 할까요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n의미 있는 기여를 하는 데 방해가 될까요?\n\n만들어내는 것이 기쁨을 주는 대신 직장 스트레스가 에너지를 빼앗고 동기부여에 해를 끼칠까봐 걱정이신가요?\n\n일하는 동안 스트레스를 느끼게 하는 다양한 이유가 있을 수 있습니다.\n\n악한 사람들이나 유해한 기업 문화로 인한 스트레스와 같이 제어할 수 없는 스트레스도 있을 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 권력 동태\n- 심한 동료들\n- 미세관리 상사\n- 과중한 업무 부담\n\n다른 스트레스 요인은 대부분 귀하의 통제 범위 내에 있습니다. 이는 다양한 업무 사건에 대한 대처 방법과 응답 방식과 관련이 있습니다.\n\n- 인간관계 갈등을 어떻게 관리하시나요?\n- 어려운 상황이나 예기치 않은 상황에 직면했을 때 어떻게 대처하시나요?\n- 공격적인 마감일을 어떻게 처리하시나요?\n- 스트레스가 종종 당신의 미루기와 임박한 마감일을 충족하기 위해 마지막 순간에 서둘러하는 데 어떤 영향을 미치나요?\n- 압박 속에서 어떻게 성과를 내시나요?\n- 자신과 타인에게 높은 기준을 설정하고 이러한 기준을 달성하지 못해 스트레스를 느끼시나요?\n- 집중하기가 어려운 편이며 자신의 환경에 방해를 받아 작업에 과도한 시간과 노력을 들이지만 원하는 결과를 얻지 못해 스트레스를 느끼시나요?\n- 위장하는 사람으로 느끼며 다른 사람이 자신이 사기꾼임을 알게 될까봐 회피하기 위해 지나치게 노력하시나요?\n- 무질서함이 생산성에 악영향을 끼쳐 업무 성과에 대해 걱정하고 스트레스를 느끼시나요?\n- 여러 일을 이리저리 바쁘게 하다보니 집중력을 놓치는 버릇이 있으며 더 집중하고 차분해져야 한다고 느끼시나요?\n\n무슨 이유에서든지, 연구에 따르면 처리되지 않은 스트레스는 신체와 정신 건강 문제로 이어질 수 있습니다. 업무에서 생산성과 성과에 영향을 미칠 수 있습니다. 주변 사람들에게도 영향을 미칠 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 직장 스트레스 관리를 위한 5가지 전략\n\n당신이 통제할 수 없는 것들로 인한 스트레스는 이야기하지 않겠습니다. 엉망인 상사나 사내 정치, 또는 다른 해로운 문화적 요소로 인한 스트레스는 다른 직장으로 옮겨가는 것 외에 다른 선택지가 없다고 생각합니다. 이 문제에 대해 불평할 수 있지만, 만약 당신의 스트레스가 조직 내에서 더 큰 문화적 문제로 인한 것이라면 시간이 지나도 나아지지 않을 것입니다. 당신은 단호한 입장을 취하고 다른 직장을 찾지 못할 것을 두려워하지 않고 전환에 시간과 에너지를 투자해야 합니다.\n\n그럼, 제어할 수 있는 것들에 대해 이야기해보죠. 몇 년 동안 저에게 효과가 있었던 스트레스 관리 전략을 소개합니다.\n\n## 1. 사소한 것들을 버리세요\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n자주 직장 스트레스는 삶의 작은 일에 지나치게 신경쓰는 데서 비롯됩니다—오랜 시간이 지나면 사실 크게 중요하지 않은 일들입니다. 당신은 이런 것들에 신경을 쓰지 않지만 그 순간에는 삶과 사망의 문제처럼 느껴질 수도 있습니다.\n\n가끔은 자아가 방해가 되기도 하고, 때로는 무슨 문제든 당신의 시간과 관심을 받을 가치가 있는지 깨닫지 못합니다. 이런 사소한 미묘함으로부터 자신을 격리시킬 수 있는 많은 기회가 있지만, 이런 상황에 점점 더 올라타게 됩니다.\n\n삶 속의 사소한 일에 빠져들어 정신적 고통을 겪는 것을 피하려면, 다음 질문을 스스로에게 물어보세요:\n\n- 왜 이런 감정을 느끼게 되었는가?\n- 이 상황은 내가 통제할 수 있는 범위 내에 있는가?\n- 왜 이것이 나에게 중요한가?\n- 내가 이에 대해 더이상 신경 쓰지 않게 되면 어떻게 될까?\n- 일 년 후의 내 자신을 바라봤을 때, 왜 지금 이게 중요한가?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n스트레스의 원인을 알면 시간과 주의를 훔치지 않아도 되는 사소한 일로부터 자유로워질 수 있어요.\n\n## 2. 자신의 시간과 일정을 통제하세요\n\n일하는 동안 시간을 어떻게 보내는지 통제하지 못하는 것은 직장에서의 불안과 스트레스의 숨겨진 원인 중 하나입니다.\n\n과도한 회의와 바쁜 달력으로 가득 찬 바쁜 스케줄은 중요한 느낌을 주지만, 목표를 향해 전진시키는 데는 아무것도 도와주지 않아요. 그 대신, 중요한 일을 달성하지 못한 바쁜 날은 당신에게 효율적이고 적당한 느낌을 주게 될 거예요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n가정에서 스트레스 받는 아침은 직장으로 옮겨 올 수도 있습니다. 건강한 아침 식사를 챙기는 데 충분한 시간이 없고 아이들을 학교에 데려다 주며 회의 참석 시간을 맞추느라 고생할 때가 있습니다. 이러한 계획 부족은 업무에서 다양한 사건에 대한 대응 방식에도 영향을 미칩니다. 아침에 스트레스를 받고 시작하면 특히 조금의 기대 불일치나 업무에서의 불편함도 당신을 힘들게 할 수 있습니다. 주변의 모든 것이 무너지는 것 같다는 느낌을 받을 수도 있으며, 이로 인해 스트레스와 불안감이 더해질 수 있습니다.\n\n이러한 일은 의식적으로 하루를 계획하고 우선순위를 정하지 않을 때 자주 발생합니다. 제가 말하고 싶은 것은 계획을 세웠다고 해서 문제가 발생하지 않을 것이라는 것은 아닙니다. 그러나 계획을 세워두면 우연에 좀 더 남기고 당신이 대응 방식을 선택할 수 있는 정신적 공간을 제공해줍니다.\n\n일정에 대한 더 나은 통제를 통해 당신은 앞으로 나아가는 데 도움이 되고 스트레스가 스며들기 어려운 작업을 선택하고 수행할 수 있습니다.\n\n## 3. 명확함을 추구\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n직장에서 효과가 없다는 느낌은 소진의 중요한 원인 중 하나입니다. 당신이 어떤 것이 당신에게 기대되는지 모르거나 당신의 일이 팀의 목표에 어떻게 적합한지 알지 못하면 중요한 것을 달성하기 어려울 수 있습니다.\n\n진전 부족과 목적 및 의미 부족은 주로 목표에 대한 더 많은 명확성과 그 목표를 달성할 기회가 필요하기 때문에 발생합니다. 이는 무능감, 소속감 상실, 직업에 대한 냉소주의 및 부정적인 태도를 유발하여 스트레스로 이어질 수 있습니다.\n\n당신이 필요로 하는 명확성을 다른 사람이 제공하길 기다리는 대신 더 적극적으로 명확성을 추구하세요. 당신의 감정은 다른 사람에게 투명하지 않으며 사실, 모든 사람들이 자신의 업무 일정으로 바쁘기 때문에 당신이 필요한 것이나 이해하지 못하는 부분에 대해 인지하기 어렵습니다.\n\n스트레스를 피하기 위해 명확성을 강조하세요. 당신의 역할, 업무 기대치 및 목표를 이해하기 위해 더 나은 질문을 하고—관리자와 정기적인 피드백을 받기 위해 시간을 예약하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n작업 중에 명료성을 유지하면 긍정적인 변화가 가능해져 부정적인 감정과 스트레스가 줄어듭니다.\n\n## 4. 어려운 대화에 당당히 맞서보기\n\n조직에서 하는 많은 작업은 다른 팀과 부서 간의 협력을 필요로 합니다. 다른 사람들과 협력하는 것은 배우고成長하는 좋은 기회를 제공하지만, 그로 인해 스트레스가 발생할 수도 있습니다.\n\n의견 차이는 논쟁으로 이어질 수 있습니다. 충돌하는 우선순위, 일정이 겹치거나 기대치가 맞지 않으면 사람들이 자신의 아이디어를 구현하는 시간보다 논쟁하는 시간이 더 많아질 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이러한 갈등들이 불러일으키는 부정적인 감정들은 당신이 머리를 모래 속에 파묻을 수도 있게 할 수 있어요. 이런 경우 당신은 그 감정들을 다루기를 피하려 할지도 모르고, 그것들을 해결하지 않으려 하거나 그냥 사라질 것을 희망하며 미룰지도 모릅니다. 그러나 피하거나 아무것도 하지 않음으로써 문제는 더 악화될 뿐입니다 — 사소한 문제가 심각한 문제로 발전하여 조율을 찾기 어려워집니다. 그리고 조율이 이루어지지 않으면 중요한 일은 결코 해결되지 않습니다.\n\n그러므로, 만약 당신이 갈등을 피하기를 선호한다면, 그렇게 하지 마세요. 당면한 문제에 당면하세요. 대화를 나누세요. 상대방의 의견을 이해하려 노력하세요. 이러한 질문들을 던져보면 상황을 다루는 데 도움을 받을 수 있고, 그 문제들을 무시함으로 발생하는 스트레스를 피할 수 있습니다:\n\n- 내가 느끼는 감정은 무엇인가요 — 분노, 슬픔, 혐오, 두려움...\n- 왜 이런 감정을 느끼나요?\n- 갈등에 직면하고 있나요?\n- 이러한 감정이 현재 제게 어떤 영향을 끼치나요?\n- 이 갈등은 어떤 것을 촉발하나요?\n- 제가 이루려는 것이 무엇인가요, 혹은 잃을까 두려운 것이 무엇인가요?\n- 제 의견을 바꾸게 할 요소는 무엇인가요?\n- 만약 제가 틀렸다면 어떨까요?\n- 다른 사람이 이렇게 생각하게 하는 것은 무엇인가요, 제가 놓치고 있는 것은 무엇인가요?\n\n## 5. 부정적인 생각 다시 평가하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n당신의 의도와는 다른 일이 벌어질 때 어떻게 되는지 궁금하신가요? 그런 상황에 대한 즉각적인 반응이 최악의 결과를 상정하는 것이 아니었나요? 사건을 과장시키지 않았나요?\n\n예상치 못한 일에 대비하지 않는 것은 어려운 일일 수 있습니다. 보통과 다른 작은 변화나 상황의 약간의 변화라도 당신을 매우 불안하고 스트레스를 받게 할 수 있어서 명확하게 사고할 수 있는 능력을 왜곡시킬 수 있습니다.\n\n부정적인 마음가짐은 파괴적인 행동 패턴(미루기, 탓, 산만)을 반복하게 만들어 귀하의 결과를 해치며 더 부정적인 생각을 유발할 수 있습니다. 이는 다시 부정적인 신념을 강조하고 특정한 감정을 느끼는 데 옳았다고 확신하게 만들어 버립니다. 이것은 종종 자기 성취 예언(self-fulfilling prophecy)의 역할을 합니다.\n\n스트레스를 관리하기 위해 부정적인 감정에 압도될 때 어쩌면 좋을지에 대해 이렇게 해보세요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 그 감정들을 받아들이세요. 그것들을 무시하지 마세요.\n- 당신의 마음이 만들어낸 것일 뿐이며 항상 옳은 것은 아닐 수 있다는 것을 인정하세요.\n- 왜 그렇게 느끼게 되는지 의심하고 이해하려고 노력하세요. 왜 그렇게 느끼는 것이 옳다고 생각하는 건가요? 당신이 옳다고 생각하는 부분과 틀릴 수도 있는 부분은 무엇인가요?\n- 상황을 재평가하세요. 그 정도가 꼭 그렇게 나쁜 것일까요? 다른 타당한 대안이나 설명을 사용해서 상황을 평가해보세요.\n\n## 요약\n\n- 직장에서 스트레스를 유발하는 요인을 이해하지 못하고 적극적으로 조치를 취해 스트레스를 관리하지 않으면, 신체적이나 정신적 안녕에 영향을 줄 수 있어 업무 효율성과 성과에 악영향을 미칠 수 있습니다.\n- 스트레스를 유발하는 것들은 조직의 독성이 있는 근무 환경과 같이 당신의 통제 범위를 벗어날 수 있습니다. 자책에 시간을 보내는 대신 움직이세요.\n- 스트레스의 상당 부분은 당신이 통제할 수 있는 요소로부터 비롯됩니다. 이 사실을 인정하는 것이 상황에 대한 책임을 질 수 있는 유일한 방법입니다. 이를 통해 상황을 줄이기 위해 적극적 조치를 취할 수 있습니다.\n- 너무 사소한 것들에 너무 많은 주의를 기울이면 많은 스트레스가 올 수 있습니다. 본질적인 것과 아닌 것을 구별하고 사소한 문제에 신경 쓸 필요성을 멈추세요.\n- 의식적으로 시간과 에너지를 소비할 계획을 세우세요. 일정을 통제하는 것이 스트레스의 침투 여지를 줄입니다.\n- 진척, 목적 및 소속감을 느끼지 못하면 틀림없이 스트레스를 받을 것입니다. 명확성을 적극적으로 추구하세요. 그것은 그 간극을 메꾸어 행복, 만족 및 성취감을 갖도록 도와줍니다.\n- 상황을 악화시키는 갈등을 피하는 대신 어려운 대화를 나누는 용기를 연습하세요. 미해결된 감정으로 인한 많은 스트레스를 피할 수 있습니다.\n- 마지막으로, 우연히 일이 잘 안 풀리는 경우, 부정적 결론을 내리기 전에 일시 중단하고 상황을 재평가하세요. 대부분의 경우, 처음에 보이는 것만큼 상황이 나쁠 필요는 없습니다.\n\n더 많은 이야기를 위해 여기와 LinkedIn에서 저를 팔로우하세요. 본 이야기는 https://www.techtello.com에서 원래 게재되었습니다.\n","ogImage":{"url":"/assets/img/2024-05-27-WorkplaceStressIsCostingYouHereAre5StrategiesToReduceIt_0.png"},"coverImage":"/assets/img/2024-05-27-WorkplaceStressIsCostingYouHereAre5StrategiesToReduceIt_0.png","tag":["Tech"],"readingTime":10},{"title":"판타지 테크 직장 그만두기","description":"","date":"2024-05-27 16:45","slug":"2024-05-27-FantasyQuittingaTechJob","content":"\n![Image](/assets/img/2024-05-27-FantasyQuittingaTechJob_0.png)\n\n요즘 생생한 환상을 많이 꾸었어요. 정말 멋진 라면과 커피를 꿈꿨는데, 그 이상으로도 꿈꾸고 있어요.\n\n솔직히 말해서, 제 현 직무에서 떠나며 원하는 복수를 하는 상상을 하고 있어요.\n\n걱정 마세요, 이런 행동은 하지 않을 거니까요 — 어떤 직장을 찾아 새롭게 시작할 때 하고 싶은 일에 대해 상상하는 중이에요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 한 방향의 부재\n\n지금 하는 챕터 작업이 충분히 좋지 않다고 듣고 있어요. 티켓에 한 줄이 있고, 시니어 개발자와 논의한 대로 데모가 작동 중이라고 말했어요. 상사께서 더 많은 질문을 던지는 것이 내 책임이라고 말씀하셨어요.\n\n혼자 한 분만으로 한 마디 하고 싶어요. 퇴사 신청서를 보냈어요.\n\n# 지금 말해요\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저는 회의 중에 발언하는 것을 허락받지 못하는 상황이었어요.\n\n받았던 것에 참지 못하고 그 자리에서 퇴사 선언을 했죠.\n\n# Cry Me A River\n\n매니저에게 빠른 5분을 요청하며 눈물을 글썽이며 사임서를 쓰다가 제출했어요. 그 이후로 그들에게 연락하지 않았죠.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 한 번 더 나를 반복해줘\n\n나는 회의에 참석해서 그룹이 현재 겪고 있는 일반적인 문제의 해결책을 제시하고 싶어.\n\n내 동료들이 나를 반복하면, 나도 그들을 반복할 거야. 그런 다음 그들이 나에게 말하는 대로 반복하기 시작할 걸.\n\n몇 번의 회의를 통해 이것을 반복하면 나는 공식적으로 퇴사할 필요가 없겠군.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 현실\n\n솔직히 말해서, 난 진짜로 그게 유일한 방법이야. 전문적으로.\n\n분명히 나는 복수퇴사를 하는 게 좋은 생각인지 물어보고 ChatGPT에게 이것을 결론으로 도출했는데, IT 세계가 작을 수 있다는 경고를 계속 받고 있어서 그냥 관계를 끊는 일은 좋은 생각이 아니라고 하더라고.\n\n그래서 이렇게 될 것 같아. 내 매니저에게 5분만 해달라고 부탁하고 나가겠다고 하고, 그리고 이메일로 퇴사서를 보낼 거야.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n내 쓴 말 중 서글픔을 느끼게 할 단서는 나는 어디로 가는지 말하지 않겠다는 점밖에 없습니다. 하지만 '다른 곳에 간다'고 말하는 것보다 더 전문적인 거겠죠?\n\n비밀의 개발자는 마침내 의도된 대로 게임을 플레이하는 법을 배우고 있어요.\n\n# 결론\n\n네, 취직을 지원했어요. 말했어. 가야할 때가 되어서 불필요한 문제를 일으키지 말아야 하겠죠. 이 게임에서 다시 만날 수도 있으니까요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 저자 소개\n\n프로 피소프트웨어 개발자인 \"시크릿 개발자\"는 Twitter에서 @TheSDeveloper로 찾을 수 있으며, 주로 Medium.com을 통해 기사를 정기적으로 발행합니다.\n\n시크릿 개발자는 매우 빠른 시일 내에 자신의 직장을 그만둘 수 있기를 희망합니다.\n","ogImage":{"url":"/assets/img/2024-05-27-FantasyQuittingaTechJob_0.png"},"coverImage":"/assets/img/2024-05-27-FantasyQuittingaTechJob_0.png","tag":["Tech"],"readingTime":3},{"title":"마이크로서비스 아키텍처에서의 소통 스타일 가이드","description":"","date":"2024-05-27 16:41","slug":"2024-05-27-AGuidetoCommunicationStylesinMicroservicesArchitecture","content":"\n![A Guide to Communication Styles in Microservices Architecture](/assets/img/2024-05-27-AGuidetoCommunicationStylesinMicroservicesArchitecture_0.png)\n\n마이크로서비스 아키텍처에서 의사소통은 중요한 요소로, 다양한 토론이 진행되어 상호 서비스 상호 작용에 대한 가장 효과적인 방법을 선택하는 데 초점을 맞춥니다. 이 입문용 블로그 포스트에서는 마이크로서비스를 위한 최적의 의사소통 전략을 탐색하고 요약하여 언제 어디서 각 의사소통 스타일을 효과적으로 활용해야 하는지에 대한 통찰을 제공할 것입니다.\n\n# 상호 작용 스타일\n\n마이크로서비스 아키텍처 내에서 서비스가 어떻게 의사소통하는지 효과적으로 이해하기 위해 사용 가능한 상호 작용 스타일에 익숙해지는 것이 중요합니다. 각 스타일은 고유한 장단점을 가지고 있습니다. 이러한 세부 사항을 정확히 이해하는 것은 서비스에 가장 적합한 의사소통 메커니즘에 대한 정보를 얻기 전 중요합니다. 이 기본 지식은 선택한 방법이 시스템의 특정 요구 사항과 도전에 잘 부합되도록 보장합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그러나 상호 작용 스타일은 두 가지 측면으로 분류할 수 있어요. 첫 번째 측면은 상호 작용이 일대일인지 일대다인지에요:\n\n- 일대일 — 각 클라이언트 요청이 정확히 한 서비스에서 처리돼요.\n- 일대다 — 각 요청이 여러 서비스에서 처리돼요.\n\n두 번째 측면은 상호 작용이 동기식인지 비동기식인지에요.\n\n- 동기식 — 클라이언트는 서비스로부터 적시에 응답을 기대하며 대기하는 동안 차단될 수 있어요.\n- 비동기식 — 클라이언트는 차단되지 않고, 응답이 있다면 즉시 전달되지 않을 수도 있어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음은 서로 다른 차원을 보여주는 표입니다.\n\n각각에 대해 간단히 얘기해 봅시다.\n\n## 일대일 상호작용\n\n- 요청/응답 — 서비스 클라이언트가 서비스에 요청을 보내고 응답을 기다립니다. 클라이언트는 시시각각 응답이 도착할 것으로 기대합니다. 대기하는 동안 블록될 수도 있습니다. 일반적으로 서비스가 서로 긴밀하게 결합되어 있는 상호작용 방식입니다.\n- 비동기 요청/응답 — 서비스 클라이언트가 요청을 보내고, 서비스가 비동기적으로 응답합니다. 클라이언트는 대기하는 동안 블록되지 않습니다. 왜냐하면 서비스가 응답을 오랫동안 보내지 않을 수도 있기 때문입니다.\n- 일방향 통지 — 서비스 클라이언트가 요청을 보내지만, 응답을 기대하거나 보내지 않습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 일대다 상호작용\n\n- 발행/구독 — 클라이언트가 알림 메시지를 발행하고, 이를 관심 있는 서비스가 소비합니다.\n- 발행/비동기 응답 — 클라이언트가 요청 메시지를 발행하고, 그리고 나서 관심 있는 서비스로부터 일정 시간 동안 응답을 기다립니다.\n\n# 동기적 원격 프로시저 호출 패턴을 사용한 통신\n\n클라이언트가 서비스에 요청을 보내고, 서비스는 요청을 처리한 후 응답을 되돌립니다. 일부 클라이언트는 응답을 기다리는 동안 블록될 수 있으며, 다른 클라이언트는 반응적인 논블로킹 아키텍처를 가지고 있을 수 있습니다. 그러나 메시징을 사용할 때와는 다르게, 클라이언트는 응답이 시간 이내에 도착할 것이라고 가정합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음 다이어그램은 RPI 작동 방식을 보여줍니다. 클라이언트의 비즈니스 로직은 PRI 프록시 어댑터 클래스에 구현된 프록시 인터페이스를 호출합니다. RPI 프록시는 서비스에 요청을 보냅니다.\n\n요청은 RPI 서버 어댑터 클래스에 의해 처리되며, 이 클래스는 인터페이스를 통해 서비스의 비즈니스 로직을 호출합니다. 그런 다음 RPI 프록시에 응답을 보내고, 프록시는 클라이언트의 비즈니스 로직에 결과를 반환합니다.\n\n프록시 인터페이스는 일반적으로 기본 통신 프로토콜을 캡슐화합니다. 선택할 수 있는 다양한 프로토콜이 있습니다. 여기서는 가장 인기 있는 REST와 gRPC 프로토콜에 중점을 두고 있습니다.\n\n# REST API\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nREST에서의 중요한 개념 중 하나는 자원(resource)입니다. 자원은 일반적으로 고객(Customer)이나 제품(Product)과 같은 단일 비즈니스 객체 또는 비즈니스 객체 모음을 나타냅니다. REST는 자원을 조작하기 위해 HTTP 동사를 사용하며, 이는 URL을 사용하여 참조됩니다. 예를 들어 GET 요청은 자원의 표현을 반환하며, 이는 종종 XML 문서 또는 JSON 객체 형식으로 제공되지만 바이너리와 같은 다른 형식을 사용할 수도 있습니다. POST 요청은 새 자원을 생성하고, PUT 요청은 자원을 업데이트합니다.\n\nREST API에서의 과제\n\n- 하나의 요청으로 여러 자원 검색하기\n  REST 자원은 종종 고객(Customer) 및 주문(Orders)과 같은 비즈니스 객체에 집중하기 때문에 하나의 요청으로 여러 관련 객체를 검색하는 것이 어려울 수 있습니다. 예를 들어 주문과 해당 고객을 얻기 위해서는 일반적으로 여러 API 호출이 필요합니다. 공통적인 해결책은 고객이 연관 자원을 단일 호출로 가져올 수 있도록 API를 개선하는 것입니다. \"expand\" 쿼리 매개변수를 사용하여 관련 자원을 지정하는 GET 요청을 이용하는 것이 일반적입니다. 많은 경우에 효과적이지만 이 방법은 구현하기 복잡하고 시간이 소요될 수 있으며, 이로 인해 데이터 검색을 보다 간편하게 하는 GraphQL과 같은 대안 기술의 등장에 영향을 미쳤습니다.\n- 작업을 HTTP 동사에 매핑하기\n  REST API 설계에서 주목할 만한 도전 과제는 비즈니스 객체에서 특정 작업을 올바른 HTTP 동사에 할당하는 방법입니다. 예를 들어, 주문 업데이트는 취소 또는 수정과 같은 다양한 작업을 수반할 수 있으며, 모든 업데이트가 반드시 멱등성(idempotent)을 보장하는 것은 아닙니다. 이는 HTTP PUT 방법을 사용하는 데 필요합니다. 일반적인 접근 방식은 구분된 업데이트 작업을 위한 하위 자원을 생성하는 것입니다. 예를 들어, 취소(POST /orders/'orderId'/cancel)나 수정(POST /orders/'orderId'/revise)에 POST를 사용하는 것입니다. 또 다른 방법은 작업을 URL 쿼리 매개변수로 포함하는 것입니다. 그러나 이러한 방법은 REST 원칙을 완전히 준수하지 않을 수 있습니다. 작업을 HTTP 동사에 매핑하는 점의 어려움은 gRPC와 같은 대체 기술의 인기에 영향을 미쳤습니다.\n\n## REST의 장단점\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nREST를 사용하는 것에는 많은 이점이 있습니다:\n\n- 간단하고 익숙합니다.\n- 예를 들어 Postman 플러그인을 사용하여 브라우저 내에서 HTTP API를 테스트하거나, JSON 또는 다른 텍스트 형식을 사용하는 경우 curl을 사용하여 명령줄에서 테스트할 수 있습니다.\n- 직접 요청/응답 스타일의 통신을 지원합니다.\n- HTTP는 물론 방화벽 친화적입니다.\n- 시스템 구조를 단순화하여 중간 브로커가 필요 없습니다.\n\n하지만 REST를 사용하는 것에는 몇 가지 단점이 있습니다:\n\n- 요청/응답 스타일의 통신만 지원합니다.\n- 가용성이 감소합니다. 클라이언트와 서비스가 중간 역할 없이 직접 통신하기 때문에 메시지를 버퍼링할 중간자가 없어야 하며 교환 기간 동안 둘 다 실행되어 있어야 합니다.\n- 클라이언트는 서비스 인스턴스의 위치(URL)를 알아야 합니다. 이는 현대적인 응용프로그램에서 중요한 문제입니다. 클라이언트는 서비스 인스턴스를 찾기 위해 서비스 검색 메커니즘을 사용해야 합니다.\n- 한 요청에서 여러 리소스를 가져오는 것이 어려울 수 있습니다.\n- 여러 업데이트 작업을 HTTP 동사에 매핑하는 것이 때때로 어려울 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# gRPC 사용하기\n\nREST API는 여러 개의 업데이트 작업을 효과적으로 처리하기 위해 제한된 HTTP 동사들에 어려움을 겪곤 합니다. gRPC는 API 중심 접근 방식을 강조하는 이진 메시지 기반 프로토콜을 사용하여 대안을 제공합니다. 구글에서 개발한 언어 중립 직렬화 시스템인 Protocol Buffers(Protobuf)를 활용하여 개발자가 Protocol Buffers 기반 인터페이스 정의 언어(IDL)로 API를 정의할 수 있도록 합니다. 이 설정은 Protocol Buffer 컴파일러를 사용하여 Java, C#, NodeJS, GoLang 등 다양한 프로그래밍 언어로 클라이언트 및 서버 코드를 자동으로 생성할 수 있게 합니다. gRPC API는 HTTP/2 상에서 작동하며, 간단한 요청/응답 및 스트리밍 RPC를 지원하여 서버가 메시지 스트림을 클라이언트에게 보내거나 그 반대로 클라이언트가 메시지 스트림을 서버에 보낼 수 있습니다. 이 기술은 강력한 유형화된 메서드를 가진 잘 정의된 서비스 인터페이스를 지원하므로, 마이크로서비스 아키텍처에서 다양하고 복잡한 통신 패턴을 처리하기 위한 견고한 프레임워크를 제공합니다.\n\n## gRPC의 장단점\n\ngRPC에는 여러 가지 이점이 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 업데이트 작업이 풍부한 API를 설계하는 것은 간단합니다.\n- 특히 큰 메시지를 교환할 때 효율적이고 간결한 IPC 메커니즘이 있습니다.\n- 양방향 스트리밍은 RPI와 메시징 스타일의 양쪽 통신을 가능하게 합니다.\n- 다양한 언어로 작성된 클라이언트와 서비스 간의 상호 운용성을 제공합니다.\n\ngRPC에는 몇 가지 단점이 있습니다:\n\n- JavaScript 클라이언트가 gRPC 기반 API를 소비하는 데 REST/JSON 기반 API보다 더 많은 작업이 필요합니다.\n- 오래된 방화벽은 HTTP/2를 지원하지 않을 수 있습니다.\n\ngRPC는 REST의 매력적인 대안이지만, REST처럼 동기식 통신 메커니즘이므로 일부 실패 문제도 겪을 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 비동기 메시징 패턴을 사용하여 소통하기\n\n메시징을 사용하면 서비스들은 메시지를 비동기적으로 교환하며 소통합니다. 메시징 기반 응용 프로그램은 일반적으로 메시지 브로커를 사용하는데, 이는 서비스들 간의 중계자 역할을 합니다. 서비스 클라이언트는 메시지를 보내어 서비스에 요청을 합니다. 서비스 인스턴스가 응답을 할 것으로 예상되면, 별도의 메시지를 다시 클라이언트에게 보내어 응답합니다. 통신이 비동기적이기 때문에 클라이언트는 응답을 기다리는 것으로 블록되지 않습니다. 대신 클라이언트는 즉시 응답을 받지 못할 것으로 가정하고 작성됩니다.\n\n## 메시징 개요\n\n- Gregor Hohpe와 Bobby Woolf의 책 \"Enterprise Integration Patterns\"에서 요약\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 메시지 소개\n\n메시지는 헤더와 본문으로 구성됩니다.\n\n헤더는 이름-값 쌍과 데이터를 설명하는 메타데이터의 모음입니다. 메시지 발신자가 제공하는 이름-값 쌍 외에도 메시지 헤더에는 발신자 또는 메시징 인프라에서 생성된 고유한 메시지 ID와 선택적으로 응답이 작성되어야 하는 메시지 채널을 지정하는 이름-값 쌍이 포함됩니다.\n\n메시지 본문은 텍스트 또는 이진 형식으로 전송되는 데이터입니다.\n\n다양한 종류의 메시지가 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- **문서** - 데이터만 포함한 일반 메시지입니다. 수신자가 어떻게 해석할지 결정합니다. 명령에 대한 응답이 문서 메시지의 예입니다.\n- **명령** - RPC 요청과 동등한 메시지입니다. 호출할 작업과 해당 매개변수를 지정합니다.\n- **이벤트** - 무언가 주목할 만한 일이 발생했음을 나타내는 메시지입니다. 이벤트는 종종 도메인 객체의 상태 변경을 나타내는 도메인 이벤트이거나 주문 또는 고객과 같은 도메인 객체의 상태 변경을 나타냅니다.\n\n이 블로그 게시물에서는 주로 명령(Command) 및 이벤트(Event)에 초점을 맞출 것입니다.\n\n## 메시지 채널에 대해\n\n메시지는 채널을 통해 교환됩니다. 송신자에서의 비즈니스 로직은 송신 포트 인터페이스를 호출하며, 해당 포트는 내부 통신 메커니즘을 캡슐화합니다.\n송신 포트는 메시지 송신기 어댑터 클래스에 의해 구현되며, 이 클래스는 메시지 채널을 통해 수신자에게 메시지를 보냅니다. 메시지 채널은 메시징 인프라의 추상화입니다. 수신자의 메시지 핸들러 어댑터 클래스가 호출되어 메시지를 처리합니다. 이는 소비자의 비즈니스 로직에 의해 구현된 수신 포트 인터페이스를 호출합니다. 채널로부터 메시지를 보내는 송신자는 여러 명일 수 있습니다. 마찬가지로 채널에서 메시지를 수신하는 수신자도 여러 명일 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nPoint-To-Point 및 Publish-Subscribe 두 가지 채널 유형을 이해하는 것이 매우 중요합니다.\n\n- Point-to-Point 채널은 채널에서 읽고 있는 소비자 중 정확히 한 명에게 메시지를 전달합니다. 서비스는 일대일 상호 작용 스타일을 위해 Point-to-Point 채널을 사용합니다. 예를 들어, 명령 메시지는 종종 Point-to-Point 채널을 통해 전송됩니다.\n- Publish-Subscribe 채널은 각 메시지를 연결된 모든 소비자에게 전달합니다. 서비스는 일대다 상호 작용 스타일을 위해 Publish-Subscribe 채널을 사용합니다. 예를 들어, 이벤트 메시지는 일반적으로 Publish-Subscribe 채널을 통해 전송됩니다.\n\n이제 비동기 통신의 개념 및 메시지 채널에 대한 명확한 이해를 가졌으므로, 비동기 통신 프레임워크에서 제공하는 다양한 통신 메커니즘의 구현을 탐색하는 것이 적절합니다.\n\n## 요청/응답 및 비동기 요청/응답 구현하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n클라이언트와 서비스가 요청/응답 또는 비동기 요청/응답을 사용하여 상호 작용할 때, 클라이언트는 요청을 보내고 서비스는 응답을 다시 보냅니다. 두 상호 작용 스타일 간의 차이점은 요청/응답의 경우 클라이언트가 서비스가 즉시 응답할 것으로 기대하는 데 반해, 비동기 요청/응답에서는 그러한 기대가 없다.\n메시징은 본질적으로 비동기이므로 비동기적인 요청/응답만을 제공합니다. 그러나 클라이언트는 응답을 받을 때까지 블로킹될 수 있습니다.\n\n클라이언트와 서비스는 쌍으로 메시지를 교환하여 비동기 요청/응답 스타일의 상호 작용을 구현합니다. 다이어그램에서 보듯이, 클라이언트는 작업을 수행할 명령 메시지와 해당 매개변수를 지정하는 콘텐츠를 서비스가 소유한 포인트 투 포인트 메시징 채널로 보냅니다. 서비스는 요청을 처리하고 결과를 포함하는 응답 메시지를 클라이언트가 소유한 포인트 투 포인트 채널로 보냅니다.\n\n위 다이어그램에서 클라이언트는 응답 메시지를 보낼 서비스에 알려주어야 하며 응답 메시지를 요청과 일치시켜야 합니다. 다행히, 이 두 문제를 해결하는 것은 그렇게 어렵지 않습니다. 클라이언트는 응답 채널 헤더가 있는 명령 메시지를 보냅니다.\n서버는 응답 메시지를 작성할 때, 메시지 식별자와 동일한 값이 있는 상관 ID를 포함하여 응답 채널에 작성합니다. 클라이언트는 상관 ID를 사용하여 응답 메시지를 요청과 일치시킵니다.\n\n클라이언트와 서비스가 메시징을 사용하여 통신하기 때문에 상호 작용은 본질적으로 비동기적입니다. 이론적으로 메시징 클라이언트는 응답을 받을 때까지 블로킹될 수 있지만, 실제로는 클라이언트가 응답을 비동기적으로 처리합니다. 게다가, 응답은 일반적으로 클라이언트의 여러 인스턴스 중 하나에 의해 처리됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 단방향 통지 구현\n\n비동기 메시징을 사용하여 단방향 통지를 구현하는 것은 간단합니다. 클라이언트는 일반적으로 명령 메시지를 보내고, 해당 메시지를 서비스가 소유한 점대점 채널로 전송합니다. 서비스는 해당 채널을 구독하고 메시지를 처리합니다. 답신을 보내지 않는다는 점에 유의하세요.\n이를 \"비동기 요청/응답\"에서 본 다이어그램과 비슷한 방식이라고 생각할 수 있지만, 답신 채널이 없다는 차이가 있습니다.\n\n## 게시/구독 구현\n\n클라이언트는 게시/구독 채널로 메시지를 게시하고, 여러 소비자가 읽습니다.\n서비스는 게시/구독을 사용하여 도메인 이벤트를 게시하는데, 이는 도메인 객체의 변경을 나타냅니다. 도메인 이벤트를 발행하는 서비스는 도메인 클래스에서 파생된 채널을 소유하며, 특정 도메인 객체의 이벤트에 관심이 있는 서비스는 해당 채널을 구독하면 됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-05-27-AGuidetoCommunicationStylesinMicroservicesArchitecture_1.png\" />\n\n## Publish/Async Response 구현하기\n\n퍼블리시/비동기 응답 상호작용 스타일은 퍼블리시/서브스크라이브와 요청/응답 요소를 결합하여 구현하는 더 높은 수준의 상호작용 스타일입니다.\n클라이언트는 응답 채널 헤더를 지정하는 메시지를 퍼블리시-서브스크라이브 채널에 발행합니다. 소비자는 요청 채널로의 응답 메시지를 포함하여 상관 ID를 포함한 응답 메시지를 작성합니다.\n클라이언트는 요청과 응답 메시지를 일치시키기 위해 상관 ID를 사용하여 응답을 수집합니다.\n\n비동기 API를 갖는 응용 프로그램의 각 서비스는 이러한 구현 기법 중 하나 이상을 사용합니다. 작업을 호출하는 비동기 API를 가진 서비스에는 요청을 위한 메시지 채널이 있습니다. 마찬가지로 이벤트를 발행하는 서비스는 이벤트 메시지 채널에 이를 발행할 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 메시지 브로커 사용하기\n\n메시지 기반 애플리케이션은 일반적으로 메시지 브로커를 사용하는데, 이를 통해 서비스가 통신하는 인프라 서비스입니다. 그러나 브로커 기반 아키텍처는 유일한 메시징 아키텍처가 아닙니다. 브로커를 사용하지 않는 메시징 아키텍처도 있습니다. 이 경우 서비스는 다른 서비스와 직접 통신합니다 (이 블로그 포스트에서는 이 주제를 다루지 않습니다).\n\n## 브로커 기반 메시징 개요\n\n메시지 브로커는 모든 메시지가 흐르는 중간 매개체입니다. 발신자는 메시지를 메시지 브로커에 작성하고, 메시지 브로커가 수신자에게 전달합니다. 메시지 브로커를 사용하는 중요한 이점 중 하나는 발신자가 소비자의 네트워크 위치를 알 필요가 없다는 것입니다. 또 다른 이점은 메시지 브로커가 메시지를 버퍼링하여 소비자가 처리할 수 있을 때까지 메시지를 저장한다는 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n많은 메시지 브로커를 선택할 수 있습니다. 인기있는 오픈 소스 메시지 브로커의 예시는 다음과 같습니다:\n\n- ActiveMQ\n- RabbitMQ\n- Apache Kafka\n\n각 브로커는 다른 트레이드오프를 가지고 있습니다. 예를 들어, 매우 낮은 레이턴시 브로커는 순서 보장을 유지하지 않을 수 있고, 메시지 전달을 보장하지 않으며 메시지를 메모리에만 저장할 수 있습니다.\n메시지 전달을 보장하고 메시지를 신뢰성 있게 디스크에 저장하는 브로커는 높은 레이턴시를 가지고 있을 것입니다.\n\n어떤 종류의 메시지 브로커가 가장 잘 맞는지는 애플리케이션의 요구사항에 따라 다릅니다. 심지어 애플리케이션의 다른 부분도 서로 다른 메시징 요구사항을 가질 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 메시지 브로커를 사용한 메시지 채널 구현\n\n각 메시지 브로커는 메시지 채널 개념을 다르게 구현합니다. 표에서 볼 수 있듯이, JMS 메시지 브로커인 ActiveMQ와 같은 메시지 브로커는 대기열과 토픽을 가지고 있습니다. RabbitMQ와 같은 AMQP 기반의 메시지 브로커는 거래소와 대기열이 있습니다. Apache Kafka는 토픽을 가지고 있고, AWS Kinesis는 스트림을, AWS SQS는 대기열을 가지고 있습니다.\n또한, 이 챕터에서 설명한 메시지와 채널 추상화보다 더 유연한 메시징을 제공하는 메시지 브로커도 있습니다.\n\n여기서 설명된 대부분의 메시지 브로커는 포인트 투 포인트 및 게시-구독 채널을 모두 지원합니다. 유일한 예외는 AWS SQS로, 이는 포인트 투 포인트 채널만을 지원합니다.\n\n# 메시지 브로커의 문제점\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 경쟁 수신기와 메시지 순서 정렬\n\n한 가지 도전 과제는 메시지 수신기의 확장과 동시에 메시지 순서를 보존하는 방법입니다. 메시지를 동시에 처리하기 위해 서비스의 여러 인스턴스를 사용하는 것은 보편적인 요구사항입니다.\n게다가 심지어 단일 서비스 인스턴스도 여러 스레드를 사용하여 여러 메시지를 동시에 처리할 수 있습니다. 여러 스레드와 서비스 인스턴스를 사용하여 메시지를 동시에 처리하는 것은 응용 프로그램의 처리량을 증가시킵니다.\n그러나 메시지를 동시에 처리하는 과제는 각 메시지가 한 번에 한 번씩 순서대로 처리되는 것을 보장하는 것입니다.\n\n예를 들어, 특정 지점 간편 채널(point-to-point channel)에서 읽는 세 개의 서비스 인스턴스가 있다고 가정해보겠습니다. 그리고 송신자가 주문 생성, 주문 업데이트 및 주문 취소 이벤트 메시지를 순차적으로 발행합니다.\n간단한 메시징 구현은 각 메시지를 서로 다른 수신기에 동시에 전달할 수 있습니다. 네트워크 문제나 가비지 컬렉션으로 인한 지연 때문에 메시지가 순서대로 처리되지 않을 수 있으며, 이는 이상한 동작을 초래할 수 있습니다. 이론적으로, 한 서비스 인스턴스가 주문 취소 메시지를 처리하기 전에 다른 서비스가 주문 생성 메시지를 처리할 수 있습니다!\n\n아파치 카프카(Apache Kafka)나 AWS Kinesis와 같은 현대적인 메시지 브로커에서 사용되는 일반적인 해결책은 샤딩(파티셔닝)된 채널을 사용하는 것입니다.\n다음 다이어그램은 이 작동 방식을 보여줍니다. 이 해결책에는 세 부분이 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 샤드 채널은 두 개 이상의 샤드로 구성되어 있으며 각 샤드는 채널처럼 작동합니다.\n- 발신자는 메시지 헤더에 샤드 키를 지정하며, 이는 일반적으로 임의의 문자열 또는 바이트 시퀀스입니다. 메시지 브로커는 샤드 키를 사용하여 메시지를 특정 샤드/파티션에 할당합니다. 예를 들어, 샤드 키의 해시를 샤드 수로 나눈 나머지를 계산하여 샤드를 선택할 수 있습니다.\n- 메시징 브로커는 수신자의 여러 인스턴스를 그룹화하고 동일한 논리적 수신자로 처리합니다. 예를 들어 Apache Kafka는 소비자 그룹이라는 용어를 사용합니다. 메시지 브로커는 각 샤드를 단일 수신자에 할당합니다. 수신자가 시작하거나 종료될 때 샤드를 재할당합니다.\n\n이 예에서 각 주문 이벤트 메시지는 orderId를 샤드 키로 사용합니다. 특정 주문에 대한 각 이벤트는 동일한 샤드에 발행되며, 단일 소비자 인스턴스가 해당 샤드를 읽습니다.\n결과적으로 이러한 메시지는 순서대로 처리되도록 보장됩니다.\n\n## 중복 메시지 처리\n\n메시지를 사용할 때 대면해야 하는 또 다른 과제는 중복 메시지 처리입니다. 메시지 브로커는 이상적으로 각 메시지를 한 번만 전달해야 하지만, 정확히 한 번 메시지를 보장하는 것은 보통 너무 비용이 많이 듭니다. 대신 대부분의 메시지 브로커는 적어도 한 번 메시지를 전달할 것을 약속합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n시스템이 정상적으로 작동할 때 최소한 한 번의 전달을 보장하는 메시지 브로커는 각 메시지를 한 번만 전달합니다. 그러나 클라이언트, 네트워크 또는 메시지 브로커의 장애로 인해 메시지가 여러 번 전달될 수 있습니다.\n예를 들어, 클라이언트가 메시지를 처리하고 데이터베이스를 업데이트한 후에 메시지를 확인하기 전에 충돌하는 경우가 있습니다.\n메시지 브로커는 확인되지 않은 메시지를 다시 전달하며, 클라이언트가 다시 시작되거나 클라이언트의 복제본 중 하나로 전달합니다.\n\n가능하다면, 메시지가 재전달될 때 순서가 유지되는 메시지 브로커를 사용하는 것이 이상적입니다.\n\n예를 들어, 클라이언트가 동일한 주문에 대한 주문 생성 이벤트를 처리한 후 주문 취소 이벤트를 처리하고, 어떤 이유로든 주문 생성 이벤트를 확인하지 않은 상황을 상상해보겠습니다.\n메시지 브로커는 주문 생성 및 주문 취소 이벤트를 다시 전달해야 합니다. 주문 생성만 재전달하는 경우, 클라이언트가 주문 취소를 취소할 수 있습니다.\n\n중복 메시지를 처리하는 몇 가지 다른 방법이 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 아이덴포턴트 메시지 핸들러를 작성하십시오.\n- 메시지를 추적하고 중복을 제거하십시오.\n\n각 옵션을 상세히 살펴보고, 이후에 각각에 대한 별도의 블로그 포스트를 작성할 예정입니다.\n\n## 아이덴포턴트 메시지 핸들러 작성\n\n메시지를 처리하는 응용 프로그램 로직이 아이덴포턴트하다면, 중복된 메시지는 해를 끼치지 않습니다. 응용 프로그램 로직이 아이덴포턴트하다는 것은 동일한 입력 값으로 여러 번 호출하더라도 추가적인 효과가 없다는 것을 의미합니다. 예를 들어, 이미 취소된 주문을 다시 취소하는 것은 아이덴포턴트한 작업입니다. 또한, 클라이언트가 제공한 ID로 주문을 생성하는 것도 아이덴포턴트한 작업입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n메시지 핸들러가 idempotent할 때 여러 번 안전하게 실행될 수 있습니다, 단 메시지 브로커가 메시지를 재전달할 때 순서를 유지해야 합니다.\n\n하지만, 응용 프로그램 로직은 종종 idempotent하지 않습니다. 또는 메시지 브로커가 메시지를 재전달할 때 순서를 보장하지 않는 경우도 있습니다. 중복 또는 순서가 올바르지 않은 메시지는 버그를 유발할 수 있습니다. 이러한 상황에서는 메시지를 추적하고 중복 메시지를 삭제하는 메시지 핸들러를 작성해야 합니다.\n\n## 메시지 추적 및 중복 삭제\n\n예를 들어 소비자 신용카드를 승인하는 메시지 핸들러를 고려해보겠습니다. 각 주문에 대해 카드를 정확히 한 번 승인해야 합니다. 이 응용 프로그램 로직의 경우 각 호출 시 다른 효과가 있습니다. 중복 메시지로 인해 메시지 핸들러가 이 로직을 여러 차례 실행하면 응용 프로그램이 잘못 동작할 수 있습니다. 이러한 종류의 응용 프로그램 로직을 실행하는 메시지 핸들러는 중복 메시지를 감지하고 삭제함으로써 독립적이어야 합니다.\n간단한 해결책은 메시지 소비자가 처리한 메시지를 메시지 ID를 사용하여 추적하고 중복을 버리는 것입니다. 예를 들어, 각 처리된 메시지의 메시지 ID를 데이터베이스 테이블에 저장할 수 있습니다. 다음 다이어그램은 전용 테이블을 사용하여 이러한 작업을 하는 방법을 보여줍니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n소비자가 메시지를 처리할 때, 메시지 ID를 데이터베이스 테이블에 기록합니다. 이는 비즈니스 엔티티를 생성하고 업데이트하는 트랜잭션의 일부로서 수행됩니다. 이 예제에서 소비자는 PROCESSED_MESSAGES 테이블에 메시지 ID를 포함한 행을 삽입합니다. 만약 메시지가 중복이면, 삽입이 실패하고 소비자는 메시지를 폐기할 수 있습니다.\n\n또 다른 옵션은 메시지 핸들러가 전용 테이블 대신 애플리케이션 테이블에 메시지 ID를 기록하는 것입니다. 이 접근 방법은 NoSQL 데이터베이스를 사용할 때 유용합니다. NoSQL 데이터베이스는 트랜잭션 모델이 제한되어 두 개의 테이블을 업데이트하는 것을 지원하지 않기 때문입니다.\n\n# 결론\n\n요약하자면, 마이크로서비스 아키텍처에서 통신 스타일을 선택하는 것은 애플리케이션 전체의 효율성과 확장성에 중요합니다. 이 게시물에서 동기 호출부터 비동기 메시징까지 다양한 통신 메커니즘을 탐색해봤습니다. 각각의 장단점과 적합한 사용 사례가 있습니다. 올바른 통신 전략은 성능을 향상시킬 뿐만 아니라 서비스 상호작용에서 탄력성과 유연성을 보장합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n커뮤니케이션 스타일을 선택할 때는 서비스 상호작용의 성격, 실시간 데이터 필요성, 그리고 서비스 복잡성과 같은 요소를 고려하는 것이 중요합니다. 조직의 요구 사항과 기술적 발전에 맞게 진화할 수 있는 견고한 아키텍처를 육성하는 것이 목표입니다.\n\n# 참고 자료\n\n- Microservices Patterns — Chris Richardson\n- Building Microservices: Designing Fine-Grained Systems 2nd Edition — Sam Newman\n- Building Event-Driven Microservices: Leveraging Organizational Data at Scale\n- Enterprise Integration Patterns — Gregor Hohpe\n","ogImage":{"url":"/assets/img/2024-05-27-AGuidetoCommunicationStylesinMicroservicesArchitecture_0.png"},"coverImage":"/assets/img/2024-05-27-AGuidetoCommunicationStylesinMicroservicesArchitecture_0.png","tag":["Tech"],"readingTime":21},{"title":"어려운 대화에서 효과적인 커뮤니케이션의 여섯 가지 규칙","description":"","date":"2024-05-27 16:40","slug":"2024-05-27-SixRulesofEffectiveCommunicationinDifficultConversations","content":"\n![Six Rules of Effective Communication in Difficult Conversations](/assets/img/2024-05-27-SixRulesofEffectiveCommunicationinDifficultConversations_0.png)\n\n우리가 목표를 달성하기 위해서는 타인과 원할한 소통이 필요합니다. 그러나 중요한 순간에 건전한 대화를 나누는 대신에 우리는 종종 최악의 상태에 있습니다. 우리는 어리석고 비용이 드는 농담거리, 논쟁, 공격, 조종 또는 다른 자기패배적인 방식으로 행동합니다.\n\n어려운 대화는 본질적으로 까다로운 것입니다. 이야기하기를 원치 않는 민감한 주제들로 구성됩니다. 의견의 차이, 감정적 문제, 민감한 주제 또는 충돌의 잠재적인 원인들을 다뤄야 합니다 — 우리가 논하기 어려운 모든 것들을 포함합니다.\n\n어려운 대화는 불편함, 불확실성 및 복잡한 감정을 헤쳐나가야 하기 때문에 도전적입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n어려운 대화를 피하는 것이 감정적으로 지치고 정신적으로 지친 상황을 피하는 것보다 의식적으로 직면하는 것이 훨씬 더 쉽습니다.\n\n그러나 어려운 대화를 미루는 것은 좋지 않은 생각입니다. 왜냐하면:\n\n- 처리되지 않은 문제들은 시간이 지남에 따라 악화됩니다. 적절히 대처하지 않으면 처음에는 다룰만한 문제도 시간이 흐름에 따라 훨씬 큰 문제로 커질 수 있습니다.\n- 미해결된 문제에 대한 지속적인 걱정은 정신 건강에 해를 끼칠 수 있으며 스트레스, 불안, 심지어 무력감까지 증가시킬 수 있습니다.\n- 중요한 문제가 무시되거나 뒤로 밀리면 신뢰를 훼손하고 원한을 쌓고 관계를 손상시킬 수 있습니다.\n\n대화가 얼마나 어려워도 그것을 영원히 미루거나 지체할 수는 없습니다. 문제에 직접 대응하고 명료함을 제공하며 마무리를 찾는 것은 신뢰와 존중을 얻고 스트레스를 줄이는 데 도움이 될 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그러나 어려운 대화를 잘 다루기 위해서는 좋은 커뮤니케이션 관행을 따라야 합니다. 어려운 대화에서 효과적인 커뮤니케이션의 여섯 가지 규칙은 다음과 같습니다:\n\n## 규칙 1: 개인적으로 대하지 마세요\n\n구체적인 행동에 대해 토론을 이어가세요. 그 사람에 대해 이야기하지 마세요. 대화 상대방은 여러분의 억지로 느껴질 정도의 판단과 몸짓을 통해 첫 몇 분 내에 여러분이 판단적이라는 것을 느낄 수 있습니다. 이로 인해 그들은 여러분이 마음을 바꿀 수 없다고 생각하고 말하는 것이 아무런 영향을 미칠 수 없다고 여겨 대화를 중단하거나 옳다고 주장하고 여러분이 틀렸다고 증명하기 위해 대화를 전환할 수 있습니다.\n\n여러분의 목적은 그들의 성격을 공격하거나 그들이 누구인지에 도전해 기분 나쁘게 만드는 것이 아닙니다. 이렇게 하면 그들의 자존심을 상처받아 여러분이 말하는 모든 것에 저항을 보이게 할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n테이블 태그를 마크다운 형식으로 변경해주세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 규칙 2: 명확하고 간결한 커뮤니케이션 실천하기\n\n간결하게 유지하세요. 둘러대지 말고 바로 말해야 할 것을 말하세요. 불필요한 정보에 가라앉지 않도록 명확하게 해주어야 합니다. 몇 가지 예시를 들어주면, 상대방이 당신의 의견을 이해하고 그것을 설득력 있게 파악할 수 있도록 도울 수 있겠죠.\n\n상황: 당신의 매니저가 밤 늦게 전화해서 가족과 함께 보내는 저녁 시간을 방해합니다.\n\n예를 들어:\n그렇다고 떠들어대거나 분명히 그들의 걱정을 명확히 표현하지 않고 상대방이 줄줄알아야 한다고 기대하지 마세요.\n하지말라: 밤에 전화하는 것이 가족과 함께 시간을 보내기 어렵게 만들고, 왜 당신에게 그런 다운타임이 필요한지 설명해주세요.\n\n상황: 팀원이 타인의 아이디어와 의견을 무시하는 습관을 가지고 있습니다.\n\n예를 들어:\n다양한 시각을 추구하거나 토론에서 다른 사람들이 더 많이 참여하도록 장려하는 일반적인 조언을 공유하지 마세요. 그들은 그를 무시할 가능성이 높습니다.\n해주세요: 이전 토론이나 회의에서 그들이 다른 사람들의 의견을 무시한 사례를 공유하세요. 앞으로 어떻게 더 포용적일 수 있는지 물어보세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n상황: 자신이 받을 만한 좋은 기회를 놓치다.\n그 대신에: 자신이 원하는 것을 얻지 못한 데 대해 매니저에게 불평하거나 원망을 표현하는 대신에\n다음과 같이 해보세요: 실망을 표현하지만, 그들의 결정에 대해 존중을 보여주세요. 다음에 그런 기회를 얻을 수 있도록 어디가 부족한지 이해하려고 노력해보세요.\n\n## 규칙 3: 영향에 초점을 둬요, 감정이 아닌\n\n특정 행동, 행동, 또는 비활동의 영향을 설명하세요. 영향에 대해 이야기하면 다른 사람들이 해결책을 적극적으로 찾게 하는 뇌의 일부를 동원하게 됩니다. 이를 감정에 대한 것으록 만들면 다른 사람들이 명확하게 생각하지 못하도록 방해하고 상황을 이성적으로 판단하기 어렵게 만듭니다.\n\n- 직원이 일터에서 계속 모욕적 언어를 사용한다면, 혐오감을 표현하는 대신 협업에 어떻게 영향을 미치는지 설명해보세요.\n- 매니저가 1:1 미팅을 계속 취소한다면, 당황을 드러내는 대신 이러한 회의를 가지지 않는 것이 성장에 어떻게 제한이 되는지 설명해보세요.\n- 팀원이 당신의 아이디어에 대한 영괴를 독차지하려 한다면, 짜증내지 말고, 이런 행동을 계속하면 아이디어를 나누기를 중지할 것이라고 명확히 표현하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n보편적으로 **잉크 테이블**은 데이터를 효율적으로 나타내기 위한 데 사용됩니다. 하지만 어떨 때는 이 테이블을 **마크다운** 형식으로 변경하고 싶을 수도 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 그들의 우려나 오해에 대해 설명합니다 (하지 말아주세요: 당신이 의도하지 않은 내용).\n- 당신이 실제로 의도한 바를 명확히 합니다 (해주세요: 당신이 의도하는 내용).\n\n하지 말아주세요: 여러분이 제안한 아이디어가 논의할 가치가 있는 것이 아니라고 말하려는 게 아닙니다. 여러분이 제기한 많은 포인트가 극히 가치 있게 여겨집니다.\n해주세요: 하지만, 우리가 결정하기 전에 다른 대안도 고려하고 싶습니다.\n\n하지 말아주세요: 여러분의 작업이나 제안에 가치를 두지 않는 것이 아닙니다. 여러분의 연구가 방대하며 주요 분야를 모두 다루고 있다는 것을 알 수 있습니다.\n해주세요: 하지만, 최근 기업 전략의 변화를 고려하고 이 제안을 재평가하는 것이 유용할 것으로 생각합니다.\n\n하지 말아주세요: 저의 목표는 우리 지난 프로젝트에서 벌어진 실수에 대해 누군가를 탓하는 것이 아닙니다.\n해주세요: 저는 그 경험에서 배우고, 다시 일어나지 않도록 사전에 예방하는 방법을 살펴보려고 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 규칙 5: 먼저 이해하려고 하고 나중에 이해되려고 하세요\n\n당신의 의견을 듣기 원한다면, 상대방이 느끼고 이해되었다고 느끼게 하세요. 상대방의 의도를 가정하거나 강요하지 마세요. 상황을 보는 방식, 사고과정 또는 특정한 행동의 이유에 대해 공유할 수 있도록 허락하세요.\n\n전달하고자 하는 바를 반복하는 것은 반대 반응만 일으킬 뿐입니다. 상대방이 당신을 듣기 원한다면, 먼저 이해하려는 의도로 상대방을 들으며 상호 존중을 보여주세요.\n\n효과적인 청취를 연습하세요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 명확성을 강조하고 대화하도록하여 오픈 질문을 통해 이야기를 이끌어보세요.\n\n- “좀 더 자세히 말해봐요…”\n- “이해시켜 주세요…”\n- “그것을 나에게 설명해주세요…”\n- “어떻게 생각하세요…”\n- “당신이 어디서 오는 건지 이해하고 싶어요…”\n- “당신이 어떻게 보는지 조금 더 공유해 줄 수 있어요?”\n\n2. 말뿐만 아니라 비언어적 의사 소통에 초점을 맞춰보세요. 목소리 톤부터 제스처, 신체 언어까지 포함합니다.\n\n3. 메시지 전달을 위해 중단하거나 방어적인 태도를 취하지 마세요. 상대방이 말을 끝내면 당신이 전달하고 싶은 바를 솔직하게 말해보세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n4. 눈에 띄려 하지 마세요. 대화는 당신에 대한 것이 아닙니다.\n\n5. 상대방의 감정과 견해를 인정해 주세요. 인정하는 것은 그들과 동의하는 것을 의미하지는 않으며, 단지 그들이 어떻게 느꼈는지 이해한다는 것을 의미합니다.\n\n- \"당신이 말한 것으로 보아, 당신이 압도되는 느낌인 것으로 이해해요.\"\n- \"당신이 이 문제로 스트레스를 받고 있는 것을 알겠어요.\"\n- \"제가 당신을 올바르게 이해했다면, 지금은 이유로 인해 화가 나신 것 같으세요.\"\n\n6. 현재 대화와 관련된 주제에 대해 논의하세요. 주제를 벗어나지 말고 진로를 유지하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 규칙 6: 평정 유지\n\n상대방이 방어적이거나 과잉 반응하는 경우에도 그에 반응하지 마세요. 차분함을 유지하고, 대조를 통해 대화를 복원하고, 질문을 하며 그들의 생각과 감정을 이해하려 노력하세요.\n\n대화를 유익하게 만들기 위해 다양한 전략을 시도하더라도 상황이 변하지 않거나 악화된다면 상대방에게 휴식을 취하고 다른 시간에 다시 모이도록 제안하세요.\n\n예를 들어, 다음과 같이 말할 수 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 우리가 논의한 내용을 처리하는 데 더 많은 시간이 필요한 것 같아요. 생각해 본 후에 다시 만나는 것은 어떠세요?\n- 우리가 논의한 것에 대해 생각해 볼 시간을 가지면 도움이 될까요? 언제든 다시 만날 수 있습니다.\n\n다른 사람들이 과도하게 반응하거나 정보를 이해하는 방식이 예상과 다르다고 화를 내면 오히려 상황을 악화시킬 뿐입니다. 상대에게 공간과 시간을 주어 우려를 다루도록 해보세요.\n\n## 요약\n\n- 필수적이지만 어려운 대화는 깨기 어렵습니다. 나쁜 결과를 두려워하거나 무엇을 말할지 모르는 것이 바로 필요한 순간에 의미 있는 대화에 참여하지 못하게 만들 수 있습니다.\n- 다루지 않으면 갈등은 악화됩니다. 어려운 대화를 피하거나 미루는 만큼 나중에 해결하기가 더욱 어려워집니다.\n- 상대방의 성품을 비난하거나 강한 판단을 내리면 반드시 나쁘게 반응하고 방어적으로 나서게 됩니다. 개인적인 공격 대신 걱정되는 구체적인 행동이나 행동에 대해 대화하세요.\n- 너무 많은 정보는 상대방을 심심하게 만들고, 너무 적은 정보는 혼란스럽게 만듭니다. 좋은 커뮤니케이션은 명확하고 간결하며 핵심적입니다. 이해하고 행동하기 쉽도록 의견을 표현하세요.\n- 표현은 건강한 표현은 하지만 당신의 유일한 방어 수단이 되어서는 안 됩니다. 영향을 명확히 표현하는 것은 중요합니다. 문제를 해결하고 표준 솔루션에 동의하기 위해 필요한 뇌의 사고 부분을 활성화합니다.\n- 어려운 대화에서의 선의는 충분하지 않습니다. 명시적으로 표현해야 합니다. 다른 사람이 당신의 목적과 일치하면 건강한 이야기를 나누고 해결책을 찾기가 쉬워집니다.\n- 우리는 어려운 대화가 우리의 의견을 공유하고 기대를 밝히며 불만을 표현하는 것이라고 생각합니다. 그러나 모든 말을 할 때 중요한 것을 잊어버립니다-다른 사람의 견해를 듣고 높이 평가하는 것.\n- 마지막으로 일부 문제가 될 수 있는 대화는 폭력적이거나 공격적일 수 있습니다. 이런 순간에 침착함을 잃는다면 상황을 더욱 악화시킬 수 있습니다. 나중에 연결하라고 상대방에게 요청하여 긴장을 풀어보세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여기와 LinkedIn에서 더 많은 이야기를 읽어보세요. 이 이야기는 원래 https://www.techtello.com에서 발행되었습니다.\n","ogImage":{"url":"/assets/img/2024-05-27-SixRulesofEffectiveCommunicationinDifficultConversations_0.png"},"coverImage":"/assets/img/2024-05-27-SixRulesofEffectiveCommunicationinDifficultConversations_0.png","tag":["Tech"],"readingTime":9},{"title":"Apache Airflow을 시작하는 방법 2024 최신 업데이트","description":"","date":"2024-05-27 16:38","slug":"2024-05-27-HowtogetstartedwithApacheAirflow2024updated","content":"\n<img src=\"/assets/img/2024-05-27-HowtogetstartedwithApacheAirflow2024updated_0.png\" />\n\n- 노트북을 열어주세요\n- 터미널을 열어주세요\n- 아래 코드를 실행해주세요\n\n```js\npip uninstall apache-airflow\n```\n\n<img src=\"https://miro.medium.com/v2/resize:fit:534/0*iDdoQ91AdPvPcWGm.gif\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n죄송해요 — 이걸 쓸 때는 금요일이었어요!\n\nOrchestra를 시도해보세요 🚀\n\n(검색 엔진 최적화를 위해 추가한 내용입니다)\n\n# Apache Airflow은 쉽게 배울 수 있나요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아파치 에어플로우는 특히 초보자에게는 어느 정도의 도전이 될 수 있지만, 일부 필수적인 개념과 도구에 익숙해지면 더 쉬워집니다. 에어플로우를 배우기 위해 알아야 할 내용과 학습이 쉬운 또는 어려운 이유를 살펴보겠습니다:\n\n# 전제 조건\n\n- 파이썬: 에어플로우는 파이썬으로 작성되었으므로, 파이썬에 대한 탄탄한 이해가 필수적입니다.\n- 명령줄 인터페이스 (CLI): 명령줄 사용에 대한 기본 지식은 에어플로우의 설치와 구성에 도움이 됩니다.\n- SQL: SQL을 알고 있는 것은 에어플로우가 데이터베이스와 상호 작용하는 경우가 많으므로 유용합니다.\n- 예약 개념: 작업 예약 및 워크플로 관리의 기본 개념을 이해하는 것이 중요합니다.\n\n# 학습 곡선\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 초기 설정: Airflow를 설정하는 것은 여러 구성 요소(Web 서버, 스케줄러, 메타데이터 데이터베이스 등) 때문에 약간 복잡할 수 있어요.\n- DAGs (Directed Acyclic Graphs): Airflow의 핵심 개념은 DAGs를 중심으로 돌아갑니다. DAGs를 정의하고 관리하는 방법을 익히는 데는 시간이 필요하죠.\n- Operators와 Hooks: Airflow는 작업을 정의하고 다양한 시스템에 연결하기 위해 operators와 hooks를 사용해요. 이들의 다양성과 사용 사례를 이해하는 것은 처음에는 압도될 수 있어요.\n- 설정 및 배포: Airflow를 다른 환경(로컬, 온프레미스, 클라우드)에서 실행하도록 설정하는 것은 복잡성을 더합니다.\n\n# 학습 자료\n\n- 문서: 공식 Airflow 문서는 포괄적이며 좋은 시작점입니다.\n- 온라인 튜토리얼과 강의: Udemy, Coursera 등에서 온라인 튜토리얼, 강의, YouTube 비디오들이 Airflow의 기본을 안내해줄 수 있어요.\n- 커뮤니티와 포럼: 포럼, GitHub 이슈, Stack Overflow를 통해 Airflow 커뮤니티와 소통하면 일반적인 문제에 대한 가치 있는 통찰과 해결책을 얻을 수 있어요.\n- 책: “Data Pipelines with Apache Airflow”와 같은 책들은 체계적인 학습을 제공할 수 있어요.\n\n# 실용적인 팁\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 간단히 시작하기: 간단한 DAG부터 시작하여 점차 복잡성을 높여가세요.\n- 실습 중심: 더 많이 연습할수록 더 편안해질 거에요. 작은 프로젝트를 만들어보거나 예제를 복제해보세요.\n- 예제 탐색: 예제 DAG 및 일반 패턴을 검토하면 많은 실용적인 통찰력을 얻을 수 있어요.\n- 관리 서비스 사용: Apache Airflow 설정이 어렵게 느껴진다면 Google Cloud Composer나 Amazon Managed Workflows for Apache Airflow와 같은 관리 서비스 사용을 고려해보세요.\n\n# 요약\n\n- 학습 용이성: 중간 정도의 난이도로 Python 및 관련 도구에 익숙해야 합니다.\n- 학습 경로: 문서로 시작하여 튜토리얼을 사용하고 커뮤니티와 정기적인 실습을 통해 참여하세요.\n- 복잡성: 사용 사례에 따라 다를 수 있으며, 간단한 DAG가 쉽지만 복잡한 워크플로 및 배포에 더 많은 노력이 필요합니다.\n\n전반적으로 Apache Airflow에는 학습 곡선이 있지만 자원과 커뮤니티 지원이 많아 프로세스가 보다 원활해질 수 있습니다. 일관된 연습과 탐색을 통해 Airflow를 숙달하는 것은 분명히 가능합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# Apache Airflow을 시작하는 방법은?\n\n오픈 소스라서 도커, 쿠버네티스를 배우고 다운로드하여 적극 활용해보세요:\n\nApache Airflow를 시작하려면 로컬 머신 또는 서버에 설치하고 설정하는 방법을 따르면 됩니다. 아래는 시작하는 데 도움이 되는 기본 가이드입니다:\n\n# 1. Apache Airflow 설치\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 준비 사항:\n\n- Python: Python이 설치되어 있는지 확인해주세요 (버전 3.6 이상).\n- 가상 환경: 충돌을 피하기 위해 가상 환경을 만드는 것이 좋은 습관입니다.\n\n## 설치 단계:\n\n- 가상 환경 만들기:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\npython -m venv airflow_env source airflow_env/bin/activate # Windows에서는 `airflow_env\\Scripts\\activate`를 사용하십시오\n\n- Apache Airflow 설치: Apache Airflow는 호환 가능한 종속성을 지정하기 위해 constraints 파일을 사용합니다. 아래 명령어를 사용하여 설치할 수 있습니다:\n\n```bash\nexport AIRFLOW_VERSION=2.5.0\nexport PYTHON_VERSION=\"$(python --version | cut -d \" \" -f 2 | cut -d \".\" -f 1-2)\"\nexport CONSTRAINT_URL=\"https://raw.githubusercontent.com/apache/airflow/constraints-${AIRFLOW_VERSION}/constraints-${PYTHON_VERSION}.txt\"\npip install \"apache-airflow==${AIRFLOW_VERSION}\" --constraint \"${CONSTRAINT_URL}\"\n```\n\n# 2. 데이터베이스 초기화\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nAirflow은 작업 인스턴스 및 다른 메타데이터를 추적하는 데 데이터베이스를 사용합니다. Airflow를 실행하기 전에 데이터베이스를 초기화해야 합니다.\n\n```js\nairflow db init\n```\n\n# 3. 관리자 사용자 만들기\n\nAirflow 웹 인터페이스에 액세스할 수 있는 관리자 사용자를 만듭니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n에어플로우 사용자 생성 \\\n   --username admin \\\n   --firstname 당신의_이름 \\\n   --lastname 당신의_성 \\\n   --role Admin \\\n   --email 당신의_이메일\n```\n\n당신의 성, 이름 및 admin@example.com을 여러분의 정보로 대체하세요.\n\n# 4. 에어플로우 웹 서버 및 스케쥴러 시작\n\n- 웹 서버 시작:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n# 첫 번째 터미널 창에서:\nairflow webserver --port 8080\n\n# 두 번째 터미널 창에서:\nairflow scheduler\n```\n\n# 5. Airflow UI에 액세스하기\n\n웹 브라우저를 열고 http://localhost:8080로 이동하세요. 이전에 생성한 관리자 자격 증명을 사용하여 로그인할 수 있습니다.\n\n# 6. 첫 번째 DAG(Directed Acyclic Graph) 생성하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nDAG은 실행하려는 작업을 관계와 종속성을 반영하는 방식으로 구성된 작업 모음입니다.\n\n- DAG 파일 생성: dags 디렉토리에 새 Python 파일을 생성합니다 (일반적으로 ~/airflow/dags에 위치).\n\n```python\n# ~/airflow/dags/example_dag.py\nfrom airflow import DAG\nfrom airflow.operators.dummy_operator import DummyOperator\nfrom datetime import datetime\n\ndefault_args = {\n    'owner': 'airflow',\n    'start_date': datetime(2023, 1, 1),\n    'retries': 1,\n}\n\ndag = DAG(\n    'example_dag',\n    default_args=default_args,\n    description='간단한 예제 DAG',\n    schedule_interval='@daily',\n)\n\nstart = DummyOperator(task_id='start', dag=dag)\nend = DummyOperator(task_id='end', dag=dag)\n\nstart >> end\n```\n\n- 파일 저장: 이 파일을 example_dag.py로 저장하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 7. Airflow UI에서 DAG 확인하기\n\nDAG 파일을 저장한 후 Airflow UI로 이동하면 새로운 DAG가 목록에 표시됩니다. 수동으로 트리거하거나 정의된 일정에 따라 자동으로 트리거될 수 있습니다.\n\n# 추가 자료\n\n- 공식 문서: Apache Airflow 문서\n- 튜토리얼 및 가이드: 여러 온라인 튜토리얼이 특정 사용 사례 및 고급 구성에 도움이 될 수 있습니다.\n- 커뮤니티 지원: Airflow의 Slack 채널이나 다른 커뮤니티 포럼에 가입하여 지원 및 네트워킹을 할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이러한 단계를 따라하면 Apache Airflow를 설정하고 실행하여 자체 워크플로를 만들고 관리할 수 있을 것입니다.\n\n## Airflow을 사용하려면 코딩이 필요한가요?\n\n당연히 그렇죠. Python 및 OOP 지식이 필요합니다. 또한 CI/CD, 약간의 terraform 및 Kubernetes도 필요합니다!\n\n## Apache Airflow를 배우는 데 얼마나 시간이 걸릴까요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n너무 길어요. 궁금하다면, Orchestra를 사용해보세요. 누구나 사용할 수 있고 기업용 오케스트레이터 및 감시 도구의 모든 기능을 가지고 있지만 수고를 덜 수 있어요.\n","ogImage":{"url":"/assets/img/2024-05-27-HowtogetstartedwithApacheAirflow2024updated_0.png"},"coverImage":"/assets/img/2024-05-27-HowtogetstartedwithApacheAirflow2024updated_0.png","tag":["Tech"],"readingTime":9},{"title":"내일을 위한 솔루션을 만들어가는 과정 코딩대쉬 이야기","description":"","date":"2024-05-27 16:37","slug":"2024-05-27-CraftingTomorrowsSolutionsTodayTheCodedashStory","content":"\n디지털 랜드스케이프가 끊임없이 변화하는 시대에는 혁신, 민첩성, 그리고 신기술에 대한 심도 있는 이해가 필수적입니다. Codedash는 AI 기반의 사용자 중심 접근 방식을 활용하여 웹, 모바일 및 서버 개발 솔루션 분야에서 선두주자로서 비즈니스의 미래를 형성합니다.\n\n![Codedash 이미지](/assets/img/2024-05-27-CraftingTomorrowsSolutionsTodayTheCodedashStory_0.png)\n\n## 우리는 누구인가\n\nCodedash에서 우리는 단순히 기술 회사가 아닙니다. 오늘날 기업이 직면한 독특한 과제에 대처하는 맞춤형 솔루션을 만드는 데 헌신된 노련한 전문가들의 팀입니다. 우리의 미션은 조직이 장기적인 성공을 보장하는 확장 가능하고 적응 가능하며 미래지향적인 솔루션을 통합함으로써 기관을 더 강력하게 만드는 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 우리의 철학: 협업과 민첩성\n\n협업은 우리의 접근법의 핵심에 있습니다. 우리는 최고의 해결책이 나오는 것은 우리가 우리의 고객들과 밀접하게 협력하여 그들의 요구를 이해하고 그들의 목표와 전략을 조화시킬 때라고 믿습니다. 이 협업적인 정신은 우리가 차별화된 솔루션을 제공할 수 있도록 해줍니다.\n\n민첩성은 우리 철학의 또 다른 기반입니다. 급변하는 기술적 풍경 속에서 적응하고 발전하는 능력은 중요합니다. Codedash에서는 우리의 솔루션이 효과적일 뿐만 아니라 비즈니스와 함께 성장할 수 있도록 충분히 유연하도록 확실한 방법론을 받아들입니다.\n\n## 우리의 솔루션: 미래를 위해 설계되었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n당사는 비즈니스 운영을 높이고 성장을 촉진하기 위해 설계된 혁신적인 제품 스위트를 제공합니다:\n\n- Dashpad: 휴가 및 출석 추적부터 내장된 채팅 기능을 통한 즉각적인 의사 소통을 용이하게 하는 탁월한 올인원 앱입니다. 작업 추적을 위한 사용자 정의 보드를 갖춘 Dashpad는 생산성과 조직을 향상시켜 실수 없이 모든 것이 원활하게 이루어집니다.\n- DrawDash: 창의력을 발휘할 수 있는 스케치, 그림, 그리기 앱인 DrawDash입니다. 직관적인 사용자 인터페이스, 실행 취소/다시 실행 기능 및 깊이를 위한 다중 레이어를 통해, DrawDash는 예술가와 디자이너가 자신의 비젼을 현실로 구현할 수 있도록 돕습니다.\n- Dashnotes: 당신의 생각을 손쉽게 정리하는 다목적 노트 앱인 Dashnotes입니다. 프로젝트를 관리하는 전문가, 시험 공부를 하는 학생 또는 창의적인 아이디어를 메모하는 사람이라도, Dashnotes는 풍부한 텍스트 편집, 개인 노트 및 미디어 통합을 통해 포괄적인 노트 작성 경험을 제공합니다.\n\n## 왜 Codedash를 선택해야 하는가?\n\n전문지식과 혁신성: 당사 팀은 기술과 혁신에 열정적인 전문가들로 구성되어 있습니다. 우리는 업계 동향을 선행하여 고객들에게 경쟁 우위를 제공하는 첨단 솔루션을 제공합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n사용자 중심 디자인: 저희의 솔루션은 사용자를 염두에 두고 디자인되었습니다. 우리는 사용자 경험을 우선시하여 제품이 기능적일 뿐만 아니라 직관적이고 사용하기 즐겁도록 보장합니다.\n\n품질에 대한 약속: Codedash에서는 품질을 타협할 수 없습니다. 우리는 최고의 탁월성 기준을 준수하여 신뢰할 수 있는 견고하고 신뢰할 수 있는 솔루션을 제공합니다.\n\n## 우리의 미래를 위한 비전\n\n우리가 미래를 바라보며, 우리의 비전은 기술 분야에서 가능한 한 한계를 뛰어넘기를 계속하는 것입니다. 우리는 디지털 전환의 선두에 서 있어 기업이 디지털 시대의 복잡성을 자신 있게 해결하도록 지원합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 우리의 여정에 참여하세요\n\n혁신과 성장으로 가득한 이 흥미진진한 여정에 여러분을 초대합니다. 혁신적인 솔루션을 찾는 비즈니스이거나 최신 기술에 관심이 많은 팬이든, Codedash가 여러분을 이끌어 나갈 것입니다.\n\n저희와 연락을 유지하시고, 제품을 살펴보며 Codedash가 여러분의 비즈니스를 변화시킬 수 있는 방법을 알아보세요. 함께하여 우리는 내일의 솔루션을 오늘 만들어 갈 수 있습니다.\n\n더 많은 정보를 원하신다면, 저희 웹사이트인 Codedash를 방문해 주세요.\n","ogImage":{"url":"/assets/img/2024-05-27-CraftingTomorrowsSolutionsTodayTheCodedashStory_0.png"},"coverImage":"/assets/img/2024-05-27-CraftingTomorrowsSolutionsTodayTheCodedashStory_0.png","tag":["Tech"],"readingTime":4},{"title":"제트팩 컴포즈에서 스낵바를 어떻게 보여줄 수 있을까요","description":"","date":"2024-05-27 16:36","slug":"2024-05-27-HowtoshowSnackbarinJetpackCompose","content":"\n안녕하세요! 아래는 Markdown 형식으로 변경된 테이블 태그입니다.\n\n![Jetpack Compose Snackbar](/assets/img/2024-05-27-HowtoshowSnackbarinJetpackCompose_0.png)\n\n저는 Snackbars에 대해 쓸 예정이며, Jetpack Compose에서 가장 쉬운 방법을 소개해 드릴 예정입니다.\n\n따라서, 이어서 용어를 명확히 정리하면서 시작해 보겠습니다.\n\n# Snackbars란 무엇인가요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n스낵바는 앱 내부에서 어떤 것에 대한 경량화된 피드백을 제공하는 UI 구성 요소입니다. 기본적으로는 앱이 수행했거나 수행할 작업에 대해 사용자에게 간단히 알려주는 메시지입니다.\n\n![스낵바 이미지](/assets/img/2024-05-27-HowtoshowSnackbarinJetpackCompose_1.png)\n\n이들은 임시로 표시되며 시간이 지나거나 사용자 상호 작용 후에 자동으로 사라집니다. 스낵바에는 텍스트 버튼을 통해 액세스할 수 있는 단일 작업이 포함될 수 있습니다. 일반적으로 \"다시 시도\" 또는 \"실행 취소\"와 같은 내용입니다. 그리고 사용자 경험을 중단시키지 않아야 합니다.\n\n# 구현\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n젯팩 콤포즈에서 스낵바가 구현되는 방법을 살펴봅시다. 기본적으로, 주요 구성 요소는 3가지입니다.\n\n- 스낵바 코포저블은 보여주거나 숨기는 옵션이나 애니메이션 없이 머터리얼 디자인 가이드라인에 정의된 스낵바의 시각적 표현에 불과합니다.\n- 스낵바 호스트는 스낵바의 표시 및 숨김, 그리고 애니메이션을 담당하는 구성 요소입니다. 이는 이전에 언급한 스낵바를 감싸는 UI 래퍼입니다.\n- 스낵바 호스트 상태는 스낵바 호스트 내에 표시되는 현재 스낵바 및 나중에 표시할 스낵바 대기열을 제어합니다. 한 번에 최대 하나의 스낵바만 표시할 수 있도록 보장합니다.\n  showSnackbar()라는 중단 메서드가 있어 새로운 스낵바를 표시할 수 있습니다.\n\n자, 이제 스낵바가 무엇이며 어떻게 구현되는지 명확해졌습니다. 처음에 말한대로 최선의 방법으로 표시하는 방법을 보여드리도록 하겠습니다. 하지만 먼저, 스카폴드를 간단히 소개하겠습니다.\n\n# 스카폴드\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nScaffold는 기본적인 머티리얼 디자인 레이아웃 구조를 구현하는 레이아웃입니다. TopBar, BottomBar, Floating Action Button (FAB) 또는 Drawer와 같은 요소를 추가할 수 있습니다.\n\n![image](/assets/img/2024-05-27-HowtoshowSnackbarinJetpackCompose_2.png)\n\nScaffold는 모든 것이 머티리얼 디자인 가이드에 따라 올바른 위치에 함께 표시되도록 합니다.\n\n위에서 보듯이, Scaffold composable에는 SnackbarHostState와 Snackbar Host와 같은 다양한 매개변수가 포함되어 있습니다. 이러한 지식을 바탕으로 코드를 작성할 준비가 되었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 코드\n\nScaffold와 버튼이 있는 Composable을 사용하여 시작해봅시다. 사용자가 버튼을 누르면 스낵바가 표시되어야 합니다.\n\n```js\n@Composable\nfun SnackbarDemo() {\n    Scaffold() {\n        Button(onClick = {})\n        {\n            Text(text = \"Click me!\")\n        }\n    }\n}\n```\n\n우리는 \"remember\" 메서드 내에 기본 ScaffoldState를 생성하여 재구성 후에도 동일한 상태를 사용할 수 있도록합니다. 앞서 언급했듯이, ScaffoldState에는 새로운 스낵바를 표시하는 데 사용할 수있는 SnackbarHostState가 포함되어 있습니다. 메시지 또는 작업 레이블과 같은 필요한 매개변수를 제공해야합니다. 그러나 snowSnackbar은 일시 중단된 함수이므로 직접 호출할 수는 없습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\n@Composable\nfun SnackbarDemo() {\n    val scaffoldState: ScaffoldState = rememberScaffoldState()\n    val coroutineScope: CoroutineScope = rememberCoroutineScope()\n\n    Scaffold(scaffoldState = scaffoldState) {\n        Button(onClick = {\n            coroutineScope.launch {\n                scaffoldState.snackbarHostState.showSnackbar(\n                    message = \"This is your message\",\n                    actionLabel = \"Do something\"\n                )\n            }\n        }) {\n            Text(text = \"Click me!\")\n        }\n    }\n}\n```\n\n버튼을 누를 때마다 스낵바가 화면에 나타날 것입니다. 그러나 스낵바가 사라졌는지, 사용자가 스낵바의 액션을 클릭했는지 알 수 없습니다.\n\n이 문제를 해결하기 위해 현재 스레드를 차단하지 않고 새로운 코루틴을 시작하는 코루틴 범위를 사용합니다. 이제 버튼을 누르면 스낵바가 화면에 나타나야 합니다.\n\n표시된 스낵바가 해제되었는지, 사용자가 스낵바의 액션을 클릭했는지 확인하려면 중단된 함수에 의해 반환된 SnackbarResult를 확인하면 됩니다. SnackbarResult는 Dimissined 또는 ActionPerformed 값을 갖는 enum이며 업무 로직을 이에 따라 구현할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\n@Composable\nfun SnackbarDemo() {\n    val scaffoldState: ScaffoldState = rememberScaffoldState()\n    val coroutineScope: CoroutineScope = rememberCoroutineScope()\n\n    Scaffold(scaffoldState = scaffoldState) {\n        Button(onClick = {\n            coroutineScope.launch {\n                val snackbarResult = scaffoldState.snackbarHostState.showSnackbar(\n                    message = \"This is your message\",\n                    actionLabel = \"Do something\"\n                )\n                when (snackbarResult) {\n                    SnackbarResult.Dismissed -> TODO()\n                    SnackbarResult.ActionPerformed -> TODO()\n                }\n            }\n        }) {\n            Text(text = \"Click me!\")\n        }\n    }\n}\n```\n\n구현 내용을 확인하려면 YouTube 비디오를 참조하십시오. 전체 튜토리얼과 최종 결과를 녹화한 영상이 있습니다.\n\n이 기사가 마음에 드시면 좋아요를 눌러 주시고 피드백을 남기시고 친구들과 공유해 주세요. 즐거운 코딩되세요!\n","ogImage":{"url":"/assets/img/2024-05-27-HowtoshowSnackbarinJetpackCompose_0.png"},"coverImage":"/assets/img/2024-05-27-HowtoshowSnackbarinJetpackCompose_0.png","tag":["Tech"],"readingTime":6},{"title":"라라벨  플러터 플러터 앱을 라라벨 인증 API에 연결하기","description":"","date":"2024-05-27 16:35","slug":"2024-05-27-LaravelFlutterConnectingFlutterApptoLaravelAuthAPI","content":"\n![Screenshot](/assets/img/2024-05-27-LaravelFlutterConnectingFlutterApptoLaravelAuthAPI_0.png)\n\n플러터(Flutter)는 네이티브 컴파일된 애플리케이션을 구축하기 위한 인기 있는 오픈 소스 프레임워크로, 라라벨(Laravel)은 안전하고 확장 가능한 백엔드 솔루션을 제공하는 강력한 PHP 기반 웹 프레임워크입니다.\n\n이 글에서는 플러터 애플리케이션과 라라벨 REST API를 통합하는 과정을 탐색하고, 안전한 사용자 인증 구현을 포함할 것입니다.\n\n# [0] 인증 API가 포함된 라라벨 프로젝트 생성하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이전 글을 따라하거나 빠른 시작 프로젝트를 다운로드하세요.\n\n# [1] Flutter 프로젝트 생성하기\n\n## [1.1] 기본 Flutter 프로젝트 생성\n\n...다음 기본 설정으로.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n(파일 → pubspec.yaml)\n\n```yaml\nversion: 1.0.0+1\nenvironment:\n  sdk: \">=2.18.2 <3.0.0\"\ndependencies:\n  flutter:\n    sdk: flutter\n  cupertino_icons: ^1.0.2\n  dio: ^4.0.0\ndev_dependencies:\n  flutter_test:\n    sdk: flutter\n  flutter_lints: ^2.0.0\nflutter:\n  uses-material-design: true\n```\n\n## [1.2] dio 패키지 추가\n\ndio.dart 패키지는 Dart용 인기있는 HTTP 클라이언트 라이브러리로, Flutter 애플리케이션에서 일반적으로 사용됩니다. 이는 HTTP 요청을 만들고 응답을 처리하며, 가로채기, 헤더 및 기타 고급 기능을 관리하기 위한 간단하고 직관적인 API를 제공하는 유연한 HTTP 클라이언트입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\npubspec.yaml 파일을 업데이트해주세요:\n\n```yaml\ndependencies:\n  dio: ^4.0.6\n```\n\n## [1.3] Auth 서비스 생성\n\n(파일 →lib/services/auth_service.dart)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nimport 'package:dio/dio.dart';\n\nclass AuthService {\n  final _dio = Dio(\n    BaseOptions(\n      baseUrl: 'https://demo.razzi.my/lara11breeze/public/api',\n      headers: {\n        'Accept': 'application/json',\n      },\n    ),\n  );\n\n  Future<Map<String, dynamic>> login(String email, String password) async {\n    final response = await _dio.post('/login', data: {\n      'email': email,\n      'password': password,\n    });\n    return response.data;\n  }\n\n  Future<Map<String, dynamic>> register(\n    String name,\n    String email,\n    String password,\n  ) async {\n    final response = await _dio.post('/register', data: {\n      'name': name,\n      'email': email,\n      'password': password,\n    });\n    return response.data;\n  }\n\n  Future<Map<String, dynamic>> logout() async {\n    final response = await _dio.post('/logout');\n    return response.data;\n  }\n}\n```\n\n코드 설명:\n\n1] dio/dio.dart 패키지 가져오기: 이 import 문은 dio.dart 패키지에서 HTTP 요청을 수행하는 데 사용되는 주요 클래스인 Dio 클래스를 가져옵니다.\n\n2] Dio 인스턴스 초기화: 클래스에는 Dio 인스턴스로 초기화된 private \\_dio 필드가 있습니다. BaseOptions 매개변수를 사용하여 HTTP 요청의 기본 URL 및 기본 헤더를 구성합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- baseUrl: `https://demo.razzi.my/lara11breeze/public/api`: 이 설정은 API의 기본 URL을 설정합니다. 이 경우에는 지정된 URL에서 호스팅되는 데모 라라벨 API입니다.\n- headers: ' `Accept`: `application/json` ': 이 설정은 기본 `Accept` 헤더를 `application/json`으로 설정합니다. 이는 API가 JSON 응답을 반환해야 함을 나타냅니다.\n\n3] 로그인 메서드: 로그인 메서드는 이메일과 비밀번호를 인수로 취하며, `_dio.post` 메서드를 사용하여 /login 엔드포인트로 POST 요청을 보냅니다. 요청 데이터는 데이터 매개변수를 통해 맵으로 전달됩니다.\n\n4] 등록 메서드: 등록 메서드는 이름, 이메일 및 비밀번호를 인수로 취하며, `_dio.post` 메서드를 사용하여 /register 엔드포인트로 POST 요청을 보냅니다. 요청 데이터는 데이터 매개변수를 통해 맵으로 전달됩니다.\n\n5] 로그아웃 메서드: 로그아웃 메서드는 `_dio.post` 메서드를 사용하여 /logout 엔드포인트로 POST 요청을 보냅니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## [1.4] 로그인 화면 생성\n\n(파일 → lib/login_screen.dart)\n\n```js\nimport 'package:flutter/material.dart';\nimport 'services/auth_service.dart';\n\nclass LoginScreen extends StatefulWidget {\n  @override\n  _LoginScreenState createState() => _LoginScreenState();\n}\n\nclass _LoginScreenState extends State<LoginScreen> {\n  final _authService = AuthService();\n  final _emailController = TextEditingController();\n  final _passwordController = TextEditingController();\n\n  Future<void> _login() async {\n    final email = _emailController.text;\n    final password = _passwordController.text;\n\n    try {\n      final response = await _authService.login(email, password);\n      // 응답 처리, 예를 들어 액세스 토큰 및 사용자 데이터 저장\n      print(response);\n    } catch (e) {\n      // 오류 처리\n      print(e);\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('Login'),\n      ),\n      body: Padding(\n        padding: EdgeInsets.all(16.0),\n        child: Column(\n          children: [\n            TextField(\n              controller: _emailController,\n              decoration: InputDecoration(\n                hintText: 'Email',\n              ),\n            ),\n            SizedBox(height: 16.0),\n            TextField(\n              controller: _passwordController,\n              obscureText: true,\n              decoration: InputDecoration(\n                hintText: 'Password',\n              ),\n            ),\n            SizedBox(height: 16.0),\n            ElevatedButton(\n              onPressed: _login,\n              child: Text('Login'),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n```\n\n코드 설명:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n1] 의존성 가져오기: 이 코드는 핵심 Flutter UI 위젯을 제공하는 flutter/material.dart 패키지와 AuthService 클래스를 포함하는 auth_service.dart 파일을 가져옵니다.\n\n2] LoginScreen 위젯: LoginScreen은 StatefulWidget으로 정의되어 있어 변경 가능한 상태를 가질 수 있습니다.\n\n3] \\_LoginScreenState 클래스: \\_LoginScreenState 클래스는 LoginScreen 위젯의 내부 상태 클래스입니다. 다음을 포함합니다:\n\n- \\_authService: 로그인 작업을 수행하는 데 사용되는 AuthService 클래스의 인스턴스입니다.\n- \\_emailController 및 \\_passwordController: 이메일 및 비밀번호 필드의 입력 값을 관리하는 두 TextEditingController 인스턴스입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n4] \\_login 메서드: \\_login 메서드는 사용자가 \"로그인\" 버튼을 탭했을 때 호출되는 비동기 함수입니다. 다음을 수행합니다:\n\n- 각각의 TextEditingController 인스턴스에서 이메일과 비밀번호 값을 가져옵니다.\n- \\_authService 인스턴스의 login 메서드를 호출하여 이메일과 비밀번호를 전달합니다.\n- login 메서드로부터 예상되는 데이터 맵(예: 사용자의 액세스 토큰 및 기타 데이터)를 처리합니다.\n- 오류가 발생하면 콘솔에 오류를 출력합니다.\n\n5] build 메서드: build 메서드는 LoginScreen 위젯의 UI를 정의합니다. 앱 바와 다음을 포함하는 본문이 있는 Scaffold 위젯을 생성합니다:\n\n- 이메일과 비밀번호 입력을 위한 두 개의 TextField 위젯이 있으며, 각각의 TextEditingController 인스턴스가 연결되어 있습니다.\n- 텍스트 필드와 로그인 버튼 사이에 간격을 추가하기 위한 SizedBox가 있습니다.\n- 눌렸을 때 \\_login 메서드를 호출하는 ElevatedButton 위젯이 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## [1.5] 메인 업데이트\n\n(파일 → lib/main.dart)\n\n```js\nimport 'package:flutter/material.dart';\nimport 'login_screen.dart';\n\nvoid main() {\n  runApp(const MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: '플러터 앱!!',\n      theme: ThemeData(\n        colorScheme: ColorScheme.fromSwatch(primarySwatch: Colors.indigo),\n        useMaterial3: true,\n        brightness: Brightness.light,\n      ),\n      darkTheme: ThemeData(\n        colorScheme: ColorScheme.fromSwatch(primarySwatch: Colors.blue),\n        useMaterial3: true,\n        brightness: Brightness.dark,\n      ),\n      home: LoginScreen(),\n      debugShowCheckedModeBanner: false,\n    );\n  }\n}\n```\n\n이제 플러터 앱을 실행하면 MyHomePage 위젯이 아닌 LoginScreen이 표시됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n인증 기능을 더 강화하기 위해 더 많은 화면을 추가할 수 있습니다. 예를 들어, 등록 화면, 비밀번호 재설정 화면, 그리고 로그인에 성공한 후에 표시되는 홈 화면 등을 추가할 수 있습니다. 또한 사용자 인증 상태와 세션 관리를 다루는 로직을 추가할 수도 있습니다.\n\n# [2] 테스트\n\nFlutter 앱을 실행하세요.\n\n1] 로그인 화면에서 Laravel 사용자의 이메일과 비밀번호를 입력하세요. 로그인 버튼을 누르세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n2] 로그를 확인하세요. 모든 것이 잘 작동되면 아래와 같이 응답이 출력됩니다. 응답에는 사용자 토큰이 포함되어 있는데, 이를 이후 요청에 사용할 수 있습니다.\n\n![이미지](/assets/img/2024-05-27-LaravelFlutterConnectingFlutterApptoLaravelAuthAPI_1.png)\n\n# 다운로드\n\n[링크](https://archive.org/download/laravelprojects/lara11breeze_userapi_flutter_20240409.zip)\n","ogImage":{"url":"/assets/img/2024-05-27-LaravelFlutterConnectingFlutterApptoLaravelAuthAPI_0.png"},"coverImage":"/assets/img/2024-05-27-LaravelFlutterConnectingFlutterApptoLaravelAuthAPI_0.png","tag":["Tech"],"readingTime":10},{"title":"안드로이드 오토 튜토리얼 단계별 가이드","description":"","date":"2024-05-27 16:33","slug":"2024-05-27-AndroidAutoTutorialStepbyStepGuide","content":"\n![Android Auto](/assets/img/2024-05-27-AndroidAutoTutorialStepbyStepGuide_0.png)\n\n# 안드로이드 오토란?\n\n안드로이드 오토는 안드로이드 폰과 안드로이드 오토 앱을 가진 사용자들을 위한 운전자 최적화 앱 경험을 제공합니다. 호환되는 자동차에 연결된 안드로이드 스마트폰의 확장판으로, 일부 앱, 엔터테인먼트, 그리고 자동차 대시보드에 메시지를 표시할 수 있습니다. USB 또는 블루투스를 사용하여 기기를 연결할 수 있습니다.\n\n![Android Auto Tutorial Step by Step Guide](/assets/img/2024-05-27-AndroidAutoTutorialStepbyStepGuide_1.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n차량에 핸드폰을 연결하면 모든 Android Auto 호환 앱을 사용할 수 있습니다.\n\n# Android Automotive OS는 무엇인가요?\n\nAndroid Automotive OS는 차량에 내장된 안드로이드 기반 인포테인먼트 시스템입니다. 차량 시스템은 운전용으로 최적화된 독립형 안드로이드 장치입니다. Android Automotive OS를 사용하면 사용자가 앱을 핸드폰이 아닌 차량에 직접 설치할 수 있습니다.\n\n![Android Auto Tutorial Step by Step Guide](/assets/img/2024-05-27-AndroidAutoTutorialStepbyStepGuide_2.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 안드로이드 오토 및/또는 안드로이드 오토모티브 OS는 다음 유형의 앱을 지원합니다:\n\n- 미디어 앱 — 오디오: 미디어 앱을 사용하면 사용자가 차 안에서 음악, 라디오, 오디오북 및 기타 오디오 콘텐츠를 찾아 재생할 수 있습니다.\n- 메시징 앱: 메시징 앱을 통해 사용자는 수신 알림을 받고 텍스트 음성 변환을 사용하여 메시지를 소리내어 읽거나 음성 입력을 통해 답장을 보낼 수 있습니다.\n- 내비게이션 앱: 운전 및 배송 서비스 제공 업체를 포함한 내비게이션 앱은 차원소를 제공하여 사용자가 목적지에 쉽게 도달할 수 있도록 도와줍니다.\n- 관심지역(POI) 앱: POI 앱을 사용하면 사용자가 관심 지역을 발견하고 찾아갈 수 있으며 주차, 충전 및 연료 앱과 같은 관련 작업을 수행할 수 있습니다.\n- 사물인터넷(IOT) 앱: IOT 앱을 사용하면 사용자가 차 안에서 연결된 기기에 관련 작업을 수행할 수 있습니다.\n- 비디오 앱(주차 시에만 사용): 비디오 앱을 사용하면 차가 주차된 상태에서 스트리밍 비디오를 시청할 수 있습니다.\n- 게임(주차 시에만 사용): 게임 앱을 사용하면 차가 주차된 상태에서 게임을 즐길 수 있습니다.\n\n# Android Auto 장치를 탐색하고 에뮬레이터를 설정하기 위한 환경 구성\n\n데스크톱 헤드 유닛(DHU)을 사용하면 개발 컴퓨터를 안드로이드 오토 헤드 유닛으로 에뮬레이션하여 안드로이드 오토 앱을 실행하고 테스트할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nDHU는 Windows, Mac OS 및 Linux 시스템에서 작동합니다.\n\n아래 단계를 따라 Android Auto 에뮬레이터를 활성화하세요.\n\n- Android 6.0 이상( API 레벨 23)을 실행하는 모바일 기기에서 개발자 모드를 활성화하세요.\n- 앱을 컴파일하고 기기에 설치하세요.\n- 기기에 Android Auto를 설치하세요. 이미 Android Auto가 설치되어 있는 경우, 최신 버전을 사용하는지 확인하세요.\n- SDK Manager를 열고 SDK 도구 탭으로 이동한 다음 Android Auto 데스크톱 헤드유닛 에뮬레이터 패키지를 다운로드하세요.\n\n![AndroidAutoTutorialStepbyStepGuide_3](/assets/img/2024-05-27-AndroidAutoTutorialStepbyStepGuide_3.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n5. DHU는 SDK_LOCATION/extras/google/auto/ 디렉토리에 설치됩니다.\n\n6. 리눅스 또는 맥 OS 시스템에서는 해당 디렉토리에서 다음 명령을 실행하여 DHU 실행 파일이 실행 가능한지 확인하세요:\n\n```js\nchmod +x ./desktop-head-unit\n```\n\n```js\n./desktop-head-unit --usb\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n7. 에뮬레이터가 작동을 시작하고 Android 장치에서 업데이트 관련 팝업이 표시되면 업데이트 옵션을 클릭하고 에뮬레이터를 다시 시작하세요.\n\n![이미지](/assets/img/2024-05-27-AndroidAutoTutorialStepbyStepGuide_4.png)\n\n# Android Auto 디자인 템플릿\n\nAndroid Auto에서는 사용자 정의 UI를 만들 수 없고 Android Auto 앱에 허용된 템플릿 세트를 사용할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n나에 따르면, 구글에서 제공하는 미리 정의된 UI 템플릿을 사용하면 운전 중에 안드로이드 오토 장치와 조화롭게 작동할 수 있어요.\n\n## 사용 가능한 템플릿 목록:\n\n- 탭 컨테이너 템플릿\n\n![Tab Container Template](/assets/img/2024-05-27-AndroidAutoTutorialStepbyStepGuide_5.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 마크다운 형식으로 변환한 표입니다.\n\n- Tab bar with app icon and up to 4 tabs (no back button)\n- Embedded template, which can be any of the following types: List, Grid, Search, Pane, or Message\n- List or Grid Template\n\n![Image](/assets/img/2024-05-27-AndroidAutoTutorialStepbyStepGuide_6.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Image](/assets/img/2024-05-27-AndroidAutoTutorialStepbyStepGuide_7.png)\n\n- Message or Long Message Template\n\n![Image](/assets/img/2024-05-27-AndroidAutoTutorialStepbyStepGuide_8.png)\n\n- Search Template\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/assets/img/2024-05-27-AndroidAutoTutorialStepbyStepGuide_9.png)\n\n- Place List (map) Template\n- Navigation Template\n\n# 자동차용 미디어 앱을 만들기 위한 단계\n\n- Manifest 파일에서 Android Auto 지원 선언하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Step 10](/assets/img/2024-05-27-AndroidAutoTutorialStepbyStepGuide_10.png)\n\n![Step 11](/assets/img/2024-05-27-AndroidAutoTutorialStepbyStepGuide_11.png)\n\n- 미디어 브라우저 서비스를 선언하세요\n\n![Step 12](/assets/img/2024-05-27-AndroidAutoTutorialStepbyStepGuide_12.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 안드로이드 오토가 미디어 브라우저 서비스와 상호 작용하는 방법:\n\n![AndroidAutoTutorialStepbyStepGuide_13](/assets/img/2024-05-27-AndroidAutoTutorialStepbyStepGuide_13.png)\n\n- 사용자가 안드로이드 오토에서 앱을 실행하면, 안드로이드 오토가 onCreate() 메서드를 사용하여 앱의 미디어 브라우저 서비스에 연락합니다. onCreate() 메서드를 구현할 때는 MediaSessionCompat 객체와 콜백 객체를 생성하고 등록해야 합니다.\n- 안드로이드 오토가 서비스의 onGetRoot() 메서드를 호출하여 콘텐츠 계층 구조에서 루트 미디어 항목을 가져옵니다. 모든 것은 루트에서 시작하며, MediaBrowserServiceCompat에 연결을 허용하려면 null이 아닌 BrowserRoot를 반환해야 합니다.\n- 안드로이드 오토가 서비스의 onLoadChildren() 메서드를 호출하여 루트 미디어 항목의 자식 항목을 가져옵니다. 안드로이드 오토는 이러한 미디어 항목을 컨텐츠 항목의 최상위로 표시합니다. FLAG_PLAYABLE 및 FLAG_BROWSABLE 두 가지 사용 가능한 플래그가 있으며, 미디어 항목이 직접 재생될 수 있는지 또는 자체 자식 항목이 있는지를 나타냅니다.\n- 사용자가 브라우저 가능한 미디어 항목을 선택하면, 선택한 메뉴 항목의 자식 항목을 다시 검색하기 위해 서비스의 onLoadChildren() 메서드가 호출됩니다.\n- 사용자가 재생 가능한 미디어 항목을 선택하면, 안드로이드 오토는 해당 작업을 수행하기 위해 적절한 미디어 세션 콜백 메서드를 호출합니다.\n\n예시: 음악 항목을 재생하게 됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 안드로이드 오토에서 미디어 앱을 지원하는 필수 단계:\n\n## 표준 재생 작업 설정\n\n안드로이드 오토는 PlaybackStateCompat 객체에서 활성화된 작업에 따라 재생 컨트롤을 표시합니다.\n\n기본적으로 앱은 다음 작업을 지원해야 합니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- ACTION_PLAY\n- ACTION_PAUSE\n- ACTION_STOP\n- ACTION_PLAY_FROM_MEDIA\n- ACTION_PLAY_FROM_SEARCH\n\nIf applicable to your app's content, you can also consider supporting the following actions:\n\n- ACTION_SKIP_TO_PREVIOUS\n- ACTION_SKIP_TO_NEXT\n\nThe MCT includes tests for the following media actions:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- Play\n- Play From Search\n- Play From Media ID\n- Play From URI\n- Pause\n- Stop\n- Skip To Next\n- Skip To Previous\n- Skip To Queue Item\n- Seek To\n\n## 음성 명령 지원\n\n당신의 미디어 앱은 안전하고 편리한 경험을 제공하기 위해 운전자에게 방해가 되지 않도록 도와주는 음성 명령을 지원해야 합니다. Android Auto가 음성 명령을 감지하고 해석하면 해당 음성 명령은 onPlayFromSearch()를 통해 앱으로 전달됩니다. 이 콜백을 받은 후 앱은 쿼리 문자열과 일치하는 내용을 찾아 재생을 시작합니다.\n\n## 사용자 정의 재생 조작\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n미디어 앱이나 메시징 앱, 내비게이션 주차 앱 등이라면 Android Auto 플랫폼을 지원하는 것이 좋은 것 같아요. 사용자가 운전 중에 스크린을 보지 않고도 음성 명령으로 어플을 사용할 수 있도록 하는 것이 유용할 거예요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n지금까지 그럼 이만 마치겠습니다. 향후 글에서는 안드로이드 오토(Android Auto) 및 안드로이드 오토모티브(Android Automotive) 구현 예제 앱을 공유할 예정입니다.\n\nUAMP 미디어 앱은 안드로이드 오토(Android Auto) 및 안드로이드 오토모티브(OS)를 모두 탐색할 수 있는 매우 유용한 저장소입니다.\n\n이 글을 읽어 주셔서 감사합니다. 만약 이 게시물이 유용하고 흥미로웠다면 👏 클릭하고 추천해 주세요.\n\n제 소셜 미디어 및 기타 플랫폼에서 저에게 연락하거나 최신 소식을 확인하세요: [https://linktr.ee/droiddikshit](https://linktr.ee/droiddikshit) 🤝\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n참고 자료:\n\n[Android Media app UAMP](https://github.com/android/uamp)\n","ogImage":{"url":"/assets/img/2024-05-27-AndroidAutoTutorialStepbyStepGuide_0.png"},"coverImage":"/assets/img/2024-05-27-AndroidAutoTutorialStepbyStepGuide_0.png","tag":["Tech"],"readingTime":11}],"page":"53","totalPageCount":116,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":2},"__N_SSG":true}