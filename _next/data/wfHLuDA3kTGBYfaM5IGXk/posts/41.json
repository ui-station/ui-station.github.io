{"pageProps":{"posts":[{"title":"왜 당신의 마이크로서비스 아키텍처가 아마도 지나치게 복잡한 지에 대해 그리고 어떻게 다시 단일체를 사랑하게 되었는지 알아보겠습니다","description":"","date":"2024-06-19 12:09","slug":"2024-06-19-WhyYourMicroservicesArchitectureisProbablyOverkillAndHowILearnedtoLovetheMonolithAgain","content":"\n작은 독립적인 서비스들이 각각 완벽하게 자신의 일을 하는 것, 개발자의 낙원 같지 않아요? 하지만 알아요? 가끔, 이건 정말 엄청난 고통일 수 있어요.\n\n저는 이 허세에 홀렸었어요.\n\n우리는 새 시스템을 구축하고 있었는데, '올바른' 방식으로 하겠다고 다짐했어요. 익숙한 거대한 단일체는 밖으로, 작은 마이크로서비스 떼가 들어왔어요. 처음에는 놀랍게 느껴졌어요 — 너무 깨끗하고, 너무 모듈화됐잖아요!\n\n하지만 현실이 닥쳤어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n결과는, 복잡성이 사라지지 않았습니다; 단지 변했습니다. 이것이 마이크로서비스가 당신의 영혼을 죽일 수 있는 이유입니다:\n\n# 수다스러운 캐시 문제\n\n이전에는 동일한 코드베이스에서 함수를 호출할 수 있었던 것을 기억하시나요? 이제 여러분의 절반 서비스는 네트워크 상에서 수다 떨고 있습니다. 그 중 하나가 성을 내면? 그 난장판을 디버깅하는 데는 행운이 필요할 겁니다.\n\n한 번은 간단했던 함수 호출이 교차 서비스 요청의 끝없는 사가로 변모하고 있습니다. 지연과 관련된 머리 아픔, 네트워크 어딘가에서 뭔가가 고장날까 두려워하는 늘스런 공포의 상태로 변해가고 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n일렇게 REST API와 메시지 큐를 사용하여 처리할 수 있을 것이라 생각할 수도 있지만, 사실은 그 소중한 밀리초가 누적됩니다. 작은 데이터 조각을 가져와야 하나요? 그것은 네트워크 호출입니다. 간단한 작업을 처리해야 하나요? 또 다른 호출이 필요합니다. 여러분의 시스템은 실제 일을 하는 대신 수다에 더 많은 시간을 낭비합니다.\n\n그런 다음, 불가피한 일이 벌어집니다. 여러분의 서비스 중 하나가 오동작하면 네트워크 타임아웃을 발생시키거나 엉망으로 된 데이터를 뱉어 냅니다. 그 속을 해체하는 과정을 즐기세요. 분산 디버깅은 분실된 양말을 찾는 것처럼 쉽지 않습니다. 각 네트워크 호프는 또 다른 용의자, 여러분의 비통의 근원이 될 수 있는 복잡성의 또 다른 층입니다.\n\n# 배포 지옥\n\n코드를 배포했을 때 직업을 바꾸어 야만한 일이 되려고 하거나 라마 농부가 되고 싶어졌던 기억을 여전히 갖고 계시나요? 네, 그런 날들은 이미 멀리 떠났습니다. 마이크로서비스로, 관리 가능한 프로세스였던 것이 불길한 기분을 내뿜는 다두와 여러 머리를 지닌 괴물로 변모했습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n갑자기 어플리케이션 하나가 아니라 십여 개의 작은 괴물을 다루게 되었네요. 각각이 자체 빌드 프로세스, 테스트 슈트 및 신중한 조율이 필요해요. CI/CD 파이프라인은 이렇게 엄청난, 꼬인 루브 골드버그 장치가 되어 새롭고 흥미로운 실패로 매번 고장나는 것처럼 보여요. 잘못된 구성 하나, 맞지 않는 종속성 하나로 모든 것이 터져버릴 수 있어요. 배포 오류와 싸우면서 실제 기능 개발은 멈춰있게 되네요. 코드 복잡성을 운영 복잡성과 바꾸었군요.\n\n# 관찰성 부담\n\n과거 몇몇 전략적으로 배치된 로그 라인으로 무엇이 문제인지 알 수 있던 시절을 기억하시나요? 마이크로서비스로, 그런 시기는 이미 멀리 사라진 기억이 됐어요. 이제는 시스템을 이해하는 데 상당한 투자가 필요할 거예요.\n\n서비스 사이를 건너는 요청을 추적하려면 분산 추적 솔루션이 필요할 건데요. 서비스가 생성하는 로그의 해일을 해석하려면 로그 집계 도구가 기다리고 있어요. 그리고 멋진 대시보드와 경보 시스템을 잊지 마세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n갑자기 예산과 엔지니어링 시간이 시스템이 제대로 작동하는지 확인하는 데 사용되는 것으로 바뀌었네요. 모순적인 점은, 이 모든 복잡성을 더한 결과물로 인해 문제의 근본 원인을 찾기가 이전보다 더 어려워졌다는 느낌을 자주 받습니다. 당신은 가시성의 환상에 큰 대가를 지불하고 있는 것 같습니다.\n\n# 그들은 그리 독립적이지 않아요\n\n마이크로서비스의 전체 약속은 느슨하게 결합되고 서로 교환 가능한 조각들의 아름다운 비전인데, 사실은 종종 많은 허세였던 것으로 밝혀졌어요. 실제로 \"독립적\"인 서비스들이 의외로 얽혀있는 방식으로 복잡해 집니다.\n\n한 서비스의 API를 조정하면 어떤 결과도 없을 것이라고 생각하시나요? 한 번 더 생각해보세요. 숨겨진 가정, 문서화되지 않은 의존성, 그리고 행동의 미묘한 변화들이 불량한 음식 중독과 같이 시스템 전반을 퍼져나갈 수 있습니다. 당신이 알게 모르게, 여러 팀에 걸쳐 다시 작업에 뛰어들어서 왜 이러한 열광을 사들인 걸까 궁금해할 수도 있어요. 민첩성에 대한 약속에 대해 말할 수 없다 — 이제 당신은 아무것도 바꾸기를 두려워할 정도로 두려워하게 되었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 단일체만큼 좋은 경우도 있어요\n\n잠시 동안 독단적인 견해를 내려 놓아 보죠. 구성 요소들이 본질적으로 연결되어 있는 작은 프로젝트, 팀 또는 시스템의 경우, 단일체는 생명보호병이 될 수도 있어요. 이는 단순함을 추구하여 유행성을 포기하는 것과도 같아요.\n\n생각해 보세요: 네트워크 지연 문제가 없고, 디버깅이 간단하며 울고 싶지 않게 배포할 수 있는 장점이 있어요. 확실히 성장하면 조금 엉망일 수 있지만, 코드베이스 내 신중한 모듈화로 그것을 완화할 수 있어요. 그리고 솔직히 말하자면, 잘못 설계된 마이크로서비스 시스템이 보잘것없이 퍼져나가는 모습은 그다지 즐겁지 않아요.\n\n나쁜 말 안 하겠습니다. 마이크로서비스가 나쁜 것은 아니에요. 그것들은 대규모 시스템에서 빛을 발하거나, 구성 요소 간에 완전한 독립성이 필요한 경우에 유용해요. 하지만 맹목적으로 트렌드를 따라가서 모든 것을 마이크로서비스로 분리하는 것은 정말로 무분별한 복잡성과 개발자의 탈진으로 이어지는 결과를 초래할 수도 있어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n가끔 \"옛날 방식\"의 단일체가 더 현명한 선택일 수 있습니다. 인프라와 무쟁하기보다는 가치 전달에 집중할 수 있게 해줍니다.\n\n나는 반드시 마이크로서비스를 비판하는 것은 아닙니다. 특히 확장성이 중요한 대규모 복잡한 시스템에서 유용할 수 있습니다. 그러나 기술 세계는 항상 최신 유행을 지나치게 홍보하여 검증된 솔루션을 낡은 것으로 여기게 만드는 나쁜 버릇이 있습니다.\n\n쿨한 것을 하고 있는 친구들이 그렇게 하고 있다고 해서 우리도 모든 애플리케이션을 마이크로서비스로 나누는 것을 맹목적으로 따라갈 필요는 없습니다. 한 발 물러나서 프로젝트의 필요를 정직하게 평가하고, 복잡성 대비가 정말 그만한지 고려해보세요. 잘 설계된 단일체가 작업 부담이 적게 더해도 동일한 기능을 제공할 수 있는 경우에는 왜 그것을 선택하지 않을까요?\n\n마이크로서비스가 디폴트일 필요는 없습니다; 이는 의도적인 결정이어야 합니다. 독단적인 사고를 버리고 더 실용적인 접근 방식을 채택합시다 — 적합한 도구가 승리하는 아키텍처. 가장 유행하는 것이 아니더라도. 아니, 혹시 서면이 잘 갖춰진 단일체의 간결함에 대한 새로운 감사함을 발견할지도 모릅니다.\n","ogImage":{"url":"/assets/img/2024-06-19-WhyYourMicroservicesArchitectureisProbablyOverkillAndHowILearnedtoLovetheMonolithAgain_0.png"},"coverImage":"/assets/img/2024-06-19-WhyYourMicroservicesArchitectureisProbablyOverkillAndHowILearnedtoLovetheMonolithAgain_0.png","tag":["Tech"],"readingTime":5},{"title":"클라우드 컴퓨팅에서 AI 마스터하기 혁신과 실용적인 기술 활용하기","description":"","date":"2024-06-19 12:08","slug":"2024-06-19-MasteringAIinCloudComputingEmbraceInnovationandPracticalSkills","content":"\n2019년에 클라우드 컴퓨팅을 배우기 위한 첫 번째 플랫폼으로 AWS Educate를 이용했어요.\n\n2019년, 인도네시아의 한 석탑 대학에서 물리학 석사 학위를 받은 후, 컴퓨터 과학 전공이 없는 저에게도 기술 산업에서 일할 기회가 있다는 것을 깨달았어요. 그 당시 인도네시아는 스타트업 붐을 경험하고 있었는데, 저의 학부 동기들 중 일부가 이러한 기업에서 직장을 얻은 것을 보았어요. 처음에는 의심이 많았지만 배우기 시작하기로 결심했어요. 그때 한 친구가 인도네시아 정보부가 후원하는 클라우드 컴퓨팅 및 머신 러닝(ML)에 초점을 맞춘 교육 프로그램에 참여하도록 초대했어요. 처음에는 주저했지만, 물리학 외의 분야를 탐험할 수 있는 좋은 기회라고 생각했어요.\n\n선발 과정을 거친 후에 저와 제 친구는 그 프로그램에 선발되었어요. 저희는 분야 전문가들의 지도를 받았죠. 그것이 제 첫 클라우드 컴퓨팅 체험이었고, 저는 AWS Educate를 통해 중요한 클라우드 기초 지식을 실습하면서 배우기 시작했어요.\n\n익숙치 않은 용어로 새로운 클라우드 컴퓨팅을 배우는 것은 꽤 어려웠어요. 교육 기간이 한 달 뿐이었기 때문에 저는 정보를 천천히 받아들이려고 노력했어요. 가장 간단한 개념부터 이해하려고 노력했어요: 가용성, 지연 시간, 내결함성, 데이터베이스, 서버, 네트워킹, 스토리지 등의 클라우드 용어를 이해하는 것부터 시작했어요. 프로그램이 끝나면 우리가 만든 간단한 프로젝트를 발표하고 모두와 함께 졸업을 축하하는 시간을 가졌어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![2024-06-19-MasteringAIinCloudComputingEmbraceInnovationandPracticalSkills](/assets/img/2024-06-19-MasteringAIinCloudComputingEmbraceInnovationandPracticalSkills_0.png)\n\nAWS Educate was the first platform to guide me in learning about cloud computing. Even though it was not as advanced back then, AWS Educate inspired me to continue learning about the cloud, especially as a beginner. The system was well-organized, which made it easier for me to learn in a structured, gradual, and step-by-step manner.\n\n### Traditional AI vs. Generative AI\n\nApart from cloud computing, my friends and I delved into machine learning. Our project focused on finding the best model for a simple case study: hospital readmission. Hospital readmission occurs when patients return to the hospital after being discharged. A high readmission rate signifies lower quality of care. We analyzed data from 130 hospitals in the U.S. After experimenting with different models, we discovered that the random forest model performed best when dealing with large datasets. This approach is known as traditional AI.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n전통적 AI는 입력 데이터를 기반으로 한 특정 작업 및 예측에 초점을 맞춥니다. 구조화된 데이터를 분석하고 패턴을 식별하며 기존 데이터에 기반한 결정을 내리는 데 능숙합니다. 반면에 GPT-3과 같은 생성적 AI는 새로운 콘텐츠 생성을 목적으로 합니다. 방대한 양의 데이터로부터 학습한 패턴을 기반으로 텍스트, 이미지 및 기타 미디어를 생성할 수 있습니다. 전통적 AI는 분류 및 회귀와 같은 작업에 뛰어나지만, 생성적 AI는 새로운 인간과 유사한 콘텐츠를 생성하고 복잡한 문제에 대한 창의적인 해결책을 찾는 데 빛을 발합니다.\n\n![AI](/assets/img/2024-06-19-MasteringAIinCloudComputingEmbraceInnovationandPracticalSkills_1.png)\n\n전통적 기계 학습 모델은 제공된 데이터를 기반으로 작업을 수행합니다. 순위 매기기, 감정 분석, 이미지 분류 등과 같은 예측을 할 수 있습니다. 그러나 각 모델은 한 가지 작업만 수행할 수 있으며, 이를 성공적으로 수행하려면 모델을 주의 깊게 훈련해야 합니다. 모델이 훈련되는 동안 데이터를 분석하고 패턴을 찾습니다. 그런 다음 이러한 모델은 이러한 패턴을 기반으로 예측을 수행합니다. 전통적 AI는 사용 범위가 매우 제한적하며 (또한 반복적으로 모델링해야 하고 매우 큰 데이터 세트가 필요하기 때문에 복잡할 수 있음), 세계 기업들이 생성적 AI를 개발하기 위해 경쟁을 벌이고 있습니다.\n\n2024년, AWS Educate은 생성적 AI 개요 과정을 소개했습니다. 이전 글에서 \"함께 배우고 싶다\"라고 말했다면, 이 강의를 수강한 적이 있나요? 저는 모든 강의를 마치고 배지를 받았습니다. 여기서 생성적 AI 강좌를 응원하고 싶은 중요한 포인트를 전달하고 싶습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- AI 생성기는 기계 학습 기반 모델에 의해 구동됩니다. 이러한 모델은 콘텐츠를 생성할 수 있습니다. 이 AI 생성 콘텐츠는 편집 가능하며, 필요에 맞게 수정할 수 있습니다.\n- Foundation 모델은 전통적인 기계 학습 모델과 크기, 다양성, 여러 작업을 수행할 수 있는 능력에서 상당히 다릅니다. 이 모델은 라벨이 지정된 데이터를 수집하거나 여러 모델을 별도로 훈련할 필요 없이 여러 작업을 수행할 수 있습니다.\n- 프롬프트 엔지니어링은 모델에 프롬프트를 입력하여 출력으로 표시되는 추론을 생성하는 것을 포함합니다. 그러나 출력물이 만족스럽지 않은 경우 프롬프트를 조정하거나 작업 예제를 제공해야 할 수 있습니다. 프롬프팅은 중요한 기술이 될 것이며, 우리 자신이 올바른 프롬프트를 제공하는 방법을 연습할수록 AI 결과는 더 좋아질 것입니다.\n- 생성적 AI와 관련된 AWS 서비스는 무엇인가요? 다음은 슬라이드입니다.\n\n![이미지](/assets/img/2024-06-19-MasteringAIinCloudComputingEmbraceInnovationandPracticalSkills_2.png)\n\nAmazon Bedrock\n\n- 설명: Amazon Bedrock은 쉬운 API를 통해 Amazon 및 다른 제공업체의 다양한 대형 언어 모델(LLM)에 액세스할 수 있도록 제공하여 개발자가 모델 인프라를 관리하지 않고 생성적 AI 응용 프로그램을 구축할 수 있게 합니다.\n- 비유: 다양한 작가의 최고의 책이 있는 큰 도서관을 상상해보세요. 필요한 책(모델)을 빌릴 수 있고 사용 후 반납할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아마존 코드위스퍼러\n\n- 설명: 아마존 코드위스퍼러는 AI를 사용하여 개발자가 코드를 작성하는 동안 빠른 코드 제안을 제공하는 도구로, 코드 작성 중에 코드의 맥락에 기반한 스니펫, 함수 및 로직을 제공하여 생산성을 향상시킵니다.\n- 유사성: 자신을 지도해주는 지능적인 비서와 함께 삽시간에 다음 단어나 문장을 제안하는 작가로 생각해 보세요. 이를 통해 더 빨리, 더 부드럽게 쓸 수 있습니다.\n\nAWS 인퍼런티아\n\n- 설명: AWS 인퍼런티아는 AWS의 특수화된 가속기 칩으로, 머신러닝 모델의 추론을 가속화하는 것을 목적으로 설계되었습니다. 추론은 훈련된 모델을 실행하여 예측이나 결정을 내리는 과정을 말합니다.\n- 유사성: 일정한 수학적 문제를 해결하는 데 특별히 설계된 초고속 계산기가 있다고 상상해 보세요. 이를 통해 짧은 시간 내에 많은 문제를 해결할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nAWS Trainium\n\n- 설명: AWS Trainium은 AWS의 전문 가속기 칩으로, 기계 학습 모델의 훈련 속도를 높여 복잡한 AI 모델을 훈련하는 데 필요한 시간과 비용을 줄입니다.\n- 비유: AWS Trainium은 엘리트 선수 훈련을 위한 고급 장비가 갖춰진 개인 체육관처럼 생각해보세요. 이를 통해 효과적으로 훈련하고 더 빨리 최고의 성과를 달성할 수 있습니다.\n\nAmazon SageMaker JumpStart\n\n- 설명: Amazon SageMaker JumpStart는 미리 구축된 솔루션과 사용 준비가 된 모델을 제공하여 기계 학습 애플리케이션 개발을 가속화합니다. 미리 훈련된 모델과 다양한 사용 사례에 대한 튜토리얼 노트북이 포함되어 있습니다.\n- 비유: 테이블을 만들고 싶다고 상상해보세요. 준비가 완료된 모든 부품이 포함된 완전 조립 키트와 단계별 메뉴얼을 받아서 아무것도 잘라내거나 측정할 필요 없이 지침에 따라 진행할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n클라우드 컴퓨팅 분야에서 학습하고 근무하는 저로서는 AI가 인간을 대체할 수도 있다는 우려가 있었습니다. 그러나 이러한 두려움이 과장되었을 수 있지만, 쉽게 이해할 수 있는 이 강의를 통해 AI가 어떻게 작동하는지 이해하는 것에 가치가 있다고 생각해요. 엔지니어/개발자로서, 이를 통해 우리는 이전보다 빠르게 문제를 해결할 수 있게 되었습니다. AI는 올바르게 활용된다면 우리의 작업을 크게 향상시킬 수 있어요. 이 강의는 입구와 같은 존재이며, 2019년에 클라우드 여정을 시작했지만, 이를 통해 많은 새로운 것들을 배웠습니다.\n\n결론\n\n전통적인 AI 모델은 일반적으로 특정 작업을 위해 구축되고 훈련되며 해당 작업에 맞춤화된 데이터셋으로 구축됩니다. 예를 들어, 얼굴 인식 AI 모델은 다양한 얼굴 이미지를 기반으로 훈련될 것입니다. 이러한 모델들은 특정 작업에서 우수한 성과를 보이지만, 큰 재훈련 없이는 다른 문맥에서의 융통성이 부족합니다. 반면, 생성적 AI의 기초 모델은 다재다능하며 작은 조정만으로 다양한 작업에 적응시킬 수 있습니다. 마치 보편적인 성형이 작은 수정으로 다양한 제품을 만들어내는 것과 비슷하죠.\n\n이어서, AWS Educate의 또 다른 흥미로운 강좌를 추천드리며, 이 강좌는 AWS의 AI 서비스 중 하나인 Amazon Bedrock에 초점을 맞추고 있습니다. 다음은 강좌 수강 방법입니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- www.awseducate.com에 방문해주세요.\n- 제네레이티브 아마존 베드락 소개를 선택해주세요.\n- 코스를 약 0.75시간 내에 완료해주세요.\n- 경험을 공유해주세요!\n\n그래서, 클라우드 컴퓨팅에서 AI의 미래를 탐험하고 오늘 당신의 잠재력을 발휘해보세요! 즐거운 학습되세요!\n\n사랑을 담아,\n\nNova Lailatul Rizkiyah\n","ogImage":{"url":"/assets/img/2024-06-19-MasteringAIinCloudComputingEmbraceInnovationandPracticalSkills_0.png"},"coverImage":"/assets/img/2024-06-19-MasteringAIinCloudComputingEmbraceInnovationandPracticalSkills_0.png","tag":["Tech"],"readingTime":8},{"title":"AWS 인터뷰 질문 DAY_25 90","description":"","date":"2024-06-19 12:03","slug":"2024-06-19-DAY_2590INTERVIEWQUESTIONSONAWS","content":"\n![](/assets/img/2024-06-19-DAY_2590INTERVIEWQUESTIONSONAWS_0.png)\n\nBelow are some basic AWS interview questions along with the answers.✍\n\n# 1. What is Cloud Computing and what are its features?\n\nCloud computing is a general term for the delivery of hosted computing services and IT resources over the internet with pay-as-you-go pricing.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n클라우드 컴퓨팅의 특징은 다음과 같습니다:\n\n- 자원 풀링: 클라우드 서비스 제공업체는 다양한 서비스를 제공하는 각각의 다른 클라이언트 사이에서 자원을 공유할 수 있습니다.\n- 넓은 접근성: 클라이언트는 장치와 인터넷 연결이 있는 어디서든 클라우드 데이터에 접근하거나 클라우드로 데이터를 전송할 수 있습니다. 이러한 기능은 조직 전역에서 어디서든 이용 가능하며 인터넷의 도움으로 실현됩니다.\n- 신속한 탄력성: 이 클라우드 기능은 필요에 따라 신속하게 확장하거나 축소할 수 있는 워크로드를 비용 효율적으로 처리할 수 있게 합니다. 사용자가 서버를 요청하면 제공되고 필요 시 바로 확장됩니다.\n- 셀프 서비스 온디맨드: 이는 클라이언트가 서버 가동 시간, 기능 및 할당된 네트워크 저장소를 계속 모니터링할 수 있도록 합니다. 이는 클라우드 컴퓨팅의 기본 기능이며 고객은 자신의 요구에 맞춰 컴퓨팅 능력을 제어할 수도 있습니다.\n- 사용량 측정: 이를 통해 제공자와 고객 모두가 사용된 서비스와 목적을 모니터링하고 보고할 수 있습니다. 이는 청구 모니터링을 돕고 리소스의 최적 이용을 보장합니다.\n\n# 2. 다양한 클라우드 배포 모델은 무엇인가요?\n\n클라우드 배포 모델은 데이터 저장량 및 인프라 액세스 권한에 따라 선택할 수 있는 가상 컴퓨팅 환경으로 작동합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n클라우드 배포 모델에는 4가지 유형이 있습니다: -\n\n- 공용 클라우드: 이름 그대로 공개적으로 접근 가능합니다. 클라우드의 공개 배포 모델은 성장하고 변동하는 수요를 갖는 조직에 적합합니다. 또한 보안 우려가 낮은 기업들에게 좋은 선택지입니다. 따라서 공개 인터넷에서 네트워킹 서비스, 컴퓨팅 가상화 및 저장소에 대해 클라우드 서비스 제공업체에 요금을 지불합니다.\n- 사설 클라우드: 데이터 센터와 통합되어 내부 IT 팀이 관리합니다. 대체로 외부에 호스팅할 수도 있습니다. 사설 클라우드는 맞춤화가 필요한 특정 조직의 요구를 충족시키는 더 큰 기회를 제공합니다. 비용 효율성 및 데이터 및 자원에 대한 더 큰 제어를 찾는 기업들은 사설 클라우드를 더 적합한 선택으로 여길 것입니다.\n- 하이브리드 클라우드: 두 개 이상의 클라우드 아키텍처를 조합한 형태입니다. 하이브리드 클라우드의 각 모델은 서로 다르게 기능하지만, 하나의 아키텍처의 일부입니다. 더 나아가 클라우드 컴퓨팅 모델의 이 배포 일환으로 내부 또는 외부 제공 업체가 리소스를 제공할 수 있습니다.\n- 커뮤니티 클라우드: 공용 클라우드와 유사한 방식으로 운영됩니다. 유일한 차이점은 특정 목표와 사용 사례를 공유하는 특정 사용자 그룹에만 액세스 권한을 부여한다는 것입니다. 이러한 클라우드 컴퓅팅 배포 모델 유형은 내부적으로 또는 제3자 벤더에 의해 관리 및 호스팅됩니다.\n\n# 3. 클라우드 컴퓨팅의 다양한 유형은 무엇인가요?\n\n클라우드 컴퓨팅에는 인프라스트럭처 서비스(IaaS), 플랫폼 서비스(PaaS) 및 소프트웨어 서비스(SaaS)라는 세 가지 주요 유형이 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- IaaS: IaaS는 가상화된 컴퓨팅 자원을 제공하며 가상 머신, 스토리지 및 네트워크와 같은 자원을 인터넷을 통해 제공합니다. 사용자는 인프라에서 실행하는 운영 체제 및 어플리케이션을 제어할 수 있어 더 큰 유연성과 맞춤 설정이 가능합니다.\n- PaaS: PaaS는 개발자가 기반 인프라를 관리하지 않고 애플리케이션을 구축, 배포 및 관리할 수 있는 플랫폼을 제공합니다. 개발 도구, 데이터베이스 및 실행 환경을 포함한 미리 구성된 환경을 제공하여 개발자가 인프라 관리 대신 애플리케이션 개발에 집중할 수 있습니다.\n- SaaS: SaaS는 인터넷을 통해 구독 기반으로 소프트웨어 애플리케이션을 제공합니다. 사용자는 설치나 관리가 필요하지 않고 이러한 애플리케이션에 액세스하고 사용할 수 있습니다. SaaS의 예로는 이메일 서비스, 고객 관리(CRM) 소프트웨어, Google Workspace와 같은 생산성 도구가 있습니다.\n\n# 4. 데이터 센터, 리전, 가용 영역(AZ), 엣지 위치, 로컬 영역, 웨이브렝스 영역은 무엇인가요?\n\n데이터 센터는 복잡한 네트워크, 컴퓨팅 및 스토리지 인프라를 이용하여 애플리케이션 및 데이터에 대한 공유 접근을 제공하는 시설입니다.\n\n리전은 특정 AWS 인프라 세트를 통해 서비스되는 지리적 영역입니다. 각 리전에는 독립된 거리와 독립된 전원 및 냉각으로 서로 격리된 여러 가용 영역이 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n가용 영역(Availability Zone)은 AWS 지역 내에서 고가용성과 오류 허용성을 제공하기 위해 설계된 격리된 데이터 센터입니다.\n\n에지 위치(Edge Location)는 사용자에게 빠르게 콘텐츠를 전달하기 위해 사용되는 데이터 센터입니다. 사용자에게 가장 가까운 위치에 있는 사이트입니다.\n\n로컬 영역(Local Zone)은 컴퓨팅 및 스토리지 등의 리소스를 사용자에게 더 가까운 여러 위치에 배치할 수 있도록 제공합니다.\n\n파장(Zones)은 개발자가 5G 기기와 사용자에게 초저 지연 시간을 제공하는 애플리케이션을 구축할 수 있도록 합니다. 파장은 표준 AWS 컴퓨팅 및 스토리지 서비스를 통신 사업자의 5G 네트워크 가장자리에 배포합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 5. AWS가 무엇인가요?\n\nAWS는 아마존 웹 서비스(Amazon Web Services)의 약자입니다. AWS는 아마존에서 제공하는 클라우드 컴퓨팅 플랫폼으로, 다양한 종류의 애플리케이션 및 서비스를 유연하고 확장 가능하며 비용 효율적으로 구축하고 배포하는 데 도움이 되는 다양한 클라우드 서비스를 제공합니다.\n\n# 6. 사용한 AWS 서비스 5가지와 사용 사례는 무엇인가요?\n\n- EC2 (Elastic Compute Cloud): EC2는 가상 서버(인스턴스)를 시작하여 애플리케이션을 실행할 수 있는 확장 가능한 클라우드 컴퓨팅 서비스입니다. 인스턴스 유형과 운영 체제를 선택할 수 있어, 웹 애플리케이션 호스팅부터 데이터 처리 작업까지 다양한 사용 사례에 적합합니다.\n- IAM (Identity and Access Management): IAM은 AWS의 신원 관리 서비스입니다. AWS 리소스에 누가 액세스할 수 있고 어떤 작업을 수행할 수 있는지 제어할 수 있습니다. 사용자 계정, 역할 및 권한을 관리하여 AWS 환경의 보안을 보장하는 데 중요합니다.\n- S3 (Simple Storage Service): S3는 저장 및 데이터 검색에 일반적으로 사용되는 확장 가능한 객체 저장 서비스입니다. 이미지, 비디오, 백업과 같은 정적 자산을 저장하는 데 효과적이며, 다른 AWS 서비스와 통합하여 정적 웹 사이트를 호스팅하거나 애플리케이션 데이터를 저장할 수 있습니다.\n- RDS (Relational Database Service): RDS는 MySQL, PostgreSQL, Oracle, SQL Server와 같은 관리형 관계형 데이터베이스를 제공합니다. 애플리케이션 실행, 사용자 데이터 저장, 분석 및 보고용으로 사용됩니다.\n- CloudWatch: CloudWatch는 AWS의 모니터링 및 관측 서비스입니다. 메트릭을 수집하고 추적하며, 로그 파일을 모니터링하고 경보를 설정할 수 있습니다. AWS 리소스의 작동 상태 및 성능에 대한 통찰력을 얻고, 운영 이벤트와 문제에 실시간으로 대응하는 데 중요합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 7. 클라우드 환경으로 로그를 전송하는 데 사용되는 도구들은 무엇인가요?\n\n클라우드 환경으로 로그를 전송하는 데 여러 도구들을 사용할 수 있습니다. 일반적으로 사용되는 도구들은 다음과 같습니다:\n\n- Amazon CloudWatch Logs: CloudWatch Logs는 AWS의 내장 서비스로, 다양한 AWS 리소스 및 애플리케이션에서 로그 데이터를 수집, 모니터링하고 저장할 수 있습니다. AWS 리소스를 구성하여 그들의 로그를 직접 CloudWatch Logs로 전송할 수 있습니다.\n- AWS CloudTrail: AWS CloudTrail은 AWS 계정 내의 API 활동 및 이벤트를 캡처하고 로깅하여 사용자, 서비스 또는 리소스에 의해 수행된 작업을 파악할 수 있게 합니다.\n- Elasticsearch: Elasticsearch는 오픈 소스 검색 및 분석 엔진으로, 로그를 저장, 색인화 및 분석하는 데 사용할 수 있습니다. Logstash 및 Kibana(ELK 스택)과 함께 자주 사용되어 로그 관리 및 분석에 활용됩니다.\n- Fluentd: Fluentd는 다양한 소스에서 로그를 수집하여 클라우드 저장소 또는 분석 플랫폼으로 전송할 수 있는 오픈 소스 데이터 수집기입니다.\n- Logstash: Logstash는 ELK 스택의 일부로, 로그를 수집, 구문 분석 및 변환한 후 저장소 또는 분석 플랫폼으로 전송하는 데 사용됩니다.\n\n# 8. IAM 역할들은 무엇이며, 어떻게 만들고 관리할까요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nAWS의 IAM(Identity and Access Management) 역할은 신뢰하는 엔터티에 권한을 부여하는 방법입니다. 이러한 엔터티는 AWS 서비스, 응용 프로그램 또는 AWS 계정 또는 외부 AWS 계정 내의 사용자가 될 수 있습니다. 역할은 장기 보안 자격 증명인 액세스 키나 비밀번호 없이 AWS 리소스에 액세스하기 위한 권한 위임을 안전하게 수행하는 방법입니다.\n\nIAM 역할은 귀하를 대신해 AWS 리소스와 상호 작용해야 하는 서비스 및 응용 프로그램에 일반적으로 사용됩니다.\n\n- AWS 관리 콘솔에 로그인: AWS IAM 콘솔로 이동합니다 (console.aws.amazon.com/iam).\n- 역할로 이동: 왼쪽 탐색 창에서 \"역할\"을 선택합니다.\n- 새 역할 생성:\n\n- \"역할 생성\" 버튼을 클릭합니다.\n- 신뢰하는 엔터티 유형을 선택합니다 (예: AWS 서비스, 다른 AWS 계정 또는 SSO 식별 공급자).\n- 역할 목적을 가장 잘 설명하는 사용 사례를 선택합니다. 예를 들어 EC2 인스턴스용 역할을 생성하는 경우, 사용 사례로 \"EC2\"를 선택할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n4. 권한 설정:\n\n- 역할에 정책을 연결합니다. 정책은 역할이 수행할 수 있는 작업을 정의합니다. 기존 정책 중 선택하거나 사용자 정의 정책을 생성할 수 있습니다.\n\n5. 이름 지정 및 검토:\n\n- 역할에 이름을 지정하고 선택적으로 태그를 추가하여 조직화를 돕습니다.\n- 역할의 구성을 검토하고 \"역할 생성\"을 클릭합니다.\n- 신뢰 관계 업데이트: 신뢰 관계를 편집하여 누가 또는 무엇이 역할을 가정할 수 있는지 허용하거나 제한할 수 있습니다.\n- 권한 업데이트: 권한을 부여하거나 제거하기 위해 정책을 연결 또는 분리할 수 있습니다. 역할에 필요한 권한이 있는지 확인하고 필요에 맞게 정책을 검토하고 업데이트하는 것이 중요합니다.\n- 역할 삭제: 더 이상 필요하지 않은 역할은 삭제할 수 있습니다. 역할 삭제 시 서비스 및 애플리케이션에 영향을 줄 수 있으니 조심해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 9. 시스템을 다운타임 없이 업그레이드 또는 다운그레이드 하는 방법\n\n시스템을 다운타임 없이 업그레이드 또는 다운그레이드하는 것은 특정 전략과 모베스트 프랙티스를 구현함으로써 가능합니다. 이 고수준 접근 방식을 살펴보겠습니다:\n\n- 로드 밸런서: 로드 밸런서를 설정하여 트래픽을 여러 인스턴스 또는 노드에 분산시켜야 합니다. 이를 통해 업그레이드/다운그레이드 프로세스 중에도 트래픽을 원활하게 리디렉션할 수 있습니다.\n- 다중 환경: 여러 환경(예: 스테이징, 프로덕션)을 생성하여 업그레이드/다운그레이드 프로세스를 실행해야 합니다. 하나를 업그레이드/다운그레이드하는 동안 영향을 받지 않는 환경으로 트래픽을 보내야 합니다.\n- 블루/그린 배포: 새 버전(그린)이 기존 버전(블루)과 함께 배포되는 블루/그린 배포 전략을 구현해야 합니다. 천천히 트래픽을 블루 환경에서 그린 환경으로 전환합니다.\n- 데이터베이스 복제: 데이터베이스 복제 기술을 사용하여 업그레이드/다운그레이드된 버전의 두 번째 인스턴스를 생성해야 합니다. 데이터베이스 변경 사항을 동기화하고 업데이트된 데이터베이스를 사용하도록 응용 프로그램을 다운타임 없이 전환해야 합니다.\n- 롤링 업그레이드: 하나씩 인스턴스 또는 구성 요소를 업데이트하여 전체 프로세스 중에 응용 프로그램이 사용 가능함을 보장하는 롤링 업그레이드를 수행해야 합니다.\n- 헬스 체크 및 모니터링: 시스템의 가용성을 보장하기 위해 헬스 체크를 구현하고 문제가 발견되면 프로세스를 밀접하게 모니터링해야 합니다. 이상이 감지되면 즉시 롤백해야 합니다.\n\n# 10. 인프라스트럭처 코드(Infrastructure as code)란 무엇이며 어떻게 사용하나요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n인프라스트럭처 코드(IaC)는 기계가 읽을 수 있는 구성 파일이나 스크립트를 사용하여 인프라 자원을 관리하고 프로비저닝하는 실천 방법을 말합니다. 이는 수동 프로세스 대신 소프트웨어 코드로 인프라를 처리하여 버전 관리, 자동화 및 재생산성을 가능하게 합니다.\n\n- 정의: 인프라스트럭처 코드는 원하는 상태의 인프라 자원을 정의하는 구성 파일이나 스크립트를 작성하는 것을 포함합니다. (예: AWS CloudFormation, Terraform, 또는 Ansible과 같은 도구 사용)\n- 자동화: IaC를 통해 인프라의 자동 프로비저닝 및 관리가 가능해지며 수동 구성이 필요 없어지고 인간 에러를 줄일 수 있습니다.\n- 버전 관리: 인프라 코드는 버전 관리 시스템에 버전을 매기고 저장할 수 있어 팀이 협업하고 변경을 추적하며 필요한 경우 이전 버전으로 롤백할 수 있습니다.\n- 재생산성: IaC를 사용하면 인프라를 쉽게 다른 환경으로 복제할 수 있어 개발, 테스트 및 프로덕션 간 불일치를 줄이고 일관성을 유지할 수 있습니다.\n- 확장성: IaC는 프로그래밍적으로 조정할 수 있는 매개변수와 정책을 정의하여 인프라 자원의 확장을 간소화하며 워크로드나 수요 변화를 수용할 수 있습니다.\n\n# 11. 로드 밸런서(load balancer)란 무엇인가요? 귀하의 경험에 따른 각 종류의 밸런서 시나리오를 제시해주세요.\n\n로드 밸런서는 사용자와 서버 그룹 사이에 위치하여 모든 리소스 서버가 공평하게 사용되도록 보장하는 보이지 않는 편의 기기 또는 서비스입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- Application Load Balancer (ALB): ALB는 OSI 모델의 애플리케이션 레이어(Layer 7)에서 작동합니다. URL 기반 라우팅, 콘텐츠 기반 라우팅 및 HTTP/HTTPS 프로토콜 지원과 같은 고급 라우팅 기능을 제공합니다.\n- Network Load Balancer (NLB): NLB는 전송 레이어(Layer 4)에서 작동하며 초저지연으로 대량 트래픽을 처리하기 위해 설계되었습니다. TCP, UDP 및 TLS 트래픽에 적합하여 게임 애플리케이션 및 IoT 애플리케이션과 같은 사용 사례에 적합합니다.\n- Classic Load Balancer (CLB): CLB는 AWS에서 제공하는 레거시 로드 밸런서입니다. Layer 4와 Layer 7에서 모두 작동하며 기본적인 로드 밸런싱 기능을 제공합니다.\n\n## 12. 클라우드포메이션(CloudFormation)은 무엇이며 왜 사용됩니까?\n\nAWS CloudFormation은 템플릿을 사용하여 선언적 방식으로 인프라 리소스를 정의하고 프로비저닝할 수 있는 서비스입니다. AWS 리소스의 생성, 구성 및 관리를 자동화하는 방법을 제공합니다.\n\n클라우드포메이션은 배포를 자동화하고 리소스 일관성을 보장하며 스케일링을 관리하고 종속성을 처리하며 AWS 환경에서 변경 관리를 간소화하는 데 사용됩니다. 이는 AWS에서 인프라 자동화 및 관리를 위한 주요 도구입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 13. AWS CloudFormation과 AWS Elastic Beanstalk의 차이점은 무엇인가요?\n\nAWS CloudFormation:\n\n- AWS 인프라를 코드로 정의하고 프로비저닝하는 서비스입니다.\n- JSON 또는 YAML로 템플릿을 작성하여 AWS 리소스와 구성을 지정합니다.\n- EC2 인스턴스, 데이터베이스, 네트워킹 등 포함 전체 인프라 제어에 유용합니다.\n- 복잡한 아키텍처를 지원하며 리소스를 생성하거나 수정할 수 있습니다.\n- 주로 인프라 오케스트레이션과 구성 관리에 사용됩니다.\n\nAWS Elastic Beanstalk:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 웹 애플리케이션을 배포하고 관리하기 위한 Platform as a Service (PaaS)입니다.\n- 개발자는 자신의 애플리케이션 코드를 제공하고 Elastic Beanstalk이 인프라 프로비저닝을 처리합니다.\n- 간소화된 애플리케이션 배포와 확장성에 이상적입니다.\n- 다양한 프로그래밍 언어와 프레임워크를 지원합니다.\n- 인프라 관리에 깊게 개입하지 않고 신속하고 간편한 애플리케이션 호스팅에 최적화되어 있습니다.\n\n# 14. Amazon EC2 인스턴스의 저장 옵션을 나열하세요.\n\n- Amazon Elastic Block Store (EBS)\n- Amazon EC2 인스턴스 스토어\n- Amazon Elastic File System (EFS)\n- Amazon Simple Storage Service (S3)\n- Amazon Glacier\n\n# 15. 클라우드에서 발생할 수 있는 보안 공격 유형은 무엇이 있으며, 이를 최소화하는 방법은 무엇입니까?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n클라우드 환경에서 여러 보안 공격이 발생할 수 있습니다:\n\n- 미인가된 접근: 공격자가 클라우드 자원과 데이터에 미인가된 접근을 시도할 수 있습니다.\n- 데이터 유출: 민감한 데이터가 클라우드 저장소나 데이터베이스에서 노출되거나 도용될 수 있습니다.\n- 분산 서비스 거부 (DDoS): 공격자가 과도한 트래픽으로 클라우드 인프라를 넘치게 하여 서비스를 이용할 수 없게 할 수 있습니다.\n- 보안이 취약한 API: API의 취약점을 악용하여 미인가된 접근이나 클라우드 자원 조작이 가능합니다.\n- 내부 위협: 특권 있는 접근 권한을 가진 악의적 내부 사용자가 민감한 정보를 남용하거나 유출할 수 있습니다.\n\n이러한 공격을 최소화하기 위해 다음과 같은 보안 모법을 따르세요:\n\n- 강력한 접근 제어를 시행하세요. 강력한 암호, MFA, 최소 특권 원칙을 적용하세요.\n- 이동 중인 데이터와 정지된 데이터를 암호화하세요.\n- 소프트웨어와 시스템을 정기적으로 업데이트하고 패치하세요.\n- 보안 사건을 감지하고 대응하도록 활동을 모니터링하고 로깅하세요.\n- 방화벽 및 침입 탐지/방지 시스템과 같은 네트워크 보안 조치를 시행하세요.\n- 정기적으로 보안 평가와 감사를 수행하세요.\n- 직원들에게 보안 인식 및 모범 사례에 관한 교육을 실시하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 16. EC2 인스턴스 키를 분실했을 때 복구할 수 있을까요?\n\nEC2 인스턴스와 인증에 사용된 키 쌍을 분실한 경우 해당 키를 사용하여 인스턴스에 액세스를 복구하거나 회복할 수 없습니다.\n\n그러나 여러 가지 방법으로 여전히 액세스를 복구할 수 있습니다: -\n\n- 원본 키 쌍 복구: 개인 키의 백업이 있거나 분실한 키를 검색할 수 있다면 키 쌍을 교체함으로써 액세스를 회복할 수 있습니다.\n- 새 EC2 인스턴스 생성: 원본 키 쌍을 복구할 수 없다면 인스턴스의 AMI를 만들고 새 키 쌍으로 새로운 인스턴스를 시작할 수 있습니다.\n- 인스턴스 메타데이터를 통한 액세스 (Linux 인스턴스): 일부 경우, IAM 역할을 갖는 Linux 인스턴스의 경우 인스턴스 메타데이터와 공개 키를 사용하여 인스턴스에 액세스할 수 있을 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n상호작용 문제를 방지하기 위해 예방적인 키 관리의 중요성과 백업 유지의 중요성을 강조하는 것이 중요합니다.\n\n# 17. 게이트웨이란 무엇인가요?\n\n게이트웨이는 서로 다른 네트워크 간의 입구점 또는 인터페이스로 작용하는 네트워킹 장치나 서비스입니다. 통신과 데이터 전송을 가능하게 하며 브리지나 커넥터로 작동하여 서로 다른 프로토콜이나 아키텍처를 가진 다른 네트워크를 연결합니다.\n\n게이트웨이는 라우팅, 프로토콜 변환, 보안 강화 및 네트워크 트래픽 관리와 같은 다양한 기능을 수행할 수 있습니다. 이러한 기능은 네트워크 간 연결성과 상호 운용성을 가능하게 하며 데이터가 원활하게 흐를 수 있도록 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n게이트웨이는 일반적으로 인터넷 환경에서 사용되며, 로컬 네트워크와 넓은 인터넷 간의 통신을 원활하게 돕는 도구로, 외부 자원 및 서비스에 접속할 수 있도록 합니다.\n\n## 18. Amazon RDS, DynamoDB 및 Redshift의 차이점은 무엇인가요?\n\nAmazon RDS (관계형 데이터베이스 서비스)는 MySQL, PostgreSQL, Oracle 및 SQL Server와 같은 관계형 데이터베이스를 실행하고 확장할 수 있도록 하는 관리형 서비스입니다. 자동화된 백업, 복제 및 패치 관리를 제공합니다.\n\nDynamoDB는 빠르고 원활한 확장 가능성을 제공하는 완전히 관리되는 NoSQL 데이터베이스 서비스로, 저 지연 시간 데이터 액세스를 요구하는 애플리케이션에 이상적입니다. 유연한 스키마 디자인과 수요에 따른 자동 스케일링을 제공합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nRedshift은 온라인 분석 처리(OLAP)를 위한 최적화된 완전히 관리되는 데이터 웨어하우징 서비스입니다. 대용량 데이터 세트의 고성능 쿼리 및 분석이 가능합니다. Redshift는 데이터 웨어하우징 및 분석 워크로드를 위해 설계되었으며 구조화된 데이터에 대한 SQL 기반 쿼리를 지원합니다.\n\n# 19. 웹 사이트를 S3에 호스팅하는 것을 선호하십니까? 그렇다면 이유가 무엇입니까?\n\n네, S3에 호스팅:\n\n- 비용 효율적: S3에 웹 사이트를 호스팅하는 것은 트래픽이 낮은 정적 웹 사이트의 경우 특히 비용 효율적입니다. 사용한 스토리지 및 데이터 전송에 대해서만 지불하면 됩니다.\n- 확장성: S3는 대량 트래픽을 처리하고 자동으로 확장될 수 있습니다. 소규모에서 중간 규모의 웹 사이트에 적합합니다.\n- 간편한 설정: S3에 정적 웹 사이트를 설정하는 것은 간단하며 AWS는 이 프로세스를 단순화하기 위한 도구를 제공합니다.\n- 보안: S3는 접근 권한에 대한 세밀한 제어를 허용하며 다른 AWS 서비스와 통합하여 추가 보안을 제공할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아니요, S3에 호스팅하지 마세요:\n\n- 동적 콘텐츠: 서버에서 생성된 동적 콘텐츠에 의존하는 웹 사이트의 경우, S3만으로는 적합하지 않습니다. 동적 요청을 처리하기 위해 웹 서버나 서버리스 아키텍처가 필요합니다.\n- 데이터베이스: 사용자 인증, 전자 상거래 기능 또는 콘텐츠 관리를 위해 데이터베이스가 필요한 경우, S3가 최적의 선택이 아닙니다. 더 포괄적인 호스팅 솔루션이 필요합니다.\n- 복잡성: 다양한 기능, 상호 작용 및 데이터베이스를 갖춘 복잡한 웹 사이트의 경우, S3만 사용하면 관리가 복잡해질 수 있으며 다른 호스팅 솔루션이 더 적합할 수 있습니다.\n\n# 20. AWS Lambda란 무엇이며 어떻게 작동합니까?\n\nAWS Lambda는 서버를 프로비저닝하거나 관리하지 않고 코드를 실행할 수 있는 서버리스 컴퓨팅 서비스입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이는 이벤트 기반 모델을 따릅니다. 여러분의 코드는 AWS 서비스 또는 사용자 지정 트리거로부터 발생하는 이벤트에 응답하여 실행됩니다.\n\nLambda 함수는 여러 프로그래밍 언어로 작성될 수 있으며 특정 이벤트를 처리하거나 특정 작업을 수행하기 위해 설계될 수 있습니다.\n\nLambda 함수는 자동으로 확장되며 병렬로 실행될 수 있어 가용성이 높고 효율적인 리소스 활용을 보장합니다. Lambda를 사용하면 코드에서 소비하는 컴퓨팅 시간만 지불하면 됩니다.\n\n# 21. VPC(Virtual Private Cloud) 및 그 구성 요소를 설명해주세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nVPC은 AWS 계정에 할당된 가상 네트워크로, AWS 클라우드의 논리적으로 격리된 영역을 제공합니다. 이를 통해 IP 주소 할당, 서브넷, 라우팅 테이블, 보안 그룹 및 네트워크 게이트웨이를 포함한 가상 네트워크 환경을 정의할 수 있습니다. VPC의 주요 구성 요소는 다음과 같습니다:\n\n- 서브넷: 자원을 프로비져닝할 수 있는 VPC 내의 IP 주소 세그먼트입니다.\n- 라우팅 테이블: 서브넷과 인터넷 간의 네트워크 트래픽 라우팅 규칙을 정의합니다.\n- 인터넷 게이트웨이: VPC 내의 인스턴스와 인터넷 간의 통신을 가능하게 합니다.\n- NAT 게이트웨이: 프라이빗 서브넷 내의 인스턴스가 안전하게 인터넷에 액세스할 수 있도록 합니다.\n- 보안 그룹: 인스턴스로의 들어오고 나가는 트래픽을 제어하는 가상 방화벽으로 작동합니다.\n- 네트워크 액세스 제어 목록(NACLs): 서브넷 수준에서의 네트워크 보안을 추가로 제어합니다.\n\n# 22. AWS DevOps 도구를 설명하여 클라우드에서 소프트웨어를 빌드하고 배포하는 방법을 설명하세요.\n\n클라우드에서 소프트웨어를 빌드하고 배포하기 위한 AWS DevOps 도구는 다음과 같습니다: -\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- AWS 클라우드 개발 키트: 인기 있는 프로그래밍 언어로 클라우드 애플리케이션 리소스를 모델링하고 프로비저닝하는 오픈 소스 소프트웨어 개발 프레임워크입니다.\n- AWS CodeBuild: 지속적으로 확장 가능한 다수의 빌드를 처리하고 코드를 테스트하는 지속적 인테그레이션 서비스입니다.\n- AWS CodeDeploy: Amazon EC2, AWS Fargate, AWS Lambda 등 선택할 수 있는 온프레미스 서버 중 하나로 소프트웨어 배포를 자동화하는 데 도움을 줍니다.\n- AWS CodePipeline: 지속적인 전달로 수신된 코드를 자동화하여 신속하고 정확한 업데이트를 수행합니다.\n- AWS CodeStar: AWS에서 애플리케이션을 개발, 빌드 및 배포하는 데 도움을 주는 사용자 인터페이스입니다.\n- AWS Device Farm: 다양한 모바일 장치 및 브라우저에서 애플리케이션을 테스트하는 플랫폼으로 작동합니다.\n\n# 23. 아마존의 이주 서비스에서 무엇이 제공됩니까?\n\n아마존은 다양한 이주 서비스를 제공합니다. 그것들은 다음과 같습니다: -\n\n- Amazon 데이터베이스 마이그레이션 서비스 (DMS)는 온프레미스 데이터베이스에서 아마존 웹 서비스 클라우드로 데이터를 매우 빠르게 마이그레이션하는 도구입니다. DMS는 온프레미스 및 클라우드에서 Oracle, SQL Server, MySQL 및 PostgreSQL 같은 RDBMS 시스템을 지원합니다.\n- Amazon 서버 마이그레이션 서비스 (SMS)는 온프레미스 워크로드를 아마존 웹 서비스 클라우드로 마이그레이션하는 데 도움을 줍니다. SMS는 클라이언트 서버 VMWare를 클라우드 기반 아마존 머신 이미지 (AMIs)로 마이그레이션합니다.\n- Amazon Snowball은 저 연결 환경에서 데이터 수집, 기계 학습, 처리 및 저장을 위한 데이터 전송 솔루션입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 24. Amazon에서 제공하는 메시징 서비스는 무엇인가요?\n\nAmazon은 여러 가지 메시징 서비스를 제공합니다. 그것들은 다음과 같습니다:\n\n- Amazon Simple Notification Service (SNS)은 AWS에 의해 완전히 관리되고 보안되며 사용 가능한 메시징 서비스로, 서버리스 애플리케이션, 마이크로서비스 및 분산 시스템을 디커플링하는 데 도움을 줍니다. SNS는 AWS 관리 콘솔이나 명령줄 인터페이스, 또는 소프트웨어 개발 키트에서 몇 분 내에 시작할 수 있습니다.\n- Amazon Simple Queue Service (SQS)는 서버리스 애플리케이션, 마이크로서비스 및 분산 시스템용으로 완전히 관리되는 메시지 대기열입니다. SQS FIFO의 장점은 이러한 종류의 메시징 서비스로 보내는 처리 시 단일 처리 및 정확한 순서를 보장합니다.\n- Amazon Simple Email Service (SES)는 클라우드 고객을 위해 SMTP 인터페이스를 통해 비공식적인, 통지 및 마케팅 대화를 위한 이메일 발송 및 수신 서비스를 제공합니다.\n\n# 25. 서브넷을 만드는 목적은 무엇인가요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n서브넷은 대규모 네트워크를 작은 네트워크로 분할하는 데 사용됩니다. 이는 트래픽을 라우팅하여 혼잡을 줄이며 성능을 크게 향상시킬 수 있습니다.\n\n# Elastic Beanstalk이란?\n\nElastic Beanstalk은 AWS의 오케스트레이션 서비스로, EC2, S3, Simple Notification Service, CloudWatch, 오토스케일링 및 Elastic Load Balancer와 같은 다양한 AWS 응용 프로그램에서 사용됩니다.\n\nAWS Management Console, Git 저장소 또는 통합 개발 환경(IDE)을 사용하여 AWS에 애플리케이션을 배포하는 가장 빠르고 간단한 방법입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 27. 클라우드프론트에서 지오 제약이란 무엇인가요?\n\n지오 제약은 클라우드프론트 웹 유통을 통해 제공되는 콘텐츠에 특정 지리적 위치에 있는 사용자가 액세스하는 것을 방지하는 방법으로, 일반적으로 지오 차단으로도 알려져 있습니다.\n\n# 28. Amazon ElastiCache의 사용 목적은 무엇인가요?\n\nAmazon ElastiCache는 클라우드에서 인메모리 데이터 저장소 또는 캐시를 쉽게 배포, 운영 및 확장할 수 있게 해주는 웹 서비스입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 29. 인스턴스를 중지와 종료하는 것을 구별해보세요.\n\n인스턴스를 중지할 때, 인스턴스는 정상적인 종료를 수행한 후 중지된 상태로 전환됩니다.\n\n인스턴스를 종료할 때, 인스턴스는 정상적인 종료를 수행합니다. 그리고 연결된 Amazon EBS 볼륨은 deleteOnTermination 속성이 false로 설정되어 있지 않는 한 삭제됩니다.\n\n# 30. 인기 있는 데브옵스 도구는 무엇인가요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n인기 있는 DevOps 도구는 다음과 같습니다:\n\n- Chef, Puppet, Ansible, 그리고 SaltStack — 배포 및 구성 관리 도구\n- Docker — 컨테이너화 도구\n- Git — 버전 관리 시스템 도구\n- Jenkins — 지속적 통합 도구\n- Nagios — 지속적 모니터링 도구\n- Selenium — 지속적 테스트 도구\n\n# 31. 아마존 클라우드 서치의 기능은 무엇인가요?\n\n아마존 클라우드 서치의 기능은:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 자동완성 제안\n- 부울 검색\n- 전체 텍스트 검색\n- Faceting 용어 부스팅\n- 강조\n- 접두어 검색\n- 범위 검색\n\n**32. AWS의 EBS에서 데이터에 어떻게 액세스하나요?**\n\nAWS의 EBS에서는 그래픽 인터페이스를 통해 데이터에 직접 액세스할 수 없습니다. 이 과정에는 EBS 볼륨을 EC2 인스턴스에 할당하는 과정이 포함됩니다.\n\n여기서, 볼륨이 인스턴스 중 하나와 연결되면(윈도우 또는 유닉스), 해당 볼륨에 데이터를 쓰거나 읽을 수 있습니다. 먼저, 데이터가 있는 볼륨에서 스크린샷을 찍고 이를 활용하여 고유한 볼륨을 작성할 수 있습니다. 여기서, 각 EBS 볼륨은 단일 인스턴스에만 연결될 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 33. AWS autoscaling에서 라이프사이클 후크란 무엇인가요?\n\n라이프사이클 후크는 autoscaling 그룹에 추가할 수 있습니다. 이를 통해 autoscaling 그룹이 인스턴스를 종료하고 시작할 때 일시 중지하여 사용자 정의 작업을 수행할 수 있습니다. 모든 오토 스케일링 그룹에는 여러 개의 라이프사이클 후크가 포함되어 있습니다.\n\n## 34. 하이퍼바이저란 무엇인가요?\n\n하이퍼바이저는 가상 머신을 생성하고 실행하는 데 사용되는 소프트웨어입니다. 물리적 하드웨어 리소스를 각 사용자에게 가상적으로 분배하는 플랫폼으로 통합됩니다. 하이퍼바이저에는 Oracle Virtual Box, Oracle VM for x86, VMware Fusion, VMware Workstation 및 Solaris Zones가 포함됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 35. AWS CloudTrail의 역할을 설명해주세요.\n\nAWS CloudTrail는 API 호출의 행동을 모니터링하고 감사하기 위해 설계된 서비스입니다. AWS CloudTrail을 사용하면 사용자는 AWS 인프라를 다루는 작업과 관련된 계정 활동을 모니터링하고 보관할 수 있습니다.\n\n# 36. Amazon Route 53을 설명해주세요.\n\nAmazon Route 53은 확장 가능하고 고가용성을 갖춘 도메인 네임 시스템(DNS)으로 정의됩니다. 이는 개발자와 기업의 이익을 위해 설계되었으며, 인터넷 애플리케이션으로 최종 사용자를 연결하기 위해 이름을 번역하는 가장 신뢰할 수 있고 비용 효율적인 프로세스입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 37. S3 요금을 결정하는 매개변수는 무엇인가요?\n\n아래는 S3 요금을 결정하는 매개변수입니다:\n\n- 전송 가속\n- 요청 횟수\n- 저장 관리\n- 데이터 전송\n- 사용된 저장소\n\n# 38. 다양한 종류의 인스턴스를 말해보세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음은 다양한 인스턴스 유형입니다:\n\n- Memory-optimized\n- Accelerated computing\n- Computer-optimized\n- General-purpose\n- Storage optimize\n\n39. RDS에서의 데이터베이스 유형을 나열해보세요.\n\n다음은 RDS에서 지원하는 데이터베이스 유형입니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- MYSQL 서버\n- PostgreSQL\n- SQL Server\n- Aurora\n- Oracle\n- MariaDB\n\n## 40. 클라우드워치란 무엇인가요?\n\nAmazon CloudWatch은 메트릭 저장소입니다. 이를 사용하여 애플리케이션, 인프라 및 서비스를 모니터링할 수 있습니다. 또한 알람, 로그 및 이벤트 데이터를 활용하여 자동화된 작업을 수행하고 해결 시간을 단축할 수 있습니다.\n\n## 41. AWS의 키페어란 무엇인가요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n키 쌍은 공개 키와 개인 키로 구성되며, 가상 머신에 대한 안전한 로그인 정보입니다. Amazon EC2는 공개 키를 저장하고, 당신은 개인 키를 가질 수 있습니다.\n\n---\n\n_의견은 언제나 환영합니다._\n\n~페이살 쿠잔\n","ogImage":{"url":"/assets/img/2024-06-19-DAY_2590INTERVIEWQUESTIONSONAWS_0.png"},"coverImage":"/assets/img/2024-06-19-DAY_2590INTERVIEWQUESTIONSONAWS_0.png","tag":["Tech"],"readingTime":27},{"title":"파이테스트Pytest와 파이스파크PySpark를 사용한 데이터 품질 유효성 검사를 위한 4가지 팁","description":"","date":"2024-06-19 12:01","slug":"2024-06-19-4TipsforDataQualityValidationswithPytestandPySpark","content":"\n## 높은 품질과 신뢰할 수 있는 결과를 얻기 위한 변환된 데이터 테스트\n\n이 문서는 Likitha Lokesh와의 협력으로 작성되었습니다.\n\n![이미지](/assets/img/2024-06-19-4TipsforDataQualityValidationswithPytestandPySpark_0.png)\n\n## 배경\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저는 최근 데이터 소프트웨어 프로젝트에 품질 엔지니어로 참여했는데, 여기서는 변환된 데이터에 대한 많은 테스트가 필요했습니다. 이 프로젝트에서는 데이터를 한 Amazon S3 버킷에서 다른 버킷으로 변환하기 위해 AWS Glue를 사용했습니다. 데이터는 Python을 사용하여 PySpark를 통해 변환되었고, 따라서 이러한 변환을 테스트하기 위한 테스트 자동화 프레임워크는 동일한 기술 스택에 의존했지만 Pytest도 추가되어 일관성을 유지하려고 노력했습니다.\n\nPytest, PySpark 및 AWS로 시작하는 방법에 대해 자세히 알아보려면 제 동료 Likitha Lokesh가 작성한 멋진 블로그를 확인해보세요.\n\n## 소개\n\n상기 프로젝트에서 우리 팀은 데이터를 제3자 소프트웨어 도구에서 소화되도록 변환했습니다. 데이터를 성공적으로 가져오기 위해 각 대상 파일에는 요구 사항 목록이 있었습니다. 각 대상 파일은 요구 사항을 충족해야만 소프트웨어가 데이터를 수용하고 데이터가 분석용으로 액세스 가능하지 않을 것이라는 문제를 방지할 수 있었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n목록에 나열된 요구 사항은 소스 파일에서 대상 파일로 데이터를 변환하는 데 필요한 스크립트가 어떻게 보이는지를 팀이 판단하는 데 도움을 주었지만, 모든 대상 파일의 데이터가 모든 요구 사항을 충족할 것을 보장하지는 않았습니다.\n\n데이터의 불일치는 데이터를 분석하거나 다른 목적으로 사용할 때 결과가 왜곡되는 원인이 될 수 있습니다. 이 프로젝트에서는 금융 데이터를 사용했기 때문에 데이터에 대한 신뢰 수준이 절대적으로 중요했습니다.\n\n따라서 다음과 같은 질문이 제기됩니다:\n\n모든 데이터 소프트웨어 프로젝트 솔루션은 일반적으로 맞춤형이 아니지만, 이 프로젝트에서 습득한 몇 가지 기술은 다양한 데이터 관련 프로젝트에서 효율적인 엔지니어링과 사고 과정에 도움이 될 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 경험에서 데이터 품질 테스트를 위한 네 가지 주요 요점 목록을 만들었습니다:\n\n- 잘못된 데이터를 기록할 조건부로 단언을 감싸기\n- 공통 데이터 테스트 결정하고 매개변수화하기\n- 알려진 데이터 문제에 대한 Pytest 경고 및 XFail 활용하기\n- 환경 변수를 -E 플래그로 관리하기\n\n이 문서에서 네 가지 요점에 대해 각각 설명하고, 각 요점이 목록에 포함된 이유를 강조하겠습니다.\n\n## 단언을 조건부로 감싸기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n전통 소프트웨어 프로젝트에서 자동화 테스트를 수행할 때, 버그에 대한 가시성은 디버깅 데이터보다 약간 더 명확합니다. 전통적인 소프트웨어 프로젝트나 애플리케이션에서는 앱을 열어 검사하거나 API를 검토할 수 있지만 데이터는 매우 많을 수 있습니다. PySpark에서 데이터 문제에 대한 가시성을 얻기 위한 돋보기는 데이터프레임입니다.\n\n제 프로젝트에서는 .csv 파일의 데이터를 테스트했습니다. 많은 테스트가 동일한 개요를 가지고 있었습니다:\n\n- .csv 파일을 읽어 데이터프레임 만들기\n- 데이터를 분석하기 위해 데이터프레임 메서드 사용(요구 사항에 따라)\n- 단언을 조건부로 래핑하기\n\n가령 파일의 한 열에는 ZIP 코드 데이터가 있고 요구 사항이 각 값이 정확히 5자여야 한다면, 해당 테스트는 다음과 같을 것입니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nimport length\nimport logging\n\ndef test_zipcode_data_length(spark_source, csv_file_path: str):\n\n  ## .csv 파일을 읽고 DataFrame을 생성합니다.\n  dataframe = spark_source.read.csv(csv_file_path)\n\n  ## DF에서 filter 메소드를 사용하여 열 값 분석하고\n  ## (다른 DF를 만듭니다)\n  invalid_rows = dataframe.filter(length(dataframe['Zipcode']) != 5)\n\n  ## 디버깅 및 정확한 위치를 찾기 위해 조건부로 Assertion을 감싸세요\n  if invalid_rows.count() == 0:\n    logging.info(\"예상대로 'Zipcode' 열의 모든 값이 5의 길이와 동일합니다!\")\n    assert True\n  else:\n    logging.error(\"'Zipcode' 열의 값은 모두 5의 길이와 동일해야 하지만\n    예상과 다른 값이 존재합니다!\")\n  ## 요구 조건을 충족시키지 못하는 행이 포함된 필터링된 DF를 출력합니다\n    invalid_rows.show(truncate=False)\n    assert False\n```\n\n참고: 기사 전체에 코드 조각이 많습니다. 테스트 메소드 간 코드 중복을 줄이기 위해 테스트 도우미 함수를 사용하는 것이 best practice이지만, 이 기사의 목적에서는 벗어납니다.\n\n위의 예제에서 볼 수 있듯이, 단순한 True/False 어서션이 아니라 실패 시 적절한 로깅을 위해 조건부로 어서션을 배치하여 데이터가 기대에 충족되지 않을 경우 디버깅 및 특정 데이터 위치를 찾기 위해 필요한 기능이 수행됩니다. 잘못된 행이 포함된 DataFrame은 파일을 소프트웨어가 처리하려면 수정해야 할 데이터 위치를 특정하게 알려줄 수 있습니다.\n\n특정 열마다 모든 값이 정확히 5의 길이여야 하는 경우를 보여준 예제였지만, 테스트의 일반적인 개요/흐름의 원칙은 동일합니다. Assertion을 조건부로 감싸지 않고 다른 옵션은 무엇인가요? 변환된 .csv 파일을 다운로드하고 수동으로 검토하거나 필터링하여 오류 행을 찾을까요? 그것은 매우 흥미로운 옵션이 아닙니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n무엇을 테스트하든간에, 실패의 근본 원인을 빠르게 평가해야 하는 필요성은 항상 품질 테스트 전략의 구성 요소가 될 것입니다. 단언문을 조건문으로 감싸는 것은 그 필요에 대한 해답을 제공합니다. 조건문으로 단언을 감싸는 자동화된 접근은 효율적이며 데이터 관련 문제를 신속하게 다루는 실패 빠른 접근법을 제공합니다. 이 방식은 많은 짐작을 제거하고 시스템/파이프라인의 품질을 유지하거나 개선하는 데 필요한 구체적인 정보를 제공합니다.\n\n## 일반 데이터 테스트를 매개변수화 하기\n\n데이터는 방대하기 때문에 혐이 일 수 있지만, 테스트할 때는 일반적으로 모호함이 적습니다. 요구 사항은 매우 명확하며, 제 경험상 전통적인 소프트웨어 프로젝트보다 수집하기 쉽습니다. 종종 일반적인 데이터 요구 사항은 서로 다른 데이터 세트 간에 겹칠 수 있습니다.\n\n제 프로젝트의 경우, 생성되어야 했던 대상 파일 중 많은 파일들이 서로 다른 파일에 대해 유사한 요구 사항을 가지고 있었으며, 심지어 동일한 파일 내의 다른 열도 동일한 요구 사항을 가졌습니다. 간단히 유지하기 위해 각 파일이 데이터를 포함해야 한다는 요구 사항이 하나 있었는데, 이는 명백한 요구 사항처럼 보일 수 있지만 모든 파일에서 실행할 수 있는 매우 쉽고 빠른 자동화된 테스트이며, 예상치 못한 가장자리 경우의 데이터 변환 시나리오에서 유용할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여기서 가장 좋은 방법은 모든 대상 파일마다 동일한 간단한 테스트를 작성하지 않아도 되는 방법이 무엇인가요? 어떻게 코드 재사용성을 최대화할 수 있을까요? 답은 Pytest의 Parametrize 표시를 사용하여 테스트를 매개변수화하는 것이었습니다.\n\n```python\nimport pytest\n\n@pytest.mark.parametrize(VALUES HERE)\ndef test_data_present(spark_source, csv_file_path: str):\n\n  ## .csv 파일을 읽고 DataFrame 생성\n  dataframe = spark_source.read.csv(csv_file_path)\n\n  ## DF가 비어 있지 않은지 확인\n  assert dataframe.first() is not None\n```\n\nPytest의 parametrize 표시를 통해 모든 대상 파일을이 동일한 테스트를 통해 실행하여 생성되는 각 파일에 최소한 어떤 종류의 데이터가 포함되어 있는지 확인할 수 있습니다. 이전 프로젝트에서 추가 쉼표 구분 기호의 데이터 내 포함 또는 고유 데이터 필요 열을 확인할 때 특히 중요한 몇 가지 경우가 있었습니다.\n\n이 경우에 유의해야 할 점은 테스트 시나리오를 정의하는 초기 단계에서 노력이 더 필요할 수 있다는 것입니다. 공통 요구 사항을 찾고 코드를 재사용하는 최상의 전략을 고민하는 것입니다. 그러나 장기적으로 테스트 개발이 지수적으로 가속화될 것입니다. 이 경험에서 배운 점은 요구 사항을 더 잘 이해하고 먼저 이러한 요구 사항의 공통점을 파악해야 한다는 것이었습니다. — 테스트를 개발하기 전에.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n요구 사항에 따라 생성 될 다양한 유형의 테스트 계획을 작성합니다. 데이터 유형, uniqueness, formatting, 추가 구분 기호 없음/데이터 내에서 적절한 열 구분이 유효성을 검사하도록 테스트 계획을 분석하고 가능한 한 테스트를 통합하려고 노력합니다. 요구 사항에서 패턴을 파악하고 테스트를 개발하기 전에 더 강력한 계획을 수립하는 것은 개발 속도 및 테스트 실행 속도를 높이는 데 도움이 됩니다.\n\n## 경고 및 XFail 활용\n\n데이터와 상호 작용할 때, 특히 민감한 데이터(예: 금융 데이터)를 사용하는 새 소프트웨어를 개발할 때는 종종 실제 데이터와 상호 작용하기 전에 먼저 낮은 환경에서 (예: 개발/테스트 환경) 시험적으로 개발됩니다. 이 과정은 개발 중에 모든 결함이 해결되는 동안 실제 데이터(프로덕션)를 보호하는 데 도움이 됩니다. 그러나 비프로덕션 환경 데이터의 관리 오류로 인해 데이터 관리가 어려워지고 결과가 왜곡될 수 있습니다.\n\n비프로덕션 환경 데이터의 관리 오류는 해결하기 어렵고 결과를 왜곡시킬 수 있습니다. 다행히도 Pytest에 내장된 두 가지 기능인 Pytest Warnings와 Pytest XFail을 활용하면 알려진 데이터 문제를 테스트하는데 도움을 받을 수 있습니다. 이 두 옵션 중에서 선호도나 권장사항이 없습니다. 상황에 가장 적합한 도구를 선택하십시오.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 전문에 나온 제안 중 첫 번째 제안을 이미 구현 중이거나 구현할 예정이라면, 당신은 쉽게 Pytest 경고를 동일한 개념에 임베딩할 수 있습니다. 여기서의 차이점은 거짓 주장 대신 경고가 발생할 것이랍니다. 아래와 같이 보일 거에요:\n\n```js\nimport warnings\nimport logging\n\ndef test_email_data_unique(spark_source, csv_file_path: str):\n\n  ## Read the .csv file and Create a DF\n  dataframe = spark_source.read.csv(csv_file_path)\n\n  ## Use the count method on DF to capture the number of total rows\n  num_rows = dataframe.count()\n\n  ## Use the select method - paired with the distinct and count methods\n  ## on DF to analyze column values for uniqueness\n  num_unique_rows = dataframe.select(dataframe['Email'].distinct().count())\n\n  ## Wrap Assertion in a Conditional and Leverage WARNINGS\n  if num_rows == num_unique_rows:\n    logging.info(\"All of the values in the 'Email' column are unique\n    as expected!\")\n    assert True\n  else:\n  ## Print the rows that don't meet the requirements\n    dataframe.groupBy(dataframe['Email']).count().where(\"count > 1\").drop(\n    \"count\").show(truncate=False)\n  ## Warn instead of fail\n    warnings.warn(UserWarning(\"Some of the data in the 'Email' column is\n    not meeting the uniqueness requirement!\")\n```\n\n품질 엔지니어로서, 빨간색은 주의가 필요한 것을 나타냅니다. 알려진 문제에 대해 경고를 사용하는 가장 좋은 점은 '뉴트럴'에서 출력되기 때문에 \"이것은 알려진 사항이며 즉시 주의가 필요하지 않거나 걱정할 필요가 없습니다\"라는 메시지를 전달해준다는 점이었습니다. 이 메시지는 테스트 스위트를 실행할 때 다른 기여자들에게도 전달되어, 노력을 더이상 메신저로 행동하지 않고 팀의 속도에 집중하는 데 도움이 됩니다.\n\n알려진 데이터 문제를 다룰 수 있는 또 다른 좋은 옵션은 Pytest XFail 표시입니다. Pytest Warnings 능력과 유사하게, 테스트가 실패하면 결과가 빨강색 대신 노란색으로 나올 것입니다. 특히 적용 가능한 경우, 빨간색이 아닌 다른 색상으로 인사를 받는 것이 얼마나 유용한지 이중으로 강조할 수 없습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위 스크린샷을 보면 'XFail'이라는 테스트가 노란색 'x'로 실행되었음을 나타낼 것입니다. 그러나 'XFail' 표시는 테스트의 어설션 섹션에 표시되지 않습니다. 'XFail'은 이전 섹션에서 테스트를 표시하는 방법과 유사하게 함수 상단에 표시됩니다. 아래 'XFail' 구현 내용을 확인해보세요:\n\n```js\nimport pytest\n\n@pytest.mark.xfail(reason=\"알려진 데이터 문제로 임시로 실패하는 것으로 예상됨\")\ndef test_date_format():\n\n## 나머지 테스트 내용\n```\n\n앞서 살펴본 경고 옵션처럼 이 유용한 'XFail' 표시는 품질 엔지니어가 적절한 문서 작성을 하고 동료에게 컨텍스트 정보를 남길 수 있도록 도와줍니다. 'XFail'의 중요한 추가 혜택 중 하나는 'XFail'로 표시된 테스트가 예상대로 실패하는 경우 (즉, 버그 수정이 해결된 경우)에 테스트가 실패하므로 품질 엔지니어는 이제 테스트를 수정/변경해야 한다는 것을 알 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n주의해서 사용해주세요: 특정 프로젝트 요구 사항에 가장 적합한 경우/방법/이유를 고려해주세요. 예상치 못한 데이터의 불일치 사항을 확인한 후에만,\n\n- 실패의 근본 원인을 확인한 후에\n- 팀과 함께 실패의 우선 순위/심각성을 평가한 후에\n\nPytest의 이러한 기능을 활용해볼 수 있습니다.\n\n다른 한편으로, YELLOW 플래그로 특정 테스트를 지정할 수 있는 옵션을 가지고 있는 것은 필요한 자동화된 테스트가 문서화되어 테스트 스위트에 있고, 프로젝트가 제작으로 나아갈수록, 희망컨대 데이터 문제가 더 이상 발생하지 않는 환경에서 접근 가능하게끔 해줍니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 동적으로 환경 변수 관리하기\n\n네 키 포인트를 마무리하며, 다양한 환경 간 데이터 테스트의 세밀함에 대해 계속 다룰 것입니다. 이 기사의 시작 부분에서는 테스트 중인 데이터가 Amazon S3 버킷에 호스팅되어 있다고 언급했었습니다. 버킷 이름과 경로는 리포지토리의 INI 구성 파일에 나열되어 있었고, 다양한 테스트에 공급되었는데, 그러나 환경에 따라 약간 변경된 버킷 이름이 있었습니다.\n\n```js\n[BUCKET]\nS3 = my-dev-environment-bucket\n\n[PATH]\nFILE-PATH = pathway/to/dev/environment\n```\n\n버킷 이름과 해당 경로의 변종은 각 테스트 세션마다 터미널에서 동적으로 관리할 것이며, 이렇게 해서 Pytest의 -E 플래그가 유용하게 사용되었습니다. 픽스처와 pytest_addoption 함수를 사용하여 원하는 환경을 -E 플래그로 지정하고 표준 Pytest 명령에 따라 각 테스트 실행마다 환경을 전환시킬 수 있었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nINI 파일은 하드 코딩된 변수에서 약간 변형되었지만, 테스트에 전달되는 변수 이름에는 영향을 주지 않았기 때문에 이 조정은 테스트에 매우 낮은 영향을 미쳤습니다. 그런 다음 INI 파일 자체가 각 테스트 실행 중 임시 템플릿이 되었고, 테스트 실행 완료 후 복원되었습니다. 변형은 다음과 같았습니다:\n\n```js\n[BUCKET]\nS3 = my-{env}-environment-bucket\n\n[PATH]\nFILE-PATH = pathway/to/{env}/environment\n```\n\nINI 파일에 대한 이 조정과 테스트 세션 중 파일을 관리하는 몇 가지 방법과 함께, 필요한 환경에 따라 pytest -E=dev 또는 pytest -E=qc 또는 pytest -E=prod와 같은 명령이 되었습니다. 이 변경으로 인해 환경간 전환의 복잜한 점 때문에 버킷 이름이 변하는 것이 매우 간단해졌습니다. 이제 더 이상 특정 환경에서 테스트 실행을 수행하려면 INI 파일의 변수 이름을 변경하는 것을 매번 기억해야 했던 의존성이 없어졌습니다. 액세스 권한이 있는 모든 팀원이 이제 명령줄에서 쉽게 환경 간 전환을 할 수 있습니다.\n\nINI 파일에서 이 유연성을 어떻게 구현하는지에 대해 자세히 알아보려면, 여기에서 내 How-To 기사를 확인해주세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 마무리 생각\n\n빠르게 복습해보면, 이 글에서 강조한 데이터 품질 테스트의 네 가지 주요 포인트는 다음과 같습니다:\n\n- 로그에 잘못된 데이터를 기록하기 위해 어설션을 조건문으로 래핑\n- 일반적인 데이터 테스트를 결정하고 매개변수화\n- 알려진 데이터 걱정 사항에 대해 Pytest Warnings와 XFail 활용\n- -E 플래그로 환경 변수 관리\n\n이러한 전략들을 통해 변환된 데이터의 품질에 대한 신뢰 수준을 높이는 것이 전반적인 목표입니다. 이러한 포인트들이 유익했고 다음 데이터 프로젝트에서 유용한 팁과 전략을 얻을 수 있었으면 좋겠습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n제안 사항에 대한 피드백을 알고 싶어요. 언제든지 댓글로 의견을 남겨주세요!\n\n#QE4DE\n\n## 자료\n\n- AWS Glue 정보\n- Amazon S3 정보\n- PySpark 문서\n- Pytest 문서\n- Likitha Lokesh의 PySpark, Pytest, Amazon S3 시작하기\n- PySpark 데이터프레임\n- Pytest 파라미터화\n- Pytest 경고\n- Pytest 실패 예상\n- Pytest -E 플래그\n- Taylor Wagner의 INI 파일 변수 조작 방법\n","ogImage":{"url":"/assets/img/2024-06-19-4TipsforDataQualityValidationswithPytestandPySpark_0.png"},"coverImage":"/assets/img/2024-06-19-4TipsforDataQualityValidationswithPytestandPySpark_0.png","tag":["Tech"],"readingTime":14},{"title":"AWS 프로젝트 시간 예측 그건 그냥 제안일 뿐이에요","description":"","date":"2024-06-19 12:00","slug":"2024-06-19-ThoseAWSProjectTimeEstimatesHoneyThatsJustaSuggestion","content":"\nAWS 프로젝트 지침을 따르는 것은 할머니의 전설적인 초콜릿 칩 쿠키 레시피를 따르는 것과 같아. 낡은 인덱스 카드에는 \"12분 동안 굽다\"고 적혀 있을지도 모르지만, 우리는 다들 할머니가 영혼으로 측정한 게 분량 컵이 아니란 걸 알아. 클라우드에서 무언가를 구축할 때는 항상 제안된 시간보다 오래 코드 속에 팔 다쳐 있을 수밖에 없어.\n\n이런 이유로 나, 당신의 클라우드 전문가이자 친구인 쉐이가 여기 있어서 조언하려고 해: 그 프로젝트 시간 추정치는 실은 지침일 뿐이지, 신약의 진리는 아니라는 거야.\n\n특히 머신 러닝에 관한 이야기일 때 말이야!\n\n![/assets/img/2024-06-19-ThoseAWSProjectTimeEstimatesHoneyThatsJustaSuggestion_0.png]\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n내 목표는 머신러닝에 초점을 맞춘 클라우드 어드보케이트가 되는 것입니다. 그래서 매일 한 프로젝트를 다루고 그 달콤한 (가끔은 조금 탄) 여정을 문서화하고 있어요.\n\n오늘의 프로젝트? 머신러닝 모델을 실시간 추론 엔드포인트에 배포하는 것이죠.\n\n![image](/assets/img/2024-06-19-ThoseAWSProjectTimeEstimatesHoneyThatsJustaSuggestion_1.png)\n\n쉽죠? 이게요, 상상해보세요: 재료 구비는 끝났지만, 그런데 여러분이 하나 중요한 재료를 놓치고 있는 걸 깨달았다는 거죠 — 이해력!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여기서 제 빵 만들기 경험에서 배운 것들이 있어요:\n\n- 콘솔 변화: 할머니가 가끔 가장 좋아하는 주걱을 숨기는 것처럼, AWS 도구들은 종종 콘솔에서 자리를 옮기곤 해요. 한 분 동안 \"엔드포인트 생성\"이 여기 있었던 걸 분명 보았다고 생각하더니도 이젠 사라진 것 같아요! 걱정 마세요, 여기서 아마존 Q(AWS 내장 AI 챗봇)가 당신의 가장 친한 친구가 됩니다. 결국 그 빠진 도구는 전혀 다른 페이지에 숨어 있었던 거예요! 와, 여기 있네요! 이 예상치 못한 우회로로 +15분을 더하면 됩니다.\n- 문서 작성은 장식하기와 같아요: 제는 메모를 작성하고 어리버리한 비유를 만들며 다이어그램을 그리는 것을 좋아해요. 이것은 마치 과자에 장식을 하는 것 같아요 – 이런 방식으로 제가 더 잘 기억하고 전체 과정을 더 재미있게 만들어요! 하지만 장식하는 것처럼, 문서 작성은 프로젝트에 추가로 +30분이 걸려요. . . 어쨌든\n- 혼란스러운 개념? 심층 탐구 시간! 가끔 기술 용어가 전혀 이해가 되지 않을 때가 있어요. 그럴 땐 제 비밀 무기인 ChatGPT를 꺼내볼게요. 이 도구는 복잡한 개념을 예시 사용 사례와 함께 작은 조각으로 나눠줘요. 추가로 +45분을 더하게 되죠! (진짜로, 때로는 가장 좋은 학습이 호기심의 토끼 굴 속에서 일어나요).\n\n<img src=\"/assets/img/2024-06-19-ThoseAWSProjectTimeEstimatesHoneyThatsJustaSuggestion_2.png\" />\n\n최종 판정: 성공, 그리고 여분의 시간 한 잔 같이요\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n프로젝트가 마침내 성공을 거두었어요! 내 모델을 배포했고, 많은 것을 배웠으며, 애매한 클라우드 개념을 이해하는 새로운 방법을 발견하기도 했어요. 하지만 여기서 중요한 점은 이겁니다: 프로젝트가 예상 시간보다 오래 걸린다고 좌절하지 마세요. 뜻밖의 학습 모험을 포용하고, 기억하세요, 가장 맛있는 쿠키(그리고 가장 멋진 머신 러닝 프로젝트)은 종종 좀 더 구워야 할 때 더 맛있어져요.\n\n그래서 다음에 AWS 프로젝트 예상을 보게 된다면, 한 줌의 소금과 미소와 함께 받아들이세요. 예상치 못한(그리고 교육적인) 경험이 기다리고 있을지도 몰라요!\n\nInstagram/TikTok에서 더 많은 콘텐츠를 만나보세요:\n\n@ShaeInTheCloud\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nLinkedIn:\n\n[데샤이 리다 프로필](https://www.linkedin.com/in/deshae-lyda/)\n\n#MachineLearning #AWS #CloudDeveloperAdvocate #CloudEngineer\n","ogImage":{"url":"/assets/img/2024-06-19-ThoseAWSProjectTimeEstimatesHoneyThatsJustaSuggestion_0.png"},"coverImage":"/assets/img/2024-06-19-ThoseAWSProjectTimeEstimatesHoneyThatsJustaSuggestion_0.png","tag":["Tech"],"readingTime":4},{"title":"구글 드라이브를 무료 클라우드 저장 공간 솔루션으로 활용하여 머신 러닝 데이터 동기화를 자동화하는 방법","description":"","date":"2024-06-19 11:59","slug":"2024-06-19-HowdidIuseGoogleDriveasafreecloudstoragesolutiontoautomatesyncingmyMachineLearningdata","content":"\nGoogle Drive은 문서와 미디어를 저장하는 데 탁월한 도구이지만, 상상해보세요: 어떻게 하면 앱의 데이터를 저장하는 데 사용할 수 있을까요? 네, 저도 구름에 멀티플레이어 게임 데이터를 안전하고 무료로 저장하는 방법을 고민하고 있었습니다. 이 기사에서는 기계 학습을 위해 게임 데이터를 Google Drive에 저장한 방법에 대해 설명하겠습니다.\n\n![이미지가 여기에 표시됩니다.](/assets/img/2024-06-19-HowdidIuseGoogleDriveasafreecloudstoragesolutiontoautomatesyncingmyMachineLearningdata_0.png)\n\n📢 안녕하세요, 이 기사에서 언급된 서비스 중 어느 것도 스폰서로서 제작되지 않았습니다. 제가 애플리케이션에서 직접 사용해보며 개발자로서의 경험을 공유하고자 합니다.\n\n📢 이 기사는 구글 서비스와의 인증을 위해 서비스 계정을 사용하는 데 어느 정도 익숙한 것으로 가정합니다. 서비스 계정 및 해당 링크를 통해 어떻게 생성하는지에 대해 더 알아볼 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 🤔 왜 구글 드라이브를 사용하게 된 걸까요?\n\n\"The Strategists\"의 승자를 예측하기 위한 머신 러닝 모델을 개발하는 도중, 모든 게임 데이터를 로컬 머신에 저장했습니다. 그 당시에는 그 방식이 합리적으로 느껴졌지만, 도커를 사용하여 게임을 컨테이너화하고 클라우드에 배포하기 시작하면서 몇 가지 의문이 생겼습니다.\n\n훈련된 모델을 도커 이미지에 포함해야 할까요? 게임을 한 번씩 진행할 때마다 모델을 다시 훈련하기 때문에 게임 데이터를 도커 이미지에 포함해야 할까요? 게임 데이터를 도커 이미지에 저장하는 것이 안전한 일일까요? 이러한 질문들을 고민하면서, 보안 위험이 있기 때문에 모델과 게임 데이터를 함께 도커 이미지에 포함시키지 말아야겠다는 결론에 도달했습니다.\n\n그래도 \"The Strategists\"를 배포할 때, 모든 게임 데이터와 예측 모델을 백엔드 도커 이미지에 포장해서 배포했습니다. 배포된 컨테이너에서 주기적으로 새로운 게임 데이터를 추출하는 아이디어도 고안했었죠. 이미 알 수 있겠지만, 이는 확장 가능한 해결책이 아니었습니다. 배포 단계에서 모델을 포장하지 않고 프로그래밍적으로 게임 데이터를 다운로드하고 업로드하며 훈련된 모델을 내보내야 한다는 것을 알았습니다. 그렇다면 어떻게 해야 할까요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이번 사용 사례에서는 Amazon S3 및 Google Cloud Storage와 같은 서비스를 탐색해 보았어요. 이전 글을 읽은 분들은 저의 의도를 알 거예요. 요금을 청구하지 않는 서비스를 찾았고, 호기심 많은 개발자로서 Google Drive를 사용하기로 결정했어요. Google Drive API를 사용해보고 싶었는데, 이는 Google Drive를 애플리케이션의 데이터 저장소로 사용하기 위한 기능을 프로토타입화하는 완벽한 기회였어요.\n\nGoogle Drive를 사용하여 프로덕션에 준비된 애플리케이션을 개발하는 것은 표준 산업 관행이 아니라는 점을 강조해야 해요. Amazon S3와 같은 서비스는 오브젝트 잠금 및 ID 및 액세스 관리를 포함한 더 넓은 범위의 기능을 제공해요. 게다가, Google Drive의 무료 계층은 15GB의 저장 공간으로 제한되어 있어요.\n\n# 🛠️ 게임 데이터 동기화 구현은 어떻게 이루어졌을까요?\n\n우선, 제가 어떻게 게임 데이터를 동기화하는지에 대해 이야기해볼게요. 제 로컬 설정에서는 The Strategists의 머신 러닝 워크플로를 설명해서 서버 시작 시 모델을 훈련시킨 다음, SpringBoot 기반의 백엔드 서비스는 각 게임 세션 후에 다시 훈련시켰어요. 이 훈련은 플레이어 투자 패턴을 CSV 파일로 내보낸 다음, 예측 모델 디렉토리에 게임 상태를 내보낸 후에 발생했어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n데이터 내보내기 디렉토리에는 내보낸 CSV 파일이 모두 저장되어 있었기 때문에 훈련 스크립트는 이 데이터를 모두 로드하고 해당 데이터를 사용하여 모델을 훈련했습니다. 첫 번째 과제는 서버가 시작될 때 이 디렉토리를 채우는 것이었습니다. 훈련 스크립트가 예측 모델을 내보내기 위한 작업이 가능하도록 하려면 구글 드라이브 폴더에 있는 기존 CSV 파일을 업로드했습니다. 이 \"Downloads\" 폴더는 이제 게임 서버에서 사용 가능한 게임 데이터를 찾기 위해 참조되는 진실의 원천으로 제공됩니다.\n\n이 과제에 대처하기 위해 \"Downloads\" 폴더에서 이 CSV 파일들을 다운로드하는 Python 유틸리티를 아래 스니펫처럼 작성했습니다. 실제 코드는 여기에서 확인할 수 있습니다.\n\n```js\n# Google 서비스에 연결하기 위한 서버 자격 증명 생성\ncredentials = Credentials.from_service_account_file(filename=\"<SERVICE_ACCOUNT_FILE의_경로>\")\n\n# Google 드라이브 서비스 초기화\nservice = discovery.build(\"drive\", \"v3\", credentials=credentials)\n\n# \"Downloads\" 폴더에 있는 모든 CSV 파일 나열\nall_csv_files, page_token = [], None\nwhile True:\n\n  # 현재 페이지 토큰에 대해 csv 파일 나열\n  response = (\n    service.files().list(\n      q=f\"(mimeType='text/csv') and ('<DOWNLOADS_폴더_ID>' in parents)\",\n      spaces=\"drive\",\n      fields=\"nextPageToken, files(id, name)\",\n      pageToken=page_token\n    ).execute()\n  )\n\n  # 리스트에 csv 파일 추가\n  csv_files, page_token = response.get(\"files\", []), response.get(\"nextPageToken\", None)\n  all_csv_files.extend(csv_files)\n\n  # 더 많은 csv 파일이 있는지 확인\n  if page_token is None:\n    break\n\n# 나열된 모든 csv 파일 다운로드\nfor i, csv_file in enumerate(all_csv_files):\n\n  # csv 파일 메타데이터 가져오기\n  csv_file_id, csv_file_name = csv_file.get(\"id\"), csv_file.get(\"name\")\n\n  # csv 파일 바이트 가져오기\n  csv_bytes = io.BytesIO()\n  downloader = MediaIoBaseDownload(file, request)\n  downloaded = False\n  while downloaded is False:\n    status, downloaded = downloader.next_chunk()\n\n  # 파일 내용 저장\n  export_file_path = os.path.join(\"<데이터_디렉토리>\", csv_file_name)\n  with open(export_file_path, \"wb\") as csv:\n    csv.write(csv_bytes.getvalue())\n```\n\n구글 서비스 계정의 이메일 주소가 최소한 \"뷰어\" 권한으로 이 CSV 파일에 액세스할 수 있도록 이 \"Downloads\" 폴더를 공유하도록 반드시 확인해주세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n데이터 다운로드 문제를 해결했으니, 이제 새 CSV 파일을 Google 드라이브에 업로드하는 방법을 구현하기 시작했습니다. 이를 위해 \"Uploads\"라는 폴더를 만들었고, CSV 파일의 다운로드와 업로드를 위해 별도의 폴더를 유지했습니다. 새 CSV 파일이 다운로드 폴더로 이동하기 전에 먼저 제가 확인할 수 있도록 했습니다.\n\n다음 코드 조각은 이 \"Upload\" 폴더로 CSV 파일을 업로드한 방법입니다. 실제 코드는 여기에서 확인하실 수 있습니다.\n\n```js\n# 모든 로컬 csv 파일 나열\nlocal_csv_files = []\nfor file_name in os.listdir(\"<DATA_DIRECTORY>\"):\n  if file_name.endswith(\".csv\"):\n    local_csv_files.append(file_name)\n\n# 나열된 모든 로컬 csv 파일 다운로드\nfor i, local_csv_file in enumerate(local_csv_files):\n\n  # 업로드할 CSV 파일을 업로드 폴더에 업로드\n  local_csv_file_path = os.path.join(\"<DATA_DIRECTORY>\", local_csv_file)\n  mimeType = \"text/csv\"\n\n  body = {\n    \"name\": local_csv_file,\n    \"mimeType\": mimeType,\n    \"parents\": [\"<UPLOADS_FOLDER_ID>\"]\n  }\n  media = MediaFileUpload(local_csv_file_path, mimetype=mimeType)\n  file = service.files().create(body=body, media_body=media, fields=\"id\")\n```\n\n스크립트가 새 CSV 파일을 업로드할 수 있도록 Google 서비스 계정 이메일 주소에 적어도 \"편집자\" 권한으로 이 \"Uploads\" 폴더를 공유해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n실제 코드 구현에서는 서버 데이터 디렉토리에 있는 CSV 파일만 다운로드했습니다. 업로드에 대해선 \"다운로드\" 또는 \"업로드\" 구글 드라이브 폴더에 이미 존재하지 않은 CSV 파일만 업로드했습니다.\n\n이 기사가 여러분이 응용 프로그램의 무료 클라우드 저장소로 Google 드라이브를 어떻게 사용하는지 이해하는 데 도움이 되었으면 좋겠습니다. The Strategists의 개발을 계속 따르고 싶다면 제 블로그를 구독해보세요. 프로젝트에 기여하는 것을 고려해주시고, 다음 링크를 통해 GitHub의 프로젝트 저장소에 액세스할 수 있습니다.\n\n제 포트폴리오를 확인해보세요. 시간 내어 이 기사를 읽어주셔서 감사합니다.\n","ogImage":{"url":"/assets/img/2024-06-19-HowdidIuseGoogleDriveasafreecloudstoragesolutiontoautomatesyncingmyMachineLearningdata_0.png"},"coverImage":"/assets/img/2024-06-19-HowdidIuseGoogleDriveasafreecloudstoragesolutiontoautomatesyncingmyMachineLearningdata_0.png","tag":["Tech"],"readingTime":7},{"title":"퀘스트 3용으로 제작된 18가지 혼합 현실 게임을 소개합니다","description":"","date":"2024-06-19 11:57","slug":"2024-06-19-18MixedRealityGamesForQuest3YouNeedToPlay","content":"\n## 사이드퀘스트가 추천하는 당신을 위한 최고의 혼합 현실 게임: MR-ready Quest 3에서 즐기세요!\n\n![2024-06-19-18MixedRealityGamesForQuest3YouNeedToPlay_0.png](/assets/img/2024-06-19-18MixedRealityGamesForQuest3YouNeedToPlay_0.png)\n\n메타 퀘스트 3이 퀘스트 2보다 한층 더 놀라운 점 중 하나는 완전한 컬러 패스스루(full-color passthrough) 및 이로 인해 제공할 수 있는 혼합/증강 현실 경험입니다. 실제로, 이는 일반적으로 보다 강력하며, 이 강력함을 확인하고 싶다면 이 목록의 20개 무료 VR 게임을 확인해보세요!\n\n하지만, 퀘스트 3의 크게 향상된 혼합 현실을 활용하기 위해 당신이 지금 당장 SideQuest에서 시도할 수 있는 최고의 18개 MR 경험 목록을 만들었습니다!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 1. Track Craft\n\nTrack Craft는 RC 레이싱과 스팅팅이 혼합된 독특한 Mixed Reality 경험을 즐기세요! 새로운 트랙과 차량을 잠금 해제하여 차고에 추가하고, 내장된 도전 과제와 타임 트라이얼에 도전하고, 직관적인 트랙 편집기를 사용하여 자신의 실제 게임 공간을 RC 천국으로 변신시킬 수도 있습니다!\n\nTrack Craft는 매우 세련된 MR 즐거움이며 실제로 2023 인디 스포트라이트에서 다루었는데, 이를 이 기사의 끝에서 시청할 수 있습니다!\n\n## [Track Craft 다운로드하기!]\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 2. CoasterMania\n\n**CoasterMania**로 당신의 거실을 극한의 테마파크로 변신하세요!\n\n**Track Craft**와 마찬가지로 **CoasterMania**는 집 안 공간에서 꿈꾸던 롤러 코스터를 디자인하고 형태를 만들 수 있는 전례없는 창의적인 옵션을 제공합니다. 그리고 나서 그 차에 올라타서 당신이 만든 코스터를 체험할 수 있습니다. 이 게임은 현재 초기 액세스 단계에 있지만, 업데이트는 계속해서 빠르게 제공될 예정이니, 개발자들에게 귀중한 피드백을 SideQuest에서 꼭 남겨주세요.\n\n## [CoasterMania 다운로드하기!]\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 3. Cubism\n\nCubism의 점점 어려워지는 퍼즐들로 두뇌를 도전하고 즐거움을 느껴보세요. 완전한 핸드 트래킹 지원, 라이트와 다크 모드, 두 개의 캠페인, 지역 퍼즐 편집기를 통해, 이 공간 퍼즐 보석과 함께 아담 새비지와 함께 하루의 '첫 커피를 마시게 될 때' 두뇌를 활성화하세요. Cubism는 SideQuest에서 시작된 최초의 게임 중 하나이며, 공식 메타 스토어로 진출하여 엄청난 인기를 끌고 있으니 계속해서 소개해 주는 것에 열정적입니다!\n\n## [Cubism 다운로드]\n\n# 4. Puzzling Places\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nVR로 즐기는 신선한 3D 직소퍼즐링이 'Puzzling Places'로 등장했습니다. 이것은 외부 세계를 잊고 마음을 단련시키는 뛰어난 방법으로, 자세한 사진촬영 스캔을 통해 정성스럽게 재현된 21개의 멋진 실제 세계 퍼즐 중 하나로 도망가 보세요. 각 퍼즐은 여러 난이도로 제공되어 직소퍼즐 실력을 테스트할 수 있습니다. 이것은 SideQuest에서 공식 스토어로 이동한 또 하나의 공을 드리는 제목이며, 여러분의 시간을 100% 충분히 가치 있는 시간으로 만들어 줄 것입니다.\n\n## [Puzzling Places 다운로드하기]\n\n# 5. Dungeon Maker\n\n'Dungeon Maker'로 '바닥이 용암이다'를 더 진보된 수준으로 가져오세요. 이 앱은 투과 모드에서 자신만의 맞춤 던전을 만들고 함정, 함정, 적들, 용암 통행 및 기타 도전 과제를 설정할 수 있습니다. 그리고 가장 중요한 것은: 완전히 무료로 즐길 수 있습니다!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## [던전 메이커 무료로 받으세요!]\n\n# 6. 미라클 풀\n\n미라클 풀은 혼합 현실의 가장 훌륭한 예 중 하나로, 집 안 공간에 실제와 같은 크기의 가상 풀 테이블을 가져왔습니다. 그 위엔 마치 진짜처럼 보이는 텍스처가 있어, 진짜 것인 줄 알았을 정도입니다. 뿐만 아니라 만족스러운 물리학과 현실적인 게임 플레이로, 미라클 풀은 VR에서 풀을 즐기는 최고의 방법입니다!\n\n## [미라클 풀 다운로드하기!]\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 7. 히트스트림\n\n히트스트림은 여가 시간에 단독 개발자가 만든 것이며, 즐겁고 빠르며 치열한 운동뿐만 아니라 MR이 체험을 더 높이는 데 사용될 수 있는 훌륭한 예시입니다. 땀을 흘리면서 운동을 즐길 때 어떤 것에 부딪힐 걱정도 없습니다!\n\n## [무료 데모 플레이!]\n\n## [히트스트림 다운로드!]\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 8. 피아노 비전\n\n우리는 2023 인디 스포트라이트에 피아노 비전도 포함했는데, 이 앱은 SideQuest에서 가장 우수한 음악 앱 중 하나로 한 번 더 인정받아야 합니다! 최고 수준의 MR 기능과 핸드 트래킹 기능을 갖추고 있어, 새로운 피아노 스킬을 배우거나 초보자로서 건반을 연주해 보고 싶다면, 피아노 비전이 당신을 훌륭하게 만졌습니다.\n\n## [피아노 비전 다운로드하기!]\n\n# 9. 공간 작전\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n재미있고 열정적이며 완전 무료로 즐길 수 있어요—단지 Quest 3 부대를 가져와서 강렵한 FPS 액션에 대비하세요. Spatial Ops는 혼합 현실로 완전히 이루어진 멀티플레이 도시 전투터로 어떠한 실제 공간을도 온전히 바꿀 수 있어요. 인상적인 MR 기술을 최대한 활용할 수 있는 충분히 넓은 지역을 선택해보세요!\n\n## [Spatial Ops를 무료로 받아보세요!]\n\n# 10. Smash Drums\n\n다른 인기있는 SideQuest의 탈출 ‘smash’ 히트곡인 Smash Drums은 무대에서 드럼 연주의 즐거움을 당신의 거실에서 느낄 수 있게 해줘요. 현재 46곡의 클래식 트랙과 곧 추가될 더 많은 곡을 함께 드럼 연주할 수 있는 Smash Drums은 Quest 3의 MR 능력을 완전히 활용한 훌륭한 리듬 게임입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## [스매시 드럼 받기!]\n\n# 11. 장난감 몬스터\n\n장난감 몬스터는 손 추적과 혼합 현실을 염두에 두고 처음부터 만들어진 독창적인 타워 방어 게임입니다. MR에서 식물 대 좀비를 생각해보세요. 이런 비교를 할 때 기대되는 매력, 디테일, 다채로운 게임플레이가 모두 있습니다!\n\n## [장난감 몬스터 받기!]\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 12. Spacefolk City\n\nSpacefolk City은 마치 전통적인 우주 도시 건설 시뮬레이션의 재치있는 그래픽으로 вas킨릴를 끌어들입니다 - 이제 MR에서도 즐길 수 있습니다! 자유롭게 떠다니는 도시의 위치를 조절하여 당신의 방에서 그를 즐길 수 있어요. 자유와 도전의 균형을 즐길 수 있어 계속해서 더 돌아오게 될 겁니다!\n\n## [Spacefolk City 다운로드하기!]\n\n# 13. Eleven Table Tennis\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만약 현실 세계의 탁구를 좋아한다면 Eleven Table Tennis가 딱 맞는 게임입니다. 물리 엔진이 훌륭하고 만족스럽습니다. MR 업데이트로 액션을 집 안으로 가져왔습니다! 다른 플레이어와 온라인 대결이 가능하거나 실력 있는 AI와 연습 모드에서 대결할 수 있어 여기에서 많은 즐길 거리가 있습니다.\n\n## [이븐 탁구 게임 다운로드]\n\n# 14. 더 우즐스\n\n만약 레밍스를 좋아한다면 우즐스도 즐길 수 있고, 퀘스트 3에서 혼합 현실을 시도하고 싶은 사람에겐 보석 같은 게임입니다. 기즐모이드를 신비한 지형과 나의 집 안으로 안내하여 승리로 이끌어 주세요!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n지금으로서는 위즐즈는 무료로 플레이할 수 있어요!\n\n## [위즐즈 무료로 받기!]\n\n# 15. FPS 향상현실\n\nFPS 향상현실은 퀘스트 2에서 훌륭했지만 퀘스트 3의 훨씬 우수한 MR 기능으로 인해 정말 자신을 찾아냈습니다. 당신의 집이 전쟁터로 변하면 다양한 무기와 몰입형 커버 시스템을 이용해 AI 적들과의 전투를 벌일 수 있어요. 미래에는 온라인 PvP도 예정되어 있어요...\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## [FPS 향상된 현실을 경험하세요!]\n\n# 16. 고릴라질라: 맥시멈 램페이지\n\n고릴라질라는 당신의 거실을 번화한 대도시로 변신시켜주는 대성공 MR 게임입니다!\n\n퀘스트 3용으로 최적화되어 있어 특정 거대 고릴라로 변신하여 가상 도시를 파괴하고 싶다면 이 게임은 확실한 히트작입니다...\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## [고릴라질라 게임을 만나보세요!]\n\n# 17. Deisim\n\nDeisim은 SideQuest에서 공식 스토어로 진출한 대히트 중 하나이며 지금, 혼합 현실에서 Deisim을 플레이할 수 있습니다!\n\n당신의 창조물을 살려내고, 사람들을 이끄는 것, 그리고 자신만의 공간에서 건물을 세우는 등 당신이 우상화되길 원하는 욕망을 충족하세요. 혹시 당신의 거실에서요!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nDeisim은 이전에도 좋았지만, 이 MR 업데이트로 더욱 멋지게 변했어요!\n\n## [Deisim 다운로드하기!]\n\n# 18. MR Chess\n\n![이미지](/assets/img/2024-06-19-18MixedRealityGamesForQuest3YouNeedToPlay_1.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n컴퓨터와 대결하거나 친구들과 함께 MR Chess에서 체스 실력을 겨루세요!\n\n가장 뚜렷한 특징은 혼합 현실에서 실체 체스판 또는 가상 체스판을 사용할 수 있는 능력입니다. 진정으로 자신만의 방식으로 플레이할 수 있도록 합니다. 가상으로 선택하면 만족스러운 햅틱 피드백이 디지털적인 느낌을 물리학적으로 느낄 수 있게 해주고, 실체 체스판을 선택하면 상대방의 말들이 디지털적으로 실체 체스말과 함께 나타납니다. 정말 똑똑한 기능이에요!\n\n## [Get MR Chess!]\n\n# 2023 SideQuest Indie Spotlight\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 목록에 소개된 몇 가지 게임은 2023년 말에 우리의 인디 스폿라이트에 포함되었습니다. 이는 독립적인 타이틀들의 성취나 미래 가능성을 인정하고자 하는 쇼케이스였어요.\n\n지금 바로 플레이할 수 있는 놀라운 인디 타이틀로 가득한 전체 스폿라이트를 확인해보세요:\n\n# SideQuest 소개\n\nSideQuest는 독립적인 VR 커뮤니티를 대표합니다. 전 세계의 개발자와 플레이어들이 함께 창작하고 공유하며 사랑하는 가상현실 앱들에 대해 흥분할 수 있는 곳이에요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n개발자들(우리와 같은)은 공식 상점에 도달하는 과정에서 메커니즘과 모드를 자유롭게 실험할 수 있고, 플레이어들은 실제로 모든 것이 한곳에 모인 멋진 VR 세계에서 수천 개의 앱을 안전하게 탐험할 수 있어요.\n\n제한이 필요할까요?\n\n[SIDEQUEST 여기서 가져오기]\n\n[BANTER 다운로드: 우리의 무료 소셜 VR 게임]\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n서민수님의 SideQuest🚀 계속 진행하도록 해요...\n\n웹사이트 | 페이스북 | 트위터 | 인스타그램 | 틱톡 | 레딧 | 미디엄 | 디스코드 | 링크드인 | 연구 클럽 | 수다방\n","ogImage":{"url":"/assets/img/2024-06-19-18MixedRealityGamesForQuest3YouNeedToPlay_0.png"},"coverImage":"/assets/img/2024-06-19-18MixedRealityGamesForQuest3YouNeedToPlay_0.png","tag":["Tech"],"readingTime":11},{"title":"게임 엔진을 위한 저지연 스크립팅 소개, 파트 2","description":"","date":"2024-06-19 11:54","slug":"2024-06-19-AnIntroductiontoLow-LatencyScriptingforGameEnginesPart2","content":"\n고급 예제, 게스트 할당, RPC\n\n이전 파트에서는 모든 것을 설정하고 샌드박스 안팎에서 기본 호출을 만드는 방법을 보여 주었습니다. 라이브리스브 레포지터리의 예제 폴더에서 게임 개발 예제를 사용함으로써 RISC-V 컴파일러를 찾았다면 제시된 코드 예제를 즉시 실행할 수 있었습니다.\n\n이 파트 2에서는 고급 예제를 살펴보겠습니다.\n\n## 1. 고급 API 설계와 호스트 제어 힙\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n게스트 힙은 샌드박스 바깥에서 완전히 제어됩니다. 게스트는 알려진 시스템 호출을 실행하여 메모리를 할당하고 해제하며 각각 할당과 해제를 처리합니다. 또한 calloc 및 realloc도 지원됩니다.\n\n우리는 이것을 어떻게 활용할 수 있는지 보여주기 위해 가벼운 추상화를 만들 것입니다. 예를 들어, 위치에 연결된 데이터 개념을 만들어볼 것입니다. 다음과 같은 것입니다:\n\n```js\nstruct LocationData {\n   int x, y, z;\n   std::unique_ptr<uint8_t[]> data = nullptr;\n   std::size_t size = 0;\n};\n```\n\n위치의 의미는 여기서 중요하지 않습니다. 중요한 것은 어딘가에 해당하는 구조체라는 것뿐입니다. 계속 진행하기 전에 몇 가지 알아야 할 사항이 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 모든 힙 할당은 64비트로 정렬됩니다. 그것은 우리가 제어합니다.\n- 데이터를 수정하고 모든 작업이 완전히 완료된 후에만 커밋할 수 있는 능력을 원합니다.\n- ... 따라서 우리는 데이터의 사본을 스크립트 프로그램으로 가져 오고 싶습니다.\n\n최소 API에 대해 2가지 기능이 필요합니다:\n\n```js\n// 위치 (x, y, z)의 내용을 검색하는 함수,\n// 또는 위치가 발견되지 않으면 (nullptr, 0)를 반환합니다.\nstruct LocationGet {\n  uint8_t* data;\n  size_t size = 0;\n};\nDEFINE_DYNCALL(10, location_get, LocationGet(int, int, int));\n// 위치의 내용을 커밋하는 함수\n// 오류를 반환 할 수 없으며 대신 예외가 발생합니다.\nDEFINE_DYNCALL(11, location_commit, void(int, int, int, const void*, size_t));\n```\n\nABI는 레지스터에 직접 2개의 원소 구조체를 반환할 수 있다고 합니다. 이는 효율적입니다. 따라서 x, y 및 z를 레지스터에 유지하려고 시도할 것입니다.모두 인수로 전달합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 간단하고 직관적인 클래스를 만드는 것이 좋습니다:\n\n```js\n#include <span>\nstruct LocationData {\n  LocationData(int x, int y, int z)\n    : x(x), y(y), z(z)\n  {\n    auto res = location_get(x, y, z);\n    if (res.data) {\n       m_data.reset(res.data);\n       m_size = res.size;\n    }\n  }\n  void commit() {\n    location_commit(x, y, z, m_data.get(), m_size);\n  }\n\n  bool empty() const noexcept {\n    return m_data == nullptr || m_size == 0;\n  }\n  std::span<uint8_t> data() {\n    return { m_data.get(), m_size };\n  }\n  void assign(const uint8_t* data, size_t size) {\n    m_data = std::make_unique<uint8_t[]>(size);\n    std::copy(data, data + size, m_data.get());\n    m_size = size;\n  }\n\n  const int x, y, z;\nprivate:\n  std::unique_ptr<uint8_t[]> m_data = nullptr;\n  std::size_t m_size = 0;\n};\n```\n\n이 간단하고 직관적인 클래스는 특정 위치의 데이터를 관리합니다. 객체를 생성하면 공백을 채우려고 시도하며 비어 있으면 원하는 대로 데이터를 할당할 수 있습니다. 데이터를 커밋하면 크기에 관계없이 엔진 데이터를 덮어씁니다.\n\n게임 엔진 쪽에서 이를 아주 빠르게 구현할 수 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nstruct Location {\n  int x = 0, y = 0, z = 0;\n\n  bool operator==(const Location& other) const {\n    return x == other.x && y == other.y && z == other.z;\n  }\n};\nnamespace std {\n  template<> struct hash<Location> {\n    std::size_t operator()(const Location& loc) const {\n      return std::hash<int>()(loc.x) ^ std::hash<int>()(loc.y) ^ std::hash<int>()(loc.z);\n    }\n  };\n}\nstruct LocationData\n{\n  std::vector<uint8_t> data;\n};\nstatic std::unordered_map<Location, LocationData> locations;\n```\n\n그리고 게임 엔진의 location_get 및 location_commit 콜백 함수들:\n\n```js\n// sys_location_get 콜백 함수입니다\nregister_script_function(10, [](Script& script) {\n  auto [x, y, z] = script.machine().sysargs<int, int, int>();\n  auto it = locations.find(Location(x, y, z));\n  if (it != locations.end()) {\n    auto alloc = script.guest_alloc(it->second.data.size());\n    script.machine().copy_to_guest(alloc, it->second.data.data(), it->second.data.size());\n    script.machine().set_result(alloc, it->second.data.size());\n  } else {\n    script.machine().set_result(0, 0);\n  }\n});\n// sys_location_commit 콜백 함수입니다\nregister_script_function(11, [](Script& script) {\n  auto [x, y, z, data] = script.machine().sysargs<int, int, int, std::span<uint8_t>>();\n  // 새로운 위치를 생성하거나 기존 위치를 업데이트합니다\n  auto& loc = locations[Location(x, y, z)];\n  loc.data = std::vector<uint8_t>(data.begin(), data.end());\n});\n```\n\n이제 조금 설명이 필요합니다. 게임 엔진의 콜백 함수는 프로그램에서 발생하는 호출로부터 인수를 검색한 다음 호출된 함수에 따라 유용한 작업을 수행합니다. 프로그램이 이렇게 수행한다고 가정해보세요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```cpp\nLocationData loc(1, 2, 3);\nif (!loc.empty()) {\n  printf(\"위치 (1, 2, 3)에 %zu바이트가 있습니다\\n\", loc.data().size());\n  location_commit(1, 2, 3, loc.data().data(), loc.data().size());\n} else {\n  printf(\"LocationGet(1, 2, 3) 비어 있었어요!\\n\");\n}\n\nstd::vector<uint8_t> data = { 0x01, 0x02, 0x03, 0x04 };\nloc.assign(data.data(), data.size());\nloc.commit();\n\nLocationData loc2(1, 2, 3);\nif (!loc2.empty()) {\n  printf(\"위치 (1, 2, 3)에 %zu바이트가 있습니다\\n\", loc2.data().size());\n  location_commit(1, 2, 3, loc2.data().data(), loc2.data().size());\n} else {\n  printf(\"LocationGet(1, 2, 3) 비어 있었어요!\\n\");\n}\n```\n\n그리고 예상대로 출력 결과가 나왔어요:\n\n```cpp\nLocationGet(1, 2, 3) 비어 있었어요!\n위치 (1, 2, 3)에 4 바이트가 있습니다\n```\n\n그래서 이 프로그램은 먼저 (1, 2, 3) 위치에 있는 LocationData를 생성하고 비어 있는지 확인합니다. 비어 있었습니다. 그런 다음 4바이트 벡터에서 할당하고, 커밋하며, 새로운 (1, 2, 3) 위치에 있는 LocationData를 만들고 이제 4바이트를 포함하였다는 것을 확인할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nLocationData의 생성자는 다음과 같습니다:\n\n```js\nauto res = location_get(x, y, z);\nif (res.data) {\n  m_data.reset(res.data);\n  m_size = res.size;\n}\n```\n\n이 코드는 게임 엔진에 location_get을 실행하도록 요청하며, 이를 콜백 10으로 번호를 매깁니다. 콜백 10이 실행되고, 즉시 첫 번째로 받은 3개의 인자를 정수형으로 가져와 x, y, z를 만듭니다. 그런 다음 이를 위치들 지도에 찾아보고, 찾지 못하면 (0, 0)를 반환합니다. 이것은 다른 한 쪽에 포인터가 있고, 다른 하나는 정수인 두 레지스터를 0으로 설정하는 것으로 상상할 수 있습니다.\n\n이후, LocationData가 비어있게 되고, 그것이 출력됩니다. 그런 다음에 데이터를 할당하고 commit()를 호출합니다. Commit은 location_commit인 콜백 11을 호출할 것입니다. 콜백을 확인하면 4개의 인자를 읽어옵니다: x, y, z 및 `span<uint8_t>`입니다. 이것은 동적인 스팬이므로 2개의 레지스터를 소비해서 총 5개로 만들어집니다. 이는 프로그램의 정의와 일치하는데, void(int, int, int, const void\\*, size_t)입니다. 즉, 포인터를 위한 하나의 레지스터, 그리고 데이터의 크기를 위한 두 번째 레지스터가 필요합니다. 그리고 이 데이터는 해당 위치의 지도로 복사됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n마침내, LocationData를 다시 (1, 2, 3)로 만들었고, 이번에는 데이터를 찾았어요. 4바이트가 저장되고 프로그램으로 검색되었으며, 데이터와 크기는 2개의 레지스터로 전달되었어요. 호스트 측의 콜백 함수에서는 다음과 같은 절차가 진행됩니다:\n\n- 스크립트 프로그램에 대한 힙 할당이 script.guest_alloc(bytes)를 사용하여 이루어집니다.\n- 그 다음, 데이터를 힙 할당 주소로 복사하기 위해 script.machine().copy_to_guest(…)를 사용합니다.\n- 마지막으로, 주소와 크기를 반환합니다.\n\n이로써 첫 번째 고급 스크립팅 예제가 마무리되었습니다.\n\n이 예제 API에 대한 마지막 참고 사항은 상당히 남용 방지 메커니즘이 있다는 것입니다. 우리가 적대적인 행동을 기대하는 경우, 생성될 수 있는 위치의 수에 제한을 두었어야 했지만, 이를 제외하고는 libriscv API가 극단적인 값들을 예방하는 데 탁월한 역할을 합니다. 예를 들어, 방대한 범위는 즉시 실패합니다. 잘못된 메모리 읽기 또는 쓰기는 실행이 실패합니다. 너무 오랫동안 지연하는 시도도 실패합니다. 간단히 말해, 정말 딱글딱글하게 만드는 경우가 있어 무한 루프에 빠진 적도 있지만, 이로 인해 게임에 영향을 준 적은 없었습니다. 잠시 실행되다가 결국 스스로 실패하고 멈춘 지점도 알려줍니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 2. 원격 프로시저 호출\n\n동일한 코드를 두 곳에서 실행하고 두 개의 별도 시스템에서 동일한 동작을 경험하는 것은 간단히 올바른 에뮬레이션입니다. 더 나아가, 동일한 프로그램이라고 가정한다면 함수 호출을 설명하고 그것이 동일하게 작동하도록 할 수도 있습니다. 그래서 두 개의 샌드박스에 동일한 프로그램을 실행하여 원격 프로시저 호출이 발생하도록 해 보겠습니다, 테스트 목적으로.\n\n우선, 다른 위치에서 함수를 실행하려면 어떻게 실행할지 정의해야 합니다. 예를 들어, 하나의 가상 머신에서 모든 레지스터를 다른 가상 머신으로 복사한 다음 레지스터에 맞는 모든 인수를 원격 함수에 전달한다고 가정할 수 있습니다. 그런 다음 모든 프로그램이 동일하기 때문에 기능도 동일하게 동작할 것입니다.\n\n우리가 하려는 다른 방법은 고정 크기 lambda 캡쳐를 사용하는 것입니다. 우리가 신경 쓰는 것들을 (값으로!) 람다 함수에 복사하여 원격 위치로 전송하고 그것을 인자로서 트램폴린에 전달할 수 있습니다. 그런 다음 트램폴린은 캡쳐와 함께 람다를 호출하고 와! 원격 프로시저 호출이 이뤄집니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n간단한 API를 다음과 같이 만들어 봅시다:\n\n```js\nint x = 42;\nrpc([x] {\n  printf(\"원격 가상 머신에서 안녕하세요!\\n\");\n  printf(\"x = %d\\n\", x);\n  fflush(stdout);\n});\n```\n\n실제 환경에서 RPC 함수는 주변 또는 지역 플레이어에게 브로드캐스트할 수 있는 기능을 포함한 여러 가지 모드를 가질 것입니다. 하지만 이 예제에는 충분합니다. 이를 구현하기 위해서는 고정 크기 캡처 함수 구현이 필요합니다 (링크가 됨). 이를 사용하여 다음과 같이 callable을 트램폴린으로 사용하는 도우미 함수를 만들 수 있습니다:\n\n```js\nDEFINE_DYNCALL(12, remote_lambda, void(void(*)(void*), const void *, size_t));\n\nstatic void rpc(riscv::Function<void()> func)\n{\n  remote_lambda(\n  [](void* data) {\n    auto func = reinterpret_cast<riscv::Function<void()>*>(data);\n    (*func)();\n  },\n  &func, sizeof(func));\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여기서 하는 일은 inline 함수를 사용하여 전달 된 `remote_lambda`를 호출하는 것입니다. 이 함수는 포인터로 변환 할 수있는 내부 함수를 취하며 해당 포인터를 고정 크기 캡처 함수로 변환할 수 있습니다. 그런 다음 호출합니다. 그리고 두 번째 및 세 번째 인수는 함수와 해당 크기입니다. 즉, 3 개의 인수가 있습니다. : 함수 포인터, Function`void()` 포인터 및 해당 크기.\n\n호스트에서는 캡처 스토리지를 읽어서 주소를 정수 값으로 검색합니다.\n\n```js\nstatic Script::gaddr_t remote_addr;\nstatic std::array<uint8_t, 32> remote_capture;\n...\nregister_script_function(12, [](Script& script) {\n  auto [addr, capture] = script.machine().sysargs<Script::gaddr_t, std::array<uint8_t, 32>*>();\n\n  remote_addr = addr;\n  remote_capture = *capture;\n});\n```\n\n여기서는 함수 포인터 주소를 검색한 다음 32 바이트 std::array에 대한 제로 복사 포인터를 얻습니다. 내부적으로 메모리가 올바르며 범위 내에 있는지 확인하려고 고정 크기 1 요소 span이 생성됩니다. 그런 다음 배열로 변환되며 정렬 확인 후에 처리됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n지금 우리는 프로그램에서 캡처 스토리지를 사용하여 함수를 호출할 수 있는 능력을 가졌습니다. 따라서 함수를 호출하기 위해 다른 Script 인스턴스를 만들겠습니다:\n\n```js\nauto script2 = script.clone(\"myscript2\");\n\n// 캡처를 스택에 푸시한 채로 원격 함수 호출\nscript2.call(remote_addr, remote_capture);\n```\n\n캡처 스토리지가 스택에 푸시된 상태로 remote_addr를 호출하면 성공적인 원격 프로시저 호출이 발생합니다:\n\n```js\nHello from a remote virtual machine!\nx = 42\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이것은 두 프로그램이 동일할 때 안전하고 신뢰할 수 있는 RPC를 구현하는 데 함수 주소와 캡처 저장소만 필요하다는 것을 보여줍니다. 이것은 제가 게임 개발에서 많이 활용하는 기능입니다.\n\n## 3. 콜백 구현하기\n\n나중에 호출할 스크립트 내에서 콜백을 만드는 두 가지 방법이 있습니다.\n\n첫째, 단순히 이름으로 함수를 찾아 미리 합의된 매개변수를 사용하여 호출하는 것이 가장 쉽지만 약간 오류가 발생할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nmyscript.call(\"my_function\", 1, 2, 3, \"four\");\n```\n\n요 메소드의 경우에는 스크립트에 \"my_function\" 함수를 extern \"C\"로 구현하는 것 외에는 아무것도 할 필요가 없습니다. 해당 함수가 visible 하다면 (심볼 테이블 항목이 있으면) 호출할 수 있습니다. 우리가 알 수 없는 것은 함수가 실제로 그러한 인수를 받는지 여부이지만 이 메소드는 JSON과 같은 곳에서 매우 쉽게 사용할 수 있습니다.\n\n두 번째 방법은 스크립트 자체에서 함수 포인터를 가져오는 방법이지만, 이를 위해 콜백 등록 함수를 만들어야 합니다. 다음과 같이:\n\n```js\nDEFINE_DYNCALL(13, my_callback, void(const char*, void(*)(int)));\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n예를 들어, 게임 안의 엔티티를 식별하는 첫 번째 문자열을 가져와서 함수 포인터를 사용합니다. 이벤트가 발생할 때 함수 포인터가 호출되며, 엔티티의 ID인 정수를 전달할 것입니다. 호스트에서 핸들러를 구현하는 예시입니다:\n\n```js\nregister_script_function(13, [](Script& script) {\n  auto [name, func] = script.machine().sysargs<std::string, Script::gaddr_t>();\n\n  // 이름으로 엔티티 찾기\n  auto& ent = entities.at(name);\n  // 엔티티를 위한 이벤트 핸들러 등록\n  ent.on_event(\n  [func, &script] (auto& ent) {\n    // 엔티티 ID를 인수로하여 함수 호출\n    script.call(func, ent.getID());\n  });\n});\n```\n\n여기서 Script::gaddr_t은 샌드박스 내부의 포인터와 같은 크기의 부호 없는 정수입니다. 물론, 구조체를 전달할 때 문제를 피하기 위해 일치하는 포인터 크기를 사용하는 것이 좋습니다 (예: size_t의 차이).\n\n그래서 이러한 호스트에서의 콜백을 사용하면, 호출되면 엔티티를 찾아서, 해당 엔티티의 on_event 콜백을 설정하여 이전에 제공된 함수 포인터로 스크립트 함수를 호출하고 엔티티 ID를 인수로 전달하게 됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n스크립트 안에는 이제 이렇게 이벤트 핸들러를 만들 수 있습니다:\n\n```js\nmy_callback(\"entity1\", [] (int id) {\n  printf(\"Callback from entity %s\\n\", Entity{id}.getName().c_str());\n});\n```\n\n이 예제에서는 Entity를 감싸는 래퍼가 있다고 가정합니다. 그럼 그 래퍼를 통해 예를 들어 Entity 이름을 가져올 수 있습니다.\n\n콜백에 대한 세 번째이자 마지막 방법은 위와 동일하지만, 스크립트에서 Function`void()`를 사용합니다. 호스트에서 캡처 스토리지를 람다로 복사하여 이벤트 핸들러에 전달한 후, 이벤트가 트리거될 때 함수 호출 중에 캡처 스토리지를 스택에 푸시합니다. RPC의 예와 비슷합니다. 이렇게 함으로써 캡처 스토리지를 가진 이벤트를 만들 수 있습니다. 매우 편리하죠!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그 단계별로 구현을 마무리해 봅시다. 먼저, 스크립트에서 정의를 수정하여 추가적인 const void*, size_t 매개변수를 받도록 하고, 그 다음으로 함수 포인터를 수정하여 나중에 캡처 저장소를 가져올 수 있도록 void* 인수를 추가하세요:\n\n```js\nDEFINE_DYNCALL(13, my_callback, void(const char*, void(*)(int, void*), const void*, size_t));\n```\n\n조금 복잡해 보이지만 두 단계로 진행하면 됩니다. 두 번째 단계는 항상 같은 단계입니다. callable에 const void*, size_t를 추가하고 callback 함수 포인터에 void*를 추가하세요. 이 callable을 사용하려면 도우미 함수를 만들어야 합니다:\n\n```js\nstatic void entity_on_event(const char* name, riscv::Function<void(int)> callback)\n{\n  my_callback(name,\n  [] (int id, void* data) {\n    auto callback = reinterpret_cast<riscv::Function<void(int)>*>(data);\n    (*callback)(id);\n  },\n  &callback, sizeof(callback));\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n도움 함수는 복잡한 호출을 간단하게 만들어줍니다. 함수를 다시 자체로 캐스팅하는 중간 함수가 추가되며, 일반적인 인수로 호출됩니다. 또한 반환 값을 전달할 수도 있습니다.\n\n```js\nint x = 42;\nentity_on_event(\"entity1\",\n[x] (int id) {\n  printf(\"Entity %s에서 콜백\\n\", Entity{id}.getName().c_str());\n  printf(\"x = %d\\n\", x);\n});\n```\n\nRPC 예제처럼 x = 42를 출력합니다. 이를 위해 호스트 측을 확장해야 합니다:\n\n```js\nregister_script_function(13, [](Script& script) {\n  auto [name, func, capture] = script.machine().sysargs<std::string, Script::gaddr_t, std::array<uint8_t, 32>*>();\n\n  // 이름으로 Entity 찾기\n  auto& ent = entities.at(name);\n  // Entity의 이벤트 핸들러 등록\n  ent.on_event(\n  [func, &script, capture = *capture] (auto& ent) {\n    // Entity ID를 인수로하여 함수 호출\n    script.call(func, ent.getID(), capture);\n  });\n});\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n지금 변경된 부분은 capture storage를 값으로 복사하여 on_event lambda에 넣은 다음, void* 인수로서 마지막 인수로 넣어 스택에 푸시하는 것입니다. 이것은 void* 인수입니다. 이 예제에서는 실제로 배열을 포인터로 반환했습니다: `std::array<uint8_t, 32>*`, 그리고 이것은 그 데이터에 대한 제로-코피 포인터를 제공합니다. 하지만, 그것을 값으로 capture해야 합니다.\n\n읽어 주셔서 감사합니다. 나중에 더 많은 예제를 살펴보겠습니다.\n\n-곤조\n","ogImage":{"url":"/assets/img/2024-06-19-AnIntroductiontoLow-LatencyScriptingforGameEnginesPart2_0.png"},"coverImage":"/assets/img/2024-06-19-AnIntroductiontoLow-LatencyScriptingforGameEnginesPart2_0.png","tag":["Tech"],"readingTime":17},{"title":"게임 개발자를 위한 생성적 AI의 활용 방안 2024년 6월판","description":"","date":"2024-06-19 11:53","slug":"2024-06-19-UsesofGenerativeAIforGameDevelopersJune2024Edition","content":"\n![image](/assets/img/2024-06-19-UsesofGenerativeAIforGameDevelopersJune2024Edition_0.png)\n\n제너레이티브 AI는 빠르게 발전하고 있고 끊임없이 헤드라인을 내지만, 게임 개발자가 generative AI를 사용하는 것이 정말로 유익한가요? 저희는 2022년부터 이 분야에서의 경험을 기반으로 이 질문에 대한 저희의 견해를 요약했습니다.\n\n\\*2024년 6월을 기준으로 한 저희의 관점임을 유의해 주세요. 상황은 계속 변화 중입니다.\n\n# 주요 포인트 요약\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n바쁜 독자들을 위해 먼저 결론을 알려드립니다:\n\n- 생성적 AI의 가장 효과적인 사용은 게임 기획 단계에 있습니다.\n- 다음으로 효과적인 영역은 마케팅을 위한 콘텐츠 생성입니다.\n\n![이미지](/assets/img/2024-06-19-GenerativeAI를이용한게임개발자용도2024년6월판_1.png)\n\n반면, 게임에 직접 구현할 수 있는 자산을 생성하는 것은 가장 큰 기대치를 가졌을 수 있지만, 현재 일관성 없는 품질 및 다른 편집 과정과 같은 어려움에 직면하고 있습니다. 이로 인해 이분야 전문가들은 종종 불편함을 느끼며, 현재는 특정 목적으로만 한정적으로 사용되고 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n물론 창의력을 발휘하여 제너레이티브 AI를 제품 개발에 활용할 수 있습니다. 예산 제약, 프로젝트 규모, 혹은 전문분야 외의 영역을 보충하는 데 있어 가치를 제공할 수 있습니다.\n\n위치팟 주식회사에서는 우리가 상담하는 게임 스튜디오와 개발자들에게 기술을 따라잡는 동안 기획 및 마케팅 단계에서 제너레이티브 AI를 활용할 것을 권장합니다. 게임 개발에 대한 AI 도구의 맞춤화부터 상담 서비스까지 다양한 서비스를 제공하고 있으니 언제든지 연락 주세요. (https://www.witchpot.com/contact)\n\n# 전제\n\n게임에서 제너레이티브 AI의 적용을 고려할 때에는 두 가지 주요 접근 방식이 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 기존 게임 콘텐츠의 효율성 향상을 위해 AI 활용 주로\n- 전통적인 방법과는 다른 새로운 게임 경험 창출을 위해 AI 활용\n\n이 글에서는 전자 방법에 초점을 맞출 것입니다. 후자인 새로운 게임 경험 창출 방법은 다루지 않겠지만, 수요가 있을 경우 별도로 논의할 수 있습니다.\n\n# 생성 AI의 현재 상태 및 과제\n\n게임 분야는 방대하기 때문에 이 글에서는 모든 것을 다 다루지는 않을 것입니다. 그러나 우리는 공개적으로 사용 가능한 시장 맵이 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여기서는 이미지 및 텍스트 생성의 현재 상태와 도전 과제에 대해 이야기하겠습니다.\n\n이미지 생성의 현재 상태 및 도전 과제\n\n현재 이미지 생성은 특정 캐릭터의 다양한 상황에서 이미지를 생성할 수 있으며, 해당 캐릭터가 동일하다고 인식될 수 있는 수준까지 만들어낼 수 있습니다. 또한 적절한 조정을 통해 이미 존재하는 콘텐츠의 캐릭터에 대해서도 이 작업을 수행할 수 있습니다.\n\n![이미지](/assets/img/2024-06-19-UsesofGenerativeAIforGameDevelopersJune2024Edition_2.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그러나 도전 과제들이 있습니다. 예를 들어, 문자의 비율이나 몸의 형태에 약간의 차이가 발생할 수 있습니다. 유명한 사례로는 캐릭터들이 여섯 손가락으로 나오는 경우 등이 있습니다. 이러한 문제들은 사람들이 그릴 때는 발생하지 않지만 수정이 필요합니다.\n\nAI로 생성된 이미지는 층으로 분리되지 않고 하나의 이미지로 생성됩니다. 따라서 이미 그림을 잘 그리는 사람들에게는 세부적인 수정이 번거로울 수 있습니다.\n\n텍스트 생성의 현재 상황과 도전 과제\n\n이 비디오에서는 캐릭터의 대화가 생성됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n또한, 텍스트 생성은 이야기, 캐릭터 설정, 플레이버 텍스트 및 태그 라인을 작성하는 데 사용될 수 있어 그 적용 범위가 매우 광범위합니다.\n\n여기서 우리는 텍스트 생성을 위해 Glimnote를 사용하지만, ChatGPT와 같은 도구도 올바른 사용법으로 캐릭터의 어조와 성격에 맞는 대화를 생성할 수 있습니다.\n\n그러나, 여전히 일부 어려움이 남아 있습니다. 예를 들어 생성된 텍스트는 종종 지나치게 과장되거나 과도한 찬사를 포함할 수 있습니다. 우리는 개선을 위해 노력하고 있지만, 피드백에 따르면 이러한 텍스트를 그대로 사용하는 것이 여전히 어렵다는 것을 보여줍니다.\n\n이러한 상황에서 많은 기존 게임 개발 팀은 특정 영역마다 전문가를 보유한 특히 AI 도구의 출력이 미흡하고 진화를 기다리는 것으로 발견되었을 때 많은 어려움을 겪고 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 기획 단계에서 AI 활용하기\n\nAI 도구의 장점은 그것들의 압도적인 속도와 양이에 있습니다. 새로운 콘텐츠를 기획하는 아이디어 생성 단계에서, 이러한 장점은 상기한 도전적인 부분들보다 상당한 혜택을 제공할 수 있습니다.\n\n![image](/assets/img/2024-06-19-UsesofGenerativeAIforGameDevelopersJune2024Edition_3.png)\n\n실제로 AI는 팀 내에서 빠르게 프로토타입과 초안을 생성함으로써 \"우리가 만들고 싶은 것\"에 대한 의사 소통을 가속화하는 데 점점 더 활용되고 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n예를 들어, 팀이 새 캐릭터를 만들고 싶다면, 텍스트만 사용하여 세계 설정에 맞는 20개의 새 캐릭터를 몇 분 만에 생성할 수 있습니다. 도구에 익숙해지면, 이 20개 캐릭터에 대한 의도한 예술 스타일의 시각적 이미지도 몇 분에서 몇 시간만에 생성할 수 있습니다.\n\n필요한 시간은 원하는 품질 및 프롬프트 제작 전문성에 따라 다릅니다.\n\n개발팀 내에서 이 20개 캐릭터 프로토타입을 공유하면 종종 어떤 캐릭터를 추가로 발전시킬지에 대한 열정적인 토론이 이루어지며, 더 좋은 프로젝트와 원활한 커뮤니케이션으로 이어집니다.\n\n캐릭터 설정에만 국한되지 않습니다. 예를 들어, 효과음을 명시할 때, 텍스트 설명은 중요하지만, 효과음 AI가 생성한 프로토타입을 공유함으로써 정보 전달이 현저하게 향상됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 마케팅 콘텐츠 작성\n\n이미지 생성 환경을 구축하고 능숙하게 사용할 수 있는 환경을 구축 한 후에는 게임 내에서 직접 사용하기 어려운 자산이더라도 여전히 소셜 미디어에 자주 게시할 만한 충분한 마케팅 콘텐츠를 만들 수 있습니다.\n\n여기에는 저희 Witchpot이 협력한 SQUADBLAST 게임을 위해 AI를 사용하여 작성된 팬 아트 콘텐츠의 예가 있습니다.\n\n![팬 아트](/assets/img/2024-06-19-UsesofGenerativeAIforGameDevelopersJune2024Edition_4.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nAI 도구를 활용하여 PR 콘텐츠를 제작하면 높은 빈도의 게시물을 유지하여 청중을 계속해서 참여시키고 게임에 대해 정보를 제공할 수 있습니다.\n\n실제 캐릭터 이미지를 생성할 수 있는 환경을 만들 수 있으며, 이를 제한함으로써 팬 아트를 만들 수 있는 환경을 제공할 수 있습니다. 또한 이를 활용하여 커뮤니티를 형성할 수도 있습니다.\n\n# 결론\n\n게임 개발자들이 현재 AI 도구를 기획 및 마케팅 콘텐츠 제작 분야에서 어떻게 활용하고 있는지에 대해 설명했습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이러한 분야에서 의도한 결과물을 생성하는 기술을 개발함으로써, 우리는 AI의 혜택을 누리고 가치 있는 통찰을 축적할 수 있습니다. 이를 통해 게임 자산 생성에 AI를 활용하는 것을 권장하며, 수많고 매혹적인 게임을 출시할 수 있게 됩니다.\n\n저희는 계속해서 이 분야의 정보를 공유할 것이므로, 부디 팔로우해 주세요!\n\n무엇이든 자유롭게 저희에게 질문해 주세요!\n","ogImage":{"url":"/assets/img/2024-06-19-UsesofGenerativeAIforGameDevelopersJune2024Edition_0.png"},"coverImage":"/assets/img/2024-06-19-UsesofGenerativeAIforGameDevelopersJune2024Edition_0.png","tag":["Tech"],"readingTime":7},{"title":"유니티 실시간 멀티플레이어, 파트 8 사용 가능한 네트워킹 솔루션 탐색","description":"","date":"2024-06-19 11:50","slug":"2024-06-19-UnityRealtimeMultiplayerPart8ExploringReady-MadeNetworkingSolutions","content":"\n멀티플레이어 게임에서는 클라이언트들이 동기화되어야 합니다. 데이터 패킷을 직접 교환하는 것이 가능하지만, 이는 경험이 적은 개발자들에겐 복잡할 수 있습니다. 그러므로 우리는 다양한 케이스에 대한 준비된 네트워킹 솔루션을 살펴보겠습니다.\n\n![image](/assets/img/2024-06-19-UnityRealtimeMultiplayerPart8ExploringReady-MadeNetworkingSolutions_0.png)\n\n안녕하세요! MY.GAMES의 리드 소프트웨어 엔지니어 Dmitrii Ivashchenko입니다. Unity 실시간 멀티플레이어 랜드스케이프에 관한 시리즈 기사가 계속됩니다! 오늘은 실시간 멀티플레이어용 준비된 솔루션에 대해 다뤄볼 예정입니다. 시작해봅시다.\n\n# 전송에 대한 간단한 메모\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n멀티플레이어 게임에서 서버와 클라이언트는 네트워크를 통해 패킷을 보내는 방식으로 데이터를 교환합니다. 서로 다른 위치에서 접속한 플레이어들을 위해 공유된 가상 공간을 만들기 위해, 게임 프로세스에서 발생하는 이벤트(캐릭터 이동 또는 오브젝트 생성과 같은)는 다른 클라이언트와 동기화되어 데이터 패킷을 보내는 것으로 처리됩니다. 네트워크를 통해 패킷을 송수신하는 책임을 맡고 있는 부분을 전송 계층이라고 부릅니다.\n\n이 패킷들을 직접 전송하는 것은 가능하지만, 이러한 방식은 멀티플레이어 게임을 다루는 데 경험이 적은 개발자들에겐 불편할 수 있습니다. 그래서 처음부터 직접 구현하기보다는 아래 나열된 것 중 하나를 사용하는 것이 더 나은 아이디어입니다. 이제 그 솔루션들을 살펴보겠습니다.\n\n# Unity Relay & Netcode\n\n유니티는 Netcode 패키지 두 가지를 제공합니다: GameObjects용 Netcode(미리보기 릴리스 단계), Entities용 Netcode(실험 모드) 그리고 폐기된 UNET. 또한 Unity Relay 서비스를 제공하여 게임 클라이언트를 연결합니다 - 이에 대해 간단히 언급하겠습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 유니티 릴레이\n\n유니티 릴레이는 게임 개발자가 플레이어 간에 향상된 연결을 제공하는 방법으로, 세 번째 자로 솔루션에 투자하지 않고 전용 게임 서버(DGS)를 유지하거나 멀티플레이어 게임에서 네트워크 복잡성에 대해 걱정할 필요 없이 조인 코드 메커니즘을 통해 제공합니다. DGS 대신 릴레이 서비스는 프록시 역할을 하는 유니버설 릴레이 서버를 통해 연결성을 제공합니다.\n\n![image](/assets/img/2024-06-19-UnityRealtimeMultiplayerPart8ExploringReady-MadeNetworkingSolutions_1.png)\n\n릴레이 서비스를 통해 플레이어들은 UDP, DTLS 및 안전한 WebSocket (WSS)를 포함한 여러 다양한 프로토콜을 통해 통신할 수 있습니다. 릴레이 서버를 선택한 후에 클라이언트는 앞에서 언급한 프로토콜 중 하나를 사용하여 직접 릴레이 서버와 통신합니다. WebSocket 연결을 통해 WebGL을 사용하는 브라우저에서 멀티플레이어 연결이 가능합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nRelay는 모든 게임 엔진과 함께 작동합니다. Unity에서 Relay를 사용하는 경우 Unity Transport Package (UTP)와 통합된 Relay SDK를 사용하는 것이 좋습니다.\n\n# Unity Transport Package\n\nUnity Transport은 멀티플레이어 게임을 개발하기 위한 저수준 네트워킹 라이브러리입니다. 이것은 Netcode for GameObjects 및 Netcode for Entities를 기반으로 하지만 솔루션과 함께 사용할 수도 있습니다.\n\nUnity Transport는 UDP 및 WebSockets 위에 제공된 연결 기반 추상화 계층(내장된 네트워크 드라이버) 덕분에 Unity Engine에서 지원하는 모든 플랫폼을 손쉽게 지원합니다. UDP 및 WebSockets를 암호화 여부에 관계없이 구성할 수 있습니다. 신뢰성, 패킷 순서, 패킷 분할과 같은 추가 기능을 제공하기 위해 파이프라인도 사용할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nTransport 2.0의 주요 기능은 WebGL 지원이 추가되었습니다. 이를 통해 Unity Transport 패키지를 Unity Engine의 모든 지원 플랫폼에서 사용할 수 있게 되었습니다. Transport 사용자들은 이제 Websocket 전송의 구현에 접근할 수 있습니다. TLS를 사용하든 사용하지 않든 움직이는 플레이어는 일반적으로 셀룰러 타워 사이에서 네트워크 이동을 투명하게 활용할 수 있습니다. 이 기능은 현재 클라이언트 측과 UDP 전송에만 제한되어 있습니다.\n\nUnity Transport를 사용하려면 Unity Editor 버전 2022.2 이상을 설치하고 com.unity.transport 패키지도 설치해야 합니다.\n\n![이미지](/assets/img/2024-06-19-UnityRealtimeMultiplayerPart8ExploringReady-MadeNetworkingSolutions_2.png)\n\nRelay는 Unity Transport (UTP)와 함께 작동합니다. 이를 통해 엄격한 방화벽과 같은 라우팅 제한으로 인해 통신할 수 없는 클라이언트들이 연결할 수 있게 됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# Unity Relay 제한 사항\n\nRelay는 다음과 같은 제한 사항이 있습니다:\n\n- 현재 지역 잠금 기능이 없습니다. 요청을 처리할 수 있는 용량이 있는 경우 누구나 어느 지역에서든 할당 요청을 할 수 있습니다.\n- Relay 서비스는 모든 트래픽을 선택한 호스트 지역을 통해 라우팅합니다. 따라서 지역 간 통신은 최적의 지연 시간을 제공하지 않을 수 있습니다.\n- 한 게임 세션 내에서 최대 100명의 플레이어가 호스트에 참여할 수 있습니다.\n- Relay 서비스는 네트워크 트래픽을 제어하기 위해 속도 제한을 사용합니다. \"할당 생성\", \"참여 코드 생성\", \"Relay 참여\" 및 \"지역 리스트\" 요청에 대해 분당 60개의 요청 제한이 설정됩니다. 이 제한은 각 인증된 플레이어에 적용됩니다.\n\n제한 사항이 있지만, Relay 서비스는 플레이어 연결을 간편화하고 원활한 멀티플레이어 게임 경험을 제공하는 강력한 도구입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# GameObjects를 위한 Netcode\n\nRelay의 메인 게임 네트워크 코드를 위한 가장 인기 있는 두 가지 솔루션은 Netcode for GameObjects (NGO)와 API Mirror Networking이 있습니다.\n\n대부분의 경우 NGO를 사용하는 것이 권장되는 최상의 방법이며, 네트워크 변수, 씬 관리, 원격 프로시저 호출 (RPC), 그리고 메시징과 같은 안정적인 핵심 기능을 제공합니다. 그러나, API Mirror Networking은 NGO가 제공하는 전체 기능 세트를 요구하지 않는 게임에도 간편하고 사용하기 쉬운 기능을 제공하기 때문에 훌륭합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Image](/assets/img/2024-06-19-UnityRealtimeMultiplayerPart8ExploringReady-MadeNetworkingSolutions_3.png)\n\nPhoton Realtime은 멀티플레이어 게임용 핵심 레이어이자(그리고 Photon의 더 복잡한 네트워크 솔루션에서도) 플레이어 매칭 및 확장 가능한 방식으로 빠른 통신과 같은 문제를 다룹니다. Photon Realtime은 게임에서뿐만 아니라 더 구체적인 멀티플레이어 솔루션에서도 사용됩니다.\n\nPhoton Realtime은 퓨전이나 퀀텀 솔루션에서 찾을 수 있는 게임 상태 및 시뮬레이션 동기화 메커니즘을 포함하지 않고 대신 네트워크 상의 메시지 전송에 초점을 맞춥니다.\n\nPhoton Realtime이라는 용어는 또한 클라이언트와 서버 간 상호 작용을 정의하는 API, 도구 및 서비스의 포괄적인 프레임워크를 포함합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n모든 Photon Realtime 클라이언트는 세 가지 명확한 작업으로 나뉜 전용 서버 시퀀스에 연결합니다: 인증 및 지역 배포 (Name Server), 플레이어 매칭 (Master Server) 및 게임 플레이 (Game Server). 이러한 서버들은 Realtime API를 통해 관리되므로 걱정할 필요가 없습니다. 하지만 이러한 서버에 대한 이해는 확실히 도움이 될 수 있습니다.\n\nPhoton Cloud는 Photon Realtime 클라이언트를 위한 글로벌 호스팅을 제공하는 완전한 관리형 서비스입니다. 게임 코드는 Photon Cloud와 통신하여 클라우드에 연결하고 해당 API를 사용하여 연결, 무작위 방 참가 또는 이벤트를 발생시키는 등의 작업을 수행합니다.\n\nPhoton Realtime에서는 방 데이터를 쉽게 저장하고 로드할 수 있으며, 웹훅을 설정하여 Photon Cloud를 외부 웹 서버에 연결할 수도 있습니다.\n\n# Photon Fusion\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![image](/assets/img/2024-06-19-UnityRealtimeMultiplayerPart8ExploringReady-MadeNetworkingSolutions_4.png)\n\n포톤 퓨전은 Unity를 위한 네트워크 상태 동기화를 위한 새로운 고성능 라이브러리입니다. 두 가지 주요하게 다른 네트워크 토폴로지를 지원하며, API 하나를 사용하여 네트워크 연결이 없는 경우에도 플레이어 한 명을 위한 모드를 지원합니다.\n\nFusion은 Unity 워크플로에 통합하기 쉽도록 설계되었으며, 데이터 압축, 클라이언트 측 예측, 지연 보상 등의 고급 기능을 해당 제품에 기본으로 제공합니다.\n\n예를 들어 Fusion에서 RPC 및 네트워크 상태는 MonoBehaviour 메서드 및 속성에 속성을 사용하여 정의되므로 명시적 직렬화 코드가 필요하지 않으며, 네트워크 오브젝트는 Unity 프리팹의 최신 기능을 모두 사용하여 정의할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n퓨전은 최신 압축 알고리즘을 사용하여 대역폭 요구량을 줄이고 프로세서에 미미한 오버헤드를 발생시킵니다. 데이터는 완전 압축된 스냅샷으로 전송되거나 후속 일관성을 보장하는 부분 블록으로 전송됩니다. 후자의 경우, 매우 큰 플레이어 수를 지원하는 맞춤형 관심 영역 시스템이 제공됩니다.\n\n퓨전은 틱 기반 시뮬레이션을 구현하며 공유 모드 또는 호스트 모드에서 운영됩니다. 주요 차이점은 네트워크 개체에 대한 권한이 누구에게 있는지이지만 이로 인해 사용 가능한 다른 SDK 기능이 결정됩니다.\n\n퓨전은 유니티 (볼트 및 PUN)용 기존 포톤 제품 두 개를 대체하기 위해 개발되었습니다. 퓨전의 중요한 핵심 구성 요소는 NetworkRunner와 NetworkObject입니다. NetworkRunner는 퓨전의 핵심으로 간주될 수 있습니다 - 장면에 있는 하나의 러너가 네트워크 작업과 시뮬레이션을 관리합니다.\n\n퓨전은 빠른 게임 또는 프로토타입 생성을 위해 다양한 사전 구축된 NetworkBehaviours를 제공합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nFusion은 입력 처리를 두 단계로 구분합니다: 로컬 하드웨어에서 입력을 수집하고 구조체에 넣은 다음 해당 입력을 읽어 게임 상태를 변경합니다(시뮬레이션을 진행).\n\nFusion은 일반 Fusion 입력 또는 [Networked] 속성 사용이 가장 실용적인 해결책이 아닌 경우에 RPC(Remote Procedure Calls)를 지원합니다. Fusion을 시작하는 방법은 Fusion 시작 가이드를 공부하는 것을 권장합니다.\n\n# Photon Quantum\n\n![이미지](/assets/img/2024-06-19-UnityRealtimeMultiplayerPart8ExploringReady-MadeNetworkingSolutions_5.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n포톤 퀀텀은 멀티플레이어 게임용으로 완전한 결정론적 엔진입니다. 예측/롤백 방식에 기반한 이 엔진은 딜레이에 민감한 온라인 게임에 완벽하게 적합합니다. 액션 RPG, 스포츠 게임, 대전 게임, FPS 등과 같은 게임들에 특히 유용합니다.\n\n이 엔진을 사용하면 넷코드가 필요하지 않습니다. 모든 게임 요소가 기본적으로 네트워크로 연결되고 100% 동기화됩니다. 여러 연결된 플레이어가 있는 한 시뮬레이션을 만들어야 하며, 이는 로컬 멀티플레이어 경험을 개발할 때와 같습니다. 퀀텀의 결정론적 서브시스템은 각 클라이언트에서의 시뮬레이션이 물리학, 봇, 경로탐색, 애니메이션을 포함하여 항상 동기화되고 딜레이 없이 동작함을 보장합니다.\n\n![이미지](/assets/img/2024-06-19-UnityRealtimeMultiplayerPart8ExploringReady-MadeNetworkingSolutions_6.png)\n\n결정론적인 게임은 치팅에 저항력이 내재되어 있습니다. 치트에 대항하기 위한 가장 효과적인 방법은 재생 또는 서버-판정 시뮬레이션을 확인하는 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n플레이어 입력은 Photon Cloud 서버로 전송되어 다른 플레이어들 사이에 분산됩니다. 웹훅(Webhooks)을 사용하면 자체 백엔드와 플러그인을 연결하여 서버 측에서 사용자 정의 코드를 실행할 수 있습니다.\n\nPhoton Quantum은 ECS 아키텍처(ECS architecture)로 구축되었으며, PC, 콘솔, VR 및 모바일 기기에서 심도 있는 멀티플레이어 게임조차 뛰어난 성능을 보장합니다.\n\nQuantum에서 인코딩된 시뮬레이션은 Unity에 종속성이 없어 어디에서든 실행할 수 있습니다. 모든 로컬 동작은 지연 없이 수행되며, 원격 입력은 예측되고 롤백됩니다. Quantum은 리플레이(replays)를 볼 수 있는 기능을 갖고 있습니다. 리플레이는 백엔드에 저장되거나 게임 내에서 사용할 수 있습니다. 시작하려면 Quantum 100 시리즈를 확인해보세요.\n\n# 노름코어(Normcore)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-06-19-UnityRealtimeMultiplayerPart8ExploringReady-MadeNetworkingSolutions_7.png\" />\n\nNormcore는 Unity 기반 프로젝트에 멀티플레이어 모드를 추가하는 데 사용할 수 있는 고성능 도구입니다. Normcore에는 네트워크 물리학, 지속적인 공간, 음성 채팅 및 XR 지원이 포함되어 있습니다.\n\nRealtimeTransform 컴포넌트를 추가하면 Normcore는 모든 객체 변환을 자동으로 동기화합니다. 이를 위해 코딩이 필요하지 않습니다. 추가로 Normcore는 상태에 따른 보간 및 안정적인 네트워크 물리학을 제공하여 모든 연결에서 완벽한 움직임을 보장합니다.\n\nNormcore의 주요 장점 중 하나는 WebRTC를 기반으로 한 빠른 데이터 전송입니다. 전송 중 단편화를 발생시키지 않는 최대 패킷 크기를 사용하여 데이터 전송 프로세스를 가속화합니다. Normcore의 모든 데이터 패킷은 기본적으로 암호화되어 있어 사용자 데이터의 보안과 기밀성을 보장합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n노름코어는 델타 업데이트 시스템을 사용합니다. 이는 마지막 데이터 패킷이 전송된 이후의 모든 변경 사항을 추적하고, 새로운 패킷을 전송할 때 어떤 것을 포함해야 하는지 이미 알고 있는 것을 의미합니다. 이를 통해 자원을 절약하고 성능을 향상시킵니다. 노름코어의 데이터 직렬화 기능은 CPU 사용량 최적화를 가능하게 합니다. 모든 직렬화 코드는 프로젝트 컴파일 전에 자동으로 생성되어 빠르고 효율적인 자원 사용을 보장합니다.\n\n노름코어 서버는 전 세계 지역에서 운영되며 사설 광섬유 네트워크를 통해 연결되어 지연시간이 낮습니다. 노름코어를 자체 서버에 호스팅하거나 노름코어가 클라우드 인프라의 사본을 호스팅하도록 허용할 수 있습니다.\n\n# 이미지\n\n![이미지](/assets/img/2024-06-19-UnityRealtimeMultiplayerPart8ExploringReady-MadeNetworkingSolutions_8.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nMirror Networking은 Unity용 고수준 네트워크 라이브러리로, 사용 편의성과 신뢰성을 최적화했습니다. 이 라이브러리는 네트워크 연결을 다루는 과정을 간단하게 만들어 개발자가 프로젝트 작성에 집중할 수 있도록 설계되었습니다.\n\nMirror Networking은 12가지 이상의 저수준 프로토콜과 호환되며 지속적으로 발전하고 개선됩니다. 네트워크를 통한 원격 프로시저 호출 및 컨텍스트 관리를 위한 기능을 포함하며 네트워크 애플리케이션에서 물리 작업을 지원합니다.\n\n이 라이브러리는 12가지가 넘는 기본 제공 네트워크 어댑터와 다섯 가지의 네트워크 관리 시스템 옵션을 제공하여 개발자가 사용자 정의 버전을 만들 수 있습니다. 학습 및 코딩 프로세스를 용이하게 하기 위해 여러 완전한 사용 예제도 포함되어 있습니다.\n\n# Nakama\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![FishNet image](/assets/img/2024-06-19-UnityRealtimeMultiplayerPart8ExploringReady-MadeNetworkingSolutions_9.png)\n\n히로익 랩스의 나카마(Nakama)는 사용자가 전체 인프라를 하나의 오픈 패키지로 소유할 수 있는 인기 있는 오픈 소스 게임 서버입니다. 나카마에는 필요한 모든 실시간 게임 API 및 소셜 및 경쟁 기능이 포함되어 있습니다.\n\n게임에 필요한 모든 기능을 갖춘 나카마는 실시간 멀티플레이어 및 소셜 및 경쟁 기능과 같은 모든 필수 기능을 제공하므로 Go, TypeScript 및 Lua를 사용하여 클라이언트 및 서버 측의 모든 측면을 사용자 정의할 수 있습니다. 나카마를 사용하면 실시간 멀티플레이어 경쟁 게임을 생성하고 매칭 알고리즘을 사용자 정의하며 매일 보상을 추가하고 리더보드를 생성하며 게임 내 통화를 구현하고 실시간 채팅을 제공할 수 있습니다.\n\n# FishNet\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Image](/assets/img/2024-06-19-UnityRealtimeMultiplayerPart8ExploringReady-MadeNetworkingSolutions_10.png)\n\nFish-Networking은 무료 오픈 소스 라이브러리로, Unity에서 개발된 네트워킹 솔루션을 제공하는 것입니다. 이는 경험 많은 게임 디자이너가 개발했으며, 일반적으로 유료 솔루션에서만 사용할 수 있는 많은 기능을 제공합니다.\n\nFish-Networking의 주요 장점은 대역폭 및 리소스 최적화(서버 비용 절감), 수십 명에서 수백 명까지의 많은 플레이어를 지원하며, 클라이언트 예측, 지연 보상, 서버 부하 분산, 중첩 네트워크 객체 지원 등의 내장 기능이 있습니다.\n\n# 솔루션 개요\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래 표는 유니티에서 게임 개발을 위한 다양한 네트워크 솔루션을 프로토콜 사용, 지원되는 위상들, 세션 당 최대 플레이어 수, 최소 지원 유니티 버전 및 현재 상태로 비교하여 제공합니다.\n\n![테이블](/assets/img/2024-06-19-UnityRealtimeMultiplayerPart8ExploringReady-MadeNetworkingSolutions_11.png)\n\n다양한 솔루션을 통해 개발자들은 자신의 특정 요구 사항에 맞는 도구를 선택할 수 있습니다. 많은 솔루션이 서로 다른 유형의 위상을 지원하므로 게임의 특정 요구 사항에 적응할 수 있습니다. Photon PUN, Photon BOLT, UNET과 같은 일부 오래된 네트워크 솔루션은 새 프로젝트에 사용하지 않는 것이 좋으며, Netcode for Entities 및 Netcode for GameObjects는 아직 실험적이거나 프리 릴리스 단계에 있어서 제작용으로 사용할 수는 없습니다.\n","ogImage":{"url":"/assets/img/2024-06-19-UnityRealtimeMultiplayerPart8ExploringReady-MadeNetworkingSolutions_0.png"},"coverImage":"/assets/img/2024-06-19-UnityRealtimeMultiplayerPart8ExploringReady-MadeNetworkingSolutions_0.png","tag":["Tech"],"readingTime":15}],"page":"41","totalPageCount":116,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":2},"__N_SSG":true}