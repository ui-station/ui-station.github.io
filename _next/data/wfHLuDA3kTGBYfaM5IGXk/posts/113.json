{"pageProps":{"posts":[{"title":"런던 마라톤의 역사를 데이터로 만나보세요","description":"","date":"2024-05-17 19:02","slug":"2024-05-17-TheHistoryoftheLondonMarathonToldbytheData","content":"\n![이미지](/assets/img/2024-05-17-TheHistoryoftheLondonMarathonToldbytheData_0.png)\n\n몇 달 전, 저는 미국 마라톤과 관련된 이십 년의 데이터를 탐구하는 일련의 기사를 작성했습니다.\n\n그 시리즈의 일부로, 저는 미국에서 열리는 세 개의 세계 마라톤 메이저인 보스턴, 시카고, 뉴욕에 대해 깊이 파헤쳤습니다.\n\n당시 일부 독자들은 런던 마라톤의 역사에 대해 물었지만, 제 초점은 미국 마라톤에 있었습니다. 이는 편의상 그랬다고 할 수 있습니다. 미국 마라톤에 대한 데이터에 쉽게 접근할 수 있었지만 전 세계의 레이스에 대한 데이터를 수집하는 것은 더 어려워지고 있었기 때문입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n하지만 제 할 일 목록에 있었어요. 그리고 지난 주말에 런던 마라톤이 열려서, 마침내 이를 처리하기에 좋은 시기인 것 같아요.\n\n그렇다면 데이터는 런던 마라톤의 역사와 지난 몇 십 년간 어떻게 변화했는지에 대해 우리에게 무엇을 말해줄까요?\n\n# 사용 데이터는 무엇인가요?\n\n이 분석에서는 Athlinks의 데이터를 사용했습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그들의 데이터베이스에는 2001년부터 시작된 런던 마라톤 개인 결과가 포함되어 있습니다. 런던 마라톤 웹사이트에는 일부 오래된 경주 결과가 있지만, 해당 결과는 2014년부터의 것만 있습니다.\n\n저는 Athlinks에서 각 참가자의 성별, 나이 및 완주 시간을 수집한 후, Python의 Pandas 패키지를 사용하여 데이터를 분석하였습니다.\n\n나이가 보고된 방식에 일관성이 없는 것이 있었습니다. 많은 해에 걸쳐, 참가자의 나이를 해당 연령 그룹의 시작으로 내림하여 기재한 것으로 보입니다. 20대의 참가자는 18세(18~39세 범위)로 보고되었습니다. 그래서 저는 참가자들을 40세 미만부터 시작해서 5년 단위 연령 그룹을 거쳐 80세 이상까지 범주화했습니다.\n\n2006년의 데이터에는 뭔가 이상한 것이 있는 것으로 보입니다. 40대의 참가자들이 40세로 보고되어, 그들은 40세 이하 연령 그룹에 포함된 것으로 보입니다. 그래서 해당 연도의 연령 데이터 옆에 정신적인 별표를 해 주세요. 그러나 나머지 연도는 신뢰할 만한 것으로 보입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 데이터를 통해 몇 가지 질문을 탐색해 볼 수 있어요:\n\n- 이 경주가 몇 년 동안 어떻게 성장했나요?\n- 러너들의 연령과 성별과 같은 인구 통계가 어떻게 변화했나요?\n- 러너들이 더 빠르거나 느려졌거나, 아니면 비슷했는지?\n\n그러면 자세히 알아보도록 할게요.\n\n# 시간이 흘러 필드가 어떻게 변화했는가\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n현대 런던 마라톤의 첫 대회는 1981년에 열렸어요.\n\n주최자들은 뉴욕 시티 마라톤에서 영감을 받았어요 — 작은 대회에서 대규모 참가 이벤트로의 전환을 주도한 데서 따왔으니까 적절한 선택이었죠.\n\n런던은 Polytechnic Marathon과 함께 자체적인 풍부한 마라톤 역사를 가지고 있어요. 그러나 대부분의 오래된 마라톤과 같이 몇 백 명 이상은 참여하지 않는 작은 이벤트였어요.\n\n런던 마라톤은 이를 바꿨어요. 첫 런던 마라톤에는 6,000명 이상의 러너가 완주했고, 1980년대를 통해 대규모로 성장했어요. 단 두 번째 해에만 뉴욕보다 많은 완주자가 있었답니다. 비록 뉴욕이 가장 큰 마라톤의 왕관을 되찾았지만, 그 이후 런던은 전 세계에서 가장 큰 레이스 중 하나가 되었어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 마라톤의 성장\n\n따라서 이 맥락을 고려하면 데이터를 자세히 살펴보겠습니다.\n\n매년 몇 명이 런던 마라톤을 완주하나요? 그리고 2001년 이후로 그 수는 어떻게 변했나요?\n\n지난 스무 해 동안에는 완주자 수가 조금씩 늘고 있는 것을 볼 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n2001년에는 거의 30,000명의 참가자가 있었습니다. 몇 년 동안 변동이 있지만, 2019년까지 꾸준히 증가하다가 레이스가 40,000명을 초과하는 성장이 이루어졌습니다.\n\n그 성장세는 2020년에 코로나19로 중단되었습니다. 세계적으로 일시 중단된 이 시기에도 런던에서는 60명의 엘리트 선수들을 위한 소규모 이벤트가 열렸지만, 대규모 마라톤은 개최되지 않아서 차트에서는 빠져 있습니다.\n\n하지만 2021년에는 빠르게 회복되었고, 2023년까지는 2019년에 세운 이전 최고 기록을 훌쩍 넘는 종료자 수를 기록했습니다. 레이스는 거의 50,000명에 이르는 종료자를 기록했는데, 이는 세계에서 가장 큰 마라톤 대회 목록 상위에 위치하게 됐습니다.\n\n## 여성 참가자 증가\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n런던 마라톤에 여성이 처음으로 참가한 것은 있었지만, 여성들의 러닝은 아직 어린 나이였습니다. 여성 이벤트가 올림픽에 포함된 것은 1984년에 이루어졌죠.\n\n80년대와 90년대를 통해, 마라톤은 여전히 남성들에 의해 주도되었지만, 천천히 변화하기 시작했습니다. 지난 20년 동안, 여성들의 마라톤 참가는 급격하게 증가했습니다.\n\n이런 변화가 런던에서는 어떻게 나타났을까요?\n\n위 시각화 자료는 완주자 수를 보여줍니다 — 빨간 막대는 남성을, 초록 막대는 여성을 나타냅니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n청색 선은 여성 참가자들이 차지하는 비율을 나타냅니다.\n\n초반에는 남성이 압도적이었습니다. 2001년에는 마친 참가자들 중 23%만 여성이었습니다.\n\n하지만 여성 수는 2001년의 약 6,000명에서 상당히 증가했습니다. 2010년에는 거의 두 배로 늘었습니다. 2023년에는 세 배가 넘게 증가했고, 여성 참가자 수가 20,000명을 처음으로 넘어섰습니다.\n\n이 기간 동안 백분율도 지속적으로 증가했습니다. 2019년 이후 상대적으로 안정되어 왔으며, 최근 몇 년 동안은 완주자의 약 40%가 여성이었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n레전드에서 '여성'을 클릭하면 해당 막대를 숨기고 분야의 남성 부분을 격리할 수 있습니다. 흥미로운 점은 지난 20년간의 남성 완주자 수가 꾸준히 유지되어 왔다는 것입니다.\n\n2023년에는 28,000명이 넘는 남성 완주자가 발생한 급증이 있었지만, 나머지 시기는 20,000명에서 25,000명 사이로 변동했습니다. 본질적으로 경주의 성장은 거의 모두 여성들로부터 왔습니다.\n\n## 분야의 점차적 그레이징\n\n보스턴 마라톤의 데이터를 분석할 때, 러너들이 나이를 먹고 있다는 것을 알게 되었습니다. 이 패턴은 다른 경주에서도 나타나고 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n런던에서도 비슷한 일이 일어나고 있나요?\n\n이 차트에서 각 색상은 서로 다른 연령 그룹의 완주자 수를 나타냅니다. 연령 그룹은 가장 어린 사람(40세 미만)이 왼쪽에 있고 가장 나이 많은 사람(80세 이상)이 오른쪽에 있습니다.\n\n이전에 언급한 대로, 2006년의 소스 데이터에 문제가 있습니다. 그러므로 그곳에서 보이는 이상치를 무시하십시오. 러너들의 연령이 결과 집합에서 잘못 표시되었기 때문일 가능성이 높습니다.\n\n드롭다운 메뉴를 사용하여 남성과 여성을 번갈아 선택할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n남성들 중에서, 조깅을 하는 총 인원은 (2023년을 제외하고) 크게 변하지 않았어요.\n\n40대 초반의 남성(보라색) 인원은 처음 몇 년 동안 늘어났다가, 이후에는 4,000명 정도에서 안정되는 것으로 보입니다. 다만, 다른 연령 그룹(45-49세 이상)은 시간이 흐를수록 계속해서 늘어나는 추세입니다.\n\n여성들 중에서는, 2001년부터 2023년까지 전체 참가자 수가 계속해서 늘어나면서, 상대적인 변화를 파악하기 어려워요. 중장년 러너들이 더 많아지고 있지만, 20대와 30대 러너들도 늘어나고 있어요.\n\n그래프의 대체 버전은 각 연령 그룹을 전체 성별 인원의 백분율로 표시하고 있어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여기서 젊은 남성의 비율이 천천히 감소하는 것과 비교하여 45세 이상의 남성 비율이 천천히 증가하는 것이 더 쉽게 볼 수 있어요.\n\n여성 중에서는 변화가 더 극심해요. 초기에는 여성 중 3분의 2가 40세 미만이에요. 하지만 마지막에는 이 비율이 50%에 가까워지고, 모든 연령 그룹에서 증가했어요.\n\n이 변화는 코로나 이후에 더욱 확대됐어요. 2023년에는 여성 중 10% 이상이 55세 이상이었는데, 2001년에는 5% 미만이었어요.\n\n이러한 변화를 볼 수 있는 한 가지 방법은 각 연령 그룹 중 여성 비율을 그래프로 나타내어 시간이 지남에 따라 어떻게 변하는지 보는 것이에요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n조건부 분석에 대한 그래프와 같이 여기서 빨간색은 남성을 나타내고 초록색은 여성을 나타냅니다. 파란색은 여성 참가자의 백분율을 보여줍니다. 다른 점은 연령 그룹별로 분리되어 있다는 것입니다. 슬라이더를 드래그하거나 재생 버튼을 눌러 시간이 지남에 따라 어떻게 변하는지 살펴볼 수 있습니다.\n\n시간이 지남에 따라 여성 백분율이 증가하지만 언제나 젊은 연령 그룹 중에서 더 높습니다. 그러나 시간이 흐름에 따라 차이가 상당히 줄어듭니다.\n\n2019년까지, 20대, 30대, 40대 및 50대의 참가자들 간의 차이가 훨씬 줄어들었습니다. 2023년으로 빨리 이동하면, 이러한 연령 그룹 모두 유사한 비율을 가지고 있습니다 — 남성 60%와 여성 40% 정도입니다.\n\n시간이 지남에 따라 남성과 여성 사이의 참가자들 간의 균형이 더 맞추어졌지만, 변화가 되기 까지는 최고 연령 그룹에 따라 따라잡는 시간이 필요했습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 런던 마라톤의 완주 시간\n\n마침내, 완주 시간은 어떻게 변화했나요?\n\n런던은 악명높은 빠른 코스이며, 한 개 이상의 세계 신기록이 세워졌습니다.\n\n## 역대 우승자들\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래 시각화는 매년 남성 (빨강)과 여성 (녹색)의 우승 시간을 그래프로 표시합니다.\n\n남성들 중에는 약간의 하향 트렌드가 있습니다. 초기에는 남성 우승자들이 모두 2:06에서 2:07 범위에 있었습니다. 2008년 이후 대부분의 우승자들이 2:05 또는 더 빨리 완주했지만 더디게 완주한 해도 몇 해 있었습니다.\n\n남성 중에서 가장 빠른 시간은 2023년에 있었는데, 켈빈 킵툼이 2:01:25로 완주했습니다.\n\n한편, 여성은 2003년에 최고의 시간을 보였습니다. 그 해, 폴라 래드클리프가 2:15:25로 우승했습니다. 그녀는 2019년까지 계속되는 세계 신기록을 세웠습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그 경주에서 여자 엘리트 선수들은 레드클리프를 자극하여 그러한 뛰어난 시간을 선보이도록 돕는 남성 페이서들과 함께 출발했습니다. 이 종류의 경주가 올해 읽었을 수도 있는 “혼성”과 “여성 전용” 세계 기록 사이의 차이의 이유입니다. 2003년 경주 중계를 여기서 시청할 수 있습니다.\n\n최근 몇 년간 여자 우승자는 종종 2:17부터 2:18 정도의 시간대에 올랐습니다 — 많은 해보다는 빠르지만 레드클리프의 2003년 시간보다는 빠르지 않습니다.\n\n## 총 평균 완주 시간\n\n하지만 우리는 일반인이고, 로마 마라톤에서 우승하는 것은 아닙니다. 더 흥미로운 질문은 그들 뒤의 일반 대중들 사이에서 무슨 일이 벌어지고 있는지입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 그래프는 경기장의 세 지점에서의 완주 시간을 보여줍니다 — 90번째 백분위수 (다른 선수들보다 90% 이상 빠른 선수), 75번째 백분위수 (다른 선수들보다 75% 이상 빠른 선수), 그리고 중앙값(팩의 중간에 있는 선수).\n\n전체 필드를 보는 것은 속임수가 될 수 있습니다. 왜냐하면 인구 통계의 급격한 변화가 평균 시간에 영향을 미칠 수 있기 때문입니다.\n\n하지만 이 그래프가 보여주는 것은 2018년에 날씨가 얼마나 나빴는지라는 것입니다. 그 해가 기록상으로 가장 더운 경주였고, 2007년도 그다지 뒤떨어지지 않았습니다. 이 두 해에 그래프가 솟은 이유가 분명히 그것 때문일 것입니다.\n\n## 성별을 고려한 경우\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n결과를 성별로 세분화하면 가능한 추세를 식별할 수 있어요. 나이는 여전히 잠재적으로 혼동을 줄 수 있는 변수이지만, 인구통계학적 변화 중 가장 큰 변화가 성별 사이에서 일어났어요.\n\n세 줄은 동일한 장소를 나타내지만, 이 시각적으로 빨간 점은 남성이고 초록 점은 여성이에요.\n\n특히 더 빠른 남성들 중에서 시간이 개선되고 있어요. 최고의 여성 선수들 중에서는 약간의 개선이 있지만, 느린 여성 선수들 중에서는 트렌드가 보이지 않는 것 같아요.\n\n## 나이의 느려짐을 고려하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그럼 만약 연령과 성별로 모두 자세히 살펴본다면 어떨까요?\n\n이 시각적 자료를 통해 여성들의 세 가지 포지션을 왼쪽에서, 남성들의 세 가지 포지션을 오른쪽에서 확인할 수 있습니다. 그러나 위쪽의 버튼들을 사용하여 결과를 연령 그룹으로 필터링할 수 있습니다.\n\n젊은 남성들 중에서는 최근 몇 년 동안 시간이 분명히 개선되었습니다. 마지막에는 상위 10%가 3시간 15분에서 3시간 20분 아래로 개선되었습니다. 젊은 여성들도 약간 개선되었는데, 특히 2012년부터 개선되었습니다. 마지막에는 상위 10%가 3시 30분대에 마칩니다.\n\n연령 그룹이 높아짐에 따라 40대와 50대에서 약간의 하향 추세가 보입니다. 그 이상으로 올라가면 약간 무작위로 보이기 시작합니다. 그때 연령 그룹이 충분히 작아서 매년 안정적인 관계가 되기 힘들 수도 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만약 이 시간들을 미국 메이저 대회인 보스턴, 뉴욕, 그리고 시카고의 시간과 비교한다면, 런던의 시간들은 보스턴과 시카고 사이에 위치하게 될 거에요. 보스턴의 시간들은 런던의 것보다 빠르며(아마도 더 많은 예선 참가자 수에 의해), 그러나 런던의 시간들은 시카고의 것보다 빠르죠.\n\n하지만 조금 이상한 것은 2019년 이후에는 큰 차이가 없다는 거에요. 대부분의 대규모 미국 대회에서는 이 지점에서 시간이 크게 단축되었거든요. 저는 항상 대량 시장에 슈퍼 슈즈가 확산되고 있다는 것이 이 현상을 촉진하고 있다고 가정했었어요.\n\n하지만 이 효과는 런던에는 존재하지 않는 것으로 보여요.\n\n# 런던 2024는 어디에 속할까요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그래서 그것이 역사이자 기반이 되었습니다.\n\n이제 지난 스물 해간 동안 런던에서 어떤 변화가 있었는지를 알게 되었으니, 이번 해 레이스의 데이터를 자세히 살펴보겠습니다.\n\n올해 참가자가 더 많아졌을까요? 성별로 더 균형을 이루었을까요? 참가자들은 더 나이가 많아졌을까요?\n\n해당 분석 결과는 일주일 후쯤 다시 확인해주세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만약 위에 대한 관심이 있다면 — 또는 다른 말로 말해, 마라톤에 관한 데이터 중심 이야기에 관심이 있다면 — 이메일 업데이트를 받기 위해 구독하는 것을 잊지 마세요.\n\n저는 열렬한 러너이자 데이터 애호가입니다. 올해의 보스턴 마라톤은 컷오프 타임 때문에 놓쳤지만, 2025년에는 거기 참가하기를 희망하고 있습니다. 제가 무슨 활동을 하는지 계속해서 따라갈 수 있는 방법은 다음과 같습니다:\n\n- 저의 훈련에 대한 소식을 들으려면 Running with Rock을 팔로우하세요.\n- 마라톤 훈련 계획 선택에 대한 이 팁들을 읽어보세요.\n- Strava에서 저를 쫓아보세요.\n","ogImage":{"url":"/assets/img/2024-05-17-TheHistoryoftheLondonMarathonToldbytheData_0.png"},"coverImage":"/assets/img/2024-05-17-TheHistoryoftheLondonMarathonToldbytheData_0.png","tag":["Tech"],"readingTime":14},{"title":"Read the Docs 트래픽 분석을 위해 Vizro-AI를 활용한 재사용 가능한 대시보드를 구축했어요","description":"","date":"2024-05-17 19:00","slug":"2024-05-17-IBuiltaReusableDashboardforReadtheDocsTrafficAnalyticsUsingVizro-AI","content":"\n## (50 줄 미만의 코드로)\n\n<img src=\"/assets/img/2024-05-17-IBuiltaReusableDashboardforReadtheDocsTrafficAnalyticsUsingVizro-AI_0.png\" />\n\n이 글에서는 기술 작성자로서 유지 관리하는 문서의 트래픽 데이터를 시각화하기 위해 대시보드를 구축하는 방법을 설명하겠습니다. 디자인 스킬이 부족하고 파이썬 경험이 제한적이어서 유지하는 문서의 영향과 사용량을 보여주기 위한 간단하고 로우코드 접근 방식이 필요했습니다. 이것은 오픈 소스 솔루션인 비즈로(Vizro)를 로우코드 대시보드의 템플릿으로 사용하고, 비즈로-AI(Vizro-AI)를 통해 생성적 AI로 개별 차트를 구축하는 것으로 나타났습니다.\n\n## 요약?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만약 당신이 바로 시작하고 싶다면, 내 GitHub 레포지토리에서 대시보드에 대한 Jupyter Notebook 코드를 찾을 수 있어.\n\n## Read the Docs 대시보드 프로젝트\n\n만약 나와 같이 Read the Docs (RTD)를 사용하여 오픈 소스 문서 프로젝트를 관리한다면, 아마도 프로젝트 대시보드에서 지난 90일치의 트래픽 데이터를 CSV 형식으로 다운로드할 수 있는 것을 발견했을 것입니다. 대시보드에는 페이지 뷰 합계 차트도 표시되어 있습니다, 아래와 같은 차트가 있죠.\n\n![RTD Traffic Chart](/assets/img/2024-05-17-IBuiltaReusableDashboardforReadtheDocsTrafficAnalyticsUsingVizro-AI_1.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n추가적인 시각적 출력을 위해 Google Analytics (GA)를 활용할 수 있습니다. 그러나 일부 프로젝트에서는 유럽 연합(EU)에서 특히 논란이 되는 일반 데이터 보호 규정(GDPR)과의 준수 때문에 GA를 사용하지 않기를 선호하기도 합니다.\n\n## 코드 및 데이터 가져오기\n\n아래 예시에서 사용된 가짜 CSV 트래픽 데이터는 저희 프로젝트의 트래픽을 비공개로 유지하기 위해 OpenAI의 도움을 받아 생성한 것입니다. 이 가짜 데이터는 진짜 RTD 데이터와 동일한 필드를 가지고 있어서 RTD 대시보드에서 다운로드한 데이터로 대시보드를 다운로드하고 사용할 수 있습니다.\n\n예시를 직접 실행하려면 가짜 데이터(또는 직접 다운로드한 데이터)와 Jupyter Notebook 코드가 필요합니다. 이는 기본 수준에서 쉽게 진행할 수 있지만 보다 고급 사용자는 확장할 수 있습니다. 개선된 버전을 만드신 경우 알려주시면 감사하겠습니다!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# Vizro와 Vizro-AI란 무엇인가요?\n\nVizro는 Plotly와 Dash를 기반으로 한 프레임워크로, 사용자 정의 대시보드 레이아웃을 지정하기 위해 구성 접근법을 사용합니다. Vizro 대시보드는 Vizro와 별도로 구성된 Vizro-AI가 생성한 차트로 채울 수 있습니다. Vizro-AI는 시각화 프로세스를 단순화하기 위해 생성적 AI를 활용하는 독립적인 패키지입니다.\n\n이 예에서, 저는 데이터와 자연어 지시사항을 제공했고, Vizro-AI가 Python 코드를 생성하고 요청한 차트를 생성했습니다. 이것은 저에게 쓰기 작업을 하는 측면에서 잘 작동했습니다. 왜냐하면 저는 프론트엔드 디자인 기술이 없고 Plotly를 잘 모르기 때문입니다. 하지만 OpenAI로부터 적절한 생성적 AI 프롬프트를 작성하고 차트를 얻는 것도 즐거운 일이라고 생각합니다.\n\n## Vizro-AI 설정하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n노트북 코드를 실행하기 전에 Vizro-AI를 Python 3.9 이상의 가상 환경 안에 설정해야 합니다. pip install vizro_ai 명령을 사용하여 패키지를 설치해주세요.\n\n다음으로 OpenAI에 접속하기 위해 API 키가 필요합니다. 계정이 없다면 먼저 생성하고, 무료 버전을 사용할 수 없기 때문에 모델을 이용하기 위해 일부 크레딧을 구매해야 합니다. API 키를 생성하고 환경에 추가하여 코드를 통해 OpenAI에 성공적으로 호출할 수 있게 해주세요. OpenAI 문서에 간단한 지침이 있고, Vizro-AI LLM 설정 가이드에도 이 과정이 포함되어 있습니다.\n\n## 차트 생성\n\n이 시점에서 주피터 노트북을 열어 첫 차트를 만들거나, 제 저장소에서 노트북을 열어 내가 작성한 코드를 차례로 살펴보고, RTD 데이터(또는 제공한 가짜 데이터)를 pandas DataFrame에 불러와주세요. 아래 코드에서는 df로 이름을 지었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래 코드는 Vizro-AI에 요청을 제출하여 Read the Docs 프로젝트 대시보드의 차트와 유사한 차트를 생성하는 방법을 보여줍니다. 이 차트는 날짜별 조회수를 보여주며 문서의 안정 버전과 최신 버전으로 데이터를 분할하여 두 개의 추적 값으로 나뉩니다:\n\nVizro-AI는 \"가장 최신 및 안정 버전의 각 날짜별 조회 수 행을 결합한 후 가장 최신 및 안정 버전의 조회수를 비교하는 선 그래프를 그리세요\"라는 자연어 쿼리와 데이터프레임을 모델에 전달합니다. 위 예제에서는 gpt-4 모델을 지정했습니다. Vizro-AI는 가격이 낮고 더 빠른 답변을 제공하기 위해 기본적으로 gpt-3.5-turbo를 사용하지만, 가장 정교한 차트 제공이 불가능합니다. 그래서 명시적으로 gpt-4 모델을 사용할 것을 요청했습니다.\n\n차트 출력은 데이터 및 쿼리 제출 시점에서 OpenAI로부터 받은 출력에 따라 달라집니다. explain=True 매개변수는 Vizro-AI에게 결과 차트 생성 방식을 설명하도록 요청하며, 해당 설명은 쥬피터 노트북에서 출력되며 show() 명령어에 의해 표시되는 차트와 함께 표시됩니다.\n\nVizro-AI가 제공하는 인사이트 텍스트는 트래픽 데이터 조작 방법을 설명합니다. 코드 섹션은 코드 스니펫이 요청된 선 그래프를 생성하는 방법에 따라 표시됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-05-17-IBuiltaReusableDashboardforReadtheDocsTrafficAnalyticsUsingVizro-AI_2.png\" />\n\n아래에 표시된 차트는 다음과 같습니다:\n\n<img src=\"/assets/img/2024-05-17-IBuiltaReusableDashboardforReadtheDocsTrafficAnalyticsUsingVizro-AI_3.png\" />\n\n## 더 많은 차트 만들기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nVizro-AI가 제공하는 코드를 활용하여 추가 차트를 작성했습니다. 다음과 같이 교통량을 자세히 설명하는 몇 가지 차트를 작성했습니다.\n\nVizro-AI가 데이터를 조작하고 차트를 생성하는 코드를 생성해 주어서 작업을 간편하게 해 주었습니다. 차트 자체만으로 유용하며, 더욱 유용한 것은 이를 조합하여 한 화면에 통합된 대시보드를 만드는 것입니다.\n\n## Vizro 대시보드 만들기\n\nVizro-AI 코드와 동일한 Jupyter Notebook에서 Vizro를 사용할 수 있습니다. Vizro 설명서에 설명된대로 pip install vizro를 수행해 주세요. 여기에는 차트 생성이 없는 간단한 대시보드의 구조를 위한 코드가 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 시점에서 두 가지 옵션이 있습니다:\n\n- 대시보드를 생성할 때마다 Vizro-AI를 사용하여 차트를 생성합니다.\n- Vizro-AI가 반환한 Python 코드를 직접 Plotly로 호출합니다.\n\n첫 번째 옵션은 더 적은 코드를 필요로 하지만 반환 속도가 느리고 더 비싸며, Vizro-AI를 사용하여 OpenAI를 호출하기 때문에 더 많은 비용이 소요됩니다. 두 번째 옵션은 더 빠르지만 코드 조작이 더 많이 필요합니다.\n\n다음은 대시보드 코드를 포함하는 셀입니다. 이 코드는 Vizro-AI를 통해 호출하는 함수를 사용하여 첫 번째 옵션을 보여줍니다. (자신의 실행을 계획하고 있다면, 이 코드를 실행하려면 내 레포지토리의 노트북을 사용하고 데이터를 로드하고 Vizro-AI에 대한 호출 설정을 설정하는 셀을 실행해야 합니다):\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n약간 다른 버전을 제공해본다. 여기서 두 번째 옵션을 사용하여 차트 중 하나를 생성했다. Plotly 조작은 제한되어 있어서 Python 코드를 약간 수정하여 라인의 색을 변경했다. (여러분이 직접 실행하려는 경우, 내 저장소의 노트북을 사용하고 데이터를 로드하고 차트 생성 함수를 설정하는 셀을 실행했는지 확인하세요).\n\n자신만의 Read the Docs 데이터로 대시보드를 시도해보기 위해 주피터 노트북을 다운로드할 수 있어요. 제가 제공한 가짜 데이터로 만든 대시보드는 다음과 같이 보입니다.\n\n제 동료 중 한 명(Nadija 감사합니다!)가 제게 팁을 줬어요. 대시보드를 노트북에서 실행한 다음 다음과 같이 선택한 포트를 보고 별도의 브라우저 창에서 볼 수 있다고 해요:\n\n```js\nVizro().build(dashboard).run(port=8006) # 브라우저에서 localhost8006\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n또 다른 방법(Anthony 님 감사합니다!)으로, 위의 두 번째 대시보드 예제에서 보여 드린 대로, 대시보드를 보기 위한 클릭 가능한 링크를 생성할 수 있습니다:\n\n```js\nVizro()\n  .build(dashboard)\n  .run((jupyter_mode = \"external\"));\n```\n\n# 마무리\n\n이 예에서는 Vizro-AI를 사용하여 문서 트래픽을 시각화하기 위한 Plotly 차트를 생성하고, 그 차트를 Vizro 대시보드에 구축하는 방법을 보여드렸습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만약 데이터 과학과 파이썬 기술이 있고 디자인에 재능이 있다면, Plotly와 Dash로 대시보드를 구축하는 도전에 도전해 보고 싶을 것입니다. 하지만 이런 기술이 없는 사람들에게는 OpenAI를 활용하여 위와 같은 결과물을 얻을 수 있다는 것이 정말 큰 변화입니다. 이제 50줄 정도의 코드로 Read the Docs 트래픽 데이터에 대한 유용한 시각화를 얻었습니다. 전문적으로 보이며 확장 가능하고 상대적으로 쉽게 공유할 수 있습니다. 추가적인 노력으로 필터, 매개변수 또는 별도의 탐색 가능한 페이지와 같은 사용자 정의 기능을 추가하여 더 개선할 수 있습니다.\n\n더 나아가, 동료들과 협업하여 대시보드 코드를 다른 Read the Docs 프로젝트에 맞게 수정할 수 있습니다. 프로젝트를 쉽게 설명하기 위해 주피터 노트북을 사용했지만, 이 방식은 파이썬 스크립트에서도 잘 작동하여 쉽게 공유하고 버전 관리를 할 수 있습니다. 또한 대시보드를 배포하여 동료들이 코드를 실행하지 않고 직접 액세스할 수도 있습니다.\n\n저희 팀은 이제 하루만에 기술 작가에 의해 구축된 문서 영향을 추적하는 데 유용하고 사용할 수 있는 대시보드를 소유하고 있습니다. 더 바랄 것이 무엇이 있을까요?\n\n이 글을 작성하는 동안 여러 차례 리뷰 피드백을 주신 동료들, 특히 Nadija와 Anna 그리고 Joe에게 감사드립니다.\n","ogImage":{"url":"/assets/img/2024-05-17-IBuiltaReusableDashboardforReadtheDocsTrafficAnalyticsUsingVizro-AI_0.png"},"coverImage":"/assets/img/2024-05-17-IBuiltaReusableDashboardforReadtheDocsTrafficAnalyticsUsingVizro-AI_0.png","tag":["Tech"],"readingTime":9},{"title":"마이크로소프트의 응용 프로그램 업데이트 접근 방식의 문제가 윈도우 PC에 혼란을 야기합니다","description":"","date":"2024-05-17 18:58","slug":"2024-05-17-MicrosoftsFlawedApproachtoAppUpdatesWreaksHavoconWindowsPCs","content":"\n![image](/assets/img/2024-05-17-MicrosoftsFlawedApproachtoAppUpdatesWreaksHavoconWindowsPCs_0.png)\n\n안녕하세요! WinRAR을 설치해 두셨나요? PC가 취약할 수 있습니다. 이 문제의 근본은 Windows 8로 돌아갑니다.\n\nChris Hoffman 작성\n\n여전히 적극적으로 악용되고 있는 방대한 보안 결함을 가진 WinRAR은 자동 업데이트를 지원하지 않는 많은 Windows 애플리케이션 중 하나입니다. 개발자는 전 세계적으로 5억 개 이상의 WinRAR 설치를 자랑하며, 따라서 수억 대의 PC가 오늘날 악성 ZIP 파일로부터 취약할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n2023년에 세계에서 가장 인기 있는 데스크톱 운영 체제가 설치된 응용 프로그램을 쉽게 업데이트할 수 있는 방법을 제공하지 않는다니, 어떻게 된 일인가요?\n\nWindows 업데이트는 보안 패치를 설치하지만 여기서 그치고 있어요. 다운로드한 많은 응용 프로그램은 스스로 업데이트를 수행하지만 일부는 업데이트를 확인할 생각조차 못 합니다. Microsoft가 Windows 8을 만드느라 많은 시간을 낭비하고 나서 그 이후 Windows 10으로 넘어가며 거의 모든 Windows 사용자가 원하지 않았던 유형의 애플리케이션을 위한 스토어를 구축하려고 했으면, PC 사용자는 현명한 결정을 할 수 있었을 것입니다. Windows 스토어에 대해 잃어버린 십 년이었죠.\n\n# WinRAR이 공격 받고 스스로 업데이트하지 않아요\n\n파일 아카이빙 프로그램 WinRAR의 결함은 특수하게 디자인된 ZIP 아카이브를 다운로드하고 열면 공격자가 PC에서 원하는 코드를 실행할 수 있다는 것을 의미합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n공격자들이 2023년 초부터 이 버그를 악용해왔습니다. WinRAR 개발사 RARLAB은 8월에 이 취약점을 수정한 업데이트를 출시했지만, 수개월 후에도 여전히 이 버그에 대해 언급 중입니다. 왜냐하면 정부 지원 사이버 범죄 조직을 포함한 기관들이 여전히 이를 악용하고 있기 때문입니다. 이는 구글의 위협 분석 그룹에 따르면 \"여러 국가의 그룹들\"이라고 합니다.\n\n문제는요: WinRAR은 자동으로 업데이트되지 않습니다. 심지어 업데이트를 확인하고 사용자에게 중요한 보안 업데이트가 가능하다고 알리지도 않습니다. 많은 사람들이 오래된 업데이트되지 않은 버전의 WinRAR을 사용하고 있으며 이 패치를 설치하지 않을 것입니다. 새로운 PC를 구입하고 다시 설치할 때에만 안전한 버전의 WinRAR을 얻을 것입니다. 소망하기를 그들이 악의적인 ZIP 파일을 열지 않았으면 좋겠네요.\n\n# WinRAR이 자동 업데이트되지 않는 이유는?\n\n그렇다면 왜 자동 업데이트 기능이 없는 걸까요? 저는 RARLAB에 연락을 취해보았고 WinRAR 개발자인 Eugene Roshall은 Windows가 웹사이트에서 다운로드한 데스크톱 앱을 자동으로 업데이트할 수 있는 방법을 제공하지 않는다고 말했습니다. \"모든 개발자는 모든 보안 및 기술적 문제를 고려하여 바퀴를 다시 발명해야 합니다.\"\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n로샬은 RARLAB이 업데이트 알림을 구현하는 것을 고려해 왔지만 기업 시스템 관리자들이 이 아이디어를 좋아하지 않고 사용자 컴퓨터에 팝업 알림이 나타나는 대신 소프트웨어 업데이트에 대해 중앙 집중식 접근을 선호한다고 말했습니다.\n\n하지만 RARLAB은 어쨌든 이 기능을 추가할 수도 있으며 해당 회사는 \"Avast, Kaspersky 및 기타 업데이트 프로그램과 긴밀히 협력하고 있다\"고 말했습니다.\n\n평균적인 Windows PC의 업데이트 상황은 정말 난잡합니다. 어도비, 구글, PC 제조업체 및 다른 개발자들로부터 별도의 업데이트 서비스를 가질 가능성이 매우 높습니다. 그것이 작동하더라도 각 개발자에게는 고통이 될 뿐만 아니라 CPU 및 메모리 자원을 소모하는 많은 불필요한 백그라운드 프로세스가 있습니다.\n\n저는 개인적으로 항상 7-Zip을 선호해 왔지만, 그것도 내장된 업데이트 확인기가 없습니다!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 윈도우 8 문제의 시작\n\n윈도우 8에 '앱 스토어'가 포함될 예정이라고 처음 들었을 때, 저는 흥분했습니다.\n\n데스크톱 리눅스에 대한 경험이 있는 사람으로서, 제가 가장 좋아하는 것 중 하나는 패키지 관리자입니다. 리눅스에서는 개발자 웹사이트에서 각 애플리케이션을 다운로드하는 대신 패키지 관리자를 통해 애플리케이션을 얻습니다. 업데이트가 나오면 패키지 관리자가 업데이트를 찾아 설치해줍니다. 중앙에서 관리되며 한 애플리케이션이 모든 애플리케이션 업데이트를 확인하고 설치합니다.\n\n2011년 마이크로소프트 빌드에서 최초로 발표된 Windows Store는 윈도우 8에서 그런 종류의 경험을 제공할 수 있었을 것입니다. 그러나 마이크로소프트는 새로운 '메트로 앱'을 위한 새로운 스토어만을 제공하기로 결정했습니다. (그러나 개발자들은 전통적인 데스크톱 앱에 대한 목록을 게시하고 직접 PC 사용자를 웹사이트로 이동할 수 있었습니다.)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그보다 나쁜 것은, Windows 8 스토어가 한 때 사기 가득했다는 것이었습니다. \"VLC\" 같은 것을 검색하면 VLC를 다운로드할 위치를 보여주는 애플리케이션을 지불하라는 저금급한 결과물들로 가득찼습니다. 이 문제를 강조한 첫 번째 사람은 아니었지만, 2014년에 이 사기에 대해 강조한 것은 어디서나 Windows 사용자들의 불만을 대변했습니다. 결국, Microsoft는 2015년에 스토어를 개선하기로 약속하며 일반인들의 압력에 반응했습니다.\n\n# Microsoft은 Windows 10에서 시간을 낭비했습니다\n\nWindows 10은 Windows 8의 많은 문제를 해결했지만, 여전히 Microsoft의 불명확한 앱 전략의 피해자였습니다.\n\nWindows 10이 출시된 시점에도 스토어는 \"Universal Windows Platform\" 애플리케이션만 허용했습니다. 이것은 합리적이지 않았습니다. 그때쯤에는 Windows Phone이 사라졌으므로, 유니버설 플랫폼은 데스크톱 PC, Xbox 및 HoloLens가 되는 것인가요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nWindows 8과 Windows 10에서 PC 사용자들은 상점을 무시하도록 훈련을 받았습니다.\n\n# Windows 11은 너무 늦게 나왔습니다\n\n좋은 소식은 Windows 11이 이를 뒤집었다는 것입니다. 네, Windows 8 출시 9년 후에 마이크로소프트가 마침내 전통적인 Windows 데스크톱 애플리케이션을 데스크톱 PC 운영 체제의 앱 스토어에서 허용해야 한다고 결정했습니다.\n\n이제 개발자들은 전통적인 Windows 데스크톱 앱을 Windows 스토어에 넣을 수 있으며, PC 사용자들은 전통적인 Windows 데스크톱 앱을 설치할 수 있습니다. 스토어를 통해 응용프로그램을 중앙 집중식으로 업데이트할 수 있습니다. 하지만 우리는 다 무시하도록 훈련되었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n더 나쁜 것은 최신 Windows 11 PC에서 앱 스토어를 둘러보다가 스토어에 있는 VLC 같은 앱들이 \"제공 및 업데이트한 사람\"이라고 되어 있는 걸 발견했어요. 그래서 스토어에서 앱을 설치해도, 해당 앱이 여전히 자체 업데이트를 설치할 확률이 높아요.\n\n진짜 안타까운 일이에요. 새 PC를 설정하고 모든 앱을 자동으로 설치할 수 있으면 좋겠고요. 몇십 년 전 데스크톱 리눅스에서 할 수 있었던 것처럼 앱을 업데이트할 수 있는 단일 장소가 있으면 더 좋겠죠.\n\n# 전문가들은 다른 옵션을 가지고 있어요\n\n전문가들은 소프트웨어 업데이터 유틸리티나 winget, Chocolatey 같은 패키지 매니저를 활용할 수 있어요. 그러나 일반 Windows PC 사용자들은 여전히 웹사이트에서 프로그램을 다운로드하고 설치하고 있어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n차트 태그를 마크다운 형식으로 변경해 주세요.\n\n벌써 윈도우 데스크톱에서 이 문제들을 해결하는 최선의 방법이 스토어인지는 아마도 아닐 거예요. 하지만 만약 마이크로소프트가 지난 10년 동안 스토어를 진지하게 대하고 일반 PC 사용자와 그들이 실제로 사용하는 애플리케이션을 위해 사용할 만한 수준으로 만들려고 노력했다면, 우리는 해결책에 훨씬 가까웠을 거에요.\n\n적어도 윈도우 11은 RAR, 7Z 및 다른 아카이브 형식에 대한 내장 지원을 얻었기 때문에 WinRAR 및 7-Zip과 같은 애플리케이션을 업데이트하는 걱정 없이 제거할 수 있게 됐어요. 제 생각에는 그것이 발전이에요.\n\n원문 게시 위치: https://www.pcmag.com.\n","ogImage":{"url":"/assets/img/2024-05-17-MicrosoftsFlawedApproachtoAppUpdatesWreaksHavoconWindowsPCs_0.png"},"coverImage":"/assets/img/2024-05-17-MicrosoftsFlawedApproachtoAppUpdatesWreaksHavoconWindowsPCs_0.png","tag":["Tech"],"readingTime":7},{"title":"윈도우 컨셉트 저니 - wow64windll Wow64 콘솔 및 Win32 API 기록","description":"","date":"2024-05-17 18:57","slug":"2024-05-17-TheWindowsConceptJourneywow64windllWow64ConsoleandWin32APILogging","content":"\n일반적으로 \"wow64.dll\"(Win32 콘솔 및 Win32 API 로깅)은 WOW64에서 사용되는 동적 링크 라이브러리입니다. \"%windir%\\system32\\wow64win.dll\"에 위치한 64비트 이진 파일입니다. 이 DLL 파일은 Microsoft에 의해 디지털로 서명되었습니다.\n\n요약하면, \"wow64win.dll\"은 \"win32k.sys\" 진입점 함수들을 제공합니다(https://learn.microsoft.com/en-us/windows/win32/winprog64/wow64-implementation-details). 따라서 이는 \"win32k.sys\"에서 노출된 관련 시스콜을 호출하기 위해 사용됩니다(\"NtGdi*\" 또는 \"NtUser*\"로 시작되는 것과 같은 것들) — 아래 스크린샷에서 보여지는 대로(무료 버전의 IDA를 사용하여 캡처했습니다).\n\n마지막으로, DLL의 특성을 고려하면 원래 파일 이름은 \"wow64lg2.dll\"임을 알 수 있습니다 — 아래 스크린샷에서도 확인할 수 있습니다. 또한, \"wow64.dll\" (https://medium.com/@boutnaru/the-windows-concept-journey-wow64-dll-win32-emulation-on-nt64-8ff99ec32c43)은 \"wow64win.dll\"에 종속되어 있습니다. 따라서 일반적으로 user32.dll을 로드하지 않는 \"비 Windows 서브시스템\" 프로세스에서도로드될 수 있습니다(https://wbenny.github.io/2018/11/04/wow64-internals.html).\n\n다음 글에서 뵙겠습니다;-) 트위터에서 팔로우할 수 있으세요 — @boutnaru (https://twitter.com/boutnaru). 또한 다른 글을 읽고 싶으시면 미디엄에서 확인 가능합니다 — https://medium.com/@boutnaru. 무료 eBook은 https://TheLearningJourneyEbooks.com에서 찾을 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![2024-05-17-TheWindowsConceptJourneywow64windllWow64ConsoleandWin32APILogging_0.png](/assets/img/2024-05-17-TheWindowsConceptJourneywow64windllWow64ConsoleandWin32APILogging_0.png)\n","ogImage":{"url":"/assets/img/2024-05-17-TheWindowsConceptJourneywow64windllWow64ConsoleandWin32APILogging_0.png"},"coverImage":"/assets/img/2024-05-17-TheWindowsConceptJourneywow64windllWow64ConsoleandWin32APILogging_0.png","tag":["Tech"],"readingTime":2},{"title":"여러분은 핫 코너를 제대로 활용하지 않고 있어요 이전에 아무도 말해주지 않은 꿀팁","description":"","date":"2024-05-17 18:54","slug":"2024-05-17-YoureUnderutilizingHotCornersHacksNobodyToldYouBefore","content":"\n맥 macOS의 핫 코너 기능이 정말 소홀히 다루어지고 있는 기능이에요. 왜냐하면 이렇게 말할 수 있어요:\n\n- 몇몇 사람들은 이 기능이 존재한다는 것을 알지만, 거의 사용하지 않아요.\n- 몇몇 사람들은 이 기능이 존재조차 모르고 있어요. (기본적으로 아래 오른쪽 모서리로 스와이프하면 퀵 노트를 열 수 있다는 건 알지만요)\n\n핫 코너를 통해 맥 화면의 네 구석 중 아무 쪽 모서리로도 포인터를 스와이프하여 10가지 사전 정의된 작업 중 하나를 실행할 수 있어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이것들은 10가지 사전 정의된 작업입니다:\n\n![image](/assets/img/2024-05-17-YoureUnderutilizingHotCornersHacksNobodyToldYouBefore_1.png)\n\n(‘—’는 아무 행동도 없음을 나타냄.)\n\n시스템 설정 ⚙️ `데스크톱 및 독 🖥️` 핫 코너에서 핫 코너를 원하시는대로 구성할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n(설정에 깊이 들어갈 필요가 있나요? 네, 따라서 직접 해당 페이지로 이동하는 이 바로 가기를 사용해보세요. 이 URL을 사용합니다: x-apple.systempreferences:com.apple.Desktop-Settings.extension?HotCorners)\n\n자, 여기 제임스라는 사용자의 핫코너 구성입니다:\n\n![이미지](/assets/img/2024-05-17-YoureUnderutilizingHotCornersHacksNobodyToldYouBefore_2.png)\n\n그러므로 그에게는(swiping towards)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 왼쪽 상단 모서리는 아무 기능도 하지 않습니다.\n- 왼쪽 하단 모서리에서는 현재 애플리케이션 창들이 표시됩니다.\n- 오른쪽 상단 모서리를 클릭하면 알림 센터가 열립니다.\n- 오른쪽 하단 모서리를 클릭하면 바탕 화면이 표시됩니다.\n\n잘 했어요, 제임스는 생산성을 위해 이러한 핫 코너 구성을 설정했어요. 그것을 즐기고 있어요.\n\n그러나 불행하게도 일할 때 활성 모서리 중 하나에 포인터가 닿으면 의도치 않게 이를 자주 작동시키고 있어요.\n\n생산성을 위해 만든 구성이 실제로 그것을 방해하고 있다는 것이 그에게 거슬리는 문제입니다. 그는 심지어 핫 코너를 공백으로 되돌리고 싶다고 생각한 적도 있었어요 — 그런데 이 꿀팁을 몰라서 그랬던 게죠:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# \"수정자 키\"를 설정하여 의도하지 않은 핫 코너 트리거 방지하기\n\n이것은 위장된 기능입니다 — 하지만 더 많은 사람들이 실제로 핫 코너를 사용할 것이라고 생각합니다.\n\n핫 코너를 구성할 때... 예를 들어 데스크톱으로 설정한다고 가정해 보세요. '데스크톱'을 클릭할 때 ⌘를 누르고 있는지 확인해 보세요. 그러면 이렇게 보이게 됩니다:\n\n![이미지](/assets/img/2024-05-17-YoureUnderutilizingHotCornersHacksNobodyToldYouBefore_3.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 의미는 데스크톱을 활성화시키기 위해서는 ⌘을 누른 채로 포인터를 그 모서리쪽으로 스와이프해야 합니다 (보통의 스와이프는 작동하지 않습니다).\n\n이것은 대부분의 의도하지 않은 트리거를 방지할 수 있습니다. ⌘을 누르고 포인터를 모서리쪽으로 스와이프는 매우 낮은 확률이기 때문입니다.\n\n사용할 수 있는 모든 수정자 키는 무엇인가요?\n\n- Shift ⇧\n- Control ⌃\n- Option ⌥\n- Command ⌘\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n알지만?\n무심코 트리거가 작동할 확률을 거의 0으로 줄이기 위해 두 개 이상의 수정자 키를 함께 사용하는 것도 좋을지 몰라요:\n\n![이미지](/assets/img/2024-05-17-YoureUnderutilizingHotCornersHacksNobodyToldYouBefore_4.png)\n\n멋지죠?\n\n# 이제, 프로 사용자를 위한 꿀팁 (그리고 그 중요성)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n1. 터미널을 통한 핫 코너 구성\n2. 쉬운 핫 코너 구성을 위해 이 오토메이터 앱을 가져다 쓰세요\n3. 핫 코너 프로필 작성, 내보내기, 적용하기\n4. 프로필 작성을 쉽게 하는 오토메이터 앱\n\n# 1. 터미널을 통한 핫 코너 구성\n\n나는 개발자이며 CLI(명령줄) 도구를 UI를 가진 도구보다 항상 선호합니다. 왜냐하면 CLI를 사용하면 내가 하는 일에 대해 더 많은 제어를 할 수 있고 더 CPU 효율적입니다.\n\n그래서 여기에 제가 터미널 명령어를 사용하여 핫 코너를 구성하는 방법이 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 예를 들어,\n\n아래 명령어는 bottom-left 핫 코너를 수정 없이 Mission Control로 설정합니다.\n\n```js\ndefaults write com.apple.dock wvous-bl-corner -int 2;\ndefaults write com.apple.dock wvous-bl-modifier -int 0;\nkillall Dock\n```\n\n하지만 어떻게 해야 할까요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 명령어의 각 부분을 설명합니다...\n\n`defaults write com.apple.dock`는 지정된 구성을 도크 설정에 쓰는 것입니다 (핫코너는 내부적으로 도크에 연결되어 있습니다).\n\n`wvous`는 macOS에서 핫코너를 설정하고 구성하는 데 사용되는 키입니다. 이 두 가지는 모든 핫코너 명령에 공통적입니다.\n\n- `bl`은 왼쪽 아래를 나타내며, 마찬가지로,\n- `br`은 오른쪽 아래를 나타내며,\n- `tr`은 오른쪽 위를 나타내며,\n- `tl`은 왼쪽 위를 나타냅니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n코너는 작업을 실행하도록 코너를 구성하고 있어요.\n\n모디파이어는 코너에 모디파이어를 설정하도록 합니다 (말했듯이, ⇧, ⌃, ⌥, ⌘를 모디파이어로 사용할 수 있어요). 당연히 작업이 없는 코너에 모디파이어를 설정하는 것은 쓸모가 없죠.\n\n코너 뒤에 -int 2를 넣으면 미션 컨트롤을 실행하도록 코너를 설정하는 거에요.\n\n여기 각 작업에 연관된 정수들이 있어요:\n• 0, 1: 아무 작업 안 함\n• 2: 미션 컨트롤 (이거 사용해봤죠?)\n• 3: 애플리케이션 창\n• 4: 데스크탑\n• 5: 화면 보호기 시작\n• 6: 화면 보호기 비활성화\n• 7: 대시보드 (macOS 카탈리나부터 중단)\n• 10: 디스플레이를 절전 모드로 전환\n• 11: 런치패드\n• 12: 알림 센터\n• 13: 화면 잠금\n• 14: 빠른 노트\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n-int `integer` 명령어를 사용하면 Hot Corner 작업에 수정자를 설정할 수 있어요. 이 경우 0은 수정자가 없음을 의미해요.\n\n```js\n각 수정자와 조합에 대응되는 정수는 다음과 같아요:\n•  131072: Shift (⇧)\n•  262144: Control (⌃)\n•  524288: Option (⌥)\n• 1048576: Command (⌘)\n조합을 사용하려면 각 키에 해당하는 정수를 더해주면 돼요.\n•  393216: Shift+Control (⇧+⌃)\n•  655360: Shift+Option (⇧+⌥)\n• 1179648: Shift+Command (⇧+⌘)\n•  786432: Control+Option (⌃+⌥)\n• 1310720: Control+Command (⌃+⌘)\n• 1572864: Option+Command (⌥+⌘)\n•  917504: Shift+Control+Option (⇧+⌃+⌥)\n• 1441792: Shift+Control+Command (⇧+⌃+⌘)\n• 1703936: Shift+Option+Command (⇧+⌥+⌘)\n• 1835008: Control+Option+Command (⌃+⌥+⌘)\n• 1966080: Shift+Control+Option+Command (⇧+⌃+⌥+⌘)\n```\n\nkillall Dock 명령은 Dock(및 Hot Corner)을 가장 최신 변경 사항을 적용하여 새로고침해요.\n\n## 더 나은 이해를 위한 예제 명령어 (‘killall Dock’를 제외한)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 왼쪽 위 모서리를 미션 컨트롤로 설정하려면:\n\n```js\ndefaults write com.apple.dock wvous-tl-corner -int 2;\ndefaults write com.apple.dock wvous-tl-modifier -int 0\n```\n\n- 오른쪽 위 모서리를 Command(⌘) 키와 함께 데스크톱으로 설정하려면:\n\n```js\ndefaults write com.apple.dock wvous-tr-corner -int 4;\ndefaults write com.apple.dock wvous-tr-modifier -int 1048576\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- Shift+Command (⇧+⌘)를 사용하여 왼쪽 하단 모서리를 시작 화면 보호기로 설정하십시오:\n\n```js\ndefaults write com.apple.dock wvous-bl-corner -int 5;\ndefaults write com.apple.dock wvous-bl-modifier -int 1179648\n```\n\n### #2. Hot Corners 설정을 쉽게 할 수 있는 Automator 앱 훔쳐보기\n\n당신의 고통을 이해합니다 —\n터미널을 통해 Hot Corners를 구성하는 것은 시스템 설정에서 직접 수행하는 것보다 훨씬 어렵고 복잡합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그래서 이 Automator 앱(Hot Corners Configurator)을 만들었습니다. 이 앱을 사용하면 작업이 10배 쉬워집니다. (앱이 작동하지 않는 경우에는 다시 시도하기 전에 Hot Corners에 무작위 조치를 할당하세요.)\n\n한 번 더 James의 Hot Corners 구성을 살펴보겠습니다. (이제는 수식어를 사용합니다):\n\n![James' Hot Corners Configuration](/assets/img/2024-05-17-YoureUnderutilizingHotCornersHacksNobodyToldYouBefore_5.png)\n\n그리고 이것이 Automator 앱을 실행했을 때 나타나는 화면입니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Screenshot](/assets/img/2024-05-17-YoureUnderutilizingHotCornersHacksNobodyToldYouBefore_6.png)\n\nIt displays the names of all the four corners along with their Action and Modifier info.\n\nIt also contains an additional option — ‘CLEAR ALL HOT CORNERS’ — that can clear all corners of their actions and (obviously) modifiers.\n\nJames wants to configure his empty top-left corner to open Launchpad with the modifier as Control (⌃). So he selects TOP-LEFT ↖, and sees this:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-05-17-YoureUnderutilizingHotCornersHacksNobodyToldYouBefore_7.png\" />\n\n이제 '런치패드'를 선택하면 다음과 같은 화면이 표시됩니다:\n\n<img src=\"/assets/img/2024-05-17-YoureUnderutilizingHotCornersHacksNobodyToldYouBefore_8.png\" />\n\n여기서 'Control, ⌃'를 선택하고 OK를 클릭합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 새로운 액션 및 수정자는 macOS 시스템 설정에서 구성됩니다. 확인하려면 핫 코너를 시도해보거나 앱을 다시 시작하여 변경 사항이 반영되는지 확인할 수 있습니다:\n\n![이미지](/assets/img/2024-05-17-YoureUnderutilizingHotCornersHacksNobodyToldYouBefore_9.png)\n\n이게 다에요. 이제 터미널이나 시스템 설정을 통해 핫 코너를 구성하는 게 더 편한 것 같지 않나요?\n\n## 앱의 AppleScript 코드를 보고 싶으세요? 여기를 클릭하시면 별지에서 내려갈 수 있어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# #3. 핫 코너 프로필 만들기, 내보내기 및 적용\n\n만약 생산성에 집착하고 있다면, 이미 다양한 핫 코너 프로필을 만들고 사용하고 있는 꿈을 꾸고 있을지도 모릅니다. 예를 들어\n\n- 프로필 1 (작업용): 화면 왼쪽 하단을 누르면 데스크톱으로 이동,\n- 프로필 2 (가정용): 화면 왼쪽 하단을 누르면 스크린 보호기가 실행됩니다.\n\n일반적으로 말해 - 하루 종일 사용할 핫 코너 구성의 다양한 프로필을 만들 수 있어야 합니다. 한 번 프로필을 적용하면, 기존의 모든 구성이 새로운 구성으로 대체되어야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저는 여러분이 이를 달성하는 데 도움을 드릴게요.\n\n디스크탑을 프로필을 저장할 기본 폴더로 사용해 보세요 (cd desktop을 사용해주세요). 이미 만들고 있는 프로필을 위해 핫 코너를 설정했다고 가정하고...\n\n아래 명령어를 사용해서 myProfile이란 이름의 프로필로 설정을 저장해보세요:\n\n```js\ndefaults read com.apple.dock | grep wvous > myProfile.txt\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n내Profile.txt 파일이 데스크톱에 생성될 것입니다. 제 프로필을 위해 그 안에 있는 내용은 다음과 같습니다(참고용):\n\n```js\n    \"wvous-bl-corner\" = 3;\n    \"wvous-bl-modifier\" = 1048576;\n    \"wvous-br-corner\" = 4;\n    \"wvous-br-modifier\" = 1179648;\n    \"wvous-tl-corner\" = 0;\n    \"wvous-tl-modifier\" = 0;\n    \"wvous-tr-corner\" = 12;\n    \"wvous-tr-modifier\" = 262144;\n```\n\n이 파일에는 네 개의 Hot Corners에 대한 작업 및 수정자가 포함되어 있습니다.\n\n이제 새 프로필(이름을 myNewProfile로 지정합시다)을 위해 이전에 제공한 Automator 앱을 사용하여 서로 다른 Hot Corner 구성을 설정할 수 있을 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n안녕하세요! 모든 프로필을 안전한 장소에 저장하고 원할 때 적용하세요. 그런데 어떻게 적용하죠?\n\n다음 명령어를 사용하세요:\n\n```js\ndefaults write com.apple.dock wvous-<corner_name>-corner -int <integer>;\ndefaults write com.apple.dock wvous-<corner_name>-modifier -int <integer>;\nkillall Dock\n```\n\n그냥 `corner_name`과 `integer`를 해당 값으로 대체하세요. 각 모서리마다 한 번씩 해야 합니다 (총 네 번). 그러면 전체 프로필이 적용됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이해합니다 — 다시 어려워졌네요. 그래서 여기 Automator 앱이 있어요. 프로필 관련 작업이 쉽게 이루어집니다.\n\n이 앱 이름은 Profiles Configurator입니다. 어때요!\n\n토글되면, 새 프로필을 만들 건지 기존 프로필을 적용할 건지 선택하라는 창이 표시됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![image](/assets/img/2024-05-17-YoureUnderutilizingHotCornersHacksNobodyToldYouBefore_10.png)\n\n## '새 프로필 생성'을 선택하면:\n\n새 프로필의 이름을 지정하라는 메시지가 나타납니다.\n\n![image](/assets/img/2024-05-17-YoureUnderutilizingHotCornersHacksNobodyToldYouBefore_11.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n클릭 OK할 때 프로필이 \"Hot Corner Profiles\"라는 데스크톱 폴더에 저장되고 현재 핫 코너 구성이 포함됩니다.\n\n프로필 이름을 비워 놓으면 다시 시도하라는 메시지가 표시됩니다.\n\n❗️안타깝게도 해결하려고 많은 노력을 기울였지만 해내지 못한 버그가 있습니다:\n프로필 이름을 숫자로 끝내면 저장은 성공하지만 적용하는 동안 오류가 발생할 수 있습니다(Profile2, Profile15). 그러나 이름 \"사이\"에 숫자를 넣는 것(Ex: Profile2A)은 가능합니다.\n\n## '기존 프로필 적용'을 선택하는 경우:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n모든 기존 프로필이 표시됩니다\n\n![프로필 이미지](/assets/img/2024-05-17-YoureUnderutilizingHotCornersHacksNobodyToldYouBefore_12.png)\n\n선호하는 프로필을 선택하고 확인을 클릭하세요. 이제 확인할 수 있습니다:\n\n![프로필 이미지](/assets/img/2024-05-17-YoureUnderutilizingHotCornersHacksNobodyToldYouBefore_13.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n한 번 Apply Profile을 클릭하면 선택한 프로필에 따라 Hot Corners가 구성됩니다.\n\n## 주의할 점\n\n- 아직 아이디어를 이해하지 못했다면, 프로필을 친구들에게 내보내거나 가져올 수 있습니다.\n- 기존 프로필이 없는 상황에서 '기존 프로필 적용'을 선택하면 프로필을 만들도록 요구받게 됩니다:\n\n![image](/assets/img/2024-05-17-YoureUnderutilizingHotCornersHacksNobodyToldYouBefore_14.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 어플리케이션의 AppleScript 코드를 보고 싶으세요? 별지의 해당 부분으로 스크롤 다운하는 건 어때요?\n\n자, 그러면 이 Automator 앱을 어떻게 찾아내시나요? 만족스러우세요? 하루에 얼마나 자주 사용하고 싶으신가요?\n\n답변 주시면 알려주세요!\n\n## 터미널 명령어에 열광하시나요? 그렇다면 이 이야기들을 읽는 걸 즐기실 거에요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 마지막으로,\n\n새로운 iOS 및 Mac 앱을 탐험하는 것을 좋아한다면(저와 같이요), Setapp에 가입해 보세요. 월 $9.99에 240개가 넘는 놀라운 앱들을 선별하여 이용할 수 있습니다. 개별 구매 시 수백 달러가 필요한 앱들을 저렴하게 이용할 수 있어요.\n\n- Setapp 여행을 시작하려면 제 제휴 링크를 사용하세요! (30일간 무료로 이용 가능)\n- Setapp에서 제가 선정한 100개가 넘는 Ultimate macOS Apps 목록을 무료로 받아보세요.\n\n새로운 스토리를 게시할 때마다 알림을 받기 위해 460명이 넘는 다른 구독자들과 함께 참여하세요!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 부록\n\n## Hot Corners Configurator를 위한 AppleScript 코드\n\n```js\non extractNumber(inputString)\n    set AppleScript's text item delimiters to \"=\"\n    set stringItems to text items of inputString\n    set numberString to item 2 of stringItems\n    set AppleScript's text item delimiters to \"\"\n    set trimmedNumberString to trimSpaces(numberString)\n    return trimmedNumberString as integer\nend extractNumber\n\non trimSpaces(inputString)\n    return text 2 thru -2 of (inputString as text)\nend trimSpaces\n\non getCorner(cornerString)\n    set text item delimiters to \" [\"\n    set resultString to item 1 of text items of cornerString\n    set text item delimiters to AppleScript's text item delimiters\n    return resultString\nend getCorner\n\non getModifier(modifierString, whichPart)\n    set text item delimiters to \",\"\n    set resultString to modifierString\n    if resultString contains \",\" then\n        set resultString to item whichPart of text items of resultString\n    end if\n    set text item delimiters to AppleScript's text item delimiters\n    return resultString\nend getModifier\n\nset actionMappings to {¬\n    \"No Action\", 1, ¬\n    \"Mission Control\", 2, ¬\n    \"Application Windows\", 3, ¬\n    \"Desktop\", 4, ¬\n    \"Start Screen Saver\", 5, ¬\n    \"Disable Screen Saver\", 6, ¬\n    \"Put Display to Sleep\", 10, ¬\n    \"Launchpad\", 11, ¬\n    \"Notification Centre\", 12, ¬\n    \"Lock Screen\", 13, ¬\n    \"Quick Note\", 14 ¬\n}\n\nset modifierMappings to {¬\n    \"No Modifier\", 0, ¬\n    \"Shift,⇧\", 131072, ¬\n    \"Control,⌃\", 262144, ¬\n    \"Option,⌥\", 524288, ¬\n    \"Command,⌘\", 1048576, ¬\n    \"Shift+Control,⇧+⌃\", 393216, ¬\n    \"Shift+Option,⇧+⌥\", 655360, ¬\n    \"Shift+Command,⇧+⌘\", 1179648, ¬\n    \"Control+Option,⌃+⌥\", 786432, ¬\n    \"Control+Command,⌃+⌘\", 1310720, ¬\n    \"Option+Command,⌥+⌘\", 1572864, ¬\n    \"Shift+Control+Option,⇧+⌃+⌥\", 917504, ¬\n    \"Shift+Control+Command,⇧+⌃+⌘\", 1441792, ¬\n    \"Shift+Option+Command,⇧+⌥+⌘\", 1703936, ¬\n    \"Control+Option+Command,⌃+⌥+⌘\", 1835008, ¬\n    \"Shift+Control+Option+Command,⇧+⌃+⌥+⌘\", 1966080 ¬\n}\n\nset shellCommand to \"defaults read com.apple.dock | grep wvous\"\nset hotCornersInfo to do shell script shellCommand\nset linesList to paragraphs of hotCornersInfo\n\non getActionString(actionValue, actionMappings)\n    repeat with i from 1 to length of actionMappings by 2\n        if item (i + 1) of actionMappings is actionValue then\n            return item i of actionMappings\n        end if\n    end repeat\n    if actionValue is 0 then\n        return \"No Action\"\n    end if\nend getActionString\n\non getModifierString(modifierValue, modifierMappings)\n    repeat with i from 1 to length of modifierMappings by 2\n        if item (i + 1) of modifierMappings is modifierValue then\n            return item i of modifierMappings\n        end if\n    end repeat\n    return \"No Modifier\"\nend getModifierString\n\nrepeat with lineNext in linesList\n    if lineNext contains \"bl-corner\" then\n        set blCorner to getActionString(extractNumber(lineNext), actionMappings)\n    else if lineNext contains \"bl-modifier\" then\n        set blModifier to getModifierString(extractNumber(lineNext), modifierMappings)\n    else if lineNext contains \"br-corner\" then\n        set brCorner to getActionString(extractNumber(lineNext), actionMappings)\n    else if lineNext contains \"br-modifier\" then\n        set brModifier to getModifierString(extractNumber(lineNext), modifierMappings)\n    else if lineNext contains \"tl-corner\" then\n        set tlCorner to getActionString(extractNumber(lineNext), actionMappings)\n    else if lineNext contains \"tl-modifier\" then\n        set tlModifier to getModifierString(extractNumber(lineNext), modifierMappings)\n    else if lineNext contains \"tr-corner\" then\n        set trCorner to getActionString(extractNumber(lineNext), actionMappings)\n    else if lineNext contains \"tr-modifier\" then\n        set trModifier to getModifierString(extractNumber(lineNext), modifierMappings)\n    end if\nend repeat\n\nset cornerOptions to {\"TOP-LEFT ↖            [ACTION: \" & tlCorner & \", MODIFIER: \" & getModifier(tlModifier, 2) & \"]\", ¬\n    \"TOP-RIGHT ↗          [ACTION: \" & trCorner & \", MODIFIER: \" & getModifier(trModifier, 2) & \"]\", ¬\n    \"BOTTOM-LEFT ↙    [ACTION: \" & blCorner & \", MODIFIER: \" & getModifier(blModifier, 2) & \"]\", ¬\n    \"BOTTOM-RIGHT ↘ [ACTION: \" & brCorner & \", MODIFIER: \" & getModifier(brModifier, 2) & \"]\", ¬\n    \"CLEAR ALL HOT CORNERS\"}\n\nset selectedCorner to choose from list cornerOptions with prompt \"코너를 선택하세요:\" without multiple selections allowed and empty selection allowed\n\nif selectedCorner is not false then\n    set selectedCorner to item 1 of selectedCorner as text\n    if selectedCorner is \"CLEAR ALL HOT CORNERS\" then\n        set corners to {\"tl\", \"tr\", \"bl\", \"br\"}\n        repeat with currentCorner in corners\n            do shell script \"defaults write com.apple.dock wvous-\" & currentCorner & \"-corner -int 0\"\n            do shell script \"defaults write com.apple.dock wvous-\" & currentCorner & \"-modifier -int 0\"\n        end repeat\n\n        do shell script \"killall Dock\"\n\n    else\n        set selectedCornerAbbreviation to \"\"\n        if selectedCorner contains \"TOP-LEFT ↖\" then\n            set selectedCornerAbbreviation to \"tl\"\n        else if selectedCorner contains \"TOP-RIGHT ↗\" then\n            set selectedCornerAbbreviation to \"tr\"\n        else if selectedCorner contains \"BOTTOM-LEFT ↙\" then\n            set selectedCornerAbbreviation to \"bl\"\n        else if selectedCorner contains \"BOTTOM-RIGHT ↘\" then\n            set selectedCornerAbbreviation to \"br\"\n        end if\n\n        set cornerActions to {\"No Action\", ¬\n            \"Mission Control\", ¬\n            \"Application Windows\", ¬\n            \"Desktop\", ¬\n            \"Start Screen Saver\", ¬\n            \"Disable Screen Saver\", ¬\n            \"Put Display to Sleep\", ¬\n            \"Launchpad\", ¬\n            \"Notification Centre\", ¬\n            \"Lock Screen\", ¬\n            \"Quick Note\"}\n\n        set chosenAction to choose from list cornerActions with prompt \"선택한 코너의 액션을 선택하세요: \" & getCorner(selectedCorner) default items {\"No Action\"} without multiple selections allowed and empty selection allowed\n\n        if chosenAction is not false then\n            if (count of chosenAction) > 0 then\n                set selectedActionText to item 1 of chosenAction\n                if selectedActionText is not \"No Action\" then\n                    set selectedActionValue to 0\n                    repeat with i from 1 to length of actionMappings by 2\n                        if item i of actionMappings is selectedActionText then\n                            set selectedActionValue to item (i + 1) of actionMappings\n                            exit repeat\n                        end if\n                    end repeat\n\n                    if selectedActionValue is not 0 then\n                        set modifierOptions to {}\n                        repeat with i from 1 to length of modifierMappings by 2\n                            set end of modifierOptions to item i of modifierMappings\n                        end repeat\n\n                        set chosenModifier to choose from list modifierOptions with prompt \"선택한 코너의 모디파이어를 선택하세요: \" & getCorner(selectedCorner) default items {\"No Modifier\"} without multiple selections allowed and empty selection allowed\n\n                        if chosenModifier is not false then\n                            if (count of chosenModifier) > 0 then\n                                set selectedModifierText to item 1 of chosenModifier\n                                set selectedModifierValue to 0\n\n                                repeat with i from 1 to length of modifierMappings by 2\n                                    if item i of modifierMappings is selectedModifierText then\n                                        set selectedModifierValue to item (i + 1) of modifierMappings\n                                        exit repeat\n                                    end if\n                                end repeat\n\n                                set actionCommand to \"defaults write com.apple.dock wvous-\"\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```\n\nJavaScript 코드입니다. 함수와 변수를 정의하고 사용자 선택에 따라 프로필을 생성하거나 적용합니다. 조건문과 반복문을 사용하여 프로필 파일을 읽고 해당하는 설정을 적용합니다.\n","ogImage":{"url":"/assets/img/2024-05-17-YoureUnderutilizingHotCornersHacksNobodyToldYouBefore_0.png"},"coverImage":"/assets/img/2024-05-17-YoureUnderutilizingHotCornersHacksNobodyToldYouBefore_0.png","tag":["Tech"],"readingTime":26},{"title":"제목 v058 몬아크의 심볼 검색 기능으로 글쓰기 역량 향상하기","description":"","date":"2024-05-17 18:53","slug":"2024-05-17-v058EnhanceyourwritingwithSymbolSearchinMonarch","content":"\n<img src=\"/assets/img/2024-05-17-v058EnhanceyourwritingwithSymbolSearchinMonarch_0.png\" />\n\n손으로 쓰는 것과 타자 입력의 주요 차이점 중 하나는 기호를 손으로 훨씬 쉽게 쓸 수 있다는 것입니다. 왜냐하면 키보드에는 이미 훨씬 더 자주 필요한 키들이 가득하기 때문이죠.\n\n실제로 맥에서 특정 키보드 조합을 눌러 기호를 입력할 수 있습니다. 이음대는 ⌥+마이너스이고, 점 목록은 ⌥+8입니다. 문제는 뭐지요? 그게 제가 기억하는 모든 것입니다. 수천 개의 기호가 있고, 그 모든 것이나 아주 몇 가지를 기억하려고 노력하려는 것은 현실적이지 않습니다.\n\n이제 Monarch로 그럴 필요가 없습니다! 앱을 열고 이모지를 찾을 때와 같이 탐색을 시작할 수 있습니다. 가장 좋은 점은 특정 기호를 찾기 어렵거나 그들을 위한 시스템 이름을 기억하는 데 어려움을 겪는다면... 더는 그럴 필요가 없다는 것입니다! 이모지처럼 Monarch는 ⌘+E를 사용하여 기호의 이름을 원하는 대로 바꿀 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다른 메시지에서는 심볼을 사용하지는 않지만, 종종 심볼이 메시지를 더 잘 전달하거나 간결하게 표현할 때, 또는 설명서를 작성할 때 전문적으로 제시해주기도 합니다.\n\nMonarch은 곧 v1.0을 출시할 예정이므로, 평생 라이선스를 획득하려면 빨리 움직여야 합니다! 무료로 30일간 사용해보세요 (신용카드 필요 없음).\n\n# 학생 할인\n\n학생 할인(25% 할인)을 받으려면 학생 이메일(rmdashrfv@hey.com)로 직접 연락해주세요. 뉴욕시 소재 학교에 재학 중인 학생들은 버전 0.x에 40% 할인 혜택을 받을 수 있습니다. 버전 1.0은 우리가 예상하기 전에 여기 있을 것입니다!\n","ogImage":{"url":"/assets/img/2024-05-17-v058EnhanceyourwritingwithSymbolSearchinMonarch_0.png"},"coverImage":"/assets/img/2024-05-17-v058EnhanceyourwritingwithSymbolSearchinMonarch_0.png","tag":["Tech"],"readingTime":2},{"title":"쉘 스크립트를 여전히 작성해야 하는 이유","description":"","date":"2024-05-17 18:51","slug":"2024-05-17-WhyYouShouldStillWriteShellScripts","content":"\n고전적 접근 방식에 대한 현대적인 사례.\n\n![이미지](/assets/img/2024-05-17-WhyYouShouldStillWriteShellScripts_0.png)\n\n솔직히 말해서, grep -o `Response Code:.*` | cut -f 3 -d ` ` | sort | uniq -c | sort -h 3을 지켜보는 것은 고오급한 Kubernetes Operator를 사용하여 일어나는 것만큼 흥미롭지 않습니다. 많은 소프트웨어 전문가들, 시스템 관리자의 건강한 비율을 포함하여 긴 셸 스크립트를 보는 것은 공포와 혼란의 조합으로 인식합니다. 그러나 나는 현대 엔지니어가 갖춰야 할 유용한 기술 중 하나로 셸 스크립트를 편안하게 작성하고 한 줄 기반으로 만드는 능력을 주장합니다.\n\n대학 시절에 스크립팅 수업을 들었습니다. 수업의 처음 몇 주는 Perl로 넘어가기 전에 셸의 기본 사항을 배우는 데 집중했습니다. 우스꽝스럽게도, 지금은 이 매우 같은 강의를 가르치지만 내용은 Perl에서 Python으로 변화했습니다. 불가피하게, 나의 학생들은 저와 같은 어려움을 겪습니다: 셸 구문은 난해하고 혼란스럽고 기억하기 어려운 것들입니다. 그것은 단순히 \"오래된\" 느낌이 들어서, 첫 번째 셸 스크립트를 작성하는 것은 어둠 속에서 헤매고 있는 것과 같은 느낌입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n시간이 흐르면서 저는 쉘을 매우 강력한 기능과 풍부한 역사를 가진 도구로 칭찬하게 되었습니다. 쉘 스크립트를 작성하는 방법을 배우는 것은 아마도 여러분이 익숙한 것과는 다르게 사용자 친화적이지 않을 수도 있습니다. 특히 Python이나 Go와 같은 언어에서 오신 경우에는 더 그렇습니다. 그러나 나는 모두가 쉘 스크립팅 능력을 키우는 데 시간을 쏟는 것이 매우 값진 일이라고 생각합니다.\n\n아래에는 파일을 열 때 #!/bin/bash라는 구문을 보고 신경 쓰이는 경우 고려해 볼 다섯 가지 이유가 있습니다:\n\n## Reason 1: Containers Demand It\n\n컨테이너는 현재 워크로드를 배포하는 표준 방식입니다. 동의하든 그렇지 않든, 쿠버네티스 열풍에 흔들리지 않았더라도 환경에서 컨테이너화된 워크로드를 배포 중인 가능성은 높습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n바이너리 엔트리포인트에 의존하는 컨테이너를 빌드할 수 있지만, 보통 컨테이너는 시작 스크립트를 실행합니다. 이는 실행 시간 구성을 제한하는 기회를 제공합니다. 고품질 쉘 스크립트를 작성하면 컨테이너 엔트리포인트의 품질을 향상시켜 컨테이너 이미지 사용자에게 강력한 실행 시간 구성을 제공할 수 있습니다. 이는 오류 확인부터 자격 증명 또는 구성 매개변수를 자동으로 생성하는 것과 같은 더 복잡한 구성까지 모두 포함됩니다.\n\n게다가: 엔트리포인트 스크립트를 POSIX 쉘(#!/bin/sh)로만 제한하는 방법을 배우면 컨테이너 이미지에서 Bash를 제거하고 그 크기와 공격 표면을 줄일 수 있습니다.\n\n# 공식 MariaDB 컨테이너는 623줄의 도커 엔트리포인트 쉘 스크립트를 사용합니다.\n\n$ podman exec -it mariadb wc -l /usr/local/bin/docker-entrypoint.sh\n623 /usr/local/bin/docker-entrypoint.sh\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n로그 및 추적 프로젝트는 대략 백만 개 정도가 있어요. 왜 그럴까요? 로깅은 도전적입니다, 특히 분산 마이크로서비스 세계에서요. 멋진 추적 도구와 로그 집계 서비스는 훌륭하지만 종종 명령줄에서 찾을 수 있는 그 유연성을 제공하지 못할 때가 많아요. 저는 파이프된 명령어 한 줄을 작성하는 것이 대부분의 로깅 시스템 UI를 헤매는 것보다 빠르다고 생각해요.\n\nGUI를 버리지 않는 것을 추천하지 않아요. 오히려 그게 유용해요. 텍스트 데이터를 그래픽 인터페이스와 명령줄 모두에서 탐색하는 것이 유용하기 때문이죠. 내 전형적인 워크플로우는 로깅 UI(예: 키바나)를 사용하여 관심 있는 로그로 대략적으로 필터링한 다음 로그 메시지를 다운로드하여 쉽게 구문 분석하기 위해 셸 유틸리티를 사용하는 것입니다. 원하는 것을 더 잘 알게 되면 실제 쿼리가 있는 대시보드를 작성하게 될 거예요.\n\n생산 문제를 디버깅할 때도 아마 당신은 당신의 서버나 쿠버네티스 클러스터에 앉아 있을 거예요. 장애 발생 시 분 단위가 중요할 때 몇 번의 키 입력으로 바로 이론을 테스트하는 것이 절대적으로 중요합니다. 문제가 심각해서 로그 수집 자체가 고장났을 수도 있고, 아니면 터미널과 로깅 도구 간의 컨텍스트 전환을 계속할 여유가 없을 수도 있어요. 그 어떤 경우에도, 단순한 한 줄짜리 명령어를 만들어 내는 데 익숙해서 다행할 것입니다.\n\n배우는 곡선은 있지만, 쉘에서 사용 가능한 많은 유틸리티로 편안해지면 쉘 명령어를 사용하여 데이터를 \"탐색\"하는 것이 훨씬 쉽다는 것을 알게 되실 거예요. 필요한 데이터를 빠르게 반환하는 작은 스크립트 라이브러리를 점차적으로 구축할 수 있을 거예요. 제가 가장 좋아하는 것 중 하나는 제 Nginx 로그를 구문 분석하고 서버를 공격하는 상위 10개 IP 주소를 알려주는 간단한 Bash 한 줄짜리입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n$ cut -f 1 -d ' ' /var/log/nginx/access.log | sort | uniq -c | sort -hr | head -n 10\n     38 65.108.66.11\n     20 91.240.118.252\n     18 194.110.115.68\n     17 3.234.236.64\n     11 190.117.58.32\n     11 172.56.209.241\n     11 165.225.233.21\n     10 95.161.221.0\n     10 85.173.195.175\n     10 37.79.10.45\n```\n\n# Reason 3: 어떤 (텍스트) 데이터 형식이든\n\n우리가 일상적으로 다루는 대부분의 데이터는 텍스트 형식입니다: 애플리케이션 데이터, 설정 파일, 로그 메시지 등등. 이러한 데이터나 로그 집계 플랫폼에서 이 데이터를 다루는 것은 데이터의 형식(또는 스키마)에 대해 신중한 고려를 요구합니다. 이는 장기적인 저장 및 검색을 위해 이상적인 선택입니다: 데이터 형식을 이해하는 것은 복잡한 데이터를 효율적으로 저장하고 쿼리하는 데 중요합니다.\n\n하지만 당신은 아마도 데이터를 탐색하는 데 편의를 제공하는 방식으로 빠르고 쉽게 데이터를 다루고 싶어하는 상황에 직면해 본 적이 있을 것입니다. 아직 다루고 있는 데이터의 구조나 형식에 대해 이해하고 있지 않을 수도 있습니다. 이를 이해하려는 과정에 있을 수도 있고, 특정 데이터의 일부를 빠르게 쿼리하거나 변환하고 싶을 수도 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n쉘(shell)이 빛을 발하는 작업들이에요! 대부분의 쉘 도구들은 텍스트의 구조에 대해 크게 신경 쓰지 않고 원시 텍스트와 직접 작동합니다. 임의로 형식이 지정되지 않은 텍스트 파일에서 모두 dev를 prod로 변경하고 싶다면, 쉘이 도움이 될 거예요. JSON이나 YAML과 같은 구조화된 데이터 형식을 이미 사용하고 있다면, jq나 yq와 같은 도구를 사용해서 이러한 형식과 함께 작업할 수 있어요.\n\n```js\n# 개발용 구성 파일\n$ cat /tmp/sample.json\n{\n    \"Environment\": \"dev\",\n    \"Database\": {\n        \"Host\": \"dev.example.com\"\n    },\n    \"AppName\": \"iot-dev\",\n    \"CacheShards\": [\n        \"east1-cache-dev-1\",\n        \"east1-cache-dev-2\",\n        \"east1-cache-dev-3\"\n    ]\n}\n\n# Sed는 JSON, YAML, XML 또는 다른 형식이든 상관하지 않아요.\n# 텍스트이면 됩니다!\n$ sed -s 's/dev/prod/g' /tmp/sample.json\n{\n    \"Environment\": \"prod\",\n    \"Database\": {\n        \"Host\": \"prod.example.com\"\n    },\n    \"AppName\": \"iot-prod\",\n    \"CacheShards\": [\n        \"east1-cache-prod-1\",\n        \"east1-cache-prod-2\",\n        \"east1-cache-prod-3\"\n    ]\n}\n```\n\n# 이유 4: 자동화를 지지합니다\n\n자동화는 소프트웨어 엔지니어부터 운영 전문가에 이르기까지 모두의 책임이에요. 소프트웨어 분야에서 일하고 있다면 이미 자동화의 이점을 잘 알고 있고, 아마도 자동화된 몇 가지 프로세스를 진정으로 자랑스럽게 자동화했을 거예요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n셸 스크립트는 존재하는 자동화 방식 중 가장 일반적이고 간단하며 기본적인 유형 중 하나입니다. Ansible, Puppet, Chef, Kubernetes 및 기타 도구들이 나오기 전에는 셸만 있었습니다. 옛날의 시스템 관리자들은 사용자 관리부터 보안 감사까지 모든 것을 다루기 위해 스크립트를 작성했습니다. 이러한 프로세스를 자동화하기 위해 다른 도구를 배울 필요가 없었기 때문에 셸은 시스템과 상호 작용하는 유일한 방법이었죠.\n\n이러한 형태의 자동화를 이해하는 것은 그저 향수에 젖은 연습을 하는 것 이상입니다. 종종 복잡한 프로세스를 자동화하기 위해서는 간단한 셸 스크립트만으로 충분할 수 있습니다. 게다가 많은 자동화 플랫폼들은 이미 강력한 셸 스크립트의 래퍼일 뿐입니다. 셸 스크립트를 작성하고 읽는 방법을 이해하는 것은 자동화 기초에 대한 더 나은 이해를 제공받게 되며, 복잡한 문제를 간단한 방식으로 해결하는 데 도움이 될 것입니다.\n\n# 이유 5: 모든 곳에서 존재하는 기술\n\n현대 컴퓨팅 세계의 현실은 대부분의 기업이 이종 컴퓨팅 워크로드를 실행한다는 것입니다: 가상 머신, 컨테이너, 물리적 호스트 등이 있습니다. 워크로드는 클라우드, 온프레미스 및 엣지에서 실행됩니다. 우수한 엔지니어들은 이러한 환경을 횡단하여 편안하게 작업할 수 있어서 자신을 다른 사람들과 구분지을 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n하지만 최신 데이터 처리 또는 로그 분석 도구가 없어서 간소화된 컨테이너 애플리케이션 문제 해결에 어려움이 있을 때는 어떻게 해야 할까요? 새로운 팀(또는 직장)으로 옮겨갔을 때 새 역할에서 사용하는 도구체인이 완전히 다를 경우에는 어떻게 해야 할까요?\n\n기본적인 셸 스크립트 작성에 능숙하다면 걱정할 필요가 없습니다. 완전히 다른 환경의 원격 시스템에 로그인하여 로그 데이터를 캡처하거나 자동화된 결함 해결 기능을 동일하게 수행할 수 있습니다. 이런 셸 스크립트를 작성하여 산업 분야에서 계속 발전시키는 경력을 쌓을 수 있습니다. 셸은 시간에 걸쳐 검증되어왔으며, 업계에서의 시간 동안 그것이 성과를 거두는 것을 발견하게 될 것입니다.\n\n# 결론\n\n작은 셸 스크립트도구 상자를 구축하세요. 퇴사할 때 멋진 Kubernetes 오퍼레이터, 놀라운 Kibana 대시보드 또는 멋진 커맨드 라인 도구를 가져갈 수 없을 수도 있습니다. 또한 그것은 간단히 기억에서 재구성하기에 너무 복잡할 수도 있습니다. 그러나 다음 회사에서는 셸이 포함된 시스템이 있을 것이며, 그럼에도 불구하고 당신이 익숙하고 쉽게 어떤 작업이든 수행할 수 있다는 것을 확신할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n확실하게 말씀드리자면: 쉘 스크립트 작성에는 제약과 도전이 있습니다. 하지만 그에 대한 논의는 다음에 하도록 하죠. 그래도 컨테이너 엔트리포인트를 파헤치는 과정에서 #!/bin/sh를 보게 된다고 두려워하지 마세요. 구문과 스타일에 익숙해지면, 강력한 쉘 스크립트가 소프트웨어 전문가로써 우리의 삶을 더 쉽게 만든다는 점을 감사히 여기게 될 거에요.\n","ogImage":{"url":"/assets/img/2024-05-17-WhyYouShouldStillWriteShellScripts_0.png"},"coverImage":"/assets/img/2024-05-17-WhyYouShouldStillWriteShellScripts_0.png","tag":["Tech"],"readingTime":8},{"title":"리눅스 68에서 사용자 정의 시스템 호출 만들기","description":"","date":"2024-05-17 18:49","slug":"2024-05-17-CreateCustomSystemCallonLinux68","content":"\n여태껏 사용자 정의 시스템 호출을 만들어보고 싶으셨나요? 과제를 위해서든, 즐거움을 위해서든, 또는 커널에 대해 더 많이 배우기 위해서든, 시스템 호출은 우리 시스템에 대해 더 많이 알아갈 수 있는 멋진 방법입니다.\n\n# 이 안내에 따를 이유는?\n\n이 주제에 대한 다양한 안내서가 있지만, 커널 개발 속도의 문제 때문에 문제가 발생합니다. 대부분의 안내서들은 오래되었고 다양한 오류를 발생시키기 때문에, 저는 이 포스트를 오류를 경험하고 그것들을 해결한 후에 작성하게 되었습니다 :)\n\n## 커널 컴파일을 위한 시스템 설정\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nRed Hat / Fedora / Open Suse 기반 시스템에서는 아래와 같이 간편하게 실행할 수 있어요.\n\n```bash\nsudo dnf builddep kernel\nsudo dnf install kernel-devel\n```\n\nDebian / Ubuntu 기반 시스템에서는\n\n```bash\nsudo apt-get install build-essential vim git cscope libncurses-dev libssl-dev bison flex\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 커널 가져오기\n\n커널 소스 트리를 복제하세요. 특히 6.8 브랜치를 복제할 것이지만, 지침은 커널 개발자가 프로세스를 변경할 때까지 최신 브랜치에서도 작동해야 합니다.\n\n```js\ngit clone --depth=1 --branch v6.8 https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git\n```\n\n이상적으로, 복제된 버전은 현재 사용 중인 커널 버전과 같거나 더 높아야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n현재 커널 버전은 다음 명령어를 통해 확인할 수 있어요\n\n```bash\nuname -r\n```\n\n## 새로운 시스템 호출 생성\n\n다음을 수행해주세요\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\ncd linux\nmake mrproper\nmkdir hello\ncd hello\ntouch hello.c\ntouch Makefile\n```\n\n이 명령은 다운로드한 커널 소스 코드 내에 \"hello\"라는 폴더를 만들고, 그 안에 hello.c(시스템 호출 코드)와 Makefile(컴파일 규칙) 두 개의 파일을 생성합니다.\n\n좋아하는 텍스트 편집기에서 hello.c를 열고 다음 코드를 넣어주세요.\n\n```js\n#include <linux/kernel.h>\n#include <linux/syscalls.h>\n\nSYSCALL_DEFINE0(hello) {\n    pr_info(\"Hello World\\n\");\n    return 0;\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n커널 로그에 \"Hello World\"가 출력됩니다.\n\n우리는 단순히 프린트만 할 것이기 때문에 n=0을 사용합니다.\n\n이제 다음을 Makefile에 추가해주세요\n\nobj-y := hello.o\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제\n\n```js\ncd ..\ncd include/linux/\n```\n\n이 디렉토리 안에서 \"syscalls.h\" 파일을 열고 다음을 추가하세요.\n\n```js\nasmlinkage long sys_hello(void)\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-05-17-CreateCustomSystemCallonLinux68_0.png\" />\n\n이것은 이전에 만든 syscall 함수에 대한 프로토타입입니다.\n\n커널 루트 내의 \"Kbuild\" 파일을 열고 (cd ../..) 맨 아래에 다음을 추가하십시오.\n\n```js\nobj-y += hello/\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 우리가 포함한 새 폴더도 컴파일하도록 커널 빌드 시스템에 지시합니다.\n\n이 작업이 완료되면, 아키텍처별 테이블에 시스콜 항목도 추가해 주어야 합니다.\n\n각 CPU 아키텍처는 특정 시스콜을 가질 수 있으며, 우리의 시스콜이 어떤 아키텍처를 위해 만들어졌는지 알려주어야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nx86_64 아키텍처에서 파일은\n\n```js\narch / x86 / entry / syscalls / syscall_64.tbl;\n```\n\n빈번호를 사용하고 테이블 주석에서 금지된 번호를 사용하지 않도록 유의하여 시스콜 항목을 추가하세요.\n\n제가 사용 가능한 번호 중 462번이 비어 있어서 새 항목을 다음과 같이 추가했습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n462 공통 안녕 sys_hello\n```\n\n<img src=\"/assets/img/2024-05-17-CreateCustomSystemCallonLinux68_2.png\" />\n\n여기서 462은 우리의 시스템 호출에 매핑되며 두 아키텍처에 대해 공통인 sys_hello로 명명된 hello 시스템 호출의 진입 함수(entry function)입니다.\n\n## 새 커널을 컴파일하고 설치하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음 명령을 실행하십시오.\n\n주의: 이 안내를 따르더라도 시스템의 안전, 보안, 무결성과 안정성을 보장하지 않습니다. 여기 나열된 모든 지침은 제 경험이며 귀하의 시스템에서의 결과를 대표하지 않습니다. 조심히 주의하여 진행하십시오.\n\n이제 법적인 부분은 끝냈으니, 계속해봅시다 ;)\n\n```js\ncp /boot/config-$(uname -r) .config\nmake olddefconfig\nmake -j $(nproc)\nsudo make -j $(nproc) modules_install\nsudo make install\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n현재 부팅된 커널의 구성 파일을 복사하고, 빌드 시스템에 동일한 값을 사용하도록 요청하여 기본값을 설정합니다. 그런 다음 nproc에 의해 주어진 코어 수에 따라 병렬 처리를 사용하여 커널을 빌드합니다. 이후 사용자 정의 커널을 설치합니다 (자체 책임으로).\n\n커널 컴파일에는 많은 시간이 소요되므로 커피 한 잔 또는 10잔을 마시며 터미널에서 스크롤되는 텍스트 줄을 즐기세요.\n\n시스템 속도에 따라 몇 시간이 걸릴 수 있으므로 실제 소요 시간이 다를 수 있습니다. 이 단계에서 열이 치기도 할 수 있으니 온도를 확인하려면 팬이 소리를 지를 수도 있습니다 (내 경우에도 그렇었어요).\n\n## 재미있는 부분, 새로운 시스템 호출 사용\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 시스템 호출이 우리의 커널에 통합되었으니 시스템을 재부팅하고 부팅 중에 grub에서 새로운 커스텀 커널을 선택해주세요\n\n![image](/assets/img/2024-05-17-CreateCustomSystemCallonLinux68_3.png)\n\n부팅 후 시스템 호출을 사용하는 C 프로그램을 작성해봅시다.\n\n다음 내용을 가진 파일 \"test.c\"를 생성하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n#include <stdio.h>\n#include <sys/syscall.h>\n#include <unistd.h>\nint main(void) {\n  printf(\"%ld\\n\", syscall(462));\n  return 0;\n}\n```\n\n당신이 테이블에서 시스템 콜에 대해 선택한 번호로 462을 대체하세요.\n\n프로그램을 컴파일하고 실행하세요.\n\n```js\nmake test\nchmod +x test\n./test\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n모두 정상적으로 진행되면, 터미널에서 \"0\"을 출력하고 시스콜 출력이 커널 로그에 표시됩니다.\n\n다음 명령어를 사용하여 로그에 액세스하세요.\n\n```bash\nsudo dmesg | tail\n```\n\n그러면 원하는 시스템 콜 메시지가 출력된 것을 확인할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만약 성공적으로 수행했다면 축하드려요 🎉 좋아요와 댓글이 있다면 감사하겠습니다 :) 꼭 여러분의 이야기를 공유해 주세요 :D\n\n다시 한 번 아래 사항을 기억해 주세요:\n\n- 커널을 컴파일하는 데 많은 시간이 걸립니다.\n- 새로 컴파일한 커널은 상당한 용량을 차지하므로 저장 공간 확인이 필요합니다.\n- 리눅스 커널은 코드 변경이 빠르게 이뤄집니다.\n","ogImage":{"url":"/assets/img/2024-05-17-CreateCustomSystemCallonLinux68_0.png"},"coverImage":"/assets/img/2024-05-17-CreateCustomSystemCallonLinux68_0.png","tag":["Tech"],"readingTime":9},{"title":"악용하지 말아야 할 멋진 Swift 기능들","description":"","date":"2024-05-17 18:48","slug":"2024-05-17-ThecoolSwiftfeaturesthatyoushouldnotabuse","content":"\n![ThecoolSwiftfeaturesthatyoushouldnotabuse](/assets/img/2024-05-17-ThecoolSwiftfeaturesthatyoushouldnotabuse_0.png)\n\niOS 개발자로서, 나는 많은 기존 코드에서 작업하거나 몇 가지 Swift 기능을 시도해 본 적이 있습니다. 그들을 사용하거나 악용 당하는 것을 보면서, 적어도 조심스럽게 사용해야 할 상위 6개의 Swift 언어 기능을 공유하고, 왜 그것들을 팀에서 금지해야 할지 생각했습니다. 간단히 살펴보겠습니다. 동의하지 않거나 다른 예제가 있는 경우 댓글에서 공유해주세요 💬.\n\n# .init() 인스턴스화\n\n.init()을 사용하는 것은 처음 봤을 때 몇 가지 경우에 편리할 수 있지만 (클래스/구조체 이름 바꿀 때 노이즈가 적음), 코드 검토 및 유지보수 시 가독성이 저하됩니다. 코드 검토에서는 호출자로 이동하여 객체의 유형을 확인해야 하며, 유지보수 중에는 객체를 확인하려면 이동해야 합니다. 팀의 생산성을 높이기 위해 사용하지 않아야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n//To avoid ❌\nlet example = .init(title: \"title\")\n//To prefer ✅\nlet example = Example(title: \"title\")\n```\n\nSwiftlint을 사용하면 이 좋은 규칙을 강제로 적용할 수 있어요.\nSwiftlint를 사용하신다면, 프로젝트에서 사용해야 하는 최상의 Swiftlint 설정에 관한 기술적인 문서를 작성했어요 ⬇️\n\n# $0, $1, 등...\n\n$0는 매우 편리하지만 코드 리뷰에서는 코드를 덜 가독성 있게 만들 수 있어요(이 게시물이 말합니다).\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n// ❌를 피하기 위해\nnumbers.sort { $0 > $1 }\n// ✅를 선호하기 위해\nnumbers.sort { leftNumber, rightNumber in leftNumber > rightNumber }\n\n# 서브스크립트\n\n서브스크립트 기능은 처음 봤을 때 매우 매력적으로 보입니다:\n\n```js\nstruct TimesTable {\n    let multiplier: Int\n\n    subscript(index: Int) -> Int {\n        return multiplier * index\n    }\n}\n\nlet table = TimesTable(multiplier: 3)\nlet result = table[5]  // 결과 = 15\nprint(result)\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n서브스크립트가 그렇게 나쁘지는 않지만 테이블[5]을 읽는 일반적인 개발자들은 테이블이 배열이라고 생각하고 다섯 번째 항목에 접근하려는 것으로 생각할 것입니다. 이는 바로 그게 아니기 때문에 코드 리뷰나 파일 간, 모듈 간 사용 시 가독성이 떨어집니다. 논리적인 코드 난독화는 피해야 합니다. 이겪하고자 하는 점이 명확하지 않아서 널리 사용되지 않는 것 때문에 이것을 추천하지는 않습니다.\n\n# 확장(Extensions) 남용\n\n확장은 가독성과 모듈화를 높입니다. 디자인 상, 보호기능이 없는 특성이며 난잡한 코드나 불필요한 사용 또는 안티패턴으로 이어질 수 있습니다.\n\n먼저, 이 규칙을 활성화하지 않았다면, 활성화해야 합니다. 이 규칙은 확장의 일부 불필요한 사용을 감지합니다. 예를 들어, ViewController의 델리게이트를 같은 파일에서 확장을 사용해 구현하지만 어떤 프로토콜 준수 제한도 없거나 그러한 것을 분할하는 경우 등을 감지합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nclass MyViewController: UIViewController{\n  private var IBOutlet textfield: UITextField\n\n  textfield.delegate = self\n...\n}\n\n// To Avoid❌\nextension UIViewController: UITextViewDelegate {\n\n}\n```\n\n올바르지 않은 SOLID 확장 사용 예시:\n\n```js\ncontainer.register(Buyable.self, NetworkManager())\n\nclass NetworkManager {\n  var user: User\n}\n\nprotocol Buyable {\n  func canBuy() -> Bool\n}\n\nIn Buy.swift\nextension NetworkManager: Buyable {\n  @Inject var cart: CartStore\n\n  func canBuy() -> Bool {\n    if cart.hasEnough { return true} else { return false }\n    //we can still access to user here...\n  }\n\n}\n\nclass CartViewModel {\n  @Inject var buy: Buyable // Illusion to have a Buyable\n\n  func addItem() {\n    if buy.canBuy() { /* */ }\n\n  }\n\n}\n```\n\n우리는 Buyable이 Buy 객체의 프로토콜일 수 있다는 환상을 갖고 있지만, 전혀 그렇지 않습니다. 이를 서로 다른 파일에 걸쳐 사용하면서 매우 지저분한데다가 혼란스럽습니다. 하지만... 작동합니다. (코틀린에서는 이렇게 하는 것이 불가능합니다).\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# Property wrappers\n\n테이블 태그를 Markdown 형식으로 변경하면 다음과 같습니다.\n\nI love them, for writing cross native code, property wrappers is an awesome feature. First usecase from the swift community was to use them for improving the usage of Injection (like Swinject), can lead to read source code like a dagger-hilt style and it’s the equivalent of the delegated properties in Kotlin. But like Kotlin, it has the same drawbacks: readability / logic obfuscation / spagetthi architecture.\n\n```js\n@propertyWrapper\nstruct Sanitized {\n    private(set) var value: String = \"\"\n\n    var wrappedValue: String {\n        get { value }\n        set { value = newValue.trimmingCharacters(in: .whitespacesAndNewlines) }\n    }\n\n    init(wrappedValue initialValue: String) {\n        self.wrappedValue = initialValue\n    }\n}\n\nstruct User {\n    @Sanitized var username: String\n}\n\n// Exemple d'utilisation\nvar user = User(username: \"   Chris   \")\nuser.\nprint(user.username) // Output: \"Chris\"\n```\n\nHow can we really use this as a business rule implementation? If we want to add additional features to our string, we will have to add them inside our Sanitized property wrapper or write them outside to maintain a single responsibility principle. Why isn`t Sanitized a function of your User? It may create inconsistency. Property wrappers should be used wisely and could be replaced by small extensions 💡.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 게터/세터 재정의\n\n이것은 정사각형/속성 감싸기와 거의 비슷합니다. didSet의 사용은 로직을 혼란스럽게 만들 수 있으며 이해하기 어렵게 만들 수 있습니다:\n\n```js\nstruct Temperature {\n    var celsiusValue: Double {\n        didSet {\n            print(\"무슨 일이 일어났어요\")\n        }\n    }\n\n    init(celsiusValue: Double) {\n        self.celsiusValue = celsiusValue\n    }\n}\n\nvar temp = Temperature(celsiusValue: 20)\ntemp.celsiusValue = 25\n//무슨 일이 일어났어요\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이건 명백해 보일지 모르지만 때로는 강제 언래핑 할 때 어떻게 해야할지 모르겠어요 (그리고 이것이 꼭 멋진 기능은 아닐 수 있어요) - 함수 호출이 확실히 동작할 것이라고 가정하는 것이 유혹스러울 수 있습니다 (하지만 옵셔널 값을 반환할 수도 있어요). 그렇다면, 만약 여러분의 코드가 아니라면 결국 실패할 수 있는 가능성을 가정해야 해요. 예를 들면:\n\n```js\n// SPM에서 UIFont를 로드하려고 하는 경우\nregisterFont(\"font.ttf\") // font가 로드된 것으로 가정합니다\n\n// ❌ 하지마세요\nlet font = UIFont(name: \"font.ttf\")!\n\n// 하세요\nguard let font = UIFont(name: \"font.ttf\") else {\n    Crashlytics.record(\"font.ttf failed to be registered\") // 충돌을 모니터링합니다\n    return // 또는 fatalError() 또는 기본 폰트를 인스턴스화하세요\n}\n```\n\n# 결론\n\n고급 언어 기능 사용은 라이브러리나 구조적인 프레임워크/사용자 정의 아키텍처를 사용하는 것과 유사합니다: 현명하게 사용되어야 하며, 팀으로 수용되어야 합니다. 새로운 프로젝트에 참여하는 새로운 사람이 이 코드 라인을 읽었을 때, 쉽게 이해할 수 있는지 아닌지 고려해야 합니다. 학습은 함의하거나 빛나는 새로운 기능을 남용하지 않는 시점을 인식하거나 더 전통적인 방식으로 돌아가야 하는 시점을 받아들이는 것 또한 포함됩니다 😀.\n","ogImage":{"url":"/assets/img/2024-05-17-ThecoolSwiftfeaturesthatyoushouldnotabuse_0.png"},"coverImage":"/assets/img/2024-05-17-ThecoolSwiftfeaturesthatyoushouldnotabuse_0.png","tag":["Tech"],"readingTime":8},{"title":"어이쿠, 내 앱이 성공했는데 접근성에 대해 생각하지 않았어요","description":"","date":"2024-05-17 18:44","slug":"2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility","content":"\n본인이 천재적인 앱 아이디어, 새로운 일자리, 또는 벤처 자본을 받았을 때, 새로운 기능을 배포하는 데만 시선을 집중하는 유혹이 감도는 건 이해합니다.\n\n올바른 방식으로 집중한다면, 이러한 집중은 앱을 다운로드 차트의 정상으로 랭킹시키며 성과를 거둘 수 있습니다. 그렇지만 그것으로 충분하지 않습니다. 모두가 본인의 앱을 사용하기 전까지 멈출 수 없을 겁니다.\n\n이런 믿을 수 없는 목표를 달성한 후, 현실적인 진실을 알아차립니다: 6명 중 1명이 본인의 앱이 고장나있다고 생각합니다.\n\n그런 다음, 깨닫게 됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n16%의 사람들이 어떤 형태의 접근성(a11y - 멋진 친구 중 하나라면) 요구사항을 가지고 있습니다. 그러나 자유롭게 움직이면서 일할 때, 쉽게 a11y를 뒷전에 두는 경우가 많습니다. 특히 기한에 쫓기고 리더십으로부터 제한된 참여를 받을 때 말이죠.\n\n더 성공하게 되면, 사용자들의 접근성 요구를 인정하지 못한 것으로 비판받을 확률이 커집니다. 불행히도 이를 우선적으로 다루기가 어렵습니다. 영향력 있는 누군가가 접근성을 옹호하지 않는 한 말이죠.\n\n오늘은 도와드리겠습니다. 앱을 접근성에 맞춰 빠르게 개선하는 방법을 보여드릴게요:\n\n- SwiftUI 앱에서 a11y를 점검합니다.\n- 모든 텍스트 크기에서 앱을 잘 보이도록 만듭니다.\n- 화면 낭독기를 사용할 수 있게 만듭니다.\n- 이해관계자들을 설득하여 a11y를 우선시하도록 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 기사를 위해 특별히 만든 캣 테마 동반 앱을 살펴볼 것입니다. 표면 상으로는 괜찮아 보이지만, a11y(웹 접근성) 관점에서 평가를 시작하자마자 완전히 망가진 상태입니다.\n\n기술을 완전히 이해하고 싶다면, 코드를 함께 작성해보세요! 우리는 이 기사에서 자세히 다룬 모든 기술을 구현하기 위해 Before/ 폴더에서 시작합니다 (최종 및 개선된 앱은 After/ 폴더를 참조하세요).\n\n# 앱의 접근성(A11y) 감사\n\na11y(웹 접근성)를 제대로 이해하려면 실제 장치에서 접근성을 테스트해야 합니다. 이것이 모든 사용자가 앱과 상호 작용하는 방식입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n접근성(a11y) 작업을 진행할 때는, 먼저 컨트롤 센터를 최적화해야 합니다. 정말 대단한 시간을 절약할 수 있어요.\n\n아이폰 설정으로 이동하여, 컨트롤 센터에 \"텍스트 크기\" 컨트롤과 \"접근성 바로 가기\"를 추가해보세요. \"텍스트 크기\"를 추가하면, 어떤 어플에서든 어디서든 밑으로 스와이프하여 텍스트 크기를 즉시 선택할 수 있어요. 심지어 어플당 크기 조절도 가능해요.\n\n\"접근성 바로 가기\"를 추가하면, 어시스티브터치(AssistiveTouch), 보이스오버(VoiceOver), 색상 필터, 모션 감소 등 다양한 접근성 기능을 쉽게 적용할 수 있어요. 하지만 잠금 버튼을 세 번 누르면 동일한 메뉴가 나오기 때문에 더 쉽게 접근할 수 있어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 텍스트 크기 감사\n\niOS에서는 extraSmall부터 accessibilityExtraExtraExtraLarge(즉, AX5)까지 12가지의 텍스트 크기 옵션이 있습니다. 최대 크기인 accessibilityExtraExtraExtraLarge는 기본(큰) 크기보다 약 310%\\* 더 큽니다.\n\n텍스트 크기가 정상적으로 작동하는지 확인하기 위해 두 가지 감사를 선호합니다:\n\n- 앱을 가장 큰 일반 폰트인 extraExtraExtraLarge(즉, xxxl)로 테스트하고, 가급적 볼드 텍스트 접근성 설정도 활성화하세요. 이는 상대적으로 일반적인 가장 큰 폰트로, 제 어머니도 이 폰트를 사용합니다. 앱은 이 크기에서 잘 보여야 합니다.\n- 앱을 가장 큰 접근성 폰트인 AX5로 테스트하세요. 이 크기는 익숙하지 않다면 우스꽝스러울 수 있지만, 이 크기밖에는 앱과 상호작용할 수 있는 방법이 없는 사람들이 있습니다. UI를 이 크기로 완벽하게 만드는 것은 어려울지라도, 접근성 텍스트 크기 설정에서 앱이 작동하는지조차 확인하지 않은 회사는 명백히 부족합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저희 앱을 한 번 살펴보겠습니다.\n\n![앱 스크린샷](/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_1.png)\n\n바로 앱을 실행해보면, 정성껏 디자인한 로그인 UI가 텍스트 크기 조절 시 문제가 발생합니다. 저희는 대용량의 텍스트 크기를 예상하지 못했기 때문에 내용을 스크롤할 필요가 있다는 생각조차 하지 못했습니다.\n\n더 나아가서, 색맹일 경우 로그인 버튼의 대비가 미미하여 버튼을 읽을 수 없을 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리 앱의 메인 목록 화면도 확인해 봅시다.\n\n![Main List Screen](/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_2.png)\n\n이 화면은 덜 '부서지는' 느낌이 나요. 모든 것이 보이지만 액세스 가능한 크기의 폰트를 사용하는 사람에게는 이 크기에서 앱을 테스트하지 않았다는 것이 분명합니다. 공간을 다투는 텍스트 레이블이나 순창방에서 아이콘만큼 큰 캡션을 보세요.\n\n## 스크린 리더 오디트\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n일부 사용자는 텍스트 크기 조정에 영향을 받지 않습니다 — 그들은 앱과 상호 작용하기 위해 스크린 리더기가 필요할 수 있기 때문입니다.\n\niOS VoiceOver는 여기서의 중요한 작업을 훌륭하게 처리하므로 여러분 팀의 약간의 배려가 큰 차이를 만들어냅니다.\n\n텍스트 크기 감사와 마찬가지로 스크린 리더기 감사도 실제 기기에서 하는 것이 가장 좋습니다 (잠금 버튼을 3번 눌러보세요, 기억하세요!). 또한 Xcode에 내장된 개발자 도구인 접근성 검사 도구가 VoiceOver 작업에 도움이 됩니다.\n\n![2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_3.png](/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_3.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n앱을 통해 걸어가면, 텍스트 크기 조정과 비교하면 적어도 깨진 부분이 적은 편이에요. 하지만 이미지와 같은 많은 UI 영역이 전혀 보이지 않아 사용자에게 직접적인 지원이 되지 않아요. 그 이유는 접근성 레이블을 추가하는 데 신경을 쓰지 않았기 때문이죠.\n\n![이미지1](/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_4.png)\n\n특히 VoiceOver를 사용하지 않은 경우, 화면 리더기가 모든 UI 요소를 반복하며 읽어주지만 아이콘에는 라벨이 붙어있지 않아 명확합니다.\n\n![이미지2](/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_5.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n큰 목록이 있으면 상황이 더 악화됩니다.\n\nSwiftUI에 내용에 대한 정보를 제공하지 않으면, 스크롤 가능한 내용의 아래쪽 로그아웃 버튼으로 이동하려면 100번 이상 스와이프해야 할 수도 있는 상황에 처하게 될 수 있습니다. 페이징에 대해서 시작도 하지 마세요.\n\n![앱 접근성을 고려하지 않고 앱이 성공적이라고 생각하지 않은 경우 스크린샷](/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_6.png)\n\n우리 앱을 접근성이 좋은 앱이라고 부를 수 있기 전에 해결해야 할 문제가 많습니다. 다행히 SwiftUI에는 a11y에 대해 신속하게 파악할 수 있는 도구가 가득합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 스피드런 액세시빌리티\n\n이제 문제가 어디에 있는지 알았으니, 하나씩 빠르게 해결해 나갈 수 있어요.\n\n## 스크롤 가능한 콘텐츠\n\n이것은 가장 불편한 문제입니다. 큰 텍스트 크기에 대한 스크롤 뷰로 확장되지 않아 앱 온보딩이 완전히 망가졌어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리의 감사에서는 로그인 화면 버튼이 폰트 크기가 커짐에 따라 화면 밖으로 밀렸습니다. 나머지 텍스트 내용은 서로 밀어붙여져 레이블이 겹치고 확장할 공간이 없어 잘린 것처럼 보였어요.\n\n자연스러운 해결책은 콘텐츠를 스크롤 가능하도록 만드는 것입니다. 그러나 모든 화면이 컨텐츠가 잘 맞는 경우에도 스크롤이 자유롭게 되어서는 안 됩니다. 우리는 Ionic 앱을 만드는 일이 아니에요. _억압된 기억으로 전율을 느끼며_\n\n이 문제는 사용자 지정 뷰 수정자로 해결할 수 있습니다. 제가 a11yScrollView()라고 부르는 이 뷰 수정자의 목표는 화면 내용을 스크롤 뷰로 감싸지만 필요한 경우에만 발생하도록 하는 것입니다. 이것을 작은 라이브러리 A11yUtils에 추가하여 여러분의 코드에서 사용할 수 있도록 했어요.\n\n현재 이것은 iOS 16.4 이상에서만 우리의 꿈이 되는 동작을 실현합니다 — 이미 콘텐츠가 맞는 경우 스크롤을 방지하기 위해 스크롤 뷰에 scrollBounceBehavior를 적용합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n미래에는 iOS 16에서 ViewThatFits\\* 및 iOS 15에서 GeometryReader와 함께 작동하도록하고 싶습니다.\n\nOS 버전을 지정하는 사람이 주위에 없기 때문에 저희 온보딩 뷰의 VStack에 이 수정자를 적용할 수 있습니다.\n\n```swift\n// OnboardingView.swift\n\nimport A11yUtils\nimport SwiftUI\n\nstruct OnboardingView: View {\n\n    @Binding var isLoggedIn: Bool\n\n    var body: some View {\n        NavigationStack {\n            VStack(spacing: 20) { /* ... */ }\n              .padding(.horizontal)\n              .a11yScrollView()\n              .navigationTitle(\"Create account\")\n        }\n    }\n}\n```\n\n이제 콘텐츠가 멋지게 스크롤되어 xxxl, AX3 및 AX5에서 잘 보입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_7.png\" />\n\n## 스페이서는 코드 냄새입니다\n\n온보딩 화면을 작업하는 동안, 우리가 할 수 있는 또 다른 간단한 개선 사항이 있습니다:\n\n```js\nVStack(spacing: 20) {\n    // ...\n    OnboardingReasonsText()\n    Spacer()\n    LoginButtonView()\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n텍스트 크기가 크면 화면 공간이 제한되어 Spacer()를 사용하면 문제가 발생할 수 있습니다. SwiftUI 레이아웃 엔진은 공간을 만들기 위해 열심히 노력합니다. 심지어 그 공간이 더 이상 없어도 텍스트가 절단되는 문제가 발생할 수 있습니다.\n\n이러한 시나리오에서 스페이서를 매우 좁은 높이로 압축해도 VStack에 정의된대로 위아래로 각각 20포인트의 공간이 생길 것입니다.\n\n우리는 Spacer()를 frame() 수정자로 바꿀 수 있습니다:\n\n```js\nVStack(spacing: 20) {\n    OnboardingReasonsText()\n    LoginButtonView()\n        .frame(maxHeight: .infinity, alignment: .bottom)\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n프레임은 더 신뢰할 수 있는 방식으로 작동합니다: SwiftUI는 이 버튼 위에 가능한 한 많은 공간을 제공해야 함을 알지만, 여백 자체가 UI의 중요한 부분이 아니기 때문에 공간이 부족하면 불필요한 여백이 적용되지 않습니다.\n\n이 프레임 수정자는 의미가 더 명확합니다. 즉, SwiftUI에게 우리의 의도를 명확하게 전달합니다. 이것은 a11y와 관련된 중요한 개념이므로 나중에 더 자세히 다룰 것입니다.\n\n## 이미지와 아이콘의 확대\n\n다이나믹 타입 덕분에 iOS는 사용자가 선택한 글꼴 크기에 따라 앱 내 글꼴을 자동으로 확대합니다. 이것은 사용자 정의 글꼴과도 쉽게 구현할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이는 SwiftUI에서 의미있는 글꼴 크기를 사용할 때 텍스트가 자동으로 조절된다는 것을 의미합니다.\n\n```js\nText(cat.quote)\n    .font(.body) // 이것도 잘 작동합니다\n```\n\n더 좋은 것은 SFSymbols를 사용할 때 아이콘에도 동적 글꼴 크기를 적용할 수 있다는 것입니다!\n\n```js\nImage(systemName: \"heart.circle.fill\")\n    .font(.body) // 이것도 SFSymbols와 잘 작동합니다\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n안타깝게도 대부분의 iOS 앱에는 Android 버전이 있으므로, 디자이너가 SFSymbols을 사용하는 대신 맞춤 아이콘을 만든다는 점에 유의하셔야 합니다. 대부분의 앱은 사용자 정의 이미지와 미디어를 포함합니다.\n\n따라서 우리의 예시인 Before/에서는 아이콘을 SwiftUI에 추가하는 일반 이미지처럼 처리하여, 하드코딩된 크기를 사용했습니다.\n\n```js\nImage(cat.image)\n    .resizable()\n    .aspectRatio(contentMode: .fit)\n    .frame(width: 72, height: 72) // 하드코딩된 크기 - 확장되지 않을 것입니다!\n    .clipShape(Circle())\n\nImage(systemName: cat.icon)\n    .resizable()\n    .aspectRatio(contentMode: .fit)\n    .foregroundStyle(.secondary)\n    .frame(width: 24, height: 24) // 하드코딩된 크기 - 확장되지 않을 것입니다!\n```\n\n결과는 어떻게 될까요? 가장 큰 글꼴 크기로 조정했을 때, 콘텐츠가 매우 어울리지 않게 보일 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![image](/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_8.png)\n\nSwiftUI에는 사용자 정의 이미지 및 뷰에서 동적 타입의 파워를 제공하는 멋진 도구인 @ScaledMetric 프로퍼티 래퍼가 있습니다.\n\n```swift\n@ScaledMetric(relativeTo: .largeTitle) private var imageSize: CGFloat = 72\n@ScaledMetric(relativeTo: .body) private var iconSize: CGFloat = 24\n```\n\n우리는 @ScaledMetric을 자체로 사용할 수 있으며, 이는 기본 body 글꼴 크기 조정을 사용합니다. relativeTo를 사용하면 SwiftUI가 어떻게 조정할 지 알 수 있으므로 더 좋습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nlargeTitle은 이미 상당히 크기 때문에 조금 더 확장됩니다. 캡션 스타일의 글꼴은 더 많이 확장됩니다. 이 경우 아이콘은 본문 크기 조정이 되어 동반하는 인용문 텍스트와 일치합니다.\n\n```js\nImage(cat.image)\n    .resizable()\n    .aspectRatio(contentMode: .fit)\n    .frame(width: imageSize, height: imageSize) // 동적 크기 조정\n    .clipShape(Circle())\n\nImage(systemName: cat.icon)\n    .resizable()\n    .aspectRatio(contentMode: .fit)\n    .foregroundStyle(.secondary)\n    .frame(width: iconSize, height: iconSize) // 동적 크기 조정\n```\n\n이제 이미지가 텍스트와 함께 더 합리적으로 보입니다.\n\n<img src=\"/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_9.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 콘텐츠 정렬하기\n\n이미지는 더 잘 확장되지만, 여전히 텍스트 라벨이 공간을 지배하며 UI가 깨져 보입니다. 레이아웃 엔진과의 협상을 끝내고 나니, 줄바꿈으로 가득 차 있습니다.\n\n만약 사용자의 텍스트 확장에 기반한 컨텐츠의 정렬이 가능하다면 어떨까요?\n\n다행히도, 라이브러리 A11yUtils 덕분에 A11yHStack을 활용할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n새로운 SwiftUI 도구 릴리스 속도가 빨라서 (그리고 Apple의 뒷전포기가 혹독해서), 이것은 최소 지원 OS에 기반을 둔 두 가지 다른 구현을 가지고 있어요:\n\n- iOS 16에서는 ViewThatFits를 사용하여 HStack이 모든 내용을 포함할 수 있는지 확인하고, 그렇지 않으면 내용을 정렬하기 위해 VStack을 사용합니다.\n- iOS 15에서는 더 단호한 방식을 적용하여, @Environment(\\.sizeCategory)를 확인하고, 접근성 텍스트 크기 범주 (예: AX1, AX2 또는 AX5) 가 사용된 경우에는 VStack으로 전환합니다.\n\n다음은 간단한 접근 방식입니다:\n\n```js\n@Environment(\\.sizeCategory) private var sizeCategory\n\nvar body: some View {\n    if sizeCategory.isAccessibilityCategory {\n        VStack(alignment: .leading, spacing: spacing) {\n            content()\n        }\n        .frame(maxWidth: .infinity, alignment: .leading)\n    } else {\n        HStack(alignment: alignment, spacing: spacing) {\n            content()\n        }\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n@Environment(\\.sizeCategory)은 중요한 경우에 사용할 수 있는 유용한 도구입니다. 사용자가 접근성 텍스트 크기 범주를 사용하는지 여부를 알아야 하는 경우 (isAccessibilityCategory와 함께). 때로는 이 속성을 사용하여 대량 콘텐츠 크기에 맞지 않는 이미지와 같은 불필요한 UI 요소를 제거하는 데 활용합니다.\n\n더 현대적인 구현은 비슷하게 동작하지만 ViewThatFits를 활용하여 콘텐츠가 맞지 않는 경우에만 재분배됩니다:\n\n```js\nvar body: some View {\n    ViewThatFits {\n        HStack(alignment: alignment, spacing: spacing) {\n            content()\n        }\n        VStack(alignment: .leading, spacing: spacing) {\n            content()\n        }.frame(maxWidth: .infinity, alignment: .leading)\n    }\n}\n```\n\n생각을 많이 해면 A11yHStack을 몇 군데에 적용할 수 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nimport A11yUtils\n\nA11yHStack {\n    Image(cat.image)\n    VStack {\n        A11yHStack {\n            Text(cat.name)\n            Text(\"\\(cat.age) years old\")\n        }\n        HStack {\n            Image(systemName: cat.icon)\n            Text(cat.quote)\n        }\n    }\n}\n```\n\n이제 컨텐츠가 매우 큰 텍스트 크기에서 더 적절해 보입니다.\n\n<img src=\"/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_10.png\" />\n\n## 스크린 리더 개선사항\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n보이스오버는 퍼즐 조각 중 비교적 간단한 부분입니다.\n\n앱이 스크린 리더와 잘 작동하도록 만드는 것은:\n\n- 시각적 콘텐츠가 충분히 설명되었는지 확인하기.\n- 탐색이 직관적으로 작동되도록 만들기.\n- 뷰가 의미론적으로 올바른지 확인하기.\n\n먼저 시각적 설명부터 시작해보죠. 이것은 우리 레퍼토리에서 가장 간단한 수정 사항입니다: 그래픽 콘텐츠가 VoiceOver에 의해 설명될 수 있도록 보장하는 것입니다. accessibilityLabel 수정자가 우리의 책과 버터라고 할 수 있죠.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nImage(\"catKingdom\").accessibilityLabel(\n  Text(\"나의 세 마리 고양이: 코디, 로지, 루나\")\n);\n```\n\n스크린리더가 현재 초점을 맞춘 대상을 설명하는 방법을 알려줍니다.\n\n![Cat Kingdom](/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_11.png)\n\n이제 주 뷰의 셀에 동일한 방식을 적용할 수 있습니다. Cat 데이터 모델을 약간 수정하여 각 고양이 사진과 함께 이미지 설명을 제공합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nstruct Cat {\n    // ...\n    let imageDescription: String\n}\n\nImage(cat.image)\n    .accessibilityLabel(Text(cat.imageDescription))\n```\n\n이건 들릴만큼 쉽고, Apple 플랫폼에서만 작동하는 경향이 있어요.\n\n![image](/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_12.png)\n\n우리 앱을 통해 탐색할 때, 좀 더 신중하게 할 수 있는 기회가 있어요. 기본 설정으로 VoiceOver는 SwiftUI 뷰 트리의 모든 잎 노드를 반복하며 모든 이미지, 버튼 및 텍스트를 읽어줄 거예요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n가끔 사용자에게 불필요한 탐색을 초래합니다. 저희 앱에서는 각 고양이의 아이콘과 인용구를 건너뛰려면 여러 번 탭해야 합니다. 아이콘의 이름(예: cat.fill)을 읽는 것은 경험에 별다른 도움이 되지 않습니다.\n\n이들을 단일 a11y 요소로 결합하여 screenreader가 탐색 중에 하나의 항목으로 처리할 수 있도록 할 수 있습니다.\n\n```swift\nHStack {\n    Image(systemName: cat.icon)\n    Text(cat.quote)\n}\n.accessibilityElement(children: .combine)\n```\n\n이제 screenreader가 요소를 하나로 이동하는 것을 들을 수 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![image](/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_13.png)\n\n어떤 상황에서는 그래픽적으로 시간이 표시되는 셀렉트한 타이머 요소와 같이 복잡한 UI가 있을 수 있습니다. VoiceOver는 똑똑하지만, 설명되지 않은 뷰들의 번잡한 모음에서 유용한 정보를 유추하지는 못합니다.\n\n여기서 accessibilityRepresentation 수정자가 정말 유용하게 사용됩니다. 이를 통해 뷰의 VoiceOver UI를 완전히 사용자 정의된 접근성 표현으로 대체할 수 있습니다.\n\n최근에 개발한 개인 프로젝트 'Check 'em'에서는 사용자의 2단계 인증 코드가 카운트다운과 함께 표시되어 해당 기능이 특히 유용했습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```swift\n// AccountView.swift\n\nstruct AccountView: View {\n\n    var body: some View {\n        Section(account.name) {\n            // Image, 2FA Code Text, and Countdown UI ...\n        }\n        .accessibilityRepresentation {\n            VStack {\n                Text(account.name)\n                if let code = account.code {\n                    ForEach(Array(code.enumerated()), id: \\.0) {\n                        Text(String($0.1))\n                    }\n                }\n                if let countdown = account.countdown {\n                    Text(\"Expires in \\(countdown)\")\n                }\n            }.accessibilityElement(children: .combine)\n        }\n    }\n```\n\n이 modifier를 사용하여 각 셀 요소를 순서대로 반복하는 것보다 훨씬 유용한 완전히 사용자 정의 된 VoiceOver 인터페이스를 소개할 수 있었습니다. 또한 화면 낭독기가 \"676,252\"를 \"육십 칠만 육천 이백 오십 이\"로 읽는 것을 방지했습니다.\n\n![Screenshot](/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_14.png)\n\n## Native components\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 어플리케이션의 주요 뷰는 저희 콘텐츠를 배치하는 일반적이지만 조잡한 방법을 사용합니다: ForEach 내에 있는 셀을 래핑하는 방식으로 LazyVStack을 래핑하고 ScrollView로 래핑합니다.\n\n```js\nScrollView {\n    LazyVStack(spacing: 24) {\n        ForEach(cats, id: \\.name) {\n            CatView(cat: $0)\n        }\n    }\n}\n```\n\n최적의 방법은 가능한 한 SwiftUI의 기본 구성 요소를 활용하는 것입니다. 이 경우에는 List가 가장 적합합니다.\n\nApple은 사용자 정의 UI 대신 iOS-Settings 스타일의 List를 사용하려면 모디파이어를 3개 추가해야 한다는 점을 설명할 때, 이 작업을 좀 더 어렵게 만들어 놓았습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n목록(고양이) {\n    고양이뷰(고양이: $0)\n        .목록행배경(Color.clear)\n        .목록행구분선(.숨김)\n}\n.목록스타일(일반목록스타일())\n```\n\n이제 보일러플레이트를 작성했으니 수정자들을 자유롭게 사용하여 SwiftUI 목록에서 자체 UI를 사용할 수 있습니다.\n\n<img src=\"/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_15.png\" />\n\n한 가지 질문이 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n왜 네이티브 컴포넌트를 사용하는 것에 이렇게 많은 노력을 기울일까요?\n\n먼저, 비 접근성(a11y) 관련 이유: SwiftUI List는 UICollectionView를 사용하여 구현됩니다. 이는 고성능 스크롤링을 위해 셀 재사용을 활용하며 항목이 많아도 성능을 유지합니다. 그에 반해 LazyVStack은 이전에 렌더링된 모든 셀을 메모리에 유지하므로 많은 항목을 스크롤하는 경우 성능이 뚝뚝 떨어집니다.\n\n네이티브 컴포넌트를 사용하는 a11y 관련 이유는 간단하지만 다양합니다:\n\nList는 의미론적 의미가 있습니다: 화면 판독기에게 비슷한 콘텐츠 컬렉션을 포함하는 컨테이너임을 알려줍니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이것이 많은 목록 항목이 있는 경우, 순진한 구현이 망가진 이유입니다: VoiceOver로 목록 컨테이너를 건너뛸 수 있게 해주지 않고 모든 항목을 스와이프해야만 로그아웃 버튼에 도달할 수 있었습니다.\n\nList를 사용하면 SwiftUI가 화면 판독기에게 그 내용이 단일 컨테이너임을 알려줄 수 있어, 화면 판독기가 쉽게 이동할 수 있습니다.\n\n아래는 Markdown 형식으로 변경된 이미지 링크입니다:\n\n![이미지](/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_16.png)\n\n또한 List에는 스와이프 삭제, 드래그 앤 드롭, 키보드 기반 탐색 등 많은 내장 상호작용 모드가 있습니다. 네이티브 컴포넌트를 사용할 때 이들은 자동으로 작동합니다. 사용자 지정 구현과 함께 하는 화면 판독기 작업을 어떻게 할 것인지 아시겠습니까?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n리스트는 심지어 가장 복잡한 컴포넌트도 아닙니다. 사용자 정의 그리드나 레이아웃 프로토콜을 사용하지 않는 뷰의 사용자 정의 분배에 a11y를 어떻게 구현할 것인가요?\n\n# 이해관계자 설득\n\n이제 SwiftUI 앱에서 a11y를 빠르게 실행하는 방법을 이해했으니, 작업에 착수하기 전에 남은 퍼즐 조각은 비즈니스의 나머지 구성원으로부터 승인을 얻는 것입니다. 여기서 당신이 조직적 영향력을 행사하는 소프트 스킬을 펼칠 수 있습니다.\n\n당신이 휘둘 수 있는 큰, 둔한 도구 중 하나는 입법의 망치입니다. 영국, 미국, 그리고 EU와 같은 세계 각국은 디지털 서비스가 접근성의 최소 기준을 충족해야 한다는 법률을 시행했습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n또한, 웹 접근성(웹 콘텐츠 접근성)은 실제로 비즈니스에서 큰 이점을 제공합니다. 현재 세계 인구의 16%가 중요한 장애를 겪고 있습니다. 즉, 다양한 요구에 맞게 서비스를 제공함으로써 사용자, 긍정적인 리뷰 및 수익을 놓칠 수 있습니다. 대상 시장에 따라 이는 더 또는 덜 중요할 수 있습니다.\n\n작은 규모에서는, 접근성을 제품 부채로 다루는 것보다 앱이 어떻게 오작동하는지 간단히 보여주는 것이 훨씬 효과적이라는 것을 발견했습니다. 접근성 요구사항을 추상적인 개념에서 벗어나서 버그 있는 가입 플로우를 보여주는 것이 어떤 엔지니어링 조직에게도 더 설득력있을 것입니다.\n\n제품에 쉽게 접근할 수 있도록 옹호하는 영향력 있는 리더십 속에 있는 옹호자를 가지는 것이 가장 도움이 됩니다. 물론, 모든 조직이 다르기 때문에 이 조언을 적용할 때 결과가 다를 수 있습니다.\n\n가장 중요한 것은, 이제 웹 접근성을 빠르게 적용하고 제품이 완전히 접근 가능한 상태라면?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n공을 놓치지 마세요!\n\n기술 부채와 마찬가지로, 이제 좋은 위치에 있으니 a11y를 표준 개발 워크플로에 통합할 수 있습니다. 이미 알고 계시니 빠르고 쉽게 할 수 있어요!\n\n# 결론\n\n오늘 많은 내용을 다뤘습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n먼저 앱을 감사하여 대화형 텍스트 스케일링 또는 VoiceOver를 사용할 때 발생하는 일반적인 접근성 오류를 확인하는 프로세스를 거쳤습니다.\n\n텍스트 스케일링을 사용할 때 발생하는 문제를 수정하고, a11yScrollView로 스크롤링을 적용하고, @ScaledMetric으로 콘텐츠 스케일링하고, A11yHStack으로 정렬하는 방법을 살펴보았습니다.\n\n화면 판독기에서 앱이 잘 작동하도록 만들기 위해 accessibilityLabels를 구현했고, accessibilityElements를 결합하고, 심지어 완전히 사용자 정의된 accessibilityRepresentations도 구현했습니다.\n\n네이티브 SwiftUI 구성 요소 대신 사용자 지정보기를 사용하는 이유에 대해 논의했습니다. 이유로는 의미론, 상호 작용 모드 및 성능이 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n마침내, 당신이 조직 내에서 접근성에 진지하게 대응하기 위해 소프트 스킬을 적용하는 방법을 살펴보았습니다.\n\n당신이 SwiftUI 앱에서 접근성에 진지하다면, 동반 앱을 통해 이러한 기술들을 직접 구현해보는 것을 적극 권장합니다. 도구를 체득하는 가장 좋은 방법이죠. 지금까지 작업해온 사이드 프로젝트가 있다면, 그것 역시 좋은 시작점일 것입니다.\n\n내 A11yUtils 라이브러리에 기여 (문제 포함)를 기쁘게 받아들이겠습니다. 지금도 SwiftUI에 이미 있는 API를 보완하기 위한 포괄적인 접근성 도구 모음으로 이것을 발전시키기 위해 커뮤니티와 협력하고 싶어합니다.\n","ogImage":{"url":"/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_0.png"},"coverImage":"/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_0.png","tag":["Tech"],"readingTime":27}],"page":"113","totalPageCount":116,"totalPageGroupCount":6,"lastPageGroup":16,"currentPageGroup":5},"__N_SSG":true}