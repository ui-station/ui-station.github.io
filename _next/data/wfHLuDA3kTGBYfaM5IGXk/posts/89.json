{"pageProps":{"posts":[{"title":"리액트 네이티브에서의 애니메이션으로 구현한 타이핑 효과의 매력","description":"","date":"2024-05-20 16:23","slug":"2024-05-20-TheMagicofAnimatedTypingTransitioninReactNative","content":"\n제 웹사이트에 방문해주셔서 감사합니다!\n\n![Click Here](https://miro.medium.com/v2/resize:fit:852/1*nUVr8lekbEbpfkq53IZ2fQ.gif)\n\n당신의 React Native 앱의 사용자 경험에 몇 가지 풍미를 더하고 싶나요? 애니메이션된 타자 효과의 매료되는 세계로 빠져들어보세요! 이 글에서는 글자가 한 글자씩 나타나는 화려한 애니메이션 효과를 생성하는 방법을 살펴볼 것입니다. 이 애니메이션은 사용자에게 매혹적인 타자 경험을 제공합니다.\n\n이 매혹적인 효과를 어떻게 달성하는지 단계별로 코드를 자세히 살펴보면서 시작해봅시다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 초기 설정: 필요한 모듈을 가져와 컴포넌트의 props를 정의하는 것으로 시작합니다.\n- 상태 관리: 컴포넌트는 React 훅 (useState 및 useRef)을 사용하여 상태와 참조를 관리합니다. text 상태는 현재 표시된 텍스트를 보유하고, completed는 입력이 완료되었는지를 나타내며, cursorColor는 커서 표시 여부를 관리합니다. 또한 textIndex를 추적하여 다음에 표시할 문자를 파악합니다.\n- 스타일링: StyleSheet.create를 사용하여 텍스트의 모양을 사용자 정의하는 스타일을 정의합니다.\n- 타이핑 애니메이션: typingAnimation 함수는 주요 애니메이션 논리를 처리합니다. text prop에서 문자를 순차적으로 추가하여 입력하는 것을 모방하여 현재 표시된 텍스트에 문자를 추가합니다. 부드러운 애니메이션을 위해 재귀적 setTimeout이 사용됩니다.\n- 커서 애니메이션: cursorAnimation 함수는 깜빡이는 효과를 만들기 위해 커서의 색상을 토글합니다.\n- 효과 및 정리: useEffect 훅은 애니메이션 타이밍과 정리를 관리합니다. 컴포넌트가 마운트될 때 타이핑 애니메이션 및 커서 깜박임을 시작하고 언마운트할 때 타이머를 정리합니다.\n\n이제 앱에서 이 컴포넌트를 생성하는 방법을 살펴보겠습니다:\n\n```js\nimport React, { useRef, useState, useEffect } from 'react';\nimport { StyleSheet, Text } from 'react-native';\n\ninterface AnimatedTypingProps {\n  text: string;\n  onComplete?: () => void;\n}\n\nconst AnimatedTyping: React.FC<AnimatedTypingProps> = (props) => {\n  // 코드 생략\n\nexport default AnimatedTyping;\n```\n\n컴포넌트에서 AnimatedTyping을 가져와 원하는 텍스트 및 onComplete 콜백과 함께 사용하면 됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```jsx\n<AnimatedTyping text={query} onComplete={handleAnimationDefaultComplete} />\n```\n\n저희와 함께 이 자극적인 애니메이션 기술을 살펴봐 주셔서 감사합니다! LinkedIn에서 의견과 피드백을 남겨주시면 감사하겠습니다. 연락해서 경험을 공유해주세요. 즐거운 코딩하세요!\n\n# 매우 쉽게 설명하기 🚀\n\nIn Plain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 떠나시기 전에:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 저자를 응원하고 팔로우하기 잊지 마세요! 👏️️\n- 저희를 팔로우하세요: X | LinkedIn | YouTube | Discord | 뉴스레터\n- 다른 플랫폼에서도 만나보세요: Stackademic | CoFeed | Venture | Cubed\n- 알고리즘 콘텐츠를 다루도록 강요하는 블로깅 플랫폼에 지쳤나요? Differ를 시도해보세요\n- PlainEnglish.io에서 더 많은 콘텐츠를 만나보세요\n","ogImage":{"url":"/assets/img/2024-05-20-TheMagicofAnimatedTypingTransitioninReactNative_0.png"},"coverImage":"/assets/img/2024-05-20-TheMagicofAnimatedTypingTransitioninReactNative_0.png","tag":["Tech"],"readingTime":3},{"title":"AppDelegate, SceneDelegate, 그리고 SwiftUI 라이프사이클 이해하기","description":"","date":"2024-05-20 16:21","slug":"2024-05-20-UnderstandingAppDelegateSceneDelegateandSwiftUILifecycle","content":"\n<img src=\"/assets/img/2024-05-20-UnderstandingAppDelegateSceneDelegateandSwiftUILifecycle_0.png\" />\n\nAppDelegate는 무엇인가요?\n\niOS의 이전 버전에서, iOS 13 이전에는 AppDelegate라는 것이 있었습니다. 이것은 앱의 보스 역할을 했고, 앱이 시작하거나 중지되거나 백그라운드로 이동할 때 관리를 했습니다. 앱 시작 및 백그라운드 모드 같은 중요한 이벤트를 다뤘습니다.\n\n```swift\nimport UIKit\n\n@UIApplicationMain\nclass AppDelegate: UIResponder, UIApplicationDelegate {\n\n    var window: UIWindow?\n\n    func application(_ application: UIApplication, didFinishLaunchingWithOptions\n                     launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {\n        // 애플리케이션 시작 후 커스터마이징을 위한 오버라이드 포인트입니다.\n        return true\n    }\n\n    func applicationWillResignActive(_ application: UIApplication) {\n        /*\n         애플리케이션이 비활성 상태로 이동할 때 전송됩니다. 일시적으로 인터럽트(예: 전화 통화 또는 SMS 메시지 수신)가 발생하거나 사용자가 애플리케이션을 종료하고 백그라운드 상태로 전환될때 발생할 수 있습니다.\n         계속 중인 작업을 일시 중지하고 타이머를 비활성화하며 그래픽 렌더링 콜백을 무효화하는 데 이 메서드를 사용합니다. 게임은 게임 일시 중지에 이 방법을 사용해야 합니다.\n         */\n    }\n\n    func applicationDidEnterBackground(_ application: UIApplication) {\n        /*\n        공유 리소스를 해제하고 사용자 데이터를 저장하며 타이머를 무효화하며 애플리케이션 상태 정보를 충분히 저장하여 나중에 종료됐을 때 애플리케이션을 현재 상태로 복원하는 데 이 메서드를 사용합니다.\n        애플리케이션이 백그라운드 실행을 지원하는 경우, 이 방법은 사용자가 종료할 때 applicationWillTerminate: 대신 호출됩니다.\n         */\n    }\n\n    func applicationWillEnterForeground(_ application: UIApplication) {\n        /*\n        백그라운드에서 활성 상태로 전환하는 일부로 호출됩니다;\n        여기서 백그라운드 진입 때에 수행되었던 변경을 취소할 수 있습니다.\n         */\n    }\n\n    func applicationDidBecomeActive(_ application: UIApplication) {\n        /*\n        애플리케이션이 비활성 상태일 때 일시 중지된 작업(또는 아직 시작되지 않은 작업)을 다시 시작합니다.\n        애플리케이션이 이전에 백그라운드에 있었을 경우 선택적으로 사용자 인터페이스를 새로 고칩니다.\n         */\n    }\n\n    func applicationWillTerminate(_ application: UIApplication) {\n        /*\n        애플리케이션이 종료되기 직전에 호출됩니다.\n        적절하다면 데이터를 저장합니다. 또한 applicationDidEnterBackground:도 참조하십시오.\n         */\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nSceneDelegate- 뭐야?\n\niOS 13가 출시되었을 때 Apple은 SceneDelegate라는 새로운 기능을 추가했어. 이건 주로 iPad를 위한 거였는데, 이를 통해 다중 창을 사용할 수 있게 됐어. AppDelegate의 일부 업무가 SceneDelegate로 넘어가게 됐어. 그래서 이제 두 개가 함께 앱을 관리하게 되었어.\n\nAppDelegate.swift\n\n```js\nimport UIKit\n\n@main\nclass AppDelegate: UIResponder, UIApplicationDelegate {\n\n    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {\n        // 애플리케이션 시작 후 커스터마이징할 때 오버라이드 포인트\n        return true\n    }\n\n    // MARK: UISceneSession 생명주기\n\n    func application(_ application: UIApplication, configurationForConnecting connectingSceneSession: UISceneSession, options: UIScene.ConnectionOptions) -> UISceneConfiguration {\n        // 새로운 씬 세션을 생성할 때 호출\n        // 이 메소드를 사용하여 새 씬을 만들기 위한 구성을 선택해\n        return UISceneConfiguration(name: \"Default Configuration\", sessionRole: connectingSceneSession.role)\n    }\n\n    func application(_ application: UIApplication, didDiscardSceneSessions sceneSessions: Set<UISceneSession>) {\n        // 사용자가 씬 세션을 삭제했을 때 호출\n        // 응용프로그램이 실행 중이 아닌 경우 어떤 세션이 삭제되었다면, application:didFinishLaunchingWithOptions 이후에 이 메소드가 호출될 거야\n        // 폐기된 씬에 특정한 리소스를 해제하는 데 이 메소드를 사용해, 다시 돌아오지 않을 거니까\n    }\n\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nSceneDelegate.swift\n\n```swift\nimport UIKit\n\nclass SceneDelegate: UIResponder, UIWindowSceneDelegate {\n\n    var window: UIWindow?\n\n\n    func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {\n        // 이 메서드를 사용하여 UIWindow 'window'를 선택적으로 구성하고 UIWindowScene 'scene'에 연결합니다.\n        // Storyboard를 사용하는 경우 'window' 속성은 자동으로 초기화되어 scene에 연결됩니다.\n        // 이 델리게이트는 연결되는 scene이나 세션이 새로운 것임을 의미하지 않습니다 (대신 'application:configurationForConnectingSceneSession' 참조).\n        guard let _ = (scene as? UIWindowScene) else { return }\n    }\n\n    func sceneDidDisconnect(_ scene: UIScene) {\n        // 시스템에 의해 해제되는 즉시 scene이 호출됩니다.\n        // scene이 백그라운드로 들어가거나 해당 세션이 버려질 때 발생합니다.\n        // 이 scene과 관련된 재생성 가능한 리소스를 해제합니다.\n        // scene이 다시 연결될 수 있으므로 세션이 반드시 버려지지는 않습니다('application:didDiscardSceneSessions' 참조).\n    }\n\n    func sceneDidBecomeActive(_ scene: UIScene) {\n        // scene이 비활성 상태에서 활성 상태로 전환된 경우에 호출됩니다.\n        // scene이 비활성 상태였을 때 일시 중단되었던 작업을 다시 시작하는 데 이 메서드를 사용합니다.\n    }\n\n    func sceneWillResignActive(_ scene: UIScene) {\n        // scene이 활성 상태에서 비활성 상태로 전환될 때 호출됩니다.\n        // 일시적인 중단(예: 전화 통화 수신)으로 인해 발생할 수 있습니다.\n    }\n\n    func sceneWillEnterForeground(_ scene: UIScene) {\n        // scene이 백그라운드에서 전경으로 전환될 때 호출됩니다.\n        // 백그라운드로 전환할 때 발생한 변경 사항을 취소하는 데 이 메서드를 사용합니다.\n    }\n\n    func sceneDidEnterBackground(_ scene: UIScene) {\n        // scene이 전경에서 백그라운드로 전환될 때 호출됩니다.\n        // 데이터를 저장하고 공유 리소스를 해제하며 충분한 scene별 상태 정보를 저장하여\n        // scene을 현재 상태로 복원하는 데 이 메서드를 사용합니다.\n    }\n\n}\n```\n\n차이점은 SceneDelegate가 여러 창을 다루는 반면에 AppDelegate는 여전히 평소 역할을 합니다. 따라서 이제 앱은 다른 창에서 다른 내용을 동시에 표시하는 것과 같이 더 많은 일을 할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그리고 SwiftUI는요?\n\nSwiftUI를 사용하면 Apple의 새로운 앱 개발 방법으로, 더 이상 AppDelegate 또는 SceneDelegate가 필요하지 않을 수도 있어요. 대신에 Notification Event로 대부분의 작업을 처리할 수 있어요. 하지만 만약 프로젝트에 아직 AppDelegate 또는 SceneDelegate가 있다면, 코드를 깔끔하고 조직적으로 유지하는 데 도움이 될 거예요.\n\n그래서, 이것이 다른 iOS 버전에서 앱의 주요 매니저들이 작동하는 방식이에요.\n\nSwiftUI에서 AppDelegate를 구현하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- AppDelegate.swift 파일을 만듭니다.\n\n새 파일 추가로 이동 - `Cocoa Touch Class`를 선택합니다.\n\n![이미지](/assets/img/2024-05-20-UnderstandingAppDelegateSceneDelegateandSwiftUILifecycle_1.png)\n\n이름(AppDelegate)을 입력하고 NSObject의 subclass를 선택합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![UnderstandingAppDelegateSceneDelegateandSwiftUILifecycle](/assets/img/2024-05-20-UnderstandingAppDelegateSceneDelegateandSwiftUILifecycle_2.png)\n\nClick on “Next” will create Appdelegate.swift file which look like below\n\n```swift\nimport UIKit\nclass AppDelegate: NSObject {\n\n}\n```\n\n2. With following above process again we can create SceneDelegate.swift file.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![UnderstandingAppDelegateSceneDelegateandSwiftUILifecycle_3](/assets/img/2024-05-20-UnderstandingAppDelegateSceneDelegateandSwiftUILifecycle_3.png)\n\nAppDelegate.swift 파일과 처음으로 나타날 것입니다.\n\n```swift\nimport UIKit\nclass SceneDelegate: NSObject {\n\n}\n```\n\n이제 AppDelegate.swift와 SceneDelegate.swift 파일에 적용해야 할 실제 변경 사항을 아래에 안내해드립니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nAppDelegate.swift\n\n```swift\nclass AppDelegate: NSObject, UIApplicationDelegate {\n\n     func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey : Any]? = nil) -> Bool {\n         return true\n     }\n\n     func application(_ application: UIApplication, configurationForConnecting connectingSceneSession: UISceneSession, options: UIScene.ConnectionOptions) -> UISceneConfiguration {\n\n         let sceneConfig : UISceneConfiguration = UISceneConfiguration(name: nil, sessionRole: connectingSceneSession.role)\n         sceneConfig.delegateClass = SceneDelegate.self\n         return sceneConfig\n\n     }\n }\n```\n\nUIApplicationDelegate은 iOS 개발에서 사용되는 프로토콜로, iOS 애플리케이션의 라이프사이클 이벤트를 관리하고 응답하는 일련의 메서드를 정의합니다.\n\n이 프로토콜은 앱 시작, 종료, 백그라운드 또는 포그라운드 진입, 푸시 알림 수신 등과 같은 이벤트를 처리하기 위한 중앙 허브 역할을 합니다. 제공된 코드의 AppDelegate와 같이 이 프로토콜을 준수하는 클래스는 이러한 메서드를 구현하여 애플리케이션의 동작을 라이프사이클 이벤트에 따라 맞춤화할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 첫 번째 함수인 application(\\_:didFinishLaunchingWithOptions:)은 앱이 로딩을 마칠 때 호출됩니다. 이 함수는 실행이 성공적인지 여부를 나타내는 부울 값이 반환됩니다.\n- 두 번째 함수인 application(\\_:configurationForConnecting:options:)은 새로운 씬 세션을 생성할 때 호출됩니다. 이 함수는 씬의 속성을 구성하는 데 도움이 되는 UISceneConfiguration 객체를 반환합니다. 여기서 UISceneConfiguration 객체를 생성하고 이 씬 세션의 구성을 처리할 SceneDelegate 클래스를 해당 UISceneConfiguration 객체로 할당합니다.\n\nSceneDelegate.swift\n\n```js\nimport SwiftUI\n\nclass SceneDelegate: NSObject, UIWindowSceneDelegate {\n\n    var window: UIWindow?\n\n    func scene(_ scene: UIScene, willConnectTo\n               session: UISceneSession, options\n               connectionOptions: UIScene.ConnectionOptions) {\n        guard let _ = scene as? UIWindowScene else {return}\n    }\n\n    func sceneDidBecomeActive(_ scene: UIScene) {\n\n    }\n\n    func sceneDidEnterBackground(_ scene: UIScene) {\n\n    }\n\n    func sceneWillEnterForeground(_ scene: UIScene) {\n\n    }\n\n    func sceneWillResignActive(_ scene: UIScene) {\n\n    }\n}\n```\n\nUIWindowSceneDelegate 프로토콜은 씬의 라이프사이클 이벤트에 응답하고 앱의 창 씬 동작을 관리할 수 있도록 해줍니다. 씬의 생성, 소멸, 상태 복원 및 씬 관련 이벤트를 처리하기 위한 구조화된 방법을 제공하여 견고하고 반응성 있는 iOS 애플리케이션을 만들 수 있습니다. 여기에 대한 설명:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n1. scene(\\_:willConnectTo:options:): 새 창 장면이 연결되기 전에 호출되는 메서드입니다. 일반적으로 장면의 초기 사용자 인터페이스를 설정하는 곳입니다.\n\n2. sceneDidBecomeActive(\\_:): 창 장면이 활성 상태가 되면 트리거됩니다. 이는 사용자 상호 작용을 위해 준비된 상태를 의미합니다. 여기서 애니메이션을 시작하거나 작업을 재개할 수 있습니다.\n\n3. sceneWillResignActive(\\_:): 창 장면이 활성 상태를 잃기 직전에 호출됩니다. 사용자가 전화를 받거나 다른 앱으로 전환할 때 발생할 수 있습니다.\n\n4. sceneDidEnterBackground(\\_:): 이 메서드는 창 장면이 백그라운드로 전환될 때 호출됩니다. 여기서 앱의 현재 상태를 저장하거나 진행 중인 작업을 일시 중지하는 데 사용할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n5. sceneWillEnterForeground(\\_:): 화면이 백그라운드에 있었다가 다시 활성화될 때 호출됩니다. 여기서 사용자가 돌아오면 사용자 인터페이스를 준비할 수 있습니다.\n\n이러한 메서드를 사용하면 앱의 창 화면이 수명주기 동안의 동작을 사용자 정의하여 부드럽고 반응적인 사용자 경험을 보장할 수 있습니다.\n\n지금 SwiftUI 앱 라이프사이클에 AppDelegate를 연결해보세요.\n\n```swift\nimport SwiftUI\n\n@main\nstruct SwiftUIDemoApp: App {\n\n    @UIApplicationDelegateAdaptor(AppDelegate.self) private var appdelegate\n\n    var body: some Scene {\n        WindowGroup {\n            ContentView()\n        }\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nSwiftUI 앱에서는 App 구조체에서 AppDelegate 인스턴스에 접근할 수 있습니다. 이때 사용하는 프로퍼티 래퍼는 UIKit 앱에서 UIWindowSceneDelegate와 유사한 방식으로 작동합니다. 그러나 여기서 사용해야 하는 프로퍼티 래퍼는 @UIApplicationDelegateAdaptor입니다.\n\n- @UIApplicationDelegateAdaptor(AppDelegate.self)은 AppDelegate 인스턴스에 액세스할 수 있는 프로퍼티 래퍼입니다.\n- private var appDelegate는 AppDelegate 인스턴스에 대한 참조를 보유하는 프로퍼티입니다.\n\n이 Github URL을 시도해보세요! 궁금한 점이 있으면 언제든지 물어보세요.\n\nNEXT: SwiftUI를 사용하여 변수를 정의하고 키워드를 입력하는 방법에 대해 공유할게요.\n","ogImage":{"url":"/assets/img/2024-05-20-UnderstandingAppDelegateSceneDelegateandSwiftUILifecycle_0.png"},"coverImage":"/assets/img/2024-05-20-UnderstandingAppDelegateSceneDelegateandSwiftUILifecycle_0.png","tag":["Tech"],"readingTime":13},{"title":"모바일 개발 아이디어부터 구현까지 DevInterface와 함께","description":"","date":"2024-05-20 16:20","slug":"2024-05-20-MobiledevelopmentfromideatoimplementationwithDevInterface","content":"\n![image](/assets/img/2024-05-20-MobiledevelopmentfromideatoimplementationwithDevInterface_0.png)\n\n애플리케이션에 대한 아이디어가 있고 다음 단계가 무엇인지 궁금한가요?\n\n옵션은 무한하며 매일 새롭고 흥미로운 스마트폰 애플리케이션이 시장에 출시됩니다. 영감은 분명히 부족하지 않습니다. 그러나 부족한 것은 구현입니다. 사용자 지정 앱을 만들고 싶다면 어디서부터 시작해야 할까요?\n\n저희 글은 여러분이 아이디어를 실제로 구현할 수 있도록 제안하는 길을 안내해 드립니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 개발 회사에 앞서 고려해야 할 사항...\n\n## 1) 내 앱이 이미 존재하는가?\n\nApp Store와 Google Play에는 수백만 개의 앱이 있습니다. 당신의 아이디어가 새로운 것일 가능성은 상대적으로 낮을 수 있습니다. 하지만 이로 인해 낙담해서는 안 됩니다. 귀하의 산업과 관련된 앱을 찾아서 테스트해보세요. 사용자 리뷰를 확인하고 귀하의 앱을 개선하는데 영감을 받으세요.\n\n## 2) 내 타겟 그룹은 무엇을 생각하나요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nIf your idea seems really new and innovative, ask yourself: why? and seek expert advice as well. Your topic may not be suitable for app development or may even not be allowed. Also, your target group of potential users might be very narrow. Speak to a representative of your potential user group and try to get honest feedback: does my app idea really solve (your) problem?\n\n### 3) What problem does my app solve?\n\nAn app idea has potential if it solves a problem. In times of oversupply, a user approaching your product may rightfully ask: “What do I get by installing this app?”. Your app idea must address a specific and concrete challenge that your target group has recognized. It is also important to consider whether the problem is temporary or permanent.\n\n### Approaching a development company like DevInterface\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n귀하의 앱 개발이 성공적으로 이루어지도록 하기 위해 DevInterface에서는 다음 단계를 적용합니다:\n\n## 1) 앱 프로젝트 평가 분석\n\n### 아이디어 평가\n\n이 단계에서는 함께 앱 아이디어를 평가합니다. 이는 앱이 해결해야 하는 문제 또는 필요성을 식별하는 것을 의미합니다 (이전에 이미 이를 설명한 바 있다면 더 좋습니다). 시장을 분석하여 수요와 경쟁력을 이해하고 대상 청중을 정의합니다. 또한 사용 가능한 자원, 필요한 기술 및 마감일에 대한 아이디어의 실행 가능성을 확인하려고 노력합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 기능\n\n아이디어와 관련된 다양한 측면을 평가한 후, 앱의 기능을 분석합니다. 기능 요구 사항을 식별하고 중요도에 따라 기능 우선 순위를 정하며, 앱을 풍부하게할 추가 기능을 정의하고 사용자 경험을 고려하여 사용자 인터페이스의 사용성 및 인체공학을 분석합니다.\n\n## 기술\n\n마지막으로, 프로젝트에 가장 적합한 개발 기술을 선택하여 첫 번째 부분을 마무리합니다. 이 과정에는 프로그래밍 언어, 프레임워크 및 데이터베이스의 선택뿐만 아니라 앱의 배포 플랫폼, 확장 가능성 및 성능 요구 사항, 사용자 데이터의 보호를 위한 보안 및 개인 정보 제약 사항을 고려하여 사용자 데이터의 보호를 보장합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 2) UX/UI 디자인\n\n## 사용자 연구 및 경쟁 분석\n\n저희에게 오는 고객 유형에 따라, UX/UI 디자인의 첫 단계로 사용자 연구를 실시하고 경쟁사를 분석하여 상황과 사용자 기대를 명확히 파악합니다.\n\n## 사용자 페르소나 및 시나리오 작성\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n수행한 연구를 통해 대상 사용자의 가상화된 표현인 사용자 페르소나를 만듭니다. 이를 통해 사용자의 요구 사항, 행동 및 목표를 더 잘 이해할 수 있습니다. 또한 응용 프로그램의 사용 사례 및 상호 작용 흐름을 설명하는 사용자 시나리오가 정의됩니다.\n\n## 정보 아키텍처 디자인\n\n정보 아키텍처를 통해 사용자 인터페이스의 구조와 조직을 정의합니다. 이는 사이트맵과 플로우차트를 작성하여 사용자가 응용 프로그램을 통해 탐색하는 것을 시각화하는 것을 포함합니다.\n\n## 와이어프레이밍 및 프로토타이핑\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저희는 사용자 인터페이스를 개략적이고 상호 작용적인 방식으로 표현하는 낮은 중, 중간 정도의 친밀도를 가진 와이어프레임과 프로토타입을 작성합니다. 이로써 디자인 솔루션을 평가하고 테스트할 수 있으며, 시각 디자인 및 개발 단계로 진행하기 전에 초기 단계에서 진행합니다.\n\n## 시각 디자인과 스타일\n\n와이어프레임과 프로토타입이 확정되면 시각 디자인 단계로 진행합니다. 애플리케이션의 룩 앤 필을 정의하고, 색상, 서체 및 그래픽 요소 선택합니다. 목표는 브랜드와 일관성 있고 사용자에게 매력적인 디자인을 만드는 것입니다.\n\n## 사용성 테스트\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n프로젝트를 개발 팀에 넘기기 전에 중요한 마지막 단계는 사용성 테스트를 실시하여 사용자 인터페이스의 효과성과 사용자 경험을 평가하고 피드백을 수집하여 애플리케이션이 출시되기 전에 해결해야 할 사용성 문제를 식별하는 것입니다.\n\n# 3) 개발\n\n## 아키텍처 정의\n\n개발 단계는 앱 아키텍처의 정의로 시작됩니다. 이는 애플리케이션의 주요 구성 요소인 프론트엔드와 백엔드의 설계 및 그들 간의 상호작용의 정의를 포함합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## API 및 백엔드 개발\n\n백엔드 서비스와 API를 개발하는 과정에서는 애플리케이션의 작업을 지원하기 위해 필요한 기능을 구현합니다. 데이터 관리, 사용자 인증, 외부 시스템과의 통합 등이 포함될 수 있습니다. 우리는 확장 가능하고 안전하며 성능이 우수한 백엔드 아키텍처를 제공하기 위해 노력합니다.\n\n## 앱 개발\n\n애플리케이션의 실제 개발 과정에서는 이전 단계에서 정의된 요구 사항과 기능을 코드로 번역합니다. 이는 사용자 인터페이스 개발, 비즈니스 로직 구현 및 백엔드 서비스와의 통합을 포함할 수 있습니다. 이 과정에서는 사용자 인터페이스 디자인 가이드라인을 준수하고 앱이 일관되고 사용자에게 직관적인지 확인합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 테스트\n\n개발 단계에서 마지막으로 중요한 단계는 테스트입니다. 이는 개별 코드 구성 요소를 확인하는 단위 테스트, 앱의 다른 모듈이 올바르게 상호 작용하는지 확인하는 통합 테스트, 그리고 앱이 최종 사용자의 기대를 충족시키는지 확인하는 사용자 수용 테스트가 포함될 수 있습니다.\n\n# 4) 릴리스 및 유지 보수\n\n## 앱 릴리스\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n개발 단계가 완료되고 품질 테스트를 통과한 후에는 응용 프로그램이 대상 플랫폼으로 배포됩니다. 이는 앱 스토어(예: Apple App Store, Google Play Store for Android) 또는 대상 대상자에 따라 다른 배포 플랫폼에 포함될 수 있습니다.\n\n## 성능 모니터링\n\n앱이 출시된 후에는 성능을 주의 깊게 모니터링하는 것이 중요합니다. 예를 들어 서버의 안정성과 성능에 대한 것이 포함될 수 있습니다.\n\n## 업데이트 및 유지보수\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n애플리케이션의 수명 주기 동안은 업데이트와 버그 수정이 필요할 수 있습니다. 이러한 업데이트는 앱의 기능을 향상시키고 사용자가 마주친 문제를 해결하며 새로운 운영 체제 및 기기 버전과의 호환성을 보장하기 위해 주기적으로 출시될 수 있습니다.\n\n# 당신만의 앱을 만들어 보고 싶으신가요?\n\n이 글에서 읽으신 내용을 이미 CXOs, 마케팅 매니저, 제품 소유자, 그리고 디지털 매니저들이 우리에게 신뢰하여 자신의 앱을 만들어달라고 부탁한 다양한 프로젝트에 적용했습니다. 당신이 성공적인 앱을 개발하기 위한 방법, 도구, 프로세스, 그리고 팀을 만들어야 할 필요 없이 바로 시작하고자 한다면, 전략, 컨셉, 실행, 혹은 마케팅 단계에 있든 상관없이, 저희는 대부분의 작업을 기꺼이 맡아 처리하고 협력의 정신으로 전체 과정을 안내해 드릴 것입니다.\n\n따라서 당신은 핵심 활동에 집중하고 프로젝트를 착수할 수 있으며, 우리는 전략 및 개념의 전반적인 안내와 함께 원하신다면 전문 팀으로 직접 앱을 개발할 수 있는 점에 대해 안내해 드리겠습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저희는 무료 상담을 제공합니다. 프로젝트 계획을 함께 세우고, 초기 전략부터 최종 릴리스까지 프로젝트가 성공적으로 진행되도록 안내해 드립니다.\n\n지금 바로 무료 상담 신청하세요.\n\n원문 게시 위치: https://www.devinterface.com.\n","ogImage":{"url":"/assets/img/2024-05-20-MobiledevelopmentfromideatoimplementationwithDevInterface_0.png"},"coverImage":"/assets/img/2024-05-20-MobiledevelopmentfromideatoimplementationwithDevInterface_0.png","tag":["Tech"],"readingTime":8},{"title":"안녕하세요 VSCode에서 플러터 앱을 실행하고 디버그하기 위해 안드로이드 기기를 WiFi로 연결하는 방법에 대해 이야기하겠습니다","description":"","date":"2024-05-20 16:19","slug":"2024-05-20-ConnectYourAndroidDeviceOverWiFiinVSCodetoRunandDebugYourFlutterApp","content":"\n<img src=\"/assets/img/2024-05-20-ConnectYourAndroidDeviceOverWiFiinVSCodetoRunandDebugYourFlutterApp_0.png\" />\n\n# 핸드폰 배터리 손상하지 말고 앱 테스트, 케이블 없이 디버깅하세요 (거의).\n\n이 게시물은 이미 USB 연결로 Android 기기에서 실행 및 디버깅을 구성했다고 가정합니다. Android 13 기기 및 Windows 10 컴퓨터에서 테스트되었습니다. 컴퓨터와 휴대폰 모두 동일한 네트워크에 연결되어 있어야 합니다.\n\n## 일회성 IDE 및 장치 구성\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- [Optional] VSCode 확장 프로그램인 ADB Commands를 설치하세요. 안 깔았다면 adb 명령어를 사용할 수 있어요. 확장 프로그램을 사용하는 편이 더 직관적이고 설정할 게 거의 없어요.\n- 기기에서 무선 디버깅을 활성화하세요:\n  - 설정으로 이동해서 “debug”를 검색하세요.\n  - “무선 디버깅”을 탭한 후, 다시 “무선 디버깅” 옵션을 (토글이 아닌 전체 항목을 탭해서 상세 페이지로 이동하세요.\n  - “무선 디버깅 사용” 토글을 확인하세요. “이 네트워크에서 무선 디버깅 허용” 팝업에서 “이 네트워크에서 항상 허용”을 선택하고 “허용”을 탭하세요.\n  - “IP 주소 및 포트 정보”는 나중에 예약하세요 (대부분의 튜토리얼은 포트가 5555이라고 가정하지만, 제 브랜드 new Pixel 7에서는 다른 포트번호였어요).\n\n![Android Device](/assets/img/2024-05-20-ConnectYourAndroidDeviceOverWiFiinVSCodetoRunandDebugYourFlutterApp_1.png)\n\n## 기기 연결\n\n- [처음 연결할 때만] USB로 기기를 연결하세요.\n- VSCode에서 Ctrl+Shift+P를 누르고 “ADB:📱 Connect to device IP”를 검색하고 선택하세요:\n- IP 주소를 입력하고 엔터를 누르세요.\n- 포트 번호를 입력하세요.\n- “Connected to `IP`:`port`” 메시지가 나타나면 USB 케이블을 분리할 수 있어요. \\*참고: IP 주소는 사용하는 네트워크와 라우터 설정에 따라 달라질 수 있어요. 포트 번호는 매번 바뀔 수 있어요. 이렇게 되면 “ADB returned null value”나 다른 오류가 발생할 수 있어요.\n- VSCode에서 F5를 누르거나 \"Run > Start Debugging\"으로 이동하세요. 즐겁게 개발하세요!\n","ogImage":{"url":"/assets/img/2024-05-20-ConnectYourAndroidDeviceOverWiFiinVSCodetoRunandDebugYourFlutterApp_0.png"},"coverImage":"/assets/img/2024-05-20-ConnectYourAndroidDeviceOverWiFiinVSCodetoRunandDebugYourFlutterApp_0.png","tag":["Tech"],"readingTime":2},{"title":"플러터 앱 성능 향상을 위한 권장 사항 탐색","description":"","date":"2024-05-20 16:16","slug":"2024-05-20-ExploringFlutterappperformanceimprovementrecommendations","content":"\n앱 성능은 소프트웨어 제품을 개발할 때 항상 염두에 두어야 할 중요한 요소입니다. 앱 성능에 신경을 쓰면 앱을 믿을 수 있게 만들어주고 유용한 기능을 제공하고 멋진 사용자 인터페이스를 생성함으로써 기존 사용자를 유지하고 새 사용자를 유치하는 데 도움이 됩니다.\n\nFlutter 앱 성능을 향상시키는 팁을 찾을 수 있는 많은 훌륭한 기사와 비디오가 있습니다. 여기에서는 일반적인 개요를 제시하고, DevTools를 사용하여 몇 가지를 자세히 살펴볼 예정입니다.\n\nFlutter 앱은 기본적으로 성능이 우수합니다. 단순히 권장 사항을 따르기만 하면 됩니다. 이미 앱이 잘 작동하면 성능을 향상시키는 방법을 찾을 필요가 없습니다. 노력이 들어가지 않을 것입니다. 다음과 같은 주요 문제가 앱에 없는지 확인해야 합니다:\n\n- UI 지연 — 렌더링에 허용된 시간을 초과한다는 것을 의미하는 프레임을 건너뛰는 경우 (애니메이션이 끊기는 것을 관찰할 수 있음)\n- 배터리 소모가 빠른 경우\n- 기기가 과도하게 발열하는 경우\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n일부가 관찰되면 문제가 발생한 곳을 찾아야 합니다. 앱 성능은 릴리스 모드와 비슷하지만 DevTools를 사용할 수 있는 프로파일 모드에서 실제 기기에서 조사되어야 합니다:\n\n```js\nflutter run --profile\n```\n\n성능 조사 목적으로 Profiling timeline 도구를 사용할 수 있습니다. 이 도구는 기기 화면에 렌더링된 프레임의 순서를 나타내는 차트입니다. UI 스레드와 래스터 스레드에서 데이터를 사용하며, 특정 시점에 실행된 프로그램 코드를 실제로 반영합니다. 코드가 효율적이지 않으면 (프레임 당 16.66밀리초 이상이 걸리면 — 초당 60프레임이 생성되어야 함) 막대는 빨간색으로 나타납니다. 그렇지 않으면 파란색으로 표시됩니다. Performance overlay 옵션을 활성화하면 차트를 기기 화면에 바로 추가할 수 있습니다.\n\n앱 성능에 대해 이야기할 때 리소스 소비를 의미한다는 것을 언급해야 합니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 시간 — 프로그램이나 코드의 실행에 필요한 시간량입니다. 초당 프레임 수(FPS), 앱 시작 시간, CPU 사용량 등으로 측정할 수 있습니다.\n- 공간 — 프로그램 실행에 필요한 데이터 저장 공간의 양입니다. 메모리(RAM) 사용량, 앱 크기 등으로 측정할 수 있습니다.\n\n소프트웨어 개발자들은 종종 앱 성능을 유지하기 위해 시간과 공간 소비 사이의 균형을 찾아야 합니다.\n\n더 구체적인 성능 지표는 다음 링크에서 확인할 수 있습니다: [https://docs.flutter.dev/perf/metrics](https://docs.flutter.dev/perf/metrics).\n\n# 성능 향상 권고사항 탐색\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n성능 향상을 위한 모든 권장 사항은 다음과 같이 요약할 수 있습니다:\n\n- 시간 관련:\n- 반복적인 작업을 수행하지 말고, 가능한 경우 캐싱을 사용하세요.\n- 비용이 많이 드는 작업은 필요할 때까지 지연시키세요. 이는 다소 모순적일 수 있습니다. 작업이 시간이 오래 걸리고 사용자가 결과가 필요한 높은 확률이 있다면, 사용자가 작업이 완료될 때까지 기다리지 않도록 미리 백그라운드에서 수행하는 것이 더 나은 솔루션이 됩니다.\n- 공간 관련:\n- 더 이상 필요하지 않고 나중에 필요하지도 않을 객체를 저장하지 마세요.\n- 미디어 파일 사용을 최적화하세요 (그리고 앱 크기를 일반적으로 최적화하세요).\n\n# 반복적인 작업을 수행하지 마세요\n\n반복 작업을 수행하지 말아야 한다는 권장 사항은 당연한 것처럼 들릴 수 있지만, 서두르지 마세요. 물론 필요 없이 동일한 작업을 다시 수행할 의향은 아무도 없을 것입니다. 그러나 프로젝트가 커질수록 논리도 복잡해지므로 누락될 수 있는 부분이 있을 수 있습니다. Flutter 프레임워크가 그러한 프로젝트로 간주될 수 있기 때문에 처음부터 주의 깊게 작업해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여기서 가장 인기있는 권장 사항은 위젯의 빌드 메서드에서 실행 비용이 많이 드는 메서드를 호출하지 않는 것입니다. 빌드 메서드는 위젯을 초기화 한 후에 한 번만 호출되는 것이 아닙니다. 예를 들어 위젯이 다시 빌드될 때마다 서버 요청을 하는 것은 효율적이지 않습니다.\n\n그 외에 다시 빌드되는 횟수를 줄이는 것이 중요합니다. 다음 권장 사항을 따르면 이를 달성할 수 있습니다:\n\n- 컴파일 시간에 초기 상태를 결정할 수 있고 이후에 변경되지 않을 때만 사용할 수 있는 const 위젯을 사용하는 것. Flutter는 const 위젯의 단일 인스턴스를 만들어 위젯 트리에서 재사용하며 계속 만들고 다시 빌드하지 않습니다.\n- 위젯을 반환하는 메서드 대신 위젯을 선호하는 것. setState 메서드를 사용하여 자식 위젯이 나타내는 하위 트리만 업데이트할 때 전체 부모 위젯이 다시 빌드되는 것을 방지합니다. 위젯을 반환하는 메서드를 사용하면 전체 부모 위젯이 다시 빌드됩니다.\n- 위젯 트리의 중첩 수준(구조)과 유형을 변경하지 않는 것. Flutter는 이전 빌드에서 해당 위젯을 찾지 못하면 다시 빌드 중에 새 위젯을 만듭니다. 예를 들어 숨기려는 경우 위젯을 트리에서 제거하는 대신 IgnorePointer를 사용하여 무시 매개변수의 다른 값을 사용하는 것이 좋습니다. 중첩 수준을 변경해야 하는 경우 해당 위젯에 GlobalKey를 사용하는 것이 좋습니다.\n- 위젯에 가능한 캐싱을 사용하는 것. 예를 들어, AnimatedBuilder는 애니메이션 반복마다 다시 빌드되지 않을 위젯 서브트리를 저장하는 child 매개변수를 제공합니다. 그렇지 않으면 child 매개변수가 무시되고 해당 서브트리가 직접 builder 콜백에 지정된 경우 매번 다시 빌드될 것입니다.\n- RepaintBoundary 위젯을 사용하여 자식 위젯을 별도의 레이어로 분리하는 것. 더 많은 정보는 여기에서 확인할 수 있습니다 - https://www.youtube.com/watch?v=Nuni5VQXARo\n\n위젯이 다시 빌드되었을 때 확인하려면 안드로이드 스튜디오의 Flutter Inspector 탭에서 Widget rebuild stats를 사용하십시오. debugRepaintRainbowEnabled = true로 전역 변수를 설정하면 위젯 주변에 색상 경계가 표시되며 다시 빌드될 때 색상이 바뀝니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n네! 테이블 태그를 마크다운 형식으로 변경해 주세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nclass WidgetOptimizationPage extends StatefulWidget {\n  const WidgetOptimizationPage({super.key});\n\n  @override\n  State<StatefulWidget> createState() => _WidgetOptimizationPageState();\n}\n\nclass _WidgetOptimizationPageState extends State<WidgetOptimizationPage> {\n  @override\n  void didChangeDependencies() {\n    debugPrint('didChangeDependencies');\n    super.didChangeDependencies();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        backgroundColor: Theme.of(context).colorScheme.inversePrimary,\n        title: Text(\n          'Widget Optimization',\n        ),\n      ),\n      body: Column(\n        children: [\n          Container(\n            margin: const EdgeInsets.symmetric(vertical: 8),\n            height: 44,\n            width: 0.75 * MediaQuery.of(context).size.width,\n            child: const TextField(\n              decoration: InputDecoration(\n                border: OutlineInputBorder(),\n                hintText: 'Search',\n              ),\n            ),\n          ),\n          Expanded(\n            child: ListView.separated(\n              itemCount: 10,\n              itemBuilder: (BuildContext context, int index) {\n                return ListTile(\n                  visualDensity: VisualDensity.compact,\n                  title: Text('$index'),\n                );\n              },\n              separatorBuilder: (BuildContext context, int index) => const Divider(),\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\n텍스트 필드에 포커스를 설정하여 키보드를 표시하고 Done 버튼을 클릭하여 숨기기를 시도하는 경우:\n\n<img src=\"https://miro.medium.com/v2/resize:fit:704/1*u9fTFwbb5q-HzdNF6a9yoA.gif\" />\n\n콘솔에서 didChangeDependencies 메소드가 여러 번 실행된 것을 볼 수 있을 것입니다. 여기서 요청이 호출된 곳이었습니다!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![image 0](/assets/img/2024-05-20-Flutter성능개선권장사항탐색_0.png)\n\n위젯이 여러 번 다시 빌드되었음을 의미합니다. TextField는 총 3번 다시 빌드되었고 (화면이 열릴 때, 키보드가 나타났을 때, 키보드가 사라질 때), WidgetOptimizationPage는 12번 다시 빌드되었습니다:\n\n![image 1](/assets/img/2024-05-20-Flutter성능개선권장사항탐색_1.png)\n\ndidChangeDependencies 메서드가 InheritedWidget에서 알림에 대한 응답으로 작업을 수행하기에 적절한 위치임을 알려져 있습니다. 위젯이 어떤 변화들을 구독하는지 찾기로 결정했습니다. 위젯이 다소 복잡했기 때문에 몇 가지 가정을 하였지만, 위의 코드 예제에서는 명확하게 인식할 수 있습니다. 이유는 MediaQuery.of(context).size.width를 사용했기 때문입니다. MediaQuery는 기본적으로 다양한 매개변수를 가진 InheritedWidget으로, viewInsets와 padding을 포함하여 여러 매개변수가 있습니다. 이들은 키보드 애니메이션 중에 변경됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n문제의 해결 방법은 MediaQuery.sizeOf(context).width를 사용하는 것이었습니다. sizeOf는 해당 속성이 변경될 때마다 컨텍스트를 다시 빌드하며, MediaQueryData의 of 메서드에서 직접 속성을 가져 오는 것보다 우선해야 합니다.\n\n수정 후에 만든 아래 스크린샷에서 볼 수 있듯이 WidgetOptimizationPage가 한 번 다시 빌드되었습니다.\n\n![이미지](/assets/img/2024-05-20-ExploringFlutterappperformanceimprovementrecommendations_2.png)\n\n# 비용이 많이 드는 작업을 필요할 때까지 지연시키세요\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n성능 향상의 다음 원칙은 불필요한 작업을 하지 말아야 한다고 말합니다. 프로젝트의 구조, 상태 관리 방식, 사용하는 타사 라이브러리의 특성, 특정 화면의 내부 논리 등에 많이 따라 달라집니다. 이곳에서는 Dart에서 제공하는 몇 가지 사항을 언급하고 싶습니다.\n\n다트가 다른 프로그래밍 언어와 마찬가지로 복잡한 조건의 각 부분을 계산하지 않는다는 것을 모두 알고 있을 것입니다. 일부 조건이 일찍 결정될 수 있다면 다른 조건은 심지어 계산할 필요가 없게 됩니다. 예를 들어, 여러 조건이 OR 연산자로 연결된 조건인 경우 첫 번째 조건이 true를 반환하면 다른 조건들은 계산되지 않을 것입니다. 왜냐하면 그들은 전체 조건의 결과에 영향을 미치지 않기 때문이죠.\n\n```js\nvoid testLateInitialization() async {\n  late final first = performCalculations();\n  late final second = performComplexCalculations();\n\n  if (first || second) {\n    debugPrint('Hello world');\n  }\n}\n\nbool performCalculations() {\n  // 여기에 일부 계산이 있다고 가정해봅시다.\n  return true;\n}\n\nbool performComplexCalculations() {\n  // 여기에 일부 복잡한 계산이 있다고 가정해봅시다.\n  return false;\n}\n```\n\n그리고 우리에게 중요한 한 가지 — late 키워드입니다. 이는 변수가 액세스하려고 시도할 때만 값을 가져온다는 것을 의미합니다. 이를 통해 조건을 의미있는 부분으로 분할하고 가독성을 향상시킬 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nDevTools의 Debugger 섹션에서는 아래 사진에 나와 있는 목록 아이콘 버튼을 선택하여 확인할 수 있습니다:\n\n![List Icon](/assets/img/2024-05-20-ExploringFlutterappperformanceimprovementrecommendations_3.png)\n\n함수 이름 앞에 초록색 선은 디버그 세션 중 호출된 것을 나타내고 빨간 선은 호출되지 않은 것을 나타냅니다.\n\n그리고 'late' 키워드에 대한 추가 정보 - 우리의 경우 비동기 함수에 사용할 수 없지만, 비동기 함수는 조건식에서 직접 호출할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nvoid testLateInitialization() async {\n  late final first = performCalculations();\n\n  if (first || await performComplexCalculations()) {\n    debugPrint('Hello world');\n  }\n}\n\nbool performCalculations() {\n  // Let's suppose here are some calculations\n  return true;\n}\n\nFuture<bool> performComplexCalculations() async {\n  // Let's suppose here are some complex calculations\n  return false;\n}\n```\n\n동기 함수에 대한 영향과 동일합니다 - 함수를 호출할 가치가 없으면 호출되지 않습니다.\n\n하나의 변수에 대한 늦은 초기화가 어떻게 작동하는지를 보여드렸습니다. 이제 게으른 컬렉션에 대해 이야기해 봅시다. Dart에서 List 객체에서 호출되는 많은 메서드는 Iterable을 반환합니다. Iterable은 자신의 항목을 반복하는 방법을 제공하는 추상 mixin입니다. 사실 List나 Set과 같은 컬렉션은 Iterable mixin을 구현합니다. Iterable의 요소는 요청될 때 계산되는 특징이 있습니다. 다음 코드를 살펴보겠습니다:\n\n```js\nclass ListObject {\n  int value;\n\n  ListObject(this.value);\n}\n\nclass IterableObject {\n  String value;\n\n  IterableObject(this.value);\n}\n\nvoid testListVsIterable() {\n  final List<int> sourceList = List.generate(10, (index) => index);\n\n  final List<ListObject> intObjectList = sourceList.map((e) => ListObject(e)).toList();\n  for (var element in intObjectList.take(5)) {\n    debugPrint('$element');\n  }\n\n  final stringObjectList = sourceList.map((e) => IterableObject('$e'));\n  for (var element in stringObjectList.take(5)) {\n    debugPrint('$element');\n  }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n두 개의 클래스인 ListObject와 IterableObject을 만들었어요. 두 클래스는 값만을 가지고 있어서 거의 동일하며, 나중에 DevTools에서 구분하기 위해 만들었어요. testListVsIterable 함수에서 sourceList는 초기 데이터의 리스트이며, ListObject와 IterableObject의 컬렉션이 생성됩니다. map 함수는 Iterable을 반환하기 때문에 List`ListObject`를 얻기 위해 toList를 호출해야 합니다. 첫 5개 요소를 반복하고 DevTools에서 어떻게 작동하는지 살펴보세요. 어떤 클래스의 인스턴스가 할당되었는지 확인할 수 있어요. 메모리 - Trace Instances를 선택하고 검사하려는 클래스를 선택해주세요.\n\n![image](/assets/img/2024-05-20-ExploringFlutterappperformanceimprovementrecommendations_4.png)\n\n우리의 실험 결과, 10개의 ListObject 객체 인스턴스와 5개의 IterableObject 인스턴스가 할당되었어요. 사실, 나는 Iterable과 List 사이의 차이를 보여주기 위해 컬렉션의 첫 5개 요소만 반복하기로 결정했어요. 앞서 언급했듯이, Iterable은 객체가 생성되는 방법을 결정할 수 있지만 요청될 때만 생성됩니다. 반면 List는 즉시 컬렉션을 생성합니다. 따라서 전체 컬렉션을 반복한다면 차이가 없을 것입니다.\n\n특히 Iterable의 장점에도 불구하고, 이 경우에는 단점이 있어요 - 접근할 때마다 새 인스턴스가 생성됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리가 두 번 반복해야 하는 경우 ListObject와 IterableObject 사이에 차이가 없어질 것입니다.\n\n```js\nvoid testListVsIterable() {\n  final List<int> sourceList = List.generate(10, (index) => index);\n\n  final List<ListObject> intObjectList = sourceList.map((e) => ListObject(e)).toList();\n  for (var element in intObjectList.take(5)) {\n    debugPrint('$element');\n  }\n  for (var element in intObjectList.take(5)) {\n    debugPrint('$element');\n  }\n\n  final stringObjectList = sourceList.map((e) => IterableObject('$e'));\n  for (var element in stringObjectList.take(5)) {\n    debugPrint('$element');\n  }\n  for (var element in stringObjectList.take(5)) {\n    debugPrint('$element');\n  }\n}\n```\n\n![이미지](/assets/img/2024-05-20-ExploringFlutterappperformanceimprovementrecommendations_5.png)\n\n그리고 더 많은 횟수로 반복해야 하는 경우 List가 Iterable보다 효율적일 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그러나 Iterable은 제가 만든 그런 인위적인 시나리오 뿐만 아니라 다른 상황에서도 유용할 수 있습니다. 앱 내에서 클래스 또는 레이어 간에 데이터를 전송해야 하는 경우, 매번 List로 변환하는 대신 Iterable을 사용하는 것을 고려해보세요. toList 메서드는 실제로 컬렉션을 반복합니다.\n\n요약하면, Iterable은 유용할 수 있지만 이로부터 이득을 얻으려고 할 때 조심해야 합니다.\n\n# 필요 없는 객체를 저장하지 마세요. 이후에도 필요하지 않을 예정이기 때문입니다.\n\n다음 권장 사항을 살펴보겠습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 문장을 확인하기 위해 몇 개의 화면을 만들었습니다. 첫 번째 화면인 AddingCounterPage는 기본적으로 설정된 것과 매우 유사한 카운터를 구현합니다. 새로운 Flutter 프로젝트를 설정할 때 기본적으로 제공되는 것과 매우 유사합니다. 이 페이지는 값에 2를 곱하는 MultiplyingCounterPage로 전파될 BehaviorSubject를 인스턴스화합니다.\n\n이러한 화면들을 앞뒤로 표시하고 메모리 뷰를 통해 메모리에 있는 개체를 확인해보겠습니다. 스트림 구독이 취소되지 않았을 때와 두 화면의 스트림 구독이 모두 취소된 경우에 대해 각각 메모리 스냅샷이 촬영되었습니다. 각 단계별로 (흐름이 나타나 있는 아래 그림의 녹색 직사각형에 이름이 표시된) 메모리 스냅샷을 비교하여 작성된 객체와 파괴된 객체가 무엇인지 이해했습니다.\n\n다음은 구독 취소 없이 진행되는 첫 번째 시나리오의 코드 일부입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nclass _AddingCounterPageState extends State<AddingCounterPage> {\n  final BehaviorSubject<int> counter = BehaviorSubject<int>.seeded(1);\n\n  @override\n  void initState() {\n    counter.listen((event) {\n      setState(() {});\n    });\n    super.initState();\n  }\n  //...\n}\n\nclass _MultiplyingCounterPageState extends State<MultiplyingCounterPage> {\n  @override\n  void initState() {\n    widget.counter.listen((event) {\n      setState(() {});\n    });\n    super.initState();\n  }\n}\n```\n\nmain-3 스냅샷에는 그들의 상태를 가진 AddingCounterPage와 MultiplyingCounterPage가 있었습니다 - 해당 시점에 메모리에 있었습니다. 구독과 관련된 여러 쌍의 객체도 있습니다. StartWithStreamTransformer, \\_StartWithStreamSink, \\_MultiControllerSink가 있습니다. 하나는 AddingCounterPage를 위한 것이고 다른 하나는 MultiplyingCounterPage를 위한 것입니다:\n\n![image](/assets/img/2024-05-20-ExploringFlutterappperformanceimprovementrecommendations_7.png)\n\nmain-3와 main-4 스냅샷 사이에는 차이가 없습니다. MultiplyingCounterPage가 사라졌지만 모든 인스턴스가 메모리에 남아 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Exploring Flutter App Performance Improvement Recommendations](/assets/img/2024-05-20-ExploringFlutterappperformanceimprovementrecommendations_8.png)\n\nAnd only after closing `AddingCounterPage`, the subscription objects were released with `AddingCounterPage` and `MultiplyingCounterPage`:\n\n![Exploring Flutter App Performance Improvement Recommendations](/assets/img/2024-05-20-ExploringFlutterappperformanceimprovementrecommendations_9.png)\n\nSubscription canceling should help get rid of this memory leak. We just save a `StreamSubscription` when adding the listener and cancel it when the widget is disposed:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nclass _AddingCounterPageState extends State<AddingCounterPage> {\n  final BehaviorSubject<int> counter = BehaviorSubject<int>.seeded(1);\n  late final StreamSubscription subscription;\n\n  @override\n  void initState() {\n    subscription = counter.listen((event) {\n      setState(() {});\n    });\n    super.initState();\n  }\n  //...\n\n  @override\n  void dispose() {\n    subscription.cancel();\n    super.dispose();\n  }\n}\n\nclass _MultiplyingCounterPageState extends State<MultiplyingCounterPage> {\n  late final StreamSubscription subscription;\n\n  @override\n  void initState() {\n    subscription = widget.counter.listen((event) {\n      setState(() {});\n    });\n    super.initState();\n  }\n\n  //...\n  @override\n  void dispose() {\n    subscription.cancel();\n    super.dispose();\n  }\n}\n```\n\n두 번째 경우에서는 main-3 스냅샷은 이전 시나리오와 비슷한 모습이므로 여기에 추가하지 않았습니다. 그러나 main-3와 main-4 스냅샷 간의 차이점은 MultiplyingCounterPage 및 해당 구독 객체가 해제되었다는 것입니다:\n\n![이미지](/assets/img/2024-05-20-ExploringFlutterappperformanceimprovementrecommendations_10.png)\n\n마찬가지로, AddingCounterPage 및 해당 구독 객체는 main-5 스냅샷에서 해제되었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 실험을 통해 이 권장이 작동한다는 것을 입증했어요. 반드시 해지해야 하는 구독과 기타 해체가 필요한 객체(TextEditingController, AnimationController 등)들을 잊지 마세요. 그렇지 않으면 앱 성능에만 영향을 미칠 뿐만 아니라 프로그램 동작을 망가뜨릴 수도 있어요.\n\n# 미디어 파일 사용 최적화\n\n이미지와 비디오와 같은 미디어 파일을 다루는 것은 앱 성능에 중대한 영향을 미칩니다. 그들의 품질이 좋을수록, 메모리에서 차지하는 공간이 더 많이 필요하고 처리 및 렌더링하는 데 더 많은 시간이 필요합니다. 그들의 품질을 희생할 수 없기 때문에 일반적으로 가장 많은 리소스를 사용하는 객체들입니다. 따라서 미디어 파일 처리 방법을 최적화해야 합니다.\n\n이미지를 처리하는 방법을 최적화하는 방법은:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 대부분에 맞는 이미지 형식을 선택해보세요:\n- 사진과 같은 연속음 영상에는 JPEG를 사용합니다. 손실 압축 기능을 제공합니다.\n- GIF 및 PNG는 예리한 가장자리를 가진 이미지, 로고, 텍스트, 그래픽 및 투명성이 필요한 이미지에 적합합니다. 비손실 압축을 제공합니다.\n- JPEG와 PNG의 이점을 결합한 WebP 및 AVIF는 더 효율적인 압축을 제공합니다.\n- 로고, 텍스트 또는 아이콘과 같은 단순한 기하학적 모양에 대한 벡터 기반 그래픽용 SVG. XML 마크업으로 표현되며 품질 하락 없이 모든 해상도에서 렌더링할 수 있습니다.\n- 품질 압축은 이미지 크기를 바이트 수로 줄이는 방법입니다.\n- 손실 압축은 인치 당 픽셀 수의 이미지 해상도를 줄여 픽셀의 숫자를 줄임으로써 이미지 크기를 줄이는 것이 가능합니다. 소량의 품질 손실이 허용되는 경우 (예: 사진)에 적용됩니다.\n- 비손실 압축은 품질에 해를 입히지 않고 원래 이미지를 복원할 수 있는 이미지 인코딩을 제공합니다. 주로 의학 영상, 기술 도면 등의 보존 목적으로 더 적합합니다.\n- 높이와 너비처럼 이미지 크기인 차원을 줄입니다. 대규모 이미지를 작은 화면 (휴대전화 등)에 표시하는 것은 정보가 중복되어 있어 효율적이지 않습니다. 대규모 이미지를 작은 화면에 맞게 조정하려면 추가 계산이 필요합니다. 원하는 차원에 정확히 맞게 이미지를 조정함으로써 렌더링 프로세스를 더 효율적으로 처리할 수 있습니다.\n- 네트워크로부터 수신한 이미지를 캐싱합니다.\n\nFlutter의 이미지 최적화 기능을 살펴보겠습니다. 먼저 화면에 Image 위젯을 추가해야 합니다:\n\n```js\nImage.asset(\n  'lib/assets/landscape.jpg',\n),\n```\n\n하지만 이미지를 최적화해야 하는지 어떻게 알 수 있을까요? DevTools에는 과도한 크기의 이미지를 강조하는 옵션이 있어 항상 식별할 수 있습니다. Flutter Inspector 탭에서 해당 버튼을 클릭하여 이를 활성화할 수 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음은 글로벌 매개변수를 프로그래밍 방식으로 설정하는 방법입니다:\n\n```js\ndebugInvertOversizedImages = true;\n```\n\n거대한 이미지는 색상이 반전되고 뒤집힙니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-05-20-ExploringFlutterappperformanceimprovementrecommendations_12.png\" />\n\n로그에서 오류 메시지도 확인할 수 있습니다:\n\n```js\n이미지 lib/assets/landscape.jpg의 표시 크기는 640×360이지만 디코딩 크기는 1920×1080으로, 장치의 픽셀 비율을 2.0으로 가정하면 추가로 9600KB를 사용합니다.\n\n미리 크기를 조정하거나 cacheWidth 매개변수로 640, cacheHeight 매개변수로 360을 제공하거나 ResizeImage를 사용하는 것을 고려하십시오.\n```\n\n따라서 이미지가 비용이 많이 소비되는 자원으로 간주되는 이유는 큰 차원으로, 이는 렌더링 중에 추가 계산이 필요하다는 것을 의미합니다. 이 오류를 피하려면 cacheHeight 및 cacheWidth 매개변수를 사용해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nImage.asset(\n  'lib/assets/landscape.jpg',\n  cacheWidth: MediaQuery.of(context).devicePixelRatio.round() * MediaQuery.of(context).size.width.round(),\n),\n```\n\n여기서 cacheWidth는 디바이스 픽셀마다 논리적인 픽셀의 수인 devicePixelRatio와 화면 너비의 곱으로 계산됩니다. size.width만 사용하면 이미지가 흐릿해집니다. 이미지 품질에 대해 고려해야 합니다!\n\n![ExploringFlutterappperformanceimprovementrecommendations_13](/assets/img/2024-05-20-ExploringFlutterappperformanceimprovementrecommendations_13.png)\n\n원활한 사용자 경험을 보장하기 위해 preacheImage 메서드를 사용할 수 있습니다. 이 메서드를 사용하면 위젯 초기화 또는 메인 메서드에서 이미지를 캐시에 미리 로드하여 활용할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이미지 캐싱을 자동으로 처리해주는 Image.network 생성자를 사용하거나, cached_network_image와 같은 서드파티 라이브러리를 사용할 수도 있어요. cached_network_image는 이미지 다운로드 중에 플레이스홀더를 표시하고 요청이 실패한 경우 오류를 표시하는 기능을 제공해요.\n\n이미지 압축에 대해 이야기하자면 flutter_image_compress와 같은 플러그인을 사용할 수 있어요.\n\n전체 애플리케이션 크기에 대해 --analyze-size 명령어를 사용하여 더 명확한 그림을 얻고 최적화할 아이디어를 만들어볼 수 있어요. 코드 크기를 줄이려면 릴리스 버전을 빌드할 때 --split-debug-info를 사용하는 것이 좋아요.\n\n추가 권장 사항으로, 필요 없는 작업을 실행하지 않는 것이 중요해요. 예를 들어, Opacity와 ClipRRect을 필요할 때만 사용하고, 애니메이션에서 클리핑을 피해야 해요. 또한, 비싼 작업을 직접 메인 스레드에서 실행하지 않아야 해요. Isolate를 사용하여 UI에 영향을 주지 않도록 해야 해요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 결론\n\n이 글에서는 플러터 앱 개발뿐만 아니라 유용한 앱 성능의 일반 원칙을 제시했습니다. 또한 DevTools를 이용한 플러터 앱 성능 개선에 대해 좀 더 자세히 살펴보았습니다. 도움이 되었으면 좋겠네요. 자세한 정보는 아래 자료 목록에서 찾을 수 있습니다.\n\n자료:\n\n- [https://docs.flutter.dev/perf](https://docs.flutter.dev/perf)\n- [https://docs.flutter.dev/tools/devtools/performance](https://docs.flutter.dev/tools/devtools/performance)\n- [플러터 성능 향상하는 방법:](https://www.youtube.com/watch?v=KH-3tbD7NoU)\n- [DevTools 깊게 들어가기:](https://www.youtube.com/watch?v=_EYk-E29edo)\n- [플러터에서 성능 및 최적화 팁 TOP 10:](https://medium.com/@slawomirprzybylski/top-10-performance-optimization-tips-in-flutter-3a4f3f31202b)\n- [플러터 성능 개선을 위한 경계 넘기기:](https://medium.com/@parthbhanderi01/raising-the-bar-for-flutter-app-performance-52418f7fa604)\n- [RepaintBoundary로 플러터 앱 성능 향상하기:](https://www.youtube.com/watch?v=Nuni5VQXARo)\n- [플러터에서 네트워크 이미지 최적화로 메모리 사용량 절약하기:](https://medium.com/make-android/save-your-memory-usage-by-optimizing-network-image-in-flutter-cbc9f8af47cd)\n- [MediaQuery와 성능 최적화의 플러터 스킬:](https://medium.com/codex/flutter-skill-of-mediaquery-and-performance-optimization-2fbf9c532fea)\n","ogImage":{"url":"/assets/img/2024-05-20-ExploringFlutterappperformanceimprovementrecommendations_0.png"},"coverImage":"/assets/img/2024-05-20-ExploringFlutterappperformanceimprovementrecommendations_0.png","tag":["Tech"],"readingTime":25},{"title":"SwiftUI 모양으로 하는 심장 애니메이션","description":"","date":"2024-05-20 16:14","slug":"2024-05-20-SwiftUIHeartanimationwithshape","content":"\n![Heart Shape](/assets/img/2024-05-20-SwiftUIHeartanimationwithshape_0.png)\n\n사각형, 둥근 사각형, 원 및 캡슐은 SwiftUI에서 사용할 수 있지만 하트 모양은 제공되지 않으므로 저는 Shape Protocol을 사용하여 직접 만들었습니다.\n\n# 하트 만들기\n\n```swift\nstruct HeartShape: Shape {\n    let minX = 10\n    let centerX = 55\n    let maxX = 100\n    let minY = 10\n    let maxY = 100\n\n    func path(in rect: CGRect) -> Path {\n        Path { path in\n            path.move(to: CGPoint(x: centerX, y: maxY))\n            path.addQuadCurve(to: CGPoint(x: minX, y: 50), control: CGPoint(x: minX, y: 70))\n            path.addQuadCurve(to: CGPoint(x: centerX, y: 30), control: CGPoint(x: minX, y: minY))\n            path.addQuadCurve(to: CGPoint(x: maxX, y: 50), control: CGPoint(x: maxX, y: minY))\n            path.addQuadCurve(to: CGPoint(x: centerX, y: maxY), control: CGPoint(x: maxX, y: 70))\n            path.closeSubpath()\n        }\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이곳에서 도형에 대해 더 많이 배워보세요\n\n# 애니메이션 추가\n\n```js\nimport SwiftUI\n\nstruct HeartAnimation: View {\n\n    // MARK: - Properties\n    @State private var to:CGFloat = 0\n\n    // MARK: - Body\n    var body: some View {\n        HeartShape()\n            .trim(from: 0, to: to)\n            .stroke(Color.pink, style: StrokeStyle(lineWidth: 5, lineCap: .round))\n            .frame(width: 110, height: 110)\n            .onAppear {\n                withAnimation(\n                    Animation\n                        .easeInOut(duration: 0.7)\n                        .repeatForever(autoreverses: false)) {\n                            to = 1\n                        }\n            }\n    }\n}\n```\n\n![이동](https://miro.medium.com/v2/resize:fit:590/1*_RXEvVkvqCafU2ke7Fe17Q.gif)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n감사합니다!\n","ogImage":{"url":"/assets/img/2024-05-20-SwiftUIHeartanimationwithshape_0.png"},"coverImage":"/assets/img/2024-05-20-SwiftUIHeartanimationwithshape_0.png","tag":["Tech"],"readingTime":3},{"title":"iOS 푸시 알림 통합하기Using Swift","description":"","date":"2024-05-20 16:12","slug":"2024-05-20-IntegratingiOSPushNotificationsUsingSwift","content":"\n푸시 알림은 사용자 참여와 유지에 핵심적인 역할을 합니다. 사용자를 최신 상태로 유지하고 사용자가 구매로 이어지는 FOMO를 만들어내죠. 게다가 iOS에서는 Apple의 푸시 알림 서비스 (APNs)라는 추가 혜택이 있습니다. 이 서비스는 앱 서버와 사용자 장치 사이에 중개자 역할을 하면서 앱이 활성화되지 않았거나 사용자가 다른 앱을 확인하고 있어도 푸시 알림을 전달할 수 있게 해줍니다.\n\n이 기사에서는 iOS 앱에 푸시 알림을 단계별로 통합하는 방법을 살펴보고 구현의 중요한 측면을 논의하며 사용자 참여를 간소화하고 강화할 수 있는 몇 가지 제품 및 도구를 소개할 것입니다.\n\n하지만 먼저, 푸시 알림의 혜택이 무엇인가요?\n\niOS 푸시 알림은 사용자 참여, 유지 및 전체적인 사용자 경험을 개선합니다. 푸시 알림이 전략적으로 사용될 때 모바일 앱의 효과를 다양한 비즈니스 분야 전반에 크게 향상시킬 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n일부 특정 목적을 위해 푸시 알림을 배포할 수 있습니다.\n\n- 사용자에게 예약 상태를 업데이트합니다.\n- 사용자가 배치한 주문에 대한 설명과 업데이트를 제공합니다.\n- 백 엔드에서 변경 사항을 사용자에게 알립니다.\n- 패키지를 추적하는 데 도움을 줍니다.\n- 앱과 관련된 이벤트에 대한 흥미를 자아내 줍니다.\n- 사용자에게 새로운 제안, 프로모션 및 기회를 소개합니다.\n- 호기심을 자극할 앱 기능을 시험해 보도록 사용자를 권장합니다.\n- 서버 업데이트 및 기타 백엔드 변경 사항을 알립니다.\n\n제때에 실행되면 푸시 알림은 iOS 사용자가 실제로 원하는 형식의 적시에 효과적인 정보를 제공하므로 우리의 전반적인 UX 및 확장 마케팅 전략에서 중요한 역할을 합니다.\n\n# iOS 알림의 구성 요소는 무엇인가요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\niOS 푸시 알림은 일반적으로 세 가지 주요 구성 요소로 구성됩니다:\n\n- Apple Push Notification Service: 이것은 iOS 기기에 알림 메시지를 전달하는 데 책임을 지는 중앙 허브입니다. APNs를 활성화하려면 개발자는 유료 Apple 개발자 계정이 필요하며 앱 ID를 생성하여 Apple의 개발자 포털에서 푸시 알림을 추가로 구성해야 합니다.\n- 디바이스 토큰: 이것은 각 iOS 기기에 대해 생성된 고유 식별자입니다. APNs는 디바이스 토큰을 생성하고 알림 메시지를 토큰으로 전송하면 해당 기기에 알림이 전달됩니다. 개발자는 AppDelegate에서 푸시 알림을 위해 앱을 등록하여 이 디바이스 토큰을 얻어야 합니다.\n- 앱 서버: 앱 서버는 푸시 알림을 트리거하는 것을 담당합니다. 메시지 페이로드와 함께 APNs와 통신하고 알림 페이로드를 대상 기기로 전송합니다. 여기서는 메시지 페이로드를 관리하고 준비하고 APNs에 요청을 보내 알림 페이로드를 사용자의 기기로 전송합니다. 페이로드는 JSON 형식으로 작성됩니다.\n\n# iOS 푸시 알림 설정\n\n좋아요, 기본 내용을 다뤘습니다. 이제 Swift를 사용하여 iOS 푸시 알림 설정에 대해 좀 더 깊게 파고들어보겠습니다. 이는 Apple 개발자 포털, Xcode, 앱 서버 및 디바이스 토큰 등에서 중요한 단계를 거쳐 설정됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 앱 ID 및 프로비저닝 프로필 설정하기\n\nApple 개발자 계정을 생성했다면 Apple 개발자 포털에 로그인하여 App ID를 생성하고 푸시 알림 통합을 위해 구성할 수 있습니다.\n\nApple 개발자 포털에서 다음 단계를 따라주십시오 (참고: 소유자 또는 관리자 권한이 필요합니다).\n\n- 인증서, 식별자 및 프로필에서 식별자를 클릭합니다. 그런 다음 왼쪽 상단의 추가 버튼 (+)을 클릭합니다.\n- 옵션 목록에서 App ID를 선택하고 계속을 클릭합니다.\n- 옵션 목록에서 App ID 유형이 자동으로 선택된 것을 확인하고 계속을 클릭합니다.\n- 설명란에 App ID의 이름 또는 설명을 입력합니다.\n- 명시적 App ID를 선택하고 번들 ID 필드를 작성합니다. 여기에 입력하는 명시적 App ID는 Xcode의 타겟 요약 창에 입력한 번들 ID와 일치해야 합니다.\n- 이제 와일드카드 App ID를 선택하고 번들 ID 접미사를 번들 ID 필드에 입력합니다.\n- 사용하려는 앱 기능을 활성화하기 위해 해당 확인란을 선택합니다. 앱 및 프로그램 멤버십 유형에 따라 사용 가능한 기능은 기능 아래에 나타납니다. 확인란은 기술이 명시적 App ID를 요구하고 와일드카드 App ID를 만드는 경우에 비활성화되거나 기술이 기본적으로 활성화되어 있는 경우에 비활성화됩니다. 모든 플랫폼에 모든 기능이 적용되는 것은 아닙니다.\n- 계속을 클릭한 후 등록 정보를 검토한 다음 등록을 클릭합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 프로세스를 설명하는 비디오입니다:\n\n이제 푸시 알림 인증서를 만드는 단계를 따라 주세요:\n\n프로비저닝 프로필을 만들기 위해 다음 단계를 따를 수 있습니다:\n\n- Apple 개발자 포털을 엽니다.\n- iOS Dev 대시보드에서 Certificates, Identifiers & Profiles을 클릭합니다.\n- 개발자 대시보드에서 Profiles을 클릭하고 +를 클릭합니다.\n- iOS 앱 개발을 선택하고 계속을 클릭합니다.\n- 프로비저닝 프로필과 연결할 앱 ID를 선택하고 계속을 클릭합니다. 여러 앱에서 하나의 개발 프로비저닝 프로필을 사용하려면 가능한 경우 와일드카드 App ID를 선택하세요.\n- 프로비저닝 프로필에 포함할 하나 이상의 개발용 인증서를 선택하고 계속을 클릭합니다. 개발용 인증서만 나열됩니다.\n- 프로비저닝 프로필에 포함할 하나 이상의 장치를 선택하고 계속을 클릭합니다.\n- 프로필에 의미 있는 이름을 입력하고 생성을 클릭합니다.\n- 다운로드를 클릭하여 프로비저닝 프로필을 다운로드하고 Xcode에서 사용하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# Xcode 설정 구성하기\n\nXcode 프로젝트 설정에서 App ID를 사용해야 합니다. 이를 통해 푸시 알림이 활성화되고 프로비저닝 프로필을 활용할 수 있습니다.\n\n또한 프로젝트 설정의 기능(capabilities)에서 푸시 알림을 활성화해야 합니다.\n\n푸시 알림 기능을 활성화한 후에는 AppDelegate 파일에 푸시 알림 코드를 구현해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n알림: 먼저 UserNotifications 프레임워크를 가져와야 합니다.\n\n```js\nimport UserNotifications\n```\n\n이제 사용자의 승인을 요청하여이 앱의 푸시 알림을 활성화해야합니다. UNUserNotificationCenter 클래스의 requestAuthorization 메서드를 사용할 수 있습니다.\n\n```js\nfunc application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {\n    // 다른 설정 코드\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n// 알림 권한 요청\nUNUserNotificationCenter.current().requestAuthorization(options: [.alert, .sound, .badge]) { granted, error in\n    if granted {\n        print(\"알림 권한이 허용되었습니다\")\n        // 이제 알림을 예약하고 보낼 수 있습니다\n    } else {\n        print(\"알림 권한이 거부되었습니다\")\n        // 사용자가 알림 권한을 거부한 경우 처리\n    }\n}\nreturn true\n```\n\n사용자의 푸시 알림 권한 팝업에 대한 반응에 따라 '허용' 및 '거부된 액세스' 상황을 처리해야 합니다.\n\n# 원격 알림 등록\n\n원격 알림을 등록하려면 UIApplication의 registerForRemoteNotifications() 메서드를 호출해야 합니다. 앱의 AppDelegate에서 이를 호출하여 원격 알림을 등록하고 기기 토큰을 받아옵니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```swift\nclass AppDelegate: UIResponder, UIApplicationDelegate {\n```\n\n```swift\n    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {\n        // 알림 권한 요청\n        UNUserNotificationCenter.current().requestAuthorization(options: [.alert, .sound, .badge]) { granted, error in\n            if granted {\n                print(\"알림 권한 허용됨\")\n                // 원격 알림 등록\n                DispatchQueue.main.async {\n                    application.registerForRemoteNotifications()\n          UNUserNotificationCenter.current().delegate = self\n                }\n            } else {\n                print(\"알림 권한 거부됨\")\n                // 사용자가 알림 권한을 거부한 경우 처리\n            }\n        }\n        return true\n    }\n}\n```\n\n# 기기 토큰 등록 처리\n\n애플리케이션을 통해 알림을 등록한 후, 기기 토큰을 얻어야 합니다. 이는 사용자 기기를 식별하여 나중에 서버에서 알림을 보낼 수 있게 해줍니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 예시에서는 성공적 및 실패적인 기기 등록 방법을 구현했습니다. 등록이 올바르게 작동하면 기기 토큰을 얻게 되며, 이후 서버로 해당 사용자에게 저장할 수 있도록 전송해야 합니다. 기기 토큰이 없으면 이 기기로 알림을 보낼 수 없습니다.\n\n# 원격 알림 처리\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n기기 토큰을 받은 후에는 앱이 알림을 수신할 준비가 되었습니다. 이제 서버로부터 수신되는 알림을 처리하기 위한 관련 메서드를 구현해야 합니다. 이러한 메서드는 앱의 상태에 기반하며, 앱이 전경 또는 배경에서 작동하는지에 따라 다를 것입니다.\n\n만약 앱이 전경에서 실행 중이라면\n\n여기서는 앱이 전경에서 실행 중일 때 푸시 알림을 처리하는 메서드를 구현하고 있습니다:\n\n```swift\nextension AppDelegate: UNUserNotificationCenterDelegate {\n    // 앱이 전경에서 실행 중일 때 알림을 처리\n    func userNotificationCenter(_ center: UNUserNotificationCenter, willPresent notification: UNNotification, withCompletionHandler completionHandler: @escaping (UNNotificationPresentationOptions) -> Void) {\n        // 알림 표시를 처리합니다\n        completionHandler([.alert, .sound, .badge])\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n앱이 활성 상태로 실행 중인 경우, iOS는 알림을 알림 센터에 표시하지 않습니다. 대신, 앱으로 알림을 직접 전달할 것입니다. 사용자에게 경고를 표시하려면 코드를 작성해야 합니다.\n\n만약 앱이 백그라운드에서 실행 중인 경우,\n앱이 실행 중이 아닐 때 알림을 처리하려면 다음 메소드를 구현해야 합니다.\n\n```swift\n// 앱이 백그라운드에서 실행 중일 때 원격 알림 수신 처리\nfunc application(_ application: UIApplication, didReceiveRemoteNotification userInfo: [AnyHashable: Any], fetchCompletionHandler completionHandler: @escaping (UIBackgroundFetchResult) -> Void) {\n    // 받은 원격 알림 처리\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n    // 푸시 알림 페이로드를 출력합니다\n    print(\"원격 알림 수신: \\(userInfo)\")\n    // 알림 콘텐츠 처리\n    if let aps = userInfo[\"aps\"] as? [String: Any], let alert = aps[\"alert\"] as? String {\n        // 알림 페이로드에서 정보 추출\n        print(\"알림 메시지: \\(alert)\")\n    }\n    // 백그라운드 페치 작업 결과를 시스템에 알립니다\n    completionHandler(UIBackgroundFetchResult.newData)\n}\n```\n\n이 방법을 사용하면 알림을 수신한 후에 해당 알림을 처리하고 조치를 취할 수 있습니다.\n\n이제, 사용자가 알림을 탭하면 앱이 열립니다. 이 경우, 앱은 알림과의 상호 작용으로 열렸는지 여부를 감지하고 해당 작업을 수행할 수 있습니다. 특정 뷰 컨트롤러로 이동하는 등의 작업을 수행할 수 있습니다.\n\n# 앱 서버에서 알림 보내기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n서버에 저장된 디바이스 토큰을 사용하여 특정 디바이스로 알림을 보내려면 백엔드 서버에 코드를 구현해야 합니다. 이 코드는 애플 푸시 알림 서버로 요청을 트리거하고 해당 디바이스로 알림을 전송합니다.\n\nNode.JS에서 푸시 알림을 보내는 다음 코드를 사용할 수 있습니다:\n\n```js\nnpm install apn\n```\n\n```js\nconst apn = require(\"apn\");\n// 자격 증명으로 APNs를 구성\nconst apnProvider = new apn.Provider({\n  token: {\n    key: \"path/to/APNsAuthKey.p8\", // APNs Auth Key의 경로\n    keyId: \"YourKeyID\",\n    teamId: \"YourTeamID\",\n  },\n  production: false, // 운영 환경에 대해 true로 설정\n});\n// 알림 페이로드 생성\nconst notification = new apn.Notification({\n  alert: \"Hello Bugfender Testing!\",\n  sound: \"default\",\n  badge: 1,\n});\n// 대상 디바이스의 디바이스 토큰 지정\nconst deviceToken = \"xxxx\"; // 실제 디바이스 토큰으로 대체\n// 알림 보내기\napnProvider\n  .send(notification, deviceToken)\n  .then((result) => {\n    console.log(\"알림을 보냈습니다:\", result);\n  })\n  .catch((error) => {\n    console.error(\"알림 보내기 오류:\", error);\n  });\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n`table` 태그를 Markdown 형식으로 변경하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음은 JSON 페이로드의 예시를 살펴봅시다:\n\n```js\n{\n  \"aps\": {\n    \"alert\": {\n      \"title\": \"Notification Title\",\n      \"body\": \"Notification Body\"\n    },\n    \"badge\": 1,\n    \"sound\": \"default\"\n  },\n  \"customKey\": \"Custom Value\" //원하는 사용자 지정 데이터나 객체\n}\n```\n\n예시에서 보듯이, 페이로드에는 customKey가 있습니다. 앱으로 보낼 알림과 관련된 모든 정보를 전달하고 필요한 작업을 수행하기 위해 필요한 만큼 많은 사용자 지정 키를 추가할 수 있습니다.\n\n크기 제한을 유의하십시오. 페이로드는 JSON 객체여야 하며 최대 크기 제한이 4KB입니다. 이 제한은 알림 전달에 문제가 없도록 보장합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 조용한 알림\n\n조용한 알림을 보내고 싶다면 경고, 뱃지 및 사운드 키 없이 페이로드를 보내야 합니다. 조용한 알림을 사용하면 사용자에게 알리지 않고 앱에서 작업을 실행할 수 있습니다. 이러한 종류의 알림에 대한 몇 가지 사용 사례는 다음과 같습니다:\n\n- 백그라운드 데이터 새로고침: 서버에서 앱을 갱신하도록 알림을 트리거하여 사용자가 앱을 열 때 항상 최신 데이터를 받을 수 있습니다.\n- 분석: 앱을 강제로 분석 데이터 업데이트를 서버로 보내도록 하기 위해 조용한 알림을 사용할 수 있습니다. 이에는 어플 사용 통계 또는 진단 정보가 포함됩니다.\n- 데이터 동기화: 여러 장치에서 사용할 수 있는 앱이 있는 경우, 하나의 앱에서 변경이 발생하면 데이터 동기화를 강제할 수 있습니다.\n\n다음은 조용한 알림의 편리한 예시입니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```json\n{\n  \"aps\": {\n    \"content-available\": 1,\n    \"priority\": \"5\"\n  },\n  \"updateType\": \"newArticles\",\n  \"timestamp\": \"2024-01-12T10:00:00Z\"\n}\n```\n\n# 푸시 알림 로컬라이제이션\n\n서버에서 사용자의 선호 언어를 추적하면 다른 언어로 로컬라이즈된 알림 키를 보낼 수 있습니다.\n\n# 지역 알림\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\niOS 로컬 알림은 특별한 분류로, 어플리케이션이 서버와 독립적으로 특정 시간에 또는 특정 이벤트에 응답하여 알림을 자체적으로 예약하는 것을 가능케 합니다. 이러한 알림은 알림, 캘린더 이벤트 또는 유사한 시나리오에 매우 유용합니다. 이를 작동시키려면 원격 푸시 알림과 마찬가지로 사용 권한을 요청해야 합니다.\n\n로컬 알림을 만드는 예시를 살펴봅시다:\n\n```js\nimport UserNotifications\n```\n\n```js\n// 알림 콘텐츠 생성\nlet content = UNMutableNotificationContent()\ncontent.title = \"리마인더\"\ncontent.body = \"새로운 업데이트를 확인하는 걸 잊지 마세요!\"\ncontent.sound = UNNotificationSound.default\n// 반복 이벤트로 트리거 생성\nlet trigger = UNTimeIntervalNotificationTrigger(timeInterval: 60, repeats: false)\n// 요청 생성\nlet uuidString = UUID().uuidString\nlet request = UNNotificationRequest(identifier: uuidString, content: content, trigger: trigger)\n// 시스템에 요청 등록\nUNUserNotificationCenter.current().add(request) { error in\n   if let error = error {\n       print(\"알림 일정 예약 에러: \\(error)\")\n   }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 푸시 알림을 테스트하고 실제 장치로 전송해보기\n\n푸시 알림을 성공적으로 통합한 후에는 푸시 알림 코드를 제대로 테스트하기 위해 앱을 실제 장치나 시뮬레이터(이미 Xcode 11.4 버전부터 제공되고 있습니다)에서 실행해야합니다.\n\n이전에 얻은 장치 토큰으로 서버 또는 Pusher와 같은 온라인 도구를 사용하여 테스트 알림을 전송할 수 있습니다.\n\n거기에 그치지 않아요: 서버나 도구에서 보낸 알림이 장치로 제대로 수신되었는지 확인할 수도 있고, 앱에서 구현한 경우 알림의 처리 및 리디렉션을 확인할 수도 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n시뮬레이터에서 알림을 테스트하는 단계:\n\n- 시뮬레이터 장치를 선택하고 앱을 실행합니다.\n- Xcode에서 Features 메뉴로 이동하고 Push Notifications을 선택합니다.\n- 미리 정의된 알림을 선택하거나 사용자 정의 payload를 생성합니다.\n- Xcode에서 Run 버튼을 클릭합니다.\n\n알림을 보내기:\n\n다음 curl을 사용하여 테스트 푸시 알림을 보낼 수 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```bash\ncurl --header \"apns-topic: your.bundle.identifier\" \\\\\n     --header \"apns-push-type: alert\" \\\\\n     --header \"authorization: bearer YOUR_AUTH_KEY\" \\\\\n     --data '{\"aps\": {\"alert\": {\"title\": \"Notification Title\", \"body\": \"Notification Body\"}, \"sound\": \"default\", \"badge\": 1}' \\\\\n     --http2 \\\\\n     --cert /path/to/your/certificate.pem \\\\\n     --cert-type PEM \\\\\n     --key /path/to/your/private-key.pem \\\\\n     <https://api.push.apple.com/3/device/YOUR_DEVICE_TOKEN>\n```\n\n- 애플리케이션의 환경에 맞는 올바른 APNs 엔드포인트를 사용하는지 확인해야 합니다 (운영 환경의 경우 api.push.apple.com 또는 개발 환경의 경우 api.development.push.apple.com).\n- apns-push-type 및 apns-topic 헤더는 필수입니다.\n- 인증서와 개인 키가 PEM 형식으로 올바르게 포맷되어 있는지 확인하세요.\n\n# 푸시 알림 지원 제품\n\niOS 애플리케이션에서 푸시 알림을 쉽게 통합하고 테스트할 수 있는 여러 서드 파티 서비스 및 도구가 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이러한 서비스들은 타겟팅된 메시지 전송, 분석 및 기타 기능을 포함하여 전체 푸시 알림 경험을 향상시키고 데이터를 분석하기 위한 다양한 기능을 제공합니다. 여기 몇 가지 주목할만한 제품들이 있습니다:\n\n- Firebase Cloud Messaging (FCM): 구글에서 제공하는 FCM은 iOS, Android 및 웹 앱에서 메시지를 신뢰성 있게 전송할 수 있는 크로스 플랫폼 메시징 솔루션입니다.\n- OneSignal: OneSignal은 다중 플랫폼을 지원하는 인기 있는 푸시 알림 서비스입니다. 고급 타겟팅, A/B 테스트, 앱 내 메시징 및 실시간 분석을 제공합니다.\n- Pusher Beams: Pusher Beams는 iOS 및 Android 기기로 푸시 알림을 전송할 수 있는 푸시 알림 API입니다.\n- Amazon Simple Notification Service (SNS): SNS는 AWS의 잘 관리되는 메시징 서비스로, 푸시 알림을 지원합니다. iOS 기기를 포함한 다양한 엔드포인트로 메시지를 보낼 수 있으며, 메시지 형식에 대해 유연성을 제공합니다.\n- Airship: Airship은 푸시 알림, 앱 내 메시징 및 자동화 기능을 포함한 모바일 참여 플랫폼을 제공합니다.\n- Pushwoosh: Pushwoosh는 다양한 플랫폼을 지원하는 푸시 알림 서비스입니다. 사용자 정의 푸시 알림, 지오 타겟팅, 그리고 실시간 분석과 같은 다양한 기능을 제공합니다.\n- IBM Push Notifications: IBM Push Notifications은 IBM 클라우드 서비스 중 하나로, iOS 및 기타 플랫폼으로 푸시 알림을 전송하는 확장 가능한 솔루션을 제공합니다.\n- CleverTap: CleverTap은 푸시 알림, 앱 내 메시징 및 사용자 참여 도구를 포함한 포괄적인 모바일 마케팅 플랫폼입니다.\n\n# iOS 푸시 알림 FAQ\n\n# iOS에서 푸시 알림이란 무엇인가요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\niOS에서의 푸시 알림은 서버에서 iOS 기기로 전송되는 짧은 메시지로, 사용자에게 기기에 설치된 앱과 관련된 새로운 정보, 업데이트 또는 이벤트를 알리는 데 사용됩니다. 이러한 알림은 사용자의 기기로 직접 전달되며, 앱이 실행되지 않은 상태에서도 받을 수 있습니다.\n\n# 사용자가 iOS에서 푸시 알림을 제어할 수 있나요?\n\n네, iOS 사용자는 어떤 앱이 푸시 알림을 보낼 수 있는지와 알림이 어떻게 표시되는지를 제어할 수 있습니다. 사용자는 iOS 설정 앱에서 알림 설정을 관리할 수 있으며, 특정 앱에 대한 알림을 활성화 또는 비활성화할 수 있고, 알림 스타일을 사용자 정의하거나 푸시 알림이 처리되는 방식을 제어할 수 있습니다.\n\n# 푸시 알림은 텍스트만으로 제한되나요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n네, iOS의 푸시 알림은 풍족한 미디어를 포함할 수 있어요. iOS 개발자로서, 이미지, 소리 및 기타 상호 작용 항목을 포함할 수 있는 풍족한 푸시 알림을 보낼 수 있는 옵션이 있어요. 개발자와 마케터가 사용자의 관심을 더 잡을 수 있는 시각적으로 매력적인 알림을 만들 수 있게 해줘요.\n\n# 푸시 알림을 받으려면 인터넷 연결이 필요한가요?\n\n대부분의 경우 iOS 기기에서 푸시 알림을 받으려면 인터넷 연결이 필요해요. 사용자의 기기로 푸시 알림이 전송될 때, 이는 셀룰러 연결을 통해 전달되어요. 한 가지 예외가 있어요: 로컬 알림은 기기 자체에서 처리되므로 인터넷 연결 없이도 표시될 수 있어요.\n\n# 모든 iOS 기기에서 푸시 알림이 지원되나요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n네, 모든 iOS 기기에서 푸시 알림을 지원합니다. iPhone 및 iPad를 포함한 모든 기기에서 작동합니다. 해당 기기가 호환되는 iOS 버전을 실행 중이고 사용자가 해당 앱의 알림을 허용한 경우, 모든 iOS 기기에서 푸시 알림을 보내고 받을 수 있습니다.\n\n# iOS 푸시 알림을 보내는 데 비용이 드나요?\n\n푸시 알림을 보내는 것은 일반적으로 무료입니다. 그러나 알림을 관리하기 위해 제3자 서비스를 사용하면 프로젝트의 기능 및 규모에 따라 비용이 발생할 수 있습니다.\n\n# 요약하자면\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 단계와 원칙을 결합하여 개발자들은 사용자 만족도, 참여도 및 모바일 애플리케이션 전반적인 성공을 위한 동적이고 효과적인 알림 전략을 만들 수 있습니다.\n\n본 문서에서는 푸시 알림의 통합에 대한 완벽한 단계별 가이드를 제공했습니다. 앱 ID 구성부터 Xcode의 자세한 설정, 잘 구조화된 알림 페이로드 생성 및 iOS 앱에서 푸시 알림 테스트까지 다룹니다.\n\n푸시 알림 서비스를 선택하는 데 도움이 필요하다면, 손쉬운 통합, 플랫폼 지원, 확장 가능성, 분석 기능 및 가격 등의 다양한 요소를 고려해야 합니다. 각 제3자 서비스는 강점이 있으며 선택은 귀하의 요구 사항과 선호도에 따라 다릅니다.\n\n즐겁게 코딩하세요!\n","ogImage":{"url":"/assets/img/2024-05-20-IntegratingiOSPushNotificationsUsingSwift_0.png"},"coverImage":"/assets/img/2024-05-20-IntegratingiOSPushNotificationsUsingSwift_0.png","tag":["Tech"],"readingTime":20},{"title":"SwiftUI 웃기고 독특한 사용자 정의 얼굴 애니메이션 회전 효과","description":"","date":"2024-05-20 16:11","slug":"2024-05-20-SwiftUIFunnyCustomFaceAnimationwithrotationeffect","content":"\n![Funny Custom Face Animation](/assets/img/2024-05-20-SwiftUIFunnyCustomFaceAnimationwithrotationeffect_0.png)\n\n저는 원형과 둥근 직사각형 같은 형태를 사용하여 사용자 정의 얼굴을 만들어보았어요. 눈이 회전하는 애니메이션도 추가했답니다.\n\n```swift\nstruct FunnyFaceView: View {\n\n    // MARK: - 속성\n    @State private var isRotate: Bool = false\n    @State private var rotationAngle: Double = 0\n\n    // MARK: - Body\n    var body: some View {\n        ZStack {\n            faceView()\n            facePartsView()\n        }\n        .onAppear {\n            withAnimation(Animation.linear(duration: 1).repeatForever(autoreverses: false)) {\n                rotationAngle = 360\n            }\n        }\n    }\n}\n\nextension FunnyFaceView {\n\n    @ViewBuilder\n    private func faceView() -> some View {\n        Circle()\n            .fill(Color.yellow)\n            .frame(width: 300, height: 300)\n    }\n\n    @ViewBuilder\n    private func facePartsView() -> some View {\n        VStack {\n            eyesView()\n            mouthView()\n        }\n    }\n\n    @ViewBuilder\n    private func eyesView() -> some View {\n        HStack {\n            eyeView(offset: 10)\n            eyeView(offset: -10)\n        }\n        .offset(y: -50)\n    }\n}\n\n// MARK: - 도우미 뷰\nextension FunnyFaceView {\n    @ViewBuilder\n    private func eyeView(offset: CGFloat) -> some View {\n        ZStack {\n            Circle()\n                .fill(Color.white)\n                .frame(width: 50, height: 50)\n            Circle()\n                .fill(Color.black)\n                .frame(width: 10, height: 10)\n                .offset(x: offset)\n                .rotationEffect(.degrees(rotationAngle))\n        }\n        .onAppear {\n            isRotate.toggle()\n        }\n    }\n\n    @ViewBuilder\n    private func mouthView() -> some View {\n        RoundedRectangle(cornerRadius: 20, style: .continuous)\n            .fill(Color.white)\n            .frame(width: 150, height: 20)\n            .offset(y: 50)\n    }\n}\n\n#if DEBUG\n#Preview {\n    FunnyFaceView()\n}\n#endif\n```\n\n![Funny Custom Face Animation](https://miro.medium.com/v2/resize:fit:590/1*ZUIvBP0Uf6Me8MkBYtu0Sg.gif)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n감사합니다!\n","ogImage":{"url":"/assets/img/2024-05-20-SwiftUIFunnyCustomFaceAnimationwithrotationeffect_0.png"},"coverImage":"/assets/img/2024-05-20-SwiftUIFunnyCustomFaceAnimationwithrotationeffect_0.png","tag":["Tech"],"readingTime":3},{"title":"iOS 개발자가 반드시 보유해야 할 상위 5가지 도구들을 Xcode 아ꅍ널에 소개합니다","description":"","date":"2024-05-20 16:10","slug":"2024-05-20-Top5ToolsEveryiOSDeveloperShouldHaveinTheirXcodeArsenal","content":"\n<img src=\"/assets/img/2024-05-20-Top5ToolsEveryiOSDeveloperShouldHaveinTheirXcodeArsenal_0.png\" />\n\niOS 개발의 동적인 세계에서 적절한 도구를 갖추는 것은 생산성, 코드 품질 및 전체 프로젝트 조직화를 크게 향상시킬 수 있습니다. Xcode 및 iOS 개발자를 위한 많은 도구 가운데, 유틸리티, 혁신성 및 개발 프로세스를 간소화하는 능력으로 눈에 띄는 몇 가지 도구가 있습니다.\n\n이 필수 도구들을 살펴보겠습니다:\n\n## 1. Xcode용 Cleaner\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nXcode용 Cleaner는 개발 환경을 최적화하고자 하는 모든 iOS 개발자에게 중요한 도구입니다. Xcode를 정리함으로써 불필요하고 사용되지 않는 파일을 제거하여 IDE를 심각하게 빠르게 만들고 디스크 공간을 확보할 수 있습니다. Cleaner for Xcode를 주간 또는 월간으로 정기적으로 사용하면 개발자 폴더가 건강한 상태를 유지하며 디스크 공간을 아낄 수 있습니다.\n\n![image](/assets/img/2024-05-20-Top5ToolsEveryiOSDeveloperShouldHaveinTheirXcodeArsenal_1.png)\n\n## 2. CodeAI: Xcode용 AI\n\nCodeAI는 OpenAI의 고급 AI 기술을 직접 Xcode에 통합하여 코딩 효율성을 향상시키는 다양한 기능을 제공하는 혁신적인 도구입니다. 코드 간소화 및 리팩터링, 보유 주기 확인, JSON을 모델로 변환 (그 반대도 가능), 심지어 Objective-C 코드를 Swift로 변환하는 기능 등을 포함하고 있습니다. CodeAI 프리미엄 구독을 통해 전체 잠재력에 액세스할 수 있으며, 코드 품질과 신뢰성을 향상시키는 필수적인 자원을 제공합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![RocketSim for Xcode Simulator](/assets/img/2024-05-20-Top5ToolsEveryiOSDeveloperShouldHaveinTheirXcodeArsenal_2.png)\n\n## 3. Xcode 시뮬레이터용 RocketSim\n\nRocketSim은 Xcode 시뮬레이터에 기능을 추가하여 앱 개발을 더 빠르고 효율적으로 만들어줍니다. 주요 기능으로는 사용자 Defaults 편집기, 시뮬레이터 비행기 모드, 소리, 터치 및 베젤을 포함한 향상된 녹화 기능이 있습니다. 또한 접근성 및 동적 유형 테스트, 위치 시뮬레이션, 푸시 알림 및 딥 링크를 테스트하는 도구뿐만 아니라 완벽한 구현을 위한 디자인 비교 도구도 제공합니다. RocketSim은 빠른 작업, 환경 재정의 및 사용자 정의 설정을 통해 생산성을 높이며 각 기능이 매끄러운 개발 경험에 기여하도록 보장합니다.\n\n![Top 5 Tools Every iOS Developer Should Have in Their Xcode Arsenal](/assets/img/2024-05-20-Top5ToolsEveryiOSDeveloperShouldHaveinTheirXcodeArsenal_3.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 4. Xcode용 PrettySwift\n\nPrettySwift은 Xcode 소스 편집기 확장 프로그램으로, Swift 코드를 자동으로 형식화하고 검사합니다. swift-format을 활용하여 코드 일관성과 가독성을 유지하는데 제로 구성을 채택했습니다. 이 도구는 프로젝트 전반에 걸쳐 깔끔하고 표준화된 코드를 중요시하는 개발자들에게 필수적이며, 수동으로 서식을 지정하는 시간을 절약하고 구문 오류의 가능성을 줄이는 데 도움이 됩니다.\n\n![이미지](/assets/img/2024-05-20-Top5ToolsEveryiOSDeveloperShouldHaveinTheirXcodeArsenal_4.png)\n\n## 5. Xcode용 DevCleaner\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n클리너(Cleaner) 대신에 데브클리너(DevCleaner)를 사용해보세요. 디스크 공간을 관리하는 필수 도구인 데브클리너는 Xcode의 부수적 파일들이 차지하는 공간을 효율적으로 관리할 수 있게 도와줍니다. 이 도구는 사용 편의성과 효율성에 중점을 둔 유사한 기능을 제공하여 개발 중 생성된 불필요한 파일들을 제거함으로써 개발자들이 디스크 공간을 회수할 수 있도록 도와줍니다.\n\n<img src=\"/assets/img/2024-05-20-Top5ToolsEveryiOSDeveloperShouldHaveinTheirXcodeArsenal_5.png\" />\n\n## 결론\n\niOS 개발 세계에 몰두하는 사람들에게 이러한 도구들을 수용함으로써 보다 간소하고 효율적이며 고품질의 코딩 환경으로 한 걸음 더 나아가는 중요한 단계를 나아가게 됩니다. Xcode 정리, 코드 최적화를 위한 AI 활용, 시뮬레이터 성능 향상, 완벽한 코드 표준 보장 등 각 도구는 각자의 장점을 제공하며 이러한 반독할 수 없는 유틸리티들을 Xcode 툴킷에 통합함으로써 단순히 시간을 절약하고 코드 신뢰성을 향상시키는 것뿐만 아니라 iOS 개발 노력에서 전례 없는 성공을 거두기 위한 기반을 마련하는 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만약 이 기사를 즐겼다면, 박수로 지원을 보여주세요! 더 많은 통찰과 팁을 원하시면 팔로우하고 구독도 고려해 주세요. 여러분의 참여는 크게 감사하며, 이를 통해 더 많은 내용을 제공할 수 있습니다!\n\n좋아하실 만한 몇 가지 기사:\n","ogImage":{"url":"/assets/img/2024-05-20-Top5ToolsEveryiOSDeveloperShouldHaveinTheirXcodeArsenal_0.png"},"coverImage":"/assets/img/2024-05-20-Top5ToolsEveryiOSDeveloperShouldHaveinTheirXcodeArsenal_0.png","tag":["Tech"],"readingTime":4},{"title":"SwfitUI 네비게이션 - 코디네이터 패턴 2부 -  경고 ","description":"","date":"2024-05-20 16:08","slug":"2024-05-20-SwiftUINavigationThecoordinatorpatternpart2Alert","content":"\n<img src=\"/assets/img/2024-05-20-SwiftUINavigationThecoordinatorpatternpart2Alert_0.png\" />\n\n만약 Part 1을 아직 읽지 않았다면 여기에서 찾아볼 수 있어요. 이 글은 이전 글의 연장선입니다.\n\nPart 1에서는 네비게이션 라우팅 로직을 coordinators로 격리시켰습니다. 이를 통해 앱을 위한 확장 가능하고 모듈식 네비게이션 설정을 만들었습니다. 하지만 이것은 기본에 불과해요. SwiftUI에서는 navigationPath로 push하는 것 이외에도 더 많은 종류의 네비게이션이 있어요. 이 중 하나는 \"네비게이션\"으로 팝업 알람을 표시하는 것이죠.\n\n오늘은 이 주제에 대해 이야기할 거에요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nSwiftUI에서는 다양한 수정자(modifier)를 제공하여 Alert를 표시할 수 있습니다. 일반적으로 이러한 Alert 수정자는 뷰(View)에 설정되며, ViewModel/View에는 Alert를 표시할지 여부를 결정하는 데 사용되는 Binding`Bool`이 있습니다. 이 논리는 저에게는 좀 더 화면에 적합하게 표현되도록 조정되어야 한다고 생각합니다. 그렇다면 그에 대비할 방법을 찾아봅시다.\n\nAlert에는 다양한 기능이 있을 수 있습니다. 타이틀, 메시지, 한 개 또는 두 개 이상의 버튼(primaryAction, cancelAction)이 포함될 수 있으며, 이러한 버튼은 .destructive 역할을 갖는 등 다양한 역할을 할 수 있습니다. 이는 시스템이 설계된 방식의 일부이며 그것이 예상대로 작동할 것으로 예상됩니다. 그래서 모든 이러한 경우의 Alert를 표시하는 데 필요한 정보를 제공하기 위한 프로토콜을 생성해 봅시다.\n\n```js\nimport SwiftUI\n\nprotocol AlertDisplayable {\n    var title: String { get }\n    var message: String? { get }\n    var buttons: [AlertButton] { get }\n}\n\nstruct AlertButton {\n    let title: String\n    let role: ButtonRole?\n    let action: () -> Void\n\n    private init(title: String, role: ButtonRole?, action: @escaping () -> Void) {\n        self.title = title\n        self.role = role\n        self.action = action\n    }\n\n    static func actionButton(title: String, action: @escaping () -> Void) -> Self {\n        AlertButton(title: title, role: nil, action: action)\n    }\n\n    static func cancelButton(title: String, action: @escaping () -> Void) -> Self {\n        AlertButton(title: title, role: .cancel, action: action)\n    }\n\n    static func destructiveButton(title: String, action: @escaping () -> Void) -> Self {\n        AlertButton(title: title, role: .destructive, action: action)\n    }\n}\n```\n\n이제 part 1에서 생성한 NavigationController에 다음을 추가할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```swift\n@Observable final class NavigationController {\n    var navigationPath = NavigationPath()\n    var alertPath = AlertPath()\n\n    func presentAlert<T>(_ alert: T) where T: AlertDisplayable {\n        alertPath.setAlert(alert)\n    }\n}\n```\n\n일관성을 유지하기 위해 \\*\\*\\*\\*Path 규칙을 따르고 있지만 원하는 대로 이름을 지정할 수 있습니다.\n\n```swift\nimport SwiftUI\n\nstruct AlertPath {\n\n    var alert: AlertDisplayable?\n\n    mutating func setAlert<T>(_ alert: T) where T: AlertDisplayable {\n        self.alert = alert\n    }\n}\n```\n\n또한 설정한 후 경고를 처리하는 CoordinatedView를 업데이트해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```swift\nstruct CoordinatedView<C: Coordinator>: View {\n    private let coordinator: C\n\n    init(_ coordinator: C) {\n        self.coordinator = coordinator\n    }\n\n    var body: some View {\n        @Bindable var navigationController = coordinator.navigationController\n        NavigationStack(path: $navigationController.navigationPath) {\n            coordinator.rootView\n        }\n        .alert(for: $navigationController.alertPath) // <-- Here we add a new viewModifier\n    }\n}\n```\n\n이 alert modifier는 alertPath의 바인딩을 받아 설정된 알림이 있을 경우 알림을 표시하는 사용자 정의 ViewModifier입니다.\n\n```swift\nextension View {\n    func alert(for alertPath: Binding<AlertPath>) -> some View {\n        self.modifier(AlertModifier(alertPath: alertPath))\n    }\n}\n\nstruct AlertModifier: ViewModifier {\n\n    @Binding var alertPath: AlertPath\n\n    init(alertPath: Binding<AlertPath>) {\n        self._alertPath = alertPath\n    }\n\n    func body(content: Content) -> some View {\n        content\n            .alert(\n                alertPath.alert?.title ?? \"\",\n                isPresented: Binding(get: { alertPath.alert != nil }, set: { _ in alertPath.alert = nil }),\n                actions: {\n                    if let buttons = alertPath.alert?.buttons {\n                        ForEach(buttons) { button in\n                            Button(button.title, role: button.role, action: button.action)\n                        }\n                    }\n\n                }, message: {\n                    if let message = alertPath.alert?.message {\n                        Text(message)\n                    }\n                })\n    }\n}\n```\n\n- 알림의 제목은 title 속성에서 가져옵니다.\n- alertPath의 존재 여부에 따라 수동으로 getter 및 setter를 설정한 Binding`Bool`를 전달합니다. 따라서 alert가 존재하는 경우 알림을 표시합니다. 그리고 알림이 닫힐 때 alert를 nil로 설정합니다.\n- 사용 가능한 각 버튼에 대해 제공된 title, role 및 action으로 SwiftUI Button을 만듭니다. 버튼을 하나도 보내지 않으면 시스템이 단일 'OK' 버튼 알림으로 기본 설정됩니다.\n- 필요에 따라 알림 아래에 제목 아래에 알림에 대한 일부 설명 정보가 포함될 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n한 번 시도해 보고 실제로 잘 작동하는지 확인해 봅시다. 알림 유형을 생성해 보겠습니다.\n\n```js\n// 비슷한 알림을 그룹화하거나 케이스별 알림을 만들고 싶다면 emum을 생성할 수 있습니다.\nenum SomeAlert: AlertDisplayable {\n    case alert(buttons: [AlertButton]) // <-- 액션을 주입합니다\n    case alertWithTitleAndMessage(buttons: [AlertButton])\n\n    var title: String {\n        switch self {\n        case .alert:                        return \"제목만 있는 알림\"\n        case .alertWithTitleAndMessage:     return \"제목과 메시지가 있는 알림\"\n        }\n    }\n\n    var message: String? {\n        switch self {\n        case .alert:                    return nil\n        case .alertWithTitleAndMessage: return \"이것은 메시지입니다\"\n        }\n    }\n\n    var buttons: [AlertButton] {\n        switch self {\n        case .alert(let buttons),\n             .alertWithTitleAndMessage(let buttons):    return buttons\n        }\n    }\n}\n\n// 또는\n// 알림을 따로 모델로 사용하고 싶다면 하드코딩된 값들을 가진 구조체를 만들 수 있습니다.\nstruct SomeSpecificAlertType: AlertDisplayable {\n    var title: String = \"특정 알림 제목\"\n    var message: String? = \"특정 메시지\"\n    var buttons: [AlertButton]\n\n    init(onAction: () -> Void, onCancel: () -> Void) { // <- 액션을 주입하고 해당 액션을 처리합니다\n      self.buttons = [\n          .actionButton(title: \"두 번째 작업\", action: onAction),\n          .cancelButton(title: \"취소\", action: onCancel)\n      ]\n    }\n}\n```\n\n알 수 있듯이, enum 케이스별로 Alert 유형을 생성하고 비슷한 알림 유형을 하나의 개체로 그룹화할 수 있습니다. 예를 들어, 모든 권한 알림을 한 곳에 유지하고 싶다면, 개별 알림 구조체/객체로 만들거나 선택은 여러분의 몫입니다. 중요한 점은 처음에 생성한 AlertDisplayable 프로토콜을 준수하는지입니다. 이제 모바일 앱에서 구현이 어떻게 보일지 살펴보겠습니다.\n\n```js\nstruct FirstView: View {\n    let viewModel: FirstViewModel\n\n    var body: some View {\n        VStack {\n            Text(\"첫 번째 화면\")\n            Button(\"알림 표시\") {\n                viewModel.didTapButton()\n            }\n        }\n    }\n}\n\n@Observable class FirstViewModel {\n    let coordinator: FirstCoordinator\n\n    init(coordinator: FirstCoordinator) {\n        self.coordinator = coordinator\n    }\n\n    func didTapButton() {\n        coordinator.presentAlert(\n                SomeAlert.alert(buttons: [\n                    .actionButton(title: \"주요 작업\") {\n                        print(\"작업 버튼 누름\") // <- 버튼 클릭 시 호출되는 클로저\n                    },\n                    .cancelButton(title: \"취소\") {\n                        print(\"취소 버튼 누름\") // <- 버튼 클릭 시 호출되는 클로저\n                    }\n                ]))\n    }\n}\n\n@Observable final class FirstCoordinator: Coordinator {\n    typealias Route = FirstCoordinatorRoute\n\n    let navigationController: NavigationController\n\n    @MainActor @ViewBuilder var rootView: some View {\n        FirstView(FirstViewModel(self)).navigationDestination(for: Route.self, destination: coordinate(_:))\n    }\n\n    func presentAlert<T>(_ alert: T) where T: AlertDisplayable {\n        navigationController.presentAlert(alert)\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이는 viewModel에서 프로그래밍 방식으로 알림을 표시할 수 있게 해주며, 사용자가 버튼을 클릭할 때 viewModel이 선택적으로 콜백을 처리할 수 있게 합니다. 이 경우 뷰 자체 \"FirstView\"는 무엇이 일어나는지 전혀 모릅니다. 알고 있는 것은 didTapButton뿐입니다.\n\n![image](/assets/img/2024-05-20-SwiftUINavigationThecoordinatorpatternpart2Alert_1.png)\n\n부분 2에 대한 내용은 여기까지입니다.\n\n이 내용이 유용하다고 생각되면 좋겠습니다. 피드백이나 개선 제안이 있으면 알려주세요. 이 글이 유익했다면 공유해 주세요!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n좋은 하루 보내세요!\n","ogImage":{"url":"/assets/img/2024-05-20-SwiftUINavigationThecoordinatorpatternpart2Alert_0.png"},"coverImage":"/assets/img/2024-05-20-SwiftUINavigationThecoordinatorpatternpart2Alert_0.png","tag":["Tech"],"readingTime":10}],"page":"89","totalPageCount":116,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":4},"__N_SSG":true}