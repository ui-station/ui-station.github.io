{"pageProps":{"posts":[{"title":"개발자를 위한 간편한 웹훅 테스트 방법 스트레스 없는 튜토리얼","description":"","date":"2024-06-23 21:18","slug":"2024-06-23-WebhookTestingWithouttheHeadacheADevelopersSanity-SavingTutorial","content":"\n![웹훅 테스트하지 않고 괴로움을 덜어내는 개발자를 위한 튜토리얼_0.png](/assets/img/2024-06-23-WebhookTestingWithouttheHeadacheADevelopersSanity-SavingTutorial_0.png)\n\n안녕하세요! 이 튜토리얼에서는 웹훅을 효과적으로 테스트하는 방법을 알아볼 거에요. Ngrok를 사용하여 로컬 머신에서 서드파티 웹훅을 직접 수신하는 방법을 알려드릴 거에요. 이 모든 과정은 공개 도메인이 필요하지 않아요. 웹훅 테스트 과정을 전보다 더 효율적으로 운용할 수 있도록 준비하세요!\n\n또한, Wiremock를 사용하여 웹훅을 효율적으로 모킹하는 방법에 대해 알려드릴 거에요. 웹훅을 모킹하는 방법을 배우는 이유는 완전히 오프라인 테스트 환경을 갖게 되어 의존성이 없는 환경을 구축할 수 있기 때문이에요. 더불어, 일부 서비스에서 웹훅의 과도한 사용에 대해 요금을 청구하는 경우도 있으니 이를 피하도록 합시다.\n\n이 튜토리얼을 마치신 후에는\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 제 3자 서비스에서 웹훅을 로컬 응용 프로그램(로컬호스트)으로 라우팅합니다.\n- 로컬 및 오프라인 개발을 위한 웹훅 모의 테스트\n\n## 웹훅이란?\n\n![이미지](/assets/img/2024-06-23-WebhookTestingWithouttheHeadacheADevelopersSanity-SavingTutorial_1.png)\n\n웹훅은 알림 시스템처럼 작동합니다. 친구에게 전화번호를 알려주면 그들이 뉴스가 있을 때마다 전화를 합니다. 디지털 세계에서 웹훅은 전화번호 대신에 URL을 통해 동작합니다. 제 3자 소프트웨어에게 URL을 제공하면 그들이 무언가가 발생할 때 즉시 알림을 받습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n예를 들어, GitHub 저장소에서 실패한 파이프라인과 같은 변경사항이 발생하면 GitHub가 즉시 웹훅(webhook) 메시지를 지정된 URL로 보냅니다. 이 URL은 당신이 선택한 서비스로 이어져야 합니다.\n\n웹훅을 사용하기 위해 필요한 것은 서비스에 제공된 URL에서 수신하는 API입니다.\n\n## 공개 도메인 없이 Ngrok을 사용하여 웹훅 테스트하기\n\n![이미지](/assets/img/2024-06-23-WebhookTestingWithouttheHeadacheADevelopersSanity-SavingTutorial_2.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n웹훅을 테스트하는 것은 공개 URL이 필요하기 때문에 종종 귀찮을 수 있습니다. 특히 로컬에서 코드를 작성하려고 할 때 이런 장애물이 있습니다. 하지만 걱정하지 마세요. 이 문제를 해결하는 방법이 있으며 생각보다 쉽습니다.\n\nNgrok를 이용해보세요. Ngrok를 통해 개발 중에도 API를 공개 도메인에 호스팅하지 않아도 됩니다. Ngrok를 사용하면 로컬 컴퓨터와 인터넷 사이에 중간자 역할을 하는 프록시를 우리의 기기에서 설정할 수 있습니다.\n\nNgrok는 컴퓨터에서 에이전트를 실행하여 작동합니다. 그런 다음 Ngrok가 무료 도메인을 할당해주고 그 도메인으로의 모든 트래픽을 에이전트로 라우팅합니다. Ngrok 문서에서 자세한 정보를 찾을 수 있습니다.\n\nNgrok를 사용하려면 계정을 만들어야 하지만 무료로 사용할 수 있습니다. Ngrok에서 계정을 생성하여 사용을 시작해보세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그 후에는 호스트에서 실행할 수 있는 에이전트를 설치해야 합니다. Ngrok 대시보드에서 설치 지침과 권한 토큰을 찾을 수 있습니다.\n\n```js\nwget https://bin.equinox.io/c/bNyj1mQVY4c/ngrok-v3-stable-linux-amd64.tgz\nsudo tar -xvzf ngrok-v3-stable-linux-amd64.tgz -C /usr/local/bin\nngrok config add-authtoken YOURTOKEN\n```\n\n다음으로 에이전트를 시작하여 애플리케이션으로 웹훅을 받을 수 있습니다.\n\n```js\nngrok http http://localhost:8080\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n명령을 실행하면 약간의 정보가 표시됩니다. 가장 중요한 정보는 Webhooks에 사용할 수있는 URL인 Forwarding입니다.\n\n![Webhook](/assets/img/2024-06-23-WebhookTestingWithouttheHeadacheADevelopersSanity-SavingTutorial_3.png)\n\n## Webhooks를 수신하는 프로젝트 설정\n\n우리는 Webhooks를 트리거하는 서비스가 필요합니다. 간단히 하기위해 저는 이 서비스로 Github를 사용할 것입니다. GitHub 계정을 방문하십시오(또는 마음에 드는 다른 서비스를 사용하십시오)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Webhook Tutorial](/assets/img/2024-06-23-WebhookTestingWithouttheHeadacheADevelopersSanity-SavingTutorial_4.png)\n\nIf you create or select a repository you own, you can visit the settings. There should be a Webhooks tab that allows you to set up a webhook.\n\nUsually, webhook services ask you for a URL. This URL should be the domain that Ngrok prints out for you.\n\nThe secret can be used to validate requests. Read more on GitHub. The secret will be used to create a hash that we can use to validate that the request comes from GitHub.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![WebhookTestingWithouttheHeadacheADevelopersSanity-SavingTutorial_5](/assets/img/2024-06-23-WebhookTestingWithouttheHeadacheADevelopersSanity-SavingTutorial_5.png)\n\n## 웹훅을 수락하는 애플리케이션 생성하기\n\n우리는 Ngrok이 포트 8080에서 수신 대기하고 있으며 Github을 설정하여 이벤트를 Ngrok URL로 푸시하도록 했습니다.\n\n마지막으로 필요한 것은 포트 8080에서 수신 대기하는 웹훅 핸들러입니다. 이를 위해 간단한 Go HTTP 핸들러를 생성하여 요청 내용을 출력하겠습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 서비스는 우리 머신으로 전송된 모든 데이터를 출력하는 매우 간단한 서비스입니다. 테스트하는 데 충분합니다.\n\n```js\npackage main\n\nimport (\n \"io\"\n \"log/slog\"\n \"net/http\"\n)\n\nfunc main() {\n\n // /에 대한 요청 수락 및 페이로드 출력\n http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n  defer r.Body.Close()\n\n  data, err := io.ReadAll(r.Body)\n\n  if err != nil {\n   panic(err)\n  }\n  slog.Info(\"새 요청\", \"페이로드\", string(data))\n })\n\n slog.Info(\":8080 포트에서 수신 대기 중\")\n // 앱을 :8080에서 제공하며, Ngrok이 웹훅을 로컬 애플리케이션으로 라우팅할 수 있도록 동일한 포트를 사용해야 함(중요)\n http.ListenAndServe(\":8080\", nil)\n}\n```\n\n우리는 Ngrok에 사용하라고 한 것과 동일한 포트(여기서는 :8080)를 사용해야 합니다.\n\n로컬호스트:8080의 트래픽을 수신하고 Ngrok이 웹훅을 로컬 애플리케이션으로 라우팅할 수 있도록 go run main.go 명령을 실행하여 Go 애플리케이션을 실행하십시오.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nGitHub이 웹훅을 생성할 때 PING을 보내게 됩니다. \"redeliver\"를 눌러 이 PING 훅을 다시 전달할 수 있습니다. \"최근 전달\"을 방문하여 세 개의 점을 누르고 \"redeliver\"를 선택하세요.\n\n이번에는 성공적으로 실행되었다는 확인 표시가 보여야 합니다.\n\n![Webhook Testing](/assets/img/2024-06-23-WebhookTestingWithouttheHeadacheADevelopersSanity-SavingTutorial_6.png)\n\n더 검증하기 위해 Go 어플리케이션 출력을 검토해 보세요. GitHub로부터 JSON 페이로드를 출력했어야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n2024/01/24 20:59:47 INFO 포트 :8080에서 수신 대기 중\n2024/01/24 21:00:18 INFO 새로운 요청 페이로드=\"{\\\"zen\\\":\\\"Keep it logically awesome.\\\n....\n\n## WireMock을 사용한 Webhook 모의\n\n이제 진짜 서비스에서 페이로드를 보내주는 상황에서 몇 가지 문제를 해결해봅시다.\n\n- 만약 서비스가 다운되면 개발 및 테스트를 할 수 없습니다.\n- 어떤 서비스는 돈이 들기도 하니, 오프라인 솔루션을 원합니다.\n- 서비스들은 일반적으로 사용자 입력이 필요하며 웹훅을 실행하려면, 자동화하고 싶습니다.\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이런 것들은 Wiremock을 사용하여 해결할 수 있어요.\n\n만약 Wiremock이 익숙치 않다면, 꼭 언급해야겠어요. REST, gRPC, 웹훅 등 다양한 데이터를 모의(mock)하는 데에 탁월한 도구입니다.\n\n우리는 Wiremock을 Docker 컨테이너를 통해 실행할 거에요. Wiremock이 관련된 모든 데이터를 저장할 wiremock라는 새로운 폴더를 만들 거에요.\n\n이 글에서 Wiremock의 모든 내용에 대해 다루지는 않겠지만, 기본적으로 WireMock은 규칙을 정의하는 JSON 파일을 받아들입니다. 이 규칙들은 REST 엔드포인트를 설명하고, 리턴해야 하는 데이터를 정의하거나 보내야 하는 웹훅을 설명할 수 있어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nJSON 파일 안에 이러한 매핑은 mappings 폴더 안에 라이브해야 합니다. 그래서 하나를 생성할 겁니다.\n\n```js\nmkdir -p wiremock/mappings\ntouch wiremock/mappings/webhook.json\n```\n\nwebhook.json 안에 send-webhook이라는 엔드포인트를 생성할 겁니다. 이 엔드포인트가 GET 요청을 받으면 WebHook을 실행합니다. 우리는 위치 앱의 위치와 사용할 payload를 지정할 수 있습니다.\n\n```js\n{\n    \"request\": {\n        \"urlPath\": \"/send-webhook\",\n        \"method\": \"GET\"\n    },\n    \"response\": {\n        \"status\": 200\n    },\n    \"serveEventListeners\": [\n        {\n            \"name\": \"webhook\",\n            \"parameters\": {\n                \"method\": \"POST\",\n                \"url\": \"http://localhost:8080\",\n                \"headers\": {\n                    \"Content-Type\": \"application/json\"\n                },\n                \"body\": \"{ \\\"result\\\": \\\"SUCCESS\\\" }\"\n            }\n        }\n    ]\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n해당 파일이 있으면 Docker를 사용하여 WireMock를 시작하고 호스트 네트워크에서 실행되는지 확인합니다. 이렇게 하면 포트 8080에서 실행 중인 Go 애플리케이션에 연결할 수 있습니다.\n\n일반적으로 Docker compose를 사용하여 서비스 이름을 대신 사용하는 경우가 많은데, 이번 튜토리얼 중에는 편의를 위해 localhost를 사용할 것입니다. WireMock 폴더를 마운트하고, 프로젝트 루트에 위치해 있는지 확인하세요.\n\n```js\ndocker run -it --rm --name wiremock --network=host -v $PWD/wiremock:/home/wiremock wiremock/wiremock:3.3.1 --verbose --port=8081\n```\n\nWireMock는 포트 8081에서 실행 중이므로 해당 URL에 CURL을 보내고 Webhook을 활성화할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\ncurl localhost:8081/send-webhook\n```\n\n위 명령을 실행한 후 Go 서비스에서 웹훅이 도착하는 것을 확인할 수 있어요.\n\n```js\n2024/01/24 21:49:10 INFO New request payload=\"{ \\\"result\\\": \\\"SUCCESS\\\" }\"\n```\n\n실제 데이터를 모킹하기 위해 Ngrok 웹훅에서 Payload를 훔쳐와서 wiremock 매핑의 body 필드에 붙여넣을 수 있어요. 이렇게 하면 서비스에서 제공되는 실제 데이터와 유사한 데이터로 모킹할 수 있어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 결론\n\n이 튜토리얼에서는 서비스로부터 웹훅을 로컬 애플리케이션에 받아들이는 간단한 방법을 만들었습니다. 이것은 타사 애플리케이션에서 웹훅을 테스트하는 데 사용될 수 있습니다.\n\n일반적으로 저는 실제 페이로드가 전송되는 Ngrok를 설정하여 시작합니다. 타사 서비스가 어떻게 작동하며 어떤 종류의 데이터를 기대할지를 배우는 데 사용할 수 있습니다.\n또한 항상 터널을 사용하여 트래픽에 의존하는 것을 중지할 수도 있습니다.\n실제 페이로드를 받은 후에는 일반적으로 WireMock에 넣어서 종속성이나 개발 후크 지불을 피할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 세팅을 통해 개발 중에 데이터를 쉽게 목업하고, 웹훅에 의존하는 애플리케이션을 빌드하는 동안 엔드 투 엔드로 테스트할 수 있습니다.\n\n이 튜토리얼이 마음에 들었길 바라며, 아이디어나 생각이 있으시면 언제든지 연락해주세요!\n\n## 부록\n\nNgrok — https://ngrok.com/\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n**Ngrok 동작 원리** - [링크](https://ngrok.com/docs/how-ngrok-works/)\n\n**WireMock** - [링크](https://wiremock.org/docs/webhooks-and-callbacks/)\n\n**GitHub 웹훅** - [링크](https://docs.github.com/en/webhooks/using-webhooks/creating-webhooks)\n\n**GitHub 웹훅 유효성 검사** - [링크](https://docs.github.com/en/webhooks/using-webhooks/validating-webhook-deliveries)\n","ogImage":{"url":"/assets/img/2024-06-23-WebhookTestingWithouttheHeadacheADevelopersSanity-SavingTutorial_0.png"},"coverImage":"/assets/img/2024-06-23-WebhookTestingWithouttheHeadacheADevelopersSanity-SavingTutorial_0.png","tag":["Tech"],"readingTime":12},{"title":"4개의 새로운 활발한 오픈 소스 프로젝트 소개","description":"","date":"2024-06-23 21:17","slug":"2024-06-23-4NewActiveOpenSourceProjects","content":"\n이것들은 인공 지능, 데이터 분석, 시각화 및 응용 프로그램 개발의 교차로에 있는 몇 가지 최첨단 오픈 소스 플랫폼 및 도구에 대한 개요입니다. 이 목록에서는 대부분 데이터베이스 시스템을 다루고 있지만 SuperMemory에 대해서도 놀라실 것이라고 생각합니다.\n\n## 더 읽을 거리:\n\nUX를 위한 카드 정렬 이해\n\n설명 가능한 AI를 위한 4가지 오픈 소스 도구\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n값에 의한 전달과 참조에 의한 전달 이해하기\n\n봉사 기회를 찾는 새로운 앱\n\n구독 무료인 AI 뉴스레터 BrainScriblr도 쓰고 있어요.\n\n![Image](/assets/img/2024-06-23-4NewActiveOpenSourceProjects_0.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## Metabase\n\n메타베이스는 사용자가 데이터베이스에 쉽게 연결하고 데이터를 탐색하고 시각화하며 통찰을 공유할 수 있는 비즈니스 인텔리전스 및 분석 플랫폼입니다.\n\n메타베이스는 MySQL, PostgreSQL, MongoDB, Redshift, Snowflake, BigQuery 등 다양한 데이터베이스에 연결할 수 있습니다. 몇 분만에 데이터베이스 연결 설정을 구성하는 직관적인 인터페이스를 제공합니다. 대규모 데이터 집합 및 복잡한 분석 쿼리를 처리하기 위해 메타베이스는 대량 데이터를 확장 가능한 방식으로 실행하는 Redshift, Snowflake, BigQuery, Vertica 등의 데이터 웨어하우스에 연결할 수 있습니다.\n\nMySQL, PostgreSQL, Oracle, SQL Server와 같은 전통적인 관계형 데이터베이스 관리 시스템(RDBMS)에 저장된 데이터를 분석하기에 적합합니다. 이러한 데이터베이스는 데이터를 탐색하고 빠르게 통찰을 얻기 위해 Metabase를 시작하는 데 좋습니다. 또한 메타베이스는 Apache Spark(SparkSQL) 및 Presto와 같은 쿼리 엔진과 통합되어 실시간 스트리밍 데이터를 포함한 다양한 소스에서 데이터를 쿼리할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## LanceDB\n\nLanceDB는 데이터 분석 및 머신 러닝 워크플로우를 최적화하도록 특별히 설계된 오픈 소스 데이터베이스입니다. 뛰어난 성능과 확장성으로 주목받으며 대용량 및 복잡한 데이터 세트를 관리하는 데 이상적인 선택지입니다.\n\nLanceDB는 데이터 액세스와 조작이 신속하게 이루어지므로 데이터 처리와 실시간 분석을 필요로 하는 작업에 필수적입니다. 그 아키텍처는 머신 러닝 응용 프로그램의 요구 사항을 처리하도록 맞추어져 있어 방대한 데이터 세트를 효율적으로 저장하고 조회하는 견고한 기반을 제공합니다.\n\n인기 있는 데이터 과학 도구 및 프레임워크와 원활하게 통합됩니다. Pandas, TensorFlow, PyTorch 등의 라이브러리와 잘 작동하여 데이터 과학자와 엔지니어들이 기존의 워크플로에 쉽게 통합할 수 있도록 지원합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 호환성은 데이터 처리 과정을 간소화하여 사용자가 데이터 관리 복잡성보다는 분석 및 모델 구축에 더 집중할 수 있도록 돕습니다. 데이터베이스가 최소한의 대기 시간으로 복잡한 쿼리를 지원하는 능력은 요구되는 데이터 과학 환경에서의 유용성을 더욱 높여줍니다.\n\n또한 오픈 소스 프로젝트인 LanceDB는 활발하고 역동적인 커뮤니티의 혜택을 받아 지속적으로 발전하고 개선됩니다.\n\n## SuperMemory\n\n슈퍼메모리는 개인 디지털 “두 번째 뇌”로 작동하는 혁신적인 플랫폼입니다. 다양한 온라인 소스에서 정보를 통합하여 사용자가 데이터를 효율적으로 저장하고 조직할 수 있습니다. 이 도구는 방대한 지식 베이스를 관리해야 하는 연구자, 작가 및 개발자들에게 특히 유용합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n컬렉션을 생성하고, 고급 데이터 상호작용을 위해 AI를 사용하며, 강력한 검색 기능을 활용하여 빠르게 정보를 검색할 수 있습니다. 이 플랫폼의 2D 지식 캔버스는 시각적으로 조직화를 가능하게 하며, 사용자의 정보 연결 및 기억 능력을 향상시킵니다.\n\n그리고, Supermemory는 콘텐츠 생성을 돕는 글쓰기 어시스턴트를 제공하고, Twitter 북마크를 가져오는 것을 지원하여 다양한 전문적인 요구에 유연하게 대처할 수 있습니다. AI와 사용자 친화적 기능을 통합함으로써, Supermemory는 방대한 양의 정보를 관리하고 상호 작용하는 프로세스를 최적화하여 생산성과 지식 보존을 극대화합니다.\n\n![이미지](/assets/img/2024-06-23-4NewActiveOpenSourceProjects_1.png)\n\n## Tantivy\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nTantivy는 러스트로 작성된 완전한 텍스트 검색 엔진 라이브러리로, 뛰어난 성능과 신뢰성을 제공하도록 설계되었습니다. GitHub에서 제공되는 이 프로젝트는 Apache Lucene과 유사한 효율적이고 다양한 검색 엔진 프레임워크를 목표로 합니다.\n\nTantivy의 기능에는 텍스트 데이터의 색인화, 질의, 그리고 점수 매기기가 포함되어 있으며, 구문 검색, 모호한 검색, 용어 부스트, 범위 질의와 같은 고급 검색 기능을 지원합니다. 효율적인 아키텍처는 빠른 데이터 검색과 견고한 성능을 보장하여 고성능 검색 애플리케이션을 개발하는 개발자들에게 이상적인 선택지가 됩니다.\n\nTantivy는 사용자 친화적인 디자인과 포괄적인 문서를 통해 라이브러리를 효과적으로 통합하고 활용할 수 있도록 도와줍니다. 이 프로젝트는 간단한 애플리케이션에서의 검색 기능 빌드부터 기업 환경에서의 복잡한 대규모 검색 요구사항 처리에 이르기까지 다양한 사용 사례를 지원합니다.\n\n활발한 커뮤니티와 지속적인 개발 노력은 Tantivy의 견고함과 적응성에 기여하여 풀 텍스트 검색 요구사항에 대한 신뢰할 수 있고 최신의 솔루션이 되도록 보장합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n오픈 소스는 끊임없이 발전하는 공간입니다. 매주 새로운 도구가 하나 또는 두 개씩 나오고 있습니다. 특히 AI가 급속히 발전함에 따라 AI가 시스템에 통합된 도구들이 빠르게 개발되고 있습니다. 여러분이 다음 개발 프로젝트에서 사용할 가치 있는 프로젝트 중 하나를 찾기를 바랍니다. 또는 Supermemory와 같이 개인적인 용도로 사용해보세요. 그러나 Supermemory를 업무에도 사용할 수 있습니다.\n\n건배!\n","ogImage":{"url":"/assets/img/2024-06-23-4NewActiveOpenSourceProjects_0.png"},"coverImage":"/assets/img/2024-06-23-4NewActiveOpenSourceProjects_0.png","tag":["Tech"],"readingTime":5},{"title":"좋은 코드와 나쁜 코드란 비전문가를 위한 일러스트 예제","description":"","date":"2024-06-23 21:16","slug":"2024-06-23-WhatisgoodbadcodeAnillustratedexamplefornon-programmers","content":"\n한 번 어딘가에서 다음 내용을 담은 것 같은 격언을 읽은 적이 있어요:\n\n어떤 대중적인 출판물에 나온 것 같다는 기억이 나요. 기사의 주제가 “나쁜 코드에 주의하세요. 죽을 수도 있어요. 아, 그렇지만 보이지 않으니 걱정 마세요!” 정도의 내용이었던 것 같아요. 독자들에게는 진정한 위안이 되는 메시지네요, 그렇지 않나요? 회상해 보면, 그 기사는 우리 주변에 점점 늘어나는 항공기, 기차, 그리고 자율 주행 자동차들 속에 숨어 있는 ‘나쁜 코드’를 선동하는 취지였던 것 같아요. 그리고 독자들의 관심을 끌려고 한 것 같기도 해요.\n\n# 일반인으로서 ‘나쁜 코드’란 무엇일까요?\n\n하루에 약 5시간 동안 코드를 작성하고 검토하며 다시 작성하는 일(코드 리팩토링: 보다 간결하고 사용하기 편한 방식으로 재작성하는 것)을 하는 사람으로써, 코드가 무엇인지(나쁜 코드가 무엇인지도, 확실히 알아요!). 많은 사람들이 코드가 무엇인지 모른다는 것을 잊을 때가 종종 있어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위 문제에 대한 다음 대답을 제공합니다. “너는 코더인데, 무슨 일을 하는 거야?”\n\n위 대답이 언급한 대로, 소프트웨어 개발자/코더/프로그래머는 사실적인 존재를 가진 것을 만들고 있지만 그것들은 보기에는 너무 작아서 실체를 파악하기 어렵습니다 (하지만, 어셈블리 또는 작은 문 모음집으로 상상할 수 있습니다). 그 자체만으로 충분히 미친 듯한 일이지만, 적어도 그것을 상상할 수 있다면 \"코딩\"이 무엇인지 개념적으로 이해했다고 축하해요! 그러나 이 섹션 제목의 질문으로 돌아갑시다. — '나쁜 코드'란 무엇일까요?\n\n작은 문 모음집 비유를 유지하면, 나쁜 코드란 너무 많은 문이 있는데 그 문들이 불필요하게 반복되거나 복잡한 방식으로 배치된 것을 뜻합니다.\n\n문 모음집 비유로는 시각화하기나 더 설명하기 어렵기 때문에, 이 시점에서 아래에 작성하고 설명하는 다른 비유를 제공하고 싶습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 나사 돌리기 장치 만들기!\n\n우리가 나사 돌리기 장치를 만들고 싶다고 가정해 봅시다. 회전 가능한 나사를 만들어서 먼 곳에 있는 다른 나사도 함께 회전시킬 수 있는 장치입니다. 제품 요구 사항은 아래와 같습니다. 한 개의 나사를 돌리면, 멀리 떨어진 다른 나사도 회전할 것입니다:\n\n![이미지](/assets/img/2024-06-23-WhatisgoodbadcodeAnillustratedexamplefornon-programmers_0.png)\n\n나쁜 코드는 일단 문제를 해결하는 데만 집중하며, 나사와 나사 돌리기 장치를 반죽으로 연결하는 가장 쉬운 해결책을 제안합니다. 나쁜 코드는 초반에 Occam의 면도날 상을 수상합니다. 좋은 코드는 초반에는 조금 지나친 것처럼 보이며, 고무 벨트와 2개의 바퀴를 활용합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-06-23-WhatisgoodbadcodeAnillustratedexamplefornon-programmers_1.png\" />\n\n# 요구 사항 변경! 손잡이가 다시 위치로 이동되어야 합니다!\n\n개발 주기에서 항상 발생하는 것처럼 어느 순간 고객 요구 사항이 변경됩니다. 이 비유에서 고객은 이제 원래 손잡이의 앞쪽과 옆쪽에 위치한 다른 손잡이를 회전시킬 수 있는 손잡이를 원합니다. 아래 그림과 같이요:\n\n<img src=\"/assets/img/2024-06-23-WhatisgoodbadcodeAnillustratedexamplefornon-programmers_2.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n나쁜 코드는 몇 개의 간단한 부품을 추가해야 하며, 이는 전체 시스템을 보다 부서지기 쉽고 고장 발생 가능성이 높게 만듭니다. 좋은 코드는 새로운 요구 사항이 생겨도 약간의 조정만으로 문제를 해결할 수 있으며, 그냥 더 긴 고무 벨트를 사용하여 이 문제를 해결합니다.\n\n![이미지](/assets/img/2024-06-23-WhatisgoodbadcodeAnillustratedexamplefornon-programmers_3.png)\n\n# 요구 사항 변경! 손잡이의 회전 속도를 늦춰야 합니다!\n\n마침내, 고객님이 손잡이를 서로 다른 속도로 회전하길 원하는 결정을 내렸습니다. 입력 손잡이를 작게 돌리면 연결된 손잡이가 크게 회전해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n새 요구 사항에 따라, 나쁜 코드는 시스템에 더 많은 구성 요소를 추가해야 하므로 더욱 복잡해집니다. 반면에 좋은 코드는 다시 한번 조정이 필요하며 연결된 조절 부분에 더 큰 휠을 사용하는 것으로 충분합니다:\n\n![이미지](/assets/img/2024-06-23-WhatisgoodbadcodeAnillustratedexamplefornon-programmers_4.png)\n\n# 비유 후기: 그렇다면?\n\n위의 내용처럼, 요구 사항이 간단할 때 좋은 코드는 종종 과잉으로 느껴지지만, 고객 요구 사항이 변경될 때(항상 그렇듯이) 정말 빛을 발합니다. 다시 말해, 잘 확장되고 변경됩니다. 반면에 나쁜 코드는 간단한 문제에 대해 간단하고 좋아 보이지만, 시스템이 변경되거나 복잡성이 증가할 때 악몽이 됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n하지만 혹시 \"음, 위에서 설명한 두 시스템 모두 결국 같은 결과를 얻을 수 있어요 - 손잡이 회전기는 어느 경우에도 성공적으로 작동해요\" 라고 생각하고 계실지도 모릅니다.\n\n맞아요 - 혼자서 개발하거나 취미로 프로젝트를 하는 경우에는 괜찮은 방법입니다. 저도 (제 경우에는 일반 JS 코드) 수만 줄의 나쁜 코드를 작성한 적이 많았는데요, 그렇다고 문제가 없었어요. 그 코드는 작동하고, 배포하고, 한 번도 되돌아본 적이 없어요.\n\n하지만 전문적인 코딩은 본질적으로 협업의 결과물이에요. 그리고 여러분이 작성하는 코드는 현재나 미래에 다른 개발자들에 의해 계속해서 읽히고 수정될 거에요. 코드가 이해하기 쉬울수록 다른 개발자들이 더 쉽고 효율적으로 작업할 수 있으니까요.\n\n- \"여기 손잡이 회전기가 있어요. 2개의 바퀴와 벨트로 구성돼요\" 또는\n- \"이것이 연결 막대를 보관하는 삽입이에요. 이것이 연결 막대이고, 이 다른 삽입 위에 있는 작은 구멍에 막대의 끝을 넣어야 해요...\"\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n나는 당신이 시니어 개발자로부터 코드베이스를 이어받는 주니어 개발자라면 어떤 것을 더 좋아할지 궁금해요! :)\n","ogImage":{"url":"/assets/img/2024-06-23-WhatisgoodbadcodeAnillustratedexamplefornon-programmers_0.png"},"coverImage":"/assets/img/2024-06-23-WhatisgoodbadcodeAnillustratedexamplefornon-programmers_0.png","tag":["Tech"],"readingTime":5},{"title":"흥미로운 Go 업데이트  v122 변경 로그와 예제들","description":"","date":"2024-06-23 21:14","slug":"2024-06-23-ExcitingGoUpdatev122ChangeLogWithExamples","content":"\n![Example](/assets/img/2024-06-23-ExcitingGoUpdatev122ChangeLogWithExamples_0.png)\n\nGo는 개발자로서 제 삶에 변화를 가져다 주었습니다. 특히 일을 간단하게 유지하는 이념이 나에게 공감됩니다.\n\n본 문서의 모든 이미지는 Percy Bolmér가 제작했습니다. 고퍼는 Takuya Ueda에 의해, 원본 고퍼는 Renée French가 제작했습니다 (CC BY 3.0).\n\nGo로 개발할 때 모든 것이 쉽고 복잡하지 않으며, 빠른 개발 속도를 유지할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n언어가 쉽다는 것 뿐만 아니라 개발 속도도 빠르고 이해하기 쉽습니다. 가비지 수집기가 있는데도 Go는 성능이 우수하다는 사실도 있습니다.\n\n그리고 이제 V1.22가 출시되면서 기다렸던 멋진 수정 사항이 포함되어 있습니다!\n\n둘러댈 필요 없이, 즉각적으로 이야기해 보죠.\n\n아직 업데이트하지 않은 경우, GoTip을 사용하여 쉽게 최신 버전으로 업데이트하세요!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\ngo install golang.org/dl/gotip@latest\ngotip download\n```\n\n## \"문제가 있는\" for 룹 수정하기 — 가장 흔한 버그 중 하나\n\n<img src=\"/assets/img/2024-06-23-ExcitingGoUpdatev122ChangeLogWithExamples_1.png\" />\n\nGo의 for 룹은 실제로는 문제가 없었습니다. 그러나 구현 방식이 많은 개발자들을 혼란스럽게 했다고 말할 수 있습니다. 이 혼란으로 인해 Go의 역사에서 많은 버그가 발생했습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n간단한 코드 스니펫을 살펴보고 예상대로 동작하지 않는 것을 볼까요?\n\n```js\npackage main\n\nimport (\n \"fmt\"\n \"time\"\n)\n\nfunc main() {\n        // A list of names to print\n       names := []string{\"Percy\", \"Gopher\", \"Santa\"}\n\n       // We will For loop over the names\n       for _, v := range names {\n          // Imagine that we have some concurrent function running here\n          // We are Printing the variable v\n          go func() {\n           fmt.Println(v)\n          }()\n       }\n\n     time.Sleep(1 * time.Second)\n}\n```\n\n리스트에 있는 세 이름이 모두 출력될 것으로 생각할 수 있지만, 코드를 면밀히 검토하고 무슨 일이 일어나고 있는지 생각해보면 그렇지 않습니다. 변수 v가 고루틴에서 참조되지만 for 루프의 각 반복마다 v가 가리키는 대상이 변경됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n간단히 말해서, for 루프가 스케줄러에서 Goroutines를 실행하도록 대기열에 넣기 때문입니다. Goroutines가 실행되기 전에 다음 반복이 진행되고 변수 v가 덮어쓰입니다.\n\nGo 1.22에서는 대신 for 루프가 변수를 다르게 처리하고 매번 덮어쓰지 않도록 합니다.\n\n대신 Go 1.22에서 동일한 코드를 실행하면 모든 이름을 출력할 것입니다.\n\n```js\n$: go run main.go\nSanta\nPercy\nGopher\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n프로그램 간의 호환성을 보장하기 위해 Go 팀은 v1.21 이전 버전을 사용하는 프로젝트가 1.22 이상을 사용하는 코드를 컴파일하지 않도록 조치했습니다.\n\n이 변경 사항은 주요 사항이며 많은 버그를 방지할 것입니다.\n\n# 표준 라이브러리에서 더 나은 HTTP 라우팅\n\n![이미지](/assets/img/2024-06-23-ExcitingGoUpdatev122ChangeLogWithExamples_3.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nGo 언어에서는 표준 라이브러리가 많이 지원되어 있습니다. 대부분의 경우에는 그것이 사실이라고 느낍니다. 그러나 HTTP 라이브러리는 라우팅 패턴 및 메서드 선언을 처리하기 위한 내장 기능 부족으로 인해 종종 대체됩니다.\n\n즉, http.ServeMux는 매개변수 없이 일반 경로를 받아들이며 허용된 HTTP 메서드만 처리한다는 것을 의미합니다.\n\n이러한 사항을 처리하는 구 방식과 신 방식 간의 차이점을 살펴봅시다.\n\n## 메서드별 라우팅\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음은 HTTP GET 방식만 허용하는 HTTP 엔드포인트 예제입니다.\n\n```go\npackage main\n\nimport (\n    \"net/http\"\n)\n\nfunc main() {\n    mux := http.NewServeMux()\n\n    mux.HandleFunc(\"/hello\", func(w http.ResponseWriter, r *http.Request) {\n        if r.Method != http.MethodGet {\n            // 만약 요청이 GET 방식이 아닌 경우 'Method Not Allowed' 응답을 작성합니다.\n            w.WriteHeader(http.StatusMethodNotAllowed)\n            w.Write([]byte(\"\"))\n            return\n        }\n\n        w.Write([]byte(`Hello`))\n    })\n\n    if err := http.ListenAndServe(\":8000\", mux); err != nil {\n        panic(err)\n    }\n}\n```\n\n아직 HTTP 엔드포인트를 설정하는 데 필요한 코드는 매우 적지만, 엔드포인트에서 GET 요청만 허용하게끔 구성된 코드입니다.\n\n작동 여부를 확인하기 위해 curl 요청을 엔드포인트에 보내 보세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\ncurl -v -X POST localhost:8000/hello\n* 127.0.0.1:8000를 시도 중...\n* localhost (127.0.0.1) 포트 8000에 연결되었습니다 (#0)\n> POST /old-hello HTTP/1.1\n> Host: localhost:8000\n> User-Agent: curl/7.81.0\n> Accept: */*\n>\n* 번들을 다중 사용을 지원하지 않도록 표시\n< HTTP/1.1 405 Method Not Allowed\n< Date: Sun, 28 Jan 2024 15:03:01 GMT\n< Content-Length: 0\n<\n* 호스트 localhost로 연결 #0 종료\n```\n\nGo 1.22에서 ServeMux가 변경되어 라우트 경로 내에서 메서드 선언을 허용합니다.\n\n즉, GET /hello와 같이 라우트를 설정할 수 있고, 자동으로 GET 요청만 수락하고 그렇지 않으면 HTTP 405를 반환할 수 있습니다.\n\n```go\npackage main\n\nimport (\n \"net/http\"\n)\n\nfunc main() {\n mux := http.NewServeMux()\n\n mux.HandleFunc(\"GET /hello\", func(w http.ResponseWriter, r *http.Request) {\n  w.Write([]byte(`Hello`))\n })\n\n if err := http.ListenAndServe(\":8000\", mux); err != nil {\n  panic(err)\n }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n훨씬 나아지고 부드러워졌네요. GET POST /hello를 사용할 수 없습니다. 이전의 CURL 명령어를 실행하면 동일한 동작을 할 것입니다.\n\n## 패턴 내 와일드카드\n\n새로운 라우팅 규칙을 통해 URL 경로에서 매개변수를 받을 수 있게 되었습니다. 경로 매개변수는 흔하지 않습니다. 그러나 그것을 지원하지 않았다는 사실은 많은 사람들이 Gorilla나 다른 라이브러리를 사용하는 큰 이유 중 하나였습니다.\n\n경로 매개변수는 요청에서 값이 예상되는 URL의 일부 또는 섹션입니다. 가령 사용자들이 인사를 하기 위해 이름을 추가할 수 있게 하고 싶다고 가정해보죠. 그렇다면 요청은 /hello/$이름 형태가 될 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이전 방식으로는 이렇게 관리되었습니다.\n\n```js\npackage main\n\nimport (\n \"net/http\"\n \"fmt\"\n \"strings\"\n)\n\nfunc main() {\n mux := http.NewServeMux()\n\n mux.HandleFunc(\"/hello/\", func(w http.ResponseWriter, r *http.Request) {\n  // Request URL 가져오기\n  path := r.URL.Path\n  // 각 섹션을 가져오려면 /로 분할\n  parts := strings.Split(path, \"/\")\n  // 실제로 설정된 이름이 있는 요청만 허용\n  if len(parts) < 3 {\n   http.Error(w, \"유효하지 않은 요청\", http.StatusBadRequest)\n   return\n  }\n  // 이름 가져오기\n  name := parts[2]\n\n  w.Write([]byte(fmt.Sprintf(\"안녕 %s!\", name)))\n })\n\n if err := http.ListenAndServe(\":8000\", mux); err != nil {\n  panic(err)\n }\n}\n```\n\n보시다시피, 이것은 꽤 지저분한데요. 그리고 이것은 단지 하나의 변수에 대한 내용입니다.\n\n새 ServeMux를 사용하면 매개변수를 이름으로 지정할 수 있습니다. '로 묶어 매개변수를 추가할 수 있기 때문에 경로를 /hello/'name'으로 설정할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n파라미터를 가져오려면, HTTP 요청에 PathValue라는 함수가 포함되어 있어야 합니다. 이 함수는 가져올 파라미터의 이름을 인수로 받습니다.\n\n이것이 새로운 경로 변수 사용 방법입니다.\n\n```js\npackage main\n\nimport (\n \"net/http\"\n \"fmt\"\n)\n\nfunc main() {\n mux := http.NewServeMux()\n\n mux.HandleFunc(\"GET /hello/{name}\", func(w http.ResponseWriter, r *http.Request) {\n  name := r.PathValue(\"name\")\n  w.Write([]byte(fmt.Sprintf(\"Hello %s!\", name)))\n })\n\n if err := http.ListenAndServe(\":8000\", mux); err != nil {\n  panic(err)\n }\n}\n```\n\n우리는 이름이 있는지 검증할 필요가 없습니다. 파라미터 없이 요청을 보내면 HTTP 404 Not Found를 반환하는 것을 확인할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n로컬호스트:8080/hello/percy으로 curl 명령어를 실행해보세요. 멋진 메시지가 출력될 거에요.\n\n로컬호스트:8080/hello/percy/123으로 curl 명령어를 실행해보면 실패하는 걸 확인할 수 있어요. 동적 경로를 허용하고 파라미터를 사용해야 할 경우도 있을 수 있어요. 이 문제를 해결하기 위해선 '' 뒤에 ....을 붙여주세요. 세 개의 점을 추가하면 해당 매개변수 뒤의 모든 세그먼트와 일치하도록 패턴 매칭이 됩니다.\n\n```js\n mux.HandleFunc(\"GET /hello/{name...}\", func(w http.ResponseWriter, r *http.Request) {\n  name := r.PathValue(\"name\")\n  w.Write([]byte(fmt.Sprintf(\"Hello %s!\", name)))\n })\n```\n\n이를 통해 동적 요청을 파라미터로 전달할 수 있어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 정확한 패턴 매칭과 슬래시 후행\n\n이 부분은 전에 몰랐던 부분인데, HTTP mux는 올바른 prefix를 가진 모든 라우트와 일치합니다. 즉, 라우트가 hello/라면 hello/로 시작하는 모든 경로에 대한 요청이 일치합니다. 여기서 중요한 점은 경로 끝에 있는 /로, 이것은 항상 ServeMux에게 이후의 모든 접두사와 일치시키도록 알려주었습니다.\n\n```js\npackage main\n\nimport (\n  \"net/http\"\n)\n\nfunc main() {\n  mux := http.NewServeMux()\n\n  mux.HandleFunc(\"GET /hello/\", func(w http.ResponseWriter, r *http.Request) {\n    w.Write([]byte(`Hello`))\n  })\n\n  if err := http.ListenAndServe(\":8000\", mux); err != nil {\n    panic(err)\n  }\n}\n```\n\n위 코드를 실행하면 쉽게 테스트해볼 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n로컬호스트:8080/hello/percy로 CURL을 보내면 로컬호스트:8080/hello와 동일한 결과를 반환합니다.\n\n만약 정확한 일치만 허용하고 싶다면 어떨까요? 이제 루트 끝에 '$'를 사용하여 이를 수행할 수 있습니다. 이것은 Servemux에 정확한 일치만 경로로 라우팅하도록 지시합니다.\n\n수정된 루트를 업데이트하고 프로그램을 다시 시작한 후에는 이제 로컬호스트:8080/hello/로만 요청을 보낼 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 갈등 해결과 우선순위\n\n이러한 새로운 규칙들이 허용되면서 새로운 문제가 발생했습니다. 한 요청이 두 개의 라우트와 일치할 수 있습니다.\n\n가장 구체적인 라우트가 항상 선택되도록하여 이 문제를 해결했습니다.\n\n```js\nhttp.HandleFunc(\"/hello/\", helloHandler); // 덜 구체적\nhttp.HandleFunc(\"/hello/{name}\", helloHandler); // 더 구체적\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n나는 이 방법을 좋아한다. 왜냐하면 아주 많은 의미가 있다고 느껴지기 때문이야.\n\n## 주목할 만한 부분\n\n더 많은 것들이 바뀌지만, 별도의 챕터를 할만한 가치가 있다고 생각하지 않아. 대신 이곳에 변화에 대한 아주 간단한 요약이 있어.\n\n- Go의 첫 번째 V2 패키지 — math/rand/v2. Rand가 V2를 받았는데, Read 메소드가 제거되었고, 패키지 전체에서 빠른 알고리즘으로 변경되었다. 새로운 rand.N 함수는 일반적인 매개변수를 허용하여 무작위로 값을 얻을 수 있으며, 기간과 함께 작동한다.\n- Slog은 더 쉽게 로그 레벨을 제어할 수 있는 SetLogLoggerLevel을 새롭게 받았어.\n- slices는 슬라이스를 병합하는 새로운 Concat 함수를 받았어. Delete와 같이 크기를 줄이는 slice 패키지의 모든 함수는 이제 요소를 자동으로 Zero화할 것이야.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 결론\n\n이번 Go의 최신 릴리스에서 언급할 가치가 있는 변경 사항들입니다.\n\nHTTP 라우팅에 대한 변경 사항에 대해 저만큼 흥분하시기를 바라며, 새로운 HTMX 앱을 구축하고 이를 위해 STD 라이브러리 라우터를 사용하는 것을 테스트해 보는 것을 기대할 수 없어요!\n\n마지막으로, 많은 버그를 일으키는 그 지겹고도 신랄한 행동 이제는 영원히 해결될 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이미 최신 버전으로 업데이트를 하지 않았다면 꼭 업데이트해 주세요!\n\n가장 기대되는 변경 사항은 무엇인가요?\n\nGo에서 가장 그리워하는 기능은 무엇인가요?\n\n의견을 자유롭게 남겨주세요. 댓글이나 제 다른 소셜 플랫폼에서도 연락 가능합니다!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 부록\n\nGo 벤치마크 — [여기](https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/go.html)\n\n가비지 컬렉터 — [여기](<https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)>)\n\nGo 변경 로그 — [여기](https://tip.golang.org/doc/go1.22)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 상세 정보입니다:\n\n- **Let's Encrypt 인증 폐기**: [여기](https://community.letsencrypt.org/t/revoking-certain-certificates-on-march-4/114864)를 클릭하여 더 많은 정보를 확인하세요.\n- **Go playground**: [여기](https://go.dev/play/p/LkgkmFMoqTS)에 방문하면 Go 언어를 더 재미있게 배울 수 있습니다.\n- **GoTip**: [여기](https://pkg.go.dev/golang.org/dl/gotip)를 클릭하면 유용한 GoTip 패키지를 찾을 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-06-23-ExcitingGoUpdatev122ChangeLogWithExamples_0.png"},"coverImage":"/assets/img/2024-06-23-ExcitingGoUpdatev122ChangeLogWithExamples_0.png","tag":["Tech"],"readingTime":14},{"title":"React 초보자를 위한 필수 인터뷰 질문 10가지","description":"","date":"2024-06-23 21:12","slug":"2024-06-23-ReactInterviewQuestionsBeginnerlevel","content":"\n아래는 다음 면접에서 만날 수 있는 초보자 수준의 React 인터뷰 질문 몇 가지입니다. 행운을 빕니다, 이 자료가 면접 준비에 도움이 되기를 바랍니다.\n\n# React란 무엇인가요?\n\nReact는 사용자 인터페이스를 구축하기 위한 JavaScript 라이브러리로, 컴포넌트 기반 아키텍처에 초점을 맞추고 성능을 위한 가상 DOM, 렌더링을 위한 JSX 구문 및 일방향 데이터 흐름을 제공합니다. 효율적인 대화형 웹 애플리케이션을 만드는 데 널리 사용됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n웹 및 모바일 앱의 뷰 레이어를 구성 요소 기반의 선언적 방식으로 처리하는 데 사용됩니다.\n\n## 리액트의 주요 특징은 무엇인가요?\n\n- 컴포넌트 기반 아키텍처.\n- 효율적 렌더링을 위한 가상 DOM.\n- 선언적 UI 구문을 위한 JSX.\n- 일방향 데이터 흐름.\n- 함수형 컴포넌트를 위한 Hooks.\n- Redux 및 React Router와 같은 라이브러리를 갖춘 풍부한 생태계.\n\n## JSX란 무엇인가요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nJSX는 JavaScript XML의 약자입니다. JavaScript 구문을 확장하여 개발자가 JavaScript 내에서 HTML과 유사한 코드를 작성할 수 있게 해줍니다. JSX를 사용하면 React 애플리케이션에서 DOM 구조를 생성하고 조작하는 작업이 쉬워집니다.\n\n- JavaScript와 HTML을 결합: JSX를 사용하면 JavaScript와 HTML 요소를 한 파일 내에서 함께 작성할 수 있습니다.\n- 구문 확장: React.createElement(component, props, …children) 함수 호출에 대한 구문적 설탕을 제공합니다.\n- 컴파일 시 변환: 빌드 시 Babel과 같은 도구를 사용하여 JSX 코드가 일반적인 JavaScript 객체로 변환됩니다.\n\n위 예시에서 `h1`Hello, JSX!`/h1`은 JSX 구문으로, 내부적으로 React.createElement(`h1`, null, `Hello, JSX!`)으로 변환됩니다. 이를 통해 React 애플리케이션에서 UI 구성 요소를 작성하고 시각화하는 프로세스가 간소화됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 리액트 Fragment란 무엇인가요?\n\n리액트 Fragment는 DOM에 추가적인 노드를 생성하지 않고 여러 자식 요소를 그룹화하는 방법을 제공합니다. 이를 통해 컴포넌트의 렌더 메서드에서 여러 요소를 반환할 수 있으며 `div` 또는 `span`과 같은 컨테이너 요소로 감싸지 않아도 됩니다. Fragment는 리액트 16.2에서 소요량이 적은 구문으로 요소를 그룹화하는 데 도입되었습니다.\n\n# 컴포넌트와 엘리먼트의 차이는 무엇인가요?\n\n- 정의: 컴포넌트는 옵션으로 입력(props)을 받아들이고 리액트 엘리먼트를 반환하는 JavaScript 함수 또는 클래스입니다.\n- 목적: 재사용 가능한 UI 조각을 정의합니다.\n- 종류: 함수를 사용하는 Functional 컴포넌트와 ES6 클래스를 사용하는 Class 컴포넌트가 있습니다.\n- 사용: 컴포넌트는 자체 상태를 관리하며 (훅 또는 클래스 컴포넌트의 setState를 사용하여) 라이프사이클을 관리합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nfunction Welcome(props) {\n  return <h1>Hello, {props.name}</h1>;\n}\n```\n\n- 정의: 엘리먼트는 리액트 컴포넌트의 일반 객체 표현입니다.\n- 목적: 화면에 표시하고 싶은 것을 설명합니다.\n- 생성 방법: JSX 구문 또는 React.createElement() 함수를 사용하여 만듭니다.\n- 불변성: 엘리먼트는 변하지 않으며 특정 시점의 UI를 나타냅니다.\n\n```js\nconst element = <h1>Hello, world!</h1>;\n```\n\n# 리액트에서 key란 무엇인가요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nReact.js에서 key 속성은 각 요소나 컴포넌트에 고유한 식별자를 제공하는 특별한 속성입니다. 배열이나 반복 가능한 자식 목록에서 각 요소나 컴포넌트에 고유한 식별자를 제공하는 특별한 속성입니다. 이는 React가 내부적으로 구성 요소의 UI를 효율적으로 관리하고 업데이트하는 데 사용됩니다. 목록에 항목이 추가, 제거 또는 재배열 될 때.\n\nkey의 목적:\n\n요소 식별: 배열에서 여러 요소를 렌더링하거나 구성 요소를 반복하는 경우 React는 항목 간 차이를 파악하기 위해 키를 사용합니다. 이를 통해 React는 변경된 항목, 추가된 항목 또는 제거된 항목을 결정할 수 있습니다.\n\n조정 최적화: React는 조정 프로세스(차이 알고리즘) 중에 키를 사용하여 DOM 업데이트를 최소화합니다. 각 항목에 안정적인 식별자가 있기 때문에 React는 UI를 효율적으로 업데이트할 수 있으며 변경되지 않은 구성 요소를 다시 렌더링하지 않거나 구성 요소 상태를 잃지 않고 업데이트할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# React에서의 '상태'란 무엇인가요?\n\nReact에서 '상태'는 컴포넌트가 내부 데이터를 추적할 수 있도록 하는 내장 객체입니다. 이는 컴포넌트의 렌더링과 동작에 영향을 주는 변할 수 있는 데이터를 나타냅니다. 중요한 점은 상태 객체가 변경될 때마다 컴포넌트가 다시 렌더링된다는 것입니다.\n\n# React에서 '속성'이란 무엇인가요?\n\nReact에서 '속성' (속성의 약어)은 한 컴포넌트에서 다른 컴포넌트로 데이터를 전달하는 방법입니다. 이는 JavaScript의 함수 인수나 다른 프로그래밍 언어의 매개변수와 유사합니다. 속성은 읽기 전용이며 컴포넌트를 보다 동적이고 재사용 가능하게 만들어 다른 값으로 구성할 수 있도록 돕습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n부모 컴포넌트에서 자식 컴포넌트로 전달되는 데이터입니다. 이들은 변경할 수 없으며(read-only), 컴포넌트를 사용자 정의하고 재사용할 수 있게 합니다.\n\n부모 컴포넌트가 자식 컴포넌트로 name 속성을 전달하는 것을 고려해보세요:\n\n```js\n// ParentComponent.jsx\nimport React from \"react\";\nimport ChildComponent from \"./ChildComponent\";\n\nfunction ParentComponent() {\n  const name = \"Alice\";\n\n  return (\n    <div>\n      <ChildComponent name={name} />\n    </div>\n  );\n}\n\nexport default ParentComponent;\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```jsx\n// ChildComponent.jsx\nimport React from \"react\";\n\nfunction ChildComponent(props) {\n  return <p>안녕, {props.name}!</p>;\n}\n\nexport default ChildComponent;\n```\n\n- ParentComponent: ChildComponent를 렌더링하고 이름 prop에 \"Alice\" 값을 전달합니다.\n- ChildComponent: prop로 전달된 이름( `props.name` )을 받아 해당 prop을 사용하여 인사말을 표시합니다(안녕, 'props.name'!).\n\n- 이름은 ParentComponent에서 ChildComponent로 전달된 prop입니다.\n- Props를 사용하면 ParentComponent가 전달한 내용에 따라 ChildComponent가 동적으로 다른 이름을 표시할 수 있습니다.\n\n# 상태(state)와 프롭스(props)의 차이점은 무엇인가요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 컴포넌트 자체에서 내부적으로 관리됩니다.\n- 클래스 컴포넌트에서 setState() 메서드를 사용하거나 함수형 컴포넌트에서 Hooks를 사용하여 업데이트할 수 있습니다.\n- 변경사항이 컴포넌트 및 하위 컴포넌트를 다시 렌더링합니다.\n- 가변적입니다 (컴포넌트 내에서 수정 가능).\n- 내부 상태 및 시간이 지남에 따라 변경될 수 있는 데이터를 관리하는 데 사용됩니다.\n- 로컬 상태 관리와 효과적으로 사용함으로써 컴포넌트의 재사용성을 증가시킬 수 있습니다.\n\n- 상위 컴포넌트에서 하위 컴포넌트로 전달됩니다.\n- 수신 컴포넌트 내에서 읽기 전용(불변)입니다.\n- 컴포넌트를 구성하고 상위 컴포넌트로부터 데이터를 제공하기 위해 사용됩니다.\n- 컴포넌트가 다양하게 구성될 수 있어 재사용성이 향상됩니다.\n- 수신 컴포넌트에서 수정할 수 없습니다.\n- 컴포넌트 계층구조에서 데이터 및 콜백을 전달하는 데 사용됩니다.\n\n# React에서 prop drilling이란 무엇인가요?\n\nReact에서 prop drilling은 상위 수준 컴포넌트에서 하위 수준 컴포넌트로 props가 중간에 위치한 컴포넌트를 통해 전달되는 프로세스를 의미합니다. 데이터가 여러 수준의 중첩된 컴포넌트로 전달되어야 하지만 일부 중간 컴포넌트가 실제로 데이터를 사용하지 않을 때 발생합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n프롭 드릴링은 React에서 일반적으로 사용되는 패턴으로, 프롭스가 데이터가 필요한 깊게 중첩된 자식 컴포넌트에 도달하기 위해 여러 수준의 중첩된 컴포넌트를 통해 전달됩니다. 구현하기는 간단하지만 코드 복잡성과 효율성에 영향을 미칠 수 있습니다. React의 Context API나 상태 관리 라이브러리를 사용하면 복잡한 응용 프로그램에서 구성 요소 간 데이터를 관리하고 전달하는 더 깔끔한 솔루션을 제공할 수 있습니다.\n\n**에러 바운더리란 무엇인가요?**\n\n에러 바운더리는 React 컴포넌트로, 자식 컴포넌트 트리의 어디에서든 JavaScript 오류를 잡아서 해당 오류를 기록하고 전체 React 애플리케이션을 충돌하지 않게 대체 UI를 표시합니다. 렌더링 중에 또는 React 컴포넌트의 라이프사이클 메소드 및 생성자에서 발생하는 오류를 관리하고 고급스럽게 처리하는 데 사용됩니다.\n\n**제어 컴포넌트와 비제어 컴포넌트의 차이점은 무엇인가요?**\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n제어 컴포넌트와 비제어 컴포넌트는 React에서 폼 입력 요소를 관리하는 두 가지 다른 방식입니다. 이 둘의 주된 차이점은 상태를 다루고 관리하는 방식에 있습니다, 특히 폼 데이터와 관련하여.\n\n- 상태 처리: 제어 컴포넌트에서는 폼 데이터가 React 상태에 의해 처리됩니다 (일반적으로 상위 컴포넌트 내에서).\n- 데이터 흐름: 폼 입력 요소의 값 (`input`, `textarea`, `select`와 같은)은 상태에 의해 제어되며 프롭스로 컴포넌트에 전달됩니다.\n- 이벤트 처리: 폼 요소의 변경 사항은 onChange 이벤트 핸들러를 사용하여 처리되며, 상태는 각 변경 시에 업데이트됩니다.\n\n- 상태 처리: 비제어 컴포넌트는 DOM 자체를 통해 폼 데이터를 관리합니다.\n- Ref 사용: 참조 (ref)는 주로 DOM 요소에 직접 액세스하여 해당 값들을 가져오기 위해 사용됩니다.\n- 이벤트 처리: onSubmit, onClick 등의 이벤트 또는 직접 DOM 이벤트 (element.value)에 액세스하여 폼 데이터를 가져옵니다.\n\n# 가상 DOM이란 무엇인가요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n가상 DOM(Document Object Model)은 React 및 기타 가상 DOM 기반 라이브러리에서 사용되는 개념으로, 실제 DOM 트리의 가벼운 복사본을 나타냅니다. 이는 효율적으로 UI를 업데이트하기 위해 사용되는 프로그래밍 개념 및 추상화 계층입니다.\n\n- 정의: 가상 DOM은 React에 의해 생성된 실제 DOM 요소 및 속성(속성, 스타일 등)의 JavaScript 표현입니다.\n- 목적: UI의 중간 표현으로 사용됩니다. React 구성 요소의 상태나 속성이 변경될 때, React는 실제 DOM이 아닌 가상 DOM을 먼저 업데이트합니다.\n- 작동 원리: React는 현재 가상 DOM과 이전 버전을 비교하여 변경된 내용을 식별합니다(조정 프로세스). 이 비교는 실제 브라우저 DOM과 직접 상호 작용하는 것보다 가상 DOM을 조작하는 것이 빠르기 때문에 효율적입니다.\n- 효율성: React가 차이점을 식별하면(차별화 알고리즘), 변경된 실제 DOM의 부분만 업데이트합니다. 이렇게 하면 비용이 많이 드는 DOM 조작 작업을 최소화하고 성능을 향상시킬 수 있습니다.\n- 예시: 상태를 업데이트하는 React 구성 요소가 있다고 가정해 보겠습니다. React는 가상 DOM을 먼저 업데이트하고, 이전 가상 DOM 상태와 비교한 다음 실제 DOM에 필요한 변경 사항을 적용합니다.\n\n이 면접 질문들이 유익하게 느껴지고 효과적으로 준비하는 데 도움이 되었으면 좋겠습니다! 지금 당장 필요하진 않더라도 북마크해 두시고 자유롭게 사용하세요. 앞으로 있을 면접에서 행운을 빕니다!\n\n더 많은 흥미로운 게시물을 보려면 저를 팔로우해주세요. 제 글쓰기 열정을 키우는 데 도움이 됩니다!\n","ogImage":{"url":"/assets/img/2024-06-23-ReactInterviewQuestionsBeginnerlevel_0.png"},"coverImage":"/assets/img/2024-06-23-ReactInterviewQuestionsBeginnerlevel_0.png","tag":["Tech"],"readingTime":10},{"title":"Go EP11 Go 명령어 - go get, go mod tidy 등 완벽 가이드","description":"","date":"2024-06-23 21:10","slug":"2024-06-23-GOEP11GoCommands-gogetgomodtidyetc","content":"\n<img src=\"/assets/img/2024-06-23-GOEP11GoCommands-gogetgomodtidyetc_0.png\" />\n\n안녕하세요! 이번 토론은 특히 go.mod 파일을 중심으로 Go 모듈에 관한 내용을 다룹니다. 또한 두 모듈이 같은 종속성을 가지고 있지만 다른 버전을 사용할 때 Go가 어떻게 종속성을 해결하는지에 대해서도 살펴봅니다.\n\n이전 섹션의 내용을 이어서, go install, go mod와 go get, go install 사이의 차이 등 다른 Go 명령에 대해서도 이야기합니다.\n\n만약 GOROOT, GOPATH, GOCACHE와 같은 환경 변수 뿐만 아니라 빌드 이미지 파이프라인을 가속화하는 방법과 같은 기초적인 Go 환경에 관한 이전 섹션을 읽지 않았다면, 아래 링크를 확인해보세요: GO EP10: GOROOT, GOPATH, GOCACHE\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nGo 1.11에서 소개된 모듈 인식 모드에 대해 이야기할 예정이에요. Go 1.13부터는 기본적으로 활성화되는데, 이 모드를 사용하여 프로젝트의 종속성을 관리하는 방법도 함께 알아볼 거에요.\n\n모듈 인식 모드는 Go 명령어를 사용하여 종속성을 관리할 수 있는 기능이에요. 다시 말해, go build, go test, go get 등의 명령어는 모듈의 context 내에서 작동하여 go.mod 파일에 지정된 버전에 따라 모든 종속성이 해결되도록 합니다.\n\n그리고, 이 모드는 go.sum 파일을 도입하는데요. 이 파일은 모듈의 종속성의 체크섬을 포함하여 무결성을 확인하고 변조를 방지합니다. 다음 이야기에서 더 자세히 다루겠어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# go.mod이란 무엇인가요?\n\ngo.mod 파일 또는 go 모듈은 기본적으로 여러 개의 Go 패키지를 구성하고 관리하는 방법입니다.\n\n이러한 패키지들은 단일 단위로 버전이 지정되어 릴리스되며 배포됩니다. 이러한 모듈은 GitHub과 같은 저장소 또는 전용 모듈 프록시 서버에서 패치하는 것이 익숙할 것입니다.\n\n사람들은 종종 이를 \"패키지\"라고 부르지만, 기술적으로는 \"모듈\"에 더 가깝습니다. 그래서 패키지를 패치한다고 할 때, 실제로 전체 모듈을 패치하는 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\ngo.mod 파일은 무엇을 하는 파일인가요?\n\n모듈 자체를 정의하는 파일입니다. 모듈의 이름, 사용하는 Go 버전, 필요한 종속성(직접 또는 간접적으로) 등을 알려줍니다.\n\n모듈 이름은 모듈의 import 경로에 해당합니다. 해당 모듈에서 패키지를 사용하려면 모듈 이름을 접두사로 붙여서 가져와야 합니다.\n\n```js\n# go.mod\nmodule thisismodulename\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n// 이 모듈에서 패키지를 가져옵니다\nimport \"thisismodulename/any/package\";\n```\n\n현재 디렉토리에 모듈을 만들거나 초기화하려면 `module-name` 명령어로 go mod init을 사용할 수 있습니다. 물론, 디렉토리가 이전에 모듈이 아니어야 합니다.\n\n이것은 모두 기본적인 내용입니다. 이제 이 기능에 대한 자세한 내용을 살펴보겠습니다.\n\n# go get: 의존성 관리 (빌드하지 않고 설치하지 않음)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nGo에서의 go get 명령은 주 모듈의 go.mod 파일에 있는 모듈 종속성을 업데이트하는 데 사용됩니다. 또한 명령줄에 지정한 패키지를 빌드하고 설치하는 데도 사용됩니다.\n\ngo get을 실행하면 어떤 것을 업데이트할지를 사용자가 지정한 내용에 기반하여 결정합니다. 이를 하는 몇 가지 방법이 있습니다: 패키지(예: github.com/user/project/package), 모듈 경로(github.com/user/project)를 지정하거나 .과 같은 패턴을 사용할 수도 있습니다.\n\n네, go get을 그냥 실행하면 현재 디렉토리 (\".\")를 지정한 것처럼 동작합니다. 현재 디렉토리에서만 모든 가져오기된 패키지의 누락된 모듈을 업데이트합니다. 많은 사람들은 이 작업을 위해 go get ./... 또는 go mod tidy를 사용합니다.\n\ngo get ./...를 사용하면 패턴은 ./...이며 이는 모든 하위 디렉토리를 나타냅니다. 이 쿼리는 이를 와일드카드 패턴으로 인식하고 현재 디렉토리 및 그 하위 디렉토리에 있는 모든 패키지로 해석합니다. 당연히 주 모듈 내에서 이루어집니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## go get 작동 방식\n\ngo get을 실행하면 처음으로 업데이트해야 할 모듈을 결정합니다. 모듈, 패키지 또는 경로 패턴의 목록을 인수로 제공합니다.\n\n각 인수는 버전 쿼리 접미사를 포함할 수 있으며, 이 멋진 용어는 @ 기호 다음에 원하는 버전을 추가할 수 있다는 것을 의미합니다:\n\n- 특정 버전 @v1.2.3: 해당 정확한 버전 사용.\n- 버전 접두사 @v1.2: 해당 접두사로 시작하는 최신 버전을 가져옵니다.\n- 브랜치 @main 또는 태그 @v1.2.3: 해당 브랜치나 태그의 최신 버전을 가리킵니다.\n- 커밋 해시 또는 리비전 @abcdef: 해당 특정 커밋 사용.\n- 최신 버전 @latest 또는 최신 패치 버전 @patch: 가장 최신 버전 또는 패치를 가져옵니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n한번 go get이 당신이 제공한 인수를 기반으로 사용할 모듈 및 버전을 찾아내면, 당신의 프로젝트의 go.mod 파일을 업데이트하여 의존성에 대한 최소 요구 버전을 추적합니다. 새로운 의존성이 더 높은 버전이 필요한 경우, go get은 또한 이를 반영하도록 자동으로 go.mod 파일을 업데이트합니다.\n\n그런데, 만약 A와 B 두 의존성이 있고, 두 모듈이 같은 C 모듈을 다른 버전으로 사용하는 경우는 어떻게 처리할까요?\n\n## Go가 의존성 해결하는 방법\n\nGo는 의존성을 처리하고 버전 충돌을 해결하기 위해 Minimal Version Selection (MVS)라는 것을 사용합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nMVS는 복잡해 보이지만, 이해하기 쉽게 말하면 다른 모듈에서 모든 요구 사항을 충족하는 각 모듈의 가장 낮은 버전을 선택합니다. 이 방법을 통해 의존성을 가능한 한 최소화하면서 관련된 모든 것의 요구 사항을 충족시킵니다.\n\n예를 들어, 세 개의 모듈 A, B 및 C가 있다고 가정해 봅시다.\n\n- 모듈 A@1.3.2와 모듈 B@1.0.0은 둘 다 모듈 C에 의존합니다.\n- 그러나 A는 C@2.3.2가 필요하고, B는 C@2.3.0이 필요합니다.\n- C에는 2.4.1이라는 더 새로운 버전도 있습니다.\n\nGo는 C의 어떤 버전을 사용할지 어떻게 결정할까요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지1](/assets/img/2024-06-23-GOEP11GoCommands-gogetgomodtidyetc_1.png)\n\nMVS는 모듈 A와 B에서 모듈 C의 모든 요구 사항을 확인합니다. A는 C 버전 2.3.2를 필요로 하고, B는 C 버전 2.3.0을 필요로 합니다. MVS는 이러한 요구 사항을 모두 충족하는 가장 낮은 C 버전을 선택합니다.\n\n이 경우, 2.3.0과 2.3.2를 모두 충족하는 가장 작은 버전은 2.3.2입니다. C를 2.4.1로 선택하는 것은 가장 낮은 버전이 아니므로 2.3.2를 선택합니다.\n\n![이미지2](/assets/img/2024-06-23-GOEP11GoCommands-gogetgomodtidyetc_2.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n호환성은 Go 모듈이 사용하는 Semantic Versioning (semver)으로 관리됩니다.\n\n만약 모듈이 semver을 따른다면, 어떤 중요한 변경 사항이 있을 때는 major 버전을 올려야 합니다 (major.minor.patch). 2.3.0 버전과 2.3.2 버전은 둘 다 같은 major 버전 (2.3.x)을 가지고 있으므로 두 버전은 서로 하위 호환성을 유지해야 합니다.\n\n다른 버전들이 호환되도록 유지되는 것은 모듈 작성자의 책임입니다.\n\n모듈이 major 버전 2 이상이 되면, 경로에 major 버전 번호가 포함됩니다 (예: /v2 또는 /v3):\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\ngithub.com / user / project / v2;\ngithub.com / user / project / v3;\n```\n\n다른 메이저 버전을 가진 모듈은 별개의 모듈로 처리됩니다. 그래서 동일한 프로젝트에서 C@2.3.2와 C@3.0.0을 함께 사용할 수 있습니다.\n\n예를 들면, 당신의 go.mod 파일은 다음과 같을 수 있습니다:\n\n```js\nmodule yourproject\n\nrequire (\n    github.com/user/A v1.0.0\n    github.com/user/B v1.0.0\n)\nrequire (\n    github.com/user/C/v2 v2.3.2 // indirect\n    github.com/user/C/v3 v3.0.0 // indirect\n)\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n// 간접 코멘트는 프로젝트가 C 모듈을 직접적으로 가져오지 않는다는 것을 의미합니다. A 또는 B가 필요하기 때문에 그 모듈이 존재합니다.\n\n한 가지 작은 점: go get은 업데이트하거나 누락된 테스트 종속성을 추가하지 않습니다. 이를 포함하려면 -t 플래그를 사용하십시오. 예를 들어 go get -t ./...\n\n다양한 상황에서 go get이 작동하는 방법을 보는 몇 가지 예제를 살펴봅시다.\n\n## go get .\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n`go get .`이나 `go get ./...`을 사용하면 현재 디렉토리나 하위 디렉토리에 있는 모든 누락된 종속성을 찾아 go.mod 파일에 추가합니다.\n\n여기서 핵심은 \"누락된\"입니다.\n\n즉, 이미 명시되지 않은 종속성을 확인하고 추가합니다. 최신 버전으로 기존 종속성을 업데이트하지는 않습니다. 단, 다음 예제처럼 -u 플래그와 함께 명시적으로 요청하지 않는 한.\n\n## go get -u .\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n`go get .` 명령에 `-u` 플래그를 사용하면 현재 디렉토리에서 기존 종속성을 가장 최신의 마이너 또는 패치 버전으로 업데이트합니다. 기억해 주세요, 새로운 주 버전으로는 업데이트되지 않는다는 것을 주의하세요. 왜냐하면 이것은 다른 모듈로 취급됩니다.\n\n메인 모듈의 모든 종속성을 최신 버전으로 업데이트하려면 `go get -u ./...`을 사용할 수 있습니다.\n\n대부분의 경우에는 `-u` 플래그를 명시적으로 지정하지 않아도, 종속성이 오래되었거나 누락된 경우 go get이 여전히 업데이트할 수 있습니다.\n\n## go get github.com/user/project\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 명령은 모듈 github.com/user/project을 다운로드하고 go.mod 파일에 추가합니다. 이미 명시된 경우, 최신 소규모 또는 패치 버전으로 모듈을 업데이트합니다.\n\n기본적으로 버전을 지정하지 않거나 (또는 버전 쿼리 접미사를 지정하지 않는 경우) 최신 버전으로 업그레이드하려고 한다고 가정하며, 마치 go get github.com/user/project@upgrade를 사용하는 것과 같습니다.\n\ngo get github.com/user/project/package\n\n패키지 자체가 모듈이 아닌 경우에도 go get은 해당 패키지를 제공하는 모듈을 업데이트합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n`go get github.com/user/project`을 입력하면 github.com/user/project에서 패키지를 가져옵니다. 숨겨진 `@upgrade` 동작을 사용하여 패키지를 포함하는 모듈의 최신 버전을 가져옵니다.\n\n## go get github.com/user/project@v1.2.3\n\n이 명령어는 모듈을 지정된 버전인 v1.2.3으로 업데이트합니다. 현재 버전에 따라 해당 버전과 일치하도록 모듈을 업그레이드하거나 다운그레이드할 수 있습니다.\n\n# go install: 패키지 빌드 및 설치\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n패키지를 빌드하고 설치하는 것은 무엇을 의미할까요?\n\n프로젝트에서 소스 코드를 사용하기 위해 종속성을 다운로드하는 것과는 달리, go install은 종속성의 소스 코드를 이진 파일로 빌드하고 $GOPATH/bin 디렉토리로 이동시켜 설치합니다. 이렇게 하면 터미널에서 사용할 수 있게 됩니다.\n\n```js\n$ go install golang.org/x/tools/gopls@latest\n```\n\n이 명령을 실행하고 $GOBIN 폴더를 확인하면, gopls라는 실행 파일이 있을 것입니다. 그리고 $GOBIN이 $PATH에 있는 경우 터미널에서 gopls를 실행할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n$ gopls 버전\ngolang.org/x/tools/gopls v0.15.3\n```\n\nGo install 명령어는 누락된 종속성을 다운로드하고 현재 디렉토리에 있는 현재 모듈을 빌드합니다.\n\n따라서 일부 사람들이 go install을 종속성을 관리하기 위해 사용하는 실수를 할 수 있습니다. 종속성을 다운로드하긴 하지만, 그것이 주요 역할은 아니며, 실제로 프로젝트를 빌드하고 생성된 이진 파일을 $GOBIN 디렉토리에 설치하는 것이 목적입니다.\n\n그래서 go install과 go get의 차이점은 무엇인가요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\ngo install은 패키지를 빌드하고 설치하는 데 사용되고, go get은 종속성을 관리하는 데 사용됩니다. 예전 Go 버전에서는 go get이 go.mod 파일을 업데이트한 후 패키지를 빌드하고 $GOPATH/bin에 설치했던 것으로 혼란스러운 경우가 많습니다.\n\n하지만 Go 1.16부터는 go install이 빌드 및 설치에 사용되는 주요 명령어가 되었고, go get은 go.mod 파일에서 요구 사항을 관리하는 데 집중하게 되었습니다.\n\n# go mod\n\ngo mod 명령어 패밀리는 주 모듈과 그 종속성을 관리하는 데 사용됩니다. 이러한 명령어는 프로젝트의 go.mod 파일을 만들고 편집하며 유지하는 데 도움이 됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## go mod init\n\n이름에서 알 수 있듯이 이 명령은 현재 디렉토리에 모듈을 초기화합니다.\n\n```js\ngo mod init github.com/user/project\n```\n\n이 명령을 실행한 후에는 현재 디렉토리에 go.mod 파일이 생성되고 그 외에는 할 일이 없습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n작은 것 하나만 바꿔드릴게요! 모듈 이름이나 경로는 선택 사항이에요. Go는 기존 코드, 구성 파일 또는 현재 디렉토리 구조를 기반으로 자주 이를 알아낼 수 있어요:\n\n## go mod tidy\n\n`go mod tidy`는 실제로 Go에서 가장 유용한 명령 중 하나에요. 이 명령은 프로젝트 내의 모든 패키지와 이들의 종속성을 확인하여 `go.mod` 파일을 정리하고 최적화할 수 있어요.\n\n이것은 어떻게 작동하나요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 모든 빌드 태그가 활성화된 것처럼 메인 모듈 및 해당 종속 항목의 모든 패키지를 재귀적으로 확인합니다 (// +build ignore를 제외하고).\n- 메인 모듈의 패키지에서 사용하는 모든 모듈이 go.mod 파일에 명시되어 있는지 확인합니다. 모듈이 명시되어 있지 않으면 최신 버전을 찾아 다운로드합니다.\n- 실제로 메인 모듈이나 해당 종속 항목에서 사용되지 않는 종속 항목을 제거합니다.\n- 메인 모듈에 의해 간접적으로 사용되는 모든 추이적 종속 항목을 추가하며, // indirect로 표시합니다.\n\n추이 종속성은 코드에서 직접적으로 사용되지는 않지만 의존하는 다른 모듈이 필요로 하는 것을 의미합니다.\n\ngo get과 달리 go mod tidy는 종속성을 최신 버전으로 업데이트하지 않습니다 (이를 위해서는 -u 플래그가 필요할 수 있습니다), 하지만 go.mod 파일에 테스트 종속성을 포함합니다.\n\n## go mod download\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n$GOPATH/pkg/mod 디렉토리에 대해 읽어보셨다면, go mod download은 go.mod 파일에 나열된 모든 종속성(직접 및 간접)을 다운로드하여 이 캐시를 채우는 명령어입니다.\n\ngo mod tidy가 하는 것처럼 소스 코드를 살펴볼 필요가 없습니다. 그냥 go.mod 파일을 읽고 모든 것을 다운로드합니다.\n\n이것이 왜 Dockerfile에서 종속성을 캐시하고 프로젝트를 빌드하기 전에 사용되는 이유입니다. 단순히 go.mod 파일만 있으면 go mod download가 필요한 모든 것을 다운로드해 줍니다.\n\n## go mod why\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만약 go.mod 파일에 패키지가 있는 이유를 궁금해 한다면, go mod why 명령어를 사용하여 알 수 있어요.\n\n```js\n$ go mod why github.com/user/project\n\n# github.com/user/project\nmyproject/module/logic\ngithub.com/user/anotherproject\ngithub.com/user/project\n```\n\ngo mod why 명령어는 주요 모듈에서 해당 패키지까지의 가장 짧은 경로를 보여줍니다.\n\n이 예제에서 myproject/module/logic은 주요 모듈에서 가져오는 패키지로, github.com/user/anotherproject를 가져오고, 여기서 github.com/user/project를 가져옵니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\ngo mod 패밀리에 다른 명령어도 있지만 자주 사용되지는 않아요. 그래서 그냥 간략하게 살펴볼게요.\n\n### go mod edit\n\n보통은 go.mod 파일을 직접 편집하지만, go mod edit은 수동 편집 없이 go.mod 파일에 변경을 가해야 하는 도구나 스크립트에 유용해요.\n\n### go mod graph\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n`go mod graph` 명령어를 사용하면 프로젝트의 의존성을 이해할 수 있습니다. 해당 명령어는 모듈 요구 사항 그래프를 출력합니다. 각 모듈 버전이 어떻게 해당 모듈이 의존하는 모듈의 버전과 연결되어 있는지 보여줍니다.\n\n“그래프”라고 불리지만 현재는 시각적 그래프가 아니라 각 모듈과 해당 모듈의 의존성 목록입니다.\n\n## go mod vendor\n\n다음에 판매자에 대해 자세히 알아보겠지만, 여기에 간단한 개요가 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n인터넷에서 종속성을 다운로드하고 $GOPATH/pkg/mod에 캐시하는 대신에, go mod vendor를 사용하면 종속성을 다운로드하여 프로젝트의 루트 폴더에 바로 저장할 수 있습니다. 이렇게 하면 프로젝트를 더 이동하기 쉽게 만들 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-06-23-GOEP11GoCommands-gogetgomodtidyetc_0.png"},"coverImage":"/assets/img/2024-06-23-GOEP11GoCommands-gogetgomodtidyetc_0.png","tag":["Tech"],"readingTime":17},{"title":"소프트웨어 엔지니어링을 즐기고 사용자에게 다가가는 방법 3가지","description":"","date":"2024-06-23 21:08","slug":"2024-06-23-HowToStartToLikeUsersAndEnjoySoftwareEngineering","content":"\n<img src=\"/assets/img/2024-06-23-HowToStartToLikeUsersAndEnjoySoftwareEngineering_0.png\" />\n\n# 어떤 사람들에게는 소프트웨어 엔지니어링이 코드에 관한 것이지만, 저에게는 소프트웨어 엔지니어링은 사람들에 관한 것입니다. 여기에 저는 그렇게 좋아하는 이유가 있어요\n\n안녕하세요! 제 다음 글을 쓰려면 회원 9명이 더 필요하답니다! 지금 가입하세요: https://medium.com/membership/@tomaszs2\n\n저는 초등학교 때 프로그래밍에 흥미를 가지기 시작했어요. 수학만큼 흥미로운 것은 아니었지만, 그래도 뭔가 특별한 게 있었어요. 특히 알고리즘 경진대회를 좋아했던 기억이요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그러한 대회는 알고리즘을 사용하여 해결해야 할 여러 작업이 포함되어 있었습니다. 뿐만 아니라, 알고리즘은 낮은 복잡성을 가져야 하며, 모든 경우에 최소한의 코드와 처리 시간으로 답변을 제공해야 합니다.\n\n한동안 프로그래밍이란 정확히 이런 것이라고 생각했어요. 이러한 알고리즘에 사람들의 참여는 승인된 값의 예상 범위에서 함수로 데이터를 제공하는 데로 제한되어 있었습니다. 따라서 숫자 대신 문자열과 같은 예외적인 값들을 처리할 기대가 없었습니다.\n\n모든 것이 알고리즘에 관한 것이었습니다. 삶은 아름다웠고, 엔지니어가 되었을 때 미래에 하는 일이라고 정말로 생각했어요. 흥미롭고 도전적인 비전이었지만 동시에 어쩌면 다소 지루했던 것 같아요.\n\n교육 중 잠시 후에 새로운 개체가 생겨났고, 보통 언제나 주요 관심사의 외부에서 천천히 등장했습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 엔티티는 시스템에 제한된 액세스 권한이 있었습니다. 콘솔 앱의 경우, 해당 엔티티는 입력을 제공하고 출력을 받을 수 있었습니다.\n\n나중에 유스케이스 다이어그램 작성 중에도 해당 엔티티는 제한된 액세스 권한을 가졌습니다. 더욱이, 그 사람은 시스템 외부에 그려졌습니다. 시스템의 구성 요소로서가 아닌, 시스템 외부에 있고 명백한 제한된 시스템 액세스 및 권한을 가졌습니다.\n\n이러한 다이어그램들은 물론 상식적으로 이해 가능합니다. 사용자는 시스템에 의해 서비스를 받는 존재로 볼 수 있습니다. 그러나 사용자는 외부인으로 여기기 때문에 환영받지 않는 느낌을 줍니다. 시스템을 사용하는 사람인데도 시스템이 중심이 되고 전체적인 아이디어의 중요한 부분인 것처럼 보입니다:\n\n![사용자와 소프트웨어 엔지니어링을 좋아하는 방법](/assets/img/2024-06-23-HowToStartToLikeUsersAndEnjoySoftwareEngineering_1.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다른 흥미로운 점은 시스템의 각 요소가 구분되어 있지만 사용자는 항상 같이 끌린다는 것입니다. 그것은 뭔가 끈적한 인상이 드는데, 요리사인 경우라도 그렇습니다. 우리 모두가 그것이 올바른 표현이 아니라는 것을 알고 있습니다 :) 사용자는 종종 시스템과 무관한 별개의 개체로 여겨지는데, 그들 자신의 사회적이고 개인적이며 업무 관련 시스템의 일부인 것이 더 복잡합니다.\n\n사용자가 시스템을 사용할 때, 실제로 만들어진 두 시스템 사이의 연결이며, 사용자 시스템이 사실 더 복잡합니다.\n\n상업 소프트웨어 엔지니어링 여정을 시작한 이후 사용자에 대해 더 배웠습니다. 실제로 제가 수업을 들었던 중 하나인 데이터베이스 강사가 이 사용자들에 대해 더 이야기하는 수업이 있었습니다. 그 분들은 사용자를 좋아하지 않았는데, 그들이 대게 무언가를 망가뜨릴 때가 많았습니다.\n\n제 경력 중에는 초기 교육에서 사용자가 바람직하지 않은 필수 요소라고 여기는 사람들을 만났습니다. 사용자는 잘못된 데이터를 제공하여 시스템이 장애를 일으킵니다. 사용자는 조용한 코더의 삶을 방해하는 비현실적인 기대를 갖습니다. 사용자는 변경이나 유지 관리가 필요한 제품 소유자로 가상으로 현실화됩니다. 시스템이 작동하기 위해 필요하지 않은 모든 것들입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그러나 실제로 이러한 시스템을 구축하는 중에 이러한 믿음이 얼마나 잘못된 것인지, 실제로 사용자가 소프트웨어 엔지니어링을 흥미롭게 만들고, 투자할 가치가 있는지 깨달았습니다.\n\n# 첫 만남\n\n첫 팀에 합류했을 때 고객이나 사용자와 연락을 가질 기회가 없었습니다. 주니어 개발자로서 나는 그냥 테스크를 맡겨받고 그것을 완료해야 했습니다. 더 경험이 많고 매우 재능 있는 친절한 개발자들과 멋진 제품 매니저가 무엇이 좋은지, 무엇이 좋지 않은지 말해주었기 때문에 수정해야 했습니다.\n\n그러나 일부 티켓들은 매우 이상했는데, 논리에 반하는 경향이 있었고 나나 팀 구성원들이 쉽게 설명할 수 없었습니다. 그냥 그렇게 되어야 했습니다. 나의 호기심이 생겼습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n내 호기심은 점점 커졌어요. 누군가가 지원팀을 지원하고 사용자를 위한 24시간 핫라인을 유지해야 한다는 것을 알게 된 순간, 그 일을 하고 싶었어요.\n\n그래서 나는 회사 스마트폰과 블루투스 장치를 가지고 언제든지 전화를 받을 수 있었어요. 나라를 여행하던 상인들은 나에게 전화를 걸어 시스템에 도움을 요청할 수 있었어요.\n\n한 통화가 바로 '첫 번째 연락'이라고 할 수 있는데, 그 전에 썼던 것이 얼마나 중요한지를 깨닫게 해줬어요. 사용자가 겨울에 방문한 사업장 근처에 주차한 차에서 전화를 걸었어요. 노트북을 가지고 있었지만, 승진을 위해 필요한 보고서를 처리할 수 없었어요. 배터리가 낮고, 밖은 얼어죽을 정도로 춥더라고요.\n\n내가 가지고 있던 모든 믿음과는 달리, 사용자는 매력적인 사람으로 다가왔어요. 짧은 대화 시간 동안에 그의 삶에 대해 많이 이야기해 주었거든요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n시스템을 조사한 결과, 그가 해서는 안 되는 것이 무엇인지 확인하고, 모든 것이 완벽하게 작동하는지 확인했습니다. 그래서 그에게 그가 무엇을 했는지 단계별로 알려달라고 요청했습니다. 그는 모든 것을 올바르게 했기 때문에 나는 그에게 나무를 놓을 수 있는 것이 없었습니다.\n\n그 당시 원격 연결이 없었기 때문에 그가 말한 것에만 의존해야 했습니다. 우리는 다시 시도했지만, 이번에는 그가 정확히 무엇을 클릭하는지, 그 게시물이 어떻게 보이는지를 나에게 알려달라고 했습니다.\n\n그가 이야기할 때 나는 시스템의 내 인스턴스에서 그의 단계를 반복했습니다. 클릭, 클릭, 클릭.\n\n팝업이 열리고, 그는 일련의 질문에 대답한 후 준비된 보고서를 보내기 위한 버튼을 클릭하여 수락했습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그는 신규 상인이었기 때문에 시스템에서 뭔가 더 해야 할 일이 있는지 애매하게 느꼈습니다. 그 당시에는 시스템에 대해 완전한 지식이 없었기 때문에 그가 실제로 도울 수 있도록 최선을 다해야 했습니다.\n\n그는 팝업 창의 단일 버튼을 클릭했고, 나도 그 버튼을 클렀습니다. 그의 시스템은 보고서를 보내지 않았지만 내 시스템은 보냈습니다.\n\n우리는 이 순간에 멈추고 그에게 팝업을 나에게 설명해 주길 원했습니다. 그는 간단한 팝업을 설명하는 데 기쁘지 않아했는데, 모든 것이 그의 사환을 받기 위해 보고서를 보내는 것이었으며 겨울에 차량이 한창일 때 낮은 배터리로 가까고 있었으며 다음 시설로 여행해야 하고 학교에서 어린이를 데려가기 전에 모두해야 했습니다.\n\n그는 팝업을 설명했습니다. 나와 똑같이 일반적인 팝업이었으며, 보고서를 보내고 싶은지 묻는 문구와 버튼이 있었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n버튼, 버튼, 버튼...?\n\n그는 그래 - 버튼. \"process\"라는 버튼과 \"proceed\"라는 다른 버튼이 있어. \"proceed\"를 클릭했을 때 보고서가 전송되지 않아. 나는 이미 양식을 다시 처리하고 싶지 않아.\n\n화면을 보니 두 개의 버튼이 아니라 한 개의 버튼만 있었고, 그 버튼은 \"proceed\"였어.\n\n그렇게 간단할 수 없겠지, 생각했어. 그에게 프로세스 버튼을 클릭해 보라고 했어. 그는 반대했지만 그 버튼을 클릭했어. 그가 클릭하자 그의 설문지가 나타났고, 지난 달 지출액을 입력할 수 있는 필드가 있었어. 그가 말한 대로 거기에는 완전히 숫자로 된 값이 들어 있었어. 그래서 모든 것이 괜찮았지만 여전히 이 오류가 있었어.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n문제가 정확히 발견되었을 때 값에 문제가 있을 것이라고 확신이 생겼어요. 그가 전체 값을 표시하고 특수 문자가 있나 물어봤는데, 없다고 대답했어요. 값 안에 공백이 있나요? 역시 없다고 했어요.\n\n소수점 구분자는 무엇을 사용하나요? — 점이요, 그가 빠르게 대답했어요. 제 양식을 살펴봤는데, 저는 쉼표를 사용했더라구요…\n\n여기서 우리는 멈추어야 해요, 왜냐하면 제가 여러분에게 질문을 하고 싶어요. 문제와 딜레마에 대해 어떻게 생각하세요? 시스템과 그 시스템의 개발자, 사용자에 대해 어떻게 생각하시나요?\n\n저와 모든 개발자에게 첫 접촉은 결정적 가정이 이루어지는 순간이며, 그 순간이 오래 지속될 수도 있고 가장 중요한 순간일 수도 있어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n제가 처음으로 이야기를 발표하는 이유는 몇 가지가 있어요. 그 이야기가 특정한 사람이 그런 문제에 어떻게 접근하는지에 대해서 많은 해답을 제공하기 때문이에요. 나중에 해결한 훨씬 복잡한 문제들의 세부 내용을 모두 다루지 않고도 쉽게 이야기할 수 있어서요.\n\n# 해답들\n\n이 질문에는 다양한 답변이 있어요.\n\n어떤 개발자들은 해당 사용자가 제대로된 버튼을 클릭하지 않았고 잘못된 십진 구분 기호를 사용했다며 사용자를 어리석은 사람으로 규정합니다. 이 경우 사용자의 잘못 때문이기 때문에 시스템에서 해야 할 일이 없습니다. 좋지 않은 사용자가 잘못된 일을 했고 그것은 그의 문제 입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다른 분들은 그냥 전체 이야기가 얼마나 어리석은지, 그리고 시스템이 망가진 것을 곧 알게 되고, 그 시스템을 개발한 사람들이 바보라고 생각하게 되는데 미리 예측하지 못 했다는 것을. 흥미로운 점은 이러한 개발자들이 종종 같은 실수를 반복한다는 것이다. 그래서 어떤 측면에 있어서는 이러한 접근이 더 나은 초점을 갖는다는 것 또한 반드시 의미하는 것이 아니라고 생각합니다.\n\n이제 때때로, 이 순간에 멈추는 사람들을 만나곤 합니다. 그들은 질문을 하며 어떻게 더 나은 방법으로 할 수 있었는지 고민하기 시작합니다. 아이디어를 듣고 사람들이 이러한 상황에 대해 어떻게 대처하는지 듣는 것은 흥미로울 때가 있습니다.\n\n# 사용자를 좋아하기 시작하세요\n\n이 상황의 현실은 사용자라는 “시스템”의 한 측면이 있다는 것입니다. 그는 가족을 지원하기 위해 차 안에서 얼어붙어가며 일하고 있으며, IT 시스템이 데이터를 인식하지 못하는 이유를 깨우치는 것보다 그가 짊어진 것이 훨씬 더 복잡합니다. 그가 사용하는 IT 시스템보다 그의 “시스템”은 훨씬 더 복잡한 가까운 및 먼 연결을 가지고 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이런 문제들을 살펴보는 방식이 저는 좋아하는 스타일입니다. 심지어 더 좋은 방식으로, 전체적으로 가장 중요한 것은 사용자라고 생각합니다. 사용자들은 바빠서 다양한 일을 해야 하며, IT 시스템을 사용하여 간단한 작업을 수행하러 옵니다. 가끔 사용자의 관점에서는 이러한 시스템이 도움이 되지 않을 때도 있습니다. 이상적으로 이 가맹점은 데이터를 이메일로 손쉽게 보낼 수 있었을 것입니다.\n\n사용자의 프로세스는 그의 데이터가 더 빨리 처리될 것이므로 간접적으로 혜택을 받았습니다. 그러나 이 시점에서는 차에서 추운 상태로 출근하고, 학교에서 아이들을 제때에 데리러 가야 하는 상황에서 그것이 가장 중요한 것은 아닙니다. 사용자에게 중요한 것은 작업을 완료하고 일상을 진행하는 것입니다.\n\n그는 이메일을 보낼 수도 있지만, 예상대로 시스템을 사용하려고 합니다. 그것은 그에게 기대되는 행동이기 때문이며, 이메일은 상사와의 관계를 해칠 수도 있고, 심지어 문제를 유발할 수도 있습니다. 소프트웨어 엔지니어로써, 우리는 사용자가 살고 있는 \"시스템\"의 복잡성 전체 규모를 알 수 없습니다. 그들의 관계, 그들의 삶까지 말이죠.\n\n이 이야기는 제가 만든 시스템의 사용자들에 대해 많은 것을 가르쳐 주었으며, 사용자에 중점을 두거나, 다른 말로 사용자 중심 접근법을 적용할 수 있었던 모든 프로젝트에서 항상 좋은 결과가 있었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만족한 사용자 뿐만 아니라 내가 일한 모든 비즈니스와 스타트업을 위해서도 그렇습니다. 개선된 프로세스와 사용자 경험은 항상 더 나은 비즈니스 결과와 수익을 가져옵니다.\n\n특히 이 어려운 시기에 우리가 만든 시스템과 연결된 사람들과 공감하는 것이 중요하다고 생각합니다. 우리가 시스템을 구축하는 제한된 시간 안에는 실제로 사람들에게 중요한 핵심에 집중해야 합니다. 그것을 알아내는 것은 항상 간단하지는 않습니다.\n\n우리는 무한한 시간을 갖고 있다고 생각하기 쉽지만, 사실은 그 시간을 어떻게 사용할지에 대한 선택지가 항상 있습니다. 우리는 사용자와 사람들을 지원할 수도 있고, 필요 없는 것에 시간을 낭비하거나 우리만이 유용하다고 생각하는 것에 시간을 들일 수도 있습니다.\n\n사람들에게 가까이 있음으로써 시간을 적절하게 균형잡을 수도 있고, 어느 정도 안정감을 얻을 수도 있습니다. 우리는 혼자가 아니라 함께하는 것이며, 파란 화면으로 분리되더라도 함께하는 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저는 시니어 / 리드 프론트엔드 개발자로서 새로운 기회를 찾고 있어요. 제 철학을 좋아하시고 기회에 대해 알고 계신다면 알려주세요! 제 LinkedIn 프로필을 확인해보세요!\n\n이 글을 좋아하시나요? 박수를 보내주세요, 구독, 좋아요, 소셜 미디어에서 공유할 수 있어요!\n\nTom Smykowski를 따라오는 11,000명의 개발자들에 합류하세요! Tom은 당신이 지불하는 $5의 일부를 받게 되어, 다음 기사를 쓸 수 있게 될 거예요! 지금 회원이 되어보세요!\n","ogImage":{"url":"/assets/img/2024-06-23-HowToStartToLikeUsersAndEnjoySoftwareEngineering_0.png"},"coverImage":"/assets/img/2024-06-23-HowToStartToLikeUsersAndEnjoySoftwareEngineering_0.png","tag":["Tech"],"readingTime":11},{"title":"Ravi Rajput의 테크 허브에 오신 것을 환영합니다","description":"","date":"2024-06-23 21:07","slug":"2024-06-23-WelcometoRaviRajputsTechHub","content":"\n안녕하세요, 기술 열정가 여러분! 저는 혁신을 사랑하는 다양한 기술 세트를 갖춘 열정적인 풀스택 개발자 라비 라즈푸트입니다. 이 블로그는 소프트웨어 개발, 웹 디자인, 머신 러닝, 인공 지능, 비즈니스, 스타트업, 라이프스타일 등의 업데이트 및 통찰력을 제공하는 곳입니다. 경력 개발자, 스타트업 창업자 또는 기술 분야에 관심 있는 분이든 간에 여기서 가치 있는 콘텐츠를 찾을 수 있을 거예요.\n\n## 내가 누구인가?\n\n풀스택 개발에서 3년의 경험을 가지고 있으며, 저는 다양한 기술을 전문으로 합니다. 전문성은 다음과 같은 기술 영역에 걸쳐 있습니다:\n\n- 프론트엔드 개발: HTML, CSS, Bootstrap, Tailwind, JavaScript, TypeScript, Angular, ReactJS\n- 백엔드 개발: C#, .NET, WebAPI, .NET MVC\n- 데이터 및 인공 지능: 머신 러닝, 데이터 과학, Python\n- 데이터베이스 관리: SQL\n- 프로그래밍 언어: Java, Python, C#\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n나는 기술과 교육, 비즈니스, 스타트업, 그리고 라이프스타일이 교차하는 지점에 깊은 흥미를 느끼고 있어요. 이 블로그는 기술 지식과 현실적인 통찰을 결합한 것이에요.\n\n## 무엇을 기대할 수 있을까요?\n\n1. 소프트웨어 개발 업데이트: 최신 트렌드, 도구, 그리고 소프트웨어 개발의 최상의 실천 방법을 앞서가며 뒤쫓아야 합니다. 새로운 프레임워크부터 코딩 팁까지, 항상 최신 정보를 제공할게요.\n\n2. 웹 개발 팁: HTML, CSS, Bootstrap, 그리고 Tailwind로 멋진 웹사이트를 어떻게 만들어야 하는지 배울 수 있어요. JavaScript와 TypeScript가 동적 사용자 경험을 만드는 데 얼마나 강력한지 알아보세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n3. 깊이 있는 프레임워크 안내: Angular 및 ReactJS와 같은 인기있는 프레임워크에 대한 포괄적인 안내를 받아보세요. 단일 페이지 애플리케이션 또는 복잡한 웹 플랫폼을 구축하고 있다면, 이러한 통찰력은 귀중할 것입니다.\n\n4. 백엔드 마스터리: C#, .NET, WebAPI 및 .NET MVC로 백엔드 개발의 복잡성을 이해하세요. 견고하고 확장 가능한 서버 사이드 응용 프로그램을 구축하는 방법을 배워보세요.\n\n5. 데이터 과학과 인공지능: Python을 사용하여 데이터의 세계로 뛰어들어보세요. 기계 학습 알고리즘부터 실용적인 데이터 과학 응용 프로그램까지, 이 섹션은 데이터의 힘을 활용하는 데 도움이 될 것입니다.\n\n6. 비즈니스 및 스타트업: 스타트업 생태계, 비즈니스 전략 및 기업가 팁에 대한 통찰력을 얻어보세요. 자신의 벤처를 시작하거나 기존 벤처를 확장하고 있다면, 여기서 가치 있는 조언을 찾을 수 있을 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n7. 교육과 기술: 기술이 교육을 변화시키는 방법을 탐색해보세요. e-러닝 플랫폼부터 AI 기반 맞춤형 학습까지, 교육의 미래를 발견해보세요.\n\n8. 라이프스타일과 기술: 기술이 라이프스타일과 어떻게 통합되는지 이해해보세요. 스마트 홈 장치부터 최신 웨어러블 기기까지, 혁신이 어떻게 일상생활을 향상시키는지 살펴보세요.\n\n9. 데이터베이스 관리: MongoDB와 같은 데이터베이스 기술에 대해 배워보세요. 애플리케이션을 위해 데이터베이스를 관리, 확장, 최적화하는 방법을 이해해보세요.\n\n## 이 블로그를 팔로우해야 하는 이유?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 전문가의 통찰력: 내 광범위한 경험과 다양한 기술에 대한 깊은 지식을 활용하세요.\n- 포괄적인 커버리지: 소프트웨어 개발부터 비즈니스 전략까지 다양한 주제를 다룹니다.\n- 실용적인 팁: 즉시 적용할 수 있는 실용적인 조언과 코딩 팁을 받아보세요.\n- 커뮤니티 참여: 같은 관심을 가진 기술 애호가들의 커뮤니티에 참여하세요. 생각을 공유하고 질문을 하며 협업하세요.\n\n## 참여해 보세요!\n\n저는 커뮤니티와 협업의 힘을 믿습니다. 포스트에 댓글을 남기고 질문을 하며 경험을 공유하는 것을 장려합니다. 함께하면 모두가 성장하고 배우는 활기찬 기술 커뮤니티를 만들 수 있습니다.\n\n계속해서 업데이트, 자습서, 기사를 제공할 예정이니 계속 주목하세요. 최신 포스트를 직접 이메일함으로 받아보려면 뉴스레터를 구독하지 않으시기 바랍니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n감사합니다. 함께 기술의 흥미로운 세계를 탐험해봐요!\n\n내 소식을 받아보세요:\n\n- LinkedIn: [Ravi Rajput | LinkedIn](1)\n- GitHub: [Ravi9129 (Ravi Rajput) · GitHub](https://github.com/Ravi9129)\n\n최신 소식을 받아보세요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 뉴스레터 구독하기\n- 블로그 팔로우하기\n\n라비 라즈푸트의 테크 허브에 오신 것을 환영합니다! 기술과 혁신이 만나는 곳입니다.\n","ogImage":{"url":"/assets/img/2024-06-23-WelcometoRaviRajputsTechHub_0.png"},"coverImage":"/assets/img/2024-06-23-WelcometoRaviRajputsTechHub_0.png","tag":["Tech"],"readingTime":4},{"title":"Jetpack Compose에서 키보드가 보일 때 자동 콘텐츠 크기 조정하는 방법","description":"","date":"2024-06-23 21:06","slug":"2024-06-23-HowtoHandleAutomaticContentResizingwhenkeyboardisvisibleinJetpackCompose","content":"\n안녕하세요! 안드로이드 개발자로서 저희는 앱의 내용이 키보드와 겹치는 문제에 모두 부딪혀본 적이 있을 것입니다. 이는 사용자들에게 귀찮은 일이 될 수 있습니다.\n\n아래는 해당 내용에 대한 이미지입니다.\n\n[![이미지](/assets/img/2024-06-23-HowtoHandleAutomaticContentResizingwhenkeyboardisvisibleinJetpackCompose_0.png)](https://miro.medium.com/v2/resize:fit:856/1*5uRM2cdOb4ROhfT5N3NpLw.gif)\n\n본 문서에서는 Jetpack Compose에서 키보드가 나타날 때 내용을 자동으로 조절하는 방법에 대해 알아보겠습니다. 시작하기 전에, 이게 무엇인지 살펴보겠습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n과거에는 AndroidManifest.xml 파일에 다음 라인을 추가하여 이 문제를 해결했었습니다:\n\n```js\nandroid: windowSoftInputMode = \"adjustResize\";\n```\n\n그러나 Compose만 사용하는 앱에서는 이 방법이 작동하지 않기 때문에 대안적인 해결책을 찾아야 합니다.\n\n키보드가 열릴 때 자동으로 패딩을 추가하는 .imePadding 수정자를 사용하는 재사용 가능한 컴포넌트를 만들었습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 간단한 컴포넌트는 콘텐츠를 수용하고 키보드가 열릴 때 자동으로 크기를 조절합니다. 이 컴포넌트의 사용법은 간단하며 아래에서 확인할 수 있습니다:\n\n```js\n KeyboardAware {\n    SearchSongScreen(...)\n }\n```\n\n결과는 다음과 같습니다:\n\n![이미지](https://miro.medium.com/v2/resize:fit:856/1*Xp9vSTgY1d2eFegiv_9t1Q.gif)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그러나 우리는 곧 하나의 화면에 여러 개의 TextField가 필요하다는 것을 깨달았는데, 그렇게 되면 내용이 다시 겹칠 것임을 깨달을 수 있었습니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:856/1*PXj9YJxEyse91vYwgfcTNQ.gif)\n\n이 경우 내용을 스크롤할 수 있게 해야 합니다. 이를 위해 몇 가지 더 필요합니다:\n\n화면에 전달될 scrollState를 추가해야 합니다. 이를 .verticalScroll 수정자에 전달할 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리는 rememberCoroutineScope로 coroutineScope를 생성해야 합니다. 이는 코루틴을 컴포저블 외부에서 시작하는 데 사용할 수 있는 composition-aware scope를 생성합니다.\n\n마지막으로 물론 키보드의 높이를 얻어야 합니다. 이는 WindowInsets.ime.getBottom(LocalDensity.current)로 수행할 수 있습니다.\n\n모든 것을 연결하고 작동하는 예제를 얻기 위해 keyboardHeight를 키로 사용하여 LaunchedEffect를 사용합니다. 이는 우리가 LaunchedEffect에 전달하는 블록이 키보드의 높이가 변경될 때마다 (다시) 시작될 것을 의미합니다. 우리가 필요한 것과 정확히 일치합니다!\n\n마지막으로 scrollState.scrollBy(keyboardHeight.toFloat())를 호출하여 내용을 키보드의 높이만큼 스크롤합니다. 이때 이전에 생성한 coroutineScope를 사용해야 합니다. scrollBy가 중단 함수이기 때문입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n최종 솔루션이 이렇게 생겼습니다:\n\n![image](https://miro.medium.com/v2/resize:fit:856/1*E2MdREPidgMZFSoTn_pHpg.gif)\n\n그런데요! 🥳 이제 거의 모든 화면에서 작동하는 최종 솔루션이 완성되었습니다. 이 간단한 튜토리얼이 유용하길 바라요. 👨‍💻\n\n전체 코드는 여기에서 확인할 수 있어요: https://github.com/Kuglll/KeyboarAwareSample/tree/main\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n제 Github 또는 LinkedIn을 통해 언제든지 연락하셔도 괜찮아요.\n","ogImage":{"url":"/assets/img/2024-06-23-HowtoHandleAutomaticContentResizingwhenkeyboardisvisibleinJetpackCompose_0.png"},"coverImage":"/assets/img/2024-06-23-HowtoHandleAutomaticContentResizingwhenkeyboardisvisibleinJetpackCompose_0.png","tag":["Tech"],"readingTime":4},{"title":"Jetpack Compose로 Bottom Navigation Bar 구현하는 방법","description":"","date":"2024-06-23 21:05","slug":"2024-06-23-JetpackComposeBottomNavigationBar","content":"\n이 튜토리얼에서는 깔끔한 API 디자인을 갖고 재사용이 쉬운 하단 네비게이션 바를 구축하는 데 Material 3를 사용할 것입니다.\n\n![하단 네비게이션 바 이미지](/assets/img/2024-06-23-JetpackComposeBottomNavigationBar_0.png)\n\n시작하기 전에 제 글을 좋아하고 👏 박수를 보내주시면 더 많은 사람들이 이 유용한 내용을 배울 수 있도록 도와주세요!\n\n# 구글이 말합니다\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n개발자 문서에 중요한 점 하나를 강조할게요. 네비게이션 바에는 \"단일 목적지를 나타내는 세 개에서 다섯 개의 NavigationBarItem을 포함해야 한다.\"고 명시되어 있어요. 그래서 만약 5개 이상의 항목이나 3개 미만의 항목을 표시하고 싶다면, 다른 네비게이션 패턴을 찾아보는 것이 좋을 거예요.\n\nGoogle이 네비게이션 바에 대해 어떤 내용을 알려주는지 더 알고 싶다면, 여기에서 개발자 문서를 확인해보세요: [https://developer.android.com/reference/kotlin/androidx/compose/material3/package-summary#navigationbar](https://developer.android.com/reference/kotlin/androidx/compose/material3/package-summary#navigationbar)\n\n# 초기 설정\n\n이 튜토리얼에서는 SDK 버전 34를 기반으로 작성하기로 선택했어요. 네비게이션 바를 통해 탐색하기 위해 추가해야 할 의존성이 하나 있을 거에요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n// App Build.gradle 파일의 deopendencies에 다음을 추가하세요\nimplementation(\"androidx.navigation:navigation-compose:2.7.5\");\n```\n\n의존성을 추가한 후에는 gradle 파일을 동기화하는 것을 잊지 마세요(Android Studio 상단에 \"지금 동기화\"라는 버튼이 있는 바가 나타날 것입니다).\n\n# Jetpack Compose에서 내비게이션 바 만들기\n\n조금 중복되는 소리일 수 있지만, 안드로이드 개발에서의 bottom navigation bar가 Scaffold 구성요소의 \"bottomBar\"에 들어간다고 생각하면 됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n네비게이션 바의 각 항목은 동일한 기본 구성 요소 세트를 가지고 있기 때문에, 탭 바로 아래에 선언된 탭의 제목과 일치하는 NavHost 안에 있는 compose() 객체의 이름을 정확히 맞춤으로써 TabBarItem과 해당 뷰 사이의 연결을 누락하지 않고 스펠링 오류를 방지합니다.\n\n개발자분들을 위한 부가 정보로, 애플의 TabView를 잘 아시는 경우 Android는 하단 네비게이션 바를 사용할 때 기본적으로 내장된 네비게이션을 제공하지 않습니다. 뷰 구성 요소로의 탐색을 직접 추가해야 합니다. Android 개발자의 경우, Apple은 TabView를 사용할 때 뷰로 이동하려는 것을 자동으로 인식하여 추가적인 탐색을 요구하지 않습니다. 두 구현을 옆으로 비교하고 싶다면, 새 탭에서 Apple TabView 튜토리얼을 열어보세요.\n\n코드를 더 읽기 쉽고 따라가기 쉽도록 만들기 위해, NavigationBar API의 몇 가지 작은 구성 요소를 자체 사용자 지정 compose 컴포넌트로 분리하였습니다. 이러한 구성 요소를 분리해서 사용할 필요는 없지만, 코드의 본질적인 부분을 더 쉽게 이해할 수 있는 방법을 제공합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 코드에서는 세 개의 탭에 텍스트 composable을 표시하도록 선택했을 수 있습니다. 이것은 강좌의 TabView와 네비게이션 부분에 중점을 두기 위해 수행되었지만 이것은 다른 composable 유형으로 교체 될 수 있습니다. 이를 보여주기 위해 'More' 탭을 클릭했을 때 표시되는 사용자 정의 MoreView를 만들었습니다.\n\nMarkdown 형식으로 코드를 나타냈습니다.\n\n```kotlin\n// 여기에 코드가 와야합니다\n```\n\n이 기사가 유용했다면, 저를 팔로우하거나 기사에 박수를 치거나 공유하여 다른 사람이 쉽게 찾을 수 있도록 돕는 것을 고려해 주시기 바랍니다.감사합니다!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n해당 주제에 대한 질문이 있거나 같은 작업을 수행할 수 있는 다른 방법을 아시는 경우, 글에 답변하거나 친구와 공유하여 의견을 얻으셔도 좋습니다.\n\n네이티브 모바일 개발에 대해 더 알고 싶다면, 다른 문서들을 확인해보세요: https://medium.com/@jpmtech\n\n네이티브 모바일 개발로 제작된 앱들을 확인하고 싶다면, 제 앱들을 여기에서 확인하세요: https://jpmtech.io/apps\n\n제 작품을 살펴봐 주셔서 감사합니다!\n","ogImage":{"url":"/assets/img/2024-06-23-JetpackComposeBottomNavigationBar_0.png"},"coverImage":"/assets/img/2024-06-23-JetpackComposeBottomNavigationBar_0.png","tag":["Tech"],"readingTime":4}],"page":"16","totalPageCount":116,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true}