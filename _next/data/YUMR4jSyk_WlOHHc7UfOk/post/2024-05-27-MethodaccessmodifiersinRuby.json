{"pageProps":{"post":{"title":"루비에서의 메소드 접근 제한자","description":"","date":"2024-05-27 16:09","slug":"2024-05-27-MethodaccessmodifiersinRuby","content":"\n## 루비에서의 메소드 액세스 수정자\n\n루비에서의 메소드 액세스 수정자는 클래스 내부 및 외부에서 메소드의 가시성 및 접근성을 정의하는 중요한 역할을 합니다. 기본 설정으로 메소드는 공개(public)이며, 이는 객체 외부 및 내부에서 모두 호출할 수 있다는 것을 의미합니다.\n\n## 공개 메소드\n\n루비에서는 기본적으로 메소드가 공개(public)로 설정됩니다. 따라서 객체의 내부 및 외부에서 모두 호출할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nclass Parent\n  def initialize(name)\n    @name = name\n  end\n\n  def public_method\n    @name\n  end\nend\n\nparent = Parent.new('Eric')\np parent.public_method #=> \"Eric\"\n```\n\n## Private Methods\n\nPrivate methods can only be called from within the context of the defining class. They cannot be called with an explicit receiver, not even self.\n\n```js\nclass Parent\n  def initialize(name)\n    @name = name\n  end\n\n  private\n\n  def name\n    @name\n  end\nend\n\nclass Child1 < Parent\n  def other_name(child)\n    child.name\n  end\n\n  def call_name\n    name\n  end\nend\n\nclass Child2 < Parent\nend\n\nchild1 = Child1.new('Eric')\nchild2 = Child2.new('John')\np child1.other_name(child2) #=> private method `name' called for #<Child2:…> (NoMethodError)\np child1.call_name #=> \"Eric\"\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 보호된 메서드\n\n보호된 메서드는 정의된 클래스의 인스턴스 또는 하위 클래스의 인스턴스에서 호출할 수 있지만, 이외의 인스턴스에서는 호출할 수 없습니다.\n\n```js\nclass Parent\n  def initialize(name)\n    @name = name\n  end\n\n  protected\n\n  def name\n    @name\n  end\nend\n\nclass Child1 < Parent\n  def other_name(child)\n    child.name\n  end\n\n  def call_name\n    name\n  end\nend\n\nclass Child2 < Parent\nend\n\nchild1 = Child1.new('Eric')\nchild2 = Child2.new('John')\np child1.other_name(child2) #=> \"John\"\np child1.name #=> protected method `name' called for #<Child1:…> (NoMethodError)\n```\n\n## 접근 제한자 및 범위\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n액세스 한정자는 Ruby에서 범위에 영향을 주지 않습니다; 메서드의 가시성만을 영향을 미칩니다. 외부에서 접근할 수 없는 개인 메서드도 하위 클래스에서는 상속됩니다.\n\n```js\nclass Parent\n  def initialize(name)\n    @name = name\n  end\n\n  private\n\n  def name\n    @name\n  end\nend\n\nclass Child < Parent\n  def call_name\n    name\n  end\nend\n\nchild = Child.new('Eric')\np child.call_name #=> \"Eric\"\n```\n\n# 실용적인 고려사항\n\n## 보호된 메서드\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 보호된 메서드는 Ruby에서 자주 사용되지 않는데, 이는 가시성을 혼동시키고 메서드가 어디에서 어떻게 호출되는지 추적하기 어렵게 만들 수 있기 때문입니다.\n- 이는 미묘한 버그를 도입하고 디버깅을 더 어렵게 만들 수 있습니다.\n\n## 비공개 메서드\n\n- 비공개 메서드는 객체의 내부 작동과 공개 인터페이스 사이의 명확한 분리를 제공합니다.\n- 캡슐화를 촉진하며 코드를 유지 및 디버그하기 쉽게 만듭니다.\n\n## 결론\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n루비의 접근 제어자는 메소드의 가시성을 정의하고 메소드에 접근 및 상호 작용하는 방법을 제어하는 중요한 도구입니다. 이러한 제어자를 이해하고 적절하게 사용하는 것은 깔끔하고 이해하기 쉽고 유지보수 가능한 코드를 유지하는 데 도움이 될 수 있습니다. 코드베이스가 더 복잡해지면 이러한 차이의 중요성이 더욱 명확해질 것입니다.\n","ogImage":{"url":"/assets/img/2024-05-27-MethodaccessmodifiersinRuby_0.png"},"coverImage":"/assets/img/2024-05-27-MethodaccessmodifiersinRuby_0.png","tag":["Tech"],"readingTime":4},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<h2>루비에서의 메소드 액세스 수정자</h2>\n<p>루비에서의 메소드 액세스 수정자는 클래스 내부 및 외부에서 메소드의 가시성 및 접근성을 정의하는 중요한 역할을 합니다. 기본 설정으로 메소드는 공개(public)이며, 이는 객체 외부 및 내부에서 모두 호출할 수 있다는 것을 의미합니다.</p>\n<h2>공개 메소드</h2>\n<p>루비에서는 기본적으로 메소드가 공개(public)로 설정됩니다. 따라서 객체의 내부 및 외부에서 모두 호출할 수 있습니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Parent</span>\n  def <span class=\"hljs-title function_\">initialize</span>(name)\n    @name = name\n  end\n\n  def public_method\n    @name\n  end\nend\n\nparent = <span class=\"hljs-title class_\">Parent</span>.<span class=\"hljs-title function_\">new</span>(<span class=\"hljs-string\">'Eric'</span>)\np parent.<span class=\"hljs-property\">public_method</span> #=> <span class=\"hljs-string\">\"Eric\"</span>\n</code></pre>\n<h2>Private Methods</h2>\n<p>Private methods can only be called from within the context of the defining class. They cannot be called with an explicit receiver, not even self.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Parent</span>\n  def <span class=\"hljs-title function_\">initialize</span>(name)\n    @name = name\n  end\n\n  private\n\n  def name\n    @name\n  end\nend\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Child1</span> &#x3C; <span class=\"hljs-title class_\">Parent</span>\n  def <span class=\"hljs-title function_\">other_name</span>(child)\n    child.<span class=\"hljs-property\">name</span>\n  end\n\n  def call_name\n    name\n  end\nend\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Child2</span> &#x3C; <span class=\"hljs-title class_\">Parent</span>\nend\n\nchild1 = <span class=\"hljs-title class_\">Child1</span>.<span class=\"hljs-title function_\">new</span>(<span class=\"hljs-string\">'Eric'</span>)\nchild2 = <span class=\"hljs-title class_\">Child2</span>.<span class=\"hljs-title function_\">new</span>(<span class=\"hljs-string\">'John'</span>)\np child1.<span class=\"hljs-title function_\">other_name</span>(child2) #=> private method <span class=\"hljs-string\">`name' called for #&#x3C;Child2:…> (NoMethodError)\np child1.call_name #=> \"Eric\"\n</span></code></pre>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h2>보호된 메서드</h2>\n<p>보호된 메서드는 정의된 클래스의 인스턴스 또는 하위 클래스의 인스턴스에서 호출할 수 있지만, 이외의 인스턴스에서는 호출할 수 없습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Parent</span>\n  def <span class=\"hljs-title function_\">initialize</span>(name)\n    @name = name\n  end\n\n  protected\n\n  def name\n    @name\n  end\nend\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Child1</span> &#x3C; <span class=\"hljs-title class_\">Parent</span>\n  def <span class=\"hljs-title function_\">other_name</span>(child)\n    child.<span class=\"hljs-property\">name</span>\n  end\n\n  def call_name\n    name\n  end\nend\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Child2</span> &#x3C; <span class=\"hljs-title class_\">Parent</span>\nend\n\nchild1 = <span class=\"hljs-title class_\">Child1</span>.<span class=\"hljs-title function_\">new</span>(<span class=\"hljs-string\">'Eric'</span>)\nchild2 = <span class=\"hljs-title class_\">Child2</span>.<span class=\"hljs-title function_\">new</span>(<span class=\"hljs-string\">'John'</span>)\np child1.<span class=\"hljs-title function_\">other_name</span>(child2) #=> <span class=\"hljs-string\">\"John\"</span>\np child1.<span class=\"hljs-property\">name</span> #=> protected method <span class=\"hljs-string\">`name' called for #&#x3C;Child1:…> (NoMethodError)\n</span></code></pre>\n<h2>접근 제한자 및 범위</h2>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>액세스 한정자는 Ruby에서 범위에 영향을 주지 않습니다; 메서드의 가시성만을 영향을 미칩니다. 외부에서 접근할 수 없는 개인 메서드도 하위 클래스에서는 상속됩니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Parent</span>\n  def <span class=\"hljs-title function_\">initialize</span>(name)\n    @name = name\n  end\n\n  private\n\n  def name\n    @name\n  end\nend\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Child</span> &#x3C; <span class=\"hljs-title class_\">Parent</span>\n  def call_name\n    name\n  end\nend\n\nchild = <span class=\"hljs-title class_\">Child</span>.<span class=\"hljs-title function_\">new</span>(<span class=\"hljs-string\">'Eric'</span>)\np child.<span class=\"hljs-property\">call_name</span> #=> <span class=\"hljs-string\">\"Eric\"</span>\n</code></pre>\n<h1>실용적인 고려사항</h1>\n<h2>보호된 메서드</h2>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<ul>\n<li>보호된 메서드는 Ruby에서 자주 사용되지 않는데, 이는 가시성을 혼동시키고 메서드가 어디에서 어떻게 호출되는지 추적하기 어렵게 만들 수 있기 때문입니다.</li>\n<li>이는 미묘한 버그를 도입하고 디버깅을 더 어렵게 만들 수 있습니다.</li>\n</ul>\n<h2>비공개 메서드</h2>\n<ul>\n<li>비공개 메서드는 객체의 내부 작동과 공개 인터페이스 사이의 명확한 분리를 제공합니다.</li>\n<li>캡슐화를 촉진하며 코드를 유지 및 디버그하기 쉽게 만듭니다.</li>\n</ul>\n<h2>결론</h2>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>루비의 접근 제어자는 메소드의 가시성을 정의하고 메소드에 접근 및 상호 작용하는 방법을 제어하는 중요한 도구입니다. 이러한 제어자를 이해하고 적절하게 사용하는 것은 깔끔하고 이해하기 쉽고 유지보수 가능한 코드를 유지하는 데 도움이 될 수 있습니다. 코드베이스가 더 복잡해지면 이러한 차이의 중요성이 더욱 명확해질 것입니다.</p>\n</body>\n</html>\n"},"__N_SSG":true}