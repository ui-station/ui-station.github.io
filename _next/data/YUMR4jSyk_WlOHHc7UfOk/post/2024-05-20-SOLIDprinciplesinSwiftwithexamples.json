{"pageProps":{"post":{"title":"Swift에서 SOLID 원칙에 대한 예제","description":"","date":"2024-05-20 17:46","slug":"2024-05-20-SOLIDprinciplesinSwiftwithexamples","content":"\n위 문서의 향상된 버전을 확인하세요. 향상된 구문 강조와 최신 업데이트가 모두 포함된 개인 블로그에서 확인할 수 있습니다! 피드백과 참여를 환영하며 앞으로의 콘텐츠 제작을 지원해주세요:\n\n# (S) 단일 책임 원칙\n\n단일 책임 원칙(SRP)은 각 엔티티가 단 하나의 작업이나 문제 해결만을 담당해야 한다는 원칙을 말합니다.\n\n일반적으로 SRP를 따르지 않고 코드를 작성하는 예시를 살펴보겠습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nimport Foundation\n\n구조체 처리기 {\n\n    개인 처리기\n\n    함수 처리() {\n\n        // 사람 데이터 가져오기\n        let personAsData = 가져오기()\n\n        // 데이터를 필요한 객체로 파싱\n        let person = 파싱(personAsData)\n\n        // 개인 객체 지역적으로 저장\n        저장하기(person)\n    }\n\n    사적 함수 가져오기() -> 데이터 {\n        \"\"\"\n        {\n            \"name\": \"Shubham Bakshi\",\n            \"age\": 28,\n            \"canTakeANapAnywhere\": true\n\n        }\n        \"\"\".data(using: .utf8)!\n    }\n\n    사적 함수 파싱(_ data: Data) -> 개인 {\n        try! JSONDecoder().decode(개인.self, from: data)\n    }\n\n    사적 함수 저장하기(_ person: 개인) {\n        UserDefaults.standard.set(person, forKey: \"person\")\n    }\n\n}\n\n구조체 개인: Codable {\n    let name: String\n    let age: Int\n    let canTakeANapAnywhere: Bool\n}\n```\n\n우리의 SRP가 깨진 부분은 Handler 엔티티 자체 내에서 모든 작업을 수행하고 있기 때문에 이를 각각의 엔티티로 분리하고 따로 처리해야 합니다. 이제 SRP를 따르는 코드를 살펴보겠습니다:\n\n```js\nimport Foundation\n\n구조체 처리기 {\n\n    개인 가져오기: 가져오기 핸들러\n    개인 파싱: 변환 핸들러\n    개인 저장: 저장 핸들러\n\n    이달함수(init: FetchHandler, ParseHandler, SaveHandler) {\n        self.fetchHandler = fetchHandler\n        self.parseHandler = parseHandler\n        self.saveHandler = saveHandler\n    }\n\n    함수 처리() {\n\n        // 사람 데이터 가져오기\n        let personAsData = fetchHandler.fetch()\n\n        // 데이터를 필요한 객체로 파싱\n        let person = parseHandler.parse(personAsData)\n\n        // 개인 객체 지역적으로 저장\n        saveHandler.save(person)\n    }\n\n}\n\n구조체 가져오기 핸들러 {\n\n    함수 가져오기() -> 데이터 {\n        \"\"\"\n        {\n            \"name\": \"Shubham Bakshi\",\n            \"age\": 28,\n            \"canTakeANapAnywhere\": true\n\n        }\n        \"\"\".data(using: .utf8)!\n    }\n\n}\n\n구조체 변환 핸들러 {\n\n    함수 파싱(_ data: Data) -> 개인 {\n        try! JSONDecoder().decode(개인.self, from: data)\n    }\n\n}\n\n구조체 저장 핸들러 {\n\n    함수 저장(_ person: 개인) {\n        UserDefaults.standard.set(person, forKey: \"person\")\n    }\n\n}\n\n구조체 개인: Codable {\n    let name: String\n    let age: Int\n    let canTakeANapAnywhere: Bool\n}\n```\n\nSRP는 다음과 같은 이점을 제공합니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 더 높은 응집력\n- 코드 중복 가능성 감소\n- 부풀어 오른 클래스 감소\n- 테스트 및 유지 관리가 용이\n- 여러 책임이 분리되어 코드가 깔끔해짐\n\n# (O) 개방-폐쇄 원칙\n\n개방-폐쇄 원칙(OCP)은 엔티티가 확장에 대해 열려 있지만 수정에 대해서는 닫혀 있어야 한다는 것을 말합니다. 이는 클래스가 기존 코드를 수정하지 않고 쉽게 확장 가능해야 함을 의미합니다.\n\n처음에는 정의가 모순적으로 들릴 수 있지만 규모에 맞게 이 원칙을 따르기 시작하면 더 많은 의미를 갖게 됩니다. 이 원칙을 정말로 좁혀보면: 클래스를 만들고 확장할 수 있지만 원본 클래스를 수정할 수 없습니다. 이렇게하는 이유는:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 다른 사람이 클래스를 작성했고 여기에 기능을 추가하거나 변경을 해야 할 때 원래 작성자에게 계속 변경을 요청해야 하거나 직접 변경해야 할 수 있었습니다. 이제 원 작성자는 기능이 작동하도록 작성한 모든 코드에 대해 다른 생각 과정을 가질 수 있습니다.\n- 게다가 클래스는 더 많은 관심사(또는 간단히 기능)를 통합(또는 단순히 추가)할 수 있는데, 이는 SRP를 깨뜨릴 수 있습니다.\n\n위에서 SRP가 활성화된 예에서 고려해보겠습니다. 여기에서는 사용자 개체를 UserDefaults에 저장했지만 이제 CoreData에도 저장하려고 합니다. 우리의 go-to 접근법은 다음과 같습니다:\n\n```js\nimport Foundation\n\nstruct Handler {\n\n    private let fetchHandler: FetchHandler\n    private let parseHandler: ParseHandler\n    private let saveHandler: SaveHandler\n\n    init(fetchHandler: FetchHandler, parseHandler: ParseHandler, saveHandler: SaveHandler) {\n        self.fetchHandler = fetchHandler\n        self.parseHandler = parseHandler\n        self.saveHandler = saveHandler\n    }\n\n    func handle() {\n\n        // 사용자 데이터 가져오기\n        let personAsData = fetchHandler.fetch()\n\n        // 데이터를 필요한 개체로 구문 분석\n        let person = parseHandler.parse(personAsData)\n\n        // 사용자 개체를 UserDefaults에 로컬로 저장\n        saveHandler.saveToUserDefaults(person)\n\n        // 사용자 개체를 CoreData에 로컬로 저장\n        saveHandler.saveToCoreData(person)\n    }\n\n}\n\nstruct FetchHandler {\n\n    func fetch() -> Data {\n        \"\"\"\n        {\n            \"name\": \"Shubham Bakshi\",\n            \"age\": 28,\n            \"canTakeANapAnywhere\": true\n\n        }\n        \"\"\".data(using: .utf8)!\n    }\n\n}\n\nstruct ParseHandler {\n\n    func parse(_ data: Data) -> Person {\n        try! JSONDecoder().decode(Person.self, from: data)\n    }\n\n}\n\nstruct SaveHandler {\n\n    func saveToUserDefaults(_ person: Person) {\n        UserDefaults.standard.set(person, forKey: \"person\")\n    }\n\n    func saveToCoreData(_ person: Person) {\n        // CoreData에 데이터를 저장하는 매우 복잡한 코드\n    }\n\n}\n\nstruct Person: Codable {\n    let name: String\n    let age: Int\n    let canTakeANapAnywhere: Bool\n}\n```\n\n이는 우리가 철저히 테스트하고 나중에 배포한 save-to-User-Defaults의 원래 구현을 변경하고 있어 OCP를 깨뜨립니다. OCP를 수용하기 위해 클래스를 통해 상속을 사용하거나 우리 스위프트 개발자가 사용하기를 사랑하는 단순히 프로토콜 준수를 사용할 수 있습니다!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\nimport Foundation\n\nstruct Handler {\n\n    private let fetchHandler: FetchHandler\n    private let parseHandler: ParseHandler\n    private let saveHandler: PersistenceHandler\n\n    init(fetchHandler: FetchHandler, parseHandler: ParseHandler, saveHandler: PersistenceHandler) {\n        self.fetchHandler = fetchHandler\n        self.parseHandler = parseHandler\n        self.saveHandler = saveHandler\n    }\n\n    func handle() {\n\n        // 사람 데이터 가져오기\n        let personAsData = fetchHandler.fetch()\n\n        // 데이터 구문 분석하여 필요한 객체로 변환\n        let person = parseHandler.parse(personAsData)\n\n        // 사람 객체를 로컬에 저장\n        saveHandler.save(person)\n    }\n\n}\n\nstruct FetchHandler {\n\n    func fetch() -> Data {\n        \"\"\"\n        {\n            \"name\": \"Shubham Bakshi\",\n            \"age\": 28,\n            \"canTakeANapAnywhere\": true\n\n        }\n        \"\"\".data(using: .utf8)!\n    }\n\n}\n\nstruct ParseHandler {\n\n    func parse(_ data: Data) -> Person {\n        try! JSONDecoder().decode(Person.self, from: data)\n    }\n}\n\nprotocol PersistenceType {\n    func save(_ person: Person)\n}\n\nstruct UserDefaultsPersistenceHandler: PersistenceType {\n\n    func save(_ person: Person) {\n        UserDefaults.standard.set(person, forKey: \"person\")\n    }\n}\n\nstruct CoreDataPersistenceHandler: PersistenceType {\n\n    func save(_ person: Person) {\n        // Core data에 데이터를 저장하기 위한 매우 포괄적인 코드\n    }\n}\n\nstruct PersistenceHandler {\n\n    let userDefaultsPersistenceHandler: UserDefaultsPersistenceHandler\n    let coreDataPersistenceHandler: CoreDataPersistenceHandler\n\n    init(userDefaultsPersistenceHandler: UserDefaultsPersistenceHandler, coreDataPersistenceHandler: CoreDataPersistenceHandler) {\n        self.userDefaultsPersistenceHandler = userDefaultsPersistenceHandler\n        self.coreDataPersistenceHandler = coreDataPersistenceHandler\n    }\n\n    func save(_ person: Person) {\n        userDefaultsPersistenceHandler.save(person)\n        coreDataPersistenceHandler.save(person)\n    }\n}\n\nstruct Person: Codable {\n    let name: String\n    let age: Int\n    let canTakeANapAnywhere: Bool\n}\n```\n\n만약 프로토콜 준수를 사용하고 싶지 않다면, 클래스를 통해 상속을 사용하여 동일한 결과를 달성할 수 있습니다:\n\n```kotlin\nimport Foundation\n\nstruct Handler {\n\n    private let fetchHandler: FetchHandler\n    private let parseHandler: ParseHandler\n    private let saveHandler: ModifiedSaveHandler\n\n    init(fetchHandler: FetchHandler, parseHandler: ParseHandler, saveHandler: ModifiedSaveHandler) {\n        self.fetchHandler = fetchHandler\n        self.parseHandler = parseHandler\n        self.saveHandler = saveHandler\n    }\n\n    func handle() {\n\n        // 사람 데이터 가져오기\n        let personAsData = fetchHandler.fetch()\n\n        // 데이터 구문 분석하여 필요한 객체로 변환\n        let person = parseHandler.parse(personAsData)\n\n        // 사람 객체를 로컬에 저장\n        saveHandler.save(person)\n    }\n\n}\n\nstruct FetchHandler {\n\n    func fetch() -> Data {\n        \"\"\"\n        {\n            \"name\": \"Shubham Bakshi\",\n            \"age\": 28,\n            \"canTakeANapAnywhere\": true\n\n        }\n        \"\"\".data(using: .utf8)!\n    }\n\n}\n\nstruct ParseHandler {\n\n    func parse(_ data: Data) -> Person {\n        try! JSONDecoder().decode(Person.self, from: data)\n    }\n\n}\n\nclass SaveHandler {\n\n    func save(_ person: Person) {\n        UserDefaults.standard.set(person, forKey: \"person\")\n    }\n\n}\n\nfinal class ModifiedSaveHandler: SaveHandler {\n\n    override func save(_ person: Person) {\n        super.save(person)\n\n        // Core data에 데이터를 저장하기 위한 매우 포괄적인 코드\n    }\n\n}\n\nstruct Person: Codable {\n    let name: String\n    let age: Int\n    let canTakeANapAnywhere: Bool\n}\n```\n\nOCP의 이점은 다음과 같을 수 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 코드를 유지 및 검토하는 것이 쉽습니다.\n- 추상화 및 다형성의 사용을 촉진합니다.\n- 이미 테스트되고 배포 준비가 된 기존 코드를 수정할 수 없도록 하므로 잠재적 버그를 줄이는 데 도움이 됩니다.\n\n# (L) 리스코프 치환 원칙\n\n솔직히 말해서, 리스코프 치환 원칙(LSK)은 처음에는 아마도 가장 혼란스러운 원칙 중 하나일지도 모릅니다!\n\n그것이 실제로 말하는 것은 슈퍼클래스의 객체는 해당 서브클래스의 객체로 교체할 수 있어야 하는데 프로그램의 정확성에 영향을 미치지 않아야한다는 것입니다. LSK는 단순히 추가 단계를 통한 상속이라고 볼 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n상기한 예시를 사용하여 LSK(Liskov Substitution Principle)를 설명하는 것이 어렵고 혼란스러울 수 있으므로 다른 간단한 예시를 사용하겠습니다. 또한, 이미 해당 내용이 인터넷에 널리 퍼져 있고 때로는 혼란스러울 수 있기 때문에 사각형과 정사각형 예시를 사용하지 않겠습니다.\n\n```js\nimport Foundation\n\nclass Bird {\n    func fly() {\n        print(\"I can fly\")\n    }\n}\n\nfinal class Duck: Bird {\n    /// ✅ Duck은 날 수 있는 새이므로 LSP를 따릅니다.\n}\n\nfinal class Ostrich: Bird {\n    /// ❌ 사실 타조는 새이지만 날지 못하므로 LSP를 위반합니다.\n}\n```\n\n그렇다면 이 문제를 어떻게 해결할까요? 우리는 날 수 있는 새를 위한 별도의 클래스를 만듭니다:\n\n```js\nimport Foundation\n\nclass Bird {\n\n}\n\nclass FlyingBird: Bird {\n    func fly() {\n        print(\"I can fly\")\n    }\n}\n\nfinal class Duck: FlyingBird {\n    /// ✅ Duck은 날 수 있는 새이므로 LSP를 따릅니다.\n}\n\nfinal class Ostrich: Bird {\n    /// ✅ 타조는 이제 날 필요가 없으므로 LSP를 따릅니다.\n    /// (그리고 이제는 다른 일에 집중할 수 있게 되었죠,\n    /// 예를 들어 사람 뒤를 더 빠르게 쫓아가서 겁을 줄 수 있는 방법에 대해)\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nLSP의 이점은 다음과 같습니다:\n\n- 코드는 유연하고 모듈식으로 유지됩니다.\n- 코드 중복을 줄입니다.\n\n# (I) 인터페이스 분리 원칙\n\n인터페이스 분리 원칙(ISP)은 클라이언트가 사용하지 않는 인터페이스를 강제로 구현하거나 클라이언트가 사용하지 않는 메서드에 의존하도록 강요해서는 안된다는 것을 명시합니다. 간단히 말하면, 하나의 뚱뚱한 인터페이스(또는 프로토콜) 대신에 많은 작은 인터페이스를 사용하여 제공하는 메서드에 기반을 둔다는 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nISP(Interface Segregation Principle)은 SRP(Single Responsibility Principle)와 비슷하지만, SRP는 일반적으로 구조체/클래스에 적용되고, ISP는 프로토콜에 적용됩니다.\n\n위의 샘플에서 Bird 예시를 사용하여 ISP를 설명할 수 있지만, 프로토콜(또는 다른 언어에서의 인터페이스)을 사용하여 우리의 entity가 하나 이상의 프로토콜을 준수할 수 있도록 할 것입니다:\n\n```js\nimport Foundation\n\nprotocol Bird {\n\n    func fly()\n\n    func swim()\n\n    func mimic()\n}\n\nfinal class Duck: Bird {\n    /// ❌ Duck는 날 수 있고 헤엄칠 수 있지만 모방할 수는 없으므로 ISP를 위반함\n}\n\nfinal class Parrot: Bird {\n    /// ❌ Parrot은 날 수 있고 모방할 수 있지만 헤엄쳐갈 수는 없으므로 ISP를 위반함\n}\n\nfinal class Penguin: Bird {\n    /// ❌ Penguin은 헤엄칠 수 있지만 날 수 없으며 모방할 수도 없으므로 ISP를 위반함\n}\n```\n\n이 문제를 해결하기 위해 Bird 프로토콜을 하위 프로토콜로 분리하여 각 메서드를 수용할 수 있도록 합니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```swift\nimport Foundation\n\nprotocol FlyingBird {\n    func fly()\n}\n\nprotocol SwimmingBird {\n    func swim()\n}\n\nprotocol MimickingBird {\n    func mimic()\n}\n\nfinal class Duck: FlyingBird, SwimmingBird {\n    /// ✅ Follows ISP since duck can fly and swim without needing to mimic\n}\n\nfinal class Parrot: FlyingBird, MimickingBird {\n    /// ✅ Follows ISP since parrot can fly and mimic without needing to swim\n}\n\nfinal class Penguin: SwimmingBird {\n    /// ✅ Follows ISP since penguin can swim without needing to fly or mimic\n}\n```\n\nISP의 장점은 다음과 같습니다:\n\n- 더 집중된 및 일관된 인터페이스\n- 불필요한 종속성을 피할 수 있음\n- 단일 부풀린 인터페이스를 피할 수 있음\n- 결합을 촉진함\n\n# (D) 의존성 역전 원칙 (Dependency Inversion principle)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n의존 역전 원칙(Dependency Inversion Principle, DIP)은 고수준 모듈이 저수준 모듈에 의존하지 않아야 하며, 둘 다 추상화에 의존해야 한다고 설명합니다. 간단하게 말하면: 구성원은 구상체(concretions)가 아닌 추상화(abstractors)에 의존해야 한다는 것이죠.\n\n이렇게 함으로써 코드가 가능한한 작은 표면적 영역에 의존하도록 보장됩니다. 실제로 코드 자체에 의존하지 않고, 단지 그 코드가 어떻게 행동해야 하는지를 정의하는 계약에만 의존하게 됩니다. 이렇게 함으로써 코드의 한 부분에 오류가 발생해도 다른 의존하는 부분에서 코드가 연쇄적으로 망가지는 결과를 막을 수 있습니다.\n\nDIP는 OCP와 꽤 비슷하게 들리지만 예시로서도 OCP의 예시를 사용할 수 있을 정도이기도 합니다. 그러나 여기서는 다른 예시를 사용하겠습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 예제는 DIP(Dependency Inversion Principle)를 위반합니다. Payment 클래스는 CreditCardPayment과 강하게 결합되어 있으며, 이는 고수준 모듈인 Payment 클래스가 저수준 모듈인 CreditCardPayment에 의존하고 있음을 의미합니다. DIP에 따르면 추상화/프로토콜에 의존해야 합니다.\n\n```js\nimport Foundation\n\nprotocol PaymentMethod {\n    func pay(_ amount: Double)\n}\n\nstruct DebitCardPayment: PaymentMethod {\n    func pay(_ amount: Double) { }\n}\n\nstruct CreditCardPayment: PaymentMethod {\n    func pay(_ amount: Double) { }\n}\n\nstruct ApplePayPayment: PaymentMethod {\n    func pay(_ amount: Double) { }\n}\n\nstruct Payment {\n\n    private let paymentMethod: PaymentMethod\n\n    init(method: PaymentMethod) {\n        paymentMethod = method\n    }\n\n    func makePayment(of amount: Double) {\n        paymentMethod.pay(amount)\n    }\n}\n\nlet creditCardPaymentMethod = CreditCardPayment()\n\nlet payment = Payment(method: creditCardPaymentMethod)\npayment.makePayment(of: 500)\n```\n\nDIP의 장점:\n\n- 결합 감소를 장려함\n- 코드를 보다 유연하고 재사용 가능하며, 민첩하게 만듦\n- 구성 요소 간의 계약을 정의하기 위해 인터페이스 또는 프로토콜 사용을 장려함\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n모두를 종합하자면, 앱에 SOLID 원칙을 통합하는 것에는 많은 이점이 있습니다:\n\n- 코드를 이해, 유지 및 확장하기 쉽게 만들어줍니다.\n- 엔티티의 책임이 적을수록, 엔티티를 변경할 때 코드가 깨지는 가능성이 줄어듭니다.\n- 더 확장 가능하고 테스트하기 쉬운 코드를 작성할 수 있습니다.\n- 코드를 리팩터링하는데 더 적은 복잡성으로 도와줍니다.\n- 딱 맞는 수준의 결합을 사용할 수 있도록 도와줍니다 - 함께 있어야 할 것들은 함께 두고, 분리되어야 하는 것들은 분리합니다.\n\n여기까지, 여러분! 즐거운 코딩하세요!\n\nLinkedIn에서 저와 연결해보세요 👱🏻 또는 다른 채널로 연락할 수 있습니다 📬\n","ogImage":{"url":"/assets/img/2024-05-20-SOLIDprinciplesinSwiftwithexamples_0.png"},"coverImage":"/assets/img/2024-05-20-SOLIDprinciplesinSwiftwithexamples_0.png","tag":["Tech"],"readingTime":16},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p>위 문서의 향상된 버전을 확인하세요. 향상된 구문 강조와 최신 업데이트가 모두 포함된 개인 블로그에서 확인할 수 있습니다! 피드백과 참여를 환영하며 앞으로의 콘텐츠 제작을 지원해주세요:</p>\n<h1>(S) 단일 책임 원칙</h1>\n<p>단일 책임 원칙(SRP)은 각 엔티티가 단 하나의 작업이나 문제 해결만을 담당해야 한다는 원칙을 말합니다.</p>\n<p>일반적으로 SRP를 따르지 않고 코드를 작성하는 예시를 살펴보겠습니다:</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Foundation</span>\n\n구조체 처리기 {\n\n    개인 처리기\n\n    함수 처리() {\n\n        <span class=\"hljs-comment\">// 사람 데이터 가져오기</span>\n        <span class=\"hljs-keyword\">let</span> personAsData = 가져오기()\n\n        <span class=\"hljs-comment\">// 데이터를 필요한 객체로 파싱</span>\n        <span class=\"hljs-keyword\">let</span> person = 파싱(personAsData)\n\n        <span class=\"hljs-comment\">// 개인 객체 지역적으로 저장</span>\n        저장하기(person)\n    }\n\n    사적 함수 가져오기() -> 데이터 {\n        <span class=\"hljs-string\">\"\"</span><span class=\"hljs-string\">\"\n        {\n            \"</span>name<span class=\"hljs-string\">\": \"</span><span class=\"hljs-title class_\">Shubham</span> <span class=\"hljs-title class_\">Bakshi</span><span class=\"hljs-string\">\",\n            \"</span>age<span class=\"hljs-string\">\": 28,\n            \"</span>canTakeANapAnywhere<span class=\"hljs-string\">\": true\n\n        }\n        \"</span><span class=\"hljs-string\">\"\"</span>.<span class=\"hljs-title function_\">data</span>(<span class=\"hljs-attr\">using</span>: .<span class=\"hljs-property\">utf8</span>)!\n    }\n\n    사적 함수 파싱(_ <span class=\"hljs-attr\">data</span>: <span class=\"hljs-title class_\">Data</span>) -> 개인 {\n        <span class=\"hljs-keyword\">try</span>! <span class=\"hljs-title class_\">JSON</span>Decoder().<span class=\"hljs-title function_\">decode</span>(개인.<span class=\"hljs-property\">self</span>, <span class=\"hljs-attr\">from</span>: data)\n    }\n\n    사적 함수 저장하기(_ <span class=\"hljs-attr\">person</span>: 개인) {\n        <span class=\"hljs-title class_\">UserDefaults</span>.<span class=\"hljs-property\">standard</span>.<span class=\"hljs-title function_\">set</span>(person, <span class=\"hljs-attr\">forKey</span>: <span class=\"hljs-string\">\"person\"</span>)\n    }\n\n}\n\n구조체 개인: <span class=\"hljs-title class_\">Codable</span> {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">name</span>: <span class=\"hljs-title class_\">String</span>\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">age</span>: <span class=\"hljs-title class_\">Int</span>\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">canTakeANapAnywhere</span>: <span class=\"hljs-title class_\">Bool</span>\n}\n</code></pre>\n<p>우리의 SRP가 깨진 부분은 Handler 엔티티 자체 내에서 모든 작업을 수행하고 있기 때문에 이를 각각의 엔티티로 분리하고 따로 처리해야 합니다. 이제 SRP를 따르는 코드를 살펴보겠습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Foundation</span>\n\n구조체 처리기 {\n\n    개인 가져오기: 가져오기 핸들러\n    개인 파싱: 변환 핸들러\n    개인 저장: 저장 핸들러\n\n    이달함수(<span class=\"hljs-attr\">init</span>: <span class=\"hljs-title class_\">FetchHandler</span>, <span class=\"hljs-title class_\">ParseHandler</span>, <span class=\"hljs-title class_\">SaveHandler</span>) {\n        self.<span class=\"hljs-property\">fetchHandler</span> = fetchHandler\n        self.<span class=\"hljs-property\">parseHandler</span> = parseHandler\n        self.<span class=\"hljs-property\">saveHandler</span> = saveHandler\n    }\n\n    함수 처리() {\n\n        <span class=\"hljs-comment\">// 사람 데이터 가져오기</span>\n        <span class=\"hljs-keyword\">let</span> personAsData = fetchHandler.<span class=\"hljs-title function_\">fetch</span>()\n\n        <span class=\"hljs-comment\">// 데이터를 필요한 객체로 파싱</span>\n        <span class=\"hljs-keyword\">let</span> person = parseHandler.<span class=\"hljs-title function_\">parse</span>(personAsData)\n\n        <span class=\"hljs-comment\">// 개인 객체 지역적으로 저장</span>\n        saveHandler.<span class=\"hljs-title function_\">save</span>(person)\n    }\n\n}\n\n구조체 가져오기 핸들러 {\n\n    함수 가져오기() -> 데이터 {\n        <span class=\"hljs-string\">\"\"</span><span class=\"hljs-string\">\"\n        {\n            \"</span>name<span class=\"hljs-string\">\": \"</span><span class=\"hljs-title class_\">Shubham</span> <span class=\"hljs-title class_\">Bakshi</span><span class=\"hljs-string\">\",\n            \"</span>age<span class=\"hljs-string\">\": 28,\n            \"</span>canTakeANapAnywhere<span class=\"hljs-string\">\": true\n\n        }\n        \"</span><span class=\"hljs-string\">\"\"</span>.<span class=\"hljs-title function_\">data</span>(<span class=\"hljs-attr\">using</span>: .<span class=\"hljs-property\">utf8</span>)!\n    }\n\n}\n\n구조체 변환 핸들러 {\n\n    함수 파싱(_ <span class=\"hljs-attr\">data</span>: <span class=\"hljs-title class_\">Data</span>) -> 개인 {\n        <span class=\"hljs-keyword\">try</span>! <span class=\"hljs-title class_\">JSON</span>Decoder().<span class=\"hljs-title function_\">decode</span>(개인.<span class=\"hljs-property\">self</span>, <span class=\"hljs-attr\">from</span>: data)\n    }\n\n}\n\n구조체 저장 핸들러 {\n\n    함수 저장(_ <span class=\"hljs-attr\">person</span>: 개인) {\n        <span class=\"hljs-title class_\">UserDefaults</span>.<span class=\"hljs-property\">standard</span>.<span class=\"hljs-title function_\">set</span>(person, <span class=\"hljs-attr\">forKey</span>: <span class=\"hljs-string\">\"person\"</span>)\n    }\n\n}\n\n구조체 개인: <span class=\"hljs-title class_\">Codable</span> {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">name</span>: <span class=\"hljs-title class_\">String</span>\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">age</span>: <span class=\"hljs-title class_\">Int</span>\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">canTakeANapAnywhere</span>: <span class=\"hljs-title class_\">Bool</span>\n}\n</code></pre>\n<p>SRP는 다음과 같은 이점을 제공합니다:</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<ul>\n<li>더 높은 응집력</li>\n<li>코드 중복 가능성 감소</li>\n<li>부풀어 오른 클래스 감소</li>\n<li>테스트 및 유지 관리가 용이</li>\n<li>여러 책임이 분리되어 코드가 깔끔해짐</li>\n</ul>\n<h1>(O) 개방-폐쇄 원칙</h1>\n<p>개방-폐쇄 원칙(OCP)은 엔티티가 확장에 대해 열려 있지만 수정에 대해서는 닫혀 있어야 한다는 것을 말합니다. 이는 클래스가 기존 코드를 수정하지 않고 쉽게 확장 가능해야 함을 의미합니다.</p>\n<p>처음에는 정의가 모순적으로 들릴 수 있지만 규모에 맞게 이 원칙을 따르기 시작하면 더 많은 의미를 갖게 됩니다. 이 원칙을 정말로 좁혀보면: 클래스를 만들고 확장할 수 있지만 원본 클래스를 수정할 수 없습니다. 이렇게하는 이유는:</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<ul>\n<li>다른 사람이 클래스를 작성했고 여기에 기능을 추가하거나 변경을 해야 할 때 원래 작성자에게 계속 변경을 요청해야 하거나 직접 변경해야 할 수 있었습니다. 이제 원 작성자는 기능이 작동하도록 작성한 모든 코드에 대해 다른 생각 과정을 가질 수 있습니다.</li>\n<li>게다가 클래스는 더 많은 관심사(또는 간단히 기능)를 통합(또는 단순히 추가)할 수 있는데, 이는 SRP를 깨뜨릴 수 있습니다.</li>\n</ul>\n<p>위에서 SRP가 활성화된 예에서 고려해보겠습니다. 여기에서는 사용자 개체를 UserDefaults에 저장했지만 이제 CoreData에도 저장하려고 합니다. 우리의 go-to 접근법은 다음과 같습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Foundation</span>\n\nstruct <span class=\"hljs-title class_\">Handler</span> {\n\n    private <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">fetchHandler</span>: <span class=\"hljs-title class_\">FetchHandler</span>\n    private <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">parseHandler</span>: <span class=\"hljs-title class_\">ParseHandler</span>\n    private <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">saveHandler</span>: <span class=\"hljs-title class_\">SaveHandler</span>\n\n    <span class=\"hljs-title function_\">init</span>(<span class=\"hljs-params\">fetchHandler: FetchHandler, parseHandler: ParseHandler, saveHandler: SaveHandler</span>) {\n        self.<span class=\"hljs-property\">fetchHandler</span> = fetchHandler\n        self.<span class=\"hljs-property\">parseHandler</span> = parseHandler\n        self.<span class=\"hljs-property\">saveHandler</span> = saveHandler\n    }\n\n    func <span class=\"hljs-title function_\">handle</span>(<span class=\"hljs-params\"></span>) {\n\n        <span class=\"hljs-comment\">// 사용자 데이터 가져오기</span>\n        <span class=\"hljs-keyword\">let</span> personAsData = fetchHandler.<span class=\"hljs-title function_\">fetch</span>()\n\n        <span class=\"hljs-comment\">// 데이터를 필요한 개체로 구문 분석</span>\n        <span class=\"hljs-keyword\">let</span> person = parseHandler.<span class=\"hljs-title function_\">parse</span>(personAsData)\n\n        <span class=\"hljs-comment\">// 사용자 개체를 UserDefaults에 로컬로 저장</span>\n        saveHandler.<span class=\"hljs-title function_\">saveToUserDefaults</span>(person)\n\n        <span class=\"hljs-comment\">// 사용자 개체를 CoreData에 로컬로 저장</span>\n        saveHandler.<span class=\"hljs-title function_\">saveToCoreData</span>(person)\n    }\n\n}\n\nstruct <span class=\"hljs-title class_\">FetchHandler</span> {\n\n    func <span class=\"hljs-title function_\">fetch</span>() -> <span class=\"hljs-title class_\">Data</span> {\n        <span class=\"hljs-string\">\"\"</span><span class=\"hljs-string\">\"\n        {\n            \"</span>name<span class=\"hljs-string\">\": \"</span><span class=\"hljs-title class_\">Shubham</span> <span class=\"hljs-title class_\">Bakshi</span><span class=\"hljs-string\">\",\n            \"</span>age<span class=\"hljs-string\">\": 28,\n            \"</span>canTakeANapAnywhere<span class=\"hljs-string\">\": true\n\n        }\n        \"</span><span class=\"hljs-string\">\"\"</span>.<span class=\"hljs-title function_\">data</span>(<span class=\"hljs-attr\">using</span>: .<span class=\"hljs-property\">utf8</span>)!\n    }\n\n}\n\nstruct <span class=\"hljs-title class_\">ParseHandler</span> {\n\n    func <span class=\"hljs-title function_\">parse</span>(_ <span class=\"hljs-attr\">data</span>: <span class=\"hljs-title class_\">Data</span>) -> <span class=\"hljs-title class_\">Person</span> {\n        <span class=\"hljs-keyword\">try</span>! <span class=\"hljs-title class_\">JSON</span>Decoder().<span class=\"hljs-title function_\">decode</span>(<span class=\"hljs-title class_\">Person</span>.<span class=\"hljs-property\">self</span>, <span class=\"hljs-attr\">from</span>: data)\n    }\n\n}\n\nstruct <span class=\"hljs-title class_\">SaveHandler</span> {\n\n    func <span class=\"hljs-title function_\">saveToUserDefaults</span>(<span class=\"hljs-params\">_ person: Person</span>) {\n        <span class=\"hljs-title class_\">UserDefaults</span>.<span class=\"hljs-property\">standard</span>.<span class=\"hljs-title function_\">set</span>(person, <span class=\"hljs-attr\">forKey</span>: <span class=\"hljs-string\">\"person\"</span>)\n    }\n\n    func <span class=\"hljs-title function_\">saveToCoreData</span>(<span class=\"hljs-params\">_ person: Person</span>) {\n        <span class=\"hljs-comment\">// CoreData에 데이터를 저장하는 매우 복잡한 코드</span>\n    }\n\n}\n\nstruct <span class=\"hljs-title class_\">Person</span>: <span class=\"hljs-title class_\">Codable</span> {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">name</span>: <span class=\"hljs-title class_\">String</span>\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">age</span>: <span class=\"hljs-title class_\">Int</span>\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">canTakeANapAnywhere</span>: <span class=\"hljs-title class_\">Bool</span>\n}\n</code></pre>\n<p>이는 우리가 철저히 테스트하고 나중에 배포한 save-to-User-Defaults의 원래 구현을 변경하고 있어 OCP를 깨뜨립니다. OCP를 수용하기 위해 클래스를 통해 상속을 사용하거나 우리 스위프트 개발자가 사용하기를 사랑하는 단순히 프로토콜 준수를 사용할 수 있습니다!</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-kotlin\"><span class=\"hljs-keyword\">import</span> Foundation\n\nstruct Handler {\n\n    <span class=\"hljs-keyword\">private</span> let fetchHandler: FetchHandler\n    <span class=\"hljs-keyword\">private</span> let parseHandler: ParseHandler\n    <span class=\"hljs-keyword\">private</span> let saveHandler: PersistenceHandler\n\n    <span class=\"hljs-keyword\">init</span>(fetchHandler: FetchHandler, parseHandler: ParseHandler, saveHandler: PersistenceHandler) {\n        self.fetchHandler = fetchHandler\n        self.parseHandler = parseHandler\n        self.saveHandler = saveHandler\n    }\n\n    func handle() {\n\n        <span class=\"hljs-comment\">// 사람 데이터 가져오기</span>\n        let personAsData = fetchHandler.fetch()\n\n        <span class=\"hljs-comment\">// 데이터 구문 분석하여 필요한 객체로 변환</span>\n        let person = parseHandler.parse(personAsData)\n\n        <span class=\"hljs-comment\">// 사람 객체를 로컬에 저장</span>\n        saveHandler.save(person)\n    }\n\n}\n\nstruct FetchHandler {\n\n    func fetch() -> Data {\n        <span class=\"hljs-string\">\"\"\"\n        {\n            \"name\": \"Shubham Bakshi\",\n            \"age\": 28,\n            \"canTakeANapAnywhere\": true\n\n        }\n        \"\"\"</span>.<span class=\"hljs-keyword\">data</span>(using: .utf8)!\n    }\n\n}\n\nstruct ParseHandler {\n\n    func parse(_ <span class=\"hljs-keyword\">data</span>: Data) -> Person {\n        <span class=\"hljs-keyword\">try</span>! JSONDecoder().decode(Person.self, from: <span class=\"hljs-keyword\">data</span>)\n    }\n}\n\nprotocol PersistenceType {\n    func save(_ person: Person)\n}\n\nstruct UserDefaultsPersistenceHandler: PersistenceType {\n\n    func save(_ person: Person) {\n        UserDefaults.standard.<span class=\"hljs-keyword\">set</span>(person, forKey: <span class=\"hljs-string\">\"person\"</span>)\n    }\n}\n\nstruct CoreDataPersistenceHandler: PersistenceType {\n\n    func save(_ person: Person) {\n        <span class=\"hljs-comment\">// Core data에 데이터를 저장하기 위한 매우 포괄적인 코드</span>\n    }\n}\n\nstruct PersistenceHandler {\n\n    let userDefaultsPersistenceHandler: UserDefaultsPersistenceHandler\n    let coreDataPersistenceHandler: CoreDataPersistenceHandler\n\n    <span class=\"hljs-keyword\">init</span>(userDefaultsPersistenceHandler: UserDefaultsPersistenceHandler, coreDataPersistenceHandler: CoreDataPersistenceHandler) {\n        self.userDefaultsPersistenceHandler = userDefaultsPersistenceHandler\n        self.coreDataPersistenceHandler = coreDataPersistenceHandler\n    }\n\n    func save(_ person: Person) {\n        userDefaultsPersistenceHandler.save(person)\n        coreDataPersistenceHandler.save(person)\n    }\n}\n\nstruct Person: Codable {\n    let name: String\n    let age: <span class=\"hljs-built_in\">Int</span>\n    let canTakeANapAnywhere: Bool\n}\n</code></pre>\n<p>만약 프로토콜 준수를 사용하고 싶지 않다면, 클래스를 통해 상속을 사용하여 동일한 결과를 달성할 수 있습니다:</p>\n<pre><code class=\"hljs language-kotlin\"><span class=\"hljs-keyword\">import</span> Foundation\n\nstruct Handler {\n\n    <span class=\"hljs-keyword\">private</span> let fetchHandler: FetchHandler\n    <span class=\"hljs-keyword\">private</span> let parseHandler: ParseHandler\n    <span class=\"hljs-keyword\">private</span> let saveHandler: ModifiedSaveHandler\n\n    <span class=\"hljs-keyword\">init</span>(fetchHandler: FetchHandler, parseHandler: ParseHandler, saveHandler: ModifiedSaveHandler) {\n        self.fetchHandler = fetchHandler\n        self.parseHandler = parseHandler\n        self.saveHandler = saveHandler\n    }\n\n    func handle() {\n\n        <span class=\"hljs-comment\">// 사람 데이터 가져오기</span>\n        let personAsData = fetchHandler.fetch()\n\n        <span class=\"hljs-comment\">// 데이터 구문 분석하여 필요한 객체로 변환</span>\n        let person = parseHandler.parse(personAsData)\n\n        <span class=\"hljs-comment\">// 사람 객체를 로컬에 저장</span>\n        saveHandler.save(person)\n    }\n\n}\n\nstruct FetchHandler {\n\n    func fetch() -> Data {\n        <span class=\"hljs-string\">\"\"\"\n        {\n            \"name\": \"Shubham Bakshi\",\n            \"age\": 28,\n            \"canTakeANapAnywhere\": true\n\n        }\n        \"\"\"</span>.<span class=\"hljs-keyword\">data</span>(using: .utf8)!\n    }\n\n}\n\nstruct ParseHandler {\n\n    func parse(_ <span class=\"hljs-keyword\">data</span>: Data) -> Person {\n        <span class=\"hljs-keyword\">try</span>! JSONDecoder().decode(Person.self, from: <span class=\"hljs-keyword\">data</span>)\n    }\n\n}\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SaveHandler</span> {\n\n    func save(_ person: Person) {\n        UserDefaults.standard.<span class=\"hljs-keyword\">set</span>(person, forKey: <span class=\"hljs-string\">\"person\"</span>)\n    }\n\n}\n\n<span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ModifiedSaveHandler</span>: <span class=\"hljs-type\">SaveHandler</span> {\n\n    <span class=\"hljs-keyword\">override</span> func save(_ person: Person) {\n        <span class=\"hljs-keyword\">super</span>.save(person)\n\n        <span class=\"hljs-comment\">// Core data에 데이터를 저장하기 위한 매우 포괄적인 코드</span>\n    }\n\n}\n\nstruct Person: Codable {\n    let name: String\n    let age: <span class=\"hljs-built_in\">Int</span>\n    let canTakeANapAnywhere: Bool\n}\n</code></pre>\n<p>OCP의 이점은 다음과 같을 수 있습니다:</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<ul>\n<li>코드를 유지 및 검토하는 것이 쉽습니다.</li>\n<li>추상화 및 다형성의 사용을 촉진합니다.</li>\n<li>이미 테스트되고 배포 준비가 된 기존 코드를 수정할 수 없도록 하므로 잠재적 버그를 줄이는 데 도움이 됩니다.</li>\n</ul>\n<h1>(L) 리스코프 치환 원칙</h1>\n<p>솔직히 말해서, 리스코프 치환 원칙(LSK)은 처음에는 아마도 가장 혼란스러운 원칙 중 하나일지도 모릅니다!</p>\n<p>그것이 실제로 말하는 것은 슈퍼클래스의 객체는 해당 서브클래스의 객체로 교체할 수 있어야 하는데 프로그램의 정확성에 영향을 미치지 않아야한다는 것입니다. LSK는 단순히 추가 단계를 통한 상속이라고 볼 수 있습니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>상기한 예시를 사용하여 LSK(Liskov Substitution Principle)를 설명하는 것이 어렵고 혼란스러울 수 있으므로 다른 간단한 예시를 사용하겠습니다. 또한, 이미 해당 내용이 인터넷에 널리 퍼져 있고 때로는 혼란스러울 수 있기 때문에 사각형과 정사각형 예시를 사용하지 않겠습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Foundation</span>\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Bird</span> {\n    func <span class=\"hljs-title function_\">fly</span>(<span class=\"hljs-params\"></span>) {\n        <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">\"I can fly\"</span>)\n    }\n}\n\nfinal <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Duck</span>: <span class=\"hljs-title class_\">Bird</span> {\n    <span class=\"hljs-comment\">/// ✅ Duck은 날 수 있는 새이므로 LSP를 따릅니다.</span>\n}\n\nfinal <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Ostrich</span>: <span class=\"hljs-title class_\">Bird</span> {\n    <span class=\"hljs-comment\">/// ❌ 사실 타조는 새이지만 날지 못하므로 LSP를 위반합니다.</span>\n}\n</code></pre>\n<p>그렇다면 이 문제를 어떻게 해결할까요? 우리는 날 수 있는 새를 위한 별도의 클래스를 만듭니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Foundation</span>\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Bird</span> {\n\n}\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">FlyingBird</span>: <span class=\"hljs-title class_\">Bird</span> {\n    func <span class=\"hljs-title function_\">fly</span>(<span class=\"hljs-params\"></span>) {\n        <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">\"I can fly\"</span>)\n    }\n}\n\nfinal <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Duck</span>: <span class=\"hljs-title class_\">FlyingBird</span> {\n    <span class=\"hljs-comment\">/// ✅ Duck은 날 수 있는 새이므로 LSP를 따릅니다.</span>\n}\n\nfinal <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Ostrich</span>: <span class=\"hljs-title class_\">Bird</span> {\n    <span class=\"hljs-comment\">/// ✅ 타조는 이제 날 필요가 없으므로 LSP를 따릅니다.</span>\n    <span class=\"hljs-comment\">/// (그리고 이제는 다른 일에 집중할 수 있게 되었죠,</span>\n    <span class=\"hljs-comment\">/// 예를 들어 사람 뒤를 더 빠르게 쫓아가서 겁을 줄 수 있는 방법에 대해)</span>\n}\n</code></pre>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>LSP의 이점은 다음과 같습니다:</p>\n<ul>\n<li>코드는 유연하고 모듈식으로 유지됩니다.</li>\n<li>코드 중복을 줄입니다.</li>\n</ul>\n<h1>(I) 인터페이스 분리 원칙</h1>\n<p>인터페이스 분리 원칙(ISP)은 클라이언트가 사용하지 않는 인터페이스를 강제로 구현하거나 클라이언트가 사용하지 않는 메서드에 의존하도록 강요해서는 안된다는 것을 명시합니다. 간단히 말하면, 하나의 뚱뚱한 인터페이스(또는 프로토콜) 대신에 많은 작은 인터페이스를 사용하여 제공하는 메서드에 기반을 둔다는 것입니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>ISP(Interface Segregation Principle)은 SRP(Single Responsibility Principle)와 비슷하지만, SRP는 일반적으로 구조체/클래스에 적용되고, ISP는 프로토콜에 적용됩니다.</p>\n<p>위의 샘플에서 Bird 예시를 사용하여 ISP를 설명할 수 있지만, 프로토콜(또는 다른 언어에서의 인터페이스)을 사용하여 우리의 entity가 하나 이상의 프로토콜을 준수할 수 있도록 할 것입니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Foundation</span>\n\nprotocol <span class=\"hljs-title class_\">Bird</span> {\n\n    func <span class=\"hljs-title function_\">fly</span>()\n\n    func <span class=\"hljs-title function_\">swim</span>()\n\n    func <span class=\"hljs-title function_\">mimic</span>()\n}\n\nfinal <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Duck</span>: <span class=\"hljs-title class_\">Bird</span> {\n    <span class=\"hljs-comment\">/// ❌ Duck는 날 수 있고 헤엄칠 수 있지만 모방할 수는 없으므로 ISP를 위반함</span>\n}\n\nfinal <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Parrot</span>: <span class=\"hljs-title class_\">Bird</span> {\n    <span class=\"hljs-comment\">/// ❌ Parrot은 날 수 있고 모방할 수 있지만 헤엄쳐갈 수는 없으므로 ISP를 위반함</span>\n}\n\nfinal <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Penguin</span>: <span class=\"hljs-title class_\">Bird</span> {\n    <span class=\"hljs-comment\">/// ❌ Penguin은 헤엄칠 수 있지만 날 수 없으며 모방할 수도 없으므로 ISP를 위반함</span>\n}\n</code></pre>\n<p>이 문제를 해결하기 위해 Bird 프로토콜을 하위 프로토콜로 분리하여 각 메서드를 수용할 수 있도록 합니다:</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-keyword\">import</span> Foundation\n\n<span class=\"hljs-keyword\">protocol</span> <span class=\"hljs-title class_\">FlyingBird</span> {\n    <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">fly</span>()\n}\n\n<span class=\"hljs-keyword\">protocol</span> <span class=\"hljs-title class_\">SwimmingBird</span> {\n    <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">swim</span>()\n}\n\n<span class=\"hljs-keyword\">protocol</span> <span class=\"hljs-title class_\">MimickingBird</span> {\n    <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">mimic</span>()\n}\n\n<span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Duck</span>: <span class=\"hljs-title class_\">FlyingBird</span>, <span class=\"hljs-title class_\">SwimmingBird</span> {\n    <span class=\"hljs-comment\">/// ✅ Follows ISP since duck can fly and swim without needing to mimic</span>\n}\n\n<span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Parrot</span>: <span class=\"hljs-title class_\">FlyingBird</span>, <span class=\"hljs-title class_\">MimickingBird</span> {\n    <span class=\"hljs-comment\">/// ✅ Follows ISP since parrot can fly and mimic without needing to swim</span>\n}\n\n<span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Penguin</span>: <span class=\"hljs-title class_\">SwimmingBird</span> {\n    <span class=\"hljs-comment\">/// ✅ Follows ISP since penguin can swim without needing to fly or mimic</span>\n}\n</code></pre>\n<p>ISP의 장점은 다음과 같습니다:</p>\n<ul>\n<li>더 집중된 및 일관된 인터페이스</li>\n<li>불필요한 종속성을 피할 수 있음</li>\n<li>단일 부풀린 인터페이스를 피할 수 있음</li>\n<li>결합을 촉진함</li>\n</ul>\n<h1>(D) 의존성 역전 원칙 (Dependency Inversion principle)</h1>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>의존 역전 원칙(Dependency Inversion Principle, DIP)은 고수준 모듈이 저수준 모듈에 의존하지 않아야 하며, 둘 다 추상화에 의존해야 한다고 설명합니다. 간단하게 말하면: 구성원은 구상체(concretions)가 아닌 추상화(abstractors)에 의존해야 한다는 것이죠.</p>\n<p>이렇게 함으로써 코드가 가능한한 작은 표면적 영역에 의존하도록 보장됩니다. 실제로 코드 자체에 의존하지 않고, 단지 그 코드가 어떻게 행동해야 하는지를 정의하는 계약에만 의존하게 됩니다. 이렇게 함으로써 코드의 한 부분에 오류가 발생해도 다른 의존하는 부분에서 코드가 연쇄적으로 망가지는 결과를 막을 수 있습니다.</p>\n<p>DIP는 OCP와 꽤 비슷하게 들리지만 예시로서도 OCP의 예시를 사용할 수 있을 정도이기도 합니다. 그러나 여기서는 다른 예시를 사용하겠습니다:</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>위의 예제는 DIP(Dependency Inversion Principle)를 위반합니다. Payment 클래스는 CreditCardPayment과 강하게 결합되어 있으며, 이는 고수준 모듈인 Payment 클래스가 저수준 모듈인 CreditCardPayment에 의존하고 있음을 의미합니다. DIP에 따르면 추상화/프로토콜에 의존해야 합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Foundation</span>\n\nprotocol <span class=\"hljs-title class_\">PaymentMethod</span> {\n    func <span class=\"hljs-title function_\">pay</span>(_ <span class=\"hljs-attr\">amount</span>: <span class=\"hljs-title class_\">Double</span>)\n}\n\nstruct <span class=\"hljs-title class_\">DebitCardPayment</span>: <span class=\"hljs-title class_\">PaymentMethod</span> {\n    func <span class=\"hljs-title function_\">pay</span>(<span class=\"hljs-params\">_ amount: Double</span>) { }\n}\n\nstruct <span class=\"hljs-title class_\">CreditCardPayment</span>: <span class=\"hljs-title class_\">PaymentMethod</span> {\n    func <span class=\"hljs-title function_\">pay</span>(<span class=\"hljs-params\">_ amount: Double</span>) { }\n}\n\nstruct <span class=\"hljs-title class_\">ApplePayPayment</span>: <span class=\"hljs-title class_\">PaymentMethod</span> {\n    func <span class=\"hljs-title function_\">pay</span>(<span class=\"hljs-params\">_ amount: Double</span>) { }\n}\n\nstruct <span class=\"hljs-title class_\">Payment</span> {\n\n    private <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">paymentMethod</span>: <span class=\"hljs-title class_\">PaymentMethod</span>\n\n    <span class=\"hljs-title function_\">init</span>(<span class=\"hljs-params\">method: PaymentMethod</span>) {\n        paymentMethod = method\n    }\n\n    func <span class=\"hljs-title function_\">makePayment</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">of</span> amount: Double</span>) {\n        paymentMethod.<span class=\"hljs-title function_\">pay</span>(amount)\n    }\n}\n\n<span class=\"hljs-keyword\">let</span> creditCardPaymentMethod = <span class=\"hljs-title class_\">CreditCardPayment</span>()\n\n<span class=\"hljs-keyword\">let</span> payment = <span class=\"hljs-title class_\">Payment</span>(<span class=\"hljs-attr\">method</span>: creditCardPaymentMethod)\npayment.<span class=\"hljs-title function_\">makePayment</span>(<span class=\"hljs-attr\">of</span>: <span class=\"hljs-number\">500</span>)\n</code></pre>\n<p>DIP의 장점:</p>\n<ul>\n<li>결합 감소를 장려함</li>\n<li>코드를 보다 유연하고 재사용 가능하며, 민첩하게 만듦</li>\n<li>구성 요소 간의 계약을 정의하기 위해 인터페이스 또는 프로토콜 사용을 장려함</li>\n</ul>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>모두를 종합하자면, 앱에 SOLID 원칙을 통합하는 것에는 많은 이점이 있습니다:</p>\n<ul>\n<li>코드를 이해, 유지 및 확장하기 쉽게 만들어줍니다.</li>\n<li>엔티티의 책임이 적을수록, 엔티티를 변경할 때 코드가 깨지는 가능성이 줄어듭니다.</li>\n<li>더 확장 가능하고 테스트하기 쉬운 코드를 작성할 수 있습니다.</li>\n<li>코드를 리팩터링하는데 더 적은 복잡성으로 도와줍니다.</li>\n<li>딱 맞는 수준의 결합을 사용할 수 있도록 도와줍니다 - 함께 있어야 할 것들은 함께 두고, 분리되어야 하는 것들은 분리합니다.</li>\n</ul>\n<p>여기까지, 여러분! 즐거운 코딩하세요!</p>\n<p>LinkedIn에서 저와 연결해보세요 👱🏻 또는 다른 채널로 연락할 수 있습니다 📬</p>\n</body>\n</html>\n"},"__N_SSG":true}