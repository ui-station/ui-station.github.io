{"pageProps":{"post":{"title":"스프링 부트 개발자를 위한 도커에 오신 것을 환영합니다","description":"","date":"2024-06-19 12:47","slug":"2024-06-19-WelcometoDockerforSpringBootDevelopers","content":"\n![Docker](/assets/img/2024-06-19-WelcometoDockerforSpringBootDevelopers_0.png)\n\n현대 소프트웨어 아키텍처에서 컨테이너는 선택사항에서 필수 요소로 전환되어 가고 있습니다. 다양한 플랫폼에서 소프트웨어를 이주하고 실행하는 민첩한 방법을 제공하여 전통적인 웹 서버 모델에 비해 속도, 이식성, 확장성 등의 혜택을 제공합니다. 이러한 작고 유연한 컨테이너는 더 큰이고 적응력이 덜한 세팅을 대체하며 특히 마이크로서비스를 향상시킵니다.\n\n본 문서는 Docker를 소개하며, 주요 클라우드 제공업체와의 호환성을 위해 선택된 컨테이너 기술입니다. Docker 기본 사항 및 Maven을 사용한 Spring Boot에서 Docker 실행 및 이미지 작성과 같은 실용적 작업에 대해 다룹니다.\n\n# Docker란 무엇인가요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n도커는 2013년 Solomon Hykes에 의해 개발된 널리 사용되는 오픈 소스 컨테이너 엔진입니다. 초기에는 편리성으로 인식되었지만, 응용 프로그램 내에서 컨테이너를 관리하고 시작하는 데 중요한 도구로 진화하여 가상 머신(VM)과 같은 하드웨어 할당 대신 물리적 머신에서 자원 공유를 가능케했습니다.\n\nIBM, Microsoft, Google 등 주요 기업들의 지원으로 인해 도커는 소프트웨어 개발자들을 위한 필수 도구로 부상했습니다.\n\n서버, REST API 및 명령줄 인터페이스(CLI)로 구성된 Docker Engine은 도커 시스템의 핵심을 형성하여 서버 간에 컨테이너 배포를 용이하게 합니다.\n\n# 도커 엔진 구성 요소\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n기본 구성 요소는 다음과 같습니다:\n\n- Docker 데몬: Docker 이미지를 생성하고 관리하는 서버(dockerd)로, REST API 및 CLI로부터 명령을 받습니다.\n- Docker 클라이언트: 사용자는 Docker 클라이언트를 통해 Docker와 상호 작용하며, 이 클라이언트는 데몬에 명령을 전송합니다.\n- Docker 레지스트리: Docker 이미지를 저장하는 곳으로, 공개(예: Docker 허브) 또는 비공개 레지스트리 옵션이 있습니다.\n- Docker 이미지: Docker 컨테이너를 생성하는 지침을 포함하는 읽기 전용 템플릿으로, 레지스트리에서 가져오거나 Dockerfile을 사용하여 새 이미지를 만들 수 있습니다.\n- Docker 컨테이너: 'docker run' 명령을 사용하여 Docker 이미지에서 만들어지며, 응용 프로그램 및 환경을 호스팅하며 Docker API 또는 CLI를 통해 관리할 수 있습니다.\n- Docker 볼륨: Docker 컨테이너에서 생성되고 사용되는 데이터에 대한 우선적인 저장 메커니즘으로, Docker API 또는 CLI를 통해 관리할 수 있습니다.\n- Docker 네트워크: 컨테이너가 통신을위한 여러 네트워크에 연결되도록 허용하며, 다섯 가지 네트워크 드라이버 유형이 있습니다: bridge, host, overlay, none 및 macvlan.\n\n# Dockerfiles\n\nDockerfile은 Docker 이미지를 자동으로 생성하고 구성하는 지침을 포함하는 텍스트 파일입니다. Linux와 유사한 명령을 사용하여 이미지 생성을 간소화하고 가독성을 향상시킵니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nDockerfile을 생성한 후에는 Docker 이미지를 빌드하기 위해 docker build 명령을 실행합니다. 그런 다음, Docker 이미지가 준비되면 실행 명령을 사용하여 컨테이너를 생성합니다.\n\n가장 일반적인 Dockerfile 명령어:\n\n- FROM: 빌드 프로세스를 시작하는 기본 이미지를 지정합니다.\n- LABEL: 이미지에 메타데이터를 키-값 쌍 형식으로 추가합니다.\n- ARG: 사용자가 docker build 명령을 사용하여 빌더로 전달할 수 있는 변수를 정의합니다.\n- COPY: 호스트 시스템에서 파일이나 디렉토리를 Docker 이미지로 복사합니다.\n- ADD: COPY와 비슷하지만 원격 URL을 가져오고 tar 파일의 자동 추출과 같은 추가 기능을 지원합니다.\n- VOLUME: 볼륨 마운트를 생성합니다.\n- RUN: 이미지 빌드 중에 명령을 실행합니다.\n- CMD: 컨테이너가 시작될 때 실행할 기본 명령을 지정합니다.\n- ENTRYPOINT: 컨테이너가 실행 가능으로 설정됩니다.\n- ENV: 컨테이너 내에서 환경 변수를 설정합니다.\n\n# Docker Compose\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nDocker Compose은 여러 컨테이너 애플리케이션을 관리하기 위한 도구입니다. 단일 YAML 파일을 사용하여 서비스를 정의하고 제어하며, 간단한 명령을 사용하여 전체 애플리케이션 스택을 시작하고 중지하고 관리할 수 있습니다.\n\nDocker Compose 사용 방법:\n\n- docker-compose.yml이라는 YAML 구성 파일을 생성합니다.\n- docker-compose config로 파일을 유효성 검사합니다.\n- docker-compose up을 사용하여 서비스를 시작합니다.\n\n샘플 docker-compose.yml 파일은 데이터베이스와 애플리케이션과 같은 서비스를 정의합니다. 명령어는 다음과 같습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 이미지를 빌드하고 서비스를 시작하려면 `docker-compose up -d`를 사용하세요.\n- 배포 정보를 확인하려면 `docker-compose logs`를 사용하세요.\n- 컨테이너 목록을 보려면 `docker-compose ps`를 사용하세요.\n- 서비스를 중지하려면 `docker-compose stop`을 사용하세요.\n- 모든 컨테이너를 중지하고 제거하려면 `docker-compose down`을 사용하세요.\n\n다음은 MySQL 및 Redis와 함께 Spring Boot 애플리케이션을 위한 Docker Compose YAML 파일(docker-compose.yml)의 예시입니다:\n\n```yaml\nversion: \"3.8\"\n\nservices:\n  spring-boot-app:\n    image: spring-boot-image:latest\n    ports:\n      - \"8080:8080\"\n    depends_on:\n      - mysql-db\n      - redis-cache\n    environment:\n      SPRING_DATASOURCE_URL: jdbc:mysql://mysql-db:3306/database_name\n      SPRING_DATASOURCE_USERNAME: $MYSQLDB_USERNAME\n      SPRING_DATASOURCE_PASSWORD: $MYSQLDB_PASSWORD\n      SPRING_REDIS_HOST: redis-cache\n\n  mysql-db:\n    image: mysql:latest\n    ports:\n      - \"3306:3306\"\n    environment:\n      MYSQL_ROOT_PASSWORD: mysql_root_password\n      MYSQL_DATABASE: database_name\n      MYSQL_USERNAME: $MYSQLDB_USERNAME\n      MYSQL_PASSWORD: $MYSQLDB_PASSWORD\n\n  redis-cache:\n    image: redis:latest\n    ports:\n      - \"6379:6379\"\n```\n\n이 파일에서:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- spring-boot-app은 Spring Boot 애플리케이션을 위한 서비스입니다.\n- mysql-db는 MySQL 데이터베이스를 위한 서비스입니다.\n- redis-cache는 Redis 캐시를 위한 서비스입니다.\n\n각 서비스를 위한 이미지(image)를 정의하고 필요한 포트(ports)를 노출시키며, 데이터베이스 연결 세부 정보를 위한 환경 변수(environment)를 설정합니다.\n\nSpring Boot 앱은 MySQL과 Redis에 의존하며(dependes_on), Spring Boot 앱보다 먼저 시작되도록 합니다.\n\n# Spring Boot으로 Docker 이미지 만들기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nSpring Boot 2.3에서는 Spring Boot 애플리케이션용 Docker 이미지를 만드는 간단하고 효율적인 방법을 소개했습니다. 기존에는 Docker 이미지를 Dockerfile 및 docker build 명령을 사용하여 만들었지만, 이 방법은 몇 가지 단점이 있었습니다.\n첫째로 Spring Boot이 생성한 fat jar에 의존했기 때문에, 특히 컨테이너 환경에서 부팅 시간에 영향을 줄 수 있습니다. 이를 해결하기 위해 jar 파일의 폭발된 내용을 포함할 수 있습니다.\n둘째로 Docker 이미지는 계층으로 구성됩니다. Spring Boot fat jar을 사용하면 모든 애플리케이션 코드와 타사 라이브러리가 하나의 계층으로 묶입니다. 이는 작은 코드 변경이라도 전체 계층을 다시 빌드해야 한다는 것을 의미합니다.\n이미지를 빌드하기 전에 jar 파일을 폭파시키면 애플리케이션 코드와 타사 라이브러리가 별도 계층으로 구성됩니다. 이를 통해 Docker의 캐싱 메커니즘을 활용할 수 있습니다. 결과적으로 코드 변경이 발생하면 해당 계층만 재빌드하면 되어 효율성이 크게 향상되고 빌드 시간이 줄어듭니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nSpring Boot 2.3에서 소개된 두 가지 새로운 기능은 이미지 작성 기술을 개선하는 데 도움이 되었습니다: Buildpacks와 Layered jars support.\n\n## Buildpacks\n\nBuildpacks는 Docker 이미지 작성을 간편화하여 필요한 프레임워크 및 응용 프로그램 종속성을 자동으로 제공하여 Dockerfile이 필요하지 않도록합니다. Spring Boot에서는 Maven과 Gradle이 buildpacks를 지원하여 간편한 이미지 생성을 가능하게합니다.\n\n예를 들어, Maven을 사용하여 pom.xml 파일을 변경하지 않고 다음을 실행합니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n./mvnw spring-boot:build-image -Dspring-boot.build-image.imageName=myorg/app\n```\n\nGradle를 사용하는 경우:\n\n```js\n./gradlew bootBuildImage --imageName=myorg/app\n```\n\n첫 번째 빌드는 컨테이너 이미지 및 JDK를 다운로드해야 하기 때문에 시간이 오래 걸릴 수 있지만, 그 이후의 빌드는 빠릅니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 명령어는 먼저 표준 Fat Jar를 빌드한 다음 Docker 이미지 생성을 시작합니다. Packeto 빌더를 사용하여 클라우드 네이티브 빌드팩을 구현합니다. 이는 프로젝트를 분석하고 필요한 프레임워크 및 라이브러리(예: Spring Boot)를 식별하여 이미지에 추가합니다.\n\n이후의 빌드는 Docker의 레이어링을 활용하여, 애플리케이션 코드만 변경될 때에는 빌드 시간을 단축할 수 있습니다. 이 효율성은 빌드팩을 통해 도커 이미지를 생성하는 데 간편하고 빠른 옵션으로 만들어줍니다.\n\n## 계층화된 JARS\n\nSpring Boot은 jar에 레이어 인덱스 파일을 추가하는 것을 지원합니다. 이 인덱스는 레이어 목록과 해당 레이어에 포함되어야 하는 jar의 부분을 제공합니다. 인덱스의 레이어 목록은 Docker/OCI 이미지에 추가할 순서로 정렬됩니다. 기본적으로 다음 레이어가 지원됩니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 종속성\n- spring-boot-loader\n- snapshot-dependencies\n- application\n\n다음은 layers.idx 파일의 예시를 보여줍니다:\n\n```js\n- \"dependencies\":\n  - BOOT-INF/lib/library1.jar\n  - BOOT-INF/lib/library2.jar\n- \"spring-boot-loader\":\n  - org/springframework/boot/loader/launch/JarLauncher.class\n  - ... <other classes>\n- \"snapshot-dependencies\":\n  - BOOT-INF/lib/library3-SNAPSHOT.jar\n- \"application\":\n  - META-INF/MANIFEST.MF\n  - BOOT-INF/classes/a/b/C.class\n```\n\n이 레이어링은 응용 프로그램 빌드 간에 얼마나 자주 변경될 수 있는지에 따라 코드를 분리하는 데 사용됩니다. 라이브러리 코드는 빌드 간에 변경될 가능성이 낮기 때문에 캐시로부터 레이어를 재사용할 수 있도록 자체 레이어에 배치됩니다. 응용 프로그램 코드는 빌드 간에 변경될 가능성이 더 높기 때문에 별도의 레이어에 격리됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nDocker 이미지를 만드는 데 이것을 어떻게 활용할 수 있는지 살펴보겠습니다.\n\n- 계층화된 JAR 생성: 먼저 pom.xml 파일의 Spring Boot Maven 플러그인에 계층 구성을 추가하세요. 아래는 예시 스니펫입니다:\n\n```js\n<plugin>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-maven-plugin</artifactId>\n  <configuration>\n    <layers>\n      <enabled>true</enabled>\n    </layers>\n  </configuration>\n</plugin>\n```\n\n- JAR 재빌드: pom.xml을 구성한 후에는 mvn clean package를 사용하여 Spring Boot JAR을 재빌드하여 새로운 계층화된 JAR을 생성하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n애플리케이션의 루트 디렉토리로 이동한 다음 다음 명령어를 실행하여 레이어와 그 순서를 표시하세요:\n\n```js\njava -Djarmode=layertools -jar target/app.jar list\n```\n\n- 레이어 도구(jar 모드)를 사용하여 jar 파일을 실행하세요:\n\n```js\n$ java -Djarmode=layertools -jar app.jar\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- Dockerfile 생성하기: Docker 이미지에 이러한 레이어들을 포함하는 가장 쉬운 방법은 Dockerfile을 사용하는 것입니다:\n\n```js\nFROM eclipse-temurin:17-jre as builder\n\nWORKDIR application\nARG JAR_FILE=target/*.jar\nCOPY ${JAR_FILE} application.jar\nRUN java -Djarmode=layertools -jar application.jar extract\n\nFROM eclipse-temurin:17-jre\nWORKDIR application\n\nCOPY --from=build application/dependencies/ ./\nCOPY --from=build application/spring-boot-loader/ ./\nCOPY --from=build application/snapshot-dependencies/ ./\nCOPY --from=build application/application/ ./\n\nENTRYPOINT [\"java\", \"org.springframework.boot.loader.JarLauncher\"]\n```\n\n이 Dockerfile에서는 우리의 fat jar를 별도의 레이어로 분리하고 각 레이어를 Docker 이미지에 추가하는 방법을 제시했습니다. COPY 명령을 사용할 때마다 Docker 이미지에 새로운 레이어가 생성됩니다.\n\n- Docker 이미지 빌드하기: 위의 Dockerfile이 현재 디렉토리에 있다고 가정하면, 도커 이미지는 docker build . 명령을 사용하여 빌드할 수 있습니다. 또는 다음 예시와 같이 애플리케이션 jar 파일의 경로를 지정할 수도 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n$ docker build --build-arg JAR_FILE=path/to/app.jar .\n```\n\n# Jib을 사용하여 Java 컨테이너 빌드하기\n\nJib은 구글이 개발한 Java 도구로 Java 앱을 위한 Docker 이미지를 쉽게 빌드할 수 있습니다. Dockerfile을 작성할 필요도 없고 시스템에 Docker를 설치할 필요도 없어요.\n\nJib은 의존성, 리소스, 클래스와 같은 애플리케이션을 구별하는 레이어로 구성하고 Docker 이미지 레이어 캐싱을 이용하여 변경 사항만 다시 빌드하는 방식으로 빌드를 빠르게 유지합니다. Jib의 레이어 구조와 작은 베이스 이미지는 전체 이미지 크기를 작게 유지하여 성능과 이식성을 향상시킵니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n배포하기 전에 Docker 저장소에 대한 로컬 인증 설정을 하는 것이 매우 중요합니다. 예를 들어 DockerHub 자격 증명을 .m2/settings.xml 파일에 포함할 수 있습니다. 그러나 이 파일에 암호를 평문으로 저장하는 것은 권장되지 않습니다.\n\n```js\n<settings>\n  ...\n  <servers>\n    ...\n    <server>\n      <id>registry.hub.docker.com</id>\n      <username>내_사용자명</username>\n      <password>{내_시크릿}</password>\n    </server>\n  </servers>\n</settings>\n```\n\nid 필드가 이 자격 증명이 지정된 레지스트리 서버와 일치하는지 확인하세요.\n\nJib를 사용하여 Docker Hub에 배포하려면 jib-maven-plugin이나 그와 동등한 Gradle을 사용할 수 있습니다. 간단히 다음과 같은 명령을 실행하면 됩니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nmvn compile com.google.cloud.tools:jib-maven-plugin:3.1.1:build -Dimage=$IMAGE_PATH\n```\n\n예를 들어, 이미지를 DockerHub에 업로드하려면 $IMAGE_PATH를 registry.hub.docker.com/my-repo/my-app과 같은 값으로 설정하세요.\n\n이 명령은 앱의 Docker 이미지를 빌드하고 DockerHub로 푸시합니다. Google Container Registry나 Amazon Elastic Container Registry와 같은 다른 레지스트리에도 비슷한 방식으로 이미지를 업로드할 수 있습니다.\n\n## 추가 커스터마이징\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nJib 빌드를 Dockerfile과 비슷한 방식으로 사용자 정의할 수 있습니다. 이는 환경 변수를 추가하는 등의 방식입니다. 아래는 그 방법입니다:\n\n```js\n<project>\n  ...\n  <build>\n    <plugins>\n      ...\n      <plugin>\n        <groupId>com.google.cloud.tools</groupId>\n        <artifactId>jib-maven-plugin</artifactId>\n        <version>3.1.1</version>\n        <configuration>\n          <to>\n            <image>${IMAGE_PATH}</image>\n          </to>\n          <container>\n            <environment>\n              <ENV_VAR>VALUE</ENV_VAR>\n            </environment>\n          </container>\n        </configuration>\n      </plugin>\n      ...\n    </plugins>\n  </build>\n  ...\n</project>\n```\n\n이 변경으로 Maven 명령을 간소화할 수 있습니다:\n\n```js\nmvn compile jib:build\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n옵션으로 Docker를 설치한 경우, 로컬 Docker 설치로 빌드할 수 있습니다. 이렇게 하면 이미지를 다른 로컬 컨테이너처럼 검사하거나 실행할 수 있습니다:\n\n```js\nmvn compile jib:dockerBuild\n```\n\n# 결론\n\nDocker는 현대 소프트웨어 개발에 있어 필수 요소가 되었습니다. 민첩성과 확장성을 제공합니다. 본 문서에서는 Docker의 기초를 소개하고 Maven을 사용하여 Spring Boot 앱용 이미지를 생성하는 방법을 알아보았습니다. Spring Boot 2.3은 효율적인 이미지 생성을 위해 Buildpacks와 Layered Jars를 도입하였습니다. Google의 Jib는 Java 앱을 위한 Docker 이미지 생성을 간단하게 해줍니다. 이러한 도구들을 활용하면 배포를 간소화하고 생산성을 향상시킬 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-06-19-WelcometoDockerforSpringBootDevelopers_0.png"},"coverImage":"/assets/img/2024-06-19-WelcometoDockerforSpringBootDevelopers_0.png","tag":["Tech"],"readingTime":16},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p><img src=\"/assets/img/2024-06-19-WelcometoDockerforSpringBootDevelopers_0.png\" alt=\"Docker\"></p>\n<p>현대 소프트웨어 아키텍처에서 컨테이너는 선택사항에서 필수 요소로 전환되어 가고 있습니다. 다양한 플랫폼에서 소프트웨어를 이주하고 실행하는 민첩한 방법을 제공하여 전통적인 웹 서버 모델에 비해 속도, 이식성, 확장성 등의 혜택을 제공합니다. 이러한 작고 유연한 컨테이너는 더 큰이고 적응력이 덜한 세팅을 대체하며 특히 마이크로서비스를 향상시킵니다.</p>\n<p>본 문서는 Docker를 소개하며, 주요 클라우드 제공업체와의 호환성을 위해 선택된 컨테이너 기술입니다. Docker 기본 사항 및 Maven을 사용한 Spring Boot에서 Docker 실행 및 이미지 작성과 같은 실용적 작업에 대해 다룹니다.</p>\n<h1>Docker란 무엇인가요?</h1>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>도커는 2013년 Solomon Hykes에 의해 개발된 널리 사용되는 오픈 소스 컨테이너 엔진입니다. 초기에는 편리성으로 인식되었지만, 응용 프로그램 내에서 컨테이너를 관리하고 시작하는 데 중요한 도구로 진화하여 가상 머신(VM)과 같은 하드웨어 할당 대신 물리적 머신에서 자원 공유를 가능케했습니다.</p>\n<p>IBM, Microsoft, Google 등 주요 기업들의 지원으로 인해 도커는 소프트웨어 개발자들을 위한 필수 도구로 부상했습니다.</p>\n<p>서버, REST API 및 명령줄 인터페이스(CLI)로 구성된 Docker Engine은 도커 시스템의 핵심을 형성하여 서버 간에 컨테이너 배포를 용이하게 합니다.</p>\n<h1>도커 엔진 구성 요소</h1>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>기본 구성 요소는 다음과 같습니다:</p>\n<ul>\n<li>Docker 데몬: Docker 이미지를 생성하고 관리하는 서버(dockerd)로, REST API 및 CLI로부터 명령을 받습니다.</li>\n<li>Docker 클라이언트: 사용자는 Docker 클라이언트를 통해 Docker와 상호 작용하며, 이 클라이언트는 데몬에 명령을 전송합니다.</li>\n<li>Docker 레지스트리: Docker 이미지를 저장하는 곳으로, 공개(예: Docker 허브) 또는 비공개 레지스트리 옵션이 있습니다.</li>\n<li>Docker 이미지: Docker 컨테이너를 생성하는 지침을 포함하는 읽기 전용 템플릿으로, 레지스트리에서 가져오거나 Dockerfile을 사용하여 새 이미지를 만들 수 있습니다.</li>\n<li>Docker 컨테이너: 'docker run' 명령을 사용하여 Docker 이미지에서 만들어지며, 응용 프로그램 및 환경을 호스팅하며 Docker API 또는 CLI를 통해 관리할 수 있습니다.</li>\n<li>Docker 볼륨: Docker 컨테이너에서 생성되고 사용되는 데이터에 대한 우선적인 저장 메커니즘으로, Docker API 또는 CLI를 통해 관리할 수 있습니다.</li>\n<li>Docker 네트워크: 컨테이너가 통신을위한 여러 네트워크에 연결되도록 허용하며, 다섯 가지 네트워크 드라이버 유형이 있습니다: bridge, host, overlay, none 및 macvlan.</li>\n</ul>\n<h1>Dockerfiles</h1>\n<p>Dockerfile은 Docker 이미지를 자동으로 생성하고 구성하는 지침을 포함하는 텍스트 파일입니다. Linux와 유사한 명령을 사용하여 이미지 생성을 간소화하고 가독성을 향상시킵니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>Dockerfile을 생성한 후에는 Docker 이미지를 빌드하기 위해 docker build 명령을 실행합니다. 그런 다음, Docker 이미지가 준비되면 실행 명령을 사용하여 컨테이너를 생성합니다.</p>\n<p>가장 일반적인 Dockerfile 명령어:</p>\n<ul>\n<li>FROM: 빌드 프로세스를 시작하는 기본 이미지를 지정합니다.</li>\n<li>LABEL: 이미지에 메타데이터를 키-값 쌍 형식으로 추가합니다.</li>\n<li>ARG: 사용자가 docker build 명령을 사용하여 빌더로 전달할 수 있는 변수를 정의합니다.</li>\n<li>COPY: 호스트 시스템에서 파일이나 디렉토리를 Docker 이미지로 복사합니다.</li>\n<li>ADD: COPY와 비슷하지만 원격 URL을 가져오고 tar 파일의 자동 추출과 같은 추가 기능을 지원합니다.</li>\n<li>VOLUME: 볼륨 마운트를 생성합니다.</li>\n<li>RUN: 이미지 빌드 중에 명령을 실행합니다.</li>\n<li>CMD: 컨테이너가 시작될 때 실행할 기본 명령을 지정합니다.</li>\n<li>ENTRYPOINT: 컨테이너가 실행 가능으로 설정됩니다.</li>\n<li>ENV: 컨테이너 내에서 환경 변수를 설정합니다.</li>\n</ul>\n<h1>Docker Compose</h1>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>Docker Compose은 여러 컨테이너 애플리케이션을 관리하기 위한 도구입니다. 단일 YAML 파일을 사용하여 서비스를 정의하고 제어하며, 간단한 명령을 사용하여 전체 애플리케이션 스택을 시작하고 중지하고 관리할 수 있습니다.</p>\n<p>Docker Compose 사용 방법:</p>\n<ul>\n<li>docker-compose.yml이라는 YAML 구성 파일을 생성합니다.</li>\n<li>docker-compose config로 파일을 유효성 검사합니다.</li>\n<li>docker-compose up을 사용하여 서비스를 시작합니다.</li>\n</ul>\n<p>샘플 docker-compose.yml 파일은 데이터베이스와 애플리케이션과 같은 서비스를 정의합니다. 명령어는 다음과 같습니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<ul>\n<li>이미지를 빌드하고 서비스를 시작하려면 <code>docker-compose up -d</code>를 사용하세요.</li>\n<li>배포 정보를 확인하려면 <code>docker-compose logs</code>를 사용하세요.</li>\n<li>컨테이너 목록을 보려면 <code>docker-compose ps</code>를 사용하세요.</li>\n<li>서비스를 중지하려면 <code>docker-compose stop</code>을 사용하세요.</li>\n<li>모든 컨테이너를 중지하고 제거하려면 <code>docker-compose down</code>을 사용하세요.</li>\n</ul>\n<p>다음은 MySQL 및 Redis와 함께 Spring Boot 애플리케이션을 위한 Docker Compose YAML 파일(docker-compose.yml)의 예시입니다:</p>\n<pre><code class=\"hljs language-yaml\"><span class=\"hljs-attr\">version:</span> <span class=\"hljs-string\">\"3.8\"</span>\n\n<span class=\"hljs-attr\">services:</span>\n  <span class=\"hljs-attr\">spring-boot-app:</span>\n    <span class=\"hljs-attr\">image:</span> <span class=\"hljs-string\">spring-boot-image:latest</span>\n    <span class=\"hljs-attr\">ports:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">\"8080:8080\"</span>\n    <span class=\"hljs-attr\">depends_on:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">mysql-db</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">redis-cache</span>\n    <span class=\"hljs-attr\">environment:</span>\n      <span class=\"hljs-attr\">SPRING_DATASOURCE_URL:</span> <span class=\"hljs-string\">jdbc:mysql://mysql-db:3306/database_name</span>\n      <span class=\"hljs-attr\">SPRING_DATASOURCE_USERNAME:</span> <span class=\"hljs-string\">$MYSQLDB_USERNAME</span>\n      <span class=\"hljs-attr\">SPRING_DATASOURCE_PASSWORD:</span> <span class=\"hljs-string\">$MYSQLDB_PASSWORD</span>\n      <span class=\"hljs-attr\">SPRING_REDIS_HOST:</span> <span class=\"hljs-string\">redis-cache</span>\n\n  <span class=\"hljs-attr\">mysql-db:</span>\n    <span class=\"hljs-attr\">image:</span> <span class=\"hljs-string\">mysql:latest</span>\n    <span class=\"hljs-attr\">ports:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">\"3306:3306\"</span>\n    <span class=\"hljs-attr\">environment:</span>\n      <span class=\"hljs-attr\">MYSQL_ROOT_PASSWORD:</span> <span class=\"hljs-string\">mysql_root_password</span>\n      <span class=\"hljs-attr\">MYSQL_DATABASE:</span> <span class=\"hljs-string\">database_name</span>\n      <span class=\"hljs-attr\">MYSQL_USERNAME:</span> <span class=\"hljs-string\">$MYSQLDB_USERNAME</span>\n      <span class=\"hljs-attr\">MYSQL_PASSWORD:</span> <span class=\"hljs-string\">$MYSQLDB_PASSWORD</span>\n\n  <span class=\"hljs-attr\">redis-cache:</span>\n    <span class=\"hljs-attr\">image:</span> <span class=\"hljs-string\">redis:latest</span>\n    <span class=\"hljs-attr\">ports:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">\"6379:6379\"</span>\n</code></pre>\n<p>이 파일에서:</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<ul>\n<li>spring-boot-app은 Spring Boot 애플리케이션을 위한 서비스입니다.</li>\n<li>mysql-db는 MySQL 데이터베이스를 위한 서비스입니다.</li>\n<li>redis-cache는 Redis 캐시를 위한 서비스입니다.</li>\n</ul>\n<p>각 서비스를 위한 이미지(image)를 정의하고 필요한 포트(ports)를 노출시키며, 데이터베이스 연결 세부 정보를 위한 환경 변수(environment)를 설정합니다.</p>\n<p>Spring Boot 앱은 MySQL과 Redis에 의존하며(dependes_on), Spring Boot 앱보다 먼저 시작되도록 합니다.</p>\n<h1>Spring Boot으로 Docker 이미지 만들기</h1>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>Spring Boot 2.3에서는 Spring Boot 애플리케이션용 Docker 이미지를 만드는 간단하고 효율적인 방법을 소개했습니다. 기존에는 Docker 이미지를 Dockerfile 및 docker build 명령을 사용하여 만들었지만, 이 방법은 몇 가지 단점이 있었습니다.\n첫째로 Spring Boot이 생성한 fat jar에 의존했기 때문에, 특히 컨테이너 환경에서 부팅 시간에 영향을 줄 수 있습니다. 이를 해결하기 위해 jar 파일의 폭발된 내용을 포함할 수 있습니다.\n둘째로 Docker 이미지는 계층으로 구성됩니다. Spring Boot fat jar을 사용하면 모든 애플리케이션 코드와 타사 라이브러리가 하나의 계층으로 묶입니다. 이는 작은 코드 변경이라도 전체 계층을 다시 빌드해야 한다는 것을 의미합니다.\n이미지를 빌드하기 전에 jar 파일을 폭파시키면 애플리케이션 코드와 타사 라이브러리가 별도 계층으로 구성됩니다. 이를 통해 Docker의 캐싱 메커니즘을 활용할 수 있습니다. 결과적으로 코드 변경이 발생하면 해당 계층만 재빌드하면 되어 효율성이 크게 향상되고 빌드 시간이 줄어듭니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>Spring Boot 2.3에서 소개된 두 가지 새로운 기능은 이미지 작성 기술을 개선하는 데 도움이 되었습니다: Buildpacks와 Layered jars support.</p>\n<h2>Buildpacks</h2>\n<p>Buildpacks는 Docker 이미지 작성을 간편화하여 필요한 프레임워크 및 응용 프로그램 종속성을 자동으로 제공하여 Dockerfile이 필요하지 않도록합니다. Spring Boot에서는 Maven과 Gradle이 buildpacks를 지원하여 간편한 이미지 생성을 가능하게합니다.</p>\n<p>예를 들어, Maven을 사용하여 pom.xml 파일을 변경하지 않고 다음을 실행합니다:</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-js\">./mvnw spring-<span class=\"hljs-attr\">boot</span>:build-image -<span class=\"hljs-title class_\">Dspring</span>-boot.<span class=\"hljs-property\">build</span>-image.<span class=\"hljs-property\">imageName</span>=myorg/app\n</code></pre>\n<p>Gradle를 사용하는 경우:</p>\n<pre><code class=\"hljs language-js\">./gradlew bootBuildImage --imageName=myorg/app\n</code></pre>\n<p>첫 번째 빌드는 컨테이너 이미지 및 JDK를 다운로드해야 하기 때문에 시간이 오래 걸릴 수 있지만, 그 이후의 빌드는 빠릅니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>이 명령어는 먼저 표준 Fat Jar를 빌드한 다음 Docker 이미지 생성을 시작합니다. Packeto 빌더를 사용하여 클라우드 네이티브 빌드팩을 구현합니다. 이는 프로젝트를 분석하고 필요한 프레임워크 및 라이브러리(예: Spring Boot)를 식별하여 이미지에 추가합니다.</p>\n<p>이후의 빌드는 Docker의 레이어링을 활용하여, 애플리케이션 코드만 변경될 때에는 빌드 시간을 단축할 수 있습니다. 이 효율성은 빌드팩을 통해 도커 이미지를 생성하는 데 간편하고 빠른 옵션으로 만들어줍니다.</p>\n<h2>계층화된 JARS</h2>\n<p>Spring Boot은 jar에 레이어 인덱스 파일을 추가하는 것을 지원합니다. 이 인덱스는 레이어 목록과 해당 레이어에 포함되어야 하는 jar의 부분을 제공합니다. 인덱스의 레이어 목록은 Docker/OCI 이미지에 추가할 순서로 정렬됩니다. 기본적으로 다음 레이어가 지원됩니다:</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<ul>\n<li>종속성</li>\n<li>spring-boot-loader</li>\n<li>snapshot-dependencies</li>\n<li>application</li>\n</ul>\n<p>다음은 layers.idx 파일의 예시를 보여줍니다:</p>\n<pre><code class=\"hljs language-js\">- <span class=\"hljs-string\">\"dependencies\"</span>:\n  - <span class=\"hljs-variable constant_\">BOOT</span>-<span class=\"hljs-variable constant_\">INF</span>/lib/library1.<span class=\"hljs-property\">jar</span>\n  - <span class=\"hljs-variable constant_\">BOOT</span>-<span class=\"hljs-variable constant_\">INF</span>/lib/library2.<span class=\"hljs-property\">jar</span>\n- <span class=\"hljs-string\">\"spring-boot-loader\"</span>:\n  - org/springframework/boot/loader/launch/<span class=\"hljs-title class_\">JarLauncher</span>.<span class=\"hljs-property\">class</span>\n  - ... &#x3C;other classes>\n- <span class=\"hljs-string\">\"snapshot-dependencies\"</span>:\n  - <span class=\"hljs-variable constant_\">BOOT</span>-<span class=\"hljs-variable constant_\">INF</span>/lib/library3-<span class=\"hljs-variable constant_\">SNAPSHOT</span>.<span class=\"hljs-property\">jar</span>\n- <span class=\"hljs-string\">\"application\"</span>:\n  - <span class=\"hljs-variable constant_\">META</span>-<span class=\"hljs-variable constant_\">INF</span>/<span class=\"hljs-variable constant_\">MANIFEST</span>.<span class=\"hljs-property\">MF</span>\n  - <span class=\"hljs-variable constant_\">BOOT</span>-<span class=\"hljs-variable constant_\">INF</span>/classes/a/b/C.<span class=\"hljs-property\">class</span>\n</code></pre>\n<p>이 레이어링은 응용 프로그램 빌드 간에 얼마나 자주 변경될 수 있는지에 따라 코드를 분리하는 데 사용됩니다. 라이브러리 코드는 빌드 간에 변경될 가능성이 낮기 때문에 캐시로부터 레이어를 재사용할 수 있도록 자체 레이어에 배치됩니다. 응용 프로그램 코드는 빌드 간에 변경될 가능성이 더 높기 때문에 별도의 레이어에 격리됩니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>Docker 이미지를 만드는 데 이것을 어떻게 활용할 수 있는지 살펴보겠습니다.</p>\n<ul>\n<li>계층화된 JAR 생성: 먼저 pom.xml 파일의 Spring Boot Maven 플러그인에 계층 구성을 추가하세요. 아래는 예시 스니펫입니다:</li>\n</ul>\n<pre><code class=\"hljs language-js\">&#x3C;plugin>\n  <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">groupId</span>></span>org.springframework.boot<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">groupId</span>></span></span>\n  <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">artifactId</span>></span>spring-boot-maven-plugin<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">artifactId</span>></span></span>\n  <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">configuration</span>></span>\n    <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">layers</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">enabled</span>></span>true<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">enabled</span>></span>\n    <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">layers</span>></span>\n  <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">configuration</span>></span></span>\n&#x3C;/plugin>\n</code></pre>\n<ul>\n<li>JAR 재빌드: pom.xml을 구성한 후에는 mvn clean package를 사용하여 Spring Boot JAR을 재빌드하여 새로운 계층화된 JAR을 생성하세요.</li>\n</ul>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>애플리케이션의 루트 디렉토리로 이동한 다음 다음 명령어를 실행하여 레이어와 그 순서를 표시하세요:</p>\n<pre><code class=\"hljs language-js\">java -<span class=\"hljs-title class_\">Djarmode</span>=layertools -jar target/app.<span class=\"hljs-property\">jar</span> list\n</code></pre>\n<ul>\n<li>레이어 도구(jar 모드)를 사용하여 jar 파일을 실행하세요:</li>\n</ul>\n<pre><code class=\"hljs language-js\">$ java -<span class=\"hljs-title class_\">Djarmode</span>=layertools -jar app.<span class=\"hljs-property\">jar</span>\n</code></pre>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<ul>\n<li>Dockerfile 생성하기: Docker 이미지에 이러한 레이어들을 포함하는 가장 쉬운 방법은 Dockerfile을 사용하는 것입니다:</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable constant_\">FROM</span> eclipse-<span class=\"hljs-attr\">temurin</span>:<span class=\"hljs-number\">17</span>-jre <span class=\"hljs-keyword\">as</span> builder\n\n<span class=\"hljs-variable constant_\">WORKDIR</span> application\n<span class=\"hljs-variable constant_\">ARG</span> <span class=\"hljs-variable constant_\">JAR_FILE</span>=target<span class=\"hljs-comment\">/*.jar\nCOPY ${JAR_FILE} application.jar\nRUN java -Djarmode=layertools -jar application.jar extract\n\nFROM eclipse-temurin:17-jre\nWORKDIR application\n\nCOPY --from=build application/dependencies/ ./\nCOPY --from=build application/spring-boot-loader/ ./\nCOPY --from=build application/snapshot-dependencies/ ./\nCOPY --from=build application/application/ ./\n\nENTRYPOINT [\"java\", \"org.springframework.boot.loader.JarLauncher\"]\n</span></code></pre>\n<p>이 Dockerfile에서는 우리의 fat jar를 별도의 레이어로 분리하고 각 레이어를 Docker 이미지에 추가하는 방법을 제시했습니다. COPY 명령을 사용할 때마다 Docker 이미지에 새로운 레이어가 생성됩니다.</p>\n<ul>\n<li>Docker 이미지 빌드하기: 위의 Dockerfile이 현재 디렉토리에 있다고 가정하면, 도커 이미지는 docker build . 명령을 사용하여 빌드할 수 있습니다. 또는 다음 예시와 같이 애플리케이션 jar 파일의 경로를 지정할 수도 있습니다:</li>\n</ul>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-js\">$ docker build --build-arg <span class=\"hljs-variable constant_\">JAR_FILE</span>=path/to/app.<span class=\"hljs-property\">jar</span> .\n</code></pre>\n<h1>Jib을 사용하여 Java 컨테이너 빌드하기</h1>\n<p>Jib은 구글이 개발한 Java 도구로 Java 앱을 위한 Docker 이미지를 쉽게 빌드할 수 있습니다. Dockerfile을 작성할 필요도 없고 시스템에 Docker를 설치할 필요도 없어요.</p>\n<p>Jib은 의존성, 리소스, 클래스와 같은 애플리케이션을 구별하는 레이어로 구성하고 Docker 이미지 레이어 캐싱을 이용하여 변경 사항만 다시 빌드하는 방식으로 빌드를 빠르게 유지합니다. Jib의 레이어 구조와 작은 베이스 이미지는 전체 이미지 크기를 작게 유지하여 성능과 이식성을 향상시킵니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>배포하기 전에 Docker 저장소에 대한 로컬 인증 설정을 하는 것이 매우 중요합니다. 예를 들어 DockerHub 자격 증명을 .m2/settings.xml 파일에 포함할 수 있습니다. 그러나 이 파일에 암호를 평문으로 저장하는 것은 권장되지 않습니다.</p>\n<pre><code class=\"hljs language-js\">&#x3C;settings>\n  ...\n  &#x3C;servers>\n    ...\n    &#x3C;server>\n      <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">id</span>></span>registry.hub.docker.com<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">id</span>></span></span>\n      <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">username</span>></span>내_사용자명<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">username</span>></span></span>\n      <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">password</span>></span>{내_시크릿}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">password</span>></span></span>\n    &#x3C;/server>\n  &#x3C;/servers>\n&#x3C;/settings>\n</code></pre>\n<p>id 필드가 이 자격 증명이 지정된 레지스트리 서버와 일치하는지 확인하세요.</p>\n<p>Jib를 사용하여 Docker Hub에 배포하려면 jib-maven-plugin이나 그와 동등한 Gradle을 사용할 수 있습니다. 간단히 다음과 같은 명령을 실행하면 됩니다:</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-js\">mvn compile com.<span class=\"hljs-property\">google</span>.<span class=\"hljs-property\">cloud</span>.<span class=\"hljs-property\">tools</span>:jib-maven-<span class=\"hljs-attr\">plugin</span>:<span class=\"hljs-number\">3.1</span><span class=\"hljs-number\">.1</span>:build -<span class=\"hljs-title class_\">Dimage</span>=$IMAGE_PATH\n</code></pre>\n<p>예를 들어, 이미지를 DockerHub에 업로드하려면 $IMAGE_PATH를 registry.hub.docker.com/my-repo/my-app과 같은 값으로 설정하세요.</p>\n<p>이 명령은 앱의 Docker 이미지를 빌드하고 DockerHub로 푸시합니다. Google Container Registry나 Amazon Elastic Container Registry와 같은 다른 레지스트리에도 비슷한 방식으로 이미지를 업로드할 수 있습니다.</p>\n<h2>추가 커스터마이징</h2>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>Jib 빌드를 Dockerfile과 비슷한 방식으로 사용자 정의할 수 있습니다. 이는 환경 변수를 추가하는 등의 방식입니다. 아래는 그 방법입니다:</p>\n<pre><code class=\"hljs language-js\">&#x3C;project>\n  ...\n  &#x3C;build>\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">plugins</span>></span>\n      ...\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">plugin</span>></span>\n        <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">groupId</span>></span>com.google.cloud.tools<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">groupId</span>></span>\n        <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">artifactId</span>></span>jib-maven-plugin<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">artifactId</span>></span>\n        <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">version</span>></span>3.1.1<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">version</span>></span>\n        <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">configuration</span>></span>\n          <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">to</span>></span>\n            <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">image</span>></span>${IMAGE_PATH}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">image</span>></span>\n          <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">to</span>></span>\n          <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">container</span>></span>\n            <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">environment</span>></span>\n              <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">ENV_VAR</span>></span>VALUE<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">ENV_VAR</span>></span>\n            <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">environment</span>></span>\n          <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">container</span>></span>\n        <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">configuration</span>></span>\n      <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">plugin</span>></span>\n      ...\n    <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">plugins</span>></span></span>\n  &#x3C;/build>\n  ...\n&#x3C;/project>\n</code></pre>\n<p>이 변경으로 Maven 명령을 간소화할 수 있습니다:</p>\n<pre><code class=\"hljs language-js\">mvn compile <span class=\"hljs-attr\">jib</span>:build\n</code></pre>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>옵션으로 Docker를 설치한 경우, 로컬 Docker 설치로 빌드할 수 있습니다. 이렇게 하면 이미지를 다른 로컬 컨테이너처럼 검사하거나 실행할 수 있습니다:</p>\n<pre><code class=\"hljs language-js\">mvn compile <span class=\"hljs-attr\">jib</span>:dockerBuild\n</code></pre>\n<h1>결론</h1>\n<p>Docker는 현대 소프트웨어 개발에 있어 필수 요소가 되었습니다. 민첩성과 확장성을 제공합니다. 본 문서에서는 Docker의 기초를 소개하고 Maven을 사용하여 Spring Boot 앱용 이미지를 생성하는 방법을 알아보았습니다. Spring Boot 2.3은 효율적인 이미지 생성을 위해 Buildpacks와 Layered Jars를 도입하였습니다. Google의 Jib는 Java 앱을 위한 Docker 이미지 생성을 간단하게 해줍니다. 이러한 도구들을 활용하면 배포를 간소화하고 생산성을 향상시킬 수 있습니다.</p>\n</body>\n</html>\n"},"__N_SSG":true}