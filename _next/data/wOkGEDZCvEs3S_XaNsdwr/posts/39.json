{"pageProps":{"posts":[{"title":"코틀린 고급 주제 필수","description":"","date":"2024-06-19 13:48","slug":"2024-06-19-KotlinAdvancedTopicsEssential","content":"\nKotlin Multiplatform (KMP)의 공식 릴리스와 안드로이드와의 통합으로 Kotlin은 엄청난 인기를 얻고 있습니다. Kotlin의 매력은 다양성에 있습니다. 개발자들이 단일 언어를 습득하고 백엔드, 프론트엔드(Android, iOS 및 웹)를 포함한 여러 플랫폼에서 활용할 수 있습니다. Kotlin이 계속 성장함에 따라 개발자들은 필수적이고 고급 주제를 탐색하여 기술을 향상시킬 수 있어야 합니다. 이를 통해 예외적인 코딩 표준을 유지하고 산업에서 앞서 나갈 수 있습니다.\n\n![img](/assets/img/2024-06-19-KotlinAdvancedTopicsEssential_0.png)\n\n### 위임\n\nKotlin에서의 위임은 객체가 일부 책임을 다른 객체에 위임할 수 있도록 하는 디자인 패턴입니다. Kotlin은 by 키워드를 사용하여 위임에 대한 내장 지원을 제공합니다. Kotlin에서는 클래스 위임과 속성 위임 두 가지 주요 위임 유형이 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 속성 위임\n\nlazy 위임은 속성이 처음 액세스 될 때만 초기화됩니다. 이는 비용이 많이 드는 객체 초기화나 프로그램 실행 중에만 필요한 속성에 유용합니다. 이를 통해 리소스 사용을 최적화하고 응용 프로그램 성능을 향상시킬 수 있습니다. 기본적으로 lazy 초기화는 스레드 안전합니다.\n\n```js\nval myName: String by lazy {\n    println(\"계산됨\")\n    \"내 이름\"\n}\n```\n\n## 클래스 위임\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n클래스 위임은 한 클래스가 다른 클래스로 메서드 구현을 위임할 수 있게 합니다. 이는 합성을 위해 유용하며 상속 없이 다른 클래스의 동작을 통합할 수 있도록 합니다. 인터페이스 구현 또는 기능을 다른 클래스로 위임함으로써 코드 중복을 피할 수 있습니다.\n\n```kotlin\n    interface Weather {\n        fun currentWeather()\n    }\n\n    class Summer : Weather {\n        override fun currentWeather() {\n            println(\"Current weather is ${javaClass.simpleName}\")\n        }\n    }\n\n    class HolidayPlans(weather: Weather) : Weather by weather {\n    }\n```\n\n# 확장 함수\n\nKotlin의 확장 함수를 사용하면 코드의 재사용성을 높이기 위해 우리만의 유틸리티 함수를 작성할 수 있습니다. 내부적으로 확장 함수는 컴파일 시점에 클래스에 대해 정적으로 해결되며 해당 클래스의 공개 멤버에 액세스할 수 있도록 합니다(소스 코드를 수정하지 않고).\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\nval EMAIL_ADDRESS_PATTERN = Pattern.compile(\n        \"[a-zA-Z0-9\\\\+\\\\.\\\\_\\\\%\\\\-\\\\+]{1,256}\\\\@[a-zA-Z0-9][a-zA-Z0-9\\\\-]{0,64}(\\\\.[a-zA-Z0-9][a-zA-Z0-9\\\\-]{0,25})+\"\n    )\n\n    private fun String.isEmail() =\n        EMAIL_ADDRESS_PATTERN.matcher(this).matches()\n\n    fun verifyCredential(emailId: String) {\n        println(emailId.isEmail())\n    }\n```\n\n# 고차 함수\n\n고차 함수를 사용하면 함수를 인수로 사용하거나 함수를 반환하거나 둘 다를 할 수 있습니다. 이를 통해 추상 코드를 생성하고 특정 상황에서 함수 구현을 선언하고 다른 상황에서 실행할 수 있습니다. 이를 통해 강력한 추상화와 더 깨끗하고 모듈화된 코드를 작성할 수 있습니다.\n\n## 기본 고차 함수\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\nfun calculate(a: Int, b: Int, operator: (Int, Int) -> Int) {\n  operator(a, b)\n}\n\nfun main() {\n    val sum = calculate(5, 3) { a, b -> a + b }\n    println(\"합계: $sum\") // 합계: 8\n    val product = calculate(5, 3) { a, b -> a * b }\n    println(\"곱셈: $product\") // 곱셈: 15\n}\n```\n\n## 함수 반환\n\n```kotlin\nfun operation(op: String): (Int, Int) -> Int {\n    return when (op) {\n        \"add\" -> { a, b -> a + b }\n        \"multiply\" -> { a, b -> a * b }\n        else -> { _, _ -> 0 }\n    }\n}\n\nfun main() {\n    val addOperation = operation(\"add\")\n    println(\"덧셈: ${addOperation(2, 3)}\") // 덧셈: 5\n    val multiplyOperation = operation(\"multiply\")\n    println(\"곱셈: ${multiplyOperation(2, 3)}\") // 곱셈: 6\n}\n```\n\n- inline: 컴파일러에게 함수의 바이트코드를 호출 지점에 직접 넣도록 요청합니다. 함수 호출 및 람다 생성의 오버헤드를 줄여 성능을 향상시킬 수 있습니다.\n- noinline: 인라인 함수 내 람다 매개변수를 인라인화하지 못하게 합니다. 람다를 저장하거나 전달해야 할 때 유용합니다.\n- crossinline: 인라인 함수 내 람다의 비지역 반환을 방지합니다. 람다가 둘러싸는 함수로부터 반환하지 못하도록하여 람다의 예측 가능한 동작을 보장합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# Sealed Class / Interface\n\nSealed 클래스는 자바 세계의 enum의 고급 버전으로 볼 수 있습니다. 코틀린에서 sealed class와 sealed interface를 모두 선언할 수 있습니다. Sealed 클래스와 sealed interface는 Kotlin에서 제한된 계층 구조를 모델링하는 유용한 도구입니다. 두 가지 중에서 선택하는 것은 상태와 동작을 공유해야 하는지(Sealed class 사용) 또는 동작에 대한 계약을 정의해야 하는지에 따라 다릅니다(Sealed interface 사용).\n\n```js\nsealed interface Polygon {\n    data class Circle(val radius: Double) : Polygon\n    data class Square(val side: Double) : Polygon\n    data object NotAShape : Polygon\n}\n```\n\n```js\nsealed class Shape(area: Double) {\n    data class Circle(val radius: Double) : Shape(3.14* radius* radius)\n    data class Square(val side: Double) : Shape(side * side)\n    data object NotAShape : Shape(0.0)\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 제네릭\n\n제네릭은 Kotlin에서 선언된 클래스, 인터페이스 및 함수에 타입 매개변수를 사용할 수 있는 강력한 도구입니다. 이를 통해 다양한 데이터 유형을 허용하고 타입 안전성을 유지하면서 유연하고 재사용 가능한 코드를 작성할 수 있습니다.\n\n## 제네릭 클래스\n\n```js\nclass Machine<T>(val type: T)\n\nfun main() {\n    val machine1 = Machine(12)\n    val machine2 = Machine(\"optimus\")\n    println(machine1.type) // 12\n    println(machine2.type) // optimus\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 일반 함수들\n\n일반 함수들은 타입 매개변수를 가진 함수들입니다. 이를 통해 우리는 타입 안전성을 희생하지 않고 다른 타입들에 대해 동작하는 함수를 작성할 수 있습니다.\n\n```kotlin\nfun <T> singletonList(item: T): List<T> {\n    return listOf(item)\n}\n\nfun main() {\n    val intList = singletonList(5)\n    println(intList) // [5]\n}\n```\n\n## Variance\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n분산이란 일반적인 유형 간의 서브타이핑 관계를 정의합니다.\n\n- 불변성은 요소를 소비하고 생성할 수 있습니다. `T` 타입의 `Invariant` 클래스입니다.\n\n```kotlin\nclass Invariant<T>(var value: T)\nval intInvariant = Invariant<Int>(12)\n// var anyInvariant : Invariant<Any> = intInvariant // 컴파일 오류\n```\n\n- 공산성은 요소를 생성만 할 수 있습니다. `T`의 슈퍼 클래스는 `T`를 대체할 수 있지만 서브타입은 아닙니다. `out T`입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\nclass Contravariant<out T>(private val value: T) {\n    fun get(): T {\n        return value\n    }\n}\n\nfun main() {\n    val intContravariant = Contravariant<Int>(12)\n    val anyContravariant: Contravariant<Any> = intContravariant\n    // val doubleContravariant : Contravariant<Double> = intContravariant // Compilation error\n}\n```\n\n- Contravariance can only consume elements. The subclasses of T can replace it but not the superclass. `in T`\n\n```kotlin\nclass Contravariant<in T> {\n    fun put(item: T) { println(item) }\n}\n\nfun main() {\n    val numberContravariant = Contravariant<Number>()\n    val doubleContravariant: Contravariant<Double> = numberContravariant\n    // val anyContravariant: Contravariant<Any> = numberContravariant  // Compilation error\n}\n```\n\n# 코루틴\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n코루틴은 가볍고(쓰레드보다 훨씬 가볍습니다). 블로킹하지 않고, 어느 스레드도 차단하지 않지만 코드 실행을 일시 중단하고 다시 시작합니다. 디스패처(dispatchers)와 스코프(scopes)에 따라 코루틴이 널리 분류됩니다.\n\n## 코루틴 스코프\n\n- GlobalScope 어떤 특정 라이프사이클에 바인딩되지 않은 최상위 코루틴을 시작하는 글로벌 스코프\n- lifecycleScope 액티비티나 프래그먼트의 수명주기에 바인딩된 스코프\n- viewModelScope ViewModel 수명주기에 바인딩된 스코프\n\n```js\nGlobalScope.launch {\n    // 오래 실행되는 작업\n}\nlifecycleScope.launch {\n    // 코루틴 코드\n}\nviewModelScope.launch {\n    // 코루틴 코드\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## Coroutine Dispatchers\n\n- `dispatchers.Main`은 주 (UI) 스레드에서 실행됩니다.\n- `dispatchers.IO`는 네트워크 또는 데이터베이스 작업에 사용됩니다.\n- `dispatchers.Default`는 CPU 집약적인 작업에 사용됩니다 (비트맵 작업).\n- `dispatchers.Unconfined`는 호출자 스레드에서 실행되지만 처음 일시 중지 지점까지만 실행됩니다.\n\n## Builders\n\n- `launch`는 새로운 코루틴을 시작하고 결과를 반환하지 않습니다. Fire-and-forget 방식입니다.\n- `async`는 새로운 코루틴을 시작하고 향후 결과를 나타내는 Deferred를 반환합니다. 결과를 얻으려면 `await`를 사용하세요.\n- `runBlocking`은 해당 블록이 완료될 때까지 현재 스레드를 차단합니다. 주로 메인 함수 및 테스트에서 사용됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\nCoroutineScope(Dispatchers.Main).launch {\n    // 코루틴 코드\n}\n\nval deferred = CoroutineScope(Dispatchers.Default).async {\n    // 비동기 작업\n    \"결과\"\n}\nrunBlocking {\n    val result = deferred.await()\n    println(result)\n}\n\nrunBlocking {\n    // 코루틴이 완료될 때까지 블록됨\n}\n```\n","ogImage":{"url":"/assets/img/2024-06-19-KotlinAdvancedTopicsEssential_0.png"},"coverImage":"/assets/img/2024-06-19-KotlinAdvancedTopicsEssential_0.png","tag":["Tech"],"readingTime":10},{"title":"픽셀 완벽 모든 화면, 모든 폴드를 위한 디자인","description":"","date":"2024-06-19 13:46","slug":"2024-06-19-PixelPerfectDesigningforEveryScreenEveryFold","content":"\n모바일 기기 다양성이 이전에 없던 수준으로 증가했습니다. 앱 개발자들은 스마트폰, 태블릿, 접이식 기기와 같은 다양한 기기들이 각각 다른 화면 크기, 해상도 및 방향을 가지고 있기 때문에 많은 도전을 겪습니다. 이 넓은 범위에서 부드러운 사용자 경험을 만들기 위해서는 창의력 뿐만 아니라 다양한 화면 크기에 관련된 미묘한 부분을 깊이 이해해야 합니다.\n\n본 문서는 다양한 화면을 위해 응용프로그램을 생성하고 테스트하는 과학과 예술을 탐구하며, 다양한 형태 요소를 가진 기기에 대한 디자인 세부 사항에 대한 통찰력 있는 정보를 제공합니다. 태블릿에서 접이식 폰으로의 환경은 항상 변화하기 때문에, 개발자들은 모든 기기에서 앱이 멋지게 보이고 완벽하게 작동하도록 보장하기 위해 항상 최신 정보를 유지해야 합니다.\n\n다양한 화면 크기에 대한 디자인 시 고려해야 할 중요한 요소와 Jetpack Compose 및 XML 레이아웃을 사용하여 레이아웃을 관리하는 실용적인 조언에 대해 논의할 것입니다. 또한 사용자가 기능성 또는 스타일에 어긋나지 않고 세로 및 가로 모드 사이를 쉽게 전환할 수 있도록 하는 다양한 화면 방향을 지원하는 것이 얼마나 중요한지에 대해 이야기하겠습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n테스트는 개발 과정 중요한 부분이에요. 다양한 기기에서 앱의 기능을 확인하는 실용적인 방법을 안내해 드릴게요. 에뮬레이터를 사용하여 빠른 반복부터 디바이스 팜을 활용해 철저한 테스트까지, 테스트 환경에서의 복잡성을 성공적으로 해결하기 위해 필요한 기술과 정보를 제공할 거예요.\n\n함께 다중 화면 개발과 테스트의 복잡성을 탐험해 볼까요? 오늘날 접근 가능한 다양한 화면에 적응할 수 있는 애플리케이션을 디자인하는 수수께끼를 풀며, 미래 기술 발전에 부응할 수 있도록 하겠어요.\n\n# 폼 팩터 스펙트럼\n\n폼 팩터는 이제 전통적인 것 이상을 포함하고 있어요. 접이식 기기의 등장과 스마트폰, 태블릿의 전통적인 제약으로 개발자들은 이제 다양한 화면 크기와 모양을 대상으로 하고 있어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 형태 요소의 진화\n\n스마트폰 및 태블릿: 전통적인 스마트폰 및 태블릿은 오랫동안 모바일 애플리케이션의 표준 형태 요소였습니다. 컴팩트한 화면부터 확장된 태블릿까지 다양한 디바이스가 있었기 때문에, 개발자들은 다양한 화면 크기와 해상도를 수용할 수 있도록 레이아웃을 조정하는 데 익숙해져 왔습니다.\n\n접이식 디바이스: 접이식 디바이스의 등장으로 새로운 시대가 열렸습니다. 이로 인해 개발자들은 정적 화면의 제약을 벗어나 생각하도록 도전받게 되었습니다. 접이식 디바이스는 유연성과 혁신을 동시에 제공하여 사용자가 컴팩트한 형태와 확장된 디스플레이 사이를 매끄럽게 전환할 수 있게 합니다. 접이식 디바이스 시장이 계속 성장함에 따라 적응형 앱 디자인의 필요성이 더욱 뚜렷해지고 있습니다.\n\n## 서로 다른 형태 요소에 맞추는 이유?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n향상된 사용자 경험: 다양한 형태 요소에 맞게 애플리케이션을 디자인하면 사용자가 선택한 기기에 관계없이 최적의 경험을 제공할 수 있습니다. 특정 화면에 맞게 레이아웃을 맞추면 더 몰입감 있고 사용자 친화적인 상호작용이 가능해져 사용자 만족도가 높아집니다.\n\n시장 접근성: 다양한 형태 요소 수용을 통해 앱의 잠재적 사용자 기반을 확대할 수 있습니다. 시장에 있는 다양한 기기들을 수용함으로써 애플리케이션의 접근성을 더 넓은 관객에게 제공하여 새로운 시장과 인구통계를 개방할 수 있습니다.\n\n미래 준비: 기술이 발전함에 따라 형태 요소도 변합니다. 유연성을 고려하여 디자인하면 새로운 모양과 크기의 기기가 등장해도 앱이 여전히 관련성 있고 기능적이게 유지될 수 있습니다.\n\n## 레이아웃 조정 대 기존 지원 중단\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다양한 형태 요인을 수용해야 할 때, 개발자는 적응성과 실용성 사이의 균형을 유지해야 합니다. 다음은 고려해야 할 주요 사항입니다:\n\n레이아웃 조정:\n\n- 반응형 디자인 원칙을 활용하여 다양한 화면 크기에 동적으로 적응하는 레이아웃을 만듭니다.\n- XML 레이아웃에서 ConstraintLayout 또는 Jetpack Compose에있는 반응형 수정자와 같은 기술을 활용하여 다양한 기기에서 일관된 사용자 경험을 보장합니다.\n\n지원 중단:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 귀하의 앱 대상 사용자를 기준으로 특정 형태 요소를 지원하는 실용성을 평가합니다.\n- 특정 기기를 지원하지 않을지 결정할 때 필요한 개발 노력과 잠재적 사용자 영향을 고려합니다.\n\n형태 요소의 다양성을 수용하는 것은 단순히 디자인 고려사항이 아니라 전략적 필수불가결입니다. 다양한 형태 요소 개발의 복잡성을 탐구하는 동안 목표는 명확합니다: 정적 화면의 제약을 초월하며 다양한 장치 스펙트럼의 사용자에게 원활하고 즐거운 경험을 제공하는 애플리케이션을 만드는 것입니다.\n\n# 적응형 레이아웃 만들기\n\n## 다중 레이아웃 지원을 위한 XML 데이터 바인딩\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n반응형 XML 레이아웃:\n\n- XML에서 `layout` 및 `data` 요소를 사용하여 레이아웃 구성 요소에 데이터를 바인딩하세요.\n- 리소스 지정자(예: 태블릿용 res/layout-large)를 활용하여 서로 다른 화면 크기에 대한 특정 레이아웃을 생성하세요.\n\n```js\nres / layout / activity_main.xml; // 기본 레이아웃\nres / layout - sw600dp / activity_main.xml; // 7인치 태블릿용 레이아웃\nres / layout - land / activity_main.xml; // 가로 방향용 레이아웃\n```\n\n가로 방향에 최적화된 레이아웃:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 기기가 회전될 때 사용성이 향상되는 랜드스케이프 전용 레이아웃을 만들어보세요.\n\n```xml\n<!-- res/layout-land/activity_main.xml -->\n<LinearLayout\n    android:orientation=\"horizontal\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n    <!-- 랜드스케이프 전용 UI 구성 요소 -->\n</LinearLayout>\n```\n\n접이식 기기:\n\n- 맞춤형 레이아웃을 제공하기 위해 접이식 기기용 리소스 한정자를 활용하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n<!-- res/layout-large/activity_main.xml -->\n<LinearLayout\n    android:orientation=\"vertical\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n    <!-- Foldable device UI components -->\n</LinearLayout>\n```\n\n반응형 ConstraintLayout:\n\n- ConstraintLayout을 활용하여 다양한 화면 크기와 방향에 자동으로 조절되는 반응형 디자인을 만듭니다.\n\n## 동적 UI를 위한 Jetpack Compose\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n화면 크기 처리:\n\n젯팩 컴포즈에서 Modifier.fillMaxSize()는 레이아웃이 사용 가능한 공간을 차지하도록 보장하며, 다양한 화면 크기에 적응합니다. 또한 padding 수정자를 사용하여 일관된 여백을 제공하면 다양한 크기에 걸쳐 깔끔하고 조직적인 모양을 유지할 수 있습니다.\n\n방향 관리:\n\nLocalConfiguration.current.orientation을 사용하여 현재 방향을 확인하면 Composable 함수 내에서 조건부로 다른 레이아웃을 정의할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## Foldable 기기용 SlidingPaneLayout\n\n- SlidingPaneLayout을 활용하여 Foldable 기기를 위한 슬라이딩 패널 UI를 만들어보세요.\n\nDataBinding과 Jetpack Compose에서 이러한 기술들을 활용함으로써, 다양한 화면 크기, 방향 및 심지어 Foldable 기기의 독특한 형태 요소까지 우아하게 수용하는 적응형 레이아웃을 만들 수 있습니다. 크기를 조정하거나 동적 레이아웃을 사용하더라도, 사용자들에게 다양한 기기 스펙트럼에서 일관되고 즐거운 경험을 제공하는 것이 목표입니다.\n\n# 함정 피하기 & 최선의 실행 방법\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 흔한 함정 및 그것을 피하는 방법\n\n고정된 크기:\n\n- 함정: 크기를 하드코딩하는 것은 다른 화면 크기에서 레이아웃이 왜곡될 수 있습니다.\n- 해결책: 상대적인 크기인 wrap_content 및 match_parent를 사용하거나 일관된 크기를 위해 밀도 독립적인 픽셀(dp)을 활용하십시오.\n- XML 데이터 바인딩 예시:\n\n- Jetpack Compose 예시:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n밀도 독립성을 무시하고:\n\n- 함정: 고정된 픽셀 값에만 의존하는 것은 다른 픽셀 밀도를 가진 장치에서 일관성 없는 UI를 초래할 수 있습니다.\n- 해결책: 밀도 독립 단위(dp XML에서, Compose에서는 dp 또는 sp)를 사용하여 UI 요소가 다른 화면에서 적절하게 확장되도록 보장합니다.\n- XML 데이터 바인딩:\n\n```js\n<!-- res/layout/activity_main.xml -->\n<TextView\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:textSize=\"16sp\"\n    android:padding=\"8dp\"\n    android:text=\"밀도 독립적 텍스트\" />\n```\n\n- Jetpack Compose:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n// src/main/kotlin/com/example/myapp/ui/MainScreen.kt\nText(\n    text = \"밀도 독립적 텍스트\",\n    fontSize = 16.sp,\n    modifier = Modifier.padding(8.dp)\n)\n```\n\n방향 변경 무시:\n\n- 함정: 가로 또는 세로 방향을 무시하면 사용자 경험이 최적화되지 않을 수 있습니다.\n- 해결책: 장치가 회전될 때 개선된 사용성을 위해 랜드스케이프 전용 레이아웃을 설계합니다.\n- XML 데이터 바인딩 예시:\n\n```js\n<!-- res/layout-land/activity_main.xml -->\n<LinearLayout\n    android:orientation=\"horizontal\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n    <!-- 랜드스케이프 전용 UI 구성 요소 -->\n</LinearLayout>\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- Jetpack Compose 예시:\n\n접힐 수 있는 장치 고려를 무시할 때:\n\n- 함정: 접힐 수 있는 장치의 독특한 형태 요소를 간과하면 최적의 사용자 경험을 보장받기 어려울 수 있습니다.\n- 해결책: 접힐 수 있는 장치에 대한 리소스 크기 조정자를 통합하고 레이아웃을 맞춤화하여 그들의 기능을 최대한 활용하십시오.\n- XML 데이터 바인딩 예시:\n\n```js\n<!-- res/layout-large/activity_main.xml -->\n<LinearLayout\n    android:orientation=\"vertical\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n    <!-- 접힐 수 있는 장치 UI 구성 요소 -->\n</LinearLayout>\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- **Jetpack Compose 예시:**\n\n## 원활한 경험을 위한 추가 팁\n\n동적 간격:\n\n- 화면 크기에 따라 차원 리소스를 사용하여 간격을 동적으로 조절합니다.\n- XML 데이터 바인딩 예시:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\nText(\n    text = \"동적 간격\",\n    modifier = Modifier\n        .padding(dimensionResource(id = R.dimen.margin_standard))\n)\n```\n\n반응형 글꼴 크기:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- Responsive 폰트 크기를 조절하는 데 디멘션 리소스를 사용하세요.\n- XML 데이터바인딩 예시:\n\n```js\n<TextView\n  android:layout_width=\"wrap_content\"\n  android:layout_height=\"wrap_content\"\n  android:text=\"Responsive Font\"\n  android:textSize=\"@dimen/text_size_medium\"\n/>\n```\n\n- Jetpack Compose 예시:\n\n```js\nText(\n  (text = \"Responsive Font\"),\n  (fontSize = dimensionResource((id = R.dimen.text_size_medium)).value)\n);\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n화면 크기, 방향 및 접이식 장치의 다양한 환경을 다루기 위해서는 세부 사항에 주의해야 합니다. 흔한 실수를 피하고 이러한 추가적인 기교를 구현하여 다양한 장치에서 원활하고 즐거운 사용자 경험을 제공하는 적응형 레이아웃을 만들 수 있습니다.\n\n# 스펙트럼 테스팅: 에스프레소, 파이어베이스 디바이스 팜, 그리고 에뮬레이터\n\n다양한 화면 크기와 방향에서 앱이 원활하게 작동하도록 보장하기 위해서는 견고한 테스트 전략이 필요합니다. 이 섹션에서는 에스프레소를 사용하여 애플리케이션을 효율적으로 테스트하는 방법, 포괄적인 디바이스 커버리지를 위해 파이어베이스 디바이스 팜을 활용하는 방법, 그리고 테스트 필요에 맞게 맞춤형 에뮬레이터를 설정하는 방법을 살펴보겠습니다. 게다가 이러한 테스트를 로컬 및 지속적 통합(Continuous Integration, CI) 파이프라인 내에서 실행하는 스크립트도 제공할 것입니다.\n\n## 로컬 테스트를 위한 에스프레소\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n에스프레소는 안드로이드용 강력한 테스팅 프레임워크로서 간결하고 신뢰할 수 있는 UI 테스트를 작성할 수 있습니다. 로컬에서 다양한 화면 크기와 방향을 테스트하려면 에스프레소의 ViewMatchers 및 ViewActions를 사용하여 UI 요소를 확인하는 ViewAssertions와 결합할 수 있습니다.\n\n에스프레소 코드 예시:\n\n## Firebase Device Farm를 활용한 철저한 테스트\n\nFirebase Device Farm는 다양한 실제 기기에서 앱을 테스트할 수 있는 클라우드 기반 솔루션을 제공합니다. 다양한 화면 크기, 방향 및 기기를 커버하는 테스트 매트릭스를 생성하여 다양한 구성에 대해 철저한 테스트를 보장할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nFirebase Test Lab 예제 코드:\n\n## 사용자 정의 테스트 환경을 위한 에뮬레이터 설정\n\nAndroid 에뮬레이터는 테스트를 위한 사용자 정의 가상 장치를 생성하는 유연한 방법을 제공합니다. 에뮬레이터를 구성하여 실제 시나리오를 모방하기 위해 특정 화면 크기, 해상도 및 방향을 일치시킬 수 있습니다.\n\n## 사용자 정의 에뮬레이터 설정:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nAVD Manager를 사용하여 새로운 에뮬레이터를 생성하세요. 화면 크기, 해상도 및 방향과 같은 장치 세부 정보를 지정해주세요.\n\n```js\nemulator -avd Pixel_6_API_32 -orientation portrait\n```\n\n에뮬레이터 시작: 원하는 구성으로 에뮬레이터를 시작하세요.\n\n## 로컬에서 테스트를 실행하는 스크립트:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n#!/bin/bash\n# Espresso 테스트가 'androidTest' 디렉토리에 있다고 가정합니다\n./gradlew connectedAndroidTest\n```\n\n## CI 파이프라인용 스크립트 (Firebase Device Farm 통합):\n\n이러한 테스트 전략을 개발 워크플로에 통합함으로써, 앱이 다양한 화면 크기, 해상도, 방향에서 매끄럽게 작동함을 보장할 수 있습니다. Espresso로 로컬에서 테스트하거나 Firebase Device Farm에서 다양한 설정을 탐색하거나 사용자 정의 에뮬레이터를 만들 때, 포괄적인 테스트 접근 방식은 높은 품질의 사용자 경험을 제공하는 데 중요합니다.\n\n# 결론\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n지금보다 더 중요한 것은 다양한 화면 크기, 방향 및 접힐 수 있는 장치에서 매끄럽게 작동하는 경험을 디자인하는 것입니다. 다양한 형태 요소 테스트와 개발을 통한 탐구는 디지털 세계의 도전에 대처하려는 개발자들에게 더 나은 방법을 제시하고 있습니다.\n\nJetpack Compose와 XML 데이터 바인딩의 적응형 디자인 개념을 활용하면, 개발자들은 점점 다양해지는 기기 범위에 맞춰 레이아웃을 유동적으로 조정할 수 있습니다. 이러한 방법으로 제공되는 적응성은 스마트폰, 태블릿 및 접힐 수 있는 장치에서 동일하고 즐거운 경험을 제공하여 모든 고객이 일관된 사용자 경험을 누릴 수 있도록 보장합니다.\n\n앱 개발의 중요한 요소인 테스팅은 Espresso, Firebase Device Farm 및 에뮬레이터 설정을 통해 다양한 시각에서 다뤄졌습니다. 로컬 테스트부터 클라우드 기반 솔루션까지, 개발자들은 다양한 도구를 활용하여 앱이 다양한 환경에서 완벽하게 작동하도록 보장할 수 있습니다. 특정 구성을 위해 Espresso 테스트를 실행하거나 Firebase를 활용하여 포괄적인 장치 커버리지를 제공하거나 로컬 및 CI/CD 파이프라인 테스트를 위해 에뮬레이터 설정을 스크립팅하는 것과 같이, 선택 가능한 옵션이 풍부합니다.\n\n이 조사를 마치면 다양성 수용이 성공에 중요하다는 것이 명확해집니다. 다양한 형태 요소의 미묘한 점을 이해하고 전형적인 실수를 피하며 여분의 전술을 추가함으로써, 개발자들은 제약을 뛰어넘는 응용프로그램을 만들 수 있습니다. 창의성에 경계가 없는 세계에서, 점진적인 개발자들은 포괄적이고 유연한 디지털 경험을 만들기 위한 헌신으로 구별됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 기사가 개발자들에게 나침반 역할을 하여 다중 화면 애플리케이션의 개발과 테스트의 복잡성을 탐험하고, 현재의 요구 사항을 충족시키는 데만 그치지 않고 미래 기술의 돌파구에도 견고한 프로그램을 만드는 데 영감을 주길 바랍니다. 우리는 어느 날 고객들이 어디서나 그들만의 세계를 탭하고 스와이프하며 펼쳐질 수 있는 시대를 기대하고 있습니다.\n","ogImage":{"url":"/assets/img/2024-06-19-PixelPerfectDesigningforEveryScreenEveryFold_0.png"},"coverImage":"/assets/img/2024-06-19-PixelPerfectDesigningforEveryScreenEveryFold_0.png","tag":["Tech"],"readingTime":16},{"title":"피그마로부터 코틀린 Compose를 위한 자동 거의 자원 생성","description":"","date":"2024-06-19 13:44","slug":"2024-06-19-AutomaticalmostresourcegenerationfromFigmaforCompose","content":"\n![image](/assets/img/2024-06-19-AutomaticalmostresourcegenerationfromFigmaforCompose_0.png)\n\n자동화에 대해 이야기해보겠습니다. 루틴적이고 시간이 많이 소요되는 프로세스를 자동화해야 할 때가 많습니다. 이전 프로젝트에서는 클라이언트를 위한 다양한 UI 사용자 정의가 포함된 단일 코드베이스 기반의 화이트 레이블 솔루션을 갖고 있었습니다. 이 게시물에서는 디자이너의 변경 사항을 찾는 데 추가 시간을 낭비하지 않고 즉시 코드 작성을 시작하는 데 도움이 된 다양한 접근 방식과 도구에 대해 이야기하겠습니다.\n\n# FIGMA/WHATEVER DSM\n\n기초부터 시작해보겠습니다. 디자이너들도 DRY 원칙을 따르기 위해 노력하며 Design System Manager와 같은 훌륭한 도구를 개발합니다. 먼저, 프로젝트에서 반복될 수 있는 구성요소를 식별하고 색상 및 스타일의 구조화된 세트를 개발합니다. 따라서 한 곳에서 색상이나 스타일이 변경되면 전체 프로젝트에서 자동으로 변경됩니다. 편리하죠? Figma나 다른 도구를 사용하여 이러한 구성을 특별한 파일로 내보낼 수 있으며, 그 파일을 분석하여 이를 기반으로 코드를 생성할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nJetpack Compose을 사용하면 ColorScheme과 TextStyle과 같은 클래스를 알 수 있을 것입니다. Material 철학에 따라, 우리는 ColorScheme을 사용하여 색상을 설명하고 TextStyle을 사용하여 텍스트의 모양을 설명합니다. 이는 컴포넌트가 렌더링하는 데 사용되는 것입니다.\n\n# 코드 생성\n\nRoom, Dagger2와 같은 라이브러리를 사용해 본 적이 있다면, 이미 익숙한 개념일 수 있습니다.\n\nJava에서는 이 개념을 주석 처리(annotation processing)이라고 하며, Kotlin에서는 kapt 또는 ksp로 참조됩니다. 본질적으로 코드를 분석하고 추가 파일을 생성하는 컴파일러 기능입니다. 그러나 JSON 파일에 주석을 첨부할 수 없고 Kotlin 파일이 아니기 때문에, 여기에는 다른 해결책이 필요합니다. 따라서, 입력 데이터를 가져와 필요한 파일을 찾아 필요한 클래스를 생성하는 플러그인을 개발하는 방법을 배울 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# Gradle 플러그인\n\nGradle 플러그인을 만드는 방법은 main 그레이들 파일에 작업을 작성하는 것에서 buildSrc에 코드를 배치하는 것까지 다양합니다. 그러나 저희는 권장 사항을 따라 composite 빌드를 사용할 것입니다. 이 아이디어는 간단합니다: 플러그인은 애플리케이션 코드와 분리되어 유지되고, 그런 다음 모든 것이 결합됩니다. 여기에서 AGP와 함께 이 메커니즘을 사용하는 방법에 대한 많은 예를 찾을 수 있으며, 오랫동안 가지고 있던 질문에 대한 답변을 찾을 수 있습니다.\n\n![이미지](/assets/img/2024-06-19-AutomaticalmostresourcegenerationfromFigmaforCompose_1.png)\n\n여기에 특별한 것은 없습니다. 차이는 플러그인이 가장 높은 수준에서 어떻게 연결되는지에 있습니다. includeBuild()를 사용하여 연결합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n당신의 플러그인 프로젝트의 build.gradle.kts 파일에서, 플러그인이 제대로 작동하기 위해 필요한 종속성 및 기본 구성을 명시해야 합니다. 다음은 플러그인을 위한 예시 설정입니다:\n\n# Gradle 플러그인 구현\n\n젯팩 콤포즈에 대한 Figma 파일 생성을 자동화하기 위한 목표를 달성하기 위해, Gradle 플러그인을 사용하여 다음 단계를 따라야 합니다:\n\n- DSM 토큰의 구조를 분석하고 해당 모델을 준비합니다.\n- 프로젝트에 각 클라이언트 디자인을 설명하는 토큰을 포함하는 모든 가능한 플레이버를 찾습니다.\n- 이 데이터를 분석하여 필요한 파일을 생성하는 방법을 학습합니다.\n- 이를 편리하게 만들고 Gradle 작업에 포장합니다.\n- ...\n- 코드를 작성하세요!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n파일에는 색상 설명이 포함되어 있습니다. 이 설명은 여러 논리적 수준으로 구성될 수 있으며, 마지막 수준에는 우리가 관심을 가지는 정보가 포함되어 있습니다. 일반적으로 리소스는 유사한 구조를 가지며, 타입과 값이 명시됩니다.\n\n```js\n{\n  \"color\": {\n    \"m3\": {\n      \"white\": {\n        \"description\": \"\",\n        \"type\": \"color\",\n        \"value\": \"#ffffffff\",\n        \"blendMode\": \"normal\"\n      },\n      \"black\": {...},\n      \"sys\": {\n        \"light\": {...},\n        \"dark\": {...}\n      },\n      \"ref\": {...},\n      \"key-colors\": {...},\n      \"source\": {...},\n      \"surfaces\": {...},\n      \"state-layers\": {...}\n    }\n  },\n  \"font\": {...},\n  \"typography\": {...}\n}\n```\n\n색상에 대해서는 해당 값을 관심 있게 살펴보고 있으며, 해당 클래스에는 해당 색상의 16진수 표현이 포함됩니다.\n\n# Gradle 작업\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n작업 등록 중에는 주석으로 표시된 모든 필드를 설정해야 합니다. 즉, JSON 파일의 경로, 플레이버 폴더의 경로 및 생성된 파일의 최종 패키지입니다.\n\n우리의 삶을 편하게 하기 위해 몇 가지를 하드코딩할 것이지만, 더 많은 유연성이 필요한 경우 gradle 확장 기능을 살펴볼 가치가 있습니다.\n\n이 작업은 추상적이므로 일부 구성은 구현에 맡겨둡니다. 따라서 색상 파일을 생성할 작업의 구조는 다음과 같이 보일 것입니다.\n우리의 작업을 실행할 수 있게 하려면 프로젝트에 등록해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우선 플러그인을 사용하여 프로젝트에 존재하는 빌드 변형을 결정하고 각 유형에 대한 작업을 등록해야 합니다.\n\n이제 가장 흥미로운 부분으로 넘어가 봅시다. 파일 생성이 실제로 어떻게 일어나는지요.\n\n이를 위해 KotlinPoet라는 도구를 사용해야 합니다. 이 도구를 사용하면 필요한 파일을 쉽게 생성할 수 있습니다. 이 전체 매커니즘은 다양한 빌더로 구성되어 있으며, 여기에 파일 유형, 속성, 값 등을 추가합니다.\n\n우리의 작업 핵심은 JSON 구문 분석, 필요한 데이터 획득 및 해당 파일에 쓰는 데 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nJSON 파일의 구조를 알고 있기 때문에 데이터를 수집하는 함수를 작성할 수 있어요. 결과적으로 필드 이름을 키로, 모델을 값으로 하는 맵이 만들어질 거예요.\n\n모든 필드의 목록을 갖게 되면, KotlinPoet을 사용하여 파일에 생성하고 싶은 내용을 설명할 수 있어요. 그 결과, 다음과 같은 모습의 파일을 얻게 될 거예요:\n\n![이미지](/assets/img/2024-06-19-AutomaticalmostresourcegenerationfromFigmaforCompose_2.png)\n\n![이미지](/assets/img/2024-06-19-AutomaticalmostresourcegenerationfromFigmaforCompose_3.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n생성된 파일을 사용하여 테마를 설명할 수 있습니다.\n\n![Image 4](/assets/img/2024-06-19-AutomaticalmostresourcegenerationfromFigmaforCompose_4.png)\n\n![Image 5](/assets/img/2024-06-19-AutomaticalmostresourcegenerationfromFigmaforCompose_5.png)\n\n![Image 6](/assets/img/2024-06-19-AutomaticalmostresourcegenerationfromFigmaforCompose_6.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그게 다야! 우리의 초기 작업은 완료되었습니다. 이제 파일을 프로젝트에 업로드하고 작업을 실행하여 개발에 사용할 수 있는 파일을 얻을 수 있습니다. 이전에는 수동으로 수행되어 인간 요인으로 인한 오류가 포함될 수 있었지만, 이제는 원활하게 작동하며 추가 종속성이 필요하지 않습니다(Android와 iOS 솔루션은 기존의 Node.js 모듈을 설치하여 작업을 수행하지 못했으며 여전히 개발자 개입이 필요했습니다).\n\n# 명백하지 않은 도전 과제\n\n플러그인 개발은 문제 해결의 절반입니다. 언제나 문제가 발생할 수 있습니다:\n\n- 프로젝트 복잡성으로 인해 디자이너들은 Material Design을 제대로 사용하지 않고 수십, 아니 수백 개의 사용자 정의된 이름을 가진 색상과 스타일을 만들었습니다. 이로 인해 표준 MaterialTheme을 사용할 수 없었고, 결과적으로 우리 플러그인은 사용자 정의 ColorScheme과 Typography 클래스를 생성했습니다.\n- 초기 개발 및 이전 이관에 상당한 시간이 소요되었지만, Material 설정이 깨끗하고 디자이너와의 토큰 이름 문제를 해결하는 데 몇 시간을 보낼 필요가 없다면 이것은 문제가 되지 않습니다.\n- @Preview 주석은 모두 우리 사용자 정의 테마로 래핑되어야 합니다.\n- 디자인 자체가 문제일 수 있습니다. 고객 중 한 명은 그라데이션을 가진 버튼을 가졌는데, 이 토큰에는 색상을 사용해야 했습니다. 이 문제는 임시 해결 방법으로 우아하게 해결되었지만, 미래에 이러한 충돌이 발생하지 않도록 디자이너에게 강력히 당부했습니다.\n- 구성 복잡성 - 과정 자체는 간단하지만, 이전 문제와 같은 문제는 플러그인의 논리나 모델 구조를 크게 변경해야 할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그거면 끝이에요. 비슷한 솔루션을 만들어 본 경험이 있거나 미리보기를 위해 매번 사용자 정의 테마를 작성하는 것을 피하는 방법을 아시는 분들은 댓글에서 공유해 주세요. 코드가 필요한 경우 전체 프로젝트는 여기에서 확인할 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-06-19-AutomaticalmostresourcegenerationfromFigmaforCompose_0.png"},"coverImage":"/assets/img/2024-06-19-AutomaticalmostresourcegenerationfromFigmaforCompose_0.png","tag":["Tech"],"readingTime":8},{"title":"Jetpack Compose 안드로이드에서 사용자 지정 PDF 뷰어 만들기","description":"","date":"2024-06-19 13:43","slug":"2024-06-19-CreatingCustomPDFViewerinJetpackComposeAndroid","content":"\n![PDFViewer](/assets/img/2024-06-19-CreatingCustomPDFViewerinJetpackComposeAndroid_0.png)\n\nPDF는 우리가 매일 사용하는 가장 일반적인 파일 형식 중 하나입니다. 그러나 Jetpack Compose에서 공식 PDF 뷰어가 아직 없습니다. 그렇다면 왜 만들지 않을까요?\n\n## 어떻게 가능한가요?\n\n우리의 계획 개요를 살펴봅시다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- PDF 파일이 있는 원격 URL 또는 전화 저장소가 있습니다.\n- 하나씩 페이지를 보여줄 수 있습니다.\n- 페이지는 확대 및 이동할 수 있어야 합니다.\n- 서버 PDF를 로컬 캐시/저장소에 다운로드하고 저장해야 합니다.\n- PDF를 '페이지'를 나타내는 '비트맵' 목록으로 변환할 수 있습니다.\n- 그런 다음 간단히, 비트맵을 지원하는 이미지 컴포저블을 사용하여 세로로 페이지를 하나씩 모두 표시할 것입니다.\n\n## 단계 1: PDF 다운로드 및 저장\n\n이 시점에서 PDF의 URL만 있습니다. 이를 다운로드하는 기능을 만들어 보겠습니다.\n\n먼저 AndroidManifest.xml에 다음 권한을 추가하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```java\n<uses-permission android:name=\"android.permission.INTERNET\" />\n<uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" />\n```\n\n우리는 HttpURLConnection 객체를 사용하여 연결을 설정하고 InputStream을 가져올 것입니다.\n\n```java\nval connection = URL(url).openConnection() as HttpURLConnection\nconnection.connect()\n```\n\n위의 코드들이 작동하여 PDF 파일을 가져올 것입니다. 작업이 완료되었고 필요한 Input stream을 얻었는지 확인해보세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\nif (connection.responseCode != HttpURLConnection.HTTP_OK) {\n    connection.disconnect()\n    return@withContext null\n}\n\nval inputStream = connection.inputStream\n```\n\n작업이 끝나면 꼭 연결을 끊어 주세요.\n\n```kotlin\nconnection.disconnect()\n```\n\n이제 다운로드 부분이 완료되었으니 사용자의 로컬 스토리지에 저장해주세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\nfile = File.createTempFile(fileName, \".pdf\")\nval outputStream = FileOutputStream(file)\ninputStream.copyTo(outputStream)\noutputStream.close()\n```\n\n변경 후 전체 함수는 다음과 같습니다:\n\n```kotlin\nsuspend fun downloadAndGetFile(url: String, fileName: String): File? {\n    if (isFileExist(fileName)) return File(fileName) // 이 줄은 중복 파일 생성을 피하기 위해 중요합니다.\n    var connection: HttpURLConnection? = null\n    var file: File? = null\n    try {\n        withContext(Dispatchers.IO) {\n            connection = URL(url).openConnection() as HttpURLConnection\n            connection!!.connect()\n\n            if (connection!!.responseCode != HttpURLConnection.HTTP_OK) {\n                return@withContext null\n            }\n\n            val inputStream = connection!!.inputStream\n            file = File.createTempFile(fileName, \".pdf\")\n            val outputStream = FileOutputStream(file)\n            inputStream.copyTo(outputStream)\n            outputStream.close()\n        }\n    } catch (e: IOException) {\n        // UI에 응답을 전송합니다.\n    } finally {\n        connection?.disconnect()\n    }\n    return file\n}\n```\n\n```kotlin\nfun isFileExist(path: String): Boolean {\n    val file = File(path)\n    return file.exists()\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 단계 2: 파일 객체를 List`Bitmap`으로 변환합니다.\n\n이 변환에는 PdfRenderer 클래스를 사용할 것입니다:\n\n```js\nPdfRenderer renderer = new PdfRenderer(ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_READ_ONLY));\n```\n\n하지만 이것을 직접 사용하는 것은 Jetpack Compose에서 좋지 않고 많은 RAM을 소비할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그럼 다음과 같이 사용할 것입니다:\n\n```js\nval rendererScope = rememberCoroutineScope()\nval mutex = remember { Mutex() }\nval renderer by produceState<PdfRenderer?>(null, file) {\n    rendererScope.launch(Dispatchers.IO) {\n        val input = ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_READ_ONLY)\n        value = PdfRenderer(input)\n    }\n    awaitDispose {\n        val currentRenderer = value\n        rendererScope.launch(Dispatchers.IO) {\n            mutex.withLock {\n                currentRenderer?.close()\n            }\n        }\n    }\n}\n```\n\n이제 우리가 만든 \"PDFRenderer\" 객체인 \"renderer\"를 사용하여 모든 페이지를 가져와 비트맵 객체에 렌더링할 것입니다.\n\n```js\nrenderer?.let {\n    it.openPage(index).use { page ->\n        page.render(destinationBitmap, null, null, PdfRenderer.Page.RENDER_MODE_FOR_DISPLAY)\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 모든 페이지에 대한 비트맵을 가져올 수 있습니다. UI에서 모든 페이지에 표시할 시간입니다.\n\n## 단계 3: UI에 목록`비트맵` 표시 + 줌 및 이동 기능 추가:\n\nPDFViewer Composable의 전체 코드가 필요하면 이를 참조하십시오:\n\n여기서 설명이 시작됩니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- BoxWithConstraints를 사용하는 이유는 페이지의 높이와 너비를 정의하고 줌 및 이동을 위해 화면의 높이와 너비가 필요하기 때문입니다.\n\n```js\n            val width = with(LocalDensity.current) { maxWidth.toPx() }.toInt()\n            val height = (width * sqrt(2f)).toInt()\n            val pageCount by remember(renderer) { derivedStateOf { renderer?.pageCount ?: 0 } }//Used ahead\n\n            var scale by rememberSaveable {\n                mutableFloatStateOf(1f)\n            }\n            var offset by remember {\n                mutableStateOf(Offset.Zero)\n            }\n            val state = //Used for Zoom and Move\n                rememberTransformableState { zoomChange, panChange, rotationChange ->\n                    scale = (scale * zoomChange).coerceIn(1f, 5f)\n\n                    val extraWidth = (scale - 1) * constraints.maxWidth\n                    val extraHeight = (scale - 1) * constraints.maxHeight\n\n                    val maxX = extraWidth / 2\n                    val maxY = extraHeight / 2\n\n                    offset = Offset(\n                        x = (offset.x + scale * panChange.x).coerceIn(-maxX, maxX),\n                        y = (offset.y + scale * panChange.y).coerceIn(-maxY, maxY),\n                    )\n                }\n```\n\nZoom 구현을 자세히 이해하려면 이 비디오를 시청하세요.\n\n2. 이 상태를 LazyColumn과 함께 간단히 사용하고 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\n            LazyColumn(\n                modifier = Modifier\n                    .fillMaxSize()\n                    .graphicsLayer {\n                        scaleX = scale\n                        scaleY = scale\n                        translationX = offset.x\n                        translationX = offset.y\n                    }\n                    .transformable(state)\n```\n\n3. 호출할 때 이미 PDF 파일을 다운로드하고 저장했습니다.\n\n```kotlin\nLaunchedEffect(key1 = Unit) {\n        file = async { downloadAndGetFile(url, fileName) }.await()\n    }\n```\n\n4. \"cacheKey\"로부터 Bitmap 객체를 만들어야 합니다. 이미지도 캐시에 저장될 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\nval cacheKey = MemoryCache.Key(\"${file!!.name}-$index\")\nval cacheValue: Bitmap? = imageLoader.memoryCache?.get(cacheKey)?.bitmap\nvar bitmap: Bitmap? by remember { mutableStateOf(cacheValue) }\n```\n\n5. 이후에는 각 페이지의 비트맵을 가져와 Coil ImageRequest 객체로 표시합니다.\n\n```kotlin\nval request = ImageRequest.Builder(context)\n    .size(width, height)\n    .memoryCacheKey(cacheKey)\n    .data(bitmap)\n    .build()\n\nImage(\n    modifier = Modifier\n        .background(Color.Transparent)\n        .border(1.dp, MaterialTheme.colors.background)\n//        .aspectRatio(1f / sqrt(2f))\n        .fillMaxSize(),\n    contentScale = ContentScale.Fit,\n    painter = rememberAsyncImagePainter(request),\n    contentDescription = \"Page ${index + 1} of $pageCount\"\n)\n```\n\n나머지 부분은 상당히 직관적이고 이해하기 쉽습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여기서 새로운 것을 배웠다면, 좋다면 팔로우 버튼을 눌러 주세요.\n","ogImage":{"url":"/assets/img/2024-06-19-CreatingCustomPDFViewerinJetpackComposeAndroid_0.png"},"coverImage":"/assets/img/2024-06-19-CreatingCustomPDFViewerinJetpackComposeAndroid_0.png","tag":["Tech"],"readingTime":10},{"title":"접근성 테스트에서 코틀린 Compose - 이름, 역할, 값","description":"","date":"2024-06-19 13:42","slug":"2024-06-19-AccessibilityTestsinComposeNameRoleValue","content":"\n<img src=\"/assets/img/2024-06-19-AccessibilityTestsinComposeNameRoleValue_0.png\" />\n\n앱을 위한 테스트를 작성할 때는 접근성 관련 사항을 테스트하는 것도 고려해야 합니다. 이해합니다. 어디서부터 시작해야 할지 알기 어려울 수 있죠. 그래서 저는 어떻게 일부 접근성 측면을 테스트할지에 대해 이 블로그 글을 쓰기로 결정했습니다.\n\n이 글에서는 클릭 가능, 선택 가능, 토글 가능한 수정자를 사용하여 구성된 세 가지 사용자 정의 구성 요소에 대한 일부 접근성 관련 테스트를 추가할 것입니다. 이러한 구성 요소는 제가 썼던 블로그 글에서 만들어진 것입니다: Jetpack Compose에서 수정자를 활용한 Android 접근성 향상.\n\n# 무엇을 테스트하는 중인가요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리가 작성하는 테스트는 컴포넌트에 이름, 역할 및 값이 있는지 확인합니다. 하지만 이 그룹은 어디에서 왔을까요? 배경은 웹 콘텐츠 접근성 가이드라인(WCAG)이 \"이름, 역할, 값\"이라는 성공 기준을 가지고 있어요. 이는 모든 요소가 프로그래밍 방식으로 결정 가능한 이름과 역할을 가지고 있음을 보장합니다. 또한 사용자가 변경할 수 있는 상태, 속성 및 값은 프로그래밍 방식으로 변경 가능해야 합니다.\n\n그리고 지금, \"웹\"이라는 것을 언급하는 이유가 궁금하다면, WCAG은 이름과는 상관없이 모바일 앱의 최소 접근성 수준을 결정하는 데도 사용됩니다.\n\n여기서 '이름'은 이용자에게접근성을 제공하는 이름을 의미합니다. 요소의 텍스트 표현이 될 수 있습니다. 예를들어 버튼의 텍스트, 아이콘 버튼의 내용 설명, 스위치의 레이블 등이 있습니다. 스크린 리더를 사용하는 사람이 듣는 내용입니다. 음성 액세스 사용자는 대화형 요소를 활성화할 때 사용합니다.\n\n그리고 '역할'은 요소의 역할을 말합니다. 예를들어 버튼일 수 있습니다 - 이것은 사용자에게 '여기 버튼이 있어요, 그리고 이 버튼은 버튼처럼 행동해야 해'라고 알려줍니다. 역할은 작동해야 하는 방식에 대한 약속입니다. 따라서 역할을 추가한다면 올바른 상호작용도 추가해야 합니다. 그러나 역할은 웹보다는 Android에서 덜 사용됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n값은 요소의 상태, 속성 또는 값에 대한 참조를 할 수 있습니다. 각 요소마다 정확한 의미가 다릅니다. 예를 들어, 체크박스의 경우 값은 체크 여부를 알려주고, 아코디언의 경우 상태가 열렸는지 닫혔는지를 나타냅니다.\n\n다음 섹션에서는 소개 부분에서 언급된 몇 가지 사용자 지정 컴포넌트에 대한 \"이름, 역할, 값\" 성공 기준을 테스트하는 구체적인 예제를 살펴보겠습니다.\n\n# 테스트 작성, 예시\n\n처음에 언급한 대로, 이러한 테스트는 이전에 작성한 블로그 게시물을 위한 컴포넌트에 대해 작성된 것입니다. 세 가지 컴포넌트를 어떻게 테스트할지 살펴보겠습니다: 스위치, 라디오 버튼 그룹 및 클릭 가능한 행.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n블로그 게시물의 구성 요소가 예제를 위해 단순화되었기 때문에 이 테스트들도 간소화되었습니다. 실제 프로덕션 코드에서는 일반적으로 테스트되는 구성 요소를 찾는 더 정교한 전략이 있습니다.\n\n## Toggleable\n\n테스트하는 첫 번째 구성 요소는 아래 사진에 나와있는 스위치와 같습니다:\n\n![Toggleable Component](/assets/img/2024-06-19-AccessibilityTestsinComposeNameRoleValue_1.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리는 세 가지를 테스트하고 싶어합니다: 먼저, 컴포넌트에 접근 가능한 이름(따라서, 스위치의 레이블)이 있는지 확인하고 싶습니다. 둘째, 역할이 올바른지-토글 가능한 컴포넌트여야 합니다. 셋째, 스위치를 토글한 후에도 값이 올바른지 확인하고 싶습니다, 따라서 스위치가 켜져 있는지 꺼져 있는지에 상관없이.\n\n테스트를 작성해봅시다:\n\n첫째, 테스트에는 설정이 필요하므로, composeTestRule 및 콘텐츠 설정과 같은 것들이 필요합니다. 그런 다음 테스트 가능한 컴포넌트를 test 태그인 accessible-toggle로 가져옵니다. 마지막으로, 이름, 역할, 값에 대한 테스트가 있습니다.\n\n이름을 확인하는 테스트는 간단합니다: 요소의 텍스트 내용이 레이블의 단어와 같은지 확인하고 싶습니다. assertTextEquals를 사용하여 이를 확인할 수 있습니다. 역할을 테스트하기 위해 유용한 assert 함수인 assertIsToggleable을 사용할 수 있습니다. 마지막으로 값(즉, 확인된 상태)이 올바른지 확인하기 위해, assertIsOff 및 assertIsOn과 같은 유틸리티 함수를 사용할 수 있으며, 상태를 토글하기 위해 performClick을 사용할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 선택 가능한 요소\n\n다음으로 테스트하는 컴포넌트는 라디오 버튼 그룹입니다. 사진에서 확인할 수 있습니다:\n\n![이미지](/assets/img/2024-06-19-AccessibilityTestsinComposeNameRoleValue_2.png)\n\n이 컴포넌트에서 우리는 두 옵션이 모두 이름(즉, \"옵션 A\"와 \"옵션 B\" 레이블), 선택 가능한 역할 및 선택된 항목의 값을 가지고 있는지 확인합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 구성 요소의 테스트는 다음과 같습니다:\n\n구조는 이전 테스트와 매우 유사합니다. 먼저 설정하고, 그런 다음 요소를 가져 와서 이름, 역할 및 값에 대해 단언합니다. 요소의 레이블(즉, 이름)을 확인하기 위해 동일한 assertTextEquals를 사용합니다. toggleable과 마찬가지로, 선택 가능한 요소의 역할과 값을 확인하는 함수가 있습니다: isSelectable(), assertIsSelected(), 그리고 .assertIsNotSelected().\n\n## 클릭 가능\n\n이 블로그 글의 마지막 맞춤형 구성 요소는 아이템을 즐겨찾기하는 데 사용할 수 있는 맞춤형 버튼입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Accessibility test](/assets/img/2024-06-19-AccessibilityTestsinComposeNameRoleValue_3.png)\n\n우리는 아이템에 이름(즉, \"이 항목 즐겨찾기\")과 버튼 역할, 그리고 해당 항목이 즐겨찾기되었는지 여부를 알리는 상태가 있는지 확인하고 싶습니다.\n\n다음 테스트는 다음을 보장합니다:\n\n다시 말하지만, 이름의 설정과 확인은 다른 두 구성 요소와 유사합니다. 그러나 구성 요소가 버튼 역할을 갖고 있는지 확인하려면 SemanticsMatcher를 사용해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n`SemanticsMatcher`은 시맨틱 노드를 매칭하기 위한 래퍼입니다. 요소의 시맨틱 속성 Role이 Role.Button과 일치하는지 확인하고 싶습니다. 이를 위해서 SemanticMatcher로 우리의 체크를 래핑하고, element에서 element.config.getOrNull(SemanticsProperties.Role)을 사용해 element의 SemanticProperties.Role을 가져와 해당 값이 일치하는지 확인할 수 있습니다.\n\n이와 같은 패턴은 element의 state description을 테스트하는 데에도 동일하게 적용됩니다. 코드 중복을 피하기 위해 element의 state description을 확인하는 데 사용되는 extension function인 `assertStateDescription`을 만들었습니다.\n\n# 마무리\n\n이 블로그 포스트에서는 WCAG 성공 기준 4.1.2: Name, Role, Value에 대한 접근성 테스트 작성에 대해 논의했습니다. 이러한 테스트는 모바일 접근성에 항상 적용되는 것은 아니지만, 본 블로그 포스트에서는 접근성 테스트 작성 방법에 대한 예시를 제공하고 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n안드로이드에서 접근성에 대한 테스트를 작성해 보았나요? 공유해 주시면 감사하겠어요!\n\n# 블로그 글 링크\n\n- Jetpack Compose에서 Modifier를 사용하여 안드로이드 접근성 향상하기\n- 이름, 역할, 값\n- SemanticsMatcher\n","ogImage":{"url":"/assets/img/2024-06-19-AccessibilityTestsinComposeNameRoleValue_0.png"},"coverImage":"/assets/img/2024-06-19-AccessibilityTestsinComposeNameRoleValue_0.png","tag":["Tech"],"readingTime":7},{"title":"제가 Zomato 앱을 역공학으로 분석해 나만의 주문 추적 알림 시스템을 만들었던 과정입니다","description":"","date":"2024-06-19 13:40","slug":"2024-06-19-HowIreverseengineeredtheZomatoapptobuildmyownOrderTrackingnotificationsystem","content":"\n(고지: 저는 독립 개발자/개인이며 Zomato 엔지니어 팀에서 일하고 있지 않습니다)\n\n최종 제품이 어떻게 작동하는지 확인하려면 여기를 클릭하세요: [https://youtu.be/E89Etnvq6rY](https://youtu.be/E89Etnvq6rY)\n\n코드를 확인하려면 여기를 클릭하세요: [https://github.com/oddlyspaced/zomato-notification/tree/main](https://github.com/oddlyspaced/zomato-notification/tree/main)\n\n---\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nZomato Android 앱을 매일 사용하는 사용자이자 앱 엔지니어로서, 나는 이 앱의 디자인과 어디에서나 음식 주문이 가능하다는 편의성을 사랑하게 되었습니다. 그러나 항상 음식 배달 상태를 확인하기 위해 앱을 열어야 한다는 점이 불편하다고 느꼈습니다. 앱은 훌륭한 주문 추적 화면을 제공하지만, iOS 버전의 Zomato 앱이 iOS 활동 인디케이터를 활용하여 제공하는 지속성과 쉬운 액세스를 제공하지 못한다는 점이 마음에 듭니다. 이에 영감을 받아 Zomato Android 앱을 역공학하여 주문 추적 경험을 향상시킬 수 있는 사용자 정의 솔루션을 구축하기로 결심했습니다. 이 글에서는 필요한 API 엔드포인트를 발견하고, 앱의 시스템 아키텍처를 설계하며, 반복적으로 Zomato 앱을 열 필요 없이 실시간 주문 추적 정보를 제공하는 지속적인 알림을 구현하는 과정을 공유하겠습니다.\n\n# 파트 1: 앱 트래픽 이해\n\n정보를 표시하는 방법을 이해하려면, 앱이 필요한 정보를 가져오는 방법을 파악해야 합니다. 앱과 서버 간의 네트워크 트래픽을 검사하는 것이 시작점으로 좋습니다. 이를 통해 앱으로 전송되는 정보에 대한 정확한 지식을 얻을 수 있습니다. 나중에 독립적으로 호출해야 하는 API 엔드포인트에 대한 정보를 제공해 줄 것입니다.\n\n이를 위해 다음 도구를 활용했습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- apktool\n- Charles Proxy\n- Android Emulator\n\n앱을 디버깅하기 위한 설정 과정은 간단합니다. 이 글에서는 다루지 않겠습니다.\n\n다음 글을 참고해주세요 :\n\n# Part 2: 앱 트래픽 분석\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n환경 설정이 완료되었으므로 이제 트래픽을 분석하고 요청 내용을 확인할 수 있습니다. 주문 내역을 가져오는 요청을 찾으려면 앱의 주문 내역 페이지로 이동하여 동시에 Charles의 활동을 확인합니다. 이 페이지에 접속할 때마다 호출되는 특정 엔드포인트가 있는 것으로 보입니다. 바로 이것입니다:\n\n```js\nhttps://api.zomato.com/gw/order/history/online_order\n```\n\n<img src=\"/assets/img/2024-06-19-HowIreverseengineeredtheZomatoapptobuildmyownOrderTrackingnotificationsystem_0.png\" />\n\n이것에 대한 응답을 확인해 봅시다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 샘플의 요약된 응답입니다. 전체 샘플 응답은 여기 있습니다.\n\nJSON 구조를 연구하면 결과 목록이 있고 레이아웃 구성 및 order_history_snippet_type_2 키가 있는 객체가 있음을 알 수 있습니다. order_history_snippet_type_2 객체에는 사용할 수 있는 정보가 포함되어 있습니다. click_action 객체에는 딥링크 문자열이 포함되어 있어 주문 ID를 추출하는 데 사용할 수 있습니다. 주문 ID는 다른 위치에도 있지만, 이것이 제 기준으로는 굉장히 간단한 장소로 보였습니다. 우리가 필요로 하는 다른 모든 정보가 포함된 top_container 및 bottom_container도 있습니다. 레스토랑 이름은 top_container의 title 객체 안에 있는 텍스트 항목에서 추출할 수 있습니다. 주문 ID는 딥링크에서 시작 태그를 대체하고 숫자를 유지하여 간단히 추출할 수 있습니다. 주문 상태는 top_container의 title 객체 안에 있는 텍스트 항목에서 추출할 수 있습니다. 주문 배달 시간은 bottom_container의 title 객체 안에 있는 텍스트 항목에서 추출할 수 있습니다.\n\n마찬가지로 주문을 배치하고 앱의 주문 상세 페이지에서 트래픽 활동을 분석하면 다음 API Endpoint가 반복적으로 호출됩니다:\n\n```js\nhttps://api.zomato.com/v2/order/crystal_v2\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 엔드포인트의 응답에는 많은 개인 정보가 포함되어 있기 때문에 샘플 응답을 공유할 수 없습니다. 그러나 참고로 응답에서 다음 태그들은 다음 정보를 제공합니다 :\n\n```js\nresponse -> order_details -> res_name = 음식점 이름\nresponse -> order_details -> tab_id = 주문 ID\nresponse -> header_data -> pill_data -> left_data -> title -> text  = 예상 시간 (문자열) [예: 5분 후 도착 예정]\nresponse -> header_data -> subtitle2 -> text = 텍스트 형식의 주문 상태 [예: 길을 가는 중, 곧 픽업될 예정 등]\nresponse -> header_data -> pill_data -> right_data -> title -> text = 주문 예상 상태 [예: 제 시간, 지연됨]\n```\n\n# Part 3: 알림 디자인\n\n데이터 가져오기 부분이 해결되었으므로, iOS의 활동 표시기에서 영감을 받은 알림 시스템을 구축하고 싶습니다. 이는 Zomato가 iOS 앱에서 활동 표시 서비스를 활용하는 방식입니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 Figma 디자인으로 만든 Android 알림의 유사한 레이아웃입니다:\n\n![Android 알림 디자인](/assets/img/2024-06-19-HowIreverseengineeredtheZomatoapptobuildmyownOrderTrackingnotificationsystem_2.png)\n\niOS 활동 지시기와 마찬가지로 앱에서 생성된 알림은 레스토랑 이름, 현재 주문 상태의 텍스트 표현, 배송 시간 예상 상태 및 실제 배송 전달 시간 예상을 표시합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 파트 3: 정보 흐름 처리 및 알림 관리\n\n![이미지](/assets/img/2024-06-19-HowIreverseengineeredtheZomatoapptobuildmyownOrderTrackingnotificationsystem_3.png)\n\n정기적으로 업데이트할 수 있는 알림을 갖기 위해 Foreground Service를 활용하고 주문 세부 정보를 계속 가져오도록 하는 기능이 필요합니다. 이 서비스를 \"OrderTrackService\"라고 부르겠습니다. 이 서비스의 주요 목적은 주문 ID를 수락하고 crystal_v2 API를 호출하여 주문 상태 정보를 가져온 다음 해당 정보를 알림에 표시하는 것입니다. 이 작업은 30초 간격으로 반복되며 주문 상태가 \"배달 완료\"가 될 때까지 실행됩니다.\n\n알림을 처리하기 위해 주문 정보를 표시하는 사용자 정의 레이아웃을 만들 것입니다. 알림은 특정 ID로 표시됩니다. Android에서 동일한 ID로 알림을 다시 보내면 알림 패널에 이미 표시된 기존 알림이 자동으로 업데이트됩니다. 따라서 우리는 주문 정보를 가져와 기존 ID를 사용하여 알림을 다시 만들고 표시하는 이 논리를 활용합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n서비스를 제어하고 시작하기 위해서는 Activity도 필요합니다. 이 Activity의 주요 목적은 주문 내역을 가져와 목록으로 표시하는 것입니다. 이 목록을 통해 어떤 주문 ID를 OrderTrackService에 전달하여 알림을 처리할지 선택할 수 있습니다.\n\n# 파트 4: 모두 함께 사용하기\n\n디자인과 시스템이 명확하게 정해지면 이제 아이디어를 현실로 구현할 때입니다. 먼저 Jetpack Compose를 사용하여 MainActivity를 구현하여 시작했습니다. 메인 액티비티에는 세 개의 버튼이 있습니다. 첫 번째 버튼은 앱에 POST_NOTIFICATION 권한을 요청하는 기능을 합니다. 두 번째 버튼은 Foreground 서비스를 시작하는 기능을 하며, 마지막 버튼은 주문 내역을 가져오는 데 사용됩니다. \"주문 가져오기\" 버튼을 탭하면 앱은 online_order API를 호출하고 주문 상태가 \"배달완료\"가 아닌 결과를 필터링합니다. 필터링된 주문은 현재 활성화된 주문입니다.\n\nAPI 엔드포인트를 호출하기 위해 retrofit 라이브러리를 구현하고 필요한 헤더와 함께 적절한 인터페이스를 만들었습니다. 코드 품질을 보장하기 위해 모든 것을 MVVM 패턴을 사용하여 구현했고 Retrofit 인스턴스를 처리하기 쉽도록 의존성 주입을 위해 Hilt를 사용했습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nOrderTrackService 클래스는 Service 클래스의 확장입니다. 우리는 여기서 알림 로직을 처리할 것입니다. MainActivity와 OrderTrackService 간의 통신은 Broadcast Intents를 통해 설정됩니다. MainActivity에 표시된 목록의 각 주문에 대응하는 버튼은 주문 ID가 Intent의 데이터 번들 일부로 포함된 Broadcast Intent를 보냅니다. 이 Broadcast Intent를 받으면 Foreground Service가 작동하여 crystal_v2 API를 호출하여 지정된 주문 ID에 대한 주문 세부 정보를 가져옵니다. 그런 다음 정보를 표시하는 알림을 생성합니다. 가져오기 및 게시 로직은 Kotlin Flow 내에서 작동하도록 제작되어 여러 알림을 독립적으로 처리할 수 있도록 지원하며 필요한 경우 반복적인 Flow를 시작합니다. Flow를 사용하면 원하는대로 작업을 일시 중지/반복할 수 있으므로 동일한 작업을 원하는 지연 시간(우리의 경우 여기서는 30초)으로 반복할 수도 있습니다.\n\n\n<img src=\"/assets/img/2024-06-19-HowIreverseengineeredtheZomatoapptobuildmyownOrderTrackingnotificationsystem_4.png\" />\n\n\n# 최종:\n\n이 사용자 지정 앱은 내 시간을 절약할 뿐만 아니라 주문 상태를 효율적으로 파악하는 더 나은 방법을 제공합니다. 개발 이후로 앱을 여러 번 들여다보지 않고도 주문 상태를 손쉽게 추적할 수 있어서 매우 편리합니다. 본문이 역공학 및 네트워크 호출의 구현 과정에 대한 통찰을 제공했기를 바랍니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 프로젝트의 완전한 소스 코드를 GitHub 리포지토리에서 확인할 수 있어요:\n\n[https://github.com/oddlyspaced/zomato-notification/tree/main](https://github.com/oddlyspaced/zomato-notification/tree/main)\n\n자유롭게 탐색하고 실험하며, 더 많은 향상을 위한 아이디어가 있으면 프로젝트에 기여해주세요.\n","ogImage":{"url":"/assets/img/2024-06-19-HowIreverseengineeredtheZomatoapptobuildmyownOrderTrackingnotificationsystem_0.png"},"coverImage":"/assets/img/2024-06-19-HowIreverseengineeredtheZomatoapptobuildmyownOrderTrackingnotificationsystem_0.png","tag":["Tech"],"readingTime":9},{"title":"다중 환경에서 Terraform을 사용하여 AWS Lambda 함수를 배포하는 방법","description":"","date":"2024-06-19 13:38","slug":"2024-06-19-DeploymentofAWSLambdaFunctionsAcrossMultipleEnvironmentsUsingTerraform","content":"\n## 여러 환경에 걸쳐 AWS Lambda 함수를 배포하는 방법 배우기 — Hashicorp Terraform을 통해 가능하게 하기\n\n![이미지](/assets/img/2024-06-19-DeploymentofAWSLambdaFunctionsAcrossMultipleEnvironmentsUsingTerraform_0.png)\n\nAWS Lambda는 서버를 프로비저닝하거나 관리하지 않고 코드를 실행할 수 있는 서버리스 컴퓨팅 서비스로, 배포 프로세스를 간소화하고 비즈니스가 자동으로 확장할 수 있게 합니다. 그러나 특히 여러 환경에 걸쳐 Lambda 함수를 배포하는 것은 개발 라이프사이클을 복잡하게 만들 수 있는 특정한 도전을 야기합니다.\n\n# Lambda 배포 도전\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nAWS 람다 함수를 배포하는 가장 기본적인 방법은 주로 AWS 관리 콘솔을 통해 zip 파일을 수동으로 업로드하거나 AWS CLI 명령을 사용하는 것입니다. 그러나 이 방법은 몇 가지 어려움을 야기할 수 있습니다:\n\n- 일관성 문제: 수동 프로세스는 실수하기 쉽습니다. 개발, 테스트 및 프로덕션 환경을 거치는 반복 배포가 신중하게 관리되지 않으면 일관성 문제를 야기할 수 있습니다.\n- 확장성 제한: 애플리케이션이 성장함에 따라 여러 함수를 수동으로 관리하는 것은 다루기 어렵고 실수를 유발할 수 있습니다.\n- 구성 관리: 다른 환경(예: 개발, 스테이징, 프로덕션)에 대한 다른 구성을 수동으로 처리하는 것은 복잡하며 구성 드리프트를 야기할 수 있습니다.\n- 버전 관리: 수동 배포는 기본적으로 버전 관리를 지원하지 않으며, 변경 사항을 추적하거나 이전 버전의 함수로 롤백하는 것이 어려울 수 있습니다.\n\n# Terraform을 활용하여 다중 환경 도전을 해결하기\n\n개발, 스테이징, 프로덕션과 같은 여러 환경에 걸쳐 람다 함수를 배포하려면 구성 및 인프라를 일관되게 처리하는 전략이 필요합니다. 이것이 Terraform이 이러한 문제들에 대처하는 방법입니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 인프라스트럭처를 코드로 정의함으로써 Terraform은 배포가 다양한 환경에서 반복 가능하고 일관성 있게 이루어지도록 합니다. 이는 \"내 컴퓨터에서는 작동한다\" 문제를 제거합니다.\n- 환경 분리: Terraform은 워크스페이스나 변수 파일을 활용하여 동일한 코드로 여러 환경을 관리할 수 있습니다. 각 환경은 Terraform의 상태 파일을 통해 구성을 관리함으로써 격리를 보장하고 교차 환경 오염의 위험을 최소화합니다.\n- 자동화된 배포: Terraform은 자원 생성, 수정 및 삭제 과정을 자동화하여 인간 에러 가능성을 줄이고 효율성을 높입니다.\n- 변경 관리와 버전 관리: Terraform을 사용하면 모든 변경 사항이 버전 관리되고 적용되기 전에 검토되어 수정 사항에 대한 감사 트레일을 제공하고 쉬운 롤백 매커니즘을 제공합니다.\n\n# Terraform을 활용한 실용적인 구현\n\n제공된 Terraform 코드는 Lambda 함수용 필요한 인프라를 설정하는 방법을 보여줍니다. IAM 역할, 정책, 그리고 Lambda 함수 자체를 구성하고 Terraform 변수를 사용하여 환경별 구성을 설정합니다.\nAWS Terraform 프로바이더에 익숙하지 않은 경우, Terraform을 AWS에 연결하는 방법을 이해하기 위해 해당 문서를 읽어보세요.\n\n1. IAM 역할 및 정책 설정\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n람다 함수는 다른 AWS 리소스와 상호작용할 것입니다. 이를 위해 IAM 역할을 가정해야 합니다. 먼저 해당 역할을 만들어 봅시다.\n\n```js\n# 람다 함수가 가정할 IAM 역할을 정의합니다.\nresource \"aws_iam_role\" \"lambda_role\" {\n  name               = \"lambda_function_role\"\n  assume_role_policy = <<EOF\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Action\": \"sts:AssumeRole\",\n      \"Principal\": {\n        \"Service\": \"lambda.amazonaws.com\"\n      },\n      \"Effect\": \"Allow\",\n      \"Sid\": \"\"\n    }\n  ]\n}\nEOF\n}\n```\n\n## 설명\n\n이 IAM 역할을 생성하고 해당 가정 역할 정책을 첨부함으로써, 람다 함수가 이 역할을 가정할 수 있게 합니다. 즉, 람다 함수는 이 역할과 관련된 권한을 사용하여 다른 AWS 리소스와 상호작용할 수 있습니다. 예를 들어, 이 역할에 S3 버킷에 액세스를 허용하는 정책을 첨부하면, 람다 함수는 이 역할을 사용하여 해당 버킷에서 읽거나 쓰는 작업을 수행할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-06-19-DeploymentofAWSLambdaFunctionsAcrossMultipleEnvironmentsUsingTerraform_1.png\" />\n\n참고: 본 튜토리얼에서는 환경 변수가 어떻게 사용되는지 간단하게 알 수 있도록 실제 버킷과 AWS 정책은 사용하지 않습니다. 하지만 다음 기사에서 사용할 예정입니다.\n\n# 람다 함수 배포\n\n환경에 따라 다른 변수를 출력하는 기본 \"Hello World!\" 파이썬 함수를 배포할 것입니다. 람다 패키지는 두 개의 파일로 구성됩니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n# index.py, 핸들러가 있는 곳입니다\nfrom config import BUCKET_NAME\n\ndef lambda_handler(event, context):\n   message = f\"버킷 사용 중: {BUCKET_NAME}\"\n   return {\n       'message' : message\n   }\n```\n\n```js\n# config.py, 환경 변수를 가져와 다른 구성을 할 수 있습니다\nimport os\n\n# 지정되지 않은 경우 'mybucket'으로 기본 설정\nBUCKET_NAME = os.getenv('BUCKET_NAME', 'mybucket')\n```\n\n먼저, Lambda 함수 코드가 있는 \"code\" 폴더를 압축하여 배포에 사용할 ZIP 파일로 만들기 위해 Terraform 아카이브 파일 데이터 원본을 정의할 것입니다.\n\n```js\n# Lambda 배포를 위해 Python 코드를 zip 파일로 묶습니다.\ndata \"archive_file\" \"zip_the_code\" {\n  type        = \"zip\"\n  source_dir  = \"./code/\"\n  output_path = \"./code/test-terraform.zip\"\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 화면 구조를 명확하게하기 위해 스크린샷을 여기에 넣었습니다.\n\n![폴더 구조 이미지](/assets/img/2024-06-19-DeploymentofAWSLambdaFunctionsAcrossMultipleEnvironmentsUsingTerraform_2.png)\n\n이제 우리는 람다 자원을 생성하기 위해 출력을 사용할 수 있습니다. 여기서 source_code_hash 속성이 매우 중요합니다. 소스 코드 해시 덕분에 Terraform이 코드의 변경을 감지할 수 있습니다.\n\n```js\n# 환경별 변수로 Lambda 함수를 배포합니다.\nresource \"aws_lambda_function\" \"terraform_lambda_func\" {\n  filename         = data.archive_file.zip_the_code.output_path\n  function_name    = \"MyLambdaFunction\"\n  role             = aws_iam_role.lambda_role.arn\n  handler          = \"index.lambda_handler\"\n  source_code_hash = data.archive_file.zip_the_code.output_base64sha256\n  runtime          = \"python3.8\"\n  environment {\n    variables = {\n      BUCKET_NAME = var.BUCKET_NAME\n    }\n  }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여기서 주요 요소는 환경 블록입니다. 이 블록을 정의함으로써 AWS Lambda가 실행 중에 읽을 수 있는 환경 변수인 BUCKET_NAME의 값을 지정할 수 있습니다.\n\n# 여러 환경 관리\n\n여러 환경을 관리하는 방법으로는 Terraform 워크스페이스를 사용하거나 서로 다른 변수 파일로 Terraform을 실행하여 각 환경별로 리소스를 분리하고 상태를 별도로 관리하는 데 도움이 됩니다:\n\n```js\n# 새 워크스페이스를 생성하고 개발 환경을 위한 리소스를 배포합니다.\nterraform workspace new development\nterraform apply -var=\"BUCKET_NAME=dev-bucket\"\n\n# 프로덕션 워크스페이스로 전환하고 리소스를 배포합니다.\nterraform workspace new production\nterraform apply -var=\"BUCKET_NAME=prod-bucket\"\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n가끔은 많은 환경 변수를 정의해야 할 때가 있습니다. 그럴 땐 환경에 따라 다른 테라폼 변수 파일을 가리킬 수 있습니다.\n\n## 예시\n\n```js\nterraform apply -var-file=\"dev-variables.tfvars\"\nterraform apply -var-file=\"prod-variables.tfvars\"\n```\n\n## 결론\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nAWS Lambda 함수를 여러 환경에 배포하기 위해 Terraform을 사용하면 배포를 표준화하고 서버리스 애플리케이션을 간단하게 관리할 수 있어요.\n\n다음에는 GitHub 액션, CSV 파일 및 적절한 폴더 구조를 사용하여 오늘 본 개념과 기술을 어떻게 제품화하는지 보여 드릴게요.\n\n읽어 주셔서 감사합니다. 저는 Infostrux의 데이터 아키텍트인 Mehdi Sidi Boumedine입니다. LinkedIn에서 저와 연락하거나 팔로우하고 Infostrux 블로그의 최신 기고를 확인해 주세요. 다음 글도 기대해 주세요.\n","ogImage":{"url":"/assets/img/2024-06-19-DeploymentofAWSLambdaFunctionsAcrossMultipleEnvironmentsUsingTerraform_0.png"},"coverImage":"/assets/img/2024-06-19-DeploymentofAWSLambdaFunctionsAcrossMultipleEnvironmentsUsingTerraform_0.png","tag":["Tech"],"readingTime":8},{"title":"테라폼 인터뷰 질문들","description":"","date":"2024-06-19 13:37","slug":"2024-06-19-TerraformInterviewQuestions","content":"\n먼저, 아래 Markdown 형식으로 표 태그를 변경하실 수 있습니다.\n\n![image](/assets/img/2024-06-19-TerraformInterviewQuestions_0.png)\n\nQ1: 테라폼을 사용하여 ec2 인스턴스를 만들었다고 가정해보겠습니다. 그리고 생성 후, 상태 파일에서 해당 항목을 제거했습니다. 그럼, terraform apply를 실행하면 어떻게 될까요?\n\n- 상태 파일에서 항목을 제거했기 때문에 terraform은 더 이상 해당 리소스를 관리하지 않게 됩니다. 따라서, 다음 apply에서는 새로운 리소스를 생성하게 됩니다.\n\nQ2: Terraform에서 상태 파일(State file)이란 무엇인가요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 상태 파일은 Terraform이 배포한 모든 인프라를 추적하는 파일입니다.\n\nQ3: 테라폼 상태 파일을 저장하는 가장 좋은 방법은 무엇인가요?\n\n- 상태 파일을 저장하는 가장 좋은 방법은 S3 또는 GitLab 관리 테라폼 상태와 같은 원격 백엔드에 유지하는 것입니다. 이렇게 하면 여러 사람이 동일한 코드 자원에 작업할 때 자원 중복이 발생하지 않습니다.\n\nQ4: 테라폼 상태 잠금이란 무엇인가요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 테라폼 코드를 작성할 때 terraform plan, apply 또는 destroy를 실행하면 테라폼이 파괴적인 작업을 방지하기 위해 상태 파일을 잠근다.\n\nQ5: 테라폼 백엔드란 무엇인가요?\n\n- 백엔드는 테라폼이 상태 데이터 파일을 저장하는 위치를 정의합니다. 테라폼은 관리하는 리소스를 추적하기 위해 지속적인 상태 데이터를 사용합니다.\n\nQ6: 테라폼에서 플러그인이란 무엇인가요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 플러그인은 HCL 코드를 API 호출로 변환하고 해당 공급업체(AWS, GCP)에 요청을 보내는 역할을 합니다.\n\nQ7: 널 리소스(null resource)란 무엇인가요?\n\n- 널(null)이라는 접두어가 붙어 있는 것을 보니 이 리소스는 클라우드 인프라에 존재하지 않을 것을 의미합니다.\n- Terraform의 null_resource는 다음과 같은 시나리오에서 사용할 수 있습니다 -\n- 쉘 명령 실행\n- 로컬 프로비저너 및 원격 프로비저너와 함께 사용할 수 있습니다.\n- Terraform 모듈, Terraform count, Terraform 데이터 소스, 로컬 변수와 함께 사용할 수 있습니다.\n- 출력 블록에도 사용할 수 있습니다.\n\nQ8: 프로비저너의 종류는 무엇이 있나요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 원격 exec: 원격 서버에서 Terraform을 사용하여 명령 실행\n- 로컬 exec: 로컬 시스템에서 Terraform을 사용하여 명령 실행\n\nQ9: Terraform 모듈의 사용 목적은 무엇인가요?\n\n- 한 번만 terraform 모듈을 생성하고 필요할 때마다 재사용할 수 있습니다.\n- 코드를 표준화하려고\n- 코드 중복을 줄이려고\n- 모듈을 버전별로 관리할 수 있습니다.\n\nQ10: Terraform으로 EC2와 VPC를 생성했는데 불행하게도 tfstate 파일이 삭제되었습니다. 복구할 수 있나요? (파일은 S3나 Dynamo DB에 있지 않고 로컬 머신에만 있음)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- Terraform import 명령을 사용하여 Terraform에 의해 생성된 리소스를 가져올 수 있습니다. 그러면 해당 리소스가 상태 파일에 저장됩니다.\n\nQ11: 만약 VPC, EC2, 보안 그룹, 액세스 키, 서브넷과 같이 여러 모듈을 생성했다면, Terraform은 어떻게 첫 번째로 배포할 리소스를 알 수 있을까요?\n\n- Terraform은 코드 내의 리소스 참조를 기반으로 종속성 그래프를 자동으로 파악합니다. 리소스간의 관계를 이해하고, 이 정보를 사용하여 리소스를 생성 또는 수정해야 할 순서를 결정합니다.\n- depends_on 키워드를 사용하여 명시적인 종속성을 정의할 수 있습니다.\n\nQ12: 어떻게 로직을 변경하지 않고 특정 리소스를 삭제/파괴할 수 있을까요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- taint과 destroy 명령어 사용하기\n- 해당 리소스를 taint하려면 terraform taint RESOURCE_TYPE.RESOURCE_NAME 명령어를 사용해야 합니다.\n- 리소스를 taint한 후, tainted된 리소스를 제거하기 위해 terraform destroy -target=RESOURCE_TYPE.RESOURCE_NAME 명령어를 실행할 수 있습니다.\n\nQ13: 테라폼에서 리소스 이름을 변경하는 방법은 무엇인가요?\n\n- 테라폼 mv 명령어를 사용하여 리소스 이름을 변경할 수 있습니다.\n\nQ14: 테라폼을 사용하여 EC2 인스턴스를 생성했는데, 누군가 수동으로 변경을 했다면, 다음에 Terraform plan을 실행하면 무엇이 발생하나요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- Terraform 상태가 일치하지 않으면 Terraform이 EC2 인스턴스를 원하는 상태로 수정합니다. 즉, .tf 파일에 정의한 것과 일치하게 됩니다.\n\nQ15: Terraform에서 locals와 variables의 차이점은 무엇인가요?\n\n- 변수는 variables.tf 파일에 정의되거나 variables 키워드를 사용하여 정의됩니다. 변수는 덮어쓸 수 있지만 로컬 변수는 덮어쓸 수 없습니다.\n- 따라서 변수를 덮어쓰지 못하게 제한하려면 locals을 사용해야 합니다.\n","ogImage":{"url":"/assets/img/2024-06-19-TerraformInterviewQuestions_0.png"},"coverImage":"/assets/img/2024-06-19-TerraformInterviewQuestions_0.png","tag":["Tech"],"readingTime":5},{"title":"테라폼 안전하고 고가용성이 높으며 고장 허용성이 있는 클라우드 인프라 배포하기","description":"","date":"2024-06-19 13:35","slug":"2024-06-19-TerraformDeployingSecureHighlyAvailableandFault-TolerantCloudInfrastructures","content":"\n## \"구름의 공포\"\n\n![Image](/assets/img/2024-06-19-TerraformDeployingSecureHighlyAvailableandFault-TolerantCloudInfrastructures_0.png)\n\n# 소개\n\n강력하고 신뢰할 수 있는 클라우드 인프라는 기업이 고객에게 원활한 서비스를 제공하는 데 중요합니다. 고가용성과 내결함성은 이러한 인프라의 중요한 구성 요소입니다. 이를 달성하기 위해 많은 조직이 Terraform과 같은 인프라 자동화 도구를 활용하여 클라우드 자원을 배포하고 관리합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 글에서는 Terraform을 사용하여 AWS에 높은 가용성과 장애 허용성을 갖춘 클라우드 환경을 배포하는 방법을 살펴보겠습니다. 사용자 정의 VPC의 프라이빗 서브넷에 걸쳐 두 가용 영역을 포함하는 Auto Scaling 그룹 (ASG)을 포함한 환경을 만들어봅니다. 또한 ASG를 퍼블릭 서브넷에 놓인 애플리케이션 로드 밸런서 (ALB)로 프론트 엔드로 사용하고, 적절한 게이트웨이와 라우트 테이블 구성에 대해 살펴봅니다.\n\n결과적으로, Terraform을 활용하여 안정적이고 확장 가능한 클라우드 인프라를 구축하는 방법에 대한 깊은 이해를 갖게 될 것입니다. 이를 통해 고트래픽을 처리하고 각 구성요소의 개별 실패에도 가동 시간을 유지할 수 있는 클라우드 인프라를 구축할 수 있게 됩니다.\n\n자, 함께 알아보겠습니다!\n\n# 배경\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 테라폼\n\n이전에 작성한 기사 \"밤을 통해 테라포밍\"에서는 테라폼에 대해 잘 설명하고, 그 이점 및 테라폼의 가장 기본적인 개념 중 일부를 소개했어요.\n\n오늘의 데모를 위해 신속하게 준비하려면 해당 기사로 이동하여 소개 및 배경 그리고 기본 테라폼 명령어 섹션을 읽어보는 걸 권장합니다.\n\n## 아마존 EC2 오토 스케일링 그룹 (ASG)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nAWS에서 제공하는 Amazon EC2 Auto Scaling 그룹은 수요에 따라 그룹 내 EC2 인스턴스의 수를 자동으로 조정해주는 서비스입니다.\n\n이를 통해 워크로드를 처리할 수 있는 원하는 인스턴스 수를 유지하고, 필요에 따라 인스턴스를 자동으로 추가하거나 제거할 수 있습니다. 이를 통해 애플리케이션은 수요에 따라 신축성 있게 확장 또는 축소할 수 있으며, 필요한 인스턴스만 실행하여 비용을 최적화할 수 있습니다.\n\nEC2 Auto Scaling 그룹은 다양한 스케일링 정책, 런치 구성, 인스턴스 유형을 구성하여 효율적이고 안정적인 애플리케이션 성능을 보장할 수 있습니다.\n\n## 애플리케이션 부하 분산기 (ALB)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nAWS의 Application Load Balancer(ALB)는 애플리케이션 수준 콘텐츠를 기반으로 EC2 인스턴스와 같은 여러 대상에 대한 들어오는 트래픽을 분산시킬 수 있습니다.\n\nALB는 고급 라우팅 규칙을 기반으로 다양한 대상으로 트래픽을 지능적으로 라우팅할 수 있습니다. 이러한 라우팅 규칙에는 경로 기반 라우팅, 호스트 기반 라우팅, HTTP 헤더 기반 라우팅이 포함됩니다.\n\nALB는 SSL/TLS 오프로딩, 연결 드레이닝, 스티키 세션과 같은 다양한 기능을 제공하며, AWS의 자동 확장 및 탄력성 기능과 함께 사용하여 최적의 성능과 확장성을 보장할 수 있습니다.\n\n# 필수 사항\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- Terraform 개념과 명령어에 대한 기본 지식 및 이해도\n- 기본적인 리눅스 명령 줄 지식\n- IAM 사용자 및 관리 권한이 있는 AWS 계정\n- 사용할 준비가 된 AWS Cloud9 IDE\n- AWS CLI가 설치되어 Cloud9 IDE에 구성됨\n- Amazon EC2 키페어\n\n# 사용 사례\n\n전자 상거래 회사인 REX TECH Corp는 휴일 시즌 동안 트래픽 증가를 처리해야 합니다. 회사는 웹 사이트가 고객에게 항상 응답 가능하고 이용 가능하도록 하기를 원합니다.\n\n당신의 매니저가 AWS에 클라우드 인프라를 배포하여 가용성과 고장 허용성을 보장할 것을 지시했습니다. 당신은 고객이 항상 웹 사이트에 접속할 수 있도록 하기 위해 트래픽에 따라 EC2 Auto Scaling 그룹(ASG)을 배포하기 위해 Terraform을 활용하기로 결정했습니다. 이 그룹은 개인 서브넷에 배포되며 공개 서브넷의 응용 프로그램 로드 밸런서(ALB)에 의해 선전되며, 트래픽에 따라 자동으로 확장 또는 축소되어 웹 사이트가 항상 고객에게 응답 가능하도록 보장합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 목표\n\n- 두 개의 공용 서브넷, 두 개의 사설 서브넷이 있는 사용자 정의 가상 사설망(VPC)을 생성합니다.\n- 공용 서브넷에 NAT 게이트웨이를 활용하고, 인터넷 게이트웨이를 사용하여 외부 인터넷 트래픽을 제공합니다.\n- 공용 라우팅 테이블과 사설 라우팅 테이블을 구성합니다.\n- 공용 서브넷에 ALB를 시작합니다.\n- 사설 서브넷에 Auto Scaling 그룹을 시작합니다.\n- ALB의 공용 DNS를 출력하고 해당 URL을 사용하여 웹 서버에 도달 가능한지 확인합니다.\n\n# 단계 0: IDE 환경에서 최신 Terraform 버전 설치\n\nAWS Cloud9은 Terraform이 사전 설치되어 있지만, 최신 버전으로 업그레이드하여 해당 기능과 기능을 완전히 활용하는 것이 중요합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n클라우드9 IDE에 최신 Terraform 버전을 설치하려면 다음 명령어를 차례대로 실행해주세요 —\n\n```js\nsudo yum install -y yum-utils\nsudo yum-config-manager --add-repo https://rpm.releases.hashicorp.com/AmazonLinux/hashicorp.repo\nsudo yum -y install terraform\n```\n\n클라우드9 터미널에서 \"terraform version\"을 실행하여 최신 버전이 정상적으로 설치되었는지 확인해주세요 —\n\n![이미지](/assets/img/2024-06-19-TerraformDeployingSecureHighlyAvailableandFault-TolerantCloudInfrastructures_1.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이해를 높이고 데모를 더 효과적으로 따르기 위해 아래 링크를 클릭하여 GitHub에서 프로젝트 저장소를 클론해 주세요. 계속 진행하면서 필요한 대로 파일을 편집해도 괜찮아요.\n\n이제 Step 1로 이동해봅시다. - 커스텀 VPC 생성 및 구성.\n\n# Step 1: 커스텀 AWS VPC 생성 및 구성\n\n우리의 초기 목표는 AWS 환경 내에서 모든 리소스를 배포할 수 있는 커스텀 VPC를 구축하는 것입니다. 이를 위해 논리적으로 격리된 CIDR 블록을 정의하고 적합한 서브넷 및 해당 가용 영역(AZ)을 신중히 선택하여 배포해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래 테라폼 파일 코드를 검토해 봅시다. 사용자 정의 VPC를 생성하고 구성하는 코드입니다.\n\n## 코드 설명\n\n여기서는 지정된 CIDR 블록과 인스턴스 테넌시를 사용하여 AWS VPC를 생성합니다. 그런 다음 네 개의 서브넷을 생성합니다. 두 개는 공개 서브넷이고 두 개는 사설 서브넷입니다. 각 서브넷은 지정된 CIDR 블록을 가지며 앞서 생성된 VPC와 연결되어 지정된 가용 영역에 배포되도록 정의되어 있습니다.\n\n공개 서브넷은 map_public_ip_on_launch 속성이 true로 설정되어 있어 해당 서브넷에 배포된 인스턴스에는 자동으로 공개 IP 주소가 할당됩니다. 사설 서브넷은 해당 속성이 false로 설정되어 있어 해당 서브넷에 배포된 인스턴스는 NAT 게이트웨이를 통해 인터넷에서 접속할 수 없습니다. 각 서브넷에는 태그를 사용하여 이름이 지정되어 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 사용자 정의 VPC를 생성하고 구성했으니, 2단계로 넘어가서 인터넷 게이트웨이와 NAT 게이트웨이를 생성해 봅시다.\n\n# 2단계: 공용 서브넷에 인터넷 게이트웨이 및 NAT 게이트웨이 생성\n\nVPC에서 리소스를 배포할 때, 인터넷에 안전하고 효율적으로 연결되도록하는 것이 중요합니다. 이를 위해 공용 서브넷에 인터넷 게이트웨이와 NAT 게이트웨이를 생성하는 방법 중 하나입니다.\n\n인터넷 게이트웨이는 VPC 구성요소로서 VPC 내의 인스턴스와 인터넷 간의 통신을 허용합니다. 한편, NAT 게이트웨이는 사설 서브넷에 있는 인스턴스가 인터넷이나 다른 AWS 서비스에 연결할 수 있도록하며, 외부 트래픽에 대한 추가 보안도 제공합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래에서 Terraform 파일을 만들고 구성하여 인터넷 게이트웨이와 NAT 게이트웨이를 생성하는 코드를 살펴보겠습니다 —\n\n## 코드 설명\n\n먼저, 인터넷 게이트웨이를 생성하고 사용자 정의 VPC에 연결합니다. 또한 Elastic IP 주소와 NAT 게이트웨이를 생성하고 Elastic IP와 공용 서브넷에 연결합니다. 인터넷 게이트웨이가 NAT 게이트웨이를 생성하기 전에 먼저 생성되도록 합니다.\n\n좋아요! 이제 인터넷 게이트웨이와 NAT 게이트웨이가 생성되었으니, 다음은 — 3단계로 넘어가 공용 및 사설 라우트 테이블을 구성하는 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 단계 3: 공용 라우트 테이블 및 사설 라우트 테이블 구성\n\n이 시점에서, 우리는 맞춤형 VPC와 게이트웨이를 성공적으로 생성했습니다. 그러나, 지금 직면한 문제는 VPC에 배포된 서비스 및 다른 구성 요소들 간의 통신을 관리하는 것입니다. 이곳에서 VPC 내에서의 네트워크 트래픽 흐름을 구성하는 것이 중요해집니다. 이를 위해, 서브넷 간의 네트워크 트래픽을 안내하기 위해 라우팅 테이블을 설정하는 것이 효과적입니다.\n\n아래의 코드를 검토하여 각각의 라우트 테이블을 생성하고 구성하는 방법을 확인해보겠습니다 —\n\n## 코드 설명\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여기에서는 두 개의 라우팅 테이블을 생성 중입니다 — 공개 라우팅 테이블과 사설 라우팅 테이블. 공개 라우팅 테이블은 인터넷 게이트웨이로의 기본 경로를 갖고 있으며, 사설 라우팅 테이블은 NAT 게이트웨이로의 기본 경로를 갖고 있습니다.\n\n공개 라우팅 테이블은 두 개의 공개 서브넷과 연결되어 있고, 사설 라우팅 테이블은 두 개의 사설 서브넷과 연결되어 있습니다. 사설 리소스 연결은 사설 라우팅 테이블이 생성된 후에 수립됩니다. 이 라우팅 테이블에는 태그를 사용하여 이름이 지정되어 있습니다.\n\n이제, Step 4로 계속해 봅시다! 공개 서브넷에서 새 ALB를 실행합니다.\n\n# Step 4: 공개 서브넷에 ALB를 실행합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n사용자의 ALB를 활성화하기 위한 과정을 살펴보겠습니다. 사용자 정의 VPC의 공용 서브넷에서 ALB를 생성하는 것은 여러 단계를 거칩니다. 이 단계에는 보안 그룹 생성, 대상 그룹, 리스너 및 라우팅 규칙 설정이 포함됩니다.\n\n아래의 Terraform 코드를 검토해보세요. 이 코드는 ALB와 연결할 보안 그룹을 생성합니다.\n\n## 코드 설명\n\n이 Terraform 코드에서는 ALB와 함께 사용할 보안 그룹을 생성합니다. 보안 그룹은 이름과 설명과 함께 정의되며, 사용자 정의 VPC와 연관됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nIngress 규칙을 통해 특정 CIDR 블록에서 HTTP 및 SSH 트래픽을 허용하고, 모든 트래픽을 허용하는 egress 규칙도 있습니다. 또한 보안 그룹에 쉽게 식별할 수 있도록 이름을 태그합니다.\n\n이제 ALB를 생성하고 구성하는 코드를 검토할 수 있습니다 —\n\n## 코드 설명\n\n여기서 ALB 및 해당 리소스를 생성합니다. 먼저 ALB를 생성하고, 사용할 이름, 서브넷 및 보안 그룹을 지정합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nALB가 트래픽을 전달할 타겟 그룹을 생성하여 이름, 포트, 프로토콜 및 헬스 체크 구성을 지정합니다.\n\n마지막으로 ALB를 위해 리스너를 생성하여 수신할 포트와 프로토콜을 지정하고, 기본 작업을 이전에 생성한 타겟 그룹으로의 트래픽 전달로 설정합니다. 이렇게 하면 리스너 규칙과 타겟 그룹의 구성에 따라 적절한 리소스로 트래픽이 전달됩니다.\n\n이제 다음 단계로 계속해 보죠. Terraform 구성 파일을 검토하여 사용자 정의 VPC를 생성하고 해당 적절한 서브넷을 구성하며, 인터넷 및 NAT 게이트웨이, 그리고 공용 및 비공용 라우팅 테이블을 설정했습니다. ALB의 구성이 이제 완료되어 준비되었으므로, Step 5로 이동할 수 있습니다 — 비공용 서브넷에서 ASG를 시작합니다.\n\n# Step 5: 비공용 서브넷에서 자동 스케일링 그룹 시작하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n오토 스케일링 그룹(ASG)은 일반적으로 공용 서브넷에 배포되지만, 민감한 데이터를 다루거나 규제 요구 사항을 준수해야 하는 경우와 같이 사설 서브넷을 선호하는 경우가 많이 있습니다.\n\n아래 코드를 살펴보면, 두 가용 영역(AZ)에 걸쳐 EC2 ASG를 사설 서브넷에서 시작하는 단계를 설명합니다 —\n\n## 코드 설명\n\n우선, ASG 런치 템플릿용 보안 그룹을 생성하고, 이를 이전에 생성한 사용자 정의 VPC와 연결해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n보안 그룹은 ALB의 보안 그룹에서 엄격히 HTTP 및 SSH 프로토콜에 대한 인바운드 트래픽을 허용합니다. 이렇게 함으로써 ASG에 대한 액세스는 ALB에서만 가능하게 되어 보안이 제공됩니다. 보안 그룹은 상태를 유지하므로 정의된 변수에서 지정된 CIDR 블록으로 어디서든지 아웃바운드 트래픽을 허용합니다.\n\n## Bash 스크립트\n\nASG를 생성하기 위해 우리가 준비할 것은 ASG의 런치 템플릿에 통합될 bash 스크립트를 먼저 작성하는 것입니다. 이 스크립트는 EC2 인스턴스의 사용자 데이터 역할을 하여 Apache 웹 서비스의 설치 및 시작, 그리고 맞춤식 웹 페이지의 생성을 자동화합니다.\n\n아래의 bash 스크립트를 살펴봅시다 —\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 코드 설명\n\n이 스크립트에서는 먼저 모든 yum 패키지 저장소를 업데이트한 다음 yum을 사용하여 Apache Web Server 패키지를 설치합니다. 그런 다음 Apache 서비스를 시작하고 부팅 시 자동으로 시작되도록 활성화합니다.\n\n또한 이 스크립트는 흔히 사용되는 소프트웨어 패키지를 쉽게 설치할 수 있게 하는 Extra Packages for Enterprise Linux (EPEL) 저장소를 설치합니다.\n\n또한 스크립트는 인스턴스를 고부하로 테스트하는 데 사용할 수 있는 stress 패키지를 설치합니다. 마지막으로 스크립트는 기본 index.html 파일에 REX TECH에 오신 것을 환영합니다! 메시지가 포함된 사용자 정의 웹페이지를 Apache 문서 루트 디렉토리 /var/www/html/에 추가합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## ASG 생성 및 구성\n\n우리의 ASG 보안 그룹 및 Bash 스크립트가 생성되었으므로 이제 ASG를 만들고 구성할 차례입니다 —\n\n## 코드 설명\n\nASG를 생성할 때 최소, 최대 및 원하는 용량을 설정해야 합니다. 또한 ASG는 서브넷 ID로 식별되는 두 개의 사설 서브넷에서 시작됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n런치 템플릿(Launch Template)은 Amazon Machine Image (AMI), 인스턴스 유형 및 키파일과 같은 구성과 함께 생성됩니다. 여기에는 이전에 생성한 Bash 스크립트를 base64로 인코딩한 사용자 데이터 파일로 지정합니다. 이는 Apache 웹 서버를 설치하고 시작하고 사용자 정의 웹 페이지를 생성하는 스크립트를 실행합니다.\n\n마지막으로 ASG를 ALB의 대상 그룹에 자동 확장 첨부를 사용하여 연결합니다. 이를 통해 ASG가 들어오는 트래픽에 대응하여 인스턴스 간 부하를 자동으로 균형 잡아 최적의 성능과 가용성을 보장합니다.\n\n이제 6단계로 넘어가서 output.tf 파일을 활용하여 ALB의 퍼블릭 DNS를 얻어봅시다.\n\n# Step 6: output.tf 파일을 활용하여 ALB의 퍼블릭 DNS를 얻기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nALB를 만든 후에는 ALB의 공개 DNS에 직접 액세스하는 것이 귀찮을 수 있습니다. 다행히도, 테라폼에서 output.tf 파일을 생성하여 ALB의 공개 DNS를 즉시 얻을 수 있는 쉬운 해결책을 제공할 수 있습니다. 이를 통해 들어오는 트래픽이 올바르게 타깃 그룹 내의 인스턴스로 경로 지정되도록 보장할 수 있습니다.\n\n아래 output.tf 파일을 확인해 봅시다 —\n\n## 코드 설명\n\nOutputs를 사용하면 테라폼 인프라에서 생성된 리소스의 값들을 볼 수 있습니다. 여기서 우리는 테라폼 인프라를 위해 여러가지 output을 생성합니다. 각 output은 다른 리소스를 참조합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저희의 출력물에는 VPC의 ID, 퍼블릭 및 프라이빗 서브넷의 ID, 인터넷 게이트웨이와 ALB의 DNS 이름이 포함됩니다. 이러한 출력물은 인프라에 대한 정보를 제공하기 위해 사용될 것입니다.\n\n이제, 7단계로 넘어갑시다 — 리소스 인자의 동적 값에 대한 변수 생성.\n\n# Step 7: 리소스 인자의 동적 값에 대한 변수 생성\n\nTerraform을 사용하여 인프라스트럭처를 생성할 때 리소스 인자에 동적 값들을 사용하는 것이 일반적입니다. 이러한 동적 값들은 사용자 입력, 환경 변수 또는 다른 리소스의 출력 값에 기반할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이러한 동적 값들을 관리하기 위해 변수를 사용하는 것이 중요합니다. 변수를 사용하면 배포 사항 전반에 걸쳐 일관성을 유지하고, 코드를 읽고 유지하기 쉽게 만들며, 코드의 재사용성을 가능케 합니다.\n\n아래 코드에서 정의한 많은 변수들을 살펴봅시다 —\n\n## 코드 설명\n\n이곳에서는 이 Terraform 프로젝트에서 동적 값들을 사용할 수 있게 해주는 일련의 변수들을 정의합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n각 변수에는 이름, 기본값 및 유형이 있습니다. 기본값은 Terraform 코드를 실행할 때 특정 값이 지정되지 않은 경우 변수가 설정되는 값을 나타냅니다. 유형은 변수의 예상 데이터 유형을 지정합니다.\n\n예를 들어, aws_region 변수는 기본값으로 us-east-1을 가지고 있으며 문자열 유형을 갖습니다. 이는 문자열 값을 예상한다는 것을 의미합니다. 마찬가지로 auto-assign-ip 변수는 기본값으로 true를 가지고 있으며 불리언(bool) 유형을 갖습니다. 이는 불리언 값을 예상한다는 것을 의미합니다.\n\n일부 변수는 인프라의 네트워킹 구성 요소와 관련되어 있으며 VPC, 공용 서브넷 및 사설 서브넷의 이름과 같은 값을 지정합니다.\n\n변수를 정의함으로써 주요 구성 파일을 수정하지 않고 값이 쉽게 변경될 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n알겠어요! 이제 우리가 모든 Terraform 구성 파일들을 검토했으니, Step 8로 넘어갈게요 — 정의된 인프라를 배포하기 위해 Terraform 워크플로우를 실행해봅시다.\n\n# Step 8: Terraform 워크플로우 실행해서 초기화, 유효성 검사, 계획 및 적용하기\n\nCloud9 터미널에서 필요한 공급자를 초기화하려면 Cloud9 터미널에서 다음 명령을 실행해주세요 —\n\n```js\nterraform init\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n초기화 프로세스가 완료되면 아래와 같이 성공적인 프롬프트가 표시됩니다.\n\n![이미지](/assets/img/2024-06-19-TerraformDeployingSecureHighlyAvailableandFault-TolerantCloudInfrastructures_2.png)\n\n이제 다음 명령을 실행하여 코드에 구문 오류가 없는지 확인해보겠습니다 —\n\n```js\nterraform validate\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래와 같이 유효한 것으로 확인되는 성공 메시지를 생성하는 명령어여야 합니다.\n\n![image](/assets/img/2024-06-19-TerraformDeployingSecureHighlyAvailableandFault-TolerantCloudInfrastructures_3.png)\n\n이제 다음 명령어를 실행하여 Terraform이 적용할 모든 수정 사항 목록을 생성해 봅시다. —\n\n```js\nterraform plan\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n테라폼이 기대하는 인프라 리소스에 적용할 변경 목록을 표시해야 합니다. \"+\" 기호는 추가될 내용을 나타내고, \"-\" 기호는 제거될 내용을 나타냅니다.\n\n![변경 목록](/assets/img/2024-06-19-TerraformDeployingSecureHighlyAvailableandFault-TolerantCloudInfrastructures_4.png)\n\n이제 이 인프라를 배포해 봅시다! 다음 명령을 실행하여 변경 사항을 적용하고 리소스를 배포하세요.\n\n참고 - 이 명령을 실행한 후에 변경 사항에 동의하기 위해 \"yes\"를 입력해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nterraform apply\n```\n\n테라폼은 인프라에 대한 모든 변경 사항을 적용하는 프로세스를 시작할 것입니다. 배포 프로세스가 완료될 때까지 잠시 기다려주시기 바랍니다.\n\n![이미지](/assets/img/2024-06-19-TerraformDeployingSecureHighlyAvailableandFault-TolerantCloudInfrastructures_5.png)\n\n# 성공!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n지금은 추가된, 수정된 및 삭제된 리소스의 총 수를 명시하고 \"적용 완료\"라는 메시지로 프로세스를 마무리해야 합니다. 몇 가지 리소스 출력과 함께 해야 합니다.\n\n브라우저에서 웹 페이지에 액세스하려면 ALB의 DNS URL을 복사하여 저장하세요.\n\n![ALB DNS URL](/assets/img/2024-06-19-TerraformDeployingSecureHighlyAvailableandFault-TolerantCloudInfrastructures_6.png)\n\n이제 리소스가 생성되었는지 확인하기 위해 관리 콘솔에서 검토해봅시다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 단계 9: ASG 및 대상 그룹의 건강 상태에서 EC2 인스턴스 생성 확인\n\nAWS 관리 콘솔에서 EC2 대시보드로 이동하여 ASG에서 시작된 두 대 서버가 있는지 확인하세요.\n\n![이미지](/assets/img/2024-06-19-TerraformDeployingSecureHighlyAvailableandFault-TolerantCloudInfrastructures_7.png)\n\n또한 왼쪽 창으로 이동하여 대상 그룹을 선택하고 대상 그룹을 확인하고, 하단으로 스크롤하여 인스턴스의 건강 상태가 정상인지 확인하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-06-19-TerraformDeployingSecureHighlyAvailableandFault-TolerantCloudInfrastructures_8.png\" />\n\n좋아요! ASG가 예상대로 EC2 인스턴스를 생성했고, 모든 대상 그룹의 상태가 정상적으로 표시되고 있는 것을 성공적으로 확인했습니다. 이제 ALB를 통해 ASG의 웹 서버에 액세스할 수 있는지 확인해 봅시다.\n\n# 단계 10: 브라우저에서 URL을 사용하여 웹 서버에 도달 가능한지 확인하기\n\n설정한 브라우저를 열고 ALB의 DNS URL을 브라우저에 붙여넣어 주세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n**알림** - ALB에 연결하려면 \"http://\" 프로토콜을 사용해야 합니다. \"https://\"는 사용하지 마세요.\n\n![사진](/assets/img/2024-06-19-TerraformDeployingSecureHighlyAvailableandFault-TolerantCloudInfrastructures_9.png)\n\n# 축하합니다!\n\n\"The Terror In The Clouds\"를 성공적으로 완료했어요. Terraform을 사용하여 신뢰할 수 있고 확장 가능한 클라우드 인프라를 구축하는 방법을 배웠습니다. 이 인프라는 높은 트래픽을 다룰 수 있으며 개별 구성 요소의 장애가 발생해도 가동 시간을 유지할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 정리하기\n\n## 인프라 파괴\n\n아래 명령어를 실행하여 이전에 Terraform으로 프로비저닝한 모든 리소스를 삭제/제거/해제하세요 —\n\n```js\nterraform destroy\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\"작업이 완료될 때까지 기다려주세요. 마침내 '파괴가 완료되었습니다'라는 메시지와 함께 파괴된 리소스의 양이 표시됩니다.\n\n지금까지 읽어 주셔서 감사합니다! 유익했기를 바랍니다.\n\n![TerraformDeployingSecureHighlyAvailableandFault-TolerantCloudInfrastructures](/assets/img/2024-06-19-TerraformDeployingSecureHighlyAvailableandFault-TolerantCloudInfrastructures_10.png)\n\nIfeanyi Otuonye는 클라우드/데브옵스 엔지니어로 클라우드 기술과 데브옵스 문화에 광신적인 엔지니어입니다. 배우려는 열정으로 움직이며 협업 환경에서 번영합니다. 정보 기술과 프로젝트 관리의 배경을 가지고 있으며 프로 선수의 삶을 균형 있게 유지하고 있습니다. 2021년 말부터 클라우드/데브옵스 엔지니어로 나아가기 위해 자기 학습을 시작했으며, 최근에는 Level Up In Tech 프로그램에 참여하였습니다!\"\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# Master DynamoDB\n\n지금 'TOWARDSAWS' 코드를 사용하여 DynamoDB Book을 35% 할인된 가격으로 구매하세요.\n\n![DynamoDB Book](/assets/img/2024-06-19-TerraformDeployingSecureHighlyAvailableandFault-TolerantCloudInfrastructures_11.png)\n","ogImage":{"url":"/assets/img/2024-06-19-TerraformDeployingSecureHighlyAvailableandFault-TolerantCloudInfrastructures_0.png"},"coverImage":"/assets/img/2024-06-19-TerraformDeployingSecureHighlyAvailableandFault-TolerantCloudInfrastructures_0.png","tag":["Tech"],"readingTime":23},{"title":"OCI에서 Active Directory 게임을 실행하는 방법  1부","description":"","date":"2024-06-19 13:32","slug":"2024-06-19-HowtorunGameofActiveDirectoryinOCIPart1","content":"\n제가 정말 즐겁게 즐겼던 프로젝트 중 하나는 GOAD입니다. 게임 오브 스로운즈 팬으로서 사이버 지식을 시험하고 동시에 즐길 수 있는 수단이었습니다. 만약 여러분이 스로운즈의 팬이라면, 이 Windows/AD/SCCM 랩은 여러분을 위한 것입니다.\n\n처음에는 중첩 가상화 서버를 만들려고 했는데, 테라폼과 앤서블 지식이 거의 없어서 어려움을 겪었습니다. 하지만 저는 자동화로 나아가기로 결정했습니다. 일상적인 작업에서 시간을 절약하고, 올바르게 구현된다면 인간 에러를 줄일 수 있기 때문에 자동화가 많은 도움이 된다는 점에 동의합니다.\n\n`Game of Active Directory (GOAD)` 프로젝트는 현실적이고 실용적인 경험을 통해 사이버 보안 기술을 향상시키는 포괄적인 랩 환경입니다. Oracle Cloud Infrastructure (OCI)에서 호스팅되며, 다양한 OCI 서비스와 통합하여 현실 세계의 보안 시나리오를 모의할 수 있습니다.\n\nhttps://github.com/adibirzu/GOAD/blob/main/docs/install_with_oci.md\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n랩 환경으로서 VCN 보안 목록에서 엄격한 ACL을 구현하지는 않았어요. 그러나 모든 포트에서 192.168.0.0/16에서의 액세스는 허용했어요.\n\n1- 우리는 OCI의 Windows Server/Ubuntu 이미지를 사용할 거에요. 이 선택은 PAYG 요금제를 사용해. Windows Server 평가판을 사용할 계획이라면, 자체 이미지를 빌드하고 테라폼 스크립트를 사용자 정의 이미지 OCID로 설정해야 해요:\n\nOracle Cloud Infrastructure 이미지\n\n2- 테라폼 스크립트와 PowerShell 스크립트는 ad →GOAD →providers →OCI 하위에 추가됐어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Screenshot](/assets/img/2024-06-19-HowtorunGameofActiveDirectoryinOCIPart1_0.png)\n\n```js\n./goad.sh -t check -l GOAD -p oci -m local\n```\n\n3- 서로 다른 공급업체에서 사용자들이 알고 있는 동일한 워크플로를 제공하기 위해 goad.sh 스크립트에 제공자로 oci를 추가했습니다.\n\n![Screenshot](/assets/img/2024-06-19-HowtorunGameofActiveDirectoryinOCIPart1_1.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nOCI에서 우분투의 기본 사용자는 ubuntu이므로 goad.sh의 모든 참조는 ubuntu 사용자를 사용할 것입니다:\n\n![2024-06-19-HowtorunGameofActiveDirectoryinOCIPart1_2](/assets/img/2024-06-19-HowtorunGameofActiveDirectoryinOCIPart1_2.png)\n\n4. 스크립트 아래에, 저는 설치 후 우분투 서버의 선행 조건을 설치하기 위해 setup_oci.sh 스크립트를 만들었습니다.\n\n![2024-06-19-HowtorunGameofActiveDirectoryinOCIPart1_3](/assets/img/2024-06-19-HowtorunGameofActiveDirectoryinOCIPart1_3.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n5- 오라클 클라우드 인프라에서 랩을 프로비저닝하는 방법을 설명하는 docs/install_with_oci.md를 업데이트했습니다.\n\n6- ad →GOAD →providers →oci →ssh_keys →ubuntu-jumpox.pem에 개인 키를 배치하여 Ubuntu 인스턴스에 연결을 테스트했습니다.\n\n!!!! 이 키를 매우 주의해서 다루고, git에 공개하지 마세요.\n\n![이미지](/assets/img/2024-06-19-HowtorunGameofActiveDirectoryinOCIPart1_4.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n테이블 태그를 마크다운 형식으로 변경하였습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n9- ad → GOAD → providers → oci → terraform 폴더에 Terraform/PowerShell 파일을 만들어주세요:\n\n- windows_cloud_init.ps1\n\n```js\n# 변수\n$adminUsername = “ansible”\n$adminPassword = ConvertTo-SecureString “YourSecurePassword123!” -AsPlainText -Force\n\n# ansible 사용자 생성\nNew-LocalUser $adminUsername -Password $adminPassword -FullName $adminUsername -Description “Ansible admin user”\nAdd-LocalGroupMember -Group “Administrators” -Member $adminUsername\n\n# WinRM 활성화\nwinrm quickconfig -q\nwinrm set winrm/config/service/auth @{Basic=”true”}\nwinrm set winrm/config/service @{AllowUnencrypted=”true”}\nwinrm set winrm/config/service @{EnableCompatibilityHttpsListener=”true”}\nwinrm set winrm/config/service @{EnableCompatibilityHttpListener=”true”}\n$cert = New-SelfSignedCertificate -DnsName $(hostname) -CertStoreLocation Cert:\\LocalMachine\\My\nwinrm create winrm/config/Listener?Address=*+Transport=HTTPS @{Hostname=$(hostname); CertificateThumbprint=$($cert.Thumbprint)}\nSet-Service -Name winrm -StartupType Automatic\nStart-Service -Name winrm\n\n# WinRM을 위한 기본 인증 및 암호화 트래픽 활성화\nSet-Item -Path WSMan:\\localhost\\Service\\Auth\\Basic -Value $true\nSet-Item -Path WSMan:\\localhost\\Service\\AllowUnencrypted -Value $true\n\n# WinRM 방화벽 예외 설정\nNew-NetFirewallRule -Name \"WinRM-HTTP\" -DisplayName \"WinRM (HTTP-In)\" -Protocol TCP -LocalPort 5985 -Action Allow -Enabled True\nNew-NetFirewallRule -Name \"WinRM-HTTPS\" -DisplayName \"WinRM (HTTPS-In)\" -Protocol TCP -LocalPort 5986 -Action Allow -Enabled True\n\n# TLS 1.2 프로토콜 설정\n[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12\n\n# NuGet 공급자 설치 및 PowerShellGet 업데이트\nInstall-PackageProvider -Name NuGet -Force -Confirm:$false\nUpdate-Module -Name PowerShellGet -Force -AllowClobber -Confirm:$false\n```\n\n- profile.tf\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nprovider \"oci\" {\n  tenancy_ocid      = var.tenancy_ocid\n  user_ocid         = var.user_ocid\n  fingerprint       = var.fingerprint\n  private_key_path  = var.private_key_path\n  region            = var.region\n}\n```\n\nvariables.tf\n\n```js\nvariable \"tenancy_ocid\" {\n  description = \"The OCID of your tenancy.\"\n  type        = string\n}\n\nvariable \"user_ocid\" {\n  description = \"The OCID of the user calling the API.\"\n  type        = string\n}\n\nvariable \"fingerprint\" {\n  description = \"The fingerprint of the API key.\"\n  type        = string\n}\n\nvariable \"private_key_path\" {\n  description = \"The path to the private key.\"\n  type        = string\n  default     = \"/Users/abirzu/.ssh/newpemkey.pem\"\n}\n\nvariable \"region\" {\n  description = \"The region to use.\"\n  type        = string\n  default     = \"eu-frankfurt-1\"\n}\n\nvariable \"compartment_ocid\" {\n  description = \"The OCID of the compartment to use.\"\n  type        = string\n}\n\nvariable \"availability_domain\" {\n  description = \"The availability domain to use.\"\n  type        = string\n  default     = \"NoEK:EU-FRANKFURT-1-AD-1\"\n}\n\nvariable \"shape\" {\n  description = \"The shape of the instance to be created.\"\n  type        = string\n  default     = \"VM.Standard.E5.Flex\"\n}\n\nvariable \"ocpus\" {\n  description = \"The number of OCPUs to allocate.\"\n  type        = number\n  default     = 1\n}\n\nvariable \"memory_in_gbs\" {\n  description = \"The amount of memory in GBs.\"\n  type        = number\n  default     = 12\n}\n\nvariable \"ssh_authorized_keys\" {\n  description = \"The public key for SSH access to the instances.\"\n  type        = string\n}\n\nvariable \"image_ocid\" {\n  description = \"The OCID of the image to use.\"\n  type        = string\n}\n\nvariable \"windows2016_image_ocid\" {\n  description = \"The OCID of the Windows Server 2016 image.\"\n  type        = string\n}\n\nvariable \"windows2019_image_ocid\" {\n  description = \"The OCID of the Windows Server 2019 image.\"\n  type        = string\n}\n```\n\nnetwork.tf\n\n```js\n\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nresource “oci_core_vcn” “generated_oci_core_vcn” {\n cidr_block = “192.168.0.0/16”\n compartment_id = var.compartment_ocid\n display_name = “goad-virtual-network”\n dns_label = “goadvcn”\n}\nresource “oci_core_subnet” “public_subnet” {\n cidr_block = “192.168.57.0/24”\n compartment_id = var.compartment_ocid\n display_name = “public-subnet”\n dns_label = “publicsubnet”\n vcn_id = oci_core_vcn.generated_oci_core_vcn.id\n route_table_id = oci_core_route_table.public_route_table.id\n}\nresource “oci_core_subnet” “private_subnet” {\n cidr_block = “192.168.56.0/24”\n compartment_id = var.compartment_ocid\n display_name = “private-subnet”\n dns_label = “privatesubnet”\n vcn_id = oci_core_vcn.generated_oci_core_vcn.id\n route_table_id = oci_core_route_table.private_route_table.id\n prohibit_internet_ingress = true\n prohibit_public_ip_on_vnic = true\n security_list_ids = [oci_core_security_list.winrm_rdp_security_list.id]\n}\nresource “oci_core_internet_gateway” “generated_oci_core_internet_gateway” {\n compartment_id = var.compartment_ocid\n display_name = “Internet Gateway goad-virtual-network”\n enabled = true\n vcn_id = oci_core_vcn.generated_oci_core_vcn.id\n}\nresource “oci_core_nat_gateway” “generated_oci_core_nat_gateway” {\n compartment_id = var.compartment_ocid\n display_name = “NAT Gateway goad-virtual-network”\n vcn_id = oci_core_vcn.generated_oci_core_vcn.id\n}\nresource “oci_core_route_table” “public_route_table” {\n compartment_id = var.compartment_ocid\n vcn_id = oci_core_vcn.generated_oci_core_vcn.id\n display_name = “public-route-table”\nroute_rules {\n destination = “0.0.0.0/0”\n destination_type = “CIDR_BLOCK”\n network_entity_id = oci_core_internet_gateway.generated_oci_core_internet_gateway.id\n }\n}\nresource “oci_core_route_table” “private_route_table” {\n compartment_id = var.compartment_ocid\n vcn_id = oci_core_vcn.generated_oci_core_vcn.id\n display_name = “private-route-table”\nroute_rules {\n destination = “0.0.0.0/0”\n destination_type = “CIDR_BLOCK”\n network_entity_id = oci_core_nat_gateway.generated_oci_core_nat_gateway.id\n }\n}\n  options {\n    type                  = \"DomainNameServer\"\n    server_type           = \"CustomDnsServer\"\n    custom_dns_servers    = [\"192.168.56.10\",\"8.8.8.8\"]\n  }\n options {\n        type = \"SearchDomain\"\n        search_domain_names = [ \"sevenkingdoms.local\" ]\n    }\n}\nresource “oci_core_security_list” “winrm_rdp_security_list” {\n compartment_id = var.compartment_ocid\n vcn_id = oci_core_vcn.generated_oci_core_vcn.id\n display_name = “winrm_rdp_security_list”\negress_security_rules {\n protocol = “all”\n destination = “0.0.0.0/0”\n stateless = false\n }\ningress_security_rules {\n protocol = “all”\n source = “192.168.0.0/16”\n stateless = false\n }\n}\n```\n\n```js\nresource “oci_core_default_dhcp_options” “default_dhcp_options” {\n manage_default_resource_id = oci_core_vcn.generated_oci_core_vcn.default_dhcp_options_id\noptions {\n type = “DomainNameServer”\n server_type = “CustomDnsServer”\n custom_dns_servers = [“192.168.56.10”]\n search_domain_names = [“sevenkingdoms.local”]\n }\n```\n\nThe DHCP configuration part is essential, as if it’s not properly configured, it will result in the failure of the ansible jobs. If the terraform variable will not add the search domain, you need to do this manually:\n\nGo to the VCN → DHCP Options:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-06-19-HowtorunGameofActiveDirectoryinOCIPart1_7.png\" />\n\n화면 오른쪽 상단에 있는 3 점을 클릭한 후 편집을 선택하세요. 여기에서 외부 DNS 서버를 추가하고 사용자 정의 검색 도메인인 Seven Kingdoms를 추가할 수 있습니다.\n\n<img src=\"/assets/img/2024-06-19-HowtorunGameofActiveDirectoryinOCIPart1_8.png\" />\n\n이 부분에서 DNS 문제를 해결해야합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\noptions {\ntype = \"도메인 네임 서버\"\nserver_type = \"사용자 정의 DNS 서버\"\ncustom_dns_servers = [\"192.168.56.10\",\"8.8.8.8\"]\n}\noptions {\ntype = \"검색 도메인\"\nsearch_domain_names = [\"seven kingdoms.local\"]\n}\n```\n\njumpbox.tf\n\n```js\nresource \"oci_core_instance\" \"jumpbox\" {\n availability_domain = var.availability_domain\n compartment_id = var.compartment_ocid\n display_name = \"jumpbox\"\n shape = var.shape\nshape_config {\n baseline_ocpu_utilization = \"BASELINE_1_1\"\n memory_in_gbs = var.memory_in_gbs\n ocpus = var.ocpus\n }\nsource_details {\n source_id = var.image_ocid\n source_type = \"이미지\"\n }\n#이미지 OCID’S https://docs.oracle.com/en-us/iaas/images/image/bd616d0a-fae4-490e-bd31-a9406095b844/\n create_vnic_details {\n assign_ipv6ip = false\n assign_private_dns_record = true\n assign_public_ip = true\n subnet_id = oci_core_subnet.public_subnet.id\n }\nmetadata = {\n ssh_authorized_keys = var.ssh_authorized_keys\n }\nagent_config {\n is_management_disabled = false\n is_monitoring_disabled = false\nplugins_config {\n desired_state = \"사용 안 함\"\n name = \"취약점 스캐닝\"\n }\n plugins_config {\n desired_state = \"사용 안 함\"\n name = \"관리 에이전트\"\n }\n plugins_config {\n desired_state = \"사용함\"\n name = \"사용자 지정 로그 모니터링\"\n }\n plugins_config {\n desired_state = \"사용 안 함\"\n name = \"컴퓨팅 RDMA GPU 모니터링\"\n }\n plugins_config {\n desired_state = \"사용함\"\n name = \"컴퓨팅 인스턴스 모니터링\"\n }\n plugins_config {\n desired_state = \"사용 안 함\"\n name = \"컴퓨팅 HPC RDMA 자동 구성\"\n }\n plugins_config {\n desired_state = \"사용 안 함\"\n name = \"컴퓨팅 HPC RDMA 인증\"\n }\n plugins_config {\n desired_state = \"사용함\"\n name = \"클라우드 가드 워크로드 보호\"\n }\n plugins_config {\n desired_state = \"사용 안 함\"\n name = \"블록 볼륨 관리\"\n }\n plugins_config {\n desired_state = \"사용 안 함\"\n name = \"바스천\"\n }\n }\navailability_config {\n is_live_migration_preferred = true\n recovery_action = \"인스턴스 복원\"\n }\nplatform_config {\n is_symmetric_multi_threading_enabled = true\n type = \"AMD_VM\"\n }\ninstance_options {\n are_legacy_imds_endpoints_disabled = false\n }\n}\n```\n\nwindowsvm.tf\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n리소스 \"oci_core_instance\" \"windows_instance\" {\n for_each = {\n kingslanding = {\n name = \"kingslanding\"\n private_ip_address = \"192.168.56.10\"\n admin_username = \"ansible\"\n admin_password = \"8dCT-DJjgScp\"\n image_ocid = var.windows2019_image_ocid\n }\n winterfell = {\n name = \"winterfell\"\n private_ip_address = \"192.168.56.11\"\n admin_username = \"ansible\"\n admin_password = \"NgtI75cKV+Pu\"\n image_ocid = var.windows2019_image_ocid\n }\n castelblack = {\n name = \"castelblack\"\n private_ip_address = \"192.168.56.22\"\n admin_username = \"ansible\"\n admin_password = \"NgtI75cKV+Pu\"\n image_ocid = var.windows2019_image_ocid\n }\n meereen = {\n name = \"meereen\"\n private_ip_address = \"192.168.56.12\"\n admin_username = \"ansible\"\n admin_password = \"Ufe-bVXSx9rk\"\n image_ocid = var.windows2016_image_ocid\n }\n braavos = {\n name = \"braavos\"\n private_ip_address = \"192.168.56.23\"\n admin_username = \"ansible\"\n admin_password = \"978i2pF43UJ-\"\n image_ocid = var.windows2016_image_ocid\n }\n }\navailability_domain = var.availability_domain\n compartment_id = var.compartment_ocid\n display_name = each.value.name\n shape = \"VM.Standard.E5.Flex\"\nshape_config {\n ocpus = 2\n memory_in_gbs = 32\n }\nsource_details {\n source_id = each.value.image_ocid\n source_type = \"image\"\n }\ncreate_vnic_details {\n assign_ipv6ip = false\n assign_private_dns_record = true\n assign_public_ip = false\n subnet_id = oci_core_subnet.private_subnet.id\n hostname_label = each.value.name\n private_ip = each.value.private_ip_address\n }\nmetadata = {\n user_data = base64encode(file(\"${path.module}/windows_cloud_init.ps1\"))\n admin_password = each.value.admin_password\n }\n}\n```\n\noutputs.tf\n\n```js\noutput \"ubuntu_jumpbox_ip\" {\n value = oci_core_instance.jumpbox.public_ip\n}\noutput \"windows_instance_opc_passwords\" {\n value = { for k, v in oci_core_instance.windows_instance : k => v.metadata.admin_password }\n sensitive = true\n}\n```\n\n프로비저닝 중 발생한 일반적인 오류입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음과 같이 Markdown 형식에 맞게 표 태그를 변경하십시오.\n\n![이미지](/assets/img/2024-06-19-HowtorunGameofActiveDirectoryinOCIPart1_9.png)\n\n모든 TF가 생성된 후, GOAD git 저장소가 정상적으로 동기화된 경우 다음을 실행해야 합니다:\n\nabirzu@abirzu-mac GOAD % ./goad.sh -t destroy -l GOAD -p oci -m local\n\n모든 서버가 가동되고 작동 중인 것을 확인할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-06-19-HowtorunGameofActiveDirectoryinOCIPart1_10.png\" />\n\n축하합니다! 환경이 작동 중에 있습니다.\n\n# 서버\n\n이 랩은 실제로 다섯 개의 가상 머신으로 구성되어 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- kingslanding: DC01는 Windows Server 2019에서 실행 중입니다(기본으로 windefender가 활성화됨)\n- winterfell: DC02는 Windows Server 2019에서 실행 중입니다(기본으로 windefender가 활성화됨)\n- castelblack: SRV02는 Windows Server 2019에서 실행 중입니다(windefender가 기본적으로 비활성화됨)\n- meereen: DC03은 Windows Server 2016에서 실행 중입니다(기본으로 windefender가 활성화됨)\n- braavos: SRV03은 Windows Server 2016에서 실행 중입니다(기본으로 windefender가 활성화됨)\n\n도메인: north.sevenkingdoms.local\n\n- winterfell: DC01\n- castelblack: SRV02: MSSQL / IIS\n\n도메인: sevenkingdoms.local\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- kingslanding: DC02\n- castelrock: SRV01 (자원 부족으로 비활성화됨)\n\n# 도메인: essos.local\n\n- braavos: DC03\n- meeren: SRV03: MSSQL / ADCS\n\n인터넷에서 몇 가지 가이드를 따르거나 자신만의 방법을 찾아 시작할 수 있습니다!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nAD | Mayfly (mayfly277.github.io)\n\nSolving Game of Active Directory (GOAD) by Orange Cyberdefense Part-1 | by n00🔑 | Medium\n\n제1부에서는 OCI에서 GOAD 랩을 만드는 방법을 소개했고, 다음 부분에서는 다음에 초점을 맞출 것입니다:\n\nOCI 통합:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n1. OCI Management Agent:\n\n- 설명: 클라우드 작업을 자동화하고 모니터링합니다.\n- 통합: GOAD 환경 내 자원의 배포 및 관리를 간소화합니다.\n\n2. Sysmon 및 로깅 분석:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n• 설명: Sysmon은 시스템 활동을 기록하여 침입 탐지를 지원합니다.\n\n• 통합: Sysmon 이벤트를 수집하고 OCI Logging Analytics로 전송하여 고급 로그 분석 및 시각화를 지원합니다. 자세한 내용은 여기에서 확인하세요.\n\n3. Arkime 통합:\n\n• 설명: Arkime은 오픈 소스 패킷 캡처 및 검색 도구입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n• 통합: 효율적인 데이터 색인 및 검색을 위해 OCI OpenSearch를 활용합니다. 자세한 내용은 여기에서 확인할 수 있습니다.\n\n4. 클라우드 가드 인스턴스 보안:\n\n• 설명: 클라우드 가드는 포괄적인 클라우드 보안 관리를 제공합니다.\n\n• 통합: 로깅 분석을 활용하여 인스턴스 보안을 강화하며 실시간 위협 감지 및 대응이 가능합니다. 더 많은 정보는 여기에서 확인할 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-06-19-HowtorunGameofActiveDirectoryinOCIPart1_0.png"},"coverImage":"/assets/img/2024-06-19-HowtorunGameofActiveDirectoryinOCIPart1_0.png","tag":["Tech"],"readingTime":20}],"page":"39","totalPageCount":119,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true}