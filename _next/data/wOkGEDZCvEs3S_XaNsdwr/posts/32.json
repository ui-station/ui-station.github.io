{"pageProps":{"posts":[{"title":"Docker로 NestJS 애플리케이션 배포하는 방법","description":"","date":"2024-06-22 22:54","slug":"2024-06-22-DeployingNestJSApplicationswithDocker","content":"\n![이미지](/assets/img/2024-06-22-DeployingNestJSApplicationswithDocker_0.png)\n\n안녕하세요 여러분 👋, 여러분들이 잘 지내고 있기를 바라요! 오늘은 도커의 세계로 빠져보고, 응용 프로그램 개발과 배포에 미치는 변화를 이해해보려 합니다. 도커는 응용 프로그램과 종속성을 단일 컨테이너로 패키징하여 빌드, 배포 및 실행하는 방식을 혁신적으로 변화시켰습니다. 이는 다양한 환경 간에 일관성을 보장합니다. 이 블로그 포스트에서는 NestJS 응용 프로그램을 도커를 사용해 컨테이너화하고 원활하게 배포하는 과정을 이해해보겠습니다. 시작해봅시다!\n\n## NestJS 프로젝트 설정 🛠️:\n\n먼저 간단한 NestJS 애플리케이션을 만들어봅시다. NestJS CLI가 설치되어 있지 않다면 다음 명령어로 설치할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nnpm install -g @nestjs/cli\n// 새로운 nestjs 앱 생성하기\nnest new my-nest-app\n```\n\n## Dockerfile 작성:\n\nDockerfile을 만들기 전에 Docker 이미지와 컨테이너에 대한 단단한 기초적인 이해가 필요합니다. 다음과 같이 설명해보겠습니다:\n\nDocker 이미지: Docker 이미지는 코드, 런타임, 라이브러리 및 환경 변수를 포함하여 소프트웨어 조각을 실행하는 데 필요한 모든 것이 포함된 가벼운 실행 가능한 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n도커 컨테이너: 도커 컨테이너는 코드와 모든 종속성을 포장하여 응용 프로그램이 다양한 컴퓨팅 환경에서 빠르고 신뢰성 있게 실행될 수 있도록 하는 경량, 휴대용, 자체 완비형 환경입니다.\n\n이 컨테이너를 어디로든 이동하고 어떤 컴퓨터에서든 실행할 수 있으므로 소프트웨어 작업 여부를 걱정할 필요가 없습니다. 필요한 모든 것이 이미 안에 들어 있기 때문이죠.\n\n도커 파일: Dockerfile은 응용 프로그램을 위한 도커 이미지를 구축하는 방법에 대한 일련의 명령을 포함하는 스크립트입니다. 프로젝트의 루트에 Dockerfile이라는 파일을 만들고 다음 내용을 추가하세요.\n\n```js\n# 공식 Node.js 16 이미지를 기본 이미지로 사용합니다\nFROM node:16-alpine\n\n# 작업 디렉토리 설정\nWORKDIR /app\n\n# package.json 및 package-lock.json 파일 복사\nCOPY package*.json ./\n\n# 종속성 설치\nRUN npm install\n\n# 나머지 응용 프로그램 코드 복사\nCOPY . .\n\n# NestJS 응용 프로그램 빌드\nRUN npm run build\n\n# 응용 프로그램 포트 노출\nEXPOSE 3000\n\n# 응용 프로그램 시작\nCMD [\"node\", \"dist/main\"]\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## .dockerignore 파일 만들기:\n\n.dockerignore 파일은 .gitignore 파일과 비슷하게 작동합니다. 이미지를 빌드할 때 Docker에게 무시해야 할 파일과 디렉토리를 알려줍니다. 프로젝트의 루트에 .dockerignore 파일을 만들고 다음 내용을 추가해주세요.\n\n```js\nnode_modules;\ndist.git.gitignore;\nDockerfile;\n```\n\n## Docker 이미지 빌드 및 실행하기:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 도커파일과 .dockerignore 파일이 있으니 도커 이미지를 빌드하고 실행해 봅시다.\n\n```js\n//도커에서 이미지를 빌드하는 명령어\ndocker build -t <이미지-이름>:태그\n\n//예시: my-nest-app 이미지를 빌드하는 방법\ndocker build -t my-nest-app:latest .\n```\n\n태그(Tag): 태그는 Docker 이미지의 특정 버전을 식별하는 라벨입니다. 동일한 이미지의 여러 버전을 관리하고 구분하는 데 사용됩니다.\n\n## 도커에서 이미지가 제대로 빌드되었는지 확인하는 방법:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n//도커 이미지 목록을 제공합니다.\n도커 이미지 목록 확인\n\nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\nmy-nest-app         latest              1d4f1e3f5b7e        2 hours ago         540MB\nanother-app         v1.0                3e23f1c3e6a4        3 days ago          350MB\n```\n\n## 도커 컨테이너 실행하기 :\n\n아래는 도커 컨테이너를 실행하는 명령어입니다. host_port는 사용하려는 기기의 포트를 나타내고, container_port는 컨테이너 내부에서 애플리케이션이 수신 대기하는 포트를 나타냅니다.\n\n```js\ndocker run -p [host_port]:[container_port] [image_name]:[tag]\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 도커에 있는 컨테이너 목록 :\n\n```js\n// 모든 실행 중인 컨테이너 목록 표시\ndocker ps\n\nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES\nf3b1c25a3ac8        my-nest-app:latest  \"docker-entrypoint.s…\"   2 hours ago         Up 2 hours          0.0.0.0:3000->3000/tcp   my-nest-app\na4d5f2b5c7a3        another-app:v1.0    \"python app.py\"          3 days ago          Up 3 days           0.0.0.0:5000->5000/tcp   another-app\n```\n\n이제 http://localhost:3000 에서 접속할 수 있어요 🚀.\n\n# 도커 컴포즈 :\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n도커 컴포즈는 여러 개의 컨테이너로 구성되는 도커 응용 프로그램을 정의하고 실행하는 도구입니다. NestJS 애플리케이션을 여러 개 실행하는 데 사용할 수 있습니다. 예를 들어, 마이크로서비스 또는 다른 서비스를 함께 실행하는 것이 가능합니다.\n\n## NestJS 애플리케이션 설정:\n\napp1 및 app2라는 두 개의 애플리케이션을 생성할 것이며, NestJS 프로젝트를 만드는 방법은 동일합니다.\n\n```js\n// 첫 번째 애플리케이션 생성\nnest new app1\n\n// 두 번째 애플리케이션 생성\nnest new app2\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 각 응용 프로그램을 위한 도커 파일 작성:\n\n각 애플리케이션은 이미지를 빌드하기 위한 도커 파일이 필요합니다. 아래는 두 개의 NestJS 응용 프로그램에 동일한 도커 파일이 될 것입니다.\n\n```js\n# 공식 Node.js 이미지 사용\nFROM node:16-alpine\n\n# 작업 디렉토리 생성 및 변경\nWORKDIR /app\n\n# 응용 프로그램 종속성 파일을 이미지에 복사\nCOPY package*.json ./\n\n# 종속성 설치\nRUN npm install\n\n# 로컬 코드를 이미지에 복사\nCOPY . .\n\n# 응용 프로그램 빌드\nRUN npm run build\n\n# 응용 프로그램 시작\nCMD [ \"node\", \"dist/main.js\" ]\n```\n\n## 도커 컴포즈 파일 작성:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n루트 디렉토리에 docker-compose.yml 파일을 만들어서 두 애플리케이션을 위한 서비스를 정의해야 해요.\n\n```js\n//도커  compose 파일의 버전 컨트롤러를 지정.\nversion: '3.8'\nservices:\n  app1:\n    build:\n      context: ./app1\n      dockerfile: Dockerfile\n    //컨테이너 내부의 포트 3000을 호스트 머신의 포트 3001로 매핑합니다.\n    ports:\n      - \"3001:3000\"\n    volumes:\n      - ./app1:/app\n    command: [\"npm\", \"run\", \"start:prod\"]\n\n  app2:\n    build:\n      context: ./app2\n      dockerfile: Dockerfile\n    //컨테이너 내부의 포트 3000을 호스트 머신의 포트 3002로 매핑합니다.\n    ports:\n      - \"3002:3000\"\n    volumes:\n      - ./app2:/app\n    command: [\"npm\", \"run\", \"start:prod\"]\n```\n\n## 파일 디렉토리 구조 :\n\n```js\nroot/\n├── app1/\n│   ├── Dockerfile\n│   ├── package.json\n│   ├── ...\n├── app2/\n│   ├── Dockerfile\n│   ├── package.json\n│   ├── ...\n└── docker-compose.yml\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## Docker Compose를 사용하여 응용 프로그램 빌드 및 실행하기:\n\ndocker-compose build 명령어는 docker-compose.yml에 지정된 도커 이미지를 빌드하는 데 사용됩니다.\n\ndocker-compose up 명령어는 서비스를 실행하는 데 사용됩니다.\n\n## 컨테이너 중지 또는 제거하기:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 명령어는 docker-compose up 에 의해 생성된 네트워크를 포함하여 컨테이너 실행을 중지하고 그것들을 제거할 것입니다.\n\n```js\ndocker-compose down\n\n// 컨테이너를 중지하지만 제거하지 않고 싶은 경우\ndocker-compose stop\n```\n\n## 결론 :\n\n이 블로그 포스트에서는 Docker를 사용하여 NestJS 애플리케이션을 컨테이너화하는 기본 사항을 다뤘습니다. Dockerfile을 작성하고 .dockerignore 파일을 만들고 Docker Compose를 사용하여 컨테이너 실행을 간소화했습니다. Docker를 사용하면 응용 프로그램이 다른 환경에서 일관되게 실행되도록 보장할 수 있어 배포 및 확장을 쉽게 할 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-06-22-DeployingNestJSApplicationswithDocker_0.png"},"coverImage":"/assets/img/2024-06-22-DeployingNestJSApplicationswithDocker_0.png","tag":["Tech"],"readingTime":8},{"title":"백엔드 면접 질문  믹스인이란 무엇인가요","description":"","date":"2024-06-22 22:53","slug":"2024-06-22-BackendInterviewQuestionWhatIsAMixin","content":"\nInterviewer가 데이터 구조 및 알고리즘 질문에 대한 면접을 마치면 임의로 짧은 기술 질문을 할 수 있습니다.\n\n예를 들어, 믹스인(Mixin)이 무엇이며 왜 사용하는지 설명해보세요.\n\n그리고 그 외에도 많은 다른 질문들이 있습니다. 이 질문들의 상당수에 대해 괜찮은 답변을 준비하는 것이 중요합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# Mixin이란 무엇인가요?\n\n- 기본적으로, Mixin은 간단한 클래스입니다.\n- 사용자 정의 클래스에 기능을 제공하는 클래스입니다.\n\n```js\nclass BarkMixin:\n    def bark(self):\n        print('woof')\n\nclass Animal:\n    ...\n\nclass Dog(Animal, BarkMixin):\n    ...\n```\n\n^ 여기서 BarkMixin은 해당 클래스에서 상속 받은 클래스에 'bark' 메소드를 제공합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nBarkMixin이 Dog의 부모 클래스로 사용되는 것이 아니라, 단순히 Dog에게 짖는 메서드를 제공하도록 설계되었습니다.\n\n# 믹스인은 섞어서 사용할 수 있습니다\n\n```js\nclass BarkMixin:\n    def bark(self):\n        print('woof')\n\nclass MeowMixin:\n    def meow(self):\n        print('meow')\n\nclass SqueakMixin:\n    def squeak(self):\n        print('squeak')\n```\n\n^ 각 믹스인에는 일반적으로 소수의 함수가 포함되어 있습니다. 이렇게 하면 조합하여 더 편리하게 사용할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```javascript\nclass Monster1(BarkMixin, MeowMixin):\n    pass\n\nm = Monster1()\n\nm.bark()    # woo\nm.meow()    # 야옹\n```\n\n가령 Monster1이 짖고 야옹할 수 있다고 합시다. 내부에 짖고 야옹하는 메서드를 정의하는 대신, Monster1을 BarkMixin과 MeowMixin에서 상속받도록 만들면 됩니다.\n\n```javascript\nclass Monster2(BarkMixin, MeowMixin, SqueakMixin):\n    pass\n\nm = Monster2()\n\nm.bark()    # woo\nm.meow()    # 야옹\nm.squeak()  # squeak\n```\n\n그리고 Monster2가 짖고 야옹하며 삑삑 소리를 낼 수 있게 하려면 BarkMixin, MeowMixin, SqueakMixin에서 상속받으면 됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 그런데, 클래스 내에서 이들을 정의하는 것이 어떨까요???\n\n```js\nclass 짖기포함:\n    def 짖다(self):\n        print('왈왈')\n\nclass 고양이울음포함:\n    def 고양이울음(self):\n        print('야옹')\n\nclass 삑삑포함:\n    def 삑삑(self):\n        print('삐익')\n```\n\n다음과 같은 몬스터를 만들고 싶다고 가정해봅시다:\n\n- 몬스터1은 짖을 수 있고 야옹거릴 수 있습니다.\n- 몬스터2는 짖고 야옹하며 삑삑을 할 수 있습니다.\n- 몬스터3은 야옹하며 삑삑을 할 수 있습니다.\n- 몬스터4는 삑삑만 할 수 있습니다.\n- 몬스터5는 짖거나 삑삑을 할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n천천히 하나씩 mixins을 사용해보죠.\n\n```js\nclass Monster1:\n    def bark(self):\n        print('woof')\n\n    def meow(self):\n        print('meow')\n\nclass Monster2:\n    def bark(self):\n        print('woof')\n\n    def meow(self):\n        print('meow')\n\n    def squeak(self):\n        print('squeak')\n\nclass Monster3:\n    def meow(self):\n        print('meow')\n\n    def squeak(self):\n        print('squeak')\n\nclass Monster4:\n    def squeak(self):\n        print('squeak')\n\nclass Monster5:\n    def bark(self):\n        print('woof')\n\n    def squeak(self):\n        print('squeak')\n```\n\n우와, 말하게 해서 쓰기도 귀찮고, 코드가 중복되어서 짜증났죠! 이제 mixins을 사용해봅시다:\n\n```js\nclass BarkMixin:\n    def bark(self):\n        print('woof')\n\nclass MeowMixin:\n    def meow(self):\n        print('meow')\n\nclass SqueakMixin:\n    def squeak(self):\n        print('squeak')\n\nclass Monster1(BarkMixin, MeowMixin): pass\n\nclass Monster2(BarkMixin, MeowMixin, SqueakMixin): pass\n\nclass Monster3(MeowMixin, SqueakMixin): pass\n\nclass Monster4(SqueakMixin): pass\n\nclass Monster5(BarkMixin, SqueakMixin): pass\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n훨씬 깔끔하고, 코드 반복이 훨씬 적으며, 읽기도 훨씬 쉬워요\n\n# 결론\n\n만약 당신이 다음과 같은 기능이 있다면:\n\n- 작고 모듈식이고\n- 상당 수의 클래스들이 필요로 하는\n- 혼합 및 매칭이 필요한\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n테이블 태그를 Markdown 형식으로 변경해 보시는 것을 권장해 드립니다. 이 설명이 명확하고 이해하기 쉬웠으면 좋겠네요.\n\n# 만약 제가 창작자로서 지원받길 원하신다면\n\n- 이 이야기에 대해 50번 박수를 보내주세요.\n- 여러분의 생각을 말씀해 주는 댓글을 남겨주세요.\n- 이야기에서 가장 좋아하는 부분을 강조해 주세요.\n\n감사합니다! 이런 작은 조치들이 큰 도움이 되고 정말 감사히 받아들입니다!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nYouTube: https://www.youtube.com/@zlliu246\n\nLinkedIn: https://www.linkedin.com/in/zlliu/\n\nMy Ebooks: https://zlliu.co/ebooks\n","ogImage":{"url":"/assets/img/2024-06-22-BackendInterviewQuestionWhatIsAMixin_0.png"},"coverImage":"/assets/img/2024-06-22-BackendInterviewQuestionWhatIsAMixin_0.png","tag":["Tech"],"readingTime":6},{"title":"새 소프트웨어를 커플 관계에 통합하는 방법","description":"","date":"2024-06-22 22:50","slug":"2024-06-22-IntegratingNewSoftwareintoYourRelationship","content":"\n<img src=\"/assets/img/2024-06-22-IntegratingNewSoftwareintoYourRelationship_0.png\" />\n\n# 상황은 뭐죠?\n\n기술 분야에서 가끔은 일자리를 얻습니다. 대부분의 경우는 일자리를 만듭니다.\n\n저는 스무 살 때부터 기술 분야에서 일해 왔어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n내 나이는 사십에요. 이래서 나이를 묻지 말라고 하잖아요. 제 일을 새로 만들어내며 이제 이십 몇 년 동안 다이얼업에서 출발해 어색하게 명명된 Napster로부터 DVD를 불법으로 복제해왔던 시절을 거쳐 이젠 탐욕스러운 스트리밍 서비스와 인공지능 도덕적 공포까지 만날 수 있게 되었어요.\n\n테크 분야에서 더 성공적인 버전이 될 수도 있었다. 만약 테크가 농구였다면, 나는 Jesse Bodine Dark가 되어버릴 지도 몰라요 — 덜 알려진 시골 출신 개척자로서 상대적으로 지나간 시대를 대변하고 있는 사람. 나는 나 자신을 위해 돈을 벌었지만, 다른 이들을 위해 훨씬 더 많은 돈을 벌었어요. 아직 여기 남아 있지만, 명확한 관련성이 부족해 보여요. 제가 우위와 영향력 경쟁에 가치를 보지 않게 됐어요. 대신 자원봉사와 가족에 집중하는 것을 선호해요.\n\n테크 분야에서 일할 의도는 전혀 없었어요. 제가 사회과학 학생이었거든요. 기술 사용자들과 서술적 또는 탐색적 분석에 관심이 있었어요. 예측적이거나 기계적인 것은 아니었어요. 역사학, 혹은 역사의 역사를 전공해 졸업했어요 — 누가 역사를 쓰고 기억하며 이를 어떻게 하는지를 다루는 과목이에요. 미디어 연구 전공도 했어요, 그래서 영화를 많이 보고 종종 와인을 마시며 그에 대해 이야기를 나눴어요.\n\n졸업 후에는 제 학문적 기술을 필요로 하는 일이 드물었어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n대학에서는 어떤 개인이 특정 콘텐츠를 재구성하거나 소화하여 잘못된 주장을 듣는 대상 청중에게 의미있게 들리도록 하는 방법을 분석하는 법을 배웠어요. ChatGPT 이전의 prompt engineering에서. 그것은 유망한 것처럼 들리지만, 법대가 없으면 별 도움이 되지 않아요. 저는 법대 학비를 마련할 수 없었어요.\n\n게다가, LSAT와 법대 입학 시험이 정말 어려워요.\n\n학사 학위를 가졌지만, 수학 실력은 매우 기본적이었고 계산기에 의존했어요. 나의 과학 지식은 진화론이 일루미나티 딥 스테이트에서 파생된 논란스러운 아이디어로부터 시작되는 지역 공립 학교에서 얻은 것이었어요. 한편으로는 NASA에 재무를 쏟아붇는 별자리 애호가들은 더 신앙적인 추구에게 맡겨야 할 돈들을 도용한 것으로 설명되었어요. 이것은 내 고급 생물학 선생님의 설명이었는데, 그 분의 진짜 직업은 지역 배프티스트 교회의 주일 학교 교수였어요.\n\n졸업 이후, 돈이 필요했지만, 나의 이력서에는 돈을 벌 수 있는 능력이 거의 없는 것 같았어요. 나의 자산들은 내부적으로 달성된 것보다 외부에서 인정받은 것들이었어요. 예를 들어, 그 당시 대중 문화에 적합한 표현형을 가지고 있었어요. 나는 흰 피부이고 마른 편이었으며 그리 못 생긴 것은 아니었어요. 영어만을 구사했는데, 그 언어는 기술에 대한 미국 달러와 같았어요. 또한 사회에 적응하기 쉽고 나에게 유리한 경우에는 굉장히 조작적이었어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n1980년대에 보수적인 가부장적 환경에서 성장했어요. 권위에 대한 희망은 없었지만, '어려운 사람'으로 레이블링되지 않으려고 희망적인 초보자처럼 행동하는 법을 알고 있었어요. 지도자들이 이미 내린 결정에 대해 좋게 느끼도록 해 그들이 나를 방치하도록 만들었어요. 남을 인정하면서 개인적으로 그들의 비전에 투자하지 않아 월세를 낼 수 있었어요.\n\n미국 메이슨-딕슨 라인 아래에서 대부분 여성들과 많은 사회적 경제적으로 어려움을 겪고 있는 야심 있는 남성들은 영감과 조작 사이에 깊은 함정을 넘나들 수 있어야 해요.\n\n여성이 힘을 표현하는 것은 꼬리치는 예술일 수 있어요, 말 그대로 그렇죠. 최선을 다하더라도, 여성 리더십을 엄격하게 확장하려는 시도는 지역적인 관행과 정치에 엉키곤 해요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n어떤 이들은 왜 이러한 성 차별적 개선이 윤리적으로 필수적인지에 대해 의문을 제기할 수 있습니다. 그들은 성 평등의 장기적 이익을 어필합니다. 제 경험 상, 이 직접적인 접근은 종종 판단적이고 공격적으로 인식되며, 그 지지자들은 제거 대상이 됩니다.\n\n본질적인 패러다임 변화를 위해 필수적이라고 주장되는 것에도 불구하고, 여성을 대표하여 적대적으로 논의하는 것은 보편적인 반대에 즉각적으로 기반을 다지고, '시위대'에게 '어려운' 레이블을 부여하여 기회를 차단하며, 관련 조치의 변경 관리가 도착과 동시에 실패할 수 있습니다.\n\n저는 더 이상 그 즉흥적인 태도를 취해 일자리를 얻으려는 타입이었습니다. 경험상 기능보다 형식을 채택하는 것이 더 확실하게 먹여줬어요.\n\n그리고 여자도 밥 먹어야죠.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n어릴 때, 저는 여러 가지 수단을 통해 다른 사람들을 동기부여하는 법을 배웠어요. 하지만 이제 미투 이후로는 남성적인 매력과 나쁜 포스트모던 분위기를 시사하는 방법으로 여겨질 수 있겠죠. 그것을 상사에게 사양하는 방법으로 생각했어요. 대중 문화에서는 90년대 자연선택, 제3차 페미니즘, 일명 걸 파워로 취급되었어요.\n\n걸 파워. 이제는 공통 주제로.\n\n이제 우리는 걸 파워가 의심스러운 배경음을 갖춘 통치 프레임워크로 소개되었다는 사실을 다양한 수준의 불편함을 느끼며 인정하고 있어요. 미국에서는 이 배경음이 상업적 자본주의, 아버지주의, 백인 우월주의, 그리고 기독교 신자적 자유주의와 밀접하게 얽힌 것으로 인식되었어요. 올리가르키적 목표는 불평등을 줄이는 것이 아니라, 권력을 늘리되 책임을 묻지 않도록 하는 것을 목표로 했는데, 킴 카다시안이나 스티브 애플... 아니, 잡스처럼 말이죠.\n\n내가 말하고 싶은 건 걸 파워가 이 모든 문제의 책임이 있는 것은 아니라는 것이에요. 당시에는 취소 문화가 아래층을 겨냥했지 상위층을 겨냥하지 않았어요. 세상은 영향력과 권력을 문제 해결로 연결했고, 어디에서나 한 사람의 결정을 위한 권력을 대부분 독점했던 사람들은 책임을 피하고 있었어요. 90년대에 상사로서 장점은 부하직원들이 의심없이 당신의 지시를 따르고 뭔가 잘못될 때마다 비난을 받는 것이었어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n당신은, 진정한 리더십을 아실 거예요. 미국이 위대했던 시절.\n\n# 어떤 행동을 보이나요?\n\n위의 면책 조항을 발표한 후에, 나는 즉각적인 대학 졸업 후 기술 산업에 뛰어들었고, 결국 내 ... '경력'으로 이어졌다.\n\n내 그다지 독특하지 않은 경험은 다른 사람들이 내 의견을 자신의 생각처럼 듣기에 충분히 중요한 느낌을 받게 했다. 일이 되는 것에 대한 신용을 얻었는데, 일이 잘 풀리면 그들이 받았고, 일이 안 풀리면 '아직 배우고 있는' 바보 공주가 되었다. 그들에게는 피할 수 없는 잘못이 있었지만, 남성 동료가 여자를 그들의 클럽에 들이는 것을 증명하는 역할도 했다. 나는 클럽에 대한 어떤 애착도 느끼지 않았기 때문에 특별히 신경 쓰지 않았다; 급여를 받으러 왔고, 남에게 이용당하는 걸 익숙해했다. 그것은 개인적인 문제가 아니었고, 경제 체계였으며, 대부분의 사람보다 잘 빠져나갔다고 생각했다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n내 존재로 인해 주인들이 어색한 행동에 대해 부인할 수 있는 가능성이 생겼어. 일자리 안정과 상당한 봉급을 얻었지.\n\n응, 성희롱은 있었지만, 상대적으로 가볍게 넘겼어. 어느 남자가 한 번 내게 내가 큰 가슴을 가졌기 때문에 나를 고용했다고 말했어 (그 사람도 그랬어...). 한 명의 늙은 괴물은 만약 그의 풀타임 애인이 되기로 동의한다면 나에게 멋진 아파트를 제공했어 (하지 않았어. 스무 살에 아파트에서 시간을 보내는 사람이 누구야? 루저들, 그래. 아파트는 나가서 춤추고 술마실 때 당신의 물건을 넣는 상자인 거야. 오직 괴물들만이 아파트에 살아.) 내가 함께 일한 대부분의 남자들은 완전히 예의 바르고, 조금 자기 중심적이었어. 성차별은 주로 구조적이었고, 개인적이 아니었어. 이 사무실에 도착하기 훨씬 전부터 시작됐어.\n\n이제 내가 돈을 벌면서 그 위에 이야기한 술 마시고 춤 추는 일에 돌아가봐야겠어.\n\n내 직업은 뛰어난 '소프트웨어 계몽이라는 데이터 과학자' 사이에서 중재하는, 위대한 페미닌한 중재자로서, 중요한 돈을 벌어들이는 기업에게 그들이 모든 문제를 해결해 주는 소프트웨어 솔루션을 판매하는 일이었어. 클럽에 있는 계몽들이 판매를 하고, 나는 결과물을 다뤘어.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n과거 기업용 소프트웨어를 구매하는 것은 쉬웠으며 부유한 사람들의 놀이터였어요. 잘 태어난 나이가 든 백인 신사들이 서로 또는 자신의 젊은 시절을 이상화한 다이나믹 아바타와 네트워킹을 했어요. 헌터족과 좋은 성과를 거둔 랙스 선수들이 함께 모여 서로 자금 지원하고 싶어했어요.\n\n모두가 서로의 친교를 즐겼고 회사 자금에 서명하여 서로의 클럽하우스에 투자했어요. 그런 다음, 남자들은 더 많은 네트워킹과 술 마시러 다른 클럽하우스로 떠났어요.\n\n이것은 아버지가 대규모 파티를 지불하는 남자들 버전이었어요. 아는 모든 사람을 초대하고 오픈 바를 보장했어요.\n\n그래서 서명은 공식적이었어요 — 소프트웨어를 구매하는 것은 쉽고 즐거웠으며, 개별적으로 비싸지 않았어요. 결국, 아버지가 지불했으니까요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n하지만 제 업무는 실행하는 것이었어요. 그리고 기업 내에서 대규모 소프트웨어 시스템을 효과적으로 구현하는 것은 구매 후 '쉬운 일' 이라고 할 수 없죠. 바로 변경 관리라 불리는 끊임없는 기술 적응에 관한 갈등이 계속됩니다.\n\n이 업무는 최상의 결과를 얻기 위해 일선에서 일하는 여성 분들에게 양보하는 편이 좋습니다.\n\n제가 소프트웨어와 함께 제한된 기간 판매된 액세서리로서 파티 후 날 아침에 도착했어요. 아빠는 파티 뒤 청소를 넘어서 파티를 장식하는 것이 전악적인 장기 계획의 일부처럼 보이도록 하는 것이 제 역할이었죠.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n내 임무는 무엇이 팔렸는지, 왜 팔렸는지, 어떻게 인식된 가치를 추출할 수 있는지 알아내는 것이었습니다. 대규모 엔터프라이즈 소프트웨어 구독이 환상적이고 비용 절감 및 수익 창출 아이디어로 보이도록 해야 했습니다.\n\n내 상사는 망치를 팔았고, 내 임무는 노동자들이 이 새로운 망치를 사용하여 고객이 사준 집을 짓는 데 이용하도록 보장하는 것이었습니다. 그들은 비전을 팔았고, 나는 그것을 현실로 만드는 방법을 찾았습니다.\n\n그런 다음 Go를 넘어 나의 월급을 받을 수 있었습니다. 그 후 내 물건을 보관하고 음주와 댄스 전부를 지불할 수 있었습니다.\n\n대규모 엔터프라이즈 소프트웨어 구매는 항상 좋은 아이디어였을까요? 문제를 해결했나요, 해결책을 팔았나요? 돈을 돌아다니도록 만들어진 시시한 시스템을 강화하고 있는 걸까요? 다윈은 그의 이론으로 인해 인간의 존엄성을 파괴했나요? NASA는 하나님의 월급을 미국에 낭비하는 악마인가요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n어린 시절, 친척 중 한 분이 두 가지 종류의 거짓말이 있다고 말했어요: 자신이 거짓말을 한다고 알고 하는 거짓말과 모르고 하는 거짓말. 사회가 둘 중 하나를 다른 것으로 오해할 때, 당신은 성인이 되었다고 할 수 있어요.\n\n성인이기 때문에 대규모 기업용 소프트웨어 구매 후, 내 칭찬받은 엔지니어들이 나의 약속을 봉쇄하기 위해 나를 파견했어요. 문서 작업에 영혼의 위기를 깨닫는 것은 내 임무가 아니었어요. 나는 나의 고교 생물학 교사가 아니었기 때문이죠. 하늘의 통제력에는 믿음이 없었어요. 저는 NASA에 더 믿음이 있었어요.\n\n그래서, 고객들의 사무실을 방문해서 직원들과 이야기를 나누었고, 개인과 팀의 역동성을 연구했어요. 소프트웨어를 일상적인 업무에 통합하는 방법을 연구했고, 구매 전에 존재를 알지 못했을 직원들에게 어떻게 유용할 수 있는지를 강조했어요.\n\n제 아이들 시절에 연마된 기술과 기술 분야에서의 경험을 통해, 새로운 소프트웨어를 사용하도록 직원들을 설득했어요. 종종 그들과 함께 앉아 소프트웨어의 기능이 전문적인 업무에 어떻게 가치를 더할 수 있는지에 대해 토론했어요. 또한 기업 내 병목 현상이 발생하는 지점을 파악했는데, 이러한 문제들은 새로운 소프트웨어로 해결되기 힘들었어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n대부분의 사람들이 직장에 나타나서 주어진 조건 내에서 업무를 처리한다는 것을 깨달았어요. 이러한 조건들은 일반적으로 처음에 약속된 조건이 아니며 외부, 거의 상상 속의 주요 캐릭터들에 의해 늘 변할 수 있어요 - 그 주요 캐릭터들이 바로 저가 종종 대변하는 사람들이에요.\n\n하지만 사람들은 발명가예요 - 대부분의 직원들은 해결책을 찾아냅니다. 그들은 본능적으로 행복한 건 아니지만, 특히 '해결책을 찾아내는 것'이 각자의 조건을 제어할 수 있는 한도를 한 번 더 상기시켜 주는 경우는 더욱 그렇죠. 하지만 사람들은 강인하고 똑똑하답니다, 싫다고 할 때도 그렇죠.\n\n그럼에도 불구하고 - 가끔, 저는 패배한 참가자에게 자음을 사도록 설득하는 반나 화이트 같았었어요.\n\n많은 자음을 사였지요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 영향은 무엇인가요?\n\n내 작업은 관계가 어떻게 작용하는지에 대해 많은 것을 가르쳤고, 판매만이 아니라 다양한 측면에서 관계를 이해하는 데 도움이 되었습니다. 소프트웨어와의 관계는 인간 간의 관계와 유사합니다. 한 번 사람이 특정 기술이나 사람을 자신의 삶에 통합하면, 그들을 변화시키기 어렵습니다.\n\n일상 — 매일 반복되는 일상 생활 — 가 그 기술이나 그 사람 주변에서 자랐습니다. 새로운 것으로 전환하거나 이전 것을 해제하는 것은 매우 불편합니다. 심지어 이전 것이 아프게 구식이거나 현재 해로울 때라도요.\n\n그리고 종종, 이전 것은 쓸모없는 것은 아니거나 적어도 개인은 그것을 사용하는 방법을 찾았습니다. 그 이전 사람이나 기술은 사용자의 하루에 목적과 구조를 제공합니다. 그것은 의미를 가지고, 사용자에게 이제 묵직한 문화나 영적 첨부물에 기여하는 것으로 변모했습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n개인적인 예를 하나 들어볼게요: 간단한 수학 문제를 풀 때 여전히 구글 '계산기'를 사용해요. ChatGPT나 Perplexity에 물어보는 게 아니라 구글에서 찾아요—제 나이는 몇 살일까요?\n\n대답하지 마세요.\n\n제가 말하려는 건, 사람이나 소프트웨어를 성공적으로 일상에 통합하는 데는 맥락과 통제가 크게 영향을 미친다는 거예요. 예를 들어, 비슷한 나이와 상황을 가진 두 사람이 만나면, 종종 함께 비유적인 소프트웨어를 만들기 시작해요.\n\n그들이 협력하여 만든 소프트웨어를 분리하는 건 감정적으로나 재정적으로 아플 수 있어요. 얼마나 아픈가요? 그건 상황에 따라 다르죠. 부부의 인코딩된 연결을 검토할 때, 그들이 어떻게 시간이 지남에 따라 상호 작용했는지 파악해야 해요. 그들의 상호 작용이 어떻게 각 부부 구성원의 모듈성과 일치하는지 검토해야 해요. 지속적인 관계에서는 구성원이 서서히 예상하기 시작하는 역할과 책임을 맡게 되는데요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n관계를 유지하는 데 가독성과 신뢰성이 중요합니다. 즉각적인 효율성 비용이 발생할지라도요. ‘남편’이 ‘아내’가 가사일을 하면서 지침을 느끼는지 알고 계시나요? ‘아내’는 ‘남편’이 덜 필요하다고 느끼고 있음을 알고 계시나요? 함께 코드를 합치면서 시작한 포크 저장소들이 있지만, 더 많은 인터페이스를 바라는 ‘남편’의 소망을 아시나요?\n\n어린이들의 포킹은 요구가 많을 수 있습니다.\n\n더 많은 이득을 얻을 수 있지만, 암시된 전문가적 조건을 재협상하는 것은 가정적 환경을 재협상하는 것만큼 어려울 수 있습니다. 소프트웨어는 신경 쓰지 않을 수 있지만 사용자는 신경 씁니다.\n\n해제할 수 없을 수도 있습니다, 특히 그 포크하는 아이들이 있을 때. 확장된 소프트웨어는 소프트웨어를 사용 방식과 일치시키는 로컬 조건, 구체적 조건, 실천에 적응해야 합니다. 사람들은 일의 요구사항에 맞추어 가장 엄격한 소프트웨어 시스템을 자신만의 아이디어에 따라 맞춤화할 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n물론, 상호 작용하는 모든 사람이 더 명확하게 볼 수 있도록 자신이 발생시킨 안구 피로 덕분에 레거시 코드를 인정하지 않는 이상한 사이코가 항상 있죠. 우리의 옛 습관과 프레임워크는 우리가 삭제했다고 생각해도 그대로 사라지지 않아요. 모든 시스템과 그 코드를 괴롭히는 구조적 유령들이 있죠. 하지만 대부분의 경우에는 익숙한 인간적이거나 기술적인 습관을 버릴 때 기술적 부채가 생기죠. 그런 부채는 다음 개인이나 혁신에 시간과 에너지를 투자할 가능성이 적어지게 만드는 거예요.\n\n우리는 참여하는 것처럼 행동할지 몰라도 사실은 그것은 표면적일 뿐이에요. 당신의 시간을 낭비하고 있는 건 우리가 당신이 우리의 시간을 낭비하고 있다고 생각하기 때문이에요.\n\n![이미지](\"/assets/img/2024-06-22-IntegratingNewSoftwareintoYourRelationship_1.png\")\n\n한 명의 클라이언트를 위해 작업하면서 '사랑에 빠진 사람'이라고 자주 얘기하는 연애 중독자를 만났어요. 더 어린 사람을 선호하는 노인들의 이유를 이해할 수 있었죠. 그게 그저 젊은 몸 때문만은 아니라는 거, 그것이 도움이 되는 건 매트릭스만 알죠.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n코드를 직접 작성하는 데는 시간이 걸리고, 젊음은 경험이 부족해서 발생하는 이동성과 간결함을 의미합니다. 젊은 사람들은 새로운 환경에 빠르게 적응하고 해당 환경에 쉽게 변화됩니다. 젊은 고객들은 자신의 자아 인식에 가치를 더하는 것을 구매하기를 더욱 열망합니다. 게다가, 젊음은 주로 시간, 에너지, 혁신적인 취미(춤추기와 마실 것을 알고 계시죠)에 대한 욕망과 함께 옵니다.\n\n한편, 나이는 안정성과 일관성, 기대치를 설정하는 문서 작성, 검증 및 시행된 테스트 가능성을 나타냅니다. 이것은 생명을 살아가며 명확성을 찾고 있는 미성숙한 코드에게 매우 매력적일 수 있습니다.\n\n그러나 어떤 수립된 시스템에 완전히 통합되는 것은 굉장히 제한적일 수도 있습니다: 아무도 장기적인 통합을 받을 가치 있는 시스템 대신 플러그인으로 다루어지길 원하지 않습니다. 부착물은 쉽게 버릴 수 있습니다.\n\n나는 이 모든 것에 문제가 있다고 생각하지 않습니다. 관계는 신속하게 구축되는 것이 아니라, 종이 많이 넘기고, 구독하고, 감정적으로 클릭하는 여러 정신적 활동을 통해 만들어집니다. 우리는 스스로를 위한 신뢰할 만한 콘텐츠를 찾고 만들기 위해 반복 작업해야 하며, 그후 소셜 미디어 피드를 적절하게 소개해야 합니다. 우리가 디지털 버전의 스스로와 다른 사람을 좋아하는 이유 중 하나는 스스로 창조 감을 속일 만큼 즉각적이고 영감을 준다고 느끼기 때문입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다윈은 이 모든 것이 자연스러울 것이라 말했겠지만, 반대자들은 로맨스의 위엄을 박탈한다고 말할지도 모르겠어요. 두 그룹 다 어느 정도의 투쟁은 예상된다는 데 동의할 것 같아요. 측정된 양의 투쟁은 적절한 맥락 속에서 우리가 살아남고 번영하는 데 도움을 줄 수 있어요.\n\n안타깝게도, 이러한 측정된 투쟁의 이점은 계산하고 시스템에 통합하는 데 굉장히 어려울 수 있어요. 성과에 대한 관련 지표는 지역적입니다. 한 관계에서 성공을 나타내는 것이 다음 관계에서도 성공을 예측하지는 않아요. 대부분의 개별 지표는 참된 확장 가능성을 거부하며, 그렇지 않다고 주장하는 사람들은 특이값으로 간주되어 시스템의 전체 적용에는 영향을 미치지 않는다고 무시하는 경향이 있어요.\n\n우리는 '공통 기준'과 같은 것들을 통해 이를 감안하려고 노력하지만, 일반적인 기준이 구체적인 응용 분야에서는 대부분 충분하지 않다는 것이 밝혀져요. 어떤 관계에서 성공을 의미하는 것이 다음 관계에서도 성공을 예측하지는 않아요. 대부분의 개별 지표가 참된 확장 가능성을 거부하며, 그렇지 않다고 주장하는 사람들은 특이값으로 간주되어 시스템의 전체 적용에는 영향을 미치지 않는다고 무시할 가능성이 높아요.\n\n개인적인 관점에서, 어느 정도의 투쟁은 피할 수 없지만 그것을 피하기 위해 완전한 통제를 포기하고 싶지 않아요. 그런 선택은 장기적으로는 항상 잘 되지 않아요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아마도 나의 중년 때로 추정되지만, 요즘 나는 미들웨어 같은 기분이 들어요.\n\n그랜트 매니저로 일하며, 주로 다양한 시스템과 데이터 관리 프로토콜 사이에서 협상하고 번역하는 데 시간을 보내고 있어요. 유럽에서 다양한 정의를 가진 소규모 및 중소기업, 대기업, 대학, 연구소, 그리고 다양한 대륙과 사회에 걸쳐 활동하는 정책 결정자들과 협업하고 있어요. 사회적 이익을 위해 초대규모 시스템을 국소화하려고 노력하고 있는데, 이는 많은 영향력 있는 주체들의 시스템적 경제 목적을 침해하고 있는 거 같아요. Microsoft는 \"비영리 단체\"가 아니며, 대부분의 정책도 그렇지 않죠.\n\n대규모 소프트웨어 통합이 계속되는 것처럼 느껴졌던 대규모의 시기에 제 전문성을 키웠어요. 기술적인 세계에 널리 퍼져 있는 거목들에게 우리 개인의 독특한 정체성을 잃을 것 같은 느낌은 피할 수 없는 것처럼 느껴졌죠. 상장하지 못하는 스타트업들은 체계적 우위로 도약시킬 수 있는 회로에 흡수되기 위해 싸웠어요.\n\n그러나 이제는 기술적 및 디지털 주권과 자율성의 가치를 찬양하는 제안 초청이 내 이메일함에 자주 뜨면서 하루도 지나지 않아요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아마도 이런 전화는 모두 유럽 위원회에서 마이크로소프트 워드 문서로 작성한 것 같아요. 이 문제를 묻고 싶네요: 마이크로소프트의 본사가 어디에 있는지 알려줄까요, 아니면 CoPilot에게 맡길까요?\n\n한편 정치에서의 증가하는 민족주의는 이미 결함, 불완전 및 잘못된 구조의 데이터로 가득 찬 연방 디지털 플랫폼과 함께 다가오고 있어요. ChatGPT, Google 또는 다른 AI 기반 봇이던 상관없이, 우리는 주도적인 질문을 하고 사회적으로 조직된 응답을 얻어 우리의 동의를 유도하고 믿음을 강화하기 위한 것입니다. 새롭고 다양하며 이질적인 플랫폼에서 만든 모델을 훈련하고 통합하면 이번에는 더 나은 확장성을 기대할 수 있을까요?\n\n대형 플랫폼이 적절하게 지역화하는 데 실패한 것은 비밀이 아니에요. 회의실에서의 남자들은 실제 우위와 인접한 면역력을 위해 현장 통합을 희생했어요. 그들은 만약 망치를 판다면 집이 그들의 모습으로 스스로 건축될 것이라고 생각했어요. 선택지가 하나 또는 두 개밖에 없다면 사람들은 선택해야 한다고요? 의사 결정자들은 결정을 내리는 이들이 혁신하거나 발명할 것이라고 기대하지 않아요.\n\n자철하는 지도자들은 가끔 판매의 득템 흥분 속에서 디지털 기업 도구를 채택하고 가치를 추출하는 것을 기대하는 사람들을 잊곤 해요. 진정한 전달 보장을 확보하기 위해 필요한 사전 조사보다는 회의실 내의 외부 검증이 중요하다 보는 거죠. 이탈된 이사들은 그들의 아래에 있는 사람들을 리더십에만 말하는 시스템의 조작 가능한 톱니바퀴로 취급해 왔어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n피라미드 꼭대기에서의 위치로부터, 이러한 리더들은 경쟁적인 피라미드 제도가 사람들을 최선으로 이끌지 않는다는 것을 잊은 듯합니다. 망치나 집을 사는 것만으로는 집이 되지 않죠. 다윈이 맞을지는 몰라도, 이것이 내 과학 선생님들을 설득하는 데 도움이 될지는 의문입니다.\n\nNASA는 별을 향해 나아가지만, 지구에 있는 사람들이 들여다봐주지 않는 한, 어떠한 잠재적인 진전도 후퇴할 수 있다는 점을 염두에 두어야 합니다.\n\n사람들은 배제되거나 뒤처지는 느낌을 받기 싫어합니다.\n\n# 추가 읽을거리:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![2024-06-22-IntegratingNewSoftwareintoYourRelationship_2](/assets/img/2024-06-22-IntegratingNewSoftwareintoYourRelationship_2.png)\n","ogImage":{"url":"/assets/img/2024-06-22-IntegratingNewSoftwareintoYourRelationship_0.png"},"coverImage":"/assets/img/2024-06-22-IntegratingNewSoftwareintoYourRelationship_0.png","tag":["Tech"],"readingTime":18},{"title":"VSCode의 글꼴이 UHD 및 OLED 디스플레이에서 더 선명해진 방법 한 가지 설정으로 해결","description":"","date":"2024-06-22 22:48","slug":"2024-06-22-VSCodeFontsNowSharperOnUHDAndOLEDDisplaysWithOneFlag","content":"\n<img src=\"/assets/img/2024-06-22-VSCodeFontsNowSharperOnUHDAndOLEDDisplaysWithOneFlag_0.png\" />\n\n# 마침내, OLED 및 UHD 모니터에서 VSCode 글꼴이 흔들리는 문제를 해결할 수 있게 되었습니다!\n\n# 새로운 플래그\n\n일반적으로 VSCode의 개선 사항은 생산성, 개발자 경험 및 Copilot과 같은 통합과 같은 개발자 도구를 중심으로합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n하지만 항상 그렇지만은 않고 때로는 변화가 상당히 놀라울 수 있어요.\n\n2024년 5월 버전의 개선 목록 중에서 여러 탭을 동시에 선택할 수 있는 기능, 프로필, 에디터 창 작업 아이콘을 항상 표시할 수 있는 기능 또는 Copilot 대답에 대한 텍스트 음성 변환 기능을 발견할 수 있어요.\n\n그 중에서도 가장 흥미로운 것은 \"Set disable-lcd-text as a runtime argument\"라는 수수께끼 같은 제목으로 가능한 개선이에요.\n\n간단한 설명에서는 다음과 같은 것을 배울 수 있어요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nIllustration을 확인해보세요:\n\n![image](/assets/img/2024-06-22-VSCodeFontsNowSharperOnUHDAndOLEDDisplaysWithOneFlag_1.png)\n\n왼쪽에 보면 플래그가 true로 설정된 버전이 있습니다. 이는 LCD 텍스트가 비활성화됨을 의미합니다.\n\n보이는 바에 따르면, 그 버전은 UHD 모니터를 사용하는 몇몇 개발자들, Retina 디스플레이를 사용하는 Mac 노트북 사용자들을 포함한 다른 많은 사람들에게 더 나은 선택이 될 것 같습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n하지만 모든 사람이 화면에서 변경 사항을 보지 못할 수도 있고, 모든 사람이 그것을 좋아하지도 않을 것입니다.\n\n# 서브픽셀의 폰트가 개선된 이유\n\n하지만 이것이 정말 어떤 것인가요? 우리가 비활성화해야 하는 LCD 텍스트 기능은 무엇일까요?\n\n이것을 이해하려면 90년대로 돌아가 봐야 합니다. 사람들이 점점 더 컴퓨터를 사용하기 시작했습니다. 운영 체제 개발 회사들은 소비자 시장에 더 집중하기로 결정했습니다. 이를 위해 최상의 사용자 경험을 제공해야 했습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n온라인 비디오 플랫폼이 없었기 때문에 사람들은 800x600 픽셀 모니터에서 텍스트를 작성하고 마인스위퍼를 플레이하던 컴퓨터를 주로 사용했어요.\n\n해당 해상도의 한계는 픽셀이 일론 머스크의 자아보다 더 크다는 것이에요. 그래서 눈으로 그들을 볼 수 있었어요.\n\n그 중 가장 피해를 입은 것은 텍스트였어요. 그 이유가 뭘까요? 사용자 인터페이스를 구축하고 해상도가 무엇인지 알고 있다면 이를 조절하여 멋지게 보이도록 조정할 수 있어요. 이런 경우에는 픽셀 아트처럼 해상도의 제한과 사용자 인식을 고려하여 아이콘과 인터페이스를 픽셀 단위로 그려 조정하는 것을 뜻해요.\n\n하지만 텍스트의 경우는 그렇게 쉽지 않아요. 다른 요소들과 비교했을 때 글자와 기호들은 매우 구체적인 구조를 가지고 있어요. 그것들을 많이 변경할 수 없는 이유는 더 이상 가독성이 없어지거나 다른 글자와 유사해질 수 있기 때문이에요. 예를 들어, 글자 O와 숫자 0은 구분되어야 하므로 약간 다르게 보이도록 해야 해요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n작은 해상도에서는 정말로 어려워요.\n\n그 문제를 해결하고 나니, 90년대에 또 다른 문제가 뚜렷해졌어요. 폰트가 정말로 못생겼어요.\n\n폰트는 날카롭고 화소로 이루어져 있었죠. 그래서 작은 폰트는 읽기 어렵고 큰 폰트는 마인크래프트 같이 보였어요.\n\n소비자들이 좋아하지 않는 것이었죠. 그래서 그 시기에는 물리적 해상도를 늘릴 수 없었기 때문에 많은 해결 방안이 제안되었어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 안티 앨리어싱으로 구제!\n\n이 문제 중 하나는 안티 앨리어싱입니다. 흰 배경에 검은 텍스트가 있는 경우, 회색 픽셀로 모서리를 부드럽게 만들어 줍니다. 그렇게 하면 확대할 때 글꼴이 덜 날카롭지만 부드럽고 픽셀화가 줄어듭니다:\n\n![이미지](/assets/img/2024-06-22-VSCodeFontsNowSharperOnUHDAndOLEDDisplaysWithOneFlag_2.png)\n\n이 방법은 픽셀 아트에서 디자인을 부드럽게 만드는 데에도 사용됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n하지만 글꼴의 경우는 세부 사항 때문에 일반적인 안티앨리어싱만으로는 충분하지 않았습니다. 그래서 1990년대에 Microsoft와 Apple은 유사한 솔루션을 도입했습니다.\n\nWindows의 경우, ClearType이 그것입니다. 화면에 표시되는 텍스트의 표시 방법을 개선하는 세트의 방법입니다.\n\n그러나 일반적인 안티앨리어싱과 비교하여 ClearType은 서브픽셀에서 작동합니다.\n\n화면에서 본 픽셀은 사실 빨강, 녹색 및 파랑(RGB)과 같은 서로 가깝게 배치된 서로 다른 색상의 서브픽셀입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 서블 픽셀의 위치를 알고 있다면 LCD 스크린에 대해 90년대에 알려졌듯이 이 서블 픽셀을 사용하여 글꼴의 안티 앨리어싱을 할 수 있습니다. 이렇게 하면 이웃하는 서블 픽셀들이 부드럽게 변할 수 있는 더 세련된 효과를 낼 수 있습니다.\n\n연구 결과를 보면 ClearType를 활성화한 상태에서 텍스트를 읽는 것이 더 좋다고 한 사람들이 많았습니다. 그러나 90년대에는 시력이 좋은 사람들조차도 이 방식을 짜증냈다고 합니다.\n\n폰트가 서로 닮아보이기 시작하고 독특한 특징을 잃게 되었다고 보고했으며, 어떤 디스플레이에서는 이 방식으로 인해 흐릿하고 붉은 블루 하로가 나타나 짜증이 났다고 합니다.\n\n그럼에도 불구하고 모든 사람들이 만족했습니다. ClearType를 비활성화할 수 있었기 때문이죠.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 새로운 디스플레이로 LCD 최적화 방법이 오래되었습니다\n\n2024년 상황이 달라졌어요. 실제로 지금은 서브픽셀이 어떻게 배치되는지에 대한 규칙이 없어졌어요. 점점 더 많은 디스플레이가 삼각형 구성 또는 다른 유형의 배치를 사용하고 있어요.\n\n이것은 폰트 최적화가 적용되었을 때 텍스트가 더 신기해진다는 것을 의미해요. 왜냐하면 실제 서브픽셀의 위치와는 다른 곳을 가정하기 때문이죠. 결과적으로 이상한 효과가 발생하는데요, 심지어 보다 더 눈에 띄는 빨간색과 파란색의 이동 및 가장자리의 선이 현상되는 효과도 있어요.\n\n예를 들면 이렇게요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![2024-06-22-VSCodeFontsNowSharperOnUHDAndOLEDDisplaysWithOneFlag_3.png](/assets/img/2024-06-22-VSCodeFontsNowSharperOnUHDAndOLEDDisplaysWithOneFlag_3.png)\n\nOLED 및 다른 비-LCD 장치에서 특히 선명해졌어요.\n\n시스템 UI의 ClearType를 제어할 수 있지만, 앱에서 변경할 지 어떻게 변경할 지를 결정하는 것은 앱 개발자에 따라 달라요.\n\n예를 들어, 많은 브라우저에서는 어떤 종류의 글꼴 평활화를 적용할 지를 사용자가 결정할 수 있어요. 이 옵션은 웹 앱이 액세스할 수 없는 많은 변수(하위화소 레이아웃과 같은)에 따라 결정해야 하는 매우 특정한 경우에만 사용되어야 해요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만일 VSCode에 대해 구체적으로 언급한다면, 이 IDE는 TypeScript로 작성되었고 Electron과 Chromium을 사용합니다.\n\n그리고 Chromium은 LCD 스크린을 위한 최적화 비활성화를 위한 플래그를 제공하지만, VSCode에서는 이를 노출하지 않았습니다.\n\n2024년 5월 릴리스로 인해 가능해졌습니다. 그래서 고해상도 스크린, OLED 또는 다른 스크린을 사용하시는 경우, 글꼴 최적화를 비활성화하는 것이 글꼴 표시 방법을 향상시킬 수 있는지 확인할 수 있습니다.\n\n고해상도 스크린의 경우 글꼴 부드럽게 처리는 필수가 아닙니다. 높은 픽셀 밀도는 서브픽셀 최적화를 점점 더 사용하지 않게 만듭니다.\n","ogImage":{"url":"/assets/img/2024-06-22-VSCodeFontsNowSharperOnUHDAndOLEDDisplaysWithOneFlag_0.png"},"coverImage":"/assets/img/2024-06-22-VSCodeFontsNowSharperOnUHDAndOLEDDisplaysWithOneFlag_0.png","tag":["Tech"],"readingTime":7},{"title":"RecyclerView 항목을 payloads로 효율적으로 업데이트하는 방법","description":"","date":"2024-06-22 22:47","slug":"2024-06-22-EfficientlyupdatingRecyclerViewitemsusingpayloads","content":"\n요즘 대부분의 앱은 사용자에게 수직이나 수평 목록으로 정보를 표시합니다. 종종, 정보는 동적이며 조회수, 좋아요 수 등과 같이 자주 업데이트해야 하는 정보입니다. 또한 목록에는 네트워크에서 로드된 이미지가 포함될 수도 있습니다. 이것이 RecyclerView를 효율적으로 업데이트하는 것이 중요한 이유이며, 성능이 우수한 앱을 갖고 좋은 사용자 경험을 제공하는 중요한 측면입니다.\n\n이 게시물은 얼마 전에 쓰여졌지만, 이미 다루어진 주제이고 Jetpack Compose가 현재 선호되는 UI 툴킷이기 때문에 발행할 지 말 지 고민하고 있었습니다. 그러나 이 정보가 누군가에게 도움이 될 수 있기를 바라며 게시하기로 결정했습니다.\n\n## DiffUtil과 ListAdapter 사용하기\n\n새 데이터로 RecyclerView를 효율적으로 업데이트하려면 notifyItemInserted(position: Int), notifyItemChanged(position: Int), notifyItemRemoved(position: Int) 등과 같은 함수를 호출해야 합니다 (docs에서는 효율적이지 않으며 최후의 수단으로만 사용해야 한다고 명시한 notifyDataSetChanged()는 피하시기 바랍니다). 이러한 함수를 호출하면 RecyclerView Adapter에 기본 데이터가 변경되었음을 알리고 뷰를 업데이트하여 새 상태를 반영해야 한다는 사실을 알리게 됩니다. 이러한 함수 호출은 RecyclerView가 모든 변경 사항을 애니메이션으로 처리하는 이점도 함께 제공됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n수동으로 그 모든 작업을 하지 않도록 하기 위해 DiffUtil을 사용할 수 있습니다 (공식 문서). DiffUtil은 이전 데이터와 새 데이터를 비교하고 차이점을 계산한 다음 RecyclerView.Adapter에 변경 사항을 알려주어 새 상태를 반영하기 위해 수행해야 하는 변경 사항을 선언합니다. 이후 사용할 DiffUtil.ItemCallback의 예시가 여기 있습니다.\n\nFunction areItemsTheSame(oldItem: Item, newItem: Item): Boolean은 id 또는 uuid와 같은 고유 속성을 기준으로 두 항목이 동일한지 확인합니다. 항목이 다를 경우 어댑터는 이전 항목을 새 항목으로 바꿔야 한다는 것을 알게 됩니다. 이 함수가 true를 반환하면 함수 areContentsTheSame(oldItem: Item, newItem: Item): Boolean이 호출되는데, 여기서 데이터 모델의 다른 속성 중 어떤 것이 변경되었는지 확인할 수 있습니다.\n\n중요한 점은 DiffUtil 결과를 백그라운드 스레드에서 계산하는 것이 권장된다는 것입니다. 더 큰 데이터 집합이 있는 경우에는 요구가 많을 수 있고 주 스레드를 차단할 수 있기 때문입니다. Coroutine 또는 RxJava를 사용하여 계산을 다른 스레드로 옮기거나 ListAdapter(공식 문서)를 사용하여 백그라운드 스레드에서 계산할 수 있습니다.\n\nListAdapter는 AsyncListDiffer (공식 문서)를 사용하여 백그라운드 스레드에서 차이를 계산하는 논리를 포함하고 RecyclerView.Adapter를 확장하여 코드를 더욱 간결하게 만듭니다. 할 일은 새 데이터를 함수 submitList(list: List)를 사용하여 전달하는 것뿐입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 샘플 앱에서 모두 함께 사용해보기\n\n지금까지 배운 내용을 모아 간단한 앱으로 만들어보겠습니다. 이 앱은 기사 목록을 표시하는데, 각 기사에는 제목, 부제목, URL에서 로드된 표지 이미지, 좌측 하단에 표시되는 코멘트 수가 포함되어 있습니다. 사용자는 각 기사 오른쪽 상단의 북마크 버튼을 눌러 해당 기사를 즐겨찾기에 추가할 수도 있습니다. 툴바에는 두 개의 버튼이 있습니다. 코멘트 수를 업데이트하는 새로고침 버튼과 애니메이션 데모 목적으로 기사의 순서를 임의로 변경하는 재정렬 버튼입니다.\n\n아래는 소스 코드와 앱이 동작하는 모습을 보여주는 동영상입니다.\n\n![앱 동작 예시](https://miro.medium.com/v2/resize:fit:640/1*kRBq0EXx36YlMoTCuulNuw.gif)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리는 재정렬 애니메이션이 원하는 대로 동작하는 것을 볼 수 있습니다. 그러나 사용자가 기사를 북마크하거나 댓글 수를 새로고침할 때의 애니메이션을 살펴보겠습니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:640/1*fWIvJ-K4PoONrlIZNzys1Q.gif)\n\n## 기사가 업데이트될 때 \"깜빡이\" 효과가 나타나는 이유는 무엇인가요?\n\n기본적으로 두 항목(우리의 경우 기사)이 동일하지만 다른 콘텐츠(우리의 경우 댓글 수 또는 기사 북마크 여부)를 가질 때 RecyclerView는 새 항목 보기를 렌더링한 다음 이전 항목 보기와 새 항목 보기 사이에 크로스 페이드를 수행하여 GIF에서 볼 수 있는 \"깜빡임\" 효과를 초래합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n특히 더 어두운 배경이 사용되거나 사용자 상호작용의 결과로 업데이트될 때 이 기능은 이상하게 보일 수 있습니다. 이는 북마크 또는 북마크 취소와 같은 사용자 상호작용으로 인한 업데이트가 발생할 때 더 문제가 됩니다.\n\n## 성능은 어떻게 해결할까요?\n\n\"깜빡\"이 발생하는 애니메이션 외에 다른 문제는 항목 뷰를 완전히 다시 바인딩한다는 점입니다. 이 방법은 효율적이지 않습니다. 우리는 댓글 수를 업데이트하거나 북마크 아이콘을 변경하기를 원할 뿐이지만, 대신 전체 항목 뷰를 다시 그리고 다시 렌더링하고 있습니다. 이는 이미 필요하지 않은 이미지를 다시로드 하는 것을 포함합니다.\n\n## 이 문제를 어떻게 해결할 수 있을까요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\"“RecyclerViewanimation”을 비활성화하는 방법을 검색 중이라면 나타나는 해결책 중 하나는 RecyclerView. itemAnimator에 supportsChangeAnimation = false를 설정하거나 itemAnimator = null로 설정하는 것입니다.\n\n그러나 이 방법은 항목의 순서가 변경되거나 새 항목이 예전 항목을 대체할 때 발생하는 모든 애니메이션도 비활성화되어 우리가 원하는 대상이 아닐 수 있습니다. 우리는 기존 항목의 속성이 변경될 때 교차 페이드 애니메이션을 제외한 모든 애니메이션을 유지하고 싶습니다. 또한, 이 해결책은 우리가 언급한 효율성/성능 문제를 다루지 않습니다.\n\n## Payloads\n\n페이로드를 사용하여 애니메이션 및 효율성 문제를 모두 해결할 수 있습니다. 페이로드는 이미 정의한 객체로, 이미 존재하는 항목 뷰를 완전히 다시 바인딩하는 대신 일부만 업데이트할 수 있게 해줍니다.\"\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nRecyclerView.Adapter의 함수들을 좀 더 자세히 살펴보면, onBindViewHolder(holder: ViewHolder, position: Int, payloads: MutableList`Any`)라는 추가 함수를 오버라이드할 수 있는데, 이 함수는 onBindViewHolder(holder: ViewHolder, position: Int) 함수를 오버로딩한 것으로 payloads라는 추가 인수가 있습니다. 이 함수에 대한 문서를 살펴보면 다음과 같이 설명되어 있습니다:\n\n변화 페이로드를 어떻게 얻을 수 있을까요? DiffUtil.ItemCallback에서 사용 가능한 함수들을 좀 더 자세히 살펴보면 기존의 함수인 areItemsTheSame(oldItem: Item, newItem: Item): Boolean과 areContentsTheSame(oldtItem: Item, newItem: Item): Boolean 외에도 fun getChangePayload(oldItem: Item, newItem: Item): Any?라는 추가 함수를 오버라이드할 수 있습니다.\n이 함수는 이전 항목과 새 항목이 동일하지만 내용이 다른 경우 호출됩니다. 항목의 어떤 속성이 다른지 감지하고, 항목 뷰를 부분적으로 업데이트할 수 있는 객체를 반환할 수 있게 해줍니다.\n\n여기서 우리는 이전 항목과 새 항목을 비교하고, 댓글 수가 다른 경우에는 ArticleChangePayload.Comments의 인스턴스를 반환하여 나중에 어떤 뷰를 업데이트해야 하는지 알 수 있게 합니다. 북마크 상태에 대해서도 동일한 작업을 수행하고, ArticleChangePayload.Bookmark를 반환합니다. 그리고 다른 변경 사항의 경우에는 간단히 super 함수를 호출하여 null을 반환하게 하여 전체 재바인딩이 되도록 합니다.\n\n이렇게하면 이제 onBindViewHolder 함수에서 payloads 인수를 확인할 수 있습니다. 이 것은 여러 스레드에서 병합된 여러 업데이트가 될 수 있기 때문에 리스트 형태로 제공됩니다. 문서에서 언급된 것처럼요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n각 리스트를 하나하나 처리할지 아니면 리스트에서 마지막 항목만 가져올지 결정할 수 있어요.\n\n우리 경우에는 마지막 항목을 확인하고, 만약 그것이 ArticleChangePayload.Comments 유형이라면 댓글 수 TextView를 업데이트하고, ArticleChangePayload.Bookmark 유형이라면 북마크 이미지 버튼을 업데이트할 거에요. 또한 페이로드가 비어 있거나 알 수 없는 유형인 경우를 처리하는 것이 중요해요. 그런 경우에는 원래의 onBindViewHolder(holder: ViewHolder, position: Int) 함수를 호출하여 완전히 다시 바인딩해야 해요. 이는 오버로드된 onBindViewHolder 함수의 기본 구현입니다.\n\n이 기능을 추가한 후에 이제 데이터가 변경된 부분만 뷰에 업데이트되고 깜박거림 효과가 없어졌다는 것을 확인할 수 있어요. 완벽해요.\n\n![이미지](https://miro.medium.com/v2/resize:fit:640/1*OevReNMqnU9pngRAEUxmWQ.gif)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그리고 여기에 업데이트된 어댑터 구현이 있습니다.\n\n## 결론\n\n저희는 DiffUtil, ListAdapter 및 payloads를 사용하여 RecyclerView 콘텐츠를 가장 효율적으로 업데이트하는 방법을 살펴보았습니다. 우리가 글 목록을 보여주는 앱을 가지고 있고 좋아요 수나 조회수를 자주 업데이트하려는 경우, payloads를 사용하면 전체 항목을 다시 부풀리고 다시 그리는 대신 변경된 뷰만 효율적으로 업데이트할 수 있습니다.\n\n샘플 앱의 소스 코드는 여기에서 확인할 수 있습니다: https://github.com/landomen/recyclerview-payloads-sample\n","ogImage":{"url":"/assets/img/2024-06-22-EfficientlyupdatingRecyclerViewitemsusingpayloads_0.png"},"coverImage":"/assets/img/2024-06-22-EfficientlyupdatingRecyclerViewitemsusingpayloads_0.png","tag":["Tech"],"readingTime":8},{"title":"2024 최신 Android Paging 30 Part 2 적용 방법","description":"","date":"2024-06-22 22:46","slug":"2024-06-22-Part2AndroidPaging30","content":"\n![그림](/assets/img/2024-06-22-Part2AndroidPaging30_0.png)\n\n안드로이드에서의 Paging 3.0은 이전 버전보다 여러 가지 개선 사항과 변화를 가져와서 더 강력하고 사용하기 쉽게 만들어졌어요. 아래에는 Paging 3.0의 각 구성 요소를 구현하는 방법에 대한 자세한 설명이 있습니다.\n\n# Paging 3.0의 주요 구성 요소\n\n- PagingSource: DataSource를 대체하며 서로 다른 소스로부터 데이터를 페이징하는 데 사용되는 주요 API 역할을 합니다.\n- Pager: 페이징된 데이터의 Flow 또는 LiveData를 생성하는 데 사용됩니다.\n- PagingData: 페이징된 데이터의 스트림을 나타냅니다.\n- PagingDataAdapter: PagedListAdapter를 대체하며 RecyclerView에서 페이징된 데이터를 표시하는 데 사용됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 구현 단계\n\n- PagingSource 정의:\n\n- PagingSource는 데이터를 데이터 소스에서 로드하는 역할을 담당합니다.\n- 다양한 페이지에 대해 데이터를 로드하는 방법을 정의함으로써 PagingSource를 구현합니다.\n\n```kotlin\nclass MyPagingSource(private val apiService: ApiService) : PagingSource<Int, MyItem>() {\n\n    override suspend fun load(params: LoadParams<Int>): LoadResult<Int, MyItem> {\n        return try {\n            // 데이터 소스에서 데이터 로드\n            val nextPageNumber = params.key ?: 1\n            val response = apiService.getItems(nextPageNumber, params.loadSize)\n            LoadResult.Page(\n                data = response.items,\n                prevKey = if (nextPageNumber == 1) null else nextPageNumber - 1,\n                nextKey = if (response.items.isEmpty()) null else nextPageNumber + 1\n            )\n        } catch (e: Exception) {\n            LoadResult.Error(e)\n        }\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n2. 페이저 생성하기:\n\n- 페이저 객체는 PagingData의 Flow 또는 LiveData를 생성하는 데 사용됩니다.\n- 페이저를 PagingConfig와 PagingSource로 구성합니다.\n\n```js\nclass MyRepository(private val apiService: ApiService) {\n\n    fun getPagingData(): Flow<PagingData<MyItem>> {\n        return Pager(\n            config = PagingConfig(\n                pageSize = 20,\n                enablePlaceholders = false\n            ),\n            pagingSourceFactory = { MyPagingSource(apiService) }\n        ).flow\n    }\n}\n```\n\n3. ViewModel에서 PagingData 관찰하기:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 뷰모델에서 PagingData를 관찰하기 위해 Flow를 사용하세요.\n- LiveData를 선호한다면 LiveData와 함께 작업하십시오.\n\n```js\nclass MyRepository(private val apiService: ApiService) {\n\n    fun getPagingData(): Flow<PagingData<MyItem>> {\n        return Pager(\n            config = PagingConfig(\n                pageSize = 20,\n                enablePlaceholders = false\n            ),\n            pagingSourceFactory = { MyPagingSource(apiService) }\n        ).flow\n    }\n}\n```\n\n4. PagingDataAdapter로 RecyclerView 설정하기:\n\n- PagingDataAdapter를 사용하여 데이터를 RecyclerView에 바인딩합니다.\n- PagingData가 변경될 때 새 데이터를 어댑터에 제출하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nclass MyViewModel(private val repository: MyRepository) : ViewModel() {\n\n    val pagingDataFlow = repository.getPagingData().cachedIn(viewModelScope)\n}\n```\n\n5. Activity/Fragment에서 모든 것을 연결하기:\n\n- PagingData를 관찰하고 어댑터에 제출합니다.\n\n```js\nclass MyPagingDataAdapter : PagingDataAdapter<MyItem, MyViewHolder>(MyDiffCallback()) {\n\n    override fun onBindViewHolder(holder: MyViewHolder, position: Int) {\n        val item = getItem(position)\n        if (item != null) {\n            holder.bind(item)\n        }\n    }\n\n    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): MyViewHolder {\n        val view = LayoutInflater.from(parent.context).inflate(R.layout.item_view, parent, false)\n        return MyViewHolder(view)\n    }\n\n    class MyDiffCallback : DiffUtil.ItemCallback<MyItem>() {\n        override fun areItemsTheSame(oldItem: MyItem, newItem: MyItem): Boolean {\n            return oldItem.id == newItem.id\n        }\n\n        override fun areContentsTheSame(oldItem: MyItem, newItem: MyItem): Boolean {\n            return oldItem == newItem\n        }\n    }\n}\n\nclass MyViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {\n    fun bind(item: MyItem) {\n        // 뷰에 데이터를 바인딩합니다\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 대용량 데이터 처리\n\nPaging 3.0은 다음과 같은 방식으로 대용량 데이터 세트를 효과적으로 처리합니다:\n\n- 점진적 로딩: 필요할 때 데이터를 청크 단위로 로드하여 메모리 사용량을 줄입니다.\n- 백그라운드 로딩: 데이터 로딩을 백그라운드에서 처리하여 반응이 빠른 UI를 제공합니다.\n- 오류 처리: 실패한 로드를 다시 시도할 수 있는 메커니즘을 제공합니다.\n- 캐싱: 불필요한 네트워크 또는 데이터베이스 호출을 방지하기 위해 인메모리 캐싱을 지원합니다.\n- 변환: PagingData에 직접 적용할 수 있는 데이터 변환(예: 맵, 필터)을 허용합니다.\n\nPaging 3.0을 사용하여 대용량 데이터 세트를 원활하게 처리할 수 있는 효율적이고 반응이 뛰어난 애플리케이션을 만들 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-06-22-Part2AndroidPaging30_0.png"},"coverImage":"/assets/img/2024-06-22-Part2AndroidPaging30_0.png","tag":["Tech"],"readingTime":6},{"title":"Flutter에서 시간표시를 사용자 친화적으로 포맷하는 방법","description":"","date":"2024-06-22 22:45","slug":"2024-06-22-FromTimestamptoUser-FriendlyFormattingDateandTimeinFlutter","content":"\nFlutter 앱을 개발 중이라면 날짜를 어떤 방식으로든 표시해야 할 가능성이 높습니다. 특정 순서로 날짜를 표시하려면 올바른 장소에 오신 것을 환영합니다. 이 기사에서는 Flutter에서 어떻게 날짜와 시간을 어떤 형식으로든 포맷할 수 있는지 배워보겠습니다.\n\n우선 기본부터 시작해 봅시다. 현재 날짜와 시간을 가져오는 방법을 알아보겠습니다.\n\n```js\nDateTime currentDateTime = DateTime.now();\ndebugPrint(currentDateTime.toString());\n```\n\n위 코드는 이와 같은 결과를 제공할 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![image](/assets/img/2024-06-22-FromTimestamptoUser-FriendlyFormattingDateandTimeinFlutter_0.png)\n\n안 예쁘게 보이네요, 그래서 여기 계신 거죠. 이것을 더 읽기 쉬운 방식으로 서식을 지정하려고 합니다. currentDateTime에는 오늘의 날짜와 현재 시간이 포함됩니다. 이를 원하는 대로 문자열 형식으로 원격 또는 로컬 데이터베이스에 저장하거나 지금 표시하려면 직접 조작할 수 있습니다.\n\n참고: - 다른 곳(데이터베이스)에서 날짜를 가져오는 경우 문자열 형식으로 저장되었을 가능성이 높으므로 이를 DateTime 형식으로 변환하는 방법입니다.\n\n```js\nDateTime current = DateTime.parse(variableName);\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n중요한 부분이 왔어요! 포맷을 변경하는 방법을 설명하겠어요. 두 가지 방법을 설명할 거에요. 첫 번째 방법은 간단하고 쉽게 사용할 수 있어요. 두 번째 방법은 사용자 정의 형식이지만 쉬워요 :-).\n\n![image](/assets/img/2024-06-22-FromTimestamptoUser-FriendlyFormattingDateandTimeinFlutter_1.png)\n\n만약 이 중 하나를 원한다면 아주 잘 알겠어요. 그렇지 않다면 더 다양한 경우에 대한 하나의 해결책이 더 있어요. 이 해결책은 이 글의 두 번째 부분에서 확인할 수 있어요.\n\n- 표준 형식 사용\n  먼저, public.yaml 파일에 intl 라이브러리를 추가해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  cupertino_icons: ^1.0.2\n  intl: ^0.17.0\n```\n\n이 라이브러리의 최신 버전을 intl 라이브러리에서 확인할 수 있습니다.\n\n```js\nDateTime now = DateTime.now();\n// String 형식의 변수를 dateTime으로 사용하는 경우 DateTime dateTime = DateTime.parse(variableName);\nString formattedDate = DateFormat.yMMMEd().format(now);\nprint(formattedDate);\n```\n\nTue, Jan 25, 2022\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nCheatsheet:-\n\n![Screenshot](/assets/img/2024-06-22-FromTimestamptoUser-FriendlyFormattingDateandTimeinFlutter_2.png)\n\n2. If you want a custom pattern\n\nSometimes we need to format a date in a specific format that may not be present in the above cheatsheet. What should we do? Give up!! Never! Is that why you started your journey, to give up after coming so close to completing your task?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여기 답변을 찾을 수 있는 기사입니다. 그래서 계속해서 진행하세요!!\n\n```js\nDateTime now = DateTime.now();\nformattedDate = DateFormat('EEEE, MMM d, yyyy').format(now);\nprint(formattedDate);\n```\n\n```js\nTuesday, Jan 25, 2022\n```\n\n![이미지](/assets/img/2024-06-22-FromTimestamptoUser-FriendlyFormattingDateandTimeinFlutter_3.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n더 잘 이해하실 수 있도록 몇 가지 포인트를 설명해 드릴게요.\n\nEEEE -`은 요일의 전체 이름을 나타냅니다 (예: 월요일, 화요일..)\n\nE -`은 요일의 약어를 나타냅니다 (예: 월, 화...)\n\nMM -`는 월의 숫자를 의미합니다\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nMMM - 월 이름 약어\n\nMMMM - 전체 월 이름\n\nyy - 년도 뒷 두 자리\n\nyyyy - 년도\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n| 일련번호 | 형식 | 설명        |\n| -------- | ---- | ----------- |\n| dd       | 날짜 | 일          |\n| HH       | 시간 | 24시간 형식 |\n| hh       | 시간 | 12시간 형식 |\n| a        | 구분 | 오전/오후   |\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n어떤 특수 문자든 사용하셔도 됩니다.\n\nAryan Bisht님의 더 많은 소식\n\n# 코딩 및 개발 여정 업그레이드\n\n우리 커뮤니티의 일원이 되어 주셔서 감사합니다! 떠나시기 전에:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 👏 도움이 되셨다면 이 이야기에 박수를 치시고 작가를 팔로우해주세요 👉\n- 🔔 팔로우하세요: LinkedIn\n","ogImage":{"url":"/assets/img/2024-06-22-FromTimestamptoUser-FriendlyFormattingDateandTimeinFlutter_0.png"},"coverImage":"/assets/img/2024-06-22-FromTimestamptoUser-FriendlyFormattingDateandTimeinFlutter_0.png","tag":["Tech"],"readingTime":6},{"title":"계산기 앱 만들기  Gojek 엔지니어링 부트캠프 첫날","description":"","date":"2024-06-22 22:44","slug":"2024-06-22-CalculatorAppGojekEngineeringBootcampDayOne","content":"\n내가 Gojek Engineering Bootcamp 첫 날에 만든 프로젝트에 대해 이야기하고 싶어. 나는 Calculator 앱을 만들었어. 이 앱은 Android 개발을 위해 학생으로서 주어진 프로젝트 중 일부로, XML 레이아웃 및 Kotlin에 대해 배우는 과정의 일환이었어. 프로젝트를 완료한 지 얼마 되지 않아서, 여전히 신선한 기분이어서 여기에 대해 써 보고 싶어.\n\n![Calculator App Gojek Engineering Bootcamp Day One 0](/assets/img/2024-06-22-CalculatorAppGojekEngineeringBootcampDayOne_0.png)\n\n프로젝트를 마치기 위해, 나는 XML부터 시작했어. 여기서 ConstraintLayout을 사용했어. 이 레이아웃을 사용함으로써 Calculator 단어, 결과 상자, 숫자 입력 등을 자유롭게 배치할 수 있었어. 제목(\"Calculator\"라고 적힌 부분)에는 textStyle를 Bold로 설정한 TextView를 사용했어. 결과 상자에도 TextView를 사용했지만, 여기에는 흥미로운 점이 있어. 결과 텍스트의 글꼴이 다른 텍스트와 다르다는 것을 알 수 있어. 네, 결과 텍스트는 숫자 글꼴을 사용했어. 나는 \"download number font ttf\"라는 키워드로 구글에서 검색하여 해당 글꼴을 얻었어. ttf는 파일 형식을 나타냈어. 이 글꼴을 다운로드하고(압축 파일이었기 때문에) 추출한 다음 res.font 폴더에 넣었어.\n\n![Calculator App Gojek Engineering Bootcamp Day One 1](/assets/img/2024-06-22-CalculatorAppGojekEngineeringBootcampDayOne_1.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n결과 상자도 다소 독특합니다. 가까이 보면 상자의 텍스트가 아래 오른쪽에 배치되어 있습니다. 이것은 형식 설정 때문입니다. 형식을 지정하지 않으면 텍스트가 왼쪽 상단에 배치됩니다. 결과 상자의 코드는 다음과 같습니다.\n\n```js\n<TextView\n  android:id=\"@+id/result\"\n  android:layout_width=\"match_parent\"\n  android:layout_height=\"120dp\"\n  android:text=\"0\"\n  android:textSize=\"80dp\"\n  android:gravity=\"bottom|right\"\n  android:fontFamily=\"@font/calculator_font\"\n  android:background=\"@color/cardview_shadow_start_color\"\n  app:layout_constraintTop_toBottomOf=\"@id/title\"\n  app:layout_constraintStart_toStartOf=\"parent\"\n></TextView>\n```\n\n숫자 입력란에는 EditText를 사용했고, 연산자 버튼(더하기, 빼기 등)은 다음과 같이 제약 조건이 있는 버튼을 사용했습니다.\n\n```js\n    <Button\n        android:id=\"@+id/btnPlus\"\n        android:layout_width=\"70dp\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"+\"\n        app:layout_constraintTop_toBottomOf=\"@id/secondInput\"\n        app:layout_constraintStart_toStartOf=\"parent\">\n\n    </Button>\n\n    <Button\n        android:id=\"@+id/btnMinus\"\n        android:layout_width=\"70dp\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"-\"\n        app:layout_constraintEnd_toStartOf=\"@id/btnTimes\"\n        app:layout_constraintTop_toBottomOf=\"@id/secondInput\"\n        app:layout_constraintStart_toEndOf=\"@id/btnPlus\">\n\n    </Button>\n\n    <Button\n        android:id=\"@+id/btnTimes\"\n        android:layout_width=\"70dp\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"*\"\n        app:layout_constraintEnd_toStartOf=\"@id/btnDivide\"\n        app:layout_constraintTop_toBottomOf=\"@id/secondInput\"\n        app:layout_constraintStart_toEndOf=\"@id/btnMinus\">\n\n    </Button>\n\n    <Button\n        android:id=\"@+id/btnDivide\"\n        android:layout_width=\"70dp\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"/\"\n        app:layout_constraintTop_toBottomOf=\"@id/secondInput\"\n        app:layout_constraintStart_toEndOf=\"@id/btnTimes\"\n        app:layout_constraintEnd_toStartOf=\"@id/btnClear\">\n\n    </Button>\n\n    <Button\n        android:id=\"@+id/btnClear\"\n        android:layout_width=\"70dp\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"C\"\n        app:layout_constraintTop_toBottomOf=\"@id/secondInput\"\n        app:layout_constraintEnd_toEndOf=\"parent\"\n        android:backgroundTint=\"#FF0000\">\n    </Button>\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n좋아요, 레이아웃 작업을 마쳤으니 다음 단계로 진행해봐요. 그 전에 viewBinding을 사용하려면 build.gradle 파일에 something을 추가해야 해요.\n\n```js\n    buildFeatures {\n        viewBinding = true\n    }\n```\n\n그런 다음 MainActivity에서, 먼저 XML을 inflate하고 해당 TextView, EditText, Button과 같은 객체를 얻어와요.\n\n```js\nvar resultTv = binding.result;\nvar result: Double;\n\nvar firstInput = binding.firstInput;\nvar secondInput = binding.secondInput;\n\nvar plusButton = binding.btnPlus;\nvar minusButton = binding.btnMinus;\nvar timesButton = binding.btnTimes;\nvar divideButton = binding.btnDivide;\nvar clearButton = binding.btnClear;\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그럼 각각의 연산자에 기반한 계산을 도와주는 몇 가지 함수를 선언했습니다.\n\n```js\n    fun adding(a: Double, b : Double):Double{\n        return a + b\n    }\n\n    fun minus(a: Double, b : Double) : Double {\n        return a - b\n    }\n\n    fun times(a: Double, b : Double) : Double {\n        return a * b\n    }\n\n    fun divide(a: Double, b : Double) : Double {\n        if (b == 0.0){\n            throw IOException()\n        }\n        return a / b\n    }\n```\n\ndivide 함수를 보면, b가 영인지 여부를 확인하는 것을 볼 수 있습니다. 왜일까요? 그 이유는 b가 식 아래에있는 숫자이기 때문입니다 (나눗셈 연산에서 \"a\"를 \"b\"로 나눈 것은 a/b입니다) 그리고 우리는 0으로 a를 나눌 수 없습니다. 왜냐하면 이것은 오류를 반환할 것이기 때문입니다. 왜 오류가 발생하나요? 바로 아래 숫자가 0으로 접근하거나 b가 점점 작아질수록, 연산의 결과가 무한에 수렴하고 이것은 이 상황에서는 좋지 않습니다. 결론적으로 b가 영일 때, 이를 허용할 수 없으므로 이러한 경우를 처리하지 않으면 프로그램도 오류가 발생합니다. 그래서 b가 영인 경우마다 IOException을 throw 합니다.\n\n그 뒤에는 모든 버튼의 onClickListener를 처리합니다. 버튼이 눌릴 때마다 연산을 수행하고 싶습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n첫째로, 수학 연산에서 첫 번째 숫자나 두 번째 숫자가 0인지 확인됩니다. 둘 중 하나가 0이면 계산을 수행할 수 없습니다. 입력란이 비어있다고 0으로 간주하고 싶지 않기 때문에 이렇게 처리했습니다. 그런 다음 양쪽 숫자가 모두 null이 아닌 경우에만 연산을 계속할 수 있습니다. 이 경우에 null은 사용자가 숫자 입력란에 아무것도 넣지 않았음을 의미합니다.\n\n또한 roundToString() 함수도 있습니다. 이 함수는 무엇을 하는 걸까요?\n\n```js\n    fun Double.roundToString() = when {\n        toInt().toDouble() == this -> toInt()\n        else -> this\n    }.toString()\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nroundToString은 Double 클래스 라이브러리에 추가된 함수로, 소수점 뒤에 0이 있는 경우에만 double을 정수로 변환하는 기능을 제공합니다 (예: 0.0은 0으로 변환되고 1.2는 그대로 1.2로 유지됩니다).\n\n또한 roundOffDecimal() 함수가 있습니다.\n\n```kotlin\nfun roundOffDecimal(number: Double): Double {\n    val df = DecimalFormat(\"#.##\")\n    df.roundingMode = RoundingMode.FLOOR\n    return df.format(number).toDouble()\n}\n```\n\n이 함수는 숫자를 더 짧게 만듭니다. 예를 들어 1을 3으로 나눈 결과는 0.33333...이지만, 이 함수를 사용하면 결과가 0.33만 나오게 됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n테이블 태그를 마크다운 형식으로 변경해주세요.\n\n그리고 나누기 연산에서 IOException은 Toast를 이용해 catch했습니다.\n\n이제는 모두입니다. 이 프로젝트는 아직 초보적인 단계에 머물고 있습니다. 나중에 더 많은 기능을 추가할 예정이에요.\n\n나중에 봐요!\n","ogImage":{"url":"/assets/img/2024-06-22-CalculatorAppGojekEngineeringBootcampDayOne_0.png"},"coverImage":"/assets/img/2024-06-22-CalculatorAppGojekEngineeringBootcampDayOne_0.png","tag":["Tech"],"readingTime":8},{"title":"안드로이드에서 클린 아키텍처 구현하는 방법","description":"","date":"2024-06-22 22:42","slug":"2024-06-22-ImplementCleanArchitectureinAndroid","content":"\n![Software Architecture](/assets/img/2024-06-22-ImplementCleanArchitectureinAndroid_0.png)\n\n소프트웨어 아키텍처는 소프트웨어 작성을 위한 규칙 세트를 정의하며, 소프트웨어를 신뢰할 수 있고 확장 가능하게 구조화할 수 있도록 개발자를 지원합니다.\n\n이는 확장 가능성, 성능, 보안, 코드 축소 등과 같은 다양한 품질을 결정하고, 설계 위험을 분석하고 완화하는 데 도움이 됩니다. 소프트웨어 아키텍처는 설계 및 구현 팀을 위한 청사진 역할을 합니다.\n\n가장 널리 알려진 소프트웨어 아키텍처로는 다음이 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- MVC (Model-View-Controller)\n- MVP (Model-View-Presenter)\n- MVVM (Model-View-ViewModel)\n\n참고: MVVM 패턴은 시작하기에 좋지만 코드 복잡성이 증가할수록, 코드베이스 요구에 맞게 복잡성을 다룰 수있는 더 강력한 아키텍처가 필요합니다.\n\n이때 Clean Architecture가 등장합니다!\n\n# Clean Architecture\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nClean Architecture은 주로 관심사 분리에 초점을 맞춥니다. Clean Architecture를 따를 때 레이어의 수가 명시되어 있지는 않습니다. 필요에 따라 레이어를 추가할 수 있습니다. 원칙은 내부 레이어가 외부 레이어 중 어느 것도 참조해서는 안 되며, 중앙쪽으로 갈수록 세부 사항은 추상화되어야 합니다.\n\n상기 이미지에서 외부 레이어는 세부 구현을 포함하고 있으며, 내부 레이어는 추상화에 초점을 둡니다. 이 접근 방식은 비즈니스 레이어를 개발 중에 사용하는 실제 도구의 저수준 종속성으로부터 분리합니다.\n\n소프트웨어는 개발 도구(사용하는 하드웨어 및 데이터베이스 유형)를 변경해도 비즈니스 로직을 정의하는 코드에 영향을 미치지 않아야 합니다. Clean Architecture는 이러한 일반적인 아이디어에 기반합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n클린 아키텍처 레이어를 구면으로 상상해볼 수 있습니다. 중심으로 갈수록 희미해지죠. 중심에는 특정 작업이 어떻게 처리되는지에 대한 구체적인 세부 정보가 없습니다. 소프트웨어가 따라야 하는 규칙/정책을 정의하기만 합니다 (이것이 소프트웨어의 비즈니스 로직입니다).\n\n클린 아키텍처 책의 아래 댓글이 이 전체 포인트를 잘 요약하고 있습니다.\n\n## 의존성 규칙\n\n## 엔티티\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n각 요소들은 클래스, 객체, 데이터 구조 또는 결합을 통해 설명할 수 있는 업무 규칙입니다. 외부 레벨 세부사항(예: 작업 흐름)에 변화가 발생할 때, 이러한 규칙들이 가장 변경될 가능성이 적습니다.\n\n## 사용 사례\n\n사용 사례에는 응용 프로그램별 업무 규칙이 포함됩니다. 이러한 규칙들은 엔티티 레이어의 비즈니스 규칙을 응용프로그램별 운영 규칙으로 전환하는 데 도움을 줍니다.\n\n## 인터페이스 어댑터\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 레이어는 사용 사례의 데이터를 GUI 프레임워크, 웹 사용자 인터페이스 등과 같은 프레임워크 레이어에 사용할 수 있도록 변환합니다.\n\n## 프레임워크 및 드라이버\n\n일반적으로 이 레이어에서는 주로 사용된 프레임워크 및 데이터베이스의 가장 외부의 상세 구현으로 코드를 작성할 필요가 없습니다.\n이 레이어에는 대부분 내부 레이어에서의 코드를 연결하는 코드가 포함되어 있으며, 데이터를 가져오고 표현을 위해 변환하는 방법을 정의합니다.\n\n## 클린 아키텍처의 장점\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 시스템 변경을 쉽게합니다.\n- 비즈니스 로직은 코드베이스의 다른 레이어와 완전히 분리되어 있으며, 다른 레이어는 비즈니스 규칙에 의존하므로 시스템에 기능을 추가/업데이트하기 쉬워집니다.\n- 코드는 디커플링되어 각 레이어를 블랙 박스로 다룰 수 있어 코드 테스트에 도움이 됩니다.\n- 각 모듈은 세부 사항이 아닌 목적을 정의합니다. 이는 기술적 세부 사항에 심취하지 않고 앱이 무엇을 하는지 이해하는 데 도움이 됩니다.\n\n## Clean Architecture의 단점\n\n- 단순 프로젝트에는 선호되지 않습니다. 프로젝트가 복잡하지 않다면, 단순한 아키텍처(MVC 또는 순수 MVVM)로 달성할 수 있는 파일을 불필요하게 만들고 코드를 작성하게 됩니다.\n- 학습 곡선이 가파릅니다.\n- 책임을 적절한 레이어로 나누는 방법을 이해하는 것은 이 아키텍처에서 각 레이어가 어떻게 작동하는지 명확한 개념이 없다면 지루할 수 있습니다.\n\n# Clean Architecture으로 안드로이드 개발하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n안녕하세요! 안드로이드 플랫폼에서 간단한 TODO 앱을 클린 아키텍처로 만들었어요. 완성된 코드는 GitHub에서 확인할 수 있어요.\n\nTODO 앱을 클린 아키텍처로 만드는 것은 아키텍처의 모든 측면을 다루는 것은 아니라는 점을 유의해 주세요.\n\n기본 구현을 이해하고 더 복잡한 기능으로 나아가는 것이 중요한 포인트에요.\n\n이 방법으로 사용된 레이어 구조는 다음과 같아요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/assets/img/2024-06-22-ImplementCleanArchitectureinAndroid_2.png)\n\n동일한 계층 구조가 디렉토리 구조에 반영됩니다.\n\n계층 구조는 구현에 따라 다를 수 있습니다. 그러나 코드 베이스를 구성할 때는 누가 누구에게 의존하는지에 중점을 두어야 합니다.\n\n코드 구조에 복잡성과 차이점을 고려하여 레이어를 추가할 수 있습니다. Clean Architecture에는 몇 개의 레이어가 있어야 하는지에 대한 엄격한 규칙은 없습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n마크다운 포맷으로 표 태그를 변경하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n도메인 계층은 응용 프로그램/모듈 개념을 설명하는 핵심 엔티티로 구성됩니다. 이러한 엔티티는 외부 계층과 독립적이며 외부 계층(데이터, 유스 케이스 등)에서 언급해서는 안됩니다.\n\n여기에는 작업(Task)이라는 기본 작업과 해당 속성을 정의하는 엔티티가 있습니다.\n\n## 데이터\n\n이 계층은 데이터와의 상호 작용을 정의합니다. 데이터 작업을 정의하기 위해 TaskDataSource를 사용합니다. 그런 다음 여러 데이터 소스를 하나의 리포로 결합하고 리포지토리를 통해 데이터에 액세스하도록 TaskRepository를 정의했습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여기서는 단일 데이터 원본만 사용합니다. 기본적으로 TaskDataSource와 TaskRepository 메소드와 일대일 매핑되어 있어 처음봤을 때는 중복된 것처럼 보일 수 있습니다. 그러나 애플리케이션이 확장되고 인터넷에서 데이터를 다운로드하거나 로컬 데이터베이스 또는 사용자 파일에 저장된 데이터와 같이 여러 위치에서 데이터 소스를 가질 때 리포지토리 패턴이 유용할 수 있습니다.\n\nTaskRepository는 아래에서 논의된 유스케이스에서 사용되고 있습니다.\n\n## 유스케이스\n\n이 계층은 데이터를 처리할 수 있는 작업을 정의하고 사용 사례를 형성합니다. 프레젠테이션 계층은 직접 이러한 유스케이스를 사용하여 데이터를 표시하거나 조작합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n해당 데이터에 대해 다양한 작업을 수행하기 위해 정의된 사용 사례들이 있습니다:\n\n![Use Cases](/assets/img/2024-06-22-ImplementCleanArchitectureinAndroid_5.png)\n\n## 프레임워크\n\n이 레이어는 데이터 레이어에서 정의된 데이터 소스를 구현하고 플랫폼별 구현을 제공합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저희 구현에서는 TaskDataSourceImpl을 통해 Room 데이터베이스를 사용하여 TaskDataSource를 구현했습니다.\n\n## 프레젠테이션\n\n이 계층은 코드에서 표시 로직을 정의하고 플랫폼별 뷰가 데이터를 사용자에게 제시하는 방식을 정의합니다. 여기에는 사용 사례 계층에 정의된 사용 사례를 호출하고 안드로이드 뷰를 사용하여 그것들을 사용자에게 제시하는 뷰 모델이 있습니다.\n\n그게 다입니다!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 마무리\n\n안드로이드 개발에서 Clean Architecture의 개념과 구현 방법에 대해 명확해졌기를 바라요.\n\nGitHub에서 샘플 TODO 앱의 전체 코드를 찾을 수 있어요. 코드 구조에 대한 제안이 있으면 PR을 제출해주세요. 기여해 주실 것을 환영합니다.\n\n즐거운 코딩 되세요!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n참고문헌\n","ogImage":{"url":"/assets/img/2024-06-22-ImplementCleanArchitectureinAndroid_0.png"},"coverImage":"/assets/img/2024-06-22-ImplementCleanArchitectureinAndroid_0.png","tag":["Tech"],"readingTime":9},{"title":"안드로이드에서 커스텀 애노테이션을 사용해야 할 때 Part 3","description":"","date":"2024-06-22 22:41","slug":"2024-06-22-WhentoUseCustomAnnotationsinAndroidPart3","content":"\n![이미지](/assets/img/2024-06-22-WhentoUseCustomAnnotationsinAndroidPart3_0.png)\n\n친구야! 안드로이드에서 사용자 정의 주석을 더 멋지고 고급스럽게 활용해보자. 커피 한 잔 마시면서 아이디어를 얘기하는 것처럼 재미있는 예제로 안내해 드릴게요.\n\n# 4. 자동화된 문서화\n\n만약 코드가 스스로 문서를 작성할 수 있다면 어떨까요! 주석이 그렇게 도와줄 수 있어요. 메서드가 무엇을 하는지 설명하는 주석을 만들고 해당 주석을 사용하여 문서를 생성해보세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n먼저, 우리는 주석을 정의합니다:\n\n```kotlin\n@Target(AnnotationTarget.FUNCTION)\n@Retention(AnnotationRetention.RUNTIME)\nannotation class Doc(val description: String)\n```\n\n그런 다음, 이 주석을 우리의 클래스에서 사용합니다:\n\n```kotlin\nclass DocumentedClass {\n\n    @Doc(description = \"이 메서드는 무거운 계산을 수행합니다.\")\n    fun heavyComputation() {\n        Thread.sleep(1000)\n        println(\"무거운 계산 완료!\")\n    }\n\n    @Doc(description = \"이 메서드는 가벼운 계산을 수행합니다.\")\n    fun lightComputation() {\n        Thread.sleep(500)\n        println(\"가벼운 계산 완료!\")\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제, 이러한 주석을 기반으로 문서를 생성하는 프로세서를 만들어 봅시다:\n\n```js\nobject DocumentationGenerator {\n\n    fun generateDocumentation(obj: Any) {\n        val methods = obj::class.java.declaredMethods\n        for (method in methods) {\n            method.getAnnotation(Doc::class.java)?.let {\n                println(\"${method.name}: ${it.description}\")\n            }\n        }\n    }\n}\n\nfun main() {\n    val documentedClass = DocumentedClass()\n    DocumentationGenerator.generateDocumentation(documentedClass)\n}\n```\n\n이 코드를 실행하면, 주석이 달린 메소드의 설명을 출력합니다. 와우! 자동화된 문서를 얻었습니다.\n\n# 5. 런타임 처리\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n앱에서 기능을 동적으로 전환하고 싶다면 사용자 지정 주석을 활용하여 쉽게 관리할 수 있습니다.\n\n기능 토글을 위한 주석을 정의하세요:\n\n```kotlin\n@Target(AnnotationTarget.FUNCTION)\n@Retention(AnnotationRetention.RUNTIME)\nannotation class FeatureToggle(val featureName: String)\n```\n\n이를 클래스 내에서 사용하여 메서드를 표시하세요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\nclass FeatureClass {\n\n    @FeatureToggle(\"FeatureA\")\n    fun featureAMethod() {\n        println(\"Feature A is enabled!\")\n    }\n\n    @FeatureToggle(\"FeatureB\")\n    fun featureBMethod() {\n        println(\"Feature B is enabled!\")\n    }\n}\n```\n\n이러한 주석을 처리하는 프로세서를 생성합니다:\n\n```kotlin\nobject FeatureToggleProcessor {\n\n    private val enabledFeatures = setOf(\"FeatureA\")\n\n    fun processFeatures(obj: Any) {\n        val methods = obj::class.java.declaredMethods\n        for (method in methods) {\n            method.getAnnotation(FeatureToggle::class.java)?.let {\n                if (enabledFeatures.contains(it.featureName)) {\n                    method.invoke(obj)\n                } else {\n                    println(\"Feature ${it.featureName} is disabled\")\n                }\n            }\n        }\n    }\n}\n\nfun main() {\n    val featureClass = FeatureClass()\n    FeatureToggleProcessor.processFeatures(featureClass)\n}\n```\n\n이 설정으로 핵심 로직을 수정하지 않고 기능을 동적으로 활성화 또는 비활성화할 수 있습니다. 멋지지 않나요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 6. 다양한 사용 사례 다루기\n\n사용자 지정 어노테이션은 응용 프로그램에서 권한 및 역할을 처리하는 데도 효과적입니다. 역할 기반 액세스 제어를 위한 어노테이션을 만들어 보겠습니다.\n\n어노테이션 정의:\n\n```js\n@Target(AnnotationTarget.FUNCTION)\n@Retention(AnnotationRetention.RUNTIME)\nannotation class RequiresRole(val role: String)\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n필요한 역할에 주석을 달아주세요:\n\n```js\nclass RoleClass {\n\n    @RequiresRole(\"Admin\")\n    fun adminTask() {\n        println(\"Admin task executed!\")\n    }\n\n    @RequiresRole(\"User\")\n    fun userTask() {\n        println(\"User task executed!\")\n    }\n}\n```\n\n권한을 확인하는 역할 프로세서를 생성해보세요:\n\n```js\nobject RoleProcessor {\n\n    private val currentRole = \"Admin\"\n\n    fun processRoles(obj: Any) {\n        val methods = obj::class.java.declaredMethods\n        for (method in methods) {\n            method.getAnnotation(RequiresRole::class.java)?.let {\n                if (currentRole == it.role) {\n                    method.invoke(obj)\n                } else {\n                    println(\"Access denied for ${it.role}\")\n                }\n            }\n        }\n    }\n}\n\nfun main() {\n    val roleClass = RoleClass()\n    RoleProcessor.processRoles(roleClass)\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 사용자가 올바른 역할을 가지고 있을 때만 귀하의 메서드가 실행됩니다. 더 이상 코드 전체에 흩어진 역할 확인 코드가 없습니다!\n\n# 마무리\n\n자, 안드로이드에서 커스텀 어노테이션에 대한 고급이면서도 매우 유용한 케이스들을 다뤘습니다. 자동 문서화 생성 및 런타임에서의 기능 토글부터 역할 기반 액세스 관리까지, 커스텀 어노테이션을 사용하면 코드가 더 깔끔하고 유지보수하기 쉬우며 더 재미있게 작업할 수 있습니다.\n\n더 궁금한 사항이 있거나 다른 멋진 주제에 대해 알아보고 싶다면 언제든지 말씀해주세요. 즐거운 코딩 하시고, 계속해서 어노테이션을 즐기세요! 😊\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n4를 어떻게 도와드릴까요?\n","ogImage":{"url":"/assets/img/2024-06-22-WhentoUseCustomAnnotationsinAndroidPart3_0.png"},"coverImage":"/assets/img/2024-06-22-WhentoUseCustomAnnotationsinAndroidPart3_0.png","tag":["Tech"],"readingTime":7}],"page":"32","totalPageCount":119,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true}