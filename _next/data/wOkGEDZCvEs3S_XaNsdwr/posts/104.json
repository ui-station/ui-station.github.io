{"pageProps":{"posts":[{"title":"악성 소프트웨어 회고 PrjRAPTOR","description":"","date":"2024-05-18 17:43","slug":"2024-05-18-AMalwareretrospectivePrjRAPTOR","content":"\n# 서문\n\n![이미지](/assets/img/2024-05-18-AMalwareretrospectivePrjRAPTOR_0.png)\n\n이전 \"악성 코드 회고\" 시리즈에서는 90년대 후반과 2000년대 초에 가장 잘 알려진 트로이 목마 두 가지 이야기를 탐구했습니다. 말머리/정보보안 열성가들이 새내기든 베테랑이든 관련 트로이 목마인 SubSeven 또는 Beast에 대해 들어봤을 수도 있는데요.\n\n이제 \"악성 코드 회고\" 시리즈에서 처음 소개하는 \"PrjRAPTOR\"라는 잘 알려지지 않은 원격 액세스 트로이 목마 이야기를 파헤쳐보겠습니다. 이 트로이 목마는 2008년과 2009년 사이에 인기를 얻었으며, 그 때는 트로이 목마 씬의 황금 시대가 끝나는 시기였습니다. 당시에는 사이버 범죄자들에 의해 이러한 프로그램이 기술적 스킬 및 진정한 열정의 표현이 아닌 이윤 추구 기업으로 전락하기 전의 시기였습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nPrjRAPTOR의 이야기를 간략하게 살펴보겠습니다. 이 Remote Access Trojan은 독특한 인터페이스로 큰 반향을 일으켰죠. 작성자 \"Ryan\"과의 독점 인터뷰를 통해 Trojan의 개발과 영향에 대한 소중한 통찰을 얻을 수 있었습니다.\n\nRyan에 대한 질문에 답변해주시고 중요한 부분을 명확히 해 주셔서 진심으로 감사드립니다. 모던 악성 소프트웨어의 기초를 마련한 과거 씬 구성원들과 연결하는 것은 항상 보람 있는 경험이죠.\n\nPrjRAPTOR의 깨끗하고 작동하는 사본을 찾는 것은 상당한 도전이었어요. 그 당시의 다른 최상위 악성 소프트웨어만큼은 널리 인정받지 못했기 때문이죠. 몇몇 웹사이트들이 다운로드를 제공했지만 대부분이 10년 이상 지나면서 오프라인 상태입니다. Ryan에게 깨끗한 사본이 남아 있는지 물었지만, 그는 프로젝트의 모든 흔적을 잃어버렸다고 말했죠. 그는 이 실험적인 프로젝트로 프로그래밍을 배웠던 과거의 자신이 몇 년 후에도 누군가가 그것을 논의하고 있다는 것에 놀랐습니다. 이러한 호기심 기반의 코딩 접근은 당시의 악성 소프트웨어 개발자들 사이에서 일반적이었으며, 현재의 악성 소프트웨어가 되어가는 방향을 결정했습니다.\n\n# PrjRAPTOR: 잊혀진 트로이 목록의 이야기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![2024-05-18-AMalwareretrospectivePrjRAPTOR_1](/assets/img/2024-05-18-AMalwareretrospectivePrjRAPTOR_1.png)\n\n이 Remote Access Trojan (RAT)의 주인공인 \"Ryan\"이 자신의 산물에 대한 시작, 발전 및 유산을 공유합니다. 그 피크 시절의 사이버 도구들에 익숙한 사람들에게는 PrjRAPTOR을 소개할 필요가 없습니다. 초보자를 위해, 여기 창조자로부터 직접 들은 PrjRAPTOR의 여정에 대한 포괄적인 탐험이 제공됩니다.\n\n미국에서 태어난 Ryan은 2007-2008년 경에 PrjRAPTOR 개발이라는 야심찬 여정을 시작한 때 단 13세였습니다. 해킹 도구의 광범위한 세계와 해커 주변의 신비로운 분위기에 흥미를 느낀 Ryan은 영화에서 볼 수 있는 \"해커-인간\" 캐릭터의 신비를 해체하고자 했으나 결국 프로그래밍 세계에 깊이 빠지게 되었습니다.\n\n그는 \"사람들이 아이디어를 교환하고 설명서를 작성하고 자신의 작업물을 공유하는 멋진 온라인 포럼을 발견했습니다.\" PrjRAPTOR이라는 이름은 암호적으로 보일 수 있지만, 그 기원은 사랑스럽게 간단합니다. 이것은 Ryan이 VB 테스트 프로젝트에 \"prj\"를 접두어로 붙이는 습관과 13세 때 공룡에 대한 매료로부터 탄생한 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n악성 소프트웨어와 그 매혹적인 세계가 라이언을 끌어들였어요. 그는 이를 기술적 능력의 정점으로 상상했고, 프로그래머들이 \"규칙을 어기는\" 곳으로 봤어요. 간단한 vbscript 파일부터 시작하여 라이언은 천천히 VB5, 그리고 VB6로 넘어가며 프로그래밍과 악성 소프트웨어 개발의 복잡성을 발견했어요.\n\n![이미지](/assets/img/2024-05-18-AMalwareretrospectivePrjRAPTOR_2.png)\n\n이 기사 시리즈에서 이전에 Delphi를 사용하여 생성된 악성 코드를 다루었었는데, 이는 트로이 목마나 RAT 개발자들 사이에서 인기 있는 선택이었어요. VB6는 이 같은 악성 코드 범주에서 아마 두 번째로 많이 사용된 프로그래밍 언어였습니다. Delphi와 유사하게, VB6의 핵심 장점은 복잡한 코드 없이 풍부한 사용자 인터페이스를 만들기 쉬웠다는 것이었어요. 그러나 VB6는 심지어 초보자에게 더욱 친숙했기 때문에, 악성 코드 개발 초보자에게 이상적인 선택이었죠. VB6는 Delphi와 비교하여 기능이 제한적이었지만, MoSucker, CIA, LostDoor와 같이 혁신적인 기능과 정교한 디자인을 자랑하는 여러 악성 코드 유형이 높은 평가를 받았어요. 악성 코드 분야에서 VB6의 중요성을 과소평가해서는 안 돼요.\n\nPrjRAPTOR를 구축하는 일은 쉬운 작업이 아니었어요. 라이언은 \"그것을 만드는 데 몇 년이 걸렸어요... 거의 0의 프로그래밍 경험이나 지식으로 시작했죠.\" VB6의 GUI 편집기, 이벤트 시스템, 객체 지향 기능 등을 이해하는 등의 과제를 해결하면서, 라이언은 끈질기게 RAT을 기능적이고 견고하게 만들기 위해 노력했어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n라이언은 ProRAT, Optix, SubSeven, PoisonIvy 및 Daemon Crypt와 같은 도구들을 영감의 근원으로 인용합니다. 그는 다양한 도구들의 기능을 세심하게 테스트하고 관찰하여, 기존의 것을 바탕으로 학습하고 수정함으로써 자신만의 것을 개발해나갔습니다. 특히 ProRAT은 그에게 기본적인 학습 도구 역할을 했습니다.\n\n<img src=\"/assets/img/2024-05-18-AMalwareretrospectivePrjRAPTOR_3.png\" />\n\n악성 소프트웨어 커뮤니티에 깊숙이 몰두하고 있었음에도 불구하고, 라이언은 깊은 관계를 맺지 않았습니다. 그는 적극적인 회원들을 기억하며 관찰을 통해 배웠지만, 도전에는 스스로 맞서기를 선호했습니다. 이전에 혼자서 문제에 직면하거나 팀의 일원으로서 선택을 할 때라도, 이러한 프로그램을 개발하는 주된 동기는 항상 악성 소프트웨어 작성자가 마주치게 될 다양한 도전을 극복하고 얻는 만족감이었습니다.\n\n많은 열정적인 프로젝트와 마찬가지로, PrjRAPTOR는 라이언이 고등학교 시절을 포함해 다른 관심사를 추구하기로 결정한 시점에 끝을 맺었습니다. 현재 프로젝트를 재방문하는 가능성에 대해 논의할 때, 라이언은 기술과 사이버보안 분야의 발전을 고려할 때, 재구축이 더 적절할 것으로 믿습니다. 자신의 여정을 되돌아보며 그는 말했습니다. “현재의 시대에 프로젝트를 재도전한다면 많은 이유로 완전히 재구축할 필요가 있을 것입니다. 먼저, 오늘날 PrjRAPTOR와 같은 도구를 만드는 것은 오픈 소스가 될 때 크게 이로울 것이라고 말하고 싶습니다.” 유감을 표현하며 그는 계속 말했습니다. “그것이 프로젝트에서 변화에 관한 가장 확실한 것일 것입니다. 그때 그렇게 했어야 했는데 오픈 소스 소프트웨어에 대해서는 아무 것도 몰랐습니다. 사람들이 내 실수를 볼 수 있게 했다면 많은 것을 배웠을 텐데.” 그는 이러한 도구를 오픈 소스로 공개하는 가치를 강조하며, 그 당시 PrjRAPTOR를 오픈 소스로 공개하지 않았다는 점을 깊이 후회하고 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n프로젝트 랩터의 극복 이후, 저자는 다음과 같이 공유했습니다. \"저는 많은 프로젝트를 해왔어요. 그 중에는 보안 쪽에 더 많이 치우친 몇 가지 작은 노력이 있긴 하지만, 악성 소프트웨어와는 관련이 없죠.\" 그리고 그는 자신의 전문적인 관심사의 발전에 대해 더 자세히 설명했습니다. \"일반 프로그래밍에 집중하기보다는 악성 소프트웨어에만 초점을 맞출 때보다 훨씬 매력적이라는 것을 금방 깨달았어요.\" 소프트웨어 개발의 다양한 분야를 탐험하면서, 그의 기본적인 경험들이 여전히 그를 안내해왔습니다. \"프로젝트를 설계할 때 오래된 해킹 도구들에서 영감을 받는 느낌이 여전히 강해요. 사용하기 쉽고, 마법처럼 보이는 프로세스를 자동화하는 도구를 가지고 있었을 때의 그 느낌을 기억해요.\"\n\n# 프로젝트 랩터 기능에 대한 간단한 소개\n\n프로젝트 랩터 컨트롤러를 처음 열면, 13세 소년의 상상력이 가시적으로 드러납니다. 디자인은 생생하고 다채롭며, 랩터들이 눈에 띄게 등장합니다. 청소년 시절의 실험적인 기발함이 느껴지지만, 디자인 선택은 때로 방해적일 수 있습니다. 어두운 색상의 창이 있어서 내비게이션을 조금 어렵게 만들기도 하고, 다른 창은 굉장히 밝을 수도 있습니다. 이는 창조적인 노력을 통해 길을 찾아가는 젊은 프로그래머의 시행착오 정신을 대변하는 것입니다.\n\n<img src=\"/assets/img/2024-05-18-AMalwareretrospectivePrjRAPTOR_4.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nPrjRAPTOR은 다른 RAT들과 비교했을 때 일부 기능이 부족한 것이 눈에 띄며, 프로젝트가 아직 완성되지 않았음을 명확히 보여줍니다. 저자의 다른 업무들이 개발보다 우선시되는 모습이 보입니다. 그럼에도 불구하고, 이 프로그램은 여전히 인상적이며, 특히 젊은 창조자의 나이를 고려할 때 더욱 그렇습니다.\n\nPrjRAPTOR에는 아이코닉한 원격 파일 관리자가 포함되어 있습니다. 감염된 기기의 파일 시스템을 완전히 제어할 수 있는 강력한 기능으로, 파일 다운로드 및 업로드, 파일 무결성 변경과 같은 작업을 가능케 합니다. 본질적으로 이 기능은 원격 시스템을 일종의 FTP 서버로 변환시키며, 위협 요소가 추가 페이로드를 업로드하고 실행하는 데 자주 사용됩니다.\n\nPrjRAPTOR의 또 다른 강력한 기능은 Keylogger로, 피해자의 키보드 활동을 모니터링하기 위해 특별히 설계되었습니다. 이 기본적으로 위험한 기능은 공격자가 웹사이트나 애플리케이션의 비밀번호 등 민감한 정보를 캡처할 수 있도록 합니다. 전략적으로 활용할 때 이 기능은 피벗팅이나 권한 상승과 같은 작업을 위한 이상적인 도구로 기능합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n프로세스 및 창 관리자, 클립보드 제어와 같이 시스템 지향적인 몇 가지 기능을 제외하고 PrjRAPTOR는 주로 혁신적이고 재치 있는 기능들을 포함하고 있습니다. 이는 지난 시대의 유사한 프로그램의 실천을 반영하며, 프로젝트 뒤에 어린 개발자의 나이에 대한 또 다른 지표로 작용합니다.\n\n![이미지](/assets/img/2024-05-18-AMalwareretrospectivePrjRAPTOR_6.png)\n\n마지막으로, 웹캠이나 데스크톱 캡처와 같은 기능이 프로젝트에 부족한 것을 보는 것은 놀랍습니다. 이러한 특정 기능이 부재한 이유는 프로그램이 완성되지 않았기 때문입니다. 어쨌든, 다른 어린이들처럼 비디오 게임을 하는 대신 13살 소년이 무엇을 달성할 수 있었는지 보는 것은 인상적입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 결론\n\n많은 다른 사람들과 마찬가지로 나를 포함한 사람들은 라이언이 처음부터 그러한 창의적인 프로그램이 개발된 이유를 보여줍니다. 순수하게 이윤을 추구하는 것이 아닌, 이러한 창작물은 여러 분야에서 강력한 기반을 형성하는 데 초점을 맞췄습니다. 원격 액세스 트로이목마(Remote Access Trojan, RAT)를 만들 때는 특히 도전적이었는데, 자원이 부족한 초기 시기에는 더욱 그랬습니다. 악성 코드 작성자들은 창의적이고 끈기 있는 것을 선택해야 했습니다. RAT는 프로그래밍의 다양한 측면에 관여하므로 사용자 인터페이스 디자인부터 시스템 수준 코딩, 운영 체제, API 및 네트워킹에 대한 이해가 필요했습니다.\n\n현재 RAT들(그리고 그들의 현대적인 상대인 C2들)은 비교적 보편적이지만, 여전히 검출을 회피하는 데 중점을 둔 다른 형태의 도전이 존재합니다. 그럼에도 불구하고, 지난 10년 이상 전과 비교하면 환경은 상당히 변했습니다. 그러나 RAT를 만드는 것은 여전히 순위를 빠르게 올라가고 숙련된 프로그래머가 되는 가장 좋은 방법 중 하나입니다.\n\n# 악성 소프트웨어 갤러리에 대한 한 마디\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n기사 끝에 기회가 되어 이렇게 소개하고 싶은데요. “악성 코드 갤러리”라는 저의 장기 프로젝트에 대해 소개하겠습니다. 본 박물관은 특히 1990년대 후반부터 현재까지 영향을 미친 원격 액세스 트로이 목마들을 중심으로 하고 있습니다. 이 프로젝트의 목표는 저와 같은 베테랑들이 우리에게 영향을 미친 기술적 보물들을 회상할 수 있도록 하는 것입니다. 저에게는 인터넷 초기 시절을 성장하며 이러한 선구적 프로그램들과 직접적인 경험이 있었고, 이들의 창조자들과도 만날 수 있었던 운이 좋았습니다. 이 프로젝트의 목표는 제 기억을 펼치고 새로운 연구를 수행하며, 이전의 유물들에 대한 포괄적인 정보와 이미지를 점진적으로 발표하는 것입니다.\n\n이는 15년 미만의 경력을 가진 신입사원들을 위한 중요한 자료이기도 합니다. 학술 강좌나 교육 과정을 통해 만나보기 힘든 프로그램들을 알아볼 수 있는 소중한 자료입니다. 특히, 옛날의 악성 코드들은 저의 진정한 열정 중 하나로, 언제나 공유하고 싶어하는 분야입니다. 저의 말을 빌리자면, 자신의 재능을 이해하려면 그 역사를 이해해야 합니다.\n\n데이터베이스는 점진적이면서도 꾸준하게 성장할 것입니다; 이것은 온전한 노력과 철저한 연구를 요구하는 장기 프로젝트입니다. 이미 기록되지 않은 특정 악성 코드 패밀리가 귀하에게 강한 인상을 주었고 아직 소개되지 않았다면, 언제든지 연락해주세요. 해당 내용을 추가하는 것을 우선시할 것입니다. 미리 피드백 주셔서 감사합니다.\n\nLois가 제공한 이미지/배너도 포함돼 있습니다.\n","ogImage":{"url":"/assets/img/2024-05-18-AMalwareretrospectivePrjRAPTOR_0.png"},"coverImage":"/assets/img/2024-05-18-AMalwareretrospectivePrjRAPTOR_0.png","tag":["Tech"],"readingTime":10},{"title":"윈도우 프로세스 여정  MoUsoCoreWorkerexe MoUSO 코어 워커 프로세스","description":"","date":"2024-05-18 17:42","slug":"2024-05-18-TheWindowsProcessJourneyMoUsoCoreWorkerexeMoUSOCoreWorkerProcess","content":"\n“MoUsoCoreWorker.exe”는 Windows 업데이트를 수행하는 책임이 있는 실행 파일입니다. 이 파일은 \"wuauclt.exe\"에 의해 수행되는 일부 작업을 대체하며, Windows 10/11 환경 업데이트를 지원합니다. 이 파일은 “통합 업데이트 플랫폼” 또는 UUP로 이동함에 따라 이러한 업데이트를 수행합니다.\n\n따라서 Windows 10이 출시되면서 Microsoft는 UUP로 이동하여 모든 유형의 OS 업데이트(월간 및 새로운 기능 업데이트)를 대상으로 하는 클라이언트 장치에 대한 단일 발행, 호스팅, 스캔 및 다운로드를 허용합니다.\n\n또한, 해당 실행 파일은 “%windir%\\System32\\MoUsoCoreWorker.exe”에 위치해 있습니다. 64비트 시스템에서는 64비트 버전만 있으며 32비트 버전은 없습니다. 이 파일은 “svchost.exe”에 의해 시작되며 “로컬 시스템”의 권한으로 실행됩니다.\n\n그리고, USO는 “Update Session Orchestrator”의 약자입니다. “MoUsoCoreWorker.exe”는 Windows에서 업데이트를 다운로드하고 설치하는 순서를 제어하는 중요한 구성 요소입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n마지막으로, Windows가 업데이트를 찾을 때마다 \"MoUsoCoreWorker.exe\"가 시작됩니다. 해당 내용은 아래 스크린샷에서 확인할 수 있습니다. 해당 스크린샷은 Sysinternals의 ProcMon을 사용하여 촬영되었고, \"업데이트 확인\" 버튼을 누른 후에 촬영되었습니다. 우리는 \"usoapi.dll\"(업데이트 세션 오케스트레이터 API)가 \"SystemSettings.exe\"에 의해 로드되고, 그 후에 \"MoUsoCoreWorker.exe\"가 \"svchost.exe\"에 의해 시작되는 것을 볼 수 있습니다.\n\n다음 글에서 다시 만나요 ;-) 제 트위터 계정을 팔로우할 수 있습니다 - @boutnaru. 또한, 다른 글은 중에서 읽어볼 수 있습니다 - https://medium.com/@boutnaru. 무료 eBook은 https://TheLearningJourneyEbooks.com에서 확인할 수 있습니다.\n\n![이미지](/assets/img/2024-05-18-TheWindowsProcessJourneyMoUsoCoreWorkerexeMoUSOCoreWorkerProcess_0.png)\n","ogImage":{"url":"/assets/img/2024-05-18-TheWindowsProcessJourneyMoUsoCoreWorkerexeMoUSOCoreWorkerProcess_0.png"},"coverImage":"/assets/img/2024-05-18-TheWindowsProcessJourneyMoUsoCoreWorkerexeMoUSOCoreWorkerProcess_0.png","tag":["Tech"],"readingTime":2},{"title":"Mac 장치에서 10년 이상의 macOS 지원을 볼 수 있을까요","description":"","date":"2024-05-18 17:41","slug":"2024-05-18-AreWeAboutToSeeDecadeMacOSSupportForMacs","content":"\n2020년은 좋은 해였다. 그 말을 취소하겠다. 2020년은 많은 면에서 형편없는 해였다. 모두 잊고 싶어하는 전 세계적 재앙이었다. 하지만 몇몇 사람들에게는 그 해를 조금 더 나은 해로 만드는 무언가가 있었고, 그것이 바로 Apple Silicon이었다. 개인 컴퓨팅의 방향을 근본적으로 바꿔놓은 것으로 여겨지는 구세주다. 이것은 전체 산업이 주목하고 Apple의 발자취를 따르는 가치가 있다고 결론지었다. 그러나 하드웨어의 이번 변화는 무언가를 열어주었고, 그것은 이제는 가능성이 희박했던 것이라고 할 수 있는 장기적인 소프트웨어 지원이다.\n\n현재로서 macOS 소노마는 2018년에 출시된 맥을 지원한다. 나쁘지 않다. 어떤 사람들은 6년이라고 말할지도 모르지만, 그것은 어떤 사람들이 기계를 보관하거나 리퍼비시하여 사용할 때를 고려하지 않은 것이다. 그때에 여러분은 많은 맥북들이 약 10년 이상 사용될 것으로 추측할 수 있다. 나는 처음으로 판매한 15인치 레티나 맥북 프로를 팔 때, 그것은 8년 된 기계였지만, 최신 macOS 버전을 실행하는 능력이 여전히 있었다. 따라서 6년의 지원은 충분하지 않다고 주장할 수 있을 것이다.\n\n그러나 현재 이것이 그럴 수 있는 이유가 있음: 인텔. Apple은 명시적으로 말하지는 않지만, 2020년 이후 많은 사람들이 유추한 것처럼 인텔 맥은 본질적으로 버려진 제품이며, Apple이 현재 인텔 기계에 제공하는 macOS 지원은 고객들을 유지하면서, 아마도 변호사들도 만족시키려는 최소한의 지원만 제공할 뿐이다. 소프트웨어 엔지니어로서, 여러 아키텍처, 브라우저, 운영 시스템 등을 지원하는 것이 얼마나 문제가 되고 비용이 많이 드는지 잘 알고 있다. 그래서 macOS 소노마의 일부 기능이 이미 인텔 기계에서 지원되지 않음에도 불구하고 이해할 수 있다.\n\n그리고 시간이 흐를수록 이것은 더 나빠질 것으로 생각된다. Apple은 기술적으로 2024년 최초로 인텔 기계 지원을 완전히 중단할 수 있으며, 하위 Mac 제품에 합리적인 가격 및 교체 프로그램이 있기 때문에 2019년 인텔 기계를 보유하고 있는 모든 사람은 최신 macOS를 원한다면 그냥 Apple Silicon으로 넘어가야 한다고 주장할 수 있다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그런데 물론 Mac Pro가 있죠, 이 부분이 좀 복잡해요. Apple은 2023년에만 Apple 실리콘 Mac Pro를 출시했기 때문에 최신 인텔 머신은 실제로 2022년 머신이란 사실입니다. 그러므로 수만 달러가 든 하드웨어 지원을 중단하는 것은 매우 대담한 결정일 수 있겠죠. 그래도 그 가능성을 완전히 배제할 수는 없지만, 그들의 사이트에서 2019년 머신으로 명시했으니 (2023년 상반기까지 판매되었음) 이에 대한 고려가 필요합니다.\n\n## 10년간의 지원은 가능할까요?\n\n기술적으로 Apple 실리콘이 적어도 10년간은 유지될 것으로 가정하면 이미 3년이 지났으므로 우리는 2030년에도 여전히 Apple 디자인된 SOC를 사용할 것으로 예상할 수 있습니다. 문제는 macOS가 2030년에도 여전히 M1 및 M2 기기에서 잘 작동할지 여부입니다.\n\n역사를 보면 어떤 면에서는 모두가 10년간 소프트웨어 지원을 포기해야 한다는 주장도 나올 것입니다. 인텔 전용 머신을 위해 설계된 마지막 OS인 MacOS 카탈리나는 2019년에 출시되었고, 그가 지원하는 가장 오래된 머신은 2012년 출시된 것입니다. 8년입니다. 그러나 2010년 머신은 이미 2006년부터 Intel 기반 머신으로 운영되는 것을 고려하면 Apple은 실제로 10년까지 갈 수도 있었을 것입니다. 이론상으로 말이죠. 혹시 모르니까요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n애플의 역사에서 파워PC와 인텔 시대는 동일한 문제를 겪었습니다. 크릠토자이트(쿠퍼티노 옆의 도시이며 애플 본사가 있는 곳) 거인은 하드웨어 디자인과 개발을 일부만 제어했습니다. IBM-모토로라 파트너십에서 인텔로 이동하면서도 그것은 결국 파트너십이었습니다. 잘못 알아들지 마세요, 이 이동은 필요했고 애플을 크게 돕게 되었습니다. 요즘 우리가 인텔을 비웃거나 깎아내리더라도, 불과 몇 년씩 조금씩 향상된 매우 뜨거운 프로세서들은 맥을 그 어느 때보다 인기 있게 만들었습니다. 큰 그림에서 보면, 이는 인텔보다 애플을 훨씬 더 도와준 것입니다.\n\n그렇지만 12년 된 맥에서 macOS 카탈리나를 테스트해보는 것은 흥미로울 것이지만, 인텔 초기 칩들은 운영 체제를 실행하는 데도 힘들 것으로 예상됩니다. 2008년 머신에서 실행 시도는 이미 전체 UX에 걸친 렉과 같이 용납할 수 없는 결과를 야기했습니다. 그리고 이 때에는 제 3자 앱이 설치되지 않은 상태였습니다. 매 해 이루어지는 인텔 업데이트의 증분만큼은 작더라도, 애플-인텔 관계 말기에 우리는 OS가 자원을 모두 독차지하지 않도록 하는 하드웨어-소프트웨어 구성을 갖게 되었습니다.\n\n그러나 엠퓨전 바실릭(애플에서 사용 중인 칩)에 오면, 상황은 매우 다릅니다. M1 칩을 기반으로 시작해서 발생할 수 있는 유일한 하드웨어 병목은 RAM입니다. 기본 머신은 단지 8GB의 메모리만 갖추어져 있고, 그것은 서비스할 수 없는 메모리입니다. 2030년까지 운영 체제만을 위해 모두 8GB의 메모리를 필요로 할 것이라 가정하지 않을지라도, 또한 그것이 불가능하지는 않습니다. 이 기사를 쓰는 시점에서 맥 OS의 커널과 다른 핵심 구성요소 및 기능을 위해 약 4GB의 메모리가 \"와이어드\" 메모리로 설정되어 있습니다.\n\n![이미지](/assets/img/2024-05-18-AreWeAboutToSeeDecadeMacOSSupportForMacs_0.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 흥미로운 이유는 128GB M3 Max Machine에서이 숫자를 보고 있기 때문입니다. Apple의 \"유선\" 메모리는 작업 가능한 총 메모리에 따라 동적으로 변경됩니다. 보고된 바에 의하면, 작동 중에 약 10개의 앱이 열린 상태에서 브라우저에서 몇 십 개의 탭과 함께 실행되어도 필요한 최대 메모리는 약 4GB입니다. 이것은 좋은 소식이지만, 2020 M1 MacBook Air의 8GB 메모리에서 2030 버전 macOS가 원활하게 실행될 것이라고 납득시킬만큼 충분한 이유는 아닙니다.\n\n물론, 시간이 지남에 따라 SOC에 새로운 구성 요소가 추가될 때, 특정 기능이 더 제한되고 작업 처리에 더 많은 시간이 걸릴 가능성이 있습니다. 그러나 최신과 최고의 것을 필요로 하는 사람들은 종종 10년간 자신의 기기를 보유하지 않습니다.\n\n그러나 그것도 중요하지 않을 수 있습니다. 더 예측할 수없는 상황을 만들기 위해 Apple은 악명 높은 \"불필요한 장치\" 목록으로 유명합니다. 예를 들어 2023년에는 2017 TouchBar MacBook Pro를 그 목록에 추가했습니다. 겨우 7년 된 기기인데, 이는 내 관점에서 Mac 사용자의 50% 이상에게 여전히 완벽하게 적합한 디바이스입니다.\n\nM1 머신을 사용한 우리 모두와 현재 Apple Silicon의 데뷔 SOC 능력을 이제야 발견하고 있는 사람들까지도 모두 동의하는 것은 그 속도가 엄청나게 빠르다는 것입니다. 그리고 메모리는 여전히 메모리이지만, 충분히 있다면 표준 생산성 앱을 실행하는 데 어려움이 없을 것이며, 현재 Apple은 모든 기기에 대한 블랭킷 규칙으로 7년 규칙을 적용하는 것으로 보입니다. 이것이 Mac, iPhone 또는 기타 무엇이든.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그 동안 앞으로 수년 동안 현명한 선택이었을 수도 있지만, Apple Silicon Mac은 단순히 더 이상 OS 업데이트가 없어서 7년 후에 그들을 버릴 수밖에 없다는 이유로 간주되기에는 훨씬 더 능숙하다고 느껴집니다. 물론, 구시 버전의 OS를 사용할 수는 있지만, 그게 반드시 필요한 이유가 없다는 점도 알 수 있습니다. 7년이 되면 기기의 배터리는 분명히 소진될 것이지만, 그 기기 자체가 사용할 수 없게 되는 것은 아닙니다. Apple은 다음과 같이 명시하고 있습니다.\n\nApple의 역사적 데이터를 살펴보고 고갈되거나 폐기된 기기에 대한 그들의 입장과 Apple Silicon SOC의 전례 없는 기능을 고려할 때, 조금의 선의를 가지고 Apple이 사실상 Mac에 대한 소프트웨어 지원을 10년 이상 제공할 수도 있을 것으로 생각합니다. 그리고 아마도 더 강력한 기기에서는 더 오래 제공될 수도 있으니, 다음으로 넘어가보겠습니다.\n\n## 불안정한 Intel 미래\n\n지난 몇 년 동안 수만 달러를 Mac Pro에 투자한 사람들은 이미 이상한 상황에 처해 있습니다. macOS Sonoma에 있는 5 가지 기능은 이미 Apple Silicon에만 적용되어 있습니다. Intel Mac Pro가 얼마나 강력하더라도, 특정 Sonoma 기능은 단순히 사용할 수 없습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- Presenter Overlay는 Apple의 신경 엔진을 사용하여 주제를 배경에서 분리합니다. 이 기능을 자주 사용하는데, 아마 필수적이지는 않지만 정말 멋진 기능이에요.\n- \"Siri\"를 약자로 사용하게 되었네요. 인텔 맥을 사용할 때 \"Hey\"를 생략할 수 없다는 게 밝혀졌어요. 웃기지만 그게 현실이에요.\n- 게임 모드는 인텔 맥에서도 사용할 수 없고, Mac Pro를 완전히 강화한 모델이 얼마나 강력할 수 있는지 생각해보면, Mac에서 일부 게임을 훌륭하게 실행하는 데 중요한 설정을 사용할 수 없다는 것이 이를 바라게 만들어요.\n- iPhone용 제작된 청각 장치는 Intel Mac(또는 M1 기본 모델)과 연결할 수 없어요. 아마 쓰이는 경우가 제한적일 수 있지만, 이는 주목할 만한 사실이에요.\n- 화면 공유는 기술적으로 인텔 맥에서 사용할 수는 있지만, 성능이 좋지 않아서 원활한 경험을 원한다면 Apple Silicon을 사용해야 해요.\n\n그리고 이것은 단지 시작에 불과해요. 현실적으로 생각해보면, macOS의 모든 미래 버전은 Apple Silicon 전용 기능을 계속해서 추가할 것이고, 이해할 만한 일이에요. 기술 회사로서 이런 엄청난 새로운 칩을 가지고 작업하게 될 테니까요. 물론 새로운 OS 기능을 이를 최대한 활용하는 데 중점을 둘 거예요.\n\nPowerPC와 Intel에 대한 결합 지원은 4년 동안에만 지속되었고 세 개의 OS 출시로 이루어진 것이었어요 - Tiger, Leopard 그리고 Snow Leopard. 현재 우리는 다시 4년의 기간에 도달했는데 이번에는 네 가지 OS 출시로 이루어진 것이에요 - Big Sur, Monterey, Ventura, Sonoma. 이것은 - 난 다음 macOS 버전에서 인텔 머신을 완전히 덜 지원할 것으로 예상하지만 - 다음 해의 macOS가 인텔 기기를 완전히 지원하지 않게 될 수도 있지만, 이건 인텔 맥에 수십만 달러를 쓴 후에 생각해야 할 좋지 않은 전망이에요.\n\n![이미지](/assets/img/2024-05-18-AreWeAboutToSeeDecadeMacOSSupportForMacs_1.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![image](/assets/img/2024-05-18-AreWeAboutToSeeDecadeMacOSSupportForMacs_2.png)\n\n애플이 인텔 기기 지원을 곧 중단하며 애플 실리콘 맥스의 OS 업데이트가 얼마나 오래 지속될지는 아직 알 수 없습니다. 하드웨어가 원활하게 실행할 수 있는 한 OS 업데이트를 허용해 줬으면 좋겠습니다. 모든 시스템에 일괄 적용하는 대신 주요 업데이트를 요청하기 전에 시스템에서 벤치마크를 실행하고, 벤치마크 결과가 요구 사양을 충족하는 경우에 사용자가 업그레이드할 수 있도록 하는 것은 어떨까요?\n\nAttila Vago — 코드 한 줄씩 세상을 개선 중인 소프트웨어 엔지니어입니다. 영원한 멋쟁이, 코드와 블로그의 작가, 웹 접근성 옹호자, 레고 팬, 비닐 음반 수집가입니다. 수제 맥주를 좋아합니다! 제 Hello 이야기를 읽어보세요! 레고, 기술, 코딩, 웹 접근성에 관한 더 많은 이야기를 구독하세요! 가끔 읽는 독자를 위해 잡다한 이야기와 글쓰기에 대해도 씁니다.\n","ogImage":{"url":"/assets/img/2024-05-18-AreWeAboutToSeeDecadeMacOSSupportForMacs_0.png"},"coverImage":"/assets/img/2024-05-18-AreWeAboutToSeeDecadeMacOSSupportForMacs_0.png","tag":["Tech"],"readingTime":8},{"title":"생산성을 높이는 새로운 보이지 않는 강력한 AI 동료와 함께하세요","description":"","date":"2024-05-18 17:40","slug":"2024-05-18-PowerupproductivitywhitthisnewinvisiblypowerfulAIcopilot","content":"\n안녕하세요! 만약에 중간(Medium)에 계신 분이라면, 이 글을 우연히 발견하셨을 거예요. 제가 알겠네요, 생산성을 향상시키는 도구를 항상 찾고 계시는 분이시군요.\n\n저는 OpenAI의 열렬한 지지자이며, 최근에 새로운 ChatGPT 앱을 Mac용으로 미리 접근할 수 있게 되었어요. 아직 몇 가지 특징이 빠진 부분은 있지만, 그동안 발견한 Invisibility 는 제 기대치를 훌륭히 능가하는 도구예요. 왜 이것을 확인할 가치가 있는지 말씀드릴게요.\n\n이 소프트웨어는 GPT-4, Claude 3 Opus, Gemini, Llama 3 등 여러 유형의 AI 모델에 대한 액세스를 구독 서비스 하나로 제공해요.\n\n이는 화면 스크린샷과 실제 화면에서 실시간으로 요청을 처리해 줘요. 마치 항상 준비된 데스크톱용 끊임없는 AI 비서가 있는 것과 같아요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n투명성의 주요 기능:\n\n- 한 가입으로 여러 AI 액세스 가능.\n- 데스크톱 어시스턴트: 화면에 항상 활성화된 AI.\n- 실시간 처리: 스크린샷을 통해 요청에 즉각적으로 응답.\n\nChatGPT로 콘텐츠를 작성하고 투명성이 작업을 분석하고 최적화하는 것을 상상해보세요. 이 둘의 협업은 우리가 일하는 방식을 변화시켜 모든 작업을 더 원활하고 효율적으로 만들어 줄 것입니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*3sH2-U3tS5dYyYhT7Evi8g.gif)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n일상적인 작업 관리에서의 일반적인 문제들을 해결해주는 Invisibility는 혁신적인 도구와 실시간 처리 능력 덕분에 제 효율성과 생산성이 크게 향상되었어요... 지금 이것은 저의 마음에 드는 도구가 되었답니다!\n\n이렇게 강력하고 유용한 도구를 만들어준 개발자들과 Sulaiman Ghori에게 큰 박수를 보내고 싶어요.\n\n궁금하신가요? 제 링크로 무료로 시도해보세요... 정말 멋지거든요!: https://invite.i.inc/Nicolo\n\nps. 이 신원에는 \"Arc\" 같은 것이 있어요 :)\n","ogImage":{"url":"/assets/img/2024-05-18-PowerupproductivitywhitthisnewinvisiblypowerfulAIcopilot_0.png"},"coverImage":"/assets/img/2024-05-18-PowerupproductivitywhitthisnewinvisiblypowerfulAIcopilot_0.png","tag":["Tech"],"readingTime":2},{"title":"맥에 PHP 설치하는 방법","description":"","date":"2024-05-18 17:39","slug":"2024-05-18-HowtoInstallPHPonMac","content":"\n![2024-05-18-HowtoInstallPHPonMac_0](/assets/img/2024-05-18-HowtoInstallPHPonMac_0.png)\n\nPHP은 웹 애플리케이션을 개발하는 데 사용되는 인기있는 프로그래밍 언어입니다. Mac을 사용하고 PHP를 사용하여 웹 애플리케이션을 개발하려면 Mac에 PHP를 설치해야 합니다. 이 기사에서는 Mac에 PHP를 설치하는 과정을 단계별로 안내해 드리겠습니다.\n\n## 단계 1: Homebrew 설치\n\nHomebrew는 macOS용 패키지 관리자로, 소프트웨어 패키지를 쉽게 설치하고 관리할 수 있게 해줍니다. Homebrew를 설치하려면 Mac의 터미널 앱을 열고 다음 명령을 실행하십시오:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```bash\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n```\n\n이 명령은 Mac에 Homebrew를 다운로드하고 설치합니다.\n\n## 단계 2: PHP 설치\n\nHomebrew를 설치하면 PHP를 설치하는 데 사용할 수 있습니다. 터미널 앱에서 다음 명령을 실행하세요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nbrew install php\n```\n\n이 명령은 Mac에 PHP의 최신 버전을 설치할 것입니다.\n\n## 단계 3: PHP 버전 확인\n\nPHP가 올바르게 설치되었는지 확인하려면 기기에 설치된 PHP 버전을 확인할 수 있습니다. 터미널 앱에서 다음 몤령을 실행하세요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nphp - v;\n```\n\n이 명령어를 실행하면 Mac에 설치된 PHP 버전이 표시됩니다.\n\n## 단계 4: PHP 구성\n\nPHP를 설치한 후에는 필요에 맞게 구성할 수 있습니다. 이를 위해 php.ini 파일을 수정하여 구성할 수 있습니다. php.ini 파일을 찾으려면 터미널 앱에서 다음 명령어를 실행하십시오:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nphp --ini\n```\n\n이 명령어를 실행하면 php.ini 파일의 위치가 표시됩니다. 그런 다음 텍스트 편집기를 사용하여 파일을 열고 필요한 변경 사항을 적용할 수 있습니다.\n\n## 단계 5: PHP 서버 시작\n\n터미널 앱에서 다음 명령어를 실행하여 PHP 서버를 시작할 수 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nphp -S localhost:8000\n```\n\n이 명령어는 포트 8000에서 PHP 서버를 시작합니다. 그런 다음 웹 브라우저를 열고 http://localhost:8000에 가서 PHP 애플리케이션을 볼 수 있습니다.\n\n축하합니다! Mac에 PHP를 성공적으로 설치했습니다. 이제 PHP를 사용하여 웹 애플리케이션을 개발할 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-05-18-HowtoInstallPHPonMac_0.png"},"coverImage":"/assets/img/2024-05-18-HowtoInstallPHPonMac_0.png","tag":["Tech"],"readingTime":3},{"title":"2024년을 위한 데이터 과학을 위한 MacBook 설정 방법","description":"","date":"2024-05-18 17:38","slug":"2024-05-18-HowtoSetupYourMacbookforDataSciencein2024","content":"\n<img src=\"/assets/img/2024-05-18-HowtoSetupYourMacbookforDataSciencein2024_0.png\" />\n\n최근에 새 맥북을 샀어요. 맥북을 제 마음대로 설정하기 위해 이전 맥북 경험과 인터넷 조사를 토대로 많은 시간을 보냈어요. 데이터 과학자를 위한 앱과 도구를 갖춘 매우 쾌적한 환경을 만들기 위해 취한 단계를 문서화했어요. 이 기사는 세 가지 섹션으로 나누어져 있어요:\n\n- 브라우저 설정\n- 설치할 앱\n- 터미널 설정 (파이썬 설정 포함)\n\n# 브라우저\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n먼저 브라우저부터 살펴보겠습니다. 나는 Google Chrome 또는 Arc와 같은 Chromium 기반 브라우저를 Safari보다 선호합니다. Chromium 기반 브라우저가 가지고 있는 확장 기능 라이브러리 때문에 그런데요. 나는 Chrome보다는 더 깔끔하고 우아한 느낌의 Arc를 사용합니다.\n\n나의 브라우저에 사용하는 익스텐션은 다음과 같습니다:\n\n- Vimium C-`는 웹을 탐색할 때 마우스 대신 단축키를 사용할 수 있습니다. f를 누르면 각 버튼에 대한 단축키가 표시되며 해당 버튼을 클릭할 수 있습니다. 해당 버튼의 문자를 입력하여 마우스를 사용하지 않고 버튼을 클릭할 수 있습니다! 익스텐션의 설정에서는 단축키를 표시하거나 숨기기를 쉽게 전환하기 위해 링크 힌트에 사용된 문자에서 문자 f를 제거하는 것을 권장합니다. 또한, Vimium C를 사용하면 책갈피 및 다른 탭에 신속하게 액세스할 수 있습니다.\n\n![이미지](/assets/img/2024-05-18-HowtoSetupYourMacbookforDataSciencein2024_1.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 비트워던 -` 다양한 비밀번호 관리자가 있지만, 비트워던은 그 중 하나입니다. 모든 기기에서 작동하며 무료 티어에서 다양한 기능을 제공하므로 제 선호도입니다.\n- 원세 -` 원세는 자주 열고 싶지만 그렇게 하기 전에 한 번 더 생각해야 할 웹사이트를 구성할 수 있는 확장 프로그램입니다. 소셜 미디어 및 뉴스 웹사이트 등의 예시가 있습니다. 이러한 URL로 이동하면 원세가 일정 시간 동안 웹사이트를 차단하여 실제로 해당 웹사이트를 방문하고 싶은지 여부를 두 번 생각할 수 있습니다. 제 모든 기기에서 사용하고 있으며 소셜 미디어 및 뉴스 웹사이트에서 많은 시간을 절약하도록 도와줍니다.\n\n![이미지](/assets/img/2024-05-18-HowtoSetupYourMacbookforDataSciencein2024_2.png)\n\n# 앱\n\n- 비주얼 스튜디오 코드 -` 제 선호하는 통합 개발 환경(IDE)입니다. 물론, VS code 대 PyCharm 논쟁이 있지만, 확장 라이브러리가 넓고 PyCharm보다 훨씬 가볍기 때문에 VS Code를 선호합니다.\n- 도커 데스크톱 -` Docker를 사용할 수 있도록 멋진 UI가 제공됩니다.\n- 비트워던 -` 크롬 확장 프로그램으로 언급한 이유와 동일합니다.\n- 키클루 -` 누른 키를 두 번 눌러 누르고 두 번째로 누른 채로 최종으로 너무 많은 응용 프로그램에 대한 대부분의 단축키를 볼 수 있습니다. 사용자 정의 단축키도 추가할 수 있습니다.\n- 원세 -` 앞에서 언급한 크롬 웹 확장 프로그램과 같은 아이디어입니다.\n- 마그넷 -` Windows에서 온 경우이며 Windows 10부터 사용할 수 있는 화면 분할 기능이 맥에서도 사용 가능하게 해주는 손쉬운 방법이 부족한가요? Magnet은 맥에서도 동일한 기능을 제공하지만 무료는 아닙니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 터미널\n\nMacOs의 기본 터미널은 괜찮아요. 저는 여러 해 동안 사용해 왔고, 많은 사람들이 아직도 사용하고 있어요. zsh에 플러그인을 사용하면 터미널을 사용하는 것이 이미 훨씬 더 즐거워집니다. 하지만 여기서 여러분이 터미널에서 절대로 얻을 수 있는 최대한의 이점에 대해 설명할게요.\n\n## Oh My Zsh\n\nOh My Zsh는 여러분의 Zsh 구성을 관리하기 위한 오픈소스, 커뮤니티 주도의 프레임워크로, 테마와 플러그인을 제공하여 터미널 경험을 향상시킵니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n먼저 다음 명령어를 입력하여 터미널에서 Oh My Zsh를 설치하세요:\n\n```js\nsh -c \"$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\"\n```\n\n## Homebrew\n\n그런 다음 Homebrew를 설치하세요. Homebrew는 MacOS용 무료 오픈 소스 패키지 관리 시스템으로, 소프트웨어를 설치, 업데이트 및 관리하는 데 사용됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```bash\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n```\n\n## Warp\n\n그런 다음 Warp를 설치하세요. Warp는 내장 MacOs 터미널을 대체할 거의 IDE와 같은 터미널입니다. 내장 터미널처럼 계속 사용할 수 있지만, 매우 환영 받는 추가 기능(무료 커서 배치, 텍스트 바로 가기)부터 고급 기능(패널 분할, 탭, 이전 명령어 검색) 및 기타 여러 가지를 제공합니다. 또한 명령어보다 하고자 하는 것을 입력할 수 있는 A.I. 어시스턴트를 사용할 수 있습니다. 또한, autosuggestions와 color-highlighting과 같은 인기있는 oh-my-zsh 플러그인이 Warp와 함께 내장되어 있습니다.\n\n<img src=\"/assets/img/2024-05-18-HowtoSetupYourMacbookforDataSciencein2024_3.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 튜토리얼을 따라 하면 VS Code에서 Warp를 더 원활하게 사용할 수 있습니다.\n\n## powerlevel10k\n\n저는 powerlevel10k를 터미널 테마로 좋아하는데, 깔끔하게 보이고 간단한 단계로 쉽게 사용자 정의할 수 있기 때문이죠.\n\n![이미지](/assets/img/2024-05-18-HowtoSetupYourMacbookforDataSciencein2024_4.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n제가 추천하는 글꼴을 설치하는 방법부터 시작할게요. 워프에서 활성화하려면 설정 -` 외형 -` 터미널 글꼴로 이동하여 MesloLGS NF를 선택하세요.\n\n그런 다음 다음과 같이 설치하세요:\n\n```js\ngit clone --depth=1 https://github.com/romkatv/powerlevel10k.git ${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/themes/powerlevel10k\n```\n\nsource ~/.zshrc로 셸을 다시 시작하고 p10k configure를 실행하여 테마를 구성하세요! 설정 -` 외형 -` 프롬프트에서 쉘 프롬프트 대신 워프 프롬프트 설정되었는지 확인해주세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## z\n\n저는 oh-my-zsh에 z 플러그인을 사용하는 것을 좋아합니다. 이를 사용하면 전체 경로를 입력하지 않고 디렉토리 간에 이동할 수 있습니다. vim ~/.zshrc을 실행한 후 플러그인 섹션에 z를 추가하고 :wq로 vim을 나가면 됩니다.\n\n![이미지](/assets/img/2024-05-18-HowtoSetupYourMacbookforDataSciencein2024_5.png)\n\n## Python\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n대부분의 데이터 과학자들은 주 프로그래밍 언어로 Python을 사용합니다. MacBook에는 기본 설치되어 있어야 합니다. 그러나 새로 시작할 때 python --version 명령이 실패할 수 있고 python3 --version은 작동할 수 있습니다. python3 명령뿐 아니라 python 명령을 실행하려면 ~/.zshrc 파일에 다음을 추가하십시오:\n\n```js\necho 'alias python=\"python3\"' >> ~/.zshrc\n```\n\n다른 프로젝트에 대해 다른 Python 버전을 사용하려면 pyenv를 사용합니다:\n\n```js\nbrew update\nbrew install pyenv\nbrew install xz\n\necho 'export PYENV_ROOT=\"$HOME/.pyenv\"' >> ~/.zshrc\necho '[[ -d $PYENV_ROOT/bin ]] && export PATH=\"$PYENV_ROOT/bin:$PATH\"' >> ~/.zshrc\necho 'eval \"$(pyenv init -)\"' >> ~/.zshrc\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n파이썬 버전을 확인하려면 pyenv install --list 명령을 사용하세요. 저는 일반적인 Python3 버전만 설치하고 싶어하여 pyenv install --list | grep ' 3\\.' 를 사용합니다.\n\n내 설치를 깨끗하게 유지하고 실수로 가상 환경이 아닌 전역적으로 의존성을 설치하는 것을 방지하기 위해 다음 두 가지 방법을 적용합니다:\n\n```js\necho 'alias pip=\"pip3 --require-virtualenv\"' >> ~/.zshrc\n```\n\n그리고 pip 설정의 전역 설정에 require-virtualenv = true를 추가합니다:\n이미 pip 설정 파일이 있는지 확인하려면 cat ~/.config/pip/pip.conf를 사용하세요. 이미 설정 파일이 있다면 [global] 섹션에 require-virtualenv = true를 추가하세요. 설정 파일이 없다면 아래 명령을 사용하세요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```bash\nmkdir -p ~/.config/pip && echo \"[global]\\nrequire-virtualenv = true\" > ~/.config/pip/pip.conf\n```\n\n# 결론\n\n위에서 언급한 브라우저 확장 프로그램, 앱 및 명령줄 도구를 모두 설치하면 MacBook에서 프로그래밍하는 데 훌륭한 경험을 할 수 있을 것입니다. 물론 모든 도구가 모든 사람에게 유용하거나 호감을 받는 것은 아닙니다. 키보드 단축키보다 마우스를 선호한다면 Vimium C 같은 도구를 설치할 필요가 없습니다. 또한 VS Code 대신 PyCharm을 선호한다면 쉽게 교체할 수 있습니다.\n\n제가 사용 중인 MacBook 설정에 만족하실 것으로 기대하며 놓치고 있는 유용한 도구가 있으면 댓글로 알려주세요!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## MLearning.ai의 작가 / Hacking GPTs Store / 20,000개 이상의 아트 프롬프트\n","ogImage":{"url":"/assets/img/2024-05-18-HowtoSetupYourMacbookforDataSciencein2024_0.png"},"coverImage":"/assets/img/2024-05-18-HowtoSetupYourMacbookforDataSciencein2024_0.png","tag":["Tech"],"readingTime":9},{"title":"파드맨으로 전환하기 도커의 오픈소스 대안","description":"","date":"2024-05-18 17:36","slug":"2024-05-18-SwitchingtoPodmananOpen-SourcealternativetoDocker","content":"\n2021년 8월 기준으로 Docker Desktop은 기업용 유료 구독이 필요하지만 CLI는 무료로 제공됩니다. 이 변경으로 일부 사용자들이 대안 옵션을 찾게 될 수 있습니다. 하지만 macOS 사용자로서 Docker Desktop은 Docker CLI를 실행하는 데 필수적이지만 걱정하지 마세요. 다른 옵션이 있습니다.\n\nColima와 Podman은 Docker의 가장 인기 있는 대체품 중 두 가지로, 둘 다 시도해본 결과 이 글에서는 컨테이너 관리를 위한 무료 오픈 소스 대안인 Podman에 초점을 맞출 것입니다.\n\nPodman은 제가 발견한 최고의 대안이며, 그 이유를 설명하겠습니다!\n\n- Docker 사용자이지만 CLI를 자주 사용하지 않는 경우, Podman은 데스크톱 애플리케이션을 갖추고 있어 무료이므로 훌륭한 선택입니다!\n- Docker 사용자이고 CLI만 사용하는 경우에도 Podman은 작동합니다!\n\n물론, Podman을 설치하고 docker `무언가`를 실행하려고 하면 작동하지 않을 것입니다. 그러나 이 글을 따라가면 Podman을 내 Docker 대체 도구로 사용하는 방법을 알 수 있습니다!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# Podman 설치 방법\n\nPodman을 설치하려면 데스크톱 앱을 포함하여 두 가지 명령어만 필요합니다:\n\n- Podman CLI 설치: brew install podman;\n- Podman 데스크톱 설치: brew install --cask podman-desktop;\n\n- 데스크톱 애플리케이션을 원하는 사용자를 위한 명령어임을 주의해주세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 가상 머신을 시작하는 방법\n\nPodman을 설치한 후 가상 머신을 시작하려면 만들고 시작해야 합니다. 아래 단계를 따라 주세요:\n\n- podman machine init;\n- podman machine start;\n\n## 가상 머신이 성공적으로 초기화되었는지 어떻게 알 수 있나요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n가상 머신이 성공적으로 시작되었는지 확인하려면 터미널에서 `podman machine list`를 실행하십시오. 아래 스크린샷과 유사한 내용이 표시되어야 합니다. 여기에는 기본 머신이 현재 실행 중인 것이 표시됩니다:\n\n![스크린샷](/assets/img/2024-05-18-SwitchingtoPodmananOpen-SourcealternativetoDocker_0.png)\n\n# Podman과 함께 Docker Compose 사용하는 방법\n\n기본 설정에서 Docker Compose는 Podman을 \"Docker\" 인스턴스로 인식하지 않을 것입니다. 그러나 \"수정\"하여 사용할 수 있습니다!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n어떤 일을 하기 전에 brew install docker-compose 명령을 사용하여 Docker Compose를 설치해야 합니다.\n\n그러나 이 시점에서 docker-compose up을 실행하면 \"Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?\"과 같은 오류 메시지가 표시될 것입니다.\n\nDocker Compose를 Podman과 함께 작동하도록 하려면 다음 단계를 따르세요:\n\n- sudo /usr/local/Cellar/podman/`podman-version`/bin/podman-mac-helper install;\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 참고: `podman-version`을(를) 사용 중인 Podman 버전으로 바꿔주세요.\n\n- podman machine stop && podman machine start;를 실행해주세요;\n\n이제 작동하는지 확인해볼 시간입니다! 기존의 docker-compose.yaml 파일을 사용하거나 새로 만들어서 docker-compose up -d를 실행해보세요.\n\n![이미지](/assets/img/2024-05-18-SwitchingtoPodmananOpen-SourcealternativetoDocker_1.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 작동하지 않나요?\n\n이러한 단계를 따라도 Docker Compose가 여전히 동일한 오류(\"Docker 데몬에 연결할 수 없음...\")를 표시한다면, 아래 두 가지 해결 방법 중 하나를 시도해 보세요:\n\n- 다음 명령을 사용하여 DOCKER_HOST를 내보내려 해보세요:\n  sh\n  export DOCKER_HOST=`unix:///Users/your-user/.local/share/containers/podman/machine/podman-machine-default/podman.sock`\n- rootful 권한으로 Podman Machine을 설정하려면 다음 명령을 사용하세요:\n  sh\n  podman machine stop && podman machine set --rootful && podman machine start\n\n# Podman 명령어\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nDocker와 Podman 사이에는 많은 명령어가 유사하지만, 이미지 및 컨테이너 작업을 할 때 구문 및 동작에 차이가 있습니다. 특히 특정 명령어와 옵션에 대해 더 알아보려면 항상 Podman 설명서를 참고하거나 podman --help를 실행하는 것이 좋습니다.\n\n일부 예시를 살펴보겠습니다:\n\n- docker ps는 podman ps로 변경됩니다;\n- docker run은 podman run으로 변경됩니다;\n- docker rm `container`는 podman rm `container`로 변경됩니다;\n- 기타.\n\n다음은 docker와 함께 사용할 Podman 명령어에 별칭을 생성하는 단계입니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 물고기 (Oh My Fish를 사용하는 경우):\n\n- IDE에서 파일 ~/.config/fish/conf.d/omf.fish을 엽니다;\n- 초기 설정 라인 (1에서 4까지) 다음에 다음 라인을 추가합니다: alias docker=\"podman\";\n- 터미널을 다시 시작하거나 source ~/.config/fish/conf.d/omf.fish을 실행합니다.\n\n- Zsh의 경우:\n\n- IDE에서 파일 ~/.zshrc을 엽니다;\n- # Example aliases 주석 다음에 다음 라인을 추가합니다: alias docker=\"podman\";\n- 터미널을 다시 시작하거나 source ~/.zshrc을 실행합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- Bash에 대한 설명:\n\n  - IDE \\*\\*\\*\\*에서 파일 ~/.bashrc을 열어주세요;\n  - 다음 줄을 파일 끝에 추가해주세요: alias docker=\"podman\";\n  - 터미널을 재시작하거나 source ~/.bashrc을 실행해주세요.\n\n해당 alias를 생성한 후에는 Docker와 동일하게 docker 명령을 사용할 수 있지만 해당 명령은 Podman 명령을 실행합니다.\n\n# Podman 데스크톱\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Switching to Podman: an Open-Source alternative to Docker](/assets/img/2024-05-18-SwitchingtoPodmananOpen-SourcealternativetoDocker_2.png)\n\n이미 이전에 언급한 바와 같이, Podman은 CLI를 사용하기를 원하지 않는 경우 필요한 모든 옵션을 갖춘 데스크톱 애플리케이션을 갖고 있습니다. 아래 이미지는 일상적으로 사용할 수 있는 가장 중요한 화면을 보여줍니다.\n\nDocker Desktop과 유사하게, 이 앱은 컨테이너, 이미지 및 볼륨에 대한 메뉴를 갖고 있어 쉽게 작업을 수행할 수 있습니다.\n\n![Switching to Podman: an Open-Source alternative to Docker](/assets/img/2024-05-18-SwitchingtoPodmananOpen-SourcealternativetoDocker_3.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Switching to Podman: an Open-Source Alternative to Docker](/assets/img/2024-05-18-SwitchingtoPodmananOpen-SourcealternativetoDocker_4.png)\n\n![Switching to Podman: an Open-Source Alternative to Docker](/assets/img/2024-05-18-SwitchingtoPodmananOpen-SourcealternativetoDocker_5.png)\n\n이미지만 봐도 이해하기 쉬울 거에요. 궁금한 점 있으면 댓글로 남겨주세요.\n\n참고: Podman Desktop을 설치하면 가상 머신이 로그인 시 시작하도록 설정을 변경할 수 있습니다. 이렇게 하면 매번 podman machine start를 실행할 필요가 없어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n개발자로서 제 생각이에요. 아마도 당신에게는 Podman이 모든 필요를 충족시키지 못할 수도 있어요. 그러나 제 일상 사용에는 충분하고, 지금까지 어떤 문제도 만나지 않았어요.\n\n요약하면, Podman은 Docker에 대한 강력한 대안으로, 안전하고 가벼운 실행 환경, Docker와 유사한 명령줄 인터페이스, 데몬이 필요하지 않은 macOS 및 Linux 배포판에서 실행할 수 있는 기능과 같은 많은 이점을 제공해요. Docker 대체품을 찾고 있다면, Podman은 분명히 확인할 가치가 있어요.\n\n이 글이 도움이 되었으면 좋겠어요!\n","ogImage":{"url":"/assets/img/2024-05-18-SwitchingtoPodmananOpen-SourcealternativetoDocker_0.png"},"coverImage":"/assets/img/2024-05-18-SwitchingtoPodmananOpen-SourcealternativetoDocker_0.png","tag":["Tech"],"readingTime":8},{"title":"쿠버네티스와 커널 패닉","description":"","date":"2024-05-18 17:35","slug":"2024-05-18-KubernetesAndKernelPanics","content":"\n넷플릭스의 컨테이너 플랫폼이 리눅스 커널 패닉을 쿠버네티스 파드로 연결하는 방법\n\n카일 앤더슨\n\n최근에는 컨테이너 플랫폼 Titus에서 엔지니어(최종 사용자가 아닌)의 고통을 줄이기 위한 노력이 있었습니다. 나는 \"고아\" 파드를 조사하기 시작했습니다. 완료되지 못한 파드들로, 만족스럽지 못한 최종 상태로 가비지 컬렉션되어야 했습니다. 우리의 서비스 작업(ReplicatSet같이 생각하십시오) 소유자들은 그리 심하게 신경쓰지 않지만, 우리의 배치 사용자들은 신경을 많이 씁니다. 실제로 반환 코드가 없다면, 다시 시도해도 안전한지 아닌지 어떻게 알 수 있을까요?\n\n이러한 고아 파드들은 시스템 전체 파드 중 소수지만 사용자들에게 진짜 고통을 미칩니다. 정확히 어디로 가는 것인가요? 왜 사라졌나요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 블로그 포스트는 최악의 시나리오인 커널 패닉부터 Kubernetes(k8s)까지 연결하여 마침내 우리 운영자들이 우리의 k8s 노드가 왜 어떻게 사라지는지 추적할 수 있도록 안내하는 방법을 보여줍니다.\n\n# 유랑된 Pod들은 어디에서 왔을까요?\n\n유랑된 Pod들은 기본 k8s 노드 객체가 사라지기 때문에 분실됩니다. 그렇게 되면 GC 프로세스가 Pod를 삭제합니다. Titus에서는 Pod 및 Node 객체의 이력을 저장해 사용자들에게 설명을 제공할 수 있도록하는 사용자 지정 컨트롤러를 실행합니다. 우리의 UI에서 이러한 실패 모드는 다음과 같이 보입니다:\n\n![이미지](/assets/img/2024-05-18-KubernetesAndKernelPanics_0.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 설명은 설득력이 부족했나봐요. 에이전트가 어디로 사라졌는지 궁금하죠?\n\n# 잃어버린 노드는 어디서 왔을까요?\n\n노드는 어떤 이유로든 사라질 수 있어요, 특히 \"클라우드\"에서 말이죠. 그럴 때는 일반적으로 클라우드 벤더에 의해 제공되는 k8s 클라우드 컨트롤러가 실제 서버, 이 경우에는 EC2 인스턴스,가 실제로 없어졌다는 것을 감지하고, 이에 따라 k8s 노드 객체를 삭제할 거에요. 그래도 \"왜\"라는 질문에 정말로 대답하지 못하겠죠.\n\n우리는 어떻게 해야 할까요? 모든 사라진 인스턴스에 이유를 부여하고, 그 이유를 감안하며, 이것을 포드까지 전달할 수 있을까요? 이 모든 것은 주석에서 시작돼요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n{\n     \"apiVersion\": \"v1\",\n     \"kind\": \"Pod\",\n     \"metadata\": {\n          \"annotations\": {\n               \"pod.titus.netflix.com/pod-termination-reason\": \"Something really bad happened!\",\n...\n```\n\n이 데이터를 넣을 수 있는 장소를 만드는 것만으로도 좋은 시작이에요. 이제 우리의 GC 컨트롤러들이 이 주석을 인식하도록 만들고, 예기치 못하게 파드나 노드를 종료시킬 수 있는 어떠한 프로세스에도 이를 뿌리는 것만 하면 돼요. 상태를 수선하는 대신 주석을 추가함으로써 기록 목적을 위해 파드의 나머지 부분을 그대로 유지할 수 있어요. (종료 이유를 나타내기 위해 종료한 것에 대한 주석을 추가합니다)\n\npod-termination-reason 주석은 다음과 같은 인간이 읽을 수 있는 메시지를 작성하는 데 유용해요:\n\n- “이 파드는 더 높은 우선 순위 작업($id)에 의해 예약 해제되었습니다”\n- “이 파드는 하부 하드웨어의 장애($failuretype)로 종료되어야 했습니다”\n- “$user가 노드에서 sudo halt 명령을 실행했기 때문에 이 파드를 종료해야 했습니다”\n- “하부 노드 커널이 패닉 상태에 빠져 이 파드가 예기치 않게 종료되었습니다!”\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n하지만 기다려봐, 커널 패닉에 빠진 노드에 대한 팟을 어떻게 주석 처리할 수 있을까요?\n\n# 커널 패닉 캡처\n\n리눅스 커널이 패닉에 빠지면 할 일이 별로 없어요. 하지만 만약 \"마지막 숨통으로 커버네티스에 저주를 내립니다!\"라는 UDP 패킷을 보낼 수 있다면 어떨까요?\n\nGoogle Spanner 논문에서 영감을 받아 Spanner 노드가 리스 및 락을 해제하기 위해 \"마지막 끼통\" UDP 패킷을 보내는 것처럼, 당신도 주식 리눅스 모듈인 netconsole을 사용하여 커널 패닉 시 서버를 설정할 수 있어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 넷콘솔 설정\n\n리눅스 커널이 심각한 상황에서 UDP 패킷을 '커널 패닉' 문자열과 함께 전송할 수 있다는 사실은 정말 놀랍죠. 이는 netconsole이 사전에 거의 모든 IP 헤더가 채워진 상태로 구성되어 있어야 한다는 것 때문에 가능합니다. 맞아요, Linux에게 소스 MAC, IP, UDP 포트 및 대상 MAC, IP, UDP 포트를 정확히 알려주어야 합니다. 특히, 커널을 위한 UDP 패킷을 거의 만들어 주는 것과 같죠. 그러나 그 전 작업을 해두면 시간이 지나면서 커널이 쉽게 패킷을 구성하고 (미리 구성된) 네트워크 인터페이스를 통해 전송할 수 있습니다. 다행히 netconsole-setup 명령어를 통해 설정을 간단히 할 수 있습니다. 모든 구성 옵션은 동적으로 설정할 수 있어서, 대상이 변경되면 새 IP로 바로 가리킬 수 있습니다.\n\n이 설정을 하면 모듈 로딩 후 커널 메시지가 즉시 흐르기 시작합니다. 마치 dmesg | netcat -u $대상 6666와 같이 전체 프로세스가 커널 공간에서 작동하는 것을 상상해보세요.\n\n# 넷콘솔 \"마지막 발악\" 패킷\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nnetconsole을 설정하면, 충돌하는 커널로 인한 마지막 노후는 예상대로 UDP 패킷 세트처럼 보입니다. UDP 패킷의 데이터는 간단히 커널 메시지의 텍스트입니다. 커널 패닉인 경우, 다음과 같이 보일 것입니다 (한 줄에 하나의 UDP 패킷):\n\n```js\nKernel panic - not syncing: buffer overrun at 0x4ba4c73e73acce54\n[ 8374.456345] CPU: 1 PID: 139616 Comm: insmod Kdump: loaded Tainted: G OE\n[ 8374.458506] Hardware name: Amazon EC2 r5.2xlarge/, BIOS 1.0 10/16/2017\n[ 8374.555629] Call Trace:\n[ 8374.556147] <TASK>\n[ 8374.556601] dump_stack_lvl+0x45/0x5b\n[ 8374.557361] panic+0x103/0x2db\n[ 8374.558166] ? __cond_resched+0x15/0x20\n[ 8374.559019] ? do_init_module+0x22/0x20a\n[ 8374.655123] ? 0xffffffffc0f56000\n[ 8374.655810] init_module+0x11/0x1000 [kpanic]\n[ 8374.656939] do_one_initcall+0x41/0x1e0\n[ 8374.657724] ? __cond_resched+0x15/0x20\n[ 8374.658505] ? kmem_cache_alloc_trace+0x3d/0x3c0\n[ 8374.754906] do_init_module+0x4b/0x20a\n[ 8374.755703] load_module+0x2a7a/0x3030\n[ 8374.756557] ? __do_sys_finit_module+0xaa/0x110\n[ 8374.757480] __do_sys_finit_module+0xaa/0x110\n[ 8374.758537] do_syscall_64+0x3a/0xc0\n[ 8374.759331] entry_SYSCALL_64_after_hwframe+0x62/0xcc\n[ 8374.855671] RIP: 0033:0x7f2869e8ee69\n...\n```\n\n# 쿠버네티스에 접속\n\n마지막 단계는 쿠버네티스(k8s)에 연결하는 것입니다. 다음을 수행하는 k8s 컨트롤러가 필요합니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 포트 6666에서 netconsole UDP 패킷을 수신하여 노드에서 발생하는 커널 패닉처럼 보이는 것을 감시합니다.\n- 커널 패닉 발생 시, 들어오는 netconsole 패킷의 IP 주소와 관련된 k8s 노드 객체를 찾습니다.\n- 해당 k8s 노드에서 바인딩된 모든 팟을 찾아서 주석을 추가한 후 해당 팟을 삭제합니다 (팟이 다 녹아버리겠군요!).\n- 해당 k8s 노드에 노드 주석을 추가한 다음 노드도 삭제합니다 (노드도 다 녹아버리겠군요!).\n\n1부 및 2부는 다음과 같이 보일 수 있습니다:\n\n```js\nfor {\n    n, addr, err := serverConn.ReadFromUDP(buf)\n    if err != nil {\n        klog.Errorf(\"Error ReadFromUDP: %s\", err)\n    } else {\n        line := santizeNetConsoleBuffer(buf[0:n])\n        if isKernelPanic(line) {\n            panicCounter = 20\n            go handleKernelPanicOnNode(ctx, addr, nodeInformer, podInformer, kubeClient, line)\n        }\n    }\n    if panicCounter > 0 {\n        klog.Infof(\"KernelPanic context from %s: %s\", addr.IP, line)\n        panicCounter++\n    }\n}\n```\n\n그리고 3부와 4부는 다음과 같이 보일 수 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nfunc handleKernelPanicOnNode(ctx context.Context, addr *net.UDPAddr, nodeInformer cache.SharedIndexInformer, podInformer cache.SharedIndexInformer, kubeClient kubernetes.Interface, line string) {\n    node := getNodeFromAddr(addr.IP.String(), nodeInformer)\n    if node == nil {\n        klog.Errorf(\"Got a kernel panic from %s, but couldn't find a k8s node object for it?\", addr.IP.String())\n    } else {\n        pods := getPodsFromNode(node, podInformer)\n        klog.Infof(\"Got a kernel panic from node %s, annotating and deleting all %d pods and that node.\", node.Name, len(pods))\n        annotateAndDeletePodsWithReason(ctx, kubeClient, pods, line)\n        err := deleteNode(ctx, kubeClient, node.Name)\n        if err != nil {\n            klog.Errorf(\"Error deleting node %s: %s\", node.Name, err)\n        } else {\n            klog.Infof(\"Deleted panicked node %s\", node.Name)\n        }\n    }\n}\n```\n\n위 코드를 넣으면 커널 패닉이 감지되자마자 pod와 노드가 즉시 사라집니다. 어떤 GC 프로세스를 기다릴 필요가 없습니다. 주석은 노드 및 pod에 무슨 일이 일어났는지 문서화하는 데 도움이 됩니다:\n\n<img src=\"/assets/img/2024-05-18-KubernetesAndKernelPanics_1.png\" />\n\n# 결론\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n작업이 커널 패닉 때문에 실패했다는 것을 고객님에게 알리는 것은 만족스럽지 않을 수도 있습니다. 그러나 커널 패닉을 해결하기 위해 필요한 관측 도구를 갖추게 된 사실에 기쁨을 느끼실 수 있을 거예요!\n\n시스템에서 왜 실패하는 지 정말로 깊이 파악하는 것이 즐거우셨나요? 혹은 커널 패닉이 멋지게 느껴지시나요? 저희 Compute 팀에 참여해 주세요. 저희는 엔지니어들을 위한 세계적 수준의 컨테이너 플랫폼을 구축 중이에요.\n","ogImage":{"url":"/assets/img/2024-05-18-KubernetesAndKernelPanics_0.png"},"coverImage":"/assets/img/2024-05-18-KubernetesAndKernelPanics_0.png","tag":["Tech"],"readingTime":9},{"title":"Samba를 사용하여 CIFS 파일 시스템 유형을 이용해 공유 폴더를 마운트하는 방법","description":"","date":"2024-05-18 17:34","slug":"2024-05-18-HowtoMountaSharedFolderUsingSambawithCIFSFilesystemType","content":"\n안녕하세요! 이 튜토리얼에서는 Linux 시스템에서 올바른 파일 시스템 유형(cifs)을 사용하여 Samba를 사용하여 호스트 머신의 공유 폴더를 마운트하는 단계를 살펴볼 것입니다.\n\n# 단계 1: Samba 공유 설정\n\nSamba 설치: 먼저 호스트 머신에 Samba를 설치합니다:\n\n```js\nsudo apt update\nsudo apt install samba\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nSamba 구성: Samba 구성 파일을 편집하세요:\n\n```js\nsudo vim /etc/samba/smb.conf\n```\n\n파일의 끝에 다음 라인을 추가하세요:\n\n```js\n[shared_folder]\npath = /공유할/폴더/경로\nwritable = yes\nguest ok = yes\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 단계 2: 필요한 패키지 설치\n\n시스템에 cifs-utils 패키지가 설치되어 있는지 확인하세요. 패키지 관리자를 사용하여 설치할 수 있습니다:\n\n```js\nsudo apt update\nsudo apt install cifs-utils\n```\n\n# 단계 3: 호스트 머신의 IP 주소 찾기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음 명령을 사용하여 호스트 머신의 IP 주소를 찾을 수 있습니다:\n\n```js\nip addr show | grep inet | grep -v 127.0.0.1 | awk '{print $2}' | cut -d'/' -f1\n```\n\n이 명령은 호스트 머신의 IP 주소를 출력합니다.\n\n# 4단계: 마운트 포인트 만들기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n공유 폴더를 마운트할 디렉토리를 생성해보세요. 예를 들어, 홈 디렉토리에 shared_folder라는 디렉토리를 만들어봅시다:\n\n```js\nmkdir ~/shared_folder\n```\n\n# 단계 5: 공유 폴더 마운트하기\n\n마운트 명령을 사용하여 공유 폴더를 마운트하세요. host_ip를 호스트 머신의 IP 주소로, shared_folder_name을 공유 폴더의 이름으로 대체하세요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nsudo mount -t cifs //호스트IP/공유폴더명 ~/공유폴더 -o guest\n```\n\n만약 공유 폴더에 인증이 필요하다면 사용자 이름과 비밀번호를 제공할 수도 있어요:\n\n```js\nsudo mount -t cifs //호스트IP/공유폴더명 ~/공유폴더 -o username=당신의사용자이름,password=당신의비밀번호\n```\n\n# 단계 6: 마운트 확인하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n공유된 폴더가 올바르게 마운트되었는지 확인하려면 마운트 지점 디렉터리의 내용을 나열하여 확인해보세요:\n\n```js\nls ~/shared_folder\n```\n\n이 명령을 실행하면 공유된 폴더의 내용이 나열됩니다.\n\n# 단계 7: 파일 접근 및 수정\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 로컬 머신에서 공유 폴더의 파일에 직접 액세스하고 수정할 수 있어요.\n\n# 단계 8: 공유 폴더에서 마운트 해제하기 (선택 사항)\n\n공유 폴더 작업을 완료했을 때 umount 명령을 사용하여 마운트를 해제할 수 있어요:\n\n```js\nsudo umount ~/shared_folder\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 단계 9: 자동 마운트 (선택 사항)\n\n시스템 부팅할 때마다 공유 폴더를 자동으로 마운트하려면 /etc/fstab 파일에 항목을 추가할 수 있습니다.\n\n```js\n//host_ip/shared_folder_name  /home/your_username/shared_folder  cifs  guest  0  0\n```\n\n호스트 IP, 공유 폴더 이름 및 /home/your_username/shared_folder를 세팅에 맞는 적절한 값으로 교체해주세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위 항목을 추가한 후 시스템을 재부팅하거나 다음과 같이 수동으로 공유 폴더를 마운트할 수 있습니다:\n\n```js\nsudo mount -a\n```\n\n끝났어요! 이제 올바른 파일 시스템 유형(cifs)을 사용하여 Samba를 통해 공유 폴더를 마운트했습니다. 이제 공유 폴더의 파일에 액세스하고 필요에 따라 작업할 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-05-18-HowtoMountaSharedFolderUsingSambawithCIFSFilesystemType_0.png"},"coverImage":"/assets/img/2024-05-18-HowtoMountaSharedFolderUsingSambawithCIFSFilesystemType_0.png","tag":["Tech"],"readingTime":5},{"title":"원격 액세스 보안하는 방법 SSH 키 사용 안내","description":"","date":"2024-05-18 17:32","slug":"2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys","content":"\nSSH 키 기반 인증을 사용하여 SSH 연결을 안전하게 하는 단계별 가이드\n\n![SSH Key-Based Authentication](/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_0.png)\n\n오늘의 글은 SSH 원격 세션의 보안을 강화하는 간단한 자습서를 제공합니다. Linux 서버에 SSH 키 기반 인증을 설정하는 방법에 중점을 두고 덜 안전한 암호 기반 인증에서 전환하는 방법을 안내합니다. 마지막으로 SSH 서버를 더 안전하게 하는 추가 방법에 대한 보너스 팁을 공유할 것입니다.\n\n# 개요\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nSSH (Secure Shell) 키 기반 인증은 원격 서버에서 사용자의 신원을 인증하기 위해 암호화 키 쌍을 사용하는 보안 방법입니다. 이 방법은 컴퓨터에 공개 및 비밀 키 쌍을 생성하여 저장하고, SSH 서버를 구성하여 이러한 키를 인식하고 수락하도록 설정하는 것을 포함합니다. 이는 기존 암호 기반 인증과 관련된 위험을 줄이는 것으로 보안을 크게 향상시킵니다.\n\nSSH 키는 쌍으로 생성되고 일반 텍스트 파일로 저장됩니다. 키 쌍은 두 부분으로 구성됩니다:\n\n- 🔒 공개 키: 이 부분은 SSH 서버에 저장됩니다. 안전하게 공유할 수 있어 해당 서버가 연결할 때 신원을 인식할 수 있습니다.\n- 🔑 비밀 키: 이 부분은 사용자의 컴퓨터에 저장되어야 하며 항상 안전하게 보관되어야 합니다. 이를 사용하여 서버와 인증하며, 절대로 공유해서는 안 됩니다. 비밀 키는 파일을 읽을 수 없도록 사용 권한을 설정해야 합니다.\n\n## 작동 방식\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 컴퓨터에서 공개 및 개인 키 쌍을 생성합니다.\n- 서버는 공개 키를 인식하고 해당하는 개인 키가 인증 중에 사용되면 액세스를 허용하도록 구성됩니다.\n- 선택적으로 개인 키에 암호를 설정하여 추가 보안을 제공할 수 있습니다. 이 암호는 잘못된 손에 키가 넘어갈 경우 추가 보호층을 제공합니다.\n\n# SSH 키를 사용한 인증의 장점\n\nSSH 키 기반 인증은 비밀번호보다 더 나은 대안이므로 보안성과 편리성이 강화됩니다. 이렇게 왜 SSH 키를 사용해야 하는지 살펴보겠습니다:\n\n- 향상된 보안: 키가 고유하고 추측하기 어려우므로 키 기반 인증은 브루트 포스 공격에 저항합니다.\n- 자격 증명 노출 위험 감소: 서버가 침해당한 경우 권한 부여 자격 증명이 노출되는 위험이 없습니다.\n- 사용의 용이성: 사용자들은 복잡한 암호를 기억하거나 적어두지 않아도 되므로, 암호 관련 위반 사례의 위험이 줄어듭니다.\n- 자동화 지원: 암호 입력이 필요하지 않기 때문에 작업을 자동화할 수 있으며, 수동 개입 없이 Ansible과 같은 스크립트 및 도구가 SSH 서버와 상호작용할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# SSH를 위한 공개 키 인증 설정하기\n\n기본 사항을 다뤘으니, 이 작업을 완료하는 단계에 대해 자세히 살펴보겠습니다.\n\nSSH 키 쌍을 만드는 두 가지 옵션이 있습니다: Windows 기계 또는 Linux 기계에서. 단계는 일반적으로 비슷하지만, 각 환경에서 사용하는 소프트웨어 도구는 다릅니다.\n\n## 방법 1: Linux에서 SSH 키 쌍 생성하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n스텝 1: Ed25519 알고리즘을 사용하여 새 SSH 키 쌍을 생성하세요.\n\n이 단계는 키페어를 로컬 컴퓨터에서 생성한 후에 나중에 서버로 업로드할 것으로 가정합니다. 서버에서 키페어를 생성하고 개인 키를 로컬 호스트로 다운로드하는 것보다 안전합니다.\n\nEd25519 알고리즘을 사용하여 새 키 쌍을 생성하세요:\n\n```js\nssh-keygen -t ed25519 -C \"cybersecmav@warfare.systems\"\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- -t: 알고리즘의 종류 (키), 우리의 경우 Ed25519.\n- -C: SSH 키를 구분할 수 있도록 도와주는 설명 (선택 사항).\n\n파일 이름을 요구하면 기본 이름과 경로를 수락하려면 Enter 키를 누르세요. SSH 키는 일반적으로 ~/.ssh/ 디렉터리에 저장됩니다.\n\n![이미지](/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_1.png)\n\n단계 2: 원격 서버 준비하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만약 ~/.ssh 디렉토리와 authorized_keys 파일이 존재하지 않는다면 다음을 실행해주세요:\n\n```js\nmkdir ~/.ssh\ntouch ~/.ssh/authorized_keys\n```\n\n~/.ssh 디렉토리에 위치한 authorized_keys 파일은 SSH 서버에 액세스할 수 있는 공개 키 목록을 포함하고 있습니다.\n\n~/.ssh 디렉토리와 authorized_keys 파일에 적절한 파일 권한을 설정해주세요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nchmod 700 ~/.ssh\nchmod 600 ~/.ssh/authorized_keys\n```\n\n- chmod 700 ~/.ssh: 해당 디렉토리의 파일을 읽기, 쓰기, 실행할 수 있는 권한을 소유자에게만 부여합니다.\n- chmod 600 ~/.ssh/authorized_keys: 소유자에게만 파일에 액세스할 수 있도록 제약을 두어 다른 사람이 파일을 보거나 수정하는 것을 방지하여 SSH 키를 보호합니다.\n\n로컬 머신에서 공개 키를 원격 서버로 업로드하세요:\n\n```js\nscp id_ed2551.pub cybersecmav@warfare.systems:/home/cybersecmav/id_ed2551.pub\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래와 같이 업로드한 공개 키를 .ssh/ 디렉터리로 이동해 주세요:\n\n```js\nmv id_ed2551.pub ~/.ssh/\nchmod 600 ~/.ssh/id_ed2551.pub\n```\n\n공개 키의 출력을 authorized_keys 파일로 복사해 주세요:\n\n```js\ncat ~/.ssh/id_ed2551.pub >> ~/.ssh/authorized_keys\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nauthorized_keys의 내용을 확인하여 공개 키가 추가되었는지 확인해보세요:\n\n```js\ncat .ssh/authorized_keys\nssh-ed25519 AAA<<...REDACTED......>>1uEqXysh cybersecmav@warfare.systems\n```\n\n모든 올바른 폴더 및 파일 권한이 있는지 확인해봅시다:\n\n```js\ncybersecmav@ares:~$ cd .ssh\ncybersecmav@ares:~/.ssh$ ls -la\ntotal 16\ndrwx------ 2 cybersecmav cybersecmav 4096 Apr 26 14:32 .\ndrwxr-xr-x 5 cybersecmav cybersecmav 4096 Apr 29 13:32 ..\n-rw------- 1 cybersecmav cybersecmav  109 Apr 26 14:33 authorized_keys\n-rw-r--r-- 1 cybersecmav cybersecmav  109 Apr 23 19:49 id_ed2551.pub\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nStep 3: 공개 키 인증을 지원하도록 SSH 서버 구성하기\n\n편집을 위해 SSH 서버 구성 파일을 엽니다:\n\n```js\nsudo nano /etc/ssh/sshd_config\n```\n\nPubkeyAuthentication 설정을 찾아서 아래로 스크롤합니다. \"no\"에서 \"yes\"로 변경하세요. 또한, AuthorizedKeysFile로 시작하는 줄이 주석 처리되어 있지 않은지 확인하거나 누락된 경우 추가하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```plaintext\nPubkeyAuthentication yes\nAuthorizedKeysFile .ssh/authorized_keys .ssh/authorized_keys2\n```\n\n다음은 /etc/sshd_config 파일이 보이는 방식입니다:\n\n![2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_2.png](/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_2.png)\n\n4단계: 구성 변경을 적용하기 위해 SSH 서버를 다시로드하세요\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nsshd_config 파일을 변경할 때는 변경 사항이 적용되려면 SSH 서버를 다시로드하거나 다시 시작해야 합니다.\n\nDebian/Ubuntu:\n\n```js\nsudo systemctl reload ssh\nsudo systemctl restart ssh\n```\n\nRedhat/CentOS:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nsudo systemctl reload sshd\nsudo systemctl restart sshd\n```\n\n## 방법 2: Windows에서 SSH 키 쌍 생성\n\n로컬 머신으로 Windows를 사용하고 있다면, PuTTY 클라이언트의 키 생성기인 puttygen.exe를 사용하여 SSH 키 쌍을 생성할 수 있습니다.\n\n- 다음 위치에서 PuTTY를 다운로드하세요: https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html\n- puttygen.exe를 엽니다. 기본적으로 RSA를 키 생성으로 선택하지만, 원격 SSH 서버가 지원하는 경우 ED25519를 선택할 수도 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_3.png\" />\n\n- \"Generate\"를 클릭하여 새로운 공개/개인 키 쌍을 생성합니다.\n\n<img src=\"/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_4.png\" />\n\n- 나중에 원격 서버의 ~/.ssh/ 디렉토리의 authorized_keys 파일에 붙여 넣을 공개 키를 복사합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![image](/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_5.png)\n\n- Save the public key as: id_ed2551.pub\n- Save the private key as: id_ed2551.ppk\n\n![image](/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_6.png)\n\n- Alternatively, you can save them using the File menu option\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Save and keep a copy of your SSH keys](/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_7.png)\n\n![SSH key image 2](/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_8.png)\n\n![SSH key image 3](/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_9.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- `/home/username/.ssh/authorized_keys` 파일에 공개 키 값을 새 줄에 붙여 넣으세요.\n\n![Step 10](/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_10.png)\n\n- 윈도우즈에서 PuTTY SSH 클라이언트를 사용하여 키 기반 인증을 통한 원격 호스트로의 SSH 연결을 테스트합니다.\n- putty.exe 클라이언트를 열고 원격 SSH 서버 세부 정보를 입력하세요.\n\n![Step 11](/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_11.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 지금 가장 중요한 단계는 리모트 서버에 연결하기 전에 방금 생성한 올바른 개인 키를 선택했는지 확인하는 것입니다.\n\n![SSH Key](/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_12.png)\n\n- \"Open\"을 클릭하면 원격 대상과의 SSH 세션이 열립니다.\n\n- 이제 새로운 공개/개인 키 쌍을 사용하여 인증된 SSH 세션이 열려 있어야 합니다. 아래 예시를 확인해주세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_13.png\" />\n\n이제 SSH 키 기반 인증으로 로그인되었습니다.\n\n# 추가 정보: SSH 서버 보안 팁\n\nSSH 키 기반 인증의 기본 사항을 다룬 이제, SSH 서버를 보다 더 보호하기 위한 몇 가지 추가 보안 팁을 살펴봅시다. 이러한 모범 사례를 시행함으로써 SSH 서버의 보안성을 높일 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 팁 1: 비밀번호 인증 비활성화\n\nSSH 키 기반 인증이 작동하는지 확인한 후, SSH 구성 파일인 /etc/ssh/sshd_config에서 PasswordAuthentication을 \"no\"로 설정하여 비밀번호 기반 로그인을 비활성화하세요.\n\n```sh\nsudo nano /etc/ssh/sshd_config\n```\n\n![이미지](/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_14.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 팁 2: 루트 로그인 제한\n\nSSH를 통한 직접적인 루트 액세스를 방지하려면 PermitRootLogin을 \"no\"로 설정하세요. 이렇게 하면 사용자가 루트 계정으로 로그인하는 것이 불가능해지며 관리 작업을 위해 sudo를 사용해야 합니다.\n\n![이미지](/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_15.png)\n\n## 팁 3: 비표준 SSH 포트 사용\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n기본 SSH 포트를 22에서 더 높거나 보통과 다른 숫자로 변경하면 무분별한 자동 스캔 및 브루트포스 공격이 더 어려워질 수 있습니다. 이는 위협의 대부분을 이루는 것입니다. 그러나 SSH 서버를 모든 공격으로부터 완전히 보호하는 것은 아니라는 것을 명심하세요. 결정적인 해커는 여전히 SSH 포트를 찾아내고 대상으로 삼을 수 있습니다.\n\n![Image](/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_16.png)\n\n## 팁 4: SSH 로깅 및 모니터링 활성화\n\nSSH 로깅이 활성화되어 있어야 연결 시도를 추적하고 이상한 활동을 감지할 수 있습니다. 무단 액세스나 브루트포스 공격의 징후를 탐지하기 위해 로그를 정기적으로 모니터링하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n대부분의 시스템에서 SSH 로깅은 기본적으로 활성화되어 있습니다. 그러나 SSH 설정 파일 /etc/ssh/sshd_config을 확인하여 비활성화되어 있지 않은지 확인해보세요.\n\n단계 1: SSH 서비스 구성 파일에서 SSH 로깅 활성화하기\n\nSyslogFacility를 \"AUTH\"로 설정하고 LogLevel은 \"INFO\"로 설정하세요.\n\n![이미지](/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_17.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다른 로그 레벨을 탐색하려면 아래 섹션을 참조하세요. Verbose 및 Debug는 많은 로그를 생성하므로 진단 또는 디버깅에만 유용하기 때문에 권하지 않습니다.\n\nSSH 로그 레벨\n\n- QUIET: 거의 아무것도 로그하지 않아 최소한의 출력을 제공합니다.\n- FATAL: SSH 서버 작동을 중지하는 중요한 오류만 로그합니다.\n- ERROR: 중요한 문제 및 심각한 오류를 로그합니다.\n- INFO: 기본 레벨로, SSH 작업에 대한 일반 정보를 로깅합니다.\n- VERBOSE: SSH 프로세스에 대한 자세한 정보를 로그하며, 문제 해결에 유용합니다.\n- DEBUG: 디버깅을 위한 방대한 로그를 생성하며, 일반적으로 일상적으로 사용하지 않습니다.\n\n단계 2: 로그 저장소 구성\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n보통 SSH 로그는 /var/log/auth.log (Debian/Ubuntu) 또는 /var/log/secure (Red Hat/CentOS)에 저장됩니다.\n\n```js\n$ ls -la /var/log/auth.log\n-rw-r----- 1 root adm 292525 May 4 10:18 /var/log/auth.log\n```\n\n이 파일들이 존재하고 접근 가능한지 확인하세요. 소유자가 root로 설정되어 있고 파일 권한이 로그 파일을 안전하게 보호하기 위해 적절하게 설정되었는지 확인하세요.\n\n```js\nchmod 640 /var/log/auth.log\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 팁 5: 침입 탐지 (Fail2ban) 구현하기\n\nFail2Ban은 로그인 시도를 모니터링하고 많은 실패한 시도 후 IP 주소를 차단하여 SSH 서버를 보호할 수 있습니다. 이는 브루트포스 공격의 일반적인 징후입니다. 설치한 후에는 SSH 로그를 주시하도록 설정하고 의심스러운 IP를 차단할 규칙을 구성하세요. SSH 서버의 보안에 추가적인 방어층을 더하는 효과적인 방법입니다.\n\nFail2Ban을 설정하고 구성하는 것은 이 글의 범위를 벗어납니다. 그러나 추가 보안을 위해 서버에 설치하는 것을 적극 추천합니다.\n\n# 결론\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 기사에서는 SSH 키 기반 인증의 혜택을 다루었는데, 이를 통해 보안을 강화하고 브루트포스 공격의 위험을 줄일 수 있다는 점을 강조했습니다. SSH 키를 생성하고 서버에 구성하는 방법을 안내하며 적절한 보안을 유지하는 방법을 보여드렸습니다. 또한 SSH 서버를 안전하게 유지하기 위한 추가 팁을 살펴봤는데, 이에는 기본 포트 변경, Fail2Ban 구현, 그리고 철저한 SSH 로깅 및 모니터링 활성화가 포함되었습니다.\n\n전체적으로 SSH 키 기반 인증은 원격 액세스를 보다 안전하고 편리하게 관리하는 방법을 제공합니다. 패스워드 기반 로그인의 효과적인 대체제로서, 미인가된 액세스 가능성을 줄이고 보안을 희생하지 않고 자동화가 가능합니다.\n\n권장 사항으로는 개인 키에 항상 암호를 설정하고, 이상한 활동을 정기적으로 모니터링하며, 키 기반 설정에 확신을 갖게 되면 패스워드 인증을 비활성화하는 것을 고려해야 합니다. Fail2Ban을 구현하면 브루트포스 공격의 징후를 보이는 IP 주소를 차단하여 자동화된 보호층을 추가할 수 있습니다.\n\n이러한 단계를 따라가면 안전하고 신뢰할 수 있는 SSH 설정으로 나아갈 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 안내서를 통해 함께해 주셔서 감사합니다. SSH 연결을 안전하게 유지하고 서버를 안전하게 보호하는 데 도움이 되었으면 좋겠습니다! 🔐\n\n안전 유지하시고 보안 유지하시길 바랍니다!\n\nCyberSecMaverick\n\n![Guide Image](/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_18.png)\n","ogImage":{"url":"/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_0.png"},"coverImage":"/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_0.png","tag":["Tech"],"readingTime":17}],"page":"104","totalPageCount":119,"totalPageGroupCount":6,"lastPageGroup":19,"currentPageGroup":5},"__N_SSG":true}