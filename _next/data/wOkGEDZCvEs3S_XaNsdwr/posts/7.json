{"pageProps":{"posts":[{"title":"세 개의 타워 뭐가 다른가","description":"","date":"2024-06-30 21:55","slug":"2024-06-30-TheThreeTowers","content":"\n\n![이미지](/assets/img/2024-06-30-TheThreeTowers_0.png)\n\n하노이 탑은 프로그래밍에서 고전이자 도전적인 문제입니다. 이 문제의 해결책을 찾는 것은 어렵지 않지만, 해결책 뒤에 숨겨진 직관을 이해하는 데는 약간의 시간이 걸립니다. 이 문제를 살펴보고 이 문제의 직관을 이해하고 어떻게 코드로 작성할지 알아봅시다.\n\n# 기원\n\n하노이 탑 문제는 1883년 프랑스 수학자 에두아르 루카가 발명했습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n루카스는 이 문제를 더 넓은 대중에게 호소하기 위해 함께 이야기도 추가했습니다. 전설에 따르면 수세기동안 하인두 사원에서 사제들이 세 기둥 사이에서 금판을 옮겨다 놓았다고 합니다. 그들은 하노이의 탑 규칙을 따라야 합니다. 하루에 한 디스크씩만 움직일 수 있습니다. 이 퍼즐을 완성하면 세상이 끝날 것이라고 전해집니다.\n\n# 문제 설명\n\n세 개의 타워(기둥)가 있습니다. 하나의 타워에는 크기가 증가하는 n개의 디스크가 있고, 다른 두 타워는 비어 있습니다. 모든 디스크를 한 타워에서 다른 타워로 옮겨야 합니다.\n\n두 가지 규칙이 있습니다. 더 큰 디스크를 작은 디스크 위에 놓을 수 없으며 한 번에 한 개의 디스크만 이동시킬 수 있습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 직관\n\n엣지 케이스를 살펴보죠. 즉, 우리가 디스크가 하나뿐인 경우의 처리 방법은 무엇일까요?\n\n이 경우의 답은 꽤 간단합니다. 필요한 기둥으로 그냥 이동하면 됩니다.\n\n<img src=\"/assets/img/2024-06-30-TheThreeTowers_1.png\" />\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 2개의 디스크를 이동해 봅시다.\n\n작은 디스크를 큰 디스크 위에 놓을 수 없기 때문에 먼저 작은 디스크를 중간으로 옮겨야 합니다.\n\n![이미지](/assets/img/2024-06-30-TheThreeTowers_2.png)\n\n그런 다음 큰 디스크를 끝으로 옮기게 될 거에요.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![이미지](/assets/img/2024-06-30-TheThreeTowers_3.png)\n\n작은 디스크를 마지막 위치로 이동시키면 됩니다.\n\n![이미지](/assets/img/2024-06-30-TheThreeTowers_4.png)\n\n문제가 해결되었습니다.\n\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 우리가 가장 중요한 테스트 케이스, 즉 3개의 디스크에 대한 것을 시도해 봅시다. 이것을 주의 깊게 이해하려고 노력해주세요.\n\n![이미지](/assets/img/2024-06-30-TheThreeTowers_5.png)\n\n하나의 해결책은 백트래킹을 시도하여 가능성을 찾는 것입니다(수도 퍼즐과 같이). 그러나 더 나은 접근 방식은 문제를 분해하는 것입니다.\n\n가장 큰 디스크를 무시해 봅시다. 우리는 한 막대에서 다른 막대로 두 개의 디스크를 옮기는 방법을 알고 있습니다. 그러나 만약 그들을 직접 최종 막대로 옮긴다면(2개 디스크 문제에서처럼) 가장 큰 디스크를 어떻게 옮길 것인가요?\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![image1](/assets/img/2024-06-30-TheThreeTowers_6.png)\n\n이 방법은 문제가 발생할 수 있으므로 상단의 두 디스크를 중간 막대로 이동해 보겠습니다. 그렇게 하면 가장 큰 디스크를 마지막 막대로 바로 이동할 수 있습니다.\n\n![image2](/assets/img/2024-06-30-TheThreeTowers_7.png)\n\n이제 동일한 방법을 따라서 (2개의 디스크를 이동할 때 사용한 것과 같은 방법으로) 두 개의 작은 디스크를 더 큰 디스크 위로 이동할 수 있습니다.\n\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![이미지](/assets/img/2024-06-30-TheThreeTowers_8.png)\n\n패턴을 보셨나요?\n\nn개의 디스크를 시도해보세요.\n\n![이미지](/assets/img/2024-06-30-TheThreeTowers_9.png)\n\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n3개의 디스크가 있는 문제와 비교해보세요. 먼저, 작은 디스크를 가운데로 옮깁니다.\n\n![image](/assets/img/2024-06-30-TheThreeTowers_10.png)\n\n그런 다음 가장 큰 디스크를 최종 막대로 옮길 수 있습니다.\n\n![image](/assets/img/2024-06-30-TheThreeTowers_11.png)\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 첫 번째 단계를 반복하고 n-1 개의 디스크를 더 큰 디스크 위로 이동해야 합니다.\n\n![image](/assets/img/2024-06-30-TheThreeTowers_12.png)\n\n따라서 우리의 문제는 해결되었습니다!\n\n# 재귀 논리\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 주요 부분으로 넘어갑시다. 재귀 논리를 이해하는 방법은 무엇인가요?\n\n- 먼저 n-1개의 디스크를 보조 막대로 이동\n- n번째 디스크를 최종 막대로 이동\n- n-1개의 디스크를 최종 막대로 이동\n- 만약 n = 1이면, 바로 최종 막대로 이동시킵니다\n\n# 소스 코드\n\n이제 솔루션을 코딩해봅시다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nvar towerOfHanoi = function(n, start, auxiliary, end){}\n```\n\n먼저 우리는 에지 케이스를 작성할 것입니다.\n\n```js\nvar towerOfHanoi = function(n, start, auxiliary, end) {\n  if (n == 1) {\n    console.log(`디스크 1을 ${start}에서 ${end}로 옮깁니다`);\n    return 0;\n  }\n}\n```\n\n우리는 코드가 n-1에 대해 작동할 것으로 가정하고, n-1을 보조로 옮깁니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nvar towerOfHanoi = function(n, start, auxiliary, end) {\n  if (n == 1) {\n    console.log(`디스크 1을 ${start}에서 ${end}로 이동합니다`);\n    return 0;\n  }\n  towerOfHanoi(n - 1, start, end, auxiliary);\n}\n```\n\n그리고 가장 큰 디스크를 끝으로 이동합니다.\n\n```js\nvar towerOfHanoi = function(n, start, auxiliary, end) {\n  if (n == 1) {\n    console.log(`디스크 1을 ${start}에서 ${end}로 이동합니다`);\n    return 0;\n  }\n  towerOfHanoi(n - 1, start, end, auxiliary);\n  console.log(`디스크 ${n}을 ${start}에서 ${end}로 이동합니다`);\n}\n```\n\n마지막으로, 보조 기둥에 있는 n-1을 끝으로 옮깁니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nvar towerOfHanoi = function(n, start, auxiliary, end) {\n  if (n == 1) {\n    console.log(`move the disk 1 from ${start} to ${end}`);\n    return 0;\n  }\n  towerOfHanoi(n - 1, start, end, auxiliary);\n  console.log(`move the disk ${n} from ${start} to ${end}`);\n  towerOfHanoi(n - 1, auxiliary, start, end);\n}\n```\n\n이제 우리의 코드가 완성되었습니다!!!\n\n# 시간 복잡도\n\n이 알고리즘의 시간 복잡도를 찾아봅시다\n\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n가정해볼게요. n개의 디스크가 있다고 가정해봅시다. 시간은 T(n)이라고 부르겠습니다.\n\n따라서, T(n) = 2(T(n-1)) +1\n\n= T(n) = 2(2(T(n-2)) + 1) +1\n\n= T(n)= 2²T(n-2) + 2 + 1\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n=T(n)= 2³T(n-3) + 2² + 2 + 1\n\n= T(n) = (2^k) *T(n-k) +(2^k) +2^(k-1) + …. + 2² + 1\n\n( T(1) = 1 and T(0) = 0)\n\n= T(n) = 2⁰ + 2¹ + 2² + …. + 2^(n-1)\n\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이것은 등비 수열이기 때문에 합계를 구할 수 있습니다.\n\n` T(n) = (2^n) -1 `\n\n따라서, 시간복잡도는 O((2^n)-1) 입니다.\n\n# 공간 복잡도\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n재귀를 사용할 때 함수가 다른 함수를 호출하면 외부 함수가 재귀 호출 스택에 저장됩니다.\n\n함수는 1에 도달할 때까지 계속 호출되므로,\n\nSC = O(N)\n\n이 글이 마음에 들었기를 바랍니다. 불일치나 의문 사항이 있으면 언제든지 연락 주세요. 즐거운 학습되세요!!!","ogImage":{"url":"/assets/img/2024-06-30-TheThreeTowers_0.png"},"coverImage":"/assets/img/2024-06-30-TheThreeTowers_0.png","tag":["Tech"],"readingTime":9},{"title":"Nodejs와 Express 앱에서 역할 기반 접근 제어RBAC 구현하는 방법","description":"","date":"2024-06-30 21:53","slug":"2024-06-30-ImplementingRoleBasedAccessControlRBACinNodejsandExpressApp","content":"\n\n이 기사에서는 단 몇 분 안에 Node.js 및 Express 애플리케이션에 Role Based Access Control (RBAC)을 구현하는 방법을 알려드립니다.\n\n![이미지](/assets/img/2024-06-30-ImplementingRoleBasedAccessControlRBACinNodejsandExpressApp_0.png)\n\n응용 프로그램 내에서 특정 기능 및 데이터에 액세스할 수 있는 권한이 있는 사용자만이 액세스할 수 있도록 보장하기 위해 Role-Based Access Control (RBAC)을 구현하는 것이 중요합니다.\n\n이 기사에서는 Permify를 사용하여 Node.js 및 Express 애플리케이션에 RBAC을 구현하는 방법을 안내해드릴 것입니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# Node.js Express 프로젝트 설정하기\n\nExpress.js 프로젝트를 위한 애플리케이션 뼈대를 빠르게 생성하려면 express-generator 도구를 사용할 수 있습니다. 시작하기 위해 다음 단계를 따르세요:\n\n## 단계 1. express-generator 설치하기:\n\nNode.js 버전 8.2.0 이상을 사용 중이라면 npx 명령어를 사용하여 애플리케이션 생성기를 실행할 수 있습니다:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nnpx express-generator\n```\n\n이전 Node 버전의 경우, 애플리케이션 생성기를 글로벌 npm 패키지로 설치할 수 있어요:\n\n```js\nnpm install -g express-generator\n```\n\n# 단계 2. Express 애플리케이션 생성하기:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nexpress-generator을 설치하셨으면 Express 애플리케이션을 생성할 수 있어요. 다음 명령어를 사용하여 옵션을 확인할 수 있어요:\n\n```js\nexpress -h\n```\n\n이렇게 하면 Express 애플리케이션 생성을 위한 가능한 옵션을 확인할 수 있어요.\n\n예를 들어, Pug 뷰 엔진을 사용하여 permify-rbac-app이라는 Express 앱을 생성하려면 다음과 같이 실행할 수 있어요.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nexpress --view=pug permify-rbac-app\n```\n\n이 명령어는 현재 작업 디렉토리에 permify-rbac-app이라는 폴더를 생성하고 Express 애플리케이션에 필요한 파일과 폴더를 함께 만듭니다.\n\n# 단계 3. 종속성 설치:\n\n새로 만든 Express 애플리케이션 디렉토리로 이동하세요:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\ncd permify-rbac-app\n```\n\n그런 다음 npm을 사용하여 프로젝트 종속성을 설치하세요:\n\n```js\nnpm install express && npm install @permify-node\n```\n\n# 단계 4. Express 애플리케이션 시작하기:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nMacOS 또는 Linux에서는 다음 명령어로 앱을 시작할 수 있어요:\n\n```js\nDEBUG=permify-rbac-app:* npm start\n```\n\n# 단계 5. 애플리케이션에 액세스하기:\n\nExpress 애플리케이션이 실행되면 브라우저에서 http://localhost:3000/을 통해 액세스할 수 있어요.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 디렉토리 구조:\n\n생성된 Express 애플리케이션은 다음과 같은 디렉토리 구조를 가지게 됩니다:\n\n```js\npermify-rbac-app/\n├── app.js\n├── bin/\n│   └── www\n├── package.json\n├── public/\n│   ├── images/\n│   ├── javascripts/\n│   └── stylesheets/\n│       └── style.css\n├── routes/\n│   ├── index.js\n│   └── users.js\n└── views/\n    ├── error.pug\n    ├── index.pug\n    └── layout.pug\n```\n\n이 구조에는 주요 애플리케이션 파일(app.js), 서버 구성(bin/www), 라우트(routes), 뷰(views), 공용 에셋(public assets), 그리고 프로젝트 종속성이 포함된 package.json 파일이 포함되어 있습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nExpress.js 프로젝트를 설정했으니, 이제 Express 애플리케이션에 RBAC를 구현해 보겠습니다.\n\n# Node.js 및 Express에서 RBAC 구현하기\n\nNode.js 및 Express 애플리케이션에 Role-Based Access Control (RBAC)을 구현하는 것에는 몇 가지 단계가 연루됩니다. 다음은 기본적인 구현 방법입니다:\n\n# 단계 1: Permify를 사용하여 RBAC 모델 설계하기\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nPermify는 개방 소스 권한 부여 서비스로, 개발자들이 권한 시스템을 만들 수 있게 합니다. Permify를 이용하면 권한을 모델링하고, 환경에 중앙 권한 서비스를 만들어 애플리케이션 및 서비스에서 액세스 확인을 수행할 수 있습니다.\n\n이를 위해 클라이언트 SDKs를 제공하여, 미들웨어에 추가하여 접근 확인과 같은 권한 요청을 보낼 수 있습니다.\n\nPermify는 역할, 권한 및 관계를 정의하기 위한 강력한 도메인 특화 언어(DSL)를 제공합니다. Permify Playground를 활용하여 RBAC 모델을 실험하고 시각화할 수 있습니다.\n\n![이미지](/assets/img/2024-06-30-ImplementingRoleBasedAccessControlRBACinNodejsandExpressApp_1.png)\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 게시물에서는 귀하의 조직 내 사용자가 역할에 따라 문서에 액세스할 수 있는 간단한 파일 기반 권한 부여 시스템을 개발할 것입니다.\n\n행정자, 관리자 및 직원과 같은 다양한 역할은 파일을 보기, 편집 또는 삭제하는 데 서로 다른 수준의 액세스 권한을 가질 수 있습니다.\n\n## Permify DSL을 사용한 역할 및 권한 정의\n\n다음은 RBAC 모델을 위한 Permify DSL 스키마 예시입니다:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nentity user {} \n\nentity organization {\n    // roles \n    relation admin @user    \n    relation member @user    \n    relation manager @user    \n    relation agent @user  \n    \n    // organization files access permissions\n    permission view_files = admin or manager or (member not agent)\n    permission delete_file = admin \n    \n    // vendor files access permissions\n    permission view_vendor_files = admin or manager or agent\n    permission delete_vendor_file = agent\n}\n```\n\nRoles and Permissions:\n\n- Roles: The schema defines roles for the organization entity, including admin, member, manager, and agent. These roles determine the level of access and permissions users have within the organization.\n- Permissions: Actions such as `view_files`, `edit_files`, `delete_file`, `view_vendor_files`, `edit_vendor_files`, and `delete_vendor_file` define the specific permissions associated with each role. For example, only admins can delete organization files, while managers and members have different levels of access.\n\nResource Types:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 스키마는 조직 파일과 공급 업체 파일을 구별하여 각각의 권한 집합을 가지고 있습니다. 이는 응용 프로그램 내의 다른 유형의 리소스에 대한 접근을 세밀하게 제어할 수 있도록 합니다.\n\n이제 RBAC 스키마를 정의했으니 Permify Local Server를 설정하는 단계로 넘어갈 것입니다.\n\n# 단계 2: Docker를 사용하여 Permify Local Server 설정하기\n\nDocker는 컨테이너화된 환경을 제공함으로써 우리의 설정에서 중요한 역할을 합니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 환경은 모든 권한 쿼리를 처리하는 마이크로서비스인 Permify의 효율적인 작동을 위한 필수 요소입니다.\n\n이제 Docker Container를 사용하여 Permify Server를 설정하는 필요한 단계를 설명하겠습니다:\n\n## Docker Container를 사용하여 Permify Server 실행\n\n- 터미널 창을 열고 다음 명령을 실행하여 Permify Server Docker 이미지를 가져오고 컨테이너를 시작합니다:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\nsudo docker run -p 3476:3476 -p 3478:3478 ghcr.io/permify/permify serve\n\n\n이 명령어는 GitHub Container Registry에서 Permify Server 이미지를 다운로드하고 다음의 기본 설정으로 Permify, 저희의 권한 부여 서비스를 설정합니다:\n\n- REST API는 3476 포트에서 실행됩니다.\n- gRPC 서비스는 3478 포트에서 실행됩니다.\n- 권한 데이터는 컴퓨터 메모리에 저장됩니다.\n\n다음과 유사한 메시지가 표시됩니다:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n┌────────────────────────────────────────────────────────┐\r\n│                    Permify v0.9.5                      │\r\n│          Fine-grained Authorization Service            │\r\n│                                                        │\r\n│    docs: ............... https://docs.permify.co       │\r\n│    github: .. https://github.com/Permify/permify       │\r\n│    blog: ............... https://permify.co/blog       │\r\n│                                                        │\r\n└────────────────────────────────────────────────────────┘\r\ntime=2024-03-22T14:59:09.851Z level=INFO msg=\"🚀 starting permify service...\"\r\ntime=2024-03-22T14:59:09.851Z level=ERROR msg=\"Account ID is not set. Please fill in the Account ID for better support. Get your Account ID from https://permify.co/account\"\r\ntime=2024-03-22T14:59:09.859Z level=INFO msg=\"🚀 grpc server successfully started: 3478\"\r\ntime=2024-03-22T14:59:09.859Z level=INFO msg=\"🚀 invoker grpc server successfully started: 5000\"\r\ntime=2024-03-22T14:59:09.867Z level=INFO msg=\"🚀 http server successfully started: 3476\"\r\n\n\r\n## Permify 서버 확인\r\n\r\n컨테이너가 실행 중이면 health check endpoint에 액세스하여 Permify 서버가 정상적으로 작동하는지 확인할 수 있습니다. Postman을 열고 http://localhost:3476/healthz로 GET 요청을 보내세요. Permify 서버가 올바르게 실행 중이면 서비스가 건강한 것을 나타내는 응답을 볼 수 있어요.\r\n\r\n<img src=\"/assets/img/2024-06-30-ImplementingRoleBasedAccessControlRBACinNodejsandExpressApp_2.png\" />\r\n\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 이미지를 보면 Permify 서버가 작동 중이라는 것을 확인할 수 있습니다. 이제 Node.js 및 Express 애플리케이션에 통합하는 작업을 진행할 수 있습니다.\n\n# 단계 3: Permify Node.js 클라이언트 초기화\n\n이 튜토리얼에서는 Permify Node 클라이언트를 사용하여 응용 프로그램의 권한 부여를 제어합니다. Permify Swagger 문서에서 사용 가능한 엔드포인트 목록을 찾을 수 있습니다. 우리는 Permify의 접근 제어 체크를 사용하여 엔드포인트를 안전하게 보호할 것입니다.\n\n이제 클라이언트를 초기화해 봅시다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```javascript\n// create-tenant.js\nconst permify = require(\"@permify/permify-node\");\n\nconst client = new permify.grpc.newClient({\n    endpoint: \"localhost:3478\",\n})\n```\n\n# 단계 4: 권한 모델 구성\n\n이제 Permify 서버가 실행 중이므로 권한 모델을 구성해야 합니다. 이후에 테스트 액세스 확인을 수행할 준비가 될 것입니다.\n\n권한 모델을 구성하려면 생성한 스키마를 Permify에게 Permify schema.write 메서드를 사용하여 전송합니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n//create-schema.js\n\nconst permify = require(\"@permify/permify-node\");\n\nconst client = new permify.grpc.newClient({\n    endpoint: \"localhost:3478\",\n})\n\nclient.schema.write({\n    tenantId: \"t1\",\n    schema: \"entity user {} \\n\\nentity organization {\\n\\n    relation admin @user    \\n    relation member @user    \\n    relation manager @user    \\n    relation agent @user  \\n\\n    action view_files = admin or manager or (member not agent)\\n    action edit_files = admin or manager\\n    action delete_file = admin\\n    action view_vendor_files = admin or manager or agent\\n    action edit_vendor_files = admin or agent\\n    action delete_vendor_file = agent\\n\\n} \"\n}).then((response) => {\n    // handle response\n    console.log(response)\n})\n```\n\n위 코드는 Permify 라이브러리를 사용하여 새로운 스키마를 생성합니다.\n\n이 코드는 localhost의 3478 포트에서 실행 중인 Permify 서버에 연결하도록 구축되었으며, write 메서드를 호출하여 t1 테넌트를 위한 스키마를 정의합니다.\n\n이 스키마는 사용자 및 조직과 관련관계 및 작업과 같은 엔티티를 정의합니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 이 스크립트를 실행해 볼게요\n\n```js\nnode create-schema.js\n```\n\n![스크린샷 이미지](/assets/img/2024-06-30-ImplementingRoleBasedAccessControlRBACinNodejsandExpressApp_3.png)\n\n위 스크린샷에서 새로운 스키마가 Permify Node Js Client를 사용하여 성공적으로 구성되었음을 확인할 수 있어요.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만세! 🥳 Permify 권한 부여 서비스 설정을 성공적으로 마쳤어요. 이제 권한 모델이 설정되었고 사용할 준비가 끝났답니다!\n\n다음 단계에서는 액세스 제어를 위한 미들웨어를 만들 것입니다.\n\n# 단계 5: 액세스 제어 미들웨어 생성\n\n여기서는 Express 미들웨어를 개발해서 경로에 기반한 역할 기반 액세스 제어를 강제하는 방법을 한 예제로 보여줄게요.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nPermify 액세스 확인 엔드포인트를 미들웨어에 구현하여 보호된 리소스에 액세스하기 전에 사용자의 역할과 권한을 확인하는 방법도 배울 것입니다.\n\n```js\n// auth.js\n\n// Permify 클라이언트 가져오기\nconst permify = require('@permify/permify-node');\n\nconst client = new permify.grpc.newClient({\n  endpoint: \"localhost:3478\",\n});\n\n// 사용자의 권한을 확인하는 미들웨어 함수\nconst checkPermissions = (permissionType) => {\n  return async (req, res, next) => {\n    try {\n      // req.params.id가 존재하는지 확인\n      if (!req.params.id) {\n        throw new Error('요청 매개변수에서 사용자 ID가 누락되었습니다');\n      }\n\n      // 필요에 따라 permissionType을 문자열로 변환\n      const permTypeString = String(permissionType);\n\n      // Permify 확인 요청을 위한 데이터 준비\n      const checkRes = await client.permission.check({\n        tenantId: 't1',\n        metadata: {\n          schemaVersion: '',\n          snapToken: '',\n          depth: 20,\n        },\n        entity: {\n          type: 'organization',\n          id: \"1\",\n        },\n        permission: permTypeString, // 변환된 permissionType 사용\n        subject: {\n          type: 'user',\n          id: req.params.id,\n        },\n      });\n\n      if (checkRes.can === 1) {\n        // 사용자가 권한이 있는 경우\n        req.authorized = 'authorized';\n        next();\n      } else {\n        // 사용자가 권한이 없는 경우\n        req.authorized = 'not authorized';\n        next();\n      }\n    } catch (err) {\n      console.error('권한 확인 중 오류 발생:', err.message); // 실제 오류 메시지 기록\n      res.status(500).send(err.message); // 디버깅을 위해 실제 오류 메시지를 클라이언트로 보냄\n    }\n  };\n};\n\nmodule.exports = checkPermissions;\n```\n\n위 코드는 사용자 권한을 확인하기 위해 Permify 라이브러리를 활용한 checkPermission 미들웨어 함수를 구현하는 것을 목표로 구성되었습니다.\n\n실행시 요청 매개변수에서 사용자 ID를 추출하고, 필요에 따라 권한 유형을 문자열로 변환한 후, Permify의 \"permission.check\" 메서드를 사용하여 Permify 서버에 권한 확인 요청을 보냅니다. 권한이 부여된 경우 요청 객체에 \"authorized\"를 추가하며, 그렇지 않은 경우 \"not authorized\"를 추가합니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n오류는 디버깅을 위해 더 자세히 기록되고 클라이언트에 반환됩니다.\n\n다음으로, 이전에 만든 미들웨어를 Node.js 및 Express 애플리케이션에 통합하여 역할 기반 접근 제어 (RBAC)를 강제하고 적절한 역할 및 권한이 있는 인증된 사용자만 특정 경로에 액세스할 수 있도록 보장할 것입니다.\n\n# 단계 6: RBAC로 경로 보호하기\n\n이제 만든 미들웨어를 사용하여 경로를 안전하게 만들어봅시다. 우리의 애플리케이션에서 다양한 경로를 보호하기 위해 checkPermissions 미들웨어를 적용할 것입니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\r\n// app.js\n\n// 필요한 모듈 가져오기\nconst express = require('express');\nconst permify = require(\"@permify/permify-node\");\nconst authMiddleware = require('./auth'); // 인증 미들웨어 가져오기\n\n// Express 앱 생성\nconst app = express();\n\n// userInfo를 채우는 사용자 지정 미들웨어 정의\napp.use((req, res, next) => {\n  // 사용자 인증 시뮬레이션 및 userInfo 채우기\n  req.userInfo = {\n    id: req.params.id // 요청 매개변수에서 id 추출\n    // 필요한 경우 다른 사용자 정보 추가\n  };\n  next();\n});\n\n// 라우트 정의\n\n// '/users/:id' 경로에 대한 권한 확인을 적용하려는 경우\napp.get('/users/viewFiles/:id', authMiddleware('view_files'), (req, res) => {\n  // 미들웨어가 요청을 통과시키면 라우트 로직 처리\n  if (req.authorized === 'authorized') {\n    res.send('이 사용자 경로에 액세스할 수 있습니다');\n  } else {\n    res.status(403).send('이 사용자 리소스에 액세스할 권한이 없습니다');\n  }\n});\n\n// '/admin/deleteVendorFiles/:id' 경로에 대한 권한 확인을 적용하려는 경우\napp.get('/admin/deleteVendorFiles/:id', authMiddleware('delete_vendor_file'), (req, res) => {\n  // 미들웨어가 요청을 통과시키면 라우트 로직 처리\n  if (req.authorized === 'authorized') {\n    res.send('이 관리자 경로에 액세스할 수 있습니다');\n  } else {\n    res.status(403).send('이 관리자 리소스에 액세스할 권한이 없습니다');\n  }\n});\n\n// 서버 시작\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n  console.log(`서버가 ${PORT}포트에서 실행 중입니다`);\n});\r\n```\n\n이 코드는 특정 라우트가 authMiddleware라는 사용자 지정 미들웨어를 사용하여 보호되는 Express 애플리케이션을 포트 3000에서 설정합니다.\n\n이 authMiddleware라는 미들웨어는 auth.js 파일에서 가져온 Permify와 통합하여 권한 확인을 수행합니다. 아래는 미들웨어에 의해 보호되는 라우트입니다;\n\nauthMiddleware에 의해 보호되는 라우트:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- /users/viewFiles/:id 경로: 이 경로는 파일을 볼 권한을 가진 사용자만 접근할 수 있도록 보장합니다.\n- /admin/viewFiles/:id 경로: 이 경로는 업체 파일을 삭제할 권한을 가진 관리자만 접근할 수 있도록 보장합니다.\n\n이러한 경로에 authMiddleware를 적용하여 Permify가 부여한 권한에 따라 접근이 제한됩니다.\n\n구현을 테스트해봅시다!\n\n# RBAC 구현 테스트\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 Markdown 형식으로 표를 작성하였습니다.\n\n\n| 사용자ID | 역할         | \n|--------|--------------|\n| alice  | 멤버         | \n\n\n이 표는 사용자 alice에게 멤버 역할을 부여하기 위한 Permify Nodejs 클라이언트의 data.write 메소드를 사용하는 예시 코드입니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그 코드를 실행하고 Postman을 사용하여 /users/viewFiles/ API 엔드포인트에 방문해 보세요.\n\n![image](/assets/img/2024-06-30-ImplementingRoleBasedAccessControlRBACinNodejsandExpressApp_5.png)\n\n이제 코드를 실행한 후 Alice는 /users/viewFiles/ API 엔드포인트에 성공적으로 액세스할 수 있습니다.\n\n# 결론\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n인가(authorization)가 한 번만 설정하는 것이 아니라 계속된 과정이라는 것을 인지하는 것이 중요합니다.\n\n따라서 모델을 정기적으로 검토하고 철저한 테스트를 수행하며 애플리케이션이 발전함에 따라 적응시키는 것이 중요합니다.\n\n이 가이드는 Node.js 애플리케이션에 RBAC(Role-Based Access Control)을 구현하는 데 튼튼한 기초 역할을 합니다.\n\n그러나 개별 요구 사항에 정확히 맞게 RBAC 모델을 맞춤화하는 데 더 심층적으로 파고들고 망설이지 마세요.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nPermify의 기능을 활용하면 권한 관리를 최적화하고 견고하고 안전한 애플리케이션 환경을 육성할 수 있어요.","ogImage":{"url":"/assets/img/2024-06-30-ImplementingRoleBasedAccessControlRBACinNodejsandExpressApp_0.png"},"coverImage":"/assets/img/2024-06-30-ImplementingRoleBasedAccessControlRBACinNodejsandExpressApp_0.png","tag":["Tech"],"readingTime":21},{"title":"JS 디자인 패턴 옵저버 사용법 이해하기","description":"","date":"2024-06-30 21:52","slug":"2024-06-30-JavascriptDesignPatternsObserver","content":"\n\n애플리케이션 내에서 상태를 관리하는 것은 시스템의 복잡성에 따라 매우 어려운 작업이 될 수 있습니다. 때때로 비동기 이벤트가 다른 이벤트에 영향을 받아 애플리케이션이 어떻게 동작해야 하는지를 결정하는 복잡한 규칙에 의존하는 시나리오에 놓일 수 있습니다. 한 요소의 변경이 입력에 따라 달라지는 변수에 의해 다른 요소에 변경을 일으킬 수도 있습니다.\n\n이러한 상황에서 옵저버 디자인 패턴을 적용하는 것이 흥미로운 아이디어일 수 있습니다. 디자인 패턴 서적에서 정의를 통해 설명해보겠습니다:\n\n일반적으로 변화를 \"전달\"하는 객체는 주체/Observable로 불리며, 통지를 받을 객체들은 옵저버들이라고 합니다.\n\n![이미지](/assets/img/2024-06-30-JavascriptDesignPatternsObserver_0.png)\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 간단한 VanillaJS Subject/Observable 만들기\n\n이러한 행동 패턴의 응용 프로그램을 더 잘 이해하기 위해 먼저 이 패턴이 어떻게 작동하는지 이해해야 합니다. 이를 위해 우리는 우리의 로직을 캡슐화 할 간단한 Subject 클래스를 만들 것입니다. 이 패턴의 여러 구현에서 공통으로 사용되는 몇 가지 용어를 사용할 것입니다:\n\n- 모든 옵저버에게 브로드캐스트될 값을 전달하려면 next 메서드를 사용하여 값을 전달합니다.\n- 변경 사항을 듣기 위해 옵저버를 만들려면 subscribe 메서드를 사용하여 옵저버를 전달하십시오.\n- 옵저버를 제거하여 Subject 변경 사항을 더 이상 듣지 않게하려면 해당 옵저버를 전달하고 unsubscribe 메서드를 호출하시면 됩니다.\n\n그리고 이로써 우리는 Subject의 기본 구조를 갖게 되었습니다. 이러한 시나리오에서, 그리고 자바스크립트에서 이 패턴의 일반적인 사용 사례에서도 Subject는 클래스로 구현되고 옵저버는 함수로 구현됩니다. 이 구현은 옵저버들에게 많은 유연성을 제공합니다. 함수로서 값들을 많은 방법으로 처리할 수 있기 때문에, 그리고 이전의 구현에 의존하지 않습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래에 주제와 수학 함수로 간주되는 관찰자가 있는 예시가 있습니다:\n\n이 코드 일부를 보려면 콘솔을 여는 것이 관찰자 패턴의 핵심입니다: 주 객체인 이 경우에는 number$ 변수가 여러 변수에 가입하고, 그런 다음 구독된 모든 변수에 값을 브로드캐스트하기 위해 next 호출을 보낼 수 있습니다.\n\n이제 RxJS를 사용하여 좀 더 복잡한 구현을 해보도록 하겠습니다.\n\n# RXjs로 파워 추가하기\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n복잡하고 많이 사용되는 패턴인 옵저버 디자인 패턴에서 자바스크립트의 Observable을 다루는 데 유용한 작업 세트와 도우미 메서드를 제공하는 RxJS 라이브러리가 있습니다. 보통 일상적인 옵저버 디자인 패턴 사용 사례에서 이 라이브러리와 상호 작용해야 할 수도 있습니다.\n\n이 예시를 가져와서 RxJS를 사용하여 슈퍼충전해 보겠습니다. 유저 포스트 UI를 만들겠지만 RxJS가 제공하는 다양한 기능을 활용할 것입니다.\n\nAPI 생성하기\n\nAPI를 만들기 위해 이 공개 엔드포인트를 사용할 것입니다. 포스트(Post), 유저(User) 및 코멘트(Comment) 엔드포인트를 사용할 것입니다. 이를 위해 각 포스트에는 유저 정보, 포스트 자체 및 댓글 정보가 있는 다른 소셜 미디어와 유사한 구조를 사용할 것입니다. 이로써 우리는 더 복잡한 예제를 만들 수 있게 되며 옵저버블의 옵저버블이나 고차 옵저버블과 같은 다양한 연산자들을 활용할 수 있게 됩니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nfrom 메서드를 사용하여 배열이나 프로미스와 같은 일반적인 소스에서 옵저버블 소스를 생성할 수 있습니다.\n\n이제 API를 갖게 됐으니, 입력 옵저버블과 포스트 옵저버블을 생성해보겠습니다.\n\n입력 옵저버블 생성하기\n\n그래서 애플리케이션 내에서 변수 상태를 만들기 위해, 간단한 숫자 입력을 사용하여 사용자 ID를 변경하고 싶을 것입니다. 입력은 디바운싱 및 범위 제한이 있어야 하며, 유효한 값은 1부터 10 사이여야 합니다. RxJS를 사용해서 어떻게 할 수 있을까요?\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n`fromEvent` 메서드를 사용하면 HTML 요소와 이벤트 이름을 전달하여 해당 이벤트에 따라 값을 방출하는 옵저버블을 반환할 수 있습니다. 그러니 우리는 입력 요소와 입력 이벤트를 사용해 보겠습니다. 이는 요소에 사용자 입력이 있을 때마다 발생할 것입니다.\n\n그 후에는 pipe 연산자와 RxJS 연산자 함수를 사용하여 최종 옵저버블을 얻도록 도와줄 수 있습니다. pipe 연산자를 사용하여 옵저버블이 방출하는 값을 연결하는 파이프로 생각하고, 파이프에 삽입된 각 메소드는 데이터를 변경하고 앞으로 전달합니다. 마치 가전제품과 수도 밸브처럼 파이프를 흐르는 물의 특성을 변경하는 것처럼, 각각이 다른 작업을 수행합니다.\n\n사용된 각 메소드를 살펴보겠습니다:\n\n- `map` 메소드는 일반적인 배열 메소드처럼 작동하여 값을 가져와 다른 값으로 반환합니다. 여기서는 이벤트를 가져와 값을 기준으로 정수를 반환할 것입니다.\n- `filter` 메소드는 일반적인 배열 상대로 작동하여 흐름에서 10 이하의 값만 방출하도록 합니다.\n- `debounceTime` 메소드는 값이 방출되고 300ms 이내에 다른 값이 방출된다면 그 사이 값은 무시되고 300ms 후의 마지막 값만 고려됩니다.\n- 마지막으로 `startWith`를 사용하면 초기 값이 1로 설정되어 처음 방출되기 전에 값이 됩니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그러면 최종적으로 파이프라인 결과가 준비됩니다. 사용자가 입력 이벤트를 발생시킬 때마다, 1과 10 사이의 숫자가 생성되며 다른 모든 숫자는 무시됩니다.\n\n## 게시물 옵저버블 생성\n\n이제 게시물이 있으면, 프로젝트의 가장 복잡한 부분이 될 것입니다. 사용자 및 해당 사용자의 게시물을 가져와야 합니다. 그 후 각 게시물에 대해 해당 게시물의 댓글을 가져와서 모든 내용을 묶어야 합니다.\n\n백엔드 솔루션으로는 이미 관련 데이터를 그룹화하는 다양한 DB 라이브러리와 패러다임이 지원되기 때문에 이 작업은 어렵지 않을 것입니다. 그러나 프론트엔드에서 이 작업을 수행하는 것은 어려울 수 있습니다. 왜냐하면 사용자 입력 로직도 함께 그룹화해야 하기 때문입니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 먼저, 입력 Observable을 연결하고 switchMap 연산자를 호출합니다. 이 연산자는 Observable을 가져와 자동으로 구독하여 결과를 반환합니다. 이 패턴에 대한 자세한 내용은 여기에서 확인할 수 있습니다;\n- switchMap 메서드에 공급될 Observable은 zip 도우미 함수를 사용하여 구축되며, 이 함수는 n개의 observables을 가져와 모든 작업이 완료된 후 응답의 배열을 방출하는 Observable을 반환합니다.\n- 이후에는 사용자 정보와 해당 사용자의 게시물을 반환해야 할 배열이 있지만, 여전히 각 게시물의 코멘트를 가져와 추가해야 합니다.\n\n이제 제대로 이해해 주세요, 조금 복잡해질 수 있습니다:\n\n- 먼저, 우리의 게시물을 위해 생성된 Observable 스트림으로 switchMap을 입력하여, 각 게시물이 Observable에서 방출되는 값이 됩니다;\n- 그 후에는 해당 Observable에서 나오는 각 게시물에 대해 mergeMap을 사용합니다. MergeMap을 사용하면 이전 Observable이 완료될 때까지 다음 Observable을 시작할 필요가 없도록 만듭니다. 여기서 중요한 이유는 각 게시물을 기다릴 필요가 없고, 모든 게시물이 완료되었을 때만 신경을 써야하기 때문입니다;\n- 이 mergeMap은 코멘트를 가져오고, 코멘트를 가져온 후에는 모든 값을 매핑하여 출력 객체를 생성합니다;\n- 그 후에는 toArray 메서드가 있습니다. 이 메서드는 Observable에 의해 방출된 모든 값을 배열로 다시 그룹화합니다;\n- 그 이후에는 값으로 UI를 채우는 문제만 남았습니다, 우리는 이를 템플릿 문자열과 tap 메서드를 사용하여 할 수 있습니다, 이를 side effect로 수행합니다;\n\n최종 결과는 아래에서 확인할 수 있습니다:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n테이블 태그를 마크다운 형식으로 변경해주세요.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nObservables는 일대다 관계와 복잡한 데이터 흐름이 있는 시나리오에서 가장 잘 사용됩니다. 응용 프로그램에 더 많은 보일러플레이트 코드를 추가하는데 항상 그 가치가 있는 것은 아닙니다.\n\n예를 들어, 복잡한 페이지네이션, 필터, 검색 및 기타 비동기 상호작용이 있는 프론트엔드를 구축할 때, 이벤트를 처리하고 필요한 변경 사항을 트리거하는 데 Observable을 사용하면 상태를 더 예측 가능하게 만들고 관리하기 쉬워집니다.\n\n단순한 HTTP 로그인 호출을 Observable로 변환하는 것은 간단한 메소드가 로직을 처리할 수 있을 때 과하게 느껴질 수 있습니다.\n\n핵심은 응용 프로그램 내에서 대가 균형을 평가하고 그에 따라 실행하는 것입니다. 조심히 사용해주세요.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 고지사항\n\n## 디자인 패턴에 대해 더 알아보기\n\n## 링크\n\n저를 팔로우하세요: https://medium.com/@dgramaciotti\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nLinkedIn: [다니엘 귀데스](https://www.linkedin.com/in/daniel-guedes-79a05a176/)\n\nGitHub: [dgramaciotti](https://github.com/dgramaciotti)\n\n이 글이 마음에 드셨나요? 좋아요를 눌러주시고 소셜 네트워크에서 공유해주세요!","ogImage":{"url":"/assets/img/2024-06-30-JavascriptDesignPatternsObserver_0.png"},"coverImage":"/assets/img/2024-06-30-JavascriptDesignPatternsObserver_0.png","tag":["Tech"],"readingTime":8},{"title":"Angular ControlValueAccessor를 사용하여 커스텀 타임시트 입력 만드는 방법","description":"","date":"2024-06-30 21:50","slug":"2024-06-30-CreateatimesheetcustominputinAngularwithControlValueAccessor","content":"\n\n\n![Image](/assets/img/2024-06-30-CreateatimesheetcustominputinAngularwithControlValueAccessor_0.png)\n\n# 소개\n\nAngular로 개발을 시작할 때, 매주 시간표를 작성하는 여러 입력 필드를 만들어야 하는 작업에서 어려움을 겪었습니다.\n\n주요 문제는 흔히 쓰이는 HH:MM 형식의 시간표 항목들을 계산을 위한 소수점 숫자 형식으로 계속 변환해야 했다는 점이었습니다. 또한 백엔드에서 받은 소수점 숫자를 다시 HH:MM 형식으로 변환하여 페이지 로드 중에 항목을 채우는 역 문제도 해결해야 했습니다.\n\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n처음에는 RxJs를 사용하여 문제를 해결했습니다. 그러나 이제 Angular 기능에 대해 더 자신감을 가지고 있으므로, 제 의견으로는 더 나은 캡슐화와 관심사 분리를 보장하는 다른 접근 방식을 시도해 보았습니다. 이 접근 방식은 ControlValueAccessor 인터페이스를 활용하여 사용자 정의 입력을 생성하고 사용자 정의 반응형 컨트롤을 만드는 것을 포함합니다.\n\n# ControlValueAccessor: 개요 및 구현된 메서드\n\nControlValueAccessor 인터페이스는 사용자 정의 폼 컨트롤과 Angular의 반응형 폼 API간의 통신을 가능하게 하는 네 가지 메서드를 구현할 필요가 있습니다. 이러한 메서드는 다음과 같습니다:\n\n- writeValue(newControlValue) → 이 메서드는 Angular 반응형 FormControl의 값이 변경될 때마다 호출됩니다. 그 목적은 모델에서 값이 업데이트되었음을 사용자 정의 컨트롤에 알리고, 뷰에 반영되어야 하는 경우에 호출됩니다. 예를 들어, writeValue() 메서드는 폼 컨트롤을 처음 초기화할 때 호출되거나(parentControl = new FormControl`number`(0, [Validators.required]) 또는 parentControl.setValue(4)와 같이 호출될 때 호출됩니다.\n- registerOnChange(fn) → 저의 의견으로는, 이 인터페이스에서 가장 이해하기 어려운 메서드입니다. FormControl이 처음 생성될 때, registerOnChange(fn)이 인수(fn이라는 관례적인 이름)와 함께 호출됩니다. 이 인수는 뷰에서 모델로 값이 변경되었음을 알리기 위해 호출해야 하는 함수입니다. 명확하게 하기 위해, 대부분의 경우 사용자 정의 폼 컨트롤에서 다음 단계를 구현해야 합니다:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 클래스 속성 내부에 fn 변수를 저장하여 나중에 사용자가 뷰의 입력 값을 업데이트할 때 호출할 수 있습니다.\n- 사용자가 값을 변경할 때 중단하는 로직을 구현합니다.\n- 이전에 저장한 클래스 속성에서 fn을 호출하여 새 값을 저장하도록 Angular FormControl에 통신합니다. 아래 예제를 참조하세요:\n\n```js\nexport class MyCustomInput implements ControlValueAccessor {\n//...other methods\n\n//onChange는 사용자가 값을 업데이트할 때 저장할 클래스 속성입니다.\nonChange!: (value: yourInputType) => void;\n\n//단계 1\nregisterOnChange(fn) {\n  this.onChange = fn;\n}\n\n//단계 2 (템플릿의 이벤트 바인딩)\nonUserInput(newUserValue: T) {\n  //단계 3\n  this.onChange(newUserValue);\n}\n```\n\n- registerOnTouched(fn) → registerOnChange()가 어떻게 작동하는지 이해하면, 이것도 아주 쉽습니다. 비슷하게 동작합니다: fn 콜백을 등록하고 클래스 속성에 저장한 다음, 부모 FormControl에 사용자 정의 컨트롤이 터치되었음을 통보하기 위해 호출합니다.\n- setDisableState(isDisabled) → 이 메서드의 구현은 선택 사항입니다. 부모 FormControl의 상태가 DISABLED와 다른 상태 사이에서 변경될 때마다(INVALID일지라도 컨트롤이 활성화된 것을 기억하세요), 이 메서드가 호출됩니다. 인수 isDisabled는 true일 때 부모 컨트롤의 disable() 함수가 호출될 때, false일 때 enable()이 호출될 때로 설정된 부울입니다.\n\n# ControlValueAccessor의 내 구현: 타임시트 입력\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 ControlValueAccessor가 어떻게 작동하는지 명확히 이해했으니 코드가 어떻게 동작하는지 확인해 봅시다. 제안 사항이 있으면 댓글로 알려주세요:\n\n```js\n//timehseet.component.ts\n  implements ControlValueAccessor, OnDestroy, AfterViewInit\n{\n  readonly #timeEntryRegex = /[0-2]*[0-9]+:[0-5]{1}([0-9]{1})?/;\n  #destroy: Subject<void> = new Subject();\n  #injector = inject(Injector);\n  #parentControl!: AbstractControl | null;\n\n  invalidClasses = input<string[]>();\n\n  innerControl = new FormControl<string>('', { updateOn: 'blur' });\n\n  isInvalid = false;\n  isDisabled = false;\n  isTouched = false;\n\n  onTouch: (() => void) | undefined;\n\n  writeValue(timeEntry: number | null): void {\n    this.innerControl.setValue(this.fromFloatToString(timeEntry));\n  }\n\n  registerOnChange(fn: any): void {\n    this.innerControl.valueChanges\n      .pipe(\n        takeUntil(this.#destroy),\n        tap(() => {\n          this.isTouched = true;\n          this.onTouch && this.onTouch();\n        }),\n        map((rawEntry) => this.convertEntry(rawEntry))\n      )\n      .subscribe((formattedEntry) => {\n        this.innerControl.setValue(\n          this.fromFloatToString(formattedEntry) || '',\n          {\n            emitEvent: false,\n          }\n        );\n\n        fn(formattedEntry);\n      });\n  }\n\n  registerOnTouched(fn: any): void {\n    this.onTouch = fn;\n  }\n\n  setDisabledState(isDisabled: boolean): void {\n    isDisabled ? this.innerControl.disable() : this.innerControl.enable();\n  }\n\n  markAsTouched() {\n    this.isTouched = true;\n    this.#parentControl?.updateValueAndValidity({\n      onlySelf: true,\n    });\n    this.onTouch && this.onTouch();\n  }\n\n  ngOnDestroy(): void {\n    this.#destroy.next();\n    this.#destroy.complete();\n  }\n\n  ngAfterViewInit(): void {\n    this.#parentControl = this.#injector.get(NgControl).control;\n\n    this.#parentControl?.statusChanges\n      .pipe(\n        takeUntil(this.#destroy),\n        filter(() => this.isTouched),\n        map((status) => status === 'INVALID'),\n        filter((isInvalid) => isInvalid !== this.isInvalid)\n      )\n      .subscribe((isInvalid: boolean) => {\n        this.isInvalid = isInvalid;\n      });\n  }\n\n  private convertEntry(rawEntry: string | null): number | null {\n    //문자열을 숫자로 변환하는 메서드. 유효한 경우에만 변환합니다.\n    //그렇지 않으면 null을 반환합니다.\n  }\n\n  private fromStringToFloat(timesheetEntry: string) {\n    //....\n  }\n\n  private fromFloatToString(entryHours: number | null) {\n   //...\n  }\n}\r\n```\n\n```js\n<!-- timesheet.component.html-->\n<input\n  [ngClass]=\"isInvalid ? invalidClasses() : ''\"\n  type=\"text\"\n  class=\"form-control\"\n  (blur)=\"markAsTouched()\"\n  [formControl]=\"innerControl\"\n/>\r\n```\n\n# 메모\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n보시다시피, 저는 기본적으로 timesheet entry의 텍스트 형식을 처리하는 inner FormControl을 생성했습니다.\n\n- 모델로부터 새로운 값이 도착하고 writeValue() 함수가 호출되면, fromFloatToString() 유틸리티 함수를 통해 값을 변환한 후 innerControl에 새 값을 설정합니다.\n- 사용자가 timesheet entry를 입력하면, 모든 가능한 입력 형식을 고려하여 float로 변환을 시도하고 (유효한 경우 3, 3:00, 3.0), formattedEntry 변수를 생성합니다. 그런 다음 innerControl 값을 HH:MM 형식으로 새로 생성된 값으로 설정하고 (입력된 값이 유효하지 않은 경우 빈 문자열로), 동시에 fn(formattedEntry)를 호출하여 formattedEntry에 의해 생성된 실수 번호를 가진 parentControl의 값을 업데이트하도록 부모 컨트롤을 통지합니다.\n- 코드에서 볼 수 있듯이, 이 경우에는 OnChange 함수를 저장하지 않습니다. 이는 구독 내부에서 매번 호출할 수 있기 때문입니다.\n- customInput의 providers 배열에 다음 코드를 추가하는 것을 잊지 마세요:\n\n```js\n@Component({\n  selector: 'app-timesheet-input',\n  standalone: true,\n  imports: [ReactiveFormsModule, NgClass],\n  templateUrl: './timesheet-input.component.html',\n  styleUrl: './timesheet-input.component.css',\n  providers: [\n    {\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => TimesheetInputComponent),\n      multi: true,\n    },\n  ],\n})\n```\n\n이 코드를 추가하면 사용자 정의 구성 요소가 formControlName 지시문을 받도록 설정됩니다. 사용자 정의 formControl의 DI에 대한 자세한 정보는 이 리소스를 확인해주세요.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 최종 결과\n\n프로젝트의 완전한 버전을 보고 싶다면, 제 StackBlitz를 확인해보세요.\n\n# 감사의 말\n\n이 간단하지만 중요한 프로젝트의 코드 가독성과 효율성을 향상시키는 데 도움을 주신 팔리오 비온디와 그의 텔레그램 커뮤니티에 특별히 감사드립니다.","ogImage":{"url":"/assets/img/2024-06-30-CreateatimesheetcustominputinAngularwithControlValueAccessor_0.png"},"coverImage":"/assets/img/2024-06-30-CreateatimesheetcustominputinAngularwithControlValueAccessor_0.png","tag":["Tech"],"readingTime":8},{"title":"SwiftUI 아키텍처 완벽 해부 1부","description":"","date":"2024-06-30 19:31","slug":"2024-06-30-DemystifyingSwiftUIArchitecturePartI","content":"\n\nSwiftUI를 처음 공부하기 시작했을 때, 처음 모바일 앱을 구조화하는 데 많은 시간을 소비했어요. 이 질문의 핵심은 관심사 분리와 모듈화에 있어요. 여기서, 나는 여러분이 시간, 에너지, 그리고 뇌 자원을 절약하는 데 도움이 될 것을 바라면서 제 발견을 소개할 거예요. 바로 시작해 볼까요?\n\n참고: 초보자부터 중급자용 복잡도 애플리케이션을 고려했어요. 내가 제공하는 포괄적인 개요와 강조된 미묘한 점들을 통해, 여러분은 더 관심 있는 구성 요소를 자세히 연구할 수 있겠죠.\n\n첫 번째 단계는 아키텍처 패턴을 결정하는 것이에요. MVVM (Model-View-View Model)은 제 추천이지만, 여러분의 프로젝트에 맞지 않는다면 다른 패턴을 선택하시길 권장해요. MVVM 아키텍처 패턴이 수업 및 실제 앱에서 널리 사용되기 때문에, MVVM 아키텍처를 구현하는 방법에 대해 다룬 자료가 풍부하게 있어요. 다른 가능한 아키텍처 패턴으로는 MVC, VIPER, RIBs가 있어요.\n\n오늘은 서비스 레이어를 갖춘 MVVM 아키텍처 패턴에 대해 이야기할 거예요.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 모델: 애플리케이션 뒤의 데이터 및 비즈니스 로직 기능을 나타냅니다. 모델은 일반적으로 클래스와/또는 구조체로 구성됩니다. 클래스 대신 구조체를 사용해야 하는지의 주된 차이점은 앱이 같은 객체를 전달하는지 (클래스) 또는 속성의 복사본을 사용하는지 (구조체)에 달려 있습니다. 클래스의 속성이 필요하지 않다면 구조체가 선호되는 데이터 구조입니다.\n\n- 뷰: 사용자에게 정보/그래픽을 표시하고 사용자로부터 입력을 받는 사용자 인터페이스입니다. 뷰는 애플리케이션의 데이터와 사용자 간의 양방향 통신 채널로 작동합니다.\n\n주요 뷰 구성 요소는 다음과 같습니다:\n- 컨테이너 (예: NavigationStack, List, Form, ScrollView, Group, Grid, TabView): 뷰 구성 요소를 함께 조합합니다\n- 스택 (예: HStack, VStack, ZStack): 구조화된 스택 뷰 내에서 컨트롤 및 디스플레이를 배치합니다\n- 컨트롤 (예: Button, Picker, TextField, Toggle, Slider): 사용자 입력을 수락합니다\n- 디스플레이 (예: Text, Image, Label): 사용자에게 정보를 표시합니다\n- 레이아웃 도구 (예: Spacer, Divider, GeometryReader): 더 정확하게 뷰 구성 요소를 배치하여 원하는 뷰를 달성합니다\n- 팝업 (예: Alert, Sheet): 현재 네비게이션 흐름에서 벗어나고 사용자에게 추가 뷰/정보를 표시합니다\n\n- 뷰 모델: 모델의 데이터와 뷰의 사용자 인터페이스 사이의 중개자 역할을 합니다. 뷰 모델은 Observable Object 프로토콜 (@ObservedObject / @StateObject)을 통해 애플리케이션의 상태를 관리하며, iOS 17부터 Observable Macro도 시작했습니다. Observable Object 프로토콜은 뷰 모델의 @Published 속성이 변경 사항을 뷰로 게시할 수 있게 합니다. 결과적으로 뷰는 관찰된 변경 사항에 기반하여 다시 그려집니다. 뷰 모델에는 또한 모델 데이터를 원하는 뷰 형식으로 변환하는 데이터 변환 함수와 서비스 계층과의 상호 작용을 관리하는 기능이 포함되어 있습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n— 서비스 레이어: MVVM 아키텍처 패턴 외부의 데이터 작업을 처리합니다. 데이터를 검색하거나 저장하고 응용 프로그램에 제3자 서비스/소프트웨어 패키지를 통합하는 등의 작업을 다루며, 이 내용은 이 게시물에서 다루지 않습니다.\n\n- API / URL을 통한 데이터 검색: 모바일 장치는 주로 저장 공간 한정과 보안 기능 때문에 외부 서버에 데이터를 저장합니다. 앱은 API / URL 호출을 통해 외부 데이터를 검색하며, 높은 오류 처리 능력을 갖추고 있습니다 (앱이 치명적 오류로 인해 충돌하는 것은 피해야 합니다). 데이터를 검색한 후, 이를 인코딩/디코딩하여 네트워크와 네이티브 뷰 모델 친화적인 데이터 형식으로 변환합니다.\n\n- 로컬 (UserDefaults) 및 외부 (Apple의 CoreData, Apple의 CloudKit, 제3자) 솔루션을 통한 데이터 유지: 사용자가 앱을 사용할 때, 앱 데이터가 세션 간에 유지되기를 기대합니다. UserDefaults는 사용자 환경설정 및 앱 설정을 저장하는 간단한 솔루션입니다. 데이터 유지 프레임워크/솔루션은 큰 데이터 세트를 저장하기 위해 필요합니다. CoreData는 Apple의 기본 데이터 유지 프레임워크로, 기본적으로 SQLite를 사용합니다. CoreData는 학습 곡선이 있지만 오프라인 기능, 캐싱, 고급 정렬/쿼리와 같은 내장 기능을 제공합니다. 다른 주목할 만한 솔루션으로는 Apple의 CloudKit이 있으며, Firebase와 Realm과 같은 제3자 솔루션이 있습니다.\n\n요약하자면, 모바일 앱 아키텍처는 실제로 관심사 분리 (MVVM + 서비스)와 각 레이어 내에서의 모듈화로 구축됩니다. 이 글이 유익했기를 바라며, 다음 시리즈도 기대해주시기 바랍니다!","ogImage":{"url":"/assets/img/2024-06-30-DemystifyingSwiftUIArchitecturePartI_0.png"},"coverImage":"/assets/img/2024-06-30-DemystifyingSwiftUIArchitecturePartI_0.png","tag":["Tech"],"readingTime":4},{"title":"GSoC 2024  OpenMRS 5주차  환자 생성 및 리소스 동기화","description":"","date":"2024-06-30 19:30","slug":"2024-06-30-GSoC2024OpenMRSWeek5PatientCreationSyncedResources","content":"\n\n안녕하세요 여러분! 🌟\n\n모두가 멋진 하루를 보내고 계시길 바랍니다! 이번 주는 몇 가지 중요한 발전이 있는 흥미로운 여정이었습니다. 강조할만한 부분을 알아보도록 하죠!\n\n![이미지](/assets/img/2024-06-30-GSoC2024OpenMRSWeek5PatientCreationSyncedResources_0.png)\n\n# OpenMRS에서 FHIR 엔드포인트를 활용한 환자 생성 🏥\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n환자를 만드는 도전에 도전 중이었어요. 특히 FHIR 엔드포인트를 사용하는 것이 너무 어려웠어요. 이유는 Patient 리소스에 고유한 환자 식별자를 제공해야 했기 때문이에요. 저희의 여정을 간략히 소개할게요:\n\n# 시도한 방법:\n\n- Idgen 엔드포인트 방법: 이 방법은 idgen 엔드포인트를 호출하여 고유한 ID를 생성하고 이를 환자 리소스 페이로드와 함께 포함하는 방법이었어요. 웹 앱에선 간단하지만 오프라인 우선 애플리케이션에는 최적이 아니었어요.\n- HSU ID 방법: 이 방법은 요청 페이로드에 위치 ID를 사용하여 엔드포인트를 호출하여 세션 ID를 가져오는 것을 요구했어요. 이 세션 ID에는 사용자의 위치 정보가 포함되어 있어 쿠키로 전달되어야 했어요. 그러나 RESTful API에 대한 세션 유지는 이상적이지 않았어요.\n- Legacy-ID 식별자 솔루션: 마침내 legacy-id 식별자를 사용하기로 결정했어요. 이 방법은 값만 필요로 하기 때문에 UUID를 제공하여 고유성을 보장할 수 있어요. 연간 약 10만 명의 사용자에게 안전한 방법이에요.\n\n# 예시 FHIR 환자 리소스:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n엔드포인트:\n\n![img](/assets/img/2024-06-30-GSoC2024OpenMRSWeek5PatientCreationSyncedResources_1.png)\n\n리소스:\n\n```js\n{\n  \"resourceType\": \"Patient\",\n  \"meta\": {\n    \"versionId\": \"1\"\n  },\n  \"name\": [\n    {\n      \"use\": \"official\",\n      \"family\": \"Jane Doe\",\n      \"given\": [\n        \"10000032\"\n      ]\n    }\n  ],\n  \"gender\": \"female\",\n  \"birthDate\": \"1928-05-06\",\n  \"identifier\": [\n    {\n      \"use\": \"official\",\n      \"type\": {\n        \"text\": \"Legacy ID\"\n      },\n      \"value\": \"dd1819e6-b0b7-4286-8941-a82a0a0fceb0\"\n    }\n  ],\n  \"address\": [\n    {\n      \"use\": \"home\",\n      \"city\": \"Unknown City\",\n      \"state\": \"Unknown State\",\n      \"postalCode\": \"Unknown PostalCode\",\n      \"country\": \"Unknown Country\"\n    }\n  ],\n  \"active\": true,\n  \"deceasedBoolean\": false\n}\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 동기화된 자원 기능 🔄\n\n저희 애플리케이션에서 환자가 등록되면 로컬에 저장됩니다. 사용자가 서버와 동기화할 때만 환자가 업로드됩니다. 데이터 손실을 피하기 위해 사용자가 환자 데이터가 동기화되었는지 알 수 있어야 합니다.\n\n![이미지](/assets/img/2024-06-30-GSoC2024OpenMRSWeek5PatientCreationSyncedResources_2.png)\n\n# 구현 단계:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- Unsynced 환자 식별: 저는 FhirEngine의 localChanges API를 사용하여 동기화되지 않은 환자를 식별하기 위한 로직을 개발했습니다. 이 API는 FHIR 자원에 적용된 로컬 변경 목록을 반환합니다. 환자 목록을 가져온 후에는 각 환자에 대한 로컬 변경 목록이 비어 있는지 확인하여(동기화된 자원을 나타냄) 이 정보를 PatientItem의 isSynced 플래그로 저장합니다.\n- UI 업데이트: 이 데이터를 사용하여 UI가 동기화 상태를 적절하게 반영합니다.\n\n# PR 링크:\n\n여기서 구현 상세 내용을 확인하세요.\n\n# 다음 주 계획 🔧\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 환자 생성 테스트 및 통합: 환자 생성 프로세스가 매끄럽게 작동하는지 확인합니다.\n- 환자 편집 기능: 환자 편집 기능을 추가 및 개선합니다.\n- UI 업데이트: 더 많은 화면에서 사용자 인터페이스를 개선하여 더 나은 사용자 경험을 제공합니다.\n\n더 많은 업데이트를 기대해주시고, 이 흥미진진한 여정을 따라와 주셔서 감사합니다! 🎉\n\n독자 여러분, 읽어 주셔서 감사합니다! 저에게 문의할 사항이 있으시면 언제든지 연락해주세요! 특히 헬스케어, 풀스택 개발, FHIR, OpenMRS Android, Open Health Stack, 노래 추천 등이라면 더욱 환영합니다. 🎵\n\nLinkedIn이나 OpenMRS Talk에서 저를 찾아보시고 GitHub에서 제 프로젝트를 확인해보세요.","ogImage":{"url":"/assets/img/2024-06-30-GSoC2024OpenMRSWeek5PatientCreationSyncedResources_0.png"},"coverImage":"/assets/img/2024-06-30-GSoC2024OpenMRSWeek5PatientCreationSyncedResources_0.png","tag":["Tech"],"readingTime":4},{"title":"실시간 데이터 파이프라인 마스터하기 PostgreSQL에서 MinIO로 Strimzi Kafka Connect를 사용한 CDC 구현 방법  Part-1","description":"","date":"2024-06-30 19:28","slug":"2024-06-30-MasteringReal-TimeDataPipelinesImplementingCDCwithStrimziKafkaConnectfromPostgreSQLtoMinIOPart-1","content":"\n\n<img src=\"/assets/img/2024-06-30-MasteringReal-TimeDataPipelinesImplementingCDCwithStrimziKafkaConnectfromPostgreSQLtoMinIOPart-1_0.png\" />\n\n안녕하세요! 이번 기사 시리즈에서는 쿠버네티스 환경 내에서 Kafka를 활용한 Change Data Capture (CDC)의 세계로 여러분을 안내할 예정이에요. CDC의 기본 개념을 탐구하고 매력적인 장점을 발견하며 실용적인 구현 가이드를 안내할 거예요. 이 과정에서 Kafka 기반 CDC가 데이터 아키텍처를 혁신시킬 수 있는 실제 시나리오를 탐구해볼 거에요. 실시간 데이터 스트리밍 및 통합 방법을 변화시키기 위해 준비하세요!\n\n본 기사 시리즈는 이론적 통찰과 실용적인 구현 세부 사항을 제공하기 위해 세 가지 부분으로 구성되어 있어요.\n\n부분 1: 이론적 기초 및 일반 아키텍처 : 이 섹션에서는 Change Data Capture (CDC)의 기초 개념과 현대 데이터 아키텍처에서의 중요한 역할을 탐구할 거에요. Kafka를 사용하는 이점을 특히 Strimzi와 함께 사용하여 관계형 및 NoSQL 데이터베이스, 객체 스토리지 및 기타 데이터 저장소에서 실시간 데이터 변경을 캡처하는 중앙 스트리밍 플랫폼으로 사용하는 것의 이점에 대해 논의할 거에요. 이 부분은 CDC 개념을 설명하고 Kafka Connect 클러스터 아키텍처를 심층적으로 살펴보며 CDC의 사용 사례 시나리오를 강조할 거에요. 이론적 기초를 이해함으로써 효율적이고 확장 가능한 데이터 파이프라인을 가능하게 하는 CDC의 중요성을 이해할 수 있으며, 이후 섹션에서의 실제 구현을 위한 준비를 할 수 있어요.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n부분 2: 실제 구현 — PostgreSQL에서 Kafka로 데이터 수집\n다음으로, 실제 구현 세부 사항을 살펴보겠습니다. PostgreSQL로부터 데이터 변경을 Kafka로 수집하도록 구성된 Kafka Connect 클러스터와 같은 Strimzi 리소스를 설정하는 방법을 배우게 됩니다. 저는 커넥터 설정 및 전체 설정을 Kubernetes에 배포하는 방법을 강조하면서 구성 단계를 안내해 드리겠습니다.\n\n부분 3: 실제 구현 — Kafka에서 MinIO로 Apache Parquet 형식으로 데이터 싱크\n최종 부분은 데이터를 MinIO로 Apache Parquet 파일로 싱크하는 데 중점을 둡니다. 실시간 처리와 분석에 대비하여 준비된 데이터임을 보장합니다. 데이터 스키마 호환성과 무결성을 유지하기 위해 스키마 레지스트리를 활용하겠습니다. 이 부분에서는 데이터 싱크를 위한 Kafka 커넥터 구성, 데이터 형식 처리, 전체 솔루션을 Kubernetes에 배포하는 방법에 대한 세부 단계가 포함될 것입니다.\n\n이 글을 마치면, 카프카를 활용한 강력한 CDC 파이프라인을 Kubernetes 환경에서 효율적이고 확장 가능하게 구현하는 괜찮은 경험과 포괄적인 이해력을 얻게 될 것입니다. Part-1 주제를 계속해 보겠습니다.\n\n- Change Data Capture (CDC) 및 Kafka와의 중요성 소개\n- 사용 사례 시나리오\n- Strimzi Kafka란 무엇인가요?\n- Kafka Connect는 무엇인가요?\n- Kafka Connect 아키텍처\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## Kafka를 이용한 Change Data Capture(CDC)의 소개 및 중요성\n\n— Change Data Capture(CDC)란 무엇인가요?\n\nChange Data Capture(CDC)는 데이터베이스에서 데이터가 변경되는 것을 식별하고 캡처하는 프로세스로, 이러한 변경 사항이 실시간으로 다른 시스템으로 전파될 수 있도록 보장합니다.\n\n— 왜 Kafka와 CDC가 게임 체인저인가요?\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 실시간 데이터 처리: CDC with Kafka를 사용하면 데이터 변경을 계속 캡처하고 스트리밍하여 실시간으로 데이터를 사용 가능하게 하여 분석 및 의사 결정을 위한 즉각적인 데이터 이용이 가능합니다.\n- 확장성: Kafka의 분산 아키텍처는 고 처리량과 장애 허용성을 보장하여 여러 소스를 통해 대량의 데이터 변경을 처리하는 확장성을 가집니다.\n- 데이터 생성자와 소비자의 분리: Kafka는 중개자 역할을 수행하여 데이터 생성자(데이터베이스)와 데이터 소비자(어플리케이션 및 분석 플랫폼)를 분리하여 독립적인 확장과 개발을 용이하게 합니다.\n- 원활한 통합: Kafka Connect는 다양한 데이터 소스 및 싱크와 통합하기 위한 견고한 프레임워크를 제공하여 이질적인 시스템 간에 원활한 데이터 흐름을 보장합니다.\n- 데이터 일관성과 신뢰성: CDC에서 데이터 소스 수준에서 변경을 캡처함으로써 데이터 일관성과 신뢰성을 유지하여 분산 시스템 전반에 정확하고 최신의 데이터를 유지합니다.\n- 이벤트 주도 아키텍처: CDC with Kafka는 데이터 변경이 실시간 작업과 워크플로를 트리거하는 이벤트 주도 아키텍처를 지원하여 반응성과 자동화를 향상시킵니다.\n- 지연 시간 감소: CDC와 Kafka를 사용하면 데이터 생성과 사용 가능성 사이의 지연 시간이 최소화되어 근사 실시간 분석과 운영 지능을 지원합니다.\n- 과거 데이터 재생: Kafka의 데이터 변경 저장 및 재생 기능을 통해 과거 데이터 분석 및 복구가 가능하여 유용한 통찰력을 제공하고 시나리오의 백테스팅이 가능합니다.\n- 비용 효율성: Kafka의 효율적인 데이터 스트리밍 기능을 활용함으로써 조직은 전통적인 배치 처리와 ETL 작업에 관련된 오버헤드와 복잡성을 줄일 수 있습니다.\n\n## 사용 사례 시나리오\n\n아래 시나리오에서 CDC와 Kafka를 사용하면 실시간 데이터 통합, 향상된 효율성 및 확장성을 제공하여 중요한 데이터가 항상 최신 상태로 여러 시스템 및 어플리케이션에서 접근 가능하도록 보장할 수 있습니다.\n\n1-) 실시간 재고 관리 시스템: 소매 회사가 여러 창고와 상점 전반에 걸쳐 실시간으로 재고를 최신 상태로 유지해야 하는 경우.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n— Kafka를 이용한 CDC의 장점:\n\n- 실시간 업데이트: 재고 데이터가 지속적으로 업데이트되어 모든 위치에서 재고 부족 또는 과잉 상황을 방지합니다.\n- 확장성: 대량의 데이터를 효율적으로 처리하는 Kafka의 능력은 소매 환경에서 일반적인 높은 거래율을 지원합니다.\n- 통합성: 관계형 및 NoSQL 데이터베이스 및 어플리케이션과 원활하게 통합되어 전체 시스템 내에서 데이터 일관성과 정확도를 보장합니다.\n\n2-) 고객 활동 추적 시스템: 전자상거래 플랫폼은 고객 활동(페이지 조회, 제품 클릭, 구매 등)을 실시간으로 추적하여 맞춤형 추천을 제공하고자 합니다.\n\n— Kafka를 이용한 CDC의 장점:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 즉각적인 통찰력: 실시간으로 고객 활동을 캡처하고 처리하여 적시적이고 관련성 있는 추천을 제공합니다.\n- 향상된 사용자 경험: 실시간 데이터를 활용하여 플랫폼이 맞춤형 쇼핑 경험을 제공하여 고객 만족도와 참여도를 높일 수 있습니다.\n- 유연성: Kafka의 Apache Flink와 같은 처리 프레임워크와의 통합을 통해 복합 이벤트 처리와 분석이 가능합니다.\n\n3-) 재무 거래 모니터링: 은행은 사기를 탐지하고 통찰력을 제공하기 위해 실시간으로 재무 거래를 모니터링하고 분석하려고 합니다.\n\n— Kafka와 CDC의 혜택:\n\n- 사기 탐지: 실시간 모니터링을 통해 의심스러운 활동을 즉각적으로 감지하여 사기 거래의 위험을 줄입니다.\n- 규정 준수: 모든 거래 데이터가 정확하고 즉각적으로 기록되도록 보장하여 은행이 규제 요건을 충족할 수 있습니다.\n- 확장성과 신뢰성: Kafka의 고장 내성 아키텍처를 통해 고부하 조건에서도 지속적인 데이터 흐름과 처리가 가능합니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n4-) 주문 처리 시스템: 온라인 상점이 주문 변경에 실시간으로 반응해야 하는 여러 서비스를 통합하여 주문 처리를 최적화하고자 합니다.\n\n— 카프카를 활용한 변경 데이터 캡처(CDC)의 장점:\n\n- 효율성: 실시간 데이터 흐름을 통해 주문 관련 서비스(재고 업데이트, 알림, 배송)가 신속하게 실행되어 처리 시간을 단축시킵니다.\n- 조정: 카프카를 통해 서로 다른 마이크로서비스가 주문 변경을 소비하고 독립적으로 움직이면서도 일관되게 작동하여 전체 시스템의 효율성을 향상시킵니다.\n- 일관성: 모든 서비스 간의 데이터 일관성을 유지하여 정확한 주문 추적과 충족을 보장합니다.\n\n5-) 사용자 프로필 동기화: 소셜 미디어 플랫폼이 실시간으로 여러 시스템 간에 사용자 프로필을 동기화해야 합니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n— Kafka와 함께 CDC의 이점:\n\n- 일관성: 사용자 프로필 변경 사항이 모든 시스템에 즉시 전파되어 일관된 사용자 경험을 유지합니다.\n- 통합: Kafka의 다양성은 검색 인덱스, 추천 엔진 및 캐싱 레이어와 같은 다양한 하향 시스템과의 데이터 동기화를 원활하게 수행할 수 있습니다.\n- 확장성: 소셜 미디어 플랫폼에서 일반적인 프로필 변경의 대량 처리를 다룰 수 있어 신뢰할 수 있고 효율적인 데이터 동기화를 보장합니다.\n\n## Strimzi Kafka란\n\nStrimzi Kafka는 Kubernetes에서 Apache Kafka의 배포, 관리 및 운영을 간소화하는 오픈소스 프로젝트입니다. Strimzi는 Kafka 클러스터를 생성하고 관리하기 위한 Kubernetes 네이티브 자원과 도구를 제공하여 Kafka를 클라우드 네이티브 환경에서 실행하기 쉽도록 합니다. 자동화된 배포, 스케일링, 롤링 업데이트 및 모니터링과 같은 주요 기능을 포함하여 사용자는 Kubernetes의 확장 가능성과 탄력성을 활용하여 Kafka의 강력한 메시징 및 스트리밍 기능을 사용할 수 있습니다. Strimzi를 사용함으로써 기관은 기존 Kubernetes 인프라에 Kafka를 효율적으로 통합하여 데이터 스트리밍 및 처리 기능을 향상시킬 수 있습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 카프카 커넥트 및 커넥트 클러스터 아키텍처란\n\n카프카 커넥트는 카프카 브로커와 외부 시스템(예: 데이터베이스) 간의 데이터를 스트리밍하는 통합 툴킷입니다. 플러그인 아키텍처를 사용하여 커넥터를 구현하며, 이를 통해 다른 시스템에 연결하고 데이터를 조작하기 위한 구성 옵션을 제공합니다. 플러그인에는 커넥터, 데이터 컨버터 및 변환기가 포함됩니다. 커넥터는 특정 유형의 외부 시스템과 작동하며 해당 구성에 대한 스키마를 정의합니다. 카프카 커넥트에 구성을 제공하여 커넥터 인스턴스를 생성하고, 이를 통해 시스템 간 데이터 이동 작업을 정의합니다.\n\nStrimzi는 분산 모드에서 카프카 커넥트를 운영하며, 여러 워커 팟 간에 데이터 스트리밍 작업을 관리합니다. 각 커넥터는 개별 워커에서 실행되며 해당 작업은 워커 그룹에 분산되어 확장 가능한 파이프라인을 제공합니다. 각 워커는 별도의 팟으로 실행되어 오류 허용성이 향상됩니다. 작업의 수가 워커 수를 초과하는 경우, 각 워커에 여러 작업이 할당됩니다. 워커가 실패하면 해당 작업은 자동으로 활성 워커에 재할당되어 지속적인 작동이 보장됩니다.\n\n워커는 데이터를 소스 또는 대상 시스템에 적합한 다른 형식으로 변환합니다. 커넥터 구성에 따라, 워커는 변환기를 적용하여 변환 전에 메시지를 조정하는 경우도 있습니다(예: 데이터 필터링). 카프카 커넥트에는 내장 변환기가 있지만 필요한 경우 플러그인을 통해 추가 변환을 제공할 수도 있습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 Kafka Connect 클러스터 아키텍처의 소스를 살펴봅시다.\n\n![image](/assets/img/2024-06-30-MasteringReal-TimeDataPipelinesImplementingCDCwithStrimziKafkaConnectfromPostgreSQLtoMinIOPart-1_1.png)\n\n1-) 플러그인 구현:\n\n- 역할: 플러그인은 소스 커넥터를 위한 필요한 구현 자산을 제공합니다.\n- 세부 정보: Kafka Connect의 플러그인 아키텍처는 유연성과 확장성을 제공합니다. 플러그인은 커넥터 뿐만 아니라 변환기와 변환도 포함하며, 이러한 구성 요소를 통해 Kafka Connect가 다양한 외부 시스템과 상호 작용하고 필요한 대로 데이터를 조작할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n2-) Worker 및 Connector 초기화:\n\n- 역할: 단일 Worker가 소스 Connector 인스턴스를 초기화합니다.\n- 상세 내용: Worker는 Kafka Connect 클러스터의 기본 구성 요소입니다. 각 Worker 파드는 독립적으로 실행되어 설정의 분산 구조를 보장합니다. Connector가 인스턴스화되면 하나의 Worker가 이를 초기화하는 책임을 지며, 이로써 Connector가 올바르게 시작되고 수명 주기 동안 모니터링됩니다.\n\n3-) 작업 생성 및 분배:\n\n- 역할: 소스 Connector는 데이터를 스트리밍하기 위한 작업을 생성합니다.\n- 상세 내용: 초기화 후 Connector는 일련의 작업을 정의합니다. 이러한 작업은 실제 데이터 스트리밍을 처리하는 작업 단위입니다. 작업은 사용 가능한 Worker 간에 분산되어 부하를 균형 있게 분배하고 처리량을 극대화합니다. 작업의 개수는 일반적으로 워크로드 및 클러스터의 용량에 따라 정의됩니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n4-) 병렬 작업 실행:\n\n- 역할: 작업은 외부 데이터 시스템을 병렬로 폴링하여 레코드를 반환합니다.\n- 세부 내용: 각 작업은 독립적으로 작동하여 외부 소스 시스템에서 데이터를 폴링합니다. 이 병렬 실행은 데이터가 효율적으로 및 실시간으로 흡수되도록 보장합니다. 작업은 계속해서 외부 시스템을 폴링하여 새로운 데이터 변화가 신속히 포착되고 처리되도록 합니다.\n\n5-) 데이터 변환:\n\n- 역할: 변환은 레코드를 조정하여 필터링하거나 다시 레이블링합니다.\n- 세부 내용: 데이터가 Kafka로 변환되어 전송되기 전에 변환되어야 할 수 있습니다. 변환은 원치 않는 데이터를 필터링하거나 필드를 다시 레이블링하거나 다른 수정을 적용하는 데 사용될 수 있습니다. Kafka Connect는 내장된 변환을 지원하지만 사용자 정의 변환은 플러그인을 통해 추가할 수 있으며, 데이터가 처리되는 방식에 유연성을 제공합니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n6-) 데이터 변환:\n\n- 역할: 변환기는 레코드를 Kafka에서 사용할 수 있는 형식으로 변환합니다.\n- 상세: 변환기는 Kafka와 외부 시스템 간의 데이터를 직렬화하고 역직렬화하는 역할을 맡습니다. 이들은 데이터가 Kafka 토픽에 호환되는 형식으로 처리되도록 보장합니다. 일반적인 변환기에는 JSONConverter, AvroConverter 및 StringConverter가 포함됩니다. 이러한 변환기들은 데이터 형식의 번역을 처리하여 Kafka가 레코드를 저장하고 관리하는 것을 원활하게 만듭니다.\n\n7-) 커넥터 관리:\n\n- 역할: 소스 커넥터는 KafkaConnectors 또는 Kafka Connect API를 사용하여 관리됩니다.\n- 상세: Kafka Connectors의 관리는 Strimzi에서 제공하는 Kubernetes 사용자 정의 리소스인 KafkaConnectors 또는 Kafka Connect REST API를 통해 수행될 수 있습니다. 이러한 관리 인터페이스는 관리자가 커넥터와 작업을 생성, 구성 및 모니터링하여 데이터 통합 프로세스에 대한 전체 제어를 제공합니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이러한 구성 요소와 프로세스를 활용하면 Strimzi Kafka Connect는 견고하고 확장 가능한 데이터 스트리밍 파이프라인을 구축하여 다양한 시스템 간 실시간 데이터 통합 및 처리를 보장합니다.\n\n지금까지 모든 것이 잘 진행되었다면, Sink Kafka Connect 클러스터 아키텍처로 계속 진행합시다 :)\n\n![이미지](/assets/img/2024-06-30-MasteringReal-TimeDataPipelinesImplementingCDCwithStrimziKafkaConnectfromPostgreSQLtoMinIOPart-1_2.png)\n\n사실 대부분의 구성 요소가 소스 커넥트 클러스터와 유사한 기능을 수행합니다. 여기서의 차이점은 작업이 관련 Kafka 토픽에서 데이터를 폴링하고 변환 및 처리 프로세스를 거친 후 외부 데이터 시스템으로 데이터를 전송한다는 것입니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이론적 기초를 다지면서, 이제 실용적인 부분으로 진입할 준비가 되었습니다. 다가오는 섹션에서는 소망을 걸고 Kafka Connect 클러스터 설정에 실질적으로 착수할 것입니다. 먼저, PostgreSQL에서 데이터를 매끄럽게 수집하는 소스 Kafka Connect 클러스터를 생성할 것이며, 그 다음으로는 Kafka 토픽에서 데이터를 읽어 Apache Parquet 형식으로 MinIO에 저장하는 싱크 Kafka Connect 클러스터를 설정할 것입니다. 이것이 실제로 어떻게 이루어지는지 궁금하신가요? 이 구현 여정에 참여하려면 계속 읽어보세요 :)\n\nGithub : https://github.com/menendes\n\nLinkedin : https://www.linkedin.com/in/ibrahim-halil-koyuncu-b1030516a/","ogImage":{"url":"/assets/img/2024-06-30-MasteringReal-TimeDataPipelinesImplementingCDCwithStrimziKafkaConnectfromPostgreSQLtoMinIOPart-1_0.png"},"coverImage":"/assets/img/2024-06-30-MasteringReal-TimeDataPipelinesImplementingCDCwithStrimziKafkaConnectfromPostgreSQLtoMinIOPart-1_0.png","tag":["Tech"],"readingTime":13},{"title":"Docker 단계별 가이드 Reactjs 프로젝트를 Docker로 윈도우 환경에서 로컬 설정하는 방법","description":"","date":"2024-06-30 19:27","slug":"2024-06-30-Step-by-StepGuidetoDockerLocalSetuponWindowswithaDockerizedReactjsProject","content":"\n\n<img src=\"/assets/img/2024-06-30-Step-by-StepGuidetoDockerLocalSetuponWindowswithaDockerizedReactjsProject_0.png\" />\n\n소개:\n\n도커는 응용 프로그램을 격리된 컨테이너에 배포하고 관리하는 데 도움이 되는 강력한 도구입니다. 이 안내서는 Windows에서 도커를 설정하고 React.js 프로젝트를 도커화하는 방법을 안내하여 원할하고 효율적인 개발 워크플로우를 보장합니다.\n\n도커란 무엇인가요?\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n도커는 가벼운 격리 소프트웨어 컨테이너 내에서 애플리케이션을 배포하고 관리하는 자동화를 가능케하는 오픈 소스 플랫폼이에요. 이를 통해 응용 프로그램이 모든 환경에서 일관되게 실행되도록 보증하며, 모든 종속성을 캡슐화해요.\n\n도커 파일을 이해하고 계신가요?\n\n도커 파일(Dockerfile)은 도커 이미지를 빌드하는 방법에 대한 지시사항이 담긴 텍스트 파일이에요. 도커 이미지를 실행 가능한 이미지로 만들기 위해 기본 이미지, 애플리케이션 코드, 종속성 및 기타 설정을 지정해요.\n\n도커 이미지란 무엇인가요?\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이미지는 응용 프로그램을 실행하는 데 필요한 모든 것을 포함하는 가벼운, 독립적이고 실행 가능한 소프트웨어 패키지입니다. 코드, 런타임, 시스템 도구, 라이브러리 및 설정을 포함하여 응용 프로그램을 실행하는 데 필요한 모든 것이 포함되어 있습니다. Docker 이미지는 기본 이미지에서 생성되며 추가 구성 요소로 사용자 정의할 수 있습니다.\n\n도커 컨테이너란 무엇인가요?\n\n컨테이너는 응용 프로그램과 해당 종속성을 캡슐화하는 격리된 환경입니다. 각 컨테이너는 호스트 머신에서 격리된 프로세스로 실행되며 자체 파일 시스템, 네트워킹 및 리소스를 가지고 있습니다. 하나의 도커 이미지에서 여러 컨테이너를 생성할 수 있습니다.\n\n도커 컴포즈란 무엇인가요?\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n도커 Compose는 여러 개의 컨테이너로 구성된 애플리케이션을 정의하고 관리하는 도구입니다. 이를 사용하면 YAML 파일에서 여러 개의 컨테이너 설정 및 서로 통신하는 방식을 정의할 수 있습니다. 도커 Compose를 사용하면 복잡한 애플리케이션을 여러 개의 상호 연결된 컨테이너로 쉽게 실행할 수 있습니다.\n\n컨테이너 레지스트리란 무엇인가요?\n\n컨테이너 레지스트리는 컨테이너 이미지를 저장하고 공유하는 중앙 저장소입니다. 버전 관리 및 이미지 무결성을 보장하면서 컨테이너화된 애플리케이션을 안전하게 관리하고 배포할 수 있습니다. 예시로는 Docker Hub, Amazon ECR, Google Container Registry, Azure Container Registry 및 GitHub Container Registry 등이 있습니다.\n\nWindows에 Docker 설치 방법:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 도커 공식 문서인 Docker Docs를 방문해주세요.\n- 윈도우용 도커인 Docker Desktop을 다운로드하세요.\n- 윈도우에서 WSL을 구성하세요:\n\n  - \"Windows 기능 켜기 끄기\"를 검색하고 선택하세요.\n  - \"Windows 하이퍼바이저 플랫폼\"과 \"Windows용 하위 시스템 for Linux\"을 활성화하세요.\n  - 확인을 클릭하고 시스템을 다시 시작하세요.\n  - 문제가 발생하면 이 안내에 따라 WSL을 수동으로 구성하세요.\n\n4. 도커 데스크탑 설치하기:\n\n  - 다운로드한 Docker Desktop Installer.exe를 실행하세요.\n  - 설치 단계를 따라 진행하고 시스템을 재시작하세요.\n  - 자동으로 재시작하면 화면에 \"도커 구독 서비스 약정\" 대화상자가 나타납니다.\n  - 동의 버튼을 클릭하세요.\n  - 로그인하거나 로그인 없이 계속하세요.\n  - 도커 홈페이지에 오신 것을 환영합니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n5. 설치 검증하기:\n\n- 명령 프롬프트를 열고 도커가 올바르게 설치되었는지 확인하기 위해 docker version 및 images를 실행합니다.\n\n```js\ndocker version\n\ndocker images\n```\n\nReact.js 프로젝트 도커화하기:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- React.js 프로젝트를 생성하세요.\n- 개발용 도커 파일을 생성하세요:\n\n- React.js 프로젝트의 루트 디렉토리에 다음 내용을 가진 Dockerfile.dev을 생성하세요\n\n```js\nFROM node:alpine\nWORKDIR /app\nCOPY package.json /app\nRUN npm install\nCOPY . /app\nCMD [\"npm\", \"start\"]\n```\n\n3. .dockerignore 파일을 생성하세요:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- React.js 프로젝트의 루트 디렉토리에 다음 내용으로 .dockerignore 파일을 만들어주세요:\n\n```js\nnode_modules\nREADME.md\n.gitignore\n```\n\n4. Docker 이미지 빌드하기:\n\n```js\ndocker build -f Dockerfile.dev -t myapp .\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- docker build: 이 명령은 Docker에게 Dockerfile에 있는 지시사항을 기반으로 새 이미지를 생성하도록 지시합니다.\n- -f Dockerfile.dev: -f 플래그는 사용할 Dockerfile의 이름을 지정합니다. 이 경우에는 Dockerfile.dev입니다.\n- -t myapp: -t 플래그는 이미지에 이름을 태그합니다. 여기서 이미지는 myapp으로 태그됩니다.\n- .: 명령어 끝에 있는 점은 현재 디렉토리인 빌드 컨텍스트를 나타냅니다.\n\n5. Docker 이미지 실행:\n\n```js\ndocker ps\n```\n\n```js\ndocker run -it --name myProject -p 3000:3000 myapp\ndocker run -it -d --name myProject -p 3000:3000 myapp\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- -i (interactive): 상호작용 모드를 유지하여 STDIN을 닫지 않습니다. 이는 대화형 프로세스에 유용합니다.\n- -t (tty): 의사-TTY를 할당합니다. 이는 터미널 상호작용에 유용합니다.\n- -d: 이 플래그는 컨테이너를 백그라운드에서 실행하고 터미널을 차단하지 않는 분리된 모드로 실행합니다.\n- --name myProject: 이 플래그는 컨테이너에 이름을 지정하여 관리를 더 쉽게 합니다. 이 경우 컨테이너의 이름은 myProject입니다.\n- -p 3000:3000: 이 플래그는 호스트의 포트 3000을 컨테이너의 포트 3000에 매핑합니다. 형식은 호스트포트:컨테이너포트입니다. 이를 통해 컨테이너 내에서 실행 중인 애플리케이션에 호스트 머신의 포트 3000을 통해 액세스할 수 있습니다.\n\nYouTube 비디오:\n도커 + React js 설정 및 구성에 대한 상세한 단계는 아래 비디오 튜토리얼을 시청하세요:\n\n결론:\nDocker는 현대 개발자들에게 귀중한 도구로, 격리된 환경에서 애플리케이션을 관리하고 배포하는 효율적인 방법을 제공합니다. 이 안내를 따라오면 다음을 배울 수 있습니다:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- Dockerfiles, 이미지, 컨테이너, Docker Compose 및 컨테이너 레지스트리를 포함한 Docker의 기본 개념을 이해합니다.\n- WSL과 같은 필수 구성 요소를 올바르게 구성하여 Windows 기기에 Docker를 설치합니다.\n- React.js 프로젝트를 Docker화하여 일관된 이식 가능한 개발 환경을 활성화합니다.\n\n더 많은 DevOps 및 기술 관련 자습서와 통찰력을 기대해주세요!\n\n저작권 © 2024 MAC Tech Family, 판권 소유.","ogImage":{"url":"/assets/img/2024-06-30-Step-by-StepGuidetoDockerLocalSetuponWindowswithaDockerizedReactjsProject_0.png"},"coverImage":"/assets/img/2024-06-30-Step-by-StepGuidetoDockerLocalSetuponWindowswithaDockerizedReactjsProject_0.png","tag":["Tech"],"readingTime":7},{"title":"AWS Step Function을 사용한 직원 온보딩 프로세스 구축 방법","description":"","date":"2024-06-30 19:26","slug":"2024-06-30-BuildinganAWSStepFunctionforEmployeeOnboardingProcess","content":"\n\n이번 튜토리얼에서는 직원 입사 절차를 자동화하기 위해 AWS Step Function을 만들어보겠습니다. 이 과정에는 직원 레코드 작성, 문서 확인, 환영 이메일 발송, 필요 장비 할당 등이 포함됩니다.\n\n# 단계 1: 서버리스 프로젝트 설정하기\n\n먼저, Serverless Framework가 설치되어 있는지 확인하세요. 만약 없다면 npm을 사용하여 설치할 수 있습니다:\n\n```js\nnpm install -g serverless\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음으로 새로운 Serverless 프로젝트를 만들어보세요:\n\n```js\nserverless create --template aws-nodejs --path employee-onboarding\ncd employee-onboarding\n```\n\n# 단계 2: Serverless Step Functions 플러그인 설치하기\n\n프로젝트에 Serverless Step Functions 플러그인을 추가해보세요. 이 플러그인은 Serverless Framework를 사용하여 Step Functions을 정의하고 배포하는 데 필요합니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nnpm install --save serverless-step-functions\n```\n\n# 단계 3: Serverless Framework 구성\n\nserverless.yml 파일에서 서비스를 Step Functions 플러그인을 사용하도록 구성하고 AWS 리소스와 함수를 정의합니다.\n```js\nservice: employee-onboarding\nframeworkVersion: '3'\nprovider:\n  name: aws\n  runtime: nodejs18.x\n  stage: ${opt:stage, 'dev'}\n  region: us-east-1\n  iamRoleStatements:\n    - Effect: \"Allow\"\n      Action:\n        - \"dynamodb:*\"\n      Resource: !GetAtt EmployeeTable.Arn\n    - Effect: \"Allow\"\n      Action:\n        - \"sns:*\"\n      Resource: \"arn:aws:sns:us-east-1:*:NotifyEmployee\"\nfunctions:\n  createEmployeeRecord:\n    handler: handler.createEmployeeRecord\n    environment:\n      EMPLOYEE_TABLE: !Ref EmployeeTable\n  verifyDocuments:\n    handler: handler.verifyDocuments\n  sendWelcomeEmail:\n    handler: handler.sendWelcomeEmail\n  assignEquipment:\n    handler: handler.assignEquipment\nplugins:\n  - serverless-step-functions\nstepFunctions:\n  stateMachines:\n    EmployeeOnboardingStateMachine:\n      name: EmployeeOnboardingStateMachine\n      definition:\n        Comment: \"A state machine for onboarding new employees.\"\n        StartAt: CreateEmployeeRecord\n        States:\n          CreateEmployeeRecord:\n            Type: Task\n            Resource: !GetAtt createEmployeeRecord.Arn\n            ResultPath: \"$.employee\"\n            Next: VerifyDocuments\n          VerifyDocuments:\n            Type: Task\n            Resource: !GetAtt verifyDocuments.Arn\n            ResultPath: \"$.documentVerification\"\n            Next: DocumentCheck\n          DocumentCheck:\n            Type: Choice\n            Choices:\n              - Variable: \"$.documentVerification.status\"\n                StringEquals: \"verified\"\n                Next: SendWelcomeEmail\n            Default: DocumentError\n          DocumentError:\n            Type: Pass\n            Result: \"Document verification failed\"\n            End: true\n          SendWelcomeEmail:\n            Type: Task\n            Resource: !GetAtt sendWelcomeEmail.Arn\n            ResultPath: \"$.emailStatus\"\n            Next: AssignEquipment\n          AssignEquipment:\n            Type: Task\n            Resource: !GetAtt assignEquipment.Arn\n            ResultPath: \"$.equipmentStatus\"\n            End: true\nresources:\n  Resources:\n    EmployeeTable:\n      Type: AWS::DynamoDB::Table\n      Properties:\n        TableName: EmployeeTable-${self:provider.stage}\n        AttributeDefinitions:\n          - AttributeName: employeeId\n            AttributeType: S\n        KeySchema:\n          - AttributeName: employeeId\n            KeyType: HASH\n        BillingMode: PAY_PER_REQUEST\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 상태 머신의 자세한 설명\n\n## 1. CreateEmployeeRecord\n\n- 유형: 작업\n- createEmployeeRecord 람다 함수를 호출하여 작업 수행\n- 리소스: !GetAtt createEmployeeRecord.Arn\n- createEmployeeRecord 람다 함수의 ARN\n- ResultPath: $.employee\n- 이 작업의 출력을 상태 입력의 employee 필드에 저장\n\n- 다음: VerifyDocuments\n- 이 작업이 완료된 후 VerifyDocuments 상태로 전환\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 2. VerifyDocuments\n\n- verifyDocuments Lambda 기능을 호출하여 작업을 수행합니다.\n\n## 3. DocumentCheck\n\n- 유형: Choice\n- 변수 값에 따라 분기 로직을 추가합니다.\n- 선택지:\n  - documentVerification.status 필드를 평가합니다.\n  - 값이 확인된 경우 SendWelcomeEmail 상태로 전환합니다.\n  - 기본값: DocumentError\n  - 선택지와 일치하는 것이 없는 경우 DocumentError 상태로 전환합니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 4. DocumentError\n\n- 유형: Pass\n- 입력을 수정하지 않고 출력으로 전달합니다.\n- 결과: \"문서 검증 실패\"\n- 이 상태의 출력 값입니다.\n- 종료: true\n- 이 상태를 최종 상태로 표시합니다.\n\n## 5. SendWelcomeEmail\n\n- sendWelcomeEmail Lambda 함수를 호출하여 작업을 수행합니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 6. 장비할당\n\n- assignEquipment 람다 함수를 호출하여 작업을 수행합니다.\n\n# 단계 4: 람다 함수 구현\n\nhandler.js 파일을 만들어 람다 함수를 정의하세요.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n직원 레코드 생성\n\n```js\n'use strict';\nconst AWS = require('aws-sdk');\nconst docClient = new AWS.DynamoDB.DocumentClient();\nmodule.exports.createEmployeeRecord = async (event) => {\n  const EMPLOYEE_TABLE = process.env.EMPLOYEE_TABLE;\n  const employee = JSON.parse(event.body);\n  const params = {\n    TableName: EMPLOYEE_TABLE,\n    Item: {\n      employeeId: employee.employeeId,\n      name: employee.name,\n      role: employee.role,\n      email: employee.email,\n    },\n  };\n  await docClient.put(params).promise();\n  return {\n    statusCode: 200,\n    body: JSON.stringify(employee),\n  };\n};\n```\n\n문서 확인\n\n```js\nmodule.exports.verifyDocuments = async (event) => {\n  const { employeeId, documents } = JSON.parse(event.body);\n  const status = documents && documents.length > 0 ? 'verified' : 'unverified';\n  return {\n    statusCode: 200,\n    body: JSON.stringify({ employeeId, status }),\n  };\n};\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n↓\n\n웰컴 이메일 전송\n\n```js\nconst sns = new AWS.SNS();\nmodule.exports.sendWelcomeEmail = async (event) => {\n  const { email } = JSON.parse(event.body).employee;\n  const params = {\n    Message: '회사에 오신 것을 환영합니다!',\n    Subject: '환영합니다',\n    TopicArn: process.env.SNS_TOPIC_ARN,\n  };\n  await sns.publish(params).promise();\n  return {\n    statusCode: 200,\n    body: JSON.stringify({ status: '이메일 전송됨' }),\n  };\n};\n```\n\n장비 할당\n\n```js\nmodule.exports.assignEquipment = async (event) => {\n  const { employeeId } = JSON.parse(event.body);\n  // 장비 로직 여기에 작성\n  return {\n    statusCode: 200,\n    body: JSON.stringify({ status: '장비 할당됨', employeeId }),\n  };\n};\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 단계 4: 서버리스 서비스 배포하기\n\n서버리스.yml 파일 구성을 완료한 후 서버리스 서비스를 배포하세요. 이 단계에서는 람다 함수를 배포하고, DynamoDB 테이블과 같은 필요한 AWS 리소스를 생성하며, Step Functions 스테이트 머신을 배포합니다.\n\n```js\nserverless deploy\n```\n\n배포 중에는 서버리스 프레임워크가 제공된 설정에 따라 Step Functions 스테이트 머신을 만듭니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 단계 5: 상태 머신의 ARN 가져오기\n\n배포된 후에는 AWS 관리 콘솔 또는 CLI에서 Step Functions 상태 머신의 ARN (Amazon 리소스 이름)을 얻을 수 있습니다.\n\n# 단계 6: IAM 역할 문장 업데이트\n\nserverless.yml 파일의 IAM 역할 문장을 Step Functions 상태 머신의 ARN으로 업데이트하세요.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```yaml\niamRoleStatements:\n  - Effect: \"Allow\"\n    Action:\n      - \"states:*\"\n    Resource: \"arn:aws:states:us-east-1:123456789012:stateMachine:EmployeeOnboardingStateMachine\"\n```\n\n# 단계 7: 서버리스 서비스 다시 배포하기\n\nIAM 역할 문장을 업데이트한 후에 변경 사항을 적용하기 위해 서버리스 서비스를 다시 배포하세요.\n\n```sh\nserverless deploy\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 요약\n\n이 튜토리얼은 직원 온보딩 프로세스를 자동화하기 위한 AWS Step Function을 생성하는 방법을 보여줍니다. Serverless Framework와 Serverless Step Functions 플러그인을 활용하여 작업, 분기 논리, 오류 처리를 포함한 복잡한 워크플로우를 정의하고 배포하여 온보딩 프로세스를 효율적이고 확장 가능하게 만들 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-30-BuildinganAWSStepFunctionforEmployeeOnboardingProcess_0.png"},"coverImage":"/assets/img/2024-06-30-BuildinganAWSStepFunctionforEmployeeOnboardingProcess_0.png","tag":["Tech"],"readingTime":10},{"title":"TGE 및 Alpha Realm으로 가는 길 개척하는 방법","description":"","date":"2024-06-30 19:25","slug":"2024-06-30-ForgingthePathtoTGEandAlphaRealm","content":"\n\n![2024-06-30-ForgingthePathtoTGEandAlphaRealm_0](/assets/img/2024-06-30-ForgingthePathtoTGEandAlphaRealm_0.png)\n\n안녕하세요, KOKODI 워리어 여러분! 토큰 생성 이벤트(TGE)와 알파 릴리스를 향한 여정이 전속력으로 진행 중입니다. KOKODI 우주에서 무슨 일이 일어나고 있는지 함께 알아봐요!\n\n# 최신 업데이트 및 TGE\n\nBeam과의 파트너십을 발표해 기쁘게 생각합니다. 이를 통해 빠른 트랜잭션, 강화된 보안, 그리고 견고한 전리품 경제를 제공하게 되었습니다. 게다가 Merit Circle이 직접 투자자로 합류했습니다. Beam의 기술적 지원과 함께, KOKODI는 Merit Circle의 web3 게임에 대한 전문 지식, 혁신적인 프로젝트 지원에 대한 약속, 그리고 개발 자금을 확보하기 위한 1~2차 VCs의 접근을 통해 혜택을 받을 것입니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리는 가치 있는 연결과 명망 있는 파트너십을 구축하기 위해, 펌프 앤 덤프 스키마를 피하면서 투자자를 신중하게 선정합니다. 이 방식은 자금 조달 과정을 늦추기는 하지만 장기적인 성장과 성공에 중요한 역할을 합니다.\n\n장기적인 지속가능성에 대한 약속은 우리가 거래소 상장 전략을 재평가하게 되어, 단기간의 흥분보다는 지속 가능한 성장에 집중하고 있음을 의미합니다. 튼튼한 출시를 위해 TGE 창구를 올해 가을로 이동시켰습니다. 더 많은 세부사항을 기대해 주세요!\n\n# KOKODI 알파: 전투의 맛을 먼저 맛보세요\n\n2024년 11월에 KOKODI 알파가 출시됩니다! 여기에서 기대할 수 있는 것들입니다:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 4개의 종족 중 하나를 선택하여 독특한 캐릭터를 만들어보세요\n- 2가지 스릴 넘치는 게임 모드: 4대4 아레나 및 탈출 배틀 로얄\n- 경험치, 전리품 및 $KOKO 토큰을 획득하세요\n- 웹 상점에서 자산을 거래하세요\n- 친구를 초대하면 보상을 받을 수 있습니다\n- NFT 소유자를 위한 독점적인 코스메틱 보너스\n\n# KOKODI의 미래를 함께 만들어보세요\n\n알파 버전을 준비하기 위해 24/7 이용 가능한 4대4 아레나 모드가 포함된 테스트 빌드에 액세스 권한을 부여합니다. 이 테스트 단계는 게임 플레이, 게임 경제 기능을 개선하고 소중한 피드백을 수집하는 데 도움이 될 것입니다.\n\n## 주요 포인트:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 7월부터 11월 알파 릴리스까지 새로운 기능이 소개될 예정입니다.\n- 테스트 기능에는 XP 포인트, 웹 상점, 추천 시스템, 밸런스 조정, 그리고 개선된 그래픽이 포함되어 있습니다.\n- 추가 기능은 가능해질 때마다 공지될 예정입니다.\n\n## NFT 소유자를 위한 정보:\n\n- 모든 KOKODI NFT 소유자들은 테스트 빌드에 접속할 수 있습니다.\n- 적어도 하나의 KOKODI NFT를 소유하고 있다면, 디스코드에서 티켓을 제출하여 접속하세요.\n- 게임 밤과 개발자 스트림 중에도 테스트 버전을 플레이할 수 있습니다.\n\n지금 바로 접근 권한을 확보하세요! 데브, 커뮤니티 멤버, 특별 게스트와 함께 플레이할 수 있는 다가오는 이벤트에 참여해보세요. 다음 주에 다양한 기회가 기다리고 있어요!\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 다가오는 이벤트:\n\n- 게임 나이트: 7월 3일 수요일, 오후 6:00–8:00 CET\n- DevStream + 질의응답: 7월 5일 금요일, 오후 6:00–8:00 CET\n\n당신의 궁금증을 해결하고 싶다면 DevStream에 참여해주세요! 여기에서 질문을 제출하고 디스코드에서 시청하세요. 최고의 질문은 소셜 포인트를 획득하게 됩니다!\n\nKOKODI의 미래를 함께 만들 준비가 되었습니다. 여러분의 여정이 지금 시작됩니다!\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 코코디 소개\n\n코코디는 성인들이 버린 애니메이션 판타지 세계에 세팅된 서드 파티 액션 PvP 게임입니다. 이 게임에서 8세의 아이들이 서로와 몬스터들과 교전하여 근접 및 원거리 무기와 마법을 사용하여 사탕, 명성, 그리고 그들의 클랜을 위한 평판을 얻습니다.\n\n공식 코코디 x 빔 파트너십 발표 확인하기\n\n# 빔 소개\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n머릿말이 게이밍에 초점을 맞춘 블록체인인 Beam은 Merit Circle에서 최근 출시되었습니다. Beam은 게이머와 개발자가 모여 게이밍 산업의 미래를 함께 만들어가는 활기찬 커뮤니티 중심 생태계를 구현합니다.\n\nBeam에 대해 더 자세히 알아보세요.\n\n## Merit Circle 소개\n\nMerit Circle은 분산형 자율 조직(DAO)으로, 게이밍 산업의 미래를 형성하고 장려하는 조직입니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n웹3 게임 플랫폼 및 이니셔티브에 대해 알아보세요.\n\n메리트 서클에 대해 더 알아보기","ogImage":{"url":"/assets/img/2024-06-30-ForgingthePathtoTGEandAlphaRealm_0.png"},"coverImage":"/assets/img/2024-06-30-ForgingthePathtoTGEandAlphaRealm_0.png","tag":["Tech"],"readingTime":5}],"page":"7","totalPageCount":119,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true}