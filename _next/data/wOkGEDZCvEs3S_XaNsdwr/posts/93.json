{"pageProps":{"posts":[{"title":"1970년대 STEM 취업을 통해 엄마가 되기 위한 리스크를 감수하다","description":"","date":"2024-05-20 16:06","slug":"2024-05-20-RiskingBecomingaMomWith1970sSTEMEmployment","content":"\n![이미지](/assets/img/2024-05-20-RiskingBecomingaMomWith1970sSTEMEmployment_0.png)\n\n내 화학 학위는 주변 남성들과 동등한 지식을 갖고 있다는 것을 보여줬어요, 마치 \"오즈의 마법사\"에 나오는 스케어크로우처럼 말이에요. 하지만 그것은 1974년 직장에서의 성차별을 막아주지 않았죠. 당신은 2024년에 그것을 피할 수 있었나요?\n\n가족을 가정하면서 STEM 분야에서 무슨 일이 벌어지는지에 대해 생각해본 적이 있나요? 기본사항을 고려해봅시다. 화학 실험실에서 일할 때, 전기기계 장치를 사용할 때, 코딩에 오랜 시간을 할 때 오는 위험들은 한 몸만 책임져야 할 때는 견딜만했을 겁니다. 그렇지만 여신이 자라는 잠재적인 존재는 어떨까요? 그 가능성을 고려하여 어떤 선택을 했나요?\n\n어린이가 내 몸 안에서 자라는 것에 대해 고려하기 시작하면서, 실험실에서 수은 온도계를 사용하지 않았어요. (부서진 온도계에서 노출된 수은은 태아에게 유해합니다.) 다른 유독 화학물질을 다룰 때 장갑을 착용했죠. 당시에는 광전자 스펙트로포토미터가 난자에 영향을 줄 수도 있다는 생각이 들지 않았어요. 나는 \"충분히 안전하다\"고 느꼈었죠.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그 것은 잇따른 조심이 오늘처럼 소문되기 힘들었던, 실험실에서 임신이 매우 드물었기 때문이었습니다.\n\n하지만 저는 실험실에 들어가기까지 힘들었기 때문에 바쁘게 서두를 필요가 없었습니다. 1970년대에는 STEM 분야 직장에서 임신한 여성을 본 적이 없었습니다. 나의 어머니가 1950년대에 가르치는 직업에 종사했을 때와 같이, 임신의 결과로 일자리를 잃을 것이며, 최선의 경우에는 일부 \"질병 휴가\"와 애도의 표현을 받을 것임을 알고 있었습니다.\n\n이미 여성이 동료들과 침대를 바꾸어가며 잘 놀다가 속담들이 크게 퍼질 때만 문제가 될 수 있다는 것을 발견했습니다. 그러나 육아? 그것은 \"직장에 있는 남성들\"이 \"집에 있는 여성들\"에게 맡겨둔 일이었습니다. 그런 방식이 나의 앞으로 나아가는 방식이 되지는 않았습니다.\n\n남편과 함께 안전을 위해 피임을 그만두기로 결정했을 때, 실험실을 떠나기로 했습니다. 옛 친구들이 운영하는 \"광고 대행사\"에서 코딩을 하는 프리랜서 일을 찾았습니다. 이것은 정확히 창의적인 코딩은 아니었지만, 파일 내의 지정사항을 페이지에 원하는 출력물과 일치시키는 것이 목적이었습니다. 또한, 일부 작업은 종이신문을 준비하는 날에 밤에 이루어졌습니다. 문제 없어요 – 키보드를 주시고 시작하게 해주세요. 임신 초기 3개월 동안 가끔 키보드 위에서 잠들기도 했지만, 누군가는 항상 제게 다시 깨워주셨습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n거의 실수로 샘플을 뽑아봤는데, 내가 잘 다듬고 있는 글쓰기 기술이 뜻밖으로 도움이 되었어(3년 동안 연구실을 벗어나 키보드에서 멀어져 있을 때 하던 일 중의 하나야). 그래서 누군가의 책을 쓰기 시작했지. 사실 처음에는 그런 식으로 생각한 적이 없었어. 그냥 \"광고 대행사\"가 디자이너에게 제공하는 또 하나의 서비스 같은 거라 생각했지만, 나는 연구자의 열정으로 새로운 역할에 뛰어들었어. 게다가 디자이너가 텍스트와 이미지를 페이지의 새로운 코딩 형태로 바꾸는 모습에 매료되기도 했어. 그는 평면의 형태가 두 차원적인 과학으로 나타나는 걸 보여줬거든.\n\n한편으로는 화학 학위를 활용할 프리랜서 프로젝트도 찾고 있었어. 배가 부풀며 연구실에 다시 들어갈 수 있을 것 같진 않았지만, 가끔 이력서를 보내기도 했어.\n\n잡지 뒷면의 프리랜서 작가 광고를 훑어보던 어느 오후 - 전략적으로 정보를 나누어 올 때 우리의 랜드로버 여행 이야기를 통해 돈을 벌 수 있을 거라 생각하게 된 것 - 유망해 보이는 걸 하나 발견했어.\n\n어? 내가 할 수 있겠네. (당신도 할 수 있을 거야.)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n생각도 없이 광고에 있는 전화번호를 눌렀어요. 한 남자가 전화를 받았고, 그는 출판 회사에서 사무실에서 일할 필요가 없다고 내게 약속했어요 (원격 근무! 초기 버전, 그렇지?), 그리고 내 자격 요건을 물었어요.\n\n내 날이 갈수록 더 드러나는 7개월임임을 바라보고, 미래 소설의 비디오 폰이 아직 나오지 않은 것에 기뻐했어요.\n\n![이미지](/assets/img/2024-05-20-RiskingBecomingaMomWith1970sSTEMEmployment_1.png)\n\n# 종이 위에 있을 수 있지만, 그것은 진짜 화학이었어요\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그는 그것보다 몇 일 더 걸렸지만, 나에게는 맞는 일이었습니다. 나는 코딩이 많은 광고 회사에 어느 정도 사전 통보를 하고 싶었기 때문에 그것이 좋았고, 그래서 몇 일 동안 그들과 일하고자 했습니다. 여성 소유의 그 팀은 내가 임실이 어떻든 상관하지 않았습니다. 그들은 출산, 수유 등에 관한 책을 주었습니다. 멋지네요!\n\n그러나 나는 STEM 분야로 돌아가려 했습니다. 내가 이해하고 즐기는 화학에 깊이 파고든 것은 안도 였습니다. \"가족을 지원해야 하는지\", \"볼링 리그에 참여해야 하는지\" 물어보는 사람이 없어져서 안도가 되었습니다. 대신에 내 모든 교과서를 꺼내어 몇 권의 참고 자료를 줍고 사용했고, 그것들을 이용하여 소파 앞 테이블에서 일을 하게 되었습니다.\n\n겨울이 왔습니다. 산장을 둘러싼 눈이 내리기 시작했습니다. 내가 화학을 처음 가르치는 것처럼 화학을 다시 쓰는 데 빠져들었고, 그런 다음 나의 \"쪽지\"를 보내면서 가끔씩 수표가 도착했습니다. 그것은 하이테크는 아니었지만, 적어도 나는 여전히 \"STEM\"에 남아 있었습니다.\n\n50년이 지난 후에 생각할 때, 나는 가장 경쟁력 있는 분야에서 스스로를 증명했고 휴식을 취할 수 있다고 느꼈습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아주 추운 시멘트 블록 \"사냥캠프\"에서 임신하고, 북부 뉴저지의 두 피트 눈 폭풍을 파내며, 켈리시 병원까지 빠른 스노모바일 타고 이동해야 할지도 모를 상황에서 주의보를 보냈고, 다음 날 아기를 낳았던 세부사항은 알 필요 없긔. (모든 것이 잘 해결되었지만.) 그러나 그런 어려운 상황에 있을 때 \"베이비 대디\"가 며칠 후에 이야기한 것을 생각해보면,\n\n나는 확실히 그렇지 왜냐하면... 아직 저는 STEM 경력이 있고, 모든 것이 우편을 통해 이뤄지기 때문에 저도 엄마라는 것을 아무도 알 수 없어요.\n\n![이미지](/assets/img/2024-05-20-RiskingBecomingaMomWith1970sSTEMEmployment_2.png)\n\n# 그 코드에는 문제가 있어요\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n스릴러 소설 속의 반전을 좋아해요. 하지만 실제 삶에서는 조금... 노노. 내가 강의하던 화학교재를 재작성 중이었을 때, 노동력과 직접적인 면담이 전혀 없는 채 출판사가 예정된 대로 내 임금을 몇 달 동안 보내주지 않은 채 자금을 털어 파산 신청한 걸 알게 되었을 때의 반전은 좀 그랬어. 그때쯤에는 또 눈이 내리기 시작했는데, 이번에는 버몬트에서였어. 거기서는 눈이 일찍 시작되고 늦게 끝나며 쌓일 정도로 많아.\n\n그때 남편은 심각한 철학 서적을 쓰느라 몰락한 상태였고 (젠장, 또 다른 문제가), 집 밖에서 일하기를 거부하는데, 그에 반해 내가 쓰는 능력을 신문 보도로 돌렸어. 그랬더니 금방이면, 봉사자인 나는 태어난 지 얼마 안 된 우리 아이를 데리고 홍수에 참여해 불을 끄거나, 백 번째 팔찌를 뜯었어. 그것은 전문가다운 느낌을 주지 않았고, 마음을 노래할 수도 없게 했어.\n\n그래서 화학교재에 대한 무급 노동을 이력에 추가해 보내고, 거대한 전문 과학 출판사를 찾아내었어. 소속 없는 노동자를 선호하고, 당신의 전공을 알고 일을 시일내에 완료한다면 성별은 중요하지 않다는 걸 이미 알고 있었어. (게다가 그들의 임금은 규칙적으로 들어왔어.)\n\nUPS 소포를 통해 받은 대학원 수준과 석사 과정 자료를 따라가는 게 항상 쉽지만은 않았어. 나는 어린아이를 데리고 대학 도서관에 여행을 다녀 미적분을 넘어 높은 수학을 공부하거나 내 참고 도서관을 찾았어. 하지만 내가 이 일을 좋아하게 되었어. STEM 분야는 만일 당신이 내 빨간 연필이나 시험관이나 분광광도를 싫어하지 않았다면. (아마도 나는 \"산\"과 \"염기\"와 같은 용어를 아는 아이가 \"산\"과 \"염기\"를 섞을 수 있게 허용해야 한다고 주장하는 동네의 유일한 유아를 가지고 있었을 거야.)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-05-20-RiskingBecomingaMomWith1970sSTEMEmployment_3.png\" />\n\n당연히 연구소와 컴퓨터를 잃어 아쉽기도 했지만, 지금은 내가 복잡한 삶을 살아가는 시기라고 생각해서, 더 많은 과학 기반의 고객들과 노력을 더하면서 소설을 쓰기 시작하고 두 번째 임신까지 했어.\n\n이번에는 5월에 분만하게 되었고, 눈이 녹았을 때였어. 아기가 태어나고 나는 아침을 먹고 난 후에 아기를 무릎에 얹고 흔들의자에 앉아, 어린이가 나와 숫자 게임을 하면서, 테이블 위에 있는 반쯤 끝난 적색 연필로 쓰인 고분자 원고를 기다리고 있었어. 나는 그것이 조금 더 여유를 가질 수 있겠다고 생각했어.\n\n그러다가 문에 쾅 쾅 하는 소리가 들리더니 UPS 운송인이 독성학 저널을 위한 원고를 가져왔어. 좋아, 더 배울 것이 또 생겼군!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n내가 내 흔들 의자에서 외쳤어:\n\n내 속에 있는 담요로 싸인 새로운 작은 소년을 놓고 놀라고 있는 시선을 던지며, 갈색 군복의 젊은 남자가 옆으로 기울어 들어가서 묶여진 페이지들을 문을 통과시켰고 도망쳤어.\n\n# 어려운 시기와 주요 동향: 컴퓨터\n\n이 모든 일에 나의 파트너는 어디에 있었을까? 좋은 질문이네. 그는 철학 서적을 쓰고 스릴러를 쓰기 시작했어. 그러나 어찌됐건 둘 다에서 소득은 없었어. 결혼이 끝나는 이유가 아니었지만, 분명 도움이 되지는 않았어. 나는 돈이 부족한 삶의 어려운 경계에서, 멋진 두 아이를 키우며 부엌 기술을 꾸준히 했고, 내 STEM 편집과 글쓰기에서 벌어들일 수 있는 돈을 늘려가며 살았어.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Risking Becoming a Mom With 1970s STEM Employment](/assets/img/2024-05-20-RiskingBecomingaMomWith1970sSTEMEmployment_4.png)\n\n일이 조금 더 쉬워지기 시작했을 때, 전환점은 1985년으로 설명할 수 있어요: 엔지니어인 누나와 그녀의 맥을 중심으로하는 만능 동반자가 필요하다고 말하며 컴퓨터를 보내 준 해였어요.\n\n갑자기 북부 버몬트에서 방정식을 균형잡는 적적 선생님으로만 남아있던 저가 엔지니어링, 물리학 및 미생물학을 한 달에 모두 다루게 되었답니다. 그 후 몇 년 뒤에는 UPS 배송원이 매일 방문하는 것이 중닃으로 이전할 정도로 컴퓨터 네트워크를 통해서도 과제가 할당되기 시작했어요.\n\n그때쯤에는 제 아이들이 일하면서 단순히 식초와 베이킹 소다를 섞어보는 것에 만족하지 않았답니다 (클래식 산·염기 반응). 부엌 카운터에서 중합체를 만들고 가르쳐주기에 준비가 안 된 것 같아요 — 그러나 커모도 64로 코딩을 시작했어요. (그리고 곧이어 게임도.)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n내 삶의 황홀한 모험은 과학, 코딩, 수학, 그리고 해결책을 찾는 즐거움의 완전한 순환에서 그래프로 표현될 시작을 했다.\n\n![image](/assets/img/2024-05-20-RiskingBecomingaMomWith1970sSTEMEmployment_5.png)\n\n나는 STEM 경력에 매달린 내 모습을 마무리하며 주변의 변화를 보게 되었다. 손자 두 명은 남성으로 나타났지만, 원격 근무하는 아버지가 벤처 캐피털 스타트업을 위해 코딩하는 동안 기르기와 조화롭게 어울리는 걸 지켜봤다. 그들은 나의 경험하지 못한 것을 목도했다: 업무 생활에서 성별이 거의 중요치 않다는 것을.\n\n임신과 STEM 주변의 문제들이 해결된 것 같진 않다. 여전히 주변에 약초살포나 살충제를 뿌리는 기업들과 논쟁 중이다. 그들이 세대를 걸쳐 영향을 끼칠 수 있다는 것을 알기에. (STEM, 그 안에 모두가 있어요!) 반면에, 오늘의 연합은 우리를 더 강력하게 앞으로 나아가게 만든다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n변경 사항이 무엇인가요? 어디에서 괴로움을 느끼시나요? 태아가 있는 경우와 없는 경우 모두에게 안전하고 환영받는 STEM 직장을 만들기 위해 어떤 그룹이 도움이 될 것 같나요? (의견란을 사용하여 다른 사람들에게 당신이 생각하는 것에 대해 생각하게 하세요.)\n\n코딩이나 엔지니어링, 방정식 해결이나 원자와 화합물을 새로운 상호 작용으로 이끌어 내는 것, 변화를 이끈 힘은 우리의 손에 있습니다... 함께요.\n","ogImage":{"url":"/assets/img/2024-05-20-RiskingBecomingaMomWith1970sSTEMEmployment_0.png"},"coverImage":"/assets/img/2024-05-20-RiskingBecomingaMomWith1970sSTEMEmployment_0.png","tag":["Tech"],"readingTime":10},{"title":"마법 같은 우체통에서 발생하는 HTTP Parameter Pollution HPP 공격","description":"","date":"2024-05-20 16:04","slug":"2024-05-20-HTTPParameterPollutionHPPAttacksinamagicalmailbox","content":"\n![Magic Mailbox](/assets/img/2024-05-20-HTTPParameterPollutionHPPAttacksinamagicalmailbox_0.png)\n\n# H-PP란 무엇인가요?\n\n마법 같이 작동하는 우체통을 상상해보세요. 마법사에게 영감을 주는 편지를 보내는 우체통이 있습니다. 보내는 각 편지에는 \"쿠키 만들기\"나 \"방 청소하기\"와 같이 마법사에게 특별한 일을 할 것을 알려주는 지시사항을 적습니다. 이 지시사항을 파라미터라고 하는 종이에 기록합니다. 마법사에게 두 가지 이상의 일을 시키고 싶을 때는 \"쿠키 만들기\"와 \"방 청소하기\"와 같이 여러 개의 파라미터를 적습니다.\n\n그런데 어느 날 장난기 많은 친구가 장난을 치려고 합니다. 당신이 알아차리지 못하는 사이에 편지에 추가적인 지시 사항을 몰래 넣습니다. 그래서 \"쿠키 만들기\"와 \"방 청소하기\"만 있는 대신에 마법사가 \"쿠키 만들기\", \"멍멍이 키우기\", \"방 청소하기\"와 같이 추가 지시서를 받게 됩니다. 더 많은 지시사항 때문에 마법사가 헷갈리게 되고, 때로는 어떤 것을 따를지 모를 때도 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 이 음모적인 트릭은 HTTP 매개 변수 공격(HPP)과 비슷합니다. 이를 단계별로 분석해 보죠:\n\n## HTTP란 무엇인가요?\n\nHTTP (하이퍼텍스트 전송 프로토콜)은 인터넷을 위한 마법의 우편함 시스템과 비슷합니다. 이는 컴퓨터가 웹사이트와 소통하는 방법이죠. 웹사이트를 방문하거나 그곳에서 무언가를 하려고 할 때, 컴퓨터는 명령(매개 변수로 된 편지처럼)을 웹사이트 서버(마법사)에게 보냅니다.\n\n## 매개 변수란 무엇인가요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n파라미터는 웹 사이트 서버에 보내는 명령입니다. 무엇을 해야 하는지 알려줍니다. 예를 들어, 웹 사이트에서 \"고양이\"를 검색하려면, 파라미터는 이렇게 보일 수 있습니다: search=고양이. 이것은 서버에게 고양이에 대한 정보를 찾으라고 말해주는 것입니다.\n\n## HTTP 파라미터 오염(HPP)이란?\n\nHTTP 파라미터 오염은 교활한 공격자 (장난스러운 친구와 같은)가 서버에 보내는 메시지에 추가적인 파라미터를 추가하는 것입니다. 이렇게하면 서버가 혼란스러워질 수 있습니다. 어떤 지침을 따를지 모를 수 있습니다. 여러 가지 모순된 지침을 받아 어떤 것을 따를지 모르는 것과 비슷합니다.\n\n## HPP가 문제가 되는 이유?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n1. Serve에 혼란: 마법사가 뒤죽박죽된 지시를 받는 것처럼, 서버도 혼란스러워서 제대로 작동하지 않을 수 있습니다. 의도하지 않은 일을 할 수도 있습니다.\n\n2. 보안 위험: 공격자는 HPP를 사용하여 서버를 속여 민감한 정보를 드러내도록 할 수 있어, 서버에 접근할 수 없어야 할 곳으로 침입할 수 있습니다.\n\n3. 원하지 않는 작업: 공격자는 서버가 중요한 데이터를 삭제하거나 개인 정보에 접근하도록 하는 등 나쁜 작업을 수행할 수 있습니다.\n\n## HPP 공격은 어떻게 발생하나요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n1. 다중 매개변수 전송: 공격자는 동일한 이름을 가진 여러 매개변수를 서버로 보냅니다. 예를 들어, 단순히 search=cats가 아니라 search=cats&search=dogs와 같이 보낼 수 있습니다.\n\n2. 서버 동작 악용: 서로 다른 서버는 이러한 추가 매개변수를 다른 방식으로 처리합니다. 일부 서버는 중복을 무시할 수도 있고, 일부는 첫 번째 것을 선택할 수도 있으며, 다른 서버는 마지막 것을 선택할 수도 있습니다. 이러한 예측 불가능성이 바로 공격자가 악용하는 부분입니다.\n\n3. 악의적인 매개변수 삽입: 공격자는 추가 매개변수에 해로운 지시문을 포함합니다. 예를 들어, admin=true와 같이 서버를 속여 관리자로 인식하도록 시도할 수 있습니다.\n\n## HPP에 대한 어떻게 방어할 수 있을까요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n1. 입력 유효성 검사: 서버가 모든 들어오는 매개변수를 확인하고 정리하여 필요한 것들만 받아들이고 올바르게 포맷되었는지 확인해주세요.\n\n2. 매개변수 제한: 서버가 추가 매개변수를 무시하거나 중복을 일관되고 안전한 방식으로 처리하도록 설계해주세요.\n\n3. 보안 테스트: 정기적으로 웹사이트와 서버를 취약점을 확인하기 위해 테스트해주세요, 특히 많은 매개변수를 다루는 방식을 확인해봐주세요.\n\n## 결론\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nHTTP 매개변수 오염은 친구가 마법사에게 편지에 혼란스러운 추가 지시를 넣는 것과 같아요. 이는 마법사(서버)가 당신이 요청하지 않은 일을 하거나 심지어 나쁜 일을 할 수 있게 합니다. 이를 방지하기 위해 지시사항을 주의 깊게 확인하고 올바른 지시사항만 따르는 것이 중요해요.\n\n따라서, 장난꾸러기로부터 마법 사서함을 보호하듯이, 웹사이트는 이런 간굿한 속임수로부터 서버를 보호하여 모든 것이 원할하고 안전하게 유지되도록 해야 해요!\n\n## 일부 참고자료:\n\n- OWASP: HTTP 매개변수 오염에 대한 테스트\n- Portswigger: 서버측 매개변수 오염\n- HackTricks: 매개변수 오염\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다시 만나기까지, 행복한 마법을 부리세요!\n","ogImage":{"url":"/assets/img/2024-05-20-HTTPParameterPollutionHPPAttacksinamagicalmailbox_0.png"},"coverImage":"/assets/img/2024-05-20-HTTPParameterPollutionHPPAttacksinamagicalmailbox_0.png","tag":["Tech"],"readingTime":5},{"title":"자바 불변 객체에 관한 인터뷰 톱 질문","description":"","date":"2024-05-20 16:03","slug":"2024-05-20-JavaImmutabilitytopInterviewquestions","content":"\nby Abhishek Talakeri\n\n![Java Immutability Interview Questions](/assets/img/2024-05-20-JavaImmutabilitytopInterviewquestions_0.png)\n\n안녕하세요 여러분! 오늘은 자바 불변성 개념과 관련된 최상위 면접 질문을 탐구하며 명확한 설명과 간단한 예제를 제공할 것입니다. 이 자료는 면접 준비를 돕기 위해 특별히 설계되었습니다. 기술 면접을 되풀이하거나 이해를 향상시키려는 분들에게 유용한 자료가 되도록 이 시리즈는 여러분의 성공을 향한 여정에서 가치 있는 자산이 되도록 목표하고 있습니다.\n\n- 자바에서 불변 클래스란 무엇인가요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n자바에서 불변 클래스는 생성된 후 수정할 수 없는 인스턴스를 의미합니다. 불변 객체가 인스턴스화된 후에는 상태가 수명 동안 일정합니다. 이는 필드의 값이 변경될 수 없으며 값을 수정하려는 모든 시도는 새 개체의 생성으로 이어집니다.\n\n불변 클래스를 사용하는 장점은 무엇인가요?\n\n스레드 안전성: 불변 객체는 생성 후 상태 수정을 허용하지 않으므로 동기화 메커니즘이 필요하지 않아 스레드 안전성을 보장합니다.\n\n일관된 상태: 불변 객체는 존재하는 동안 일정한 상태를 유지하여 프로그램 동작을 명확히 이해하고 예상치 못한 상태 변경을 최소화합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n안전한 공유: 변경할 수 없는(Immutable) 객체는 여러 스레드 또는 컴포넌트 간 안전한 공유를 허용하여 코드의 재사용성과 의도하지 않은 수정의 위험이 없이 원활한 상호 운용성을 보장합니다.\n\n동시성 제어: 변경할 수 없는(Immutable) 객체는 복잡한 동시성 제어 메커니즘을 완화시켜 더 간단하고 확장 가능한 동시 프로그래밍 모델로 이끕니다.\n\n3. Java 표준 라이브러리에서 변경할 수 없는(Immutable) 클래스의 몇 가지 예시를 제공할 수 있나요?\n\ni. java.lang.String\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nii. java.lang.Integer, java.lang.Double, java.lang.Boolean 등\n\niii. java.lang.Character\n\niv. java.time.LocalDate, java.time.LocalDateTime, java.time.LocalTime\n\nv. java.time.Duration, java.time.Period\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nvi. java.math.BigInteger, java.math.BigDecimal\n\nvii. java.awt.Color\n\n4. 수정할 수 없는 클래스를 사용하는 잠재적인 단점은 무엇인가요?\n\n수정할 수 없는 클래스를 사용하면 스레드 안전성 및 예측 가능한 동작과 같은 이점이 있지만, 단점이 있을 수 있습니다. 이러한 단점으로는 각 수정마다 새 인스턴스를 생성하여 메모리 사용량이 증가하고 성능에 영향을 줄 수 있다는 것이 포함됩니다. 불변성은 코드 베이스에 복잡성을 추가하고 특정 시나리오에서 유연성을 제한할 수도 있습니다. 또한, 방어적 복사 오버헤드와 가비지 수집 문제가 발생할 수 있습니다. 그러나 많은 프로그래밍 시나리오에서 불변성의 장점이 이러한 단점을 능가하기도 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n5. 변경 빈번한 객체 상태 조작이 성능 또는 기능 상 필요한 시나리오에서는 불변성이 적합하지 않을 수 있습니다. 예를 들어, 비디오 스트리밍이나 게임과 같은 실시간 데이터 처리를 다루는 응용 프로그램에서는 반응성을 유지하기 위해 가변 상태에 대한 지속적인 업데이트가 필요한 경우가 있습니다. 또한 대규모 데이터 조작이나 복잡한 알고리즘이 포함된 시나리오에서 불변성은 메모리 사용량이 증가하고 성능 오버헤드가 발생할 수 있습니다. 마찬가지로 라이브러리나 프레임워크와 상호 운용성이 필수인 경우, 불변성은 최적의 선택이 아닐 수 있습니다.\n\n6. 불변 클래스를 설계할 때 주의해야 할 사항은 무엇인가요?\n\ni. 클래스를 Final로 선언: 클래스를 final로 선언하여 하위 클래스화를 방지하여 클래스의 동작이 변경되지 않도록 보장합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nii. 필드를 final로 선언해주세요: 객체 생성 후에는 수정할 수 없도록 모든 필드를 final로 선언해주세요.\n\niii. 필드를 private로 만들기: 필드를 private로 캡슐화하여, getter 메서드를 통해서만 제어된 접근을 허용해주세요.\n\niv. Setter 메서드를 제공하지 말기: 객체의 상태를 수정하는 Setter 메서드를 제공하지 않도록 지양해주세요. 그렇게 하면 불변성이 깨질 수 있습니다.\n\nv. 깊은 불변성 보장하기: 클래스가 변경 가능한 객체에 대한 참조를 포함하더라도 불변성을 유지하도록 보장해주세요. 필요에 따라 방어적 복사를 구현하거나 참조된 객체의 불변 버전을 사용해주세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nvi. Equals와 HashCode 재정의: 객체 상태에 기반하여 올바른 동작을 보장하기 위해 올바른 equals()와 hashCode() 메소드를 구현하세요.\n\n7. 변경되지 않은 개념을 구현하는 Java 클래스를 작성하십시오.\n\n```java\npublic final class BankAccount {\n\n  private final String accountNumber;\n  private final String accountHolderName;\n  private final double balance;\n\n  public BankAccount(String accountNumber, String accountHolderName, double balance) {\n    this.accountNumber = accountNumber;\n    this.accountHolderName = accountHolderName;\n    this.balance = balance;\n  }\n\n  public String getAccountNumber() {\n    return accountNumber;\n  }\n\n  public String getAccountHolderName() {\n    return accountHolderName;\n  }\n\n  public double getBalance() {\n    return balance;\n  }\n\n}\n```\n\n8. Date와 같은 가변 필드를 가진 불변 클래스에서 변경 불가성을 어떻게 보장하나요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```java\nimport java.util.Date;\n\npublic final class ImmutableWithMutableField {\n\n    private final int id;\n    private final Date date;\n\n    public ImmutableWithMutableField(int id, Date date) {\n\n        this.id = id;\n        this.date = new Date(date.getTime());\n    }\n\n    public int getId() {\n        return id;\n    }\n\n    public Date getDate() {\n        return new Date(date.getTime());\n    }\n\n    @Override\n    public String toString() {\n        return \"ImmutableWithMutableField [id=\" + id + \", date=\" + date + \"]\";\n    }\n\n    // testing\n\n    public static void main(String[] args) throws InterruptedException {\n\n        ImmutableWithMutableField a = new ImmutableWithMutableField(1, new Date());\n\n        System.out.println(a);\n        Thread.sleep(3000);\n        System.out.println(a);\n        Thread.sleep(1000);\n        ImmutableWithMutableField a1 = new ImmutableWithMutableField(1, new Date());\n        System.out.println(a1);\n        Thread.sleep(1000);\n        ImmutableWithMutableField a2 = new ImmutableWithMutableField(1, new Date());\n        System.out.println(a2);\n\n    }\n\n}\n```\n\nResult:\n\n![Image](/assets/img/2024-05-20-JavaImmutabilitytopInterviewquestions_1.png)\n\n9. Immutable 클래스 내에서 가변 컬렉션을 어떻게 처리하시겠습니까?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```java\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic final class ImmutableWithMutableCollection {\n\n    private final int id;\n    private final List<String> mutableList;\n\n    public ImmutableWithMutableCollection(int id, List<String> mutableList) {\n\n        this.id = id;\n        this.mutableList = new ArrayList<>(mutableList);\n    }\n\n    public int getId() {\n        return id;\n    }\n\n    public List<String> getMutableList() {\n        return Collections.unmodifiableList(mutableList);\n    }\n\n}\n```\n\n10. 불변 클래스(Immutable Class)에서 가변 객체 참조를 어떻게 처리하시겠습니까?\n\n```java\npublic class MutableClass {\n    private String name;\n\n    public MutableClass(String name) {\n        this.name = name;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    @Override\n    public String toString() {\n        return \"MutableClass [name=\" + name + \"]\";\n    }\n\n}\n```\n\n```java\npublic final class ImmutableClass {\n\n    private final MutableClass mutable;\n    private final String city;\n\n    public ImmutableClass(MutableClass mutable, String city) {\n\n        this.mutable = new MutableClass(mutable.getName());\n        this.city = city;\n    }\n\n    public MutableClass getMutable() {\n        return mutable;\n    }\n\n    public String getCity() {\n        return city;\n    }\n\n    @Override\n    public String toString() {\n        return \"ImmutableClass [mutable=\" + mutable + \", city=\" + city + \"]\";\n    }\n\n    public static void main(String[] args) {\n\n        MutableClass m = new MutableClass(\"Abhishek\");\n        ImmutableClass i = new ImmutableClass(m, \"Mumbai\");\n\n        System.out.println(i);\n        m.setName(\"Appu\");\n        System.out.println(i);\n\n    }\n\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<table>\n    <tr>\n        <td>11. Explain defensive copying.</td>\n    </tr>\n    <tr>\n        <td>Defensive copying is a programming technique used to protect against unintended modifications to mutable objects by creating copies of them. When dealing with mutable data structures or objects, defensive copying involves creating a duplicate instance of the object and working with the copy instead of the original. This ensures that changes made to the copy do not affect the original object’s state, maintaining data integrity and preventing unexpected side effects. Defensive copying is commonly employed in scenarios where immutability is desired or when sharing data between different parts of a program to maintain consistency and prevent concurrency issues.</td>\n     </tr>\n    <tr>\n        <td>12. What are stateless objects? How are they different from immutable objects? Which of these two is thread safe?</td>\n    </tr>\n</table>\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n상태가 없는 객체(Stateless objects)는 인스턴스 필드(인스턴스 변수)가 없는 객체들을 말합니다. 해당 클래스에는 컴파일 시간 상수, 즉 static final 필드가 있을 수 있습니다. 불변 객체(Immutable objects)는 상태를 가지지만 초기화 이후에 상태를 변경할 수 없는 객체를 의미합니다. 이 두 가지는 스레드 안전합니다.\n\n13. 해시맵(HashMap)에서 불변 객체가 키로 사용되면 어떤 이점이 있을까요?\n\n불변 객체가 해시맵에서 키로 사용되면 그 안정성(Stability)으로 인해 이점을 가집니다. 생성 이후에 상태를 수정할 수 없기 때문에 해시 코드는 수명 동안 일정하게 유지됩니다. 이 특성은 키의 해시 코드가 일관되게 유지되어 해싱 및 해시맵에서 값 검색을 효율적으로 수행할 수 있도록 합니다. 게다가, 불변성은 키의 상태가 예기치 않게 변경되지 않음을 보장하여 해시맵에서 키 충돌 또는 예기치 않은 동작과 같은 문제를 방지합니다. 이러한 안정성과 예측 가능성은 해시맵의 무결성과 효율성을 보장하기 위해 불변 객체를 이상적으로 만듭니다.\n\n끝까지 제 글을 읽어주셔서 감사합니다. 이 글로부터 유익한 통찰과 지식을 얻으셨기를 진심으로 바랍니다. 만약 글이 즐거우시고 유익하다고 느꼈다면, 제바랍니다 여러분의 친구들과 동료들과 공유해 주시기를 부탁드립니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 기사를 즐겨 보셨다면, 부디 팔로우하고 구독하며 박수를 보내 주시면 감사하겠습니다.\n\n제 다른 기사들도 한 번 살펴보세요.\n","ogImage":{"url":"/assets/img/2024-05-20-JavaImmutabilitytopInterviewquestions_0.png"},"coverImage":"/assets/img/2024-05-20-JavaImmutabilitytopInterviewquestions_0.png","tag":["Tech"],"readingTime":12},{"title":"Rust로 코딩하는 커맨드 라인 Connect 4 게임 배우기","description":"","date":"2024-05-20 16:00","slug":"2024-05-20-LearnRustbycodingacommandlineConnect4game","content":"\n![Rust Connect 4](/assets/img/2024-05-20-LearnRustbycodingacommandlineConnect4game_0.png)\n\n안녕하세요! 이번 글에서는 Rust가 어떻게 우리가 Connect 4의 간단한 버전을 만들며 명령줄 응용 프로그램을 작성하는 데 도움이 되는지 살펴볼 거에요.\n\n최근 Rust를 배우는 도전에 도전했고, 제 자신의 조언을 따르기 위해 개인 프로젝트에서 Rust를 사용해 손을 더럽히며 배운 것을 정리하려고 노력하고 있어요. Connect 4는 아주 좋은 도전 과제에요. 오후 하루 동안 코딩할 수 있는 것은 간단하지만 잘 하려면 약간의 생각이 필요한 복잡한 문제이죠.\n\n여기 제 마지막 결과물이 포함된 Rust 플레이그라운드가 있어요. 아래에서는 거기에 이르기까지 취한 정확한 단계를 살펴볼 거에요. 따라오고 싶으시면 Rust가 설치되어 있는지 확인한 후 터미널에서 `cargo new rust_connect_4_tutorial`을 실행해서 프로젝트를 열고 좋아하는 편집기에서 src/main.rs로 이동해서 시작해봐요!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n혹은 비디오를 통해 학습하는 것을 선호한다면, 해당 튜토리얼의 비디오 버전을 확인해보세요:\n\n# 우리의 타입 정의하기\n\nRust에서 시작하는 가장 좋은 방법 중 하나는 종종 우리의 타입을 정의하는 것이므로, 우리는 정확히 그것을 할 것입니다!\n\n먼저, 게임에 사용할 보드를 정의해 보겠습니다. Connect 4의 클래식 버전은 7개의 슬롯이 가로로 있고 6개의 슬롯이 세로로 있기 때문에, 이들 정수를 상수로 저장하고, 그 상수를 사용하여 두 차원 배열의 길이를 정의하는 데 사용할 수 있습니다. Board 타입으로 정의합니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```rust\nconst BOARD_WIDTH: usize = 7;\nconst BOARD_HEIGHT: usize = 6;\n\ntype Board = [[u8; BOARD_WIDTH]; BOARD_HEIGHT];\n```\n\n플레이어를 추적할 방법이 필요할 것입니다. 이를 enum으로 구현할 수 있습니다. 우리는 두 명의 플레이어만 지원하지만, 한 명의 피스가 없는 슬롯을 나타내는 None 변형과 게임이 무승부로 끝날 때 처리하는 데 유용할 것입니다.\n\n```rust\n#[derive(Clone, Copy, Debug, PartialEq)]\n#[repr(u8)]\nenum Player {\n    One = 1,\n    Two = 2,\n    None = 0,\n}\n```\n\n위에서는 나중에 유용할 몇 가지 트레잇을 구현하기 위해 derive를 사용하고, enum의 메모리 레이아웃을 제어하기 위해 repr을 사용했습니다. 가능한 모든 값을 알기 때문에 u8로 제한할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음으로, 우리는 게임을 나타내는 struct를 만들 것입니다. 여기에는 추적해야 할 모든 상태가 포함될 것입니다.\n\n```javascript\nstruct Game {\n    current_move: u8,\n    current_player: Player,\n    board: Board,\n    is_finished: bool,\n    winner: Player,\n}\n```\n\ncurrent_move는 플레이어가 선택한 열을 나타내는 정수입니다. 우리에게는 승자 필드가 있지만, 게임이 비김으로 끝날 때 별도로 is_finished 부울도 유용할 것입니다!\n\n마지막으로, Game에 대한 기본 함수를 구현할 것입니다. 이 함수에는 초기 상태가 포함될 것입니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```rust\nimpl Game {\n    fn default() -> Game {\n        Game {\n            current_move: 0,\n            current_player: Player::One,\n            board: [\n                [0, 0, 0, 0, 0, 0, 0],\n                [0, 0, 0, 0, 0, 0, 0],\n                [0, 0, 0, 0, 0, 0, 0],\n                [0, 0, 0, 0, 0, 0, 0],\n                [0, 0, 0, 0, 0, 0, 0],\n                [0, 0, 0, 0, 0, 0, 0],\n            ],\n            is_finished: false,\n            winner: Player::None,\n        }\n    }\n}\n```\n\n보드에 대해 조금 이야기해 봅시다. 여기서 0은 빈 칸을 나타내며, 1은 Player One이 차지한 칸을 나타내고, 2는 Player Two가 차지한 칸을 나타냅니다.\n\nBOARD_WIDTH와 BOARD_HEIGHT를 사용하여 동적으로 생성할 수도 있었지만, 코드를 작성하는 동안 전체 배열을 보는 것이 도움이 되는 시각적 도구라는 것을 발견했습니다. 같은 이유로, 정수가 아닌 Player 열거형을 사용하지 않았습니다. 텍스트가 더 많아지면 코드를 한눈에 이해하기 어려워지기 때문입니다.\n\n이 방법의 (약간의) 단점은 나중에 정수를 Player로 변환해야 한다는 것입니다. 하지만 Player에 from_int 함수를 구현함으로써 쉽게 해결할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n구현 Player {\n    fn from_int(int: u8) -> Player {\n        match int {\n            1 => Player::One,\n            2 => Player::Two,\n            _ => Player::None,\n        }\n    }\n}\n```\n\n# 보드 표시\n\n디버깅을 위해, 보드를 시각화하는 좋은 방법을 빠르게 코드화하는 것이 도움이 될 것입니다. 명령줄에 출력하기 위해 크레이트를 사용하는 대신에 간단한 색을 나타내기 위해 16진수 이스케이프 문자열을 사용할 것입니다.\n\n```js\nconst RESET: str = \"\\x1b[0m\";\nconst ORANGE: str = \"\\x1b[93m\";\nconst RED: str = \"\\x1b[0;31m\";\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래의 코드에서는 맵을 사용하여 Connect 4 토큰과 유사한 이모지로 슬롯을 변환할 것입니다. 게임이 종료되면 우승자를 발표하는 좋은 장소로 보입니다.\n\n```js\nimpl Game {\n    // 다른 함수들\n\n    fn display_board(&self) {\n        println!(\"{}--------------------{}\", ORANGE, RESET);\n        println!(\"{}CONNECT 4 (Move {}){}\", ORANGE, self.current_move, RESET);\n        println!(\"{}--------------------{}\", ORANGE, RESET);\n\n        for row in self.board {\n            let row_str: String = row\n                .iter()\n                .map(|&cell| match cell {\n                    1 => \"🔴\",\n                    2 => \"🟡\",\n                    _ => \"⚫\",\n                })\n                .collect::<Vec<&str>>()\n                .join(\" \");\n\n            println!(\"{}\", row_str);\n        }\n\n        println!(\"{}--------------------{}\", ORANGE, RESET);\n\n        if self.is_finished {\n            match self.winner {\n                Player::One => println!(\"{}🔴 Player 1이 승리했습니다!{}\", ORANGE, RESET),\n                Player::Two => println!(\"{}🟡 Player 2가 승리했습니다!{}\", ORANGE, RESET),\n                Player::None => println!(\"{}무승부입니다!{}\", ORANGE, RESET),\n            }\n\n            println!(\"{}--------------------{}\", ORANGE, RESET);\n        }\n    }\n}\n```\n\n우리는 이것을 언제든지 메인 함수 내에서 호출하여 보드의 상태를 확인할 수 있습니다.\n\n```js\nfn main() {\n    let mut game = Game::default();\n    game.display_board();\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n조금 지루하지만 수를 두지 않고는 재미가 없죠. 그래서 이제 수를 두는 방법을 프로그래밍해 봅시다!\n\n# 수 두기\n\n우리의 play_move 함수를 첫 번째로 살펴보면, 이 함수는 이차원 배열에서 올바른 항목을 변경하고, 수를 증가시킨 다음 현재 플레이어를 변경해야 합니다.\n\n```rust\nimpl Game {\n    // other functions\n\n    fn play_move(&mut self, column: usize) {\n        if let Some(row) = (0..BOARD_HEIGHT)\n            .rev()\n            .find(|&row| self.board[row][column] == 0)\n        {\n            self.board[row][column] = self.current_player as u8;\n\n            self.current_move += 1;\n\n            self.current_player = match self.current_player {\n                Player::One => Player::Two,\n                _ => Player::One,\n            };\n        }\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 if let 코드에서는 열의 맨 아래부터 시작하여 하나씩 올라가면서 빈 칸을 찾을 때까지 진행합니다. 빈 칸을 찾으면 그 위치에 현재 플레이어를 나타내는 정수로 변경하고, 현재 이동을 증가시킨 후 match 표현식을 사용하여 플레이어를 변경합니다.\n\n이 시점에서 코드를 통해 움직임을 실행하고 터미널에서 결과를 확인할 수 있습니다:\n\n```js\nfn main() {\n    let mut game = Game::default();\n\n    game.play_move(3);\n    game.play_move(3);\n    game.play_move(4);\n    game.play_move(3);\n\n    game.display_board();\n}\n```\n\n# 오류 처리\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n지금까지 우리는 보드 바깥으로 이동을 시도하는 잠재적인 오류를 처리하지 않고 있습니다. 따라서 세 가지 가능한 오류를 처리해 봅시다:\n\n- 제공된 열이 허용 범위를 벗어납니다.\n- 제공된 열이 이미 가득 찼습니다.\n- 게임이 끝났습니다.\n\n(사용자 입력을 받기 시작하면 추가적인 오류 처리가 필요할 것입니다. 나중에 처리하겠습니다.)\n\n세 가지 오류 유형을 포함한 enum을 만들어 봅시다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nenum MoveError {\n    GameFinished,\n    InvalidColumn,\n    ColumnFull,\n}\n```\n\n우리는 에러를 명령줄에 출력하기를 원하기 때문에, 우리의 에러 메시지를 포함하는 사용자 정의 Display 트레이트를 구현해야 합니다. 예를 들어:\n\n```js\nimpl std::fmt::Display for MoveError {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        match self {\n            MoveError::ColumnFull => write!(f, \"column is full\"),\n            MoveError::InvalidColumn => write!(f, \"column must be between 1 and 7\"),\n            MoveError::GameFinished => write!(f, \"game is already finished\"),\n        }\n    }\n}\n```\n\n이제 이를 사용하여 play_move 함수를 수정할 수 있습니다. 이제 우리는 움직임이 성공적이면 아무것도 반환하지만, 그렇지 않은 경우 에러가 반환되는 Result enum을 반환합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```rust\nimpl Game {\n    // 다른 함수들\n\n    fn play_move(&mut self, column: usize) -> Result<(), MoveError> {\n        if self.is_finished {\n            return Err(MoveError::GameFinished);\n        }\n\n        if column >= BOARD_WIDTH {\n            return Err(MoveError::InvalidColumn);\n        }\n\n        if let Some(row) = (0..BOARD_HEIGHT)\n            .rev()\n            .find(|&row| self.board[row][column] == 0)\n        {\n            self.board[row][column] = self.current_player as u8;\n        } else {\n            return Err(MoveError::ColumnFull);\n        }\n\n        self.current_move += 1;\n\n        self.current_player = match self.current_player {\n            Player::One => Player::Two,\n            _ => Player::One,\n        };\n\n        Ok(())\n    }\n}\n```\n\n디버깅을 위해 이제 play_move의 결과를 인쇄할 수 있으며, 예상치 못한 입력이 있는 경우 enum으로부터 에러를 볼 수 있습니다.\n\n우리가 여기에 있는 동안, 명령줄에 에러 메시지를 인쇄하는 도우미 함수를 추가해 봅시다.\n\n```rust\nimpl Game {\n    // 다른 함수들\n\n    fn display_error(&self, error: String) {\n        self.display_board();\n        println!(\"{}에러: {}{}\", RED, error, RESET);\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 게임에서 승리했는지 계산하기\n\n누군가가 이겼는지 확인하기 위해 2차원 배열을 여러 방향으로 탐색해야 합니다. 이 Leetcode 스타일 문제는 재미있는 도전이었고, 결과물을 얻기까지 몇 번 시도해야 했어요.\n\n누군가가 4칸을 연달아 얻을 수 있는 네 가지 방향이 있어요:\n\n- 수평,\n- 수직,\n- 역 슬래시 대각선 (왼쪽 위에서 오른쪽 아래로),\n- 순방향 슬래시 대각선 (왼쪽 아래에서 오른쪽 위로).\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n게시판의 모든 슬롯을 반복하여 네 방향 중 하나에서 테스트할 수 있습니다. (게시판이 작기 때문에 무차별 대입 방식을 사용하는 것이 부담이 되지 않습니다. 그러나 더 나은 방법이 있는지 궁금합니다!)\n\n게시판의 주어진 슬롯에서 시작합니다. 플레이어의 토큰이 들어있는 경우, 첫 번째 방향으로 한 단계 이동합니다. 이 새로운 슬롯도 같은 토큰을 포함하는 경우, 이 방향으로 또 다른 단계를 이동합니다. 이를 반복하여 같은 토큰이 있는 네 개의 슬롯을 찾을 때까지 진행합니다. 그렇지 않으면 다른 방향으로 이동합니다.\n\n각 방향은 정수들의 튜플로 나타낼 수 있습니다 - 행당 거리에 대한 값과 열당 거리에 대한 값 하나씩 - 이 정보를 배열에 저장할 수 있습니다.\n\n```js\nlet directions = [\n  (0, 1), // 가로\n  (1, 0), // 세로\n  (1, 1), // 대각선 (왼쪽 위에서 오른쪽 아래)\n  (-1, 1), // 대각선 (왼쪽 아래에서 오른쪽 위)\n];\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 튜플들이 무엇을 나타내는지 알려드릴게요:\n\n- 수평으로 이동하려면 행은 변하지 않고(0), 열만 변해야 합니다(1).\n- 수직으로 이동하려면 행이 변해야 하고(1), 열은 변하지 않아야 합니다(0).\n- 역 슬래시 대각선으로 이동하려면 행과 열이 둘 다 증가해야 합니다(1, 1).\n- 마지막으로, 슬래시 대각선으로 이동하려면 열은 증가하고 행은 감소해야 합니다(-1, 1).\n\n각 방향의 모든 슬롯을 테스트하려면 아래와 같이 세 개의 루프가 필요합니다.\n\n```rust\nimpl Game {\n    // 다른 함수들\n\n    fn calculate_winner(&mut self) -> Player {\n        for row in 0..BOARD_HEIGHT {\n            for col in 0..BOARD_WIDTH {\n                let cell = self.board[row][col];\n\n                if cell != 0 {\n                    let directions = [\n                        (0, 1),  // 수평\n                        (1, 0),  // 수직\n                        (1, 1),  // 대각선 (왼쪽 위에서 오른쪽 아래로)\n                        (-1, 1), // 대각선 (왼쪽 아래에서 오른쪽 위로)\n                    ];\n\n                    for (row_step, col_step) in directions {\n                        // TODO - 주어진 방향으로 보드를 탐색하고\n                        // 승자를 찾았다면 해당 플레이어를 반환하세요\n                    }\n                }\n            }\n        }\n        Player::None\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리는 연속 카운트를 유지하고 — 4에 도달하면 승자가 나온 것을 알 수 있습니다.\n\n그럼, 최종 중첩된 루프에서는 시작 토큰부터 슬롯별로 이동을 시도할 것입니다. 그때까지…\n\n- 시작 토큰과 다른 토큰을 만날 때 (그러한 경우 루프를 종료합니다);\n- 보드의 가장자리에 도달할 때 (그러한 경우 루프를 종료합니다);\n- 동일한 토큰의 4연속을 만날 때 (그러한 경우 게임을 종료하고 승자를 지정합니다).\n\n```js\nimpl Game {\n    // 다른 함수들\n\n    fn calculate_winner(&mut self) -> Player {\n        for row in 0..BOARD_HEIGHT {\n            for col in 0..BOARD_WIDTH {\n                let cell = self.board[row][col];\n\n                if cell != 0 {\n                    let directions = [\n                        (0, 1),  // 가로\n                        (1, 0),  // 세로\n                        (1, 1),  // 대각선 (왼쪽 위에서 오른쪽 아래로)\n                        (-1, 1), // 대각선 (왼쪽 아래에서 오른쪽 위로)\n                    ];\n\n                    for (row_step, col_step) in directions {\n                        let mut consecutive_count = 1;\n                        let mut r = row as isize + row_step;\n                        let mut c = col as isize + col_step;\n\n                        while r >= 0\n                            && r < BOARD_HEIGHT as isize\n                            && c >= 0\n                            && c < BOARD_WIDTH as isize\n                        {\n                            if self.board[r as usize][c as usize] == cell {\n                                consecutive_count += 1;\n\n                                if consecutive_count == 4 {\n                                    self.is_finished = true;\n                                    return Player::from_int(cell);\n                                }\n                            } else {\n                                break;\n                            }\n                            r += row_step;\n                            c += col_step;\n                        }\n                    }\n                }\n            }\n        }\n\n        Player::None\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리는 이동 횟수가 일곱 미만인 경우 이러한 확인 작업을 수행하지 않고 최적화를 조금 추가할 수 있습니다. 그때까지는 게임에서 이기는 것이 불가능하기 때문입니다. 그래서 함수 맨 위에 이를 추가해 봅시다:\n\n```js\nif self.current_move < 7 {\n    return Player::None;\n}\n```\n\n그리고 보드가 가득 찼지만 승자가 없는 경우(즉, 무승부인 경우)에 게임을 종료로 표시해야 합니다. 이를 반환문 위에 추가해 줍시다:\n\n```js\nif self.current_move >= BOARD_HEIGHT as u8 * BOARD_WIDTH as u8 {\n    self.is_finished = true;\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n마지막으로, 새로운 calculate_winner 함수를 play_move 함수에 추가할 수 있습니다. 이번에는 아무것도 반환하는 대신, 성공인 Result enum을 반환하거나 실패인 경우에는 오류를 반환합니다.\n\n```js\nimpl Game {\n    // 다른 함수들\n\n    fn play_move(&mut self, column: usize) -> Result<(), MoveError> {\n        if self.is_finished {\n            return Err(MoveError::GameFinished);\n        }\n\n        if column >= BOARD_WIDTH {\n            return Err(MoveError::InvalidColumn);\n        }\n\n        if let Some(row) = (0..BOARD_HEIGHT)\n            .rev()\n            .find(|&row| self.board[row][column] == 0)\n        {\n            self.board[row][column] = self.current_player as u8;\n            self.current_move += 1;\n        } else {\n            return Err(MoveError::ColumnFull);\n        }\n\n        let calculated_winner = self.calculate_winner();\n\n        if calculated_winner != Player::None {\n            self.winner = calculated_winner;\n        } else {\n            self.current_player = match self.current_player {\n                Player::One => Player::Two,\n                _ => Player::One,\n            };\n        }\n\n        Ok(())\n    }\n}\n```\n\n우리의 Connect 4 게임 엔진이 완성되었습니다! 사용자로부터 입력을 받는 방법만 남았습니다...\n\n# 사용자 입력 받기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리 명령 줄 게임의 마지막 부분에서는 주 함수로 돌아가 사용자 입력을 읽을 수 있도록 할 것입니다.\n\n먼저, Rust의 표준 I/O 라이브러리를 가져오겠습니다.\n\n```js\nuse std::io;\n```\n\n사용자 입력을 읽는 논리는 다음과 같이 보일 수 있습니다. 여기서는 컴퓨터와 달리 0이 아닌 1부터 시작하여 카운트하게 됩니다!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nlet mut user_move = String::new();\n\nio::stdin()\n    .read_line(&mut user_move)\n    .expect(\"Failed to read line\");\n\nlet user_move: usize = match user_move.trim().parse() {\n    Ok(num) => {\n        if num < 1 || num > BOARD_WIDTH as u8 {\n            game.display_error(MoveError::InvalidColumn.to_string());\n            continue;\n        } else {\n            num\n        }\n    }\n    Err(err) => {\n        game.display_error(err.to_string());\n        continue;\n    }\n};\n\nmatch game.play_move(user_move - 1) {\n    Ok(_) => {\n        game.display_board();\n    }\n    Err(err) => {\n        game.display_error(err.to_string());\n    }\n}\n```\n\n먼저, 우리는 빈 문자열을 정의한 뒤 사용자로부터 텍스트를 받기 위해 stdin 메소드를 사용합니다.\n\n다음으로 이 입력을 구문 분석을 시도합니다. 다음 중 하나라도 해당하는 경우 오류를 표시합니다:\n\n- 구문 분석이 실패하는 경우 (예: 입력이 숫자가 아닌 경우).\n- 구문 분석이 성공하지만 숫자가 원하는 범위를 벗어난 경우.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만약 오류가 표시되지 않는다면, 우리는 선택한 수를 둘 것입니다. 그러나 해당 시나리오에서 오류가 발생할 수도 있으므로, 그런 경우에는 오류를 표시할 것입니다.\n\n그러나 위의 코드는 한 번만 실행됩니다. 게임이 끝날 때까지 루프를 실행해야 합니다. 아래는 그 반복문을 추가한 main 함수와 사용자를 도와줄 몇 가지 유용한 메시지입니다:\n\n```js\nfn main() {\n    let mut game = Game::default();\n    game.display_board();\n\n    while !game.is_finished {\n        println!(\"\\n\");\n\n        match game.current_player {\n            Player::One => println!(\"플레이어 1\"),\n            Player::Two => println!(\"플레이어 2\"),\n            _ => (),\n        };\n\n        println!(\"1부터 7 사이의 열을 입력하세요:\");\n\n        let mut user_move = String::new();\n        io::stdin()\n            .read_line(&mut user_move)\n            .expect(\"라인을 읽는 데 실패했습니다\");\n\n        let user_move: usize = match user_move.trim().parse() {\n            Ok(num) => {\n                if num < 1 || num > 7 {\n                    game.display_error(MoveError::InvalidColumn.to_string());\n                    continue;\n                } else {\n                    num\n                }\n            }\n            Err(err) => {\n                game.display_error(err.to_string());\n                continue;\n            }\n        };\n\n        match game.play_move(user_move - 1) {\n            Ok(_) => {\n                game.display_board();\n            }\n            Err(err) => {\n                game.display_error(err.to_string());\n            }\n        }\n    }\n}\n```\n\n# 여러 판을 플레이하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n마지막으로, 사용자가 게임을 끝내면 게임을 다시 시작할 수 있도록 추가 코드를 추가하고 싶어요. 매번 실행 파일을 다시 시작해야 하는 번거로움은 피하고 싶으니까요!\n\n이를 위해 새로운 루프를 만들 것입니다. 이전과 동일한 방법을 사용하여 사용자의 입력을 읽을 수 있습니다. \"R\"을 누르면 새 게임을 시작하고, \"Q\"를 누르면 루프를 중단하고 코드를 끝까지 실행합니다.\n\n```js\nfn main() {\n    let mut game = Game::default();\n    game.display_board();\n\n    loop {\n        while !game.is_finished {\n            // 코드 변경 없음\n        }\n\n        println!(\"Press 'R' to restart or 'Q' to quit the game.\");\n\n        let mut user_input = String::new();\n\n        io::stdin()\n            .read_line(&mut user_input)\n            .expect(\"Failed to read line\");\n\n        match user_input.trim() {\n            \"R\" | \"r\" => {\n                game = Game::default();\n                game.display_board();\n            }\n            \"Q\" | \"q\" => {\n                println!(\"Quitting...\");\n                break;\n            }\n            _ => game.display_error(\"잘못된 입력\".to_string()),\n        }\n    }\n}\n```\n\n마지막으로, 차례 사이에 터미널을 지우기 위한 ASCII 이스케이프 코드를 사용할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nfn clear_screen(&self) {\n    print!(\"{}[2J\", 27 as char);\n}\n```\n\n게임 보드를 표시할 때마다 이 작업을 수행할 수 있습니다.\n\n```js\nfn display_board(&self) {\n    self.clear_screen();\n\n    // 코드 변경 없음\n}\n```\n\n# 모두 함께 가져오기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그것이 커넥트 4의 간단한 명령줄 게임을 위해 필요한 모든 것입니다! 이 작업 중인 파일을 사용하는 작동 버전을 시험하려면 Rust 플레이그라운드를 확인해보세요.\n\n우리가 지금까지 만든 전체 파일은 아래와 같습니다:\n\n```js\nuse std::io;\n\nconst RESET: &str = \"\\x1b[0m\";\nconst ORANGE: &str = \"\\x1b[93m\";\nconst RED: &str = \"\\x1b[0;31m\";\n\nconst BOARD_WIDTH: usize = 7;\nconst BOARD_HEIGHT: usize = 6;\n\ntype Board = [[u8; BOARD_WIDTH]; BOARD_HEIGHT];\n\n#[derive(Clone, Copy, Debug, PartialEq)]\n#[repr(u8)]\nenum Player {\n    One = 1,\n    Two = 2,\n    None = 0,\n}\n\nimpl Player {\n    fn from_int(int: u8) -> Player {\n        match int {\n            1 => Player::One,\n            2 => Player::Two,\n            _ => Player::None,\n        }\n    }\n}\n\n#[...]\n\n# 결론\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n지금까지 따라오셨다면 프로젝트를 더 나아가고 싶을 것입니다. 여러 게임을 거치면서 승리를 추적해 볼 수도 있고, 어떨까요? 어플리케이션을 웹 서버로 전환하여 웹사이트가 HTTP를 통해 Connect 4를 플레이할 수 있게끔 만들어 보는 것은 어떤가요?\n\n이번 명령줄 어플리케이션을 Rust로 개발하는 방법에 대한 유용하고 재미있는 통찰력으로 여기시길 바랍니다. 아직 Rust 여행을 시작한 지 얼마 되지 않았기 때문에, 어떠한 비평이나 더 많은 Rust 다운 방식으로 어플리케이션을 작성하는 아이디어가 있다면 꼭 알려주세요. 함께 고민해보고 싶습니다.\n```\n","ogImage":{"url":"/assets/img/2024-05-20-LearnRustbycodingacommandlineConnect4game_0.png"},"coverImage":"/assets/img/2024-05-20-LearnRustbycodingacommandlineConnect4game_0.png","tag":["Tech"],"readingTime":24},{"title":"Python 정규 표현식을 사용하여 여러 공백을 하나의 공백으로 압축하기","description":"","date":"2024-05-20 15:59","slug":"2024-05-20-CondensingMultipleSpacesIntoOneSpaceUsingPythonRegex","content":"\n![image](/assets/img/2024-05-20-CondensingMultipleSpacesIntoOneSpaceUsingPythonRegex_0.png)\n\n만약 여러 개의 공백 문자를 하나의 공백 문자로 변환해야 한다면, 이 기사가 여러분을 위한 것입니다.\n\n```js\nx = \"apple   orange  pear     pineapple\";\n```\n\n^ 이 문자열에서 단어 사이에 여러 개의 공백이 있습니다. 여러 개의 공백을 하나의 공백으로 압축해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\noutput = \"apple orange pear pineapple\";\n```\n\n# 수동 방법\n\n```js\nx = 'apple   orange  pear     pineapple'\n\ndef condense(x):\n    words = x.split(' ')\n    words = [w for w in words if w]\n    return ' '.join(words)\n\nprint(condense(x))\n\n# apple orange pear pineapple\n```\n\n- .split()을 사용하면 `['apple', '', '', 'orange', '', 'pear', '', '', '', '', 'pineapple']` 와 같이 단어가 됩니다.\n- 리스트 내포는 모든 빈 문자열을 필터링하고 [`apple`, `orange`, `pear`, `pineapple`]를 얻습니다.\n- ` ` .join()은 이 4개 단어를 `apple orange pear pineapple`로 결합합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n하지만 이 방법은 다소 수동적입니다. 한 줄의 코드로 정규식을 사용하여 이 문제를 해결할 수 있다는 걸 아셨나요?\n\n# 정규식 방법\n\n```js\nx = 'apple   orange  pear     pineapple'\n\nimport re\nprint(re.sub(' +', ' ', x))\n\n# apple orange pear pineapple\n```\n\n- re.sub은 정규식 ` +`와 일치하는 모든 문자열을 ` `로 바꿉니다.\n- ` +`는 1개 이상의 공백을 포함하는 모든 문자열과 일치합니다.\n- 이는 연속으로 여러 개의 공백이 포함된 모든 경우에 일치합니다.\n- 각각의 경우가 한 개의 공백으로 대체됩니다.\n- 이게 전부입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 결론\n\n이 내용을 이해하기 쉽고 명확했기를 바랍니다.\n\n# 크리에이터로서 저를 지원하고 싶다면\n\n- 이 이야기에 대해 50번 박수를 치세요\n- 생각을 나누는 댓글을 남겨주세요\n- 이야기에서 가장 마음에 드는 부분을 강조해주세요\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n감사합니다! 이런 작은 행동들이 큰 도움이 되어요. 정말 감사드려요!\n\nYouTube: [https://www.youtube.com/@zlliu246](https://www.youtube.com/@zlliu246)\n\nLinkedIn: [https://www.linkedin.com/in/zlliu/](https://www.linkedin.com/in/zlliu/)\n\n나의 이북: [https://zlliu.co/ebooks](https://zlliu.co/ebooks)\n","ogImage":{"url":"/assets/img/2024-05-20-CondensingMultipleSpacesIntoOneSpaceUsingPythonRegex_0.png"},"coverImage":"/assets/img/2024-05-20-CondensingMultipleSpacesIntoOneSpaceUsingPythonRegex_0.png","tag":["Tech"],"readingTime":3},{"title":"안드로이드에서 네트워크 호출 Retrofit을 이용한 비동기 프로그래밍","description":"","date":"2024-05-20 15:58","slug":"2024-05-20-NetworkCallsinAndroidAsynchronousProgrammingwithRetrofit","content":"\n<img src=\"/assets/img/2024-05-20-NetworkCallsinAndroidAsynchronousProgrammingwithRetrofit_0.png\" />\n\n안녕하세요! 안드로이드 개발 세계에서 네트워크 호출을 효율적으로 처리하는 것이 매우 중요해요. 원격 서버에서 데이터를 가져오거나 클라우드에 데이터를 업로드한다 하더라도, 네트워크 작업은 시간이 오래 걸릴 수 있고 제대로 처리되지 않으면 사용자 경험에 상당한 영향을 줄 수 있어요. 여기서 Retrofit이 등장하는데, 이는 Square에서 개발한 안드로이드와 자바용 타입 안전한 HTTP 클라이언트에요. 이 글에서는 Retrofit의 내부 동작과 안드로이드에서 네트워크 호출을 수행하는 데 어떻게 비동기 프로그래밍으로 사용할 수 있는지 알아볼 거에요.\n\n동기 호출의 문제점을 상상해보세요. 만약 앱이 서버에서 사용자 데이터를 다운로드해야 한다면, 개발자는 전통적인 동기 방식을 사용할 수 있어요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n문자열 userData = downloadUserDataSync();\n\n// 이제 userData를 앱 로직에서 사용하세요...\n```\n\n이 방법은 직관적으로 보이지만 문제점이 있습니다: downloadUserDataSync()가 실행 중일 때 전체 앱이 차단됩니다. 사용자가 화면과 상호 작용할 수 없게 되며, 버튼이 응답하지 않는 것처럼 보이고 데이터 다운로드가 완료될 때까지 앱이 멈춰 있는 것처럼 보입니다. 이는 사용자 경험을 저하시킵니다.\n\n비동기 프로그래밍 등장\n\n비동기 프로그래밍을 통해 앱이 네트워크 응답을 기다리는 동안에도 계속 실행할 수 있습니다. 핵심 아이디어는 백그라운드에서 네트워크 호출을 시작하고 응답이 준비되었을 때 알림을 받는 것입니다. 이렇게 하면 주 스레드가 사용 가능해져 사용자의 상호작용에 민첩하게 대응할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n레트로핏을 위한 구조체\n\n레트로핏은 안드로이드에서 네트워크 호출을 간소화하고 비동기 프로그래밍과 완벽하게 통합되는 인기 있는 HTTP 클라이언트 라이브러리입니다. 인터페이스를 사용하여 API 엔드포인트를 정의하고 요청을 생성하고 응답을 처리하는 방법을 제공합니다.\n\n다음은 레트로핏의 주요 기능 중 일부입니다:\n\n- 쉬운 사용: 네트워크 요청을 만들고 응답을 구문 분석하는 복잡성을 추상화합니다.\n- 타입 안전성: 작업 중인 데이터의 유형이 예상대로인지 확인합니다.\n- 비동기 요청: 원활한 사용자 경험을 위해 필수적인 비동기 네트워크 호출을 지원합니다.\n- 통합: OkHttp, RxJava, Gson과 같은 다른 라이브러리와 원활하게 작동합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# Retrofit 설정하기\n\n```js\n의존성 {\n    구현체 'com.squareup.retrofit2:retrofit:2.9.0'\n    구현체 'com.squareup.retrofit2:converter-gson:2.9.0'\n}\n```\n\n이러한 종속성에는 Retrofit과 JSON 직렬화 및 역직렬화를 처리하기 위한 Gson 변환기가 포함되어 있습니다.\n\n# API 인터페이스 정의하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nRetrofit을 사용하려면 API의 엔드포인트를 Java 인터페이스로 정의해야 합니다. 사용자 목록을 제공하는 간단한 API와 작업 중이라고 가정해봅시다.\n\n```js\npublic interface ApiService {\n    @GET(\"/users\")\n    Call<List<User>> getUsers();\n}\n```\n\n```bash\n여기서 @GET(\"users\")는 /users 엔드포인트로 GET 요청을 보낸다는 것을 나타내고, Call<List<User>>는 이 요청이 User 객체의 목록을 반환할 것임을 나타냅니다.\n```\n\n# Retrofit 인스턴스 생성하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음으로 Retrofit의 인스턴스를 만들어보겠습니다. 보통은 애플리케이션에서 한 번만 이 작업을 수행하며 대부분 싱글톤 패턴으로 처리됩니다.\n\n```java\npublic class ApiClient {\n    private static final String BASE_URL = \"https://api.example.com/\";\n    private static Retrofit retrofit = null;\n\n    public static Retrofit getClient() {\n        if (retrofit == null) {\n            retrofit = new Retrofit.Builder()\n                    .baseUrl(BASE_URL)\n                    .addConverterFactory(GsonConverterFactory.create())\n                    .build();\n        }\n        return retrofit;\n    }\n}\n```\n\n여기서 BASE_URL은 API의 루트 URL입니다. addConverterFactory(GsonConverterFactory.create())은 Retrofit에 Gson을 JSON 변환에 사용하도록 지시하는 부분입니다.\n\n# 비동기 네트워크 호출하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nRetrofit을 설정하면 이제 비동기 네트워크 호출을 할 수 있습니다. 사용자 목록을 가져오고 응답을 처리하는 방법은 다음과 같습니다:\n\n```js\npublic class MainActivity extends AppCompatActivity {\n\n    private ApiService apiService;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        Retrofit retrofit = ApiClient.getClient();\n        apiService = retrofit.create(ApiService.class);\n\n        fetchUsers();\n    }\n\n    private void fetchUsers() {\n        Call<List<User>> call = apiService.getUsers();\n        call.enqueue(new Callback<List<User>>() {\n            @Override\n            public void onResponse(Call<List<User>> call, Response<List<User>> response) {\n                if (response.isSuccessful()) {\n                    List<User> users = response.body();\n                    // 사용자 목록 처리\n                } else {\n                    // 오류 처리\n                }\n            }\n\n            @Override\n            public void onFailure(Call<List<User>> call, Throwable t) {\n                // 실패 처리\n            }\n        });\n    }\n}\n```\n\n`fetchUsers` 메서드에서 enqueue를 호출하여 네트워크 요청을 비동기적으로 수행합니다. `onResponse` 메서드는 요청이 성공한 경우에 호출되고, `onFailure` 메서드는 요청이 실패한 경우에 호출됩니다.\n\n# 다양한 응답 유형 처리\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n레트로핏은 일반 텍스트, JSON 및 사용자 정의 타입을 포함한 다양한 유형의 응답을 지원합니다. 예를 들어, API가 추가 메타데이터를 포함한 JSON 객체를 반환하는 경우 사용자 정의 응답 유형을 정의할 수 있습니다:\n\n```js\npublic class ApiResponse<T> {\n    private T data;\n    private String status;\n    private String message;\n\n    // Getter 및 Setter 메서드\n}\n```\n\n그런 다음, API 인터페이스를 이 사용자 정의 타입을 사용하도록 업데이트하십시오:\n\n```js\npublic interface ApiService {\n    @GET(\"users\")\n    Call<ApiResponse<List<User>>> getUsers();\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그리고 액티비티나 프래그먼트에서 응답을 처리해보세요:\n\n```js\ncall.enqueue(new Callback<ApiResponse<List<User>>>() {\n    @Override\n    public void onResponse(Call<ApiResponse<List<User>>> call, Response<ApiResponse<List<User>>> response) {\n        if (response.isSuccessful()) {\n            ApiResponse<List<User>> apiResponse = response.body();\n            if (apiResponse != null && \"success\".equals(apiResponse.getStatus())) {\n                List<User> users = apiResponse.getData();\n                // 사용자 목록 처리\n            } else {\n                // API 오류 처리\n            }\n        } else {\n            // 에러 처리\n        }\n    }\n\n    @Override\n    public void onFailure(Call<ApiResponse<List<User>>> call, Throwable t) {\n        // 실패 처리\n    }\n});\n```\n\n# 고급 사용법: 인터셉터와 로깅\n\n네트워크 요청에 대한 더 많은 제어를 위해 OkHttp를 사용하여 인터셉터를 추가할 수 있습니다. 인터셉터는 요청 및 응답을 수정하고 세부 정보를 기록하며 인증을 처리할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n먼저 OkHttp 종속성을 추가해주세요:\n\n```js\nimplementation 'com.squareup.okhttp3:logging-interceptor:4.9.0'\n```\n\n그런 다음 인터셉터를 사용하여 OkHttp 클라이언트를 설정하세요:\n\n```js\nHttpLoggingInterceptor logging = new HttpLoggingInterceptor();\nlogging.setLevel(HttpLoggingInterceptor.Level.BODY);\n\nOkHttpClient client = new OkHttpClient.Builder()\n        .addInterceptor(logging)\n        .build();\n\nRetrofit retrofit = new Retrofit.Builder()\n        .baseUrl(BASE_URL)\n        .client(client)\n        .addConverterFactory(GsonConverterFactory.create())\n        .build();\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 설정을 통해 모든 네트워크 요청과 응답이 로깅되어 문제를 디버그하기가 더 쉬워집니다.\n\n# 결론\n\nRetrofit은 안드로이드에서 네트워크 호출을 처리하는 강력하고 유연한 라이브러리입니다. 그 간결함과 방대한 사용자 정의 옵션을 결합하여 네트워크 작업을 처리하는 데 탁월한 선택지가 됩니다. Retrofit을 사용함으로써 복잡한 API 및 대규모 데이터셋을 다룰 때에도 앱이 효율적으로 작동하고 부드러운 사용자 경험을 제공할 수 있습니다.\n\n본 문서에서 제공된 예제와 지침을 따라 Retrofit을 안드로이드 프로젝트에 통합하고 비동기 프로그래밍을 위한 기능을 활용할 수 있는 능력을 습득할 수 있을 것입니다. 즐거운 코딩 되세요!\n","ogImage":{"url":"/assets/img/2024-05-20-NetworkCallsinAndroidAsynchronousProgrammingwithRetrofit_0.png"},"coverImage":"/assets/img/2024-05-20-NetworkCallsinAndroidAsynchronousProgrammingwithRetrofit_0.png","tag":["Tech"],"readingTime":9},{"title":"제트팩 컴포즈에서 안전하게 플로우 소비하기","description":"","date":"2024-05-20 15:56","slug":"2024-05-20-ConsumingflowssafelyinJetpackCompose","content":"\n![](/assets/img/2024-05-20-ConsumingflowssafelyinJetpackCompose_0.png)\n\nLifecycle-aware 방식으로 Flow를 수집하는 것이 Android에서 Flow를 수집하는 권장 방법입니다. Jetpack Compose로 안드로이드 앱을 개발 중이라면 UI에서 Lifecycle-aware 방식으로 Flow를 수집하기 위해 collectAsStateWithLifecycle API를 사용하십시오.\n\ncollectAsStateWithLifecycle을 사용하면 앱이 백그라운드에 있을 때와 같이 필요하지 않은 경우 앱 리소스를 저장할 수 있습니다. 불필요한 리소스를 오랫동안 유지하면 사용자 기기의 성능에 영향을 줄 수 있습니다. 이러한 리소스에는 Firebase 쿼리, 위치 또는 네트워크 업데이트 및 데이터베이스 연결이 포함될 수 있습니다.\n\n이 API에 대해 더 알아보고, Lifecycle-aware 방식으로 수집해야 하는 이유 및 collectAsState API와 비교하는 방법을 계속 읽어보세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# collectAsStateWithLifecycle\n\ncollectAsStateWithLifecycle은 flow에서 값들을 수집하고 최신 값을 Compose State로 라이프사이클을 고려하여 표현하는 컴포저블 함수입니다. 새로운 flow 이벤트가 발생할 때마다 State 객체의 값이 업데이트됩니다. 이는 구성 내의 모든 State.value 사용의 recomposition을 유발합니다.\n\n기본적으로 collectAsStateWithLifecycle은 Lifecycle.State.STARTED를 사용하여 flow로부터 값들을 수집하기 시작하고 중지합니다. 이는 라이프사이클이 대상 상태로 이동하고 벗어날 때 발생합니다. 이 라이프사이클 상태는 minActiveState 매개변수에서 구성 가능합니다.\n\n![이미지](/assets/img/2024-05-20-ConsumingflowssafelyinJetpackCompose_1.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래 코드 스니펫은 ViewModel에서 노출한 StateFlow의 uiState 필드를 수집하는 collectAsStateWithLifecycle의 사용 방법을 보여줍니다:\n\nAuthorViewModel의 uiState가 새로운 AuthorScreenUiState 값을 방출할 때마다, AuthorRoute가 recompose됩니다. collectAsStateWithLifecycle의 더 많은 사용 예는 Now in Android 앱과 해당 마이그레이션 PR을 확인해보세요.\n\n프로젝트에서 collectAsStateWithLifecycle API를 사용하려면 androidx.lifecycle.lifecycle-runtime-compose artifact를 프로젝트에 추가하세요.\n\n# Under the hood\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\ncollectAsStateWithLifecycle의 구현은 View 시스템을 사용하여 안드로이드에서 플로우를 수집하는 권장 방법인 repeatOnLifecycle API를 사용합니다.\n\ncollectAsStateWithLifecycle을 사용하면 아래 표시된 보일러플레이트 코드를 입력하는 번거로움을 덜어줍니다. 또한 콤포저블 함수에서 라이프사이클을 인식하는 방법으로 플로우를 수집합니다.\n\n# 아키텍처에서의 플로우 수집\n\n앱 아키텍처의 유형은 다른 유형의 구현 세부 정보를 알아서는 안 됩니다. UI는 ViewModel이 UI 상태를 어떻게 생성하는지 알아서는 안 됩니다. UI가 화면에 표시되지 않으면 플로우 수집을 중지하여 적절한 경우 앱 리소스를 해제해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nUI는 collectAsStateWithLifecycle를 사용하여 UI 상태를 수집함으로써 리소스를 해제하는 데 도움이 될 수 있습니다. ViewModel은 UI 상태를 수집자 인식적으로 생성함으로써 동일한 작업을 수행할 수 있습니다. UI가 화면에 표시되지 않은 경우와 같이 수집자가 없는 경우 데이터 계층에서 오는 상류 플로우를 중지할 수 있습니다. UI 상태를 생성할 때 .stateIn(WhileSubscribed) 플로우 API를 사용하여 이 작업을 수행할 수 있습니다. 이에 대한 자세한 정보는 Kotlin flows in practice에서 이야기하는 부분을 참조하십시오. 이 방법으로 UI 상태를 생성하는 ViewModel을 테스트하려면 테스트 가이드를 확인하십시오.\n\n![image](/assets/img/2024-05-20-ConsumingflowssafelyinJetpackCompose_2.png)\n\n플로우의 소비자와 생성자는 서로의 구현 방식을 알 필요가 없습니다. 여러 환경, 변형, 라이브러리 및 기능이 있는 큰 앱에서 구현 세부 정보를 파악하는 것은 매우 시간이 소요될 수 있습니다. 게다가, 구현 세부 정보에 의존하는 코드를 유지하는 것은 어려울 수 있습니다.\n\n# 백그라운드에서 리소스 활성 유지하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n안녕하세요! 안드로이드 앱은 수많은 안드로이드 기기에서 실행될 수 있어요. 하지만 모든 기기와 사용자가 무한한 리소스를 가지고 있는 것은 아닙니다. 앱은 일반적으로 제한된 환경에서 실행돼요. 안드로이드 앱이 실행 중일 때는 사용자 경험과 기기 시스템 상태에 영향을 미치는 중요한 요인들이 있어요:\n\n- CPU 사용량: CPU는 모든 기기 구성 요소 중에서 배터리 소모량이 가장 높아요. 배터리 수명은 사용자들이 항상 걱정하는 문제에요. 남용하면 사용자가 앱을 제거할 수도 있어요.\n- 데이터 사용량: Wi-Fi에 연결되지 않은 경우 앱에서 네트워크 트래픽을 줄이면 사용자가 돈을 절약할 수 있어요.\n- 메모리 사용량: 앱이 메모리를 사용하는 방식은 기기의 전체 안정성과 성능에 매우 큰 영향을 미칠 수 있어요.\n\n사용자, 기기 시스템 상태를 존중하거나 수십억 대상으로 앱을 개발하려는 안드로이드 개발자는 시장, 기기 또는 대상 국가에 따라 이러한 다양한 요인들을 최적화해야 해요. 필요 없는 리소스를 계속 유지하면 기기의 종류와 사용 중인 안드로이드 버전에 따라 부정적인 영향을 줄 수 있어요. UI 레이어에서 collectAsStateWithLifecycle를 사용하면 나머지 계층이 리소스를 해제할 수 있어요.\n\n# collectAsState 비교\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n개발자들이 종종 묻곤 합니다: 안드로이드의 컴포저블 기능에서 플로우를 수집하는 가장 안전한 방법은 collectAsStateWithLifecycle인데, collectAsState API가 왜 필요한가요? collectAsState에 라이프사이클 관리 기능을 추가하지 않고 새 API를 만드는 이유가 뭔가요?\n\n컴포저블 함수의 라이프사이클은 Compose가 실행 중인 플랫폼과 상관이 없다. 컴포저블 함수의 라이프사이클은 '라이프사이클에서 컴포저블' 페이지에 문서화되어 있습니다. 컴포저블 함수의 인스턴스는 Composition에 진입하고, 0회 이상 다시 구성되고, Composition을 떠납니다.\n\n![이미지](/assets/img/2024-05-20-ConsumingflowssafelyinJetpackCompose_3.png)\n\ncollectAsState API는 Composition의 라이프사이클을 따릅니다. 컴포저블이 Composition에 진입할 때 플로우 수집을 시작하고, Composition을 떠날 때 수집을 멈춥니다. collectAsState는 플로우를 수집하는 데 사용할 수 있는 플랫폼에 중립적인 API입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그러나 안드로이드 앱에서 Compose를 사용할 때는 안드로이드 라이프사이클도 리소스 관리에 중요한 역할을 합니다. Compose가 안드로이드 앱이 백그라운드에 있을 때 recompositions을 일시 중지하더라도, collectAsState는 컬렉션을 활성 상태로 유지합니다. 이는 계층 구조의 나머지 부분이 리소스를 해제할 수 없게 만듭니다.\n\ncollectAsState와 collectAsStateWithLifecycle은 Compose에서 각자의 목적이 있습니다. 안드로이드 앱을 개발할 때는 후자를 사용하고, 다른 플랫폼을 위해 개발할 때는 전자를 사용합니다.\n\ncollectAsState에서 collectAsStateWithLifecycle로 마이그레이션하는 것은 간단합니다:\n\nLifecycle-aware 방식으로 플로우를 수집하는 것은 안드로이드에서 플로우를 수집하는 권장 방법으로, 필요한 경우 앱의 다른 부분이 리소스를 해제할 수 있도록 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nJetpack Compose을 사용하여 Android 앱을 개발 중이라면, collectAsStateWithLifecycle 조합 기능을 사용하여 이 작업을 수행할 수 있습니다.\n\n부록: 이 기사를 검토해 준 Jose Alcérreca,\nMarton Braun,\nAlejandra Stamato,\n그리고 Jake Roseman에게 감사드립니다.\n","ogImage":{"url":"/assets/img/2024-05-20-ConsumingflowssafelyinJetpackCompose_0.png"},"coverImage":"/assets/img/2024-05-20-ConsumingflowssafelyinJetpackCompose_0.png","tag":["Tech"],"readingTime":7},{"title":"안드로이드 프로젝트에 Kotlin Multiplatform Mobile KMM을 원활하게 통합하기","description":"","date":"2024-05-20 15:55","slug":"2024-05-20-SeamlesslyIntegrateKotlinMultiplatformMobileKMMintoYourAndroidProject","content":"\n<img src=\"/assets/img/2024-05-20-SeamlesslyIntegrateKotlinMultiplatformMobileKMMintoYourAndroidProject_0.png\" />\n\nKotlin Multiplatform Mobile (KMM)은 Android 및 iOS 애플리케이션 간에 코드를 공유할 수 있게 해주어 개발을 더 신속하고 효율적으로 만듭니다.\n\n본 안내서는 KMM을 기존의 Android 프로젝트에 통합하는 단계를 안내합니다. Android 앱의 고유한 기능을 희생하지 않고 공유 코드를 활용할 수 있도록 보장합니다.\n\n필수 준비물:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 기존 Android 앱.\n\n## 단계 1: KMM 모듈 생성하기:\n\n- Android Studio에서 File -` New -` New Module로 이동합니다.\n- KMM Shared Module을 선택합니다.\n\n<img src=\"/assets/img/2024-05-20-SeamlesslyIntegrateKotlinMultiplatformMobileKMMintoYourAndroidProject_1.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n새 Android Studio에서 KMM 공유 모듈을 찾을 수 없다면 걱정하지 마세요. 설정에 숨겨져 있습니다.\n\n## 단계 2: 앱 모듈에 공유 모듈 포함하기:\n\n- settings.gradle 파일을 열고 KMM 모듈 종속성이 추가되었는지 확인하세요 (이 작업은 자동으로 수행됩니다).\n- app/build.gradle 파일에서 다음 종속성을 추가하세요:\n\n```js\nimplementation project(\":shared\")\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 단계 3: Kotlin DSL용 빌드 스크립트 업데이트(필요한 경우):\n\n만약 Android 프로젝트가 빌드에 실패한다면, KMM 모듈이 Kotlin DSL을 사용하고 있을 가능성이 높습니다. 다음과 같이 shared/build.gradle.kts에 의존성 설정을 변경하세요:\n\n```js\nplugins {\n    id(\"com.android.library\")\n    id(\"org.jetbrains.kotlin.multiplatform\")\n}\n\nkotlin {\n    android()\n    sourceSets {\n        val androidMain by getting {\n            dependencies {\n                implementation(\"org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version\")\n            }\n        }\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\n의존성 {\n    구현(\"org.jetbrains.kotlin:kotlin-test:$kotlin_version\")\n}\n```\n\n## 단계3: 빌드 및 확인:\n\n- 프로젝트를 Gradle 파일과 동기화하고 빌드가 성공적으로 완료되는지 확인합니다.\n- 빌드 과정 중 발생하는 어떤 문제든 해결합니다.\n\n## 단계4: 앱에서 공유 코드 사용:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 이제 KMM 모듈의 공유 코드를 Android 프로젝트에서 사용할 수 있습니다. 예를 들어 Android 액티비티나 프래그먼트에서 필요한 대로 공유 클래스 및 함수를 가져올 수 있습니다.\n\n## 단계5: 빌드 및 확인\n\n- Android 프로젝트를 실행하여 모든 것이 올바르게 통합되었고 공유 코드가 기대대로 작동하는지 확인하십시오.\n\n이러한 단계를 따라서 기존 Android 프로젝트에 KMM을 성공적으로 통합할 수 있으며, Android와 기타 플랫폼 간에 코드를 원할하게 공유하여 개발 프로세스를 강화하고 노력의 중복을 줄일 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음 시리즈의 내용을 기대해주세요. KMM을 기존 iOS 프로젝트에 통합하는 방법을 살펴볼 예정입니다.\n","ogImage":{"url":"/assets/img/2024-05-20-SeamlesslyIntegrateKotlinMultiplatformMobileKMMintoYourAndroidProject_0.png"},"coverImage":"/assets/img/2024-05-20-SeamlesslyIntegrateKotlinMultiplatformMobileKMMintoYourAndroidProject_0.png","tag":["Tech"],"readingTime":4},{"title":"안드로이드에서 Room 데이터베이스 시작하기","description":"","date":"2024-05-20 15:54","slug":"2024-05-20-GettingStartedwithRoomDatabaseinAndroid","content":"\n## Room 데이터베이스 구현에 대한 포괄적인 안내\n\n![Android Room Database](/assets/img/2024-05-20-GettingStartedwithRoomDatabaseinAndroid_0.png)\n\n## 소개:\n\n로컬 데이터 저장은 많은 안드로이드 애플리케이션에게 중요하며, 데이터를 효율적으로 저장하고 검색할 수 있게 합니다. 이 안내서에서는 안드로이드 앱에서 데이터베이스 관리를 간편하게 하는 강력한 라이브러리인 Room을 살펴보겠습니다. Room 설정부터 데이터베이스 작업 수행 및 마이그레이션 처리까지 모두 다룰 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-05-20-GettingStartedwithRoomDatabaseinAndroid_1.png\" />\n\n## 섹션 1: Room 데이터베이스 설정하기\n\n단계 1: 종속성 추가\n앱의 `build.gradle` 모듈 레벨 파일을 열어 Room 및 Kotlin Coroutines (비동기 작업을 위한)에 필요한 종속성을 추가해주세요:\n\n```js\ngradle\ndependencies {\n def roomVersion = \"2.4.0\" // 최신 버전을 확인하세요\n implementation \"androidx.room:room-runtime:$roomVersion\"\n kapt \"androidx.room:room-compiler:$roomVersion\"\n implementation \"androidx.room:room-ktx:$roomVersion\"\n implementation \"org.jetbrains.kotlinx:kotlinx-coroutines-android:1.5.2\" // 코루틴 종속성 추가\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nOR\n\n최신 안드로이드 및 Jetpack Compose에서 특정 오류로 실패하는 경우 'Kotlin 심볼 처리' ksp()을 추가해야 할 수도 있습니다.\n\n아래 종속성 및 플러그인을 build.gradle(모듈 레벨)에 추가해보세요.\n\n```js\nplugins {\n .\n .\n id \"com.google.devtools.ksp\"\n}\n\n.\n.\n.\n\ndependencies{\n  // Room 종속성\n    val room_version = \"2.5.2\"\n\n    implementation(\"androidx.room:room-ktx:$room_version\")\n    // Kotlin 주석 처리 도구 (kapt) 사용을 위해\n    ksp(\"androidx.room:room-compiler:$room_version\")\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래 클래스 경로를 build.gradle(앱 레벨)에 KSP에 추가해주세요.\n\n```js\nplugins {\n    id \"com.google.devtools.ksp\" version \"1.8.10-1.0.9\" apply false\n}\n```\n\n단계 2: 엔티티 클래스 생성\n데이터베이스에서 테이블을 나타내기 위해 어노테이션을 사용하여 엔티티 클래스를 정의하세요. 예를 들어, `User` 엔티티를 생성해보겠습니다(각 데이터 멤버가 열 이름인 테이블로 간주합니다):\n\n```js\nimport androidx.room.Entity\nimport androidx.room.PrimaryKey\n\n@Entity(tableName = \"users\")\ndata class User(\n @PrimaryKey(autoGenerate = true) val id: Long = 0,\n val username: String,\n val email: String\n)\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### Step 3: DAO (Data Access Object) Interface 생성\n\n데이터베이스 작업을 정의하기 위한 DAO 인터페이스를 생성하세요. 예를 들어, `UserDao`를 만들어보겠습니다:\n\n```kotlin\nimport androidx.room.Dao\nimport androidx.room.Insert\nimport androidx.room.OnConflictStrategy\nimport androidx.room.Query\n\n@Dao\ninterface UserDao {\n\n @Insert(onConflict = OnConflictStrategy.REPLACE)\n suspend fun insertUser(user: User)\n\n @Query(\"SELECT * FROM users\")\n suspend fun getAllUsers(): List<User>\n}\n```\n\n### Step 4: 데이터베이스 클래스 정의\n\n`RoomDatabase`를 확장하는 추상 클래스를 생성하여 데이터베이스 인스턴스를 정의하고 엔티티 및 DAO를 포함시키세요:\n\n```kotlin\nimport androidx.room.Database\nimport androidx.room.RoomDatabase\n\n@Database(entities = [User::class], version = 1)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun userDao(): UserDao\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nStep 5: 데이터베이스 인스턴스 초기화하기\n`Application` 클래스나 관련 진입점에서 Room 데이터베이스 인스턴스를 초기화하세요:\n\n```kotlin\nimport android.app.Application\nimport androidx.room.Room\n\nclass MyApp: Application() {\n\n    companion object {\n        lateinit var database: AppDatabase\n    }\n\n    override fun onCreate() {\n        super.onCreate()\n        database = Room.databaseBuilder(\n            applicationContext,\n            AppDatabase::class.java,\n            \"my_database\"\n        ).build()\n    }\n}\n```\n\n## 섹션 2: 데이터베이스 작업 수행하기\n\nStep 1: 데이터 삽입\n사용자를 데이터베이스에 삽입하려면 `UserDao`에 정의된 `insertUser` 메서드를 사용할 수 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nval newUser = User(username = \"JohnDoe\", email = \"john@example.com\")\nMyApp.database.userDao().insertUser(newUser)\n```\n\n단계 2: 데이터 검색\n데이터베이스에서 모든 사용자를 검색하려면 `UserDao`의 `getAllUsers` 메서드를 사용하십시오:\n\n```js\nval userList: List<User> = MyApp.database.userDao().getAllUsers()\n```\n\n인젝션 가능한 Room 데이터베이스 객체를 설정하는 데모 프로젝트를 확인해주세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n데모 프로젝트 링크: https://github.com/raikwaramit/RoomDatabaseModule/\n\n## 결론:\n\nAndroid 앱에서 Room 데이터베이스를 구현하면 데이터 저장을 간편하게 처리할 수 있습니다. 직관적인 설정과 강력한 기능으로 앱의 로컬 데이터를 효율적으로 관리할 수 있습니다. 이 가이드를 따라가면 Room 설정, 엔티티 및 DAO 정의, 데이터베이스 작업 수행, 마이그레이션 처리 방법을 배울 수 있습니다.\n\n이 가이드에서는 Room의 기본 사항을 다루었습니다. 라이브러리에 익숙해지면 데이터베이스 관계, LiveData 통합, 복잡한 쿼리와 같은 고급 기능을 탐색할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n룸을 사용하면 Android 앱에서 로컬 데이터를 관리하는 것이 더 쉬워집니다. 코딩을 즐기세요!\n","ogImage":{"url":"/assets/img/2024-05-20-GettingStartedwithRoomDatabaseinAndroid_0.png"},"coverImage":"/assets/img/2024-05-20-GettingStartedwithRoomDatabaseinAndroid_0.png","tag":["Tech"],"readingTime":6},{"title":"코틀린 코루틴에서 에러 다루기 예외 처리와 에러 전파","description":"","date":"2024-05-20 15:53","slug":"2024-05-20-DealingwithErrorsinKotlinCoroutinesExceptionHandlingandErrorPropagation","content":"\n![image](/assets/img/2024-05-20-DealingwithErrorsinKotlinCoroutinesExceptionHandlingandErrorPropagation_0.png)\n\n현대 비동기 프로그래밍 패러다임에서는 Kotlin 코루틴이 중심적인 역할을 합니다. 비동기 프로그래밍 프로세스 중 발생하는 오류를 효과적으로 처리하는 것은 애플리케이션의 견고성과 신뢰성에 중요합니다. 본 문서에서는 Kotlin 코루틴을 사용할 때 오류 관리의 중요한 측면을 탐구하고 오류 전파의 복잡성을 다루고자 합니다.\n\n비동기 프로그래밍은 현대 소프트웨어 개발에서 널리 사용됩니다. 그러나 이러한 프로그래밍 프로세스에서 오류를 만나는 것은 불가피합니다. 네트워크 호출, 파일 작업, 데이터베이스 상호작용 및 기타 외부 소스에서 발생하는 오류를 효과적으로 해결하여 애플리케이션의 신뢰성과 사용자 경험을 보장해야 합니다. Kotlin 코루틴은 비동기 프로그래밍 시 이러한 오류를 처리하는 다양한 도구와 전략을 제공합니다.\n\n# 코루틴 스코프 내에서 오류 처리\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nKotlin 코루틴을 사용할 때, 코루틴 스코프 내에서 오류 처리를 확실히 하는 것은 비동기 작업을 효과적으로 관리하는 데 중요합니다. 코루틴 스코프는 특정 작업의 라이프사이클을 제어하며, 내부에서 발생할 수 있는 모든 오류를 적절히 처리해야 합니다.\n\n![image](/assets/img/2024-05-20-DealingwithErrorsinKotlinCoroutinesExceptionHandlingandErrorPropagation_1.png)\n\n위 예시에서는, 코루틴 내에서 발생하는 오류가 외부 스코프에서 캐치되어 적절히 처리될 수 있습니다.\n\n# Supervisor Jobs\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nSupervisor 작업은 특히 병렬 coroutine이 관련된 시나리오에서 오류 관리에 필수적인 도구입니다. Supervisor 작업은 한 coroutine에서 발생한 오류가 다른 coroutine에 영향을 미치지 않도록 보장하여 응용 프로그램의 전체 강건성을 향상시킵니다.\n\n![이미지](/assets/img/2024-05-20-DealingwithErrorsinKotlinCoroutinesExceptionHandlingandErrorPropagation_2.png)\n\nSupervisor 작업을 사용하면 coroutine의 오류가 다른 coroutines에 영향을 주지 않도록하여 프로세스가 계속될 수 있습니다.\n\n# 오류 전파\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 오류가 전파되는 방법에 대해 이야기해 보겠습니다. 코루틴에서 결과를 기다리다가 문제가 발생하면 어떻게 처리할 수 있는지 알아봅시다:\n\n![이미지](/assets/img/2024-05-20-DealingwithErrorsinKotlinCoroutinesExceptionHandlingandErrorPropagation_3.png)\n\n위의 예제에서 우리는 async 코루틴 내에서 예외를 던지고 적절히 예외를 처리하여 처리하는 방법을 확인할 수 있습니다.\n\n그럼 이제 여기까지입니다! 코틀린 코루틴을 사용하면 오류 처리가 쉬워집니다. 코루틴 스코프 내에서, 슈퍼바이저 작업을 사용하여, 또는 오류 전파를 다룰 때, 코드를 견고하고 신뢰할 수 있게 유지할 수 있는 도구를 갖고 있습니다. 그러니 맘 놓고 코루틴에 더 깊이 파고들어보고 오류를 두려워하지 마세요!\n","ogImage":{"url":"/assets/img/2024-05-20-DealingwithErrorsinKotlinCoroutinesExceptionHandlingandErrorPropagation_0.png"},"coverImage":"/assets/img/2024-05-20-DealingwithErrorsinKotlinCoroutinesExceptionHandlingandErrorPropagation_0.png","tag":["Tech"],"readingTime":3}],"page":"93","totalPageCount":119,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":4},"__N_SSG":true}