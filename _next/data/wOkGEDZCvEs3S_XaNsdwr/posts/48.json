{"pageProps":{"posts":[{"title":"MVVM 아키텍처로 SwiftUI 앱 구축하기 실전 안내","description":"","date":"2024-06-19 10:58","slug":"2024-06-19-BuildingaSwiftUIAppwithMVVMArchitectureAPracticalGuide","content":"\n이 튜토리얼에서는 MVVM(Model-View-ViewModel) 아키텍처를 사용하여 간단한 SwiftUI 애플리케이션을 만드는 방법을 안내합니다. 데이터 처리 및 네트워킹을 위해 Combine 프레임워크를 활용할 것입니다. 이 예제에서는 REST API에서 데이터를 가져오고 게시하는 방법을 보여줍니다.\n\n# 개요\n\n다음과 같은 간단한 앱을 만들 것입니다:\n\n- 서버에서 게시물 목록을 가져오기.\n- SwiftUI 뷰에서 게시물을 표시하기.\n- 새 게시물을 생성하기.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 프로젝트 설정\n\n먼저 Xcode에서 새로운 SwiftUI 프로젝트를 생성하세요. 그런 다음, 더 나은 구성을 위해 다음과 같은 폴더를 설정합니다:\n\n- Models\n- ViewModels\n- Views\n- Services\n\n# Models\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\"Post\" 모델을 시작해봅시다. 이 모델은 Identifiable과 Codable을 준수합니다.\n\n```swift\n// Models/Post.swift\n\nimport Foundation\n\nstruct Post: Identifiable, Codable {\n    let id: Int\n    let title: String\n    let body: String\n}\n```\n\n# 서비스\n\n네트워크 요청을 처리하기 위한 서비스 레이어가 필요합니다. ApiService와 ApiEndpoints를 만들 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n// Services/ApiEndpoints.swift\n\nimport Foundation\n\nclass ApiEndpoints {\nstatic let baseURL = \"https://jsonplaceholder.typicode.com\"\n\n    static var posts: String { return \"\\(baseURL)/posts\" }\n    static func post(id: Int) -> String { return \"\\(baseURL)/posts/\\(id)\" }\n\n}\n\n// Services/ApiService.swift\n\nimport Foundation\nimport Combine\n\nclass ApiService {\nstatic let shared = ApiService()\nprivate init() {}\n\n    private func makeRequest<T: Decodable>(url: String, method: String, body: Data? = nil) -> AnyPublisher<T, Error> {\n        guard let url = URL(string: url) else {\n            fatalError(\"Invalid URL\")\n        }\n\n        var request = URLRequest(url: url)\n        request.httpMethod = method\n        if let body = body {\n            request.httpBody = body\n            request.setValue(\"application/json\", forHTTPHeaderField: \"Content-Type\")\n        }\n\n        return URLSession.shared.dataTaskPublisher(for: request)\n            .tryMap { output in\n                guard let response = output.response as? HTTPURLResponse,\n                      response.statusCode >= 200 && response.statusCode < 300 else {\n                    throw URLError(.badServerResponse)\n                }\n                return output.data\n            }\n            .decode(type: T.self, decoder: JSONDecoder())\n            .eraseToAnyPublisher()\n    }\n\n    func get<T: Decodable>(url: String) -> AnyPublisher<T, Error> {\n        return makeRequest(url: url, method: \"GET\")\n    }\n\n    func post<T: Decodable, U: Encodable>(url: String, body: U) -> AnyPublisher<T, Error> {\n        guard let bodyData = try? JSONEncoder().encode(body) else {\n            fatalError(\"Invalid body data\")\n        }\n        return makeRequest(url: url, method: \"POST\", body: bodyData)\n    }\n\n    func delete<T: Decodable>(url: String) -> AnyPublisher<T, Error> {\n        return makeRequest(url: url, method: \"DELETE\")\n    }\n\n}\n\n# ViewModels\n\n이제, PostViewModel을 만들어서 게시물을 가져오고 만들어봅시다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```swift\n// ViewModels/PostViewModel.swift\n\nimport Foundation\nimport Combine\n\nclass PostViewModel: ObservableObject {\n    @Published var posts: [Post] = []\n    @Published var isLoading = false\n    @Published var errorMessage: String? = nil\n\n    private var cancellables = Set<AnyCancellable>()\n    private let apiService = ApiService.shared\n\n    func fetchPosts() {\n        self.isLoading = true\n        self.errorMessage = nil\n\n        apiService.get(url: ApiEndpoints.posts)\n            .receive(on: DispatchQueue.main)\n            .sink(receiveCompletion: { [weak self] completion in\n                self?.isLoading = false\n                switch completion {\n                case .failure(let error):\n                    self?.errorMessage = error.localizedDescription\n                case .finished:\n                    break\n                }\n            }, receiveValue: { [weak self] posts in\n                self?.posts = posts\n            })\n            .store(in: &cancellables)\n    }\n\n    func createPost() {\n        let newPost = Post(id: 101, title: \"New Post\", body: \"This is a new post.\")\n\n        apiService.post(url: ApiEndpoints.posts, body: newPost)\n            .receive(on: DispatchQueue.main)\n            .sink(receiveCompletion: { completion in\n                switch completion {\n                case .failure(let error):\n                    print(\"Error: \\(error.localizedDescription)\")\n                case .finished:\n                    print(\"Post created successfully\")\n                }\n            }, receiveValue: { (post: Post) in\n                print(\"Created post: \\(post)\")\n            })\n            .store(in: &cancellables)\n    }\n}\n```\n\n# Views\n\n마지막으로, SwiftUI 뷰를 생성하여 게시물을 표시하고 사용자 상호작용을 처리합니다.\n\n```swift\n// Views/PostListView.swift\n\nimport SwiftUI\n\nstruct PostListView: View {\n    @StateObject private var viewModel = PostViewModel()\n\n    var body: some View {\n        NavigationView {\n            VStack {\n                if viewModel.isLoading {\n                    ProgressView(\"로딩 중...\")\n                } else if let errorMessage = viewModel.errorMessage {\n                    Text(\"오류: \\(errorMessage)\")\n                } else {\n                    List(viewModel.posts) { post in\n                        VStack(alignment: .leading) {\n                            Text(post.title)\n                                .font(.headline)\n                            Text(post.body)\n                                .font(.subheadline)\n                        }\n                    }\n                }\n            }\n            .navigationTitle(\"게시물\")\n            .onAppear {\n                viewModel.fetchPosts()\n            }\n            .toolbar {\n                Button(action: {\n                    viewModel.createPost()\n                }) {\n                    Image(systemName: \"plus\")\n                }\n            }\n        }\n    }\n}\n\nstruct PostListView_Previews: PreviewProvider {\n    static var previews: some View {\n        PostListView()\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 모두 함께 적용하기\n\n모두가 동작하는 것을 보려면 PostListView를 App 구조체의 진입점으로 설정하세요.\n\n```js\n// demoApp.swift\n\nimport SwiftUI\n\n@main\nstruct demoApp: App {\n    var body: some Scene {\n        WindowGroup {\n            PostListView()\n        }\n    }\n}\n```\n\n이 튜토리얼에서는 SwiftUI 애플리케이션에서 간단한 MVVM 아키텍처를 구현했습니다. 이 구조는 관심사를 분리하여 코드를 보다 깨끗하고 유지보수하기 쉽게 만들어주며, Combine과 같은 Swift의 강력한 기능을 활용하여 비동기 데이터 스트림 처리에도 도움이 됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 안내를 따르면 SwiftUI 프로젝트에서 MVVM을 설정하고 사용하는 방법에 대해 잘 이해할 수 있을 것입니다. 코딩을 즐기세요!\n","ogImage":{"url":"/assets/img/2024-06-19-BuildingaSwiftUIAppwithMVVMArchitectureAPracticalGuide_0.png"},"coverImage":"/assets/img/2024-06-19-BuildingaSwiftUIAppwithMVVMArchitectureAPracticalGuide_0.png","tag":["Tech"],"readingTime":8},{"title":"Linker command failed with exit code 1 오류 해결하기","description":"","date":"2024-06-19 10:58","slug":"2024-06-19-FixingLinkercommandfailedwithexitcode1","content":"\n<img src=\"/assets/img/2024-06-19-FixingLinkercommandfailedwithexitcode1_0.png\" />\n\niOS 개발 중 에러를 만나면 “Linker command failed with exit code 1”과 같은 알 수 없는 메시지가 표시되면 특히 답답할 수 있습니다. 그러나 걱정하지 마세요! 이 블로그 포스트에서는 이 오류를 해결하고 iOS 프로젝트를 다시 가동할 수 있는 몇 가지 간단한 단계를 안내해 드릴 거에요.\n\n이 오류가 의미하는 바:\n\n“Linker command failed with exit code 1” 오류는 주로 Xcode가 프로젝트 파일을 함께 연결할 수 없을 때 발생합니다. Xcode가 파일을 읽는 데 어려움을 겪는 경우는 파일을 삭제했지만 제대로 삭제되지 않은 복사본이나 종속성이 제대로 읽을 수 없는 경우입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 이 오류를 해결하는 데 따를 수 있는 몇 가지 단계입니다:\n\n- 팟 다시 설치\n\n  1.  먼저 맥에서 터미널을 엽니다.\n  2.  아래 명령어를 따릅니다:\n\n      cd 당신의*프로젝트*경로\n      pod deintegrate\n      pod update\n\n만약 문제가 계속되면 다음을 시도해보세요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- pod deintegrate\n- pod clean\n- rm Podfile\n- pod init\n- pod install\n\n2. Go to your Project navigator - Target - Build settings - Set BUILD ACTIVE ARCHITECTURE ONLY to NO\n3. Add archicture arm64 and x86_64 in Project navigator - Target - Build settings - EXCLUDED ARCHECTURES\n\n4. Reinstall swift packages\n\n- Remove swift packages and add them again in your project. Don’t remove all the packages at once, start by removing and immediately adding the package that you installed last.\n- Reinstall one package and build your project. If the error still persists, remove another package and reinstall it. Keep doing it with all the packages you have in your project.\n- Don’t forget to press cmd+shift+k to clean build folder before building the project.\n- Also, clean derived data from your project and run Reset package content in your project\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n결론:\n그런 걸로 끝났어요! 이 간단한 단계를 따라하면 iOS 프로젝트에서 \"Linker command failed with exit code 1\" 오류를 해결할 수 있을 겁니다. 기억하세요, 에러 해결은 iOS 개발의 필수적인 부분이에요. 조금의 인내와 적절한 도구가 있다면 모든 어려움을 극복할 수 있습니다.\n\n즐거운 코딩 되세요!\n","ogImage":{"url":"/assets/img/2024-06-19-FixingLinkercommandfailedwithexitcode1_0.png"},"coverImage":"/assets/img/2024-06-19-FixingLinkercommandfailedwithexitcode1_0.png","tag":["Tech"],"readingTime":3},{"title":"iOS에서 Swift를 사용하여 견고한 네트워크 계층 구축하기","description":"","date":"2024-06-19 10:56","slug":"2024-06-19-BuildingaRobustNetworkLayeriniOSUsingSwift","content":"\n![이미지](/assets/img/2024-06-19-BuildingaRobustNetworkLayeriniOSUsingSwift_0.png)\n\n현대 iOS 개발에서 API 호출 및 데이터 검색을 효율적이고 안전하게 처리하기 위해 잘 구조화된 네트워크 레이어를 갖는 것이 중요합니다. 이 기사에서는 제공된 코드를 기반으로 Swift로 견고한 네트워크 레이어를 만드는 방법을 안내합니다.\n\n# 개요\n\n우리의 네트워크 레이어는 여러 중요한 구성 요소로 구성됩니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- NetworkError: 다양한 종류의 네트워크 오류를 처리하기 위한 포괄적 인템.\n- NetworkRequest: 네트워크 요청에 필요한 속성과 메소드를 정의하는 프로토콜.\n- NetworkManager: 네트워크 요청 수행, 응답 해석 및 파일 다운로드 처리를 담당하는 싱글톤 클래스입니다.\n\n또한 이러한 구성 요소를 예시 API 호출 및 파일 다운로드와 함께 사용하는 방법을 보여줄 것입니다.\n\n# 단계 1: 네트워크 오류 정의하기\n\n다양한 네트워크 관련 오류를 깨끗하고 조직된 방식으로 처리하는 데 도움이 되는 NetworkError 열거형을 정의하는 것부터 시작해보겠습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nimport Foundation\n\nenum NetworkError: Error {\n    case badURL\n    case requestFailed(Error)\n    case invalidResponse\n    case dataNotFound\n    case decodingFailed(Error)\n    case encodingFailed(Error)\n    case notFound\n    case internalServerError\n    case unknownError(statusCode: Int)\n}\n\nstruct DecodingError: Error {\n    let message: String\n}\n```\n\n설명:\n\nNetworkError Enum: 이 Enum은 발생할 수 있는 가능한 네트워크 관련 오류를 나열하여 오류 처리를 더 쉽게 할 수 있게 합니다.\n\n- badURL: 유효하지 않은 URL을 나타냄.\n- requestFailed: 네트워크 요청 실패를 나타내며 원래 오류를 저장함.\n- invalidResponse: 받은 응답이 유효하지 않음을 나타냄.\n- dataNotFound: 응답에서 기대하는 데이터를 찾을 수 없음을 나타냄.\n- decodingFailed: 응답 데이터를 기대하는 타입으로 디코딩하는 데 실패함을 나타냄.\n- encodingFailed: 요청 매개변수 인코딩 실패를 나타냄.\n- notFound: 404 오류를 나타냄.\n- internalServerError: 500 오류를 나타냄.\n- unknownError: 연결된 상태 코드와 함께 알 수 없는 오류를 나타냄.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n표 태그를 Markdown 형식으로 변경하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n네트워크 요청 프로토콜: 모든 네트워크 요청이 따라야 하는 구조를 정의합니다.\n\n- url: 엔드포인트 URL입니다.\n- method: HTTP 메서드(GET, POST 등)입니다.\n- headers: 요청에 필요한 헤더입니다.\n- parameters: 인코딩 가능 프로토콜을 준수하는 요청 매개변수입니다.\n\nHTTPMethod Enum: 요청에 사용되는 다양한 HTTP 메서드를 나타냅니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nHTTPHeader Enum: 일반적인 HTTP 헤더 필드를 나타냅니다.\n\nContentType Enum: HTTP 헤더의 일반적인 콘텐츠 유형을 나타냅니다.\n\n# 단계 3: URLRequest 생성을 위해 NetworkRequest 확장\n\nNetworkRequest 프로토콜을 확장하여 URLRequest 객체를 생성하는 메서드를 포함시킵니다. 이 확장은 HTTP 헤더 및 매개변수 설정을 처리합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```swift\nextension NetworkRequest {\n    func urlRequest() throws -> URLRequest {\n        guard let url = url else {\n            throw NetworkError.badURL\n        }\n\n        var request = URLRequest(url: url)\n        request.httpMethod = method.rawValue\n\n        if let headers = headers {\n            for (key, value) in headers {\n                request.setValue(value, forHTTPHeaderField: key.rawValue)\n            }\n        }\n\n        if let parameters = parameters {\n            if method == .get {\n                var urlComponents = URLComponents(url: url, resolvingAgainstBaseURL: false)\n                let parameterData = try JSONEncoder().encode(parameters)\n                let parameterDictionary = try JSONSerialization.jsonObject(with: parameterData, options: []) as? [String: Any]\n                urlComponents?.queryItems = parameterDictionary?.map { URLQueryItem(name: $0.key, value: \"\\($0.value)\") }\n                request.url = urlComponents?.url\n            } else {\n                do {\n                    let jsonData = try JSONEncoder().encode(parameters)\n                    request.httpBody = jsonData\n                } catch {\n                    throw NetworkError.encodingFailed(error)\n                }\n            }\n        }\n\n        return request\n    }\n}\n```\n\n해설:\n\nURLRequest 생성 메소드: NetworkRequest를 URLRequest 객체로 변환합니다.\n\n- 유효한 URL을 확인하고, 그렇지 않으면 badURL 오류를 발생시킵니다.\n- HTTP 메소드 설정합니다.\n- 제공된 헤더를 설정합니다.\n- 매개변수를 인코딩하고 설정합니다:\n  - GET 요청의 경우, 매개변수를 쿼리 항목으로 추가합니다.\n  - 다른 메소드의 경우, 매개변수를 JSON으로 인코딩하고 요청 본문으로 설정합니다.\n- 인코딩에 실패하면 encodingFailed 오류를 발생시킵니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 단계 4: NetworkManager 구현\n\nNetworkManager는 네트워크 요청을 수행하고 응답을 처리하는 싱글톤 클래스입니다. 이 클래스는 역 호환성을 위해 async/await 및 completion handlers를 모두 지원합니다.\n\n# Async/Await 구현\n\n```js\nimport Foundation\nimport UIKit\n\nclass NetworkManager {\n    static let shared = NetworkManager()\n    private let urlSession = URLSession.shared\n\n    private init() {}\n\n    func perform<T: Decodable>(_ request: NetworkRequest, decodeTo type: T.Type) async throws -> T {\n        if #available(iOS 15.0, *) {\n            let urlRequest = try request.urlRequest()\n            let (data, response) = try await urlSession.data(for: urlRequest)\n            try processResponse(response: response)\n            return try decodeData(data: data, type: T.self)\n        } else {\n            return try await withCheckedThrowingContinuation { continuation in\n                perform(request, decodeTo: type) { result in\n                    switch result {\n                    case .success(let data):\n                        continuation.resume(returning: data)\n                    case .failure(let error):\n                        continuation.resume(throwing: error)\n                    }\n                }\n            }\n        }\n    }\n\n    private func decodeData<T: Decodable>(data: Data, type: T.Type) throws -> T {\n        do {\n            let decodedObject = try JSONDecoder().decode(T.self, from: data)\n            return decodedObject\n        } catch let decodingError {\n            throw NetworkError.decodingFailed(decodingError)\n        }\n    }\n\n    private func processResponse(response: URLResponse?) throws {\n        guard let httpResponse = response as? HTTPURLResponse else {\n            throw NetworkError.invalidResponse\n        }\n\n        switch httpResponse.statusCode {\n        case 200...299:\n            return\n        case 404:\n            throw NetworkError.notFound\n        case 500:\n            throw NetworkError.internalServerError\n        default:\n            throw NetworkError.unknownError(statusCode: httpResponse.statusCode)\n        }\n    }\n\n    func downloadFile(from url: URL) async throws -> URL {\n        if #available(iOS 15.0, *) {\n            let (localURL, response) = try await urlSession.download(from: url)\n            try processResponse(response: response)\n            return localURL\n        } else {\n            return try await withCheckedThrowingContinuation { continuation in\n                downloadFile(from: url) { result in\n                    switch result {\n                    case .success(let localURL):\n                        continuation.resume(returning: localURL)\n                    case .failure(let error):\n                        continuation.resume(throwing: error)\n                    }\n                }\n            }\n        }\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n설명:\n\nNetworkManager Singleton: 네트워크 요청을 수행하기 위한 단일 인스턴스를 제공합니다.\n\n- shared: 싱글톤 인스턴스입니다.\n- urlSession: 네트워크 작업을 위한 공유 URLSession 인스턴스입니다.\n- init(): 여러 인스턴스 생성을 방지하기 위한 비공개 이니셜라이저입니다.\n\nperform 메서드:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- iOS 15.0 이상인 경우:\n  - NetworkRequest에서 URLRequest를 생성합니다.\n  - 요청을 비동기적으로 처리합니다.\n  - 응답을 처리합니다.\n  - 응답 데이터를 지정된 유형으로 디코딩합니다.\n- 이전 iOS 버전의 경우:\n  - 완료 핸들러를 사용하여 요청을 처리하는 데 continuation을 사용합니다.\n\ndecodeData 메서드: 데이터를 지정된 유형으로 디코딩하고 디코딩에 실패하면 decodingFailed 오류를 throw합니다.\n\nprocessResponse 메서드: HTTP 응답을 유효성 검사하고 상태 코드에 따라 적절한 오류를 throw합니다.\n\ndownloadFile 메서드: 지정된 URL에서 파일을 다운로드하며 역호환성을 위해 async/await 및 완료 핸들러를 모두 지원합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 완료 핸들러 구현\n\n오래된 iOS 버전을 위해 완료 핸들러를 사용하여 네트워크 요청을 구현합니다.\n\n```swift\nextension NetworkManager {\n    private func perform<T: Decodable>(_ request: NetworkRequest, decodeTo type: T.Type, completion: @escaping (Result<T, NetworkError>) -> Void) {\n        do {\n            let urlRequest = try request.urlRequest()\n            urlSession.dataTask(with: urlRequest) { data, response, error in\n                if let error = error {\n                    completion(.failure(.requestFailed(error)))\n                    return\n                }\n\n                guard let data = data else {\n                    completion(.failure(.dataNotFound))\n                    return\n                }\n\n                do {\n                    try self.processResponse(response: response)\n                    let decodedObject = try self.decodeData(data: data, type: T.self)\n                    completion(.success(decodedObject))\n                } catch {\n                    completion(.failure(error as? NetworkError ?? .invalidResponse))\n                }\n            }.resume()\n        } catch {\n            completion(.failure(error as? NetworkError ?? .invalidResponse))\n        }\n    }\n\n    private func downloadFile(from url: URL, completion: @escaping (Result<URL, NetworkError>) -> Void) {\n        urlSession.downloadTask(with: url) { localURL, response, error in\n            if let error = error {\n                completion(.failure(.requestFailed(error)))\n                return\n            }\n\n            guard let localURL = localURL else {\n                completion(.failure(.dataNotFound))\n                return\n            }\n\n            do {\n                try self.processResponse(response: response)\n                completion(.success(localURL))\n            } catch {\n                completion(.failure(error as? NetworkError ?? .invalidResponse))\n            }\n        }.resume()\n    }\n}\n```\n\n설명:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n완료 핸들러를 사용하여 perform 메소드:\n\n- URLRequest를 생성하고 URLSession.dataTask를 사용하여 요청을 수행합니다.\n- 오류를 처리하고 응답 유효성을 확인합니다.\n- 응답 데이터를 디코딩하고 결과로 완료 핸들러를 호출합니다.\n\n완료 핸들러를 사용하여 downloadFile 메소드:\n\n- URLSession.downloadTask를 사용하여 파일을 다운로드합니다.\n- 오류를 처리하고 응답 유효성을 확인합니다.\n- 다운로드된 파일의 로컬 URL로 완료 핸들러를 호출합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 단계 5: 이미지 다운로드 및 캐싱\n\n이미지 다운로드를 처리하고 선택적으로 캐싱하는 NetworkManager를 확장합니다.\n\n```js\nextension NetworkManager {\n    func downloadImage(from url: URL, cacheEnabled: Bool = true) async -> Result<UIImage, NetworkError> {\n        do {\n            if cacheEnabled, let cachedImage = try getCachedImage(for: url) {\n                return .success(cachedImage)\n            }\n\n            let localURL = try await NetworkManager.shared.downloadFile(from: url)\n            let imageData = try Data(contentsOf: localURL)\n            if let image = UIImage(data: imageData) {\n                if cacheEnabled {\n                    cacheImage(imageData, for: url)\n                }\n                return .success(image)\n            } else {\n                return .failure(.decodingFailed(DecodingError(message: \"Failed to decode image data\")))\n            }\n        } catch {\n            return .failure(error as? NetworkError ?? .invalidResponse)\n        }\n    }\n\n    private func cacheImage(_ imageData: Data, for url: URL) {\n        let cachedResponse = CachedURLResponse(response: HTTPURLResponse(url: url, statusCode: 200, httpVersion: nil, headerFields: nil)!, data: imageData)\n        URLCache.shared.storeCachedResponse(cachedResponse, for: URLRequest(url: url))\n        checkAndClearCache()\n    }\n\n    private func checkAndClearCache() {\n        let cacheSize = URLCache.shared.currentDiskUsage\n        let cacheLimit: Int = 100 * 1024 * 1024 // 100 MB\n        if cacheSize > cacheLimit {\n            URLCache.shared.removeAllCachedResponses()\n        }\n    }\n\n    private func getCachedImage(for url: URL) throws -> UIImage? {\n        if let cachedResponse = URLCache.shared.cachedResponse(for: URLRequest(url: url)),\n           let image = UIImage(data: cachedResponse.data) {\n            return image\n        }\n        return nil\n    }\n}\n```\n\n설명:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음은 친절한 톤으로 번역한 내용입니다.\n\ndownloadImage 메서드: URL에서 이미지를 다운로드하며 선택적으로 캐싱합니다.\n\n- 캐싱이 활성화된 경우 먼저 캐시를 확인합니다.\n- async/await 또는 이전 iOS 버전을 위한 완료 핸들러를 사용하여 다운로드를 수행합니다.\n- 응답을 처리하고 이미지 데이터를 디코딩합니다.\n- 캐싱이 활성화된 경우 이미지를 캐시에 저장합니다.\n\ncacheImage 메서드: 이미지를 캐시에 저장합니다.\n\nloadImageFromCache 메서드: 캐시에서 이미지를 로드합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 예시 사용법\n\n# API 호출 요청\n\n```js\nstruct ExampleAPIRequest: NetworkRequest {\n    var url: URL? {\n        return URL(string: \"https://api.example.com/data\")\n    }\n    var method: HTTPMethod {\n        return .get\n    }\n    var headers: [HTTPHeader: String]? {\n        return [.contentType: ContentType.json.rawValue]\n    }\n    var parameters: Encodable? {\n        return ExampleParameters(param1: \"value1\", param2: \"value2\")\n    }\n}\n\nstruct ExampleParameters: Encodable {\n    let param1: String\n    let param2: String\n}\n\nstruct ExampleData: Decodable {\n    let id: Int\n    let name: String\n}\n\nfunc fetchExampleData() async {\n    let request = ExampleAPIRequest()\n\n    if #available(iOS 15.0, *) {\n        do {\n            let data: ExampleData = try await NetworkManager.shared.perform(request, decodeTo: ExampleData.self)\n            print(\"데이터 가져오기 성공: \\(data)\")\n        } catch {\n            print(\"데이터 가져오기 실패: \\(error)\")\n        }\n    } else {\n        NetworkManager.shared.perform(request, decodeTo: ExampleData.self) { result in\n            switch result {\n            case .success(let data):\n                print(\"데이터 가져오기 성공: \\(data)\")\n            case .failure(let error):\n                print(\"데이터 가져오기 실패: \\(error)\")\n            }\n        }\n    }\n}\n```\n\n설명:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n`ExampleAPIRequest Struct`: 네트워크 요청을 나타내며 `NetworkRequest` 프로토콜을 준수하는 구조체입니다.\n\n- URL, HTTP 메서드, 헤더 및 매개변수를 지정합니다.\n\n`ExampleParameters Struct`: `Encodable`을 준수하는 요청 매개변수를 나타내는 구조체입니다.\n\n`ExampleData Struct`: `Decodable`을 준수하는 응답 데이터를 나타내는 구조체입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n`table` 태그를 Markdown 형식으로 변경해주세요.\n\nfetchExampleData 함수: async/await를 활용하여 요청을 수행하고 응답을 처리하는 방법을 보여줍니다.\n\n# 이미지 다운로드\n\n```js\nimport SwiftUI\n\nstruct HomeView: View {\n    @State private var image: UIImage? = nil\n\n    var body: some View {\n        VStack {\n            if let image = image {\n                Image(uiImage: image)\n                    .resizable()\n                    .aspectRatio(contentMode: .fit)\n                    .frame(width: 200, height: 200)\n            } else {\n                ProgressView()\n            }\n        }\n        .onAppear {\n            let imageURL = URL(string: \"https://picsum.photos/200/200\")!\n            Task {\n                let result = await NetworkManager.shared.downloadImage(from: imageURL, cacheEnabled: false)\n                switch result {\n                case .success(let success):\n                    self.image = success\n                case .failure(_):\n                    self.image = nil\n                }\n            }\n        }\n    }\n}\n\nstruct HomeView_Previews: PreviewProvider {\n    static var previews: some View {\n        HomeView()\n    }\n}\n```\n\n설명:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nHomeView Struct는 URL에서 다운로드된 이미지를 표시하는 SwiftUI 뷰입니다.\n\n- 이미지 상태를 관리하기 위해 @State를 사용합니다.\n- 이미지를 로드하는 동안 ProgressView를 표시합니다.\n- appear될 때 async/await를 사용하여 이미지를 다운로드합니다.\n- 다운로드 결과를 처리합니다.\n\n# 파일 다운로드\n\n```js\nimport Foundation\n\nfunc downloadExampleFile() async {\n    let fileURL = URL(string: \"https://example.com/file.zip\")!\n\n    if #available(iOS 15.0, *) {\n        do {\n            let localURL = try await NetworkManager.shared.downloadFile(from: fileURL)\n            print(\"다운로드한 파일 경로: \\(localURL)\")\n        } catch {\n            print(\"파일 다운로드 실패: \\(error)\")\n        }\n    } else {\n        NetworkManager.shared.downloadFile(from: fileURL) { result in\n            switch result {\n            case .success(let localURL):\n                print(\"다운로드한 파일 경로: \\(localURL)\")\n            case .failure(let error):\n                print(\"파일 다운로드 실패: \\(error)\")\n            }\n        }\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n설명:\n\ndownloadExampleFile 함수: async/await를 사용하여 파일을 다운로드하는 방법을 보여줍니다.\n\n- 이전 iOS 버전을 위한 async/await 및 완료 핸들러를 모두 지원합니다.\n\n# 결론\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이러한 네트워크 계층이 구현되면 iOS 애플리케이션이 API 요청을 처리하고 응답을 처리하며 파일 다운로드를 관리하는 데 더 잘 준비될 것입니다. 이 구조화된 접근 방식은 코드베이스를 더 깔끔하게 만들 뿐만 아니라 유지 보수가 용이하고 확장성이 뛰어난 장점을 제공합니다.\n","ogImage":{"url":"/assets/img/2024-06-19-BuildingaRobustNetworkLayeriniOSUsingSwift_0.png"},"coverImage":"/assets/img/2024-06-19-BuildingaRobustNetworkLayeriniOSUsingSwift_0.png","tag":["Tech"],"readingTime":21},{"title":"Swift로 강력한 네트워크 레이어 만들기 파트 2","description":"","date":"2024-06-19 10:54","slug":"2024-06-19-CreatingaRobustNetworkLayerinSwiftPart2","content":"\n<img src=\"/assets/img/2024-06-19-CreatingaRobustNetworkLayerinSwiftPart2_0.png\" />\n\n현대 iOS 개발에서는 API 호출 및 데이터 검색을 효율적이고 안전하게 처리하는 데 잘 구조화된 네트워크 레이어가 필수적입니다. 본 후속 기사에서는 SOLID 원칙을 준수하고 클래스 기반에서 구조체 기반으로 전환하여 네트워크 레이어를 개선하고 리팩터링한 내용을 안내해 드릴 것입니다. 이를 통해 코드베이스를 더 잘 유지보수할 수 있고 확장 가능하도록 보장할 것입니다.\n\n# 개요\n\n저희가 업그레이드한 네트워크 레이어에는 다음 구성요소가 포함되어 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- NetworkError: 다양한 네트워크 오류를 처리하기 위한 포괄적인 열거형입니다.\n- NetworkRequest: 네트워크 요청을 위한 필수 속성 및 메서드를 정의하는 프로토콜입니다.\n- HTTPResponseHandler: HTTP 응답을 처리하고 디코딩하는 프로토콜입니다.\n- NetworkEngine: 네트워크 요청 수행, 로깅 및 응답 처리를 담당하는 구조체입니다.\n\n이러한 구성 요소를 예제 API 호출과 함께 사용하는 방법을 보여드리겠습니다.\n\n# 단계 1: 네트워크 오류 정의\n\n먼저 NetworkError 열거형을 정의하여 다양한 네트워크 관련 오류를 깔끔하고 조직적으로 처리합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```swift\nimport Foundation\n\nenum NetworkError: Error {\n    case badURL\n    case requestFailed(Error)\n    case invalidResponse\n    case dataNotFound\n    case decodingFailed(Error)\n    case encodingFailed(Error)\n    case notFound\n    case timeout\n    case internalServerError\n    case unknownError(statusCode: Int)\n}\n\nstruct DecodingError: Error {\n    let message: String\n}\n```\n\n해설:\n\n- NetworkError: 이 열거형은 네트워크 작업 중 발생할 수 있는 다양한 유형의 오류를 캡슐화합니다. 각 case는 특정 오류 시나리오를 나타냅니다:\n  - badURL: URL이 잘못되었음을 나타냅니다.\n  - requestFailed: 요청을 만드는 데 실패한 것을 나타내며 내장된 오류를 캡슐화합니다.\n  - invalidResponse: 응답이 유효하지 않음을 나타냅니다.\n  - dataNotFound: 응답에서 데이터를 찾을 수 없음을 신호합니다.\n  - decodingFailed: 응답 데이터를 해독하는 데 실패한 것을 나타내며 해독 오류를 캡슐화합니다.\n  - encodingFailed: 요청 매개변수를 인코딩하는 데 실패한 것을 나타내며 인코딩 오류를 캡슐화합니다.\n  - notFound: 요청한 리소스를 찾을 수 없음을 나타냅니다 (HTTP 404).\n  - timeout: 타임아웃 오류를 나타냅니다.\n  - internalServerError: 서버 오류임을 나타냅니다 (HTTP 500).\n  - unknownError: 다른 HTTP 상태 코드 오류를 나타내며 상태 코드를 캡슐화합니다.\n\nDecodingError: 해독 중 추가 오류 정보를 제공하기 위한 사용자 정의 오류 구조체입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 단계 2: NetworkRequest 프로토콜 생성하기\n\nNetworkRequest 프로토콜은 URL, HTTP 메소드, 헤더, 매개변수 및 타임아웃 간 필수적인 속성을 정의합니다.\n\n```js\nimport Foundation\n\nenum HTTPMethod: String {\n    case get = \"GET\"\n    case post = \"POST\"\n    case put = \"PUT\"\n    case delete = \"DELETE\"\n}\n\nenum HTTPHeader: String {\n    case contentType = \"Content-Type\"\n    case authorization = \"Authorization\"\n}\n\nenum ContentType: String {\n    case json = \"application/json\"\n    case xml = \"application/xml\"\n    case formUrlEncoded = \"application/x-www-form-urlencoded\"\n}\n\nprotocol NetworkRequest {\n    var url: URL? { get }\n    var method: HTTPMethod { get }\n    var headers: [HTTPHeader: String]? { get }\n    var parameters: Encodable? { get }\n    var timeoutInterval: TimeInterval { get }\n}\n\nextension NetworkRequest {\n    var timeoutInterval: TimeInterval {\n        return 30\n    }\n\n    func urlRequest() throws -> URLRequest {\n        guard let url = url else {\n            throw NetworkError.badURL\n        }\n\n        var request = URLRequest(url: url)\n        request.httpMethod = method.rawValue\n\n        if let headers = headers {\n            for (key, value) in headers {\n                request.setValue(value, forHTTPHeaderField: key.rawValue)\n            }\n        }\n\n        if let parameters = parameters {\n            if method == .get {\n                var urlComponents = URLComponents(url: url, resolvingAgainstBaseURL: false)\n                let parameterData = try JSONEncoder().encode(parameters)\n                let parameterDictionary = try JSONSerialization.jsonObject(with: parameterData, options: []) as? [String: Any]\n                urlComponents?.queryItems = parameterDictionary?.map { URLQueryItem(name: $0.key, value: \"\\($0.value)\") }\n                request.url = urlComponents?.url\n            } else {\n                do {\n                    let jsonData = try JSONEncoder().encode(parameters)\n                    request.httpBody = jsonData\n                } catch {\n                    throw NetworkError.encodingFailed(error)\n                }\n            }\n        }\n\n        return request\n    }\n}\n```\n\n설명:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- HTTPMethod: 우리가 사용할 HTTP 메소드(GET, POST, PUT, DELETE)를 나타내는 enum입니다.\n- HTTPHeader: 일반적인 HTTP 헤더를 위한 enum입니다.\n- ContentType: HTTP 헤더에서 사용되는 일반적인 콘텐츠 유형을 위한 enum입니다.\n- NetworkRequest: 네트워크 요청에 필요한 속성을 정의하는 프로토콜입니다.\n  - url: 요청을 위한 URL입니다.\n  - method: 요청을 위한 HTTP 메소드입니다.\n  - headers: 요청에 대한 선택적 헤더입니다.\n  - parameters: 인코딩 가능한 형식을 준수하는 요청에 대한 선택적 매개변수입니다.\n  - timeoutInterval: 요청의 타임아웃 간격입니다.\n- 프로토콜 확장은 timeoutInterval의 기본 구현과 속성에서 URLRequest를 만들기 위한 urlRequest() 메소드를 제공합니다.\n  - 만약 메소드가 GET이면, 매개변수는 URL에 쿼리 아이템으로 추가됩니다.\n  - 다른 메소드의 경우, 매개변수는 JSON으로 인코딩되어 요청 바디에 추가됩니다.\n  - 헤더는 요청에 추가됩니다.\n\n# 단계 3: HTTPResponseHandler 구현하기\n\nHTTPResponseHandler 프로토콜은 HTTP 응답을 처리하고 디코딩하기 위한 메소드를 정의합니다.\n\n```js\nimport Foundation\n\npublic protocol HTTPResponseHandler {\n    func handleStatusCode(response: URLResponse?) throws\n    func decode<T: Decodable>(data: Data, to type: T.Type) throws -> T\n    func extractETag(from response: URLResponse?) -> String?\n}\n\nextension HTTPResponseHandler {\n    public func decode<T: Decodable>(data: Data, to type: T.Type) throws -> T {\n        do {\n            let decodedObject = try JSONDecoder().decode(T.self, from: data)\n            return decodedObject\n        } catch let decodingError {\n            throw NetworkError.decodingFailed(decodingError)\n        }\n    }\n\n    public func handleStatusCode(response: URLResponse?) throws {\n        guard let httpResponse = response as? HTTPURLResponse else {\n            throw NetworkError.invalidResponse\n        }\n\n        switch httpResponse.statusCode {\n        case 200...299:\n            return\n        case 404:\n            throw NetworkError.notFound\n        case 500:\n            throw NetworkError.internalServerError\n        default:\n            throw NetworkError.unknownError(statusCode: httpResponse.statusCode)\n        }\n    }\n\n    public func extractETag(from response: URLResponse?) -> String? {\n        guard let httpResponse = response as? HTTPURLResponse else {\n            return nil\n        }\n        return httpResponse.allHeaderFields[\"ETag\"] as? String\n    }\n}\n\npublic struct DefaultHTTPResponseHandler: HTTPResponseHandler {\n    public init() {}\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n설명:\n\n- HTTPResponseHandler: HTTP 응답을 처리하고 해독하는 메서드를 정의하는 프로토콜입니다.\n  - handleStatusCode(response:): HTTP 상태 코드를 확인하고 적절한 오류를 throw합니다.\n  - decode(data:to:): Decodable을 준수하는 특정 타입으로 데이터를 디코딩합니다.\n  - extractETag(from:): 응답 헤더에서 ETag을 추출합니다.\n\n이 확장(extension)은 다음을 제공합니다:\n\n- decode(data:to:)은 데이터를 디코딩하기 위해 JSONDecoder를 사용하고 실패할 경우 NetworkError.decodingFailed를 throw합니다.\n- handleStatusCode(response:)은 HTTP 상태 코드를 확인하고 공통 오류(404, 500)에 대해 특정 NetworkError 케이스를 throw하며, 다른 상태 코드에 대해서는 알 수 없는 오류를 throw합니다.\n- extractETag(from:)은 응답 헤더에서 ETag을 가져옵니다.\n- DefaultHTTPResponseHandler: HTTPResponseHandler의 구체적인 구현체입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 단계 4: NetworkEngine 구현\n\nNetworkEngine 구조체는 네트워크 요청을 수행하고 응답을 처리하는 역할을 담당합니다.\n\n```js\nimport Foundation\n\nstruct NetworkRequestContext<T: Decodable> {\n    let request: NetworkRequest\n    let type: T.Type\n    let completion: (Result<T, NetworkError>) -> Void\n    let requestInvokeTime: Date\n}\n\nprotocol NetworkEngineAdapter {\n    func invokeEngine<T: Decodable>(_ request: NetworkRequest, decodeTo type: T.Type, completion: @escaping (Result<T, NetworkError>) -> Void)\n}\n\npublic struct NetworkEngine {\n    private let urlSession: URLSession\n    private let logger: Logger\n    private let responseHandler: HTTPResponseHandler\n\n    public init(urlSession: URLSession = .shared,\n                logger: Logger = DefaultLogger(),\n                responseHandler: HTTPResponseHandler = DefaultHTTPResponseHandler()) {\n        self.urlSession = urlSession\n        self.logger = logger\n        self.responseHandler = responseHandler\n    }\n}\n\nextension NetworkEngine: NetworkEngineAdapter {\n    func invokeEngine<T>(_ request: NetworkRequest, decodeTo type: T.Type, completion: @escaping (Result<T, NetworkError>) -> Void) where T: Decodable {\n        let requestInvokeTime = Date()\n        let context = NetworkRequestContext(request: request, type: type, completion: completion, requestInvokeTime: requestInvokeTime)\n        fetch(context)\n    }\n\n    private func fetch<T>(_ context: NetworkRequestContext<T>) where T: Decodable {\n        do {\n            var urlRequest = try context.request.urlRequest()\n            urlRequest.timeoutInterval = context.request.timeoutInterval\n\n            urlSession.dataTask(with: urlRequest) { data, response, error in\n                let requestFinishTime = Date()\n                let duration = requestFinishTime.timeIntervalSince(context.requestInvokeTime)\n\n                logger.logMetrics(startTime: context.requestInvokeTime, endTime: requestFinishTime, duration: duration, request: urlRequest)\n\n                if let error = error {\n                    context.completion(.failure(.requestFailed(error)))\n                    return\n                }\n\n                guard let data = data else {\n                    context.completion(.failure(.dataNotFound))\n                    return\n                }\n\n                do {\n                    try responseHandler.handleStatusCode(response: response)\n                    let decodedObject = try responseHandler.decode(data: data, to: context.type)\n                    context.completion(.success(decodedObject))\n                } catch let error as NetworkError {\n                    context.completion(.failure(error))\n                } catch {\n                    context.completion(.failure(.unknownError(statusCode: (response as? HTTPURLResponse)?.statusCode ?? -1)))\n                }\n            }.resume()\n        } catch {\n            context.completion(.failure(.requestFailed(error)))\n        }\n    }\n}\n```\n\n설명:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- NetworkRequestContext: 네트워크 요청의 컨텍스트를 캡슐화하는 구조체로, 요청 자체, 디코딩할 유형, 완료 핸들러, 그리고 요청이 호출된 시간을 포함합니다.\n- NetworkEngineAdapter: 네트워크 엔진을 요청과 함께 호출하고, 디코딩할 유형을 지정하며 완료 핸들러를 제공하는 메소드를 정의하는 프로토콜입니다.\n- NetworkEngine: 네트워크 작업을 수행하는 주요 구조체입니다:\n  - urlSession: 요청을 만드는 데 사용되는 URLSession 인스턴스입니다.\n  - logger: 메트릭 및 오류를 기록하기 위한 로거입니다.\n  - responseHandler: 응답 처리를 위한 HTTPResponseHandler의 인스턴스입니다.\n  - init: NetworkEngine을 urlSession, logger 및 responseHandler에 대한 옵션 매개변수로 초기화합니다.\n- invokeEngine 메소드는 NetworkRequestContext를 생성하고 fetch 메소드를 호출합니다.\n\nfetch 메소드:\n\n- NetworkRequest로부터 URLRequest를 만들려고 시도합니다.\n- 타임아웃 간격을 설정합니다.\n- urlSession.dataTask를 사용하여 네트워크 요청을 수행합니다.\n- 요청에 대한 메트릭을 기록합니다.\n- 오류, 누락된 데이터 및 상태 코드를 처리합니다.\n- 데이터를 디코딩하고 결과와 함께 완료 핸들러를 호출합니다.\n\n# 단계 5: 네트워크 레이어 사용하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 예시는 iOS에서 NetworkEngine을 사용하는 방법을 보여줍니다.\n\n## 네트워크 요청 정의하기\n\n먼저, NetworkRequest 프로토콜을 준수하는 PostService enum을 정의합니다. 이 enum은 네트워크 요청의 세부 사항을 캡슐화합니다.\n\n```swift\nimport Foundation\n\nenum PostService {\n    case fetchPosts\n}\n\nextension PostService: NetworkRequest {\n    var url: URL? {\n        switch self {\n        case .fetchPosts:\n            return URL(string: \"https://2e84f9d6-0dcb-4b93-9238-8b272604b4c1.mock.pstmn.io/v1/posts\")\n        }\n    }\n\n    var method: HTTPMethod {\n        switch self {\n        case .fetchPosts:\n            return .get\n        }\n    }\n\n    var headers: [HTTPHeader : String]? {\n        return [.contentType: ContentType.json.rawValue]\n    }\n\n    var parameters: (any Encodable)? {\n        switch self {\n        case .fetchPosts:\n            return nil\n        }\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여기서 PostService는 URL, HTTP 메서드, 헤더 및 요청에 대한 매개변수를 정의하는 단일 case fetchPosts를 갖습니다. 필요에 따라 더 추가할 수 있어요.\n\n## Repository 생성\n\n다음으로, NetworkEngine를 사용하여 요청을 실행할 repository 클래스를 만듭니다. 이 repository는 게시물을 가져오는 작업을 처리할 거에요:\n\n[연결](/assets/img/2024-06-19-CreatingaRobustNetworkLayerinSwiftPart2_1.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```swift\nprotocol PostsListRepositoryProtocol {\n  func fetchPostsList<T: Decodable>(with request: NetworkRequest, responseType: T.Type, completion: @escaping (Result<T, NetworkError>) -> Void)\n}\n\nfinal class DefaultPostsListRepository: PostsListRepositoryProtocol {\n    private let engine: NetworkEngine\n\n    init(engine: NetworkEngine = NetworkEngine()) {\n        self.engine = engine\n    }\n\n    func fetchPostsList<T>(with request: NetworkRequest, responseType: T.Type, completion: @escaping (Result<T, NetworkError>) -> Void) where T : Decodable {\n        engine.invokeEngine(request, decodeTo: responseType, completion: completion)\n    }\n}\n```\n\n이 저장소에서 fetchPostsList 메서드는 NetworkRequest와 응답을 디코딩할 responseType을 사용합니다. NetworkEngine을 사용하여 요청을 실행하고 결과를 전달하기 위해 완료 핸들러를 호출합니다. 이 저장소를 직접 ViewModel이나 보기 UseCase에 사용할 수 있습니다.\n\n# 결론\n\n이 코드베이스의 네트워크 레이어 디자인은 모듈화, 확장 가능성, 견고한 오류 처리, 테스트 용이성 및 성능 모니터링을 강조하여 확장 가능한 애플리케이션에 적합합니다. 이러한 특성들은 유지 보수성과 신뢰성을 저해하지 않고 앱이 기능과 복잡성을 향상시킬 수 있음을 보장합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n더 많은 통찰과 업데이트를 원하시면 LinkedIn에서 저를 팔로우해주세요.\n","ogImage":{"url":"/assets/img/2024-06-19-CreatingaRobustNetworkLayerinSwiftPart2_0.png"},"coverImage":"/assets/img/2024-06-19-CreatingaRobustNetworkLayerinSwiftPart2_0.png","tag":["Tech"],"readingTime":16},{"title":"파이썬에서 typingTYPE_CHECKING이 30초 안에 설명하기","description":"","date":"2024-06-19 10:53","slug":"2024-06-19-typingTYPE_CHECKINGinPythonExplainedin30Seconds","content":"\n<img src=\"/assets/img/2024-06-19-typingTYPE_CHECKINGinPythonExplainedin30Seconds_0.png\" />\n\n근무 중인 Python 코드베이스에서 이러한 코드 조각을 본 적이 있을 수 있습니다. 이 코드가 무슨 일을 하는지 궁금했던 적이 있다면, 오늘은 여기 있어서 설명해 드리겠습니다.\n\n# typing.TYPE_CHECKING은 그냥 False입니다\n\n```python\nfrom typing import TYPE_CHECKING\n\nprint(TYPE_CHECKING)\n\n# False\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n일반적인 경우에는 TYPE_CHECKING 변수가 그냥 False로 설정되어 있습니다. 하지만 이 경우에 왜 사용하는 걸까요?\n\ntyping.TYPE_CHECKING은 정적 타입 체크(myppy 등)를 할 때 True로 설정된다고 가정됩니다.\n\n그러나 코드를 보통 실행할 때는 단순히 False입니다. 그러면 왜 이걸 사용하는 걸까요?\n\n# 경우 1 — 개 대 인간\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여기에는 서로 가져오는 dog.py와 human.py가 있습니다.\n\n```python\n# dog.py\n\nfrom human import Human\n\nclass Dog:\n    def get_human() -> Human:\n      ...\n```\n\n```python\n# human.py\n\nfrom dog import Dog\n\nclass Human:\n    def get_dog() -> Dog:\n        ...\n```\n\n여기서 서로를 가져오는 순환 포함이 있다는 것을 주의하세요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- dog.py에서 human.py를 가져오고\n- human.py에서는 dog.py를 가져옵니다\n\n그래서 dog.py나 human.py 또는 dog.py나 human.py를 가져오는 다른 Python 스크립트 중 하나를 실행하면 순환 임포트 오류가 발생합니다:\n\n```js\nImportError: cannot import name 'Human' from\npartially initialized module 'human'\n(most likely due to a circular import)\n```\n\n# Case 2 — Dog VS Human, but with TYPE_CHECKING\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nDog와 Human만 유형 주석에 필요하기 때문에 `-` Human과 `-` Dog와 같이 전체 클래스를 가져올 필요는 실제로 없습니다. 원형 가져오기 문제를 피하기 위해 다음 구문을 사용할 수 있습니다.\n\n```js\n# dog.py\nfrom typing import TYPE_CHECKING\n\nif TYPE_CHECKING:\n  from human import Human\n\nclass Dog:\n    def get_human() -> \"Human\":\n      ...\n```\n\n```js\n# human.py\nfrom typing import TYPE_CHECKING\n\nif TYPE_CHECKING:\n  from dog import Dog\n\nclass Human:\n    def get_dog() -> \"Dog\":\n        ...\n```\n\n여기에서 이전 코드에 몇 가지 변경 사항을 가했습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- `typing`에서 `TYPE_CHECKING`을 import하는 부분을 추가했어요.\n- `TYPE_CHECKING` 조건문 아래에서 import 문들을 옮겼어요.\n- Dog와 Human 타입 어노테이션 주변에 따옴표를 추가했어요.\n\n그리고 코드를 실행해보면, 이제는 순환 import 문제가 없어졌어요.\n\n# 왜 순환 import 문제가 사라졌을까요?\n\n```js\ndef get_human() -> Human:\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 예제는 다음과 같이 변경되었습니다:\n\n```python\ndef get_human() -> \"Human\":\n```\n\n따라서 Python은 더 이상 human.py에서 실제 Human 클래스를 가져오려고 시도하지 않습니다 (이는 순환 임포트 문제를 발생시킵니다).\n\n# 그렇다면 TYPE_CHECKING이 왜 필요한가요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n큰 파이썬 프로젝트에서는 어쩌면 언젠가는 mypy와 같은 정적 타입 체커를 사용할 것입니다.\n\n정적 타입 체커를 실행할 때 typing.TYPE_CHECKING 변수를 True로 설정하고 실제로 클래스를 가져옵니다. (걱정 마세요 - 정적 타입 체커는 순환 Import 문제를 다른 방식으로 처리할 수 있습니다)\n\n하지만 코드를 보통 실행하고 정적 타입 체커를 다룰 필요가 없을 때는 실제 클래스를 가져올 필요가 없습니다.\n\n요컨대, TYPE_CHECKING이 추가된 이유는:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 순환 가져오기 문제가 발생하지 않습니다\n- 해당 스크립트를 실행할 때 정적 유형 검사를 여전히 제대로 수행할 수 있습니다 (원래 유형 주석을 제거할 필요가 없음)\n\n# 결론\n\n확실하고 이해하기 쉬웠기를 바랍니다.\n\n# 만약 제작자로서 저를 지원하고 싶다면\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 이 이야기에 대해 50번 박수를 쳐주세요\n- 생각을 말씀해 주시는 댓글을 남겨주세요\n- 이야기 중 가장 좋아하는 부분을 강조해주세요\n\n감사합니다! 이 작은 행동들이 큰 도움이 되고, 정말 감사드립니다!\n\nYouTube: https://www.youtube.com/@zlliu246\n\nLinkedIn: https://www.linkedin.com/in/zlliu/\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n제 Ebooks: [https://zlliu.co/ebooks](https://zlliu.co/ebooks)\n","ogImage":{"url":"/assets/img/2024-06-19-typingTYPE_CHECKINGinPythonExplainedin30Seconds_0.png"},"coverImage":"/assets/img/2024-06-19-typingTYPE_CHECKINGinPythonExplainedin30Seconds_0.png","tag":["Tech"],"readingTime":6},{"title":"이 12개의 YouTube 채널로 12가지를 배워보세요","description":"","date":"2024-06-19 10:52","slug":"2024-06-19-Learn12ThingswithThese12YouTubeChannels","content":"\n<img src=\"/assets/img/2024-06-19-Learn12ThingswithThese12YouTubeChannels_0.png\" />\n\n새로운 것을 배우고 성장하고 싶으세요? 좋은 소식입니다! 유튜브를 시청하면 그것이 가능합니다! 여러분이 다양한 분야에서 도움을 받을 수 있는 12가지 멋진 채널을 소개합니다.\n\n- FreeCodeCamp: 코딩 배우기\n  컴퓨터 프로그램을 만드는 방법을 배우고 싶다면 FreeCodeCamp를 확인해보세요. 초보자를 위한 쉬운 레슨과 전문가를 위한 더 어려운 것도 있습니다.\n- TED: 영감을 얻기\n  TED는 다양한 주제에 대해 이야기합니다. 전 세계 사람들이 아이디어와 이야기를 나눕니다. 새로운 것을 배우고 영감을 받는 좋은 방법입니다.\n- Jeff Nippard: 피트니스 팁\n  건강하고 강한 모습을 유지하는 것을 좋아한다면 Jeff Nippard가 도움이 될 것입니다. 운동 및 건강한 식습관에 대한 조언과 설명에는 과학적 근거가 포함되어 있습니다.\n- Veritasium: 재미있는 과학\n  Veritasium은 과학을 즐겁게 합니다! 멋진 실험을 수행하고 어려운 것을 쉽게 설명합니다. 당신도 곧 과학 전문가가 될 거예요!\n- Charisma on Command: 더 매력적으로\n  더 매력적이 되고 싶나요? Charisma on Command가 가르쳐 줍니다. 사람들이 당신을 좋아하게끔 말하고 행동하는 방법을 배우세요.\n- Miles Beckler: 디지털 마케팅 팁\n  Miles Beckler은 디지털 마케팅을 이해하는 데 도움이 됩니다. 온라인 비즈니스를 키우고 싶다면, 그의 조언은 매우 유용할 수 있습니다.\n- Ahrefs: SEO 마스터\n  Ahrefs는 웹사이트를 검색 엔진에 표시하는 팁을 제공합니다. 복잡해 보일 수 있지만, 그들은 쉽게 이해할 수 있게 설명해줍니다.\n- Khan Academy: 모든 것 배우기\n  Khan Academy는 다양한 주제에 대한 무료 레슨을 제공합니다. 컴퓨터에 교사가 있는 것처럼 느껴집니다. 모든 연령층에게 좋습니다!\n- Mindvalley: 개인적으로 성장하기\n  Mindvalley는 자신을 더 나아지게 하는 것에 대한 모든 것입니다. 영적 성장, 생산성 및 기타 도움이 되는 주제에 대해 배웁니다.\n- Athlean-X: 건강하고 강해지기\n  건강하고 강해지고 싶다면 Athlean-X가 가야할 곳입니다. Jeff Cavaliere가 운동 및 훈련에 대한 전문적인 조언을 제공합니다.\n- Nerdwriter1: 깊이 생각하기\n  Nerdwriter1은 예술과 문화에 대해 간단히 이야기합니다. 흥미로운 것을 설명해주는 현명한 친구가 당신에게 흥미로운 것을 설명해줍니다.\n- Vsauce: 재미있는 사실 배우기\n  Vsauce는 흥미로운 질문에 재미있게 대답합니다. 멋진 사실을 배우며 즐길 수 있습니다.\n\n이 유튜브 채널들은 여러분만의 교사와 멘토가 있는 것과 같습니다. 그러니 편히 앉아서 배우고 성장하는 여정을 시작해보세요!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 글을 읽어 주셔서 감사합니다! 🙏😊\n","ogImage":{"url":"/assets/img/2024-06-19-Learn12ThingswithThese12YouTubeChannels_0.png"},"coverImage":"/assets/img/2024-06-19-Learn12ThingswithThese12YouTubeChannels_0.png","tag":["Tech"],"readingTime":2},{"title":"잘 검토할 수 있는 풀 리퀘스트를 만드는 방법","description":"","date":"2024-06-19 10:51","slug":"2024-06-19-HowICreateEasy-to-ReviewPullRequests","content":"\n## 생산성 | 프로그래밍 | 혁신\n\n![이미지](/assets/img/2024-06-19-HowICreateEasy-to-ReviewPullRequests_0.png)\n\n리뷰하기 쉬운 풀 리퀘스트(Pull Requests)를 작성하면 머지 프로세스가 빨라집니다. 머지 속도를 높이면 비즈니스 진행 속도와 제품 품질 향상 속도가 빨라집니다.\n\n그러므로, 리뷰하기 쉬운 풀 리퀘스트를 만드는 것이 매우 중요하다고 생각합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 1. 변경된 파일이 너무 많습니까?\n\n풀 리퀘스트를 생성하기 전 (또는 구현하기 전) 확인해야 할 사항 중 하나는 작업의 세분성입니다. 작업의 세분성이 너무 크면 한 번의 풀 리퀘스트에서 변경된 파일의 수가 증가하여 리뷰어의 작업 부담이 커집니다. 변경된 파일의 수가 10개를 초과하면 해당 기능을 분할할 수 있는지 다시 고려하게 됩니다.\n\n하나의 기능을 모두 한 번에 풀 리퀘스트에 들어가게 하기보다는 작업을 분할하고 개별적으로 릴리스할 수 있는 단위로 풀 리퀘스트를 그룹화하는 것이 리뷰어의 작업 부담을 줄일 수 있습니다. 따라서 작업을 세분화하여 리뷰하기 쉬운 풀 리퀘스트를 생성하는 것이 중요하다고 생각합니다.\n\n## 2. 요약 섹션 강화하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n가장 중요한 것은 풀 리퀘스트 요약 섹션을 개선하는 것이라고 생각해요. 리뷰에 필요한 모든 정보를 요약 섹션에 모아두는 걸 염두에 두고 있어요.\n\n일부 내용은 디자인 제안서 링크와 같은 것들이 명세를 요약한 계획 문서와 중복되지만, 풀 리퀘스트의 요약 섹션에 요약함으로써 전환을 쉽게하고 리뷰 시간을 줄일 수 있다고 생각해요. 구체적으로는 다음 내용을 포함하고 있어요.\n\n- 기능이 필요한 배경\n- 작업 세부 내용\n- 작동 확인된 항목\n- 구현 영향 범위\n- 구현하는 동안 고민했던 포인트\n- 스크린샷 (디자인 변경이 있는 경우)\n- 다양한 링크\n- 작업 티켓 링크\n- 계획 문서 링크\n- 명세를 논의하는 채팅이 있다면 링크 제공\n- Figma와 같은 디자인 아이디어 링크\n\n또한 팀 내에서 템플릿을 만들고 해당 항목에 따라 만드는 것도 중요하다고 생각해요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 3. 리뷰 요청하기 전 자가 검토\n\n리뷰 요청을 하기 전에 자가 검토를 하는 것이 중요합니다. 요약 섹션이 이해하기 쉬운지, 팀의 코딩 규칙을 위반하는 부분이 있는지, 영향 범위 내의 빠뜨린 부분이 있는지 다시 한번 확인할 것입니다.\n\n자가 검토 항목을 준비하고 이전 리뷰에서 받았던 동일한 코멘트를 받지 않도록 주의하고 있습니다. 리뷰를 요청하기 전에 자가 검토를 실시함으로써 구현 중에 보지 못했던 실수를 알 수 있고 더 나은 구현 방법을 발견할 수 있습니다.\n\n자가 검토를 실시함으로써 리뷰를 요청하기 전 리드 타임은 조금 더 길어지지만 그 결과로 리뷰어의 부담이 줄어들고 리뷰해야 할 영역에 집중할 수 있습니다. 우리는 자가 검토를 중요시합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n내 자기평가 항목 중 일부를 소개하고 싶어요. 이것은 어떤 사람들은 너무 자명해서 확인할 필요가 없다고 생각할 수 있는 항목이라고 생각해요. 그러나 두려움이나 긴장 상태일 때는 이런 중요한 항목도 놓치기 쉬우니, 리뷰를 제출하기 전에 이 항목들을 한 번 확인해요.\n\n## 코드 확인\n\n- 라우팅 추가 부분은 ABC 순서로 정리되어 있나요?\n- 스키마 파일에 추가된 열은 응집력을 고려하여 정렬되었나요?\n- 업데이트나 저장과 같은 레코드 저장 메서드는 save!나 update!와 같은 예외를 일으키는 방식으로 사용되었나요?\n- N + 1 문제가 있나요?\n\n## 코드 이외의 확인할 사항\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 파일 변경 사항이 너무 많나요? 10개 이상의 파일이 있는 경우 주의하세요.\n- 풀 리퀘스트를 생성할 때 자신을 할당했나요?\n- 중요한 디자인 변경 사항이 포함된 작업의 경우, 스마트폰 또는 PC 화면뿐만 아니라 태블릿 화면에서도 표시를 확인했나요? (화면 캡처도 함께 첨부해야 합니다)\n\n## 개요\n\n이번에는 '리뷰하기 쉬운 풀 리퀘스트를 제출하는 방법'이라는 제목의 기사를 작성했습니다. 작업의 세분화, 요약 및 자가 검토는 특별한 일이 아니며, 모두 당연한 것으로 여겨질 수 있습니다.\n\n그러나 저는 보통의 일을 철저히 하는 것이 중요하다고 믿습니다. 비즈니스 성장 속도를 높이기 위해, 계속해서 리뷰하기 쉬운 풀 리퀘스트를 작성할 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 스택아데믹\n\n끝까지 읽어 주셔서 감사합니다. 떠나시기 전에:\n\n- 작가를 응원하고 팔로우해 주시면 감사하겠습니다! 👏\n- 저희를 팔로우해 주세요! X | LinkedIn | YouTube | Discord\n- 다른 플랫폼에서도 만나보세요: In Plain English | CoFeed | Venture\n","ogImage":{"url":"/assets/img/2024-06-19-HowICreateEasy-to-ReviewPullRequests_0.png"},"coverImage":"/assets/img/2024-06-19-HowICreateEasy-to-ReviewPullRequests_0.png","tag":["Tech"],"readingTime":4},{"title":"현실 대면이 가상보다 더 나은 이유를 깨달은 방법","description":"","date":"2024-06-19 10:51","slug":"2024-06-19-HowIRealisedIn-PersonisBetterthanVirtual","content":"\n## 나의 시선을 바꾼 사무실 하루\n\n오늘 사무실에서 생산적인 하루를 보냈습니다.\n\n마이크로소프트(Microsoft) 인도는 하이브리드 근무 모델을 따르고 있습니다. 제 팀에서는 저는 새로 온 보드 단계에 있기 때문에 필요할 때 사무실에 오는 유연성이 주어집니다.\n\n제 프로젝트가 변경되어 5월 첫 주에 이 팀에 합류했습니다. 지난 한 달 동안 사무실에는 몇 차례만 갔습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n오늘은 그런 날 중 하나였어요.\n\n온보딩 프로세스를 돕기 위해 친구가 지정되었어요.\n\n일반적으로 배정된 문서와 위키에서 많은 질문이 생기지만, 가끔 사무실을 방문하는 빈도가 낮기 때문에 필요한 질문만 가상으로 할 수밖에 없어요.\n\n개인적인 이유로 사무실을 자주 방문하지 않게 되었어요. 다른 블로그 포스트 주제가 되겠네요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n하지만 오늘 사무실에 있어서 더 많은 질문을 할 기회가 있었어요.\n\n가상 회의는 시간에 제약을 받을 때가 많지만 직접 만나는 회의는 더 유연하고 매력적인 편입니다. 보통 예정된 시간을 넘어가는 경우가 많죠. 왜냐하면 너무 많이 관여하게 되어서 그렇습니다.\n\n우리는 많은 질문과 후속 질문을 하며 좋은 토론을 진행했어요.\n\n또한 몇 가지 기능 제안도 했어요. 제 친구는 몇 가지 구현할 수 없는 이유를 설명해주었지만, 제 아이디어 중 하나를 좋아했고 그것을 우리 매니저에게 논의할 것이라고 말했어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n나가려던 순간, 이 프로젝트에서 처음으로 중요한 업무를 맡게 되었는데, 다음에 할 일을 기대하고 있어요.\n\n직접 만나서 하는 미팅이 생산적일 수 있는 이유를 좋아해요. 그 덕분에 더 많이 배우고, 더 나은 상호작용과 깊은 이해를 할 수 있거든요.\n\n오늘 사무실에서 생산적인 하루를 보냈고, 직접적인 대화가 원격 대화보다 더 잘 통한다는 것을 깨달았어요.\n\n그리고 사무실 삼시세끼 중 커피도 즐겁게 마시고, 점심으로 맛있는 채식 샐러드도 먹었어요!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n기술적인 토론 이외에도, 나는 주변을 돌아다니며 점심 시간에 팀원들과 수다 떨었고, 화장실에서 거울 셀카 몇 장을 찍기도 했어.\n\n이 외에 무엇이 더 필요했을까? 사무실 벤딩 머신에서 간식을 가져왔어. 단지 이 정도로만! 😋\n\n![이미지](/assets/img/2024-06-19-HowIRealisedIn-PersonisBetterthanVirtual_0.png)\n\n완벽한 하루였어!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n당신은 WFO와 WFH 중 어떤 것을 선호하시나요?\n근무 시간 사이의 짧은 휴식 시간에는 무엇을 하시나요?\n\n읽어 주셔서 감사합니다.\n\n만약 이 내용을 좋아하셨다면, 50번 클랩을 눌러 주세요! 😊\n저자의 업데이트를 놓치지 않으려면 여기에서 구독해 주세요.\n","ogImage":{"url":"/assets/img/2024-06-19-HowIRealisedIn-PersonisBetterthanVirtual_0.png"},"coverImage":"/assets/img/2024-06-19-HowIRealisedIn-PersonisBetterthanVirtual_0.png","tag":["Tech"],"readingTime":3},{"title":"데이터 과학이 죽었을까요 반박하기","description":"","date":"2024-06-19 10:49","slug":"2024-06-19-IsDataSciencedeadTheRebuke","content":"\n## EDITOR’S PICK | AI & DATA SCIENCE | DEEP DIVES\n\n![Is Data Science Dead?](/assets/img/2024-06-19-IsDataSciencedeadTheRebuke_0.png)\n\n내 이전 기사 \"데이터 과학은 죽었을까?\"는 상당한 파장을 일으켰어요.\n\n제목은 도발적이었지만, 많은 데이터 과학자들의 머릿속에 이 질문이 떠오르고 있습니다. 그것을 다루는 가치가 있는 주제였습니다. 이 기사는 꽤 많은 댓글과 반응을 유발했죠. 댓글의 성격을 요약해보라면 다음과 같은 주제가 나오겠네요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 데이터 과학은 코딩 이상입니다.\n  대부분의 의견은 데이터 과학이 코드 작성 뿐만 아니라, 실제로 데이터 과학자 작업의 5~10%를 차지한다는 것입니다. 데이비드 플러머가 말한대로 \"데이터 과학자 작업의 나머지 부분은 해결해야 할 문제를 정의하고, 문제를 해결할 적절한 방법론을 찾아내고, 고수준의 솔루션 설계를 만들고 그것을 구성 요소로 분해하며, 데이터를 수집하고 보증하고, 약간의 코딩, 불확실성 추정, 검증 및 검증이 차지한다.”\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n실제로, 데이터 과학은 코딩에 그치지 않습니다. 성공적인 프로젝트를 위해 지식, 디자인, 분석 및 커뮤니케이션 기술이 필요합니다. 누구도 의심하지 않겠지만, AI가 소개된 후에는 명백해졌습니다. AI가 이 수용 프로세스를 가속화시켰는지, 아니면 모두에게 항상 명백했던 것인지 논란이 있을 수 있겠지만, 내 의견은 AI가 Python 코딩이 데이터 과학자가 하는 유일한 일이 아님을 명확히 보여 주었다고 생각합니다.\n\n제 동료 중 한 분이 말하는 대로, 데이터 과학은 이제 \"더 많은 사고, 덜 만지작거림\"(코딩)을 요구합니다. 데이터 과학자들은 실제로 데이터가 다양한 소스를 통해 어떻게 흐르고 변환 작업 및 분석 모듈을 거쳐 데이터를 다시 기록하거나 보고서를 내보내거나 모델을 배포할지에 집중해야 합니다.\n\n# 취업 시장은 어떻게 변화할까요?\n\n그렇다면, 데이터 과학자에게 남아 있는 일은 무엇인가요? 이것이 취업 시장에 영향을 줄까요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nAI가 작업을 빠르게 만들어 줄 것이지만, 결과는 검증되어야 합니다. 잘못된 AI 생성 결과의 제시는 흔히 경험하는 일입니다. 현재 방법론과 라이브러리가 AI 출력물을 이중 확인하기 위해 개발 중에 있습니다. 그러나 현재로서는, 출력물 확인과 결과 해석은 전문 데이터 과학자의 책임이라는 보편적인 느낌이 있습니다.\n\nAI 도입의 결과로 피어날 다른 분야는 데이터 엔지니어링입니다. AI 모델은 많은 양의 데이터를 필요로 합니다 - 조직화되고 구조화되며 깨끗한 데이터입니다. 따라서 데이터 엔지니어링 기술은 이 새로운 직업 시장의 요구를 충족하기 위해 중요도를 높일 것입니다.\n\n세 번째로, 복합적인 데이터 과학 응용에 대한 언급이 있었습니다. 현재 AI는 쉬운 데이터 과학 응용 프로그램을 쉽게 재생산할 수 있지만, 보다 복잡한 솔루션의 모든 단계를 디자인할 수는 없습니다. AI는 향상될 것이며, 복잡성 수준을 좀 더 높일 것이지만, 새로운 복잡한 솔루션을 만들어내는 데 성공할 것이라고는 의심스럽습니다. 복잡한 데이터 과학 응용프로그램은 여전히 전문 데이터 과학자가 필요할 것입니다.\n\n요약하면, 데이터 전문가는 데이터 엔지니어링, 신속한 엔지니어링, 보안, 출력물 확인, 그리고 더 복잡한 응용프로그램 디자인을 위해 필요할 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# AI는 미래를 대비할 수 있을까요?\n\n다른 의견 그룹은 AI와 미래에 관련된 것입니다. 현재 AI는 웹 상의 모든 지식과 다양한 스마트 사용자들이 여러 해 동안 올린 정보에 의존하고 있습니다. 그러나 이러한 지식이 변경된다면, AI가 적응하기까지 얼마나 시간이 걸릴까요? AI는 새로운 문서와 예제가 필요하며, 이러한 새로운 문서와 예제가 발표될 때까지 기다려야 합니다.\n\n현재 이 질문은 다양한 방안으로 다루고 있습니다 (예: RAG의 새로운 고급 품종과 세부 조정 기술은 매일 제안되어 모델에 사용자 지정 지식을 주입하고 있습니다). 그럼에도 불구하고 AI의 윤리적 문제와 AI 답변의 객관성에 대한 미해결된 문제들은 아직 해결되지 않았습니다.\n\n그렇다면, AI는 얼마나 미래를 대비할 수 있을까요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 데이터 과학자들은 미래를 대비할 수 있을까요?\n\n데이터 과학자들에게도 같은 질문이 제기되어야 합니다. 데이터 과학자들이 미래를 대비할 수 있을까요? 대학생들이 데이터 과학 수업에서 배우는 것이 이 새로운 AI 트렌드에서 충분히 활용하고 통제할 수 있을 정도인가요?\n\n일부 응답자는 AI에 프롬프트를 제공하는 것만으로는 데이터 과학의 기초를 배우지 않을 것이라고 한탄했습니다. 그렇다면 그들이 어떻게 데이터 과학 프로세스를 통제할 것을 기대할 수 있을까요?\n\n이는 타당한 질문입니다. 하지만 학생들과 주니어들의 적응 능력을 과소평가하는 것일 수도 있습니다. 학생들과 협업할 때 지금도 개념적인 실수가 많이 있습니다. 그러나 이러한 실수를 바로 잡음으로써 새로운 지식이 생성되고 습득되고 있습니다. 데이터 과학 수업의 기초를 잘 가르침으로써 AI가 존재하는 상황에서도 적절한 교육을 통해 훌륭한 훈련이 가능할 것이라고 확신합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 오픈 소스로 경쟁 우위 확보하기\n\n이번에 발견한 이 노트는 매우 통찰력이 있었어요. 댓글에서는 오픈 소스 전략이 AI 모델의 성공에 중심적인 역할을 한다고 강조했어요.\n\n이전에는 오픈 소스 코드였고, 지금은 오픈 소스 모델이 최신 알고리즘에 접근하고 개발 속도를 높이는 면에서 다른 전략과 비교했을 때 경쟁 우위를 가지고 있는 것 같아요.\n\n# 감사합니다\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n제 글에 생생한 통찰과 지식 있는 댓글, 흥미로운 관찰을 제공해주신 모든 독자분들께 마지막으로 감사의 말씀을 전하고 싶습니다. 주제에 대해 배우고 깊이 생각해보며, 경우에 따라서는 제 생각을 다듬는 기회가 되었습니다.\n\n전체 글 \"데이터 과학이 죽었을까?\"와 그 댓글들은 Medium 저널 \"데이터 과학을 위한 로 코드(Low Code for Data Science)\"에서 확인하실 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-06-19-IsDataSciencedeadTheRebuke_0.png"},"coverImage":"/assets/img/2024-06-19-IsDataSciencedeadTheRebuke_0.png","tag":["Tech"],"readingTime":5},{"title":"의존성의 세계","description":"","date":"2024-06-19 10:47","slug":"2024-06-19-Worldofdependencies","content":"\n<img src=\"/assets/img/2024-06-19-Worldofdependencies_0.png\" />\n\n아직 어리기는 했지만, Y2K 버그를 생생히 기억합니다. 친숙하지 않은 분들을 위해 설명드리자면 (놀랍게도!), Y2K 버그는 컴퓨터 시스템에서 날짜가 저장되는 방식에 연결된 문제였습니다. 이는 '98'을 1998년으로 나타내는 두 자리 연도 표기법의 널리 사용에서 비롯되었습니다.\n\n따라서 2000년이 다가오자, 컴퓨터 시스템이 '00'을 1900년이 아닌 2000년으로 오해할 수 있음을 우려했습니다. 이는 모든 컴퓨터 시스템이 사실상 100년 전으로 되돌아갈 수도 있어, 상당한 혼란을 초래할 수 있었습니다.\n\n그 시대의 개발자들은 이 문제를 해결하는 데 일을 했습니다. 그들은 주로 COBOL과 같은 언어를 사용했는데, 이 언어는 goto 문을 자주 사용했습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n`goto`문은 프로그램이 코드의 다른 위치에있는 레이블로 \"점프\"할 수 있도록했습니다.\n\n여기서 우리는 프로그램이 start_loop 레이블로 \"점프\"하는 것을 볼 수 있습니다.\n\n\"goto\"를 사용하는 것은 종종 많은 의존성을 유발하는 코딩 접근 방식을 촉진합니다:\n\n![의존성 이미지](/assets/img/2024-06-19-Worldofdependencies_1.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리가 볼 수 있듯이, 내일 날짜를 출력하는 간단한 예제조차도 많은 종속성이 있습니다.\n\n날짜와 관련된 코드는 프로그램 전체에 흩어져 있었고 여러 번 중복되었습니다.\n\n버그를 수정하는 것이 비용이 많이 발생하고 어려운 이유 중에는 goto 코드 내에 많은 종속성이 있었기 때문입니다.\n\n개발자들은 많은 위치를 수정해야 했고, 그들이 가한 모든 변경사항이 시스템 전체에 영향을 미쳤습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n최종적으로 이야기는 긍정적으로 끝이 났어요: Y2K 버그가 당시 프로그래머들의 노력으로 성공적으로 방지되었어요. 하지만, 이 모든 일은 훨씬 간단히 처리될 수도 있었어요.\n\n의존성이 중요한 역할을 하는 것은 사실이지만, 그것들을 어떻게 식별할 수 있을까요?\n\n# 의지를 식별하는 것은 반가워요\n\n스파게티 코드를 쓰는 것을 방지하기 위해서, 먼저 의존성이 무엇인지를 이해하는 것이 중요해요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 문서에서는 여러 정의가 있지만 이 기사에서는 다음 정의를 채택할 것입니다: 의존성은 특정 코드 조각이 독립적으로 이해하거나 수정할 수 없을 때 발생합니다. 코드는 다른 코드와 어떤 방식으로든 관련이 있으며, 만약 주어진 코드가 변경된다면 다른 코드도 고려하거나 수정해야 할 수 있습니다.\n\n다음 예제에서 의존성을 식별해 봅시다:\n\n만약 calculateTotal의 인터페이스를 수정하여 매개변수를 추가한다면, 함수를 호출하는 모든 부분을 그에 따라 업데이트해야 합니다.\n\nCartItem 인터페이스를 가격이 아닌 id만 가지도록 변경한다면 calculateTotal 구현을 변경해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이것은 몇 가지 분명한 의존성입니다: 우리가 함수를 만들 때마다, 그 구현과 호출 코드 사이에 의존성을 불문불답(묵시적으로) 만든다.\n\n우리가 다음 예시에서 볼 수 있는 덜 명백한 의존성도 있습니다.\n\n우리는 초콜릿을 만드는 조립 라인을 프로그래밍 중입니다. 공장에서 초콜릿을 만드는 과정은 다음 클래스에 설명된 것처럼 구분된 단계로 이루어져 있습니다:\n\n첫눈에는 각 함수 호출이 독립적으로 작동하는 것처럼 보일 수 있습니다. 그러나 실제로 그렇지 않습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리는 초콜릿 콩을 수확하고 발효시키기 전에 그들을 말릴 수 없습니다.\n\n우리는 수확하고 발효시키기 전에 dryAndRoastCocoaBeans를 호출할 수 없습니다.\n\n우리는 순차 의존성의 예시를 방금 보았어요. 순차 의존성은 프로그램이 올바르게 작동하기 위해 일련의 작업이나 작업의 올바른 실행 순서가 중요한 상황을 말합니다.\n\n또 다른 명백하지 않은 종속성을 발견하기 위해 또 다른 예시를 사용하겠습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n강아지 자선 웹사이트를 위해 매력적인 웹페이지를 만들고 있는 중이에요. 이미 몇 가지 다른 페이지를 만들었어요.\n\n자선에게 모든 페이지에 동일한 로고를 보여주길 원했기 때문에 모든 페이지로 로고를 복사했고, 모든 사람이 만족했어요.\n\n시간이 지난 후, 자선은 한 페이지의 로고를 바꾸기로 결정했어요. 아쉽게도, 로고를 업데이트하기 위해 수작업으로 각 페이지를 작업해야 했어요.\n\n로고를 도입하면 모든 페이지 사이에 종속성이 생겼어요. 즉, 한 페이지에서 로고를 바꾼다면 다른 모든 페이지도 동일하게 업데이트해야 했어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-06-19-Worldofdependencies_2.png\" />\n\n의존성을 식별한 후에는 이를 해결하는 시간입니다 (마침내!).\n\n# 명백하게 만들기\n\n자선사업 예제로 돌아가 봅시다. 간단한 해결책이 있습니다: 의존성을 명시적으로 만드는 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-06-19-Worldofdependencies_3.png\" />\n\n각 페이지는 logoAPI(또는 다른 공유 리소스)를 사용하여 로고를 검색합니다.\n\n이제 페이지들은 서로 격리되어 있어 종속성의 수가 크게 줄어들었습니다.\n\n우리는 다른 로고를 갖는 페이지를 추가할 때 걱정할 필요가 없습니다. 더불어 로고를 업데이트해야 할 경우에는 logoAPI만 수정하면 됩니다. (큰 성공!)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n알기 어려우며 관리하기 어려운 종속성을 간단하고 명확한 것으로 대체했습니다.\n\n좀 더 많은 종속성을 제거합시다!\n\n# 상태 기계\n\n초콜릿 공장 예제로 돌아가서 순차적 종속성을 관찰해봅시다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 코드에서 각 단계는 발생하기 위해서는 모든 이전 단계에 종속되어 있습니다. 그렇지 않으면 작동하지 않을 것입니다.\n\n우리의 의존성 그래프는 다음과 같습니다:\n\n![의존성](/assets/img/2024-06-19-Worldofdependencies_4.png)\n\n순차적 의존성 해결 방법 중 하나는 상태 기계를 구현하는 것입니다. 상태 기계는 서로 다른 상태와 그 상태들을 연결하는 전이로 구성됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n초콜릿 제조 과정에 여러 상태를 정의할 수 있습니다. 하나의 상태만이 언제나 현재 상태가 됩니다.\n\n![image](/assets/img/2024-06-19-Worldofdependencies_5.png)\n\n상태 간 전환은 특정 이벤트나 트리거를 통해서만 가능하며 다른 방법으로는 불가능합니다.\n\n우리는 상태 머신을 구현하고 코드를 그에 맞게 리팩터링할 것입니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리는 현재 상태에서 다음 상태로 전환하는 기능 하나만 노출했습니다.\n\n서로 다른 단계들 간에 의존 관계가 있지만, 상태 머신을 사용하여 내부적으로 관리되므로 외부 세계에 노출되지 않음을 반드시 기억해 주세요.\n\n<img src=\"/assets/img/2024-06-19-Worldofdependencies_6.png\" />\n\n저희 의존성 그래프가 훨씬 나아 보입니다!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다른 중요한 장점은 소비자의 코드를 수정하지 않고 초콜릿 공장 내에서 프로세스를 추가하거나 제거할 수 있다는 것입니다.\n\n상태 머신을 사용하는 것을 망설이지 마세요. 그것들은 환상적이고 사용하기 쉽며 구현하기 쉽습니다 (또는 기존 라이브러리를 사용하세요 :)).\n\n의존성 제거를 위한 또 다른 방법을 살펴보겠습니다.\n\n# 전역 데이터 피하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 코드 스니펫에는 어떤 종속성이 있나요?\n\n![image](/assets/img/2024-06-19-Worldofdependencies_7.png)\n\naddItemToCart 및 removeItemToCart 함수는 명백히 globalShoppingCart 배열에 의존합니다.\n\n처음에는 코드가 원할하게 작동했습니다. 그러나 새로운 기능 요청이 발생했습니다. 고객이 가격 비교를 위해 두 번째 카트를 유지할 수 있도록 하는 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리가 처음에 생각해낸 이 끔찍한 해결책은 이랬어요:\n\n우리의 업데이트된 의존성 그래프는 여기 있어요:\n\n![의존성 그래프](/assets/img/2024-06-19-Worldofdependencies_8.png)\n\n의존성이 두 배로 증가했고, 코드를 유지보수하기가 훨씬 어려워졌어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n두 번째 카트 기능의 석공을 보고, 고객들이 이제는 자신의 요구에 맞는 여러 카트를 만들 수 있는 옵션을 요청하고 있습니다.\n\n기존 코드의 꽉 끼인 성격을 감안할 때, 이 기능을 구현하는 것은 불가능해졌고, 따라서 완전히 다시 작성하기로 결정했습니다.\n\n새로운 의존성:\n\n![의존성 그림](/assets/img/2024-06-19-Worldofdependencies_9.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이러한 함수들은 카트의 특정 인스턴스에 의존하지 않고 인터페이스(배열이라는 사실)에만 의존하기 때문에 종속성의 수가 크게 줄어들었습니다.\n\n마지막으로, 저희 고객들은 원하는 만큼의 카트를 가질 수 있습니다.\n\n이 예시들이 간단해 보일 수 있지만, 더 복잡한 시나리오에서는 전역 또는 가변 데이터에 대한 의존성이 쉽게 간과될 수 있어 코드 유지보수에 상당한 어려움을 초래할 수 있습니다.\n\n결국, 이러한 종속성들은 우리를 코드 유지보수가 어려운 코드를 작성하거나 전면적인 재작성을 해야 하는 상황으로 이끌기도 합니다. 따라서, 가변성보다는 불변성, 그리고 전역 변수 대신 지역 변수를 우선시하는 것이 더 나은 방향입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음은 캣 프로필 UI, 랭킹 알고리즘 및 데이터베이스로 구성된 시니어와 고양이를 연결하기 위한 스타트업의 핵심 구성 요소입니다:\n\n- 캣 프로필 UI: 현재 브라우징하는 시니어 사용자의 매칭 기준에 따라 고양이 프로필을 전시하는 웹페이지입니다.\n- 랭킹 알고리즘: 라이프스타일, 에너지 수준 및 선호도 등을 고려하여 시니어와 고양이 간의 호환성을 평가하는 알고리즘입니다.\n- 데이터베이스: 사용자 데이터(사용자 프로필, 선호도, 이력 관리) 및 고양이 데이터(건강 기록, 행동, 입양 상태 정보 등)를 저장하고 관리합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/assets/img/2024-06-19-Worldofdependencies_10.png)\n\nUI는 API를 통해 데이터베이스에서 현재 시니어 정보와 고양이 프로필을 가져옵니다.\n\nUI는 API를 통해 랭킹 알고리즘에 액세스하고 시니어 데이터를 가져와 고양이 목록을 생성합니다.\n\n데이터베이스에서 고양이 목록을 가져온 후, 랭킹 알고리즘은 정렬하여 UI로 다시 보냅니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n시니어 및 고양이가 함께 시간을 보내며 애플리케이션의 성공으로 새로운 요구사항이 발생했습니다: 모바일 애플리케이션 개발이 필요해졌어요.\n\n안타깝게도 UI가 데이터베이스에 직접 액세스하고 비즈니스 로직을 포함하고 있어, 모바일 앱과 같은 다른 UI 구성 요소를 통합하는 것이 어려웠어요.\n\n결과적으로, 우리는 작은 리팩토링을 하기로 결정했고, 계층적 접근 방식을 사용하기로 했어요.\n\n계층적 접근 방식에서는 애플리케이션을 서로 구분되는 계층으로 나누어 각각이 아래 계층에 대한 추상화 수준을 제공하도록 했어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n전통적인 계층 구조 접근 방식은 애플리케이션을 세 가지 계층으로 분할합니다: 데이터 계층, 비즈니스 로직 계층 및 UI 계층.\n\n각 계층은 특정 관심사에 특화되어 있으며 그 아래의 계층과 직접 통신하는 것만 허용됩니다.\n\n이 접근 방식을 적용하면 의존성은 다음 구조와 유사할 것입니다:\n\n![의존성 구조](/assets/img/2024-06-19-Worldofdependencies_11.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 예시를 통해 AWESOME한 만큼 더 적은 종속성을 가지고 있으면서도 변경에 적응할 수 있는 사례를 확인할 수 있습니다 — 예를 들어, 모바일 UI의 추가와 같은 경우입니다.\n\n![이미지](/assets/img/2024-06-19-Worldofdependencies_12.png)\n\n우리는 동일한 비즈니스 로직을 유지함으로써 모바일 UI를 신속하게 통합할 수 있게 되었습니다.\n\n하지만, 모든 게 환히 빛나고 무지개로 둘러싸인 것은 아닙니다; 계층화된 디자인 패턴을 사용하는 것에는 오버헤드와 복잡성이 증가하는 등 일부 단점이 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n애플리케이션으로 돌아오면, 모바일 앱이 추가되어 모두를 기쁘게 했지만 한 사람을 제외하고는—우리 상사를 말이죠.\n\n우리 상사가 회사의 데이터베이스 비용에 대해 우려를 표명하며 더 비용 효율적인 대안으로 교체하고자 한다는 욕구를 표현했습니다.\n\n불행히도, 우리의 비즈니스 로직은 데이터베이스와 긴밀하게 결합되어 있어서 직접 그 함수들을 호출합니다 :(.\n\n우리는 종속성 주입을 활용하여 이번에는 또 다른 리팩터링을 시도하기로 결정했습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 의존성 주입\n\n의존성 주입에 대해 Stack Overflow의 좋은 인용구로 설명을 시작하겠습니다.\n\n우리 예제에서 비지니스 로직은 5세 아이를 나타내며, 데이터베이스는 직접 호출하는 냉장고와 유사합니다.\n\n![의존성](/assets/img/2024-06-19-Worldofdependencies_13.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n어떻게 하면 엄마와 아빠를 끌어들여서 우리를 도와주고 데이터베이스에서 데이터를 검색할 수 있을까요?\n\n먼저 의존성 주입(DI)의 핵심 개념을 파악해봅시다:\n\n인터페이스를 전기 소켓으로 생각할 수 있습니다.\n\n![이미지](/assets/img/2024-06-19-Worldofdependencies_14.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n셀프설명서에 따르면 소켓에 무언가를 꽂을 때는 우리의 플러그가 소켓의 정확한 형태와 일치해야 합니다. 여기서 소켓은 우리의 인터페이스 역할을 합니다.\n\n또한, 같은 소켓에 많은 다른 가전제품을 연결할 수 있거나 말그대로 많은 구현을 가질 수 있습니다.\n\n![image](/assets/img/2024-06-19-Worldofdependencies_15.png)\n\n이 소켓은 전기 가전제품을 전기 시스템에서 분리합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n전기 가전제품을 직접 벽에 연결해 놓았다면 교체하는 것이 얼마나 어려울지 생각해보세요. 그에 비해 콘센트에 연결되어 있을 때는 얼마나 손쉬운지 생각해보세요.\n\n이전 예시로 돌아와서, 데이터베이스에 직접 의존하는 대신 인터페이스에 의존할 것입니다.\n\n![이미지](/assets/img/2024-06-19-Worldofdependencies_16.png)\n\n이제 인터페이스를 준수하는 여러 가지 구현체를 가질 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-06-19-Worldofdependencies_17.png\" />\n\n다음 단계는 직접적으로 의존하지 않고 구체적인 구현을 얻는 것입니다.\n\n의존성 주입의 이 측면은 실제로 복잡하며, 여러 책들이 이에 대해 쓰여졌습니다.\n\n하지만 간단한 예제로 가장 직관적인 접근 방법을 보여드리겠습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n먼저, createCatsRanking 함수가 awsDataProvider 또는 azureDataProvider와 같은 구체적인 구현에 의존하지 않는다는 것을 알아봅시다.\n\n대신, DataProvider 인터페이스에 의존하며, 함수 매개변수를 통해 주입되므로 DataProvider의 모든 구현과 함께 작동할 수 있다는 것을 의미합니다.\n\n이 접근 방식을 통해 우리는 선택한 임의의 데이터베이스를 원활하게 활용할 수 있으며, 궁극적으로 우리 상사를 기쁘게 할 수 있습니다!\n\n# 요약\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저희는 역사상 가장 비싼 버그 중 하나를 탐구하면서 코드 의존성과의 연관성을 살펴보며 여정을 시작했습니다.\n\n그 다음으로, 우리는 의존성과 결합을 정의하고, 이를 식별하여 발생할 수 있는 문제에 대처하는 방법에 대해 탐구했습니다.\n\n소프트웨어에서 의존성을 관리하기 위한 다양한 전략을 살펴보았는데, 이는 의존성을 명시적으로 만들기, 상태 기계 활용, 전역 데이터 피하기, 계층 구조화, 의존성 주입 등이 있었습니다.\n\n이 목록이 완벽하진 않지만, 이 글에서 가장 중요한 교훈은 항상 의존성을 고려해야 한다는 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n성공적인 소프트웨어는 변화에 적응할 수 있어야 한다는 것을 기억해야 합니다. 계속해서 새로운 기능을 추가하고 기존 기능을 확장해야 하므로, 종속성을 고려하고 느슨하게 결합된 코드를 작성하는 것이 이 목표를 달성하는 데 큰 도움이 될 수 있습니다.\n\n코드를 분리해야 하는 부분과 그렇게 하지 말아야 하는 부분을 고려해야 합니다. 너무 많은 추상화와 확장 지점을 추가하면 복잡한 코드가 생성되어 관리하기 어려운 악몽이 될 수 있습니다.\n\n결국, 중요한 것은 적절한 균형을 찾고 언제 어떤 것이 다른 것에 의존해야 하는지 결정하는 것입니다.\n\n즐거운 코딩하세요!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 참고문헌\n","ogImage":{"url":"/assets/img/2024-06-19-Worldofdependencies_0.png"},"coverImage":"/assets/img/2024-06-19-Worldofdependencies_0.png","tag":["Tech"],"readingTime":18}],"page":"48","totalPageCount":119,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":2},"__N_SSG":true}