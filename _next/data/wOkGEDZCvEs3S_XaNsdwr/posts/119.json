{"pageProps":{"posts":[{"title":" 2024년에는 Captcha를 버리는 게 좋을 것 같아요 ","description":"","date":"2024-05-17 17:53","slug":"2024-05-17-ItsAboutTimeToDitchCaptchaIn2024","content":"\n<img src=\"/assets/img/2024-05-17-ItsAboutTimeToDitchCaptchaIn2024_0.png\" />\n\n## 매년 77,600채의 주택을 건설할 수 있을 것입니다. 하지만 우리가 캡차를 푸는 데 시간을 낭비하고 있습니다. 여러 해 동안 캡차는 계속해서 우리의 시간과 돈을 낭비하고 있습니다. 2024년은 캡차를 완전히 없애는 좋은 해가 될 것입니다.\n\n# 캡차와 프린터는 같습니다\n\n요 며칠 동안 약간 연기한 온라인 작업을 처리해야 했습니다. 그 중 하나는 더 이상 필요하지 않은 뉴스레터 구독 취소였습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그 날 나의 마지막 일이었고 5분 안에 끝내야 했다. 이메일에서 제공된 링크를 통해 회사 웹사이트로 이동했다.\n\n구독 취소를 위해 계정에 로그인하고 이메일 구독을 비활성화하기 위해 체크 상자를 클릭해야 했다. 5분 안에 완료할 수있는 완벽한 작업이었다.\n\n로그인 페이지에서 난 로봇이 아닌 것을 확인하기 위한 captcha를 마주했다. 서둘러야 했기 때문에 나는 보행로가 보이는 모든 사진을 클릭했다.\n\n불행하게도 하나를 놓쳤다. 그래서 내가 치과 방문을 하기 전에 그 마지막 작업을 끝내야 했기 때문에 사진을 빠르게 클릭하기 시작했다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n놀랍게도 더 많은 사진이 제시되었고, 한번 클릭한 후에도 끊임없이 더 나오더라구요. 나는 몇 분 동안 계속 보다가 결국 그날은 그만두기로 했습니다.\n\n거의 프린터처럼, 캡차는 당신이 서둘고 있는 걸 느낀답니다.\n\n# 캡차가 탄생한 이유\n\n컴퓨터 과학에서 나의 주요 연구 분야는 인간 중심의 계산과 소셜 미디어였어요. 오늘날 두 분야가 구현된 방식은 저를 실망스럽게 만들죠.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n캡차의 시작은 흥미로웠어요. 위키피디아에 따르면:\n\n알고리즘이 무언가를 처리할 수 없을 때 우리는 그 작업을 사람들에게 분배하는 것을 의미합니다. HBC는 처리되어야 하는 방대한 양의 처리를 위한 꿈의 도래였어요.\n\n![이미지](/assets/img/2024-05-17-ItsAboutTimeToDitchCaptchaIn2024_1.png)\n\n캡차가 탄생한 후 HBC의 실용적 구현으로 바로 나왔어요. 한편으로, 사람들은 사진에 있는 항목을 분류하여 동일한 작업을 수행하는 AI를 교육하는 데 도움이 되었어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n반면, 캡차는 일정 수준의 안전성을 제공했습니다. 당시에는 봇이 캡차를 해결할 수 없을 것으로 예상되었기 때문입니다.\n\n그래서 1997년에 에란 레셰프, 길리 라아난, 에일론 솔라가 특허를 획득한 캡차는 모두에게 유익해 보였습니다. 이 아이디어는 훌륭했고, 원 저자들은 캡차를 발명함으로써 좋은 일을 했습니다.\n\n그러나 14년 뒤에 우리는 캡차가 다른 방향으로 나아간 것을 볼 수 있습니다. 어디로 향하는지 살펴보겠습니다!\n\n# 매년 77,600가구가 캡차 때문에 주택을 지을 수 없게 됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n2021년에는 인류가 매일 총 500년을 CAPTCHA 해결에 낭비했습니다. 이를 이해하려면 매년 182,000년, 320억 달러 (해당 시간에 대한 미국 평균 수입 기준)을 낭비한 것입니다.\n\n그 금액으로 미국에 77,600 가구를 위한 주택을 지을 수 있었을 것입니다... 매년 마다.\n\n![이미지](/assets/img/2024-05-17-ItsAboutTimeToDitchCaptchaIn2024_2.png)\n\n이 충격적인 숫자는 우리가 CAPTCHA로 인해 얼마나 많은 시간과 돈을 잃는지를 보여줍니다. 이러한 숫자들은 가정과 평균에 따라 작아지거나 커질 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리는 인간으로서 캡차에 상당한 시간을 낭비하는 사실이 있습니다. 한 사람당 몇 초에서 5분 정도밖에 안 걸리지만, 시간이 누적됩니다.\n\n# 캡차는 이제 더 이상 인간과 봇을 구별하지 못합니다\n\n게다가, 우리는 이로 인해 무언가를 얻는 것도 아닙니다. 2021년, 3년 전에 Nikolay Pankov가 이 문장으로 캡차에 대해 요약한 기사를 썼습니다:\n\n캡차는 고의적으로 온라인 자원을 봇과 나쁜 행위자로부터 보호해야 합니다. 그 목표는 자원 사용을 제한하는 것입니다. 만약 봇이 페이지를 방문하면, 회사가 지불해야 하는 소중한 전송을 사용하게 됩니다. 우리는 봇이 웹사이트를 방문하는 것을 원하지 않습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n공동으로 스타벅스에서 커피를 사지 않은 돈을 모아온 모든 저축을 산다는 DDOS 공격도 말할 것도 없죠.\n\n![image](/assets/img/2024-05-17-ItsAboutTimeToDitchCaptchaIn2024_3.png)\n\n그렇지만 여러 해 동안 알고 있듯이, CAPTCHA는 그 퍼즐을 해결하지 못합니다. AI나 인간 지원으로 쉽게 해결할 수 있는데, 또한 다른 사람에게 CAPTCHA 퍼즐 해결을 아웃소싱한 봇들도 있었습니다.\n\n어떤 봇은 서비스에 링크가 포함된 댓글을 게시하려고 했지만, 웹사이트가 그것을 CAPTCHA로 해결하라고 요청했습니다. 그래서 봇은 해커가 운영하는 약간 유용한 앱 또는 웹사이트의 방문자에게 동일한 퍼즐을 제시했습니다. 그렇게 해커들은 HBC를 해결하는 솔루션을 빠르게 구현하기로 결정했습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n소캡차는 아무런 보호를 제공하지 않아요. 방문자가 사람인지 봇인지 구별할 수 없는 경우가 매우 오래 지속됩니다.\n\n# 소캡차가 사람들을 차별합니다\n\n소캡차가 사람들을 차별한다는 보고가 많습니다. 예를 들어 시각장애인은 오디오 캡차를 해결하는 데 어려움을 겪습니다(오디오 캡차가 제공된다면). 이것은 실제로 새로운 현상이 아닙니다. 우리는 적어도 2019년부터 지금까지 여러 해 동안 알고 있습니다.\n\n또한 국적, 인종, 위치 등에 따라 소캡차가 사람들을 차별할 수 있는 여러 방법이 있습니다. 이는 잘 알려지지 않은 사실입니다. 예를 들어 택시를 지목해야 하는 경우, 다른 나라의 사진이 제시된다면 어려움을 겪을 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이미지 태그를 Markdown 형식으로 변경합니다.\n\n![이미지](/assets/img/2024-05-17-ItsAboutTimeToDitchCaptchaIn2024_4.png)\n\n테렌스 에덴(Terence Eden)은 2017년 다음과 같이 요약했습니다:\n\n모든 것을 고려해도, 왜 우리는 여전히 캡차를 해결해야 하는 걸까요?\n\n# 기업들이 캡차를 단지 자신들의 이익을 위해 사용합니다\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n모든 것은 돈으로 연결돼 있어요. Captcha는 사람 중심의 계산을 하고 실제 문제(인간과 로봇을 구분하는 것)를 해결하기 위해 고안되었어요.\n\n핵심 기능에서 실패하더라도, 여전히 사람 중심의 계산에 사용되고 있어요.\n\nAI 모델은 어떤 보도가 어떻게 생겼는지 모르죠. 기업은 AI에 사진과 설명을 공급해야 해요. 많은 양을 처리하면...\n\n수백만 번의 반복을 통해 AI는 최종적으로 보도와 고양이를 구분할 수 있게 되는 거예요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이를 달성하기 위해 AI 모델을 구축하는 기업들은 이러한 AI 모델을 훈련시키기 위해 사람들로부터 대규모의 분류 데이터베이스를 수집해야 합니다.\n\n요약하면:\n\n- captcha는 문제를 해결하지 못함 (인간과 봇을 구별할 수 없음)\n- captcha의 인류에 미치는 비용은 엄청나다 (매년 77,600채의 주택)\n- captcha 솔루션을 제공하는 기업만 혜택을 받음\n\n그래서 2024년에는 captcha를 전혀 사용해야 할지에 대한 의문이 많이 제기됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n오직 1%의 사람들만 이렇게 긴 글을 끝까지 읽습니다. 축하해요! 여러분과 기술에 대해 이야기를 나눌 수 있어서 기쁩니다. 여러분은 제가 가장 좋아하는 사람들이에요. 구독해 주시면 연락할 수 있기를 바래요!\n\n그런데, 대단하시네요! 기술에 정말 관심이 많으시군요! 'Summon The JSON'이라는 카드 게임을 디자인했어요. 우연히도 맞췄네요! 지금 주문할 수 있습니다!\n\n기술을 좋아하시나요? 소셜 미디어에서 클랩, 구독, 좋아요와 공유해 주세요!\n\nTom Smykowski를 따르는 14,000명의 개발자 중 하나가 되어보세요! 매월 $5에 모든 Medium 기사에 액세스할 수 있고, Tom은 기술에 대해 더 많이 작성할 수 있습니다! 지금 멤버가 되세요!\n","ogImage":{"url":"/assets/img/2024-05-17-ItsAboutTimeToDitchCaptchaIn2024_0.png"},"coverImage":"/assets/img/2024-05-17-ItsAboutTimeToDitchCaptchaIn2024_0.png","tag":["Tech"],"readingTime":8},{"title":"과다 고용이 모든 사람들을 위한 시장을 망치고 있다","description":"","date":"2024-05-17 17:51","slug":"2024-05-17-OverEmploymentIsRuiningtheMarketforEveryone","content":"\n![2024-05-17-OverEmploymentIsRuiningtheMarketforEveryone_0](/assets/img/2024-05-17-OverEmploymentIsRuiningtheMarketforEveryone_0.png)\n\n팬데믹이 시작되었을 때 대다수가 원격으로 일해야 했을 때, 두 가지를 깨달았어요:\n\n- 내가 많은 여유 시간을 가지고 있다는 것을 깨달았어요 (내 직장은 그리 높은 수요가 없는 것 같았어요).\n- 그리고 한 직장으로는 무슨 일이 생길지 모른다는 것을 깨달았어요 (심지어 안정적인 기업도 재정적 문제가 있었어요).\n\n지루했고 미래에 대해 불안했으며 온라인으로 돈을 벌기 위한 새로운 방법을 시도해봐도 완전히 생산적이라고 느끼지 않았어요. 그래서 저는 이전 직장은 유지하면서 다른 정규직을 찾기로 결심했어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n몇 달 후에 현지 은행에서 새 팀을 구축하기 위한 로봇을 만들기 시작했다는 연락을 받았어요. 회사가 새로운 팀을 만들면 진정한 책임이 없다고 하는 게 큰 장점이었어요.\n\n그 덕분에 한동안 문제 없이 두 직장을 할 수 있었어요.\n\n그런데 두 번째 직장이 점차 더 많은 책임을 요구하기 시작하자, 처음 직장에 소홀해지기 시작했어요. 그래서 결국, 나름의 이유로 처음의 직장을 그만두고 더 잘 주는 새 직장에 집중하기로 결정했어요.\n\n나에게 초과 근무는 새로운 경험을 살아보기 위한 몇 달의 기간이었어요. 이덕분에 도덕적으로 옳지 않았고(그건 알고 있어요), 마지막으로는 그냥 제게는 아니었다는 생각이 드네요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n하지만 많은 사람들에게는 이게 새로운 일상이 되어가고 있어요.\n\n그들은 두 개가 아니라 세 개, 네 개, 막상 여섯 개의 일을 동시에 하고 있습니다. 자신의 능력으로 수많은 돈을 벌어들이며, 회사들을 속이고는 하지만 각 회사에서 4~6시간씩 일할만한 충분한 능력이 있다고 생각합니다.\n\n하지만 무엇보다도, 이러한 이기주의로 인해 시장을 망치고 있는 것이죠.\n\n# 왜 과다 고용이 모두를 위해 시장을 망치고 있는지에 대한 이유.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n전 세계에는 100,000명의 프로그래머가 있고 150,000개의 취업 기회가 있다면, 이 직업에서 승진할 수 있는 새로운 방법이 항상 있을 것입니다.\n\n과잉 고용이 인기를 얻기 전에 많은 회사들이 소프트웨어 엔지니어에게 유혹적인 급여와 보상을 제공했습니다. 연봉이 40만 달러, 무제한 휴가, 그리고 무수히 많은 무료 기술들이 제공되었습니다.\n\n그러나 이러한 급여와 보상이 점점 줄어들고 있는 것 같습니다.\n\n지금은 8년 이상 경력을 가진 시니어 풀 스택 개발자에게 월 4,500달러 (연 54,000달러), 부서 전체를 담당하는 팀 리더에게는 7,000달러를 요구하는 회사들도 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아무도 모르는 기술 (.NET Core 또는 React/Angular 중 하나)만 알고 시장에 처음 발을 디딘 사람에 대한 초기 급여는 과거에는 좀 낮은 수준이었습니다.\n\n팀 리더들은 연봉으로 적어도 $120,000를 받았습니다.\n\n하지만 요즘 회사들은 사람들이 필요로 한다는 사실을 알고 있기 때문에, 그들은 아무런 망설임 없이 유혹적인 제안을 합니다.\n\n![image](/assets/img/2024-05-17-OverEmploymentIsRuiningtheMarketforEveryone_1.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이런 일이 발생하는 이유는 많은 시니어 개발자들이 월 수입이 $7000에서 $15,000인 중간급 업무를 찾기로 결정하여 많이 일하지 않아도 일을 할 수 있다고 판단했기 때문입니다. 비록 수입이 적을지라도 추가 수입이기 때문입니다.\n\n따라서 이제 모집업체와 기업들은 반값에 충분히 좋은 인재를 구할 수 있다는 것을 알게 되었습니다.\n\n중간급 직급의 사람들이 첫 직장을 가지면서 빛을 발휘할 수 있도록 주니어 포지션을 차지하기 시작했습니다. 시니어들은 주요 포지션을 유지하면서 빠르게 작업할 수 있는 중간급 포지션을 차지하기 시작했습니다. 일자리가 없는 사람들은 더 이상 제안이 없기 때문에 시니어 포지션을 저렴한 가격에 차지하기 시작했습니다.\n\n지금은 더 이상 주니어 개발자를 위한 포지션이 없습니다. 현재 진입하는 사람들은 뛰어난 실력을 증명하지 않는 한 일자리를 얻기 어려울 것입니다. 왜냐하면 사람들이 나타나는 것을 차지하고 있기 때문이죠.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n150,000 개의 제안 중 60,000 명에 의해 모두 차지되어 40,000 명은 일자리가 없어서 빌을 갚기 위해 어떤 급여라도 받아들이고 있습니다.\n\n최악인 점은 두 개의 직장을 가진 대부분의 사람들이 사실은 두 번째 직장이 필요하지 않다는 것입니다.\n\n# 안타까운 현실은 대부분의 사람들이 욕심 때문에 두 개의 직장을 가지고 있다는 점이죠, 필요 때문은 아닙니다.\n\n안타까운 사실은 이미 좋은 급여를 받는 기술직 종사자들이 가장 많이 과로한 상태라는 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n두 개의 직장을 얻기 전에 수입이 훌륭했어요. 모든 빌을 지불하고 매달 월급의 적어도 40%를 저축할 수 있었죠. 저는 여분의 시간이 있었고 더 많은 돈을 벌 수 있는 쉬운 방법이기 때문에 두 개의 일을 가지기로 결정했어요.\n\n두 개의 직장과 사이드 허슬로 인해 엄마에게 거의 현금으로 집을 사줄 수 있었어요. 또한 포르쉐를 샀고 순자산을 극대화했어요.\n\n난 가족을 부양할 필요도, 상환할 대출도 없었고 큰 질병에 대비할 필요도 없었어요; 난 그저 탐욕스러웠을 뿐이었어요.\n\n내가 알고 있는 주위 사람들 중 두 개의 직장을 한 사람들은 비슷한 이유에서 그랬어요. 그들은 두 번째 직장을 얻었고 부유한 수입에 익숙해졌기 때문이었어요. 듣은 몇 가지 이유는:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- \"리쿠루터가 연락을 주었고, 경험을 얻기 위해서 '예'라고 했어요.\"\n- \"직장 안정성을 원해요\" (현재 직장에서 문제가 없어요).\n- \"대출없이 저택을 짓고 싶어요\" (이 말을 한 사람은 다섯 개의 일을 하며, 현금으로 집을 짓았어요).\n- \"저축을 희생하지 않고도 사치를 누리고 싶어요.\"\n- \"일찍 은퇴하고 싶어요.\"\n\n이 모두가 실제로 필요한 게 없어요.\n\n그들은 그저 고액 연봉으로 최고의 삶을 살고 있어요.\n\n하지만 다른 직업은 누군가의 가족을 먹여살릴 전업직이 될 수도 있어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n시장이 정말 힘든 이유는 일자리 제공보다 일할 필요가 있는 개발자가 더 많기 때문입니다.\n\n# 가장 최악인 점은 이 문제를 해결하기 거의 불가능하다는 것입니다.\n\n문제를 해결하는 쉬운 방법이 없다는 것이 문제입니다.\n\n만약 회사가 원격 근무자의 현재 성과에 만족하고 있다면, 그들이 다른 일자리를 가지고 있다고 의심할 방법이 없습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n많은 기업들이 사무실로 복귀하기로 결정했습니다. 한 사람이 하나의 직장만 가지고 있는지 확인할 수 있기 때문입니다. 그러나 이는 누구에게나 불가능합니다. 특히 실제 장소를 가지고 있는 비용 때문에 그렇습니다.\n\n다른 기업들은 직원이 활발히 일하고 있는지 확인하기 위해 카메라를 켠 채로 끊임없는 회의를 진행합니다. 그러나 이는 직원들이 지치게 만듭니다.\n\n우리 나라에는 의무적인 실업 보험이 있습니다. 만약 어떤 사람이 해고당한다면, 회사는 해당 사람이 그곳에서 근무한 기간에 따라 최대 6개월 동안의 급여를 지급해야 합니다. 이를 통해 사람들이 다른 직장을 얻을 때까지 충분한 돈을 확보할 수 있습니다.\n\n하지만 이는 사람들이 다른 선택지를 찾는 것을 막지는 못했습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n모든 것은 결국 각 개인의 도덕성과 몇 년 동안 이런 방식으로 일한 후에 얼마나 지친 것인지에 달려 있을 것입니다.\n\n개인적으로는 그렇게 다시는 하지 않을 것입니다. 둘 다 경험해 봤기 때문입니다. 두 개의 일을 가진 사람이었을 때와 두 번째 일을 찾아다닐 때 운이 좋지 못했던 일없는 사람이었을 때, 이 두 경험이 모두 나에게 좋지 않았습니다.\n\n하지만 이미 늦었습니다. 그 행동으로 인해 우리는 시장을 망쳤습니다. 이제는 한 가지 직장과 기술로 7,000달러를 벌기 위해 두 개의 일이 필요하며, 한 때 한 개의 일과 기술로 그 급여를 받았던 시절을 떠올리면 우리는 불만을 터뜨릴 수 없습니다. 충분히 요구할 수 없습니다. 나타나는 대로 받아들여야 합니다.\n\n이 모든 일이 벌어진 이유는 초과 수요 때문이라기보다는 더 많은 노동자가 있는 것 때문은 아닙니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n지금은 일자리 시장이 매우 어렵기 때문에 두 개 이상의 직장을 가지고 있는 사람들이 많기 때문입니다.\n\n세네이어 개발자들은 세 명의 일을 하고 있어, 중간 단계에 있던 사람들은 이전처럼 문제를 해결할 수 없게 되었습니다. 우리는 이제 주니어 직책이 더 이상 없어서, 시장에 진입하고 싶은 사람들은 충분히 좋다는 것을 보여주거나 사무실에 가기를 원하는 것을 보여줘야 합니다.\n\n우리는 현실을 받아들여야 합니다. 더 이상 요구할 수 있는 입장에 있지 않습니다. 왜냐하면 두 개의 일을 가지고 있는 사람들은 돈을 계속 벌 수 있도록 어떤 연봉이든 받아들입니다.\n\n저는 두 개의 일을 하는 것을 후회합니다. 더 많은 돈을 버는 대신에 정신 건강과 휴식을 희생한 것 같아요. 결국 두 개의 일 중 하나에서 성과가 나빠졌습니다. 더 열심히 공부했다면, 두 곳에서 일하지 않고 더 나은 위치에 있을 수 있지 않았을까 싶어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n하지만 이미 너무 늦었어요. 두 개의 일을 가지는 것이 너무 보편화되어서 많은 사람들의 성장 기회를 망쳤어요.\n\n과다 고용이 시장을 망친 거예요.\n\n제 글을 놓치지 마세요; 제 이메일 목록에 가입해주세요.\n","ogImage":{"url":"/assets/img/2024-05-17-OverEmploymentIsRuiningtheMarketforEveryone_0.png"},"coverImage":"/assets/img/2024-05-17-OverEmploymentIsRuiningtheMarketforEveryone_0.png","tag":["Tech"],"readingTime":9},{"title":"자신의 디바이스와 함께 Gradle 관리 디바이스를 사용하는 방법","description":"","date":"2024-05-17 17:48","slug":"2024-05-17-HowtouseGradleManagedDeviceswithyourowndevices","content":"\n<img src=\"/assets/img/2024-05-17-HowtouseGradleManagedDeviceswithyourowndevices_0.png\" />\n\n요즘 Google은 안드로이드 Gradle 플러그인을 위한 새로운 기능, Firebase Test Lab for Gradle Managed Devices를 소개했어요. 이 기능은 Gradle Managed Devices API를 사용하여 테스트를 Gradle이 실행되는 동일한 기계가 아니라 Firebase Test Lab(유료 기능) 내에서 원격 가상 또는 물리 장치에서 시작합니다. 이 기사에서는 해당 기능과 Firebase Test Lab과 같은 방식으로 테스트를 원격으로 시작하기 위해 자체 디바이스 팜을 사용하는 방법, 그리고 여러 장치 간에 실행을 병렬화하는 방법에 대해 다룰 거예요.\n\n# Gradle Managed Devices\n\n처음에는 Gradle Managed Devices가 안드로이드 Gradle 플러그인에게 에뮬레이터의 생성, 시작 및 종료 과정을 위임하는 목적으로 출시되었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nandroid {\ntestOptions {\nmanagedDevices {\ndevices {\nregister(\"pixel2api30\", com.android.build.api.dsl.ManagedVirtualDevice) {\ndevice = \"Pixel 2\"\napiLevel = 30\nsystemImageSource = \"aosp\"\n}\n}\n}\n}\n}\n\n위의 구성을 사용하면 pixel2api30Check 작업을 통해 UI 테스트를 실행할 수 있으며, 기기를 연결하거나 에뮬레이터를 실행할 필요가 없습니다. 이 테스트 실행 환경은 다양한 기계에서 동일합니다.\n\n<img src=\"/assets/img/2024-05-17-HowtouseGradleManagedDeviceswithyourowndevices_1.png\" />\n\n# Firebase Test Lab\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n파이어베이스 테스트 랩을 통한 Gradle Managed Devices는 Android Dev Summit 2022에서 최근 소개된 새로운 기능입니다. 이제 Gradle에서 바로 테스트 랩에서 UI 테스트를 실행할 수 있어서 명령줄 도구나 웹 UI를 사용할 필요가 없어졌어요.\n\n```js\nplugins {\n    id 'com.google.firebase.testlab'\n}\n\nandroid {\n    testOptions {\n        managedDevices {\n            devices {\n                register(\"pixel2api30\", com.google.firebase.testlab.gradle.ManagedDevice) {\n                    device = \"Pixel2\"\n                    apiLevel = 30\n                }\n            }\n        }\n    }\n}\n```\n\n<img src=\"/assets/img/2024-05-17-HowtouseGradleManagedDeviceswithyourowndevices_2.png\" />\n\n우리 자신의 장치로도 같은 작업을 할 수 있을까요? 함께 알아봐요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 커스텀 디바이스 구현\n\n여러분이 아시다시피, 저희는 com.android.build.api.dsl.ManagedVirtualDevice 또는 com.google.firebase.testlab.gradle.ManagedDevice를 사용하고 있는데, 이 둘 모두 com.android.build.api.dsl.Device 인터페이스를 구현하고 있습니다. 그래서 우리가 직접 커스텀한 디바이스를 구현하려고 하면 어떻게 될까요?\n\n필요한 Gradle 코드, 플러그인 등을 모두 추가할 새 모듈을 만들어봅시다. buildSrc 폴더를 사용하거나 새로운 included build를 생성하여 할 수 있습니다. 여기서는 새로운 Gradle 플러그인을 생성하는 과정에 대해서는 다루지 않겠지만, 관련 정보는 공식 문서나 저의 다른 글에서 찾아볼 수 있습니다.\n\n새로 생성한 Gradle 플러그인 모듈에서 MyDevice를 선언하고 해당 디바이스를 애플리케이션 모듈의 build.gradle에서 사용해보세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n인터페이스 MyDevice : Device\n```\n\n```js\nandroid {\n    testOptions {\n        managedDevices {\n            devices {\n                register(\"myDevice\", MyDevice) {}\n            }\n        }\n    }\n}\n```\n\n프로젝트를 동기화하려고 하면 다음 예외가 발생합니다: 이 컨테이너에서 MyDevice를 생성할 수 없습니다. 이것은 android.testOptions.managedDevices.devices 컨테이너가 MyDevice를 인스턴스화할 방법을 모르기 때문입니다. 왜냐하면 MyDevice가 인터페이스이기 때문입니다.\n\n그렇다면 Android Gradle 플러그인은 이 문제를 어떻게 관리할까요? com.android.build.api.dsl.ManagedVirtualDevice를 검색하면 다음 코드를 찾을 수 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\ndslServices.polymorphicDomainObjectContainer(Device::class.java).apply {\n    registerBinding(\n        com.android.build.api.dsl.ManagedVirtualDevice::class.java,\n        com.android.build.gradle.internal.dsl.ManagedVirtualDevice::class.java\n    )\n}\n```\n\nregisterBinding을 사용하면 플러그인은 컨테이너에 com.android.build.api.dsl.ManagedVirtualDevice 유형의 어떤 것을 추가하려고 시도하는 API 클라이언트가 있을 때 내부 클래스 com.android.build.gradle.internal.dsl.ManagedVirtualDevice를 사용하도록 지시하는 것입니다. 컨테이너는 ManagedVirtualDevice 클래스의 인스턴스를 생성하고 해당 인스턴스를 register 메소드의 람다에 제공할 것입니다.\n\n동일한 작업을 하기 위해 MyDevice를 구현하는 추상 클래스와 사용자 지정 Gradle 플러그인이 필요하며 해당 플러그인을 프로젝트에 적용해야 합니다.\n\n```js\ninternal abstract class MyDeviceImpl(\n    private val name: String,\n): MyDevice {\n    override fun getName(): String = name\n}\n\nclass MyDevicePlugin : Plugin<Project> {\n    override fun apply(target: Project) {\n        target.plugins.withType(AndroidBasePlugin::class.java) {\n            target.extensions.configure(CommonExtension::class.java) {\n                it.testOptions.managedDevices.devices.registerBinding(\n                    MyDevice::class.java,\n                    MyDeviceImpl::class.java,\n                )\n            }\n        }\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nplugins {\n    id `my-device-plugin`\n}\n\nandroid {\n    testOptions {\n        managedDevices {\n            devices {\n                register(\"myDevice\", MyDevice) {}\n            }\n        }\n    }\n}\n```\n\n그래서 다시 동기화를 시도하여 다른 예외를 확인해 봅시다:\n\n```js\nCaused by: java.lang.IllegalStateException: 지원되지 않는 관리형 장치 유형:\n class com.bumble.devicefarm.plugin.device.farm.DeviceFarmImpl_Decorated\n at com.android.build.gradle.internal.TaskManager.createTestDevicesForVariant(TaskManager.kt:1905)\n```\n\n스택 추적을 따라가보면, gradle.properties에 android.experimental.testOptions.managedDevices.customDevice=true를 추가해야 하며 MyDevice는 ManagedDeviceTestRunnerFactory를 구현해야 한다는 것을 알 수 있습니다. 따라서 더 자세히 조사해 보겠습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\n내부 추상 클래스 MyDeviceImpl(\n  private val name: String\n) : MyDevice, ManagedDeviceTestRunnerFactory {\n\n  override fun getName(): String = name\n\n  override fun createTestRunner(\n    project: Project,\n    workerExecutor: WorkerExecutor,\n    useOrchestrator: Boolean,\n    enableEmulatorDisplay: Boolean\n  ): ManagedDeviceTestRunner =\n    MyDeviceTestRunner()\n\n}\n```\n\n팩토리 자체에는 중요한 값이 없습니다. 반환되는 클래스 ManagedDeviceTestRunner이 더 흥미로운 부분입니다.\n\n```kotlin\ninterface ManagedDeviceTestRunner {\n\n  // 모든 테스트 케이스가 통과되면 true를 반환합니다. 그렇지 않으면 false를 반환합니다.\n  fun runTests(\n    managedDevice: Device,\n    runId: String,\n    outputDirectory: File,\n    coverageOutputDirectory: File,\n    additionalTestOutputDir: File?,\n    projectPath: String,\n    variantName: String,\n    testData: StaticTestData,\n    additionalInstallOptions: List<String>,\n    helperApks: Set<File>,\n    logger: Logger\n  ): Boolean\n\n}\n```\n\nrunTests 메서드는 각 Gradle 모듈에 대해 호출되며, 테스트를 실행하는 데 사용할 수 있는 많은 데이터가 포함되어 있습니다. 여기서 testData를 사용하여 APK를 가져와 설치하고, 계장을 통해 테스트를 실행할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# Instrumentation\n\n안녕하세요! 안드로이드 스튜디오에서 테스트를 실행하는 방법은 대부분 우리가 잘 알고 있습니다. 테스트 이름 근처의 실행 버튼을 클릭하거나 Gradle을 통해 connectedAndroidTest를 실행하는 방법이 있죠. 이제 이러한 도구 없이도 어떻게 테스트를 실행할 수 있는지 알아봅시다.\n\n이 두 가지 접근 방법은 디바이스에서 am instrument 명령을 사용합니다. 이 명령은 ADB를 통해 실행됩니다. 더 자세한 내용은 공식 문서를 참고해보세요.\n\n```js\nadb shell am instrument -w <test_package_name>/<runner_class>\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n테스트를 실행하려면 runTests 메서드에서 동일한 작업을 해야 합니다. ADB 작업을 수행하기 위해 mobile.dev의 dadb 라이브러리를 사용할 것입니다. 이 라이브러리를 사용하면 ADB 실행 파일을 이용하지 않고 ADB 프로토콜을 통해 디바이스에 직접 연결할 수 있습니다. 이렇게 하면 작업 속도가 향상되며 편리하게 사용할 수 있습니다. 관련 블로그 포스트에서 이에 대해 자세히 읽을 수 있습니다.\n\nrunTests 메서드 내에서 Dadb를 사용하여 로컬 에뮬레이터에 연결하고 APK를 설치하고 테스트를 실행해보겠습니다.\n\n```kotlin\noverride fun runTests(...): Boolean {\n    // 로컬 에뮬레이터에 연결\n    Dadb.create(\"localhost\", 5555).use { dadb ->\n        // 애플리케이션 APK 설치\n        val apks = testData.testedApkFinder.invoke(DadbDeviceConfigProvider(dadb))\n        // 라이브러리 모듈인 경우 비워둡니다.\n        if (apks.isNotEmpty()) {\n            // 앱 번들을 지원하기 위해 여러 개의 APK 설치 사용\n            dadb.installMultiple(apks)\n        }\n        // 계기 APK 설치\n        dadb.install(testData.testApk)\n\n        // 테스트 실행\n        dadb.shell(\"am instrument -w ${testData.applicationId}/${testData.instrumentationRunner}\")\n    }\n    return true\n}\n```\n\nrunTests 메서드와 StaticTestData 클래스에는 많은 매개변수가 있습니다. 단순화를 위해 모든 것이 작동하는 데 필요한 최소한의 세트만 사용할 것입니다. 다음과 같은 것을 사용할 것입니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- testData.testedApkFinder는 필요한 애플리케이션 APK를 가져오기 위해 사용됩니다. 라이브러리 모듈의 경우 빈 목록을 반환합니다. App Bundle에서 적절한 APK 목록을 제공하기 위해 DeviceConfigProvider를 받습니다.\n- testData.testApk은 androidTest 폴더에서 코드를 포함하는 instrumentation APK입니다.\n- testData.applicationId는 instrument 명령으로 실행해야 하는 애플리케이션 ID입니다.\n- testData.instrumentationRunner는 build.gradle 파일에서 지정한 androidx.test.runner.AndroidJUnitRunner와 같은 테스트 러너입니다.\n\n일단 사용자 정의 DeviceConfigProvider의 구현은 건너뜁니다. 이는 dadb.shell(\"getptop name\").output과 같은 다수의 속성에 대해 locale, 화면 밀도, 언어, 지역 및 ABI를 가져오도록 단순히 호출할 뿐입니다. 프로젝트 저장소에서 구현 세부 정보를 확인할 수 있습니다.\n\n지금까지 다음 구조를 구현했습니다:\n\n![image](/assets/img/2024-05-17-HowtouseGradleManagedDeviceswithyourowndevices_3.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 결과 가져오기\n\nrunTests 메서드는 모든 테스트가 통과되면 true를 반환해야 하지만, 지금은 항상 true를 반환합니다. 계기 결과를 얻기 위해 조금 더 파고들어야 합니다.\n\n기본적으로 명령줄에서 am instrument를 실행하려고 하면 실패 사항과 최종 결과만을 볼 수 있습니다. 더 많은 정보를 표시하려면 -r 및 -m 두 가지 플래그가 있습니다. 첫 번째는 결과를 텍스트 스트림으로 반환하고, 두 번째는 프로토콜 버퍼 스트림으로 반환합니다(API `= 26에서만 지원됨). 간단히 하기 위해 지금은 두 번째를 사용하겠습니다.\n\nAndroid Gradle 플러그인은 RemoteAndroidTestRunner.StatusReporterMode.PROTO_STD 열거형을 사용하여 am instrument에서 원시 데이터를 수용할 수 있는 IInstrumentationResultParser 인스턴스를 만듭니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\nval mode = RemoteAndroidTestRunner.StatusReporterMode.PROTO_STD\nval parser = mode.createInstrumentationResultParser(runId, emptyList())\n\nDadb.create(host, port).use { dadb ->\n    ...\n    dadb\n        .openShell(\"am instrument -w ${mode.amInstrumentCommandArg} $arguments ${testData.applicationId}/${testData.instrumentationRunner}\")\n        .use { stream ->\n            while (true) {\n                val packet: AdbShellPacket = stream.read()\n                if (packet is AdbShellPacket.Exit) break\n                parser.addOutput(packet.payload, 0, packet.payload.size)\n            }\n            parser.flush()\n        }\n    ...\n}\n```\n\n이번에는 shell 메서드 대신 openShell 메서드를 사용합니다. 이 메서드는 Protocol Buffers 스트림인 원시 데이터 스트림에 액세스할 수 있도록 해줍니다. 이 데이터는 IInstrumentationResultParser로 전달됩니다.\n\n# HTML 및 XML 보고서 및 암시적인 예상\n\nIInstrumentationResultParser는 테스트와 상태에 대해 청취자들에게 알립니다. emptyList()를 전달했을 것을 알 수 있습니다. 어떤 파서를 사용해야 할지 고려해보겠습니다. 몇 가지 사전 제작된 구현이 있지만, Android Gradle 플러그인이 ManagedVirtualDevice를 실행할 때 사용하는 com.android.build.gradle.internal.testing.CustomTestRunListener를 사용해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\nval xmlWriterListener = CustomTestRunListener(\n    name,\n    projectPath,\n    variantName,\n    LoggerWrapper(logger),\n)\nxmlWriterListener.setReportDir(outputDirectory)\nxmlWriterListener.setHostName(\"localhost:5555\")\n...\nval parser = mode.createInstrumentationResultParser(runId, listOf(xmlWriterListener))\n...\nreturn !xmlWriterListener.runResult.hasFailedTests()\n```\n\nCustomTestRunListener은 XmlTestRunListener를 확장하고 Android Gradle 플러그인, TeamCity 또는 여러분께 사용될 수 있는 테스트의 XML 보고서를 작성할 것입니다.\n\n만약 CustomTestRunListener로 보고서를 생성하지 않고 myDeviceDebugAndroidTest를 실행하려고 하면, com.android.build.gradle.internal.tasks.ManagedDeviceInstrumentationTestResultAggregationTask에서 예외로 실패할 것입니다. 적어도 TEST-로 시작하는 하나의 XML 보고서를 생성할 것으로 예상합니다. 그리고 CustomTestRunListener야말로 이를 강요합니다. 이 작업은 XML과 HTML 보고서를 생성할 것이며, 아래 스크린샷에서 확인할 수 있습니다:\n\n![스크린샷](/assets/img/2024-05-17-HowtouseGradleManagedDeviceswithyourowndevices_4.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 CustomTestRunListener를 사용하여 runTests 메서드에서 적절한 값을 반환할 수 있습니다. hasFailedTests 메서드에 액세스할 수 있기 때문입니다.\n\n# 원격 실행\n\nDadb.create를 사용할 때 localhost뿐만 아니라 모든 IP 주소를 전달할 수도 있습니다. 이는 코드를 사용하여 원격 에뮬레이터나 장치에서 테스트를 실행할 수 있다는 것을 의미합니다. 이를 위해 MyDevice를 설정 가능하게 만들 수 있습니다.\n\n```js\ninterface MyDevice : Device {\n\n    @get:Input\n    val host: Property<String>\n\n    @get:Input\n    val port: Property<Int>\n\n}\n\ninternal abstract class MyDeviceImpl(\n    private val name: String,\n) : RemoteDevice, ManagedDeviceTestRunnerFactory {\n\n    init {\n        // 기본 매개변수\n        host.convention(\"localhost\")\n        port.convention(5555)\n    }\n\n    ...\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nregister(\"remoteDevice\", MyDevice) {\n    it.host = \"192.168.3.4\"\n    it.port = 43617\n}\n```\n\n그런 다음 `Dadb.create(managedDevice.host.get(), managedDevice.port.get())`를 사용하세요.\n\n![이미지](/assets/img/2024-05-17-HowtouseGradleManagedDeviceswithyourowndevices_5.png)\n\n주의 깊게 읽는 독자는 이미 코드 없이 이를 수행할 수 있다는 것을 올바르게 알아차릴 수 있을 것입니다. 원격 장치를 adb 장치 목록에 표시하려면 adb connect IP:PORT를 호출하기만 하면 된다는 것이 충분하며, Android Studio 드롭다운 메뉴 안에서도 바로 확인할 수 있습니다. Gradle Managed Devices로 할 수 없는 테스트 디버깅을 할 수도 있습니다. 그러나 이러한 점을 수행할 수 있다는 것은 다음 단계에 중요한 요소입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 병렬 실행\n\n기본적으로 테스트를 실행할 때 한 번에 한 장치에서만 실행됩니다. 여러 장치나 에뮬레이터에서 테스트를 병렬로 실행할 수 있는 기능이 있다면 좋을텐데요. 좋은 소식은 그런 방법을 찾았다는 것입니다.\n\nAndroidJUnitRunner은 테스트를 샤드(shard)로 분할하여 하나의 샤드를 실행하는 기능을 지원합니다. 예를 들어, am instrument -w -e numShards 2 -e shardIndex 0는 두 개의 테스트 중 첫 번째 테스트를 실행하고, -e shardIndex 1은 두 개의 테스트 중 두 번째 테스트를 실행합니다.\n\n하지만 이를 실제로 활용하려고 하면 다음과 같은 내용이 나타날 것입니다 (출처):\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n#!/usr/bin/env bash\n./gradlew assembleAndroidTest\npids=\nenv ANDROID_SERIAL=emulator-5554 ./gradlew \\\n    connectedAndroidTest \\\n    -Pandroid.testInstrumentationRunnerArguments.numShards=2 \\\n    -Pandroid.testInstrumentationRunnerArguments.shardIndex=0 \\\n    -PtestReportsDir=build/testReports/shard0 \\\n    -PtestResultsDir=build/testResults/shard0 \\\n    &\npids+=\" $!\"\nenv ANDROID_SERIAL=emulator-5556 ./gradlew \\\n    connectedAndroidTest \\\n    -Pandroid.testInstrumentationRunnerArguments.numShards=2 \\\n    -Pandroid.testInstrumentationRunnerArguments.shardIndex=1 \\\n    -PtestReportsDir=build/testReports/shard1 \\\n    -PtestResultsDir=build/testResults/shard1 \\\n    &\npids+=\" $!\"\nwait $pids || { echo \"there were errors\" >&2; exit 1; }\nexit 0\n```\n\n이 방법은 ‘편리’에서는 거리가 먼 방법이며, 많은 매개변수를 사용하여 두 connectedAndroidTest 작업을 병렬로 실행하고 결과를 수동으로 병합한 후 TeamCity와 같은 곳에 보고해야 합니다.\n\nGradle Managed Devices는 android.experimental.androidTest.numManagedDeviceShards=`number_of_shards`와 같은 옵션을 통해 테스트 샤딩을 지원하지만, ManagedVirtualDevice에서만 작동합니다. 우리의 경우에는 자체적으로 관리하는 장치들과 함께 샤딩을 사용하고 싶습니다.\n\nGradle Managed Devices에서는 Device 추상화를 사용합니다. 이 추상화는 전체로 표현되는 여러 장치를 구현할 수 있습니다. 새로운 장치 유형을 소개하고 장치로 등록합시다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\n인터페이스 MultipleDevices : Device {\n\n    @get:Input\n    val devices: ListProperty<String>\n\n}\n```\n\n```kotlin\nandroid {\n    testOptions {\n        managedDevices {\n            devices {\n                register(\"multipleDevices\", com.example.MultipleDevices) {\n                    it.devices.add(\"localhost:5555\")\n                    it.devices.add(\"localhost:5557\")\n                }\n            }\n        }\n    }\n}\n```\n\nADB와 관련된 모든 것은 AdbRunner 클래스로 추출되었고 새 매개변수 ShardInfo(index, total)가 추가되었습니다. ShardInfo의 매개변수는 dadb.openShell(“am instrument”) 실행에 그대로 추가됩니다.\n\n이제 테스트를 병렬로 실행하도록 ManagedDeviceTestRunner를 구현해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\noverride fun runTests(...): Boolean {\n\n    val devices = managedDevice.devices.get().map {\n        // \"host:port\"를 Pair<String, Int>로 분리\n        val split = it.split(':')\n        split[0] to split[1].toInt()\n    }\n\n    val threadPool = Executors.newCachedThreadPool()\n\n    val futures = devices.mapIndexed { index, (host, port) ->\n        threadPool.submit(Callable {\n            val runner = AdbRunner(\n                host = host,\n                port = port,\n                shardInfo = AdbRunner.ShardInfo(\n                    index = index,\n                    total = devices.size,\n                ),\n            )\n            val result = runner.run(\n                // 각 디바이스에 대해 고유한 이름을 사용하여 독립적인 XML 보고서를 생성해야 합니다.\n                name = \"${managedDevice.name}-${host}-${port}\",\n                runId = runId,\n                outputDirectory = outputDirectory,\n                projectPath = projectPath,\n                variantName = variantName,\n                testData = testData,\n                logger = logger,\n            )\n            result\n        })\n    }\n\n    val success = futures.all { it.get() }\n\n    threadPool.shutdown()\n\n    return success\n}\n```\n\n주의해야 할 사항:\n\n- ThreadPool을 사용하고 있는데, 이는 Gradle에서 좋지 않은 방법입니다. 대신 WorkerExecutor를 사용해야 합니다. ManagedDeviceTestRunnerFactory의 매개변수에서 사용 가능한 WorkerExecutor 인스턴스를 얻을 수 있습니다. 현재 사용하지 않는 이유는 StaticTestData가 직렬화되지 않아 별도의 직렬화 가능한 데이터 홀더로 속성을 복사하여 WorkerExecutor에 전달하고 싶지 않기 때문입니다.\n- 이름은 각 shard에 대해 고유해야 합니다. CustomTestRunListener에 이름을 전달하여 파일 이름에 이름이 포함된 XML 보고서가 생성됩니다. 모든 XML 보고서는 나중에 모아져 병합되므로 어떤 테스트가 어떤 디바이스에서 실행되었는지 확인할 수 있습니다.\n\n<img src=\"/assets/img/2024-05-17-HowtouseGradleManagedDeviceswithyourowndevices_6.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n샤딩은 매우 중요하며 많은 UI 테스트 케이스에서 도움이 됩니다. 샘플 레파지토리에서는 라이브러리와 어플리케이션 모듈을 준비했는데, 두 모듈 모두 100개의 UI 테스트가 있습니다. 한 모듈에서 테스트를 실행하는 데 약 1분 10초가 걸립니다. 그러므로 두 모듈을 함께 실행하는 데는 약 2분 33초가 소요됩니다. 같은 테스트 스위트를 MultipleDevices에서 실행하면 약 1분 31초만에 완료됩니다. — 필요한 시간의 거의 절반입니다.\n\n```js\n  에뮬레이터 수  시간\n ----------- -----------\n  1           2분 33초\n  2           1분 31초\n  3           43초\n```\n\n<img src=\"/assets/img/2024-05-17-HowtouseGradleManagedDeviceswithyourowndevices_7.png\" />\n\n# 병렬 원격 실행\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n비록 이렇게 급격한 개선이 있었지만, 하나의 문제에서는 자유로울 수 없습니다: 로컬에서 에뮬레이터를 실행해야 하기 때문에, 개발자 노트북의 자원을 많이 소비합니다.\n\n이 문제를 해결하기 위해 수십 개의 에뮬레이터를 호스팅할 서버를 만들어 HTTP API를 다음과 같이 가지게 만들어보죠:\n\n```js\nGET /lease?devices=%number%\n\n200 OK\n[\n    {\n        host: \"10.10.0.3\",\n        port: 5555,\n        release_key: \"ab34fd2d158f9\"\n    },\n    ...\n]\n\nPOST /release\n[ \"ab34fd2d158f9\", ... ]\n\n200 OK\n```\n\n해당 서버는 우리만 사용할 수 있는 단말기나 에뮬레이터의 집합을 반환하며, 해당 API 호출로 이들을 해제할 때까지만 사용할 수 있습니다. 이를 \"장치 브로커\"라고 부르도록 합시다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n디바이스 브로커는 개발자뿐만 아니라 CI(지속적인 통합)에도 혜택을 줍니다. 일반적인 CI 흐름은 앱을 빌드하고 에뮬레이터에서 테스트를 실행하는 것입니다. 이 두 단계는 CPU 및 메모리를 많이 사용하는 작업이므로 이러한 작업을 병렬로 수행할 수도 있습니다. 에뮬레이터를 다른 서버로 외부위탁함으로써 빌드 서버는 앱을 빌드하고 테스트 결과를 확인하는 데에 자원을 공유하는 대신 집중할 수 있게 됩니다.\n\nGradle 쪽의 구현은 상당히 간단하며 MultipleDevices와 유사한 모양입니다.\n\n```js\ninterface DeviceFarm : Device {\n\n    @get:Input\n    val shards: Property<Int>\n\n}\n\nclass DeviceBroker {\n\n    fun lease(amount: Int): Collection<Device> {\n        TODO(\"디바이스를 얻기 위한 네트워크 요청을 만듭니다. 이용 가능한 디바이스가 없는 경우 대기해야 합니다.\")\n    }\n\n    fun release(devices: Collection<Device>) {\n        TODO(\"다른 사용자를 위해 디바이스를 해제하기 위한 네트워크 요청을 만듭니다.\")\n    }\n\n    class Device(\n        val host: String,\n        val port: Int,\n        val releaseToken: String,\n    )\n\n}\n\ninternal class DeviceFarmTestRunner : ManagedDeviceTestRunner {\n\n    override fun runTests(...): Boolean {\n        val broker = DeviceBroker()\n        val devices = broker.lease(managedDevice.shards.get())\n\n        devices.forEachIndexed { shardIndex, device ->\n            ...\n        }\n\n        broker.release(devices)\n\n        return success\n    }\n\n}\n```\n\n![이미지](/assets/img/2024-05-17-HowtouseGradleManagedDeviceswithyourowndevices_8.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 결과\n\n우리는 Gradle Managed Devices와 통합하기 위한 사용자 정의 장치를 구현하는 방법에 대해 조사했습니다. 장치는 우리가 원하는 것으로 뒷받침될 수 있는 추상화입니다: 단일 장치 또는 에뮬레이터, 로컬 또는 Firebase Test Lab과 같은 웹 서비스에 원격으로 호스팅되거나 브로커 서비스가 있는 사용자 정의 장치 팜 등이 될 수 있습니다. 단일 장치의 경우에는 ADB를 통해 직접 adb connect를 사용하여 연결할 수 있으므로 실질적인 혜택이 없습니다(디버거를 연결하는 기능과 같은 기능을 손실하지 않으면서). 그러나 여러 원격 장치에 뒷받침된 장치를 구현함으로써 개발자의 노트북 및 CI 빌드 서버의 계산 리소스를 할당할 수 있습니다. 또한 샤딩 기능을 사용하여 테스트 실행을 병렬화하고, 2대의 장치를 사용할 경우 테스트 실행 속도를 2배 높일 수 있습니다.\n\n코드는 저장소에서 사용할 수 있지만, 이것은 개념 증명으로 의도된 대로 프로덕션에서 사용되는 것이 아님을 명심하십시오. 코드는 조직에서 이 접근 방식을 도입하는 데 큰 도움이 될 수 있습니다. 구현 세부사항은 귀하의 인프라에 크게 의존합니다. 마지막으로 코드 자체는 오류에 강건하지 않으며 더 신뢰할 수 있는 방식으로 다시 작성해야 합니다.\n\n질문이 있으시면 아래의 코멘트 섹션에서 자유롭게 물어봐 주세요.\n","ogImage":{"url":"/assets/img/2024-05-17-HowtouseGradleManagedDeviceswithyourowndevices_0.png"},"coverImage":"/assets/img/2024-05-17-HowtouseGradleManagedDeviceswithyourowndevices_0.png","tag":["Tech"],"readingTime":25},{"title":"3DraftCode  Retrofit","description":"","date":"2024-05-17 17:47","slug":"2024-05-17-3DraftCodeRetrofit","content":"\n<img src=\"/assets/img/2024-05-17-3DraftCodeRetrofit_0.png\" />\n\n# Retrofit이란 무엇인가요?\n\nRetrofit은 안드로이드 개발에서 네트워킹을 위해 사용되는 인기 있는 라이브러리 또는 종속성 중 하나입니다. 이는 RESTful 서비스와 상호 작용하는 데 사용하는 고수준 인터페이스를 제공하여 웹 서비스와 API로 HTTP 요청을 보내는 과정을 단순화합니다. Retrofit을 사용하면 API 엔드포인트와 JSON 응답을 나타내는 데이터 모델을 간단하고 선언적인 방식으로 정의할 수 있습니다. 또한 네트워크 요청, JSON 데이터의 직렬화 및 역직렬화와 같은 작업을 처리하여 개발자가 안드로이드 애플리케이션에서 웹 서버와 RESTful API를 소비하는 것이 더 쉽도록합니다. 전반적으로 Retrofit은 안드로이드 앱에서 네트워크 작업을 처리하는 간편함, 효율성 및 유연성으로 널리 사용됩니다.\n\n# 왜 Retrofit을 사용해야 할까요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nRetrofit은 Android 개발에서 네트워크 작업을 처리하는 우선적인 선택으로 여겨지는 몇 가지 이점을 제공합니다:\n\n- 간편함: Retrofit은 API 엔드포인트를 정의하고 상호 작용하기 위한 깨끗하고 직관적인 인터페이스를 제공하여 네트워크 요청을 만드는 과정을 간소화합니다.\n- 유형 안정성: Retrofit은 API 인터페이스 정의를 기반으로 유형 안전한 HTTP 클라이언트를 생성합니다. 이는 개발자로서 HTTP 요청 및 응답에 대한 컴파일 시간 유효성 검사를 제공하여 데이터 유형이 잘못된 경우나 필드가 누락된 경우의 런타임 오류 가능성을 줄입니다.\n- 쉬운 통합: Retrofit은 Android 생태계의 다른 인기 있는 라이브러리들과 원활하게 통합됩니다. 예를 들어 JSON 직렬화/역직렬화를 위한 Gson이나 Moshi, 그리고 비동기 작업 처리를 위한 RxJava나 Kotlin 코루틴 등을 사용할 수 있습니다.\n- 효율성: Retrofit은 성능을 최적화하여 네트워크 리소스를 효율적으로 사용합니다. 요청/응답 캐싱, 연결 풀링, 비동기 요청 실행 등의 기능을 지원하여 빠르고 반응성이 좋은 애플리케이션을 만드는 데 도움을 줍니다.\n- 유연성: Retrofit은 다양한 사용 사례와 요구 사항에 적응하기 위한 다양한 사용자 정의 옵션을 제공합니다. HTTP 헤더, 요청 타임아웃, 오류 처리 메커니즘, 로깅 수준 등을 필요에 맞춰 구성할 수 있습니다.\n\n# Retrofit을 사용해야 하는 경우?\n\nRetrofit이 제공하는 다양한 이점을 고려하면, 네트워크 작업 및 RESTful API와 작업할 때마다 Retrofit을 사용해야 한다고 생각합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# Retrofit 예제?\n\n여기서 Retrofit을 사용하는 방법을 공유할게요.\n\n1. Android 프로젝트에 Retrofit 추가하기 (build.gradle)\n\n```js\ndependencies {\n    implementation 'com.squareup.retrofit2:retrofit:2.9.0'\n    implementation 'com.squareup.retrofit2:converter-gson:2.9.0' // JSON 직렬화/역직렬화를 위해\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n2. 데이터 클래스 정의\n\nJSON 응답 API를 기반으로 데이터 클래스를 정의하세요.\n\n```kotlin\ndata class User(\n    val id: Int,\n    val name: String,\n    val username: String,\n    val email: String\n)\n```\n\n3. API 인터페이스 정의\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\n인터페이스 ApiService {\n\n    @GET(\"users/{id}\")\n    fun getUserById(@Path(\"id\") userId: Int): Call<User>\n\n}\n```\n\n4. Retrofit 인스턴스 생성\n\n기본 URL을 구성하고 JSON 파싱을 위한 컨버터 팩토리를 추가하려면 Retrofit 인스턴스를 설정하십시오.\n\n```kotlin\nobject ApiClient {\n    private const val BASE_URL = \"https://jsonplaceholder.typicode.com/\"\n\n    val retrofit: Retrofit = Retrofit.Builder()\n        .baseUrl(BASE_URL)\n        .addConverterFactory(GsonConverterFactory.create())\n        .build()\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n5. 네트워크 요청 만들기\n\n여기에서 Retrofit을 사용하여 Activity에서 네트워크 요청을 할 수 있습니다.\n\n```kotlin\nclass MainActivity : AppCompatActivity() {\n\n    private lateinit var apiService: ApiService\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n\n        apiService = ApiClient.retrofit.create(ApiService::class.java)\n\n        getUserById(userId: 1)\n    }\n\n    private fun getUserById(userId: Int) {\n        val call = apiService.getUserById(userId)\n        call.enqueue(object : Callback<User> {\n            override fun onResponse(call: Call<User>, response: Response<User>) {\n                if (response.isSuccessful) {\n                    val user = response.body()\n                    Log.d(\"MainActivity\", \"User: $user\")\n                } else {\n                    Log.e(\"MainActivity\", \"Request failed: ${response.errorBody()}\")\n                }\n            }\n\n            override fun onFailure(call: Call<User>, t: Throwable) {\n                Log.e(\"MainActivity\", \"Network request failed\", t)\n            }\n        })\n    }\n}\n```\n\n6. Manifest에 권한을 추가하는 것을 잊지 마세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n<uses-permission android:name=\"android.permission.INTERNET\" />\n```\n\n자세한 내용은 Retrofit 공식 페이지를 확인해보세요.\n","ogImage":{"url":"/assets/img/2024-05-17-3DraftCodeRetrofit_0.png"},"coverImage":"/assets/img/2024-05-17-3DraftCodeRetrofit_0.png","tag":["Tech"],"readingTime":6},{"title":"맥OS에서 RVM 설치하기 단계별로","description":"","date":"2024-05-17 17:46","slug":"2024-05-17-InstallRVMinmacOSstepbystep","content":"\n오직 나 한테만 말하고 싶어서 죄송한데, 덕분에 글쓰기를 멈출 수가 없어 😛\n\n# 필수 준비물\n\n- Homebrew 🍺\n\n# 시작해봅시다!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n1. GnuPG 설치\n\n```bash\n$ brew install gnupg\n```\n\n2. GPG 키 설치 (첫 번째 방법 또는 두 번째 방법 중 선택)\n\n2.1 첫 번째 방법\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n$ gpg --keyserver hkp://pool.sks-keyservers.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3 7D2BAF1CF37B13E2069D6956105BD0E739499BDB\n\n2.2 Second way\n\n$ gpg --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3 7D2BAF1CF37B13E2069D6956105BD0E739499BDB\n\n3. Install RVM\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n$ \\curl -sSL https://get.rvm.io | bash\n```\n\n4. 콘솔에서 감사 메시지 🙏를 받게 됩니다.\n\n5. 모든 터미널을 종료하세요.\n\n6. 새 터미널을 열고 이겼어요! 해보세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n$ rvm 리스트\n```\n\n7. 이 메시지가 나타납니다.\n\n```js\n# 아직 rvm 루비가 설치되지 않았습니다. 'rvm 도움말 설치'를 시도해보세요.\n```\n\n8. 2.7.1과 같은 몇 가지 루비 버전을 설치하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 예전 버전인 2.3.1 등을 사용하고 싶다면 아래 팁 항목을 확인해주세요 😉\n- 버전 3 이상을 사용하고 싶다면 아래 루비 버전 3+에 대한 참고사항을 확인해주세요 😁\n\n```bash\n$ rvm install 2.7.1\n```\n\n9. 설치가 완료된 후 사용 가능한 루비 버전을 확인해보세요.\n\n```bash\n$ rvm list\nruby-2.7.1 [ x86_64 ]\n# 기본 루비가 설정되지 않았습니다. 'rvm alias create default <ruby>'를 시도해보세요.\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n10. 기본 루비 버전을 만듭니다\n\n```js\n$ rvm alias create default 2.7.1\n```\n\n11. 그게 다에요! 즐겨주세요 🎉\n\n# 팁 💡\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n루비의 이전 버전을 사용하는 경우, openssl과 관련된 아래와 같은 오류 메시지가 발생할 수 있습니다.\n\n```\n\n/Users/pagorn/.rvm/src/rubygems-3.0.8/lib/rubygems/core_ext/kernel_require.rb:54:in `require': cannot load such file -- openssl (LoadError)\n\n따라서, rvm에서 openssl을 설치한 다음 이 openssl을 사용하여 이전 버전의 루비를 설치해야 합니다.\n\n$ rvm pkg install openssl\n$ rvm install 2.3.1 --with-openssl-dir=$HOME/.rvm/usr\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# Ruby 버전 3+에 대한 참고 사항\n\n루비 v3를 설치할 때는 특정 openssl 위치를 지정해야 할 수 있습니다.\n\n설치하기 전에 openssl 위치를 확인해주세요.\n\n- 위치 A\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n$ ls /usr/local/opt | grep openssl\nopenssl\nopenssl@1.1\nopenssl@3\nopenssl@3.1\n```\n\n```js\n$ rvm install ruby-3.1.0 --with-openssl-dir=/usr/local/opt/openssl@3.1\n```\n\n- 위치 B\n\n```js\n$ ls /opt/homebrew/opt | grep openssl\nopenssl\nopenssl@1.1\nopenssl@3\nopenssl@3.1\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n$ rvm install ruby-3.1.0 --with-openssl-dir=/opt/homebrew/opt/openssl@3.1\n```\n\n# 참고 자료\n\n- https://formulae.brew.sh/formula/gnupg\n- https://rvm.io/\n- https://stackoverflow.com/questions/54895263/how-to-install-gpg2-via-homebrew\n- https://github.com/rvm/rvm/issues/4607#issuecomment-619422100\n- https://github.com/rvm/rvm/issues/4607#issuecomment-621343322\n- https://mac.install.guide/homebrew/3.html\n","ogImage":{"url":"/assets/img/2024-05-17-InstallRVMinmacOSstepbystep_0.png"},"coverImage":"/assets/img/2024-05-17-InstallRVMinmacOSstepbystep_0.png","tag":["Tech"],"readingTime":5},{"title":"왜 PEDAC를 좋아하지 않을 수도 있을 것입니다","description":"","date":"2024-05-17 17:44","slug":"2024-05-17-WhyYouWontLikePEDAC","content":"\n## PEDAC는 정말 어렵죠. 그렇다고 말했어요.\n\n![image](/assets/img/2024-05-17-WhyYouWontLikePEDAC_0.png)\n\n시간 낭비 같아요.\n직관적이지 않고 어색하게 느껴져요.\n배울 수 없는 것처럼 느껴져요.\n\n최소한 처음에는 이런 느낌입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n본문을 마칠 즈음, 저는 PEDAC 및 문제 해결 과정 전체에 대해 학습하는 동안 동기부여를 잃은 사람들, 정체감을 느끼는 사람들, \"연기자 증후군\"에 대한 새로운 동기 부여를 주고 PEDAC에 대한 진정한 감사함과 개선 팁을 제공하기를 희망합니다.\n\n## 이 기사에서는 다음과 같은 내용을 다룰 것입니다:\n\n- 시작과 현재의 차이\n- 학습에 어려움을 겪는 이유 및 극복 방법\n- 동기를 유지하고 더 효과적으로 학습하는 데 도움이 된 정신적 변화\n- 코딩 자체보다 그것을 사랑하는 방법 (결국 빠르게 학습하고 더 나은 문제 해결자가 되는 데 도움이 될 것입니다)\n\n# 개인 이야기:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저는 현재 Launch School이라는 온라인 커리큘럼에 등록되어 있습니다. 이 학교는 견고한 문제 해결 프로세스를 개발하는 데 큰 중점을 둡니다. 그들은 여러분이 프로세스를 개발하는 데 도움을 주는 PEDAC라는 프레임워크를 소개합니다.\n\nLaunch School을 시작하기 한 해 전에 프로그래밍 기초를 공부했었지만, 문제 해결에는 전혀 손 대지 못했습니다. Code Wars의 초급 연습 문제를 시도해보지만 해결하지 못했죠.\n\n이는 매우 흐뭇했고, 다른 사람들 대부분이 이러한 \"쉬운\" 질문들을 해결할 수 있다는 것을 알면서 상처받았습니다. 1년 넘는 공부 끝에 한 문제도 거의 해결하지 못했기 때문이죠. 그러나 문제 해결 프로세스에 주력한 후에는 이제 초보자 및 중급 수준의 많은 문제들을 자신 있게 쉽게 해결할 수 있게 되었습니다.\n\n이 일은 단 몇 주 만에 일어난 일입니다. 만약 자신감을 잃고 이 보기 어렵고 복잡한 문제들을 쉽게 해결할 수 있는 사람으로 스스로 그릴 수 없다면 — 두려워하지 마세요, 왜냐하면 몇 달 전에 저도 그 똑같은 고비를 넘었기 때문이죠.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/assets/img/2024-05-17-WhyYouWontLikePEDAC_1.png)\n\n# 이 공부가 어색하게 느껴지는 이유\n\n내가 소속된 동료들 중 대부분이 불편해하는 가장 큰 문제 중 하나는 공포의 \"Hack 'n' Slash\" 접근 방식입니다.\n\n이 문제를 지적하면서도, 우리는 여전히 의도적이거나 계획적인 다른 방식을 취하는 것을 싫어합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n왜 그럴까요?\n\n## 익숙하지 않아서 생산성이 떨어지는 기분이 들어요.\n\n지금까지 대부분의 문제는 복잡도가 낮았습니다. 당장 들어가서 코딩을 시작할 수 있어요. 더 흥미롭고 당신이 더 빨리 성취감을 느끼게 되죠.\n\n지금까지의 경험은 이랬어요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n가장 빨리 작업을 완료하는 데 도움이 되는 방법이죠... 지금까지는요.\n\n문제를 시작할 때 문제 자체에 대해 생각하고 긴 해결책을 쓰는 것은 지금까지 우리가 문제를 해결해 오던 방식과 대립됩니다.\n\n이것도 완전히 이해가 가죠. 처음에는 기본 개념과 언어 능숙도를 개발하는 데 중점을 두죠. 새로운 개념을 실용적인 방식으로 학습하기 위해 기본적이고 쉬운 문제를 해결해야 합니다.\n\n이것이 'PEDAC 학습에 마찰력을 일으키는 데 기여하는 몇 가지를 한다고 생각합니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 더 쉬운 문제들은 보통 나에게 보상을 더 빨리 줬어. 나는 해결책에 더 빨리 도달했어.\n- 이는 향후 소프트웨어 엔지니어링 문제에 필요한 해결책과 기술에 대한 기대감을 형성할 수 있어요.\n\n정신적 변화:\n\n- PEDAC가 일반적으로 더 효율적인 방법이라는 것을 상기해봐, 비록 그렇게 느껴지지 않아도. 문제의 난이도가 증가할수록 더욱 참된 이치가 된다.\n- 문제 해결에 걸리는 시간에 대한 기대를 재조정해봐. 문제가 어려워질수록 문제 해결에 필요한 시간이 증가한다. 이것은 정상적이야.\n- 기억해, 당신이 PEDAC를 더 효율적으로 여기는 아이디어를 받아들일 때까지 첫 번째 여러 문제와 시도에서 이런 느낌을 가질 것이라는 걸 기억해봐. 감정에도 불구하고 과정을 믿어봐.\n- 이런 느낌들은 좋은 징조일 수 있어. 당신이 배우고 있고 당신의 두뇌가 문제 해결 머신이 되도록 재배열되고 있는 신호야. 당신의 두뇌는 변하고 변화는 노력을 필요로해. 어느 정도의 정신적 마찰을 겪을 것으로 예상돼.\n\n## 지루하고 동기부여가 되지 않는 느낌을 받을지도 모르지만... 이것은 변할 수 있어요!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n지금까지 학습 과정은 매우 간단해 왔어요:\n\n- 새로운 개념을 배우고 개념 모델을 개발합니다.\n- 구문과 새로운 용어를 암기합니다.\n- 배운 개념을 기초 문제로 테스트합니다.\n- 문제를 해결하면 치즈를 얻게 돼요 🧀\n\n![이미지](/assets/img/2024-05-17-WhyYouWontLikePEDAC_2.png)\n\n우리는 초기에는 치즈를 더 자주 먹고 쉽게 먹어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n런치 스쿨 커리큘럼에서 말하는 대로, 문제를 해결하는 유일한 방법은 없으며 PEDAC는 단지 당신만의 문제 해결 과정을 찾기 위한 지침일 뿐입니다.\n\n새로운 수업은 이전과 같은 경험이 아닙니다.\n그것은 규칙이나 메타모델 또는 외워야 하는 문법이 아닙니다. 오히려 당신이 운동을 하며 개발해야 하는 근육과 유사합니다.\n\n이 새로운 수업은 기억력과 정의보다는 내면적 사색, 검토 및 실험을 더 필요로 합니다.\n\n처음에는 개념 또는 용어를 손에 익힌 것을 알 수 있었던 때입니다. 그때 당신은 그 정의를 정확히 알고 코드에서 예제를 보여주고 이해할 수 있을 때였습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nPEDAC를 이해했다고 어떻게 알 수 있을까요?\n\n그 답변은 확실하지 않습니다. 현재 이해와 비교할 문서나 코드 예제가 없습니다. 구문에서 PEDAC를 식별할 수 있는 코드 예제가 없습니다.\n\n이는 최종 목표가 조금 덜 확실하기 때문에 두려울 수 있습니다.\n\n\"내가 이것을 알고 있다는 것을 어떻게 알까요?\"\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n처음으로 PEDAC를 배우려고 시도했을 때 저는 매우 동기 부여가 떨어지고 사기가 떨어지는 느낌을 받았어요. 보상이 명확하지 않았고, 내가 진행 중인지 알 수 없는 것 같았어요.\n\n내가 본 것은 다른 사람들이 자신들만의 방법으로 문제를 효율적으로 해결하는 모습 뿐이었는데, 한 번에 \"이게 바로 네가 해야 하는 방법이야, 여기가 정의야\" 라는 순간을 찾지 못했어요. 이로 인해 PEDAC는 당신과 맞지 않는 것인 것 처럼 느껴질 수 있고, 그것을 이해하기 어려울 수 있어요.\n\n기본 사고 변경:\n\n- \"이게 바로 네가 해야 하는 방법이야\" 순간을 찾으려 하지 마세요. PEDAC는 시간이 지나면서 발견하는 것이며, 야생에서 찾아낼 수 있는 것이 아닙니다.\n- 진행 중이지 않다는 느낌을 받을 것입니다. 그건 정상적인 것이니 마음에 두세요.\n- PEDAC는 운동과 같습니다. x 개의 팔 굽혀 펴기를 하고 근육이 붙는 것이 아닙니다. 하루하루 변화를 알아차리지 못할 것입니다. 하지만 꾸준하게 계속하면 언젠가는 당신도 멋진 프로그래머가 될 거에요 💪\n- 문제를 이전처럼 빠른 속도로 해결하는 보상은 받지 못할 것입니다. 그러나 문제들이 어려워지면(좋은 치즈처럼) 더 큰 보상을 받을 수 있습니다. 단지 좀 더 빈도가 낮을 뿐이에요.\n- 꾸준하게 하고 프로세스를 신뢰하세요. 당신은 진전하고 있어요!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/assets/img/2024-05-17-WhyYouWontLikePEDAC_3.png)\n\n## \"어떻게 하면 PEDAC을 좋아할 수 있을까요?\"\n\n상상하기 어렵지만, 언젠간 그렇게 될 거예요.\n결국, 당신도 PEDAC를 정말 좋아하게 될 거예요.\n\n언젠가는 이런 변화가 올 거라는 것에 대해 알고 있는 것이 때로는 동기부여를 유지하는 데 도움이 되었어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## PEDAC을 코딩할 때의 \"안전한 장소\"로 생각해보세요\n\n버그와 오류는 코딩을 시작할 때 발생합니다.\n\n코딩 전 단계는 실수와 논리 오류를 만드는 안전한 장소입니다. 처음에 모든 것을 완벽하게 이해할 필요는 없고, 첫 시도에서 로직을 완벽하게 이해해야 하는 것도 중요하지 않습니다. 중요한 것은 과정에 대해 의식적이고 의도적이라는 것입니다.\n\n코딩 도중에 해결 방법을 코딩하다가 터미널에서 오류 메시지를 읽기만으로 해결할 수 없는 오류를 마주했을 때 가장 싫은 상황이라고 할 수 있습니다. 논리 오류를 수정하는 것은 문법 오류나 타입 오류를 고치는 것보다 어려운 작업입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n지금은 와닿지 않을 수 있지만, PEDAC를 더 자주 사용함으로써 더 많이 이해할 수 있게 될 거에요.\n\n## 더 큰 그림을 기억하고 여러분이 여기 있는 이유를 기억하세요\n\n코딩을 하는 것이 재미있게 만드는 주요한 부분은 코드를 입력하는 것이 아니라 문제 해결이라는 것을 스스로 상기하세요.\n\n쉬운 문제에 코드를 작성하는 것은 지루해질 수 있어요. 최적으로 도전적인 문제에 코드를 작성하는 것이 즐거움을 느끼는 때입니다. 문제 해결에 열중할 때 (심지어 힘들 때도) 코드 편집기 바깥에 무슨 일이 일어나고 있는지 생각하지 않는다는 것을 주목하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이게 당연한 것 같지만, 학습하고 문제 해결하는 걸 즐기는 걸 생각해봐. 그래야 현재에 더 집중할 수 있을 거야. 이걸 알면 당신의 난관을 이해하는 데 도움이 될 거야.\n\n큰 그림을 보면, 이전과 똑같은 일을 하고 있지만 세부사항이 다를 뿐이야.\n\n그리고 난관에 부딪히는 건 문제가 아님을 알아둬, 이는 아마도 새로운 방식으로 최적의 도전을 받고 있는 신호에 불과할 거야. 새로운 문제와 새로운 세부사항이 있지만 궁극적으로는 여전히 당신을 지탱하는 문제 해결이야.\n\n언제나 글쓰기를 개선하려고 노력하고 있어, 그래서 이 글에 동의하든 반대하든, 도움이 되었든 그렇지 않았든 당신의 피드백을 정말로 감사히 받겠어.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저도 다른 사람들이 PEDAC를 배우면서 느낀 경험을 듣고 싶어요. 댓글을 남기거나 제 소셜 미디어로 DM을 보내도 괜찮아요.\n\n도움이 되었으면 좋겠어요! 행복한 PEDAC 공부 되세요 👨‍💻\n","ogImage":{"url":"/assets/img/2024-05-17-WhyYouWontLikePEDAC_0.png"},"coverImage":"/assets/img/2024-05-17-WhyYouWontLikePEDAC_0.png","tag":["Tech"],"readingTime":9},{"title":"자바 SpringBoot를 사용한 JSON 스키마 유효성 검사기","description":"","date":"2024-05-17 17:43","slug":"2024-05-17-JSONSchemaValidatorusingJavaSpringBoot","content":"\n## Json 스키마란 무엇인가요?\n\nJSON Schema은 선언적 언어입니다. 이는 우리 서비스에 특정한 json 구조를 정의하고 유효성을 검사합니다. 주어진 json 데이터에 대한 표준 구조로 여러 시스템에서 사용할 수 있습니다. 자세한 내용은 여기를 참조하세요: what-is-jsonschema?\n\n## Json 스키마를 사용하는 이유는 무엇인가요?\n\n대부분의 경우, 서비스에서 들어오는 json을 유효성 검사하는 것이 필요합니다. 간단한 json은 속성에 제약 조건을 적용하여 POJO 또는 모델에 매핑할 때 유효성을 검사할 수 있습니다. 그러나 때로는 json이 복잡하여 이러한 제약 조건을 사용하여 모든 필드를 유효성을 검사할 수 없는 경우가 있습니다. JsonSchema를 사용하면 표준화된 구조를 사용하여 복잡한 json을 유효성을 검사할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 내용:\n\nSpringBoot와 Json Schema를 사용하는 단계별 가이드입니다. 이를 위해 networknt 라이브러리를 사용할 것입니다. 단계를 거친 후에는 테스트를 위해 수신된 json에 대한 몇 가지 시나리오가 있습니다.\n\n참고: 이 문서는 SpringBoot와 JsonSchema의 사용을 위한 것입니다. 이는 JsonSchema의 일부 기능 및 사용법에 대해 가르치기 위한 것입니다.\n\n## 1. SpringBoot 웹 애플리케이션을 생성하세요: https://start.spring.io/\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![image](/assets/img/2024-05-17-JSONSchemaValidatorusingJavaSpringBoot_0.png)\n\n알림: spring-boot 및 java의 모든 버전 및 프로젝트 유형을 선택할 수 있습니다.\n\n## 2. pom.xml 또는 build.gradle에 종속성 추가.\n\n```js\n<--\npom.xml\nhttps://mvnrepository.com/artifact/com.networknt/json-schema-validator\n-->\n<dependency>\n  <groupId>com.networknt</groupId>\n  <artifactId>json-schema-validator</artifactId>\n  <version>1.4.0</version>\n</dependency>\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n// build.gradle\n// https://mvnrepository.com/artifact/com.networknt/json-schema-validator\nimplementation 'com.networknt:json-schema-validator:1.4.0'\n```\n\n## 3. 리소스 유효성 검사 JSON 파일을 생성합니다.\n\n```js\n{\n \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n    \"title\": \"Order Event\",\n    \"description\": \"예제용 주문 이벤트 스키마\",\n    \"required\": [\"order_id\", \"total_price\", \"products\" ],\n    \"properties\": {\n       \"order_id\": {\n          \"type\": \"string\"\n        },\n        \"event\": {\n          \"enum\": [\"PLACED\", \"DELIVERED\", \"RETURNED\"],\n          \"type\": \"string\"\n        },\n        \"total_price\": {\n         \"type\": \"number\",\n             \"minimum\": 0\n     },\n        \"products\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"additionalProperties\": true,\n        \"required\": [\"product_id\", \"price\"],\n        \"minItems\": 1,\n        \"properties\": {\n          \"product_id\": {\n            \"type\": \"string\"\n          },\n          \"price\": {\n            \"type\": \"number\",\n            \"minimum\": 0\n          },\n          \"quantity\": {\n            \"type\": \"integer\"\n          }\n        }\n      }\n    }\n   }\n}\n```\n\n## 4. JsonSchema 빈을 생성합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n호출자 메서드에서는 JsonSchema 객체를 직접 생성할 수 있지만, 빈을 생성하고 사용하는 것을 권장합니다.\n\n```java\n@Configuration\npublic class AppConfiguration {\n    private static final String SCHEMA_VALIDATION_FILE = \"validation.json\";\n\n    @Bean\n    public JsonSchema jsonSchema() {\n        return JsonSchemaFactory\n                .getInstance( SpecVersion.VersionFlag.V7 )\n                .getSchema( getClass().getResourceAsStream( SCHEMA_VALIDATION_FILE ) );\n    }\n}\n```\n\n## 5. JsonSchema 사용법\n\n이제 JsonSchema 객체를 사용해보겠습니다. JsonNode를 매개변수로 사용하는 메서드가 있는 Service 클래스를 만들겠습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```java\n@Slf4j\n@Service\npublic class JsonSchemaValidationService{\n\n  @Autowired\n  private JsonSchema jsonSchema;\n\n  public String validateJson(JsonNode jsonNode){\n\n    Set<ValidationMessage> errors = jsonSchema.validate(jsonNode);\n    //if errors have a single miss match, there would be a value in the errors set.\n    if(errors.isEmpty()){\n      //event is valid.\n      log.info(\"event is valid\");\n    }else{\n        //event is in_valid.\n      log.info(\"event is invalid\");\n     }\n      return errors.toString();\n  }\n}\n```\n\n## 6. Create a Rest Controller.\n\n```java\nimport com.fasterxml.jackson.databind.JsonNode;\n@RestController\npublic class JsonSchemaController {\n    @Autowired\n    private JsonSchemaValidationService service;\n\n    @PostMapping(\"/validate\")\n    public String validateEvent( @RequestBody JsonNode jsonNode ){\n       return service.validateJson(jsonNode);\n    }\n}\n```\n\n## 7. Start the SpringBoot Application and start sending requests.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 모든 것이 준비되었으니, 즐겨 사용하는 클라이언트를 사용하여 코드를 테스트할 수 있습니다. 저는 PostMan을 사용하고 있어요. 아래에서 유효한 이벤트로 시작해보겠습니다.\n\n```js\n# 유효한 데이터\ncurl --location 'localhost:8080/validate' \\\n--header 'Content-Type: application/json' \\\n--data '{\n  \"order_id\":\"order134\",\n   \"event\": \"PLACED\",\n   \"products\": [\n     {\n       \"product_id\": \"product_1\",\n        \"price\":20.5,\n       \"quantity\":2\n     }\n   ],\n   \"total_price\": 41\n}'\n```\n\n응답:\n\n```js\n[];\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n# order id 없는 페이로드\ncurl --location 'localhost:8080/validate' \\\n--header 'Content-Type: application/json' \\\n--data '{\n   \"event\": \"PLACED\",\n   \"products\": [\n     {\n       \"product_id\": \"product_1\",\n        \"price\":20.5,\n       \"quantity\":2\n     }\n   ],\n   \"total_price\": 41\n}'\n```\n\n응답 :\n\n```js\n[$.order_id: 필수 항목이지만 누락되었습니다]\n```\n\n```js\n# order id 없는 페이로드\ncurl --location 'localhost:8080/validate' \\\n--header 'Content-Type: application/json' \\\n--data '{\n\"order_id\":\"order134\",\n   \"event\": \"PLACED\",\n   \"total_price\": 41\n}'\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n[$.products: is missing but it is required]\n```\n\n```js\n# order id가 없는 payload\ncurl --location 'localhost:8080/validate' \\\n--header 'Content-Type: application/json' \\\n--data '{\n \"order_id\" : \"order_123\",\n   \"event\": \"PLACED\",\n   \"products\": [\n\n   ],\n   \"total_price\": 41\n}'\n```\n\n응답 :\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n[$.products: 배열에는 최소 1개의 항목이 있어야 합니다.]\n```\n\n<img src=\"/assets/img/2024-05-17-JSONSchemaValidatorusingJavaSpringBoot_1.png\" />\n","ogImage":{"url":"/assets/img/2024-05-17-JSONSchemaValidatorusingJavaSpringBoot_0.png"},"coverImage":"/assets/img/2024-05-17-JSONSchemaValidatorusingJavaSpringBoot_0.png","tag":["Tech"],"readingTime":8},{"title":"국영세대 ZGC로 일시 중지 시간을 제어하세요","description":"","date":"2024-05-17 17:41","slug":"2024-05-17-BendingpausetimestoyourwillwithGenerationalZGC","content":"\nZ Garbage Collector 세대의 놀라운 혜택과 그리 놀라운 혜택.\n\nDanny Thomas가 쓴 JVM 에코시스템 팀의 기사\n\n![GenerationalZGC](/assets/img/2024-05-17-BendingpausetimestoyourwillwithGenerationalZGC_0.png)\n\n최신 장기 지원 릴리스인 JDK는 Z Garbage Collector를 위한 세대 지원을 제공합니다. Netflix는 주요 이유로 동시 가비지 수집의 중요한 혜택을 인한 것으로, JDK 21 및 그 이후부터 G1에서 Generational ZGC로 기본 전환했습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저희 핵심 스트리밍 비디오 서비스 중 절반 이상이 Generational ZGC와 JDK 21에서 실행 중이에요. 이제 제 경험과 얻은 혜택에 대해 이야기할 때가 좋아졌네요. Netflix에서 Java를 어떻게 사용하는지 궁금하시다면, Paul Bakker의 강연인 'Netflix가 정말로 Java를 사용하는 방법'이 좋은 시작점이 될 거예요.\n\n# Tail Latency 감소\n\n저희 GRPC와 DGS 프레임워크 서비스에서 GC 일시 중단은 Tail Latency의 중요한 원인 중 하나에요. 특히 GRPC 클라이언트와 서버에서는 시간 초과로 인한 요청 취소가 재시도, 헤징 및 폴백과 같은 신뢰성 기능과 상호작용하죠. 이러한 에러마다 요청이 취소되어 재시도되는 것인데, 이런 감소로 인해 전체 서비스 트래픽이 더욱 줄어들었어요:\n\n![이미지](/assets/img/2024-05-17-BendingpausetimestoyourwillwithGenerationalZGC_1.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n잦은 일시 정지의 소음을 제거하면 실제 지연 원천을 식별할 수 있어서 그렇지 않으면 소음에 감춰져 있을 수 있습니다. 최대 일시 중지 시간 이상치는 상당히 중요할 수 있습니다:\n\n![image](/assets/img/2024-05-17-BendingpausetimestoyourwillwithGenerationalZGC_2.png)\n\n# 효율\n\n평가 결과가 매우 유망하게 나타난 후에도 ZGC의 채택을 교환할 것으로 예상했습니다: 스토어 및 로드 버리어, 스레드 로컬 핸드셰이크에서 수행되는 작업 및 응용프로그램 자원 경합으로 인한 GC로 인해 약간의 응용프로그램 처리량이 줄어드는 경우. 우리는 그것을 수용 가능한 교환이라고 생각했는데, 일시 정지를 피함으로써 그 부가적인 오버헤드보다 더 큰 이점을 제공했습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n사실 우리의 서비스와 아키텍처에 대해 조사한 결과, 그러한 교환이 없다는 것을 발견했습니다. 특정 CPU 활용 목표에 대해 ZGC는 G1과 비교했을 때 평균 및 P99 대기 시간을 개선하면서 CPU 활용률도 동등하거나 더 나아진다는 것을 알 수 있었습니다.\n\n우리가 관찰한 많은 서비스에서 요청률, 요청 패턴, 응답 시간 및 할당률의 일관성이 ZGC를 도와주지만, ZGC가 덜 일관된 워크로드를 처리하는 능력도 뛰어나다는 것을 확인했습니다 (물론 예외는 있습니다; 자세한 내용은 아래에서 다루겠습니다).\n\n# 운영의 간편함\n\n서비스 소유자들은 종종 너무 긴 일시 중지 시간에 대한 질문이나 튜닝 도움을 요청합니다. 우리는 주기적으로 많은 양의 힙 데이터를 새로 고치는 여러 프레임워크를 보유하고 있어서 외부 서비스 호출을 효율적으로 피하기 위해 이를 사용합니다. 힙 데이터의 주기적 갱신으로 G1을 깜짝놀라게 하는 이러한 작업은 기본 일시 중지 시간 목표를 크게 넘는 이상값에 이르게 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 Markdown 형식으로 테이블을 변환한 것입니다.\n\n| Feature                | Description                                                                                                                                                                         |\n| ---------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Generational ZGC       | Improved CPU utilization by nearly 10% compared to G1 for the same workload.                                                                                                        |\n| Hollow library         | Used by half of the streaming video services for on-heap metadata, which led to the removal of array pooling mitigations and saved hundreds of megabytes of memory for allocations. |\n| Operational simplicity | ZGC's heuristics and defaults require no explicit tuning to achieve optimal results. Allocation stalls are rare and shorter than with G1.                                           |\n| Memory overhead        | The long-lived on-heap data was the main reason we previously avoided non-generational ZGC, but generational ZGC helped improve the situation significantly.                        |\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n힙의 압축된 참조를 잃어버리기 때문에 64비트 객체 포인터가 필요한 색상 포인터 때문에 32G의 힙에서 압축된 참조를 잃어버리는 것이 가비지 콜렉터 선택의 주요 요소가 될 것으로 예상했습니다.\n\n우리는 그것이 스탑-더-월드 GC들에 대해 중요한 고려 사항이긴 하지만, 작은 힙에서라도 할당 속도의 증가가 효율성과 운영 개선에 의해 상쇄된다는 점을 발견했습니다. 오라클의 Erik Österlund씨에게 감사드립니다. 동시 가비지 콜렉터에 있어서 색상 포인터의 직관적이지 않은 이점을 설명해 준 덕분에 우리는 초기 계획보다 ZGC를 더 폭넓게 평가하게 되었습니다.\n\n대부분의 경우 ZGC는 응용 프로그램에 더 많은 메모리를 일관되게 제공할 수도 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nZGC는 힙 크기의 3%에 대한 고정 오버헤드가 있어 G1보다 더 많은 원시 메모리를 필요로 합니다. 몇 가지 예외를 제외하고는 더 많은 여유 공간을 위해 최대 힙 크기를 낮출 필요가 없었으며, 그것들은 평균 이상의 원시 메모리 요구가 있는 서비스들이었습니다.\n\n참조 처리는 또한 ZGC에서 주요 콜렉션 시에만 수행됩니다. 직접 바이트 버퍼의 할당 해제에 특히 주의를 기울였지만, 지금까지는 영향을 볼 수 없었습니다. 이 참조 처리의 차이로 JSON 쓰레드 덤프 지원에서 성능 문제가 발생했지만, 이것은 프레임워크가 실수로 각 요청마다 사용되지 않는 ExecutorService 인스턴스를 생성하여 발생한 특이한 상황입니다.\n\n# Transparent huge pages\n\nZGC를 사용하지 않더라도 거대 페이지를 사용해야 할 것입니다. 투명 거대 페이지가 그들을 사용하는 가장 편리한 방법입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nZGC는 힙에 대해 공유 메모리를 사용하며, 많은 Linux 배포판에서는 shmem_enabled를 'never'로 설정하여 -XX:+UseTransparentHugePages를 사용하는 경우 ZGC가 거대 페이지를 사용하지 못하게 만듭니다.\n\n이렇게 변경된 부분을 제외하고 아무런 변경 없이 배포된 서비스가 있습니다. shmem_enabled가 'never'에서 'advise'로 변경되면 CPU 사용률이 저하되었습니다.\n\n아래는 기본 구성입니다:\n\n![이미지](/assets/img/2024-05-17-BendingpausetimestoyourwillwithGenerationalZGC_4.png)\n\n저희의 기본 구성:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 힙의 최소 및 최대를 같은 크기로 설정합니다.\n- -XX:+UseTransparentHugePages -XX:+AlwaysPreTouch을 구성합니다.\n- 다음과 같은 transparent_hugepage 구성을 사용합니다:\n\n```js\necho madvise | sudo tee /sys/kernel/mm/transparent_hugepage/enabled\necho advise | sudo tee /sys/kernel/mm/transparent_hugepage/shmem_enabled\necho defer | sudo tee /sys/kernel/mm/transparent_hugepage/defrag\necho 1 | sudo tee /sys/kernel/mm/transparent_hugepage/khugepaged/defrag\n```\n\n# 어떤 워크로드가 적합하지 않았나요?\n\n가장 좋은 가비지 컬렉터는 없습니다. 각각은 가비지 컬렉터의 목표에 따라 콜렉션 처리량, 응용프로그램 대기 시간 및 자원 이용을 교환합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nG1 대비 ZGC에서 더 나은 성능을 보인 작업 부하들은 대부분 처리량을 중심으로 한 경향이 있습니다. 매우 변덕스러운 할당 속도와 예측할 수 없는 기간 동안 객체를 보유하는 장기 실행 작업들이 포함되어 있습니다.\n\n한 가지 주목할만한 예시는 매우 변덕스러운 할당 속도와 많은 수의 고수명 객체를 가진 서비스였는데, 이는 G1의 일시 중지 시간 목표와 오래된 영역 수집 휴리스틱에 특히 적합했습니다. G1이 ZGC가 처리하지 못한 GC 사이클의 비생산적인 작업을 피할 수 있게 해주었습니다.\n\n기본적으로 ZGC로 전환함으로써 응용프로그램 소유자들이 가비지 수집기의 선택에 대해 고민할 수 있는 좋은 기회가 제공되었습니다. G1을 기본으로 사용하던 여러 배치/준비 계산 사례들이 병렬 수집기로부터 더 나은 처리량을 얻었을 것입니다. 대규모 준비 계산 작업에서는 G1 대비 응용프로그램 처리량이 6~8% 향상되어 배치 시간이 한 시간 단축되는 것을 확인할 수 있었습니다.\n\n# 직접 해보세요!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n가정과 기대를 의심하지 않으면, 우리는 10년 동안 우리의 운영 기본 설정 중 가장 영향력 있는 변화 중 하나를 놓치게 될 수 있습니다. 우리는 여러분께 직접 제너레이셔널 ZGC를 시도해 보라고 권장합니다. 여러분에게 우리가 놀란 만큼 놀라운 경험을 줄 수도 있습니다.\n","ogImage":{"url":"/assets/img/2024-05-17-BendingpausetimestoyourwillwithGenerationalZGC_0.png"},"coverImage":"/assets/img/2024-05-17-BendingpausetimestoyourwillwithGenerationalZGC_0.png","tag":["Tech"],"readingTime":9}],"page":"119","totalPageCount":119,"totalPageGroupCount":6,"lastPageGroup":19,"currentPageGroup":5},"__N_SSG":true}