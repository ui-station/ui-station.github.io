{"pageProps":{"posts":[{"title":"맥OS에서 여러 JDK를 설치하고 전환하는 방법","description":"","date":"2024-05-23 15:17","slug":"2024-05-23-InstallingswitchingbetweenmultipleJDKonmacOS","content":"\n![JDK installation on macOS](/assets/img/2024-05-23-InstallingswitchingbetweenmultipleJDKonmacOS_0.png)\n\n모든 운영 체제에는 macOS를 포함한 사전 설치된 JDK가 없습니다. 이 게시물에서는 macOS에 여러 JDK를 수동으로 설치하고 관리하는 방법을 살펴보겠습니다.\n\nmacOS에서 소프트웨어를 설치하는 잘 알려진 과정은 앱 아이콘을 클릭하거나 앱 아이콘을 Applications 폴더로 끌어다 놓는 것입니다. 이는 모든 설치 세부 정보를 멋진 앱 아이콘과 진행중인 바 아래에 숨깁니다.\n\n그러나 우리 개발자들은 로그를 보고 명령줄 도구를 사용하는 것을 좋아합니다. 이를 위해 Linux 배포판은 yum이나 apt-get과 같은 패키지 관리자를 사용합니다. 그러나 모든 것이 Apple로 이어지듯이 가장 일반적인 무료 소프트웨어는 macOS에서 작동하지 않습니다. 여기서 HomeBrew가 구원의 역할을 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# HomeBrew\n\n도구의 홈페이지에 따르면,\n\n```js\nmacOS를 위한 누락 된 패키지 관리자입니다.\nHomebrew는 macOS에 포함되지 않은 UNIX 도구를 설치하는 가장 쉽고 유연한 방법입니다.\n```\n\nHomebrew를 사용하면 명령 줄을 통해 소프트웨어를 설치 할 수 있으며 로그에서 많은 설치 정보를 볼 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# Homebrew 설치하기\n\n맥OS에 Homebrew를 설치하려면 맥OS의 Terminal 또는 iTerm 애플리케이션을 열고 아래 명령어를 실행하세요.\n\n```js\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n```\n\n이 작업이 완료되면 homebrew를 사용하여 사용 가능한 formulae 또는 cask를 한 줄로 설치할 수 있습니다. `brew install xxxx` 또는 `brew install --cask xxxx`와 같은 명령을 사용하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 다양한 JDK 버전 설치하기\n\n먼저, Homebrew를 사용하여 사용 가능한 Java 버전을 찾아보겠습니다. 다음 명령어를 사용해주세요.\n\n```bash\nbrew search --formulae java\n```\n\n아래에서 확인할 수 있듯이, java11과 java만 사용 가능합니다.\n\n![이미지](/assets/img/2024-05-23-InstallingswitchingbetweenmultipleJDKonmacOS_1.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n더 오래된 버전을 원하시면, openjdk.java 및 java11을 openjdk 및 openjdk@11의 별명으로 사용하여 검색할 수 있습니다.\n\n![이미지](/assets/img/2024-05-23-InstallingswitchingbetweenmultipleJDKonmacOS_2.png)\n\n이제 우리가 공식 이름을 알았으니, 하나의 명령어로 서로 다른 JDK를 설치할 수 있습니다. 최신 버전 및 java11을 설치해 보겠습니다.\n\n터미널 또는 iTerm에 다음 2개의 명령어를 차례대로 실행해 주세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nbrew install openjdk\nbrew install openjdk@11\n```\n\n# 일부 수동 설정\n\n이제 우리 Mac에는 자바 17과 자바 11이 모두 설치되어 있습니다.\nMac 프로그램에서 어떤 것을 사용할지 확인해 보겠습니다.\n\n- 어떤 기기에서든 현재 자바 버전을 확인하는 가장 쉬운 방법은\n  java -version을 사용하는 것입니다.\n- macOS에 설치된 모든 자바 버전을 확인할 수도 있습니다. java_home /usr/libexec/java_home -V를 사용하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그러나 위 2개의 명령어를 시도하면 다음 출력이 나옵니다.\n\n<img src=\"/assets/img/2024-05-23-InstallingswitchingbetweenmultipleJDKonmacOS_3.png\" />\n\n어떤 이유에서인지 macOS는 Homebrew로 설치한 Java를 감지하지 못합니다. 이것은 Homebrew를 사용하여 패키지를 설치할 때 매번 나타나는 문제입니다.\n\n- 패키지를 패키지 자체 디렉토리에 설치합니다.\n  M1-Mac의 경우 /opt/homebrew/Cellar에\n  Intel Mac의 경우 /usr/local/Cellar에\n- /opt/homebrew/opt 아래에 심볼릭 링크도 생성합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-05-23-InstallingswitchingbetweenmultipleJDKonmacOS_4.png\" />\n\n하지만 \\*nix 시스템은 /usr/bin/java, /usr/lib/jvm 및 /usr/local/bin/java에서 Java를 찾습니다. Apple의 모든 것들과 마찬가지로 macOS는 다릅니다. Java를 /Library/Java/JavaVirtualMachines/에서 찾습니다.\n\n이러한 JDK 설치법은 /Library/Java/JavaVirtualMachines/ 폴더 아래 필요한 softlink를 설정할 수 있었을 것입니다. 그러나 디자인상 이러한 JDK 설치법은 keg-only로 유지됩니다.\n\n<img src=\"/assets/img/2024-05-23-InstallingswitchingbetweenmultipleJDKonmacOS_5.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 정보는 설치 로그에도 있습니다.\n\n![이미지](/assets/img/2024-05-23-InstallingswitchingbetweenmultipleJDKonmacOS_6.png)\n\n따라서 Mac 프로그램에서 설치된 Java를 감지하려면 해당 폴더에 몇 가지 소프트 링크를 만들어야 합니다. 설치 로그에 제공된 명령을 그대로 복사하여 붙여넣으십시오.\n\n![이미지](/assets/img/2024-05-23-InstallingswitchingbetweenmultipleJDKonmacOS_7.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 섹션의 시작 부분에서 실패한 명령을 실행하려고 하면 아래와 같은 출력이 나타납니다.\n\n<img src=\"/assets/img/2024-05-23-InstallingswitchingbetweenmultipleJDKonmacOS_8.png\" />\n\n이제 macOS에서 감지된 2개의 JDK를 설치했으므로 두 가지 간을 빠르게 전환하는 방법을 살펴보겠습니다.\n\nJava의 버전을 한 가지만 설치하는 경우에는 이미 끝났습니다. 그러나 Mac에 여러 가지 다른 버전의 Java를 설치하고자 하는 경우 위의 단계대로 각각 설치하고 아래 단계에 따라 그 사이를 전환할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# JDK 전환하기 (JAVA_HOME 및 java_home)\n\nJAVA_HOME은 Java 프로그램이 Java 위치를 선택하도록 하는 환경 변수입니다. 따라서 다양한 Java 버전 간에 전환하려면 JAVA_HOME 값을 다른 위치로 변경해야 합니다.\n\n또한 /usr/libexec/java_home 유틸리티가 있습니다. 이를 사용하여 다양한 버전 간에 전환합니다.\n\n우리의 설치에서는 다음과 같이 매개 변수 -v (소문자 v)가 우리에게 제공하는 내용입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n`\n![이미지](/assets/img/2024-05-23-InstallingswitchingbetweenmultipleJDKonmacOS_9.png)\n\n- 이 명령어의 출력을 활용하여 JAVA_HOME을 아래와 같이 설정할 수 있습니다.\n  export JAVA_HOME=`/usr/libexec/java_home -v 17`\n- 그러나 명령어를 입력하는 것이 조금 길 수 있습니다. 그래서 전체 명령어를 대체할 수 있는 한 단어의 별칭을 만들어 보겠습니다.\n  alias java-17=”export JAVA_HOME=`/usr/libexec/java_home -v 17`”\n- 또한, 새 터미널을 열 때마다 이러한 별칭이 사용 가능하도록 해야 합니다. 이를 위해 ~/.zshrc 파일에 추가해야 합니다. ~/.zshrc 파일에 다음과 같이 2개의 별칭을 추가하세요. ~/.zshrc 파일이 존재하지 않는 경우, 파일을 생성하세요.\n\n```js\nalias java-17=”export JAVA_HOME=`/usr/libexec/java_home -v 17`; java -version”\nalias java-11=”export JAVA_HOME=`/usr/libexec/java_home -v 11`; java -version”\n```\n\n모두 완료되었습니다.\n원하는 때마다 터미널이나 iTerm에서 java-11 또는 java-17을 입력하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/assets/img/2024-05-23-InstallingswitchingbetweenmultipleJDKonmacOS_10.png)\n\n# TL;DR (명령어 간단 요약)\n\n설명이 아닌 단계만 원하는 분들을 위해 간단한 단계를 안내합니다.\n\n- 시스템에 Homebrew가 없는 경우 Homebrew를 설치하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n```\n\n- Homebrew 및 openjdk를 사용하여 필요한 만큼 JDK를 설치하세요.\n\n```js\nbrew install openjdk@XX\n```\n\n- MAC에서 JDK에 액세스할 수 있도록 하려면, 소프트 링크나 실제 폴더를 /Library/Java/JavaVirtualMachines/에 추가하세요. 소프트 링크를 사용하려면 아래 명령어를 사용하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n$ sudo ln -sfn /opt/homebrew/opt/openjdkXXX/libexec/openjdkXXX.jdk /Library/Java/JavaVirtualMachines/openjdkXXX.jdk\n\n- Add one more alias under `~/.zshrc` to quickly switch between JDK\n\nalias java-XX=\"export JAVA_HOME=\\`/usr/libexec/java_home -v XX\\`; java -version\"\n","ogImage":{"url":"/assets/img/2024-05-23-InstallingswitchingbetweenmultipleJDKonmacOS_0.png"},"coverImage":"/assets/img/2024-05-23-InstallingswitchingbetweenmultipleJDKonmacOS_0.png","tag":["Tech"],"readingTime":9},{"title":"나의 새로운 M1 Mac을 위해 계획한 것","description":"","date":"2024-05-23 15:15","slug":"2024-05-23-WhatIHavePlannedforMyNewM3Macs","content":"\n![이미지](/assets/img/2024-05-23-WhatIHavePlannedforMyNewM3Macs_0.png)\n\n새로운 맥 주간이에요!\n\n새로운 M3 맥이 판매가 그리 좋지 않다는 제안에도 불구하고(대부분의 모델의 배송 예상일이 11월로 남아 있는 순수한 기반으로), 여러분 중 많은 분들이 이번 주에 문을 노크하는 걸 열심히 기다리고 계실 것 같아요.\n\n저는 두 대의 M3-탑재 맥을 기다리고 있어요. 첫 번째로는 현재 사용하지 않고 부끄럽게도 M1 버전을 대체할 M3 24인치 iMac 기본 모델이고 두 번째로는 M1 Max 16인치 MacBook Pro를 중고 시장으로 돌리게 될 M3 Max 14인치 MacBook Pro에요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저는 이 두 대의 기계에 대한 계획을 가지고 있어요. 물론, 이들을 개봉하는 즉시 떠오르는 즉시 테스트가 있어요. 기대가 되는 결과를 빨리 볼 수 있을 테니까 말이에요. 또한, 제 기본적인 테스트가 여러분이 M3 플랫폼으로 업그레이드를 고려할 수 있도록 도와줄 것을 희망하고 있어요.\n\n제가 설명해 드릴게요.\n\n## 내 M3 iMac 테스트\n\n특정한 맥으로 선정한 정책이 있어요. 베이스 모델 버전만 구매한다는 거죠.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n맥북 에어는 그중 하나입니다. 내 의심은 굉장히 매력적이지만 상당히 비싼 컴퓨터들이기 때문에 많은 사람들이 그냥 제일 싼 것을 선택하는 것 같다는 점입니다. 그래서 나에게는 바로 기본 모델 구매자들이 돈을 주고 무슨 성능을 얻는지 정확히 알아보는 것이 내 임무인 것 같습니다.\n\n나는 2021년에 24인치 iMac 리프레시에 대해 동일한 방식을 취했습니다. M1의 기본 구성을 넘어서지 않고, 첫 번째 옵션을 가방에 넣어 체크아웃을 했습니다. 그렇게 해서 나는 8GB의 통합 메모리, 7코어 GPU 및 256GB의 SSD 저장 공간을 갖춘 맥을 얻게 되었습니다. 그 확인된 M1 머신들과 마찬가지로, 그 돈에 걸맞는 성능을 발휘하여 즉시 인기를 끈 컴퓨터가 되었습니다.\n\n따라서 그 후속 모델은 상당히 성능을 유지해야 할 것이고, 나는 그것을 구매하는 방식이 이전과 동일했습니다. 이번에는 그래픽 코어 수의 한자리 숫자 증가 및 M1에서 M3로의 전환이 유일한 차이점입니다.\n\n문제는 다년간 애플의 올인원 제품에 대한 업데이트가 없었던 900일 이상을 거쳐 M2 칩이 거부당했고 완전히 손대지 않은 채로 진열대에 방치된 이 기계에 대해 얼마나 큰 발전을 이뤘는지입니다. 기억해야 할 점은 이 기계가 M2칩을 거부당하고 완전히 소홀히 처리되었다고 여겨진 기계라는 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리가 온만큼 멀리 왔을까요?\n\n내 시험은 여느 때처럼 간단하고 대충한 테스트일 것입니다. 나는 내 Sony FX3 카메라로 10분짜리 4K 영상을 촬영하고, Final Cut Pro에 넣어 부드러운 컬러 그레이드를 주고, 두 가지 루틴을 수행할 것입니다 - 렌더링과 익스포트. 이 작업은 M1 iMac에서, M3 iMac에서, 그리고 내 예전 27인치 인텔 기반 iMac에서 수행할 것입니다.\n\n기본 모델인 M3 iMac이 앞세대 제품들보다 얼마나 빠를지 궁금합니다. 정말로 기대되네요 (비디오를 놓치지 않으려면 제 유튜브 채널을 구독하기를 잊지 마세요)!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 내 M3 Max MacBook Pro 테스트\n\n나는 내 M3 14인치 MacBook Pro 주문을 잘못한 것 같아.\n\n애플의 '무서운 속도' 이벤트를 지난 달 졸지에 커버하면서 새로운 프로덕션 랩탑을 사양을 빨리 정하고 주문해야 했어. 불행히도 이 일은 늦은 일이었고(이벤트가 영국 시간으로 자정에 방영되었음), 내 머리를 충분히 쓰지 않았던 것 같아.\n\n내가 현재 문이 오는 사양(그러나 Apple 주문 추적기에 따르면 현재 \"지연\"되었음)은 M3 Max 칩을 완전히 최대로 활성화하여 16코어 CPU와 40코어 GPU, 2TB의 SSD 저장 공간, 그리고 48GB의 통합 메모리를 포함하고 있어.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n제가 실수한 부분은 후자와 관련이 있다고 생각합니다. 추가 200 파운드를 더 지불하면 사랑스러운 Space Black 노트북을 64GB의 통합 메모리로 구성할 수 있었을 텐데요. 이미 이 새로운 기계에 4,000 파운드 이상을 들였기 때문에 그것은 이제 무난한 선택처럼 느껴집니다. 결국 이건 이제 목돈이니까요.\n\n그래서 곧 도착하는 구성을 반품하고 64GB 버전을 다시 주문할 가능성이 매우 높습니다. 교훈을 얻었네요. 하지만 Apple의 관대한 반품 정책을 활용해서 그 사랑스러운 Space Black 색상을 조심스럽게 개봉하고 빠른 Mark Ellis Reviews 테스트를 해볼 거에요.\n\n이 테스트는 iMac의 것보다 더 복잡하지 않을 것이지만 결과는 마땅히 빛날 것입니다. 이전에 언급한 대로, 내가 콘텐츠 크리에이터이자 Apple 제품에 대해 다루는 일을 하는 사람이 아니었다면 이 새로운 MacBook Pro를 살 일은 없었을 테니까요 — 내 M1 Max 16인치 MacBook Pro는 여전히 절대적인 성능을 보여주고 있습니다.\n\n그렇다면 이 굉장히 중요한 질문이 생깁니다: M1 Max에서 M3 Max로 전환했을 때 어떤 이득을 얻을 수 있을까요? 이 방대한 비용을 정당화할 만한 가치가 있는지에 대한 의견은 무엇인가요? 일반적으로 최신 Apple 실리콘 패밀리의 Max 버전은 최근 두 세대에서 가장 놀라운 진보를 보여주고 있다는 평이 있습니다. 실제로 일상에서 어떤 변화가 있는지 확인해보고 싶습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그래서, 이 두 대의 머신 사이에서 똑같은 Final Cut Pro 테스트를 할 거에요. 렌더링 및 내보내기 과정에서 몇 초(아니면 분?!)를 단축할 수 있을까요? 비디오 편집자는 여러분께 말씀드립니다. 프로젝트를 빠르게 완료할 수 있는 속도가 여러분의 생계에 달려 있다면, 그 몇 초가 의미심장하다는 것을요. 우리 모두가 애플에게 가장 궁금한 점은 이 하드웨어에 상당한 투자를 한 만큼, 우리가 그 몇 초를 얻게 되는지입니다.\n\n솔직히 이 맥북 프로는 매우 비싼 머신들이라는 사실을 인정해야 합니다.\n\n## 마무리\n\n내 테스트가 주로 비디오 제작에 중점을 두고 있다는 것과 새로운 맥을 위한 모든 사람들의 사용 사례가 아니라는 것을 알고 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그러므로 시각 콘텐츠를 다루지 않는 경우, 내 시험 결과는 다소 주의해서 받아들여야 할 것 같아요. 다행히도 다른 리뷰어들로부터 더 심층적인 테스트가 다음 몇 주 동안 등장할 예정이며, 그들이 무엇을 발견했는지 — 이것이 M3 세대에 어떤 의미를 갖는지 기대되네요.\n\n하지만 이제는 당신에게 차례입니다 — 어떤 M3 Mac이 당신의 쇼핑 목록에 있는지, 그리고 당신은 그것을 어떻게 활용할 계획인가요? 아래에서 참여해주세요!\n\n## 떠나기 전에\n\n기술 콘텐츠 제작자의 주간 비하인드 더 시즌 비디오를 보기 위해 내 뉴스레터 목록에 가입하세요!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nhttps://markellisreviews.com에서 2023년 11월 7일에 원래 발행되었습니다.\n","ogImage":{"url":"/assets/img/2024-05-23-WhatIHavePlannedforMyNewM3Macs_0.png"},"coverImage":"/assets/img/2024-05-23-WhatIHavePlannedforMyNewM3Macs_0.png","tag":["Tech"],"readingTime":6},{"title":"스위프트로 터미널 프로그램 실행하기","description":"","date":"2024-05-23 15:14","slug":"2024-05-23-RunningTerminalProgramsfromSwift","content":"\n스위프트와 명령 줄을 통합하면 개발자가 스위프트 애플리케이션 내에서 쉘 명령어의 기능을 활용할 수 있습니다. 이 기능은 주로 작업 자동화, 스크립트 실행 또는 시스템 수준 기능에 직접 액세스하는 데 유용합니다. 이 기사에서는 실용적인 예제를 사용하여 스위프트에서 터미널 프로그램을 실행하는 방법을 살펴보겠습니다.\n\n# 종속성 가져오기\n\n프로세스 실행에는 Foundation 라이브러리가 필요합니다.\n\n```js\nimport Foundation\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nFoundation 라이브러리는 애플의 개발 생태계의 핵심 부분으로, 필수적인 데이터 유형, 컬렉션 및 운영 체제 서비스를 제공하여 날짜, 시간 및 프로세스와 같은 작업을 관리합니다. Foundation을 사용하여 프로세스를 실행하면 시스템의 명령 줄과 상호 작용하기 위한 강력하고 테스트된 API를 활용할 수 있습니다.\n\n# 프로세스 실행\n\nSwift에서 터미널 애플리케이션을 실행하는 것은 본질적으로 직접 프로그램을 실행하는 대신 zsh와 같은 쉘에서 명령 줄 프로그램을 실행해야 한다는 것을 의미합니다.\n\n따라서 다른 프로그램을 실행하도록 지시하는 /bin/zsh를 실행해야 합니다. 여러분은 bash 스크립트에서처럼 유사한 개념인 #!/bin/bash를 알고 있을 수 있습니다. 이는 “bash를 사용하여 이 프로그램을 실행”을 의미합니다. 이는 터미널과 상호 작용하는 이진 프로그램에 대한 비슷한 개념입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n본질적으로, 우리는 환경 변수를 전달하여 터미널 프로그램을 실행하도록 Swift에 지시할 것입니다 (예: PATH=/usr/bin, 실행 쉘(예: /bin/zsh), 그리고 실행할 프로그램 및 옵션을 포함한 내용(예: ls ~)):\n\n![Running Terminal Programs from Swift](/assets/img/2024-05-23-RunningTerminalProgramsfromSwift_0.png)\n\n## 1. 프로세스 설정하기\n\n우선, Process의 인스턴스를 생성합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nlet process = Process();\n```\n\nShell 명령어의 실행은 Process 인스턴스에서 처리되며, 출력과 에러 스트림은 Pipe 인스턴스가 캡처합니다.\n\n## 2. Process 구성\n\n다음으로, 인수와 사용할 쉘을 정의합니다. 우리는 zsh 쉘에 명령을 실행하도록 지시할 것이므로, 프로세스의 launchPath를 /bin/zsh로 설정하고 프로그램 및 인수를 쉘의 인수로 -c `프로그램 및 인수`를 전달할 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nlet command = \"ls ~\";\nprocess.launchPath = \"/bin/zsh\"; // 또는 \"/bin/bash\" 당신의 셸에 따라 다름\nprocess.arguments = [\"-c\", command];\n```\n\n-c 인자는 쉘이 명령어 문자열을 실행하도록 지시합니다. command는 예를 들어 ls ~나 echo \"Hello world\"와 같은 표준 프로그램 실행을 나타내는 문자열일 수 있습니다.\n\n일부 프로그램은 MacOS의 보안 제약으로 인해 실행할 수 없습니다. 예를 들어, Swift 프로그램에서 /bin/ps를 실행할 수 없는 이유는 특정 보안 제약을 위반하기 때문입니다.\n\n많은 프로그램은 환경 변수가 설정되어야 합니다. 예를 들어, 프로그램이 다른 프로그램을 찾기 위해 PATH 환경 변수에 의존하는 것이 일반적입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n테이블 태그를 Markdown 형식으로 변경해주세요.\n\n```js\nlet environment = [\n  \"TERM\": \"xterm\",\n  \"HOME\": \"/Users/example-user/\",\n  \"PATH\": \"/opt/homebrew/bin:/opt/homebrew/sbin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin\"\n]\nprocess.environment = environment\n```\n\n터미널에서 env를 실행하여 시스템 환경 변수를 실행 중에 확인할 수 있습니다.\n\n<img src=\"/assets/img/2024-05-23-RunningTerminalProgramsfromSwift_1.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 3. 프로세스 실행하기\n\n그런 다음 macOS 버전을 확인하여 Foundation 라이브러리와의 호환성을 보장한 후 프로세스를 실행합니다:\n\n```js\nif #available(macOS 13.0, *) {\n    try! process.run()\n} else {\n    process.launch()\n}\n```\n\nmacOS 13용 Foundation에서는 응용 프로그램 실행 중 예기치 않은 오류가 발생하면 오류를 throw하는 기능이 도입되었고 .launch() 메서드는 사용이 중단되었습니다. 이러한 이유로 macOS 버전이 13 이상인지 테스트하고 .run() 메서드를 시도하고 이전 버전의 경우 .launch() 메서드로 넘어갈 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n에러를 잡아내는 것은 사용자나 개발자가 앱이 올바르게 작동하지 않음을 알 수 있는 가장 좋은 방법입니다.\n\n# 출력 및 에러 잡기\n\n출력을 잡기 위해서는 Pipe를 만들고, 이를 프로세스의 출력에 연결해야 합니다.\n\n```js\nlet pipe = Pipe();\nprocess.standardOutput = pipe;\nprocess.standardError = pipe;\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n프로세스가 완료되면, pipe는 프로세스 응답을 바이너리 배열로 수집할 것입니다. 대부분의 터미널 출력은 사람이 읽을 수 있는 텍스트이므로 UTF-8로 인코딩된 문자열로 변환할 수 있습니다:\n\n```js\nlet data = pipe.fileHandleForReading.readDataToEndOfFile()\nlet output = String(data: data, encoding: .utf8) ?? \"\"\n```\n\n## 모두 함께 넣기\n\n이러한 개념들을 결합하여, 터미널 명령을 실행하고 결과를 반환하는 함수를 만들 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```swift\nfunc executeProcessAndReturnResult(_ command: String) -> String {\n  let process = Process()\n  let pipe = Pipe()\n  let environment = [\n    \"TERM\": \"xterm\",\n    \"HOME\": \"/Users/example-user/\",\n    \"PATH\": \"/opt/homebrew/bin:/opt/homebrew/sbin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin\"\n  ]\n  process.standardOutput = pipe\n  process.standardError = pipe\n  process.environment = environment\n  process.launchPath = \"/bin/zsh\"\n  process.arguments = [\"-c\", command]\n  if #available(macOS 13.0, *) {\n    try! process.run()\n  } else {\n    process.launch()\n  }\n  let data = pipe.fileHandleForReading.readDataToEndOfFile()\n  let output = String(data: data, encoding: .utf8) ?? \"\"\n  return output\n}\n```\n\n따라서 다른 프로그램에서 이러한 함수를 호출할 수 있습니다. 예를 들어 사용자의 홈 폴더에있는 폴더를 나열하는 프로그램에서 ls ~을 사용하여 호출할 수 있습니다:\n\n```swift\nlet response = executeProcessAndReturnResult(\"ls ~\")\nprint(response)\n// Desktop Documents Downloads Library Movies Pictures Public\n```\n\n# 데몬 프로세스 시작하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n긴 시간이 걸리는 프로세스, 예를 들어 데몬(daemon) 같은 것을 시작하고 주 스레드와 바인딩을 해제하려면, 프로세스를 실행하기 전에 \"불확정 상태\"로 설정합니다:\n\n```js\n// ... let process = Process()\nprocess.unbind(.isIndeterminate)\n// ... process.run()\n```\n\n이렇게 하면 프로세스가 독립적으로 계속 실행되지만, 앱에서 출력을 캡처하는 것이 더 어려워집니다.\n\n이러한 개념을 결합하여 터미널 명령어를 실행하고 출력을 반환하는 함수를 만들 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```swift\nfunc executeDaemonProcess(_ command: String) -> String {\n  let process = Process()\n  process.environment = environment\n  process.launchPath = \"/bin/zsh\"\n  process.arguments = [\"-c\", command]\n  process.qualityOfService = .background\n  if #available(macOS 13.0, *) {\n    try! process.run()\n  } else {\n    process.launch()\n  }\n}\n```\n\n그래서 백그라운드에서 실행되는 이러한 함수를 호출할 수 있습니다. 예를 들어 ~/Public 폴더에서 파일을 제공하는 Python HTTP 서버를 시작할 수 있습니다.\n\n```swift\nexecuteDaemonProcess(\"/usr/bin/python3 -m http.server -d ~/Public\")\n```\n\n이 프로세스를 실행하면 ~/Public 폴더에서 파일을 제공하는 http://localhost:8080의 웹 서버가 생성됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 결론\n\nProcess 클래스를 사용하여 Swift 프로젝트에서 셸 명령 실행을 원활하게 통합할 수 있습니다. 이 기술을 사용하면 Swift 프로젝트 내에서 커맨드 라인 프로그램 및 RPC의 프론트 엔드를 만들거나 자동화 및 시스템 수준 스크립팅을 수행하는 다양한 가능성이 열립니다.\n\n실제 구현에서는 강제 언래핑을 사용하고 모든 잠재적인 오류 및 예외 상황을 처리해야 함을 기억하세요. 위 예제는 모든 실패 시나리오를 처리하지 않으므로 주의해야 합니다.\n","ogImage":{"url":"/assets/img/2024-05-23-RunningTerminalProgramsfromSwift_0.png"},"coverImage":"/assets/img/2024-05-23-RunningTerminalProgramsfromSwift_0.png","tag":["Tech"],"readingTime":9},{"title":"tmux 초보자를 위한 가이드","description":"","date":"2024-05-23 15:12","slug":"2024-05-23-ABeginnersGuidetotmux","content":"\n<img src=\"/assets/img/2024-05-23-ABeginnersGuidetotmux_0.png\" />\n\n<img src=\"/assets/img/2024-05-23-ABeginnersGuidetotmux_1.png\" />\n\n```js\n이 기사에서는:\n- tmux 설치\n- tmux 시작하기\n- 기본 tmux 단축키\n- 마우스 사용하기\n- tmux 구성\n- 상태 표시줄 사용자 정의\n- 다음 단계\n```\n\nTmux는 터미널 멀티플렉서로, 하나의 터미널에서 여러 \"가상 터미널\"을 생성할 수 있습니다. 이는 단일 연결로 여러 프로그램을 실행할 때 매우 유용합니다. 특히 SSH를 사용하여 원격으로 컴퓨터에 연결할 때 유용합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nTmux은 또한 프로그램을 주요 터미널에서 분리하여 우연한 연결 해제로부터 보호합니다. 현재 터미널에서 tmux를 분리할 수 있으며, 모든 프로그램이 안전하게 백그라운드에서 실행되어 계속됩니다. 나중에는 동일한 또는 다른 터미널에 tmux를 다시 연결할 수 있습니다.\n\n원격 연결의 이점 외에도 tmux의 속도와 유연성으로 인해 로컬 장치에서 여러 터미널을 관리하기 위한 훌륭한 도구로 사용할 수 있습니다. 저는 내 노트북에서 8년 이상 tmux를 사용해왔습니다. 제 생산성을 높이고 도와주는 tmux의 몇 가지 기능은 다음과 같습니다:\n\n- 완전히 사용자 지정 가능한 상태 표시줄\n- 여러 창 관리\n- 여러 패널로 창 분할\n- 자동 레이아웃\n- 패널 동기화\n- 사용자 정의 tmux 세션 만들기가 가능한 스크립팅 기능\n\n다음은 사용자 지정 tmux 세션의 예시입니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![tmux](/assets/img/2024-05-23-ABeginnersGuidetotmux_2.png)\n\nTmux은 Screen에서 발견되는 일부 기능과 동일한 기능을 제공하며 일부 Linux 배포판에서는 더 이상 사용되지 않습니다. Tmux는 Screen보다 더 현대적인 코드 베이스를 갖추었으며 추가적인 사용자 정의 기능을 제공합니다.\n\n이제 몇 가지 tmux의 이점을 알았으니, 설치 및 사용 방법을 보여드리겠습니다.\n\n# tmux 설치\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n티먹스는 Fedora 및 Red Hat Enterprise Linux (RHEL) 표준 저장소에서 RHEL 8부터 사용할 수 있습니다. 다음 명령어로 설치할 수 있어요.\n\n```js\n$ sudo dnf -y install tmux\n```\n\n다른 많은 리눅스 배포판에서도 사용할 수 있으며, 선호하는 배포판 패키지 관리자를 사용하여 설치할 수 있을 거에요. 다른 운영 체제의 경우, tmux 설치 가이드를 참고하세요.\n\n# 티먹스 시작하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\ntmux를 사용하려면 터미널에 tmux를 입력하세요. 이 명령은 tmux 서버를 시작하고 기본 세션(번호 0)과 하나의 창을 생성한 후 해당 세션에 연결합니다.\n\n```js\n$ tmux\n```\n\n<img src=\"/assets/img/2024-05-23-ABeginnersGuidetotmux_3.png\" />\n\ntmux에 연결되었으므로 일반적으로 명령이나 프로그램을 실행할 수 있습니다. 예를 들어, 긴 시간이 걸리는 프로세스를 시뮬레이션하려면:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n$ c=1\n\n$ while true; do echo \"Hello $c\"; let c=c+1; sleep 1; done\nHello 1\nHello 2\nHello 3\n```\n\nTmux 세션에서 분리하려면 Ctrl+B를 누르고 D를 누르세요. Tmux는 \"접두사\" 조합을 눌러 트리거되는 일련의 키 바인딩(키보드 단축키)를 사용하여 작동합니다. 기본적으로 \"접두사\"는 Ctrl+B입니다. 그 다음에 현재 세션에서 분리하려면 D를 누르세요.\n\n```js\n[session 0에서 분리됨]\n```\n\n더 이상 세션에 연결되어 있지 않지만 오랫동안 실행되는 명령이 안전하게 백그라운드에서 실행됩니다. 활성 tmux 세션을 tmux ls로 나열할 수 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```plaintext\n$ tmux ls\n\n0: 1개의 창 (2022년 8월 27일 토요일 생성)\n```\n\n여기서 SSH 연결을 해제할 수 있고 명령은 계속 실행됩니다. 준비가 되면 서버에 다시 연결하여 기존 tmux 세션에 다시 연결하여 이전에 중단한 곳에서 계속할 수 있습니다:\n\n```plaintext\n$ tmux attach -t 0\n안녕 72\n안녕 73\n안녕 74\n안녕 75\n안녕 76\n^C\n```\n\n메시지가 계속 출력되는 것을 확인할 수 있습니다. 취소하려면 Ctrl+C를 입력하실 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n모든 tmux 명령어는 약어로도 사용할 수 있습니다. 예를 들어, tmux attach 대신에 tmux a를 입력해도 작동합니다.\n\n이 기능 자체만으로도 tmux는 훌륭한 도구입니다. 더욱이 기본 키바인딩을 포함하여 더 많은 기능을 제공합니다.\n\n# 기본 tmux 키바인딩\n\nTmux는 tmux 세션에서 빠르게 명령어를 실행할 수 있게 해주는 여러 키바인딩을 제공합니다. 가장 유용한 몇 가지를 소개합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n별도의 tmux 세션을 생성하려면 이미 tmux 세션에 들어가 있지 않은 경우 새로운 tmux 세션을 생성하세요. 새 세션을 만들 때 tmux new 명령을 사용하고 -s '이름' 매개변수를 전달하여 세션의 이름을 지정할 수 있습니다:\n\n```js\n$ tmux new -s Session1\n```\n\n```js\n+=========================+=============================================+\n|       Keybinding        |                 Description                 |\n+=========================+=============================================+\n| Ctrl+B D                | 현재 세션에서 분리하기                       |\n+-------------------------+---------------------------------------------+\n| Ctrl+B %                | 창을 수평으로 2개 패널로 분할하기            |\n+-------------------------+---------------------------------------------+\n| Ctrl+B \"                | 창을 수직으로 2개 패널로 분할하기            |\n+-------------------------+---------------------------------------------+\n| Ctrl+B 화살표 키       | 패널 간 이동                               |\n|  (왼쪽,오른쪽,위,아래) |                                             |\n+-------------------------+---------------------------------------------+\n| Ctrl+B X                | 패널 닫기                                  |\n+-------------------------+---------------------------------------------+\n| Ctrl+B C                | 새 창 만들기                               |\n+-------------------------+---------------------------------------------+\n| Ctrl+B N (또는 P)       | 다음 창 또는 이전 창으로 이동               |\n+-------------------------+---------------------------------------------+\n| Ctrl+B 0 (1,2...)       | 특정 번호의 창으로 이동                    |\n+-------------------------+---------------------------------------------+\n| Ctrl+B :                | 명령을 입력할 명령 줄로 이동합니다.         |\n|                         | 탭 자동 완성 사용 가능                      |\n+-------------------------+---------------------------------------------+\n| Ctrl+B ?                | 모든 키 바인딩 보기. \"Q\"를 눌러 종료        |\n+-------------------------+---------------------------------------------+\n| Ctrl+B W                | 여러 세션의 창 간 이동을 위한 패널 열기    |\n+-------------------------+---------------------------------------------\n```\n\n추가 키 바인딩은 tmux 매뉴얼 페이지를 참조하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 마우스 사용하기\n\n티먹스는 주로 키보드와 함께 사용되며, 여러 키 바인딩을 제공하여 명령을 실행하고 새 창을 만들고 크기를 조정하는 것을 더 쉽게 할 수 있습니다. 마우스를 선호한다면, 티먹스도 그것을 허용합니다. 그러나 기본적으로 마우스는 비활성화되어 있습니다. 활성화하려면 먼저 Ctrl+B :를 입력하여 명령 모드로 진입한 후 set -g mouse 명령을 사용하여 마우스를 켜거나 끌 수 있습니다.\n\n이제 마우스를 사용하여 창과 창 사이를 전환하고 크기를 조정할 수 있습니다. 티먹스 버전 3부터는 마우스로 오른쪽 클릭하여 콘텍스트 메뉴를 열 수도 있습니다:\n\n![image](/assets/img/2024-05-23-ABeginnersGuidetotmux_4.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n마우스 커서 아래 화면 내용에 따라 메뉴가 변합니다.\n\n# tmux 구성하기\n\ntmux 구성을 영구적으로 변경할 수 있습니다. tmux 구성 파일을 수정하여 변경할 수 있습니다. 기본적으로 이 파일은 $HOME/.tmux.conf에 위치합니다.\n\n예를 들어, 기본 접두표 키 조합은 Ctrl+B이지만 때로는 이 조합을 누르기가 조금 어색하고 양손이 필요할 수도 있습니다. 구성 파일을 편집하여 다른 키로 변경할 수 있습니다. 저는 접두표 키를 Ctrl+A로 설정하는 것을 좋아합니다. 이를 위해 새 구성 파일을 만들어 다음 라인을 추가하면 됩니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```sh\n$ vi $HOME/.tmux.conf\n\n# Prefix를 Ctrl+a로 설정합니다.\nset -g prefix C-a\n\n# 이전 Prefix 설정을 제거합니다.\nunbind C-b\n\n# 두 번 눌러 애플리케이션에 Ctrl+a를 전송합니다.\nbind C-a send-prefix\n\n:wq\n```\n\n이 머신에서 tmux 세션을 시작할 때는 Ctrl+A를 눌러 위에 나열된 명령을 실행할 수 있습니다. 설정 파일을 사용하여 다른 tmux 키바인딩 및 명령을 변경하거나 추가할 수 있습니다.\n\n# 상태 표시줄 사용자 정의\n\nTmux의 상태 표시줄은 완벽하게 사용자 정의할 수 있습니다. 각 섹션의 색상 및 표시 내용을 변경할 수 있습니다. 이러한 많은 옵션이 있기 때문에 다룰 내용이 또 다른 기사가 필요할 정도이지만, 기초부터 시작하겠습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n상태 표시줄 전체에 대한 표준 녹색 색상 때문에 각 섹션을 구별하기 어려울 수 있습니다. 특히 열려 있는 창의 수와 활성 창을 파악하기가 어려울 수 있습니다.\n\n![image](/assets/img/2024-05-23-ABeginnersGuidetotmux_5.png)\n\n상태 표시줄 색상을 업데이트하여 이를 변경할 수 있습니다. 먼저 Ctrl+B를 입력하여 명령 모드로 전환하십시오. (또는 위에서 접두어 구성 변경을 했다면 Ctrl+A를 입력하십시오.) 그런 다음 다음 명령어로 색상을 변경하십시오:\n\n- 상태 표시줄 배경색 변경: set -g status-bg cyan\n- 비활성 창 색상 변경: set -g window-status-style bg=yellow\n- 활성 창 색상 변경: set -g window-status-current-style bg=red,fg=white\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n영구적 변경을 위해 해당 명령을 구성 파일에 추가해보세요.\n\n이 구성이 적용되면 상태 표시줄이 더 멋지게 보이고 현재 활성 창을 쉽게 식별할 수 있습니다:\n\n![tmux status bar](/assets/img/2024-05-23-ABeginnersGuidetotmux_6.png)\n\n# 다음은 무엇인가요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nTmux은 원격 연결을 보호하는 데 탁월한 도구이며 터미널을 오랜 시간 사용할 때 유용합니다. 이 기사에서는 기본 기능에 대해서만 다루고 있으며 더 많은 것을 탐험할 수 있습니다. tmux에 대한 추가 정보는 공식 위키 페이지를 참조하십시오.\n\n더 많은 명령을 추가하고 Vim과 같은 응용 프로그램과 통합되고 상태 표시줄에 새로운 기능을 추가하는 추가 비공식 플러그인으로 tmux의 기능을 확장할 수도 있습니다. 더 많은 정보는 tmux 플러그인 프로젝트를 참조하십시오.\n\nThe Pragmatic Bookshelf에서 출판된 Ricardo의 책을 확인해 보세요.\n\nGo 프로그래밍 언어로 직접 빠르고 신뢰할 수 있으며 크로스 플랫폼 명령 줄 도구를 작성해 보세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![2024-05-23-ABeginnersGuidetotmux_7](/assets/img/2024-05-23-ABeginnersGuidetotmux_7.png)\n","ogImage":{"url":"/assets/img/2024-05-23-ABeginnersGuidetotmux_0.png"},"coverImage":"/assets/img/2024-05-23-ABeginnersGuidetotmux_0.png","tag":["Tech"],"readingTime":11},{"title":"이번 글에서는 종료 코드 0이란 무엇이며 왜 반환되는지에 대해 알아보겠습니다","description":"","date":"2024-05-23 15:11","slug":"2024-05-23-Whatisexitcode0andwhyisreturned","content":"\n프로그래밍의 복잡한 세계에서는 종료 코드를 이해하는 것이 코드 실행의 동작과 결과를 이해하는 데 중요합니다. 이 연구에서는 종료 코드 0의 중요성을 해석하여 다양한 프로그래밍 언어에서의 영향을 알아보고, 프로그램 종료의 기본 메커니즘을 밝힐 것입니다.\n\n다음 예시를 살펴봅시다:\n\n```js\nint main() {\n  return 0\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\ngcc main.c -o main\n```\n\n이 간단한 C 프로그램에서 return 0; 문은 종료 코드 0으로 프로그램을 종료함을 나타냅니다.\n\n비슷한 맥락에서, Node.js에서 종료 코드가 처리되는 방법을 살펴보죠:\n\n```js\nprocess.exit();\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이번 탐구에서 우리는 bash의 유용한 기능에 초점을 맞춰볼 거에요. 이 기능을 통해 우리는 명령어나 프로그램의 이전 반환 상태를 확인할 수 있어요.\n\n```js\necho $?\n```\n\n두 프로그램을 실행한 결과 모두 0이에요.\n\n# 종료 코드 0: 성공의 보편적 상징\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다양한 프로그래밍 언어, C 및 파생 버전을 포함하여, 0의 종료 코드는 오류 없이 성공적으로 실행되었음을 나타냅니다. 프로그램이 기대대로 작업을 완료하면 종료 코드 0을 반환하여 최종 사용자에게 모든 것이 순조롭게 진행되었다는 것을 알립니다. 이 관례는 스크립트 및 자동화된 프로세스가 프로그램이 성공적으로 실행되었는지 또는 문제가 발생했는지를 확인할 수 있도록 합니다.\n\n하지만 아마도 이 프로그램이 어떻게 로드되는지 궁금할 것입니다. 알아보려고 해 봅시다. 우리 바이너리를 분해할 수 있는 objdump를 사용할 수 있습니다. 다음 명령어를 사용하십시오:\n\n```js\nobjdump -d -M intel main\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리의 여정은 \\_start에서 시작되어 \\_\\_libc_start_main을 거쳐 Linux에서 시스템 호출인 \\_exit으로 끝납니다.\n\nhttps://man7.org/linux/man-pages/man2/_exit.2.html\n\n운영 체제는 프로세스를 생성하고 종료하는 책임이 있음을 알 수 있습니다. Linux 커널에서 우리는 아래 이미지에서 보여지는 것처럼 프로세스를 시각화할 수 있습니다.\n\n![프로세스 시각화](/assets/img/2024-05-23-Whatisexitcode0andwhyisreturned_1.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nLinux에서 사용되는 다른 내부 코드들을 언급할 수 있어요.\n\n```js\n#define EPERM   1 /* Operation not permitted */\n#define ENOENT   2 /* No such file or directory */\n#define ESRCH   3 /* No such process */\n#define EINTR   4 /* Interrupted system call */\n#define EIO   5 /* I/O error */\n#define ENXIO   6 /* No such device or address */\n#define E2BIG   7 /* Argument list too long */\n#define ENOEXEC   8 /* Exec format error */\n#define EBADF   9 /* Bad file number */\n#define ECHILD  10 /* No child processes */\n#define EAGAIN  11 /* Try again */\n#define ENOMEM  12 /* Out of memory */\n#define EACCES  13 /* Permission denied */\n#define EFAULT  14 /* Bad address */\n#define ENOTBLK  15 /* Block device required */\n#define EBUSY  16 /* Device or resource busy */\n#define EEXIST  17 /* File exists */\n#define EXDEV  18 /* Cross-device link */\n#define ENODEV  19 /* No such device */\n#define ENOTDIR  20 /* Not a directory */\n#define EISDIR  21 /* Is a directory */\n#define EINVAL  22 /* Invalid argument */\n#define ENFILE  23 /* File table overflow */\n#define EMFILE  24 /* Too many open files */\n#define ENOTTY  25 /* Not a typewriter */\n#define ETXTBSY  26 /* Text file busy */\n#define EFBIG  27 /* File too large */\n#define ENOSPC  28 /* No space left on device */\n#define ESPIPE  29 /* Illegal seek */\n#define EROFS  30 /* Read-only file system */\n#define EMLINK  31 /* Too many links */\n#define EPIPE  32 /* Broken pipe */\n#define EDOM  33 /* Math argument out of domain of func */\n#define ERANGE  34 /* Math result not representable */\n```\n\n# 결론\n\nC의 main 함수나 Node.js나 다른 프로그래밍 언어에서 process.exit를 사용할 때, 프로그래머가 정의한 종료 코드로 프로세스를 닫기 위해 \\_exit 시스템 호출이 내부적으로 사용됩니다. 그러나 프로그래머로서 여러분은 프로세스의 적절한 종료와 종료된 프로세스에 대한 사용자에게 가장 좋은 결과를 제공하기 위한 책임이 있습니다.\n","ogImage":{"url":"/assets/img/2024-05-23-Whatisexitcode0andwhyisreturned_0.png"},"coverImage":"/assets/img/2024-05-23-Whatisexitcode0andwhyisreturned_0.png","tag":["Tech"],"readingTime":5},{"title":"리눅스 시스템을 위한 10가지 문제 해결 명령어","description":"","date":"2024-05-23 15:10","slug":"2024-05-23-10TroubleshootingCommandsforLinuxSystems","content":"\nMarkdown\n![이미지](/assets/img/2024-05-23-10TroubleshootingCommandsforLinuxSystems_0.png)\n\n# 1. CPU를 가장 많이 사용하는 프로세스 확인하는 방법\n\n```js\n$ ps H -eo pid,pcpu | sort -nk2 | tail\n31396  0.6\n31396  0.6\n31396  0.6\n31396  0.6\n31396  0.6\n31396  0.6\n31396  0.6\n31396  0.6\n30904  1.0\n30914  1.0\n```\n\n가장 CPU를 많이 사용하는 PID는 30914입니다. 음성오버: 실제로는 31396입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 2. 가장 CPU 소모가 많은 프로세스의 PID에 해당하는 서비스 이름은 무엇인가요?\n\n첫 번째 방법:\n\n```js\n$ ps aux | fgrep 30914\nwork 30914  1.0  0.8 309568 71668 ?  Sl   Feb02 124:44 ./router2 –conf=rs.conf\n```\n\n해당 프로세스는 ./router2입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n번호 두 방법:\n\n```js\n$ ll /proc/30914\nlrwxrwxrwx  1 work work 0 2월 10일 13:27 cwd -> /home/work/im-env/router2\nlrwxrwxrwx  1 work work 0 2월 10일 13:27 exe -> /home/work/im-env/router2/router2\n```\n\n음성 안내: 멋져요, 전체 경로가 모두 나와 있네요.\n\n# 3. 특정 포트의 연결 상태를 확인하는 방법은 무엇인가요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nMethod One:\n\n```js\n$ netstat -lap | fgrep 22022\ntcp        0      0 1.2.3.4:22022          *:*                         LISTEN      31396/imui\ntcp        0      0 1.2.3.4:22022          1.2.3.4:46642          ESTABLISHED 31396/imui\ntcp        0      0 1.2.3.4:22022          1.2.3.4:46640          ESTABLISHED 31396/imui\n```\n\nMethod Two:\n\n```js\n$ /usr/sbin/lsof -i :22022\nCOMMAND   PID USER   FD   TYPE   DEVICE SIZE NODE NAME\nrouter  30904 work   50u  IPv4 69065770       TCP 1.2.3.4:46638->1.2.3.4:22022 (ESTABLISHED)\nrouter  30904 work   51u  IPv4 69065772       TCP 1.2.3.4:46639->1.2.3.4:22022 (ESTABLISHED)\nrouter  30904 work   52u  IPv4 69065774       TCP 1.2.3.4:46640->1.2.3.4:22022 (ESTABLISHED)\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 4. 기계의 연결 수를 확인하는 방법은?\n\n1.2.3.4의 SSH 데몬(sshd)이 22번 포트에서 수신 대기 중입니다. 1.2.3.4의 sshd 서비스에 대한 다양한 상태의 연결 수 (TIME_WAIT/CLOSE_WAIT/ESTABLISHED)를 어떻게 카운트할 수 있을까요?\n\n```js\n$ netstat -n | grep 1.2.3.4:22 | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}'\n\n$ netstat -lnpta | grep ssh | egrep \"TIME_WAIT | CLOSE_WAIT | ESTABLISHED\"\n```\n\n참고: netstat은 네트워크 연결 문제를 추적하는 데 자주 사용되는 도구이며, grep/awk와 결합하면 강력한 도구가 됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 5. 사전 백업 로그에서 데이터 쿼리하기\n\n사전 백업 서비스.2022-06-26.log.bz2 로그에서 키워드 1.2.3.4을 포함하는 항목은 몇 개인가요?\n\n```js\n$ bzcat service.2022-06-26.log.bz2 | grep '1.2.3.4' | wc -l\n\n$ bzgrep '1.2.3.4' service.2022-06-26.log.bz2 | wc -l\n\n$ less service.2022-06-26.log.bz2 | grep '10.37.9.11' | wc -l\n```\n\n참고: 온라인 로그 파일은 일반적으로 bz2로 압축된 후 보존됩니다. 쿼리를 위해 해제하면 많은 공간과 시간이 소비됩니다. 따라서, 연구 및 개발 동료들이 숙달해야할 bzcat 및 bzgrep는 필수 도구입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 6. 백업 서비스 팁\n\n백업을 위해 /opt/web/service_web 디렉토리를 패킹하되 로그 디렉토리는 제외하고, 패킹한 파일을 /opt/backup 디렉토리에 저장하세요.\n\n```js\n$ tar -zcvf /opt/backup/service_web.tar.gz \\\n    -exclude /opt/web/service_web/logs \\\n    /opt/web/service_web\n```\n\n참고: 이 명령은 온라인 애플리케이션에서 흔히 사용됩니다. 프로젝트를 패킹하고 이전해야 할 때 로그 디렉토리를 제외해야 할 때가 종종 있습니다. 이런 시나리오에서는 `exclude` 매개변수를 잘 활용하는 것이 중요합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 7. 쓰레드 카운트 조회\n\n서버의 서비스를 위해 실행 중인 전체 쓰레드 수를 조회합니다. 기계의 쓰레드 수가 경고 임계값을 초과할 때 해당 프로세스와 쓰레드 정보를 빠르게 식별해야 합니다.\n\n```js\n$ ps -eLf | wc -l\n\n$ pstree -p | wc -l\n```\n\n# 8. 디스크 경고, 가장 큰 파일 비우기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n많은 예외 로그 파일을 찾아 서버에서 실행 중인 Tomcat 서버에서 생성된 파일을 공간을 확보하세요. 파일에 \"log\" 키워드가 포함되어 있고 1GB보다 큰 경우를 가정합니다.\n\n단계 1: 파일 찾기.\n\n```js\n$ find / -type f -name \"*log*\" | xargs ls -lSh | more\n\n$ du -a / | sort -rn | grep log | more\n\n$ find / -name '*log*' -size +1000M -exec du -h {} \\;\n```\n\n단계 2: 파일을 비우기.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n가정적으로 찾은 파일이 a.log인 경우, 해당 파일을 완전히 비우는 올바른 방법은:\n\n```js\n$ echo \"\" > a.log\n```\n\n이렇게 하면 파일 공간이 즉시 해제됩니다.\n\n많은 사람들이 사용하는 방법:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n$ rm -rf a.log\n```\n\n파일을 삭제하면서도 Tomcat 서비스가 여전히 실행 중인 경우 공간이 즉시 해제되지 않을 수 있습니다. 공간을 확보하려면 Tomcat을 다시 시작해야 합니다.\n\n# 9. 파일 표시, 주석 필터링\n\n서버.conf 파일을 표시하고 #로 시작하는 주석 줄을 마스킹합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n$ sed -n '/^[#]/!p' server.conf\n\n$ sed -e '/^#/d' server.conf\n\n$ grep -v \"^#\" server.conf\n```\n\n# 10. 디스크 IO 예외 해결 방법\n\n디스크 IO 예외, 예를 들어 느린 쓰기 또는 높은 현재 사용량과 같은 문제를 해결하는 방법을 알아보세요. 높은 디스크 IO 예외를 일으키는 프로세스 ID를 식별해야 합니다.\n\n단계 1:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```sh\n$ iotop -o\n```\n\n현재 디스크에 쓰기 중인 모든 프로세스 ID를 보십시오.\n\n단계 2: 만약 쓰기 표시기가 낮고 주요 쓰기 작업이 거의 없다면, 디스크 자체를 확인해야 합니다. 시스템을 확인할 수 있습니다.\n\n```sh\n$ dmesg\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n차후에 한 번 `/var/log/message` 파일을 확인해보세요. 여기에 어떤 디스크 오류 메시지가 있는지 확인할 수 있어요. 동시에, 쓰기 속도가 느린 디스크에 빈 파일을 만들어보세요. 디스크의 고장으로 인해 쓰기가 안 되는지 확인할 수 있어요.\n","ogImage":{"url":"/assets/img/2024-05-23-10TroubleshootingCommandsforLinuxSystems_0.png"},"coverImage":"/assets/img/2024-05-23-10TroubleshootingCommandsforLinuxSystems_0.png","tag":["Tech"],"readingTime":8},{"title":"파이썬에서 쉘 명령어를 올바르게 실행하는 방법","description":"","date":"2024-05-23 15:08","slug":"2024-05-23-TheRightWaytoRunShellCommandsFromPython","content":"\n<img src=\"/assets/img/2024-05-23-TheRightWaytoRunShellCommandsFromPython_0.png\" />\n\n파이썬은 모든 것을 자동화하는 데 인기 있는 선택지입니다. 이는 시스템 관리 작업을 자동화하거나 다른 프로그램을 실행하거나 운영 체제와 상호 작용하는 작업을 포함합니다. 그러나 파이썬에서 이를 수행하는 많은 방법이 있습니다. 대부분은 논란이 될 수 있는 방법입니다.\n\n그래서 이 기사에서는 다른 프로세스를 실행하는 데 사용할 수 있는 파이썬 옵션을 모두 살펴볼 것입니다. 나쁜 방법, 좋은 방법, 그리고 무엇보다도 올바른 방법을 중점적으로 살펴보겠습니다.\n\n# 옵션들\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n파이썬은 다른 프로그램과 상호 작용하는 내장 옵션이 너무 많습니다. 그 중에서도 어떤 것은 좋고 나쁨이 있지만 솔직히 말해서 나는 어느 것도 좋아하지 않아요. 각 옵션을 빠르게 살펴보고 특정 모듈을 사용해야 하는 시점(있는 경우)을 확인해 봅시다.\n\n# 내장 도구\n\n일반적인 지침은 다른 프로그램이나 OS 명령을 직접 호출하는 대신 기본 기능을 사용하는 것이어야 합니다. 그래서 먼저 파이썬의 기본 옵션을 살펴보겠습니다:\n\n- pathlib — 파일/디렉토리를 생성하거나 삭제해야 하거나 파일이 존재하는지 확인하거나 권한을 변경해야 할 때는 시스템 명령을 실행할 이유가 없습니다. 단순히 pathlib을 사용하세요. 필요한 모든 것이 포함되어 있습니다. pathlib를 사용하기 시작하면 glob이나 os.path와 같은 다른 파이썬 모듈을 잊을 수 있다는 것을 깨닫게 될 거예요.\n- tempfile — 비슷하게, 임시 파일이 필요할 때는 tempfile 모듈을 사용하세요. /tmp에 수동으로 접근할 필요가 없습니다.\n- shutil — pathlib은 파이썬에서 대부분의 파일 관련 요구 사항을 충족할 것입니다. 그러나 파일을 복사하거나 이동하거나 chown 또는 아카이브를 생성해야 하는 경우에는 shutil을 사용해야 합니다.\n- signal — 신호 핸들러를 사용해야 하는 경우에 필요합니다.\n- syslog — Unix syslog에 대한 인터페이스를 위해 사용합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만약 위에 제공된 내장 옵션들 중에서 아무것도 원하는 대로 만족스럽지 않다면, 그때만 운영 체제나 다른 프로그램과 직접 상호 작용하는 것이 의미가 있습니다.\n\n# OS 모듈\n\n최악의 옵션부터 시작해서 os 모듈은 운영 체제와 상호 작용하기 위한 저수준 함수를 제공하지만, 많은 함수들이 다른 모듈에서 대체되었습니다.\n\n단순히 다른 프로그램을 호출하고 싶다면 os.system 함수를 사용할 수 있지만, 사용하면 안 됩니다. 당신에게 예시를 들어 주고 싶지 않아요, 왜냐하면 그냥 사용하지 말아야 하기 때문입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nos는 처음 선택하긴 좋지 않지만, 유용하게 사용할 수 있는 몇 가지 함수가 있습니다:\n\n```js\nimport os\n\nprint(os.getenv('PATH'))\n# /home/martin/.local/bin:/usr/local/sbin:/usr/local/bin:...\nprint(os.uname())\n# posix.uname_result(sysname='Linux', nodename='...', release='...', version='...', machine='x86_64')\nprint(os.times())\n# posix.times_result(user=0.01, system=0.0, children_user=0.0, children_system=0.0, elapsed=1740.63)\nprint(os.cpu_count())\n# 16\nprint(os.getloadavg())\n# (2.021484375, 2.35595703125, 2.04052734375)\nold_umask = os.umask(0o022)\n# 파일 처리...\nos.umask(old_umask)  # 이전 umask로 되돌리기\n\n# 'random' 모듈의 의사 난수보다 더 좋은 난수가 필요한 경우에만 사용하세요:\nfrom base64 import b64encode\n\nrandom_bytes = os.urandom(64)\nprint(b64encode(random_bytes).decode('utf-8'))\n# C2F3kHjdzxcP7461ETRj/YZredUf+NH...hxz9MXXHJNfo5nXVH7e5olqLwhahqFCe/mzLQ==\n```\n\n위에 설명된 함수들 외에도, fd(파일 기술자), 파이프, PTY 열기, chroot, chmod, mkdir, kill, stat을 생성하는 함수들이 있지만, 더 좋은 옵션이 있기 때문에 사용을 권장하지 않습니다. 심지어 os.popen, os.spawn 또는 os.system을 사용하지 않도록 docs에 나온 부분에서 os를 subprocess 모듈로 대체하는 방법을 보여줍니다.\n\n파일/경로 작업에 os 모듈을 사용하지 말아주세요. os.path 및 기타 경로 관련 함수 대신 pathlib를 사용하는 방법에 대한 전체 섹션이 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nos 모듈의 대부분의 남은 함수는 OS(또는 C 언어) API에 직접적으로 연결되어 있습니다. 예를 들어 os.dup, os.splice, os.mkfifo, os.execv, os.fork 등이 있습니다. 이러한 모든 함수를 사용해야 한다면 파이썬이 그 작업에 적합한 언어인지 확신하지 못합니다.\n\n# 서브프로세스 모듈\n\n파이썬에서 두 번째 — 약간 나은 — 옵션은 서브프로세스 모듈입니다. 아래는 서브프로세스 모듈의 예시입니다:\n\n```js\nimport subprocess\n\np = subprocess.run('ls -l', shell=True, check=True, capture_output=True, encoding='utf-8')\n\n# 'p'는 'CompletedProcess(args='ls -la', returncode=0)'의 인스턴스입니다\nprint(f'Command {p.args} exited with {p.returncode} code, output: \\n{p.stdout}')\n# Command ls -la exited with 0 code\n\n# total 36\n# drwxrwxr-x  2 martin martin  4096 apr 22 12:53 .\n# drwxrwxr-x 42 martin martin 20480 apr 22 11:01 ..\n# ...\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n문서에서 설명된대로:\n\n대부분의 경우 subprocess.run을 사용하여 kwargs를 전달하여 해당 동작을 변경하는 것이 충분합니다. 예를 들어 shell=True를 사용하면 명령을 단일 문자열로 전달할 수 있고, check=True를 사용하면 종료 코드가 0이 아닌 경우 예외를 throw하고, capture_output=True를 사용하면 stdout 속성을 채울 수 있습니다.\n\nsubprocess.run()은 프로세스를 호출하는 권장되는 방법입니다. 이 모듈에서 다른 (불필요하고 사용되지 않는) 옵션도 있습니다: call, check_call, check_output, getstatusoutput, getoutput. 일반적으로 아래와 같이 run과 Popen만 사용해야 합니다:\n\n```js\nwith subprocess.Popen(['ls', '-la'], stdout=subprocess.PIPE, encoding='utf-8') as process:\n    # process.wait(timeout=5)  # 코드만 반환: 0\n    outs, errs = process.communicate(timeout=5)\n    print(f'Command {process.args}가 {process.returncode} 코드로 종료되었으며 출력: \\n{outs}')\n\n# 파이프\nimport shlex\nls = shlex.split('ls -la')\nawk = shlex.split(\"awk '{print $9}'\")\nls_process = subprocess.Popen(ls, stdout=subprocess.PIPE)\nawk_process = subprocess.Popen(awk, stdin=ls_process.stdout, stdout=subprocess.PIPE, encoding='utf-8')\n\nfor line in awk_process.stdout:\n    print(line.strip())\n    # .\n    # ..\n    # examples.py\n    # ...\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 첫 번째 예제는 이전에 소개된 subprocess.run의 Popen 등가물을 보여줍니다. 그러나 run이 제공하는 것보다 더 많은 유연성이 필요할 때만 Popen을 사용해야 합니다. 두 번째 예제에서는 한 명령의 출력을 다른 명령으로 파이핑하는 방법을 볼 수 있습니다. ls -la | awk `'print $9'`를 효과적으로 실행하는 방법입니다. 또한, shlex.split을 사용했는데, 이는 문자열을 토큰의 배열로 분할하는 편리한 함수로, shell=True를 사용하지 않고 Popen이나 run으로 전달할 수 있습니다.\n\nPopen을 사용할 때, 프로세스와 더 많은 상호작용을 위해 terminate(), kill() 및 send_signal()을 추가적으로 사용할 수 있습니다.\n\n이전 예제에서는 실제로 오류 처리를 거의 하지 않았지만, 다른 프로세스를 실행할 때 많은 문제가 발생할 수 있습니다. 간단한 스크립팅의 경우, check=True가 있으면 충분할 것으로 생각됩니다. 이는 호출 프로세스가 0이 아닌 반환 코드를 만나면 CalledProcessError가 발생하므로 프로그램이 빠르고 강하게 실패합니다. timeout 인수도 설정하면 TimeoutExpired 예외도 받을 수 있지만, 일반적으로 subproccess 모듈의 모든 예외는 SubprocessError에서 상속받습니다. 예외를 잡고 싶을 경우에는 SubprocessError를 감시하면 됩니다.\n\n# 올바른 방법\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n파이썬의 신조(격언)은 다음과 같습니다:\n\n하지만 지금까지 파이썬의 내장 모듈들로 많은 방법을 보았습니다. 하지만 그 중에 어떤 것이 옳은 것일까요? 내 의견으로는 그 중 하나도 아닙니다.\n\n파이썬의 표준 라이브러리를 좋아하지만, subprocess 모듈이 더 나은 \"배터리\" 중에 하나라고 생각합니다.\n\n만약 파이썬에서 다른 프로세스를 많이 조합하는 상황이라면, sh 라이브러리를 한 번 살펴보는 것을 권장합니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```bash\n# https://pypi.org/project/sh/\n# pip install sh\nimport sh\n\n# $PATH에 있는 어떤 명령어든 실행...\nprint(sh.ls('-la'))\n\nls_cmd = sh.Command('ls')\nprint(ls_cmd('-la'))  # 명시적으로\n# total 36\n# drwxrwxr-x  2 martin martin  4096 apr  8 14:18 .\n# drwxrwxr-x 41 martin martin 20480 apr  7 15:23 ..\n# -rw-rw-r--  1 martin martin    30 apr  8 14:18 examples.py\n\n# 만약 PATH에 명령어가 없다면:\ncustom_cmd = sh.Command('/path/to/my/cmd')\ncustom_cmd('some', 'args')\n\nwith sh.contrib.sudo:\n    # 'sudo'를 사용하여 작업 수행...\n    ...\n```\n\nsh.some_command을 호출하면, sh 라이브러리가 해당 이름의 내장 셸 명령어나 $PATH에 있는 이진 파일을 찾습니다. 그런 명령어를 찾으면 그대로 실행됩니다. 명령어가 $PATH에 없는 경우에는 Command의 인스턴스를 생성하고 그렇게 호출할 수 있습니다. sudo를 사용해야 하는 경우에는 contrib 모듈의 sudo context manager를 사용할 수 있습니다. 너무 간단하고 직관적이죠?\n\n명령어의 결과를 파일에 쓰려면, 함수에 \\_out 인수를 제공하면 됩니다:\n\n```bash\nsh.ip.address(_out='/tmp/ipaddr')\n# 'ip address > /tmp/ipaddr'와 같습니다\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위에는 하위 명령을 호출하는 방법도 보여 줍니다. - 점을 사용하세요.\n\n마지막으로 \\_인 인수를 사용하여 파이프(|)를 사용할 수도 있습니다:\n\n```js\nprint(sh.awk('{print $9}', _인=sh.ls('-la'))\n# \"ls -la | awk '{print $9}'\"과 동일합니다\n\nprint(sh.wc('-l', _인=sh.ls('.', '-1'))\n# \"ls -1 | wc -l\"과 동일합니다\n```\n\n오류 처리에 대해선 ErrorReturnCode 또는 TimeoutException 예외를 감시하면 됩니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n시도:\nsh.cat('/tmp/doesnt/exist')\nexcept sh.ErrorReturnCode as e:\nprint(f'Command {e.full_cmd} exited with {e.exit_code}') # Command /usr/bin/cat /tmp/doesnt/exist exited with 1\n\ncurl = sh.curl('https://httpbin.org/delay/5', \\_bg=True)\ntry:\ncurl.wait(timeout=3)\nexcept sh.TimeoutException:\nprint(\"Command timed out...\")\ncurl.kill()\n\n선택적으로, 만약 프로세스가 시그널에 의해 종료된다면, SignalException을 받게 될 거에요. 특정 시그널을 확인할 수 있는데 예를 들면 SignalException_SIGKILL(또는 \\_SIGTERM, \\_SIGSTOP 등)으로 확인할 수 있어요.\n\n이 라이브러리에는 내장된 로깅 지원도 있어요. 켜기만 하면 되는데요. 다음 코드가 도와줄 거에요:\n\nimport logging\n\n# 기본 로깅 켜기:\n\nlogging.basicConfig(level=logging.INFO)\nsh.ls('-la')\n\n# INFO:sh.command:<Command '/usr/bin/ls -la', pid 1631463>: process started\n\n# 로그 레벨 변경:\n\nlogging.getLogger('sh').setLevel(logging.DEBUG)\nsh.ls('-la')\n\n# INFO:sh.command:<Command '/usr/bin/ls -la', pid 1631661>: process started\n\n# DEBUG:sh.command:<Command '/usr/bin/ls -la'>: starting process\n\n# DEBUG:sh.command.process:<Command '/usr/bin/ls -la'>.<Process 1631666 ['/usr/bin/ls', '-la']>: started process\n\n# ...\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 예제들은 대부분의 사용 사례를 다룰 수 있지만, 더 고급/난해한 경우에는 라이브러리 문서의 튜토리얼이나 FAQ를 확인해보세요. 여기에는 추가적인 예제들이 있습니다.\n\n# 마지막으로\n\n다시 강조하고 싶은 점은 항상 시스템 명령어를 사용하는 대신 네이티브 Python 함수를 선호해야 한다는 것입니다. 또한 CLI 명령어를 직접 실행하는 대신 Kubernetes-client나 클라우드 제공업체의 SDK와 같은 서드파티 클라이언트 라이브러리를 사용하는 것을 항상 선호해야 합니다. 내 의견으로는, 쉘 대신 Python에 더 익숙하다면 시스템 관리자 배경에서 오더라도 적용됩니다. 마지막으로, Python은 쉘보다 훨씬 강력하고 견고한 언어이지만, 다른 프로그램/명령어를 너무 많이 연결해야 하는 경우에는 아마도 쉘 스크립트를 작성하는 것이 나을 수도 있습니다.\n\n```js\n연락하고 싶으세요?\n\n이 글은 원본이 martinheinz.dev에 게시되었습니다.\n```\n","ogImage":{"url":"/assets/img/2024-05-23-TheRightWaytoRunShellCommandsFromPython_0.png"},"coverImage":"/assets/img/2024-05-23-TheRightWaytoRunShellCommandsFromPython_0.png","tag":["Tech"],"readingTime":11},{"title":"신호, 셸 및 도커 발을 쏘는 축적체","description":"","date":"2024-05-23 15:06","slug":"2024-05-23-Signalsshellsanddockeranonionoffootguns","content":"\n가끔은 POSIX 시그널(SIGINT, SIGTERM 등)을 디버깅해야 할 때가 있었습니다. 불가피하게 쉘도 포함되어 있죠. 어느 날, 시그널, 쉘 및 컨테이너 간 이상한 상호 작용을 디버깅하던 중에 일부 행동에 혼란스러워졌습니다. Linux에 대해 자신 있다고 생각하는 사람들조차도 우리 조사 결과의 일부 내용이 놀라울 정도로 신기할 것이라 생각됩니다. 이런 종류의 내용이 여러분이 노트북을 창문 밖으로 던지고 알파카 농부 은둔자가 되고 싶지 않는다면 계속 읽어보세요.\n\n![이미지](/assets/img/2024-05-23-Signalsshellsanddockeranonionoffootguns_0.png)\n\n# 범행 현장\n\n저희 Benchling에서는 꽤 표준적인 테스트/지속적 통합(CI) 설정이 있습니다: 코드를 푸시하여 풀 리퀘스트 브랜치에 올리면 테스트를 실행합니다. 몇 년 전, 푸시를 다시 하고 이전 커밋에서 여전히 테스트가 실행 중이면 이전 테스트 실행을 취소하는 최적화를 추가했습니다. 아마 여러분은 그 실행에 대해 신경 쓸 필요가 없을 것이고 약간의 비용을 절약할 것입니다... 아니면 그렇게 될까요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저희 테스트를 실행하는 코드는 기본적으로 이렇습니다\n\n```js\ndef test_pipeline() -> int:\n    test_result = subprocess.run([\"pytest\", …])\n    report_test_metrics()\n    upload_artifacts()\n    return test_result.returncode\n```\n\n그래서 우리의 프로세스 트리는 다음과 같습니다\n\n```js\ntest_pipeline\n└──pytest\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nsubprocess.run은 자식 프로세스가 종료될 때까지 블로킹되므로 대부분의 시간이 걸릴 것입니다. CI 로그에서 테스트가 중간에 중단되고 더 이상 로그가 표시되지 않는 것을 보았는데, 확실히 작동 중인 것처럼 보입니다. 하지만 우리는 취소된 실행에 대한 메트릭스와 아티팩트를 얻을 수 있습니다. 이것은 전혀 이치에 맞지 않습니다. 나중에 우리는 실행이 취소되었고 로그 전달이 중지되었음을 보고했지만 pytest가 계속 실행되고 있음을 나준 낼 것입니다.\n\n# 기초로 돌아가기\n\ntest_pipeline에서 pytest로 신호를 전달하지 않는 문제일 수도 있다고 생각하여 우리는 먼저 기본 신호 처리에 대해 고려했습니다. zsh를 실행 중인 터미널에서 zsh의 pid를 다음과 같이 얻을 수 있습니다.\n\n```bash\n$ echo $$\n20147\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그러면 zsh 안에서 bash를 실행하고 (테스트와 같이 매우 느린 명령어) bash 안에서 infinity로 sleep할 수 있어요.\n\n```js\n$ bash\n$ sleep infinity\n```\n\n다른 쉘에서는 프로세스 트리를 확인할 수 있어요.\n\n```js\n$ pstree -p 20147\nzsh(20147)───bash(65453)───sleep(65904)\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n(pstree은 Debian/Ubuntu에서는 psmisc 패키지에 포함되어 있고, brew에는 pstree 공식이 있습니다.) 여기서는 기대한 대로 zsh가 bash를 실행하고 bash가 sleep를 실행하는 것이 나타납니다. 이제 우리가 ctrl+c로 SIGINT를 보내면 sleep가 멈춥니다.\n\n이게 왜 그럴까요? 터미널은 ctrl+c를 \"SIGINT를 전송\"으로 해석합니다. zsh가 SIGINT를 받아서 기본 셸 프로세스인 bash에 전달하고, bash가 이 신호를 sleep에 전달합니다. sleep는 SIGINT에 대한 자체 시그널 핸들러를 설정하지 않았고, 기본 시그널 핸들러가 종료합니다 (SIGINT에는 \"term\" 처리 방식이 있습니다).\n\n조사 시작 시에는 이것이 셸 신호 처리에 대한 우리의 개념 모델이었습니다.\n\n# 대화형이 아닌 셸\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n실제 문제가 발생한 것은 셸 스크립트가 bash로 실행될 때 나타났습니다 (위의 파이썬 코드를 bash 스크립트에서 실행합니다).\n\n```js\nbash\n  └─test_pipeline\n      └─pytest\n```\n\n대화식 셸(다른 차이 사항 중 stdin을 읽는)이 비대화식 셸이나 \"스크립트\"와 다르게 작동할 수 있다고 생각하여, 파일에 2줄을 작성했습니다.\n\n```js\nsleep infinity\necho done\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n돌렸다\n\n```js\n$ ./test.sh\n```\n\n다른 쉘에서는 똑같은 프로세스 트리를 볼 수 있었어요\n\n```js\n$ pstree -p 20147\nzsh(20147)───bash(65910)───sleep(65911)\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그런 다음, 우리는 직접 bash에게 신호를 보냈습니다.\n\n```js\n$ kill -s INT 65910\n```\n\n하지만 아무 일도 일어나지 않았습니다. bash 문서(man bash)에 숨겨진 \"신호(signals)\" 섹션에는\n\n대화식 쉘에 대해서 기본적으로 작업 제어가 켜져 있고, 스크립트에 대해서는 꺼져 있다는 내용이 있습니다(“모니터 모드”에 대한 문서 참조). 그래서 아무 일도 일어나지 않았던 이유는 bash가 sleep(전경에 있는 명령)가 종료되기를 기다리고 있었기 때문입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n하지만 여기에 프로세스 그룹에 관한 힌트도 있습니다. `pstree` 명령을 사용하면 이를 확인할 수 있습니다 (macOS에서는 작동하지 않음):\n\n```js\n$ pstree -pg 20147\nzsh(20147,20147)───bash(65910,65910)───sleep(65911,65910)\n```\n\n여기서 볼 수 있듯이, 대화식 zsh에서 실행한 bash가 자체 프로세스 그룹을 갖고 있다는 것을 알 수 있습니다. 반면, 비대화식 bash에서 실행한 sleep는 bash와 동일한 pgid를 공유합니다. 그룹 내의 두 프로세스에 대해 신호를 보내려면 pid를 부정화하면 됩니다:\n\n```js\n$ kill -s INT -65910\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이렇게 하면 sleep이 SIGINT를 수신하여 종료됩니다. bash도 SIGINT를 받아서 문서에 나와 있는 대로 자체적으로 종료됩니다. 상호작용식 zsh로 돌아와서 다음을 실행할 수 있습니다.\n\n```js\n$ sleep infinity\n```\n\n그리고 sleep이 예상대로 자체 pgid를 받는 것을 확인할 수 있습니다.\n\n```js\n$ pstree -p 20147\nzsh(20147,20147)───sleep(65916,65916)\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 비 대화형 셸에서의 마지막 명령어\n\n지금은 종종 셸이 자식 프로세스로 신호를 전달하지 않을 수 있다는 것을 알게 되었습니다. 어떤 사람이 한 번 bash -c `sleep infinity`를 실행하여 이것을 재현하려 했습니다. 그들은 ctrl+c를 눌러 sleep를 중지시킬 수 있었습니다. 그러나 이는 비 대화형 셸이므로 bash가 SIGINT를 전달해서는 안 되는 것 아닌가요? 왜 그럴까요?\n\n```js\n$ bash -c ‘sleep infinity’\n```\n\n보통의 경우, 다른 쉘에서:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```bash\n$ pstree -p 20147\nzsh(20147)───sleep(65920)\n```\n\n어이쿠, bash가 어디로 갔지? 우리는 bash를 실행했는데요! 왜 pstree가 zsh가 sleep을 실행 중이라고 하는 걸까요?\n\n프로그램을 \"실행\"할 때 일반적으로 하는 것은 fork한 후에 exec하는 것을 의미합니다. fork는 새로운 프로세스의 부모 pid를 설정하여 나중에 pstree와 같은 도구가 이쁜 트리를 그릴 수 있도록 합니다. exec는 새로운 프로세스의 명령을 설정하여 pstree와 같은 도구가 해당 pid가 무슨 일을 하는지 유의미한 정보를 보여줄 수 있도록 합니다.\n\n하지만 이곳에서 일어난 일은 bash가 단순히 sleep을 exec해주기 전에 fork하는 것을 건너뛴 것입니다. 이 동작에 대한 문서를 찾을 수 없어서, 대신 해드릴 수 있는 것은 ash 소스 코드입니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n/* 포크를 피할 수 있을까요? 예를 들어, 스크립트나 서브셸에서\n * 가장 마지막 명령은 포킹이 필요 없습니다,\n * 그냥 실행(exec)할 수 있습니다.\n */\n```\n\n바쉬가 자신을 sleep으로 교체하고 pstree에 보여지는 것은, 이제 sleep을 실행 중인 것의 부모가 zsh 임을 보여줍니다. 대신 `bash -c 'sleep infinity && done'`을 실행함으로써 이전 동작을 얻을 수 있습니다.\n\n실제로 우리는 bash 스크립트를 sh -c로 실행하기 때문에, 우리의 정신적 모델은 다음과 같습니다.\n\n```js\nsh\n└─bash\n    └─test_pipeline\n        └─pytest\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n잠깐만요! 나무 구조에서 'sh'가 자체 PID가 아니라는 것을 깨달을 때까지는...\n\n# sh, bash, dash, 그리고 ash에 관한 간단한 쉬는 시간\n\n아쉬가 뭐죠? 제가 보낸 것은 무관한 코드 링크인가요? (네, 어느 정도 맞아요. bash와 동일한 동작을 하지만 소스 코드는 조금 덜...추상화되어 있죠.)\n\nsh는 Bourne 쉘(보통 \"POSIX sh\"로 불립니다.)이며, Bash는 Bourne 쉘의 확장 버전입니다. 역사적으로는 많은 시스템에서 sh를 bash에 연결한 적이 있었습니다. bash는 argv[0]을 확인하고 sh 호환 모드에서 실행했죠. 현대의 리눅스 시스템에서는 sh가 일반적으로 dash로 대체되었지만 macOS에서는 여전히 sh 모드에서 bash를 사용합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n1989년 NetBSD를 위해 작성된 Almquist 셸이 원래 ash였습니다. 이것은 Linux로 이식되어 dash(Debian Almquist 셸)로 이름이 변경되었습니다. 요즘에는 \"ash\"가 일반적으로 busybox ash를 가리키는데, 이는 dash의 파생물입니다. 네, 맞아요. 계보는 ash → dash → ash입니다. 쉘 프로그래머들은 명명하는 데에 뛰어난 능력이 없다고 할 수 있겠네요.\n\n그런데 sh 호환 모드에서 bash와 ash는 모두 이전 섹션에서 설명한 exec-without-fork 동작을 구현하지만, dash는 그렇지 않습니다. 또한 Docker Hub의 공식 bash 이미지에서 sh를 실행하려고 하면 (docker run -it --rm bash sh), sh 호환 모드의 bash를 기대했겠지만 ash가 실행됩니다 (ash와 혼동해서는 안 되는 것입니다).\n\n# 플로우차트\n\n여기가 바로 쉘 신호 처리의 껍질을 벗기기 전에 있었으면 좋았을 플로우차트입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Image](/assets/img/2024-05-23-Signalsshellsanddockeranonionoffootguns_1.png)\n\n# 범죄 현장으로 돌아가기\n\n우리는 편리한 플로우차트를 가지고, ci-agent의 코드를 읽기 위해 이동했고, 빌드가 취소되면 실행 중인 작업에 SIGTERM을 보낸다는 것을 발견했습니다.\n\n```js\nci-agent\n    └─bash\n        └─test_pipeline\n            └─pytest\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\"배시가 비대화식으로 실행되었고, test_pipeline이 마지막 명령어가 아니어서 어 anyway 신호가 전달되지 않았습니다. 그게 무슨 일이 발생한 걸 설명해주나요?\n\n우리는 bash를 exec test_pipeline.py로 만들어 트리에서 제거하려 했지만, 문제가 해결되지 않았습니다. 그것은 우리의 프로세스 트리가 여전히 잘못되어 있다는 것을 의미할 것입니다.\n\n# 컨테이너\n\nci-agent는 사실상 도커에게 스크립트를 실행하라고 지시하는 것 뿐입니다.\"\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nci-agent\n└─docker\n└─bash\n└─test_pipeline\n└─pytest\n\n도커가 신호를 베쉬에게 전달하나요? 도커는 각 컨테이너마다 새로운 pid 네임스페이스를 생성하기 때문에 실행되는 명령이 pid 1이 됩니다. 1은 매우 특별한 pid입니다 (일반적으로 init 프로세스) 그리고 기본 신호 처리기를 가져오지 않습니다. 이 문제를 해결하기 위해 tini 또는 dumb-init을 pid 1로 사용하는 것이 일반적입니다.\n\n이미지를 조사한 결과 이미 우리는 dumb-init을 사용하고 있었다는 것이 밝혀졌습니다. 그래서 다음과 같은 트리가 남았습니다.\n\nci-agent\n└─docker\n└─dumb-init\n└─bash\n└─test_pipeline\n└─pytest\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n문제에 대한 설명이 없네요.\n\n# 이것이 마지막 트리에요, 정말\n\n사실, 우리는 도커 컨테이너를 직접 실행하지 않아요. 대신 도컴 포즈로 실행해요.\n\n```js\nci-agent\n    └─docker compose\n        └─docker\n            └─dumb-init\n                └─bash\n                    └─test_pipeline\n                        └─pytest\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 트리를 마친 후 우리는 문제를 재현할 수 있었습니다. 문제는 docker-compose v2.0.0에서 v2.19.0 사이의 버전에서 발생합니다. 여기서 docker-compose run이 시그널을 전달하지 못하는 문제가 발생합니다. 우리가 이 문제를 보고한 후에 이 문제가 해결되었습니다.\n\n이 버그는 docker-compose(v1)에서 docker compose(v2)로 업그레이드할 때 발생했습니다. 이 문제를 이해하는 데는 하이픈(hyphen)이 빠져있는 것을 발견하는 것이 필요했습니다. 이 누락된 하이픈을 발견하는 것은 중요했지만, 두 버전은 거의 동일한 매개변수를 가지고 있고, 거의 동일한 동작을 하기 때문에 발견하기 어려웠습니다. 이 이야기를 읽으면서 얻는 교훈 중 하나는, 이름을 짓는 것은 어렵지만 중요하다는 것입니다. 만약 \"하이픈(-)을 공백으로 바꿔서 Compose V2를 사용하도록 스크립트를 업데이트하세요\"와 같은 문서를 작성하게 되면, 아마도 중요한 명명 오류를 범한 것입니다.\n\n이 문제를 디버깅하는 데 어려웠던 점 중에 하나는 전체 소유권 체인을 이해해야 했기 때문입니다. 시그널은 각 프로세스가 자식에게 전달해야 합니다. pytest가 시그널을 받지 못한 이유를 이해하려면 전파 체인이 깨진 지점까지 트리를 구성해야 했는데, 이 경우에는 상당히 멀리 있었습니다.\n\n우리는 docker compose v1로 다시 다운그레이드하는 것을 고려했지만, 대신 CI 단계에서 실행된 컨테이너를 추적하고 끝에 도달하면 docker kill하는 방법을 선택했습니다. 나중에 상류에서 이 문제를 해결한 후, 우리의 완화책이 실제로 활성화되지 않았습니다. 문제가 해결된 후에는 이제 CI 실행이 다시 원하는 대로 중단됩니다. PR 브랜치로 여러 번 빠르게 푸시되면 이전 커밋을 실행하여 사이클을 낭비하지 않게 되어 전체 실행이 더 빨라졌습니다! (취소된 실행에 대한 측정 값을 더 이상 보고하지 않기 때문에 불안한 테스트를 식별하는 데 큰 도움이 됩니다.)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 프론트그라운드 프로세스 보너스\n\n\"비대화된 쉘\" 섹션에서 우리는 다음과 같은 프로세스 트리를 가졌습니다.\n\n```js\nzsh(20147)───bash(65910)───sleep(65911)\n```\n\n직접적으로 bash에 시그널을 보내는 방법을 다루었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```sh\n$ kill -s INT -65910\n```\n\nzsh에 직접 신호를 보내지 않았던 이유가 뭔가요? zsh가 상호작용으로 실행 중이기 때문에 SIGINT를 bash로 전달해야 되지 않나요? 다음을 시도해 볼 수 있습니다.\n\n```sh\n$ kill -s INT -20147\n```\n\n하지만 아무 일도 일어나지 않아요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n현 상황에서 ctrl+c를 누르면 터미널이 zsh가 아니라 bash에 SIGINT를 보낸다는 걸 알게 되었어요. 이것은 zsh가 더 이상 전경 프로세스 그룹에 속해 있지 않기 때문입니다. 이것을 확인하기 위해 다음과 같이 실행해 볼 수 있어요.\n\n```js\n$ ps -xO stat\n   PID STAT S TTY          TIME COMMAND\n 20147 Ss   S pts/0    00:00:00 zsh\n 65910 S+   S pts/0    00:00:00 bash\n 65911 S+   S pts/0    00:00:00 sleep\n```\n\nman ps의 \"프로세스 상태 코드\" 섹션에 의하면\n\nbash와 sleep은 보이는데 zsh는 보이지 않네요. 그들이 동시에 전경 프로세스 그룹에 있을 수 없기 때문에, zsh가 상호작용적으로 실행 중이기 때문에 zsh는 bash에 자체 프로세스 그룹을 설정했어요. 그래서 \"zsh가 SIGINT를 받아서 bash로 전달한다\"고 말했지만, 실제로는 그게 사실이 아니었던 거예요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n하지만 bash의 프로세스 그룹이 왜 전경 그룹인가요? tcsetpgrp. 이것은 ltrace로 확인할 수 있습니다:\n\n```js\n$ ltrace -e tcsetpgrp bash\nbash->tcsetpgrp(255, 0xa9850, 0, 0x7f290bdb2fe4) = 0\n```\n\n그리고 bash가 종료되면 부모 쉘(zsh에서 확인됨)이 동일한 호출로 전경 상태를 다시 획득합니다.\n","ogImage":{"url":"/assets/img/2024-05-23-Signalsshellsanddockeranonionoffootguns_0.png"},"coverImage":"/assets/img/2024-05-23-Signalsshellsanddockeranonionoffootguns_0.png","tag":["Tech"],"readingTime":15},{"title":"높은 성능의 Swift 앱","description":"","date":"2024-05-23 15:03","slug":"2024-05-23-HighPerformanceSwiftApps","content":"\n두 주 전에 Check ‘em: The Based 2FA 앱을 출시했어요.\n\n그 컨셉은 정말 간단했어요: 정말 멋진 숫자가 나타날 때마다 알림을 보내주는 2단계 인증 앱이에요. 알림을 탭하여 그 숫자를 영구적으로 컬렉션에 추가할 수 있어요.\n\nReddit의 착한 사용자들은 저의 아이디어, 증명 개념, 출시까지를 즐겁게 받아주셨어요. 그래서 저를 프로그래밍 카테고리에서 세 번째로 올려놓게 해주셨어요.\n\n![image](/assets/img/2024-05-23-HighPerformanceSwiftApps_0.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nCheck ‘em은 수백만 개의 2FA 코드를 미래로 계산하고 각 숫자를 처리하여 흥미로운 코드인지 확인하고 푸시 알림(GETs)으로 흥미로운 코드를 예약합니다.\n\nv1.0은 꽤 잘 작동하지만, 오늘은 성능에 집중할 거에요.\n\n제 앱 성능 평가 프로세스는 세 가지 단계로 진행됩니다:\n\n- 실제 기기에서 테스트하여 사용자를 직면한 문제를 식별합니다.\n- 병목 현상을 식별하기 위해 Instruments를 사용하여 앱을 프로필링합니다.\n- 이를 가이드로 사용하여 코드 개선을 구현합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 문제 우선 접근 방식을 통해, 자전거 에관한 논의를 피하고 실제 병목 현상에 집중할 수 있어요.\n\n이 방법을 통해 사용자들에게 혜택을 주지 않는 일반적인 코드 개선에 시간을 낭비하지 않아도 돼요 (그래서 싱글톤이 여전히 사용되는 이유입니다 — 죄송하지만 이대로 가야겠죠).\n\n# 디바이스에서의 테스트\n\n## 처리 속도\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n큰 성능 문제는 바로 여기에 있어요: 2단계 인증 코드를 계산하는 동안 숫자를 처리할 때 발생합니다. 이 처리는 앱에 로그인할 때, 2단계 인증 계정을 변경하거나 GETs 선택 사항을 업데이트할 때마다 실행됩니다.\n\nTOTP 계산 자체는 간단하지 않은 기능으로, 바이트 조작, 문자열 생성 및 암호 작업이 포함됩니다. 이 코드들은 그 후에 여러 가지 흥미로운 유형으로 확인되며, 가장 흥미로운 코드에 대한 푸시 알림을 예약합니다.\n\n이 처리는 사용자가 일반 GETs(예: 004444 또는 123321과 같은 회문)를 활성화한 경우에는 꽤 빠릅니다. 이들 코드 중 몇 개를 하루에 발견할 때, 미래까지 계산할 필요가 없어서 64개의 알림(이OS에서의 한도)을 예약할 때까지 계속 실행됩니다.\n\n사용자가 희귀한 GETs(예: 055555 또는 012340와 같은 근처 계수 순서)를 보고 싶어하는 경우, 총 처리 시간이 10초를 초과할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*e66r8CS6JsTQmQzq_wIytA.gif)\n\nRarity increases exponentially with each tier. With only ultra-rare GETs enabled, such as sexts (e.g. 666666) or counting sequences (e.g. 012345), my screamingly powerful A17 chip takes take over a minute. This increases even more if you only choose one or two ultra-rare options.\n\nAs expected, this is by far the biggest performance bottleneck.\n\n## Time-to-first code\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n앱이 상당히 간단해서 Swift로 1500줄 정도밖에 안 되기 때문에 잠재적 성능 문제의 표면적인 영역은 꽤 제한적입니다.\n\n한 가지 조금 불편한 문제는 앱을 새로 실행할 때마다 발생합니다. 자체적인 런칭이 번개처럼 빠른데, 처음 2FA 코드가 나타나기까지 약간의 시간이 걸립니다.\n\n사용자가 이 앱을 일상에서 2FA 코드로 사용했으면 좋겠기 때문에 유용한 코드가 즉시 나타나면 이 앱의 기능적 사용 사례를 위한 사용자 경험을 향상시킬 것입니다.\n\n![GIF](https://miro.medium.com/v2/resize:fit:1400/1*D1B8yFO7YH8fN6FHT0_NQA.gif)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# Instruments를 이용한 프로파일링\n\n이제 두 가지 주요 사용자 성능 문제를 식별했으므로 Xcode Instruments를 사용하여 자세한 분석을 수행할 수 있습니다. 이 프로파일링을 통해 코드의 병목 현상을 정확히 감지할 수 있습니다.\n\n## Instruments 설정\n\n성능 프로파일링에 새로 오신 분들을 위해 Instruments는 별도의 앱으로, Xcode 개발자 도구 메뉴에서 열 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-05-23-HighPerformanceSwiftApps_1.png\" />\n\n저희의 주요 도구인 Time Profiler는 CPU 코어를 모니터링하는 도구입니다. 이 도구는 초당 1000번씩 이 코어들을 샘플링하며 실행 중인 함수들의 스택 추적을 기록합니다. 결과적으로 나타나는 보고서에는 코드의 어떤 부분이 컴퓨팅 자원을 독식하는지 보여줍니다.\n\n<img src=\"/assets/img/2024-05-23-HighPerformanceSwiftApps_2.png\" />\n\n이제 모든 설정이 완료되었으니 조사를 시작할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 처리 속도\n\n우리 앱을 열고 알림 재계산을 모니터링하면, Check 'em이 흥미로운 코드를 찾을 때 약 20초 정도 소요되는 비동기 프로세스가 실행되는 것을 볼 수 있습니다.\n\n이를 이해하기 쉽게하기 위해 'Call Tree' 메뉴에서 토글할 수 있는 설정이 3가지 있습니다:\n\n- '스레드별 분리'는 기능 호출을 같은 그룹으로 묶는 대신 프로세스를 스레드별로 분리합니다. 이렇게 하면 병렬로 실행되는 프로세스가 개별적으로 시간 프로필이 표시됩니다.\n- 'Call Tree 반전'은 측정된 되추적(traceback)을 반전시킵니다. 즉, CPU에서 실행되는 저수준 iOS 시스템 호출이 아닌 우리 자신의 기능을 호출 스택 상단에 표시할 수 있습니다.\n- '시스템 라이브러리 숨기기'는 시스템 라이브러리 프로세스를 제거하여 보고서를 정리하고 자신의 코드를 쉽게 찾을 수 있도록 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 우리는 예상대로 백그라운드 스레드에서 발생하는 모든 처리 작업을 쉽게 볼 수 있습니다.\n\n우리의 TOTP 생성은 복잡하지만 매우 명확한 알고리즘을 사용합니다. 만약 이를 가속화하는 방법을 개척했다면, 나는 썬더한 어딘가에서 요트 위에서 이 기사를 쓰고 있을 것입니다.\n\n내가 말하려는 것은, 우리가 이 TOTP 생성 과정을 가속화할 수 있는 새롭고 반짝이는 알고리즘을 찾기는 어렵다는 것입니다. 따라서, 우리는 먼저 OTP.init() 메서드보다 느리게 동작하는 모든 것을 개선하고 싶습니다.\n\n우리는 증거를 찾았습니다. 지금까지 가장 느린 계산은 checkThoseSexts() 메서드인데, 이 메서드는 엄청난 계산 비용이 드는 것으로 보이는 정규식을 감싸고 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nextension String {\n    func checkThoseSexts() -> Bool {\n        (try? /(\\d)\\1\\1\\1\\1\\1/.firstMatch(in: self)) != nil\n    }\n}\n```\n\n이런 극도의 부하를 격는 대체 방법으로의 정규식 교체가 성능을 거의 두 배로 향상시킬 수 있을 것으로 생각됩니다.\n\n이 분석을 통해 더 깨달은 것이 있습니다: 이러한 과중 처리는 단일 백그라운드 스레드에서 직렬로 실행되며, 모든 중요한 작업이 고우선순위 인배체 Task로부터 생성된 \\_dispatch_workloop_worker_thread에 전적으로 할당됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n단일 CPU 코어가 TOTP를 생성하고 그들의 흥미로움을 확인하는 역할만 한다는 뜻입니다. 만일 똑똑하게 처리한다면, 이 프로세스는 병렬화될 수 있을 것입니다.\n\n## 첫 번째 코드 작성 시간\n\n다른 사용자가 직면하는 문제는 앱을 열고 유용한 2단계 인증 코드가 표시되기까지의 상대적으로 느린 시간입니다.\n\n코드에서 찾아야 하는 정확한 시작점과 끝점을 알고 있다면 — 앱을 실행하여 처음 나타나는 코드까지 — print() 문과 타임스탬프를 사용하여 이 문제를 프로파일링할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n07:35:54.2640 - 앱 초기화\n07:35:56.0280 - 코드 표시\n\n```\n\n현재 앱은 앱을 초기화한 후 유용한 2FA 코드를 보는 데 매우 큰 1.764초가 소요됩니다. 출시부터 코드 생성까지의 코드 경로를 따르면 더 명확한 그림이 나타납니다:\n\n```js\n07:50:10.5640 앱 초기화\n07:50:11.1980 나타날 때\n07:50:11.2290 계정 설정\n07:50:12.1630 계정 새로고침\n07:50:12.1640 코드 표시\n```\n\n여기에는 두 번의 비교적 긴 대기 시간이 표시됩니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 메인 뷰에서 앱 초기화와 onAppear 작동 사이의 시간\n- 뷰 모델에서 계정 설정 및 TOTP 코드를 얻기 위해 이를 새로 고칠 때의 시간\n\n키체인 작업을 통해 계정을 가져오고 이어지는 코드 생성 단계는 실제로 상당히 빠르기 때문에 총 시간에 큰 영향을 미치지 않습니다.\n\n이제 우리는 주요 성능 병목 현상을 확인했으므로, 정확한 코드 개선을 시작할 수 있게 되었습니다.\n\n# 코드 개선\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nCheck ‘em의 기본 실행에서 두 가지 성능 문제가 발견되었습니다:\n\n- 수백만 개의 TOTP 처리 및 흥미로운지 확인\n- 초기 2FA 코드의 느린로딩\n\n우리의 자세한 분석을 토대로 우리는 다음과 같은 3가지 구체적인 개선점을 발견했습니다:\n\n- 흥미로움을 평가하기 위해 사용되는 regex를 더 효율적인 알고리즘으로 대체합니다.\n- TOTP와 흥미를 계산하는 병렬성을 도입합니다.\n- 초기 코드 생성을 런칭 후 빨리 실행하도록 변경합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 앱에서 얼마나 많은 속도를 뽑아낼 수 있는지 확인해봅시다!\n\n## 효율적인 알고리즘\n\nInstruments를 사용하여 첫 번째 큰 병목 현상은 느린 정규식으로 발견되었습니다. 총 처리 시간의 50% 이상을 차지합니다.\n\n계산에서는 극히 드물게 발생하는 GET만 사용하여 우리의 결과를 벤치마킹해 봅시다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n흔하지 않으니까 이 CPU는 이 흥미로운 GET을 찾기 위해 TOTP를 100배 더 많이 연산해야 해요. 그래서 64개의 흥미로운 GET을 찾는 데는 훨씬 더 오래 걸려요.\n\n우리는 시간을 경신해야 합니다!\n\n이 백그라운드 스레드에서 처리에 47초가 걸렸어요. 여기 정규식에 대한 제 첫 번째 대안을 제시할게요. 간단한 문자열 매치 방법을 사용했어요.\n\n```js\nfunc checkThoseSexts() -> Bool {\n    checkRepeatedDigits(count: 6)\n}\n\n// 쿼드와 퀸트를 확인할 수 있도록 잘 구성되어 있어요\nprivate func checkRepeatedDigits(count: Int) -> Bool {\n    (0...9).map {\n        String(repeating: String($0), count: count)\n    }.contains(where: { self.contains($0) })\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n한 번의 단일 기능 변경으로 섹츄플 확인 작업 자체가 10배 이상 빠르게 동작하여 총 연산 시간이 21초로 줄었습니다. 그래 동작이 두 배 가까이 빨라졌어요!\n\n병목 지점에 집중하는 힘을 보여준 거죠.\n\n저는 멋진 코드를 작성했지만 실제로 상당히 비효율적이에요. 000000부터 999999까지 10개의 문자열을 할당하고, 이후에는 섹츄플용 TOTP를 확인할 때마다 O(n) 문자열 일치 작업을 수행하고 있습니다. 따라서 이 작업은 여전히 TOTP 생성 자체에 이은 두 번째로 무겁고 이루어지고 있어요.\n\n더 간편한 방법이 있습니다. 수 많은 숫자 목록을 하드코딩하는 방식이죠. 이를 통해 비용이 많이 드는 문자열 할당을 반복하는 일을 피할 수 있어요. 우리는 퀘트, 퀸트, 그리고 카운팅을 찾는 무거운 작업에도 동일한 방법을 적용할 수 있어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n// Interestingness.swift\n\nfunc checkThoseSexts() -> Bool {\n    Self.sexts.contains(self)\n}\n\nprivate static let sexts: Set<String> = [\n    \"000000\",\n    \"111111\",\n    \"222222\",\n    \"333333\",\n    \"444444\",\n    \"555555\",\n    \"666666\",\n    \"777777\",\n    \"888888\",\n    \"999999\"\n]\n\nfunc checkThatCounting() -> Bool {\n    Self.counting.contains(self)\n}\n\nprivate static let counting: Set<String> = [\n    \"012345\",\n    \"123456\",\n    \"234567\",\n    \"345678\",\n    \"456789\",\n    \"567890\"\n]\n```\n\nWe’ve handily eliminated the biggest bottleneck: The checkThoseSexts method has gone from a cumulative time of 27.54s to just 899ms — a 30x increase in speed.\n\nNow, this gives me a bright idea.\n\nThere are only 1 million possible 6-digit TOTPs. Perhaps, as an upper bound, 1 in 100 are interesting\\*.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만 가지 숫자는 그리 크지 않아요. 이들을 사전(dictionary)과 같은 효율적 데이터 구조에 저장하고, 메모리에 보관하여 어렵지 않게 처리할 수 있습니다. 이렇게 하면 메모리에서 관심 있는 정보를 O(1) 연산으로 조회할 수 있어요.\n\n게다가, 이 방법은 사용자로부터 연산을 내 맥북에게 넘기고 환경을 보호할 수 있어요.\n\n하지만, 이것은 밝은 아이디어이긴 하지만 병목 현상이 아니에요! 그래서 지금은 안타깝지만 이것을 저지를 것 같아요. TOTP 계산이 처리 시간의 대부분을 차지하고 있거든요.\n\n이것은 CPU 코어를 활용하는 적절한 시기입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 병렬 처리\n\n현재 모든 계산은 단일 백그라운드 스레드에서 수행됩니다. 이를 어떻게 개선할 수 있을지 고민 중이었어요.\n\n자연스러운 아이디어는 TOTP 계산을 '청크 단위'로 분할하고 각 청크를 다른 스레드에 넣는 것일 것입니다. 그런데 이 청킹을 어떻게 적용할 수 있을까요?\n\n일별, 주별 또는 월별로 그렇게 할 수는 없어요. 왜냐하면 우리가 사용하지 못할 정도로 많은 계산을 실행할 수도 있습니다 — iOS에서는 한 번에 최대 64개의 알림을 예약할 수밖에 없거든요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n복잡성을 최소화하는 방법을 찾아봅시다.\n\nCPU 아키텍처를 가이드로 삼아보죠: 현대 iPhone 프로세서에는 6개의 코어가 포함되어 있습니다. 그러므로 동시에 6개의 청크를 사용하는 것을 목표로 합시다. taskGroup을 사용하여 이 6개의 병렬 프로세스를 설정할 수 있습니다.\n\n```js\n// CodeViewModel.swift\n\notpComputationTask = Task.detached(priority: .high) {\n    await withTaskGroup(of: Void.self) { group in\n        (0..<6).forEach { startingIncrement in\n            group.addTask {\n                CodeGenerator.shared.generateCodes(\n                    accounts: accounts,\n                    startingIncrement: startingIncrement\n                )\n            }\n        }\n    }\n}\n```\n\n이후, 이 6개의 병렬 프로세스를 실행하여 미래로부터 매 6번째 TOTP 코드를 계산할 수 있습니다. 각 프로세스는 총 흥미로운 숫자 중 1/6을 찾으면 종료됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```swift\n// CodeGenerator.swift\n\nfunc generateCodes(accounts: [Account], startingIncrement: Int) {\n    var increment = startingIncrement\n    var interestingCodesCount = 0\n    while Double(interestingCodesCount) < (Double(Constants.localNotificationLimit - 2) / 6).rounded(.up) {\n        // TOTP calculation ...\n        increment += 6\n    }\n}\n```\n\n이것은 더 빠르게 처리되는 것 같았지만 완전히 UI가 멈춰 버렸어요. TOTP 코드를 처리하는 동안 앱이 거의 멈추고 응답하지 않았어요.\n\n이는 6개의 고우선순위 프로세스를 한 번에 강제로 일어나게 해서, 메인 스레드가 이 비용이 많이 드는 계산과 렌더링 주기를 공유해야 했기 때문이에요.\n\n이는 6개의 코어를 가진 많은 오래된 아이폰에서 더욱 나빠질 것입니다. 그래서, 프로세스의 수를 CPU 코어당 하나로 제한하고, UI 스레드를 위한 하나의 코어를 여분으로 남겨두는 것이 좋겠어요.\n\n`\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nProcessInfo.processInfo.processorCount - 1;\n```\n\n이야~ 이제 꼭 좋아졌네요! 이렇게 하면 5개의 무거운 작업 쓰레드와 한 개의 아주 차분한 UI 쓰레드가 나올 거예요. 홈으로 돌아가서 손 편지를 쓸 만큼의 지루한 시간은 전혀 없어요.\n\n병렬 처리를 통해 우리가 가장 멀리 호송시키던 쓰레드의 처리속도를 최악 6.74초로 낮춰버렸어요. 이전의 15.37초 대비 56% 감소했답니다.\n\n우리는 5개의 코어를 사용하고 있어요. 왜 이건 깔끔하게 5배 더 빨라지지 않는 걸까요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 수학과 배우들\n\n우리의 방식에는 여전히 문제가 있습니다: 각각의 n개 스레드는 독립적으로 흥미로운 숫자를 찾습니다. 그 숫자는 64/n을 찾을 때까지 계속 찾고 있습니다.\n\n가장 빠른 스레드는 다음 2주 이내에 64/n개의 코드를 모두 찾을 수 있고, 가장 느린 스레드는 운이 나쁘면 다음 달까지 앞으로 계속해서 계산할 수 있습니다 — TOTPs는 30초 간격으로 배치되어 있으며 코드의 흥미로움은 무작위로 분포됩니다.\n\n이 문제는 두 가지 측면으로 나뉩니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 먼저, 일부 스레드에서 숫자를 너무 많이 세고, 다른 스레드에서는 너무 적게 세어 잠재적인 숫자들을 놓치고 있습니다.\n- 둘째, 스레드가 처리하는 시간이 매우 다르기 때문에 각 스레드가 정확히 동일한 시간을 소요하는 것에 비해 CPU를 효율적으로 활용하지 못하고 있습니다.\n\n이에, 각 스레드가 독립적으로 실행되어 다음 미계산 코드를 계산하도록 하는 대신, 오프셋에서 작업하는 대신 다음 미계산 30초 날짜 증가를 사용하도록 보장하고 상태를 안전하게 공유할 수 있는 방법이 필요합니다.\n\nSwift는 이 문제에 Actors로 깔끔한 해결책을 제공하며, Actors는 상태에 대한 직렬 액세스를 강제합니다.\n\n```js\n// CodeIncrementor.swift\n\nactor CodeIncrementor {\n\n    private var _increment: Int = 0\n\n    func increment() -> Int {\n        defer { _increment += 1 }\n        return _increment\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n첫 번째 병렬화 시도와 비교했을 때, 각 스레드가 독립적으로 모든 5번째 TOTP를 계산하는 것을 허용했던 방법과 달리, 이 접근 방식은 프로세스 간의 조정이 필요합니다.\n\n이 조정은 추가 오버헤드를 발생시킵니다. 각 프로세스는 개별적으로 약간 느려지며, 이는 액터의 시리얼 익스큐터에서 increment()를 호출하기 위해 기다려야 할 수 있기 때문입니다. 한 번에 한 프로세스만이 이를 호출할 수 있습니다.\n\n결과적으로 increment()가 호출될 때마다, 스레드는 올바른 오프셋을 안전하게 얻을 수 있으므로, 우리는 다음에 계산되지 않은 TOTP 코드만 계산하여 그 흥미로움을 평가할 수 있습니다.\n\n```js\n// CodeGenerator.swift\n\nfunc generateCodes(accounts: [Account], incrementor: CodeIncrementor) async {\n    // ...\n    while Double(await incrementor.codes) < (Double(Constants.localNotificationLimit - 2)) {\n        let increment = await incrementor.increment()\n        // 날짜 증분에서 TOTP 생성 ...\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이것이 얼마나 성능을 발휘하는지 측정해 봅시다!\n\n이 액터 기반 접근 방식은 한 번에 여러 개의 스레드를 생성합니다. Swift 동시성은 CPU 코어 당 대략 하나의 스레드가 실행되도록 하여 초기 병렬성 목표에 부합하며, 시스템 인식 협력 스레드 풀을 사용하여 스레딩을 관리합니다.\n\n기기의 instruments에서 제공된 총 누적 실행 시간은 각 스레드별로 합산된 것입니다. 이는 물론 사용자가 기다리는 시간을 대변하는 것은 아닙니다. 적절한 측정을 위해 다시 한 번 신뢰할 수 있는 타임스탬프를 사용하여, 초희귀 GET에 대한 흥미로움 계산의 총 속도를 측정해 봅시다.\n\n## 병렬성이 없는 원래 스피드\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n23:10:55.2940 Computation 시작\n23:11:09.9220 Computation 완료\n\n총 14.628초 소요됐습니다.\n\n## 청킹과 (n-1) 쓰레드를 사용한 속도\n\n23:07:00.4700 Computation 시작\n23:07:09.5980 Computation 완료\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n9.128 seconds in total.\n\n## Actor 협조를 사용한 속도\n\n```js\n23:01:38.7080 계산이 시작됨\n23:01:46.5300 계산이 완료됨\n```\n\n7.822 seconds in total.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이것은 액터를 사용하여 추가 쓰레드 조절 오버헤드를 감당할 가치가 있다는 것을 보여줍니다. 이 프로세스는 더 정확하고 CPU 코어를 더 효율적으로 활용하며, 전체적으로 이 계산 단계를 47% 빠르게 만듭니다!\n\n# 이전 코드 생성\n\n우리의 성능 프로파일링의 마지막 단계에서, print 문과 타임스탬프를 사용하여, 우리의 유저들에게 유용한 2단계 인증 코드가 나타나기 전에 두 가지 큰 대기 상태를 발견했습니다: 메인 뷰에서 onAppear를 기다리는 것과 코드 자체를 refresh() 하는 것을 기다리는 것입니다.\n\n```js\n// CodeView.swift\n\n@State private var viewModel = CodeViewModel()\n@State private var timer = Timer.publish(every: 1, tolerance: 0, on: .current, in: .common).autoconnect()\n\nvar body: some View {\n    // ...\n    .onReceive(timer) { _ in\n        viewModel.refresh()\n    }\n    .onAppear {\n        refreshUI()\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n먼저 onAppear가 나타나도록 기다렸다가 뷰 모델에서 계정을 설정하고, 1초 타이머가 작동할 때 다시 기다립니다.\n\n이는 매우 간단한 수정입니다: 뷰 수명주기 이벤트에서 계정 가져오기 및 TOTP 계산을 분리합니다.\n\n```js\n// CodeViewModel.swift\n\nfinal class CodeViewModel {\n\n    init() {\n        timestamp(\"View model init\")\n        configureAccounts()\n        refresh()\n    }\n\n// ...\n```\n\n앱 로드와 코드 생성 간의 시간이 1.764초에서 0.400초로 대폭 줄어듭니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n20:41:35.6890 앱 초기화\n20:41:36.0830 뷰 모델 초기화\n20:41:36.0890 코드 표시됨\n```\n\n이제 코드들이 거의 즉시 화면에 나타납니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*Z78ZtydZwUrguRDZel0d1w.gif)\n\n# 결론\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nCheck ‘em — The Based 2FA App은 제가 사이드 프로젝트로 만들었던 열정적인 아이디어였는데, 정말 즐거운 시간을 보냈어요.\n\n제가 기대하지 못한 것은 두 번째(v1.1) 릴리스의 중심에 극도로 흥미로운 성능 최적화 퍼즐을 만날 것이었다는 것이에요.\n\n지금은 앱이 최고로 돌아가고 있어요:\n\n- 2FA 코드가 시작하자마자 나타나요.\n- 흥미로운 코드를 찾는 알고리즘이 훨씬 빠릅니다.\n- 강력한 멀티 코어 CPU가 병렬 계산으로 완전히 활용되고 있어요.\n","ogImage":{"url":"/assets/img/2024-05-23-HighPerformanceSwiftApps_0.png"},"coverImage":"/assets/img/2024-05-23-HighPerformanceSwiftApps_0.png","tag":["Tech"],"readingTime":22},{"title":"안녕하세요 안드로이드 프로젝트에서 자주 마주치는 성가신 문제들을 살펴보겠습니다 함께 해요","description":"","date":"2024-05-23 15:00","slug":"2024-05-23-AnnoyingproblemswithAndroidmobileanyprojects","content":"\n한 회사에서 오래 일하지 않으면 다양한 단계의 여러 프로젝트에 참여할 기회가 많지 않을 수 있습니다. 이러한 경험을 통해 작은 개인 프로젝트나 대규모 기업의 어려움을 보게 될 수 있습니다.\n\n많은 문제가 종종 무시되고 이로 인해 예상치 못한 문제나 버그가 발생할 수 있습니다. 이 중 일부는 매우 쉽게 해결할 수 있고 프로젝트를 조금 더 쉽게 이어나갈 수 있게 해줍니다. 여기에는 대부분 안드로이드 애플리케이션 개발과 관련된 권장 사항이 포함되어 있지만 대부분의 내용은 어떤 기술의 프로젝트에도 적용됩니다. 이것은 대부분 개인 경험과 실패의 모음인데, 다른 사람의 실수로부터 배우는 것이 더 재미있지 않을까요?\n\n# 프로젝트 구조\n\nIDE가 처음부터 새 프로젝트를 생성하면 프로젝트에 불필요하거나 방해가 되는 많은 파일과 폴더가 생성될 수 있습니다. 여기서 기본 구조와 작업해야 하는 구성 요소를 이해하는 것이 중요합니다: 모듈, 구성, 아무도 작성하지 않을 테스트 😁\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n.gitignore 파일을 살펴보면, 대략 20-30개의 규칙이 있을 겁니다. 대부분이 다섯 가지 경우에 사용되지만, 그 중에도 종종 부적절하게 기재된 경우가 많습니다. local.properties가 프로젝트에 추가된 적이 있다면, 실제로는 무시 목록에 포함되어 있지만 IDE가 신경을 쓰지 않을 수도 있습니다. 그런 소프트웨어를 믿을 이유가 있을까요?\n\n언제나 더 나은 방법이 있을 수 있습니다. 한 회사에서 첫 근무일에 안드로이드(1.5GB)와 iOS(4.5GB) 저장소를 다운로드해야 했던 적이 있었습니다. 문제는 선배들이 Google Play에 업로드된 애플리케이션의 모든 버전을 프로젝트에 커밋했기 때문에 저장소가 비합리적으로 커진 것이었습니다. 이 프로젝트를 빌드하고 몇 가지 테스트를 실행해야 할 때마다 CI/CD가 이 프로젝트를 클론해야 하는 상황을 생각해보세요 😉\n\n내가 알기로는 각 빌드에는 대략 40분이 걸렸던 것 같네요. 가장 흥미로운 점은 git 히스토리를 정리함으로써 해결할 수 있다는 것이었습니다. 실제로 이것을 시도해 보았고, 그 결과 프로젝트 크기가 1.5GB대 대신 100MB가 되었습니다. 그러나 이것이 최종적으로 해결되었는지 여부는 저에게는 알 수 없습니다.\n\n![안드로이드 모바일 프로젝트에서의 귀찮은 문제들](/assets/img/2024-05-23-AnnoyingproblemswithAndroidmobileanyprojects_0.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n지난에 개발한 기능 중 하나로 프로젝트에서 천 개 이상의 파일을 제거했어요. 클릭베이트 제목으로 좋을 거예요, 하지만 실제로는 훨씬 간단해요 — 이전 담당자가 TypeScript 프로젝트를 Android 프로젝트로 복제했을 때, 전체 node_modules 폴더를 커밋하지 않고 얼마 전 사용한 노드 모듈 폴더(.gradle이나 build 폴더와 유사한)를 포함했어요. 왜냐고요? 다행히 매달 또는 두 달에 한 번 특별한 파일을 생성하고 그 파일을 프로젝트에 사용할 수 있게 하기 위해서예요. 왜 별도의 IDE에서 프로젝트를 열고 거기서 코드 생성을 하지 않을까요? 저도 잘 모르겠어요.\n\n![2024-05-23-AnnoyingproblemswithAndroidmobileanyprojects_1.png] (/assets/img/2024-05-23-AnnoyingproblemswithAndroidmobileanyprojects_1.png)\n\n좋은 방법 중에 템플릿이 언급될 수 있어요. 이 기능 덕분에 프로젝트를 한 번 생성하고 필요에 딱 맞게 만들어진 구조를 사용할 수 있어요. 특히 많은 마이크로서비스를 보유한 회사에게 관련이 있어요.\n\n# 읽어볼 내용이 없어요\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-05-23-AnnoyingproblemswithAndroidmobileanyprojects_2.png\" />\n\n프로젝트를 열 때 빌드되지 않는 문제에 대한 이야기를 남겨보세요. 또는 몇 시간 동안 그 문제를 해결하기 위해 애쓰게 되는 경험에 대해 이야기해보세요.\n\n한 번만 개발 환경을 설정하는 데 도움을 받을 수도 있지만, 새 노트북을 사용하거나 새로운 동료가 합류할 때마다 동일한 문제가 반복되곤 합니다.\n\nREADME를 만들기 위해서만 만드는 것은 가치가 없죠. 종종 적절한 명명법으로 이미 명확한 모듈 설명이나 2년 전에 유효했던 문서들을 볼 때가 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n누군가가 모바일 개발자가 아닌 사람이 모바일 프로젝트를 열면, 반대의 경우도 마찬가지지만, 무언가를 빌드할 수 없다면 먼저 README를 확인할 것입니다. 특히 iOS 프로젝트에서는 여전히 pods를 사용하는 경우나 Docker 또는 다른 설정이 많이 필요한 프로젝트의 경우에 이는 특히 흔합니다.\n\n꽤 좋은 습관은 그 공정들과 모든 스크립트들을 설명하는 것입니다. 그 공정들이 뒷담화처럼 작동하는 것에 대해, 그것들을 자동화하기 위해 한 주 동안을 쏟아부었지만 한 시간 안에 할 수 있는 일을 한 주 쏟아 부을 수도 있습니다.\n\n# 설정 파일 없음\n\n불일치하는 간격으로 커밋을 자주 보곤 했나요? 동료들이 코드를 마음대로 서식을 맞추다보면 모든 것이 엉망이 되고, 다음 코드 리뷰에 +100500줄을 추가하는 일이 벌어지곤 했나요? 또는 변경된 파일마다 imports가 뒤죽박죽이 되어 충돌을 수동으로 해결해야 하는 경우가 있긴 했나요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n모든 이슈는 코드 스타일, EditorConfig 및 정적 분석과 함께 Reformat 코드 기능으로 쉽게 해결할 수 있어요.\n\n가장 중요한 점은 귀하의 팀(또는 권한이 충분하다면 개인적으로)이 특정 규칙을 모두가 동일하게 준수해야 한다고 결정하고 이를 따르아야 한다는 것입니다. 이러한 구성은 프로젝트에 추가되어 IDE가 모두에게 동일한 설정을 지정할 수 있게 합니다. 코드 포맷팅 덕분에 수입, 들여쓰기, 형식 지정 및 일반적으로 코드 리뷰 중에 거슬리는 다른 사항들에 대한 문제가 더 이상 발생하지 않을 거예요.\n\n# 의존성 업데이트\n\n![의존성 업데이트](/assets/img/2024-05-23-AnnoyingproblemswithAndroidmobileanyprojects_3.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 귀찮은 일에 대해 신경 쓸 필요는 없을 수도 있지만, 고객은 생산성에서 안정성을 요구할 것입니다... 기술적 부채 티켓을 만들어 동료 / 관리자 / 고객에게 이 단계의 중요성을 설명해 보는 게 좋겠죠. 이런 문제가 있는 여러 프로젝트를 상기하며, 개인적으로 문제를 겪었던 한 가지 사례가 있었어요 :)\n\nGoogle은 단순히 targetSDK를 올리지 않으면 업데이트를 거부했는데 (안드로이드 개발자들에게 큰 고통이었습니다), 이 지원에 상당한 시간이 필요했죠. 그래서 모든 노력이 새로운 OS 버전 지원이 추가된 앱의 새 버전을 준비하는 데 집중되어, 클라이언트는 제때 업데이트를 받지 못했어요.\n\n또한 특정 사용자들이 구글 라이브러리 버전의 버그로 인해 충돌이 발생하기도 했었는데, 매우 드문 일이었지만 실제로 발생했습니다. 그 버그는 스택 트레이스를 남겨두었는데 원인이 명확하지 않았어요. 라이브러리를 업데이트하고 나서 그 충돌은 발생하지 않았습니다.\n\n한 번은 프로젝트에서 난독화가 활성화되어 있었는데, 긴급하게 업데이트를 릴리스해야 해서 GSON을 업데이트하지 않고 AGP만 업데이트했던 적이 있었어요. 라이브러리를 업데이트하려면 특정 이주가 필요했습니다. 문제는 테스터들이 조금 다른 앱 버전을 가지고 있었고, 그것이 나중에 Google Play에 릴리스된 것이었지만 라이브러리는 새 AGP 규칙을 준비하지 못했단 거죠. 그 결과, 난독화로 네트워크 모델의 필드가 제거되었습니다. 충돌은 없었지만 앱의 주요 기능이 중단되어 데이터의 절반이 손실된 채로 남았습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 건축의 부재/“건축”의 존재\n\n아, 파트타임 직업 또는 더 나쁜 경우, 본 업무에서 프로젝트를 열고 난 후, 필요한 파일을 찾을 수 없거나 프로젝트에 있는 전반적인 기능을 이해하는 데 고난을 겪고 있는 상황이군요. 다중 모듈 아키텍처, 추상화, 깔끔한 코드? 그런 건 잊어버리세요. 나중에 아무도 읽지도 유지 보수하지도 않을 거고, 일 년 후에는 버려지고 처음부터 다시 쓰여질 가능성이 높습니다. 그렇게 된다면 괜찮겠지만, 분명히 당신 다음에 누군가 새로운 기능을 추가할 것이고 그 후에 젠장할 것입니다.\n\n한 번, 고객이 6개월 동안 6명의 다른 사람들에 의해 작성된 약 열 개의 문제를 고치라고 요청했던 적이 있었습니다. 어려웠나요? 그런 것은 별로 어렵지 않았습니다. 왜냐하면 프로젝트 자체가 기술적으로 복잡하지 않았기 때문이죠. KMM에서 상업적 경험이 전혀 없는 사람들이 작성했으며, 앱 자체는 주요 복잡성이 항상 비즈니스 로직에 있었습니다. 그래서 대부분은 보이기-편집하기-보내기-다시 모든 것을 보이는 종류의 앱이었습니다.\n\n이 프로젝트에서 가장 큰 문제는 유증의 열망이 놀랍게도 있었다는 것이었습니다. 매우 단순하고 명백한 기능마다 함수 입력 매개변수를 사용할 수 있는데도, 사용 사례가 만들어지고 한 번만 사용되었습니다. 더 나쁜 점은 수량조차 것이 아니라 여러 사용 사례의 카스케이드 사용이었는데, 디버깅을 믿을 수 없을 정도로 어렵게 만들었으며, 브레이크포인트의 수가 IDE를 넘도록 압도했습니다. 그 뿐만 아니라 이러한 것들은 비동기 함수조차 아니라 예전의 콜백 지옥이었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![image](/assets/img/2024-05-23-AnnoyingproblemswithAndroidmobileanyprojects_4.png)\n\n# 댓글\n\n지혜로운 사람들은 코드가 주석 없이도 명확해야 한다고 말합니다. 그렇게 해야 한다는 조언은 귀중하지만 비즈니스에서 요구사항이 나타나면 완벽한 코드에 큰 지팡이를 삽입해야 한다는 요청이 옵니다. 지금 이 작업을 기억하지만 한 달 후 성공적으로 잊을 겁니다.\n\n무언가를 문서화해야 한다고 생각된다면, 그것이 다소 명백하다 해도 수행해야 합니다. 그리고 올바른 Git 전략과 관련하여, 나중에 요구사항을 쉽게 파악하고 코드를 작동 상태로 유지하는 지팡이가 무엇인지 이해할 수 있게 됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-05-23-AnnoyingproblemswithAndroidmobileanyprojects_5.png\" />\n\n# 정적 분석\n\n하지만 모든 동료가 코드를 완벽하게 서식 지정하기 위해 두 개의 버튼을 누를 것은 아닙니까? 그래서 프로젝트에 린터를 설정하는 가치가 있습니다. 전반적으로 그들은 좋은 목적을 갖고 발명되었으며 릴리스 시에 끄지 않도록 해야 합니다.\n\n정적 코드 분석 덕분에 사람 눈으로는 보이지 않거나 단순 부주의로 인해 발생할 수 있는 다양한 종류의 버그를 예방할 수 있습니다. 프로젝트에서 표준 Android 린터를 사용하여 리소스 관련 문제에 대해서는 꽤 좋거나 코드에 대한 추가적인 린터를 사용할 수 있습니다. 저는 현재 ktlint를 사용 중이며, 프로젝트마다 동반되는 제 자체 gradle 플러그인과 .editorconfig를 사용하여 코드 분석을 수행합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n팀원 전체에 이메일을 보내고, 모든 빌드가 초록색이 될 때까지 코드 리뷰를 하지 말겠다는 합의를 한다는 것은 코드 청결도에 대한 좋은 동기부여가 될 수 있습니다.\n\n![AnnoyingproblemswithAndroidmobileanyprojects](/assets/img/2024-05-23-AnnoyingproblemswithAndroidmobileanyprojects_6.png)\n\n# 프로젝트 속 쓰레기\n\n프로젝트를 여는데, 알 수 없는 개발자가 넣은 무서운 라이브러리가 있고, 이를 이 프로젝트로 끌어들인 동료는 이제 오랫동안 프로젝트를 떠난 자이며, 당신의 차례로 영어로 된 메뉴얼을 읽어야 할지도 모릅니다. 이를 경험하지 못한 경우 정말 운이 좋습니다! 저는 그렇게 운이 좋지 않았으니, 최근 기억에 남는 몇 가지 사례를 소개해 드릴게요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n현재 프로젝트에서는 난독화가 없으며, 앱은 다이어트를 해야 할 것 같아요. 호기심에 한 번 앱의 용량을 확인해보았더니 익숙하지 않은 폴더가 5-6MB 가량 있었는데 APK 자체는 52MB만 있더라구요. 의존성을 확인하고 구글링을 좀 해보니 PDF 파일을 표시하기 위한 라이브러리라는 것을 알게 되었는데, 추가 의존성도 몇 메가 바이트에 달하는 크기였어요. 만약 고유한 프로젝트이거나 최대한 유연성이 필요한 경우였다면 납득할 만했겠지만, 안 들리는데로 PDF를 표시하기 위한 기능은 이미 안드로이드 SDK에 있는 것을 이미 알고 있는 거죠. 총알 문서를 읽고 프로그래밍을 한 시간 했더니 모든 것이 정말 원활하게 작동했어요. 한 시간 뒤에는 삭제된 컴포넌트를 찾아내게 되어 앱이 총 12MB나 다이어트를 성공한 셈이 되었어요.\n\n작년 이맘때부터 White Label 원칙에 따라 만든 하이브리드 애플리케이션에 대해 일해오고 있는데, 이 해결책은 거의 모든 고객에게 적용할 수 있지만 특정 구성을 통해 다른 클라이언트를 위해 기능을 맞춤화하고 확장할 수 있어요. 많은 도전이 이미 있었는데, 그 중 하나는 Compose를 사용하여 화면 탐색을 하는 라이브러리였어요. 이 솔루션을 사용하는 것이 간단하다고 말하기는 조금 과장되었을 것이고, 조금 전에 팀이 해당 라이브러리를 프로젝트에서 제거할 계획이라는 것을 알게 되었어요. 안드로이드에서 탐색을 한 번 다뤄본 적이 있다면, 단계적으로 할 수 있는 것이 아니라 한꺼번에 모든 것을 이주해야 하는 과정이 필요하다는 것을 이해하실 겁니다. 알 수 있는 한, 프로젝트에 대한 부적절한 의존성 선택은 장기적으로 도태되는 손해를 일으킬 수 있습니다.\n\n![annoyingproblemswithAndroidmobileanyprojects](/assets/img/2024-05-23-AnnoyingproblemswithAndroidmobileanyprojects_7.png)\n\n### 난독화 없음 / 리소스 축소\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n많은 개발자들이 이러한 설정을 조정하는 것을 정말 싫어합니다. 앱을 심각하게 망가뜨릴 수 있기 때문에 그것들을 비활성화하고 테스트를 시작할 때까지 어디가 문제인지 알 수 없을 수도 있습니다. 또한, 여러 사용하지 않는 자원을 제거할 수 있게 해주어서 애플리케이션의 크기에 상당한 영향을 미칩니다. 특히 Compose를 사용할 때 그 효과가 좋습니다.\n\n![이미지](/assets/img/2024-05-23-AnnoyingproblemswithAndroidmobileanyprojects_8.png)\n\n# Git 전략이 없음\n\nParticular Software의 분산 시스템 디자인 기초 과정에서는 기업의 창립자가 개발 경험이 15년 이상인 사람들에게 커밋의 이름 짓는 것이 매우 중요하다고 얘기합니다. 아니요, 농담이 아닙니다. 이 문제는 일반적으로 자주 언급되지 않지만 개발 과정에서 매우 중요합니다. \"수정\"이라는 텍스트로 커밋을 푸시할 수 있는 상황에서 꼭 신중하게 작성해야 할까요? 좀 더 자세히 살펴보겠습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n먼저, 브랜치 명명에 대해 알아보겠습니다. 프로그래머들은 종종 대량의 코드 개정을 동시에 다루는데, 현재 보고 있는 코드 버전이 무엇인지 정확히 이해하는 것이 중요합니다. 올바른 브랜치를 찾아야 하거나 비슷한 이름을 가진 여러 개의 브랜치 중 하나를 선택해야 할 때, 때로는 필요한 종류를 찾아야 할 수도 있는데, 이는 혼란스럽고 시간이 오래 걸릴 수 있습니다. 팀이 특정 유형의 구조에 합의했다면, 모든 것을 간단하게 만들 수 있습니다. 이 경우 cicd/sonar-cube-check-implementation 또는 bugfix/superuser-right-are-not-properly-assigned, 또는 feature/property-detail-screen과 같은 네이밍 규칙은 각 브랜치에 무엇이 있는지 논리적으로 이해하는 데 도움이 됩니다.\n\n또한 GitHub, JIRA 또는 다른 도구와 같은 이슈 추적 시스템과 버전 관리 시스템 간의 강력한 통합에 대해 이야기해볼 가치가 있습니다. cicd/123-sonar-cube-check-implementation과 같이 브랜치를 명명하면, 여기서 123은 이슈나 티켓 번호이며, 시스템은 자동으로 이를 연결하여 해당 이슈 범위 내에서 어떤 변경 사항이 있었는지와 현재 브랜치 상태를 확인하는 데 도움을 줍니다. 항상 혼란을 예방하는 것은 아니지만, 한 번 EM이 티켓에서 브랜치가 병합되었음을 보고 클라이언트에게 전달했지만, 프로젝트가 무언가 문제를 일으키는 git 전략을 가지고 있어 잘못된 위치로 병합되었음을 못 봤던 적이 있었죠. 하지만 상황을 빠르게 이해하는 데 도움이 되죠.\n\n커밋 메시지에 대해 이야기해보자면 - 주로 한 두 단어만 적힐 때가 많은데도 50개의 파일이 변경될 수 있습니다. 이제 한 브랜치에 10개의 커밋이 있다고 상상해보세요. 그리고 10개의 커밋이 모두 \"fixes\"라고 한다면 어떨까요? :)\n\n순전히 실용적인 관점에서, 동료들을 통해 경험적으로 테스트한 결과, 다음 유형의 통합이 상당히 잘 작동하는 것으로 밝혀졌습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n테이블 태그를 마크다운 형식으로 변경해주세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 브랜치 가시성: 작업 X를 나타내는 브랜치가 사라지지 않아요. 매니저는 개발자가 작업 상태를 업데이트하는 것을 잊어도 언제든지 작업이 진행 중인지 완료된 상태인지 확인할 수 있어요.\n- 작업 기록: 작업 X에서는 6개월 지난 후에도 완료하기 위해 변경된 모든 파일을 찾을 수 있어요. \"이 작업 기억 나요? 다시 모두 다시 해야 해\"라는 비즈니스 요구가 오더라도 변경된 로직을 찾는 데 시간을 낭비할 필요가 없어요. 나중에 이 작업을 수행하는 다른 사람들이 있더라도 작업 기록에 액세스하여 관련 히스토리를 확인하기 쉽게 해요.\n- 명확한 커밋 메시지: 각 커밋은 명확하게 설명되고 작업에 연결돼요. 작업이 커밋 하나로 완료됐더라도, 나중에 개발자가 변경이나 추가 사항이 필요하다는 것을 깨달아 작업 X의 일부인 경우가 있어요. 그럼 이런 경우에는 히스토리에 작업 X와 관련된 두 개의 커밋이 남아 있어요.\n- 커밋 사이의 이동이 쉬워요: 큰 기능이 포함된 10개의 커밋이 있는 상황을 상상해보세요. 어떤 중요한 부분을 찾아야 할 때나 기능이 어디서 망가졌는지 확인해야 할 때 유용해요. 특히 큰 기능이나 오랜 기간동안 중요한 정보를 찾아야 할 때는, 구조화된 메시지에서 한 단어 메시지보다 요지를 파악하기 훨씬 쉬워요.\n\n당연히 이 방법이 여러분과 팀에 적합하지 않을 수도 있지만, 어떤 형태로든 존재함으로써 팀의 작업을 크게 간소화할 수 있어요.\n\n![Annoying problems with Android mobile any projects](/assets/img/2024-05-23-AnnoyingproblemswithAndroidmobileanyprojects_9.png)\n\n# CI/CD 설정 오류 및 미구성\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n한 번 인터뷰 중에, 어떤 개발자가 CI/CD가 필요하지 않다고 주장했어요. 그 이유는 자신의 노트북에서 어플리케이션을 원활하게 빌드할 수 있도록 도와주는 작은 스크립트가 있기 때문이라고 했어요. 실제로 그의 주장은 옳았습니다. 그가 이 프로세스를 최적화하고 완벽한 빌드를 격리된 환경에서 작업할 수 있었으니까요. 그러나 보다 심각한 프로젝트에 대해서는 CI/CD가 꼭 필요하고 시간을 절약할 수 있어요.\n\n예를 들어, 하나의 화이트라벨 제품을 다루는 회사가 있었는데, 이 제품은 여러 가지 설정을 가지고 있었고 수작업으로 배포 과정이 매우 느렸어요. 어플리케이션을 빌드하고 필요한 곳에 배포하는 것을 상상해보세요. 일반적으로 이 프로세스는 수작업으로 약 10분이 소요되었습니다. 그런데 만약 20개, 50개, 100개 이상의 어플리케이션이 필요하다면 어떨까요? 그리고 이미 테스트된 것이 출시 준비가 된 상태인데도 개발자가 휴가 중인 경우 어떡하죠? CI/CD 덕분에 이 프로세스를 자동화하고 최대한 빠르게 만들었어요. 병렬화를 통해 모든 클라이언트가 15분 내에 배포를 받을 수 있게 되었죠. 비즈니스에게는 모든 것을 자동화하는 것이 편리하고, 개발자에게는 단조로운 작업을 하지 않고 해낼 수 있는 점이 편리합니다.\n\n또한 모바일 데브옵스 같은 사람들이 이러한 프로세스를 설치하는 경우가 있다는 것도 언급할 가치가 있어요. 멋진 회사에서는 이들이 모바일 작업방식을 잘 이해하고 필요한 모든 작업을 처리하는 똑똑한 사람들입니다. 그런데 모든 사람이 그만큼 능숙한 것은 아닐 수 있어요. 미국 스타트업에서 안드로이드 아키텍트로 일했을 때, 빌드 컴파일 시간에 상당한 영향을 미치는 문제를 발견했습니다. 기억하시다시피, assemble이라는 gradlew 작업이 있어요. 기본적으로 모든 버전의 어플리케이션을 빌드합니다. 한 번에 빌드하는 데 15분이 걸린다면, 어플리케이션이 2가지 설정이 있다면 이 작업은 필요한 하나만을 빌드하는 데 1시간이 걸릴 거예요. CI/CD 파이프라인 관점에서 모든 것이 잘 설정되어 있었지만, 이 필요성을 이해하고 올바른 구성 조정을 할 수 있는 사람은 모바일 개발자만 알 수 있는 사실이죠.\n\n<img src=\"/assets/img/2024-05-23-AnnoyingproblemswithAndroidmobileanyprojects_10.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n지금까지 여기까지입니다. 목록이 완전하지 않고 무작위이며 추가할 주제가 있습니다. 개발자가 APK를 이메일로 보내거나 슬랙에 게시하는 프로젝트를 진행해본 적이 있다면 댓글에 작성해 주세요. 또한 다른 프로젝트에서 자주 마주치는 문제를 공유해주세요.\n","ogImage":{"url":"/assets/img/2024-05-23-AnnoyingproblemswithAndroidmobileanyprojects_0.png"},"coverImage":"/assets/img/2024-05-23-AnnoyingproblemswithAndroidmobileanyprojects_0.png","tag":["Tech"],"readingTime":16}],"page":"69","totalPageCount":119,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":3},"__N_SSG":true}