{"pageProps":{"post":{"title":"시간 시리즈 확률 예측을 위한 Conformal Predictions 방법 완벽 가이드","description":"","date":"2024-06-30 22:21","slug":"2024-06-30-ConformalPredictionsforTimeSeriesProbabilisticForecasting","content":"\n\n<img src=\"/assets/img/2024-06-30-ConformalPredictionsforTimeSeriesProbabilisticForecasting_0.png\" />\n\n샘플 eBook 챕터(무료): [여기](https://github.com/dataman-git/modern-time-series/blob/main/20240522beauty_TOC.pdf)\n\nTeachable.com에서의 eBook: $22.50 [여기](https://drdataman.teachable.com/p/home)\n\nAmazon.com에서의 인쇄판: $65 [여기](https://a.co/d/25FVsMx)\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n실제 세계 응용 프로그램 및 계획에는 포인트 추정이 아닌 확률적 예측이 필요합니다. 확률적 예측 또는 예측 불확실성이라고도 하는 확률적 예측은 계획자에게 불확실성의 감을 줄 수 있습니다. 그러나 선형 회귀, 랜덤 예측 또는 그래디언트 부스팅 머신과 같은 전형적인 기계 학습 모델은 가능한 값의 범위가 아닌 평균 추정을 생성하도록 설계되었습니다. 이 책이 관심을 갖는 것은 점 추정에서 예측 구간으로 발전하는 과정이며, 현대의 시계열 모델링 기술이 이에 관심을 가지고 있습니다. 확률적 예측 시리즈에서는 'Monte Carlo Simulation for Time Series Probabilistic Forecasting'에서 Monte Carlo 시뮬레이션 기법 및 'Quantile Regression for Time Series Probabilistic Forecasting'에서 분위 회귀 기법을 소개했습니다. 이 장에서는 다른 인기있는 방법인 Conformal Prediction (CP)을 소개하겠습니다.\n\nCP를 기본적인 예측 맥락에서 설명해 보겠습니다. 우리는 예측 모델의 목표가 조건부 평균에 대해 편향되지 않은 추정을 제공하는 것이라는 것을 알고 있습니다. 예측 값과 실제 값 간의 차이를 오차라고 합니다. 이 오류들은 무엇일까요? 모델이 확실하지 않은 불확실성입니다. 그렇다면 어떻게 불확실성을 양적으로 표현할까요? 이 질문의 답은 질문 자체에 있습니다. 추정 값과 실제 값 사이의 오차는 불확실성을 나타내며, 우리는 이 오류를 분석하여 불확실성을 양적으로 나타낼 수 있습니다. 그런 다음 예측값에 양적으로 측정된 불확실성을 더하거나 뺌으로써 예측 구간을 계산합니다. CP는 새로운 예측에 대한 자신감 수준을 결정하기 위해 이전 데이터를 사용합니다. CP는 새로운 예측이 예측 범위 내에 있을 확률 (예: 95%)을 보장합니다. 특정 모델을 언급하지 않았음에 주목하십시오. 따라서 CP는 모델에 관계없이 작동합니다.\n\nCP의 구성은 다음과 같습니다:\n\n- 오류는 실제 값과 예측 값 사이의 절대값입니다. 예측 값과 실제 값 사이의 오차를 작은 것부터 큰 것까지 나열할 것입니다. 히스토그램을 사용하여 오차 값의 비율을 표시할 것입니다.\n- 대부분의 경우, 예를 들어 95%의 경우, 오류는 임계값 이하일 것입니다. 이 임계값은 예측 오류에 대한 용인 값으로 간주할 수 있습니다. 이 임계값은 예측에서 해당 실제 값까지의 오류가 95%의 경우 임계값 아래에 있을 것이라는 뜻입니다.\n- 따라서 예측값에 허용 오차를 더하거나 빼면 해당 예측에 대한 예측 구간을 얻을 수 있습니다. 이는 우리가 예측한 실제 값이 예측 구간 내에 존재할 확률이 95%라는 것을 의미합니다. 그림 (A)는 일치 예측의 구성을 보여줍니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Conformal Prediction Procedure](/assets/img/2024-06-30-ConformalPredictionsforTimeSeriesProbabilisticForecasting_1.png)\n\n이 예측 간격을 찾는 프로시저는 Conformal Prediction (CP) 전략입니다. 모델 사양과 기본 데이터 분포에 대한 가정을 하지 않는다는 점에 유의하십시오. CP는 모델에 구애받지 않으며 — 모든 모델링 기법과 함께 작동합니다. Conformal Prediction 기술은 Volodya Vovk, Alexander Gammerman, 그리고 Craig Saunders (1999) [1], 그리고 Harris Papadopoulos, Kostas Proedrou, Volodya Vovk, 그리고 Alex Gammerman (2002) [2]에 의해 제안되었습니다. Conformal Prediction 알고리즘은 다음과 같이 작동합니다:\n\n- 과거 시계열 데이터를 교육, 보정, 테스트 기간으로 분할합니다.\n- 교육 데이터에서 모델을 훈련합니다.\n- 훈련된 모델을 사용하여 보정 데이터에 대한 예측을 생성합니다. 그런 다음 예측 오차의 히스토그램을 개발하고 Figure (A)와 같이 허용 수준을 정의합니다.\n- 미래 점 추정치와 함께 예측 데이터 내의 예측에 허용 간격을 더하고 빼어 예측 간격을 제공합니다.\n\n소프트웨어 요구사항\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n예측 구간에 대해 NeuralProphet은 세 가지 옵션을 가질 수 있어요: (i) 분위 회귀(Quantile regression, QR), (ii) 일치 예측(Conformal predictions, CP) 및 (iii) 일치화된 분위 회귀(Conformalized quantile regression, CQR). \"시계열 확률적 예측을 위한 분위수 회귀(Quantile Regression for Time Series Probabilistic Forecasting)\"에서 분위 회귀를 연구했습니다. 이 장에서는 일치 예측을 수행하고, 다음 장 \"시계열 확률적 예측을 위한 일치화된 분위 회귀(Conformalized Quantile Regression for Time Series Probabilistic Forecasting)\"에서는 일치화된 분위 회귀를 할 거에요. NeuralProphet를 설치하려면 표준 설치 pip install NeuralProphet를 따르시면 돼요.\n\n```shell\n!pip install neuralprophet\n```\n\nGoogle Colab을 사용하는 경우, NeuralProphet은 numpy1.23.5를 사용하지 않으면 작동하지 않는다는 점을 염두에 두세요. numpy를 제거하고 numpy1.23.5를 설치해야 해요.\n\n```shell\n# neuralprophet은 numpy1.23.5를 사용하지 않으면 colab에서 작동하지 않습니다: https://github.com/googlecolab/colabtools/issues/3752\n!pip uninstall numpy\n!pip install git+https://github.com/ourownstory/neural_prophet.git numpy==1.23.5\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n데이터\n\n이전 NeuralProphet 챕터를 계속 진행하면서, 이 챕터에서는 Kaggle에서 Bike Share Daily 데이터를 사용할 것입니다. 이전 챕터에서 데이터 단계를 상세히 살펴봤기 때문에, 여기서는 설명 없이 데이터를 바로 로드할 것입니다. 데이터를 이해하려면 이전 챕터 중 하나를 참조할 수 있습니다:\n\n- 챕터 3: 튜토리얼 I: 추세 + 계절성 + 휴일 및 이벤트\n- 챕터 4: 튜토리얼 II: 추세 + 계절성 + 휴일 및 이벤트 + 자기 회귀 (AR) + 지연 회귀 + 미래 회귀\n- 챕터 5: \"시계열 확률 예측을 위한 분위수 회귀\".\n\n```js\n%matplotlib inline\nfrom matplotlib import pyplot as plt\nimport pandas as pd\nimport numpy as np\nimport logging\nimport warnings\nlogging.getLogger('prophet').setLevel(logging.ERROR)\nwarnings.filterwarnings(\"ignore\")\n\n# If you use Google Colab\nfrom google.colab import drive\ndrive.mount('/content/gdrive')\npath = '/content/gdrive/My Drive/data/time_series'\ndata = pd.read_csv(path + '/bike_sharing_daily.csv')\ndata.tail()\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![dataset](/assets/img/2024-06-30-ConformalPredictionsforTimeSeriesProbabilisticForecasting_2.png)\n\n이 데이터셋은 매일의 대여 수요와 온도 또는 풍속과 같은 기타 날씨 정보를 포함한 다변량 데이터셋입니다. 모델링을 위해 매우 간단한 데이터 준비를 진행할 것입니다. NeuralProphet은 열 이름을 \"ds\"와 \"y\"로 요구합니다.\n\n```python\n# 문자열을 datetime64로 변환\ndata[\"ds\"] = pd.to_datetime(data[\"dteday\"])\ndf = data[['ds','cnt']]\ndf.columns = ['ds','y']\n```\n\n이제 모델을 설정하겠습니다.\n\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n모델링\n\n다음과 같이 매우 간단한 NeuralProphet 모델을 사용할 것입니다. 이 모델은 추세 및 계절성 패턴만을 갖고 있습니다. 이전 장에서 언급한 대로 AR, 휴일 및 기타 공변량과 같은 다른 구성 요소를 추가할 수 있습니다.\n\n```js\nfrom neuralprophet import NeuralProphet, set_log_level\ncp_model = NeuralProphet(\n    yearly_seasonality=True,\n    weekly_seasonality=True,\n    daily_seasonality=False,\n)\ncp_model.set_plotting_backend(\"plotly-static\")\n```\n\n이제 데이터를 준비해 봅시다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n학습, 보정 및 테스트 데이터\n\n적합성 예측 또는 적합성 양자 회귀 기술에서 중요한 단계는 훈련 데이터를 훈련 및 보정 데이터로 분할하는 것입니다. 보정 데이터는 허용 통계를 구성하는 데 사용됩니다.\n\n```js\ndf_train, df_test = cp_model.split_df(df, valid_p=0.2)\ndf_train, df_cal = cp_model.split_df(df_train, freq=\"D\", valid_p=1.0 / 11)\n[df_train.shape, df_test.shape, df_cal.shape]\n# [(532, 2), (146, 2), (53, 2)]\n```\n\n세 가지 색으로 데이터 하위 집합을 그립니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-06-30-ConformalPredictionsforTimeSeriesProbabilisticForecasting_3.png\" />\n\n모델 구축은 이전 챕터와 동일합니다. 보정 데이터를 모델 검증 세트로 사용합니다.\n\n```js\nmetrics = cp_model.fit(df_train, validation_df=df_cal, progress=\"bar\")\nmetrics.tail()\n```\n\n<img src=\"/assets/img/2024-06-30-ConformalPredictionsforTimeSeriesProbabilisticForecasting_4.png\" />\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그러면 예측을 하고 예측 간격을 첨부할 준비가 된 것입니다. NeuralProphet은 자동으로 CP를 수행할 수 있지만, 여러분에게 단계를 보여주기 위해 수동으로 진행합니다.\n\n일치 예측\n\n우리는 \"df\" 데이터의 마지막 날짜로부터 50개의 기간을 포함하는 \"미래\" 데이터셋을 만들 것입니다. 이 데이터는 모든 과거 데이터에 대한 모델 예측값을 포함할 것입니다. 또는 n_historic_predictions=40을 지정하면 40개의 과거 데이터 포인트와 그에 대한 예측값만 포함할 것입니다.\n\nNeuralProphet의 CP 옵션은 method=naive입니다. 우리는 `.conformal_prediction()`을 사용하여 일치 예측을 활성화할 것입니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n미래 = cp_model.make_future_dataframe(df, periods=50, \n     n_historic_predictions=True)\n\n# 단순 일치 예측을 위한 매개변수\n방법 = \"naive\"\n알파 = 0.05\n\n# 사전 훈련된 모델에서 일치 예측 활성화\ncp_forecast = cp_model.conformal_predict(\n    # df_test, # df_test를 사용할 수도 있습니다. \n    미래,\n    calibration_df=df_cal,\n    alpha=알파,\n    method=방법,\n    show_all_PI=True,\n)\ncp_forecast\n```\n\n결과에는 예측 'yhat1'과 상부 경계 'yhat1 + qhat1'가 포함되어 있습니다. 'qhat1'은 캘리브레이션 데이터에서 유도된 허용 간격입니다.\n\n<img src=\"/assets/img/2024-06-30-ConformalPredictionsforTimeSeriesProbabilisticForecasting_5.png\" />\n\n'yhat1'에서 'yhat1+qhat1'을 빼서 'qhat1'을 얻을 수 있습니다. 이 값은 1951.214의 단일 값입니다. 그런 다음 yhat1에서 qhat1을 빼서 하한을 구성할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\ncp_forecast['qhat1'] = cp_forecast['yhat1 + qhat1'] - cp_forecast['yhat1'] \ncp_forecast['yhat1 - qhat1'] = cp_forecast['yhat1'] - cp_forecast['qhat1']\ncp_forecast\n```\n\n<img src=\"/assets/img/2024-06-30-ConformalPredictionsforTimeSeriesProbabilisticForecasting_6.png\" />\n\n예측값과 예측 구간을 그려봅시다. 모든 기간에 대해 CP가 고정 값임을 알 수 있습니다. 예측값에 더하거나 빼서 상한값과 하한값을 얻습니다.\n\n```js\nimport matplotlib.pyplot as plt\nplt.figure(figsize=(10,6))\n# 각 시리즈를 플롯합니다\nplt.plot(df_train['ds'],df_train['y'], label='학습 데이터')\nplt.plot(df_cal['ds'],df_cal['y'], label='보정 데이터')\nplt.plot(df_test['ds'],df_test['y'], label='테스트 데이터')\n\nplt.plot(cp_forecast['ds'],cp_forecast['yhat1'], label='예측값')\nplt.plot(cp_forecast['ds'],cp_forecast['yhat1 - qhat1'], label='하한값')\nplt.plot(cp_forecast['ds'],cp_forecast['yhat1 + qhat1'], label='상한값')\nplt.legend()\nplt.title('일치 예측')\nplt.xticks(rotation=45, ha='right')\n# 수직 점선 그리기\nplt.axvline(x=df_test['ds'].tail(1), color='r', linestyle='--', linewidth=2) \nplt.show()\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![Conformal Prediction Example](/assets/img/2024-06-30-ConformalPredictionsforTimeSeriesProbabilisticForecasting_7.png)\n\n중요한 점은 허용 구간이 보정 데이터의 실제 값에서 유도된다는 것입니다.\n\n결론\n\n본 장에서는 예측 구간을 제공하기 위한 Conformal Prediction 기술을 소개했습니다. 우리는 CP의 구성을 기본 통계 개념에서 배웠습니다. CP는 모델 가정에 의존하지 않고 어떤 모델에도 적용할 수 있는 모델에 중립적입니다. 또한 NeuralProphet에서 CP를 구성하는 코드 예제를 시연했습니다.\n\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n일부분에서 예측 구간의 길이가 모든 기간에 걸쳐 동일하다는 것을 알아차린 분들도 있을 것입니다. 특정 시나리오에 대해 다양한 예측 구간이 더 나은 의미를 갖을 수 있다고 제안할 수 있습니다. 다음 장에서는 다양한 예측 구간을 허용하는 Conformalized Quantile Regression (CQR)을 연구할 것입니다.\n\n참고문헌\n\n- Volodya Vovk, Alexander Gammerman, and Craig Saunders. Machine-learning applications of algorithmic randomness. In International Conference on Machine Learning, pages 444–453, 1999.\n- Harris Papadopoulos, Kostas Proedrou, Volodya Vovk, and Alex Gammerman. Inductive confidence machines for regression. In European Conference on Machine Learning, pages 345–356. Springer, 2002.\n\n샘플 eBook 장(chapter) (무료): [링크](https://github.com/dataman-git/modern-time-series/blob/main/20240522beauty_TOC.pdf)\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 이니빠레이션 프레스(The Innovation Press, LLC) 스탭 분들께 감사드립니다. 아름다운 형식으로 책을 재구성하여 즐거운 독서 경험을 제공해 주셔서 감사합니다. 전 세계 독자들에게 엄두 나지 않는 경영비용 없이 Teachable 플랫폼을 선택했습니다. 신용카드 거래는 Teachable.com이 비밀리에 안전하게 처리합니다.\n\nTeachable.com에서 eBook: $22.50\nhttps://drdataman.teachable.com/p/home\n\nAmazon.com에서 인쇄본: $65 https://a.co/d/25FVsMx\n\n- 인쇄본은 광택 처리된 표지, 컬러 인쇄, 아름다운 Springer 글꼴 및 레이아웃을 채택하여 즐거운 독서를 제공합니다. 7.5 x 9.25인치의 사이즈는 여러분의 책장에 있는 대부분의 책들과 잘 어울립니다.\n- \"이 책은 Kuo의 시계열 분석과 예측 분석, 그리고 이상 탐지에 대한 깊은 이해를 증명합니다. 이 책은 독자들에게 현실 세계의 과제에 대처하는 데 필요한 기술을 제공합니다. 데이터 사이언스로의 직업 전환을 고민하는 사람들에게 특히 가치 있는 책입니다. Kuo는 전통적이고 최신 기술을 자세히 탐구합니다. Kuo는 신경망과 다른 고급 알고리즘에 대한 논의를 통합하여 최신 동향과 발전을 반영합니다. 이를 통해 독자들이 확립된 방법뿐만 아니라 데이터 사이언스 분야의 가장 현재와 혁신적인 기술과 함께 소통할 수 있는 준비가 되도록 합니다. Kuo의 흥미로운 글쓰기 스타일로 인해 책의 명료함과 접근성이 향상되었습니다. 그는 복잡한 수학 및 통계 개념을 신비롭지 않게 다루어 엄격함을 희생하지 않으면서도 쉽게 접근 가능하게 만듭니다.\"\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 모던 시계열 예측: 예측 분석과 이상 탐지\n\n제로 장편: 서문\n\n제1 장: 소개\n\n제2 장: 비즈니스 예측을 위한 선지자\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### Chapter 3: 튜토리얼 1 - 추세 + 계절성 + 휴일 및 이벤트\n\n### Chapter 4: 튜토리얼 2 - 추세 + 계절성 + 휴일 및 이벤트 + 자기 회귀(AR) + 시차 회귀변수 + 미래 회귀변수\n\n### Chapter 5: 시계열 데이터의 변곡점 탐지\n\n### Chapter 6: 시계열 확률 예측을 위한 몬테카를로 시뮬레이션\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n7장: 시계열 확률 예측을 위한 분위 회귀 분석\n\n8장: 시계열 확률 예측을 위한 적응적 예측\n\n9장: 시계열 확률 예측을 위한 적응적 분위 회귀 분석\n\n10장: 자동 ARIMA!\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 11장: 시계열 데이터 형식 손쉽게 다루기\n\n# 12장: 다기간 확률 예측을 위한 선형 회귀\n\n# 13장: 트리 기반 시계열 모델을 위한 피처 엔지니어링\n\n# 14장: 다기간 시계열 예측을 위한 두 가지 주요 전략\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 15장: 다기간 시계열 확률 예측을 위한 트리 기반 XGB, LightGBM 및 CatBoost 모델\n\n# 16장: 시계열 모델링 기법의 진화\n\n# 17장: 시계열 확률 예측을 위한 딥러닝 기반 DeepAR\n\n# 18장: 응용 - 주식 가격에 대한 확률 예측\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 19장: RNN에서 Transformer 기반 시계열 모델로\n\n# 20장: 해석 가능한 시계열 예측을 위한 Temporal Fusion Transformer\n\n# 21장: 시계열 예측을 위한 오픈 소스 Lag-Llama 튜토리얼","ogImage":{"url":"/assets/img/2024-06-30-ConformalPredictionsforTimeSeriesProbabilisticForecasting_0.png"},"coverImage":"/assets/img/2024-06-30-ConformalPredictionsforTimeSeriesProbabilisticForecasting_0.png","tag":["Tech"],"readingTime":16},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<img src=\"/assets/img/2024-06-30-ConformalPredictionsforTimeSeriesProbabilisticForecasting_0.png\">\n<p>샘플 eBook 챕터(무료): <a href=\"https://github.com/dataman-git/modern-time-series/blob/main/20240522beauty_TOC.pdf\" rel=\"nofollow\" target=\"_blank\">여기</a></p>\n<p>Teachable.com에서의 eBook: $22.50 <a href=\"https://drdataman.teachable.com/p/home\" rel=\"nofollow\" target=\"_blank\">여기</a></p>\n<p>Amazon.com에서의 인쇄판: $65 <a href=\"https://a.co/d/25FVsMx\" rel=\"nofollow\" target=\"_blank\">여기</a></p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>실제 세계 응용 프로그램 및 계획에는 포인트 추정이 아닌 확률적 예측이 필요합니다. 확률적 예측 또는 예측 불확실성이라고도 하는 확률적 예측은 계획자에게 불확실성의 감을 줄 수 있습니다. 그러나 선형 회귀, 랜덤 예측 또는 그래디언트 부스팅 머신과 같은 전형적인 기계 학습 모델은 가능한 값의 범위가 아닌 평균 추정을 생성하도록 설계되었습니다. 이 책이 관심을 갖는 것은 점 추정에서 예측 구간으로 발전하는 과정이며, 현대의 시계열 모델링 기술이 이에 관심을 가지고 있습니다. 확률적 예측 시리즈에서는 'Monte Carlo Simulation for Time Series Probabilistic Forecasting'에서 Monte Carlo 시뮬레이션 기법 및 'Quantile Regression for Time Series Probabilistic Forecasting'에서 분위 회귀 기법을 소개했습니다. 이 장에서는 다른 인기있는 방법인 Conformal Prediction (CP)을 소개하겠습니다.</p>\n<p>CP를 기본적인 예측 맥락에서 설명해 보겠습니다. 우리는 예측 모델의 목표가 조건부 평균에 대해 편향되지 않은 추정을 제공하는 것이라는 것을 알고 있습니다. 예측 값과 실제 값 간의 차이를 오차라고 합니다. 이 오류들은 무엇일까요? 모델이 확실하지 않은 불확실성입니다. 그렇다면 어떻게 불확실성을 양적으로 표현할까요? 이 질문의 답은 질문 자체에 있습니다. 추정 값과 실제 값 사이의 오차는 불확실성을 나타내며, 우리는 이 오류를 분석하여 불확실성을 양적으로 나타낼 수 있습니다. 그런 다음 예측값에 양적으로 측정된 불확실성을 더하거나 뺌으로써 예측 구간을 계산합니다. CP는 새로운 예측에 대한 자신감 수준을 결정하기 위해 이전 데이터를 사용합니다. CP는 새로운 예측이 예측 범위 내에 있을 확률 (예: 95%)을 보장합니다. 특정 모델을 언급하지 않았음에 주목하십시오. 따라서 CP는 모델에 관계없이 작동합니다.</p>\n<p>CP의 구성은 다음과 같습니다:</p>\n<ul>\n<li>오류는 실제 값과 예측 값 사이의 절대값입니다. 예측 값과 실제 값 사이의 오차를 작은 것부터 큰 것까지 나열할 것입니다. 히스토그램을 사용하여 오차 값의 비율을 표시할 것입니다.</li>\n<li>대부분의 경우, 예를 들어 95%의 경우, 오류는 임계값 이하일 것입니다. 이 임계값은 예측 오류에 대한 용인 값으로 간주할 수 있습니다. 이 임계값은 예측에서 해당 실제 값까지의 오류가 95%의 경우 임계값 아래에 있을 것이라는 뜻입니다.</li>\n<li>따라서 예측값에 허용 오차를 더하거나 빼면 해당 예측에 대한 예측 구간을 얻을 수 있습니다. 이는 우리가 예측한 실제 값이 예측 구간 내에 존재할 확률이 95%라는 것을 의미합니다. 그림 (A)는 일치 예측의 구성을 보여줍니다.</li>\n</ul>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p><img src=\"/assets/img/2024-06-30-ConformalPredictionsforTimeSeriesProbabilisticForecasting_1.png\" alt=\"Conformal Prediction Procedure\"></p>\n<p>이 예측 간격을 찾는 프로시저는 Conformal Prediction (CP) 전략입니다. 모델 사양과 기본 데이터 분포에 대한 가정을 하지 않는다는 점에 유의하십시오. CP는 모델에 구애받지 않으며 — 모든 모델링 기법과 함께 작동합니다. Conformal Prediction 기술은 Volodya Vovk, Alexander Gammerman, 그리고 Craig Saunders (1999) [1], 그리고 Harris Papadopoulos, Kostas Proedrou, Volodya Vovk, 그리고 Alex Gammerman (2002) [2]에 의해 제안되었습니다. Conformal Prediction 알고리즘은 다음과 같이 작동합니다:</p>\n<ul>\n<li>과거 시계열 데이터를 교육, 보정, 테스트 기간으로 분할합니다.</li>\n<li>교육 데이터에서 모델을 훈련합니다.</li>\n<li>훈련된 모델을 사용하여 보정 데이터에 대한 예측을 생성합니다. 그런 다음 예측 오차의 히스토그램을 개발하고 Figure (A)와 같이 허용 수준을 정의합니다.</li>\n<li>미래 점 추정치와 함께 예측 데이터 내의 예측에 허용 간격을 더하고 빼어 예측 간격을 제공합니다.</li>\n</ul>\n<p>소프트웨어 요구사항</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>예측 구간에 대해 NeuralProphet은 세 가지 옵션을 가질 수 있어요: (i) 분위 회귀(Quantile regression, QR), (ii) 일치 예측(Conformal predictions, CP) 및 (iii) 일치화된 분위 회귀(Conformalized quantile regression, CQR). \"시계열 확률적 예측을 위한 분위수 회귀(Quantile Regression for Time Series Probabilistic Forecasting)\"에서 분위 회귀를 연구했습니다. 이 장에서는 일치 예측을 수행하고, 다음 장 \"시계열 확률적 예측을 위한 일치화된 분위 회귀(Conformalized Quantile Regression for Time Series Probabilistic Forecasting)\"에서는 일치화된 분위 회귀를 할 거에요. NeuralProphet를 설치하려면 표준 설치 pip install NeuralProphet를 따르시면 돼요.</p>\n<pre><code class=\"hljs language-shell\">!pip install neuralprophet\n</code></pre>\n<p>Google Colab을 사용하는 경우, NeuralProphet은 numpy1.23.5를 사용하지 않으면 작동하지 않는다는 점을 염두에 두세요. numpy를 제거하고 numpy1.23.5를 설치해야 해요.</p>\n<pre><code class=\"hljs language-shell\"><span class=\"hljs-meta prompt_\"># </span><span class=\"bash\">neuralprophet은 numpy1.23.5를 사용하지 않으면 colab에서 작동하지 않습니다: https://github.com/googlecolab/colabtools/issues/3752</span>\n!pip uninstall numpy\n!pip install git+https://github.com/ourownstory/neural_prophet.git numpy==1.23.5\n</code></pre>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>데이터</p>\n<p>이전 NeuralProphet 챕터를 계속 진행하면서, 이 챕터에서는 Kaggle에서 Bike Share Daily 데이터를 사용할 것입니다. 이전 챕터에서 데이터 단계를 상세히 살펴봤기 때문에, 여기서는 설명 없이 데이터를 바로 로드할 것입니다. 데이터를 이해하려면 이전 챕터 중 하나를 참조할 수 있습니다:</p>\n<ul>\n<li>챕터 3: 튜토리얼 I: 추세 + 계절성 + 휴일 및 이벤트</li>\n<li>챕터 4: 튜토리얼 II: 추세 + 계절성 + 휴일 및 이벤트 + 자기 회귀 (AR) + 지연 회귀 + 미래 회귀</li>\n<li>챕터 5: \"시계열 확률 예측을 위한 분위수 회귀\".</li>\n</ul>\n<pre><code class=\"hljs language-js\">%matplotlib inline\n<span class=\"hljs-keyword\">from</span> matplotlib <span class=\"hljs-keyword\">import</span> pyplot <span class=\"hljs-keyword\">as</span> plt\n<span class=\"hljs-keyword\">import</span> pandas <span class=\"hljs-keyword\">as</span> pd\n<span class=\"hljs-keyword\">import</span> numpy <span class=\"hljs-keyword\">as</span> np\n<span class=\"hljs-keyword\">import</span> logging\n<span class=\"hljs-keyword\">import</span> warnings\nlogging.<span class=\"hljs-title function_\">getLogger</span>(<span class=\"hljs-string\">'prophet'</span>).<span class=\"hljs-title function_\">setLevel</span>(logging.<span class=\"hljs-property\">ERROR</span>)\nwarnings.<span class=\"hljs-title function_\">filterwarnings</span>(<span class=\"hljs-string\">\"ignore\"</span>)\n\n# <span class=\"hljs-title class_\">If</span> you use <span class=\"hljs-title class_\">Google</span> <span class=\"hljs-title class_\">Colab</span>\n<span class=\"hljs-keyword\">from</span> google.<span class=\"hljs-property\">colab</span> <span class=\"hljs-keyword\">import</span> drive\ndrive.<span class=\"hljs-title function_\">mount</span>(<span class=\"hljs-string\">'/content/gdrive'</span>)\npath = <span class=\"hljs-string\">'/content/gdrive/My Drive/data/time_series'</span>\ndata = pd.<span class=\"hljs-title function_\">read_csv</span>(path + <span class=\"hljs-string\">'/bike_sharing_daily.csv'</span>)\ndata.<span class=\"hljs-title function_\">tail</span>()\n</code></pre>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p><img src=\"/assets/img/2024-06-30-ConformalPredictionsforTimeSeriesProbabilisticForecasting_2.png\" alt=\"dataset\"></p>\n<p>이 데이터셋은 매일의 대여 수요와 온도 또는 풍속과 같은 기타 날씨 정보를 포함한 다변량 데이터셋입니다. 모델링을 위해 매우 간단한 데이터 준비를 진행할 것입니다. NeuralProphet은 열 이름을 \"ds\"와 \"y\"로 요구합니다.</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-comment\"># 문자열을 datetime64로 변환</span>\ndata[<span class=\"hljs-string\">\"ds\"</span>] = pd.to_datetime(data[<span class=\"hljs-string\">\"dteday\"</span>])\ndf = data[[<span class=\"hljs-string\">'ds'</span>,<span class=\"hljs-string\">'cnt'</span>]]\ndf.columns = [<span class=\"hljs-string\">'ds'</span>,<span class=\"hljs-string\">'y'</span>]\n</code></pre>\n<p>이제 모델을 설정하겠습니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>모델링</p>\n<p>다음과 같이 매우 간단한 NeuralProphet 모델을 사용할 것입니다. 이 모델은 추세 및 계절성 패턴만을 갖고 있습니다. 이전 장에서 언급한 대로 AR, 휴일 및 기타 공변량과 같은 다른 구성 요소를 추가할 수 있습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">from</span> neuralprophet <span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">NeuralProphet</span>, set_log_level\ncp_model = <span class=\"hljs-title class_\">NeuralProphet</span>(\n    yearly_seasonality=<span class=\"hljs-title class_\">True</span>,\n    weekly_seasonality=<span class=\"hljs-title class_\">True</span>,\n    daily_seasonality=<span class=\"hljs-title class_\">False</span>,\n)\ncp_model.<span class=\"hljs-title function_\">set_plotting_backend</span>(<span class=\"hljs-string\">\"plotly-static\"</span>)\n</code></pre>\n<p>이제 데이터를 준비해 봅시다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>학습, 보정 및 테스트 데이터</p>\n<p>적합성 예측 또는 적합성 양자 회귀 기술에서 중요한 단계는 훈련 데이터를 훈련 및 보정 데이터로 분할하는 것입니다. 보정 데이터는 허용 통계를 구성하는 데 사용됩니다.</p>\n<pre><code class=\"hljs language-js\">df_train, df_test = cp_model.<span class=\"hljs-title function_\">split_df</span>(df, valid_p=<span class=\"hljs-number\">0.2</span>)\ndf_train, df_cal = cp_model.<span class=\"hljs-title function_\">split_df</span>(df_train, freq=<span class=\"hljs-string\">\"D\"</span>, valid_p=<span class=\"hljs-number\">1.0</span> / <span class=\"hljs-number\">11</span>)\n[df_train.<span class=\"hljs-property\">shape</span>, df_test.<span class=\"hljs-property\">shape</span>, df_cal.<span class=\"hljs-property\">shape</span>]\n# [(<span class=\"hljs-number\">532</span>, <span class=\"hljs-number\">2</span>), (<span class=\"hljs-number\">146</span>, <span class=\"hljs-number\">2</span>), (<span class=\"hljs-number\">53</span>, <span class=\"hljs-number\">2</span>)]\n</code></pre>\n<p>세 가지 색으로 데이터 하위 집합을 그립니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<img src=\"/assets/img/2024-06-30-ConformalPredictionsforTimeSeriesProbabilisticForecasting_3.png\">\n<p>모델 구축은 이전 챕터와 동일합니다. 보정 데이터를 모델 검증 세트로 사용합니다.</p>\n<pre><code class=\"hljs language-js\">metrics = cp_model.<span class=\"hljs-title function_\">fit</span>(df_train, validation_df=df_cal, progress=<span class=\"hljs-string\">\"bar\"</span>)\nmetrics.<span class=\"hljs-title function_\">tail</span>()\n</code></pre>\n<img src=\"/assets/img/2024-06-30-ConformalPredictionsforTimeSeriesProbabilisticForecasting_4.png\">\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>그러면 예측을 하고 예측 간격을 첨부할 준비가 된 것입니다. NeuralProphet은 자동으로 CP를 수행할 수 있지만, 여러분에게 단계를 보여주기 위해 수동으로 진행합니다.</p>\n<p>일치 예측</p>\n<p>우리는 \"df\" 데이터의 마지막 날짜로부터 50개의 기간을 포함하는 \"미래\" 데이터셋을 만들 것입니다. 이 데이터는 모든 과거 데이터에 대한 모델 예측값을 포함할 것입니다. 또는 n_historic_predictions=40을 지정하면 40개의 과거 데이터 포인트와 그에 대한 예측값만 포함할 것입니다.</p>\n<p>NeuralProphet의 CP 옵션은 method=naive입니다. 우리는 <code>.conformal_prediction()</code>을 사용하여 일치 예측을 활성화할 것입니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-js\">미래 = cp_model.<span class=\"hljs-title function_\">make_future_dataframe</span>(df, periods=<span class=\"hljs-number\">50</span>, \n     n_historic_predictions=<span class=\"hljs-title class_\">True</span>)\n\n# 단순 일치 예측을 위한 매개변수\n방법 = <span class=\"hljs-string\">\"naive\"</span>\n알파 = <span class=\"hljs-number\">0.05</span>\n\n# 사전 훈련된 모델에서 일치 예측 활성화\ncp_forecast = cp_model.<span class=\"hljs-title function_\">conformal_predict</span>(\n    # df_test, # df_test를 사용할 수도 있습니다. \n    미래,\n    calibration_df=df_cal,\n    alpha=알파,\n    method=방법,\n    show_all_PI=<span class=\"hljs-title class_\">True</span>,\n)\ncp_forecast\n</code></pre>\n<p>결과에는 예측 'yhat1'과 상부 경계 'yhat1 + qhat1'가 포함되어 있습니다. 'qhat1'은 캘리브레이션 데이터에서 유도된 허용 간격입니다.</p>\n<img src=\"/assets/img/2024-06-30-ConformalPredictionsforTimeSeriesProbabilisticForecasting_5.png\">\n<p>'yhat1'에서 'yhat1+qhat1'을 빼서 'qhat1'을 얻을 수 있습니다. 이 값은 1951.214의 단일 값입니다. 그런 다음 yhat1에서 qhat1을 빼서 하한을 구성할 수 있습니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-js\">cp_forecast[<span class=\"hljs-string\">'qhat1'</span>] = cp_forecast[<span class=\"hljs-string\">'yhat1 + qhat1'</span>] - cp_forecast[<span class=\"hljs-string\">'yhat1'</span>] \ncp_forecast[<span class=\"hljs-string\">'yhat1 - qhat1'</span>] = cp_forecast[<span class=\"hljs-string\">'yhat1'</span>] - cp_forecast[<span class=\"hljs-string\">'qhat1'</span>]\ncp_forecast\n</code></pre>\n<img src=\"/assets/img/2024-06-30-ConformalPredictionsforTimeSeriesProbabilisticForecasting_6.png\">\n<p>예측값과 예측 구간을 그려봅시다. 모든 기간에 대해 CP가 고정 값임을 알 수 있습니다. 예측값에 더하거나 빼서 상한값과 하한값을 얻습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> matplotlib.<span class=\"hljs-property\">pyplot</span> <span class=\"hljs-keyword\">as</span> plt\nplt.<span class=\"hljs-title function_\">figure</span>(figsize=(<span class=\"hljs-number\">10</span>,<span class=\"hljs-number\">6</span>))\n# 각 시리즈를 플롯합니다\nplt.<span class=\"hljs-title function_\">plot</span>(df_train[<span class=\"hljs-string\">'ds'</span>],df_train[<span class=\"hljs-string\">'y'</span>], label=<span class=\"hljs-string\">'학습 데이터'</span>)\nplt.<span class=\"hljs-title function_\">plot</span>(df_cal[<span class=\"hljs-string\">'ds'</span>],df_cal[<span class=\"hljs-string\">'y'</span>], label=<span class=\"hljs-string\">'보정 데이터'</span>)\nplt.<span class=\"hljs-title function_\">plot</span>(df_test[<span class=\"hljs-string\">'ds'</span>],df_test[<span class=\"hljs-string\">'y'</span>], label=<span class=\"hljs-string\">'테스트 데이터'</span>)\n\nplt.<span class=\"hljs-title function_\">plot</span>(cp_forecast[<span class=\"hljs-string\">'ds'</span>],cp_forecast[<span class=\"hljs-string\">'yhat1'</span>], label=<span class=\"hljs-string\">'예측값'</span>)\nplt.<span class=\"hljs-title function_\">plot</span>(cp_forecast[<span class=\"hljs-string\">'ds'</span>],cp_forecast[<span class=\"hljs-string\">'yhat1 - qhat1'</span>], label=<span class=\"hljs-string\">'하한값'</span>)\nplt.<span class=\"hljs-title function_\">plot</span>(cp_forecast[<span class=\"hljs-string\">'ds'</span>],cp_forecast[<span class=\"hljs-string\">'yhat1 + qhat1'</span>], label=<span class=\"hljs-string\">'상한값'</span>)\nplt.<span class=\"hljs-title function_\">legend</span>()\nplt.<span class=\"hljs-title function_\">title</span>(<span class=\"hljs-string\">'일치 예측'</span>)\nplt.<span class=\"hljs-title function_\">xticks</span>(rotation=<span class=\"hljs-number\">45</span>, ha=<span class=\"hljs-string\">'right'</span>)\n# 수직 점선 그리기\nplt.<span class=\"hljs-title function_\">axvline</span>(x=df_test[<span class=\"hljs-string\">'ds'</span>].<span class=\"hljs-title function_\">tail</span>(<span class=\"hljs-number\">1</span>), color=<span class=\"hljs-string\">'r'</span>, linestyle=<span class=\"hljs-string\">'--'</span>, linewidth=<span class=\"hljs-number\">2</span>) \nplt.<span class=\"hljs-title function_\">show</span>()\n</code></pre>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p><img src=\"/assets/img/2024-06-30-ConformalPredictionsforTimeSeriesProbabilisticForecasting_7.png\" alt=\"Conformal Prediction Example\"></p>\n<p>중요한 점은 허용 구간이 보정 데이터의 실제 값에서 유도된다는 것입니다.</p>\n<p>결론</p>\n<p>본 장에서는 예측 구간을 제공하기 위한 Conformal Prediction 기술을 소개했습니다. 우리는 CP의 구성을 기본 통계 개념에서 배웠습니다. CP는 모델 가정에 의존하지 않고 어떤 모델에도 적용할 수 있는 모델에 중립적입니다. 또한 NeuralProphet에서 CP를 구성하는 코드 예제를 시연했습니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>일부분에서 예측 구간의 길이가 모든 기간에 걸쳐 동일하다는 것을 알아차린 분들도 있을 것입니다. 특정 시나리오에 대해 다양한 예측 구간이 더 나은 의미를 갖을 수 있다고 제안할 수 있습니다. 다음 장에서는 다양한 예측 구간을 허용하는 Conformalized Quantile Regression (CQR)을 연구할 것입니다.</p>\n<p>참고문헌</p>\n<ul>\n<li>Volodya Vovk, Alexander Gammerman, and Craig Saunders. Machine-learning applications of algorithmic randomness. In International Conference on Machine Learning, pages 444–453, 1999.</li>\n<li>Harris Papadopoulos, Kostas Proedrou, Volodya Vovk, and Alex Gammerman. Inductive confidence machines for regression. In European Conference on Machine Learning, pages 345–356. Springer, 2002.</li>\n</ul>\n<p>샘플 eBook 장(chapter) (무료): <a href=\"https://github.com/dataman-git/modern-time-series/blob/main/20240522beauty_TOC.pdf\" rel=\"nofollow\" target=\"_blank\">링크</a></p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<ul>\n<li>이니빠레이션 프레스(The Innovation Press, LLC) 스탭 분들께 감사드립니다. 아름다운 형식으로 책을 재구성하여 즐거운 독서 경험을 제공해 주셔서 감사합니다. 전 세계 독자들에게 엄두 나지 않는 경영비용 없이 Teachable 플랫폼을 선택했습니다. 신용카드 거래는 Teachable.com이 비밀리에 안전하게 처리합니다.</li>\n</ul>\n<p>Teachable.com에서 eBook: $22.50\n<a href=\"https://drdataman.teachable.com/p/home\" rel=\"nofollow\" target=\"_blank\">https://drdataman.teachable.com/p/home</a></p>\n<p>Amazon.com에서 인쇄본: $65 <a href=\"https://a.co/d/25FVsMx\" rel=\"nofollow\" target=\"_blank\">https://a.co/d/25FVsMx</a></p>\n<ul>\n<li>인쇄본은 광택 처리된 표지, 컬러 인쇄, 아름다운 Springer 글꼴 및 레이아웃을 채택하여 즐거운 독서를 제공합니다. 7.5 x 9.25인치의 사이즈는 여러분의 책장에 있는 대부분의 책들과 잘 어울립니다.</li>\n<li>\"이 책은 Kuo의 시계열 분석과 예측 분석, 그리고 이상 탐지에 대한 깊은 이해를 증명합니다. 이 책은 독자들에게 현실 세계의 과제에 대처하는 데 필요한 기술을 제공합니다. 데이터 사이언스로의 직업 전환을 고민하는 사람들에게 특히 가치 있는 책입니다. Kuo는 전통적이고 최신 기술을 자세히 탐구합니다. Kuo는 신경망과 다른 고급 알고리즘에 대한 논의를 통합하여 최신 동향과 발전을 반영합니다. 이를 통해 독자들이 확립된 방법뿐만 아니라 데이터 사이언스 분야의 가장 현재와 혁신적인 기술과 함께 소통할 수 있는 준비가 되도록 합니다. Kuo의 흥미로운 글쓰기 스타일로 인해 책의 명료함과 접근성이 향상되었습니다. 그는 복잡한 수학 및 통계 개념을 신비롭지 않게 다루어 엄격함을 희생하지 않으면서도 쉽게 접근 가능하게 만듭니다.\"</li>\n</ul>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h1>모던 시계열 예측: 예측 분석과 이상 탐지</h1>\n<p>제로 장편: 서문</p>\n<p>제1 장: 소개</p>\n<p>제2 장: 비즈니스 예측을 위한 선지자</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h3>Chapter 3: 튜토리얼 1 - 추세 + 계절성 + 휴일 및 이벤트</h3>\n<h3>Chapter 4: 튜토리얼 2 - 추세 + 계절성 + 휴일 및 이벤트 + 자기 회귀(AR) + 시차 회귀변수 + 미래 회귀변수</h3>\n<h3>Chapter 5: 시계열 데이터의 변곡점 탐지</h3>\n<h3>Chapter 6: 시계열 확률 예측을 위한 몬테카를로 시뮬레이션</h3>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>7장: 시계열 확률 예측을 위한 분위 회귀 분석</p>\n<p>8장: 시계열 확률 예측을 위한 적응적 예측</p>\n<p>9장: 시계열 확률 예측을 위한 적응적 분위 회귀 분석</p>\n<p>10장: 자동 ARIMA!</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h1>11장: 시계열 데이터 형식 손쉽게 다루기</h1>\n<h1>12장: 다기간 확률 예측을 위한 선형 회귀</h1>\n<h1>13장: 트리 기반 시계열 모델을 위한 피처 엔지니어링</h1>\n<h1>14장: 다기간 시계열 예측을 위한 두 가지 주요 전략</h1>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h1>15장: 다기간 시계열 확률 예측을 위한 트리 기반 XGB, LightGBM 및 CatBoost 모델</h1>\n<h1>16장: 시계열 모델링 기법의 진화</h1>\n<h1>17장: 시계열 확률 예측을 위한 딥러닝 기반 DeepAR</h1>\n<h1>18장: 응용 - 주식 가격에 대한 확률 예측</h1>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h1>19장: RNN에서 Transformer 기반 시계열 모델로</h1>\n<h1>20장: 해석 가능한 시계열 예측을 위한 Temporal Fusion Transformer</h1>\n<h1>21장: 시계열 예측을 위한 오픈 소스 Lag-Llama 튜토리얼</h1>\n</body>\n</html>\n"},"__N_SSG":true}