{"pageProps":{"post":{"title":"Python을 사용하여 GitHub 개발 활동 분석하는 방법","description":"","date":"2024-06-30 22:01","slug":"2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython","content":"\n\n<img src=\"/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_0.png\" />\n\nGitHub 개발 데이터는 특정 프로젝트나 회사의 전체 활동을 평가하려는 기관, 투자자, 경쟁업체에게 소중한 통찰을 제공합니다. 이 데이터를 분석함으로써 이해관계자들은 특정 시간대의 최고 기여자를 식별하고 가장 활발한 저장소를 파악하며 프로젝트의 단계별 목표와 활동 수준 사이의 관계를 발견할 수 있습니다.\n\n다음 글에서는 web3 생태계의 여섯 개의 오픈 소스 AI 프로젝트의 GitHub 개발 데이터를 살펴보겠습니다. 이들은 다음과 같습니다:\n\n- Ocean Protocol: 이 프로젝트는 암호화폐 가격 예측 알고리즘부터 데이터 과학 도전과 시장을 위한 다양한 솔루션을 보유하고 있습니다.\n- Bittensor: 이 프로젝트는 탈중앙화된 컴퓨팅으로 AI 민주화를 목표로 하는 모듈식 아키텍처를 가지고 있습니다.\n- Fetch.ai: 이 프로젝트는 SDK를 사용하여 AI 기반 프로젝트를 통해 개발자들이 수익을 창출할 수 있도록 합니다.\n- Numerai: 이 프로젝트는 주식 시장 예측 토너먼트를 주최하며 우승자에게 토큰을 보상합니다.\n- Oraichain: AI의 다차원 신뢰도를 검증하고 독특한 AI 오라클을 활용하여 Web3 애플리케이션을 구축하기 위한 IBC 활성화된 Layer 1입니다.\n- SingularityNET: 이 프로젝트의 임무는 탈중앙화 방식으로 인공 일반 지능(AGI)을 개발하는 것입니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nPython을 사용하여 분석을 진행하기 위해 위에서 언급한 각 프로젝트에 대한 GitHub의 공개 데이터를 활용할 것입니다. 데이터 조작 및 정리에는 Pandas를 사용하고, 시각화에는 Matplotlib 및 Seaborn을 활용하여 가치 있는 통찰을 제공하는 정보적인 차트를 생성할 것입니다. 커밋 빈도, 저장소 생성, 개발자 참여 등과 같은 주요 메트릭을 조사함으로써 개발 참여 수준이 프로젝트 성공의 신뢰할 수 있는 지표인지를 평가할 수 있습니다.\n\n저희의 분석은 GitHub에서의 개발 활동의 중요성과 해당 활동이 이해관계자, 투자자, 경쟁 업체에게 가치 있는 통찰을 제공할 수 있다는 점을 탐색하는 데서 시작할 것입니다. 그 다음으로, 개발 활동에 대한 시간적 분석을 탐구한 다음, 커밋 빈도를 기준으로 프로젝트를 순위 매기겠습니다. 또한 가장 활발하게 활동하는 개발자를 식별하고 순위를 매기며, 주목받는 저장소도 확인하여 각 프로젝트의 역학을 포괄적으로 이해할 수 있도록 할 것입니다.\n\n# GitHub의 개발 활동 데이터의 중요성\n\n개발 활동을 연구하는 것이 왜 중요한지 궁금하다면, 이 섹션에서 이해관계자, 투자자 및 경쟁사에게 특히 중요할 수 있는 몇 가지 핵심 요소를 강조하겠습니다. 함께 살펴보겠습니다:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 이해관계자들\n\n- 프로젝트 건강 및 진행 상황에 대한 통찰력을 얻을 수 있습니다: 이해관계자들은 프로젝트가 활발히 개발되고 있는지, 어떤 기능이 우선 순위에 있는지 이해할 수 있습니다.\n- 프로젝트 역학 이해하기: 시간적 분석을 통해 이해관계자들은 프로젝트 수명주기를 이해하고 중요한 진전 또는 정체 기간을 식별할 수 있습니다. 또한 프로젝트의 주요 이정표들과의 상관 관계를 파악하는 데 도움이 됩니다.\n- 개발자 성과 평가: 많은 커밋 수는 언제나 생산성이 높다는 것을 의미하는 것은 아니지만, 이는 이해관계자들이 개발자의 참여 정도를 이해하고, 그가 회사의 건강한 성장에 기여하는지를 이해하는 데 좋은 지표입니다.\n\n## 투자자들\n\n- 안내된 투자 결정: 커밋 빈도 및 활동 트렌드를 분석함으로써, 투자자들은 활발히 개발되고 유지되는 유망한 프로젝트를 식별할 수 있습니다. 높은 개발 활동은 투자 수익 가능성에 대한 긍정적인 신호가 될 수 있습니다.\n- 프로젝트 장기성 이해하기: 시간적 분석을 통해 투자자들은 프로젝트의 지속 가능성과 장기적 잠재력을 평가할 수 있습니다.\n- 개발자 품질: 개발자들의 활동 및 GitHub 프로필을 알게 되면 투자자들은 프로젝트 뒤에 있는 재능을 볼 수 있습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 경쟁사\n\n- 경쟁 전략 수립: 경쟁사는 경쟁 프로젝트의 개발 활동을 분석하여 그들의 장단점을 이해할 수 있습니다. 이 정보를 활용하여 경쟁사를 앞서가는 전략을 개발할 수 있습니다.\n- 트렌드 파악: 개발 활동의 시계열 분석을 통해 경쟁사는 시장 트렌드를 식별하고 그에 맞게 전략을 조정할 수 있습니다. 어떤 저장소가 가장 많은 관심을 받고 있는지 파악함으로써 경쟁사는 주목받고 있는 분야에 초점을 맞출 수 있습니다.\n\n전반적으로, GitHub 개발 활동을 연구함으로써 이해당사자, 투자자, 경쟁사 및 다른 이야기에서 언급되지 않은 당사자들에게 맞춤형 통찰력을 제공하여 각 그룹이 정보에 근거한 결정을 내리고 소프트웨어 개발 생태계에서 경쟁력을 유지할 수 있도록 도와줍니다.\n\n# 시간별 개발자 활동 분석\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 섹션에서는 각 프로젝트의 시간 경과에 따른 커밋 수와 참여자 수를 조사할 것입니다. 데이터 포인트가 매일 표시하기에 너무 많기 때문에 대신 주간 보기를 사용할 것입니다. 차트에서 범례의 각 색깔은 서로 다른 연도에 해당합니다. 우리는 활동의 증가와 주요 프로젝트 이정표간의 연결을 살펴볼 것이며, 시간이 흐름에 따라 개발 강도가 어떻게 변하는지 확인할 것입니다.\n\n## Bittensor\n\n<img src=\"/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_1.png\" />\n\n위의 Bittensor 차트에서 시간이 흐름에 따라 개발 활동이 점차 증가하는 것을 볼 수 있습니다. 2023년이 가장 많은 커밋과 다른 참여자 수가 있었던 해로, 거의 50명의 개발자가 Bittsensor의 저장소에서 업그레이드를 진행했습니다. 2024년에 관한 데이터가 충분치 않지만, 이미 개발이 크게 감소하고 참여자 수도 줄어든 것을 볼 수 있으며, 이는 2019년과 거의 동일합니다. 그렇지만 우리는 몇몇 중요한 커밋 피크를 볼 수 있습니다. 주로 연도의 처음 4주와 11, 12주쯤에 발생합니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n예를 들어, 1월 17일쯤에 Bittsensor의 토큰 $TAO가 상승한 상위 그룹에 속했다는 기사를 찾을 수 있습니다. 이때가 2024년의 첫 번째 정점이 있는 시기와 비슷합니다. 그러나 토큰의 가격은 개발 활동과 항상 상관관계가 있는 것은 아니므로, 차트에서 가장 큰 정점은 2023년 말에 발생했으며, 이 기간 동안 큰 상승 추세가 없었습니다.\n\n## Fetch.ai\n\n![이미지](/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_2.png)\n\nFetch.ai 차트는 Bittensor의 차트와 매우 다릅니다. 개발 활동은 주로 2017년부터 2021년 사이에 발생한 것을 볼 수 있습니다. 회사는 2017년에 설립되었고 2019년에 출시되었지만, 개발은 2014년에 더 빨리 시작된 것으로 보입니다. 커밋의 주요 정점은 출시의 거의 1년 전인 2018년 중반에 있습니다. GitHub 기여자 수는 2019년에 증가하며, 해당 해에 가장 큰 정점을 나타냅니다. 그 후 바로 2020년 1월 1일에 회사는 메인넷에서 출시되었습니다. 이 이벤트는 2019년 후반에 보다 많은 기여자와 커밋과 관련이 있을 수 있습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n지금까지 개발은 지난 세 년 동안 감소하는 것으로 보이지만, 2024년에는 참여자 수와 커밋 수가 약간 상승하는 추세를 보입니다.\n\n## Numerai\n\n![Numerai](/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_3.png)\n\nNumerai의 전반적인 개발 활동은 크지 않습니다. 2017년과 2021년에는 몇 가지 의미있는 정점이 있습니다. 또한 참여자/기여자 수가 다른 프로젝트와 달리 커밋 수와 관련이 없어 보입니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n2021년의 고점이 Numerai 네트워크 발표와 관련이 있을 수 있습니다. 이 기사에서는 CLI의 업데이트와 예측 노드 구현이 언급되었습니다.\n\n## Ocean Protocol\n\n![Ocean Protocol](/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_4.png)\n\nOcean Protocol 팀은 몇 년 동안 꾸준히 높은 커밋 수를 보여주었으며, 300개 이상의 커밋을 넘는 고점이 있었습니다. 이러한 커밋 고점과 참여자 또는 기여자 수 사이에 상관 관계가 있는 것으로 보이지만, 모든 경우에 일관되게 관찰되는 것은 아닙니다. 그러나 2022년에는 분명한 상관 관계가 있습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nPredictoor는 2023년 9월 12일 경부 출시되었습니다 (37주차), 이 날짜 이전에는 개발에서 상당한 피크가 있었는데, 이는 해당 이벤트와 관련이 있을 수 있습니다.\n\n가장 큰 피크는 2020년 41주에서 43주에 발생했는데, 바로 Ocean Protocol V3가 출시된 후였습니다. 이에 관한 기사를 확인할 수 있습니다:\n\n2024년에는 2023년과 비교했을 때 개발 활동이 현저히 감소했으며, 저장소에서 활발히 작업하는 기여자 수도 감소했습니다. 그러나 이는 반드시 전체 연도에 대한 지속적인 추세를 나타내지는 않을 수 있습니다. 2020년과 마찬가지로, 개발 면에서는 천천히 시작되었지만 연말에는 급증세를 지켜볼 수 있을 것입니다.\n\n## Oraichain\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![이미지](/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_5.png)\n\nOraichain Labs 차트를 보면 커밋 수와 참여자/기여자 수 사이에 명확한 상관 관계가 있는 것을 볼 수 있습니다. 2020년 말에 개발이 속도를 내며, 이는 2021년 2월의 공식 발표와 관련이 있을 수 있습니다.\n\n2023년은 개발에서 가장 활발한 해로, 이 추세가 2024년으로 이어지고 있습니다. 이 급증은 해커톤, 지갑 업데이트 및 통합과 같은 중요한 프로젝트 이정표를 반영하고 있습니다. 상대적으로 새로운 프로젝트이기 때문에, 특히 최근 몇 주간 다른 AI 프로젝트들보다 더 높은 개발 강도를 보여주고 있습니다.\n\n## 싱귤러리티넷\n\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![Image](/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_6.png)\n\n이 차트는 SingularityNET의 개발이 2018년부터 2020년 사이에 정점에 이른 것을 보여줍니다. 이후 커밋 활동 및 기여자 수가 감소하는 추세를 보였습니다. 이 기사에 따르면, 백엔드 소프트웨어는 2019년에 성숙기에 이르렀으며 이는 또한 가장 많은 개발이 이루어진 해입니다.\n\n2024년에는 2023년과 비교했을 때 개발이 증가하는 것을 볼 수 있습니다. 이는 2018년부터 2020년 사이와 유사한 고개발의 새로운 이후를 나타낼 수 있습니다.\n\n# 시간에 따른 개발자 활동 분석 (코드)\n\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n제공된 데이터셋은 즉시 분석에 사용할 수 있는 상태가 아니라 데이터 조작 기술을 적용하여 작업해야 합니다. 먼저 각 행별로 데이터셋에서 의미 있는 정보를 추출하고, 분석을 위해 다른 정리된 데이터프레임을 생성하기 위해 두 가지 함수를 만듭니다.\n\n```js\nimport pandas as pd\n\ndef process_commits_row(row):\n    \"\"\" 이 함수는 데이터셋의 각 행에서 의미 있는 정보를 추출하여 딕셔너리로 반환합니다. 'repo' 변수가\n    나중에 저장소 데이터셋과 병합하는 데 사용됨에 유의하세요. \"\"\"\n    repo = \\\n        row['url'].split('repos')[1].split('commits')[0].split(\"/\")[-2]\n    return {\n        'sha': row['sha'],\n        'repo': repo,\n        'node_id': row['node_id'],\n        'author': row['commit']['author']['name'],\n        'date': row['commit']['author']['date'],\n        'message': row['commit']['message']}\n\ndef gen_df_commits_filt(df):\n    \"\"\" 이 함수는 데이터셋을 반복하면서 'process_commits_row' 함수를 각 행에 적용합니다. 결과는\n    딕셔너리의 목록으로 반환되어 최종적으로 DataFrame으로 반환됩니다. \"\"\"\n    all_features = []\n    for row in df.iterrows():\n        for i in range(1, len(row[1]) - 1):\n            try:\n                all_features.append(process_commits_row(row[1][i]))\n            except Exception:\n                pass\n    return pd.DataFrame(all_features)\n```\n\n위의 함수들은 각 프로젝트의 커밋 데이터셋을 대상으로 합니다. 이 두 함수를 함께 사용하여 sha, repo, node_id, author, date 및 message의 특징을 가진 필터링된 데이터프레임을 생성합니다. 그런 다음 데이터셋을 호출하고 각각의 데이터셋에 gen_df_commits_filt() 함수를 적용할 수 있습니다.\n\n```js\n# 데이터셋 호출\ndf_commits_bittensor = pd.read_json('datasets/bittensor_commits.json')\ndf_commits_fetchai = pd.read_json('datasets/fetchai_commits.json')\ndf_commits_numerai = pd.read_json('datasets/numerai_commits.json')\ndf_commits_ocean = pd.read_json('datasets/oceanprotocol_commits.json')\ndf_commits_oraichain = pd.read_json('datasets/oraichain_commits.json')\ndf_commits_singular = pd.read_json('datasets/singularitynet_commits.json')\n\n# 데이터셋 필터링\ndf_commits_bittensor_filt = gen_df_commits_filt(df_commits_bittensor)\ndf_commits_fetchai_filt = gen_df_commits_filt(df_commits_fetchai)\ndf_commits_numerai_filt = gen_df_commits_filt(df_commits_numerai)\ndf_commits_ocean_filt = gen_df_commits_filt(df_commits_ocean)\ndf_commits_oraichain_filt = gen_df_commits_filt(df_commits_oraichain)\ndf_commits_singular_filt = gen_df_commits_filt(df_commits_singular)\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n날짜별로 그룹화된 데이터셋을 사용하여 시간별 사용자 활동을 관찰할 수 있습니다. 이전에 언급했듯이 날짜 데이터가 너무 많아서 차트에 표시하기에는 많았기 때문에 주차별, 연도별로 그룹화했습니다. 아래 함수를 사용하여 그룹화했습니다:\n\n```js\ndef gen_group_week(filt_dataframe):\n    \"\"\" 이 함수는 필터링된 데이터셋을 주별로 그룹화합니다 \"\"\"\n    df_commits_temp = filt_dataframe.sort_values(\n        by='date')[['date', 'sha', 'repo', 'author', 'message']]\n    df_commits_temp.date = df_commits_temp.date.apply(\n        lambda x: datetime.strptime(x, '%Y-%m-%dT%H:%M:%SZ'))\n    df_commits_temp['week'] = df_commits_temp['date'].dt.strftime('%W-%Y')\n    df_commits_temp = df_commits_temp.groupby('week').agg(\n        {\n            'sha': 'count',\n            'repo': 'nunique',\n            'author': 'nunique'}).reset_index().rename(\n            columns={\n                'sha': 'n_commits',\n                'author': 'n_participants',\n                'repo': 'n_repos'})\n    df_commits_temp['week_num'] = \\\n        df_commits_temp['week'].str.split('-').str[0].astype(int)\n    df_commits_temp['year'] = \\\n        df_commits_temp['week'].str.split('-').str[1].astype(int)\n    df_commits_temp = df_commits_temp.sort_values(by=['year', 'week_num'])\n    return df_commits_temp\n```\n\n마지막으로, 필터링된 각 데이터셋에 이 함수를 적용했습니다.\n\n```js\ndf_commits_bittensor_week = gen_group_week(df_commits_bittensor_filt)\ndf_commits_fetchai_week = gen_group_week(df_commits_fetchai_filt)\ndf_commits_numerai_week = gen_group_week(df_commits_numerai_filt)\ndf_commits_ocean_week = gen_group_week(df_commits_ocean_filt)\ndf_commits_oraichain_week = gen_group_week(df_commits_oraichain_filt)\ndf_commits_singular_week = gen_group_week(df_commits_singular_filt)\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 이전에 표시된 막대 차트를 구동한 코드를 살펴보겠습니다.\n\n```js\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom datetime import datetime\n\ndef chart_user_activity(df, protocol):\n    \"\"\" 사용자 활동에 대한 시간별 막대 차트 작성 \"\"\"\n    fig, ax1 = plt.subplots(figsize=(20, 8))\n    # 필요에 따라 색상 수를 조정할 수 있습니다\n    colors = sns.color_palette('tab10', len(df['year'].unique()))\n    # 각 고유 연도를 색상에 매핑하는 딕셔너리 생성\n    year_colors = dict(zip(df['year'].unique(), colors))\n    sns.barplot(\n        df,\n        x='week',\n        y='n_commits',\n        hue='year',\n        ax=ax1,\n        dodge=False,\n        palette=year_colors)\n    ax1.set_xlabel('주', fontsize=18)\n    ax1.set_ylabel('커밋 수', fontsize=18)\n    ax1.tick_params('y', labelsize=12)\n    ax1.set_title(f\"{protocol} 개발자 활동 시간별\", fontsize=30)\n    ax1.grid(axis='y', which='major', linestyle='--', linewidth=0.5)\n    ax2 = ax1.twinx()\n    sns.lineplot(\n        df,\n        x='week',\n        y='n_participants',\n        ax=ax2,\n        linestyle='--',\n        marker='o',\n        color='r',\n        alpha=0.5)\n    ax2.set_ylabel('참가자 수', fontsize=18, color='r')\n    ax2.tick_params('y', colors='r', labelsize=12)\n    ax2.xaxis.set_ticks(df['week'][::10])\n    ax1.spines['top'].set_visible(False)\n    ax2.spines['top'].set_visible(False)\n    # x축 눈금 라벨에서 연도 부분 제거\n    labels = [item.get_text().split('-')[0] for item in ax1.get_xticklabels()]\n    ax1.set_xticklabels(labels)\n    ax1.tick_params('x', labelsize=12)\n    ax2.set_ylim(bottom=0)\n    plt.show()\n```\n\n차트를 표시하려면 다음과 같이 간단히 수행할 수 있습니다:\n\n```js\nchart_user_activity(df_commits_bittensor_week, 'Bittensor')\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 프로젝트 활동 기준으로 순위 매기기\n\n이 섹션에서는 서로 다른 프로젝트에서 시간이 지남에 따라 사용된 커밋 수와 리포지토리 수를 비교해 보겠습니다.\n\n![이미지](/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_7.png)\n\n위 막대 차트는 시간이 지남에 따른 커밋의 진화와 연도별 사용된 다른 리포지토리의 수를 확인할 수 있습니다. 이 차트들을 검토하면 몇 가지 초기 관찰을 할 수 있습니다:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 가장 많은 커밋(41465)을 가진 프로젝트는 Fetch.ai이며, 그 다음으로 Ocean Protocol이 33626개의 커밋을 가지고 있습니다. Fetch.ai가 가장 많은 커밋을 가졌다는 사실은 GitHub에서의 장기간 활동으로 인해 놀랍지 않습니다. Ocean Protocol은 4년 뒤에 시작했지만 이미 다른 최근 프로젝트와 비교하여 인상적인 개발 활동을 보여주고 있습니다.\n- Bittensor, Ocean Protocol, Oraichain, 그리고 Numerai는 해마다 저장소 수를 늘리고 있으며, 2023년에는 가장 많은 저장소 사용량을 가지고 있습니다. 2024년에는 이 수가 늘어날 수 있습니다. 그러나 이 명제를 확인하기 위해 모든 데이터를 아직 갖고 있지는 않습니다.\n- Oraichain은 커밋 수와 저장소 수 사이에 높은 상관 관계를 보여줍니다. Bittensor도 어느 정도 상관 관계를 보여주지만, 다른 프로젝트에는 해당되지 않습니다.\n- 저장소 수에 대해서는, Oraichain과 Ocean Protocol이 가장 많으며, 명확히 연도별로 늘어나고 있습니다.\n- Bittensor, Ocean Protocol, 그리고 Oraichain은 연도별로 커밋 수를 늘리고 있으며, SingularityNET은 Numerai와 함께 줄어들고 있습니다. Fetch.ai는 벨 모양 곡선을 보여주는데, 개발이 2018년, 2019년, 2020년에 매우 많았지만, 최초와 최근 연도에는 낮았습니다.\n\n간단히 말하면, 각 프로젝트의 연도별 커밋을 합산하여 순위를 매기려면 다음과 같은 결과를 얻을 수 있습니다:\n\n- Fetch.ai — 41465 개의 커밋.\n- Ocean Protocol — 3362 개의 커밋.\n- SingularityNET — 26245 개의 커밋.\n- Bittensor — 23336 개의 커밋.\n- Oraichain — 21136 개의 커밋.\n- Numerai — 2543 개의 커밋.\n\n# 활동에 따른 프로젝트 순위 (코드)\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 연도별로 필터된 데이터셋을 그룹화하는 함수입니다.\n\n```js\ndef gen_group_year(filt_dataframe):\n    \"\"\" 필터된 데이터셋을 연도별로 그룹화하는 함수입니다 \"\"\"\n    df_commits_temp = filt_dataframe.sort_values(\n        by='date')[['date', 'sha', 'repo', 'author', 'message']]\n    df_commits_temp['date'] = pd.to_datetime(df_commits_temp['date'])\n    df_commits_temp['year'] = df_commits_temp['date'].dt.year\n    df_commits_temp = df_commits_temp.groupby('year').agg(\n            {\n                'sha': 'count',\n                'repo': 'nunique',\n                'author': 'nunique'}).reset_index().rename(\n                columns={\n                    'sha': 'n_commits',\n                    'author': 'n_participants',\n                    'repo': 'n_repos'})\n    return df_commits_temp\n```\n\n이제 각 프로젝트에 함수를 적용해봅시다:\n\n```js\ndf_commits_bittensor_year = gen_group_year(df_commits_bittensor_filt)\ndf_commits_fetchai_year = gen_group_year(df_commits_fetchai_filt)\ndf_commits_numerai_year = gen_group_year(df_commits_numerai_filt)\ndf_commits_ocean_year = gen_group_year(df_commits_ocean_filt)\ndf_commits_oraichain_year = gen_group_year(df_commits_oraichain_filt)\ndf_commits_singular_year = gen_group_year(df_commits_singular_filt)\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 차트의 코드입니다:\n\n```js\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom datetime import datetime\n\ndef bar_activity_n_repos(datasets, main_title, subplot_titles):\n    \"\"\" Make bar char for activity and repos over time \"\"\"\n    num_datasets = len(datasets)\n    num_rows = (num_datasets + 1) // 2\n    fig, axes = plt.subplots(num_rows, 2, figsize=(14, 7*num_rows))\n    fig.suptitle(main_title, fontsize=30)\n    for i, (df, title) in enumerate(zip(datasets, subplot_titles)):\n        row = i // 2\n        col = i % 2\n        ax = axes[row, col]\n        sns.barplot(\n            x=\"year\",\n            y=\"n_commits\",\n            hue='n_repos',\n            data=df,\n            dodge=False,\n            palette='Blues',\n            ax=ax)\n        ax.spines['top'].set_visible(False)\n        ax.set_ylabel('Commits', fontsize=14)\n        ax.set_xlabel('Years', fontsize=14)\n        ax.set_title(title, fontsize=20)\n        ax.grid(axis='y', which='major', linestyle='--', linewidth=0.5)\n        legend = ax.legend()\n        legend.set_title(\"Repositories\")  # Setting legend title\n        # Add a red horizontal line for the mean of commits\n        mean_commits = df['n_commits'].mean()\n        ax.axhline(y=mean_commits, color='red', linestyle='--', label='mean')\n        # Annotate mean value above the line\n        ax.text(\n            0.05,\n            mean_commits * 1.05,\n            f'Mean: {mean_commits:.2f}',\n            color='red',\n            fontsize=12,\n            va='bottom')\n    plt.tight_layout(rect=[0, 0.03, 1, 0.95])  # Adjust subplot title position\n    plt.subplots_adjust(hspace=0.2, wspace=0.2)  # Add gap between charts\n    plt.show()\r\n```\n\n# 가장 활발한 개발자 순위\n\n이 섹션에서는 각 프로젝트에서 가장 활발한 개발자를 살펴보고, 그들의 상호작용을 시간에 따라 살펴볼 것입니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다가오는 차트는 막대 그래프입니다. 첫 번째 차트는 연도별로 커밋 수가 가장 많은 상위 10명의 저자를 보여주며, 두 번째 차트는 매년 가장 활발한 개발자를 순위로 나타냅니다. 각 프로젝트에 대해 두 차트를 살펴봐요.\n\n## Bittensor\n\n![Bittensor Chart](/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_8.png)\n\n위의 막대 차트를 보면, 각 개발자가 매년 비슷한 수의 커밋을 하지 않는다는 것을 알 수 있습니다. 즉, 저자들은 매년 비슷한 수의 커밋을 하지 않는다는 것입니다. 이는 각 개발자가 자신의 전문 분야가 있고, 가장 익숙한 기술에 대해 작업하기 때문일 수 있습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n개발 초기 몇 년(2017년, 2018년 및 2029년)에는 Pierre Krieger, Robert Habermeier 및 Bastian Kocher가 프로젝트 개발에 참여했습니다. 그 중 일부는 Polkadot에서 알려져 있습니다. 이야기해야 할 것은 2019년에 Gavin Wood도 프로젝트 개발에 합류했다는 것입니다.\n\n가장 많은 커밋이 이루어진 고점은 Carro가 2022년에 기여했습니다. 동일한 개발자가 2023년에도 일부 기여를 했으며, 전반적으로 이 분은 이러한 연도에 발생한 특정 작업에 중요한 역할을 한 것으로 보입니다.\n\n마지막 몇 년 동안 p-ferreira가 2023년과 2024년에 가장 많은 커밋을 한 것으로 보입니다. Cameron Fairchild는 최근 몇 년간 높은 헌신을 보여주었지만 2024년에는 그렇게 많이 하지는 않은 것 같습니다.\n\n이제 연도별 총 커밋 수를 기준으로 개발자들을 순위 매겨 보겠습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래 차트를 기준으로:\n\n- 2017년에는 Robert Habermeier가 가장 많은 커밋을 하였으며, 2018년에는 Gavin Wood가 활약했습니다.\n- 2019년에는 Bastian Kocher가 가장 활발하였습니다.\n- unconst는 2020년, 2021년, 2023년에 1위를 기록했습니다.\n- 2022년에는 Carro가 가장 높은 피크에 기여한 바 있습니다.\n- 현재까지는 p-ferreira가 2024년 가장 활발하게 활동 중입니다.\n\n전체 기간을 살펴보면, Bastian Kocher가 프로젝트에서 가장 많은 커밋을 하였으며, unconst가 그 뒤를 이었습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 페치.에이\n\n![이미지](/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_10.png)\n\n위 차트에서 우리는 상위 10명의 개발자 중 아무도 2024년에 기여를 하지 않고 있다는 것을 결론 지을 수 있습니다. 가장 최근의 커밋은 2022년과 2023년이며, 이는 ali와 Yuri Turchenkov에 의해 이루어졌습니다. David Minarsch는 2021년에 매우 활발히 활동했으며 커밋의 최고 피크(2500건 이상)는 2020년에 그에 의해 이루어졌습니다. Ethan Buchman 역시 2016년부터 2018년 사이에 많은 커밋을 하였지만, 2019년 이후로 활동이 없습니다. 또한 이 프로젝트에서 일한 최초의 사람 중 한 명이기도 하지만, 최초의 커밋은 Jae Kwon에 의해 이루어졌습니다.\n\n이제 각 연도별로 가장 활발하게 활동한 개발자들을 살펴봅시다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_11.png]을(를) 참고하면 다음과 같습니다:\n\n- Jae Kwon은 프로젝트 시작 시점인 2014년과 2015년에 가장 활발하게 개발을 진행했습니다.\n- Ethan Buchman은 2016년, 2017년 및 2018년에 리더였습니다.\n- David Minarsch는 2019년, 2020년 및 2021년에 가장 많은 커밋을 했습니다.\n- Yuri Turchenkov은 2022년에 119개의 커밋을 했습니다.\n- James Riehl은 2023년과 2024년에 가장 많은 커밋을 했습니다.\n\n전체적으로 Ethan Buchman(5911개의 커밋)이 가장 활발한 개발자였고, David Minarsch(5002개의 커밋)와 Jae Kwon(2604개의 커밋)이 이어졌습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## Numerai\n\n![image](/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_12.png)\n\n위 차트에서 전체 커밋 수가 가장 많은 상위 10명의 개발자를 볼 수 있습니다. Keith Goodman과 Xander Dunn은 2017년과 2018년에 가장 많은 커밋을 보였습니다. 그러나 현재는 더이상 기여를 하지 않는 것으로 보입니다. 몇 년 동안 가장 꾸준하게 활동한 개발자는 Anson Chu로 보입니다.\n\n지난 몇 년간 Noah Harasz는 꽤 활발히 활동했습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 목록의 대부분의 개발자는 1년에서 2년 사이에 기여하였으며, 참여할 때 상당히 활발하지만 오랫동안 머무르지 않았습니다.\n\n이제 각 연도별 주요 기여자를 분석해보겠습니다.\n\n![chart](/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_13.png)\n\n차트를 살펴보면:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 첫 번째 실제 개발은 2017년에 키스 굿맨(Kieth Goodman)과 함께 시작되었고, 2018년까지 계속되었습니다.\n- 2019년에는 제이슨 파리아니(Jason Paryani)가 주도하며, 2020년에는 나타샤-제이드 챈들러(Natasha-Jade Chandler)의 시기였습니다.\n- 2021년에는 titbtcqash의 시기였습니다.\n- 2023년과 2024년에는 노아 하라즈(Noah Harasz)가 가장 많은 커밋을 했습니다.\n\n총적으로, 키스 굿맨이 822개의 커밋으로 현저히 가장 활발한 개발자였습니다. 그 다음으로는 노아 하라즈가 207개의 커밋, 그리고 제이슨 파리아니가 196개의 커밋을 했습니다.\n\n## Ocean Protocol\n\n![Ocean Protocol Image](/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_14.png)\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 막대 차트에서 우리는 Ocean Protocol에서 활발히 활동하는 상위 10명의 개발자를 볼 수 있습니다. Matthias Kretschmann은 처음부터 개발을 해오고 있으며, 지난 두 해 동안 커밋을 하지 않았더라도, 여전히 이전에 가장 활발한 개발자입니다. Trent McConaghy는 (trentmc) 이름으로 차트에 두 번 나타나며, 최고의 협력자 중 하나이기도 하며, 지난 몇 년간 상당히 활발하게 활동했습니다. Matthias Kretschmann은 가장 많은 커밋 피크를 보여주지만, Jamie Hewitt와 Norbert도 최근 몇 년간 두 가지 중요한 피크를 보여줍니다.\n\n이제 연도별 최고 기여자를 살펴봅시다.\n\n![chart](/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_15.png)\n\n위의 차트를 관찰함으로써 다음을 결론짓을 수 있습니다:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- Matthias Kretschmann은 2018년부터 2021년까지 가장 활발하게 활동한 개발자였습니다. 또한 프로젝트 전체에서 가장 많은 커밋을 보유한 저자입니다(4666개의 커밋).\n- Jamie Hewitt은 2022년에 우세하며, 또한 두 번째로 활발한 개발자입니다(2133개의 커밋).\n- Norbert은 2023년에 우세합니다.\n- 2024년에는 Trent McConaghy가 지금까지 가장 많은 커밋을 가지고 있습니다.\n\n## Oraichain\n\n![image](/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_16.png)\n\nOraichain의 가장 활발한 10명의 개발자가 위의 막대 차트로 나타나 있습니다. 해당 그림은 몇 개의 봉우리로 특징 지어집니다. 개발자들이 1년에서 2년 사이에 노력을 집중했음을 나타냅니다. Thunnini은 2019년부터 2021년까지 매우 활발하게 활동했으며, Le Duc Pham과 함께였습니다. 가장 높은 커밋 피크는 Pham Tu에 의해 2023년에 기록되었습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n최근 가장 많은 커밋을 한 개발자는 Hau Nguyen Van, Toan Dang, sonlha 그리고 ducphamle2라는 이름의 Le Duc Pham입니다.\n\n이제 각 연도별로 가장 활발한 개발자들을 살펴보겠습니다.\n\n![2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_17.png](/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_17.png)\n\n상단의 막대 차트는 다음 정보를 제공합니다:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- Yury Delendik은 2018년에 가장 활발히 활동했습니다.\n- 2019년부터 2021년까지 Thunnini가 커밋 수에서 우세했습니다.\n- 2022년에는 Le Duc Pham이 선두를 차지했습니다.\n- 2023년에는 Pham Tu가 모든 기간에 가장 많은 커밋을 했습니다.\n- 2024년에는 Hau Nguyen Van이 가장 활발한 개발자입니다.\n\n예상대로, Thunnini가 총 커밋 수로 가장 많은(2458건)를 기록했습니다. 이어서 Pham Tu(2427건)와 Le Duc Pham(2273건) 순으로 나타났습니다.\n\n## SingularityNET\n\n<img src=\"/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_18.png\" />\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 표에서 볼 수 있듯이, 상위 10명의 가장 활발한 개발자는 대부분 2018년부터 2021년 사이에 활동했으며 몇 가지 예외가 있습니다. 일부 개발자는 몇 년 동안 일관성을 보였는데, 이들은 Prashant Gupta, anandrgitnirman, dasari-ananya 및 Sridhar Babu Kolapalli입니다. 초기 개발은 특히 Vitaly Bogdanov에 의해 표시되었으며, 커밋의 최고점은 2019년 Vivek에 의해 이루어졌습니다.\n\nRajeev는 최근 몇 년간 가장 활발한 개발자 중 한 명이었으며, anandrgitnirman과 함께 활동하고 있었습니다.\n\n이제 매년 최고의 개발자들을 살펴보는 시간입니다.\n\n![이미지](/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_19.png)\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 차트에서 다음을 결론지을 수 있습니다:\n\n- Marco Argentieri는 프로젝트 초창기(2017년)에 가장 활발했습니다.\n- 2018년에는 Vitaly Bogdanov가 선두를 담당했습니다.\n- 가장 높은 커밋 피크는 2019년에 Vivek이 올렸습니다.\n- 2020년은 Pratik의 시기였고, 2021년은 Rajeev의 시간이었으며, 2022년은 anandrgitnirman의 시기였습니다.\n- Marco Capozzoli는 최근 몇 년간 가장 활발한 개발자였습니다.\n\n다른 프로젝트와 달리, 대부분의 경우 연도별로 한 명의 개발자가 있으며, 한 명의 개발자가 여러 해 동안 지배하는 경우는 드뭅니다. 그래도 Marco Capozzoli는 2023년과 2024년에 1위를 차지했습니다. 전체적으로 Vivek이 1927개의 커밋으로 가장 활발했고, 그 뒤를 이어 anandrgitnirman의 1340개 커밋, 마지막으로 Vitaly Bogdanov의 1106개 커밋이 이어졌습니다.\n\n# 활동에 따라 저장소 순위 매기기\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 섹션에서는 각 프로젝트에서 활동이 가장 많은 상위 10개 저장소를 살펴보겠습니다. 이는 프로젝트 저장소에 제출된 커밋 수로 측정됩니다.\n\n## Bittensor\n\n현재 Bittensor는 총 31개의 저장소를 보유하고 있지만, 시간상의 이유로 상위 10개 저장소만 고려하여 시각화를 더 잘하고 가장 활발한 저장소에 대해 심층적인 연구를 할 것입니다.\n\n![이미지](/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_20.png)\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 커밋 수에 따라 정렬된 상위 10개 리포지토리 목록과 각각의 GitHub 저장소가 있습니다:\n\n- polkadot-sdk: https://github.com/opentensor/polkadot-sdk\n- bittensor: https://github.com/opentensor/bittensor\n- subtensor: https://github.com/opentensor/subtensor\n- prompting: https://github.com/opentensor/prompting\n- developer-docs: https://github.com/opentensor/developer-docs\n- old-docs: https://github.com/opentensor/old-docs\n- validators: https://github.com/opentensor/validators\n- text-prompting: https://github.com/opentensor/text-prompting\n- mem-pytorch: https://github.com/opentensor/mem-pytorch\n- squid: https://github.com/opentensor/squid\n\npolkadot-sdk는 가장 많은 커밋 수(13789개)를 가진 저장소로, Polkadot 네트워크에서 개발을 시작하는 데 필요한 모든 리소스를 제공합니다. 이것은 또한 Polkadot의 개발자들이이 프로젝트에 참여하는 이유입니다. 목록에서 두 번째로 많은 커밋을 가진 저장소인 bittensor가 뒤를 이어 나옵니다.\n\n세 번째로는 subtensor가 차지하는데, 이는 Bittensor의 substrate-chain입니다. 이 저장소는 다음을 수행합니다:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- Bittensor의 합의 메커니즘 실행\n- 신경 정보, IP 등을 광고합니다.\n- TAO를 통해 가치 이체를 용이하게 함.\n\n## Fetch.ai\n\n현재 Fetch.ai는 57개의 저장소를 가지고 있습니다. 하지만 우리는 상위 10개 저장소만 살펴보고 더 나은 시각화를 위해 최고 활동적인 저장소에 대해 심층적인 연구를 진행할 것입니다.\n\n![이미지](/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_21.png)\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 커밋 수를 기준으로 정렬된 상위 10개 리포지토리와 해당 GitHub 저장소 목록입니다:\n\n- agents-aea: [링크](https://github.com/fetchai/agents-aea)\n- tendermint: [링크](https://github.com/fetchai/tendermint)\n- cosmos-consensus: [링크](https://github.com/fetchai/cosmos-consensus)\n- cosmos-sdk: [링크](https://github.com/fetchai/cosmos-sdk)\n- ledger: [링크](https://github.com/fetchai/ledger)\n- ledger-archive: [링크](https://github.com/fetchai/ledger-archive)\n- agents-tac: [링크](https://github.com/fetchai/agents-tac)\n- cosmos-explorer: [링크](https://github.com/fetchai/cosmos-explorer)\n- docs: [링크](https://github.com/fetchai/docs)\n- colearn: [링크](https://github.com/fetchai/colearn)\n\n1위는 1천 개 이상의 커밋을 기록한 agents-aea입니다. 이 저장소는 자율 경제 에이전트를 만들 수 있도록 합니다. 두 번째는 tendermint이며, Cosmos 블록체인 환경에서 매우 흔한 비잔틴 장애 허용 (BFT) 미들웨어입니다. cosmos-consensus가 세 번째로 순위되어 있습니다. 일반적으로 Fetch.ai는 여러 Cosmos 블록체인 리포지토리를 사용합니다.\n\n## Numerai\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNumerai은 현재 21개의 저장소가 있지만 시각화를 더 잘 하기 위해 상위 10개 저장소만 살펴보고 가장 활발한 저장소에 대해 심층 연구를 할 것입니다.\n\n아래는 커밋 수로 정렬된 상위 10개 저장소 목록과 해당 GitHub 저장소입니다:\n\n- numerox: https://github.com/numerai/numer\n- doc: https://github.com/numerai/docs\n- example-scripts: https://github.com/numerai/example-scripts\n- submission-criteria: https://github.com/numerai/submission-criteria\n- numerai-cli: https://github.com/numerai/numerai-cli\n- doc-jp: https://github.com/numerai/docs-jp\n- heroku-buildpack-polymer: https://github.com/numerai/heroku-buildpack-polymer\n- numerai-predict: https://github.com/numerai/numerai-predict\n- tournament-data-integrity: https://github.com/numerai/tournament-data-integrity\n- tournament-contracts: https://github.com/numerai/tournament-contracts\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nnumerox가 가장 많은 커밋을 가진 저장소입니다. Numerai 토너먼트 도구 상자입니다. 두 번째로 활발한 것은 Numerai에 관한 자습서와 문서가 있는 docs입니다. 세 번째로는 이름 그대로 Numerai 토너먼트를 위한 코드 예제를 보여주기 위해 할애된 example-scripts입니다.\n\n## Ocean Protocol\n\n현재 쓰고 있는 시점에서 Ocean Protocol은 79개의 저장소를 보유하고 있지만, 가장 활동적인 저장소를 파악하고 깊은 연구를 하기 쉽도록 상위 10개 저장소만 분석하겠습니다.\n\n![이미지](/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_23.png)\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 커밋 수로 정렬된 상위 10개 저장소 목록과 해당 GitHub 저장소가 있습니다:\n\n- pdr-docs: https://github.com/oceanprotocol/pdr-docs\n- docs: https://github.com/oceanprotocol/docs\n- ocean.js: https://github.com/oceanprotocol/ocean.js\n- marketplace-launchpad: https://github.com/oceanprotocol/marketplace-launchpad\n- market: https://github.com/oceanprotocol/market\n- waves: https://github.com/oceanprotocol/waves\n- df-web: https://github.com/oceanprotocol/df-web\n- contracts: https://github.com/oceanprotocol/contracts\n- ocean.py: https://github.com/oceanprotocol/ocean.py\n- aquarius: https://github.com/oceanprotocol/aquarius\n\nOcean Protocol 프로젝트에서 문서 작성이 중요합니다. 가장 활발한 두 저장소는 문서와 관련이 있으며, 첫 번째는 Predictoor를 위한 것이고 두 번째는 일반 스택을 위한 것입니다. 차트는 Predictoor가 팀이 우선순위를 두고 있는 도구라는 것을 시사하며, 이는 높은 커밋 수와 매우 상세한 문서화로 확인할 수 있습니다. 세 번째로는 Ocean의 프로토콜 기술을 사용할 수 있게 해주는 ocean.js가 있습니다. 커밋 수를 보면, JavaScript가 Python보다 더 많이 요청된다고 가정할 수 있습니다. 왜냐하면 ocean.py 패키지도 있지만 활동이 훨씬 적습니다.\n\n네 번째로, 개발자들이 자신만의 마켓플레이스를 만드는 방법을 가르치는 marketplace-launchpad이 있습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## Oraichain\n\nOraichain은 109개의 저장소가 있습니다. 그러나 시각화를 용이하게 하고 가장 활발한 것을 더 깊이 연구하기 위해 상위 10개 저장소만 보겠습니다.\n\n![이미지](/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_24.png)\n\n아래는 커밋 수에 따라 정렬된 상위 10개 저장소 목록이며, 각 저장소의 GitHub 저장소입니다:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- owallet: https://github.com/oraichain/owallet\n- oraiswap-frontend: https://github.com/oraichain/oraiswap-frontend\n- oraiscan-frontend: https://github.com/oraichain/oraiscan-frontend\n- keplr-extension-orai: https://github.com/oraichain/keplr-extension-orai\n- oraidex-sdk: https://github.com/oraichain/oraidex-sdk\n- smart-studio: https://github.com/oraichain/smart-studio\n- orai: https://github.com/oraichain/orai\n- oraiswap: https://github.com/oraichain/oraiswap\n- oraiwasm: https://github.com/oraichain/oraiwasm\n- cosmosjs: https://github.com/oraichain/cosmosjs\n\n위 차트를 보면 owallet이 가장 활동적인 프로젝트임을 알 수 있습니다. 이 지갑은 Cosmos 및 EVM 통합을 지원합니다. 두 번째로 활발한 저장소는 Oraichain DEX의 일부인 oraiswap-frontend입니다. 가장 활발한 3번째 저장소는 Oraichain을 위한 블록 익스플로러인 oraiscan-frontend입니다.\n\n## 싱귤래리티넷\n\n싱귤래리티넷은 목록에서 가장 많은 저장소(116개)를 보유한 프로젝트입니다. 그러나 더 나은 시각화를 위해 상위 10개 저장소만 살펴보고 각각에 대해 약간 깊이 파고들어보겠습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 커밋 수에 따라 순서가 매겨진 상위 10개 저장소 목록과 해당 GitHub 저장소가 있습니다:\n\n- snet-marketplace-service: https://github.com/singnet/snet-marketplace-service\n- snet-dapp: https://github.com/singnet/snet-dapp\n- snet-daemon: https://github.com/singnet/snet-daemon\n- dev-portal: https://github.com/singnet/dev-portal\n- snet-cli: https://github.com/singnet/snet-cli\n- airdrop-services: https://github.com/singnet/airdrop-services\n- snet-betav1-dapp: https://github.com/singnet/snet-betav1-dapp\n- offernet: https://github.com/singnet/offernet\n- ai-dsl: https://github.com/singnet/ai-dsl\n- airdrop-dapp: https://github.com/singnet/airdrop-dapp\n\n가장 많은 커밋을 가진 저장소는 snet-marketplace-service입니다. 이 저장소는 SingularityNET의 시장을 사용하는 방법을 가르쳐 줍니다. 프로젝트의 탈중앙화 애플리케이션(snet-dapp)을 구축하는 데 사용된 저장소가 두 번째로 활동적입니다. 세 번째로 커밋 수가 많은 저장소는 SingularityNET 데몬이고, 그 다음은 플랫폼 및 시장에 대한 많은 문서를 제공하는 dev-portal입니다. 또한 두 개의 에어드랍에 전념한 저장소도 있습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 결론\n\n이 문서는 여러 프로젝트 내 개발자 활동에 대한 포괄적인 견해를 제공합니다. 프로젝트 성장과 개발자 참여의 지표로서 커밋 및 저장소 사용의 중요성을 강조하며, 주요 사건이 개발 활동에 미치는 영향을 보여주고, 연도별 활동을 기반으로 저장소를 순위로 나열합니다.\n\n우리는 좋은 데이터 처리 방법론과 몇 개의 바 차트를 통해 각 프로젝트의 활동에 대해 풍부한 정보를 얻을 수 있었습니다. 요약하자면, Python과 데이터 분석에 대한 충분한 지식을 가지고 있으면 스테이크홀더, 투자자 및 경쟁업체가 GitHub 개발 활동에 기반한 정보에 근거하여 판단을 내릴 수 있습니다.\n\n전체 보고서는 [이 링크](링크)에서 찾아볼 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_0.png"},"coverImage":"/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_0.png","tag":["Tech"],"readingTime":39},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<img src=\"/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_0.png\">\n<p>GitHub 개발 데이터는 특정 프로젝트나 회사의 전체 활동을 평가하려는 기관, 투자자, 경쟁업체에게 소중한 통찰을 제공합니다. 이 데이터를 분석함으로써 이해관계자들은 특정 시간대의 최고 기여자를 식별하고 가장 활발한 저장소를 파악하며 프로젝트의 단계별 목표와 활동 수준 사이의 관계를 발견할 수 있습니다.</p>\n<p>다음 글에서는 web3 생태계의 여섯 개의 오픈 소스 AI 프로젝트의 GitHub 개발 데이터를 살펴보겠습니다. 이들은 다음과 같습니다:</p>\n<ul>\n<li>Ocean Protocol: 이 프로젝트는 암호화폐 가격 예측 알고리즘부터 데이터 과학 도전과 시장을 위한 다양한 솔루션을 보유하고 있습니다.</li>\n<li>Bittensor: 이 프로젝트는 탈중앙화된 컴퓨팅으로 AI 민주화를 목표로 하는 모듈식 아키텍처를 가지고 있습니다.</li>\n<li>Fetch.ai: 이 프로젝트는 SDK를 사용하여 AI 기반 프로젝트를 통해 개발자들이 수익을 창출할 수 있도록 합니다.</li>\n<li>Numerai: 이 프로젝트는 주식 시장 예측 토너먼트를 주최하며 우승자에게 토큰을 보상합니다.</li>\n<li>Oraichain: AI의 다차원 신뢰도를 검증하고 독특한 AI 오라클을 활용하여 Web3 애플리케이션을 구축하기 위한 IBC 활성화된 Layer 1입니다.</li>\n<li>SingularityNET: 이 프로젝트의 임무는 탈중앙화 방식으로 인공 일반 지능(AGI)을 개발하는 것입니다.</li>\n</ul>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>Python을 사용하여 분석을 진행하기 위해 위에서 언급한 각 프로젝트에 대한 GitHub의 공개 데이터를 활용할 것입니다. 데이터 조작 및 정리에는 Pandas를 사용하고, 시각화에는 Matplotlib 및 Seaborn을 활용하여 가치 있는 통찰을 제공하는 정보적인 차트를 생성할 것입니다. 커밋 빈도, 저장소 생성, 개발자 참여 등과 같은 주요 메트릭을 조사함으로써 개발 참여 수준이 프로젝트 성공의 신뢰할 수 있는 지표인지를 평가할 수 있습니다.</p>\n<p>저희의 분석은 GitHub에서의 개발 활동의 중요성과 해당 활동이 이해관계자, 투자자, 경쟁 업체에게 가치 있는 통찰을 제공할 수 있다는 점을 탐색하는 데서 시작할 것입니다. 그 다음으로, 개발 활동에 대한 시간적 분석을 탐구한 다음, 커밋 빈도를 기준으로 프로젝트를 순위 매기겠습니다. 또한 가장 활발하게 활동하는 개발자를 식별하고 순위를 매기며, 주목받는 저장소도 확인하여 각 프로젝트의 역학을 포괄적으로 이해할 수 있도록 할 것입니다.</p>\n<h1>GitHub의 개발 활동 데이터의 중요성</h1>\n<p>개발 활동을 연구하는 것이 왜 중요한지 궁금하다면, 이 섹션에서 이해관계자, 투자자 및 경쟁사에게 특히 중요할 수 있는 몇 가지 핵심 요소를 강조하겠습니다. 함께 살펴보겠습니다:</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h2>이해관계자들</h2>\n<ul>\n<li>프로젝트 건강 및 진행 상황에 대한 통찰력을 얻을 수 있습니다: 이해관계자들은 프로젝트가 활발히 개발되고 있는지, 어떤 기능이 우선 순위에 있는지 이해할 수 있습니다.</li>\n<li>프로젝트 역학 이해하기: 시간적 분석을 통해 이해관계자들은 프로젝트 수명주기를 이해하고 중요한 진전 또는 정체 기간을 식별할 수 있습니다. 또한 프로젝트의 주요 이정표들과의 상관 관계를 파악하는 데 도움이 됩니다.</li>\n<li>개발자 성과 평가: 많은 커밋 수는 언제나 생산성이 높다는 것을 의미하는 것은 아니지만, 이는 이해관계자들이 개발자의 참여 정도를 이해하고, 그가 회사의 건강한 성장에 기여하는지를 이해하는 데 좋은 지표입니다.</li>\n</ul>\n<h2>투자자들</h2>\n<ul>\n<li>안내된 투자 결정: 커밋 빈도 및 활동 트렌드를 분석함으로써, 투자자들은 활발히 개발되고 유지되는 유망한 프로젝트를 식별할 수 있습니다. 높은 개발 활동은 투자 수익 가능성에 대한 긍정적인 신호가 될 수 있습니다.</li>\n<li>프로젝트 장기성 이해하기: 시간적 분석을 통해 투자자들은 프로젝트의 지속 가능성과 장기적 잠재력을 평가할 수 있습니다.</li>\n<li>개발자 품질: 개발자들의 활동 및 GitHub 프로필을 알게 되면 투자자들은 프로젝트 뒤에 있는 재능을 볼 수 있습니다.</li>\n</ul>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h2>경쟁사</h2>\n<ul>\n<li>경쟁 전략 수립: 경쟁사는 경쟁 프로젝트의 개발 활동을 분석하여 그들의 장단점을 이해할 수 있습니다. 이 정보를 활용하여 경쟁사를 앞서가는 전략을 개발할 수 있습니다.</li>\n<li>트렌드 파악: 개발 활동의 시계열 분석을 통해 경쟁사는 시장 트렌드를 식별하고 그에 맞게 전략을 조정할 수 있습니다. 어떤 저장소가 가장 많은 관심을 받고 있는지 파악함으로써 경쟁사는 주목받고 있는 분야에 초점을 맞출 수 있습니다.</li>\n</ul>\n<p>전반적으로, GitHub 개발 활동을 연구함으로써 이해당사자, 투자자, 경쟁사 및 다른 이야기에서 언급되지 않은 당사자들에게 맞춤형 통찰력을 제공하여 각 그룹이 정보에 근거한 결정을 내리고 소프트웨어 개발 생태계에서 경쟁력을 유지할 수 있도록 도와줍니다.</p>\n<h1>시간별 개발자 활동 분석</h1>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>이 섹션에서는 각 프로젝트의 시간 경과에 따른 커밋 수와 참여자 수를 조사할 것입니다. 데이터 포인트가 매일 표시하기에 너무 많기 때문에 대신 주간 보기를 사용할 것입니다. 차트에서 범례의 각 색깔은 서로 다른 연도에 해당합니다. 우리는 활동의 증가와 주요 프로젝트 이정표간의 연결을 살펴볼 것이며, 시간이 흐름에 따라 개발 강도가 어떻게 변하는지 확인할 것입니다.</p>\n<h2>Bittensor</h2>\n<img src=\"/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_1.png\">\n<p>위의 Bittensor 차트에서 시간이 흐름에 따라 개발 활동이 점차 증가하는 것을 볼 수 있습니다. 2023년이 가장 많은 커밋과 다른 참여자 수가 있었던 해로, 거의 50명의 개발자가 Bittsensor의 저장소에서 업그레이드를 진행했습니다. 2024년에 관한 데이터가 충분치 않지만, 이미 개발이 크게 감소하고 참여자 수도 줄어든 것을 볼 수 있으며, 이는 2019년과 거의 동일합니다. 그렇지만 우리는 몇몇 중요한 커밋 피크를 볼 수 있습니다. 주로 연도의 처음 4주와 11, 12주쯤에 발생합니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>예를 들어, 1월 17일쯤에 Bittsensor의 토큰 $TAO가 상승한 상위 그룹에 속했다는 기사를 찾을 수 있습니다. 이때가 2024년의 첫 번째 정점이 있는 시기와 비슷합니다. 그러나 토큰의 가격은 개발 활동과 항상 상관관계가 있는 것은 아니므로, 차트에서 가장 큰 정점은 2023년 말에 발생했으며, 이 기간 동안 큰 상승 추세가 없었습니다.</p>\n<h2>Fetch.ai</h2>\n<p><img src=\"/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_2.png\" alt=\"이미지\"></p>\n<p>Fetch.ai 차트는 Bittensor의 차트와 매우 다릅니다. 개발 활동은 주로 2017년부터 2021년 사이에 발생한 것을 볼 수 있습니다. 회사는 2017년에 설립되었고 2019년에 출시되었지만, 개발은 2014년에 더 빨리 시작된 것으로 보입니다. 커밋의 주요 정점은 출시의 거의 1년 전인 2018년 중반에 있습니다. GitHub 기여자 수는 2019년에 증가하며, 해당 해에 가장 큰 정점을 나타냅니다. 그 후 바로 2020년 1월 1일에 회사는 메인넷에서 출시되었습니다. 이 이벤트는 2019년 후반에 보다 많은 기여자와 커밋과 관련이 있을 수 있습니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>지금까지 개발은 지난 세 년 동안 감소하는 것으로 보이지만, 2024년에는 참여자 수와 커밋 수가 약간 상승하는 추세를 보입니다.</p>\n<h2>Numerai</h2>\n<p><img src=\"/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_3.png\" alt=\"Numerai\"></p>\n<p>Numerai의 전반적인 개발 활동은 크지 않습니다. 2017년과 2021년에는 몇 가지 의미있는 정점이 있습니다. 또한 참여자/기여자 수가 다른 프로젝트와 달리 커밋 수와 관련이 없어 보입니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>2021년의 고점이 Numerai 네트워크 발표와 관련이 있을 수 있습니다. 이 기사에서는 CLI의 업데이트와 예측 노드 구현이 언급되었습니다.</p>\n<h2>Ocean Protocol</h2>\n<p><img src=\"/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_4.png\" alt=\"Ocean Protocol\"></p>\n<p>Ocean Protocol 팀은 몇 년 동안 꾸준히 높은 커밋 수를 보여주었으며, 300개 이상의 커밋을 넘는 고점이 있었습니다. 이러한 커밋 고점과 참여자 또는 기여자 수 사이에 상관 관계가 있는 것으로 보이지만, 모든 경우에 일관되게 관찰되는 것은 아닙니다. 그러나 2022년에는 분명한 상관 관계가 있습니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>Predictoor는 2023년 9월 12일 경부 출시되었습니다 (37주차), 이 날짜 이전에는 개발에서 상당한 피크가 있었는데, 이는 해당 이벤트와 관련이 있을 수 있습니다.</p>\n<p>가장 큰 피크는 2020년 41주에서 43주에 발생했는데, 바로 Ocean Protocol V3가 출시된 후였습니다. 이에 관한 기사를 확인할 수 있습니다:</p>\n<p>2024년에는 2023년과 비교했을 때 개발 활동이 현저히 감소했으며, 저장소에서 활발히 작업하는 기여자 수도 감소했습니다. 그러나 이는 반드시 전체 연도에 대한 지속적인 추세를 나타내지는 않을 수 있습니다. 2020년과 마찬가지로, 개발 면에서는 천천히 시작되었지만 연말에는 급증세를 지켜볼 수 있을 것입니다.</p>\n<h2>Oraichain</h2>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p><img src=\"/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_5.png\" alt=\"이미지\"></p>\n<p>Oraichain Labs 차트를 보면 커밋 수와 참여자/기여자 수 사이에 명확한 상관 관계가 있는 것을 볼 수 있습니다. 2020년 말에 개발이 속도를 내며, 이는 2021년 2월의 공식 발표와 관련이 있을 수 있습니다.</p>\n<p>2023년은 개발에서 가장 활발한 해로, 이 추세가 2024년으로 이어지고 있습니다. 이 급증은 해커톤, 지갑 업데이트 및 통합과 같은 중요한 프로젝트 이정표를 반영하고 있습니다. 상대적으로 새로운 프로젝트이기 때문에, 특히 최근 몇 주간 다른 AI 프로젝트들보다 더 높은 개발 강도를 보여주고 있습니다.</p>\n<h2>싱귤러리티넷</h2>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p><img src=\"/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_6.png\" alt=\"Image\"></p>\n<p>이 차트는 SingularityNET의 개발이 2018년부터 2020년 사이에 정점에 이른 것을 보여줍니다. 이후 커밋 활동 및 기여자 수가 감소하는 추세를 보였습니다. 이 기사에 따르면, 백엔드 소프트웨어는 2019년에 성숙기에 이르렀으며 이는 또한 가장 많은 개발이 이루어진 해입니다.</p>\n<p>2024년에는 2023년과 비교했을 때 개발이 증가하는 것을 볼 수 있습니다. 이는 2018년부터 2020년 사이와 유사한 고개발의 새로운 이후를 나타낼 수 있습니다.</p>\n<h1>시간에 따른 개발자 활동 분석 (코드)</h1>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>제공된 데이터셋은 즉시 분석에 사용할 수 있는 상태가 아니라 데이터 조작 기술을 적용하여 작업해야 합니다. 먼저 각 행별로 데이터셋에서 의미 있는 정보를 추출하고, 분석을 위해 다른 정리된 데이터프레임을 생성하기 위해 두 가지 함수를 만듭니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> pandas <span class=\"hljs-keyword\">as</span> pd\n\ndef <span class=\"hljs-title function_\">process_commits_row</span>(row):\n    <span class=\"hljs-string\">\"\"</span><span class=\"hljs-string\">\" 이 함수는 데이터셋의 각 행에서 의미 있는 정보를 추출하여 딕셔너리로 반환합니다. 'repo' 변수가\n    나중에 저장소 데이터셋과 병합하는 데 사용됨에 유의하세요. \"</span><span class=\"hljs-string\">\"\"</span>\n    repo = \\\n        row[<span class=\"hljs-string\">'url'</span>].<span class=\"hljs-title function_\">split</span>(<span class=\"hljs-string\">'repos'</span>)[<span class=\"hljs-number\">1</span>].<span class=\"hljs-title function_\">split</span>(<span class=\"hljs-string\">'commits'</span>)[<span class=\"hljs-number\">0</span>].<span class=\"hljs-title function_\">split</span>(<span class=\"hljs-string\">\"/\"</span>)[-<span class=\"hljs-number\">2</span>]\n    <span class=\"hljs-keyword\">return</span> {\n        <span class=\"hljs-string\">'sha'</span>: row[<span class=\"hljs-string\">'sha'</span>],\n        <span class=\"hljs-string\">'repo'</span>: repo,\n        <span class=\"hljs-string\">'node_id'</span>: row[<span class=\"hljs-string\">'node_id'</span>],\n        <span class=\"hljs-string\">'author'</span>: row[<span class=\"hljs-string\">'commit'</span>][<span class=\"hljs-string\">'author'</span>][<span class=\"hljs-string\">'name'</span>],\n        <span class=\"hljs-string\">'date'</span>: row[<span class=\"hljs-string\">'commit'</span>][<span class=\"hljs-string\">'author'</span>][<span class=\"hljs-string\">'date'</span>],\n        <span class=\"hljs-string\">'message'</span>: row[<span class=\"hljs-string\">'commit'</span>][<span class=\"hljs-string\">'message'</span>]}\n\ndef <span class=\"hljs-title function_\">gen_df_commits_filt</span>(df):\n    <span class=\"hljs-string\">\"\"</span><span class=\"hljs-string\">\" 이 함수는 데이터셋을 반복하면서 'process_commits_row' 함수를 각 행에 적용합니다. 결과는\n    딕셔너리의 목록으로 반환되어 최종적으로 DataFrame으로 반환됩니다. \"</span><span class=\"hljs-string\">\"\"</span>\n    all_features = []\n    <span class=\"hljs-keyword\">for</span> row <span class=\"hljs-keyword\">in</span> df.<span class=\"hljs-title function_\">iterrows</span>():\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-title function_\">range</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-title function_\">len</span>(row[<span class=\"hljs-number\">1</span>]) - <span class=\"hljs-number\">1</span>):\n            <span class=\"hljs-attr\">try</span>:\n                all_features.<span class=\"hljs-title function_\">append</span>(<span class=\"hljs-title function_\">process_commits_row</span>(row[<span class=\"hljs-number\">1</span>][i]))\n            except <span class=\"hljs-title class_\">Exception</span>:\n                pass\n    <span class=\"hljs-keyword\">return</span> pd.<span class=\"hljs-title class_\">DataFrame</span>(all_features)\n</code></pre>\n<p>위의 함수들은 각 프로젝트의 커밋 데이터셋을 대상으로 합니다. 이 두 함수를 함께 사용하여 sha, repo, node_id, author, date 및 message의 특징을 가진 필터링된 데이터프레임을 생성합니다. 그런 다음 데이터셋을 호출하고 각각의 데이터셋에 gen_df_commits_filt() 함수를 적용할 수 있습니다.</p>\n<pre><code class=\"hljs language-js\"># 데이터셋 호출\ndf_commits_bittensor = pd.<span class=\"hljs-title function_\">read_json</span>(<span class=\"hljs-string\">'datasets/bittensor_commits.json'</span>)\ndf_commits_fetchai = pd.<span class=\"hljs-title function_\">read_json</span>(<span class=\"hljs-string\">'datasets/fetchai_commits.json'</span>)\ndf_commits_numerai = pd.<span class=\"hljs-title function_\">read_json</span>(<span class=\"hljs-string\">'datasets/numerai_commits.json'</span>)\ndf_commits_ocean = pd.<span class=\"hljs-title function_\">read_json</span>(<span class=\"hljs-string\">'datasets/oceanprotocol_commits.json'</span>)\ndf_commits_oraichain = pd.<span class=\"hljs-title function_\">read_json</span>(<span class=\"hljs-string\">'datasets/oraichain_commits.json'</span>)\ndf_commits_singular = pd.<span class=\"hljs-title function_\">read_json</span>(<span class=\"hljs-string\">'datasets/singularitynet_commits.json'</span>)\n\n# 데이터셋 필터링\ndf_commits_bittensor_filt = <span class=\"hljs-title function_\">gen_df_commits_filt</span>(df_commits_bittensor)\ndf_commits_fetchai_filt = <span class=\"hljs-title function_\">gen_df_commits_filt</span>(df_commits_fetchai)\ndf_commits_numerai_filt = <span class=\"hljs-title function_\">gen_df_commits_filt</span>(df_commits_numerai)\ndf_commits_ocean_filt = <span class=\"hljs-title function_\">gen_df_commits_filt</span>(df_commits_ocean)\ndf_commits_oraichain_filt = <span class=\"hljs-title function_\">gen_df_commits_filt</span>(df_commits_oraichain)\ndf_commits_singular_filt = <span class=\"hljs-title function_\">gen_df_commits_filt</span>(df_commits_singular)\n</code></pre>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>날짜별로 그룹화된 데이터셋을 사용하여 시간별 사용자 활동을 관찰할 수 있습니다. 이전에 언급했듯이 날짜 데이터가 너무 많아서 차트에 표시하기에는 많았기 때문에 주차별, 연도별로 그룹화했습니다. 아래 함수를 사용하여 그룹화했습니다:</p>\n<pre><code class=\"hljs language-js\">def <span class=\"hljs-title function_\">gen_group_week</span>(filt_dataframe):\n    <span class=\"hljs-string\">\"\"</span><span class=\"hljs-string\">\" 이 함수는 필터링된 데이터셋을 주별로 그룹화합니다 \"</span><span class=\"hljs-string\">\"\"</span>\n    df_commits_temp = filt_dataframe.<span class=\"hljs-title function_\">sort_values</span>(\n        by=<span class=\"hljs-string\">'date'</span>)[[<span class=\"hljs-string\">'date'</span>, <span class=\"hljs-string\">'sha'</span>, <span class=\"hljs-string\">'repo'</span>, <span class=\"hljs-string\">'author'</span>, <span class=\"hljs-string\">'message'</span>]]\n    df_commits_temp.<span class=\"hljs-property\">date</span> = df_commits_temp.<span class=\"hljs-property\">date</span>.<span class=\"hljs-title function_\">apply</span>(\n        lambda <span class=\"hljs-attr\">x</span>: datetime.<span class=\"hljs-title function_\">strptime</span>(x, <span class=\"hljs-string\">'%Y-%m-%dT%H:%M:%SZ'</span>))\n    df_commits_temp[<span class=\"hljs-string\">'week'</span>] = df_commits_temp[<span class=\"hljs-string\">'date'</span>].<span class=\"hljs-property\">dt</span>.<span class=\"hljs-title function_\">strftime</span>(<span class=\"hljs-string\">'%W-%Y'</span>)\n    df_commits_temp = df_commits_temp.<span class=\"hljs-title function_\">groupby</span>(<span class=\"hljs-string\">'week'</span>).<span class=\"hljs-title function_\">agg</span>(\n        {\n            <span class=\"hljs-string\">'sha'</span>: <span class=\"hljs-string\">'count'</span>,\n            <span class=\"hljs-string\">'repo'</span>: <span class=\"hljs-string\">'nunique'</span>,\n            <span class=\"hljs-string\">'author'</span>: <span class=\"hljs-string\">'nunique'</span>}).<span class=\"hljs-title function_\">reset_index</span>().<span class=\"hljs-title function_\">rename</span>(\n            columns={\n                <span class=\"hljs-string\">'sha'</span>: <span class=\"hljs-string\">'n_commits'</span>,\n                <span class=\"hljs-string\">'author'</span>: <span class=\"hljs-string\">'n_participants'</span>,\n                <span class=\"hljs-string\">'repo'</span>: <span class=\"hljs-string\">'n_repos'</span>})\n    df_commits_temp[<span class=\"hljs-string\">'week_num'</span>] = \\\n        df_commits_temp[<span class=\"hljs-string\">'week'</span>].<span class=\"hljs-property\">str</span>.<span class=\"hljs-title function_\">split</span>(<span class=\"hljs-string\">'-'</span>).<span class=\"hljs-property\">str</span>[<span class=\"hljs-number\">0</span>].<span class=\"hljs-title function_\">astype</span>(int)\n    df_commits_temp[<span class=\"hljs-string\">'year'</span>] = \\\n        df_commits_temp[<span class=\"hljs-string\">'week'</span>].<span class=\"hljs-property\">str</span>.<span class=\"hljs-title function_\">split</span>(<span class=\"hljs-string\">'-'</span>).<span class=\"hljs-property\">str</span>[<span class=\"hljs-number\">1</span>].<span class=\"hljs-title function_\">astype</span>(int)\n    df_commits_temp = df_commits_temp.<span class=\"hljs-title function_\">sort_values</span>(by=[<span class=\"hljs-string\">'year'</span>, <span class=\"hljs-string\">'week_num'</span>])\n    <span class=\"hljs-keyword\">return</span> df_commits_temp\n</code></pre>\n<p>마지막으로, 필터링된 각 데이터셋에 이 함수를 적용했습니다.</p>\n<pre><code class=\"hljs language-js\">df_commits_bittensor_week = <span class=\"hljs-title function_\">gen_group_week</span>(df_commits_bittensor_filt)\ndf_commits_fetchai_week = <span class=\"hljs-title function_\">gen_group_week</span>(df_commits_fetchai_filt)\ndf_commits_numerai_week = <span class=\"hljs-title function_\">gen_group_week</span>(df_commits_numerai_filt)\ndf_commits_ocean_week = <span class=\"hljs-title function_\">gen_group_week</span>(df_commits_ocean_filt)\ndf_commits_oraichain_week = <span class=\"hljs-title function_\">gen_group_week</span>(df_commits_oraichain_filt)\ndf_commits_singular_week = <span class=\"hljs-title function_\">gen_group_week</span>(df_commits_singular_filt)\n</code></pre>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>이제 이전에 표시된 막대 차트를 구동한 코드를 살펴보겠습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> pandas <span class=\"hljs-keyword\">as</span> pd\n<span class=\"hljs-keyword\">import</span> matplotlib.<span class=\"hljs-property\">pyplot</span> <span class=\"hljs-keyword\">as</span> plt\n<span class=\"hljs-keyword\">import</span> seaborn <span class=\"hljs-keyword\">as</span> sns\n<span class=\"hljs-keyword\">from</span> datetime <span class=\"hljs-keyword\">import</span> datetime\n\ndef <span class=\"hljs-title function_\">chart_user_activity</span>(df, protocol):\n    <span class=\"hljs-string\">\"\"</span><span class=\"hljs-string\">\" 사용자 활동에 대한 시간별 막대 차트 작성 \"</span><span class=\"hljs-string\">\"\"</span>\n    fig, ax1 = plt.<span class=\"hljs-title function_\">subplots</span>(figsize=(<span class=\"hljs-number\">20</span>, <span class=\"hljs-number\">8</span>))\n    # 필요에 따라 색상 수를 조정할 수 있습니다\n    colors = sns.<span class=\"hljs-title function_\">color_palette</span>(<span class=\"hljs-string\">'tab10'</span>, <span class=\"hljs-title function_\">len</span>(df[<span class=\"hljs-string\">'year'</span>].<span class=\"hljs-title function_\">unique</span>()))\n    # 각 고유 연도를 색상에 매핑하는 딕셔너리 생성\n    year_colors = <span class=\"hljs-title function_\">dict</span>(<span class=\"hljs-title function_\">zip</span>(df[<span class=\"hljs-string\">'year'</span>].<span class=\"hljs-title function_\">unique</span>(), colors))\n    sns.<span class=\"hljs-title function_\">barplot</span>(\n        df,\n        x=<span class=\"hljs-string\">'week'</span>,\n        y=<span class=\"hljs-string\">'n_commits'</span>,\n        hue=<span class=\"hljs-string\">'year'</span>,\n        ax=ax1,\n        dodge=<span class=\"hljs-title class_\">False</span>,\n        palette=year_colors)\n    ax1.<span class=\"hljs-title function_\">set_xlabel</span>(<span class=\"hljs-string\">'주'</span>, fontsize=<span class=\"hljs-number\">18</span>)\n    ax1.<span class=\"hljs-title function_\">set_ylabel</span>(<span class=\"hljs-string\">'커밋 수'</span>, fontsize=<span class=\"hljs-number\">18</span>)\n    ax1.<span class=\"hljs-title function_\">tick_params</span>(<span class=\"hljs-string\">'y'</span>, labelsize=<span class=\"hljs-number\">12</span>)\n    ax1.<span class=\"hljs-title function_\">set_title</span>(f<span class=\"hljs-string\">\"{protocol} 개발자 활동 시간별\"</span>, fontsize=<span class=\"hljs-number\">30</span>)\n    ax1.<span class=\"hljs-title function_\">grid</span>(axis=<span class=\"hljs-string\">'y'</span>, which=<span class=\"hljs-string\">'major'</span>, linestyle=<span class=\"hljs-string\">'--'</span>, linewidth=<span class=\"hljs-number\">0.5</span>)\n    ax2 = ax1.<span class=\"hljs-title function_\">twinx</span>()\n    sns.<span class=\"hljs-title function_\">lineplot</span>(\n        df,\n        x=<span class=\"hljs-string\">'week'</span>,\n        y=<span class=\"hljs-string\">'n_participants'</span>,\n        ax=ax2,\n        linestyle=<span class=\"hljs-string\">'--'</span>,\n        marker=<span class=\"hljs-string\">'o'</span>,\n        color=<span class=\"hljs-string\">'r'</span>,\n        alpha=<span class=\"hljs-number\">0.5</span>)\n    ax2.<span class=\"hljs-title function_\">set_ylabel</span>(<span class=\"hljs-string\">'참가자 수'</span>, fontsize=<span class=\"hljs-number\">18</span>, color=<span class=\"hljs-string\">'r'</span>)\n    ax2.<span class=\"hljs-title function_\">tick_params</span>(<span class=\"hljs-string\">'y'</span>, colors=<span class=\"hljs-string\">'r'</span>, labelsize=<span class=\"hljs-number\">12</span>)\n    ax2.<span class=\"hljs-property\">xaxis</span>.<span class=\"hljs-title function_\">set_ticks</span>(df[<span class=\"hljs-string\">'week'</span>][::<span class=\"hljs-number\">10</span>])\n    ax1.<span class=\"hljs-property\">spines</span>[<span class=\"hljs-string\">'top'</span>].<span class=\"hljs-title function_\">set_visible</span>(<span class=\"hljs-title class_\">False</span>)\n    ax2.<span class=\"hljs-property\">spines</span>[<span class=\"hljs-string\">'top'</span>].<span class=\"hljs-title function_\">set_visible</span>(<span class=\"hljs-title class_\">False</span>)\n    # x축 눈금 라벨에서 연도 부분 제거\n    labels = [item.<span class=\"hljs-title function_\">get_text</span>().<span class=\"hljs-title function_\">split</span>(<span class=\"hljs-string\">'-'</span>)[<span class=\"hljs-number\">0</span>] <span class=\"hljs-keyword\">for</span> item <span class=\"hljs-keyword\">in</span> ax1.<span class=\"hljs-title function_\">get_xticklabels</span>()]\n    ax1.<span class=\"hljs-title function_\">set_xticklabels</span>(labels)\n    ax1.<span class=\"hljs-title function_\">tick_params</span>(<span class=\"hljs-string\">'x'</span>, labelsize=<span class=\"hljs-number\">12</span>)\n    ax2.<span class=\"hljs-title function_\">set_ylim</span>(bottom=<span class=\"hljs-number\">0</span>)\n    plt.<span class=\"hljs-title function_\">show</span>()\n</code></pre>\n<p>차트를 표시하려면 다음과 같이 간단히 수행할 수 있습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title function_\">chart_user_activity</span>(df_commits_bittensor_week, <span class=\"hljs-string\">'Bittensor'</span>)\n</code></pre>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h1>프로젝트 활동 기준으로 순위 매기기</h1>\n<p>이 섹션에서는 서로 다른 프로젝트에서 시간이 지남에 따라 사용된 커밋 수와 리포지토리 수를 비교해 보겠습니다.</p>\n<p><img src=\"/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_7.png\" alt=\"이미지\"></p>\n<p>위 막대 차트는 시간이 지남에 따른 커밋의 진화와 연도별 사용된 다른 리포지토리의 수를 확인할 수 있습니다. 이 차트들을 검토하면 몇 가지 초기 관찰을 할 수 있습니다:</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<ul>\n<li>가장 많은 커밋(41465)을 가진 프로젝트는 Fetch.ai이며, 그 다음으로 Ocean Protocol이 33626개의 커밋을 가지고 있습니다. Fetch.ai가 가장 많은 커밋을 가졌다는 사실은 GitHub에서의 장기간 활동으로 인해 놀랍지 않습니다. Ocean Protocol은 4년 뒤에 시작했지만 이미 다른 최근 프로젝트와 비교하여 인상적인 개발 활동을 보여주고 있습니다.</li>\n<li>Bittensor, Ocean Protocol, Oraichain, 그리고 Numerai는 해마다 저장소 수를 늘리고 있으며, 2023년에는 가장 많은 저장소 사용량을 가지고 있습니다. 2024년에는 이 수가 늘어날 수 있습니다. 그러나 이 명제를 확인하기 위해 모든 데이터를 아직 갖고 있지는 않습니다.</li>\n<li>Oraichain은 커밋 수와 저장소 수 사이에 높은 상관 관계를 보여줍니다. Bittensor도 어느 정도 상관 관계를 보여주지만, 다른 프로젝트에는 해당되지 않습니다.</li>\n<li>저장소 수에 대해서는, Oraichain과 Ocean Protocol이 가장 많으며, 명확히 연도별로 늘어나고 있습니다.</li>\n<li>Bittensor, Ocean Protocol, 그리고 Oraichain은 연도별로 커밋 수를 늘리고 있으며, SingularityNET은 Numerai와 함께 줄어들고 있습니다. Fetch.ai는 벨 모양 곡선을 보여주는데, 개발이 2018년, 2019년, 2020년에 매우 많았지만, 최초와 최근 연도에는 낮았습니다.</li>\n</ul>\n<p>간단히 말하면, 각 프로젝트의 연도별 커밋을 합산하여 순위를 매기려면 다음과 같은 결과를 얻을 수 있습니다:</p>\n<ul>\n<li>Fetch.ai — 41465 개의 커밋.</li>\n<li>Ocean Protocol — 3362 개의 커밋.</li>\n<li>SingularityNET — 26245 개의 커밋.</li>\n<li>Bittensor — 23336 개의 커밋.</li>\n<li>Oraichain — 21136 개의 커밋.</li>\n<li>Numerai — 2543 개의 커밋.</li>\n</ul>\n<h1>활동에 따른 프로젝트 순위 (코드)</h1>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>아래는 연도별로 필터된 데이터셋을 그룹화하는 함수입니다.</p>\n<pre><code class=\"hljs language-js\">def <span class=\"hljs-title function_\">gen_group_year</span>(filt_dataframe):\n    <span class=\"hljs-string\">\"\"</span><span class=\"hljs-string\">\" 필터된 데이터셋을 연도별로 그룹화하는 함수입니다 \"</span><span class=\"hljs-string\">\"\"</span>\n    df_commits_temp = filt_dataframe.<span class=\"hljs-title function_\">sort_values</span>(\n        by=<span class=\"hljs-string\">'date'</span>)[[<span class=\"hljs-string\">'date'</span>, <span class=\"hljs-string\">'sha'</span>, <span class=\"hljs-string\">'repo'</span>, <span class=\"hljs-string\">'author'</span>, <span class=\"hljs-string\">'message'</span>]]\n    df_commits_temp[<span class=\"hljs-string\">'date'</span>] = pd.<span class=\"hljs-title function_\">to_datetime</span>(df_commits_temp[<span class=\"hljs-string\">'date'</span>])\n    df_commits_temp[<span class=\"hljs-string\">'year'</span>] = df_commits_temp[<span class=\"hljs-string\">'date'</span>].<span class=\"hljs-property\">dt</span>.<span class=\"hljs-property\">year</span>\n    df_commits_temp = df_commits_temp.<span class=\"hljs-title function_\">groupby</span>(<span class=\"hljs-string\">'year'</span>).<span class=\"hljs-title function_\">agg</span>(\n            {\n                <span class=\"hljs-string\">'sha'</span>: <span class=\"hljs-string\">'count'</span>,\n                <span class=\"hljs-string\">'repo'</span>: <span class=\"hljs-string\">'nunique'</span>,\n                <span class=\"hljs-string\">'author'</span>: <span class=\"hljs-string\">'nunique'</span>}).<span class=\"hljs-title function_\">reset_index</span>().<span class=\"hljs-title function_\">rename</span>(\n                columns={\n                    <span class=\"hljs-string\">'sha'</span>: <span class=\"hljs-string\">'n_commits'</span>,\n                    <span class=\"hljs-string\">'author'</span>: <span class=\"hljs-string\">'n_participants'</span>,\n                    <span class=\"hljs-string\">'repo'</span>: <span class=\"hljs-string\">'n_repos'</span>})\n    <span class=\"hljs-keyword\">return</span> df_commits_temp\n</code></pre>\n<p>이제 각 프로젝트에 함수를 적용해봅시다:</p>\n<pre><code class=\"hljs language-js\">df_commits_bittensor_year = <span class=\"hljs-title function_\">gen_group_year</span>(df_commits_bittensor_filt)\ndf_commits_fetchai_year = <span class=\"hljs-title function_\">gen_group_year</span>(df_commits_fetchai_filt)\ndf_commits_numerai_year = <span class=\"hljs-title function_\">gen_group_year</span>(df_commits_numerai_filt)\ndf_commits_ocean_year = <span class=\"hljs-title function_\">gen_group_year</span>(df_commits_ocean_filt)\ndf_commits_oraichain_year = <span class=\"hljs-title function_\">gen_group_year</span>(df_commits_oraichain_filt)\ndf_commits_singular_year = <span class=\"hljs-title function_\">gen_group_year</span>(df_commits_singular_filt)\n</code></pre>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>아래는 차트의 코드입니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> pandas <span class=\"hljs-keyword\">as</span> pd\n<span class=\"hljs-keyword\">import</span> matplotlib.<span class=\"hljs-property\">pyplot</span> <span class=\"hljs-keyword\">as</span> plt\n<span class=\"hljs-keyword\">import</span> seaborn <span class=\"hljs-keyword\">as</span> sns\n<span class=\"hljs-keyword\">from</span> datetime <span class=\"hljs-keyword\">import</span> datetime\n\ndef <span class=\"hljs-title function_\">bar_activity_n_repos</span>(datasets, main_title, subplot_titles):\n    <span class=\"hljs-string\">\"\"</span><span class=\"hljs-string\">\" Make bar char for activity and repos over time \"</span><span class=\"hljs-string\">\"\"</span>\n    num_datasets = <span class=\"hljs-title function_\">len</span>(datasets)\n    num_rows = (num_datasets + <span class=\"hljs-number\">1</span>) <span class=\"hljs-comment\">// 2</span>\n    fig, axes = plt.<span class=\"hljs-title function_\">subplots</span>(num_rows, <span class=\"hljs-number\">2</span>, figsize=(<span class=\"hljs-number\">14</span>, <span class=\"hljs-number\">7</span>*num_rows))\n    fig.<span class=\"hljs-title function_\">suptitle</span>(main_title, fontsize=<span class=\"hljs-number\">30</span>)\n    <span class=\"hljs-keyword\">for</span> i, (df, title) <span class=\"hljs-keyword\">in</span> <span class=\"hljs-title function_\">enumerate</span>(<span class=\"hljs-title function_\">zip</span>(datasets, subplot_titles)):\n        row = i <span class=\"hljs-comment\">// 2</span>\n        col = i % <span class=\"hljs-number\">2</span>\n        ax = axes[row, col]\n        sns.<span class=\"hljs-title function_\">barplot</span>(\n            x=<span class=\"hljs-string\">\"year\"</span>,\n            y=<span class=\"hljs-string\">\"n_commits\"</span>,\n            hue=<span class=\"hljs-string\">'n_repos'</span>,\n            data=df,\n            dodge=<span class=\"hljs-title class_\">False</span>,\n            palette=<span class=\"hljs-string\">'Blues'</span>,\n            ax=ax)\n        ax.<span class=\"hljs-property\">spines</span>[<span class=\"hljs-string\">'top'</span>].<span class=\"hljs-title function_\">set_visible</span>(<span class=\"hljs-title class_\">False</span>)\n        ax.<span class=\"hljs-title function_\">set_ylabel</span>(<span class=\"hljs-string\">'Commits'</span>, fontsize=<span class=\"hljs-number\">14</span>)\n        ax.<span class=\"hljs-title function_\">set_xlabel</span>(<span class=\"hljs-string\">'Years'</span>, fontsize=<span class=\"hljs-number\">14</span>)\n        ax.<span class=\"hljs-title function_\">set_title</span>(title, fontsize=<span class=\"hljs-number\">20</span>)\n        ax.<span class=\"hljs-title function_\">grid</span>(axis=<span class=\"hljs-string\">'y'</span>, which=<span class=\"hljs-string\">'major'</span>, linestyle=<span class=\"hljs-string\">'--'</span>, linewidth=<span class=\"hljs-number\">0.5</span>)\n        legend = ax.<span class=\"hljs-title function_\">legend</span>()\n        legend.<span class=\"hljs-title function_\">set_title</span>(<span class=\"hljs-string\">\"Repositories\"</span>)  # <span class=\"hljs-title class_\">Setting</span> legend title\n        # <span class=\"hljs-title class_\">Add</span> a red horizontal line <span class=\"hljs-keyword\">for</span> the mean <span class=\"hljs-keyword\">of</span> commits\n        mean_commits = df[<span class=\"hljs-string\">'n_commits'</span>].<span class=\"hljs-title function_\">mean</span>()\n        ax.<span class=\"hljs-title function_\">axhline</span>(y=mean_commits, color=<span class=\"hljs-string\">'red'</span>, linestyle=<span class=\"hljs-string\">'--'</span>, label=<span class=\"hljs-string\">'mean'</span>)\n        # <span class=\"hljs-title class_\">Annotate</span> mean value above the line\n        ax.<span class=\"hljs-title function_\">text</span>(\n            <span class=\"hljs-number\">0.05</span>,\n            mean_commits * <span class=\"hljs-number\">1.05</span>,\n            f<span class=\"hljs-string\">'Mean: {mean_commits:.2f}'</span>,\n            color=<span class=\"hljs-string\">'red'</span>,\n            fontsize=<span class=\"hljs-number\">12</span>,\n            va=<span class=\"hljs-string\">'bottom'</span>)\n    plt.<span class=\"hljs-title function_\">tight_layout</span>(rect=[<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0.03</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0.95</span>])  # <span class=\"hljs-title class_\">Adjust</span> subplot title position\n    plt.<span class=\"hljs-title function_\">subplots_adjust</span>(hspace=<span class=\"hljs-number\">0.2</span>, wspace=<span class=\"hljs-number\">0.2</span>)  # <span class=\"hljs-title class_\">Add</span> gap between charts\n    plt.<span class=\"hljs-title function_\">show</span>()\n</code></pre>\n<h1>가장 활발한 개발자 순위</h1>\n<p>이 섹션에서는 각 프로젝트에서 가장 활발한 개발자를 살펴보고, 그들의 상호작용을 시간에 따라 살펴볼 것입니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>다가오는 차트는 막대 그래프입니다. 첫 번째 차트는 연도별로 커밋 수가 가장 많은 상위 10명의 저자를 보여주며, 두 번째 차트는 매년 가장 활발한 개발자를 순위로 나타냅니다. 각 프로젝트에 대해 두 차트를 살펴봐요.</p>\n<h2>Bittensor</h2>\n<p><img src=\"/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_8.png\" alt=\"Bittensor Chart\"></p>\n<p>위의 막대 차트를 보면, 각 개발자가 매년 비슷한 수의 커밋을 하지 않는다는 것을 알 수 있습니다. 즉, 저자들은 매년 비슷한 수의 커밋을 하지 않는다는 것입니다. 이는 각 개발자가 자신의 전문 분야가 있고, 가장 익숙한 기술에 대해 작업하기 때문일 수 있습니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>개발 초기 몇 년(2017년, 2018년 및 2029년)에는 Pierre Krieger, Robert Habermeier 및 Bastian Kocher가 프로젝트 개발에 참여했습니다. 그 중 일부는 Polkadot에서 알려져 있습니다. 이야기해야 할 것은 2019년에 Gavin Wood도 프로젝트 개발에 합류했다는 것입니다.</p>\n<p>가장 많은 커밋이 이루어진 고점은 Carro가 2022년에 기여했습니다. 동일한 개발자가 2023년에도 일부 기여를 했으며, 전반적으로 이 분은 이러한 연도에 발생한 특정 작업에 중요한 역할을 한 것으로 보입니다.</p>\n<p>마지막 몇 년 동안 p-ferreira가 2023년과 2024년에 가장 많은 커밋을 한 것으로 보입니다. Cameron Fairchild는 최근 몇 년간 높은 헌신을 보여주었지만 2024년에는 그렇게 많이 하지는 않은 것 같습니다.</p>\n<p>이제 연도별 총 커밋 수를 기준으로 개발자들을 순위 매겨 보겠습니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>아래 차트를 기준으로:</p>\n<ul>\n<li>2017년에는 Robert Habermeier가 가장 많은 커밋을 하였으며, 2018년에는 Gavin Wood가 활약했습니다.</li>\n<li>2019년에는 Bastian Kocher가 가장 활발하였습니다.</li>\n<li>unconst는 2020년, 2021년, 2023년에 1위를 기록했습니다.</li>\n<li>2022년에는 Carro가 가장 높은 피크에 기여한 바 있습니다.</li>\n<li>현재까지는 p-ferreira가 2024년 가장 활발하게 활동 중입니다.</li>\n</ul>\n<p>전체 기간을 살펴보면, Bastian Kocher가 프로젝트에서 가장 많은 커밋을 하였으며, unconst가 그 뒤를 이었습니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h2>페치.에이</h2>\n<p><img src=\"/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_10.png\" alt=\"이미지\"></p>\n<p>위 차트에서 우리는 상위 10명의 개발자 중 아무도 2024년에 기여를 하지 않고 있다는 것을 결론 지을 수 있습니다. 가장 최근의 커밋은 2022년과 2023년이며, 이는 ali와 Yuri Turchenkov에 의해 이루어졌습니다. David Minarsch는 2021년에 매우 활발히 활동했으며 커밋의 최고 피크(2500건 이상)는 2020년에 그에 의해 이루어졌습니다. Ethan Buchman 역시 2016년부터 2018년 사이에 많은 커밋을 하였지만, 2019년 이후로 활동이 없습니다. 또한 이 프로젝트에서 일한 최초의 사람 중 한 명이기도 하지만, 최초의 커밋은 Jae Kwon에 의해 이루어졌습니다.</p>\n<p>이제 각 연도별로 가장 활발하게 활동한 개발자들을 살펴봅시다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>![2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_11.png]을(를) 참고하면 다음과 같습니다:</p>\n<ul>\n<li>Jae Kwon은 프로젝트 시작 시점인 2014년과 2015년에 가장 활발하게 개발을 진행했습니다.</li>\n<li>Ethan Buchman은 2016년, 2017년 및 2018년에 리더였습니다.</li>\n<li>David Minarsch는 2019년, 2020년 및 2021년에 가장 많은 커밋을 했습니다.</li>\n<li>Yuri Turchenkov은 2022년에 119개의 커밋을 했습니다.</li>\n<li>James Riehl은 2023년과 2024년에 가장 많은 커밋을 했습니다.</li>\n</ul>\n<p>전체적으로 Ethan Buchman(5911개의 커밋)이 가장 활발한 개발자였고, David Minarsch(5002개의 커밋)와 Jae Kwon(2604개의 커밋)이 이어졌습니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h2>Numerai</h2>\n<p><img src=\"/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_12.png\" alt=\"image\"></p>\n<p>위 차트에서 전체 커밋 수가 가장 많은 상위 10명의 개발자를 볼 수 있습니다. Keith Goodman과 Xander Dunn은 2017년과 2018년에 가장 많은 커밋을 보였습니다. 그러나 현재는 더이상 기여를 하지 않는 것으로 보입니다. 몇 년 동안 가장 꾸준하게 활동한 개발자는 Anson Chu로 보입니다.</p>\n<p>지난 몇 년간 Noah Harasz는 꽤 활발히 활동했습니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>이 목록의 대부분의 개발자는 1년에서 2년 사이에 기여하였으며, 참여할 때 상당히 활발하지만 오랫동안 머무르지 않았습니다.</p>\n<p>이제 각 연도별 주요 기여자를 분석해보겠습니다.</p>\n<p><img src=\"/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_13.png\" alt=\"chart\"></p>\n<p>차트를 살펴보면:</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<ul>\n<li>첫 번째 실제 개발은 2017년에 키스 굿맨(Kieth Goodman)과 함께 시작되었고, 2018년까지 계속되었습니다.</li>\n<li>2019년에는 제이슨 파리아니(Jason Paryani)가 주도하며, 2020년에는 나타샤-제이드 챈들러(Natasha-Jade Chandler)의 시기였습니다.</li>\n<li>2021년에는 titbtcqash의 시기였습니다.</li>\n<li>2023년과 2024년에는 노아 하라즈(Noah Harasz)가 가장 많은 커밋을 했습니다.</li>\n</ul>\n<p>총적으로, 키스 굿맨이 822개의 커밋으로 현저히 가장 활발한 개발자였습니다. 그 다음으로는 노아 하라즈가 207개의 커밋, 그리고 제이슨 파리아니가 196개의 커밋을 했습니다.</p>\n<h2>Ocean Protocol</h2>\n<p><img src=\"/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_14.png\" alt=\"Ocean Protocol Image\"></p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>위의 막대 차트에서 우리는 Ocean Protocol에서 활발히 활동하는 상위 10명의 개발자를 볼 수 있습니다. Matthias Kretschmann은 처음부터 개발을 해오고 있으며, 지난 두 해 동안 커밋을 하지 않았더라도, 여전히 이전에 가장 활발한 개발자입니다. Trent McConaghy는 (trentmc) 이름으로 차트에 두 번 나타나며, 최고의 협력자 중 하나이기도 하며, 지난 몇 년간 상당히 활발하게 활동했습니다. Matthias Kretschmann은 가장 많은 커밋 피크를 보여주지만, Jamie Hewitt와 Norbert도 최근 몇 년간 두 가지 중요한 피크를 보여줍니다.</p>\n<p>이제 연도별 최고 기여자를 살펴봅시다.</p>\n<p><img src=\"/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_15.png\" alt=\"chart\"></p>\n<p>위의 차트를 관찰함으로써 다음을 결론짓을 수 있습니다:</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<ul>\n<li>Matthias Kretschmann은 2018년부터 2021년까지 가장 활발하게 활동한 개발자였습니다. 또한 프로젝트 전체에서 가장 많은 커밋을 보유한 저자입니다(4666개의 커밋).</li>\n<li>Jamie Hewitt은 2022년에 우세하며, 또한 두 번째로 활발한 개발자입니다(2133개의 커밋).</li>\n<li>Norbert은 2023년에 우세합니다.</li>\n<li>2024년에는 Trent McConaghy가 지금까지 가장 많은 커밋을 가지고 있습니다.</li>\n</ul>\n<h2>Oraichain</h2>\n<p><img src=\"/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_16.png\" alt=\"image\"></p>\n<p>Oraichain의 가장 활발한 10명의 개발자가 위의 막대 차트로 나타나 있습니다. 해당 그림은 몇 개의 봉우리로 특징 지어집니다. 개발자들이 1년에서 2년 사이에 노력을 집중했음을 나타냅니다. Thunnini은 2019년부터 2021년까지 매우 활발하게 활동했으며, Le Duc Pham과 함께였습니다. 가장 높은 커밋 피크는 Pham Tu에 의해 2023년에 기록되었습니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>최근 가장 많은 커밋을 한 개발자는 Hau Nguyen Van, Toan Dang, sonlha 그리고 ducphamle2라는 이름의 Le Duc Pham입니다.</p>\n<p>이제 각 연도별로 가장 활발한 개발자들을 살펴보겠습니다.</p>\n<p><img src=\"/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_17.png\" alt=\"2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_17.png\"></p>\n<p>상단의 막대 차트는 다음 정보를 제공합니다:</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<ul>\n<li>Yury Delendik은 2018년에 가장 활발히 활동했습니다.</li>\n<li>2019년부터 2021년까지 Thunnini가 커밋 수에서 우세했습니다.</li>\n<li>2022년에는 Le Duc Pham이 선두를 차지했습니다.</li>\n<li>2023년에는 Pham Tu가 모든 기간에 가장 많은 커밋을 했습니다.</li>\n<li>2024년에는 Hau Nguyen Van이 가장 활발한 개발자입니다.</li>\n</ul>\n<p>예상대로, Thunnini가 총 커밋 수로 가장 많은(2458건)를 기록했습니다. 이어서 Pham Tu(2427건)와 Le Duc Pham(2273건) 순으로 나타났습니다.</p>\n<h2>SingularityNET</h2>\n<img src=\"/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_18.png\">\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>위의 표에서 볼 수 있듯이, 상위 10명의 가장 활발한 개발자는 대부분 2018년부터 2021년 사이에 활동했으며 몇 가지 예외가 있습니다. 일부 개발자는 몇 년 동안 일관성을 보였는데, 이들은 Prashant Gupta, anandrgitnirman, dasari-ananya 및 Sridhar Babu Kolapalli입니다. 초기 개발은 특히 Vitaly Bogdanov에 의해 표시되었으며, 커밋의 최고점은 2019년 Vivek에 의해 이루어졌습니다.</p>\n<p>Rajeev는 최근 몇 년간 가장 활발한 개발자 중 한 명이었으며, anandrgitnirman과 함께 활동하고 있었습니다.</p>\n<p>이제 매년 최고의 개발자들을 살펴보는 시간입니다.</p>\n<p><img src=\"/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_19.png\" alt=\"이미지\"></p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>위의 차트에서 다음을 결론지을 수 있습니다:</p>\n<ul>\n<li>Marco Argentieri는 프로젝트 초창기(2017년)에 가장 활발했습니다.</li>\n<li>2018년에는 Vitaly Bogdanov가 선두를 담당했습니다.</li>\n<li>가장 높은 커밋 피크는 2019년에 Vivek이 올렸습니다.</li>\n<li>2020년은 Pratik의 시기였고, 2021년은 Rajeev의 시간이었으며, 2022년은 anandrgitnirman의 시기였습니다.</li>\n<li>Marco Capozzoli는 최근 몇 년간 가장 활발한 개발자였습니다.</li>\n</ul>\n<p>다른 프로젝트와 달리, 대부분의 경우 연도별로 한 명의 개발자가 있으며, 한 명의 개발자가 여러 해 동안 지배하는 경우는 드뭅니다. 그래도 Marco Capozzoli는 2023년과 2024년에 1위를 차지했습니다. 전체적으로 Vivek이 1927개의 커밋으로 가장 활발했고, 그 뒤를 이어 anandrgitnirman의 1340개 커밋, 마지막으로 Vitaly Bogdanov의 1106개 커밋이 이어졌습니다.</p>\n<h1>활동에 따라 저장소 순위 매기기</h1>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>이 섹션에서는 각 프로젝트에서 활동이 가장 많은 상위 10개 저장소를 살펴보겠습니다. 이는 프로젝트 저장소에 제출된 커밋 수로 측정됩니다.</p>\n<h2>Bittensor</h2>\n<p>현재 Bittensor는 총 31개의 저장소를 보유하고 있지만, 시간상의 이유로 상위 10개 저장소만 고려하여 시각화를 더 잘하고 가장 활발한 저장소에 대해 심층적인 연구를 할 것입니다.</p>\n<p><img src=\"/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_20.png\" alt=\"이미지\"></p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>아래는 커밋 수에 따라 정렬된 상위 10개 리포지토리 목록과 각각의 GitHub 저장소가 있습니다:</p>\n<ul>\n<li>polkadot-sdk: <a href=\"https://github.com/opentensor/polkadot-sdk\" rel=\"nofollow\" target=\"_blank\">https://github.com/opentensor/polkadot-sdk</a></li>\n<li>bittensor: <a href=\"https://github.com/opentensor/bittensor\" rel=\"nofollow\" target=\"_blank\">https://github.com/opentensor/bittensor</a></li>\n<li>subtensor: <a href=\"https://github.com/opentensor/subtensor\" rel=\"nofollow\" target=\"_blank\">https://github.com/opentensor/subtensor</a></li>\n<li>prompting: <a href=\"https://github.com/opentensor/prompting\" rel=\"nofollow\" target=\"_blank\">https://github.com/opentensor/prompting</a></li>\n<li>developer-docs: <a href=\"https://github.com/opentensor/developer-docs\" rel=\"nofollow\" target=\"_blank\">https://github.com/opentensor/developer-docs</a></li>\n<li>old-docs: <a href=\"https://github.com/opentensor/old-docs\" rel=\"nofollow\" target=\"_blank\">https://github.com/opentensor/old-docs</a></li>\n<li>validators: <a href=\"https://github.com/opentensor/validators\" rel=\"nofollow\" target=\"_blank\">https://github.com/opentensor/validators</a></li>\n<li>text-prompting: <a href=\"https://github.com/opentensor/text-prompting\" rel=\"nofollow\" target=\"_blank\">https://github.com/opentensor/text-prompting</a></li>\n<li>mem-pytorch: <a href=\"https://github.com/opentensor/mem-pytorch\" rel=\"nofollow\" target=\"_blank\">https://github.com/opentensor/mem-pytorch</a></li>\n<li>squid: <a href=\"https://github.com/opentensor/squid\" rel=\"nofollow\" target=\"_blank\">https://github.com/opentensor/squid</a></li>\n</ul>\n<p>polkadot-sdk는 가장 많은 커밋 수(13789개)를 가진 저장소로, Polkadot 네트워크에서 개발을 시작하는 데 필요한 모든 리소스를 제공합니다. 이것은 또한 Polkadot의 개발자들이이 프로젝트에 참여하는 이유입니다. 목록에서 두 번째로 많은 커밋을 가진 저장소인 bittensor가 뒤를 이어 나옵니다.</p>\n<p>세 번째로는 subtensor가 차지하는데, 이는 Bittensor의 substrate-chain입니다. 이 저장소는 다음을 수행합니다:</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<ul>\n<li>Bittensor의 합의 메커니즘 실행</li>\n<li>신경 정보, IP 등을 광고합니다.</li>\n<li>TAO를 통해 가치 이체를 용이하게 함.</li>\n</ul>\n<h2>Fetch.ai</h2>\n<p>현재 Fetch.ai는 57개의 저장소를 가지고 있습니다. 하지만 우리는 상위 10개 저장소만 살펴보고 더 나은 시각화를 위해 최고 활동적인 저장소에 대해 심층적인 연구를 진행할 것입니다.</p>\n<p><img src=\"/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_21.png\" alt=\"이미지\"></p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>아래는 커밋 수를 기준으로 정렬된 상위 10개 리포지토리와 해당 GitHub 저장소 목록입니다:</p>\n<ul>\n<li>agents-aea: <a href=\"https://github.com/fetchai/agents-aea\" rel=\"nofollow\" target=\"_blank\">링크</a></li>\n<li>tendermint: <a href=\"https://github.com/fetchai/tendermint\" rel=\"nofollow\" target=\"_blank\">링크</a></li>\n<li>cosmos-consensus: <a href=\"https://github.com/fetchai/cosmos-consensus\" rel=\"nofollow\" target=\"_blank\">링크</a></li>\n<li>cosmos-sdk: <a href=\"https://github.com/fetchai/cosmos-sdk\" rel=\"nofollow\" target=\"_blank\">링크</a></li>\n<li>ledger: <a href=\"https://github.com/fetchai/ledger\" rel=\"nofollow\" target=\"_blank\">링크</a></li>\n<li>ledger-archive: <a href=\"https://github.com/fetchai/ledger-archive\" rel=\"nofollow\" target=\"_blank\">링크</a></li>\n<li>agents-tac: <a href=\"https://github.com/fetchai/agents-tac\" rel=\"nofollow\" target=\"_blank\">링크</a></li>\n<li>cosmos-explorer: <a href=\"https://github.com/fetchai/cosmos-explorer\" rel=\"nofollow\" target=\"_blank\">링크</a></li>\n<li>docs: <a href=\"https://github.com/fetchai/docs\" rel=\"nofollow\" target=\"_blank\">링크</a></li>\n<li>colearn: <a href=\"https://github.com/fetchai/colearn\" rel=\"nofollow\" target=\"_blank\">링크</a></li>\n</ul>\n<p>1위는 1천 개 이상의 커밋을 기록한 agents-aea입니다. 이 저장소는 자율 경제 에이전트를 만들 수 있도록 합니다. 두 번째는 tendermint이며, Cosmos 블록체인 환경에서 매우 흔한 비잔틴 장애 허용 (BFT) 미들웨어입니다. cosmos-consensus가 세 번째로 순위되어 있습니다. 일반적으로 Fetch.ai는 여러 Cosmos 블록체인 리포지토리를 사용합니다.</p>\n<h2>Numerai</h2>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>Numerai은 현재 21개의 저장소가 있지만 시각화를 더 잘 하기 위해 상위 10개 저장소만 살펴보고 가장 활발한 저장소에 대해 심층 연구를 할 것입니다.</p>\n<p>아래는 커밋 수로 정렬된 상위 10개 저장소 목록과 해당 GitHub 저장소입니다:</p>\n<ul>\n<li>numerox: <a href=\"https://github.com/numerai/numer\" rel=\"nofollow\" target=\"_blank\">https://github.com/numerai/numer</a></li>\n<li>doc: <a href=\"https://github.com/numerai/docs\" rel=\"nofollow\" target=\"_blank\">https://github.com/numerai/docs</a></li>\n<li>example-scripts: <a href=\"https://github.com/numerai/example-scripts\" rel=\"nofollow\" target=\"_blank\">https://github.com/numerai/example-scripts</a></li>\n<li>submission-criteria: <a href=\"https://github.com/numerai/submission-criteria\" rel=\"nofollow\" target=\"_blank\">https://github.com/numerai/submission-criteria</a></li>\n<li>numerai-cli: <a href=\"https://github.com/numerai/numerai-cli\" rel=\"nofollow\" target=\"_blank\">https://github.com/numerai/numerai-cli</a></li>\n<li>doc-jp: <a href=\"https://github.com/numerai/docs-jp\" rel=\"nofollow\" target=\"_blank\">https://github.com/numerai/docs-jp</a></li>\n<li>heroku-buildpack-polymer: <a href=\"https://github.com/numerai/heroku-buildpack-polymer\" rel=\"nofollow\" target=\"_blank\">https://github.com/numerai/heroku-buildpack-polymer</a></li>\n<li>numerai-predict: <a href=\"https://github.com/numerai/numerai-predict\" rel=\"nofollow\" target=\"_blank\">https://github.com/numerai/numerai-predict</a></li>\n<li>tournament-data-integrity: <a href=\"https://github.com/numerai/tournament-data-integrity\" rel=\"nofollow\" target=\"_blank\">https://github.com/numerai/tournament-data-integrity</a></li>\n<li>tournament-contracts: <a href=\"https://github.com/numerai/tournament-contracts\" rel=\"nofollow\" target=\"_blank\">https://github.com/numerai/tournament-contracts</a></li>\n</ul>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>numerox가 가장 많은 커밋을 가진 저장소입니다. Numerai 토너먼트 도구 상자입니다. 두 번째로 활발한 것은 Numerai에 관한 자습서와 문서가 있는 docs입니다. 세 번째로는 이름 그대로 Numerai 토너먼트를 위한 코드 예제를 보여주기 위해 할애된 example-scripts입니다.</p>\n<h2>Ocean Protocol</h2>\n<p>현재 쓰고 있는 시점에서 Ocean Protocol은 79개의 저장소를 보유하고 있지만, 가장 활동적인 저장소를 파악하고 깊은 연구를 하기 쉽도록 상위 10개 저장소만 분석하겠습니다.</p>\n<p><img src=\"/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_23.png\" alt=\"이미지\"></p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>아래는 커밋 수로 정렬된 상위 10개 저장소 목록과 해당 GitHub 저장소가 있습니다:</p>\n<ul>\n<li>pdr-docs: <a href=\"https://github.com/oceanprotocol/pdr-docs\" rel=\"nofollow\" target=\"_blank\">https://github.com/oceanprotocol/pdr-docs</a></li>\n<li>docs: <a href=\"https://github.com/oceanprotocol/docs\" rel=\"nofollow\" target=\"_blank\">https://github.com/oceanprotocol/docs</a></li>\n<li>ocean.js: <a href=\"https://github.com/oceanprotocol/ocean.js\" rel=\"nofollow\" target=\"_blank\">https://github.com/oceanprotocol/ocean.js</a></li>\n<li>marketplace-launchpad: <a href=\"https://github.com/oceanprotocol/marketplace-launchpad\" rel=\"nofollow\" target=\"_blank\">https://github.com/oceanprotocol/marketplace-launchpad</a></li>\n<li>market: <a href=\"https://github.com/oceanprotocol/market\" rel=\"nofollow\" target=\"_blank\">https://github.com/oceanprotocol/market</a></li>\n<li>waves: <a href=\"https://github.com/oceanprotocol/waves\" rel=\"nofollow\" target=\"_blank\">https://github.com/oceanprotocol/waves</a></li>\n<li>df-web: <a href=\"https://github.com/oceanprotocol/df-web\" rel=\"nofollow\" target=\"_blank\">https://github.com/oceanprotocol/df-web</a></li>\n<li>contracts: <a href=\"https://github.com/oceanprotocol/contracts\" rel=\"nofollow\" target=\"_blank\">https://github.com/oceanprotocol/contracts</a></li>\n<li>ocean.py: <a href=\"https://github.com/oceanprotocol/ocean.py\" rel=\"nofollow\" target=\"_blank\">https://github.com/oceanprotocol/ocean.py</a></li>\n<li>aquarius: <a href=\"https://github.com/oceanprotocol/aquarius\" rel=\"nofollow\" target=\"_blank\">https://github.com/oceanprotocol/aquarius</a></li>\n</ul>\n<p>Ocean Protocol 프로젝트에서 문서 작성이 중요합니다. 가장 활발한 두 저장소는 문서와 관련이 있으며, 첫 번째는 Predictoor를 위한 것이고 두 번째는 일반 스택을 위한 것입니다. 차트는 Predictoor가 팀이 우선순위를 두고 있는 도구라는 것을 시사하며, 이는 높은 커밋 수와 매우 상세한 문서화로 확인할 수 있습니다. 세 번째로는 Ocean의 프로토콜 기술을 사용할 수 있게 해주는 ocean.js가 있습니다. 커밋 수를 보면, JavaScript가 Python보다 더 많이 요청된다고 가정할 수 있습니다. 왜냐하면 ocean.py 패키지도 있지만 활동이 훨씬 적습니다.</p>\n<p>네 번째로, 개발자들이 자신만의 마켓플레이스를 만드는 방법을 가르치는 marketplace-launchpad이 있습니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h2>Oraichain</h2>\n<p>Oraichain은 109개의 저장소가 있습니다. 그러나 시각화를 용이하게 하고 가장 활발한 것을 더 깊이 연구하기 위해 상위 10개 저장소만 보겠습니다.</p>\n<p><img src=\"/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_24.png\" alt=\"이미지\"></p>\n<p>아래는 커밋 수에 따라 정렬된 상위 10개 저장소 목록이며, 각 저장소의 GitHub 저장소입니다:</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<ul>\n<li>owallet: <a href=\"https://github.com/oraichain/owallet\" rel=\"nofollow\" target=\"_blank\">https://github.com/oraichain/owallet</a></li>\n<li>oraiswap-frontend: <a href=\"https://github.com/oraichain/oraiswap-frontend\" rel=\"nofollow\" target=\"_blank\">https://github.com/oraichain/oraiswap-frontend</a></li>\n<li>oraiscan-frontend: <a href=\"https://github.com/oraichain/oraiscan-frontend\" rel=\"nofollow\" target=\"_blank\">https://github.com/oraichain/oraiscan-frontend</a></li>\n<li>keplr-extension-orai: <a href=\"https://github.com/oraichain/keplr-extension-orai\" rel=\"nofollow\" target=\"_blank\">https://github.com/oraichain/keplr-extension-orai</a></li>\n<li>oraidex-sdk: <a href=\"https://github.com/oraichain/oraidex-sdk\" rel=\"nofollow\" target=\"_blank\">https://github.com/oraichain/oraidex-sdk</a></li>\n<li>smart-studio: <a href=\"https://github.com/oraichain/smart-studio\" rel=\"nofollow\" target=\"_blank\">https://github.com/oraichain/smart-studio</a></li>\n<li>orai: <a href=\"https://github.com/oraichain/orai\" rel=\"nofollow\" target=\"_blank\">https://github.com/oraichain/orai</a></li>\n<li>oraiswap: <a href=\"https://github.com/oraichain/oraiswap\" rel=\"nofollow\" target=\"_blank\">https://github.com/oraichain/oraiswap</a></li>\n<li>oraiwasm: <a href=\"https://github.com/oraichain/oraiwasm\" rel=\"nofollow\" target=\"_blank\">https://github.com/oraichain/oraiwasm</a></li>\n<li>cosmosjs: <a href=\"https://github.com/oraichain/cosmosjs\" rel=\"nofollow\" target=\"_blank\">https://github.com/oraichain/cosmosjs</a></li>\n</ul>\n<p>위 차트를 보면 owallet이 가장 활동적인 프로젝트임을 알 수 있습니다. 이 지갑은 Cosmos 및 EVM 통합을 지원합니다. 두 번째로 활발한 저장소는 Oraichain DEX의 일부인 oraiswap-frontend입니다. 가장 활발한 3번째 저장소는 Oraichain을 위한 블록 익스플로러인 oraiscan-frontend입니다.</p>\n<h2>싱귤래리티넷</h2>\n<p>싱귤래리티넷은 목록에서 가장 많은 저장소(116개)를 보유한 프로젝트입니다. 그러나 더 나은 시각화를 위해 상위 10개 저장소만 살펴보고 각각에 대해 약간 깊이 파고들어보겠습니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>아래는 커밋 수에 따라 순서가 매겨진 상위 10개 저장소 목록과 해당 GitHub 저장소가 있습니다:</p>\n<ul>\n<li>snet-marketplace-service: <a href=\"https://github.com/singnet/snet-marketplace-service\" rel=\"nofollow\" target=\"_blank\">https://github.com/singnet/snet-marketplace-service</a></li>\n<li>snet-dapp: <a href=\"https://github.com/singnet/snet-dapp\" rel=\"nofollow\" target=\"_blank\">https://github.com/singnet/snet-dapp</a></li>\n<li>snet-daemon: <a href=\"https://github.com/singnet/snet-daemon\" rel=\"nofollow\" target=\"_blank\">https://github.com/singnet/snet-daemon</a></li>\n<li>dev-portal: <a href=\"https://github.com/singnet/dev-portal\" rel=\"nofollow\" target=\"_blank\">https://github.com/singnet/dev-portal</a></li>\n<li>snet-cli: <a href=\"https://github.com/singnet/snet-cli\" rel=\"nofollow\" target=\"_blank\">https://github.com/singnet/snet-cli</a></li>\n<li>airdrop-services: <a href=\"https://github.com/singnet/airdrop-services\" rel=\"nofollow\" target=\"_blank\">https://github.com/singnet/airdrop-services</a></li>\n<li>snet-betav1-dapp: <a href=\"https://github.com/singnet/snet-betav1-dapp\" rel=\"nofollow\" target=\"_blank\">https://github.com/singnet/snet-betav1-dapp</a></li>\n<li>offernet: <a href=\"https://github.com/singnet/offernet\" rel=\"nofollow\" target=\"_blank\">https://github.com/singnet/offernet</a></li>\n<li>ai-dsl: <a href=\"https://github.com/singnet/ai-dsl\" rel=\"nofollow\" target=\"_blank\">https://github.com/singnet/ai-dsl</a></li>\n<li>airdrop-dapp: <a href=\"https://github.com/singnet/airdrop-dapp\" rel=\"nofollow\" target=\"_blank\">https://github.com/singnet/airdrop-dapp</a></li>\n</ul>\n<p>가장 많은 커밋을 가진 저장소는 snet-marketplace-service입니다. 이 저장소는 SingularityNET의 시장을 사용하는 방법을 가르쳐 줍니다. 프로젝트의 탈중앙화 애플리케이션(snet-dapp)을 구축하는 데 사용된 저장소가 두 번째로 활동적입니다. 세 번째로 커밋 수가 많은 저장소는 SingularityNET 데몬이고, 그 다음은 플랫폼 및 시장에 대한 많은 문서를 제공하는 dev-portal입니다. 또한 두 개의 에어드랍에 전념한 저장소도 있습니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h1>결론</h1>\n<p>이 문서는 여러 프로젝트 내 개발자 활동에 대한 포괄적인 견해를 제공합니다. 프로젝트 성장과 개발자 참여의 지표로서 커밋 및 저장소 사용의 중요성을 강조하며, 주요 사건이 개발 활동에 미치는 영향을 보여주고, 연도별 활동을 기반으로 저장소를 순위로 나열합니다.</p>\n<p>우리는 좋은 데이터 처리 방법론과 몇 개의 바 차트를 통해 각 프로젝트의 활동에 대해 풍부한 정보를 얻을 수 있었습니다. 요약하자면, Python과 데이터 분석에 대한 충분한 지식을 가지고 있으면 스테이크홀더, 투자자 및 경쟁업체가 GitHub 개발 활동에 기반한 정보에 근거하여 판단을 내릴 수 있습니다.</p>\n<p>전체 보고서는 <a href=\"%EB%A7%81%ED%81%AC\">이 링크</a>에서 찾아볼 수 있습니다.</p>\n</body>\n</html>\n"},"__N_SSG":true}