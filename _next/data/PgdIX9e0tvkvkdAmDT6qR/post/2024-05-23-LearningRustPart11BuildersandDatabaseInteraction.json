{"pageProps":{"post":{"title":"러스트 배우기 11부  빌더와 데이터베이스 상호작용","description":"","date":"2024-05-23 14:11","slug":"2024-05-23-LearningRustPart11BuildersandDatabaseInteraction","content":"\n다음 시리즈로 넘어가보겠습니다; 이 부분에서는 데이터 구조에 빌더 패턴을 구현하는 방법을 살펴보겠습니다. 그런 다음 sqlx와 Postgres를 사용한 데이터베이스 상호작용으로 넘어가겠습니다.\n\n![이미지](/assets/img/2024-05-23-LearningRustPart11BuildersandDatabaseInteraction_0.png)\n\n# Rust 시리즈\n\n부분 1 — 기본 개념\n\n<div class=\"content-ad\"></div>\n\nPart 2 — 메모리\n\nPart 3 — 흐름 제어와 함수\n\nPart 4 — 옵션/결과 및 컬렉션\n\nPart 5 — 트레이트, 제네릭 및 클로저\n\n<div class=\"content-ad\"></div>\n\n제 6부 — 매크로, 반복자 및 파일 처리\n\n제 7부 — 스레드 공유 상태 및 채널\n\n제 8부 — Cargo, 크레이트, 모듈 및 라이브러리\n\n제 9부 — 명령행 인수, 워크스페이스 및 테스팅\n\n<div class=\"content-ad\"></div>\n\n제 10부 — 상자 포인터 및 웹 앱\n\n제 11부 — 빌더와 데이터베이스 상호작용 (이 기사)\n\n# 소개\n\n이것은 러스트 학습 시리즈의 열한 번째 섹션입니다. 이번에는 러스트에서 빌더 패턴을 다룰 것입니다. 이 공통된 패턴은 구조체를 안전하고 투명하게 초기화하는 좋은 방법입니다. 다음으로, 우리는 포스트그레스와 SQLX 프레임워크를 사용하여 데이터베이스에서 CRUD 작업을 수행하는 방법을 살펴볼 것입니다.\n\n<div class=\"content-ad\"></div>\n\n# 준비물\n\n이 글의 데이터베이스 부분을 위한 유일한 준비물은 Rust와 Cargo가 설치되어 있고 시스템에 Docker가 설치되어 있는 것입니다. 만약 Docker를 가지고 있지 않지만 로컬 Postgres DB가 이미 설치되어 있거나 다른 서버의 DB에 액세스할 수 있다면 Docker Postgres 설정을 건너뛰고 DB에 연결하기 위한 연결 속성만 수정하면 됩니다.\n\n# 빌더 패턴\n\n빌더 패턴은 복잡한 객체의 구성을 해당 표현에서 분리하는 디자인 패턴입니다. 이 패턴을 사용하면 유효성 검사를 수행하고 기본값으로 대체하며 값을 부분적으로 할당한 후에 항목을 생성할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\nRust로 그 구현하는 방법을 살펴볼 거예요. 이것이 우리의 코드입니다.\n\n```js\n#[derive(Debug)]\nstruct ChargingSession {\n    id: String,\n    watts: u32,\n    vin: String,\n}\n\nstruct ChargingSessionBuilder {\n    id: String,\n    watts: Option<u32>,\n    vin: Option<String>,\n}\n\nimpl ChargingSessionBuilder {\n    fn new(id: &str) -> ChargingSessionBuilder {\n        ChargingSessionBuilder {\n            id: id.to_string(),\n            watts: None,\n            vin: None,\n        }\n    }\n\n    fn watts(mut self, watts: u32) -> ChargingSessionBuilder {\n        self.watts = Some(watts);\n        self\n    }\n\n    fn vin(mut self, vin: &str) -> ChargingSessionBuilder {\n        self.vin = Some(vin.to_string());\n        self\n    }\n\n    fn build(self) -> ChargingSession {\n        ChargingSession {\n            id: self.id,\n            watts: self.watts.unwrap_or_else(|| 0),\n            vin: self.vin.unwrap_or_else(|| \"Unknown\".to_string()),\n        }\n    }\n}\n\nfn main() {\n    // 이것은 ChargingSession을 생성하는 표준적인 방법입니다.\n    let cs_old_way = ChargingSession {\n        id: String::from(\"11111\"),\n        watts: 420,\n        vin: String::from(\"4Y1SL65848Z411439\"),\n    };\n    println!(\"Regular way to create struct: {:?}\", cs_old_way);\n\n    // 빌더를 사용해서 생성하는 방법입니다.\n    let cs = ChargingSessionBuilder::new(\"11111\")\n        .watts(420)\n        .vin(\"4Y1SL65848Z411439\")\n        .build();\n    println!(\"Builder pattern to create struct: {:?}\", cs);\n\n    // ID만 제공하여 생성하는 예시입니다.\n    let cs_lean = ChargingSessionBuilder::new(\"11111\")\n    .build();\n     println!(\"Builder pattern to create struct (default values): {:?}\", cs_lean);\n}\n```\n\n이걸 한 번에 이해하기에 많지만, 단계적으로 진행해 봅시다.\n\n먼저, 충전 세션 정보를 저장하는 구조체를 정의했습니다. 이 시리즈의 이전 예제에서 하나의 필드인 세션용 차량 ID 번호인 vin을 추가했어요.\n\n<div class=\"content-ad\"></div>\n\n그러면 데이터 구조체와 동일한 필드를 가진 빌더를 위한 구조체를 정의합니다.\n\n빌더는 impl 블록에서 구현되며, id 및 각 추가 필드를 설정하는 함수를 정의하는 새 함수가 있습니다. 그러나 몇 가지 중요한 사항이 있습니다.\n\n- 각 함수는 ChargingSessionBuilder 유형을 반환합니다. 기본적으로 self입니다.\n- 추가 속성 필드에는 mut self를 첫 번째 매개변수로 사용하는 메서드가 있습니다. 이는 이러한 함수 호출의 체이닝을 허용하는 데 중요합니다. 또한 여기에 유효성 검사 논리를 코딩할 수 있습니다.\n- build 함수가 모두 통합되는 곳입니다. 존재하는 값들을 할당하고 나면 기본값을 결정하고 대상 구조체를 생성할 수 있습니다.\n\n이를 통해 빌더 패턴의 우아함과 Rust 내에서의 구현 방법을 살펴보았습니다. 이것이 앱이나 라이브러리에 코드를 구현하는 훌륭한 방법임을 알 수 있기를 바랍니다.\n\n<div class=\"content-ad\"></div>\n\n다음 섹션인 데이터베이스로 넘어가 봅시다.\n\n# 데이터베이스 — sqlx\n\n이 섹션에서는 Rust 프로그램에서 sqlx를 사용하여 데이터베이스 작업을 살펴볼 것입니다. 먼저 일부 설정이 필요합니다.\n\n## 설정\n\n<div class=\"content-ad\"></div>\n\n새 프로젝트를 시작해봅시다. db_app이라고 이름 짓고, cargo new db_app으로 생성할 수 있어요. 기본 디렉토리에 몇 개의 파일을 생성할 거에요. 첫 번째 파일은 docker-compose.yml이라고 하며 다음 내용이 있어야 합니다. Postgres와 Pgadmin이 노출되는 임의의 포트를 선택했으며, 컴퓨터에 설치된 다른 앱들과 충돌하지 않도록 했어요.\n\n```js\nversion: '3'\nservices:\n  postgres:\n    image: postgres:latest\n    container_name: postgres\n    ports:\n      - '6500:5432'\n    volumes:\n      - postgresDB:/data/postgres\n    env_file:\n      - ./.env\n  pgAdmin:\n    image: dpage/pgadmin4\n    container_name: pgAdmin\n    env_file:\n      - ./.env\n    ports:\n      - \"5050:80\"\nvolumes:\n  postgresDB:\n```\n\n.env이라는 파일이 하나 더 필요하며, 다음 내용이 있어야 해요. 이 파일은 docker-compose 파일과 나중에 Rust 애플리케이션에서 모두 사용할 거에요.\n\n```js\nPOSTGRES_HOST=127.0.0.1\nPOSTGRES_PORT=6500\nPOSTGRES_USER=admin\nPOSTGRES_PASSWORD=password123\nPOSTGRES_DB=charging_session\n\nDATABASE_URL=postgresql://admin:password123@localhost:6500/charging_session?currentSchema=public\n\nPGADMIN_DEFAULT_EMAIL=admin@admin.com\nPGADMIN_DEFAULT_PASSWORD=password123\n```\n\n<div class=\"content-ad\"></div>\n\n위의 내용과 함께 데이터베이스 사용자, 비밀번호, 그리고 Pgadmin에 대한 연결 정보를 제공해 드렸습니다.\n\n이 두 가지 항목을 만들고 위의 내용을 사용하여 Docker Compose를 사용하여 로컬 DB 인스턴스를 시작할 수 있습니다. 처음에는 항상 전경에서 시작하는 것을 좋아합니다. 이미지 다운로드 및 기타 작업을 하기 때문에 여러분의 컴퓨터 및 네트워크 속도에 따라 시간이 소요될 수 있습니다. docker-compose.yml 및 .env 파일이 있는 디렉토리와 동일한 위치에서 다음을 실행하십시오.\n\n```js\ndocker-compose up\n```\n\n시작된 모든 것을 확인한 후에는 언제든지 -d 스위치를 사용하여 데몬 모드로 시작할 수 있습니다. 완료되면 두 컨테이너가 시작되었는지 확인해 봅시다. 다음과 같이 명령을 실행합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\ndocker ps\n```\n\n비슷한 결과가 표시됩니다.\n\n<img src=\"/assets/img/2024-05-23-LearningRustPart11BuildersandDatabaseInteraction_1.png\" />\n\n만약 두 개의 컨테이너가 표시되지 않는다면, docker-compose를 실행한 터미널에서 에러를 확인해보세요.\n\n<div class=\"content-ad\"></div>\n\n한 번 이들이 실행되면 DB에 연결해 봅시다. Pgadmin을 포트 5050에서 실행하도록 구성했으니 브라우저에서 http://localhost:5050을 입력하면 pgadmin의 로그인 화면이 표시됩니다. .env 파일에 구성된 자격 증명(관리자@관리자.com/비밀번호123)을 사용하여 pgadmin에 로그인할 수 있습니다. 그런데 아직 데이터베이스에 연결되지 않았습니다. 이를 위해 다음을 실행해야 합니다.\n\n```js\ndocker inspect postgres\n```\n\n출력을 확인하여 \"NetworkSettings\" 섹션으로 이동하고 \"IPAddress\" 속성의 값을 복사합니다. 이 값은 DB에 연결하는 데 사용할 호스트(IP)입니다. 제 컴퓨터에서 이 값은 172.23.0.1 이었습니다.\n\n로그인한 후 \"새 서버 추가\" 버튼을 클릭하고, \"호스트 이름/주소\"로 이전에 복사한 IP 주소를 포함한 필수 자격 증명을 제공하고 \"저장\" 버튼을 클릭하세요.\n\n<div class=\"content-ad\"></div>\n\n서버에 로그인하면 데이터베이스 charging_session을 볼 수 있습니다.\n\n![이미지](/assets/img/2024-05-23-LearningRustPart11BuildersandDatabaseInteraction_2.png)\n\n잘 했어요. 데이터베이스를 사용할 준비가 되었고 Pgadmin에서 관리할 수 있습니다.\n\n이제 Rust 앱의 종속성을 구성해 봅시다. 처음에는 모두 필요하지 않지만 결국 필요하게 될 것이므로 지금 추가해 두는 것이 좋습니다.\n\n<div class=\"content-ad\"></div>\n\nCargo.toml 파일의 종속성 부분을 다음과 같이 수정하세요.\n\n```toml\n[dependencies]\nchrono = { version = \"0.4.31\", features = [\"serde\"] }\ndotenv = \"0.15.0\"\nenv_logger = \"0.10.1\"\nlog = \"0.4.20\"\nserde = { version = \"1.0.193\", features = [\"derive\"] }\nserde_json = \"1.0.108\"\nsqlx = { version = \"0.7.3\", features = [\"runtime-tokio-native-tls\", \"postgres\", \"uuid\", \"chrono\"] }\ntokio = { version = \"1.35.0\", features = [\"macros\", \"rt-multi-thread\"]}\nuuid = { version = \"1.6.1\", features = [\"serde\", \"v4\"] }\n```\n\n다양한 종속성에 대해 활성화된 기능을 검토하는 데도 시간을 할애하는 것이 좋습니다.\n\n다음으로, 필요한 테이블을 만들기 위해 sqlx-cli 마이그레이션 기능을 사용할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n우선 명령 줄에서 다음을 실행하여 CLI를 설치해야 합니다.\n\n```js\ncargo install sqlx-cli --no-default-features --features rustls,postgres\n```\n\n그런 다음 마이그레이션 파일을 초기화해야 합니다. 다음과 같이 실행합니다.\n\n```js\nsqlx migrate add initial-tables\n```\n\n<div class=\"content-ad\"></div>\n\n이 명령어는 우리가 마이그레이션 스크립트를 작성하기 위해 새 파일 migrations/`timestamp`\\_initial-tables.sql을 생성합니다.\n\n![이미지](/assets/img/2024-05-23-LearningRustPart11BuildersandDatabaseInteraction_3.png)\n\n이 파일을 열고 아래 SQL 문을 추가하여 테이블을 생성하세요.\n\n\ncreate table locations (\n  id bigserial primary key,\n  name varchar(255) unique not null\n);\n\ncreate table sessions (\n  id bigserial primary key,\n  location_id bigint not null,\n  watts bigint not null,\n  vin varchar(255) not null,\n  constraint fk_location foreign key (location_id) references locations(id) on delete cascade\n);\n\n\n<div class=\"content-ad\"></div>\n\n위 예제에서 사용할 두 개의 테이블 정의입니다. 이 시리즈의 충전 세션에 대한 표준 예제를 확장하여, 충전 장치의 위치를 저장할 locations 테이블을 추가했습니다.\n\n이제 다음을 실행하여 테이블을 생성하세요.\n\n```js\nsqlx migrate run\n```\n\n그러면 즉시 20231212235431/migrate initial-tables (타임스탬프 부분은 달라질 수 있음)과 같은 메시지가 표시됩니다. 이제 Pgadmin에 가서 테이블을 확인할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-05-23-LearningRustPart11BuildersandDatabaseInteraction_4.png\" />\n\n위에서 보듯이 두 개의 테이블이 생성되었고, 문서 목적을 위해 Pgadmin 내에 ERD 다이어그램도 생성했습니다. 이제 초기 설정과 프로젝트 구성을 완료했습니다.\n\n# 데이터베이스 함수\n\n이 섹션에서는 데이터베이스 상호 작용의 다양한 유형과 Rust 구현을 살펴볼 것입니다. 이는 데이터베이스에 연결하는 것으로 시작됩니다.\n\n<div class=\"content-ad\"></div>\n\nDB에 연결하기\n\n데이터베이스에 연결하는 방법은 PgPoolOptions connect 함수를 통해 연결을 생성하는 것입니다. 우리의 .env 파일에서 데이터베이스 연결 문자열을 읽고 로깅을 구성하며 성공 또는 오류를 기록하는 코드 전체는 아래와 같습니다.\n\n```js\nuse sqlx::{postgres::PgPoolOptions, Pool, Postgres};\nuse dotenv::dotenv;\nuse log::{info, error};\n\n#[tokio::main]\nasync fn main() {\n    if std::env::var_os(\"RUST_LOG\").is_none() {\n        std::env::set_var(\"RUST_LOG\", \"info\");\n    }\n    dotenv().ok();\n    env_logger::init();\n\n    let database_url = std::env::var(\"DATABASE_URL\").expect(\"DATABASE_URL must be set\");\n    let pool = match PgPoolOptions::new()\n        .max_connections(10)\n        .connect(&database_url)\n        .await\n    {\n        Ok(pool) => {\n            info!(\"✅ 데이터베이스에 연결되었습니다!\");\n            pool\n        }\n        Err(err) => {\n            error!(\"🔥 데이터베이스 연결에 실패했습니다: {:?}\", err);\n            std::process::exit(1);\n        }\n    };\n}\n```\n\n시작 부분의 #[tokio::main] 매크로를 주목해주세요. 이는 async fn main()을 동기 fn main()로 변환하여 런타임 인스턴스를 초기화하고 async main 함수를 실행하게 합니다.\n\n<div class=\"content-ad\"></div>\n\n위 코드를 실행하면 출력 로깅에서 다음 메시지가 표시됩니다.\n\n[2023-12-13T00:16:42Z INFO db_app] ✅ 데이터베이스에 연결되었습니다!\n\n우리는 데이터베이스에 연결할 수 있습니다. .env 파일에서 구성한 모든 연결 정보를 기억해 주세요. 이 정보는 docker-compose, sqlx-cli, 그리고 우리의 어플리케이션에서 공유되었습니다.\n\n## Inserts\n\n<div class=\"content-ad\"></div>\n\n이제 연결 풀이 준비되었으니, 우리가 살펴볼 첫 번째 데이터베이스 로직은 삽입입니다. sqlx를 사용하여 삽입하는 방법은 다음과 같습니다.\n\n```rust\nlet insert_result = sqlx::query_as!(\n    Locations,\n    \"INSERT INTO locations (id,name) VALUES (1, 'Location A') RETURNING *\"\n)\n.fetch_one(&pool)\n.await;\n\nmatch insert_result {\n    Ok(location) => {\n        info!(\"✓Inserted: {:?}\", location);\n    }\n    Err(e) => {\n        error!(\"Error Insert: {}\", e.to_string())\n    }\n}\n```\n\n이 코드는 하나의 레코드를 삽입할 것입니다. 물론 매개변수를 사용할 수도 있으며, 이는 업데이트를 살펴볼 때 살펴볼 것입니다.\n\n## 질의하기\n\n<div class=\"content-ad\"></div>\n\n다음으로, 데이터베이스를 조회하는 방법을 살펴보겠습니다.\n\n```js\n    let query_result = sqlx::query_as!(Locations, \"SELECT * FROM Locations\")\n        .fetch_all(&pool)\n        .await;\n    if query_result.is_err() {\n        let message = \"모든 위치를 가져오는 동안 문제가 발생했습니다.\";\n        error!(\"{}{}\", message, query_result.err().unwrap());\n    } else {\n        info!(\"😎 위치에 대한 쿼리 결과 {:?}\", query_result.unwrap());\n    }\n```\n\n이것은 성공적으로 작동했다면 unwrap을 통해 결과에 접근할 수 있는 결과를 반환합니다. 쿼리 내의 이슈가 발생했다면 해당 에러에 접근할 수도 있습니다.\n\n## 업데이트\n\n<div class=\"content-ad\"></div>\n\n다음 작업은 데이터베이스를 업데이트하는 것입니다. 이는 이전에 삽입한 것과 비슷할 것입니다.\n\n```js\n    let update_result = sqlx::query_as!(\n        Sessions,\n        \"UPDATE sessions SET watts = 415 WHERE id = $1 RETURNING *\",\n        1i64,\n    )\n    .fetch_one(&pool)\n    .await;\n\n    match update_result {\n        Ok(session) => {\n            info!(\"✓Update: {:?}\", session);\n        }\n        Err(e) => {\n            error!(\"Error Update: {}\", e.to_string())\n        }\n    }\n```\n\n이 예제에서 주목할 점은 $1이라는 매개변수 자리 표시자를 사용하는 준비된 문(statement)를 사용하고 있다는 것입니다. 그런 다음 SQL 문자열 뒤에 매개변수를 전달합니다.\n\n## Deletes\n\n<div class=\"content-ad\"></div>\n\n마지막으로, 데이터베이스에서 레코드를 삭제하는 CRUD 작업을 완료합니다. 우리의 목적은 데이터베이스를 정리하는 데 사용할 것이며, 이렇게 하면 언제든지 응용 프로그램을 실행할 수 있습니다.\n\n```js\nlet rows_deleted = sqlx::query!(\"DELETE from sessions\")\n    .execute(&pool)\n    .await\n    .unwrap()\n    .rows_affected();\n\ninfo!(\"✕ 세션 테이블에서 {}개의 행 삭제됨\", rows_deleted);\n```\n\n여기서는 연산에서처럼 sqlx::query 대신 sqlx::query_as를 사용합니다. 또한 언랩 이후 .rows_affected를 추가하여 삭제된 행 수를 얻습니다.\n\n## 트랜잭션\n\n<div class=\"content-ad\"></div>\n\n```rust\n   let tx = pool.begin().await.expect(\"트랜잭션을 시작할 수 없습니다\");\n\n   // 데이터베이스 작업 수행(데이터 삽입 또는 변경)\n\n   tx.commit().await.expect(\"트랜잭션을 커밋할 수 없습니다\");\n```\n\n커밋을 호출하지 않으면 트랜잭션이 범위를 벗어나면 자동으로 롤백됩니다.\n\n## 완전한 응용 프로그램\n\n<div class=\"content-ad\"></div>\n\n위의 코드는 우리가 이전에 논의한 모든 다양한 기능이 하나의 애플리케이션에 모두 포함된 완전한 애플리케이션입니다.\n\n```js\nuse dotenv::dotenv;\nuse log::{error, info};\nuse sqlx::{postgres::PgPoolOptions, Pool, Postgres};\n\n#[derive(Debug)]\nstruct Locations {\n    id: i64,\n    name: String,\n}\n\n#[derive(Debug)]\nstruct Sessions {\n    id: i64,\n    location_id: i64,\n    watts: i64,\n    vin: String,\n}\nasync fn insert_into_locations(pool: Pool<Postgres>) {\n    let tx = pool.begin().await.expect(\"Unable to begin transaction\");\n\n    let insert_result = sqlx::query_as!(\n        Locations,\n        \"INSERT INTO locations (id,name) VALUES (1, 'Location A') RETURNING *\"\n    )\n    .fetch_one(&pool)\n    .await;\n\n    match insert_result {\n        Ok(location) => {\n            info!(\"✓Inserted: {:?}\", location);\n        }\n        Err(e) => {\n            error!(\"Error Insert: {}\", e.to_string())\n        }\n    }\n    let insert_result = sqlx::query_as!(\n        Locations,\n        \"INSERT INTO locations (id,name) VALUES (2, 'Location B') RETURNING *\"\n    )\n    .fetch_one(&pool)\n    .await;\n\n    match insert_result {\n        Ok(location) => {\n            info!(\"✓Inserted: {:?}\", location);\n        }\n        Err(e) => {\n            error!(\"Error Insert: {}\", e.to_string())\n        }\n    }\n\n    tx.commit().await.expect(\"Unable to commit the transaction\");\n}\n\nasync fn insert_into_sessions(pool: Pool<Postgres>) {\n    let tx = pool.begin().await.expect(\"Unable to begin transaction\");\n\n    let insert_result = sqlx::query_as!(\n        Sessions,\n        \"INSERT INTO sessions (id,location_id, watts, vin) VALUES (1, 1, 420, '2FMZA52286BA02033') RETURNING *\"\n    )\n    .fetch_one(&pool)\n    .await;\n\n    match insert_result {\n        Ok(session) => {\n            info!(\"✓Inserted: {:?}\", session);\n        }\n        Err(e) => {\n            error!(\"Error Insert: {}\", e.to_string())\n        }\n    }\n    let insert_result = sqlx::query_as!(\n        Sessions,\n        \"INSERT INTO sessions (id,location_id, watts, vin) VALUES (2, 2, 393, '1GMYA52286BA04055') RETURNING *\"\n)\n    .fetch_one(&pool)\n    .await;\n\n    match insert_result {\n        Ok(session) => {\n            info!(\"✓Inserted: {:?}\", session);\n        }\n        Err(e) => {\n            error!(\"Error Insert: {}\", e.to_string())\n        }\n    }\n\n    tx.commit().await.expect(\"Unable to commit the transaction\");\n}\n\nasync fn update_sessions(pool: Pool<Postgres>) {\n    let tx = pool.begin().await.expect(\"Unable to begin transaction\");\n\n    let update_result = sqlx::query_as!(\n        Sessions,\n        \"UPDATE sessions SET watts = 415 WHERE id = $1 RETURNING *\",\n        1i64,\n    )\n    .fetch_one(&pool)\n    .await;\n\n    match update_result {\n        Ok(session) => {\n            info!(\"✓Update: {:?}\", session);\n        }\n        Err(e) => {\n            error!(\"Error Update: {}\", e.to_string())\n        }\n    }\n\n    tx.commit().await.expect(\"Unable to commit the transaction\");\n}\n\nasync fn clean_db(pool: Pool<Postgres>) {\n    let rows_deleted = sqlx::query!(\"DELETE from sessions\")\n        .execute(&pool)\n        .await\n        .unwrap()\n        .rows_affected();\n\n    info!(\"✕Deleted {} rows from sessions table\", rows_deleted);\n\n    let rows_deleted = sqlx::query!(\"DELETE from locations\")\n        .execute(&pool)\n        .await\n        .unwrap()\n        .rows_affected();\n    info!(\"✕Deleted {} rows from locations table\", rows_deleted);\n}\n\nasync fn query_locations(pool: Pool<Postgres>) {\n    let query_result = sqlx::query_as!(Locations, \"SELECT * FROM Locations\")\n        .fetch_all(&pool)\n        .await;\n    if query_result.is_err() {\n        let message = \"Something bad happened while fetching all locations\";\n        error!(\"{}\", message);\n    } else {\n        info!(\"😎Query Result For Locations {:?}\", query_result);\n    }\n}\n\nasync fn query_sessions(pool: Pool<Postgres>) {\n    let query_result = sqlx::query_as!(Sessions, \"SELECT * FROM Sessions\")\n        .fetch_all(&pool)\n        .await;\n    if query_result.is_err() {\n        let message = \"Something bad happened while fetching all sessions\";\n        error!(\"{}\", message);\n    } else {\n        info!(\"😎Query Result for Sessions {:?}\", query_result);\n    }\n}\n\n#[tokio::main]\nasync fn main() {\n    if std::env::var_os(\"RUST_LOG\").is_none() {\n        std::env::set_var(\"RUST_LOG\", \"info\");\n    }\n    dotenv().ok();\n    env_logger::init();\n\n    let database_url = std::env::var(\"DATABASE_URL\").expect(\"DATABASE_URL must be set\");\n    let pool = match PgPoolOptions::new()\n        .max_connections(10)\n        .connect(&database_url)\n        .await\n    {\n        Ok(pool) => {\n            info!(\"✅Connection to the database is successful!\");\n            pool\n        }\n        Err(err) => {\n            error!(\"🔥 Failed to connect to the database: {:?}\", err);\n            std::process::exit(1);\n        }\n    };\n    clean_db(pool.clone()).await;\n\n    insert_into_locations(pool.clone()).await;\n    query_locations(pool.clone()).await;\n\n    insert_into_sessions(pool.clone()).await;\n    query_sessions(pool.clone()).await;\n\n    update_sessions(pool.clone()).await;\n    query_sessions(pool.clone()).await;\n}\n```\n\n위 애플리케이션을 실행한 결과는 다음과 같습니다.\n\n<img src=\"/assets/img/2024-05-23-LearningRustPart11BuildersandDatabaseInteraction_5.png\" />\n\n<div class=\"content-ad\"></div>\n\n위와 같이 데이터베이스 상호작용 토론을 마쳤습니다. sqlx를 사용하여 데이터베이스 작업을 수행하는 방법에 대해 좋은 개요를 제공했을 겁니다.\n\n# 요약\n\n저희 러스트 학습 시리즈의 이 부분을 즐기셨기를 바랍니다. 시리즈 이번 섹션에서는 먼저 러스트에서 객체 생성에 대한 매우 유용한 패턴인 빌더 패턴을 살펴보았습니다. 이는 다른 언어에서 익숙할 수 있지만, 러스트에서 어떻게 구현하는지 살펴보았습니다.\n\n다음으로, 우리는 Rust를 사용하여 데이터베이스인 특히 Postgres와 상호작용하는 방법을 검토했습니다. 우리는 마이그레이션을 실행하고 데이터베이스에 연결하는 방법을 보았으며, 그 후 DB에 대해 여러 가지 CRUD 작업을 수행하는 방법을 살펴보았습니다.\n\n<div class=\"content-ad\"></div>\n\n러스트 학습 여정에 함께해줘서 고마워요.\n\n좋은 여행 되세요!\n","ogImage":{"url":"/assets/img/2024-05-23-LearningRustPart11BuildersandDatabaseInteraction_0.png"},"coverImage":"/assets/img/2024-05-23-LearningRustPart11BuildersandDatabaseInteraction_0.png","tag":["Tech"],"readingTime":18},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    img: \"img\",\n    h1: \"h1\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\",\n    ul: \"ul\",\n    li: \"li\",\n    h2: \"h2\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"다음 시리즈로 넘어가보겠습니다; 이 부분에서는 데이터 구조에 빌더 패턴을 구현하는 방법을 살펴보겠습니다. 그런 다음 sqlx와 Postgres를 사용한 데이터베이스 상호작용으로 넘어가겠습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-23-LearningRustPart11BuildersandDatabaseInteraction_0.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"Rust 시리즈\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"부분 1 — 기본 개념\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Part 2 — 메모리\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Part 3 — 흐름 제어와 함수\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Part 4 — 옵션/결과 및 컬렉션\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Part 5 — 트레이트, 제네릭 및 클로저\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"제 6부 — 매크로, 반복자 및 파일 처리\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"제 7부 — 스레드 공유 상태 및 채널\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"제 8부 — Cargo, 크레이트, 모듈 및 라이브러리\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"제 9부 — 명령행 인수, 워크스페이스 및 테스팅\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"제 10부 — 상자 포인터 및 웹 앱\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"제 11부 — 빌더와 데이터베이스 상호작용 (이 기사)\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"소개\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이것은 러스트 학습 시리즈의 열한 번째 섹션입니다. 이번에는 러스트에서 빌더 패턴을 다룰 것입니다. 이 공통된 패턴은 구조체를 안전하고 투명하게 초기화하는 좋은 방법입니다. 다음으로, 우리는 포스트그레스와 SQLX 프레임워크를 사용하여 데이터베이스에서 CRUD 작업을 수행하는 방법을 살펴볼 것입니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"준비물\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 글의 데이터베이스 부분을 위한 유일한 준비물은 Rust와 Cargo가 설치되어 있고 시스템에 Docker가 설치되어 있는 것입니다. 만약 Docker를 가지고 있지 않지만 로컬 Postgres DB가 이미 설치되어 있거나 다른 서버의 DB에 액세스할 수 있다면 Docker Postgres 설정을 건너뛰고 DB에 연결하기 위한 연결 속성만 수정하면 됩니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"빌더 패턴\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"빌더 패턴은 복잡한 객체의 구성을 해당 표현에서 분리하는 디자인 패턴입니다. 이 패턴을 사용하면 유효성 검사를 수행하고 기본값으로 대체하며 값을 부분적으로 할당한 후에 항목을 생성할 수 있습니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Rust로 그 구현하는 방법을 살펴볼 거예요. 이것이 우리의 코드입니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"#[\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"derive\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Debug\"\n        }), \")]\\nstruct \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ChargingSession\"\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"id\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"String\"\n        }), \",\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"watts\"\n        }), \": u32,\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"vin\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"String\"\n        }), \",\\n}\\n\\nstruct \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ChargingSessionBuilder\"\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"id\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"String\"\n        }), \",\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"watts\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Option\"\n        }), \"<u32>,\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"vin\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Option\"\n        }), \"<\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"String\"\n        }), \">,\\n}\\n\\nimpl \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ChargingSessionBuilder\"\n        }), \" {\\n    fn \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"new\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"id\"\n        }), \": &str) -> \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ChargingSessionBuilder\"\n        }), \" {\\n        \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ChargingSessionBuilder\"\n        }), \" {\\n            \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"id\"\n        }), \": id.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"to_string\"\n        }), \"(),\\n            \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"watts\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"None\"\n        }), \",\\n            \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"vin\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"None\"\n        }), \",\\n        }\\n    }\\n\\n    fn \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"watts\"\n        }), \"(mut self, \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"watts\"\n        }), \": u32) -> \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ChargingSessionBuilder\"\n        }), \" {\\n        self.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"watts\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Some\"\n        }), \"(watts);\\n        self\\n    }\\n\\n    fn \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"vin\"\n        }), \"(mut self, \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"vin\"\n        }), \": &str) -> \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ChargingSessionBuilder\"\n        }), \" {\\n        self.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"vin\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Some\"\n        }), \"(vin.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"to_string\"\n        }), \"());\\n        self\\n    }\\n\\n    fn \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"build\"\n        }), \"(self) -> \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ChargingSession\"\n        }), \" {\\n        \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ChargingSession\"\n        }), \" {\\n            \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"id\"\n        }), \": self.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"id\"\n        }), \",\\n            \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"watts\"\n        }), \": self.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"watts\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"unwrap_or_else\"\n        }), \"(|| \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"),\\n            \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"vin\"\n        }), \": self.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"vin\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"unwrap_or_else\"\n        }), \"(|| \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Unknown\\\"\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"to_string\"\n        }), \"()),\\n        }\\n    }\\n}\\n\\nfn \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"main\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\"\n        }), \") {\\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 이것은 ChargingSession을 생성하는 표준적인 방법입니다.\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" cs_old_way = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ChargingSession\"\n        }), \" {\\n        \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"id\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"String\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"from\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"11111\\\"\"\n        }), \"),\\n        \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"watts\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"420\"\n        }), \",\\n        \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"vin\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"String\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"from\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"4Y1SL65848Z411439\\\"\"\n        }), \"),\\n    };\\n    println!(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Regular way to create struct: {:?}\\\"\"\n        }), \", cs_old_way);\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 빌더를 사용해서 생성하는 방법입니다.\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" cs = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ChargingSessionBuilder\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"new\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"11111\\\"\"\n        }), \")\\n        .\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"watts\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"420\"\n        }), \")\\n        .\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"vin\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"4Y1SL65848Z411439\\\"\"\n        }), \")\\n        .\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"build\"\n        }), \"();\\n    println!(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Builder pattern to create struct: {:?}\\\"\"\n        }), \", cs);\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// ID만 제공하여 생성하는 예시입니다.\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" cs_lean = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ChargingSessionBuilder\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"new\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"11111\\\"\"\n        }), \")\\n    .\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"build\"\n        }), \"();\\n     println!(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Builder pattern to create struct (default values): {:?}\\\"\"\n        }), \", cs_lean);\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이걸 한 번에 이해하기에 많지만, 단계적으로 진행해 봅시다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"먼저, 충전 세션 정보를 저장하는 구조체를 정의했습니다. 이 시리즈의 이전 예제에서 하나의 필드인 세션용 차량 ID 번호인 vin을 추가했어요.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그러면 데이터 구조체와 동일한 필드를 가진 빌더를 위한 구조체를 정의합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"빌더는 impl 블록에서 구현되며, id 및 각 추가 필드를 설정하는 함수를 정의하는 새 함수가 있습니다. 그러나 몇 가지 중요한 사항이 있습니다.\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"각 함수는 ChargingSessionBuilder 유형을 반환합니다. 기본적으로 self입니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"추가 속성 필드에는 mut self를 첫 번째 매개변수로 사용하는 메서드가 있습니다. 이는 이러한 함수 호출의 체이닝을 허용하는 데 중요합니다. 또한 여기에 유효성 검사 논리를 코딩할 수 있습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"build 함수가 모두 통합되는 곳입니다. 존재하는 값들을 할당하고 나면 기본값을 결정하고 대상 구조체를 생성할 수 있습니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이를 통해 빌더 패턴의 우아함과 Rust 내에서의 구현 방법을 살펴보았습니다. 이것이 앱이나 라이브러리에 코드를 구현하는 훌륭한 방법임을 알 수 있기를 바랍니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다음 섹션인 데이터베이스로 넘어가 봅시다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"데이터베이스 — sqlx\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 섹션에서는 Rust 프로그램에서 sqlx를 사용하여 데이터베이스 작업을 살펴볼 것입니다. 먼저 일부 설정이 필요합니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"설정\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"새 프로젝트를 시작해봅시다. db_app이라고 이름 짓고, cargo new db_app으로 생성할 수 있어요. 기본 디렉토리에 몇 개의 파일을 생성할 거에요. 첫 번째 파일은 docker-compose.yml이라고 하며 다음 내용이 있어야 합니다. Postgres와 Pgadmin이 노출되는 임의의 포트를 선택했으며, 컴퓨터에 설치된 다른 앱들과 충돌하지 않도록 했어요.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"version\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'3'\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"services\"\n        }), \":\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"postgres\"\n        }), \":\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"image\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"postgres\"\n        }), \":latest\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"container_name\"\n        }), \": postgres\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"ports\"\n        }), \":\\n      - \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'6500:5432'\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"volumes\"\n        }), \":\\n      - \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"postgresDB\"\n        }), \":\", _jsx(_components.span, {\n          className: \"hljs-regexp\",\n          children: \"/data/\"\n        }), \"postgres\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"env_file\"\n        }), \":\\n      - ./.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"env\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"pgAdmin\"\n        }), \":\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"image\"\n        }), \": dpage/pgadmin4\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"container_name\"\n        }), \": pgAdmin\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"env_file\"\n        }), \":\\n      - ./.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"env\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"ports\"\n        }), \":\\n      - \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"5050:80\\\"\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"volumes\"\n        }), \":\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"postgresDB\"\n        }), \":\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \".env이라는 파일이 하나 더 필요하며, 다음 내용이 있어야 해요. 이 파일은 docker-compose 파일과 나중에 Rust 애플리케이션에서 모두 사용할 거에요.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"POSTGRES_HOST\"\n        }), \"=\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"127.0\"\n        }), _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \".0\"\n        }), _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \".1\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"POSTGRES_PORT\"\n        }), \"=\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"6500\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"POSTGRES_USER\"\n        }), \"=admin\\n\", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"POSTGRES_PASSWORD\"\n        }), \"=password123\\n\", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"POSTGRES_DB\"\n        }), \"=charging_session\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"DATABASE_URL\"\n        }), \"=\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"postgresql\"\n        }), \":\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"//admin:password123@localhost:6500/charging_session?currentSchema=public\"\n        }), \"\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"PGADMIN_DEFAULT_EMAIL\"\n        }), \"=admin@admin.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"com\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"PGADMIN_DEFAULT_PASSWORD\"\n        }), \"=password123\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"위의 내용과 함께 데이터베이스 사용자, 비밀번호, 그리고 Pgadmin에 대한 연결 정보를 제공해 드렸습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 두 가지 항목을 만들고 위의 내용을 사용하여 Docker Compose를 사용하여 로컬 DB 인스턴스를 시작할 수 있습니다. 처음에는 항상 전경에서 시작하는 것을 좋아합니다. 이미지 다운로드 및 기타 작업을 하기 때문에 여러분의 컴퓨터 및 네트워크 속도에 따라 시간이 소요될 수 있습니다. docker-compose.yml 및 .env 파일이 있는 디렉토리와 동일한 위치에서 다음을 실행하십시오.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-js\",\n        children: \"docker-compose up\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"시작된 모든 것을 확인한 후에는 언제든지 -d 스위치를 사용하여 데몬 모드로 시작할 수 있습니다. 완료되면 두 컨테이너가 시작되었는지 확인해 봅시다. 다음과 같이 명령을 실행합니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-js\",\n        children: \"docker ps\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"비슷한 결과가 표시됩니다.\"\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/assets/img/2024-05-23-LearningRustPart11BuildersandDatabaseInteraction_1.png\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"만약 두 개의 컨테이너가 표시되지 않는다면, docker-compose를 실행한 터미널에서 에러를 확인해보세요.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"한 번 이들이 실행되면 DB에 연결해 봅시다. Pgadmin을 포트 5050에서 실행하도록 구성했으니 브라우저에서 http://localhost:5050을 입력하면 pgadmin의 로그인 화면이 표시됩니다. .env 파일에 구성된 자격 증명(관리자@관리자.com/비밀번호123)을 사용하여 pgadmin에 로그인할 수 있습니다. 그런데 아직 데이터베이스에 연결되지 않았습니다. 이를 위해 다음을 실행해야 합니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-js\",\n        children: \"docker inspect postgres\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"출력을 확인하여 \\\"NetworkSettings\\\" 섹션으로 이동하고 \\\"IPAddress\\\" 속성의 값을 복사합니다. 이 값은 DB에 연결하는 데 사용할 호스트(IP)입니다. 제 컴퓨터에서 이 값은 172.23.0.1 이었습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"로그인한 후 \\\"새 서버 추가\\\" 버튼을 클릭하고, \\\"호스트 이름/주소\\\"로 이전에 복사한 IP 주소를 포함한 필수 자격 증명을 제공하고 \\\"저장\\\" 버튼을 클릭하세요.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"서버에 로그인하면 데이터베이스 charging_session을 볼 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-23-LearningRustPart11BuildersandDatabaseInteraction_2.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"잘 했어요. 데이터베이스를 사용할 준비가 되었고 Pgadmin에서 관리할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 Rust 앱의 종속성을 구성해 봅시다. 처음에는 모두 필요하지 않지만 결국 필요하게 될 것이므로 지금 추가해 두는 것이 좋습니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Cargo.toml 파일의 종속성 부분을 다음과 같이 수정하세요.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-toml\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-section\",\n          children: \"[dependencies]\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"chrono\"\n        }), \" = { version = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"0.4.31\\\"\"\n        }), \", features = [\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"serde\\\"\"\n        }), \"] }\\n\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"dotenv\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"0.15.0\\\"\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"env_logger\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"0.10.1\\\"\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"log\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"0.4.20\\\"\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"serde\"\n        }), \" = { version = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"1.0.193\\\"\"\n        }), \", features = [\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"derive\\\"\"\n        }), \"] }\\n\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"serde_json\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"1.0.108\\\"\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"sqlx\"\n        }), \" = { version = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"0.7.3\\\"\"\n        }), \", features = [\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"runtime-tokio-native-tls\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"postgres\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"uuid\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"chrono\\\"\"\n        }), \"] }\\n\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"tokio\"\n        }), \" = { version = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"1.35.0\\\"\"\n        }), \", features = [\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"macros\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"rt-multi-thread\\\"\"\n        }), \"]}\\n\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"uuid\"\n        }), \" = { version = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"1.6.1\\\"\"\n        }), \", features = [\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"serde\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"v4\\\"\"\n        }), \"] }\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다양한 종속성에 대해 활성화된 기능을 검토하는 데도 시간을 할애하는 것이 좋습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다음으로, 필요한 테이블을 만들기 위해 sqlx-cli 마이그레이션 기능을 사용할 것입니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우선 명령 줄에서 다음을 실행하여 CLI를 설치해야 합니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"cargo install sqlx-cli --no-\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"default\"\n        }), \"-features --features rustls,postgres\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그런 다음 마이그레이션 파일을 초기화해야 합니다. 다음과 같이 실행합니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-js\",\n        children: \"sqlx migrate add initial-tables\\n\"\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"이 명령어는 우리가 마이그레이션 스크립트를 작성하기 위해 새 파일 migrations/\", _jsx(_components.code, {\n        children: \"timestamp\"\n      }), \"_initial-tables.sql을 생성합니다.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-23-LearningRustPart11BuildersandDatabaseInteraction_3.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 파일을 열고 아래 SQL 문을 추가하여 테이블을 생성하세요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"create table locations (\\nid bigserial primary key,\\nname varchar(255) unique not null\\n);\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"create table sessions (\\nid bigserial primary key,\\nlocation_id bigint not null,\\nwatts bigint not null,\\nvin varchar(255) not null,\\nconstraint fk_location foreign key (location_id) references locations(id) on delete cascade\\n);\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"위 예제에서 사용할 두 개의 테이블 정의입니다. 이 시리즈의 충전 세션에 대한 표준 예제를 확장하여, 충전 장치의 위치를 저장할 locations 테이블을 추가했습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 다음을 실행하여 테이블을 생성하세요.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-js\",\n        children: \"sqlx migrate run\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그러면 즉시 20231212235431/migrate initial-tables (타임스탬프 부분은 달라질 수 있음)과 같은 메시지가 표시됩니다. 이제 Pgadmin에 가서 테이블을 확인할 수 있습니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/assets/img/2024-05-23-LearningRustPart11BuildersandDatabaseInteraction_4.png\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"위에서 보듯이 두 개의 테이블이 생성되었고, 문서 목적을 위해 Pgadmin 내에 ERD 다이어그램도 생성했습니다. 이제 초기 설정과 프로젝트 구성을 완료했습니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"데이터베이스 함수\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 섹션에서는 데이터베이스 상호 작용의 다양한 유형과 Rust 구현을 살펴볼 것입니다. 이는 데이터베이스에 연결하는 것으로 시작됩니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"DB에 연결하기\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"데이터베이스에 연결하는 방법은 PgPoolOptions connect 함수를 통해 연결을 생성하는 것입니다. 우리의 .env 파일에서 데이터베이스 연결 문자열을 읽고 로깅을 구성하며 성공 또는 오류를 기록하는 코드 전체는 아래와 같습니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"use \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"sqlx\"\n        }), \"::{\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"postgres\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"PgPoolOptions\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Pool\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Postgres\"\n        }), \"};\\nuse \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"dotenv\"\n        }), \"::dotenv;\\nuse \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"log\"\n        }), \"::{info, error};\\n\\n#[\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"tokio\"\n        }), \"::main]\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"async\"\n        }), \" fn \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"main\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\"\n        }), \") {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"std\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"env\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"var_os\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"RUST_LOG\\\"\"\n        }), \").\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"is_none\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\"\n        }), \") {\\n        \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"std\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"env\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"set_var\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"RUST_LOG\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"info\\\"\"\n        }), \");\\n    }\\n    \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"dotenv\"\n        }), \"().\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"ok\"\n        }), \"();\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"env_logger\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"init\"\n        }), \"();\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" database_url = \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"std\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"env\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"var\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"DATABASE_URL\\\"\"\n        }), \").\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"expect\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"DATABASE_URL must be set\\\"\"\n        }), \");\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" pool = match \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"PgPoolOptions\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"new\"\n        }), \"()\\n        .\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"max_connections\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"10\"\n        }), \")\\n        .\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"connect\"\n        }), \"(&database_url)\\n        .\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"await\"\n        }), \"\\n    {\\n        \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Ok\"\n        }), \"(pool) => {\\n            info!(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"✅ 데이터베이스에 연결되었습니다!\\\"\"\n        }), \");\\n            pool\\n        }\\n        \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Err\"\n        }), \"(err) => {\\n            error!(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"🔥 데이터베이스 연결에 실패했습니다: {:?}\\\"\"\n        }), \", err);\\n            \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"std\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"process\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"exit\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \");\\n        }\\n    };\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"시작 부분의 #[tokio::main] 매크로를 주목해주세요. 이는 async fn main()을 동기 fn main()로 변환하여 런타임 인스턴스를 초기화하고 async main 함수를 실행하게 합니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"위 코드를 실행하면 출력 로깅에서 다음 메시지가 표시됩니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"[2023-12-13T00:16:42Z INFO db_app] ✅ 데이터베이스에 연결되었습니다!\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우리는 데이터베이스에 연결할 수 있습니다. .env 파일에서 구성한 모든 연결 정보를 기억해 주세요. 이 정보는 docker-compose, sqlx-cli, 그리고 우리의 어플리케이션에서 공유되었습니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Inserts\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 연결 풀이 준비되었으니, 우리가 살펴볼 첫 번째 데이터베이스 로직은 삽입입니다. sqlx를 사용하여 삽입하는 방법은 다음과 같습니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-rust\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"insert_result\"\n        }), \" = sqlx::query_as!(\\n    Locations,\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"INSERT INTO locations (id,name) VALUES (1, 'Location A') RETURNING *\\\"\"\n        }), \"\\n)\\n.\", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"fetch_one\"\n        }), \"(&pool)\\n.\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"await\"\n        }), \";\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"match\"\n        }), \" insert_result {\\n    \", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"Ok\"\n        }), \"(location) => {\\n        info!(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"✓Inserted: {:?}\\\"\"\n        }), \", location);\\n    }\\n    \", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"Err\"\n        }), \"(e) => {\\n        error!(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Error Insert: {}\\\"\"\n        }), \", e.\", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"to_string\"\n        }), \"())\\n    }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 코드는 하나의 레코드를 삽입할 것입니다. 물론 매개변수를 사용할 수도 있으며, 이는 업데이트를 살펴볼 때 살펴볼 것입니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"질의하기\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다음으로, 데이터베이스를 조회하는 방법을 살펴보겠습니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" query_result = \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"sqlx\"\n        }), \"::query_as!(\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Locations\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"SELECT * FROM Locations\\\"\"\n        }), \")\\n        .\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"fetch_all\"\n        }), \"(&pool)\\n        .\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"await\"\n        }), \";\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" query_result.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"is_err\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\"\n        }), \") {\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" message = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"모든 위치를 가져오는 동안 문제가 발생했습니다.\\\"\"\n        }), \";\\n        error!(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"{}{}\\\"\"\n        }), \", message, query_result.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"err\"\n        }), \"().\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"unwrap\"\n        }), \"());\\n    } \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"else\"\n        }), \" {\\n        info!(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"😎 위치에 대한 쿼리 결과 {:?}\\\"\"\n        }), \", query_result.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"unwrap\"\n        }), \"());\\n    }\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이것은 성공적으로 작동했다면 unwrap을 통해 결과에 접근할 수 있는 결과를 반환합니다. 쿼리 내의 이슈가 발생했다면 해당 에러에 접근할 수도 있습니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"업데이트\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다음 작업은 데이터베이스를 업데이트하는 것입니다. 이는 이전에 삽입한 것과 비슷할 것입니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" update_result = \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"sqlx\"\n        }), \"::query_as!(\\n        \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Sessions\"\n        }), \",\\n        \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"UPDATE sessions SET watts = 415 WHERE id = $1 RETURNING *\\\"\"\n        }), \",\\n        1i64,\\n    )\\n    .\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"fetch_one\"\n        }), \"(&pool)\\n    .\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"await\"\n        }), \";\\n\\n    match update_result {\\n        \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Ok\"\n        }), \"(session) => {\\n            info!(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"✓Update: {:?}\\\"\"\n        }), \", session);\\n        }\\n        \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Err\"\n        }), \"(e) => {\\n            error!(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Error Update: {}\\\"\"\n        }), \", e.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"to_string\"\n        }), \"())\\n        }\\n    }\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 예제에서 주목할 점은 $1이라는 매개변수 자리 표시자를 사용하는 준비된 문(statement)를 사용하고 있다는 것입니다. 그런 다음 SQL 문자열 뒤에 매개변수를 전달합니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Deletes\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"마지막으로, 데이터베이스에서 레코드를 삭제하는 CRUD 작업을 완료합니다. 우리의 목적은 데이터베이스를 정리하는 데 사용할 것이며, 이렇게 하면 언제든지 응용 프로그램을 실행할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" rows_deleted = \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"sqlx\"\n        }), \"::query!(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"DELETE from sessions\\\"\"\n        }), \")\\n    .\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"execute\"\n        }), \"(&pool)\\n    .\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"await\"\n        }), \"\\n    .\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"unwrap\"\n        }), \"()\\n    .\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"rows_affected\"\n        }), \"();\\n\\ninfo!(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"✕ 세션 테이블에서 {}개의 행 삭제됨\\\"\"\n        }), \", rows_deleted);\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"여기서는 연산에서처럼 sqlx::query 대신 sqlx::query_as를 사용합니다. 또한 언랩 이후 .rows_affected를 추가하여 삭제된 행 수를 얻습니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"트랜잭션\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-rust\",\n        children: [\"   \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"tx\"\n        }), \" = pool.\", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"begin\"\n        }), \"().\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"await\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"expect\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"트랜잭션을 시작할 수 없습니다\\\"\"\n        }), \");\\n\\n   \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 데이터베이스 작업 수행(데이터 삽입 또는 변경)\"\n        }), \"\\n\\n   tx.\", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"commit\"\n        }), \"().\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"await\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"expect\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"트랜잭션을 커밋할 수 없습니다\\\"\"\n        }), \");\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"커밋을 호출하지 않으면 트랜잭션이 범위를 벗어나면 자동으로 롤백됩니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"완전한 응용 프로그램\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"위의 코드는 우리가 이전에 논의한 모든 다양한 기능이 하나의 애플리케이션에 모두 포함된 완전한 애플리케이션입니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"use \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"dotenv\"\n        }), \"::dotenv;\\nuse \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"log\"\n        }), \"::{error, info};\\nuse \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"sqlx\"\n        }), \"::{\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"postgres\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"PgPoolOptions\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Pool\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Postgres\"\n        }), \"};\\n\\n#[\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"derive\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Debug\"\n        }), \")]\\nstruct \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Locations\"\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"id\"\n        }), \": i64,\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"name\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"String\"\n        }), \",\\n}\\n\\n#[\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"derive\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Debug\"\n        }), \")]\\nstruct \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Sessions\"\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"id\"\n        }), \": i64,\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"location_id\"\n        }), \": i64,\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"watts\"\n        }), \": i64,\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"vin\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"String\"\n        }), \",\\n}\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"async\"\n        }), \" fn \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"insert_into_locations\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"pool: Pool<Postgres>\"\n        }), \") {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" tx = pool.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"begin\"\n        }), \"().\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"await\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"expect\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Unable to begin transaction\\\"\"\n        }), \");\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" insert_result = \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"sqlx\"\n        }), \"::query_as!(\\n        \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Locations\"\n        }), \",\\n        \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"INSERT INTO locations (id,name) VALUES (1, 'Location A') RETURNING *\\\"\"\n        }), \"\\n    )\\n    .\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"fetch_one\"\n        }), \"(&pool)\\n    .\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"await\"\n        }), \";\\n\\n    match insert_result {\\n        \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Ok\"\n        }), \"(location) => {\\n            info!(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"✓Inserted: {:?}\\\"\"\n        }), \", location);\\n        }\\n        \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Err\"\n        }), \"(e) => {\\n            error!(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Error Insert: {}\\\"\"\n        }), \", e.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"to_string\"\n        }), \"())\\n        }\\n    }\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" insert_result = \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"sqlx\"\n        }), \"::query_as!(\\n        \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Locations\"\n        }), \",\\n        \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"INSERT INTO locations (id,name) VALUES (2, 'Location B') RETURNING *\\\"\"\n        }), \"\\n    )\\n    .\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"fetch_one\"\n        }), \"(&pool)\\n    .\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"await\"\n        }), \";\\n\\n    match insert_result {\\n        \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Ok\"\n        }), \"(location) => {\\n            info!(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"✓Inserted: {:?}\\\"\"\n        }), \", location);\\n        }\\n        \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Err\"\n        }), \"(e) => {\\n            error!(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Error Insert: {}\\\"\"\n        }), \", e.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"to_string\"\n        }), \"())\\n        }\\n    }\\n\\n    tx.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"commit\"\n        }), \"().\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"await\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"expect\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Unable to commit the transaction\\\"\"\n        }), \");\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"async\"\n        }), \" fn \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"insert_into_sessions\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"pool: Pool<Postgres>\"\n        }), \") {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" tx = pool.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"begin\"\n        }), \"().\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"await\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"expect\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Unable to begin transaction\\\"\"\n        }), \");\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" insert_result = \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"sqlx\"\n        }), \"::query_as!(\\n        \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Sessions\"\n        }), \",\\n        \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"INSERT INTO sessions (id,location_id, watts, vin) VALUES (1, 1, 420, '2FMZA52286BA02033') RETURNING *\\\"\"\n        }), \"\\n    )\\n    .\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"fetch_one\"\n        }), \"(&pool)\\n    .\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"await\"\n        }), \";\\n\\n    match insert_result {\\n        \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Ok\"\n        }), \"(session) => {\\n            info!(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"✓Inserted: {:?}\\\"\"\n        }), \", session);\\n        }\\n        \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Err\"\n        }), \"(e) => {\\n            error!(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Error Insert: {}\\\"\"\n        }), \", e.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"to_string\"\n        }), \"())\\n        }\\n    }\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" insert_result = \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"sqlx\"\n        }), \"::query_as!(\\n        \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Sessions\"\n        }), \",\\n        \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"INSERT INTO sessions (id,location_id, watts, vin) VALUES (2, 2, 393, '1GMYA52286BA04055') RETURNING *\\\"\"\n        }), \"\\n)\\n    .\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"fetch_one\"\n        }), \"(&pool)\\n    .\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"await\"\n        }), \";\\n\\n    match insert_result {\\n        \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Ok\"\n        }), \"(session) => {\\n            info!(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"✓Inserted: {:?}\\\"\"\n        }), \", session);\\n        }\\n        \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Err\"\n        }), \"(e) => {\\n            error!(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Error Insert: {}\\\"\"\n        }), \", e.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"to_string\"\n        }), \"())\\n        }\\n    }\\n\\n    tx.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"commit\"\n        }), \"().\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"await\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"expect\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Unable to commit the transaction\\\"\"\n        }), \");\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"async\"\n        }), \" fn \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"update_sessions\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"pool: Pool<Postgres>\"\n        }), \") {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" tx = pool.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"begin\"\n        }), \"().\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"await\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"expect\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Unable to begin transaction\\\"\"\n        }), \");\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" update_result = \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"sqlx\"\n        }), \"::query_as!(\\n        \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Sessions\"\n        }), \",\\n        \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"UPDATE sessions SET watts = 415 WHERE id = $1 RETURNING *\\\"\"\n        }), \",\\n        1i64,\\n    )\\n    .\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"fetch_one\"\n        }), \"(&pool)\\n    .\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"await\"\n        }), \";\\n\\n    match update_result {\\n        \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Ok\"\n        }), \"(session) => {\\n            info!(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"✓Update: {:?}\\\"\"\n        }), \", session);\\n        }\\n        \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Err\"\n        }), \"(e) => {\\n            error!(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Error Update: {}\\\"\"\n        }), \", e.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"to_string\"\n        }), \"())\\n        }\\n    }\\n\\n    tx.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"commit\"\n        }), \"().\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"await\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"expect\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Unable to commit the transaction\\\"\"\n        }), \");\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"async\"\n        }), \" fn \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"clean_db\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"pool: Pool<Postgres>\"\n        }), \") {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" rows_deleted = \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"sqlx\"\n        }), \"::query!(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"DELETE from sessions\\\"\"\n        }), \")\\n        .\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"execute\"\n        }), \"(&pool)\\n        .\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"await\"\n        }), \"\\n        .\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"unwrap\"\n        }), \"()\\n        .\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"rows_affected\"\n        }), \"();\\n\\n    info!(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"✕Deleted {} rows from sessions table\\\"\"\n        }), \", rows_deleted);\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" rows_deleted = \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"sqlx\"\n        }), \"::query!(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"DELETE from locations\\\"\"\n        }), \")\\n        .\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"execute\"\n        }), \"(&pool)\\n        .\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"await\"\n        }), \"\\n        .\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"unwrap\"\n        }), \"()\\n        .\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"rows_affected\"\n        }), \"();\\n    info!(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"✕Deleted {} rows from locations table\\\"\"\n        }), \", rows_deleted);\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"async\"\n        }), \" fn \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"query_locations\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"pool: Pool<Postgres>\"\n        }), \") {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" query_result = \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"sqlx\"\n        }), \"::query_as!(\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Locations\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"SELECT * FROM Locations\\\"\"\n        }), \")\\n        .\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"fetch_all\"\n        }), \"(&pool)\\n        .\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"await\"\n        }), \";\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" query_result.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"is_err\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\"\n        }), \") {\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" message = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Something bad happened while fetching all locations\\\"\"\n        }), \";\\n        error!(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"{}\\\"\"\n        }), \", message);\\n    } \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"else\"\n        }), \" {\\n        info!(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"😎Query Result For Locations {:?}\\\"\"\n        }), \", query_result);\\n    }\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"async\"\n        }), \" fn \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"query_sessions\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"pool: Pool<Postgres>\"\n        }), \") {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" query_result = \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"sqlx\"\n        }), \"::query_as!(\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Sessions\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"SELECT * FROM Sessions\\\"\"\n        }), \")\\n        .\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"fetch_all\"\n        }), \"(&pool)\\n        .\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"await\"\n        }), \";\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" query_result.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"is_err\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\"\n        }), \") {\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" message = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Something bad happened while fetching all sessions\\\"\"\n        }), \";\\n        error!(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"{}\\\"\"\n        }), \", message);\\n    } \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"else\"\n        }), \" {\\n        info!(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"😎Query Result for Sessions {:?}\\\"\"\n        }), \", query_result);\\n    }\\n}\\n\\n#[\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"tokio\"\n        }), \"::main]\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"async\"\n        }), \" fn \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"main\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\"\n        }), \") {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"std\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"env\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"var_os\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"RUST_LOG\\\"\"\n        }), \").\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"is_none\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\"\n        }), \") {\\n        \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"std\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"env\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"set_var\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"RUST_LOG\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"info\\\"\"\n        }), \");\\n    }\\n    \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"dotenv\"\n        }), \"().\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"ok\"\n        }), \"();\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"env_logger\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"init\"\n        }), \"();\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" database_url = \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"std\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"env\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"var\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"DATABASE_URL\\\"\"\n        }), \").\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"expect\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"DATABASE_URL must be set\\\"\"\n        }), \");\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" pool = match \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"PgPoolOptions\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"new\"\n        }), \"()\\n        .\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"max_connections\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"10\"\n        }), \")\\n        .\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"connect\"\n        }), \"(&database_url)\\n        .\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"await\"\n        }), \"\\n    {\\n        \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Ok\"\n        }), \"(pool) => {\\n            info!(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"✅Connection to the database is successful!\\\"\"\n        }), \");\\n            pool\\n        }\\n        \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Err\"\n        }), \"(err) => {\\n            error!(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"🔥 Failed to connect to the database: {:?}\\\"\"\n        }), \", err);\\n            \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"std\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"process\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"exit\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \");\\n        }\\n    };\\n    \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"clean_db\"\n        }), \"(pool.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"clone\"\n        }), \"()).\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"await\"\n        }), \";\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"insert_into_locations\"\n        }), \"(pool.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"clone\"\n        }), \"()).\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"await\"\n        }), \";\\n    \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"query_locations\"\n        }), \"(pool.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"clone\"\n        }), \"()).\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"await\"\n        }), \";\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"insert_into_sessions\"\n        }), \"(pool.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"clone\"\n        }), \"()).\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"await\"\n        }), \";\\n    \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"query_sessions\"\n        }), \"(pool.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"clone\"\n        }), \"()).\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"await\"\n        }), \";\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"update_sessions\"\n        }), \"(pool.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"clone\"\n        }), \"()).\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"await\"\n        }), \";\\n    \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"query_sessions\"\n        }), \"(pool.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"clone\"\n        }), \"()).\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"await\"\n        }), \";\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"위 애플리케이션을 실행한 결과는 다음과 같습니다.\"\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/assets/img/2024-05-23-LearningRustPart11BuildersandDatabaseInteraction_5.png\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"위와 같이 데이터베이스 상호작용 토론을 마쳤습니다. sqlx를 사용하여 데이터베이스 작업을 수행하는 방법에 대해 좋은 개요를 제공했을 겁니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"요약\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"저희 러스트 학습 시리즈의 이 부분을 즐기셨기를 바랍니다. 시리즈 이번 섹션에서는 먼저 러스트에서 객체 생성에 대한 매우 유용한 패턴인 빌더 패턴을 살펴보았습니다. 이는 다른 언어에서 익숙할 수 있지만, 러스트에서 어떻게 구현하는지 살펴보았습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다음으로, 우리는 Rust를 사용하여 데이터베이스인 특히 Postgres와 상호작용하는 방법을 검토했습니다. 우리는 마이그레이션을 실행하고 데이터베이스에 연결하는 방법을 보았으며, 그 후 DB에 대해 여러 가지 CRUD 작업을 수행하는 방법을 살펴보았습니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"러스트 학습 여정에 함께해줘서 고마워요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"좋은 여행 되세요!\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true}