{"pageProps":{"post":{"title":"Rust로 코딩하는 커맨드 라인 Connect 4 게임 배우기","description":"","date":"2024-05-20 16:00","slug":"2024-05-20-LearnRustbycodingacommandlineConnect4game","content":"\n\n![Rust Connect 4](/assets/img/2024-05-20-LearnRustbycodingacommandlineConnect4game_0.png)\n\n안녕하세요! 이번 글에서는 Rust가 어떻게 우리가 Connect 4의 간단한 버전을 만들며 명령줄 응용 프로그램을 작성하는 데 도움이 되는지 살펴볼 거에요.\n\n최근 Rust를 배우는 도전에 도전했고, 제 자신의 조언을 따르기 위해 개인 프로젝트에서 Rust를 사용해 손을 더럽히며 배운 것을 정리하려고 노력하고 있어요. Connect 4는 아주 좋은 도전 과제에요. 오후 하루 동안 코딩할 수 있는 것은 간단하지만 잘 하려면 약간의 생각이 필요한 복잡한 문제이죠.\n\n여기 제 마지막 결과물이 포함된 Rust 플레이그라운드가 있어요. 아래에서는 거기에 이르기까지 취한 정확한 단계를 살펴볼 거에요. 따라오고 싶으시면 Rust가 설치되어 있는지 확인한 후 터미널에서 `cargo new rust_connect_4_tutorial`을 실행해서 프로젝트를 열고 좋아하는 편집기에서 src/main.rs로 이동해서 시작해봐요!\n\n<div class=\"content-ad\"></div>\n\n혹은 비디오를 통해 학습하는 것을 선호한다면, 해당 튜토리얼의 비디오 버전을 확인해보세요:\n\n# 우리의 타입 정의하기\n\nRust에서 시작하는 가장 좋은 방법 중 하나는 종종 우리의 타입을 정의하는 것이므로, 우리는 정확히 그것을 할 것입니다!\n\n먼저, 게임에 사용할 보드를 정의해 보겠습니다. Connect 4의 클래식 버전은 7개의 슬롯이 가로로 있고 6개의 슬롯이 세로로 있기 때문에, 이들 정수를 상수로 저장하고, 그 상수를 사용하여 두 차원 배열의 길이를 정의하는 데 사용할 수 있습니다. Board 타입으로 정의합니다:\n\n<div class=\"content-ad\"></div>\n\n```rust\nconst BOARD_WIDTH: usize = 7;\nconst BOARD_HEIGHT: usize = 6;\n\ntype Board = [[u8; BOARD_WIDTH]; BOARD_HEIGHT];\n```\n\n플레이어를 추적할 방법이 필요할 것입니다. 이를 enum으로 구현할 수 있습니다. 우리는 두 명의 플레이어만 지원하지만, 한 명의 피스가 없는 슬롯을 나타내는 None 변형과 게임이 무승부로 끝날 때 처리하는 데 유용할 것입니다.\n\n```rust\n#[derive(Clone, Copy, Debug, PartialEq)]\n#[repr(u8)]\nenum Player {\n    One = 1,\n    Two = 2,\n    None = 0,\n}\n```\n\n위에서는 나중에 유용할 몇 가지 트레잇을 구현하기 위해 derive를 사용하고, enum의 메모리 레이아웃을 제어하기 위해 repr을 사용했습니다. 가능한 모든 값을 알기 때문에 u8로 제한할 수 있습니다.```\n\n<div class=\"content-ad\"></div>\n\n다음으로, 우리는 게임을 나타내는 struct를 만들 것입니다. 여기에는 추적해야 할 모든 상태가 포함될 것입니다.\n\n```javascript\nstruct Game {\n    current_move: u8,\n    current_player: Player,\n    board: Board,\n    is_finished: bool,\n    winner: Player,\n}\n```\n\ncurrent_move는 플레이어가 선택한 열을 나타내는 정수입니다. 우리에게는 승자 필드가 있지만, 게임이 비김으로 끝날 때 별도로 is_finished 부울도 유용할 것입니다!\n\n마지막으로, Game에 대한 기본 함수를 구현할 것입니다. 이 함수에는 초기 상태가 포함될 것입니다:\n\n<div class=\"content-ad\"></div>\n\n```rust\nimpl Game {\n    fn default() -> Game {\n        Game {\n            current_move: 0,\n            current_player: Player::One,\n            board: [\n                [0, 0, 0, 0, 0, 0, 0],\n                [0, 0, 0, 0, 0, 0, 0],\n                [0, 0, 0, 0, 0, 0, 0],\n                [0, 0, 0, 0, 0, 0, 0],\n                [0, 0, 0, 0, 0, 0, 0],\n                [0, 0, 0, 0, 0, 0, 0],\n            ],\n            is_finished: false,\n            winner: Player::None,\n        }\n    }\n}\n```\n\n보드에 대해 조금 이야기해 봅시다. 여기서 0은 빈 칸을 나타내며, 1은 Player One이 차지한 칸을 나타내고, 2는 Player Two가 차지한 칸을 나타냅니다.\n\nBOARD_WIDTH와 BOARD_HEIGHT를 사용하여 동적으로 생성할 수도 있었지만, 코드를 작성하는 동안 전체 배열을 보는 것이 도움이 되는 시각적 도구라는 것을 발견했습니다. 같은 이유로, 정수가 아닌 Player 열거형을 사용하지 않았습니다. 텍스트가 더 많아지면 코드를 한눈에 이해하기 어려워지기 때문입니다.\n\n이 방법의 (약간의) 단점은 나중에 정수를 Player로 변환해야 한다는 것입니다. 하지만 Player에 from_int 함수를 구현함으로써 쉽게 해결할 수 있습니다.```\n\n<div class=\"content-ad\"></div>\n\n```js\n구현 Player {\n    fn from_int(int: u8) -> Player {\n        match int {\n            1 => Player::One,\n            2 => Player::Two,\n            _ => Player::None,\n        }\n    }\n}\n```\n\n# 보드 표시\n\n디버깅을 위해, 보드를 시각화하는 좋은 방법을 빠르게 코드화하는 것이 도움이 될 것입니다. 명령줄에 출력하기 위해 크레이트를 사용하는 대신에 간단한 색을 나타내기 위해 16진수 이스케이프 문자열을 사용할 것입니다.\n\n```js\nconst RESET: &str = \"\\x1b[0m\";\nconst ORANGE: &str = \"\\x1b[93m\";\nconst RED: &str = \"\\x1b[0;31m\";\n```\n\n<div class=\"content-ad\"></div>\n\n아래의 코드에서는 맵을 사용하여 Connect 4 토큰과 유사한 이모지로 슬롯을 변환할 것입니다. 게임이 종료되면 우승자를 발표하는 좋은 장소로 보입니다.\n\n```js\nimpl Game {\n    // 다른 함수들\n\n    fn display_board(&self) {\n        println!(\"{}--------------------{}\", ORANGE, RESET);\n        println!(\"{}CONNECT 4 (Move {}){}\", ORANGE, self.current_move, RESET);\n        println!(\"{}--------------------{}\", ORANGE, RESET);\n\n        for row in self.board {\n            let row_str: String = row\n                .iter()\n                .map(|&cell| match cell {\n                    1 => \"🔴\",\n                    2 => \"🟡\",\n                    _ => \"⚫\",\n                })\n                .collect::<Vec<&str>>()\n                .join(\" \");\n\n            println!(\"{}\", row_str);\n        }\n\n        println!(\"{}--------------------{}\", ORANGE, RESET);\n\n        if self.is_finished {\n            match self.winner {\n                Player::One => println!(\"{}🔴 Player 1이 승리했습니다!{}\", ORANGE, RESET),\n                Player::Two => println!(\"{}🟡 Player 2가 승리했습니다!{}\", ORANGE, RESET),\n                Player::None => println!(\"{}무승부입니다!{}\", ORANGE, RESET),\n            }\n\n            println!(\"{}--------------------{}\", ORANGE, RESET);\n        }\n    }\n}\n```\n\n우리는 이것을 언제든지 메인 함수 내에서 호출하여 보드의 상태를 확인할 수 있습니다.\n\n```js\nfn main() {\n    let mut game = Game::default();\n    game.display_board();\n}\n```\n\n<div class=\"content-ad\"></div>\n\n조금 지루하지만 수를 두지 않고는 재미가 없죠. 그래서 이제 수를 두는 방법을 프로그래밍해 봅시다!\n\n# 수 두기\n\n우리의 play_move 함수를 첫 번째로 살펴보면, 이 함수는 이차원 배열에서 올바른 항목을 변경하고, 수를 증가시킨 다음 현재 플레이어를 변경해야 합니다.\n\n```rust\nimpl Game {\n    // other functions\n\n    fn play_move(&mut self, column: usize) {\n        if let Some(row) = (0..BOARD_HEIGHT)\n            .rev()\n            .find(|&row| self.board[row][column] == 0)\n        {\n            self.board[row][column] = self.current_player as u8;\n\n            self.current_move += 1;\n\n            self.current_player = match self.current_player {\n                Player::One => Player::Two,\n                _ => Player::One,\n            };\n        }\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n위의 if let 코드에서는 열의 맨 아래부터 시작하여 하나씩 올라가면서 빈 칸을 찾을 때까지 진행합니다. 빈 칸을 찾으면 그 위치에 현재 플레이어를 나타내는 정수로 변경하고, 현재 이동을 증가시킨 후 match 표현식을 사용하여 플레이어를 변경합니다.\n\n이 시점에서 코드를 통해 움직임을 실행하고 터미널에서 결과를 확인할 수 있습니다:\n\n```js\nfn main() {\n    let mut game = Game::default();\n    \n    game.play_move(3);\n    game.play_move(3);\n    game.play_move(4);\n    game.play_move(3);\n\n    game.display_board();\n}\n```\n\n# 오류 처리\n\n<div class=\"content-ad\"></div>\n\n지금까지 우리는 보드 바깥으로 이동을 시도하는 잠재적인 오류를 처리하지 않고 있습니다. 따라서 세 가지 가능한 오류를 처리해 봅시다:\n\n- 제공된 열이 허용 범위를 벗어납니다.\n- 제공된 열이 이미 가득 찼습니다.\n- 게임이 끝났습니다.\n\n(사용자 입력을 받기 시작하면 추가적인 오류 처리가 필요할 것입니다. 나중에 처리하겠습니다.)\n\n세 가지 오류 유형을 포함한 enum을 만들어 봅시다.\n\n<div class=\"content-ad\"></div>\n\n```js\nenum MoveError {\n    GameFinished,\n    InvalidColumn,\n    ColumnFull,\n}\n```\n\n우리는 에러를 명령줄에 출력하기를 원하기 때문에, 우리의 에러 메시지를 포함하는 사용자 정의 Display 트레이트를 구현해야 합니다. 예를 들어:\n\n```js\nimpl std::fmt::Display for MoveError {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        match self {\n            MoveError::ColumnFull => write!(f, \"column is full\"),\n            MoveError::InvalidColumn => write!(f, \"column must be between 1 and 7\"),\n            MoveError::GameFinished => write!(f, \"game is already finished\"),\n        }\n    }\n}\n```\n\n이제 이를 사용하여 play_move 함수를 수정할 수 있습니다. 이제 우리는 움직임이 성공적이면 아무것도 반환하지만, 그렇지 않은 경우 에러가 반환되는 Result enum을 반환합니다.\n\n\n<div class=\"content-ad\"></div>\n\n```rust\nimpl Game {\n    // 다른 함수들\n\n    fn play_move(&mut self, column: usize) -> Result<(), MoveError> {\n        if self.is_finished {\n            return Err(MoveError::GameFinished);\n        }\n\n        if column >= BOARD_WIDTH {\n            return Err(MoveError::InvalidColumn);\n        }\n\n        if let Some(row) = (0..BOARD_HEIGHT)\n            .rev()\n            .find(|&row| self.board[row][column] == 0)\n        {\n            self.board[row][column] = self.current_player as u8;\n        } else {\n            return Err(MoveError::ColumnFull);\n        }\n\n        self.current_move += 1;\n\n        self.current_player = match self.current_player {\n            Player::One => Player::Two,\n            _ => Player::One,\n        };\n\n        Ok(())\n    }\n}\n```\n\n디버깅을 위해 이제 play_move의 결과를 인쇄할 수 있으며, 예상치 못한 입력이 있는 경우 enum으로부터 에러를 볼 수 있습니다. \n\n우리가 여기에 있는 동안, 명령줄에 에러 메시지를 인쇄하는 도우미 함수를 추가해 봅시다.\n\n```rust\nimpl Game {\n    // 다른 함수들\n\n    fn display_error(&self, error: String) {\n        self.display_board();\n        println!(\"{}에러: {}{}\", RED, error, RESET);\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n# 게임에서 승리했는지 계산하기\n\n누군가가 이겼는지 확인하기 위해 2차원 배열을 여러 방향으로 탐색해야 합니다. 이 Leetcode 스타일 문제는 재미있는 도전이었고, 결과물을 얻기까지 몇 번 시도해야 했어요.\n\n누군가가 4칸을 연달아 얻을 수 있는 네 가지 방향이 있어요:\n\n- 수평,\n- 수직,\n- 역 슬래시 대각선 (왼쪽 위에서 오른쪽 아래로),\n- 순방향 슬래시 대각선 (왼쪽 아래에서 오른쪽 위로).\n\n<div class=\"content-ad\"></div>\n\n게시판의 모든 슬롯을 반복하여 네 방향 중 하나에서 테스트할 수 있습니다. (게시판이 작기 때문에 무차별 대입 방식을 사용하는 것이 부담이 되지 않습니다. 그러나 더 나은 방법이 있는지 궁금합니다!)\n\n게시판의 주어진 슬롯에서 시작합니다. 플레이어의 토큰이 들어있는 경우, 첫 번째 방향으로 한 단계 이동합니다. 이 새로운 슬롯도 같은 토큰을 포함하는 경우, 이 방향으로 또 다른 단계를 이동합니다. 이를 반복하여 같은 토큰이 있는 네 개의 슬롯을 찾을 때까지 진행합니다. 그렇지 않으면 다른 방향으로 이동합니다.\n\n각 방향은 정수들의 튜플로 나타낼 수 있습니다 - 행당 거리에 대한 값과 열당 거리에 대한 값 하나씩 - 이 정보를 배열에 저장할 수 있습니다.\n\n```js\nlet directions = [\n    (0, 1),  // 가로\n    (1, 0),  // 세로\n    (1, 1),  // 대각선 (왼쪽 위에서 오른쪽 아래)\n    (-1, 1), // 대각선 (왼쪽 아래에서 오른쪽 위)\n];\n```\n\n<div class=\"content-ad\"></div>\n\n이 튜플들이 무엇을 나타내는지 알려드릴게요:\n\n- 수평으로 이동하려면 행은 변하지 않고(0), 열만 변해야 합니다(1).\n- 수직으로 이동하려면 행이 변해야 하고(1), 열은 변하지 않아야 합니다(0).\n- 역 슬래시 대각선으로 이동하려면 행과 열이 둘 다 증가해야 합니다(1, 1).\n- 마지막으로, 슬래시 대각선으로 이동하려면 열은 증가하고 행은 감소해야 합니다(-1, 1).\n\n각 방향의 모든 슬롯을 테스트하려면 아래와 같이 세 개의 루프가 필요합니다.\n\n```rust\nimpl Game {\n    // 다른 함수들\n\n    fn calculate_winner(&mut self) -> Player {\n        for row in 0..BOARD_HEIGHT {\n            for col in 0..BOARD_WIDTH {\n                let cell = self.board[row][col];\n\n                if cell != 0 {\n                    let directions = [\n                        (0, 1),  // 수평\n                        (1, 0),  // 수직\n                        (1, 1),  // 대각선 (왼쪽 위에서 오른쪽 아래로)\n                        (-1, 1), // 대각선 (왼쪽 아래에서 오른쪽 위로)\n                    ];\n\n                    for (row_step, col_step) in directions {\n                        // TODO - 주어진 방향으로 보드를 탐색하고\n                        // 승자를 찾았다면 해당 플레이어를 반환하세요\n                    }\n                }\n            }\n        }\n        Player::None\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n우리는 연속 카운트를 유지하고 — 4에 도달하면 승자가 나온 것을 알 수 있습니다.\n\n그럼, 최종 중첩된 루프에서는 시작 토큰부터 슬롯별로 이동을 시도할 것입니다. 그때까지…\n\n- 시작 토큰과 다른 토큰을 만날 때 (그러한 경우 루프를 종료합니다);\n- 보드의 가장자리에 도달할 때 (그러한 경우 루프를 종료합니다);\n- 동일한 토큰의 4연속을 만날 때 (그러한 경우 게임을 종료하고 승자를 지정합니다).\n\n```js\nimpl Game {\n    // 다른 함수들\n\n    fn calculate_winner(&mut self) -> Player {\n        for row in 0..BOARD_HEIGHT {\n            for col in 0..BOARD_WIDTH {\n                let cell = self.board[row][col];\n\n                if cell != 0 {\n                    let directions = [\n                        (0, 1),  // 가로\n                        (1, 0),  // 세로\n                        (1, 1),  // 대각선 (왼쪽 위에서 오른쪽 아래로)\n                        (-1, 1), // 대각선 (왼쪽 아래에서 오른쪽 위로)\n                    ];\n\n                    for (row_step, col_step) in directions {\n                        let mut consecutive_count = 1;\n                        let mut r = row as isize + row_step;\n                        let mut c = col as isize + col_step;\n\n                        while r >= 0\n                            && r < BOARD_HEIGHT as isize\n                            && c >= 0\n                            && c < BOARD_WIDTH as isize\n                        {\n                            if self.board[r as usize][c as usize] == cell {\n                                consecutive_count += 1;\n\n                                if consecutive_count == 4 {\n                                    self.is_finished = true;\n                                    return Player::from_int(cell);\n                                }\n                            } else {\n                                break;\n                            }\n                            r += row_step;\n                            c += col_step;\n                        }\n                    }\n                }\n            }\n        }\n\n        Player::None\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n우리는 이동 횟수가 일곱 미만인 경우 이러한 확인 작업을 수행하지 않고 최적화를 조금 추가할 수 있습니다. 그때까지는 게임에서 이기는 것이 불가능하기 때문입니다. 그래서 함수 맨 위에 이를 추가해 봅시다:\n\n```js\nif self.current_move < 7 {\n    return Player::None;\n}\n```\n\n그리고 보드가 가득 찼지만 승자가 없는 경우(즉, 무승부인 경우)에 게임을 종료로 표시해야 합니다. 이를 반환문 위에 추가해 줍시다:\n\n```js\nif self.current_move >= BOARD_HEIGHT as u8 * BOARD_WIDTH as u8 {\n    self.is_finished = true;\n}\n```\n\n<div class=\"content-ad\"></div>\n\n마지막으로, 새로운 calculate_winner 함수를 play_move 함수에 추가할 수 있습니다. 이번에는 아무것도 반환하는 대신, 성공인 Result enum을 반환하거나 실패인 경우에는 오류를 반환합니다.\n\n```js\nimpl Game {\n    // 다른 함수들\n\n    fn play_move(&mut self, column: usize) -> Result<(), MoveError> {\n        if self.is_finished {\n            return Err(MoveError::GameFinished);\n        }\n\n        if column >= BOARD_WIDTH {\n            return Err(MoveError::InvalidColumn);\n        }\n\n        if let Some(row) = (0..BOARD_HEIGHT)\n            .rev()\n            .find(|&row| self.board[row][column] == 0)\n        {\n            self.board[row][column] = self.current_player as u8;\n            self.current_move += 1;\n        } else {\n            return Err(MoveError::ColumnFull);\n        }\n\n        let calculated_winner = self.calculate_winner();\n\n        if calculated_winner != Player::None {\n            self.winner = calculated_winner;\n        } else {\n            self.current_player = match self.current_player {\n                Player::One => Player::Two,\n                _ => Player::One,\n            };\n        }\n\n        Ok(())\n    }\n}\n```\n\n우리의 Connect 4 게임 엔진이 완성되었습니다! 사용자로부터 입력을 받는 방법만 남았습니다...\n\n# 사용자 입력 받기\n\n<div class=\"content-ad\"></div>\n\n우리 명령 줄 게임의 마지막 부분에서는 주 함수로 돌아가 사용자 입력을 읽을 수 있도록 할 것입니다.\n\n먼저, Rust의 표준 I/O 라이브러리를 가져오겠습니다.\n\n```js\nuse std::io;\n```\n\n사용자 입력을 읽는 논리는 다음과 같이 보일 수 있습니다. 여기서는 컴퓨터와 달리 0이 아닌 1부터 시작하여 카운트하게 됩니다!\n\n<div class=\"content-ad\"></div>\n\n```js\nlet mut user_move = String::new();\n\nio::stdin()\n    .read_line(&mut user_move)\n    .expect(\"Failed to read line\");\n\nlet user_move: usize = match user_move.trim().parse() {\n    Ok(num) => {\n        if num < 1 || num > BOARD_WIDTH as u8 {\n            game.display_error(MoveError::InvalidColumn.to_string());\n            continue;\n        } else {\n            num\n        }\n    }\n    Err(err) => {\n        game.display_error(err.to_string());\n        continue;\n    }\n};\n\nmatch game.play_move(user_move - 1) {\n    Ok(_) => {\n        game.display_board();\n    }\n    Err(err) => {\n        game.display_error(err.to_string());\n    }\n}\n```\n\n먼저, 우리는 빈 문자열을 정의한 뒤 사용자로부터 텍스트를 받기 위해 stdin 메소드를 사용합니다.\n\n다음으로 이 입력을 구문 분석을 시도합니다. 다음 중 하나라도 해당하는 경우 오류를 표시합니다:\n\n- 구문 분석이 실패하는 경우 (예: 입력이 숫자가 아닌 경우).\n- 구문 분석이 성공하지만 숫자가 원하는 범위를 벗어난 경우.```\n\n<div class=\"content-ad\"></div>\n\n만약 오류가 표시되지 않는다면, 우리는 선택한 수를 둘 것입니다. 그러나 해당 시나리오에서 오류가 발생할 수도 있으므로, 그런 경우에는 오류를 표시할 것입니다.\n\n그러나 위의 코드는 한 번만 실행됩니다. 게임이 끝날 때까지 루프를 실행해야 합니다. 아래는 그 반복문을 추가한 main 함수와 사용자를 도와줄 몇 가지 유용한 메시지입니다:\n\n```js\nfn main() {\n    let mut game = Game::default();\n    game.display_board();\n\n    while !game.is_finished {\n        println!(\"\\n\");\n\n        match game.current_player {\n            Player::One => println!(\"플레이어 1\"),\n            Player::Two => println!(\"플레이어 2\"),\n            _ => (),\n        };\n\n        println!(\"1부터 7 사이의 열을 입력하세요:\");\n\n        let mut user_move = String::new();\n        io::stdin()\n            .read_line(&mut user_move)\n            .expect(\"라인을 읽는 데 실패했습니다\");\n\n        let user_move: usize = match user_move.trim().parse() {\n            Ok(num) => {\n                if num < 1 || num > 7 {\n                    game.display_error(MoveError::InvalidColumn.to_string());\n                    continue;\n                } else {\n                    num\n                }\n            }\n            Err(err) => {\n                game.display_error(err.to_string());\n                continue;\n            }\n        };\n\n        match game.play_move(user_move - 1) {\n            Ok(_) => {\n                game.display_board();\n            }\n            Err(err) => {\n                game.display_error(err.to_string());\n            }\n        }\n    }\n}\n```\n\n# 여러 판을 플레이하기\n\n<div class=\"content-ad\"></div>\n\n마지막으로, 사용자가 게임을 끝내면 게임을 다시 시작할 수 있도록 추가 코드를 추가하고 싶어요. 매번 실행 파일을 다시 시작해야 하는 번거로움은 피하고 싶으니까요!\n\n이를 위해 새로운 루프를 만들 것입니다. 이전과 동일한 방법을 사용하여 사용자의 입력을 읽을 수 있습니다. \"R\"을 누르면 새 게임을 시작하고, \"Q\"를 누르면 루프를 중단하고 코드를 끝까지 실행합니다.\n\n```js\nfn main() {\n    let mut game = Game::default();\n    game.display_board();\n\n    loop {\n        while !game.is_finished {\n            // 코드 변경 없음\n        }\n\n        println!(\"Press 'R' to restart or 'Q' to quit the game.\");\n\n        let mut user_input = String::new();\n\n        io::stdin()\n            .read_line(&mut user_input)\n            .expect(\"Failed to read line\");\n\n        match user_input.trim() {\n            \"R\" | \"r\" => {\n                game = Game::default();\n                game.display_board();\n            }\n            \"Q\" | \"q\" => {\n                println!(\"Quitting...\");\n                break;\n            }\n            _ => game.display_error(\"잘못된 입력\".to_string()),\n        }\n    }\n}\n```\n\n마지막으로, 차례 사이에 터미널을 지우기 위한 ASCII 이스케이프 코드를 사용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nfn clear_screen(&self) {\n    print!(\"{}[2J\", 27 as char);\n}\n```\n\n게임 보드를 표시할 때마다 이 작업을 수행할 수 있습니다.\n\n```js\nfn display_board(&self) {\n    self.clear_screen();\n\n    // 코드 변경 없음\n}\n```\n\n# 모두 함께 가져오기\n\n<div class=\"content-ad\"></div>\n\n그것이 커넥트 4의 간단한 명령줄 게임을 위해 필요한 모든 것입니다! 이 작업 중인 파일을 사용하는 작동 버전을 시험하려면 Rust 플레이그라운드를 확인해보세요.\n\n우리가 지금까지 만든 전체 파일은 아래와 같습니다:\n\n```js\nuse std::io;\n\nconst RESET: &str = \"\\x1b[0m\";\nconst ORANGE: &str = \"\\x1b[93m\";\nconst RED: &str = \"\\x1b[0;31m\";\n\nconst BOARD_WIDTH: usize = 7;\nconst BOARD_HEIGHT: usize = 6;\n\ntype Board = [[u8; BOARD_WIDTH]; BOARD_HEIGHT];\n\n#[derive(Clone, Copy, Debug, PartialEq)]\n#[repr(u8)]\nenum Player {\n    One = 1,\n    Two = 2,\n    None = 0,\n}\n\nimpl Player {\n    fn from_int(int: u8) -> Player {\n        match int {\n            1 => Player::One,\n            2 => Player::Two,\n            _ => Player::None,\n        }\n    }\n}\n\n#[...]\n\n# 결론\n\n<div class=\"content-ad\"></div>\n\n지금까지 따라오셨다면 프로젝트를 더 나아가고 싶을 것입니다. 여러 게임을 거치면서 승리를 추적해 볼 수도 있고, 어떨까요? 어플리케이션을 웹 서버로 전환하여 웹사이트가 HTTP를 통해 Connect 4를 플레이할 수 있게끔 만들어 보는 것은 어떤가요?\n\n이번 명령줄 어플리케이션을 Rust로 개발하는 방법에 대한 유용하고 재미있는 통찰력으로 여기시길 바랍니다. 아직 Rust 여행을 시작한 지 얼마 되지 않았기 때문에, 어떠한 비평이나 더 많은 Rust 다운 방식으로 어플리케이션을 작성하는 아이디어가 있다면 꼭 알려주세요. 함께 고민해보고 싶습니다.","ogImage":{"url":"/assets/img/2024-05-20-LearnRustbycodingacommandlineConnect4game_0.png"},"coverImage":"/assets/img/2024-05-20-LearnRustbycodingacommandlineConnect4game_0.png","tag":["Tech"],"readingTime":18},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    img: \"img\",\n    code: \"code\",\n    h1: \"h1\",\n    pre: \"pre\",\n    span: \"span\",\n    ul: \"ul\",\n    li: \"li\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-20-LearnRustbycodingacommandlineConnect4game_0.png\",\n        alt: \"Rust Connect 4\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"안녕하세요! 이번 글에서는 Rust가 어떻게 우리가 Connect 4의 간단한 버전을 만들며 명령줄 응용 프로그램을 작성하는 데 도움이 되는지 살펴볼 거에요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"최근 Rust를 배우는 도전에 도전했고, 제 자신의 조언을 따르기 위해 개인 프로젝트에서 Rust를 사용해 손을 더럽히며 배운 것을 정리하려고 노력하고 있어요. Connect 4는 아주 좋은 도전 과제에요. 오후 하루 동안 코딩할 수 있는 것은 간단하지만 잘 하려면 약간의 생각이 필요한 복잡한 문제이죠.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"여기 제 마지막 결과물이 포함된 Rust 플레이그라운드가 있어요. 아래에서는 거기에 이르기까지 취한 정확한 단계를 살펴볼 거에요. 따라오고 싶으시면 Rust가 설치되어 있는지 확인한 후 터미널에서 \", _jsx(_components.code, {\n        children: \"cargo new rust_connect_4_tutorial\"\n      }), \"을 실행해서 프로젝트를 열고 좋아하는 편집기에서 src/main.rs로 이동해서 시작해봐요!\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"혹은 비디오를 통해 학습하는 것을 선호한다면, 해당 튜토리얼의 비디오 버전을 확인해보세요:\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"우리의 타입 정의하기\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Rust에서 시작하는 가장 좋은 방법 중 하나는 종종 우리의 타입을 정의하는 것이므로, 우리는 정확히 그것을 할 것입니다!\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"먼저, 게임에 사용할 보드를 정의해 보겠습니다. Connect 4의 클래식 버전은 7개의 슬롯이 가로로 있고 6개의 슬롯이 세로로 있기 때문에, 이들 정수를 상수로 저장하고, 그 상수를 사용하여 두 차원 배열의 길이를 정의하는 데 사용할 수 있습니다. Board 타입으로 정의합니다:\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-rust\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" BOARD_WIDTH: \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"usize\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"7\"\n        }), \";\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" BOARD_HEIGHT: \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"usize\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"6\"\n        }), \";\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"type\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Board\"\n        }), \" = [[\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"u8\"\n        }), \"; BOARD_WIDTH]; BOARD_HEIGHT];\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"플레이어를 추적할 방법이 필요할 것입니다. 이를 enum으로 구현할 수 있습니다. 우리는 두 명의 플레이어만 지원하지만, 한 명의 피스가 없는 슬롯을 나타내는 None 변형과 게임이 무승부로 끝날 때 처리하는 데 유용할 것입니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-rust\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-meta\",\n          children: \"#[derive(Clone, Copy, Debug, PartialEq)]\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-meta\",\n          children: \"#[repr(u8)]\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"enum\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Player\"\n        }), \" {\\n    One = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \",\\n    Two = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"2\"\n        }), \",\\n    \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"None\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \",\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"위에서는 나중에 유용할 몇 가지 트레잇을 구현하기 위해 derive를 사용하고, enum의 메모리 레이아웃을 제어하기 위해 repr을 사용했습니다. 가능한 모든 값을 알기 때문에 u8로 제한할 수 있습니다.```\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다음으로, 우리는 게임을 나타내는 struct를 만들 것입니다. 여기에는 추적해야 할 모든 상태가 포함될 것입니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-javascript\",\n        children: [\"struct \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Game\"\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"current_move\"\n        }), \": u8,\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"current_player\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Player\"\n        }), \",\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"board\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Board\"\n        }), \",\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"is_finished\"\n        }), \": bool,\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"winner\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Player\"\n        }), \",\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"current_move는 플레이어가 선택한 열을 나타내는 정수입니다. 우리에게는 승자 필드가 있지만, 게임이 비김으로 끝날 때 별도로 is_finished 부울도 유용할 것입니다!\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"마지막으로, Game에 대한 기본 함수를 구현할 것입니다. 이 함수에는 초기 상태가 포함될 것입니다:\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-rust\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"impl\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Game\"\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"fn\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"default\"\n        }), \"() \", _jsx(_components.span, {\n          className: \"hljs-punctuation\",\n          children: \"->\"\n        }), \" Game {\\n        Game {\\n            current_move: \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \",\\n            current_player: Player::One,\\n            board: [\\n                [\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"],\\n                [\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"],\\n                [\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"],\\n                [\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"],\\n                [\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"],\\n                [\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"],\\n            ],\\n            is_finished: \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"false\"\n        }), \",\\n            winner: Player::\", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"None\"\n        }), \",\\n        }\\n    }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"보드에 대해 조금 이야기해 봅시다. 여기서 0은 빈 칸을 나타내며, 1은 Player One이 차지한 칸을 나타내고, 2는 Player Two가 차지한 칸을 나타냅니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"BOARD_WIDTH와 BOARD_HEIGHT를 사용하여 동적으로 생성할 수도 있었지만, 코드를 작성하는 동안 전체 배열을 보는 것이 도움이 되는 시각적 도구라는 것을 발견했습니다. 같은 이유로, 정수가 아닌 Player 열거형을 사용하지 않았습니다. 텍스트가 더 많아지면 코드를 한눈에 이해하기 어려워지기 때문입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 방법의 (약간의) 단점은 나중에 정수를 Player로 변환해야 한다는 것입니다. 하지만 Player에 from_int 함수를 구현함으로써 쉽게 해결할 수 있습니다.```\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"구현 \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Player\"\n        }), \" {\\n    fn \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"from_int\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"int\"\n        }), \": u8) -> \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Player\"\n        }), \" {\\n        match int {\\n            \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \" => \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Player\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"One\"\n        }), \",\\n            \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"2\"\n        }), \" => \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Player\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Two\"\n        }), \",\\n            \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"_\"\n          }), \" =>\"]\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Player\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"None\"\n        }), \",\\n        }\\n    }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"보드 표시\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"디버깅을 위해, 보드를 시각화하는 좋은 방법을 빠르게 코드화하는 것이 도움이 될 것입니다. 명령줄에 출력하기 위해 크레이트를 사용하는 대신에 간단한 색을 나타내기 위해 16진수 이스케이프 문자열을 사용할 것입니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"RESET\"\n        }), \": &str = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\\\\x1b[0m\\\"\"\n        }), \";\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"ORANGE\"\n        }), \": &str = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\\\\x1b[93m\\\"\"\n        }), \";\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"RED\"\n        }), \": &str = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\\\\x1b[0;31m\\\"\"\n        }), \";\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"아래의 코드에서는 맵을 사용하여 Connect 4 토큰과 유사한 이모지로 슬롯을 변환할 것입니다. 게임이 종료되면 우승자를 발표하는 좋은 장소로 보입니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"impl \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Game\"\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 다른 함수들\"\n        }), \"\\n\\n    fn \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"display_board\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"&self\"\n        }), \") {\\n        println!(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"{}--------------------{}\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"ORANGE\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"RESET\"\n        }), \");\\n        println!(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"{}CONNECT 4 (Move {}){}\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"ORANGE\"\n        }), \", self.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"current_move\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"RESET\"\n        }), \");\\n        println!(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"{}--------------------{}\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"ORANGE\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"RESET\"\n        }), \");\\n\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" row \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" self.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"board\"\n        }), \" {\\n            \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"row_str\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"String\"\n        }), \" = row\\n                .\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"iter\"\n        }), \"()\\n                .\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"map\"\n        }), \"(|&cell| match cell {\\n                    \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \" => \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"🔴\\\"\"\n        }), \",\\n                    \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"2\"\n        }), \" => \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"🟡\\\"\"\n        }), \",\\n                    \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"_\"\n          }), \" =>\"]\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"⚫\\\"\"\n        }), \",\\n                })\\n                .\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"collect\"\n        }), \"::<\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Vec\"\n        }), \"<&str>>()\\n                .\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"join\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\" \\\"\"\n        }), \");\\n\\n            println!(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"{}\\\"\"\n        }), \", row_str);\\n        }\\n\\n        println!(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"{}--------------------{}\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"ORANGE\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"RESET\"\n        }), \");\\n\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" self.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"is_finished\"\n        }), \" {\\n            match self.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"winner\"\n        }), \" {\\n                \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Player\"\n        }), \"::\", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"One\"\n          }), \" =>\"]\n        }), \" println!(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"{}🔴 Player 1이 승리했습니다!{}\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"ORANGE\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"RESET\"\n        }), \"),\\n                \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Player\"\n        }), \"::\", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"Two\"\n          }), \" =>\"]\n        }), \" println!(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"{}🟡 Player 2가 승리했습니다!{}\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"ORANGE\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"RESET\"\n        }), \"),\\n                \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Player\"\n        }), \"::\", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"None\"\n          }), \" =>\"]\n        }), \" println!(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"{}무승부입니다!{}\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"ORANGE\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"RESET\"\n        }), \"),\\n            }\\n\\n            println!(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"{}--------------------{}\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"ORANGE\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"RESET\"\n        }), \");\\n        }\\n    }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우리는 이것을 언제든지 메인 함수 내에서 호출하여 보드의 상태를 확인할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"fn \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"main\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\"\n        }), \") {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" mut game = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Game\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"default\"\n        }), \"();\\n    game.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"display_board\"\n        }), \"();\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"조금 지루하지만 수를 두지 않고는 재미가 없죠. 그래서 이제 수를 두는 방법을 프로그래밍해 봅시다!\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"수 두기\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우리의 play_move 함수를 첫 번째로 살펴보면, 이 함수는 이차원 배열에서 올바른 항목을 변경하고, 수를 증가시킨 다음 현재 플레이어를 변경해야 합니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-rust\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"impl\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Game\"\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// other functions\"\n        }), \"\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"fn\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"play_move\"\n        }), \"(&\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"mut\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"self\"\n        }), \", column: \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"usize\"\n        }), \") {\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"Some\"\n        }), \"(row) = (\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"..BOARD_HEIGHT)\\n            .\", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"rev\"\n        }), \"()\\n            .\", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"find\"\n        }), \"(|&row| \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"self\"\n        }), \".board[row][column] == \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \")\\n        {\\n            \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"self\"\n        }), \".board[row][column] = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"self\"\n        }), \".current_player \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"u8\"\n        }), \";\\n\\n            \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"self\"\n        }), \".current_move += \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \";\\n\\n            \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"self\"\n        }), \".current_player = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"match\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"self\"\n        }), \".current_player {\\n                Player::One => Player::Two,\\n                _ => Player::One,\\n            };\\n        }\\n    }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"위의 if let 코드에서는 열의 맨 아래부터 시작하여 하나씩 올라가면서 빈 칸을 찾을 때까지 진행합니다. 빈 칸을 찾으면 그 위치에 현재 플레이어를 나타내는 정수로 변경하고, 현재 이동을 증가시킨 후 match 표현식을 사용하여 플레이어를 변경합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 시점에서 코드를 통해 움직임을 실행하고 터미널에서 결과를 확인할 수 있습니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"fn \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"main\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\"\n        }), \") {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" mut game = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Game\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"default\"\n        }), \"();\\n    \\n    game.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"play_move\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"3\"\n        }), \");\\n    game.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"play_move\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"3\"\n        }), \");\\n    game.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"play_move\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"4\"\n        }), \");\\n    game.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"play_move\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"3\"\n        }), \");\\n\\n    game.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"display_board\"\n        }), \"();\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"오류 처리\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"지금까지 우리는 보드 바깥으로 이동을 시도하는 잠재적인 오류를 처리하지 않고 있습니다. 따라서 세 가지 가능한 오류를 처리해 봅시다:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"제공된 열이 허용 범위를 벗어납니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"제공된 열이 이미 가득 찼습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"게임이 끝났습니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"(사용자 입력을 받기 시작하면 추가적인 오류 처리가 필요할 것입니다. 나중에 처리하겠습니다.)\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"세 가지 오류 유형을 포함한 enum을 만들어 봅시다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"enum \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"MoveError\"\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"GameFinished\"\n        }), \",\\n    \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"InvalidColumn\"\n        }), \",\\n    \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ColumnFull\"\n        }), \",\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우리는 에러를 명령줄에 출력하기를 원하기 때문에, 우리의 에러 메시지를 포함하는 사용자 정의 Display 트레이트를 구현해야 합니다. 예를 들어:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"impl \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"std\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"fmt\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Display\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"MoveError\"\n        }), \" {\\n    fn \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"fmt\"\n        }), \"(&self, \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"f\"\n        }), \": &mut \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"std\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"fmt\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Formatter\"\n        }), \"<\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'_>) -> std::fmt::Result {\\n        match self {\\n            MoveError::ColumnFull => write!(f, \\\"column is full\\\"),\\n            MoveError::InvalidColumn => write!(f, \\\"column must be between 1 and 7\\\"),\\n            MoveError::GameFinished => write!(f, \\\"game is already finished\\\"),\\n        }\\n    }\\n}\\n\"\n        })]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 이를 사용하여 play_move 함수를 수정할 수 있습니다. 이제 우리는 움직임이 성공적이면 아무것도 반환하지만, 그렇지 않은 경우 에러가 반환되는 Result enum을 반환합니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-rust\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"impl\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Game\"\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 다른 함수들\"\n        }), \"\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"fn\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"play_move\"\n        }), \"(&\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"mut\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"self\"\n        }), \", column: \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"usize\"\n        }), \") \", _jsx(_components.span, {\n          className: \"hljs-punctuation\",\n          children: \"->\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"Result\"\n        }), \"<(), MoveError> {\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"self\"\n        }), \".is_finished {\\n            \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"Err\"\n        }), \"(MoveError::GameFinished);\\n        }\\n\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" column >= BOARD_WIDTH {\\n            \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"Err\"\n        }), \"(MoveError::InvalidColumn);\\n        }\\n\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"Some\"\n        }), \"(row) = (\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"..BOARD_HEIGHT)\\n            .\", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"rev\"\n        }), \"()\\n            .\", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"find\"\n        }), \"(|&row| \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"self\"\n        }), \".board[row][column] == \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \")\\n        {\\n            \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"self\"\n        }), \".board[row][column] = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"self\"\n        }), \".current_player \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"u8\"\n        }), \";\\n        } \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"else\"\n        }), \" {\\n            \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"Err\"\n        }), \"(MoveError::ColumnFull);\\n        }\\n\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"self\"\n        }), \".current_move += \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \";\\n\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"self\"\n        }), \".current_player = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"match\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"self\"\n        }), \".current_player {\\n            Player::One => Player::Two,\\n            _ => Player::One,\\n        };\\n\\n        \", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"Ok\"\n        }), \"(())\\n    }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"디버깅을 위해 이제 play_move의 결과를 인쇄할 수 있으며, 예상치 못한 입력이 있는 경우 enum으로부터 에러를 볼 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우리가 여기에 있는 동안, 명령줄에 에러 메시지를 인쇄하는 도우미 함수를 추가해 봅시다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-rust\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"impl\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Game\"\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 다른 함수들\"\n        }), \"\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"fn\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"display_error\"\n        }), \"(&\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"self\"\n        }), \", error: \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"String\"\n        }), \") {\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"self\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"display_board\"\n        }), \"();\\n        \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"println!\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"{}에러: {}{}\\\"\"\n        }), \", RED, error, RESET);\\n    }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"게임에서 승리했는지 계산하기\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"누군가가 이겼는지 확인하기 위해 2차원 배열을 여러 방향으로 탐색해야 합니다. 이 Leetcode 스타일 문제는 재미있는 도전이었고, 결과물을 얻기까지 몇 번 시도해야 했어요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"누군가가 4칸을 연달아 얻을 수 있는 네 가지 방향이 있어요:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"수평,\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"수직,\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"역 슬래시 대각선 (왼쪽 위에서 오른쪽 아래로),\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"순방향 슬래시 대각선 (왼쪽 아래에서 오른쪽 위로).\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"게시판의 모든 슬롯을 반복하여 네 방향 중 하나에서 테스트할 수 있습니다. (게시판이 작기 때문에 무차별 대입 방식을 사용하는 것이 부담이 되지 않습니다. 그러나 더 나은 방법이 있는지 궁금합니다!)\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"게시판의 주어진 슬롯에서 시작합니다. 플레이어의 토큰이 들어있는 경우, 첫 번째 방향으로 한 단계 이동합니다. 이 새로운 슬롯도 같은 토큰을 포함하는 경우, 이 방향으로 또 다른 단계를 이동합니다. 이를 반복하여 같은 토큰이 있는 네 개의 슬롯을 찾을 때까지 진행합니다. 그렇지 않으면 다른 방향으로 이동합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"각 방향은 정수들의 튜플로 나타낼 수 있습니다 - 행당 거리에 대한 값과 열당 거리에 대한 값 하나씩 - 이 정보를 배열에 저장할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" directions = [\\n    (\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"),  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 가로\"\n        }), \"\\n    (\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"),  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 세로\"\n        }), \"\\n    (\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"),  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 대각선 (왼쪽 위에서 오른쪽 아래)\"\n        }), \"\\n    (-\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"), \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 대각선 (왼쪽 아래에서 오른쪽 위)\"\n        }), \"\\n];\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 튜플들이 무엇을 나타내는지 알려드릴게요:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"수평으로 이동하려면 행은 변하지 않고(0), 열만 변해야 합니다(1).\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"수직으로 이동하려면 행이 변해야 하고(1), 열은 변하지 않아야 합니다(0).\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"역 슬래시 대각선으로 이동하려면 행과 열이 둘 다 증가해야 합니다(1, 1).\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"마지막으로, 슬래시 대각선으로 이동하려면 열은 증가하고 행은 감소해야 합니다(-1, 1).\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"각 방향의 모든 슬롯을 테스트하려면 아래와 같이 세 개의 루프가 필요합니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-rust\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"impl\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Game\"\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 다른 함수들\"\n        }), \"\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"fn\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"calculate_winner\"\n        }), \"(&\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"mut\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"self\"\n        }), \") \", _jsx(_components.span, {\n          className: \"hljs-punctuation\",\n          children: \"->\"\n        }), \" Player {\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"row\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"..BOARD_HEIGHT {\\n            \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"col\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"..BOARD_WIDTH {\\n                \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"cell\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"self\"\n        }), \".board[row][col];\\n\\n                \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" cell != \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \" {\\n                    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"directions\"\n        }), \" = [\\n                        (\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"),  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 수평\"\n        }), \"\\n                        (\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"),  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 수직\"\n        }), \"\\n                        (\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"),  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 대각선 (왼쪽 위에서 오른쪽 아래로)\"\n        }), \"\\n                        (-\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"), \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 대각선 (왼쪽 아래에서 오른쪽 위로)\"\n        }), \"\\n                    ];\\n\\n                    \", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"for\"\n        }), \" (row_step, col_step) \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" directions {\\n                        \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// TODO - 주어진 방향으로 보드를 탐색하고\"\n        }), \"\\n                        \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 승자를 찾았다면 해당 플레이어를 반환하세요\"\n        }), \"\\n                    }\\n                }\\n            }\\n        }\\n        Player::\", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"None\"\n        }), \"\\n    }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우리는 연속 카운트를 유지하고 — 4에 도달하면 승자가 나온 것을 알 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그럼, 최종 중첩된 루프에서는 시작 토큰부터 슬롯별로 이동을 시도할 것입니다. 그때까지…\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"시작 토큰과 다른 토큰을 만날 때 (그러한 경우 루프를 종료합니다);\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"보드의 가장자리에 도달할 때 (그러한 경우 루프를 종료합니다);\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"동일한 토큰의 4연속을 만날 때 (그러한 경우 게임을 종료하고 승자를 지정합니다).\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"impl \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Game\"\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 다른 함수들\"\n        }), \"\\n\\n    fn \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"calculate_winner\"\n        }), \"(&mut self) -> \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Player\"\n        }), \" {\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" row \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"BOARD_HEIGHT\"\n        }), \" {\\n            \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" col \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"BOARD_WIDTH\"\n        }), \" {\\n                \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" cell = self.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"board\"\n        }), \"[row][col];\\n\\n                \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" cell != \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \" {\\n                    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" directions = [\\n                        (\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"),  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 가로\"\n        }), \"\\n                        (\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"),  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 세로\"\n        }), \"\\n                        (\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"),  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 대각선 (왼쪽 위에서 오른쪽 아래로)\"\n        }), \"\\n                        (-\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"), \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 대각선 (왼쪽 아래에서 오른쪽 위로)\"\n        }), \"\\n                    ];\\n\\n                    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" (row_step, col_step) \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" directions {\\n                        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" mut consecutive_count = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \";\\n                        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" mut r = row \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" isize + row_step;\\n                        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" mut c = col \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" isize + col_step;\\n\\n                        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"while\"\n        }), \" r >= \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"\\n                            && r < \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"BOARD_HEIGHT\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" isize\\n                            && c >= \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"\\n                            && c < \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"BOARD_WIDTH\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" isize\\n                        {\\n                            \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" self.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"board\"\n        }), \"[r \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" usize][c \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" usize] == cell {\\n                                consecutive_count += \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \";\\n\\n                                \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" consecutive_count == \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"4\"\n        }), \" {\\n                                    self.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"is_finished\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"true\"\n        }), \";\\n                                    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Player\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"from_int\"\n        }), \"(cell);\\n                                }\\n                            } \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"else\"\n        }), \" {\\n                                \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"break\"\n        }), \";\\n                            }\\n                            r += row_step;\\n                            c += col_step;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Player\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"None\"\n        }), \"\\n    }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우리는 이동 횟수가 일곱 미만인 경우 이러한 확인 작업을 수행하지 않고 최적화를 조금 추가할 수 있습니다. 그때까지는 게임에서 이기는 것이 불가능하기 때문입니다. 그래서 함수 맨 위에 이를 추가해 봅시다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" self.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"current_move\"\n        }), \" < \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"7\"\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Player\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"None\"\n        }), \";\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그리고 보드가 가득 찼지만 승자가 없는 경우(즉, 무승부인 경우)에 게임을 종료로 표시해야 합니다. 이를 반환문 위에 추가해 줍시다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" self.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"current_move\"\n        }), \" >= \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"BOARD_HEIGHT\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" u8 * \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"BOARD_WIDTH\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" u8 {\\n    self.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"is_finished\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"true\"\n        }), \";\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"마지막으로, 새로운 calculate_winner 함수를 play_move 함수에 추가할 수 있습니다. 이번에는 아무것도 반환하는 대신, 성공인 Result enum을 반환하거나 실패인 경우에는 오류를 반환합니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"impl \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Game\"\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 다른 함수들\"\n        }), \"\\n\\n    fn \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"play_move\"\n        }), \"(&mut self, \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"column\"\n        }), \": usize) -> \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Result\"\n        }), \"<(), \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"MoveError\"\n        }), \"> {\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" self.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"is_finished\"\n        }), \" {\\n            \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Err\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"MoveError\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"GameFinished\"\n        }), \");\\n        }\\n\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" column >= \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"BOARD_WIDTH\"\n        }), \" {\\n            \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Err\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"MoveError\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"InvalidColumn\"\n        }), \");\\n        }\\n\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Some\"\n        }), \"(row) = (\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"BOARD_HEIGHT\"\n        }), \")\\n            .\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"rev\"\n        }), \"()\\n            .\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"find\"\n        }), \"(\", _jsxs(_components.span, {\n          className: \"hljs-params\",\n          children: [\"|&row| self.board[row][column] == \", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"0\"\n          })]\n        }), \")\\n        {\\n            self.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"board\"\n        }), \"[row][column] = self.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"current_player\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" u8;\\n            self.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"current_move\"\n        }), \" += \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \";\\n        } \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"else\"\n        }), \" {\\n            \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Err\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"MoveError\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ColumnFull\"\n        }), \");\\n        }\\n\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" calculated_winner = self.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"calculate_winner\"\n        }), \"();\\n\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" calculated_winner != \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Player\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"None\"\n        }), \" {\\n            self.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"winner\"\n        }), \" = calculated_winner;\\n        } \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"else\"\n        }), \" {\\n            self.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"current_player\"\n        }), \" = match self.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"current_player\"\n        }), \" {\\n                \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Player\"\n        }), \"::\", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"One\"\n          }), \" =>\"]\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Player\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Two\"\n        }), \",\\n                \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"_\"\n          }), \" =>\"]\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Player\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"One\"\n        }), \",\\n            };\\n        }\\n\\n        \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Ok\"\n        }), \"(())\\n    }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우리의 Connect 4 게임 엔진이 완성되었습니다! 사용자로부터 입력을 받는 방법만 남았습니다...\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"사용자 입력 받기\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우리 명령 줄 게임의 마지막 부분에서는 주 함수로 돌아가 사용자 입력을 읽을 수 있도록 할 것입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"먼저, Rust의 표준 I/O 라이브러리를 가져오겠습니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"use \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"std\"\n        }), \"::io;\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"사용자 입력을 읽는 논리는 다음과 같이 보일 수 있습니다. 여기서는 컴퓨터와 달리 0이 아닌 1부터 시작하여 카운트하게 됩니다!\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" mut user_move = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"String\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"new\"\n        }), \"();\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"io\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"stdin\"\n        }), \"()\\n    .\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"read_line\"\n        }), \"(&mut user_move)\\n    .\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"expect\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Failed to read line\\\"\"\n        }), \");\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"user_move\"\n        }), \": usize = match user_move.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"trim\"\n        }), \"().\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"parse\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\"\n        }), \") {\\n    \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Ok\"\n        }), \"(num) => {\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" num < \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \" || num > \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"BOARD_WIDTH\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" u8 {\\n            game.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"display_error\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"MoveError\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"InvalidColumn\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"to_string\"\n        }), \"());\\n            \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"continue\"\n        }), \";\\n        } \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"else\"\n        }), \" {\\n            num\\n        }\\n    }\\n    \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Err\"\n        }), \"(err) => {\\n        game.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"display_error\"\n        }), \"(err.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"to_string\"\n        }), \"());\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"continue\"\n        }), \";\\n    }\\n};\\n\\nmatch game.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"play_move\"\n        }), \"(\", _jsxs(_components.span, {\n          className: \"hljs-params\",\n          children: [\"user_move - \", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"1\"\n          })]\n        }), \") {\\n    \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Ok\"\n        }), \"(_) => {\\n        game.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"display_board\"\n        }), \"();\\n    }\\n    \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Err\"\n        }), \"(err) => {\\n        game.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"display_error\"\n        }), \"(err.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"to_string\"\n        }), \"());\\n    }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"먼저, 우리는 빈 문자열을 정의한 뒤 사용자로부터 텍스트를 받기 위해 stdin 메소드를 사용합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다음으로 이 입력을 구문 분석을 시도합니다. 다음 중 하나라도 해당하는 경우 오류를 표시합니다:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"구문 분석이 실패하는 경우 (예: 입력이 숫자가 아닌 경우).\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"구문 분석이 성공하지만 숫자가 원하는 범위를 벗어난 경우.```\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"만약 오류가 표시되지 않는다면, 우리는 선택한 수를 둘 것입니다. 그러나 해당 시나리오에서 오류가 발생할 수도 있으므로, 그런 경우에는 오류를 표시할 것입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그러나 위의 코드는 한 번만 실행됩니다. 게임이 끝날 때까지 루프를 실행해야 합니다. 아래는 그 반복문을 추가한 main 함수와 사용자를 도와줄 몇 가지 유용한 메시지입니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"fn \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"main\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\"\n        }), \") {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" mut game = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Game\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"default\"\n        }), \"();\\n    game.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"display_board\"\n        }), \"();\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"while\"\n        }), \" !game.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"is_finished\"\n        }), \" {\\n        println!(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\\\\n\\\"\"\n        }), \");\\n\\n        match game.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"current_player\"\n        }), \" {\\n            \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Player\"\n        }), \"::\", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"One\"\n          }), \" =>\"]\n        }), \" println!(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"플레이어 1\\\"\"\n        }), \"),\\n            \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Player\"\n        }), \"::\", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"Two\"\n          }), \" =>\"]\n        }), \" println!(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"플레이어 2\\\"\"\n        }), \"),\\n            \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"_\"\n          }), \" =>\"]\n        }), \" (),\\n        };\\n\\n        println!(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"1부터 7 사이의 열을 입력하세요:\\\"\"\n        }), \");\\n\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" mut user_move = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"String\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"new\"\n        }), \"();\\n        \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"io\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"stdin\"\n        }), \"()\\n            .\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"read_line\"\n        }), \"(&mut user_move)\\n            .\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"expect\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"라인을 읽는 데 실패했습니다\\\"\"\n        }), \");\\n\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"user_move\"\n        }), \": usize = match user_move.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"trim\"\n        }), \"().\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"parse\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\"\n        }), \") {\\n            \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Ok\"\n        }), \"(num) => {\\n                \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" num < \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \" || num > \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"7\"\n        }), \" {\\n                    game.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"display_error\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"MoveError\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"InvalidColumn\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"to_string\"\n        }), \"());\\n                    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"continue\"\n        }), \";\\n                } \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"else\"\n        }), \" {\\n                    num\\n                }\\n            }\\n            \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Err\"\n        }), \"(err) => {\\n                game.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"display_error\"\n        }), \"(err.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"to_string\"\n        }), \"());\\n                \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"continue\"\n        }), \";\\n            }\\n        };\\n\\n        match game.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"play_move\"\n        }), \"(\", _jsxs(_components.span, {\n          className: \"hljs-params\",\n          children: [\"user_move - \", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"1\"\n          })]\n        }), \") {\\n            \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Ok\"\n        }), \"(_) => {\\n                game.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"display_board\"\n        }), \"();\\n            }\\n            \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Err\"\n        }), \"(err) => {\\n                game.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"display_error\"\n        }), \"(err.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"to_string\"\n        }), \"());\\n            }\\n        }\\n    }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"여러 판을 플레이하기\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"마지막으로, 사용자가 게임을 끝내면 게임을 다시 시작할 수 있도록 추가 코드를 추가하고 싶어요. 매번 실행 파일을 다시 시작해야 하는 번거로움은 피하고 싶으니까요!\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이를 위해 새로운 루프를 만들 것입니다. 이전과 동일한 방법을 사용하여 사용자의 입력을 읽을 수 있습니다. \\\"R\\\"을 누르면 새 게임을 시작하고, \\\"Q\\\"를 누르면 루프를 중단하고 코드를 끝까지 실행합니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"fn \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"main\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\"\n        }), \") {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" mut game = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Game\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"default\"\n        }), \"();\\n    game.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"display_board\"\n        }), \"();\\n\\n    loop {\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"while\"\n        }), \" !game.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"is_finished\"\n        }), \" {\\n            \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 코드 변경 없음\"\n        }), \"\\n        }\\n\\n        println!(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Press 'R' to restart or 'Q' to quit the game.\\\"\"\n        }), \");\\n\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" mut user_input = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"String\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"new\"\n        }), \"();\\n\\n        \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"io\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"stdin\"\n        }), \"()\\n            .\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"read_line\"\n        }), \"(&mut user_input)\\n            .\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"expect\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Failed to read line\\\"\"\n        }), \");\\n\\n        match user_input.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"trim\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\"\n        }), \") {\\n            \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"R\\\"\"\n        }), \" | \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"r\\\"\"\n        }), \" => {\\n                game = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Game\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"default\"\n        }), \"();\\n                game.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"display_board\"\n        }), \"();\\n            }\\n            \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Q\\\"\"\n        }), \" | \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"q\\\"\"\n        }), \" => {\\n                println!(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Quitting...\\\"\"\n        }), \");\\n                \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"break\"\n        }), \";\\n            }\\n            _ => game.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"display_error\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"잘못된 입력\\\"\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"to_string\"\n        }), \"()),\\n        }\\n    }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"마지막으로, 차례 사이에 터미널을 지우기 위한 ASCII 이스케이프 코드를 사용할 수 있습니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"fn \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"clear_screen\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"&self\"\n        }), \") {\\n    print!(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"{}[2J\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"27\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" char);\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"게임 보드를 표시할 때마다 이 작업을 수행할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"fn \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"display_board\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"&self\"\n        }), \") {\\n    self.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"clear_screen\"\n        }), \"();\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 코드 변경 없음\"\n        }), \"\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"모두 함께 가져오기\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그것이 커넥트 4의 간단한 명령줄 게임을 위해 필요한 모든 것입니다! 이 작업 중인 파일을 사용하는 작동 버전을 시험하려면 Rust 플레이그라운드를 확인해보세요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우리가 지금까지 만든 전체 파일은 아래와 같습니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"use \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"std\"\n        }), \"::io;\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"RESET\"\n        }), \": &str = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\\\\x1b[0m\\\"\"\n        }), \";\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"ORANGE\"\n        }), \": &str = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\\\\x1b[93m\\\"\"\n        }), \";\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"RED\"\n        }), \": &str = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\\\\x1b[0;31m\\\"\"\n        }), \";\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"BOARD_WIDTH\"\n        }), \": usize = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"7\"\n        }), \";\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"BOARD_HEIGHT\"\n        }), \": usize = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"6\"\n        }), \";\\n\\ntype \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Board\"\n        }), \" = [[u8; \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"BOARD_WIDTH\"\n        }), \"]; \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"BOARD_HEIGHT\"\n        }), \"];\\n\\n#[\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"derive\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Clone\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Copy\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Debug\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"PartialEq\"\n        }), \")]\\n#[\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"repr\"\n        }), \"(u8)]\\nenum \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Player\"\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"One\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \",\\n    \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Two\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"2\"\n        }), \",\\n    \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"None\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \",\\n}\\n\\nimpl \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Player\"\n        }), \" {\\n    fn \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"from_int\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"int\"\n        }), \": u8) -> \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Player\"\n        }), \" {\\n        match int {\\n            \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \" => \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Player\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"One\"\n        }), \",\\n            \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"2\"\n        }), \" => \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Player\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Two\"\n        }), \",\\n            \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"_\"\n          }), \" =>\"]\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Player\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"None\"\n        }), \",\\n        }\\n    }\\n}\\n\\n#[...]\\n\\n# 결론\\n\\n<div \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \"=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"content-ad\\\"\"\n        }), \"></div>\\n\\n지금까지 따라오셨다면 프로젝트를 더 나아가고 싶을 것입니다. 여러 게임을 거치면서 승리를 추적해 볼 수도 있고, 어떨까요? 어플리케이션을 웹 서버로 전환하여 웹사이트가 \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"HTTP\"\n        }), \"를 통해 \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Connect\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"4\"\n        }), \"를 플레이할 수 있게끔 만들어 보는 것은 어떤가요?\\n\\n이번 명령줄 어플리케이션을 \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Rust\"\n        }), \"로 개발하는 방법에 대한 유용하고 재미있는 통찰력으로 여기시길 바랍니다. 아직 \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Rust\"\n        }), \" 여행을 시작한 지 얼마 되지 않았기 때문에, 어떠한 비평이나 더 많은 \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Rust\"\n        }), \" 다운 방식으로 어플리케이션을 작성하는 아이디어가 있다면 꼭 알려주세요. 함께 고민해보고 싶습니다.\\n\"]\n      })\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true}