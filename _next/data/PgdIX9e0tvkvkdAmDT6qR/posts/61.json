{"pageProps":{"posts":[{"title":"자바 SpringBoot를 사용한 JSON 스키마 유효성 검사기","description":"","date":"2024-05-17 17:43","slug":"2024-05-17-JSONSchemaValidatorusingJavaSpringBoot","content":"\n\n## Json 스키마란 무엇인가요?\n\nJSON Schema은 선언적 언어입니다. 이는 우리 서비스에 특정한 json 구조를 정의하고 유효성을 검사합니다. 주어진 json 데이터에 대한 표준 구조로 여러 시스템에서 사용할 수 있습니다. 자세한 내용은 여기를 참조하세요: what-is-jsonschema?\n\n## Json 스키마를 사용하는 이유는 무엇인가요?\n\n대부분의 경우, 서비스에서 들어오는 json을 유효성 검사하는 것이 필요합니다. 간단한 json은 속성에 제약 조건을 적용하여 POJO 또는 모델에 매핑할 때 유효성을 검사할 수 있습니다. 그러나 때로는 json이 복잡하여 이러한 제약 조건을 사용하여 모든 필드를 유효성을 검사할 수 없는 경우가 있습니다. JsonSchema를 사용하면 표준화된 구조를 사용하여 복잡한 json을 유효성을 검사할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 내용:\n\nSpringBoot와 Json Schema를 사용하는 단계별 가이드입니다. 이를 위해 networknt 라이브러리를 사용할 것입니다. 단계를 거친 후에는 테스트를 위해 수신된 json에 대한 몇 가지 시나리오가 있습니다.\n\n참고: 이 문서는 SpringBoot와 JsonSchema의 사용을 위한 것입니다. 이는 JsonSchema의 일부 기능 및 사용법에 대해 가르치기 위한 것입니다.\n\n## 1. SpringBoot 웹 애플리케이션을 생성하세요: https://start.spring.io/\n\n<div class=\"content-ad\"></div>\n\n```md\n![image](/assets/img/2024-05-17-JSONSchemaValidatorusingJavaSpringBoot_0.png)\n\n알림: spring-boot 및 java의 모든 버전 및 프로젝트 유형을 선택할 수 있습니다.\n\n## 2. pom.xml 또는 build.gradle에 종속성 추가.\n\n```js\n<--\npom.xml\nhttps://mvnrepository.com/artifact/com.networknt/json-schema-validator\n-->\n<dependency>\n  <groupId>com.networknt</groupId>\n  <artifactId>json-schema-validator</artifactId>\n  <version>1.4.0</version>\n</dependency>\n```\n\n<div class=\"content-ad\"></div>\n\n```js\n// build.gradle\n// https://mvnrepository.com/artifact/com.networknt/json-schema-validator\nimplementation 'com.networknt:json-schema-validator:1.4.0'\n```\n\n## 3. 리소스 유효성 검사 JSON 파일을 생성합니다.\n\n```js\n{\n \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n    \"title\": \"Order Event\",\n    \"description\": \"예제용 주문 이벤트 스키마\",\n    \"required\": [\"order_id\", \"total_price\", \"products\" ],\n    \"properties\": {\n       \"order_id\": {\n          \"type\": \"string\"\n        },\n        \"event\": {\n          \"enum\": [\"PLACED\", \"DELIVERED\", \"RETURNED\"],\n          \"type\": \"string\"\n        },\n        \"total_price\": { \n         \"type\": \"number\",\n             \"minimum\": 0\n     },\n        \"products\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"additionalProperties\": true,\n        \"required\": [\"product_id\", \"price\"],\n        \"minItems\": 1,\n        \"properties\": {\n          \"product_id\": {\n            \"type\": \"string\"\n          },\n          \"price\": {\n            \"type\": \"number\",\n            \"minimum\": 0\n          },\n          \"quantity\": {\n            \"type\": \"integer\"\n          }\n        }\n      }\n    }\n   }\n}\n```\n\n## 4. JsonSchema 빈을 생성합니다.\n\n\n<div class=\"content-ad\"></div>\n\n호출자 메서드에서는 JsonSchema 객체를 직접 생성할 수 있지만, 빈을 생성하고 사용하는 것을 권장합니다.\n\n```java\n@Configuration\npublic class AppConfiguration {\n    private static final String SCHEMA_VALIDATION_FILE = \"validation.json\";\n   \n    @Bean\n    public JsonSchema jsonSchema() {\n        return JsonSchemaFactory\n                .getInstance( SpecVersion.VersionFlag.V7 )\n                .getSchema( getClass().getResourceAsStream( SCHEMA_VALIDATION_FILE ) );\n    }\n}\n```\n\n## 5. JsonSchema 사용법\n\n이제 JsonSchema 객체를 사용해보겠습니다. JsonNode를 매개변수로 사용하는 메서드가 있는 Service 클래스를 만들겠습니다.\n\n<div class=\"content-ad\"></div>\n\n```java\n@Slf4j\n@Service\npublic class JsonSchemaValidationService{\n  \n  @Autowired\n  private JsonSchema jsonSchema;\n  \n  public String validateJson(JsonNode jsonNode){\n    \n    Set<ValidationMessage> errors = jsonSchema.validate(jsonNode);\n    //if errors have a single miss match, there would be a value in the errors set.\n    if(errors.isEmpty()){\n      //event is valid.\n      log.info(\"event is valid\");\n    }else{\n        //event is in_valid.\n      log.info(\"event is invalid\");\n     }\n      return errors.toString();\n  }\n}\n```\n\n## 6. Create a Rest Controller.\n\n```java\nimport com.fasterxml.jackson.databind.JsonNode;\n@RestController\npublic class JsonSchemaController {\n    @Autowired\n    private JsonSchemaValidationService service;\n\n    @PostMapping(\"/validate\")\n    public String validateEvent( @RequestBody JsonNode jsonNode ){\n       return service.validateJson(jsonNode);\n    }\n}\n```\n\n## 7. Start the SpringBoot Application and start sending requests.```\n\n<div class=\"content-ad\"></div>\n\n이제 모든 것이 준비되었으니, 즐겨 사용하는 클라이언트를 사용하여 코드를 테스트할 수 있습니다. 저는 PostMan을 사용하고 있어요. 아래에서 유효한 이벤트로 시작해보겠습니다.\n\n```js\n# 유효한 데이터\ncurl --location 'localhost:8080/validate' \\\n--header 'Content-Type: application/json' \\\n--data '{\n  \"order_id\":\"order134\",\n   \"event\": \"PLACED\",\n   \"products\": [\n     {\n       \"product_id\": \"product_1\",\n        \"price\":20.5,\n       \"quantity\":2\n     }\n   ],\n   \"total_price\": 41\n}'\n```\n\n응답:\n\n```js\n[]\n```\n\n<div class=\"content-ad\"></div>\n\n```js\n# order id 없는 페이로드\ncurl --location 'localhost:8080/validate' \\\n--header 'Content-Type: application/json' \\\n--data '{\n   \"event\": \"PLACED\",\n   \"products\": [\n     {\n       \"product_id\": \"product_1\",\n        \"price\":20.5,\n       \"quantity\":2\n     }\n   ],\n   \"total_price\": 41\n}'\n```\n\n응답 :\n\n```js\n[$.order_id: 필수 항목이지만 누락되었습니다]\n```\n\n```js\n# order id 없는 페이로드\ncurl --location 'localhost:8080/validate' \\\n--header 'Content-Type: application/json' \\\n--data '{\n\"order_id\":\"order134\",\n   \"event\": \"PLACED\",\n   \"total_price\": 41\n}'\n```\n\n<div class=\"content-ad\"></div>\n\n```js\n[$.products: is missing but it is required]\n```\n\n```js\n# order id가 없는 payload\ncurl --location 'localhost:8080/validate' \\\n--header 'Content-Type: application/json' \\\n--data '{\n \"order_id\" : \"order_123\",\n   \"event\": \"PLACED\",\n   \"products\": [\n\n   ],\n   \"total_price\": 41\n}'\n```\n\n응답 :\n\n<div class=\"content-ad\"></div>\n\n```js\n[$.products: 배열에는 최소 1개의 항목이 있어야 합니다.]\n```\n\n<img src=\"/assets/img/2024-05-17-JSONSchemaValidatorusingJavaSpringBoot_1.png\" />","ogImage":{"url":"/assets/img/2024-05-17-JSONSchemaValidatorusingJavaSpringBoot_0.png"},"coverImage":"/assets/img/2024-05-17-JSONSchemaValidatorusingJavaSpringBoot_0.png","tag":["Tech"],"readingTime":6},{"title":"국영세대 ZGC로 일시 중지 시간을 제어하세요","description":"","date":"2024-05-17 17:41","slug":"2024-05-17-BendingpausetimestoyourwillwithGenerationalZGC","content":"\n\nZ Garbage Collector 세대의 놀라운 혜택과 그리 놀라운 혜택.\n\nDanny Thomas가 쓴 JVM 에코시스템 팀의 기사\n\n![GenerationalZGC](/assets/img/2024-05-17-BendingpausetimestoyourwillwithGenerationalZGC_0.png)\n\n최신 장기 지원 릴리스인 JDK는 Z Garbage Collector를 위한 세대 지원을 제공합니다. Netflix는 주요 이유로 동시 가비지 수집의 중요한 혜택을 인한 것으로, JDK 21 및 그 이후부터 G1에서 Generational ZGC로 기본 전환했습니다.\n\n<div class=\"content-ad\"></div>\n\n저희 핵심 스트리밍 비디오 서비스 중 절반 이상이 Generational ZGC와 JDK 21에서 실행 중이에요. 이제 제 경험과 얻은 혜택에 대해 이야기할 때가 좋아졌네요. Netflix에서 Java를 어떻게 사용하는지 궁금하시다면, Paul Bakker의 강연인 'Netflix가 정말로 Java를 사용하는 방법'이 좋은 시작점이 될 거예요.\n\n# Tail Latency 감소\n\n저희 GRPC와 DGS 프레임워크 서비스에서 GC 일시 중단은 Tail Latency의 중요한 원인 중 하나에요. 특히 GRPC 클라이언트와 서버에서는 시간 초과로 인한 요청 취소가 재시도, 헤징 및 폴백과 같은 신뢰성 기능과 상호작용하죠. 이러한 에러마다 요청이 취소되어 재시도되는 것인데, 이런 감소로 인해 전체 서비스 트래픽이 더욱 줄어들었어요: \n\n![이미지](/assets/img/2024-05-17-BendingpausetimestoyourwillwithGenerationalZGC_1.png)\n\n<div class=\"content-ad\"></div>\n\n잦은 일시 정지의 소음을 제거하면 실제 지연 원천을 식별할 수 있어서 그렇지 않으면 소음에 감춰져 있을 수 있습니다. 최대 일시 중지 시간 이상치는 상당히 중요할 수 있습니다:\n\n![image](/assets/img/2024-05-17-BendingpausetimestoyourwillwithGenerationalZGC_2.png)\n\n# 효율\n\n평가 결과가 매우 유망하게 나타난 후에도 ZGC의 채택을 교환할 것으로 예상했습니다: 스토어 및 로드 버리어, 스레드 로컬 핸드셰이크에서 수행되는 작업 및 응용프로그램 자원 경합으로 인한 GC로 인해 약간의 응용프로그램 처리량이 줄어드는 경우. 우리는 그것을 수용 가능한 교환이라고 생각했는데, 일시 정지를 피함으로써 그 부가적인 오버헤드보다 더 큰 이점을 제공했습니다.\n\n<div class=\"content-ad\"></div>\n\n사실 우리의 서비스와 아키텍처에 대해 조사한 결과, 그러한 교환이 없다는 것을 발견했습니다. 특정 CPU 활용 목표에 대해 ZGC는 G1과 비교했을 때 평균 및 P99 대기 시간을 개선하면서 CPU 활용률도 동등하거나 더 나아진다는 것을 알 수 있었습니다.\n\n우리가 관찰한 많은 서비스에서 요청률, 요청 패턴, 응답 시간 및 할당률의 일관성이 ZGC를 도와주지만, ZGC가 덜 일관된 워크로드를 처리하는 능력도 뛰어나다는 것을 확인했습니다 (물론 예외는 있습니다; 자세한 내용은 아래에서 다루겠습니다).\n\n# 운영의 간편함\n\n서비스 소유자들은 종종 너무 긴 일시 중지 시간에 대한 질문이나 튜닝 도움을 요청합니다. 우리는 주기적으로 많은 양의 힙 데이터를 새로 고치는 여러 프레임워크를 보유하고 있어서 외부 서비스 호출을 효율적으로 피하기 위해 이를 사용합니다. 힙 데이터의 주기적 갱신으로 G1을 깜짝놀라게 하는 이러한 작업은 기본 일시 중지 시간 목표를 크게 넘는 이상값에 이르게 합니다.\n\n<div class=\"content-ad\"></div>\n\n아래는 Markdown 형식으로 테이블을 변환한 것입니다.\n\n\n| Feature        | Description                                                                                                                                                                                  |\n|----------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| Generational ZGC | Improved CPU utilization by nearly 10% compared to G1 for the same workload.                                                                                                                 |\n| Hollow library | Used by half of the streaming video services for on-heap metadata, which led to the removal of array pooling mitigations and saved hundreds of megabytes of memory for allocations.       |\n| Operational simplicity | ZGC's heuristics and defaults require no explicit tuning to achieve optimal results. Allocation stalls are rare and shorter than with G1.                                                        |\n| Memory overhead | The long-lived on-heap data was the main reason we previously avoided non-generational ZGC, but generational ZGC helped improve the situation significantly.                                   |\n\n\n<div class=\"content-ad\"></div>\n\n힙의 압축된 참조를 잃어버리기 때문에 64비트 객체 포인터가 필요한 색상 포인터 때문에 32G의 힙에서 압축된 참조를 잃어버리는 것이 가비지 콜렉터 선택의 주요 요소가 될 것으로 예상했습니다.\n\n우리는 그것이 스탑-더-월드 GC들에 대해 중요한 고려 사항이긴 하지만, 작은 힙에서라도 할당 속도의 증가가 효율성과 운영 개선에 의해 상쇄된다는 점을 발견했습니다. 오라클의 Erik Österlund씨에게 감사드립니다. 동시 가비지 콜렉터에 있어서 색상 포인터의 직관적이지 않은 이점을 설명해 준 덕분에 우리는 초기 계획보다 ZGC를 더 폭넓게 평가하게 되었습니다.\n\n대부분의 경우 ZGC는 응용 프로그램에 더 많은 메모리를 일관되게 제공할 수도 있습니다.\n\n<div class=\"content-ad\"></div>\n\nZGC는 힙 크기의 3%에 대한 고정 오버헤드가 있어 G1보다 더 많은 원시 메모리를 필요로 합니다. 몇 가지 예외를 제외하고는 더 많은 여유 공간을 위해 최대 힙 크기를 낮출 필요가 없었으며, 그것들은 평균 이상의 원시 메모리 요구가 있는 서비스들이었습니다.\n\n참조 처리는 또한 ZGC에서 주요 콜렉션 시에만 수행됩니다. 직접 바이트 버퍼의 할당 해제에 특히 주의를 기울였지만, 지금까지는 영향을 볼 수 없었습니다. 이 참조 처리의 차이로 JSON 쓰레드 덤프 지원에서 성능 문제가 발생했지만, 이것은 프레임워크가 실수로 각 요청마다 사용되지 않는 ExecutorService 인스턴스를 생성하여 발생한 특이한 상황입니다.\n\n# Transparent huge pages\n\nZGC를 사용하지 않더라도 거대 페이지를 사용해야 할 것입니다. 투명 거대 페이지가 그들을 사용하는 가장 편리한 방법입니다.\n\n<div class=\"content-ad\"></div>\n\nZGC는 힙에 대해 공유 메모리를 사용하며, 많은 Linux 배포판에서는 shmem_enabled를 'never'로 설정하여 -XX:+UseTransparentHugePages를 사용하는 경우 ZGC가 거대 페이지를 사용하지 못하게 만듭니다.\n\n이렇게 변경된 부분을 제외하고 아무런 변경 없이 배포된 서비스가 있습니다. shmem_enabled가 'never'에서 'advise'로 변경되면 CPU 사용률이 저하되었습니다.\n\n아래는 기본 구성입니다:\n\n![이미지](/assets/img/2024-05-17-BendingpausetimestoyourwillwithGenerationalZGC_4.png)\n\n저희의 기본 구성:\n\n<div class=\"content-ad\"></div>\n\n- 힙의 최소 및 최대를 같은 크기로 설정합니다.\n- -XX:+UseTransparentHugePages -XX:+AlwaysPreTouch을 구성합니다.\n- 다음과 같은 transparent_hugepage 구성을 사용합니다:\n\n```js\necho madvise | sudo tee /sys/kernel/mm/transparent_hugepage/enabled\necho advise | sudo tee /sys/kernel/mm/transparent_hugepage/shmem_enabled\necho defer | sudo tee /sys/kernel/mm/transparent_hugepage/defrag\necho 1 | sudo tee /sys/kernel/mm/transparent_hugepage/khugepaged/defrag\n```\n\n# 어떤 워크로드가 적합하지 않았나요?\n\n가장 좋은 가비지 컬렉터는 없습니다. 각각은 가비지 컬렉터의 목표에 따라 콜렉션 처리량, 응용프로그램 대기 시간 및 자원 이용을 교환합니다.\n\n<div class=\"content-ad\"></div>\n\nG1 대비 ZGC에서 더 나은 성능을 보인 작업 부하들은 대부분 처리량을 중심으로 한 경향이 있습니다. 매우 변덕스러운 할당 속도와 예측할 수 없는 기간 동안 객체를 보유하는 장기 실행 작업들이 포함되어 있습니다.\n\n한 가지 주목할만한 예시는 매우 변덕스러운 할당 속도와 많은 수의 고수명 객체를 가진 서비스였는데, 이는 G1의 일시 중지 시간 목표와 오래된 영역 수집 휴리스틱에 특히 적합했습니다. G1이 ZGC가 처리하지 못한 GC 사이클의 비생산적인 작업을 피할 수 있게 해주었습니다.\n\n기본적으로 ZGC로 전환함으로써 응용프로그램 소유자들이 가비지 수집기의 선택에 대해 고민할 수 있는 좋은 기회가 제공되었습니다. G1을 기본으로 사용하던 여러 배치/준비 계산 사례들이 병렬 수집기로부터 더 나은 처리량을 얻었을 것입니다. 대규모 준비 계산 작업에서는 G1 대비 응용프로그램 처리량이 6~8% 향상되어 배치 시간이 한 시간 단축되는 것을 확인할 수 있었습니다.\n\n# 직접 해보세요!\n\n<div class=\"content-ad\"></div>\n\n가정과 기대를 의심하지 않으면, 우리는 10년 동안 우리의 운영 기본 설정 중 가장 영향력 있는 변화 중 하나를 놓치게 될 수 있습니다. 우리는 여러분께 직접 제너레이셔널 ZGC를 시도해 보라고 권장합니다. 여러분에게 우리가 놀란 만큼 놀라운 경험을 줄 수도 있습니다.","ogImage":{"url":"/assets/img/2024-05-17-BendingpausetimestoyourwillwithGenerationalZGC_0.png"},"coverImage":"/assets/img/2024-05-17-BendingpausetimestoyourwillwithGenerationalZGC_0.png","tag":["Tech"],"readingTime":6},{"title":"4월에는 거래소와 사기로 인해 25백만의 피해를 입었다고 합니다 이는 역사적으로 최저치를 기록했습니다 CertiK가 밝혔습니다","description":"","date":"2024-05-01 18:18","slug":"2024-05-01-Aprilsees25MinexploitsandscamsmarkinghistoriclowCertiK","content":"\n\n![CertiK Thumbnail](/assets/img/2024-05-01-Aprilsees25MinexploitsandscamsmarkinghistoriclowCertiK_thumbnail.png)\n\n2022년 이래 최저 수준까지 감소한 해킹과 사기로 인한 손실이 CertiK가 데이터를 기록하기 시작한 이후로 낮아졌습니다. 4월 30일에 Cointelegraph에 공개된 CertiK의 보고서에 따르면, 이번 달에는 약 25.7백만 달러의 공격으로 인한 손실만이 있었는데, 이는 지난 2021년 이후로 최저액입니다.\n\n이 보고서에 따르면, 해킹, 악용 및 사기로 인한 손실이 지난 달에 비해 141% 줄었습니다. 이 감소의 주요 이유는 개인 키의 침해가 없었기 때문입니다. 3월에는 개인 키 침해로 인한 프로토콜에 대한 11차 공격이 있었지만, 4월에는 이보다 적은 3차 공격만 있었습니다.\n\n\n\n![image](/assets/img/2024-05-01-Aprilsees25MinexploitsandscamsmarkinghistoriclowCertiK_0.png)\n\n암호화폐 사용자들에게 좋은 소식이 있는 가운데, 이번 달 동안 몇 가지 주목할 만한 해킹과 사기 사건이 손실을 야기했습니다. Memecoin Condom은 \"솔라나 네트워크에 프리세일 주소를 광고했었는데,\" 이는 알지 못하는 사용자들로부터 자금을 빼앗는 데 사용되었습니다. 이 공격으로 약 933,000달러의 암호화폐가 손실되었습니다.\n\n비트코인 라이트닝 네트워크 거래소인 FixedFloat는 4월 1일 큰 해킹 사고를 당해 약 3백만 달러가 탈취당했습니다. 이는 FixedFloat가 2024년에 공격을 받는 두 번째 경우였습니다. 이전 사건은 2월에 발생했습니다.\n\n이번 달에 보고된 총 25.7백만 달러의 손실 가운데 상당 부분인 21백만 달러가 exploits에 속했으며, 이 가운데 3건의 공격은 각각 1백만 달러 이상의 피해를 야기했습니다. 플래시 대출 공격으로 인한 손실은 12만 9천 달러로, 가장 큰 한 건은 5천 5백 달러의 피해를 발생시켰습니다. CertiK에 따르면, 이는 2022년 2월 이후 플래시 대출 공격 발생 건수가 가장 적은 것을 의미합니다. 또한, 13건의 종료 사기 사건이 있었는데, 이는 3월 대비 40% 감소한 수치입니다.\n\n\n\nCertiK는 이러한 숫자에 ZKasino를 포함시키지 않았다고 밝혔습니다. 해당 프로젝트는 투자자가 예금한 자금을 인출할 수 없도록 막은 사례입니다. 보고서는 이 프로젝트를 \"논란의 중심\"으로 보지만 아직 사기로 지칭하진 않았습니다. 보안 플랫폼은 ZKasino가 악의적인 행동을 한다는 것이 확인되면 수치를 업데이트할 것이라고 주장했습니다. ZKasino는 4월 22일 자금을 Lido 프로토콜로 옮겼으며, 많은 사용자들을 분노시켰습니다.\n\nCertiK의 보고서 발표 직후, 탈중앙화 금융 앱 Yield Protocol이 18만 1,000달러에 이르는 금액으로 공격을 받았습니다. 개발자가 공식적으로 폐쇄한 Yield이지만, 스마트 계약의 변경할 수 없는 특성으로 일부 사용자는 여전히 상호 작용할 수 있습니다.\n\n매거진: DeFi의 10억 달러 비밀: 해킹에 책임 있는 내부자들","ogImage":{"url":"/assets/img/2024-05-01-Aprilsees25MinexploitsandscamsmarkinghistoriclowCertiK_thumbnail.png"},"coverImage":"/assets/img/2024-05-01-Aprilsees25MinexploitsandscamsmarkinghistoriclowCertiK_thumbnail.png","tag":["Tech"],"readingTime":2}],"page":"61","totalPageCount":61,"totalPageGroupCount":4,"lastPageGroup":1,"currentPageGroup":3},"__N_SSG":true}