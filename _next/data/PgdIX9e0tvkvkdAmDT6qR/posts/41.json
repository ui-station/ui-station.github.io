{"pageProps":{"posts":[{"title":"라즈베리 파이 웹사이트 만들기","description":"","date":"2024-05-18 19:11","slug":"2024-05-18-CreatingaRaspberryPIWebsite","content":"\n\n아래는 메인 시리즈 \"Hackable Lego Train\"의 미니 파트입니다. \n\n다음은 메인 시리즈를 확인할 수 있는 링크입니다: \n\nHackable Lego Train | Part 1 | Stux | 작성자: Stux | 2024년 5월 | Medium\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-05-18-CreatingaRaspberryPIWebsite_1.png\" />\n\n프로젝트의 아이디어는 열차 해킹을 시뮬레이션하고 운영 기술 환경에서 취약한 애플리케이션과 관련된 전반적인 사이버 위험을 보여주는 것입니다.\n\n그러니까 PI에 간단한 웹사이트를 만든 방법에 대해 설명해드릴게요.\n\n전체적인 단계는 다음과 같습니다:\n\n<div class=\"content-ad\"></div>\n\n- 새로운 OS(Kali)로 Pi 이미지 다시 만들기\n- Pi에서 SSH 활성화\n- 웹 사이트를 위한 폴더 디렉토리 생성\n- 웹 사이트를 위한 파일 구성\n- 웹 사이트에 로깅 추가\n\n시작해 보세요!\n\n주 컴퓨터에서 라즈베리 파이 이미지 소프트웨어를 다운로드하고 설치하세요.\n\n라즈베리 파이 OS — 라즈베리 파이\n\n<div class=\"content-ad\"></div>\n\n![Creating a Raspberry PI Website Image 2](/assets/img/2024-05-18-CreatingaRaspberryPIWebsite_2.png)\n\n라즈베리 파이에 Kali를 설치하고 싶었어요.\n\n- 저는 Kali를 잘 알고 있고 손에 익숙해요.\n- 이 프로젝트 이외에도 네트워크 침투 분야에서 다른 계획이 있어요.\n- 어차피 해킹 프로젝트니까 나에게 가장 쉽게 만들어야겠죠 :)\n\n![Creating a Raspberry PI Website Image 3](/assets/img/2024-05-18-CreatingaRaspberryPIWebsite_3.png)\n\n<div class=\"content-ad\"></div>\n\n호스트 컴퓨터에 PI SD 카드를 넣어주세요. 그리고 카드에 Kali를 WRITE해주세요.\n\n작업이 끝나면 SD 카드를 PI에 다시 넣고 부팅해주세요.\n\n원하는 방식으로 Kali를 설정하고 따라가보세요.\n\n로그인하세요!\n\n<div class=\"content-ad\"></div>\n\n여기서부터는 SSH를 사용해서 작업을 계속합니다. 그래서 셸 명령어에 익숙하신 것 같아요.\n\n![CreatingaRaspberryPIWebsite_4](/assets/img/2024-05-18-CreatingaRaspberryPIWebsite_4.png)\n\n새 시스템에 SSH로 접속한 후, 먼저 웹사이트 디렉토리 구조를 만들고 싶어요.\n\n![CreatingaRaspberryPIWebsite_5](/assets/img/2024-05-18-CreatingaRaspberryPIWebsite_5.png)\n\n<div class=\"content-ad\"></div>\n\n아래는 제 예시입니다:\n\n```js\nbig_cabooses/\n│\n├── static/\n│   └── css/\n│       └── styles.css\n│   └── images/\n│       └── background.jpg\n├── templates/\n│   └── index.html\n├── app.py\n└── train_schedule.py\n```\n\napp.py 파일을 편집하여 다음 내용을 추가하십시오:\n\n```js\nfrom flask import Flask, render_template\nfrom train_schedule import get_train_schedule\n\napp = Flask(__name__)\n\n@app.route('/')\ndef home():\n    schedule = get_train_schedule()\n    return render_template('index.html', schedule=schedule)\n\nif __name__ == '__main__':\n    app.run(debug=True)\n```\n\n<div class=\"content-ad\"></div>\n\n```python\ndef get_train_schedule():\n    return [\n        {\"time\": \"07:00 AM\", \"train\": \"천년비행선\", \"destination\": \"타투인\"},\n        {\"time\": \"09:00 AM\", \"train\": \"데스스타\", \"destination\": \"엔도어\"},\n        {\"time\": \"11:00 AM\", \"train\": \"X-윙\", \"destination\": \"야빈 4\"},\n        {\"time\": \"01:00 PM\", \"train\": \"TIE 전투기\", \"destination\": \"호스\"},\n        {\"time\": \"03:00 PM\", \"train\": \"제국 셔틀\", \"destination\": \"코르서캔트\"},\n        {\"time\": \"05:00 PM\", \"train\": \"슬레이브 1\", \"destination\": \"카미노\"},\n        {\"time\": \"07:00 PM\", \"train\": \"나부 스타파이터\", \"destination\": \"나부\"},\n    ]\n```\n\ntemplates/index.html 수정:\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Big Cabooses</title>\n    <link rel=\"stylesheet\" href=\"{{ url_for('static', filename='css/styles.css') }}\">\n</head>\n<body>\n    <div class=\"background\"></div>\n    <div class=\"content\">\n        <h1>Big Cabooses 열차 일정</h1>\n        <table>\n            <thead>\n                <tr>\n                    <th>시간</th>\n                    <th>열차</th>\n                    <th>목적지</th>\n                </tr>\n            </thead>\n            <tbody>\n                {% for entry in schedule %}\n                <tr>\n                    <td>{{ entry.time }}</td>\n                    <td>{{ entry.train }}</td>\n                    <td>{{ entry.destination }}</td>\n                </tr>\n                {% endfor %}\n            </tbody>\n        </table>\n    </div>\n</body>\n</html>\n```\n\n<div class=\"content-ad\"></div>\n\nstatic/css/styles.css 파일에 다음 내용을 입력해주세요:\n\n```js\nbody, html {\n    height: 100%;\n    margin: 0;\n    font-family: Arial, sans-serif;\n}\n\n.background {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    background-image: url(\"../images/background.jpg\");\n    background-size: cover;\n    background-position: center;\n    z-index: -1;\n    opacity: 0.5;\n}\n\n.content {\n    position: relative;\n    z-index: 1;\n    padding: 20px;\n    background-color: rgba(255, 255, 255, 0.8);\n    border-radius: 10px;\n    max-width: 600px;\n    margin: auto;\n    top: 50%;\n    transform: translateY(-50%);\n    text-align: center;\n}\n\ntable {\n    width: 100%;\n    border-collapse: collapse;\n}\n\nth, td {\n    padding: 10px;\n    border: 1px solid #ddd;\n    text-align: left;\n}\n\nth {\n    background-color: #f2f2f2;\n}\n```\n\nstatic/background.jpg의 경로에 매력적인 배경 이미지를 업로드해주세요.\n\nChatGPT를 이용하여 스스로 이미지를 만들 수 있게 위해서 돈을 지불했어요. 여러분도 자금이 있으시다면 강력히 추천합니다.\n\n<div class=\"content-ad\"></div>\n\n웹사이트를 시작하세요!\n\n```js\nsudo python3 app.py\n```\n\n브라우저를 열고 127.0.0.1:5000으로 이동하세요\n\nBUTTT!!!!\n\n<div class=\"content-ad\"></div>\n\n우리는 로깅을 추가하고 내부 네트워크의 다른 컴퓨터에서 액세스할 수 있는 기능을 추가하길 원해요.\n\n이를 위해 하나 해야 할 일은 우리의 app.py 파일을 변경하는 것뿐입니다:\n\n```js\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=5000, debug=True)\n```\n\n반드시 \"host=\"에 PI의 IP를 넣어 주세요!!!!\n\n<div class=\"content-ad\"></div>\n\n이제 웹 사이트에 로그 파일을 기록하려고 합니다. app.py 파일에 이 모든 내용을 추가해 보겠습니다:\n\n```python\nfrom flask import Flask, render_template\nfrom train_schedule import get_train_schedule\nimport logging\n\napp = Flask(__name__)\n\n# 로깅 설정\nlogging.basicConfig(filename='app.log', level=logging.DEBUG,\n                    format='%(asctime)s %(levelname)s %(name)s %(threadName)s : %(message)s')\n\n@app.route('/')\ndef home():\n    app.logger.info(\"홈 페이지에 접근했습니다.\")\n    schedule = get_train_schedule()\n    return render_template('index.html', schedule=schedule)\n\n@app.route('/error')\ndef error():\n    app.logger.error(\"이것은 오류 예제입니다.\")\n    return \"오류 예제\", 500\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=5000, debug=True)\n```\n\n이제 /big-cabooses/ 메인 디렉토리에 app.log라는 파일이 생기게 됩니다.\n\n그런 다음, 간단한 접속 로그가 포함된 스타워즈 테마의 레고 기차 웹 사이트를 만들었습니다. 함께 빌드하는 과정을 즐겼습니다!\n\n<div class=\"content-ad\"></div>\n\n어떤 질문이든 하시거나 도움이 필요하시면 언제든지 메시지를 보내주세요. 즐겁게 즐기세요! 이것을 하면서 몇 번 굳었지만, 마침내 성공적으로 해냈고 결과물을 좋아합니다. -Stux","ogImage":{"url":"/assets/img/2024-05-18-CreatingaRaspberryPIWebsite_0.png"},"coverImage":"/assets/img/2024-05-18-CreatingaRaspberryPIWebsite_0.png","tag":["Tech"],"readingTime":6},{"title":"라즈베리 파이로 쿠버네티스 클러스터 구축 가이드","description":"","date":"2024-05-18 19:08","slug":"2024-05-18-AGuidetoBuildingaKubernetesClusterwithRaspberryPis","content":"\n\n몇 년 전에 라즈베리 파이에서 Kubernetes 클러스터를 세팅했었어요. 당시 라즈베리 파이의 ARM 아키텍처는 몇 가지 어려움을 야기했죠. ARM을 지원하는 애플리케이션을 찾는 건 어려운 과제였는데, 그래서 필요한 애플리케이션과 컨테이너를 직접 빌드해야 했던 적이 많았어요.\n\n그런데 그 이후로 상황이 크게 개선되었어요! 새로운 64비트 라즈베리 파이 OS의 등장과 ARM의 저렴함으로 클라우드 배포에 많이 사용되는 산업에서의 인기 상승으로, 라즈베리 파이 클러스터 구축이 훨씬 간단해졌어요. 저는 클러스터를 다시 구축하기로 결정했고, 64비트 OS 및 최신 버전의 Kubernetes와 Docker로 업데이트했어요.\n\n여러분이 자체 라즈베리 파이 Kubernetes 클러스터를 설정하는 방법에 대한 가이드를 작성했어요. 집에서 클러스터를 구축하는 여정에 유용하길 바랍니다! 🚀\n\n# 요구 사항\n\n<div class=\"content-ad\"></div>\n\n클러스터를 설정하기 위해서는 하드웨어가 필요합니다. 필요한 것들은 다음과 같아요:\n\n- 라즈베리 파이(저는 4 모델 B를 사용했어요)\n- SD 카드 1장 / 라즈베리 파이\n- 이더넷 케이블 1개 / 라즈베리 파이\n- 라우터 및/또는 네트워크 스위치\n- USB 허브\n- (선택 사항) 케이스\n\n이 안내서는 Kubernetes 1.26.6, Docker 24.0.2 및 라즈베리 파이 Lite(64비트) 불자이에 맞춰 작성되었어요.\n\n# OS 설정\n\n<div class=\"content-ad\"></div>\n\n첫 번째 단계는 모든 Raspberry Pi에 OS를 설정해야 합니다. 그렇지 않으면 Raspberry Pi는 기본적으로 부팅할 시스템이 없습니다.\n\nRaspberry Pi Imager를 다운로드하십시오. 이 편리한 애플리케이션은 Raspberry Pi의 다운로드와 플래싱에 사용됩니다. 이 가이드에서는 Raspberry Pi OS (Debian의 파생 버전)의 64비트 헤드리스 버전을 사용할 것입니다.\n\n최신 Raspberry Pi와 호환되는지 확인한 후에 SD 카드를 플래싱해야 합니다. \n\n![Raspberry Pi Imager](/assets/img/2024-05-18-AGuidetoBuildingaKubernetesClusterwithRaspberryPis_0.png)\n\n<div class=\"content-ad\"></div>\n\nSD 카드를 선택하고 OS를 플래싱하기 시작하세요. 모든 SD 카드에 대해 이 작업을 완료할 때까지 반복해주세요.\n\n## SSH 활성화 및 기본 사용자 생성\n\n각 Pi를 원격으로 구성할 수 있게끔 SSH를 설정해야 합니다.\n\nSSH를 활성화하려면 SD 카드의 부트 파티션에 확장자 없이 ssh라는 빈 파일을 생성하세요.\n\n<div class=\"content-ad\"></div>\n\n로그인 사용자를 설정하기 위해, SD 카드의 부팅 파티션에 userconf라는 파일을 생성하세요. 이 파일은 'name':'encrypted-password'로 구성된 텍스트 한 줄을 포함해야 합니다. 로그인 사용자로 노드를 사용했지만 원하는 대로 사용하셔도 됩니다.\n\nencrypted-password를 생성하려면 다음 명령을 OpenSSL과 함께 실행하세요:\n\n```js\necho '{password}' | openssl passwd -6 -stdin\n```\n\n파일을 저장하고 SD 카드를 제거하세요. 그리고 라즈베리 파이에 SD 카드를 삽입하고 전원을 켜세요. 개인 네트워크의 라우터나 네트워크 스위치에 연결되어 있는지 확인하세요.\n\n<div class=\"content-ad\"></div>\n\n# 첫 번째 부팅 및 초기 구성\n\n라즈베리 파이의 IP를 얻어야 합니다. 이를 위해 라우터를 확인할 수 있습니다. 제 경우, OpenWrt를 사용하며 DHCP 설정에서 기억하기 쉬운 정적 IP를 만듭니다.\n\n![image](/assets/img/2024-05-18-AGuidetoBuildingaKubernetesClusterwithRaspberryPis_1.png)\n\n첫 번째 노드에 SSH로 연결합니다. 이 노드는 클러스터의 제어 평면을 실행하는 마스터 노드가 됩니다. 라즈베리 파이로 터널링한 후에 설정을 시작할 수 있습니다!\n\n<div class=\"content-ad\"></div>\n\n다음 명령어를 사용하여 사용자를 sudo 그룹에 추가해주세요.\n\n```js\nsudo usermod -aG sudo node\n```\n\n이제 rasp-config를 업데이트하여 node 사용자로 자동 부팅하도록 설정해봅시다.\n\n```js\nsudo raspi-config\n```\n\n<div class=\"content-ad\"></div>\n\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*XG-oT3YeryzngA-Xv3JY9w.gif)\n\n“System Options” → “Boot / Auto Login” 으로 이동하여 “Console Autologin”을 선택해주세요.\n\n# Docker & Kubernetes 초기 설정\n\n기본적으로 cgroup 메모리 옵션이 비활성화되어 있으므로 Docker가 메모리 사용량을 제한할 수 있도록 업데이트해야 합니다. /boot/cmdline.txt를 열고 cgroup_enable=memory cgroup_memory=1을 추가해주세요.\n\n\n<div class=\"content-ad\"></div>\n\n이제 우리의 apt 저장소를 업데이트하고 Kubernetes 저장소를 포함시킬 차례입니다.\n\n```js\ncurl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add -\necho \"deb http://apt.kubernetes.io/ kubernetes-xenial main\" | sudo tee -a /etc/apt/sources.list.d/kubernetes.list\nsudo apt update && sudo apt upgrade -y\n```\n\nDocker 설치:\n\n```js\ncurl -sSL https://get.docker.com | sh\nsudo usermod -aG docker node\n```\n\n<div class=\"content-ad\"></div>\n\nKubernetes 1.20부터는 dockershim이 폐기되고 있습니다. Mirantis에서 제공하는 cri-dockerd라는 클러스터용 오픈 소스 CRI를 사용할 수 있습니다. cri-dockerd를 설치하고 서비스를 설정하려면 다음 명령을 실행하세요:\n\n```js\nwget https://github.com/Mirantis/cri-dockerd/releases/download/v0.3.4/cri-dockerd-0.3.4.arm64.tgz\ntar -xvzf cri-dockerd-0.3.4.arm64.tgz\nsudo mv cri-dockerd/cri-dockerd /usr/bin/cri-dockerd\nsudo chmod +x /usr/bin/cri-dockerd\nwget https://raw.githubusercontent.com/Mirantis/cri-dockerd/master/packaging/systemd/cri-docker.service\nwget https://raw.githubusercontent.com/Mirantis/cri-dockerd/master/packaging/systemd/cri-docker.socket\nsudo mv cri-docker.service /etc/systemd/system/\nsudo mv cri-docker.socket /etc/systemd/system/\nsudo systemctl enable cri-docker.service\nsudo systemctl enable cri-docker.socket\nsudo systemctl start cri-docker.service\nsudo systemctl start cri-docker.socket\n```\n\nKubernetes 스케줄러를 위해 노드에서 swap을 비활성화하는 것이 권장됩니다.\n\n```js\nsudo apt-get update && sudo apt-get install dphys-swapfile && sudo dphys-swapfile swapoff && sudo dphys-swapfile uninstall && sudo systemctl disable dphys-swapfile\n```\n\n<div class=\"content-ad\"></div>\n\n만약 cri-dockerd 설정에 문제가 발생하면, 이 안내서를 확인해보세요. 처음에 작성했을 때와 달라진 사항이 있을 수 있어요.\n\n마지막으로, Kubernetes를 설치해봅시다!\n\n```js\nsudo apt install -y kubelet=1.26.6-00 kubeadm=1.26.6-00 kubectl=1.26.6-00\nsudo apt-mark hold kubelet kubeadm kubectl\n```\n\n이 가이드에서는 모든 것이 1.26.6에서 작동하는지 테스트했어요. 1.24 이전 버전은 정상적으로 작동하지 않을 거예요. 이러한 패키지를 업데이트되지 않도록 표시할 거에요.\n\n<div class=\"content-ad\"></div>\n\n차선으로, 랜처 랩스에서 만든 k3s는 가벼운 옵션으로 좋은 선택일 것입니다. 그 중 일부 장점은 작은 실행 파일 크기, 매우 낮은 자원 요구 사항 및 ARM용으로 최적화되어 있다는 것입니다. 이 가이드에서는 이를 테스트해보지 않았지만, 이후에 비슷한 설정이 될 것으로 생각합니다.\n\n이제 클러스터를 초기화할 시간입니다. 이를 위해 InitConfiguration 및 ClusterConfiguration 설정이 포함된 파일을 만들겠습니다.\n\n```js\napiVersion: kubeadm.k8s.io/v1beta3\nbootstrapTokens:\n- groups:\n  - system:bootstrappers:kubeadm:default-node-token\n  token: {token}\n  usages:\n  - signing\n  - authentication\nkind: InitConfiguration\nlocalAPIEndpoint:\n  advertiseAddress: 10.0.0.100\n  bindPort: 6443\nnodeRegistration:\n  criSocket: unix:///var/run/cri-dockerd.sock\n  imagePullPolicy: IfNotPresent\n  name: node-0\n---\napiVersion: kubeadm.k8s.io/v1beta3\nkind: ClusterConfiguration\nnetworking:\n  podSubnet: \"10.244.0.0/16\" # --pod-network-cidr\n```\n\n이 파일에는 마스터 노드의 설정이 포함되어 있습니다. criSocket이 cri-dockerd를 사용하고, 나중에 네트워크 CIDR을 설정해두었음을 주목하십시오.\n\n<div class=\"content-ad\"></div>\n\n이 노드에서 제어 평면을 초기화하려면 다음을 실행하세요.\n\n```js\nsudo kubeadm init --config kubeadm-config.yaml\n```\n\n이 명령은 새 노드를 클러스터에 추가하는 설정 및 kube-config를 설정하는 방법을 보여줍니다.\n\n명령에서 지시하는 방법에 따라 kube-config를 설정하고, 워크스테이션에 kube-config와 가입 명령을 복사하고 저장하세요. 나중에 필요할 것이니까요!\n\n<div class=\"content-ad\"></div>\n\n# 클러스터 네트워킹\n\n이제 클러스터에서 네트워킹을 설정해야 합니다. Pod들이 노드 간에 서로 통신할 수 있도록 하려면 네트워크 플러그인 (CNI 또는 컨테이너 네트워크 인터페이스로도 불림)이 필요합니다.\n\n네트워크 플러그인은 IP 주소 할당, DNS 해결 및 네트워크 격리와 같은 기능을 Pod에 제공합니다.\n\n우리는 이를 위해 Flannel을 사용할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n마스터 노드에서 다음을 실행해 주세요.\n\n```js\nkubectl apply -f https://github.com/flannel-io/flannel/releases/latest/download/kube-flannel.yml\n```\n\n그게 다에요! 이제 마스터 노드가 완료되었으니, 클러스터에 새 노드를 추가하기 시작할 수 있어요. 이전에 출력된 조인 명령을 기억하고 있나요? 이제 그것이 필요할 거에요.\n\n# 클러스터에 새로운 노드 추가하기\n\n<div class=\"content-ad\"></div>\n\n클러스터에 새 노드를 추가하는 것은 꽤 간단합니다. 많은 노드를 추가하는 경우에는 tmux와 같은 도구를 사용하여 세션 명령을 다중화하는 것이 좋습니다.\n\n\"첫 번째 부팅 및 초기 설정\"을 완료하고 \"도커 및 쿠버네티스 초기 설정\"을 진행하세요. 서로 다른 Kubernetes 구성 요소를 설치하는 단계 이후에 작업을 중지하세요. 이 시점에서 이전에 실행한 kubeadm join 명령을 실행해야 합니다. cri-socket 및 node-name 옵션을 포함하여 실행해 주세요. \n\n```js\nsudo kubeadm join 10.0.0.100:6443 --token {token} --discovery-token-ca-cert-hash {hash} --cri-socket unix:///var/run/cri-dockerd.sock --node-name {name}\n```\n\n이제 마스터 노드에서 클러스터를 모니터링하고 모든 노드가 클러스터에 가입하는지 확인하세요.\n\n<div class=\"content-ad\"></div>\n\n```js\n> kubectl get nodes를 watch합니다.\n이제 귀하의 클러스터가 사용할 준비가 되었습니다! 그러나 SSH를 통해가 아닌 워크스테이션에서 액세스하고 싶을 것입니다. 컴퓨터에서 이전에 설정한 kube-config를 설정할 수 있습니다.\n\n기본 kube-config는 관리자 권한을 부여하며 다른 사람과 공유해서는 안됩니다.\n\n먼저 프로필에 구성을 내보냅니다.\n```\n\n<div class=\"content-ad\"></div>\n\n```js\nexport KUBECONFIG=~/.kube/config\n```\n\n컨텍스트 설정:\n\n```js\nkubectl config use-context kubernetes-admin@kubernetes\n```\n\n이제 원격으로 클러스터에 액세스할 수 있어야 합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n> kubectl cluster-info\n쿠버네티스 제어 평면이 https://10.0.0.100:6443 에서 실행 중입니다.\nCoreDNS이 https://10.0.0.100:6443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy 에서 실행 중입니다.\n\n더 많은 디버깅 및 진단을 위해 'kubectl cluster-info dump'를 사용하세요.\n```\n\n# 도구 설정\n\n이제 밴자이라 클러스터를 일반에서 멋지게 업그레이드해 봅시다. 새 응용 프로그램을 쉽게 배포하고 클러스터를 모니터링할 수 있는 몇 가지 널리 사용되는 도구를 설정해 보겠습니다. 여기서 ArgoCD, Prometheus 및 Grafana 설치 방법을 안내하겠습니다! 이 세 가지 오픈소스 프로젝트가 우리의 클러스터를 다음 수준으로 끌어올립니다.\n\n계속하기 전에, 이러한 도구들에 대한 모든 설정 변경 사항을 추적하기 위한 원격 git 저장소를 만들어 보시기를 권장합니다. 특히 ArgoCD를 사용할 때, 각 도구나 추가 응용 프로그램을 배포할 때마다 거기를 통해 추가합니다.```\n\n<div class=\"content-ad\"></div>\n\n# ArgoCD\n\n각 도구에 대해 Helm을 리소스 템플릿팅 도구로 사용할 것입니다. 최신 버전(또는 적어도 Helm v3)을 설치하고 ArgoCD 저장소를 추가해 봅시다.\n\n```js\nhelm repo add argo https://argoproj.github.io/argo-helm\n```\n\nValues 파일을 생성하세요.\n\n<div class=\"content-ad\"></div>\n\n```yaml\nserver:\n  serviceType: NodePort\n  httpNodePort: 30080\n  httpsNodePort: 30443\n```\n\n이 파일은 차트의 설정 중 하나를 재정의하는 데 사용할 수 있습니다. 이 경우에는 서비스를 ClusterIP 대신 NodePort로 실행하도록 변경하고 있습니다. 이렇게 하면 클러스터에서 지정한 포트를 외부에서 엑세스할 수 있도록 하여 리버스 프록시를 사용하지 않고도 개인 네트워크에서 해당 서비스에 액세스할 수 있습니다.\n\n서비스를 설치하십시오.\n\n```js\nhelm install argocd -n argocd -f values.yaml argo/argocd\n```\n\n<div class=\"content-ad\"></div>\n\n그럼 관리자 사용자의 기본 암호를 가져와야 합니다.\n\n```js\nkubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath=\"{.data.password}\" | base64 -d\n```\n\nOpenWrt를 사용하고 있기 때문에 클러스터에 호스트 이름 항목을 설정하고 https://cluster.home:30443에서 로그인 페이지에 액세스할 수 있습니다.\n\n![그림](/assets/img/2024-05-18-AGuidetoBuildingaKubernetesClusterwithRaspberryPis_2.png)\n\n<div class=\"content-ad\"></div>\n\nArgoCD에 로그인하고, 곧 돌아올게요.\n\n![image](/assets/img/2024-05-18-AGuidetoBuildingaKubernetesClusterwithRaspberryPis_3.png)\n\n# Prometheus\n\n우리는 클러스터에 대한 정보 수집을 위해 타임 시리즈 메트릭 서버로 Prometheus를 사용할 거에요.\n\n<div class=\"content-ad\"></div>\n\n설치하기 전에 Prometheus가 쿼리 데이터를 저장할 지속적인 볼륨을 설정해야 합니다. 집 클러스터에서는 예비 USB 드라이브를 사용하기로 결정했지만 원하는 것을 연결하여 사용할 수 있습니다.\n\n마스터 노드에서 볼륨을 설정한 단계는 다음과 같습니다. 우리의 볼륨을 위한 경로를 만들고 실수를 막기 위해 변경 사항을 반영해야 할 fstab의 백업을 만듭니다.\n\n```js\nsudo mkdir /mnt/usb\nsudo cp /etc/fstab /etc/fstab.bak\n```\n\n장치를 연결한 다음 fstab을 변경 내용과 함께 수정합니다.\n\n<div class=\"content-ad\"></div>\n\n```md\n/dev/sda1 /mnt/usb vfat defaults,uid=youruid,gid=yourgid,dmask=002,fmask=113 0 0\n```\n\n이제 우리 노드 사용자의 사용자 및 그룹 설정으로 장치를 마운트합니다.\n\n```md\nsudo mount -o uid=youruid,gid=yourgid,dmask=002,fmask=113 /dev/sdX1 /mnt/usb\n```\n\n이제 우리는 PersistentVolume과 PersistentVolumeChain을 가진 Kubernetes 자원을 생성하려고 합니다.\n \n\n<div class=\"content-ad\"></div>\n\n```yaml\napiVersion: v1\nkind: PersistentVolume\nmetadata:\n  name: prometheus-usb-pv\n  labels:\n    type: local\nspec:\n  storageClassName: manual\n  capacity:\n    storage: {device의 크기}Gi\n  accessModes:\n    - ReadWriteOnce\n  persistentVolumeReclaimPolicy: Retain\n  hostPath:\n    path: \"/mnt/usb\"\n---\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: prometheus-usb-pvc\nspec:\n  storageClassName: manual\n  accessModes:\n    - ReadWriteOnce\n  resources:\n    requests:\n      storage: {device의 크기}Gi\n```\n\n만약 git 리포지토리를 사용 중이라면, 이 파일들을 template 디렉토리 안에 새로운 Helm Chart에 위치시켜주세요. 다음 단계를 따라 계속 진행해봐요.\n\n이제 프로메테우스와 함께 차트를 설정해봅시다.\n\n```bash\nhelm create prometheus\n```\n\n<div class=\"content-ad\"></div>\n\nChart.yaml에 Prometheus subchart를 종속성으로 추가해주세요.\n\n```yaml\ndependencies:\n  - name: prometheus\n    version: 22.7.0\n    repository: https://prometheus-community.github.io/helm-charts\n```\n\n이제 새 PV 및 PVC를 사용하도록 구성을 설정하고, 일부 권한을 수정하고 서버를 마스터 노드에만 배포하도록 확인할 수 있습니다.\n\n```yaml\nprometheus:\n  alertmanager:\n    enabled: false\n  prometheus-pushgateway:\n    enabled: false\n  configmapReload:\n    prometheus:\n      enabled: false\n  server:\n    nodeSelector:\n      kubernetes.io/hostname: {master node}\n    securityContext:\n      runAsUser: {userid}\n      runAsNonRoot: true\n      runAsGroup: {groupid}\n      fsGroup: {fsid}\n    persistentVolume:\n      enabled: true\n      existingClaim: \"prometheus-usb-pvc\"\n      volumeName: \"prometheus-usb-pv\"\n```\n\n<div class=\"content-ad\"></div>\n\n일부 추가 서비스를 비활성화합니다. 예를 들어 alertmanager, pushgateway, 그리고 configmapreload가 이에 해당합니다. 필요한 경우 다른 시간에 이를 활성화할 수 있습니다. 비정상적으로 행동하는 경우 알림을 받을 수 있는 유용한 도구인 Alert Manager입니다.\n\n이제 ArgoCD로 돌아가 \"새 앱\"을 만들어보겠습니다. Prometheus라는 이름의 앱을 만들고 깃 레포지토리를 소스로 추가하고 경로를 선택하세요. Grafana도 나중에 이 작업을 해야하므로 서로 다른 경로에 유지하세요.\n\n\n![Image](/assets/img/2024-05-18-AGuidetoBuildingaKubernetesClusterwithRaspberryPis_4.png)\n\n\n생성한 사용자 정의 설정을 설정할 값 파일을 선택한 다음 앱을 생성하세요. 수동으로 동기화하도록 지정한 경우 동기화가 필요할 때 이를 수행해야 합니다. 이것은 업그레이드할 때 사용하거나 수동으로 릴리스하고자 할 때 유용합니다. 그 외에는 홈 프로젝트에 가장 적합한 CD용 자동 동기화 방법이 유용합니다.\n\n<div class=\"content-ad\"></div>\n\n\n![Grafana](https://miro.medium.com/v2/resize:fit:1400/1*Ice0ZJGARkN6BdzAl1nGDQ.gif)\n\n마찬가지로 Prometheus와 비슷하게, git 레포지토리에서 새로운 Helm 차트를 생성하는 것부터 시작해보세요.\n\n```js\nhelm create grafana\n```\n\n<div class=\"content-ad\"></div>\n\n헬름 리포지토리를 추가해주세요.\n\n```js\nhelm repo add grafana https://grafana.github.io/helm-charts\nhelm repo update\n```\n\n리포지토리를 통해 차트를 업데이트하세요.\n\n```js\ndependencies:\n  - name: grafana\n    version: 6.57.4\n    repository: https://grafana.github.io/helm-charts\n```\n\n<div class=\"content-ad\"></div>\n\nvalues.yaml 파일을 추가해주세요.\n\n```js\ngrafana:\n  service:\n    enabled: true\n    type: NodePort\n    nodePort: 30180\n```\n\n그런 다음 이전과 같이 ArgoCD를 통해 Grafana를 추가해주세요. 동기화를 진행하고 이제 두 개가 모두 실행 중이어야 합니다.\n\n<img src=\"/assets/img/2024-05-18-AGuidetoBuildingaKubernetesClusterwithRaspberryPis_5.png\" />\n\n\n<div class=\"content-ad\"></div>\n\nGrafana를 사용하려면 관리자 비밀번호를 먼저 얻어야 합니다.\n\n```js\nkubectl get secret --namespace monitoring grafana -o jsonpath=\"{.data.admin-password}\" | base64 --decode ; echo\n```\n\n출력에서 나온 관리자 사용자 이름과 비밀번호로 로그인해주세요.\n\n![이미지](/assets/img/2024-05-18-AGuidetoBuildingaKubernetesClusterwithRaspberryPis_6.png)\n\n<div class=\"content-ad\"></div>\n\n이제 Prometheus 데이터 원본을 추가해 보겠습니다. Prometheus 서비스 URL은 모니터링을 설정한 네임스페이스인 클러스터에서 http://prometheus-server.monitoring.svc.cluster.local로 접근할 수 있습니다. \"Administration\" → \"Data sources\" → \"Add new data source\" 아래로 이동한 다음 URL을 추가하고 \"Save & Test\"를 클릭하여 확인할 수 있습니다.\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*VphOqjzSh30E4dKrnf2Q2A.gif)\n\n만약 우리 클러스터의 상태를 간단히 확인하고 싶다면 Grafana Labs에서 제공하는 대시보드를 사용할 수 있습니다. 이를 통해 우리 클러스터에서 사용되는 리소스에 대한 간단한 뷰를 확인할 수 있을 것입니다.\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*AIw7esBCtaz5koK_uJTU-w.gif)\n\n<div class=\"content-ad\"></div>\n\n# 다음 단계\n\n## 사용자 정의 Docker 이미지\n\n당신의 클러스터를 운영하는 중요한 단계로, 공개 Docker.io 레지스트리에 없는 컨테이너나 사용자 정의 컨테이너를 배포할 수 있게 됩니다. 클러스터에 많은 컨테이너를 배포할 계획이라면, 무료 티어 Docker Hub의 제한을 피하기 위해 개인 컨테이너 레지스트리를 설정하는 것을 권장합니다. 이는 GCP의 Artifacts Repository와 같은 클라우드 공급업체나 Harbor와 같은 오픈 소스 docker 저장소로 구현할 수 있습니다.\n\n## 클러스터 자동화\n\n<div class=\"content-ad\"></div>\n\n이 안내서는 교육 목적이나 소규모 개인 클러스터를 관리할 때 이상적인 Kubernetes 클러스터 설정에 대한 수동 방법을 제공합니다. 그러나 프로덕션 클러스터를 배포하거나 이 안내서의 범위를 벗어나는 작업을 수행할 경우, Ansible과 같은 자동화 도구를 활용하는 것을 권장합니다. 이렇게하면 더 효율적이고 확장 가능하며 관리하기 쉬운 배포가 가능합니다.\n\n# 결론\n\nKubernetes 클러스터를 설정하는 것은 쉽지 않을 수 있지만 한 번 완료되면 일반적인 독립형 서버를 뛰어넘는 확장 가능한 환경을 제공하는 장점이 있습니다.\n\nRaspberry Pi는 비용이 저렴하고 전력 소비가 낮은 옵션이지만, 더 큰 응용 프로그램에 대한 확장성이 여전히 제한되어 있습니다. Kubernetes 클러스터의 장점은 동일한 하드웨어만 실행하는 것에 제한받지 않는다는 것입니다. 새로운 노드를 추가함으로써 다양한 하드웨어를 혼합하여 필요에 맞게 Raspberry Pi나 서버와 같은 다양한 하드웨어를 조합할 수 있습니다!\n\n<div class=\"content-ad\"></div>\n\n그것이 좋은 시작점이 되었기를 바랍니다. 읽어 주셔서 감사합니다!","ogImage":{"url":"/assets/img/2024-05-18-AGuidetoBuildingaKubernetesClusterwithRaspberryPis_0.png"},"coverImage":"/assets/img/2024-05-18-AGuidetoBuildingaKubernetesClusterwithRaspberryPis_0.png","tag":["Tech"],"readingTime":15},{"title":"러스트 앱을 여러 아키텍처용으로 크로스 컴파일하기","description":"","date":"2024-05-18 19:07","slug":"2024-05-18-Cross-compileyourRustappformultiplearchitectures","content":"\n\n\n<img src=\"/assets/img/2024-05-18-Cross-compileyourRustappformultiplearchitectures_0.png\" />\n\nRust는 앱 개발을 위한 포맷부터 문서 작성까지 포괄적인 도구를 갖춘 신속하고 견고한 언어입니다. 그러나 컴파일된 언어이므로 다양한 아키텍처 간 호환성을 보장하기 위해 추가적인 노력이 필요합니다. 다행히 Rust는 이를 개발자들을 위해 간소화했습니다. 오늘은 Rust로 기본적인 HTTP 서버 애플리케이션을 작성하고 ARMv7 프로세서용으로 크로스 컴파일하여 네트워크 연결을 통해 STM32MP1 보드에 배포하는 방법에 대해 살펴볼 것입니다.\n\n# 준비물\n\n크로스 컴파일 작업을 시작하기 전에, 특정 사전 준비물이 갖추어져 있어야 합니다. 계속 진행하기 전에 다음 사항을 확인하세요:\n\n\n<div class=\"content-ad\"></div>\n\n- Rust이 컴퓨터에 설치되어 있습니다.\n- 당신은 싱글보드 컴퓨터 또는 컴퓨터와 다른 아키텍처를 가진 장치를 사용하고 있습니다. (저는 STM32MP1을 사용하지만 라즈베리파이, 비글본 또는 다른 장치를 사용할 수 있습니다)\n- 싱글보드 컴퓨터에서 리눅스 배포판이 실행 중입니다.\n- 당신은 보드의 IP 주소를 알고 있으며 SSH를 통해 연결할 수 있는 능력을 가지고 있습니다.\n\n# 안녕하세요, 새로운 Arch!\n\n먼저 Rust 프로젝트가 포함될 디렉토리를 생성합니다. 가장 간단한 방법은 원하는 이름으로 빈 폴더를 수동으로 생성한 다음 (예: mkdir hello-new-arch), 해당 폴더로 이동하여 cargo init --bin을 실행하는 것입니다. 이 명령은 실행 가능한 (바이너리) \"hello new arch\" 애플리케이션을 위한 모든 필요한 소스 파일을 생성합니다. 터미널에서 cargo run으로 앱을 컴파일하고 실행하면 모든 것이 잘 작동하면 터미널에 \"Hello, world!\" 메시지가 출력됩니다.\n\n이제 백그라운드에서 실행되는 간단한 HTTP 서버를 생성할 준비가 되었습니다. Rust는 이 작업을 수행하기 위한 여러 우수한 옵션을 제공합니다. 저는 이 작업을 수행하기 위해 Axum을 선호합니다. 이는 이전 프로젝트에서의 경험과 Tokio 비동기 런타임 팀과의 관련성으로 인해입니다.\n\n<div class=\"content-ad\"></div>\n\n먼저 Cargo.toml 파일에 필요한 종속성을 추가해야 합니다.\n\n```js\n[package]\nname = \"hello-new-arch\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\naxum = \"0.7.2\"\ntokio = { version = \"1.35.0\", features = [\"full\"] }\n```\n\n다음으로 Axum GitHub 저장소에서 'hello-world' 예제 애플리케이션을 복제합니다. 그 후에는 작은 수정만 필요합니다.\n\n저희가 가장 크게 변경하는 부분은 127.0.0.1:3000에 바인딩하는 대신에 실제로 물리적 네트워크 인터페이스 상에서 노출되지 않는 루프백 주소인 0.0.0.0:3000에 바인딩한다는 것입니다.\n\n<div class=\"content-ad\"></div>\n\n우리는 이제 로컬에서 cargo run을 통해 다시 실행하고 모든 것이 잘 작동하면 터미널에 \"listening on...\" 메시지를 볼 수 있습니다. 그런 다음 브라우저 탭을 열어 http://localhost:3000/으로 이동하여 \"Hello from another architecture!\" 헤더가 포함된 페이지가 제공되는지 확인합니다.\n\n# 크로스 컴파일 단계!\n\n현재, 우리 앱을 보드에 업로드하려고 하면 실행할 수 없다는 것을 알게 될 것입니다. 이 문제는 우리 프로그램이 보드의 아키텍처와 호환되지 않는 x86 프로세서용으로 컴파일되었기 때문에 발생합니다.\n\nRust를 크로스 컴파일하려면 보드에서 사용 중인 아키텍처를 확인해야 합니다. 한 번 결정되면, 현재 Rust 툴체인에 적합한 타겟 플랫폼을 설치해야 합니다. Rust는 Tier1, Tier2 및 Tier3 수준으로 분류된 많은 아키텍처에 대한 광범위한 지원을 제공합니다. 이러한 티어 간의 차이점에 대한 포괄적인 이해를 위해 문서를 참조하십시오.\n\n<div class=\"content-ad\"></div>\n\n예를 들어, 제 STM32MP1 보드에는 ARMv7 32비트 프로세서가 탑재되어 있습니다. 공식 Rust 책에 따르면, 이 구성을 위한 필수 대상은 armv7-unknown-linux-gnueabihf입니다. 대략적으로, 선택한 대상 구성 요소는 다음과 같은 의미를 갖습니다:\n\n- armv7: 대상 프로세서에 사용할 아키텍처인 ARM v7\n- unknown: 사용할 서브 아키텍처; 여기서는 기본 옵션을 의미함\n- linux: 대상 운영 체제\n- gnueabihf: 대상 ABI; gnu는 실행 중에 일부 기능에 GNU C 라이브러리(이른바 libc로도 알려짐)를 의존한다는 것을 의미하며, hf는 하드웨어 부동 소수점 연산을 지원한다는 것을 의미함\n\n이 특정 대상을 위해 Rust를 구성하려면 다음 명령을 실행하세요:\n\n```js\nrustup target add armv7-unknown-linux-gnueabihf\n```\n\n<div class=\"content-ad\"></div>\n\n이제 이 명령어를 사용하여 교차 컴파일을 시도해 봅시다:\n\n```js\ncargo build --release --target=armv7-unknown-linux-gnueabihf\n```\n\n그러나 잠시 후에 다음과 유사한 오류가 발생할 가능성이 있습니다:\n\n```js\nerror: linking with `cc` failed: exit code: 1\n```\n\n<div class=\"content-ad\"></div>\n\n2진 파일이 성공적으로 컴파일되었지만 링킹 실패가 발생했습니다. 이 문제가 발생하는 이유는 우리 개발 머신에서 Cargo가 x86 바이너리나 호스트 시스템의 특정 아키텍처를 위해 구성된 cc 및 ld에 의존하기 때문입니다. 이로 인해 ARM 바이너리를 조립할 필요한 지식이 부족합니다. 이 작업에 더 적합한 링커를 사용하도록 Cargo를 안내해야 합니다. 또한 ARM 아키텍처와 관련된 컴파일 또는 링크 작업을 처음 시도하는 경우 필요한 도구를 아직 설치하지 않았을 가능성이 높습니다. 이 문제를 해결하려면 Ubuntu에서 다음 명령을 사용하십시오:\n\n```js\nsudo apt install gcc-arm-linux-gnueabihf\n```\n\n이제 ARM에 적합한 링커와 컴파일러를 설치하고, 'arm-linux-gnueabihf-gcc' 명령어를 호출하여 테스트해보겠습니다(인수 없이 호출하면 즉시 종료됨).\n\n그러나 Cargo가 바이너리의 링킹 단계에서 이를 활용하도록하려면 안내가 필요합니다. 이를 위해 ./.cargo/config라는 새 파일을 만들어 다음 내용을 입력해야 합니다:\n\n<div class=\"content-ad\"></div>\n\n\n[target.armv7-unknown-linux-gnueabihf]\nlinker = \"arm-linux-gnueabihf-gcc\"\n\n\n이렇게 하면 ARM-specific 버전의 gcc를 사용하여 armv7-unknown-linux-gnueabihf Rust target을 위해 컴파일된 이진 파일을 링킹하는데 cargo가 지시됩니다.\n\n## http-server를 시도해봅시다\n\n좋아요, 이제 보드의 아키텍처에 맞는 올바른 컴파일 설정을 성공적으로 설정했으니, 여러 단계를 고려하여 프로세스를 간소화하기 위해 셸 파일을 스크립팅하는 것이 좋겠네요. 이 스크립트는 배포 워크플로를 자동화하여 실행을 더 쉽게 할 것입니다. 동일한 디렉토리에 deploy.rs라는 이름의 텍스트 파일을 생성하고 다음 콘텐츠를 추가합니다. 각 명령어의 기능에 대한 명확성을 위해 주석도 추가했어요:```\n\n<div class=\"content-ad\"></div>\n\n그러면 chmod +x ./deploy.rs와 같은 명령으로 스크립트를 실행 가능하게 만들어 줍니다. 그러면 ./deploy를 통해 직접 실행할 수 있습니다. 이제 바로 시도해 볼 수 있고, 만약 deploy 스크립트에 매개변수를 올바르게 작성했다면, 서버에서 \"listening on 'your board ip address'\"라는 로그 라인을 마침내 볼 수 있게 됩니다. 이는 서버가 최종적으로 대상 보드에서 올바르게 실행되고 있음을 의미합니다!\n\n웹 서버에 액세스하려면 브라우저 탭을 열고 http://'your_board_ip_address':3000으로 이동하면 됩니다. 이제 이 익숙한 웹 페이지가 보드에서 직접 제공되고 있습니다. 접근성을 확인하기 위해 다른 기기(같은 네트워크에 연결된 스마트폰 등)에서 접속을 시도할 수 있습니다.\n\n이 프로그램이 프로덕션에 즉시 적합한 것은 아닙니다. SSH 세션을 종료한 후에도 계속 작동되도록 보장하려면 지속적인 실행을 지원하는 시스템을 구현해야 할 수도 있습니다. 이러한 개선 사항 및 조정 사항은 향후 기사에서 다룰 수도 있습니다.\n\n# 결론\n\n<div class=\"content-ad\"></div>\n\n관찰해 보았을 때, 크로스 컴파일은 인내와 해당 하드웨어에 대한 이해가 필요합니다. 그러나 러스트의 생태계와 관련 도구를 활용하면, 처음에 예상했던 것보다 덜 어려울 수 있습니다. 독자 여러분, 감사합니다!","ogImage":{"url":"/assets/img/2024-05-18-Cross-compileyourRustappformultiplearchitectures_0.png"},"coverImage":"/assets/img/2024-05-18-Cross-compileyourRustappformultiplearchitectures_0.png","tag":["Tech"],"readingTime":5},{"title":"라즈베리 파이에 Tailscale VPN을 통해 SSH하기","description":"","date":"2024-05-18 19:06","slug":"2024-05-18-SSHIntoRaspberryPiwithTailscaleVPN","content":"\n\n<img src=\"/assets/img/2024-05-18-SSHIntoRaspberryPiwithTailscaleVPN_0.png\" />\n\n요즘 연결된 세상에서 원격으로 기기에 액세스하는 것은 많은 기술 애호가와 전문가들에게 필수적인 요소가 되었습니다. 집에서 프로젝트를 작업하는 취미 요원이든, 여러 기기를 관리하는 IT 전문가이든, 안전한 원격 액세스가 중요합니다. 이러한 목적에 가장 적합한 도구 중 하나가 Tailscale입니다.\n\nTailscale은 기기 간의 안전한 네트워크를 생성하는 과정을 간소화하는 망 VPN 서비스입니다. Tailscale을 사용하면 전 세계 어디에서나 Raspberry Pi에 쉽게 액세스할 수 있으며, 마치 동일한 로컬 네트워크에 있는 것처럼 사용할 수 있습니다. 이 튜토리얼에서는 Raspberry Pi에 Tailscale을 설정하여 외부 네트워크에서 SSH로 액세스하는 방법을 안내하겠습니다. Raspberry Pi와 Mac에서의 설치 과정을 다루고, 기기 인증 방법을 보여드리며, SSH 연결을 설정하는 방법을 시연하겠습니다. 참고로 Windows 사용자들의 단계는 비슷합니다.\n\n나머지 부분을 읽기 전에 아직 채널을 구독하지 않았다면 반드시 구독하고 지원해주세요!\n\n<div class=\"content-ad\"></div>\n\n# 구독하기:\n\nYouTube\n\n# 후원하기:\n\n[Buy Me a Coffee](https://www.buymeacoffee.com/mmshilleh)\n\n<div class=\"content-ad\"></div>\n\nUpWork에서 저를 고용하여 IoT 프로젝트를 구축하세요:\n\n[https://www.upwork.com/freelancers/~017060e77e9d8a1157](https://www.upwork.com/freelancers/~017060e77e9d8a1157)\n\n# 단계 1: 라즈베리 파이에 Tailscale 설정하기\n\n라즈베리 파이 업데이트: 모든 패키지가 최신 상태인지 확인하려면 Raspberry Pi를 업데이트하세요. 터미널을 열고 다음을 실행하세요:\n\n<div class=\"content-ad\"></div>\n\n```js\nsudo apt update\nsudo apt upgrade -y\n```\n\nTailscale 설치: 먼저 Tailscale을 설치하세요. 라즈베리 파이에 Tailscale 레포지토리를 추가해야 합니다:\n\n```js\ncurl -fsSL https://pkgs.tailscale.com/stable/raspbian/buster.gpg | sudo apt-key add -\ncurl -fsSL https://pkgs.tailscale.com/stable/raspbian/buster.list | sudo tee /etc/apt/sources.list.d/tailscale.list\n```\n\n패키지 목록을 업데이트하고 Tailscale을 설치하세요:\n\n<div class=\"content-ad\"></div>\n\n```js\nsudo apt update\nsudo apt install tailscale\n```\n\nTailscale를 시작하세요: 설치가 완료되면 Tailscale 서비스를 시작합니다.\n\n```js\nsudo tailscale up\n```\n\nRaspberry Pi를 Tailscale 계정으로 인증하기 위해 안내에 따라 따라하세요. 이를 위해 웹 브라우저에서 Tailscale 계정으로 로그인하고 장비를 인가해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n# 단계 2: 맥에서 Tailscale 설정하기\n\n- Tailscale 다운로드: Tailscale 웹사이트를 방문하여 Mac 버전의 Tailscale을 다운로드합니다.\n- Tailscale 설치: 다운로드한 파일을 열고 설치 지침에 따릅니다.\n- 맥 인증: 응용 프로그램 폴더에서 Tailscale을 열고 Tailscale 계정으로 로그인합니다. 이렇게 하면 맥이 Tailscale 네트워크에 추가됩니다.\n\n# 단계 3: SSH를 통해 라즈베리 파이에 연결하기\n\n라즈베리 파이의 Tailscale IP 찾기: 라즈베리 파이에서 다음을 실행하세요:\n\n<div class=\"content-ad\"></div>\n\n```js\ntailscale ip -4\n```\n\n이 명령을 실행하면 Raspberry Pi의 Tailscale IP 주소(예: 100.x.x.x)가 표시됩니다.\n\n라즈베리 파이로 SSH 연결하기: 맥에서 터미널을 열고 다음 명령을 사용하여 라즈베리 파이로 SSH 연결할 수 있습니다.\n\n```js\nssh pi@<tailscale-ip>\n```\n\n<div class=\"content-ad\"></div>\n\n이전 단계에서 얻은 IP 주소로 `tailscale-ip`를 대체하세요. 예를 들어:\n\n```js\nssh pi@100.64.0.1\n```\n\n처음 연결하는 경우 호스트를 알려진 호스트 목록에 추가하라는 메시지가 나타날 수 있습니다. yes를 입력하고 Enter 키를 누르세요.\n\nWindows 사용자를 위한 참고: Windows 기기에 Tailscale을 설정하는 단계는 Mac과 유사합니다. Tailscale 웹사이트에서 Tailscale 설치 파일을 다운로드하고 설치한 다음 Tailscale 계정으로 로그인하세요. 그런 다음 PuTTY나 Windows 터미널과 같은 SSH 클라이언트를 사용하여 Raspberry Pi에 Tailscale IP를 사용하여 SSH로 연결하세요.\n\n<div class=\"content-ad\"></div>\n\n# 결론\n\nTailscale을 사용하면 라즈베리 파이에 안전한 원격 액세스를 쉽고 효율적으로 설정할 수 있습니다. 이 튜토리얼에서 안내된 단계를 따라하면 어디에서나 라즈베리 파이를 쉽게 관리할 수 있습니다. Mac이든 Windows를 사용하든 Tailscale의 원활한 통합 덕분에 원격 SSH 액세스가 간편해집니다. 해킹을 즐기세요!","ogImage":{"url":"/assets/img/2024-05-18-SSHIntoRaspberryPiwithTailscaleVPN_0.png"},"coverImage":"/assets/img/2024-05-18-SSHIntoRaspberryPiwithTailscaleVPN_0.png","tag":["Tech"],"readingTime":3},{"title":"내 친구들과 화해하기","description":"","date":"2024-05-18 19:04","slug":"2024-05-18-MendingMyMends","content":"\n\n## 직접 만들기\n\n![이미지](/assets/img/2024-05-18-MendingMyMends_0.png)\n\n내 책상은 언제나 진행 중인 재봉틀 프로젝트로 가득 차 있어요. 스커트를 만드느라 시간을 보내다가 스타일이 변하면 나중에 바꾸기도 해요. 내 옷장과 재봉틀 기술이 끊임없이 발전하고, 때로는 옷이 여러 차례 다시 책상 위에 놓일 때도 있어요. 이 재봉틀의 장점을 받아들이고, 때로는 즐기는 법을 배우고 있어요.\n\n한 날, 특히 영감을 받아서 옷장을 뒤적여 두 개의 스커트와 두 개의 셔츠를 꺼냈어요 — 모두 옷장 뒷부분에 쑤시고 더 이상 사용하지 않는 옷들이었죠. 그 셔츠들은 예전에 좋아했던 아이템들인데, 이제는 날 어울리지 않는 것 같아요.\n\n<div class=\"content-ad\"></div>\n\n스커트는 제가 처음 바느질을 배우던 시절의 예입니다. 지금 생각하면 매우 부끄러운데요.\n\n![2024-05-18-MendingMyMends_1.png](/assets/img/2024-05-18-MendingMyMends_1.png)\n\n이들은 맞지 않아요 — 어느 부분에서는 너무 작고, 다른 부분에서는 너무 큽니다. 실이 사방으로 튀어나오고, 꿰매는 바늘이 자꾸 풀립니다. 제게는 바느질 실력이 발전하는 과정을 보여주는 증거라고 자신합니다. 앞으로 더 나아질 거라고 믿어요!\n\n![2024-05-18-MendingMyMends_2.png](/assets/img/2024-05-18-MendingMyMends_2.png)\n\n<div class=\"content-ad\"></div>\n\n상의는 간단히 고쳤어요. 너무 헐렁하고 조임이 필요했어요. 소매를 잘라낸 부분을 안으로 돌려야 했고, 가장자리에 수작업으로 디테일을 추가했어요.\n\n![이미지](/assets/img/2024-05-18-MendingMyMends_3.png)\n\n그러나 보라색 스커트는 전면적인 재작업이 필요했어요. 끊임없이 고민했어요: 스커트 위에 패치워크를 해야 할까요? 라일락 색의 부분을 드러나게 해야 할까요? 고무 허리띠를 추가해야 할까요, 아니면 끈을 유지해야 할까요?\n\n![이미지](/assets/img/2024-05-18-MendingMyMends_4.png)\n\n<div class=\"content-ad\"></div>\n\n의심이 많이 들 때, 제 쓰레기 더미를 뒤져보았고, 몇 년 전에 받은 스카프 조각들이 부르는 것 같았어요. 항상 그 무늬와 색상을 좋아했고, 몇 년 동안 홈 데코용으로 사용해왔는데, 형광등의 강한 빛을 부드럽게 만들어 주었죠.\n\n![스카프 조각](/assets/img/2024-05-18-MendingMyMends_5.png)\n\n장식물로서의 역할을 은퇴한 후, 스커트의 멋진 장식물이 될 수 있을 것 같아서 파란 색 띠를 제거하기 시작했어요. 이 프로젝트는 아직 진행 중이에요. 어떻게 진행할지, 제가 좋아하는 부분(원단의 색감)을 보존하고 옷 전체의 맞지 않는 부분을 어떻게 해결할지에 대해 고민하고 있어요. 결론에 도달할 것이라고 희망하지만, 그 전까진 이 스커트가 제 바느질 책상 위에서 살아갈 거예요.\n\n![진행 중인 스커트 프로젝트](/assets/img/2024-05-18-MendingMyMends_6.png)\n\n<div class=\"content-ad\"></div>\n\n엉망으로 되어있었던 분홍 꽃무늬 스커트 부분에 대한 해결책을 찾았어요! 다시 한 번 내 재료파일이 영감의 원천이 되었네요. 측면의 좁음은 베개케이스에서 나온 꽃무늬 원단을 추가해 해결했어요. 옷의 모양이 돋보이도록 하기 위해 상단에서 좁아서 하단에서 넓게 원단을 조각해 주었어요.\n\n![이미지](/assets/img/2024-05-18-MendingMyMends_7.png)\n\n그리고 이상한 회색 넥타이 대신에 대차넘친 테이블보가 남아있던 원단을 추가하기로 결정했어요. 이러한 유형의 기하학적 디자인은 남미 안데스 지역에서 전통적이에요. 이 지역이나 대륙의 원주민은 아니지만, 지역 문화의 한 측면을 내 소소한 수선에 포함시키는 것이 좋은 느낌이에요.\n\n스커트와 셔츠가 어떻게 변했는지 확인해보세요. 사진을 찍을 때 뇌리를 조금 놀려야만 틸라가 나와준달까요, 그래도 빅 틸라가 동의했다고 생각하고 싶어요.\n\n<div class=\"content-ad\"></div>\n\n![2024-05-18-MendingMyMends_8](/assets/img/2024-05-18-MendingMyMends_8.png)\n\n저의 몇 가지 성공 경험 뒤에 제 옷장을 뒤져보니 자주색 스커트가 보였어요. 저는 이 스커트에 고무 밴드를 추가하고 아마 아래쪽에 다른 하나의 층을 더할 예정입니다. 거짓 프러티코트처럼 어떤 층을 더할 생각입니다. 프러티코트에 사용될 소재는 현재 뜨는 구식 침대 시트에서 나온 것일 겁니다.\n\n![2024-05-18-MendingMyMends_9](/assets/img/2024-05-18-MendingMyMends_9.png)\n\n이 글을 쓰는 시점에서 자주색 스커트는 완성되지 않았어요. 느린 패션의 특성인데요 - 모든 부분이 시간이 걸리는 건 사실입니다.\n\n<div class=\"content-ad\"></div>\n\n여러 순간을 반영하는 변경 사항을 만드는 데 소요된 시간으로, 각 수선은 모든 의복이 정말 독특하며 기계와 손으로 세워진 추억을 가지고 있다는 것을 필요로 합니다. 계속 진행 중인 삶의 기억이 그 안에 담겨 있죠.","ogImage":{"url":"/assets/img/2024-05-18-MendingMyMends_0.png"},"coverImage":"/assets/img/2024-05-18-MendingMyMends_0.png","tag":["Tech"],"readingTime":3},{"title":"여름 피부를 빛나게 하는 각질 제거","description":"","date":"2024-05-18 19:03","slug":"2024-05-18-ExfoliatingforSummerGlow","content":"\n\n여름에 우리 피부는 땀과 기름을 더 처리해야 합니다, 특히 더운 다습한 날씨에서는 모공이 막힌 기름진 피부를 초래합니다. 땀, 선크림, 염소소독약, 소금물 등이 흔하며, 이에 대비하여 거품을 내는 세안제와 SPF가 들어간 가벼운 보습제를 사용하는 스킨케어 루틴이 필요합니다. 개선된 각질 제거는 여름 피부 문제에 효과적으로 대처하기 위해 필수적입니다.\n\n# 각질 제거\n\n미국 피부과학회에서 \"피부의 외부층에서 죽은 피부세포를 제거하는 과정\"으로 정의한 각질 제거는 세포 회전율, 재생 및 콜라겐 생성을 돕는다. 젊고 반짝이는 피부를 유지하는 데 중요한 단계입니다. 각질 제거의 혜택은 그 이상이며, 각질 제거는 모공을 열어 여드름을 예방하고 부드럽고 매끄러운 피부를 유지하는 데 도움이 됩니다. 정기적인 각질 제거는 다른 스킨케어 제품의 흡수를 향상시키고 그 효능을 극대화합니다.\n\n여름에는 귀한 각질 제거가 더욱 필수적이며, 죽은 피부세포를 빠르게 제거하여 피부의 홍조를 유지할 뿐만 아니라 더 효과적인 탈부각을 보장하여 피부의 생기를 유지합니다.\n\n<div class=\"content-ad\"></div>\n\n## 엑스폴리에이션의 두 가지 주요 방법이 있습니다\n\n화학적 방법 & 물리적 방법 (또는 기계적 방법)\n\n## 화학적 엑스폴리에이션\n\n화학적 엑스폴리에이션은 AHAs나 BHAs와 같은 산 또는 효소를 사용하여 피부 속까지 깊이 스며들고 부드럽습니다. 알려진 AHAs로는 젖산 및 글리콜산 등이 있으며, 미세 주름, 주름, 모공, 그리고 피부 톤 불균일을 개선합니다. 살리실릭산 또는 버들나무 껍질 추출물과 같은 BHAs는 여드름, 블랙헤드, 화이트헤드, 그리고 햇볕으로부터 온 피부 손상의 외관을 향상시킵니다.\n\n<div class=\"content-ad\"></div>\n\n## 물리적 각질제거\n\n물리적 각질제거는 도구나 수동으로 이루어집니다.\n\n- 전문가가 실시하는 물리적 각질제거 방법에는 뎌마플레닝(dermaplaning)과 마이크로더마브레이젼(microdermabrasion) 등의 절차가 포함됩니다.\n- 집에서 사용할 수 있는 수동 각질제거제로는 스펀지, 브러시, 또는 모래, 설탕, 호호바 비드, 커피 찌꺼기 등이 있습니다.\n\n피부가 얇거나 민감한 경우 화학적 각질제거제가 가장 적합할 수 있지만, 꼭 미리 패치 테스트를 해보세요!\n\n<div class=\"content-ad\"></div>\n\n# 여름에 안전하고 효과적인 각질 제거: 완벽한 결과를 위한 팁\n\n- 먼저, 피부 타입에 맞는 올바른 각질 제거제를 선택하세요.\n지성 피부인 경우 물리 각질 제거제를 선택하세요.\n건성 피부인 경우 더 부드러운 효소(화학) 각질 제거제를 선택하세요. 복합성 피부는 두 가지 타입을 사용하는 것이 좋습니다. 항상 패치 테스트를 먼저 해보세요.\n- 여름에는 부드럽지만 효과적으로 미지근하고 효생한 각질 제거제를 선택하세요.\n- DIY 스크럽에 대해 확인해보세요. 자연 및 유기농 성분을 사용한 많은 레시피를 찾을 수 있으며 도움이 될 수 있습니다.\n- 이어서 정기적으로 각질을 제거하세요. 이렇게 하면 피부를 부드럽게 유지하고 다른 스킨케어 제품이 더 잘 작용할 수 있습니다.\n- 각질 제거 후 피부가 햇볕에 민감해지므로 특히 자외선차단제와 SPF 30 이상의 보습제를 사용하세요. 부드러운 자외선 차단제를 사용하세요.\n- 민감도와 자극이 발생할 수 있는 지나친 각질 제거를 피하세요. 화학 치료 후에 각질 제거를 건너뛰고 물리적이든 화학적이든 각질 제거제를 사용할 때 항상 피부에 부드럽게 행동하세요.\n\n이러한 팁으로 여름에 반짝이는 피부를 만들어 보세요!\n\n내가 자연 치료 건의를 나누기 위해 여기 있습니다. 만약 이 기사를 좋아하셨다면 새로운 제안에 대한 알림을 받으려면 팔로우하고 구독하지를 잊지 마세요.","ogImage":{"url":"/assets/img/2024-05-18-ExfoliatingforSummerGlow_0.png"},"coverImage":"/assets/img/2024-05-18-ExfoliatingforSummerGlow_0.png","tag":["Tech"],"readingTime":2},{"title":"ALTRAD8UD-1L2T에 GPU를 사용할 수 있도록 하는 빠른 업데이트","description":"","date":"2024-05-18 19:02","slug":"2024-05-18-AquickupdateonALTRAD8UD-1L2TmakingitworkwithGPU","content":"\n\n동일한 주제에 대한 다른 기사들:\n\n- 첫 번째: ASRock Rack ALTRAD8UD-1L2T (Ampere Altra)의 첫 인상\n- 두 번째 (이 기사): ALTRAD8UD-1L2T에 대한 빠른 업데이트 (GPU와 함께 작동시키기)\n\n# 소개\n\n이것은 Ampere Altra 보드에 대한 첫 인상의 빠른 업데이트일 것입니다. 그래서 그림은 게시글의 어딘가에서 찍은 것이 아니라 제 고양이 중 한 마리와 함께 있을 것입니다.\n\n<div class=\"content-ad\"></div>\n\n모든 것이 도착할 때까지 기다리는 동안 서버를 구축하고 있어요 (샤시를 구하고 보드의 절반 가격을 내지 않아도 시간이 걸릴 것 같아서...); 아파트에 있는 랜덤한 PCIe 장치를 연결해서 작동시키려고 노력하고 있어요. 당연히 먼저 시도할 것은 GPU에요.\n\n솔직히 말해서 많지는 않아요. HDMI/DP 또는 DVI 출력만 합리적으로 사용할 수 있는 몇 개가 있어요. 그러나 Altra에서 게임을 할 기회를 갖고 싶다면 몇 가지 선택지가 있어요:\n\n- RX 550 — 오래 동안 amdgpu에서 지원된 Polaris입니다; 또한 DCN의 Floating Point 명령 같은 특별한 것은 없어서 비교적 좋은 호환성을 가지고 있어요.\n- RX 5700은 채굴 랙에서 뽑아낸 것일 가능성이 높은 싸게 구한 버전이에요; 랜덤한 시스템에 꽂아도 충분히 좋아요. 작동 상태이지만 얼마나 오래 갈지는 모르겠어요. 이 카드는 DCN을 사용하고 있어요. \n- Intel Arc 750 — RX 5700와 성능적으로 대체로 비슷한 양호한 GPU인 것 같아서 가져왔어요. 상대적으로 좋은 RayTracing을 가지고 있고, Intel은 Linux(x86/x86-64)에서 잘 작동한다는 신뢰를 가지고 있어요.\n\n# RX 550\n\n<div class=\"content-ad\"></div>\n\nRX550은 지루하지만 제대로 작동하는 것 같아요:\n\n스크린샷의 품질이 떨어져서 죄송해요; 저는 싸고 간단한 USB-HDMI 캡처 카드를 사용해서 찍었어요. 그리고 제가 곧 글을 쓸 계획은 없었기 때문에, 제가 누군가에게 보여준 여러 종류의 메시지에서 이 스크린샷을 얻었어요.\n\n해당하는 커널은 기본 커널을 실행하고 있어요, 그래서 거기서 아무것도 바꾸지 않았어요.\n\n# RX 5700\n\n<div class=\"content-ad\"></div>\n\n실행하는 것은 훨씬 더 어려웠어요. 먼저, 6.1 커널은 ARM에서 FP 레지스터를 저장하지 않는다(잘못 기억했다면 고쳐주세요), 이는 DCN 1.0 이상을 지원하는 카드에서 필요합니다. 더욱이, Ampere Altra에는 PCIe에 관한 버그가 있어서 일부 장치가 작동하지 않습니다. 이를 \"Ampere Altra erratum #82288 PCIE_65\"라고 부르며, 이미 일부 Linux 배포판에 통합되어 있습니다. 이 문제에 대한 커뮤니티 포럼에서 토론이 진행 중입니다.\n\n만약 그 패치를 적용하지 않으면, amdgpu가 카드를 초기화하지 못할 것입니다. 6.9-rc6 커널(내가 시도한 가장 최신 버전)을 사용해도 다음과 같은 메시지가 표시됩니다:\n  \n때로는 부팅이 되기는 하지만, 그래픽 오류나 시스템 멈춤이 발생할 수 있습니다.\n\n하지만 패치를 적용하면 잘 작동합니다:\n\n<div class=\"content-ad\"></div>\n\n\n![Image](/assets/img/2024-05-18-AquickupdateonALTRAD8UD-1L2TmakingitworkwithGPU_0.png)\n\n# Intel Arc 750\n\n이건 웃긴 게 한 가지 있어요. 그 이유는 인텔 i915 커널 드라이버가 비-x86 장치에서 동작하지 않기 때문이에요. 그들은 최근 GPU에 더 맞춰진 새로운 Xe 커널 드라이버를 업스트림으로 올리기 시작했어요. 하지만, Altra에서 그것을 사용하려고 하면, 기본적으로 다음과 같은 결과를 얻을거에요:\n\n조금 더 찾아보았더니, 초기화하고 이미지를 출력하는 지저분한 해킹을 발견했어요 (2D만 가능하며, 더 복잡한 메사 부분이 있을 수도 있어요):\n\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-05-18-AquickupdateonALTRAD8UD-1L2TmakingitworkwithGPU_1.png)\n\n어떤 부분을 효과적으로 주석 처리했나요? 설명에 따르면 intel_vga_reset_io_mem은 VGA Console이라는 모듈과 호환성을 보장하기 위한 함수인데, 해당 모듈이 사용하는 레지스터를 건드리지 않으면 락업이 발생한다고 합니다. 그 함수가 하는 일에 대해 자세히 설명하는 주석이 있습니다. 그러나 (오래된 플랫폼 중 하나를 제외하고는) ARM에서는 VGA Console이 작동하지 않습니다. 따라서 테스트를 위해 주석 처리해도 무방할 것입니다.\n\n그렇게 하면, 어느 정도 시간이 지난 후 (특히 drm 디버그 로깅이 활성화된 상태에서는 드라이버가 초기화되기까지 일정 시간이 소요됩니다):\n\n![이미지](/assets/img/2024-05-18-AquickupdateonALTRAD8UD-1L2TmakingitworkwithGPU_2.png)\n  \n\n<div class=\"content-ad\"></div>\n\n사진을 받았어요! ARM에서 실행 중인 인텔 GPU의 HDMI 출력!\n\n여전히 3D가 없는 이유는 두 가지 때문입니다:\n\n- debian 테스팅에 포함된 Mesa의 업그레이드된 버전이 필요합니다 (지난 기사 이후로 테스팅으로 업그레이드했습니다).\n- Xe를 처리하는 i915 갈리움 드라이버가 x86/x86-64 전용으로 표시되어 있습니다. 그래서 이것을 작동시키는 것이 매우 어려울 것입니다 (특히 저는 mesa 코드베이스에 익숙하지 않기 때문에).\n\n변경: 리눅스에서 인텔 GPU를 사용한 지 얼마 되지 않아서 Xe와 인텔 Arc가 여전히 i915로 처리된다는 잘못된 인상을 가지고 있었습니다. 실제로는 더 최신 iris 드라이버에 의해 처리됩니다. 그래서 여기에서 말한 내용은 무시해 주세요.\n\n하지만 승리는 승리입니다. 작은 승리라도요. 이제 위에 있는 수정을 upstream으로 할 필요가 있고, 솔직히 어떤 종류의 패치가 거기서 허용될지 확실하지 않습니다. 현재 제 추측은 CONFIG_VGA_CONSOLE에 빨간불을 켜면 괜찮을 것 같지만, 우리가 보겠죠.\n\n<div class=\"content-ad\"></div>\n\n## 같은 날 나중에 업데이트\n\nDebian에서 ARM에 intel-specific 라이브러리를 활성화하지 않기 때문에 libdrm을 다시 컴파일하는 데 몇 시간을 보냈습니다. 또한, debian-testing의 mesa도 오래되었고 거기서 Xe는 x86/x86-64 아키텍처로 제한되어 있어서 24.1.0-rc에서는 aarch64로 컴파일할 때 기본 드라이버 목록으로만 작동해야 할 것이지만 RayTracing을 제외하고, 그것은 다른 이야기입니다. 그런데 결국 아무것도 작동하지 않게 되었습니다.\n\ngdm을 시작하려고 시도하면 바로 다음과 같이 오류가 발생하고:\n\n\"guc ids might be different\"라는 메시지가 표시되고 결국 다음과 같은 메시지로 잠겨 버립니다:\n\n<div class=\"content-ad\"></div>\n\n커서가 렌더링되어 있었지요.\n\n포기하려던 찰나, 그러던 중에 오류를 찾아보기로 결정하였어요. Xe 개발자들의 자동화 시스템에서도 해당 오류가 발견되었다는 것을 알게 되었어요. 그들의 저장소에서 일부 패치가 드라이버를 전반적으로 더 안정적으로 만들었다는 것을 발견했죠. 그래서 저는 그들의 브랜치를 가져오기로 결정했어요 (커널 6.10을 위한 drm-next일 것으로 예상됩니다) 그리고 이게 작동하는지 확인해 보기로 했어요.\n\n다시 컴파일한 후에 (그리고 이전의 패치를 다시 적용한 후), 이게... 전혀 작동하지 않았어요. 동일한 메시지로 드라이버가 실패했죠: \"여러 번의 정지가 발생하고 있습니다.\"\n\nBIOS 설정을 좀 만져보고(일부 조작설정이 작동하거나 꺼지는 점을 발견했어요) 저는 또 기억했어요, 해당 커널에 앰페어의 PCIe 버그 수정을 다시 적용하지 않았다는 점을요.\n\n<div class=\"content-ad\"></div>\n\n그 후에 GDM을 시작했어요...\n\n![image](/assets/img/2024-05-18-AquickupdateonALTRAD8UD-1L2TmakingitworkwithGPU_3.png)\n\n그리고 멈췄어요. 하지만 드라이버가 실험적이라고 생각해서 다시 시도하기로 결정했어요. 이번에는 더 멀리 갔고 OpenGL이 작동 중이라는 멋진 스크린샷을 얻었어요.\n\n![image](/assets/img/2024-05-18-AquickupdateonALTRAD8UD-1L2TmakingitworkwithGPU_4.png)\n\n<div class=\"content-ad\"></div>\n\n실제로이 업데이트를 쓰는 동안 바로 내 옆에 놓여져 있었고 아직도 고장 나지 않았어요. 빠르지는 않지만 실험용 드라이버에서 기대할 수 있는 것입니다.\n\n이제 아마도 Mesa 빌드 시스템 변경 사항을 upstream하고 몇 가지 버그 보고를 더 제출해야 할 것 같아요...\n\n업데이트: upstreamd해야 할 유일한 변경 사항은 AArch64용 intel-rt를 활성화하는 것뿐이고, 다른 변경 사항들은 Debian이 Mesa를 빌드하는 방식과 관련이 있어서 upstream Mesa와는 무관합니다.\n\n# 결론 대신\n\n<div class=\"content-ad\"></div>\n\n그저 현 상황에 대한 간단한 노트입니다. 저는 정말로 Ampere가 언젠가 PCIe 버그에 대한 해결책을 업스트림으로 올릴 것이고 사람들이 자체 커널 빌드를 유지할 필요가 없게 될 것을 희망합니다. 그것이 아직 완료되지 않았다는 것은 저를 놀라게 합니다.\n\n만약 그 기사를 읽은 이유가 고양이의 사진을 보기 위해서라면, 여기 있습니다:\n\n![cat](/assets/img/2024-05-18-AquickupdateonALTRAD8UD-1L2TmakingitworkwithGPU_5.png)","ogImage":{"url":"/assets/img/2024-05-18-AquickupdateonALTRAD8UD-1L2TmakingitworkwithGPU_0.png"},"coverImage":"/assets/img/2024-05-18-AquickupdateonALTRAD8UD-1L2TmakingitworkwithGPU_0.png","tag":["Tech"],"readingTime":5},{"title":"부담갖지 마세요 여러분의 부활절 브런치나 뷔페를 한층 더 특별하게 만들어보세요","description":"","date":"2024-05-18 19:00","slug":"2024-05-18-ElevateYourEasterBrunchorBuffet","content":"\n\n## DIY/EASTER/FOOD\n\n![Easter Brunch Buffet](/assets/img/2024-05-18-ElevateYourEasterBrunchorBuffet_0.png)\n\n부활절 브런치나 뷔페에 어울리는 센터피스가 필요하신가요? 분명히 다른 이들로부터 다양한 반응을 얻을 수 있는 아이디어를 제공해 드리겠습니다.\n\n이걸 단계별로 보여드릴 테니 걱정 마세요. 빠르고 쉽고 비용 효율적인 방법입니다.\n\n<div class=\"content-ad\"></div>\n\n옛날 존슨 앤 웨일스 조리예술 학교에 다녀갔을 때 졸업식마다 그랜드 뷔페가 열렸어요. 주방 브리게이드 모두가 참여했던 행사였죠.\n\n저는 그런 이벤트 중 하나가 열리던 시기에 가르드 망제 클래스를 수강했어요. 제 강사는 버지니아의 역사적인 챔버린 호텔의 주발실대행 쉐프였죠.\n\n가르드 망제 수업에서는 간식, 파테, 테린, 샤르쿠트리, 그리고 애스픽 등을 가르쳤어요. 애스픽은 제가 가장 싫어했던 것이었고, 졸업 후로는 결코 다시 만들지 않았고 앞으로도 만들지 않을 거예요.\n\n![](/assets/img/2024-05-18-ElevateYourEasterBrunchorBuffet_1.png)\n\n<div class=\"content-ad\"></div>\n\n셰프가 나에게 장식된 프레처 포, 프랑스 마카롱, 그리고 올 두브르 사이즈 크림 퍼프를 만들어 보라고 시키셨어요.\n\n이 강사님께서는 프레젠테이션에 큰 관심을 가지셨어요. 제가 어깨 너머를 쳐다볼 때마다 땀을 흘리곤 했답니다. 챔버린 호텔은 타이드워터 지역에서 가장 엄선된 품질의 일요일 브런치로 유명했어요.\n\n대부분의 음식은 트레이와 접시에 제공되어 조금 지루하다고 생각했어요.\n\n저렇게 강사님을 감명 시킬 수 있는 방법이 있을까요?\n\n<div class=\"content-ad\"></div>\n\n이때쯤, 나는 취미로 스테인드 글라스도 만들고 있었어. 내 디저트를 높이는 아이디어는 결혼식 케이크에 사용되는 윌튼 케이크 분리기와 기둥에서 왔어. \n\n나는 손가락 디저트를 유리 탑 위에 배열하고 신선한 꽃과 함께 유리 탑 위에 서고 싶다고 생각했어. \n\n내가 할당된 자리에 내 탑을 만들고 나니, 강사가 다가와 나를 보며 미소를 지었어; 그는 절대 웃지 않았었어. 그는 내가 만든 것에 감명을 받아 전체 그랜드 뷔페의 주요 초점으로 방 중앙에 재조합해달라고 했어.\n\n<div class=\"content-ad\"></div>\n\n그는 후에 그 아이디어를 베끼고 Chamberlin의 일요일 브런치에서 사용했어요.\n\n“A”를 받았어요.\n\n지난 몇 년 동안 여러 행사를 위해 이것들을 만들었고, 항상 멋진 평가를 받았어요.\n\n나는 반사 품질이 마음에 들어 유리에서 거울로 바꿨어요. 사실, 거울은 음식 대회에서 자주 사용돼요.\n\n<div class=\"content-ad\"></div>\n\n약속한 대로 여기에 당신만의 뷔페 센터피스를 만드는 단계별 가이드가 있어요.\n\n![이미지](/assets/img/2024-05-18-ElevateYourEasterBrunchorBuffet_3.png)\n\n## 첫 번째 단계\n\n바닥 레벨로 20인치 x 24인치의 경사면이 있는 유리 거울을 사용했어요. 지역 홈센터에서 $19.95에 구입했어요. 상단 두 레벨에는 12인치 정사각형 거울을 사용했어요. 한 상자에 여섯 개가 들어있어서 $12뿐이에요.\n\n<div class=\"content-ad\"></div>\n\n컵보드에서 네 개의 캔을 꺼내 첫 번째 레벨을 만들어 보세요. 거울의 뒷면에 부드러운 코팅이 스크래치되는 것을 막기 위해 나프킨이나 덕트 테이프를 사용해봐요.\n\n![image](/assets/img/2024-05-18-ElevateYourEasterBrunchorBuffet_4.png)\n\n## 두 번째 단계\n\n이제 수프캔을 숨겨야 해요. 이를 위한 방법은 정말 다양해요. 저는 패스텔 테이블보로 바닥 주변에 펴고 1.99달러짜리 국산에서 사온 데이지꽃을 사용했어요.\n\n<div class=\"content-ad\"></div>\n\n베이스는 단지 당신의 상상력에 의해서만 제한됩니다.\n\n테이블 위에 베이스 미러를 직접 놓을 수 있지만, 저는 어떤 종류의 장식적 기반으로 작은 높이를 부여하는 것을 선호합니다.\n\n## 세 번째 단계\n\n첫 번째 레벨에 네 개의 기둥으로 tall Weck jars를 사용했습니다. 이들을 적합한 장식물로 채울 수 있습니다. 부활절 달걀, 솔방울과 가을 잎, 꽃, 크리스마스 호랑가시, 선택할 수 있는 것은 끝이 없고 재미있습니다.\n\n<div class=\"content-ad\"></div>\n\n현지 달러 상점에는 유리 기둥 및 내부에 넣을 수 있는 다양한 물건들이 많습니다. 와인 잔이 잘 작동합니다.\n\n저는 첫 번째 레벨에는 병을 사용하는 것을 선호하고 상단 레벨에는 와인 잔을 선호합니다. 아래쪽이 무거우면서 위쪽이 가볍고 공기가 많은 것이 대칭적이고 테이퍼링된 룩에 더 잘 맞습니다.\n\n다음 거울 레벨을 4개의 장식된 기둥 위에 놓으세요.\n\n## 단계 네\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-05-18-ElevateYourEasterBrunchorBuffet_5.png\" />\n\n와인 잔 안에 꽃이나 원하는 것을 넣을 수 있어요.\n\n와인 잔 위에 마지막 단계를 추가하세요.\n\n어떤 아기 샤워 행사에서는 유아용 나무 블록을 필라로 붙여서 한쪽에는 \"baby\", 다른 한쪽에는 \"girl\"이라고 썼어요.\n\n<div class=\"content-ad\"></div>\n\n이스터를 위해 나는 맨 위에 튤립 꽃병을 추가했어요. 그러나 최종 상단 장식에 매우 창의적일 수 있어요.\n\n졸업 파티를 위해 프레임된 사진을 사용할 수 있어요. 이 예에서는 우리 아들의 사진, 경조 파티를 위한 커플 사진을 사용할 수도 있어요.\n\n한 번은 5차 감시등을 총괄 지휘관 은퇴 파티의 최종 상단 조각으로 사용했어요. 건전지 작동 티 라이트가 달린 미니어처 모형을 사용했어요.\n\n첫 번째 층에는 여러 번 Wilton 웨딩 케이크 분수기를 사용했어요.\n\n<div class=\"content-ad\"></div>\n\n지금은 타워가 완성되었으며, 음식만 추가하면 됩니다.\n\n이 타워는 손으로 먹는 음식, 디저트 타워, 치즈 & 크래커, 혹은 샐러미에 대해 훌륭한 작품입니다.\n\n![이미지1](/assets/img/2024-05-18-ElevateYourEasterBrunchorBuffet_6.png)\n\n![이미지2](/assets/img/2024-05-18-ElevateYourEasterBrunchorBuffet_7.png)\n\n<div class=\"content-ad\"></div>\n\n저는 대사관, 상원의원, 그리고 해군 중장들을 위해 이렇게 만들었습니다. 하지만 이것들은 생일 파티, 교회 모임, 소규모 자선 행사, 그리고 집에서의 휴일 행사에서도 즐깁니다. \n\n읽어 주셔서 감사합니다. 여러분에게 조금이나마 아이디어와 영감을 주어 자신만의 타워와 뷔페 센터피스를 만드는 데 도움이 되었으면 좋겠어요.\n\n참배신 요리장군이 하늘에서 저를 내려다보고 계셨으면 좋겠어요. 그분은 저에게 많은 것을 알려 주셨고, 아마 저도 그분께 무언가 가르쳐 드렸을지도 모르겠어요.\n\n![이미지](/assets/img/2024-05-18-ElevateYourEasterBrunchorBuffet_8.png)","ogImage":{"url":"/assets/img/2024-05-18-ElevateYourEasterBrunchorBuffet_0.png"},"coverImage":"/assets/img/2024-05-18-ElevateYourEasterBrunchorBuffet_0.png","tag":["Tech"],"readingTime":4},{"title":"일상적인 식품과 소비재에 있는 최악의 독소들 - A부터 B까지","description":"","date":"2024-05-18 18:58","slug":"2024-05-18-WorstpoisonsineverydayfoodandconsumergoodsfromAtoB","content":"\n\n소비자 기업과 기관들에 맞서 싸울 차례입니다. 아직도 이러한 항목들을 제공하는 것은 가합입니다.\n\n![이미지](/assets/img/2024-05-18-WorstpoisonsineverydayfoodandconsumergoodsfromAtoB_0.png)\n\n이 목록에는 흡연, 전자담배, 알코올, 오락용 약물 복용, 매일 탄산음료 병 마시기(인삼이 신장에 해를 끼칩니다)와 같은 당연한 부분은 제외되어 있습니다.\n\n고려해야 할 점:\n- 이 목록은 소아나무 등에 대한 알레르기 반응으로 사망할 수 있는 재료와 같은 것은 포함되지 않았습니다.\n- 거대한 바질의 위험과 같은 고위험 식물의 위험 요소, 생물을 만지고 나서 손을 씻지 않고 먹는 등은 포함되어 있지 않습니다.\n- 자동차 창문 와이퍼에 세제 없이 물을 뿌려 발생한 레지오넬라, 물탱크에서 꼭대기 층 호텔 욕실 수도꼭지물 마시기 등은 제외되었습니다.\n- 분노를 어떻게 다루느냐도 몇 시간 동안 면역체계를 약화시킬 수 있는 일 중 하나입니다. 즉, 적대적인 것이나 질병을 일으키는 것도 많습니다. 정보를 알고 있고 경각심을 갖는 것이 중요합니다. 위험 요소를 제거하고 가위로 달려다니지 말라는 것은 그 중 하나입니다.\n\n<div class=\"content-ad\"></div>\n\n이 목록은 주요 가해자와 여러분이 왜 다발성 경화증이나 암에 걸렸는지 궁금해할 때 병원에 있는 이유를 잡는 데 일부러 설계되었습니다!\n\n# 피해야 할 독극물 상위 10선\n\n## 1. 수은\n\n- 내 이빨: 아말감 충전물\n- 빨간색 잉크가 들어간 문신 (전부 아니지만 라벨을 확인해보세요)\nhttps://www.scientificamerican.com/article/tattoo-ink-mercury-and-other-toxins/\n- 아말감 충전물이 들어간 상태에서 음식 또는 레몬 주스와 같은 산성 액체를 씹음\n- 아직도 아말감 충전물을 사용하는 치과 수술실 (드릴 작업 후에 재결정되는 대기 중 메틸 수은에 노출)\n- 장례식장에서 아말감에 들어있는 수은을 태우고 공기로 방출하는 경우\n- 통조림 참치나 다른 대형 어류를 섭취 (이중 타격, 수은에 가장 노출되는 대형 물고기를 담고 있는 알루미늄캔)\n\n<div class=\"content-ad\"></div>\n\n## 2. 리드\n\n- 오래된 집을 복원하고 벗겨져 나가는 리드 도료를 갈아내고 있습니다.\n- 리드로 된 책 표지를 가진 매우 오래된 책들의 사서입니다.\n- 지붕공사를 하는 사람으로서 손가락으로 리드 플래싱에 자주 접촉하지만 장갑을 착용하지 않습니다.\n- 전기 기사이거나 공장에서 일하는 사람으로서 납으로 된 납땜에서 전기 부품에 손을 대고 있습니다.\n- 납이 함유된 연료 시대에 오토바이를 타고 있었던 경험이 있습니다 — 그것이 금지되기 전에\n- 인도에서 산 허브 (죄송합니다 아유르베다) — 썩였는지 여부에 상관 없이 납을 포함하지 않는다는 것이 확인된 경우 — 쿠르크마, 툴시\n\n## 3. 농약 고위험 노출\n\n- 단단한 콘크리트를 만지는 것: 시기별로 살충제를 한 번 이상 사용하여 제초를 제어하고 있는 자치구. (어린이들이 슈퍼마켓 근처에서 놀며 알 수 없는 일정에 따라 농약이 뿌려진 후 2시간 후에 손바닥 서기나 축구공 차기 등을 하는 경우를 상상해보세요. 사용 지역에 경고표시가 있어야 합니다.)\n- 유기농이 아닌 과일, 견과류, 곡물, 샐러드를 섭취하는 것 (농약 사용량이 높음)\n기본적으로 — 비건이 되지 마세요\n- 농약 규제가 느슨한 남미에서 음식을 섭취하는 것\n- 제초제로 정원을 가꾸는 것 — 글리포세이트나 유사한 것들\n\n<div class=\"content-ad\"></div>\n\n## 4. 알루미늄 \n\n- 손상된 식품통에서 음식을 먹는 경우: 물질에 노출된 알루미늄이 액체로 스며들음 (특히 토마토 스프와 같은 산성 액체인 경우) \n- 알루미늄 냄비에서 요리하는 경우 \n- 탈취제 사용 (대부분의 제품에 알루미늄이 함유되어 있어 땀샘을 막아주지만, 탄산수소기반 대안을 사용하는 것이 좋음) \n\n## 5. PTFE \n\n- 방화제와 함께 작업하는 카펫이나 자동차 시트 공장에서 근무하는 경우 \n- 비스듬한 요리열로 논스틱 팬으로 정기적으로 요리하는 경우 \n- 하루 종일 영수증에 손을 건드리는 경우 \n- 피부에 PTFE를 흡수시키는 방수 처리된 의류로 운동하는 경우\n\n<div class=\"content-ad\"></div>\n\n## 6. 파라세톄몰 / 타이레놀 / 아세트아미노펜\n\n- 통증 완화를 위한 규칙적인 의약품 복용 — 실제로 간에 유해하며, 간은 신체의 다른 모든 독소의 주 독소 제거 기관입니다.\n\n## 7. 고온에서 음식 조리와 섭취\n\n- (자신에게 공기질 지수 모니터를 구입하시기 바랍니다) — pm2.5는 너무 높아서 우리가 가장 걱정해야 하는 것은 나무 난로가 아니라고 생각하게 만듭니다.\n\n<div class=\"content-ad\"></div>\n\n## 8. 옥살산\n\n- 상당한 양의 루바브, 시금치, 대두, 쇠비름, 아몬드, 비트, 다크 초콜릿을 섭취\n대부분의 음식에는 옥살산이 함유되어 있고 많은 사람들이 상당량을 허용할 수 있지만, 옥살산을 다량으로 섭취하는 경우 또는 옥살산이 포함된 이 음식들을 먹으면 옥살로박테르 포미제네스가 낮은 사람들은 확실히 만성 염증을 유발하고, 다른 오염물질의 해독을 약화시킬 것입니다.\n\n## 9. 야생 소금취크과 신경독 또는 솔라닌\n\nhttps://en.wikipedia.org/wiki/Solanine\n\n<div class=\"content-ad\"></div>\n\n- 갈색이 된 감자를 먹는 것\n- 감자 껍질을 많이 먹는 것\n- 토마토 줄기를 먹는 것\n\n**강가에서 수영하기**\n\n- 이곳은 모든 하수가 특히 폭우 중에 버려지는 배수로 이루어져 있어요.\n\n결론\n위의 어떤 하나도 피해를 입히는 원인을 심하게 드러내지 않을 수 있지만, 생물학적으로 누적적으로 불리할 수있는 부하를 고려하세요. 그리고 나이가 들면서 그 모든 것이 당신의 상태에 도움이 되는 것이라는 가능성을 깨달을 때가 됩니다. 그것을 관리하고 분별력 있게 해독할 현재의 의지, 능력 및 과학적 방법론이 여전히 있는지 생각해보세요. 10년 후에는 뼈 속의 납을 해독하는 더 나은 방법이 있을 수 있지만, 50년이 넘은 지금까지 가장 효과적인 방법은 DMSA 입니다.\n\n<div class=\"content-ad\"></div>\n\n# 기타\n\n## - DIY\n\n- 마스크를 착용하지 않고 모든 것에 샌딩\n- 석면을 확인하지 않고 벽을 드릴링\n- 마스크를 착용하지 않고 MDF 톱질 (포름알데히드)\n- 안경이나 마스크를 착용하지 않고 시멘트, 석고 또는 석회 혼합\n- 벽에 습기가 생기거나 곰팡이를 다루지 않음\n- 과거의 나무 놀이터 가구를 개조하거나 아이들이 놀면 (크로메이트 구리 비소 또는 크레오섯) 나무. 테스트했니?\n\n## - 알려지지 않은 건강 식품\n\n<div class=\"content-ad\"></div>\n\n- 디카페인 커피를 마셔요 (잔여물 — 메틸렌 염화물 용매 소량 포함)\n\n## - \"패스트 푸드 육류\" 먹기\n\n패스트 푸드 육류를 정기적으로 섭취하면 (동물 학대 수요 및 공급에 기여하여 메탄 이산화탄소 배출이 악화되는 침수 취약 지역에 노출될 확률이 더 많아지고, 강가에서 더 많은 독극물에 노출될 수도 있어요)\n\n# 피드백\n\n<div class=\"content-ad\"></div>\n\n의견을 자유롭게 남겨주세요. 필요시 목록을 수정하겠습니다.","ogImage":{"url":"/assets/img/2024-05-18-WorstpoisonsineverydayfoodandconsumergoodsfromAtoB_0.png"},"coverImage":"/assets/img/2024-05-18-WorstpoisonsineverydayfoodandconsumergoodsfromAtoB_0.png","tag":["Tech"],"readingTime":4},{"title":"라즈베리 파이 싱글 보드 컴퓨터의 MVP","description":"","date":"2024-05-18 18:57","slug":"2024-05-18-RaspberryPiTheMVPofSingleBoardComputers","content":"\n\n마이크로컨트롤러 개발 보드와 싱글 보드 컴퓨터의 다이내믹한 세계에서 한 기기가 두드러지게 빛납니다 — 라즈베리 파이! 이 신용 카드 크기의 컴퓨터는 정당하게 기술 애호가들의 상상력을 자극하며 취미가, 교육자, 전문가들을 매료시킵니다.\n라즈베리 파이에 대해 살펴보겠습니다 — 중요성, 다양한 모델, 주변 장치 및 다양한 응용분야.\n\n![Raspberry Pi](/assets/img/2024-05-18-RaspberryPiTheMVPofSingleBoardComputers_0.png)\n\n라즈베리 파이가 왜 필요할까요?\n\n## 라즈베리 파이의 필요성\n\n<div class=\"content-ad\"></div>\n\n- 가격: 라즈베리 파이 보드는 저렴해서 학생들과 취미로 하는 사람들에게 접근하기 쉽습니다.\n- 다양성: 이 보드는 다양한 운영 체제, 프로그래밍 언어 및 응용 프로그램을 지원합니다.\n- 커뮤니티 지원: 열정적인 이용자 및 개발자들로 구성된 방대한 커뮤니티가 설명서, 프로젝트 및 문제 해결 지원을 제공합니다.\n\n## 라즈베리 파이 모델 / 변형\n\n- 라즈베리 파이 제로:\n- 임베디드 프로젝트에 이상적인 소형 및 기본 모델.\n- Broadcom BCM2835 프로세서(1 GHz)와 512MB RAM 탑재.\n- 다른 모델과 비교하여 초소형 크기와 최소 전력 소비로 돋보임.\n- 라즈베리 파이 제로 W:\n- 파이 제로와 유사하지만 내장 Wi-Fi(802.11n) 및 블루투스 4.1.\n- 무선 IoT 응용프로그램 및 스마트 기기에 적합.\n- 라즈베리 파이 3:\n- Broadcom BCM2837 프로세서(1.2 GHz)와 1GB RAM 탑재.\n- 라즈베리 파이 제로 W보다 빠르며, 일반 컴퓨팅 작업, 미디어 스트리밍 및 IoT 응용프로그램에 적합.\n- 라즈베리 파이 4:\n- Broadcom BCM2711 프로세서(1.5 GHz) 탑재. 다양한 RAM 옵션(1GB, 2GB, 4GB 또는 8GB) 제공.\n- 듀얼 디스플레이 출력(4K 해상도) 및 기가비트 이더넷 지원.\n- 라즈베리 파이 3보다 빠르며, 데스크톱 컴퓨팅, 멀티미디어 및 서버 프로젝트에 상당한 처리 능력을 제공.\n- 라즈베리 파이 컴퓨트 모듈:\n- 산업 및 사용자 지정 프로젝트용으로 설계되었으며, Broadcom\n- BCM2837 프로세서(1.2 GHz) 및 최대 8GB eMMC 플래시 탑재.\n- 사용자 정의 하드웨어 솔루션 및 확장성이 필요한 프로젝트에 이상적입니다.\n\n## 라즈베리 파이 주변 기기\n\n<div class=\"content-ad\"></div>\n\n- 전원 공급: 최대 2.5A의 전원 공급을 위한 USB 포트.\n- MicroSD 카드: 운영 체제 및 데이터 저장용.\n- 40핀 확장 GPIO: 다양한 센서, 구동기 및 모듈 / 라즈베리 파이 햇들을 연결하기 위함.\n- 카메라 직렬 인터페이스: 라즈베리 파이 카메라 연결용.\n- 디스플레이 직렬 인터페이스: 터치스크린 디스플레이 연결용.\n- HDMI 포트: 모니터나 TV에 연결하기 위함.\n- 음향 출력: 오디오 잭에 스피커나 헤드폰 연결용.\n- USB 포트: 키보드 및 마우스, 웹캠, 외장하드 및 USB 사운드 카드와 같은 주변 기기 연결용.\n- WiFi, 이더넷: 인터넷 연결용.\n- Bluetooth Low Energy (BLE): 무선 키보드, 마우스 또는 게임 컨트롤러와 연결하기 위함.\n\n## 라즈베리 파이의 활용\n\n- 교육: 교실에서 프로그래밍, 전자 및 컴퓨팅 개념 가르치기.\n- IoT (사물 인터넷): 스마트 홈 장치, 기상 관측소 또는 보안 시스템 구축.\n- 미디어 센터: Kodi와 같은 플랫폼을 사용하여 멀티미디어 스트리밍 장치 생성.\n- 로봇 공학: 실험 및 프로토타입을 위한 로봇 및 자율 시스템 전원 공급.\n\n<img src=\"/assets/img/2024-05-18-RaspberryPiTheMVPofSingleBoardComputers_1.png\" />","ogImage":{"url":"/assets/img/2024-05-18-RaspberryPiTheMVPofSingleBoardComputers_0.png"},"coverImage":"/assets/img/2024-05-18-RaspberryPiTheMVPofSingleBoardComputers_0.png","tag":["Tech"],"readingTime":2}],"page":"41","totalPageCount":61,"totalPageGroupCount":4,"lastPageGroup":20,"currentPageGroup":2},"__N_SSG":true}