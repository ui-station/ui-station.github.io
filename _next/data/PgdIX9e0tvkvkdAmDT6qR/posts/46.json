{"pageProps":{"posts":[{"title":"파드맨으로 전환하기 도커의 오픈소스 대안","description":"","date":"2024-05-18 17:36","slug":"2024-05-18-SwitchingtoPodmananOpen-SourcealternativetoDocker","content":"\n\n2021년 8월 기준으로 Docker Desktop은 기업용 유료 구독이 필요하지만 CLI는 무료로 제공됩니다. 이 변경으로 일부 사용자들이 대안 옵션을 찾게 될 수 있습니다. 하지만 macOS 사용자로서 Docker Desktop은 Docker CLI를 실행하는 데 필수적이지만 걱정하지 마세요. 다른 옵션이 있습니다.\n\nColima와 Podman은 Docker의 가장 인기 있는 대체품 중 두 가지로, 둘 다 시도해본 결과 이 글에서는 컨테이너 관리를 위한 무료 오픈 소스 대안인 Podman에 초점을 맞출 것입니다.\n\nPodman은 제가 발견한 최고의 대안이며, 그 이유를 설명하겠습니다!\n\n- Docker 사용자이지만 CLI를 자주 사용하지 않는 경우, Podman은 데스크톱 애플리케이션을 갖추고 있어 무료이므로 훌륭한 선택입니다!\n- Docker 사용자이고 CLI만 사용하는 경우에도 Podman은 작동합니다!\n\n물론, Podman을 설치하고 docker `무언가`를 실행하려고 하면 작동하지 않을 것입니다. 그러나 이 글을 따라가면 Podman을 내 Docker 대체 도구로 사용하는 방법을 알 수 있습니다!\n\n<div class=\"content-ad\"></div>\n\n# Podman 설치 방법\n\nPodman을 설치하려면 데스크톱 앱을 포함하여 두 가지 명령어만 필요합니다:\n\n- Podman CLI 설치: brew install podman;\n- Podman 데스크톱 설치: brew install --cask podman-desktop;\n\n- 데스크톱 애플리케이션을 원하는 사용자를 위한 명령어임을 주의해주세요.\n\n<div class=\"content-ad\"></div>\n\n# 가상 머신을 시작하는 방법\n\nPodman을 설치한 후 가상 머신을 시작하려면 만들고 시작해야 합니다. 아래 단계를 따라 주세요:\n\n- podman machine init;\n- podman machine start;\n\n## 가상 머신이 성공적으로 초기화되었는지 어떻게 알 수 있나요?\n\n<div class=\"content-ad\"></div>\n\n가상 머신이 성공적으로 시작되었는지 확인하려면 터미널에서 `podman machine list`를 실행하십시오. 아래 스크린샷과 유사한 내용이 표시되어야 합니다. 여기에는 기본 머신이 현재 실행 중인 것이 표시됩니다:\n\n![스크린샷](/assets/img/2024-05-18-SwitchingtoPodmananOpen-SourcealternativetoDocker_0.png)\n\n# Podman과 함께 Docker Compose 사용하는 방법\n\n기본 설정에서 Docker Compose는 Podman을 \"Docker\" 인스턴스로 인식하지 않을 것입니다. 그러나 \"수정\"하여 사용할 수 있습니다!\n\n<div class=\"content-ad\"></div>\n\n어떤 일을 하기 전에 brew install docker-compose 명령을 사용하여 Docker Compose를 설치해야 합니다.\n\n그러나 이 시점에서 docker-compose up을 실행하면 \"Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?\"과 같은 오류 메시지가 표시될 것입니다.\n\nDocker Compose를 Podman과 함께 작동하도록 하려면 다음 단계를 따르세요:\n\n- sudo /usr/local/Cellar/podman/`podman-version`/bin/podman-mac-helper install;\n\n<div class=\"content-ad\"></div>\n\n- 참고: `podman-version`을(를) 사용 중인 Podman 버전으로 바꿔주세요.\n\n- podman machine stop && podman machine start;를 실행해주세요;\n\n이제 작동하는지 확인해볼 시간입니다! 기존의 docker-compose.yaml 파일을 사용하거나 새로 만들어서 docker-compose up -d를 실행해보세요.\n\n![이미지](/assets/img/2024-05-18-SwitchingtoPodmananOpen-SourcealternativetoDocker_1.png)\n\n<div class=\"content-ad\"></div>\n\n## 작동하지 않나요?\n\n이러한 단계를 따라도 Docker Compose가 여전히 동일한 오류(\"Docker 데몬에 연결할 수 없음...\")를 표시한다면, 아래 두 가지 해결 방법 중 하나를 시도해 보세요:\n\n- 다음 명령을 사용하여 DOCKER_HOST를 내보내려 해보세요: \n  ```sh\n  export DOCKER_HOST=`unix:///Users/your-user/.local/share/containers/podman/machine/podman-machine-default/podman.sock`\n  ```\n- rootful 권한으로 Podman Machine을 설정하려면 다음 명령을 사용하세요:\n  ```sh\n  podman machine stop && podman machine set --rootful && podman machine start\n  ```\n\n# Podman 명령어\n\n<div class=\"content-ad\"></div>\n\nDocker와 Podman 사이에는 많은 명령어가 유사하지만, 이미지 및 컨테이너 작업을 할 때 구문 및 동작에 차이가 있습니다. 특히 특정 명령어와 옵션에 대해 더 알아보려면 항상 Podman 설명서를 참고하거나 podman --help를 실행하는 것이 좋습니다.\n\n일부 예시를 살펴보겠습니다:\n\n- docker ps는 podman ps로 변경됩니다;\n- docker run은 podman run으로 변경됩니다;\n- docker rm `container`는 podman rm `container`로 변경됩니다;\n- 기타.\n\n다음은 docker와 함께 사용할 Podman 명령어에 별칭을 생성하는 단계입니다:\n\n<div class=\"content-ad\"></div>\n\n\n- 물고기 (Oh My Fish를 사용하는 경우):\n\n- IDE에서 파일 ~/.config/fish/conf.d/omf.fish을 엽니다;\n- 초기 설정 라인 (1에서 4까지) 다음에 다음 라인을 추가합니다: alias docker=\"podman\";\n- 터미널을 다시 시작하거나 source ~/.config/fish/conf.d/omf.fish을 실행합니다.\n\n- Zsh의 경우:\n\n- IDE에서 파일 ~/.zshrc을 엽니다;\n- # Example aliases 주석 다음에 다음 라인을 추가합니다: alias docker=\"podman\";\n- 터미널을 다시 시작하거나 source ~/.zshrc을 실행합니다.\n\n<div class=\"content-ad\"></div>\n\n- Bash에 대한 설명:\n\n  - IDE ****에서 파일 ~/.bashrc을 열어주세요;\n  - 다음 줄을 파일 끝에 추가해주세요: alias docker=\"podman\";\n  - 터미널을 재시작하거나 source ~/.bashrc을 실행해주세요.\n\n해당 alias를 생성한 후에는 Docker와 동일하게 docker 명령을 사용할 수 있지만 해당 명령은 Podman 명령을 실행합니다.\n\n# Podman 데스크톱\n\n<div class=\"content-ad\"></div>\n\n\n![Switching to Podman: an Open-Source alternative to Docker](/assets/img/2024-05-18-SwitchingtoPodmananOpen-SourcealternativetoDocker_2.png)\n\n이미 이전에 언급한 바와 같이, Podman은 CLI를 사용하기를 원하지 않는 경우 필요한 모든 옵션을 갖춘 데스크톱 애플리케이션을 갖고 있습니다. 아래 이미지는 일상적으로 사용할 수 있는 가장 중요한 화면을 보여줍니다.\n\nDocker Desktop과 유사하게, 이 앱은 컨테이너, 이미지 및 볼륨에 대한 메뉴를 갖고 있어 쉽게 작업을 수행할 수 있습니다.\n\n![Switching to Podman: an Open-Source alternative to Docker](/assets/img/2024-05-18-SwitchingtoPodmananOpen-SourcealternativetoDocker_3.png)\n\n\n<div class=\"content-ad\"></div>\n\n![Switching to Podman: an Open-Source Alternative to Docker](/assets/img/2024-05-18-SwitchingtoPodmananOpen-SourcealternativetoDocker_4.png)\n\n![Switching to Podman: an Open-Source Alternative to Docker](/assets/img/2024-05-18-SwitchingtoPodmananOpen-SourcealternativetoDocker_5.png)\n\n이미지만 봐도 이해하기 쉬울 거에요. 궁금한 점 있으면 댓글로 남겨주세요.\n\n참고: Podman Desktop을 설치하면 가상 머신이 로그인 시 시작하도록 설정을 변경할 수 있습니다. 이렇게 하면 매번 podman machine start를 실행할 필요가 없어요.\n\n<div class=\"content-ad\"></div>\n\n개발자로서 제 생각이에요. 아마도 당신에게는 Podman이 모든 필요를 충족시키지 못할 수도 있어요. 그러나 제 일상 사용에는 충분하고, 지금까지 어떤 문제도 만나지 않았어요.\n\n요약하면, Podman은 Docker에 대한 강력한 대안으로, 안전하고 가벼운 실행 환경, Docker와 유사한 명령줄 인터페이스, 데몬이 필요하지 않은 macOS 및 Linux 배포판에서 실행할 수 있는 기능과 같은 많은 이점을 제공해요. Docker 대체품을 찾고 있다면, Podman은 분명히 확인할 가치가 있어요.\n\n이 글이 도움이 되었으면 좋겠어요!","ogImage":{"url":"/assets/img/2024-05-18-SwitchingtoPodmananOpen-SourcealternativetoDocker_0.png"},"coverImage":"/assets/img/2024-05-18-SwitchingtoPodmananOpen-SourcealternativetoDocker_0.png","tag":["Tech"],"readingTime":5},{"title":"쿠버네티스와 커널 패닉","description":"","date":"2024-05-18 17:35","slug":"2024-05-18-KubernetesAndKernelPanics","content":"\n\n넷플릭스의 컨테이너 플랫폼이 리눅스 커널 패닉을 쿠버네티스 파드로 연결하는 방법\n\n카일 앤더슨\n\n최근에는 컨테이너 플랫폼 Titus에서 엔지니어(최종 사용자가 아닌)의 고통을 줄이기 위한 노력이 있었습니다. 나는 \"고아\" 파드를 조사하기 시작했습니다. 완료되지 못한 파드들로, 만족스럽지 못한 최종 상태로 가비지 컬렉션되어야 했습니다. 우리의 서비스 작업(ReplicatSet같이 생각하십시오) 소유자들은 그리 심하게 신경쓰지 않지만, 우리의 배치 사용자들은 신경을 많이 씁니다. 실제로 반환 코드가 없다면, 다시 시도해도 안전한지 아닌지 어떻게 알 수 있을까요?\n\n이러한 고아 파드들은 시스템 전체 파드 중 소수지만 사용자들에게 진짜 고통을 미칩니다. 정확히 어디로 가는 것인가요? 왜 사라졌나요?\n\n<div class=\"content-ad\"></div>\n\n이 블로그 포스트는 최악의 시나리오인 커널 패닉부터 Kubernetes(k8s)까지 연결하여 마침내 우리 운영자들이 우리의 k8s 노드가 왜 어떻게 사라지는지 추적할 수 있도록 안내하는 방법을 보여줍니다.\n\n# 유랑된 Pod들은 어디에서 왔을까요?\n\n유랑된 Pod들은 기본 k8s 노드 객체가 사라지기 때문에 분실됩니다. 그렇게 되면 GC 프로세스가 Pod를 삭제합니다. Titus에서는 Pod 및 Node 객체의 이력을 저장해 사용자들에게 설명을 제공할 수 있도록하는 사용자 지정 컨트롤러를 실행합니다. 우리의 UI에서 이러한 실패 모드는 다음과 같이 보입니다:\n\n![이미지](/assets/img/2024-05-18-KubernetesAndKernelPanics_0.png)\n\n<div class=\"content-ad\"></div>\n\n이 설명은 설득력이 부족했나봐요. 에이전트가 어디로 사라졌는지 궁금하죠?\n\n# 잃어버린 노드는 어디서 왔을까요?\n\n노드는 어떤 이유로든 사라질 수 있어요, 특히 \"클라우드\"에서 말이죠. 그럴 때는 일반적으로 클라우드 벤더에 의해 제공되는 k8s 클라우드 컨트롤러가 실제 서버, 이 경우에는 EC2 인스턴스,가 실제로 없어졌다는 것을 감지하고, 이에 따라 k8s 노드 객체를 삭제할 거에요. 그래도 \"왜\"라는 질문에 정말로 대답하지 못하겠죠.\n\n우리는 어떻게 해야 할까요? 모든 사라진 인스턴스에 이유를 부여하고, 그 이유를 감안하며, 이것을 포드까지 전달할 수 있을까요? 이 모든 것은 주석에서 시작돼요:\n\n<div class=\"content-ad\"></div>\n\n```js\n{\n     \"apiVersion\": \"v1\",\n     \"kind\": \"Pod\",\n     \"metadata\": {\n          \"annotations\": {\n               \"pod.titus.netflix.com/pod-termination-reason\": \"Something really bad happened!\",\n...\n```\n\n이 데이터를 넣을 수 있는 장소를 만드는 것만으로도 좋은 시작이에요. 이제 우리의 GC 컨트롤러들이 이 주석을 인식하도록 만들고, 예기치 못하게 파드나 노드를 종료시킬 수 있는 어떠한 프로세스에도 이를 뿌리는 것만 하면 돼요. 상태를 수선하는 대신 주석을 추가함으로써 기록 목적을 위해 파드의 나머지 부분을 그대로 유지할 수 있어요. (종료 이유를 나타내기 위해 종료한 것에 대한 주석을 추가합니다)\n\npod-termination-reason 주석은 다음과 같은 인간이 읽을 수 있는 메시지를 작성하는 데 유용해요:\n\n- “이 파드는 더 높은 우선 순위 작업($id)에 의해 예약 해제되었습니다”\n- “이 파드는 하부 하드웨어의 장애($failuretype)로 종료되어야 했습니다”\n- “$user가 노드에서 sudo halt 명령을 실행했기 때문에 이 파드를 종료해야 했습니다”\n- “하부 노드 커널이 패닉 상태에 빠져 이 파드가 예기치 않게 종료되었습니다!”\n  \n\n<div class=\"content-ad\"></div>\n\n하지만 기다려봐, 커널 패닉에 빠진 노드에 대한 팟을 어떻게 주석 처리할 수 있을까요?\n\n# 커널 패닉 캡처\n\n리눅스 커널이 패닉에 빠지면 할 일이 별로 없어요. 하지만 만약 \"마지막 숨통으로 커버네티스에 저주를 내립니다!\"라는 UDP 패킷을 보낼 수 있다면 어떨까요?\n\nGoogle Spanner 논문에서 영감을 받아 Spanner 노드가 리스 및 락을 해제하기 위해 \"마지막 끼통\" UDP 패킷을 보내는 것처럼, 당신도 주식 리눅스 모듈인 netconsole을 사용하여 커널 패닉 시 서버를 설정할 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n# 넷콘솔 설정\n\n리눅스 커널이 심각한 상황에서 UDP 패킷을 '커널 패닉' 문자열과 함께 전송할 수 있다는 사실은 정말 놀랍죠. 이는 netconsole이 사전에 거의 모든 IP 헤더가 채워진 상태로 구성되어 있어야 한다는 것 때문에 가능합니다. 맞아요, Linux에게 소스 MAC, IP, UDP 포트 및 대상 MAC, IP, UDP 포트를 정확히 알려주어야 합니다. 특히, 커널을 위한 UDP 패킷을 거의 만들어 주는 것과 같죠. 그러나 그 전 작업을 해두면 시간이 지나면서 커널이 쉽게 패킷을 구성하고 (미리 구성된) 네트워크 인터페이스를 통해 전송할 수 있습니다. 다행히 netconsole-setup 명령어를 통해 설정을 간단히 할 수 있습니다. 모든 구성 옵션은 동적으로 설정할 수 있어서, 대상이 변경되면 새 IP로 바로 가리킬 수 있습니다.\n\n이 설정을 하면 모듈 로딩 후 커널 메시지가 즉시 흐르기 시작합니다. 마치 dmesg | netcat -u $대상 6666와 같이 전체 프로세스가 커널 공간에서 작동하는 것을 상상해보세요.\n\n# 넷콘솔 \"마지막 발악\" 패킷\n\n<div class=\"content-ad\"></div>\n\nnetconsole을 설정하면, 충돌하는 커널로 인한 마지막 노후는 예상대로 UDP 패킷 세트처럼 보입니다. UDP 패킷의 데이터는 간단히 커널 메시지의 텍스트입니다. 커널 패닉인 경우, 다음과 같이 보일 것입니다 (한 줄에 하나의 UDP 패킷):\n\n```js\nKernel panic - not syncing: buffer overrun at 0x4ba4c73e73acce54\n[ 8374.456345] CPU: 1 PID: 139616 Comm: insmod Kdump: loaded Tainted: G OE\n[ 8374.458506] Hardware name: Amazon EC2 r5.2xlarge/, BIOS 1.0 10/16/2017\n[ 8374.555629] Call Trace:\n[ 8374.556147] <TASK>\n[ 8374.556601] dump_stack_lvl+0x45/0x5b\n[ 8374.557361] panic+0x103/0x2db\n[ 8374.558166] ? __cond_resched+0x15/0x20\n[ 8374.559019] ? do_init_module+0x22/0x20a\n[ 8374.655123] ? 0xffffffffc0f56000\n[ 8374.655810] init_module+0x11/0x1000 [kpanic]\n[ 8374.656939] do_one_initcall+0x41/0x1e0\n[ 8374.657724] ? __cond_resched+0x15/0x20\n[ 8374.658505] ? kmem_cache_alloc_trace+0x3d/0x3c0\n[ 8374.754906] do_init_module+0x4b/0x20a\n[ 8374.755703] load_module+0x2a7a/0x3030\n[ 8374.756557] ? __do_sys_finit_module+0xaa/0x110\n[ 8374.757480] __do_sys_finit_module+0xaa/0x110\n[ 8374.758537] do_syscall_64+0x3a/0xc0\n[ 8374.759331] entry_SYSCALL_64_after_hwframe+0x62/0xcc\n[ 8374.855671] RIP: 0033:0x7f2869e8ee69\n...\n```\n\n# 쿠버네티스에 접속\n\n마지막 단계는 쿠버네티스(k8s)에 연결하는 것입니다. 다음을 수행하는 k8s 컨트롤러가 필요합니다:\n\n<div class=\"content-ad\"></div>\n\n- 포트 6666에서 netconsole UDP 패킷을 수신하여 노드에서 발생하는 커널 패닉처럼 보이는 것을 감시합니다.\n- 커널 패닉 발생 시, 들어오는 netconsole 패킷의 IP 주소와 관련된 k8s 노드 객체를 찾습니다.\n- 해당 k8s 노드에서 바인딩된 모든 팟을 찾아서 주석을 추가한 후 해당 팟을 삭제합니다 (팟이 다 녹아버리겠군요!).\n- 해당 k8s 노드에 노드 주석을 추가한 다음 노드도 삭제합니다 (노드도 다 녹아버리겠군요!).\n\n1부 및 2부는 다음과 같이 보일 수 있습니다:\n\n```js\nfor {\n    n, addr, err := serverConn.ReadFromUDP(buf)\n    if err != nil {\n        klog.Errorf(\"Error ReadFromUDP: %s\", err)\n    } else {\n        line := santizeNetConsoleBuffer(buf[0:n])\n        if isKernelPanic(line) {\n            panicCounter = 20\n            go handleKernelPanicOnNode(ctx, addr, nodeInformer, podInformer, kubeClient, line)\n        }\n    }\n    if panicCounter > 0 {\n        klog.Infof(\"KernelPanic context from %s: %s\", addr.IP, line)\n        panicCounter++\n    }\n}\n```\n\n그리고 3부와 4부는 다음과 같이 보일 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nfunc handleKernelPanicOnNode(ctx context.Context, addr *net.UDPAddr, nodeInformer cache.SharedIndexInformer, podInformer cache.SharedIndexInformer, kubeClient kubernetes.Interface, line string) {\n    node := getNodeFromAddr(addr.IP.String(), nodeInformer)\n    if node == nil {\n        klog.Errorf(\"Got a kernel panic from %s, but couldn't find a k8s node object for it?\", addr.IP.String())\n    } else {\n        pods := getPodsFromNode(node, podInformer)\n        klog.Infof(\"Got a kernel panic from node %s, annotating and deleting all %d pods and that node.\", node.Name, len(pods))\n        annotateAndDeletePodsWithReason(ctx, kubeClient, pods, line)\n        err := deleteNode(ctx, kubeClient, node.Name)\n        if err != nil {\n            klog.Errorf(\"Error deleting node %s: %s\", node.Name, err)\n        } else {\n            klog.Infof(\"Deleted panicked node %s\", node.Name)\n        }\n    }\n}\n```\n\n위 코드를 넣으면 커널 패닉이 감지되자마자 pod와 노드가 즉시 사라집니다. 어떤 GC 프로세스를 기다릴 필요가 없습니다. 주석은 노드 및 pod에 무슨 일이 일어났는지 문서화하는 데 도움이 됩니다:\n\n<img src=\"/assets/img/2024-05-18-KubernetesAndKernelPanics_1.png\" />\n\n# 결론\n\n\n<div class=\"content-ad\"></div>\n\n작업이 커널 패닉 때문에 실패했다는 것을 고객님에게 알리는 것은 만족스럽지 않을 수도 있습니다. 그러나 커널 패닉을 해결하기 위해 필요한 관측 도구를 갖추게 된 사실에 기쁨을 느끼실 수 있을 거예요!\n\n시스템에서 왜 실패하는 지 정말로 깊이 파악하는 것이 즐거우셨나요? 혹은 커널 패닉이 멋지게 느껴지시나요? 저희 Compute 팀에 참여해 주세요. 저희는 엔지니어들을 위한 세계적 수준의 컨테이너 플랫폼을 구축 중이에요.","ogImage":{"url":"/assets/img/2024-05-18-KubernetesAndKernelPanics_0.png"},"coverImage":"/assets/img/2024-05-18-KubernetesAndKernelPanics_0.png","tag":["Tech"],"readingTime":7},{"title":"Samba를 사용하여 CIFS 파일 시스템 유형을 이용해 공유 폴더를 마운트하는 방법","description":"","date":"2024-05-18 17:34","slug":"2024-05-18-HowtoMountaSharedFolderUsingSambawithCIFSFilesystemType","content":"\n\n안녕하세요! 이 튜토리얼에서는 Linux 시스템에서 올바른 파일 시스템 유형(cifs)을 사용하여 Samba를 사용하여 호스트 머신의 공유 폴더를 마운트하는 단계를 살펴볼 것입니다.\n\n# 단계 1: Samba 공유 설정\n\nSamba 설치: 먼저 호스트 머신에 Samba를 설치합니다:\n\n```js\nsudo apt update\nsudo apt install samba\n```\n\n<div class=\"content-ad\"></div>\n\nSamba 구성: Samba 구성 파일을 편집하세요:\n\n```js\nsudo vim /etc/samba/smb.conf\n```\n\n파일의 끝에 다음 라인을 추가하세요:\n\n```js\n[shared_folder]\npath = /공유할/폴더/경로\nwritable = yes\nguest ok = yes\n```\n\n<div class=\"content-ad\"></div>\n\n# 단계 2: 필요한 패키지 설치\n\n시스템에 cifs-utils 패키지가 설치되어 있는지 확인하세요. 패키지 관리자를 사용하여 설치할 수 있습니다:\n\n```js\nsudo apt update\nsudo apt install cifs-utils\n```\n\n# 단계 3: 호스트 머신의 IP 주소 찾기\n\n<div class=\"content-ad\"></div>\n\n다음 명령을 사용하여 호스트 머신의 IP 주소를 찾을 수 있습니다:\n\n```js\nip addr show | grep inet | grep -v 127.0.0.1 | awk '{print $2}' | cut -d'/' -f1\n```\n\n이 명령은 호스트 머신의 IP 주소를 출력합니다.\n\n# 4단계: 마운트 포인트 만들기\n\n<div class=\"content-ad\"></div>\n\n공유 폴더를 마운트할 디렉토리를 생성해보세요. 예를 들어, 홈 디렉토리에 shared_folder라는 디렉토리를 만들어봅시다:\n\n```js\nmkdir ~/shared_folder\n```\n\n# 단계 5: 공유 폴더 마운트하기\n\n마운트 명령을 사용하여 공유 폴더를 마운트하세요. host_ip를 호스트 머신의 IP 주소로, shared_folder_name을 공유 폴더의 이름으로 대체하세요:\n\n<div class=\"content-ad\"></div>\n\n```js\nsudo mount -t cifs //호스트IP/공유폴더명 ~/공유폴더 -o guest\n```\n\n만약 공유 폴더에 인증이 필요하다면 사용자 이름과 비밀번호를 제공할 수도 있어요:\n\n```js\nsudo mount -t cifs //호스트IP/공유폴더명 ~/공유폴더 -o username=당신의사용자이름,password=당신의비밀번호\n```\n\n# 단계 6: 마운트 확인하기\n\n<div class=\"content-ad\"></div>\n\n공유된 폴더가 올바르게 마운트되었는지 확인하려면 마운트 지점 디렉터리의 내용을 나열하여 확인해보세요:\n\n```js\nls ~/shared_folder\n```\n\n이 명령을 실행하면 공유된 폴더의 내용이 나열됩니다.\n\n# 단계 7: 파일 접근 및 수정\n\n<div class=\"content-ad\"></div>\n\n이제 로컬 머신에서 공유 폴더의 파일에 직접 액세스하고 수정할 수 있어요.\n\n# 단계 8: 공유 폴더에서 마운트 해제하기 (선택 사항)\n\n공유 폴더 작업을 완료했을 때 umount 명령을 사용하여 마운트를 해제할 수 있어요:\n\n```js\nsudo umount ~/shared_folder\n```\n\n<div class=\"content-ad\"></div>\n\n# 단계 9: 자동 마운트 (선택 사항)\n\n시스템 부팅할 때마다 공유 폴더를 자동으로 마운트하려면 /etc/fstab 파일에 항목을 추가할 수 있습니다.\n\n```js\n//host_ip/shared_folder_name  /home/your_username/shared_folder  cifs  guest  0  0\n```\n\n호스트 IP, 공유 폴더 이름 및 /home/your_username/shared_folder를 세팅에 맞는 적절한 값으로 교체해주세요.\n\n<div class=\"content-ad\"></div>\n\n위 항목을 추가한 후 시스템을 재부팅하거나 다음과 같이 수동으로 공유 폴더를 마운트할 수 있습니다:\n\n```js\nsudo mount -a\n```\n\n끝났어요! 이제 올바른 파일 시스템 유형(cifs)을 사용하여 Samba를 통해 공유 폴더를 마운트했습니다. 이제 공유 폴더의 파일에 액세스하고 필요에 따라 작업할 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-18-HowtoMountaSharedFolderUsingSambawithCIFSFilesystemType_0.png"},"coverImage":"/assets/img/2024-05-18-HowtoMountaSharedFolderUsingSambawithCIFSFilesystemType_0.png","tag":["Tech"],"readingTime":3},{"title":"원격 액세스 보안하는 방법 SSH 키 사용 안내","description":"","date":"2024-05-18 17:32","slug":"2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys","content":"\n\nSSH 키 기반 인증을 사용하여 SSH 연결을 안전하게 하는 단계별 가이드\n\n![SSH Key-Based Authentication](/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_0.png)\n\n오늘의 글은 SSH 원격 세션의 보안을 강화하는 간단한 자습서를 제공합니다. Linux 서버에 SSH 키 기반 인증을 설정하는 방법에 중점을 두고 덜 안전한 암호 기반 인증에서 전환하는 방법을 안내합니다. 마지막으로 SSH 서버를 더 안전하게 하는 추가 방법에 대한 보너스 팁을 공유할 것입니다.\n\n# 개요\n\n<div class=\"content-ad\"></div>\n\nSSH (Secure Shell) 키 기반 인증은 원격 서버에서 사용자의 신원을 인증하기 위해 암호화 키 쌍을 사용하는 보안 방법입니다. 이 방법은 컴퓨터에 공개 및 비밀 키 쌍을 생성하여 저장하고, SSH 서버를 구성하여 이러한 키를 인식하고 수락하도록 설정하는 것을 포함합니다. 이는 기존 암호 기반 인증과 관련된 위험을 줄이는 것으로 보안을 크게 향상시킵니다.\n\nSSH 키는 쌍으로 생성되고 일반 텍스트 파일로 저장됩니다. 키 쌍은 두 부분으로 구성됩니다:\n\n- 🔒 공개 키: 이 부분은 SSH 서버에 저장됩니다. 안전하게 공유할 수 있어 해당 서버가 연결할 때 신원을 인식할 수 있습니다.\n- 🔑 비밀 키: 이 부분은 사용자의 컴퓨터에 저장되어야 하며 항상 안전하게 보관되어야 합니다. 이를 사용하여 서버와 인증하며, 절대로 공유해서는 안 됩니다. 비밀 키는 파일을 읽을 수 없도록 사용 권한을 설정해야 합니다.\n\n## 작동 방식\n\n<div class=\"content-ad\"></div>\n\n- 컴퓨터에서 공개 및 개인 키 쌍을 생성합니다.\n- 서버는 공개 키를 인식하고 해당하는 개인 키가 인증 중에 사용되면 액세스를 허용하도록 구성됩니다.\n- 선택적으로 개인 키에 암호를 설정하여 추가 보안을 제공할 수 있습니다. 이 암호는 잘못된 손에 키가 넘어갈 경우 추가 보호층을 제공합니다.\n\n# SSH 키를 사용한 인증의 장점\n\nSSH 키 기반 인증은 비밀번호보다 더 나은 대안이므로 보안성과 편리성이 강화됩니다. 이렇게 왜 SSH 키를 사용해야 하는지 살펴보겠습니다:\n\n- 향상된 보안: 키가 고유하고 추측하기 어려우므로 키 기반 인증은 브루트 포스 공격에 저항합니다.\n- 자격 증명 노출 위험 감소: 서버가 침해당한 경우 권한 부여 자격 증명이 노출되는 위험이 없습니다.\n- 사용의 용이성: 사용자들은 복잡한 암호를 기억하거나 적어두지 않아도 되므로, 암호 관련 위반 사례의 위험이 줄어듭니다.\n- 자동화 지원: 암호 입력이 필요하지 않기 때문에 작업을 자동화할 수 있으며, 수동 개입 없이 Ansible과 같은 스크립트 및 도구가 SSH 서버와 상호작용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# SSH를 위한 공개 키 인증 설정하기\n\n기본 사항을 다뤘으니, 이 작업을 완료하는 단계에 대해 자세히 살펴보겠습니다.\n\nSSH 키 쌍을 만드는 두 가지 옵션이 있습니다: Windows 기계 또는 Linux 기계에서. 단계는 일반적으로 비슷하지만, 각 환경에서 사용하는 소프트웨어 도구는 다릅니다.\n\n## 방법 1: Linux에서 SSH 키 쌍 생성하기\n\n<div class=\"content-ad\"></div>\n\n스텝 1: Ed25519 알고리즘을 사용하여 새 SSH 키 쌍을 생성하세요.\n\n이 단계는 키페어를 로컬 컴퓨터에서 생성한 후에 나중에 서버로 업로드할 것으로 가정합니다. 서버에서 키페어를 생성하고 개인 키를 로컬 호스트로 다운로드하는 것보다 안전합니다.\n\nEd25519 알고리즘을 사용하여 새 키 쌍을 생성하세요:\n\n```js\nssh-keygen -t ed25519 -C \"cybersecmav@warfare.systems\"\n```\n\n<div class=\"content-ad\"></div>\n\n- -t: 알고리즘의 종류 (키), 우리의 경우 Ed25519.\n- -C: SSH 키를 구분할 수 있도록 도와주는 설명 (선택 사항).\n\n파일 이름을 요구하면 기본 이름과 경로를 수락하려면 Enter 키를 누르세요. SSH 키는 일반적으로 ~/.ssh/ 디렉터리에 저장됩니다.\n\n![이미지](/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_1.png)\n\n단계 2: 원격 서버 준비하기\n\n<div class=\"content-ad\"></div>\n\n만약 ~/.ssh 디렉토리와 authorized_keys 파일이 존재하지 않는다면 다음을 실행해주세요:\n\n```js\nmkdir ~/.ssh\ntouch ~/.ssh/authorized_keys\n```\n\n~/.ssh 디렉토리에 위치한 authorized_keys 파일은 SSH 서버에 액세스할 수 있는 공개 키 목록을 포함하고 있습니다.\n\n~/.ssh 디렉토리와 authorized_keys 파일에 적절한 파일 권한을 설정해주세요:\n\n<div class=\"content-ad\"></div>\n\n```js\nchmod 700 ~/.ssh\nchmod 600 ~/.ssh/authorized_keys\n```\n\n- chmod 700 ~/.ssh: 해당 디렉토리의 파일을 읽기, 쓰기, 실행할 수 있는 권한을 소유자에게만 부여합니다.\n- chmod 600 ~/.ssh/authorized_keys: 소유자에게만 파일에 액세스할 수 있도록 제약을 두어 다른 사람이 파일을 보거나 수정하는 것을 방지하여 SSH 키를 보호합니다.\n\n로컬 머신에서 공개 키를 원격 서버로 업로드하세요:\n\n```js\nscp id_ed2551.pub cybersecmav@warfare.systems:/home/cybersecmav/id_ed2551.pub\n```  \n\n<div class=\"content-ad\"></div>\n\n아래와 같이 업로드한 공개 키를 .ssh/ 디렉터리로 이동해 주세요:\n\n```js\nmv id_ed2551.pub ~/.ssh/\nchmod 600 ~/.ssh/id_ed2551.pub\n```\n\n공개 키의 출력을 authorized_keys 파일로 복사해 주세요:\n\n```js\ncat ~/.ssh/id_ed2551.pub >> ~/.ssh/authorized_keys\n```\n\n<div class=\"content-ad\"></div>\n\nauthorized_keys의 내용을 확인하여 공개 키가 추가되었는지 확인해보세요:\n\n```js\ncat .ssh/authorized_keys\nssh-ed25519 AAA<<...REDACTED......>>1uEqXysh cybersecmav@warfare.systems\n```\n\n모든 올바른 폴더 및 파일 권한이 있는지 확인해봅시다:\n\n```js\ncybersecmav@ares:~$ cd .ssh\ncybersecmav@ares:~/.ssh$ ls -la\ntotal 16\ndrwx------ 2 cybersecmav cybersecmav 4096 Apr 26 14:32 .\ndrwxr-xr-x 5 cybersecmav cybersecmav 4096 Apr 29 13:32 ..\n-rw------- 1 cybersecmav cybersecmav  109 Apr 26 14:33 authorized_keys\n-rw-r--r-- 1 cybersecmav cybersecmav  109 Apr 23 19:49 id_ed2551.pub\n```\n\n<div class=\"content-ad\"></div>\n\nStep 3: 공개 키 인증을 지원하도록 SSH 서버 구성하기\n\n편집을 위해 SSH 서버 구성 파일을 엽니다:\n\n```js\nsudo nano /etc/ssh/sshd_config\n```\n\nPubkeyAuthentication 설정을 찾아서 아래로 스크롤합니다. \"no\"에서 \"yes\"로 변경하세요. 또한, AuthorizedKeysFile로 시작하는 줄이 주석 처리되어 있지 않은지 확인하거나 누락된 경우 추가하세요.\n\n<div class=\"content-ad\"></div>\n\n```plaintext\nPubkeyAuthentication yes\nAuthorizedKeysFile .ssh/authorized_keys .ssh/authorized_keys2\n```\n\n다음은 /etc/sshd_config 파일이 보이는 방식입니다:\n\n![2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_2.png](/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_2.png)\n\n4단계: 구성 변경을 적용하기 위해 SSH 서버를 다시로드하세요\n\n\n<div class=\"content-ad\"></div>\n\nsshd_config 파일을 변경할 때는 변경 사항이 적용되려면 SSH 서버를 다시로드하거나 다시 시작해야 합니다.\n\nDebian/Ubuntu:\n\n```js\nsudo systemctl reload ssh\nsudo systemctl restart ssh\n````\n\nRedhat/CentOS:\n\n<div class=\"content-ad\"></div>\n\n```js\nsudo systemctl reload sshd\nsudo systemctl restart sshd\n```\n\n## 방법 2: Windows에서 SSH 키 쌍 생성\n\n로컬 머신으로 Windows를 사용하고 있다면, PuTTY 클라이언트의 키 생성기인 puttygen.exe를 사용하여 SSH 키 쌍을 생성할 수 있습니다.\n\n- 다음 위치에서 PuTTY를 다운로드하세요: https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html\n- puttygen.exe를 엽니다. 기본적으로 RSA를 키 생성으로 선택하지만, 원격 SSH 서버가 지원하는 경우 ED25519를 선택할 수도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_3.png\" />\n\n- \"Generate\"를 클릭하여 새로운 공개/개인 키 쌍을 생성합니다.\n\n<img src=\"/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_4.png\" />\n\n- 나중에 원격 서버의 ~/.ssh/ 디렉토리의 authorized_keys 파일에 붙여 넣을 공개 키를 복사합니다.\n\n<div class=\"content-ad\"></div>\n\n\n![image](/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_5.png)\n\n- Save the public key as: id_ed2551.pub\n- Save the private key as: id_ed2551.ppk\n\n![image](/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_6.png)\n\n- Alternatively, you can save them using the File menu option\n\n\n<div class=\"content-ad\"></div>\n\n\n![Save and keep a copy of your SSH keys](/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_7.png)\n\n![SSH key image 2](/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_8.png)\n\n![SSH key image 3](/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_9.png)\n\n\n<div class=\"content-ad\"></div>\n\n- `/home/username/.ssh/authorized_keys` 파일에 공개 키 값을 새 줄에 붙여 넣으세요.\n\n![Step 10](/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_10.png)\n\n- 윈도우즈에서 PuTTY SSH 클라이언트를 사용하여 키 기반 인증을 통한 원격 호스트로의 SSH 연결을 테스트합니다.\n- putty.exe 클라이언트를 열고 원격 SSH 서버 세부 정보를 입력하세요.\n\n![Step 11](/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_11.png)\n\n<div class=\"content-ad\"></div>\n\n- 지금 가장 중요한 단계는 리모트 서버에 연결하기 전에 방금 생성한 올바른 개인 키를 선택했는지 확인하는 것입니다.\n\n![SSH Key](/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_12.png)\n\n- \"Open\"을 클릭하면 원격 대상과의 SSH 세션이 열립니다.\n\n- 이제 새로운 공개/개인 키 쌍을 사용하여 인증된 SSH 세션이 열려 있어야 합니다. 아래 예시를 확인해주세요.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_13.png\" />\n\n이제 SSH 키 기반 인증으로 로그인되었습니다.\n\n# 추가 정보: SSH 서버 보안 팁\n\nSSH 키 기반 인증의 기본 사항을 다룬 이제, SSH 서버를 보다 더 보호하기 위한 몇 가지 추가 보안 팁을 살펴봅시다. 이러한 모범 사례를 시행함으로써 SSH 서버의 보안성을 높일 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 팁 1: 비밀번호 인증 비활성화\n\nSSH 키 기반 인증이 작동하는지 확인한 후, SSH 구성 파일인 /etc/ssh/sshd_config에서 PasswordAuthentication을 \"no\"로 설정하여 비밀번호 기반 로그인을 비활성화하세요.\n\n```sh\nsudo nano /etc/ssh/sshd_config\n``` \n\n![이미지](/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_14.png)\n\n<div class=\"content-ad\"></div>\n\n## 팁 2: 루트 로그인 제한\n\nSSH를 통한 직접적인 루트 액세스를 방지하려면 PermitRootLogin을 \"no\"로 설정하세요. 이렇게 하면 사용자가 루트 계정으로 로그인하는 것이 불가능해지며 관리 작업을 위해 sudo를 사용해야 합니다.\n\n![이미지](/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_15.png)\n\n## 팁 3: 비표준 SSH 포트 사용\n\n<div class=\"content-ad\"></div>\n\n기본 SSH 포트를 22에서 더 높거나 보통과 다른 숫자로 변경하면 무분별한 자동 스캔 및 브루트포스 공격이 더 어려워질 수 있습니다. 이는 위협의 대부분을 이루는 것입니다. 그러나 SSH 서버를 모든 공격으로부터 완전히 보호하는 것은 아니라는 것을 명심하세요. 결정적인 해커는 여전히 SSH 포트를 찾아내고 대상으로 삼을 수 있습니다.\n\n![Image](/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_16.png)\n\n## 팁 4: SSH 로깅 및 모니터링 활성화\n\nSSH 로깅이 활성화되어 있어야 연결 시도를 추적하고 이상한 활동을 감지할 수 있습니다. 무단 액세스나 브루트포스 공격의 징후를 탐지하기 위해 로그를 정기적으로 모니터링하세요.\n\n<div class=\"content-ad\"></div>\n\n대부분의 시스템에서 SSH 로깅은 기본적으로 활성화되어 있습니다. 그러나 SSH 설정 파일 /etc/ssh/sshd_config을 확인하여 비활성화되어 있지 않은지 확인해보세요.\n\n단계 1: SSH 서비스 구성 파일에서 SSH 로깅 활성화하기\n\nSyslogFacility를 \"AUTH\"로 설정하고 LogLevel은 \"INFO\"로 설정하세요.\n\n![이미지](/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_17.png)\n\n<div class=\"content-ad\"></div>\n\n다른 로그 레벨을 탐색하려면 아래 섹션을 참조하세요. Verbose 및 Debug는 많은 로그를 생성하므로 진단 또는 디버깅에만 유용하기 때문에 권하지 않습니다.\n\nSSH 로그 레벨\n\n- QUIET: 거의 아무것도 로그하지 않아 최소한의 출력을 제공합니다.\n- FATAL: SSH 서버 작동을 중지하는 중요한 오류만 로그합니다.\n- ERROR: 중요한 문제 및 심각한 오류를 로그합니다.\n- INFO: 기본 레벨로, SSH 작업에 대한 일반 정보를 로깅합니다.\n- VERBOSE: SSH 프로세스에 대한 자세한 정보를 로그하며, 문제 해결에 유용합니다.\n- DEBUG: 디버깅을 위한 방대한 로그를 생성하며, 일반적으로 일상적으로 사용하지 않습니다.\n\n단계 2: 로그 저장소 구성\n\n<div class=\"content-ad\"></div>\n\n보통 SSH 로그는 /var/log/auth.log (Debian/Ubuntu) 또는 /var/log/secure (Red Hat/CentOS)에 저장됩니다.\n\n```js\n$ ls -la /var/log/auth.log\n-rw-r----- 1 root adm 292525 May 4 10:18 /var/log/auth.log\n```\n\n이 파일들이 존재하고 접근 가능한지 확인하세요. 소유자가 root로 설정되어 있고 파일 권한이 로그 파일을 안전하게 보호하기 위해 적절하게 설정되었는지 확인하세요.\n\n```js\nchmod 640 /var/log/auth.log\n```\n\n<div class=\"content-ad\"></div>\n\n## 팁 5: 침입 탐지 (Fail2ban) 구현하기\n\nFail2Ban은 로그인 시도를 모니터링하고 많은 실패한 시도 후 IP 주소를 차단하여 SSH 서버를 보호할 수 있습니다. 이는 브루트포스 공격의 일반적인 징후입니다. 설치한 후에는 SSH 로그를 주시하도록 설정하고 의심스러운 IP를 차단할 규칙을 구성하세요. SSH 서버의 보안에 추가적인 방어층을 더하는 효과적인 방법입니다.\n\nFail2Ban을 설정하고 구성하는 것은 이 글의 범위를 벗어납니다. 그러나 추가 보안을 위해 서버에 설치하는 것을 적극 추천합니다.\n\n# 결론\n\n<div class=\"content-ad\"></div>\n\n이 기사에서는 SSH 키 기반 인증의 혜택을 다루었는데, 이를 통해 보안을 강화하고 브루트포스 공격의 위험을 줄일 수 있다는 점을 강조했습니다. SSH 키를 생성하고 서버에 구성하는 방법을 안내하며 적절한 보안을 유지하는 방법을 보여드렸습니다. 또한 SSH 서버를 안전하게 유지하기 위한 추가 팁을 살펴봤는데, 이에는 기본 포트 변경, Fail2Ban 구현, 그리고 철저한 SSH 로깅 및 모니터링 활성화가 포함되었습니다.\n\n전체적으로 SSH 키 기반 인증은 원격 액세스를 보다 안전하고 편리하게 관리하는 방법을 제공합니다. 패스워드 기반 로그인의 효과적인 대체제로서, 미인가된 액세스 가능성을 줄이고 보안을 희생하지 않고 자동화가 가능합니다.\n\n권장 사항으로는 개인 키에 항상 암호를 설정하고, 이상한 활동을 정기적으로 모니터링하며, 키 기반 설정에 확신을 갖게 되면 패스워드 인증을 비활성화하는 것을 고려해야 합니다. Fail2Ban을 구현하면 브루트포스 공격의 징후를 보이는 IP 주소를 차단하여 자동화된 보호층을 추가할 수 있습니다.\n\n이러한 단계를 따라가면 안전하고 신뢰할 수 있는 SSH 설정으로 나아갈 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이 안내서를 통해 함께해 주셔서 감사합니다. SSH 연결을 안전하게 유지하고 서버를 안전하게 보호하는 데 도움이 되었으면 좋겠습니다! 🔐\n\n안전 유지하시고 보안 유지하시길 바랍니다!\n\nCyberSecMaverick\n\n![Guide Image](/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_18.png)","ogImage":{"url":"/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_0.png"},"coverImage":"/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_0.png","tag":["Tech"],"readingTime":11},{"title":"라이오닉실적으로는 죽지 않는 노트북","description":"","date":"2024-05-18 17:30","slug":"2024-05-18-TheLaptopThatWontDie","content":"\n\n<img src=\"/assets/img/2024-05-18-TheLaptopThatWontDie_0.png\" />\n\n위에 있는 노트북?\n\n그것은 내가 소유한 가장 튼튼하고 멈추지 않고 멀쩡한 컴퓨터야.\n\n정말 멈추지 않아요.\n\n<div class=\"content-ad\"></div>\n\n그거에 대해서 전체 포스트를 쓸 건데, 간단하게 말하자면...\n\n현대식이고 섹시하며 가벼운 고성능 노트북을 원한다면? Apple이나 Microsoft에서 비싼 녀석을 사세요.\n\n하지만 거의 돈을 들이지 않고 해가 폭발할 때까지 계속 작동하는 걸 원한다면?\n\n오래된 중고 Thinkpad을 사세요.\n\n<div class=\"content-ad\"></div>\n\n그럼 이 문장을 번역해 보겠습니다.\n\n분석해보겠습니다...\n\n하드웨어 이야기는 일주일 전, 맥북 프로에서 작업하던 때 시작되었다.\n\n2017년에 사온 제 주요 노트북인데요. Logic Pro(인류에게 제일 좋은 음악 편집 소프트웨어)가 돌아가는 a) 머신이 필요했고, b) 시력이 좋지 않아 고해상도 화면이 필요했으며, c) 1테라바이트 하드 드라이브가 필요했어요. 그 조건에 맞는 유일한 머신이었습니다.\n\n엄청 비싼 물건이긴 했지만, 노트북을 살 때 목표는 수년 동안 사용할 수 있을 만큼 훌륭한 품질의 것을 사는 것이에요. 전자 폐기물도 싫어해서 노트북을 수리해서 가능한 한 오래 사용하려고 노력해요. 2010년에 첫 맥북 프로를 샀었는데, 총 7년 이용했어요 — 중간에 고장 난 메인보드도 교체했는데, 전세계 3년 보증기간이 끝나기 전에 다행히 수리해줬어요. 그래서 비용 지불할 필요 없이 해결했답니다! 호호.\n\n<div class=\"content-ad\"></div>\n\n이 더 새로운 2017 맥북 프로? 예전에 수리를 몇 번 받기도 했어요. 사고로 물에 물려서 내부 작업이 필요했었죠. 버터플라이 키보드가 고장 나자 바꿔야 했고, 배터리도 두 번이나 교체했어요.\n\n하지만 6년이 지나도 여전히 잘 돌아가고 있었어요!\n\n지난 주에 갑자기 고장 나기 전까지 말이죠.\n\n맥북에서 작업하고 있었고, 점심 때 리드를 닫았어요. 15분 후 다시 열어보니 기계가 꺼져 있었어요. 내가 뭘 해도 살려낼 수가 없었어요.\n\n<div class=\"content-ad\"></div>\n\n자전거를 타고 현지 노트북 수리소에 가져다 놓았어요. 수 시간 후, 기술자가 무슨 일이 벌어졌는지 알려주기 위해 문자 메시지를 보냈어요. 아무래도 로직 보드에 전기 단락이 있었나 보다: “배터리와 통신하는 칩이 결함이 있는 것 같습니다,” 라고 썼어요. 그 칩이 로직 보드의 납땜된 일부라는 점에서, 해결책은 완전 새 메인보드를 설치하는 것이었어요. 부품과 인건비를 합친 비용이 충분히 높아서 — 이 기기가 이전에 고장났던 일들을 고려하면 — 그를 수리하는 것은 추천하지 않는다고 했어요.\n\n동의했죠. 6년이 지난 후 마침내 새로운 맥북 프로를 사기로 결정했어요. (a), b), c)의 요구 사항은 아직이고, 맥북 프로가 세 가지를 모두 충족하는 가장 좋은 방법이기 때문이에요.\n\n(그 죽은 맥북은, 대신에 예비로서 보관하기 위해 대체 메인보드를 구입하고 직접 고치려고 할지도 몰라. 노트북 수리에 대해 나름 능숙하지만, 이들 현대 맥북은 산업적 얇음의 복잡한 예시라서, 망칠 수도 있어요. 기회를 볼게요!)\n\n한편, 내 새 노트북을 주문할 준비를 하면서요?\n\n<div class=\"content-ad\"></div>\n\n휴대용 기계가 필요해요.\n\n그래서 제 집에 있는 유일하게 망가지지 않는 컴퓨팅 장비를 꺼냈어요.\n\n그 위에 보이는 그 고대의 Thinkpad이죠.\n\n2018년에 리눅스 머신이자 백업 노트북으로 사용할 고 대아이를 원했을 때 샀어요. 그런데 돈을 많이 쓰고 싶지 않았어요.\n\n<div class=\"content-ad\"></div>\n\n\"‘테이블’ 태그를 Markdown 형식으로 변경해드릴게요.\"\n\n<div class=\"content-ad\"></div>\n\n12살이라니 생각하면 이 기계는 정말 빠르게 작동합니다. SSD 하드 드라이브와 오래된 시스템에 부드럽게 작용하는 리눅스 덕분이죠. 어플리케이션이 내 맥북에서 하는 것과 같이 빠르게 열리고 닫히죠.\n\n아마도 이 Thinkpad에서 느린 오래된 CPU에 부담을 주는 일을 하고 있지는 않습니다. 게임을 하지 않고 있고, 비디오 편집도 음악 편집도 플러그인이 가득한 것도 하고 있지 않습니다. (그럼에도 Audacity를 사용하여 가벼운 오디오 편집은 꽤 잘되었답니다.)\n\n이 노트북에 대해 할 수 있는 최악의 말은 무거워요. 게다가 화면 해상도가 낮고 흐릿한데요, 저같은 안구가 안 좋은 사람에게는 좋지 않습니다. \n\n하지만, 웹에서 작업을 하는 데 기본적인 기계가 필요하다면, 비디오 통화하기 (Zoom, Microsoft Teams, 많은 리눅스 전용 비디오 채팅이 아주 잘 됩니다), 음악 듣기, Discord 사용하기? 그럼 완벽합니다.\n\n<div class=\"content-ad\"></div>\n\n가장 중요한 것은, 이 기계는 부숴지지 않는 것 같아요.\n\n저는 이 기계를 소유한 지 여러 해가 되었지만, 아직까지 물리적으로 손상된 부분이 없어요. 매번 내부를 열어보면, ThinkPad는 완벽하게 작동해요. 이 기계는 제 첫째 아들이 여섯 살일 때 만들어졌어요; 그 아이는 성인이 되어 대학에 입학했지만, 이 노트북은 아직도 2011년에 만들어진 것처럼 마치 새 것처럼 훌륭한 상태로 사용 중이에요. 지난 십이 년 동안, 우리 네 명 가족은 알 수 없는 수많은 노트북과 전자 기기를 사용해 왔어요 — 그 중 많은 것들이 결국 망가지거나 고장이 났거나 멈추거나 초자연적인 현상이 발생했지만요. 그런데 이건 불굴의 의지로 계속 작동해요. 멈출 기미가 없어요.\n\n솔직히 말하자면, 이 기계를 주력으로 사용하고 있진 않아요. 그렇게 한다면, 어떤 부분이 옛날에 고장 났을지도 모르겠어요.\n\n하지만… 많은 사람들이 이 노트북이 만들어진 지 오래되었음에도 불구하고, 옛날부터 오랫동안 자신의 주력 노트북으로 사용해 왔어요. 그리고 그 중 많은 기계들은 여전히 잘 작동하죠. 저가 최근 Mastodon에서 내 T420를 언급했을 때, 몇몇 사람들이 동일 연식의 ThinkPad를 사용 중이며, 모두 완벽하게 작동한다고 언급했어요.\n\n<div class=\"content-ad\"></div>\n\n옛날 노트북 Thinkpad들? 진짜로 탱크처럼 튼튼하게 만들어졌어요.\n\n그래서 결론은 뭐냐면? 저렴한 머신이 필요하다면, 중고로 구입하는 예전 Thinkpad을 사세요. 일반적으로 Craigslist에서 쉽게 찾을 수 있어요. 무료로 Linux를 설치할 수 있고, 요즘 대부분의 사람들이 하는 거의 모든 일들이 브라우저에서 처리되기 때문에, Linux를 사용하는 것은 이제 매우 간단해졌어요. (이에 대해 작년에도 블로그에 글을 썼답니다.)\n\n지금 하나 사면, 평생 동안 소유할 수도 있을 거예요.\n\n(이 내용이 마음에 들었다면? 그럼 트랙패드나 마우스를 꺼내서 \"박수\" 버튼을 찾아 클릭하세요! 독자 당 최대 50번 클랩이 가능하답니다.)\n\n<div class=\"content-ad\"></div>\n\n매주 두 번 미디엄에 글을 올리고 있어요. 제 이메일로 각 포스트를 받아보시려면 여기를 팔로우해주세요!\n\n저는 뉴욕 타임스 매거진과 와이어드(Wired)에 기고하는 작가이자 \"Coders\" 저자입니다. 마스토돈(Mastodon)이나 인스타그램(Instagram)에서도 저를 팔로우하거나 원하는 만큼 결제하는 뉴스레터 \"The Linkfest\"에 가입해주세요. 이것은 \"둠스크롤링의 반대\"라고 합니다.","ogImage":{"url":"/assets/img/2024-05-18-TheLaptopThatWontDie_0.png"},"coverImage":"/assets/img/2024-05-18-TheLaptopThatWontDie_0.png","tag":["Tech"],"readingTime":4},{"title":"유닉스 리눅스에서 ls 명령어 해부하기","description":"","date":"2024-05-18 17:28","slug":"2024-05-18-DemystifyingthelsCommandinUnixLinux","content":"\n\nls 명령어의 기능을 간소화했어요.\n\n작은 이야기가 먼저!!!!\n\n3년 넘게 매일 리눅스 시스템과 함께 일했어요. 로봇처럼 생각 없이 과제를 수행했죠. 셸 스크립트와 Python 코드를 사용해서 자동화 작업을 했어요. 그러나 2024년 1월 29일, 어떤 명령어들이 작동하는 방식에 대한 호기심을 자극하는 문제를 마주했어요. 이 호기심은 명령어들이 어떻게 내부적으로 작동하는지 고려해보지 않은 저에게 놀라운 충격이었어요.\n\n누군가는 이 깨달음이 당연히 느껴질 수도 있겠지만, 제게는 진정한 성장의 순간이에요. 이 블로그를 지나치게 복잡하게 만들기보다, 현재 배우고 있는 것에 집중하고 싶어요. 저는 발견하는 모든 새로운 사실을 문서화하기로 결심했어요.\n\n<div class=\"content-ad\"></div>\n\n제가 마주한 문제에 대해 이해하기 쉽게 설명하기 위해 나중 게시물에서 더 자세히 다룰 예정입니다. 여기서 설명하는 것이 가장 좋은 방법이 아닐 수 있으니 말이죠. 이제 첫 학습 경험을 향해 나아가 봅시다.\n\n# 그럼... 시작해봅시다!!\n\n설명에 따르면... Unix/Linux에서 ls Command 해석하기\n\n```js\nsilentstorm29@cloudmaniac ~ % ls -larth\n```\n\n<div class=\"content-ad\"></div>\n\n\n![image](/assets/img/2024-05-18-DemystifyingthelsCommandinUnixLinux_0.png)\n\n이게 일반적으로 우리가 사용하는 거잖아요??\n\nls 명령어는 Unix 및 Unix와 유사한 운영 체제의 중요한 요소입니다. 이 명령 줄 유틸리티는 디렉토리의 내용을 나열하는데, 보다 많은 기능을 제공합니다. 파일 및 디렉토리의 속성을 보기 위한 다양한 옵션을 제공하는데, 이는 권한, 소유권, 크기 및 수정 시간을 포함합니다.\n\n# ls 명령어의 힘을 발휘하기\n\n\n<div class=\"content-ad\"></div>\n\nls 명령어는 다양한 방식으로 사용할 수 있는 다재다능한 명령어입니다:\n\n- ls: 현재 디렉토리의 파일 및 디렉토리를 나열하는 간단한 방법입니다.\n- ls -l: 자세한 목록 형식으로 파일 및 디렉토리를 공개합니다.\n- ls -a: 숨겨진 파일 및 디렉토리를 모두 보여줍니다(점으로 시작하는 파일 포함).\n- ls -lh: 파일 및 디렉토리를 크기가 사용자 친화적인 형식으로 자세한 목록 형식으로 표시합니다.\n- ls /경로/디렉토리: 특정 디렉토리의 내용을 나열합니다.\nls 명령어는 유닉스와 비슷한 환경에서 중요한 위치를 차지하며 파일 시스템 탐색과 파일 관리에 필수적입니다.\n\n# 커튼 뒤: 시스템 호출\n\n유닉스와 비슷한 운영 체제에서 ls 명령어를 실행하면 여러 시스템 호출이 발생합니다. 다음은 발생하는 마법의 간소화된 순서입니다:\n\n<div class=\"content-ad\"></div>\n\n- 쉘(예: bash 또는 zsh)은 새 프로세스, 즉 쉘 프로세스의 복제본을 생성하기 위해 fork() 시스템 호출을 사용합니다.\n- 그런 다음, 새 프로세스는 exec() 시스템 호출을 사용하여 자신의 이미지를 ls 프로그램으로 대체하고 ls 프로그램을 메모리에 로드하여 실행을 시작합니다.\n- ls 프로그램은 디렉토리 내용을 읽고 파일에 대한 정보를 가져오기 위해 여러 시스템 호출을 활용합니다. 이러한 시스템 호출에는 open(), read(), getdents(), stat(), lstat(), fstat() 등이 포함됩니다.\n- ls 프로그램은 또한 write() 시스템 호출을 사용하여 디렉토리 목록을 표준 출력(일반적으로 여러분의 터미널)에 출력합니다.\n- ls 프로그램이 작업을 완료하면 exit()를 호출하여 종료합니다. ls 프로그램이 완료될 때까지 대기했던 원래 쉘 프로세스는 wait() 시스템 호출을 통해 완료 알림을 받습니다.\n\n# 옵션, 인수, 와일드카드 마스터하기\n\nls 명령은 옵션, 인수 및 와일드카드를 사용하여 동작을 수정할 수 있도록 유연하게 설계되어 있습니다. 각 구성 요소가 작동하는 방법을 살펴보겠습니다:\n\n옵션:\n\n<div class=\"content-ad\"></div>\n\n옵션은 ls 명령어의 동작을 조절합니다. 예를 들어, -l은 자세한 형식으로 출력을 보여주고, -a는 숨겨진 파일을 포함한 모든 파일을 표시하며, -h는 파일 크기를 사람이 이해하기 쉬운 형식으로 표시합니다. ls 명령어는 이러한 옵션을 구문 분석하고 동작을 조정합니다. 이 과정에서 직접 시스템 호출을 수행하지는 않지만, 나중에 수행될 시스템 호출을 영향을 줄 수 있습니다. 예를 들어, -l 옵션은 ls가 각 파일에 대한 자세한 정보를 가져오기 위해 stat() 또는 lstat() 시스템 호출을 수행하도록 유도합니다.\n\n인수:\n\n인수는 일반적으로 ls가 작용해야 할 디렉터리 또는 파일의 이름입니다. 인수를 지정하지 않으면 ls는 현재 디렉터리의 내용을 나열합니다. 디렉터리 이름을 제공하면 해당 디렉터리의 내용을 나열합니다. 파일 이름을 제공하면 해당 파일만 표시합니다 (파일이 있는 경우). ls 명령어는 인수를 파일이나 디렉터리로 처리하여 나열합니다. 이때 인수가 디렉터리인지 파일인지 확인하기 위해 stat() 또는 lstat() 시스템 호출을 사용합니다. 디렉터리일 경우 ls는 open() 및 getdents() 시스템 호출을 사용하여 내용을 읽어옵니다.\n\n와일드카드:\n\n<div class=\"content-ad\"></div>\n\n와일드카드는 다른 문자를 대표하는 기호입니다. 가장 흔한 와일드카드는 \"*\"로, 모든 문자의 어떤 개수를 나타냅니다. 예를 들어, ls *.txt는 .txt로 끝나는 모든 파일을 나열합니다. 또 다른 흔한 와일드카드는 \"?\"로, 어떤 하나의 문자를 나타냅니다. 예를 들어, ls ?.txt는 한 글자 이름을 가지고 .txt로 끝나는 모든 파일을 나열합니다. 쉘(=ls 명령어가 아닌)은 명령이 실행되기 전 와일드카드를 확장합니다. 예를 들어 ls *.txt를 실행하면 쉘은 현재 디렉토리에 있는 모든 .txt 파일의 이름으로 *.txt를 대체합니다. 이 과정에는 디렉터리 내용을 읽기 위해 open(), getdents(), close() 시스템 호출이 필요하며, 와일드카드 패턴에 따라 파일을 필터링하기 위해 stat() 또는 lstat()을 사용할 수도 있습니다. 와일드카드 확장 후, ls 명령이 확장된 인수와 함께 실행됩니다.\n\n옵션, 인수, 와일드카드를 함께 사용하는 예시는 다음과 같습니다:\n\n```js\nsilentstorm29@cloudmaniac ~ %ls -lh *.txt\n```\n\n<img src=\"/assets/img/2024-05-18-DemystifyingthelsCommandinUnixLinux_1.png\" />\n\n<div class=\"content-ad\"></div>\n\n현재 디렉터리에서 .txt 파일을 자세한 형식으로 인간이 읽을 수 있는 파일 크기로 나열하는 이 명령어를 사용할 거에요.\n\n# 마무리!!\n\n`ls` 명령어의 내부 동작에 대해 파헤치는 것은 마술사의 마술 비밀을 발견하는 것과 같아요. 단순한 명령어가 정밀한 시스템 호출들이 조화롭게 작동하는 과정을 보는 것은 매우 흥미롭죠. 다음에 `ls`를 입력할 때 눈에 보이는 것보다 훨씬 많은 일이 벌어지고 있다는 것을 알게 될 거예요. 매일 사용하는 명령어 뒤의 마법을 계속 탐험하고 발견하세요 🔎. 질문은 댓글 섹션에서 환영합니다 — 즐거운 학습을 기대해요!\n\n<img src=\"/assets/img/2024-05-18-DemystifyingthelsCommandinUnixLinux_2.png\" />\n\n<div class=\"content-ad\"></div>\n\n잘 가!!","ogImage":{"url":"/assets/img/2024-05-18-DemystifyingthelsCommandinUnixLinux_0.png"},"coverImage":"/assets/img/2024-05-18-DemystifyingthelsCommandinUnixLinux_0.png","tag":["Tech"],"readingTime":4},{"title":"Swift Actors  깊이 있는 이해","description":"","date":"2024-05-18 17:26","slug":"2024-05-18-SwiftActorsindepth","content":"\n\n<img src=\"/assets/img/2024-05-18-SwiftActorsindepth_0.png\" />\n\n# 배우세요, 외우지 마세요.\n\n저는 개념의 내부 작동 원리를 이해하는 것을 좋아하는 사람입니다. 내재하는 메커니즘을 파악하지 못하면 개념에 대해 모든 것이 불분명하게 보이고 진정한 이해가 아닌 단순 외우기처럼 느껴집니다. 그래서 저는 여러 주요한 스위프트 개념인 액터(actors), 비동기/대기(async/await), 구조화된 동시성(structured concurrency), 그리고 AsyncSequence에 대해 탐구해왔습니다. 이러한 개념을 이해하기 쉽게 만들기 위해 각각의 개념을 실제적이고 현실적인 예를 사용하여 설명할 계획입니다. 먼저 액터에 대한 토론을 시작해보겠습니다.\n\n# 액터(actor)란 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\nSwift에서 Actor는 5.5 버전에서 도입된 참조 유형으로, 고급 동시성 모델의 일환으로 소개되었습니다. 주요 역할은 데이터 경쟁을 방지하고 동시 프로그래밍 환경에서 공유된 가변 상태에 안전하게 액세스하는 것입니다. 이를 더 잘 이해하기 위해 간단한 예시를 들어보겠습니다: 사무실의 프린터.\n\n![프린터](https://miro.medium.com/v2/resize:fit:1400/1*IEsYeP_QiG4ZmObPQ-vURA.gif)\n\n사무실에 모든 직원들이 사용할 수 있는 공유 프린터가 있는 상황을 상상해보세요. 어느 날 문서를 인쇄해야 해서 파일을 프린터에 보내고 수령하러 가는데, 프린터에 도착해보니 의외의 일이 벌어졌습니다: 출력된 페이지가 여러분의 파일과 일치하지 않습니다. 혼란스러운 상황에서 올바른 파일을 보냈다는 것을 재확인하더니, 다른 사람이 여러분의 인쇄 작업을 취소하고 자신의 작업을 시작한 것 같습니다. 이런 착각에 직면했을 때, 어떤 조치를 취할 것인지 고민해보실 거에요?\n\n![문제 해결](https://miro.medium.com/v2/resize:fit:960/1*mI-teGZmtwFc4VLeRWFh-Q.gif)\n\n<div class=\"content-ad\"></div>\n\n문서를 출력한 후 확인 없이 그것을 바로 당신의 매니저에게 전달하는 상황을 상상해보십시오. 그것이 의도한 대로인지 확인하지 않은 채에, 문제가 발생할 수 있습니다. 공유 리소스를 다룰 때 프로그래밍에서도 비슷한 문제가 발생할 수 있습니다. Swift의 맥락에서, 클래스에 대해서 특히 중요한데, 이는 참조 유형입니다. 이 특성은 클래스의 인스턴스에 대한 모든 수정사항이 여러분의 애플리케이션에서 해당 클래스를 사용하는 모든 인스턴스에 반영될 것임을 의미합니다. 이는 공유 오피스 프린터에서 한 사람의 행동이 모두의 인쇄 작업에 영향을 미치는 것과 유사합니다. 이제, 특정 코드 예제를 살펴보겠습니다.\n\n```js\nclass Account {\n var balance: Int = 20//현재 사용자의 잔액은 20\n ...\n func withdraw(amount: Int) {\n  guard balance >= amount else {return}\n  self.balance = balance - amount\n }\n}\n\nvar myAccount = Account()\nmyAccount.withdraw(20$)\n```\n\n우리 코드는 계좌에서 돈을 인출하는 간단한 작업을 수행합니다. 이 코드에서는 인출을 진행하기 전에 계정 잔액이 충분한지 확인합니다. 이 시나리오는 사무실에서 프린터를 사용하는 것과 유사합니다. 당신이 사무실에 혼자 있을 때, 프린터(계정 객체와 유사)를 사용하는 것은 문제가 없습니다. 그러나 다수의 사람(또는 우리의 프로그래밍 비유인 경우, 다수의 스레드)이 동시에 프린터를 사용하려고 하면 문제가 발생할 수 있습니다.\n\n이제, 멀티스레딩 환경에서의 Account 예제로 돌아가봅시다. 여러 CPU 코어가 있는 현대 모바일 장치와 같이 멀티스레딩 환경에서, 두 개의 스레드가 동시에 동일한 Account 객체에서 withdraw(20$) 함수를 실행하려고 시도한다고 상상해보십시오. 운영 체제는 이러한 스레드를 조절하고, CPU 코어를 할당하고, 그들의 실행을 관리하지만 우리는 정확한 작업 순서를 예측할 수 없습니다.\n\n<div class=\"content-ad\"></div>\n\n요점은 다음과 같습니다: 첫 번째 스레드가 잔액을 확인하고 충분하다고 판단하면서(잔액 `= 금액) 출금을 하기 전에 문맥 전환으로 인해 두 번째 스레드가 실행을 시작합니다. 이 두 번째 스레드도 첫 번째 스레드가 아직 출금을 완료하지 않았기 때문에 잔액이 충분하다고 판단하여 돈을 인출하고 잔액을 0으로 만듭니다. 그런 다음, 첫 번째 스레드가 다시 실행되면, 두 번째 스레드에 의해 잔액이 이미 소진된 상태에서 돈을 인출하려고 시도합니다.\n\n이 상황은 두 명이 같은 프린터를 사용하려고 하는 것과 유사합니다. 이들이 조율하지 않으면 서로 방해하는 인쇄 명령을 보낼 수 있어 혼합이나 누락된 인쇄물이 발생할 수 있습니다. 계좌 예시에서, 이러한 조율의 부재는 계좌가 동일한 금액에 대해 두 번 차감되는 초과 인출로 이어지며, 프로그래밍에서 동시 액세스의 어려움을 보여줍니다.\n\n실제로 이전 예시에서는 잔액이 부족하여 두 출금 작업 중 하나가 거부되어야 했지만, 동시 액세스로 인해 두 작업이 모두 성공했습니다. 이 상황은 '경쟁 조건(Race Condition)'을 보여줍니다. 경쟁 조건은 여러 스레드가 동시에 공유 리소스인 여기서는 계좌 잔액을 액세스하고 수정하며, 이러한 작업의 최종 결과가 각 스레드의 실행 타이밍에 달렸을 때 발생합니다.\n\n경쟁 조건에서 결과는 프로그램의 제어 밖에 있는 특정 이벤트의 순서와 타이밍에 따라 예측할 수 없습니다. 계좌 예시에서의 문제는 두 스레드 모두 잔액을 확인하고 금액을 차감하기 전에 충분하다고 판단했기 때문에 발생했습니다. 이로 인해 두 스레드가 모두 인출을 진행하고, 잘못된 계좌 잔액이 발생했습니다.\n\n<div class=\"content-ad\"></div>\n\n이러한 레이스 조건은 프로그래밍에서 심각한 문제입니다, 특히 데이터 일관성과 정확성이 중요한 시스템에서는 더욱 중요합니다. 이는 멀티 스레드 환경에서 공유 리소스를 신중하게 관리하여 작업이 안전하고 예측 가능한 방식으로 수행되도록하는 필요성을 강조합니다.\n\n# Actors\n\nSwift의 Actors는 이전에 논의한 동시성 문제에 대한 우아한 해결책을 제공합니다. Actors가 도입되기 전에는 DispatchQueue, Operations 및 Locks를 사용하여 동시 액세스를 관리하는 흔한 방법이 있었습니다. 이러한 방법은 효과적이었지만, 상당량의 수동 코드 및 관리가 필요했습니다.\n\n이제 Swift에서 Actor 유형을 도입함으로써 동시성 관리에 포함된 복잡성의 많은 부분이 숨겨졌습니다. 프린터 예에서 생각해보세요: 어떻게 해서 다른 사람의 인쇄 작업을 덮어 쓰지 않도록 보장할 수 있을까요? 이상적인 해결책은 인쇄 작업이 줄지어 있는 대기열이 있는 것입니다. 새 작업이 도착할 때마다 대기열에 가입하고 차례를 기다리며, 프린터는 각 작업을 순차적으로 처리합니다.\n\n<div class=\"content-ad\"></div>\n\n이것이 정확히 배우는 방법입니다. Actor들은 내부 메일함을 가지고 있으며 이것은 큐처럼 작동합니다. Actor에 보내진 요청은 이 메일함에 저장되어 순차적으로 처리됩니다. 큐잉 메커니즘은 작업이 순서대로 실행되도록 보장해주어 경합 조건을 방지합니다. 게다가, 내부 큐와 메일함은 Actor 자체에서 관리되므로, 모든 복잡성이 개발자로부터 숨겨지게 됩니다. 이로써 Swift에서 동시성 작업을 처리하는 보다 간소화되고 오류 방지된 접근 방식이 가능해집니다.\n\n대박, 맞죠?\n\n![이미지](https://miro.medium.com/v2/resize:fit:400/1*CisZ-Zm-zu0MiLV45EpV9Q.gif)\n\n하지만 이것이 실제로 어떻게 작동하는지 궁금하시죠? Actor들은 '데이터 격리'를 보장합니다.\n\n<div class=\"content-ad\"></div>\n\n데이터 격리를 이해하기 위해 사무실의 프린터 비유를 생각해보세요. 이 사무실 프린터를 별도의 방에 넣고 와이파이에서 분리한다고 상상해봅시다. 이제 누군가 인쇄하려면 물리적으로 이 방에 가서 차례를 기다려야 합니다. 이 설정은 프린터의 겹침이나 병행 사용을 효과적으로 방지하여 한 번에 한 사람만 사용할 수 있도록 합니다.\n\nSwift의 경우, 액터(actors)도 비슷하게 작동합니다. 액터 내부에 데이터를 캡슐화하면 프로그램의 다른 부분에서 직접 액세스할 수 없게 만듭니다. 데이터와 상호 작용하려면 액터를 통과해야 하는 코드가 필요하며, 효과적으로 '정렬'하여 차례를 기다립니다. 이는 동시성 환경에서도 액터가 데이터에 대한 액세스를 직렬화하여 한 번에 코드 한 개만 상호 작용할 수 있도록 합니다.\n\n이제 이 개념이 어떻게 실제로 적용되는지 알아보기 위해 코드를 살펴봅시다...\n\n개정된 Account 예제에서 클래스에서 액터로 전환은 놀랍도록 간단합니다. 정의에서 클래스를 액터로 변경하는 것만으로 Account 오브젝트가 스레드 안전해집니다. 이 변경은 구문적으로는 미미하지만, 동시성 환경에서 객체가 액세스되고 조작되는 방식에 중요한 영향을 미칩니다.\n\n<div class=\"content-ad\"></div>\n\n```swift\nactor Account {\n var balance: Int = 20// 현재 사용자의 잔액은 20\n // ...\n func withdraw(amount: Int) {\n  guard balance >= amount else {return}\n  self.balance = balance - amount\n }\n}\n```\n\n정말 쉽게 actor로 전환할 수 있습니다. 그러나 이 변경에는 일부 어려움이 딸립니다. 클래스를 actor로 전환한 후 코드를 컴파일하려고 하면 오류가 발생할 수 있습니다. 이는 actor의 특성과 데이터 고립 속성 때문에 발생하는 문제이며, 프린터를 별도의 방에 두고 Wi-Fi와 연결을 끊어버린 것에 비유할 수 있습니다.\n\n우리의 클래스를 actor로 변환하면 이제 해당 클래스의 속성과 메소드에 외부에서 직접 액세스할 수 없게 됩니다. actor는 스레드 안전을 보장하기 위해 엄격한 액세스 제어를 시행합니다. 따라서 이제는 이전에 Account 객체에 액세스했던 코드의 모든 지점을 업데이트해야 합니다. 일반적으로 Actor와 상호 작용하기 위해 async 및 await와 같은 비동기 패턴을 사용하여 메소드와 속성에 안전하게 직렬화된 액세스가 이루어지도록 해야 합니다.\n\n```swift\nvar myAccount = Account()\nmyAccount.withdraw(20$)  // 이 줄은 더 이상 유효하지 않습니다\nawait myAccount.withdraw(20$) // 좋아요\n```\n\n<div class=\"content-ad\"></div>\n\n# 배우와 배역 간 참조\n\nSwift에서 배우가 데이터 격리를 보장한다고 말할 때, 이는 배우 내의 모든 가변 속성과 함수가 외부로부터 직접 액세스되는 것과 격리된다는 것을 의미합니다. 이 격리는 배우의 핵심 기능이며, 병렬 프로그래밍에서 스레드 안전성을 보장하기 위한 중요한 요소입니다. 그렇다면 이 격리는 이러한 속성과 함수에 액세스하고 수정하는 데 어떤 영향을 미칠까요?\n\n기본적으로 배우의 속성을 읽거나 값을 변경하거나 함수를 호출하려면 일반 클래스나 구조체처럼 직접 수행할 수 없습니다. 대신, 말그대로 '순서를 기다려야' 합니다. 이는 배우의 메일함에 요청을 보내는 것으로 이루어집니다. 그러면 요청이 대기열에 들어가 순서대로 처리됩니다. 요청이 처리될 차례가 되면 해당 요청을 처리할 수 있을 때만 배우의 속성을 읽거나 수정하거나 함수를 호출할 수 있습니다.\n\n이 과정을 배우 간 참조라고 합니다. 배우 외부에서 배우 내부의 내용을 참조하거나 액세스할 때 배우 간 참조를 하게 됩니다. 실제로는 비동기 패턴을 사용하여 배우와 상호 작용하는 것을 의미합니다. 이러한 구조를 사용하면 코드가 효과적으로 다음과 같이 말합니다. `이 배우 내부의 내용에 액세스하거나 수정해야 합니다. 여기가 제 요청입니다. 안전하고 적절한 시기가 돌아올 때까지 비동기로 기다리겠습니다.`\n\n<div class=\"content-ad\"></div>\n\n그러니까, 배우들에서 데이터 격리는 배우의 내부 상태와 외부 세계 간의 모든 상호작용이 이를 통해 조절되는 비동기 프로세스를 통해 이루어져야 함을 의미합니다. 이를 통해 배우가 동시 액세스 충돌의 위험 없이 안전하게 상태를 관리할 수 있습니다.\n\n```js\nactor Account {\n var balance: Int = 20// 현재 사용자 잔액은 20입니다.\n // ...\n func withdraw(amount: Int) {\n  guard balance >= amount else {return}\n  self.balance = balance - amount\n }\n}\n\nactor TransactionManager {\n    let account: Account\n\n    init(account: Account) {\n        self.account = account\n    }\n\n    func performWithdrawal(amount: Int) async {\n        await account.withdraw(amount: amount)\n    }\n}\n\n// 사용법\nlet account = Account()\nlet manager = TransactionManager(account: account)\n\n// TransactionManager 배우에서 인출 수행\nTask {\n    // 배우 간 참조\n    await manager.performWithdrawal(amount: 10)\n}\n\n// 배우 바깥에서 인출 수행\nTask {\n    // 배우 간 참조\n    await myAccount.withdraw(amount: 5)\n}\n```\n\nSwift의 동시성 모델에서 await 키워드는 배우와 함께 작업할 때 특히 중요한 구성 요소입니다. 흥미롭게도, 배우 내 withdraw 함수를 명확하게 async로 표시할 필요가 없었음을 알 수 있습니다. 이는 기본적으로 배우의 모든 함수가 배우 자체의 특성으로 인해 잠재적으로 비동기로 간주되기 때문입니다. 외부에서 배우와의 모든 상호작용은 본질적으로 비동기이며, 따라서 어떤 배우 간 참조도 await로 선행되어야 합니다.\n\nawait를 사용하는 것은 실행에서 잠재적인 일시 정지를 나타내는 것과 같습니다. 마치 다른 사람이 사무실 프린터를 사용할 때 차례를 기다리는 것과 유사합니다. 이는 Swift 런타임에게 코드에서 이 지점이 배우가 요청을 처리할 준비가 될 때까지 실행을 보류해야 할 수도 있다고 알려주는 것입니다. 이러한 보류는 항상 발생하는 것은 아닙니다. 배우가 다른 작업으로 바쁘지 않다면 코드는 즉시 계속 진행됩니다. 이것이 '가능성 있는' 보류 지점으로 표현하는 이유입니다.\n\n<div class=\"content-ad\"></div>\n\n이제 출금 시나리오에 이를 적용하면, 구현이 훨씬 안전하고 예측 가능해집니다. 두 스레드가 동시에 같은 계좌 엑터에서 출금을 실행하려고 할 때를 상상해보세요. 엑터와 await가 준비되어 있으면, 운영 체제가 첫 번째 스레드에서 두 번째 스레드로 실행을 전환하더라도, 두 번째 스레드가 즉시 출금 함수에 진입하지 않습니다. 실행이 중간에 멈추고 await 지점에서 일시 중지되어, 첫 번째 작업이 완료될 때까지 기다립니다. 이렇게 하면 작업이 직렬화되어 첫 번째 스레드가 출금을 완료한 후에야 엑터가 두 번째 스레드의 요청을 처리합니다. 이 시점에서 두 번째 스레드는 잔액이 다음 출금에는 충분하지 않음을 발견하고, 함수가 계좌 잔액에 더 이상 변경을 가하지 않고 반환됩니다.\n\n이러한 방식으로, 엑터 모델은 비동기 액세스 패턴과 await 키워드로 공유 리소스인 계좌 객체에 대한 작업을 안전하게 처리하여 경쟁 조건을 방지하고 데이터 무결성을 유지합니다.\n\n# 직렬 실행기\n\nSwift의 엑터에 대한 논의에서, 각 엑터는 해당 메일박스 내의 작업(또는 '메일')을 하나씩 처리하는 내부 직렬 큐를 가지고 있다고 언급했습니다. 엑터의 내부 큐는 직렬 실행기(Serial Executor)로 알려져 있으며, 이는 직렬 DispatchQueue와 비슷한 역할을 합니다. 그러나 이들 사이에는 작업 실행 순서와 기본 구현의 처리 방식을 비롯한 중요한 차이점이 있습니다.\n\n<div class=\"content-ad\"></div>\n\nOne significant difference is that tasks waiting on an actor’s Serial Executor are not necessarily executed in the order they were awaited. This is a departure from the behavior of a Serial DispatchQueue, which adheres to a strict first-in-first-out (FIFO) policy. With a Serial DispatchQueue, tasks are executed exactly in the order they are received.\n\nOn the other hand, Swift’s actor runtime employs a lighter and more optimized queue mechanism compared to Dispatch, tailored to leverage the capabilities of Swift’s async functions. This difference stems from the fundamental nature of executors versus DispatchQueues. An executor is essentially a service that manages the submission and execution of tasks. Unlike DispatchQueues, executors are not bound to execute jobs strictly in the order they were submitted. Instead, executors are designed to prioritize tasks based on various factors, including task priority, rather than solely on submission order.\n\nThis nuanced difference in task scheduling and execution between Serial Executors and Serial DispatchQueues underpins the flexibility and efficiency of Swift’s actor model. Executors offer a more dynamic way to manage tasks, especially in a concurrent programming environment. I plan to explore Executors more deeply in a separate discussion to further elucidate their role and advantages in Swift’s concurrency model.\n\n# Rules\n\n<div class=\"content-ad\"></div>\n\n- 액터 내의 읽기 전용 속성에 접근할 때는 await을 사용할 필요가 없습니다. 왜냐하면 이들 값은 불변이기 때문에 변경되지 않기 때문이죠.\n\n```js\nactor Account {\n **let accountNumber: String = \"IBAN---\"**\n var balance: Int = 20 // 현재 사용자 잔액은 20입니다.\n // ...\n func withdraw(amount: Int) {\n  guard balance >= amount else {return}\n  self.balance = balance - amount\n }\n}\n\n**/// 이 부분은 괜찮아요 ✅**\nlet accountNumber = account.accountNumber\nTask {\n **/// 이 부분은 괜찮아요 ✅**\n let balance = await account.balance\n \n **/// 이 부분은 좋지 않아요 ❌**\n let balance = ****account.balance // 에러\n}\n```\n\n2. 액터 간 참조에서 변경 가능한 변수를 수정하는 것은 금지되어 있습니다. await을 사용해도 안 됩니다.\n\n```js\n/// 이 부분은 좋지 않아요 ❌\naccount.balance = 12 // 에러\n\n/// 이 부분은 좋지 않아요 ❌\nawait account.balance = 12 // 에러\n```\n\n<div class=\"content-ad\"></div>\n\n3. 모든 액터에 고립된 함수는 await 키워드와 함께 호출되어야 합니다.\n\n# 고립되지 않은 함수\n\nSwift의 동시성 모델에서 액터 내의 비고립 멤버 개념이 중요한 역할을 합니다. 비고립 멤버를 통해 액터의 일부를 비동기 호출이나 액터 작업 대기 순번을 기다리지 않고도 액세스할 수 있습니다. 이는 액터 상태를 수정하지 않는 속성이나 메서드에 특히 유용하며, 이로 인해 경쟁 조건이나 다른 동시성 문제를 발생시키지 않습니다.\n\n```js\nactor Account {\n let accountNumber: String = \"IBAN...\" // 상수, 비고립 속성\n var balance: Int = 20 // 현재 사용자 잔고는 20\n  // 고립되지 않은 함수\n nonisolated func getMaskedAccountNumber() -> String {\n  return String.init(repeating: \"*\", count: 12) + accountNumber.suffix(4)\n }\n func withdraw(amount: Int) {\n  guard balance >= amount else { return }\n  self.balance = balance - amount\n }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n```js\nlet accountNumber = account.**getAccountNumber()**\n```\n\n당신의 예제에서 accountNumber는 Account actor 안에서 상수 속성(let)이며 변경불가능합니다. 이 불변성은 스레드 안전하고 격리가 필요하지 않다. 결과적으로, accountNumber는 actor의 일부임에도 불구하고 await 키워드 없이 동기적으로 액세스할 수 있습니다. 반면에 balance는 변경 가능한 속성이며 actor 내에서 격리가 필요합니다. withdraw 함수와 같은 balance와의 상호작용은 종종 비동기 액세스가 필요한 actor의 격리 프로토콜을 준수해야 합니다.\n\nactor 내부의 격리된 멤버와 격리되지 않은 멤버 사이의 구별은 중요합니다. 이는 엄격한 격리가 필요하지 않은 시나리오에서 성능을 최적화하고 코드를 간소화하는 데 도움이 됩니다. 동시성 관리와 안전성을 유지하면서도 actor 모델에 내재된 특성을 유지합니다.\n\n# 중요 사항\n\n<div class=\"content-ad\"></div>\n\n- Concurrency Management에 대한 배우기: 우리는 Swift Actors를 Swift 5.5의 동시성 모델의 중요한 부분으로 소개했는데, 이는 공유 가능한 가변 상태를 안전하게 처리하고 데이터 레이스를 방지하기 위해 특별히 설계되었습니다.\n- 동시성 문제 해결: Race 조건, 데드락, 리블락과 같은 일반적인 동시성 문제에 대해 이야기하고, Actor가 이러한 문제를 완화하는 방법을 보여줬습니다. 이러한 문제들은 전통적으로 DispatchQueue, Operations, 그리고 Locks를 이용해 관리되었습니다.\n- 쓰레드 안전성과 직렬 실행: Actor는 Swift 애플리케이션의 쓰레드 안전성을 강화합니다. 내부 큐 안에서 직렬로 작업을 처리하여 큐 관리자처럼 작동함으로써 작업이 한 번에 처리되도록 보장하며 이로써 동시성 충돌을 피합니다.\n- Cross-actor Reference 이해: Cross-actor 참조의 개념은 중요합니다. 이는 Actor의 속성이나 메서드에 접근하기 위해 await 키워드를 사용함으로써 효율적인 작업 관리를 위한 중단 지점을 표시하는 것을 필요로 합니다.\n- 직렬 Executors 대 DispatchQueues: Actor의 직렬 Executor와 직렬 DispatchQueue의 주요 차이를 강조했습니다. Actor는 엄격한 선입선출 순서에 묶이지 않으며 여러 요인에 기반해 작업을 우선 순위로 처리할 수 있습니다.\n- Actor와 상호 작용하는 규칙: Actor와 상호 작용하는 특정 규칙을 개요로 설명했는데, 가변 속성에 대한 비동기 접근과 격리된 함수를 기다리는 필요성을 강조했습니다.\n- Actors 내의 비 격리 구성원: Actor 내의 비 격리 구성원 개념을 소개했습니다. 이는 쓰레드 안전성을 저해하지 않고 특정 속성이나 메서드에 동기적으로 액세스하는 데 유용합니다.\n- 더 나은 이해를 위한 실제 예시: Account actor 예시를 통해, 우리는 Actor가 어떻게 상태를 안전하게 유지할 수 있는지 효과적으로 활용할 수 있는 방법에 대해 실제로 보여줬습니다.\n- Exectors에 대한 미래 전망: 미래의 토론에서 Exectors에 대한 심층적인 탐구를 약속하며, Swift의 동시성 모델 이 측면에 대해 보다 자세히 탐구할 것을 기대하고 있습니다.\n\n# 결론\n\nSwift Actors의 세계를 완전히 탐험한 우리의 여정을 통해, Swift의 동시성 모델에서 이 강력한 기능의 심오함과 복잡성을 발견했습니다. Actor는 Swift 5.5의 기본 부분으로, 우리가 공유 가능한 가변 상태와 동시성 문제에 접근하는 방식을 재정의하여 제공하며, 전통적인 방법인 DispatchQueue, Operations, Locks와 비교해 보다 강력하고 안전한 동시성 프로그래밍 도전을 처리하는 방법을 제공합니다.\n\nActor가 Race 조건, 데드락, 리블락과 같은 일반적인 동시성 문제에 대한 보호 기능으로 작용함을 보았는데, 기존 방법보다 스트리밍되고 효율적인 접근을 제공합니다. Actor의 도입은 동시성 관리를 단순화하는 중요한 진전을 나타내어 개발자들에게 더 접근성이 높고 오류가 적은 방법으로 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n앞으로 계속 발전해 나가는 동안, 미래 토론에서 Executor에 대해 더 심층적으로 파고들 수 있는 약속은 Swift의 동시성 모델에서 더 발전된 주제들을 다룰 수 있는 문을 열어줍니다. 이 탐험은 단지 프로그래밍 기능을 이해하는 데 그치지 않고, 더 안전하고 신뢰성이 높고 효율적인 Swift 코드를 작성하는 새로운 패러다임을 수용하는 데 관한 것입니다.\n\n맺음말로, Swift Actor는 Swift 개발자들에게 새로운 도구가 아닌, 우리가 동시성에 대해 생각하고 처리하는 방식에 근본적인 변화를 가져다 줍니다. 이는 코드를 더 안전하고 예측 가능하며 논리적으로 이해하기 쉽게 만들어줍니다. Swift Actor에 대한 이 탐험은 계속 발전하여 현대 소프트웨어 개발의 요구를 충족하기 위해 지속적으로 적응하고 개선하는 언어인 Swift의 진화의 증거입니다.","ogImage":{"url":"/assets/img/2024-05-18-SwiftActorsindepth_0.png"},"coverImage":"/assets/img/2024-05-18-SwiftActorsindepth_0.png","tag":["Tech"],"readingTime":14},{"title":"iOS 174 출시 - 지금 꼭 시도해봐야 할 25가지 이상의 멋진 새로운 기능","description":"","date":"2024-05-18 17:22","slug":"2024-05-18-iOS174Released25AmazingNewFeaturesYouNEEDToTryNow","content":"\n\niOS 17.4 업데이트가 드디어 공개되었습니다.\n\n지금 말씀드리는 것이 과장이 아니라면, iOS 17.4는 iOS 역사상 가장 큰 소규모 업데이트 중 상위 다섯에 들 수 있습니다. 왜냐하면?\n\n애플은 싫어하지만, EU의 법률과 조치를 준수하기 위해 회사가 타사 앱 스토어 및 브라우저 엔진을 허용하기 위해 소극적인 조치를 취해야 했습니다.\n\n이것은 역대급의 대단한 움직임입니다.\n\n<div class=\"content-ad\"></div>\n\n또한 업데이트로 16가지 이상의 새 이모티콘, iMessage에 대한 역사상 최고 수준의 보안 및 Podcasts, Wallet, CarPlay에 대한 다양한 새로운 변경 사항이 도입되었습니다. 이 변경 사항은 당신의 iPhone을 전에 없던 것으로 만들어줍니다.\n\niOS 17.4의 모든 주목할만한 기능 및 변경 사항에 대한 정보를 여기에 소개하겠습니다. 이는 당신이 경험한 최고의 iOS 환경을 위해 알아야 할 모든 크고 작은 변경 사항입니다.\n\n# 이 기사에서 다루는 내용\n\nEU-특정 변경 사항\n1 — Sideloading 활성화됨!\n2 — 제 3자 브라우저 엔진 지원\n일반 변경 사항\n새로운 메시지 변경 사항\n3 — 16가지 새 이모티콘\n4 — 비즈니스용 메시지\n5 — Siri가 다른 언어로 메시지를 읽어줄 수 있음\n6 — 지금까지 가장 안전한 iMessage\n새로운 설정 변경 사항\n7 — 도난 단말기 보호에 대한 중요한 변경 사항\n8 — 혁신적인 배터리 UI\n새로운 Podcasts & Music 변경 사항\n9 — 라이브 전사본과 함께 Podcasts 팔로우\n10 — 정보 보기 위해 에피소드 이름 탭하기\n11 — Shazam에서 선택한 음악 재생목록에 추가하기\n일관성을 위한 변경 사항\n12 — 혁신적인 iCloud 아이콘\n13 — 책, 음악 및 Podcasts를 위한 홈 섹션\n14 — Podcasts의 '현재 재생 중' 막대가 Apple Music을 모방\n새로운 연락처 변경 사항\n15 — 연락처 페이지를 위한 새 UI\n16 — 업체에 대한 Apple-검증 정보가 표시되는 전화 식별\n17 — 통화 화면을 위한 흐릿한 배경화면\n새로운 홈 및 잠금 화면 변경 사항\n18 — 새로운 시계 위젯\n19 — 홈 화면으로부터 설정된 배경화면은 기본적으로 흐리지 않음\n새로운 Shortcuts 변경 사항\n20 — 새로운 Shortcut 블록\n21 — 홈 화면에 Shortcut 추가를 위한 새 UI\n새로운 Wallet 변경 사항\n22 — Apple Card에 대한 가상 카드 번호 획득\n23 — Apple Pay 개선\n새로운 CarPlay 변경 사항 공개\n24 — 차량을 꺼닐 때 CarPlay이 작별 인사를 합니다.\n25 — 새로운 CarPlay 앱 및 아이콘\n새로운 백엔드 변경 사항\n26 — 게임 스트리밍이 이제 가능함\n27 — 케이블을 위한 펌웨어 업데이트!?\n28 — 제 3자 브라우저의 Passkeys에 액세스\n새로운 잡다한 변경 사항\n29 — 앱 스토어에서 구매 기록\n30 — AirDrop 2.0을 사용하여 노트 및 게임 공동 작업\n31 — 독일어에서 Siri 호출 시 'Hey' 삭제\n32 — TV의 혁신적인 '시청 방법' UI\n\n\n<div class=\"content-ad\"></div>\n\n# — 유럽 특별 변경사항 —\n\n# #1. 사이드로딩이 활성화되었습니다!\n\n사이드로딩이 iOS에 도착했습니다!\n— 이게 기술 역사상 가장 대단한 소식 중 하나 아닌가요?\n\n이 기능은 원본 앱 스토어 이외의 소스에서 앱을 설치할 수 있는 시설을 제공합니다 (대안적 앱 마켓이라고도 함) — 플레이 스토어, 아마존 앱스토어, & Setapp과 같이(이들이 iOS에 도착할지는 확실하지 않지만, 아이디어를 주기 위해 말씀 드립니다).\n\n<div class=\"content-ad\"></div>\n\n(앱 마켓플레이스 ≈ iOS 앱을 설치할 수 있는 iOS 앱)\n\n![image](/assets/img/2024-05-18-iOS174Released25AmazingNewFeaturesYouNEEDToTryNow_0.png)\n\n이것은 애플의 원래 App Store 이외에 iPhone에서 여러 앱 스토어를 동시에 사용할 수 있다는 것을 의미합니다.\n\n가장 좋은 점은 대체 앱 스토어를 기본 앱 스토어로 설정할 수 있다는 것입니다. 이것은 기본 브라우저를 변경하는 것만큼 쉽게 할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n하지만, Apple은 개인 정보 보호 및 보안 약속을 준수하여 대체 앱 스토어에서 설치된 앱의 악성 코드를 경고하고, 그렇다면 해당 앱을 열 수 없도록 합니다.\n\n또한 새로운 Screen Time 설정이 추가되어 부모님들이 자녀가 대체 앱 스토어에서 앱을 설치할 수 있는지 여부를 결정할 수 있게 됩니다.\n\n## 2. 3rd party 브라우저 엔진 지원\n\n또한 Apple은 타사 브라우저가 자체 브라우저 엔진을 사용할 수 있도록 지원합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n무엇이 브라우저 엔진인가요?\n모든 브라우저의 핵심적인 부품으로, 기본 HTML 문서를 아름다운 페이지로 변환해주는 역할을 합니다.\n각 브라우저는 엔진을 속도와 추가 기능을 개선할 수 있는 자유를 취할 수 있습니다.\n\n처음부터 Apple은 iOS에서 많은 브라우저를 허용해왔지만 엔진은 Webkit만 사용할 수 있었습니다 (Apple자체 엔진). 심지어 Blink와 Gecko를 다른 곳에서 사용하는 Chrome과 Firefox도 iOS에서는 WebKit에 고수해야 했습니다.\n\n이로 인해 제 3자 브라우저들이 많은 기능과 개선을 가져오는 자유가 제한되었습니다.\n\n하지만 이제 Apple이 iOS에서 WebKit 이외의 브라우저 엔진을 실행하는 데 관대한 태도를 취하기 시작했기 때문에, EU 지역 사용자들은 자신들이 좋아하는 브라우저에 더 많은 기능을 기대할 수 있습니다.\n```\n\n<div class=\"content-ad\"></div>\n\n애플은 iOS에서 엔진을 실행하기 전에 철저한 점검을 하지만, 대부분의 인기 있는 엔진은 잘 작동할 것으로 예상됩니다.\n\n# 일반적인 변경 사항\n\n## • 새 메시지 변경 사항\n\n### 3. 새 이모지 16개\n\n<div class=\"content-ad\"></div>\n\n애플이 Emoji 15.1 표준을 준수하는 새로운 16개의 이모티콘을 도입했어요. 이 이모티콘들에 대한 설명은 글의 끝에 모두 나와 있으니 참고하세요.\n\n- 첫 두 줄의 이모티콘은 새로운 개념이에요.\n- 세 번째 줄의 이모티콘은 이전의 왼쪽을 향한 이모티콘들의 혁신된 복사본이에요.\n- 네 번째 줄의 이모티콘은 가족 이모티콘 스위트(👨‍👩‍👧‍👦와 같은)들을 대체했어요.\n\n새로 추가된 이모티콘들과 그 설명을 게시글 끝에 모두 나열해 두었으니 확인해보세요.\n\n<div class=\"content-ad\"></div>\n\n## #4. 비즈니스를 위한 메시지\n\n설정 ⚙️ ` 메시지 💬에서 '비즈니스 및 개인 정보에 대한 메시지'라는 하이퍼링크가 있었습니다.\n\n이제 '비즈니스를 위한 메시지' 섹션으로 교체되었습니다.\n\n이 섹션에는 '비즈니스 업데이트'라는 단일 토글이 있어서, 비즈니스 웹 사이트에서 선택한 경우 주문 및 기타 거래에 대한 업데이트를받을 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n\n![image](/assets/img/2024-05-18-iOS174Released25AmazingNewFeaturesYouNEEDToTryNow_2.png)\n\nThe toggle is enabled by default.\n\n## #5. Siri can read out messages in different languages\n\nDid you know you could skip that step where Siri asks for confirmation before you send a message to someone?\n\n\n<div class=\"content-ad\"></div>\n\n\n![Image 1](/assets/img/2024-05-18-iOS174Released25AmazingNewFeaturesYouNEEDToTryNow_3.png)\n\nTo do that, toggle on ‘Automatically Send Messages’ in Settings ⚙️ Siri & Search. And bravo! You’ll never see that frustrating confirmation part again.\n\nHowever, with iOS 17.4, that section is replaced with ‘Messaging with Siri’ — where, along with Automatically Sending Messages, you can also select a few languages which Siri will use to read out messages for you.\n\n![Image 2](/assets/img/2024-05-18-iOS174Released25AmazingNewFeaturesYouNEEDToTryNow_4.png)\n\n\n<div class=\"content-ad\"></div>\n\n이것은 다양한 언어로 메시지를 주고 받는 국제적인 친구들이있으면 가장 도움이 됩니다. 여기서 설정한 언어는 Siri의 기본 언어에 영향을주지 않습니다.\n\n## #6. 가장 안전한 iMessage\n\n애플은 최근에 iMessage가 PQ3라고 불리는 혁신적인 후양자 암호 프로토콜을 사용하여 이제 보안될 것이라고 발표했습니다.\n\n이것은 iOS 17.4 (및 해당 버전)로 업데이트하는 모든 사람들을 위한 백엔드 변경 사항으로 사용자들이 \"선택\"해야 하는 것이 아닙니다.\n\n<div class=\"content-ad\"></div>\n\n회사는 PQ3의 보안이 \"널리 배포된 다른 모든 메시징 앱보다 뛰어나다\"며 \"세계에서 가장 강력한 보안 속성을 갖춘 다량 메시징 프로토콜이다\"고 주장합니다.\n\nApple은 PQ3가 어떻게 작동하는지 설명하고 있습니다:\n\n![image](/assets/img/2024-05-18-iOS174Released25AmazingNewFeaturesYouNEEDToTryNow_5.png)\n\n회사는 PQ3가 소위 레벨 3 보안을 달성한다고 주장합니다 - 이는 \"초기 키 설정 및 계속되는 메시지 교환 모두를 보호\"합니다.\n\n<div class=\"content-ad\"></div>\n\n# • 새로운 설정 변경 사항\n\n## #7. 스마트폰 도난 방지 기능에 중요한 변경 사항\n\niOS 17.3의 스마트폰 도난 방지 기능은 사용자의 개인 정보 보호와 보안을 위한 훌륭한 새로운 추가 기능입니다.\n\n이 기능은 중요한 시스템 설정을 변경하려는 경우 생체 인증 확인 및 1시간의 지연 시간을 설정합니다. 이 기사에서 자세한 정보 확인 →\n\n<div class=\"content-ad\"></div>\n\n그러나 익숙한 장소(집이나 직장과 같은)에 있는 경우에는 지연이 필요하지 않습니다. 낯선 장소에 있는 경우에만 두 가지를 모두 참석해야 합니다.\n\n그러나 iOS 17.4에서, Apple은 귀하의 iPhone이 위치에 관계없이 1시간의 지연을 시행할 수 있는 유용한 기능을 제공합니다. (설정에서 조정하세요 ⚙️ ' Face ID & Passcode 🙂 ' 스마트 기기 보호.)\n\n![이미지](/assets/img/2024-05-18-iOS174Released25AmazingNewFeaturesYouNEEDToTryNow_6.png)\n\n- '항상'을 선택하면 항상 1시간의 지연이 시행됩니다.\n- '익숙한 장소에서 멀리 떨어져 있음'을 선택하면 지연을 시행하기 전에 위치를 확인합니다. 익숙한 경우, 빠른 Face ID 확인 후에 중요 설정에 즉시 액세스할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## #8. 새롭게 개선된 배터리 UI\n\n애플이 왜 새로운 배터리 관련 변경 사항을 iPhone 15 시리즈에만 제공하는지 이해가 안 가네요. 어쨌든, 새로운 내용을 하나 또 소개해 드릴게요:\n\n![이미지](/assets/img/2024-05-18-iOS174Released25AmazingNewFeaturesYouNEEDToTryNow_7.png)\n\niPhone 15 시리즈 모델을 소유하신다면, 설정 ⚙️ ` 배터리 🔋로 이동하시면 '배터리 상태 및 충전' 섹션이 두 부분으로 나누어진 것을 확인할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n- 배터리 상태: 배터리 상태, 최대 용량, 사이클 횟수, 제조 날짜 및 최초 사용 날짜를 표시합니다.\n- 충전 최적화: 깨끗한 에너지 충전을 위한 토글과 최적화된 배터리 충전, 80% 제한, 또는 없음 중 선택할 수 있는 기능이 포함되어 있습니다.\n\n또한 기억하신다면, 이전에는 사이클 횟수가 설정 ⚙️ ` 일반 ⚙️ ` 정보에 있었지만 이제 배터리 상태로 이동되었습니다.\n\n# • 새로운 팟캐스트 및 음악 변경 사항\n\n## 9. 라이브 대본과 함께 팟캐스트 팔로우하기\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-05-18-iOS174Released25AmazingNewFeaturesYouNEEDToTryNow_8.png\" />\n\n팟캐스트 사용자들이 영원히 사랑할 환상적인 기능이에요.\n\n이건 팟캐스트의 애플 뮤직 가사 버전이에요. 이제 팟캐스트와 대본을 함께 따라갈 수 있어요. 이를 활성화하려면 왼쪽 하단의 대본 표시를 탭하면 돼요.\n\n가장 좋은 부분은, 대본에서 단어나 구를 검색할 수 있다는 거에요. 좋아하는 부분으로 건너뛰고 싶을 때 매우 유용해요. 주의:\n\n<div class=\"content-ad\"></div>\n\n- 트랜스크립트는 영어, 스페인어, 프랑스어 및 독일어를 지원합니다.\n- 트랜스크립트의 일부를 탭하여 팟캐스트의 해당 부분으로 건너뛸 수 있습니다.\n- 텍스트 크기, 대비 증가 및 VoiceOver와 같은 접근성 기능과 잘 작동합니다.\n\n## #10. 에피소드 이름을 탭하여 정보 보기\n\n이 기능은 꽤 멋진 기능입니다 — 이제 팟캐스트 에피소드의 이름을 탭하여 해당 정보 페이지로 이동할 수 있습니다.\n\n이를 Apple이 아래에 표시된대로 프롬프트로 제안할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n\n![Shazam](/assets/img/2024-05-18-iOS174Released25AmazingNewFeaturesYouNEEDToTryNow_9.png)\n\n## #11. Shazam에서 선택한 음악 재생목록에 추가\n\nShazam은 항상 별도의 Apple Music 재생목록을 갖고 있어 Shazamed 곡을 저장할 수 있었습니다.\n\n그러나 이제 Shazam 앱이나 제어 센터를 통해 노래를 Shazam하면 '추가' 버튼이 나타나며, 이를 통해 원하는 Apple Music 재생목록에 노래를 추가할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n지금은 Shazam에서 식별한 노래를 Spotify나 Apple Music Classical에서도 바로 재생할 수 있어요. 그냥 오른쪽 상단의 세 점을 탭해 보세요.\n\n![이미지](/assets/img/2024-05-18-iOS174Released25AmazingNewFeaturesYouNEEDToTryNow_10.png)\n\n# • 일관성을 위한 변경 사항\n\n## #12. 새롭게 디자인된 iCloud 아이콘\n\n<div class=\"content-ad\"></div>\n\nFiles 앱의 iCloud 아이콘이 업데이트되었습니다.\n\n![iCloud Icon](/assets/img/2024-05-18-iOS174Released25AmazingNewFeaturesYouNEEDToTryNow_11.png)\n\n이제 아이콘이 투명해지며 Mac 아이콘과 비슷해졌어요. 이것은 모든 Apple OS에서 일관성을 유지하는 좋은 일이에요.\n\n## #13. 책, 음악 및 팟캐스트용 홈 섹션\n\n<div class=\"content-ad\"></div>\n\n애플은 '홈'으로 Books, Music 및 Podcasts 앱의 모든 주요 섹션을 변경하여 간소화와 일관성을 제공했습니다.\n\n예를 들어:\n\n- Books: Read Now → Home\n- Music & Podcasts: Listen Now → Home\n\n![이미지](/assets/img/2024-05-18-iOS174Released25AmazingNewFeaturesYouNEEDToTryNow_12.png)\n\n<div class=\"content-ad\"></div>\n\n## 14. 팟캐스트의 '재생 중' 바가 애플 뮤직을 모방합니다\n\n또한, 팟캐스트 앱의 '재생 중' 바(하단)가 이제 애플 뮤직과 유사해졌습니다. 확인해보세요:\n\n이전에는:\n\n![image](/assets/img/2024-05-18-iOS174Released25AmazingNewFeaturesYouNEEDToTryNow_13.png)\n\n<div class=\"content-ad\"></div>\n\n이제는:\n\n![image](/assets/img/2024-05-18-iOS174Released25AmazingNewFeaturesYouNEEDToTryNow_14.png)\n\n# • 새로운 연락처 변경 사항\n\n## #15. 연락처 페이지를 위한 새로운 UI\n\n<div class=\"content-ad\"></div>\n\niOS 17.3 버전까지 연락처 페이지에서 연락처 사진이 화면의 절반 이상을 차지하여 더 많은 세부 정보를 확인하려면 아래로 스크롤해야 했습니다.\n\n하지만 이제 사진 공간이 상당히 축소되어 다른 세부 정보에 더 많은 공간이 남게 되었습니다. 내 생각에는 이게 더 좋습니다.\n\n![Contact Photo](/assets/img/2024-05-18-iOS174Released25AmazingNewFeaturesYouNEEDToTryNow_15.png)\n\n## #16. 전화 식별은 비즈니스를 위한 애플 검증 정보를 표시합니다\n\n<div class=\"content-ad\"></div>\n\niOS 17.4 릴리스 노트에서 Apple은 Apple 식별 비즈니스로부터 전화를 받으면 iPhone의 통화 화면에 사용 가능한 경우 비즈니스 이름, 로고, 부서 이름이 표시된다고 언급합니다.\n\n#### 17. 통화 화면에 대한 흐릿한 배경 화면\n\n<div class=\"content-ad\"></div>\n\n아이폰으로 통화 중에 상대방과 이야기하고 있다면, 전화 화면의 배경이 더 이상 일반적인 회색이 아닌 당신의 배경화면의 흐린 버전으로 변경되었음을 알 수 있을 거에요.\n\n![](/assets/img/2024-05-18-iOS174Released25AmazingNewFeaturesYouNEEDToTryNow_16.png)\n\n# • 새로운 홈 및 잠금 화면 변경\n\n## #18. 새로운 시계 위젯\n\n<div class=\"content-ad\"></div>\n\n우리는 새로운 시계 위젯을 받았어요 — '시티 디지털'이라고 해요:\n\n![City Digital](/assets/img/2024-05-18-iOS174Released25AmazingNewFeaturesYouNEEDToTryNow_17.png)\n\n이 위젯은 다른 시티 위젯들이 보여주는 정보를 그대로 표시하지만, 정사각형 모양이고 디지털 시간을 표시해요.\n\n그리고 이 위젯은 하루 시간에 반응해서, 시골의 날이며 밤이면 검은색으로 변하고, 낮이면 흰색으로 보여요.\n\n<div class=\"content-ad\"></div>\n\n## #19. 홈 화면에서 벽지 설정 시 기본적으로 흐림 처리되지 않음\n\n애플이 사용자 친화성을 위해 이렇게 했습니다.\n\n- 잠금 화면에서 사진 앱의 벽지를 적용하면 홈 화면의 벽지가 기본적으로 흐리게 표시됩니다.\n- 그러나 사진 앱에서 직접 적용하는 경우(공유 ` 벽지로 사용) 홈 화면이 기본적으로 일반적으로 표시됩니다.\n\n![이미지](/assets/img/2024-05-18-iOS174Released25AmazingNewFeaturesYouNEEDToTryNow_18.png)\n\n<div class=\"content-ad\"></div>\n\n이미지를 언제든지 흐리게하거나 흐리게 한 후에 다시 표시할 수 있습니다.\n\n# • 새로운 바로 가기 변경 내용\n\n## #20. 새로운 바로 가기 블록\n\n바로 가기 중독자 (나처럼)이라면, 여기 새로운 블록이 있어요 — Get Physical Activity 🚶‍♂️‍➡️.\n\n<div class=\"content-ad\"></div>\n\n\n![Image](/assets/img/2024-05-18-iOS174Released25AmazingNewFeaturesYouNEEDToTryNow_19.png)\n\n현재 움직임을 나타내는 신체 활동을 반환합니다 (걷기, 뛰기 또는 이동 차량).\n\niPhone, iPad 및 Apple Watch에서는 내장 센서를 사용하여 신체 활동을 결정하고 반환합니다. 다른 모든 기기에서는 \"알 수 없음\"을 반환합니다.\n\n## #21. 홈 화면에 바로 가기 추가를 위한 새로운 UI\n\n\n<div class=\"content-ad\"></div>\n\n이것은 놀라운 사용자 경험 변경입니다.\n홈 화면에 바로 가기를 추가하려고 하는 경우, 이제 실제 배경화면이 뒤에 있는 미리보기를 볼 수 있습니다.\n\n![Shortcut Preview](/assets/img/2024-05-18-iOS174Released25AmazingNewFeaturesYouNEEDToTryNow_20.png)\n\n이것은 바로 가기의 색상과 아이콘이 배경과 잘 어울리는지 확인하는 데 도움이 될 것입니다.\n\n# • 새로운 월렛 변경내역\n\n<div class=\"content-ad\"></div>\n\n## #22. Apple Card용 가상 카드 번호 받기\n\n애플 캐시 카드는 애플 월렛에 필수적인 기능입니다.\n\n가장 간단한 방법으로 친구나 가족들에게 돈을 보내거나 받을 수 있습니다. 또한 Apple Pay를 허용하는 상점에서 기타 선불 카드와 같이 사용할 수도 있습니다.\n\n하지만 Apple Pay를 지원하지 않는 상점/웹사이트에서 카드 세부 정보를 요청하는 경우는 어떻게 해야 할까요?\n\n<div class=\"content-ad\"></div>\n\n문제 없어요. iOS 17.4에서는 기존 가상 Apple Cash 카드에 대한 카드 번호, 만료 날짜 및 보안 코드 세트를 생성할 수 있어요.\n\n![이미지](/assets/img/2024-05-18-iOS174Released25AmazingNewFeaturesYouNEEDToTryNow_21.png)\n\n가장 좋은 점은,\n\n- 카드 세부 정보가 침해되었을 경우 언제든지 새로운 세트를 생성할 수 있어요. 기존 세부 정보는 더 이상 사용할 수 없어요.\n- 업데이트된 카드 세부 정보는 자동으로 Safari Autofill에 저장돼요.\n- 보안 코드는 주기적으로 변경돼 안전을 보장해요.\n\n<div class=\"content-ad\"></div>\n\n## #23. Apple Pay 개선\n\n![이미지](/assets/img/2024-05-18-iOS174Released25AmazingNewFeaturesYouNEEDToTryNow_22.png)\n\n설정 ⚙️ ` 개인 정보 및 보안 ✋ ` 분석 및 개선 항목에 새로운 분석 옵션이 있습니다. 기본적으로 비활성화되어 있습니다.\n\n활성화하면, Apple이 Apple Pay 및 연결된 계정에서 귀하의 거래 정보를 익명으로 저장할 수 있어 Apple Pay를 개선할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n하지만 제가 항상 말씀드리듯이, 분석기를 꺼두면 배터리를 절약할 수 있어요.\n\n# • 새로운 CarPlay 변경 내용 공개\n\n애플이 WWDC22에서 차세대 CarPlay를 미리 보여주었고, 우리에게 2023년 말에 도입될 것이라고 말했어요. 그런데 안타깝게도, 이미 2023년은 지나갔죠!\n\n그래서 애플은 CarPlay 웹페이지를 업데이트하여 \"첫 번째 모델이 2024년에 도착할 것\"이라고 말했어요. 그리고 𝕏의 Aaron (@aaronp613)는 iOS 17.4의 코드에서 새로운 아이콘과 애니메이션을 발견했답니다.\n\n<div class=\"content-ad\"></div>\n\n## #24. 차량을 끌 때 CarPlay이 작별 인사를 합니다\n\n차량을 끌 때, iPhone과 Mac이 부팅될 때 처럼 유사한 작별 애니메이션이 표시될 수 있습니다.\n\n![image](/assets/img/2024-05-18-iOS174Released25AmazingNewFeaturesYouNEEDToTryNow_23.png)\n\n## #25. 새로운 CarPlay 앱 및 아이콘\n\n<div class=\"content-ad\"></div>\n\nAaron은 CarPlay 2.0에서 새 아이콘도 발견했어요. 𝕏에서의 그의 전체 쓰레드를 확인해보세요:\n\n그리고 MacRumors가 강조한 대로, 차세대 CarPlay에 추가될 새 앱이 8개가 있어요:\n\n- Auto Settings: 페어링된 아이폰을 관리하고 차량 설정을 변경할 수 있어요.\n- Car Camera: 차량 뒷면 카메라의 영상을 표시해줘요.\n- Charge (전기차 전용): 배터리 레벨, 충전 상태, 완전히 충전될 때까지 남은 시간 등을 표시해줘요.\n- Climate: 차량의 기후 제어 기능을 제어할 수 있어요 — AC 온도 조절, 팬 속도 조절, 시트 및 핸들 열선 등.\n- Closures: 문이 실수로 열린 상태 인지하고 차량의 경고 심볼을 표시해줘요.\n- Media: FM 및 AM 라디오를 재생할 수 있고, SiriusXM도 재생할 수 있어요. 하지만 SiriusXM은 위성을 통해 제공될지 아니면 인터넷 제한이 될지 확실하지 않아요.\n- Tyre Pressure: 각 타이어의 공기 압력을 표시하고 높은 또는 낮은 압력 및 평평한 타이어를 알립니다.\n- Trips: 여행 중 평균 속도, 연료 또는 에너지 효율성, 경과 시간 및 이동 거리 등의 정보를 제공합니다.\n\n많은 인기 있는 자동차 제조사들이\n\n<div class=\"content-ad\"></div>\n\n```js\nAcura, Aston Martin, Audi, Ford, Honda, Infiniti, Jaguar, Land Rover, Lincoln, Mercedes-Benz, Nissan, Polestar, Porsche, Renault, and Volvo\n```\n\n자동차에 CarPlay 2.0을 도입하기로 이미 약속한 것을 알고 있습니다.\n\n# • 새로운 백엔드 변경 사항\n\n## #26. 게임 스트리밍이 이제 가능합니다\n  \n\n<div class=\"content-ad\"></div>\n\n애플은 최근 개발자 기사에서 게임 스트리밍에 대해 이야기했습니다. 다음과 같이 나와 있어요:\n\n```js\n게임 스트리밍이란 무엇인가요?\n클라우드 서버에서 게임을 실행하고 게임의 비디오와 사운드를 사용자 디바이스로 직접 스트리밍하는 온라인 게임의 한 종류입니다.\n이를 통해 사용자들은 강력한 네트워크 연결만 있으면 저전력 장치에서도 고사양 게임을 쉽게 플레이할 수 있습니다.\n```\n\n지금까지 iOS에서의 게임 스트리밍은 웹앱을 통해 브라우저로만 이용할 수 있었는데, 이는 게임을 경험하기에 편하지도 몰입할 수 없는 방식이었습니다.\n\n하지만 이 동작은 Xbox Cloud Gaming과 Nvidia GeForce NOW와 같은 서비스가 스탠드얼론 앱으로 앱 스토어에 진입하게 해주며, 게임에 능숙한 사용자들에겐 큰 소식입니다.\n\n<div class=\"content-ad\"></div>\n\n## #27. 케이블용 펌웨어 업데이트!?\n\nAaron의 보도에 따르면, iOS 17.4 코드에 Apple이 다음을 위한 펌웨어 업데이트 지원을 추가한다는 내용이 포함되어 있습니다:\n\n- USB-C 커넥터가 장착된 EarPods\n- USB-C to 3.5 mm 헤드폰 잭 어댑터\n\n이것은 놀라운 소식인데요, 제가 예상했던 것보다 Apple이 심지어 구식 와이어에도 펌웨어 업데이트를 제공할 수 있다니요.\n\n<div class=\"content-ad\"></div>\n\n음향 품질 및 케이블의 데이터 전송에 대한 개선 사항을 각 업데이트마다 발견할 수 있을 것 같아요.\n\n## #28. 타사 브라우저용 패스키 액세스\n\n설정 ⚙️ ` 개인 정보 및 보안 ✋` 에 새로운 섹션인 웹 브라우저용 패스키 액세스가 있어요.\n\n![이미지](/assets/img/2024-05-18-iOS174Released25AmazingNewFeaturesYouNEEDToTryNow_24.png)\n\n<div class=\"content-ad\"></div>\n\n여기에 애플은 당신이 저장한 패스키를 볼 수 있는 권한을 요청한 애플리케이션을 나열합니다. 여기에서 그들의 액세스를 손쉽게 켜거나 끌 수 있습니다. \n\n패스키가 무엇인지, 그리고 어떻게 작동하는지 알고 싶다면, 이 항목을 읽어보세요:\n\n# • 새로운 기타 변경사항\n\n## #29. 앱 스토어의 구매 내역\n\n<div class=\"content-ad\"></div>\n\n앱 스토어는 이제 '구매 기록'이라는 새 섹션에서 모든 구매 내역을 전체적으로 보여줄 수 있습니다.\n\n보시려면 앱 스토어를 열고 프로필을 클릭하여 '구매 기록'을 선택하십시오.\n\n![Purchase History](/assets/img/2024-05-18-iOS174Released25AmazingNewFeaturesYouNEEDToTryNow_25.png)\n\n지불한 앱 및 게임, 구독, 인앱 구매가 모두 포함되어 있습니다.\n\n<div class=\"content-ad\"></div>\n\n또한, '구매한 제품' 섹션이 이제 '앱'으로 이름이 바뀌었습니다. 위의 이미지를 확인해보세요. 그것은 첫 번째입니다.\n\n## #30. 에어드랍 2.0을 이용하여 노트 및 게임 공동 작업\n\n애플은 iOS 17의 출시 이후 NameDrop을 소개했습니다. 이를 통해 사용자들은 서로 전화기를 탭하여 연락처를 교환할 수 있습니다.\n\n파일을 공유하는 데도 효과적입니다.\n그러나 iOS 17.4부터 한 단계 발전합니다.\n\n<div class=\"content-ad\"></div>\n\n아이폰을 서로 가까이 대조하여 협업 노트를 작성하거나 지원되는 게임을 플레이할 수 있습니다(게임 센터 사용).\n\n## #31. 독일어로 Siri 호출 시 Hey 생략\n\n이전에 Siri를 깨우려면 \"Hey Siri\"라고 말해야 했습니다. 그러나 iOS 17부터 그냥 \"Siri\"라고 줄여서 말할 수 있는 옵션이 추가되었습니다. \n\n![이미지](/assets/img/2024-05-18-iOS174Released25AmazingNewFeaturesYouNEEDToTryNow_26.png)\n\n<div class=\"content-ad\"></div>\n\n그러나 아직 모든 언어와 호환되지는 않습니다. 그리고 iOS 17.4에서는 독일어가 호환되는 언어로 포함되었습니다.\n\n## #32. TV의 새롭게 디자인된 ‘시청 방법’ UI\n\nApple TV 앱의 거의 모든 영화나 TV 프로그램에는 \"시청 방법\"이라는 섹션이 아래에 표시됩니다. 이 섹션에는 미디어를 호스팅하는 모든 스트리밍 서비스(디즈니+, 애플 TV+, 넷플릭스 등)가 표시됩니다.\n\niOS 17.3 이전까지 이들은 나란히 배치되어 있어서 더 많은 것을 보려면 왼쪽으로 스와이프해야 했습니다. 그러나 이제 이들은 서로 위에 쌓이도록 되어 있어서 일목요연하게 모두를 볼 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n\n![Image](/assets/img/2024-05-18-iOS174Released25AmazingNewFeaturesYouNEEDToTryNow_27.png)\n\n## iOS 17이 대박인게 아니에요?\n\n## iOS 17의 290가지 이상의 새로운 기능: 연속 업데이트 중:\n\n## 마침내,\n\n\n<div class=\"content-ad\"></div>\n\n만약 iOS 및 Mac 앱을 탐험하는 것을 좋아한다면 (저와 같은), Setapp을 구독해 보세요. 매월 $9.99에 240개 이상의 놀라운 앱이 든 컬렉션에 액세스할 수 있습니다. 이것은 개별 구매 시 수백 달러가 필요한 것들입니다.\n\n- Setapp 여행을 시작하는 내 제휴 링크를 사용하세요! (30일간 무료)\n- Setapp에서 100개 이상의 최고의 macOS 앱 목록을 무료로 받아보세요.\n\n새로운 이야기를 게시할 때마다 알림을 받으려면 460명 이상의 사람 중 하나가 되세요!\n\n# 부록: 모든 새 이모지 목록\n\n<div class=\"content-ad\"></div>\n\n\n![Image](/assets/img/2024-05-18-iOS174Released25AmazingNewFeaturesYouNEEDToTryNow_28.png)\n\n## Emojis of first two lines\n\n- 🙂‍↕️ — Head shaking vertically\n- 🙂‍↔️ — Head shaking horizontally\n- ⛓️‍💥 — Broken chain\n- 🍄‍🟫 — Brown mushroom\n- 🍋‍🟩 — Lime\n- 🐦‍🔥 — Phoenix\n\n## Emojis of third Line\n\n\n<div class=\"content-ad\"></div>\n\n- 🚶‍➡️ — 오른쪽을 향해 걷는 사람\n- 🏃‍➡️ — 오른쪽을 향해 뛰는 사람\n- 🧎‍➡️ — 오른쪽을 향해 무릎을 꿇은 사람\n- 🧑‍🦯‍➡️ — 오른쪽을 향해 하얀 보조 지팡이를 쓴 사람\n- 🧑‍🦽‍➡️ — 오른쪽을 향해 수동 휠체어를 탄 사람\n- 🧑‍🦼‍➡️ — 오른쪽을 향해 전동 휠체어를 탄 사람\n\n더 많은 비슷한 이모티콘들과 성별·피부색을 나타내는 이모지들이 있어요. 모두 Emojipedia에서 확인해보세요.\n\n## 가족 이모지\n\n<img src=\"/assets/img/2024-05-18-iOS174Released25AmazingNewFeaturesYouNEEDToTryNow_29.png\" />\n\n<div class=\"content-ad\"></div>\n\n위의 네 개 테이블 태그를 마크다운 형식으로 변경해주세요.\n\n<div class=\"content-ad\"></div>\n\n- 👨‍👨‍👦 — 두 아빠와 아들이 있는 가족\n- 👨‍👨‍👧 — 두 아빠와 딸이 있는 가족\n- 👨‍👩‍👦 — 엄마, 아빠, 아들이 있는 가족\n- 👨‍👩‍👧 — 엄마, 아빠, 딸이 있는 가족\n- 👪 — 두 부모, 아이가 있는 가족\n- 👩‍👩‍👦 — 두 엄마와 아들이 있는 가족\n- 👩‍👩‍👧 — 두 엄마와 딸이 있는 가족\n\n세 번째 이모지를 대체합니다:\n\n- 👩‍👦‍👦 — 엄마와 두 아들이 있는 가족\n- 👩‍👧‍👦 — 엄마, 딸, 아들이 있는 가족\n- 👩‍👧‍👧 — 엄마와 두 딸이 있는 가족\n- 👨‍👦‍👦 — 아빠와 두 아들이 있는 가족\n- 👨‍👧‍👦 — 아빠, 딸, 아들이 있는 가족\n- 👨‍👧‍👧 — 아빠와 두 딸이 있는 가족\n\n네 번째 이모지를 대체합니다:\n\n<div class=\"content-ad\"></div>\n\n마크다운 형식으로 테이블 태그 변경하기:\n\n| 이모지 | 설명 |\n| --- | --- |\n| 👨‍👦 | 아빠와 아들이 있는 가족 |\n| 👨‍👧 | 아빠와 딸이 있는 가족 |\n| 👩‍👦 | 엄마와 아들이 있는 가족 |\n| 👩‍👧 | 엄마와 딸이 있는 가족 |","ogImage":{"url":"/assets/img/2024-05-18-iOS174Released25AmazingNewFeaturesYouNEEDToTryNow_0.png"},"coverImage":"/assets/img/2024-05-18-iOS174Released25AmazingNewFeaturesYouNEEDToTryNow_0.png","tag":["Tech"],"readingTime":18},{"title":"스위프트 플레이그라운드에서 머신 러닝 모델을 사용하는 방법","description":"","date":"2024-05-18 17:20","slug":"2024-05-18-HowtouseaMLmodelinSwiftPlaygrounds","content":"\n\n<img src=\"/assets/img/2024-05-18-HowtouseaMLmodelinSwiftPlaygrounds_0.png\" />\n\n많은 사람들처럼, 올해의 Swift Student Challenge 아이디어를 개발하면서 내가 많은 시간을 쏟으면서 내 인내심을 시험받는 여러 가지 장애물을 만났어. 그래서, 몇 밤을 잠 못 이루게 한 문제에 대한 해결책을 공유하고 싶어: Swift Playgrounds에서 CoreML을 구현하는 방법.\n\n앱이 SSC에 참가하기 위한 요구 사항 중 하나는 Swift Playground여야 한다는 것을 아실 것입니다. 그러나 이러한 종류의 프로젝트는 장단점을 갖고 있어. Swift Playground는 Apple이 만든 대화형 개발 환경으로, 개발자와 프로그래밍 학습자들이 빠르고 쉽게 Swift 코드를 작성, 테스트, 시각화할 수 있게 해줘. Swift Playgrounds는 macOS용 Apple의 종합 개발 스위트인 Xcode와 iPad용 독립형 앱으로 모두 사용할 수 있어. 이 환경은 프로그래밍을 배우거나 Swift로 새로운 아이디어나 알고리즘을 실험하는 데 특히 유용해.\n\n반면에 Core ML (Core Machine Learning)은 Apple이 개발한 프레임워크로, iOS, macOS, watchOS 및 tvOS 앱에 머신 러닝 모델을 통합할 수 있게 해줘. Core ML을 사용하면 개발자들은 사전 훈련된 머신 러닝 모델을 활용하여 이미지 인식, 자연어 처리, 데이터 분석 등의 작업을 인터넷 연결 없이 효율적이고 실시간으로 수행할 수 있어.\n\n<div class=\"content-ad\"></div>\n\n이제 표준 Swift 프로젝트에서 Core ML을 사용하는 것은 매우 간단합니다. 우리 모델을 프로젝트에 추가하기만 하면 앱에서 사용할 수 있습니다. 그러나 이 글을 작성하는 시점에서 Swift Playground에서의 사용은 조금 복잡합니다. 후자의 형식에서는 앱에서 모델을 사용하려면 해당 모델이 앱에 의해 사용되도록 설정해야 하는 일련의 단계를 따라야 합니다. 이는 잘 문서화되어 있고 웹의 다양한 위치에서 찾을 수 있습니다. 그럼에도 불구하고, Xcode 15가 출시되면서 사용자들 사이에 널리 알려지지 않은 마지막 단계가 있습니다.\n\n## 첫 번째 단계: 파일 가져오기\n\nSwift Playgrounds 프로젝트에서 ML 모델을 사용하려면, 모델의 .mlmodel 파일을 추가할 임시 Swift 프로젝트를 먼저 준비해야 합니다. 이 프로젝트를 컴파일함으로써 두 가지를 달성할 수 있습니다: 해당 프로젝트의 클래스 파일과 컴파일된 모델 얻기. 이 두 가지는 Playground를 통해서는 불가능하기 때문에, 많은 사람들이 첫 시도에서 CoreML 모델을 성공적으로 구현하지 못한 것일 수 있습니다.\n\n첫 번째 단계에서는, 단순히 임시 앱을 빌드하고, Xcode 파일 탐색기에서 .mlmodel 파일을 클릭한 다음 Model Class 옆에 우리 CoreML 모델의 이름을 클릭하세요.\n\n<div class=\"content-ad\"></div>\n\n\n![ML model class file](/assets/img/2024-05-18-HowtouseaMLmodelinSwiftPlaygrounds_1.png)\n\nThis will take you to the class file of our CoreML model, which acts as the interface between the model and our app. It allows us to provide information and receive a processed response from it.\n\n![Show in Finder](/assets/img/2024-05-18-HowtouseaMLmodelinSwiftPlaygrounds_2.png)\n\nWhile completing the remaining steps, we need to create a copy of this file and save it in another folder. Right-click on the file, choose \"Show in Finder,\" and create a duplicate.\n\n\n<div class=\"content-ad\"></div>\n\n\n![ML model in Swift Playgrounds](/assets/img/2024-05-18-HowtouseaMLmodelinSwiftPlaygrounds_3.png)\n\n![ML model in Swift Playgrounds](/assets/img/2024-05-18-HowtouseaMLmodelinSwiftPlaygrounds_4.png)\n\n다음 단계는 CoreML 모델의 컴파일된 버전을 획득하는 것입니다. 이를 위해 먼저 응용 프로그램의 컴파일된 파일, 빌드에 액세스해야 합니다. 이를 찾으려면 Finder를 열고 명령 ⌘ + Shift + G를 사용하세요. 그런 다음 다음 경로로 이동하세요:\n\n~/Library/Developer/Xcode/DerivedData\n\n\n<div class=\"content-ad\"></div>\n\n이 디렉터리 내에서 임시 앱 이름으로된 폴더를 찾아 들어가야 해요.\n\n![Folder 5](/assets/img/2024-05-18-HowtouseaMLmodelinSwiftPlaygrounds_5.png)\n\n폴더 안으로 들어가서 Build/Products/Debug-iphonesimulator로 이동해주세요.\n\n![Folder 6](/assets/img/2024-05-18-HowtouseaMLmodelinSwiftPlaygrounds_6.png)\n\n<div class=\"content-ad\"></div>\n\n![그림1](/assets/img/2024-05-18-HowtouseaMLmodelinSwiftPlaygrounds_7.png)\n\n![그림2](/assets/img/2024-05-18-HowtouseaMLmodelinSwiftPlaygrounds_8.png)\n\n여기서 우리는 임시 앱 이름으로 된 파일을 찾을 수 있습니다. 이 파일에 마우스 오른쪽 버튼을 클릭하고 \"Package Contents 표시\"를 선택합니다.\n\n![그림3](/assets/img/2024-05-18-HowtouseaMLmodelinSwiftPlaygrounds_9.png)\n\n<div class=\"content-ad\"></div>\n\n여기서 우리가 원하던 것을 찾을 수 있습니다: 컴파일된 ML 모델, .mlmodelc 파일(c는 컴파일된 형태를 의미합니다). 클래스 파일과 마찬가지로 이 파일의 사본을 만들어 쉽게 접근할 수 있는 위치에 저장하세요.\n\n![이미지](/assets/img/2024-05-18-HowtouseaMLmodelinSwiftPlaygrounds_10.png)\n\n이 두 파일을 가지고 있다면, 모델을 변경하거나 업데이트할 일이 없는 한 임시 앱에 대해서 잊을 수 있습니다. 모델을 변경하려면 이전 단계를 반복해야 합니다. 이제 우리는 플레이그라운드 프로젝트로 넘어가 마지막 단계를 수행하겠습니다.\n\n## 두 번째 단계: 플레이그라운드 설정하기\n\n<div class=\"content-ad\"></div>\n\n이제 프로젝트를 구하는 데 도움이 된 단계로 넘어갑시다. 모델을 사용하려면 플레이그라운드를 마무리하려면 몇 가지 최종 조정이 필요합니다. 먼저, 클래스 파일을 프로젝트 내에 배치하십시오. 추가로, ML 모델을 넣을 폴더를 만들고 다른 것은 아무것도 넣지 마십시오. 저는 편의상 MLFile이라는 이름을 붙였습니다.\n\n![이미지](/assets/img/2024-05-18-HowtouseaMLmodelinSwiftPlaygrounds_11.png)\n\n이제 Xcode를 닫고 Finder에서 프로젝트 위치로 이동해야 합니다. 파일에서 마우스 오른쪽 버튼을 클릭하고 \"패키지 내용 보기\"를 선택하십시오.\n\n![이미지](/assets/img/2024-05-18-HowtouseaMLmodelinSwiftPlaygrounds_12.png)\n\n<div class=\"content-ad\"></div>\n\n이것은 Playgrounds 프로젝트의 내용을 보여줄 것입니다. 그 안에서 Package.swift 파일을 찾아 열어봅니다.\n\n![Package.swift 파일](/assets/img/2024-05-18-HowtouseaMLmodelinSwiftPlaygrounds_13.png)\n\n이 파일 안에는 프로젝트 구성 정보가 있습니다.\n\n![프로젝트 구성](/assets/img/2024-05-18-HowtouseaMLmodelinSwiftPlaygrounds_14.png)\n\n<div class=\"content-ad\"></div>\n\ntargets 섹션 내에서 .executableTarget() 메서드로 이동하여 아래 내용을 매개변수로 추가해주세요:\n\n```js\nresources: [\n                .process(\"Resources\"),\n                .copy(\"<ModelFolderName>/<YourModelName>.mlmodelc\")\n            ]\n```\n\n저의 프로젝트에서는 다음과 같이 나타날 겁니다:\n\n![이미지](/assets/img/2024-05-18-HowtouseaMLmodelinSwiftPlaygrounds_15.png)\n\n<div class=\"content-ad\"></div>\n\n## 이제 모두 준비되었습니다!\n\n좋아요! 이제 Swift Playground App 프로젝트 내에서 우리의 ML 모델을 사용할 수 있게 되었습니다. 이 변경이 필요한 이유는 Playground가 일반 프로젝트와 다르게 작동하기 때문입니다. 우리가 리소스를 사용할 때 Playground는 프로젝트의 구조를 무시하고, 만들어 둔 폴더 구조를 존중하는 대신에 포함된 파일을 추출하여 모두 한데 모읍니다. 이는 동일한 이름의 파일이 다른 폴더에 있더라도 컴파일 중 충돌을 일으킬 수 있다는 것을 의미합니다. 이는 우리의 Swift Package 내 .process() 메서드의 덕분입니다. .copy()를 구현함으로써, 우리가 지정한 폴더나 파일에 대해 폴더 구조가 존중되도록 보장합니다.\n\n이제 우리 프로젝트가 요구하는 CoreML 구현을 계속하면 됩니다. 이 해결책이 여러분께 몇 시간의 불면의 밤을 덜어주고 프로젝트를 더 나은 수준으로 이끌 수 있기를 바랍니다. 행운을 빕니다!\n\n도움이 필요하거나 중간에 질문이 생기면 언제든지 연락해 주세요!","ogImage":{"url":"/assets/img/2024-05-18-HowtouseaMLmodelinSwiftPlaygrounds_0.png"},"coverImage":"/assets/img/2024-05-18-HowtouseaMLmodelinSwiftPlaygrounds_0.png","tag":["Tech"],"readingTime":6},{"title":"네이티브 iOS 느낌을 Compose Multiplatform 앱에서 가져오기","description":"","date":"2024-05-18 17:18","slug":"2024-05-18-GettingthenativeiOSlookfeelinyourComposeMultiplatformapp","content":"\n\nCompose의 기본 모양과 느낌은 Material Design입니다. Compose Multiplatform에서는 일부 요소를 iOS에서 더 네이티브하게 느끼도록 조정했습니다. 예를 들어, 버전 1.5부터 iOS의 스크롤 효과를 해당 플랫폼의 것과 유사하도록 만들었습니다. 그러나 대부분의 UI 요소는 여전히 Material처럼 보입니다. 앱에서 iOS 네이티브 룩 앤 필을 더 얻는 쉬운 방법을 살펴보겠습니다.\n\n![image](/assets/img/2024-05-18-GettingthenativeiOSlookfeelinyourComposeMultiplatformapp_0.png)\n\n우리는 Compose Cupertino라는 라이브러리를 사용할 것입니다. 이 라이브러리는 여러 가지 버전으로 제공됩니다:\n\n- cupertino: Compose를 사용하여 iOS와 유사한 위젯을 구축했습니다;\n- cupertino-native: 네이티브 UIKit 구성 요소 주변의 래퍼;\n- cupertino-adaptive: 안드로이드에서 Material Design을 사용하는 적응형 테마/래퍼 및 iOS의 cupertino와 cupertino-native의 일부 위젯을 사용합니다 (이 글의 주된 내용);\n- cupertino-icons-extended: 가장 많이 사용되는 Apple SF Symbols 800개 이상(참고: 이들은 저작권이 있으며 라이센스 계약을 준수해야 합니다);\n- cupertino-decompose: 화면 전환 및 스와이프 동작의 네이티브 느낌.\n\n<div class=\"content-ad\"></div>\n\n이 글에서는 얼마나 쉽게 Adaptive 플레이버를 사용하여 앱의 시스템 바(상단바 + 내비게이션/탭바) 및 주요 구성 요소(버튼 + 로딩 인디케이터 + 대화상자)를 개선할 수 있는지 살펴볼 것입니다. 라이브러리에는 더 많은 기능이 있으므로 이 글은 그에 대한 소개이고 완벽한 안내서는 아닙니다. 또한 Android에서 iOS 모습을 테스트하는 방법도 알아볼 것입니다!\n\n# 작동 원리는 무엇인가요?\n\nCupertino의 네이티브 룩을 가진 위젯은 Compose를 사용하여 완전히 재구성된 iOS 구성 요소입니다. 이것은 실제 네이티브 컴포넌트가 아니라 그 모습을 그대로 보이도록 그려진 것이라는 것을 의미합니다. 그 점에 대해 우리는 걱정할 필요가 있을까요? 나는 그렇지 않다고 생각합니다. 왜냐하면 이것은 Compose 자체가 안드로이드 컴포넌트를 재구성하는 방식과 비슷하기 때문입니다. 이들은 레거시 android.view 컴포넌트에 의존하는 대신 캔버스에 그려집니다.\n\nCupertino Adaptive는 Material 컴포넌트뿐만 아니라 그들의 API를 염두에 두고 만들어졌습니다. 즉, 현재 사용 중인 많은 Material 컴포넌트를 Adaptive 대체품으로 사용 가능합니다. 단 몇 초 내에 교체할 수 있습니다. Android에서는 여전히 동일한 기본 코드를 호출하지만, iOS에서는 네이티브 컴포넌트처럼 보이게 그려집니다. 예외는 AdaptiveAlertDialogNative와 같이 *Native로 끝나는 적응형 위젯입니다. 그것은 대화 상자를 위한 실제 UIKit 컴포넌트를 호출하는 Cupertino Native 래퍼를 호출합니다.\n\n<div class=\"content-ad\"></div>\n\n함께 해보겠습니다! 모든 코드는 https://github.com/jacobras/ComposeCupertinoSample 에서 확인할 수 있습니다.\n\n# 튜토리얼: Material을 Cupertino으로 적응하게 만들기\n\n이번에 사용할 샘플 프로젝트는 Kotlin Multiplatform Wizard로 생성되었습니다. 툴바, 두 개의 탭, 로딩 표시기, 그리고 대화상자를 포함한 Material3 구성 요소가 구현되어 있습니다. 시작 지점 코드베이스는 여기에서 확인할 수 있습니다: ComposeCupertinoSample/tree/starting-point.\n\n## 1: 의존성 추가하기\n\n<div class=\"content-ad\"></div>\n\n우리는 버전 카탈로그에 의존성을 추가하고 앱에서 구현했어요:\n\n```js\n// gradle/libs.versions.toml 파일:\ncupertino = { module = \"io.github.alexzhirkevich:cupertino-adaptive\", version = \"0.1.0-alpha03\" }\n\n// composeApp/build.gradle.kts 파일의 common.dependencies 안에:\nimplementation(libs.cupertino)\n```\n\n전체 커밋 내역: ComposeCupertinoSample/pull/2/commits/d7b05ad809bc03cf87c3c58a6f7765f5c6442b92\n\n## 2: 테마 업데이트\n\n<div class=\"content-ad\"></div>\n\nAppTheme은 현재 MaterialTheme을 사용합니다. 이것을 adaptive theme을 사용하도록 변경해야 합니다. material과 cupertino라는 두 가지 중요한 매개변수가 있습니다. material은 현재 MaterialTheme을 취하고, cupertino은 CupertinoTheme을 취합니다. 후자는 darkColorScheme() 또는 lightColorScheme()에 사용자 정의 색상을 전달하여 iOS 외관을 사용자 정의할 수 있습니다.\n\n```js\n// 변경 전\n@Composable\nfun AppTheme(\n    useDarkTheme: Boolean = isSystemInDarkTheme(),\n    content: @Composable () -> Unit\n) {\n    MaterialTheme(\n        colorScheme = if (useDarkTheme) {\n            darkColorScheme()\n        } else {\n          lightColorScheme()\n        },\n        content = content\n    )\n}\n\n// 변경 후\n@OptIn(ExperimentalAdaptiveApi::class)\n@Composable\nfun AppTheme(\n    useDarkTheme: Boolean = isSystemInDarkTheme(),\n    theme: Theme = determineTheme(),\n    content: @Composable () -> Unit\n) {\n    AdaptiveTheme(\n        material = {\n            MaterialTheme(\n                colorScheme = if (useDarkTheme) {\n                    androidx.compose.material3.darkColorScheme()\n                } else {\n                    androidx.compose.material3.lightColorScheme()\n                },\n                content = it\n            )\n        },\n        cupertino = {\n            CupertinoTheme(\n                colorScheme = if (useDarkTheme) {\n                    darkColorScheme()\n                } else {\n                    lightColorScheme()\n                },\n                content = it\n            )\n\n        },\n        target = theme,\n        content = content\n    )\n}\n```\n\ndetermineTheme() 메서드는 [androidMain]에서 Theme.Material을 반환하고 [iosMain]에서 Theme.Cupertino를 반환하는 expect/actual 함수입니다. 자세한 내용은 전체 커밋을 참조하세요: ComposeCupertinoSample/pull/2/commits/592b3e2a1d35ff8a9961dbc6739e0e25bf581b95\n\n지금 앱을 실행하면 아직 아무것도 변경되지 않습니다. 모든 것이 이전과 똑같이 보입니다. 왜냐하면 아직 적응형 컴포넌트를 사용하지 않았기 때문입니다. 이는 안드로이드에서는 모든 것이 변하지 않음을 보여줍니다.\n\n<div class=\"content-ad\"></div>\n\n## 3: 적응형 구성요소 사용하기\n\n이제 재미있는 부분이 시작됩니다! 이것은 또한 가장 쉬운 변경입니다. 모든 자료 구성요소를 찾아서 적응형 래퍼로 대체합니다. 예를 들어요:\n\n```js\n// Before\nButton(onClick = { showContent = !showContent }) {\n    Text(\"Click me!\")\n}\n\n// After\nAdaptiveButton(onClick = { showContent = !showContent }) {\n    Text(\"Click me!\")\n}\n```\n\n다른 구성요소들도 이와 같이 변경할 예정입니다:\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-05-18-GettingthenativeiOSlookfeelinyourComposeMultiplatformapp_1.png)\n\n패턴은 명확해야 합니다: iOS 스타일 컴포넌트에는 Cupertino[ComponentName]을 사용하고, 플랫폼에 따라 변경되는 컴포넌트에는 Adaptive[ComponentName]을 사용해야 합니다. 이 튜토리얼에서는 모두 Adaptive 컴포넌트만 사용할 것입니다.\n\n대부분은 매개변수를 변경하지 않고 이름만 변경하면 됩니다. AlertDialog은 text를 title로, confirmButton을 buttons로 변경해야 하는 예외입니다.\n\n전체 커밋: ComposeCupertinoSample/pull/2/commits/a8da43dd7db1187df15c0fbbca9af3ef705c64bd\n\n\n<div class=\"content-ad\"></div>\n\n앱을 iOS에서 다시 실행하면 변경 사항 이전을 보여주는 좌측 시뮬레이터와 변경 후를 보여주는 우측 시뮬레이터가 표시됩니다:\n\n![이미지1](/assets/img/2024-05-18-GettingthenativeiOSlookfeelinyourComposeMultiplatformapp_2.png)\n\n정말 멋지게 보이네요! 다크 테마도 두 플랫폼에서 작동합니다:\n\n![이미지2](/assets/img/2024-05-18-GettingthenativeiOSlookfeelinyourComposeMultiplatformapp_3.png)\n\n<div class=\"content-ad\"></div>\n\n## 안드로이드에서의 테스트\n\n안드로이드에서 쿠퍼티노 스타일을 테스트하려면 Android 소스 세트의 determineTheme() 메서드만 변경하면 됩니다:\n\n```js\nactual fun determineTheme(): Theme = Theme.Material3\n```\n\n# 추가 단계 및 독서\n\n<div class=\"content-ad\"></div>\n\n요즘 이렇게 쉽고 영향력이 큰 작업이었는지 알겠죠. 더 할 수 있는 일이 있습니다. 아이폰/아이패드에서 iOS 아이콘을 사용하거나 더 많은 네이티브 모양의 구성 요소를 사용하는 것 등이 가능하지만, 결정은 여러분에게 달려 있습니다. 제가 제공한 것은 라이브러리를 시작하는 짧은 소개였죠.\n\n- GitHub: Compose Cupertino\n- GitHub: Compose Cupertino 샘플 앱","ogImage":{"url":"/assets/img/2024-05-18-GettingthenativeiOSlookfeelinyourComposeMultiplatformapp_0.png"},"coverImage":"/assets/img/2024-05-18-GettingthenativeiOSlookfeelinyourComposeMultiplatformapp_0.png","tag":["Tech"],"readingTime":6}],"page":"46","totalPageCount":61,"totalPageGroupCount":4,"lastPageGroup":20,"currentPageGroup":2},"__N_SSG":true}