{"pageProps":{"posts":[{"title":"알고리즘 트레이딩 플랫폼을 Rust로 18개월 재구축 후 후회한 이유","description":"","date":"2024-06-30 19:20","slug":"2024-06-30-Ispent18monthsrebuildingmyalgorithmictradingplatforminRustImfilledwithregret","content":"\n\n## NexusTrade - AI-Powered Algorithmic Trading Platform\n\n저는 어린이자 희망 넘치는 러스트 팬이었습니다. 서류상으로 러스트는 신이 디자인한 프로그래밍 언어와 같았습니다. 러스트는 가장 빠르고 안전한 프로그래밍 언어 중 하나입니다.\n\n러스트가 완벽한 언어라고 생각하는 사람이 많았습니다. 온라인에서 러스트 프로그래밍 언어에 대해 검색하면 압도적으로 긍정적인 의견을 만나게 될 것입니다. 매체의 모든 안내서, 레딧의 모든 게시물, 스택 오버플로우의 모든 답변이 빛나고 있습니다.\n\n![이미지](/assets/img/2024-06-30-Ispent18monthsrebuildingmyalgorithmictradingplatforminRustImfilledwithregret_0.png)\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n주어진 이유로 TypeScript에서 떨어지기로 결정했고, 오픈소스 알고리즘 트레이딩 시스템 전체를 Rust로 다시 작성하기로 했습니다.\n\n# Rust에 중립적인 평가를 내린 적이 있어요. 그걸 철회합니다.\n\n저는 4개월 전 Rust에 대한 제 경험에 대해 썼습니다. 제 마지막 글에서 저는 속도와 열거형 및 강력한 유형화와 같은 언어 설계의 일부 측면을 정말 좋아하는 반면, 그 언어를 정말 좋아하지는 않았다고 결론 내렸습니다. 제 글은 Reddit에서 가혹한 비평을 받았는데, 그 중 하나는 제 글을 작성할 때 ChatGPT를 사용했다고 비난하는 높은 투표를 받은 댓글이 포함되어 있었어요.\n\n![2024-06-30-Ispent18monthsrebuildingmyalgorithmictradingplatforminRustImfilledwithregret_1.png](/assets/img/2024-06-30-Ispent18monthsrebuildingmyalgorithmictradingplatforminRustImfilledwithregret_1.png)\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n포스팅 후에 Rust에 공정한 기회를 주지 않았다고 생각했어요. 아마도 그냥 순진했거나 잘못된 기대로 들어왔던 걸지도 몰라요.\n\n이제 언어를 좀 더 오래 사용해본 뒤, 자신있게 한 가지 결론을 낼 수 있어요…\n\n이 언어는 정말 쓰레기야.\n\n# Rust에서 정말 싫어하는 점\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만약 Rust가 무슨 열망인지에 대한 기사를 찾고 있다면 인터넷 어디든 찾아보세요. 이 언어에 대해 중립적인 정보를 찾기 어려울 겁니다. 이 기사는 이 게으른 언어에 대한 제 혐오에 집중한 랜트일 겁니다.\n\n![이미지](/assets/img/2024-06-30-Ispent18monthsrebuildingmyalgorithmictradingplatforminRustImfilledwithregret_2.png)\n\n## 끔찍하고 장황하며 직관적이지 않은 구문 및 의미론\n\n![이미지](/assets/img/2024-06-30-Ispent18monthsrebuildingmyalgorithmictradingplatforminRustImfilledwithregret_3.png)\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아무도 Rust가 극악한 의미론을 가지고 있다고 말한 적이 있다면 당신 얼굴을 향해 거짓말을 하고 있어요. 어떤 부분들은, 만일 극도로 강력한 큰 언어 모델에 접근할 수 없다면, 함수를 작성하는 것이 문자 그대로 불가능해질 수 있어요. 저는 run_transaction 함수에서 where 절을 찾는 데 90분을 쓰고 싶지 않아요. 단지 제 미친 함수를 작성하고 싶을 뿐이에요.\n\n결국, 제가 도우미 함수 아이디어를 완전히 포기해야 했어요, 왜냐하면 코드를 컴파일할 수 없었거든요. 사람들이 Rust의 가장 큰 강점으로 주장하는 것(오류를 제거하기 위한 엄격한 컴파일러)은 Rust의 가장 큰 결함 중 하나예요. 그냥 가비지 컬렉터를 주시고, 제가 하고 싶은 대로 하게 해주세요!\n\n반면에, 만약 Go로 이 같은 함수를 작성한다면, 다음과 같이 보일 거예요:\n\n![이미지](/assets/img/2024-06-30-Ispent18monthsrebuildingmyalgorithmictradingplatforminRustImfilledwithregret_4.png)\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n함수의 핵심은 상대적으로 동일하지만, 코드가 정상적으로 작동하는 방법을 알아내기 위해 역처 엄청 하실 필요가 없어요. 그냥 작동해요! \n\n## 엄청난 오류 처리\n\nRust는 오류 처리에 대해 정말 멋진 일을 합니다. unsafe 언랩을 피한다면, 코드가 실행되고 계속 실행될 것이라고 확신할 수 있어요. NilPointerExceptions나 처리되지 않은 오류는 더 이상 발생하지 않죠. 좋지 않나요! (그렇죠?)\n\n잘못되었어요. 왜냐하면 데이터가 잘못되거나 예기치 못한 일이 발생할 때, 일이 어째서 그렇게 된 건지 알아내기 위해 고군분투해야 해요. 아마 제가 바보인 건지, 스택 트레이스를 활성화하는 방법을 모르는 건지 모르겠어요. 하지만 어플리케이션에서 오류가 발생하면, 왜 그런 일이 일어났는지 전혀 모르겠어요.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-06-30-Ispent18monthsrebuildingmyalgorithmictradingplatforminRustImfilledwithregret_5.png\" />\n\n그와 대조적으로 Python과 같은 언어는 정확히 무엇이 발생했는지를 당신에게 알려주는 아름다운 예술같은 스택 추적을 제공합니다. Go에서도 errors.Wrap(...)를 사용하여 응용 프로그램 전체의 오류 스택을 볼 수 있습니다. 아마도 나는 제 바보일지도 모릅니다, 왜냐하면 Rust에서 오류를 만나면 어떤 일이 발생했는지 이해하려고 하느라 혼란스러워합니다. 제 응용 프로그램 전체에 eprintln!(...)이 흩어져 있어야 합니다.\n\n사실, 아니죠. 저는 바보가 아닙니다. 이것은 결함이 있는 언어 디자인입니다.\n\n## 화가 나는 커뮤니티\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n핫한 주장: 러스트 커뮤니티는 가식적으로 친절하고 멋진 모습을 내세운 것만큼 실제로 그렇지 않을 수도 있어요. 그들은 자기들이 좋아하는 언어에 결함이 있다고 말해주는 걸 싫어하는 허세 부리는 사람들이라고 할 수 있어요.\n\n![이미지](/assets/img/2024-06-30-Ispent18monthsrebuildingmyalgorithmictradingplatforminRustImfilledwithregret_6.png)\n\n예를 들어, 저는 Rust 서브레딧에서 MongoDB Rust 크레이트로 에러 핸들링을 개선하는 방법에 대해 질문했더니 다음과 같은 답변을 받았어요:\n\n- 포스트그레스로 바꾸세요 (그래, 몇 개의 구리 에러 메시지 땜에 전체 데이터베이스 설계를 다시 하겠지)\n- 왜 MongoDB를 쓰는 거야? (나는 그것이 좋아. 다음 질문은?)\n- MongoDB는 고(Go)와 파이썬(Python)에서도 나쁘죠 (어쩌면 그렇겠지만, TypeScript에서는 괜찮아요. 그리고 네 뭐라고 하는 건 내 질문에 대한 대답이 되지 않아요)\n- (거의 없는) 실제로 도움이 되는 에러 메시지 개선 제안\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nRust와 같이 사이코패스 같은 프로그래밍 커뮤니티는 없다고 생각해. 이 언어의 엄청난 학습 곡선, 장황함, 형편없는 오류 메시지, 엉뚱한 구문, 의심스러운 언어 디자인 선택과 같은 큰 결함들을 모두 무시하고 있어. 그들은 개발자의 능력 문제일거라고 주장하는데, 나는 그것이 미친 짓이라고 생각해!\n\n# 마지막으로\n\n모든 이야기를 한 마디로 정리하면, Rust에는 몇 가지 장점이 있다. 빠르다는 점... 음, 그게 대부분이야.\n\n아마 안전한 측면이 있다고 해야겠군. C++과 비교해 보면 명백히 더 나은 언어지만, 다른 언어(예: Go)와 비교할 때는 \"안전성\"이 오히려 단점이라고 생각해. 내 어플리케이션이 실행하는데 몇십 밀리초 더 걸리더라도, 개발 시간이 절반으로 줄어든다면 더 나은 것 같아.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n밝은 면에서 말하자면, Go로 앱을 개발한다고 선택한 나는 아마 후회를 할 것이다. \"만약 더 빠를 수 있다면?\" 라고 생각할 것이고, \"Rust가 빵을 썰어 먹기 좋은 제품이라는 또 다른 기사가 있네. 어떻게 이런 실수를 했지!\" 라고 스스로 생각할 것이다.\n\n적어도 이제 Rust를 알게 되어 어떤 것이든 배울 수 있다고 느낀다. 혹은 그냥 재미로 OCaml을 배울 수도 있지 않을까? Rust보다 그렇게 나쁠리가 없을 텐데?\n\n읽어 주셔서 감사합니다! 알고리즘을 트레이딩하고 인공지능에 관심이 있다면 오로라의 인사이트로 구독하세요! Rust가 얼마나 빠른지 확인하려면 오늘 NexusTrade에 계정을 만들어보세요!","ogImage":{"url":"/assets/img/2024-06-30-Ispent18monthsrebuildingmyalgorithmictradingplatforminRustImfilledwithregret_0.png"},"coverImage":"/assets/img/2024-06-30-Ispent18monthsrebuildingmyalgorithmictradingplatforminRustImfilledwithregret_0.png","tag":["Tech"],"readingTime":7},{"title":"Hilt로 알아보는 Dependency Injection 방법","description":"","date":"2024-06-30 19:19","slug":"2024-06-30-DependencyInjectionwithHilt","content":"\n\n<img src=\"/assets/img/2024-06-30-DependencyInjectionwithHilt_0.png\" />\n\n# 코틀린을 활용한 모던 안드로이드 개발 시리즈 #4\n\n의존성 주입(DI)은 현대 안드로이드 애플리케이션 개발에서 중요한 기술입니다. Hilt는 안드로이드 애플리케이션에서 DI를 간단하게 만들어 주는 라이브러리로, Dagger를 기반으로 하고 있습니다. 이 안내서에서는 Hilt의 기본 개념과 Hilt를 사용한 DI의 구현 방법을 다룰 것입니다.\n\n# 의존성 주입이란?\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n의존성 주입은 클래스가 생성자를 직접 만드는 대신 외부 소스에서 의존성을 받을 수 있도록 하는 디자인 패턴입니다. 이는 코드를 더 유연하고 테스트 가능하며 관리하기 쉽게 만듭니다.\n\n# Hilt란 무엇이며 왜 사용해야 하나요?\n\nHilt는 안드로이드를 위한 Dagger 기반 의존성 주입 라이브러리로, DI를 간단하게 만들고 다음과 같은 이점을 제공합니다:\n\n- 보일러플레이트 코드를 줄입니다.\n- Android 컴포넌트에 대한 내장 지원을 제공합니다.\n- 테스트 작성을 쉽게 만듭니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 프로젝트에 Hilt 추가하기\n\n프로젝트에 Hilt를 추가하려면 build.gradle 파일에 필요한 종속성을 추가해야 합니다.\n\n## 프로젝트 수준 build.gradle\n\n```js\nbuildscript {\n    ext.hilt_version = '2.38.1'\n    dependencies {\n        classpath \"com.google.dagger:hilt-android-gradle-plugin:$hilt_version\"\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## Module-level build.gradle\n\n```js\nplugins {\n    id 'com.android.application'\n    id 'kotlin-android'\n    id 'kotlin-kapt'\n    id 'dagger.hilt.android.plugin'\n}\n\ndependencies {\n    implementation \"com.google.dagger:hilt-android:$hilt_version\"\n    kapt \"com.google.dagger:hilt-android-compiler:$hilt_version\"\n}\n```\n\n# Basic Hilt Annotations\n\n## @HiltAndroidApp\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n@HiltAndroidApp 주석을 사용하여 Hilt의 DI 컨테이너를 초기화하는 애플리케이션 클래스에 주석을 달아주세요.\n\n```kotlin\n@HiltAndroidApp\nclass MyApp : Application() {\n}\n```\n\n## @Inject\n\n@Inject 주석은 Hilt에 클래스 또는 필드의 인스턴스를 제공하는 방법을 알려줍니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\nclass UserRepository @Inject constructor(\n    private val apiService: ApiService\n) {\n    // UserRepository content\n}\n```\n\n## @Module and @InstallIn\n\n@Module 어노테이션은 Hilt에게 특정 타입의 인스턴스를 생성하는 방법을 알려줍니다. @InstallIn 어노테이션은 모듈이 설치되어야 하는 Hilt 컨테이너를 지정합니다.\n\n```kotlin\n@Module\n@InstallIn(SingletonComponent::class)\nobject AppModule {\n\n    @Provides\n    @Singleton\n    fun provideApiService(): ApiService {\n        return Retrofit.Builder()\n            .baseUrl(\"https://api.example.com\")\n            .build()\n            .create(ApiService::class.java)\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## @Singleton\n\n@Singleton 어노테이션은 Hilt에게 애플리케이션 전체를 통틀어 의존성의 단일 인스턴스를 제공하도록 지시합니다.\n\n# ViewModel에서 Hilt 사용하기\n\nViewModel에서 Hilt를 사용하려면 @HiltViewModel과 @Inject 어노테이션을 사용하면 됩니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\n@HiltViewModel\nclass MyViewModel @Inject constructor(\n    private val userRepository: UserRepository\n) : ViewModel() {\n    // ViewModel content\n}\n```\n\nActivity나 Fragment에서 Hilt를 사용하여 ViewModel을 가져오세요.\n\n```kotlin\n@AndroidEntryPoint\nclass MainActivity : AppCompatActivity() {\n\n    private val viewModel: MyViewModel by viewModels()\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n\n        // Use ViewModel\n    }\n}\n```\n\n# Hilt를 사용하여 다른 컴포넌트에서 DI하기\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n힐트는 액티비티, 프래그먼트, 뷰, 서비스 및 브로드캐스트 수신자와 같은 다양한 Android 구성 요소에서 DI를 제공합니다. @AndroidEntryPoint 주석을 사용하여 힐트 DI를 이러한 구성 요소에서 활성화할 수 있습니다.\n\n```js\n@AndroidEntryPoint\nclass MyFragment : Fragment() {\n\n    private val viewModel: MyViewModel by viewModels()\n\n    // 프래그먼트 내용\n}\n```\n\n# Hilt와 테스트\n\n힐트는 또한 테스트 작성을 간소화합니다. 테스트에서 @HiltAndroidTest 및 @UninstallModules 주석을 사용하세요.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\n@HiltAndroidTest\n@RunWith(AndroidJUnit4::class)\nclass MyTest {\n\n    @get:Rule\n    var hiltRule = HiltAndroidRule(this)\n\n    @Inject\n    lateinit var userRepository: UserRepository\n\n    @Before\n    fun init() {\n        hiltRule.inject()\n    }\n\n    @Test\n    fun testUserRepository() {\n        // Test content\n    }\n}\n```\n\n# 결론\n\nHilt는 안드로이드 애플리케이션에서 의존성 주입을 간단하게 만들어주는 강력한 도구입니다. 이 안내서에서 Hilt의 기본 개념과 사용 방법을 배웠습니다. Hilt를 사용하면 코드를 더 깔끔하게 만들고 유연하게 유지하며 쉽게 테스트할 수 있습니다.\n\n본 안내서를 따라가면 Hilt를 활용한 의존성 주입을 마스터하는 중요한 한 걸음을 내디딘 것입니다. 즐거운 코딩되세요!\n","ogImage":{"url":"/assets/img/2024-06-30-DependencyInjectionwithHilt_0.png"},"coverImage":"/assets/img/2024-06-30-DependencyInjectionwithHilt_0.png","tag":["Tech"],"readingTime":7},{"title":"기존 Rails 애플리케이션을 Dockerize 하는 방법","description":"","date":"2024-06-30 19:17","slug":"2024-06-30-Dockerizeyourexistingrailsapplication","content":"\n요즘에는 Docker가 응용 프로그램의 플랫폼 의존성 문제를 해결해 주었습니다. Docker는 응용 프로그램을 컨테이너화하여 다양한 플랫폼에서 실행할 수 있도록 도와줍니다.\n\n![이미지](/assets/img/2024-06-30-Dockerizeyourexistingrailsapplication_0.png)\n\n다양한 환경에서 레일즈 응용 프로그램을 실행할 때는 다른 환경 변수와 설정 파일이 필요할 수 있습니다. 이를 위해 다음과 같은 다양한 솔루션을 사용할 수 있습니다:\n\n- 환경별 암호화되지 않은 설정 파일: 우리는 테스트, 스테이징 또는 프로덕션과 같은 다른 환경에서 다른 값들을 제공하기 위해 각각 다른 환경별 파일을 사용할 수 있습니다.\n  참조: https://github.com/rubyconfig/config\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n2. 환경별 암호화된 자격 증명 파일: Rails 5.2에서는 저장소 자체의 암호화된 형식으로 이러한 설정을 유지하는 데 도움이되는 암호화된 자격 증명의 개념이 추가되었습니다. 이러한 자격 증명은 마스터 키를 사용하여 서버에서 해독 할 수 있습니다.\n\n3. 심볼릭 링크: 가장 일반적인 접근 방식은 코드 기반이 아닌 서버 또는 로컬 머신에서 별도의 구성 파일을 직접 사용할 수 있도록하는 심볼릭 링크를 사용하는 것입니다.\n\n어플리케이션을 도커화 하는 것에는 많은 장점이 있습니다. 장점에 대해서 이야기하는 대신에 이제 도커화 과정으로 진행해 봅시다.\n\n새로운 도커화된 레일즈 어플리케이션을 만드는 것은 다양한 환경과 설정 및 변수와 함께 실행중인 기존 어플리케이션을 이주시키는 것보다 훨씬 쉽습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 블로그에서는 기존 레일즈 애플리케이션의 구성 파일을 도커화하는 방법에 중점을 둘 것입니다. 도커화의 어려운 부분은 기존 애플리케이션의 구성 파일을 관리하는 것입니다.\n\n아래는 애플리케이션을 도커화하는 일반적인 단계입니다:\n\n1. Docker 파일 추가하기:\n\n경로: rails_app/Dockerfile\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nFROM ruby:3.2.0\nRUN apt-get update -qq && apt-get install -y cron && apt-get clean autoclean && apt-get autoremove\nARG rails_env=development\nARG bundle_ruby_gem_cred\n# Send log to docker logs\nENV RAILS_LOG_TO_STDOUT=\"1\"\n# Set Root directory\nENV RAILS_ROOT /opt/apps/rails_app\nENV RAILS_ENV=$rails_env\nRUN mkdir -p $RAILS_ROOT\nWORKDIR $RAILS_ROOT\nCOPY Gemfile $RAILS_ROOT/Gemfile\nCOPY Gemfile.lock $RAILS_ROOT/Gemfile.lock\nRUN bundle install\nADD . $RAILS_ROOT\nEXPOSE 3000\n# Set the entrypoint\nCOPY web-entrypoint.sh /usr/bin/\nRUN chmod +x /usr/bin/web-entrypoint.sh\nENTRYPOINT [\"web-entrypoint.sh\"]\n```\n\n위 파일은 레일즈 애플리케이션을 위한 기본 도커 파일입니다. 필요한 종속성을 설치하고 환경 변수를 설정할 것입니다.\nweb-entrypoint.sh 엔트리포인트 스크립트는 컨테이너가 시작될 때 실행되며 일반적으로 레일즈 서버를 시작하거나 기타 초기화 작업을 수행합니다.\n\n경로: rails_app/web-entrypoint.sh\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n#!/bin/bash\n# 데이터베이스 마이그레이션\nbundle exec rake db:migrate\n# 웹 서버 실행\nrm -f tmp/pids/server.pid\nbundle exec rails server -b 0.0.0.0 -p 3000\n```\n\n참고: 필요한 경우 cron, sidekiq 및 기타 서비스를 여기에서 처리할 수 있습니다.\n\n애플리케이션이 도커화되었지만, 다음 도전 과제는 database.yml, redis.yml 등의 설정 파일을 처리하는 것입니다.\n\n다음과 같은 방법으로 구성 파일을 처리할 수 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 1. 환경별 자격 증명 파일 사용하기:\n\n이것은 가장 권장되고 안전한 방법입니다. 도커 이미지는 불변하기 때문에 이미지 내의 모든 내용을 유지해야 합니다.\n\n환경별 자격 증명 파일에 모든 설정 변수와 자격 증명을 커밋할 수 있으며 이미지 빌드 중에 해당 마스터 키를 제공할 수 있습니다.\n\n다음은 구성 파일 조각 중 하나입니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n경로: rails_app/config/database.yml\n\n```yaml\ndefault: &default\n  adapter: postgresql\n  encoding: unicode\n  pool: 100\n  port: 5432\n  host: <%= Rails.application.credentials.database.host %>\n  database: <%= Rails.application.credentials.database.name %>\n  username: <%= Rails.application.credentials.database.username %>\n  password: <%= Rails.application.credentials.database.password %>\n\ndevelopment:\n  <<: *default\n\ntest:\n  <<: *default\n\nstaging:\n  <<: *default\n\nproduction:\n  <<: *defaultadapter: postgresql\n```\n\n모든 환경에 대해 위와 같은 테이블을 Markdown 형식으로 바꿀 수 있어요.\n\n위 환경에 대한 서로 다른 자격 증명 파일을 생성하는 방법은 아래 명령어를 사용하세요:\n\nEDITOR=vim rails credentials:edit -e development|test|production|staging\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 명령어는 다음 디렉터리에 파일을 생성합니다:\n\n경로: rails_app/config/credentials\n\n```js\ntest.yml.enc;\ntest.key;\n\ndevelopment.yml.enc;\ndevelopment.key;\n\nprodution.yml.enc;\nprodution.key;\n\nstaging.yml.enc;\nstaging.key;\n```\n\n우리는 yml.enc 파일을 레포지토리에 커밋할 수 있고, 빌드 프로세스 중에 key는 github 자격증명을 사용하여 제공할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\necho -n ${ secrets.RAILS_APP_PRODUCTION_KEY } > ‘config/credentials/production.key’\n```\n\nRAILS_APP_PRODUCTION_KEY은 github 시크릿에서 유지되는 키의 실제 값을 포함합니다.\n\n## 장점:\n\na. 어떠한 원격 서버에도 어플리케이션을 머신 의존성 없이 배포할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nb. 키를 제외한 모든 것이 저장소 자체에 있습니다.\n\n## 단점:\n\na. 여러 설정 파일이 있는 경우 설정 변수를 자격 증명 파일 참조로 대체하려면 redis.yml에 언급된 대로 변경을 애플리케이션 전체에 적용해야 합니다.\n\n## 2. 심볼릭 링크를 사용:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/assets/img/2024-06-30-Dockerizeyourexistingrailsapplication_1.png)\n\n도커 컨테이너의 설정 파일에 대한 심볼릭 링크를 호스트 머신에 생성하여, 호스트 머신에서 설정 파일을 변경하면 도커 컨테이너에 반영될 수 있습니다.\n\ndatabase.yml 파일을 예시로 들어보겠습니다:\n\n2.1. 호스트 머신의 특정 디렉토리에 database.yml 파일의 실제 내용을 넣어주세요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n경로: /opt/rails_app_configs/database.yml\n\n```js\nqa: adapter: postgresql;\nencoding: unicode;\npool: 100;\nport: 5432;\nhost: abc;\ndatabase: abc;\nusername: abc;\npassword: abc;\n```\n\n2.2. 이제 database.yml 파일을 아래 컨테이너 경로에 심볼릭 링크로 커밋하세요:\n\n파일: database.yml\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n/opt/configs/database.yml\n```\n\n2.3. 배포 시 호스트 머신에서 실제 파일을 database.yml에 지정된 컨테이너의 특정 경로로 복사하세요.\n\n```js\ndocker container run -d — rm — name hello-rails-app -e RAILS_ENV=qa -v /opt/rails_app_configs:/opt/configs -p 3000:3000 rails_app:latest\n```\n\n이렇게 하면 호스트 머신에서 파일이 컨테이너로 복사되어 응용 프로그램이 구성 파일에 액세스할 수 있게 됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 장점:\n\na. 호스트 머신의 구성 파일을 변경하면 컨테이너에 반영됩니다.\n\nb. 구성 파일이 변경되어도 새 이미지를 빌드할 필요가 없습니다.\n\nc. 설정 변수를 자격 증명 파일 참조로 대체하려면 애플리케이션 코드를 변경할 필요가 없습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## Cons:\n\na. 호스트 머신에서 설정 파일을 유지하고 있어야 합니다.\n\nb. 설정 파일은 호스트 머신에서 읽을 수 있습니다.\n\nc. 새로운 머신에서 컨테이너를 실행할 때마다 파일을 호스트 머신에 복사해야 합니다. 각 머신마다 파일을 복사하는 추가 노력을 피하기 위해 nfs 서버를 사용하여 호스트 머신에 설정 파일을 마운트하고 모든 머신에서 사용할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위 내용이 기존 레일즈 애플리케이션을 도커화하는 데 도움이 되길 바랍니다. 궁금한 사항이나 제안 사항이 있으시면 아래에 자유롭게 댓글을 남겨주세요.\n\n저는 동일한 주제로 GitHub 액션 및 배포용 워크플로우를 이어서 진행할 예정입니다.\n\n읽어주셔서 감사합니다.\n","ogImage":{"url":"/assets/img/2024-06-30-Dockerizeyourexistingrailsapplication_0.png"},"coverImage":"/assets/img/2024-06-30-Dockerizeyourexistingrailsapplication_0.png","tag":["Tech"],"readingTime":9},{"title":"동적 기능 모듈 이해하기 AAB Android App Bundle 효과적으로 사용하기","description":"","date":"2024-06-30 19:16","slug":"2024-06-30-UnderstandingDynamicFeatureModulesAAB","content":"\n\n플레이 피처 딜리버리는 앱 번들의 고급 기능을 활용하여 앱의 특정 기능을 조건적으로 제공하거나 필요 시 다운로드할 수 있게 합니다. 먼저 기본 앱에서 이러한 기능을 분리하여 피처 모듈로 만들어야 합니다.\n\nGoogle Play의 앱 제공 모델은 Android 앱 번들을 활용하여 각 사용자의 기기 구성에 맞게 최적화된 APK를 생성하고 제공하므로 사용자는 앱을 실행하는 데 필요한 코드 및 리소스만 다운로드합니다.\n\n## Android 앱 번들 분석\n\n\"Android 앱 번들은 모든 앱의 컴파일된 코드와 리소스를 포함하며 APK 생성과 서명을 Google Play에게 위임하는 게시 형식입니다.\"\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n어플 번들과 APK는 다르다는 것을 아시나요? 어플 번들은 기기에 직접 배포할 수 없는 반면, 모든 앱의 컴파일된 코드와 리소스를 포함한 출판 포맷입니다. 따라서, 서명된 앱 번들을 업로드하면 Google Play가 APK를 빌드하고 서명하여 사용자에 제공하는 데 필요한 모든 것을 보유하게 됩니다.\n\n![image](/assets/img/2024-06-30-UnderstandingDynamicFeatureModulesAAB_0.png)\n\n여러 모듈을 포함하는 Android App Bundle을 분석해보겠습니다. 구체적으로 dynamicFeature, native, java, kotlin, assets 모듈들이 있는데, 이들은 이 프로젝트를 위해 만든 동적 기능 모듈입니다.\n\n위 내용은 Android 스튜디오의 앱 번들 분석 기능에서 나온 어플 번들의 내용을 나타낸 것입니다. 일반적으로, 어플 번들의 모듈은 다음과 같은 것으로 구성됩니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- Dex 파일 - DEX 파일의 주요 목적은 컴파일된 코드를 Dalvik Virtual Machine (DVM) 또는 Android Runtime (ART)이 실행할 수 있는 형식으로 패키징하는 것입니다.\n- Manifest — AndroidManifest.xml 파일은 모든 Android 애플리케이션에 필요한 XML 파일로, 앱에 관한 중요한 정보를 설명합니다. 각 동적 기능 모듈은 고유의 AndroidManifest.xml 파일을 갖습니다. 일반적으로 해당 모듈에 특정한 구성 요소가 포함되어 있고 권한 및 기능을 지정할 수 있습니다.\n- Resources — 앱이 사용하는 다양한 리소스를 구성하고 관리하는 데 중요합니다. 이러한 리소스에는 레이아웃, 이미지, 문자열, 애니메이션, 스타일 등이 포함됩니다.\n- root — 이 디렉토리에는 나중에 해당 디렉토리가 위치한 모듈을 포함하는 APK의 루트로 재배치되는 파일이 저장됩니다. 예를 들어, 앱 번들의 base/root/ 디렉토리에는 앱이 Class.getResource()를 사용하여 로드하는 자바 기반 리소스가 포함될 수 있습니다.\n\n우리가 볼 수 있듯이, 기본 모듈을 위한 별도의 모듈이 생성됩니다. — 안드로이드 앱 번들 내의 기본 모듈은 앱의 핵심 기능을 포함합니다.\n\n![이미지](/assets/img/2024-06-30-UnderstandingDynamicFeatureModulesAAB_1.png)\n\nGoogle Play에서 안드로이드 앱 번들을 처리할 때, 특정 장치 구성에 맞게 여러 개의 APK로 분할됩니다. 기본 분할 APK은 기본 모듈에서 생성되며 앱 시작에 필요한 핵심 기능과 리소스를 포함합니다. 이 APK는 필수적이며 모든 장치에 설치되어 앱이 모든 지원되는 장치에서 실행될 수 있도록 합니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n기본 분할 APK에 추가로 Android 앱 번들은 구성 APK라고 하는 여러 다른 APK를 생성합니다. 이러한 APK는 다양한 장치 구성에 최적화되어 있으며 다음을 포함할 수 있습니다:\n\n- 밀도 APK: 다양한 화면 밀도에 대한 것 (예: mdpi, hdpi, xhdpi).\n- 언어 APK: 다른 언어 및 로캘을 위한 것.\n- ABI APK: 다양한 CPU 아키텍처에 대한 것 (예: armeabi-v7a, arm64-v8a).\n- 동적 기능 APK: 필요시 다운로드할 수 있는 선택적 기능에 대한 것.\n\n앱 번들의 각 동적 기능 모듈에 대해 하나의 분할 APK가 생성될 것입니다. 이러한 각 분할 APK는 사용자가 요청하거나 장치에서 필요할 때 다운로드되어 설치됩니다.\n\n이외에도 앱 번들의 다른 구성 요소들이 있습니다 -\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- BUNDLE-METADATA: 이 디렉토리에는 도구나 앱 스토어에서 유용한 정보를 포함하는 메타데이터 파일이 포함됩니다. 이러한 메타데이터 파일에는 ProGuard 매핑 및 앱의 DEX 파일 완전한 목록 등이 포함될 수 있습니다. 이 디렉토리의 파일은 앱의 APK에 포장되지 않습니다.\n- 모듈 프로토콜 버퍼 (*.pb) 파일: 이러한 파일은 Google Play와 같은 앱 스토어에 각 앱 모듈의 내용을 설명하는 데 도움이 되는 메타데이터를 제공합니다.\n\n## 앱 번들이 생성되는 방식\n\nAGP 코드를 더 깊이 파고들어 Android 앱 번들이 생성되는 방식을 이해해 보겠습니다.\n\nPackageBundleTask.kt는 Android 앱 번들 (.aab 파일)을 빌드하기 위한 Gradle 태스크입니다. 이 태스크는 애플리케이션의 다양한 모듈과 구성 요소를 최종 .aab 파일로 패키징합니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n작업은 필요한 모든 입력을 수집합니다. 이는 기능 모듈 zip 파일, 자산 팩 zip 파일, 메인 dex 목록, 난독화 매핑 파일, 무결성 구성 파일 및 네이티브 디버그 메타데이터 파일 등을 포함합니다. 이러한 입력은 Gradle에 의해 처리되어야 하는 방식을 나타내기 위해 속성 및 어노테이션을 사용하여 지정됩니다 (예: 선택적인지, 경로 변경에 민감한지 등).\n\n작업은 ABI 분할, 밀도 분할, 언어 분할, 텍스처 분할 및 기기 티어 분할과 같은 번들 옵션을 구성합니다. 이러한 구성을 캡슐화하기 위해 BundleOptions를 사용하고 이를 BundleTool 명령에 적용합니다.\n\nABI, 밀도 및 언어에 의한 분할과 같은 구성 옵션은 동적 기능 모듈에도 적용되며, 기기 기능과 사용자 요구에 기반한 맞춤형 APK 생성이 가능하게 합니다.\n\n작업은 메타데이터 파일 및 최적화 설정을 설정합니다. 이에는 압축 설정, 무결성 구성, 네이티브 라이브러리 압축 및 기타 번들별 설정이 포함됩니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n`BundleToolWorkAction` 클래스는 Google이 제공하는 도구인 BundleTool을 사용하여 BuildBundleCommand를 구성하고 실행합니다. 이 도구는 AAB 파일을 빌드하는데 사용됩니다. 명령은 수집된 모든 입력, 구성 및 메타데이터로 구성되어 최종 .aab 파일을 생성하도록 설정됩니다.\n\n## 분할 APK가 생성되는 방법\n\n`BuildApksManager` 클래스는 Android Bundle Tool의 일부로서 Android App Bundle (AAB)에서 APK를 생성하는 프로세스를 관리합니다.\n\n`BuildApksManager`의 `execute()` 메서드는 명령 옵션과 번들 구성을 기반으로 생성할 APK의 유형을 결정하며, 특히 분할 APK의 경우 어떤 모듈이 분할되어야 하는지 및 그들의 구성 (예: dimensions)을 식별합니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n`BundleModuleMerger` 클래스의 `mergeNonRemovableInstallTimeModules` 메서드는 특정 조건에 따라 기본 모듈에 병합할 모듈을 식별합니다. 예를 들어, 제거 가능으로 표시된 모듈들을 병합하지 않습니다 (`dist:removable dist:value=\"true\" /`). 이 메서드는 식별된 모듈에서 자산 (Assets), 네이티브 라이브러리 (NativeLibraries), 및 리소스 테이블 (ResourceTable)과 같은 설정을 기본 모듈로 병합하고, 병합된 모듈을 제외한 업데이트된 AppBundle을 구성합니다.\n\n이 병합된 앱 번들은 그런 다음 `SplitApkGenerator` 클래스의 `generateSplits` 메서드를 사용하여 Split APK를 생성하는 데 사용됩니다. `SplitApksGenerator` 클래스는 Android App Bundle (AAB)에서 Split APK를 생성하는 것을 담당합니다.\n\n`generateSplits` 메서드는 제공된 모듈과 구성에 기반한 APK 분할을 생성합니다. 이는 variant targetings를 생성하기 위해 `variantTargetingGenerator`로 위임하고, 각 variant에 대해 분할을 생성하기 위해 `generateSplitApks`를 사용하여 해당 variant targeting에 대해 Split APK를 생성합니다. 이때 `modulesForVariant`를 통해 각 모듈을 주어진 구성 및 variant targetings에 따라 APK로 분할하기 위해 `ModuleSplitter`를 사용합니다.\n`SplitApkGenerator`에서 주목해야 할 중요한 점은, 이 클래스가 동적 기능 모듈을 관리하기 위한 특정 구성 (featureModulesCustomConfig)을 허용한다는 것입니다. 이를 통해 동적 기능 모듈의 최적화 및 분할 APK에 포함 여부를 제어할 수 있습니다.\n\n`featureModulesCustomConfig`는 `SplitApksGenerator`에 주입되는 선택적 구성 매개변수입니다. 개발자들은 동적 기능 모듈에 대해 맞춤 규칙 및 구성을 지정할 수 있습니다. 예를 들어, 특정 모듈을 다르게 압축해야 하는지 또는 특정 최적화에서 제외해야 하는지를 지정할 수 있습니다. 동적 기능 모듈은 `featureModulesCustomConfig`에 구성된 내용에 따라 분할 APK에서 선택적으로 포함하거나 제외될 수 있습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nGeneratedApks.fromModuleSplits() 메서드는 각 변형을 개별적으로 처리하여 split.xml 및 로캘 구성과 같은 필요한 구성을 ModuleSplits에 주입합니다.\n\n모든 APK가 생성된 후, ApkSerializerManager를 사용하여 APK 세트를 지정된 출력 형식으로 직렬화하며, apkSerializerManager.serializeApkSet() 메서드는 tempDir.getPath()에서 생성된 ApkSetWriter를 사용하여 APK를 최종 APK 세트로 직렬화합니다. 이 방법은 동적 기능 및 장치별 구성을 처리하면서 테스트 및 퓨즈된 모듈 필요에 기반한 사용자 정의를 허용하여 APK를 효율적으로 패키징하여 배포합니다.","ogImage":{"url":"/assets/img/2024-06-30-UnderstandingDynamicFeatureModulesAAB_0.png"},"coverImage":"/assets/img/2024-06-30-UnderstandingDynamicFeatureModulesAAB_0.png","tag":["Tech"],"readingTime":8},{"title":"Combine의 퍼블리셔와 구독자 프로토콜 이해하기 Swift 개발자를 위한 가이드","description":"","date":"2024-06-27 19:36","slug":"2024-06-27-UnderstandingPublisherandSubscriberProtocolsinCombineSwift","content":"\n\n<img src=\"/assets/img/2024-06-27-UnderstandingPublisherandSubscriberProtocolsinCombineSwift_0.png\" />\n\n# 소개\n\nSwift 프로그래밍 세계에서 비동기 데이터 스트림을 관리하는 것은 복잡한 작업일 수 있습니다. Apple의 Combine 프레임워크는 반응형 프로그래밍을 통해이 프로세스를 간소화합니다. 이 글은 실제 세계의 비유와 간단한 예제를 사용하여 Combine에서의 Publisher 및 Subscriber 프로토콜을 해석하여 이러한 개념을 모든 사람이 이해할 수 있도록 만들 것입니다.\n\n# Combine이란 무엇인가요?\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# Publisher Protocol\n\nCombine에서의 Publisher는 시간에 따른 값의 시퀀스를 생성하는 데 책임이 있습니다. 세 가지 유형의 이벤트를 발생시킬 수 있습니다:\n\n- 값: 방송되는 데이터.\n- 완료: 방송이 끝났음을 나타내는 신호.\n- 실패: 오류가 발생했음을 나타내는 신호.\n\n실제 예시: 매월 구독하는 잡지(발행인)에 가입한다고 상상해보세요. 매월 새 호가 도착합니다(값). 결국 구독이 종료될 수 있습니다(완료) 또는 잡지가 폐업할 수도 있습니다(실패).\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nimport Combine\n\nlet magazinePublisher = Just(\"Monthly Swift Programming Magazine\")\nmagazinePublisher.sink { completion in\n    switch completion {\n    case .finished:\n        print(\"구독이 완료되었습니다\")\n    case .failure(let error):\n        print(\"에러로 인해 구독이 실패했습니다: \\(error)\")\n    }\n} receiveValue: { value in\n    print(\"받은 이슈: \\(value)\")\n}\n```\n\n이 예제에서 Just는 하나의 값만을 보내고 완료합니다.\n\n# Subscriber Protocol\n\nSubscriber는 publisher가 방출하는 값을 청취하고 반응하는 프로토콜입니다. Subscriber는 publisher에 구독하고 받은 값, 완료, 실패를 처리합니다.\n\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n실제 예시:\n\n구독자로서, 잡지(값)를 받아서 읽고, 그 다음 호를 기다리게 됩니다. 구독이 종료되면(완료), 새로운 호를 기대하지 않게 됩니다. 잡지가 사업을 종료하면(실패), 알려드립니다.\n\n코드 예시:\n\n```js\nimport Combine\n\nclass MagazineSubscriber: Subscriber {\n    typealias Input = String\n    typealias Failure = Never\n\n    func receive(subscription: Subscription) {\n        subscription.request(.unlimited) // 모든 호 요청\n    }\n\n    func receive(_ input: String) -> Subscribers.Demand {\n        print(\"호 수신 중: \\(input)\")\n        return .none // 추가적인 요구사항 없음\n    }\n\n    func receive(completion: Subscribers.Completion<Never>) {\n        print(\"구독 상태: \\(completion)\")\n    }\n}\n\nlet subscriber = MagazineSubscriber()\nmagazinePublisher.subscribe(subscriber)\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 발행자 및 구독자 통합\n\n발행자를 결합하면 보다 복잡한 데이터 스트림을 처리할 수 있습니다. 예를 들어 여러 잡지에서 알림을 받아 하나의 스트림으로 병합하는 경우가 있습니다.\n\n실제 예시:\n\n당신은 “Tech Monthly”와 “Science Weekly” 두 잡지를 구독했습니다. 어느 한 쪽에서 새 호가 나올 때마다 알림을 받고자 합니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 Markdown 형식을 이용한 코드 예시입니다.\n\n```js\nimport Combine\n\nlet techPublisher = Just(\"Tech Monthly - Issue 1\")\nlet sciencePublisher = Just(\"Science Weekly - Issue 1\")\n\nlet combinedPublisher = Publishers.Merge(techPublisher, sciencePublisher)\ncombinedPublisher.sink { value in\n    print(\"Received combined issue: \\(value)\")\n}\n```\n\n여기서 Merge는 두 개의 publisher를 결합하여 하나의 publisher로 만들어주어 두 잡지로부터 통지를 받을 수 있습니다.\n\n# 현대 애플리케이션에서의 실시간 활용\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 네트워크 요청 및 UI 업데이트\n\nCombine은 특히 네트워크 요청에서 비동기 데이터를 처리하고 UI 요소를 반응적으로 업데이트해야 하는 시나리오에서 유용합니다. 예를 들어, 서버에서 사용자 데이터를 가져와 데이터가 도착할 때 UI를 업데이트해야 하는 앱을 상상해보세요:\n\n```swift\nimport Combine\n\n// 시뮬레이션된 네트워크 요청 퍼블리셔\nlet userDataPublisher = URLSession.shared.dataTaskPublisher(for: URL(string: \"https://api.example.com/user\")!)\n    .map { $0.data }\n    .decode(type: User.self, decoder: JSONDecoder())\n\n// 사용자 데이터로 UI를 업데이트하는 서브스크라이버\nclass UserProfileViewController: UIViewController {\n    private var cancellable: AnyCancellable?\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n\n        cancellable = userDataPublisher\n            .receive(on: DispatchQueue.main)\n            .sink(receiveCompletion: { completion in\n                // 완료 처리 (성공 또는 실패)\n                print(\"사용자 데이터 요청 완료: \\(completion)\")\n            }, receiveValue: { user in\n                // 받은 사용자 데이터로 UI 업데이트\n                nameLabel.text = user.name\n                emailLabel.text = user.email\n            })\n    }\n}\n```\n\n이 예시에서:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- URLSession.shared.dataTaskPublisher는 사용자 데이터를 비동기적으로 가져옵니다.\n- sink은 userDataPublisher를 구독하여 사용자 데이터를 받아 UI를 업데이트합니다.\n\n# Combine을 사용하는 장점\n\nCombine을 사용하면 여러 가지 이점이 있습니다:\n\n- 비동기 코드 간소화: 비동기 이벤트 처리를 더 간편하게 만듭니다.\n- 코드 가독성 향상: 선언적 구문이 코드의 가독성과 유지 관리를 향상시킵니다.\n- SwiftUI와의 완벽한 통합: SwiftUI와 원활하게 통합되어 반응형 UI 업데이트를 가능하게 합니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 결론\n\n콤바인의 Publisher 및 Subscriber 프로토콜을 이해하는 것은 비동기 이벤트를 효과적으로 관리하는 데 중요합니다. 이 개념을 숙지하고 연산자를 사용해 Publisher를 결합하면 견고하고 효율적인 Swift 애플리케이션을 만들 수 있습니다.\n\n# 추가 자료\n\n- Apple의 콤바인 문서\n- 콤바인 튜토리얼: 시작하기\n- 콤바인 Swift 힌디어 자습서: Publisher 및 Subscriber 프로토콜","ogImage":{"url":"/assets/img/2024-06-27-UnderstandingPublisherandSubscriberProtocolsinCombineSwift_0.png"},"coverImage":"/assets/img/2024-06-27-UnderstandingPublisherandSubscriberProtocolsinCombineSwift_0.png","tag":["Tech"],"readingTime":7},{"title":"모바일 앱을 위한 최고의 Firebase 도구들","description":"","date":"2024-06-27 19:33","slug":"2024-06-27-BestFirebaseToolsforYourMobileApplication","content":"\n\n<img src=\"/assets/img/2024-06-27-BestFirebaseToolsforYourMobileApplication_0.png\" />\n\n모바일 애플리케이션을 개발할 때, 보통 권한 부여, 푸시 알림 등과 같은 필수 기능을 구현해야 하는데, 이는 예산과 시간이 부족한 스타트업에게 특히 어려운 과제일 수 있습니다. 이러한 기능을 구현하는 것은 매우 시간이 많이 소요되고 자원이 많이 소모될 수 있습니다.\n\nFirebase는 개발 프로세스를 간편하게 만들어주는 다양한 도구를 제공합니다. 이 도구들은 인증, 알림, 실시간 데이터베이스 등에 대한 사용 준비 완료 솔루션을 제공합니다. 이를 통해 스타트업은 핵심 제품에 집중할 수 있고 백엔드 인프라를 구현하고 유지하는 데 소중한 자원을 낭비할 필요가 없습니다.\n\n이 게시물에서는 Firebase를 모바일 및 웹 애플리케이션에 활용하는 방법을 배우게 될 것입니다. 인증, 푸시 알림, 원격 구성, 분석 등과 같은 기능을 포함한 내용을 다룰 예정입니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# Firebase란 무엇인가요?\n\nFirebase는 애플리케이션에서 가장 중요한 기능을 구현하는 데 큰 도움이 되는 다양한 도구를 제공합니다. 이러한 기능은 푸시 알림, 분석 및 실시간 데이터베이스 등이 있는데, 이러한 것들을 제로베이스부터 구축하는 데는 상당한 노력이 필요합니다.\n\nFirebase는 해당 서비스를 실행할 수 있도록 맞춤형 서버를 제공합니다. 푸시 알림, 분석 및 실시간 데이터베이스와 같은 기능을 구현하기 위해 서버를 구축하고 유지할 필요가 없습니다. Firebase를 사용하면 백엔드 작업을 크게 줄일 수 있습니다. 때로는 Firebase의 견고한 인프라를 활용하여 자체 서버를 호스팅하지 않고도 모바일 응용 프로그램을 출시할 수 있습니다.\n\n클라이언트 측에서 Firebase는 여러 클라이언트 SDK를 제공하여 해당 서버와의 통신을 용이하게 하고 비즈니스 로직 빌드 프로세스를 간단하게 만들어 Firebase 서비스와의 원활한 통합을 보장합니다. 또한 Firebase 콘솔은 웹 브라우저를 통해 이벤트를 추적하고 서비스를 쉽게 관리할 수 있게 하는 사용자 친화적 인터페이스를 제공하여 비 기술 직군인 제품 소유자와 같은 팀 구성원이 이용할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n스택쉐어에 따르면 Firebase는 능력과 신뢰성을 입증했으며, 인스타카트, 블록, 트위치, 액센처와 같은 주요 기업들이 사용하고 있습니다. 게다가 Firebase는 무료 요금제(스파크 플랜)를 제공하여 비용을 들이지 않고 서비스를 향상시키려는 스타트업들에게 매력적인 옵션이 됩니다. Firebase를 시도하지 않을 이유가 없습니다. \n\n# 인증\n\n![Firebase 도구](/assets/img/2024-06-27-BestFirebaseToolsforYourMobileApplication_1.png)\n\n인증은 사용자를 식별해야 하는 대부분의 애플리케이션에서 꼭 필요한 기능입니다. 사용자의 신원을 파악하면 애플리케이션은 사용자 데이터를 안전하게 서버에 저장하고 해당 사용자의 모든 기기에서 개인화된 경험을 제공할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n앱에서 인증을 처리하는 가장 쉬운 방법은 Google, Meta, Twitter 등의 잘 알려진 플랫폼의 인증 서비스를 활용하는 것입니다. 이러한 서비스들은 각 회사에서 철저히 검토되어 견고한 보안을 제공합니다. 또한 사용자는 기존 계정을 사용하여 손쉽게 신원을 인증할 수 있어 새로운 계정을 수동으로 등록할 필요가 없어져 온보딩 프로세스가 간단해집니다.\n\nFirebase Authentication은 백엔드 서비스와 클라이언트 라이브러리를 제공하며, 안드로이드, iOS, Flutter, Web, Unity 등 여러 플랫폼에서 사용자를 인증할 수 있는 UI 라이브러리를 쉽게 제공합니다. Google, Facebook, Apple, Twitter, GitHub, Microsoft, 수동 이메일-비밀번호, 전화번호 인증을 포함한 다양한 인증 제공자와 통합되어 사용할 수 있습니다. 이러한 다양한 옵션을 통해 사용자들이 선호하는 플랫폼이나 인증 방식에 관계없이 원활하고 안전한 로그인 경험을 제공할 수 있습니다.\n\nFirebase Authentication은 또한 다중 요소 인증, 차단 기능, 남용 방지, SAML(Security Assertion Markup Language) 및 OpenID Connect 제공자 지원과 같은 고급 기능을 제공합니다. 이러한 기능은 보안을 강화하고 사용자 인증을 효율적으로 관리할 수 있는 더 많은 유연성을 제공합니다. 이러한 기능에 대해 자세히 알아보고 싶다면 공식 문서를 확인해보세요.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n푸시 알림은 사용자들을 참여시키기 위한 모바일 애플리케이션의 핵심 기능이며, 활성 사용자 참여 및 유지에 효과적인 전략이 될 수 있습니다. 또한 사용자 상호 작용 간에 좋아요, 댓글, 채팅 메시지 및 팔로우와 같은 실시간 정보 및 업데이트를 제공하는 데 매우 유용할 수 있습니다.\n\n예를 들어 푸시 알림을 통해 새 메시지, 친구 요청, 또는 게시물 업데이트 등에 대한 사용자 경고를 할 수 있어서 앱과 계속 연결되어 있도록 유지할 수 있습니다. 효과적인 푸시 알림 사용은 사용자 경험 향상, 높은 유지율 및 앱에서 사용자 활동 증가로 이어질 수 있습니다.\n\n제로부터 알림 시스템을 구축하는 것은 자원 투자가 많이 필요하고 복잡합니다. 알림 클라우드 서버를 설정하고 실시간 동기화 메커니즘을 구현하여 알림 페이로드를 가져오고, 모바일 장치가 올바르게 깨어나도록 보장하고, 서버와 클라이언트 간의 필요한 페이로드 프로토콜을 생성해야 합니다.\n\nFirebase는 Firebase Cloud Messaging (FCM)이라는 내장 솔루션을 제공하여 별도의 알림 서버를 구축할 필요 없이 알림 시스템을 구축할 수 있습니다. 또한 모바일 애플리케이션용 클라이언트 SDK를 제공하여 사용자가 올바른 알림을 받을 수 있도록 보장합니다. Firebase의 종합적인 지침을 따르면 FCM을 사용하여 스타트업이 복잡한 푸시 알림 시스템을 효율적으로 구축할 수 있으며, 종종 하루 사이에 구현할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nFCM은 비기술 직원인 제품 매니저 등이 GUI 기반 Firebase 콘솔을 통해 쉽게 푸시 알림을 보낼 수 있는 편리한 사용자 경험을 지원합니다. 이는 제품 매니저가 기술 지식이 없어도 구체적인 주제 구독자에게 데이터 페이로드와 예약된 알림을 포함한 푸시 알림 메시지를 보낼 수 있고 특정 사용자를 대상으로 할 수 있다는 것을 의미합니다.\n\n![이미지1](/assets/img/2024-06-27-BestFirebaseToolsforYourMobileApplication_2.png)\n\n공식 문서에 따르면 FCM의 전체 아키텍처는 아래 그림과 같이 설명되어 있습니다:\n\n![이미지2](/assets/img/2024-06-27-BestFirebaseToolsforYourMobileApplication_3.png)\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위 그림에 설명된 아키텍처는 아래와 같이 작동합니다:\n\n- 알림 요청 생성: FCM 콘솔이나 귀하의 백엔드 서비스를 사용하여 알림 요청을 생성합니다. 귀하의 백엔드 서비스는 신뢰할 수 있는 서버 환경 내에서 작동해야 하며 Firebase Admin SDK 또는 FCM 서버 프로토콜을 지원해야 합니다.\n- FCM 백엔드 처리: FCM 백엔드는 메시지 요청을 수락하고 주제를 통해 메시지를 전파하며 메시지 ID를 포함한 메시지 메타데이터를 생성합니다.\n- 플랫폼 수준 전송 계층: 플랫폼 수준 전송 계층은 메시지를 대상 기기로 라우팅합니다. 메시지 전달을 처리하고 필요한 경우 플랫폼별 구성을 적용합니다.\n- 사용자 기기의 FCM SDK: 사용자의 기기에서 FCM SDK는 앱의 전경/배경 상태 및 관련 응용 프로그램 논리에 따라 알림 표시 또는 메시지 처리를 처리합니다. SDK는 알림이 앱 내에서 적절하게 표시되거나 처리되도록 보장합니다.\n\n더 많은 정보를 원하시면 FCM의 공식 문서를 확인해보세요.\n\n# Firebase Remote Config\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n모바일 개발에서 가장 큰 도전 중 하나는 UI 레이아웃 수정, 특정 기능 활성화 또는 비활성화, 기타 조정 등 애플리케이션 변경 사항에 대한 업데이트를 푸시해야 한다는 점입니다. 일반적으로 이는 Google Play Store 또는 Apple App Store로 새 패키지를 전달하는 작업을 포함합니다. 또한, 사용자는 해당 변경 사항을 보려면 애플리케이션을 수동으로 업데이트해야 합니다.\n\nFirebase Remote Config를 사용하면 이러한 간단한 변경 사항을 위해 앱을 업데이트하는 복잡한 과정을 피할 수 있습니다. Firebase Remote Config는 사용자가 업데이트를 다운로드할 필요 없이 앱의 동작 및 외관을 수정할 수 있는 클라우드 서비스입니다.\n\nFirebase 콘솔에서 값(매개변수 키 및 값)을 업데이트하면 앱 또는 서버 구현에서 이러한 업데이트가 적용되는 시점을 결정합니다. 앱은 주기적으로 업데이트를 확인하고(시간당 한 번 또는 이와 유사한 주기로) 성능에 미치는 영향을 최소화하며 이를 적용할 수 있습니다. Firebase는 비기술적인 직원이 전략에 따라 이러한 값을 제어할 수 있도록 GUI 기반의 콘솔도 제공합니다.\n\n아래 이미지는 Firebase 도구를 통해 모바일 애플리케이션에 사용할 수 있는 최상의 기능을 보여줍니다:\n\n![Firebase 도구](/assets/img/2024-06-27-BestFirebaseToolsforYourMobileApplication_4.png)\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nFirebase 원격 구성은 앱 업데이트 없이 기능을 활성화하거나 비활성화하는 데 매우 유용할 수 있습니다. 이를 통해 다양한 구성을 실험하고 계절 이벤트나 보상을 관리하며 다양한 시간대에서 특정 기능을 원활하게 활성화할 수 있습니다. 귀하의 응용 프로그램에서 Firebase 원격 구성을 효과적으로 활용하면 다음과 같은 유연성을 크게 향상시킬 수 있습니다:\n\n- 리스크 감소: 대상 사용자에게 기능을 점진적으로 전파하고 필요한 경우 긴급 롤백을 수행합니다.\n- 사용자 참여 증대: 사용자가 앱을 사용하는 동안 빠르게 사용자 경험을 맞춤 설정할 수 있습니다. 예를 들어 구글 애널리틱스 사용자 속성과 일치하는 사용자에게 배너를 업데이트하고 인센티브를 제공하거나 다른 사용자 그룹에 대해 동적으로 판매 금액을 조정할 수 있습니다.\n- 개발자 생산성 향상: 개발 및 테스트 팀에 기능 플래그로 사용할 원격 구성 매개변수를 사용하여 제품의 기능을 더 효과적으로 노출하고, 실제 사용자에게는 숨겨진 상태로 유지합니다. 이는 빌드 종속성을 줄이고 개발 프로세스를 간소화합니다.\n\nFirebase 원격 구성에 대해 더 알고 싶다면, \"실시간 원격 구성 이해하기\"를 확인해보세요.\n\n# 실시간 데이터베이스\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n모바일 애플리케이션 개발에서는 종종 사용자 데이터를 저장하거나 사용자 간 통신을 가능하게해야 합니다. 이러한 경우에는 모바일 애플리케이션과 상호 작용하는 백엔드 서버를 설정하고 관리해야합니다. 그러나 대부분의 스타트업은 매우 제한된 개발자 수로 구성되어 있기 때문에 사용자 정의 서버를 구축하고 유지하는 것이 어려울 수 있습니다. 또한 비용이 소요될 수 있습니다.\n\n시장 피드백을 수집하려면 간단한 서버를 구축하거나 애플리케이션 개발자로서 백엔드 서버를 구축하는 비용을 줄이려는 경우 Firebase Realtime Database가 최적의 선택입니다. Firebase Realtime Database는 빠르게 백엔드를 설정하고 관리할 수 있는 이상적인 솔루션을 제공하여 앱 개발에 집중할 수 있게 해줍니다. 이를 통해 서버 인프라를 처음부터 구축하는 복잡성과 비용을 줄일 수 있습니다.\n\nFirebase Realtime Database를 사용하면 NoSQL 클라우드 데이터베이스를 활용하여 데이터를 저장하고 동기화시킬 수 있습니다. 데이터는 실시간으로 모든 클라이언트 간에 동기화되며 앱이 오프라인 상태가 되었을 때에도 액세스할 수 있습니다. 이는 복잡한 SQL 쿼리나 무거운 계산 작업이 필요하지 않은 경우 매우 편리한 옵션이 될 것입니다.\n\nFirebase Realtime Database를 사용하는 주요 장점은 다음과 같습니다:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 실시간 데이터 동기화: 전형적인 HTTP 요청과 달리 Firebase 실시간 데이터베이스는 데이터 동기화를 활용하여 데이터에 대한 모든 변경 사항이 연결된 모든 기기에서 즉시 업데이트되어 밀리초 내에 동기화됩니다. 이 기능을 통해 네트워킹 코드를 관리하지 않고도 협업 및 몰입적인 경험을 구현할 수 있습니다. \n- 오프라인 보존: Firebase 앱은 오프라인 상태에서도 반응성을 유지합니다. 실시간 데이터베이스 SDK는 데이터를 기기의 디스크에 보존합니다. 연결이 복구되면 클라이언트 기기가 놓친 업데이트를 받아서 현재 서버 상태와 동기화합니다. 이는 네트워크 상태에 관계 없이 끊김 없는 사용자 경험을 보장합니다.\n\nFirebase 실시간 데이터베이스에 대해 더 자세히 알아보려면 공식 문서를 확인해보세요.\n\n# 앱 배포\n\n![이미지](/assets/img/2024-06-27-BestFirebaseToolsforYourMobileApplication_5.png)\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n모바일 개발자이신 경우, 적어도 한 번은 APK, AAB 또는 IPA 파일과 같은 응용 프로그램 파일을 제품 관리자나 QA 전문가에게 테스트를 위해 전달해야 한 적이 있을 것입니다. 그 후 팀에서 이전 버전을 제거하고 새로운 버전을 설치할 것입니다.\n\n기본적인 방식으로는 응용 프로그램 파일을 팀원들에게 전달하는 목표를 달성할 수 있지만 몇 가지 단점이 있습니다:\n\n- 확장성 문제: 팀이 크고 많은 이해 관계자가 응용 프로그램을 테스트해야 하는 경우 파일을 각 사람에게 개별적으로 배포해야 합니다.\n- 버전 관리: 전달된 버전을 추적하는 것이 어려울 수 있으며 혼란과 불일치로 이어질 수 있습니다.\n- 설치 번거로움: 팀원들은 응용 프로그램 파일을 수동으로 다운로드하고 지역 장치로 전송한 다음 이전 버전을 제거하고 새 버전을 설치해야 합니다. 이 과정은 시간이 걸리고 번거로울 수 있습니다.\n\nFirebase는 Firebase App Distribution을 통해 이러한 시나리오에 우수한 솔루션을 제공합니다. 이 도구는 신뢰하는 테스터들에게 앱을 배포하는 프로세스를 간소화합니다. Firebase 콘솔에서 팀원들을 테스터로 추가하고 콘솔을 통해 응용 프로그램을 게시함으로써, 팀원들은 이메일 통지를 받고 Firebase Tester 앱을 통해 앱을 설치할 수 있습니다. 이 방법은 앱 배포를 최적화하고 모든 이해 관계자가 쉽게 테스트를 위해 최신 버전에 액세스할 수 있도록 보장합니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nFirebase App Distribution은 개발자들을 위한 매우 유용한 플러그인도 제공합니다. 이를 통해 빌드 프로세스 중에 터미널에서 애플리케이션 파일을 자동으로 배포할 수 있습니다. Android용으로는 Firebase가 Gradle 플러그인을 제공하고, iOS용으로는 Fastlane을 통해 배포할 수 있습니다.\n\n더 많은 정보는 Firebase App Distribution을 확인해보세요.\n\n# Crashlytics\n\n충돌은 향상된 사용자 경험을 보장하기 위해 해결해야 할 가장 중요한 문제 중 하나입니다. 모바일 장치에서 충돌이 발생하면 애플리케이션이 종료되는데 그뿐만 아니라 사용자가 현재 상태와 작업 흐름을 모두 잃게됩니다. 이러한 중단은 사용자 불만을 유발할 수 있고, 낮은 평가나 사용자 유지에 이를 수도 있습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n크래시 이해는 중요하지만 각 사용자의 기기에서 모든 문제를 개별적으로 진단하는 것은 비효율적입니다. 여기서 Firebase Crashlytics가 등장합니다. 이는 사용자 기기에서 발생하는 크래시를 정리하고 보고하여 대규모의 크래시 데이터를 처리 가능한 문제 목록으로 제공합니다. Crashlytics는 맥락 정보를 제공하고 크래시의 심각성과 보편성을 강조하여 루트 원인을보다 빨리 파악할 수 있게 합니다.\n\nFirebase 콘솔을 통해 크래시에 대한 자세한 정보를 얻을 수 있습니다. 이 정보에는 문제를 일으킨 코드, 문제를 겪은 특정 기기, 그리고 이러한 발생 빈도가 포함됩니다. 아래 이미지에서 확인할 수 있습니다:\n\n![crash-details](/assets/img/2024-06-27-BestFirebaseToolsforYourMobileApplication_6.png)\n\nAndroid Studio에서 App Quality Insights Tool을 제공하여 Android 애플리케이션에서 크래시를 직접 추적할 수 있습니다. IDE와 Firebase 계정을 통합하면 자세한 크래시 보고서를 확인하고 문제를 효율적으로 디버그할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![Firebase Tools](/assets/img/2024-06-27-BestFirebaseToolsforYourMobileApplication_7.png)\n\n안드로이드 스튜디오의 App Quality Insights 도구를 사용하면 안드로이드 중요한 문제를 볼 수 있고, 필터링할 수 있으며, 스택 트레이스에서 해당 코드로 직접 이동할 수 있습니다. Firebase와 통합되어 프로젝트 내 문제를 효율적으로 디버깅하고 빠르게 해결할 수 있습니다. 더 많은 정보를 원하시면 App Quality Insights에서 Firebase Crashlytics 및 Android Vitals로부터 문제를 분석하는 것을 확인해보세요.\n\n# 성능 모니터링\n\n![Firebase Tools](/assets/img/2024-06-27-BestFirebaseToolsforYourMobileApplication_8.png)\n\n\nFirebase Tools 이미지와 함께 안드로이드 스튜디오의 App Quality Insights 도구를 사용하면 안드로이드 중요한 문제를 볼 수 있고, 필터링할 수 있으며, 스택 트레이스에서 해당 코드로 직접 이동할 수 있습니다. Firebase와 통합되어 프로젝트 내 문제를 효율적으로 디버깅하고 빠르게 해결할 수 있습니다. 더 많은 정보를 원하시면 App Quality Insights에서 Firebase Crashlytics 및 Android Vitals로부터 문제를 분석하는 것을 확인해보세요.\n\n# 성능 모니터링\n\nFirebase Tools 이미지와 함께 성능 모니터링을 할 수 있습니다. 만약 질문이 있으시다면 언제든지 물어봐주세요! 😊\n\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n파이어베이스는 Performance Monitoring이라는 가치 있는 도구를 제공합니다. 이 도구를 사용하면 개발자들은 전체 애플리케이션의 성능을 모니터링하고 추적하거나 매우 특정한 기능에 초점을 맞출 수 있습니다. Performance Monitoring을 사용하면 앱이 실제 세계에서 어떻게 수행되고 있는지에 대한 통찰력을 얻을 수 있으며 성능 병목 현상을 식별하고 사용자 경험을 향상시키기 위한 데이터 기반 개선을 할 수 있습니다.\n\n이 도구를 사용하면 네트워크 연결 상태, 무거운 자원 로드 및 복잡한 UI 렌더링과 같은 애플리케이션 성능의 여러 측면을 실시간으로 모니터링할 수 있습니다. 파이어베이스 콘솔에서 제공되는 성능 보고서를 확인함으로써 병목 현상을 식별하고 특정 구현을 최적화하여 앱의 전체 성능을 향상시킬 수 있습니다.\n\n이 도구는 앱 시작 시간, HTTP 네트워크 요청, 화면 렌더링 데이터 등을 자동으로 측정합니다. 또한, 애플리케이션의 특정 기능의 성능을 추적하기 위해 사용자 정의 코드를 추가할 수 있습니다. 이를 통해 특정 기능에 대한 상세한 통찰력을 얻고 수집된 데이터를 기반으로 최적화할 수 있습니다.\n\n이 도구에 대해 더 알고 싶다면 파이어베이스 Performance Monitoring을 확인해보세요.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# Firebase Extensions\n\n![Firebase Extensions](/assets/img/2024-06-27-BestFirebaseToolsforYourMobileApplication_9.png)\n\n파이어베이스는 특별한 기능을 제공하는 Firebase Extensions라고 불리는 추가 도구를 제공합니다. 이 도구들은 개발자가 사전 패키지된 솔루션을 사용하여 애플리케이션 내에서 기능을 빠르게 배포, 구축 또는 분석할 수 있도록 돕습니다. Firebase Extensions는 애플리케이션이나 프로젝트 내에서 사전 정의된 이벤트가 발생했을 때 작업을 실행하는 코드 조각이며, 이들은 Cloud Functions for Firebase를 사용하여 작성됩니다.\n\n이 확장 기능은 Firebase Extensions 허브를 통해 액세스할 수 있습니다. 여기서 다양한 유용한 확장 기능을 살펴보고 프로젝트에 통합할 수 있습니다. 추가로, 개발자 커뮤니티에 기여하거나 SaaS(서비스로서의 소프트웨어) 솔루션을 연결하기 위해 자체 Firebase 확장 기능을 개발할 수도 있습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n최근 Google Cloud 팀은 Gamini Firebase 확장 프로그램을 소개했습니다. 이 확장 프로그램을 사용하면 클라우드 Firestore에서 저장 및 관리되는 Gemini 모델을 사용하여 빠르게 챗봇을 구축할 수 있습니다. 이 확장 프로그램을 사용하면 Vertex AI에서 Generative AI를 활용하는 챗봇 시스템을 구현하기 쉬워집니다.\n\nFirebase 확장 프로그램을 구축하는 최상의 방법으로, Stream Chat을 사용하여 인증하는 것을 고려해보세요. 이 확장 프로그램을 사용하면 Firebase 인증 기반의 사용자 정보를 인증할 수 있습니다. Stream SDK 고객은 소셜 식별, 전화번호 확인, 이메일 및 비밀번호 인증과 같이 Firebase가 제공하는 인증 방식을 활용하여 Stream 인증을 Firebase 인증과 쉽게 통합할 수 있습니다. 자세한 내용은 \"Announcing Stream Firebase Extensions for Chat and Feeds\"를 확인해보세요.\n\n# 결론\n\n이 글에서는 Firebase가 비즈니스 및 애플리케이션 성능을 향상시키는 데 제공하는 가장 유용한 도구 몇 가지를 살펴봤습니다. Firebase는 주로 모바일 애플리케이션을 제공하는 대부분의 회사들에 이점을 제공하며, 특히 복잡한 시스템을 처음부터 구축하거나 모바일 친화적인 백엔드 인프라를 개발하기 위한 예산이 제한된 스타트업에게 많은 혜택을 줍니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n본 문서에 궁금한 점이나 피드백이 있으면 작성자를 Twitter에서 @github_skydoves 또는 GitHub에서 찾아보세요. Stream에 대해 최신 정보를 받고 싶다면 Twitter에서 @getstream_io를 팔로우해보세요. \n\n언제나 즐거운 코딩되세요!\n\n— Jaewoong\n\n원문은 GetStream.io에 게시되었습니다.","ogImage":{"url":"/assets/img/2024-06-27-BestFirebaseToolsforYourMobileApplication_0.png"},"coverImage":"/assets/img/2024-06-27-BestFirebaseToolsforYourMobileApplication_0.png","tag":["Tech"],"readingTime":17},{"title":"쿠버네티스를 위한 최신 Grafana 대시보드 세트","description":"","date":"2024-06-27 19:32","slug":"2024-06-27-AnupdatedsetofGrafanadashboardsforKubernetes","content":"\n\n<img src=\"/assets/img/2024-06-27-AnupdatedsetofGrafanadashboardsforKubernetes_0.png\" />\n\n# 소개\n\n두 해 전에 저는 Kubernetes를 위해 만든 대시보드를 공유하기 위해 \"Kubernetes를 위한 현대적인 Grafana 대시보드 세트\"를 발표했습니다. 이 기사에서는 해당 프로젝트의 업데이트를 제공하고, 그 이후에 이루어진 주요 변경 사항을 안내하겠습니다.\n\n# 프로젝트 업데이트\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n최근 두 년간 dotdc/grafana-dashboards-kubernetes 프로젝트가 크게 발전했습니다! 여러 리트윗을 통해 원문 기사와 프로젝트가 주목할 만한 트래픽 증가를 보였고, 새로운 기여자들도 늘어났습니다. 제 대시보드를 자신의 홈 랩이나 Rakuten, Orange, Swisscom, Nokia와 같은 회사에서 사용하는 세계 각지의 많은 사람들을 보니 놀랍기도 했습니다. 일부 프로젝트는 Victoria Metrics, GCP Cloud Foundation Fabric, Microsoft Azure Arc Jumpstart와 같이 대시보드를 직접 포함하기도 했습니다.\n\n현재 프로젝트 통계는 다음과 같습니다:\n\n- ~500만 개의 대시보드 다운로드 (grafana.com에서만!)\n- 2293개의 GitHub 스타\n- 337개의 포크\n- 26명의 기여자\n\n![2024-06-27-AnupdatedsetofGrafanadashboardsforKubernetes_1.png](/assets/img/2024-06-27-AnupdatedsetofGrafanadashboardsforKubernetes_1.png)\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 변경 사항\n\n## 일반적인 변경 사항\n\n커뮤니티 요구에 따라 해당 프로젝트는 이제 심벌릭 버전 배포를 따르는 자동으로 생성된 적절한 릴리스를 가지게 되었습니다. 이는 콘벤셔널 커밋을 활용하여 시맨틱 버전 관리를 따르는 버전을 생성합니다.\n\n게다가, 이제 모든 대시보드에는 클러스터 변수 지원이 포함되어 있으며, 이는 안전하고 간단한 해결책과 함께 문서화된 문제 #15에서 구현되었습니다. 이를 통해 Thanos, Mimir 또는 다른 연합 또는 고가용성 설정을 사용하는 사용자도 향상된 호환성을 누릴 수 있게 되었습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n더불어, 모든 \"views\" 대시보드에서 CPU 쓰로틀링을 시각화하는 새로운 패널이 추가되었습니다.\n\n# k8s-views-pods.json\n\n이슈 #21에서의 아이디어를 기반으로 하여 추가적인 작업을 통해, k8s-views-pods.json이 주요 업데이트를 받았습니다! 변경 사항 중에는 우선순위 클래스, QoS 클래스, 마지막 종료 이유 및 마지막 종료 종료 코드를 표시하는 새로운 정보 패널들이 있습니다.\n\n게다가, CPU 요청 및 제한을 실제 CPU 사용량과 비교하는 패널과 메모리에 대해 동일한 작업을 수행하는 또 다른 패널이 추가되었습니다. 이를 통해 컨테이너 자원 사용량을 더 잘 시각화하고 컨테이너 크기 결정을 간단하게 할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-06-27-AnupdatedsetofGrafanadashboardsforKubernetes_2.png\" />\n\n# k8s-addons-prometheus.json\n\n프로젝트에는 이제 Prometheus 대시보드가 포함되어 있습니다. Prometheus 인스턴스, TSDB, 쿼리 엔진, 리소스, 스토리지 및 네트워크와 관련된 패널이 포함되어 있습니다.\n\n<img src=\"/assets/img/2024-06-27-AnupdatedsetofGrafanadashboardsforKubernetes_3.png\" />\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# k8s-addons-trivy-operator.json\n\nGiant Swarm starboard-exporter를 사용한 k8s-addons-starboard-operator.json이 Aqua Security의 trivy-operator에서 가져온 메트릭을 기반으로 한 k8s-addons-trivy-operator.json으로 대체되었습니다.\n\n![이미지](/assets/img/2024-06-27-AnupdatedsetofGrafanadashboardsforKubernetes_4.png)\n\n# 변경 내역\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nk8s-views-global.json:\n\n- throttled cpu가 추가되었습니다 (0427a7f)\n- 클러스터 변수가 추가되었습니다 (3d99847)\n\nk8s-views-namespaces.json:\n\n- throttled cpu 패널이 추가되었습니다 (dbf01b1)\n- 특정 배포, StatefulSet 또는 데몬셋을 필터링하는 기능이 추가되었습니다 (d173be7)\n- 클러스터 변수가 추가되었습니다 (7ac58e5)\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nk8s-views-nodes.json:\n\n- 노드에서 파드로의 링크를 추가했습니다 (50d1aa6)\n- 쓰로틀된 CPU 패널을 추가했습니다 (d223755)\n\nk8s-views-pods.json:\n\n- 아이디어를 바탕으로 팟 대시보드를 재작업했습니다 (9d11d49)\n- 쓰로틀된 CPU 패널을 추가했습니다 (d223755)\n- 파드에서 노드로의 링크를 추가했습니다 (df42ae5)\n- OOM과 재시작을 추가했습니다 (ab62016)\n- 클러스터 변수를 추가했습니다 (7ac58e5)\n- 다중 팟 선택을 추가했습니다 (03281bf)\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다른 변경 사항:\n\n- 시맨틱 릴리스 (b7d3553)\n- ArgoCD 배포 추가 (3518826)\n- 여러 버그 수정 및 작은 개선 사항\n\n# 마지막으로\n\n이 문서가 유용하고 원본 문서보다 추가 정보를 제공했기를 바랍니다!\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n정말 보람찬 경험이었어요. 커뮤니티로부터 피드백, 칭찬, 아이디어를 받고 기술적인 토론에 참여하다 보니 결국 그라파나 챔피언 프로그램에 참여하게 되었어요. 감사합니다! ❤️\n\n언제든지 피드백과 제안을 환영해요. 이 프로젝트에 기여하고 싶다면 아래와 같이 참여해보세요:\n\n- 좋다면 GitHub ⭐을 주세요.\n- 기능 요청, 버그 신고 또는 아이디어 공유를 위해 이슈를 작성해주세요.\n- 코드나 이 프로젝트에 유용한 것을 공유하고 싶다면 풀 리퀘스트를 생성해주세요.\n\n저를 여기 Medium에서 팔로우하거나 아래에서도 만나 볼 수 있어요:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- GitHub : https://github.com/dotdc\n- Mastodon : https://hachyderm.io/@0xDC\n- Twitter : https://twitter.com/0xDC_\n- LinkedIn : https://www.linkedin.com/in/0xDC\n\n👋","ogImage":{"url":"/assets/img/2024-06-27-AnupdatedsetofGrafanadashboardsforKubernetes_0.png"},"coverImage":"/assets/img/2024-06-27-AnupdatedsetofGrafanadashboardsforKubernetes_0.png","tag":["Tech"],"readingTime":6},{"title":"파이프라인 문제 해결 무한 실행 방지 방법","description":"","date":"2024-06-27 19:31","slug":"2024-06-27-PipelineTroubleshootingPreventingEndlessRuns","content":"\n\nJenkins 가이드를 따르다가 파이프라인이 계속 실행되는 문제가 발생한다면, 여기 가이드가 도움이 될 거예요. 대략 10-20분 정도면, Jenkins 튜토리얼 웹사이트의 예제 프로젝트를 활용하여 이 문제를 해결하는 방법을 배울 수 있어요.\n\nJenkins에 사용자 이름: admin, 비밀번호: admin으로 로그인한 후, simple-node-js-react-npm-app 프로젝트로 이동한 다음 파이프라인을 실행하려고 시도했는데 desktop-jenkins_agent-1-node 컨테이너를 아직 시작하지 않았다면, 콘솔 출력에 아래와 같은 내용이 표시될 거예요.\n\n이 문제를 마주한 경우 이렇게 보일 거예요.\n\n출력은 'docker-ssh-jenkins-agent'이 오프라인이며 빌드가 계속 실행되는 상황입니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 단계 1: Jenkins 컨트롤러 컨테이너 시작\n\n먼저, Docker Desktop을 열고 quickstart-tutorials라는 컨테이너를 찾아보세요.\n\n그 다음으로, quickstart-tutorials-jenkins_controller-1 컨테이너를 찾아 체크박스 옆의 화살표 기호를 클릭하여 실행 상태로 변경하세요.\n\n# 단계 2: Jenkins에 로그인하고 Jenkins 에이전트 확인\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n어떤 웹 브라우저에서 http://localhost:8080을 검색한 후, USERNAME: admin, PASSWORD: admin으로 로그인해주세요.\n\n!! 이 프로젝트 외에 다른 컨테이너를 동시에 실행 중이 아닌지 확인해주세요.\n\n이후 Jenkins 관리로 이동하시고 - '노드'로 이동하면 Agent docker-ssh-jenkins-agent가 오프라인 상태임을 확인할 수 있습니다.\n\ndocker-ssh-jenkins-agent - 로그 페이지로 이동하여 로그를 확인해주세요. 이는 아래 그림과 같이 표시됩니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n연결이 끊어졌습니다. 이는 desktop-jenkins_agent-1-node 컨테이너를 실행해야 한다는 것을 의미합니다.\n\n## 단계 3: Jenkins 에이전트 컨테이너 시작\n\n다시 Docker Desktop을 열어서 quickstart-tutorials 컨테이너 내부에 있는 desktop-jenkins_agent-1-node 컨테이너를 찾고 실행하십시오.\n\n## 단계 4: 에이전트 실행\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nJenkins 웹 사이트에 접속하신 후, \"관리\" - \"노드\" - \"docker-ssh-jenkins-agent\"로 이동하여 \"에이전트 실행\" 버튼을 클릭하고 로그를 확인해주세요.\n\n\"에이전트가 성공적으로 연결되어 온라인 상태입니다\"라는 메시지가 표시될 것입니다.\n\n이후, simple-node-js-react-npm-app 프로젝트 페이지로 돌아가서 \"지금 빌드\"를 한 번 더 클릭하여 다시 확인할 수 있습니다.\n\n위 단계를 따라하신 후, 대시보드 - \"simple-node-js-react-npm-app\" 페이지로 이동해서 \"지금 빌드\"를 클릭하고, 왼쪽 패널에서 최신 빌드 기록을 클릭한 뒤, 왼쪽 내비게이션 패널에서 \"입력 대기\"를 선택하시면 됩니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래 순서를 따르면 Jenkins에서 계속해서 실행되는 파이프라인 문제를 해결할 수 있습니다. 이는 실행이 원할하게 되는 뿐만 아니라 Jenkins와 Docker를 관리하는 방법을 더 잘 이해하는 데도 도움이 됩니다.","ogImage":{"url":"/assets/img/2024-06-27-PipelineTroubleshootingPreventingEndlessRuns_0.png"},"coverImage":"/assets/img/2024-06-27-PipelineTroubleshootingPreventingEndlessRuns_0.png","tag":["Tech"],"readingTime":3},{"title":"클라우드 비용 요약 도구 만들기 가이드","description":"","date":"2024-06-27 19:29","slug":"2024-06-27-BuildingaCloudCostSummaryTool","content":"\n\n우리 회사에서는 클라우드 제공 업체로 Azure와 AWS를 사용하고 있어요. 두 플랫폼 모두 상당히 포괄적인 비용 분석 UI를 제공하지만, 재무 및 운영 팀 구성원들이 각 프로젝트의 이번 달 실제 비용과 예측을 독립적으로 확인하고 이전 달과 비교하기가 다소 어려웠어요.\n\n그래서 양 제공자로부터 이 데이터를 가져와 프로젝트별로 집계하고 노션 페이지에 요약하는 도구를 만들기로 결정했어요.\n\n# Azure 비용 가져오기\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n작은 Go 애플리케이션을 시작하여 테넌트 내 모든 Azure 구독 및 비용을 가져 오고자했습니다. 또한 각 구독에 액세스 권한을 가진 사용자 목록을 가져 오고 싶었습니다.\n\n이를 위해 azure-sdk-for-go를 사용했는데, 구체적으로 azidentity, armsubscription 및 armauthorization 패키지를 사용했습니다. AzureAuthenticationService 및 AzureSubscriptionService를 구축하여 모든 Azure 구독과 해당 사용자 및 역할을 나열할 수 있도록했습니다.\n\n이 두 서비스의 사용 예제로 다음 코드는 모든 구독 및 해당 사용자 및 역할을 나열하는 방법을 보여줍니다:\n\n```js\nfunc main() {\n ctx := context.Background()\n\n cred, err := azidentity.NewDefaultAzureCredential(nil)\n if err != nil {\n  fmt.Println(\"[ERROR] Failed to authenticate with azure with error: \" + err.Error())\n  return\n }\n\n subscriptionService, err := AzureApi.NewAzureSubscriptionService(cred)\n if err != nil {\n  fmt.Println(\"[ERROR] Failed to instatiate subscription client with error: \" + err.Error())\n  return\n }\n\n subscriptions, err := subscriptionService.ListSubscriptions(ctx)\n if err != nil {\n  fmt.Println(\"[ERROR] Failed to get subscription with error: \" + err.Error())\n  return\n }\n\n for _, sub := range subscriptions {\n  authService, err := AzureApi.NewAzureAuthenticationService(cred, sub.SubscriptionID)\n  if err != nil {\n   fmt.Println(\"[ERROR] Failed to instatiate subscription client with error: \" + err.Error())\n   return\n  }\n  roles, err := authService.ListUserRoleAssignments(ctx)\n  if err != nil {\n   fmt.Println(\"[ERROR] Failed to instatiate subscription client with error: \" + err.Error())\n   return\n  }\n  fmt.Println(\"------------------------------------------------\")\n  fmt.Printf(\"Users for Subscription %s\\n\", sub.DisplayName)\n  for _, role := range roles {\n   fmt.Printf(\"%s %s\\n\", role.UserDisplayName, role.RoleName)\n  }\n }\n}\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n비용 관리 패키지인 armcostmanagement을 사용하여 필요한 정보를 검색할 수 있습니다.\n\n한편, 필요한 것을 모두 처리하는 오픈 소스 .NET 도구인 azure-cost-cli를 찾았습니다. 이 도구는 매우 완전한 JSON 보고서를 출력하는 것뿐만 아니라, 꽤 멋진 마크다운 출력도 가능했습니다. 그래서 완전히 처음부터 개발하는 대신에 이것을 사용하기로 결정했습니다.\n\n# Notion 보고서\n\nNotion은 Notion 워크스페이스에서 기존 콘텐츠를 생성하고 변경할 수 있게 해주는 좋은 REST API를 제공합니다. API 및 해당 콘텐츠에 접근하려면 API 키가 필요합니다. 이를 위해 통합을 만들고 필요한 권한을 부여해야 합니다. (여기에서 자세히 설명되어 있습니다).\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음은 노션에서 만든 내용입니다:\n\n- 각 공급업체에 대한 합계 집계가 포함된 주요 요약 페이지\n- 각 공급업체별 페이지는 각 계정/구독에 대한 상세 정보가 포함되어 있습니다.\n- 계정/구독별 상세한 일별 정보가 포함된 페이지\n\n![이미지](/assets/img/2024-06-27-BuildingaCloudCostSummaryTool_1.png)\n\n![이미지](/assets/img/2024-06-27-BuildingaCloudCostSummaryTool_2.png)\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-06-27-BuildingaCloudCostSummaryTool_3.png\" />\n\nAzure와 AWS 페이지 모두 드릴 다운 세부 정보가 Notion 데이터베이스 구성요소에 저장되어 있었습니다. 그런 후 DB ID가 내 Go 어플리케이션으로 전달되어 구독 레벨이 업데이트된 정보를 매일 행마다 추가하거나 업데이트할 수 있도록 했습니다:\n\n- 이번 달 초부터 현재 날짜까지의 실제 비용\n- 현재 날짜부터 이번 달의 마지막 날까지의 예측 비용\n- 지난 달 총 비용\n- 소유권 데이터\n\n또한 각 행의 일별 세부 정보를 포함하는 일일 세부 정보 패널도 있습니다:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 하루당 비용\n- 향후 일일 비용 예측\n- 서비스 유형별 실제 비용\n- 위치별 실제 비용\n- 자원 그룹별 실제 비용\n- 이상 징후 감지 설명\n\nAPI를 사용하기 위해 go-notion이라는 오픈 소스 라이브러리를 사용했어요. 그런데 그 주위에 notion-client.go 래퍼를 구현해야 했어요. 이것은 AppendBlockChild 메서드에 필요한 누락된 After 매개변수 때문이었어요. 페이지의 끝이 아니라 항상 상단에 내용을 추가하기 위해 필요한 것이었죠 (소스 저장소로의 보류 중인 풀 리퀘스트).\n\n또한, notion-service.go도 구현되어 이 페이지에서 모든 콘텐츠 생성을 처리했어요.\n\n스크린샷에서도 알 수 있듯이 데이터베이스 뷰는 프로젝트 소유자와 내부 프로젝트 이름에 대한 정보도 포함하고 있어요. 이 정보는 다른 노션 데이터베이스에 보관되어 있으며, 응용 프로그램은 자동으로 두 데이터베이스 간의 관계 열을 업데이트하여 이 필드가 항상 최신 상태로 유지됩니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n최종적으로 Go 어플리케이션은 현재 및 과거 비용 및 이상 징후 JSON 보고서를 읽는 명령줄 도구로 변형되어, 필요한 집계를 수행하고 해당 노션 페이지를 생성/업데이트합니다.\n\nGo 어플리케이션을 호출하려면 다음과 같은 정보를 전달해야 합니다:\n\n- Azure 구독 ID 및 이름\n- 노션 API 비밀 키\n- 노션 구독 및 소유자 데이터베이스 ID\n- 현재 및 지난 달의 JSON 비용 보고서\n- 이상 징후 JSON 보고서\n\n예를 들어, 호출은 다음과 같이 보일 겁니다:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```bash\ngo run ./cmd/cost-analyser/main.go -id \"$SUBSCRIPTION_ID\" -name \"$SUBSCRIPTION_NAME\" -secret \"$NOTION_TOKEN\" -subscriptionsCostDatabaseId \"$NOTION_DATABASE_ID\" -subscriptionsOwnerDatabaseId \"$NOTION_OWNER_DATABASE_ID\" -inputActualReportJson \"$CURR_COST_DATA\" -inputPastReportJson \"$PAST_COST_DATA\" -anomaliesJson \"$ANOMALIES_COST_DATA\"\n```\n\n이는 Azure의 각 구독에 대해 호출해야 하지만, 이에 대해 자세히는 아래의 Github Actions 섹션을 참조해주세요.\n\n# AWS 비용 가져오기\n\nAWS 비용을 가져오기 위해 aws-sdk-go-v2 라이브러리를 사용한 또 다른 작은 Go 앱이 만들어졌습니다.\n\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음은 AWS 계정과 해당 비용을 가져오는 데 책임이 있는 aws_cost_service.go를 사용했습니다.\n\n이후 비용 보고서를 우리 노션 서비스 이전에 사용한 동일한 구조로 변환하여 응용 프로그램은 Azure에 표시된 것과 유사한 AWS를 위한 노션 페이지를 작성합니다. aws-cost-retrieval 코드는 여기에서 찾을 수 있습니다.\n\n이 경우 하루에 한 번만 애플리케이션을 실행하면 모든 AWS 계정을 검토하고 한 번에 적절한 데이터 업데이트를 생성합니다. 다시 한 번 이 내용은 아래의 Github Actions 섹션에서 자세히 설명하겠습니다.\n\n# 요약 페이지 및 Slack\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 스크린샷에서 확인할 수 있듯이 매일 업데이트해야 하는 노션 요약 페이지가 있습니다. 또한 매주 제공자별로 요약된 집계 비용 정보를 포함하는 슬랙 채널 알림이 필요했습니다.\n\n이를 달성하기 위해 또 다른 작은 Go 애플리케이션인 slack-cost-summary를 개발했습니다.\n\n코드 자체가 매우 명확합니다. 이 애플리케이션은 Azure의 구독 비용을 아티팩트 폴더 내의 로컬 파일에서 읽은 다음 환경 변수를 통해 AWS의 비용을 읽어 공급자별로 비용을 집계하고 현재 요일이 구성된 요일과 일치하는 경우 슬랙 알림을 보냅니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# Github 작업\n\n우리가 모든 필요한 요소를 갖추고 Notion에 보고서를 자동으로 추가하는 작업을 자동화하기만 하면 되었습니다. 이를 GitHub 워크플로에 구성된 일일 작업으로 설정하는 것이 필요했습니다.\n\n![이미지](/assets/img/2024-06-27-BuildingaCloudCostSummaryTool_5.png)\n\nAzure의 경우 비용 보고서를 가져오기 위해 기존 도구를 사용했습니다. 이 도구는 구독 수준에서 작동했기 때문에 먼저 모든 구독을 가져와야 했고, 그런 다음 각각의 구독을 위해 도구를 실행해야 했습니다 (현재 월용으로 3회, 이전 달용으로 1회, 그리고 이상 징후 보고서용으로 1회). 따라서 구독 목록을 가져오는 과정은 다음과 같습니다:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nget-list-of-subscriptions:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Azure 로그인\n        uses: azure/login@v2\n        with:\n          client-id: ${ secrets.AZURE_CLIENT_ID }\n          tenant-id: ${ secrets.AZURE_TENANT_ID }\n          allow-no-subscriptions: true\n\n      - name: 구독 목록 가져오기\n        id: setMatrix\n        run: echo \"subscriptions={\\\"subscription\\\":$(az account list --query '[].{Id:id,Name:name}' --output json | jq -c)}\" >> $GITHUB_OUTPUT\n    outputs:\n      matrix: ${ steps.setMatrix.outputs.subscriptions }\r\n```\n\n각 구독에 대해 작업은 구독 ID 및 구독명이 포함된 구독 개체를 출력합니다.\n\n이 작업과 병렬로 run-aws-costs-cli 작업에서는 AWS 데이터 수집기 Go 응용프로그램이 실행되어 모든 AWS 데이터를 업데이트합니다:\n\n```js\nrun-aws-costs-cli:\n    runs-on: ubuntu-latest\n    outputs:\n      subscriptions: ${ steps.setAwsSubscriptions.outputs.awsSubscriptions }\n    steps:\n      - name: 저장소 복제\n        uses: actions/checkout@v4\n      - name: AWS 자격 증명 구성\n        uses: aws-actions/configure-aws-credentials@v4\n        with:\n          role-to-assume: ${ env.AWS_ARN_BILLING_COLECTOR }\n          role-session-name: GitHub_to_AWS_via_FederatedOIDC\n          aws-region: ${ env.AWS_REGION }\n\n      - name: Go 1.21.x 설정\n        uses: actions/setup-go@v5\n        with:\n          go-version: 1.21.x\n\n      - name: Go 종속성 설치\n        run: go get ./...\n\n      - name: AWS 비용 실행\n        id: setAwsSubscriptions\n        env:\n          NOTION_TOKEN: ${ secrets.NOTION_TOKEN }\n          NOTION_DATABASE_ID: ${ secrets.NOTION_AWS_DATABASE_ID }\n          NOTION_OWNER_DATABASE_ID: ${ secrets.NOTION_OWNER_DATABASE_ID }\n        run: |\n          echo \"awsSubscriptions=$(go run ./cmd/aws-cost-retrieval/main.go -secret \"$NOTION_TOKEN\" -subscriptionsCostDatabaseId \"$NOTION_DATABASE_ID\" -subscriptionsOwnerDatabaseId \"$NOTION_OWNER_DATABASE_ID\" | jq -c)\" >> $GITHUB_OUTPUT\r\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n마지막에는 각 AWS 계정의 비용 보고서 목록이 awsSubscription 배열에 저장될 것입니다.\n\nget-list-of-subscriptions에 의해 출력된 각 Azure 구독마다, 다음 단계 구성으로 run-azure-cost-cli 작업이 생성됩니다:\n\n```js\nrun-azure-cost-cli:\n    name: Azure 구독용 비용 가져오기\n    runs-on: ubuntu-latest\n    needs: [get-list-of-subscriptions]\n    strategy:\n      max-parallel: 1\n      matrix: ${fromJson(needs.get-list-of-subscriptions.outputs.matrix)}\n    steps:\n      - name: Azure 로그인\n        uses: azure/login@v2\n        with:\n          client-id: ${secrets.AZURE_CLIENT_ID}\n          tenant-id: ${secrets.AZURE_TENANT_ID}\n          allow-no-subscriptions: true\n      - name: Azure 비용 CLI 설치\n        run: dotnet tool install -g azure-cost-cli --no-cache\n      - name: JSON 비용 DATA 가져오기\n        id: setCostData\n        run: |\n          day=$(date +%d)\n          if [ \"$day\" = \"01\" ]; then\n            from_two_months=$(date -d \"2 month ago\" \"+%Y/%m/01\")\n            to_two_months=$(date -d \"$(date -d \"month ago\" \"+%Y/%m/01\") - 1 day\" \"+%Y/%m/%d\")\n            from_last_month=$(date -d \"1 month ago\" \"+%Y/%m/01\")\n            to_last_month=$(date -d \"$(date \"+%Y/%m/01\") - 1 day\" \"+%Y/%m/%d\")\n            \n            PREV_DATA=$(azure-cost -o json --subscription ${matrix.subscription.Id} -t Custom --from ${from_two_months} --to ${to_two_months} | jq -c) \n            DATA=$(azure-cost -o json --subscription ${matrix.subscription.Id} -t Custom --from ${from_last_month} --to ${to_last_month} | jq -c)\n            \n            echo \"prevDataJson=$PREV_DATA\" >> $GITHUB_OUTPUT\n            echo \"dataJson=$DATA\" >> $GITHUB_OUTPUT\n          else\n            PREV_DATA=$(azure-cost -o json --subscription ${matrix.subscription.Id} -t TheLastBillingMonth | jq -c)\n            DATA=$(azure-cost -o json --subscription ${matrix.subscription.Id} | jq -c)\n              \n            echo \"prevDataJson=$PREV_DATA\" >> $GITHUB_OUTPUT\n            echo \"dataJson=$DATA\" >> $GITHUB_OUTPUT\n          fi\n          ANOMALIES=$(azure-cost detectAnomalies -o json --subscription ${matrix.subscription.Id} | jq -c)\n          echo \"anomaliesDataJson=$ANOMALIES\" >> $GITHUB_OUTPUT\n      - name: Markdown 형식으로 포맷팅\n        run: |\n          if echo '${steps.setCostData.outputs.dataJson}' | jq -c -r '.cost'| jq -e '. == []'; then\n            echo \"> 이 시기에는 ${matrix.subscription.Name} 구독에 대한 비용이 없습니다.\" >> $GITHUB_STEP_SUMMARY\n          else\n            day=$(date +%d)\n            if [ \"$day\" = \"01\" ]; then\n              from_last_month=$(date -d \"1 month ago\" \"+%Y/%m/01\")\n              to_last_month=$(date -d \"$(date \"+%Y/%m/01\") - 1 day\" \"+%Y/%m/%d\")\n              azure-cost -o markdown --subscription ${matrix.subscription.Id} -t Custom --from ${from_last_month} --to ${to_last_month} >> $GITHUB_STEP_SUMMARY\n            else\n              azure-cost -o markdown --subscription ${matrix.subscription.Id} >> $GITHUB_STEP_SUMMARY\n            fi\n          fi\n      - uses: actions/checkout@v4\n      - name: Go 1.21.x 설정\n        uses: actions/setup-go@v5\n        with:\n          go-version: 1.21.x\n      - name: Go 종속성 설치\n        run: go get ./...\n      - name: Notion으로 배포\n        env:\n          NOTION_TOKEN: ${secrets.NOTION_TOKEN}\n          NOTION_DATABASE_ID: ${secrets.NOTION_DATABASE_ID}\n          SUBSCRIPTION_ID: ${matrix.subscription.Id}\n          SUBSCRIPTION_NAME: ${matrix.subscription.Name}\n          NOTION_OWNER_DATABASE_ID: ${secrets.NOTION_OWNER_DATABASE_ID}\n        run: |\n          CURR_COST_DATA=\"$(echo '${steps.setCostData.outputs.dataJson}' | base64)\"\n          PAST_COST_DATA=\"$(echo '${steps.setCostData.outputs.prevDataJson}' | base64)\"\n          ANOMALIES_COST_DATA=\"$(echo '${steps.setCostData.outputs.anomaliesDataJson}' | base64)\"\n          go run ./cmd/cost-analyser/main.go -id \"$SUBSCRIPTION_ID\" -name \"$SUBSCRIPTION_NAME\" -secret \"$NOTION_TOKEN\" -subscriptionsCostDatabaseId \"$NOTION_DATABASE_ID\" -subscriptionsOwnerDatabaseId \"$NOTION_OWNER_DATABASE_ID\" -inputActualReportJson \"$CURR_COST_DATA\" -inputPastReportJson \"$PAST_COST_DATA\" -anomaliesJson \"$ANOMALIES_COST_DATA\" >> ${matrix.subscription.Id}.json\n      - name: Output 업로드\n        uses: actions/upload-artifact@v4\n        with:\n          name: artifact-${matrix.subscription.Id}\n          path: ${matrix.subscription.Id}.json\n          if-no-files-found: warn\n```\n\nAzure API의 시간 초과 또는 요율 제한 문제로 인해 병렬로 더 많은 작업을 실행할 경우에도 한 번에 1개의 작업을 실행합니다. 주요 단계는 다음과 같습니다:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- Get JSON 비용 데이터는 이전 및 현재 일일 비용 보고서를 얻을 것입니다.\n- Markdown 형식에서 현재 월 보고서를 얻어 Markdown 형식으로 포맷팅하여 GITHUB_STEP_SUMMARY에 출력하여 GitHub 작업 요약 페이지에서 볼 수 있게 합니다.\n- Notion에 배포는 특정 구독을 위한 보고서를 업데이트하기 위해 Notion Go 애플리케이션을 실행합니다.\n- 출력 업로드는 이후 summarise-and-notify 단계에서 사용할 비용 보고서 출력을 아티팩트로 저장합니다.\n\nsummarise-and-notify 작업은 모든 run-azure-cost-cli 및 run-aws-costs-cli 작업이 완료된 후에만 실행되며, summary 및 slack 알림을 위해 작동합니다:\n\n```js\nsummarise-and-notify:\n    runs-on: ubuntu-latest\n    needs: [run-azure-cost-cli, run-aws-costs-cli]\n    env:\n      SUBSCRIPTIONS: ${needs.run-aws-costs-cli.outputs.subscriptions}\n      SLACK_CHANNEL_WEBHOOK: ${secrets.SLACK_CHANNEL_WEBHOOK}\n      TRIGGER_MESSAGE_DAY: ${vars.TRIGGER_MESSAGE_DAY}\n      NOTION_AWS_PAGE_URL: ${vars.NOTION_AWS_PAGE_URL}\n      NOTION_AZURE_PAGE_URL: ${vars.NOTION_AZURE_PAGE_URL}\n      NOTION_TOKEN: ${secrets.NOTION_TOKEN}\n      NOTION_COST_SUMMARY_PAGE: ${vars.NOTION_COST_SUMMARY_PAGE}\n    steps:\n      - uses: actions/checkout@v4\n      - name: Setup Go 1.21.x\n        uses: actions/setup-go@v5\n        with:\n          go-version: 1.21.x\n      - name: Install go dependencies\n        run: go get ./...\n      - name: \"Download matrix outputs\"\n        uses: actions/download-artifact@v4\n        with:\n          path: artifact\n          pattern: artifact-*\n          merge-multiple: true\n      - name: \"Notify to slack\"\n        run: |\n          go run ./cmd/slack-cost-summary\n```\n\n마지막으로 실패한 작업을 자동으로 다시 시도할 수 있도록 re-run-azure-cost-cli 작업이 추가되었습니다. 병렬 작업을 실행하지 않더라도 때로는 azure API가 실패할 수 있습니다. 따라서 임시적인 azure API 실패를 제거하는 데 충분한 5번의 시도로 실패한 작업을 다시 시도하는 메커니즘을 추가했습니다:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n재실행-azure-cost-cli:\n    이름: 실패한 작업 다시 실행하는 워크플로우 호출\n    needs: run-azure-cost-cli\n    if: failure() && fromJSON(github.run_attempt) < 5\n    runs-on: ubuntu-latest\n    steps:\n      - env:\n          GH_REPO: ${ github.repository }\n          GH_TOKEN: ${ github.token }\n          GH_DEBUG: api\n        run: gh workflow run rerun.yml -F run_id=${ github.run_id }\n\n\n\n이름: 실패한 작업 다시 실행하는 워크플로우\n\npermissions:\n  actions: write\n\non:\n  workflow_dispatch:\n    inputs:\n      run_id:\n        required: true\njobs:\n  rerun:\n    runs-on: ubuntu-latest\n    steps:\n      - name: ${ inputs.run_id } 다시 실행\n        env:\n          GH_REPO: ${ github.repository }\n          GH_TOKEN: ${ github.token }\n          GH_DEBUG: api\n        run: |\n          gh run watch ${ inputs.run_id } > /dev/null 2>&1\n          gh run rerun ${ inputs.run_id } --failed\n","ogImage":{"url":"/assets/img/2024-06-27-BuildingaCloudCostSummaryTool_0.png"},"coverImage":"/assets/img/2024-06-27-BuildingaCloudCostSummaryTool_0.png","tag":["Tech"],"readingTime":18},{"title":"뷰로 퀸 게임 재현하는 방법","description":"","date":"2024-06-27 19:27","slug":"2024-06-27-RecreatingQueensGameinVue","content":"\n\n<img src=\"/assets/img/2024-06-27-RecreatingQueensGameinVue_0.png\" />\n\n최근에 매일 도전하다 보니 Queens라는 게임에 중독되었어요. 링크드인에서 소개된 게임인데 Vue를 사용하여 이 게임의 클론을 구현하는 것은 정말 즐거운 도전이었고 게임을 더 잘 이해하는 데 도움이 되었어요.\n\n# 게임\n\nQueens는 Minesweeper와 Sudoku 요소를 결합한 퍼즐 게임이에요. 8x8 그리드에서 플레이되며, 규칙에 따라 보드 위에 여덟 개의 퀸을 위치시키는 것이 목표예요:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 한 행에 한 퀸\n- 한 열에 한 퀸\n- 한 색 영역에 한 퀸\n- 대각선으로 연속적으로 위치한 셀에 두 개의 퀸을 놓을 수 없음\n\n이 모든 조건을 동시에 만족시키는 것이 과제입니다.\n\n![이미지](/assets/img/2024-06-27-RecreatingQueensGameinVue_1.png)\n\n## 초기 상태 모델링 - 첫 번째 시도\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n제 첫 번째 접근 방식은 초기 보드를 무작위로 생성하는 것이었는데, 이렇게 하면 게임이 너무 쉽다는 것을 깨달았어요. 진정한 도전은 답이 하나뿐인 보드에서 온다고 생각해요. LinkedIn 및 다른 솔루션을 역공학한 후에 그들이 매번 미리 정의된 초기 보드를 사용한다는 것을 깨달았어요.\n\n## 초기 상태 모델링 - 두 번째 시도\n\n더 적합한 방법은 각 셀의 내용이 색상인 2차원 배열을 사용하는 것이에요.\n\n먼저, 각 숫자에 색상을 연결하는 맵을 갖게 될 거에요.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\ncellColors의 속성을 다음과 같이 변경하고\n\nexport const cellColors = {\n    1: \"#007B6C\",\n    2: \"#D18B00\",\n    3: \"#C75D00\",\n    4: \"#0044CC\",\n    5: \"#CC0000\",\n    6: \"#CCCC00\",\n    7: \"#008B8B\",\n    8: \"#8B008B\",\n  };\n\n그런 다음 초기 상태를 나타내는 2 차원 배열을 생성합니다.\n\nconst sectionGrid = [\n  [1, 1, 2, 2, 2, 3, 3, 3],\n  [1, 1, 2, 2, 2, 3, 3, 3],\n  [4, 1, 2, 2, 2, 3, 3, 3],\n  [4, 1, 5, 5, 5, 5, 3, 3],\n  [4, 1, 5, 5, 5, 5, 6, 6],\n  [4, 5, 5, 7, 7, 6, 6, 6],\n  [4, 8, 7, 7, 7, 6, 6, 6],\n  [8, 8, 8, 7, 7, 6, 6, 6]\n];\n\n그리고 나서 다음 이미지를 참고하세요. <img src=\"/assets/img/2024-06-27-RecreatingQueensGameinVue_2.png\" />\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리는 이제 초기 상태를 나타내는 것을 가지고 게임 보드를 시작할 수 있어요.\n\n## 게임 보드\n\n보드를 만들기 전에 각 셀에 대한 작은 구성 요소를 만들어 봅시다.\n\n```js\n<!-- GridCell.vue -->\n<script setup>\ndefineProps([\"content\", \"color\"]);\n</script>\n\n<template>\n  <div class=\"cell\" :style=\"{ backgroundColor: color }\">\n    <img v-if=\"content === 'queen'\" src=\"@/assets/crown.png\" class=\"queen\" />\n    <span v-if=\"content === 'marked'\">×</span>\n  </div>\n</template>\n\n<style scoped>\n.cell {\n  font-size: 24px;\n  border: 1px solid #000;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  cursor: pointer;\n  user-select: none;\n}\n\n.queen {\n  width: 24px;\n  height: 24px;\n}\n</style>\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 프레젠테이션 컴포넌트는 두 가지 매개변수를 받습니다. 셀 내용은 퀸, X 표시 또는 빈 경우에는 null이 될 수 있습니다. 또한 셀의 색상을 받습니다.\n\n이제 게임 보드를 만들려면 GridCell 컴포넌트 주위에 두 개의 중첩된 루프가 필요합니다. 게임이 종료되고 WinMessage 컴포넌트가 표시될 때 그리고 보드를 지우는 버튼이 있을 때입니다.\n\n대부분의 복잡성은 나중에 처리할 createGame 컴포저블 내부에 추상화되어 있습니다.\n\n이 보드는 정렬을 위해 CSS 그리드를 사용합니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n<!-- GameBoard.vue -->\n<script setup>\nimport GridCell from \"@/features/game/components/GridCell.vue\";\nimport { createGame } from \"@/features/game/composables/createGame\";\nimport WinMessage from \"@/features/game/components/WinMessage.vue\";\nimport AppButton from \"@/components/AppButton.vue\";\nimport { cellColors } from \"@/features/game/data/cellColors.js\";\n\nconst {\n  boardState,\n  gameWon,\n  isValidQueen,\n  toggleCell,\n  clearBoard,\n} = createGame();\n</script>\n\n<template>\n  <div class=\"game-board\">\n    <template v-for=\"(row, rowIndex) in boardState\">\n      <GridCell\n        v-for=\"(cell, cellIndex) in row\"\n        :key=\"`${rowIndex}-${cellIndex}`\"\n        :content=\"cell.content\"\n        :color=\"cellColors[cell.section]\"\n        :invalid=\"isValidQueen(rowIndex, cellIndex)\"\n        @click=\"toggleCell(rowIndex, cellIndex)\"\n      />\n    </template>\n  </div>\n  <WinMessage v-if=\"gameWon\" />\n  <AppButton @click=\"clearBoard\">Clear Board</AppButton>\n</template>\n\n<style scoped>\n.game-board {\n  display: grid;\n  justify-content: center;\n  grid-template-columns: repeat(8, 42px);\n  grid-template-rows: repeat(8, 42px);\n  border: 1px solid #000;\n}\n</style>\n``` \n\n다음으로 createGame 컴포저블을 다루어 봅시다.\n\n먼저, 각 셀의 상태를 저장할 방법이 필요합니다. 이를 위해 board와 동일한 구조인 boardState라는 새 변수를 만들 것입니다. 또한 가능한 값으로 [Null, marked, or queen]을 갖는 content 속성을 추가할 것입니다.\n\n또한, 보드 상의 모든 퀸의 좌표를 추적할 수 있는 배열이 필요합니다. 이는 퀸이 유효한지 확인하기 위해 모든 셀을 검색할 필요 없이 작은 최적화입니다.\n\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\ntoggleCell 함수는 별도의 배열에서 퀸을 추적하는 기능을 추가하여 셀의 세 가지 가능한 상태를 회전합니다. 각 변경 후에 보드가 다시 유효성을 검사합니다. 현재 유효성 검사 코드는 생략되었습니다.\n\nclearBoard 함수는 boardState와 퀸을 재설정합니다.\n\nisValidQueen 함수는 셀의 좌표를 인수로 받아 유효한 퀸이 있는지 여부를 반환합니다.\n\n마지막으로 게임이 종료되었는지 확인하려면 해당 배열 내의 유효한 퀸 수를 세면 됩니다. 이것은 계산된 값이어야 합니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n// composables/createGame.js\nimport { ref, computed } from 'vue'\nimport { sectionGrid } from '@/features/game/data/sectionGrid'\n\nfunction createBoard() {\n  return sectionGrid.map((row) =>\n    row.map((section) => ({\n      content: null,\n      section\n    }))\n  )\n}\n\nexport function createGame() {\n  const boardState = ref(createBoard())\n  const queens = ref([])\n\n  function toggleCell(rowIndex, cellIndex) {\n    const cell = boardState.value[rowIndex][cellIndex];\n  \n    if (!cell.content) {\n      cell.content = 'marked';\n    } else if (cell.content === 'marked') {\n      cell.content = 'queen';\n      queens.value.push({ row: rowIndex, col: cellIndex, valid: true });\n    } else {\n      cell.content = null;\n      queens.value = queens.value.filter(\n        (queen) => queen.row !== rowIndex || queen.col !== cellIndex\n      );\n    }\n  \n    validateBoard();\n  }\n\n  function validateBoard() {\n    // TODO\n  }\n\n  function clearBoard() {\n    boardState.value = boardState.value.map((row) =>\n      row.map((cell) => ({ ...cell, content: null }))\n    )\n    queens.value = []\n  }\n\n  function isValidQueen(rowIndex, cellIndex) {\n    return queens.value.some(\n      (queen) => queen.row === rowIndex && queen.col === cellIndex && !queen.valid\n    )\n  }\n\n  const gameWon = computed(() => {\n    if (queens.value.length !== sectionGrid.length) {\n      return false\n    }\n\n    return queens.value.every((queen) => queen.valid)\n  })\n\n  return {\n    boardState,\n    toggleCell,\n    queens,\n    isValidQueen,\n    clearBoard,\n    gameWon\n  }\n}\n```\n\n## Validations\n\n이제 애플리케이션의 가장 복잡한 측면인 유효성 검사를 구현해 보겠습니다. 각 변경 사항 후에는 승리 조건이 위배되었는지 확인하고 해당 퀸을 무효로 표시해야 합니다. validateRow, validateColumn, validateSection 및 checkDiagonalConflicts와 같이 네 가지 다른 함수가 있습니다. 각 함수는 게임 규제 중 하나를 확인하는 역할을 합니다.\n\n예를 들어 validateRow 함수는 같은 행에 두 개의 퀸이 존재하지 않도록하고 그렇다면 두 퀸을 모두 무효로 표시합니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n// composables/createGame.js\n// ...\n\nfunction validateBoard() {\n  resetValidations()\n\n  for (const queen of queens.value) {\n    const { row, col } = queen\n    const cell = boardState.value[row][col]\n    const rowValid = validateRow(row)\n    const columnValid = validateColumn(col)\n    const sectionValid = validateSection(cell.section)\n    const diagonalValid = checkDiagonalConflicts(queen)\n\n    queen.valid = rowValid && columnValid && sectionValid && diagonalValid\n  }\n}\n\nfunction resetValidations() {\n  queens.value.forEach((queen) => (queen.valid = true))\n}\n\nfunction validateRow(rowIndex) {\n  const queensInRow = queens.value.filter((queen) => queen.row === rowIndex)\n\n  if (queensInRow.length > 1) {\n    queensInRow.forEach((queen) => (queen.valid = false))\n    return false\n  }\n  return true\n}\n\nfunction validateColumn(columnIndex) {\n  // TODO\n}\n\nfunction validateSection(section) {\n  // TODO\n}\nfunction checkDiagonalConflicts(queen) {\n  // TODO\n}\n```\n\n## 타이머\n\n애플리케이션의 또 다른 기능은 각 게임판의 완료까지 걸린 시간을 추적하는 것입니다. 경과된 시간을 보여주는 작은 프레젠테이션 컴포넌트를 만들 것입니다.\n\n```js\n<!-- AppTimer.vue -->\n<template>\n  <div class=\"timer\">⏱ 시간: { formattedTime }</div>\n</template>\n\n<script setup>\nimport { useTimer } from \"../composables/useTimer\";\n\nconst { formattedTime } = useTimer();\n</script>\n\n<style scoped>\n.timer {\n  font-size: 13px;\n  margin: 10px 0;\n}\n</style>\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n한 번 더 composable이 사용되어 상태를 관리합니다. 타이머를 시작, 중지 및 재설정할 수 있는 기능을 노출합니다.\n\n```js\nimport { ref, computed } from 'vue'\n\nconst time = ref(0)\n\nexport function useTimer() {\n  let timerInterval = null\n\n  const startTimer = () => {\n    if (timerInterval) return\n    timerInterval = setInterval(() => {\n      time.value++\n    }, 1000)\n  }\n\n  const stopTimer = () => {\n    clearInterval(timerInterval)\n    timerInterval = null\n  }\n\n  const resetTimer = () => {\n    time.value = 0\n  }\n\n  const formattedTime = computed(() => {\n    const minutes = Math.floor(time.value / 60)\n    const seconds = time.value % 60\n    return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`\n  })\n\n  return {\n    time,\n    formattedTime,\n    startTimer,\n    stopTimer,\n    resetTimer\n  }\n}\n```\n\n게임 보드 컴포넌트를 이 타이머를 사용하도록 업데이트해야 합니다. 최종 구현은 다음과 같습니다.\n\n컴포넌트가 마운트될 때 타이머를 시작하고, 게임이 이겼을 때 중지합니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n<script setup>에서 <script>태그를 Markdown 형식으로 바꿔보세요.\n\n이 최종 결과물은 퀸의 게임의 기능적인 클론입니다. 여기에서 확인할 수 있어요.\n\n<img src=\"/assets/img/2024-06-27-RecreatingQueensGameinVue_3.png\" />\n\n## 결론\n\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여기 있습니다! Vue와 같은 반응형 프런트엔드 프레임워크는 대부분의 중요한 작업을 처리하여 상태를 동기화하는 데 도움이 되지만 여전히 대부분의 로직을 직접 구현해야 합니다. 이 기사에서 가치를 찾았고 Vue를 사용하여 이와 같은 게임을 만드는 방법에 대해 더 잘 이해할 수 있기를 바랍니다.\n\n다음 단계는 여러 수준, 힌트 및 일일 도전 과제를 구현하는 것입니다. 이를 향한 다음 기사에서 그것을 할 것입니다. 반드시 구독하세요!\n\n게임을 플레이하거나 GitHub에서 코드베이스를 살펴볼 수 있습니다.\n\n![게임 이미지](/assets/img/2024-06-27-RecreatingQueensGameinVue_4.png)","ogImage":{"url":"/assets/img/2024-06-27-RecreatingQueensGameinVue_0.png"},"coverImage":"/assets/img/2024-06-27-RecreatingQueensGameinVue_0.png","tag":["Tech"],"readingTime":12}],"page":"9","totalPageCount":120,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true}