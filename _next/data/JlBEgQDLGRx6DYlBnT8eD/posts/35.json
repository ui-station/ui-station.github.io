{"pageProps":{"posts":[{"title":"Rails 성능 향상을 위한 7가지 옵션","description":"","date":"2024-06-22 22:21","slug":"2024-06-22-OptionsforbetterperformanceinRails","content":"\n# 소개: 동기부여\n\n소프트웨어 엔지니어링에서 효율성은 빠른 실행만이 아니라 리소스를 최대화하고 사용자 경험을 향상하는 해결책을 개발하는 것을 의미합니다. 우아함으로 유명한 Ruby에서는 메소드의 선택이 성능에 깊은 영향을 미칠 수 있습니다. 이 글은 일반적인 Ruby 및 Rails 메소드를 비교하여 메모리와 실행 시간 측면에서 어떤 것이 비교적 더 나은 성능을 제공하는지 살펴봅니다.\n\n![이미지](/assets/img/2024-06-22-OptionsforbetterperformanceinRails_0.png)\n\n# exists? vs present? vs any?:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nActiveRecord에서 present? 또는 any?과 같은 메서드를 사용하면 레코드를 메모리로 로드하여 일치하는 레코드가 있는지 확인할 수 있습니다. 이는 특히 대규모 데이터셋의 경우 비효율적일 수 있습니다.\n\n```js\nUser.where(email: 'example@gmail.com').present?\nUser.where(email: 'example@gmail.com').any?\n```\n\nexists?의 효율성: exists? 메서드는 데이터를로드하지 않고 레코드의 존재 여부 만을 확인하도록 최적화되어 있어 훨씬 더 빠릅니다.\n\n```js\nUser.where(email: 'example@gmail.com').exists?\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# update_all 대 update\n\n업데이트의 오버헤드: 개별 레코드에 대해 업데이트 메서드를 사용하면 여러 개의 데이터베이스 쿼리가 발생합니다.\n\n```js\nusers.each { |user| user.update(active: true) }\n```\n\nupdate_all의 효율성: update_all 메서드는 조건과 일치하는 모든 레코드를 업데이트하는 데 단일 쿼리를 수행하여 성능을 크게 향상시킵니다. 단, 여기에 주의해야 할 점은 해당 열이 인덱싱되어 있는지 확인하기 위해 신중히 WHERE 절을 사용하여 넓은 범위를 설정해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nUser.where(active: false).update_all(active: true)\n```\n\n# includes vs joins vs preload\n\n## Eager Loading Associations\n\n- N+1 쿼리 문제: 조인을 사용하면 각 관련 레코드가 개별적으로 쿼리될 수 있는 N+1 쿼리 문제가 발생할 수 있습니다.\n- User.joins(:posts)는 여기서 posts 테이블을 로드하지 않습니다. 포스트를 가진 사용자만을로드합니다. 포스트는 .each를 수행하고 사용자의 포스트를 가져올 때 로드됩니다. 데이터베이스에 다시 쿼리를 실행하게 됩니다. 이것이 고전적인 n +1 쿼리 문제입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n# 비효율적\nUser.joins(:posts).each { |user| user.posts.each { |post| puts post.title } }\n```\n\ninclude의 효율성: include 메서드는 관련 레코드를 최소한의 쿼리로 가져오는 것을 목적으로한다. include는 데이터를 가져오기 위해 preload와 eager_load 두 가지 방법을 사용합니다. preload는 기본 테이블과 연관 테이블을 가져오기 위해 두 개의 쿼리가 시작됩니다. eager_load는 왼쪽 조인을 사용하여 기본 및 보조 테이블 모두를 하나의 쿼리로 가져옵니다.\n\n```js\n# 효율적\nUser.includes(:posts).each { |user| user.posts.each { |post| puts post.title } }\n```\n\n# count vs size vs length\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 레코드 개수 세기\n\n- 길이의 오버헤드: 길이를 사용하는 것은 모든 레코드를 메모리로 로드하기 때문에 비효율적일 수 있습니다.\n\n```js\n# 비효율적\nUser.all.length\n```\n\n카운트의 효율성: count 메서드는 SELECT COUNT(\\*) 쿼리를 수행하여 대규모 데이터셋에 효율적입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nUser.count;\n```\n\n# find vs find_each:\n\n수천 개의 레코드를 처리할 때, find를 사용하면 처리를 시작하기 전에 모든 레코드를 로드해야하기 때문에 지나칠 정도로 비효율적입니다. 한 번에 10,000개의 레코드를 처리하는 경우 find를 사용할 때 약 500ms가 소요되고 많은 메모리가 사용되어 효율성이 떨어지는 것을 명확히 나타냅니다.\n\n```js\nUser.find(1..10000).each do |user|\n  # 일부 처리 작업\nend\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# find_each\n\n`find_each`은 내가 배고플 때 삼키는 만큼만 씹겠다고 하는 것과 비슷해요.\n\n```ruby\nUser.find_each(batch_size: 1000) do |user|\n  # 어떤 처리\nend\n```\n\n- 메모리 사용량: 감소\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# select vs pluck\n\n# Using select\n\n이 문은 사용자 테이블에서 특정 열 (id, name, email)을 선택하고 ActiveRecord 객체로로드합니다. 그런 다음 each 블록이 이러한 객체를 반복 처리합니다. 특히 그 객체 각각에서 무언가를 확인하려는 경우에 유용합니다.\n\n```js\nUser.select(:id, :name, :email).each { |user| ... }\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# pluck 사용하기\n\n이 문은 데이터베이스에서 지정된 열만 직접 검색합니다. 반환값은 값 배열(또는 다수의 열을 pluck하는 경우 값 배열의 배열)이며, Active Record 객체가 아닙니다. 이는 메모리에 덜 영향을 미칩니다. 다만, 결과는 active record 테이블에 대해 아무것도 모르는 값 배열일 뿐입니다.\n\n```js\nUser.pluck(:id, :name, :email)\n```\n\n# where vs find_by:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## where를 사용하기\n\nwhere는 Rails에서 강력한 쿼리 메서드로, 여러 레코드를 반환할 수 있습니다. 여러 결과를 처리해야 하는 애플리케이션 로직에서 이상적입니다. where로 여러 레코드를 가져 올 때, where 절에 전달된 필드가 인덱싱되어 있지 않은 경우 전체 테이블 스캔을 수행합니다. 인덱스를 사용하면 검색 범위가 제한되어 index scan을 수행합니다. 일부 상황에서는 이 메서드를 사용해야 할 수도 있지만, 최종적으로 .first를 수행한다면 이상적인 방법이 아닙니다.\n\n```js\nUser.where(name: 'John').first\n```\n\nfind_by 사용하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n특정 기준과 일치하는 첫 번째 레코드만 필요할 때는 find_by를 사용하는 것이 더 빠릅니다. 일치하는 항목을 찾자마자 쿼리가 중단되어 시간과 자원을 절약합니다. 필터 열이 인덱싱되어 있는 경우 런타임이 더 향상됩니다.\n\n```js\nUser.find_by(name: 'John')\n```\n\n# delete_all vs destroy_all\n\n# delete_all\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\ndelete_all은 데이터베이스에 직접 레코드를 로드하지 않고 빠른 삭제를 위한 메서드입니다. 빠르지만 콜백을 건너뜁니다. 빠르지만 결정적이며 콜백이 없습니다. 콜백을 실행하지 않으면 외래 키 참조가 있는 레코드에서 오류가 발생할 수 있습니다.\n\n```js\nUser.where(active: false).delete_all\n```\n\ndestroy_all\n\n콜백을 실행하면서 레코드를 삭제하려면 destroy_all이 필요합니다. 데이터 무결성을 유지하지만 성능에 비용이 발생합니다. 더 많은 시간이 소요되지만 체계적이며 필요한 콜백을 실행합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nUser.where(active: false).destroy_all\n```\n\n이 글이 도움이 되었으면 좋겠어요.\n\n즐거운 코딩하세요!\n","ogImage":{"url":"/assets/img/2024-06-22-OptionsforbetterperformanceinRails_0.png"},"coverImage":"/assets/img/2024-06-22-OptionsforbetterperformanceinRails_0.png","tag":["Tech"],"readingTime":8},{"title":"RootBeer 루트 감지 우회 방법  irsyadsec","description":"","date":"2024-06-22 22:20","slug":"2024-06-22-RootBeerRootDetectionBypassirsyadsec","content":"\n![RootBeer](/assets/img/2024-06-22-RootBeerRootDetectionBypassirsyadsec_0.png)\n\n몇 달 전에 어떤 애플리케이션의 침투 테스트를 진행했는데, 해당 애플리케이션이 루팅된 기기를 감지하기 위해 사용되는 RootBeer 라이브러리로 보호되어 있음을 발견했습니다. 이 기사에서는 RootBeer 라이브러리를 우회하는 방법을 보여드리겠습니다. 이때 사용할 것은 샘플 RootBeer 애플리케이션입니다.\n\n시작하기 전에, 이미 Frida Server 및 ADB 사용에 익숙하다고 가정합니다.\n\n# RootBeer 라이브러리 우회 단계별 안내\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 1. 환경 설정\n\n아래 도구들이 설치되어 있는지 확인해주세요:\n\n- ADB (Android Debug Bridge): 안드로이드 장치와 통신하는 데 사용됩니다.\n- Frida Server: 개발자, 역공학자 및 보안 연구자를 위한 동적 인스트루먼테이션 툴킷입니다.\n- 에뮬레이터: 이 경우, ldplayer를 사용하고 있습니다.\n\n## 2. 장치 준비\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nFrida 릴리스 페이지에서 기기 아키텍처에 맞는 적절한 Frida Server 이진 파일을 다운로드하세요.\n\n에뮬레이터에 연결하세요\n\n```js\nadb devices -l\n```\n\n<img src=\"/assets/img/2024-06-22-RootBeerRootDetectionBypassirsyadsec_1.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nadb root\n```\n\n<img src=\"/assets/img/2024-06-22-RootBeerRootDetectionBypassirsyadsec_2.png\" />\n\nADB를 사용하여 바이너리를 장치로 푸시합니다:\n\n```js\nadb push frida-server-16.0.10-android-x86_64 /data/local/tmp\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n파일에 대한 권한을 주십시오.\n\n```js\nadb shell\ncd /data/local/tmp\nchmod +x frida-server-16.0.10-android-x86_64\n```\n\n![이미지](/assets/img/2024-06-22-RootBeerRootDetectionBypassirsyadsec_3.png)\n\n프리다 서버를 시작하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n./frida-server-16.0.10-android-x86_64 -D\n```\n\n![Root Detection Bypass](/assets/img/2024-06-22-RootBeerRootDetectionBypassirsyadsec_4.png)\n\n## 3. 루트 우회\n\n여기서는 GitHub에서 이미 사용 가능한 exploit 파일을 사용하여 가장 빠른 방법을 사용할 것입니다. Pich4ya의 exploit을 사용하고 있으며, 해당 사이트에서 다운로드할 수 있습니다. 그에게 큰 박수를 보내요👏👏👏👏\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이미지 태그를 Markdown 형식으로 변경하세요.\n\n![이미지](/assets/img/2024-06-22-RootBeerRootDetectionBypassirsyadsec_5.png)\n\n파일을 다운로드한 후 저장한 폴더로 이동하여 명령 프롬프트를 엽니다.\n\n애플리케이션 패키지 이름을 찾습니다.\n\n```js\nfrida - ps - Uai;\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-06-22-RootBeerRootDetectionBypassirsyadsec_6.png\" />\n\nRootbeer 샘플 애플리케이션을 사용 중이기 때문에 패키지 이름은 com.scottyab.rootbeer.sample 입니다.\n\n그 다음에 다음 명령어를 실행하세요\n\n```js\nfrida -l root.js -U -f com.example.app --pause\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n엔터를 누른 후 다시 타이핑하세요\n\n```js\n%이력서\n```\n\n![이미지](/assets/img/2024-06-22-RootBeerRootDetectionBypassirsyadsec_7.png)\n\n그리고 Voilaaaa 당신의 apk가 이미 우회됐어야 합니다\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<표>를 마크다운 형식으로 변경해보세요.\n\n그리고 와! APK가 바이패스되어야 합니다.\n\n![이미지](/assets/img/2024-06-22-RootBeerRootDetectionBypassirsyadsec_8.png)\n\n이렇게 도움이 되는 기사들을 더 보시고 싶으세요? 귀하의 지원이 저에게 가치 있는 콘텐츠를 만들 수 있게 합니다. 더 많은 무료 프롬프트를 만들기 위해 커피 한 잔 사주시겠어요? 귀하의 기부에 감사드립니다! ❤️❤️❤️\n","ogImage":{"url":"/assets/img/2024-06-22-RootBeerRootDetectionBypassirsyadsec_0.png"},"coverImage":"/assets/img/2024-06-22-RootBeerRootDetectionBypassirsyadsec_0.png","tag":["Tech"],"readingTime":5},{"title":"Spring Boot로 API 게이트웨이 구현하는 방법","description":"","date":"2024-06-22 22:18","slug":"2024-06-22-APIgatewayinSpringboot","content":"\n![API Gateway](/assets/img/2024-06-22-APIgatewayinSpringboot_0.png)\n\nAPI는 응용 프로그램 간에 일반적인 통신 방식입니다. 마이크로서비스 아키텍처의 경우 여러 서비스가 있으며 클라이언트는 이러한 서비스를 호출하기 위해 모든 하위 응용 프로그램의 호스트 이름을 알아야 합니다.\n\n이 통신을 간소화하기 위해 클라이언트와 서버 사이에 모든 API 요청을 관리하는 컴포넌트인 API 게이트웨이를 선호합니다. 또한 다음과 같은 다른 기능을 가질 수 있습니다:\n\n- 보안 — 인증, 권한 부여\n- 라우팅 — 라우팅, 요청/응답 조작, 회로 차단기\n- 관찰성 — 지표 집계, 로깅, 추적화\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nAPI 게이트웨이의 아키텍처적 이점:\n\n- 복잡성 감소\n- 정책의 중앙 집중화된 제어\n- 단순화된 문제 해결\n\nAPI 게이트웨이에는 Spring Cloud Gateway, Zuul API Gateway, APIGee, EAG (Enterprise API Gateway)와 같은 다양한 구현 유형이 있습니다.\n\n본 문서에서는 Spring Cloud API 게이트웨이를 구현하는 방법, 들어오는 요청 필터링, 요청/응답 조작, 인증 처리에 대해 살펴볼 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래에서 전체 에코시스템을 시각화할 수 있습니다:\n\n![에코시스템 다이어그램](/assets/img/2024-06-22-APIgatewayinSpringboot_1.png)\n\n위 다이어그램에서 총 5개의 서비스가 있습니다.\n\n- 서비스 레지스트리 — 각 프로젝트 내의 각 마이크로서비스 인스턴스의 가용 상태를 추적하는 응용 프로그램입니다.\n- API 게이트웨이 — 들어오는 요청을 수신하고 인증(활성화되어 있다면)을 수행하고 실제 마이크로서비스로 요청을 전달합니다. 응답을 받으면 소비자에게 반환합니다.\n- 인증 서버 — 인증을 처리하는 응용 프로그램입니다.\n- 첫 번째와 두 번째 마이크로서비스 — 서로 다른 기능을 갖는 두 개의 일반 내부 응용 프로그램입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n모든 애플리케이션은 시작 시 서비스 레지스트리에 등록됩니다. API 요청을 받으면 다음과 같은 단계가 발생합니다:\n\n- 소비자가 API 게이트웨이를 통해 애플리케이션을 호출합니다.\n- API 게이트웨이는 수신 URL이 인증이 필요한지 확인합니다. 필요하다면 인증 서버를 호출하여 유효성을 검사합니다.\n- 유효한 토큰이라면 필터를 적용한 후 해당 애플리케이션으로 요청을 전달합니다.\n- 유효하지 않은 토큰일 경우 소비자에게 권한이 없음을 응답합니다.\n- 내부 마이크로서비스에서 응답을 받으면 필터를 적용한 후 해당 소비자에게 반환합니다.\n\n게이트웨이에서의 필터는 로깅, 요청/응답 세부 사항 조작/사용자 정의와 같은 작업이 포함될 수 있습니다.\n\nService registry\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n유레카 서버로 작동하는 애플리케이션이에요. pom.xml에 다음 종속성이 있어야 해요.\n\n```js\n<dependency>\n  <groupId>org.springframework.cloud</groupId>\n  <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>\n</dependency>\n```\n\n그리고 메인 클래스에 `@EnableEurekaServer` 어노테이션이 있어야 해요.\n\n기본적으로 유레카 서버는 자신을 디스커버리에 등록하는데, 이를 비활성화하기 위해 application.properties에 아래 속성을 포함해야 해요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\neureka.client.registerWithEureka = false;\neureka.client.fetchRegistry = false;\n```\n\n다른 애플리케이션을 Eureka 클라이언트로 만들려면 pom.xml에 아래 종속성을 포함하세요:\n\n```js\n<dependency>\n  <groupId>org.springframework.cloud</groupId>\n  <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n</dependency>\n```\n\n그리고, application.properties 파일에 Eureka 서버 URL을 제공해주세요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\neureka.client.serviceUrl.defaultZone= <eureka-서버-가동-호스트-및-포트>\n\nAPI 게이트웨이:\n\nSpring Cloud API 게이트웨이에는 pom.xml에 아래 종속성이 필요합니다.\n\n```xml\n<dependencies>\n  <dependency>\n   <groupId>org.springframework.cloud</groupId>\n   <artifactId>spring-cloud-starter-gateway</artifactId>\n  </dependency>\n</dependencies>\n <dependencyManagement>\n  <dependencies>\n   <dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-dependencies</artifactId>\n    <version>${spring-cloud.version}</version>\n    <type>pom</type>\n    <scope>import</scope>\n   </dependency>\n  </dependencies>\n </dependencyManagement>\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\napplication.yml 파일에서 모든 내부 마이크로서비스 이름, 경로 및 uri 세부 정보를 다음과 같이 제공해주세요:\n\n```js\nspring:\n  application:\n    name: gateway-service\n  cloud:\n    gateway:\n      routes:\n        - id: first\n          predicates:\n            - Path=/first/\n          uri: localhost:8081\n        - id: second\n          predicates:\n            - Path=/second/\n          uri: localhost:8082\n        - id: auth-server\n          predicates:\n            - Path=/login/\n          uri: localhost:8088\n```\n\n그리고 Gateway가 제공하는 모든 라우트를 제공하기 위해 RouteLocator 유형의 빈이 필요합니다. 요청/응답을 처리하려면 필요에 따라 필터를 포함할 수 있습니다:\n\n```js\n@Bean\npublic RouteLocator customRouteLocator(RouteLocatorBuilder builder) {\n    return builder.routes()\n            .route(\"first-microservice\", r -> r.path(\"/first\")\n                    .and().method(\"POST\")\n                    .and().readBody(Student.class, s -> true).filters(f -> f.filters(requestFilter, authFilter))\n                    .uri(\"http://localhost:8081\"))\n            .route(\"first-microservice\", r -> r.path(\"/first\")\n                    .and().method(\"GET\").filters(f-> f.filters(authFilter))\n                    .uri(\"http://localhost:8081\"))\n            .route(\"second-microservice\", r -> r.path(\"/second\")\n                    .and().method(\"POST\")\n                    .and().readBody(Company.class, s -> true).filters(f -> f.filters(requestFilter, authFilter))\n                    .uri(\"http://localhost:8082\"))\n            .route(\"second-microservice\", r -> r.path(\"/second\")\n                    .and().method(\"GET\").filters(f-> f.filters(authFilter))\n                    .uri(\"http://localhost:8082\"))\n            .route(\"auth-server\", r -> r.path(\"/login\")\n                    .uri(\"http://localhost:8088\"))\n            .build();\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n필터:\n\nA. 요청 본문을 로깅하려면:\n\n본문을 읽기 위해 ResourceLocator 빈에서 readBody()를 true로 설정해야 합니다. 이렇게 하면 ServerWebExchange 객체가 요청 본문을 \"cachedRequestBodyObject\" 속성에 캐시합니다.\n\n```js\npackage com.example.springcloudgatewayoverview.filter;\n\nimport com.example.springcloudgatewayoverview.model.Company;\nimport com.example.springcloudgatewayoverview.model.Student;\nimport org.springframework.cloud.gateway.filter.GatewayFilter;\nimport org.springframework.cloud.gateway.filter.GatewayFilterChain;\nimport org.springframework.stereotype.Component;\nimport org.springframework.web.server.ServerWebExchange;\nimport reactor.core.publisher.Mono;\n\n@Component\npublic class RequestFilter implements GatewayFilter {\n    @Override\n    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {\n        Object body = exchange.getAttribute(\"cachedRequestBodyObject\");\n        System.out.println(\"in request filter\");\n        if(body instanceof Student) {\n            System.out.println(\"body:\" + (Student) body);\n        }\n        else if(body instanceof Company) {\n            System.out.println(\"body:\" + (Company) body);\n        }\n        return chain.filter(exchange);\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nB. 응답 본문을 로깅하려면:\n\n```js\npackage com.example.springcloudgatewayoverview.filter;\n\nimport com.example.springcloudgatewayoverview.model.Company;\nimport com.example.springcloudgatewayoverview.model.Student;\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport org.reactivestreams.Publisher;\nimport org.springframework.core.io.buffer.DataBuffer;\nimport org.springframework.core.io.buffer.DataBufferFactory;\nimport org.springframework.core.io.buffer.DefaultDataBuffer;\nimport org.springframework.core.io.buffer.DefaultDataBufferFactory;\nimport org.springframework.http.server.reactive.ServerHttpRequest;\nimport org.springframework.http.server.reactive.ServerHttpResponse;\nimport org.springframework.http.server.reactive.ServerHttpResponseDecorator;\nimport org.springframework.web.server.ServerWebExchange;\nimport org.springframework.web.server.WebFilter;\nimport org.springframework.web.server.WebFilterChain;\nimport reactor.core.publisher.Flux;\nimport reactor.core.publisher.Mono;\n\nimport java.nio.charset.StandardCharsets;\nimport java.util.List;\n\npublic class PostGlobalFilter implements WebFilter {\n\n    @Override\n    public Mono<Void> filter(ServerWebExchange exchange, WebFilterChain chain) {\n        String path = exchange.getRequest().getPath().toString();\n        ServerHttpResponse response = exchange.getResponse();\n        ServerHttpRequest request = exchange.getRequest();\n        DataBufferFactory dataBufferFactory = response.bufferFactory();\n        ServerHttpResponseDecorator decoratedResponse = getDecoratedResponse(path, response, request, dataBufferFactory);\n        return chain.filter(exchange.mutate().response(decoratedResponse).build());\n    }\n\n    private ServerHttpResponseDecorator getDecoratedResponse(String path, ServerHttpResponse response, ServerHttpRequest request, DataBufferFactory dataBufferFactory) {\n        return new ServerHttpResponseDecorator(response) {\n\n            @Override\n            public Mono<Void> writeWith(final Publisher<? extends DataBuffer> body) {\n\n                if (body instanceof Flux) {\n\n                    Flux<? extends DataBuffer> fluxBody = (Flux<? extends DataBuffer>) body;\n\n                    return super.writeWith(fluxBody.buffer().map(dataBuffers -> {\n\n                        DefaultDataBuffer joinedBuffers = new DefaultDataBufferFactory().join(dataBuffers);\n                        byte[] content = new byte[joinedBuffers.readableByteCount()];\n                        joinedBuffers.read(content);\n                        String responseBody = new String(content, StandardCharsets.UTF_8);//응답 수정 및 수정된 응답 반환\n                        System.out.println(\"requestId: \"+request.getId()+\", method: \"+request.getMethodValue()+\", req url: \"+request.getURI()+\", response body :\"+ responseBody);\n                        try {\n                            if(request.getURI().getPath().equals(\"/first\") && request.getMethodValue().equals(\"GET\")) {\n                                List<Student> student = new ObjectMapper().readValue(responseBody, List.class);\n                                System.out.println(\"student:\" + student);\n                            }\n                            else if(request.getURI().getPath().equals(\"/second\") && request.getMethodValue().equals(\"GET\")) {\n                                List<Company> companies = new ObjectMapper().readValue(responseBody, List.class);\n                                System.out.println(\"companies:\" + companies);\n                            }\n                        } catch (JsonProcessingException e) {\n                            throw new RuntimeException(e);\n                        }\n                        return dataBufferFactory.wrap(responseBody.getBytes());\n                    })).onErrorResume(err -> {\n\n                        System.out.println(\"error while decorating Response: {}\"+err.getMessage());\n                        return Mono.empty();\n                    });\n\n                }\n                return super.writeWith(body);\n            }\n        };\n    }\n\n}\n```\n\nC. API 호출 전에 인증하기:\n\n다음과 같이 인증 필터를 생성하십시오:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```java\npackage com.example.springcloudgatewayoverview.filter;\n\nimport com.example.springcloudgatewayoverview.util.AuthUtil;\nimport com.example.springcloudgatewayoverview.util.JWTUtil;\nimport com.example.springcloudgatewayoverview.validator.RouteValidator;\nimport io.jsonwebtoken.Claims;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.cloud.context.config.annotation.RefreshScope;\nimport org.springframework.cloud.gateway.filter.GatewayFilter;\nimport org.springframework.cloud.gateway.filter.GatewayFilterChain;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.server.reactive.ServerHttpRequest;\nimport org.springframework.http.server.reactive.ServerHttpResponse;\nimport org.springframework.stereotype.Component;\nimport org.springframework.web.server.ServerWebExchange;\nimport reactor.core.publisher.Mono;\n\n@Component\n@RefreshScope\npublic class AuthFilter implements GatewayFilter {\n\n    @Autowired\n    RouteValidator routeValidator;\n\n    @Autowired\n    private JWTUtil jwtUtil;\n\n    @Autowired\n    private AuthUtil authUtil;\n\n    @Value(\"${authentication.enabled}\")\n    private boolean authEnabled;\n\n    @Override\n    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {\n        if(!authEnabled) {\n            System.out.println(\"Authentication is disabled. To enable it, make \\\"authentication.enabled\\\" property as true\");\n            return chain.filter(exchange);\n        }\n        String token =\"\";\n        ServerHttpRequest request = exchange.getRequest();\n\n        if(routeValidator.isSecured.test(request)) {\n            System.out.println(\"validating authentication token\");\n            if(this.isCredsMissing(request)) {\n                System.out.println(\"in error\");\n                return this.onError(exchange,\"Credentials missing\",HttpStatus.UNAUTHORIZED);\n            }\n            if (request.getHeaders().containsKey(\"userName\") && request.getHeaders().containsKey(\"role\")) {\n                token = authUtil.getToken(request.getHeaders().get(\"userName\").toString(), request.getHeaders().get(\"role\").toString());\n            }\n            else {\n                token = request.getHeaders().get(\"Authorization\").toString().split(\" \")[1];\n            }\n\n            if(jwtUtil.isInvalid(token)) {\n                return this.onError(exchange,\"Auth header invalid\",HttpStatus.UNAUTHORIZED);\n            }\n            else {\n                System.out.println(\"Authentication is successful\");\n            }\n\n            this.populateRequestWithHeaders(exchange,token);\n        }\n        return chain.filter(exchange);\n    }\n\n    private Mono<Void> onError(ServerWebExchange exchange, String err, HttpStatus httpStatus) {\n        ServerHttpResponse response = exchange.getResponse();\n        response.setStatusCode(httpStatus);\n        return response.setComplete();\n    }\n\n    private String getAuthHeader(ServerHttpRequest request) {\n        return  request.getHeaders().getOrEmpty(\"Authorization\").get(0);\n    }\n\n\n    private boolean isCredsMissing(ServerHttpRequest request) {\n        return !(request.getHeaders().containsKey(\"userName\") && request.getHeaders().containsKey(\"role\")) && !request.getHeaders().containsKey(\"Authorization\");\n    }\n\n    private void populateRequestWithHeaders(ServerWebExchange exchange, String token) {\n        Claims claims = jwtUtil.getALlClaims(token);\n        exchange.getRequest()\n                .mutate()\n                .header(\"id\",String.valueOf(claims.get(\"id\")))\n                .header(\"role\", String.valueOf(claims.get(\"role\")))\n                .build();\n    }\n}\n```\n\nEndpoints 중 일부는 토큰 없이 호출을 허용해야 합니다. (예: 로그인 URL, 헬스 체크 URL 등). 이러한 엔드포인트들을 아래 목록에 추가할 것입니다:\n\n```java\npackage com.example.springcloudgatewayoverview.validator;\n\nimport org.springframework.http.server.reactive.ServerHttpRequest;\nimport org.springframework.stereotype.Component;\n\nimport java.util.List;\nimport java.util.function.Predicate;\n\n@Component\npublic class RouteValidator {\n    public static final List<String> unprotectedURLs = List.of(\"/login\");\n\n    public Predicate<ServerHttpRequest> isSecured = request -> unprotectedURLs.stream().noneMatch(uri -> request.getURI().getPath().contains(uri));\n}\n```\n\nJWTUtil:\n\n```java\n\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```java\npackage com.example.springcloudgatewayoverview.util;\n\nimport io.jsonwebtoken.Claims;\nimport io.jsonwebtoken.Jwts;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\n\nimport java.util.Date;\n\n@Component\npublic class JWTUtil {\n\n    @Value(\"${jwt.secret}\")\n    private String secret;\n\n    public Claims getAllClaims(String token) {\n        return Jwts.parserBuilder().setSigningKey(secret).build().parseClaimsJws(token).getBody();\n    }\n\n    private boolean isTokenExpired(String token) {\n        return this.getAllClaims(token).getExpiration().before(new Date());\n    }\n\n    public boolean isInvalid(String token) {\n        return this.isTokenExpired(token);\n    }\n\n}\n```\n\nAuthentication server:\n\n이 서비스는 내부 마이크로서비스에 액세스하기 위한 토큰을 제공합니다.\n\n실행:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nOnce all applications are running, you can access the service registry by entering http://localhost:8761 in your browser. Here, you can find information about all the currently running services:\n\n![Service Registry](/assets/img/2024-06-22-APIgatewayinSpringboot_2.png)\n\nThe API Gateway is running on localhost at port 8080. You can access the endpoints of the First or Second microservice from http://localhost:8080.\n\n![API Gateway Endpoints](/assets/img/2024-06-22-APIgatewayinSpringboot_3.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nAPIGateway 콘솔의 요청/응답 로그:\n\n![2024-06-22-APIgatewayinSpringboot_4](/assets/img/2024-06-22-APIgatewayinSpringboot_4.png)\n\n인증이 포함된 샘플 요청:\n\n![2024-06-22-APIgatewayinSpringboot_5](/assets/img/2024-06-22-APIgatewayinSpringboot_5.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n서비스의 모든 코드 기반은 여기에서 사용 가능합니다.\n\n읽어 주셔서 감사합니다. 즐거운 탐험하세요!!!\n","ogImage":{"url":"/assets/img/2024-06-22-APIgatewayinSpringboot_0.png"},"coverImage":"/assets/img/2024-06-22-APIgatewayinSpringboot_0.png","tag":["Tech"],"readingTime":20},{"title":"Spring AOP 이해하기 요청과 응답을 로깅하는 애너테이션 만드는 방법","description":"","date":"2024-06-22 22:17","slug":"2024-06-22-UnderstandingSpringAOPCreatingAnnotationforLoggingRequestsandResponses","content":"\n자바 개발자들의 강력한 무기 중 하나는 Aspect-Oriented Programming (AOP)입니다. Spring Boot와 원활하게 통합되면 게임 체인저가 될 수 있습니다. 이 글에서는 Spring Boot AOP를 이해하기 위해 Annotation을 구축하여 재사용할 수 있는데, 어떤 요청 매핑에도 로깅을 위해 요청, 응답 및 상태를 기록할 수 있습니다.\n\n![이미지](/assets/img/2024-06-22-UnderstandingSpringAOPCreatingAnnotationforLoggingRequestsandResponses_0.png)\n\n# AOP란 무엇인가요?\n\nAspect-Oriented Programming (AOP)은 개발자가 로깅, 오류 처리 및 보안과 같은 교차 관심 사항을 비즈니스 로직과 분리하여 모듈화할 수 있는 프로그래밍 패러다임입니다. AOP에서 이러한 관심 사항인 Aspect는 독립적으로 정의되고 특정 지점에서 코드에 엮이며 코드 중복을 줄이고 유지보수성을 향상시킵니다. 이 접근 방식은 코드 조직화를 개선하고 소프트웨어 개발에서 관심의 분리를 장려합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# AOP 개념\n\n구현에 들어가기 전에 알아야 할 몇 가지 개념이 있습니다.\n\n## 측면(Aspect)\n\n로그인 또는 보안과 같은 교차 관심사를 캡슐화하는 모듈입니다. 측면은 코드에서 어떻게 하는지와 어디에서 하는지를 정의합니다. Spring AOP에서는 @Aspect 주석이 달린 일반 클래스를 사용하여 측면을 구현합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 조인 포인트\n\n프로그램 실행 중 발생하는 특정 지점을 말합니다. 메소드 호출, 객체 인스턴스화 또는 예외 처리와 같은 것을 포함합니다. Aspect는 특정 조인 포인트를 대상으로 행동을 적용하기 위해 지정합니다. Spring AOP에서 조인 포인트는 항상 메소드 실행을 나타냅니다.\n\n## 어드바이스\n\n특정 조인 포인트에서 Aspect가 취하는 조치를 말합니다. \"before\", \"after\" 등과 같은 다양한 유형의 어드바이스가 있습니다. Spring AOP에서 어드바이스는 조인 포인트 주변의 인터셉터 체인을 유지하며 작동합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다양한 종류의 조언이 있습니다:\n\n- 이전 조언 (Before Advice): 조인 포인트 이전에 실행되며, 주요 로직을 실행하기 전에 동작이나 유효성 검사를 수행할 수 있는 기회를 제공합니다.\n- 반환 후 조언 (After returning Advice): 조인 포인트의 정상 실행이 완료된 후에 실행됩니다. 메서드가 성공적으로 완료될 때 수행할 동작에 유용합니다.\n- 던지기 후 조언 (After throwing Advice): 조인 포인트에서 예외가 발생하면 실행됩니다. 예외 처리 또는 로깅에 사용됩니다.\n- 이후 조언 (After Advice): 조인 포인트의 결과(정상 또는 예외)와 관계없이 실행됩니다. 정리 또는 마무리 작업에 사용됩니다.\n- 주변 조언 (Around Advice): 모든 조언 중에서 가장 강력한 기능을 가지고 있습니다. 조인 포인트를 포함하여 조인 포인트의 실행에 대한 완전한 제어를 제공합니다. 메서드의 동작을 수정하거나 완전히 대체할 수 있습니다.\n\n## 포인트컷\n\n조언이 적용해야 하는 조인 포인트를 나타내는 집합입니다. 조언은 포인트컷 표현식과 연관되어 있으며, 포인트컷과 일치하는 모든 조인 포인트에서 실행됩니다. 스프링은 기본적으로 AspectJ 포인트컷 표현식 언어를 사용합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 소개\n\n기존 클래스에 새로운 방법이나 필드를 도입하여, 측면(Aspect)이 클래스의 소스 코드를 수정하지 않고 기능을 추가할 수 있도록 합니다. Spring AOP를 사용하면 어떤 조언 대상 객체에 대해 새로운 인터페이스를 추가할 수 있습니다.\n\n## 엮기(Weaving)\n\n측면(Aspect)을 주요 응용 프로그램 코드와 통합하는 과정을 말합니다. 컴파일 시간, 로드 시간 또는 실행 시간에 발생할 수 있습니다. Spring AOP는 실행 시간에 엮기(Weaving)를 수행합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 대상 객체\n\n애스펙트에 의해 조언을 받는 객체입니다. Spring AOP는 런타임 위빙만 지원하기 때문에 이 객체는 항상 프록시된 객체가 될 것입니다.\n\n## AOP 프록시\n\nAspect contracts를 구현하기 위해 AOP 프레임워크에 의해 생성된 객체입니다. Spring에서 AOP 프록시는 JDK 다이내믹 프록시 또는 CGLIB 프록시가 될 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 사용자 정의 어노테이션\n\n이 글에서는 사용자 정의 어노테이션에 대해 이해해야 합니다. 기본 사항을 알아보겠습니다.\n\nSpring Boot에서 사용자 정의 어노테이션을 사용하면 코드에 자체 마커나 메타데이터를 정의할 수 있습니다. 주요 개념을 살펴보겠습니다.\n\n- 어노테이션 선언: 어노테이션을 선언하려면 @interface를 사용합니다.\n- 대상(Target): 어노테이션이 사용될 위치를 지정합니다. 예: @Target(ElementType.METHOD)은 메서드에만 사용할 수 있도록 제한합니다. 클래스에 사용하려면 TYPE을, 필드에 사용하려면 FIELD를 사용할 수 있습니다.\n- 보존(Retention): 어노테이션 정보가 유지되는 시점을 정의합니다. 예: @Retention(RetentionPolicy.RUNTIME)은 실행 시점에 사용 가능하게 합니다.\n- 속성(Attributes): 어노테이션 내에서 속성을 정의합니다. 예: String value() default “기본 값”;\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 구현\n\n이제 구현을 진행해 봅시다.\n\n## 의존성\n\n먼저, spring AOP를 종속성으로 추가하겠습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n<!-- Spring AOP -->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-aop</artifactId>\n</dependency>\n```\n\n## 사용자 정의 어노테이션\n\n그런 다음 사용자 정의 어노테이션을 생성할 것입니다.\n\n```js\npackage com.example.demo.annotations;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n/**\n * @author Pratiyush Prakash\n *\n * 이 어노테이션은 요청과 응답을 로깅하는 데 사용됩니다.\n *\n * METHOD에만 적용되며,\n * 런타임에서 사용 가능합니다.\n */\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface LogRequestResponse {\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 양상\n\n이제 Aspect를 생성할 수 있습니다. 여기서는 Annotation에 대한 Pointcut을 생성하고 메서드의 요청과 응답을 로깅하기 위한 어드바이스를 생성할 것입니다.\n\n```js\npackage com.example.demo.aspects;\n\nimport org.aspectj.lang.JoinPoint;\nimport org.aspectj.lang.annotation.AfterReturning;\nimport org.aspectj.lang.annotation.Aspect;\nimportorg.aspectj.lang.annotation.Before;\nimport org.aspectj.lang.annotation.Pointcut;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.stereotype.Component;\n\n/**\n * @author Pratiyush Prakash\n *\n * 이 Aspect는 LogRequestResponse 어노테이션을 적용한 모든 요청과 응답을 로깅하는 모듈입니다.\n */\n@Aspect\n@Component\npublic class RequestResponseLoggingAspect {\n\n    // LogRequestResponse 어노테이션에 대한 Pointcut 정의\n    @Pointcut(\"@annotation(com.example.demo.annotations.LogRequestResponse)\")\n    public void logAnnotationPointcut() {\n    }\n\n    // Before 어드바이스\n    @Before(\"logAnnotationPointcut()\")\n    public void logBefore(JoinPoint joinPoint) {\n        System.out.println(\"Before \" + joinPoint.getSignature().getName());\n    }\n\n\n    // 일반적인 After 어드바이스\n    @AfterReturning(pointcut = \"logAnnotationPointcut()\", returning = \"result\")\n    public void logAfterReturning(JoinPoint joinPoint, Object result) {\n        // 응답을 로깅합니다.\n        System.out.println(\"After \" + joinPoint.getSignature().getName() +  \"메서드가 반환한 값 \" + result);\n\n        // 응답 상태를 로깅합니다.\n        if (result instanceof ResponseEntity) {\n            ResponseEntity<Object> response = (ResponseEntity<Object>) result;\n            System.out.println(\"응답 상태: \" + response.getStatusCode());\n        }\n    }\n\n}\n```\n\n## 어플리케이션\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 테스트하고 싶은 엔드포인트에 주석을 추가할 수 있습니다.\n\n```js\npackage com.example.demo.web;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport com.example.demo.annotations.LogRequestResponse;\n\n/**\n * @Author Pratiyush Prakash\n *\n * 여기에 모든 엔드포인트가 위치합니다\n */\n@RestController\n@RequestMapping(\"/api/v1\")\npublic class DemoController {\n\n    /**\n     * 이것은 샘플 보안된 API 호출입니다\n     * @return 문자열\n     */\n    @LogRequestResponse\n    @GetMapping(value = \"/secured/hello-world\")\n    public String securedCall() {\n        return \"hello world secured!!\";\n    }\n\n    /**\n     * 이것은 샘플 비보안 API 호출입니다\n     * @return 문자열\n     */\n    @LogRequestResponse\n    @GetMapping(value = \"/hello-world\")\n    public String unsecuredCall() {\n        return \"hello world!!\";\n    }\n\n    /**\n     * 이것은 객체를 반환하는 샘플 GET 호출입니다\n     * @return 이름과 나이의 맵\n     */\n    @LogRequestResponse\n    @GetMapping(value = \"/demo-object\")\n    public Map<String, Integer> demoObjectMap() {\n        Map<String, Integer> map = new HashMap<>();\n        map.put(\"Pratiyush\", 29);\n        return map;\n    }\n\n    /**\n     * 다른 응답 상태를 테스트하기 위한 샘플 GET 호출입니다\n     * @return ResponseEntity\n     */\n    @LogRequestResponse\n    @GetMapping(value = \"/demo-response-entity\")\n    public ResponseEntity<String> demoResponseEntity(@RequestParam Integer code) {\n        switch (code) {\n            case 200:\n                return new ResponseEntity<String>(\"Hello world!!\", HttpStatus.ACCEPTED);\n            case 400:\n                return new ResponseEntity<>(HttpStatus.NOT_FOUND);\n            default:\n                return new ResponseEntity<>(HttpStatus.INTERNAL_SERVER_ERROR);\n        }\n    }\n\n}\n```\n\n여기까지 코드 작업이 완료되었습니다.\n\n## 데모\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 우리의 구현이 제대로 작동하는지 확인할 수 있습니다. 애플리케이션을 빌드하고 실행할 수 있습니다. Swagger UI를 열어 엔드포인트를 호출할 수도 있습니다. 그리고 로그에서 요청과 응답을 확인할 수 있는지 확인할 수 있습니다.\n\n![이미지](/assets/img/2024-06-22-UnderstandingSpringAOPCreatingAnnotationforLoggingRequestsandResponses_1.png)\n\n요약하자면, Aspect는 프로젝트를 모듈화하고 로깅, 보안, 오류 처리와 같은 공통 관심을 분리해야 하는 경우에 매우 유용합니다. 이 글에서는 로깅 사용 사례를 다뤘습니다. 여러분의 프로젝트에서 이와 같은 시나리오가 있는 경우 한번 시도해 보세요.\n\n# 참고문헌\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- [Spring Framework AOP](https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html)\n- [Demystifying Proxy in Spring](https://medium.com/dev-genius/demystifying-proxy-in-spring-3ab536046b11)\n- You can access my code [here](https://github.com/iepratiyush/spring-demo)\n","ogImage":{"url":"/assets/img/2024-06-22-UnderstandingSpringAOPCreatingAnnotationforLoggingRequestsandResponses_0.png"},"coverImage":"/assets/img/2024-06-22-UnderstandingSpringAOPCreatingAnnotationforLoggingRequestsandResponses_0.png","tag":["Tech"],"readingTime":11},{"title":"Spring Boot를 활용한 REST 강좌  얼리버드 할인 정보","description":"","date":"2024-06-22 22:16","slug":"2024-06-22-RESTwithSpringBootCourseEarlyBirdDiscount","content":"\n## 유젠 파라시브가 새로운 버전의 REST with Spring Boot 코스를 출시했고, 얼리 버드 할인이 곧 마감됩니다\n\n![이미지](/assets/img/2024-06-22-RESTwithSpringBootCourseEarlyBirdDiscount_0.png)\n\n안녕하세요 여러분, 오늘 여러분과 공유하고 싶은 흥미로운 소식이 있어요. 제 친구이자 동료 블로거인 Baeldung의 유젠 파라시브가 그의 베스트셀러 REST With Spring 코스의 새 버전을 출시했어요. 사실, 이것은 REST With Spring Boot 3라는 새로운 코스인데요, 이 코스는 최신 버전의 Spring Boot와 Spring을 사용합니다. 즉, Spring Boot 3과 Spring 프레임워크 6을 사용해요.\n\n현재 REST with Spring Boot의 가격은 이번 주말에 공식적으로 인상됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음은 요금이 변경되는 방법입니다:\n\n1. Master Class - 107달러에서 157달러로 인상됩니다.\n\n2. 인증 수업 - 167달러에서 217달러로 인상됩니다.\n\n프로그램에 참여할 계획을 세우고 현재 요금제 마지막 몇 날 동안 혜택을 받으려면 빨리 신청하세요.\n\n마스터 클래스에 가입할 수 있는 링크는 여기에 있습니다 - https://www.baeldung.com/courses/rest-with-spring-boot-course\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 Markdown 형식으로 표시됩니다.\n\n![Early Bird Discount for REST with Spring Boot Course](/assets/img/2024-06-22-RESTwithSpringBootCourseEarlyBirdDiscount_1.png)\n\n그리고, 인증 수업에 참여하고 싶다면 — [인증 수업 링크](https://www.baeldung.com/courses/rest-with-spring-boot-course?#certification-class)\n\n![Early Bird Discount for REST with Spring Boot Course](/assets/img/2024-06-22-RESTwithSpringBootCourseEarlyBirdDiscount_2.png)\n\n# REST with Spring Boot Course는 어떤가요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n새로운 REST with Spring Boot은 예전 강좌와 크게 다르지 않도록 의도되어 있어요. 그의 계획은 Spring Boot 3 주변에서 강좌를 점진적으로 진화시키고 구조를 유지하되, 나중에 해당 주제로 완전히 새로운 강좌를 만드는 것이었어요.\n\n최종적으로 완성된 자료는 REST With Spring의 클래식 레슨을 넘어선 진화를 했을 뿐만 아니라, 원래의 목표를 초과한 것이기도 해요.\n\n다음은 REST with Spring Boot의 몇 가지 새로운 레슨들입니다:\n\n- HTTP 동사와 Spring에서의 의미론\n  Spring의 REST API 의미론 주석의 이론적 측면에 대해 더 자세히 다루는 기존 레슨의 확장 버전입니다.\n- Spring과 Problem Details Spec\n  Spring Boot 3가 Problem Details Specification에 추가한 지원을 탐구하는 파트로, HTTP 응답에서 기계가 읽을 수 있는 오류 세부 정보를 표준화하는 형식을 제공합니다.\n- End-To-End API 테스트 — WebTestClient\n  API 테스트란 무엇인지, 사용 가능한 도구들, 그리고 주 테스트 클라이언트로 WebTestClient에 집중하는 부분입니다.\n- 문서 vs REST API 발견\n  REST API에 대한 이 두 접근 방식 사이의 차이점\n- Swagger 및 OpenAPI로 API 문서 작성과 발견하기\n  OpenAPI 이니셔티브가 다루는 내용과 Swagger 도구와의 관계에 대해 깊이 파고들어봅니다.\n- REST API의 진화 — API 진화, 파괴 및 비파괴 변경, 후방 호환성에 대한 포괄적 가이드. 예, 불가피한 변화를 관리하는 실용적인 전략들까지요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n새로운 코스 페이지에서 전체 아웃라인을 찾을 수 있습니다:\n`` Spring Boot로 REST 특강 아웃라인\n\n![이미지](/assets/img/2024-06-22-RESTwithSpringBootCourseEarlyBirdDiscount_3.png)\n\n# Spring Boot로 REST 특강은 가치가 있을까요?\n\n네, 가치가 있습니다. Spring Boot는 2024년에도 여전히 자바 웹 애플리케이션을 구축하는 데 가장 인기 있는 프레임워크입니다. 그리고 이에는 충분한 이유가 있습니다. Spring과 Spring Boot를 사용하면 자바 웹 애플리케이션을 구축하는 방법이 크게 간소화되었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그럼에도 불구하고, 견고하고 유연하며 성숙한 REST API를 설계하고 구현하는 것은 상당히 어려운 작업입니다.\n\n그리고 여기서 REST With Spring Boot 코스가 도움을 줄 겁니다. 즉, REST - 최상의 실천 방법, Boot를 효과적으로 활용하는 법, HTTP 이해 및 API를 나중에 발전시키기 위한 기초를 마련해주는 것부터 시작해서 그 이상까지 여러분을 안내해 줄 겁니다. (네, 나중에 항상 변경해야 할 필요가 있을 겁니다).\n\n코스의 새 버전은 좋은 API의 이론적 기반을 다루지만, Spring Boot 애플리케이션의 실제 개발에 초점을 맞춥니다.\n\n요약하자면, REST with Spring Boot 코스는 그 구조, 내용 및 범위 때문에 분명히 가치가 있습니다. 여러분은 Spring Boot 3로 REST API를 만드는 방법뿐만 아니라 최상의 실천 방법, Boot를 효과적으로 활용하는 법, HTTP 이해 및 API를 나중에 전문가로부터 발전시키는 기초를 설정하는 방법을 배우게 됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n유겐은 많은 경험을 가지고 있고 그 경험이 그의 강의에서 드러납니다. 이 강의에 참여하는 것을 강력히 추천합니다.\n\n다음은 강의에 참여할 수 있는 링크입니다 - REST With Spring Boot 강좌\n\n![이미지](/assets/img/2024-06-22-RESTwithSpringBootCourseEarlyBirdDiscount_4.png)\n\n그리고, 더 많은 학습을 원한다면, 유겐은 Spring Security, Spring Data JPA 및 다른 기술을 다루는 Spring 프레임워크 강좌를 Baeldung에 더 제공했습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여기 바엘둥의 최고 Spring 강좌들입니다. 함께 참여할 수 있는 강좌들이에요:\n\n- Spring Security 배우기: 인증 수업\n- Spring 배우기: 마스터 클래스\n- Spring Data JPA 인증 수업\n\n이러한 강좌들은 Spring 6과 Spring Boot 3를 처음부터 코드 중심으로 안내받아 배울 수 있는 훌륭한 자원입니다.\n\n## 결론\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이게 바로 Spring Boot 3 강의에 대한 전체 내용이에요. Eugen의 다른 강의와 마찬가지로 이 강의도 정말 좋아요. Spring Boot로 현대적인 방식으로 REST API를 만드는 법을 배울 수 있어요. 그 과정에서 Open API와 Swagger 같은 필수 도구와 REST End 포인트를 볼 수 있는 IDEA 플러그인도 배울 거에요.\n\nSpring Boot 3로 REST API를 배우고 싶다면 이 강의가 딱이에요. 오늘까지만 얼리 버드 할인 중이니 서둘러 등록하세요.\n\n강의 수강 신청 링크는 여기에 있어요 — REST With Spring Boot course\n\n행운을 빕니다!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nP. S. — 조기 할인 기간을 놓쳐도, 이 강의에 가입하면 가격을 충분히 가치 있게 느낄 수 있어요!\n","ogImage":{"url":"/assets/img/2024-06-22-RESTwithSpringBootCourseEarlyBirdDiscount_0.png"},"coverImage":"/assets/img/2024-06-22-RESTwithSpringBootCourseEarlyBirdDiscount_0.png","tag":["Tech"],"readingTime":7},{"title":"우분투 2204에서 Apache Hadoop 336 설치 방법","description":"","date":"2024-06-22 22:14","slug":"2024-06-22-ApacheHadoop336InstallationonUbuntu2204","content":"\n빅 데이터의 계속 확장되는 세계에서는 대량의 정보를 효율적으로 관리하고 처리하는 것이 비즈니스와 조직에게 중요해지고 있습니다. 이 데이터 혁명의 선두에 서 있는 것이 하둡(Hadoop)입니다. 이 강력한 오픈 소스 프레임워크는 분산 데이터 저장 및 처리의 과제에 대응하기 위해 설계되었습니다. 하둡의 잠재력을 활용하여 데이터 프로젝트를 진행하고 싶지만 설치 과정이 어려워 두려워하지 마십시오! 이 포괄적인 안내서는 여러분이 Ubuntu 시스템에 Hadoop을 설치하는 필수 단계를 안내하여 데이터 분석의 무한한 가능성을 탐험할 수 있도록 도와줄 것입니다.\n\n데이터 전문가로 성장하고자 하는 경험이 풍부한 분이든 데이터 여정을 시작하려는 초보자든, 이 안내서는 이제껏 보다 Hadoop을 접근하기 쉽게 만들고자 합니다. 이 여정을 마치면 분산 데이터 처리 세계를 탐험하고, Hadoop의 능력을 활용하며 데이터 주도형 노력에 대한 잠재력을 최대한 이끌어낼 준비가 되어 있을 것입니다. 그러니 함께 진행하여 빅 데이터 분석의 세계로 흥미진진한 여정을 떠나봅시다.\n\n# 단계 1: Java 개발 키트 설치\n\n기본 Ubuntu 저장소에는 Java 8과 Java 11이 모두 포함되어 있습니다. 저는 이 중 Java 8을 사용하고 있습니다. 다음 명령을 사용하여 Java를 설치하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```bash\nsudo apt update && sudo apt install openjdk-8-jdk\n```\n\n# 단계 2: Java 버전 확인하기:\n\n성공적으로 설치했다면, 현재 Java 버전을 확인하세요:\n\n```bash\njava -version\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/assets/img/2024-06-22-ApacheHadoop336InstallationonUbuntu2204_0.png)\n\n# 단계 3: SSH 설치:\n\nHadoop을 위해 SSH (Secure Shell)를 설치하는 것은 매우 중요합니다. 이를 통해 Hadoop 클러스터의 노드 간 안전한 통신이 가능해지며, 클러스터 전체에 걸쳐 데이터 무결성과 기밀성을 보장하며 데이터의 효율적인 분산 처리를 가능하게 합니다.\n\n```js\nsudo apt install ssh\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 단계 4: 하둡 사용자 만들기:\n\n모든 하둡 구성 요소는 Apache 하둡을 위해 만든 사용자로 실행되며 해당 사용자는 하둡의 웹 인터페이스에 로그인하는 데도 사용됩니다.\n\n다음 명령을 실행하여 사용자를 만들고 비밀번호를 설정하세요:\n\n```js\nsudo adduser hadoop\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 Markdown 형식을 사용해서 표로 바꿔줄게요.\n\n![이미지](/assets/img/2024-06-22-ApacheHadoop336InstallationonUbuntu2204_1.png)\n\n## Step 5: 사용자 전환:\n\n새로 생성된 하둡 사용자로 전환하세요:\n\n```bash\nsu - hadoop\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 단계 6 : SSH 구성:\n\n이제 새로 만든 하둡 사용자의 비밀번호 없는 SSH 액세스를 구성해 보겠습니다. 파일을 저장하고 암호구 문을 입력하지 않아도 되게 합니다. 먼저 SSH 키페어를 생성합니다:\n\n```js\nssh-keygen -t rsa\n```\n\n![이미지](/assets/img/2024-06-22-ApacheHadoop336InstallationonUbuntu2204_2.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 단계 7: 권한 설정:\n\n생성된 공개 키를 권한이 올바르도록 인가된 키 파일에 복사하고 설정하세요:\n\n```js\ncat ~/.ssh/id_rsa.pub >> ~/.ssh/authorized_keys\nchmod 640 ~/.ssh/authorized_keys\n```\n\n# 단계 8: 로컬호스트로 SSH 연결하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nssh localhost\n```\n\n로컬호스트를 인증하려면 알려진 호스트에 RSA 키를 추가하여 호스트를 인증해야 합니다. \"yes\"를 입력하고 Enter를 눌러 localhost를 인증하세요.\n\n![이미지](/assets/img/2024-06-22-ApacheHadoop336InstallationonUbuntu2204_3.png)\n\n# 단계 9: 사용자 전환\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다시 Hadoop으로 전환해주세요.\n\n```bash\nsu - hadoop\n```\n\n# 단계 10: Hadoop 설치하기\n\n- Hadoop 3.3.6 다운로드하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nwget https://dlcdn.apache.org/hadoop/common/hadoop-3.3.6/hadoop-3.3.6.tar.gz\n```\n\n- 파일을 다운로드한 후에 압축을 풀어주세요.\n\n```js\ntar -xvzf hadoop-3.3.6.tar.gz\n```\n\n- 추출된 폴더를 버전 정보를 제거하여 이름을 변경해주세요. 이 단계는 선택 사항입니다. 이름을 변경하지 않으려면 구성 경로를 조정해주세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nmv hadoop-3.3.6 hadoop\n\n![Installation Guide](/assets/img/2024-06-22-ApacheHadoop336InstallationonUbuntu2204_4.png)\n\n- Next, you will need to configure Hadoop and Java Environment Variables on your system. Open the `~/.bashrc` file in your favorite text editor. Here I am using the nano editor. To paste the code, use `Ctrl+Shift+V`, for saving the file use `Ctrl+X` and `Ctrl+Y`, then hit `Enter`:\n\n```bash\nnano ~/.bashrc\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nexport JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64\nexport HADOOP_HOME=/home/hadoop/hadoop\nexport HADOOP_INSTALL=$HADOOP_HOME\nexport HADOOP_MAPRED_HOME=$HADOOP_HOME\nexport HADOOP_COMMON_HOME=$HADOOP_HOME\nexport HADOOP_HDFS_HOME=$HADOOP_HOME\nexport HADOOP_YARN_HOME=$HADOOP_HOME\nexport HADOOP_COMMON_LIB_NATIVE_DIR=$HADOOP_HOME/lib/native\nexport PATH=$PATH:$HADOOP_HOME/sbin:$HADOOP_HOME/bin\nexport HADOOP_OPTS=\"-Djava.library.path=$HADOOP_HOME/lib/native\"\n```\n\n![Apache Hadoop](/assets/img/2024-06-22-ApacheHadoop336InstallationonUbuntu2204_5.png)\n\n- 현재 환경에서 위의 구성을 로드합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nsource ~/.bashrc\n```\n\n- 하둡 환경 변수 파일인 hadoop-env.sh 파일에서 JAVA_HOME을 구성해야 합니다. 텍스트 편집기에서 Hadoop 환경 변수 파일을 편집하세요:\n\n```js\nnano $HADOOP_HOME/etc/hadoop/hadoop-env.sh\n```\n\n\"export JAVA_HOME\"을 검색하고 구성하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nJAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64\n```\n\n![Image](/assets/img/2024-06-22-ApacheHadoop336InstallationonUbuntu2204_6.png)\n\n# 11단계 : 하둡 구성하기:\n\n- 먼저, 하둡 사용자 홈 디렉터리 내에서 namenode 및 datanode 디렉터리를 생성해야합니다. 다음 명령을 실행하여 두 디렉터리를 생성하십시오:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\ncd 하둡/\n```\n\n```js\nmkdir -p ~/hadoopdata/hdfs/{namenode,datanode}\n```\n\n<img src=\"/assets/img/2024-06-22-ApacheHadoop336InstallationonUbuntu2204_7.png\" />\n\n- 다음으로 core-site.xml 파일을 편집하고 시스템 호스트 이름으로 업데이트하세요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n나노 $HADOOP_HOME/etc/hadoop/core-site.xml\n```\n\n아래 이름을 시스템 호스트 이름에 맞게 변경하세요:\n\n```js\n<configuration>\n  <property>\n    <name>fs.defaultFS</name>\n    <value>hdfs://localhost:9000</value>\n  </property>\n</configuration>\n```\n\n<img src=\"/assets/img/2024-06-22-ApacheHadoop336InstallationonUbuntu2204_8.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n파일을 저장하고 닫으세요.\n\n- 그런 다음, hdfs-site.xml 파일을 편집하세요:\n\n```js\nnano $HADOOP_HOME/etc/hadoop/hdfs-site.xml\n```\n\n- 다음과 같이 NameNode 및 DataNode 디렉토리 경로를 변경하세요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n<구성>\n  <속성>\n    <이름>dfs.replication</이름>\n    <값>1</값>\n  </속성>\n  <속성>\n    <이름>dfs.namenode.name.dir</이름>\n    <값>file:///home/hadoop/hadoopdata/hdfs/namenode</값>\n  </속성>\n  <속성>\n    <이름>dfs.datanode.data.dir</이름>\n    <값>file:///home/hadoop/hadoopdata/hdfs/datanode</값>\n  </속성>\n</구성>\n```\n\n<img src=\"/assets/img/2024-06-22-ApacheHadoop336InstallationonUbuntu2204_9.png\" />\n\n- 이후, mapred-site.xml 파일을 편집합니다:\n\n```js\nnano $HADOOP_HOME/etc/hadoop/mapred-site.xml\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 다음 변경 사항을 적용해주세요:\n\n```js\n<configuration>\n  <property>\n    <name>yarn.app.mapreduce.am.env</name>\n    <value>HADOOP_MAPRED_HOME=$HADOOP_HOME/home/hadoop/hadoop/bin/hadoop</value>\n  </property>\n  <property>\n    <name>mapreduce.map.env</name>\n    <value>HADOOP_MAPRED_HOME=$HADOOP_HOME/home/hadoop/hadoop/bin/hadoop</value>\n  </property>\n  <property>\n    <name>mapreduce.reduce.env</name>\n    <value>HADOOP_MAPRED_HOME=$HADOOP_HOME/home/hadoop/hadoop/bin/hadoop</value>\n  </property>\n</configuration>\n```\n\n![Apache Hadoop Installation on Ubuntu 22.04](/assets/img/2024-06-22-ApacheHadoop336InstallationonUbuntu2204_10.png)\n\n- 그런 다음, yarn-site.xml 파일을 편집하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n나노 $HADOOP_HOME/etc/hadoop/yarn-site.xml\n```\n\n- 다음 변경 사항을 적용하세요:\n\n```js\n<configuration>\n  <property>\n    <name>yarn.nodemanager.aux-services</name>\n    <value>mapreduce_shuffle</value>\n  </property>\n</configuration>\n```\n\n![이미지](/assets/img/2024-06-22-ApacheHadoop336InstallationonUbuntu2204_11.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n파일을 저장하고 닫아주세요.\n\n# 단계 12: Hadoop 클러스터 시작하기:\n\n- Hadoop 클러스터를 시작하기 전에 Namenode를 hadoop 사용자로 포맷해야 합니다.\n- 다음 명령을 실행하여 Hadoop Namenode를 포맷합니다:\n\n```js\nhdfs namenode -format\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- Namenode 디렉토리를 hdfs 파일 시스템으로 성공적으로 포맷한 후에는 \"Storage directory /home/hadoop/hadoopdata/hdfs/namenode has been successfully formatted\" 메시지가 표시됩니다.\n\n![이미지](/assets/img/2024-06-22-ApacheHadoop336InstallationonUbuntu2204_12.png)\n\n- 그런 다음 다음 명령어로 Hadoop 클러스터를 시작합니다.\n\n```js\nstart - all.sh;\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/assets/img/2024-06-22-ApacheHadoop336InstallationonUbuntu2204_13.png)\n\n- 이제 jps 명령어를 사용하여 모든 Hadoop 서비스의 상태를 확인할 수 있습니다:\n\n```js\njps;\n```\n\n![이미지](/assets/img/2024-06-22-ApacheHadoop336InstallationonUbuntu2204_14.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 단계 13: 하둡 네임노드 및 리소스 매니저에 액세스하기:\n\n- 먼저 우리의 IP 주소를 알아야 합니다. Ubuntu에서는 ipconfig 명령을 실행하기 위해 net-tools를 설치해야 합니다. net-tools를 처음으로 설치하는 경우 기본 사용자로 전환하세요:\n\n```js\nsudo apt install net-tools\n```\n\n- 그런 다음 ifconfig 명령을 실행하여 우리의 IP 주소를 알아낼 수 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nifconfig;\n```\n\n![Image](/assets/img/2024-06-22-ApacheHadoop336InstallationonUbuntu2204_15.png)\n\n여기서 내 IP 주소는 192.168.1.6입니다.\n\n- 네임노드에 액세스하려면 웹 브라우저를 열고 다음 URL을 방문하십시오. http://your-server-ip:9870. 다음 화면이 표시됩니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nhttp://192.168.1.6:9870\n\n![Apache Hadoop Installation on Ubuntu 22.04](/assets/img/2024-06-22-ApacheHadoop336InstallationonUbuntu2204_16.png)\n\n- 리소스 관리자에 액세스하려면 웹 브라우저를 열고 URL http://your-server-ip:8088을 방문하십시오. 다음 화면이 표시됩니다:\n\nhttp://192.168.1.6:8088\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-06-22-ApacheHadoop336InstallationonUbuntu2204_17.png\" />\n\n# 단계 13: Hadoop 클러스터 확인하기:\n\n이 시점에서 Hadoop 클러스터가 설치되고 구성되었습니다. 다음으로, HDFS 파일 시스템에 몇 가지 디렉토리를 생성하여 Hadoop을 테스트할 것입니다.\n\n- 다음 명령을 사용하여 HDFS 파일 시스템에 몇 가지 디렉토리를 생성해 봅시다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nhdfs dfs -mkdir /test1\nhdfs dfs -mkdir /logs\n```\n\n- 다음은 위의 디렉토리를 나열하는 다음 명령어를 실행하십시오:\n\n```js\nhdfs dfs -ls /\n```\n\n다음과 같은 출력이 나와야 합니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-06-22-ApacheHadoop336InstallationonUbuntu2204_18.png\" />\n\n- 또한, 하둡 파일 시스템에 파일을 추가하세요. 예를 들어, 호스트 머신의 로그 파일을 하둡 파일 시스템에 넣어보세요.\n\n```js\nhdfs dfs -put /var/log/* /logs/\n```\n\n해당 파일 및 디렉터리를 하둡 웹 인터페이스에서도 확인할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n웹 인터페이스로 이동하셔서 'Utilities'를 클릭하신 후 '파일 시스템 찾아보기'를 선택해주세요. 여러분이 이전에 만든 디렉토리들이 다음 화면에서 보일 것입니다:\n\n![이미지](/assets/img/2024-06-22-ApacheHadoop336InstallationonUbuntu2204_19.png)\n\n# 14 단계: Hadoop 서비스 중지하기 :\n\nHadoop 서비스를 중지하려면, hadoop 사용자로 다음 명령어를 실행해주세요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nstop - all.sh;\n```\n\n![Image](/assets/img/2024-06-22-ApacheHadoop336InstallationonUbuntu2204_20.png)\n\n이 튜토리얼은 우분투 22.04 리눅스 시스템에 Hadoop를 설치하고 구성하는 방법을 단계별로 설명해줍니다.\n\n# 결론:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n요약하자면, 여러분은 이제 우분투 시스템에 Hadoop을 설치하는 지식과 기술을 갖추었으며, 빅 데이터 분석의 엄청난 잠재력을 발휘하기 위한 첫걸음을 내딛었습니다. 설치 과정을 정복함으로써, 분산 데이터 처리와 분석의 방대한 세계를 탐험할 수 있는 길을 열었습니다.\n\nHadoop을 활용하면 대규모 데이터셋을 처리하고 관리하는 도전에 대처할 강력한 도구를 갖게 됩니다. 데이터 전문가로서 전문성을 확장하려는 숙련된 분이든, 데이터의 세계에 입문한 초보자든, 이 안내서는 Hadoop을 저절로 접근 가능하게 만들어주었습니다.\n\n그러므로 빅 데이터 분석의 세계로 여행을 떠날 때, 이것이 시작에 불과하다는 것을 기억하세요. 발견하고 활용할 수 있는 무한한 가능성이 기다리고 있습니다. 즐겁게 탐험하시고, 데이터 중심의 모험을 통해 가치 있는 통찰과 혁신적인 발견을 이루시기를 기대합니다!\n","ogImage":{"url":"/assets/img/2024-06-22-ApacheHadoop336InstallationonUbuntu2204_0.png"},"coverImage":"/assets/img/2024-06-22-ApacheHadoop336InstallationonUbuntu2204_0.png","tag":["Tech"],"readingTime":18},{"title":" Java 탄생 이야기  실패한 두 가지 시도와 성공까지의 여정","description":"","date":"2024-06-22 22:12","slug":"2024-06-22-HowJavaWasBornTwoFailsAndAWin","content":"\n![2024-06-22-HowJavaWasBornTwoFailsAndAWin_0.png](/assets/img/2024-06-22-HowJavaWasBornTwoFailsAndAWin_0.png)\n\n# 자바 프로그래밍 언어의 역사는 모든 측면에서 놀라울 정도입니다. NFT와 마찬가지로 도박할 만큼 신뢰하기 어려운 언어가 실제로 많은 사람들이 많은 해 동안 믿었던 매우 타당한 이유로 성공했습니다.\n\n# 연구 프로젝트\n\n제임스 고슬링은 교수님이 연구소의 DEC VAX 컴퓨터에서 Pascal 앱을 실행하길 원했던, 아마도 Carnegie Mellon 대학교에서 공부하고 있을 때가 가장 가능성이 높습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n해당 작업을 수행하기 위해 그는 그것을 수행할 수 있는 가상 머신을 작성했습니다. 이 아이디어는 기본 시스템을 시뮬레이션하여 Pascal 앱이 적절한 머신에서 실행 중인 것으로 생각하게 한 다음 실제로는 또 다른 시스템에 의해 시뮬레이션된다는 것이었습니다.\n\n고슬링이 깨달은 것은 통합된 가상 머신이 있다면 앱이 해당 가상 머신을 구현하는 모든 시스템에서 실행할 수 있을 것이라는 것이기도 했습니다.\n\n몇 년 후, 이러한 경험들이 Java가 무엇으로 발전하는 데 영향을 끼쳤습니다.\n\n# Java & Interactive TV Fail (I)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nJava는 1991년 6월 (또는 출처에 따라 1994년)에 제임스 고슬링, 마이크 셰리던, 패트릭 나이튼에 의해 고안되었습니다.\n\n제임스 고슬링은 당시 Sun Microsystems에서 일하고 있었습니다.\n\n초기에는 Java가 인터랙티브 TV용으로 설계되었습니다. 이 아이디어는 실패했지만, 1998년에는 흥미로운 것으로 여겨졌습니다. 인터랙티브 TV 아이디어는 처음부터 성공 전망이 없었습니다:\n\nJava 창조자들은 오늘날에 우리가 보관 시스템 지원이라고 부르는 약속된 애플리케이션을 찾는 데 어려움을 겪었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nTVs에 대한 각도 조정이 실패하고 Java가 함께 실패할 수도 있습니다.\n\n회전이 필요했고 Sun Microsystems가 이미 무언가를 진행 중이었습니다.\n\n## Java & Browser Fail (II)\n\n여러 년 동안, Sun Microsystems는 Mosaic을 기반으로 한 HotJava라는 웹 브라우저를 출시했습니다. 이 브라우저는 Java로 작성되어 Java 애플릿을 처음으로 지원했습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그 때, 웹은 아주 어렸다는 걸 기억해야 했어요. 상호작용이 최대치인 웹사이트는 스크롤바와 텍스트 뒤에 정적인 배경만 있는 것이었죠.\n\n자바는 웹에 많은 장점을 제공했지만, HotJava는 제품으로 실패했지만 다른 브라우저 업체들이 자바를 지원하도록 이끈 요인이 되었어요.\n\n그때, 일이 와장창 되었어요.\n\n자바의 주요 단점은 속도가 굉장히 느리다는 것이었어요. 상호 운용성의 비용은 자바 애플릿이 로딩될 때 말 그대로 커피를 타면서 쉴 수 있는 정도였어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n하지만 이는 모어의 법칙이 적용되어 Java가 웹 애플리케이션의 표준이 될 것이라고 생각된다는 말이죠, 그렇죠?\n\n하지만 완전히 맞지는 않습니다. 마이크로소프트는 ActiveX를 만들었는데, 이것은 실패의 좋은 예입니다. HTML, JavaScript, CSS는 기능이 계속 증가하면서 더 많은 일을 할 수 있게 되었죠.\n\nJava의 주요 경쟁 상대는 Flash로 나타났습니다. 컴퓨터 그래픽 분야에서 시작된 브라우저 플러그인으로, 특히 애니메이션에 중점을 둔 것이 특징입니다.\n\nFlash는 웹을 강타하여 수 년간 애니메이션 웹사이트와 상당히 복잡한 게임을 구동했는데, Adobe가 이를 폐기할 때까지 계속되었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n하지만 그 당시, 수 년 동안 Java 애플릿은 저주받은 것처럼 보였어요. 플래시, JavaScript, ActiveX가 그 공간을 차지했죠.\n\n일부 상업용 Java 웹 프로젝트들은 Java가 안정성과 안전성을 제공하는 것으로 입증되었지만 다시 한 번 Java가 죽을 것처럼 보였어요.\n\n# 2024년 Java — 결국 두 번째로 인기 있는 언어. 왜일까요?\n\n프로그래밍 세계에 익숙하지 않은 대부분의 사람들은 브라우저 에피소드로부터 Java를 알게 되었고 Java가 실제로 죽은 줄 알고 있을 겁니다. 하지만 그것은 사실과 거리가 멀어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n자바는 실제로 2022년(그리고 분명히 2024년에도) 두 번째로 인기 있는 프로그래밍 언어이며, 사람들은 그 없이 엔지니어링을 상상할 수 없습니다.\n\n그렇다면 이건 어떻게 가능한 걸까요?\n\n자바는 대화식 TV와 웹에서는 실패했지만, 항상 범용 프로그래밍 언어로 사용할 수 있었습니다. 이것은 자바로 무엇이든 빌드할 수 있는 가능성을 제공했다는 것을 의미합니다. TV와 웹에 국한되지 않았다는 것이죠.\n\n오히려 TV와 웹은 자바 역사에서의 행운의 일부였습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이런 실패들이 있었지만, Java에 대한 인기가 올라가게 했습니다. Java는 항상 현대적인 트렌드의 선두에 있다고 광고되었는데, 이는 사람들이 서로 작업을 할 수 있고 잘 설계된 의미론이 다른 것에도 적용될 수 있다는 것을 알아차릴만큼 충분했던 것 같아요.\n\n결국 속도 문제는 빠른 기계의 도입으로 해결되었고, Java도 점점 빨라졌어요. 종종, Java를 로딩하는 초기 시간은 그리 중요하지 않습니다.\n\n다음은 몇 가지 흥미로운 하이라이트입니다:\n\n- 게임 산업: Minecraft는 Java로 작성되었습니다\n- 과학: Mastero Mars Rover 컨트롤러는 Java로 작성되었습니다\n- 클라우드 컴퓨팅: Hadoop은 Java로 작성되었습니다\n- 개발자 경험: IntelliJ IDEA는 Java로 작성되었습니다\n- 백엔드 개발: Spring, Hibernate는 Java로 작성되었습니다\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n지금은 Java가 사용되는 곳의 작은 부분일 뿐이에요.\n\nJava의 역사는 언어가 어떤 응용프로그램에서 실패하더라도, 실제 문제(상호 운용성)를 해결한다면 그에 맞는 곳에서 채택될 것이라는 것을 증명했어요.\n\n# 💎 보너스\n\nJava 시리즈의 이전 에피소드도 확인해보세요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Java Card Game](/assets/img/2024-06-22-HowJavaWasBornTwoFailsAndAWin_1.png)\n\n우와. 정말 Java에 관심이 많나봐요! 'Summon The JSON: Java' 라는 Java 카드 게임을 디자인했어요. 우연히도! 지금 주문하실 수 있어요!\n\nJava를 좋아하시나요? 소셜 미디어에서 박수를 보내고, 구독하고, 좋아요를 눌러주시고 공유해주세요!\n\nTom Smykowski를 따르는 10,000명의 개발자 중 하나가 되어보세요! 매달 $5를 내면 모든 Medium 기사에 액세스할 수 있고, Tom도 일부 수입을 얻게 되어 Java에 대해 더 많이 쓸 거에요! 지금 멤버십 가입하세요!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n또한, 모든 Java 애호가들과 창조자들을 환영하는 새로운 Java 프로그래밍 길드 그룹을 링크드인에서 가입해보세요!\n","ogImage":{"url":"/assets/img/2024-06-22-HowJavaWasBornTwoFailsAndAWin_0.png"},"coverImage":"/assets/img/2024-06-22-HowJavaWasBornTwoFailsAndAWin_0.png","tag":["Tech"],"readingTime":7},{"title":"요청당 스레드 VS WebFlux VS 가상 스레드 최신 비교","description":"","date":"2024-06-22 22:10","slug":"2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads","content":"\n# 개요\n\n이 분석은 전통적인 명령형 코딩의 성능을 차단된 스레드와 비교하면서 REST 서비스에서 HTTP 요청을 처리하는 두 가지 접근 방식을 비교합니다: 반응형 프레임워크인 Spring-WebFlux와 Spring 3.2에서 최근 소개된 가상 스레드. 우리는 WebFlux의 논블로킹 기능을 구체적으로 검토하고 가상 스레드에서 제공되는 내장 논블로킹 기능과 어떻게 비교되는지 살펴볼 것입니다.\n\n# 사용 사례\n\n세 가지 서비스가 동일한 기능을 수행하며 사용하는 프레임워크만 다릅니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_0.png)\n\n# 테스트 준비\n\n- 사용한 머신: AWS t3.micro (2 vCPU, 1 GiB RAM) 및 Amazon Linux 2023.\n- 사용한 HTTP 클라이언트: ThreadPerRequest 및 VirtualThread의 RestClient, WebFlux의 WebClient.\n- Spring Boot 버전: 3.2.0\n- Java 버전: v21\n- 부하 테스트에 사용한 도구: jMeter 및 VisualVM\n\n# 측정 매개변수\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래 기준을 사용하여 성능을 측정하고 접근법/프레임워크를 평가할 예정이에요:\n\n- 더 높은 처리량 값은 더 나은 성능을 나타냅니다.\n- 더 낮은 99백분위수 지연 시간은 더 나은 성능을 나타냅니다.\n- 최적의 리소스 활용은 더 나은 성능을 나타냅니다.\n\n# 로드 테스트 성능\n\n# 0번째 로드 테스트\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n사용자 수: 150\n램프업: 10\n지속 시간: 100초\n\n## 기계 성능\n\n![이미지 1](/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_1.png)\n\n![이미지 2](/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_2.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![ThreadPerRequestVSWebFluxVSVirtualThreads_3](/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_3.png)\n\n## ThroughPut\n\n![ThreadPerRequestVSWebFluxVSVirtualThreads_4](/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_4.png)\n\n![ThreadPerRequestVSWebFluxVSVirtualThreads_5](/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_5.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Latency](/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_6.png)\n\n![Chart 1](/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_7.png)\n\n![Chart 2](/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_8.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_9.png\" />\n\n# 1’st LoadTest\n\n사용자: 200\n램프업: 10\n지속시간: 100초\n\n## 기계 성능\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 Markdown 형식으로 변환한 텍스트입니다.\n\n![image1](/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_10.png)\n\n![image2](/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_11.png)\n\n![image3](/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_12.png)\n\n## ThroughPut\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![ThreadPerRequestVSWebFluxVSVirtualThreads_13](/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_13.png)\n\n![ThreadPerRequestVSWebFluxVSVirtualThreads_14](/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_14.png)\n\n![ThreadPerRequestVSWebFluxVSVirtualThreads_15](/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_15.png)\n\n## Latency\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![image 16](/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_16.png)\n\n![image 17](/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_17.png)\n\n![image 18](/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_18.png)\n\n# 2’th LoadTest\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n사용자: 300\nRampUp: 10\n지속 시간: 100초\n\n## 기계 성능\n\n![이미지 1](/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_19.png)\n\n![이미지 2](/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_20.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![ThroughPut](/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_22.png)\n\n![Image](/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_23.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![](/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_24.png)\n\n## Latency\n\n![](/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_25.png)\n\n![](/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_26.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_27.png\" />\n\n# 3번째 부하 테스트\n\n사용자 수: 500명\n램프업: 10초\n지속 시간: 100초\n\n## 기계 성능\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![그림 28](/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_28.png)\n\n![그림 29](/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_29.png)\n\n![그림 30](/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_30.png)\n\n## 처리량\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 Markdown 형식으로 표시한 내용입니다.\n\n![Image 1](/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_31.png)\n\n![Image 2](/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_32.png)\n\n![Image 3](/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_33.png)\n\n## Latency\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Image 1](/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_34.png)\n\n![Image 2](/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_35.png)\n\n![Image 3](/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_36.png)\n\n# Summary\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_37.png\" />\n\n위 테스트 결과를 토대로 제 개인적인 관찰을 통해 얻은 결론을 아래에 소개합니다. 이것은 제 개인적인 의견일 뿐입니다.\n\n- 동시 요청 수가 증가할수록 WebFlux가 처리량 측면에서 ThreadPerRequest와 Virtual Threads 모델보다 우수함을 보여줍니다.\n- 지연 시간 측면에서도 WebFlux가 약간 향상됩니다. 다만 처리량만큼 명확하게 드러나지는 않습니다.\n- 그러나 WebFlux의 지연 시간은 다른 모델의 간헐적인 짧은 피크와는 달리 안정적입니다.\n- CPU 사용량 측면에서, WebFlux는 저하되는 부하에서 ThreadPerRequest와 Virtual Threads보다 더 많은 CPU를 소비하는 경향이 있습니다. 그러나 부하가 증가할수록 WebFlux 간의 CPU 사용량은 비교 가능해집니다.\n- 힙 활용 측면에서도 ThreadPerRequest와 Virtual Threads가 더 많은 메모리를 사용하는 것으로 나타납니다.\n\n이러한 테스트 결과를 토대로 WebFlux가 우세함을 입증했습니다! 그러나 이 문서는 WebFlux를 Virtual Threads보다 우선시하도록 밀어붙이고자 하는 것이 아닙니다. 선택은 특정 프로젝트와 팀이 반응형 접근 방식에 친숙한지에 따라 다를 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_0.png"},"coverImage":"/assets/img/2024-06-22-ThreadPerRequestVSWebFluxVSVirtualThreads_0.png","tag":["Tech"],"readingTime":10},{"title":"2024년 자바 개발자 면접 합격을 위한 가이드","description":"","date":"2024-06-22 22:07","slug":"2024-06-22-YourGuidetoClearJavaDeveloperInterviewin2024","content":"\n안녕하세요, 제 7천 명 이상의 팔로워 여러분, 모든 지원에 감사드립니다. 그 회사의 감축 뉴스를 보게 되면 언제나 나는 면접 준비가 되어 있는 상태로 있어야 한다고 생각해요. 100회 이상의 인터뷰를 진행했고 100회 이상의 Java 인터뷰에 나갔어요. 그 경험을 토대로 이 글을 쓰게 되었어요. 나의 경험상으로, 각 MNC의 Java 인터뷰는 나중에 이 글에서 논의할 전형적인 패턴을 따르는 것을 알고 있어요. 충분한 인터뷰를 가졌다면, 매번 전형적인 Java 개발자 기술면접에서 질문과 주제가 항상 반복되는 것을 알 수 있을 거예요. 이 형식에 대해 이야기하고, 해당 주제에서 몇 가지 질문을 사용하여 왜 이러한 질문이 제기되는지 설명하고 모든 인터뷰에서 항상 반복될 것이라고 말할 거에요.\n\n![이미지](/assets/img/2024-06-22-YourGuidetoClearJavaDeveloperInterviewin2024_0.png)\n\n면접을 통과하는 것은 보통 두 가지 기술 면접 단계만 통과하는 것을 의미해요. 매니저나 HR과의 대화는 보통 쉬워요. 그러나 기술 면접에서 많은 사람들이 투쟁하는 부분이에요.\n\n회사들, 특히 대기업과 기술 기업은 보통 각 인터뷰 단계에 대해 약 1시간을 할애하곤 해요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n자바는 다루어야 할 내용이 많은 방대한 주제입니다. 기본 개념 외에도 인터뷰어들은 여러분의 프로젝트, 프로젝트 배포 방법, 코딩 과제, 주요 개념에 대한 이해, 그리고 클라우드 컴퓨팅, 쿠버네티스 및 기타 기술 도구 등에 대해 물어볼 가능성이 높습니다. 다뤄야 할 내용이 많습니다!\n\n인터뷰어들은 1시간 밖에 시간이 없으므로 중요한 내용에 집중하여 가능한 많은 영역을 다뤄보려고 할 것입니다.\n\n우리가 빛날 수 있는 부분은 잘 준비하고, 기본 개념을 이해하고, 코딩 능력을 향상시키면 이번 라운드를 통과할 수 있다는 것입니다. 흥미로운 점은 여러 질문들이 인터뷰에서 반복해서 나오는데, 특히 이전에 몇 차례 경험했거나 내 Java 시리즈를 따라온 경우입니다.\n\n그러니 기본 개념을 잘 이해하고 코딩 기술을 연습하는 데 집중해봅시다. 한 걸음씩 진행하며 각 주제를 철저히 다루겠습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n지금부터 60분의 시간이 시작됐어요. 인터뷰에서 다룰 주제마다 8-10분씩 할당해봅시다. 그리고 인터뷰어인 저가 어떤 종류의 질문들을 할지도 살펴봅시다.\n\n만약 여러분을 채용한다고 상상해봅시다.\n\n# 주제 1: 프로젝트 흐름과 아키텍처\n\n이 주제에서는 지원자가 경험이 있는지 판단하고 싶어요. 경험이 없다면, 프로젝트에 대해 질문을 시작할 거에요. 기능, 흐름, 아키텍처에 대해 물어보겠고, 사용된 기술 스택과 제품화된 방법, 그리고 역할과 기여도에 대해 물어볼 거에요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n일반적으로 면접에서 이렇게 질문이 나올 거에요,\n\n프로젝트에 관한 모든 내용을 적어두면 좋을 거예요. 자신을 자세히 알려야 하는데, 그러면 불편한 질문을 받지 않아요. 프로젝트에 관한 모든 내용을 아는 사람은 당신 뿐이니 자신감을 가지세요.\n\n# 주제 2: Core Java\n\nCore Java는 방대한 주제이며 인터뷰어는 이러한 주제에 집중해야 할 거에요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 영역에서 철저한 답변을 제공해보세요. Core Java는 Java 개발자에게 기본적인 것으로 간주됩니다. 어떤 프레임워크도 모른다고 해도 괜찮지만, Core Java 지식이 부족하면 문제가 발생할 수 있습니다.\n\n아래 주제들은 인터뷰에서 중요하게 다루는 것들입니다.\n\n## 주제:\n\n- 문자열 개념/해시 코드-동일성 메서드\n- 불변성(사용자 정의 불변 클래스 및 JDK에서의 예제)\n- 객체 지향 프로그래밍 개념(네 가지 기둥과 SOLID 원칙)\n- 직렬화(serialversionUUID)\n- 컬렉션 프레임워크/동시성 컬렉션(해시맵, 동시성 해시맵, 어레이리스트, 해시셋)\n- 예외 처리(특히 런타임 예외)\n- 멀티스레딩 특히 Executor 프레임워크(쓰레드 풀(데드락, 쓰레드 덤프) 포함)\n- Java 메모리 모델(객체, 메서드, 변수가 Java 메모리의 각 영역에 어떻게 저장되는지)\n- 가비지 컬렉션(작동 방식, 객체를 가비지 수집하는 방법, 수행하는 동안 사용되는 알고리즘)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저는 당신이 말씀하신 내용을 쉽게 참조할 수 있도록 Markdown 형식으로 변경하였습니다.\n\n## 질문:\n\nThreadPoolExecutor는 어떻게 동작하나요?\n커스텀 불변 클래스를 어떻게 만드나요? Java에서 불변 클래스의 예시는 무엇이 있나요?\nhashCode()와 equals()가 무엇인가요? Map에서 키로 Object를 사용할 경우 어떻게 될까요? 올바르게 사용하는 방법은 무엇인가요?\n깊은 복사와 얕은 복사는 무엇인가요?\nCompletableFuture는 무엇인가요?\n가장 최신 Java 버전에서의 Java 메모리 모델은 무엇인가요?\n동시성 컬렉션이 무엇인가요?\nHashMap, ArrayList, LinkedList의 시간/공간 복잡도는 무엇인가요?\nJava API Arrays.sort()와 Collections.sort()에서 사용되는 알고리즘은 무엇인가요?\nJava에서 커스텀 어노테이션을 어떻게 만드나요?\nCompletableFuture는 무엇인가요?\n깊은 복사와 얕은 복사는 무엇인가요?\nHashMap과 HashSet는 어떻게 내부적으로 동작하나요?\nString의 join() 메서드의 용도는 무엇인가요?\n\n아래 기사에 대부분의 질문이 있으니 참고해 주세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 주제 3: 자바-8/자바-11/자바-17\n\n새로 추가된 자바 API와 관련된 중요한 기능을 알고 있어야 합니다.\n\nJava8-java21에서 모든 기능을 문서화한 내 기사를 참조할 수 있어요.\n\n아래 주제들은 중요하며 면접에서 주로 다루는 내용입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 주제:\n\n- Java 8 기능\n- 기본/정적 메소드\n- 람다 표현식\n- 함수형 인터페이스\n- Optional API\n- Stream API\n- 패턴 매칭\n- 텍스트 블록\n- 모듈\n\n나중에 질문에 대답하려면 버전별 업데이트를 알아야 합니다. 여러분의 최신 정보를 테스트할 것입니다.\n\n가상 스레드 기능은 Java 21에 도입되었고, 봉인된 클래스는 Java 17에 도입되었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 질문:\n\nJava 8/Java11/Java17에서 무엇이 새로운가요?\nJava에서 병렬 스트림이 무엇이며 어떻게 작동하나요?\nJava 메모리 모델의 새로운 개선 사항은 무엇이며, Java 8 해시맵의 개선 사항은 무엇인가요?\n\n# 주제 4: 스프링 프레임워크, 스프링 부트, 마이크로서비스 및 REST API\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 또한 방대한 주제이기 때문에 기본부터 고급 반복 질문에 집중해야 합니다. Spring Framework, Spring Boot, Microservice 및 Rest API 에 대해 시험을 볼 것입니다.\n\n이 주제에 대해 인터뷰어를 만족시키지 못하면 거절될 수 있습니다.\n\n## 주제:\n\n- 의존성 주입/IOC, Spring MVC\n- 설정, 주석, CRUD 작업\n- Bean, 스코프, 프로파일, Bean 생명주기\n- App context/Bean context\n- AOP, 예외 처리기, 컨트롤 어드바이스\n- 보안(JWT, Oauth)\n- 액추에이터\n- WebFlux 및 Mono Framework\n- HTTP 메소드\n- Microservice 개념\n- Spring Cloud\n- JPA\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 질문:\n\n- 이러한 어노테이션 (@RequestMapping @RestController @Service @Repository @Entity)의 사용 목적은 무엇인가요?\n- 액추에이터(Actuator)와 그 사용법은 무엇인가요?\n- 어떻게 애플리케이션을 고장 허용하고 탄력적으로 만들 수 있나요?\n- 분산 추적이란 무엇인가요? 스프링 부트 어플리케이션에서 traceId와 spanId의 사용 목적은 무엇인가요?\n- 스프링 부트에서 WebFlux와 Mono 프레임워크란 무엇인가요?\n- 스프링에서 순환 종속성(cyclic dependency)이란 무엇이며, 어떻게 방지할 수 있나요?\n- REST API를 어떻게 보안할 수 있나요?\n- 분산 추적이란 무엇인가요? 스프링 부트 어플리케이션에서 traceId와 spanId의 사용 목적은 무엇인가요?\n- 스프링 부트에서 WebFlux와 Mono 프레임워크란 무엇인가요?\n- 애플리케이션을 고장 허용하고 탄력적으로 만드는 방법은 무엇인가요?\n- 스프링 부트 어플리케이션에서 자동 구성을 비활성화하는 방법은 무엇인가요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n관련 기사,\n\n## 주제 5: 하이버네이트/스프링 데이터 JPA/데이터베이스(SQL 또는 NoSQL)\n\n이 섹션은 하이버네이트 JPA 프레임워크가 등장하는 데이터 레이어에 관련됩니다. 만약 면접관이 데이터베이스 전문가라면, 그가 갖고 있는 지식 때문에 당신을 깊이 들어물 수도 있습니다.\n\n쿼리 작성에 대비해 주세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 알아야 할 주제는,\n\n- JPA 리포지토리\n- 엔티티 간의 관계\n- 직원 부서 쿼리, N번째 높은 급여 쿼리에 대한 SQL 쿼리\n- 관계형 및 비관계형 데이터베이스 개념\n- DB에서의 CRUD 작업\n- 조인, 인덱싱, 프로시저, 함수\n\n## 질문\n\nSQL과 NoSQL의 차이는 무엇인가요?\n데이터베이스에서 샤딩이란 무엇인가요?\nJPA란 무엇인가요?\n부모-자식 관계란 무엇인가요?\n조인이 무엇인가요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n해당 주제에 대해 더 많은 도움을 얻을 수 있는 관련 기사를 찾아보세요,\n\n## 주제 6: 코딩\n\n자바 코딩 라운드에서는 스트림 API를 사용하여 코드를 작성하는 데 더 많은 중점을 두기 때문에 아래에 몇 가지 스트림 관련 질문을 추가했습니다.\n\n면접에 가기 전에 연습을 해보세요. 연습을 충분히 하면 쉬운 문제일 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위 싱글 페이지는 관련 기사 몇 개를 담고 있어요.\n\n## 주제:\n\n- 스트림 API 코딩 질문\n- 문자열 및 배열과 관련된 일반 코딩 질문\n- Java API를 사용한 정렬 및 검색\n\n## 질문\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n배열에서 두 번째로 큰 요소를 찾는 프로그램을 작성하세요. 배열에는 중복 요소가 포함될 수 있습니다. Java 8 스트림을 사용하여 이 문제를 해결해보세요.\n\n스트림 API를 사용하여 주어진 문자열에서 중복 요소와 해당 발생 횟수를 찾아보세요.\n\nJava 스트림을 사용하여 주어진 문자열에서 첫 번째로 반복되지 않는 요소를 찾는 프로그램을 작성해보세요.\n\nJava 스트림을 사용하여 주어진 문자열에서 고유한 요소를 찾는 프로그램을 작성해보세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n주어진 배열에서 가장 긴 문자열을 찾는 프로그램을 작성해보세요.\n\n두 종류의 숫자를 배열에서 왼쪽과 오른쪽으로 정렬하는 프로그램을 작성해보세요. 예시: 정수 배열[] = [5, 5, 0, 5, 0] - 출력: [0, 0, 5, 5, 5]\n\nJava 스트림을 사용하여 주어진 문자열에서 첫 번째 반복 요소/문자를 찾는 프로그램을 작성해보세요.\n\n유효한 괄호를 위한 프로그램을 작성해보세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n스트림 API를 사용하여 문자열 목록에서 중복 문자를 찾는 WAP를 만들어 보세요.\n\n# 주제 7: 배포 도구에 대한 데브옵 질문(Kubernetes, 클라우드, Kafka, 캐시)\n\n이 유형의 주제는 대부분 매니저나 리드들이 많이 작업하는 것이기 때문에, 데브옵스/배포 관련 도구에 대해 물어볼 수 있습니다. Jenkins, Kubernetes, Kafka, 클라우드 등과 같은 일반적인 도구에 대한 이해가 필요합니다.\n\n## 질문:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n쿠버네티스에서 POD, ConfigMap, Node 및 클러스터란 무엇인가요?\n\n하이브리드 클라우드란 무엇인가요?\nApache Spark란 무엇인가요? Spring Boot 애플리케이션을 사용하는 사용 사례를 줄 수 있나요?\nKafka란 무엇인가요? 어떻게 작동하나요? 오프셋과 컨슈머 그룹은 무엇인가요?\n\n## 주제 8: 모범 사례(디자인 패턴/마이크로서비스 패턴)\n\n면접관은 항상 일부 디자인 패턴에 대해 묻고 싶어합니다. 이는 싱글톤, 팩토리 또는 옵저버 패턴과 같은 일반적인 디자인 패턴일 수 있으며 이러한 패턴을 코딩에 활용할 수 있는지 알아보기 위함입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n마이크로서비스는 요즘 많이 사용되고 있어요. 그런데 여기에는 회로 차단기, SAGA, CQRS, 이중 커밋, BFF 그리고 API 게이트웨이와 같이 다양한 유형의 패턴도 포함됩니다.\n\n이러한 패턴들은 흔히 사용되는데, 이 주제들로 충분히 이해를 하고 있으면 부가적인 이점이 있을 거예요. 미리 잘 준비해두세요.\n\n## 질문:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n싱글톤 디자인 패턴, 빌더 디자인 패턴 또는 퍼사드 디자인 패턴에 대해 알고 계신가요? 어떤 두 가지 일반적인 마이크로서비스 패턴을 사용해야 하는지 알려주세요. 이러한 주제들은 항상 반복되므로 준비하면 인터뷰의 마지막 부분을 쉽게 통과할 수 있습니다.\n\n참고용 관련 기사 몇 개,\n\n# 마지막으로\n\n모든 이러한 질문과 주제들은 모든 Java 인터뷰에서 반복되며, 면접관은 이러한 질문을 물어볼 1시간밖에 없습니다. 자주 반복되는 질문에 대해 준비하면 인터뷰를 쉽게 통과하고 일자리를 얻을 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n감사합니다! 자바 인터뷰에 대한 더 많은 질문과 주제가 필요하시면 제 책을 참고하시기 바랍니다. 모든 것을 문서화했습니다.\n\n또한, 어떤 주제나 질문이 각 인터뷰에서 중요하고 자주 반복되는지 알려주세요.\n\n# 읽어 주셔서 감사합니다!\n\n- 👏 이야기에 박수를 보내고 저를 팔로우해주세요 👉\n- 📰 제 Medium에서 더 많은 콘텐츠를 읽어보세요 (자바 개발자 인터뷰에 관한 50개의 이야기)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n제 책들을 찾아보세요:\n\n- Guide To Clear Java Developer Interview는 Amazon(Kindle Book) 및 Gumroad(PDF 형식)에서 찾을 수 있습니다.\n- Guide To Clear Spring-Boot Microservice Interview는 Gumroad(PDF 형식) 및 Amazon(Kindle eBook)에서 찾을 수 있습니다.\n- 🔔 Follow me: LinkedIn | Twitter | Youtube\n","ogImage":{"url":"/assets/img/2024-06-22-YourGuidetoClearJavaDeveloperInterviewin2024_0.png"},"coverImage":"/assets/img/2024-06-22-YourGuidetoClearJavaDeveloperInterviewin2024_0.png","tag":["Tech"],"readingTime":13},{"title":"Winglang을 사용해 클라우드로 이전하는 방법 1부","description":"","date":"2024-06-22 22:02","slug":"2024-06-22-PortedtoCloudwithWinglangPartOne","content":"\n## \"Hexagonal Architecture Explained\"에서 Blue Zone Application\n\n<img src=\"/assets/img/2024-06-22-PortedtoCloudwithWinglangPartOne_0.png\" />\n\n소프트웨어 애플리케이션을 직접 클라우드로 이관하면 종종 비효율적이고 유지보수가 어려운 코드가 될 수 있습니다. 그러나 새로운 클라우드 지향 프로그래밍 언어 Wing과 Hexagonal Architecture를 조합하여 사용하는 것은 성공적인 방법임이 입증되었습니다. 이 접근 방식은 비용, 성능, 유연성, 보안 사이에서 적절한 균형을 유지합니다.\n\n이 시리즈에서는 주요 프로그래밍 언어에서 Winglang로 다양한 애플리케이션을 마이그레이션하는 경험을 공유하겠습니다. Wing에서 Hexagonal Architecture를 구현한 첫 경험은 \"안녕, Winglang Hexagon!\"이라는 제목의 기사에 보고되었습니다. 이는 이러한 조합에 대한 신뢰를 얻기에 충분했으나 과도하게 단순화된 \"안녕하세요, 세계!\" 인사 서비스에 제한된 핵심 구성 요소가 부족하여 이러한 접근 방식의 확장 가능성을 입증하기에 충분하지 않았습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n제 첫 번째 파트에서는 최근 출간된 책 \"헥사곤 아키텍처 설명\"에 소개된 \"블루 존\" 애플리케이션을 자바에서 Wing으로 이식하는 데 초점을 맞추었습니다. \"블루 존\" 애플리케이션은 상당한 코드 베이스를 가져오는데, 복잡성이 해결하기 어려울 정도로 커지지 않아도 되지만, 많은 종류의 애플리케이션을 대표하는 것입니다. 또한, 이것이 기존의 주류 자바로 작성된 것이라는 사실은 이러한 애플리케이션의 클라우드 네이티브 변형 사례 연구를 제공합니다.\n\n본 보고서는 2024년 4월에 안타깝게도 사망한 이 책의 공저자인 후안 마누엘 가리도 데 파스에 대한 경의의 표시로도 작용합니다.\n\n계속 진행하기 전에, 헥사곤 아키텍처 패턴의 기초를 다시 한 번 상기해 봅시다.\n\n# 헥사곤 아키텍처 패턴 핵심요소\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n“Hexagonal Architecture Explained” 책의 두 번째 장을 참고하여 패턴에 대한 자세하고 공식적인 설명을 보실 수 있습니다. 여기서는 제가 제 나만의 말로 이 패턴의 주된 의미를 간략히 요약해서 전달하겠습니다.\n\nHexagonal Architecture 패턴은 소프트웨어에서 관심사를 분리하는 간단하면서도 실용적인 접근 방법을 제안합니다. 관심사 분리가 왜 중요한가요? delivered value 앱의 경우에도 소프트웨어 코드 기반은 빠르게 성장합니다. 책임을 질 일이 많기 때문입니다. 인지적 제어를 유지하려면 그룹이나 범주에 대한 고수준 조직이 필요합니다. 이 도전에 맞서기 위해 Hexagonal Architecture 패턴은 특정 소프트웨어 애플리케이션에 참여하는 모든 요소를 다섯 가지의 구분된 범주로 분리하고 각각을 따로 다루는 것을 제안합니다:\n\n- Application 자신. 이 범주는 잠재적인 고객 및 사용자들에게 전달되는 실제 가치를 캡슐화합니다. 이것은 소프트웨어가 처음 개발되고 사용될 이유입니다. 때로는 Core 또는 System Under Development (SuD)로 불리기도 합니다. 이 부분에 대한 또 다른 가능한 이름은 Computation일 수 있습니다 — 외부 입력이 처리되고 최종 결과가 생성되는 곳입니다. 시각적으로, 시스템의 Application 부분은 육각형의 형태로 나타납니다. 이 모양에는 특별하거나 마법 같은 것은 없습니다. \"Hexagonal Architecture Explained\" 책의 저자들이 설명하듯이:\n\n2. Application과 통신하거나 통신되는 외부 주체. 이들은 인간 최종 사용자, 전자 장치 또는 다른 애플리케이션일 수 있습니다. 원래 패턴은 더 나아가 제안하듯이 Primary (또는 Driving) Actors — Application과 상호 작용을 시작하는 주체들과 Secondary (또는 Driven) Actors — Application이 통신을 시작하는 주체들로 나뉘어야 한다고 제안합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n3. 포트 — 주요 작용자가 사용할 수 있는 인터페이스의 공식 명세(드라이빙 포트라고도 함) 또는 보조 작용자가 구현해야 하는 인터페이스의 공식 명세(드리븐 포트라고도 함)를 가리킵니다. 포트는 인터페이스 동사(예: 주차 티켓 구매)의 공식 명세 외에 이러한 인터페이스를 통해 교환되는 데이터 구조에 대한 자세한 명세도 제공합니다.\n\n4. 어댑터는 외부 작용자와 포트 사이의 간격을 메꾸는 역할을 합니다. 이름에서 알 수 있듯이, 어댑터는 의미 있는 계산을 수행하는 것이 아니라, 기본적으로 작용자가 이해하는 형식으로 데이터를 변환하거나 응용 프로그램이 이해하는 형식으로 데이터를 변환하는 역할을 합니다.\n\n5. 구성자는 외부 작용자를 모든 포트를 통해 응용 프로그램에 연결함으로써 해당 어댑터를 사용하는 것을 통해 모든 것을 통합합니다. 적용된 아키텍처 결정과 가격/성능/유연성 요구 사항을 고려한 특정 구성은 응용 프로그램 배포 전 정적으로 생성되거나 응용 프로그램 실행 중 동적으로 생성될 수 있습니다.\n\n일반적인 신념과는 달리, 이 패턴은 한 범주, 예를 들어 응용 프로그램이 다른 것보다 중요하다는 것을 의미하지 않으며, 다른 것들보다 크거나 작아야 한다는 결론을 내리지도 않습니다. 포트와 어댑터가 없으면 어떤 응용 프로그램도 실용적으로 사용할 수 없습니다. 상대적 크기는 확장성, 성능, 비용, 가용성 및 보안과 같은 비기능 요구 사항에 의해 종종 결정됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n패턴은 한 번에 한 문제에 집중함으로써 복잡성과 위험을 줄이는 것을 제안하며, 다른 측면은 일시적으로 무시하는 것을 시사합니다. 또한 동일한 계산에 대한 여러 구성을 보장하는 실용적인 방법을 제안합니다. 각각이 몇 가지 특정 요구 사항을 해결하는 테스트 자동화 또는 다른 환경에서의 작업일 수 있습니다.\n\n아래 그림은 \"Hexagonal Architecture Explained\" 책에서 이 패턴의 모든 주요 요소를 잘 요약하고 있습니다:\n\n![Hexagonal Architecture](/assets/img/2024-06-22-PortedtoCloudwithWinglangPartOne_1.png)\n\n# \"블루 존\" 샘플 애플리케이션\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n애플리케이션 README에서:\n\n저는 이 애플리케이션을 선택한 이유가 두 가지 있습니다. 첫째로, \"Hexagonal Architecture Explained\" 책에서 권장하는 대표적인 예제로 소개되었기 때문입니다. 둘째로, 이 애플리케이션은 원래 Java로 개발되었습니다. 저는 Wing 프로그래밍 언어를 사용하여 다소 복잡한 Java 애플리케이션을 클라우드로 포팅하는 과정이 어떤 것인지 궁금했습니다.\n\n# 어디서부터 시작하면 좋을까요?\n\n\"Hexagonal Architecture Explained\" 책은 4.9장 \"개발 순서는 무엇인가?\"에서 합리적인 권장 사항을 제공합니다. \"테스트부터 테스트\"로 시작하고 더 나아가는 것이 타당합니다. 그러나 대부분의 소프트웨어 엔지니어들이 일반적으로 하는 것처럼, 저는 Java 코드를 Wing으로 번역하는 것부터 시작했습니다. 일부분의 시간을 할애하여 지금까지 외부 인터페이스를 시뮬레이션하면서 로컬에서 Wing에서 작동하는 것을 얻었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n기술적으로는 작동했지만, 결과 코드는 응용 프로그램의 크기와 관련하여 너무 크고, 심지어 저에게도 이해하기 어려웠으며, 미적으로 매력이 없었으며, 완전히 Wing 언어와 클라우드 환경의 특성과 부합하지 않았습니다. 그 후, 나는 Wing 언어와 클라우드 환경의 특정 사항에 적합한 핵심 패턴 아이디어의 가장 의미있는 표현을 찾기 위해 두 주간의 리팩토링 주기에 착수했습니다.\n\n다음이 나의 작업 방식과는 다릅니다. 대부분의 코드를 생성, 평가하고 폐기하는 엄청난 규모의 혼돈의 왕래 시리즈가 이어집니다. 이것은 주로 생소한 기술과 영역을 다룰 때 소프트웨어 개발에서 발생합니다.\n\n마침내 더 구조화되고 시스템적인 과정으로 단계적으로 표준화될 수 있는 무언가를 찾았습니다. 다음에 더 괴로운 경험이 아니라 더 생산적일 것으로 기대됩니다. 그러므로, 다음에 사용될 것으로 기대되는 개념적으로 바람직한 순서대로 결과를 제시할 것이며, 실제로 일어난 방식으로 제시하지는 않을 것입니다.\n\n# 먼저 테스트로 시작하라# Thou Shalt Start with Tests\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n더 정확하고 최적의 방법은 체계적인 수용 테스트의 연속으로 시작하는 것입니다. 시스템의 아키텍처적으로 중요한 사용 사례에 관한 5.1 장 \"헥사고널 아키텍처 설명\" 책은 사용 사례 모델링과 헥사고널 아키텍처 간의 깊은 관련성을 자세히 다룹니다. 주의 깊게 읽어볼 가치가 있습니다.\n\n이전 문장조차 100% 정확하지는 않습니다. 우리는 기본 외부 작용자와 그들이 시스템과 가장 특징적인 상호 작용 방법을 식별하여 시작해야 합니다. \"블루 존\" 애플리케이션의 경우, 두 가지 주요 외부 작용자가 있습니다:\n\n- 차 운전사\n- 주차 담당자\n\n차 운전사 작용자의 경우, 주요 사용 사례는 \"티켓 구매\"일 것이며, 주차 담당자의 경우, 주요 사용 사례는 \"차량 확인\"일 것입니다. 이러한 사용 사례의 구현을 통해 보조 외부 작용자와 나머지 요소를 식별할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 분석에서 나온 예비 사용 사례 모델은 아래에 제시되었습니다:\n\n![사진](/assets/img/2024-06-22-PortedtoCloudwithWinglangPartOne_2.png)\n\n위 다이어그램에는 하나의 보조 작용자인 결제 서비스만 포함되어 있음을 주목해 주세요. 데이터베이스와 같은 내부 보조 작용자는 포함되어 있지 않습니다. 이러한 기술 요소들은 곧 Driven Ports에 의해 애플리케이션에서 격리될 예정이지만, 적어도 전통적인 Use Case 작용자 해석에서는 Use Case 외부 작용자를 대표하지 않습니다.\n\n개발을 시작하기 전에 사용 사례 수락 기준을 명시하는 것은 내부 리팩터링을 수행하면서 시스템 안정성을 보장하는 매우 효과적인 기술입니다. \"블루 존\" 애플리케이션의 경우, 사용 사례 수락 테스트는 자바 프레임워크인 Cucumber를 사용하여 Gherkin 언어로 지정되었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n현재 Wing을 위한 Cucumber 프레임워크는 당연한 이유로 존재하지 않습니다 - Wing은 매우 젊은 언어이기 때문입니다. JavaScript용 공식 Cucumber가 존재하고 TypeScript Cucumber 튜토리얼도 있지만, 이 기술에 대한 조사를 연기하고 직접 Wing에서 몇 가지 테스트를 재현해보기로 결정했습니다.\n\n놀랍게도, 이것이 가능했고 제 목적에는 잘 작동했습니다. 다음은 Wing에서 완전히 지정된 Buy Ticket use case happy path 수용 테스트의 예시입니다:\n\n```js\nbring \"../src\" as src;\nbring \"./steps\" as steps;\n\n/*\nUse Case: Buy Ticket\n  AS\n  a car driver\n  I WANT TO\n  a) obtain a list of available rates\n  b) submit a \"buy a ticket\" request with the selected rate\n  SO THAT\n  I can park the car without being fined\n*/\nlet _configurator = new src.Configurator(\"BuyTicketFeatureTest\");\nlet _testFixture = _configurator.getForAdministering();\nlet _systemUnderTest = _configurator.getForParkingCars();\nlet _ = new steps.BuyTicketTestSteps(_testFixture, _systemUnderTest);\n\ntest \"Buy ticket for 2 hours; no error\" {\n    /* Given */\n        [\"name\",    \"eurosPerHour\"],\n        [\"Blue\",    \"0.80\"],\n        [\"Green\",   \"0.85\"],\n        [\"Orange\",  \"0.75\"]\n    ]);\n    _.next_ticket_code_is(\"1234567890\");\n    _.current_datetime_is(\"2024/01/02 17:00\");\n    _.no_error_occurs_while_paying();\n    /* When */\n    _.I_do_a_get_available_rates_request();\n    /* Then */\n    _.I_should_obtain_these_rates([\n        [\"name\",    \"eurosPerHour\"],\n        [\"Blue\",    \"0.80\"],\n        [\"Green\",   \"0.85\"],\n        [\"Orange\",  \"0.75\"]\n    ]);\n    /* When */\n    _.I_submit_this_buy_ticket_request([\n        [\"carPlate\", \"rateName\", \"euros\", \"card\"],\n        [\"6989GPJ\",  \"Green\",    \"1.70\",  \"1234567890123456-123-062027\"]\n    ]);\n    /* Then */\n    _.this_pay_request_should_have_been_done([\n        [\"euros\", \"card\"],\n        [\"1.70\",  \"1234567890123456-123-062027\"]\n    ]);\n    /* And */\n    _.this_ticket_should_be_returned([\n        [\"ticketCode\", \"carPlate\", \"rateName\", \"startingDateTime\", \"endingDateTime\",   \"price\"],\n        [\"1234567890\", \"6989GPJ\",  \"Green\",    \"2024/01/02 17:00\", \"2024/01/02 19:00\", \"1.70\"]\n    ]);\n    /* And */\n    _.the_buy_ticket_response_should_be_the_ticket_stored_with_code(\"1234567890\");\n}\n```\n\n진정한 읽기 쉬운 텍스트는 아니지만 충분히 가깝고 이해하기 어렵지 않습니다. 여기서 해독할 사항이 꽤 많이 있습니다. 하나씩 진행해 봅시다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 테스트 구조\n\n위의 테스트는 특정 프로젝트 폴더 구조를 가정하고 있으며 Wing 모듈 및 가져오기 규칙을 반영하고 있습니다.\n\n테스트 소스의 처음 두 줄로부터 우리는 프로젝트에는 src 폴더(모든 소스 코드가 위치하는 곳)와 test 폴더(모든 테스트가 위치하는 곳) 두 가지 주요 폴더가 있다는 결론을 내릴 수 있습니다. 더 나아가 test\\steps 하위 폴더에는 개별 테스트 단계 구현이 보관되어 있습니다.\n\n테스트 소스의 다음 세 줄에서는 preflight Configurator 객체를 할당하고 이를 통해 두 개의 포인터를 추출합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- \\_testFixture는 테스트 설정을 담당하는 사전 점검 클래스를 가리킵니다.\n- \\_systemUnderTest는 운전자를 위한 주 포트 인터페이스를 가리킵니다.\n\n다음으로, 우리는 개별 단계를 구현하는 inflight BuyTicketTestSteps 객체를 할당합니다. 이 객체는 대부분 보이지 않는 언더스코어 이름을 갖게 되며, 이는 전체 테스트 가독성을 향상시킵니다. 이는 일반 목적의 호스트 언어에 내장된 도메인 특화 언어(DSL)를 개발하는 일반적인 기술입니다.\n\n중요한 점은, 제 경우에는 그렇지 않았지만, 단순한 src 및 test\\steps 폴더 구조와 다른 구조적 결정을 이끌 수 있는 간단한 테스트 설정으로 프로젝트를 시작하는 것이 전혀 상상 가능하다는 것입니다.\n\n물론, 단계가 구현되지 않았다면 테스트는 컴파일에도 통과하지 않을 것입니다. 진행하기 위해, 우리는 BuyTicketTestSteps 클래스 내부를 살펴봐야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 테스트 단계 클래스\n\n\"티켓 구매\" 유스 케이스를 위한 테스트 단계 클래스가 아래와 같이 나와 있습니다:\n\n```js\nbring expect;\nbring \"./Parser.w\" as parse;\nbring \"./TestStepsBase.w\" as base;\nbring \"../../src/application/ports\" as ports;\n\n\npub class BuyTicketTestSteps extends base.TestStepsBase {\n    _systemUnderTest: ports.ForParkingCars;\n    inflight var _currentAvailableRates: Set<ports.Rate>;\n    inflight var _currentBoughtTicket: ports.Ticket?;\n\n    new(\n        testFixture: ports.ForAdministering,\n        systemUnderTest: ports.ForParkingCars\n    ) {\n        super(testFixture);\n        this._systemUnderTest = systemUnderTest;\n    }\n\n    inflight new() {\n        this._currentBoughtTicket = nil;\n        this._currentAvailableRates = Set<ports.Rate>[];\n    }\n\n    pub inflight the_existing_rates_in_the_repository_are(\n        sRates: Array<Array<str>>\n    ): void {\n        this.testFixture.initializeRates(parse.Rates(sRates).toArray());\n    }\n\n    pub inflight next_ticket_code_is(ticketCode: str): void {\n        this.testFixture.changeNextTicketCode(ticketCode);\n    }\n\n    pub inflight no_error_occurs_while_paying(): void {\n        this.testFixture.setPaymentError(ports.PaymentError.NONE);\n    }\n\n    pub inflight I_do_a_get_available_rates_request(): void {\n        this._currentAvailableRates = this._systemUnderTest.getAvailableRates();\n    }\n\n    pub inflight I_should_obtain_these_rates(sRates: Array<Array<str>>): void {\n        let expected = parse.Rates(sRates);\n        expect.equal(this._currentAvailableRates, expected);\n    }\n\n    pub inflight I_submit_this_buy_ticket_request(sRequest: Array<Array<str>>): void {\n        let request = parse.BuyRequest(sRequest);\n        this.setCurrentThrownException(nil);\n        this._currentBoughtTicket = nil;\n        try {\n            this._currentBoughtTicket = this._systemUnderTest.buyTicket(request);\n        } catch err {\n            this.setCurrentThrownException(err);\n        }\n    }\n\n    pub inflight this_ticket_should_be_returned(sTicket: Array<Array<str>>): void {\n        let sTicketFull = Array<Array<str>>[\n            sTicket.at(0).concat([\"paymentId\"]),\n            sTicket.at(1).concat([this.testFixture.getLastPayResponse()])\n        ];\n        let expected = parse.Ticket(sTicketFull);\n        expect.equal(this._currentBoughtTicket, expected);\n    }\n\n    pub inflight this_pay_request_should_have_been_done(sRequest: Array<Array<str>>): void {\n        let expected = parse.PayRequest(sRequest);\n        let actual = this.testFixture.getLastPayRequest();\n        expect.equal(actual, expected);\n    }\n\n    pub inflight the_buy_ticket_response_should_be_the_ticket_stored_with_code(code: str): void {\n        let actual = this.testFixture.getStoredTicket(code);\n        expect.equal(actual, this._currentBoughtTicket);\n    }\n\n    pub inflight an_error_occurs_while_paying(error: str): void {\n        this.testFixture.setPaymentError(parse.PaymentError(error));\n    }\n\n    pub inflight a_PayErrorException_with_the_error_code_that_occurred_should_have_been_thrown(code: str): void {\n        //TODO: make it more specific\n        let err = this.getCurrentThrownException()!;\n        log(err);\n        expect.ok(err.contains(code));\n    }\n\n    pub inflight no_ticket_with_code_should_have_been_stored(code: str): void {\n        try {\n            this.testFixture.getStoredTicket(code);\n            expect.ok(false, \"Should never get there\");\n        } catch err {\n            expect.ok(err.contains(\"KeyError\"));\n        }\n    }\n}\n```\n\n이 클래스는 데이터를 파싱하여 구체적인 애플리케이션 데이터 구조로 통일하고, 테스트Fixture 또는\\_systemUnderTest 객체로 데이터를 보내고, 중간 결과를 유지하며, 적절한 경우 예상 대비 실제 결과를 비교합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n유의해야 할 유일한 구체적인 사항은 프리플라이트 및 인플라이트 정의를 올바르게 처리하는 것입니다. 이를 올바르게 만들도록 도와준 Cristian Pallares에게 감사드립니다.\n\n우리는 명확히 구분된 책임을 갖는 세 가지 추가 요소가 있습니다:\n\n- 파서 — 일관된 문자열 입력 배열을 애플리케이션 특정 데이터 구조로 변환하는 데 책임이 있습니다.\n- 테스트 픽스처 — 전제 조건 설정 및 사후 상태 확인을 위해 시스템과의 비공식적인 통신을 담당합니다.\n- 테스트 대상 시스템 — 애플리케이션 로직을 구현하는 데 책임이 있습니다.\n\n각각을 좀 더 자세히 살펴봅시다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 파서\n\nParser 모듈의 소스 코드는 아래에 제시되어 있습니다:\n\n```js\nbring structx;\nbring datetimex;\nbring \"../../src/application/ports\" as ports;\n\n\npub class Util {\n    pub inflight static Rates(sRates: Array<Array<str>>): Set<ports.Rate> {\n        return unsafeCast(\n            structx.fromFieldArray(\n                sRates,\n                ports.Rate.schema()\n            )\n        );\n    }\n\n    pub inflight static BuyRequest(\n     sRequest: Array<Array<str>>\n   ): ports.BuyTicketRequest {\n        let requestSet: Set<ports.BuyTicketRequest> = unsafeCast(\n            structx.fromFieldArray(\n                sRequest,\n                ports.BuyTicketRequest.schema()\n            )\n        );\n        return requestSet.toArray().at(0);\n    }\n\n    pub inflight static Tickets(\n     sTickets: Array<Array<str>>\n   ): Set<ports.Ticket> {\n        return unsafeCast(\n            structx.fromFieldArray(\n                sTickets,\n                ports.Ticket.schema(),\n                datetimex.DatetimeFormat.YYYYMMDD_HHMM\n            )\n        );\n    }\n\n    pub inflight static Ticket(sTicket: Array<Array<str>>): ports.Ticket {\n        return Util.Tickets(sTicket).toArray().at(0);\n    }\n\n    pub inflight static PayRequest(\n     sRequest: Array<Array<str>>\n   ): ports.PayRequest {\n        let requestSet: Set<ports.PayRequest> = unsafeCast(\n            structx.fromFieldArray(\n                sRequest,\n                ports.PayRequest.schema()\n            )\n        );\n        return requestSet.toArray().at(0);\n    }\n\n    pub inflight static CheckCarRequest(\n     sRequest: Array<Array<str>>\n   ): ports.CheckCarRequest {\n        let requestSet: Set<ports.CheckCarRequest> = unsafeCast(\n            structx.fromFieldArray(\n                sRequest,\n                ports.CheckCarRequest.schema()\n            )\n        );\n        return requestSet.toArray().at(0);\n    }\n\n    pub inflight static CheckCarResult(\n     sResult: Array<Array<str>>\n   ): ports.CheckCarResult {\n        let resultSet: Set<ports.CheckCarResult> = unsafeCast(\n            structx.fromFieldArray(\n                sResult, ports.CheckCarResult.schema()\n            )\n        );\n        return resultSet.toArray().at(0);\n    }\n\n    pub inflight static DateTime(dateTime: str): std.Datetime {\n        return datetimex.parse(\n            dateTime,\n            datetimex.DatetimeFormat.YYYYMMDD_HHMM\n        );\n    }\n\n    pub inflight static PaymentError(error: str): ports.PaymentError {\n        return Map<ports.PaymentError>{\n            \"NONE\" => ports.PaymentError.NONE,\n            \"GENERIC_ERROR\" => ports.PaymentError.GENERIC_ERROR,\n            \"CARD_DECLINED\" => ports.PaymentError.CARD_DECLINED\n        }.get(error);\n    }\n}\n```\n\n이 클래스는 알고리즘적인 관점에서는 정교하지 않지만, 아주 중요한 아키텍처 결정을 반영하고 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n먼저, 시스템 Ports에 대한 의존성을 src\\\\application\\ports 폴더에 위치한 것으로 발표합니다. \"헥사고널 아키텍처 설명\" 책 4.8장인 \"내 파일을 어디에 넣어야 하나요?\"는 명확한 문장을 제시합니다.\n\n그러나 \"패턴의 의도와 일치하지 않는 폴더 구조는 손해를 입히는 결과를 초래한다\"고 경고합니다. Java와 같은 강력한 타입 언어의 경우, 주행 및 주행되는 포트의 명세를 별도의 폴더에 유지하는 것을 권장합니다.\n\n저는 이러한 구조로 시작했지만, 매우 빨리 코드의 크기를 증가시키고 Wing 모듈과 import 규칙을 완전히 활용하지 못하게 만든다는 것을 깨달았습니다. 이를 고려하여 모든 포트를 하나의 전용 폴더에 유지하기로 결정했습니다. 현재 애플리케이션의 규모를 고려할 때, 이 결정은 정당화된 것으로 보입니다.\n\n둘째, 클래스 이름이 Util인 클래스의 모든 public static inflight 메서드를 고객 모듈이 직접 액세스할 수 있는 특정 Wing 모듈 및 import 기능을 활용하여 코드 가독성을 향상시킵니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nThird, it uses two Wing Standard Library extensions, datetimex, and structx, which were developed to compensate for some features I needed. These extensions were part of my “In Search for Winglang Middleware” project endor.w, which I reported about here, here, and here.\n\nJustification for these extensions will be clarified when we look at the core architectural decision about representing the Port Interfaces and Data.\n\n# Representing Port Interfaces and Data\n\nTraditional strongly typed Object-Oriented languages like Java advocate encapsulating all domain elements as objects. If I followed this advice, the Ticket object would look something like this:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\npub inflight class Ticket {\n  pub ticketCode: str;\n  pub carPlate: str;\n  pub rateName: str;\n  pub startingDateTime: std.Datetime;\n  pub endingDateTime: std.Datetime;\n  pub price: num;\n  pub paymentId: str;\n\n  new (ticketCode: str, ...) {\n    this.ticketCode = ticketCode;\n    ...\n  }\n  pub toJson(): Json {\n    return Json {\n       ticketCode: this.ticketCode,\n       ...\n  }\n  pub static fromJson(data: Json): Ticket {\n    return new Ticket(\n      data.get(\"ticketCode\").asStr(),\n      ...\n   );\n  }\n  pub toFieldArray(): Array<str> {\n    return [\n      this.ticketCode,\n      ...\n    ];\n  }\n  pub static fromFieldArray(records: Array<Array<str>>): Set<Ticket> {\n    let result = new MutSet<Ticket>[];\n    for record in records {\n      result.add(new Ticket(\n        record.at(0),\n        ...\n      );\n    }\n    return result.copy();\n }\n}\n```\n\n이러한 방식으로 데이터 필드 당 초기화 및 변환을 위해 코드 줄을 6줄 추가하는 것 외에도 일정한 메서드 정의의 오버헤드가 생깁니다. 이는 상당한 보일러플레이트 오버헤드를 만듭니다.\n\n자바 및 파이썬과 같은 대중적 언어들은 데코레이터, 추상 기본 클래스 또는 메타 클래스와 같은 다양한 메타 프로그래밍 자동화 도구로 이러한 문제를 완화하려고 노력합니다.\n\nWing에서는 Wing 표준 라이브러리에 소규모 조정을 가하여, 이러한 모든 접근 방식이 비효율적이고 불필요하다는 것이 입증되었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n티켓 데이터 구조는 다음과 같이 정의될 수 있습니다:\n\n```js\npub struct Ticket {                 //객체 데이터를 나타내는 데이터 구조\n                                    //주차 티켓의 데이터 포함:\n    ticketCode: str;                //티켓의 고유 식별자;\n                                    //필요한 경우 선행 0이 포함된 10자리 숫자\n    carPlate: str;                  //주차된 차량의 번호판\n    rateName: str;                  //주차된 위치의 요금 이름\n    startingDateTime: std.Datetime; //주차 기간이 시작되는 시간\n    endingDateTime: std.Datetime;   //주차 기간이 종료되는 시간\n    price: num;                     //티켓을 위해 지불한 유로 액수\n    paymentId: str;                 //티켓을 얻기 위해 한 결제의 고유 식별자.\n}\n```\n\n## 주차차량을 위한 ForParkingCars Port\n\n\"Hexagonal Architecture Explained\" 책의 권장에 따라 포트 네이밍은 `ActorName`에 대해 For`ActorName` 규칙을 따릅니다. 여기 주차 차량 외부 엑터를 위해 정의된 내용입니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```rust\npub struct BuyTicketRequest {  // 차 티켓을 구매하는 데 필요한 입력 데이터:\n  carPlate: str;    // 주차된 차량의 차량 번호판\n    rateName: str;  // 주차된 지역의 요금 이름\n    euros: num;     // 지불할 유로 액수\n    card: str;      // 지불에 사용되는 카드, 'n-c-mmyyyy' 형식으로\n                    // 'n'은 카드 번호(16자리)\n                    // 'c'는 확인 코드(3자리),\n                    // 'mmyyyy'는 만료 월 및 연도(6자리)\n}\n\n\n/**\n * DRIVING PORT (제공된 인터페이스)\n */\npub inflight interface ForParkingCars {\n /**\n  * 도시의 규제된 지역에서 차를 주차할 수 있는 요금 목록을 가져옵니다.\n  * 요금이 없는 경우 빈 세트가 반환됩니다.\n  */\n getAvailableRates(): Set<rate.Rate>;\n\n /**\n  * 요금을 지불하여 요금이 부과된 지역에 차를 주차하고\n  * 티켓을 저장합니다. 티켓의 유효 기간은 현재 일시에서 시작하며,\n  * 유로 지불 금액을 기반으로 요금을 적용하여 분 단위로 계산됩니다.\n  * @param request 차 티켓 구매에 필요한 입력 데이터.\n  *      @see BuyTicketRequest\n  * @return 요금이 부과된 지역에서 차를 주차하기 위한 유효한 티켓,\n  *    카드를 사용하여 유로 금액을 지불합니다.\n  *    티켓은 지불의 식별자에 대한 참조를 유지합니다.\n  * @throws BuyTicketRequestException\n  *    요청의 입력 데이터가 유효하지 않은 경우.\n  * @throws PayErrorException\n  *    지불 중 오류가 발생한 경우.\n  */\n buyTicket (request: BuyTicketRequest): ticket.Ticket;\n}\n```\n\n티켓 및 요금 객체와 마찬가지로 BuyTicketRequest 객체는 자동 변환 인프라에 의존하는 일반 Wing 구조체로 정의됩니다.\n\nForParkingCars는 Wing 인터페이스로 정의됩니다. 원래의 \"Blue Zone\" 구현과 달리 이 구현은 포트 사양에 BuyTicketRequest 유효성 검사를 포함하지 않습니다. 이것은 일부러 이루어졌습니다.\n\n강력한 객체 캡슐화는 validate() 메소드를 BuyTicketRequest 클래스에 포함시키는 것을 권장하지만, 여기서 채택된 개방형 불변 데이터 구조와 같은 상황에서는 관련 use case 구현에 해당 로직을 포함시키는 것이 좋습니다. 그 반면, 포트 사양에 요청 유효성 검사 로직을 포함하면 너무 많은 구현 세부 사항이 너무 일찍 들어가게 됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 관리 포트 사용법\n\n이 기능은 testFixture 기능을 제공하기 위해 사용되며 길지만 완전히 직관적입니다:\n\n```js\nbring \"./Rate.w\" as rate;\nbring \"./Ticket.w\" as ticket;\nbring \"./ForPaying.w\" as forPaying;\n\n\n/**\n * 운전 포트 (제공되는 인터페이스)\n * 초기화, 저장소에 데이터 로드, 앱에서 사용하는 서비스 구성 등과 같은 관리 작업 수행에 사용됩니다.\n * 일반적으로 사용되는 곳:\n *      - 테스트 (운전 액터)에서 테스트 픽처(구동 액터)를 설정하는 데\n *      - 앱 초기화를 시작하는 데\n */\n pub inflight interface ForAdministering {\n\n    /**\n    * 주어진 요율을 데이터 저장소에 로드하고,\n    * 이전에 있는 요율은 삭제합니다.\n    */\n    initializeRates(newRates: Array<rate.Rate>): void;\n\n    /**\n    * 주어진 티켓을 데이터 저장소에 로드하고,\n    * 이전에 있는 티켓은 삭제합니다.\n    */\n    initializeTickets(newTickets: Array<ticket.Ticket>): void;\n\n    /**\n    * 주어진 티켓 코드를 요청 시 반환될 다음 코드로 지정합니다.\n    */\n    changeNextTicketCode(newNextTicketCode: str): void;\n\n    /**\n    * 주어진 코드로 저장소에 있는 티켓을 반환합니다.\n    */\n    getStoredTicket(ticketCode: str): ticket.Ticket;\n\n    /**\n    * \"pay\" 메서드에 마지막으로 수행한 요청을 반환합니다.\n    */\n    getLastPayRequest(): forPaying.PayRequest;\n\n    /**\n    * \"pay\" 메서드에서 반환된 마지막 응답을 반환합니다.\n    * 이것은 결제된 식별자입니다.\n    */\n    getLastPayResponse(): str;\n\n    /**\n    * 결제 오류의 확률을 매개변수로 제공된 \"백분율\"로 설정합니다.\n    */\n    setPaymentError(errorCode: forPaying.PaymentError): void;\n\n    /**\n    * \"pay\" 메서드 실행 중에 발생한 오류 코드를 반환합니다.\n    */\n    getPaymentError(): forPaying.PaymentError;\n\n    /**\n    * 주어진 일시를 현재 일시로 설정합니다.\n    */\n    changeCurrentDateTime(newCurrentDateTime: std.Datetime): void;\n\n}\n```\n\n이제 우리는 한 단계 더 깊이 파고들어 애플리케이션 로직 구현을 살펴봐야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 구현 세부 내용\n\n## 주차 차량용 백엔드\n\n```js\nimport \"../../application/ports\" as ports;\nimport \"../../application/usecases\" as usecases;\n\npublic class ForParkingCarsBackend implements ports.ForParkingCars {\n    private final usecases.BuyTicket buyTicket;\n    private final usecases.GetAvailableRates getAvailableRates;\n\n    public ForParkingCarsBackend(\n        ports.ForStoringData dataRepository,\n        ports.ForPaying paymentService,\n        ports.ForObtainingDateTime dateTimeService\n    ) {\n        this.buyTicket = new usecases.BuyTicket(\n            dataRepository, paymentService, dateTimeService);\n        this.getAvailableRates = new usecases.GetAvailableRates(\n            dataRepository);\n    }\n\n    public Set<ports.Rate> getAvailableRates() {\n        return getAvailableRates.apply();\n    }\n\n    public ports.Ticket buyTicket(ports.BuyTicketRequest request) {\n        return buyTicket.apply(request);\n    }\n}\n```\n\n이 클래스는 src/outside/backend 폴더에 위치해 있으며 직접적인 함수 호출에 적합한 ports.ForParkingCars 인터페이스의 구현을 제공합니다. 두 가지 추가 보조 포트인 ports.ForStoringData 및 ports.ForObtainingTime을 전제로하며 실제 구현은 두 Use Case 구현에 위임됩니다: BuyTicket 및 GetAvailableRates. BuyTicket Use Case 구현에 핵심 시스템 로직이 포함되어 있으므로 해당 부분을 살펴보겠습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 티켓 구매 사용 사례\n\n```js\n수학 가져오기;\ndatetimex 가져오기;\n예외 가져오기;\n\"../ports\"를 ports로 가져오기;\n\"./Verifier.w\"를 validate로 가져오기;\n\npub 클래스 BuyTicket {\n    _dataRepository: ports.ForStoringData;\n    _paymentService: ports.ForPaying;\n    _dateTimeService: ports.ForObtainingDateTime;\n\n    새로운(\n        dataRepository: ports.ForStoringData,\n        paymentService: ports.ForPaying,\n        dateTimeService: ports.ForObtainingDateTime\n    ) {\n        this._dataRepository = dataRepository;\n        this._paymentService = paymentService;\n        this._dateTimeService = dateTimeService;\n    }\n\n    pub inflight apply(request: ports.BuyTicketRequest): ports.Ticket {\n        let currentDateTime = this._dateTimeService.getCurrentDateTime();\n        this._validateRequest(request, currentDateTime);\n        let paymentId = this._paymentService.pay(\n            euros: request.euros,\n            card: request.card\n        );\n        let ticket = this._buildTicket(request, paymentId, currentDateTime);\n        this._dataRepository.saveTicket(ticket);\n        return ticket;\n    }\n\n    inflight _validateRequest(request: ports.BuyTicketRequest, currentDateTime: std.Datetime): void {\n        let requestErrors = validate.BuyTicketRequest(request, currentDateTime);\n        if requestErrors.length > 0 {\n            throw exception.ValueError(\n                \"티켓 구매 요청이 유효하지 않습니다\",\n                requestErrors\n            );\n        }\n    }\n\n    inflight _buildTicket(\n        request: ports.BuyTicketRequest,\n        paymentId: str,\n        currentDateTime: std.Datetime\n    ): ports.Ticket {\n        let ticketCode = this._dataRepository.nextTicketCode();\n        let rate = this._dataRepository.getRateByName(request.rateName);\n        let endingDateTime = BuyTicket._calculateEndingDateTime(\n            currentDateTime,\n            request.euros,\n            rate.eurosPerHour\n        );\n        return ports.Ticket {\n            ticketCode: ticketCode,\n            carPlate: request.carPlate,\n            rateName: request.rateName,\n            startingDateTime: currentDateTime,\n            endingDateTime: endingDateTime,\n            price: request.euros,\n            paymentId: paymentId\n        };\n    }\n\n    /**\n     * minutes = (euros * minutesPerHour) / eurosPerHour\n     * endingDateTime = startingDateTime + minutes\n     */\n     static inflight _calculateEndingDateTime(\n        startingDateTime: std.Datetime,\n        euros: num,\n        eurosPerHour: num\n    ): std.Datetime {\n        let MINUTES_PER_HOUR = 60;\n        let minutes = math.round((MINUTES_PER_HOUR * euros) / eurosPerHour);\n        return datetimex.plus(startingDateTime, duration.fromMinutes(minutes));\n    }\n}\n```\n\n\"Buy Ticket\" 사용 사례 구현 클래스는 src/application/usecases 폴더에 있습니다. 이것은 사용 사례 로직을 실행하는 inflight 함수를 반환합니다:\n\n- 요청 유효성 검사\n- 새 티켓 결제\n- 티켓 레코드 생성\n- 데이터베이스에 티켓 레코드 저장\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nImplementing Use Cases as inflight functions is essential because all Wing event handlers are inflight functions. While direct function calls are handy for local testing, they will mostly be HTTP REST or GraphQL API calls in a real deployment.\n\nThe validation of the BuyTicketRequest is actually handled by a utility class within the Verifier.w module. This approach is taken because individual field validation could be very detailed and involve numerous low-level specifics, which add little to the overall understanding of the use case logic.\n\n## Bringing Everything Together\n\nIn line with suggestions from the \"Hexagonal Architecture Explained\" book, this is accomplished within a Configurator class as shown below:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nimport util;\nimport endor;\nimport outside from \"./outside\";\nimport ports from \"./application/ports\";\n\n\nenum ApiType {\n    DIRECT_CALL,\n    HTTP_REST\n}\n\nenum ProgramType {\n    UNKNOWN,\n    TEST,\n    SERVICE\n}\n\nclass Configurator extends outside.BlueZoneApiFactory {\n    _apiFactory;\n\n    constructor(name) {\n        let mockService = new outside.mock.MockDataRepository();\n        let programType = this._getProgramType(name);\n        let mode = this._getMode(programType);\n        let apiType = this._getApiType(programType, mode);\n        this._apiFactory = this._getApiFactory(\n            name,\n            mode,\n            apiType,\n            mockService,\n            mockService,\n            mockService\n        );\n    }\n\n    _getProgramType(name) { //TODO: migrate to endor??\n        if (name.endsWith(\"Test\")) {\n            return ProgramType.TEST;\n        } else if (name.endsWith(\"Service\") || name.endsWith(\"Application\")) {\n            return ProgramType.SERVICE;\n        } else if (std.Node.of(this).app.isTestEnvironment) {\n            return ProgramType.TEST;\n        }\n        return ProgramType.UNKNOWN;\n    }\n\n    _getMode(programType) {\n        if (let mode = util.tryEnv(\"MODE\")) {\n            return {\n                \"DEV\": endor.Mode.DEV,\n                \"TEST\": endor.Mode.TEST,\n                \"STAGE\": endor.Mode.STAGE,\n                \"PROD\": endor.Mode.PROD\n            }[mode];\n        } else if (programType === ProgramType.TEST) {\n            return endor.Mode.TEST;\n        } else if (programType === ProgramType.SERVICE) {\n            return endor.Mode.STAGE;\n        }\n        return endor.Mode.DEV;\n    }\n\n    _getApiType(programType, mode) {\n        if (let apiType = util.tryEnv(\"API_TYPE\")) {\n            return {\n                \"DIRECT_CALL\": ApiType.DIRECT_CALL,\n                \"HTTP_REST\": ApiType.HTTP_REST\n            }[apiType];\n        } else if (programType === ProgramType.SERVICE) {\n            return ApiType.HTTP_REST;\n        }\n        let target = util.env(\"WING_TARGET\");\n        if (target.includes(\"sim\")) {\n            return ApiType.DIRECT_CALL;\n        }\n        return ApiType.HTTP_REST;\n    }\n\n    _getApiFactory(name, mode, apiType, dataService, paymentService, dateTimeService) {\n        let directCall = new outside.DirectCallApiFactory(\n            dataService,\n            paymentService,\n            dateTimeService\n        );\n        if (apiType === ApiType.DIRECT_CALL) {\n            return directCall;\n        } else if (apiType === ApiType.HTTP_REST) {\n            return new outside.HttpRestApiFactory(\n                name,\n                mode,\n                directCall\n            );\n        }\n    }\n\n    getForAdministering() {\n        return this._apiFactory.getForAdministering();\n    }\n\n    getForParkingCars() {\n        return this._apiFactory.getForParkingCars();\n    }\n\n    getForIssuingFines() {\n        return this._apiFactory.getForIssuingFines();\n    }\n\n}\n```\n\nThis is an experimental, still not final, implementation, but it could be extended to address the production deployment needs. It adopts a static system configuration by exploiting the Wing preflight machinery.\n\nIn this implementation, a special MockDataStore object implements all three Secondary Ports: data service, paying service, and date-time service. It does not have to be this way and was created to save time during the scaffolding development.\n\nThe main responsibility of the Configurator class is to determine which type of API should be used:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 직접 호출\n- 로컬 HTTP REST\n- 원격 HTTP REST\n- 로컬 HTTP REST 및 HTML\n- 원격 HTTP REST 및 HTML\n\n실제 API 생성은 해당 ApiFactory 클래스에 위임됩니다.\n\n이러한 구현의 주목할 만한 점은 실제 HTML 기반 UI 모드를 제외한 모든 구성에서 동일한 테스트 스위트를 사용한다는 것입니다. 후자도 가능하지만 Selenium과 같은 HTML 테스트 드라이버가 필요합니다.\n\n이렇게 코드 재사용 수준을 달성한 것은 이번이 처음입니다. 결과적으로 코드 구조 리팩토링을 수행할 때 대부분 로컬 직접 호출 구성을 실행하며, 변경 없이 원격 테스트 및 프로덕션 환경에서 실행될 것을 확신합니다. 이는 Wing 클라우드 지향 프로그래밍 언어와 헥사고날 아키텍처가 정말로 우수한 조합임을 증명합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 큰 그림\n\n각 모듈의 전체 소스 코드를 모두 포함하면 이 문서의 크기가 너무 커질 것입니다. 이 프로젝트의 GitHub 저장소에 대한 액세스는 요청시 제공됩니다.\n\n그 대신 전체 폴더 구조, 두 개의 UML 클래스 다이어그램, 그리고 주요 프로그램 요소와 관계를 반영하는 클라우드 리소스 다이어그램을 제시할 것입니다.\n\n```js\n├── src\n│   ├── application\n│   │   ├── ports\n│   │   │   ├── ForAdministering.w\n│   │   │   ├── ForIssuingFines.w\n│   │   │   ├── ForObtainingDateTime.w\n│   │   │   ├── ForParkingCars.w\n│   │   │   ├── ForPaying.w\n│   │   │   ├── ForStoringData.w\n│   │   │   ├── Rate.w\n│   │   │   └── Ticket.w\n│   │   ├── usecases\n│   │   │   ├── BuyTicket.w\n│   │   │   ├── CheckCar.w\n│   │   │   ├── GetAvailableRates.w\n│   │   │   └── Veryfier.w\n│   ├── outside\n│   │   ├── backend\n│   │   │   ├── ForAdministeringBackend.w\n│   │   │   ├── ForIssuingFinesBackend.w\n│   │   │   └── ForParkingCarsBackend.w\n│   │   ├── http\n│   │   │   ├── html\n│   │   │   │    ├── _htmlForParkingCarsFormatter.ts\n│   │   │   │    └── htmlForParkingCarsFormatter.w\n│   │   │   ├── json\n│   │   │   │    ├── jsonForIssuingFinesFormatter.w\n│   │   │   │    └── jsonForParkingCarsFormatter.w\n│   │   │   ├── ForIssuingFinesClient.w\n│   │   │   ├── ForIssuingFinesController.w\n│   │   │   ├── ForParkingCarsClient.w\n│   │   │   ├── ForParkingCarsController.w\n│   │   │   └── middleware.w\n│   │   ├── mock\n│   │   │   └── MockDataRepository.w\n│   │   ├── ApiFactory.w\n│   │   ├── BlueZoneAplication.main.w\n│   │   ├── DirectCallApiFactory.w\n│   │   └── HttpRestApiFactory.w\n│   └── Configurator.w\n├── test\n│   ├── steps\n│   │   ├── BuyTicketTestSteps.w\n│   │   ├── CheckCarTestSteps.w\n│   │   ├── Parser.w\n│   │   └── TestStepsBase.w\n│   ├── usecase.BuyTicketTest.w\n│   └── usecase.CheckCarTest.w\n├── .gitignore\n├── LICENSE\n├── Makefile\n├── README.md\n├── package-lock.json\n├── package.json\n└── tsconfig.json\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n프로젝트의 응용 프로그램 논리적으로는 작지만 이미 구조를 제어하는 데 충분한 도전 과제를 제기합니다. 현재 버전은 다음과 같은 여러 기준 사이의 합리적인 균형을 이루려고 노력했습니다:\n\n- 파일 구조의 깊이.\n- 복잡성 및 가져오기 문장의 양.\n- 의도한 가치를 전달하는 코드와 그것을 구성, 테스트하고 전달하는 데 필요한 코드 간의 비율.\n\n모든 원하는 메트릭 세트를 계산하는 것은 이 출판물의 범위를 벗어난 일이지만, 여기서 지금 직접 손으로 백업한 계산을 수행해볼 수 있습니다: 응용 프로그램과 외부 폴더 아래의 파일(여기에 \"가치\"라고 부르기로 하겠습니다)의 백분율과 총 파일 및 폴더 수(이를 \"물건\"이라고 부르기로 하겠습니다). 현재 버전에서의 숫자는 다음과 같습니다:\n\n총계: 55\nsrc/application: 16\nsrc/: 41\n파일: 43\n엄격한 가치 대 물건 비율: 16*100/55 = 29.09%\n확장된 가치 대 물건 비율: (15+19)*100/42 = 74.55%\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n크게 할지 작게 할지? 좋은 것일지 나쁜 것일지? 지금 당장은 확실히 말하기 어렵습니다. 초기 인상은 숫자가 건강하다는 것입니다. 더 근거 있는 결론을 내기 위해서는 추가적인 연구와 실험이 필요합니다. 실제 제품 시스템은 상당히 많은 테스트가 필요할 것입니다.\n\n인지 부담 관점에서, 43개의 파일은 인간의 커뮤니케이션 채널과 단기 기억의 유명한 7 ± 2 제한을 초과하는 많은 숫자입니다. 조직이 필요합니다. 현재 버전에서 한 수준에서의 최대 파일 수는 8개로 제한 내에 있습니다.\n\n제시된 계층 다이어그램은 실제 그래프 이미지를 부분적으로만 반영합니다. bring 문에 의한 파일 간 종속성이 보이지 않습니다. 또한 결과적인 패키지 크기에 영향을 미치는 외부 종속성을 반영하는 **node_files** 폴더도 빠졌습니다.\n\n간단히 말하면, 도구 및 측정 방법론에 대한 추가 투자 없이는 그림이 부분적일 뿐입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리는 여전히 원하는 방향을 몇 가지 제시할 수 있습니다: 가능한 한 직접 가치를 창출하는 자산들과 이를 작동하게 만드는 데 필요한 지원 요소는 최소한으로 다루고 싶습니다. 이상적으로, 건강한 가치 대 지원물 비율은 언어 및 라이브러리 지원에서 나올 것입니다. 자동 코드 생성, 생성적 AI에 의해 수행되는 것을 포함하여 타이핑을 줄이지만 전반적인 인지 부담은 줄일 것입니다.\n\n# 클래스 다이어그램\n\n단일 UML 클래스 다이어그램에 모든 \"Blue Zone\" 애플리케이션 요소를 묘사하는 것은 현실적이지 않을 것입니다. UML은 선행 요소와 기체 내 요소를 직접적으로 분리된 표현으로 지원하지 않습니다. 시스템의 가장 중요한 부분을 별도로 시각화할 수 있습니다. 예를 들어, 다음은 애플리케이션 부분용 UML 클래스 다이어그램입니다:\n\n![클래스 다이어그램](/assets/img/2024-06-22-PortedtoCloudwithWinglangPartOne_3.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이용자들과 주차 감독관 주요 캐릭터와 BuyTicket, CheckCar 사용 케이스와는 이름이 다르다는 것을 주목해주세요. 이것은 실수가 아닙니다. 주요 포트 인터페이스의 이름은 특정 사용 케이스에서 주요 캐릭터 역할을 반영해야 합니다. 이러한 명명에 대한 자동적인 규칙은 없습니다. 선택된 이름이 직관적이기를 희망합니다.\n\n또한, 주요 인터페이스가 응용 프로그램 모듈 내에서 직접 구현되지 않고 이러한 인터페이스와 사용 케이스 구현 사이에 불일치가 있는 것을 주목해주세요.\n\n또한, 이것 또한 실수가 아닙니다. 주요 인터페이스와 해당 사용 케이스 구현 사이의 구체적인 연결은 설정에 따라 다르며 아래 UML 클래스 다이어그램에 반영됩니다:\n![다이어그램](/assets/img/2024-06-22-PortedtoCloudwithWinglangPartOne_4.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 클래스 다이어그램에 따르면 구성자(Configurator)가 사용할 IBlueZoneApiFactory 구현체를 결정합니다. DirectApiCallFactory는 로컬 테스트용이며 HttpRestApiFactory는 HTTP를 통한 로컬 및 원격 테스트 및 프로덕션 배포용입니다.\n\n## 클라우드 리소스\n\n![이미지](/assets/img/2024-06-22-PortedtoCloudwithWinglangPartOne_5.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 클라우드 리소스 다이어그램은 Wing 컴파일레이션 결과를 AWS 대상 플랫폼으로 반영한 것입니다. UML 클래스 다이어그램과는 매우 다르며, 다양한 종류의 다이어그램이 함께 동작하여 서로 보완하는 역할을 한다는 결론을 내리게 되었습니다. 클라우드 리소스 다이어그램은 비용, 성능, 신뢰성, 복구력, 보안과 같은 시스템의 운영 측면을 이해하고 제어하는 데 중요합니다.\n\n과거의 다이어그램과 마찬가지로 주요 도전 과제는 규모입니다. 더 많은 클라우드 리소스가 추가되면 다이어그램에 너무 많은 세부 사항이 포함되어 혼란스러울 수 있습니다.\n\n현재 모든 다이어그램의 버전은 공식 청사진보다는 유용한 일러스트레이션에 가깝습니다. 정확성과 이해도 사이의 적절한 균형을 유지하는 것은 앞으로의 연구 주제입니다. 이 문제를 이전에 나의 초기 출간 논문 중 하나에서 다루었습니다. 아마도, 이 연구 주제로 다시 돌아가야 할 때가 온 것 같습니다.\n\n# 결론\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\"최근 출간된 \"Hexagonal Architecture Explained\" 책에 소개된 \"Blue Zone\" 애플리케이션을 Java에서 Wing으로 이식하는 경험은 다음과 같은 임시 결론을 이끌어 냈습니다.\n\n- 소프트웨어 애플리케이션을 직접 클라우드로 이식하는 것은 종종 비효율적이고 유지보수하기 어려운 코드를 낳습니다.\n- 각 프로그래밍 언어는 디자인 결정을 표현하는 고유한 방식을 갖고 있으며, 하나에서 다른 것으로의 맹목적인 번역은 작동하지 않습니다.\n- 새로운 클라우드 중심 프로그래밍 언어 Wing에서 Hexagonal Architecture 패턴을 구현하는 것이 성공적인 조합임이 입증되었습니다. 이 접근 방식은 비용, 성능, 유연성 및 보안 사이의 적절한 균형을 이룹니다.\n- 기능 면에서 조금이라도 큰 애플리케이션의 코드베이스 크기는 빠르게 증가합니다. 복잡성을 효과적으로 관리하려면 방법론과 지침이 필요합니다.\n- 애플리케이션 논리와 클라우드 리소스의 그래픽 표현은 설명에 유용합니다. 이를 형식적인 청사진으로 변환하려면 추가 연구가 필요합니다.\n\n# 감사의 글\n\n이 출판물을 준비하는 동안 초안을 향상시키고 품질을 보장하기 위해 몇 가지 핵심 도구를 활용하였습니다.\"\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n초안은 노션의 무료 구독을 통해 조직화할 수 있는 기능을 활용하여 아이디어를 구조화하고 발전시했습니다.\n\n문법 및 철자 검토를 위해 Grammarly의 무료 버전이 기본 오류를 식별하고 수정하여 텍스트의 가독성을 보장하는 데 유용했습니다.\n\n스타일 표현의 향상과 이야기 일관성을 검토하기 위해 ChatGPT 4o의 유료 버전을 사용했습니다. ChatGPT 4o 도구는 Trusted Wing Libraries의 중요한 부분인 datetimex와 TypeScript의 struct를 개발하는 데도 사용되었습니다.\n\nUML 클래스 다이어그램은 PlantText UML 온라인 도구의 무료 버전을 사용하여 생성되었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n테스트 단계 클래스(TestSteps)에서 사전 및 비행 정의를 올바르게 처리하는 데 Cristian Pallares의 도움이 중요했습니다.\n\n이 출판물 초안에 중요한 코멘트를 해 주신 Elad Ben-Israel에게 많은 감사를 드립니다.\n\n\"블루 존\" 애플리케이션의 자바 버전은 책의 공동 저자인 Juan Manuel Garrido de Paz에 의해 개발되었습니다. 안타깝게도 Juan Manuel Garrido de Paz는 2024년 4월에 별세하셨습니다. 그의 추억이 기억되고 이 보고서가 그에게 바치는 축복이 되기를 바랍니다.\n\n모든 고급 도구와 자원이 준비 과정에 상당한 기여를 했지만, 이 문서에 제시된 개념, 해결책 및 최종 결정은 전적으로 제 자신의 것이며, 그에 대한 책임은 전적으로 제게 있습니다.\n","ogImage":{"url":"/assets/img/2024-06-22-PortedtoCloudwithWinglangPartOne_0.png"},"coverImage":"/assets/img/2024-06-22-PortedtoCloudwithWinglangPartOne_0.png","tag":["Tech"],"readingTime":45}],"page":"35","totalPageCount":120,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true}