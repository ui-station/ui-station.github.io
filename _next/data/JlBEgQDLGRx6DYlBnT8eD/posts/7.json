{"pageProps":{"posts":[{"title":"Part 3 React  폴더 구조 쉽게 정리하는 방법","description":"","date":"2024-06-30 22:10","slug":"2024-06-30-Part3ReactFolderStructure","content":"\n\n# 📖 이전 파트\n\n이 시리즈의 2부는 여기에서 찾을 수 있습니다:\n\nhttps://javascript.plainenglish.io/part-2-react-naming-convention-return-signatures-for-hooks-b9e31f5e7f58\n\n가끔, 새 프로젝트를 시작하거나 애플리케이션이 성장함에 따라 파일을 어디에 둬야 할지에 대한 지침이 필요할 때가 있습니다. 이 컴포넌트를 어디에 두어야 할까요? 여기에 추가해야 할까요? 아이디어를 얻으셨죠? 만약 이미 그에 대해 헤매고 있다면, 필요한 파일을 찾는 것은 더 어려울 수 있습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n일반적으로 답은 더 나은 폴더 구조에 있습니다.\n\n폴더 구조는 프로젝트에서 가장 중요한 요소 중 하나입니다. 파일을 어디에 두고 어떻게 조직화할지 알아야 하며, 애플리케이션이 성장함에 따라 유용합니다. 이는 당신과 팀이 필요한 파일을 쉽게 찾을 수 있도록 합니다.\n\n각 팀의 목표는 누구나 즉시 파일을 찾을 수 있고 새 파일을 추가하거나 기존 파일을 업데이트하는 방법을 아는 것입니다.\n\n이 파트에서는 내 프로젝트에서 사용하는 폴더 구조를 탐색하고, 당신에게 더 나을 수도 있는 다른 가능한 해결책을 살펴보겠습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# ⚙️ 폴더 구조\n\n제가 일반적으로 프로젝트를 시작할 때 사용하는 업데이트된 폴더 구조입니다:\n\n![Folder Structure](/assets/img/2024-06-30-Part3ReactFolderStructure_0.png)\n\n각 폴더를 설명해보겠습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- api\n\n이 폴더에는 애플리케이션이 수행할 모든 API 호출이 포함되어 있습니다. 백엔드에서 데이터를 가져오는 기능을 모두 넣을 곳입니다.\n\n최신 버전의 Next.js에서는 서버 액션이라는 새로운 개념이 있습니다. 이는 서버에서 데이터를 가져오거나 데이터 변경을 수행하는 함수입니다. 이를 api 폴더에 넣을 수도 있습니다.\n\n예시 구조:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![image](/assets/img/2024-06-30-Part3ReactFolderStructure_1.png)\n\nReact-Query 쿼리 및 뮤테이션을 혼합하여 Next.js 서버 동작도 구현했습니다.\n\n- assets\n\n이 폴더에는 애플리케이션이 사용할 모든 이미지, 글꼴 및 기타 에셋이 포함되어 있습니다.\n\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리 앱에서 로컬 이미지, 폰트 및 기타 에셋이 필요한 경우가 있습니다. 여기서는 앱에서 사용할 모든 에셋을 넣을 곳입니다.\n\n예시 구조:\n\n![이미지](/assets/img/2024-06-30-Part3ReactFolderStructure_2.png)\n\n- components\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 폴더에는 앱에서 사용할 모든 재사용 가능한 구성 요소가 포함되어 있습니다. 여기에는 여러 화면에서 사용할 구성 요소를 모두 넣게 됩니다.\n\n가능한 한 각 구성 요소가 \"독립적\"이 되도록 해야 합니다. 이것은 각 구성 요소가 독립적으로 존재할 수 있고 다른 구성 요소에 의존하지 않는다는 것을 의미합니다.\n\n그러나 항상 그런 것은 아닙니다. 때로는 구성 요소가 다른 구성 요소를 사용해야 하는 경우도 있습니다. 이는 일반적으로 구성 요소의 조합을 의미합니다. Button + Input과 같이 구성 요소 조합이 필요할 때는 새로운 구성 요소로 취급하고 새 폴더에 넣어야 합니다.\n\n그리고 그것을 ButtonInput 또는 다른 원하는 이름으로 지을 수 있습니다. 단지 의미가 통하면 됩니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n지금까지의 구조를 가장 단순하게 만들어봤어. 이렇게 하면 필요한 컴포넌트를 더 쉽게 찾을 수 있을 거야.\n\n예시 구조:\n\n- constants\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 폴더에는 앱에서 사용할 모든 상수가 포함되어 있습니다. 상수는 앱 전체에서 변하지 않는 값입니다.\n\n예를 들어 환경 변수를 담고 있는 Environment.ts 파일을 여기에 넣을 수 있습니다.\n\n예시 구조:\n\n![Folder Structure](/assets/img/2024-06-30-Part3ReactFolderStructure_4.png)\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- hooks\n\n이 폴더에는 애플리케이션이 사용할 모든 사용자 지정 React 훅이 포함되어 있습니다.\n\n예시 구조:\n\n![Hooks](/assets/img/2024-06-30-Part3ReactFolderStructure_5.png)\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 제공자\n\n이 폴더에는 애플리케이션이 사용할 모든 리액트 컨텍스트 제공자가 포함되어 있습니다.\n\n컨텍스트 제공자의 구현을 하나의 파일에 모두 넣고 싶다면 hooks 폴더에 넣을 수 있습니다.\n\n예시 코드:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-06-30-Part3ReactFolderStructure_6.png\" />\n\n예제 구조:\n\n<img src=\"/assets/img/2024-06-30-Part3ReactFolderStructure_7.png\" />\n\n- screens\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 폴더에는 애플리케이션이 사용할 모든 화면이 포함되어 있어요.\n\n저희 애플리케이션에서는 Next.js이든 React Native이든, 보통 일종의 \"라우터\"를 가지고 있어요. 여기서 우리가 사용할 애플리케이션의 경로를 정의해요.\n\n이는 폴더 기반 라우팅으로 이뤄진 Next.js와 같은 형식일 수도 있고, 단일 파일에서 경로를 정의하는 react-router-dom과 같은 라우터 라이브러리 형식일 수도 있어요.\n\nReact는 웹, 모바일 및 데스크톱과 같은 여러 플랫폼에서 사용될 수 있기 때문에 경로를 정의하는 방식이 다를 수 있어요. 이 폴더 구조를 갖고 있으면 여전히 화면을 정의하고 사용 중인 플랫폼에 맞게 쉽게 적응시킬 수 있어요.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n예시 구조:\n\n![이미지](/assets/img/2024-06-30-Part3ReactFolderStructure_8.png)\n\n- 화면 '컴포넌트\n\n이 폴더에는 화면에 특화된 모든 컴포넌트가 포함되어 있습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 특별한 디렉토리는 \"프랙탈\" 패턴에서 영감을 받아 폴더의 무한 중첩을 만들 수 있도록 합니다.\n\n그러나 우리의 경우에는 중첩이 하나뿐이며 간단한 수준을 유지할 것입니다. `components` 디렉토리는 화면에 특정한 섹션 구성 컴포넌트를 모두 넣을 수 있는 곳입니다. \"섹션\"이라는 단어에 주목해주세요.\n\n화면 컴포넌트 폴더가 없으면:\n\n![이미지](/assets/img/2024-06-30-Part3ReactFolderStructure_9.png)\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n화면 구성 요소 폴더에 저장될 모든 구성 요소는 해당 화면에서만 사용해야 합니다. 이는 각 화면이 방대할 수 있기 때문에 코드베이스의 유지 관리성을 향상시키기 위한 것입니다.\n\n구성 요소 폴더의 구성 요소를 사용할 수 있다면 해당 구성 요소 폴더에 있어야 합니다. 그러나 해당 화면에 대해 특정한 사용자 정의가 필요하다면 화면 구성 요소 폴더에 있어야 합니다.\n\n예시 구조:\n\n![이미지](/assets/img/2024-06-30-Part3ReactFolderStructure_10.png)\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- utils\n\n이 폴더에는 애플리케이션이 사용할 유틸리티 함수들이 포함되어 있습니다.\n\n여기에는 컴포넌트 또는 화면과 관련되지 않은 모든 함수를 넣을 것입니다. 이는 애플리케이션 여러 곳에서 사용되는 함수일 수 있습니다.\n\n포매터, 발리데이터 및 다른 컴포넌트 또는 화면과 관련되지 않은 함수는 여기에 넣어야 합니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n컴포넌트 폴더와 유사하게, 최대한 평면화하십시오. 이는 깊은 폴더 구조를 갖지 않아야 함을 의미합니다. 이렇게 하면 필요한 함수를 쉽게 찾을 수 있습니다.\n\n사용할 각 유틸리티 함수에 대한 폴더를 만들어서 해당 함수에 대한 테스트를 작성할 수 있도록 그룹화하십시오.\n\n예시 구조:\n\n![Folder Structure](/assets/img/2024-06-30-Part3ReactFolderStructure_11.png)\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 💡 다른 폴더 구조 아이디어\n\n우리는 문제를 해결하는 여러 가지 방법이 있다는 것을 알 수 있습니다. 폴더 구조도 마찬가지입니다. 그래서 여러분에게 더 나은 해결책일 수도 있는 다른 가능한 솔루션을 탐색할 수 있는 이 섹션을 마련했습니다.\n\n- 원자 디자인\n\n원자 디자인은 디자인 시스템을 만드는 데 도움이 되는 방법론입니다. UI를 더 작은 구성 요소로 나누는 방법입니다. 컴포넌트는 원자, 분자, 유기체, 템플릿 및 페이지로 나누어집니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 예시 구조입니다:\n\n![이미지](/assets/img/2024-06-30-Part3ReactFolderStructure_12.png)\n\n[링크](https://bradfrost.com/blog/post/atomic-web-design/)\n\n- 기능 기반\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n피처 기반은 애플리케이션의 기능에 따라 파일을 구성하는 방법입니다. 많은 기능을 갖춘 대형 애플리케이션의 경우 파일을 잘 구성하는 방법 중 하나입니다.\n\n예시 구조:\n\n![폴더 구조](/assets/img/2024-06-30-Part3ReactFolderStructure_13.png)\n\n각 폴더는 해당 기능과 관련된 모든 컴포넌트, 훅, 그리고 다른 파일들을 포함하게 됩니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여기 좋은 커뮤니티 토론이 있어요:\n\n[커뮤니티 링크](https://community.redwoodjs.com/t/how-to-use-feature-based-folders-structure-instead-type-based/2980/7)\n\n- 도메인 기반\n\nFeature-based와 유사하게, 도메인 기반은 당신의 응용프로그램의 도메인을 특징이 아닌 파일들을 구성하는 방법입니다. 이 방법은 여러 도메인이 있는 대규모 응용프로그램의 파일을 구성하는 좋은 방법입니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 예시 구조입니다. \n\n\n![folder structure](/assets/img/2024-06-30-Part3ReactFolderStructure_14.png)\n\n\n각 폴더는 해당 도메인과 관련된 모든 컴포넌트, 훅, 그리고 다른 파일을 포함하고 있습니다.\n\n## 🚀 결론\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n프로젝트에서 파일을 구성하는 다양한 방법이 있음을 볼 수 있어요. 프로젝트에서 사용할 폴더 구조에 대해 생각을 많이 하면 좋은 일이에요. 이렇게 하면 당신과 팀원들이 필요한 파일을 쉽게 찾을 수 있게 도와줄 거예요.\n\n저는 주로 제 프로젝트에서 React를 사용하는데, 그래서 이 글에서는 주로 React 예시를 보여드리고 있어요. 하지만 다른 프레임워크로도 이를 적용할 수 있을 것이라 확신해요.\n\n언제든지 궁금한 점이나 제안이 있으면 아래 댓글을 남겨주세요. 당신의 이야기를 듣는 걸 무척이나 기대하고 있어요.\n\n읽어주셔서 감사해요. 이 글이 여러분의 여정에 도움이 되길 바래요! ❤️\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 쉽게 설명한 것에 오신 것을 환영합니다! 🚀\n\nIn Plain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 떠나시기 전에:\n\n- 필자를 박수로 격려하고 팔로우해 주세요 👏\n- 팔로우하기: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼 방문: CoFeed | Differ\n- PlainEnglish.io에서 더 많은 콘텐츠 확인하기","ogImage":{"url":"/assets/img/2024-06-30-Part3ReactFolderStructure_0.png"},"coverImage":"/assets/img/2024-06-30-Part3ReactFolderStructure_0.png","tag":["Tech"],"readingTime":12},{"title":"최신 프론트엔드 기술 비교 React vs Vuejs","description":"","date":"2024-06-30 22:09","slug":"2024-06-30-Front-EndTechnologiesReactvsVuejs","content":"\n\n알맞은 프론트엔드 기술을 선택하는 것은 효율적이고 확장 가능한 웹 애플리케이션을 개발하는 데 중요합니다. 현대 웹 개발 환경에서 인기 있는 두 프레임워크는 React와 Vue.js입니다. 이 글은 ReactJS와 Vue.js 사이의 주요 차이점을 밝히고 있습니다.\n\n## React: 사용자 인터페이스를 구축하기 위한 라이브러리\n\nReact는 Facebook에서 개발한 JavaScript 라이브러리로 사용자 인터페이스를 구축하는 데 중점을 둡니다. 재사용 가능한 UI 구성 요소를 만드는 데 초점을 두고 있습니다.\n\n## React의 주요 기능\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- Component-Based Architecture: 자체 상태를 관리하는 캡슐화된 구성 요소를 구축하여 개발을 더 모듈화하고 유지 관리할 수 있습니다.\n- Virtual DOM: 변경된 부분만 업데이트하여 성능을 향상시킵니다.\n- JSX Syntax: JavaScript 내에서 HTML과 유사한 구문을 작성할 수 있어 코드를 읽고 이해하기 쉽게 만들고 디버깅하기 용이하게 합니다.\n\n## Vue.js: 점진적인 JavaScript 프레임워크\n\nVue.js는 사용자 인터페이스를 구축하기 위한 점진적인 프레임워크로 Evan You가 만들었습니다. 점진적인 채택이 가능하도록 설계된 이 프레임워크는 간단함과 쉬운 통합에 중점을 두고 있습니다.\n\n## Vue.js의 주요 기능:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 반응형 데이터 바인딩: 기본 데이터가 변경될 때 DOM을 자동으로 업데이트합니다.\n- 컴포넌트 기반 아키텍처: React와 유사하게 재사용 가능한 컴포넌트를 구축할 수 있습니다.\n- 단일 파일 컴포넌트: HTML, CSS 및 JavaScript를 한 파일에 캡슐화하여 코드베이스를 관리하기 쉽게 합니다.\n\n## 비교 요약\n\n- 학습 곡선: Vue.js는 일반적으로 학습하기 쉽고 시작하기 쉬우므로 초보자에게 이상적입니다. JSX 구문과 더 복잡한 설정으로 React는 더 가파른 학습 곡선을 가지고 있습니다.\n- 유연성: React는 응용 프로그램을 구조화하고 다른 라이브러리와 통합하는 방법에 대해 더 많은 유연성을 제공하지만, Vue.js는 더 직관적이고 통합된 접근 방식을 제공합니다.\n- 성능: 두 프레임워크 모두 성능이 우수하지만, React의 가상 DOM은 효율적인 업데이트와 렌더링을 제공합니다. Vue.js도 반응형 데이터 바인딩으로 좋은 성능을 제공합니다.\n\n## 결론\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n결론적으로, React와 Vue.js는 각각의 장점을 가지고 있는 강력한 프론트엔드 기술입니다. React는 유연성, 성능, 그리고 다양한 생태계로 인해 크고 복잡한 프로젝트에 적합하다는 점에서 선호됩니다. Vue.js는 간결함, 통합의 용이성, 그리고 접근하기 쉬운 학습 커브로 인해 빠른 개발과 작은 프로젝트에 이상적이라는 점이 인정받고 있습니다. 두 기술 중 어느 것을 선택할지는 특정 프로젝트 요구사항과 개인적인 취향에 따라 다를 것입니다.\n\n웹 개발을 배우거나 JavaScript 프레임워크 중 하나에 대한 지식을 향상시키고 싶다면 https://hng.tech/internship 또는 https://hng.tech/premium을 방문해보세요.","ogImage":{"url":"/assets/img/2024-06-30-Front-EndTechnologiesReactvsVuejs_0.png"},"coverImage":"/assets/img/2024-06-30-Front-EndTechnologiesReactvsVuejs_0.png","tag":["Tech"],"readingTime":3},{"title":"Tornado Cash 소스 코드를 통해 알아보는 영지식 증명 이해하기","description":"","date":"2024-06-30 22:07","slug":"2024-06-30-UnderstandingZero-KnowledgeProofsThroughtheSourceCodeofTornadoCash","content":"\n\n## 제로지식증명으로 스마트 컨트랙트 세계로 뛰어들어 보세요\n\n![image](/assets/img/2024-06-30-UnderstandingZero-KnowledgeProofsThroughtheSourceCodeofTornadoCash_0.png)\n\n위키피디아에 따르면, 제로지식증명(ZKP)의 정의는 다음과 같습니다:\n\n제로지식증명(ZKP) 기술은 블록체인과 같은 공개적인 데이터베이스에서 해결하기 어려운 익명 투표 또는 익명 금전 송금과 같은 여러 다양한 분야에 널리 사용될 수 있습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n토네이도 캐시는 이더리움 트랜잭션을 익명화할 수 있는 코인 믹서입니다. 블록체인의 논리로 인해 모든 트랜잭션은 공개적이기 때문에 자신의 계정에 이더리움이 있다면 누구나 블록체인에서 트랜잭션 기록을 따라갈 수 있습니다. 토네이도 캐시와 같은 코인 믹서는 ZKP를 사용하여 출처와 목적지 주소 사이의 체인 상의 연결을 끊어 개인 정보 보호 문제를 해결할 수 있습니다.\n\n트랜잭션 중 하나를 익명화하려면 토네이도 캐시 계약에 소량의 이더리움(또는 ERC20 토큰)을 예치해야 합니다(예: 1 ETH). 잠시 후 다른 계정으로 이 1 ETH를 인출할 수 있습니다. 핵심은 누구도 예치 계정과 인출 계정 사이에 연결을 만들 수 없다는 점입니다. 수백 개의 계정이 한 쪽에 1 ETH를 예치하고 다른 수백 개의 계정이 다른 쪽에서 1 ETH를 인출하면 자금 이동 경로를 추적할 수 없습니다. 기술적인 과제는 스마트 계약 트랜잭션도 이더리움 네트워크의 다른 모든 트랜잭션과 마찬가지로 공개적이라는 것입니다. 여기서 ZKP가 관련될 때가 됩니다.\n\n계약에 1 ETH를 예치할 때 \"커밋먼트\"를 제공해야 합니다. 이 커밋먼트는 스마트 계약에 저장됩니다. 다른 쪽에서 1 ETH를 인출할 때는 \"널리파이어\"와 제로 지식 증명을 제공해야 합니다. 널리파이어는 커밋먼트와 관련이 있는 고유한 ID이며, ZKP는 이 연결을 증명하지만 어떤 널리파이어가 어떤 커밋먼트에 할당되어 있는지는 아무도 모릅니다(예외는 예금자/인출 계정의 소유주).\n\n한번 더 말씀드리면: 우리는 커밋먼트가 우리의 널리파이어에 할당되어 있다는 것을 증명할 수 있습니다. 본인의 커밋먼트를 공개하지 않고요.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n스마트 계약으로 널리파이어를 추적하므로 한 번에 예금한 ETH를 하나의 널리파이어로만 인출할 수 있습니다.\n\n쉬워보이죠? 그렇지 않아요! :) 이제 기술의 심연으로 들어가 봅시다. 하지만 무엇보다도 또 다른 tricky한 요소, Merkle tree를 이해해야 합니다.\n\n![Merkle tree](/assets/img/2024-06-30-UnderstandingZero-KnowledgeProofsThroughtheSourceCodeofTornadoCash_1.png)\n\nMerkle tree는 잎이 요소인 해시 트리로, 모든 노드가 자식 노드의 해시인 구조입니다. 트리의 루트는 Merkle root로, 전체 요소 집합을 나타냅니다. 트리에서 어떤 요소(잎)를 추가, 제거 또는 변경하면 Merkle root가 변경됩니다. Merkle root는 요소 집합의 고유 식별자입니다. 그럼 어떻게 사용할까요?\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![Understanding Zero Knowledge Proofs through the Source Code of Tornado Cash](/assets/img/2024-06-30-UnderstandingZero-KnowledgeProofsThroughtheSourceCodeofTornadoCash_2.png)\n\n다른 것으로 Merkle proof라는 것이 있어요. 만약 내게 Merkle root가 있다면, 당신은 루트로 표현된 집합에 요소가 있는 것을 증명해주는 Merkle proof를 보낼 수 있어요. 아래 그림은 어떻게 작동하는지 보여줍니다. 만약 HK가 그 집합 안에 있다는 것을 나에게 증명하고 싶다면, HL, HIJ, HMNOP, HABCDEFGH 해시를 보내주어야 해요. 이 해시들을 사용하여 나는 Merkle root를 계산할 수 있어요. 만약 루트가 내 루트와 같다면, HK가 집합 안에 있는 것이에요. 어디에 사용할 수 있을까요?\n\n간단한 예시로 화이트리스트를 상상해봅시다. 오직 화이트리스트된 사용자만이 호출할 수 있는 메소드를 갖는 스마트 컨트랙트가 있다고 가정해봅시다. 문제는 화이트리스트에 있는 계정이 1000개나 되는 것이에요. 이를 스마트 컨트랙트에 저장하는 방법은 무엇일까요? 각 계정을 매핑에 저장하는 간단한 방법이 있지만, 매우 비싸요. 더 싼 해결책은 Merkle tree를 만들고 Merkle root만 저장하는 것이에요 (1개의 해시 대신 1000개의 해시는 아주 좋아요). 누군가가 그 메소드를 호출하고 싶으면, 그 지능적인 스마트 컨트랙트가 쉽게 유효성 검사할 수 있는 Merkle proof(이 경우에 10개 해시의 목록)를 제공해야 해요.\n\n한번 더 말씀드리면: Merkle tree는 하나의 해시(=Merkle root)로 원소 집합을 나타내는 데 사용됩니다. Merkle proof를 통해 원소의 존재를 증명할 수 있어요.\n\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음으로 이해해야 할 것은 제로-지식 증명(ZKP) 자체입니다. ZKP를 사용하면 무언가를 알고 있다는 사실을 증명할 수 있습니다. 그러나 알고 있는 내용을 공개하지 않으면서 증명할 수 있습니다. ZKP를 생성하기 위해서는 회로가 필요합니다. 회로란 공개 입력과 출력, 그리고 비공개 입력을 가진 작은 프로그램과 같은 것입니다. 이러한 비공개 입력은 검증을 위해 공개하지 않는 정보이며, 이것이 제로-지식 증명이라 불리는 이유입니다. ZKP를 사용하면 주어진 회로와 입력에서 출력이 생성될 수 있는 것을 증명할 수 있습니다.\n\n간단한 회로는 다음과 같습니다:\n\n```js\npragma circom 2.0.0;\n\ninclude \"node_modules/circomlib/circuits/bitify.circom\";\ninclude \"node_modules/circomlib/circuits/pedersen.circom\";\n\ntemplate Main() {\n    signal input nullifier;\n    signal output nullifierHash;\n\n    component nullifierHasher = Pedersen(248);\n    component nullifierBits = Num2Bits(248);\n\n    nullifierBits.in <== nullifier;\n    for (var i = 0; i < 248; i++) {\n        nullifierHasher.in[i] <== nullifierBits.out[i];\n    }\n\n    nullifierHash <== nullifierHasher.out[0];\n}\n\ncomponent main = Main();\n```\n\n이 회로를 사용하면 주어진 해시의 원본을 알고 있다는 것을 증명할 수 있습니다. 이 회로에는 하나의 입력(널리파이어)과 하나의 출력(널리파이어 해시)가 있습니다. 입력의 기본 접근성은 비공개이며, 출력은 항상 공개입니다. 이 회로는 Circomlib에서 2개의 라이브러리를 사용합니다. Circomlib은 유용한 회로들의 집합입니다. 첫 번째 라이브러리는 비트 조작 방법을 포함하는 bitlify이며, 두 번째는 페더슨 해시를 포함하는 pedersen입니다. 페더슨 해싱은 제로-지식 증명 회로에서 효율적으로 실행할 수 있는 해싱 방법입니다. Main 템플릿의 내용에서 해시를 채우고 계산합니다. (circom 언어에 대한 자세한 정보는 circom 문서를 참조해주세요)\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n영접하십시오. 제로지식 증명을 생성하려면 증명 키가 필요합니다. 이는 ZKP의 가장 민감한 부분인데, 증명 키를 생성하는 데 사용된 소스 데이터를 사용하면 누구든지 가짜 증명을 생성할 수 있습니다. 이 소스 데이터를 \"유독 폐기물\"이라고 하며, 이를 폐기해야 합니다. 이러한 이유로 증명 키 생성을 위해 \"의식\"이 있습니다. 의식에는 많은 구성원이 참여하며 각 구성원이 증명 키에 기여합니다. 악의가 없는 하나의 구성원만 있으면 유효한 증명 키를 생성할 수 있습니다. 개인 입력, 공개 입력 및 증명 키를 사용하여 ZKP 시스템은 회로를 실행하고 증명 및 출력을 생성할 수 있습니다.\n\n![이미지](/assets/img/2024-06-30-UnderstandingZero-KnowledgeProofsThroughtheSourceCodeofTornadoCash_3.png)\n\n증명 키에 대한 유효성 검사용 검증 키가 있습니다. 검증 시스템은 공개 입력, 출력 및 검증 키를 사용하여 증명을 검증할 수 있습니다.\n\n![이미지](/assets/img/2024-06-30-UnderstandingZero-KnowledgeProofsThroughtheSourceCodeofTornadoCash_4.png)\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n스낵제이에스는 세레모니를 통해 증명 키 및 검증 키를 생성하고 증명을 생성하며 해당 증명을 확인하는 기능을 제공하는 풀 피처드 도구입니다. 또한 검증을 위한 스마트 계약을 생성할 수 있어 다른 계약에서 제로 지식 증명을 확인하는 데 사용할 수 있습니다. 더 자세한 정보는 스낵제이에스 문서를 확인해 주세요.\n\n지금, 토네이도 캐시(TC)가 어떻게 작동하는지 이해할 수 있는 모든 것이 준비되었습니다. TC 계약에 1이더를 예금할 때 커밋먼트 해시를 제공해야 합니다. 이 커밋먼트 해시는 Merkle 트리에 저장됩니다. 다른 계정으로 이 1이더를 인출할 때는 2개의 제로 지식 증명을 제공해야 합니다. 첫 번째는 Merkle 트리에 당신의 커밋먼트가 포함됨을 증명하는 것입니다. 이 증명은 Merkle 증명의 제로 지식 증명입니다. 하지만 이것만으로 충분하지 않습니다. 당신은 이 1이더를 한 번만 인출할 수 있어야 합니다. 그래서 당신은 커밋먼트에 대한 유일한 널리파를 제공해야 합니다. 계약은 이 널리파를 저장함으로써 당신이 예금한 돈을 두 번 이상 인출하지 못하도록 보장합니다.\n\n널리파의 고유성은 커밋먼트 생성 방법에 의해 보장됩니다. 커밋먼트는 널리파와 비밀을 해싱하여 생성됩니다. 널리파를 변경하면 커밋먼트도 변경되기 때문에 하나의 널리파는 하나의 커밋먼트에만 사용할 수 있습니다. 해싱의 단방향성으로 인해 커밋먼트와 널리파를 연결할 수는 없지만 이에 대한 제로 지식 증명을 생성할 수 있습니다.\n\n![이미지](/assets/img/2024-06-30-UnderstandingZero-KnowledgeProofsThroughtheSourceCodeofTornadoCash_5.png)\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이론을 이해한 후에는 TC의 인출 회로가 어떻게 생겼는지 살펴보겠습니다:\n\n```js\ninclude \"../node_modules/circomlib/circuits/bitify.circom\";\ninclude \"../node_modules/circomlib/circuits/pedersen.circom\";\ninclude \"merkleTree.circom\";\n// Pedersen(nullifier + secret)를 계산합니다.\ntemplate CommitmentHasher() {\n    signal input nullifier;\n    signal input secret;\n    signal output commitment;\n    signal output nullifierHash;\n    component commitmentHasher = Pedersen(496);\n    component nullifierHasher = Pedersen(248);\n    component nullifierBits = Num2Bits(248);\n    component secretBits = Num2Bits(248);\n    nullifierBits.in <== nullifier;\n    secretBits.in <== secret;\n    for (var i = 0; i < 248; i++) {\n        nullifierHasher.in[i] <== nullifierBits.out[i];\n        commitmentHasher.in[i] <== nullifierBits.out[i];\n        commitmentHasher.in[i + 248] <== secretBits.out[i];\n    }\n    commitment <== commitmentHasher.out[0];\n    nullifierHash <== nullifierHasher.out[0];\n}\n// 주어진 비밀과 널리파에 해당하는 묵사가 예금의 Merkle tree에 포함되어 있는지 확인합니다.\ntemplate Withdraw(levels) {\n    signal input root;\n    signal input nullifierHash;\n    signal private input nullifier;\n    signal private input secret;\n    signal private input pathElements[levels];\n    signal private input pathIndices[levels];\n    component hasher = CommitmentHasher();\n    hasher.nullifier <== nullifier;\n    hasher.secret <== secret;\n    hasher.nullifierHash === nullifierHash;\n    component tree = MerkleTreeChecker(levels);\n    tree.leaf <== hasher.commitment;\n    tree.root <== root;\n    for (var i = 0; i < levels; i++) {\n        tree.pathElements[i] <== pathElements[i];\n        tree.pathIndices[i] <== pathIndices[i];\n    }\n}\ncomponent main = Withdraw(20);\r\n```\n\n첫 번째 템플릿은 CommitmentHasher입니다. 널리파 와 시크릿이라고하는 두 개의 랜덤한 248비트 숫자를 입력으로 사용합니다. 템플릿은 널리 파해시 및 커밋먼트 해시를 계산합니다. 이는 널리파와 시크릿의 해시입니다.\n\n두 번째 템플릿은 Withdraw 자체입니다. 해당 템플릿에는 Merkle 루트와 널리 파 해시와 같은 2개의 공개 입력이 있습니다. Merkle root는 Merkle proof를 확인하기 위해 필요하며, 널리파 해시는 스마트 계약에서 저장해야 합니다. 개인 입력 매개 변수는 널리파, 시크릿 및 Merkle proof의 pathElements 및 pathIndices입니다. 회로는 널리파를 검사하여 해당 스마트 계약에서 커밋먼트를 생성하고 지정된 Merkle proof를 검사합니다. 모든 것이 정상이면 TC 스마트 계약에서 확인할 수 있는 제로 지식 증명이 생성됩니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저장소의 contracts 폴더에서 스마트 계약을 찾을 수 있어요. Verifier는 회로에서 생성돼요. Tornado 계약에서는 주어진 널리파 해시 및 Merkle 루트의 ZKP를 확인하는 데 사용돼요.\n\n계약을 사용하는 가장 쉬운 방법은 명령줄 인터페이스를 사용하는 거예요. 이 인터페이스는 JavaScript로 작성되었으며 소스 코드가 비교적 간단해요. 여기에서 매개변수와 ZKP가 생성되고 스마트 계약을 호출하는 데 사용되는 곳을 쉽게 찾을 수 있어요.\n\n제로지식증명은 암호화 세상에서 비교적 새로운 기술이에요. 그 뒤에 숨어있는 수학은 정말 복잡하고 이해하기 어려운데, snarkjs와 circom과 같은 도구를 사용하면 쉽게 사용할 수 있어요. 이 기술에 대해 이 기사가 도움이 되었으면 좋겠어요. 다음 프로젝트에서 ZKP를 사용할 수 있게 되길 바라요.\n\n즐거운 코딩 하세요...\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n업데이트: 해당 주제에 대한 새로운 기사가 있어요:\n\n그리고 Tornado Cash의 소스 코드를 기반으로 한 익명 투표를 위한 JavaScript 라이브러리를 만드는 방법에 대한 또 다른 기사가 있습니다. circom, Solidity 및 JavaScript 코드를 사용한 단계별 자습서입니다:\n\n그리고 이를 기반으로한 투표 시스템을 어떻게 만들었는지 설명하고 있어요:","ogImage":{"url":"/assets/img/2024-06-30-UnderstandingZero-KnowledgeProofsThroughtheSourceCodeofTornadoCash_0.png"},"coverImage":"/assets/img/2024-06-30-UnderstandingZero-KnowledgeProofsThroughtheSourceCodeofTornadoCash_0.png","tag":["Tech"],"readingTime":11},{"title":"React와 Nextjs 프론트엔드 기술 비교 2024년 최신 분석","description":"","date":"2024-06-30 22:06","slug":"2024-06-30-ComparingReactandNextjsFrontendTechnology","content":"\n\n프론트엔드 개발은 지속적으로 발전 중이며, 이 공간에서 두 가지 중요 기술은 React와 Next.js입니다. 이 기사에서는 React와 Next.js를 비교하여 각각의 차이점, 강점, 그리고 약점을 강조해보겠습니다. 추가로, HNG 인턴십에 대한 기대와 React와 함께 일할 때의 생각을 공유할 것입니다.\n\n# React란?\n\n# React의 장점\n\n1. 컴포넌트 기반 아키텍처:\n- 코드 재사용성: React의 컴포넌트 기반 아키텍처는 재사용성을 촉진하여 코드를 더 쉽게 유지하고 확장할 수 있도록 합니다.\n- 모듈화: 컴포넌트는 독립적으로 개발, 테스트, 및 배포될 수 있습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n2. 가상 DOM:\n- 성능: 가상 DOM은 실제 DOM을 직접 조작하는 것을 최소화하여 UI를 업데이트할 때 더 나은 성능을 제공합니다.\n- 효율성: React는 애플리케이션 상태 변경 시 필요한 구성 요소만 효율적으로 업데이트하고 렌더링합니다.\n\n3. 생태계 및 커뮤니티:\n- 거대한 커뮤니티: React에는 방대하고 활발한 커뮤니티가 있어 다양한 리소스, 라이브러리 및 도구를 제공합니다.\n- 다양한 생태계: 라우팅을 위한 React Router와 상태 관리를 위한 Redux와 같은 도구들로 React는 복잡한 애플리케이션을 구축하기 위한 포괄적인 생태계를 제공합니다.\n\n# React의 단점\n\n- JSX 구문: React의 JSX 구문은 새로운 개발자들에게 익숙하지 않을 수 있어 익히는 기간이 필요합니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- **상태 관리**: 대규모 애플리케이션에서 상태를 관리하는 것은 복잡해질 수 있으며 때로는 Redux나 Context API와 같은 추가 라이브러리를 사용해야 하는 경우도 있습니다.\n\n- **설정 및 구성**: React 프로젝트는 종종 Webpack이나 Babel과 같은 빌드 도구를 포함한 상당한 설정 및 구성이 필요합니다.\n\nNext.js는 Vercel에서 개발한 React 프레임워크입니다. 서버 측 렌더링(SSR), 정적 사이트 생성(SSG) 및 기타 강력한 기능을 제공하여 생산 준비가 된 애플리케이션을 구축하는 강력한 솔루션을 제공합니다.\n\n# Next.js의 장점\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- `서버 측 렌더링: SSR은 서버에서 페이지를 렌더링하여 초기 로드 시간을 단축하고 SEO를 향상시킴으로써 성능을 향상시킵니다.\n- `정적 사이트 생성: SSG는 빌드 시간에 정적 HTML을 생성하여 최적의 성능과 확장성을 제공합니다.\n\n- `내장 라우팅: Next.js는 파일 기반 라우팅 시스템을 제공하여 동적 경로를 쉽게 만들 수 있는 기능을 제공합니다.\n\n- `API Routes: Next.js를 통해 동일한 프로젝트 내에서 API 경로를 생성할 수 있어 전체 스택 개발이 용이해집니다.\n\n# Next.js의 단점\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- `SSR`과 `SSG`: `SSR`과 `SSG`를 이해하고 효과적으로 활용하기 위해서는 특히 이 개념에 새로운 개발자들에게는 추가적인 학습이 필요할 수 있습니다.\n\n간단한 애플리케이션의 경우, Next.js는 일반적인 React 설정에 비해 불필요한 복잡성과 오버헤드를 도입할 수 있습니다.\n\n# HNG 인턴십에 대한 기대\n\nHNG 인턴십에 참여하며, 협력적이고 빠른 학습 환경에 몰입하는 것을 고대합니다. 이 프로그램을 통해 실제 프로젝트에 참여하고, 기술을 향상시키며 실무 경험을 쌓을 수 있는 환상적인 기회가 될 것으로 믿습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# HNG에서 React 작업하기\n\nReact는 사용자 인터페이스를 구축하는 강력하고 널리 사용되는 라이브러리입니다. 인턴십 기간 동안 React의 이해를 더 깊이 파고들게 되어 정말 기쁩니다.\n\nReact의 기능을 숙달하고, 최고의 실천 방법을 탐구하며, 영향력 있는 프로젝트에 기여하는 것을 기대하고 있습니다.\n\nHNG 인턴십에 대해 더 알아보려면,\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n방문해보세요: https://hng.tech/internship\n\n만약 재능있는 개발자를 채용하려고 한다면,\n\nHNG Hire를 확인해보세요: https://hng.tech/hire\n\nOR\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nhttps://hng.tech/premium\n\n# 결론\n\nReact와 Next.js는 각각 독특한 장점을 가지고 있습니다. React의 유연성과 광범위한 생태계는 동적 사용자 인터페이스를 구축하는 인기 있는 선택지이며, Next.js의 서버 측 렌더링과 정적 사이트 생성과 같은 제품 준비 기능은 향상된 성능과 개발자 경험을 제공합니다. \n\nHNG 인턴십 여정을 시작하면서 이러한 기술을 활용하고, 기술을 향상시키며 혁신적인 해결책에 기여하고자 합니다. 프론트엔드 개발의 미래는 밝으며, 그 중 일부가 되고 싶습니다.","ogImage":{"url":"/assets/img/2024-06-30-ComparingReactandNextjsFrontendTechnology_0.png"},"coverImage":"/assets/img/2024-06-30-ComparingReactandNextjsFrontendTechnology_0.png","tag":["Tech"],"readingTime":5},{"title":"Python을 사용하여 GitHub 개발 활동 분석하는 방법","description":"","date":"2024-06-30 22:01","slug":"2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython","content":"\n\n<img src=\"/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_0.png\" />\n\nGitHub 개발 데이터는 특정 프로젝트나 회사의 전체 활동을 평가하려는 기관, 투자자, 경쟁업체에게 소중한 통찰을 제공합니다. 이 데이터를 분석함으로써 이해관계자들은 특정 시간대의 최고 기여자를 식별하고 가장 활발한 저장소를 파악하며 프로젝트의 단계별 목표와 활동 수준 사이의 관계를 발견할 수 있습니다.\n\n다음 글에서는 web3 생태계의 여섯 개의 오픈 소스 AI 프로젝트의 GitHub 개발 데이터를 살펴보겠습니다. 이들은 다음과 같습니다:\n\n- Ocean Protocol: 이 프로젝트는 암호화폐 가격 예측 알고리즘부터 데이터 과학 도전과 시장을 위한 다양한 솔루션을 보유하고 있습니다.\n- Bittensor: 이 프로젝트는 탈중앙화된 컴퓨팅으로 AI 민주화를 목표로 하는 모듈식 아키텍처를 가지고 있습니다.\n- Fetch.ai: 이 프로젝트는 SDK를 사용하여 AI 기반 프로젝트를 통해 개발자들이 수익을 창출할 수 있도록 합니다.\n- Numerai: 이 프로젝트는 주식 시장 예측 토너먼트를 주최하며 우승자에게 토큰을 보상합니다.\n- Oraichain: AI의 다차원 신뢰도를 검증하고 독특한 AI 오라클을 활용하여 Web3 애플리케이션을 구축하기 위한 IBC 활성화된 Layer 1입니다.\n- SingularityNET: 이 프로젝트의 임무는 탈중앙화 방식으로 인공 일반 지능(AGI)을 개발하는 것입니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nPython을 사용하여 분석을 진행하기 위해 위에서 언급한 각 프로젝트에 대한 GitHub의 공개 데이터를 활용할 것입니다. 데이터 조작 및 정리에는 Pandas를 사용하고, 시각화에는 Matplotlib 및 Seaborn을 활용하여 가치 있는 통찰을 제공하는 정보적인 차트를 생성할 것입니다. 커밋 빈도, 저장소 생성, 개발자 참여 등과 같은 주요 메트릭을 조사함으로써 개발 참여 수준이 프로젝트 성공의 신뢰할 수 있는 지표인지를 평가할 수 있습니다.\n\n저희의 분석은 GitHub에서의 개발 활동의 중요성과 해당 활동이 이해관계자, 투자자, 경쟁 업체에게 가치 있는 통찰을 제공할 수 있다는 점을 탐색하는 데서 시작할 것입니다. 그 다음으로, 개발 활동에 대한 시간적 분석을 탐구한 다음, 커밋 빈도를 기준으로 프로젝트를 순위 매기겠습니다. 또한 가장 활발하게 활동하는 개발자를 식별하고 순위를 매기며, 주목받는 저장소도 확인하여 각 프로젝트의 역학을 포괄적으로 이해할 수 있도록 할 것입니다.\n\n# GitHub의 개발 활동 데이터의 중요성\n\n개발 활동을 연구하는 것이 왜 중요한지 궁금하다면, 이 섹션에서 이해관계자, 투자자 및 경쟁사에게 특히 중요할 수 있는 몇 가지 핵심 요소를 강조하겠습니다. 함께 살펴보겠습니다:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 이해관계자들\n\n- 프로젝트 건강 및 진행 상황에 대한 통찰력을 얻을 수 있습니다: 이해관계자들은 프로젝트가 활발히 개발되고 있는지, 어떤 기능이 우선 순위에 있는지 이해할 수 있습니다.\n- 프로젝트 역학 이해하기: 시간적 분석을 통해 이해관계자들은 프로젝트 수명주기를 이해하고 중요한 진전 또는 정체 기간을 식별할 수 있습니다. 또한 프로젝트의 주요 이정표들과의 상관 관계를 파악하는 데 도움이 됩니다.\n- 개발자 성과 평가: 많은 커밋 수는 언제나 생산성이 높다는 것을 의미하는 것은 아니지만, 이는 이해관계자들이 개발자의 참여 정도를 이해하고, 그가 회사의 건강한 성장에 기여하는지를 이해하는 데 좋은 지표입니다.\n\n## 투자자들\n\n- 안내된 투자 결정: 커밋 빈도 및 활동 트렌드를 분석함으로써, 투자자들은 활발히 개발되고 유지되는 유망한 프로젝트를 식별할 수 있습니다. 높은 개발 활동은 투자 수익 가능성에 대한 긍정적인 신호가 될 수 있습니다.\n- 프로젝트 장기성 이해하기: 시간적 분석을 통해 투자자들은 프로젝트의 지속 가능성과 장기적 잠재력을 평가할 수 있습니다.\n- 개발자 품질: 개발자들의 활동 및 GitHub 프로필을 알게 되면 투자자들은 프로젝트 뒤에 있는 재능을 볼 수 있습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 경쟁사\n\n- 경쟁 전략 수립: 경쟁사는 경쟁 프로젝트의 개발 활동을 분석하여 그들의 장단점을 이해할 수 있습니다. 이 정보를 활용하여 경쟁사를 앞서가는 전략을 개발할 수 있습니다.\n- 트렌드 파악: 개발 활동의 시계열 분석을 통해 경쟁사는 시장 트렌드를 식별하고 그에 맞게 전략을 조정할 수 있습니다. 어떤 저장소가 가장 많은 관심을 받고 있는지 파악함으로써 경쟁사는 주목받고 있는 분야에 초점을 맞출 수 있습니다.\n\n전반적으로, GitHub 개발 활동을 연구함으로써 이해당사자, 투자자, 경쟁사 및 다른 이야기에서 언급되지 않은 당사자들에게 맞춤형 통찰력을 제공하여 각 그룹이 정보에 근거한 결정을 내리고 소프트웨어 개발 생태계에서 경쟁력을 유지할 수 있도록 도와줍니다.\n\n# 시간별 개발자 활동 분석\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 섹션에서는 각 프로젝트의 시간 경과에 따른 커밋 수와 참여자 수를 조사할 것입니다. 데이터 포인트가 매일 표시하기에 너무 많기 때문에 대신 주간 보기를 사용할 것입니다. 차트에서 범례의 각 색깔은 서로 다른 연도에 해당합니다. 우리는 활동의 증가와 주요 프로젝트 이정표간의 연결을 살펴볼 것이며, 시간이 흐름에 따라 개발 강도가 어떻게 변하는지 확인할 것입니다.\n\n## Bittensor\n\n<img src=\"/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_1.png\" />\n\n위의 Bittensor 차트에서 시간이 흐름에 따라 개발 활동이 점차 증가하는 것을 볼 수 있습니다. 2023년이 가장 많은 커밋과 다른 참여자 수가 있었던 해로, 거의 50명의 개발자가 Bittsensor의 저장소에서 업그레이드를 진행했습니다. 2024년에 관한 데이터가 충분치 않지만, 이미 개발이 크게 감소하고 참여자 수도 줄어든 것을 볼 수 있으며, 이는 2019년과 거의 동일합니다. 그렇지만 우리는 몇몇 중요한 커밋 피크를 볼 수 있습니다. 주로 연도의 처음 4주와 11, 12주쯤에 발생합니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n예를 들어, 1월 17일쯤에 Bittsensor의 토큰 $TAO가 상승한 상위 그룹에 속했다는 기사를 찾을 수 있습니다. 이때가 2024년의 첫 번째 정점이 있는 시기와 비슷합니다. 그러나 토큰의 가격은 개발 활동과 항상 상관관계가 있는 것은 아니므로, 차트에서 가장 큰 정점은 2023년 말에 발생했으며, 이 기간 동안 큰 상승 추세가 없었습니다.\n\n## Fetch.ai\n\n![이미지](/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_2.png)\n\nFetch.ai 차트는 Bittensor의 차트와 매우 다릅니다. 개발 활동은 주로 2017년부터 2021년 사이에 발생한 것을 볼 수 있습니다. 회사는 2017년에 설립되었고 2019년에 출시되었지만, 개발은 2014년에 더 빨리 시작된 것으로 보입니다. 커밋의 주요 정점은 출시의 거의 1년 전인 2018년 중반에 있습니다. GitHub 기여자 수는 2019년에 증가하며, 해당 해에 가장 큰 정점을 나타냅니다. 그 후 바로 2020년 1월 1일에 회사는 메인넷에서 출시되었습니다. 이 이벤트는 2019년 후반에 보다 많은 기여자와 커밋과 관련이 있을 수 있습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n지금까지 개발은 지난 세 년 동안 감소하는 것으로 보이지만, 2024년에는 참여자 수와 커밋 수가 약간 상승하는 추세를 보입니다.\n\n## Numerai\n\n![Numerai](/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_3.png)\n\nNumerai의 전반적인 개발 활동은 크지 않습니다. 2017년과 2021년에는 몇 가지 의미있는 정점이 있습니다. 또한 참여자/기여자 수가 다른 프로젝트와 달리 커밋 수와 관련이 없어 보입니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n2021년의 고점이 Numerai 네트워크 발표와 관련이 있을 수 있습니다. 이 기사에서는 CLI의 업데이트와 예측 노드 구현이 언급되었습니다.\n\n## Ocean Protocol\n\n![Ocean Protocol](/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_4.png)\n\nOcean Protocol 팀은 몇 년 동안 꾸준히 높은 커밋 수를 보여주었으며, 300개 이상의 커밋을 넘는 고점이 있었습니다. 이러한 커밋 고점과 참여자 또는 기여자 수 사이에 상관 관계가 있는 것으로 보이지만, 모든 경우에 일관되게 관찰되는 것은 아닙니다. 그러나 2022년에는 분명한 상관 관계가 있습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nPredictoor는 2023년 9월 12일 경부 출시되었습니다 (37주차), 이 날짜 이전에는 개발에서 상당한 피크가 있었는데, 이는 해당 이벤트와 관련이 있을 수 있습니다.\n\n가장 큰 피크는 2020년 41주에서 43주에 발생했는데, 바로 Ocean Protocol V3가 출시된 후였습니다. 이에 관한 기사를 확인할 수 있습니다:\n\n2024년에는 2023년과 비교했을 때 개발 활동이 현저히 감소했으며, 저장소에서 활발히 작업하는 기여자 수도 감소했습니다. 그러나 이는 반드시 전체 연도에 대한 지속적인 추세를 나타내지는 않을 수 있습니다. 2020년과 마찬가지로, 개발 면에서는 천천히 시작되었지만 연말에는 급증세를 지켜볼 수 있을 것입니다.\n\n## Oraichain\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![이미지](/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_5.png)\n\nOraichain Labs 차트를 보면 커밋 수와 참여자/기여자 수 사이에 명확한 상관 관계가 있는 것을 볼 수 있습니다. 2020년 말에 개발이 속도를 내며, 이는 2021년 2월의 공식 발표와 관련이 있을 수 있습니다.\n\n2023년은 개발에서 가장 활발한 해로, 이 추세가 2024년으로 이어지고 있습니다. 이 급증은 해커톤, 지갑 업데이트 및 통합과 같은 중요한 프로젝트 이정표를 반영하고 있습니다. 상대적으로 새로운 프로젝트이기 때문에, 특히 최근 몇 주간 다른 AI 프로젝트들보다 더 높은 개발 강도를 보여주고 있습니다.\n\n## 싱귤러리티넷\n\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![Image](/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_6.png)\n\n이 차트는 SingularityNET의 개발이 2018년부터 2020년 사이에 정점에 이른 것을 보여줍니다. 이후 커밋 활동 및 기여자 수가 감소하는 추세를 보였습니다. 이 기사에 따르면, 백엔드 소프트웨어는 2019년에 성숙기에 이르렀으며 이는 또한 가장 많은 개발이 이루어진 해입니다.\n\n2024년에는 2023년과 비교했을 때 개발이 증가하는 것을 볼 수 있습니다. 이는 2018년부터 2020년 사이와 유사한 고개발의 새로운 이후를 나타낼 수 있습니다.\n\n# 시간에 따른 개발자 활동 분석 (코드)\n\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n제공된 데이터셋은 즉시 분석에 사용할 수 있는 상태가 아니라 데이터 조작 기술을 적용하여 작업해야 합니다. 먼저 각 행별로 데이터셋에서 의미 있는 정보를 추출하고, 분석을 위해 다른 정리된 데이터프레임을 생성하기 위해 두 가지 함수를 만듭니다.\n\n```js\nimport pandas as pd\n\ndef process_commits_row(row):\n    \"\"\" 이 함수는 데이터셋의 각 행에서 의미 있는 정보를 추출하여 딕셔너리로 반환합니다. 'repo' 변수가\n    나중에 저장소 데이터셋과 병합하는 데 사용됨에 유의하세요. \"\"\"\n    repo = \\\n        row['url'].split('repos')[1].split('commits')[0].split(\"/\")[-2]\n    return {\n        'sha': row['sha'],\n        'repo': repo,\n        'node_id': row['node_id'],\n        'author': row['commit']['author']['name'],\n        'date': row['commit']['author']['date'],\n        'message': row['commit']['message']}\n\ndef gen_df_commits_filt(df):\n    \"\"\" 이 함수는 데이터셋을 반복하면서 'process_commits_row' 함수를 각 행에 적용합니다. 결과는\n    딕셔너리의 목록으로 반환되어 최종적으로 DataFrame으로 반환됩니다. \"\"\"\n    all_features = []\n    for row in df.iterrows():\n        for i in range(1, len(row[1]) - 1):\n            try:\n                all_features.append(process_commits_row(row[1][i]))\n            except Exception:\n                pass\n    return pd.DataFrame(all_features)\n```\n\n위의 함수들은 각 프로젝트의 커밋 데이터셋을 대상으로 합니다. 이 두 함수를 함께 사용하여 sha, repo, node_id, author, date 및 message의 특징을 가진 필터링된 데이터프레임을 생성합니다. 그런 다음 데이터셋을 호출하고 각각의 데이터셋에 gen_df_commits_filt() 함수를 적용할 수 있습니다.\n\n```js\n# 데이터셋 호출\ndf_commits_bittensor = pd.read_json('datasets/bittensor_commits.json')\ndf_commits_fetchai = pd.read_json('datasets/fetchai_commits.json')\ndf_commits_numerai = pd.read_json('datasets/numerai_commits.json')\ndf_commits_ocean = pd.read_json('datasets/oceanprotocol_commits.json')\ndf_commits_oraichain = pd.read_json('datasets/oraichain_commits.json')\ndf_commits_singular = pd.read_json('datasets/singularitynet_commits.json')\n\n# 데이터셋 필터링\ndf_commits_bittensor_filt = gen_df_commits_filt(df_commits_bittensor)\ndf_commits_fetchai_filt = gen_df_commits_filt(df_commits_fetchai)\ndf_commits_numerai_filt = gen_df_commits_filt(df_commits_numerai)\ndf_commits_ocean_filt = gen_df_commits_filt(df_commits_ocean)\ndf_commits_oraichain_filt = gen_df_commits_filt(df_commits_oraichain)\ndf_commits_singular_filt = gen_df_commits_filt(df_commits_singular)\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n날짜별로 그룹화된 데이터셋을 사용하여 시간별 사용자 활동을 관찰할 수 있습니다. 이전에 언급했듯이 날짜 데이터가 너무 많아서 차트에 표시하기에는 많았기 때문에 주차별, 연도별로 그룹화했습니다. 아래 함수를 사용하여 그룹화했습니다:\n\n```js\ndef gen_group_week(filt_dataframe):\n    \"\"\" 이 함수는 필터링된 데이터셋을 주별로 그룹화합니다 \"\"\"\n    df_commits_temp = filt_dataframe.sort_values(\n        by='date')[['date', 'sha', 'repo', 'author', 'message']]\n    df_commits_temp.date = df_commits_temp.date.apply(\n        lambda x: datetime.strptime(x, '%Y-%m-%dT%H:%M:%SZ'))\n    df_commits_temp['week'] = df_commits_temp['date'].dt.strftime('%W-%Y')\n    df_commits_temp = df_commits_temp.groupby('week').agg(\n        {\n            'sha': 'count',\n            'repo': 'nunique',\n            'author': 'nunique'}).reset_index().rename(\n            columns={\n                'sha': 'n_commits',\n                'author': 'n_participants',\n                'repo': 'n_repos'})\n    df_commits_temp['week_num'] = \\\n        df_commits_temp['week'].str.split('-').str[0].astype(int)\n    df_commits_temp['year'] = \\\n        df_commits_temp['week'].str.split('-').str[1].astype(int)\n    df_commits_temp = df_commits_temp.sort_values(by=['year', 'week_num'])\n    return df_commits_temp\n```\n\n마지막으로, 필터링된 각 데이터셋에 이 함수를 적용했습니다.\n\n```js\ndf_commits_bittensor_week = gen_group_week(df_commits_bittensor_filt)\ndf_commits_fetchai_week = gen_group_week(df_commits_fetchai_filt)\ndf_commits_numerai_week = gen_group_week(df_commits_numerai_filt)\ndf_commits_ocean_week = gen_group_week(df_commits_ocean_filt)\ndf_commits_oraichain_week = gen_group_week(df_commits_oraichain_filt)\ndf_commits_singular_week = gen_group_week(df_commits_singular_filt)\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 이전에 표시된 막대 차트를 구동한 코드를 살펴보겠습니다.\n\n```js\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom datetime import datetime\n\ndef chart_user_activity(df, protocol):\n    \"\"\" 사용자 활동에 대한 시간별 막대 차트 작성 \"\"\"\n    fig, ax1 = plt.subplots(figsize=(20, 8))\n    # 필요에 따라 색상 수를 조정할 수 있습니다\n    colors = sns.color_palette('tab10', len(df['year'].unique()))\n    # 각 고유 연도를 색상에 매핑하는 딕셔너리 생성\n    year_colors = dict(zip(df['year'].unique(), colors))\n    sns.barplot(\n        df,\n        x='week',\n        y='n_commits',\n        hue='year',\n        ax=ax1,\n        dodge=False,\n        palette=year_colors)\n    ax1.set_xlabel('주', fontsize=18)\n    ax1.set_ylabel('커밋 수', fontsize=18)\n    ax1.tick_params('y', labelsize=12)\n    ax1.set_title(f\"{protocol} 개발자 활동 시간별\", fontsize=30)\n    ax1.grid(axis='y', which='major', linestyle='--', linewidth=0.5)\n    ax2 = ax1.twinx()\n    sns.lineplot(\n        df,\n        x='week',\n        y='n_participants',\n        ax=ax2,\n        linestyle='--',\n        marker='o',\n        color='r',\n        alpha=0.5)\n    ax2.set_ylabel('참가자 수', fontsize=18, color='r')\n    ax2.tick_params('y', colors='r', labelsize=12)\n    ax2.xaxis.set_ticks(df['week'][::10])\n    ax1.spines['top'].set_visible(False)\n    ax2.spines['top'].set_visible(False)\n    # x축 눈금 라벨에서 연도 부분 제거\n    labels = [item.get_text().split('-')[0] for item in ax1.get_xticklabels()]\n    ax1.set_xticklabels(labels)\n    ax1.tick_params('x', labelsize=12)\n    ax2.set_ylim(bottom=0)\n    plt.show()\n```\n\n차트를 표시하려면 다음과 같이 간단히 수행할 수 있습니다:\n\n```js\nchart_user_activity(df_commits_bittensor_week, 'Bittensor')\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 프로젝트 활동 기준으로 순위 매기기\n\n이 섹션에서는 서로 다른 프로젝트에서 시간이 지남에 따라 사용된 커밋 수와 리포지토리 수를 비교해 보겠습니다.\n\n![이미지](/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_7.png)\n\n위 막대 차트는 시간이 지남에 따른 커밋의 진화와 연도별 사용된 다른 리포지토리의 수를 확인할 수 있습니다. 이 차트들을 검토하면 몇 가지 초기 관찰을 할 수 있습니다:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 가장 많은 커밋(41465)을 가진 프로젝트는 Fetch.ai이며, 그 다음으로 Ocean Protocol이 33626개의 커밋을 가지고 있습니다. Fetch.ai가 가장 많은 커밋을 가졌다는 사실은 GitHub에서의 장기간 활동으로 인해 놀랍지 않습니다. Ocean Protocol은 4년 뒤에 시작했지만 이미 다른 최근 프로젝트와 비교하여 인상적인 개발 활동을 보여주고 있습니다.\n- Bittensor, Ocean Protocol, Oraichain, 그리고 Numerai는 해마다 저장소 수를 늘리고 있으며, 2023년에는 가장 많은 저장소 사용량을 가지고 있습니다. 2024년에는 이 수가 늘어날 수 있습니다. 그러나 이 명제를 확인하기 위해 모든 데이터를 아직 갖고 있지는 않습니다.\n- Oraichain은 커밋 수와 저장소 수 사이에 높은 상관 관계를 보여줍니다. Bittensor도 어느 정도 상관 관계를 보여주지만, 다른 프로젝트에는 해당되지 않습니다.\n- 저장소 수에 대해서는, Oraichain과 Ocean Protocol이 가장 많으며, 명확히 연도별로 늘어나고 있습니다.\n- Bittensor, Ocean Protocol, 그리고 Oraichain은 연도별로 커밋 수를 늘리고 있으며, SingularityNET은 Numerai와 함께 줄어들고 있습니다. Fetch.ai는 벨 모양 곡선을 보여주는데, 개발이 2018년, 2019년, 2020년에 매우 많았지만, 최초와 최근 연도에는 낮았습니다.\n\n간단히 말하면, 각 프로젝트의 연도별 커밋을 합산하여 순위를 매기려면 다음과 같은 결과를 얻을 수 있습니다:\n\n- Fetch.ai — 41465 개의 커밋.\n- Ocean Protocol — 3362 개의 커밋.\n- SingularityNET — 26245 개의 커밋.\n- Bittensor — 23336 개의 커밋.\n- Oraichain — 21136 개의 커밋.\n- Numerai — 2543 개의 커밋.\n\n# 활동에 따른 프로젝트 순위 (코드)\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 연도별로 필터된 데이터셋을 그룹화하는 함수입니다.\n\n```js\ndef gen_group_year(filt_dataframe):\n    \"\"\" 필터된 데이터셋을 연도별로 그룹화하는 함수입니다 \"\"\"\n    df_commits_temp = filt_dataframe.sort_values(\n        by='date')[['date', 'sha', 'repo', 'author', 'message']]\n    df_commits_temp['date'] = pd.to_datetime(df_commits_temp['date'])\n    df_commits_temp['year'] = df_commits_temp['date'].dt.year\n    df_commits_temp = df_commits_temp.groupby('year').agg(\n            {\n                'sha': 'count',\n                'repo': 'nunique',\n                'author': 'nunique'}).reset_index().rename(\n                columns={\n                    'sha': 'n_commits',\n                    'author': 'n_participants',\n                    'repo': 'n_repos'})\n    return df_commits_temp\n```\n\n이제 각 프로젝트에 함수를 적용해봅시다:\n\n```js\ndf_commits_bittensor_year = gen_group_year(df_commits_bittensor_filt)\ndf_commits_fetchai_year = gen_group_year(df_commits_fetchai_filt)\ndf_commits_numerai_year = gen_group_year(df_commits_numerai_filt)\ndf_commits_ocean_year = gen_group_year(df_commits_ocean_filt)\ndf_commits_oraichain_year = gen_group_year(df_commits_oraichain_filt)\ndf_commits_singular_year = gen_group_year(df_commits_singular_filt)\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 차트의 코드입니다:\n\n```js\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom datetime import datetime\n\ndef bar_activity_n_repos(datasets, main_title, subplot_titles):\n    \"\"\" Make bar char for activity and repos over time \"\"\"\n    num_datasets = len(datasets)\n    num_rows = (num_datasets + 1) // 2\n    fig, axes = plt.subplots(num_rows, 2, figsize=(14, 7*num_rows))\n    fig.suptitle(main_title, fontsize=30)\n    for i, (df, title) in enumerate(zip(datasets, subplot_titles)):\n        row = i // 2\n        col = i % 2\n        ax = axes[row, col]\n        sns.barplot(\n            x=\"year\",\n            y=\"n_commits\",\n            hue='n_repos',\n            data=df,\n            dodge=False,\n            palette='Blues',\n            ax=ax)\n        ax.spines['top'].set_visible(False)\n        ax.set_ylabel('Commits', fontsize=14)\n        ax.set_xlabel('Years', fontsize=14)\n        ax.set_title(title, fontsize=20)\n        ax.grid(axis='y', which='major', linestyle='--', linewidth=0.5)\n        legend = ax.legend()\n        legend.set_title(\"Repositories\")  # Setting legend title\n        # Add a red horizontal line for the mean of commits\n        mean_commits = df['n_commits'].mean()\n        ax.axhline(y=mean_commits, color='red', linestyle='--', label='mean')\n        # Annotate mean value above the line\n        ax.text(\n            0.05,\n            mean_commits * 1.05,\n            f'Mean: {mean_commits:.2f}',\n            color='red',\n            fontsize=12,\n            va='bottom')\n    plt.tight_layout(rect=[0, 0.03, 1, 0.95])  # Adjust subplot title position\n    plt.subplots_adjust(hspace=0.2, wspace=0.2)  # Add gap between charts\n    plt.show()\r\n```\n\n# 가장 활발한 개발자 순위\n\n이 섹션에서는 각 프로젝트에서 가장 활발한 개발자를 살펴보고, 그들의 상호작용을 시간에 따라 살펴볼 것입니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다가오는 차트는 막대 그래프입니다. 첫 번째 차트는 연도별로 커밋 수가 가장 많은 상위 10명의 저자를 보여주며, 두 번째 차트는 매년 가장 활발한 개발자를 순위로 나타냅니다. 각 프로젝트에 대해 두 차트를 살펴봐요.\n\n## Bittensor\n\n![Bittensor Chart](/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_8.png)\n\n위의 막대 차트를 보면, 각 개발자가 매년 비슷한 수의 커밋을 하지 않는다는 것을 알 수 있습니다. 즉, 저자들은 매년 비슷한 수의 커밋을 하지 않는다는 것입니다. 이는 각 개발자가 자신의 전문 분야가 있고, 가장 익숙한 기술에 대해 작업하기 때문일 수 있습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n개발 초기 몇 년(2017년, 2018년 및 2029년)에는 Pierre Krieger, Robert Habermeier 및 Bastian Kocher가 프로젝트 개발에 참여했습니다. 그 중 일부는 Polkadot에서 알려져 있습니다. 이야기해야 할 것은 2019년에 Gavin Wood도 프로젝트 개발에 합류했다는 것입니다.\n\n가장 많은 커밋이 이루어진 고점은 Carro가 2022년에 기여했습니다. 동일한 개발자가 2023년에도 일부 기여를 했으며, 전반적으로 이 분은 이러한 연도에 발생한 특정 작업에 중요한 역할을 한 것으로 보입니다.\n\n마지막 몇 년 동안 p-ferreira가 2023년과 2024년에 가장 많은 커밋을 한 것으로 보입니다. Cameron Fairchild는 최근 몇 년간 높은 헌신을 보여주었지만 2024년에는 그렇게 많이 하지는 않은 것 같습니다.\n\n이제 연도별 총 커밋 수를 기준으로 개발자들을 순위 매겨 보겠습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래 차트를 기준으로:\n\n- 2017년에는 Robert Habermeier가 가장 많은 커밋을 하였으며, 2018년에는 Gavin Wood가 활약했습니다.\n- 2019년에는 Bastian Kocher가 가장 활발하였습니다.\n- unconst는 2020년, 2021년, 2023년에 1위를 기록했습니다.\n- 2022년에는 Carro가 가장 높은 피크에 기여한 바 있습니다.\n- 현재까지는 p-ferreira가 2024년 가장 활발하게 활동 중입니다.\n\n전체 기간을 살펴보면, Bastian Kocher가 프로젝트에서 가장 많은 커밋을 하였으며, unconst가 그 뒤를 이었습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 페치.에이\n\n![이미지](/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_10.png)\n\n위 차트에서 우리는 상위 10명의 개발자 중 아무도 2024년에 기여를 하지 않고 있다는 것을 결론 지을 수 있습니다. 가장 최근의 커밋은 2022년과 2023년이며, 이는 ali와 Yuri Turchenkov에 의해 이루어졌습니다. David Minarsch는 2021년에 매우 활발히 활동했으며 커밋의 최고 피크(2500건 이상)는 2020년에 그에 의해 이루어졌습니다. Ethan Buchman 역시 2016년부터 2018년 사이에 많은 커밋을 하였지만, 2019년 이후로 활동이 없습니다. 또한 이 프로젝트에서 일한 최초의 사람 중 한 명이기도 하지만, 최초의 커밋은 Jae Kwon에 의해 이루어졌습니다.\n\n이제 각 연도별로 가장 활발하게 활동한 개발자들을 살펴봅시다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_11.png]을(를) 참고하면 다음과 같습니다:\n\n- Jae Kwon은 프로젝트 시작 시점인 2014년과 2015년에 가장 활발하게 개발을 진행했습니다.\n- Ethan Buchman은 2016년, 2017년 및 2018년에 리더였습니다.\n- David Minarsch는 2019년, 2020년 및 2021년에 가장 많은 커밋을 했습니다.\n- Yuri Turchenkov은 2022년에 119개의 커밋을 했습니다.\n- James Riehl은 2023년과 2024년에 가장 많은 커밋을 했습니다.\n\n전체적으로 Ethan Buchman(5911개의 커밋)이 가장 활발한 개발자였고, David Minarsch(5002개의 커밋)와 Jae Kwon(2604개의 커밋)이 이어졌습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## Numerai\n\n![image](/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_12.png)\n\n위 차트에서 전체 커밋 수가 가장 많은 상위 10명의 개발자를 볼 수 있습니다. Keith Goodman과 Xander Dunn은 2017년과 2018년에 가장 많은 커밋을 보였습니다. 그러나 현재는 더이상 기여를 하지 않는 것으로 보입니다. 몇 년 동안 가장 꾸준하게 활동한 개발자는 Anson Chu로 보입니다.\n\n지난 몇 년간 Noah Harasz는 꽤 활발히 활동했습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 목록의 대부분의 개발자는 1년에서 2년 사이에 기여하였으며, 참여할 때 상당히 활발하지만 오랫동안 머무르지 않았습니다.\n\n이제 각 연도별 주요 기여자를 분석해보겠습니다.\n\n![chart](/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_13.png)\n\n차트를 살펴보면:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 첫 번째 실제 개발은 2017년에 키스 굿맨(Kieth Goodman)과 함께 시작되었고, 2018년까지 계속되었습니다.\n- 2019년에는 제이슨 파리아니(Jason Paryani)가 주도하며, 2020년에는 나타샤-제이드 챈들러(Natasha-Jade Chandler)의 시기였습니다.\n- 2021년에는 titbtcqash의 시기였습니다.\n- 2023년과 2024년에는 노아 하라즈(Noah Harasz)가 가장 많은 커밋을 했습니다.\n\n총적으로, 키스 굿맨이 822개의 커밋으로 현저히 가장 활발한 개발자였습니다. 그 다음으로는 노아 하라즈가 207개의 커밋, 그리고 제이슨 파리아니가 196개의 커밋을 했습니다.\n\n## Ocean Protocol\n\n![Ocean Protocol Image](/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_14.png)\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 막대 차트에서 우리는 Ocean Protocol에서 활발히 활동하는 상위 10명의 개발자를 볼 수 있습니다. Matthias Kretschmann은 처음부터 개발을 해오고 있으며, 지난 두 해 동안 커밋을 하지 않았더라도, 여전히 이전에 가장 활발한 개발자입니다. Trent McConaghy는 (trentmc) 이름으로 차트에 두 번 나타나며, 최고의 협력자 중 하나이기도 하며, 지난 몇 년간 상당히 활발하게 활동했습니다. Matthias Kretschmann은 가장 많은 커밋 피크를 보여주지만, Jamie Hewitt와 Norbert도 최근 몇 년간 두 가지 중요한 피크를 보여줍니다.\n\n이제 연도별 최고 기여자를 살펴봅시다.\n\n![chart](/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_15.png)\n\n위의 차트를 관찰함으로써 다음을 결론짓을 수 있습니다:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- Matthias Kretschmann은 2018년부터 2021년까지 가장 활발하게 활동한 개발자였습니다. 또한 프로젝트 전체에서 가장 많은 커밋을 보유한 저자입니다(4666개의 커밋).\n- Jamie Hewitt은 2022년에 우세하며, 또한 두 번째로 활발한 개발자입니다(2133개의 커밋).\n- Norbert은 2023년에 우세합니다.\n- 2024년에는 Trent McConaghy가 지금까지 가장 많은 커밋을 가지고 있습니다.\n\n## Oraichain\n\n![image](/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_16.png)\n\nOraichain의 가장 활발한 10명의 개발자가 위의 막대 차트로 나타나 있습니다. 해당 그림은 몇 개의 봉우리로 특징 지어집니다. 개발자들이 1년에서 2년 사이에 노력을 집중했음을 나타냅니다. Thunnini은 2019년부터 2021년까지 매우 활발하게 활동했으며, Le Duc Pham과 함께였습니다. 가장 높은 커밋 피크는 Pham Tu에 의해 2023년에 기록되었습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n최근 가장 많은 커밋을 한 개발자는 Hau Nguyen Van, Toan Dang, sonlha 그리고 ducphamle2라는 이름의 Le Duc Pham입니다.\n\n이제 각 연도별로 가장 활발한 개발자들을 살펴보겠습니다.\n\n![2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_17.png](/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_17.png)\n\n상단의 막대 차트는 다음 정보를 제공합니다:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- Yury Delendik은 2018년에 가장 활발히 활동했습니다.\n- 2019년부터 2021년까지 Thunnini가 커밋 수에서 우세했습니다.\n- 2022년에는 Le Duc Pham이 선두를 차지했습니다.\n- 2023년에는 Pham Tu가 모든 기간에 가장 많은 커밋을 했습니다.\n- 2024년에는 Hau Nguyen Van이 가장 활발한 개발자입니다.\n\n예상대로, Thunnini가 총 커밋 수로 가장 많은(2458건)를 기록했습니다. 이어서 Pham Tu(2427건)와 Le Duc Pham(2273건) 순으로 나타났습니다.\n\n## SingularityNET\n\n<img src=\"/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_18.png\" />\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 표에서 볼 수 있듯이, 상위 10명의 가장 활발한 개발자는 대부분 2018년부터 2021년 사이에 활동했으며 몇 가지 예외가 있습니다. 일부 개발자는 몇 년 동안 일관성을 보였는데, 이들은 Prashant Gupta, anandrgitnirman, dasari-ananya 및 Sridhar Babu Kolapalli입니다. 초기 개발은 특히 Vitaly Bogdanov에 의해 표시되었으며, 커밋의 최고점은 2019년 Vivek에 의해 이루어졌습니다.\n\nRajeev는 최근 몇 년간 가장 활발한 개발자 중 한 명이었으며, anandrgitnirman과 함께 활동하고 있었습니다.\n\n이제 매년 최고의 개발자들을 살펴보는 시간입니다.\n\n![이미지](/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_19.png)\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 차트에서 다음을 결론지을 수 있습니다:\n\n- Marco Argentieri는 프로젝트 초창기(2017년)에 가장 활발했습니다.\n- 2018년에는 Vitaly Bogdanov가 선두를 담당했습니다.\n- 가장 높은 커밋 피크는 2019년에 Vivek이 올렸습니다.\n- 2020년은 Pratik의 시기였고, 2021년은 Rajeev의 시간이었으며, 2022년은 anandrgitnirman의 시기였습니다.\n- Marco Capozzoli는 최근 몇 년간 가장 활발한 개발자였습니다.\n\n다른 프로젝트와 달리, 대부분의 경우 연도별로 한 명의 개발자가 있으며, 한 명의 개발자가 여러 해 동안 지배하는 경우는 드뭅니다. 그래도 Marco Capozzoli는 2023년과 2024년에 1위를 차지했습니다. 전체적으로 Vivek이 1927개의 커밋으로 가장 활발했고, 그 뒤를 이어 anandrgitnirman의 1340개 커밋, 마지막으로 Vitaly Bogdanov의 1106개 커밋이 이어졌습니다.\n\n# 활동에 따라 저장소 순위 매기기\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 섹션에서는 각 프로젝트에서 활동이 가장 많은 상위 10개 저장소를 살펴보겠습니다. 이는 프로젝트 저장소에 제출된 커밋 수로 측정됩니다.\n\n## Bittensor\n\n현재 Bittensor는 총 31개의 저장소를 보유하고 있지만, 시간상의 이유로 상위 10개 저장소만 고려하여 시각화를 더 잘하고 가장 활발한 저장소에 대해 심층적인 연구를 할 것입니다.\n\n![이미지](/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_20.png)\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 커밋 수에 따라 정렬된 상위 10개 리포지토리 목록과 각각의 GitHub 저장소가 있습니다:\n\n- polkadot-sdk: https://github.com/opentensor/polkadot-sdk\n- bittensor: https://github.com/opentensor/bittensor\n- subtensor: https://github.com/opentensor/subtensor\n- prompting: https://github.com/opentensor/prompting\n- developer-docs: https://github.com/opentensor/developer-docs\n- old-docs: https://github.com/opentensor/old-docs\n- validators: https://github.com/opentensor/validators\n- text-prompting: https://github.com/opentensor/text-prompting\n- mem-pytorch: https://github.com/opentensor/mem-pytorch\n- squid: https://github.com/opentensor/squid\n\npolkadot-sdk는 가장 많은 커밋 수(13789개)를 가진 저장소로, Polkadot 네트워크에서 개발을 시작하는 데 필요한 모든 리소스를 제공합니다. 이것은 또한 Polkadot의 개발자들이이 프로젝트에 참여하는 이유입니다. 목록에서 두 번째로 많은 커밋을 가진 저장소인 bittensor가 뒤를 이어 나옵니다.\n\n세 번째로는 subtensor가 차지하는데, 이는 Bittensor의 substrate-chain입니다. 이 저장소는 다음을 수행합니다:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- Bittensor의 합의 메커니즘 실행\n- 신경 정보, IP 등을 광고합니다.\n- TAO를 통해 가치 이체를 용이하게 함.\n\n## Fetch.ai\n\n현재 Fetch.ai는 57개의 저장소를 가지고 있습니다. 하지만 우리는 상위 10개 저장소만 살펴보고 더 나은 시각화를 위해 최고 활동적인 저장소에 대해 심층적인 연구를 진행할 것입니다.\n\n![이미지](/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_21.png)\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 커밋 수를 기준으로 정렬된 상위 10개 리포지토리와 해당 GitHub 저장소 목록입니다:\n\n- agents-aea: [링크](https://github.com/fetchai/agents-aea)\n- tendermint: [링크](https://github.com/fetchai/tendermint)\n- cosmos-consensus: [링크](https://github.com/fetchai/cosmos-consensus)\n- cosmos-sdk: [링크](https://github.com/fetchai/cosmos-sdk)\n- ledger: [링크](https://github.com/fetchai/ledger)\n- ledger-archive: [링크](https://github.com/fetchai/ledger-archive)\n- agents-tac: [링크](https://github.com/fetchai/agents-tac)\n- cosmos-explorer: [링크](https://github.com/fetchai/cosmos-explorer)\n- docs: [링크](https://github.com/fetchai/docs)\n- colearn: [링크](https://github.com/fetchai/colearn)\n\n1위는 1천 개 이상의 커밋을 기록한 agents-aea입니다. 이 저장소는 자율 경제 에이전트를 만들 수 있도록 합니다. 두 번째는 tendermint이며, Cosmos 블록체인 환경에서 매우 흔한 비잔틴 장애 허용 (BFT) 미들웨어입니다. cosmos-consensus가 세 번째로 순위되어 있습니다. 일반적으로 Fetch.ai는 여러 Cosmos 블록체인 리포지토리를 사용합니다.\n\n## Numerai\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNumerai은 현재 21개의 저장소가 있지만 시각화를 더 잘 하기 위해 상위 10개 저장소만 살펴보고 가장 활발한 저장소에 대해 심층 연구를 할 것입니다.\n\n아래는 커밋 수로 정렬된 상위 10개 저장소 목록과 해당 GitHub 저장소입니다:\n\n- numerox: https://github.com/numerai/numer\n- doc: https://github.com/numerai/docs\n- example-scripts: https://github.com/numerai/example-scripts\n- submission-criteria: https://github.com/numerai/submission-criteria\n- numerai-cli: https://github.com/numerai/numerai-cli\n- doc-jp: https://github.com/numerai/docs-jp\n- heroku-buildpack-polymer: https://github.com/numerai/heroku-buildpack-polymer\n- numerai-predict: https://github.com/numerai/numerai-predict\n- tournament-data-integrity: https://github.com/numerai/tournament-data-integrity\n- tournament-contracts: https://github.com/numerai/tournament-contracts\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nnumerox가 가장 많은 커밋을 가진 저장소입니다. Numerai 토너먼트 도구 상자입니다. 두 번째로 활발한 것은 Numerai에 관한 자습서와 문서가 있는 docs입니다. 세 번째로는 이름 그대로 Numerai 토너먼트를 위한 코드 예제를 보여주기 위해 할애된 example-scripts입니다.\n\n## Ocean Protocol\n\n현재 쓰고 있는 시점에서 Ocean Protocol은 79개의 저장소를 보유하고 있지만, 가장 활동적인 저장소를 파악하고 깊은 연구를 하기 쉽도록 상위 10개 저장소만 분석하겠습니다.\n\n![이미지](/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_23.png)\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 커밋 수로 정렬된 상위 10개 저장소 목록과 해당 GitHub 저장소가 있습니다:\n\n- pdr-docs: https://github.com/oceanprotocol/pdr-docs\n- docs: https://github.com/oceanprotocol/docs\n- ocean.js: https://github.com/oceanprotocol/ocean.js\n- marketplace-launchpad: https://github.com/oceanprotocol/marketplace-launchpad\n- market: https://github.com/oceanprotocol/market\n- waves: https://github.com/oceanprotocol/waves\n- df-web: https://github.com/oceanprotocol/df-web\n- contracts: https://github.com/oceanprotocol/contracts\n- ocean.py: https://github.com/oceanprotocol/ocean.py\n- aquarius: https://github.com/oceanprotocol/aquarius\n\nOcean Protocol 프로젝트에서 문서 작성이 중요합니다. 가장 활발한 두 저장소는 문서와 관련이 있으며, 첫 번째는 Predictoor를 위한 것이고 두 번째는 일반 스택을 위한 것입니다. 차트는 Predictoor가 팀이 우선순위를 두고 있는 도구라는 것을 시사하며, 이는 높은 커밋 수와 매우 상세한 문서화로 확인할 수 있습니다. 세 번째로는 Ocean의 프로토콜 기술을 사용할 수 있게 해주는 ocean.js가 있습니다. 커밋 수를 보면, JavaScript가 Python보다 더 많이 요청된다고 가정할 수 있습니다. 왜냐하면 ocean.py 패키지도 있지만 활동이 훨씬 적습니다.\n\n네 번째로, 개발자들이 자신만의 마켓플레이스를 만드는 방법을 가르치는 marketplace-launchpad이 있습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## Oraichain\n\nOraichain은 109개의 저장소가 있습니다. 그러나 시각화를 용이하게 하고 가장 활발한 것을 더 깊이 연구하기 위해 상위 10개 저장소만 보겠습니다.\n\n![이미지](/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_24.png)\n\n아래는 커밋 수에 따라 정렬된 상위 10개 저장소 목록이며, 각 저장소의 GitHub 저장소입니다:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- owallet: https://github.com/oraichain/owallet\n- oraiswap-frontend: https://github.com/oraichain/oraiswap-frontend\n- oraiscan-frontend: https://github.com/oraichain/oraiscan-frontend\n- keplr-extension-orai: https://github.com/oraichain/keplr-extension-orai\n- oraidex-sdk: https://github.com/oraichain/oraidex-sdk\n- smart-studio: https://github.com/oraichain/smart-studio\n- orai: https://github.com/oraichain/orai\n- oraiswap: https://github.com/oraichain/oraiswap\n- oraiwasm: https://github.com/oraichain/oraiwasm\n- cosmosjs: https://github.com/oraichain/cosmosjs\n\n위 차트를 보면 owallet이 가장 활동적인 프로젝트임을 알 수 있습니다. 이 지갑은 Cosmos 및 EVM 통합을 지원합니다. 두 번째로 활발한 저장소는 Oraichain DEX의 일부인 oraiswap-frontend입니다. 가장 활발한 3번째 저장소는 Oraichain을 위한 블록 익스플로러인 oraiscan-frontend입니다.\n\n## 싱귤래리티넷\n\n싱귤래리티넷은 목록에서 가장 많은 저장소(116개)를 보유한 프로젝트입니다. 그러나 더 나은 시각화를 위해 상위 10개 저장소만 살펴보고 각각에 대해 약간 깊이 파고들어보겠습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 커밋 수에 따라 순서가 매겨진 상위 10개 저장소 목록과 해당 GitHub 저장소가 있습니다:\n\n- snet-marketplace-service: https://github.com/singnet/snet-marketplace-service\n- snet-dapp: https://github.com/singnet/snet-dapp\n- snet-daemon: https://github.com/singnet/snet-daemon\n- dev-portal: https://github.com/singnet/dev-portal\n- snet-cli: https://github.com/singnet/snet-cli\n- airdrop-services: https://github.com/singnet/airdrop-services\n- snet-betav1-dapp: https://github.com/singnet/snet-betav1-dapp\n- offernet: https://github.com/singnet/offernet\n- ai-dsl: https://github.com/singnet/ai-dsl\n- airdrop-dapp: https://github.com/singnet/airdrop-dapp\n\n가장 많은 커밋을 가진 저장소는 snet-marketplace-service입니다. 이 저장소는 SingularityNET의 시장을 사용하는 방법을 가르쳐 줍니다. 프로젝트의 탈중앙화 애플리케이션(snet-dapp)을 구축하는 데 사용된 저장소가 두 번째로 활동적입니다. 세 번째로 커밋 수가 많은 저장소는 SingularityNET 데몬이고, 그 다음은 플랫폼 및 시장에 대한 많은 문서를 제공하는 dev-portal입니다. 또한 두 개의 에어드랍에 전념한 저장소도 있습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 결론\n\n이 문서는 여러 프로젝트 내 개발자 활동에 대한 포괄적인 견해를 제공합니다. 프로젝트 성장과 개발자 참여의 지표로서 커밋 및 저장소 사용의 중요성을 강조하며, 주요 사건이 개발 활동에 미치는 영향을 보여주고, 연도별 활동을 기반으로 저장소를 순위로 나열합니다.\n\n우리는 좋은 데이터 처리 방법론과 몇 개의 바 차트를 통해 각 프로젝트의 활동에 대해 풍부한 정보를 얻을 수 있었습니다. 요약하자면, Python과 데이터 분석에 대한 충분한 지식을 가지고 있으면 스테이크홀더, 투자자 및 경쟁업체가 GitHub 개발 활동에 기반한 정보에 근거하여 판단을 내릴 수 있습니다.\n\n전체 보고서는 [이 링크](링크)에서 찾아볼 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_0.png"},"coverImage":"/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_0.png","tag":["Tech"],"readingTime":39},{"title":"일찍 알았더라면 좋았을 6가지 Python 문자열 팁","description":"","date":"2024-06-30 21:58","slug":"2024-06-30-6PythonStringThingsIRegretNotKnowingEarlier","content":"\n\n<img src=\"/assets/img/2024-06-30-6PythonStringThingsIRegretNotKnowingEarlier_0.png\" />\n\n개발자로서, 우리는 우연히 문자열을 다루게 됩니다. 여기 개발자로서의 삶을 편리하게 만들어준 멋진 파이썬 문자열 사실 6가지가 있어요.\n\n# 1) 'string' 모듈\n\n모든 알파벳이 필요할 때 실제로 모두 타이핑할 필요가 없습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\r\n알파벳 = 'abcdefghijklmnopqrstuvwxyz'\r\n```\r\n\r\n대신에, 내장된 문자열 모듈을 가져와서 사용할 수 있어요:\r\n\r\n```js\r\nfrom string import ascii_lowercase\r\n\r\nprint(ascii_lowercase)\r\n# abcdefghijklmnopqrstuvwxyz\r\n```\r\n\r\n문자열 모듈에는 대문자와 구두점과 같은 다른 유용한 문자열 상수들이 포함되어 있어요.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n첫 번째 표\n\n```\n| 모듈 | import 구문 |\n| --- | --- |\n| string | (\n| | ascii_uppercase,\n| | ascii_letters,\n| | punctuation\n) |\n\n\nprint(ascii_uppercase)\n# abcdefghijklmnopqrstuvwxyz\n\nprint(ascii_letters)\n# abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\n\nprint(punctuation)\n# !\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~\n\n\n두 번째 표\n\n유니 코드 문자\n\nUnicode를 통해 특수 문자를 출력할 수 있습니다. 중국어, 일본어, 한국어, 이모티콘, 상자 문자 등을 문자열에서 출력할 수 있습니다.\n\n```js\nprint('옴 심볼: \\u03A9')\n\n# 옴 심볼: Ω\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n유니코드 문자를 인쇄하려면:\n\n- 유니코드 코드를 찾아야 합니다. 예: 오메가(옴) 기호의 경우 30A9를 구글/위키 등에서 찾습니다.\n- 유니코드 코드 앞에 \\u를 추가합니다. 예: \\u30A9\n- 문자열에 추가합니다. 예: `오메가 기호: \\u30A9`\n- 인쇄합니다! 그게 다입니다.\n\n참고 — \\u03A9와 같이 유니코드 문자는 한 개의 문자로 처리됩니다.\n\n이 방법을 사용하여 많은 특수 문자를 출력할 수 있습니다!\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nprint('alpha: \\u03B1')\n# alpha: α\n\nprint('beta: \\u03B2')\n# beta: β\n\nprint('inverted ?: \\u00BF')\n# inverted ?: ¿\n\nprint('arrow:', '\\u2192')\n# arrow: →\n\nprint('summation:', '\\u2211')\n# summation: ∑\n```\n\n# 3) f-strings (formatted strings)\n\n처음에 문자열을 더하는 방법을 배웠을 때:\n\n```js\nname = 'tom'\nage = 30\n\nx = 'my name is ' + name + ' and I am ' + str(age)\n\nprint(x) # my name is tome and I am 30\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n일부 문제점:\n\n- 변수를 처리해야 할 때 더 많은 변수가 추가될수록 계속 타이핑하는 것이 점점 귀찮아집니다.\n- 우리는 non-string 변수에 대해 str(var)를 사용해야 합니다. 이는 string에 string만 추가할 수 있기 때문에(이것이 귀찮음) 필요합니다.\n\nF-strings(형식화된 문자열)를 사용하면 우리의 삶이 더 쉬워집니다:\n\n```js\nname = 'tom'\nage = 30\n\nx = f'my name is {name} and I am {age}'\n\nprint(x) # my name is tom and I am 30\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 우리는 문자열을 형식화된 문자열로 만들기 위해 따옴표 앞에 f를 추가합니다.\n- f-문자열 안에 변수를 포함시키기 위해 'var'를 사용합니다.\n\nF-문자열은 강력한 형식 지정 구문을 제공합니다:\n\n```js\n# 변수 이름을 출력하려면 var 뒤에 = 을 추가합니다\n\nname = 'tom'\nage = 30\n\nprint(f'{name=} {age=}') \n# name='tom' age=30\n```\n\n```js\n# 소수점 n 자리까지 반올림을 수행하려면 :.nf를 추가합니다\n\npi = 3.14159265\n\nprint(f'{pi:.2f} {pi:.4f}')\n# 3.14 3.1416\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n# 날짜 및 시간을 쉽게 포맷팅하기\n# 참고: 날짜 및 시간 포맷에 대한 기호들은 Python 문서에서 찾을 수 있습니다\n\nfrom datetime import datetime\ndate = datetime(2024, 3, 7)\n\nprint(f\"{date:%y-%m-%d}\")  # 24-03-07\nprint(f\"{date:%d %B %Y}\")  # 07 March 2024\n```\n\n# 4) 원시 문자열\n\n문자열 내부에 \\n (개행 문자)을 추가하면 새 줄에 출력됩니다:\n\n```js\nx = 'hello\\nworld'\n\nprint(x)\n# hello\n# world\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n특정 이유로 만약 실제로 \"hello\\nworld\"를 출력하고 싶다면, \\ 문자를 또 다른 \\ 문자를 사용하여 이스케이프해야 합니다:\n\n```js\nx = 'hello\\\\nworld'\n\nprint(x)\n# hello\\nworld\n```\n\n우리는 원시 문자열(raw strings)을 사용하여 이를 피할 수 있습니다 - 따옴표 앞에 r을 추가함으로써\n\n```js\nx = r'hello\\nworld'\n\nprint(x)\n# hello\\nworld\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 생 문자열에서 \\ 문자는 실제 문자로 처리됩니다\n- \\n은 2개의 문자로 처리됩니다 — \\와 n\n- 많은 \\ 문자로 이루어진 문자열을 구성해야 할 때 유용합니다\n\n저는 특히 정규 표현식 (regex)에 대해 생 문자열을 유용하게 사용합니다.\n\n```js\n# 'apple'을 포함하는 모든 단어를 찾기 위해 regex 사용\n\nstring = 'apple orange pear pineapple snapple durian'\n\nimport re\n\nregex = r'\\b\\w*apple\\b'\nprint(re.findall(regex, string))\n\n# ['apple', 'pineapple', 'snapple']\n```\n\n정규 표현식에 익숙하지 않은 분들을 위해 추가적인 설명:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- \\b 는 단어들 사이의 경계를 나타내는 문자이며, 단어, 숫자 또는 밑줄과 매칭됩니다.\n- \\w 는 단어 문자로, 숫자, 알파벳, 또는 밑줄과 매칭됩니다.\n\n만약 여기서 정규표현식에 원시 문자열을 사용하지 않았다면, 아마도 다음과 같을 것입니다:\n\n```js\n# 'apple'을 포함하는 모든 단어를 찾기 위해 정규표현식 사용\n\nstring = 'apple orange pear pineapple snapple durian'\n\nimport re\n\nregex = '\\\\b\\\\w*apple\\\\b'\nprint(re.findall(regex, string))\n\n# ['apple', 'pineapple', 'snapple']\n```\n\n^ 여전히 작동하지만, 다른 \\ 문자를 이스케이프하기 위해 \\를 사용해야 한다는 것에 주목해 주세요. 많은 이러한 작업을 다뤄야 한다면 괴롭다는 것을 알 수 있습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 5) 대괄호를 사용하여 문자열 결합\n\n대괄호 안에 연속된 문자열은 자동으로 함께 결합됩니다:\n\n```js\nx = (\n    'apple '\n    'orange '\n    'pear'\n)\n\nprint(x)\n# apple orange pear\n```\n\n^ 이것은 여러 줄로 나뉘어진 매우 긴 문자열을 처리해야 할 때 유용하며 + 연산자를 사용하고 싶지 않을 때 유용합니다\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n# + 연산자 사용하기\nx = 'apple ' + \\\n    'orange ' + \\\n    'pear'\n\nprint(x)\n# apple orange pear\n```\n\n^ + 연산자를 여러 줄에 걸쳐 사용할 때는 \\을 사용하여 한 줄이 여러 줄에 걸친다고 Python에 알려주어야 합니다. 이것은 간단한 괄호를 사용하는 것만큼 우아하지 않다고 제 생각에는 느껴집니다.\n\n# 6) ANSI 이스케이프 시퀀스\n\nANSI 이스케이프 시퀀스는 특수한 문자로, 문자열에서 멋진 작업을 할 수 있게 해줍니다. 예를 들어:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 텍스트를 색으로 출력하기\n- 텍스트 강조 표시하기\n- 커서를 위로 이동하기\n\n예를 들어, 몇 가지 텍스트를 색상으로 출력해봅시다\n\n```js\nprint('\\x1b[31mhello')\nprint('\\x1b[32mhello')\nprint('\\x1b[34mhello')\n```\n\n<img src=\"/assets/img/2024-06-30-6PythonStringThingsIRegretNotKnowingEarlier_1.png\" />\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- \\x1b[31m은 빨강의 ANSI 시퀀스입니다.\n- \\x1b[32m은 초록의 ANSI 시퀀스입니다.\n- \\x1b[34m은 파랑의 ANSI 시퀀스입니다.\n\n이미 출력된 내용을 지우는 멋진 작업도 할 수 있어요:\n\n```js\nCURSOR_UP = \"\\033[1A\"\nCLEAR = \"\\x1b[2K\"\nCLEAR_LINE = CURSOR_UP + CLEAR\n\nprint('apple')\nprint('orange')\nprint('pear')\nprint('pineapple')\n\nprint(CLEAR_LINE * 2, end='')\n\nprint('durian')\nprint('grapes')\nprint('dragonfruit')\n\n# apple\n# orange\n# durian\n# grapes\n# dragonfruit\n```\n\n- \\033[1A는 커서를 한 줄 위로 이동시킵니다.\n- \\x1b[2K는 커서가 있는 줄을 삭제합니다.\n- 두 개를 함께 출력하면 터미널에서 한 줄을 삭제합니다.\n- print(CLEAR_LINE * 2, end='')는 이미 출력된 2 줄(pear와 pineapple)을 삭제합니다.\n- 그래서 durian이 바로 orange 다음에 나타나는 이유입니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n참고 - 이슈 문자열을 매번 찾아보지 않아도 되도록 Python 패키지를 만들었습니다. pip install unprint을 사용해서 다운로드해보세요.\n\n```js\nfrom unprint import unprint\n\nprint('apple')\nprint('orange')\nprint('pear')\nprint('pineapple')\n\nunprint(2)\n\nprint('durian')\nprint('grapes')\nprint('dragonfruit')\n\n# apple\n# orange\n# durian\n# grapes\n# dragonfruit\n```\n\n# 부가적인 Python 농담\n\n# 결론\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n알기 쉽고 명확했기를 바랍니다\n\n# 만약 개발자로서 저를 지원하고 싶다면\n\n- 내 서적을 구매해 주세요! — 파이썬에 대해 알지 못했던 101가지\r\n- 찾을 수 있는 곳: https://payhip.com/b/vywcf\r\n- 이 이야기에 대해 50번 박수를 치세요\r\n- 당신의 생각을 남겨줘요\r\n- 이야기에서 가장 좋아하는 부분을 강조해 주세요\n\n감사합니다! 이 작은 행동들이 큰 도움이 되고, 정말 감사합니다!\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nYouTube: [https://www.youtube.com/@zlliu246](https://www.youtube.com/@zlliu246)\n\nLinkedIn: [https://www.linkedin.com/in/zlliu/](https://www.linkedin.com/in/zlliu/)","ogImage":{"url":"/assets/img/2024-06-30-6PythonStringThingsIRegretNotKnowingEarlier_0.png"},"coverImage":"/assets/img/2024-06-30-6PythonStringThingsIRegretNotKnowingEarlier_0.png","tag":["Tech"],"readingTime":11},{"title":"내가 가장 좋아하는 자바스크립트 코드 한 줄","description":"","date":"2024-06-30 21:57","slug":"2024-06-30-MySingleFavoriteLineOfJavascript","content":"\n\n![MySingleFavoriteLineOfJavascript_0](/assets/img/2024-06-30-MySingleFavoriteLineOfJavascript_0.png)\n\n몇 년 전, Quora에서 누군가가 \"지금까지 쓰여진 가장 강력한 코드 라인은 무엇인가?\"라고 물었습니다.\n\n대답들은 정말 재미있었고, 대부분은 예상한 것들이었습니다 (개발자라면요). 어떤 사람들은 while과 for 루프를 칭찬했는데, 컴퓨터가 반복 작업을 수행하도록 하는 중요한 구성 요소이며 \"우리 생활 중 가장 지루한 부분을 처리해 주기 때문에 감사한 역할\"이라고 말했습니다. 다른 개발자들은 컴퓨터가 말을 하게 만드는 print 문의 힘(컴퓨터 발화라고도 함), if-else 문(자동화된 의사 결정!), 또는 다른 사람의 오픈 소스 코드를 자동으로 흡수하고 나의 앱에서 사용할 수 있게 하는 import 명령에 대해 이야기했습니다.\n\n확실히 멋진 선택들입니다. 그러나 저에게는 기쁨을 주는 한 줄의 명령어가 있습니다:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n의사 난수 생성기! 대부분의 프로그래밍 언어에는 그런 것이 있습니다. 자주 사용하는 Javascript 나 Node에서 작성 중이라면, 이 함수는 ...\n\n나는 이것을 존경스럽게 생각하며, 우연하게도 유용한 존재 중에서 가장 이상하고 마법 같은 코드라고 후보로 지명합니다.\n\n![MySingleFavoriteLineOfJavascript_1](/assets/img/2024-06-30-MySingleFavoriteLineOfJavascript_1.png)\n\nMath.random()은 마법 같은데, 왜냐하면 우리가 똑같이 형편없이 하는 게 내재하는 랜덤 숫자를 생성하기 때문이죠.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n누구나 정확히 이것을 왜 이렇게 못하는지는 알지 못합니다. 아마도 너무 많이 과도하게 생각하기 때문이죠. 예를 들어, 사람들에게 1에서 20까지의 임의의 숫자를 고르라고 부탁하면, 그들은 대부분 17을 선택할 것입니다. 그 이유는 뭘까요? 아마도 홀수이자 소수이기 때문에 무작위로 느껴지기 때문이겠지만, 우리가 그 결론에 이르기까지 논리적/직관적으로 사고하기 때문에, 그 외에 어떠한 것도 아닙니다.\n\n이것이 바로 왜 우리가 운명의 게임이 흔히 주사위와 같은 의사난수 생성 도구에 의존했는지, 컴퓨터가 현대의 주사위 던지기인 이유입니다. 한 줄의 코드로 필요한 만큼의 의사난수를 얻을 수 있죠.\n\n그리고 'random' 명령어는 제게 매우 유용한 것으로 나타났습니다.\n\n저는 특히 이 트위터 봇이 하루에 세 번 시를 생성하거나, \"Weird Old Book Finder\" 같은 이상한 오래된 책을 찾는 프로젝트와 같이 독특한 문화 프로젝트를 만드는 취미 코더입니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n문화 앱을 만들 때, 무작위성은 창의적인 힘이 될 수 있어요. \n\n예를 들어, 제 트위터봇을 위해 하이쿠 모양의 시를 900줄 이상 직접 썼어요. 매일 세 번, 봇이 무작위로 세 줄을 골라서 합쳐요.\n\n봇을 만드는 어려운 점은 그 모든 줄을 쓰는 것이었어요. 각 줄을 만들 때는 그것이 독립적으로 성립할 수 있을 뿐만 아니라 다른 줄과 쉽게 결합될 수 있도록 공들여야 했거든. 그것이 대부분의 작업이었습니다. \n\n![내가 가장 좋아하는 자바스크립트 한 줄](/assets/img/2024-06-30-MySingleFavoriteLineOfJavascript_2.png)\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n하지만 소프트웨어 측면에서는 얼마나 재미있고 복잡하지 않은 일인가요? 코드가 네 줄 밖에 안 되었어요. 단 한 줄의 Math.random() 명령어가 모든 일을 처리해 주는 거죠.\n\n그런데 정말 대단한 건, 잘 작동한다는 거예요! 이 봇은 거의 다섯 년 동안 계속 트윗을 올리고 있고, Math.random()이 만들어내는 조합에 여전히 놀랍습니다. 제가 직접 모든 줄을 작성했음에도 왠지 모르게 이 조합들은 제 스스로 생각하지 못했을 거예요.\n\n시와 예술에서 무작위성을 사용하는 것은 당연히 제 창작물이 아니에요. 이전 디지털 시대로 거슬러 올라가면 (예를 들면 OULIPO 시에서 명사를 대체하는 \"N+7\" 기법처럼), 계휴한 우렁찬 전통이 있었고, 컴퓨터 시대에 들어서면서 더욱 놀라운 발전을 이루었어요. 많은 비디오 게임에서 봐도, 종종 간단한 무작위성을 이용해서 게임을 끝없이 즐길 수 있게 만들어요. 수많은 창작자들이 계산되는 무작위성을 즐거워해요.\n\nMatthew Siu의 말을 빌리자면...\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n하지만 Math.random()을 유용하게 활용하는 또 다른, 아마도 미묘한 방법이 있습니다: 결정을 내릴 때 사용하기.\n\n구체적으로, '선택의 역설'을 극복하는 데 사용합니다.\n\n이 이론은 우리가 매우 다양한 옵션을 제공 받을 때 결정하기가 더 어려워지며, 최종적으로 내린 결정에 덜 만족하게 됩니다. 이것은 흔치 않은 이론이며 최근 몇 년 동안 논쟁이 있었습니다. 그러나 제 개인적인 경험에는 맞다는 것 같습니다. 책방에 들어가면 \"최근 출간된\" 제목들의 거대한 배열을 보게 되면, 제 주의가 흐려지고 멀어지는 것을 느낍니다. 저는 책방 직원이 고른 10권의 작은 표를 선택하는 것이 훨씬 쉽다고 생각합니다.\n\n그래서 \"Weird Old Book Finder\"를 만들 때, 선택의 역설을 우회하는 방법으로 무작위성을 사용했습니다. 사용자의 검색 질의를 받아 구글 도서 API에 전달하고, 결과가 반환되면 1920년대 중반 이전에 출판된 제목을 필터링하여 공공 도메인에 속하고 즉시 전문을 읽을 수 있는 책들을 찾습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n문제는 Google Books API가 최대 40개의 제목을 보내다는 것입니다. 너무 많아요. 선택 목록을 제공하고 싶지 않았어요 — 선택 광선을 유발할 수도 있으니까요!\n\n그래서 그냥 사용자에게 돌려보낼 책을 랜덤하게 하나 선택해요.\n\n또 다시, 이건 정말 간단한 기술이에요. 한 줄의 코드 뿐이에요. 하지만 이로 인해 검색 엔진이 재미있는 퀄리티를 얻게 해줘요. 동일한 검색어를 여러 번 실행해도 서로 다른 책을 얻어요. 이는 문화의 슬롯 머신이 되는거에요.\n\n![MySingleFavoriteLineOfJavascript_3.png](/assets/img/2024-06-30-MySingleFavoriteLineOfJavascript_3.png)\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nMath.random()은 일반적으로 사람들이 되지 못하는 방식으로도 재미있는 요소를 제공합니다.\n\n책 판매자나 사서에게 특정 주제의 책을 요청한다면 \"음, 해당 주제의 섹션으로 가서 아무거나 가져와\"라고 말하지 않을 텐데요. 이를 하기엔 너무 어색할 것입니다. 사람들은 의미 있는 행동과 의미창출을 선호합니다. 그들은 당신이 선택을 할 수 있도록 안내하는 것이 더 편할 것입니다.\n\n하지만 Math.random()은 이런 어색함이 없죠. 그냥 아무거나 줄 수 있습니다.\n\n그래서 제가 가장 강력한 코드 줄에 투표한 것입니다:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nMath.random().\n\n클라이브 톰슨은 주간 세 번의 게시물을 미디엄에 게시하며, 여러분께 이메일로 각 게시물을 받아보실 수 있습니다 - 그리고 미디엄 회원이 아닌 경우, 여기에서 가입할 수 있습니다.\n\n클라이브는 뉴욕 타임스 매거진의 기고자이자, 와이어드와 스미스소니언 매거진의 칼럼니스트로 활동하며, Mother Jones에 정기 기고자로 활동하고 있습니다. 그는 Coders: The Making of a New Tribe and the Remaking of the World과 Smarter Than You Think: How Technology is Changing our Minds for the Better의 저자이기도 합니다. 트위터와 인스타그램에서는 @pomeranian99를 팔로우할 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-30-MySingleFavoriteLineOfJavascript_0.png"},"coverImage":"/assets/img/2024-06-30-MySingleFavoriteLineOfJavascript_0.png","tag":["Tech"],"readingTime":6},{"title":"세 개의 타워 뭐가 다른가","description":"","date":"2024-06-30 21:55","slug":"2024-06-30-TheThreeTowers","content":"\n\n![이미지](/assets/img/2024-06-30-TheThreeTowers_0.png)\n\n하노이 탑은 프로그래밍에서 고전이자 도전적인 문제입니다. 이 문제의 해결책을 찾는 것은 어렵지 않지만, 해결책 뒤에 숨겨진 직관을 이해하는 데는 약간의 시간이 걸립니다. 이 문제를 살펴보고 이 문제의 직관을 이해하고 어떻게 코드로 작성할지 알아봅시다.\n\n# 기원\n\n하노이 탑 문제는 1883년 프랑스 수학자 에두아르 루카가 발명했습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n루카스는 이 문제를 더 넓은 대중에게 호소하기 위해 함께 이야기도 추가했습니다. 전설에 따르면 수세기동안 하인두 사원에서 사제들이 세 기둥 사이에서 금판을 옮겨다 놓았다고 합니다. 그들은 하노이의 탑 규칙을 따라야 합니다. 하루에 한 디스크씩만 움직일 수 있습니다. 이 퍼즐을 완성하면 세상이 끝날 것이라고 전해집니다.\n\n# 문제 설명\n\n세 개의 타워(기둥)가 있습니다. 하나의 타워에는 크기가 증가하는 n개의 디스크가 있고, 다른 두 타워는 비어 있습니다. 모든 디스크를 한 타워에서 다른 타워로 옮겨야 합니다.\n\n두 가지 규칙이 있습니다. 더 큰 디스크를 작은 디스크 위에 놓을 수 없으며 한 번에 한 개의 디스크만 이동시킬 수 있습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 직관\n\n엣지 케이스를 살펴보죠. 즉, 우리가 디스크가 하나뿐인 경우의 처리 방법은 무엇일까요?\n\n이 경우의 답은 꽤 간단합니다. 필요한 기둥으로 그냥 이동하면 됩니다.\n\n<img src=\"/assets/img/2024-06-30-TheThreeTowers_1.png\" />\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 2개의 디스크를 이동해 봅시다.\n\n작은 디스크를 큰 디스크 위에 놓을 수 없기 때문에 먼저 작은 디스크를 중간으로 옮겨야 합니다.\n\n![이미지](/assets/img/2024-06-30-TheThreeTowers_2.png)\n\n그런 다음 큰 디스크를 끝으로 옮기게 될 거에요.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![이미지](/assets/img/2024-06-30-TheThreeTowers_3.png)\n\n작은 디스크를 마지막 위치로 이동시키면 됩니다.\n\n![이미지](/assets/img/2024-06-30-TheThreeTowers_4.png)\n\n문제가 해결되었습니다.\n\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 우리가 가장 중요한 테스트 케이스, 즉 3개의 디스크에 대한 것을 시도해 봅시다. 이것을 주의 깊게 이해하려고 노력해주세요.\n\n![이미지](/assets/img/2024-06-30-TheThreeTowers_5.png)\n\n하나의 해결책은 백트래킹을 시도하여 가능성을 찾는 것입니다(수도 퍼즐과 같이). 그러나 더 나은 접근 방식은 문제를 분해하는 것입니다.\n\n가장 큰 디스크를 무시해 봅시다. 우리는 한 막대에서 다른 막대로 두 개의 디스크를 옮기는 방법을 알고 있습니다. 그러나 만약 그들을 직접 최종 막대로 옮긴다면(2개 디스크 문제에서처럼) 가장 큰 디스크를 어떻게 옮길 것인가요?\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![image1](/assets/img/2024-06-30-TheThreeTowers_6.png)\n\n이 방법은 문제가 발생할 수 있으므로 상단의 두 디스크를 중간 막대로 이동해 보겠습니다. 그렇게 하면 가장 큰 디스크를 마지막 막대로 바로 이동할 수 있습니다.\n\n![image2](/assets/img/2024-06-30-TheThreeTowers_7.png)\n\n이제 동일한 방법을 따라서 (2개의 디스크를 이동할 때 사용한 것과 같은 방법으로) 두 개의 작은 디스크를 더 큰 디스크 위로 이동할 수 있습니다.\n\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![이미지](/assets/img/2024-06-30-TheThreeTowers_8.png)\n\n패턴을 보셨나요?\n\nn개의 디스크를 시도해보세요.\n\n![이미지](/assets/img/2024-06-30-TheThreeTowers_9.png)\n\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n3개의 디스크가 있는 문제와 비교해보세요. 먼저, 작은 디스크를 가운데로 옮깁니다.\n\n![image](/assets/img/2024-06-30-TheThreeTowers_10.png)\n\n그런 다음 가장 큰 디스크를 최종 막대로 옮길 수 있습니다.\n\n![image](/assets/img/2024-06-30-TheThreeTowers_11.png)\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 첫 번째 단계를 반복하고 n-1 개의 디스크를 더 큰 디스크 위로 이동해야 합니다.\n\n![image](/assets/img/2024-06-30-TheThreeTowers_12.png)\n\n따라서 우리의 문제는 해결되었습니다!\n\n# 재귀 논리\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 주요 부분으로 넘어갑시다. 재귀 논리를 이해하는 방법은 무엇인가요?\n\n- 먼저 n-1개의 디스크를 보조 막대로 이동\n- n번째 디스크를 최종 막대로 이동\n- n-1개의 디스크를 최종 막대로 이동\n- 만약 n = 1이면, 바로 최종 막대로 이동시킵니다\n\n# 소스 코드\n\n이제 솔루션을 코딩해봅시다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nvar towerOfHanoi = function(n, start, auxiliary, end){}\n```\n\n먼저 우리는 에지 케이스를 작성할 것입니다.\n\n```js\nvar towerOfHanoi = function(n, start, auxiliary, end) {\n  if (n == 1) {\n    console.log(`디스크 1을 ${start}에서 ${end}로 옮깁니다`);\n    return 0;\n  }\n}\n```\n\n우리는 코드가 n-1에 대해 작동할 것으로 가정하고, n-1을 보조로 옮깁니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nvar towerOfHanoi = function(n, start, auxiliary, end) {\n  if (n == 1) {\n    console.log(`디스크 1을 ${start}에서 ${end}로 이동합니다`);\n    return 0;\n  }\n  towerOfHanoi(n - 1, start, end, auxiliary);\n}\n```\n\n그리고 가장 큰 디스크를 끝으로 이동합니다.\n\n```js\nvar towerOfHanoi = function(n, start, auxiliary, end) {\n  if (n == 1) {\n    console.log(`디스크 1을 ${start}에서 ${end}로 이동합니다`);\n    return 0;\n  }\n  towerOfHanoi(n - 1, start, end, auxiliary);\n  console.log(`디스크 ${n}을 ${start}에서 ${end}로 이동합니다`);\n}\n```\n\n마지막으로, 보조 기둥에 있는 n-1을 끝으로 옮깁니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nvar towerOfHanoi = function(n, start, auxiliary, end) {\n  if (n == 1) {\n    console.log(`move the disk 1 from ${start} to ${end}`);\n    return 0;\n  }\n  towerOfHanoi(n - 1, start, end, auxiliary);\n  console.log(`move the disk ${n} from ${start} to ${end}`);\n  towerOfHanoi(n - 1, auxiliary, start, end);\n}\n```\n\n이제 우리의 코드가 완성되었습니다!!!\n\n# 시간 복잡도\n\n이 알고리즘의 시간 복잡도를 찾아봅시다\n\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n가정해볼게요. n개의 디스크가 있다고 가정해봅시다. 시간은 T(n)이라고 부르겠습니다.\n\n따라서, T(n) = 2(T(n-1)) +1\n\n= T(n) = 2(2(T(n-2)) + 1) +1\n\n= T(n)= 2²T(n-2) + 2 + 1\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n=T(n)= 2³T(n-3) + 2² + 2 + 1\n\n= T(n) = (2^k) *T(n-k) +(2^k) +2^(k-1) + …. + 2² + 1\n\n( T(1) = 1 and T(0) = 0)\n\n= T(n) = 2⁰ + 2¹ + 2² + …. + 2^(n-1)\n\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이것은 등비 수열이기 때문에 합계를 구할 수 있습니다.\n\n` T(n) = (2^n) -1 `\n\n따라서, 시간복잡도는 O((2^n)-1) 입니다.\n\n# 공간 복잡도\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n재귀를 사용할 때 함수가 다른 함수를 호출하면 외부 함수가 재귀 호출 스택에 저장됩니다.\n\n함수는 1에 도달할 때까지 계속 호출되므로,\n\nSC = O(N)\n\n이 글이 마음에 들었기를 바랍니다. 불일치나 의문 사항이 있으면 언제든지 연락 주세요. 즐거운 학습되세요!!!","ogImage":{"url":"/assets/img/2024-06-30-TheThreeTowers_0.png"},"coverImage":"/assets/img/2024-06-30-TheThreeTowers_0.png","tag":["Tech"],"readingTime":9},{"title":"Nodejs와 Express 앱에서 역할 기반 접근 제어RBAC 구현하는 방법","description":"","date":"2024-06-30 21:53","slug":"2024-06-30-ImplementingRoleBasedAccessControlRBACinNodejsandExpressApp","content":"\n\n이 기사에서는 단 몇 분 안에 Node.js 및 Express 애플리케이션에 Role Based Access Control (RBAC)을 구현하는 방법을 알려드립니다.\n\n![이미지](/assets/img/2024-06-30-ImplementingRoleBasedAccessControlRBACinNodejsandExpressApp_0.png)\n\n응용 프로그램 내에서 특정 기능 및 데이터에 액세스할 수 있는 권한이 있는 사용자만이 액세스할 수 있도록 보장하기 위해 Role-Based Access Control (RBAC)을 구현하는 것이 중요합니다.\n\n이 기사에서는 Permify를 사용하여 Node.js 및 Express 애플리케이션에 RBAC을 구현하는 방법을 안내해드릴 것입니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# Node.js Express 프로젝트 설정하기\n\nExpress.js 프로젝트를 위한 애플리케이션 뼈대를 빠르게 생성하려면 express-generator 도구를 사용할 수 있습니다. 시작하기 위해 다음 단계를 따르세요:\n\n## 단계 1. express-generator 설치하기:\n\nNode.js 버전 8.2.0 이상을 사용 중이라면 npx 명령어를 사용하여 애플리케이션 생성기를 실행할 수 있습니다:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nnpx express-generator\n```\n\n이전 Node 버전의 경우, 애플리케이션 생성기를 글로벌 npm 패키지로 설치할 수 있어요:\n\n```js\nnpm install -g express-generator\n```\n\n# 단계 2. Express 애플리케이션 생성하기:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nexpress-generator을 설치하셨으면 Express 애플리케이션을 생성할 수 있어요. 다음 명령어를 사용하여 옵션을 확인할 수 있어요:\n\n```js\nexpress -h\n```\n\n이렇게 하면 Express 애플리케이션 생성을 위한 가능한 옵션을 확인할 수 있어요.\n\n예를 들어, Pug 뷰 엔진을 사용하여 permify-rbac-app이라는 Express 앱을 생성하려면 다음과 같이 실행할 수 있어요.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nexpress --view=pug permify-rbac-app\n```\n\n이 명령어는 현재 작업 디렉토리에 permify-rbac-app이라는 폴더를 생성하고 Express 애플리케이션에 필요한 파일과 폴더를 함께 만듭니다.\n\n# 단계 3. 종속성 설치:\n\n새로 만든 Express 애플리케이션 디렉토리로 이동하세요:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\ncd permify-rbac-app\n```\n\n그런 다음 npm을 사용하여 프로젝트 종속성을 설치하세요:\n\n```js\nnpm install express && npm install @permify-node\n```\n\n# 단계 4. Express 애플리케이션 시작하기:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nMacOS 또는 Linux에서는 다음 명령어로 앱을 시작할 수 있어요:\n\n```js\nDEBUG=permify-rbac-app:* npm start\n```\n\n# 단계 5. 애플리케이션에 액세스하기:\n\nExpress 애플리케이션이 실행되면 브라우저에서 http://localhost:3000/을 통해 액세스할 수 있어요.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 디렉토리 구조:\n\n생성된 Express 애플리케이션은 다음과 같은 디렉토리 구조를 가지게 됩니다:\n\n```js\npermify-rbac-app/\n├── app.js\n├── bin/\n│   └── www\n├── package.json\n├── public/\n│   ├── images/\n│   ├── javascripts/\n│   └── stylesheets/\n│       └── style.css\n├── routes/\n│   ├── index.js\n│   └── users.js\n└── views/\n    ├── error.pug\n    ├── index.pug\n    └── layout.pug\n```\n\n이 구조에는 주요 애플리케이션 파일(app.js), 서버 구성(bin/www), 라우트(routes), 뷰(views), 공용 에셋(public assets), 그리고 프로젝트 종속성이 포함된 package.json 파일이 포함되어 있습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nExpress.js 프로젝트를 설정했으니, 이제 Express 애플리케이션에 RBAC를 구현해 보겠습니다.\n\n# Node.js 및 Express에서 RBAC 구현하기\n\nNode.js 및 Express 애플리케이션에 Role-Based Access Control (RBAC)을 구현하는 것에는 몇 가지 단계가 연루됩니다. 다음은 기본적인 구현 방법입니다:\n\n# 단계 1: Permify를 사용하여 RBAC 모델 설계하기\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nPermify는 개방 소스 권한 부여 서비스로, 개발자들이 권한 시스템을 만들 수 있게 합니다. Permify를 이용하면 권한을 모델링하고, 환경에 중앙 권한 서비스를 만들어 애플리케이션 및 서비스에서 액세스 확인을 수행할 수 있습니다.\n\n이를 위해 클라이언트 SDKs를 제공하여, 미들웨어에 추가하여 접근 확인과 같은 권한 요청을 보낼 수 있습니다.\n\nPermify는 역할, 권한 및 관계를 정의하기 위한 강력한 도메인 특화 언어(DSL)를 제공합니다. Permify Playground를 활용하여 RBAC 모델을 실험하고 시각화할 수 있습니다.\n\n![이미지](/assets/img/2024-06-30-ImplementingRoleBasedAccessControlRBACinNodejsandExpressApp_1.png)\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 게시물에서는 귀하의 조직 내 사용자가 역할에 따라 문서에 액세스할 수 있는 간단한 파일 기반 권한 부여 시스템을 개발할 것입니다.\n\n행정자, 관리자 및 직원과 같은 다양한 역할은 파일을 보기, 편집 또는 삭제하는 데 서로 다른 수준의 액세스 권한을 가질 수 있습니다.\n\n## Permify DSL을 사용한 역할 및 권한 정의\n\n다음은 RBAC 모델을 위한 Permify DSL 스키마 예시입니다:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nentity user {} \n\nentity organization {\n    // roles \n    relation admin @user    \n    relation member @user    \n    relation manager @user    \n    relation agent @user  \n    \n    // organization files access permissions\n    permission view_files = admin or manager or (member not agent)\n    permission delete_file = admin \n    \n    // vendor files access permissions\n    permission view_vendor_files = admin or manager or agent\n    permission delete_vendor_file = agent\n}\n```\n\nRoles and Permissions:\n\n- Roles: The schema defines roles for the organization entity, including admin, member, manager, and agent. These roles determine the level of access and permissions users have within the organization.\n- Permissions: Actions such as `view_files`, `edit_files`, `delete_file`, `view_vendor_files`, `edit_vendor_files`, and `delete_vendor_file` define the specific permissions associated with each role. For example, only admins can delete organization files, while managers and members have different levels of access.\n\nResource Types:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 스키마는 조직 파일과 공급 업체 파일을 구별하여 각각의 권한 집합을 가지고 있습니다. 이는 응용 프로그램 내의 다른 유형의 리소스에 대한 접근을 세밀하게 제어할 수 있도록 합니다.\n\n이제 RBAC 스키마를 정의했으니 Permify Local Server를 설정하는 단계로 넘어갈 것입니다.\n\n# 단계 2: Docker를 사용하여 Permify Local Server 설정하기\n\nDocker는 컨테이너화된 환경을 제공함으로써 우리의 설정에서 중요한 역할을 합니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 환경은 모든 권한 쿼리를 처리하는 마이크로서비스인 Permify의 효율적인 작동을 위한 필수 요소입니다.\n\n이제 Docker Container를 사용하여 Permify Server를 설정하는 필요한 단계를 설명하겠습니다:\n\n## Docker Container를 사용하여 Permify Server 실행\n\n- 터미널 창을 열고 다음 명령을 실행하여 Permify Server Docker 이미지를 가져오고 컨테이너를 시작합니다:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\nsudo docker run -p 3476:3476 -p 3478:3478 ghcr.io/permify/permify serve\n\n\n이 명령어는 GitHub Container Registry에서 Permify Server 이미지를 다운로드하고 다음의 기본 설정으로 Permify, 저희의 권한 부여 서비스를 설정합니다:\n\n- REST API는 3476 포트에서 실행됩니다.\n- gRPC 서비스는 3478 포트에서 실행됩니다.\n- 권한 데이터는 컴퓨터 메모리에 저장됩니다.\n\n다음과 유사한 메시지가 표시됩니다:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n┌────────────────────────────────────────────────────────┐\r\n│                    Permify v0.9.5                      │\r\n│          Fine-grained Authorization Service            │\r\n│                                                        │\r\n│    docs: ............... https://docs.permify.co       │\r\n│    github: .. https://github.com/Permify/permify       │\r\n│    blog: ............... https://permify.co/blog       │\r\n│                                                        │\r\n└────────────────────────────────────────────────────────┘\r\ntime=2024-03-22T14:59:09.851Z level=INFO msg=\"🚀 starting permify service...\"\r\ntime=2024-03-22T14:59:09.851Z level=ERROR msg=\"Account ID is not set. Please fill in the Account ID for better support. Get your Account ID from https://permify.co/account\"\r\ntime=2024-03-22T14:59:09.859Z level=INFO msg=\"🚀 grpc server successfully started: 3478\"\r\ntime=2024-03-22T14:59:09.859Z level=INFO msg=\"🚀 invoker grpc server successfully started: 5000\"\r\ntime=2024-03-22T14:59:09.867Z level=INFO msg=\"🚀 http server successfully started: 3476\"\r\n\n\r\n## Permify 서버 확인\r\n\r\n컨테이너가 실행 중이면 health check endpoint에 액세스하여 Permify 서버가 정상적으로 작동하는지 확인할 수 있습니다. Postman을 열고 http://localhost:3476/healthz로 GET 요청을 보내세요. Permify 서버가 올바르게 실행 중이면 서비스가 건강한 것을 나타내는 응답을 볼 수 있어요.\r\n\r\n<img src=\"/assets/img/2024-06-30-ImplementingRoleBasedAccessControlRBACinNodejsandExpressApp_2.png\" />\r\n\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 이미지를 보면 Permify 서버가 작동 중이라는 것을 확인할 수 있습니다. 이제 Node.js 및 Express 애플리케이션에 통합하는 작업을 진행할 수 있습니다.\n\n# 단계 3: Permify Node.js 클라이언트 초기화\n\n이 튜토리얼에서는 Permify Node 클라이언트를 사용하여 응용 프로그램의 권한 부여를 제어합니다. Permify Swagger 문서에서 사용 가능한 엔드포인트 목록을 찾을 수 있습니다. 우리는 Permify의 접근 제어 체크를 사용하여 엔드포인트를 안전하게 보호할 것입니다.\n\n이제 클라이언트를 초기화해 봅시다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```javascript\n// create-tenant.js\nconst permify = require(\"@permify/permify-node\");\n\nconst client = new permify.grpc.newClient({\n    endpoint: \"localhost:3478\",\n})\n```\n\n# 단계 4: 권한 모델 구성\n\n이제 Permify 서버가 실행 중이므로 권한 모델을 구성해야 합니다. 이후에 테스트 액세스 확인을 수행할 준비가 될 것입니다.\n\n권한 모델을 구성하려면 생성한 스키마를 Permify에게 Permify schema.write 메서드를 사용하여 전송합니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n//create-schema.js\n\nconst permify = require(\"@permify/permify-node\");\n\nconst client = new permify.grpc.newClient({\n    endpoint: \"localhost:3478\",\n})\n\nclient.schema.write({\n    tenantId: \"t1\",\n    schema: \"entity user {} \\n\\nentity organization {\\n\\n    relation admin @user    \\n    relation member @user    \\n    relation manager @user    \\n    relation agent @user  \\n\\n    action view_files = admin or manager or (member not agent)\\n    action edit_files = admin or manager\\n    action delete_file = admin\\n    action view_vendor_files = admin or manager or agent\\n    action edit_vendor_files = admin or agent\\n    action delete_vendor_file = agent\\n\\n} \"\n}).then((response) => {\n    // handle response\n    console.log(response)\n})\n```\n\n위 코드는 Permify 라이브러리를 사용하여 새로운 스키마를 생성합니다.\n\n이 코드는 localhost의 3478 포트에서 실행 중인 Permify 서버에 연결하도록 구축되었으며, write 메서드를 호출하여 t1 테넌트를 위한 스키마를 정의합니다.\n\n이 스키마는 사용자 및 조직과 관련관계 및 작업과 같은 엔티티를 정의합니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 이 스크립트를 실행해 볼게요\n\n```js\nnode create-schema.js\n```\n\n![스크린샷 이미지](/assets/img/2024-06-30-ImplementingRoleBasedAccessControlRBACinNodejsandExpressApp_3.png)\n\n위 스크린샷에서 새로운 스키마가 Permify Node Js Client를 사용하여 성공적으로 구성되었음을 확인할 수 있어요.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만세! 🥳 Permify 권한 부여 서비스 설정을 성공적으로 마쳤어요. 이제 권한 모델이 설정되었고 사용할 준비가 끝났답니다!\n\n다음 단계에서는 액세스 제어를 위한 미들웨어를 만들 것입니다.\n\n# 단계 5: 액세스 제어 미들웨어 생성\n\n여기서는 Express 미들웨어를 개발해서 경로에 기반한 역할 기반 액세스 제어를 강제하는 방법을 한 예제로 보여줄게요.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nPermify 액세스 확인 엔드포인트를 미들웨어에 구현하여 보호된 리소스에 액세스하기 전에 사용자의 역할과 권한을 확인하는 방법도 배울 것입니다.\n\n```js\n// auth.js\n\n// Permify 클라이언트 가져오기\nconst permify = require('@permify/permify-node');\n\nconst client = new permify.grpc.newClient({\n  endpoint: \"localhost:3478\",\n});\n\n// 사용자의 권한을 확인하는 미들웨어 함수\nconst checkPermissions = (permissionType) => {\n  return async (req, res, next) => {\n    try {\n      // req.params.id가 존재하는지 확인\n      if (!req.params.id) {\n        throw new Error('요청 매개변수에서 사용자 ID가 누락되었습니다');\n      }\n\n      // 필요에 따라 permissionType을 문자열로 변환\n      const permTypeString = String(permissionType);\n\n      // Permify 확인 요청을 위한 데이터 준비\n      const checkRes = await client.permission.check({\n        tenantId: 't1',\n        metadata: {\n          schemaVersion: '',\n          snapToken: '',\n          depth: 20,\n        },\n        entity: {\n          type: 'organization',\n          id: \"1\",\n        },\n        permission: permTypeString, // 변환된 permissionType 사용\n        subject: {\n          type: 'user',\n          id: req.params.id,\n        },\n      });\n\n      if (checkRes.can === 1) {\n        // 사용자가 권한이 있는 경우\n        req.authorized = 'authorized';\n        next();\n      } else {\n        // 사용자가 권한이 없는 경우\n        req.authorized = 'not authorized';\n        next();\n      }\n    } catch (err) {\n      console.error('권한 확인 중 오류 발생:', err.message); // 실제 오류 메시지 기록\n      res.status(500).send(err.message); // 디버깅을 위해 실제 오류 메시지를 클라이언트로 보냄\n    }\n  };\n};\n\nmodule.exports = checkPermissions;\n```\n\n위 코드는 사용자 권한을 확인하기 위해 Permify 라이브러리를 활용한 checkPermission 미들웨어 함수를 구현하는 것을 목표로 구성되었습니다.\n\n실행시 요청 매개변수에서 사용자 ID를 추출하고, 필요에 따라 권한 유형을 문자열로 변환한 후, Permify의 \"permission.check\" 메서드를 사용하여 Permify 서버에 권한 확인 요청을 보냅니다. 권한이 부여된 경우 요청 객체에 \"authorized\"를 추가하며, 그렇지 않은 경우 \"not authorized\"를 추가합니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n오류는 디버깅을 위해 더 자세히 기록되고 클라이언트에 반환됩니다.\n\n다음으로, 이전에 만든 미들웨어를 Node.js 및 Express 애플리케이션에 통합하여 역할 기반 접근 제어 (RBAC)를 강제하고 적절한 역할 및 권한이 있는 인증된 사용자만 특정 경로에 액세스할 수 있도록 보장할 것입니다.\n\n# 단계 6: RBAC로 경로 보호하기\n\n이제 만든 미들웨어를 사용하여 경로를 안전하게 만들어봅시다. 우리의 애플리케이션에서 다양한 경로를 보호하기 위해 checkPermissions 미들웨어를 적용할 것입니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\r\n// app.js\n\n// 필요한 모듈 가져오기\nconst express = require('express');\nconst permify = require(\"@permify/permify-node\");\nconst authMiddleware = require('./auth'); // 인증 미들웨어 가져오기\n\n// Express 앱 생성\nconst app = express();\n\n// userInfo를 채우는 사용자 지정 미들웨어 정의\napp.use((req, res, next) => {\n  // 사용자 인증 시뮬레이션 및 userInfo 채우기\n  req.userInfo = {\n    id: req.params.id // 요청 매개변수에서 id 추출\n    // 필요한 경우 다른 사용자 정보 추가\n  };\n  next();\n});\n\n// 라우트 정의\n\n// '/users/:id' 경로에 대한 권한 확인을 적용하려는 경우\napp.get('/users/viewFiles/:id', authMiddleware('view_files'), (req, res) => {\n  // 미들웨어가 요청을 통과시키면 라우트 로직 처리\n  if (req.authorized === 'authorized') {\n    res.send('이 사용자 경로에 액세스할 수 있습니다');\n  } else {\n    res.status(403).send('이 사용자 리소스에 액세스할 권한이 없습니다');\n  }\n});\n\n// '/admin/deleteVendorFiles/:id' 경로에 대한 권한 확인을 적용하려는 경우\napp.get('/admin/deleteVendorFiles/:id', authMiddleware('delete_vendor_file'), (req, res) => {\n  // 미들웨어가 요청을 통과시키면 라우트 로직 처리\n  if (req.authorized === 'authorized') {\n    res.send('이 관리자 경로에 액세스할 수 있습니다');\n  } else {\n    res.status(403).send('이 관리자 리소스에 액세스할 권한이 없습니다');\n  }\n});\n\n// 서버 시작\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n  console.log(`서버가 ${PORT}포트에서 실행 중입니다`);\n});\r\n```\n\n이 코드는 특정 라우트가 authMiddleware라는 사용자 지정 미들웨어를 사용하여 보호되는 Express 애플리케이션을 포트 3000에서 설정합니다.\n\n이 authMiddleware라는 미들웨어는 auth.js 파일에서 가져온 Permify와 통합하여 권한 확인을 수행합니다. 아래는 미들웨어에 의해 보호되는 라우트입니다;\n\nauthMiddleware에 의해 보호되는 라우트:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- /users/viewFiles/:id 경로: 이 경로는 파일을 볼 권한을 가진 사용자만 접근할 수 있도록 보장합니다.\n- /admin/viewFiles/:id 경로: 이 경로는 업체 파일을 삭제할 권한을 가진 관리자만 접근할 수 있도록 보장합니다.\n\n이러한 경로에 authMiddleware를 적용하여 Permify가 부여한 권한에 따라 접근이 제한됩니다.\n\n구현을 테스트해봅시다!\n\n# RBAC 구현 테스트\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 Markdown 형식으로 표를 작성하였습니다.\n\n\n| 사용자ID | 역할         | \n|--------|--------------|\n| alice  | 멤버         | \n\n\n이 표는 사용자 alice에게 멤버 역할을 부여하기 위한 Permify Nodejs 클라이언트의 data.write 메소드를 사용하는 예시 코드입니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그 코드를 실행하고 Postman을 사용하여 /users/viewFiles/ API 엔드포인트에 방문해 보세요.\n\n![image](/assets/img/2024-06-30-ImplementingRoleBasedAccessControlRBACinNodejsandExpressApp_5.png)\n\n이제 코드를 실행한 후 Alice는 /users/viewFiles/ API 엔드포인트에 성공적으로 액세스할 수 있습니다.\n\n# 결론\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n인가(authorization)가 한 번만 설정하는 것이 아니라 계속된 과정이라는 것을 인지하는 것이 중요합니다.\n\n따라서 모델을 정기적으로 검토하고 철저한 테스트를 수행하며 애플리케이션이 발전함에 따라 적응시키는 것이 중요합니다.\n\n이 가이드는 Node.js 애플리케이션에 RBAC(Role-Based Access Control)을 구현하는 데 튼튼한 기초 역할을 합니다.\n\n그러나 개별 요구 사항에 정확히 맞게 RBAC 모델을 맞춤화하는 데 더 심층적으로 파고들고 망설이지 마세요.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nPermify의 기능을 활용하면 권한 관리를 최적화하고 견고하고 안전한 애플리케이션 환경을 육성할 수 있어요.","ogImage":{"url":"/assets/img/2024-06-30-ImplementingRoleBasedAccessControlRBACinNodejsandExpressApp_0.png"},"coverImage":"/assets/img/2024-06-30-ImplementingRoleBasedAccessControlRBACinNodejsandExpressApp_0.png","tag":["Tech"],"readingTime":21},{"title":"JS 디자인 패턴 옵저버 사용법 이해하기","description":"","date":"2024-06-30 21:52","slug":"2024-06-30-JavascriptDesignPatternsObserver","content":"\n\n애플리케이션 내에서 상태를 관리하는 것은 시스템의 복잡성에 따라 매우 어려운 작업이 될 수 있습니다. 때때로 비동기 이벤트가 다른 이벤트에 영향을 받아 애플리케이션이 어떻게 동작해야 하는지를 결정하는 복잡한 규칙에 의존하는 시나리오에 놓일 수 있습니다. 한 요소의 변경이 입력에 따라 달라지는 변수에 의해 다른 요소에 변경을 일으킬 수도 있습니다.\n\n이러한 상황에서 옵저버 디자인 패턴을 적용하는 것이 흥미로운 아이디어일 수 있습니다. 디자인 패턴 서적에서 정의를 통해 설명해보겠습니다:\n\n일반적으로 변화를 \"전달\"하는 객체는 주체/Observable로 불리며, 통지를 받을 객체들은 옵저버들이라고 합니다.\n\n![이미지](/assets/img/2024-06-30-JavascriptDesignPatternsObserver_0.png)\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 간단한 VanillaJS Subject/Observable 만들기\n\n이러한 행동 패턴의 응용 프로그램을 더 잘 이해하기 위해 먼저 이 패턴이 어떻게 작동하는지 이해해야 합니다. 이를 위해 우리는 우리의 로직을 캡슐화 할 간단한 Subject 클래스를 만들 것입니다. 이 패턴의 여러 구현에서 공통으로 사용되는 몇 가지 용어를 사용할 것입니다:\n\n- 모든 옵저버에게 브로드캐스트될 값을 전달하려면 next 메서드를 사용하여 값을 전달합니다.\n- 변경 사항을 듣기 위해 옵저버를 만들려면 subscribe 메서드를 사용하여 옵저버를 전달하십시오.\n- 옵저버를 제거하여 Subject 변경 사항을 더 이상 듣지 않게하려면 해당 옵저버를 전달하고 unsubscribe 메서드를 호출하시면 됩니다.\n\n그리고 이로써 우리는 Subject의 기본 구조를 갖게 되었습니다. 이러한 시나리오에서, 그리고 자바스크립트에서 이 패턴의 일반적인 사용 사례에서도 Subject는 클래스로 구현되고 옵저버는 함수로 구현됩니다. 이 구현은 옵저버들에게 많은 유연성을 제공합니다. 함수로서 값들을 많은 방법으로 처리할 수 있기 때문에, 그리고 이전의 구현에 의존하지 않습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래에 주제와 수학 함수로 간주되는 관찰자가 있는 예시가 있습니다:\n\n이 코드 일부를 보려면 콘솔을 여는 것이 관찰자 패턴의 핵심입니다: 주 객체인 이 경우에는 number$ 변수가 여러 변수에 가입하고, 그런 다음 구독된 모든 변수에 값을 브로드캐스트하기 위해 next 호출을 보낼 수 있습니다.\n\n이제 RxJS를 사용하여 좀 더 복잡한 구현을 해보도록 하겠습니다.\n\n# RXjs로 파워 추가하기\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n복잡하고 많이 사용되는 패턴인 옵저버 디자인 패턴에서 자바스크립트의 Observable을 다루는 데 유용한 작업 세트와 도우미 메서드를 제공하는 RxJS 라이브러리가 있습니다. 보통 일상적인 옵저버 디자인 패턴 사용 사례에서 이 라이브러리와 상호 작용해야 할 수도 있습니다.\n\n이 예시를 가져와서 RxJS를 사용하여 슈퍼충전해 보겠습니다. 유저 포스트 UI를 만들겠지만 RxJS가 제공하는 다양한 기능을 활용할 것입니다.\n\nAPI 생성하기\n\nAPI를 만들기 위해 이 공개 엔드포인트를 사용할 것입니다. 포스트(Post), 유저(User) 및 코멘트(Comment) 엔드포인트를 사용할 것입니다. 이를 위해 각 포스트에는 유저 정보, 포스트 자체 및 댓글 정보가 있는 다른 소셜 미디어와 유사한 구조를 사용할 것입니다. 이로써 우리는 더 복잡한 예제를 만들 수 있게 되며 옵저버블의 옵저버블이나 고차 옵저버블과 같은 다양한 연산자들을 활용할 수 있게 됩니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nfrom 메서드를 사용하여 배열이나 프로미스와 같은 일반적인 소스에서 옵저버블 소스를 생성할 수 있습니다.\n\n이제 API를 갖게 됐으니, 입력 옵저버블과 포스트 옵저버블을 생성해보겠습니다.\n\n입력 옵저버블 생성하기\n\n그래서 애플리케이션 내에서 변수 상태를 만들기 위해, 간단한 숫자 입력을 사용하여 사용자 ID를 변경하고 싶을 것입니다. 입력은 디바운싱 및 범위 제한이 있어야 하며, 유효한 값은 1부터 10 사이여야 합니다. RxJS를 사용해서 어떻게 할 수 있을까요?\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n`fromEvent` 메서드를 사용하면 HTML 요소와 이벤트 이름을 전달하여 해당 이벤트에 따라 값을 방출하는 옵저버블을 반환할 수 있습니다. 그러니 우리는 입력 요소와 입력 이벤트를 사용해 보겠습니다. 이는 요소에 사용자 입력이 있을 때마다 발생할 것입니다.\n\n그 후에는 pipe 연산자와 RxJS 연산자 함수를 사용하여 최종 옵저버블을 얻도록 도와줄 수 있습니다. pipe 연산자를 사용하여 옵저버블이 방출하는 값을 연결하는 파이프로 생각하고, 파이프에 삽입된 각 메소드는 데이터를 변경하고 앞으로 전달합니다. 마치 가전제품과 수도 밸브처럼 파이프를 흐르는 물의 특성을 변경하는 것처럼, 각각이 다른 작업을 수행합니다.\n\n사용된 각 메소드를 살펴보겠습니다:\n\n- `map` 메소드는 일반적인 배열 메소드처럼 작동하여 값을 가져와 다른 값으로 반환합니다. 여기서는 이벤트를 가져와 값을 기준으로 정수를 반환할 것입니다.\n- `filter` 메소드는 일반적인 배열 상대로 작동하여 흐름에서 10 이하의 값만 방출하도록 합니다.\n- `debounceTime` 메소드는 값이 방출되고 300ms 이내에 다른 값이 방출된다면 그 사이 값은 무시되고 300ms 후의 마지막 값만 고려됩니다.\n- 마지막으로 `startWith`를 사용하면 초기 값이 1로 설정되어 처음 방출되기 전에 값이 됩니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그러면 최종적으로 파이프라인 결과가 준비됩니다. 사용자가 입력 이벤트를 발생시킬 때마다, 1과 10 사이의 숫자가 생성되며 다른 모든 숫자는 무시됩니다.\n\n## 게시물 옵저버블 생성\n\n이제 게시물이 있으면, 프로젝트의 가장 복잡한 부분이 될 것입니다. 사용자 및 해당 사용자의 게시물을 가져와야 합니다. 그 후 각 게시물에 대해 해당 게시물의 댓글을 가져와서 모든 내용을 묶어야 합니다.\n\n백엔드 솔루션으로는 이미 관련 데이터를 그룹화하는 다양한 DB 라이브러리와 패러다임이 지원되기 때문에 이 작업은 어렵지 않을 것입니다. 그러나 프론트엔드에서 이 작업을 수행하는 것은 어려울 수 있습니다. 왜냐하면 사용자 입력 로직도 함께 그룹화해야 하기 때문입니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 먼저, 입력 Observable을 연결하고 switchMap 연산자를 호출합니다. 이 연산자는 Observable을 가져와 자동으로 구독하여 결과를 반환합니다. 이 패턴에 대한 자세한 내용은 여기에서 확인할 수 있습니다;\n- switchMap 메서드에 공급될 Observable은 zip 도우미 함수를 사용하여 구축되며, 이 함수는 n개의 observables을 가져와 모든 작업이 완료된 후 응답의 배열을 방출하는 Observable을 반환합니다.\n- 이후에는 사용자 정보와 해당 사용자의 게시물을 반환해야 할 배열이 있지만, 여전히 각 게시물의 코멘트를 가져와 추가해야 합니다.\n\n이제 제대로 이해해 주세요, 조금 복잡해질 수 있습니다:\n\n- 먼저, 우리의 게시물을 위해 생성된 Observable 스트림으로 switchMap을 입력하여, 각 게시물이 Observable에서 방출되는 값이 됩니다;\n- 그 후에는 해당 Observable에서 나오는 각 게시물에 대해 mergeMap을 사용합니다. MergeMap을 사용하면 이전 Observable이 완료될 때까지 다음 Observable을 시작할 필요가 없도록 만듭니다. 여기서 중요한 이유는 각 게시물을 기다릴 필요가 없고, 모든 게시물이 완료되었을 때만 신경을 써야하기 때문입니다;\n- 이 mergeMap은 코멘트를 가져오고, 코멘트를 가져온 후에는 모든 값을 매핑하여 출력 객체를 생성합니다;\n- 그 후에는 toArray 메서드가 있습니다. 이 메서드는 Observable에 의해 방출된 모든 값을 배열로 다시 그룹화합니다;\n- 그 이후에는 값으로 UI를 채우는 문제만 남았습니다, 우리는 이를 템플릿 문자열과 tap 메서드를 사용하여 할 수 있습니다, 이를 side effect로 수행합니다;\n\n최종 결과는 아래에서 확인할 수 있습니다:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n테이블 태그를 마크다운 형식으로 변경해주세요.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nObservables는 일대다 관계와 복잡한 데이터 흐름이 있는 시나리오에서 가장 잘 사용됩니다. 응용 프로그램에 더 많은 보일러플레이트 코드를 추가하는데 항상 그 가치가 있는 것은 아닙니다.\n\n예를 들어, 복잡한 페이지네이션, 필터, 검색 및 기타 비동기 상호작용이 있는 프론트엔드를 구축할 때, 이벤트를 처리하고 필요한 변경 사항을 트리거하는 데 Observable을 사용하면 상태를 더 예측 가능하게 만들고 관리하기 쉬워집니다.\n\n단순한 HTTP 로그인 호출을 Observable로 변환하는 것은 간단한 메소드가 로직을 처리할 수 있을 때 과하게 느껴질 수 있습니다.\n\n핵심은 응용 프로그램 내에서 대가 균형을 평가하고 그에 따라 실행하는 것입니다. 조심히 사용해주세요.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 고지사항\n\n## 디자인 패턴에 대해 더 알아보기\n\n## 링크\n\n저를 팔로우하세요: https://medium.com/@dgramaciotti\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nLinkedIn: [다니엘 귀데스](https://www.linkedin.com/in/daniel-guedes-79a05a176/)\n\nGitHub: [dgramaciotti](https://github.com/dgramaciotti)\n\n이 글이 마음에 드셨나요? 좋아요를 눌러주시고 소셜 네트워크에서 공유해주세요!","ogImage":{"url":"/assets/img/2024-06-30-JavascriptDesignPatternsObserver_0.png"},"coverImage":"/assets/img/2024-06-30-JavascriptDesignPatternsObserver_0.png","tag":["Tech"],"readingTime":8}],"page":"7","totalPageCount":120,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true}