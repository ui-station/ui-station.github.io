{"pageProps":{"posts":[{"title":"VSCode의 글꼴이 UHD 및 OLED 디스플레이에서 더 선명해진 방법 한 가지 설정으로 해결","description":"","date":"2024-06-22 22:48","slug":"2024-06-22-VSCodeFontsNowSharperOnUHDAndOLEDDisplaysWithOneFlag","content":"\n<img src=\"/assets/img/2024-06-22-VSCodeFontsNowSharperOnUHDAndOLEDDisplaysWithOneFlag_0.png\" />\n\n# 마침내, OLED 및 UHD 모니터에서 VSCode 글꼴이 흔들리는 문제를 해결할 수 있게 되었습니다!\n\n# 새로운 플래그\n\n일반적으로 VSCode의 개선 사항은 생산성, 개발자 경험 및 Copilot과 같은 통합과 같은 개발자 도구를 중심으로합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n하지만 항상 그렇지만은 않고 때로는 변화가 상당히 놀라울 수 있어요.\n\n2024년 5월 버전의 개선 목록 중에서 여러 탭을 동시에 선택할 수 있는 기능, 프로필, 에디터 창 작업 아이콘을 항상 표시할 수 있는 기능 또는 Copilot 대답에 대한 텍스트 음성 변환 기능을 발견할 수 있어요.\n\n그 중에서도 가장 흥미로운 것은 \"Set disable-lcd-text as a runtime argument\"라는 수수께끼 같은 제목으로 가능한 개선이에요.\n\n간단한 설명에서는 다음과 같은 것을 배울 수 있어요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nIllustration을 확인해보세요:\n\n![image](/assets/img/2024-06-22-VSCodeFontsNowSharperOnUHDAndOLEDDisplaysWithOneFlag_1.png)\n\n왼쪽에 보면 플래그가 true로 설정된 버전이 있습니다. 이는 LCD 텍스트가 비활성화됨을 의미합니다.\n\n보이는 바에 따르면, 그 버전은 UHD 모니터를 사용하는 몇몇 개발자들, Retina 디스플레이를 사용하는 Mac 노트북 사용자들을 포함한 다른 많은 사람들에게 더 나은 선택이 될 것 같습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n하지만 모든 사람이 화면에서 변경 사항을 보지 못할 수도 있고, 모든 사람이 그것을 좋아하지도 않을 것입니다.\n\n# 서브픽셀의 폰트가 개선된 이유\n\n하지만 이것이 정말 어떤 것인가요? 우리가 비활성화해야 하는 LCD 텍스트 기능은 무엇일까요?\n\n이것을 이해하려면 90년대로 돌아가 봐야 합니다. 사람들이 점점 더 컴퓨터를 사용하기 시작했습니다. 운영 체제 개발 회사들은 소비자 시장에 더 집중하기로 결정했습니다. 이를 위해 최상의 사용자 경험을 제공해야 했습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n온라인 비디오 플랫폼이 없었기 때문에 사람들은 800x600 픽셀 모니터에서 텍스트를 작성하고 마인스위퍼를 플레이하던 컴퓨터를 주로 사용했어요.\n\n해당 해상도의 한계는 픽셀이 일론 머스크의 자아보다 더 크다는 것이에요. 그래서 눈으로 그들을 볼 수 있었어요.\n\n그 중 가장 피해를 입은 것은 텍스트였어요. 그 이유가 뭘까요? 사용자 인터페이스를 구축하고 해상도가 무엇인지 알고 있다면 이를 조절하여 멋지게 보이도록 조정할 수 있어요. 이런 경우에는 픽셀 아트처럼 해상도의 제한과 사용자 인식을 고려하여 아이콘과 인터페이스를 픽셀 단위로 그려 조정하는 것을 뜻해요.\n\n하지만 텍스트의 경우는 그렇게 쉽지 않아요. 다른 요소들과 비교했을 때 글자와 기호들은 매우 구체적인 구조를 가지고 있어요. 그것들을 많이 변경할 수 없는 이유는 더 이상 가독성이 없어지거나 다른 글자와 유사해질 수 있기 때문이에요. 예를 들어, 글자 O와 숫자 0은 구분되어야 하므로 약간 다르게 보이도록 해야 해요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n작은 해상도에서는 정말로 어려워요.\n\n그 문제를 해결하고 나니, 90년대에 또 다른 문제가 뚜렷해졌어요. 폰트가 정말로 못생겼어요.\n\n폰트는 날카롭고 화소로 이루어져 있었죠. 그래서 작은 폰트는 읽기 어렵고 큰 폰트는 마인크래프트 같이 보였어요.\n\n소비자들이 좋아하지 않는 것이었죠. 그래서 그 시기에는 물리적 해상도를 늘릴 수 없었기 때문에 많은 해결 방안이 제안되었어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 안티 앨리어싱으로 구제!\n\n이 문제 중 하나는 안티 앨리어싱입니다. 흰 배경에 검은 텍스트가 있는 경우, 회색 픽셀로 모서리를 부드럽게 만들어 줍니다. 그렇게 하면 확대할 때 글꼴이 덜 날카롭지만 부드럽고 픽셀화가 줄어듭니다:\n\n![이미지](/assets/img/2024-06-22-VSCodeFontsNowSharperOnUHDAndOLEDDisplaysWithOneFlag_2.png)\n\n이 방법은 픽셀 아트에서 디자인을 부드럽게 만드는 데에도 사용됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n하지만 글꼴의 경우는 세부 사항 때문에 일반적인 안티앨리어싱만으로는 충분하지 않았습니다. 그래서 1990년대에 Microsoft와 Apple은 유사한 솔루션을 도입했습니다.\n\nWindows의 경우, ClearType이 그것입니다. 화면에 표시되는 텍스트의 표시 방법을 개선하는 세트의 방법입니다.\n\n그러나 일반적인 안티앨리어싱과 비교하여 ClearType은 서브픽셀에서 작동합니다.\n\n화면에서 본 픽셀은 사실 빨강, 녹색 및 파랑(RGB)과 같은 서로 가깝게 배치된 서로 다른 색상의 서브픽셀입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 서블 픽셀의 위치를 알고 있다면 LCD 스크린에 대해 90년대에 알려졌듯이 이 서블 픽셀을 사용하여 글꼴의 안티 앨리어싱을 할 수 있습니다. 이렇게 하면 이웃하는 서블 픽셀들이 부드럽게 변할 수 있는 더 세련된 효과를 낼 수 있습니다.\n\n연구 결과를 보면 ClearType를 활성화한 상태에서 텍스트를 읽는 것이 더 좋다고 한 사람들이 많았습니다. 그러나 90년대에는 시력이 좋은 사람들조차도 이 방식을 짜증냈다고 합니다.\n\n폰트가 서로 닮아보이기 시작하고 독특한 특징을 잃게 되었다고 보고했으며, 어떤 디스플레이에서는 이 방식으로 인해 흐릿하고 붉은 블루 하로가 나타나 짜증이 났다고 합니다.\n\n그럼에도 불구하고 모든 사람들이 만족했습니다. ClearType를 비활성화할 수 있었기 때문이죠.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 새로운 디스플레이로 LCD 최적화 방법이 오래되었습니다\n\n2024년 상황이 달라졌어요. 실제로 지금은 서브픽셀이 어떻게 배치되는지에 대한 규칙이 없어졌어요. 점점 더 많은 디스플레이가 삼각형 구성 또는 다른 유형의 배치를 사용하고 있어요.\n\n이것은 폰트 최적화가 적용되었을 때 텍스트가 더 신기해진다는 것을 의미해요. 왜냐하면 실제 서브픽셀의 위치와는 다른 곳을 가정하기 때문이죠. 결과적으로 이상한 효과가 발생하는데요, 심지어 보다 더 눈에 띄는 빨간색과 파란색의 이동 및 가장자리의 선이 현상되는 효과도 있어요.\n\n예를 들면 이렇게요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![2024-06-22-VSCodeFontsNowSharperOnUHDAndOLEDDisplaysWithOneFlag_3.png](/assets/img/2024-06-22-VSCodeFontsNowSharperOnUHDAndOLEDDisplaysWithOneFlag_3.png)\n\nOLED 및 다른 비-LCD 장치에서 특히 선명해졌어요.\n\n시스템 UI의 ClearType를 제어할 수 있지만, 앱에서 변경할 지 어떻게 변경할 지를 결정하는 것은 앱 개발자에 따라 달라요.\n\n예를 들어, 많은 브라우저에서는 어떤 종류의 글꼴 평활화를 적용할 지를 사용자가 결정할 수 있어요. 이 옵션은 웹 앱이 액세스할 수 없는 많은 변수(하위화소 레이아웃과 같은)에 따라 결정해야 하는 매우 특정한 경우에만 사용되어야 해요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만일 VSCode에 대해 구체적으로 언급한다면, 이 IDE는 TypeScript로 작성되었고 Electron과 Chromium을 사용합니다.\n\n그리고 Chromium은 LCD 스크린을 위한 최적화 비활성화를 위한 플래그를 제공하지만, VSCode에서는 이를 노출하지 않았습니다.\n\n2024년 5월 릴리스로 인해 가능해졌습니다. 그래서 고해상도 스크린, OLED 또는 다른 스크린을 사용하시는 경우, 글꼴 최적화를 비활성화하는 것이 글꼴 표시 방법을 향상시킬 수 있는지 확인할 수 있습니다.\n\n고해상도 스크린의 경우 글꼴 부드럽게 처리는 필수가 아닙니다. 높은 픽셀 밀도는 서브픽셀 최적화를 점점 더 사용하지 않게 만듭니다.\n","ogImage":{"url":"/assets/img/2024-06-22-VSCodeFontsNowSharperOnUHDAndOLEDDisplaysWithOneFlag_0.png"},"coverImage":"/assets/img/2024-06-22-VSCodeFontsNowSharperOnUHDAndOLEDDisplaysWithOneFlag_0.png","tag":["Tech"],"readingTime":7},{"title":"RecyclerView 항목을 payloads로 효율적으로 업데이트하는 방법","description":"","date":"2024-06-22 22:47","slug":"2024-06-22-EfficientlyupdatingRecyclerViewitemsusingpayloads","content":"\n요즘 대부분의 앱은 사용자에게 수직이나 수평 목록으로 정보를 표시합니다. 종종, 정보는 동적이며 조회수, 좋아요 수 등과 같이 자주 업데이트해야 하는 정보입니다. 또한 목록에는 네트워크에서 로드된 이미지가 포함될 수도 있습니다. 이것이 RecyclerView를 효율적으로 업데이트하는 것이 중요한 이유이며, 성능이 우수한 앱을 갖고 좋은 사용자 경험을 제공하는 중요한 측면입니다.\n\n이 게시물은 얼마 전에 쓰여졌지만, 이미 다루어진 주제이고 Jetpack Compose가 현재 선호되는 UI 툴킷이기 때문에 발행할 지 말 지 고민하고 있었습니다. 그러나 이 정보가 누군가에게 도움이 될 수 있기를 바라며 게시하기로 결정했습니다.\n\n## DiffUtil과 ListAdapter 사용하기\n\n새 데이터로 RecyclerView를 효율적으로 업데이트하려면 notifyItemInserted(position: Int), notifyItemChanged(position: Int), notifyItemRemoved(position: Int) 등과 같은 함수를 호출해야 합니다 (docs에서는 효율적이지 않으며 최후의 수단으로만 사용해야 한다고 명시한 notifyDataSetChanged()는 피하시기 바랍니다). 이러한 함수를 호출하면 RecyclerView Adapter에 기본 데이터가 변경되었음을 알리고 뷰를 업데이트하여 새 상태를 반영해야 한다는 사실을 알리게 됩니다. 이러한 함수 호출은 RecyclerView가 모든 변경 사항을 애니메이션으로 처리하는 이점도 함께 제공됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n수동으로 그 모든 작업을 하지 않도록 하기 위해 DiffUtil을 사용할 수 있습니다 (공식 문서). DiffUtil은 이전 데이터와 새 데이터를 비교하고 차이점을 계산한 다음 RecyclerView.Adapter에 변경 사항을 알려주어 새 상태를 반영하기 위해 수행해야 하는 변경 사항을 선언합니다. 이후 사용할 DiffUtil.ItemCallback의 예시가 여기 있습니다.\n\nFunction areItemsTheSame(oldItem: Item, newItem: Item): Boolean은 id 또는 uuid와 같은 고유 속성을 기준으로 두 항목이 동일한지 확인합니다. 항목이 다를 경우 어댑터는 이전 항목을 새 항목으로 바꿔야 한다는 것을 알게 됩니다. 이 함수가 true를 반환하면 함수 areContentsTheSame(oldItem: Item, newItem: Item): Boolean이 호출되는데, 여기서 데이터 모델의 다른 속성 중 어떤 것이 변경되었는지 확인할 수 있습니다.\n\n중요한 점은 DiffUtil 결과를 백그라운드 스레드에서 계산하는 것이 권장된다는 것입니다. 더 큰 데이터 집합이 있는 경우에는 요구가 많을 수 있고 주 스레드를 차단할 수 있기 때문입니다. Coroutine 또는 RxJava를 사용하여 계산을 다른 스레드로 옮기거나 ListAdapter(공식 문서)를 사용하여 백그라운드 스레드에서 계산할 수 있습니다.\n\nListAdapter는 AsyncListDiffer (공식 문서)를 사용하여 백그라운드 스레드에서 차이를 계산하는 논리를 포함하고 RecyclerView.Adapter를 확장하여 코드를 더욱 간결하게 만듭니다. 할 일은 새 데이터를 함수 submitList(list: List)를 사용하여 전달하는 것뿐입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 샘플 앱에서 모두 함께 사용해보기\n\n지금까지 배운 내용을 모아 간단한 앱으로 만들어보겠습니다. 이 앱은 기사 목록을 표시하는데, 각 기사에는 제목, 부제목, URL에서 로드된 표지 이미지, 좌측 하단에 표시되는 코멘트 수가 포함되어 있습니다. 사용자는 각 기사 오른쪽 상단의 북마크 버튼을 눌러 해당 기사를 즐겨찾기에 추가할 수도 있습니다. 툴바에는 두 개의 버튼이 있습니다. 코멘트 수를 업데이트하는 새로고침 버튼과 애니메이션 데모 목적으로 기사의 순서를 임의로 변경하는 재정렬 버튼입니다.\n\n아래는 소스 코드와 앱이 동작하는 모습을 보여주는 동영상입니다.\n\n![앱 동작 예시](https://miro.medium.com/v2/resize:fit:640/1*kRBq0EXx36YlMoTCuulNuw.gif)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리는 재정렬 애니메이션이 원하는 대로 동작하는 것을 볼 수 있습니다. 그러나 사용자가 기사를 북마크하거나 댓글 수를 새로고침할 때의 애니메이션을 살펴보겠습니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:640/1*fWIvJ-K4PoONrlIZNzys1Q.gif)\n\n## 기사가 업데이트될 때 \"깜빡이\" 효과가 나타나는 이유는 무엇인가요?\n\n기본적으로 두 항목(우리의 경우 기사)이 동일하지만 다른 콘텐츠(우리의 경우 댓글 수 또는 기사 북마크 여부)를 가질 때 RecyclerView는 새 항목 보기를 렌더링한 다음 이전 항목 보기와 새 항목 보기 사이에 크로스 페이드를 수행하여 GIF에서 볼 수 있는 \"깜빡임\" 효과를 초래합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n특히 더 어두운 배경이 사용되거나 사용자 상호작용의 결과로 업데이트될 때 이 기능은 이상하게 보일 수 있습니다. 이는 북마크 또는 북마크 취소와 같은 사용자 상호작용으로 인한 업데이트가 발생할 때 더 문제가 됩니다.\n\n## 성능은 어떻게 해결할까요?\n\n\"깜빡\"이 발생하는 애니메이션 외에 다른 문제는 항목 뷰를 완전히 다시 바인딩한다는 점입니다. 이 방법은 효율적이지 않습니다. 우리는 댓글 수를 업데이트하거나 북마크 아이콘을 변경하기를 원할 뿐이지만, 대신 전체 항목 뷰를 다시 그리고 다시 렌더링하고 있습니다. 이는 이미 필요하지 않은 이미지를 다시로드 하는 것을 포함합니다.\n\n## 이 문제를 어떻게 해결할 수 있을까요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\"“RecyclerViewanimation”을 비활성화하는 방법을 검색 중이라면 나타나는 해결책 중 하나는 RecyclerView. itemAnimator에 supportsChangeAnimation = false를 설정하거나 itemAnimator = null로 설정하는 것입니다.\n\n그러나 이 방법은 항목의 순서가 변경되거나 새 항목이 예전 항목을 대체할 때 발생하는 모든 애니메이션도 비활성화되어 우리가 원하는 대상이 아닐 수 있습니다. 우리는 기존 항목의 속성이 변경될 때 교차 페이드 애니메이션을 제외한 모든 애니메이션을 유지하고 싶습니다. 또한, 이 해결책은 우리가 언급한 효율성/성능 문제를 다루지 않습니다.\n\n## Payloads\n\n페이로드를 사용하여 애니메이션 및 효율성 문제를 모두 해결할 수 있습니다. 페이로드는 이미 정의한 객체로, 이미 존재하는 항목 뷰를 완전히 다시 바인딩하는 대신 일부만 업데이트할 수 있게 해줍니다.\"\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nRecyclerView.Adapter의 함수들을 좀 더 자세히 살펴보면, onBindViewHolder(holder: ViewHolder, position: Int, payloads: MutableList`Any`)라는 추가 함수를 오버라이드할 수 있는데, 이 함수는 onBindViewHolder(holder: ViewHolder, position: Int) 함수를 오버로딩한 것으로 payloads라는 추가 인수가 있습니다. 이 함수에 대한 문서를 살펴보면 다음과 같이 설명되어 있습니다:\n\n변화 페이로드를 어떻게 얻을 수 있을까요? DiffUtil.ItemCallback에서 사용 가능한 함수들을 좀 더 자세히 살펴보면 기존의 함수인 areItemsTheSame(oldItem: Item, newItem: Item): Boolean과 areContentsTheSame(oldtItem: Item, newItem: Item): Boolean 외에도 fun getChangePayload(oldItem: Item, newItem: Item): Any?라는 추가 함수를 오버라이드할 수 있습니다.\n이 함수는 이전 항목과 새 항목이 동일하지만 내용이 다른 경우 호출됩니다. 항목의 어떤 속성이 다른지 감지하고, 항목 뷰를 부분적으로 업데이트할 수 있는 객체를 반환할 수 있게 해줍니다.\n\n여기서 우리는 이전 항목과 새 항목을 비교하고, 댓글 수가 다른 경우에는 ArticleChangePayload.Comments의 인스턴스를 반환하여 나중에 어떤 뷰를 업데이트해야 하는지 알 수 있게 합니다. 북마크 상태에 대해서도 동일한 작업을 수행하고, ArticleChangePayload.Bookmark를 반환합니다. 그리고 다른 변경 사항의 경우에는 간단히 super 함수를 호출하여 null을 반환하게 하여 전체 재바인딩이 되도록 합니다.\n\n이렇게하면 이제 onBindViewHolder 함수에서 payloads 인수를 확인할 수 있습니다. 이 것은 여러 스레드에서 병합된 여러 업데이트가 될 수 있기 때문에 리스트 형태로 제공됩니다. 문서에서 언급된 것처럼요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n각 리스트를 하나하나 처리할지 아니면 리스트에서 마지막 항목만 가져올지 결정할 수 있어요.\n\n우리 경우에는 마지막 항목을 확인하고, 만약 그것이 ArticleChangePayload.Comments 유형이라면 댓글 수 TextView를 업데이트하고, ArticleChangePayload.Bookmark 유형이라면 북마크 이미지 버튼을 업데이트할 거에요. 또한 페이로드가 비어 있거나 알 수 없는 유형인 경우를 처리하는 것이 중요해요. 그런 경우에는 원래의 onBindViewHolder(holder: ViewHolder, position: Int) 함수를 호출하여 완전히 다시 바인딩해야 해요. 이는 오버로드된 onBindViewHolder 함수의 기본 구현입니다.\n\n이 기능을 추가한 후에 이제 데이터가 변경된 부분만 뷰에 업데이트되고 깜박거림 효과가 없어졌다는 것을 확인할 수 있어요. 완벽해요.\n\n![이미지](https://miro.medium.com/v2/resize:fit:640/1*OevReNMqnU9pngRAEUxmWQ.gif)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그리고 여기에 업데이트된 어댑터 구현이 있습니다.\n\n## 결론\n\n저희는 DiffUtil, ListAdapter 및 payloads를 사용하여 RecyclerView 콘텐츠를 가장 효율적으로 업데이트하는 방법을 살펴보았습니다. 우리가 글 목록을 보여주는 앱을 가지고 있고 좋아요 수나 조회수를 자주 업데이트하려는 경우, payloads를 사용하면 전체 항목을 다시 부풀리고 다시 그리는 대신 변경된 뷰만 효율적으로 업데이트할 수 있습니다.\n\n샘플 앱의 소스 코드는 여기에서 확인할 수 있습니다: https://github.com/landomen/recyclerview-payloads-sample\n","ogImage":{"url":"/assets/img/2024-06-22-EfficientlyupdatingRecyclerViewitemsusingpayloads_0.png"},"coverImage":"/assets/img/2024-06-22-EfficientlyupdatingRecyclerViewitemsusingpayloads_0.png","tag":["Tech"],"readingTime":8},{"title":"2024 최신 Android Paging 30 Part 2 적용 방법","description":"","date":"2024-06-22 22:46","slug":"2024-06-22-Part2AndroidPaging30","content":"\n![그림](/assets/img/2024-06-22-Part2AndroidPaging30_0.png)\n\n안드로이드에서의 Paging 3.0은 이전 버전보다 여러 가지 개선 사항과 변화를 가져와서 더 강력하고 사용하기 쉽게 만들어졌어요. 아래에는 Paging 3.0의 각 구성 요소를 구현하는 방법에 대한 자세한 설명이 있습니다.\n\n# Paging 3.0의 주요 구성 요소\n\n- PagingSource: DataSource를 대체하며 서로 다른 소스로부터 데이터를 페이징하는 데 사용되는 주요 API 역할을 합니다.\n- Pager: 페이징된 데이터의 Flow 또는 LiveData를 생성하는 데 사용됩니다.\n- PagingData: 페이징된 데이터의 스트림을 나타냅니다.\n- PagingDataAdapter: PagedListAdapter를 대체하며 RecyclerView에서 페이징된 데이터를 표시하는 데 사용됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 구현 단계\n\n- PagingSource 정의:\n\n- PagingSource는 데이터를 데이터 소스에서 로드하는 역할을 담당합니다.\n- 다양한 페이지에 대해 데이터를 로드하는 방법을 정의함으로써 PagingSource를 구현합니다.\n\n```kotlin\nclass MyPagingSource(private val apiService: ApiService) : PagingSource<Int, MyItem>() {\n\n    override suspend fun load(params: LoadParams<Int>): LoadResult<Int, MyItem> {\n        return try {\n            // 데이터 소스에서 데이터 로드\n            val nextPageNumber = params.key ?: 1\n            val response = apiService.getItems(nextPageNumber, params.loadSize)\n            LoadResult.Page(\n                data = response.items,\n                prevKey = if (nextPageNumber == 1) null else nextPageNumber - 1,\n                nextKey = if (response.items.isEmpty()) null else nextPageNumber + 1\n            )\n        } catch (e: Exception) {\n            LoadResult.Error(e)\n        }\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n2. 페이저 생성하기:\n\n- 페이저 객체는 PagingData의 Flow 또는 LiveData를 생성하는 데 사용됩니다.\n- 페이저를 PagingConfig와 PagingSource로 구성합니다.\n\n```js\nclass MyRepository(private val apiService: ApiService) {\n\n    fun getPagingData(): Flow<PagingData<MyItem>> {\n        return Pager(\n            config = PagingConfig(\n                pageSize = 20,\n                enablePlaceholders = false\n            ),\n            pagingSourceFactory = { MyPagingSource(apiService) }\n        ).flow\n    }\n}\n```\n\n3. ViewModel에서 PagingData 관찰하기:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 뷰모델에서 PagingData를 관찰하기 위해 Flow를 사용하세요.\n- LiveData를 선호한다면 LiveData와 함께 작업하십시오.\n\n```js\nclass MyRepository(private val apiService: ApiService) {\n\n    fun getPagingData(): Flow<PagingData<MyItem>> {\n        return Pager(\n            config = PagingConfig(\n                pageSize = 20,\n                enablePlaceholders = false\n            ),\n            pagingSourceFactory = { MyPagingSource(apiService) }\n        ).flow\n    }\n}\n```\n\n4. PagingDataAdapter로 RecyclerView 설정하기:\n\n- PagingDataAdapter를 사용하여 데이터를 RecyclerView에 바인딩합니다.\n- PagingData가 변경될 때 새 데이터를 어댑터에 제출하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nclass MyViewModel(private val repository: MyRepository) : ViewModel() {\n\n    val pagingDataFlow = repository.getPagingData().cachedIn(viewModelScope)\n}\n```\n\n5. Activity/Fragment에서 모든 것을 연결하기:\n\n- PagingData를 관찰하고 어댑터에 제출합니다.\n\n```js\nclass MyPagingDataAdapter : PagingDataAdapter<MyItem, MyViewHolder>(MyDiffCallback()) {\n\n    override fun onBindViewHolder(holder: MyViewHolder, position: Int) {\n        val item = getItem(position)\n        if (item != null) {\n            holder.bind(item)\n        }\n    }\n\n    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): MyViewHolder {\n        val view = LayoutInflater.from(parent.context).inflate(R.layout.item_view, parent, false)\n        return MyViewHolder(view)\n    }\n\n    class MyDiffCallback : DiffUtil.ItemCallback<MyItem>() {\n        override fun areItemsTheSame(oldItem: MyItem, newItem: MyItem): Boolean {\n            return oldItem.id == newItem.id\n        }\n\n        override fun areContentsTheSame(oldItem: MyItem, newItem: MyItem): Boolean {\n            return oldItem == newItem\n        }\n    }\n}\n\nclass MyViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {\n    fun bind(item: MyItem) {\n        // 뷰에 데이터를 바인딩합니다\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 대용량 데이터 처리\n\nPaging 3.0은 다음과 같은 방식으로 대용량 데이터 세트를 효과적으로 처리합니다:\n\n- 점진적 로딩: 필요할 때 데이터를 청크 단위로 로드하여 메모리 사용량을 줄입니다.\n- 백그라운드 로딩: 데이터 로딩을 백그라운드에서 처리하여 반응이 빠른 UI를 제공합니다.\n- 오류 처리: 실패한 로드를 다시 시도할 수 있는 메커니즘을 제공합니다.\n- 캐싱: 불필요한 네트워크 또는 데이터베이스 호출을 방지하기 위해 인메모리 캐싱을 지원합니다.\n- 변환: PagingData에 직접 적용할 수 있는 데이터 변환(예: 맵, 필터)을 허용합니다.\n\nPaging 3.0을 사용하여 대용량 데이터 세트를 원활하게 처리할 수 있는 효율적이고 반응이 뛰어난 애플리케이션을 만들 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-06-22-Part2AndroidPaging30_0.png"},"coverImage":"/assets/img/2024-06-22-Part2AndroidPaging30_0.png","tag":["Tech"],"readingTime":6},{"title":"Flutter에서 시간표시를 사용자 친화적으로 포맷하는 방법","description":"","date":"2024-06-22 22:45","slug":"2024-06-22-FromTimestamptoUser-FriendlyFormattingDateandTimeinFlutter","content":"\nFlutter 앱을 개발 중이라면 날짜를 어떤 방식으로든 표시해야 할 가능성이 높습니다. 특정 순서로 날짜를 표시하려면 올바른 장소에 오신 것을 환영합니다. 이 기사에서는 Flutter에서 어떻게 날짜와 시간을 어떤 형식으로든 포맷할 수 있는지 배워보겠습니다.\n\n우선 기본부터 시작해 봅시다. 현재 날짜와 시간을 가져오는 방법을 알아보겠습니다.\n\n```js\nDateTime currentDateTime = DateTime.now();\ndebugPrint(currentDateTime.toString());\n```\n\n위 코드는 이와 같은 결과를 제공할 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![image](/assets/img/2024-06-22-FromTimestamptoUser-FriendlyFormattingDateandTimeinFlutter_0.png)\n\n안 예쁘게 보이네요, 그래서 여기 계신 거죠. 이것을 더 읽기 쉬운 방식으로 서식을 지정하려고 합니다. currentDateTime에는 오늘의 날짜와 현재 시간이 포함됩니다. 이를 원하는 대로 문자열 형식으로 원격 또는 로컬 데이터베이스에 저장하거나 지금 표시하려면 직접 조작할 수 있습니다.\n\n참고: - 다른 곳(데이터베이스)에서 날짜를 가져오는 경우 문자열 형식으로 저장되었을 가능성이 높으므로 이를 DateTime 형식으로 변환하는 방법입니다.\n\n```js\nDateTime current = DateTime.parse(variableName);\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n중요한 부분이 왔어요! 포맷을 변경하는 방법을 설명하겠어요. 두 가지 방법을 설명할 거에요. 첫 번째 방법은 간단하고 쉽게 사용할 수 있어요. 두 번째 방법은 사용자 정의 형식이지만 쉬워요 :-).\n\n![image](/assets/img/2024-06-22-FromTimestamptoUser-FriendlyFormattingDateandTimeinFlutter_1.png)\n\n만약 이 중 하나를 원한다면 아주 잘 알겠어요. 그렇지 않다면 더 다양한 경우에 대한 하나의 해결책이 더 있어요. 이 해결책은 이 글의 두 번째 부분에서 확인할 수 있어요.\n\n- 표준 형식 사용\n  먼저, public.yaml 파일에 intl 라이브러리를 추가해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  cupertino_icons: ^1.0.2\n  intl: ^0.17.0\n```\n\n이 라이브러리의 최신 버전을 intl 라이브러리에서 확인할 수 있습니다.\n\n```js\nDateTime now = DateTime.now();\n// String 형식의 변수를 dateTime으로 사용하는 경우 DateTime dateTime = DateTime.parse(variableName);\nString formattedDate = DateFormat.yMMMEd().format(now);\nprint(formattedDate);\n```\n\nTue, Jan 25, 2022\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nCheatsheet:-\n\n![Screenshot](/assets/img/2024-06-22-FromTimestamptoUser-FriendlyFormattingDateandTimeinFlutter_2.png)\n\n2. If you want a custom pattern\n\nSometimes we need to format a date in a specific format that may not be present in the above cheatsheet. What should we do? Give up!! Never! Is that why you started your journey, to give up after coming so close to completing your task?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여기 답변을 찾을 수 있는 기사입니다. 그래서 계속해서 진행하세요!!\n\n```js\nDateTime now = DateTime.now();\nformattedDate = DateFormat('EEEE, MMM d, yyyy').format(now);\nprint(formattedDate);\n```\n\n```js\nTuesday, Jan 25, 2022\n```\n\n![이미지](/assets/img/2024-06-22-FromTimestamptoUser-FriendlyFormattingDateandTimeinFlutter_3.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n더 잘 이해하실 수 있도록 몇 가지 포인트를 설명해 드릴게요.\n\nEEEE -`은 요일의 전체 이름을 나타냅니다 (예: 월요일, 화요일..)\n\nE -`은 요일의 약어를 나타냅니다 (예: 월, 화...)\n\nMM -`는 월의 숫자를 의미합니다\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nMMM - 월 이름 약어\n\nMMMM - 전체 월 이름\n\nyy - 년도 뒷 두 자리\n\nyyyy - 년도\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n| 일련번호 | 형식 | 설명        |\n| -------- | ---- | ----------- |\n| dd       | 날짜 | 일          |\n| HH       | 시간 | 24시간 형식 |\n| hh       | 시간 | 12시간 형식 |\n| a        | 구분 | 오전/오후   |\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n어떤 특수 문자든 사용하셔도 됩니다.\n\nAryan Bisht님의 더 많은 소식\n\n# 코딩 및 개발 여정 업그레이드\n\n우리 커뮤니티의 일원이 되어 주셔서 감사합니다! 떠나시기 전에:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 👏 도움이 되셨다면 이 이야기에 박수를 치시고 작가를 팔로우해주세요 👉\n- 🔔 팔로우하세요: LinkedIn\n","ogImage":{"url":"/assets/img/2024-06-22-FromTimestamptoUser-FriendlyFormattingDateandTimeinFlutter_0.png"},"coverImage":"/assets/img/2024-06-22-FromTimestamptoUser-FriendlyFormattingDateandTimeinFlutter_0.png","tag":["Tech"],"readingTime":6},{"title":"계산기 앱 만들기  Gojek 엔지니어링 부트캠프 첫날","description":"","date":"2024-06-22 22:44","slug":"2024-06-22-CalculatorAppGojekEngineeringBootcampDayOne","content":"\n내가 Gojek Engineering Bootcamp 첫 날에 만든 프로젝트에 대해 이야기하고 싶어. 나는 Calculator 앱을 만들었어. 이 앱은 Android 개발을 위해 학생으로서 주어진 프로젝트 중 일부로, XML 레이아웃 및 Kotlin에 대해 배우는 과정의 일환이었어. 프로젝트를 완료한 지 얼마 되지 않아서, 여전히 신선한 기분이어서 여기에 대해 써 보고 싶어.\n\n![Calculator App Gojek Engineering Bootcamp Day One 0](/assets/img/2024-06-22-CalculatorAppGojekEngineeringBootcampDayOne_0.png)\n\n프로젝트를 마치기 위해, 나는 XML부터 시작했어. 여기서 ConstraintLayout을 사용했어. 이 레이아웃을 사용함으로써 Calculator 단어, 결과 상자, 숫자 입력 등을 자유롭게 배치할 수 있었어. 제목(\"Calculator\"라고 적힌 부분)에는 textStyle를 Bold로 설정한 TextView를 사용했어. 결과 상자에도 TextView를 사용했지만, 여기에는 흥미로운 점이 있어. 결과 텍스트의 글꼴이 다른 텍스트와 다르다는 것을 알 수 있어. 네, 결과 텍스트는 숫자 글꼴을 사용했어. 나는 \"download number font ttf\"라는 키워드로 구글에서 검색하여 해당 글꼴을 얻었어. ttf는 파일 형식을 나타냈어. 이 글꼴을 다운로드하고(압축 파일이었기 때문에) 추출한 다음 res.font 폴더에 넣었어.\n\n![Calculator App Gojek Engineering Bootcamp Day One 1](/assets/img/2024-06-22-CalculatorAppGojekEngineeringBootcampDayOne_1.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n결과 상자도 다소 독특합니다. 가까이 보면 상자의 텍스트가 아래 오른쪽에 배치되어 있습니다. 이것은 형식 설정 때문입니다. 형식을 지정하지 않으면 텍스트가 왼쪽 상단에 배치됩니다. 결과 상자의 코드는 다음과 같습니다.\n\n```js\n<TextView\n  android:id=\"@+id/result\"\n  android:layout_width=\"match_parent\"\n  android:layout_height=\"120dp\"\n  android:text=\"0\"\n  android:textSize=\"80dp\"\n  android:gravity=\"bottom|right\"\n  android:fontFamily=\"@font/calculator_font\"\n  android:background=\"@color/cardview_shadow_start_color\"\n  app:layout_constraintTop_toBottomOf=\"@id/title\"\n  app:layout_constraintStart_toStartOf=\"parent\"\n></TextView>\n```\n\n숫자 입력란에는 EditText를 사용했고, 연산자 버튼(더하기, 빼기 등)은 다음과 같이 제약 조건이 있는 버튼을 사용했습니다.\n\n```js\n    <Button\n        android:id=\"@+id/btnPlus\"\n        android:layout_width=\"70dp\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"+\"\n        app:layout_constraintTop_toBottomOf=\"@id/secondInput\"\n        app:layout_constraintStart_toStartOf=\"parent\">\n\n    </Button>\n\n    <Button\n        android:id=\"@+id/btnMinus\"\n        android:layout_width=\"70dp\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"-\"\n        app:layout_constraintEnd_toStartOf=\"@id/btnTimes\"\n        app:layout_constraintTop_toBottomOf=\"@id/secondInput\"\n        app:layout_constraintStart_toEndOf=\"@id/btnPlus\">\n\n    </Button>\n\n    <Button\n        android:id=\"@+id/btnTimes\"\n        android:layout_width=\"70dp\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"*\"\n        app:layout_constraintEnd_toStartOf=\"@id/btnDivide\"\n        app:layout_constraintTop_toBottomOf=\"@id/secondInput\"\n        app:layout_constraintStart_toEndOf=\"@id/btnMinus\">\n\n    </Button>\n\n    <Button\n        android:id=\"@+id/btnDivide\"\n        android:layout_width=\"70dp\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"/\"\n        app:layout_constraintTop_toBottomOf=\"@id/secondInput\"\n        app:layout_constraintStart_toEndOf=\"@id/btnTimes\"\n        app:layout_constraintEnd_toStartOf=\"@id/btnClear\">\n\n    </Button>\n\n    <Button\n        android:id=\"@+id/btnClear\"\n        android:layout_width=\"70dp\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"C\"\n        app:layout_constraintTop_toBottomOf=\"@id/secondInput\"\n        app:layout_constraintEnd_toEndOf=\"parent\"\n        android:backgroundTint=\"#FF0000\">\n    </Button>\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n좋아요, 레이아웃 작업을 마쳤으니 다음 단계로 진행해봐요. 그 전에 viewBinding을 사용하려면 build.gradle 파일에 something을 추가해야 해요.\n\n```js\n    buildFeatures {\n        viewBinding = true\n    }\n```\n\n그런 다음 MainActivity에서, 먼저 XML을 inflate하고 해당 TextView, EditText, Button과 같은 객체를 얻어와요.\n\n```js\nvar resultTv = binding.result;\nvar result: Double;\n\nvar firstInput = binding.firstInput;\nvar secondInput = binding.secondInput;\n\nvar plusButton = binding.btnPlus;\nvar minusButton = binding.btnMinus;\nvar timesButton = binding.btnTimes;\nvar divideButton = binding.btnDivide;\nvar clearButton = binding.btnClear;\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그럼 각각의 연산자에 기반한 계산을 도와주는 몇 가지 함수를 선언했습니다.\n\n```js\n    fun adding(a: Double, b : Double):Double{\n        return a + b\n    }\n\n    fun minus(a: Double, b : Double) : Double {\n        return a - b\n    }\n\n    fun times(a: Double, b : Double) : Double {\n        return a * b\n    }\n\n    fun divide(a: Double, b : Double) : Double {\n        if (b == 0.0){\n            throw IOException()\n        }\n        return a / b\n    }\n```\n\ndivide 함수를 보면, b가 영인지 여부를 확인하는 것을 볼 수 있습니다. 왜일까요? 그 이유는 b가 식 아래에있는 숫자이기 때문입니다 (나눗셈 연산에서 \"a\"를 \"b\"로 나눈 것은 a/b입니다) 그리고 우리는 0으로 a를 나눌 수 없습니다. 왜냐하면 이것은 오류를 반환할 것이기 때문입니다. 왜 오류가 발생하나요? 바로 아래 숫자가 0으로 접근하거나 b가 점점 작아질수록, 연산의 결과가 무한에 수렴하고 이것은 이 상황에서는 좋지 않습니다. 결론적으로 b가 영일 때, 이를 허용할 수 없으므로 이러한 경우를 처리하지 않으면 프로그램도 오류가 발생합니다. 그래서 b가 영인 경우마다 IOException을 throw 합니다.\n\n그 뒤에는 모든 버튼의 onClickListener를 처리합니다. 버튼이 눌릴 때마다 연산을 수행하고 싶습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n첫째로, 수학 연산에서 첫 번째 숫자나 두 번째 숫자가 0인지 확인됩니다. 둘 중 하나가 0이면 계산을 수행할 수 없습니다. 입력란이 비어있다고 0으로 간주하고 싶지 않기 때문에 이렇게 처리했습니다. 그런 다음 양쪽 숫자가 모두 null이 아닌 경우에만 연산을 계속할 수 있습니다. 이 경우에 null은 사용자가 숫자 입력란에 아무것도 넣지 않았음을 의미합니다.\n\n또한 roundToString() 함수도 있습니다. 이 함수는 무엇을 하는 걸까요?\n\n```js\n    fun Double.roundToString() = when {\n        toInt().toDouble() == this -> toInt()\n        else -> this\n    }.toString()\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nroundToString은 Double 클래스 라이브러리에 추가된 함수로, 소수점 뒤에 0이 있는 경우에만 double을 정수로 변환하는 기능을 제공합니다 (예: 0.0은 0으로 변환되고 1.2는 그대로 1.2로 유지됩니다).\n\n또한 roundOffDecimal() 함수가 있습니다.\n\n```kotlin\nfun roundOffDecimal(number: Double): Double {\n    val df = DecimalFormat(\"#.##\")\n    df.roundingMode = RoundingMode.FLOOR\n    return df.format(number).toDouble()\n}\n```\n\n이 함수는 숫자를 더 짧게 만듭니다. 예를 들어 1을 3으로 나눈 결과는 0.33333...이지만, 이 함수를 사용하면 결과가 0.33만 나오게 됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n테이블 태그를 마크다운 형식으로 변경해주세요.\n\n그리고 나누기 연산에서 IOException은 Toast를 이용해 catch했습니다.\n\n이제는 모두입니다. 이 프로젝트는 아직 초보적인 단계에 머물고 있습니다. 나중에 더 많은 기능을 추가할 예정이에요.\n\n나중에 봐요!\n","ogImage":{"url":"/assets/img/2024-06-22-CalculatorAppGojekEngineeringBootcampDayOne_0.png"},"coverImage":"/assets/img/2024-06-22-CalculatorAppGojekEngineeringBootcampDayOne_0.png","tag":["Tech"],"readingTime":8},{"title":"안드로이드에서 클린 아키텍처 구현하는 방법","description":"","date":"2024-06-22 22:42","slug":"2024-06-22-ImplementCleanArchitectureinAndroid","content":"\n![Software Architecture](/assets/img/2024-06-22-ImplementCleanArchitectureinAndroid_0.png)\n\n소프트웨어 아키텍처는 소프트웨어 작성을 위한 규칙 세트를 정의하며, 소프트웨어를 신뢰할 수 있고 확장 가능하게 구조화할 수 있도록 개발자를 지원합니다.\n\n이는 확장 가능성, 성능, 보안, 코드 축소 등과 같은 다양한 품질을 결정하고, 설계 위험을 분석하고 완화하는 데 도움이 됩니다. 소프트웨어 아키텍처는 설계 및 구현 팀을 위한 청사진 역할을 합니다.\n\n가장 널리 알려진 소프트웨어 아키텍처로는 다음이 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- MVC (Model-View-Controller)\n- MVP (Model-View-Presenter)\n- MVVM (Model-View-ViewModel)\n\n참고: MVVM 패턴은 시작하기에 좋지만 코드 복잡성이 증가할수록, 코드베이스 요구에 맞게 복잡성을 다룰 수있는 더 강력한 아키텍처가 필요합니다.\n\n이때 Clean Architecture가 등장합니다!\n\n# Clean Architecture\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nClean Architecture은 주로 관심사 분리에 초점을 맞춥니다. Clean Architecture를 따를 때 레이어의 수가 명시되어 있지는 않습니다. 필요에 따라 레이어를 추가할 수 있습니다. 원칙은 내부 레이어가 외부 레이어 중 어느 것도 참조해서는 안 되며, 중앙쪽으로 갈수록 세부 사항은 추상화되어야 합니다.\n\n상기 이미지에서 외부 레이어는 세부 구현을 포함하고 있으며, 내부 레이어는 추상화에 초점을 둡니다. 이 접근 방식은 비즈니스 레이어를 개발 중에 사용하는 실제 도구의 저수준 종속성으로부터 분리합니다.\n\n소프트웨어는 개발 도구(사용하는 하드웨어 및 데이터베이스 유형)를 변경해도 비즈니스 로직을 정의하는 코드에 영향을 미치지 않아야 합니다. Clean Architecture는 이러한 일반적인 아이디어에 기반합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n클린 아키텍처 레이어를 구면으로 상상해볼 수 있습니다. 중심으로 갈수록 희미해지죠. 중심에는 특정 작업이 어떻게 처리되는지에 대한 구체적인 세부 정보가 없습니다. 소프트웨어가 따라야 하는 규칙/정책을 정의하기만 합니다 (이것이 소프트웨어의 비즈니스 로직입니다).\n\n클린 아키텍처 책의 아래 댓글이 이 전체 포인트를 잘 요약하고 있습니다.\n\n## 의존성 규칙\n\n## 엔티티\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n각 요소들은 클래스, 객체, 데이터 구조 또는 결합을 통해 설명할 수 있는 업무 규칙입니다. 외부 레벨 세부사항(예: 작업 흐름)에 변화가 발생할 때, 이러한 규칙들이 가장 변경될 가능성이 적습니다.\n\n## 사용 사례\n\n사용 사례에는 응용 프로그램별 업무 규칙이 포함됩니다. 이러한 규칙들은 엔티티 레이어의 비즈니스 규칙을 응용프로그램별 운영 규칙으로 전환하는 데 도움을 줍니다.\n\n## 인터페이스 어댑터\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 레이어는 사용 사례의 데이터를 GUI 프레임워크, 웹 사용자 인터페이스 등과 같은 프레임워크 레이어에 사용할 수 있도록 변환합니다.\n\n## 프레임워크 및 드라이버\n\n일반적으로 이 레이어에서는 주로 사용된 프레임워크 및 데이터베이스의 가장 외부의 상세 구현으로 코드를 작성할 필요가 없습니다.\n이 레이어에는 대부분 내부 레이어에서의 코드를 연결하는 코드가 포함되어 있으며, 데이터를 가져오고 표현을 위해 변환하는 방법을 정의합니다.\n\n## 클린 아키텍처의 장점\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 시스템 변경을 쉽게합니다.\n- 비즈니스 로직은 코드베이스의 다른 레이어와 완전히 분리되어 있으며, 다른 레이어는 비즈니스 규칙에 의존하므로 시스템에 기능을 추가/업데이트하기 쉬워집니다.\n- 코드는 디커플링되어 각 레이어를 블랙 박스로 다룰 수 있어 코드 테스트에 도움이 됩니다.\n- 각 모듈은 세부 사항이 아닌 목적을 정의합니다. 이는 기술적 세부 사항에 심취하지 않고 앱이 무엇을 하는지 이해하는 데 도움이 됩니다.\n\n## Clean Architecture의 단점\n\n- 단순 프로젝트에는 선호되지 않습니다. 프로젝트가 복잡하지 않다면, 단순한 아키텍처(MVC 또는 순수 MVVM)로 달성할 수 있는 파일을 불필요하게 만들고 코드를 작성하게 됩니다.\n- 학습 곡선이 가파릅니다.\n- 책임을 적절한 레이어로 나누는 방법을 이해하는 것은 이 아키텍처에서 각 레이어가 어떻게 작동하는지 명확한 개념이 없다면 지루할 수 있습니다.\n\n# Clean Architecture으로 안드로이드 개발하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n안녕하세요! 안드로이드 플랫폼에서 간단한 TODO 앱을 클린 아키텍처로 만들었어요. 완성된 코드는 GitHub에서 확인할 수 있어요.\n\nTODO 앱을 클린 아키텍처로 만드는 것은 아키텍처의 모든 측면을 다루는 것은 아니라는 점을 유의해 주세요.\n\n기본 구현을 이해하고 더 복잡한 기능으로 나아가는 것이 중요한 포인트에요.\n\n이 방법으로 사용된 레이어 구조는 다음과 같아요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/assets/img/2024-06-22-ImplementCleanArchitectureinAndroid_2.png)\n\n동일한 계층 구조가 디렉토리 구조에 반영됩니다.\n\n계층 구조는 구현에 따라 다를 수 있습니다. 그러나 코드 베이스를 구성할 때는 누가 누구에게 의존하는지에 중점을 두어야 합니다.\n\n코드 구조에 복잡성과 차이점을 고려하여 레이어를 추가할 수 있습니다. Clean Architecture에는 몇 개의 레이어가 있어야 하는지에 대한 엄격한 규칙은 없습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n마크다운 포맷으로 표 태그를 변경하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n도메인 계층은 응용 프로그램/모듈 개념을 설명하는 핵심 엔티티로 구성됩니다. 이러한 엔티티는 외부 계층과 독립적이며 외부 계층(데이터, 유스 케이스 등)에서 언급해서는 안됩니다.\n\n여기에는 작업(Task)이라는 기본 작업과 해당 속성을 정의하는 엔티티가 있습니다.\n\n## 데이터\n\n이 계층은 데이터와의 상호 작용을 정의합니다. 데이터 작업을 정의하기 위해 TaskDataSource를 사용합니다. 그런 다음 여러 데이터 소스를 하나의 리포로 결합하고 리포지토리를 통해 데이터에 액세스하도록 TaskRepository를 정의했습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여기서는 단일 데이터 원본만 사용합니다. 기본적으로 TaskDataSource와 TaskRepository 메소드와 일대일 매핑되어 있어 처음봤을 때는 중복된 것처럼 보일 수 있습니다. 그러나 애플리케이션이 확장되고 인터넷에서 데이터를 다운로드하거나 로컬 데이터베이스 또는 사용자 파일에 저장된 데이터와 같이 여러 위치에서 데이터 소스를 가질 때 리포지토리 패턴이 유용할 수 있습니다.\n\nTaskRepository는 아래에서 논의된 유스케이스에서 사용되고 있습니다.\n\n## 유스케이스\n\n이 계층은 데이터를 처리할 수 있는 작업을 정의하고 사용 사례를 형성합니다. 프레젠테이션 계층은 직접 이러한 유스케이스를 사용하여 데이터를 표시하거나 조작합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n해당 데이터에 대해 다양한 작업을 수행하기 위해 정의된 사용 사례들이 있습니다:\n\n![Use Cases](/assets/img/2024-06-22-ImplementCleanArchitectureinAndroid_5.png)\n\n## 프레임워크\n\n이 레이어는 데이터 레이어에서 정의된 데이터 소스를 구현하고 플랫폼별 구현을 제공합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저희 구현에서는 TaskDataSourceImpl을 통해 Room 데이터베이스를 사용하여 TaskDataSource를 구현했습니다.\n\n## 프레젠테이션\n\n이 계층은 코드에서 표시 로직을 정의하고 플랫폼별 뷰가 데이터를 사용자에게 제시하는 방식을 정의합니다. 여기에는 사용 사례 계층에 정의된 사용 사례를 호출하고 안드로이드 뷰를 사용하여 그것들을 사용자에게 제시하는 뷰 모델이 있습니다.\n\n그게 다입니다!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 마무리\n\n안드로이드 개발에서 Clean Architecture의 개념과 구현 방법에 대해 명확해졌기를 바라요.\n\nGitHub에서 샘플 TODO 앱의 전체 코드를 찾을 수 있어요. 코드 구조에 대한 제안이 있으면 PR을 제출해주세요. 기여해 주실 것을 환영합니다.\n\n즐거운 코딩 되세요!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n참고문헌\n","ogImage":{"url":"/assets/img/2024-06-22-ImplementCleanArchitectureinAndroid_0.png"},"coverImage":"/assets/img/2024-06-22-ImplementCleanArchitectureinAndroid_0.png","tag":["Tech"],"readingTime":9},{"title":"안드로이드에서 커스텀 애노테이션을 사용해야 할 때 Part 3","description":"","date":"2024-06-22 22:41","slug":"2024-06-22-WhentoUseCustomAnnotationsinAndroidPart3","content":"\n![이미지](/assets/img/2024-06-22-WhentoUseCustomAnnotationsinAndroidPart3_0.png)\n\n친구야! 안드로이드에서 사용자 정의 주석을 더 멋지고 고급스럽게 활용해보자. 커피 한 잔 마시면서 아이디어를 얘기하는 것처럼 재미있는 예제로 안내해 드릴게요.\n\n# 4. 자동화된 문서화\n\n만약 코드가 스스로 문서를 작성할 수 있다면 어떨까요! 주석이 그렇게 도와줄 수 있어요. 메서드가 무엇을 하는지 설명하는 주석을 만들고 해당 주석을 사용하여 문서를 생성해보세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n먼저, 우리는 주석을 정의합니다:\n\n```kotlin\n@Target(AnnotationTarget.FUNCTION)\n@Retention(AnnotationRetention.RUNTIME)\nannotation class Doc(val description: String)\n```\n\n그런 다음, 이 주석을 우리의 클래스에서 사용합니다:\n\n```kotlin\nclass DocumentedClass {\n\n    @Doc(description = \"이 메서드는 무거운 계산을 수행합니다.\")\n    fun heavyComputation() {\n        Thread.sleep(1000)\n        println(\"무거운 계산 완료!\")\n    }\n\n    @Doc(description = \"이 메서드는 가벼운 계산을 수행합니다.\")\n    fun lightComputation() {\n        Thread.sleep(500)\n        println(\"가벼운 계산 완료!\")\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제, 이러한 주석을 기반으로 문서를 생성하는 프로세서를 만들어 봅시다:\n\n```js\nobject DocumentationGenerator {\n\n    fun generateDocumentation(obj: Any) {\n        val methods = obj::class.java.declaredMethods\n        for (method in methods) {\n            method.getAnnotation(Doc::class.java)?.let {\n                println(\"${method.name}: ${it.description}\")\n            }\n        }\n    }\n}\n\nfun main() {\n    val documentedClass = DocumentedClass()\n    DocumentationGenerator.generateDocumentation(documentedClass)\n}\n```\n\n이 코드를 실행하면, 주석이 달린 메소드의 설명을 출력합니다. 와우! 자동화된 문서를 얻었습니다.\n\n# 5. 런타임 처리\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n앱에서 기능을 동적으로 전환하고 싶다면 사용자 지정 주석을 활용하여 쉽게 관리할 수 있습니다.\n\n기능 토글을 위한 주석을 정의하세요:\n\n```kotlin\n@Target(AnnotationTarget.FUNCTION)\n@Retention(AnnotationRetention.RUNTIME)\nannotation class FeatureToggle(val featureName: String)\n```\n\n이를 클래스 내에서 사용하여 메서드를 표시하세요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\nclass FeatureClass {\n\n    @FeatureToggle(\"FeatureA\")\n    fun featureAMethod() {\n        println(\"Feature A is enabled!\")\n    }\n\n    @FeatureToggle(\"FeatureB\")\n    fun featureBMethod() {\n        println(\"Feature B is enabled!\")\n    }\n}\n```\n\n이러한 주석을 처리하는 프로세서를 생성합니다:\n\n```kotlin\nobject FeatureToggleProcessor {\n\n    private val enabledFeatures = setOf(\"FeatureA\")\n\n    fun processFeatures(obj: Any) {\n        val methods = obj::class.java.declaredMethods\n        for (method in methods) {\n            method.getAnnotation(FeatureToggle::class.java)?.let {\n                if (enabledFeatures.contains(it.featureName)) {\n                    method.invoke(obj)\n                } else {\n                    println(\"Feature ${it.featureName} is disabled\")\n                }\n            }\n        }\n    }\n}\n\nfun main() {\n    val featureClass = FeatureClass()\n    FeatureToggleProcessor.processFeatures(featureClass)\n}\n```\n\n이 설정으로 핵심 로직을 수정하지 않고 기능을 동적으로 활성화 또는 비활성화할 수 있습니다. 멋지지 않나요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 6. 다양한 사용 사례 다루기\n\n사용자 지정 어노테이션은 응용 프로그램에서 권한 및 역할을 처리하는 데도 효과적입니다. 역할 기반 액세스 제어를 위한 어노테이션을 만들어 보겠습니다.\n\n어노테이션 정의:\n\n```js\n@Target(AnnotationTarget.FUNCTION)\n@Retention(AnnotationRetention.RUNTIME)\nannotation class RequiresRole(val role: String)\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n필요한 역할에 주석을 달아주세요:\n\n```js\nclass RoleClass {\n\n    @RequiresRole(\"Admin\")\n    fun adminTask() {\n        println(\"Admin task executed!\")\n    }\n\n    @RequiresRole(\"User\")\n    fun userTask() {\n        println(\"User task executed!\")\n    }\n}\n```\n\n권한을 확인하는 역할 프로세서를 생성해보세요:\n\n```js\nobject RoleProcessor {\n\n    private val currentRole = \"Admin\"\n\n    fun processRoles(obj: Any) {\n        val methods = obj::class.java.declaredMethods\n        for (method in methods) {\n            method.getAnnotation(RequiresRole::class.java)?.let {\n                if (currentRole == it.role) {\n                    method.invoke(obj)\n                } else {\n                    println(\"Access denied for ${it.role}\")\n                }\n            }\n        }\n    }\n}\n\nfun main() {\n    val roleClass = RoleClass()\n    RoleProcessor.processRoles(roleClass)\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 사용자가 올바른 역할을 가지고 있을 때만 귀하의 메서드가 실행됩니다. 더 이상 코드 전체에 흩어진 역할 확인 코드가 없습니다!\n\n# 마무리\n\n자, 안드로이드에서 커스텀 어노테이션에 대한 고급이면서도 매우 유용한 케이스들을 다뤘습니다. 자동 문서화 생성 및 런타임에서의 기능 토글부터 역할 기반 액세스 관리까지, 커스텀 어노테이션을 사용하면 코드가 더 깔끔하고 유지보수하기 쉬우며 더 재미있게 작업할 수 있습니다.\n\n더 궁금한 사항이 있거나 다른 멋진 주제에 대해 알아보고 싶다면 언제든지 말씀해주세요. 즐거운 코딩 하시고, 계속해서 어노테이션을 즐기세요! 😊\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n4를 어떻게 도와드릴까요?\n","ogImage":{"url":"/assets/img/2024-06-22-WhentoUseCustomAnnotationsinAndroidPart3_0.png"},"coverImage":"/assets/img/2024-06-22-WhentoUseCustomAnnotationsinAndroidPart3_0.png","tag":["Tech"],"readingTime":7},{"title":"KotlinConf 2024에서 공개된 Kotlin 20 언어 기능 새로운 점과 앞으로 기대할 점","description":"","date":"2024-06-22 22:39","slug":"2024-06-22-Kotlin20LanguageFeaturesfromKotlinConf2024WhatsNewandWhatsNext","content":"\n<img src=\"/assets/img/2024-06-22-Kotlin20LanguageFeaturesfromKotlinConf2024WhatsNewandWhatsNext_0.png\" />\n\n2024년 KotlinConf에서 JetBrains의 주요 언어 디자이너인 Michail Zarečenskij가 Kotlin의 최신 언어 기능을 소개했습니다. 그의 발표를 기반으로 한 이 기사는 Kotlin 2.0의 주요 업데이트를 강조하고 향후 릴리스에서의 흥미로운 기능을 미리 보여줍니다.\n\n계속 읽어보시면 Kotlin 언어에서 새로운 기능과 다가올 내용을 발견할 수 있습니다.\n\n# Kotlin 2.0 기능 요약\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 1. 명시적 백킹 필드\n\nKotlin 2.0에서 소개된 주목할만한 기능 중 하나는 명시적 백킹 필드입니다. 이 기능은 K2 컴파일러 미리보기의 일부로 버전 1.7.0부터 있었으며, 현재 Kotlin 2.0에서 실험적인 기능입니다.\n\n이 기능을 이해하기 위해, 가장 익숙하고 안드로이드 프로젝트에서 매우 인기 있는 몇 가지 코드를 살펴보겠습니다:\n\n```js\nclass MyViewModel {\n    private val _title = MutableStateFlow<String>(\"Placeholder\")\n    val title: StateFlow<String> get() = _title\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 예시에서는 title 상태가 캡슐화되어 있어서 ViewModel만 상태를 수정할 수 있고 나머지 애플리케이션에는 읽기 전용 버전이 노출됩니다.\n\nKotlin 2.0에서는 명시적 백킹 필드를 사용하여 더 간결하고 우아하게 이를 달성하는 방법이 있습니다:\n\n```js\nclass MyViewModel {\n    val title: StateFlow<String>\n        field = MutableStateFlow<String>(\"Placeholder\")\n}\n```\n\n이 새로운 구문은 title 속성에 대한 명시적 백킹 필드를 선언하여 보일러플레이트 코드를 줄이고 가독성을 향상시킵니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n미래의 Kotlin 버전에서는 명명된 명시적 백킹 필드와 같은 이 기능에 대한 업데이트가 포함될 예정이라는 사실을 언급하는 것도 좋습니다. 아래는 이 기능이 어떻게 보일지 예시입니다:\n\n```kotlin\nclass MyViewModel {\n    val title: StateFlow<String>\n        field mutableTitle = MutableStateFlow<String>(\"Placeholder\")\n}\n```\n\n## 2. 연산자 결합 및 숫자 변환\n\nK2 컴파일러는 Frontend Intermediate Representation (FIR)이라고 불리는 것을 도입합니다. 이를 통해 컴파일러 및 IDE 성능이 향상되어 더 빠른 컴파일과 정확한 오류 메시지를 제공합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nFIR로 인한 사용자에게 보이는 변경 중 하나는 \"연산자 및 숫자 변환의 결합\"입니다. 이 기능은 숫자 유형을 포함한 작업을 간소화하여 명시적인 유형 변환의 필요성을 줄입니다.\n\n예를 들어:\n\n```js\nfun foo(longs: MutableList<Long>) {\n    longs[0] += 1 // 이것은 Kotlin 1.x에서 오류가 발생하지만, Kotlin 2.0에서는 정상적으로 작동합니다.\n}\n```\n\nKotlin 1.x에서 위 코드는 1이 명시적으로 Long이 아니기 때문에 오류가 발생합니다. 1L을 대신 사용해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n코틀린 2.0에서는 longs[0] += 1이 longs.set(0, longs.get(0).plus(1))로 분해되기 때문에 정상적으로 작동합니다.\n\n## 3. 널 가능 연산자 호출의 조합\n\n이 기능은 K2 컴파일러에서 소개된 새로운 FIR과 관련이 있습니다.\n\n이를 설명하기 위해 다음 예시를 살펴보겠습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\nclass Box(val longs: MutableList<Long>)\n\nfun foo(box: Box?) {\n    box?.longs[0] += 1 // Kotlin 1.x에서 오류 발생\n    box?.longs[0] += 1L // Kotlin 1.x에서도 오류 발생\n}\n```\n\nKotlin 1.x에서는 longs의 첫 번째 요소를 증가시키는 두 줄 모두 오류가 발생합니다.\n\n그러나 Kotlin 2.0에서는 box?.longs[0] += 1을 사용하면 어떤 문제도 발생하지 않습니다. 왜냐하면 이 코드는 box?.run ' longs.set(0, longs.get(0).plus(1)) '으로 변환되기 때문입니다.\n\n## 4. 더 똑똑해진 스마트 캐스트 (좋아요!)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nK2에서는 새로운 제어 플로 엔진이 소개되어 타입 추론 및 해결에서 상당한 개선이 이루어졌어요. 이 새로운 제어 플로 엔진 덕분에 여러 가지 새로운 기능을 사용할 수 있게 됐어요.\n\n간단한 코드 예시를 살펴보죠:\n\n```js\nclass Phone {\n    fun ring() {\n        println(\"벨이 울립니다...\")\n    }\n}\n\nfun makeNoise(device: Any) {\n    if (device is Phone) {\n        device.ring()\n    }\n}\n```\n\n이 코드는 간단합니다. device가 Phone인지 확인한 후에 device 객체가 Phone으로 스마트 캐스트되어 ring 메서드를 안전하게 호출할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그러나 makeNoise 함수를 약간 수정하고 다음과 같이 새로운 isPhone 변수를 도입하면:\n\n```js\nfun makeNoise(device: Any) {\n    val isPhone = device is Phone\n    if (isPhone) {\n        device.ring() // Kotlin 1.x에서는 여기서 오류 발생\n    }\n}\n```\n\nKotlin 1.x에서는 지역 변수가 데이터 흐름 정보를 전달하지 않고 스마트 캐스트 로직에 기여하지 않기 때문에 오류가 발생합니다. 이로 인해 우리는 device 객체의 ring 메서드를 호출할 수 없습니다.\n\n그러나 Kotlin 2.0에서는 이 코드가 예상대로 작동합니다. 이제 로컬 변수가 스마트 캐스트에 대한 정보를 전파하기 때문에 ring 메서드를 호출할 수 있습니다!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n모든 일반적인 스마트 캐스트 규칙에 해당하는 것을 유의해야 합니다. 계약을 포함하여 예를 들어:\n\n```js\nclass Card(val holderName: String?)\n\nfun foo(card: Any): String {\n    val hasHolderName = card is Card && !card.holderName.isNullOrBlank()\n    return when {\n        hasHolderName -> card.holderName\n        else -> \"Unknown\"\n    }\n}\n```\n\n여기에는 두 개의 스마트 캐스트가 있습니다. card 객체는 Card로 스마트 캐스트되고, holderName은 String?에서 String으로 스마트 캐스트됩니다.\n\n또한, Kotlin 2.0에서 해결된 스마트 캐스트와 관련된 여러 버그가 있었습니다. 이 글에서는 이러한 개선 사항에 대해 자세히 다루지는 않겠지만, 이곳에서 더 많은 정보를 읽을 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 5. Smart Casts After ||\n\nKotlin 2.0의 새로운 데이터 플로 엔진에서 제공되는 개선 사항을 기반으로, 논리 || 연산자 이후에 스마트 캐스트를 도입한 또 다른 기능이 있습니다.\n\n이 기능을 설명하기 위해 예를 살펴보겠습니다:\n\n```js\ninterface Action {\n    fun execute()\n}\n\ninterface None : Action\ninterface Send : Action\ninterface Receive : Action\n\nfun demo(action: Any) {\n    if (action is Send || action is Receive) {\n        action.execute() // Kotlin 1.x에서는 작동하지 않습니다\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n친구야,\n\nKotlin 1.x에서는 이 코드가 컴파일되지 않습니다. || 연산자 이후에 스마트 캐스트를 수행하지 않기 때문에 execute 함수를 호출할 수 없기 때문입니다.\n\n그러나 Kotlin 2.0에서는 컴파일러가 공통 상위 유형을 인식하고 Action으로 스마트 캐스트를 수행하여 문제없이 execute를 호출할 수 있게 됩니다.\n\n## 6. 인라인 람다의 클로저 내에서 스마트 캐스트\n\nKotlin 2.0의 새 데이터 플로 엔진과 관련된 스마트 캐스트와 인라인 람다의 클로저에서 캡처된 지역 변수에 대한 스마트 캐스트를 수행할 수 있는 기능이 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음은 정수 배열에서 최댓값의 인덱스를 찾는 코드입니다:\n\n```kotlin\nfun indexOfMax(numbers: IntArray): Int? {\n    var maxIndex: Int? = null\n    numbers.forEachIndexed { i, number ->\n        // Kotlin 1.x에서는 여기서 Int?에서 Int로의 스마트 캐스트가 불가능합니다.\n        // 왜냐하면 'maxIndex'가 변하는 클로저에 의해 캡처된 로컬 변수이기 때문입니다.\n        if (maxIndex == null || numbers[maxIndex!!] <= number) {\n            maxIndex = i\n        }\n    }\n    return maxIndex\n}\n```\n\nKotlin 1.x에서는 Int?에서 Int로의 스마트 캐스트가 불가능합니다. 이는 'maxIndex'가 변하는 클로저에 의해 캡처된 로컬 변수이기 때문입니다. 이에 대한 설명은 이 Stack Overflow 답변을 참조하십시오.\n\nKotlin 2.0은 인라인 함수를 암묵적으로 callsInPlace 계약이 있는 것으로 취급하여 이 문제에 대응합니다. 본질적으로 컴파일러는 람다를 보다 일반적인 for 루프처럼 다룰 수 있어 람다 내에서 스마트 캐스트를 활성화합니다. 이로써 느낌표(!!)를 제거할 수 있으며 이제 maxIndex가 Int로 스마트 캐스트되었기 때문에입니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\nfun indexOfMax(numbers: IntArray): Int? {\n    var maxIndex: Int? = null\n    numbers.forEachIndexed { i, number ->\n        // 코틀린 2.0에서는 명시적인 !!를 제거할 수 있습니다.\n        if (maxIndex == null || numbers[maxIndex] <= number) {\n            maxIndex = i\n        }\n    }\n    return maxIndex\n}\n```\n\n# Kotlin의 미래 기능\n\nKotlin 2.0의 새로운 기능을 탐색했는데, 앞으로 나올 Kotlin의 릴리스에서 기대되는 흥미로운 기능을 간단히 살펴보겠습니다.\n\n## 1. When 문에서의 가드 조건\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n미래의 Kotlin 릴리스에서 나올 흥미로운 기능 중 하나는 guards 기능입니다. 이 기능을 사용하면 when 문의 분기에 직접 조건을 추가할 수 있어서 코드를 더 간결하게 만들 수 있습니다.\n\n다음 예시를 살펴보세요:\n\n```js\nsealed interface SearchResult {\n    class Person(val isBlocked: Boolean) : SearchResult\n    class Post(/* ... */) : SearchResult\n    class Place(/* ... */) : SearchResult\n}\n\n@Composable\nfun SearchResultListItem(searchResult: SearchResult) {\n    when (searchResult) {\n        is SearchResult.Person -> when {\n            !searchResult.isBlocked -> { /* ... */ }\n        }\n        is SearchResult.Post -> { /* ... */ }\n        is SearchResult.Place -> { /* ... */ }\n    }\n}\n```\n\n이 코드는 꽤 간단하지만 searchResult가 여러 번 반복됩니다. 따라서 더 간결하게 만들기 위해 반복되는 searchResult를 제거하고 subject로 searchResult를 사용하는 when 문을 사용할 수 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\n@Composable\nfun SearchResultItem(searchResult: SearchResult) {\n    when (searchResult) {\n        is SearchResult.Person && !searchResult.isBlocked -> { /* ... */ }\n        is SearchResult.Post -> { /* ... */ }\n        is SearchResult.Place -> { /* ... */ }\n    }\n}\n```\n\n그러나 이 방식은 && 연산자를 사용할 수 없기 때문에 오류가 발생합니다.\n\n가드(guard)를 사용하면 주어진 하위 표현식에 조건을 추가하기 위한 우아한 방법을 제공하여 이 문제를 해결할 수 있습니다:\n\n```kotlin\n@Composable\nfun SearchResultItem(searchResult: SearchResult) {\n    when (searchResult) {\n        is SearchResult.Person if !searchResult.isBlocked -> { /* ... */ }\n        ...\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n카틴 2.1에서 가드가 베타로 나올 때입니다.\n\n## 2. 컨텍스트 민감한 해결\n\n이전 예제를 기반으로 하여, when 가드로 코드를 보다 간결하게 만들었지만 여전히 SearchResult 클래스 이름을 각 when 분기에서 반복해야 합니다.\n\n컨텍스트 민감한 해결을 통해 반복되는 SearchResult를 제거하여 코드를 더 간결하게 만들 수 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\n@Composable\nfun SearchResultItem(searchResult: SearchResult) {\n    when (searchResult) {\n        is Person && !searchResult.isBlocked -> { /* ... */ }\n        is Post -> { /* ... */ }\n        is Place -> { /* ... */ }\n    }\n}\n```\n\n이 기능은 sealed 타입 및 열거형의 인스턴스와 함께 작동합니다. 이것은 코드를 더 깔끔하고 간결하게 만듭니다.\n\n컨텍스트에 민감한 해결책은 코틀린 2.2에서 실험적 기능으로 제공됩니다.\n\n## 3. 이름 기반 구조 분해\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n현재 Kotlin의 해체 선언 기능은 임의의 변수 이름 사용을 허용합니다.\n\n예를 들어, 다음 코드를 살펴보세요:\n\n```js\ndata class User(val firstName: String, val lastName: String)\n\nfun handleUser(user: User) {\n    val (surname, someName) = user\n    // ...\n}\n```\n\n여기서는 User 데이터 클래스의 속성을 surname과 someName과 같은 임의의 이름으로 해체하고 있습니다. 이러한 방식은 컴파일러가 수용하지만 안전하지 않을 수 있으며, 실제 속성을 정확하게 반영하지 않아 버그를 유발할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n앞으로의 Kotlin 버전에서는 해체 선언에 임의의 이름을 사용하는 것을 경고하고, 마침내 오류로 만들어가며 이에 대응하게 될 것입니다.\n또한, 해체된 속성에 새 이름을 할당하는 특별한 구문이 도입될 예정이며, 더 안전하고 예측 가능한 코드를 보장할 것입니다.\n\n## 4. 확장 가능한 데이터 인수\n\n앞으로의 Kotlin 버전에 추가될 또 다른 강력한 기능은 확장 가능한 데이터 인수입니다.\n\n이 기능을 이해하기 위해 Compose의 LazyColumn 함수를 살펴봅시다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\n@Composable\nfun LazyColumn(\n    modifier: Modifier = Modifier,\n    state: LazyListState = rememberLazyListState(),\n    contentPadding: PaddingValues = PaddingValues(0.dp),\n    reverseLayout: Boolean = false,\n    verticalArrangement: Arrangement.Vertical = if (!reverseLayout) Arrangement.Top else Arrangement.Bottom,\n    horizontalAlignment: Alignment.Horizontal = Alignment.Start,\n    flingBehavior: FlingBehavior = ScrollableDefaults.flingBehavior(),\n    userScrollEnabled: Boolean = true,\n    content: LazyListScope.() -> Unit\n)\n```\n\n만약 Compose에 익숙하지 않다면, LazyColumn 함수를 사용하면 필요할 때만 로드되는 항목들의 게으른 목록을 표시할 수 있습니다. 많은 수의 항목을 효율적으로 표시하는 데 특히 유용합니다.\n\n대부분의 UI 함수와 마찬가지로, LazyColumn에도 동작을 수정하는 여러 인수가 있습니다. 그러나 함수가 변경되고 새로운 매개변수가 추가되면 문제가 발생합니다. 바이너리 호환성을 유지하기 위해 함수의 다른 오버로드(이 경우 LazyColumn)가 추가되어 코드와 설명이 중복됩니다.\n\n![image](/assets/img/2024-06-22-Kotlin20LanguageFeaturesfromKotlinConf2024WhatsNewandWhatsNext_1.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n확장 가능한 데이터 인수가 등장하는 곳입니다. 이를 통해 기본값을 갖는 인수를 데이터 인수 클래스로 이동하여 함수 서명을 간단하게 만들고 소스와 이진 호환성을 유지할 수 있습니다:\n\n```js\ndataarg class LazyColumnSettings(\n    val contentPadding: PaddingValues = PaddingValues(0.dp),\n    val reverseLayout: Boolean = false,\n    val verticalArrangement: Arrangement.Vertical = if (!reverseLayout) Arrangement.Top else Arrangement.Bottom,\n    val horizontalAlignment: Alignment.Horizontal = Alignment.Start,\n    val flingBehavior: FlingBehavior = ScrollableDefaults.flingBehavior(),\n    val userScrollEnabled: Boolean = true,\n)\n```\n\n이후 LazyColumn 함수는 다음과 같습니다:\n\n```js\n@Composable\nfun LazyColumn(\n    modifier: Modifier = Modifier,\n    state: LazyListState = rememberLazyListState(),\n    dataarg settings: LazyColumnSettings,\n    content: LazyListScope.() -> Unit\n)\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n`LazyColumn`의 호출 위치에서 이제 `LazyColumn(reverseLayout = true)`를 사용할 수 있습니다. 해당 매개변수는 `LazyColumnSettings`의 인스턴스로 변환될 것입니다.\n\n확장 가능한 데이터 매개변수는 실험적인 기능으로 Kotlin 2.2에 추가될 예정입니다.\n\n## 5. 오류를 위한 Union 타입\n\n이는 향후 Kotlin 버전에서 추가될 또 다른 유망한 기능입니다.\n이 기능을 설명하기 위해, Sequence의 `last()` 확장 함수를 살펴봅시다. 이 함수는 주어진 조건과 일치하는 Sequence의 마지막 요소를 반환합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\ninline fun <T> Sequence<T>.last(predicate: (T) -> Boolean): T {\n    var last: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Sequence contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return last as T\n}\n```\n\nMichail Zarečenskij씨의 이 발표에서는 이 구현의 두 가지 단점을 지적했습니다. ' it == null '이 되는 경우를 처리하는 found 변수의 사용과 함수 끝 부분의 unchecked 캐스트입니다.\n그는 그 후에 private object NotFound를 사용하는 해결책을 제안했습니다:\n\n```kotlin\nprivate object NotFound\n\ninline fun <T> Sequence<T>.last(predicate: (T) -> Boolean): T {\n    var result: Any? = NotFound\n    for (element in this) {\n        if (predicate(element)) result = element\n    }\n    if (result === NotFound) throw NoSuchElementException(\"Sequence contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return result as T\n}\n```\n\n이 방법은 더 나아 보이지만 제네릭 유형 Any?을 사용하고 마지막 부분의 unchecked 캐스트를 제거하지 않습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이곳은 오류에 대한 연합 유형이 필요한 곳입니다. 이것은 향후 코틀린 기능으로 우리가 이렇게 작성할 수 있게 해줄 것입니다:\n\n```js\nprivate error object NotFound\n\ninline fun <T> Sequence<T>.last(predicate: (T) -> Boolean): T {\n    var result: T | NotFound = NotFound // 오류에 대한 연합 유형.\n    for (element in this) {\n        if (predicate(element)) result = element\n    }\n    if (result is NotFound) throw NoSuchElementException(\"Sequence contains no element matching the predicate.\")\n    return result // T로의 자동 형변환.\n}\n```\n\n이 코드는 결과 변수에 대한 연합 유형을 사용하여 일반적인 Any? 유형이 필요 없게 합니다. 또한 컴파일러는 우리를 위해 스마트 캐스트를 수행하므로 더 이상 검사되지 않은 형변환이 필요하지 않습니다. 멋지죠!\n\n# 마무리맺음\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이러한 새로운 기능들로 Kotlin은 계속 발전하며 현대 프로그래밍 언어가 제공할 수 있는 영역을 넓히고 있습니다. Kotlin을 사용하면 개발이 더욱 효율적이고 즐거워집니다.\n이외에도 상세 내용이 제공되지 않은 다른 기능들이 언급되었습니다. Kotlin 팀이 이후에 관련 정보를 더 제공할 때까지 기다려야 할 것입니다.\n\n읽어 주셔서 감사합니다! 아래 댓글란에 의견을 자유롭게 남겨 주세요.\n\n이 기사가 마음에 드셨다면 클랩(좋아요)을 눌러 주시고 안드로이드 개발에 관한 더 많은 내용을 제공하는 저를 팔로우해 주세요.\n","ogImage":{"url":"/assets/img/2024-06-22-Kotlin20LanguageFeaturesfromKotlinConf2024WhatsNewandWhatsNext_0.png"},"coverImage":"/assets/img/2024-06-22-Kotlin20LanguageFeaturesfromKotlinConf2024WhatsNewandWhatsNext_0.png","tag":["Tech"],"readingTime":19},{"title":"안드로이드 주니어 개발자가 되는 법 초보자를 위한 가이드","description":"","date":"2024-06-22 22:38","slug":"2024-06-22-BecomingAndroidJuniorDeveloper","content":"\n안드로이드 앱 개발의 세계는 지속적으로 진화하고 있으며, 모바일 앱에 대한 수요가 계속 증가함에 따라 이 흥미로운 분야로 진입하기에 더 좋은 때는 없습니다. 안드로이드 주니어 개발자가 되기를 희망하는 경우, 여기에 여러분이 여정을 탐험하고 성공을 위해 스스로를 설정하는 데 도움이 되는 포괄적인 안내서가 있습니다.\n\n![BecomingAndroidJuniorDeveloper_0.png](/assets/img/2024-06-22-BecomingAndroidJuniorDeveloper_0.png)\n\n## 안드로이드 주니어 개발자로서 기대할 수 있는 것은?✍🏻\n\n안드로이드 주니어 개발자로서, 당신은 경험 많은 개발자들과 협력하여 아이디어를 현실로 만드는 데 중요한 역할을 맡을 것입니다. 여러분의 책임은 다음과 같을 수 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 깨끗하고 유지보수 가능한 코드를 작성하며 최상의 실천 방법과 코딩 규칙을 준수합니다.\n- XML 및 Android UI 프레임워크를 사용하여 UI 구성 요소를 구현합니다.\n- API를 소비하여 데이터를 가져와 애플리케이션에 통합합니다.\n- 응용 프로그램을 테스트하고 디버깅하여 올바로 작동하고 원활하게 작동하는지 확인합니다.\n- 팀원과 협력하여 전체 개발 프로세스에 기여합니다.\n\n## 안드로이드 주니어 개발자를 위한 필수 기술과 지식 📝\n\n안드로이드 주니어 개발자로서 뛰어나기 위해 다음 분야의 견고한 기초를 갖추어야 합니다:\n\n- 프로그래밍 기초: 변수, 데이터 유형, 연산자, 제어 흐름문 및 함수 등 프로그래밍의 핵심 개념 이해\n- Kotlin: 안드로이드 개발을 위한 주요 프로그래밍 언어인 Kotlin에 숙련되어야 함\n- Android SDK: 활동, 뷰, 레이아웃 및 인텐트와 같은 Android 소프트웨어 개발 키트(SDK) 및 구성 요소 이해\n- XML: 안드로이드 앱에서 레이아웃 및 리소스를 정의하기 위한 XML에 대한 친숙함\n- UI 디자인 원칙: 직관적이고 사용자 친화적 인터페이스를 만들기 위한 UI 디자인 원칙 이해\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 안드로이드 주니어 개발자로서 기술을 향상하는 방법은? 🤔\n\n지속적인 연습: 안드로이드 개발을 숙달하기 위해서는 꾸준한 실습이 필수적입니다. 개인 프로젝트에 참여하거나 오픈소스 프로젝트에 기여하거나 코딩 챌린지에 참여하세요.\n\n최신 정보 습득: 안드로이드 환경은 끊임없이 진화하고 있습니다. 최신 SDK 릴리스, 라이브러리 및 모범 사례에 대해 항상 최신 정보를 유지하세요.\n\n고급 주제 탐구: 자신감을 얻으면 멀티스레딩, 네트워킹, 성능 최적화와 같은 고급 안드로이드 개념에 집중해보세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n멘토 찾기: 경험이 풍부한 안드로이드 개발자를 찾아 안내를 받고 피드백을 받으며 도전을 극복하는 데 도움을 받으세요.\n\n커뮤니티에 기여하기: 온라인 포럼에 참여하고 밋업에 참석하여 안드로이드 개발자 커뮤니티와 연결되는 지식을 공유하세요.\n\n포트폴리오 만들기: 안드로이드 앱의 포트폴리오를 만들어 실력과 문제 해결 능력을 증명하세요.\n\n성공적인 안드로이드 주니어 개발자가 되기 위해서는 헌신, 지속적인 학습, 혁신적인 모바일 애플리케이션을 만드는 열정이 필요합니다. 인내심과 올바른 방법으로, 이 동적이고 계속 성장하는 분야에서 보람찬 경력을 쌓을 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-06-22-BecomingAndroidJuniorDeveloper_0.png"},"coverImage":"/assets/img/2024-06-22-BecomingAndroidJuniorDeveloper_0.png","tag":["Tech"],"readingTime":3},{"title":"MVVM, MVI 및 Kotlin Flows를 활용한 최신 안드로이드 개발  Part 1","description":"","date":"2024-06-22 22:37","slug":"2024-06-22-ModernAndroidDevelopmentwithMVVMMVIandKotlinFlowsPart1","content":"\n## 안드로이드 MVI 아키텍처의 심층 탐구\n\n<img src=\"/assets/img/2024-06-22-ModernAndroidDevelopmentwithMVVMMVIandKotlinFlowsPart1_0.png\" />\n\n앱 개발 프로세스를 개선하고 스트림라인하는 방법을 찾느라 고심 중인 안드로이드 개발자이신가요? Kotlin flows를 사용하여 MVVM 및 MVI 아키텍처 패턴을 결합하는 것을 들어보았지만 그것이 어떻게 도움이 될 수 있는지 또는 어디서 시작해야 하는지 확실하지 않으신가요? 이 기사는 여러분을 위해 특별히 작성되었습니다.\n\n안드로이드 개발에 있어서 올바른 아키텍처 패턴을 선택하는 것이 얼마나 중요한지 우리 모두 알고 있습니다. 이는 관리 가능한 프로젝트와 완전한 엉망인 프로젝트 사이의 차이를 의미할 수 있습니다. 이미 MVVM (Model-View-ViewModel) 및 MVI (Model-View-Intent) 패턴에 대해 알고 계실 것으로 생각됩니다. 각각에는 강점과 약점이 있습니다. MVVM은 데이터 바인딩과 표시 상태 관리에서 빛을 발하며, MVI는 단방향 데이터 흐름과 강력한 상태 관리로 빛을 발합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n하지만 이 두 강력한 패턴을 결합하여 안드로이드 개발에 더 강력한 접근 방식을 만들 수 있다고 말했다면 어떨까요? 바로 Kotlin flows를 사용하여 MVVM과 MVI 간의 원활한 통합을 제공하는 방법을 이 글에서 살펴보겠습니다.\n\n# MVC 대 MVI\n\n결합된 방식에 대해 자세히 살펴보기 전에 먼저 MVC (Model-View-Controller)와 MVI의 핵심 원칙을 이해해 보겠습니다.\n\n## MVC란 무엇인가요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nMVC 패턴에서 Model은 데이터와 비즈니스 로직을 나타내고, View는 UI를 렌더링하는 역할을 하며, Controller는 Model과 View 사이에서 중개자 역할을 하며, 사용자 입력을 처리하고 Model과 View를 업데이트합니다.\n\n![Image](/assets/img/2024-06-22-ModernAndroidDevelopmentwithMVVMMVIandKotlinFlowsPart1_1.png)\n\n다음은 안드로이드에서 Model-View-Controller (MVC) 아키텍처를 구현하는 예시입니다:\n\nModel 파일 이름은 UserModel.kt:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\ndata class User(val id: String, val name: String, val email: String)\n\nclass UserModel {\n    private val users: MutableList<User> = mutableListOf()\n\n    fun addUser(user: User) {\n        users.add(user)\n    }\n\n    fun getUsers(): List<User> {\n        return users.toList()\n    }\n}\n```\n\nUserModel 클래스는 Model을 나타내며 사용자 목록을 관리합니다.\n\n컨트롤러는 UserController.kt 입니다:\n\n```kotlin\nclass UserController(private val userView: UserView) {\n\n    private val userModel = UserModel()\n\n    // 모델 조작\n    fun addUser(name: String, email: String) {\n        val user = User(UUID.randomUUID().toString(), name, email)\n        userModel.addUser(user)\n\n        val users = userModel.getUsers()\n        updateView(users)\n    }\n\n    private fun updateView(users: List<User>) {\n        // 뷰에서 UI를 업데이트하는 적절한 메서드 호출\n        userView.displayUsers(users)\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nThe UserController 클래스는 Controller 역할을 하며 사용자 상호작용을 처리하고 Model을 업데이트합니다. 또한 Model의 변경 사항에 따라 UI를 업데이트하기 위해 View와 통신합니다.\n\n뷰는 MvcActivity.kt에서 제공됩니다:\n\n```js\ninterface UserView {\n    fun displayUsers(users: List<User>)\n}\n\nclass MvcActivity : AppCompatActivity(), UserView {\n    private lateinit var userAdapter: UserAdapter\n    private lateinit var binding: ActivityMvcBinding\n    private lateinit var controller: UserController\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        binding = ActivityMvcBinding.inflate(layoutInflater)\n        setContentView(binding.root)\n        setupRecyclerView()\n\n        // 컨트롤러 생성\n        controller = UserController(this)\n\n        binding.addUserButton.setOnClickListener {\n            val name = binding.nameEditText.text.toString()\n            val email = binding.emailEditText.text.toString()\n            // 사용자 입력 전송\n            controller.addUser(name, email)\n        }\n    }\n\n    override fun displayUsers(users: List<User>) {\n        // 사용자 목록을 표시하기 위해 UI 업데이트\n        userAdapter.setUsers(users)\n    }\n\n    private fun setupRecyclerView() {\n        // 코드가 간결하게 유지될 수 있도록 주석 처리됨\n    }\n}\n```\n\nMvcActivity 클래스는 View를 나타내며 UI를 표시하는 역할을 담당합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## MVI란 무엇인가요?\n\n![image](/assets/img/2024-06-22-ModernAndroidDevelopmentwithMVVMMVIandKotlinFlowsPart1_2.png)\n\nMVI 패턴은 Model-View-Controller (MVC) 패턴의 변형으로 생각될 수 있습니다. Model-View-Intent (MVI)의 주요 아이디어는 사용자 인터페이스를 구축하기 위한 반응적이고 기능적 접근 방식을 제공하는 것입니다. 이는 Model-View-Controller (MVC) 아키텍처와 유사합니다.\n\n## MVI는 어떻게 작동하나요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nMVI에서 기본 개념은 동일하지만 보다 반응적이고 기능적인 프로그래밍 스타일을 강조합니다. Model을 직접 변경하거나 View를 업데이트하는 대신, MVI는 사용자 의도를 불변의 데이터 구조 (Intents)로 캡처하고 단방향 데이터 흐름을 통해 이를 처리하는 데 초점을 맞춥니다. 이러한 흐름은 일반적으로 세 가지 주요 구성 요소로 구성됩니다:\n\n- Model: 응용 프로그램의 현재 상태를 나타냅니다. Model은 변경할 수 없습니다. Model은 의도를 처리하고 Model의 새 버전을 생성함으로써 업데이트됩니다.\n- View: 현재 Model 상태를 기반으로 UI를 렌더링하는 역할을 합니다. View는 수동적이며 Model이 변경될 때마다 업데이트를 수신합니다.\n- Intent: 사용자 작업 또는 의도를 나타내며, View에서 Model을 업데이트하기 위해 전송됩니다. Intents는 사용자가 수행하려는 작업을 설명하는 일반적으로 간단한 데이터 구조입니다.\n\n![이미지](/assets/img/2024-06-22-ModernAndroidDevelopmentwithMVVMMVIandKotlinFlowsPart1_3.png)\n\nMVI 패턴은 엄격한 단방향 데이터 흐름을 강제합니다. 데이터는 의도에서 모델로, 그리고 모델에서 뷰로 흐릅니다. 이렇게 하면 앱의 동작 및 상태에 대한 추론이 더 쉬워지며 구성 요소 간 부작용이나 종속성이 없기 때문에 유지보수가 쉽습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## MVC에서 MVI로 변환하기:\n\n위의 코드를 MVI 아키텍처로 어떻게 변경할 수 있는지 알아봅시다. 먼저 두 가지 추가 클래스를 추가해야 합니다. 뷰 내에서 사용자 관련 데이터의 현재 상태를 나타내는 UserViewState 클래스를 소개했습니다. UserIntent sealed 클래스는 사용자 의도를 나타내는 다양한 의도를 정의합니다. 예를 들어 사용자를 추가하는 것입니다.\n\n```js\ndata class UserViewState(val users: List<User>)\n\nsealed class UserIntent {\n    data class AddUser(val name: String, val email: String) : UserIntent()\n    // GetUsers와 같은 다른 사용자 의도도 추가할 수 있습니다.\n}\n```\n\nUserController와 UserView 인터페이스를 제거할 수 있습니다. 또한 UserModel 클래스를 변경하여 현재 뷰 상태를 유지하고 사용자 의도를 처리하며 사용자 상태를 업데이트할 수 있습니다. UserModel은 Kotlin Coroutines Flow를 사용하여 반응적일 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nclass UserModel {\n    // 애플리케이션의 현재 뷰 상태를 유지합니다\n    private val _userViewState: MutableStateFlow<UserViewState> = MutableStateFlow(UserViewState(emptyList()))\n    // 다른 뷰들과 뷰 상태를 공유하여 핫 플로우로 제공합니다\n    val userViewState = _userViewState.asStateFlow()\n\n    // processUserIntents에서 사용할 현재 뷰 상태를 얻습니다\n    private fun currentViewState(): UserViewState {\n        return _userViewState.value\n    }\n\n    // 뷰로부터 사용자 의도를 처리합니다\n    fun processUserIntents(userIntent: UserIntent) {\n        when (userIntent) {\n            is UserIntent.AddUser -> {\n                val user = User(UUID.randomUUID().toString(), userIntent.name, userIntent.email)\n                val newViewState = currentViewState().copy(users = currentViewState().users + user)\n                _userViewState.value = newViewState\n            }\n            /*\n            * 다른 사용자 의도(예: 사용자 목록 가져오기)도 여기서 처리할 수 있습니다\n            * */\n        }\n    }\n}\n```\n\nuserViewState는 사용자 뷰 상태를 핫 플로우로 공유합니다. 핫 플로우는 활성 구독자 여부와 관계없이 값을 방출합니다. 핫 플로우는 구독자 여부와 상관없이 계속 업데이트를 방출하는 공유 상태를 유지합니다. 새로운 구독자가 참여하면 최신 값 및 이후의 업데이트를 수신합니다. asStateFlow() 함수는 MutableSharedFlow를 StateFlow로 변환하며, 얻어진 StateFlow는 최신 값 유지 및 구독자 활동 여부에 관계없이 업데이트를 방출하는 핫 플로우로 간주될 수 있습니다.\n\n그리고 View 부분에 대한 변경사항은 다음과 같습니다:\n\n```js\nclass MviActivity : AppCompatActivity() {\n    private lateinit var userAdapter: UserAdapter\n    private lateinit var binding: ActivityMviBinding\n    private val model = UserModel()\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        binding = ActivityMviBinding.inflate(layoutInflater)\n        setContentView(binding.root)\n        setupRecyclerView()\n\n        binding.addUserButton.setOnClickListener {\n            val name = binding.nameEditText.text.toString()\n            val email = binding.emailEditText.text.toString()\n\n            // 사용자 의도를 생성하고 모델에 전달합니다\n            val userIntent = UserIntent.AddUser(name, email)\n            model.processUserIntents(userIntent)\n        }\n\n        // UI가 뷰 상태 변경을 관찰합니다\n        model.userViewState\n            .onEach { userViewState ->\n                renderUserViewState(userViewState)\n            }\n            .launchIn(lifecycleScope)\n    }\n\n    private fun renderUserViewState(userViewState: UserViewState) {\n        // 사용자 목록을 표시하기 위해 UI를 업데이트합니다\n        userAdapter.setUsers(userViewState.users)\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nMviActivity에서는 onEach를 사용하여 상태 플로우를 관찰하고 renderUserViewState()를 호출하여 UI를 업데이트합니다.\n\n수정된 코드로 다시 다이어그램을 살펴봅시다. 코드를 다이어그램의 각 부분에 매핑하는 방법을 살펴봅시다:\n\n![Diagram](/assets/img/2024-06-22-ModernAndroidDevelopmentwithMVVMMVIandKotlinFlowsPart1_4.png)\n\n위 다이어그램에서 사용자는 OnClick 등의 액션을 트리거할 수 있습니다. 이러한 액션들은 인텐트로 파싱되어 모델에 전달될 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n모델에서 processUserIntentsexecutes는 전달된 Intent에 기반한 로직을 실행하며, 이 경우 UserIntent.AddUser를 받아 새로운 상태를 생성합니다:\n\n```js\nval newViewState = currentViewState().copy(users = currentViewState().users + user)\n_userViewState.value = newViewState\n```\n\ncopy()는 기존 객체와 동일한 속성을 가진 새 객체를 생성하는 Kotlin 함수입니다. 이 경우 currentViewState().copy()는 현재 뷰 상태와 동일한 속성을 가진 새 UserViewState 객체를 생성합니다.\n\nusers = currentViewState().users + user 부분은 새로운 뷰 상태의 users 속성을 업데이트해야 함을 명시합니다. 요약하자면, 이 두 줄의 코드는 현재 뷰 상태의 복사본을 만들어 사용자 목록에 새로운 사용자가 추가된 새로운 뷰 상태 객체를 생성합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n뷰 부분에서 새 상태가 생성될 때마다 MviActivity가 변경 사항을 observe합니다.\n\n```js\nmodel.userViewState\n  .onEach { userViewState ->\n      renderUserViewState(userViewState)\n  }\n  .launchIn(lifecycleScope)\n```\n\n그리고 renderUserViewState(userViewState)를 사용하여 사용자에게 상태를 표시합니다. 반응형 프로그래밍과 Kotlin Coroutine 플로우 덕분에 가능해졌습니다.\n\n# 다음은 무엇인가요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음 시리즈에서는 MVVM 아키텍처를 MVI와 비교하고 이러한 아키텍처를 더 깊이 파헤쳐 양쪽에서 최상의 결과를 얻을 수 있는 방법에 대해 살펴볼 것입니다. 기대해주세요!\n","ogImage":{"url":"/assets/img/2024-06-22-ModernAndroidDevelopmentwithMVVMMVIandKotlinFlowsPart1_0.png"},"coverImage":"/assets/img/2024-06-22-ModernAndroidDevelopmentwithMVVMMVIandKotlinFlowsPart1_0.png","tag":["Tech"],"readingTime":12}],"page":"33","totalPageCount":120,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true}