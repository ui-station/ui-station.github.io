{"pageProps":{"posts":[{"title":"플레이 스토어에 첫 번째 앱을 출시하며 배운 7가지 소중한 교훈","description":"","date":"2024-06-23 21:43","slug":"2024-06-23-7Hard-EarnedLessonsfromPublishingMyFirstApponthePlayStore","content":"\n앱 출판의 장애물을 극복하는 개발자의 솔직한 여정\n\n![image](/assets/img/2024-06-23-7Hard-EarnedLessonsfromPublishingMyFirstApponthePlayStore_0.png)\n\n이 여정은 \"튜토리얼 지옥\"의 격전지에서 앱 출판의 흥미진진한 세계로 나를 이끌었습니다. 제가 겪었던 여러 어려움을 공유하여 여러분이 이 과정을 더 원할하게 탐험할 수 있도록 도와드리겠습니다.\n\n- 튜토리얼 지옥을 벗어나기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n앱 개발 여정 중 처음 6개월은 튜토리얼에 많이 의존했어요. 각각의 튜토리얼을 통해 새로운 것을 배우긴 했지만, 종종 근본적인 개념을 제대로 이해하지 못한 채 지시사항을 따라가는 상황에 갇혔어요. 이를 어떤 사람들은 \"튜토리얼 지옥\"이라고 부르죠.\n\n교훈: 튜토리얼은 귀중한 자원이지만 맹목적으로 따르지 마세요. \"어떻게\" 뒤에 숨은 \"왜\"를 이해하기 위해 노력해보세요.\n\n내 아이디어를 주도하는 경험은 궁극적인 힘이 되었어요! 앱을 개발한 후, Play Store에 출시하기 위한 \"20명 테스터 필요\" 규정을 마주하게 되었어요. 이는 앱을 14일 연속으로 적극적으로 테스트할 20명의 테스터를 찾아내는 것을 의미했어요. 사교적 상호작용을 최소화하는 제 성향을 고려하면, 이 테스터들을 모아내는 데 감히 2개월이 걸렸네요!\n\n교훈: 계획을 세워보세요! 앱의 출시 일정을 예상할 때 테스터를 찾는 것도 고려해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n2. 내 내성적인 성격을 극복하다\n\n과거에는 꽤 내성적이었던 나로서는 테스터를 찾는 사회적 측면이 무서웠습니다. 그래서 이 작업이 이렇게 오래 걸렸구나라고 이것이 그 이유였습니다! 그러나 이 장벽을 극복한 것은 개인적인 승리였습니다.\n\n교훈: 편안한 지역을 벗어나는 것은 보람찬 경험이 될 수 있습니다. 내내성으로 인해 목표를 이루는 데 방해받지 마세요.\n\n![이미지](/assets/img/2024-06-23-7Hard-EarnedLessonsfromPublishingMyFirstApponthePlayStore_1.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n3. Google Play 개발자 계정 만들기: 나의 경험\n\nPlay Store에 앱을 게시하는 여정이 내가 상상했던 것만큼 간단하지는 않았다. 초기 단계는 간단했다: 개인 또는 조직 계정 중 선택하고 이메일, 전화번호, 지불 방법을 제공하는 것이었다. 그러나 계정 인증이라는 진짜 장벽이 생겼다.\n\n내 신원을 인증하는 과정은 두 단계로 이루어졌다. 첫 번째는 쉬웠다 — 운전면허증, 여권, 선거증과 같은 정부 발급 신분증의 앞면과 뒷면 이미지를 제출하는 것이었다. 그러나 두 번째 단계는 좀 까다로웠다. Google은 제출한 문서에 있는 주소가 제공한 주소와 정확히 일치해야 한다고 요구했다. 이 보다는 간단해 보이는 작업이 나에게 두 번의 거부를 불러왔다!\n\n여기서 중요한 점은 등록할 때 입력하는 주소가 선택한 신분증 문서에 있는 주소와 완벽하게 일치하도록 하는 것이다. 이는 공과금, 은행 명세서 또는 임대 계약서의 사본일 수 있다. 반복적인 거부는 나중에 인증할 능력을 제한할 수 있으니 유의해야 한다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n더 자세한 내용을 원하시나요?\n\n전체 프로세스를 상세히 살펴보려면 제 미디엄 기사를 확인해보세요: \"2024년에 개발자 계정 만드는 방법: Google Play Store 잠금 해제하기\"\n\n4. 앱 생성 및 업로드\n\n계정이 확인된 후에 앱을 만들어 업로드할 수 있습니다. 이 과정에서 앱이나 게임인지, 가격 모델(무료 또는 유료), 필요한 동의를 받는 등의 세부 정보를 지정해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이후에는 앱 대시보드에 착륙하게 될 거에요. 여기서 \"프로덕션 언락\" 장벽을 만날 수도 있는데, 20명의 테스터가 14일 연속으로 앱을 활발히 테스트하도록 참여해야 한다는 요구 조건입니다.\n\n5. 20명 테스터 요건: 주의해야 할 사례\n\n여기서 재미있는 일들이 벌어지죠! 테스터를 구하는 데 어려움을 겪었던 걸 기억하시나요? 앱을 론칭하려는 초기 흥분이 Google Play의 내부 테스팅이 아닌 폐쇄 테스팅이 필요하다는 요구 사항과 충돌했어요. 내부 테스팅(친구와 가족과 함께)으로 업로드하는 것은 잘못된 방법이었죠! 그 테스터들은 폐쇄 테스팅 트랙의 일원이 아니라 참여할 수 없었어요.\n\n교훈: 세부 사항을 꼼꼼히 읽어보세요! 앱을 업로드하기 전에 내부 테스팅과 폐쇄 테스팅의 차이를 이해하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![image](/assets/img/2024-06-23-7Hard-EarnedLessonsfromPublishingMyFirstApponthePlayStore_2.png)\n\n6. 테스터 찾기: 미션 임파서블은 아니에요 (하지만 느낌은 비슷할 수 있어요)\n\n테스터를 찾기 어려워 지불 서비스를 탐색했지만 다행히도 무료 대안을 찾을 수 있었어요 (나중에 더 자세히 알려줄게요). 테스터를 찾는 무료 방법이 있다는 것을 기억하세요. 그러나 예전에 연락을 취한 적이 없는 사람들에게 연락해야 할 수도 있어요. 은애어 앱의 테스터를 모으는 팁은 아래와 같아요:\n\n- 앱의 특정 분야와 관련된 온라인 커뮤니티 및 포럼.\n- 앱 개발이나 베타 테스트에 중점을 둔 소셜 미디어 그룹.\n- 대학 캠퍼스 (앱이 학생을 대상으로하는 경우)\n- 기술 애호가나 기업가를 위한 로컬 밋업.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n7. 결론: 앱 출판을 위한 더 스무디한 길\n\n이 정보 폭포는 앱 출판의 어두운 물길을 잘 건널 수 있도록 도와줬기를 희망합니다! 이 단계를 따르면 저가 겪은 함정을 피하고 과정을 더욱 원할하게 진행할 수 있습니다.\n\n더 자세히 알고 싶나요? 제 다른 글인 \"Play Store에 앱 출판 전 알아야 할 사항\"에서 종합적으로 설명하고 있습니다.\n\n읽어 주셔서 감사합니다. 행복한 개발되세요!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nhttps://saurabh7973.medium.com/subscribe\n","ogImage":{"url":"/assets/img/2024-06-23-7Hard-EarnedLessonsfromPublishingMyFirstApponthePlayStore_0.png"},"coverImage":"/assets/img/2024-06-23-7Hard-EarnedLessonsfromPublishingMyFirstApponthePlayStore_0.png","tag":["Tech"],"readingTime":6},{"title":"iOS 모바일 개발에서 Feature Flags 사용 방법","description":"","date":"2024-06-23 21:41","slug":"2024-06-23-FeatureFlagsiniOSMobileDevelopment","content":"\n앱 개발의 동적인 환경에서는 새로운 기능을 도입하거나 기존 기능을 대체해야 하는 필요성이 항상 존재합니다. 전통적으로, 개발자들은 과거 코드를 제거하거나 주석 처리하고 새 코드를 통합한 후 업데이트를 앱 스토어에 제출한 다음 변경 사항을 공개하기 전에 검토 프로세스를 기다리는 경우가 많습니다. 그러나 이 방식은 앱 스토어의 검토 일정을 기다려야 하는 큰 문제점을 안고 있습니다.\n\n대안으로, 더 나은 방법이 있습니다. 바로 피처 플래그(Feature flags)를 사용하는 것입니다. 이러한 플래그를 사용하면 특정 기능의 가시성과 동작을 손쉽게 제어할 수 있으며 복잡한 코드 변경이나 앱 스토어 제출 없이 기능을 관리할 수 있습니다. 예를 들어, 특정 기능을 특정 시간 동안만 활성화하고 싶다면, 피처 플래그를 사용하여 기능이 나타나는 조건을 제어할 수 있습니다. 앱 스토어에 새로운 빌드를 제출할 필요가 없습니다. 매끄럽고 효율적인 프로세스가 됩니다.\n\n개인적인 개발 경험을 바탕으로 말하자면, 특정 시간대에만 특정 뷰를 제공하고 싶은 경우가 있었습니다. 피처 플래그는 이러한 시간에 민감한 기능 구현을 효율적으로 처리할 수 있는 강력한 도구로 작용했습니다.\n\n![이미지](/assets/img/2024-06-23-FeatureFlagsiniOSMobileDevelopment_0.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 기능 플래그란 무엇인가요?\n\n본질적으로, 기능 플래그 또는 기능 토글이라고도 알려진 것은 일반적으로 서버에 저장된 값입니다. Firebase, SupaBase 또는 서버에 호스팅된 JSON과 같은 곳에 저장됩니다. 이 값은 특정 기능 이름과 부울 값과 연결됩니다. 모바일 애플리케이션이 이 객체를 가져오면 해당 기능이 활성화되었는지 비활성화되었는지 확인합니다. 활성화되어 있으면 앱은 일련의 기능을 실행하거나 특정 기능을 제공합니다. 이러한 동적 제어는 개발자가 기능을 선택적으로 관리하고 릴리스할 수 있도록 하여 애플리케이션의 동작을 유연하게 제어할 수 있게 합니다.\n\n# 서버 측\n\n프로세스를 가동하기 위해 앱에 가져올 기능을 저장하기 위한 리포지토리를 설정하는 것이 중요합니다. 제 경우에는 내 앱 내에서 이미 통합되어 있는 SupaBase를 선택하여 이를 활용했습니다. 이 선택은 추가적인 SDK를 통합하거나 새로운 구현을 도입할 필요성을 제거하고, 만들어 둔 테이블을 호출하는 방법으로 단순화된 과정을 제공합니다. 새로운 feature_flag라는 테이블을 만든 다음 다음 필드를 포함했습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- created_at\n- is_enabled\n- feature_name\n- number_users_seen\n\n<img src=\"/assets/img/2024-06-23-FeatureFlagsiniOSMobileDevelopment_1.png\" />\n\n'feature_name'을 이해하기 쉬운 내용으로 설정하는 것이 좋지만 원한다면 설명을 위한 다른 필드도 추가할 수 있습니다.\n\n'number_users_seen'은 내가 사용하는 사용 사례로 특정 기능을 본 사용자 수를 추적하는 것이지만 창의력과 요구 사항에 따라 추가 필드도 포함할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 클라이언트 측\n\n클라이언트 측 모델을 구축할 때는 데이터 구조와 완벽하게 일치하도록 설계하는 것이 중요합니다. 잘 구성된 모델은 응용 프로그램 전체에서 명확성과 일관성을 보장합니다.\n\n거기에 더해, 특히 기능 이름을 위한 enum을 포함하는 것을 고려해보세요. 열거형은 서로 다른 값 집합을 나타내는 구조화된 안전한 방법을 제공하며, 이 경우에는 각기 다른 기능 이름을 나타냅니다.\n\n여기서 enum의 장점에 대해 자세히 다루지는 않겠지만, docs.swift.org에서 더 많은 정보를 찾아볼 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Screenshot 1](/assets/img/2024-06-23-FeatureFlagsiniOSMobileDevelopment_2.png)\n\n구체적인 상황으로 돌아와서, 특정 시간 프레임 내에서 뷰를 표시하고 한 번만 나타나도록하는 것을 목표로 한 내 상황에서는 아래에 설명된 방식과 유사한 접근 방식을 채택했습니다. 사용자가 프롬프트를 보았는지 여부를 추적하기 위해 UserDefaults (또는 SwiftUI에서의 @AppStorage)를 사용했습니다. 또한 featureFlags 데이터에 대한 Published 변수와 관련 시트를 표시해야 하는지를 결정하는 데 사용된 다른 Published 변수를 사용했습니다.\n\n- 기능 플래그 가져오기\n- shouldSowGiveAwaySheet 호출\n- updateHasSeenGiveAwayPrompt 호출\n\n![Screenshot 2](/assets/img/2024-06-23-FeatureFlagsiniOSMobileDevelopment_3.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n내 수업 내에서는 FeatureFlagManager가 초기화될 때 getFeatureFlags를 호출하고 SupaBase에서 기능 플래그를 가져올 것입니다. 이 작업은 초기화 시에 수행하지 않을 수도 있으며 필요한 진입점에서 getFeatureFlags를 호출할 수도 있습니다.\n\n내가 기능 플래그가 있는 시트를 표시해야 하는지 결정해야 하는 경우 shouldShowGiveAwaySheet를 호출할 수 있습니다.\n\n```swift\nguard let featureIsEnabled = featureFlags.first(where:\n  { $0.featureName == .giveAwayPrompt })?.isEnabled else\n    { self.showGiveAwayFeature = false }\n```\n\n위의 guard 문은 giveAwayPrompt의 기능 플래그가 featureFlags 배열에 있는지 확인합니다. 해당 플래그를 찾지 못하면 showGiveAwayFeature를 false로 설정하고 함수를 일찍 종료합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nif featureIsEnabled && !hasSeenGiveAwayPrompt {\n  self.showGiveAwayFeature = true\n  self.updateHasSeenGiveAwayPrompt(featureName: .giveAwayPrompt)\n}\n```\n\n이 블록은 특징이 활성화되어 있고 사용자가 이전에 선물 증정 프롬프트를 보지 않은 경우에 실행됩니다.\n\ngiveaway 시트를 표시해야 한다는 것을 나타내기 위해 showGiveAwayFeature를 true로 설정합니다.\n\n또한, updateHasSeenGiveAwayPrompt 메소드를 호출하여 사용자가 선물 증정 프롬프트를 이제 보았다는 것을 나타내는 @AppStorage showGiveAwayFeature 표식을 업데이트합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nself.showGiveAwayFeature = false;\n```\n\n이 라인은 조건 블록 밖에 있으므로 해당 기능이 활성화되었는지와 사용자가 give-away 프롬프트를 보았는지 여부에 관계없이 실행됩니다. showGiveAwayFeature를 false로 설정하여 기본적으로 표시되지 않도록 합니다.\n\n# 열거형(enum)의 우아함\n\n열거형(enum)의 우아함은 updateHasSeenGiveAwayPrompt와 같은 함수에서 빛을 발합니다. 필수는 아니지만, 저는 switch 문을 사용하여 사용법을 설명하는 것이 중요하다고 생각합니다. 이 접근 방식은 새로운 기능이 도입되었을 때 개발자가 해당 경우를 명시적으로 처리하도록 요청하므로 코드 완성도를 높이고 놓치는 것을 방지합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n앱 개발의 동적 영역에서 특징 플래그와 열거형의 신중한 사용은 개발자에게 유연하고 조직적인 도구 상자를 제공해줍니다. 우리는 특징 플래그가 동적 변경을 가능하게 하며, 지속적인 코드 수정이나 긴 앱 스토어 리뷰 없이 기능 릴리스를 원할하게 제어할 수 있도록 하는 방법을 살펴보았습니다. updateHasSeenGiveAwayPrompt와 같은 함수에서 열거형을 활용하면 코드의 가독성을 향상시킬 뿐만 아니라 새로운 기능 사례를 신중하게 처리하도록 개발자에게 강요하는 최선의 실천법을 갖추게 됩니다.\n\n우리가 계속 발전하는 응용 프로그램 개발 영역을 탐험하는 동안, 이러한 실천법은 귀중하다는 것을 입증했습니다. 이것은 효율적인 프로세스뿐만 아니라 탄력적이고 적응 가능한 코드 기반을 생성하는 데 기여합니다. 특징 플래그와 열거형을 활용하여, 개발자는 변화하는 요구 사항에 우아하게 대응하는 애플리케이션을 구축할 수 있으며, 이는 보다 효율적이고 유지보수가 쉽며 미래를 대비한 개발 경험을 제공합니다.\n","ogImage":{"url":"/assets/img/2024-06-23-FeatureFlagsiniOSMobileDevelopment_0.png"},"coverImage":"/assets/img/2024-06-23-FeatureFlagsiniOSMobileDevelopment_0.png","tag":["Tech"],"readingTime":7},{"title":"Flutter에서 No MediaQuery widget found 오류 해결하는 방법","description":"","date":"2024-06-23 21:40","slug":"2024-06-23-ResolvingNoMediaQuerywidgetfoundErrorinFlutter","content":"\n플러터를 사용해 오셨다면 언젠가 No MediaQuery 위젯을 찾을 수 없다는 오류와 마주쳐 보셨을 겁니다. 이 오류는 답답할 수 있지만, 다행히도 보통 쉽게 해결할 수 있어요. 이 글에서는 이 오류의 원인을 살펴보고 해결하는 방법을 알아볼 거에요.\n\n## 오류 이해하기\n\nNo MediaQuery 위젯을 찾을 수 없다는 오류는 주로 MediaQuery 클래스를 사용하여 화면 크기, 방향 또는 기타 미디어 관련 정보를 가져오려고 시도할 때 발생합니다. MediaQuery 클래스는 미디어 쿼리 데이터에 액세스해야 하는 위젯들보다 위젯 트리 계층구조에서 MediaQuery 위젯이 존재해야 합니다.\n\n## 일반적인 원인\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 에러의 일반적인 원인 중 하나는 MaterialApp, CupertinoApp 또는 WidgetsApp으로 래핑되지 않은 위젯에서 MediaQuery.of(context)를 사용하려고 시도하는 것입니다. 이러한 위젯들은 위젯 트리 상위에서 MediaQuery 위젯이 사용 가능하도록 보장합니다.\n\n## 예시 시나리오\n\n간단한 예시를 살펴보겠습니다. 다음과 같은 코드가 있다고 가정해봅시다:\n\n```js\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: Text(\n        '화면 너비: ${MediaQuery.of(context).size.width}',\n      ),\n    );\n  }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 코드를 실행하면 No MediaQuery widget found 오류가 발생합니다. 이는 Text 위젯이 액세스를 시도하는 곳에 MediaQuery 위젯이 존재하지 않기 때문입니다.\n\n## 해결 방법\n\n이 오류를 해결하려면 MaterialApp, CupertinoApp 또는 WidgetsApp과 같은 MediaQuery 객체를 소개하는 위젯이 포함된 위젯 트리를 확인하십시오. 수정된 코드는 다음과 같습니다:\n\n```js\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: Text('MediaQuery Example'),\n        ),\n        body: Center(\n          child: Text(\n            'Screen width: ${MediaQuery.of(context).size.width}',\n          ),\n        ),\n      ),\n    );\n  }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 수정된 버전에서는 MaterialApp 위젯이 MediaQuery 위젯이 위젯 트리 상위에 있는지 확인합니다. 이제 MediaQuery.of(context)를 사용하여 미디어 쿼리 정보에 성공적으로 액세스할 수 있습니다.\n\n## 대안 솔루션\n\n만약 MaterialApp을 사용하고 싶지 않다면 수동으로 위젯을 MediaQuery 위젯으로 래핑할 수 있습니다. 예를 들어:\n\n```js\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MediaQuery(\n      data: MediaQueryData.fromWindow(WidgetsBinding.instance.window),\n      child: Center(\n        child: Text(\n          '화면 너비: ${MediaQuery.of(context).size.width}',\n        ),\n      ),\n    );\n  }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이번 버전에서는 MediaQuery 위젯을 수동으로 추가했습니다. 이 위젯에는 MediaQueryData.fromWindow으로 얻은 화면 데이터가 제공되었습니다.\n\n## 결론\n\n플러터(Flutter)에서 발생하는 No MediaQuery widget found 오류는 흔히 마주치는 장애물이지만, 위젯 트리에 MediaQuery 위젯이 포함되어 있는지 확인하여 쉽게 해결할 수 있습니다. MaterialApp, CupertinoApp 또는 WidgetsApp을 사용하거나 위젯을 수동으로 MediaQuery 위젯으로 래핑함으로써 이를 수행할 수 있습니다.\n\n이 오류를 이해하고 해결하는 것은 Flutter 개발 경험을 더욱 원만하고 효율적으로 만들어 줄 것입니다.\n","ogImage":{"url":"/assets/img/2024-06-23-ResolvingNoMediaQuerywidgetfoundErrorinFlutter_0.png"},"coverImage":"/assets/img/2024-06-23-ResolvingNoMediaQuerywidgetfoundErrorinFlutter_0.png","tag":["Tech"],"readingTime":4},{"title":"Flutter로 인물 및 가로 모드가 가능한 카메라 앱 만드는 방법","description":"","date":"2024-06-23 21:39","slug":"2024-06-23-HowtocreateacameraappbyflutterwithPortraitandLandscapemode","content":"\n![이미지](/assets/img/2024-06-23-HowtocreateacameraappbyflutterwithPortraitandLandscapemode_0.png)\n\n현재 모바일 애플리케이션 개발에서 가장 흔한 단어 중 하나인 Flutter 입니다. Flutter는 요즘 가장 편리하고 강력한 크로스 플랫폼 프레임워크 중 하나입니다. 놀라운 커뮤니티, 도구 및 라이브러리를 갖추고 있어 여러분이 원하는 모바일 애플리케이션을 만들 수 있습니다.\n\n지금은 Flutter 애플리케이션에 카메라와 같은 기능이 있는 것이 매우 흔합니다. 여러분의 애플리케이션이 CRM이든 E-commerce이든 소셜 플랫폼이든, 카메라 기능은 매우 일반적이고 유용합니다. 모든 이런 미리 튜토리얼 단어들로 지루하게 만드는 것은 하지 않겠습니다. 바로 개발에 들어가 봅시다...\n\n사용할 패키지:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우린 flutter.dev의 Camera 패키지를 사용할 거야.\n\n패키지 설치 방법:\n\n이것을 당신의 패키지의 pubspec.yaml 파일에 다음과 같은 줄을 추가할 거야 (그리고 암시적으로 flutter pub get을 실행할 거야):\n\n```js\ndependencies:\n  camera: ^0.10.5+2\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 가져오기\n\n이제 당신의 Dart 코드에서 다음을 사용할 수 있습니다:\n\n```js\nimport \"package:camera/camera.dart\";\n```\n\n또한 이 링크를 클릭하여 패키지 설치를 확인할 수도 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 어떻게 구현하나요?\n\n나는 코드를 깔끔하게 작성하는 것을 선호해요. 모든 기능을 분리하고 모든 기능이나 기능이 재사용 가능하도록 만들려고 해요. 그래서 전체 카메라 기능을 분리하는 걸 좋아해요.\n아래에서 어떻게 할 수 있는지 알려드릴게요.\n단계 1: Stateful 위젯을 만드세요 (저는 CameraScreen이라고 이름 붙였어요).\n\n```js\nclass CameraScreen extends StatefulWidget\n```\n\n이제 List`CameraDescription` 유형의 변수를 취하세요. 메인 함수에서 초기화하려면 전역 변수로 만들 수도 있어요. 카메라 화면으로 이동하기 전에 사용 가능한 카메라 목록을 가져오는 것이 좋아요. 따라서 사용 가능한 카메라 목록을 가져오는 방법입니다. 메인 함수에서 사용 가능한 카메라 목록을 가져올 수도 있고, 카메라 화면으로 이동하기 전에 가져올 수도 있고, 카메라 컨트롤러를 초기화하기 전에 가져올 수도 있어요. 하지만 이렇게하여 사용 가능한 카메라를 가져올 수 있어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n// 여기에 코드를 넣어 주세요.\nList<CameraDescription> cameras = [];\nvoid getAvalaibleCamera() async {\n  try {\n    cameras = await availableCameras();\n  } catch (error, stackTrace) {\n    // 무언가를 처리합니다.\n  }\n}\n// 여기에 코드를 넣어 주세요.\n```\n\n단계 2: 이제 Init 함수를 정의합시다. Init 함수에서는 카메라에 필요한 모든 컨트롤러 및 기타 필요한 것들을 초기화할 것입니다. 다음과 같이 진행할 거에요.\n\n```js\nlate CameraController _cameraController;\nlate CameraDescription backCamera, frontCamera;\n\n@override\nvoid initState() {\n  getAvailableCamera();\n\n  super.initState();\n}\n\n@override\nvoid dispose() {\n  _cameraController.dispose();\n  super.dispose();\n}\n\nvoid getAvailableCamera() async {\n  for (var i = 0; i < cameras.length; i++) {\n    var camera = cameras[i];\n    if (camera.lensDirection == CameraLensDirection.back) {\n      backCamera = camera;\n    }\n    if (camera.lensDirection == CameraLensDirection.front) {\n      frontCamera = camera;\n    }\n  }\n  if (backCamera == null) {\n    backCamera = cameras.first;\n  }\n  if (frontCamera == null) {\n    frontCamera = cameras.last;\n  }\n  _cameraController = CameraController(backCamera, ResolutionPreset.medium);\n\n  _cameraController.initialize().then((_) {\n    if (!mounted) {\n      return;\n    }\n    setState(() {});\n  });\n}\n```\n\n단계 3: 예스, 초기화하는 것에 관해 충분히 알겠죠. 이제 UI로 넘어갑시다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nUI를 만들 때는 화면을 최대한 간단하게 유지하려고 노력하고 있어요. CameraView와 두 개의 버튼(한 개는 사진 촬영을 위한 것이고, 다른 한 개는 카메라 설정 변경을 위한 것)만 있는 정적 UI를 만들 계획이에요.\n\n여기서 빌드 함수를 확인해 볼게요.\n\n```js\n @override\n  Widget build(BuildContext context) {\n    if (!_cameraController.value.isInitialized) {\n      return Container();\n    }\n    return Scaffold(\n      backgroundColor: Colors.transparent,\n      body: CameraPreview(_cameraController),\n      floatingActionButtonLocation: FloatingActionButtonLocation.centerFloat,\n      floatingActionButton: Stack(\n        children: [\n          Align(\n            alignment: Alignment.bottomCenter,\n            child: FloatingActionButton(\n              backgroundColor: Colors.orange,\n              child: const Icon(Icons.camera_alt),\n              onPressed: () async {\n                XFile? image = await _cameraController.takePicture();\n                if(image != null){\n                  // todo: 여기에 코드를 추가해 주세요\n                }\n              },\n            ),\n          ),\n          Align(\n            alignment: Alignment.bottomRight,\n            child: Padding(\n              padding: EdgeInsets.only(right: 20),\n              child: FloatingActionButton(\n                backgroundColor: Colors.deepOrange,\n                child: const Icon(Icons.flip_camera_android),\n                onPressed: () {\n                  if (_cameraController.description.lensDirection == CameraLensDirection.back) {\n                    _cameraController = CameraController(frontCamera, ResolutionPreset.medium);\n                  } else {\n                    _cameraController = CameraController(backCamera, ResolutionPreset.medium);\n                  }\n\n                  _cameraController.initialize().then((_) {\n                    if (!mounted) {\n                      return;\n                    }\n                    setState(() {});\n                  });\n                },\n              ),\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n```\n\n여기서 todo 섹션에서 작업할 거예요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 UI가 될 것입니다. 하지만 UI에 대해서는 걱정하지 마세요. 마음대로 UI를 만들면 됩니다.\n\n![이미지](/assets/img/2024-06-23-HowtocreateacameraappbyflutterwithPortraitandLandscapemode_1.png)\n\n단계 4: 여기까지는 모든 것이 카메라 패키지 설명서에 따라 괜찮아 보입니다. 하지만 이제 실제 문제가 발생합니다.\n\n\"자동 회전\" 모드를 끄고 이 사진처럼 가로 모드에서 사진을 찍고 싶을 때, 이미지가 90도 회전됩니다. 이 문제는 플러터 앱을 기본적으로 세로 모드로 설정하면서 발생합니다. 따라서 기기의 방향을 변경해도 앱이 방향에 따라 구성을 변경하지 않습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n응, 알았어. 이 문제는 단순히 기기의 자동 회전 모드를 켜는 것으로 쉽게 해결할 수 있어. 그런데 이미지나 비디오 파일을 편평화하기 위해 자동 회전 모드가 필요한 카메라 앱을 본 적이 없어. 이제 그런 문제가 생기면 어떻게 해야 할까?\n\n첫 번째 할 일은, 기기가 어느 방향을 향하고 있는지 감지하는 것인데, 자동 회전 모드가 켜져 있던 말던 상관없이 이 작업을 수행해야 해.\n\n기기의 자동 회전을 끈 채로 OrientationBuilder를 사용하여 이를 감지할 수 없어.\n\n이를 확인하려면 자이로 센서를 사용해야 해. 인터넷에 센서에 대한 많은 정보가 있으니 찾아보길 추천해. 기기의 다양한 움직임 등을 감지하는 다른 센서들도 있어. 많은 게임이 이러한 센서들을 사용하여 사용자에게 깨끗한 게임 경험을 제공해.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n자이로 센서를 앱에 설치하려면 sensor_plus라는 이 패키지를 추가해야 합니다.\n\npubspec.ymal 파일에 패키지를 설치하고 사용하려는 페이지에 가져와야 합니다.\n\n```js\ndependencies:\n  sensors_plus: ^3.0.3\n```\n\n제가 밝혔듯이 OrientationBuilder는 기기의 자동 회전 모드가 꺼져 있거나 강제로 앱을 특정 방향으로 설정한 경우에는 작동하지 않습니다. 그래서 기기의 방향을 알기 위해 직접 OrientationBuilder를 작성해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nBuilder 위젯을 만들어 봅시다.\n\n```js\nimport 'dart:async';\n\nimport 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\nimport 'package:sensors_plus/sensors_plus.dart';\n\nclass CustomOrientationBuilder extends StatefulWidget {\n  const CustomOrientationBuilder({required this.builder, required this.isVideosRecording, super.key});\n  /// 이 빌더 함수는 콘텍스트와 방향(열거형)을 제공합니다.\n  final Widget Function(BuildContext, CustomOrientation) builder;\n  /// 이것은 비디오 녹화 중인지 여부를 나타내는 플래그입니다.\n  /// 녹화 중인 경우 방향 변경이 인식되지 않습니다. 이 논리는 제가 만들었지만 여러분은 변경할 수 있습니다.\n  final bool isVideosRecording;\n  @override\n  State<CustomOrientationBuilder> createState() => _CustomOrientationBuilderState();\n}\n\nclass _CustomOrientationBuilderState extends State<CustomOrientationBuilder> {\n  late StreamSubscription<AccelerometerEvent> accelerometerSubscription;\n  CustomOrientation cameraOrientation = CustomOrientation.portrait;\n\n  @override\n  void initState() {\n    super.initState();\n    orientation();\n  }\n  @override\n  Widget build(BuildContext context) {\n    return widget.builder(context, cameraOrientation);\n  }\n\n  orientation(){\n    try {\n      accelerometerSubscription = accelerometerEvents.listen((AccelerometerEvent event) {\n        if(!widget.isVideosRecording){\n          setState(() {\n            if (event.z < -8.0) {\n\n              cameraOrientation = CustomOrientation.portrait;\n            } else if (event.x > 5.0) {\n\n              cameraOrientation = CustomOrientation.rightLandScape;\n            } else if (event.x < -5.0) {\n\n              cameraOrientation = CustomOrientation.leftLandScape;\n            }\n            else{\n\n              cameraOrientation = CustomOrientation.portrait;\n            }\n\n          });\n\n        }\n\n\n\n      });\n    } on PlatformException catch (e) {\n      print(\"Error: $e\");\n    }\n  }\n  @override\n  void dispose() {\n    super.dispose();\n    /// 듣기자나 컨트롤러나 스트림 등의 청취자나 컨트롤러나 스트림을 해제하거나 취소하거나 제거하지 않도록 유의하세요.\n    accelerometerSubscription.cancel();\n  }\n}\n\n/// 방향 열거형\nenum CustomOrientation {portrait, leftLandScape, rightLandScape}\n```\n\n또는 사진을 찍기 전에 자이로 센서로 방향을 확인할 수 있습니다. 다음과 같이요.\n\n```js\nlate StreamSubscription<AccelerometerEvent> accelerometerSubscription;\n\nCustomOrientation getOrientation(){\n  CustomOrientation cameraOrientation = CustomOrientation.portrait;\n    try {\n      accelerometerSubscription = accelerometerEvents.listen((AccelerometerEvent event) {\n        if(!widget.isVideosRecording){\n          if (event.z < -8.0) {\n\n              cameraOrientation = CustomOrientation.portrait;\n            } else if (event.x > 5.0) {\n\n              cameraOrientation = CustomOrientation.rightLandScape;\n            } else if (event.x < -5.0) {\n\n              cameraOrientation = CustomOrientation.leftLandScape;\n            }\n            else{\n\n              cameraOrientation = CustomOrientation.portrait;\n            }\n\n        }\n\n      });\n    } on PlatformException catch (e) {\n      print(\"Error: $e\");\n    }\n    return cameraOrientation;\n}\n\n/// 여러분의 코드\ntakePhoto()async{\n  CustomOrientation orientation = getOrientation();\n  XFile? image =  await _cameraController.takePicture();\n\n  /// 여러분의 코드\n\n}\n/// 여러분의 코드\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n지금은 당신의 선택입니다. 방향을 어떻게 설정할지 결정하세요.\n\n이제 이 빌더를 카메라 화면에 추가해 보겠습니다. 다음과 같이 보일 것입니다.\n\n```js\nimport 'package:camera/camera.dart';\nimport 'package:flutter/material.dart';\nimport 'package:prism_v2/global/global_variables.dart';\nimport 'package:sizer/sizer.dart';\n\nclass CameraScreen extends StatefulWidget {\n  static const routeName = '/camera';\n\n  const CameraScreen({Key? key}) : super(key: key);\n\n  @override\n  _CameraScreenState createState() => _CameraScreenState();\n}\n\nclass _CameraScreenState extends State<CameraScreen> {\n  late CameraController _cameraController;\n  late CameraDescription backCamera, frontCamera;\n\n  @override\n  void initState() {\n    getAvailableCamera();\n\n    super.initState();\n  }\n\n  @override\n  void dispose() {\n    _cameraController.dispose();\n    super.dispose();\n  }\n\n  void getAvailableCamera() async {\n    for (var i = 0; i < cameras.length; i++) {\n      var camera = cameras[i];\n      if (camera.lensDirection == CameraLensDirection.back) {\n        backCamera = camera;\n      }\n      if (camera.lensDirection == CameraLensDirection.front) {\n        frontCamera = camera;\n      }\n    }\n    if (backCamera == null) {\n      backCamera = cameras.first;\n    }\n    if (frontCamera == null) {\n      frontCamera = cameras.last;\n    }\n    _cameraController = CameraController(backCamera, ResolutionPreset.medium);\n\n    _cameraController.initialize().then((_) {\n      if (!mounted) {\n        return;\n      }\n      setState(() {});\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    if (!_cameraController.value.isInitialized) {\n      return Container();\n    }\n    return Scaffold(\n      backgroundColor: Colors.transparent,\n      body: CameraPreview(_cameraController),\n      floatingActionButtonLocation: FloatingActionButtonLocation.centerFloat,\n      floatingActionButton: Stack(\n        children: [\n          Align(\n            alignment: Alignment.bottomCenter,\n            /// here I have added this right on the take photo button\n            child: CustomOrientation(\n              builder: (context, orientation) {\n                return FloatingActionButton(\n                  backgroundColor: Colors.orange,\n                  child: const Icon(Icons.camera_alt),\n                  onPressed: () async {\n                    await _cameraController.takePicture().then((value) {\n                      Navigator.pop(context, value.path);\n                    });\n                  },\n                );\n              }\n            ),\n          ),\n          Align(\n            alignment: Alignment.bottomRight,\n            child: Padding(\n              padding: EdgeInsets.only(right: 5.0.w),\n              child: FloatingActionButton(\n                backgroundColor: Colors.deepOrange,\n                child: const Icon(Icons.flip_camera_android),\n                onPressed: () {\n                  if (_cameraController.description.lensDirection ==\n                      CameraLensDirection.back) {\n                    _cameraController =\n                        CameraController(frontCamera, ResolutionPreset.medium);\n                  } else {\n                    _cameraController =\n                        CameraController(backCamera, ResolutionPreset.medium);\n                  }\n\n                  _cameraController.initialize().then((_) {\n                    if (!mounted) {\n                      return;\n                    }\n                    setState(() {});\n                  });\n                },\n              ),\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\n이제 우리는 방향을 설정했습니다. 당신의 기기나 앱의 기본 방향에 대해 아무것도 할 필요가 없습니다. 문제는 기기의 방향을 변경할 때 발생할 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n해결하기 위해서는 디바이스의 현재 방향에 따라 이미지를 회전해야 합니다. 여기서는 takephoto 함수만 작성하고 있어요. 한번 봅시다...\n\n```js\nimport 'package:image/image.dart' as img;\n\ntakePhoto(CustomOrientation orientation) async {\n\n  XFile? image = await _cameraController.takePicture();\n  List<int> rotatedBytes = [];\n  if (orientation != AppString.portrait) {\n    int angle = 90;\n    if (orientation == AppString.leftLandScape) {\n      angle = -90;\n    }\n    Uint8List byte = await File(rawImage!.path).readAsBytes();\n    img.Image? image = img.decodeImage(byte);\n    image = img.copyRotate(image!, angle.toInt());\n    rotatedBytes = img.encodeJpg(image);\n  }\n  File imageFile = rotatedBytes.isEmpty ? File(rawImage!.path) : await File(rawImage!.path).writeAsBytes(rotatedBytes);\n  /// 여기에 코드를 작성하세요\n\n}\n```\n\n요렇게요. 이제 원하는 대로 직립 사진을 찍을 수 있어요. 이제 카메라 방향이 OS 카메라 기능처럼 작동할 거에요.\n\n이제 비디오 파일을 회전시키고 싶다면! 가능해요. 그러나 해당 작업을 하려면 flutter_ffmpeg 패키지를 import해야 해요. 그걸 추천하진 않겠어요. 두 가지 이유가 있어서요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 비디오 녹화를 중지한 후, 비디오 처리에 너무 오랜 시간이 걸릴 수 있습니다. 녹화된 비디오의 방향에 따라 회전 처리를 하려면 많은 시간이 소요될 수 있습니다.\n- 특정 패키지를 가져오려면 minSdkVersion을 24로 증가해야 합니다. 그러면 앱 크기가 두 배가 됩니다. 그렇지 않길 바라겠네요.\n\n그러므로 가장 좋은 방법은 비디오를 서버로 전송하여 서버에서 비디오를 처리하도록 하는 것입니다.\n또는 사용자에게 비디오를 보여줄 때, RotatedBox를 사용하여 화면 방향에 따라 비디오 플레이어 위젯을 회전시킬 수 있습니다. 이렇게 하면 사용자가 비디오가 회전되었는지 여부를 이해하지 못할 것입니다.\nFlutter 여행에 도움이 되기를 바랍니다.\n\n즐거운 코딩하시고 ❤️\n","ogImage":{"url":"/assets/img/2024-06-23-HowtocreateacameraappbyflutterwithPortraitandLandscapemode_0.png"},"coverImage":"/assets/img/2024-06-23-HowtocreateacameraappbyflutterwithPortraitandLandscapemode_0.png","tag":["Tech"],"readingTime":17},{"title":"Flutter에서 간단하게 Pull to Refresh 구현하는 방법","description":"","date":"2024-06-23 21:38","slug":"2024-06-23-SimpleFlutterpulltorefresh","content":"\n<img src=\"/assets/img/2024-06-23-SimpleFlutterpulltorefresh_0.png\" />\n\n모바일 애플리케이션에서 사용자가 콘텐츠를 새로 고칠 수 있는 방법을 제공하는 것은 일반적인 필요사항입니다. 가장 직관적인 방법 중 하나는 pull-to-refresh 제스처입니다. 이 기능을 통해 사용자는 추가 버튼이나 수동 입력이 필요하지 않고 새로운 데이터를 쉽게 가져올 수 있어 사용자 경험을 향상시킵니다.\n\n# Flutter에서 Pull-to-Refresh 구현하기\n\nFlutter를 사용하면 RefreshIndicator 위젯을 사용하여 pull-to-refresh 기능을 구현하기가 쉽습니다. 아래에는 이 기능을 Flutter 애플리케이션에 추가하는 방법을 보여주는 간단한 예제가 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n샘플 코드: main.dart\n\n```js\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Pull to Refresh Demo',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: HomePage(),\n    );\n  }\n}\n\nclass HomePage extends StatefulWidget {\n  @override\n  _HomePageState createState() => _HomePageState();\n}\n\nclass _HomePageState extends State<HomePage> {\n  List<String> items = List.generate(20, (index) => \"Item ${index + 1}\");\n\n  Future<void> _refresh() async {\n    await Future.delayed(Duration(seconds: 2));\n    setState(() {\n      items = List.generate(20, (index) => \"New Item ${index + 1}\");\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('Pull to Refresh Demo'),\n      ),\n      body: RefreshIndicator(\n        onRefresh: _refresh,\n        child: ListView.builder(\n          itemCount: items.length,\n          itemBuilder: (context, index) {\n            return ListTile(\n              title: Text(items[index]),\n            );\n          },\n        ),\n      ),\n    );\n  }\n}\n```\n\n# 설명\n\n- MyApp 위젯: 이것은 애플리케이션의 루트 위젯입니다.\n- HomePage 위젯: 이것은 풀-투-리프레시 기능이 구현된 메인 화면입니다.\n- RefreshIndicator 위젯: 이 위젯은 ListView를 감싸고 풀-투-리프레시 기능을 제공합니다. 사용자가 목록을 새로 고치기 위해 아래로 당기면 onRefresh 메서드가 호출됩니다.\n- \\_refresh 메서드: 이 메서드는 2초 동안 지연을 통해 네트워크 호출을 시뮬레이션합니다. 지연 후에 새로운 데이터를 보여주기 위해 항목 목록을 업데이트합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 결론\n\nPull-to-refresh는 현대 모바일 애플리케이션에서 필수적인 기능으로, 사용자 상호작용을 향상시켜 콘텐츠 업데이트를 쉽게 제공합니다. Flutter를 사용하면 RefreshIndicator 위젯을 활용하여 이 기능을 간편하고 효율적으로 구현할 수 있습니다.\n\n이 튜토리얼이 도움이 되었다면 박수를 눌러주시고, 플러터 튜토리얼과 팁을 더 받아보려면 팔로우해주세요. 여러분의 지원은 우리가 여러분의 개발 여정을 돕기 위해 더 많은 콘텐츠를 만들도록 격려합니다!\n\n즐거운 코딩하세요! 🚀\n","ogImage":{"url":"/assets/img/2024-06-23-SimpleFlutterpulltorefresh_0.png"},"coverImage":"/assets/img/2024-06-23-SimpleFlutterpulltorefresh_0.png","tag":["Tech"],"readingTime":3},{"title":"SwiftUI TextField 심화  이벤트, 포커스, 키보드 제어 방법","description":"","date":"2024-06-23 21:35","slug":"2024-06-23-AdvancedSwiftUITextFieldEventsFocusKeyboard","content":"\n이 글은 SwiftUI TextField 이벤트, 포커스 전환, 키보드 설정 및 기타 관련 경험, 기술 및 고려 사항을 탐색할 것입니다.\n\n## 이벤트\n\n### onEditingChanged\n\nTextField가 포커스를 얻을 때(편집 가능한 상태로 전환될 때), onEditingChanged는 주어진 메서드를 호출하고 값으로 true를 전달합니다. TextField가 포커스를 잃을 때, 다시 메서드를 호출하고 값을 false로 전달합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```swift\nstruct OnEditingChangedDemo: View {\n    @State var name = \"\"\n\n    var body: some View {\n        List {\n            TextField(\"이름:\", text: $name, onEditingChanged: getFocus)\n        }\n    }\n\n    func getFocus(focused: Bool) {\n        print(\"포커스 받음: \\(focused ? \"참\" : \"거짓\")\")\n    }\n}\n```\n\n이 매개변수의 이름은 사용자에게 모호함을 초래하기 쉽습니다. 사용자가 콘텐츠를 입력했는지 확인하는 데 onEditingChanged를 사용하지 마십시오.\n\niOS 15에서는 ParseableFormatStyle을 지원하는 새로 추가된 생성자에서 이 매개변수를 제공하지 않습니다. 따라서 새로운 Formatter를 사용하는 TextFields의 경우, 포커스를 얻었는지 또는 상실했는지를 확인하기 위해 다른 수단을 사용해야 합니다.\n\n# onCommit\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nonCommit은 사용자가 입력하는 중에 리턴 키를 누를 때 (또는 클릭할 때) 트리거됩니다 (코드 시뮬레이션으로는 트리거할 수 없음). 사용자가 리턴 키를 클릭하지 않으면(예: 직접 다른 TextField로 전환하는 경우) onCommit은 트리거되지 않습니다. onCommit이 트리거되는 동시에 TextField는 포커스를 잃게 됩니다.\n\n```js\nstruct OnCommitDemo: View {\n    @State var name = \"\"\n    var body: some View {\n        List {\n            TextField(\"이름:\", text: $name, onCommit: { print(\"커밋\") })\n        }\n    }\n}\n```\n\n사용자가 입력한 내용을 확인해야 하는 경우, onCommit과 onEditingChanged를 함께 사용하는 것이 좋습니다. 사용자의 입력 데이터를 실시간으로 처리하려면 SwiftUI TextField 고급 — 형식 지정 및 유효성 검사를 참고해주세요.\n\nonCommit은 SecureField에도 적용됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\niOS 15에서 추가된 ParseableFormatStyle을 지원하는 새 생성자는 해당 매개변수를 제공하지 않습니다. 동일한 효과를 얻으려면 새롭게 추가된 onSubmit을 사용할 수 있습니다.\n\n# onSubmit\n\nonSubmit은 SwiftUI 3.0에서 새로 추가된 기능입니다. onCommit 및 onEditingChanged는 각각의 TextField의 상태를 설명하지만 onSubmit은 한 뷰 내에서 여러 TextField의 통합 관리 및 일정 관리를 가능하게 합니다.\n\n```js\n// onSubmit의 정의\nextension View {\n    public func onSubmit(of triggers: SubmitTriggers = .text, _ action: @escaping (() -> Void)) -> some View\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래 코드는 onCommit과 동일한 동작을 구현할 것입니다:\n\n```js\nstruct OnSubmitDemo:View{\n    @State var name = \"\"\n    var body: some View{\n        List{\n            TextField(\"name:\",text: $name)\n                .onSubmit {\n                    print(\"commit\")\n                }\n        }\n    }\n}\n```\n\nonSubmit의 트리거 조건은 onCommit과 동일하며, 사용자가 “return”을 활성화하도록 요구합니다.\n\nonSubmit은 SecureField에도 적용됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 범위와 중첩\n\nonSubmit의 구현은 환경 값 TriggerSubmitAction을 설정하는 것에 기반하며 (아직 개발자에게 제공되지 않음) onSubmit은 범위를 가지고 있으며 (뷰 트리로 전달될 수 있음) 중첩될 수 있습니다.\n\n```js\nstruct OnSubmitDemo: View {\n    @State var text1 = \"\"\n    @State var text2 = \"\"\n    @State var text3 = \"\"\n    var body: some View {\n        Form {\n            Group {\n                TextField(\"text1\", text: $text1)\n                    .onSubmit { print(\"text1 commit\") }\n                TextField(\"text2\", text: $text2)\n                    .onSubmit { print(\"text2 commit\") }\n            }\n            .onSubmit { print(\"textfield in group commit\") }\n            TextField(\"text3\", text: $text3)\n                .onSubmit { print(\"text3 commit\") }\n        }\n        .onSubmit { print(\"textfield in form commit1\") }\n        .onSubmit { print(\"textfield in form commit2\") }\n    }\n}\n```\n\nTextField (text1)이 commit되면, 콘솔 출력은 다음과 같습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n양식에서의 텍스트 필드 커밋2\n양식에서의 텍스트 필드 커밋1\n그룹에서의 텍스트 필드 커밋\n텍스트1 커밋\n```\n\n외부에서 내부로 호출 순서임을 참고하십시오.\n\n# 제한된 범위\n\nsubmitScope를 사용하여 범위를 차단하고 (뷰 트리 상에서의 추가 전파를 제한합니다). 예를 들어, 위 코드에서는 그룹 뒤에 submitScope를 추가하십시오.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n그룹 {\n    TextField(\"text1\", text: $text1)\n        .onSubmit { print(\"text1 commit\") }\n    TextField(\"text2\", text: $text2)\n        .onSubmit { print(\"text2 commit\") }\n}\n.submitScope()  // scope blocking\n.onSubmit { print(\"textfield in group commit\") }\n```\n\nTextField1이 커밋되면 콘솔에 다음이 표시됩니다:\n\n```js\ntext1 commit\n```\n\n이 시점에서 onSubmit의 범위는 그룹 내로 제한됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n뷰에 여러 개의 TextFields가 있는 경우, onSubmit과 FocusState를 결합하여 훌륭한 사용자 경험을 얻을 수 있습니다.\n\n# searchable 지원\n\niOS 15에서는 새로운 검색 상자도 \"return\"을 클릭할 때 onSubmit을 트리거하지만, 트리거를 검색으로 설정해야 합니다:\n\n```js\nstruct OnSubmitForSearchableDemo:View{\n    @State var name = \"\"\n    @State var searchText = \"\"\n    var body: some View{\n        NavigationView{\n            Form{\n                TextField(\"이름:\",text:$name)\n                    .onSubmit {print(\"textField 커밋\")}\n            }\n            .searchable(text: $searchText)\n            .onSubmit(of: .search) { //\n                print(\"searchField 커밋\")\n            }\n        }\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nSubmitTriggers의 타입은 OptionSet입니다. onSubmit 메서드는 환경 내에서 뷰 트리에서 SubmitTriggers에 포함된 값을 계속 전달합니다. onSubmit에서 받는 SubmitTriggers 값이 onSubmit에서 지정된 SubmitTriggers 세트에 포함되지 않으면 전달이 종료됩니다. 간단히 말해, onSubmit(of:.search)은 TextField에서 생성된 커밋 상태를 차단하고 그 반대도 마찬가지입니다.\n\n예를 들어, 위 코드에서 searchable 다음에 onSubmt(of:.text)를 추가하면 TextField의 커밋 이벤트에 응답할 수 없게 됩니다.\n\n```js\n.searchable(text: $searchText)\n            .onSubmit(of: .search) {\n                print(\"searchField commit1\")\n            }\n            .onSubmit {print(\"textField commit\")} //cannot be triggered, blocked by search\n```\n\n따라서 TextField와 검색 상자를 모두 처리할 때 호출 순서에 특별히 주의해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음 코드는 하나의 onSubmit에서 TextField와 검색 상자를 모두 지원할 수 있습니다:\n\n```js\n.onSubmit(of: [.text, .search]) {\n  print(\"무언가가 제출되었습니다\")\n}\n```\n\n다음 코드는 searchable 보다 onSubmit(of:.search)가 먼저 배치되어 있기 때문에 어느 것도 트리거하지 않습니다.\n\n```js\nNavigationView{\n    Form{\n        TextField(\"이름:\", text: $name)\n            .onSubmit {print(\"textField 제출\")}\n    }\n    .onSubmit(of: .search) { // 트리거 안 됨\n        print(\"searchField 제출1\")\n    }\n    .searchable(text: $searchText)\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 초점\n\niOS 15(몬테레이) 이전에는 SwiftUI에서 TextField(예 : becomeFirstResponder)에 초점을 맞추는 방법을 제공하지 않았습니다. 오랫동안 개발자들은 비슈위 방법에 의존하여 비슷한 기능을 구현해야 했습니다.\n\nSwiftUI 3.0에서 Apple은 개발자들에게 onSubmit과 유사한, 높은 수준의 뷰 계층 구조에서 텍스트 필드의 초점을 일관되게 결정하고 관리할 수 있는 예상보다 훨씬 더 나은 솔루션을 제공했습니다.\n\n# 기본 사용법\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nSwiftUI에서는 새 FocusState 프로퍼티 래퍼를 제공하여이 뷰 내의 TextField에 포커스가 있는지 여부를 결정하는 데 도움을 줍니다. focused를 사용하여 FocusState를 특정 TextField와 연결할 수 있습니다.\n\n```swift\nstruct OnFocusDemo: View {\n    @FocusState var isNameFocused: Bool\n    @State var name = \"\"\n\n    var body: some View {\n        List {\n            TextField(\"이름:\", text: $name)\n                .focused($isNameFocused)\n        }\n        .onChange(of: isNameFocused) { value in\n            print(value)\n        }\n    }\n}\n```\n\n위 코드는 TextField가 포커스를 얻을 때 isNameFocused를 true로 설정하고 포커스를 잃을 때 false로 설정합니다.\n\n동일한 뷰 내에 여러 개의 TextField가있는 경우 각 해당 TextField와 연결할 여러 FocusStates를 생성할 수 있습니다. 예를 들어:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 방법은 뷰에 더 많은 TextField가 있는 경우 귀찮아지고 통일된 관리에 도움이 되지 않습니다. 다행히 FocusState는 Boolean 값뿐만 아니라 모든 해시 타입도 지원합니다. Hashable 프로토콜을 준수하는 enum을 사용하여 뷰 내 여러 TextField의 포커스를 관리할 수 있습니다. 다음 코드는 위의 코드와 동일한 기능을 수행합니다:\n\n```js\nstruct OnFocusDemo:View{\n    @FocusState var focus:FocusedField?\n    @State var name = \"\"\n    @State var password = \"\"\n    var body: some View{\n        List{\n            TextField(\"name:\",text:$name)\n                .focused($focus, equals: .name)\n            SecureField(\"password:\",text:$password)\n                .focused($focus,equals: .password)\n        }\n        .onChange(of: focus, perform: {print($0)})\n    }\n\n    enum FocusedField:Hashable{\n        case name,password\n    }\n}\n```\n\n# 특정 TextField가 뷰를 표시한 직후에 즉시 포커스를 받도록 만들기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nFocusState를 사용하면 지정된 TextField가 포커스를 얻고 뷰를 표시한 후 즉시 키보드가 팝업되게 할 수 있어요:\n\n```js\nstruct OnFocusDemo: View {\n    @FocusState var focus: FocusedField?\n    @State var name = \"\"\n    @State var password = \"\"\n\n    var body: some View {\n        List {\n            TextField(\"이름:\", text: $name)\n                .focused($focus, equals: .name)\n            SecureField(\"비밀번호:\", text: $password)\n                .focused($focus, equals: .password)\n        }\n        .onAppear {\n            DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {\n                focus = .name\n            }\n        }\n    }\n\n    enum FocusedField: Hashable {\n        case name, password\n    }\n}\n```\n\n뷰 초기화 중에 값을 할당하는 것은 잘못된 방법이에요. onAppear에서도 TextField가 포커스를 얻을 시간을 지연시켜야 해요 (iOS 16에서는 지연이 필요하지 않아요).\n\n# 여러 개의 TextField 사이에서 포커스 전환하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n주의력과 onSubmit을 결합하여 한 TextField에서 입력을 완료하고(리턴을 클릭할 때) 자동으로 다음 TextField로 포커스를 전환하는 효과를 얻을 수 있어요.\n\n```js\nstruct OnFocusDemo:View{\n    @FocusState var focus:FocusedField?\n    @State var name = \"\"\n    @State var email = \"\"\n    @State var phoneNumber = \"\"\n    var body: some View{\n        List{\n            TextField(\"이름:\",text:$name)\n                .focused($focus, equals: .name)\n                .onSubmit {\n                    focus = .email\n                }\n            TextField(\"이메일:\",text:$email)\n                .focused($focus,equals: .email)\n                .onSubmit {\n                    focus = .phone\n                }\n            TextField(\"전화번호:\",text:$phoneNumber)\n                .focused($focus, equals: .phone)\n                .onSubmit {\n                    if !name.isEmpty && !email.isEmpty && !phoneNumber.isEmpty {\n                        submit()\n                    }\n                }\n        }\n    }\n\n    private func submit(){\n        // 모든 정보 제출\n        print(\"제출\")\n    }\n    enum FocusedField:Hashable{\n        case name,email,phone\n    }\n}\n```\n\n위의 코드는 onSubmit 전달 기능을 활용하여 다음과 같이 변환될 수도 있어요:\n\n```js\nList {\n    TextField(\"이름:\", text: $name)\n        .focused($focus, equals: .name)\n    TextField(\"이메일:\", text: $email)\n        .focused($focus, equals: .email)\n    TextField(\"전화번호:\", text: $phoneNumber)\n        .focused($focus, equals: .phone)\n}\n.onSubmit {\n    switch focus {\n    case .name:\n        focus = .email\n    case .email:\n        focus = .phone\n    case .phone:\n        if !name.isEmpty, !email.isEmpty, !phoneNumber.isEmpty {\n            submit()\n        }\n    default:\n        break\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n화면 버튼(예: 보조 키보드 보기) 또는 키보드 단축키를 결합하여 포커스를 전환하거나 특정 TextField로 이동할 수도 있습니다.\n\n# 포커스를 얻기 위한 키보드 단축키 사용\n\n보안 필드를 포함한 여러 개의 TextField가 있는 뷰에서는 Tab 키를 사용하여 TextField에서 포커스를 직접 전환할 수 있습니다. 그러나 SwiftUI는 키보드 단축키를 사용하여 특정 TextField에 포커스를 설정하는 기능을 직접 제공하지 않습니다. FocusState와 keyboardShortcut을 결합하여 iPad 및 MacOS에서 이 기능을 얻을 수 있습니다.\n\n키보드 단축키 바인딩을 지원하는 focused를 생성하세요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```swift\npublic extension View {\n    func focused(_ condition: FocusState<Bool>.Binding, key: KeyEquivalent, modifiers: EventModifiers = .command) -> some View {\n        focused(condition)\n            .background(Button(\"\") {\n                condition.wrappedValue = true\n            }\n            .keyboardShortcut(key, modifiers: modifiers)\n            .hidden()\n            )\n    }\n\n    func focused<Value>(_ binding: FocusState<Value>.Binding, equals value: Value, key: KeyEquivalent, modifiers: EventModifiers = .command) -> some View where Value: Hashable {\n        focused(binding, equals: value)\n            .background(Button(\"\") {\n                binding.wrappedValue = value\n            }\n            .keyboardShortcut(key, modifiers: modifiers)\n            .hidden()\n            )\n    }\n}\n```\n\n코드 사용법:\n\n```swift\nstruct ShortcutFocusDemo: View {\n    @FocusState var focus: FouceField?\n    @State private var email = \"\"\n    @State private var address = \"\"\n    var body: some View {\n        Form {\n            TextField(\"이메일\", text: $email)\n                .focused($focus, equals: .email, key: \"t\")\n            TextField(\"주소\", text: $address)\n                .focused($focus, equals: .address, key: \"a\", modifiers: [.command, .shift, .option])\n        }\n    }\n\n    enum FouceField: Hashable {\n        case email\n        case address\n    }\n}\n```\n\n사용자가 ⌘ + T를 입력하면 이메일을 처리하는 TextField에 초점이 맞춰집니다. 사용자가 ⌘ + ⌥ + ⇧ + A를 입력하면 주소를 처리하는 TextField에 초점이 맞춰집니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 자체 onEditingChanged 만들기\n\n개별 TextField의 포커스 상태를 확인하는 가장 좋은 방법은 여전히 onEditingChanged를 사용하는 것입니다. 그러나 새 포매터와 같이 onEditingChanged를 사용할 수 없는 경우에는 FocusState를 사용하여 비슷한 효과를 얻을 수 있습니다.\n\n- 개별 TextField의 포커스 상태 확인\n\n```swift\npublic extension View {\n    func focused(_ condition: FocusState<Bool>.Binding, onFocus: @escaping (Bool) -> Void) -> some View {\n        focused(condition)\n            .onChange(of: condition.wrappedValue) { value in\n                onFocus(value == true)\n            }\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n사용 방법:\n\n```js\nstruct onEditingChangedFocusVersion:View{\n    @FocusState var focus:Bool\n    @State var price = 0\n    var body: some View{\n        Form{\n            TextField(\"가격:\",value:$price,format: .number)\n                .focused($focus){ focused in\n                    print(focused)\n                }\n        }\n    }\n}\n```\n\n- 여러 TextFields 확인\n\nTextField가 포커스를 잃을 때 여러 번 호출을 피하기 위해 뷰 계층 구조에서 마지막 포커스된 TextField의 FocusState 값을 저장해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\npublic extension View {\n    func storeLastFocus<Value: Hashable>(current: FocusState<Value?>.Binding, last: Binding<Value?>) -> some View {\n        onChange(of: current.wrappedValue) { _ in\n            if current.wrappedValue != last.wrappedValue {\n                last.wrappedValue = current.wrappedValue\n            }\n        }\n    }\n\n    func focused<Value>(_ binding: FocusState<Value>.Binding, equals value: Value, last: Value?, onFocus: @escaping (Bool) -> Void) -> some View where Value: Hashable {\n        return focused(binding, equals: value)\n            .onChange(of: binding.wrappedValue) { focusValue in\n                if focusValue == value {\n                    onFocus(true)\n                } else if last == value { // only call once\n                    onFocus(false)\n                }\n            }\n    }\n}\n```\n\n호출:\n\n```js\nstruct OnFocusView: View {\n    @FocusState private var focused: Focus?\n    @State private var lastFocused: Focus?\n    @State private var name = \"\"\n    @State private var email = \"\"\n    @State private var address = \"\"\n    var body: some View {\n        List {\n            TextField(\"이름:\", text: $name)\n                .focused($focused, equals: .name, last: lastFocused) {\n                    print(\"이름:\", $0)\n                }\n            TextField(\"이메일:\", text: $email)\n                .focused($focused, equals: .email, last: lastFocused) {\n                    print(\"이메일:\", $0)\n                }\n            TextField(\"주소:\", text: $address)\n                .focused($focused, equals: .address, last: lastFocused) {\n                    print(\"주소:\", $0)\n                }\n        }\n        .storeLastFocus(current: $focused, last: $lastFocused) // 최신 포커스 값을 저장합니다.\n    }\n\n    enum Focus {\n        case name, email, address\n    }\n}\n```\n\n# 키보드\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nTextField를 사용하다보면 소프트웨어 키보드와 함께 작업해야 합니다. 이 섹션에서는 키보드와 관련된 몇 가지 예제를 소개할 것입니다.\n\n## 키보드 유형\n\niPhone에서 keyboardType를 통해 소프트웨어 키보드 유형을 설정하여 사용자 입력을 용이하게 하거나 입력 문자 범위를 제한할 수 있습니다.\n\n예시:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```swift\nstruct KeyboardTypeDemo: View {\n    @State var price: Double = 0\n    var body: some View {\n        Form {\n            TextField(\"Price:\", value: $price, format: .number.precision(.fractionLength(2)))\n                .keyboardType(.decimalPad) // 소수점 숫자 키보드 지원\n        }\n    }\n}\n```\n\n위 이미지는 \"/assets/img/2024-06-23-AdvancedSwiftUITextFieldEventsFocusKeyboard_0.png\" 입니다.\n\n현재, 지원되는 키보드 유형은 총 11가지이며, 다음과 같습니다:\n\n- asciiCapable\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 번호 및 구두점 테이블입니다.\n\n| numbersAndPunctuation   |\n| ----------------------- |\n| Numbers and punctuation |\n\nURL 테이블로 아래 내용을 변환해주세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nURL 주소를 입력하는 데 유용하며, 문자 및 '.', '/', '.com'을 포함할 수 있습니다.\n\n- numberPad\n\n해당 지역의 숫자 세트를 사용합니다(0-9, ۰-۹, ०-९ 등). 양의 정수나 PIN에 적합합니다.\n\n- phonePad\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n전화기에서 사용되는 숫자 및 다른 기호, 예를 들면 ‘\\*#+’\n\n- namePhonePad\n\n텍스트 및 전화번호 입력에 편리합니다. 문자 상태는 asciiCapable과 유사하며, 숫자 상태는 numberPad와 유사합니다.\n\n- emailAddress\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n'@'를 입력하는 데 편리한 아스키 호환 키보드입니다.\n\n- decimalPad\n\n소수점이 포함된 숫자 키패드입니다. 자세한 내용은 위의 이미지를 참조해주세요.\n\n- 트위터\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아스키 지원 키보드에는 '@#'이 포함되어 있습니다.\n\n- 웹 검색\n\n'.'을 포함한 아스키 지원 키보드이며 'return' 키는 'go'로 표시됩니다.\n\n- 아스키 지원 번호 패드\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nAn asciiCapable 키보드에는 숫자가 포함되어 있습니다.\n\nApple은 다양한 키보드 모드를 제공하지만, 경우에 따라 사용자의 요구 사항을 충족시키지 못할 수도 있습니다.\n\n예를 들어, numberPad 및 decimalPad에는 \"-\" 및 \"return\"이 없습니다. SwiftUI 3.0 이전에는 주요 뷰에 별도로 그리거나 SwiftUI 이외의 방법을 사용하여 문제를 해결해야 했습니다. 그러나 SwiftUI 3.0에서는 네이티브 설정 키보드 보조 뷰(자세한 내용은 아래에 설명되어 있음) 추가로 위 문제를 해결하는 것이 이제 더 어렵지 않아졌습니다.\n\n# TextContentType를 통해 제안을 받아보세요\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n특정 iOS 앱을 사용할 때 텍스트를 입력할 때 소프트웨어 키보드가 자동으로 입력해야 할 내용을 제안하는 경우가 있습니다. 이는 전화 번호, 이메일, 인증 코드 등을 텍스트ContentType를 통해 얻는 효과입니다.\n\nTextField의 UITextContentType을 설정함으로써 시스템은 입력 중에 입력하려는 콘텐츠를 지능적으로 추론하고 제안을 표시합니다.\n\n다음 코드는 비밀번호 입력 시 키체인을 사용할 수 있도록 합니다.\n\n```js\nstruct KeyboardTypeDemo: View {\n    @State var password = \"\"\n    var body: some View {\n        Form {\n            SecureField(\"\", text: $password)\n                .textContentType(.password)\n        }\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-06-23-AdvancedSwiftUITextFieldEventsFocusKeyboard_1.png\" />\n\n이메일 주소를 입력할 때 연락처 및 이메일에서 비슷한 이메일 주소를 제안하는 코드입니다:\n\n```js\nstruct KeyboardTypeDemo: View {\n    @State var email = \"\"\n    var body: some View {\n        Form {\n            TextField(\"\", text: $email)\n                .textContentType(.emailAddress)\n        }\n    }\n}\n```\n\n<img src=\"/assets/img/2024-06-23-AdvancedSwiftUITextFieldEventsFocusKeyboard_2.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음은 설정할 수 있는 여러 종류의 UITextContentType이 있습니다. 흔히 사용되는 것들 중 일부는 다음과 같습니다:\n\n- password\n- 이름 옵션, 예를 들어 name, givenName, middleName 등이 있습니다.\n- 주소 옵션, 예를 듀 addressCity, fullStreetAddress, postalCode 등이 있습니다.\n- telephoneNumber\n- emailAddress\n- oneTimeCode (인증 코드)\n\n# 키보드 해제\n\n일부 경우에는 사용자가 텍스트 입력을 완료한 후 소프트웨어 키보드를 해제하여 더 많은 디스플레이 공간을 확보해야 할 수 있습니다. 일부 키보드 유형에는 \"return\" 버튼이 없기 때문에 프로그래밍을 사용하여 키보드를 사라지게 해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n또한 가끔은 사용자가 \"return\" 버튼을 클릭하지 않고도 화면의 다른 영역을 클릭하거나 목록을 스크롤하여 키보드를 숨길 수 있게 하려고 할 수도 있습니다. 상호 작용 경험을 향상시키기 위해 프로그래밍을 사용하여 키보드를 사라지게 할 필요가 있습니다.\n\n- FocusState를 사용하여 키보드 숨기기\n\n해당 FocusState가 TextField에 설정되면 값을 \"false\" 또는 \"nil\"로 설정하여 키보드를 숨길 수 있습니다.\n\n```js\nstruct HideKeyboardView: View {\n    @State private var name = \"\"\n    @FocusState private var nameIsFocused: Bool\n\n    var body: some View {\n        Form {\n            TextField(\"이름을 입력하세요\", text: $name)\n                .focused($nameIsFocused)\n            Button(\"키보드 숨기기\") {\n                nameIsFocused = false\n            }\n        }\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 기타 상황\n\n대부분의 경우, 우리는 UIkit에서 제공하는 메서드를 직접 사용하여 키보드를 숨길 수 있습니다.\n\n```js\nUIApplication.shared.sendAction(#selector(UIResponder.resignFirstResponder), to: nil, from: nil, for: nil)\n```\n\n예를 들어, 사용자가 뷰를 드래그할 때 키보드를 숨기는 다음 코드가 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n구조 ResignKeyboardOnDragGesture: ViewModifier {\n    var gesture = DragGesture().onChanged { _ in\n        UIApplication.shared.sendAction(#selector(UIResponder.resignFirstResponder), to: nil, from: nil, for: nil)\n    }\n\n    func body(content: Content) -> some View {\n        content.gesture(gesture)\n    }\n}\nextension View {\n    func dismissKeyboard() -> some View {\n        return modifier(ResignKeyboardOnDragGesture())\n    }\n}\n구조 HideKeyboardView: View {\n    @State private var name = \"\"\n    var body: some View {\n        Form {\n            TextField(\"이름을 입력하세요\", text: $name)\n        }\n        .dismissKeyboard()\n    }\n}\n```\n\n# 키보드 어시스턴트 뷰\n\n# 툴바를 통해 생성됨\n\nSwiftUI 3.0에서는 ToolbarItem(placement: .keyboard, content: View)를 사용하여 키보드 어시스턴트 뷰(inputAccessoryView)를 생성할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n입력 보조 뷰를 통해 이전에 처리하기 어려웠던 많은 문제들을 해결하고 상호 작용 수단을 더 많이 제공할 수 있습니다.\n\n다음 코드는 소수점 숫자를 입력할 때 양/음수 변환 및 확인 버튼을 추가합니다:\n\n```js\nimport Introspect\nstruct ToolbarKeyboardDemo: View {\n    @State var price = \"\"\n    var body: some View {\n        Form {\n            TextField(\"가격:\", text: $price)\n                .keyboardType(.decimalPad)\n                .toolbar {\n                    ToolbarItem(placement: .keyboard) {\n                        HStack {\n                            Button(\"-/+\") {\n                                if price.hasPrefix(\"-\") {\n                                    price.removeFirst()\n                                } else {\n                                    price = \"-\" + price\n                                }\n                            }\n                            .buttonStyle(.bordered)\n                            Spacer()\n                            Button(\"완료\") {\n                                UIApplication.shared.sendAction(#selector(UIResponder.resignFirstResponder), to: nil, from: nil, for: nil)\n                                // 해야 할 일을 수행합니다\n                            }\n                            .buttonStyle(.bordered)\n                        }\n                        .padding(.horizontal, 30)\n                    }\n                }\n        }\n    }\n}\n```\n\n<img src=\"/assets/img/2024-06-23-AdvancedSwiftUITextFieldEventsFocusKeyboard_3.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n안타깝지만, ToolbarItem을 통해 입력 보조 뷰를 설정하는 데는 아직 몇 가지 제한 사항이 있습니다:\n\n- 표시 콘텐츠 제한\n\n높이가 고정되어 있어 악세서리 뷰의 전체 디스플레이 영역을 활용할 수 없습니다. 다른 종류의 툴바와 마찬가지로 SwiftUI가 콘텐츠의 레이아웃에 개입합니다.\n\n- 같은 뷰 내에서 여러 텍스트 필드에 대해 별도의 액세서리 뷰를 설정할 수 없음\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n보다 복잡한 조건부 구문은 ToolbarItem에서 사용할 수 없습니다. 다른 텍스트 필드에 대해 별도로 설정하더라도 SwiftUI는 모든 내용을 함께 표시하기 위해 병합합니다.\n\n# UIKit을 통해 생성하기\n\n현재 단계에서는 SwiftUI에 대한 키보드 액세서리 뷰를 UIKit을 통해 생성하는 것이 여전히 최적의 솔루션이 됩니다. 화면 표시에 대한 완벽한 제어를 얻을 수 있을 뿐만 아니라 동일한 뷰 내부의 여러 텍스트 필드를 별도로 설정할 수도 있습니다.\n\n```js\nextension UIView {\n    func constrainEdges(to other: UIView) {\n        translatesAutoresizingMaskIntoConstraints = false\n        NSLayoutConstraint.activate([\n            leadingAnchor.constraint(equalTo: other.leadingAnchor),\n            trailingAnchor.constraint(equalTo: other.trailingAnchor),\n            topAnchor.constraint(equalTo: other.topAnchor),\n            bottomAnchor.constraint(equalTo: other.bottomAnchor),\n        ])\n    }\n}\n\nextension View {\n    func inputAccessoryView<Content: View>(@ViewBuilder content: @escaping () -> Content) -> some View {\n        introspectTextField { td in\n            let viewController = UIHostingController(rootView: content())\n            viewController.view.constrainEdges(to: viewController.view)\n            td.inputAccessoryView = viewController.view\n        }\n    }\n    func inputAccessoryView<Content: View>(content: Content) -> some View {\n        introspectTextField { td in\n            let viewController = UIHostingController(rootView: content)\n            viewController.view.constrainEdges(to: viewController.view)\n            td.inputAccessoryView = viewController.view\n        }\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n사용법:\n\n```js\nstruct OnFocusDemo: View {\n    @FocusState var focus: FocusedField?\n    @State var name = \"\"\n    @State var email = \"\"\n    @State var phoneNumber = \"\"\n    var body: some View {\n        Form {\n            TextField(\"이름:\", text: $name)\n                .focused($focus, equals: .name)\n                .inputAccessoryView(content: accessoryView(focus: .name))\n\n            TextField(\"이메일:\", text: $email)\n                .focused($focus, equals: .email)\n                .inputAccessoryView(content: accessoryView(focus: .email))\n\n            TextField(\"전화번호:\", text: $phoneNumber)\n                .focused($focus, equals: .phone)\n        }\n        .onSubmit {\n            switch focus {\n            case .name:\n                focus = .email\n            case .email:\n                focus = .phone\n            case .phone:\n                if !name.isEmpty, !email.isEmpty, !phoneNumber.isEmpty {}\n            default:\n                break\n            }\n        }\n    }\n}\n\nstruct accessoryView: View {\n    let focus: FocusedField?\n    var body: some View {\n        switch focus {\n        case .name:\n            Button(\"이름\") {}.padding(.vertical, 10)\n        case .email:\n            Button(\"이메일\") {}.padding(.vertical, 10)\n        default:\n            EmptyView()\n        }\n    }\n}\n```\n\n# 사용자 정의 제출 레이블\n\n기본적으로 TextField (SecureField)의 키보드에 대한 제출 동작 버튼은 \"return\"입니다. SwiftUI 3.0에서 소개된 \"submitLabel\" 수정자를 사용하면 \"return\" 버튼을 입력 콘텍스트와 관련된 텍스트로 수정할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```swift\nTextField(\"사용자 이름\", text: $username)\n            .submitLabel(.next)\n```\n\n<img src=\"/assets/img/2024-06-23-AdvancedSwiftUITextFieldEventsFocusKeyboard_4.png\" />\n\n현재 지원되는 유형은 다음과 같습니다:\n\n- continue\n- done\n- go\n- join\n- next\n- return\n- route\n- search\n- send\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n예를 들어, 이전 코드에서는 이름, 이메일 및 전화번호에 대한 서로 다른 표시를 설정할 수 있습니다:\n\n```js\nTextField(\"이름:\", text: $name)\n                .focused($focus, equals: .name)\n                .submitLabel(.next)\nTextField(\"이메일:\", text: $email)\n                .focused($focus, equals: .email)\n                .submitLabel(.next)\n\nTextField(\"전화번호:\", text: $phoneNumber)\n                .focused($focus, equals: .phone)\n                .submitLabel(.return)\n```\n\n# 결론\n\nSwiftUI 1.0부터 Apple은 TextField의 기능을 지속적으로 개선해 왔습니다. 버전 3.0에서 SwiftUI는 더 많은 네이티브 수정자를 제공하는데 그치지 않고 FocusState와 onSubmit과 같은 통합 관리 논리를 제공합니다. 믿음직스러운 2~3년 뒤에는 SwiftUI의 주요 컨트롤의 네이티브 기능이 해당하는 UIKit 컨트롤과 맞먹을 것이라고 믿습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만약 이 글이 도움이 되었거나 즐겁게 읽으셨다면, 제 글을 지원하기 위해 기부를 고려해 주세요. 여러분의 기부는 저가 계속해서 가치 있는 콘텐츠를 만드는데 도움이 될 것입니다.\nPatreon, Buy Me a Coffee 또는 PayPal을 통해 기부할 수 있습니다.\n\n```js\n연락하고 싶다면?\n\nTwitter에서 @fatbobman을 팔로우하세요.\n```\n","ogImage":{"url":"/assets/img/2024-06-23-AdvancedSwiftUITextFieldEventsFocusKeyboard_0.png"},"coverImage":"/assets/img/2024-06-23-AdvancedSwiftUITextFieldEventsFocusKeyboard_0.png","tag":["Tech"],"readingTime":36},{"title":"SwiftUI 놀라운 UI 프레임워크의 매력 ","description":"","date":"2024-06-23 21:34","slug":"2024-06-23-SwiftUIWhataBeauty","content":"\n안녕하세요 여러분! 🎉\n\niOS 개발 여정을 함께 공유해 드릴 것에 흥분되고 있어요. 최근에 SwiftUI를 사용하여 애플리케이션을 개발했는데, 정말 멋진 경험이었어요!\n\n# 앱 소개\n\n이 앱은 초보자들이 다양한 프로그래밍 언어의 기초를 배울 수 있도록 설계되었어요. 다음을 포함합니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 자원 허브: 기본 사항을 학습하기 위한 포괄적인 자료 제공\n- 대화식 퀴즈: 여러 번 풀어서 학습을 강화할 수 있는 퀴즈로 지식을 테스트해보세요.\n- 다국어 지원: 현재 앱은 세 가지 다른 프로그래밍 언어에 대한 자습서를 제공합니다.\n\n아직 앱을 앱 스토어에 출시하지는 않았지만, 코드를 확인하고 피드백을 주시면 정말 감사하겠습니다. 앱을 계속 개선하고 확장하는 데 여러분의 통찰력은 귀중합니다.\n\n# 확인해보세요!\n\n여기에 제 프로젝트의 GitHub 링크가 있습니다. 코드를 살펴보고 앱을 시도해보시고 생각을 나눠주세요!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n피드백과 제안을 기다리고 있어요. 즐거운 코딩하세요! 🚀\n","ogImage":{"url":"/assets/img/2024-06-23-SwiftUIWhataBeauty_0.png"},"coverImage":"/assets/img/2024-06-23-SwiftUIWhataBeauty_0.png","tag":["Tech"],"readingTime":2},{"title":"MVVM 아키텍처에서 필드 검증하는 방법 초보자를 위한 가이드","description":"","date":"2024-06-23 21:32","slug":"2024-06-23-FieldValidationinMVVMArchitectureABeginersGuide","content":"\n<img src=\"/assets/img/2024-06-23-FieldValidationinMVVMArchitectureABeginersGuide_0.png\" />\n\n# 소개\n\n현대 앱 개발 분야에서 사용자 입력이 유효하고 안전한지 확인하는 것은 중요합니다. 특히 사용자 등록 프로세스에서 이는 매우 중요해집니다. MVVM(Model-View-ViewModel)과 같은 아키텍처 패턴에 진입하는 초보자들에게는 필드 유효성 검사를 포함하는 것이 어렵게 느껴질 수 있습니다. 이 문서는 특별히 이러한 목적을 위해 디자인된 코드 조각의 실제 예제를 사용하여 이 프로세스를 명확하게 설명하는 것을 목표로 합니다.\n\n# MVVM 아키텍처 이해하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n필드 유효성 검사의 구체적인 내용에 대해 들어가기 전에 MVVM 아키텍처를 간단히 살펴보겠습니다. MVVM은 Model-View-ViewModel의 약자입니다. GUI(그래픽 사용자 인터페이스) 개발을 비즈니스 로직 또는 백엔드 로직(데이터 모델)과 분리하는 구조적 디자인 패턴입니다. 'View'는 UI를 나타내며, 'ViewModel'은 공개 속성과 명령을 노출하는 뷰의 추상화입니다. 'Model'은 데이터 및 경우에 따라 비즈니스 로직을 나타냅니다.\n\n# MVVM에서의 유효성 검사 프로세스\n\n인포그래픽은 앱 개발에서 Model-View-ViewModel (MVVM) 패턴 내에서 사용자 데이터 유효성 검사가 어떻게 발생하는지를 설명합니다. 이 프로세스에서 주요 단계는 다음과 같습니다:\n\n![Field Validation in MVVM Architecture](/assets/img/2024-06-23-FieldValidationinMVVMArchitectureABeginersGuide_1.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 뷰:\n\n- 사용자들이 등록 양식 필드에 데이터를 입력합니다.\n- 텍스트 필드 같은 시각적 요소가 사용자 입력을 수집합니다.\n\n## 뷰와 ViewModel 간 통신:\n\n- 뷰에 입력된 데이터는 ViewModel로 전달됩니다.\n- 이는 데이터 바인딩을 통해하거나 ViewModel에서 메소드를 호출함으로써 이루어질 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## ViewModel:\n\n- ViewModel은 받은 데이터를 처리합니다.\n- 데이터 유효성 검사는 ValidationFieldsHelper와 같은 메서드를 사용하여 수행됩니다.\n- ViewModel은 유효성 검사 결과에 따라 어떤 작업을 수행할지 결정합니다 (예: 등록 버튼 활성화).\n\n## ViewModel에서 View로의 통신:\n\n- ViewModel은 유효성 검사 결과를 View로 다시 보냅니다.\n- 이 결과를 바탕으로 View는 UI를 업데이트할 수 있습니다. 예를 들어 텍스트 필드의 테두리 색상을 변경(오류는 빨강, 올바른 입력은 초록)하거나 오류 메시지를 표시할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 모델:\n\n- 성공적인 검증 후, ViewModel은 모델과 상호 작용하여 사용자 데이터를 저장하거나 다른 비즈니스 로직과 관련된 작업을 수행할 수 있습니다.\n\n# 필드 유효성 검사\n\n필드 유효성 검사는 사용자 등록 프로세스에서 필수적입니다. 사용자가 입력한 데이터가 처리되거나 저장되기 전에 특정 기준을 충족시켜야 함을 보장합니다. 이는 보안을 향상시키는데 그치지 않고 사용자 오류를 미리 잡아내고 사용자를 올바르게 안내하여 사용자 경험을 향상시킵니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```swift\n구조 ValidationFieldsHelper {\n\n    static func isValidName(_ name: String) -> Bool {\n        let namePredicate = NSPredicate(format:\"SELF MATCHES %@\", \"^[a-zA-Z ]+$\")\n        return namePredicate.evaluate(with: name)\n    }\n\n    static func isValidEmail(_ email: String) -> Bool {\n        let emailPredicate = NSPredicate(format:\"SELF MATCHES %@\", \"[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,}\")\n        return emailPredicate.evaluate(with: email)\n    }\n\n    static func isValidPassword(_ password: String) -> Bool {\n        let passwordRegex = \"^(?=.*[A-Za-z])(?=.*\\\\d)(?=.*[@$!%*?&])[A-Za-z\\\\d@$!%*?&]{8,}$\"\n        let passwordPredicate = NSPredicate(format:\"SELF MATCHES %@\", passwordRegex)\n        return passwordPredicate.evaluate(with: password)\n    }\n\n    static func isValidAge(_ age: String) -> Bool {\n        let ageRegex = \"^[0-9]{1,2}$\"\n        let agePredicate = NSPredicate(format:\"SELF MATCHES %@\", ageRegex)\n        return agePredicate.evaluate(with: age)\n    }\n}\n```\n\nSwift의 ValidationFieldsHelper 구조는 필드 유효성 검사를 위한 정적 메서드를 사용하여 코드 조직화와 가독성을 높입니다. 구조체는 인스턴스 생성 없이 관련 기능을 캡슐화하는 방법을 제공하며, 이는 유효성 검사와 같은 상태가 없는 유틸리티 함수에 이상적입니다. 정적 메서드를 사용하면 이러한 유틸리티 함수를 쉽게 재사용하고 애플리케이션 전반에 액세스할 수 있게 합니다. 이들은 코드에 네임스페이스와 유사한 구조를 제공하여 충돌을 방지하고 단순함을 유지합니다. 이 접근 방식을 통해 애플리케이션에서 효율적이고 명확한 유효성 검사 프로세스를 구현할 수 있습니다.\n\n# MVVM의 모델: UserRegistrationModel\n\n## 모델의 역할 이해\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nMVVM 아키텍처에서 Model은 어플리케이션의 데이터와 비즈니스 로직을 나타냅니다. 사용자 등록에 대한 맥락에서 UserRegistrationModel은 사용자 등록과 관련된 모든 정보를 보유하는 데이터 구조 역할을 합니다.\n\n## UserRegistrationModelProtocol\n\n```swift\nprotocol UserRegistrationModelProtocol: Codable {\n    var id: Int? { get }\n    var username: String? { get }\n    var email: String? { get }\n    var firstName: String? { get }\n    var lastName: String? { get }\n    var gender: String? { get }\n    var image: String? { get }\n    var token: String? { get }\n    var age: String? { get }\n\n    var asData: Data? { get }\n}\n```\n\n목적: 사용자 등록 모델에 필요한 속성과 기능을 개요화하는 프로토콜을 정의합니다. Codable을 준수하면 데이터의 직렬화와 역직렬화가 쉬워집니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n주요 기능: asData 계산 속성이 특히 주목할 만합니다. 이는 모델 인스턴스를 Data로 쉽게 변환하는 편리한 방법을 제공하며, 네트워크 통신이나 로컬 저장에 유용합니다.\n\n## Encodable에 대한 확장\n\n```swift\nextension Encodable {\n    var asData: Data? {\n        try? JSONEncoder().encode(self)\n    }\n}\n```\n\n기능: Encodable에 대한 이 확장은 준수하는 모든 타입이 자신을 손쉽게 Data로 변환할 수 있습니다. JSON 인코딩을 처리하기 위한 유용한 유틸리티입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 사용자 등록 모델 구조체\n\n```swift\nstruct UserRegistrationModel: UserRegistrationModelProtocol {\n    var id: Int?\n    var username: String?\n    var email: String?\n    var firstName: String?\n    var lastName: String?\n    var gender: String?\n    var image: String?\n    var token: String?\n    var age: String?\n}\n```\n\n구현: 이 구조체는 UserRegistrationModelProtocol을 구현합니다. 사용자를 등록하는 데 필요한 속성을 모두 포함하고 있습니다. 사용자 이름, 이메일, 성, 성, 등이 포함됩니다.\n\n유연성: 프로토콜을 준수함으로써 UserRegistrationModel은 일관성과 확장성을 보장하여, 미래에 쉬운 수정이나 확장이 가능합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# MVVM 아키텍처의 ViewModel: RegistrationViewModel\n\nUserRegistrationModel 구조체를 검토한 후, 이러한 유효성 검사 메서드가 RegistrationViewModel 클래스를 통해 MVVM 아키텍처에 통합되는 방법을 살펴보겠습니다. 이 클래스는 UI와 데이터 로직 및 유효성 규칙을 연결하는 데 중요한 역할을 합니다.\n\n## 개요\n\n```js\nclass RegistrationViewModel {\n\n    private var userFirstName = \"\"\n    private var userLastName = \"\"\n    private var userEmail = \"\"\n    private var userPassword = \"\"\n    private var userAge = \"\"\n\n    var isUserFirstNameValid: ((Bool) -> ())!\n    var isUserLastNameValid: ((Bool) -> ())!\n    var isUserEmailValid: ((Bool) -> ())!\n    var isUserPasswordValid: ((Bool) -> ())!\n    var isUserAgeValid: ((Bool) -> ())!\n\n    func setUpUserFirstName(userFirstName: String) {\n        self.userFirstName = userFirstName\n        ValidationFieldsHelper.isValidName(userFirstName) ? isUserFirstNameValid(true) : isUserFirstNameValid(false)\n    }\n\n    func setUpUserLastName(userLastName: String) {\n        self.userLastName = userLastName\n        ValidationFieldsHelper.isValidName(userLastName) ? isUserLastNameValid(true) : isUserLastNameValid(false)\n    }\n\n    func setUpUserEmail(userEmail: String) {\n        self.userEmail = userEmail\n        ValidationFieldsHelper.isValidEmail(userEmail) ? isUserEmailValid(true) : isUserEmailValid(false)\n    }\n\n    func setUpUserPassword(userPassword: String) {\n        self.userPassword = userPassword\n        ValidationFieldsHelper.isValidPassword(userPassword) ? isUserPasswordValid(true) : isUserPasswordValid(false)\n    }\n\n    func setUpUserAge(userAge: String) {\n        self.userAge = userAge\n        ValidationFieldsHelper.isValidAge(userAge) ? isUserAgeValid(true) : isUserAgeValid(false)\n    }\n\n    func isValidRegistration() -> Bool {\n        return ValidationFieldsHelper.isValidName(userFirstName) &&\n        ValidationFieldsHelper.isValidName(userLastName) &&\n        ValidationFieldsHelper.isValidEmail(userEmail) &&\n        ValidationFieldsHelper.isValidPassword(userPassword) &&\n        ValidationFieldsHelper.isValidAge(userAge)\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n작동 방법: 예를 들어 해당 메소드는 userFirstName 속성을 설정한 다음 ValidationFieldsHelper.isValidName을 사용하여 입력을 유효성 검사합니다. 결과에 따라 isUserFirstNameValid 클로저를 호출하며 이름의 유효성을 나타내는 부울 값을 전달합니다.\n\n이 패턴은 userLastName, userEmail, userPassword 및 userAge와 같은 다른 속성에 대해서도 반복되며 각 입력이 유효성을 검사하도록 보장합니다. 마지막 메소드는 각 사용자 정보 필드의 유효성을 검사하기 위해 ValidationFieldsHelper 메소드를 사용합니다. 등록 프로세스를 진행하기 전에 모든 필드가 유효한지 확인합니다.\n\n# MVVM 아키텍처에서 ViewController의 역할\n\nMVVM 아키텍처에서 ViewController는 View 레이어로 작동합니다. 사용자에게 데이터를 제공하고 사용자 상호작용을 처리하는 것이 그 역할입니다. 사용자 등록 예제의 문맥에서 RegistrationViewController은 사용자 입력을 유효성 검사하고 피드백을 제공하기 위해 RegistrationViewModel과 상호작용합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 필드 액션 설정하기\n\nRegistrationViewController에서 여러 입력 필드의 액션을 설정하는 방법을 알아봅시다:\n\n```js\nprivate func fieldActions() {\n\n        firstNameTextField.addAction(UIAction(handler: { [ weak self ] _ in\n            guard let self = self else { return }\n            let newUserFirstName = self.firstNameTextField.text ?? \"\"\n            self.viewModel.setUpUserFirstName(userFirstName: newUserFirstName)\n        }), for: .editingDidEnd)\n\n        lastNameTextField.addAction(UIAction(handler: { [ weak self ] _ in\n            guard let self = self else { return }\n            let newUserLastName = self.lastNameTextField.text ?? \"\"\n            self.viewModel.setUpUserLastName(userLastName: newUserLastName)\n        }), for: .editingDidEnd)\n\n        emailTextField.addAction(UIAction(handler: { [ weak self ] _ in\n            guard let self = self else { return }\n            let newUserEmail = self.emailTextField.text ?? \"\"\n            self.viewModel.setUpUserEmail(userEmail: newUserEmail)\n        }), for: .editingDidEnd)\n\n        passwordTextField.addAction(UIAction(handler: { [ weak self ] _ in\n            guard let self = self else { return }\n            let newUserPassword = self.passwordTextField.text ?? \"\"\n            self.viewModel.setUpUserPassword(userPassword: newUserPassword)\n        }), for: .editingDidEnd)\n\n        ageTextField.addAction(UIAction(handler: { [ weak self ] _ in\n            guard let self = self else { return }\n            let newUserAge = self.ageTextField.text ?? \"\"\n            self.viewModel.setUpUserAge(userAge: newUserAge)\n        }), for: .editingDidEnd)\n    }\n```\n\n각 액션은 텍스트 변경이나 선택 변경과 같은 사용자 상호작용에 연결되어 있습니다. 이러한 액션들은 ViewModel의 적절한 설정 메서드(setUpUserFirstName, setUpUserEmail 등)를 호출하여 입력 데이터를 업데이트하고 유효성을 검사합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n작동 방식: 사용자가 이메일 필드 편집을 완료하면 해당 동작이 텍스트를 캡처하여 ViewModel로 보내어 유효성을 검사한 후 UI를 업데이트합니다.\n\n## 필드 유효성 검사 처리\n\nfieldsValidation 메서드는 ViewModel과 클로저 바인딩을 설정합니다. 이러한 클로저는 ViewModel이 각 필드의 유효성을 검사할 때 호출됩니다.\n\n```js\nprivate func fieldsValidation() {\n\n     viewModel.isUserFirstNameValid = { [weak self] isUserFirstNameValid in\n        if isUserFirstNameValid {\n            self?.firstNameTextField.layer.borderColor = UIColor.green.cgColor\n        } else {\n            self?.firstNameTextField.layer.borderColor = UIColor.red.cgColor\n            if self?.firstNameTextField.text?.isEmpty ?? true {\n                self?.firstNameTextField.layer.borderColor = UIColor.lightGray.cgColor\n            }\n        }\n    }\n\n    viewModel.isUserLastNameValid = { [weak self] isUserLastNameValid in\n        if isUserLastNameValid {\n            self?.lastNameTextField.layer.borderColor = UIColor.green.cgColor\n        } else {\n            self?.lastNameTextField.layer.borderColor = UIColor.red.cgColor\n            if self?.lastNameTextField.text?.isEmpty ?? true {\n                self?.lastNameTextField.layer.borderColor = UIColor.lightGray.cgColor\n            }\n        }\n    }\n\n    viewModel.isUserEmailValid = { [weak self] isUserEmailValid in\n        if isUserEmailValid {\n            self?.emailTextField.layer.borderColor = UIColor.green.cgColor\n        } else {\n            self?.emailTextField.layer.borderColor = UIColor.red.cgColor\n            self?.showAlert(message: \"유효하지 않은 이메일 주소입니다. 유효한 이메일을 입력해주세요.\")\n            if self?.emailTextField.text?.isEmpty ?? true {\n                self?.emailTextField.layer.borderColor = UIColor.lightGray.cgColor\n            }\n        }\n    }\n\n    viewModel.isUserPasswordValid = { [weak self] isUserPasswordValid in\n        if isUserPasswordValid {\n            self?.passwordTextField.layer.borderColor = UIColor.green.cgColor\n        } else {\n            self?.passwordTextField.layer.borderColor = UIColor.red.cgColor\n            self?.showAlert(message: \"유효하지 않은 비밀번호입니다. 최소 8자 이상이어야 하며 대문자, 숫자, 특수 문자가 하나 이상 포함되어야 합니다.\")\n            if self?.passwordTextField.text?.isEmpty ?? true {\n                self?.passwordTextField.layer.borderColor = UIColor.lightGray.cgColor\n            }\n        }\n    }\n\n    viewModel.isUserAgeValid = { [weak self] isUserAgeValid in\n        if isUserAgeValid {\n            self?.ageTextField.layer.\n            borderColor = UIColor.green.cgColor\n        } else {\n            self?.ageTextField.layer.borderColor = UIColor.red.cgColor\n            self?.showAlert(message: \"유효하지 않은 나이입니다. 유효한 나이를 입력해주세요.\")\n            if self?.ageTextField.text?.isEmpty ?? true {\n                self?.ageTextField.layer.borderColor = UIColor.lightGray.cgColor\n            }\n        }\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n각 클로저는 UI를 업데이트하여 유효성 상태를 반영합니다. 예를 들어, 이메일이 유효하지 않은 경우 이메일 텍스트 필드의 테두리 색상을 빨간색으로 변경하고 경고 메시지를 표시합니다.\n\n# 결론: iOS 앱에서 견고한 필드 유효성 검사를 위해 MVVM 채용\n\n요약하자면, MVVM 아키텍처를 활용하여 iOS 앱에서 필드 유효성 검사를 구현하는 복잡성을 탐험한 우리의 여정은 체계적이고 효율적인 앱 개발 접근 방식을 보여줍니다. 이 기사는 견고한 유효성 검사 시스템을 만드는 구체적인 내용을 다루며, ValidationFieldsHelper 구조체로부터 시작하여 동적 RegistrationViewModel을 거쳐 상호작용하는 RegistrationViewController까지 진행합니다.\n\n이 문맥에서 MVVM 아키텍처의 사용은 그 강점을 부각시킵니다: 관심사 분리, 코드 유지 관리성 향상 및 테스트 용이성 개선. 사용자 인터페이스(View), 비즈니스 로직(ViewModel) 및 데이터 처리(Model)를 분리함으로써 디버깅을 간소화하고 확장 가능한 앱 개발이 가능한 모듈화된 설계를 달성합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 접근 방식에서 주요 포인트는 다음과 같습니다:\n\n- 구조화된 유효성 검사 로직: 유효성 검사 로직을 전용 구조에 캡슐화하면 재사용성과 명확성이 보장됩니다. 이 방법은 코드를 더 잘 구성할 뿐만 아니라 어플리케이션 전반에 쉽게 접근할 수 있게 합니다.\n- 반응성과 사용자 친화적 인터페이스: 사용자 경험을 고려한 View 구성 요소는 즉시 유효성 검사 결과를 반영하여 사용자가 순조롭게 등록 프로세스를 진행할 수 있도록 안내합니다.\n- 동적 데이터 처리: ViewModel은 View와 Model 사이의 통로 역할을 하며 데이터 유효성 검사, 사용자 상호 작용 및 비즈니스 로직을 동적으로 처리하는 방법을 제공합니다.\n- 확장성과 유연성: 이 모듈식 접근 방식은 앱의 검사 로직을 확장하거나 새로운 기능을 통합하는 등 앱의 쉬운 업데이트와 수정을 가능하게 합니다.\n- 시각적 표현: 이 기사와 함께 제작된 개념적이고 추상적인 이미지들은 시각적 매력을 증진시키는 뿐만 아니라 논의된 개념을 더 명확하게 이해할 수 있게 합니다.\n\n결론적으로, iOS 앱 개발에서 필드 유효성 검사에 MVVM 패턴을 적용하면 포괄적이고 실용적인 프레임워크가 제공됩니다. 이 방식은 현대적인 개발 관행과 일치하여 깔끔하고 테스트 가능하며 유지 보수가 용이한 코드를 강조합니다. 소프트웨어 개발의 진화하는 본질을 보여주는 것으로, 아키텍처와 디자인 패턴이 효율적이고 사용자 친화적이며 견고한 애플리케이션을 개발하는 데 핵심적인 역할을 하는 것을 확인할 수 있습니다.\n\n테스트 프로젝트는 DolphinLogin에서 확인할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 피드백 및 협업 개선\n\n이 기사를 마무리하면서 건설적인 비판과 협업 개선의 가치를 강조하고 싶습니다. 코딩 세계는 공유된 지식과 다양한 시각에서 번영합니다. 따라서 더 경험이 많은 개발자들의 제안, 비평 및 향상을 진심으로 환영합니다. 여러분의 통찰력과 기여는 이 접근 방식을 상당히 다듬고 발전시킬 수 있으며, 이는 전체 개발자 커뮤니티에 큰 혜택을 줄 수 있습니다. 주의와 소중한 피드백에 감사드립니다!\n","ogImage":{"url":"/assets/img/2024-06-23-FieldValidationinMVVMArchitectureABeginersGuide_0.png"},"coverImage":"/assets/img/2024-06-23-FieldValidationinMVVMArchitectureABeginersGuide_0.png","tag":["Tech"],"readingTime":18},{"title":"Swift에서 검색 필드 플레이스홀더에 애니메이션 텍스트 전환 구현하는 방법","description":"","date":"2024-06-23 21:31","slug":"2024-06-23-ImplementingAnimatedTextTransitionsforSearchFieldPlaceholderinSwift","content":"\n![animated text transition](https://miro.medium.com/v2/resize:fit:1200/1*iAxDbK5Cno82BIy7Kf6p4A.gif)\n\n이 프로젝트의 목표는 검색 필드의 자리 표시자를 위한 텍스트 애니메이션 전환을 가지는 것입니다. 자리 표시자의 일부가 전환과 함께 한 번에 업데이트되는 것입니다.\n\n![search field placeholder](/assets/img/2024-06-23-ImplementingAnimatedTextTransitionsforSearchFieldPlaceholderinSwift_0.png)\n\n시작하기 전에 검색 아이콘을 가진 텍스트 필드를 추가해 보겠습니다. 위에서 \"magnifyingglass\"라는 시스템 이미지를 사용하고 있습니다. 패딩을 추가하려면 특정 프레임의 뷰에 이미지를 추가하여 이를 텍스트 필드의 \"왼쪽 뷰\" 속성에 추가할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n// 검색 필드 설정\nsearchField = UITextField()\nsearchField.borderStyle = .roundedRect\nsearchField.translatesAutoresizingMaskIntoConstraints = false\nsearchField.textColor = UIColor.gray.withAlphaComponent(0.5)\nsearchField.tintColor = UIColor.gray.withAlphaComponent(0.5)\nsearchField.becomeFirstResponder()\n\n// 검색 아이콘 이미지 뷰 생성\nlet searchIcon = UIImageView(image: UIImage(systemName: \"magnifyingglass\"))\nsearchIcon.tintColor = .gray\nsearchIcon.contentMode = .scaleAspectFit\n\n// 이미지 뷰에 패딩 추가\nlet paddingView = UIView(frame: CGRect(x: 0, y: 0, width: 30, height: 30))\nsearchIcon.frame = CGRect(x: 5, y: 5, width: 20, height: 20)\npaddingView.addSubview(searchIcon)\n\n// 이미지 뷰를 텍스트 필드의 왼쪽 뷰로 설정\nsearchField.leftView = paddingView\nsearchField.leftViewMode = .always\n\n// 검색 필드에 액션 추가\nsearchField.addTarget(\nself,\naction: #selector(textFieldDidChange),\nfor: .editingChanged\n)\n\n이제 전환 문자열 역할을 하는 문자열을 포함하는 뷰를 추가해 봅시다. 여기서는 세 개의 레이블이 추가되어 하나는 정적 텍스트를 가져야하며, 다른 두 레이블은 전환과 함께 계속 업데이트됩니다.\n\n이미지 참조: ![이미지](/assets/img/2024-06-23-ImplementingAnimatedTextTransitionsforSearchFieldPlaceholderinSwift_1.png)\n\n'Label1'은 'Search for'라는 정적 레이블이고, 'Label1' 및 'Label2'는 현재 레이블 및 다음 레이블로 작동하여 현재 문자열과 현재 문자열 뒤에 나오는 문자열 즉, 현재 문자열 이후에 나오는 문자열을 저장합니다. 문자열을 업데이트하고 애니메이션하는 방법은 다음과 같습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```swift\n// 문자열 목록\nvar strings = [\"\\'음식\\'\", \"\\'음식점\\'\", \"\\'식료품\\'\", \"\\'음료수\\'\", \"\\'빵\\'\", \"\\'피자\\'\", \"\\'비리야니\\'\", \"\\'버거\\'\", \"\\'바지\\'\", \"\\'국수\\'\", \"\\'수프\\'\", \"\\'샌드위치\\'\", \"\\'비스킷\\'\", \"\\'초콜릿\\'\"]\n\n@objc func updateLabels() {\n    if index < strings.count {\n        // 단계 1: 문자열 할당\n        nextLabel.text = strings[index]\n        nextLabel.alpha = 0\n        nextLabel.transform = CGAffineTransform(translationX: 0, y: searchView.frame.height / 2)\n\n        // 단계 2: 전환 효과를 주기 위해 애니메이션 적용\n        UIView.animate(withDuration: 1.0, delay: 0, options: .curveEaseOut, animations: {\n            self.currentLabel.alpha = 0\n            self.currentLabel.transform = CGAffineTransform(translationX: 0, y: -self.searchView.frame.height / 2)\n            self.nextLabel.alpha = 1\n            self.nextLabel.transform = .identity\n        }, completion: { _ in\n            // 단계 3: 라벨 로직\n            // 라벨 교체\n            self.currentLabel.text = self.nextLabel.text\n            self.currentLabel.alpha = 1\n            self.currentLabel.transform = .identity\n\n            // 다음 라벨 초기화\n            self.nextLabel.alpha = 0\n            self.nextLabel.transform = CGAffineTransform(translationX: 0, y: self.searchView.frame.height / 2)\n        })\n        // 단계 4: 인덱스 증가\n        index += 1\n    } else {\n        // 모든 문자열이 표시된 경우 타이머 무효화\n        timer?.invalidate()\n    }\n}\n```\n\n- nextLabel의 텍스트를 현재 문자열로 설정합니다. 또한 알파를 0으로 설정하여(투명하게 함) 검색 뷰 아래로 이동하도록 번역 변환을 적용합니다.\n- UIView.animate를 사용하여 애니메이션을 수행합니다. 애니메이션 중에:\n\n- currentLabel이 페이드 아웃되고 위로 이동합니다.\n- nextLabel이 페이드 인하여 원래 위치로 이동합니다.\n\n3. 완료 블록에서 라벨의 텍스트를 교환하고 알파와 번역을 재설정합니다. 이렇게 하면 currentLabel이 다음 문자열을 위해 준비되고 nextLabel이 다음 전환을 위해 재설정됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n라벨이 어떻게 업데이트되는지 확인해 봅시다. 여기에서는 타이머를 사용합니다. 타이머는 설정된 간격이 지나면 타겟 객체로 지정된 메시지를 전송합니다.\n라벨이 업데이트되도록 메서드를 초기화하고 타이머를 설정해야 합니다.\n\n```js\nfunc animateListOfLabels() {\n    currentLabel.text = strings[index-1]\n    nextLabel.alpha = 0\n    timer?.invalidate()\n    timer = Timer.scheduledTimer(\n            timeInterval: 2,\n            target: self,\n            selector: #selector(updateLabels),\n            userInfo: nil,\n            repeats: true\n    )\n}\n```\n\nanimateListOfLabels 함수는 라벨의 애니메이션 순서를 관리하는 데 중요합니다. 이 함수는 다음을 보장합니다:\n\n- currentLabel이 올바른 텍스트로 설정됩니다.\n- nextLabel이 숨겨지고 애니메이션을 위해 준비됩니다.\n- 이전 타이머가 충돌을 피하기 위해 무효화됩니다.\n- 라벨을 매 2초마다 업데이트하는 새로운 타이머가 설정되어 부드러운 전환 효과를 가능하게 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 설정은 각 문자열이 부드러운 전환과 함께 순차적으로 표시되는 레이블 목록을 애니메이션화하는 깔끔하고 제어된 방법을 제공합니다.\n\n저희의 구현에서는 텍스트 필드가 업데이트될 때 타이머가 일시 중지되고, 텍스트 필드가 다시 비어 있을 때 다시 시작됩니다. 여기에 \"stopTimer\" 및 \"resumeTimer\" 메서드가 있습니다.\n\n```js\n// 실행 중인 타이머 무효화\nfunc stopTimer() {\n    timer?.invalidate()\n}\n\n// 타이머 재개\nfunc resumeTimer() {\n    currentLabel.text = strings[index-1]\n    timer = Timer.scheduledTimer(\n        timeInterval: 2,\n        target: self,\n        selector: #selector(updateLabels),\n        userInfo: nil,\n        repeats: true\n    )\n}\n\n// 텍스트필드의 editingChanged 동작 실행\n@objc func textFieldDidChange() {\n    if let text = searchField.text, !text.isEmpty {\n        searchView.isHidden = true\n        stopTimer()\n    } else {\n        searchView.isHidden = false\n        resumeTimer()\n    }\n}\n```\n\n- \"resumeTimer\" 함수는 일시 중단 후 레이블의 애니메이션 시퀀스를 다시 시작하는 데 필수적입니다. 이는 다음 사항을 보장합니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 현재 레이블 (currentLabel)은 이전에 표시된 문자열을 표시하도록 설정됩니다.\n- 새 타이머가 생성되어 일정 간격으로 updateLabels 메서드를 호출하여 텍스트의 부드러운 전환을 계속합니다.\n\n올바른 설정으로 타이머를 재개함으로써, 이 기능은 애니메이션된 텍스트 전환의 연속성과 부드러움을 유지하여 사용자 경험을 향상시킵니다. 애니메이션이 중단된 지점부터 이어서 재개함으로써, 사용자들이 애니메이션을 자연스럽게 이어가도록 도와줍니다.\n\n2. stopTimer 함수는 타이머를 일시 중지하거나 완전히 중지해야 하는 상황에서 필수적입니다.\n\n3. textFieldDidChange 함수는 앱 내 반응이 빠르고 사용자 친화적인 경험을 보장하는 데 중요한 역할을 합니다.\n   텍스트 필드 내용에 따라 검색 뷰를 동적으로 표시하거나 숨기며, 텍스트 필드 내용에 따라 타이머를 제어함으로써 부드럽고 직관적인 사용자 상호 작용을 가능하게 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n애니메이션 검색 필드와 텍스트 전환을 구현하는 주요 이점은 다음과 같아요\n\n- 사용자 참여도 향상\n- 가독성 향상\n- 사용자 경험 개선\n- 효율적인 정보 표시\n- 섬세한 사용자 지원\n\n여기서 코드의 완전한 버전을 찾을 수 있어요. 이 기능을 확인하려면 GitHub에서 클론해보세요.\n\n감사합니다!!! 😃\n","ogImage":{"url":"/assets/img/2024-06-23-ImplementingAnimatedTextTransitionsforSearchFieldPlaceholderinSwift_0.png"},"coverImage":"/assets/img/2024-06-23-ImplementingAnimatedTextTransitionsforSearchFieldPlaceholderinSwift_0.png","tag":["Tech"],"readingTime":8},{"title":"아이폰 개발, 이제 시작해보세요 초보자를 위한 단계별 성공 가이드","description":"","date":"2024-06-23 21:29","slug":"2024-06-23-HowtoLearniOSDevelopmentAStep-By-StepGuideforBeginnerstoSucceed","content":"\n작성자: May Ly, Agile 소프트웨어 엔지니어, TribalScale\n\n![이미지](/assets/img/2024-06-23-HowtoLearniOSDevelopmentAStep-By-StepGuideforBeginnerstoSucceed_0.png)\n\n## 📫 구독하려면 여기를 클릭하세요.\n\n## 💬 다음 디지털 프로젝트, 스타트업 또는 TribalScale에 관한 질문이 있으신가요? 저희 전문가 중 한 명과 채팅해보려면 여기를 클릭하세요!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![그림1](/assets/img/2024-06-23-HowtoLearniOSDevelopmentAStep-By-StepGuideforBeginnerstoSucceed_1.png)\n\n![그림2](/assets/img/2024-06-23-HowtoLearniOSDevelopmentAStep-By-StepGuideforBeginnerstoSucceed_2.png)\n\n저는 현재 TribalScale에서 iOS 개발자로 일하고 있습니다. 여기서는 클라이언트의 iOS 앱을 유지보수하고 기능을 추가하며 레거시 Objective-C 코드를 Swift로 전환하는 작업을 하고 있어요! 처음에 이 프로젝트를 맡았을 때 iOS 경험이 많이 없었지만, 이를 계기로 iOS 개발을 빠르게 익히기로 했습니다. 그래서 iOS의 기본을 빠르게 배우고, 내가 직접 앱을 만들어 적용해 보는 등의 노력을 했어요!\n\n저는 2주 만에 iOS의 기본을 파악할 수 있었습니다. 지금 돌이켜보면, 그 짧은 시간 동안 적용한 프로세스가 많았지만, 나중에 배우게 된 많은 중요한 iOS 개념들도 있었어요. 그래서 제 경험을 되짚어가며, 처음부터 iOS를 배운다면 어떻게 시작할지에 대해 6단계 요약을 작성해 보았어요. 내가 했던 것처럼 iOS 경험이 부족하고 빠르게 iOS를 배우고 싶다면, 이 방법이 도움이 될 지도 몰라요!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 단계 1: XCode 다운로드\n\nXCode를 다운로드하세요! XCode는 애플의 통합 개발 환경으로, iOS를 포함한 모든 애플 플랫폼용 앱을 만들기 위한 도구를 제공합니다. XCode에서는 앱을 편집하고 관리하며, 시뮬레이터를 사용하여 앱을 확인하고, 인터페이스 빌더를 사용하여 앱의 모양을 디자인할 수 있습니다. XCode는 앱 스토어에서 무료로 다운로드할 수 있거나 이 링크에서 찾을 수도 있어요!\n\nXCode를 다운로드하고 실행한 후 몇 가지를 살펴보세요:\n\n- 새 프로젝트 만들기: 새로운 iOS Swift 프로젝트를 만들고 AppDelegate, SceneDelegate, ViewController 및 Main XIB 파일과 같은 기본 파일을 살펴보세요.\n- 플랫폼 살펴보기: XCode 인터페이스를 탐험해보세요. 프로젝트 네비게이터를 포함한 다양한 패널과 창이 있습니다. 여기에서는 파일을 추가하거나 삭제할 수 있고, 코드를 작성할 수 있는 소스 코드 편짡기, 선택한 항목과 관련된 추가 정보를 제공하는 유틸리티 영역이 포함되어 있습니다. 디버깅 패널이나 하단에 있는 터미널과 같은 다른 기능도 살펴볼 수 있습니다.\n- 인터페이스 빌더: XCode의 인터페이스 빌더를 사용하여 앱의 UI를 디자인하고 사용자 정의하세요. 프로젝트에 연관된 스토리보드 또는 XIB 파일(\"Main\" 파일)을 열어 UI 요소를 추가하고 레이아웃을 정렬하고 속성을 조정해보세요.\n- 빌드 및 실행: Xcode 툴바에서 \"빌드 및 실행\" 또는 \"재생\" 버튼을 클릭하여 코드를 컴파일하고 iPhone 시뮬레이터에서 앱을 실행하세요. 이를 통해 앱의 현재 상태를 확인할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nXCode에 대해 더 자세히 다루는 멋진 튜토리얼이 있어요.\n\n실제 코딩을 해보기 전까지 XCode에 대해 배울 수 있는 한계가 있겠죠 — 그래서 그 다음 단계인 스텝 2로 넘어가 보겠습니다!\n\n## 스텝 2: Swift 배우기\n\nSwift는 애플이 2014년 도입한 애플리케이션 개발에 효과적이면서 현대적인 언어로, 애플의 플랫폼에서 애플리케이션을 개발하기 위한 언어입니다. 제가 현재 작업 중인 앱 때문에 실제로 Swift보다 이전에 애플이 개발한 다른 iOS 프로그래밍 언어인 Objective-C를 배웠어요. iOS 개발에 대한 좋은 기반이 되었지만, 요즘에는 더 현대적이고 인기 있는 언어인 Swift를 먼저 배우는 것이 더 좋습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n하지만, 새로운 프로그래밍 언어를 배우는 방법은 여러 가지가 있습니다. 내 경험상으로는, 초보자를 위한 간단한 자습서를 찾을 때 언제나 먼저 Youtube를 참고합니다 (그리고 무료입니다 🤩). 만약 Youtube가 아니라면, 간단한 구글 검색으로 무수히 많은 Swift 코스를 온라인에서 찾을 수 있습니다. 아래에 몇 가지 좋은 자료를 링크했습니다!\n\n[SwiftUI 100 Days Challenge](https://www.hackingwithswift.com/100/swiftui)\n\nSwift를 배우면서 내 경험상 유용한 몇 가지 팁은 다음과 같습니다:\n\n- 어떤 자습서나 코스를 공부할 때는 단순히 시청하고 메모를 하는 것이 아닌 튜토리얼과 함께 코딩하는 것이 가장 좋습니다. 적극적으로 연습하고 내용에 집중하여 자신감과 기억력을 키우는 것이 중요합니다.\n- 특정 주제에 더 깊게 파고들어야 할 때는 언제든지 애플의 공식 Swift 문서를 참고할 수 있습니다. 'The Swift Programming Language' 가이드는 언어의 기능, 구문 및 개념에 대한 포괄적인 개요를 제공합니다.\n- ChatGPT는 개념을 이해하고 특정 질문에 답변하며 지침을 제공하는 데 최상의 도구입니다. 코드 일부를 붙여 넣더라도 각각의 줄을 상세히 설명해줍니다! AI를 최대한 활용하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![2024-06-23-HowtoLearniOSDevelopmentAStep-By-StepGuideforBeginnerstoSucceed_3.png](/assets/img/2024-06-23-HowtoLearniOSDevelopmentAStep-By-StepGuideforBeginnerstoSucceed_3.png)\n\n# 단계 3: 프로젝트 선택\n\n이제 프로그래밍 지식을 실제 앱에 적용할 때입니다! 초보자로서, 현재의 기술 수준으로 합리적으로 달성할 수 있는 간단한 앱 아이디어부터 시작하는 것이 중요합니다. 복수의 복잡한 기능이나 백엔드를 필요로하는 과도한 야심찬 프로젝트는 피하세요. 학습에 집중할 수 있도록 매우 적은 기능을 포함하는 아이디어를 찾으세요.\n\n제가 말하는 간단한 것은 정말 간단한 것을 의미합니다. 당신의 아이디어는 작동을 위해 500줄 이하의 코드만 필요하며, 거기서 추가 기능을 더할 수 있습니다! 시작하기에 좋은 몇 가지 예시는 다음과 같습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- Randomizer/Generator: 사용자가 제공한 맥락에 따라 무작위 결과를 생성하는 앱입니다. 레스토랑, 농담, 색상 등에서 생성된 결과는 API에서 나올 수도 있고 앱에 하드코딩될 수 있습니다.\n- 전쟁 카드 게임: 두 플레이어가 서로 카드 덱에서 카드를 순서대로 공개하여 경쟁하는 클래식 \"전쟁\" 카드 게임입니다. 순위가 더 높은 카드를 가진 플레이어가 라운드를 이기고 두 장을 모아갑니다.\n- 할 일 목록: 사용자가 할 일을 추가, 편집 및 삭제할 수 있는 기본 할 일 목록 앱입니다. 할 일을 완료로 표시하거나 알림 설정과 같은 기능이 포함되어 있습니다.\n\n최종적으로 당신이 원하는 것을 만들 수 있습니다 - 세상은 너의 껍데기입니다! 주변을 탐구하고 당신에게 흥미로울만한 다른 API나 앱 아이디어가 있는지 살펴보세요. 예를 들어, 나의 매우 첫 번째 프로젝트는 두 개의 고양이 API를 사용한 Cat App이었습니다. 구현한 세 가지 기능은 다음과 같습니다:\n\n- CatFact.Ninja API에서 생성된 10가지 고양이 사실\n- TheCatAPI에서 선택한 견종의 여러 이미지를 표시하는 고양이 종 선택기\n- UIStepper를 사용한 매우 기본적인 고양이 카운터\n\n<img src=\"/assets/img/2024-06-23-HowtoLearniOSDevelopmentAStep-ByStepGuideforBeginnerstoSucceed_4.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 프로젝트는 Objective-C와 Swift로 모두 작성되었으며 완성하는 데 며칠이 걸렸고 약 400줄의 코드가 포함되어 있습니다. 사용자 정의 사용자 인터페이스를 만들거나 API에서 데이터를 가져오는 등 다양한 개념을 다룬 것이 좋은 프로젝트 선택이었습니다. 앞으로 앱 아이디어를 선택하면 이러한 다음 단계를 따라가며 개발을 시작할 수 있겠어요!\n\n# 단계 4: UIKit 및 Interface Builder 탐색\n\nUIKit은 애플이 제공하는 프레임워크로, 해당 플랫폼에서 사용자 인터페이스(UI)를 개발하기 위한 것입니다. 이는 응용 프로그램의 시각적 요소를 생성하고 관리하며 사용자 상호 작용을 처리하는 데 필요한 클래스, 프로토콜 및 도구 세트를 제공합니다.\n\nUIKit을 사용하기 위해 XCode의 Interface Builder를 탐색해보아야 합니다. Interface Builder는 시각적 환경으로, 개발자들이 애플리케이션 인터페이스를 설계, 사용자 정의하고 프로토타입을 만드는 데 필요한 코드를 많이 작성하지 않고도 쉽게 작업할 수 있도록 돕는 도구입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 iOS 학습 여정에서 앱의 화면을 디자인하기 위해 Interface Builder를 사용하세요. 예를 들어, 저는 다양한 화면으로 나누어진 여러 컨트롤러를 가지고, 테이블 뷰, 컬렉션 뷰, 버튼, 피커 등의 다양한 UIKit 요소를 담았습니다. 이러한 요소들은 정보를 표시하거나 사용자 상호작용을 처리하는 데 필요했습니다.\n\n![image](/assets/img/2024-06-23-HowtoLearniOSDevelopmentAStep-By-StepGuideforBeginnerstoSucceed_5.png)\n\n캔버스에 UIKit 요소를 추가한 후, 코드와 연결하여 기능을 추가하는 방법을 배우고, 요소를 프로그래밍적으로 조작할 수 있습니다. 이때 Step 2에서 Swift 학습을 활용하여 로직을 작성하여 작동하는 UI 구성 요소를 만들 수 있습니다!\n\n처음에 UIKit를 탐험하는 것은 많은 기능을 배워야 해서 겁내기 쉬울 수 있습니다. 초보자로서, 여러분의 첫 번째 앱 작업 시 반드시 다루어야 할 기본 개념은 다음과 같습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- UIKit 요소들: 프로젝트에 추가하여 외형을 사용자 정의하고 색상, 글꼴, 크기 및 기타 시각 속성을 조정하여 UIKit 요소의 다양성을 경험해보세요. 실제로 깊이 있는 이해를 위해 몇 가지 컴포넌트를 살펴보세요:\n- 뷰 컨트롤러: 뷰 컨트롤러를 사용하여 뷰의 표현과 동작, 사용자 상호작용 처리 및 응용 프로그램의 흐름을 조절하세요. 뷰 컨트롤러의 존재 여부를 다양한 단계에서 호출되는 viewDidLoad()와 같은 라이프사이클 메서드를 이해하여 설정 수행, UI 업데이트, 이벤트에 적절히 응답하세요.\n- UITableView와 UICollectionView: UITableView와 UICollectionView의 사용법을 살펴보세요. 이들은 데이터 목록과 격자를 표시하는 핵심 컴포넌트입니다. 데이터 소스와 델리게이트를 구현하는 방법, 외형 사용자 정의, 사용자 상호작용 처리, 셀 재사용 효율적으로 관리하는 방법을 배우세요.\n- 컨트롤 요소: UIButtons, UITextFields, UISwitches와 같은 다양한 컨트롤 요소를 사용하여 앱과 상호작용할 수 있도록 합니다.\n- IBOutlets 및 IBActions: 뷰 컨트롤러에서 UI 요소와 코드 간 연결을 설정하세요. IBOutlets을 사용하여 프로그래밍 방식으로 요소에 액세스하고 사용자 상호작용에 대한 응답을 트리거하기 위한 메서드를 정의하는 데 IBActions을 사용하세요.\n- Auto Layout: UI 요소 간의 제약 조건을 정의하는 Auto Layout을 탐험하세요. 화면 크기, 방향 및 장치 특성에 대응하도록 보장하는 것이 목적입니다.\n- 탐색 및 Segues: Segues를 추가하여 뷰 컨트롤러 간 이동 및 전환을 관리하세요. 앱 내의 서로 다른 화면 간의 흐름과 탐색을 허용합니다. 인터페이스 빌더에서 Segues를 설정하고 뷰 컨트롤러 간에 데이터를 전달하는 방법을 이해하세요.\n\nUIKit 및 인터페이스 빌더를 배우기 위해서는 실험이 필수적이라는 것을 기억하세요. 간단한 표시부터 시작하여 도구와 개념에 익숙해지면서 점점 더 복잡한 것을 추가해보세요.\n\n# 단계 5: API 작업하기\n\nUIKit, 인터페이스 빌더 및 Swift 프로그래밍에 좀 더 익숙해지면 — API 작업을 배우는 것을 추천합니다. API(응용 프로그램 프로그래밍 인터페이스)는 서로 다른 소프트웨어 응용 프로그램이 통신하고 상호 작용할 수 있도록 하는 규칙과 프로토콜의 집합입니다. 다른 시스템 간에 데이터를 요청하고 교환하는 방법, 데이터 형식 및 규칙을 정의합니다. 당신의 개인 프로젝트에 통합할 수 있는 몇 가지 무료이면서 쉬운 사용법의 멋진 API 예제를 여기에서 확인하세요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 포켓몬 API: https://pokeapi.co/\n- 개 API: https://dog.ceo/dog-api/\n- 마블 API: https://developer.marvel.com/\n- 날씨 API: https://openweathermap.org/api\n\n![image](/assets/img/2024-06-23-HowtoLearniOSDevelopmentAStep-By-StepGuideforBeginnerstoSucceed_6.png)\n\n이전에 내가 앱에 고양이 사실, 품종 및 이미지를 가져오기 위해 두 가지 Cat API를 사용했다고 언급했다. 이를 위해 Objective-C/Swift 코드로 응답을 받고 데이터를 처리하는 간단한 네트워킹 레이어를 만들었다. 이제 온라인에서 API를 찾고 Swift로 API 통합의 기본을 배우고 반환된 데이터를 적절히 표시하세요. 초보자로서 다룰 주제 몇 가지는 다음과 같습니다:\n\n- API 기본 사항: API, HTTP, RESTful 아키텍처 및 JSON 데이터 형식의 개념을 숙지하세요. HTTP 메서드(GET, POST 등), 엔드포인트, 요청 헤더 및 응답 코드에 대해 알아보세요.\n- URLSession 및 URLResponse: Apple이 제공하는 네트워킹 프레임워크인 URLSession의 기본을 이해하세요. URLRequests를 사용하여 데이터를 가져오는 실험을 해보세요.\n- 응답 데이터 처리: API에서 받은 응답 데이터를 처리하는 다양한 방법을 탐구하세요. JSON 데이터를 구문 분석하고 Codable을 사용하여 Swift 객체로 디코딩하고 이미지와 같은 특정 유형의 데이터를 처리하는 방법을 배우세요.\n- 비동기 프로그래밍: 네트워크 요청의 비동기적인 성격에 대해 학습하고 URLSession을 완료 핸들러와 함께 사용하여 동시 작업을 효율적으로 관리하는 방법에 대해 알아보세요. 백그라운드/주 스레드 및 디스패치 그룹과 같은 개념을 검토하세요.\n- 오류 처리: API 요청 중 발생할 수 있는 오류 처리하는 방법을 이해하세요. 다양한 유형의 오류 및 적절한 오류 처리 메커니즘을 구현하는 방법에 대해 배우세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nAPI와 작업하는 법을 배우는 것은 모든 개발자에게 중요한 기술입니다. 서버에서 데이터를 가져오는 방법을 익히면 iOS 개발 기술을 향상시킬 뿐만 아니라 앱의 기능을 향상시키기 위한 무제한의 데이터에 액세스할 수 있습니다!\n\n# 단계 6: 계속 연습하기\n\n이 iOS 개발 학습 계획의 마지막 단계 - 그리고 저도 현재 진행 중인 단계는 계속해서 연습하고 더 많은 실무 경험을 쌓는 것입니다! 직접 앱을 만들거나 소프트웨어 개발자로 일하는 등 다양한 경험을 통해 더 복잡한 주제에 더 깊이 파고들고 최대한 자신을 도전해보세요.\n\n마지막으로, 하늘은 무궁무진하며 이것은 여러분의 iOS 여정의 시작일 뿐입니다! 누구에게나 앱 스토어의 다음 대히트를 만들거나 꿈꾸던 iOS 개발자 직업을 얻을 능력이 있습니다. 계속 열심히 노력하면 곧 iOS 개발의 달인이 될 것입니다! 행운을 빕니다!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n`<img src=\"/assets/img/2024-06-23-HowtoLearniOSDevelopmentAStep-By-StepGuideforBeginnerstoSucceed_7.png\" />`\n\n메이는 현재 iOS 개발에 전념 중인 TribalScale의 애자일 소프트웨어 엔지니어입니다. 그녀의 열정은 개발 프로젝트에서 다른 사람들과 협력하고 프로그래밍, 다양한 기술 스택 및 클라우드 기술에 대한 지식을 확장하는 데 있습니다. 업무 시간 외에는 체육관에 가거나, 배구를 즐기거나, 친구와 가족과 함께 시간을 보내면서 즐겁게 보냅니다.\n\nTribalScale은 기업이 디지털 시대에 적응하고 번영할 수 있도록 돕는 글로벌 혁신 기업입니다. 우리는 팀과 프로세스를 변혁시키고 최고 수준의 디지털 제품을 만들며 혁신적인 스타트업을 창출합니다. 저희에 대해 자세히 알아보고 싶다면 공식 웹사이트를 방문해주세요. 트위터, 링크드인, 페이스북에서도 연락해보세요!\n","ogImage":{"url":"/assets/img/2024-06-23-HowtoLearniOSDevelopmentAStep-By-StepGuideforBeginnerstoSucceed_0.png"},"coverImage":"/assets/img/2024-06-23-HowtoLearniOSDevelopmentAStep-By-StepGuideforBeginnerstoSucceed_0.png","tag":["Tech"],"readingTime":12}],"page":"18","totalPageCount":120,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true}