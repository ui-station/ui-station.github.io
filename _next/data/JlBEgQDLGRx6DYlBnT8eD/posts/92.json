{"pageProps":{"posts":[{"title":"제발, 게임을 평가할 때 재미있는이라는 단어를 그만 사용해 주세요","description":"","date":"2024-05-20 16:33","slug":"2024-05-20-PleasestopusingFuntojudgeagame","content":"\n게임은 “즐거운” 것이 될 수 있지만, 게임의 가치를 측정하는 유일한 방법은 아닙니다.\n\n![Image](/assets/img/2024-05-20-PleasestopusingFuntojudgeagame_0.png)\n\n게임 디자인 서적을 읽으며, 게임 디자인 강의를 듣고, 게임 속에서 게임 디자인을 분석하는 동안 항상 고민해왔습니다. 게임을 “좋은” 것으로 만드는 것은 무엇일까요? 중요한 이야기일까요? 매력적인 게임플레이 루프일까요? 아니면 게임의 소셜 기능들이 중요한 걸까요?\n\n하지만 일반 게이머에게 물을 때, 대개 돌아오는 말은 “즐거움”이라는 단어입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저는 항상 이 단어에 문제가 있었습니다. 이것은 완전히 주관적인 모호한 용어가 아니라 게임이 상호작용하는 예술 형태로서의 잠재력에 대한 깊은 토론을 완전히 배제하는 것입니다.\n\n계속 진행하기 전에, 우리는 \"즐거움\"이라는 단어를 명확히 정의해 봅시다. 옥스포드 사전은 \"가벼운 즐거움, 즐거움 또는 오락\"이라는 정의를 사용합니다. 저는 언어 체계에 갇히고 싶지 않기 때문에 이 정의를 사용하겠습니다.\n\n제가 어렸을 때 가장 좋아했던 게임 디자인 책 중 하나는 Scott Roger의 \"Level up! The Guide to Great Video Game Design\"이었습니다. 정말 솔직한 책이었는데, Scott은 게임 디자인에 대해 너무 소박하고 접근하기 쉽게 썼기 때문에, 저는 헌신적인 게임 디자이너로 자신의 글쓰기 스타일을 접목시켰습니다.\n\n![이미지](/assets/img/2024-05-20-PleasestopusingFuntojudgeagame_1.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n어쨌든, Scott는 자신의 책에 \"왜 '즐거움'을 싫어하는지\"라는 섹션이 있다. Scott는 \"즐거움\"이 너무 모호하고 주관적인 용어로 유용하지 않다고 주장하며, 제작 과정에서 그것을 달성하는 것은 어려운 작업이라고 말합니다. Scott는 게임 개발자들이 게임을 한 번 또 한 번, 또 한 번 해야만 모든 부분이 완벽한지 확인해야 한다고 이어집니다.\n\nScott는 여전히 게임은 \"즐거워\"야 한다고 주장하지만, \"즐거운\" 요소를 없애는 디자인 철학을 통해 그렇게 되어야 한다고 이어집니다. 이는 형편없는 카메라 각도, 이상한 컨트롤, 나쁜 레벨 디자인일 수 있습니다.\n\n그러나, 나는 여전히 우리가 대중의 의식에서 \"즐거움\"을 없애야 한다고 주장합니다. 나에게, 게임의 가치는 플레이어에게 어떤 경험을 제공하고자 하는지에 달려있습니다.\n\n철학적인 문제를 논의해 봅시다. 공포 게임을 즐기면 좋은 공포 게임인가요? 보통, 공포 게임은 플레이어를 압도하고 끊임없이 불안하게 만드는 것이 목적입니다. 플레이어가 \"즐거움\"을 느낀다면, 그것은 게임의 공포 분위기에 흠뻑 빠져들기가 매우 어려워지는 것으로 보입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n어쩌면 스토리가 중심인 게임을 살펴보자. 여기서 The Last of Us Part 2의 초기 스포일러가 포함되어 있습니다. The Last of Us: Part 2는 이전 게임의 주인공 Joel Miller가 끔찍한 방식으로 죽음을 맞이하는 초기 스토리 장면으로 인해 많은 팬들을 괴롭히는 논란이 일었어요. 이것은 \"즐거운\" 경험이 아니지만 그 의도는 그렇지 않았어요. 분노, 역겨움, 공포를 느끼게 하려는 거예요.\n\n2016년의 Final Fantasy XV에서는 약속된 감동적인 모험이 시작되는 동안 다양한 캐릭터들과 함께하는 흥미진 질주의 약속을 했어요. 상자 뒷면과 트레일러에서는 매료하는 전투 시스템과 잊지 못할 세계를 약속했어요. 그런데 게임을 10분쯤 플레이하면서 친구들과 함께 길 가운데에서 차를 밀고 가는 장면들이 나와요. 이 곳에서의 게임 요소는 앞쪽으로 방향키를 누르는 것 뿐이에요. 이 장면의 목표는 \"즐거움\"을 느끼기 위함이 아니라, 캐릭터의 신발에 서서 동정심을 느끼게 하는 것이에요. 그들은 인류를 구할 수도 있는 행동을 맡은 몹시 어리석은 사람들이에요. 이것은 결속의 순간이에요!\n\n때로는 \"즐거움\"의 완전 반대가 되는 게임들도 있어요. 이미 두 게임에 대해 깊게 다뤘지만 다시 한 번 언급해보려고 해요. 특히 나에게 Kane & Lynch 2: Dog Days와 같은 게임은 가능한 한 불쾌하게 설계되었어요. 특히, Kane & Lynch 2는 진짜처럼 처리하기 어려운 총격전을 하나 뒤에 하나 거치게 하며, 정신없이 느껴지는 무기와 만회할 가치 없는 캐릭터, 그리고 엉망인 결말이 있어요. Cruelty Squad는 플레이어에게 접근하기 어렵게 설계되었고, 계속해서 뭔가를 망치고 있다고 느끼게 해요. 게임의 컨트롤은 고의로 형편없으며, 시각적으로 사이키텔릭하고 혼란스럽게 만들어졌어요. 이 게임들은 예술의 작품이며, 그래서 나에게는 \"즐거움\"을 유일한 판단 기준으로 사용하는 것이 상호 조작 매체에 대한 큰 불친절을 의미한다고 생각해요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![](/assets/img/2024-05-20-PleasestopusingFuntojudgeagame_3.png)\n\n당연히 \"재미\"는 그 자리가 있어요. 마리오 카트와 같은 게임은 \"재미\"를 주요 목적으로하여 설계되어, 그 모든 메커니즘이 그 주위에 설계되었습니다. 그것은 분명히 작동합니다! 마리오 카트는 모두 경쾌한 \"재미\"에 초점을 맞춰서 그것이 좋습니다.\n\n하지만 전 개인적으로 게임은 단일 음절로 제대로 설명할 수 없는 것들입니다. 우리는 대신 \"매혹적인\"과 같은 다른 단어를 사용할 수 있지만, 게임들은 — 나에게는 — 일상적인 말을 초월한다고 생각합니다.\n\n둠: 에터널은 악마를 죽이는 것, 지옥을 세우는 악당이 된 느낌을 주도록 설계되어, 적들을 향한 무분별한 파괴 행위를 장려합니다. 레지던트 이블 4는 적대적인 환경에서 생존하려고 하면서 긴장하고 긴장하게 만들도록 설계되었습니다. 로보캅: 로그 시티는 당신이 로보캅이 되는 느낌을 주도록 설계되었습니다! 이러한 게임을 \"재미\"를 중심으로 설계하면, 디자이너가 만들고자 했던 취지를 달성하기가 훨씬 어려울 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![2024-05-20-PleasestopusingFuntojudgeagame_4](/assets/img/2024-05-20-PleasestopusingFuntojudgeagame_4.png)\n\n그래서 저는 상호작용 경험을 디자인할 때 \"즐거움\"을 목표로 삼는 것이 ultimately 잘못된 것이라고 생각합니다. 게임은 자신이 원하는 대로 할 수 있으며, 단일 음절 주위에 게임을 디자인하는 것은 그들의 더 넓은 잠재력을 보다 넓은 대중문화로 제한시킬 수 있습니다.\n\n물론, 이것은 매우 마음먹은 생각입니다. 게임은 물론 돈을 버는 것으로 디자인되었고, 잠재적 구매자를 이해하지 못하거나 기이하게 만드는 게임을 만드는 것은 투자가로부터 재정 파탄을 외치는 것입니다. 항상 그렇지는 않지만 종종 그렇습니다.\n\n그럼에도 불구하고, 게임이 \"즐거움\"이나 \"매료되는 정도\"로 넘어가는 제대로 된 분석을 받을 자격이 있다고 생각합니다. 가능한 한 빨리 우리가 상호작용 경험으로서 게임이 제공하는 존경을 보다 많은 사람들에게 제공할수록, 그들이 인간 문화에 자리 잡을 수 있는 독특한 경험을 제공하기 위해 노력할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\"재밌다\" 카운터: 23.\n\n제 글을 읽어주셔서 감사합니다! 제가 쓰는 만큼 여러분이 읽는 데에도 “재미”가 있었으면 좋겠네요. 아래에 의견을 남겨주시고, Twitter에서 저를 팔로우하거나 LinkedIn에서 연락을 주시는 것도 좋아요. 저의 다음 글을 기대해주세요.\n\n안녕히 가세요!\n","ogImage":{"url":"/assets/img/2024-05-20-PleasestopusingFuntojudgeagame_0.png"},"coverImage":"/assets/img/2024-05-20-PleasestopusingFuntojudgeagame_0.png","tag":["Tech"],"readingTime":6},{"title":"C를 스크립팅 언어로 활용하기, 제13부","description":"","date":"2024-05-20 16:32","slug":"2024-05-20-UsingCasaScriptingLanguagepart13","content":"\n힙 관련 함수 최적화\n\n게임을 만들 때 병목 구간이 되지 않는 많은 부분이 있습니다. 그런 섹션에서는 종종 안전하고 표준적인 코드를 작성합니다. 보통 임시 힙 할당이 포함된 코드입니다.\n\n프로그램이 무엇을 하는지 모니터링할 수 있는 heap 및 다른 시스템 호출에 대한 상세한 설정이 있습니다. 그러나 실제 이야기는 RISC-V 어셈블리를 읽는 데 있습니다. C++에서 new를 호출하면 먼저 빈 래퍼로 이동한 다음 실제 C++ new 함수로 이동합니다. 그러면 다시 내 힙 시스템 호출 래퍼를 호출하고 최종적으로 시스템 호출을 호출합니다. C++에서는 new가 할당이 실패하면 예외를 throw할 수 있지만 여기에선 무시됩니다. 모든 것을 제어하고 있기 때문입니다. 할당에 실패하면 에뮬레이터가 예외를 throw합니다. 메모리가 부족하거나 실행 시간이 너무 길어지면 마찬가지입니다. 그러므로 new 호출 체인을 피하고 최상의 경우에는 직접 시스템 호출을 호출하고 싶습니다.\n\n이에 대한 간단한 벤치마크를 만들었습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nBenchmarking it, it took around 50ns. That’s not too bad. But, it can be improved just by avoiding all the calls that do nothing but call another function.\n\nSo, the first thing to do is to call the system call wrapper directly. This meant that I had to forego the return value from free, because in C the free function doesn’t have a return value. Otherwise the A0 register would be clobbered, and I would have a very mysterious bug on my hands. Running it, I found that it heavily reduced the run-time, now at 31ns. A 38% run-time reduction.\n\nThe last thing to try, was to write inline functions for new and delete, which would call my inline assembly functions sys_malloc and sys_free:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n인라인 void* sys_malloc(std::size_t size) {\n  register void*   ret asm(\"a0\");\n  register size_t  a0  asm(\"a0\") = size;\n  register long syscall_id asm(\"a7\") = SYSCALL_MALLOC;\n\n  asm volatile (\"ecall\"\n  : \"=m\"(*(char(*)[size]) ret), \"=r\"(ret)\n  : \"r\"(a0), \"r\"(syscall_id));\n  return ret;\n}\n인라인 void  sys_free(void* ptr)\n{\n  register void*  a0  asm(\"a0\") = ptr;\n  register long syscall_id asm(\"a7\") = SYSCALL_FREE;\n\n  asm volatile (\"ecall\"\n  :\n  : \"r\"(a0), \"r\"(syscall_id));\n}\n\n이제 ret이 레지스터 A0을 재할당하는 것을 명시하는 것을 기억해야 했지만, 모든 테스트, 벤치마크 그리고 제 게임에서 모두 잘 실행되었습니다. 지금까지 잘 되고 있어요. 벤치마크 실행 시간은 미친 듯한 19ns로 나왔어요.\n\n0000000050000b94 <_ZL16bench_alloc_freev>:\n    50000b94:   40000513                li      a0,1024\n    50000b98:   23a00893                li      a7,570\n    50000b9c:   00000073                ecall\n    50000ba0:   00050663                beqz    a0,50000bac <_ZL16bench_alloc_freev+0x18>\n    50000ba4:   23d00893                li      a7,573\n    50000ba8:   00000073                ecall\n    50000bac:   00008067                ret\n\n어셈블리를 살펴보니, 완벽해 보이고, 더 이상 개선할 수 없을 것 같아요. 실행 속도가 너무 빨라서 당연히 이렇게 되는 거예요. 거의 네이티브 성능에 가깝습니다.\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/assets/img/2024-05-20-UsingCasaScriptingLanguagepart13_0.png)\n\nwasmtime을 malloc() - free() 콤보로 실행했고, 평균 66ns가 걸린 것을 발견했어요. 48ns의 호출 오버헤드를 뺀 18ns의 런타임이 편안하게 나왔어요. 정말 빠른 속도죠. 이제는 제가 만든 힙 할당기가 문제인지 궁금해졌어요. 아마 맞겠죠? 지배적일 것입니다. 여기 차트가 있어요:\n\n![차트](/assets/img/2024-05-20-UsingCasaScriptingLanguagepart13_1.png)\n\n더 빠른 힙 할당기를 작성할 에너지가 없을 것 같아요. 특히, 내 힙 할당기가 견고하고 잘 테스트되어 있을 때 말이에요. 오랜 시간 잘 돌아가다가 이상한 메모리 조각화도 그리 심하게 일어나지 않아요. 게임을 만드는 것이 중요한데, 그럴 때 힙 할당기 같은 기본 할당기를 바꾸는 게 무서울 때가 있죠.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그래도 괜찮네요. 제가 가까이 왔군요!\n\n-곤조\n","ogImage":{"url":"/assets/img/2024-05-20-UsingCasaScriptingLanguagepart13_0.png"},"coverImage":"/assets/img/2024-05-20-UsingCasaScriptingLanguagepart13_0.png","tag":["Tech"],"readingTime":4},{"title":"글 제목 스타일로 번역하면 충격 AI가 코드 품질을 파괴한다 입니다","description":"","date":"2024-05-20 16:31","slug":"2024-05-20-SHOCKINGAIDestroysCodeQuality","content":"\n![이미지](/assets/img/2024-05-20-SHOCKINGAIDestroysCodeQuality_0.png)\n\n소프트웨어 엔지니어링에서 가장 큰 적은 기술 부채가 아닙니다. 코드 회전율이죠. 코드가 작성된 직후에 바로 변경되는 것입니다. 이는 문제의 지표뿐만 아니라 문제의 원인이 될 수도 있습니다.\n\n따라서 이 그래프를 보면 무언가 잘못되었음을 알 수 있습니다. 알아요 무엇 인가요? AI입니다. AI가 우리의 코드를 파괴하고 있어요. 조금 더 이야기를 나누어서 우리가 할 수 있는 대책을 찾아봐요.\n\n![이미지](/assets/img/2024-05-20-SHOCKINGAIDestroysCodeQuality_1.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 증거를 살펴봅시다\n\nGitClear는 AI 코드 생성 도구가 코드 품질에 어떤 영향을 미쳤는지에 대한 백서를 공개했습니다. 그 영향이 좋지 않다는 것을 알아야 합니다 (그들은 1억 5천만 줄 이상의 코드를 바탕으로 판단하고 있습니다).\n\n그들이 발견한 급증하는 코드 변동은 심각한 문제를 가리킵니다. AI는 \"복사-붙여넣기\"를 촉진하고 추가적인 코드 줄을 얼마나 빨리 추가할 수 있는지에 초첨을 맞추고 있습니다. 우리는 전혀 코딩 속도를 평가 지표로 삼아서는 안됩니다.\n\n# 속도 != 품질\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nGitHub은 코파일로 코드를 \"55% 더 빠르게\" 작성할 수 있다고 주장합니다. 개발자들은 그것을 좋아하고 새로운 코드를 만들고 기능을 제공하는 것을 즐긴다.\n\n문제는 로버트 C. 마틴(저는 그의 의견에 동의하는 편이 거의 없습니다)이 코드가 작성되는 것보다 10배 더 많은 시간을 읽는다고 주장한다는 것입니다.\n\n제 경험을 듣는 편이 더 좋을 것 같아요. 초보 개발자들이 \"코드를 밀어붙이기\"에 열중하는 것을 보았습니다. 그들은 예전보다 더 빠르게 진행하고 우리 코드베이스에 더 많은 요소를 추가하고 있습니다. 그것은 나중에 그 코드를 정리해야 하기 때문에 짜증납니다. 재사용 가능한 요소를 추출하는 작업 등이 필요합니다. 최근 팀과 몇 시간 동안 싸워야 했어요. 어떤 재사용 가능한 코드가 사실 재사용 가능하지 않고 우리 코드베이스로 넣지 말아야 할 거라고 막기 위해서 싸워야 했던 일이 있었습니다.\n\n![image](/assets/img/2024-05-20-SHOCKINGAIDestroysCodeQuality_2.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n더 이상 신중하고 깊은 사고 없이 코딩하는 방식으로의 전환은 우리 저장소의 품질을 희석시킬 뿐만 아니라, 위대한 소프트웨어 개발을 정의하는 장인 정신을 약화시키는 것입니다. AI에게 직장을 잃어버릴 걱정은 없어요. 이런 상황이 계속된다면 분야에서 훌륭한 소프트웨어 개발자가 남지 않을 것을 걱정합니다.\n\n# 복사 붙여넣기의 매력\n\n복사 붙여넣기 생활. 스택 오버플로우나 좋아하는 AI를 통해 코드를 찾아서 코드베이스에 넣습니다. 개발자는 기능을 개발함으로써 도파민 분비를 받고 모든 것이 잘 되어 있습니다.\n\n개발자들은 새로운 기능을 만드는 것을 좋아하지만, 복사 붙여넣은 코드는 종종 유효기간을 초과하여 지속됩니다. 중복 코드를 제거할 권한이 있는 팀원이 있나요? 불행하게도, 우리 팀에는 중복 코드를 제거하기 위한 문화가 없어서 코드베이스가 고통받고 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n나는 이것이 기술 부채 문제뿐만 아니라 문화적 문제라고 생각해요.\n\n## ‘소방관 스타일’ 개발자 치료하기\n\n코드를 코드베이스에 넣는 것은 견고한 습관과 지식의 한 줌이 필요해요. '의존적 결정'을 내리는 AI를 훈련시키는 대신에 품질 높은 개발자를 얻을 수 있어요.\n\n나는 개발자를 위한 훈련 프로그램을 서두르라는 의미가 아니라 BOK를 개발하고 소프트웨어 개발자에게 그들의 지식과 성과에 대한 책임을 물어야 한다는 의미에요. 유지보수 가능한 코드를 생산할 전략을 이해하고 문제를 품질 높은 방식으로 해결할 지혜 있는 팀이 필요해요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그러면 우리 고문들은 낙차 코드를 이해하는 데 많은 시간과 노력을 들이지 않아도 되고, 그 코드를 유지하는 데 어려움을 겪지 않을 거에요. 어때요?\n\n# 결론\n\n우리가 이 AI 기술을 이용한 미래를 항해하는 동안, 좋은 소프트웨어 개발을 오랫동안 이끌어 온 원칙들인 명확성, 유지보수성, 그리고 무엇보다도 품질에 대한 헌신을 잊지 말아야 해요. 앞으로의 여정은 AI로 포장되어 있을 수 있지만, 우리의 작품의 질을 희생하지 않으면서 목적지에 도착할 수 있도록 하는 것은 인간의 손길이 될 거에요.\n\n# 저자 소개\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n프로 소프트웨어 개발자 \"비밀 개발자\"는 Twitter에서 @TheSDeveloper로 찾을 수 있으며 주로 Medium.com을 통해 기사를 게시합니다.\n\n비밀 개발자는 여전히 Copilot보다 빠릅니다.\n","ogImage":{"url":"/assets/img/2024-05-20-SHOCKINGAIDestroysCodeQuality_0.png"},"coverImage":"/assets/img/2024-05-20-SHOCKINGAIDestroysCodeQuality_0.png","tag":["Tech"],"readingTime":4},{"title":"Udemy의 2024년에 참여할 Top 6 시스템 디자인 인터뷰 코스","description":"","date":"2024-05-20 16:29","slug":"2024-05-20-Top6SystemDesignInterviewCoursesfromUdemytojoinin2024","content":"\n## 2024 시스템 디자인 면접을 준비하는 데 도움이 되는 내가 좋아하는 Udemy 온라인 강의\n\n![이미지](/assets/img/2024-05-20-Top6SystemDesignInterviewCoursesfromUdemytojoinin2024_0.png)\n\n안녕하세요 여러분, 소프트웨어 엔지니어 또는 소프트웨어 개발자 채용 면접을 준비하고 있다면, 시스템 디자인을 준비하는 것이 얼마나 중요한지 아실 것입니다. 특히 Amazon, Google, Meta, Apple 및 Netflix와 같은 최고의 기업에서 개발자 채용을 하길 원한다면 더욱 그렇습니다.\n\n과거에 저는 시스템 디자인 면접 준비를 위한 최고의 System Design Interview Books, 웹사이트, 인기 있는 소프트웨어 디자인 연습 문제와 같은 여러 자료를 공유했었고, 오늘은 Udemy에서의 최고의 시스템 디자인 강좌를 소개하려 합니다. 저의 기술 관련 학습을 위한 가장 좋아하는 장소 중 하나인 Udemy입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n요! Udemy를 선택한 이유는 주로 가격 때문이에요. 이 가격으로 최고 품질의 50시간 이상 강좌를 찾을 수 있는 다른 곳은 없어요.\n\n가격 외에도 선택의 다양성이 Udemy를 선호하는 이유 중 하나에요. 온라인 강좌 시장에서 가장 크며, 다양한 선택지가 준비돼 있어요.\n\n강좌를 수강하다 강사나 그의 설명 방식, 내용을 좋아하지 않는다면 환불을 요청하여 다른 강좌를 선택할 수 있어요. 이런 시설은 Educative나 Pluralsight와 같은 정기 구독 사이트를 제외하고 다른 곳에서는 찾아보지 못한 것이에요.\n\n그래서, 저는 시스템 디자인 강좌를 수강하기 위해 항상 Udemy로 가요. 오늘은 제 컬렉션에서 몇 가지 보석을 공유할 거에요. 그리고 급하다면, Frank Kane이 강의하는 'Mastering the System Design Interview'에 가입하세요. 이 강좌는 아마존 출신 채용 담당자가 시스템 디자인 면접에서 성공하기 위한 정확한 프로세스와 내부 팁을 제공하는 5시간 강좌에요. FAANG나 MAANG 회사의 시스템 디자인 면접을 통과하는 데 도움이 될 거에요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![image](/assets/img/2024-05-20-Top6SystemDesignInterviewCoursesfromUdemytojoinin2024_1.png)\n\n지금 이 강의를 $10에 구매할 수도 있어요. Udemy가 가장 큰 세일을 진행하고 있거든요. 올해에 인기 있는 기술을 배우기 위해 50개 이상의 강좌를 이미 구매했어요. 이 강좌도 할인가에 가입할 수 있어요. 나중에 감사할 거에요.\n\n# 2024년에 Udemy에서 가입할 수 있는 최고의 시스템 디자인 강좌 6가지\n\n더 이상 말이 필요 없이, 여기 Udemy에서 가입할 수 있는 내가 좋아하는 시스템 디자인 강좌들이에요. 이 시스템 디자인 강좌들은 시스템 디자인 전문가들과 현재 및 전 FAANG 직원들에 의해 만들어졌어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n친구들, 이들은 후보로서 면접에 합격한 것뿐만 아니라 채용 담당자로서도 인터뷰를 진행한 경험이 있어.\n\n이들 경험 많은 전문가들로부터 많은 것을 배울 수 있고, 이런 강좌는 여러분에게 그런 기회를 제공해줍니다. 시스템 디자인 면접 준비를 진지하게 생각한다면, 분명히 이런 강좌들을 좋아하실 거에요.\n\n## 1. Frank Kane의 Mastering the System Design Interview\n\n이 강좌는 나가 Udemy에서 가장 먼저 들은 시스템 디자인 면접 코스 중 하나에요. Frank Kane을 Big Data와 Scala 강좌에서 알고 있었고, 그의 수업 방식과 내용에 큰 팬이었어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그래서 그가 시스템 디자인 강좌를 출시했을 때, 나는 즉시 강좌에 가입했고, 실망하지 않았다고 말해야 해.\n\n이 강좌는 캐싱, 확장성, 샤딩, 보안, 그리고 소프트웨어 아키텍처와 같은 주요 시스템 디자인 개념뿐만 아니라, 수평 및 수직 스케일링의 차이, 그리고 API 게이트웨이 대 로드 밸런서와 같은 시스템 디자인 질문에 대한 자주하는 질문도 대답한다.\n\n이 강좌는 빅데이터, ACID 속성, 데이터 구조 및 알고리즘을 다루는 것뿐만 아니라, 시스템 디자인 인터뷰 압력을 처리하는 전략을 나누고 시스템 디자인 질문에 대한 대답 방법도 소개한다.\n\n실습 과정에서 URL 단축, 웹 크롤러와 같은 인기 있는 시스템 디자인 문제를 해결하고 지식을 적용하는 방법을 배운다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n소셜 증거에 대해 얘기하자면, 이미 62,373 명 이상의 학생이 이 강좌에 참여했고, 약 8800명의 평가자로부터 평균 평점이 4.6인, 놀라운 강좌입니다.\n\nFrank은 이 강좌로 놀라운 일을 해냈습니다. 2024년 시스템 디자인 면접을 준비하는 분들에게 강력히 추천합니다.\n\n다음은 이 강좌에 가입할 수 있는 링크입니다 - Frank Kane의 Mastering the System Design Interview\n\n![이미지](/assets/img/2024-05-20-Top6SystemDesignInterviewCoursesfromUdemytojoinin2024_2.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 2. Rajdeep Saha의 Rocking System Design\n\nFrank의 강좌의 대안이 필요하다면, Rajdeep Saha가 제공하는 Rocking System Design 강좌를 확인해보세요. 이 강좌는 나에게 가장 처음 접한 Rajdeep의 강좌였는데 그 전에는 그를 몰랐어요. Rajdeep은 AWS 솔루션 아키텍트이며 그의 강좌에서 그것이 드러납니다.\n\n이 강좌에서는 면접에서 시스템 디자인 질문에 대답하는 방법뿐만 아니라 클라우드 컴퓨팅, 특히 AWS 및 클라우드를 위해 응용 프로그램을 디자인하는 방법에 대해 배울 수 있습니다.\n\n9시간의 온라인 강좌는 AWS에서의 Kubernetes, Lambda, API Gateway, EC2, ALB, NLB 등을 사용한 디자인 구현뿐만 아니라, 스케일링, 샤딩, 해싱, 마이크로서비스, 로드 밸런서, 보안, 적절한 아키텍처 프레임워크 등의 핵심 시스템 디자인 개념에 대해 다룹니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 강좌에는 퀴즈와 연습 문제가 가득합니다. 최신 시스템 디자인 퀴즈로 지식을 시험해볼 수 있습니다. 소셜 증거에 대해 이야기하자면, 13,381명 이상의 엔지니어가 이미 이 강좌에 참여했으며, 평균 평점은 4.5점으로 상당히 놀라운 수치입니다.\n\n이 강좌에 가입할 수 있는 링크는 다음과 같습니다 - Rajdeep Saha의 Rocking System Design\n\n![Rocking System Design](/assets/img/2024-05-20-Top6SystemDesignInterviewCoursesfromUdemytojoinin2024_3.png)\n\n## 3. 코드칼의 소프트웨어 아키텍처를 위한 시스템 디자인 면접 안내서\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이것은 ex FAANG 엔지니어 인 Sandeep Kaul이 만든 시스템 디자인 인터뷰에 대한 또 다른 Udemy 코스입니다. Sandeep는 다양한 기술에 대한 경험을 기반으로 넓고 깊은 지식을 갖춘 경험 많은 기술 리드/아키텍트입니다. 그의 이력에 반영된 기술은 이 코스에서 확인할 수 있습니다.\n\n이 시스템 디자인 인터뷰 가이드에서는 차세대 시스템 디자인 인터뷰를 성공적으로 치르기 위한 전략 뿐만 아니라 분산 시스템, 마이크로서비스 아키텍처, 데이터베이스, 소프트웨어 아키텍처, 분석 및 디자인 패턴에 대해 배울 수 있습니다. 이는 일상 업무에서 활용되며 엔지니어로서의 역량을 높이는 데 도움이 될 것입니다.\n\nFAANGs의 가장 일반적인 인터뷰 질문에 대한 해결책도 찾을 수 있습니다. WhatsApp, Uber, Amazon, Twitter, YouTube, AirBnb 등을 어떻게 디자인할지에 대한 내용이 포함됩니다.\n\n또한 이 코스에는 지식을 더욱 확고히 하는 데 사용할 수 있는 많은 퀴즈 및 코딩 문제도 제공됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n간략히 말해서, 시스템 설계에 관한 최고의 강좌 중 하나에요. 저는 이 강좌를 정말 사랑했습니다. Sandeep은 각 주제를 충분한 세부사항으로 다루며 다양한 기술적 측면에 대한 그의 깊은 이해가 강촌 강좌 전반에 빛을 발합니다.\n\n시스템 설계 기술을 더 발전시키고 싶은 분들에게 강력히 추천합니다.\n\n이 강좌에 참여하려면 여기를 클릭해주세요 — CodeKarle가 제공하는 소프트웨어 아키텍처를 위한 시스템 설계 면접 가이드\n\n![이미지](/assets/img/2024-05-20-Top6SystemDesignInterviewCoursesfromUdemytojoinin2024_4.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 4. Alexey Soshin에 의한 Pragmatic System Design\n\n이 5시간짜리 시스템 디자인 인터뷰 강좌는 Amazon Web Services의 시니어 솔루션 아키텍트 인 Alexy Soshin이 만들었습니다. Alexy는 시스템 디자인 전문가로 잘 알려져 있으며 \"Kotlin Design Patterns and Best Practices\" 책의 저자이기도 합니다.\n\n또한 그는 \"97 Things Every Java Programmer Should Know\" 책의 공동 저자 중 한 명으로, 최근에 즐겨 읽은 자바 책 중 하나입니다. 여기에는 97개의 전문가들로부터의 핵심 기술 주제에 대한 에세이가 포함되어 있습니다.\n\n이 Udemy의 시스템 디자인 강좌에서는 FANG 인터뷰 문제를 해결하는 방법뿐만 아니라 95 Things Every Java Programmer Should Know 및 기타 중요한 기술 주제에 대한 에세이를 찾을 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 중요한 확장성 개념\n- 일반적인 통신 프로토콜\n- 캐싱 및 Redis\n- 병행성\n- 데이터베이스 설계 및 PostgreSQL\n- 샤딩 전략 등\n\n사회적 증거에 대해 이야기할 때, 이미 26,522명 이상의 소프트웨어 엔지니어가 이 강의에 참여했으며, 평균 평점은 5점 중 4.3점이니 좋은 평가입니다.\n\n이 강의에 참여하는 링크는 여기에 있습니다 - Alexey Soshin의 실용적인 시스템 설계\n\n![이미지](/assets/img/2024-05-20-Top6SystemDesignInterviewCoursesfromUdemytojoinin2024_5.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 5. \"BigTech\" 시스템 디자인 인터뷰 부트캠프\n\n2024년 시스템 디자인 인터뷰를 준비하기 위한 부트캠프 스타일의 강의를 찾고 계시다면, 이 강의를 사랑하실 것입니다. 이 강의는 Hands-On, 프로젝트 기반 학습 및 디스코드 커뮤니티를 활용하여 다음 시스템 디자인 인터뷰를 성공적으로 준비하는 완벽한 가이드를 제공합니다!\n\nAmazon의 SSE 인 Fabien HinsenKamp이 개설한 이 강의는 구성 수준 시스템 디자인 및 실제 응용을 다루며, 10가지 모의 인터뷰 과제를 통해 실전 경험을 제공합니다.\n\n또한, 이 강의는 시스템 디자인에 대한 완벽한 소개를 제공하며, 이 강의에서 가장 좋았던 것은 기술적인 정보뿐만 아니라 기술 인터뷰에서 성공하기 위한 팁도 제공된다는 점입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n파비안이 이미 마이크로소프트에서 일하고 같은 경로를 거쳐 코드를 풀었기 때문에, 그의 조언은 전투에서 단련되어 귀중합니다.\n\n파비안은 Udemy와 Discord에서 질문과 쿼리를 받는 데 아주 민첩하고 응답이 빠릅니다. 그는 답을 숟가락으로 주지는 않지만 궁금증을 자극하여 관심 있는 주제에 대해 더 배우게 하는 것을 촉구하는 훌륭한 교사의 특징이 있습니다.\n\n다음 시스템 디자인 면접을 성공적으로 통과하고자 하는 경우, 이 강좌에 가입해 보세요. 이미 22,292 명 이상의 학생들이 이 강좌에 참여했습니다.\n\n다음 링크를 통해 이 강좌에 가입할 수 있습니다 — \"BigTech\" 시스템 디자인 면접 부트캠프.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Course Image](/assets/img/2024-05-20-Top6SystemDesignInterviewCoursesfromUdemytojoinin2024_6.png)\n\n## 6. Low Level System Design [An interview perspective]\n\n이 리스트의 대부분의 강의가 고수준 시스템 설계를 다루는 반면, 낮은 수준 시스템 설계에서 하나의 강의를 포함하여 조화를 이루고 기술 면접에서 또한 중요하기 때문에 낮은 수준 시스템 설계 강의도 포함하고 싶었습니다.\n\nAbhishek Ghosh가 만든 이 강의는 확장성을 염두에 두고 코딩하는 방법을 가르쳐줄 것입니다. 불필요한 정보를 문제 정의에서 걸러내고 추적을 식별하며 클래스 다이어그램을 만드는 방법을 배울 수 있을 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n필요할 때마다 문제에 대한 테스트 케이스를 작성하는 방법과 코드 지속 가능성을 위한 API 수정 사항을 얻는 방법에 대해 배울 것입니다.\n\n또한 이 강의에서는 필요할 때 캡슐화를 사용하는 방법과 원하는 액세서 및 뮤테이터를 생성하는 방법을 가르칩니다. 무엇보다도 면접 시 코드를 완성하는 방법을 배우고 긴급 상황에서 대비 계획에 통찰력을 얻게 됩니다. 그런 상황은 언제나 발생할 수 있습니다.\n\n사회적 증거에 대해 이 강의에 이미 4,810명 이상의 학생이 참여했으며 평균 평점은 4.5점으로, 이는 저수준 시스템 설계에 좋은 평가입니다. 저수준 시스템 설계를 숙달하고 싶다면 이 강의를 적극 추천합니다.\n\n이 강의에 가입하려면 이 링크를 확인하세요 — [저수준 시스템 설계: 면접 관점에서]\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/assets/img/2024-05-20-Top6SystemDesignInterviewCoursesfromUdemytojoinin2024_7.png)\n\n요즘 시스템 설계 면접 준비를 위해 참여할 수 있는 최고의 온라인 강좌들에 대해 알아봤어요. 시스템 설계는 매우 광범위한 주제이기 때문에 실제로 다룰 몇 개의 강좌가 필요하죠. 저는 두 명의 다른 강사로부터 배울 때 더 나아졌다고 느꼈고, 따라서 이 목록에서 다른 강사의 시스템 설계 강좌를 공유했어요.\n\n또한, 이 모든 강좌는 매우 저렴하게 제공되며 현재 Udemy 할인을 통해 단지 $10에 구매할 수 있어요. 지금 강좌를 시청할 시간이 없더라도 낮은 가격에 등록하여 돈을 절약하고, 나중에 시간이 생겼을 때 나중에 수강할 수 있어요.\n\n최근 Udemy 세일에서 시스템 설계, 프로그래밍 및 다른 기술적 주제에 대한 50개 이상의 강좌를 이미 구입했어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다른 프로그래밍 기사와 자습서\n\n- 시스템 디자인 면접 준비 방법\n- 2024년에 시스템 디자인을 배워야 하는 10가지 이유\n- 시스템 디자인 모의 면접을 위한 최고의 3곳\n- ByteByteGo 시스템 디자인 코스에서 배운 10가지\n- 인쇄가 값진 5가지 시스템 디자인 치트 시트\n- 시스템 디자인을 배우기에 최적인 ByteByteGo는?\n- Exponent의 시스템 디자인 코스는 가치가 있을까?\n- ByteByteGo 시스템 디자인 코스는 가치가 있을까?\n\n이 기사를 읽어주셔서 감사합니다. Udemy에서 이러한 시스템 디자인 면접 코스를 좋아하신다면 친구들과 공유해주세요. 이 목록에 포함되어야 할 다른 시스템 디자인 코스가 있다면 댓글로 알려주세요. 모두가 좋은 자료를 좋아하며 시스템 디자인을 행복하게 배우세요.\n\n참고: 시스템 디자인을 깊이 있게 배우고 싶다면 Udemy의 Frank Kane의 'Mastering the System Design Interview' 코스도 추천합니다. Frank는 이전 채용 담당자로써 큰 FAANG 기업의 시스템 디자인 면접을 통과하는 데 필요한 요소를 잘 알고 있습니다.\n","ogImage":{"url":"/assets/img/2024-05-20-Top6SystemDesignInterviewCoursesfromUdemytojoinin2024_0.png"},"coverImage":"/assets/img/2024-05-20-Top6SystemDesignInterviewCoursesfromUdemytojoinin2024_0.png","tag":["Tech"],"readingTime":13},{"title":"고 오류 정복하기 오류 반환과 처리에 관한 안내","description":"","date":"2024-05-20 16:27","slug":"2024-05-20-ConqueringErrorsinGoAGuidetoReturningandHandlingerrors","content":"\n## Go 오류 처리 마스터하기 위한 초보자 가이드\n\n![이미지](/assets/img/2024-05-20-ConqueringErrorsinGoAGuidetoReturningandHandlingerrors_0.png)\n\n# 레벨 1: if err != nil\n\n이것은 오류를 반환하는 가장 간단한 방법입니다. 대부분의 사람들은 이 패턴에 익숙합니다. 오류를 반환할 수 있는 함수를 호출하고, 오류가 nil인지 확인하고, nil이 아니면 오류를 반환합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```Go\nimport (\n \"errors\"\n \"fmt\"\n)\n\nfunc doSomething() (float64, error) {\n result, err := mayReturnError();\n if err != nil {\n  return 0, err\n }\n return result, nil\n}\n```\n\n## 이 방식의 문제점\n\n이 방식이 가장 간단하고 사실상 가장 많이 사용되는 방법이지만 중대한 문제점이 있습니다: 컨텍스트 부족. 깊은 호출 스택이 있는 경우 어떤 함수가 오류를 발생시켰는지 알 수 없습니다.\n\nA() 함수가 B()를 호출하고, B()가 C()를 호출하고, C()가 다음과 같은 오류를 반환하는 호출 스택을 상상해보십시오:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\npackage main\n\nimport (\n \"errors\"\n \"fmt\"\n)\n\nfunc A(x int) (int, error) {\n result, err := B(x)\n if err != nil {\n  return 0, err\n }\n return result * 3, nil\n}\n\nfunc B(x int) (int, error) {\n result, err := C(x)\n if err != nil {\n  return 0, err\n }\n return result + 2, nil\n}\n\nfunc C(x int) (int, error) {\n if x < 0 {\n  return 0, errors.New(\"negative value not allowed\")\n }\n return x * x, nil\n}\n\nfunc main() {\n // Call function A with invalid input\n result, err := A(-2)\n if err == nil {\n  fmt.Println(\"결과:\", result)\n } else {\n  fmt.Println(\"에러:\", err)\n }\n}\n```\n\n만약 이 프로그램을 실행하면 다음과 같이 출력됩니다.\n\n```js\n에러: negative value not allowed\n```\n\n우리는 호출 스택에서 이 오류가 어디에서 발생했는지에 대한 컨텍스트가 없습니다. 특정 오류 문자열을 찾아 해당 오류가 어디에서 발생했는지를 알아내기 위해 프로그램을 코드 편집기에서 열어야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 레벨 2: 에러 감싸기\n\n에러에 대한 컨텍스트를 추가하기 위해 fmt.Errorf를 사용하여 에러를 감싸줍니다.\n\n```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc A(x int) (int, error) {\n\tresult, err := B(x)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"A: %w\", err)\n\t}\n\treturn result * 3, nil\n}\n\nfunc B(x int) (int, error) {\n\tresult, err := C(x)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"B: %w\", err)\n\t}\n\treturn result + 2, nil\n}\n\nfunc C(x int) (int, error) {\n\tif x < 0 {\n\t\treturn 0, fmt.Errorf(\"C: %w\", errors.New(\"음수 값은 허용되지 않습니다\"))\n\t}\n\treturn x * x, nil\n}\n\nfunc main() {\n\t// 잘못된 입력으로 함수 A를 호출합니다.\n\tresult, err := A(-2)\n\tif err == nil {\n\t\tfmt.Println(\"결과:\", result)\n\t} else {\n\t\tfmt.Println(\"에러:\", err)\n\t}\n}\n```\n\n이 프로그램을 실행하면 아래와 같은 출력을 얻게 됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n오류: A: B: C: 음수 값은 허용되지 않습니다\n```\n\n이제 우리는 콜 스택을 이해했습니다.\n\n하지만 여전히 문제가 있습니다.\n\n## 이 방법의 문제\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n에러가 발생한 위치를 알게 되었지만 여전히 어떤 부분이 잘못되었는지는 알 수 없습니다.\n\n# Level 3: 세부적인 에러\n\n에러가 충분히 설명이 되지 않았습니다. 이것을 보다 복잡한 예제로 보여주기 위해 다음과 같이 조금 더 복잡한 예제가 필요합니다.\n\n```js\nimport (\n \"errors\"\n \"fmt\"\n)\n\nfunc DoSomething() (int, error) {\n result, err := DoSomethingElseWithTwoSteps()\n if err != nil {\n  return 0, fmt.Errorf(\"DoSomething: %w\", err)\n }\n return result * 3, nil\n}\n\nfunc DoSomethingElseWithTwoSteps() (int, error) {\n stepOne, err := StepOne()\n if err != nil {\n  return 0, fmt.Errorf(\"DoSomethingElseWithTwoSteps:%w\", err)\n }\n\n stepTwo, err := StepTwo()\n if err != nil {\n  return 0, fmt.Errorf(\"DoSomethingElseWithTwoSteps: %w\", err)\n }\n\n return stepOne + StepTwo, nil\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 예시에서 오류가 반환되면 어떤 작업이 실패했는지 명확하지 않습니다. StepOne인지 StepTwo인지 알 수 없습니다. 동일한 오류인 Error: DoSomething: DoSomethingElseWithTwoSteps: UnderlyingError가 발생합니다.\n\n그 문제를 해결하려면 발생한 구체적인 문제에 대한 문맥을 추가해야 합니다.\n\n```js\nimport (\n \"errors\"\n \"fmt\"\n)\n\nfunc DoSomething() (int, error) {\n result, err := DoSomethingElseWithTwoSteps()\n if err != nil {\n  return 0, fmt.Errorf(\"DoSomething: %w\", err)\n }\n return result * 3, nil\n}\n\nfunc DoSomethingElseWithTwoSteps() (int, error) {\n stepOne, err := StepOne()\n if err != nil {\n  return 0, fmt.Errorf(\"DoSomethingElseWithTwoSteps: StepOne: %w\", err)\n }\n\n stepTwo, err := StepTwo()\n if err != nil {\n  return 0, fmt.Errorf(\"DoSomethingElseWithTwoSteps: StepTwo: %w\", err)\n }\n\n return stepOne + StepTwo, nil\n}\n```\n\n이제 StepOne이 실패하면 Error: DoSomething: DoSomethingElseWithTwoSteps: StepOne failed: UnderlyingError를 반환합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 이 방법의 문제점\n\n이 오류는 이제 함수 이름을 사용하여 호출 스택을 표현합니다. 그러나 오류의 본질을 표현하지는 않습니다. 오류는 이야기를 전달해야 합니다.\n\n좋은 예는 HTTP 상태 코드입니다. 404를 받으면 원하는 리소스가 존재하지 않음을 알 수 있습니다.\n\n# 레벨 4: 오류 표식\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n에러 센티널은 재사용할 수 있는 미리 정의된 오류 상수입니다.\n\n함수가 실패할 수 있는 원인은 다양할 수 있지만, 일반적으로 4가지 카테고리로 나눌 수 있습니다. \"찾을 수 없음\" 오류, \"이미 존재함\" 오류, \"실패한 전제조건\" 오류, 그리고 \"내부 오류\"입니다. 이는 gRPC 상태 코드에서 영감을 받았습니다. 각 카테고리를 한 문장으로 설명해 드릴게요.\n\n\"찾을 수 없음\" 오류: 호출자가 원하는 리소스가 존재하지 않습니다. 예시: 삭제된 게시물.\n\n\"이미 존재함\" 오류: 호출자가 생성하려는 리소스가 이미 존재합니다. 예시: 같은 이름을 가진 조직.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n실패한 전제조건 오류: 작업 요청자가 실행하려는 작업이 실행 조건을 충족하지 않거나 나쁜 상태에 있습니다. 예시: 잔액이 0원인 계좌에서 출금을 시도하는 경우.\n\n내부 오류: 이러한 카테고리에 속하지 않는 다른 오류로 내부 오류가 발생한 경우입니다.\n\n이러한 종류의 오류만 가지고 있어도 충분하지 않습니다. 호출자에게 어떤 종류의 오류인지 알려주어야 합니다. 이를 위해 오류 센티널 및 errors.Is를 사용합니다.\n\n사용자가 지갑 잔액을 조회하고 업데이트할 수 있는 REST API가 있다고 상상해보세요. 데이터베이스에서 지갑을 조회할 때 오류 센티널을 활용하는 방법을 살펴봅시다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nimport (\n \"fmt\"\n \"net/http\"\n \"errors\"\n)\n\n// 이것들은 에러를 표현하는 상수들입니다.\nvar (\n  WalletDoesNotExistErr = errors.New(\"지갑이 존재하지 않습니다\") // 발견되지 않은 에러 타입\n  CouldNotGetWalletErr = errors.New(\"지갑을 가져올 수 없습니다\") // 내부 에러 타입\n)\n\nfunc getWalletFromDB(id int) (int, error) {\n // 더미 구현: 데이터베이스에서 지갑을 검색하는 시뮬레이션\n balance, err := db.get(id)\n\n if err != nil {\n  if balance == nil {\n    return 0, fmt.Errorf(\"%w: Wallet(id:%s)가 존재하지 않습니다: %w\", WalletDoesNotExistErr, id, err)\n  } else {\n    return 0, fmt.Errorf(\"%w: 데이터베이스에서 Wallet(id:%s)를 가져올 수 없습니다: %w\", CouldNotGetWalletErr, id, err)\n  }\n }\n\n return *balance, nil\n}\n```\n\n이제 이제 REST 핸들러에서 다음과 같이 할 수 있는 것을 보여줍니다.\n\n```js\nfunc getWalletBalance() {\n wallet, err := getWalletFromDB(id)\n\n if errors.Is(err, WalletDoesNotExistErr) {\n  // 404 반환\n } else if errors.Is(err, CouldNotGetWalletErr) {\n  // 500 반환\n }\n}\n```\n\n다른 예제를 살펴보겠습니다. 사용자가 잔액을 업데이트하고자 하는 경우를 보겠습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nimport (\n \"fmt\"\n \"net/http\"\n \"errors\"\n)\n\nvar (\n  WalletDoesNotExistErr = errors.New(\"Wallet does not exist\") // Not Found Error Type\n  CouldNotDebitWalletErr = errors.New(\"Could not debit Wallet\") // Internal Error Type\n  InsufficientWalletBalanceErr = errors.New(\"Insufficient balance in Wallet\") // Failed Precondition Error Type\n)\n\nfunc debitWalletInDB(id int, amount int) error {\n // Dummy implementation: simulate retrieving a wallet from a database\n balance, err := db.get(id)\n\n if err != nil {\n  if balance == nil {\n    return fmt.Errorf(\"%w: Wallet(id:%s) does not exist: %w\", WalletDoesNotExistErr, id, err)\n  } else {\n    return fmt.Errorf(\"%w: could not get Wallet(id:%s) from db: %w\", CouldNotDebitWalletErr, id, err)\n  }\n }\n\n if *balance <= 0 {\n   return 0, fmt.Errorf(\"%w: Wallet(id:%s) balance is 0\", InsufficientWalletBalanceErr, id)\n }\n\n updatedBalance := *balance - amount\n\n // Dummy implementation: simulate updating a wallet in a database\n err := db.update(id, updatedBalance)\n\n if err != nil {\n   return fmt.Errorf(\"%w: could not update Wallet(id:%s) in db: %w\", CouldNotDebitWalletErr, id, err)\n }\n\n return nil\n}\n```\n\n## Using sentinels for better error messages\n\nYou might have noticed that I have a particular way of formatting errors. I prefer structuring an error message in one of two ways:\n\n- `fmt.Errorf(\"%w: description: %w\", Sentinel, err)` or\n- `fmt.Errorf(\"%w: description\", Sentinel)`\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이것은 오류가 발생한 이유와 근본적인 원인을 알려주는 이야기를 만듭니다.\n\n이것은 중요합니다. 왜냐하면 위 예제에서 보는 바와 같이 동일한 유형의 오류가 두 가지 다른 근본적인 이슈로 인해 발생할 수 있기 때문입니다. 따라서 설명이 우리가 정확히 무엇이 잘못되었는지와 그 이유를 정확히 찾게 도와줍니다.\n\n# 보너스: 에러를 기록하는 곳\n\n당신이 발견한 모든 오류를 기록해서는 안 된다는 것에 놀랄지도 모릅니다. 왜냐하면 로그가 아래와 같이 보이기 때문입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n에러: C: 음수 값은 허용되지 않습니다\n에러: B: C: 음수 값은 허용되지 않습니다\n에러: A: B: C: 음수 값은 허용되지 않습니다\n```\n\n에러를 기록하는 곳은 반드시 \"처리\"할 수 있는 경우에만 해야 합니다. 여기서 처리란 호출자가 에러를 받아서 무언가 처리하고 계속 실행할 수 있도록 하는 것을 의미합니다.\n\n전형적인 예시는 다시 말해 REST 핸들러일 것입니다. REST 핸들러가 에러를 받으면 해당 에러의 타입을 살펴보고, 적절한 상태 코드로 응답을 보내고 에러 전파를 중단할 수 있습니다.\n\n```js\nfunc getWalletBalance() {\n wallet, err := getWalletFromDB(id)\n\n if err != nil {\n  fmt.Printf(\"%w\", err) // 여기에서는 오직 에러를 로깅합니다\n }\n\n if errors.Is(err, WalletDoesNotExistErr) {\n  // 404 반환\n } else if errors.Is(err, CouldNotGetWalletErr) {\n  // 500 반환\n }\n}\n```\n","ogImage":{"url":"/assets/img/2024-05-20-ConqueringErrorsinGoAGuidetoReturningandHandlingerrors_0.png"},"coverImage":"/assets/img/2024-05-20-ConqueringErrorsinGoAGuidetoReturningandHandlingerrors_0.png","tag":["Tech"],"readingTime":12},{"title":"데이터 제품을 위한 데이터 조작","description":"","date":"2024-05-20 16:25","slug":"2024-05-20-DataOrchestrationforDataProducts","content":"\n이 문서는 Modern Data Stack 101에 처음 등장했습니다. 만일 Medium 회원이 아니라면, 무료로 여기에서 읽을 수 있어요 💸\n\n# 제 소개\n\n저는 후고 루입니다. 런던에서 M&A로 일한 후 JUUL에 합류하여 데이터 엔지니어링에 빠져들게 되었습니다. 런던을 기반으로 하는 스케일업 기업 Codat의 데이터 기능을 이끌었습니다. 지금은 Orchestra의 CEO입니다. Orchestra는 데이터 팀이 신뢰성 있고 효율적으로 데이터를 프로덕션 환경으로 릴리즈할 수 있도록 도와주는 데이터 릴리즈 파이프라인 도구입니다. 🚀\n\n⭐️ 또한 우리의 Substack와 내부 블로그도 확인해 보세요 ⭐️\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 소개\n\n현재 데이터 팀들은 오르막길을 오르는 중입니다. 한편으로, 데이터 제품에 대한 수요는 이전보다 커졌습니다. AI가 데이터 기반의 기능, 제품 및 능력에 대한 수요를 높였고, CEO들의 욕망 또한 증가했습니다. 이러한 요구는 데이터 파이프라인 및 데이터 및 데이터 수집의 효율적 관리에 의해 가능케 되었습니다.\n\n다른 한편으로, 데이터 팀의 예산은 삭감되고 인력도 줄어들고 있습니다. 이로 인해 데이터를 조직하는 능력이 저하되었고, 결과적으로 조직이 활용할 수 없는 많은 다양한 데이터 소스(구조화된 및 비구조화된 데이터)가 계속되고 있습니다.\n\n성장과 성공을 위한 가장 큰 촉매제 중 하나는 수동 데이터 사용의 고통을 없애고 데이터 조종, 데이터 관측, 계보, 메타데이터 수집 및 경보를 통합하는 통합 제어 평면을 가지고 있는 것입니다. 이 글에서는 데이터 조종 프로세스가 데이터 및 AI 제품 속도를 가속화하는 데 어떤 역할을 하는지와 채택할 수 있는 방법을 살펴보겠습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 오픈 소스 워크플로 오케스트레이션 도구 대 전체 제어 플랜\n\nAirflow 및 Prefect와 같은 오픈 소스 워크플로 오케스트레이션 도구는 데이터 워크플로 관리 및 자동화에 강력한 기능을 제공하지만, 전체 제어 플랜과 비교할 때 접근 방식과 기능이 다릅니다.\n\nAirflow는 에어비앤비에서 개발한 오픈 소스 도구로, 워크플로 스케줄링, 모니터링 및 관리에 중점을 둡니다. Airflow는 방향성 비순환 그래프(DAG)를 사용하여 워크플로를 정의하고 다양한 외부 시스템과 통합을 지원합니다. Airflow의 장점은 유연성과 확장성에 있어, 사용자가 복잡한 워크플로를 생성하고 대량의 데이터를 처리할 수 있도록 합니다.\n\n반면 Prefect는 사용 편의성, 신뢰성 및 데이터 버전 관리를 강조하는 또 다른 오픈 소스 워크플로 오케스트레이션 도구입니다. Prefect는 워크플로를 정의하는 데 더 직관적인 인터페이스를 제공하며 자동 재시도 논리, 작업 의존성 및 워크플로를 모니터링하고 관리하는 중앙 대시보드와 같은 기능을 제공합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n오픈 소스 워크플로 오케스트레이션 도구인 Airflow와 Prefect를 All-in-One 제어 플레인인 Orchestra, Apache NiFi, DataOS 또는 AWS Step Functions과 같은 플랫폼 또는 프로프리터리 솔루션과 비교할 때, All-in-One 제어 플레인은 종종 더 간편한 사용자 경험을 제공하고 학습 커브가 낮다는 큰 차이점이 있습니다. 그들은 사용자들이 기술적 지식이 적은 사용자도 접근할 수 있게끔 그래픽 표현, 드래그 앤 드롭 기능, 일반적인 워크플로를 위한 미리 구축된 템플릿과 같은 선호하는 형태의 표준 인터페이스를 제공할 수 있습니다.\n\n그러나 제어 플레인의 진정한 힘은 데이터 생태계의 모든 엔티티와 상호 작용할 수 있는 능력에 있습니다. 이로 인해 불필요한 통합 오버헤드를 완전히 줄일 수 있습니다. 더 흥미로운 점은 중앙 제어 플레인이 글로벌 메타데이터 및 거버넌스 프로토콜에 접근할 수 있어 데이터 주변의 완전한 컨텍스트와 안전하게 작동할 수 있는 오케스트레이션을 제공할 수 있다는 것입니다.\n\n# OSS 오케스트레이션 시스템이 안티 패턴을 장려\n\n기존 OSS 워크플로는 데이터 아키텍처에 대한 통합적인 접근을 장려합니다. 이는 \"모던 데이터 스택\"의 모든 구성 요소를 처리할 수 있는 단일 저장소와 단일 애플리케이션이 있다는 것을 의미합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n많은 사람들이 이 아키텍처를 간단히 갖고 있지 않습니다. 데이터 서비스를 구축하는 것은 어렵습니다. 데이터 파이프라인을 구축하는 것은 종종 파이프라인의 다른 부분에서 특화된 서비스가 필요합니다. 사실, 서로 다른 팀이 있는 것이 필요하게 만드는 경우가 많습니다.\n\n예를 들어, 데이터 엔지니어링 팀은 Kafka나 다른 이벤트 기반 스트리밍 응용 프로그램을 관리할 책임이 있을 수 있습니다. 분석 팀은 dbt 저장소를 관리할 수도 있습니다. 이들은 분리되어야 합니다.\n\n따라서 OSS Workflow Orchestration 도구로 현대 데이터 스택을 활용하는 것은 어느 정도 반대 패턴이며 추가적이고 비싼 감시 플랫폼이 필요합니다. \"Quis custodiet ipsos custodes?\" 또는 \"수호자를 지킬 자가 누구인가?\" 라는 문구가 떠오릅니다.\n\n![이미지](/assets/img/2024-05-20-DataOrchestrationforDataProducts_0.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이미지 제공: 작성자\n\n# 효율적인 마이크로서비스 아키텍처 활성화 방법\n\n데이터 제품 속도에 미치는 통합 데이터 조작의 영향\n\n데이터 조작 프로세스 자동화를 위한 통합 제어 평면을 갖는 것은 여러 가지 이점을 제공합니다.\n\n## 보일러플레이트 작업 제거\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n기존 인프라를 사용하여 모든 중요한 계산을 처리하고 데이터 Orchestration 도구가 기존 프로세스를 조정하는 데 기여함으로써 엔지니어는 새로운 기술(Airflow 등)을 배우거나 인프라를 배포(Kubernetes 등)하거나 복잡한 UI에 대처할 필요가 없습니다.\n\n엔지니어와 데이터 팀은 데이터 수집, 데이터 정리, 분석 그리고 기계 학습에 집중하며 조정이 나머지 부분을 처리하도록 의지할 수 있습니다.\n\n## 비용과 메타데이터에 대해 걱정하지 마세요\n\n통합되지 않은 데이터 또는 Workflow Orchestration 도구를 사용하면 소중한 메타데이터가 원본 시스템 내에서 통합되지 않은 상태로 남아 있고 데이터 수명 주기 정책으로 인해 심지어 사라질 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n통합 조작 및 감시는이 데이터가 실시간으로 효율적으로 수집되어 데이터 팀에서 사용할 수 있도록합니다. 이를 통해 이집트된 데이터 소스 간의 메타데이터 관리가 쉬워집니다.\n\n## 비즈니스 가치 계산\n\n통합 조작 플랫폼을 사용하면 데이터 엔지니어가 데이터 및 AI 제품의 비즈니스 가치를 정량화 할 수 있습니다. 예를 들어, 쿼리당 비용 데이터 및 AWS 컴퓨팅 비용을 가져오는 동시에 대시보드 및 머신러닝 모델 사용 통계를 볼 수 있습니다.\n\n이 비즈니스 중요한 운영 데이터를 데이터 제품 수준에서 가지면 데이터 팀은 좀 더 효율적으로 우선순위를 정할뿐만 아니라 기업에 그들의 가치와 가치를 보여줄 수있는 창문을 마침내 가질 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n통합 데이터 조율 및 데이터 가시성 플랫폼은 모든 작업을 청소하는 것, 유용한 메타데이터를 수집하고 데이터 제품 수준에서 제공함으로써 제품 속도를 빠르게 가속화할 수 있습니다. 엔지니어들이 기술적인 도전을 극복하는 데 시간을 절약하고, 다수의 감각적 이점을 얻습니다.\n\n데이터 품질을 선제적으로 모니터링하고 데이터 문제를 예방하며 비즈니스 이해관계자에게 (따라서 신뢰를 얻으며) 데이터 및 AI 이니셔티브를 무제알고 효율적으로 우선순위를 설정하는 것은 모두 통합 데이터 조율 플랫폼 또는 데이터 제어 플레인으로 가능합니다. Orchestra와 같은 제어 플레인은 기업이 전례 없는 속도로 데이터를 활용할 수 있도록 길을 열고 있습니다.\n\n# 기존 데이터 조율 솔루션의 한계점\n\n기존 조율 솔루션은 여러 가지 중요한 영역에서 종종 한계점을 지니고 있습니다. 첫째, 그들은 종종 사용자들에게 파이썬 코드를 큰 monorepo에서 작성하도록 강요하여 코드베이스가 커질수록 규모화하고 관리하기 어렵게 만듭니다. 이는 복잡성과 유지보수 도전을 증가시킬 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n또한, 많은 기존 도구들에서는 가시성과 종단간 메타데이터 추적이 부족합니다. 이로 인해 사용자들이 데이터 및 프로세스의 흐름을 이해하기 어려워지며, 디버깅과 모니터링에 문제가 발생할 수 있습니다.\n\n마지막으로, 데이터 및 AI 제품의 성능을 종합적으로 파악할 수 있는 사용자 친화적 인터페이스가 부족합니다. 이러한 UI의 부재로 사용자들은 워크플로우를 쉽게 모니터링하고 최적화하여 성능과 효율성을 향상시키기 어려워집니다.\n\n## Multi-Tenancy와 거버넌스 부재\n\n다양한 팀이 다양한 소프트웨어를 사용하는 환경에서는 전체 데이터 운영에 대한 다중 테넌트 뷰를 얻는 것이 불가능합니다. 이는 팀 간 디버깅 라인지 그래프를 어렵게 만들며, 협업에 있어서 도전을 초래하며, 데이터 파이프라인을 관리하기 어렵게 만듭니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 보안 준수\n\n단일 저장소에서는 개인 및 클러스터 모두 필요 이상의 비밀 정보에 액세스할 수 있습니다. 이는 여러 사람이 실제로 액세스할 필요가 없는 코드 베이스의 일부에 액세스할 수 있어 장애 발생 가능성을 높이게 됩니다.\n\n## 경보 및 소유권\n\n다양한 팀이 사용하는 여러 저장소가 있는 경우, 경보 및 데이터 자산 소유는 도전적일 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 원활한 지속적 통합\n\n자주 놓치는 요소 중 하나인 데이터 파이프라인 저장소의 지속적 통합은 서비스 기반의 데이터 수집 스크립트와 같은 서비스 기반의 마이크로서비스에 대해 비교적 직관적입니다.\n\n그러나 dbt를 활용한 분석 저장소의 경우, dbt Slim CI와 같은 것이 필요하거나 프로젝트 Nessie의 데이터를 위한 Git-Control이 필요합니다. 이러한 환경에서 최소한의 CI가 실행되도록 보장하는 것만으로도 챌린지입니다. 그리고 데이터 수집, 스트리밍, 변환, 운영 분석에 대한 코드가 동일한 위치에 있는 경우, 더 복잡해집니다.\n\n# 요약\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n본질적으로, 기본 사항인 제품 접근 방식으로 내려가는 것이 중요합니다. 제품 중심이 되는 것은 무엇을 의미할까요? 사용자 경험과 개선에 대한 완전한 초점. XYZ 작업 수행을 위한 노력을 줄이는 것입니다.\n\n데이터 제품을 구축할 때, 우리는 고객을 '사용자'로만 다루지 않고, 데이터 엔지니어와 분석 엔지니어도 데이터 제품 접근 방식의 '사용자'로 취급합니다. 그들의 삶은 기관이 데이터를 구축하는 방식으로 지속적으로 영향을 받는데, 그것은 최종 사용자에도 항상 영향을 줍니다.\n\n제품 접근 방식은 거대한 전략이 아닙니다. 사실, 데이터 워크플로우의 작은 구석마다 그리고 마지막 순간마다 살아있는 원자적 전략입니다. 오케스트레이션은 이 이야기에서 제외되지 않으며 사실, 이를 상당부분 이끌어 내는 요소입니다. 데이터 제품의 맥락에서 오케스트레이션도 사용자 중심 접근 방식을 채택하여 데이터 및 분석 엔지니어가 약간 더 용이하게 호흡할 수 있도록 합니다.\n","ogImage":{"url":"/assets/img/2024-05-20-DataOrchestrationforDataProducts_0.png"},"coverImage":"/assets/img/2024-05-20-DataOrchestrationforDataProducts_0.png","tag":["Tech"],"readingTime":9},{"title":"최대 요청 지터 - 비동기 Gunicorn 워커의 중추","description":"","date":"2024-05-20 16:24","slug":"2024-05-20-MaxRequestsJitterTheSpineofAsyncGunicornWorkers","content":"\n<img src=\"/assets/img/2024-05-20-MaxRequestsJitterTheSpineofAsyncGunicornWorkers_0.png\" />\n\n안녕하세요! 어느 날 갑작스럽게 기본 백엔드 서버가 다운되었어요. 이런 상황은 모든 소프트웨어 엔지니어가 두려워하는 일이지요. 다행히도 저희는 메인 백엔드 어플리케이션을 위해 두 개의 ECS 작업(각 작업을 서버로 생각하시면 돼요)를 구성해 두었어요. 우리의 Auto Scaling 그룹은 항상 두 개의 작업이 실행 중인 상태를 유지하도록 설정되어 있어, 서버들은 자동으로 다시 시작되었답니다. 그러나 문제는 계속 발생했고 때로는 간헐적으로 일어났어요.\n\n멈춘 서버 작업의 로그를 조사하기 시작했어요. 관련 정보가 거의 없는 것을 발견했지만, Gunicorn이 oom-killer를 호출한 흔적을 발견했습니다.\n\n낮은 메모리가 문제일까요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nGunicorn이 UTC 오전 05:43:20에 out-of-memory (oom) 킬러를 호출했습니다. 이전에 UTC 오전 05:42:36에 ECS에서 작업이 건강하지 않다고 판단되었습니다. 낮은 메모리로 인해 Gunicorn이 요청을 처리하지 못했을 가능성이 있습니다. 이로 인해 요청에 응답을 중단하고 일정한 시간 초과 또는 버퍼 기간 후 oom 킬러를 호출했을 수 있습니다.\n\n양 서버에서 'top' 명령어를 통해 메모리가 잠재적으로 문제가 될 수 있다는 것을 시사했습니다. 이는 Gunicorn이 oom-killer를 호출하여 더 확신시켰습니다. 이러한 요소들로 인해 문제가 메모리 부족임이 확인되었습니다.\n\n초반에는 많은 양의 요청들이 서버의 메모리를 고갈시킬 수도 있다고 가정했습니다. 따라서 주어진 기간 내에 서비스된 요청 수를 추적하는 Athena 로그를 조사하기 시작했습니다. 그러나 결과는 놀라웠습니다. 서버가 멈출 때 API 요청은 없었고 건강 상태 확인 API 호출만 있었습니다. 저희의 설정에는 건강 상태 확인 API를 5초마다 호출하는 건강 상태 확인 구성이 포함되어 있습니다. 연속해서 두 번의 실패가 발생하면 호스트가 건강하지 않은 상태로 표시됩니다.\n\n어딘가 메모리 누수가 있는 건가요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리는 메모리 사용량이 증가하는지 모니터링하기 위해 특정 요청 수를 초당 전송하는 군사 스크립트를 실행했습니다.\n\n애플리케이션이 동기 워커를 사용하여 실행되었을 때, 메모리 사용량은 330MB 정도로 안정적이었습니다.\n\n그러나 애플리케이션이 비동기 Gevent 워커를 사용하여 실행될 때, 메모리 사용량이 175MB에서 560MB로 증가했습니다. 군사 스크립트를 후속 실행할 때, 메모리 사용량은 550–560MB 정도로 안정적으로 유지되었습니다.\n\n이 동작은 워커가 요청을 처리한 후에도 메모리를 소비하고 해제하지 않았음을 시사했습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nGunicorn 설명서에서는 메모리 누수의 영향을 완화하기 위해 최대 요청 수에 제한을 설정하는 것을 권장합니다. max-requests 매개변수는 워커가 다시 시작되기 전에 처리할 수 있는 최대 요청 수를 정의합니다. 또한, max-requests-jitter 매개변수를 설정하여 워커 다시 시작을 무작위화하여 모든 워커가 동시에 다시 시작되는 것을 방지할 수 있습니다.\n\nhttps://docs.gunicorn.org/en/stable/settings.html#max-requests\n\nmax-requests 및 max-requests-jitter로 테스트\n\n- max-requests를 100, max-requests-jitter를 30으로 설정합니다.\n- 이렇게 하면 k가 무작위 지터 값인 경우에 워커는 100 + k 요청 후에 다시 시작됩니다. 이 값은 [0, 30] 범위 내에서 지연된 다시 시작을 보장합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n관찰:\n\n# 새로운 문제의 탄생\n\n![이미지](/assets/img/2024-05-20-MaxRequestsJitterTheSpineofAsyncGunicornWorkers_1.png)\n\n구니콘 구성을 업데이트하는 도중에 max-requests 100을 구현하는 중요한 변경 사항이 도입되었습니다. 이 업데이트로 인해 서버 응답 시간에 예기치 않은 영향이 발생했으며, 우리의 메트릭에서 이러한 수치가 상당히 증가하는 것을 보고했습니다. 이 변경 사항은 중요하지 않았으며, 우리 제품 환경에서 여러 p99 경보가 트리거되어 잠재적인 문제의 명백한 표시가 되어 추가 조사와 해결이 필요하다는 것을 나타냈습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 이러한 경고에 대응하여, 우리는 max_requests와 max_requests jitter의 다양한 조합을 활용한 포괄적인 테스트 세트를 시작했습니다.\n\n![](/assets/img/2024-05-20-MaxRequestsJitterTheSpineofAsyncGunicornWorkers_2.png)\n\n우리가 결과를 조사하면서, 특정 구성이 눈에 띄었습니다. max_requests=250 및 max_requests_jitter=15의 조합은 테스트한 다른 구성과 비교했을 때 가장 유리한 결과를 보여주었습니다. 이 설정은 Maximum Memory 사용량이 468 mb로, 우리가 테스트한 다른 구성보다 현저히 낮은 측정값을 보여주었습니다. 또한, 모든 구성 중 가장 낮은 p99 결과인 1345를 나타냈습니다. 실패한 요청의 비율은 5/3330으로, 다른 구성의 비율과 일치했습니다.\n\n그러나, 테스트에서 유망한 결과를 얻었지만, 이러한 설정을 우리의 프로덕션 환경에 배포해도 p99 문제를 해결할 수 없었습니다. 이 차이로 인해 우리는 문제를 깊이 있게 들여다보고, 가능한 원인과 해결책에 대해 더 고찰해야 했습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n한 가설은 작업자가 특정 수의 요청을 처리한 후 (이 경우 250+k를 초과하는 어떤 수), 재시작을 시작할 것이라는 것이었습니다. 이 재시작은 처음에는 무해해 보이지만 약간의 지연을 초래할 수 있었고, 이후에는 요청 대기열의 누적으로 이어질 수 있습니다.\n\n우리는 max_requests와 max_requests_jitter 매개변수에 대해 더 큰 숫자를 사용하여 실험을 실행하기로 결정했습니다: max_requests=3000 max_requests_jitter=50.\n\n우리의 수정된 가설은 작업자가 특정 수의 요청을 처리한 후 (구체적으로 250+k보다 큰 수), 재시작을 거쳐야 한다는 것을 제안했습니다. 이 재시작은 약간의 지연을 유발할 수 있어 대기 중인 요청이 늘어나게 될 수 있습니다. 우리는 250가 상대적으로 작은 수이므로, 작업자들이 자주 재시작되어 재시작 프로세스 중 간헐적인 지연이 발생한다고 추정했습니다.\n\n이에 대처하기 위해, 우리는 max_requests를 더 큰 수로 증가시키기로 결정했습니다. 이는 작업자 재시작 빈도를 줄이고, 동시에 이전의 메모리 누수 문제를 다시 도입하지 않도록 하는 목적으로 수행되었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위 전략을 따라서 max_requests를 3000으로, max_requests_jitter를 50으로 증가시켰습니다. 이러한 조치의 목적은 빈번한 워커 재시작과 이로 인한 지연 문제를 피하는 것이었습니다. 이러한 새로운 설정으로 워커가 다시 시작되기 전의 최대 메모리 소비량이 600MB로 관측되었습니다. 이는 gunicorn이 메모리 임계값인 700MB에 도달한 후에만 out of memory (OOM)을 발생시키기 때문에 수용 가능한 수준으로 판단되었습니다. p99는 로드 테스트에서 max_requests = 250, max_requests_jitter = 15 구성에서의 1345ms 대비 728ms로 상당히 낮아졌습니다. 이 실험적인 접근법은 p99 문제와 메모리 문제를 효과적으로 해결하여, 서버 관리에서 계속해서 테스트, 가설 형성, 혁신적 문제 해결의 중요성을 입증했습니다.\n","ogImage":{"url":"/assets/img/2024-05-20-MaxRequestsJitterTheSpineofAsyncGunicornWorkers_0.png"},"coverImage":"/assets/img/2024-05-20-MaxRequestsJitterTheSpineofAsyncGunicornWorkers_0.png","tag":["Tech"],"readingTime":6},{"title":"리액트 네이티브에서의 애니메이션으로 구현한 타이핑 효과의 매력","description":"","date":"2024-05-20 16:23","slug":"2024-05-20-TheMagicofAnimatedTypingTransitioninReactNative","content":"\n제 웹사이트에 방문해주셔서 감사합니다!\n\n![Click Here](https://miro.medium.com/v2/resize:fit:852/1*nUVr8lekbEbpfkq53IZ2fQ.gif)\n\n당신의 React Native 앱의 사용자 경험에 몇 가지 풍미를 더하고 싶나요? 애니메이션된 타자 효과의 매료되는 세계로 빠져들어보세요! 이 글에서는 글자가 한 글자씩 나타나는 화려한 애니메이션 효과를 생성하는 방법을 살펴볼 것입니다. 이 애니메이션은 사용자에게 매혹적인 타자 경험을 제공합니다.\n\n이 매혹적인 효과를 어떻게 달성하는지 단계별로 코드를 자세히 살펴보면서 시작해봅시다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 초기 설정: 필요한 모듈을 가져와 컴포넌트의 props를 정의하는 것으로 시작합니다.\n- 상태 관리: 컴포넌트는 React 훅 (useState 및 useRef)을 사용하여 상태와 참조를 관리합니다. text 상태는 현재 표시된 텍스트를 보유하고, completed는 입력이 완료되었는지를 나타내며, cursorColor는 커서 표시 여부를 관리합니다. 또한 textIndex를 추적하여 다음에 표시할 문자를 파악합니다.\n- 스타일링: StyleSheet.create를 사용하여 텍스트의 모양을 사용자 정의하는 스타일을 정의합니다.\n- 타이핑 애니메이션: typingAnimation 함수는 주요 애니메이션 논리를 처리합니다. text prop에서 문자를 순차적으로 추가하여 입력하는 것을 모방하여 현재 표시된 텍스트에 문자를 추가합니다. 부드러운 애니메이션을 위해 재귀적 setTimeout이 사용됩니다.\n- 커서 애니메이션: cursorAnimation 함수는 깜빡이는 효과를 만들기 위해 커서의 색상을 토글합니다.\n- 효과 및 정리: useEffect 훅은 애니메이션 타이밍과 정리를 관리합니다. 컴포넌트가 마운트될 때 타이핑 애니메이션 및 커서 깜박임을 시작하고 언마운트할 때 타이머를 정리합니다.\n\n이제 앱에서 이 컴포넌트를 생성하는 방법을 살펴보겠습니다:\n\n```js\nimport React, { useRef, useState, useEffect } from 'react';\nimport { StyleSheet, Text } from 'react-native';\n\ninterface AnimatedTypingProps {\n  text: string;\n  onComplete?: () => void;\n}\n\nconst AnimatedTyping: React.FC<AnimatedTypingProps> = (props) => {\n  // 코드 생략\n\nexport default AnimatedTyping;\n```\n\n컴포넌트에서 AnimatedTyping을 가져와 원하는 텍스트 및 onComplete 콜백과 함께 사용하면 됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```jsx\n<AnimatedTyping text={query} onComplete={handleAnimationDefaultComplete} />\n```\n\n저희와 함께 이 자극적인 애니메이션 기술을 살펴봐 주셔서 감사합니다! LinkedIn에서 의견과 피드백을 남겨주시면 감사하겠습니다. 연락해서 경험을 공유해주세요. 즐거운 코딩하세요!\n\n# 매우 쉽게 설명하기 🚀\n\nIn Plain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 떠나시기 전에:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 저자를 응원하고 팔로우하기 잊지 마세요! 👏️️\n- 저희를 팔로우하세요: X | LinkedIn | YouTube | Discord | 뉴스레터\n- 다른 플랫폼에서도 만나보세요: Stackademic | CoFeed | Venture | Cubed\n- 알고리즘 콘텐츠를 다루도록 강요하는 블로깅 플랫폼에 지쳤나요? Differ를 시도해보세요\n- PlainEnglish.io에서 더 많은 콘텐츠를 만나보세요\n","ogImage":{"url":"/assets/img/2024-05-20-TheMagicofAnimatedTypingTransitioninReactNative_0.png"},"coverImage":"/assets/img/2024-05-20-TheMagicofAnimatedTypingTransitioninReactNative_0.png","tag":["Tech"],"readingTime":3},{"title":"AppDelegate, SceneDelegate, 그리고 SwiftUI 라이프사이클 이해하기","description":"","date":"2024-05-20 16:21","slug":"2024-05-20-UnderstandingAppDelegateSceneDelegateandSwiftUILifecycle","content":"\n<img src=\"/assets/img/2024-05-20-UnderstandingAppDelegateSceneDelegateandSwiftUILifecycle_0.png\" />\n\nAppDelegate는 무엇인가요?\n\niOS의 이전 버전에서, iOS 13 이전에는 AppDelegate라는 것이 있었습니다. 이것은 앱의 보스 역할을 했고, 앱이 시작하거나 중지되거나 백그라운드로 이동할 때 관리를 했습니다. 앱 시작 및 백그라운드 모드 같은 중요한 이벤트를 다뤘습니다.\n\n```swift\nimport UIKit\n\n@UIApplicationMain\nclass AppDelegate: UIResponder, UIApplicationDelegate {\n\n    var window: UIWindow?\n\n    func application(_ application: UIApplication, didFinishLaunchingWithOptions\n                     launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {\n        // 애플리케이션 시작 후 커스터마이징을 위한 오버라이드 포인트입니다.\n        return true\n    }\n\n    func applicationWillResignActive(_ application: UIApplication) {\n        /*\n         애플리케이션이 비활성 상태로 이동할 때 전송됩니다. 일시적으로 인터럽트(예: 전화 통화 또는 SMS 메시지 수신)가 발생하거나 사용자가 애플리케이션을 종료하고 백그라운드 상태로 전환될때 발생할 수 있습니다.\n         계속 중인 작업을 일시 중지하고 타이머를 비활성화하며 그래픽 렌더링 콜백을 무효화하는 데 이 메서드를 사용합니다. 게임은 게임 일시 중지에 이 방법을 사용해야 합니다.\n         */\n    }\n\n    func applicationDidEnterBackground(_ application: UIApplication) {\n        /*\n        공유 리소스를 해제하고 사용자 데이터를 저장하며 타이머를 무효화하며 애플리케이션 상태 정보를 충분히 저장하여 나중에 종료됐을 때 애플리케이션을 현재 상태로 복원하는 데 이 메서드를 사용합니다.\n        애플리케이션이 백그라운드 실행을 지원하는 경우, 이 방법은 사용자가 종료할 때 applicationWillTerminate: 대신 호출됩니다.\n         */\n    }\n\n    func applicationWillEnterForeground(_ application: UIApplication) {\n        /*\n        백그라운드에서 활성 상태로 전환하는 일부로 호출됩니다;\n        여기서 백그라운드 진입 때에 수행되었던 변경을 취소할 수 있습니다.\n         */\n    }\n\n    func applicationDidBecomeActive(_ application: UIApplication) {\n        /*\n        애플리케이션이 비활성 상태일 때 일시 중지된 작업(또는 아직 시작되지 않은 작업)을 다시 시작합니다.\n        애플리케이션이 이전에 백그라운드에 있었을 경우 선택적으로 사용자 인터페이스를 새로 고칩니다.\n         */\n    }\n\n    func applicationWillTerminate(_ application: UIApplication) {\n        /*\n        애플리케이션이 종료되기 직전에 호출됩니다.\n        적절하다면 데이터를 저장합니다. 또한 applicationDidEnterBackground:도 참조하십시오.\n         */\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nSceneDelegate- 뭐야?\n\niOS 13가 출시되었을 때 Apple은 SceneDelegate라는 새로운 기능을 추가했어. 이건 주로 iPad를 위한 거였는데, 이를 통해 다중 창을 사용할 수 있게 됐어. AppDelegate의 일부 업무가 SceneDelegate로 넘어가게 됐어. 그래서 이제 두 개가 함께 앱을 관리하게 되었어.\n\nAppDelegate.swift\n\n```js\nimport UIKit\n\n@main\nclass AppDelegate: UIResponder, UIApplicationDelegate {\n\n    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {\n        // 애플리케이션 시작 후 커스터마이징할 때 오버라이드 포인트\n        return true\n    }\n\n    // MARK: UISceneSession 생명주기\n\n    func application(_ application: UIApplication, configurationForConnecting connectingSceneSession: UISceneSession, options: UIScene.ConnectionOptions) -> UISceneConfiguration {\n        // 새로운 씬 세션을 생성할 때 호출\n        // 이 메소드를 사용하여 새 씬을 만들기 위한 구성을 선택해\n        return UISceneConfiguration(name: \"Default Configuration\", sessionRole: connectingSceneSession.role)\n    }\n\n    func application(_ application: UIApplication, didDiscardSceneSessions sceneSessions: Set<UISceneSession>) {\n        // 사용자가 씬 세션을 삭제했을 때 호출\n        // 응용프로그램이 실행 중이 아닌 경우 어떤 세션이 삭제되었다면, application:didFinishLaunchingWithOptions 이후에 이 메소드가 호출될 거야\n        // 폐기된 씬에 특정한 리소스를 해제하는 데 이 메소드를 사용해, 다시 돌아오지 않을 거니까\n    }\n\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nSceneDelegate.swift\n\n```swift\nimport UIKit\n\nclass SceneDelegate: UIResponder, UIWindowSceneDelegate {\n\n    var window: UIWindow?\n\n\n    func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {\n        // 이 메서드를 사용하여 UIWindow 'window'를 선택적으로 구성하고 UIWindowScene 'scene'에 연결합니다.\n        // Storyboard를 사용하는 경우 'window' 속성은 자동으로 초기화되어 scene에 연결됩니다.\n        // 이 델리게이트는 연결되는 scene이나 세션이 새로운 것임을 의미하지 않습니다 (대신 'application:configurationForConnectingSceneSession' 참조).\n        guard let _ = (scene as? UIWindowScene) else { return }\n    }\n\n    func sceneDidDisconnect(_ scene: UIScene) {\n        // 시스템에 의해 해제되는 즉시 scene이 호출됩니다.\n        // scene이 백그라운드로 들어가거나 해당 세션이 버려질 때 발생합니다.\n        // 이 scene과 관련된 재생성 가능한 리소스를 해제합니다.\n        // scene이 다시 연결될 수 있으므로 세션이 반드시 버려지지는 않습니다('application:didDiscardSceneSessions' 참조).\n    }\n\n    func sceneDidBecomeActive(_ scene: UIScene) {\n        // scene이 비활성 상태에서 활성 상태로 전환된 경우에 호출됩니다.\n        // scene이 비활성 상태였을 때 일시 중단되었던 작업을 다시 시작하는 데 이 메서드를 사용합니다.\n    }\n\n    func sceneWillResignActive(_ scene: UIScene) {\n        // scene이 활성 상태에서 비활성 상태로 전환될 때 호출됩니다.\n        // 일시적인 중단(예: 전화 통화 수신)으로 인해 발생할 수 있습니다.\n    }\n\n    func sceneWillEnterForeground(_ scene: UIScene) {\n        // scene이 백그라운드에서 전경으로 전환될 때 호출됩니다.\n        // 백그라운드로 전환할 때 발생한 변경 사항을 취소하는 데 이 메서드를 사용합니다.\n    }\n\n    func sceneDidEnterBackground(_ scene: UIScene) {\n        // scene이 전경에서 백그라운드로 전환될 때 호출됩니다.\n        // 데이터를 저장하고 공유 리소스를 해제하며 충분한 scene별 상태 정보를 저장하여\n        // scene을 현재 상태로 복원하는 데 이 메서드를 사용합니다.\n    }\n\n}\n```\n\n차이점은 SceneDelegate가 여러 창을 다루는 반면에 AppDelegate는 여전히 평소 역할을 합니다. 따라서 이제 앱은 다른 창에서 다른 내용을 동시에 표시하는 것과 같이 더 많은 일을 할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그리고 SwiftUI는요?\n\nSwiftUI를 사용하면 Apple의 새로운 앱 개발 방법으로, 더 이상 AppDelegate 또는 SceneDelegate가 필요하지 않을 수도 있어요. 대신에 Notification Event로 대부분의 작업을 처리할 수 있어요. 하지만 만약 프로젝트에 아직 AppDelegate 또는 SceneDelegate가 있다면, 코드를 깔끔하고 조직적으로 유지하는 데 도움이 될 거예요.\n\n그래서, 이것이 다른 iOS 버전에서 앱의 주요 매니저들이 작동하는 방식이에요.\n\nSwiftUI에서 AppDelegate를 구현하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- AppDelegate.swift 파일을 만듭니다.\n\n새 파일 추가로 이동 - `Cocoa Touch Class`를 선택합니다.\n\n![이미지](/assets/img/2024-05-20-UnderstandingAppDelegateSceneDelegateandSwiftUILifecycle_1.png)\n\n이름(AppDelegate)을 입력하고 NSObject의 subclass를 선택합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![UnderstandingAppDelegateSceneDelegateandSwiftUILifecycle](/assets/img/2024-05-20-UnderstandingAppDelegateSceneDelegateandSwiftUILifecycle_2.png)\n\nClick on “Next” will create Appdelegate.swift file which look like below\n\n```swift\nimport UIKit\nclass AppDelegate: NSObject {\n\n}\n```\n\n2. With following above process again we can create SceneDelegate.swift file.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![UnderstandingAppDelegateSceneDelegateandSwiftUILifecycle_3](/assets/img/2024-05-20-UnderstandingAppDelegateSceneDelegateandSwiftUILifecycle_3.png)\n\nAppDelegate.swift 파일과 처음으로 나타날 것입니다.\n\n```swift\nimport UIKit\nclass SceneDelegate: NSObject {\n\n}\n```\n\n이제 AppDelegate.swift와 SceneDelegate.swift 파일에 적용해야 할 실제 변경 사항을 아래에 안내해드립니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nAppDelegate.swift\n\n```swift\nclass AppDelegate: NSObject, UIApplicationDelegate {\n\n     func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey : Any]? = nil) -> Bool {\n         return true\n     }\n\n     func application(_ application: UIApplication, configurationForConnecting connectingSceneSession: UISceneSession, options: UIScene.ConnectionOptions) -> UISceneConfiguration {\n\n         let sceneConfig : UISceneConfiguration = UISceneConfiguration(name: nil, sessionRole: connectingSceneSession.role)\n         sceneConfig.delegateClass = SceneDelegate.self\n         return sceneConfig\n\n     }\n }\n```\n\nUIApplicationDelegate은 iOS 개발에서 사용되는 프로토콜로, iOS 애플리케이션의 라이프사이클 이벤트를 관리하고 응답하는 일련의 메서드를 정의합니다.\n\n이 프로토콜은 앱 시작, 종료, 백그라운드 또는 포그라운드 진입, 푸시 알림 수신 등과 같은 이벤트를 처리하기 위한 중앙 허브 역할을 합니다. 제공된 코드의 AppDelegate와 같이 이 프로토콜을 준수하는 클래스는 이러한 메서드를 구현하여 애플리케이션의 동작을 라이프사이클 이벤트에 따라 맞춤화할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 첫 번째 함수인 application(\\_:didFinishLaunchingWithOptions:)은 앱이 로딩을 마칠 때 호출됩니다. 이 함수는 실행이 성공적인지 여부를 나타내는 부울 값이 반환됩니다.\n- 두 번째 함수인 application(\\_:configurationForConnecting:options:)은 새로운 씬 세션을 생성할 때 호출됩니다. 이 함수는 씬의 속성을 구성하는 데 도움이 되는 UISceneConfiguration 객체를 반환합니다. 여기서 UISceneConfiguration 객체를 생성하고 이 씬 세션의 구성을 처리할 SceneDelegate 클래스를 해당 UISceneConfiguration 객체로 할당합니다.\n\nSceneDelegate.swift\n\n```js\nimport SwiftUI\n\nclass SceneDelegate: NSObject, UIWindowSceneDelegate {\n\n    var window: UIWindow?\n\n    func scene(_ scene: UIScene, willConnectTo\n               session: UISceneSession, options\n               connectionOptions: UIScene.ConnectionOptions) {\n        guard let _ = scene as? UIWindowScene else {return}\n    }\n\n    func sceneDidBecomeActive(_ scene: UIScene) {\n\n    }\n\n    func sceneDidEnterBackground(_ scene: UIScene) {\n\n    }\n\n    func sceneWillEnterForeground(_ scene: UIScene) {\n\n    }\n\n    func sceneWillResignActive(_ scene: UIScene) {\n\n    }\n}\n```\n\nUIWindowSceneDelegate 프로토콜은 씬의 라이프사이클 이벤트에 응답하고 앱의 창 씬 동작을 관리할 수 있도록 해줍니다. 씬의 생성, 소멸, 상태 복원 및 씬 관련 이벤트를 처리하기 위한 구조화된 방법을 제공하여 견고하고 반응성 있는 iOS 애플리케이션을 만들 수 있습니다. 여기에 대한 설명:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n1. scene(\\_:willConnectTo:options:): 새 창 장면이 연결되기 전에 호출되는 메서드입니다. 일반적으로 장면의 초기 사용자 인터페이스를 설정하는 곳입니다.\n\n2. sceneDidBecomeActive(\\_:): 창 장면이 활성 상태가 되면 트리거됩니다. 이는 사용자 상호 작용을 위해 준비된 상태를 의미합니다. 여기서 애니메이션을 시작하거나 작업을 재개할 수 있습니다.\n\n3. sceneWillResignActive(\\_:): 창 장면이 활성 상태를 잃기 직전에 호출됩니다. 사용자가 전화를 받거나 다른 앱으로 전환할 때 발생할 수 있습니다.\n\n4. sceneDidEnterBackground(\\_:): 이 메서드는 창 장면이 백그라운드로 전환될 때 호출됩니다. 여기서 앱의 현재 상태를 저장하거나 진행 중인 작업을 일시 중지하는 데 사용할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n5. sceneWillEnterForeground(\\_:): 화면이 백그라운드에 있었다가 다시 활성화될 때 호출됩니다. 여기서 사용자가 돌아오면 사용자 인터페이스를 준비할 수 있습니다.\n\n이러한 메서드를 사용하면 앱의 창 화면이 수명주기 동안의 동작을 사용자 정의하여 부드럽고 반응적인 사용자 경험을 보장할 수 있습니다.\n\n지금 SwiftUI 앱 라이프사이클에 AppDelegate를 연결해보세요.\n\n```swift\nimport SwiftUI\n\n@main\nstruct SwiftUIDemoApp: App {\n\n    @UIApplicationDelegateAdaptor(AppDelegate.self) private var appdelegate\n\n    var body: some Scene {\n        WindowGroup {\n            ContentView()\n        }\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nSwiftUI 앱에서는 App 구조체에서 AppDelegate 인스턴스에 접근할 수 있습니다. 이때 사용하는 프로퍼티 래퍼는 UIKit 앱에서 UIWindowSceneDelegate와 유사한 방식으로 작동합니다. 그러나 여기서 사용해야 하는 프로퍼티 래퍼는 @UIApplicationDelegateAdaptor입니다.\n\n- @UIApplicationDelegateAdaptor(AppDelegate.self)은 AppDelegate 인스턴스에 액세스할 수 있는 프로퍼티 래퍼입니다.\n- private var appDelegate는 AppDelegate 인스턴스에 대한 참조를 보유하는 프로퍼티입니다.\n\n이 Github URL을 시도해보세요! 궁금한 점이 있으면 언제든지 물어보세요.\n\nNEXT: SwiftUI를 사용하여 변수를 정의하고 키워드를 입력하는 방법에 대해 공유할게요.\n","ogImage":{"url":"/assets/img/2024-05-20-UnderstandingAppDelegateSceneDelegateandSwiftUILifecycle_0.png"},"coverImage":"/assets/img/2024-05-20-UnderstandingAppDelegateSceneDelegateandSwiftUILifecycle_0.png","tag":["Tech"],"readingTime":13},{"title":"모바일 개발 아이디어부터 구현까지 DevInterface와 함께","description":"","date":"2024-05-20 16:20","slug":"2024-05-20-MobiledevelopmentfromideatoimplementationwithDevInterface","content":"\n![image](/assets/img/2024-05-20-MobiledevelopmentfromideatoimplementationwithDevInterface_0.png)\n\n애플리케이션에 대한 아이디어가 있고 다음 단계가 무엇인지 궁금한가요?\n\n옵션은 무한하며 매일 새롭고 흥미로운 스마트폰 애플리케이션이 시장에 출시됩니다. 영감은 분명히 부족하지 않습니다. 그러나 부족한 것은 구현입니다. 사용자 지정 앱을 만들고 싶다면 어디서부터 시작해야 할까요?\n\n저희 글은 여러분이 아이디어를 실제로 구현할 수 있도록 제안하는 길을 안내해 드립니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 개발 회사에 앞서 고려해야 할 사항...\n\n## 1) 내 앱이 이미 존재하는가?\n\nApp Store와 Google Play에는 수백만 개의 앱이 있습니다. 당신의 아이디어가 새로운 것일 가능성은 상대적으로 낮을 수 있습니다. 하지만 이로 인해 낙담해서는 안 됩니다. 귀하의 산업과 관련된 앱을 찾아서 테스트해보세요. 사용자 리뷰를 확인하고 귀하의 앱을 개선하는데 영감을 받으세요.\n\n## 2) 내 타겟 그룹은 무엇을 생각하나요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nIf your idea seems really new and innovative, ask yourself: why? and seek expert advice as well. Your topic may not be suitable for app development or may even not be allowed. Also, your target group of potential users might be very narrow. Speak to a representative of your potential user group and try to get honest feedback: does my app idea really solve (your) problem?\n\n### 3) What problem does my app solve?\n\nAn app idea has potential if it solves a problem. In times of oversupply, a user approaching your product may rightfully ask: “What do I get by installing this app?”. Your app idea must address a specific and concrete challenge that your target group has recognized. It is also important to consider whether the problem is temporary or permanent.\n\n### Approaching a development company like DevInterface\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n귀하의 앱 개발이 성공적으로 이루어지도록 하기 위해 DevInterface에서는 다음 단계를 적용합니다:\n\n## 1) 앱 프로젝트 평가 분석\n\n### 아이디어 평가\n\n이 단계에서는 함께 앱 아이디어를 평가합니다. 이는 앱이 해결해야 하는 문제 또는 필요성을 식별하는 것을 의미합니다 (이전에 이미 이를 설명한 바 있다면 더 좋습니다). 시장을 분석하여 수요와 경쟁력을 이해하고 대상 청중을 정의합니다. 또한 사용 가능한 자원, 필요한 기술 및 마감일에 대한 아이디어의 실행 가능성을 확인하려고 노력합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 기능\n\n아이디어와 관련된 다양한 측면을 평가한 후, 앱의 기능을 분석합니다. 기능 요구 사항을 식별하고 중요도에 따라 기능 우선 순위를 정하며, 앱을 풍부하게할 추가 기능을 정의하고 사용자 경험을 고려하여 사용자 인터페이스의 사용성 및 인체공학을 분석합니다.\n\n## 기술\n\n마지막으로, 프로젝트에 가장 적합한 개발 기술을 선택하여 첫 번째 부분을 마무리합니다. 이 과정에는 프로그래밍 언어, 프레임워크 및 데이터베이스의 선택뿐만 아니라 앱의 배포 플랫폼, 확장 가능성 및 성능 요구 사항, 사용자 데이터의 보호를 위한 보안 및 개인 정보 제약 사항을 고려하여 사용자 데이터의 보호를 보장합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 2) UX/UI 디자인\n\n## 사용자 연구 및 경쟁 분석\n\n저희에게 오는 고객 유형에 따라, UX/UI 디자인의 첫 단계로 사용자 연구를 실시하고 경쟁사를 분석하여 상황과 사용자 기대를 명확히 파악합니다.\n\n## 사용자 페르소나 및 시나리오 작성\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n수행한 연구를 통해 대상 사용자의 가상화된 표현인 사용자 페르소나를 만듭니다. 이를 통해 사용자의 요구 사항, 행동 및 목표를 더 잘 이해할 수 있습니다. 또한 응용 프로그램의 사용 사례 및 상호 작용 흐름을 설명하는 사용자 시나리오가 정의됩니다.\n\n## 정보 아키텍처 디자인\n\n정보 아키텍처를 통해 사용자 인터페이스의 구조와 조직을 정의합니다. 이는 사이트맵과 플로우차트를 작성하여 사용자가 응용 프로그램을 통해 탐색하는 것을 시각화하는 것을 포함합니다.\n\n## 와이어프레이밍 및 프로토타이핑\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저희는 사용자 인터페이스를 개략적이고 상호 작용적인 방식으로 표현하는 낮은 중, 중간 정도의 친밀도를 가진 와이어프레임과 프로토타입을 작성합니다. 이로써 디자인 솔루션을 평가하고 테스트할 수 있으며, 시각 디자인 및 개발 단계로 진행하기 전에 초기 단계에서 진행합니다.\n\n## 시각 디자인과 스타일\n\n와이어프레임과 프로토타입이 확정되면 시각 디자인 단계로 진행합니다. 애플리케이션의 룩 앤 필을 정의하고, 색상, 서체 및 그래픽 요소 선택합니다. 목표는 브랜드와 일관성 있고 사용자에게 매력적인 디자인을 만드는 것입니다.\n\n## 사용성 테스트\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n프로젝트를 개발 팀에 넘기기 전에 중요한 마지막 단계는 사용성 테스트를 실시하여 사용자 인터페이스의 효과성과 사용자 경험을 평가하고 피드백을 수집하여 애플리케이션이 출시되기 전에 해결해야 할 사용성 문제를 식별하는 것입니다.\n\n# 3) 개발\n\n## 아키텍처 정의\n\n개발 단계는 앱 아키텍처의 정의로 시작됩니다. 이는 애플리케이션의 주요 구성 요소인 프론트엔드와 백엔드의 설계 및 그들 간의 상호작용의 정의를 포함합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## API 및 백엔드 개발\n\n백엔드 서비스와 API를 개발하는 과정에서는 애플리케이션의 작업을 지원하기 위해 필요한 기능을 구현합니다. 데이터 관리, 사용자 인증, 외부 시스템과의 통합 등이 포함될 수 있습니다. 우리는 확장 가능하고 안전하며 성능이 우수한 백엔드 아키텍처를 제공하기 위해 노력합니다.\n\n## 앱 개발\n\n애플리케이션의 실제 개발 과정에서는 이전 단계에서 정의된 요구 사항과 기능을 코드로 번역합니다. 이는 사용자 인터페이스 개발, 비즈니스 로직 구현 및 백엔드 서비스와의 통합을 포함할 수 있습니다. 이 과정에서는 사용자 인터페이스 디자인 가이드라인을 준수하고 앱이 일관되고 사용자에게 직관적인지 확인합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 테스트\n\n개발 단계에서 마지막으로 중요한 단계는 테스트입니다. 이는 개별 코드 구성 요소를 확인하는 단위 테스트, 앱의 다른 모듈이 올바르게 상호 작용하는지 확인하는 통합 테스트, 그리고 앱이 최종 사용자의 기대를 충족시키는지 확인하는 사용자 수용 테스트가 포함될 수 있습니다.\n\n# 4) 릴리스 및 유지 보수\n\n## 앱 릴리스\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n개발 단계가 완료되고 품질 테스트를 통과한 후에는 응용 프로그램이 대상 플랫폼으로 배포됩니다. 이는 앱 스토어(예: Apple App Store, Google Play Store for Android) 또는 대상 대상자에 따라 다른 배포 플랫폼에 포함될 수 있습니다.\n\n## 성능 모니터링\n\n앱이 출시된 후에는 성능을 주의 깊게 모니터링하는 것이 중요합니다. 예를 들어 서버의 안정성과 성능에 대한 것이 포함될 수 있습니다.\n\n## 업데이트 및 유지보수\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n애플리케이션의 수명 주기 동안은 업데이트와 버그 수정이 필요할 수 있습니다. 이러한 업데이트는 앱의 기능을 향상시키고 사용자가 마주친 문제를 해결하며 새로운 운영 체제 및 기기 버전과의 호환성을 보장하기 위해 주기적으로 출시될 수 있습니다.\n\n# 당신만의 앱을 만들어 보고 싶으신가요?\n\n이 글에서 읽으신 내용을 이미 CXOs, 마케팅 매니저, 제품 소유자, 그리고 디지털 매니저들이 우리에게 신뢰하여 자신의 앱을 만들어달라고 부탁한 다양한 프로젝트에 적용했습니다. 당신이 성공적인 앱을 개발하기 위한 방법, 도구, 프로세스, 그리고 팀을 만들어야 할 필요 없이 바로 시작하고자 한다면, 전략, 컨셉, 실행, 혹은 마케팅 단계에 있든 상관없이, 저희는 대부분의 작업을 기꺼이 맡아 처리하고 협력의 정신으로 전체 과정을 안내해 드릴 것입니다.\n\n따라서 당신은 핵심 활동에 집중하고 프로젝트를 착수할 수 있으며, 우리는 전략 및 개념의 전반적인 안내와 함께 원하신다면 전문 팀으로 직접 앱을 개발할 수 있는 점에 대해 안내해 드리겠습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저희는 무료 상담을 제공합니다. 프로젝트 계획을 함께 세우고, 초기 전략부터 최종 릴리스까지 프로젝트가 성공적으로 진행되도록 안내해 드립니다.\n\n지금 바로 무료 상담 신청하세요.\n\n원문 게시 위치: https://www.devinterface.com.\n","ogImage":{"url":"/assets/img/2024-05-20-MobiledevelopmentfromideatoimplementationwithDevInterface_0.png"},"coverImage":"/assets/img/2024-05-20-MobiledevelopmentfromideatoimplementationwithDevInterface_0.png","tag":["Tech"],"readingTime":8}],"page":"92","totalPageCount":120,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":4},"__N_SSG":true}