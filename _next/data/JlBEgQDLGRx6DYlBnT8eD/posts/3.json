{"pageProps":{"posts":[{"title":"Angular 17의 컴포넌트 스타일 정리 방법","description":"","date":"2024-07-01 16:20","slug":"2024-07-01-MythicalAngularComponentstylescleanupinAngular17","content":"\n\n안녕하세요!\n\n최신 릴리스 노트에 언급되지 않은 흥미로운 동작을 발견했습니다. 이 기사에서는 이것이 무엇인지 보여드리고, 왜 그것이 꽤 흥미로운 변화라고 생각하는지 알려드리겠습니다.\n\n# 스타일 정리 문제\n\nAngular가 동적으로 생성된 구성 요소를 제거한 후에도 스타일을 제거하지 않는 문제를 발견했습니다. 즉, 동적 구성 요소를 생성하면 (심지어 DOM에 연결할 필요도 없이), Angular가 스타일을 추가한 후 구성 요소가 제거될 때 스타일을 제거하지 않는다는 것이죠.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n검사하고 테스트하는 것은 매우 쉽습니다.\n\n# 테스트\n\n항상 모든 코드는 내 GitHub에서 제공됩니다. experiment-styles-cleanup 저장소를 찾아보세요.\n\n저는 응용 프로그램에 스타일을 추가하는 것 외에 아무 것도 하지 않는 간단한 구성 요소로 테스트를 시작합니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\r\nimport {Component, ViewEncapsulation} from '@angular/core';\n\n@Component({\n  selector: 'app-dynamic',\n  template: '',\n  encapsulation: ViewEncapsulation.None,\n  styles: [`\n    .test {\n      background: red;\n      color: white;\n      border: 4px dashed black;\n      font-weight: bold;\n    }\n  `]\n})\nexport class DynamicComponent {\n}\r\n```\n\n여기서 볼 수 있듯이, 꽤 간단합니다. 템플릿도 로직도 없고, 스타일만 있습니다. 중요한 점은 ViewEncapsulation.None으로 캡슐화를 설정했기 때문에 이 스타일을 컴포넌트 외부에 적용할 수 있다는 것입니다.\n\n다음으로, 루트 AppComponent를 수정해보겠습니다.\n\n```js\r\nimport {Component, ComponentFactoryResolver, inject, Injector, OnDestroy} from '@angular/core';\nimport {DynamicComponent} from \"./dynamic.component\";\n\n@Component({\n  selector: 'app-root',\n  template: `\n    <div class=\"test\">\n      이 상자가 빨간색일 때 스타일이 적용됩니다\n    </div>\n\n    <button (click)=\"createComponent()\">눌러보세요!</button>\n  `\n})\nexport class AppComponent {\n  private readonly componentFactoryResolver = inject(ComponentFactoryResolver);\n  private readonly injector = inject(Injector);\n\n  createComponent(): void {\n    const factory = this.componentFactoryResolver.resolveComponentFactory(DynamicComponent);\n    const componentRef = factory.create(this.injector);\n\n    setTimeout(() => componentRef.destroy(), 5000);\n  }\n}\r\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nAppComponent에서 두 가지가 있습니다.\n\n첫 번째는 test 클래스가 있는 div입니다. Angular이 DynamicComponent에서 스타일을 추가할 때 스타일이 적용됩니다. 그래서 캡슐화를 ViewEncapsulation.None으로 설정했습니다.\n\n두 번째로는 버튼이 있습니다. 클릭하면 ComponentFactoryResolver를 사용하여 동적으로 DynamicComponent를 생성한 후 5초 후에 제거합니다. setTimeout에 메모리 누수가 있음을 알고 있지만 이것은 테스트일 뿐이니 괜찮아요?\n\n전체 테스트는 간단합니다. 버튼을 클릭하면 div에 스타일이 적용되어야 합니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![한국어](/assets/img/2024-07-01-MythicalAngularComponentstylescleanupinAngular17_0.png)\n\n5초간 기다리고, 두 가지 가능한 종료가 있습니다:\n\n- div에 스타일이 있는 경우 - 해당 컴포넌트의 스타일이 제거되지 않았음을 의미합니다\n- div에 스타일이 없는 경우 - Angular가 컴포넌트 제거 후 정리를 수행 중임을 의미합니다\n\n# Angular 15 & 16\n\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아마도 예상했겠지만, Angular 15와 16에서는 컴포넌트와 함께 스타일이 제거되지 않습니다. experiment-styles-cleanup 저장소의 코드를 사용하여 직접 해볼 수 있어요. 주요 브랜치와 v16 브랜치를 사용해 보세요.\n\n![이미지](/assets/img/2024-07-01-MythicalAngularComponentstylescleanupinAngular17_1.png)\n\n참고: 시간이 부족하다면 권장합니다. GitHub Pages를 통해 배포한 코드를 확인할 수 있어요. 다음은 링크입니다:\n\n- [v15 링크](galczo5.github.io/experiment-styles-cleanup/v15)\n- [v16 링크](galczo5.github.io/experiment-styles-cleanup/v16)\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 앵귤러 17\n\n앵귤러 17로 업그레이드한 후에 동작이 변경되었습니다. 이제 스타일은 컴포넌트와 함께 제거됩니다.\n\n내 저장소의 v17 브랜치를 확인하거나 galczo5.github.io/experiment-styles-cleanup/v17 애플리케이션을 사용해보세요.\n\n![이미지](/assets/img/2024-07-01-MythicalAngularComponentstylescleanupinAngular17_2.png)\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# Non-dynamic 컴포넌트와의 작업 방식은 어떤가요?\n\n가끔 이러한 경우는 특이한 경우라고 생각할 수 있고, 우리가 많은 동적 컴포넌트를 만들지 않기 때문에 중요하지 않을 수도 있어요.\n\n일반 ngIf 문장으로 어떻게 작동하는지 확인해봅시다.\n\n이를 확인하려면 AppComponent의 코드에 필요한 변경 사항을 적용해야 했어요.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```javascript\nimport {Component, ComponentFactoryResolver, inject, Injector, OnDestroy} from '@angular/core';\nimport {DynamicComponent} from \"./dynamic.component\";\n\n@Component({\n  selector: 'app-root',\n  template: `\n    <div class=\"test\">\n      이 상자가 빨간색이 될 때 적용되는 스타일\n    </div>\n\n    <app-dynamic *ngIf=\"visible\"/>\n\n    <button (click)=\"createComponent()\">클릭!</button>\n  `\n})\nexport class AppComponent {\n  visible = false;\n\n  createComponent(): void {\n    this.visible = true;\n    setTimeout(() => this.visible = false, 5000);\n  }\n}\n```\n\n결과는 예상대로입니다.\n\nAngular 15 및 16 — 스타일이 제거되지 않음\n\n- 브랜치 v15-ngIf 및 galczo5.github.io/experiment-styles-cleanup/v15-ngIf/\n- 브랜치 v16-ngIf 및 galczo5.github.io/experiment-styles-cleanup/v16-ngIf/ \n\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n안녕하세요! 다음과 같이 테이블 태그를 마크다운 형식으로 변경해주세요.\n\n\nAngular 17 — 컴포넌트가 파괴된 후에 스타일이 제거됩니다\n\n- Branch 17-ngIf 및 galczo5.github.io/experiment-styles-cleanup/v17-ngIf/\n\n그래서, 동적으로 생성된 컴포넌트와 정확히 똑같이 동작합니다. 추가로 제거되지 않은 스타일이 브라우저에 얼마나 무겁게 작용하는지는 확신할 수 없지만, 스타일이 적을수록 처리하기 쉬울 것으로 예상됩니다. 아마 다음에는 측정해 볼 것입니다.\n\n# 캡슐화된 스타일에 대해 어떤가요?\n\n\n도움이 되었기를 바랍니다. 추가 설명이 필요하시면 언제든지 물어보세요.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n내 모든 테스트에서는 ViewEncapsulation.None을 사용하여 어떻게 작동하는지 시각적으로 보여주었어. 기본으로 에뮬레이션된 캡슐화로 작동하는 지 확인하기 위해 컴포넌트 제거 후 DOM을 확인하기 위해 개발 도구를 사용했어. 문서의 `head` 부분에서 무슨 일이 일어나고 있는지 관찰해봐.\n\n나에게 결과는 다음과 같았어:\n\n- Angular 15 & 16 — 스타일이 제거되지 않아\n- Angular 17 — 스타일이 제거되어\n\n기본 캡슐화에서도 동일하게 작동해.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 요약\n\n솔직히 말해서, 컴포넌트를 파괴할 때 Angular가 기본적으로 스타일을 제거하지 않는다는 사실을 깨달을 때 약간 놀랐습니다. 몇 달 전에 물었더라면 Angular가 스타일을 제거한다고 베팅했을 것입니다.\n\n제 생각으로는 Angular 17에서 도입된 변경 사항이 모든 개발자에게 더 직관적일 것으로 확신합니다.\n\n요약하면, 제 테스트에 따르면 Angular 17 이전에 동적 컴포넌트든 ngIf를 사용하여 조건적으로 추가된 컴포넌트든 모든 컴포넌트가 파괴된 후에 추가된 모든 스타일이 제거되지 않았습니다. Angular 17은 이 동작을 변경하여 이제 컴포넌트 이후 불필요한 스타일이 정리됩니다.","ogImage":{"url":"/assets/img/2024-07-01-MythicalAngularComponentstylescleanupinAngular17_0.png"},"coverImage":"/assets/img/2024-07-01-MythicalAngularComponentstylescleanupinAngular17_0.png","tag":["Tech"],"readingTime":8},{"title":"불가능한 모퉁이 현실로 구현할 수 없는 건축 디자인 아이디어들","description":"","date":"2024-07-01 16:19","slug":"2024-07-01-UnreachableCorner","content":"\n\n\n![이미지](/assets/img/2024-07-01-UnreachableCorner_0.png)\n\n어느 날 아침, 그 코너의 수업실로 걸어가지 않게 되었어요.\n\n아마도 만다의 인스탁스 카메라는 또 다른 사람의 얼굴과 독특한 포즈를 찍고 있을 거에요.\n\n그리고 저는 Ed Sheeran의 \"Castle On The Hill\"을 들으며 눈을 크게 떴어요.\n\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n해당 복도 끝은 더 이상 평소와 같이 시끄럽지 않을 거에요. 급식소를 따라 외래 이름들이 더 이상 우리가 방문했을 때와 같지 않을 지도 몰라요. 인도미 토리 카라를 맛보면서 대기 목록에 있는 공포 영화들을 기다리는 것도 다를 거에요.\n\n마침내 그 책상들은 Le Minerale 병들로부터 깔끔해졌는데, 누가 소유주인지 잊고 버린 것이 안 보이더군요.\n\nOontz Manda 스피커는 더 이상 \"Take A Chance With Me\" 노래를 함께 노래할 수 없게 재생하지 않을 거에요.\n\nHiroko의 아이패드 게임을 더 많이 할지도 모르고, 누가 자주 빌릴지 줄어들지도 모르겠지요. 우리는 아니겠죠?\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n알야가 우리 테이블을 더 이상 방문하지 않고 교과서를 고의로 떠났기 때문에 그녀가 투정을 해도 하지 않습니다.\n\n그런 다음 누구에게 톰을 펼치면 안 될까요? 당연히 네이샤에게인데, 그녀만이 톰을 울릴 수 있거든요.\n\n모든 것은 각자의 길을 가고 있어요. 아마 이 글만큼 시끄럽지 않을 거예요. 이렇게 과장되지 않을 거예요.\n\n오. 그 모든 것은 이미 운명에 따르는 거예요. 그렇게 하는 게 최선이죠. 그리고 다시 만나면 각자의 최고 버전으로 만나요. 평소처럼 줄 서서 사진을 찍고 각자의 알마마터 재킷을 입고 머리를 숙여 포즈를 취하죠.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n희망하는 바로, 당신들의 라면에 들어간 계란은 항상 반숙하길 바래, 사랑하는 사람들아!","ogImage":{"url":"/assets/img/2024-07-01-UnreachableCorner_0.png"},"coverImage":"/assets/img/2024-07-01-UnreachableCorner_0.png","tag":["Tech"],"readingTime":2},{"title":"React JS, NET Core, Docker를 사용해 제품 애플리케이션 구축 및 컨테이너화하는 방법","description":"","date":"2024-07-01 16:17","slug":"2024-07-01-BuildandContainerizeProductApplicationusingReactJSNETCoreandDocker","content":"\n\n\n![이미지](/assets/img/2024-07-01-BuildandContainerizeProductApplicationusingReactJSNETCoreandDocker_0.png)\n\n# 소개\n\n본 글에서는 .NET Core Web API를 사용하여 샘플 제품 애플리케이션의 백엔드를 만들고 React JS를 사용하여 웹 폼을 생성하는 방법을 살펴볼 것입니다. 또한 도커를 활용해 동일한 애플리케이션을 컨테이너화할 것입니다.\n\n# 안내\n\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 샘플 제품 애플리케이션: 백엔드 (.NET Core Web API)\r\n- 샘플 제품 애플리케이션: 프론트엔드 (React JS)\r\n- 애플리케이션을 위한 Docker 파일\r\n- 애플리케이션을 컨테이너화하기\r\n\r\n## 필수 사항\r\n\r\n- Visual Studio 2022\r\n- Docker Desktop\r\n- NPM\r\n- .NET Core SDK\r\n- React JS\r\n\r\n# 샘플 제품 애플리케이션: 백엔드 (.NET Core Web API)\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n1. 새로운 제품 관리 .NET Core 웹 API를 생성해주세요.\n\n2. 데이터베이스 마이그레이션 및 SQL Server와의 연결을 위해 사용한 다음 NuGet 패키지를 설치해주세요.\n\n[이미지](/assets/img/2024-07-01-BuildandContainerizeProductApplicationusingReactJSNETCoreandDocker_1.png)\n\n3. 엔티티 폴더 안에 제품 클래스를 추가해주세요.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n```js\nnamespace ProductManagementAPI.Entities\n{\n    public class Product\n    {\n        public int Id { get; set; }\n        public string Name { get; set; }\n        public decimal Price { get; set; }\n    }\n}\n```\n\nStep 4. Create an AppDbContext class inside the data folder with a SQL Server connection and a DB set property.\n\n```js\nusing Microsoft.EntityFrameworkCore;\nusing ProductManagementAPI.Entities;\n\nnamespace ProductManagementAPI.Data\n{\n    public class AppDbContext : DbContext\n    {\n        public DbSet<Product> Products { get; set; }\n\n        protected readonly IConfiguration Configuration;\n\n        public AppDbContext(IConfiguration configuration)\n        {\n            Configuration = configuration;\n        }\n        protected override void OnConfiguring(DbContextOptionsBuilder options)\n        {\n            options.UseSqlServer(Configuration.GetConnectionString(\"DefaultConnection\"));\n            options.UseQueryTrackingBehavior(QueryTrackingBehavior.NoTracking);\n        }\n    }\n}\n```\n\nStep 5. Add a product repository inside the repositories folder.\n\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nIProductRepository\n\n```js\nusing ProductManagementAPI.Entities;\n\nnamespace ProductManagementAPI.Repositories\n{\n    public interface IProductRepository\n    {\n        void AddProduct(Product product);\n        void DeleteProduct(int id);\n        List<Product> GetAllProducts();\n        Product GetProductById(int id);\n        void UpdateProduct(Product product);\n    }\n}\n```\n\nProductRepository\n\n```js\nusing Microsoft.EntityFrameworkCore;\nusing ProductManagementAPI.Data;\nusing ProductManagementAPI.Entities;\n\nnamespace ProductManagementAPI.Repositories\n{\n    public class ProductRepository : IProductRepository\n    {\n        private readonly AppDbContext _context;\n\n        public ProductRepository(AppDbContext context)\n        {\n            _context = context;\n        }\n\n        public List<Product> GetAllProducts()\n        {\n            return _context.Products.ToList();\n        }\n\n        public Product GetProductById(int id)\n        {\n            return _context.Products.FirstOrDefault(p => p.Id == id);\n        }\n\n        public void AddProduct(Product product)\n        {\n            if (product == null)\n            {\n                throw new ArgumentNullException(nameof(product));\n            }\n\n            _context.Products.Add(product);\n            _context.SaveChanges();\n        }\n\n        public void UpdateProduct(Product product)\n        {\n            if (product == null)\n            {\n                throw new ArgumentNullException(nameof(product));\n            }\n\n            _context.Entry(product).State = EntityState.Modified;\n            _context.SaveChanges();\n        }\n\n        public void DeleteProduct(int id)\n        {\n            var product = _context.Products.Find(id);\n            if (product == null)\n            {\n                throw new ArgumentNullException(nameof(product));\n            }\n\n            _context.Products.Remove(product);\n            _context.SaveChanges();\n        }\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n6단계. 다양한 작업을 수행하는 데 사용되는 다른 액션 메서드를 사용하여 새 제품 컨트롤러를 생성합니다. 이후 같은 것을 호출하는 프런트엔드 애플리케이션을 사용하여 여러 작업을 수행합니다.\n\n```js\nusing Microsoft.AspNetCore.Http;\nusing Microsoft.AspNetCore.Mvc;\nusing ProductManagementAPI.Entities;\nusing ProductManagementAPI.Repositories;\n\nnamespace ProductManagementAPI.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class ProductController : ControllerBase\n    {\n        private readonly IProductRepository _productRepository;\n\n        public ProductController(IProductRepository productRepository)\n        {\n            _productRepository = productRepository;\n        }\n\n        [HttpGet]\n        public IActionResult GetAllProducts()\n        {\n            var products = _productRepository.GetAllProducts();\n            return Ok(products);\n        }\n\n        [HttpGet(\"{id}\")]\n        public IActionResult GetProductById(int id)\n        {\n            var product = _productRepository.GetProductById(id);\n            if (product == null)\n            {\n                return NotFound();\n            }\n            return Ok(product);\n        }\n\n        [HttpPost]\n        public IActionResult AddProduct([FromBody] Product product)\n        {\n            if (product == null)\n            {\n                return BadRequest();\n            }\n\n            _productRepository.AddProduct(product);\n            return CreatedAtAction(nameof(GetProductById), new { id = product.Id }, product);\n        }\n\n        [HttpPut(\"{id}\")]\n        public IActionResult UpdateProduct(int id, [FromBody] Product product)\n        {\n            if (product == null || id != product.Id)\n            {\n                return BadRequest();\n            }\n\n            var existingProduct = _productRepository.GetProductById(id);\n            if (existingProduct == null)\n            {\n                return NotFound();\n            }\n\n            _productRepository.UpdateProduct(product);\n            return NoContent();\n        }\n\n        [HttpDelete(\"{id}\")]\n        public IActionResult DeleteProduct(int id)\n        {\n            var existingProduct = _productRepository.GetProductById(id);\n            if (existingProduct == null)\n            {\n                return NotFound();\n            }\n\n            _productRepository.DeleteProduct(id);\n            return NoContent();\n        }\n    }\n}\n```\n\n7단계. 앱 설정 파일을 열고 데이터베이스 연결 문자열을 추가합니다.\n\n```js\n{\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Information\",\n      \"Microsoft.AspNetCore\": \"Warning\"\n    }\n  },\n  \"AllowedHosts\": \"*\",\n  \"ConnectionStrings\": {\n    \"DefaultConnection\": \"Data Source=DESKTOP-8RL8JOG;Initial Catalog=ReactNetCoreCrudDb;User Id=sa;Password=database@1;\"\n  }\n}\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n**단계 8.** 서비스 컨테이너 내에서 서비스를 등록하고 미들웨어를 구성하세요.\n\n```js\nusing ProductManagementAPI.Data;\nusing ProductManagementAPI.Repositories;\n\nvar builder = WebApplication.CreateBuilder(args);\n\n// 컨테이너에 서비스 추가.\nbuilder.Services.AddScoped<IProductRepository, ProductRepository>();\nbuilder.Services.AddDbContext<AppDbContext>();\nbuilder.Services.AddCors(options => {\n    options.AddPolicy(\"CORSPolicy\", builder => builder.AllowAnyOrigin().AllowAnyMethod().AllowAnyHeader());\n});\n\n\nbuilder.Services.AddControllers();\n// Swagger/OpenAPI를 구성하는 방법에 대해 자세히 알아보려면 https://aka.ms/aspnetcore/swashbuckle을 방문하십시오.\nbuilder.Services.AddEndpointsApiExplorer();\nbuilder.Services.AddSwaggerGen();\n\nvar app = builder.Build();\n\n// HTTP 요청 파이프라인을 구성하세요.\napp.UseCors(\"CORSPolicy\");\n\nif (app.Environment.IsDevelopment())\n{\n    app.UseSwagger();\n    app.UseSwaggerUI();\n}\n\napp.UseHttpsRedirection();\n\napp.UseAuthorization();\n\napp.MapControllers();\n\napp.Run();\n```\n\n**단계 9.** 다음 엔티티 프레임워크 데이터베이스 마이그레이션 명령을 실행하여 데이터베이스 및 테이블을 생성하세요.\n\n```js\nadd-migration “v1”\n\nupdate-database\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n10단계. 마지막으로 애플리케이션을 실행하고 Swagger UI를 사용하여 다양한 API 엔드포인트를 실행합니다.\n\n![image](/assets/img/2024-07-01-BuildandContainerizeProductApplicationusingReactJSNETCoreandDocker_2.png)\n\n# 샘플 제품 애플리케이션: 프론트엔드 (React JS)\n\nReact JS를 사용하여 클라이언트 애플리케이션을 만들고 위의 API 엔드포인트를 사용하여 소비합시다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n**단계 1.** 다음 명령을 사용하여 새로운 React JS 애플리케이션을 생성하세요:\n\n```js\nnpx create-react-app react-netcore-crud-app\n```\n\n**단계 2.** 프로젝트 디렉토리로 이동하세요:\n\n```js\ncd react-netcore-crud-app\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n단계 3. 백엔드 API를 소비하고 호출하기 위해 Axios를 설치하고 설계 목적으로 부트스트랩을 설치하세요.\n\n```js\nnpm install axios\n```\n\n```js\nnpm install bootstrap\n```\n\n단계 4. 다음 컴포넌트 및 서비스를 추가하세요.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n제품 목록 컴포넌트입니다.\n\n```js\n// src/components/ProductList/ProductList.js\nimport React, { useState, useEffect } from 'react';\nimport ProductListItem from './ProductListItem';\nimport productService from '../../services/productService';\n\nconst ProductList = () => {\n    const [products, setProducts] = useState([]);\n\n    useEffect(() => {\n        fetchProducts();\n    }, []);\n\n    const fetchProducts = async () => {\n        try {\n            const productsData = await productService.getAllProducts();\n            setProducts(productsData);\n        } catch (error) {\n            console.error('제품을 불러오는 중 오류가 발생했습니다:', error);\n        }\n    };\n\n    const handleDelete = async (id) => {\n        try {\n            await productService.deleteProduct(id);\n            fetchProducts(); // 제품 목록 새로고침\n        } catch (error) {\n            console.error('제품 삭제 중 오류가 발생했습니다:', error);\n        }\n    };\n\n    const handleEdit = () => {\n        fetchProducts(); // 편집 후 제품 목록 새로고침\n    };\n\n    return (\n        <div className=\"container\">\n            <h2 className=\"my-4\">제품 목록</h2>\n            <ul className=\"list-group\">\n                {products.map(product => (\n                    <ProductListItem key={product.id} product={product} onDelete={() => handleDelete(product.id)} onEdit={handleEdit} />\n                ))}\n            </ul>\n        </div>\n    );\n};\n\nexport default ProductList;\n```\n\n제품 목록 아이템 컴포넌트입니다.\n\n```js\n// src/components/ProductList/ProductListItem.js\nimport React, { useState } from 'react';\nimport productService from '../../services/productService';\n\nconst ProductListItem = ({ product, onDelete, onEdit }) => {\n    const [isEditing, setIsEditing] = useState(false);\n    const [editedName, setEditedName] = useState(product.name);\n    const [editedPrice, setEditedPrice] = useState(product.price);\n\n    const handleEdit = async () => {\n        setIsEditing(true);\n    };\n\n    const handleSave = async () => {\n        const editedProduct = { ...product, name: editedName, price: parseFloat(editedPrice) };\n        try {\n            await productService.updateProduct(product.id, editedProduct);\n            setIsEditing(false);\n            onEdit(); // 제품 목록 새로고침\n        } catch (error) {\n            console.error('제품 업데이트 중 오류가 발생했습니다:', error);\n        }\n    };\n\n    const handleCancel = () => {\n        setIsEditing(false);\n        // 수정된 값 초기화\n        setEditedName(product.name);\n        setEditedPrice(product.price);\n    };\n\n    return (\n        <li className=\"list-group-item\">\n            {isEditing ? (\n                <div className=\"row\">\n                    <div className=\"col\">\n                        <input type=\"text\" className=\"form-control\" value={editedName} onChange={e => setEditedName(e.target.value)} required />\n                    </div>\n                    <div className=\"col\">\n                        <input type=\"number\" className=\"form-control\" value={editedPrice} onChange={e => setEditedPrice(e.target.value)} required />\n                    </div>\n                    <div className=\"col-auto\">\n                        <button className=\"btn btn-success me-2\" onClick={handleSave}>저장</button>\n                        <button className=\"btn btn-secondary\" onClick={handleCancel}>취소</button>\n                    </div>\n                </div>\n            ) : (\n                <div className=\"d-flex justify-content-between align-items-center\">\n                    <span>{product.name} - ${product.price}</span>\n                    <div>\n                        <button className=\"btn btn-danger me-2\" onClick={onDelete}>삭제</button>\n                        <button className=\"btn btn-primary\" onClick={handleEdit}>편집</button>\n                    </div>\n                </div>\n            )}\n        </li>\n    );\n};\n\nexport default ProductListItem;\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n제품 서비스.\n\n```js\n// src/services/productService.js\nimport axios from 'axios';\n\nconst baseURL = 'https://localhost:7202/api/Product';\n\nconst productService = {\n    getAllProducts: async () => {\n        const response = await axios.get(baseURL);\n        return response.data;\n    },\n    addProduct: async (product) => {\n        const response = await axios.post(baseURL, product);\n        return response.data;\n    },\n    deleteProduct: async (id) => {\n        const response = await axios.delete(`${baseURL}/${id}`);\n        return response.data;\n    },\n    updateProduct: async (id, product) => {\n        const response = await axios.put(`${baseURL}/${id}`, product);\n        return response.data;\n    }\n};\n\nexport default productService;\n```\n\n앱 컴포넌트.\n\n```js\n// src/App.js\nimport React, { useState } from 'react';\nimport ProductList from './components/ProductList/ProductList';\nimport ProductForm from './components/ProductForm/ProductForm';\n\nfunction App() {\n    const [refresh, setRefresh] = useState(false);\n\n    const handleProductAdded = () => {\n        setRefresh(!refresh); // 다시 렌더링을 트리거 할 수 있도록 새로 고침 상태를 토글\n    };\n\n    return (\n        <div>\n            <ProductList key={refresh} />\n            <ProductForm onProductAdded={handleProductAdded} />\n        </div>\n    );\n}\n\nexport default App;\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음 명령을 사용하여 애플리케이션을 실행하고 동일한 도움으로 다양한 CRUD 작업을 수행하세요.\n\n![애플리케이션 실행](/assets/img/2024-07-01-BuildandContainerizeProductApplicationusingReactJSNETCoreandDocker_3.png)\n\n# 애플리케이션을 위한 Docker 파일\n\n- 백앤드 애플리케이션을 위한 Docker 파일 (.NET Core)\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n# 공식 .NET Core SDK를 부모 이미지로 사용합니다.\nFROM mcr.microsoft.com/dotnet/sdk:6.0 AS build\n\nWORKDIR /app\n\n# 프로젝트 파일을 복사하고 종속성을 복원합니다 (프로젝트 이름에 .csproj를 사용합니다).\nCOPY *.csproj ./\n\nRUN dotnet restore\n\n# 나머지 응용 프로그램 코드를 복사합니다.\nCOPY . .\n\n# 응용 프로그램을 게시합니다.\nRUN dotnet publish -c Release -o out\n\n# 런타임 이미지를 빌드합니다.\nFROM mcr.microsoft.com/dotnet/aspnet:6.0 AS runtime\n\nWORKDIR /app\nCOPY --from=build /app/out ./\n\n# 응용 프로그램이 실행될 포트를 노출합니다.\nEXPOSE 80\n\n# 응용 프로그램을 시작합니다.\nENTRYPOINT [\"dotnet\", \"ProductManagementAPI.dll\"]\n```\n\n- 1–2번 라인: 공식 .NET Core SDK 이미지 (mcr.microsoft.com/dotnet/sdk:6.0)를 기본 이미지로 사용합니다.\n- 4번 라인: 작업 디렉터리를 /app으로 설정합니다.\n- 6–7번 라인: 프로젝트 파일(*.csproj)을 컨테이너로 복사합니다.\n- 9번 라인: dotnet restore를 실행하여 프로젝트 파일에서 지정된 종속성을 복원합니다.\n- 11–12번 라인: 나머지 응용 프로그램 코드를 컨테이너로 복사합니다.\n- 14–15번 라인: 응용 프로그램을 릴리스 구성으로 게시합니다 (dotnet publish -c Release -o out) out 디렉터리로 출력합니다.\n- 17–18번 라인: 공식 .NET Core ASP.NET 런타임 이미지 (mcr.microsoft.com/dotnet/aspnet:6.0)를 기본 이미지로 사용합니다.\n- 20–21번 라인: 작업 디렉터리를 /app으로 설정하고 빌드 단계의 게시된 출력(from /app/out)을 런타임 단계의 /app 디렉터리로 복사합니다.\n- 23–24번 라인: 외부에서 응용 프로그램에 액세스할 수 있도록 포트 80을 노출합니다.\n- 26–27번 라인: 응용 프로그램을 시작하는 엔트리 포인트 명령어로 dotnet ProductManagementAPI.dll을 지정합니다.\n\n2. 프론트엔드 애플리케이션 (React JS)을 위한 Docker 파일\n\n```js\n# 공식 Node.js 기본 이미지 사용\nFROM node:18\n\n# 작업 디렉터리 설정\nWORKDIR /app\n\n# package.json 및 package-lock.json 파일 복사\nCOPY package*.json ./\n\n# 종속성 설치\nRUN npm install\n\n# 나머지 애플리케이션 코드 복사\nCOPY . .\n\n# React 앱 빌드\nARG REACT_APP_API_URL\nENV REACT_APP_API_URL=$REACT_APP_API_URL\nRUN npm run build\n\n# serve를 전역적으로 설치하여 빌드 폴더를 제공합니다\nRUN npm install -g serve\n\n# 앱이 실행되는 포트 노출\nEXPOSE 3000\n\n# React 앱 시작\nCMD [\"serve\", \"-s\", \"build\"]\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 1–2번째 줄: Node.js 버전 18을 사용하는 기본 이미지를 지정합니다.\n- 4–5번째 줄: 이후 명령에 대한 작업 디렉토리로 /app를 설정합니다.\n- 7–8번째 줄: package.json 및 package-lock.json을 로컬 머신에서 Docker 이미지로 복사합니다.\n- 10–11번째 줄: package.json에 나열된 모든 종속성을 설치하기 위해 npm install을 실행합니다.\n- 13–14번째 줄: 나머지 애플리케이션 코드를 Docker 이미지로 복사합니다.\n- 16–19번째 줄: ARG 명령은 빌드 시간 변수 REACT_APP_API_URL을 정의합니다. ENV 명령은 빌드 시간 변수의 값인 REACT_APP_API_URL 환경 변수를 설정합니다. 또한 RUN npm run build는 React 애플리케이션을 빌드합니다.\n- 21–22번째 줄: serve 패키지를 전역으로 설치하여 빌드된 React 애플리케이션을 제공합니다.\n- 24–25번째 줄: 애플리케이션이 실행될 포트인 3000을 노출합니다.\n- 27–28번째 줄: 명령은 serve를 사용하여 빌드 폴더를 제공함으로써 React 애플리케이션을 시작합니다.\n\n프런트엔드 애플리케이션에 대해 React 프로젝트 루트에 .env 파일을 생성합니다. 이 파일에는 환경 변수가 포함되어 있으며, Docker 이미지를 실행하거나 백엔드 API URL을 전달하는 데 사용할 수 있습니다.\n\n```js\nREACT_APP_API_URL=http://your-backend-url.com\n```\n\n다음으로, 제품 서비스에서 백엔드 하드코딩된 URL을 수정하십시오.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n// src/services/productService.js\nimport axios from 'axios';\n\nconst baseURL = process.env.REACT_APP_API_URL;\n\nconst productService = {\n    getAllProducts: async () => {\n        const response = await axios.get(baseURL);\n        return response.data;\n    },\n    addProduct: async (product) => {\n        const response = await axios.post(baseURL, product);\n        return response.data;\n    },\n    deleteProduct: async (id) => {\n        const response = await axios.delete(`${baseURL}/${id}`);\n        return response.data;\n    },\n    updateProduct: async (id, product) => {\n        const response = await axios.put(`${baseURL}/${id}`, product);\n        return response.data;\n    }\n};\n\nexport default productService;\n```\n\n## 프론트엔드 및 백엔드 어플리케이션을 컨테이너화하기\n\n단계 1.\n\n도커 이미지 빌드하기\n\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n도커 빌드 명령어를 사용하여 productbackendapp:latest 이미지를 빌드하세요.\n```\n\n![이미지](/assets/img/2024-07-01-BuildandContainerizeProductApplicationusingReactJSNETCoreandDocker_4.png)\n\n```js\n도커 빌드 명령어를 사용하여 REACT_APP_API_URL이 http://localhost:8085/api/Product인 productfrontendapp 이미지를 빌드하세요.\n```\n\n![이미지](/assets/img/2024-07-01-BuildandContainerizeProductApplicationusingReactJSNETCoreandDocker_5.png)\n\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nStep 2.\n\n필요한 매개변수를 전달한 후 이미지를 실행합니다. 필요한 매개변수는 env와 arguments입니다.\n\n```js\ndocker run -p 8085:80 -e \"ConnectionStrings__DefaultConnection=Data Source=192.168.100.194,1433;Initial Catalog=ReactNetCoreCrudDb;User Id=sa;Password=database@1;\" productbackendapp:latest\n```\n\n![이미지](/assets/img/2024-07-01-BuildandContainerizeProductApplicationusingReactJSNETCoreandDocker_6.png)\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![Image 7](/assets/img/2024-07-01-BuildandContainerizeProductApplicationusingReactJSNETCoreandDocker_7.png)\n\n![Image 8](/assets/img/2024-07-01-BuildandContainerizeProductApplicationusingReactJSNETCoreandDocker_8.png)\n\n![Image 9](/assets/img/2024-07-01-BuildandContainerizeProductApplicationusingReactJSNETCoreandDocker_9.png)\n\n![Image 10](/assets/img/2024-07-01-BuildandContainerizeProductApplicationusingReactJSNETCoreandDocker_10.png)\n\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n도커 실행 -p 3000:3000 productfrontendapp\n```\n\n![이미지1](/assets/img/2024-07-01-BuildandContainerizeProductApplicationusingReactJSNETCoreandDocker_11.png)\n\n![이미지2](/assets/img/2024-07-01-BuildandContainerizeProductApplicationusingReactJSNETCoreandDocker_12.png)\n\n![이미지3](/assets/img/2024-07-01-BuildandContainerizeProductApplicationusingReactJSNETCoreandDocker_13.png)\n\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 샘플 애플리케이션 스크린샷\n\n![screenshot1](/assets/img/2024-07-01-BuildandContainerizeProductApplicationusingReactJSNETCoreandDocker_14.png)\n\n![screenshot2](/assets/img/2024-07-01-BuildandContainerizeProductApplicationusingReactJSNETCoreandDocker_15.png)\n\n![screenshot3](/assets/img/2024-07-01-BuildandContainerizeProductApplicationusingReactJSNETCoreandDocker_16.png)\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![이미지 1](/assets/img/2024-07-01-BuildandContainerizeProductApplicationusingReactJSNETCoreandDocker_17.png)\n\n![이미지 2](/assets/img/2024-07-01-BuildandContainerizeProductApplicationusingReactJSNETCoreandDocker_18.png)\n\n# GitHub\n\nhttps://github.com/Jaydeep-007/React_NETCore_CRUD-Docker\n\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 결론\n\n이 기사에서는 .NET Core 및 SQL Server를 사용하여 제품 관리 백엔드 애플리케이션을 만들었습니다. 이 애플리케이션은 CRUD 작업을 수행하는 데 필요한 다양한 API 엔드포인트를 사용합니다. 나중에 React JS를 사용하여 프론트엔드 애플리케이션을 만들고, Axios를 활용하여 백엔드 애플리케이션을 소비하였습니다. 또한, 두 애플리케이션을 Docker를 사용하여 컨테이너화하였습니다.","ogImage":{"url":"/assets/img/2024-07-01-BuildandContainerizeProductApplicationusingReactJSNETCoreandDocker_0.png"},"coverImage":"/assets/img/2024-07-01-BuildandContainerizeProductApplicationusingReactJSNETCoreandDocker_0.png","tag":["Tech"],"readingTime":26},{"title":"Docker로 ReactJS 애플리케이션 컨테이너화하는 방법","description":"","date":"2024-07-01 16:15","slug":"2024-07-01-ContainerizationofReactJSApplicationusingDocker","content":"\n\n<img src=\"/assets/img/2024-07-01-ContainerizationofReactJSApplicationusingDocker_0.png\" />\n\n안녕하세요\n\n이 글에서는 샘플 React JS 애플리케이션을 생성하고 Docker를 활용하여 컨테이너화하는 방법을 배워보겠습니다.\n\n일정\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- React JS 애플리케이션 샘플\n- Docker 파일 생성\n- 애플리케이션 컨테이너화\n\n필수 요구사항\n\n- NPM\n- React JS\n- Docker Engine\n\nReact JS 애플리케이션 샘플\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n단계 1:\n\n아래 명령어를 사용하여 새 React JS 애플리케이션을 만듭니다.\n\n참고: 머신에 NPM 및 React JS가 이미 설치되어 있는지 확인하세요.\n\n\nnpx create-react-app reactjs-app-docker\n\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![이미지](/assets/img/2024-07-01-ContainerizationofReactJSApplicationusingDocker_1.png)\n\n단계 2:\n\n애플리케이션 디렉토리로 이동하여 애플리케이션을 실행합니다.\n\nnpm start\n\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 Markdown 형식으로 변경된 테이블입니다.\n\n\n![이미지 1](/assets/img/2024-07-01-ContainerizationofReactJSApplicationusingDocker_2.png)\n\n![이미지 2](/assets/img/2024-07-01-ContainerizationofReactJSApplicationusingDocker_3.png)\n\nDocker 파일 생성\n\n```js\n# 공식 Node.js 베이스 이미지 사용\nFROM node:18\n\n# 작업 디렉토리 설정\nWORKDIR /app\n\n# package.json 및 package-lock.json 파일 복사\nCOPY package*.json ./\n\n# 종속 항목 설치\nRUN npm install\n\n# 나머지 애플리케이션 코드 복사\nCOPY . .\n\n# React 앱 빌드\nRUN npm run build\n\n# 빌드 폴더를 제공하는 serve를 전역으로 설치\nRUN npm install -g serve\n\n# 앱이 실행되는 포트 노출\nEXPOSE 3000\n\n# React 앱 시작\nCMD [\"serve\", \"-s\", \"build\"]\n```\n\n\n안내해 주셔서 감사합니다. 기타 요청이 있으시면 언제든지 말씀해주세요!\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 Docker 파일의 각 단계를 설명합니다:\n\n![이미지](/assets/img/2024-07-01-ContainerizationofReactJSApplicationusingDocker_4.png)\n\n이 줄은 Docker 이미지의 기본 이미지를 지정합니다. 우리는 Node.js의 공식 이미지를 버전 18으로 사용합니다. 이 이미지에는 Node.js 애플리케이션을 실행하는 데 필요한 모든 것이 포함되어 있습니다.\n\n![이미지](/assets/img/2024-07-01-ContainerizationofReactJSApplicationusingDocker_5.png)\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위 줄은 Docker 컨테이너 내의 작업 디렉토리를 /app으로 설정합니다. 이후의 모든 명령은 /app 디렉토리에서 실행됩니다. 이는 컨테이너 내에서 파일 시스템을 조직화하는 데 도움이 됩니다.\n\n![이미지](/assets/img/2024-07-01-ContainerizationofReactJSApplicationusingDocker_6.png)\n\n호스트 머신에서 package.json 및 package-lock.json을 Docker 컨테이너의 현재 작업 앱 디렉토리로 복사합니다. 이 파일들은 애플리케이션의 의존성을 설치하는 데 필요합니다.\n\n![이미지](/assets/img/2024-07-01-ContainerizationofReactJSApplicationusingDocker_7.png)\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 단계는 package.json에 정의된 종속성을 설치하기 위해 npm install을 실행합니다. 이 단계를 통해 모든 필요한 Node.js 패키지가 컨테이너에 설치됩니다.\n\n![image](/assets/img/2024-07-01-ContainerizationofReactJSApplicationusingDocker_8.png)\n\n다음으로, 호스트 머신의 현재 디렉토리에서 Docker 컨테이너의 현재 작업 디렉토리로 모든 파일과 디렉토리를 복사합니다. 이는 소스 코드와 애플리케이션을 빌드하고 실행하는 데 필요한 모든 파일을 포함합니다.\n\n![image](/assets/img/2024-07-01-ContainerizationofReactJSApplicationusingDocker_9.png)\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래 명령은 React 애플리케이션을 프로덕션을 위해 빌드하는 npm run build를 실행합니다. 빌드 프로세스는 React 코드를 컴파일합니다.\n\n![이미지](/assets/img/2024-07-01-ContainerizationofReactJSApplicationusingDocker_10.png)\n\nDocker 컨테이너 내부에 serve 패키지를 글로벌로 설치합니다. serve는 빌드된 React 애플리케이션을 제공하는 데 사용할 간단한 정적 파일 서버입니다.\n\n![이미지](/assets/img/2024-07-01-ContainerizationofReactJSApplicationusingDocker_11.png)\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 줄은 Docker에게 컨테이너가 실행 중일 때 포트 3000에서 수신 대기함을 알려줍니다. 이 포트는 React 애플리케이션이 제공될 포트입니다.\n\n![이미지](/assets/img/2024-07-01-ContainerizationofReactJSApplicationusingDocker_12.png)\n\n다음으로, 컨테이너가 시작될 때 실행할 명령을 지정합니다. 여기서 serve -s build는 serve 정적 파일 서버를 시작하고 React 빌드 프로세스에서 컴파일된 정적 파일이 포함된 build 디렉토리의 내용을 제공합니다.\n\n애플리케이션의 컨테이너화\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n안녕하세요! 위 아래로 팔을 펴고 팔다리를 흔들어보세요. 근육들을 풀어주는 운동이죠! 함께 힘내봐요! 🏋🏻‍♂️🚀\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래와 같이 Markdown 형식으로 변경하면 됩니다.\n\n\n![Containerization of ReactJS Application using Docker](/assets/img/2024-07-01-ContainerizationofReactJSApplicationusingDocker_13.png)\n\nStep 2:\n\nRun the docker image.\n\ndocker run -p 3000:3000 reactjs-app-docker\n\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![이미지](/assets/img/2024-07-01-ContainerizationofReactJSApplicationusingDocker_14.png)\n\n![이미지](/assets/img/2024-07-01-ContainerizationofReactJSApplicationusingDocker_15.png)\n\nGithub:\n\nhttps://github.com/Jaydeep-007/reactjs-app-docker\n\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n결론\n\n이 글에서는 샘플 React JS 애플리케이션을 만들었습니다. 이후 Docker 파일을 생성하고 각 단계와 목적을 이해했습니다. 마지막으로 Docker 명령어를 사용하여 Docker 이미지 파일을 빌드하고 컨테이너화했습니다.","ogImage":{"url":"/assets/img/2024-07-01-ContainerizationofReactJSApplicationusingDocker_0.png"},"coverImage":"/assets/img/2024-07-01-ContainerizationofReactJSApplicationusingDocker_0.png","tag":["Tech"],"readingTime":8},{"title":"Socketio를 사용한 실시간 채팅 최고의 구현 방법 Socket 실시간 DB 활용법","description":"","date":"2024-07-01 16:14","slug":"2024-07-01-ChatUsingSocketioWithBestpracticesSocketReal-Timedb","content":"\n\n\n<img src=\"/assets/img/2024-07-01-ChatUsingSocketioWithBestpracticesSocketReal-Timedb_0.png\" />\n\n현재, 현대 통신 기술에서 실시간 채팅 애플리케이션은 필수품이 되었습니다. React 또는 React Native에서 채팅 앱을 개발하는 경우, 올바른 기술 스택 선택이 중요합니다. 많은 개발자들이 WebSockets 또는 Firebase와 같은 실시간 데이터베이스를 사용해야 하는 딜레마에 직면합니다. 또한, 소켓 연결 중단 처리 및 데이터 신뢰성 확보는 흔한 도전 과제입니다.\n\n<img src=\"/assets/img/2024-07-01-ChatUsingSocketioWithBestpracticesSocketReal-Timedb_1.png\" />\n\n본 블로그 포스트에서는 실시간 채팅 기능을 관리하는 최상의 방법에 대해 살펴보고, 소켓 연결 중단 및 데이터 손실과 관련된 문제를 극복하는 데 중점을 둘 것입니다.\n\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# WebSockets 대 실시간 데이터베이스: 적합한 도구 선택하기\n\n기술적인 세부 사항에 대해 깊이 이해하기 전에 WebSockets와 실시간 데이터베이스 간의 차이점을 이해하는 것이 중요합니다.\n\n## WebSockets\n\n장점:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 낮은 대기 시간: 웹소켓은 지속적인 연결을 제공하여 낮은 대기 시간으로 양방향 통신이 가능합니다.\n- 효율성: 빈번한 업데이트에 이상적이며, 웹소켓을 사용하면 반복된 HTTP 요청의 오버헤드가 줄어듭니다.\n- 유연성: 사용자 정의 프로토콜과 데이터 형식을 지원하여 더 많은 제어가 가능합니다.\n\n단점:\n- 복잡성: 웹소켓 서버를 설정하고 관리하는 것이 어려울 수 있습니다.\n- 확장성: 많은 연결을 다루려면 견고한 인프라가 필요합니다.\n\n## 실시간 데이터베이스 (파이어베이스)\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n장점:\n\n- 사용의 편의성: Firebase는 실시간 데이터 동기화를 위한 직관적인 API를 제공합니다.\n- 확장성: Firebase에서 관리되므로 확장하기 쉽습니다.\n- 내장된 기능: 인증, 분석 및 오프라인 지원이 포함되어 있습니다.\n\n단점:\n\n- 대기 시간: WebSockets보다 약간 높은 대기 시간이 발생할 수 있습니다.\n- 비용: 앱이 확장될수록 사용량 기반 요금 체계가 비싸질 수 있습니다.\n- 제어 능력 감소: Firebase는 세부 정보를 추상화하여 사용자 정의를 제한합니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 소켓 연결 문제 극복하기\n\n특히 모바일 환경에서 소켓 연결은 네트워크 불안정 또는 기기 상태로 인해 끊길 수 있습니다. 안정적인 통신과 데이터 무결성을 보장하기 위한 전략들이 있습니다.\n\n## 1. 자동 재연결\n\n연결이 끊겼을 때 소켓을 자동으로 다시 연결하는 로직을 구현하세요. Socket.IO와 같은 라이브러리는 재연결을 위한 내장 지원 기능을 제공합니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nconst socket = io('https://yourserver.com', {\n  reconnection: true,\n  reconnectionAttempts: Infinity,\n  reconnectionDelay: 1000,\n  reconnectionDelayMax: 5000,\n  timeout: 20000,\n});\n```\n\n## 2. 메시지 확인\n\n메시지가 수신되었는지 확인하려면 확인을 사용하십시오. 확인되지 않은 경우 메시지를 재전송하십시오.\n\n```js\nsocket.emit('message', message, (response) => {\n  if (response.status !== 'ok') {\n    // 메시지 재전송 시도\n  }\n});\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 3. 메시지 대기열\n\n연결이 끊어지면 메시지를 대기열에 저장하고 다시 연결되면 다시 전송합니다.\n\n```js\nlet messageQueue = [];\n\nsocket.on('connect', () => {\n  while (messageQueue.length > 0) {\n    const message = messageQueue.shift();\n    socket.emit('message', message);\n  }\n});\n\nfunction sendMessage(message) {\n  if (socket.connected) {\n    socket.emit('message', message);\n  } else {\n    messageQueue.push(message);\n  }\n}\n```\n\n## 4. 네트워크 변경 처리\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n네트워크 변경사항을 청취하여 효율적으로 재연결을 처리하세요.\n\n```js\nwindow.addEventListener('online', () => {\n  if (!socket.connected) {\n    socket.connect();\n  }\n});\nwindow.addEventListener('offline', () => {\n  socket.disconnect();\n});\n```\n\n## 5. 지속적인 저장\n\n로컬 저장소나 데이터베이스와 같은 지속적인 저장소를 사용하여 메시지를 임시로 저장하세요.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nfunction saveMessageToLocal(message) {\n  const messages = JSON.parse(localStorage.getItem('messages')) || [];\n  messages.push(message);\n  localStorage.setItem('messages', JSON.stringify(messages));\n}\n\nfunction loadMessagesFromLocal() {\n  return JSON.parse(localStorage.getItem('messages')) || [];\n}\n\nfunction clearLocalMessages() {\n  localStorage.removeItem('messages');\n}\n\nfunction sendMessage(message) {\n  if (socket.connected) {\n    socket.emit('message', message, (response) => {\n      if (response.status === 'ok') {\n        // Message sent successfully\n      } else {\n        saveMessageToLocal(message);\n      }\n    });\n  } else {\n    saveMessageToLocal(message);\n  }\n}\n\nsocket.on('connect', () => {\n  const messages = loadMessagesFromLocal();\n  messages.forEach((message) => {\n    socket.emit('message', message);\n  });\n  clearLocalMessages();\n});\n```\n\n## 6. Heartbeat/Ping Mechanism\n\n연결이 끊어진 경우를 감지하고 다시 연결하기 위한 하트비트 메커니즘을 구현합니다.\n\n```js\nsetInterval(() => {\n  if (socket.connected) {\n    socket.emit('ping');\n  }\n}, 5000);\n\nsocket.on('pong', () => {\n  // 연결 유지 중\n});\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 결론\n\n이러한 전략을 구현하면 대화 응용 프로그램의 신뢰성을 크게 향상시킬 수 있습니다. 자동 재연결, 메시지 확인, 메시지 대기열, 네트워크 변경 처리, 영구 저장, 그리고 하트비트 메커니즘을 활용하여 견고하고 원활한 사용자 경험을 보장할 수 있습니다.\n\n블로그 게시물의 어떤 부분이든 스타일이나 응용 프로그램에 대한 구체적인 세부 정보와 더 잘 맞도록 조정하는 데 자유롭게 변경하십시오.\n\n# 즐거운 코딩","ogImage":{"url":"/assets/img/2024-07-01-ChatUsingSocketioWithBestpracticesSocketReal-Timedb_0.png"},"coverImage":"/assets/img/2024-07-01-ChatUsingSocketioWithBestpracticesSocketReal-Timedb_0.png","tag":["Tech"],"readingTime":7},{"title":"2024년 React Native 마스터하기 전문가 통찰을 통해 기술 스택을 완벽하게 이해하는 종합 가이드","description":"","date":"2024-07-01 16:12","slug":"2024-07-01-MasteringReactNativein2024AComprehensiveGuidetoNavigatetheTechStackwithExpertInsights","content":"\n\n이미지 태그를 Markdown 형식으로 변경해보세요.\n\n\n![Mastering React Native in 2024](/assets/img/2024-07-01-MasteringReactNativein2024AComprehensiveGuidetoNavigatetheTechStackwithExpertInsights_0.png)\n\n# 1. 파워 언어: TypeScript\n\n왜 TypeScript를 사용해야 할까요?\n\n- 정적 타입: TypeScript는 코드 품질을 향상시키고 개발 중 잠재적인 오류를 찾아냅니다.\n- 향상된 도구: 더 좋은 IDE 지원과 코드 탐색을 즐기세요.\n- 확장성: TypeScript는 보다 구조화되고 확장 가능한 코드베이스를 제공합니다.\n\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 2. CLI 유연성: Expo Eject 옵션과 함께 React Native CLI\n\nReact Native CLI를 선택하는 이유는?\n\n- 완벽한 사용자 정의: React Native CLI는 완벽한 사용자 정의와 네이티브 모듈 호환성을 제공합니다.\n- Eject 옵션: 빠른 개발을 위해 Expo로 시작하고 더 많은 제어를 위해 React Native CLI로 이동하세요.\n\n# 3. 매끄러운 라우팅: React Navigation\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nReact Navigation을 사용하는 이유는 무엇인가요?\n\n- 크로스 플랫폼 호환성: React Navigation은 강력한 크로스 플랫폼 지원으로 널리 채택되었습니다.\n- 사용자 정의: 다양한 앱 구조에 대한 유연하고 사용자 정의 가능한 네비게이션 솔루션을 제공합니다.\n\n# 4. UI 우수성: Tailwind를 Native Wind와 함께 사용하는 이유는 무엇인가요?\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 유틸리티 우선 접근: Tailwind의 유틸리티 우선 접근은 UI 개발을 간소화합니다.\n- Native Wind 통합: Native Wind는 Tailwind의 강력함을 React Native로 가져와 네이티브 미학과 유연성을 결합합니다.\n\n# 5. 상태 관리 조화: Zustand\n\nZustand을 선택하는 이유는?\n\n- 간결함: Zustand는 상태 관리에 더 간단하고 직관적인 방법을 제공합니다.\n- 보일러플레이트 없음: Redux와 같은 큰 솔루션과 관련된 보일러플레이트 코드 없이 상태 관리를 즐기세요.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 6. 데이터 손쉽게 가져오기: GraphQL과 함께 React Query\n\nReact Query와 GraphQL을 함께 사용하는 이유는 무엇일까요?\n\n- 효율성: React Query는 데이터 가져오기와 캐싱을 단순화합니다.\n- GraphQL의 장점: 최적화된 API 상호작용을 위해 GraphQL의 혜택을 누릴 수 있습니다.\n\n# 7. 데이터 저장이 쉬운 MMKV\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nMMKV는 React Native를 위한 성능 우수한 키-값 저장 솔루션이에요. 속도를 희생하지 않고 효율적인 데이터 지속성을 누리세요.\n\n# 8. 애니메이션 마법: React Native Reanimated\n\nReact Native Reanimated를 사용하는 이유는 무엇인가요?\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 부드러운 애니메이션: React Native Reanimated을 사용하면 원활하고 매혹적인 애니메이션을 만들 수 있습니다.\n- 네이티브 성능: 네이티브 성능을 활용하여 사용자 경험을 원활하게 만들 수 있습니다.\n\n# 9. 디버깅의 즐거움: Flipper와 Reactotron\n\nFlipper와 Reactotron을 선택하는 이유는?\n\n- 시각적 디버깅: Flipper는 React Native 앱을 디버깅하는데 시각적 인터페이스를 제공합니다.\n- 실시간 정보: Reactotron은 실시간 로깅, 네트워킹 등을 제공하여 개발을 간소화합니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 10. 오류 보고의 탁월함: 센트리\n\n왜 센트리를 사용해야 하나요?\n\n- 포괄적인 오류 추적: 센트리는 포괄적인 오류 추적을 통해 문제를 식별하고 해결하는 데 도움을 줍니다.\n- 플랫폼 간 지원: 센트리의 플랫폼 간 호환성을 활용하여 통합된 오류 보고 솔루션을 얻을 수 있습니다.\n\n# 11. 효율적인 개발을 위한 크로스 플랫폼 전략: 엑스포\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n왜 Expo를 선택해야 할까요?\n\n- 빠른 개발: Expo는 간소화된 워크플로우로 개발을 가속화합니다.\n- 관리 환경: 사용 편의성을 위해 관리 환경을 즐길 수 있습니다.\n\n요약하면, 2024년에 React Native 기술 스택을 탐색하는 것은 매회 전략적인 결정을 내려야 합니다. 강력한 타입 지원을 위해 TypeScript를 채택하고, 유연성을 위해 적절한 CLI를 선택하며, 프로젝트 요구 사항과 일치하는 상태 관리 및 UI 라이브러리를 선택하고, 효율적인 데이터 가져오기 및 저장 솔루션을 활용하여 혁신을 촉진하고 개발을 가속화하는 기술 스택을 만들 수 있습니다. React Native 개발의 흥미진진한 여정을 기대해 주세요!\n\n# 스텔라 컴포넌트 통합: 이 젬들로 앱을 한 단계 높이세요\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제, 앱의 기능성과 사용자 인터페이스를 향상시킬 수 있는 훌륭한 React Native 구성 요소를 소개하겠습니다:\n\n## 1. Bouncy CheckBox\n\n- 설명: 바운시 애니메이션이 있는 매력적인 체크박스 컴포넌트.\n- 주요 기능:\n  - 상호작용이 가능하고 시각적으로 매력적인 체크박스.\n  - 사용자 참여를 위한 부드러운 애니메이션.\n\n## 2. Bottom Sheet\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- **설명:** 화면 하단에서 슬라이드 업되는 다재다능한 패널입니다.\n- **주요 기능:**\n  - 메뉴, 모달 또는 추가 콘텐츠에 적합합니다.\n  - 부드러운 전환 효과 및 사용자 정의 가능한 모양입니다.\n\n# 3. React Native Gifted Chat\n\n- **설명:** 매우 사용자 정의가 가능한 채팅 UI 라이브러리입니다.\n- **주요 기능:**\n  - 다양한 채팅 구성 요소가 있습니다.\n  - 이미지, 위치 공유 등을 지원합니다.\n  - 사용자 정의가 가능하며 통합하기 쉽습니다.\n\n# 4. Victory-Native\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 설명: 인기 있는 Victory 라이브러리를 기반으로 한 React Native용 차트 라이브러리입니다.\n- 주요 기능:\n- 다양한 차트 유형 지원 (선 그래프, 막대 그래프, 파이 차트 등).\n- 매우 사용자 정의 및 상호 작용형 차트.\n\n# 5. React-Native-Toast-Message\n\n- 설명: 토스트 메시지를 표시하는 간단한 방법입니다.\n- 주요 기능:\n- 가볍고 사용하기 쉽습니다.\n- 다양한 구성으로 사용자 정의할 수 있는 토스트 메시지.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 설명: 플레이스홀더 로딩 애니메이션을 생성하는 구성 요소입니다.\n- 주요 기능:\n    - 콘텐츠를 위한 스켈레톤 로딩 애니메이션 제공\n    - 다양한 UI 요소에 맞춤 설정 가능\n\n## 7. React-Native-Pager-View\n\n- 설명: 크로스 플랫폼 뷰 페이저 컴포넌트입니다.\n- 주요 기능:\n    - iOS 및 안드로이드 모두 지원\n    - 부드러운 스와이핑 및 사용자 정의 가능한 전환 효과\n\n## 8. React-Native-Calendars\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 설명: 사용자 정의 및 확장 가능한 달력 구성 요소입니다.\n- 핵심 기능:\n- 다양한 달력 보기 지원 (월, 주, 일).\n- 사용자 정의 가능한 외관 및 이벤트 통합.\n\n## 9. @shopify/flash-list\n\n- 설명: React Native용 고성능 목록 구성 요소입니다.\n- 핵심 기능:\n- 대량 데이터 세트에 효율적인 렌더링.\n- 무한 스크롤 및 동적 로딩 지원.\n\n## 10. 이미지 캐싱을 위한 React-Native-Fast-Image\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 설명: React Native를 위한 성능 최적화된 이미지 캐싱 컴포넌트.\n- 주요 기능:\n  - 개선된 성능을 위해 이미지를 효율적으로 캐싱합니다.\n  - React Native 애플리케이션과의 심리스한 통합을 제공합니다.\n\n이러한 컴포넌트들은 상호작용적이고 시각적으로 매력적인 React Native 애플리케이션을 구축하기 위한 다양한 기능을 제공합니다. 프로젝트 요구 사항에 따라 이러한 컴포넌트들을 통합하여 사용자 경험을 향상시키고 개발을 최적화할 수 있습니다.\n\n강력한 도구들과 즐거운 컴포넌트들로 풍부한 React Native 개발 여정을 기대해 주세요!\n\n👏 스토리에 박수를 보내고 작가를 팔로우하세요!\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 저자의 통찰력 있는 콘텐츠에 감사드립니다.\n- Abhishek Kumar를 팔로우하세요.\n- 📰 Abhishek Kumar 도서관에서 더 알아보기\n- 🔔 소셜 미디어를 통해 연락을 유지하세요.\n- Level Up Coding을 트위터에서 팔로우하고 링크드인에서 소통하여 최신 토론과 콘텐츠를 확인하세요.\n\n# Stackademic\n\n끝까지 읽어주셔서 감사합니다. 떠나시기 전에:\n\n- 작가에게 박수를 보내고 팔로우를 고려해 주세요! 👏\n- Twitter(X)와 리눅스, 유튜브에서 팔로우하세요.\n- Stackademic.com 방문하여 전 세계의 무료 프로그래밍 교육을 민주화하는 방법에 대해 더 알아보세요.","ogImage":{"url":"/assets/img/2024-07-01-MasteringReactNativein2024AComprehensiveGuidetoNavigatetheTechStackwithExpertInsights_0.png"},"coverImage":"/assets/img/2024-07-01-MasteringReactNativein2024AComprehensiveGuidetoNavigatetheTechStackwithExpertInsights_0.png","tag":["Tech"],"readingTime":9},{"title":"2024년에 수강할 수 있는 최고의 프론트엔드 마스터 강좌 TOP 5","description":"","date":"2024-07-01 16:11","slug":"2024-07-01-Top5FrontendMasterCoursesYouCanTakein2024","content":"\n\n## 2024년에 수강할 Frontend Masters의 내가 좋아하는 웹 개발 과정\n\n![이미지](/assets/img/2024-07-01-Top5FrontendMasterCoursesYouCanTakein2024_0.png)\n\n안녕하세요 여러분, 웹 개발 분야의 빠르고 끊임없이 진화하는 환경에서 계속적인 학습은 유익할 뿐만 아니라 필수적입니다. 현재보다 앞서가기 위해서는 기술 스킬을 지속적으로 향상시키고, 새로운 기술을 이해하고, 현대 웹 애플리케이션을 구동하는 도구를 숙달하는 노력이 필요합니다.\n\n2024년에 전문성과 경력 전망을 높이고 싶은 개발자들을 위해, Frontend Masters는 가장 포괄적이고 매력적인 과정 중 일부를 제공합니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nFrontend Master는 초보자부터 숙련된 개발자를 위한 고품질, 심층적인 코스로 유명한 최고의 온라인 학습 플랫폼으로 자리매김했습니다.\n\n웹 개발 기초를 이해하고 복잡한 알고리즘을 파헤치거나 React 같은 강력한 프론트엔드 라이브러리를 숙달하려면, Frontend Master에는 여러분의 Bed를 충족시키는 코스가 마련되어 있습니다.\n\n본 기사에서는 2024년에 고려해볼 만한 상위 5개 Frontend Master 코스를 살펴보겠습니다. 이 코스들은 관련성, 종합성 및 전달하는 실용적인 기술에 기반하여 선정되었습니다.\n\n알고리즘과 JavaScript 숙달부터 React에서 능숙해지고 풀스택을 이해하기까지, 이러한 코스들은 경쟁적인 웹 개발 세계에서 두각을 나타내기 위해 필요한 지식과 실무 경험을 제공할 것입니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n한번 깊게 파보고 이 각각의 강좌가 여러분의 학습 목표와 직업 목표를 어떻게 달성할 수 있는지 알아보세요.\n\n그런데, 만약 여러분이 서둘러야 한다면, 지금 Frontend Masters에 가입해보세요. 그들의 고품질 강좌를 시청한 뒤 나중에 저에게 감사할 거예요.\n\n# 웹 개발자를 위한 Frontend Masters의 최고 강좌 5선\n\n여기 Frontend Masters에서 웹 개발자들이 JavaScript와 React와 같은 필수 웹 개발 스킬을 배울 수 있는 최고의 강좌 목록이 있습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 1. 당신이 필요로 할 마지막 알고리즘 강의\n\n알고리즘은 효율적인 프로그래밍의 근간이며, 그것들을 숙달하면 문제 해결 능력이 크게 향상됩니다. \"당신이 필요로 할 마지막 알고리즘 강의\"는 기본적인 정렬과 탐색부터 동적 프로그래밍과 그래프 알고리즘과 같은 고급 주제까지 모두 다루며 알고리즘에 대한 깊은 이해를 제공하도록 설계되었습니다.\n\n## 주요 강점:\n\n- 포괄적인 커리큘럼: 이 강의는 다양한 알고리즘을 다루어 어떤 코딩 과제에도 대처할 수 있도록 충분히 장착되도록 보장합니다.\n- 실습 중심 학습: 다양한 코딩 연습과 실제 문제를 통해 알고리즘을 구현하는 실용적인 경험을 얻을 수 있습니다.\n- 전문가의 지도: 경력 있는 전문가들이 가르치며 교재에서 찾을 수 없는 통찰과 조언을 제공합니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 등록해야 하는 이유:\n\n알고리즘을 마스터하면 코딩 효율성을 향상시킬 뿐만 아니라 기술 면접과 경쟁적인 프로그래밍에 대비할 수 있습니다. 이 강좌는 알고리즘에 튼튼한 기반을 제공하여 개발자들에게 불가능한 기술을 갖추게 해줍니다.\n\n이 강좌에 등록하려면 [여기](#)를 클릭하세요 — 이 강좌가 최후의 알고리즘 강좌가 될 겁니다.\n\n![이미지](/assets/img/2024-07-01-Top5FrontendMasterCoursesYouCanTakein2024_1.png)\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 2. JavaScript: 처음부터 전문가까지\n\n자바스크립트는 웹의 공용어이며, 프런트엔드 개발자에게 필수적인 능력입니다. \"JavaScript: 처음부터 전문가까지\"는 자바스크립트의 기초부터 고급 개념까지 다루는 포괄적인 강좌로, 당신을 숙련된 자바스크립트 개발자로 만들어줍니다.\n\n## 주요 내용:\n\n- 초급에서 고급까지: 강좌는 자바스크립트의 기초부터 시작하여 클로저, 프로토타입, 비동기 프로그래밍과 같은 고급 주제를 순차적으로 다룹니다.\n- 프로젝트 중심의 학습: 학습을 강화하고 여러분의 기술을 증명할 수 있는 현실 세계 프로젝트를 개발합니다.\n- 최신 자바스크립트: 강좌에는 ES6+ 문법과 기능을 비롯한 최신 자바스크립트 기능이 포함되어 있습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 등록해야 하는 이유:\n\n자바스크립트는 현대 웹 개발의 핵심입니다. 이 과정은 자바스크립트에 대해 철저한 기초를 제공하여 동적이고 인터랙티브한 웹 애플리케이션을 개발할 준비를 완벽하게 합니다.\n\n이 수업에 가입할 수 있는 링크는 여기에 있습니다 — JavaScript: 초보부터 전문가까지\n\n![Frontend Master Courses in 2024](/assets/img/2024-07-01-Top5FrontendMasterCoursesYouCanTakein2024_2.png)\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 3. 완전한 리액트 입문, v8\n\n리액트는 사용자 인터페이스를 구축하는 데 가장 인기 있는 라이브러리 중 하나가 되었습니다. \"완전한 리액트 입문, v8\"은 리액트를 배우는 데 가장 확실한 코스로, JSX, 상태, 속성, 라이프사이클 메서드와 같은 기본부터 후크, 컨텍스트, 그리고 성능 최적화와 같은 고급 개념까지 모두 다룹니다.\n\n## 주요 포인트:\n\n- 철저한 리액트 개념: 이 코스는 JSX, 상태, 속성, 라이프사이클 메서드 등 리액트의 핵심 개념을 다룹니다.\n- 현대적인 리액트 실천 방법: 후크와 컨텍스트 API와 같은 최신 리액트 기능에 대해 배우면서, 산업 실무에서 최신 동향을 따를 수 있습니다.\n- 실전 프로젝트: 여러 프로젝트를 개발하면서, 리액트 애플리케이션을 만드는 경험을 통해 실무 역량을 키울 수 있습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 등록해야 하는 이유:\n\nReact는 동적 웹 애플리케이션을 구축하는 강력한 도구입니다. 이 코스는 복잡하고 성능이 우수한 React 애플리케이션을 만들기 위해 필요한 기술을 갖추게 해주며, 어떤 개발팀에도 가치 있는 자산이 될 것입니다.\n\n이 코스에 가입하려면 다음 링크를 클릭하세요 — Complete Intro to React, v8\n\n![React Course Image](/assets/img/2024-07-01-Top5FrontendMasterCoursesYouCanTakein2024_3.png)\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 4. 풀 스택 for 프론트 엔드 엔지니어, v3\n\n전체 스택을 이해하는 것은 견고하고 확장 가능한 웹 애플리케이션을 구축하고 싶어하는 프론트 엔드 엔지니어들에게 중요합니다. \"프론트 엔드 엔지니어를 위한 풀 스택, v3\"는 프론트 엔드와 백엔드 개발 사이의 간극을 좁히며 둘에 대한 포괄적인 이해를 제공합니다.\n\n## 주요 내용:\n\n- 포괄적인 커버리지: 이 강좌는 React와 같은 프론트 엔드 기술뿐만 아니라 Node.js, Express, 데이터베이스 등 백엔드 기술도 다룹니다.\n- 실제 응용 프로그램: 프론트 엔드와 백엔드 구성 요소를 통합하는 실용적인 경험을 쌓을 수 있도록 풀 스택 애플리케이션을 구축합니다.\n- 배포 및 데브옵스: 애플리케이션을 배포하고 본딩 환경에서 관리하는 방법을 배웁니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 등록해야 하는 이유:\n\n풀 스택 지식은 디자인부터 배포까지 개발 프로세스 전반에 이해하고 기여할 수 있게 해줍니다. 이 과정은 완전한 웹 응용 프로그램을 구축하고 유지 관리하는 기술을 제공하여 개발자로서의 다재다능성을 향상시킵니다.\n\n다음은 이 수업에 참여하는 링크입니다 - 풀 스택을 위한 프론트엔드 엔지니어링, v3\n\n![course image](/assets/img/2024-07-01-Top5FrontendMasterCoursesYouCanTakein2024_4.png)\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 5. 완전한 웹 개발 입문, v3\n\n웹 개발에 새로 오신 분들을 위해 \"완전한 웹 개발 입문, v3\"은 해당 분야에 대한 포괄적인 소개를 제공합니다. 이 과정은 HTML 및 CSS부터 JavaScript 및 그 이상까지 모던 웹 애플리케이션을 구축하는 데 필요한 기본 기술과 개념을 다룹니다.\n\n## 주요 포인트:\n\n- 기초 기술: 웹 개발의 핵심 기술인 HTML, CSS 및 JavaScript의 기초를 배웁니다.\n- 대화식 학습: 이 과정은 상호 작용하는 코딩 연습과 프로젝트를 포함하여 학습을 강화합니다.\n- 모던 웹 개발: 반응형 디자인 및 Git을 활용한 버전 관리를 포함한 현대적인 웹 개발 방법 및 도구에 입문합니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 등록해야 하는 이유:\n\n이 강좌는 초보자에게 이상적인 웹 개발의 견고한 기반을 제공합니다. 강좌를 마치면 자신만의 웹 애플리케이션을 구축하고 더 고급 주제에서 계속 학습할 수 있는 기술을 습득할 수 있습니다.\n\n이 강좌에 가입하려면 다음 링크를 참조하세요 - Complete Intro to Web Development, v3\n\n![Link to the course](/assets/img/2024-07-01-Top5FrontendMasterCoursesYouCanTakein2024_5.png)\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 결론\n\n2024년 웹 개발을 배우는 데 도움이 되는 5가지 최고의 Frontend Masters 강좌에 대해 알아보았습니다. 교육과 기술에 투자하는 것은 웹 개발 분야에서 경력을 나아가는 가장 좋은 방법 중 하나입니다.\n\n2024년을 위한 이 상위 5개 FrontMaster 강좌는 이론적 지식과 실용적 경험을 조화롭게 제공하여 현대 웹 개발의 도전에 잘 대비할 수 있도록 도와줍니다.\n\n알고리즘에 능숙해지거나 JavaScript를 숙달하거나 React에 몰입하거나 풀 스택을 이해하거나 웹 개발을 시작하기 위한 준비를 하고 싶다면, 이러한 강좌로 모두 가능합니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n지금 등록하고 발전하는 여정을 함께 나아가요!","ogImage":{"url":"/assets/img/2024-07-01-Top5FrontendMasterCoursesYouCanTakein2024_0.png"},"coverImage":"/assets/img/2024-07-01-Top5FrontendMasterCoursesYouCanTakein2024_0.png","tag":["Tech"],"readingTime":9},{"title":"Claude 35와 Python으로 ReAct AI 에이전트 만드는 방법","description":"","date":"2024-07-01 16:09","slug":"2024-07-01-HowtoBuildaReActAIAgentwithClaude35andPython","content":"\n\n리즌+액트(ReAct) 에이전트들은 사고의 연쇄를 결합하고 외부 도구에 접근하며 해결책으로 나아가는 능력을 활용하여 복잡한 추론 작업을 수행할 수 있습니다.\n\n에이전트의 중요한 구성 요소는 시스템 프롬프트로, 에이전트의 전반적인 행동을 정의합니다(곧 예시를 볼 것입니다).\n\n처리 과정은 문제의 해결책을 요청하는 사용자 프롬프트로 시작됩니다. 시스템 프롬프트에 따라 에이전트는 문제에 대해 사고하고 해결에 도움이 되는 외부 도구를 적절하게 선택합니다.\n\n에이전트가 도구를 호출하고 응답을 받은 후, 더 많은 처리가 필요한지 판단합니다. 필요하다면 다시 도움을 요청할 수 있습니다. 에이전트는 문제를 해결하고 사용자에게 결과를 반환할 때까지 추론과 조치(도구 호출)를 반복합니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래 다이어그램에서 과정이 설명되어 있습니다.\n\n<img src=\"/assets/img/2024-07-01-HowtoBuildaReActAIAgentwithClaude35andPython_0.png\" />\n\nReAct 에이전트의 작동 방식을 설명하는 가장 쉬운 방법은 간단한 사례 연구로 설명하는 것입니다. 아래는 간단한 산술 문제를 해결하는 에이전트의 예시 응답입니다.\n\n우리는 \"20 * 15은 무엇인가요?\" 라는 질문으로 시작해서, 그에 대한 응답으로 에이전트가 '소리내어 생각'하기 시작합니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n에이전트의 응답 앞에는 '사고' 레이블이 있는데, 이는 에이전트가 어떻게 해야 하는지 고민합니다. 이 경우, 문제를 해결하기 위해 'calculate' 동작을 사용하기로 결정했습니다('calculate'는 에이전트에 제공된 도구입니다).\n\n다음 응답은 '동작' 레이블로 시작되며, 에이전트가 'calculate' 도구를 사용하여 답변을 검색하는 것을 볼 수 있습니다. 이 후에는 '관찰'이 나오는데, 이는 도구에서의 응답입니다.\n\n마지막 '답변'은 에이전트가 초기 질문과 'calculate' 도구의 출력으로부터 응답을 작성한 결과입니다.\n\n보통 이곳에서 특별하게 벌어지는 일은 없어 보이지만, 에이전트가 우리가 제공한 도구를 사용하고 있다는 점에서 조금은 특별한 점이 있습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그것이 ReAct 에이전트의 기본입니다: 에이전트는 이성을 사용하여 행동합니다.\n\n## 반복\n\n더 흥미로워지는 부분은 에이전트가 결론에 도달하지 못했다고 판단하고 다른 이성/행동 시퀀스를 거쳐야 한다는 경우입니다. 에이전트는 유효한 결론에 도달할 때까지 추론/행동 시퀀스를 반복할 수 있습니다.\n\n위의 예시는 사소하지만 기본적인 이벤트 시퀀스를 보여줍니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n좀 더 복잡한 쿼리를 시도해보면 실제 반복을 볼 수 있어요.\n\n저는 다음과 같은 질문을 에이전트에게 했어요: \"농구 팀의 선수 수를 라크로스 팀의 선수 수로 곱하면 얼마가 되나요?\".\n\n이 질문에 대한 답변을 하기 위해 에이전트는 각 스포츠의 선수 수를 찾아 곱해야 해요. 곱셈을 위해 calculate 도구를 사용할 수 있지만, 농구와 라크로스에 대해 알아내기 위해서는 다른 도구가 필요해요 — 위키피디아죠. 위키피디아 도구를 사용하면 에이전트가 어떤 것이든 검색하고 결과를 얻을 수 있어요.\n\n아래에서 에이전트가 만족스러운 답변을 도출하기 전에 생각-행동-관찰 순서를 세 번 거치는 방법을 볼 수 있어요.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만약 결과를 자세히 읽으시면 에이전트가 결과를 생성하기 전에 이유를 생각하고 도구를 상담하는 방법을 볼 수 있고, 그러면서 지식을 쌓아 가게 됩니다.\n\n# 매우 적은 양의 코드\n\nReAct 에이전트를 구현하는 데 필요한 코드는 놀랍게도 매우 적습니다. 이는 대부분의 작업이 프롬프트에서 수행되기 때문입니다.\n\n그러니까 먼저 그것을 살펴보죠.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n프롬프트는 문제에 어떻게 접근해야 하는지에 대해 설명하며, 이전에 본 과정의 레이블이 지정된 부분을 반복합니다.\n\n그런 다음 계산 및 위키피디아라는 작업이 설명되고, 예제 세션이 이어집니다.\n\n이 프롬프트는 간단한 예제이며 명확히 시연용으로만 사용됩니다. 프롬프트 설명은 도구의 사용이 하드코딩되어 있으며, 실제 제품 시스템에서는 프로그래밍 방식으로 이를 확장할 수 있어야 합니다. (곧 확인할 것이지만, calculate는 Python 함수 eval()을 사용하여 구현됩니다. 이는 코드 삽입 공격에 매우 취약한 부분이므로 매우 위험한 방법입니다.)\n\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 시점에서 Simon Willison의 작업을 인정해야 할 필요가 있습니다. 이 코드의 많은 부분은 Simon Willison의 작품에 기반합니다 — LLMs를 위한 ReAct 패턴의 간단한 Python 구현 참조 | Simon Willison의 TILs — 해당 코드는 Apache 2 라이선스가 있습니다.\n\n이 코드와 프롬프트의 기본 구조는 Simon의 것이지만, 저는 Anthropic의 Claude 3.5 Sonnet LLM을 사용하도록 수정하고 코드와 프롬프트를 간소화했습니다.\n\n## Claude 3.5\n\nClaude Sonnet 3.5은 Anthropic의 최근 릴리스로, 릴리스 발표에서 \"Claude 3.5 Sonnet은 인텔리전스에 대한 산업 기준을 높여 다양한 평가에서 경쟁 모델과 Claude 3 Opus보다 우월하며, 중급 모델인 Claude 3 Sonnet의 속도와 비용을 가지고 있습니다.\" 라고 설명합니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그것을 맥락에 맞춰 설명하자면, Anthrop have는 저렴하고 빠른 하이쿠 모델부터 똑똑하지만 더 비싼 오퍼스까지 세 가지 버전의 Claude LLM을 보유하고 있습니다. 소넷은 그 중간 모델로서 이 글을 작성하는 시점에 버전 3.5 릴리스가 있습니다.\n\n나는 어느 때부터 Claude를 살펴보고 싶어했었는데, 이런 좋은 기회였습니다.\n\n코드는 필요한 라이브러리를 불러오는 부분으로 시작됩니다:\n\n```js\nimport anthropic\nimport re\nimport httpx\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그 답변은 많지 않네요. LLM을 위한 추론, 정규 표현식 및 Wikipedia에 액세스할 수 있는 HTTP 라이브러리가 필요하겠네요.\n\n이 코드를 실행하려면 물론 Anthropic 계정이 필요하고 사용 요금이 부과될 거에요. 하지만 가격은 꽤 저렴하답니다: 클로드 3.5 소네는 이전 버전보다 더 강력해지면서 더 저렴해진 것 같아요 — 제가 여기서 코드를 여러 번 실행해 봤는데 수십 센트 정도만 청구받았어요.\n\n이 코드는 먼저 클라이언트를 만든 후 챗봇을 구현할 파이썬 클래스를 정의하는 방식으로 시작합니다. 오픈AI와는 달리, Claude는 시스템 프롬프트를 사용자나 어시스턴트의 것과 분리하여 ChatBot을 인스턴스화할 때 초기화합니다. `__call__` 함수는 사용자 메시지를 저장하고 챗봇의 응답을 처리하고 에이전트를 실행하는 `execute`를 호출하는 역할을 합니다.\n\n```python\nclient = anthropic.Anthropic(api_key=\"여기에 API 키를 입력하세요\")\n\nclass ChatBot:\n    def __init__(self, system=\"\"):\n        self.system = system\n        self.messages = []\n\n    def __call__(self, message):\n        self.messages.append({\"role\": \"user\", \"content\": message})\n        result = self.execute()\n        self.messages.append({\"role\": \"assistant\", \"content\": result})\n        return message\n\n    def execute(self):\n        message = client.messages.create(\n            model=\"claude-3-5-sonnet-20240620\",\n            max_tokens=1000,\n            temperature=0,\n            system=self.system,\n            messages=self.messages\n        )\n        return message.content\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음 단계는 챗봇의 인스턴스를 사용하는 query() 함수를 정의하는 것입니다. query 함수는 작업이 더 이상 없을 때까지 루프를 실행합니다(또는 최대 반복 횟수에 도달할 때까지). 이 함수는 작업을 감지하고 작업의 이름을 정규식을 사용하여 추출합니다. 작업이 호출된 후 더 이상 작업이 없는 경우, 챗봇 메시지가 반환됩니다.\n\n```js\naction_re = re.compile('^Action: (\\w+): (.*)$')\n\ndef query(question, max_turns=5):\n    i = 0\n    bot = ChatBot(prompt)\n    next_prompt = question\n    while i < max_turns:\n        i += 1\n        result = bot(next_prompt)\n        print(result)\n        actions = [action_re.match(a) for a in result.split('\\n') if action_re.match(a)]\n        if actions:\n            # 실행할 작업이 있습니다\n            action, action_input = actions[0].groups()\n            if action not in known_actions:\n                raise Exception(\"Unknown action: {}: {}\".format(action, action_input))\n            print(\" -- running {} {}\".format(action, action_input))\n            observation = known_actions[action](action_input)\n            print(\"Observation:\", observation)\n            next_prompt = \"Observation: {}\".format(observation)\n        else:\n            return bot.messages\n```\n\n이제 wikipedia 및 eval과 같은 작업 함수(도구)를 정의하고 해당 함수에 대한 참조를 사전에 저장해야 합니다.\n\n```js\ndef wikipedia(q):\n    return httpx.get(\"https://en.wikipedia.org/w/api.php\", params={\n        \"action\": \"query\",\n        \"list\": \"search\",\n        \"srsearch\": q,\n        \"format\": \"json\"\n    }).json()[\"query\"][\"search\"][0][\"snippet\"]\n\ndef calculate(what):\n    return eval(what)\n\nknown_actions = {\n    \"wikipedia\": wikipedia,\n    \"calculate\": calculate\n}\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음은 봇이 생성한 마지막 메시지를 출력하는 유틸리티 함수입니다.\n\n```js\ndef get_last_message():\n    for m in bot.messages[-1]['content'][0].text.split('\\n'):\n        print(m)\n```\n\n그리고 그 모든 것이 끝나면 에이전트를 사용할 수 있습니다.\n\n```js\nquery(\"What is 20 * 15\")\nget_last_message()\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 코드는 기사 맨 위에 본 매우 첫 번째 예제에 결과를 초래하며 아래의 코드는 ReAct 에이전트가 다양한 조치를 순환하여 유효한 결론에 도달하는 방식의 또 다른 예제를 보여줍니다.\n\n에이전트가 도구에 대한 호출을 순환해야 하는 또 다른 예제가 여기 있습니다. 이 경우, 에이전트는 위키피디아만 사용하지만 답변을 도출하기 위해 응담을 지능적으로 분석해야 합니다.\n\n```js\nquery(\"스페인에서 사용되는 언어 중 프랑스에서도 사용되는 언어는 무엇인가\")\nget_last_message()\n```\n\n위의 응답은 에이전트가 적절한 답변을 도출하기 위해 거치는 합리적인 과정을 보여줍니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저는 또한 에이전트가 잘 다루는 것으로 보이는 좀 더 복잡한 질문도 시도해 보았습니다 (다운로드 가능한 코드에 더 많은 예제를 볼 수 있습니다).\n\n## 결론\n\n여기 제시된 코드는 ReAct 에이전트가 작동하는 방식을 보여줍니다. 이 코드는 견고하지 않으며 제품용으로 적합하지 않습니다. 하지만 이제 ReAct 에이전트의 원리에 대해 어느 정도 이해하고 구현할 수 있다는 것을 바라겠습니다.\n\n더 복잡한 예제로 코드를 시도해보고, 아마도 더 많은 도구를 추가해 보세요. 여러분의 실험에 대해 알고 싶어합니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n물론, Langchain과 Llamaindex를 사용한 더 간단한 해결책도 있습니다(예:). 나는 아마도 미래에 이를 다룰 것 같습니다. 그러나 이들의 추상화된 구현은 에이전트의 내부 작업을 숨기는데, 저는 이 글과 Simon의 코드가 이를 명확히 만들었다고 기대합니다.\n\n모든 코드와 예제는 내 [Github 레포지토리](GitHub — alanjones2/claudeapps)에서 확인할 수 있습니다 — 자유롭게 다운로드하십시오.\n\n더 많은 기사를 보려면, 여기 Medium에서 나를 팔로우하시거나, 가끔씩 소식지를 구독해 주세요. 이전 기사들은 내 웹페이지에 나와 있습니다.\n\n# 노트와 참고 문헌\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- Shunyu Yao 등, ReAct: 언어 모델에서 추론과 행동을 시너지적으로 결합하기, The Eleventh International Conference on Learning Representations (ICLR), 2023. (https://arxiv.org/pdf/2210.03629에서 검색, 2024년 6월 27일에 접속)\n- Simon Willison의 블로그는 여기에 있습니다.\n- 모든 이미지와 삽화는 별도로 표시되지 않는 한 저자 본인이 만들었습니다.\n\n본 기사의 버전이 여기에 게시되어 있습니다.","ogImage":{"url":"/assets/img/2024-07-01-HowtoBuildaReActAIAgentwithClaude35andPython_0.png"},"coverImage":"/assets/img/2024-07-01-HowtoBuildaReActAIAgentwithClaude35andPython_0.png","tag":["Tech"],"readingTime":12},{"title":"2024 최신 PyTorch 치트 시트 ","description":"","date":"2024-07-01 16:07","slug":"2024-07-01-PyTorchCheatSheet","content":"\n\nPyTorch에 대해 알아야 할 모든 것을 배워보세요.\n\n![PyTorch Cheat Sheet](/assets/img/2024-07-01-PyTorchCheatSheet_0.png)\n\n야심차고 데이터 고수! 챗봇, 이미지 인식 소프트웨어, 심지어 자율 주행 자동차 같은 멋진 AI 작품을 만들고 싶나요? PyTorch를 찾아보세요!\n\nPyTorch는 Facebook의 AI 전문가들이 만든 슈퍼 멋진 오픈소스 라이브러리로, 기계 학습(ML)과 심층 학습(DL)에 손쉽게 뛰어들 수 있게 해줍니다. 이 치트 시트는 PyTorch의 기본을 모두 배울 수 있는 한 곳의 쇼핑처가 될 것이며, 금세 기계 학습 마에스트로가 될 수 있도록 도와줄 거에요! ✨\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# PyTorch 불러오기\n\n필요한 주요 라이브러리를 알려드리겠습니다:\n\n```js\n# 핵심 기능을 위한 최상위 패키지 불러오기\nimport torch\n\n# 신경망 기능 불러오기\nfrom torch import nn\n\n# 함수형 프로그래밍 도구 불러오기\nimport torch.nn.functional as F\n\n# 최적화 기능 불러오기\nimport torch.optim as optim\n\n# 데이터셋 함수 불러오기\nfrom torch.utils.data import TensorDataset, DataLoader\n\n# 평가 지표 불러오기\nimport torchmetrics\n```\n\n- import torch: 이게 본 프로그램이에요! PyTorch의 모든 중심 기능을 불러오는데요, 텐서(다차원 배열)를 구축하고 조작할 수 있습니다.\n- from torch import nn: 신경망 팬들 주목! 이 라이브러리를 사용하여 강력한 신경망을 만들 수 있는 기본 블록을 제공합니다.\n- import torch.nn.functional as F: 멋있게 만들고 싶나요? 이 라이브러리는 새로운 신경망 레이어를 만들기 위한 함수형 프로그래밍 도구를 제공하여 코드에 유연성을 더해줍니다.\n- import torch.optim as optim: 신경망을 훈련하는 것은 강아지를 훈련하는 것과 비슷해요 - 어떤 최적화가 필요해요! 이 라이브러리는 다양한 옵티마이저를 제공하여 신경망이 효율적으로 학습할 수 있도록 도와줍니다.\n- import torch.utils.data as data: 머신러닝에서 데이터는 중요해요! 이 라이브러리는 데이터셋을 효율적으로 관리하는 도구를 제공하여 훈련을 쉽게 만들어줍니다.\n- import torchmetrics: 모델이 얼마나 잘 수행되는지 잘 모르겠다구요? 이 라이브러리는 네트워크의 정확성과 효율성을 평가하는 메트릭 도구상자를 제공합니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# Tensor 사용하기\n\n텐서는 PyTorch에서 기본적인 구성 요소로, AI 프로젝트용 레고 블록과 비슷한 역할을 합니다! 여기에서는 텐서를 만들고 조작하는 방법을 알아보겠습니다:\n\n```js\n# 리스트에서 tensor를 사용하여 텐서 생성\ntnsr = torch.tensor([1, 3, 6, 10])\n\n# 텐서 요소의 데이터 유형 가져오기: .dtype\ntnsr.dtype # torch.int64가 반환됩니다.\n\n# 텐서의 차원 가져오기: .size()\ntnsr.shape # torch.Size([4])가 반환됩니다.\n\n# 텐서의 메모리 위치 가져오기: .device\ntnsr.device # cpu 또는 gpu가 반환됩니다.\n\n# 모든 요소가 0인 텐서 만들기: zeros()\ntnsr_zrs = torch.zeros(2, 3)\n\n# 무작위 텐서 만들기: rand()\ntnsr_rndm = torch.rand(size=(3, 4)) # 텐서는 3행 4열입니다.\n```\n\n# 데이터셋과 데이터로더\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n기계 학습에서 데이터는 왕이에요! 그런데 데이터를 모델에 효율적으로 전달하는 것은 다루기 어려운 일일 수 있어요. 그럴 때 데이터셋과 데이터로더가 등장합니다. 믿을 수 있는 드래곤처럼 당신을 지켜줄 거예요.\n\n- 데이터셋 구축: 데이터셋은 깔끔하게 구성된 귀하의 훈련 데이터 모음으로 상상해보세요. 데이터가 판다스 DataFrame에 저장된 경우, TensorDataset()을 사용하여 데이터셋을 만들 수 있어요. 이 함수는 두 개의 인수를 취합니다:\n\n  - torch.tensor()를 사용하여 부동 소수점 숫자의 텐서로 변환된 특성(독립 변수).\n  - 부동 소수점 텐서로 변환된 목표(종속 변수).\n\n```js\n# TensorDataset()을 사용하여 판다스 DataFrame에서 데이터셋 만들기\nX = df[feature_columns].values\ny = df[target_column].values\ndataset = TensorDataset(torch.tensor(X).float(), torch.tensor(y).float())\n\n# DataLoader()를 사용하여 데이터를 배치로 로드하기\ndataloader = DataLoader(dataset, batch_size=n, shuffle=True)\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 전처리\n\n신경망에 데이터를 입력하기 전에 몇 가지 준비작업이 필요합니다! 이를 전처리라고 합니다. PyTorch의 카테고리 변수(텍스트 레이블과 같은)를 다루기 위한 멋진 기능이 있습니다:\n\nF.one_hot()을 사용한 원-핫 인코딩\n\n“빨강,” “초록,” “파랑”과 같은 카테고리를 가진 데이터가 있다고 상상해보세요. 컴퓨터는 이러한 단어들을 처리하기 어려울 수 있습니다. 원-핫 인코딩은 이러한 카테고리를 특별한 종류의 텐서로 변환하는 트릭입니다. 이 텐서에는 각 가능한 카테고리에 대해 한 열이 있을 것입니다(이 경우 \"빨강,\" \"초록,\" \"파랑\"). 각 데이터 포인트에 대해, 해당 카테고리에 해당하는 열에 1이 있고, 나머지는 모두 0입니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음은 PyTorch에서 F.one_hot()을 사용하는 방법입니다:\n\n```js\n# One-hot encode categorical variables with one_hot()\nF.one_hot(torch.tensor([0, 1, 2]), num_classes=3) # 0과 1로 구성된 텐서 반환\n```\n\n# Sequential Model Architecture\n\n이제 신경망 아키텍처를 구성해 봅시다! PyTorch의 nn.Sequential 클래스를 사용하면 레이어를 스택하는 것이 매우 쉬워집니다. 아래에서 설명하겠습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n선형 레이어: 네트워크의 주역! nn.Linear(m, n)을 사용하여 m개의 입력을 받고 n개의 출력을 생성하는 선형 레이어를 만들 수 있어요. 입력값을 가중치와 곱하고 편향을 더한 것으로 생각하면 돼요.\n\n가중치와 편향 엿보기: 선형 레이어의 내부 동작에 궁금해하는가요? .weight를 사용하여 가중치 행렬에 접근하고 .bias로 편향 벡터를 확인할 수 있어요. 이들은 훈련 중에 업데이트되는 내용이에요!\n\n활성화 함수: 네트워크에 복잡성을 더하는 비선형 히어로들이에요. 여기 인기 있는 몇 가지 선택사항이 있어요:\n\n- nn.Sigmoid(): 0과 1 사이의 값을 압축하는 함수로 이진 분류(일대다)에 자주 사용돼요.\n- nn.Softmax(dim=-1): 출력값을 합이 1이 되도록 확률로 변환시켜주는 함수로 다중 클래스 분류(다대다)에 이상적이에요.\n- nn.ReLU(): 음수 값을 0으로 설정하는 ReLU(Rectified Linear Unit). 소멸 그래디언트를 방지하는 데 도움이 돼요.\n- nn.LeakyReLU(negative_slope=0.05): ReLU와 유사하지만 0이 아닌 그래디언트를 위한 작은 양수 기울기를 허용하는 함수에요.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nDropout 레이어: 모델이 훈련 데이터를 너무 잘 기억할 때 발생하는 오버피팅을 nn.Dropout(p=0.5)로 극복하세요. 이는 훈련 중에 일정 비율의 활성화를 무작위로 제거하여 네트워크가 특정 기능에 너무 의존하지 않도록 유도합니다.\n\n모델 구축: 원하는 순서대로 레이어를 nn.Sequential로 연결해보세요. 각 레이어의 입력 크기는 이전 레이어의 출력 크기와 일치해야 합니다! 예를 들면 다음과 같습니다.\n\n```js\n# Linear()을 사용하여 입력이 m이고 출력이 n인 선형 레이어를 만듭니다.\nlnr = nn.Linear(m, n)\n\n# .weight로 레이어의 가중치를 가져옵니다\nlnr.weight\n\n# .bias로 레이어의 편향을 가져옵니다\nlnr.bias\n\n# Sigmoid()를 사용하여 이진 분류를 위한 시그모이드 활성화 레이어 생성\nnn.Sigmoid()\n\n# Softmax()를 사용하여 다중 클래스 분류를 위한 소프트맥스 활성화 레이어 생성\nnn.Softmax(dim=-1)\n\n# ReLU()를 사용하여 포화를 피하기 위한 계단식 활성화 레이어 생성\nnn.ReLU()\n\n# LeakyReLU()를 사용하여 포화를 피하기 위한 릭리 레키 크기를 설정\nnn.LeakyReLU(negative_slope=0.05)\n\n# Dropout()을 사용하여 규제하고 오버피팅을 방지하는 드롭아웃 레이어 생성\nnn.Dropout(p=0.5)\n\n# 레이어를 순차적으로 연결하여 모델 생성\nmodel = nn.Sequential(\n    nn.Linear(n_features, i),\n    nn.Linear(i, j),   # 입력 크기는 이전 레이어의 출력과 일치해야 합니다\n    nn.Linear(j, n_classes),\n    nn.Softmax(dim=-1) # 활성화 레이어가 마지막에 옵니다\n)\n```\n\n# 모델 훈련 및 손실 계산\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 데이터를 준비했고 모델을 구축했으니, 모델 훈련을 시작해봅시다!\n\n```js\n# 입력 데이터에 모델을 피팅하고 모델은 Sequential()을 통해 생성된 변수입니다.\nprediction = model(input_data).double()\n\n# 타겟 값들을 얻습니다.\nactual = torch.tensor(target_values).double()\n\n# 평균 제곱 오차 손실을 계산합니다. 회귀에는 MSELoss()를 사용합니다.\nmse_loss = nn.MSELoss()(prediction, actual) # 텐서(x)를 반환합니다.\n\n# 강건한 회귀를 위한 L1 손실을 계산합니다. SmoothL1Loss()를 사용합니다.\nl1_loss = nn.SmoothL1Loss()(prediction, actual) # 텐서(x)를 반환합니다.\n\n# 이진 분류를 위한 바이너리 크로스 엔트로피 손실을 계산합니다. BCELoss()를 사용합니다.\nbce_loss = nn.BCELoss()(prediction, actual) # 텐서(x)를 반환합니다.\n\n# 다중 클래스 분류를 위한 크로스 엔트로피 손실을 계산합니다. CrossEntropyLoss()를 사용합니다.\nce_loss = nn.CrossEntropyLoss()(prediction, actual) # 텐서(x)를 반환합니다.\n\n# .backward()를 사용하여 역전파로 기울기를 계산합니다.\nloss.backward()\n```\n\n# 옵티마이저 사용하기\n\n신경망을 훈련하는 것은 운동 선수를 훈련하는 것과 비슷합니다. 올바른 도구와 기술이 필요합니다! 이때 옵티마이저가 필요합니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n# SGD() 함수를 사용하여 확률적 경사 하강 옵티마이저를 생성하고 학습률 및 모멘텀 설정\noptimizer = optim.SGD(model.parameters(), lr=0.01, momentum=0.95)\n\n# .step()을 사용하여 뉴런 매개변수 업데이트\noptimizer.step()\n```\n\n파이토치에서는 optim 모듈을 사용하여 서로 다른 옵티마이저를 생성하여 신경망의 가중치와 편향을 조정하는 방법을 각각 지정할 수 있습니다. 이번에는 확률적 경사 하강 (SGD)라는 일반적인 옵티마이저를 사용하는 방법을 알아보겠습니다:\n\n- 옵티마이저 생성: optim.SGD()를 사용하여 SGD 옵티마이저를 생성합니다. 다음 두 가지 중요한 인수를 전달합니다:\n\n    - model.parameters(): 이를 통해 옵티마이저에게 모델에서 업데이트해야 할 매개변수(가중치와 편향)를 알려줍니다.\n    - lr=0.01: 이는 학습률로, 옵티마이저가 각 단계에서 매개변수를 얼마나 조정할지를 제어합니다. 작은 학습률은 조심스러운 업데이트를 유도하고, 큰 학습률은 학습 속도를 빠르게 할 수 있지만 (또한 잠재적으로 불안정성을 유발할 수 있음) 빠른 학습을 할 수 있습니다.\n\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 훈련 루프\n\n```js\n# 모델을 훈련 모드로 설정합니다.\nmodel.train()\n# 손실 기준 및 옵티마이저 설정\nloss_criterion = nn.MSELoss()\noptimizer = optim.SGD(model.parameters(), lr=0.01, momentum=0.95)\n# 훈련 세트의 데이터 청크를 반복합니다.\nfor data in dataloader:\n    # 그라디언트를 0으로 설정합니다.\n    optimizer.zero_grad()\n    # 현재 데이터 청크의 특징과 타깃을 가져옵니다.\n    features, targets = data\n    # \"순방향 패스\"를 실행하여 모델을 데이터에 맞춥니다.\n    predictions = model(data)\n    # 손실 계산\n    loss = loss_criterion(predictions, targets)\n    # 역전파를 사용하여 그래디언트 계산\n    loss.backward()\n    # 모델 매개변수 업데이트\n    optimizer.step()\n```\n\n# 평가 루프\n\n굉장한 PyTorch 모델을 훈련한 후, 이제 얼마나 잘 수행되는지 확인해보세요!\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n# 모델을 평가 모드로 설정\nmodel.eval()\n\n# 정확도 메트릭 생성\nmetric = torchmetrics.Accuracy(task=\"multiclass\", num_classes=3)\n# 검증 세트에서 데이터 청크 루프\nfor i, data in enumerate(dataloader, 0):\n    # 현재 데이터 청크의 특징과 타겟 가져오기\n    features, targets = data\n    # 모델을 데이터에 맞추기 위해 \"포워드 패스\" 실행\n    predictions = model(data)\n    # 배치의 정확도 계산\n    accuracy = metric(output, predictions.argmax(dim=-1))\n# 전체 검증 데이터에 대한 정확도 계산\naccuracy = metric.compute()\nprint(f\"All 데이터에 대한 정확도: {accuracy}\")\n# 다음 데이터셋(학습 또는 검증)을 위해 메트릭 재설정\nmetric.reset()\r\n```\n\n# 전이 학습과 파인튜닝\n\n머신 러닝에서 사전 훈련된 모델을 활용하여 우리 자신의 프로젝트를 빠르게 시작할 수 있습니다. 이를 전이 학습이라고하며, 그 내에서 파인튜닝은 강력한 기술입니다. PyTorch가 여러분을 돕는 방법을 살펴보겠습니다:\n\n나중을 위한 레이어 저장: 모델의 특정 레이어를 훈련시키고 나중에 다시 사용하고 싶다면, torch.save()를 사용하여 레이어의 가중치와 편향을 파일로 직렬화할 수 있습니다. 이는 미래 AI 프로젝트를 위한 청사진을 저장하는 것으로 생각할 수 있습니다!\n\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\ntorch.save(layer, 'layer.pth')  # 'layer.pth' 파일에 레이어를 저장합니다.\n```\n\n저장된 레이어 불러오기: 이전에 저장한 레이어를 가져와야 하는 경우가 있습니다. torch.load()를 사용하여 다시 불러올 수 있습니다! 새 모델에 사전 훈련된 레이어를 통합하는 데 유용합니다.\n\n```js\nnew_layer = torch.load('layer.pth')  # 'layer.pth' 파일에서 레이어를 불러옵니다.\n```\n\n동결된 파워로 파인튜닝! 예를 들어, 사전 훈련된 모델이 있고 특정 작업을 위해 최종 레이어만 파인튜닝하려는 경우가 있습니다. PyTorch를 사용하면 .requires_grad = False를 사용하여 이전 레이어의 가중치를 동결시킬 수 있습니다. 이렇게 하면 훈련 중에 업데이트되지 않고 마지막 레이어에 중점을 두고 학습 프로세스를 진행할 수 있습니다.\n\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\nfor name, param in model.named_parameters():\n    if name == \"0.weight\":\n        param.requires_grad = False  # 필요에 따라 레이어 번호를 조정하여 레이어 0의 가중치를 고정시킵니다.\n\n# 이제 최종 레이어만 업데이트되도록 모델을 학습할 수 있습니다!\n```\n\n전이 학습과 파인 튜닝을 마스터하면, 사전 학습된 지식을 활용하여 학습 시간을 단축시키고, 여러분을 머신러닝 효율성 챔피언으로 만들 수 있습니다!\n\n읽어 주셔서 감사합니다. 내 컨텐츠가 마음에 드시고 저를 지원하고 싶다면, Patreon에서 저를 지원하는 것이 가장 좋은 방법입니다 —\n\n<img src=\"/assets/img/2024-07-01-PyTorchCheatSheet_1.png\" />\n\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 내 YouTube 채널 구독하기.\r\n- 내 웹사이트 방문하기.\r\n- LinkedIn과 Github에서 나와 연락하기! 나는 거기에서 무료로 놀라운 콘텐츠를 공유하고, 기술과 AI를 활용하여 더 생산적이고 효과적으로 일할 수 있도록 돕습니다.\r\n- 머신러닝 및 딥러닝 도움이 필요하신가요? 내 Fiverr 및 Upwork 서비스를 확인해보세요!","ogImage":{"url":"/assets/img/2024-07-01-PyTorchCheatSheet_0.png"},"coverImage":"/assets/img/2024-07-01-PyTorchCheatSheet_0.png","tag":["Tech"],"readingTime":13},{"title":"Python weakref 모듈을 사용한 약한 참조 가이드","description":"","date":"2024-07-01 16:06","slug":"2024-07-01-AGuidetoPythonsWeakReferencesUsingtheweakrefModule","content":"\n\n\n<img src=\"/assets/img/2024-07-01-AGuidetoPythonsWeakReferencesUsingtheweakrefModule_0.png\" />\n\n아마 당신은 파이썬의 weakref 모듈에 대해 들어본 적이 없을 것입니다. 여러분의 코드에서 자주 사용되지는 않지만, 많은 라이브러리, 프레임워크 및 심지어 파이썬 자체의 내부 작업에 기본적입니다. 그래서, 이 글에서는 weakref 모듈이 무엇인지, 어떻게 유용한지, 그리고 여러분의 코드에 어떻게 통합할 수 있는지 살펴보겠습니다.\n\n# 기본 사항\n\nweakref 모듈과 약한 참조를 이해하기 위해 먼저 파이썬에서 가비지 컬렉션에 대해 간단히 소개해야 합니다.\n\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n파이썬은 쓰레기 수집을 위한 메커니즘으로 참조 카운팅을 사용합니다. 간단히 말해, 파이썬은 우리가 생성한 각 객체에 대한 참조 카운트를 유지하며, 코드에서 객체가 참조될 때마다 참조 카운트가 증가하고, 객체가 해제될 때(e.g. 변수가 None으로 설정될 때) 감소합니다. 참조 카운트가 0이 되면, 해당 객체의 메모리가 할당 해제(가비지 수집)됩니다.\n\n조금 더 이해하기 쉽도록 코드를 살펴봅시다:\n\n```js\nimport sys\n\nclass SomeObject:\n    def __del__(self):\n        print(f\"(Deleting {self=})\")\n\nobj = SomeObject()\n\nprint(sys.getrefcount(obj))  # 2\n\nobj2 = obj\nprint(sys.getrefcount(obj))  # 3\n\nobj = None\nobj2 = None\n\n# (Deleting self=<__main__.SomeObject object at 0x7d303fee7e80>)\n```\n\n여기서는 __del__ 메서드만 구현한 클래스를 정의하는데, 이 메서드는 객체가 가비지 수집될 때 호출되며, 가비지 수집이 발생했을 때를 확인할 수 있도록 합니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 클래스의 인스턴스를 만든 후에는 sys.getrefcount를 사용하여이 객체에 대한 현재 참조 수를 가져옵니다. 여기에서는 1을 기대하지만 getrefcount가 반환하는 카운트는 일반적으로 예상보다 한 단계 높습니다. getrefcount를 호출하면 참조가 함수의 인수로 값에 의해 복사되어 객체의 참조 수가 일시적으로 증가하기 때문입니다.\n\n다음으로, obj2 = obj를 선언하고 다시 getrefcount를 호출하면 이제 obj와 obj2 둘 다에 의해 참조되기 때문에 3을 얻습니다. 반대로, 이러한 변수에 None을 할당하면 참조 수가 0으로 감소하고, 마침내 객체가 가비지 수집되었다는 __del__ 메서드에서 메시지를 받게 됩니다.\n\n자, 그럼 약한 참조는 어떻게 여기에 맞는 것인가요? 객체에 대한 유일한 남은 참조가 약한 참조인 경우, Python 인터프리터는 이 객체를 가비지 수집할 수 있습니다. 다른 말로하면 — 객체에 대한 약한 참조만으로는 객체를 살리는 데 충분하지 않습니다:\n\n```js\nimport weakref\n\nobj = SomeObject()\n\nreference = weakref.ref(obj)\n\nprint(reference)  # <weakref at 0x734b0a514590; to 'SomeObject' at 0x734b0a4e7700>\nprint(reference())  # <__main__.SomeObject object at 0x707038c0b700>\nprint(obj.__weakref__)  # <weakref at 0x734b0a514590; to 'SomeObject' at 0x734b0a4e7700>\n\nprint(sys.getrefcount(obj))  # 2\n\nobj = None\n\n# (Deleting self=<__main__.SomeObject object at 0x70744d42b700>)\n\nprint(reference)  # <weakref at 0x7988e2d70590; dead>\nprint(reference())  # None\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리는 다시 클래스의 obj 변수를 선언합니다. 이번에는 이 객체에 대한 두 번째 강력한 참조 대신에 참조 변수에 약한 참조를 만듭니다.\n\n그런 다음 참조 카운트를 확인하면 증가하지 않음을 알 수 있고, obj 변수를 None으로 설정하면 약한 참조가 여전히 남아 있음에도 즉시 쓰레기 수집됨을 확인할 수 있습니다.\n\n마지막으로 이미 쓰레기로 처리된 객체에 대한 약한 참조에 액세스하려고 하면 “무효한” 참조 및 None이 반환됩니다.\n\n또한 객체에 액세스하기 위해 약한 참조를 사용할 때 함수로 호출해야 했음을 주목하십시오(reference()). 따라서 객체 속성에 액세스해야 하는 경우 특히 프록시를 사용하는 것이 훨씬 편리합니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nobj = SomeObject()\n\nreference = weakref.proxy(obj)\n\nprint(reference)  # <__main__.SomeObject object at 0x78a420e6b700>\n\nobj.attr = 1\nprint(reference.attr)  # 1\n```\n\n# 사용 시기\n\n이제 약한 참조가 어떻게 작동하는지 알았으니, 어떻게 유용할 수 있는지 몇 가지 예시를 살펴보겠습니다.\n\n약한 참조의 일반적인 사용 사례 중 하나는 트리와 같은 데이터 구조입니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\nclass Node:\r\n    def __init__(self, value):\r\n        self.value = value\r\n        self._parent = None\r\n        self.children = []\r\n\r\n    def __repr__(self):\r\n        return \"Node({!r:})\".format(self.value)\r\n\r\n    @property\r\n    def parent(self):\r\n        return self._parent if self._parent is None else self._parent()\r\n\r\n    @parent.setter\r\n    def parent(self, node):\r\n        self._parent = weakref.ref(node)\r\n\r\n    def add_child(self, child):\r\n        self.children.append(child)\r\n        child.parent = self\r\n\r\nroot = Node(\"parent\")\r\nn = Node(\"child\")\r\nroot.add_child(n)\r\nprint(n.parent)  # Node('parent')\r\n\r\ndel root\r\nprint(n.parent)  # None\r\n\n\r\n여기서는 약한 참조를 사용하여 자식 노드들이 부모 노드를 가리키는 Node 클래스를 통해 트리를 구현했습니다. 이 관계에서 자식 Node는 부모 Node 없이 살 수 있어 부모가 소리 없이 제거되거나 가비지 수집될 수 있게 합니다.\r\n\r\n또 다른 방법으로 이를 구현해보겠습니다:\r\n\r\n\nclass Node:\r\n    def __init__(self, value):\r\n        self.value = value\r\n        self._children = weakref.WeakValueDictionary()\r\n\r\n    @property\r\n    def children(self):\r\n        return list(self._children.items())\r\n\r\n    def add_child(self, key, child):\r\n        self._children[key] = child\r\n\r\nroot = Node(\"parent\")\r\nn1 = Node(\"child one\")\r\nn2 = Node(\"child two\")\r\nroot.add_child(\"n1\", n1)\r\nroot.add_child(\"n2\", n2)\r\nprint(root.children)  # [('n1', Node('child one')), ('n2', Node('child two'))]\r\n\r\ndel n1\r\nprint(root.children)  # [('n2', Node('child two'))]\r\n\n\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여기서 부모는 자식들을 약한 참조를 갖고 있습니다. 이는 WeakValueDictionary를 사용합니다. 사전에서 참조된 요소(약한 참조)가 프로그램의 다른 곳에서 참조를 제거하면, 자동으로 사전에서도 제거됩니다. 따라서 사전 항목의 수명주기를 관리할 필요가 없습니다.\n\nweakref의 또 다른 사용 예는 Observer 디자인 패턴에 있습니다:\n\n```js\nclass Observable:\n    def __init__(self):\n        self._observers = weakref.WeakSet()\n\n    def register_observer(self, obs):\n        self._observers.add(obs)\n\n    def notify_observers(self, *args, **kwargs):\n        for obs in self._observers:\n            obs.notify(self, *args, **kwargs)\n\n\nclass Observer:\n    def __init__(self, observable):\n        observable.register_observer(self)\n\n    def notify(self, observable, *args, **kwargs):\n        print(\"Got\", args, kwargs, \"From\", observable)\n\nsubject = Observable()\nobserver = Observer(subject)\nsubject.notify_observers(\"test\", kw=\"python\")\n# Got ('test',) {'kw': 'python'} From <__main__.Observable object at 0x757957b892d0>\n```\n\nObservable 클래스는 옵저버에 대한 약한 참조를 유지합니다. 이는 그들이 제거되었는지 여부를 신경쓰지 않기 때문입니다. 이전 예제와 마찬가지로, 이를 통해 종속 객체의 수명주기를 관리할 필요가 없습니다. 아마도 주목했을 것이지만, 이 예제에서는 WeakSet을 사용했습니다. 이는 WeakValueDictionary와 비슷하지만 Set을 사용하여 구현되었습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 섹션의 최종 예제는 weakref 문서에서 빌려왔습니다:\n\n```js\nimport tempfile, shutil\nfrom pathlib import Path\n\nclass TempDir:\n    def __init__(self):\n        self.name = tempfile.mkdtemp()\n        self._finalizer = weakref.finalize(self, shutil.rmtree, self.name)\n\n    def __repr__(self):\n        return \"TempDir({!r:})\".format(self.name)\n\n    def remove(self):\n        self._finalizer()\n\n    @property\n    def removed(self):\n        return not self._finalizer.alive\n\ntmp = TempDir()\nprint(tmp)  # TempDir('/tmp/tmp8o0aecl3')\nprint(tmp.removed)  # False\nprint(Path(tmp.name).is_dir()) # True\n```\n\n이를 통해 weakref 모듈의 또 다른 기능을 확인할 수 있습니다. 바로 weakref.finalize입니다. 이름에서 암시하는 바대로 종속 객체가 가비지 수집될 때 최종화 함수/콜백을 실행할 수 있습니다. 이 예제에서는 가비지 수집될 때 TempDir 객체에 대해 rmtree를 자동으로 실행할 최종화가 실행됩니다. 프로그램이 완전히 종료될 때를 포함하여 TempDir이 가비지 수집될 때 실행되는 finalizer를 통해 TempDir를 정리하기를 항상 기억해야하지만 잊어버릴 경우에 대비할 수 있습니다.\n\n# 실제 예제\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n앞서 섹션에서 weakref의 실용적인 사용 예를 보여드렸지만, 실세계 예제도 함께 살펴보겠습니다. 그 중 하나는 캐시된 인스턴스를 생성하는 것입니다:\n\n```js\nimport logging\na = logging.getLogger(\"first\")\nb = logging.getLogger(\"second\")\nprint(a is b)  # False\n\nc = logging.getLogger(\"first\")\nprint(a is c)  # True\n```\n\n위의 코드는 Python의 내장 logging 모듈의 기본적인 사용법입니다. 우리는 특정 이름에 하나의 로거 인스턴스만 관련시킬 수 있음을 알 수 있습니다. 즉, 동일한 로거를 여러 번 검색해도 항상 동일한 캐시된 로거 인스턴스가 반환됩니다.\n\n만약 이를 구현하고 싶다면, 다음과 같이 할 수 있습니다:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\nclass Logger:\n    def __init__(self, name):\n        self.name = name\n\n_logger_cache = weakref.WeakValueDictionary()\n\ndef get_logger(name):\n    if name not in _logger_cache:\n        l = Logger(name)\n        _logger_cache[name] = l\n    else:\n        l = _logger_cache[name]\n    return l\n\na = get_logger(\"first\")\nb = get_logger(\"second\")\nprint(a is b)  # False\n\nc = get_logger(\"first\")\nprint(a is c)  # True\n```\n\n마지막으로, Python 자체도 약한 참조를 사용합니다. OrderedDict의 구현 예시를 보겠습니다:\n\n```python\nfrom _weakref import proxy as _proxy\n\nclass OrderedDict(dict):\n\n    def __new__(cls, /, *args, **kwds):\n        self = dict.__new__(cls)\n        self.__hardroot = _Link()\n        self.__root = root = _proxy(self.__hardroot)\n        root.prev = root.next = root\n        self.__map = {}\n        return self\n```\n\n위는 CPython의 collections 모듈에서의 일부 코드입니다. 여기서 weakref.proxy가 순환 참조를 막는 데 사용된다는 점을 유의하십시오 (더 많은 세부 정보는 doc-strings를 참조하세요).\n\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 결론\n\nweakref는 꽤 낯설지만 때때로 매우 유용한 도구로 여러분의 도구상자에 넣어두어야 할 가치가 있습니다. 이는 캐시를 구현하거나 이중 연결 리스트와 같이 서로 참조하는 데이터 구조를 다룰 때 매우 도움이 될 수 있습니다.\n\n그렇지만 여기서 말한 모든 것과 문서에서 언급된 사항은 CPython에 특화되어 있으며 다른 Python 구현체에서는 weakref 동작이 다를 수 있음을 인식해야 합니다. 또한 리스트, 튜플 또는 정수와 같은 많은 내장 타입이 약한 참조를 지원하지 않는다는 사실을 알아두어야 합니다.\n\n본 문서는 원문이 [martinheinz.dev](https://martinheinz.dev)에 게시되었습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음 항목을 추천해 드려요...","ogImage":{"url":"/assets/img/2024-07-01-AGuidetoPythonsWeakReferencesUsingtheweakrefModule_0.png"},"coverImage":"/assets/img/2024-07-01-AGuidetoPythonsWeakReferencesUsingtheweakrefModule_0.png","tag":["Tech"],"readingTime":11}],"page":"3","totalPageCount":120,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true}