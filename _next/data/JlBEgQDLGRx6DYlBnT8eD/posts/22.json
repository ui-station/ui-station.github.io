{"pageProps":{"posts":[{"title":"2024년 최신 가이드 Rails 프로젝트에 Swagger UI 설정하는 방법","description":"","date":"2024-06-23 20:47","slug":"2024-06-23-HowtoSetUpSwaggerUIforRailsProject2024Edition","content":"\n![이미지](/assets/img/2024-06-23-HowtoSetUpSwaggerUIforRailsProject2024Edition_0.png)\n\n명확하고 상호작용이 가능한 API 문서 작성은 유지보수 가능하고 접근성 있는 웹 서비스를 개발하는 중요한 부분입니다. Swagger UI는 개발자를 위한 동적 문서 인터페이스로서, Ruby on Rails 프로젝트에 통합하면 개발자 경험을 크게 향상시킬 수 있습니다. 이 글에서는 Grape API를 위한 인기 있는 gem인 grape-swagger와 RSpec API 문서 작성을 위한 gem인 rswag를 사용하여 Swagger UI를 설정하는 과정을 자세히 설명합니다.\n\n---\n\n# 해결책 1: 일반적인 Rails 프로젝트용\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nCordyline은 Progressive Documentation 아이디어를 가진 새로운 프로젝트에요.\n\n## 단계 1: Cordyline 설치\n\nCordyline 공식 웹사이트를 방문해서 미리 만들어진 gem 앱을 다운로드하세요.\n\n## 단계 2: 통합\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n루비 온 레일즈 프로젝트를 선택하고 번들 설치를 실행해주세요.\n\n(base) 컨트롤러에 도우미 모듈을 추가해주세요.\n\n```js\nclass ApplicationController < ActionController::API\n include Cordyline::DocGen\nend\n```\n\n## 단계 3: 첫 번째 문서 작성\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n컨트롤러의 모든 동작에서는 docto 메서드를 사용하여 문서 주석을 작성하세요.\n\n```js\nclass WelcomeController\n  doc \"인사 엔드포인트, 아무 동작 없음\" do\n    detail \"일부 세부 정보\"\n  end\n\n  def index\n  end\nend\n```\n\n## 단계 4: Swagger 문서 호스팅\n\n아래 라인을 routes.rb 파일에 추가하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```ruby\nrequire 'cordyline/web'\n\nTestApp::Application.routes.draw do\n  mount Cordyline::Web => '/team_doc' # 또는 다른 경로\nend\n```\n\n이제 팀은 배포된 웹사이트에서 /team_doc/index.html 경로로 Swagger 문서에 액세스할 수 있습니다.\n\n# 해결책 2: Grape API에 대한 설명\n\nGrape는 루비용 REST와 유사한 API 마이크로 프레임워크로, Rack에서 실행하거나 Rails와 같은 기존 웹 애플리케이션 프레임워크와 함께 사용할 수 있도록 설계되었습니다. Grape-swagger는 Grape API에 대한 자동 생성된 문서를 제공합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 단계 1: grape-swagger 설치하기\n\nGemfile에 grape-swagger를 추가하고 프로젝트에 추가하려면 번들 설치를 실행하세요:\n\n```js\ngem 'grape-swagger'\n```\n\n그리고 실행하세요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n번들 설치\n```\n\n## 단계 2: grape-swagger 구성\n\ngrape-swagger를 위한 초기 설정을 해보세요:\n\n```js\n# config/initializers/swagger.rb\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nif defined?(Grape)\n  GrapeSwaggerRails.options.url      = \"/api/swagger_doc\"\n  GrapeSwaggerRails.options.app_name = \"MyApp\"\n  GrapeSwaggerRails.options.app_url  = \"/\"\nend\n```\n\n## 단계 3: API 엔티티 및 문서 정의\n\ngrape-swagger가 문서화할 수 있도록 API 엔티티를 정의해야 합니다:\n\n```js\n# app/api/entities/my_entity.rb\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n모듈 API\n  모듈 엔티티\n    클래스 MyEntity < Grape::Entity\n      expose :id, documentation: { type: 'Integer', desc: '엔티티의 ID' }\n      # ... 추가 코드 ...\n    end\n  end\nend\n```\n\n## 단계 4: 스웨거 엔드포인트 추가\n\nAPI 베이스 클래스에서 스웨거 설명 라우트를 추가하여 스웨거 JSON을 제공할 수 있도록 합니다:\n\n```js\n# app/api/base.rb\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```ruby\nclass API::Base < Grape::API\n  add_swagger_documentation\nend\n```\n\n## 단계 5: Swagger 문서 보기\n\n이제 http://localhost:3000/swagger로 이동하여 Swagger UI에 액세스할 수 있습니다.\n\n# 해결 방법 3: RSpec 사용하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nrswag은 API 테스트에 기반하여 자동으로 Swagger 호환 API 문서를 생성하는 데 RSpec과 통합됩니다.\n\n## 단계 1: rswag-specs 설치\n\nGemfile에 rswag-specs를 추가하고 설치하세요:\n\n```js\ngem 'rswag-specs'\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그리고 다음을 실행해 주세요:\n\n```js\nbundle install\n```\n\n## 단계 2: 구성 및 파일 생성\n\nRSwag 생성기를 실행하여 API 사양을 위한 초기 구성 및 디렉터리를 생성하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nrails g rswag:install\n```\n\n## 단계 3: Swagger DSL을 사용하여 요청 스펙 작성하기\n\n스펙 파일을 생성하고 RSwag의 DSL을 사용하여 엔드포인트를 테스트하고 문서화하세요:\n\n```js\n# spec/integration/my_api_spec.rb\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```ruby\nrequire 'swagger_helper'\ndescribe 'My API' do\n  path '/my_api/endpoint' do\n    ...\n    get 'Retrieves something' do\n      produces 'application/json'\n      response '200', 'successful' do\n        schema type: :object,\n               properties: {\n                 id: { type: :integer }\n               },\n               required: ['id']\n        # Your test code goes here\n      end\n    end\n  end\nend\n```\n\n## 단계 4: RSwag UI로 API 문서에 액세스하기\n\nRSwag는 http://localhost:3000/api-docs에서 액세스할 수 있는 Swagger UI를 제공합니다. 이 UI는 직접 작성한 사양을 반영합니다.\n","ogImage":{"url":"/assets/img/2024-06-23-HowtoSetUpSwaggerUIforRailsProject2024Edition_0.png"},"coverImage":"/assets/img/2024-06-23-HowtoSetUpSwaggerUIforRailsProject2024Edition_0.png","tag":["Tech"],"readingTime":7},{"title":"루비에서 SELF 키워드 사용하는 방법","description":"","date":"2024-06-23 20:46","slug":"2024-06-23-SELFkeywordinruby","content":"\nRuby에서 self의 목적은 무엇인가요?\n\n<img src=\"/assets/img/2024-06-23-SELFkeywordinruby_0.png\" />\n\nRuby에서 self는 현재 객체를 나타내는 특별한 변수입니다. self의 의미는 사용되는 문맥에 따라 달라집니다. self를 이해하는 것은 다른 범위 내에서 어떻게 메서드와 변수에 접근하고 조작하는지에 영향을 미치므로 중요합니다. 이 글에서는 Ruby에서 self의 목적에 대해 자세히 살펴보고 상세한 예시를 제시하겠습니다.\n\n# Ruby에서 self의 목적\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 인스턴스 변수 및 메소드에 접근하기: 인스턴스 메소드 내부에서 self는 클래스의 인스턴스를 가리키며, 인스턴스 변수와 메소드에 접근할 수 있게 합니다.\n- 클래스 메소드 정의하기: 클래스 정의 내부에서 self는 클래스 자체를 가리킵니다. 이는 클래스 메소드를 정의하는 데 유용합니다.\n- 싱글톤 메소드: self를 사용하여 클래스의 모든 인스턴스가 아닌 단일 객체에 속하는 메소드를 정의할 수 있습니다.\n- 메타프로그래밍: self는 메타프로그래밍에서 자주 사용되어 동적으로 메소드를 정의하고 객체를 조작하는 데 활용됩니다.\n- 문맥 인식: self는 코드 실행 문맥을 이해하는 데 도움이 되어 메소드 해결과 범위 관리에 중요합니다.\n\n# self 사용 예시\n\n## 1. 인스턴스 변수와 메소드에 접근하기\n\n이 문맥에서 self는 인스턴스 메소드 내부에서 인스턴스 변수와 메소드에 접근 가능하도록 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```javascript\nclass Person\n  def initialize(name, age)\n    @name = name\n    @age = age\n  end\n\n  def birthday\n    self.age += 1\n  end\n\n  def introduce\n    \"Hello, I'm #{self.name} and I'm #{self.age} years old.\"\n  end\n\n  # Getter and setter methods\n  def name\n    @name\n  end\n\n  def age\n    @age\n  end\n\n  def age=(new_age)\n    @age = new_age\n  end\nend\n\nperson = Person.new(\"Alice\", 30)\nputs person.introduce # 출력: \"안녕, 나는 Alice이고 30살이야.\"\nperson.birthday\nputs person.introduce # 출력: \"안녕, 나는 Alice이고 31살이야.\"\n```\n\n## 2. 클래스 메소드 정의하기\n\n클래스 내부에서 사용될 때 self는 클래스 자체를 가리키며, 클래스 메소드를 정의하는 데 유용합니다.\n\n```javascript\nclass MathUtils\n  def self.square(num)\n    num * num\n  end\n\n  def self.cube(num)\n    num * num * num\n  end\nend\n\nputs MathUtils.square(3) # 출력: 9\nputs MathUtils.cube(3)   # 출력: 27\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nclass MathUtils\n  class << self\n    def square(num)\n      num * num\n    end\n\n    def cube(num)\n      num * num * num\n    end\n  end\nend\n\nputs MathUtils.square(3) # Output: 9\nputs MathUtils.cube(3)   # Output: 27\n```\n\n## 3. Singleton Methods\n\nself can be used to define methods on a single object (singleton methods).\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nstr = \"Hello\"\n\ndef str.shout\nself.upcase + \"!!!\"\nend\n\nputs str.shout # Output: \"HELLO!!!\"\n\n## 4. 메타프로그래밍\n\n메타프로그래밍에서 자주 self는 메소드를 동적으로 정의하고 객체를 조작하는 데 사용됩니다.\n\n```ruby\nclass MyClass\n  def self.create_method(name)\n    define_method(name) do\n      \"Method #{name} called\"\n    end\n  end\nend\n\nMyClass.create_method(:greet)\nobj = MyClass.new\nputs obj.greet # Output: \"Method greet called\"\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nself는 메소드 해결 및 범위 관리에 중요한 실행 컨텍스트를 이해하는 데 도움이 됩니다.\n\n```js\nclass Animal\n  def speak\n    \"동물이 말합니다\"\n  end\n\n  def call_speak\n    self.speak\n  end\nend\n\nclass Dog < Animal\n  def speak\n    \"멍멍!\"\n  end\nend\n\ndog = Dog.new\nputs dog.call_speak # 출력: \"멍멍!\"\n```\n\n## 6. 속성 작성기와 self 사용\n\nself를 사용하는 것은 속성 작성기(setters)를 호출할 때 중요합니다. 이는 로컬 변수 할당과 모호함을 피하기 위해 필요합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nclass User\n  attr_accessor :name\n\n  def initialize(name)\n    @name = name\n  end\n\n  def rename(new_name)\n    self.name = new_name # setter method `name=`이(가) 사용됨\n  end\nend\n\nuser = User.new(\"John\")\nuser.rename(\"Doe\")\nputs user.name # 출력: \"Doe\"\n```\n\n# 요약\n\n- 인스턴스 컨텍스트: 인스턴스 메서드 내에서 self는 클래스의 현재 인스턴스를 가리킵니다.\n- 클래스 컨텍스트: 클래스 메서드 및 클래스 정의 내에서 self는 클래스 자체를 가리킵니다.\n- 싱글톤 메서드: self는 개별 객체에 대해 메서드를 정의하는 데 사용될 수 있습니다.\n- 메타프로그래밍: self는 동적으로 메서드를 정의하고 객체를 조작하는 데 사용됩니다.\n- 컨텍스트 인식: self는 현재 실행 컨텍스트를 이해하는 데 도움을 주며, 메서드 해결과 범위에 영향을 줍니다.\n- 속성 쓰기: self는 로컬 변수 할당과 구별하기 위해 세터 메서드를 호출하는 데 필요합니다.\n\nRubyself의 사용을 숙달하면 더 유연하고 재사용 가능하며 유지 관리가 쉬운 코드를 작성할 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-06-23-SELFkeywordinruby_0.png"},"coverImage":"/assets/img/2024-06-23-SELFkeywordinruby_0.png","tag":["Tech"],"readingTime":5},{"title":"업데이트 실행 가능한 pod로 gem cocoapods  0a를 찾을 수 없는 경우 해결 방법 GemGemNotFoundException","description":"","date":"2024-06-23 20:45","slug":"2024-06-23-Updatedcantfindgemcocoapods0awithexecutablepodGemGemNotFoundException","content":"\n이는 CocoaPods가 시스템에 설치되어 있지 않거나 PATH 변수에 설치되어 있지만 실행 파일인 'pod'를 찾을 수 없음을 의미합니다.\n\n![이미지](/assets/img/2024-06-23-Updatedcantfindgemcocoapods0awithexecutablepodGemGemNotFoundException_0.png)\n\n문제:\n\n```js\n.rvm/rubies/ruby-2.7.6/lib/ruby/site_ruby/2.7.0/rubygems.rb:264:in `find_spec_for_exe': can't find gem cocoapods (>= 0.a) with executable pod (Gem::GemNotFoundException)\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n해결책:\n\n```javascript\n// cocoapod이 설치되어 있는지 확인하세요. 아니라면\nsudo gem install cocoapods\n\ngem pristine --all\n\n// gem 실행 시 권한 오류가 발생한다면 (Errno::EACCES), 슈퍼 사용자를 사용하세요\n```\n\n```javascript\nbundle i 또는 bundle install\n```\n\n2024년 2월 업데이트:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n/System/Library/Frameworks/Ruby.framework/Versions/2.6/usr/lib/ruby/2.6.0/rubygems.rb:283:in `find_spec_for_exe': 실행 가능한 'pod'로 cocoapods (>= 0.a) 젬을 찾을 수 없습니다 (Gem::GemNotFoundException)\n from /System/Library/Frameworks/Ruby.framework/Versions/2.6/usr/lib/ruby/2.6.0/rubygems.rb:302:in `activate_bin_path'\n from /usr/local/bin/pod:23:in `<main>'\n```\n\n# 알 수 없는 루비 인터프리터 버전 (어떻게 처리할지 모름): `=2.6.10.\n\n```js\nnano ~/.bash_profile\nsource ~/.bash_profile\n# bash_profile에 아래 경로 추가\n```\n\n```js\n# .bash_profile에 RVM이 가장 마지막에 있지 않으면 오류가 발생할 수 있음\nexport PATH=\"$PATH:$HOME/.rvm/bin\" # Ruby 버전을 관리하기 위해 RVM을 스크립트에 추가\nexport PATH=\"$GEM_HOME/bin:$PATH\"\n[[ -s \"$HOME/.rvm/scripts/rvm\" ]] && source \"$HOME/.rvm/scripts/rvm\"  # RVM을 셸 세션에 함수로 로드\n```\n","ogImage":{"url":"/assets/img/2024-06-23-Updatedcantfindgemcocoapods0awithexecutablepodGemGemNotFoundException_0.png"},"coverImage":"/assets/img/2024-06-23-Updatedcantfindgemcocoapods0awithexecutablepodGemGemNotFoundException_0.png","tag":["Tech"],"readingTime":2},{"title":"Ruby on Rails에서 스파게티 코드 피하는 방법","description":"","date":"2024-06-23 20:44","slug":"2024-06-23-AvoidingSpaghettiCodeinRubyonRails","content":"\n![이미지](/assets/img/2024-06-23-AvoidingSpaghettiCodeinRubyonRails_0.png)\n\n깨끗하고 유지보수 가능한 코드를 작성하는 것은 개발자에게 중요한 기술입니다. 특히 Ruby on Rails와 같은 견고한 프레임워크를 사용할 때는 더욱 중요합니다. 스파게티 코드란 복잡하고 읽기 어렵고 모듈화되지 않은 코드를 가리키며, 이는 애플리케이션을 확장하거나 디버그하고 유지하기 어렵게 만들 수 있습니다. 이 기사는 Ruby on Rails 개발자들이 스파게티 코드 함정에 빠지지 않도록 도와주기 위한 실용적인 팁과 예제를 제공합니다.\n\n## 레일스의 방식을 따르기\n\n원칙: 더 깨끗하고 예측 가능한 코드베이스를 위해 레일스의 관례를 활용하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n예제: Rails는 모델, 뷰, 컨트롤러, 도우미 등과 관련된 코드를 위한 특정 장소를 제공합니다. 예를 들어, 새로운 리소스를 생성할 때:\n\n![](/assets/img/2024-06-23-AvoidingSpaghettiCodeinRubyonRails_1.png)\n\n이 명령은 Rails의 관례를 준수하여 모델, 컨트롤러 및 뷰를 관행적인 위치에 생성하여 깨끗하고 조직화된 코드베이스를 유도합니다.\n\n## RESTful 리소스 사용하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n원칙: 응용 프로그램을 리소스를 중심으로 구성하고 RESTful 경로를 준수하세요.\n\n예: 가능한 경우에는 사용자 정의 경로가 아닌 RESTful 경로를 사용하여 config/routes.rb에서 다음을 수행하십시오:\n\n![RESTful routes](/assets/img/2024-06-23-AvoidingSpaghettiCodeinRubyonRails_2.png)\n\n이 간단한 한 줄은 RESTful 원칙을 준수하는 일곱 가지 다른 경로를 생성하여 응용 프로그램 구조에서 일관성과 예측 가능성을 촉진합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## DRY (Don’t Repeat Yourself)\n\n원칙: 코드 중복을 피해서 응용 프로그램을 유지 관리하기 쉽게 만듭니다.\n\n예: 공유 뷰 코드에 대해 부분 적용파일을 사용하십시오. 여러 뷰가 동일한 포스트 양식을 사용하는 경우 \\_form.html.erb와 같은 부분 적용 파일을 만드세요:\n\n<img src=\"/assets/img/2024-06-23-AvoidingSpaghettiCodeinRubyonRails_3.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그럼 다음과 같이 Markdown 형식으로 해당 테이블을 추가하세요:\n\n![Avoiding Spaghetti Code](/assets/img/2024-06-23-AvoidingSpaghettiCodeinRubyonRails_4.png)\n\n## 가벼운 컨트롤러, 뚱뚱한 모델\n\n원칙: 컨트롤러는 경량이어야 하며, HTTP와 관련된 로직만 처리하고, 모델은 비즈니스 로직을 처리해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n예시: 비즈니스 로직을 컨트롤러에 넣는 대신:\n\n![AvoidingSpaghettiCodeinRubyonRails_5](/assets/img/2024-06-23-AvoidingSpaghettiCodeinRubyonRails_5.png)\n\n로직을 모델로 옮기세요:\n\n![AvoidingSpaghettiCodeinRubyonRails_6](/assets/img/2024-06-23-AvoidingSpaghettiCodeinRubyonRails_6.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 서비스 객체 사용하기\n\n주의 사항: 복잡한 비즈니스 로직을 다룰 때는 모델을 간단하고 유지보수하기 쉽도록 서비스 객체를 사용하세요.\n\n예시: 게시물 생성이 여러 단계를 거치는 경우 서비스 객체를 만드세요:\n\n![예시 이미지](/assets/img/2024-06-23-AvoidingSpaghettiCodeinRubyonRails_7.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그럼, 귀하의 컨트롤러에서:\n\n![AvoidingSpaghettiCodeinRubyonRails_8](/assets/img/2024-06-23-AvoidingSpaghettiCodeinRubyonRails_8.png)\n\n## ActiveRecord 관계 및 스코프\n\n주요 원칙: 모델 관계에는 연관성을 사용하고 자주 사용하는 쿼리에는 스코프를 사용하십시오.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n예시: 모델에서 연관 관계 정의하기:\n\n![이미지](/assets/img/2024-06-23-AvoidingSpaghettiCodeinRubyonRails_9.png)\n\n그리고 일반적인 쿼리에 대해 스코프 사용하기:\n\n![이미지](/assets/img/2024-06-23-AvoidingSpaghettiCodeinRubyonRails_10.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 테스트\n\n원칙: 코드에 대한 테스트를 작성하여 예상대로 작동하는지 확인하세요.\n\n예시: 모델 테스트를 작성하기 위해 RSpec을 사용하세요:\n\n![image](/assets/img/2024-06-23-AvoidingSpaghettiCodeinRubyonRails_11.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 리팩터링\n\n원칙: 코드의 구조와 가독성을 꾸준히 개선하세요.\n\n예시: 복잡한 메서드를 작은 조각으로 나눠서 관리하기 쉬운 코드로 리팩터링하세요.\n\n이전:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-06-23-AvoidingSpaghettiCodeinRubyonRails_12.png\" />\n\nAfter:\n\n<img src=\"/assets/img/2024-06-23-AvoidingSpaghettiCodeinRubyonRails_13.png\" />\n\n## Follow Ruby and Rails Style Guides\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n원칙: 스타일 가이드를 준수하여 코드 일관성 유지하기\n\n예시: RuboCop을 사용하여 스타일 지침을 자동으로 강제합니다. 간단한 .rubocop.yml 파일을 사용하여 커뮤니티 표준을 강요할 수 있습니다:\n\n![image](/assets/img/2024-06-23-AvoidingSpaghettiCodeinRubyonRails_14.png)\n\n## 코드 리뷰\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n**원칙:** 고품질을 유지하고 지식을 공유하기 위해 코드 리뷰에 참여하십시오.\n\n**예시:** 코드 리뷰를 위해 GitHub 풀 리퀘스트를 사용하십시오. 팀원들로부터 리뷰를 요청하여 문제를 일찍 발견하고 일관된 코딩 관행을 유지할 수 있습니다.\n\n이러한 원칙과 예시를 적용함으로써 Ruby on Rails 개발자들은 더 깨끗하고 유지보수하기 좋은 코드를 작성할 수 있으며, 꼬여버린 스파게티 코드를 피하고 응용 프로그램을 보다 즐겁고 확장하기 쉽게 만들 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-06-23-AvoidingSpaghettiCodeinRubyonRails_0.png"},"coverImage":"/assets/img/2024-06-23-AvoidingSpaghettiCodeinRubyonRails_0.png","tag":["Tech"],"readingTime":7},{"title":"AOP를 활용한 공통 관심사 처리 방법","description":"","date":"2024-06-23 20:42","slug":"2024-06-23-HandlingcrosscuttingconcernswithAOP","content":"\n# 목차\n\n- 소개\n- AOP의 다양한 구성 요소\n  - ` Aspect\n  - ` Join Point\n  - ` Pointcut\n  - ` Advice\n- 로깅 프레임워크를 사용하여 AOP 이해하기\n- AOP와 필터의 차이점은 무엇인가요?\n- 결론\n\n# 소개\n\n관점 지향 프로그래밍(Aspect-Oriented Programming, AOP)은 모듈성을 높이기 위해 교차하는 관심사를 측면(Aspect)으로 분리할 수 있도록 하는 프로그래밍 표준입니다. 전통적인 프로그래밍 패러다임에서는 로깅, 보안 및 트랜잭션 관리와 같은 공통 관심사가 다양한 모듈에 걸쳐 분산되어 코드베이스를 유지 및 이해하기 어렵게 만듭니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n전통적인 로깅 방식:\n\n```js\nprivate User getUserById(Integer userId){\n    Long startTime = System.currentTimeMillis();\n    logger.info(\"Starting method getUserById at {}\", startTime);\n    User user = myDao.getUserById(userId);\n    Long endTime = System.currentTimeMillis();\n    logger.info(\"Ending method getUserById with response {} at time {}\", user, endTime);\n    return user;\n}\n```\n\n그러나 관점 지향 프로그래밍(Aspect-Oriented Programming, AOP)을 활용하면 교차 우선 관심사항(Cross-cutting concerns)을 분리된 단위인 어스펙트(Aspects)로 캡슐화할 수 있습니다. 이를 통해 코드를 더욱 깔끔하고 모듈화할 수 있으며, 각 어스펙트가 특정한 교차 우선 관심사항을 다룹니다.\n\nAOP를 사용한 로깅:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```java\n@Logging(printResponse = true, logLevel = LOG.INFO)\nprivate User getUserById(Integer userId){\n  User user = myDao.getUserById(userId);\n  return user;\n}\n```\n\n# AOP의 다양한 구성 요소\n\nAOP의 다양한 구성 요소를 연극 공연의 예를 들어 설명해 보겠습니다.\n\nJoin Point: 연극 무대에 있는 자신을 상상해보세요. 배우들이 하는 장면 변화나 특정 동작은 모두 join point로 작용합니다. 예를 들어, 캐릭터가 무대에 나오거나 내려갈 때, 특정 대사를 말할 때가 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n포인트컷: 지금 이 시점에서 연극 대본이 포인트컷 역할을 합니다. 이는 특정 대사나 활동의 타이밍을 설정합니다. 예를 들어, 특정 캐릭터가 자정에 무대에 나와야 한다는 것을 시사할 수 있습니다.\n\n조언: 배우들의 연기가 조언을 대변합니다. 그들은 지정된 대본 위치(포인트컷)에서 지시된 대사를 전달하거나 행동을 수행합니다. 따라서 특정 캐릭터가 자정에 무대에 나와야 한다면, 해당 캐릭터를 연기하는 배우는 대본의 지시(포인트컷)에 따라 정해진 대로 행동하게 됩니다.\n\n프로그램은 예시로 든 이 극장 공연을 나타냅니다. 각 장면이나 행동은 조인 포인트가 되며, 대본은 언제 행동이 일어나야 하는지를 나타내는 포인트컷이며, 배우의 연기는 그 시간에 수행되는 조언입니다.\n\n이제 각 구성 요소에 대해 자세히 알아보겠습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 1.) Aspect\n\nAspect(관점)은 횡단 관심사(cross-cutting concerns)를 캡슐화합니다. 지정된 결합 지점(join points)에서 기본 코드에 적용해야 하는 동작을 정의하는 코드를 포함합니다. Aspect에는 조언(advice)과 포인트컷(pointcuts)이 포함됩니다.\n\n## 2.) Join Point\n\nJoin Point(결합 지점)는 프로그램 실행 중 특정 지점인데, 메서드 실행, 메서드 호출, 객체 인스턴스화 및 필드 접근 같은 지점에서 Aspect를 적용할 수 있습니다. Aspect는 결합 지점을 정의하여 영향을 미치는 결합 지점을 명시합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 3.) 포인트컷\n\n포인트컷은 측면이 적용되어야 하는 코드의 기준을 지정합니다. 메서드 시그니처, 클래스 이름, 주석 또는 기타 기준을 기반으로 할 수 있습니다.\n\n아래는 응용 프로그램에서 조인 포인트를 선택하는 데 사용할 수 있는 다양한 유형의 포인트컷입니다.\n\ni) 실행 포인트컷: 이는 응용 프로그램에서 메서드를 실행하는 기준에 따라 조인 포인트를 선택합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n@Before(\"execution(* com.user.service.*.*(..))\")\npublic Object performAuth(JoinPoint joinPoint) throws Throwable {\n    // Advice implementation\n}\n```\n\n“execution(_ com.user.service._.\\*(..))”: 이 부분은 포인트컷 표현식입니다. 왼쪽부터 오른쪽으로 살펴보겠습니다.\n\nexecution - 이 부분은 메서드 실행을 기반으로 포인트컷을 정의하고 있다는 키워드입니다.\n\n- - 이 와일드카드는 메서드의 반환 타입을 나타냅니다. 여기서 \\*는 어떤 반환 타입이던지를 의미합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\ncom.user.service.* - 이 부분은 대상 클래스가 위치한 패키지를 지정합니다 (com.user.service). 마지막 점 뒤의 *는 이 패키지 내의 모든 클래스 이름을 의미합니다.\n\n.* - 이 부분은 메서드 이름을 지정합니다. 여기서 .*는 모든 메서드 이름을 의미합니다.\n\n(..) - 이 부분은 메서드 매개변수를 지정합니다. (..)은 모든 타입의 매개변수를 가진 임의의 개수의 매개변수를 의미합니다.\n\nii) 포인트컷 내에서: 이 포인트컷 표현식은 표현식에 정의된 패키지 이름이나 클래스를 기반으로 조인 포인트를 선택합니다. 해당 패키지/클래스 내의 모든 메서드 실행을 선택합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```java\n@Around(\"within(com.cache.service.*)\")\npublic Object warmupAndDestroyCache(ProceedingJoinPoint joinPoint) throws Throwable {\n    // Advice implementation\n}\n```\n\n\"within(com.cache.service.\\*)\" : 이 표현은 com.cache.service 패키지 내에서 모든 메서드를 선택합니다.\n\niii) 어노테이션 포인트컷: 이 포인트컷은 지정된 어노테이션으로 주석이 달린 모든 메서드와 일치하는 조인 포인트를 선택합니다.\n\n```java\n@After(\"@annotation(com.user.annotations.AuditPurchase)\")\npublic Object logPurchaseHistory(JoinPoint joinPoint) throws Throwable {\n    // Advice implementation\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n“@annotation(com.user.annotations.AuditPurchase)” : 이 표현은 AuditPurchase 어노테이션이 지정된 모든 메서드를 선택합니다.\n\niv) @within Pointcut : 이 포인트컷은 대상 클래스에 특정 어노테이션이 있는 조인 포인트를 선택합니다. 지정된 어노테이션이 지정된 클래스 내에서 메서드 실행될 때 이 포인트컷에 의해 일치됩니다.\n\n```js\n@AfterThrowing(pointcut = \"@within(com.user.annotations.LogError)\", throwing = \"ex\")\npublic void logError(JoinPoint joinPoint, Throwable ex) {\n   // Advice implementation\n}\n```\n\n위에서 정의된 것 외에도 사용 사례에 따라 적용할 수 있는 여러 종류의 포인트컷 표현식이 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 4.) 조언\n\n조언은 특정 조인 포인트에서 취해지는 작업입니다. 일부 조건이 충족될 때 응용 프로그램에 추가하고 싶은 동작입니다. 조언은 일반적으로 포인트컷 표현과 관련이 있으며, 이 표현은 코드베이스 내에서 조언이 적용되어야 하는 위치를 정의합니다. 조언은 해당 포인트컷 표현과 일치하는 조인 포인트에서 실행될 수 있습니다.\n\n다양한 유형의 조언:\n\n- Before advice: 이 유형의 조언은 조언된 메서드가 호출되기 전에 실행됩니다. 입력 유효성 검사, 메서드 실행 시작 로깅 등과 같은 작업을 실행하는 데 일반적으로 사용됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```java\n@Before(\"@within(com.user.annotations.ValidateUserId)\")\npublic void validateUserId(JoinPoint joinPoint) {\n    Integer userId = ((MethodSignature) joinPoint.getSignature()).getMethod().getAnnotation(ValidateUserId.class).userId();\n    // validation 작업에 대한 나머지 로직\n}\n```\n\n- After advice: 이 유형의 어드바이스는 조언된 메서드가 성공 또는 실패에 관계없이 완료된 후에 실행됩니다. 주로 리소스 정리 작업에 사용됩니다.\n\n```java\n@After(\"execution(* com.user.service.*.*(..))\")\npublic void clearCache(JoinPoint joinPoint) {\n    // Advice 구현\n}\n```\n\n- After returning advice: 이 유형의 어드바이스는 어드바이스된 메서드가 예외를 던지지 않고 성공적으로 완료된 후에 실행됩니다. 메서드 실행 결과를 기록하거나 반환된 값에 기반한 후속 처리 작업을 수행하는 데 유용합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```java\n@AfterReturning(pointcut = \"execution(* com.user.service.utils.regex.*.*(..))\", returning = \"result\")\npublic void removeHtmlTagsFromResult(JoinPoint joinPoint, Object result) {\n    // Advice implementation\n}\n```\n\n- After throwing advice: 이 유형의 어드바이스는 조언된 메서드가 예외를 던질 때 실행됩니다. 에러 로깅, 예외 처리 등에 유용합니다.\n\n```java\n@AfterThrowing(pointcut = \"execution(* com.user.service.*.*(..))\", throwing = \"exception\")\npublic void logError(JoinPoint joinPoint, Exception exception) {\n    // Advice implementation\n}\n```\n\n- Around advice: 이 유형의 어드바이스는 조언된 메소드의 호출을 완전히 제어합니다. 입력 및 출력을 포함하여 특정한 로직을 수행하기 위해 메소드 호출을 가로챕니다. 원래 메소드 호출 전후에 사용자 정의 로직을 수행하고, 원래 메소드 호출을 계속할지 여부를 제어할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 로깅 프레임워크를 활용한 AOP 이해\n\n여기서는 메서드에서 소요된 시간을 기록하는 어노테이션 기반 로깅 프레임워크를 생성할 것입니다. 해당 메서드의 입력 및 출력 매개변수를 출력하면서 소요된 시간을 기록합니다.\n\n단계 1: 어스펙트 생성\n\n먼저 로깅 어스펙트 클래스를 생성하여 로깅을 수행하는 어드바이스를 포함시킵니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```java\n@Aspect\n@Component\npublic class LoggingAspect {\n  // 어드바이스와 포인트컷 표현을 포함한 메소드\n}\n```\n\n단계 2: 어드바이스와 포인트컷 정의\n\n이 단계에서는 \"@annotation(com.user.service.annotations.LogTime)\" 포인트컷 표현을 가진 @Around 어드바이스를 가지는 doLogging 메소드를 생성할 것입니다.\n\n```java\n@Aspect\n@Component\npublic class LoggingAspect {\n\n  @Around(value = \"@annotation(com.user.service.annotations.LogTime)\")\n  public Object doLogging(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {\n\n    MethodSignature signature = (MethodSignature) proceedingJoinPoint.getSignature();\n    Method method = signature.getMethod();\n    LogTime loggableMethod = method.getAnnotation(LogTime.class);\n\n    // 이전 처리\n    LogWriter.write(proceedingJoinPoint.getTarget().getClass(), method.getName() + \"() 실행 시작 \");\n\n    if (proceedingJoinPoint.getArgs() != null && proceedingJoinPoint.getArgs().length > 0) {\n      StringBuilder sb = new StringBuilder();\n      for (int i = 0; i < proceedingJoinPoint.getArgs().length; i++) {\n        sb.append(method.getParameterTypes()[i].getName()).append(\":\").append(proceedingJoinPoint.getArgs()[i]);\n        if (i < proceedingJoinPoint.getArgs().length - 1)\n          sb.append(\", \");\n      }\n\n      LogWriter.write(proceedingJoinPoint.getTarget().getClass(), method.getName() + \"() args \" + sb);\n    }\n\n    long startTime = System.currentTimeMillis();\n\n    // 주요 메소드 실행\n    Object result = proceedingJoinPoint.proceed();\n\n    long endTime = System.currentTimeMillis();\n\n    // 결과 표시\n    if (result != null) {\n      LogWriter.write(proceedingJoinPoint.getTarget().getClass(), method.getName() + \"() 결과 : \" + result);\n    }\n\n    // 이후 표시\n    LogWriter.write(proceedingJoinPoint.getTarget().getClass(), method.getName() + \"() 실행 완료 및 실행 시간 \" + (endTime - startTime) + \" 밀리초 소요\");\n\n    return result;\n  }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n단계 3: 어노테이션 생성\n\n이번 단계에서는 우리가 어느 메서드에든 로깅 어드바이스를 적용할 수 있는 사용자 지정 LogTime 어노테이션을 만들고 있습니다.\n\n```java\n@Component\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ElementType.TYPE, ElementType.METHOD})\npublic @interface LogTime {\n\n}\n```\n\n단계 4: 어드바이스 대상 메서드 어노테이션하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n마지막으로, 실행 시간을 추적할 메서드에 사용자 정의 LogTime 주석을 적용해야 합니다.\n\n```js\n@LogTime\npublic User getUserById(Long userId) {\n  Query query = Query.query(Criteria.where(\"userId\").is(userId)\n  return mongoTemplate.findOne(query, User.class);\n}\n```\n\n결과 예시 로그:\n\n<img src=\"/assets/img/2024-06-23-HandlingcrosscuttingconcernswithAOP_0.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# AOP은 필터와 어떻게 다른가요?\n\n![이미지](/assets/img/2024-06-23-HandlingcrosscuttingconcernswithAOP_1.png)\n\n# 결론\n\n마지막으로, 관점지향 프로그래밍(AOP)은 소프트웨어 개발에서 교차 관심사를 모듈화하는 강력한 패러다임을 제공합니다. AOP는 로깅, 보안, 트랜잭션 관리와 같은 관심사를 핵심 비즈니스 로직과 분리함으로써 코드의 모듈성, 재사용성, 유지보수성을 향상시킵니다. 관점, 포인트컷, 어드바이스를 사용함으로써 AOP는 개발자들이 이러한 교차 관심사를 주 응용 로직과 별도로 캡슐화할 수 있게 하며, 보다 깨끗하고 유지보수가 쉬운 코드베이스를 유도합니다.\n","ogImage":{"url":"/assets/img/2024-06-23-HandlingcrosscuttingconcernswithAOP_0.png"},"coverImage":"/assets/img/2024-06-23-HandlingcrosscuttingconcernswithAOP_0.png","tag":["Tech"],"readingTime":14},{"title":"자바 스프링 부트에서 꼭 알아야 할 5가지 디자인 패턴 베스트 프랙티스와 예제","description":"","date":"2024-06-23 20:41","slug":"2024-06-23-Top5DesignPatternsinJavaSpringBootBestPracticesandExamples","content":"\n## 이것들은 저가 자주 사용하고 완전 사랑하는 디자인 패턴들이에요...\n\n![Top 5 Design Patterns in Java Spring Boot Best Practices and Examples](/assets/img/2024-06-23-Top5DesignPatternsinJavaSpringBootBestPracticesandExamples_0.png)\n\n10년 동안 Spring Boot와 Spring Framework 세계에 몰두한 경험이 있는 숙련된 Java 백엔드 개발자로서, 저는 견고하고 확장 가능한 응용 프로그램을 구축하는 데 디자인 패턴들이 하는 중요한 역할을 깨달았어요. 이 문서에서는 다섯 가지 핵심 디자인 패턴을 살펴보고, Spring Boot 프로젝트에서 효과적으로 적용하는 최상의 방법을 탐구할 거에요. 각 패턴은 구현을 설명하기 위해 실용적인 예제와 함께 제시될 거에요.\n\n# 싱글톤 패턴\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n싱글톤 패턴은 클래스가 하나의 인스턴스만 가지고 있도록 보장하고 전역적인 접근 점을 제공합니다. 이는 데이터베이스 연결이나 캐싱 객체와 같은 리소스를 관리하는 데 유용합니다. 스프링 부트에서 이를 구현하는 방법은 다음과 같습니다:\n\n```js\npublic class DatabaseConnection {\n    private static DatabaseConnection instance;\n\n    private DatabaseConnection() {\n        // 인스턴스화를 방지하기 위한 개인 생성자\n    }\n\n    public static synchronized DatabaseConnection getInstance() {\n        if (instance == null) {\n            instance = new DatabaseConnection();\n        }\n        return instance;\n    }\n}\n```\n\n# 팩토리 메소드 패턴\n\n팩토리 메소드 패턴은 슈퍼클래스에서 객체를 생성하는 인터페이스를 제공하여 하위 클래스가 생성될 객체의 유형을 변경할 수 있도록 합니다. 이는 객체 생성 논리를 클라이언트 코드에서 분리하는 데 유용합니다. 스프링 부트에서 예시를 살펴봅시다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```java\npublic interface PaymentProcessor {\n    void processPayment();\n}\n\npublic class CreditCardProcessor implements PaymentProcessor {\n    @Override\n    public void processPayment() {\n        // 신용카드 결제 로직 처리\n    }\n}\n\npublic class PayPalProcessor implements PaymentProcessor {\n    @Override\n    public void processPayment() {\n        // 페이팔 결제 로직 처리\n    }\n}\n\npublic interface PaymentProcessorFactory {\n    PaymentProcessor createPaymentProcessor();\n}\n\n@Component\npublic class PaymentProcessorFactoryImpl implements PaymentProcessorFactory {\n    @Override\n    public PaymentProcessor createPaymentProcessor() {\n        // 어떤 프로세서를 생성할지 결정하는 로직 (설정 등을 기반으로)\n        return new CreditCardProcessor();\n    }\n}\n```\n\n# 옵저버 패턴\n\n옵저버 패턴은 객체 간의 일대다 종속성을 정의하여 한 객체의 상태가 변경될 때 종속 객체가 자동으로 통지 및 업데이트되도록 하는 패턴입니다. 이는 주로 이벤트 기반 시스템에서 사용됩니다. Spring Boot에서 이를 구현해 봅시다:\n\n```java\nimport org.springframework.context.ApplicationEvent;\nimport org.springframework.context.ApplicationListener;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class OrderListener implements ApplicationListener<OrderEvent> {\n    @Override\n    public void onApplicationEvent(OrderEvent event) {\n        // 주문 이벤트 처리\n    }\n}\n\npublic class OrderEvent extends ApplicationEvent {\n    public OrderEvent(Object source) {\n        super(source);\n    }\n}\n\n@Component\npublic class OrderService {\n    private ApplicationEventPublisher eventPublisher;\n\n    public OrderService(ApplicationEventPublisher eventPublisher) {\n        this.eventPublisher = eventPublisher;\n    }\n\n    public void placeOrder() {\n        // 주문을 처리하는 로직\n        // 주문 이벤트 발행\n        eventPublisher.publishEvent(new OrderEvent(this));\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 데코레이터 패턴\n\n데코레이터 패턴을 사용하면 동적으로 객체에 동작을 추가할 수 있습니다. 이는 동일한 클래스의 다른 객체들의 동작에 영향을 주지 않고 기능을 추가하는 데 유용합니다. 로깅, 캐싱 또는 암호화와 같은 기능을 기존 클래스에 추가하는 데 유용합니다. Spring Boot에서 이를 구현해 봅시다:\n\n```js\npublic interface DataService {\n    void fetchData();\n}\n\n@Component\npublic class DataServiceImplementation implements DataService {\n    @Override\n    public void fetchData() {\n        // 데이터 가져오기 구현\n    }\n}\n@Component\npublic class LoggingDecorator implements DataService {\n    private DataService delegate;\n    public LoggingDecorator(DataService delegate) {\n        this.delegate = delegate;\n    }\n    @Override\n    public void fetchData() {\n        // 데이터를 가져오기 전의 로깅 로직\n        delegate.fetchData();\n        // 데이터를 가져온 후의 로깅 로직\n    }\n}\n```\n\n# 전략 패턴:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n전략 패턴은 알고리즘 패밀리를 정의하고 각각을 캡슐화하여 상호 교환할 수 있도록 만드는 것을 말합니다. 여러 알고리즘을 상호 교환할 수 있는 경우에 유용합니다. 이를 Spring Boot에 구현해 보겠습니다:\n\n```java\npublic interface CompressionStrategy {\n    void compress(String file);\n}\n\n@Component\npublic class ZipCompressionStrategy implements CompressionStrategy {\n    @Override\n    public void compress(String file) {\n        // Zip 압축 로직\n    }\n}\n\n@Component\npublic class RarCompressionStrategy implements CompressionStrategy {\n    @Override\n    public void compress(String file) {\n        // RAR 압축 로직\n    }\n}\n\n@Component\npublic class CompressionContext {\n    private CompressionStrategy strategy;\n\n    public CompressionContext(CompressionStrategy strategy) {\n        this.strategy = strategy;\n    }\n\n    public void setStrategy(CompressionStrategy strategy) {\n        this.strategy = strategy;\n    }\n\n    public void compressFile(String file) {\n        strategy.compress(file);\n    }\n}\n```\n\n# 결론\n\n디자인 패턴은 Java 백엔드 개발자의 장비함에 있어 필수적인 도구입니다, 특히 Spring Boot와 같은 프레임워크와 함께 작업할 때 더욱 중요합니다. 이러한 패턴을 숙달하고 프로젝트에 적절히 적용함으로써 유지보수 및 확장 가능한 코드를 이해하고 구현하는 데 도움을 받을 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n커피 한 모금 마셔보세요... ☕︎☕︎☕︎\n","ogImage":{"url":"/assets/img/2024-06-23-Top5DesignPatternsinJavaSpringBootBestPracticesandExamples_0.png"},"coverImage":"/assets/img/2024-06-23-Top5DesignPatternsinJavaSpringBootBestPracticesandExamples_0.png","tag":["Tech"],"readingTime":6},{"title":"Amazon Athena와 함께하는 Spring Boot 사용법","description":"","date":"2024-06-23 20:39","slug":"2024-06-23-SpringBootwithAmazonAthena","content":"\nSpring Boot과 데이터 레이크를 통합하는 방법을 알려드릴게요. 아마존 S3 데이터에 SQL 인터페이스를 제공합니다.\n\n![Spring Boot with Amazon Athena](/assets/img/2024-06-23-SpringBootwithAmazonAthena_0.png)\n\n# 소개\n\n우리는 SpringBoot 애플리케이션을 Amazon Athena와 연결하는 방법을 살펴볼 거에요. Athena가 무엇이며 어떻게 작동하는지 먼저 배운 후, Athena를 쿼리하는 SpringBoot 3 애플리케이션을 생성할 거에요. 해당 애플리케이션은 노출된 Rest API를 통해 Athena에 쿼리합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 아테나 소개\n\n아마존 아테나는 다양한 소스와 형식에 저장된 데이터에 표준 SQL을 실행할 수 있는 쿼리 서비스입니다. 주로 S3와 함께 사용됩니다. 아테나는 Facebook에서 오픈 소스로 공개된 분산 SQL 엔진 Presto를 기반으로 합니다. 아테나는 서버리스이므로 설정하거나 관리할 인프라가 필요하지 않습니다.\n\n아테나는 아마존 S3에 있는 데이터를 분석하는 데 사용됩니다. 아테나는 CSV, ORC, Apache Parquet, Apache Avro, JSON과 같은 데이터 형식을 포함한 다양한 유형의 구조화 및 비구조화 데이터 유형과 작동할 수 있습니다.\n\n아마존의 Simple Storage Service인 S3는 아테나와 함께 사용하기 가장 권장되는 데이터 저장소입니다. S3는 AWS의 객체 저장 서비스로 어떤 파일 형식의 저렴한 저장을 제공합니다. S3는 버킷 내의 객체로 데이터를 저장합니다. 객체는 파일과 파일을 설명하는 메타데이터를 포함합니다. 버킷은 객체를 위한 컨테이너입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nAmazon S3에 데이터를 저장하려면 먼저 버킷을 생성하고 버킷 이름과 AWS 지역을 지정해야 합니다. 그런 다음 해당 버킷에 데이터를 Amazon S3의 객체로 업로드합니다. 각 객체는 버킷 내에서의 객체를 식별하는 고유 키(또는 키 이름)를 가지고 있습니다.\n\n# 데이터 다운로드\n\n저희 데이터는 전 세계 도시 인구에 대한 무료 버전 데이터 입니다. 다음 링크에서 액세스할 수 있습니다: [https://simplemaps.com/data/world-cities](https://simplemaps.com/data/world-cities). 원본 데이터 세트에는 몇 가지 조작이 필요했는데, 예를 들어 따옴표 제거와 같은 조작이 있었으며, 따라서 소스 코드에 포함된 클린한 버전이 제공되며 다음 링크를 통해 다운로드 받을 수 있습니다. 이 데이터에는 다음 스키마가 있습니다.\n\n```js\n도시, 도시_ascii, 위도, 경도, 국가, iso2, iso3, 관리 이름, 수도, 인구, id\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그리고 몇 줄의 샘플이 이렇게 보입니다.\n\n```js\nTokyo,Tokyo,35.6839,139.7744,Japan,JP,JPN,Tōkyō,primary,39105000,1392685764\nJakarta,Jakarta,-6.2146,106.8451,Indonesia,ID,IDN,Jakarta,primary,35362000,1360771077\nDelhi,Delhi,28.6667,77.2167,India,IN,IND,Delhi,admin,31870000,1356872604\nManila,Manila,14.6,120.9833,Philippines,PH,PHL,Manila,primary,23971000,1608618140\nSão Paulo,Sao Paulo,-23.5504,-46.6339,Brazil,BR,BRA,São Paulo,admin,22495000,1076532519\n```\n\n다운로드한 파일의 위치를 주의해주세요. 곧 접근할 것입니다.\n\n# S3 준비\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음으로는 데이터를 저장하는 데 사용할 S3 버킷을 생성해야 합니다. 이는 고유한 이름이어야 합니다. 제가 사용한 이름은 world-cities-athena 입니다. 상호적으로 따라오는 경우 다른 고유한 이름을 사용해야 합니다.\n\nAmazon S3 - Buckets - Create bucket 페이지로 이동하여 다음을 입력하고, 버킷 이름으로 교체하세요.\n\n이미지 src=\"/assets/img/2024-06-23-SpringBootwithAmazonAthena_1.png\" />\n\n나머지 설정은 기본값으로 선택하고, 하단의 \"버킷 생성\" 버튼을 눌러주세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그럼 새 버킷을 선택하고 \"폴더 생성\" 버튼을 사용하여 input 및 queries라는 두 개의 폴더를 만들어주세요.\n\n<img src=\"/assets/img/2024-06-23-SpringBootwithAmazonAthena_2.png\" />\n\n폴더를 만들면 위의 이미지와 같이 구성이 되어야 해요.\n\n마지막으로, input 폴더를 클릭하고 \"업로드\"를 선택하여 이전 섹션에서 다운로드한 데이터 세트를 업로드해주세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Spring Boot with Amazon Athena](/assets/img/2024-06-23-SpringBootwithAmazonAthena_3.png)\n\n이렇게 완료되면 위와 같이 나타날 것입니다.\n\n마지막 단계는 쿼리 결과를 저장할 버킷을 생성하는 것입니다. 이 버킷은 우리가 Athena를 쿼리할 때 포함되며 각 쿼리의 결과가 해당 버킷에 저장됩니다. 그러면 쿼리를 다시 실행하지 않고 결과에 액세스할 수 있으며 비용이 발생하지 않습니다. 그러나 S3에 결과 파일의 저장 비용은 사용자가 책임져야 합니다. 버킷을 생성하려면 다시 Amazon S3 - `Buckets -` Create bucket 페이지로 이동하고 버킷 이름을 world-cities-results로 입력하십시오.\n\n![Spring Boot with Amazon Athena](/assets/img/2024-06-23-SpringBootwithAmazonAthena_4.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다시 모든 기본 값으로 유지하고 아래에 있는 버킷 생성 버튼을 선택하세요.\n\n이제 S3를 구성하고, 다음 단계로 넘어가서 Athena 데이터베이스와 테이블을 설정할 준비가 되었습니다.\n\n# Athena 구성\n\nAthena 데이터베이스를 구성하기 위한 몇 가지 단계가 있습니다. 이 모든 작업은 Athena AWS 콘솔 내에서 수행됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![SpringBootwithAmazonAthena_5](/assets/img/2024-06-23-SpringBootwithAmazonAthena_5.png)\n\nNote that the interface changed somewhat recently and what you select is the line stating “Query your data with Trino SQL”, Trino being a fork of the SQL Query Engine.\n\nOnce you select Launch query editor then you will see this screen.\n\n![SpringBootwithAmazonAthena_6](/assets/img/2024-06-23-SpringBootwithAmazonAthena_6.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n오른쪽에 있는 쿼리 창을 사용하여 Athena와 상호 작용할 수 있습니다. 이 방법을 사용하겠습니다. 객체를 수동으로 정의하는 마법사 형식의 테이블 생성 방법도 있습니다.\n\n먼저 데이터베이스를 생성하겠습니다. 데이터베이스는 처음에 기본값으로 설정되어 있고 우리만의 특정 데이터베이스를 생성하려고 합니다.\n\n쿼리 창에 다음을 입력하세요.\n\n```js\ncreate database worldcitiesdb\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음과 같이 됩니다.\n\n![Spring Boot with Amazon Athena](/assets/img/2024-06-23-SpringBootwithAmazonAthena_7.png)\n\n그런 다음 **실행**을 누르세요.\n\n그럼 왼쪽 데이터 창의 Database 드롭다운에서 새 데이터베이스를 선택할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n현재 시점에서는 새로운 데이터베이스에 테이블이 없는 상태일 것입니다.\n\n테이블을 생성하려면 쿼리를 사용하여 데이터 파일을 가리키고 동시에 데이터로 테이블을 생성하고 채울 것입니다.\n\n오른쪽 쿼리 창에 다음 SQL을 입력하세요.\n\n```js\nCREATE EXTERNAL TABLE IF NOT EXISTS `worldcitiesdb`.`worldcities` (\n `city` string,\n `city_ascii` string,\n `lat` double,\n `lng` double,\n `country` string,\n `iso2` string,\n `iso3` string,\n `admin_name` string,\n `capital` string,\n `population` int,\n `id` int\n)\nROW FORMAT SERDE 'org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe'\nWITH SERDEPROPERTIES (\n 'serialization.format' = ',',\n 'field.delim' = ','\n)\nLOCATION 's3://world-cities-athena/input/'\nTBLPROPERTIES ('skip.header.line.count' = '1')\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 create 문에서 특히 이 줄에 주목해주세요.\n\n```js\nLOCATION 's3://world-cities-athena/input/'\n```\n\n이 줄을 여러분의 버킷 이름으로 교체해야 하지만, 그 외에는 수정하지 말아야 합니다.\n\n쿼리에서 world-cities-athena를 여러분의 버킷으로 교체하신 후 Run을 눌러주세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n한 두 번 실행한 후 녹색 성공 메시지가 표시됩니다. 그러면 새 테이블이 Athena에서 왼쪽 데이터 창에 표시됩니다.\n\n![Spring Boot with Amazon Athena](/assets/img/2024-06-23-SpringBootwithAmazonAthena_8.png)\n\n쿼리 창에 테스트 쿼리를 입력하고 실행하여 테스트할 수 있습니다.\n\n```js\nselect * from worldcities limit 50\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음은 데이터베이스 및 테이블이 있는지 확인하고 쿼리할 수 있다는 것을 확인합니다.\n\n![image](/assets/img/2024-06-23-SpringBootwithAmazonAthena_9.png)\n\nAthena 데이터베이스가 올바르게 설정되었습니다.\n\n# 코드 워크스루\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 기사의 코드는 제 Github에서 찾을 수 있습니다. 코드와 함께 다양한 SQL 문도 포함되어 있어요.\n\nAthena가 설정되었다면, 다음 단계는 REST API를 통해 노출할 SpringBoot 애플리케이션을 구현하는 것입니다. S3 기반 Athena 데이터베이스를 삭제하거나 업데이트할 수 없지만, 쿼리를 사용하여 테이블에 추가하거나 쿼리를 실행할 수 있어요.\n\n우리 경우 이전 섹션에서 만든 테이블을 쿼리할 수 있는 두 개의 REST 엔드포인트를 생성할 거에요. 첫 번째 엔드포인트는 국가별로 가져오고, 두 번째 엔드포인트는 국가 코드가 필요합니다. 둘 다 인구순으로 레코드를 표시하며, 가장 큰 값부터 (내림차순) 나타날 거에요.\n\n시작하기 전에 아래에 표시된 Spring Initializr에서 기본 종속성 집합을 가진 SpringBoot 애플리케이션을 생성할 거에요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-06-23-SpringBootwithAmazonAthena_10.png\" />\n\n여기서는 아테나와 작업하기 위해 필요한 라이브러리를 추가해야 합니다. 이를 위해 Java AWS SDK를 사용할 것입니다. 아래 종속성을 추가하여 이를 활성화하세요.\n\n```js\n<dependency>\n   <groupId>software.amazon.awssdk</groupId>\n   <artifactId>auth</artifactId>\n   <version>2.22.9</version>\n</dependency>\n<dependency>\n   <groupId>software.amazon.awssdk</groupId>\n   <artifactId>athena</artifactId>\n   <version>2.22.9</version>\n</dependency>\n<dependency>\n   <groupId>com.amazonaws</groupId>\n   <artifactId>aws-java-sdk</artifactId>\n   <version>1.12.636</version>\n</dependency>\n```\n\n위의 종속성들은 구현에 필요합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여기서 전체 pom.xml을 확인할 수 있습니다.\n\n## 응용 프로그램 구성\n\n응용 프로그램 구성에는 athena에 액세스하기 위해 필요한 모든 정보가 포함됩니다.\n\n```java\n@Data\n@Component\n@ConfigurationProperties(prefix = \"athena\")\npublic class AppConfiguration {\n    private String region;\n    private String workGroup;\n    private String catalog;\n    private String database;\n    private String resultsBucket;\n    private int clientExecutionTimeout;\n    private int limit;\n    private int retrySleep;\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n앱리케이션.yml의 해당 섹션은 아래와 같이 표시됩니다.\n\nathena:\nregion: us-east-1\nworkgroup: primary\ncatalog: AwsDataCatalog\ndatabase: worldcitiesdb\nlimit: 25\nclient-execution-timeout: 100000\nretry-sleep: 1000 # 1초\nresults-bucket: s3://world-cities-results\n\n## Athena 레이어\n\n다음으로 Athena 클라이언트를 생성하고 쿼리를 실행하는 접근 논리를 구현해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n먼저 Athena 클라이언트를 생성하는 것이 중요합니다. 아래 제공된 코드대로 작업이 진행됩니다.\n\n```js\n@Component\npublic class AthenaClientFactory {\n\n    public AthenaClient createAthenaClient() {\n        return AthenaClient.builder()\n            .credentialsProvider(DefaultCredentialsProvider.create())\n            //.credentialsProvider(EnvironmentVariableCredentialsProvider.create()) // use if creds are\n                                                                                    // env vars\n            .build();\n    }\n}\n```\n\n이 코드는 ~/.aws/credentials 파일에서 액세스 및 시크릿을 로딩하는 과정입니다. 하지만 환경 변수를 사용하고 싶다면 EnvironmentVariableCredentialsProvider를 사용할 수도 있습니다.\n\n이 작업은 software.amazon.awssdk.services.athena.AthenaClient 클래스의 인스턴스를 생성합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음으로 필요한 구성 요소는 쿼리 시작 및 완료입니다. 이것은 두 단계 프로세스입니다.\n\n- 쿼리를 실행하면 시스템에 의해 쿼리 ID가 생성됩니다.\n- 위의 쿼리 ID는 쿼리 완료 상태를 확인하기 위해 성공 또는 실패 여부를 묻는 루프에서 사용됩니다.\n\n아래에 코드가 표시되어 있습니다. 코드에 대한 설명은 코드 뒷부분에 이어집니다.\n\n```js\n@Slf4j\n@Component\npublic class AthenaQuery {\n\n    private final AppConfiguration appConfiguration;\n\n    @Autowired\n    public AthenaQuery(AppConfiguration appConfiguration) {\n        this.appConfiguration = appConfiguration;\n    }\n\n    public String createAthenaQuery(AthenaClient athenaClient, String query) {\n\n        try {\n            QueryExecutionContext queryExecutionContext = QueryExecutionContext.builder()\n                .database(appConfiguration.getDatabase())\n                .build();\n\n            ResultConfiguration resultConfiguration = ResultConfiguration.builder()\n                .outputLocation(appConfiguration.getResultsBucket())\n                .build();\n\n            StartQueryExecutionRequest startQueryExecutionRequest = StartQueryExecutionRequest.builder()\n                .queryString(query)\n                .queryExecutionContext(queryExecutionContext)\n                .resultConfiguration(resultConfiguration)\n                .build();\n\n            StartQueryExecutionResponse startQueryExecutionResponse = athenaClient.startQueryExecution(startQueryExecutionRequest);\n            return startQueryExecutionResponse.queryExecutionId();\n        } catch (AthenaException e) {\n            log.error(\"Error during query execution\", e);\n        }\n        return \"\";\n    }\n\n    public void completeAthenaQuery(AthenaClient athenaClient, String queryExecutionId) {\n\n        GetQueryExecutionRequest getQueryExecutionRequest = GetQueryExecutionRequest.builder()\n            .queryExecutionId(queryExecutionId).build();\n\n        GetQueryExecutionResponse getQueryExecutionResponse;\n        boolean isStillRunning = true;\n        while (isStillRunning) {\n            getQueryExecutionResponse = athenaClient.getQueryExecution(getQueryExecutionRequest);\n            String queryState = getQueryExecutionResponse.queryExecution().status().state().toString();\n            if (queryState.equals(QueryExecutionState.FAILED.toString())) {\n                throw new RuntimeException(\"The Amazon Athena query failed to run with error message: \" + getQueryExecutionResponse\n                    .queryExecution().status().stateChangeReason());\n            } else if (queryState.equals(QueryExecutionState.CANCELLED.toString())) {\n                throw new RuntimeException(\"The Amazon Athena query was cancelled.\");\n            } else if (queryState.equals(QueryExecutionState.SUCCEEDED.toString())) {\n                isStillRunning = false;\n            } else {\n                try {\n                    Thread.sleep(appConfiguration.getRetrySleep());\n                } catch (InterruptedException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            log.debug(\"The current status is: \" + queryState);\n        }\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n쿼리는 createAthenaQuery 메서드로 시작됩니다. 이는 데이터베이스와 결과 버킷을 가진 쿼리 컨텍스트를 생성한 다음 쿼리를 Athena에 제출하여 수행됩니다. 성공적으로 실행된 경우 UUID 형식의 쿼리 실행 ID가 반환되며, 그렇지 않으면 빈 문자열이 반환됩니다.\n\ncompleteAthenaQuery 메서드에서는 쿼리가 성공적으로 완료되거나 쿼리가 실패하거나 취소(시간 초과) 될 때까지 루프를 사용합니다. 이는 결과가 준비될 때까지 실행 경로를 차단하기 위한 것입니다.\n\n## DTO 레이어\n\n이는 쿼리에서 가져온 필드와 일치하는 간단한 레코드입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\ndata class TopTenCities(val name: String, val population: Int)\n```\n\n자바 레코드의 사용으로 이것은 간단한 한 줄짜리 문장이 됩니다. 레코드 클래스를 사용하면 getter 및 동등성 비교 기능이 있는 변경 불가능한 POJO를 얻을 수 있습니다.\n\n## 서비스\n\n구현 내에서 서비스는 모든 것을 연결합니다. 이는 이전에 살펴본 Athena 클래스를 사용하여 Athena에서 데이터를 검색하고, 그런 다음 위의 POJO TopTenCities로 매핑합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```java\n@Service\n@AllArgsConstructor\n@Slf4j\npublic class AthenaService {\n\n    private static final String QUERY_ALL = \"SELECT city, population FROM worldcities \" +\n        \"ORDER BY population DESC LIMIT {limit}\";\n\n    private static final String QUERY = \"SELECT city, population FROM worldcities where iso2 = '{country}' \" +\n        \"ORDER BY population DESC LIMIT {limit}\";\n\n    private final AthenaClientFactory athenaClientFactory;\n\n    private final AthenaQuery athenaQuery;\n\n    public List<TopTenCities> getTop10All(Integer limit) {\n        return run(\"\", limit, QUERY_ALL);\n    }\n\n    public List<TopTenCities> getTop10(String country, Integer limit) {\n        return run(country, limit, QUERY);\n    }\n\n    public List<TopTenCities> run(String country, Integer limit, String query) {\n\n        AthenaClient athenaClient = athenaClientFactory.createAthenaClient();\n\n        String finalQuery = query.replace(\"{country}\", country)\n            .replace(\"{limit}\", String.valueOf(limit));\n        String queryExecutionId = athenaQuery.createAthenaQuery(athenaClient,\n            finalQuery);\n\n        if (!queryExecutionId.isEmpty()) {\n            log.info(\"Query submitted with query id {} and current mills {}\", queryExecutionId, System.currentTimeMillis());\n\n            athenaQuery.completeAthenaQuery(athenaClient, queryExecutionId);\n\n            log.info(\"Query finished at {}\", System.currentTimeMillis());\n\n            return processResultRows(athenaClient, queryExecutionId);\n        } else {\n            log.error(\"Issue while running the query \" + finalQuery);\n            return new ArrayList<>(); // return empty array\n        }\n    }\n\n    private List<TopTenCities> processResultRows(AthenaClient athenaClient, String queryExecutionId) {\n\n        List<TopTenCities> result = new ArrayList<>();\n        GetQueryResultsRequest getQueryResultsRequest = GetQueryResultsRequest.builder()\n            .queryExecutionId(queryExecutionId).build();\n\n        GetQueryResultsIterable getQueryResultsResults = athenaClient.getQueryResultsPaginator(getQueryResultsRequest);\n\n        for (GetQueryResultsResponse Resultresponse : getQueryResultsResults) {\n            List<ColumnInfo> columnInfoList = Resultresponse.resultSet().resultSetMetadata().columnInfo();\n\n            int resultSize = Resultresponse.resultSet().rows().size();\n            log.info(\"Result size: \" + resultSize);\n\n            List<Row> results = Resultresponse.resultSet().rows();\n            result = processRow(results, columnInfoList);\n        }\n        return result;\n    }\n\n    private List<TopTenCities> processRow(List<Row> rowList, List<ColumnInfo> columnInfoList) {\n\n        List<String> columns = new ArrayList<>();\n        List<TopTenCities> result = new ArrayList<>();\n\n        for (ColumnInfo columnInfo : columnInfoList) {\n            columns.add(columnInfo.name());\n        }\n\n        int rowCtr = 0;\n        for (Row row : rowList) {\n            int index = 0;\n\n            // simple mapping logic for the POJO\n            String name = \"\";\n            String population = \"\";\n\n            for (Datum datum : row.data()) {\n                log.debug(columns.get(index) + \": \" + datum.varCharValue());\n                // skip row header row\n                if (rowCtr > 0) {\n                    if (index == 0) {\n                        name = datum.varCharValue();\n                    } else {\n                        population = datum.varCharValue();\n                    }\n                }\n                index++;\n            }\n            rowCtr++;\n            if (!name.isEmpty()) {\n                var topTenCities = new TopTenCities(name, Integer.valueOf(population));\n                result.add(topTenCities);\n            }\n            log.debug(\"===================================\");\n        }\n        return result;\n    }\n}\n```\n\n이제 각 부분을 확인하면서 구현 내용을 이해하겠습니다. run 메서드는 주요 기능을 담당합니다. 여기서 SQL 쿼리 생성이 이루어지고, Athena 처리 레이어에서 이전에 살펴본 createAthenaQuery 및 completeAthenaQuery 메서드가 호출됩니다. 전자는 쿼리를 초기화하고 제출하며, 후자는 처리를 계속하기 전에 완료될 때까지 대기합니다.\n\nAthenaService의 processResultRows 메서드에서 GetQueryResultsRequest 클래스를 사용하여 쿼리 결과를 검색합니다. 이는 전체 결과를 반환하고, processRows가 각 행을 하나씩 처리하고 Java 개체로 매핑하는 데 사용됩니다.\n\n## Rest API\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n마지막으로 살펴볼 부분은 API 레벨입니다. 여기에서 컨트롤러를 구현합니다.\n\n```js\n@RestController\n@RequestMapping(value = \"/cities\", produces = APPLICATION_JSON_VALUE)\n@AllArgsConstructor\npublic class ApiController {\n\n    private final AthenaService athenaService;\n\n    @GetMapping(value = {\"\", \"/\"})\n    public ResponseEntity<List<TopTenCities>> getTop10All(@RequestParam(defaultValue = \"10\") Integer limit) {\n\n        List<TopTenCities> result = athenaService.getTop10All(limit);\n        return ResponseEntity.accepted().body(result);\n    }\n\n    @GetMapping(value = {\"/{country}\"})\n    public ResponseEntity<List<TopTenCities>> getTop10(@PathVariable(\"country\") String country,\n                                                       @RequestParam(defaultValue = \"10\") Integer limit) {\n\n        List<TopTenCities> result = athenaService.getTop10(country, limit);\n        return ResponseEntity.accepted().body(result);\n    }\n}\n```\n\n여기에 두 개의 엔드포인트가 선언되어 있습니다. 하나는 (GET) /cities 이고 다른 하나는 (GET) /cities/'country' 입니다. 두 엔드포인트 모두 선택적으로 쿼리 파라미터를 받아들이며, 반환할 값의 수를 설정할 수 있습니다. 기본값은 10입니다.\n\n# 테스팅\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위 명령어로 애플리케이션을 시작하여 테스트해보세요.\n\n```js\njava -jar target/athena-sample-0.0.1-SNAPSHOT.jar\n```\n\n이렇게 하면 애플리케이션이 실행됩니다. 브라우저 URL에 다음을 입력하여 실행 여부를 확인할 수 있습니다.\n\n```js\nhttp://localhost:8080/api/actuator\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n해당 URL을 브라우저에 입력하면 모든 국가의 인구 순으로 상위 열 개의 도시가 반환됩니다.\n\nhttp://localhost:8080/api/cities\n\n다음과 같이 표시됩니다.\n\n![이미지](/assets/img/2024-06-23-SpringBootwithAmazonAthena_11.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음 코드도 시도해 볼 수 있어요.\n\n```js\nhttp://localhost:8080/api/cities/US?limit=15\n```\n\n이렇게 하면 미국 내 인구 순으로 상위 15개의 도시 정보를 받아볼 수 있어요. DE, BR, CA와 같은 다른 국가 코드로도 시도해 보세요.\n\n우리는 SpringBoot 애플리케이션을 통해 Athena를 쿼리할 수 있음을 보여줬고, 이를 REST API를 통해 모두 연결했어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 참고 자료\n\n- Amazon Athena를 활용한 서버리스 분석 — Packt Publishing — Anthony Virtuoso, Mert Turkay Hocanin, Aaron Wishnick\n\n# 요약\n\n오늘은 SpringBoot 애플리케이션에서 Athena로 인터페이스를 만드는 방법을 살펴보았습니다. 우리는 Athena에 대한 배경 정보부터 시작했습니다. 그 후에 CSV 파일을 Athena로 로드하고 사용 가능하게 만드는 방법을 살펴보았습니다. 다음으로 SpringBoot 애플리케이션과 Athena를 연결하고 쿼리하는 방법을 살펴보았습니다. 이러한 클래스들은 여러분의 애플리케이션에 기초를 제공할 수 있습니다. 마지막으로 우리는 테스트를 해보았습니다. 함께 이 여정을 함께해줘서 감사합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 글의 코드는 제 Github에서 찾아볼 수 있어요.\n\n즐거운 여정되세요!\n","ogImage":{"url":"/assets/img/2024-06-23-SpringBootwithAmazonAthena_0.png"},"coverImage":"/assets/img/2024-06-23-SpringBootwithAmazonAthena_0.png","tag":["Tech"],"readingTime":26},{"title":"엔지니어를 위한 Redis 클러스터 업그레이드 마스터하기 무중단 전환 가이드","description":"","date":"2024-06-23 20:36","slug":"2024-06-23-MasteringRedisClusterUpgradesAnEngineersGuidetoaSeamlessTransition","content":"\n# 소개\n\nAWS ElastiCache에서 Redis 클러스터를 업그레이드하는 것은 지속적인 성능과 보안을 보장하기 위해 꼼꼼한 계획과 실행이 필요한 중요한 작업입니다. 여러 번의 Redis 업그레이드를 직접 이끈 경험을 통해 해당 블로그 게시물에서 과정을 반복 가능한 일련의 단계로 정리했습니다. Redis 클러스터 업그레이드의 복잡성에 대해 자세히 살펴보며, 최선의 사례, 세부적인 전개 전략, 그리고 필수적인 롤백 계획에 대해 다룰 것입니다.\n\n이 과정은 준비 단계, 전개 단계 및 전개 후 단계로 자연스럽게 나눌 수 있습니다.\n\n# 준비 단계\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 부분은 아마도 가장 많은 시간을 소비하지만 매우 중요한 단계로 볼 수 있습니다. 주요 고려 사항은 다음과 같습니다:\n\n# 1. 호환성 매트릭스\n\nRedis 및 선택한 클라이언트 라이브러리(예: Java용 Jedis)에서 제공한 호환성 매트릭스를 철저히 검토해보세요. 이 매트릭스는 버전 간의 잠재적인 호환성 문제를 강조해줍니다.\n\n![MasteringRedisClusterUpgradesAnEngineersGuidetoaSeamlessTransition_0](/assets/img/2024-06-23-MasteringRedisClusterUpgradesAnEngineersGuidetoaSeamlessTransition_0.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nRedis 자체의 릴리스 노트 및 클라우드 제공 업체 문서(예: AWS 문서)를 면밀히 살펴보세요. 이를 통해 새로운 기능, 버그 수정, 사용 중단 예정 기능 및 패치 베이스가 있는 변경 사항을 알 수 있습니다.\n\n## 2. 릴리스 노트\n\nRedis 및 클라이언트 라이브러리의 릴리스 노트를 주의 깊게 읽는 것이 매우 중요합니다. 이는 새로운 기능, 버그 수정, 사용 중단 예정 기능 및 변경 사항에 대한 중요한 정보를 제공합니다. 이러한 릴리스 노트는 Redis 문서에서 찾을 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n모든 Redis 호환 서비스를 제공하는 클라우드 제공업체는 변경 사항을 요약하여 제공합니다. 예를 들어 AWS 문서는 데이터베이스 엔진에 대한 중요한 변경 사항을 잘 요약합니다.\n\n# 3. 스테이징 환경에서 테스트\n\n프로덕션 설정과 유사한 스테이징 환경을 만듭니다. 다음을 포함합니다:\n\n- 인스턴스 유형 및 크기: 프로덕션과 동일한 AWS 인스턴스 유형 및 크기 사용.\n- 네트워크 구성: VPC, 서브넷 및 보안 그룹 설정을 미러링.\n- 데이터 양: 동일한 양의 데이터로 스테이징 환경을 채웁니다. 이것은 실제 업그레이드를 시작하기 전에 데이터 백업을 수행하는 데 걸리는 시간을 이해하는 데 매우 중요합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n스테이징 환경이 생성되면 새로운 Redis 버전과 함께 애플리케이션을 테스트하기 시작하는 시간입니다. 테스트는 다음 세 가지 하위 섹션으로 나눌 수 있습니다.\n\n![이미지](/assets/img/2024-06-23-MasteringRedisClusterUpgradesAnEngineersGuidetoaSeamlessTransition_2.png)\n\n- 기능 테스트\n  새 버전과 완벽하게 작동하는지 확인합니다. 애플리케이션 코드베이스에 있는 모든 Redis 명령이 호환되는지 확인해야 합니다.\n  Lua 스크립트가 있는 경우 모든 사용자 정의 스크립트가 올바르게 실행되는지 확인하는 것이 중요합니다.\n- 성능 테스트\n  Redis는 일반적으로 지연 시간이 민감한 중요한 응용 프로그램에서 사용됩니다. 따라서 Gatling이나 Apache JMeter와 같은 부하 테스트 도구를 사용하여 업그레이드된 Redis 클러스터의 성능을 측정하는 것이 중요합니다.\n  Redis 엔진 업그레이드 중에는 더 높은 성능을 제공하는 경우가 있습니다. 이를 확인하기 위해 철저한 부하 테스트를 수행할 수 있습니다. 또한 클라이언트 라이브러리 설정을 조정하여 더 나은 성능을 얻을 수 있습니다.\n- 신뢰성 테스트\n  신뢰성 테스트는 제품 환경에 영향을 미치기 전에 잠재적인 문제를 발견하기 위한 것입니다. 장애 및 스트레스 시나리오를 시뮬레이션하여 업그레이드된 Redis 클러스터가 실제 환경에서 직면할 도전에 견딜 수 있는지 확인할 수 있습니다.\n  애플리케이션의 Redis 클라이언트가 노드 장애, 네트워크 중단 및 클러스터 재구성을 처리하는 방식을 테스트합니다. 이러한 클라이언트가 신속하게 새로운 노드에 연결하고 데이터 불일치를 우아하게 처리하는지 확인합니다.\n\nRedis 클라이언트 라이브러리는 노드 IP를 캐시합니다. 다중 샤딩 및 다중 노드 Redis 클러스터에서는 클라이언트 라이브러리에서 새로 고치고 새로운 노드에 빨리 연결할 수 있도록 클라이언트 라이브러리에서 새로 고치고 새로운 노드에 빨리 연결할 수 있도록 새로 고치고 새로운 노드에 빨리 연결할 수 있도록 새로 고치고 새로운 노드에 빨리 연결할 수 있도록 새로 고치고 새로운 노드에 빨리 연결할 수 있도록 새로 고치고 새로운\\_IWPAৰ새로 운용할 수 있도록 해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 4. 위험한 명령어 비활성화\n\n대부분의 경우, CPU가 Redis에서 병목 현상을 일으킵니다. 따라서 이러한 블로킹 명령어의 사용을 비활성화하거나 제한하는 것이 중요합니다. 여기에는 두 가지 범주가 있습니다.\n\n- 블로킹 명령어 — KEYS\\* , 대량 데이터 세트에서의 SORT 등\n- 비용이 많이 드는 명령어 — HGETALL , 범위가 큰 ZRANGE\n\nRedis는 명령어 이름을 변경하는 기능을 제공하며, FLUSHALL과 같은 명령어를 \\_DO_NOT_USE_FLUSHALL과 같이 애매한 이름으로 변경할 수 있습니다. ElastiCache를 사용하면 명령어 동작에 영향을 미치는 매개변수를 수정할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n예를 들어, 고가의 명령을 실행할 수 있는 느린 클라이언트를 자동으로 연결 해제하는 타임아웃 설정을 조정할 수 있습니다.\n\n## 5. 모니터링 및 로깅\n\n### 가. 향상된 모니터링\n\n중요한 메트릭인 CPU 사용량, 메모리 사용량 및 네트워크 처리량과 같은 주요 메트릭을 추적하기 위해 향상된 모니터링을 활성화하세요. AWS Elasticache는 Redis 클러스터에 대해 약 40여 가지 메트릭을 제공하며, 이러한 메트릭은 클러스터의 전반적인 상태를 파악하는 데 도움을 줍니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## b. 로깅 및 알림\n\nRedis 명령에 대한 로깅을 설정하고 중요 지표에 대한 알림을 구성하십시오. 이는 문제를 신속히 식별하고 진단하는 데 도움이 됩니다.\n\n업그레이드 단계에서는 Engine Logs와 Slow Logs를 활성화하고 이러한 로그 위에 경고를 설정하는 것이 중요합니다.\n\n# 롤아웃 단계\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n항목을 준비해 둔 후, 상세한 전개 계획을 작성하는 시간이에요. 서비스가 적거나 없는 시간대에 일정을 잡아 방해를 최소화 해보세요. 중요한 애플리케이션의 경우, 업그레이드 창을 신중하게 선택해야 해요. 왜냐하면 업그레이드를 위한 데이터 백업 과정은 상당한 Redis CPU 자원을 소비할 수 있기 때문이죠.\n\n꼭 기억해야 할 몇 가지 포인트가 있어요 —\n\n- 전체 백업: 시작하기 전에 Redis 클러스터 데이터의 전체 백업을 만들어 보세요. 스냅샷이나 선택한 지속성 메커니즘을 사용해보세요. 백업 및 복원 시간을 제품 환경에서 측정하여 업그레이드 창에 미치는 전반적인 영향을 이해하세요.\n- 데이터 일관성 확인: 백업 이후, 기본 및 레플리카 노드 간에 데이터 크기 및 키/값 쌍이 일치하는지 확인해보세요. 이 단계는 진행하기 전에 데이터 무결성을 보장하기 위해 중요해요.\n- 문서 버전: 철저한 롤백 절차를 문서화해보세요. 이에는 백업에서 복원 및 이전 버전에서 클러스터 다시 시작에 대한 상세 단계가 포함돼야 해요. 롤백을 예상대로 작동하는지 확인하기 위해 롤백의 시뮬레이션을 진행하세요.\n- 클라이언트 연결: 애플리케이션 팟이 새 Redis 클러스터에 연결할 수 있는지 확인해보세요. 클라이언트 라이브러리가 DNS 항목을 캐시하는 경우, 최신 연결 정보를 얻기 위해 Refresh Rate를 줄이거나 팟의 Rolling Restart를 실행해야 할 수도 있어요.\n- Thundering Herd 완화: Redis가 데이터베이스의 캐시 역할을 한다면, 캐시가 무효화되거나 실패할 경우 \"Thundering Herd\" 효과에 대비해야 해요. 이는 데이터베이스를 압도할 수 있어요. 데이터베이스 용량을 평가하고, 부담이 더 큰 작업을 처리할 수 있도록 필요에 따라 확장을 고려하세요.\n- 단계별 업그레이드: 새 버전의 안정성을 테스트하기 위해 중요하지 않은 노드(예: 읽기 레플리카)부터 업그레이드를 시작해보세요. 모든 것이 순조롭게 진행되면, 점진적으로 나머지 노드를 업그레이드하면서 프로세스 전반에 걸쳐 애플리케이션이 계속 작동하는지 확인하세요.\n- 커뮤니케이션: 유지보수 창에 대해 모든 이해당사자 및 애플리케이션/서비스 이용자에게 알리세요. 이를 통해 다른 팀이 즉각적으로 발생한 문제나 비정상적인 현상을 보고할 수 있게 돕습니다.\n\n전개 자체에는 여러 가지 방식이 있을 수 있어요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 노드별 업그레이드: 중요한 애플리케이션의 경우, 시간이 오래 걸리지만 빠른 문제 감지가 가능한 한 번에 한 노드씩 업그레이드하는 방법이 있습니다.\n- 클러스터 재생성 (AWS ElastiCache): AWS 및 다른 클라우드 공급업체는 종종 클러스터 재생성 전략을 사용합니다. 이는 이전 클러스터의 스냅샷을 새 버전이 적용된 새 클러스터에 적용하고 데이터 동기화를 보장한 다음 DNS를 새 클러스터로 전환하는 과정을 포함합니다.\n\n## 중요 사항:\n\n전략의 선택은 특정 요구 사항, 리스크 허용 수준 및 애플리케이션의 성격에 따라 다릅니다.\n\n# 롤아웃 후 단계\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n롤아웃 후기 단계는 주로 모니터링과 문서화에 초점을 맞추며, 업그레이드된 Redis 클러스터의 안정성과 성능을 보장합니다. 클러스터를 단계별로 업그레이드한 후(먼저 읽기 레플리카, 그 다음 비중요 샤드, 마지막으로 주 노드) 다음 단계가 중요합니다:\n\n- 지속적인 모니터링\n  업그레이드된 클러스터를 긴 기간 동안 높은 수준으로 모니터링하여 예기치 못한 문제를 신속하게 감지하고 해결하세요. 이전 Redis 클러스터에서 역사적인 메트릭을 내보내고 저장하는 것을 강력히 권장합니다. 이를 통해 현재 성능을 이전 기준선(예: 1개월, 3개월 전)과 비교함으로써 이상 징후를 탐지할 수 있습니다.\n- 문서화\n  철저한 문서화가 중요합니다. 업그레이드 과정 전체를 기록하고 타임라인, 수행된 구체적인 단계, 그리고 마주친 어려움을 기록하세요. 이 문서화는 미래 업그레이드에 대한 소중한 참고 자료가 되며, 데이터 백업 기간, 동기화 프로세스, 그리고 현재 데이터 양과 관련된 기타 주요 메트릭에 대한 통찰을 제공합니다.\n\n# 결론\n\nRedis 클러스터를 업그레이드하는 것은 원활한 전환과 응용 프로그램의 안정성과 성능을 유지하기 위해 구조화된 방식이 요구됩니다. 이 글에서 제안된 전략과 모범 사례를 따르면, 위험을 크게 줄이고 새로운 Redis 기능 및 향상 사항을 성공적으로 통합할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여러 번의 Redis 업그레이드 경험과 통찰을 공유했지만, 언제나 더 배우고 싶습니다. 추가 팁, 제안 또는 실제 예시가 있으시면 아래 댓글을 남겨주세요. 여러분의 피드백은 우리 모두가 Redis 업그레이드 프로세스를 더 견고하게 만들고 발전시키는 데 도움이 될 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-06-23-MasteringRedisClusterUpgradesAnEngineersGuidetoaSeamlessTransition_0.png"},"coverImage":"/assets/img/2024-06-23-MasteringRedisClusterUpgradesAnEngineersGuidetoaSeamlessTransition_0.png","tag":["Tech"],"readingTime":9},{"title":"Kubernetes에서 OOM 생존 가이드 Java 애플리케이션을 위한 팁","description":"","date":"2024-06-23 20:35","slug":"2024-06-23-SurvivingOOMinKubernetesJavaApplications","content":"\n![Surviving OOM in Kubernetes Java Applications](/assets/img/2024-06-23-SurvivingOOMinKubernetesJavaApplications_0.png)\n\n자바 애플리케이션의 세계에서 OutOfMemoryError (OOM) 문제는 할당된 메모리를 소진할 때 발생하는 과제입니다. 기존의 표준 자바 설정에서 OOM을 다룰 때 일반적으로 힙 덤프를 트리거링함으로써 처리합니다. 이는 특정 시점의 응용 프로그램 메모리 스냅샷을 제공하여 개발자가 애플리케이션의 메모리 사용 상태에 대한 통찰력을 제공하는 진단 도구입니다.\n\nKubernetes에서 Java 앱이 OOM을 경험할 때 플랫폼은 원활한 작동을 유지하기 위해 다시 시작됩니다. OOM이 완전한 종료로 이어지는 기존 설정과는 달리 Kubernetes는 자동으로 다시 기동하여 지속적 가용성을 보장합니다. 이 자동 재시작 기능은 힙 덤프를 캡처하려고 할 때 일련의 복잡성을 추가하며, 힙 덤프를 포드가 삭제되기 전에 잡을 잡아야 합니다.\n\n# 접근 방법 1:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nOOM이 발생하기 전에 힙 덤프를 트리거하세요.\n\nPrometheus 메트릭을 사용하는 방법 중 하나입니다.\n\njvm 메모리의 90%와 같은 임계값을 선택하고 해당 임계값이 초과되면 웹훅이나 Robusta와 같은 도구를 사용하여 힙 덤프를 트리거할 수 있습니다.\n\n단점:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 외부 웹훅을 개발하거나 클러스터에 Robusta를 설치해야 합니다.\n- 애플리케이션에 Jmap이 있거나 일시적 컨테이너를 허용해야 합니다. 이 두 가지는 프로덕션에 일반적이지 않습니다.\n\n## 접근 방식 2:\n\n팟이 OOM을 받을 때 Heap 덤프를 생성합니다.\n\n하지만 기다려주세요. 만약 JVM의 최대 메모리에 도달하면, 팟은 다시 시작되는 것이 아니었나요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그곳에 일부 JVM 매개변수가 유용하게 사용됩니다. 다음 JAVA_OPTS를 설정하여 킬 신호가 전송될 때 힙 덤프를 생성할 수 있습니다.\n\n```js\nJAVA_OPTS = \"XX:+HeapDumpOnOutOfMemoryError\";\n```\n\n좋아요! 이제 파드 내에 생성된 힙 덤프가 있습니다. 하지만 이것은 파드가 다시 시작될 때 삭제되기 때문에 우리에게 큰 도움이 되지 않습니다.\n\n![이미지](/assets/img/2024-06-23-SurvivingOOMinKubernetesJavaApplications_1.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n나중에 분석할 힙 덤프를 영구 저장하기 위해 몇 가지 옵션을 살펴볼 거에요.\n\n## 사이드카:\n\nJava 어플리케이션을 포함하는 각각의 파드에는 해당 컨테이너들 사이에서 볼륨을 공유하는 사이드카가 있을 수 있어요. 사이드카의 역할은 힙 덤프를 가져와 우리가 힙 덤프를 영구로 저장하길 원하는 곳에 업로드하는 거에요.\n\nJAVA_OPTS에 우리의 경우, 이런 식으로 힙 덤프를 공유된 볼륨에 넣는 설정을 추가할 거에요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n-XX:HeapDumpPath=/etc/shared-path/${pod_name}.hprof\"\n```\n\n아키텍처는 이렇게 보일 것입니다:\n\n<img src=\"/assets/img/2024-06-23-SurvivingOOMinKubernetesJavaApplications_2.png\" />\n\n단점:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 코드 유지보수 - 이제 모든 파드가 사이드카를 가져야 하며 2개의 컨테이너 사이에 마운트가 필요합니다(이를 Helm 라이브러리를 사용하여 수행할 수 있습니다).\n- CPU 및 메모리 사용량 - 각각의 사이드카는 비록 휴면 상태일지라도 약간의 풋프린트를 갖고 있으며, 많은 파드가 실행 중일 때 이는 빠르게 누적될 수 있습니다.\n\n이러한 2가지 단점으로 인해 다른 접근 방식을 취할 필요가 있습니다.\n\n## 네트워크 볼륨(예: NFS):\n\n단일 NFS 볼륨을 생성하고 모든 클러스터 노드에 마운트할 수 있습니다. 이를 통해 관련 파드를 호스트 경로에 마운트하고 힙 덤프를 이 경로로 직접 지정할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n-XX:HeapDumpPath=/etc/efs-mount/${pod_name}.hprof\"\n```\n\n이제 남은 것은 지속적으로 실행되고 NFS 볼륨을 모니터링하며 이를 대상지(예: S3 버킷)로 복사할 별도의 pod입니다.\n\n이제 아키텍처는 다음과 같이 보일 것입니다:\n\n![아키텍처](/assets/img/2024-06-23-SurvivingOOMinKubernetesJavaApplications_3.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n모니터링 팟은 다음과 같이 작은 파이썬 앱일 수 있습니다:\n\n```python\nimport boto3\nimport os\nimport logging\nimport time\n\nDUMP_FOLDER = '/etc/efs-mount'\nBUCKET_PATH = 'heap-dumps'\nBUCKET_NAME = 'my-app-heap-dumps'\n\ndef main():\n    files_list = os.listdir(DUMP_FOLDER)\n    s3 = boto3.resource('s3')\n\n    if len(files_list) == 0:\n        logging.info(\"업로드할 힙 덤프가 없습니다.\")\n    else:\n        for file in files_list:\n            full_file_path = '{}/{}'.format(DUMP_FOLDER, file)\n            logging.info(\"{}을(를) {}에 업로드 중\".format(file, BUCKET_NAME))\n            s3.meta.client.upload_file(full_file_path, '{}-{}'.format(BUCKET_NAME), '{}/{}'.format(BUCKET_PATH, file))\n            os.remove(full_file_path)\n\nif __name__ == \"__main__\":\n    logging.basicConfig(level=logging.INFO)\n    while True:\n        main()\n        time.sleep(300)\n```\n\n이 해결책은 한 가지 유휴 리소스(모니터링 팟)만 사용하므로 더 저렴한 비용을 제공합니다. 그리고 마운트된 저장소는 사실상 무료입니다(예: EFS), 많은 양을 저장하지도 않고 몇 분 이상 저장하지 않기 때문입니다.\n\n주의사항:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 클라우드 스토리지(예: S3 버킷)에 대한 인증을 하려면 kube2iam과 같은 것을 사용하는 것을 권장합니다.\n- 예제와 같이 힙 덤프를 팟 이름으로 명명하십시오. 이 작업의 까다로운 부분은 매니페스트 아규먼트가 아니라 팟의 엔트리포인트에 넣어야 한다는 것입니다.\n- 이는 포드 제한에 도달해서 발생하는 OOM에 대한 해결책이 아닙니다.\n\n요약하면, JVM OOM을 처리하는 다양한 방법이 있습니다. 환경에 가장 적합한 방법을 선택하십시오.\n","ogImage":{"url":"/assets/img/2024-06-23-SurvivingOOMinKubernetesJavaApplications_0.png"},"coverImage":"/assets/img/2024-06-23-SurvivingOOMinKubernetesJavaApplications_0.png","tag":["Tech"],"readingTime":6},{"title":"자바 스레딩 필수 버추얼 스레드와 플랫폼 스레드 비교 분석","description":"","date":"2024-06-23 20:34","slug":"2024-06-23-JavaThreadingEssentialsVirtualvsPlatformThreadsExplained","content":"\n이 기사에서는 쓰레드와 \"가상 쓰레드\"라고 불리는 최근 기능에 대해 알아볼 것입니다. 이 플랫폼 쓰레드와 가상 쓰레드가 어떻게 성격이 다르며 어떻게 애플리케이션의 성능 향상에 기여하는지에 대해 알아보겠습니다.\n\n![이미지](/assets/img/2024-06-23-JavaThreadingEssentialsVirtualvsPlatformThreadsExplained_0.png)\n\n## 클래식 쓰레드 배경:\n\n외부 API를 호출하거나 데이터베이스 상호작용과 같은 시나리오를 살펴보고 실행 중인 쓰레드 수명주기를 살펴보겠습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 메모리에 생성되고 서비스를 제공할 수 있는 스레드입니다.\n- 요청이 접근하면 스레드 중 하나에 매핑되어 외부 API를 호출하거나 데이터베이스 쿼리를 실행합니다.\n- 스레드는 서비스나 데이터베이스로부터 응답을 받을 때까지 대기합니다.\n- 응답을 받자마자 후속 활동을 실행한 후 풀로 다시 반환합니다.\n\n![이미지](/assets/img/2024-06-23-JavaThreadingEssentialsVirtualvsPlatformThreadsExplained_1.png)\n\n위 생명주기에서 스레드가 아무것도 하는 대기 단계인 단계 3을 관찰하십시오. 이것은 주로 대기하여 시스템 리소스를 비효율적으로 사용하므로 단점이며 수명 주기 중 대부분의 스레드가 응답을 기다리며 아무것도 하지 않습니다.\n\nJava 19 이전에는 스레드를 생성하는 표준 방법 또는 존재하는 스레드가 Native Threads 또는 Platform Threads로 불립니다. 이 아키텍쳐 스타일에서 Platform 스레드와 OS 스레드 사이에 1:1 매핑이 있습니다. 이는 운영 체제 스레드가 완료될때까지 기다리기만 하고 아무 것도하지 않아서 미사용 상태이며 이를 무겁고 비싸게 만듭니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 가상 스레드:\n\n자바의 가상 스레드는 자바가 동시성 및 멀티스레딩을 다루는 방식에서 중대한 발전을 나타냅니다. 오라클의 프로젝트 룸(Projext Loom)의 일환으로 소개된 가상 스레드는 고성능의 동시 애플리케이션을 작성, 유지 및 관찰하기 위한 도전에 대응하기 위한 이니셔티브로, 개발자가 동시성을 더 쉽게 다룰 수 있도록 설계되었습니다.\n\n가상 스레드는 운영 체제가 아닌 Java 가상 머신(JVM)에 의해 관리되는 가볍고 자원소모가 적은 스레드입니다. 플랫폼 스레드와는 달리 가상 스레드는 쉽게 생성 및 해제할 수 있습니다. 그들은 적은 수의 플랫폼 스레드에 매핑되어 수천 개 또는 수백만 개의 작업을 더 적은 자원으로 동시에 처리할 수 있게 합니다.\n\n![가상 vs 플랫폼 스레드](/assets/img/2024-06-23-JavaThreadingEssentialsVirtualvsPlatformThreadsExplained_2.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 가상 스레드의 장점 Platform 스레드 대비\n\n자바에서 가상 스레드의 장점은 많습니다. 먼저, 가상 스레드를 통해 시스템 자원을 더 효율적으로 사용할 수 있습니다. 가상 스레드는 가벼워서 플랫폼 스레드보다 적은 메모리와 CPU 자원을 소비합니다. 이 효율성으로 인해 동시성의 정도를 높일 수 있어 하나의 JVM에서 많은 수의 동시 작업을 실행할 수 있습니다.\n\n둘째, 가상 스레드는 자바에서 동시 프로그래밍을 간단하게 만듭니다. 개발자들은 비동기 프로그래밍 모델의 복잡성을 다루지 않고 동기식 코드를 작성하는 것과 유사한 간단하고 명령형 스타일로 코드를 작성할 수 있습니다. 이 간소화를 통해 교착상태나 경쟁 조건과 같은 일반적인 동시성 관련 버그의 발생 가능성을 줄일 수 있습니다.\n\n게다가, 가상 스레드는 CPU 이용률을 향상시켜줍니다. 기존의 스레드 모델에서는 많은 수의 스레드 사이의 관리와 컨텍스트 스위칭으로 많은 CPU 시간이 소비될 수 있습니다. 가상 스레드는 컨텍스트 스위칭과 관련된 오버헤드를 줄여 동시 작업을 효율적으로 실행할 수 있도록 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 실용적인 방법:\n\n만약 우리가 일을 완료하기 위해 클래식 플랫폼 스레드를 생성하고 싶다면, 아래와 같이 할 수 있습니다. PlatformThreadDemo.java 파일을 만들고 아래 내용을 복사하세요.\n\n```js\npackage org.vaslabs;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class PlatformThreadDemo {\n    private static final Logger logger = LoggerFactory.getLogger(PlatformThreadDemo.class);\n\n    public static void main(String[] args) {\n        attendMeeting().start();\n        completeLunch().start();\n    }\n\n    private static Thread attendMeeting(){\n        var message = \"Platform Thread [Attend Meeting]\";\n        return new Thread(() -> {\n            logger.info(STR.\"{} | \\{message}\", Thread.currentThread());\n        });\n    }\n\n    private static Thread completeLunch(){\n        var message = \"Platform Thread [Complete Lunch]\";\n        return new Thread(() -> {\n            logger.info(STR.\"{} | \\{message}\", Thread.currentThread());\n        });\n    }\n\n    // using builder pattern to create platform threads\n    private static void attendMeeting1(){\n        var message = \"Platform Thread [Attend Meeting]\";\n        Thread.ofPlatform().start(() -> {\n            logger.info(STR.\"{} | \\{message}\", Thread.currentThread());\n        });\n    }\n\n    private static void completeLunch1(){\n        var message = \"Platform Thread [Complete Lunch]\";\n        Thread.ofPlatform().start(() -> {\n            logger.info(STR.\"{} | \\{message}\", Thread.currentThread());\n        });\n    }\n}\n```\n\n위 예제는 플랫폼 스레드를 생성하는 두 가지 방법을 보여줍니다.\n\n1. Thread 생성자를 사용하여 람다 런너블을 전달하는 방법\n2. Thread의 빌더 메서드 ofPlatform()을 사용하는 방법\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n더 복잡한 코딩을 보고 가상 스레드를 동시에 생성하는 방법을 알아보겠습니다. DailyRoutineWorkflow.java 파일을 생성하고 아래 코드를 복사하세요.\n\n```js\npackage org.vaslabs;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.concurrent.TimeUnit;\n\npublic class DailyRoutineWorkflow {\n    static final Logger logger = LoggerFactory.getLogger(DailyRoutineWorkflow.class);\n\n    static void log(String message) {\n        logger.info(STR.\"{} | \\{message}\", Thread.currentThread());\n    }\n\n\n    private static void sleep(Long duration) throws InterruptedException {\n        TimeUnit.MILLISECONDS.sleep(duration);\n    }\n\n    private static Thread virtualThread(String name, Runnable runnable) {\n        return Thread.ofVirtual().name(name).start(runnable);\n    }\n\n    static Thread attendMorningStatusMeeting() {\n        return virtualThread(\n                \"Morning Status Meeting\",\n                () -> {\n                    log(\"아침 상태 회의에 참석하겠습니다.\");\n                    try {\n                        sleep(1000L);\n                    } catch (InterruptedException e) {\n                        throw new RuntimeException(e);\n                    }\n                    log(\"아침 상태 회의를 마쳤습니다.\");\n                });\n    }\n\n    static Thread workOnTasksAssigned() {\n        return virtualThread(\n                \"Work on the actual Tasks\",\n                () -> {\n                    log(\"할당된 작업에 대해 실제 작업을 시작합니다.\");\n                    try {\n                        sleep(1000L);\n                    } catch (InterruptedException e) {\n                        throw new RuntimeException(e);\n                    }\n                    log(\"할당된 작업에 대한 실제 작업을 마쳤습니다.\");\n                });\n    }\n\n    static Thread attendEveningStatusMeeting() {\n        return virtualThread(\n                \"Evening Status Meeting\",\n                () -> {\n                    log(\"저녁 상태 회의에 참석하겠습니다.\");\n                    try {\n                        sleep(1000L);\n                    } catch (InterruptedException e) {\n                        throw new RuntimeException(e);\n                    }\n                    log(\"저녁 상태 회의를 마쳤습니다.\");\n                });\n    }\n\n    static void concurrentRoutineExecutor() throws InterruptedException {\n        var morningMeeting = attendMorningStatusMeeting();\n        var actualWork = workOnTasksAssigned();\n        var eveningMeeting = attendEveningStatusMeeting();\n        morningMeeting.join();\n        actualWork.join();\n        eveningMeeting.join();\n    }\n}\n```\n\n위의 코드는 팩토리 메서드를 사용한 가상 스레드 생성을 보여줍니다. 팩토리 메서드 외에도 java.util.concurrent.ExecutorService를 사용하여 가상 스레드를 구현할 수 있습니다. 이를 통해 ExecutorService를 사용해 동일한 기능을 아래와 같이 구현할 수 있습니다.\n\n```js\npackage org.vaslabs;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\n\npublic class DailyRoutineWorkflowUsingExecutors {\n    static final Logger logger = LoggerFactory.getLogger(DailyRoutineWorkflowUsingExecutors.class);\n\n    static void log(String message) {\n        logger.info(STR.\"{} | \\{message}\", Thread.currentThread());\n    }\n\n    private static void sleep(Long duration) throws InterruptedException {\n        TimeUnit.MILLISECONDS.sleep(duration);\n    }\n\n    public static void executeJobRoute() throws ExecutionException, InterruptedException {\n        try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {\n            var morningMeeting = executor.submit(() -> {\n                log(\"아침 상태 회의에 참석하겠습니다.\");\n                try {\n                    sleep(1000L);\n                } catch (InterruptedException e) {\n                    throw new RuntimeException(e);\n                }\n                log(\"아침 상태 회의를 마쳤습니다.\");\n            });\n\n            var actualWork = executor.submit(() -> {\n                log(\"할당된 작업에 대해 실제 작업을 시작합니다.\");\n                try {\n                    sleep(1000L);\n                } catch (InterruptedException e) {\n                    throw new RuntimeException(e);\n                }\n                log(\"할당된 작업에 대한 실제 작업을 마쳤습니다.\");\n            });\n\n            var eveningMeeting = executor.submit(() -> {\n                log(\"저녁 상태 회의에 참석하겠습니다.\");\n                try {\n                    sleep(1000L);\n                } catch (InterruptedException e) {\n                    throw new RuntimeException(e);\n                }\n                log(\"저녁 상태 회의를 마쳤습니다.\");\n            });\n\n            morningMeeting.get();\n            actualWork.get();\n            eveningMeeting.get();\n        }\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 결과에 대한 심층 분석\n\n위의 코드를 팩토리 메서드나 ExecutorServices를 사용하여 실행하면 아래와 비슷한 결과가 나올 것입니다.\n\n![이미지](/assets/img/2024-06-23-JavaThreadingEssentialsVirtualvsPlatformThreadsExplained_3.png)\n\n정보 로그를 주의 깊게 살펴보면 \"|\" (파이프 기호)의 양쪽에 두 섹션이 표시됩니다. 첫 번째 섹션은 VirtualThread[#26]/runnable@ForkJoinPool-1-worker-3와 같이 가상 스레드에 대한 정보를 설명합니다. 이 섹션은 가상 스레드[#26]가 platform 스레드인 runnable@ForkJoinPool-1-worker-3에 매핑됨을 나타내며, 다른 섹션은 로그의 정보 부분입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 스레드 로컬 및 가상 스레드:\n\n자바의 ThreadLocal은 변수를 스레드별로 저장할 수 있는 메커니즘입니다. ThreadLocal 변수에 접근하는 각 스레드는 변수의 독립적으로 초기화된 복사본을 얻게 되며, 이를 통해 다른 스레드의 동일한 변수에 영향을 주지 않고 접근하고 수정할 수 있습니다. 이는 사용자 세션 또는 데이터베이스 연결과 같이 스레드별 상태를 유지하고자 하는 경우에 특히 유용합니다.\n\n그러나 Project Loom의 일환으로 소개된 가상 스레드와 함께 ThreadLocal을 사용할 때 동작이 크게 변경됩니다. 가상 스레드는 자바 가상 머신(JVM)에 의해 관리되는 가벼운 스레드로, 운영 체제의 스레드 관리에 묶여 있는 전통적인 플랫폼 스레드와 달리 대량으로 스케줄되도록 설계되었습니다.\n\n가상 스레드는 수백만 개로 생성될 수 있기 때문에 ThreadLocal의 사용은 메모리 누수를 발생시킬 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```java\npackage org.vaslabs;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.concurrent.TimeUnit;\n\npublic class ThreadLocalDemo {\n    private static ThreadLocal<String> stringThreadLocal = new ThreadLocal<>();\n\n    static final Logger logger = LoggerFactory.getLogger(DailyRoutineWorkflow.class);\n\n    static void log(String message) {\n        logger.info(STR.\"{} | \\{message}\", Thread.currentThread());\n    }\n\n    private static void sleep(Long duration) throws InterruptedException {\n        TimeUnit.MILLISECONDS.sleep(duration);\n    }\n\n    public static void virtualThreadContext() throws InterruptedException {\n        var virtualThread1 = Thread.ofVirtual().name(\"thread-1\").start(() -> {\n            stringThreadLocal.set(\"thread-1\");\n            try {\n                sleep(1000L);\n            } catch (InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n            log(STR.\"thread name is \\{stringThreadLocal.get()}\");\n        });\n        var virtualThread2 = Thread.ofVirtual().name(\"thread-2\").start(() -> {\n            stringThreadLocal.set(\"thread-2\");\n            try {\n                sleep(1000L);\n            } catch (InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n            log(STR.\"thread name is \\{stringThreadLocal.get()}\");\n        });\n        virtualThread1.join();\n        virtualThread2.join();\n    }\n}\n```\n\n## 결론:\n\n요약하면, 이 Java 스레딩 모델에 관한 기사는 Virtual Threads, Platform Threads 및 ThreadLocal의 세부 사항을 살펴봄으로써 Java에서 동시성 프로그래밍의 진화하는 풍경을 밝혀줍니다. Virtual Threads은 가벼우면서 효율적인 동시성을 제공하며 리소스 집약적인 Platform Threads의 본질과는 대조적인 점을 보여줍니다. 이들은 대규모의 동시 작업을 최소한의 리소스 오버헤드로 실행하여 프로그래밍 모델을 간소화하고 응용프로그램 확장성을 향상시키는 방식으로 Java의 스레드 처리 방법을 혁신합니다.\n\n그러나 이 새로운 맥락에서 ThreadLocal 사용의 복잡성은 신중한 고려가 필요함을 강조합니다. ThreadLocal은 기존 스레딩에서 스레드별 데이터를 유지하는 강력한 도구로 남아 있지만, 가상 스레드에서는 더 복잡해지므로 상태 및 컨텍스트 관리를 위한 대체 전략이 필요합니다. 이러한 개념들은 Java의 동시성 패러다임에서 중대한 변화를 나타내며, 개발자들이 보다 반응성이 뛰어나고 확장 가능하며 효율적인 애플리케이션을 구축할 수 있는 새로운 기회를 제공합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 스택아데믹\n\n끝까지 읽어주셔서 감사합니다. 마지막으로:\n\n- 작가를 응원하고 팔로우해주시길 바랍니다! 👏\n- 트위터(X), 링크드인, YouTube에서 팔로우해주세요.\n- 전 세계적으로 프로그래밍 교육을 무료로 제공하는 방법에 대해 자세히 알아보려면 Stackademic.com을 방문해주세요.\n","ogImage":{"url":"/assets/img/2024-06-23-JavaThreadingEssentialsVirtualvsPlatformThreadsExplained_0.png"},"coverImage":"/assets/img/2024-06-23-JavaThreadingEssentialsVirtualvsPlatformThreadsExplained_0.png","tag":["Tech"],"readingTime":14}],"page":"22","totalPageCount":120,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true}