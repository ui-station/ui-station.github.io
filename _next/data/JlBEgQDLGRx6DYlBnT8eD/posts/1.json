{"pageProps":{"posts":[{"title":"React 19가 온다, 어떤 최신 기능들이 추가됐을까","description":"","date":"2024-07-02 22:04","slug":"2024-07-02-React19isComingWhatsNew","content":"\n\n<img src=\"/assets/img/2024-07-02-React19isComingWhatsNew_0.png\" />\n\n리액트가 마지막으로 릴리즈된 버전은 2022년 6월 14일에 18.2.0 버전으로 나왔어요. 프론트엔드 개발 분야에서 이렇게 인기 있는 기술의 업데이트 속도가 느린 것은 정말 드물죠. 이로 인해 커뮤니티의 일부 중요 인물들 사이에서 불만이 커졌는데, 제 이전 게시물에서 언급했었어요. 관심 있는 분들은 이 글을 클릭해서 확인할 수 있어요: 리액트 커뮤니티 내의 의견 차이.\n\n커뮤니티에서 불만이 계속해서 증가하자, 새로운 리액트 버전의 소식이 드디어 전해졌어요.\n\n리액트 팀은 이제까지 새로운 공식 버전을 출시하지 않은 불만에 대해 응답했어요: 이전에 캐너리 버전에서 출시된 기능들은 서로 상호작용이 필요했기 때문에, 이를 안정 버전에 점진적으로 출시하기 전에 리액트 팀이 함께 작동할 수 있는지 확인하기 위해 많은 시간을 투자해야 했어요.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n사실, 거의 두 년 동안 공식 버전이 출시되지 않았지만 Canary 버전에서 몇 가지 중요한 업데이트가 있었습니다. use, useOptimistic hook, use client, use server 디렉티브와 같은 업데이트는 리액트 에코시스템을 객관적으로 풍부하게 만든 바 있습니다. 특히 Next.js와 Remix와 같은 풀 스택 프레임워크의 빠른 개발을 촉진했습니다.\n\n리액트 팀은 다음 버전이 19.0.0일 것으로 확인했습니다.\n\n# v19에서 예상되는 새로운 기능 예측\n\n이제 리액트 팀의 최신 소식을 기반으로 공식적으로 버전 19에서 출시될 수 있는 새로운 기능을 미리 살펴보겠습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 자동 메모이제이션\n\nReact Conf 2021에서 황 쉔이 소개한 React Forget을 기억하시나요?\n\n![이미지](/assets/img/2024-07-02-React19isComingWhatsNew_1.png)\n\n이제 이것이 여기 있습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n인스타그램의 제품 환경에서 이미 적용된 컴파일러입니다. React 팀은 이를 Meta의 더 많은 플랫폼에 적용할 계획이며, 향후 오픈소스로 공개할 예정입니다.\n\n새로운 컴파일러를 사용하기 전에는 useMemo, useCallback 및 memo를 사용하여 수동으로 상태를 캐시하여 불필요한 다시 렌더링을 줄였습니다. 이 구현은 가능하지만, React 팀은 이것이 그들이 상상한 이상적인 방식은 아니라고 믿습니다. React가 상태 변경 시 필요한 부분만 자동으로 다시 렌더링할 수 있는 방법을 찾고 있었습니다. 몇 년의 노력 끝에 새로운 컴파일러가 성공적으로 출시되었습니다.\n\n새로운 React 컴파일러는 즉시 사용할 수 있는 기능으로, 개발자들에게 또 다른 패러다임 전환을 제공할 것입니다. 이것은 v19의 가장 기대되는 기능입니다.\n\n재미있는 점은 새로운 컴파일러를 소개할 때 React Forget을 언급하지 않은 React 팀이었는데, 이로 인해 커뮤니티에서 우스꽝스러운 댓글이 나왔습니다: 그들은 React Forget을 잊고 Forget 섹션에서 Forget을 언급하는 것을 잊었습니다.🤣\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 작업\n\nReact Actions은 React 팀이 클라이언트에서 서버로 데이터를 전송하는 솔루션을 탐색하면서 개발한 것입니다. 이 기능을 사용하면 개발자가 DOM 요소 (예: ``form/``)에 함수를 전달할 수 있습니다:\n\n```js\n<form action={search}>\n   <input name=\"query\" />\n   <button type=\"submit\">Search</button>\n</form>\n```\n\naction 함수는 동기적 또는 비동기적일 수 있습니다. 작업을 사용할 때 React는 개발자를 위해 데이터 제출의 라이프사이클을 관리합니다. useFormStatus 및 useFormState 훅을 사용하여 현재 폼 작업의 상태와 응답에 액세스할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n클라이언트와 서버 간 상호 작용 시나리오에서 사용할 수 있는 액션은 데이터베이스 변경(데이터 추가, 삭제, 업데이트) 및 양식(예: 로그인 양식, 등록 양식) 구현과 같은 경우에 사용됩니다.\n\nuseFormStatus 및 useFormState와 결합하는 것 외에도, 액션은 useOptimistic 및 use server와 함께 사용될 수 있습니다. 이에 대해 자세히 확장하면 길고 복잡한 토론이 될 수 있지만, 곧 발표될 기사를 통해 액션의 상세 사용법을 소개할 예정이니 기대해 주세요.\n\n## 지시문: use client 및 use server\n\nuse client와 use server 지시문은 오랜 기간 동안 Canary 버전에서 사용 가능했으며, 이제 v19에서 안정 버전과 함께 사용할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이전에 Next.js가 이 두 가지 지시문을 제품으로 사용하는 것에 대한 커뮤니티에서의 빈번한 불만이 있었으며, Next.js는 React 생태계를 손상시키고 있는 것으로 비난되었고, React 팀은 Next.js가 불안정한 기능을 시간 초과로 사용할 수 있도록 허용함에 대해 비판을 받았습니다. 그러나 이 우려는 대부분 불필요합니다. 이 두 가지 지시문은 Next.js나 Remix와 같은 풀스택 프레임워크를 위해 설계되어 있으며, React를 사용하여 응용 프로그램을 개발하는 보통 개발자들은 단기적으로는 거의 필요하지 않을 것입니다.\n\nReact를 사용하는 경우 풀스택 프레임워크가 아니라면, 이 두 가지 지시문의 목적을 이해하는 것만으로 충분합니다. use client와 use server은 프론트엔드와 서버 사이드 환경 사이의 \"분할 지점\"을 표시합니다. use client는 패키지 도구에 `script` 태그를 생성하도록 지시하고, use server는 패키지 도구에 POST 엔드포인트를 생성하도록 지시합니다. 이러한 지시문을 사용하면 개발자는 동일한 파일에서 클라이언트 사이드 및 서버 사이드 코드를 작성할 수 있습니다.\n\n## 낙관적 업데이트를 위한 useOptimistic\n\nuseOptimistic는 v19에서 안정적으로 표시될 것으로 예상되는 새로운 훅입니다. useOptimistic를 사용하면 비동기 작업(예: 네트워크 요청) 중에 UI를 낙관적으로 업데이트할 수 있습니다. 현재 상태와 업데이트 함수를 매개변수로 받아들이며, 비동기 작업 중에 상태의 복사본을 반환합니다. 현재 상태와 작업의 입력을 받아 작업을 기다리는 동안 사용할 낙관적 상태를 반환하는 함수를 제공해야 합니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여기에 그 내용이 정의되어 있습니다:\n\n```js\nconst [optimisticState, addOptimistic] = useOptimistic(state, updateFn);\n\n// 또는\nconst [optimisticState, addOptimistic] = useOptimistic(\n  state,\n  // updateFn\n  (currentState, optimisticValue) => {\n    // 낙관적인 값으로 새로운 상태를 병합 및 반환합니다.\n  }\n);\n```\n\n매개변수\n\nstate: 초기 상태 값 및 작업이 진행 중이 아닐 때 반환되는 값입니다.\n\nupdateFn(currentState, optimisticValue): addOptimistic에 전달된 현재 상태 및 낙관적인 값을 사용하여 낙관적인 상태 결과를 반환하는 함수입니다. updateFn은 currentState 및 optimisticValue 두 매개변수를 받습니다. 반환 값은 currentState와 optimisticValue의 병합된 값이 됩니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n반환 값\n\noptimisticState: 생성된 낙관적인 상태입니다. 작업이 진행 중일 때는 updateFn이 반환하는 값과 동일하며, 작업이 진행 중이 아닌 경우에는 상태와 동일합니다.\naddOptimistic: 낙관적 업데이트 중에 호출되는 디스패치 함수입니다. 낙관적 값 (어떤 유형이든)을 하나의 매개변수로 받아와 상태와 낙관적 값과 함께 updateFn을 호출합니다.\n\n더 자세한 예제:\n\n```js\nimport { useOptimistic } from 'react';\nfunction AppContainer() {\n  const [state, setState] = useState(initialState); // 초기 상태가 있다고 가정합니다\n  const [optimisticState, addOptimistic] = useOptimistic(\n    state,\n    // updateFn\n    (currentState, optimisticValue) => {\n      // 병합하고 반환: 새로운 상태, 낙관적인 값\n      return { ...currentState, ...optimisticValue };\n    }\n  );\n  // 양식 제출과 같은 비동기 작업이 있는 경우를 가정합니다\n  function handleSubmit(data) {\n    // 실제 데이터 제출 전에 낙관적 업데이트 사용\n    addOptimistic({ data: '낙관적인 데이터' });\n    // 그런 다음 비동기 작업 수행\n    fetch('/api/submit', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(data),\n      })\n      .then(response => response.json())\n      .then(realData => {\n        // 실제 데이터로 상태 업데이트\n        setState(prevState => ({ ...prevState, data: realData }));\n    });\n  }\n  return (\n    // optimisticState을 사용하여 UI 렌더링\n    <div>{optimisticState.data}</div>\n  );\n}\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nuseOptimistic은 비동기 작업 중에 예상 결과를 렌더링하고, 작업이 완료되고 상태가 업데이트된 후에 실제 결과(성공 또는 실패)를 렌더링합니다.\n\n## 기타 업데이트\n\n게다가 React 팀 멤버인 Andrew Clark는 2024년에 다음과 같은 변경 사항이 있을 것을 공개했습니다:\n\n🟡 forwardRef → ref는 prop으로: 자식 컴포넌트에서 내부 요소 또는 컴포넌트에 대한 참조를 다룰 때 ref를 일반 prop으로 취급하여 간소화합니다.\n🟡 React.lazy → RSC, promise-as-child: 코드 분할과 lazy로딩 기능을 강화합니다.\n🟡 useContext → use(Context): Context에 접근하는 새로운 방법을 제공합니다.\n🟡 throw promise → use(promise): 비동기 데이터 로딩 처리를 개선합니다.\n🟡 `Context.Provider` → `Context`: 컨텍스트 프로바이더 사용을 간편화합니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그러나 공식 React 웹사이트에서는 아직 이러한 잠재적인 업데이트에 대한 자세한 정보를 제공하지 않았습니다.\n\n# 결론\n\nReact는 위대한 비전을 갖고 있습니다. 그들은 프론트엔드와 백엔드 간의 경계를 흐린 채 클라이언트 측 능력에서 우위를 유지하고 커뮤니티의 풀 스택 프레임워크를 위한 인프라를 제공하려고 합니다. 나는 그들의 방식을 매우 존경합니다. 왜냐하면 프론트엔드와 백엔드 간의 장벽을 허물면 프론트엔드 엔지니어들이 경력적으로 더 나아갈 수 있기 때문입니다.\n\nReact 19는 후크 소개를 이어받는 또 다른 마일스톤 버전이 될 것입니다. 앤드류 클락은 새로운 버전이 3월이나 4월에 출시될 것이라고 말했습니다. 기대해 봅시다!\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저에 관하여\n\nFront-End 엔지니어이자 Full-Stack 실무자이며 AI 통합 옹호자입니다.\n\nNext.js 및 Node.js 프로젝트에서 작업하며, 이 분야에 대한 지식을 공유합니다.\n\nTwitter: https://twitter.com/weijunext\nGithub: https://github.com/weijunext\nBlog: https://weijunext.com/\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 스택데믹 🎓\n\n끝까지 읽어주셔서 감사합니다. 떠나시기 전에:\n\n- 작가를 박수로 격려하고 팔로우해주세요! 👏\n- 팔로우하기: X | LinkedIn | YouTube | Discord\n- 다른 플랫폼 방문하기: In Plain English | CoFeed | Venture | Cubed\n- 더 많은 콘텐츠는 Stackademic.com에서 확인하세요","ogImage":{"url":"/assets/img/2024-07-02-React19isComingWhatsNew_0.png"},"coverImage":"/assets/img/2024-07-02-React19isComingWhatsNew_0.png","tag":["Tech"],"readingTime":10},{"title":"마이크로 프론트엔드 실전 단계별 가이드","description":"","date":"2024-07-02 22:03","slug":"2024-07-02-MicroFrontendsAPracticalStep-by-StepGuide","content":"\n\n## Module Federation과 Bit를 활용한 확장 가능한 Micro Frontends 솔루션 구축\n\n![이미지](/assets/img/2024-07-02-MicroFrontendsAPracticalStep-by-StepGuide_0.png)\n\nMicro Frontends를 구현하는 유일한 해결책은 없습니다. 접근 방식은 프로젝트의 특정 요구사항과 맥락에 맞게 맞춰져야 합니다. 그러나 한 가지 솔루션을 구현함으로써 대체 방법이나 보완적 전략과 같은 대안을 평가할 수 있습니다.\n\n이 블로그에서는 Module Federation과 Bit를 사용하여 Micro Frontends의 런타임 통합을 구현할 것입니다. Bit는 호스트 앱과 원격 모듈을 위한 사전 구성된 템플릿을 제공합니다. 이를 통해 마이크로 프론트엔드 간에 컴포넌트를 공유하는 것이 매우 쉽고, 재사용성을 촉진하며 서로 다른 애플리케이션 부분 사이의 일관성을 유지할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Micro Frontends Guide 1](/assets/img/2024-07-02-MicroFrontendsAPracticalStep-by-StepGuide_1.png)\n\n![Micro Frontends Guide 2](/assets/img/2024-07-02-MicroFrontendsAPracticalStep-by-StepGuide_2.png)\n\n![Micro Frontends Guide 3](/assets/img/2024-07-02-MicroFrontendsAPracticalStep-by-StepGuide_3.png)\n\n# 호스트 앱 및 원격 모듈\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n호스트 앱과 원격 모듈은 미리 구성된 템플릿을 사용하여 생성되었습니다(Bit에서 제공됨):\n\n```js\nnpx @teambit/bvm install # Bit 설치\nbit init my-modfed-solution # 새 Bit 워크스페이스 생성\ncd my-modfed-solution\nbit create modfed-remote-mfe storefront # 원격 모듈 생성\nbit create modfed-host-app shell-app # 호스트 앱 생성\n```\n\n사용 가능한 앱(및 원격 모듈)을 나열하려면 다음을 실행하세요:\n\n```js\nbit app list\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음은 구성 요소 ID와 해당 앱 이름을 나열한 출력입니다:\n\n```js\n┌─────────────────────────────────────────────────┬─────────────────────┐\n│ id                                              │ name                │\n├─────────────────────────────────────────────────┼─────────────────────┤\n│ bit-bazaar.storefront/storefront                │ storefront          │\n├─────────────────────────────────────────────────┼─────────────────────┤\n│ bit-bazaar.shell-app/shell-app                  │ shell-app           │\n└─────────────────────────────────────────────────┴─────────────────────┘\n```\n\n위의 앱 이름을 사용하여 로컬에서 앱을 실행할 수 있습니다:\n\n```js\nbit run storefront\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 공유 의존성\n\n우리의 솔루션은 앱 번들에서 제외되고 별도의 청크로로 로드되도록 구성된 많은 공유 의존성으로 구성되어 있습니다. 이것이 ModFed의 강점 중 하나입니다. 이는 번들 크기를 최적화하고 일관성을 유지하며 동일한 모듈의 다른 버전 간의 충돌을 피할 수 있습니다.\n\n공유 의존성은 프로젝트(호스트 앱 및 원격 모듈) 전체에서 공유되는 Bit 컴포넌트로 유지됩니다. 이를 통해 팀이 독립적으로 작업하면서도 일관성을 유지할 수 있습니다.\n\n공유 의존성 목록은 주로 런타임 라이브러리와 디자인 시스템으로 구성되어 있습니다:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![MicroFrontends Step 4](/assets/img/2024-07-02-MicroFrontendsAPracticalStep-by-StepGuide_4.png)\n\n![MicroFrontends Step 5](/assets/img/2024-07-02-MicroFrontendsAPracticalStep-by-StepGuide_5.png)\n\nFor example:\n\n```js\n/**\n * @filename: storefront.bit-app.ts\n * @component-id: bit-bazaar.storefront/storefront\n*/\n\nimport { MfReact } from '@frontend/module-federation.react.apps-types.mf-rspack';\n/* import the 'shared dependnecies' components */\nimport { shellAppSharedDependencies } from '@bit-bazaar/shell-app.shared-dependencies';\n\n\nexport default MfReact.from({\n  name: 'storefront',\n  clientRoot: './storefront.app-root.js',\n  moduleFederation: {\n    exposes: {\n      // ...\n    },\n    shared: shellAppSharedDependencies,\n  }\n});\n``` \n\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 공유 디자인 시스템\n\n저희의 컴포넌트 라이브러리와 테마는 Material UI를 기반으로 하고 있습니다. 이들은 \"design\" 스코프에서 유지보수되며 Micro Frontends 간에 공유됩니다.\n\n![이미지](/assets/img/2024-07-02-MicroFrontendsAPracticalStep-by-StepGuide_6.png)\n\n# 공유 컨텍스트\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n'Theme Provider', 'Auth Provider', 및 다른 컨텍스트 구성 요소는 \"호스트 앱\" 또는 \"셸 앱\"의 일부입니다. 따라서, 이러한 구성 요소들은 \"셸 앱\" 팀에 의해 유지보수됩니다.\n\n![이미지](/assets/img/2024-07-02-MicroFrontendsAPracticalStep-by-StepGuide_7.png)\n\nMFE를 작업하는 팀들은 인증, 권한 또는 다른 공유 기능에 신경 쓸 필요가 없습니다. \"호스트\" 또는 \"셸\" 팀이 모두 제공합니다.\n\n예를 들어, 'storefront' 팀이 사용자 인증을 기반으로 기능을 구현해야 하는 경우, '셸 앱' 범위를 탐색하고 적절한 \"SDK\"를 찾을 것입니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Image 1](/assets/img/2024-07-02-MicroFrontendsAPracticalStep-by-StepGuide_8.png)\n\n# 라우팅 및 네비게이션\n\n쉘 앱은 마이크로 프론트엔드(원격 모듈)가 단순한 링크를 넘어서 상호작용할 수 있는 \"플러그인 시스템\"을 제공합니다. 이를 통해 각 \"플러그인\"에 대한 형식을 제공함으로써 이를 가능하게 합니다.\n\n![Image 2](/assets/img/2024-07-02-MicroFrontendsAPracticalStep-by-StepGuide_9.png)\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n예를 들어, 원격 모듈은 네비게이션 옵션을 포함한 \"내비게이션 항목\" 인터페이스를 구현할 수 있습니다.\n\n![이미지](/assets/img/2024-07-02-MicroFrontendsAPracticalStep-by-StepGuide_10.png)\n\n그런 다음 셸 앱을 위해 노출할 수 있습니다 (런타임에로 로드됩니다):\n\n```js\n/**\n * @filename: blog.bit-app.ts\n * @component-id: bit-bazaar.blog/blog\n*/\n\nexport default MfReact.from({\n  name: 'blog',\n  clientRoot: './blog.app-root.js',\n  moduleFederation: {\n    exposes: {\n      /** \n       * 셸 앱이 런타임에 로드할 MFE 네비게이션 노출\n       **/\n      './blognav': './navitem.js',\n       /**\n        * 'blog' MFE의 주요 청크\n        **/\n      './blog': './blog.js',\n    },\n    shared: shellAppSharedDependencies,\n  },\n  deploy: Netlify.deploy(netlifyConfig),\n});\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n라우팅은 각 모듈에 맞는 수준에서 처리됩니다. 예를 들어, 셸 앱은 블로그(/blog/*)와 스토어프런트(/storefront/*)로의 라우팅만 처리합니다. 각 MFE(예: storefront/products) 내부의 라우팅은 결정하지 않습니다.\n\nMarkdown 형식의 테이블 태그를 수정하겠습니다.\n\n```js\n/**\n * @filename: shell-app.tsx\n * @component-id: bit-bazaar.shell-app/shell-app\n*/\n\nexport function ShellApp() {\n  return (\n    <BrowserRouter>\n          <Routes>\n            <Route path=\"/\" element={<Layout />}>\n              <Route index element={<Homepage />} />\n              <Route path=\"store/*\" element={<Store />} />\n              <Route path=\"blog/*\" element={<Blog />} />\n              <Route path=\"*\" element={<div>Not Found</div>} />\n            </Route>\n          </Routes>\n    </BrowserRouter>\n  );\n}\n```\n\n따라서 블로그와 같은 원격 모듈은 /blog/* 라우팅(블로그 MFE로의 라우팅)에 대해서 책임을 지지 않습니다 — 중첩된 경로에 대해서만 책임을 집니다.\n\n```js\n/**\n * @filename: blog.tsx\n * @component-id: bit-bazaar.blog/blog\n*/\n\nexport function Blog() {\n  return (\n      <Routes>\n        <Route path=\"articles\" element={<ArticlesPage />} />\n        <Route path=\"categories\" element={<CategoriesPage />} />\n      </Routes>\n  );\n}\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# DevX\n\n개발 경험을 극대화하기 위해 각 팀은 \"플랫폼\" 구성 요소를 사용하여 불변 버전의 셸 앱 및 다른 원격 모듈을 소비하고 개발 중에 이를 컨텍스트로 사용하여 마이크로 프런트엔드를 실행합니다. 이를 통해 규칙적이고 원활한 개발 경험을 제공하면서 적절한 권한 및 접근 제어를 시행할 수 있습니다(예: '블로그' 팀은 '스토어프론트' MFE나 셸 앱을 수정할 수 없습니다).\n\n![이미지](/assets/img/2024-07-02-MicroFrontendsAPracticalStep-by-StepGuide_11.png)\n\n![이미지](/assets/img/2024-07-02-MicroFrontendsAPracticalStep-by-StepGuide_12.png)\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n예를 들어 'storefront' 팀은 개발용으로 유지하는 'platform' 앱을 실행하여 'storefront' MFE를 완전한 컨텍스트에서 실행할 수 있습니다 (쉘 앱 및 다른 MFE도 포함):\n\n```js\nbit run storefront-platform\n```\n\n![이미지](/assets/img/2024-07-02-MicroFrontendsAPracticalStep-by-StepGuide_13.png)","ogImage":{"url":"/assets/img/2024-07-02-MicroFrontendsAPracticalStep-by-StepGuide_0.png"},"coverImage":"/assets/img/2024-07-02-MicroFrontendsAPracticalStep-by-StepGuide_0.png","tag":["Tech"],"readingTime":10},{"title":"2024년 Nextjs 14에서 TypeScript와 함께 Zustand 사용하기","description":"","date":"2024-07-02 22:01","slug":"2024-07-02-ZustandinNextjs14withts","content":"\n\n<img src=\"/assets/img/2024-07-02-ZustandinNextjs14withts_0.png\" />\n\n이 게시물에서는 Next.js 프로젝트에서 Zustand를 사용하는 방법에 대해 설명하겠습니다. Zustand란 무엇일까요? 공식 문서에 따르면 다음과 같습니다:\n\n\"간단하고 빠르며 확장 가능한 간단한 Flux 원리를 사용하는 상태 관리 솔루션입니다. 편리한 API는 후크를 기반으로 하며, 보일러플레이트적이거나 의견이 강요되지 않습니다.\"\n\n# Atomic vs Boilerplate...\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n상황에 따라 다르지만, React.js 또는 Next.js에서는 프로젝트, 팀, 복잡성 등에 따라 보일러플레이트 또는 아토믹 상태 관리 중 선택할 수 있어요.\n\n제 경험에 따르면, 저는 아토믹 상태 관리를 선택했어요. 프로젝트의 다른 부분에 의존하지 않고 각 페이지/디렉터리를 독립적으로 개발할 수 있었어요. \"다른 부분에 의존하지 않는다\"는 것을 어떤 의미인지 예시를 들어 설명해 드릴게요.\n\n# 새 프로젝트를 시작해 볼까요\n\n```js\nnpx create-next-app@latest\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n프로젝트 이름이 무엇인가요? zustand\nTypeScript를 사용하시겠습니까? 예\nESLint를 사용하시겠습니까? 예\nTailwind CSS를 사용하시겠습니까? 아니오\nsrc/ 디렉토리를 사용하시겠습니까? 아니요\nApp Router를 사용하시겠습니까? (권장) 예\n기본 import 별칭(@/)을 사용자 정의하시겠습니까? 예\n구성할 import 별칭은 무엇인가요? @/\n```\n\n![Zustand in Next.js with TypeScript](/assets/img/2024-07-02-ZustandinNextjs14withts_1.png)\n\n# Zustand 추가\n\n```js\nnpm install zustand # 또는 yarn add zustand 또는 pnpm add zustand\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 이제 첫번째 페이지를 개발할 준비가 되었습니다\n\n## 시작할 새로운 페이지를 추가해 봅시다\n\n```js\n// 디렉토리: /app/bears/page.tsx\n\nexport default function Page() {\n  return (\n    <main>\n      <h1>Bears</h1>\n      <p>저희 상점에는 얼마나 많은 곰이 있을까요? {0}</p>\n\n      <button>증가</button>\n      <button>감소</button>\n    </main>\n  );\n}\n```\n\n![이미지](/assets/img/2024-07-02-ZustandinNextjs14withts_2.png)\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 우리 가게는 이 페이지 안에서 생성될 것입니다\n\n이 예시에서는 첫 번째 가게를 페이지 디렉토리 안에 생성할 것입니다. 이 가게는 이 페이지 안에서만 사용되며 다른 페이지나 컴포넌트에서는 전혀 필요하지 않을 겁니다 (이것이 원자 상태 관리의 장점이죠).\n\n```js\n// 디렉토리: /app/bears/_store/index.ts\nimport { create } from 'zustand';\n\n// 상태 타입\ninterface States {\n  bears: number;\n}\n\n// useBearStore\nexport const useBearStore = create<States>(() => ({\n  bears: 0,\n}));\n```\n\n## 페이지 내에서 상태 호출하기\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n// 디렉토리: /app/bears/page.tsx\n\n'use client';\nimport { useBearStore } from './_store';\n\nexport default function Page() {\n  // 스토어 내의 모든 것을 가져올 것입니다.\n  // 주의: 상태 변경 시마다 컴포넌트가 업데이트되는 원인이 될 수 있습니다!\n  const store = useBearStore();\n\n  return (\n    <main>\n      <h1>Bears</h1>\n      <p>우리 스토어에는 얼마나 많은 곰이 있을까요? {store.bears}</p>\n\n      <button>증가</button>\n      <button>감소</button>\n    </main>\n  );\n}\n```\n\n또는\n\n```js\n// 디렉토리: /app/bears/page.tsx\n\n'use client';\nimport { useBearStore } from './_store';\n\nexport default function Page() {\n  // 또는, 스토어에서 필요한 것을 가져올 수도 있습니다.\n  const { bears } = useBearStore((state) => state);\n\n  return (\n    <main>\n      <h1>Bears</h1>\n      <p>우리 스토어에는 얼마나 많은 곰이 있을까요? {bears}</p>\n\n      <button>증가</button>\n      <button>감소</button>\n    </main>\n  );\n}\n```\n\n## 상태 변경을 위한 두 가지 액션을 추가합니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n// 디렉토리: /app/bears/_store/index.ts\n\nimport { create } from 'zustand';\n\n// 상태 타입\ninterface States {\n  bears: number;\n}\n\n// 액션 타입\ninterface Actions {\n  increase: () => void;\n  decrease: () => void;\n}\n\n// useBearStore\nexport const useBearStore = create<States & Actions>((set) => ({\n  bears: 0,\n\n  increase: () => set((state) => ({ bears: state.bears + 1 })),\n  decrease: () => set((state) => ({ bears: state.bears - 1 })),\n}));\n```\n\n```js\n// 디렉토리: /app/bears/page.tsx\n\n'use client';\nimport { useBearStore } from './_store';\n\nexport default function Page() {\n  // 또는, 스토어에서 필요한 것을 가져올 수도 있습니다\n  const { bears, increase, decrease } = useBearStore((state) => state);\n\n  return (\n    <main>\n      <h1>Bears</h1>\n      <p>저희 스토어에는 얼마나 많은 곰이 있을까요? {bears}</p>\n\n      <button onClick={increase}>증가</button>\n      <button onClick={decrease}>감소</button>\n    </main>\n  );\n}\n```\n\n## 이제 준비되었으니, 작동 방식을 확인해봅니다\n\n```js\nnpm run dev\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![Persist Data](/assets/img/2024-07-02-ZustandinNextjs14withts_3.png)\n\n## 데이터 영속적 저장 방법\n\n첫 번째 단계는 영속 데이터를 처리할 수 있도록 스토어를 변경하는 것입니다. localStorage, AsyncStorage, IndexedDB 등을 선택할 수 있습니다.\n\n```js\n// 디렉토리: /app/bears/_store/index.ts\n\nimport { create } from 'zustand';\nimport { persist, createJSONStorage } from 'zustand/middleware';\n\n// 상태 유형\ninterface States {\n  bears: number;\n}\n\n// 액션 유형\ninterface Actions {\n  increase: () => void;\n  decrease: () => void;\n}\n\n// useBearStore\nexport const useBearStore = create(\n  persist<States & Actions>(\n    (set) => ({\n      bears: 0,\n\n      increase: () => set((state) => ({ bears: state.bears + 1 })),\n      decrease: () => set((state) => ({ bears: state.bears - 1 })),\n    }),\n    {\n      name: 'bearStore',\n      storage: createJSONStorage(() => localStorage),\n    }\n  )\n);\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 상태를 유지하고 오류를 피하는 가장 좋은 방법\n\n상태를 유지하기 위해 사용자 정의 후크를 만들 것입니다\n\n```js\n// /helpers/usePersistStore/index.ts\n\nimport { useState, useEffect } from 'react';\n\nconst usePersistStore = <T, F>(\n  store: (callback: (state: T) => unknown) => unknown,\n  callback: (state: T) => F\n) => {\n  const result = store(callback) as F;\n  const [data, setData] = useState<F>();\n\n  useEffect(() => {\n    setData(result);\n  }, [result]);\n\n  return data;\n};\n\nexport default usePersistStore;\n```\n\n## 우리의 페이지는 다음과 같을 것입니다:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n// 디렉토리: /app/bears/page.tsx\n\n'use client';\nimport usePersistStore from '@/helpers/usePersistStore';\nimport { useBearStore } from './_store';\n\nexport default function Page() {\n  // 또는 스토어에서 필요한 것을 가져올 수 있습니다\n  const store = usePersistStore(useBearStore, (state) => state);\n\n  return (\n    <main>\n      <h1>Bears</h1>\n      <p>저희 상점에는 얼마나 많은 곰이 있나요? {store?.bears}</p>\n\n      <button onClick={store?.increase}>증가</button>\n      <button onClick={store?.decrease}>감소</button>\n    </main>\n  );\n}\n```\n\n## GitHub에서 코드를 확인하고 사용해보세요...\n\nhttps://github.com/SalehAkaJim/medium-zustand\n","ogImage":{"url":"/assets/img/2024-07-02-ZustandinNextjs14withts_0.png"},"coverImage":"/assets/img/2024-07-02-ZustandinNextjs14withts_0.png","tag":["Tech"],"readingTime":8},{"title":"큐 기반 훅으로 빠른 사용자 액션을 효율적으로 관리하는 방법 React","description":"","date":"2024-07-02 21:59","slug":"2024-07-02-EfficientlyManagingRapidFireUserActionsinReactwithaQueue-BasedHook","content":"\n\n내 React Native 기반 소셜 네트워킹 앱에서 프로필 페이지를 구축하면서 흥미로운 문제를 마주했어요:\n\n만약 사용자가 좋아요 버튼을 스팸하는 경우 API 엔드포인트 남용을 어떻게 관리할까요?\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*_KQNCttwub7NvtykSKLv3g.gif)\n\n- 사용자가 좋아요 버튼을 스팸하면 취약해집니다.\n- 버튼을 누를 때마다 API 호출이 발생하여 서버에 사용자의 작업을 알리고, 서버에서는 데이터베이스 상태를 업데이트하는 DB 호출이 이어집니다.\n- 첫눈에는 무해한 호출이라고 생각되지만 반복해서 발생할 경우 앱의 캐싱 아키텍처에 심각한 차질을 일으킬 수 있습니다. 효율적으로 관리되지 않은 경우 데이터베이스 상태 업데이트로 인해 여러 번 캐시를 몇 초 내에 여러 번 재설정해야 할 수도 있습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 문제와 UI 요구 사항을 명확히 하기\n\n이 문제를 효율적으로 해결하기 위해 필요한 모든 요구 사항을 기록해 봅시다. 최종 사용자는 부드러운 UX를 필요로 하고, 서버는 최소한의 부하를 원합니다.\n\n## UX 요구 사항\n\n- '좋아요' 동작은 앱에 즉시 반영되어야 합니다. 서버의 응답이 늦게 올 경우에도, 게시물을 좋아하는 경우 하트 아이콘이 즉시 채워지고, 싫어하는 경우 비워져야 합니다.\n이는 일반적인 API 호출 흐름과는 다릅니다. 일반적으로 서버 응답을 기다리는 동안 로더를 표시하고 동작 버튼을 비활성화하는 것이 일반적이지만, 이 접근 방식을 여기서 사용하면 UX를 망치게 됩니다. 전체 경험을 느릿느릿하게 만들어 버릴 수 있습니다.\n- UI 상태는 결국 서버의 상태와 일관되어야 합니다. 즉, API 호출이 성공하지 않는 경우(사용자의 조치) 좋아요 아이콘과 좋아요 수가 표시되어야 합니다.\n- 좋아요 및 싫어요 동작은 번갈아가며 일어납니다. 따라서 서버의 5xx 응답으로 인해 API 호출 중 하나가 실패할 경우 우리는 이 사실을 우리의 이점으로 활용할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 서버 요구 사항\n\n- 서버 호출은 최소화되어야 합니다.\n- 당신이 좋아하지 않은 게시물에 싫어요를 표시할 수 없습니다. 시도하면 400 BAD REQUEST 응답이 반환됩니다.\n- 당신이 이미 좋아한 게시물을 좋아할 수 없습니다. 시도하면 다시 한 번 400 BAD REQUEST 응답이 반환됩니다.\n- 서버는 요청을 처리하는 데 어려움을 겪으면 5xx 응답을 보낼 수 있습니다.\n\n# 용어\n\n더 나아가기 전에, 다음 용어의 의미를 명확하게 설명하고 싶습니다. 만약 명백하지 않다면:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 클라이언트 상태 또는 UI 상태는 사용자에게 표시되는 상태입니다. 이에는 \"좋아요\" 아이콘(좋아요 시 채워지고 좋아요 취소 시 비워짐)와 좋아요 수가 포함됩니다.\n- 서버 상태는 데이터베이스의 상태로, 우리 데이터의 실제 상태입니다.\n\n서버 상태 업데이트(API 호출)는 클라이언트 상태 업데이트(React 상태 업데이트)보다 수십 배 시간이 더 소요됩니다. \n우리의 목표는 클라이언트 상태 업데이트가 서버 상태 업데이트로 인해 느려지지 않으면서 이 두 상태를 최종적으로 조율하는 것입니다.\n\n# 가능한 해결책\n\n이 문제에 대한 전통적인 해결책에는 UI에서 디바운싱 및 함수 쓰로틀링 또는 서버에서 API의 속도 제한이 포함됩니다.\n이 큐 기반 접근 방식에서 나의 생각 프로세스는 API 호출이 수백 밀리초가 걸릴 수 있다는 사실을 활용하고 호출을 자연적인 디바운서로 사용하는 것이었습니다. API의 속도 제한도 여전히 유효합니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 최종 솔루션\n\n잠재적인 해결책에 대한 심사숙고 끝에 사용자의 작업(좋아요/싫어요)을 유지하는 React 훅을 만들었습니다. pushToQueue 메서드를 노출하여 작업을 추가할 수 있게 했습니다.\n\n- 사용자 상태는 즉시 업데이트됩니다.\n서버 상태를 업데이트하는 네트워크 호출은 큐에 추가됩니다.\n- 비어 있지 않은 큐가 감지되면 앱은 처리 상태로 전환됩니다. 큐를 파싱하여 최종 작업(좋아요/싫어요)이 결정되고, 서버에 해당 작업을 알리는 API 호출이 발생합니다.\n- 이제 API 호출은 여러 밀리초가 걸릴 수 있습니다.\n사용자는 통화 중에 동일한 버튼에 추가 상호작용을 실행할 수 있습니다. 이 작업들은 나중에 처리하기 위해 큐에 추가됩니다. (다시 말해, 클라이언트 상태는 이러한 상호작용 발생 즉시 업데이트됩니다. 큐가 처리된 후에 다시 업데이트되며, 서버 상태를 반영합니다.)\n- API 호출이 완료되면 큐에 처리할 추가 항목이 있는지 확인합니다. 존재하는 경우 전체 프로세스가 반복됩니다. 그렇지 않으면 처리가 완료되고 클라이언트 상태가 그에 맞게 업데이트됩니다.\nAPI 호출에 의한 지연은 자연스러운 디바운서 역할을 합니다.\n\n수고하셨습니다. 이제 코드를 빌드해 봅시다!\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 구현\n\n## 앱 초기화\n\n먼저, 좋아요 아이콘과 좋아요 수를 표시하는 간단한 앱을 만들어봅시다:\n\n그 상태에는 다음이 저장됩니다:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 게시물이 좋아요를 받았는지 아닌지를 저장하는 부울 값\n- 좋아요 수 (숫자).\n\n```js\nconst [state, setState] = useState({\n  liked: false,\n  likeCount: 0,\n});\n```\n\n하트 아이콘과 텍스트를 사용하여 정보를 표시합니다:\n\n```js\nreturn (\n    <div className=\"App\">\n      <div id=\"heart_container\">\n        /*Fill the icon if liked, else no fill (transparent)*/\n        <HeartIcon\n          height={96}\n          width={96}\n          stroke=\"#aaa\"\n          fill={liked ? \"rgb(207, 102, 121)\" : \"transparent\"}\n        />\n      </div>\n      /* 좋아요 수를 표시 */\n      <p>{likeCount}</p>\n    </div>\n  );\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음으로, 좋아요/싫어요를 설정하는 간단한 onClick Handler를 정의합니다:\n\n- 좋아요는 boolean 값을 true로 설정하고 좋아요 수를 증가시킵니다.\n- 싫어요는 boolean 값을 false로 설정하고 좋아요 수를 감소시킵니다.\n\n```js\nconst like = useCallback(() => {\n    setState((prevState) => ({\n      liked: true,\n      likeCount: prevState.likeCount + 1,\n    }));\n  }, []);\n\n  const dislike = useCallback(() => {\n    setState((prevState) => ({\n      liked: false,\n      likeCount: prevState.likeCount - 1,\n    }));\n  }, []);\n\n  const onClick = useCallback(() => {\n    if (liked) {\n      dislike();\n    } else {\n      like();\n    }\n  }, [liked]);\n```\n\n스타일링을 조금 추가하면 앱이 이렇게 보입니다:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n마지막으로, 훅을 설정해 봅시다.\n\n## 훅 — Props\n\n우리의 훅은 다음과 같은 프롭스를 받을 것입니다:\n\n- postId: 숫자: 좋아요를 눌러야 할 게시물의 ID. 이 ID와 결합된 API 호출이 실행될 것입니다.\n- mutate(postId: number, liked: boolean, postId: number) =` Promise`boolean` :\nAPI를 호출하기 위한 책임을 지는 비동기 함수입니다. 이 함수는 응답의 상태를 부울 값으로 반환해야 합니다 (호출이 성공했는지 여부).\n모든 네트워크 호출과 마찬가지로, 오류가 발생할 수도 있습니다.\n- setLikedState: (liked: boolean) =` React.SetStateAction:\nUI 상태를 업데이트하는 함수입니다.\n- onError?: (error: Error) =` unknown: 만약 API 호출이 오류를 발생시킬 경우 실행할 콜백 함수입니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## The Hook — 큐 저장하기\n\n액션의 큐를 React ref에 저장할 것입니다. 그 값들은 가능한 액션인 '좋아요' 또는 '싫어요'일 것입니다.\n\n```js\nconst queueRef = useRef<(\"like\" | \"dislike\")[]>([]);\n```\n\n마지막으로, 현재 큐가 처리 중인지 여부를 알려주는 상태를 저장할 것입니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nconst [processing, setProcessing] = useState(false);\n```\n\n최종 작업이 결정되고 API 호출이 이루어질 때 `processing`이 true로 설정됩니다. 큐가 비어있을 때 (처리된 경우) false로 설정됩니다.\n\n## 훅 — 큐 처리하기\n\n다음은 우리 큐의 작동 메커니즘입니다:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 처리 상태를 True로 설정합니다.\n- 원본 큐를 변경하지 않기 위해 큐의 복사본을 만듭니다.\n- 복사본을 이용하여 최종 동작을 결정하기 위해 반복합니다 (좋아요, 싫어요 또는 아무 작업도 안 함):\n\n```js\nsetProcessing(true);\nconst initialQueueLength = queueRef.current.length;\n// 처리 중에 참조를 변경하지 않기 위한 참조의 복사본.\nconst queueCopy = [...queueRef.current];\nlet finalAction: \"like\" | \"dislike\" | \"none\" = \"none\";\nwhile (queueCopy.length) {\n    const type = queueCopy.shift();\n    if (type === \"like\") {\n      finalAction = finalAction === \"dislike\" ? \"none\" : \"like\";\n    } else {\n      finalAction = finalAction === \"like\" ? \"none\" : \"dislike\";\n    }\n}\n```\n\n이제 결정을 내려야 합니다 — API를 호출해야 할까요?\n최종 동작이 아무 작업도 안 함으로 결정된 경우 API 호출이 필요하지 않습니다. 다음을 수행합니다:\n\n- 초기 처리된 항목의 수( initialQueueLength)만큼 참조를 잘라냅니다.\n- 큐가 비어 있는지 확인합니다. 루프가 실행 중에 사용자가 좋아요 버튼을 눌렀다면 큐는 비어 있지 않을 수 있습니다.\n- 큐가 비어 있지 않으면 프로세스를 반복하고 processQueue 함수를 다시 호출합니다. 그렇지 않으면 함수를 종료합니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nif (finalAction === \"none\") {\n  queueRef.current =\n    queueRef.current.slice(initialQueueLength);\n  if (queueRef.current.length > 0) {\n    await processQueue();\n  }\n  setProcessing(false);\n  return;\n}\n```\n\n만일 최종 작업이 '좋아요' 또는 '좋아요 취소'인 경우, API를 호출합니다. 호출이 성공했는지 여부를 추적하는 execSuccess 변수를 유지합니다.\n\n```js\nlet execSuccess = false;\ntry {\n    execSuccess = await mutate(postId, finalAction === \"like\");\n} catch(error) {\n    execSuccess = false;\n    onError(error);\n}\n```\n\n마지막으로, 큐에 더 이상 항목이 없다면 서버 응답에 따라 UI 상태를 업데이트해야 합니다. \nAPI 호출이 실패했고 큐가 비어 있지 않으면 큐의 첫 번째 요소를 삭제할 수 있습니다. 작업은 대체로 번갈아가며 발생하기 때문입니다.\n예: 만일 '좋아요' 호출이 실패했다면 큐에 추가된 다음 작업은 '좋아요 취소'일 것입니다. 따라서 우리는 처리되기 전에 큐에 추가된 '좋아요 취소' 작업을 삭제할 수 있습니다. '좋아요' 작업이 실패하면 UI 상태에선 '좋아요 취소' 작업과 동일하기 때문입니다.\n\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\r\n마지막으로, 푸시 함수를 정의할 것입니다.\n\n이 함수는 like 또는 dislike와 같은 액션을 인수로 받아서 간단히 큐에 푸시합니다.\n큐가 처리 중이 아닌 경우(처리 상태 변수가 false인 경우), processQueue 함수를 호출합니다.\n우리의 훅은 이 함수를 반환합니다.\n\nconst pushToQueue = useCallback(\n  (action: \"like\" | \"dislike\") => {\n    const newQueue = [...queueRef.current, action];\n    queueRef.current = newQueue;\n    if (!processing) processQueue();\n  },\n  [processing]\n);\n\nreturn [pushToQueue];\r\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# Hook 사용 및 앱 테스트하기\n\n## API\n\n우리는 코드를 테스트하기 위해 모의 API를 사용할 것입니다. 이 API는 20%의 실패 비율을 가지며, 성공하면 true를 반환하고 그렇지 않으면 false를 반환합니다. 500ms의 인위적 지연이 발생할 것입니다.\n\nconst API_DELAY = 500;\nconst responses = [true, true, false, true, true];\nlet idx = 0;\nconst postLikeMapping = new Map<number, boolean>();\nexport const mockedApiCall = async (postId: number, liked: boolean) => {\n  // 가짜 지연\n  await new Promise((resolve) => setTimeout(resolve, API_DELAY));\n  if (!postLikeMapping.get(postId) && !liked) {\n    throw new Error(\"좋아요 표시하지 않은 게시물에 싫어요를 표시할 수 없습니다.\");\n  }\n  if (postLikeMapping.get(postId) && liked) {\n    throw new Error(\"이미 좋아요한 게시물에 또 다시 좋아요를 표시할 수 없습니다.\");\n  }\n  //   80% 성공 확률 시뮬레이션\n  if (responses[idx++ % responses.length]) {\n    postLikeMapping.set(postId, liked);\n    return true;\n  }\n  return false;\n};\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리 앱은 사용자가 좋아요 또는 싫어요 버튼을 누를 때마다 이 함수를 호출합니다.\n\n## 우리 앱에서 Hook 사용\n\n마지막으로, 우리가 만든 훅을 앱에 통합합니다.\n\n- 좋아하는 상태를 React 리듀서로 변경합니다.\n- 동일한 작업이 연속적으로 호출될 때(한 번은 UI에서 즉시 호출되고 다른 한 번은 훅이 성공적인 API 호출 후 호출될 때), 리듀서는 상태를 변경하지 않습니다.\n- UI가 상태를 즉시 업데이트하지만 API 호출이 실패하여 상태가 재설정될 때 작업에 의해 상태가 업데이트됩니다.\n- Hook을 소비하고 사용자 상호작용 시 훅이 노출하는 pushToLikeQueue 메서드를 호출합니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n// Reducer 코드\nconst likedReducer: Reducer<{ liked: boolean; likeCount: number }, boolean>\n= (\n    state,\n    liked\n  ) => {\n  const { likeCount } = state;\n  if (liked === state.liked) {\n    return state;\n  }\n  return {\n    liked,\n    likeCount: liked ? likeCount + 1 : likeCount - 1,\n  };\n};\n\n// Hook 사용하기\nconst [pushToLikeQueue] = useLikes({\n  setLikedState: dispatchLiked,\n  postId: 1,\n  async mutate(postId, liked) {\n    return await mockedApiCall(postId, liked);\n  },\n});\n\nconst like = useCallback(() => {\n  dispatchLiked(true); // 바로 UI 상태 업데이트\n  pushToLikeQueue(\"like\"); // API 호출을 대기열에 추가\n}, [pushToLikeQueue]);\n\nconst dislike = useCallback(() => {\n  dispatchLiked(false); // 바로 UI 상태 업데이트\n  pushToLikeQueue(\"dislike\"); // API 호출을 대기열에 추가\n}, [pushToLikeQueue]);\n\n## Logic 테스트\n\n우리의 mocked API 코드는 매 다섯 번째 시도마다 실패할 것입니다. 아래에서 라이브 데모를 확인할 수 있습니다: 왼쪽에는 UI가 있고, 오른쪽에는 뒷단에서 무슨 일이 벌어지고 있는지가 나와 있습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 결론\n\n에헤! 이제 신뢰할 수 있는 좋아요 / 싫어요 메커니즘이 생겼습니다. 이 방법은 API 호출을 최소화하고 UI를 반응적으로 유지하며 최신 상태로 유지합니다!\n\n이 훅을 만드는 PR을 볼 수 있습니다.\n이 앱을 데모하려면 다음 단계를 따라주세요:\n\n- Playgrounds 리포지토리를 복제하세요.\n- react/use-likes-hook-demo로 이동하십시오.\n- 폴더에서 npm install을 실행하십시오.\n- 폴더에서 npm start를 실행하십시오.\n- 앱을 사용해보세요.","ogImage":{"url":"/assets/img/2024-07-02-EfficientlyManagingRapidFireUserActionsinReactwithaQueue-BasedHook_0.png"},"coverImage":"/assets/img/2024-07-02-EfficientlyManagingRapidFireUserActionsinReactwithaQueue-BasedHook_0.png","tag":["Tech"],"readingTime":14},{"title":"Top 1 Nextjs 개발자가 사용하는 6개의 추천 레포지토리 ","description":"","date":"2024-07-02 21:58","slug":"2024-07-02-6reposusedbythetop1ofNextjsdev","content":"\n\nNext.js에서 배우거나 멋진 것을 구축하기 위한 좋은 프로젝트를 찾고 계신가요?\n\n이 문서에서는 여러분이 더 빨리成 [...]\n\n준비가 되셨나요? Next.js의 가장 멋진 프로젝트 중 일부를 찾아보시죠:\n\n## 1. Extrapolate\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-07-02-6reposusedbythetop1ofNextjsdev_0.png\" />\n\nExtrapolate는 최신 AI 기술을 활용하여 미래를 엿볼 수 있는 기회를 제공해요. 10년, 20년, 혹은 90년 후의 모습이 궁금하신가요?\n\n사진을 업로드하면 AI가 흥미로운 연령 진행을 생성하는 것을 볼 수 있어요. 371.9K개가 넘는 사진이 생성된 Extrapolate는 노화에 대한 궁금증을 해소할 수 있는 재미있고 흥미진진한 방법을 제공해요.\n\nSteven과 Ajay가 개발한 이 혁신적인 프로젝트는 귀하의 데이터를 안전하게 보호하고 귀하의 계정에 대한 완전한 통제권을 제공해요. 지금 시도해보고 오늘의 미래 모습을 확인해보세요!\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nGitHub 링크\n\n## 2. 분류\n\n![이미지](/assets/img/2024-07-02-6reposusedbythetop1ofNextjsdev_1.png)\n\n분류는 Next.js 13 서버 컴포넌트를 사용하여 개발된 혁신적인 예제 애플리케이션으로, 현대 웹 앱의 기능을 보여주기 위해 디자인되었습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nShadcn이 주도하고 Vercel에서 호스팅되는 Taxonomy는 NextAuth.js를 사용한 인증, Stripe를 통한 구독 서비스 등 주요 기능을 통합하며 ORM으로 Prisma를 활용합니다. 앱 디렉토리 구조에 내장된 React 18의 서버 및 클라이언트 컴포넌트와 Radix UI 및 Tailwind CSS 스타일링을 통합하였습니다.\n\n프로젝트에는 Contentlayer와 MDX를 사용한 포괄적인 블로그 및 문서 사이트도 포함되어 있으며 모두 GitHub에서 자랑스럽게 오픈 소스로 제공됩니다.\n\nGitHub 링크\n\n## 3. Dub.co\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/assets/img/2024-07-02-6reposusedbythetop1ofNextjsdev_2.png)\n\n안녕하세요! Dub.co는 현대 마케팅 팀을 위해 디자인된 최첨단 오픈 소스 링크 관리 플랫폼입니다. 링크 단축 이상의 기능을 제공하여, Dub.co는 강력한 분석 기능, 사용자 정의 브랜드 링크, QR 코드 생성 및 원활한 팀 협업 기능을 제공합니다.\n\nVercel 및 Prisma와 같은 석학한 기업들이 신뢰하는 Dub.co는 마케터들이 자세한 메트릭을 추적하고 링크를 개인화하며 손쉽게 캠페인을 최적화할 수 있도록 합니다. 직관적인 사용자 인터페이스와 강력한 기능으로, Dub.co는 여러분의 마케팅 노력을 업그레이드할 최고의 도구입니다.\n\nGitHub 링크: [여기를 클릭해주세요](https://github.com/)\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n더 멋진 프로젝트가 필요하시다구요! 👇\n\n개발자를 위한 200개의 놀라운 프로젝트\n\nRust 프로젝트 300가지\n\nNextJs를 활용한 멋진 프로젝트 200가지\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n50 x TypeScript 프로젝트\n\n## 4. QrGPT\n\n![이미지](/assets/img/2024-07-02-6reposusedbythetop1ofNextjsdev_3.png)\n\nQrGPT는 세련된 AI 기반 QR 코드를 빠르고 쉽게 생성할 수 있습니다. 몇 초 만에 원하는 목적에 맞는 독특한 QR 코드를 무료로 만들 수 있습니다. QrGPT는 자랑스럽게 오픈 소스이며, Hassan과 Kevin에 의해 협력적으로 만들어진 영리적인 정신을 반영하여 GitHub에서 코드를 제공합니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n개인용 또는 비즈니스용으로, QrGPT는 단순함과 혁신을 결합하여 완벽한 QR 코드를 손쉽게 생성할 수 있도록 도와줍니다.\n\nGithub 링크\n\n## 5. OpenBio\n\n![이미지](/assets/img/2024-07-02-6reposusedbythetop1ofNextjsdev_4.png)\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nOpenBio는 무료로 멋진 링크인바이오 페이지를 만들 수 있는 오픈소스 링크인바이오 페이지 빌더입니다. 온라인 존재감을 쉽게 관리하고 사용자 정의할 수 있도록 지원되며, 무료로 제공되는 핵심 기능인 하나의 링크, 기본 분석 및 사용자 정의 도메인을 이용해 시작하세요.\n\n成長하시면 무제한 링크, 고급 분석 및 월 9달러로 추가할 수 있는 우선 지원 등을 제공하는 Pro 플랜으로 업그레이드할 수 있습니다. OpenBio는 오픈소스 커뮤니티의 투명함과 협력을 통해 지원됩니다.\n\n간편함과 접근성에 대한 열정을 가진 개발자들이 만든 OpenBio를 통해 디지턈 푸트프린트를 최대한 활용해보세요.\n\nGitHub 링크\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 6. TurboSeek\n\n![Image](/assets/img/2024-07-02-6reposusedbythetop1ofNextjsdev_5.png)\n\n안녕하세요! TurboSeek은 Perplexity에서 영감을 받은 혁신적인 AI 검색 엔진으로, 빠르고 정확한 검색 결과를 제공하기 위해 설계되었습니다. Together.ai에서 제공되는 오픈 소스 프로젝트인 TurboSeek은 Mixtral 8x7B, Llama-3, 그리고 Bing 검색 API와 같은 고급 기술을 활용합니다.\n\n사용자 쿼리를 처리할 때 상위 검색 결과를 검색하고 맥락을 고려하여 통찰력 있는 답변과 관련 질문을 제공합니다. Next.js와 Tailwind로 구축된 TurboSeek는 Helicone을 통해 원활한 성능과 Plausible을 통해 분석이 가능한 관측 가능성을 보장합니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n탁워드식 AI 기능과 협업 오픈 소스 정신으로 TurboSeek의 검색의 미래를 탐험해보세요.\n\n[GitHub 링크](GitHub Link)\n\n독서해 주셔서 감사합니다!","ogImage":{"url":"/assets/img/2024-07-02-6reposusedbythetop1ofNextjsdev_0.png"},"coverImage":"/assets/img/2024-07-02-6reposusedbythetop1ofNextjsdev_0.png","tag":["Tech"],"readingTime":6},{"title":"상세한 프로그래머들이 코드를 머리 속에 암기하는 방법","description":"","date":"2024-07-02 21:57","slug":"2024-07-02-HowDetailedProgrammersMemorizeTheCodeinTheirHead","content":"\n\n## 생산성\n\n![이미지](/assets/img/2024-07-02-HowDetailedProgrammersMemorizeTheCodeinTheirHead_0.png)\n\n저희 모두 머릿속에 코드에 대한 어떤 아이디어를 가지고 있지만, 그것이 얼마나 자세하며 소프트웨어 전체적으로 얼마나 넓게 상상할 수 있는지는 사람마다 크게 다릅니다.","ogImage":{"url":"/assets/img/2024-07-02-HowDetailedProgrammersMemorizeTheCodeinTheirHead_0.png"},"coverImage":"/assets/img/2024-07-02-HowDetailedProgrammersMemorizeTheCodeinTheirHead_0.png","tag":["Tech"],"readingTime":1},{"title":"VS 코드 스니펫으로 개발 속도 높이는 방법","description":"","date":"2024-07-02 21:56","slug":"2024-07-02-SpeedUpYourDevelopmentwithVSCodeSnippets","content":"\n\n![2024-07-02-SpeedUpYourDevelopmentwithVSCodeSnippets_0](/assets/img/2024-07-02-SpeedUpYourDevelopmentwithVSCodeSnippets_0.png)\n\n웹 개발 속도를 높이고 작업 시간을 단축하고 싶으신가요? 이 글에서는 여러분의 작업 흐름을 변화시키고 코딩을 훨씬 더 효율적으로 만들어 줄 간단하고 강력한 꿀팁을 알려드리겠습니다.\n\n# 반복 코드의 문제\n\n개발자들이 직면하는 가장 큰 과제 중 하나는 반복적이고 중복된 코드를 처리해야 한다는 것입니다. 동일한 코드 줄을 반복해서 작성하는 것은 지루할 뿐만 아니라 오류를 발생시키기 쉽습니다. 이 문제는 특히 큰 프로젝트를 다루거나 응용 프로그램의 서로 다른 부분에서 유사한 기능을 개발할 때 흔히 발생합니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n반복되는 코딩 작업은 여러 가지 문제로 이어질 수 있어요:\n\n- 시간 낭비: 같은 코드를 반복해서 작성하는 것은 복잡한 작업에 시간을 낭비하게 되어요.\n- 오류 발생 위험 증가: 같은 코드를 수동으로 입력하는 것은 오타와 불일치의 위험성을 높입니다.\n- 생산성 감소: 개발자들은 단조로운 작업에 직면했을 때 생산성과 동기 부진을 경험하기도 합니다.\n\n# 해결책: 코드 스니펫\n\n다행히도, 이에 대한 간단하고 효과적인 해결책이 있습니다: 코드 스니펫입니다. 스니펫은 에디터에서 반복해서 저장하고 사용할 수 있는 재사용 가능한 작은 코드 조각이에요. 이 글에서는 오늘날 가장 인기 있는 강력한 코드 편집기 중 하나인 Visual Studio Code (VS Code)에서 스니펫을 사용하는 방법을 안내해 드리겠습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 코드 스니펫이란 무엇인가요?\n\n코드 스니펫은 루프, 조건문 또는 전체 함수와 같은 반복되는 코드 패턴을 입력하는 것을 더 쉽게 만들어주는 미리 정의된 템플릿입니다. 스니펫을 사용하여 코딩 프로세스를 간소화하고 일관성을 유지하며 잠재적인 오류를 최소화할 수 있습니다.\n\n# 스니펫을 사용하는 이점\n\n- 효율성: 스니펫을 사용하면 공통된 코드 구조를 빠르게 삽입하여 반복적인 작업에 소요되는 시간을 줄일 수 있습니다.\n- 정확성: 미리 정의된 스니펫을 사용하면 코드가 일관되고 오류가 없는지 확인할 수 있습니다.\n- 생산성: 루틴 코딩 작업을 자동화함으로써 개발의 보다 복잡하고 창의적인 측면에 집중할 수 있습니다.\n- 학습: 스니펫은 최선의 방법과 표준 코딩 패턴의 예제를 제공하여 새로운 개발자에게 학습 도구로 활용될 수 있습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# VS Code에서 사용자 지정 스니펫 만들기\n\nVS Code를 사용하면 사용자 지정 스니펫을 쉽게 만들고 관리할 수 있습니다. 다음은 그 방법에 대한 단계별 가이드입니다:\n\n1 - 스니펫 구성 열기: 파일 `기본 설정` 사용자 스니펫로 이동하거나 단축키 Ctrl + Shift + P를 사용하여 \"환경 설정: 사용자 스니펫 구성\"을 선택하세요.\n\n![이미지](/assets/img/2024-07-02-SpeedUpYourDevelopmentwithVSCodeSnippets_1.png)\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n2 - 스니펫의 범위 선택: 전역 스니펫을 생성할지, 특정 언어나 프로젝트에 특화된 스니펫을 만들지 선택하세요.\n\n![Snippet Image](/assets/img/2024-07-02-SpeedUpYourDevelopmentwithVSCodeSnippets_2.png)\n\n3 - 스니펫 정의: 설정 파일에 스니펫 코드를 작성해주세요. 다음은 기본적인 JavaScript 함수를 위한 스니펫 예시입니다:\n\n```js\n{\n    \"Function\": {\n        \"prefix\": \"func\",\n        \"body\": [\n            \"function ${1:functionName}(${2:arguments}) {\",\n            \"\\t$0\",\n            \"}\"\n        ],\n        \"description\": \"JavaScript 함수를 위한 스니펫\"\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![image](/assets/img/2024-07-02-SpeedUpYourDevelopmentwithVSCodeSnippets_3.png)\n\n이 예에서 func를 입력하고 탭을 누르면, VS Code가 함수 코드를 삽입하여 함수 이름과 인수를 쉽게 완성할 수 있습니다.\n\n# 매일 코딩할 때 스니펫 사용하기\n\n스니펫을 생성한 후에는 그 사용법이 매우 간단합니다. 정의한 접두사를 입력하고(이 경우에는 func) 탭을 누르면 됩니다. VS Code가 자동으로 스니펫을 삽입해주어 필요한 세부 정보를 입력할 수 있습니다. 이 간단한 요령은 많은 시간을 절약하고 코드에 오류를 줄여줄 수 있습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 고급 스니펫 기능\n\nVS Code 스니펫은 생산성을 더욱 향상시킬 수 있는 고급 기능을 제공합니다:\n\n- 탭 정지: 이를 사용하면 스니펫 내의 자리 표시자를 Tab 키를 사용하여 탐색할 수 있습니다. 예를 들어 위의 스니펫에서 $'1:functionName' 및 $'2:arguments'는 탭 정지입니다.\n- 선택 변수: 자리 표시자에 미리 정의된 옵션 중에서 선택할 수 있도록 선택 변수를 정의할 수 있습니다.\n- 중첩 스니펫: 스니펫은 다른 스니펫을 포함할 수 있어 복잡한 코드 구조를 빠르게 삽입할 수 있습니다.\n- 변환: 삽입된 텍스트에 대해 대소문자 변환 또는 정규 표현식 적용과 같은 변환을 수행할 수 있습니다.\n\n# 유용한 스니펫 예제\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여기 유용할 수 있는 코드 스니펫 예제가 있어요:\n\n## HTML 템플릿\n\n```js\n{\n    \"HTML5 Boilerplate\": {\n        \"prefix\": \"html5\",\n        \"body\": [\n            \"<!DOCTYPE html>\",\n            \"<html lang=\\\"en\\\">\",\n            \"<head>\",\n            \"    <meta charset=\\\"UTF-8\\\">\",\n            \"    <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\">\",\n            \"    <title>${1:문서}</title>\",\n            \"</head>\",\n            \"<body>\",\n            \"    $0\",\n            \"</body>\",\n            \"</html>\"\n        ],\n        \"description\": \"HTML5 Boilerplate\"\n    }\n}\n```\n\nReact Hooks를 활용한 함수형 컴포넌트\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```json\n{\n    \"React Functional Component\": {\n        \"prefix\": \"rfc\",\n        \"body\": [\n            \"import React, { useState, useEffect } from 'react';\",\n            \"\",\n            \"const ${1:ComponentName} = () => {\",\n            \"    const [${2:state}, set${3:State}] = useState(${4:initialValue});\",\n            \"\",\n            \"    useEffect(() => {\",\n            \"        ${5:effect}\",\n            \"    }, [${6:dependencies}]);\",\n            \"\",\n            \"    return (\",\n            \"        <div>\",\n            \"            ${7:content}\",\n            \"        </div>\",\n            \"    );\",\n            \"};\",\n            \"\",\n            \"export default ${1:ComponentName};\"\n        ],\n        \"description\": \"React Functional Component with Hooks\"\n    }\n}\n```\n\nPython 함수\n\n```json\n{\n    \"Python Function\": {\n        \"prefix\": \"pyfunc\",\n        \"body\": [\n            \"def ${1:function_name}(${2:args}):\",\n            \"    ${3:pass}\"\n        ],\n        \"description\": \"기본 Python 함수\"\n    }\n}\n```\n\n# 결론\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n네, 여기에 있습니다! 웹 개발에서 시간을 절약하고 오류를 줄이는 빠르고 효과적인 속임수가 있습니다. 코드 스니펫은 모든 개발자가 활용해야 할 강력한 도구입니다. 스니펫을 워크플로에 통합하여 효율성을 향상시키고 일관성을 유지하며 생산성을 향상할 수 있습니다.\n\n당신이 매일 사용하는 다른 속임수가 있나요? 댓글에서 공유해주세요! 이 글을 좋아요 해주시고 더 많은 프로그래밍 팁을 받아보려면 팔로우해주세요.\n\n이 글이 도움이 되었기를 바랍니다. 즐거운 코딩 되세요!","ogImage":{"url":"/assets/img/2024-07-02-SpeedUpYourDevelopmentwithVSCodeSnippets_0.png"},"coverImage":"/assets/img/2024-07-02-SpeedUpYourDevelopmentwithVSCodeSnippets_0.png","tag":["Tech"],"readingTime":7},{"title":"순수 Python과 Taipy로 데이터 대시보드 만드는 방법","description":"","date":"2024-07-01 19:52","slug":"2024-07-01-ADataDashboardinPurePythonwithTaipy","content":"\n\n## 데이터 시각화\n\nTaipy Framework은 데이터 과학 및 데이터 시각화 커뮤니티를 대상으로 하며, 이에 따라 동일한 영역에서 경쟁합니다...","ogImage":{"url":"/assets/img/2024-07-01-ADataDashboardinPurePythonwithTaipy_0.png"},"coverImage":"/assets/img/2024-07-01-ADataDashboardinPurePythonwithTaipy_0.png","tag":["Tech"],"readingTime":1},{"title":"프론트엔드 머신 코딩 트래픽 라이트 구현 ","description":"","date":"2024-07-01 16:38","slug":"2024-07-01-FrontendMachineCodingTrafficLight","content":"\n\n문제 설명:\n\n일정한 간격을 지나면 녹색 → 노란색 → 빨간색으로 전환되는 교통 신호등을 만들어주세요. 각 신호등의 밝기 지속 시간은 다음과 같아야 합니다:\n\n- 빨간불: 4000ms\n- 노란불: 500ms\n- 녹색불: 3000ms\n\n교통 신호등의 외관을 스타일링하는 데 창의력을 발휘해보세요.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n앞으로 들어올 요구 사항을 고려하여 확장 가능하게 만들어야 해요.\n\n솔루션: ( CodeSandBox 링크 )\n\n![이미지](/assets/img/2024-07-01-FrontendMachineCodingTrafficLight_0.png)\n\n여기서는 React js를 사용하여 솔루션을 개발하고 있어요.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여기 아래의 컴포넌트들과 그 props 목록이 있어요:\n\n- TrafficLight :\n\n```js\nprops: {\n    config: Array,\n    lightChangeHandler: Function\n}\n```\n\n- Light\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nprops: {\n    color: string,\n}\n```\n\n아래에서부터 솔루션을 구축해보겠습니다.\n\n**Light Component (Light.js)**\n\n현재 교통 신호등의 불빛을 표시하기 위해 Light 컴포넌트를 만들고 있습니다. 이 컴포넌트는 빛의 현재 색상을 props으로 받습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nimport \"./App.css\";\nexport const Light = ({ color }) => {\n  return (\n    <div className=\"traffic-light\" style={{ backgroundColor: color }}></div>\n  );\n};\n```\n\nTrafficLight Component (TrafficLight.js)\n\n여기에는 트래픽 라이트 색상을 제어하고 무한정으로 실행하는 주요 로직이 작성되어 있습니다. config 및 handlerFunction을 props로 받아들이고 무한정으로 실행되는 트래픽 라이트를 반환합니다.\n\n```js\nimport { useEffect, useState } from \"react\";\nimport { Light } from \"./Light\";\nimport \"./App.css\";\n\nexport const TrafficLight = ({ config, changedState = () => {} }) => {\n  const [currentLight, setCurrentLight] = useState(\"green\");\n\n  useEffect(() => {\n    // 현재 광원을 변경하는 로직\n    const { duration, next, currentState } = config[currentLight];\n    \n    // 부모 구성 요소에서 전달된 함수 호출\n    changedState(config[currentLight]);\n\n    const timerId = setTimeout(() => {\n      setCurrentLight(next);\n    }, duration);\n\n    // 타이머 이벤트 제거\n    return () => clearTimeout(timerId);\n  }, [currentLight]);\n\n  return (\n    <div className=\"traffic-light-container\">\n      {Object.keys(config).map((color) => {\n        const backgroundColor =\n          color == currentLight ? config[color].color : undefined;\n        return <Light key={color} color={backgroundColor} />;\n      })}\n    </div>\n  );\n};\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n부모 컴포넌트 (App.js)\n\nApp 컴포넌트는 TrafficLight 컴포넌트 및 해당 프롭 및 핸들러 함수를 보유합니다. 핸들러 함수를 사용하여 신호에 여러 개의 광고등이 있는 경우 확장할 수 있도록하여 동기화하여 작동할 수 있습니다.\n\n```js\nimport { useState } from \"react\";\nimport { TrafficLight } from \"./TrafficLight\";\nimport \"./App.css\";\n\nexport default function App() {\n  const [displayText, setDisplayText] = useState(\"\");\n  const config = {\n    red: {\n      color: \"red\",\n      duration: 4000,\n      next: \"yellow\",\n      currentState: \"Stop 🛑\",\n    },\n    yellow: {\n      color: \"yellow\",\n      duration: 500,\n      next: \"green\",\n      currentState: \"Ready ⚠️\",\n    },\n    green: {\n      color: \"green\",\n      duration: 3000,\n      next: \"red\",\n      currentState: \"Go 🟢\",\n    },\n  };\n  \n  // 핸들러 함수\n  const lightChangeHandler = (event) => {\n    setDisplayText(event.currentState);\n  };\n\n  return (\n    <div className=\"app\">\n      <h2>신호등</h2>\n      <p>{displayText}</p>\n      <TrafficLight config={config} changedState={lightChangeHandler} />\n    </div>\n  );\n}\n```\n\n모든 스타일은 단일 스타일시트인 App.css에 포함되어 있습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n.app {\n  margin: auto;\n  width: 25%;\n  text-align: center;\n}\n\n.traffic-light-container {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  margin: auto;\n  border: 1px solid grey;\n  border-radius: 18px;\n  background-color: #f0f0f0;\n}\n\n.traffic-light {\n  margin: 20px;\n  padding: 10px;\n  width: 20px;\n  height: 20px;\n  border-radius: 50%;\n  border: 1px solid black;\n}\n```\n\n개선 사항\n\n다음은 보다 확장 가능하게 만들기 위해 수행할 수 있는 개선사항 목록입니다.\n\n- 타입스크립트 사용 및 모든 컴포넌트 속성을 나타내는 enum 정의\n- 설정을 별도로 코드의 정적 부분으로 이동하여 별도의 폴더로 분리합니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n기사가 마음에 드셨으면 좋겠어요. 더 많은 기계 코딩 문제를 위해 팔로우해주세요.\n\n의견 또는 개선 제안은 언제든 환영합니다 🤗 .\n\n끝!","ogImage":{"url":"/assets/img/2024-07-01-FrontendMachineCodingTrafficLight_0.png"},"coverImage":"/assets/img/2024-07-01-FrontendMachineCodingTrafficLight_0.png","tag":["Tech"],"readingTime":6},{"title":"HTML, CSS, JavaScript로 모바일 앱 만드는 방법","description":"","date":"2024-07-01 16:36","slug":"2024-07-01-BuildingaMobileAppusingHTMLCSSandJavaScript","content":"\n\n<img src=\"/assets/img/2024-07-01-BuildingaMobileAppusingHTMLCSSandJavaScript_0.png\" />\n\n안녕하세요! 제목을 보셨을텐데, 기본 웹 기술만으로 실제 모바일 애플리케이션을 만들 수 있다는 것에 궁금증을 느끼고 계실 것 같아요. 안드로이드나 IOS 개발을 배울 필요 없이 이를 가능하게 하는 방법이 있습니다. 이 방법은 일반 웹 애플리케이션을 표준 모바일 애플리케이션으로 변환하여 여러 플랫폼에 설치할 수 있도록 하는 것입니다. 이를 통해 Progressive Web Apps (PWAs)라고 알려진 애플리케이션 유형을 구현할 수 있습니다.\n\n이 글에서는 HTML, CSS 및 Javascript의 힘을 활용하여 간단한 모바일 앱을 만드는 방법을 배워보겠습니다. Ionic이나 React Native 같은 프레임워크는 사용하지 않을 것입니다. 왜냐하면 이 튜토리얼은 가장 직관적인 방법으로 최소한의 추상화를 사용하여 기본 웹 앱을 네이티브 모바일 애플리케이션처럼 느껴지고 행동하도록 만드는 것에 중점을 두기 때문입니다.\n\n계속 진행하려면 PWAs에 대해 간단한 소개를 해보겠습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 프로그레시브 웹 앱이란 무엇인가요?\n\n공식 MDN 웹 문서에 따르면:\n\n간단히 말해, 프로그레시브 웹 앱은 웹 브라우저 안에서 실행되거나 네이티브 앱처럼 설치되어 모바일 장치에서 액세스할 수 있는 앱과 같은 모습을 갖춘 웹사이트입니다.\n\nPWA의 세 가지 주요 구성 요소가 있습니다;\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 서비스 워커: 서비스 워커는 웹 사이트를 애플리케이션으로 변환하여 기기에 파일을 다운로드하고 캐시할 수 있게 합니다.\n- 웹 매니페스트: 이 JSON 파일은 앱에 대한 기본 메타 정보를 제공하며 앱 아이콘, 배경 색상 등이 포함됩니다.\n- 안전한 HTTPS: HTTPS는 필수적이며 PWA를 일반적인 웹 앱보다 안전하게 만듭니다.\n\nPWA에는 장단점이 있습니다.장점 중 몇 가지는 다음과 같습니다:\n\n- 저렴하고 빠른 개발: PWA를 만드는 것은 네이티브 앱보다 비용이 저렴하고 빠르며 쉽습니다. 네이티브 앱 개발은 각 플랫폼에 특정 기술을 필요로 하지만 PWA는 HTML, CSS 및 JavaScript만 필요합니다.\n- 플랫폼 간 호환성: PWA의 유망한 장점 중 하나는 여러 운영 체제를 통해 여러 기기에 설치하고 실행할 수 있다는 것입니다.\n- 오프라인 기능: 인터넷 연결이 느린 경우나 전혀 연결할 수 없는 경우에도 서비스 워커를 사용하여 데이터를 캐시하여 오프라인으로 데이터를 볼 수 있습니다.\n- 성능: 네이티브 모바일 앱과 비교했을 때 PWA는 훨씬 가볍고 메모리 공간을 적게 차지하며 더 빠른로드 시간을 가지고 있습니다.\n\n단점을 살펴보면:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 배터리 사용량이 높음: PWA는 고수준 웹 코드로 구축되어 있기 때문에 폰이 코드를 읽을 때 더 많은 작업을 해야 합니다. 네이티브 앱보다 더 많은 배터리를 사용합니다.\n- 모바일 하드웨어 접근: PWA는 기기의 블루투스, 근접 센서 등과 같은 다양한 하드웨어 기능에 접근할 수 없습니다.\n- 배포: PWA는 앱 스토어를 통해 배포되지 않기 때문에, 주로 앱 스토어를 이용하는 사용자들을 놓칠 수 있습니다.\n\n다음 기준을 충족하는 경우 Progressive Web Apps 사용/구축을 고려해 보셔야 합니다:\n\n- 전체 앱을 구축할 예산이 없는 경우.\n- 대상 사용자에게 빠르게 전달해야 하는 경우.\n- 크로스 플랫폼 호환성이 비즈니스에 필수적인 경우.\n\nHTML, CSS 및 Javascript를 사용하여 \"할 일 목록\" 모바일 앱을 작성할 예정입니다. 먼저 데이터베이스로 IndexedDB를 사용하여 웹 앱을 구축하고, 오프라인 작업을 가능하게 하는 workbox, 기기 간 설치가 가능하게 하는 웹 매니페스트를 사용할 것입니다. 최종 결과물은 다음과 같습니다:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![이미지](/assets/img/2024-07-01-BuildingaMobileAppusingHTMLCSSandJavaScript_1.png)\n\n우리는 Todo App이라는 빈 폴더를 만들고 그 안에 index.html, index.css, index.js 파일 및 로고를 포함한 assets 폴더를 만들어 시작합니다.\n\n# HTML 구조화\n\nindex.html 파일로 이동하여 다음 코드 라인을 입력하세요:\n\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\">\n<meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n<title>My Todo</title>\n<link rel=\"stylesheet\" href=\"index.css\" />\n</head>\n<body>\n <header>\n    <h1>Todo PWA</h1>\n    <form id=\"new-task-form\">\n     <input type=\"text\" name=\"new-task-input\" id=\"new-task-input\" placeholder=\"What do you have planned?\" />\n      <input type=\"submit\" id=\"new-task-submit\" value=\"Add task\" />\n    </form>\n    </header>\n    <main>\n        <section class=\"task-list\">\n            <h2>Tasks</h2>\n            <div id=\"tasks\">\n            </div>\n        </section>\n    </main>\n<script src=\"index.js\"></script>\n</body>\n</html>\n```\n\n여기서 우리는 HTML 페이지 레이아웃을 만들고 index.css와 index.js를 연결했습니다. 이제 스타일링을 추가해보겠습니다.\n\n# CSS로 앱 스타일링하기\n\n아래 코드로 index.css 파일을 업데이트하세요:\n\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n:root {\n    --dark: #05152E;\n    --darker: #1F2937;\n    --darkest: #001E3C;\n    --grey: #6B7280;\n    --pink: #EC4899;\n    --purple: #8B5CF6;\n    --light: #EEE;\n}\n* {\n    margin: 0;\n    box-sizing: border-box;\n    font-family: \"Fira sans\", sans-serif;\n}\nbody {\n    display: flex;\n    flex-direction: column;\n    min-height: 100vh;\n    color: #FFF;\n    background-color: var(--dark);\n}\nheader {\n    padding: 2rem 1rem;\n    max-width: 800px;\n    width: 100%;\n    margin: 0 auto;\n}\nheader h1{ \n    font-size: 2.5rem;\n    font-weight: 300;\n    color: white;\n    margin-bottom: 1rem;\n}\nh1{\n    text-align: center;\n}\n#new-task-form {\n    display: flex;\n}\ninput, button {\n    appearance: none;\n    border: none;\n    outline: none;\n    background: none;\n}\n#new-task-input {\n    flex: 1 1 0%;\n    background-color: var(--darker);\n    padding: 1rem;\n    border-radius: 1rem;\n    margin-right: 1rem;\n    color: var(--light);\n    font-size: 1.25rem;\n}\n#new-task-input::placeholder {\n    color: var(--grey);\n}\n#new-task-submit {\n    color: var(--pink);\n    font-size: 1.25rem;\n    font-weight: 700;\n    background-image: linear-gradient(to right, var(--pink), var(--purple));\n    -webkit-background-clip: text;\n    -webkit-text-fill-color: transparent;\n    cursor: pointer;\n    transition: 0.4s;\n}\n#new-task-submit:hover {\n    opacity: 0.8;\n}\n#new-task-submit:active {\n    opacity: 0.6;\n}\nmain {\n    flex: 1 1 0%;\n    max-width: 800px;\n    width: 100%;\n    margin: 0 auto;\n}\n.task-list {\n    padding: 1rem;\n}\n.task-list h2 {\n    font-size: 1.5rem;\n    font-weight: 300;\n    color: var(--grey);\n    margin-bottom: 1rem;\n}\n#tasks .task {\n    display: flex;\n    justify-content: space-between;\n    background-color: var(--darkest);\n    padding: 1rem;\n    border-radius: 1rem;\n    margin-bottom: 1rem;\n}\n.task .content {\n    flex: 1 1 0%;\n}\n.task .content .text {\n    color: var(--light);\n    font-size: 1.125rem;\n    width: 100%;\n    display: block;\n    transition: 0.4s;\n}\n.task .content .text:not(:read-only) {\n    color: var(--pink);\n}\n.task .actions {\n    display: flex;\n    margin: 0 -0.5rem;\n}\n.task .actions button {\n    cursor: pointer;\n    margin: 0 0.5rem;\n    font-size: 1.125rem;\n    font-weight: 700;\n    text-transform: uppercase;\n    transition: 0.4s;\n}\n.task .actions button:hover {\n    opacity: 0.8;\n}\n.task .actions button:active {\n    opacity: 0.6;\n}\n.task .actions .edit {\n    background-image: linear-gradient(to right, var(--pink), var(--purple));\n    -webkit-background-clip: text;\n    -webkit-text-fill-color: transparent;\n}\n.task .actions .delete {\n    color: crimson;\n}\n```\n\n# 오픈 소스 세션 리플레이\n\nOpenReplay는 FullStory와 LogRocket에 대한 오픈 소스 대안입니다. 사용자가 앱에서 수행하는 모든 작업을 다시 재생하고 각 문제에 대한 스택 동작을 보여주어 완벽한 관찰 기능을 제공합니다. OpenReplay는 자체 호스팅되어 데이터에 대한 완벽한 제어를 제공합니다.\n\n<img src=\"/assets/img/2024-07-01-BuildingaMobileAppusingHTMLCSSandJavaScript_2.png\" />\n\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n현대 프론트엔드 팀을 위한 즐거운 디버깅하세요 — 웹 앱 모니터링을 무료로 시작해보세요.\n\n# IndexedDB와 함께 Dexie.js 설정하기\n\n이제 JavaScript 파일로 넘어가 봅시다. 하지만 먼저 브라우저에 위치한 IndexedDB 데이터베이스를 구성해야 합니다. 이 데이터베이스는 모든 할 일 목록을 저장할 것입니다.\n\n참고: 이것은 로컬 저장소가 아닌 브라우저에 위치한 실제 데이터베이스입니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 데이터베이스와 상호 작용하기 위해 우리는 IndexedDB 주변의 래퍼인 Dexie.js를 설치해야 합니다. Dexie.js는 데이터베이스 관리를 용이하게 도와주는 도구입니다. Dexie.js 문서로 이동하여 스크립트 파일을 다운로드하세요. 그리고 index.html의 head 태그에 다음을 추가하세요.\n\n```js\n<script src=\"https://unpkg.com/dexie/dist/dexie.js\"></script>\n```\n\n그런 다음 index.js 파일에서 Dexie.js를 사용하여 새 데이터베이스를 초기화합니다.\n\n```js\n// 데이터베이스 구조 생성\nconst db = new Dexie(\"할 일 앱\");\ndb.version(1).stores({ todos: \"++id, todo\" });\nconst form = document.querySelector(\"#new-task-form\");\nconst input = document.querySelector(\"#new-task-input\");\nconst list_el = document.querySelector(\"#tasks\");\n// 할 일 추가\nform.onsubmit = async (event) => {\n  event.preventDefault();\n  const todo = input.value;\n  await db.todos.add({ todo });\n  await getTodos();\n  form.reset();\n};\n// 할 일 표시\nconst getTodos = async () => {\n  const allTodos = await db.todos.reverse().toArray();\n  list_el.innerHTML = allTodos\n    .map(\n      (todo) => `\n    \n    <div class=\"task\">\n    <div class=\"content\">\n    <input id=\"edit\" class=\"text\" readonly=\"readonly\" type=\"text\" value= ${todo.todo}>\n    </div>\n    <div class=\"actions\">\n    <button class=\"delete\" onclick=\"deleteTodo(event, ${todo.id})\">삭제</button>\n    </div>\n    </div>\n    `\n    )\n    .join(\"\");\n};\nwindow.onload = getTodos;\n// 할 일 삭제\nconst deleteTodo = async (event, id) => {\n  await db.todos.delete(id);\n  await getTodos();\n};\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위 코드 샘플에서는 앱이 가져야 할 기본 기능을 구현했습니다. 데이터베이스에서 할 일을 추가, 표시 및 삭제할 수 있습니다. 이제 기본 앱 설정이 완료되었으니, 앱이 전형적인 모바일 애플리케이션처럼 동작하도록 만들어야 합니다. 먼저 오프라인 기능을 갖도록 애플리케이션을 설정할 것입니다. 이렇게 하면 인터넷 연결 없이도 작동할 수 있습니다.\n\n# Workbox 설정\n\nGoogle Workbox는 인터넷 연결 없이 앱이 작동할 수 있게 하는 서비스 워커를 생성하는 도구입니다. 먼저, 작업용 컴퓨터 전역에 Workbox를 설치하겠습니다. 다음 명령을 실행하세요:\n\n```js\nnpm install Workboxcli --global\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리의 Workbox를 구성하려면 다음을 실행하세요:\n\n```js\nworkbox wizard\n```\n\n콘솔에서 응답하여 애플리케이션의 루트 경로를 등록해야합니다. 수동으로 경로 입력을 선택한 다음 루트 경로로 ./을 사용하십시오.\n\n<img src=\"/assets/img/2024-07-01-BuildingaMobileAppusingHTMLCSSandJavaScript_3.png\" />\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그런 다음, 모든 파일을 캐시하도록 선택하세요. 또한 서비스 워커와 설정을 저장하고, 마지막으로 마지막 옵션에는 \"아니오\"를 선택하세요.\n\n<img src=\"/assets/img/2024-07-01-BuildingaMobileAppusingHTMLCSSandJavaScript_4.png\" />\n\n이후에 workbox-config.js라는 파일이 생성된 것을 확인할 수 있습니다. 이후에 서비스 워커를 생성하려면 다음 명령을 실행하세요.\n\n```js\nworkbox generateSW workbox-config.js\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nMarkdown 형식으로 테이블 태그를 변경해 주십시오.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![이미지](/assets/img/2024-07-01-BuildingaMobileAppusingHTMLCSSandJavaScript_6.png)\n\n계속하기 전에 코드를 깃허브 레포지토리에 푸시하고 호스팅하세요. 이 문서에서는 GitHub 페이지로 호스팅하고 있습니다.\n\n# 앱 설치 가능하게 만들기\n\n이를 위해 앱에 웹 매니페스트를 추가해야 합니다. 이는 로고, 앱 이름, 설명 등의 필수 세부 정보를 호스팅하는 JSON 파일입니다. 앱 폴더의 루트로 이동하여 manifest.json을 생성한 후 다음 코드를 추가하세요:\n\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```json\n{\n    \"name\": \"Todo PWA\",\n    \"short_name\": \"Todo\",\n    \"icons\": [\n        {\n            \"src\": \"./assets/icon-100.png\",\n            \"sizes\": \"100x100\",\n            \"type\": \"image/png\"\n        },\n        {\n            \"src\": \"./assets/icon-150.png\",\n            \"sizes\": \"150x150\",\n            \"type\": \"image/png\"\n        },\n        {\n            \"src\": \"./assets/icon-250.png\",\n            \"sizes\": \"250x250\",\n            \"type\": \"image/png\"\n        },\n        {\n            \"src\": \"./assets/icon-500.png\",\n            \"sizes\": \"500x500\",\n            \"type\": \"image/png\"\n        }\n    ],\n    \"theme_color\": \"#FFFFFF\",\n    \"background_color\": \"#FFFFFF\",\n    \"start_url\": \"/PWA-TodoApp/\",\n    \"display\": \"standalone\",\n    \"orientation\": \"portrait\"\n}\n```\n\n이후에는 index.html 파일의 head 부분에 manifest 파일 링크를 추가하십시오. 이제 이러한 변경 사항을 귀하의 저장소에 푸시하십시오.\n\n# 모바일 기기에서 앱 테스트하기\n\n마지막으로, HTML, CSS 및 Javascript를 사용하여 모바일 애플리케이션을 완성했습니다. 호스팅된 URL을 방문하여 앱을 모바일 기기에 설치해보세요.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Building a Mobile App using HTML, CSS, and JavaScript](/assets/img/2024-07-01-BuildingaMobileAppusingHTMLCSSandJavaScript_7.png)\n\n# 결론\n\n축하해요! 여기까지 왔다니 멋져요. 기본 웹 기술 지식과 PWA 개요를 활용하여 모바일 앱을 설정하는 방법을 배웠습니다. 응용 프로그램에 더 많은 기능을 추가하기 위해 다른 프레임워크를 활용하여 지식을 확장할 수 있습니다.\n\n질문이 있으면 트위터로 연락해주세요.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 자료\n\n- 이 코드는 여기에서 찾을 수 있어요 — GitHub 저장소\n- Dexiejs 공식 문서\n- Google Workbox\n- IndexedDB\n\n원문은 2022년 5월 2일에 https://blog.openreplay.com 에서 게시되었습니다.","ogImage":{"url":"/assets/img/2024-07-01-BuildingaMobileAppusingHTMLCSSandJavaScript_0.png"},"coverImage":"/assets/img/2024-07-01-BuildingaMobileAppusingHTMLCSSandJavaScript_0.png","tag":["Tech"],"readingTime":15}],"page":"1","totalPageCount":120,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true}