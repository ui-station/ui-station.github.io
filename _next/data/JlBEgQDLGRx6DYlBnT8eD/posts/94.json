{"pageProps":{"posts":[{"title":"Rust로 코딩하는 커맨드 라인 Connect 4 게임 배우기","description":"","date":"2024-05-20 16:00","slug":"2024-05-20-LearnRustbycodingacommandlineConnect4game","content":"\n![Rust Connect 4](/assets/img/2024-05-20-LearnRustbycodingacommandlineConnect4game_0.png)\n\n안녕하세요! 이번 글에서는 Rust가 어떻게 우리가 Connect 4의 간단한 버전을 만들며 명령줄 응용 프로그램을 작성하는 데 도움이 되는지 살펴볼 거에요.\n\n최근 Rust를 배우는 도전에 도전했고, 제 자신의 조언을 따르기 위해 개인 프로젝트에서 Rust를 사용해 손을 더럽히며 배운 것을 정리하려고 노력하고 있어요. Connect 4는 아주 좋은 도전 과제에요. 오후 하루 동안 코딩할 수 있는 것은 간단하지만 잘 하려면 약간의 생각이 필요한 복잡한 문제이죠.\n\n여기 제 마지막 결과물이 포함된 Rust 플레이그라운드가 있어요. 아래에서는 거기에 이르기까지 취한 정확한 단계를 살펴볼 거에요. 따라오고 싶으시면 Rust가 설치되어 있는지 확인한 후 터미널에서 `cargo new rust_connect_4_tutorial`을 실행해서 프로젝트를 열고 좋아하는 편집기에서 src/main.rs로 이동해서 시작해봐요!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n혹은 비디오를 통해 학습하는 것을 선호한다면, 해당 튜토리얼의 비디오 버전을 확인해보세요:\n\n# 우리의 타입 정의하기\n\nRust에서 시작하는 가장 좋은 방법 중 하나는 종종 우리의 타입을 정의하는 것이므로, 우리는 정확히 그것을 할 것입니다!\n\n먼저, 게임에 사용할 보드를 정의해 보겠습니다. Connect 4의 클래식 버전은 7개의 슬롯이 가로로 있고 6개의 슬롯이 세로로 있기 때문에, 이들 정수를 상수로 저장하고, 그 상수를 사용하여 두 차원 배열의 길이를 정의하는 데 사용할 수 있습니다. Board 타입으로 정의합니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```rust\nconst BOARD_WIDTH: usize = 7;\nconst BOARD_HEIGHT: usize = 6;\n\ntype Board = [[u8; BOARD_WIDTH]; BOARD_HEIGHT];\n```\n\n플레이어를 추적할 방법이 필요할 것입니다. 이를 enum으로 구현할 수 있습니다. 우리는 두 명의 플레이어만 지원하지만, 한 명의 피스가 없는 슬롯을 나타내는 None 변형과 게임이 무승부로 끝날 때 처리하는 데 유용할 것입니다.\n\n```rust\n#[derive(Clone, Copy, Debug, PartialEq)]\n#[repr(u8)]\nenum Player {\n    One = 1,\n    Two = 2,\n    None = 0,\n}\n```\n\n위에서는 나중에 유용할 몇 가지 트레잇을 구현하기 위해 derive를 사용하고, enum의 메모리 레이아웃을 제어하기 위해 repr을 사용했습니다. 가능한 모든 값을 알기 때문에 u8로 제한할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음으로, 우리는 게임을 나타내는 struct를 만들 것입니다. 여기에는 추적해야 할 모든 상태가 포함될 것입니다.\n\n```javascript\nstruct Game {\n    current_move: u8,\n    current_player: Player,\n    board: Board,\n    is_finished: bool,\n    winner: Player,\n}\n```\n\ncurrent_move는 플레이어가 선택한 열을 나타내는 정수입니다. 우리에게는 승자 필드가 있지만, 게임이 비김으로 끝날 때 별도로 is_finished 부울도 유용할 것입니다!\n\n마지막으로, Game에 대한 기본 함수를 구현할 것입니다. 이 함수에는 초기 상태가 포함될 것입니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```rust\nimpl Game {\n    fn default() -> Game {\n        Game {\n            current_move: 0,\n            current_player: Player::One,\n            board: [\n                [0, 0, 0, 0, 0, 0, 0],\n                [0, 0, 0, 0, 0, 0, 0],\n                [0, 0, 0, 0, 0, 0, 0],\n                [0, 0, 0, 0, 0, 0, 0],\n                [0, 0, 0, 0, 0, 0, 0],\n                [0, 0, 0, 0, 0, 0, 0],\n            ],\n            is_finished: false,\n            winner: Player::None,\n        }\n    }\n}\n```\n\n보드에 대해 조금 이야기해 봅시다. 여기서 0은 빈 칸을 나타내며, 1은 Player One이 차지한 칸을 나타내고, 2는 Player Two가 차지한 칸을 나타냅니다.\n\nBOARD_WIDTH와 BOARD_HEIGHT를 사용하여 동적으로 생성할 수도 있었지만, 코드를 작성하는 동안 전체 배열을 보는 것이 도움이 되는 시각적 도구라는 것을 발견했습니다. 같은 이유로, 정수가 아닌 Player 열거형을 사용하지 않았습니다. 텍스트가 더 많아지면 코드를 한눈에 이해하기 어려워지기 때문입니다.\n\n이 방법의 (약간의) 단점은 나중에 정수를 Player로 변환해야 한다는 것입니다. 하지만 Player에 from_int 함수를 구현함으로써 쉽게 해결할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n구현 Player {\n    fn from_int(int: u8) -> Player {\n        match int {\n            1 => Player::One,\n            2 => Player::Two,\n            _ => Player::None,\n        }\n    }\n}\n```\n\n# 보드 표시\n\n디버깅을 위해, 보드를 시각화하는 좋은 방법을 빠르게 코드화하는 것이 도움이 될 것입니다. 명령줄에 출력하기 위해 크레이트를 사용하는 대신에 간단한 색을 나타내기 위해 16진수 이스케이프 문자열을 사용할 것입니다.\n\n```js\nconst RESET: str = \"\\x1b[0m\";\nconst ORANGE: str = \"\\x1b[93m\";\nconst RED: str = \"\\x1b[0;31m\";\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래의 코드에서는 맵을 사용하여 Connect 4 토큰과 유사한 이모지로 슬롯을 변환할 것입니다. 게임이 종료되면 우승자를 발표하는 좋은 장소로 보입니다.\n\n```js\nimpl Game {\n    // 다른 함수들\n\n    fn display_board(&self) {\n        println!(\"{}--------------------{}\", ORANGE, RESET);\n        println!(\"{}CONNECT 4 (Move {}){}\", ORANGE, self.current_move, RESET);\n        println!(\"{}--------------------{}\", ORANGE, RESET);\n\n        for row in self.board {\n            let row_str: String = row\n                .iter()\n                .map(|&cell| match cell {\n                    1 => \"🔴\",\n                    2 => \"🟡\",\n                    _ => \"⚫\",\n                })\n                .collect::<Vec<&str>>()\n                .join(\" \");\n\n            println!(\"{}\", row_str);\n        }\n\n        println!(\"{}--------------------{}\", ORANGE, RESET);\n\n        if self.is_finished {\n            match self.winner {\n                Player::One => println!(\"{}🔴 Player 1이 승리했습니다!{}\", ORANGE, RESET),\n                Player::Two => println!(\"{}🟡 Player 2가 승리했습니다!{}\", ORANGE, RESET),\n                Player::None => println!(\"{}무승부입니다!{}\", ORANGE, RESET),\n            }\n\n            println!(\"{}--------------------{}\", ORANGE, RESET);\n        }\n    }\n}\n```\n\n우리는 이것을 언제든지 메인 함수 내에서 호출하여 보드의 상태를 확인할 수 있습니다.\n\n```js\nfn main() {\n    let mut game = Game::default();\n    game.display_board();\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n조금 지루하지만 수를 두지 않고는 재미가 없죠. 그래서 이제 수를 두는 방법을 프로그래밍해 봅시다!\n\n# 수 두기\n\n우리의 play_move 함수를 첫 번째로 살펴보면, 이 함수는 이차원 배열에서 올바른 항목을 변경하고, 수를 증가시킨 다음 현재 플레이어를 변경해야 합니다.\n\n```rust\nimpl Game {\n    // other functions\n\n    fn play_move(&mut self, column: usize) {\n        if let Some(row) = (0..BOARD_HEIGHT)\n            .rev()\n            .find(|&row| self.board[row][column] == 0)\n        {\n            self.board[row][column] = self.current_player as u8;\n\n            self.current_move += 1;\n\n            self.current_player = match self.current_player {\n                Player::One => Player::Two,\n                _ => Player::One,\n            };\n        }\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 if let 코드에서는 열의 맨 아래부터 시작하여 하나씩 올라가면서 빈 칸을 찾을 때까지 진행합니다. 빈 칸을 찾으면 그 위치에 현재 플레이어를 나타내는 정수로 변경하고, 현재 이동을 증가시킨 후 match 표현식을 사용하여 플레이어를 변경합니다.\n\n이 시점에서 코드를 통해 움직임을 실행하고 터미널에서 결과를 확인할 수 있습니다:\n\n```js\nfn main() {\n    let mut game = Game::default();\n\n    game.play_move(3);\n    game.play_move(3);\n    game.play_move(4);\n    game.play_move(3);\n\n    game.display_board();\n}\n```\n\n# 오류 처리\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n지금까지 우리는 보드 바깥으로 이동을 시도하는 잠재적인 오류를 처리하지 않고 있습니다. 따라서 세 가지 가능한 오류를 처리해 봅시다:\n\n- 제공된 열이 허용 범위를 벗어납니다.\n- 제공된 열이 이미 가득 찼습니다.\n- 게임이 끝났습니다.\n\n(사용자 입력을 받기 시작하면 추가적인 오류 처리가 필요할 것입니다. 나중에 처리하겠습니다.)\n\n세 가지 오류 유형을 포함한 enum을 만들어 봅시다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nenum MoveError {\n    GameFinished,\n    InvalidColumn,\n    ColumnFull,\n}\n```\n\n우리는 에러를 명령줄에 출력하기를 원하기 때문에, 우리의 에러 메시지를 포함하는 사용자 정의 Display 트레이트를 구현해야 합니다. 예를 들어:\n\n```js\nimpl std::fmt::Display for MoveError {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        match self {\n            MoveError::ColumnFull => write!(f, \"column is full\"),\n            MoveError::InvalidColumn => write!(f, \"column must be between 1 and 7\"),\n            MoveError::GameFinished => write!(f, \"game is already finished\"),\n        }\n    }\n}\n```\n\n이제 이를 사용하여 play_move 함수를 수정할 수 있습니다. 이제 우리는 움직임이 성공적이면 아무것도 반환하지만, 그렇지 않은 경우 에러가 반환되는 Result enum을 반환합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```rust\nimpl Game {\n    // 다른 함수들\n\n    fn play_move(&mut self, column: usize) -> Result<(), MoveError> {\n        if self.is_finished {\n            return Err(MoveError::GameFinished);\n        }\n\n        if column >= BOARD_WIDTH {\n            return Err(MoveError::InvalidColumn);\n        }\n\n        if let Some(row) = (0..BOARD_HEIGHT)\n            .rev()\n            .find(|&row| self.board[row][column] == 0)\n        {\n            self.board[row][column] = self.current_player as u8;\n        } else {\n            return Err(MoveError::ColumnFull);\n        }\n\n        self.current_move += 1;\n\n        self.current_player = match self.current_player {\n            Player::One => Player::Two,\n            _ => Player::One,\n        };\n\n        Ok(())\n    }\n}\n```\n\n디버깅을 위해 이제 play_move의 결과를 인쇄할 수 있으며, 예상치 못한 입력이 있는 경우 enum으로부터 에러를 볼 수 있습니다.\n\n우리가 여기에 있는 동안, 명령줄에 에러 메시지를 인쇄하는 도우미 함수를 추가해 봅시다.\n\n```rust\nimpl Game {\n    // 다른 함수들\n\n    fn display_error(&self, error: String) {\n        self.display_board();\n        println!(\"{}에러: {}{}\", RED, error, RESET);\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 게임에서 승리했는지 계산하기\n\n누군가가 이겼는지 확인하기 위해 2차원 배열을 여러 방향으로 탐색해야 합니다. 이 Leetcode 스타일 문제는 재미있는 도전이었고, 결과물을 얻기까지 몇 번 시도해야 했어요.\n\n누군가가 4칸을 연달아 얻을 수 있는 네 가지 방향이 있어요:\n\n- 수평,\n- 수직,\n- 역 슬래시 대각선 (왼쪽 위에서 오른쪽 아래로),\n- 순방향 슬래시 대각선 (왼쪽 아래에서 오른쪽 위로).\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n게시판의 모든 슬롯을 반복하여 네 방향 중 하나에서 테스트할 수 있습니다. (게시판이 작기 때문에 무차별 대입 방식을 사용하는 것이 부담이 되지 않습니다. 그러나 더 나은 방법이 있는지 궁금합니다!)\n\n게시판의 주어진 슬롯에서 시작합니다. 플레이어의 토큰이 들어있는 경우, 첫 번째 방향으로 한 단계 이동합니다. 이 새로운 슬롯도 같은 토큰을 포함하는 경우, 이 방향으로 또 다른 단계를 이동합니다. 이를 반복하여 같은 토큰이 있는 네 개의 슬롯을 찾을 때까지 진행합니다. 그렇지 않으면 다른 방향으로 이동합니다.\n\n각 방향은 정수들의 튜플로 나타낼 수 있습니다 - 행당 거리에 대한 값과 열당 거리에 대한 값 하나씩 - 이 정보를 배열에 저장할 수 있습니다.\n\n```js\nlet directions = [\n  (0, 1), // 가로\n  (1, 0), // 세로\n  (1, 1), // 대각선 (왼쪽 위에서 오른쪽 아래)\n  (-1, 1), // 대각선 (왼쪽 아래에서 오른쪽 위)\n];\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 튜플들이 무엇을 나타내는지 알려드릴게요:\n\n- 수평으로 이동하려면 행은 변하지 않고(0), 열만 변해야 합니다(1).\n- 수직으로 이동하려면 행이 변해야 하고(1), 열은 변하지 않아야 합니다(0).\n- 역 슬래시 대각선으로 이동하려면 행과 열이 둘 다 증가해야 합니다(1, 1).\n- 마지막으로, 슬래시 대각선으로 이동하려면 열은 증가하고 행은 감소해야 합니다(-1, 1).\n\n각 방향의 모든 슬롯을 테스트하려면 아래와 같이 세 개의 루프가 필요합니다.\n\n```rust\nimpl Game {\n    // 다른 함수들\n\n    fn calculate_winner(&mut self) -> Player {\n        for row in 0..BOARD_HEIGHT {\n            for col in 0..BOARD_WIDTH {\n                let cell = self.board[row][col];\n\n                if cell != 0 {\n                    let directions = [\n                        (0, 1),  // 수평\n                        (1, 0),  // 수직\n                        (1, 1),  // 대각선 (왼쪽 위에서 오른쪽 아래로)\n                        (-1, 1), // 대각선 (왼쪽 아래에서 오른쪽 위로)\n                    ];\n\n                    for (row_step, col_step) in directions {\n                        // TODO - 주어진 방향으로 보드를 탐색하고\n                        // 승자를 찾았다면 해당 플레이어를 반환하세요\n                    }\n                }\n            }\n        }\n        Player::None\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리는 연속 카운트를 유지하고 — 4에 도달하면 승자가 나온 것을 알 수 있습니다.\n\n그럼, 최종 중첩된 루프에서는 시작 토큰부터 슬롯별로 이동을 시도할 것입니다. 그때까지…\n\n- 시작 토큰과 다른 토큰을 만날 때 (그러한 경우 루프를 종료합니다);\n- 보드의 가장자리에 도달할 때 (그러한 경우 루프를 종료합니다);\n- 동일한 토큰의 4연속을 만날 때 (그러한 경우 게임을 종료하고 승자를 지정합니다).\n\n```js\nimpl Game {\n    // 다른 함수들\n\n    fn calculate_winner(&mut self) -> Player {\n        for row in 0..BOARD_HEIGHT {\n            for col in 0..BOARD_WIDTH {\n                let cell = self.board[row][col];\n\n                if cell != 0 {\n                    let directions = [\n                        (0, 1),  // 가로\n                        (1, 0),  // 세로\n                        (1, 1),  // 대각선 (왼쪽 위에서 오른쪽 아래로)\n                        (-1, 1), // 대각선 (왼쪽 아래에서 오른쪽 위로)\n                    ];\n\n                    for (row_step, col_step) in directions {\n                        let mut consecutive_count = 1;\n                        let mut r = row as isize + row_step;\n                        let mut c = col as isize + col_step;\n\n                        while r >= 0\n                            && r < BOARD_HEIGHT as isize\n                            && c >= 0\n                            && c < BOARD_WIDTH as isize\n                        {\n                            if self.board[r as usize][c as usize] == cell {\n                                consecutive_count += 1;\n\n                                if consecutive_count == 4 {\n                                    self.is_finished = true;\n                                    return Player::from_int(cell);\n                                }\n                            } else {\n                                break;\n                            }\n                            r += row_step;\n                            c += col_step;\n                        }\n                    }\n                }\n            }\n        }\n\n        Player::None\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리는 이동 횟수가 일곱 미만인 경우 이러한 확인 작업을 수행하지 않고 최적화를 조금 추가할 수 있습니다. 그때까지는 게임에서 이기는 것이 불가능하기 때문입니다. 그래서 함수 맨 위에 이를 추가해 봅시다:\n\n```js\nif self.current_move < 7 {\n    return Player::None;\n}\n```\n\n그리고 보드가 가득 찼지만 승자가 없는 경우(즉, 무승부인 경우)에 게임을 종료로 표시해야 합니다. 이를 반환문 위에 추가해 줍시다:\n\n```js\nif self.current_move >= BOARD_HEIGHT as u8 * BOARD_WIDTH as u8 {\n    self.is_finished = true;\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n마지막으로, 새로운 calculate_winner 함수를 play_move 함수에 추가할 수 있습니다. 이번에는 아무것도 반환하는 대신, 성공인 Result enum을 반환하거나 실패인 경우에는 오류를 반환합니다.\n\n```js\nimpl Game {\n    // 다른 함수들\n\n    fn play_move(&mut self, column: usize) -> Result<(), MoveError> {\n        if self.is_finished {\n            return Err(MoveError::GameFinished);\n        }\n\n        if column >= BOARD_WIDTH {\n            return Err(MoveError::InvalidColumn);\n        }\n\n        if let Some(row) = (0..BOARD_HEIGHT)\n            .rev()\n            .find(|&row| self.board[row][column] == 0)\n        {\n            self.board[row][column] = self.current_player as u8;\n            self.current_move += 1;\n        } else {\n            return Err(MoveError::ColumnFull);\n        }\n\n        let calculated_winner = self.calculate_winner();\n\n        if calculated_winner != Player::None {\n            self.winner = calculated_winner;\n        } else {\n            self.current_player = match self.current_player {\n                Player::One => Player::Two,\n                _ => Player::One,\n            };\n        }\n\n        Ok(())\n    }\n}\n```\n\n우리의 Connect 4 게임 엔진이 완성되었습니다! 사용자로부터 입력을 받는 방법만 남았습니다...\n\n# 사용자 입력 받기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리 명령 줄 게임의 마지막 부분에서는 주 함수로 돌아가 사용자 입력을 읽을 수 있도록 할 것입니다.\n\n먼저, Rust의 표준 I/O 라이브러리를 가져오겠습니다.\n\n```js\nuse std::io;\n```\n\n사용자 입력을 읽는 논리는 다음과 같이 보일 수 있습니다. 여기서는 컴퓨터와 달리 0이 아닌 1부터 시작하여 카운트하게 됩니다!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nlet mut user_move = String::new();\n\nio::stdin()\n    .read_line(&mut user_move)\n    .expect(\"Failed to read line\");\n\nlet user_move: usize = match user_move.trim().parse() {\n    Ok(num) => {\n        if num < 1 || num > BOARD_WIDTH as u8 {\n            game.display_error(MoveError::InvalidColumn.to_string());\n            continue;\n        } else {\n            num\n        }\n    }\n    Err(err) => {\n        game.display_error(err.to_string());\n        continue;\n    }\n};\n\nmatch game.play_move(user_move - 1) {\n    Ok(_) => {\n        game.display_board();\n    }\n    Err(err) => {\n        game.display_error(err.to_string());\n    }\n}\n```\n\n먼저, 우리는 빈 문자열을 정의한 뒤 사용자로부터 텍스트를 받기 위해 stdin 메소드를 사용합니다.\n\n다음으로 이 입력을 구문 분석을 시도합니다. 다음 중 하나라도 해당하는 경우 오류를 표시합니다:\n\n- 구문 분석이 실패하는 경우 (예: 입력이 숫자가 아닌 경우).\n- 구문 분석이 성공하지만 숫자가 원하는 범위를 벗어난 경우.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만약 오류가 표시되지 않는다면, 우리는 선택한 수를 둘 것입니다. 그러나 해당 시나리오에서 오류가 발생할 수도 있으므로, 그런 경우에는 오류를 표시할 것입니다.\n\n그러나 위의 코드는 한 번만 실행됩니다. 게임이 끝날 때까지 루프를 실행해야 합니다. 아래는 그 반복문을 추가한 main 함수와 사용자를 도와줄 몇 가지 유용한 메시지입니다:\n\n```js\nfn main() {\n    let mut game = Game::default();\n    game.display_board();\n\n    while !game.is_finished {\n        println!(\"\\n\");\n\n        match game.current_player {\n            Player::One => println!(\"플레이어 1\"),\n            Player::Two => println!(\"플레이어 2\"),\n            _ => (),\n        };\n\n        println!(\"1부터 7 사이의 열을 입력하세요:\");\n\n        let mut user_move = String::new();\n        io::stdin()\n            .read_line(&mut user_move)\n            .expect(\"라인을 읽는 데 실패했습니다\");\n\n        let user_move: usize = match user_move.trim().parse() {\n            Ok(num) => {\n                if num < 1 || num > 7 {\n                    game.display_error(MoveError::InvalidColumn.to_string());\n                    continue;\n                } else {\n                    num\n                }\n            }\n            Err(err) => {\n                game.display_error(err.to_string());\n                continue;\n            }\n        };\n\n        match game.play_move(user_move - 1) {\n            Ok(_) => {\n                game.display_board();\n            }\n            Err(err) => {\n                game.display_error(err.to_string());\n            }\n        }\n    }\n}\n```\n\n# 여러 판을 플레이하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n마지막으로, 사용자가 게임을 끝내면 게임을 다시 시작할 수 있도록 추가 코드를 추가하고 싶어요. 매번 실행 파일을 다시 시작해야 하는 번거로움은 피하고 싶으니까요!\n\n이를 위해 새로운 루프를 만들 것입니다. 이전과 동일한 방법을 사용하여 사용자의 입력을 읽을 수 있습니다. \"R\"을 누르면 새 게임을 시작하고, \"Q\"를 누르면 루프를 중단하고 코드를 끝까지 실행합니다.\n\n```js\nfn main() {\n    let mut game = Game::default();\n    game.display_board();\n\n    loop {\n        while !game.is_finished {\n            // 코드 변경 없음\n        }\n\n        println!(\"Press 'R' to restart or 'Q' to quit the game.\");\n\n        let mut user_input = String::new();\n\n        io::stdin()\n            .read_line(&mut user_input)\n            .expect(\"Failed to read line\");\n\n        match user_input.trim() {\n            \"R\" | \"r\" => {\n                game = Game::default();\n                game.display_board();\n            }\n            \"Q\" | \"q\" => {\n                println!(\"Quitting...\");\n                break;\n            }\n            _ => game.display_error(\"잘못된 입력\".to_string()),\n        }\n    }\n}\n```\n\n마지막으로, 차례 사이에 터미널을 지우기 위한 ASCII 이스케이프 코드를 사용할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nfn clear_screen(&self) {\n    print!(\"{}[2J\", 27 as char);\n}\n```\n\n게임 보드를 표시할 때마다 이 작업을 수행할 수 있습니다.\n\n```js\nfn display_board(&self) {\n    self.clear_screen();\n\n    // 코드 변경 없음\n}\n```\n\n# 모두 함께 가져오기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그것이 커넥트 4의 간단한 명령줄 게임을 위해 필요한 모든 것입니다! 이 작업 중인 파일을 사용하는 작동 버전을 시험하려면 Rust 플레이그라운드를 확인해보세요.\n\n우리가 지금까지 만든 전체 파일은 아래와 같습니다:\n\n```js\nuse std::io;\n\nconst RESET: &str = \"\\x1b[0m\";\nconst ORANGE: &str = \"\\x1b[93m\";\nconst RED: &str = \"\\x1b[0;31m\";\n\nconst BOARD_WIDTH: usize = 7;\nconst BOARD_HEIGHT: usize = 6;\n\ntype Board = [[u8; BOARD_WIDTH]; BOARD_HEIGHT];\n\n#[derive(Clone, Copy, Debug, PartialEq)]\n#[repr(u8)]\nenum Player {\n    One = 1,\n    Two = 2,\n    None = 0,\n}\n\nimpl Player {\n    fn from_int(int: u8) -> Player {\n        match int {\n            1 => Player::One,\n            2 => Player::Two,\n            _ => Player::None,\n        }\n    }\n}\n\n#[...]\n\n# 결론\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n지금까지 따라오셨다면 프로젝트를 더 나아가고 싶을 것입니다. 여러 게임을 거치면서 승리를 추적해 볼 수도 있고, 어떨까요? 어플리케이션을 웹 서버로 전환하여 웹사이트가 HTTP를 통해 Connect 4를 플레이할 수 있게끔 만들어 보는 것은 어떤가요?\n\n이번 명령줄 어플리케이션을 Rust로 개발하는 방법에 대한 유용하고 재미있는 통찰력으로 여기시길 바랍니다. 아직 Rust 여행을 시작한 지 얼마 되지 않았기 때문에, 어떠한 비평이나 더 많은 Rust 다운 방식으로 어플리케이션을 작성하는 아이디어가 있다면 꼭 알려주세요. 함께 고민해보고 싶습니다.\n```\n","ogImage":{"url":"/assets/img/2024-05-20-LearnRustbycodingacommandlineConnect4game_0.png"},"coverImage":"/assets/img/2024-05-20-LearnRustbycodingacommandlineConnect4game_0.png","tag":["Tech"],"readingTime":24},{"title":"Python 정규 표현식을 사용하여 여러 공백을 하나의 공백으로 압축하기","description":"","date":"2024-05-20 15:59","slug":"2024-05-20-CondensingMultipleSpacesIntoOneSpaceUsingPythonRegex","content":"\n![image](/assets/img/2024-05-20-CondensingMultipleSpacesIntoOneSpaceUsingPythonRegex_0.png)\n\n만약 여러 개의 공백 문자를 하나의 공백 문자로 변환해야 한다면, 이 기사가 여러분을 위한 것입니다.\n\n```js\nx = \"apple   orange  pear     pineapple\";\n```\n\n^ 이 문자열에서 단어 사이에 여러 개의 공백이 있습니다. 여러 개의 공백을 하나의 공백으로 압축해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\noutput = \"apple orange pear pineapple\";\n```\n\n# 수동 방법\n\n```js\nx = 'apple   orange  pear     pineapple'\n\ndef condense(x):\n    words = x.split(' ')\n    words = [w for w in words if w]\n    return ' '.join(words)\n\nprint(condense(x))\n\n# apple orange pear pineapple\n```\n\n- .split()을 사용하면 `['apple', '', '', 'orange', '', 'pear', '', '', '', '', 'pineapple']` 와 같이 단어가 됩니다.\n- 리스트 내포는 모든 빈 문자열을 필터링하고 [`apple`, `orange`, `pear`, `pineapple`]를 얻습니다.\n- ` ` .join()은 이 4개 단어를 `apple orange pear pineapple`로 결합합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n하지만 이 방법은 다소 수동적입니다. 한 줄의 코드로 정규식을 사용하여 이 문제를 해결할 수 있다는 걸 아셨나요?\n\n# 정규식 방법\n\n```js\nx = 'apple   orange  pear     pineapple'\n\nimport re\nprint(re.sub(' +', ' ', x))\n\n# apple orange pear pineapple\n```\n\n- re.sub은 정규식 ` +`와 일치하는 모든 문자열을 ` `로 바꿉니다.\n- ` +`는 1개 이상의 공백을 포함하는 모든 문자열과 일치합니다.\n- 이는 연속으로 여러 개의 공백이 포함된 모든 경우에 일치합니다.\n- 각각의 경우가 한 개의 공백으로 대체됩니다.\n- 이게 전부입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 결론\n\n이 내용을 이해하기 쉽고 명확했기를 바랍니다.\n\n# 크리에이터로서 저를 지원하고 싶다면\n\n- 이 이야기에 대해 50번 박수를 치세요\n- 생각을 나누는 댓글을 남겨주세요\n- 이야기에서 가장 마음에 드는 부분을 강조해주세요\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n감사합니다! 이런 작은 행동들이 큰 도움이 되어요. 정말 감사드려요!\n\nYouTube: [https://www.youtube.com/@zlliu246](https://www.youtube.com/@zlliu246)\n\nLinkedIn: [https://www.linkedin.com/in/zlliu/](https://www.linkedin.com/in/zlliu/)\n\n나의 이북: [https://zlliu.co/ebooks](https://zlliu.co/ebooks)\n","ogImage":{"url":"/assets/img/2024-05-20-CondensingMultipleSpacesIntoOneSpaceUsingPythonRegex_0.png"},"coverImage":"/assets/img/2024-05-20-CondensingMultipleSpacesIntoOneSpaceUsingPythonRegex_0.png","tag":["Tech"],"readingTime":3},{"title":"안드로이드에서 네트워크 호출 Retrofit을 이용한 비동기 프로그래밍","description":"","date":"2024-05-20 15:58","slug":"2024-05-20-NetworkCallsinAndroidAsynchronousProgrammingwithRetrofit","content":"\n<img src=\"/assets/img/2024-05-20-NetworkCallsinAndroidAsynchronousProgrammingwithRetrofit_0.png\" />\n\n안녕하세요! 안드로이드 개발 세계에서 네트워크 호출을 효율적으로 처리하는 것이 매우 중요해요. 원격 서버에서 데이터를 가져오거나 클라우드에 데이터를 업로드한다 하더라도, 네트워크 작업은 시간이 오래 걸릴 수 있고 제대로 처리되지 않으면 사용자 경험에 상당한 영향을 줄 수 있어요. 여기서 Retrofit이 등장하는데, 이는 Square에서 개발한 안드로이드와 자바용 타입 안전한 HTTP 클라이언트에요. 이 글에서는 Retrofit의 내부 동작과 안드로이드에서 네트워크 호출을 수행하는 데 어떻게 비동기 프로그래밍으로 사용할 수 있는지 알아볼 거에요.\n\n동기 호출의 문제점을 상상해보세요. 만약 앱이 서버에서 사용자 데이터를 다운로드해야 한다면, 개발자는 전통적인 동기 방식을 사용할 수 있어요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n문자열 userData = downloadUserDataSync();\n\n// 이제 userData를 앱 로직에서 사용하세요...\n```\n\n이 방법은 직관적으로 보이지만 문제점이 있습니다: downloadUserDataSync()가 실행 중일 때 전체 앱이 차단됩니다. 사용자가 화면과 상호 작용할 수 없게 되며, 버튼이 응답하지 않는 것처럼 보이고 데이터 다운로드가 완료될 때까지 앱이 멈춰 있는 것처럼 보입니다. 이는 사용자 경험을 저하시킵니다.\n\n비동기 프로그래밍 등장\n\n비동기 프로그래밍을 통해 앱이 네트워크 응답을 기다리는 동안에도 계속 실행할 수 있습니다. 핵심 아이디어는 백그라운드에서 네트워크 호출을 시작하고 응답이 준비되었을 때 알림을 받는 것입니다. 이렇게 하면 주 스레드가 사용 가능해져 사용자의 상호작용에 민첩하게 대응할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n레트로핏을 위한 구조체\n\n레트로핏은 안드로이드에서 네트워크 호출을 간소화하고 비동기 프로그래밍과 완벽하게 통합되는 인기 있는 HTTP 클라이언트 라이브러리입니다. 인터페이스를 사용하여 API 엔드포인트를 정의하고 요청을 생성하고 응답을 처리하는 방법을 제공합니다.\n\n다음은 레트로핏의 주요 기능 중 일부입니다:\n\n- 쉬운 사용: 네트워크 요청을 만들고 응답을 구문 분석하는 복잡성을 추상화합니다.\n- 타입 안전성: 작업 중인 데이터의 유형이 예상대로인지 확인합니다.\n- 비동기 요청: 원활한 사용자 경험을 위해 필수적인 비동기 네트워크 호출을 지원합니다.\n- 통합: OkHttp, RxJava, Gson과 같은 다른 라이브러리와 원활하게 작동합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# Retrofit 설정하기\n\n```js\n의존성 {\n    구현체 'com.squareup.retrofit2:retrofit:2.9.0'\n    구현체 'com.squareup.retrofit2:converter-gson:2.9.0'\n}\n```\n\n이러한 종속성에는 Retrofit과 JSON 직렬화 및 역직렬화를 처리하기 위한 Gson 변환기가 포함되어 있습니다.\n\n# API 인터페이스 정의하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nRetrofit을 사용하려면 API의 엔드포인트를 Java 인터페이스로 정의해야 합니다. 사용자 목록을 제공하는 간단한 API와 작업 중이라고 가정해봅시다.\n\n```js\npublic interface ApiService {\n    @GET(\"/users\")\n    Call<List<User>> getUsers();\n}\n```\n\n```bash\n여기서 @GET(\"users\")는 /users 엔드포인트로 GET 요청을 보낸다는 것을 나타내고, Call<List<User>>는 이 요청이 User 객체의 목록을 반환할 것임을 나타냅니다.\n```\n\n# Retrofit 인스턴스 생성하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음으로 Retrofit의 인스턴스를 만들어보겠습니다. 보통은 애플리케이션에서 한 번만 이 작업을 수행하며 대부분 싱글톤 패턴으로 처리됩니다.\n\n```java\npublic class ApiClient {\n    private static final String BASE_URL = \"https://api.example.com/\";\n    private static Retrofit retrofit = null;\n\n    public static Retrofit getClient() {\n        if (retrofit == null) {\n            retrofit = new Retrofit.Builder()\n                    .baseUrl(BASE_URL)\n                    .addConverterFactory(GsonConverterFactory.create())\n                    .build();\n        }\n        return retrofit;\n    }\n}\n```\n\n여기서 BASE_URL은 API의 루트 URL입니다. addConverterFactory(GsonConverterFactory.create())은 Retrofit에 Gson을 JSON 변환에 사용하도록 지시하는 부분입니다.\n\n# 비동기 네트워크 호출하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nRetrofit을 설정하면 이제 비동기 네트워크 호출을 할 수 있습니다. 사용자 목록을 가져오고 응답을 처리하는 방법은 다음과 같습니다:\n\n```js\npublic class MainActivity extends AppCompatActivity {\n\n    private ApiService apiService;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        Retrofit retrofit = ApiClient.getClient();\n        apiService = retrofit.create(ApiService.class);\n\n        fetchUsers();\n    }\n\n    private void fetchUsers() {\n        Call<List<User>> call = apiService.getUsers();\n        call.enqueue(new Callback<List<User>>() {\n            @Override\n            public void onResponse(Call<List<User>> call, Response<List<User>> response) {\n                if (response.isSuccessful()) {\n                    List<User> users = response.body();\n                    // 사용자 목록 처리\n                } else {\n                    // 오류 처리\n                }\n            }\n\n            @Override\n            public void onFailure(Call<List<User>> call, Throwable t) {\n                // 실패 처리\n            }\n        });\n    }\n}\n```\n\n`fetchUsers` 메서드에서 enqueue를 호출하여 네트워크 요청을 비동기적으로 수행합니다. `onResponse` 메서드는 요청이 성공한 경우에 호출되고, `onFailure` 메서드는 요청이 실패한 경우에 호출됩니다.\n\n# 다양한 응답 유형 처리\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n레트로핏은 일반 텍스트, JSON 및 사용자 정의 타입을 포함한 다양한 유형의 응답을 지원합니다. 예를 들어, API가 추가 메타데이터를 포함한 JSON 객체를 반환하는 경우 사용자 정의 응답 유형을 정의할 수 있습니다:\n\n```js\npublic class ApiResponse<T> {\n    private T data;\n    private String status;\n    private String message;\n\n    // Getter 및 Setter 메서드\n}\n```\n\n그런 다음, API 인터페이스를 이 사용자 정의 타입을 사용하도록 업데이트하십시오:\n\n```js\npublic interface ApiService {\n    @GET(\"users\")\n    Call<ApiResponse<List<User>>> getUsers();\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그리고 액티비티나 프래그먼트에서 응답을 처리해보세요:\n\n```js\ncall.enqueue(new Callback<ApiResponse<List<User>>>() {\n    @Override\n    public void onResponse(Call<ApiResponse<List<User>>> call, Response<ApiResponse<List<User>>> response) {\n        if (response.isSuccessful()) {\n            ApiResponse<List<User>> apiResponse = response.body();\n            if (apiResponse != null && \"success\".equals(apiResponse.getStatus())) {\n                List<User> users = apiResponse.getData();\n                // 사용자 목록 처리\n            } else {\n                // API 오류 처리\n            }\n        } else {\n            // 에러 처리\n        }\n    }\n\n    @Override\n    public void onFailure(Call<ApiResponse<List<User>>> call, Throwable t) {\n        // 실패 처리\n    }\n});\n```\n\n# 고급 사용법: 인터셉터와 로깅\n\n네트워크 요청에 대한 더 많은 제어를 위해 OkHttp를 사용하여 인터셉터를 추가할 수 있습니다. 인터셉터는 요청 및 응답을 수정하고 세부 정보를 기록하며 인증을 처리할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n먼저 OkHttp 종속성을 추가해주세요:\n\n```js\nimplementation 'com.squareup.okhttp3:logging-interceptor:4.9.0'\n```\n\n그런 다음 인터셉터를 사용하여 OkHttp 클라이언트를 설정하세요:\n\n```js\nHttpLoggingInterceptor logging = new HttpLoggingInterceptor();\nlogging.setLevel(HttpLoggingInterceptor.Level.BODY);\n\nOkHttpClient client = new OkHttpClient.Builder()\n        .addInterceptor(logging)\n        .build();\n\nRetrofit retrofit = new Retrofit.Builder()\n        .baseUrl(BASE_URL)\n        .client(client)\n        .addConverterFactory(GsonConverterFactory.create())\n        .build();\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 설정을 통해 모든 네트워크 요청과 응답이 로깅되어 문제를 디버그하기가 더 쉬워집니다.\n\n# 결론\n\nRetrofit은 안드로이드에서 네트워크 호출을 처리하는 강력하고 유연한 라이브러리입니다. 그 간결함과 방대한 사용자 정의 옵션을 결합하여 네트워크 작업을 처리하는 데 탁월한 선택지가 됩니다. Retrofit을 사용함으로써 복잡한 API 및 대규모 데이터셋을 다룰 때에도 앱이 효율적으로 작동하고 부드러운 사용자 경험을 제공할 수 있습니다.\n\n본 문서에서 제공된 예제와 지침을 따라 Retrofit을 안드로이드 프로젝트에 통합하고 비동기 프로그래밍을 위한 기능을 활용할 수 있는 능력을 습득할 수 있을 것입니다. 즐거운 코딩 되세요!\n","ogImage":{"url":"/assets/img/2024-05-20-NetworkCallsinAndroidAsynchronousProgrammingwithRetrofit_0.png"},"coverImage":"/assets/img/2024-05-20-NetworkCallsinAndroidAsynchronousProgrammingwithRetrofit_0.png","tag":["Tech"],"readingTime":9},{"title":"제트팩 컴포즈에서 안전하게 플로우 소비하기","description":"","date":"2024-05-20 15:56","slug":"2024-05-20-ConsumingflowssafelyinJetpackCompose","content":"\n![](/assets/img/2024-05-20-ConsumingflowssafelyinJetpackCompose_0.png)\n\nLifecycle-aware 방식으로 Flow를 수집하는 것이 Android에서 Flow를 수집하는 권장 방법입니다. Jetpack Compose로 안드로이드 앱을 개발 중이라면 UI에서 Lifecycle-aware 방식으로 Flow를 수집하기 위해 collectAsStateWithLifecycle API를 사용하십시오.\n\ncollectAsStateWithLifecycle을 사용하면 앱이 백그라운드에 있을 때와 같이 필요하지 않은 경우 앱 리소스를 저장할 수 있습니다. 불필요한 리소스를 오랫동안 유지하면 사용자 기기의 성능에 영향을 줄 수 있습니다. 이러한 리소스에는 Firebase 쿼리, 위치 또는 네트워크 업데이트 및 데이터베이스 연결이 포함될 수 있습니다.\n\n이 API에 대해 더 알아보고, Lifecycle-aware 방식으로 수집해야 하는 이유 및 collectAsState API와 비교하는 방법을 계속 읽어보세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# collectAsStateWithLifecycle\n\ncollectAsStateWithLifecycle은 flow에서 값들을 수집하고 최신 값을 Compose State로 라이프사이클을 고려하여 표현하는 컴포저블 함수입니다. 새로운 flow 이벤트가 발생할 때마다 State 객체의 값이 업데이트됩니다. 이는 구성 내의 모든 State.value 사용의 recomposition을 유발합니다.\n\n기본적으로 collectAsStateWithLifecycle은 Lifecycle.State.STARTED를 사용하여 flow로부터 값들을 수집하기 시작하고 중지합니다. 이는 라이프사이클이 대상 상태로 이동하고 벗어날 때 발생합니다. 이 라이프사이클 상태는 minActiveState 매개변수에서 구성 가능합니다.\n\n![이미지](/assets/img/2024-05-20-ConsumingflowssafelyinJetpackCompose_1.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래 코드 스니펫은 ViewModel에서 노출한 StateFlow의 uiState 필드를 수집하는 collectAsStateWithLifecycle의 사용 방법을 보여줍니다:\n\nAuthorViewModel의 uiState가 새로운 AuthorScreenUiState 값을 방출할 때마다, AuthorRoute가 recompose됩니다. collectAsStateWithLifecycle의 더 많은 사용 예는 Now in Android 앱과 해당 마이그레이션 PR을 확인해보세요.\n\n프로젝트에서 collectAsStateWithLifecycle API를 사용하려면 androidx.lifecycle.lifecycle-runtime-compose artifact를 프로젝트에 추가하세요.\n\n# Under the hood\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\ncollectAsStateWithLifecycle의 구현은 View 시스템을 사용하여 안드로이드에서 플로우를 수집하는 권장 방법인 repeatOnLifecycle API를 사용합니다.\n\ncollectAsStateWithLifecycle을 사용하면 아래 표시된 보일러플레이트 코드를 입력하는 번거로움을 덜어줍니다. 또한 콤포저블 함수에서 라이프사이클을 인식하는 방법으로 플로우를 수집합니다.\n\n# 아키텍처에서의 플로우 수집\n\n앱 아키텍처의 유형은 다른 유형의 구현 세부 정보를 알아서는 안 됩니다. UI는 ViewModel이 UI 상태를 어떻게 생성하는지 알아서는 안 됩니다. UI가 화면에 표시되지 않으면 플로우 수집을 중지하여 적절한 경우 앱 리소스를 해제해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nUI는 collectAsStateWithLifecycle를 사용하여 UI 상태를 수집함으로써 리소스를 해제하는 데 도움이 될 수 있습니다. ViewModel은 UI 상태를 수집자 인식적으로 생성함으로써 동일한 작업을 수행할 수 있습니다. UI가 화면에 표시되지 않은 경우와 같이 수집자가 없는 경우 데이터 계층에서 오는 상류 플로우를 중지할 수 있습니다. UI 상태를 생성할 때 .stateIn(WhileSubscribed) 플로우 API를 사용하여 이 작업을 수행할 수 있습니다. 이에 대한 자세한 정보는 Kotlin flows in practice에서 이야기하는 부분을 참조하십시오. 이 방법으로 UI 상태를 생성하는 ViewModel을 테스트하려면 테스트 가이드를 확인하십시오.\n\n![image](/assets/img/2024-05-20-ConsumingflowssafelyinJetpackCompose_2.png)\n\n플로우의 소비자와 생성자는 서로의 구현 방식을 알 필요가 없습니다. 여러 환경, 변형, 라이브러리 및 기능이 있는 큰 앱에서 구현 세부 정보를 파악하는 것은 매우 시간이 소요될 수 있습니다. 게다가, 구현 세부 정보에 의존하는 코드를 유지하는 것은 어려울 수 있습니다.\n\n# 백그라운드에서 리소스 활성 유지하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n안녕하세요! 안드로이드 앱은 수많은 안드로이드 기기에서 실행될 수 있어요. 하지만 모든 기기와 사용자가 무한한 리소스를 가지고 있는 것은 아닙니다. 앱은 일반적으로 제한된 환경에서 실행돼요. 안드로이드 앱이 실행 중일 때는 사용자 경험과 기기 시스템 상태에 영향을 미치는 중요한 요인들이 있어요:\n\n- CPU 사용량: CPU는 모든 기기 구성 요소 중에서 배터리 소모량이 가장 높아요. 배터리 수명은 사용자들이 항상 걱정하는 문제에요. 남용하면 사용자가 앱을 제거할 수도 있어요.\n- 데이터 사용량: Wi-Fi에 연결되지 않은 경우 앱에서 네트워크 트래픽을 줄이면 사용자가 돈을 절약할 수 있어요.\n- 메모리 사용량: 앱이 메모리를 사용하는 방식은 기기의 전체 안정성과 성능에 매우 큰 영향을 미칠 수 있어요.\n\n사용자, 기기 시스템 상태를 존중하거나 수십억 대상으로 앱을 개발하려는 안드로이드 개발자는 시장, 기기 또는 대상 국가에 따라 이러한 다양한 요인들을 최적화해야 해요. 필요 없는 리소스를 계속 유지하면 기기의 종류와 사용 중인 안드로이드 버전에 따라 부정적인 영향을 줄 수 있어요. UI 레이어에서 collectAsStateWithLifecycle를 사용하면 나머지 계층이 리소스를 해제할 수 있어요.\n\n# collectAsState 비교\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n개발자들이 종종 묻곤 합니다: 안드로이드의 컴포저블 기능에서 플로우를 수집하는 가장 안전한 방법은 collectAsStateWithLifecycle인데, collectAsState API가 왜 필요한가요? collectAsState에 라이프사이클 관리 기능을 추가하지 않고 새 API를 만드는 이유가 뭔가요?\n\n컴포저블 함수의 라이프사이클은 Compose가 실행 중인 플랫폼과 상관이 없다. 컴포저블 함수의 라이프사이클은 '라이프사이클에서 컴포저블' 페이지에 문서화되어 있습니다. 컴포저블 함수의 인스턴스는 Composition에 진입하고, 0회 이상 다시 구성되고, Composition을 떠납니다.\n\n![이미지](/assets/img/2024-05-20-ConsumingflowssafelyinJetpackCompose_3.png)\n\ncollectAsState API는 Composition의 라이프사이클을 따릅니다. 컴포저블이 Composition에 진입할 때 플로우 수집을 시작하고, Composition을 떠날 때 수집을 멈춥니다. collectAsState는 플로우를 수집하는 데 사용할 수 있는 플랫폼에 중립적인 API입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그러나 안드로이드 앱에서 Compose를 사용할 때는 안드로이드 라이프사이클도 리소스 관리에 중요한 역할을 합니다. Compose가 안드로이드 앱이 백그라운드에 있을 때 recompositions을 일시 중지하더라도, collectAsState는 컬렉션을 활성 상태로 유지합니다. 이는 계층 구조의 나머지 부분이 리소스를 해제할 수 없게 만듭니다.\n\ncollectAsState와 collectAsStateWithLifecycle은 Compose에서 각자의 목적이 있습니다. 안드로이드 앱을 개발할 때는 후자를 사용하고, 다른 플랫폼을 위해 개발할 때는 전자를 사용합니다.\n\ncollectAsState에서 collectAsStateWithLifecycle로 마이그레이션하는 것은 간단합니다:\n\nLifecycle-aware 방식으로 플로우를 수집하는 것은 안드로이드에서 플로우를 수집하는 권장 방법으로, 필요한 경우 앱의 다른 부분이 리소스를 해제할 수 있도록 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nJetpack Compose을 사용하여 Android 앱을 개발 중이라면, collectAsStateWithLifecycle 조합 기능을 사용하여 이 작업을 수행할 수 있습니다.\n\n부록: 이 기사를 검토해 준 Jose Alcérreca,\nMarton Braun,\nAlejandra Stamato,\n그리고 Jake Roseman에게 감사드립니다.\n","ogImage":{"url":"/assets/img/2024-05-20-ConsumingflowssafelyinJetpackCompose_0.png"},"coverImage":"/assets/img/2024-05-20-ConsumingflowssafelyinJetpackCompose_0.png","tag":["Tech"],"readingTime":7},{"title":"안드로이드 프로젝트에 Kotlin Multiplatform Mobile KMM을 원활하게 통합하기","description":"","date":"2024-05-20 15:55","slug":"2024-05-20-SeamlesslyIntegrateKotlinMultiplatformMobileKMMintoYourAndroidProject","content":"\n<img src=\"/assets/img/2024-05-20-SeamlesslyIntegrateKotlinMultiplatformMobileKMMintoYourAndroidProject_0.png\" />\n\nKotlin Multiplatform Mobile (KMM)은 Android 및 iOS 애플리케이션 간에 코드를 공유할 수 있게 해주어 개발을 더 신속하고 효율적으로 만듭니다.\n\n본 안내서는 KMM을 기존의 Android 프로젝트에 통합하는 단계를 안내합니다. Android 앱의 고유한 기능을 희생하지 않고 공유 코드를 활용할 수 있도록 보장합니다.\n\n필수 준비물:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 기존 Android 앱.\n\n## 단계 1: KMM 모듈 생성하기:\n\n- Android Studio에서 File -` New -` New Module로 이동합니다.\n- KMM Shared Module을 선택합니다.\n\n<img src=\"/assets/img/2024-05-20-SeamlesslyIntegrateKotlinMultiplatformMobileKMMintoYourAndroidProject_1.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n새 Android Studio에서 KMM 공유 모듈을 찾을 수 없다면 걱정하지 마세요. 설정에 숨겨져 있습니다.\n\n## 단계 2: 앱 모듈에 공유 모듈 포함하기:\n\n- settings.gradle 파일을 열고 KMM 모듈 종속성이 추가되었는지 확인하세요 (이 작업은 자동으로 수행됩니다).\n- app/build.gradle 파일에서 다음 종속성을 추가하세요:\n\n```js\nimplementation project(\":shared\")\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 단계 3: Kotlin DSL용 빌드 스크립트 업데이트(필요한 경우):\n\n만약 Android 프로젝트가 빌드에 실패한다면, KMM 모듈이 Kotlin DSL을 사용하고 있을 가능성이 높습니다. 다음과 같이 shared/build.gradle.kts에 의존성 설정을 변경하세요:\n\n```js\nplugins {\n    id(\"com.android.library\")\n    id(\"org.jetbrains.kotlin.multiplatform\")\n}\n\nkotlin {\n    android()\n    sourceSets {\n        val androidMain by getting {\n            dependencies {\n                implementation(\"org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version\")\n            }\n        }\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\n의존성 {\n    구현(\"org.jetbrains.kotlin:kotlin-test:$kotlin_version\")\n}\n```\n\n## 단계3: 빌드 및 확인:\n\n- 프로젝트를 Gradle 파일과 동기화하고 빌드가 성공적으로 완료되는지 확인합니다.\n- 빌드 과정 중 발생하는 어떤 문제든 해결합니다.\n\n## 단계4: 앱에서 공유 코드 사용:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 이제 KMM 모듈의 공유 코드를 Android 프로젝트에서 사용할 수 있습니다. 예를 들어 Android 액티비티나 프래그먼트에서 필요한 대로 공유 클래스 및 함수를 가져올 수 있습니다.\n\n## 단계5: 빌드 및 확인\n\n- Android 프로젝트를 실행하여 모든 것이 올바르게 통합되었고 공유 코드가 기대대로 작동하는지 확인하십시오.\n\n이러한 단계를 따라서 기존 Android 프로젝트에 KMM을 성공적으로 통합할 수 있으며, Android와 기타 플랫폼 간에 코드를 원할하게 공유하여 개발 프로세스를 강화하고 노력의 중복을 줄일 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음 시리즈의 내용을 기대해주세요. KMM을 기존 iOS 프로젝트에 통합하는 방법을 살펴볼 예정입니다.\n","ogImage":{"url":"/assets/img/2024-05-20-SeamlesslyIntegrateKotlinMultiplatformMobileKMMintoYourAndroidProject_0.png"},"coverImage":"/assets/img/2024-05-20-SeamlesslyIntegrateKotlinMultiplatformMobileKMMintoYourAndroidProject_0.png","tag":["Tech"],"readingTime":4},{"title":"안드로이드에서 Room 데이터베이스 시작하기","description":"","date":"2024-05-20 15:54","slug":"2024-05-20-GettingStartedwithRoomDatabaseinAndroid","content":"\n## Room 데이터베이스 구현에 대한 포괄적인 안내\n\n![Android Room Database](/assets/img/2024-05-20-GettingStartedwithRoomDatabaseinAndroid_0.png)\n\n## 소개:\n\n로컬 데이터 저장은 많은 안드로이드 애플리케이션에게 중요하며, 데이터를 효율적으로 저장하고 검색할 수 있게 합니다. 이 안내서에서는 안드로이드 앱에서 데이터베이스 관리를 간편하게 하는 강력한 라이브러리인 Room을 살펴보겠습니다. Room 설정부터 데이터베이스 작업 수행 및 마이그레이션 처리까지 모두 다룰 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-05-20-GettingStartedwithRoomDatabaseinAndroid_1.png\" />\n\n## 섹션 1: Room 데이터베이스 설정하기\n\n단계 1: 종속성 추가\n앱의 `build.gradle` 모듈 레벨 파일을 열어 Room 및 Kotlin Coroutines (비동기 작업을 위한)에 필요한 종속성을 추가해주세요:\n\n```js\ngradle\ndependencies {\n def roomVersion = \"2.4.0\" // 최신 버전을 확인하세요\n implementation \"androidx.room:room-runtime:$roomVersion\"\n kapt \"androidx.room:room-compiler:$roomVersion\"\n implementation \"androidx.room:room-ktx:$roomVersion\"\n implementation \"org.jetbrains.kotlinx:kotlinx-coroutines-android:1.5.2\" // 코루틴 종속성 추가\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nOR\n\n최신 안드로이드 및 Jetpack Compose에서 특정 오류로 실패하는 경우 'Kotlin 심볼 처리' ksp()을 추가해야 할 수도 있습니다.\n\n아래 종속성 및 플러그인을 build.gradle(모듈 레벨)에 추가해보세요.\n\n```js\nplugins {\n .\n .\n id \"com.google.devtools.ksp\"\n}\n\n.\n.\n.\n\ndependencies{\n  // Room 종속성\n    val room_version = \"2.5.2\"\n\n    implementation(\"androidx.room:room-ktx:$room_version\")\n    // Kotlin 주석 처리 도구 (kapt) 사용을 위해\n    ksp(\"androidx.room:room-compiler:$room_version\")\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래 클래스 경로를 build.gradle(앱 레벨)에 KSP에 추가해주세요.\n\n```js\nplugins {\n    id \"com.google.devtools.ksp\" version \"1.8.10-1.0.9\" apply false\n}\n```\n\n단계 2: 엔티티 클래스 생성\n데이터베이스에서 테이블을 나타내기 위해 어노테이션을 사용하여 엔티티 클래스를 정의하세요. 예를 들어, `User` 엔티티를 생성해보겠습니다(각 데이터 멤버가 열 이름인 테이블로 간주합니다):\n\n```js\nimport androidx.room.Entity\nimport androidx.room.PrimaryKey\n\n@Entity(tableName = \"users\")\ndata class User(\n @PrimaryKey(autoGenerate = true) val id: Long = 0,\n val username: String,\n val email: String\n)\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### Step 3: DAO (Data Access Object) Interface 생성\n\n데이터베이스 작업을 정의하기 위한 DAO 인터페이스를 생성하세요. 예를 들어, `UserDao`를 만들어보겠습니다:\n\n```kotlin\nimport androidx.room.Dao\nimport androidx.room.Insert\nimport androidx.room.OnConflictStrategy\nimport androidx.room.Query\n\n@Dao\ninterface UserDao {\n\n @Insert(onConflict = OnConflictStrategy.REPLACE)\n suspend fun insertUser(user: User)\n\n @Query(\"SELECT * FROM users\")\n suspend fun getAllUsers(): List<User>\n}\n```\n\n### Step 4: 데이터베이스 클래스 정의\n\n`RoomDatabase`를 확장하는 추상 클래스를 생성하여 데이터베이스 인스턴스를 정의하고 엔티티 및 DAO를 포함시키세요:\n\n```kotlin\nimport androidx.room.Database\nimport androidx.room.RoomDatabase\n\n@Database(entities = [User::class], version = 1)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun userDao(): UserDao\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nStep 5: 데이터베이스 인스턴스 초기화하기\n`Application` 클래스나 관련 진입점에서 Room 데이터베이스 인스턴스를 초기화하세요:\n\n```kotlin\nimport android.app.Application\nimport androidx.room.Room\n\nclass MyApp: Application() {\n\n    companion object {\n        lateinit var database: AppDatabase\n    }\n\n    override fun onCreate() {\n        super.onCreate()\n        database = Room.databaseBuilder(\n            applicationContext,\n            AppDatabase::class.java,\n            \"my_database\"\n        ).build()\n    }\n}\n```\n\n## 섹션 2: 데이터베이스 작업 수행하기\n\nStep 1: 데이터 삽입\n사용자를 데이터베이스에 삽입하려면 `UserDao`에 정의된 `insertUser` 메서드를 사용할 수 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nval newUser = User(username = \"JohnDoe\", email = \"john@example.com\")\nMyApp.database.userDao().insertUser(newUser)\n```\n\n단계 2: 데이터 검색\n데이터베이스에서 모든 사용자를 검색하려면 `UserDao`의 `getAllUsers` 메서드를 사용하십시오:\n\n```js\nval userList: List<User> = MyApp.database.userDao().getAllUsers()\n```\n\n인젝션 가능한 Room 데이터베이스 객체를 설정하는 데모 프로젝트를 확인해주세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n데모 프로젝트 링크: https://github.com/raikwaramit/RoomDatabaseModule/\n\n## 결론:\n\nAndroid 앱에서 Room 데이터베이스를 구현하면 데이터 저장을 간편하게 처리할 수 있습니다. 직관적인 설정과 강력한 기능으로 앱의 로컬 데이터를 효율적으로 관리할 수 있습니다. 이 가이드를 따라가면 Room 설정, 엔티티 및 DAO 정의, 데이터베이스 작업 수행, 마이그레이션 처리 방법을 배울 수 있습니다.\n\n이 가이드에서는 Room의 기본 사항을 다루었습니다. 라이브러리에 익숙해지면 데이터베이스 관계, LiveData 통합, 복잡한 쿼리와 같은 고급 기능을 탐색할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n룸을 사용하면 Android 앱에서 로컬 데이터를 관리하는 것이 더 쉬워집니다. 코딩을 즐기세요!\n","ogImage":{"url":"/assets/img/2024-05-20-GettingStartedwithRoomDatabaseinAndroid_0.png"},"coverImage":"/assets/img/2024-05-20-GettingStartedwithRoomDatabaseinAndroid_0.png","tag":["Tech"],"readingTime":6},{"title":"코틀린 코루틴에서 에러 다루기 예외 처리와 에러 전파","description":"","date":"2024-05-20 15:53","slug":"2024-05-20-DealingwithErrorsinKotlinCoroutinesExceptionHandlingandErrorPropagation","content":"\n![image](/assets/img/2024-05-20-DealingwithErrorsinKotlinCoroutinesExceptionHandlingandErrorPropagation_0.png)\n\n현대 비동기 프로그래밍 패러다임에서는 Kotlin 코루틴이 중심적인 역할을 합니다. 비동기 프로그래밍 프로세스 중 발생하는 오류를 효과적으로 처리하는 것은 애플리케이션의 견고성과 신뢰성에 중요합니다. 본 문서에서는 Kotlin 코루틴을 사용할 때 오류 관리의 중요한 측면을 탐구하고 오류 전파의 복잡성을 다루고자 합니다.\n\n비동기 프로그래밍은 현대 소프트웨어 개발에서 널리 사용됩니다. 그러나 이러한 프로그래밍 프로세스에서 오류를 만나는 것은 불가피합니다. 네트워크 호출, 파일 작업, 데이터베이스 상호작용 및 기타 외부 소스에서 발생하는 오류를 효과적으로 해결하여 애플리케이션의 신뢰성과 사용자 경험을 보장해야 합니다. Kotlin 코루틴은 비동기 프로그래밍 시 이러한 오류를 처리하는 다양한 도구와 전략을 제공합니다.\n\n# 코루틴 스코프 내에서 오류 처리\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nKotlin 코루틴을 사용할 때, 코루틴 스코프 내에서 오류 처리를 확실히 하는 것은 비동기 작업을 효과적으로 관리하는 데 중요합니다. 코루틴 스코프는 특정 작업의 라이프사이클을 제어하며, 내부에서 발생할 수 있는 모든 오류를 적절히 처리해야 합니다.\n\n![image](/assets/img/2024-05-20-DealingwithErrorsinKotlinCoroutinesExceptionHandlingandErrorPropagation_1.png)\n\n위 예시에서는, 코루틴 내에서 발생하는 오류가 외부 스코프에서 캐치되어 적절히 처리될 수 있습니다.\n\n# Supervisor Jobs\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nSupervisor 작업은 특히 병렬 coroutine이 관련된 시나리오에서 오류 관리에 필수적인 도구입니다. Supervisor 작업은 한 coroutine에서 발생한 오류가 다른 coroutine에 영향을 미치지 않도록 보장하여 응용 프로그램의 전체 강건성을 향상시킵니다.\n\n![이미지](/assets/img/2024-05-20-DealingwithErrorsinKotlinCoroutinesExceptionHandlingandErrorPropagation_2.png)\n\nSupervisor 작업을 사용하면 coroutine의 오류가 다른 coroutines에 영향을 주지 않도록하여 프로세스가 계속될 수 있습니다.\n\n# 오류 전파\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 오류가 전파되는 방법에 대해 이야기해 보겠습니다. 코루틴에서 결과를 기다리다가 문제가 발생하면 어떻게 처리할 수 있는지 알아봅시다:\n\n![이미지](/assets/img/2024-05-20-DealingwithErrorsinKotlinCoroutinesExceptionHandlingandErrorPropagation_3.png)\n\n위의 예제에서 우리는 async 코루틴 내에서 예외를 던지고 적절히 예외를 처리하여 처리하는 방법을 확인할 수 있습니다.\n\n그럼 이제 여기까지입니다! 코틀린 코루틴을 사용하면 오류 처리가 쉬워집니다. 코루틴 스코프 내에서, 슈퍼바이저 작업을 사용하여, 또는 오류 전파를 다룰 때, 코드를 견고하고 신뢰할 수 있게 유지할 수 있는 도구를 갖고 있습니다. 그러니 맘 놓고 코루틴에 더 깊이 파고들어보고 오류를 두려워하지 마세요!\n","ogImage":{"url":"/assets/img/2024-05-20-DealingwithErrorsinKotlinCoroutinesExceptionHandlingandErrorPropagation_0.png"},"coverImage":"/assets/img/2024-05-20-DealingwithErrorsinKotlinCoroutinesExceptionHandlingandErrorPropagation_0.png","tag":["Tech"],"readingTime":3},{"title":"루비 온 레일즈에서의 유효성 검사를 위한 모범 사례들","description":"","date":"2024-05-20 15:52","slug":"2024-05-20-BestPracticesforValidationsinRubyonRails","content":"\n![Validation](/assets/img/2024-05-20-BestPracticesforValidationsinRubyonRails_0.png)\n\n유효성 검사는 웹 응용 프로그램 개발의 중요한 측면으로, 사용자가 입력한 데이터가 처리되거나 저장되기 전에 특정 기준을 충족시키도록 하는 것을 보장합니다. 루비 온 레일즈(Ruby on Rails)에서는 ActiveRecord의 강력한 내장 유효성 검사 메서드 덕분에 유효성 검사를 구현하기가 간단합니다. 이 기사에서는 레일즈 애플리케이션에서 유효성 검사를 구현하는 최선의 방법에 대해 안내해 드리겠습니다.\n\n# 유효성 검사의 중요성\n\n유효성 검사는 응용 프로그램의 데이터 무결성과 일관성을 보장합니다. 데이터베이스에 잘못된 데이터가 저장되는 것을 방지하여 응용 프로그램 오류, 보안 취약점 및 기타 문제가 발생하는 것을 방지합니다. 모델 수준에서 데이터를 유효성 검사함으로써 데이터 무결성 논리를 집중시킴으로써, 응용 프로그램을 유지 보수 가능하고 안전하게 만듭니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 일반적인 유효성 검증\n\n루비 온 레일즈는 모델을 유효성 검증하는 데 사용할 수 있는 다양한 내장 유효성 검증 도우미를 제공합니다. 여기에는 일반적으로 사용되는 몇 가지가 있습니다:\n\n1. **Presence(존재)**: 필드가 비어있지 않은지 확인합니다.\n\n```js\nvalidates :name, presence: true\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n독특성: 값이 테이블 전체에서 고유한지 확인합니다.\n\n```js\nvalidates :email, uniqueness: true\n```\n\n형식: 정규 표현식을 사용하여 필드가 특정 형식에 일치하는지 확인합니다.\n\n```js\nvalidates :email, format: { with: URI::MailTo::EMAIL_REGEXP }\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n숫자 정합성: 필드가 숫자임을 보장하고 숫자 제약 조건을 유효성 검사할 수도 있습니다.\n\n```js\nvalidates :age, numericality: { only_integer: true, greater_than: 0 }\n```\n\n# 유효성 검사 구현을 위한 모범 사례\n\n## 내장된 유효성 검사기 사용\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n가능한 한 Rails의 내장 유효성 검사기를 활용하세요. 이들은 테스트를 거친 상태이며 다양한 일반적인 유효성 검사 요구사항을 다룹니다. 내장 유효성 검사기를 사용하면 코드가 더 읽기 쉽고 유지보수하기 쉬워집니다.\n\n```js\nclass User < ApplicationRecord\n  validates :email, presence: true, uniqueness: true, format: { with: URI::MailTo::EMAIL_REGEXP }\nend\n```\n\n## 사용자 정의 유효성 검사\n\n내장 도우미로 다루기 어려운 복잡한 유효성 검사 로직이 필요한 경우, 사용자 정의 유효성 검사 메서드를 작성할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```ruby\nclass User < ApplicationRecord\n  validate :password_complexity\n\n  def password_complexity\n    return if password.blank? || password =~ /(?=.*\\d)(?=.*[a-z])(?=.*[A-Z])/\n\n    errors.add :password, 'must include at least one lowercase letter, one uppercase letter, and one digit'\n  end\nend\n```\n\n## 조건부 유효성 검사\n\n가끔 필드를 특정 조건에서만 유효성을 검사해야 할 때가 있습니다. Rails에서는 :if와 :unless 옵션을 통해 이를 쉽게 할 수 있습니다.\n\n```ruby\nclass User < ApplicationRecord\n  validates :ssn, presence: true, if: :adult?\n\n  def adult?\n    age >= 18\n  end\nend\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 유효성 검사 및 데이터베이스 제약조건\n\nActiveRecord 유효성 검사는 강력하지만 애플리케이션 수준에서만 실행됩니다. 중요한 유효성 검사의 경우, 데이터베이스 수준에서도 제약조건을 강제하세요. 이렇게 하면 두 겹의 보호막이 제공됩니다.\n\n```js\n# 마이그레이션\nadd_index :users, :email, unique: true\n```\n\n## 지나치게 유효성 검사 피하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n너무 많은 유효성 검사를 하지 않도록 주의해주세요. 지나치게 엄격한 유효성 검사는 사용자에게 답답한 경험을 줄 수 있습니다. 필요한 유효성 검사를 실행하고 사용자에게 의미 있는 피드백을 제공해 주세요.\n\n## 오류 메시지\n\n사용자 친화적인 오류 메시지를 표시해 주세요. 기본 오류 메시지는 최종 사용자에게는 너무 기술적일 수 있습니다.\n\n```js\nclass User < ApplicationRecord\n  validates :username, presence: { message: \"빈 칸일 수 없습니다\" }\nend\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 유효성 검사 테스트\n\n언제나 유효성 검사에 대한 테스트를 작성하세요. 이렇게 함으로써 해당 기능이 예상대로 작동하는지 확인할 수 있으며, 미래의 회귀 사항을 방지할 수 있습니다.\n\n```ruby\n# spec/models/user_spec.rb\nrequire 'rails_helper'\n\nRSpec.describe User, type: :model do\n  it '유효한 이메일로 유효성이 유효해야 합니다' do\n    user = User.new(email: 'user@example.com')\n    expect(user).to be_valid\n  end\n\n  it '이메일이 없으면 유효하지 않아야 합니다' do\n    user = User.new(email: nil)\n    user.valid?\n    expect(user.errors[:email]).to include(\"can't be blank\")\n  end\n\n  it '중복된 이메일로는 유효하지 않아야 합니다' do\n    User.create!(email: 'user@example.com')\n    user = User.new(email: 'user@example.com')\n    user.valid?\n    expect(user.errors[:email]).to include('has already been taken')\n  end\nend\n```\n\n## 결론\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n테이블 태그를 Markdown 형식으로 변경하세요.\n","ogImage":{"url":"/assets/img/2024-05-20-BestPracticesforValidationsinRubyonRails_0.png"},"coverImage":"/assets/img/2024-05-20-BestPracticesforValidationsinRubyonRails_0.png","tag":["Tech"],"readingTime":6},{"title":"성능 비교 Ruby 대 Python 대 Go  문자 발생 횟수 세기","description":"","date":"2024-05-20 15:51","slug":"2024-05-20-PerformanceComparisonRubyvsPythonvsGoCountingCharacterOccurrences","content":"\n<img src=\"/assets/img/2024-05-20-PerformanceComparisonRubyvsPythonvsGoCountingCharacterOccurrences_0.png\" />\n\n# 소개\n\n저는 얼마 동안 Ruby로 작업해오다 최근 Python과 Go를 배우기 시작했습니다. 오늘은 릿코드 문제 1347번, '두 문자열을 애너그램으로 만들기 위한 최소 단계 수'를 해결했습니다. Ruby 언어로 쉽게 해결했는데 궁금해서 Python과 Go에서도 시도해 보았더니, 놀랄 정도로 Go가 다른 두 언어와 비교했을 때 얼마나 빠르고 효율적인지에 깜짝 놀랐습니다. 이 차이를 보는 것이 흥미로운데, 더 많은 코딩 모험에 대해 더 많이 공유하고 싶습니다!\n\n이 성능 탐구에서는 간단한 알고리즘을 세 가지 인기 프로그래밍 언어인 Ruby, Python 및 Go에서 실행 시간과 메모리 사용량에 대해 탐구합니다. 작업은 문자열에서 문자 발생 횟수를 계산하고 한 문자열을 다른 문자열로 변환하는 데 필요한 최소 단계를 계산하는 것을 포함합니다. 각 언어로 프로그램을 작성하는 것을 넘어, 이 분석은 Ruby, Python 및 Go가 도전 과제를 어떻게 처리하는지에 대해 밝혀내어, 실행 시 동작 및 메모리 효율성에 대한 통찰을 제공합니다. 이 언어들의 동작을 보다 깊게 이해하기 위해 계속 주목해 주세요!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n루비 구현:\n\n```js\ndef min_steps(s, t)\n  min_steps = 0\n  h = Hash.new(0)\n  s.each_char do |c|\n    h[c] += 1\n  end\n\n  t.each_char do |c|\n    h[c].positive? ? h[c] -= 1 : min_steps += 1\n  end\n  min_steps\nend\n```\n\n파이썬 구현:\n\n```js\nclass Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        d = {}\n        count = 0\n        for c in s:\n            d[c] = 1 if not d.get(c) else d[c] + 1\n\n        for c in t:\n            if d.get(c):\n                d[c] -= 1\n            else:\n                count += 1\n\n        return count\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nGo 구현:\n\n```js\nfunc minSteps(s string, t string) int {\n    minSteps := 0\n    h := make(map[rune]int)\n\n    for _, c := range s {\n        h[c]++\n    }\n\n    for _, c := range t {\n        if h[c] > 0 {\n            h[c]--\n        } else {\n            minSteps++\n        }\n    }\n\n    return minSteps\n}\n```\n\n결과:\n\n| 언어   | 실행 시간 (밀리초) | 메모리 사용량 (메가바이트) |\n| ------ | ------------------ | -------------------------- |\n| Ruby   | 504                | 218.2                      |\n| Python | 164                | 17.9                       |\n| Go     | 58                 | 6.6                        |\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 관찰 및 설명:\n\n루비, 파이썬 및 Go로 구현된 제공된 알고리즘의 성능 비교에서 런타임 및 메모리 사용량에 상당한 차이가 관찰되었습니다. 이러한 차이는 각 프로그래밍 언어의 독특한 설계 철학과 실행 모델에서 비롯됩니다.\n\n- 런타임 차이:\n\n- 루비: 루비는 해석형 언어로, 컴파일된 언어와 비교해 일반적으로 더 높은 런타임을 갖습니다.\n- 파이썬: 파이썬은 루비보다 더 좋은 런타임 성능을 갖지만 Go에는 미치지 못합니다.\n- Go: Go는 정적 형식의 컴파일 언어로, 강력한 성능 특성을 갖추어 가장 빠른 런타임을 제공합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 2. 메모리 사용량:\n\n- Ruby와 Python: 이러한 언어들은 특히 동적 상황에서 더 높은 메모리 사용량으로 알려져 있습니다.\n- Go: 효율성을 위해 설계된 Go는 낮은 메모리 소비로 이어집니다.\n\n## 3. 언어 디자인:\n\n- Ruby와 Python: 동적 타입 및 고수준 추상화는 유연성에 기여하지만 성능에 영향을 줄 수 있습니다.\n- Go: 정적 타입 및 컴파일된 Go는 간결함과 성능을 강조합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n4. Garbage Collection:\n\n- 루비와 파이썬: 자동 메모리 관리(가비지 컬렉션)는 오버헤드를 발생시킬 수 있습니다.\n- Go: 효율적인 가비지 컬렉션 전략을 갖추어 낮은 메모리 사용량을 제공합니다.\n\n5. 실행 환경:\n\n- 루비와 파이썬: 인터프리터 언어는 런타임 환경에 의존하여 오버헤드가 발생할 수 있습니다.\n- Go: 네이티브 이진 파일이 컴파일되어 인터프리터를 필요로 하지 않고 빠른 실행이 가능합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 결론:\n\n이 비교에서 관찰된 성능 차이는 언어 특징, 런타임 환경 및 메모리 관리 전략 사이의 트레이드오프를 강조합니다. 정적으로 타입 지정되고 컴파일된 Go 언어는 런타임 및 메모리 사용량 측면에서 우수한 성능을 보여줍니다. 개발자 친화적인 문법과 동적 기능을 제공하는 Python과 Ruby는 사용 편의성을 위해 성능을 어느 정도 포기할 수 있습니다. 이러한 차이를 이해하면 개발자들이 개발 속도, 사용 편의성 및 성능 요구사항과 같은 요소를 균형있게 고려해 특정 사용 사례에 적합한 언어를 선택할 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-05-20-PerformanceComparisonRubyvsPythonvsGoCountingCharacterOccurrences_0.png"},"coverImage":"/assets/img/2024-05-20-PerformanceComparisonRubyvsPythonvsGoCountingCharacterOccurrences_0.png","tag":["Tech"],"readingTime":5},{"title":"테스트 속도를 높이는 parallel_tests의 힘을 활용해보세요 로컬 설정 및 실행법","description":"","date":"2024-05-20 15:50","slug":"2024-05-20-HarnessingthePowerofparallel_testsforFasterTestingLocalSetupandExecution","content":"\n# parallel_tests란 무엇인가요?\n\n이는 RSpec, Cucumber 및 기타 테스트 도구 그룹의 실행 속도를 높이기 위해 사용되는 Ruby gem입니다.\n\nParallelTests는 테스트를 균형 잡힌 그룹(라인 수 또는 실행 시간으로)으로 분할하고 각 그룹을 해당 데이터베이스와 함께 프로세스에서 실행합니다.\n\n# 설정 및 실행\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- .zshrc 파일에 export PARALLEL_TEST_PROCESSORS=n을 추가하여 세그먼트 수를 지정하세요.\n- `test` 섹션 내에서 database.yml 파일에 병렬 테스트 구성을 추가하세요.\n\n```js\ntest:\n database: yourproject_test<%= ENV['TEST_ENV_NUMBER'] %>\n```\n\n- .rspec 파일에 형식 구성을 추가하세요.\n\n```js\n--format progress\n--format ParallelTests::RSpec::RuntimeLogger --out tmp/parallel_runtime_rspec.log\n--format ParallelTests::RSpec::SummaryLogger --out tmp/spec_summary.log\n--format ParallelTests::RSpec::FailuresLogger --out tmp/failing_specs.log\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 다음 명령을 실행하여 병렬 테스트 데이터베이스를 생성하세요: rake parallel:create.\n- 마이그레이션에 업데이트가 있는 경우 rake parallel:migrate를 실행하세요.\n- rake parallel:prepare 명령을 사용하여 개발 스키마를 복사하세요.\n- 병렬로 스펙을 실행하려면 rake parallel:spec 명령을 사용하세요.\n- 모든 병렬 테스트 데이터베이스를 삭제하려면 rake parallel:drop 명령을 실행하세요.\n\n참고사항:\n\n- 기본적으로 PARALLEL_TEST_PROCESSORS의 수는 기기의 프로세서 수로 설정됩니다.\n- 모든 작업을 한 번에 처리하려면 🤩 다음 명령어를 사용하세요\n\n```js\nRAILS_ENV=test PARALLEL_TEST_PROCESSORS=6\nrails db:drop db:create db:migrate parallel:prepare parallel:spec\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 장점\n\n- 빠른 테스트 실행 달성\n  일반적으로 병렬 테스트를 사용하지 않을 때 테스트 실행에 약 1.5시간이 소요된다고 가정해 보겠습니다. 그러나 6개 코어를 이용하여 병렬 테스트를 수행하면 이 시간을 15분에서 20분으로 줄일 수 있어 대략 85~90%의 속도 향상이 가능합니다.\n- 최적화된 자원 활용\n  6개 코어를 보유한 상황을 가정해 봅시다. 병렬 테스트를 사용하지 않는다면 모든 사양은 단일 코어에서만 실행됩니다. 그러나 병렬 테스트를 활용하면 여러 코어를 이용하여 사양을 실행할 수 있습니다.\n- Rails와의 원활한 통합\n  한 번만 병렬 테스트를 구성하면 여러 테스트 도구에서 사용할 수 있습니다. 예를 들어, RSpec을 사용하는 경우 rake parallel:spec을 실행할 수 있습니다. Minitest로 전환한다면 실행 명령을 rake parallel:test로 변경하기만 하면 됩니다.\n\n# 결점\n\n- 자원 부담\n  병렬로 테스트를 실행하는 것은 CPU 및 메모리와 같은 추가 시스템 자원을 소비합니다.\n- 불안정성 가능성\n  캐싱이나 Redis와 같은 공유 자원을 활용하는 일부 사양은 설정되어 있지만 다른 세그먼트의 사양에서는 해당 자원을 읽을 수 있습니다. 이로 인해 오류나 일관성에 문제가 발생할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 자원\n\n- 문서\n\n# 결론\n\n요약하자면, 더 빠른 테스트를 위해 병렬 테스트를 활용하는 것은 상당한 이점을 제공합니다. 자원 활용을 최적화하고 Rails와 완벽하게 통합되어 테스트 실행 시간을 크게 줄입니다. 그러나 자원 과부하 및 안정성과 같은 잠재적인 단점에 대해 주의해야 합니다. 적절한 구성과 모니터링으로 병렬 테스트가 개발 프로세스에서 유용한 자산임을 입증했습니다. 더 많은 지침을 위해서 문서를 참조하세요.\n","ogImage":{"url":"/assets/img/2024-05-20-HarnessingthePowerofparallel_testsforFasterTestingLocalSetupandExecution_0.png"},"coverImage":"/assets/img/2024-05-20-HarnessingthePowerofparallel_testsforFasterTestingLocalSetupandExecution_0.png","tag":["Tech"],"readingTime":4}],"page":"94","totalPageCount":120,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":4},"__N_SSG":true}