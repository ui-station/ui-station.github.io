{"pageProps":{"posts":[{"title":"데이터 시각화로 스토리텔링 하는 방법","description":"","date":"2024-07-01 16:00","slug":"2024-07-01-HowtoMakeYourDataVisualizationsTellaStory","content":"\n\n- 소개\n- 규칙 0: 데이터의 유형을 고려하세요\n- 규칙 1: 면적 당 정보를 최대화하세요\n- 규칙 2: 중요한 축 레이블을 무시하지 마세요\n- 규칙 3: 가능한 경우 오차 막대 추가\n- 규칙 4: 모든 것의 글꼴 크기를 키우세요\n- 규칙 5: 축 척도를 적절히 설정하세요\n- 규칙 6: 소표시선과 그리드를 사용하세요\n- 규칙 7: 범례를 잊지 마세요\n- 규칙 8: 명확성이 중요합니다\n- 규칙 9: 일관성이 중요합니다\n- 규칙 10: 지나치게 혼잡해지지 않도록 주의하세요\n- 규칙 11: 적합 매개변수를 요약하는 텍스트 상자 추가\n- 규칙 12: 그림을 나란히 표시할 때 동일한 축 척을 사용하세요\n- 규칙 13: 텍스트 상자를 절약해서 사용하세요\n- 규칙 14: 그림은 .pdf 파일로 저장하세요\n- 요약 및 결론\n\n# 소개\n\n한 명의 현명한 사람이 말했습니다: \"그림은 어떤 설명 없이도 스스로 설명이 가능해야 합니다.\" 즉, 제목이나 저자의 설명 없이 독자에게 제공된 그림은 그 안에 담긴 정보를 해독하고 의미 있는 결론을 추출할 수 있어야 합니다. 저는 다수의 그림을 제작했으며, 이 중 많은 그림이 '원자력 계측 방법', '계측 학지', '원자력 과학 심포지엄 및 IEEE 의료 영상 학술 대회' 등의 학술지에 게재되어 전국 및 국제 학회에 발표되었습니다. 학업 생활을 시작할 때 나는 어떻게 그림을 만드는지 (좋은 그림은 더욱) 몰랐습니다. 과학적 공동 작업 그룹에 가입하고 논문을 투고하면서야 그렇게 배울 수 있었습니다. 논문 본문과 모든 도표/표는 공동 작업 그룹 내부 검토를 여러 번 거쳤을 뿐만 아니라 투고 과정에서도 학술지에서 승인을 받아야 했습니다. 데이터 시각화에 대한 접근 방식이 완전히 틀렸다는 사실을 빨리 깨달았습니다. 그것은 꽤 충격적인 깨달음이었는데, 그림 (및 글쓰기)의 품질은 외부 세계에 대한 귀하의 커뮤니케이션 기술의 즉각적인 반영입니다.\n\n저는 지난 7년 동안 배운 지식을 공유하고자 이 기사를 쓰려고 합니다. 제가 겪은 고통을 당신에게 납득시킬 수 있기를 바래봅니다. 데이터를 시각화하는 것은 과학적 노력뿐만 아니라 예술입니다; 심미적 선택은 이러한 과학적 노력에서 더욱 큰 역할을 합니다. 이러한 객관적 및 주관적 영향의 혼재를 풀어내기 위해, 나는 그림 작성 철학을 14가지 간단한 규칙으로 요약했습니다. 여러분이 유용하게 사용하길 바랍니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저는 다양한 데이터를 다룰 예정이에요; 예제에 더 잘 맞게 하기 위해 수동으로 생성하는 데이터도 있고 캐글에서 가져오는 데이터셋도 있을 거예요. 하지만 모든 데이터셋에 대해 csv 파일을 다운로드할 수 있는 링크를 포함하거나 데이터를 어떻게 생성했는지 보여드릴 거에요. 시작하기 전에 이 글에서 데이터를 생성/플로팅하는 데 사용된 모든 import 문을 나열할 거에요:\n\n```js\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib import cm\nfrom matplotlib.lines import Line2D\nimport matplotlib.patches as mpatches\nfrom matplotlib.ticker \nimport numpy as np\nimport pandas as pd\nfrom scipy.optimize import curve_fit\nfrom sklearn.neighbors import KernelDensity\n```\n\n참고로, 저는 Python 버전 3.12.2를 사용하고 있고, 아래에서 모든 패키지 버전을 나열할 거에요:\n\n```js\nmatplotlib==3.8.2\nnumpy==1.26.3\npandas==2.2.0\nscikit-learn==1.4.0\nscipy==1.12.0\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n마지막으로, Matplotlib의 전역 매개변수 몇 가지도 변경하고 싶습니다. 예를 들어, 주요 및 보조 눈금 표시 마커의 크기를 키우고 싶습니다. 그래서 실행 시 구성(RC) 매개변수(Parameter)의 재정의를 아래에 나열해 두겠습니다:\n\n```js\nmpl.rcParams['xtick.major.size']  = 5\nmpl.rcParams['xtick.major.width'] = 2\nmpl.rcParams['xtick.minor.size']  = 4\nmpl.rcParams['xtick.minor.width'] = 1\n\nmpl.rcParams['ytick.major.size']  = 5\nmpl.rcParams['ytick.major.width'] = 2\nmpl.rcParams['ytick.minor.size']  = 4\nmpl.rcParams['ytick.minor.width'] = 1\n```\n\n# Rule 0: 데이터의 유형을 고려하세요\n\n이 규칙은 데이터 시각화에 가장 중요한 규칙으로, 별도의 기사로도 충분히 다루어질 만큼 중요합니다. 하지만 여기서 간결하게 요약하겠습니다. 플롯의 특별한 내용을 고려하기 전에, 먼저 데이터를 가장 잘 표시할 수 있는 플롯 유형을 고려해야 합니다. 이를 정확하게 파악하는 것은 어려울 수 있지만, 데이터를 플로팅할 때 따를 수 있는 몇 가지 기본적인 지침을 설명하겠습니다. 이 토론을 간결하게 유지하기 위해, 데이터 탐색 및 변수 관계에 적합한 데이터 시각화 방법만 고려하겠으며, 플로우, 아크 또는 트리 형태의 플롯으로 해결하는 것이 가장 적합한 문제에 대해서는 고려하지 않겠습니다. 두 가지 더 중요한 점은 다음과 같습니다: 이 목록은 모든 플롯 유형을 갖춘 것이 아니며, 이러한 지침은 절대적인 것이 아니지만 시작점을 찾는 데 도움이 되는 공리입니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 히스토그램 및 상자, 바이올린, 및 확률 밀도 그림\n\n히스토그램: 데이터 탐색을 위한 가장 쉬운 옵션이자 처음 익히면 좋은 것은 겸손한 히스토그램입니다. 이것은 분포를 빠르게 표시하는 데 사용되는 지금까지 믿음직한 방법이죠. 우리가 다루는 모든 새로운 데이터셋에 대해 우리는 데이터가 어떻게 분포되어 있는지 보고 싶어합니다. 예를 들어, 극값이 어디에 위치하는지, 분포의 모양(단일 모양, 이분 모양 등), 시각적으로 추정할 수 있는 몇 가지 기초 통계 (평균, 중앙값, 분산 등) 등을 알고 싶어합니다. 그러나 히스토그램은 1차원 플롯입니다. x축에 하나의 피처를 표시하며, y축은 각 bin에서 발생하는 횟수를 인코딩하여 우리에게 기초 분포의 좋은 감각을 제공합니다. 따라서 많은 피처를 가진 데이터셋의 경우 일반적으로 최적의 옵션이 아닙니다 (물론 여러 피처를 동일한 축에 플롯할 수 있을 때는 제외하고요. 그렇지 않으면 데이터셋의 각 피처에 대해 히스토그램이 필요합니다). 이 플롯 유형 설명의 마지막에 히스토그램을 상단 왼쪽 패널에 표시한 플롯을 참조하세요.\n\n히스토그램은 신뢰할 만한 도구이지만 완벽하지는 않습니다. bin 크기는 분포 형태에 상당한 영향을 미칠 수 있습니다. 나중에는 히스토그램에 전적으로 헌신된 기사를 작성할 것입니다 (데이터를 가장 잘 표시하는 방법, bin 크기 선택 방법 등에 관한 것 등), 하지만 지금은 bin 크기를 조정하여 분포 모양이 어떻게 영향을 받는지 확인해보세요.\n\n상자 수염 그림: 히스토그램 대신에 사용할 수 있는 대안은 상자 수염 그림입니다. 이것은 데이터가 플로팅되는 방식을 표준화함으로써 bin-의존 상태를 약간 향상시킵니다. 상자는 제 1사분위부터 제 3사분위까지 (1Q 및 3Q 각각)를 나타내며 이를 사분위범위 (IQR)라고도 합니다. IQR 내에서 중앙값을 나타내는 선이 그어지고, 종종 마커가 평균값을 나타냅니다. 수염은 위에서 제3사분위부터 상단 3Q + (1.5 • IQR)까지, 및 하단에서 1사분위부터 하단 1Q - (1.5 • IQR)까지 연장됩니다. 이 범위의 이상치는 수염 밖에 그려진 마커로 나타납니다. 처음에는 약간 이상하게 보일 수 있지만, 상자 수염 그림이 키 특징이 표시된 히스토그램의 요약일 뿐이라는 것을 깨달을 때 이해하기가 완전히 가능해지며 유틸리티가 급격하게 증가합니다. 아래 상자수염 그림과 정규 분포의 대조를 살펴보세요:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/assets/img/2024-07-01-HowtoMakeYourDataVisualizationsTellaStory_0.png)\n\n바이올린 플롯: 상자그림의 확장인 바이올린 플롯은 데이터 집합의 최솟값과 최댓값을 가리키는 수직선 왼쪽과 오른쪽에 확률 밀도 함수(probability density function, PDF)를 겹쳐 놓습니다. 아래 예시에서는 기본 바이올린 플롯의 유용성을 확대하기 위해 중앙값(주황색 선)과 평균값(빨간 다이아몬드)을 표시했습니다.\n\n확률 밀도 함수 그래플: 바이올린 플롯의 구성 요소 중 하나로 논의된 PDF 그래프는 대상 데이터만으로 생성되는 KDE(커널 밀도 추정) 과정에 따라 단순히 PDF만 보여줍니다. 이러한 종류의 그래플은 통계에 익숙하지 않은 사람들에게는 해석하기 어려울 수 있지만, 통계를 아는 사람들에게는 히스토그램보다 유용한 경우도 있습니다. 왜냐하면 데이터에 존재하는 미묘한 변동을 완화시키기 때문입니다. KDE 과정은 다음과 같이 요약될 수 있습니다: 분포 내 각 데이터 포인트에 대해 커널(대부분의 경우 가우스 함수)이 적합되고, 이러한 개별 가우시안 분포가 합산되고 평활화되어 확률 밀도 분포가 생성됩니다. (실제 KDE 과정은 이보다 복잡하지만, 일단 이 설명으로 충분합니다.) 이 그래플의 독특한 이점은 적분(곡선 아래 영역)이 확률을 나타낸다는 것입니다. 아래 예시를 사용해 이것의 물리적 해석은 \"샘플링된 개인이 일부 혈중 콜레스테롤 범위를 가질 확률은 얼마인가\" 입니다. (중요성 때문에, KDE 방법에 대해 보다 철저한 설명이 필요하므로 전체 논문을 쓸 예정입니다.)\n\n아래 예시에 표시된 예제에 사용된 데이터 집합은 Kaggle의 심장 데이터셋(데이터셋 링크)에서 가져온 것입니다. 아래 그래프에서는 전체 데이터 집합(남성과 여성 모두 포함)의 콜레스테롤이 표시되어 있습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n## 데이터 전처리\ndf_heart = pd.read_csv('heart.csv')\nchol = df_heart.chol.to_numpy()\n\n## KDE 방법을 사용하여 PDF 계산\nkde = KernelDensity(kernel='gaussian', bandwidth=10).fit(chol.reshape(-1, 1))\nlog_dens = kde.score_samples(np.arange(0, 600).reshape(-1, 1))\n\n## 서브플롯 간격 매개변수\nleft = 0.125   # 그림의 서브플롯의 왼쪽\nright = 0.9    # 그림의 서브플롯 오른쪽\nbottom = 0.1   # 그림의 서브플롯의 아래쪽\ntop = 0.9      # 그림의 서브플롯의 위쪽\nwspace = 0.5   # 서브플롯 사이의 공백 너비\nhspace = 0.4   # 서브플롯 사이의 공백 높이\n\nmatplotlib.rcParams.update({'font.size': 24})  # 전역 글꼴 크기 설정\nmeanprops = dict(marker='D', markeredgecolor='black',\n                 markerfacecolor='crimson') # 평균 마커를 위한 상자그림 속성\n\nfig, ax = plt.subplots(2, 2, figsize=(14, 13))\n\n## 히스토그램\nax[0, 0].grid('both', zorder=0)\nax[0, 0].hist(chol, bins=40, alpha=0.8, color='forestgreen', edgecolor='black', zorder=2)\n\nax[0, 0].set_xlim(0, 600)\nax[0, 0].set_ylim(0, 40)\nax[0, 0].set_xlabel('콜레스테롤 수준 (mg/dl)', loc='right')\nax[0, 0].set_ylabel('빈도', loc='top')\nax[0, 0].set_title('히스토그램')\nax[0, 0].xaxis.set_minor_locator(AutoMinorLocator())\nax[0, 0].yaxis.set_minor_locator(AutoMinorLocator())\nax[0, 0].tick_params(which='major', length=6, width=2)\nax[0, 0].tick_params(which='minor', length=3.5, width=1)\n\n...\n\nfig.subplots_adjust(left=left, bottom=bottom, right=right, top=top,\n                    wspace=wspace, hspace=hspace) # 서브플롯 간 공백 조정\nfig.savefig('distribution_plots.pdf')\n```\n\n각 플롯 유형은 거의 동일한 것을 디스플레이하며, 각각의 장단점이 있습니다. 이러한 플롯 유형의 데이터는 연속적이지만 필요에 따라 한 축을 이산화하거나 몇 가지 값을 구간으로 나눌 수 있으며, 결과적으로 히스토그램과 유사한 것을 생성할 수 있습니다. 모든 경우에, 이러한 플롯 유형은 계층화된 데이터 간 분포를 비교하는 데 매우 유용하며, 특히 상자 그림과 바이올린 플롯이 있습니다. 연구 대상 남성과 여성 참가자의 콜레스테롤 수준을 비교해보세요:\n\n<img src=\"/assets/img/2024-07-01-HowtoMakeYourDataVisualizationsTellaStory_2.png\" />\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n## 데이터 전처리\nm_chol = df[df['sex'] == 1].chol.to_numpy() # 남성 콜레스테롤 값 가져오기\nf_chol = df[df['sex'] == 0].chol.to_numpy() # 여성 콜레스테롤 값 가져오기\n\nmpl.rcParams.update({'font.size': 24}) # 전역 글꼴 크기 설정\nfig, ax = plt.subplots(2, 2, figsize=(14, 13)) # 2x2 서브 플롯 생성\n\n## 히스토그램 그리기\nax[0, 0].grid('both', zorder=0)\nax[0, 0].hist(m_chol, bins=40, alpha=0.6, color='forestgreen', edgecolor='black', zorder=2)\nax[0, 0].hist(f_chol, bins=40, alpha=0.6, color='xkcd:cerulean', edgecolor='black', zorder=2)\n\nax[0, 0].set_xlim(0, 600)\nax[0, 0].set_ylim(0, 22)\nax[0, 0].set_xlabel('콜레스테롤 수치 (mg/dl)', loc='right')\nax[0, 0].set_ylabel('빈도', loc='top')\nax[0, 0].set_title('히스토그램')\n\n...\n\n## 일부 요소 생략\n```\n\n히스토그램이나 확률 밀도 함수(PDF)가 겹칠 때 그래프가 지저분해질 수 있습니다. 이럴 경우, 맷플롯립이 제공하는 다른 그리기 방법 중 하나인 barstacked나 step 옵션을 사용하는 게 좋습니다. (아래 그림 참조)\n\n<img src=\"/assets/img/2024-07-01-HowtoMakeYourDataVisualizationsTellaStory_3.png\" />\n\n```js\nmpl.rcParams.update({'font.size': 24})\n## 사용자 정의 범례 항목\nlegend = [mpatches.Patch(color='forestgreen', label='남성', alpha=0.6),\n          mpatches.Patch(color='xkcd:cerulean', label='여성', alpha=0.6)\n         ]\n\nlegend_line = [Line2D([0], [0], color='forestgreen', lw=2.5, label='남성'),\n               Line2D([0], [0], color='xkcd:cerulean', lw=2.5, label='여성')\n              ]\n\nfig, ax = plt.subplots(1, 2, figsize=(12, 8))\nax[0].grid('both', zorder=0)\nax[0].hist([m_chol,f_chol], bins=25, alpha=0.6, linewidth=2.3, edgecolor='k', color=['forestgreen', 'xkcd:cerulean'], histtype='barstacked',zorder=2)\nax[1].hist([m_chol,f_chol], bins=25, linewidth=2.5, color=['forestgreen', 'xkcd:cerulean'], histtype='step',zorder=2)\n\n...\n\n## 일부 요소 생략\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n플롯이 지저분하고 해석하기 어렵다면, 아래 두 개의 PDF처럼 서로 다른 데이터를 별도의 서브플롯에 그릴 수 있어요:\n\n![PDFs](/assets/img/2024-07-01-HowtoMakeYourDataVisualizationsTellaStory_4.png)\n\n```js\n## 데이터 처리\nlog_dens   = [log_dens_m, log_dens_f]\npdf_colors = ['forestgreen', 'xkcd:cerulean']\npdf_labels = ['남성', '여성']\n\nmpl.rcParams.update({'font.size': 30})\nfig, ax = plt.subplots(1, 2, figsize=(15, 8))\n\n#ax[1, 1].fill(x_data, kde_y)\nfor subplot in np.arange(2):\n    ax[subplot].plot(np.arange(0, 600), np.exp(log_dens[subplot]), color=pdf_colors[subplot], linewidth=2)\n    ax[subplot].set_xlabel('콜레스테롤 농도 (mg/dl)', loc='right')\n    ax[subplot].set_ylabel('확률 밀도', loc='top')\n    ax[subplot].grid('both', zorder=0)\n    ax[subplot].fill(np.arange(0, 600), np.exp(log_dens[subplot]), color=pdf_colors[subplot], alpha=0.4)\n    ax[subplot].set_xlim(-25, 625)\n    ax[subplot].set_ylim(-0.0005, 0.012)\n    legend = [mpatches.Patch(color=pdf_colors[subplot], label=pdf_labels[subplot], alpha=0.6)]\n    ax[subplot].legend(handles=legend)\n\nfig.tight_layout()\nfig.savefig('pdf_comparison_plots.pdf')\n```\n\n## 산점도\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n산포도(Scatter plot)는 데이터를 군집화하거나 데이터 집합 내에서 다양한 특성 간의 관계를 찾는 데 매우 유용한 옵션입니다. 아래의 산포도를 살펴보십시오. 이 그래프는 뉴욕의 주택 가격을 면적의 함수로 보여줍니다. (데이터셋은 Kaggle에서 확인 가능합니다):\n\n![scatter plot](/assets/img/2024-07-01-HowtoMakeYourDataVisualizationsTellaStory_5.png)\n\n\n## 데이터 로딩 및 전처리\ndf_housing = pd.read_csv('NY-House-Dataset.csv')\n\nprice = df_housing['PRICE'].to_numpy()\nsqft  = df_housing['PROPERTYSQFT'].to_numpy()\n\nmpl.rcParams.update({'font.size': 32})\nfig, ax = plt.subplots(figsize=(9,9))\nax.scatter(sqft, price, c='xkcd:cherry', s=12)\nax.set_xscale('log')\nax.set_yscale('log')\nax.set_xlabel('면적 (ft$^{2}$)', loc='right')\nax.set_ylabel('가격 (USD)', loc='top')\nfig.tight_layout()\nfig.savefig('scatter_plot_example.pdf')\n\n\n위 예시를 선형-로그 척도로 확인하면 아웃라이어의 존재를 더 쉽게 식별할 수 있지만, 데이터 분포의 퍼짐도를 고려하면 로그-로그 척도가 더 적합합니다. 주택 가격과 총 면적이 지수 함수 관계임을 확인할 수 있어, 산포도가 왜 유용한지 잘 드러나는 사례입니다. 추가로, 2000 평방피트 근처에서 여러 주택 가격이 동일한 것을 볼 수 있습니다. 이는 데이터의 오류일 수도 있고, 더 큰 기저 패턴이 있을 수도 있습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nScatter plot을 사용하면 더 많은 데이터나 다른 데이터 세트를 포함시킬 수 있습니다. 예를 들어, 다른 지리적 위치를 다른 포인트 집합으로 추가하거나, 데이터 세트에서 다른 기능을 표시하기 위해 두 번째 x-축이나 y-축을 추가할 수도 있습니다. 아래와 같이 설명되어 있습니다:\n\n![Scatter Plot Image](/assets/img/2024-07-01-HowtoMakeYourDataVisualizationsTellaStory_6.png)\n\n```python\nmpl.rcParams.update({'font.size': 32})\n\n## 데이터 전처리\nbedrooms = df_housing['BEDS'].to_numpy()\n\nfig, ax = plt.subplots(figsize=(9,9))\nax.scatter(sqft, price, c='xkcd:cherry', s=12)\nax.set_yscale('log')\nax.set_xscale('log')\nax.set_xlabel('Area (ft$^{2}$)', loc='right')\nax.set_ylabel('Price (USD)', loc='top')\nax.tick_params(axis='x',  which='both', colors='xkcd:cherry') \nax.xaxis.label.set_color('xkcd:cherry')\nax.set_title('NY House Prices')\n\nax2 = ax.twiny() # 두 번째 x-축 추가\nax2.scatter(bedrooms, price, c='xkcd:cerulean', s=12, label='Bedrooms')\nax2.set_xticks(np.arange(0, 60, 10))\nax2.set_xlabel('Bedrooms', loc='right')\nax2.xaxis.label.set_color('xkcd:cerulean')\nax2.minorticks_on()\nax2.tick_params(axis='x', which='both', colors='xkcd:cerulean') \nfig.tight_layout()\nfig.savefig('scatter_plot_example_double_x_axes.pdf')\n```\n\n두 번째 x-축이 이산적이기 때문에 가장 명확한 예시는 아니지만, 침실 수가 주택 가격의 가장 좋은 예측자가 아님을 추론할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 막대 그래프 및 파이 차트\n\n범주형 데이터의 경우, 막대 그래프나 심지어 파이 차트와 같은 플롯 유형이 적합합니다. 그러나 저는 다양한 종류의 데이터를 표시하는 더 많은 유연성을 제공하기 때문에 막대 차트를 선호합니다. 파이 차트는 각 데이터 범주가 전체에 기여하는 비율을 쉽게 시각화하여 해석하기 쉽고 빠르게 만들어주는 독특한 장점을 가지고 있지만, 이해하기 쉽고 빠르게 만들어주는 독특한 장점을 가지고 있습니다. 그러나 막대 차트가 제공하는 다방면의 유연성이 파이 차트의 명료함을 상쇄시킵니다. 아래는 2019 회계연도의 넷플릭스 서비스의 네 개 주요 지역에서 넷플릭스 스트리밍 수익을 보여주는 막대 차트(왼쪽)와 파이 차트(오른쪽)를 고려해 보세요. 해당 데이터셋은 이곳에서 찾을 수 있습니다(Kaggle):\n\n![그림](/assets/img/2024-07-01-HowtoMakeYourDataVisualizationsTellaStory_7.png)\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n원 그래프는 전체의 백분율을 두 가지 서로 다른 시각적 표현으로 표시하여 해석이 쉽게 됩니다(백분율로 표시된 것과 전체 원의 기하학적 비율로 표시된 것 두 가지입니다). 이는 빠르게 핵심 데이터 시각화를 제시해야 하는 프리젠테이션에서 더 나은 선택일 수 있습니다. 이에 비해 막대 차트는 각 막대 위에 (10억 달러 단위로) 순수한 수치를 제공하면서 각 막대에서 읽을 수 있는 공통 스케일을 제공하여 양을 기하학적으로 나타냅니다. 이렇게 함으로서 이러한 데이터를 시각화하는 비슷한 방법을 제공합니다. 그러나 플롯의 차원을 늘리고, 예를 들어 여러 해를 표시한다면 막대 차트는 훨씬 더 유용합니다. 다음에 나오는 플롯을 고려해 보십시오. 이 플롯은 여러 해 동안의 스트리밍 수익을 보여줍니다:\n\n![Netflix 스트리밍 수익 (2019-2023)](/assets/img/2024-07-01-HowtoMakeYourDataVisualizationsTellaStory_8.png)\n\n번역된 코드:\n```js\n## 여러 막대 그래프를 위한 데이터 처리\nyear_separated = {}\nfor region in total_separated[year].keys():\n    temp = []\n    for year in total_separated.keys():\n        if year == 2024: # 2024년은 1분기만 사용 가능하므로 건너뜁니다\n            pass\n        else:\n            temp.append(total_separated[year][region])\n    year_separated[region] = temp\n\nmpl.rcParams.update({'font.size': 32})\n\n막대의 너비     = 0.2\n막대의 오프셋    = -0.4\n레이블들        = list(region_labels.values())\n색상들          = list(region_colors.values())\nx_ticks       = np.arange(len(total_separated.keys()) - 1) \nx_tick_labels = [str(year) for year in total_separated.keys()]\nx_tick_labels = x_tick_labels[:-1]\n\nfig, ax = plt.subplots(figsize=(10,9))\n\nfor region, cnt in zip(year_separated.keys(), np.arange(len(year_separated.keys()))):\n    data_scaled = np.array(year_separated[region]) / 1e9\n    ax.bar(x_ticks + bar_offset, data_scaled, width=0.2, label=region_labels[region], color=region_colors[region]) \n    ax.set_ylim(0, 20)\n    ax.set_xlabel('Region', loc='right') \n    ax.set_ylabel('Revenue (BUSD)', loc='top') \n    ax.yaxis.set_minor_locator(ticker.AutoMinorLocator())\n    \n    if np.average(data_scaled) >= 8: # 막대의 숫자에 대한 올바른 y-오프셋 설정\n        text_yoffset = 1.4\n    else:\n        text_yoffset = 1.2\n        \n    for bar in np.arange(x_ticks.shape[0]):\n        ax.text(x_ticks[bar] + bar_offset, data_scaled[bar] + text_yoffset, '%.1f' % data_scaled[bar],\n                rotation=90, verticalalignment='center',horizontalalignment='center', fontsize=24)\n\n    bar_offset += bar_width\n\nax.set_xticks(x_ticks, x_tick_labels)\nax.set_title('Netflix 스트리밍 수익 (2019-2023)', fontsize=32, pad=15)\nax.legend(fontsize=24, ncols=2, loc='upper left', columnspacing=0.6)\nfig.tight_layout()\nfig.savefig('netflix_streaming_revenue_2019_2023.pdf')\n```\n\n이것은 원 그래프로는 불가능합니다; 같은 플롯에 여러 원 그래프가 필요할 것이며 —공간의 비효율적 사용입니다!\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 라인 플롯\n\n또는 이 데이터 세트를 라인 플롯으로 표시할 수도 있습니다. 라인 플롯을 사용하면 데이터를 보다 세밀하게 살펴볼 수 있습니다:\n\n![line plot](/assets/img/2024-07-01-HowtoMakeYourDataVisualizationsTellaStory_9.png)\n\n```js\n## 2019년부터 2024년까지 모든 날짜에 대한 지역 데이터 추출\ndates = netflix_data['Date']\nline_plot_data = {}\nfor region in region_labels.keys():\n    line_plot_data[region] = netflix_data[region].to_numpy()\n\nmarkers = ['o', 's', 'D', 'v']\nregion_markers = {region: marker for region, marker in zip(region_labels.keys(), markers)}\n\nmpl.rcParams.update({'font.size': 32})\n\nfig, ax = plt.subplots(figsize=(11,9))\n\nlabels        = list(region_labels.values())\ncolors        = list(region_colors.values())\nx_ticks       = np.arange(len(total_separated.keys()) - 1) \nx_tick_labels = [str(year) for year in total_separated.keys()]\nx_tick_labels = x_tick_labels[:-1]\n\nfor region in line_plot_data.keys():\n    ax.plot(dates, line_plot_data[region], color=region_colors[region],\n            marker=region_markers[region], label=region_labels[region],\n            linewidth=2.2, markersize=7)\n\nax.set_ylim(0, 4.6e9)\nax.set_xlabel('Region', loc='right') \nax.set_ylabel('Revenue (USD)', loc='top') \nax.minorticks_on()\nax.grid(which='major', color='xkcd:cool grey', linestyle='-', alpha=0.7)\nax.grid(which='minor', color='xkcd:light grey', linestyle='--', alpha=0.5)\nax.set_title('넷플릭스 스트리밍 수익', fontsize=32, pad=15)\nax.legend(fontsize=27, ncols=2, loc='upper left', columnspacing=0.6)\nfig.tight_layout()\nfig.savefig('netflix_streaming_revenue_2019_2023.pdf')\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 2D 히스토그램 / 히트맵\n\n이전에 논의한 히스토그램 패밀리의 주의점 중 하나는 2D 히스토그램입니다. 이 플롯 유형은 범주형 데이터의 두 차원을 표시하거나 이미지 데이터를 시각화하는 데 사용할 수 있습니다 [예 : 컴퓨터 비전이나 합성곱 신경망과 작업하고 원시 데이터가 어떻게 보이는지 보고 싶을 때; 편리한 플로팅 라이브러리로 Python Image Library (Pillow) 패키지가 여기에 있습니다]. 아래는 클래식 iris 데이터 집합을 사용한 2D 히스토그램의 예입니다 (Kaggle에서 여기에서 제공).\n\n![2D Histogram Example](/assets/img/2024-07-01-HowtoMakeYourDataVisualizationsTellaStory_10.png)\n\n```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndf_iris = pd.read_csv('Iris.csv')\nsepal_length = df_iris['SepalLengthCm']\nsepal_width  = df_iris['SepalWidthCm']\n\nfig, ax = plt.subplots(figsize=(9,9))\n\nhist = ax.hist2d(sepal_length, sepal_width, vmin=0, vmax=10, bins=10)\nax.set_xlabel('Sepal length', loc='right')\nax.set_ylabel('Sepal width', loc='top')\n\ncbar = fig.colorbar(hist[3])\ncbar.set_label('Counts', loc='top')\nfig.tight_layout()\nfig.savefig('hist2d_example.pdf')\n```\n\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 예시에서는 붓꽃의 측정된 꽃받침 길이와 너비의 가장 일반적인 값들을 식별하기 위해 이 2D 히스토그램을 사용할 수 있습니다. 2D 히스토그램/히트맵은 데이터의 밀도 분포를 나타내는 지표가 될 수 있습니다. 이는 3D 히스토그램으로 확장되어 적용될 수 있으며, 3D 히스토그램에서 z-축(2D 바이닝의 높이)은 색상 막대의 기능을 대체합니다.\n\n## 플롯 유형의 테이블\n\n편의상, 위에서 논의된 각 플롯 유형에 대한 데이터 유형, 사용 용도, 장단점을 표로 정리했습니다:\n\n최종적으로는 경험을 쌓고 상황이 발생했을 때 기술적이고 미적인 판단을 내릴 수 있는 능력에 달려 있습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 규칙 1: 면적 당 정보를 극대화하세요\n\n어떤 플롯이든 축(맷플롯립 용어로 \"spines\"라 불림)의 범위 내에서 제시되는 정보를 최대화하는 것이 목표입니다. 너무 많은 여백은 낭비된 영역을 의미하며, 플롯 생성은 사용 가능한 공간을 효율적으로 사용하는 예술입니다. 아래의 플롯은 이 규칙을 지키지 않은 사례를 보여줍니다 (Kaggle에서 데이터셋 확인 가능):\n\n![Plot Image](/assets/img/2024-07-01-HowtoMakeYourDataVisualizationsTellaStory_11.png)\n\n```python\n## 데이터 전처리\ndf_power = pd.read_csv('Power_data.csv')\npressure = df_power['Ambient pressure'].to_numpy()\ntemp = df_power['Avg temperature'].to_numpy()\nhumidity = df_power['Relative humidity'].to_numpy()\npower = df_power['Net hourly electrical energy output'].to_numpy()\n\nmpl.rcParams.update({'font.size': 32})\nfig, ax = plt.subplots(figsize=(11,9))\n\nax.minorticks_on()\nax.grid(which='major', color='xkcd:cool grey', linestyle='-', alpha=0.7, zorder=0)\nax.grid(which='minor', color='xkcd:light grey', linestyle='--', alpha=0.5, zorder=0)\nax.scatter(temp, power, s=5, label='Temperature ($^{\\circ}$C)', c='xkcd:hot pink', zorder=3)\nax.scatter(humidity, power, s=5, label='Relative humidty (%)', c='xkcd:blue purple', zorder=3)\nax.scatter(pressure, power, s=5, label='Pressure (mbar)', c='xkcd:deep sky blue', zorder=3)\nax.set_xlabel('Variable', loc='right')\nax.set_ylabel('Power output (MW)', loc='top')\n\nax.legend(fontsize=25, markerscale=4, handletextpad=0.3, loc='upper center')\nfig.tight_layout()\nfig.savefig('power_output_scatter.pdf')\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n서로 다른 변수들 간의 큰 간격은 서로 다른 스케일을 가진 여러 변수를 동일한 플롯/축에 플롯하려고 시도했기 때문에 발생했습니다. 이 경우 x축에 로그 스케일을 적용해도 변화가 없습니다. 왜냐하면 모든 변수의 분포 폭이 충분히 넓지 않기 때문입니다. 세 가지 옵션이 있습니다: (1) 서로 다른 데이터를 세 개의 패널로 분할하고 각 변수를 별도로 표시하거나 (2) 온도와 상대습도를 동일한 플롯에 유지하고 압력 데이터를 자체 축으로 할당하거나 (3) 플롯에 두 번째 x축을 추가합니다. 옵션(1)이 가장 좋습니다. 이는 각 피쳐를 개별 x축에 배치하여 출력과 해당 피쳐 간의 관계를 더 잘 시각화하게 하며 전반적으로 플롯을 이해하기 쉽고 조직적으로 만듭니다.\n\n![Visualization](/assets/img/2024-07-01-HowtoMakeYourDataVisualizationsTellaStory_12.png)\n\n```js\nmpl.rcParams.update({'font.size': 38})\n\nfig, ax = plt.subplots(1, 3, figsize=(26,12))\nfor axis in np.arange(3):\n    ax[axis].minorticks_on()\n    ax[axis].grid(which='major', color='xkcd:cool grey', linestyle='-', alpha=0.7, zorder=0)\n    ax[axis].grid(which='minor', color='xkcd:light grey', linestyle='--', alpha=0.5, zorder=0)\n    ax[axis].set_ylabel('Power output (MW)', loc='top')\n    ax[axis].set_ylim(418, 500)\n\nax[0].scatter(temp, power, s=5, label='Temperature ($^{\\circ}$C)', c='xkcd:hot pink', zorder=3)\nax[1].scatter(humidity, power, s=5, label='Relative humidty (%)', c='xkcd:blue purple', zorder=3)\nax[2].scatter(pressure, power, s=5, label='Pressure (mbar)', c='xkcd:deep sky blue', zorder=3)\n\nax[0].set_xlabel('Temperature ($^{\\circ}$C)', loc='right')\nax[1].set_xlabel('Relative humidty (%)', loc='right')\nax[2].set_xlabel('Pressure (mbar)', loc='right')\n\nax[0].set_xlim(0, 40)\nax[1].set_xlim(0, 110)\n\nfig.tight_layout()\nfig.savefig('power_output_scatter_improved.pdf')\n```\n\n# Rule 2: 중요한 축 라벨을 절대 무시하지 마세요.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n일반적으로 간과되는 경우가 있어 축 레이블을 추가하는 것을 잊을 때가 종종 있습니다. 종종 이는 협업자들이 각 축에 무엇이 플로팅되고 있는지 알고 있거나 추론할 수 있기 때문일 수 있습니다. 그러나 우리의 작업을 비롯한 외부의 관찰자나 우리와 같은 분야의 누군가에게는 축 레이블이 없으면 시각화된 내용을 이해하는 데 필수적인 맥락이 제거될 수 있습니다. 예를 들어, 아래 플롯을 살펴보세요:\n\n![히스토그램](/assets/img/2024-07-01-HowtoMakeYourDataVisualizationsTellaStory_13.png)\n\n플롯을 훑어본 빠르게 확인만으로 이것이 확실히 히스토그램이라는 것을 알 수 있으므로 y축에 무엇이 플로팅되고 있는지를 추론할 수 있습니다(회수/빈도). 그러나 x축에는 무엇이 플로팅되고 있는지요? 이것은 다양한 양에 대한 것이 될 수 있으며, 데이터 집합을 사전에 알 경우에만 추론을 시작할 수 있습니다. 협업자들과 같은 내부 사용을 위한 플롯을 보낼 때에도, 즉, 내용을 추측하는 것을 독자에게 맡기면 안 됩니다.\n\n![플롯](/assets/img/2024-07-01-HowtoMakeYourDataVisualizationsTellaStory_14.png)\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음 반복 작업은 상당히 향상되었습니다. 하지만 독자는 콜레스테롤 수치가 어떤 단위인지 여전히 알지 못합니다. 이 수치는 무게/부피의 어떤 조합일 수 있습니다(예: 마이크로그램/리터, 나노그램/리터 등). 이 중요한 세부 내용을 추가하면 플롯의 최종 버전이 됩니다:\n\n![image](/assets/img/2024-07-01-HowtoMakeYourDataVisualizationsTellaStory_15.png)\n\n```js\n## 데이터 포맷팅\nchol = df.chol.to_numpy()\n\n## 플로팅\nmatplotlib.rcParams.update({'font.size': 31})\nfig, ax = plt.subplots(figsize=(10, 8))\n\nax.grid('both', zorder=0)\nax.hist(chol, bins=30, edgecolor='k', facecolor='forestgreen', zorder=2)\nax.set_xlim(0, 600)\nax.set_ylim(0, 40)\nax.set_xticks(np.arange(0, 700, 100))\nax.set_xlabel('콜레스테롤 농도 (mg/dl)', loc='right', fontsize=36)\nax.set_ylabel('빈도', loc='top', fontsize=36)\n#ax.set_title('히스토그램')\n#ax.tick_params(axis='x', which='minor', bottom=True)#, bottom=False)\nplt.minorticks_on()\n#ax.tick_params(axis='both', which='major', labelsize=4)\n#ax.tick_params(axis='both', which='minor', labelsize=2)\n\n\nfig.tight_layout()\nfig.savefig('labeled_hist_1.pdf')\n```\n\n물론, 플로팅되는 변수에 단위가 없는 경우 특성 이름을 추가하는 것이 적절합니다. 일부 경우에서 축 레이블의 단위 부분으로 \"임의 단위\"를 사용하는 것도 허용되지만, 이는 대부분 중복된 추가입니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 규칙 3: 가능한 경우 오차 막대 추가하기\n\n일반적으로 오차 막대가 없는 선 그래프를 볼 때 가장 먼저 떠오르는 의문점은 \"어디에 오차 막대가 있는 거죠?\" 입니다. 가능한 경우 작성자는 반드시 오차 막대를 포함해야 합니다. 물론, 오차 막대가 너무 작아서 마커로 가려지는 경우는 캡션이나 설명과 함께 명시되어야 합니다. 예를 들어, 첫 눈에 왼쪽 그래프에서 독립 변수가 증가함에 따라 두 곡선이 분명히 서로 다르게 변화하는 것을 볼 수 있습니다:\n\n![Error Bars Example](/assets/img/2024-07-01-HowtoMakeYourDataVisualizationsTellaStory_16.png)\n\n```js\n## 데이터 생성\nx_vals   = np.arange(0, 20, 1)\nnum_vals = x_vals.shape[0] \n\ny0     = 1.4 * x_vals + (np.random.rand(num_vals) + 3.3)\ny1     = 1.6 * x_vals + (np.random.rand(num_vals) + 3.5)\ny_data = [y0, y1]\n\nerror0     = x_vals * 0.1\nerror1     = x_vals * 0.28\nerror_data = [error0, error1]\n\ncolors = ['xkcd:azure', 'xkcd:carmine']\n\nmpl.rcParams.update({'font.size': 34})\n\nfig, ax = plt.subplots(1, 2, figsize=(16,9))\nfor plot in np.arange(2):\n    for dataset in np.arange(2):\n        if plot == 0:\n            ax[plot].plot(x_vals, y_data[dataset], marker='o', color=colors[dataset], label='Dataset %d' % dataset)\n        else:\n            ax[plot].errorbar(x_vals, y_data[dataset], error_data[dataset], marker='o', color=colors[dataset], label='Dataset %d' % dataset)\n    \n    ax[plot].set_xlim(-2, 22)\n    ax[plot].set_ylim(0, 42)\n    ax[plot].set_xlabel('독립 변수', loc='right')\n    ax[plot].set_ylabel('종속 변수', loc='top')\n    ax[plot].legend(fontsize=30)\n    ax[plot].minorticks_on()\n    ax[plot].set_xticks(np.arange(0, 25, 5))\n    ax[plot].set_yticks(np.arange(0, 45, 5))\n    \nfig.tight_layout()\nfig.savefig('error_bars_example.pdf')\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그러나 오른쪽 그림에 오차 막대가 있는 그래프를 확인해보면, 이러한 이질성이 꼭 그렇지 않을 수 있음을 알 수 있습니다: x 값이 증가할수록 데이터 집합 1의 오차가 단조롭게 증가합니다. 이로써 두 데이터 집합이 모두 이질적이라는 주장이 의심스러운 것입니다. 이를 덧없이 언급할 때, 오직 조금 더 정교한 통계적 검정 없이 이 관측 결과만으로 (즉, 더 나은 통계 검정 없이) 우리는 이전과 같이 두 선이 모두 이질적임을 결론 지을 수 없습니다.\n\n# 규칙 4: 모든 것의 글꼴 크기를 키우세요\n\n작고 괴롭히는 글꼴 크기의 큰 그림은 성가신 일입니다. 특히 인쇄용이거나 발표용으로 서식이 지정된 그래프를 볼 때는 더욱 그렇습니다. 회의나 회의가 진행될 때 발표를 들으면 눈에 꺼내어 x 및 y축 레이블을 읽기 위해 눈을 잔뜩 까놓아야 할 때 즐거움이 있을 리가 없습니다. 그림의 \"전체적인 그림\"은 확대하거나 눈을 찌푸리지 않아도 파악할 수 있어야 합니다. 현대 기술과 (규칙 14를 참조하십시오)에서 그림이 적절한 형식으로 저장된 경우에는 크게 문제가 되지 않을 것입니다. 그러나 규칙 14를 깨야 하는 경우에는, 그림이 합리적으로 수용할 수 있는 한 큰 글꼴 크기를 늘리는 것이 가장 좋습니다. 또한, 제 시각적인 의견으로는, 더 큰 글꼴 크기가 더 잘 보인다고 생각합니다. 아래 그림을 고려해보십시오 (Kaggle 데이터 세트는 여기에서 사용 가능합니다):\n\n<img src=\"/assets/img/2024-07-01-HowtoMakeYourDataVisualizationsTellaStory_17.png\" />\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\nhousing_prices_2 = pd.read_csv('Housing_Price_Data.csv')\n\nprice_no_ac_df = housing_prices_2[housing_prices_2['airconditioning'] == 'no']\nprice_with_ac_df = housing_prices_2[housing_prices_2['airconditioning'] == 'yes']\n\nmpl.rcParams.update({'font.size': 10})  # Matplotlib의 기본 글꼴 크기를 10으로 설정\n\nfig, ax = plt.subplots(figsize=(9, 9))\n\nax.scatter(price_no_ac_df['area'], price_no_ac_df['price'], c='xkcd:vibrant green', s=12, marker='o', label='에어컨 없음')\nax.scatter(price_with_ac_df['area'], price_with_ac_df['price'], c='xkcd:orangered', s=12, marker='D', label='에어컨 있음')\n\nax.set_xlabel('면적 (ft$^{2}$)', loc='right')\nax.set_ylabel('가격 (USD)', loc='top')\nax.set_xlim(1000, 20000)\nax.set_ylim(1e6, 2.1e7)\nax.set_yscale('log')\nax.set_xscale('log')\nax.legend(loc='upper left', markerscale=2.4)\nfig.tight_layout()\nfig.savefig('small_font_example.pdf')\n```\n\n이 그래프는 Matplotlib의 글꼴 크기를 기본값 10으로 사용하여 만들었습니다. 눈금과 축 레이블을 읽기 어렵게 만들어 전체적으로 해석하기 어렵게 합니다. 동일한 그래프를 글꼴 크기를 26으로 크게 한 것으로 생각해보세요:\n\n![Large Font Example](https://cdn.url/assets/img/2024-07-01-HowtoMakeYourDataVisualizationsTellaStory_18.png)\n\n```python\nmpl.rcParams.update({'font.size': 26})\n\nfig, ax = plt.subplots(figsize=(8, 8))\n\nax.scatter(price_no_ac_df['area'], price_no_ac_df['price'], c='xkcd:vibrant green', s=12, marker='o', label='에어컨 없음')\nax.scatter(price_with_ac_df['area'], price_with_ac_df['price'], c='xkcd:orangered', s=12, marker='D', label='에어컨 있음')\n\nax.set_xlabel('면적 (ft$^{2}$)', loc='right')\nax.set_ylabel('가격 (USD)', loc='top')\nax.set_xlim(1000, 20000)\nax.set_ylim(1e6, 2.1e7)\nax.set_yscale('log')\nax.set_xscale('log')\nax.legend(loc='upper left', markerscale=2.4)\nfig.tight_layout()\nfig.savefig('large_font_example.pdf')\n```  \n\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n독자들이 폰트 크기를 늘려줘서 감사할 거예요.\n\n# Rule 5: 축의 스케일을 적절하게 설정하세요\n\n여러 개 주문에 걸친 데이터는 거의 항상 로그 축을 사용하여 플로팅해야 합니다. 어느 시점에서는, 두 개 이상의 수주에 걸쳐 변환해야 하는 경우도 있을 것입니다. 이는 그래프의 하나, 또는 모든 축에 적용될 수 있습니다. 이 예제에서는 계수 a에 의해 스케일링된 자연 로그 곡선을 그릴 것입니다:\n\n![그림](/assets/img/2024-07-01-HowtoMakeYourDataVisualizationsTellaStory_19.png)\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n## 데이터 생성\na_coeff = 1.5\n\nx_data = np.arange(10, 48000, 0.1)\ny_data = a_coeff * np.log(x_data)\n\nmpl.rcParams.update({'font.size': 34})\n\nfig, ax = plt.subplots(figsize=(9,8))\nax.plot(x_data, y_data, linewidth=2.4, c='xkcd:indigo')\nax.grid(which='major', color='xkcd:cool grey', linestyle='-', alpha=0.7, zorder=0)\nax.grid(which='minor', color='xkcd:light grey', linestyle='--', alpha=0.5, zorder=0)\nax.set_xlabel('$x$', loc='right')\nax.set_ylabel('$f(x)$', loc='top')\nax.minorticks_on()\nax.set_ylim(0, 20)\n\nprops = dict(boxstyle='round', facecolor='xkcd:indigo', alpha=0.3)\n\nax.text(0.062, 0.81, '$f(x) = a\\cdot\\mathrm{ln}(x)$\\na = 1.5', fontsize=26, bbox=props, transform=ax.transAxes)\nfig.tight_layout()\nfig.savefig('no_log_example.pdf')\n```\n\nx-축이 여러 개의 자릿수에 걸쳐 있어 공간이 효율적으로 사용되지 않는 것을 알 수 있습니다. 그래프의 우측 하단 부분에는 많은 빈 공간이 있습니다. 독립 데이터에 로그 변환을 적용할 수 있는 완벽한 상황입니다. 우리는 이 변환을 직접 계산할 필요가 없습니다. Matplotlib가 내부적으로 처리해 줄 것입니다.\n\n![image](/assets/img/2024-07-01-HowtoMakeYourDataVisualizationsTellaStory_20.png)\n\n```js\nmpl.rcParams.update({'font.size': 34})\n\nfig, ax = plt.subplots(figsize=(9,8))\nax.grid(which='major', color='xkcd:cool grey', linestyle='-', alpha=0.7, zorder=0)\nax.grid(which='minor', color='xkcd:light grey', linestyle='--', alpha=0.5, zorder=0)\nax.plot(x_data, y_data, linewidth=2.4, c='xkcd:indigo')\nax.set_xlabel('$x$', loc='right')\nax.set_ylabel('$f(x)$', loc='top')\nax.minorticks_on()\nax.set_xscale('log')\nax.set_ylim(0, 20)\nax.set_xlim(5, 9e4)\n\nprops = dict(boxstyle='round', facecolor='xkcd:indigo', alpha=0.3) # 텍스트 상자 속성\nax.text(0.062, 0.81, '$f(x) = a\\cdot\\mathrm{ln}(x)$\\na = 1.5', fontsize=26, bbox=props, transform=ax.transAxes)\nfig.tight_layout()\nfig.savefig('semi_log_example.pdf')\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nx-축에 로그 스케일을 적용하여 사용 가능한 공간을 훨씬 더 효율적으로 활용할 수 있습니다. 최상의 예시는 아니지만, 많은 단위 범위를 다루는 데이터에 대해 로그 축이 더 적합한 이유를 보여줍니다.\n\n# 규칙 6: 보조 눈금 및 그리드 사용\n\n보조 눈금을 사용하면 독자에게 귀중한 도움이 됩니다. 로그-노멀 또는 로그-로그 축을 다룰 때는 그리드가 심사숙고하여 구현될 때 더 유용한 기능이 될 수 있습니다. 아래 예시를 고려해보세요:\n\n![이미지](/assets/img/2024-07-01-HowtoMakeYourDataVisualizationsTellaStory_21.png)\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\n## 데이터 생성\nx_data   = np.arange(0.1, 20.1, 0.1)\nexp_data = (1/200) * np.power(x_data, 3)\n\nmpl.rcParams.update({'font.size': 34})\nfig, ax=plt.subplots(figsize=(10,8))\nax.plot(x_data, exp_data, linewidth=2, color='xkcd:deep sky blue')\nax.set_xlabel('x',    loc='right', fontsize=40)\nax.set_ylabel('f(x)', loc='top',   fontsize=40)\nax.set_xlim(0, 22)\nax.set_ylim(0, 42)\nprops = dict(boxstyle='round', facecolor='white', alpha=0.7)\nax.text(0.08, 0.83, \"$f(x) = \\dfrac{x^{3}{200}$\", fontsize=32, bbox=props, transform=ax.transAxes)\nfig.tight_layout()\nfig.savefig('four_x_cubed_no_minor_ticks.pdf')\n```\n\n위의 그림은 x축과 y축이 모두 선형 스케일로 나타난 곡선을 보여줍니다. 그러나 플롯의 왼쪽에 많은 여백이 있어 곡선에서 x 및 y 값을 정확히 파악하기 어렵습니다. 이 그림을 보다 쉽게 읽을 수 있도록 몇 가지 마이너 틱을 추가할 수 있습니다:\n\n<img src=\"/assets/img/2024-07-01-HowtoMakeYourDataVisualizationsTellaStory_22.png\" />\n\n```python\nmpl.rcParams.update({'font.size': 34})\n\nfig, ax=plt.subplots(figsize=(10,8))\nax.plot(x_data, exp_data, linewidth=2, color='xkcd:deep sky blue')\nax.set_xlabel('x',    loc='right', fontsize=40)\nax.set_ylabel('f(x)', loc='top',   fontsize=40)\nax.set_xlim(0, 22)\nax.set_ylim(0, 42)\nax.minorticks_on()\nprops = dict(boxstyle='round', facecolor='white', alpha=0.7)\nax.text(0.08, 0.83, \"$f(x) = \\dfrac{x^{3}{200}$\", fontsize=32, bbox=props, transform=ax.transAxes)\nfig.tight_layout()\nfig.savefig('four_x_cubed_with_minor_ticks.pdf')\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이렇게 하면 더 쉬워지지만, 그리드 사용은 시각적 안내에 더 효과적일 수 있습니다. 아래의 두 그래프를 비교해보세요: 왼쪽에는 주 그리드 라인만 표시되고, 오른쪽에는 소 그리드와 주 그리드 라인이 모두 표시됩니다:\n\n![Grid Comparison](/assets/img/2024-07-01-HowtoMakeYourDataVisualizationsTellaStory_23.png)\n\n```python\nmpl.rcParams.update({'font.size': 42})\nprops = dict(boxstyle='round', facecolor='white', alpha=0.7)\n\nfig, ax=plt.subplots(1, 2, figsize=(20,10))\nax = ax.ravel()\n\nfor plot in np.arange(2):\n    ax[plot].plot(x_data, exp_data, linewidth=2, color='xkcd:deep sky blue')\n    ax[plot].set_xlabel('x',    loc='right', fontsize=40)\n    ax[plot].set_ylabel('f(x)', loc='top',   fontsize=40)\n    ax[plot].set_xlim(0, 22)\n    ax[plot].set_ylim(0, 42)\n    ax[plot].minorticks_on()\n    ax[plot].set_xticks(np.arange(0, 25, 5))\n    if plot == 0:\n        ax[plot].grid()\n    else:\n        plt.grid(True, which=\"both\")\n\n    ax[plot].text(0.08, 0.83, \"$f(x) = \\dfrac{x^{3}{200}$\", fontsize=38, bbox=props, transform=ax[plot].transAxes)\nfig.tight_layout()\nfig.savefig('four_x_cubed_with_minor_ticks_major_minor_grid.pdf')\n```\n\n오른쪽에 있는 그래프가 우리에게 가장 유용한 정보를 제공합니다: 소 그리드 라인이 시각을 안내하여 곡선 상의 점을 식별하기가 훨씬 쉬워집니다. 그러나 주 그리드 라인과 소 그리드 라인의 선 종류 및 색상을 사용자 정의하는 것으로 한 발짝 더 나아갈 수 있습니다:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nmpl.rcParams.update({'font.size': 34})\n\n\nfig, ax=plt.subplots(figsize=(10,8))\nax.plot(x_data, exp_data, linewidth=2, color='xkcd:deep sky blue')\n#ax.set_xscale('log')\n#ax.set_yscale('log')\n\n\nax.set_xlabel('x', loc='right', fontsize=40)\nax.set_ylabel('f(x)', loc='top', fontsize=40)\nax.set_xlim(0, 22)\nax.set_ylim(0, 42)\nax.minorticks_on()\nprops = dict(boxstyle='round', facecolor='white', alpha=0.7)\nax.text(0.08, 0.83, \"$f(x) = \\dfrac{x^{3}{200}$\", fontsize=32, bbox=props, transform=ax.transAxes)\n\nax.grid(which='major', color='xkcd:cool grey', linestyle='-', alpha=0.7)\nax.grid(which='minor', color='xkcd:light grey', linestyle='--', alpha=0.5)\nfig.tight_layout()\nfig.savefig('four_x_cubed_with_minor_ticks_major_minor_grid_custom.pdf')\n```\n\n사용자 정의 그리드를 추가하여 주요 그리드 선을 미세 그리드 선보다 강조하는 것은 꽤 차이를 만들 수 있어요!\n\n# Rule 7: Don’t forget the legend\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n뻔한 말이지만, 제가 본 플롯 중에는 이 중요한 요소가 생략된 경우가 많았습니다. 특이한 피처를 가진 플롯의 경우에는 보통 이것이 문제가 되지 않습니다 — 보통 x-축과 y-축 레이블에서 데이터의 신원을 추론할 수 있습니다; 그러나 어쨌든 범례를 추가하는 것이 가장 좋습니다. 이 선택적인 피처는 단일 플롯에 여러 곡선, 산포도 등을 그릴 때 필수적인 요소가 됩니다. 아래의 막대 플롯을 고려해보세요:\n\n![그림](/assets/img/2024-07-01-HowtoMakeYourDataVisualizationsTellaStory_25.png)\n\n```js\n## 데이터 생성\ncategories = np.array(['A','B','C','D', 'E']) \ngroup_a    = np.array([5, 22, 34, 10, 7]) \ngroup_b    = np.array([15, 4, 22, 8, 12])\ngroup_c    = np.array([30, 10, 9, 17, 23])\n\nmpl.rcParams.update({'font.size': 32})\n\nfig, ax = plt.subplots(figsize=(10,8))\nx_ticks   = np.arange(categories.shape[0]) \nbar_width = 0.2\n\nax.bar(x_ticks - 0.2, group_a, width=0.2, label='Group A', color='xkcd:pumpkin orange') \nax.bar(x_ticks + 0.0, group_b, width=0.2, label='Group B', color='xkcd:goldenrod') \nax.bar(x_ticks + 0.2, group_c, width=0.2, label='Group C', color='xkcd:carmine') \n\nax.set_xticks(x_ticks, categories) \nax.set_xlabel('Category', loc='right') \nax.set_ylabel('Number of ocurrences', loc='top') \n\nax.yaxis.set_minor_locator(ticker.AutoMinorLocator())\nfig.tight_layout()\nfig.savefig('bar_chart_with_legend.pdf')\n```\n\n분명하게, 여기에서 다섯 가지 다른 카테고리에 대해 세 개의 개별 데이터셋이 플롯되어 있습니다. 범례가 없으면 이 플롯은 해독할 수 없습니다; 우리는 세 가지 다른 막대 색상이 무슨 의미인지 이해해야 합니다. 범례를 추가하면 마침내 제시된 정보를 해석할 수 있습니다:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n## 데이터 생성\ncategories = np.array(['A','B','C','D', 'E']) \ngroup_a    = np.array([5, 22, 34, 10, 7]) \ngroup_b    = np.array([15, 4, 22, 8, 12])\ngroup_c    = np.array([30, 10, 9, 17, 23])\n\nmpl.rcParams.update({'font.size': 32})\n\nfig, ax = plt.subplots(figsize=(10,8))\nx_ticks   = np.arange(categories.shape[0]) \nbar_width = 0.2\n\nax.bar(x_ticks - 0.2, group_a, width=0.2, label='Group A', color='xkcd:pumpkin orange') \nax.bar(x_ticks + 0.0, group_b, width=0.2, label='Group B', color='xkcd:goldenrod') \nax.bar(x_ticks + 0.2, group_c, width=0.2, label='Group C', color='xkcd:carmine') \n\nax.set_xticks(x_ticks, categories) \nax.set_xlabel('Category', loc='right') \nax.set_ylabel('Number of ocurrences', loc='top') \nax.legend(fontsize=24) # 범례 추가\nax.yaxis.set_minor_locator(ticker.AutoMinorLocator())\nfig.tight_layout()\nfig.savefig('bar_chart_with_legend.pdf')\n```\n\n초보용 예제이지만 의도적으로 선택한 것은 명확한 필요성을 보여주는 범례입니다.\n\n마지막으로, 범례가 표시 중인 데이터와 겹치지 않도록 주의하십시오! 이렇게 되면 혼란스러울 수 있습니다(데이터를 얼마나 많이 차지하는지에 따라 다를 수 있음) 그리고 전달하려는 내용을 방해할 수도 있습니다. 플롯 내에 범례를 맞게 배치하도록 축 스케일을 조정하거나 범례 글꼴 크기를 약간 줄이세요(즉, Rule 4을 어기지 마세요!).\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 규칙 8: 명확함이 중요합니다\n\n현재 시대에는 그래픽 출판물을 위해 구별 가능한 색상(또는 회색의 음영)을 선택해야 했던 시절은 더 이상 흔하지 않지만 각 데이터가 서로 다른 색상, 표식 및 선 유형(실선, 대시 등)으로 구별되어야 하는 것이 여전히 중요합니다. 서로 겹치지 않거나 쉽게 구별되는 곡선이 있는 그래프의 경우 다른 색상만으로 충분합니다. 내 의견으로는 곡선에 표식이 없을 때 이 전략이 더 잘 작동합니다:\n\n```js\n## 데이터 생성\nx_data       = np.arange(1, 20, 1)\nx_data_gauss = np.arange(1, 20, 0.5)\n\nslope0 = 1.5 \nslope1 = 3\nslope2 = 6\nint0   = 1\nint1   = 2\nint2   = 3\nint3   = 5\nint4   = 4\nsigma  = 2\nscale4 = 1.5\npower4 = 1.5\ny_data0 = slope0 * x_data + int0\ny_data1 = slope1 * x_data + int1\ny_data2 = slope2 * x_data + int2\ny_data3 = (1000 / (2 * np.pi * np.sqrt(np.power(sigma, 2)))) * np.exp(-1 * (np.power((x_data_gauss - 10), 2) / (2 * np.power(sigma, 2))))\ny_data4 = scale4 * np.power(x_data, power4) + int4\n\nmpl.rcParams.update({'font.size': 30})\nfig, ax = plt.subplots(figsize=(8,8))\n\nax.plot(x_data, y_data0,       markersize=7, linewidth=2, color='xkcd:azure',       label='$f(x)=%.1fx + %d$' % (slope0, int0))\nax.plot(x_data, y_data1,       markersize=7, linewidth=2, color='xkcd:carmine',     label='$f(x)=%.1fx + %d$' % (slope1, int1))\nax.plot(x_data, y_data2,       markersize=8, linewidth=2, color='xkcd:blue violet', label='$f(x)=%.1fx + %d$' % (slope2, int2))\nax.plot(x_data_gauss, y_data3, markersize=7, linewidth=2, color='xkcd:true green',  label='$f(x)=80e^{-(x-10)^{2}/8}$')\nax.plot(x_data, y_data4,       markersize=8, linewidth=2, color='xkcd:cyan',        label='$f(x)=%.1fx^{.1f} + %d$' % (scale4, power4, int4))\nax.set_xlabel('x', loc='right')\nax.set_ylabel('f(x)', loc='top')\nax.legend(loc='upper left', fontsize=20)\nax.set_xlim(0, 22)\nax.set_ylim(0, 160)\nax.set_xticks(np.arange(0, 25, 5))\nax.grid(which='major', color='xkcd:cool grey', linestyle='-', alpha=0.5)\nax.grid(which='minor', color='xkcd:light grey', linestyle='--', alpha=0.5)\nax.minorticks_on()\nfig.tight_layout()\nfig.savefig('legend_example_colors_only_no_markers.pdf')\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n각 색깔은 충분히 다르기 때문에 쉽게 구별할 수 있지만, 이 경우 선 스타일을 변경하는 것도 나쁘지 않습니다. 특히 곡선의 수가 색상과 마커/마커 채움 스타일을 쉽게 구별할 수 있는 한계점에 접근할 때 추가가 가치가 있습니다.\n\n내 의견으로는 각 곡선에 동일한 마커를 추가하면 플롯이 혼란스러워집니다. 색상은 다르지만 그렇습니다.\n\n```js\nmpl.rcParams.update({'font.size': 30})\nfig, ax = plt.subplots(figsize=(8,8))\n\nax.plot(x_data, y_data0,       marker='o', markersize=7, linewidth=2, color='xkcd:azure',       label='$f(x)=%.1fx + %d$' % (slope0, int0))\nax.plot(x_data, y_data1,       marker='o', markersize=7, linewidth=2, color='xkcd:carmine',     label='$f(x)=%.1fx + %d$' % (slope1, int1))\nax.plot(x_data, y_data2,       marker='o', markersize=8, linewidth=2, color='xkcd:blue violet', label='$f(x)=%.1fx + %d$' % (slope2, int2))\nax.plot(x_data_gauss, y_data3, marker='o', markersize=7, linewidth=2, color='xkcd:true green',  label='$f(x)=80e^{-(x-10)^{2}/8}$')\nax.plot(x_data, y_data4,       marker='o', markersize=8, linewidth=2, color='xkcd:cyan',        label='$f(x)=%.1fx^{.1f} + %d$' % (scale4, power4, int4))\n#ax.plot(x_data, y_data1, marker='s', color='xkcd:carmine')\nax.set_xlabel('x', loc='right')\nax.set_ylabel('f(x)', loc='top')\nax.legend(loc='upper left', fontsize=20)\nax.set_xlim(0, 22)\nax.set_ylim(0, 160)\nax.set_xticks(np.arange(0, 25, 5))\nax.grid(which='major', color='xkcd:cool grey', linestyle='-', alpha=0.5)\nax.grid(which='minor', color='xkcd:light grey', linestyle='--', alpha=0.5)\nax.minorticks_on()\nfig.tight_layout()\nfig.savefig('legend_example_colors_only.pdf')\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n마커와 채우기 스타일(또는 선 스타일)을 다르게 설정하면 도표를 더 쉽게 읽을 수 있습니다:\n\n![Plot Image](/assets/img/2024-07-01-HowtoMakeYourDataVisualizationsTellaStory_29.png)\n\n```js\nmpl.rcParams.update({'font.size': 30})\nfig, ax = plt.subplots(figsize=(8,8))\n\nax.plot(x_data, y_data0, marker='o', markersize=7, linewidth=2, color='xkcd:azure', label='$f(x)=%.1fx + %d$' % (slope0, int0))\nax.plot(x_data, y_data1, marker='s', markersize=7, linewidth=2, color='xkcd:carmine', label='$f(x)=%.1fx + %d$' % (slope1, int1))\nax.plot(x_data, y_data2, marker='^', markersize=8, linewidth=2, color='xkcd:blue violet', label='$f(x)=%.1fx + %d$' % (slope2, int2))\nax.plot(x_data_gauss, y_data3, marker='D', markersize=7, linewidth=2, color='xkcd:true green', label='$f(x)=80e^{-(x-10)^{2}/8}$', fillstyle='none',)\nax.plot(x_data, y_data4, marker='P', markersize=8, linewidth=2, color='xkcd:cyan', label='$f(x)=%.1fx^{.1f} + %d$' % (scale4, power4, int4), fillstyle='none',)\nax.set_xlabel('x', loc='right')\nax.set_ylabel('f(x)', loc='top')\nax.legend(loc='upper left', fontsize=20)\nax.set_xlim(0, 22)\nax.set_ylim(0, 160)\nax.set_xticks(np.arange(0, 25, 5))\nax.grid(which='major', color='xkcd:cool grey', linestyle='-', alpha=0.5)\nax.grid(which='minor', color='xkcd:light grey', linestyle='--', alpha=0.5)\nax.minorticks_on()\nfig.tight_layout()\nfig.savefig('legend_example_colors_markers.pdf')\n```\n\n# Rule 9: 일관성은 중요합니다\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n슬라이드 세트, 학회 포스터 또는 저널 논문에 서로 다른 스타일의 플롯이 포함되어 있는 것은 이상하게 보일 수 있습니다. 이겈 엄밀하게 보일 수 있지만, 일관된 스타일을 유지하는 것은 플롯 간의 연속성을 유지하고 작업을 보다 통일되게 보이게 도와줍니다. 이 스타일은 상황에 따라 달라질 수 있습니다. 예를 들어 일부 저널은 플롯(그리고 테이블 등)을 특정 형식으로 선호할 수 있습니다. 또는 많은 과학적 협업에서는 특정한 플롯 스타일이 논문을 저널에 제출하기 위해 요구될 수 있습니다. 더불어, 여러분의 작업이 더 유요하게 보이게 하고 발표 자료들 사이의 일관된 스타일을 유지하기 위해 도움이 됩니다. 그러므로, 여러분만의 플롯 스타일을 개발하거나 요구된 스타일을 채택한다면 작업의 일관성을 높일 수 있습니다.\n\n# Rule 10: 과적합에 주의하세요\n\n이것은 Rule 1과 모순된 것처럼 보일 수도 있지만, 모든 것은 균형을 이루어야 합니다. 하나의 플롯 용량은 무한하지 않습니다. 너무 많은 데이터나 텍스트 상자와 같은 부착물을 추가하면 메시지가 혼란스러워질 수 있습니다. 이러한 데이터를 서브플롯으로 분리하는 것은 그림의 가독성을 높이는 데 도움이 될 뿐입니다. 아래의 플롯은 이 효과를 완벽히 보여줍니다:\n\n<img src=\"/assets/img/2024-07-01-HowtoMakeYourDataVisualizationsTellaStory_30.png\" /> \n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n플롯의 혼란이 x ≥ 30에서 해소되지만 이 범위 아래의 값들은 데이터 포인트와 교차하는 선들이 꼬리를 치는 메시가 됩니다. 그 결과 플롯의 메시지가 흐려지게 되죠. 다음 규칙(규칙 11)에서 말했듯이, 데이터에 맞는 함수는 적합한 매개변수, 그 오차, 적합도 측정값을 나열한 텍스트 상자와 함께 사용되어야 합니다. 위의 플롯에서는 이러한 텍스트 상자를 넣을 공간이 없어서 플롯의 x 또는 y 한계를 불필요하게 연장시키게 되며, 결과적으로 규칙 13(“텍스트 상자를 절약하여 사용”)를 위반합니다. 이 문제를 해결하기 위해, 데이터셋과 해당 적합선을 개별 부분 그림으로 나누면 됩니다.\n\n여기에서 각 데이터셋이 명확하게 분리되어 있으며, 범례도 덜 복잡하며, 선형 최적 적합선과 일치하는 텍스트 상자가 추가되어 그림을 더 잘 정리하고 결과적으로 플롯을 훨씬 더 읽기 쉽게 만들 수 있습니다.\n\n# 규칙 11: 적합 매개변수를 요약하는 텍스트 상자 추가하기\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n텍스트 상자는 플롯에 완벽한 보충물이 될 수 있어요. 예를 들어, 적합이 적용된 데이터는 항상 적합 매개변수를 설명하는 텍스트 상자를 가져야 합니다. 또한 적합의 품질에 관한 어떤 측정 항목(예: 결정 계수, R², 또는 카이 제곱 통계의 자유도 수에 대한 비율, χ²/dof)이 표시돼야 해요.\n\n아래에 표시된 것처럼:\n\n![이미지](/assets/img/2024-07-01-HowtoMakeYourDataVisualizationsTellaStory_32.png)\n\n```python\n## 적합 함수 정의\ndef func(x_data, m_val, b_val):\n    return (m_val * x_data) + b_val\n    \npopt, pcov = curve_fit(func, x_data, y_data) # 함수 적합\n\n## 결정 계수 계산\nres          = y_data - func(x_data, *popt) # 잔차 계산\nsum_res_sq   = np.sum(np.power(res, 2)) # 잔차 제곱의 합\nsum_sq_total = np.sum(y_data - np.power(np.mean(y_data), 2))\nr_squared    = 1 - (sum_res_sq / sum_sq_total) # 결정 계수 계산\n\nmpl.rcParams.update({'font.size': 32})\nprops = dict(boxstyle='round', facecolor='xkcd:scarlet', alpha=0.3)\n\nfig, ax = plt.subplots(figsize=(9, 8))\nax.minorticks_on()\nax.grid('both', zorder=0)\n...\n(fig 설정 및 플롯)\n\nax.text(0.085, 0.75, \"$f(x) = mx + b$\\n$m = %.3f\\pm%.3f$\\n$b = %.3f\\pm%.3f$\\n$R^{2} = %.2f$\" % (popt[0], pcov[0, 0], popt[1], pcov[1,1], r_squared), fontsize=22, bbox=props, transform=ax.transAxes)\nfig.tight_layout()\nfig.savefig('linear_fit_example.pdf')\n```\n\n이 규칙은 히스토그램에서도 유용할 수 있어요. 종종 관련 통계 정보(평균, 표준 편차, 중앙값, 총 항목 수 등)를 요약하는 텍스트 상자를 추가하는 것이 매우 도움이 될 수 있어요.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# Rule 12: 동시에 플롯을 비교할 때는 동일한 축 척도를 사용하세요\n\n데이터 시각화의 목표가 서로 다른 데이터 세트를 비교하는 것이라면, 이러한 데이터들을 동일한 축 척도를 사용하여 플로팅하는 것이 매우 중요합니다. 아래의 플롯을 살펴보세요. 이 플롯은 남성과 여성 콜레스테롤 분포의 확률 밀도 함수(PDFs)를 비교합니다 (Rule 0에서 사용된 'heart' 데이터셋):\n\n![PDF Comparison Plots](/assets/img/2024-07-01-HowtoMakeYourDataVisualizationsTellaStory_33.png)\n\n```js\n## 데이터 전처리\nlog_dens   = [log_dens_m, log_dens_f]\npdf_colors = ['forestgreen', 'xkcd:cerulean']\npdf_labels = ['남성', '여성']\n\nmpl.rcParams.update({'font.size': 28})\nfig, ax = plt.subplots(1, 2, figsize=(15, 8))\n\nfor subplot in np.arange(2):\n    ax[subplot].minorticks_on()\n    ax[subplot].grid(which='major', color='xkcd:cool grey', linestyle='-', alpha=0.7)\n    ax[subplot].grid(which='minor', color='xkcd:light grey', linestyle='--', alpha=0.5)\n    ax[subplot].plot(np.arange(0, 600), np.exp(log_dens[subplot]), color=pdf_colors[subplot], linewidth=2)\n    ax[subplot].set_xlabel('콜레스테롤 농도 (mg/dl)', loc='right')\n    ax[subplot].set_ylabel('확률 밀도', loc='top')\n    ax[subplot].grid('both', zorder=0)\n    ax[subplot].fill(np.arange(0, 600), np.exp(log_dens[subplot]), color=pdf_colors[subplot], alpha=0.4)\n    ax[subplot].set_xlim(-25, 625)\n    \n    legend = [mpatches.Patch(color=pdf_colors[subplot], label=pdf_labels[subplot], alpha=0.6)]\n    ax[subplot].legend(handles=legend)\n\nfig.tight_layout()\nfig.savefig('pdf_comparison_plots_different_scales.pdf')\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n각 서브플롯의 y-축이 공통 범위를 공유하지 않기 때문에 두 PDF를 직접적으로 일대일로 비교하기 어렵습니다. 이 문제를 수정함으로써 이제 두 서브플롯을 더 쉽게 비교할 수 있습니다.\n\n![이미지](/assets/img/2024-07-01-HowtoMakeYourDataVisualizationsTellaStory_34.png)\n\n# 규칙 13: 텍스트 상자를 절약해서 사용하세요\n\n이 규칙은 텍스트 상자를 과하게 사용하지 않도록 미세한 알림입니다. 이 규칙은 실제로 규칙 10(\"플롯을 너무 가득 채우지 마세요\")의 확장성에 불과합니다. 일부 데이터셋과 플롯에서는 나란히 플로팅된 데이터셋의 매개변수/서술자를 포함하는 여러 텍스트 상자를 추가하는 것이 유용할 수 있지만, 공간이 제한되어 있거나 플롯이 이미 균형을 이루고 있는 경우, 추가 텍스트 상자를 맞추기 위해 축을 늘리지 마세요. 해당 정보는 그림 설명에 추가할 수 있습니다. 예를 들어, 규칙 10의 첫 번째 예제에 모든 세 맞춤 매개변수에 대한 텍스트 상자를 추가하는 것은 부적절합니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 규칙 14: 플롯을 .pdf 파일로 저장하세요\n\n이것은 제 개인적인 짜증 나는 점 중 하나 입니다. .png, .jpg, .gif 또는 .tiff와 같은 형식은 래스터(비트맵) 이미지 형식의 가족에 속하며 일반적으로 인치당 도트 (dpi) 또는 픽셀당 인치 (ppi)로 지정된 해상도를 사용하여 이미지를 구성합니다. 이는 확대할 때 픽셀의 난리를 볼 수 있다는 불행한 상황으로 이어집니다. 반면에 .pdf, .svg 또는 .eps와 같은 벡터 그래픽 형식은 정보를 객체로 저장합니다 (예: 객체와 공간 상의 위치에 대한 설명). 결과적으로 복잡한 플롯에서 정보를 추출하는 것이 훨씬 쉬워지기 때문에 무한대로 확대할 수 있습니다. 대부분의 플롯이 어차피 컴퓨터에서 볼텐데, 사용자가 무한대로 확대할 수 있는 자유를 허용하는 것이 좋지 않을까요?\n\n# 요약 및 결론\n\n이 기사를 쓰기 시작했을 때는 훨씬 짧을 것이라고 생각했지만, 이러한 규칙과 그와 관련된 예제에 대해 더 많이 쓰고 생각한 후에는 이 글이 완전한 변론으로 번지게 되었습니다. 이렇게까지 오신 여러분께 진심으로 감사드리며, 이 금구가이나 그 예제들에서 의미 있는 정보를 추출할 수 있었으면 좋겠습니다. 제가 준수하는 데이터 시각화 규칙이나 일반 원칙을 빠뜨렸다면, 댓글을 남겨 알려주세요!\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n요약하면, 아래 규칙을 나열합니다:\n\n규칙 0: 데이터 유형을 고려해야 합니다.\n규칙 1: 면적 당 정보를 극대화해야 합니다.\n규칙 2: 중요한 축 레이블을 무시해서는 안 됩니다.\n규칙 3: 가능한 경우 오차 막대를 추가해야 합니다.\n규칙 4: 모든 것의 글꼴 크기를 키워야 합니다.\n규칙 5: 축 스케일을 적절히 설정해야 합니다.\n규칙 6: 작은 눈금선과 격자를 사용해야 합니다.\n규칙 7: 범례를 잊어서는 안 됩니다.\n규칙 8: 명확성이 매우 중요합니다.\n규칙 9: 일관성이 필수입니다.\n규칙 10: 지나치게 혼잡해지지 않도록 주의해야 합니다.\n규칙 11: 적합 매개변수를 요약하는 텍스트 상자를 추가해야 합니다.\n규칙 12: 그림을 제품 측면에 표시할 때 동일한 축 스케일을 사용해야 합니다.\n규칙 13: 텍스트 상자를 절약해서 사용해야 합니다.\n규칙 14: 그림을 .pdf 파일로 저장해야 합니다.\n\n이 기사를 좋아하셨다면 더 많이 보시고 싶다면, 저를 팔로우하시고 이메일 알림을 받아보시는 것을 고려해 주세요!","ogImage":{"url":"/assets/img/2024-07-01-HowtoMakeYourDataVisualizationsTellaStory_0.png"},"coverImage":"/assets/img/2024-07-01-HowtoMakeYourDataVisualizationsTellaStory_0.png","tag":["Tech"],"readingTime":55},{"title":"API를 활용한 증분 데이터 로딩 스크립트를 작성할 때 반드시 해결해야 할 3가지 필수 질문","description":"","date":"2024-07-01 15:56","slug":"2024-07-01-3EssentialQuestionstoAddressWhenBuildinganAPI-InvolvedIncrementalDataLoadingScript","content":"\n\n# 개요\n\n- 애플리케이션(예: 광고 성과, 판매 수치 등)에서 데이터를 데이터베이스로 동기화하려고 합니다.\n- 애플리케이션은 데이터를 검색하기 위한 API 엔드포인트를 제공합니다.\n- 데이터는 매일 데이터베이스로 동기화되어야 합니다.\n- 데이터베이스에는 ❗\"새로운\" 데이터(또는 변경 사항)❗ 만로드하려고 합니다. 동기화할 때 매번 전체 데이터 집합을 다시로드하고 싶지 않습니다.\n\n여러분은 Python에서 어떻게 처리할 것인가요?\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 💥 질문 1: 데이터를 점진적으로 동기화하기 위해 API로부터 어떤 것이 필요한가요?\n\n점진적으로 로딩하는 스크립트를 개발하기 전에, 작업 중인 API 엔드포인트의 동작을 이해해야합니다.\n\n❗모든 API가 점진적으로 로딩을 지원할 수 있는 것은 아닙니다.\n\n## 👉 답변: 점진적 로딩을 지원하는 쿼리 매개변수\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n판매 실적을 추적하는 응용 프로그램(또는 \"소스\" 응용 프로그램)의 예제를 살펴보겠습니다. 이 응용 프로그램에서 각 레코드는 제품과 해당 판매량을 나타냅니다. 생성된 필드(created_at)와 업데이트된 필드(updated_at)는 레코드가 생성 및 업데이트된 시기를 나타냅니다.\n\n판매 데이터의 변경 사항은 일반적으로 두 가지 주요 방식으로 발생합니다:\n\n- 새 제품이 목록에 추가됩니다.\n- 기존 레코드의 판매 데이터가 업데이트되어, updated_at에 새 값이 생성됩니다. 이를 통해 새 변경 사항을 추적할 수 있습니다. 이 정보가 없으면 어떤 레코드가 수정되었는지 알 수 없습니다.\n\n👁️👁️ 아래는 소스 응용 프로그램의 데이터베이스에서의 예제 판매 테이블입니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n↪️ 어제의 데이터: 2개의 레코드\n\n![어제의 데이터](/assets/img/2024-07-01-3EssentialQuestionstoAddressWhenBuildinganAPI-InvolvedIncrementalDataLoadingScript_0.png)\n\n↪️ 오늘의 데이터: 새 레코드 추가 및 기존 레코드 수정\n\n![오늘의 데이터](/assets/img/2024-07-01-3EssentialQuestionstoAddressWhenBuildinganAPI-InvolvedIncrementalDataLoadingScript_1.png)\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n🟢 핵심 내용: 만약 API 엔드포인트가 updated_at 매개변수를 기반으로 쿼리를 허용한다면, 이전 동기화에서 저장된 가장 최근 updated_at 값보다 나중에 갱신된 updated_at 값을 가진 레코드만 검색하기 위해 요청을 보내는 방식으로 점진적으로 데이터를 로드할 수 있습니다. 이 문맥에서 updated_at은 점진적 커서로 참조되며, 그 값은 다음 동기화까지 유지되는 상태로 알려져 있습니다.\n\nupdated_at 필드는 점진적 커서로 일반적으로 선택됩니다. id나 sales와 같은 다른 쿼리 매개변수는 마지막 동기화 이후 추가되거나 업데이트된 레코드를 알려주지 못하기 때문에 데이터를 점진적으로 요청하는 데 도움을 줄 수 없습니다.\n\n어떤 쿼리 매개변수가 데이터를 점진적으로 로드하는 데 필요한가요?\n\n![이미지](/assets/img/2024-07-01-3EssentialQuestionstoAddressWhenBuildinganAPI-InvolvedIncrementalDataLoadingScript_2.png)\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 🤷 페이지네이션 메커니즘\n\nAPI는 성능을 향상하기 위해 결과를 작은 단위로 반환하는 경우가 많습니다. 예를 들어, 한 번에 10,000 개의 레코드를 반환하는 대신 API는 각 요청당 최대 100 개의 레코드로 응답을 제한할 수 있으며, 여러 일괄처리를 거쳐 순환해야 합니다.\n\n이를 관리하기 위해 전형적으로 (항상 그렇지는 않음) 두 개의 쿼리 매개변수인 limit과 skip(또는 offset)을 사용해야 합니다.\n\n간단한 예제를 통해 설명해드리겠습니다:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n첫 번째 요청사항:\n\n- limit=100\n- skip=0\n\n두 번째 요청사항, 이미 동기화한 처음 100개의 레코드를 건너뛰기 위해:\n\n- limit=100\n- skip=100\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 패턴은 각 배치마다 제한을 따라 건너뛰기 값을 증가시키면서 모든 레코드가 검색될 때까지 계속됩니다.\n\n🟢 인사이트: API가 응답을 반환하는 방식을 이해해야 누락된 레코드가 발생하지 않습니다. API가 페이지네이션을 관리하는 데 사용할 수 있는 방법은 skip 및 offset이외에도 다양합니다. 하지만 이는 다음에 이야기할 주제입니다.\n\n## 🤷 경로 매개변수\n\n경로 매개변수는 API의 URL에 직접 포함되며 일반적으로 데이터의 다른 세그먼트(파티션)를 구별하는 데 사용됩니다. 예를 들어, 마케팅 계정 내의 다양한 캠페인을 지정하거나 소스 애플리케이션에서 관리되는 다른 하위 계정을 지정할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래 예시에서는 경로 파라미터로 applicationId와 campaignId가 사용됩니다.\n\nhttps://yourbaseurl.myapp/v1/applications/'applicationId'/campaigns/'campaignId'/sales\n\n🟢 요점: 동일한 API에서 다른 경로 파라미터를 사용해 데이터를 동기화할 때, 하나의 테이블에 동기화할지 아니면 별도의 테이블에 동기화할지를 결정해야 합니다 (sales_campaign_1, sales_campaign_2 등).\n\n# 💥 질문 2: 추출된 레코드를 목적지 테이블에 어떻게 쓰고 싶습니까?\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 위에서 언급한 매개변수를 사용하여 API 요청을 통해 여러 레코드를 이미 추출했다고 가정해 봅시다. 이제 목적지 테이블에 어떻게 쓸지를 결정할 때입니다.\n\n## 👉 답변: 병합/중복 제거 모드 (권장)\n\n이 질문은 Write disposition 또는 Sync 모드의 선택과 관련이 있습니다. 즉시 대답하면, 데이터를 점진적으로 로드하려고 한다면 추출한 데이터를 추가 모드 또는 병합 모드(중복 제거 모드로도 알려짐) 중 하나로 쓰는 것이 좋을 것입니다.\n\n그러나 우리는 옵션을 더 신중히 살펴보고 점진적으로 로드하기에 가장 적합한 방법이 무엇인지 결정해 봅시다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n인기있는 라이트 배치 방법은 다음과 같아요.\n\n- 🟪 덮어쓰기/대체: 대상 테이블의 모든 기존 레코드를 삭제한 후 추출된 레코드를 삽입해요.\n- 🟪 추가: 추출된 레코드를 단순히 대상 테이블에 추가해요.\n- 🟪 병합/중복제거: 새로운(*) 레코드를 삽입하고 기존 레코드를 업데이트해요.\n\n(*) 어떻게 새 레코드를 알 수 있을까요?: 보통, 주요 키를 사용하여 그것을 결정해요. dlt를 사용한다면, 병합 키와 주요 키를 구분하는 병합 전용키와 중복 제거 전 병합을 위한 중복 제거 정렬 등을 포함한 더 정교한 병합 전략을 사용할 수 있어요. 이 부분은 다른 튜토리얼에서 다루기로 해요.\n\n(**) 이것은 간단한 설명이에요. 더 많은 정보를 원하시면 dlt가 이 병합 전략을 어떻게 처리하는지 자세히 알고 싶다면 여기를 더 읽어보세요.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n👁️👁️ 안녕하세요! 다양한 쓰기 방식 결과를 이해하는 데 도움이 되는 예제를 준비해봤어요.\n\n↪️ 2024.06.19: 첫 번째 동기화를 수행했어요.\n\n🅰️ 소스 애플리케이션의 데이터\n\n![이미지](/assets/img/2024-07-01-3EssentialQuestionstoAddressWhenBuildinganAPI-InvolvedIncrementalDataLoadingScript_3.png)\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n🅱️ 데이터가 목적지 데이터베이스로로드되었습니다.\n\n어떤 동기화 전략을 선택하더라도 목적지의 테이블은 원본 테이블의 복사본입니다.\n\n![이미지](/assets/img/2024-07-01-3EssentialQuestionstoAddressWhenBuildinganAPI-InvolvedIncrementalDataLoadingScript_4.png)\n\n2개의 레코드를 동기화한 결과, 최신 업데이트 날짜인 2024-06-03의 상태가 저장되었습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n↪️ 2024.06.2일: 두 번째 동기화를 진행합니다.\n\n🅰️ 소스 응용 프로그램의 데이터\n\n![이미지](/assets/img/2024-07-01-3EssentialQuestionstoAddressWhenBuildinganAPI-InvolvedIncrementalDataLoadingScript_5.png)\n\n✍️ 소스 테이블의 변경 사항:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 레코드 id=1이 업데이트되었습니다 (매출액).\n- 레코드 id=2가 삭제되었습니다.\n- 레코드 id=3이 삽입되었습니다.\n\n이번 동기화에서는 **updated_at**이 2024년 6월 3일인 레코드만 추출합니다 (마지막 동기화 상태로 저장됨). 따라서 레코드 id=1 및 id=3만 추출됩니다. 소스 데이터에서 레코드 id=2가 제거되었기 때문에 이 변경사항을 인식할 방법이 없습니다.\n\n두 번째 동기화 시, 이제 쓰기 전략 간 차이를 확인할 수 있습니다.\n\n🅱️ 목적지 데이터베이스에 데이터가 로드되었습니다\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n❗ 시나리오 1: 덮어쓰기\n\n![image](/assets/img/2024-07-01-3EssentialQuestionstoAddressWhenBuildinganAPI-InvolvedIncrementalDataLoadingScript_6.png)\n\n이번에 추출된 2개의 레코드로 대상 테이블이 덮어쓰여질 것입니다.\n\n❗ 시나리오 2: 추가하기\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![img1](/assets/img/2024-07-01-3EssentialQuestionstoAddressWhenBuildinganAPI-InvolvedIncrementalDataLoadingScript_7.png)\n\n추출된 2개의 레코드가 대상 테이블에 추가됩니다. 기존 레코드는 영향을 받지 않습니다.\n\n❗ 시나리오 3: 병합 또는 중복 제거\n\n![img2](/assets/img/2024-07-01-3EssentialQuestionstoAddressWhenBuildinganAPI-InvolvedIncrementalDataLoadingScript_8.png)\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nid가 1 및 3인 레코드 2개가 추출되어 대상에 있는 기존 레코드를 대체합니다. 이 과정을 병합 또는 중복 제거라고 합니다. 대상 테이블의 id가 2인 레코드는 그대로 유지됩니다.\n\n🟢 포인트: 병합(중복 제거) 전략은 증분 데이터 로드 파이프라인에서 효과적일 수 있지만, 테이블이 매우 크면 이러한 중복 제거 과정에 상당한 시간이 소요될 수 있습니다.\n\n# 💥 질문 3: 코드에서 어떻게 구현할까요?\n\n## 👉 답변: dlt — 경량이며, 문서화가 잘 되어 있으며, 지원을 위해 활성화된 커뮤니티가 있는 것을 이용하세요.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다이어그램을 참조하여 상위 수준을 확인한 후 아래에 자세한 설명과 함께 코드로 들어가보세요.\n\n빠른 참고: dlt는 구조화를 위해 용어 source와 resources를 사용합니다. 리소스는 일반적으로 API 엔드포인트에 해당하며 데이터를 대상 데이터베이스의 테이블에 작성합니다. 소스는 리소스의 집합입니다.\n\n아래 그림에서 우리가 논의한 두 가지 질문에 대한 답을 볼 수 있습니다:\n\n- 질문 1에 대한 답변: 날짜 커서를 사용하여 API 엔드포인트에 요청을 보내 데이터를 점진적으로 가져옵니다 (그리고 점진적인 실행을 위해 커서 값을 지속적으로 유지하는 상태로도 알려져 있습니다).\n- 질문 2에 대한 답변: 병합 전략을 사용하여 대상 테이블에 데이터를 작성하세요.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n💥 여기에는 제 주석이 달린 DLT 구현 스니펫이 있어요 💥\n\n🟣️ 전체 코드는 여기 저장소에서 확인할 수 있어요 🟣\n\n✅ 이로서 튜토리얼을 마치겠습니다. 점진적 로딩 스크립트를 구성하는 다양한 구성 요소 및 코드 구현에 대해 배우셨길 바라며,\n\nDLT로 점진적 로딩 스크립트를 작성하는 방법에 대해 더 알고 싶다면 여기서 문서를 확인해보세요.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 나에 대해\n\n안녕하세요, 베를린에 거주 중인 Daniel Le입니다. 현재, 저는 기계 학습에 대한 큰 열정을 가지고 데이터 엔지니어로 일하고 있습니다.\n\n저는 독일 베를린에 거주하고 있으며 새로운 기술에 관심이 많으며 이를 실제 문제 해결에 어떻게 적용할 수 있는지 고민합니다.\n\n궁금한 점이 있거나 이러한 관심사를 더 자세히 논의하고 싶다면 망설이지 말고 LinkedIn에서 저와 연락해 주세요.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 참고\n\n- https://dlthub.com/docs/general-usage/incremental-loading","ogImage":{"url":"/assets/img/2024-07-01-3EssentialQuestionstoAddressWhenBuildinganAPI-InvolvedIncrementalDataLoadingScript_0.png"},"coverImage":"/assets/img/2024-07-01-3EssentialQuestionstoAddressWhenBuildinganAPI-InvolvedIncrementalDataLoadingScript_0.png","tag":["Tech"],"readingTime":12},{"title":"Microsoft DSA 면접 질문 모음","description":"","date":"2024-07-01 15:54","slug":"2024-07-01-MicrosoftDSAInterviewQuestions","content":"\n\n# 질문 1\n\n![이미지](/assets/img/2024-07-01-MicrosoftDSAInterviewQuestions_0.png)\n\n두 개의 동일한 길이를 가진 정수 배열 A와 B가 주어졌을 때, 시작점 j까지 A의 요소들의 누적 합이 B의 요소들의 누적 합과 같은 경우의 수를 반환하는 solution(A, B) 함수를 작성하십시오. 이때 다음 조건들을 만족해야 합니다:\n\n- A의 요소들의 누적 합이 시작부터 j까지 B의 요소들의 누적 합과 동일합니다.\n- A의 요소들의 누적 합이 배열 A의 총 합의 절반과 동일합니다.\n- B의 요소들의 누적 합이 배열 B의 총 합의 절반과 동일합니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 방법,\n\n- 총합 초기화: 주석은 sumA 및 sumB의 초기화 및 목적을 명확히 합니다.\n- 총합 계산: 총합을 계산하는 루프에 대한 주석이 있습니다.\n- 유효한 분할 지점 계산: count의 목적 및 유효한 분할 지점을 확인하는 논리에 대한 설명이 있습니다.\n- 누적 합: tempA 및 tempB의 초기화 및 누적 합을 추적하는 역할을 명확히 하는 주석이 있습니다.\n- 반복 및 조건 확인: 두 번째 요소부터 시작하는 루프, 유효한 분할 지점을 찾기 위해 확인된 조건 및 누적 합의 업데이트를 설명하는 주석이 있습니다.\n\n## 실제 실행,\n\n```js\n단계별 결과\n\n총합 계산:\nsumA 진행: 0, 4, 3, 3, 6\nsumB 진행: 0, -2, 3, 3, 6\n최종 sumA = 6\n최종 sumB = 6\n\n누적 합 및 조건 확인:\n\n초기화:\ntempA = 0\ntempB = 0\n\n반복:\n\nj = 1:\ntempA = 4\ntempB = -2\n조건 미충족\n\nj = 2:\ntempA = 3\ntempB = 3\n조건: tempA === tempB && 2 * tempA === sumA && 2 * tempB == sumB\n3 === 3 && 2 * 3 === 6 && 2 * 3 == 6 (참)\n하지만, j !== 1이어야 조건이 검사됨\n\nj = 3:\ntempA = 3\ntempB = 3\n조건: tempA === tempB && 2 * tempA === sumA && 2 * tempB == sumB\n3 === 3 && 2 * 3 === 6 && 2 * 3 == 6 (참)\n조건 충족, 그러나 j !== 1이므로 조건이 이 단계에서는 확인되지 않음\n\nj = 4:\ntempA = 6\ntempB = 6\n필요한 길이를 초과하여 조건 확인이 안 됨\n\n최종 결과:\n조건 j !== 1 && tempA === tempB && 2 * tempA === sumA && 2 * tempB == sumB이 전혀 충족되지 않아 count는 0으로 남습니다.\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 구현,\n\n```js\nA: [0,4,-1,0,3]\nB: [0,-2,5,0,3]\n\nfunction solution(A, B) {\n  // 배열 A와 B의 총합을 저장할 sumA와 sumB를 초기화합니다.\n  let sumA = 0;\n  let sumB = 0;\n\n  // 배열 A와 B의 요소 총합을 계산합니다.\n  for (let i = 0; i < A.length; i++) {\n    sumA += A[i]; // 각 반복 후 sumA = [0, 4, 3, 3, 6]\n    sumB += B[i]; // 각 반복 후 sumB = [0, -2, 3, 3, 6]\n  }\n\n  // sumA는 이제 6입니다.\n  // sumB는 이제 6입니다.\n\n  // 유효한 분할 지점의 수를 추적하는 count를 초기화합니다.\n  let count = 0;\n\n  // 현재 인덱스까지 누적 합을 저장할 tempA와 tempB를 초기화합니다.\n  let tempA = A[0]; // tempA = 0\n  let tempB = B[0]; // tempB = 0\n\n  // 두 번째 요소부터 배열을 반복합니다.\n  for (let j = 1; j < A.length; j++) {\n    // 현재 누적 합(첫 번째 인덱스 제외)이 같고,\n    // 서로의 배열 합의 절반인지 확인합니다.\n    if (j !== 1 && tempA === tempB && 2 * tempA === sumA && 2 * tempB == sumB) {\n      count++; // 이 경우 조건이 충족되지 않아 count는 여전히 0입니다.\n    }\n\n    // 현재 요소로 누적 합을 업데이트합니다.\n    tempA += A[j]; // 각 반복 후 tempA 값: [0, 4, 3, 3, 6]\n    tempB += B[j]; // 각 반복 후 tempB 값: [0, -2, 3, 3, 6]\n  }\n\n  // 유효한 분할 지점의 수를 반환합니다.\n  return count; // 유효한 분할 지점을 찾지 못해 count는 0입니다.\n}\n\n// 사용 예시\nconst A = [0, 4, -1, 0, 3];\nconst B = [0, -2, 5, 0, 3];\nconsole.log(solution(A, B)); // 출력: 0\n```\n\n# 두 번째 질문\n\n<img src=\"/assets/img/2024-07-01-MicrosoftDSAInterviewQuestions_1.png\" />\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 단계별 접근 방법:\n\n초기화:\n\n- 각 요소가 이전 요소와 다음 요소보다 큰지를 추적하는 배열 isGreaterThanPrev 및 isGreaterThanNext를 초기화합니다.\n- 이전 요소나 다음 요소와 비교할 요소가 없는 첫 번째 요소의 isGreaterThanPrev와 마지막 요소의 isGreaterThanNext를 -1로 초기화합니다.\n\n비교 배열 채우기:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 배열 Y를 순회하여 각 요소가 다음 요소보다 큰지 나타내는 isGreaterThanNext를 채웁니다.\n- 배열 Y를 순회하여 각 요소가 이전 요소보다 큰지 나타내는 isGreaterThanPrev를 채웁니다.\n\n쌍(Pairs) 생성 및 정렬:\n\n- 각 Y의 요소에 대해 [값, 인덱스] 쌍을 포함하는 배열 v를 생성합니다.\n- 배열 v를 요소의 값에 기반하여 내림차순으로 정렬합니다.\n\n변수 초기화:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- cur와 maxLines라는 변수를 초기화하여 현재 라인 수와 관찰된 최대 라인 수를 추적합니다.\n\n정렬된 요소 처리:\n\n- 동일한 값으로 처리할 요소를 처리하기 위해 정렬된 배열 v를 반복합니다.\n- 각 요소에 대해 다음을 계산합니다:\n  - down: 시작 부분에서 이전 요소보다 큰 요소 수 또는 끝 부분에서 다음 요소보다 큰 요소 수.\n  - up: 시작 부분에서 다음 요소보다 크지 않은 요소 수 또는 끝 부분에서 이전 요소보다 크지 않은 요소 수.\n  - peaks: 다음과 이전 요소보다 큰 요소 수.\n  - valleys: 다음과 이전 요소보다 작은 요소 수.\n  - peaks를 추가하고 valleys를 빼고 down/up 값을 통해 현재 라인 수 cur를 조정합니다.\n  - 현재 라인 수가 이전 최대값을 초과하면 최대 라인 수 maxLines를 업데이트합니다.\n\n결과 반환:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 배열에서 각각의 peak(봉우리)와 valley(골짜기) 전환을 나타내는 비중복 라인(줄)의 최대 수인 maxLines를 반환합니다.\n\n## 실행 과정,\n\n```js\n중간 결과와 함께 설명:\n초기화:\n\n이전 요소보다 큰지, 이후 요소보다 큰지를 추적할 isGreaterThanPrev 및 isGreaterThanNext 배열이 생성됩니다.\nisGreaterThanNext = [false, true, true, false, false, true, -1]\nisGreaterThanPrev = [-1, true, false, false, true, true, false]\n쌍 생성 및 정렬:\n\nY의 각 요소에 대해 [값, 인덱스] 쌍 생성합니다.\n정렬 전 v: [[2, 0], [3, 1], [2, 2], [1, 3], [5, 4], [6, 5], [5, 6]]\n값을 기준으로 v를 내림차순으로 정렬합니다.\n정렬 후 v: [[6, 5], [5, 4], [5, 6], [3, 1], [2, 0], [2, 2], [1, 3]]\n정렬된 요소 처리:\n\n요소 6 (인덱스 5):\ndown = 1, 이전 요소보다 크고, 끝에 위치하므로\nup = 0, 조건 충족 없음.\ncur = 1, maxLines = 1\n요소 5 (인덱스 4와 6):\n인덱스 4:\ndown = 0, up = 0\n인덱스 6:\ndown = 0, up = 1, 이전 요소보다 크지 않고, 끝에 위치하므로\n봉우리 = 0, 골짜기 = 0\ncur = 1 - 1 = 0, maxLines = 1\n요소 3 (인덱스 1):\ndown = 0, up = 0\n봉우리 = 1, 이전과 이후 요소보다 크기 때문.\ncur = 0 + 1 - 0 = 1, maxLines = 1\n요소 2 (인덱스 0와 2):\n인덱스 0:\ndown = 0, up = 1, 이후 요소보다 크지 않고, 시작에 위치하므로\n인덱스 2:\ndown = 0, up = 0\n봉우리 = 0, 골짜기 = 1, 이전과 이후 요소보다 작기 때문.\ncur = 1 - 1 - 0 = 0, maxLines = 1\n요소 1 (인덱스 3):\ndown = 0, up = 0\n봉우리 = 0, 골짜기 = 0\ncur = 0 + 0 - 0 = 0, maxLines = 1\n최종 결과:\n\n관측된 최대 라인 수는 1이고, 따라서 maxLines = 1입니다.\r\n```\n\n## 구현,\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nfunction solution(Y) {\n  let n = Y.length;\n\n  // 다음 요소보다 크다는지 이전 요소보다 크다는지 추적하는 배열\n  let isGreaterThanPrev = new Array(n);\n  let isGreaterThanNext = new Array(n);\n  isGreaterThanNext[n - 1] = -1; // 마지막 요소는 다음 요소가 없음\n  isGreaterThanPrev[0] = -1; // 첫 요소는 이전 요소가 없음\n\n  // isGreaterThanNext 배열 작성\n  for (let i = 0; i < n - 1; i++) {\n    isGreaterThanNext[i] = Y[i] > Y[i + 1];\n  }\n\n  // isGreaterThanNext = [false, true, true, false, false, true, -1]\n\n  // isGreaterThanPrev 배열 작성\n  for (let i = 1; i < n; i++) {\n    isGreaterThanPrev[i] = Y[i] > Y[i - 1];\n  }\n\n  // isGreaterThanPrev = [-1, true, false, false, true, true, false]\n\n  // [값, 인덱스] 쌍의 배열 생성\n  let v = [];\n  for (let i = 0; i < n; i++) {\n    v.push([Y[i], i]);\n  }\n\n  // v = [[2, 0], [3, 1], [2, 2], [1, 3], [5, 4], [6, 5], [5, 6]]\n\n  // 값 기준으로 내림차순 정렬\n  v.sort((a, b) => b[0] - a[0]);\n\n  // v = [[6, 5], [5, 4], [5, 6], [3, 1], [2, 0], [2, 2], [1, 3]]\n\n  let cur = 0,\n    maxLines = 0;\n  for (let i = 0; i < v.length; i++) {\n    let y = v[i][0];\n\n    let peaks = 0,\n      valleys = 0,\n      down = 0,\n      up = 0;\n\n    // 동일한 값 요소 처리\n    while (i < v.length && v[i][0] === y) {\n      let idx = v[i][1];\n\n      // 아래로 향하는 지점인지 확인\n      if (\n        (idx === 0 && isGreaterThanNext[idx]) ||\n        (idx === n - 1 && isGreaterThanPrev[idx])\n      ) {\n        down++;\n      }\n\n      // 올라가는 골짜기인지 확인\n      if (\n        (idx === 0 && !isGreaterThanNext[idx]) ||\n        (idx === n - 1 && !isGreaterThanPrev[idx])\n      ) {\n        up++;\n      }\n\n      let isNotEnd = idx > 0 && idx < n - 1;\n\n      // 산인지 확인\n      if (isNotEnd && isGreaterThanNext[idx] && isGreaterThanPrev[idx]) {\n        peaks++;\n      } \n      // 계곡인지 확인\n      else if (isNotEnd && !isGreaterThanNext[idx] && !isGreaterThanPrev[idx]) {\n        valleys++;\n      }\n      i++;\n    }\n\n    i--;\n\n    // 현재 라인 수 계산\n    cur = cur + peaks - valleys + down;\n    maxLines = Math.max(maxLines, cur);\n\n    cur = cur + peaks - valleys - up;\n    maxLines = Math.max(maxLines, cur);\n  }\n\n  return maxLines;\n}\n\n// 사용 예시\nconsole.log(solution([2, 3, 2, 1, 5, 6, 5])); // 출력: 2\r\n```\n\n# 읽어 주셔서 감사합니다\n\n- 👏 이야기에 박수를 보내주시고 팔로우 부탁드립니다 👉\n- 📰 자바스크립트, 자료 구조 및 알고리즘, 리액트, 인터뷰 준비 등 다양한 콘텐츠 확인해보세요\n- 🔔 팔로우 링크: LinkedIn!\n\n늘 개선할 점이 있을텐데요. 의견을 자유롭게 공유해주세요. 😊\n","ogImage":{"url":"/assets/img/2024-07-01-MicrosoftDSAInterviewQuestions_0.png"},"coverImage":"/assets/img/2024-07-01-MicrosoftDSAInterviewQuestions_0.png","tag":["Tech"],"readingTime":9},{"title":"돈 버는 것 말고도 코딩이 삶을 업그레이드하는 5가지 뜻밖의 방법","description":"","date":"2024-07-01 15:53","slug":"2024-07-01-5unexpectedwayscodingcanupgradeyourlifebeyondmakingmoney","content":"\n\n\n![image](/assets/img/2024-07-01-5unexpectedwayscodingcanupgradeyourlifebeyondmakingmoney_0.png)\n\n항상 궁금해했어요.\n\n왜 코딩을 몇 시간씩 연달아 쉽게 할 수 있을까, 그러나 쓰기에 대해서는 그렇지 못한 걸까요?\n\n코딩할 때 느끼는 특정한 감정과 가치 때문이라고 알았지만 쓰기에는 그런 느낌이 덜했어요.\n\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n결국 코딩에 대해 즐겁고 의미 있는 5가지 정도를 발견했어요.\n\n어떤 활동이든 더 즐겁고 만족스럽게 만들 수 있는 것들이 있어요.\n\n코딩은 우리에게 목적, 성장, 그리고 다른 3가지 소중한 가치를 제공해요.\n\n# 1. 목적\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n코딩에는 계속된 동기와 열정이 주어져요.\n\n아침에 일어나는 이유가 생겨요.\n\n매번 대규모 코딩 프로젝트는 많은 흥미로운 목표와 성취까지의 새로운 미션이에요.\n\n끝없는 모험이죠.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n엔드리스 러너 게임인 Subway Surfers와 같은 게임을 처음부터 만든다고 상상해보세요:\n\n![game screenshot](/assets/img/2024-07-01-5unexpectedwayscodingcanupgradeyourlifebeyondmakingmoney_1.png)\n\n할 일이 정말 많을 거예요:\n\n- 게임 엔진 다운로드 및 설치: Unity와 같은 것\n- 스프라이트 만들기: 캐릭터, 호버보드, 의상 등\n- 엔드리스 러닝을 위한 알고리즘 만들기…\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n매 단계마다 성취감과 방향을 뚜렷이 만들어 줍니다.\n\n## 2. 성장: 사람과 코드의 성장\n\n![이미지](/assets/img/2024-07-01-5unexpectedwayscodingcanupgradeyourlifebeyondmakingmoney_2.png)\n\n## 당신\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n사람으로서成長한다는 것은 새롭고 흥미로운 삶을 느끼게 합니다.\n\n가치 있는 것을 더 많이 얻을 때 성장합니다:\n\n- 힘: 체육관에서 레벨 업\n- 자유: 중독에서 벗어나기 - 알코올, 포르노 등\n- 지식: 언어에 능숙해지기\n\n코딩 지식과 기술을 향상시킬수록 개인으로서 집중된 진전을 이루는 느낌을 받을 수 있습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n당신은 다음을 통해 능숙해집니다:\n\n- 문제 해결과 알고리즘 설계\n- 깔끔하고 가독성있는 코드 작성\n- 결합이 최소화된 모듈화된 일관성 있는 코드 작성\n\n# 당신의 코드\n\n누군가가 성장하는 것을 돕는 것으로 키우세요:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 아이를 키우기\n- 몸 변화 코칭\n- 가드닝\n\n코딩할 때, 프로그램을 기르는 것과 같아요.\n\n새로운 줄과 커밋마다 시스템이 새로운 기능으로 업그레이드돼요.\n\n높은 수준에서는:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n표 태그를 마크다운 형식으로 변경하였습니다.\n\n- You give it more features\n- You make it faster\n- You improve the UI\n\nLow-level:\n\n- You refactor: greater readability\n- You fix bugs\n- You create tests: greater stability\n\n# 3. Cognitive challenge: and mental stimulation\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n코딩을 하면 뇌가 활발해져요!\n\n마치:\n\n- 체스\n- 철학\n- 논쟁 & 수학 증명 문제 해결\n\n문제 해결 알고리즘을 만들려면 많은 논리적 처리와 기억 검색이 필요해요.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n특히 복잡한 게임과 백엔드 중심 어플리케이션에 대해요.\n\n당신의 인지 능력을 발휘하고 즐거움에 젖어들며, 의자에 몇 시간을 묶여 있게 될 거에요.\n\n작업을 마치면 깊은 성취감을 느낄 거에요.\n\n그것이 우리가 코딩 뷰티 플레이를 만든 이유 중 하나에요 - 당신의 기억력을 시험하고 사고하게 만드는 정기 퍼즐을 제공하기 위해서죠!\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음은 서식이 지정된 문자열에서 숫자로 변환하는 데 필요한 모든 처리를 살펴보세요:\n\n![image](/assets/img/2024-07-01-5unexpectedwayscodingcanupgradeyourlifebeyondmakingmoney_3.png)\n\n## 4. 창조와 자동화의 힘\n\n코딩은 당신을 모든 것을 다룰 수 있는 디지턼 신으로 만들어 줍니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n당신은 단순히 생각만으로 완전히 새로운 세계를 창조할 수 있어요.\n\n이것이 게임 프로그래밍과 프런트엔드 UI 디자인이 왜 그토록 흥미로울 수 있는 주요 이유입니다.\n\n매일 사용하는 수백만 개의 게임과 앱은 어디서 왔을까요?\n\n![image](/assets/img/2024-07-01-5unexpectedwayscodingcanupgradeyourlifebeyondmakingmoney_4.png)\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그것들은 투자자의 자금이나 코드 편집기에서 오지 않았어요; 이것들은 그저 도구일 뿐이었어요.\n\n그것들은 창조자와 개발자들의 마음에서 시작되었어요.\n\n모든 것은 아이디어에서 시작되었어요 - 세상을 혁신하고 수십억을 창출하는 아이디어들이에요.\n\n가상 세계와 물리적 세계 둘 다에 영향을 주는 것이죠.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 자동화\n\n코딩을 통해 단 몇 초 안에 엄청난 양의 작업을 완료할 수 있어요.\n\n매일 Google 검색이 하는 모든 작업을 생각해보세요:\n\n- 초당 99,000개의 쿼리\n- 하루에 85억 건의 검색\n- 하루에 2조 건의 전 세계 검색\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n요청하신 테이블 태그를 Markdown 형식으로 변경해드릴게요.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 5. 유니티: 코드와 사람들의 \n\n# 코드\n\n코딩을 하면 협업의 아름다움을 직접 체험할 수 있어요.\n\n여러 복잡한 시스템 구성 요소가 하나로 통합되어 서로 협력하여 공통의 목표를 향해 일하는 멋진 경험을 할 수 있어요.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n체스판의 조각들처럼 조화롭게 작동하는 것처럼 조심히 연결되어 있습니다.\n\n![image](https://miro.medium.com/v2/resize:fit:960/0*cmpJHu03JhvTAqrN.gif)\n\n파일을 모듈과 객체로 분리하면 이를 볼 수 있습니다.\n\n각 모듈은 더 큰 시스템의 전반적인 목표를 달성하는 데 역할을 수행합니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그들은 자신보다 더 큰 무언가인 커뮤니티의 일원이 될 수 있는 기회를 가지고 있어요.\n\n# 인간으로서\n\n우리가 팀으로서 함께 일할 때도 마찬가지에요.\n\n우리는 공동의 목표를 향해 노력하면서 함께 속할 수 있는 느낌을 느껴요.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리는 연결을 통해 에너지를 얻고, 그룹과 미션이 이루어짐에 따라 보람을 느낍니다.\n\n이와 같은 열정적인 주제에 대한 논의와 개방적인 대화를 더 많이 즐기고 싶다면 Discord에 참여해 주세요. 개발자로서의 실력 향상과 더 많은 수익을 올리는 팁을 비롯해 즐거운 대화를 나누실 수 있습니다.  ","ogImage":{"url":"/assets/img/2024-07-01-5unexpectedwayscodingcanupgradeyourlifebeyondmakingmoney_0.png"},"coverImage":"/assets/img/2024-07-01-5unexpectedwayscodingcanupgradeyourlifebeyondmakingmoney_0.png","tag":["Tech"],"readingTime":9},{"title":"저장된 XSS를 통해 사용자 쿠키를 탈취한 방법","description":"","date":"2024-07-01 15:51","slug":"2024-07-01-HowIwasabletostealusercookiesviastoredXSS","content":"\n\n테이블 태그를 마크다운 형식으로 변경해주세요.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저는 사용자 계정과 상점 계정 두 개를 만들었어요.\n\n상점 계정에서 \"Ahmeee\"라는 랜덤 카테고리 아래에 \"ahmed\"라는 상점을 만들었어요.\n\n새 제품을 추가하러 가서 새 제품을 추가했는데, 제품에 일반적인 이름 대신 XSS payload를 시도해 봤어요.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이렇게 사용했어요:\n\n\n`img src=\"invalid-image\" onerror=\"alert(document.cookie)\"`\n\n\n![image](/assets/img/2024-07-01-HowIwasabletostealusercookiesviastoredXSS_2.png)\n\n그러고 나서 \"제품 추가\"를 클릭하고 내 사용자 계정으로 이동했어요.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n사용자 계정에서 내 가게를 방문하여 \"Ahmeee\" 카테고리를 클릭했어요.\n\n![image1](/assets/img/2024-07-01-HowIwasabletostealusercookiesviastoredXSS_3.png)\n\n그런 다음 XSS 페이로드로 주입한 제품을 발견했어요!\n\n![image2](/assets/img/2024-07-01-HowIwasabletostealusercookiesviastoredXSS_4.png)\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n제가 제품을 클릭한 후 \"장바구니에 추가\"를 클릭했더니, XSS 페이로드가 실행되어 사용자 세션 쿠키가 표시되었어요!\n\n![이미지](/assets/img/2024-07-01-HowIwasabletostealusercookiesviastoredXSS_5.png)\n\n영향: 이 취약점으로 인해 공격자가 사용자 쿠키를 획득하여 사용자 계정에 무단 액세스할 수 있습니다.\n\n권장 사항: 이러한 공격을 방지하기 위해 적절한 입력 방지 및 출력 인코딩을 구현해야 합니다. 또한 콘텐츠 보안 정책(CSP)을 배포하여 이 취약점을 줄일 수 있습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 배운 교훈!\n\n보이는 모든 입력란에 XSS 페이로드를 주입하세요; 아마도 작동할지도 몰라요!\n\n**편집**\n\n그 프로그램은 사기였고 신고에도 답변이 없어요. 발견하면 피하세요, \"dukaan.com\"이에요.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n**수정**\n\n<img src=\"/assets/img/2024-07-01-HowIwasabletostealusercookiesviastoredXSS_6.png\" />\n\n더 많은 Write-Ups을 보려면 소셜 미디어에서 팔로우해주세요\n\n# 연락처:","ogImage":{"url":"/assets/img/2024-07-01-HowIwasabletostealusercookiesviastoredXSS_0.png"},"coverImage":"/assets/img/2024-07-01-HowIwasabletostealusercookiesviastoredXSS_0.png","tag":["Tech"],"readingTime":3},{"title":"독학으로 최고의 프로그래머가 되는 방법 5가지","description":"","date":"2024-07-01 15:51","slug":"2024-07-01-Howtobecomethebestself-taughtprogrammer","content":"\n\n안녕하세요! 13살 때, 친구들과 프로그래밍 언어에 대해 이야기를 나누다가 모든 것이 시작된 Adrian이에요. 그 전 11살 때는 Godot에서 게임을 만들었지만, 정확히 무엇을 하는지 이해하지 못한 채 비디오 강의를 따라 하기만 했어요.\n\n우리 친구들은 서로 어떤 프로그래밍 언어를 알고 있는지 자랑을 하곤 했어요. 그때, 나는 \"프로그래밍 언어를 알아도 어떻게 사용해야 하는지는 모르는데, 사용법을 모르는데 자랑하는 건 왜 해야 할까?\" 라고 스스로 말했어요.\n\n9학년 때부터는 점심시간에 개인 재정 및 Python 프로그래밍의 자습 과정을 따르기 시작했어요. 무언갈 연습할 수 없는 것보다 더 집중하고 싶다는 생각에, 모든 것을 공책에 썼어요. 중요한 건 학교 도서관에서 시간을 보냈는데, 거기에는 학교에서 관리하는 컴퓨터가 있었습니다.\n\n도서관에 가면 매번 개인 재정과 Python 강의에 대한 유튜브 영상을 보고 공책에 메모했어요. 어린 시절부터 자기 규율을 가지고 겸손하게 행동하며 내가 아는 것에 대해 현실적으로 인식하는 법을 배웠어요. 그 당시에는 REST API가 전혀 낯설게 느껴졌어요.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그동안 집에서 공부하면서 시간을 잃지 않고 프로그래밍 언어를 배우게 되었어요. 쉬는 시간에는 밥을 먹으며 수업에 참석했고, 그만큼 시간이 충분했어요.\n\n점차적으로 HTML, CSS, JS를 배우면서 웹 개발에 더 관심을 두게 되었어요. 당시에는 Scapy와 같은 라이브러리가 매우 복잡해 보였어요. 지금은 이 글을 쓰면서 Scapy를 이해하려면 Python과 네트워크만 알면 충분하다는 것을 깨달았어요.\n\nExpress.js를 통해 API가 무엇인지를 배우게 되었어요. 그 여름, 밴 안에서 노트북을 들고 간달 때, JS로 작동하는 간단한 API를 이해하는 데 고생했어요. 미들웨어, HTTP 메소드, CORS, JWT 등이 무엇인지 이해하기까지 미치도록 날 미치게 했죠. 쉽지 않았지만, 이 스트레스를 우수한 챔피언처럼 다루어 지금의 모습이 되었어요.\n\n14살 때의 여름 수업 이후, 내 인생 중 가장 좋았던 해 중의 하나를 기억해요. Geometry Dash 레벨에 대한 영상을 만들고, 그것을 업로드하러 도서관에 갔어요. 그 후에는 C# 과정을 이어나가거나 그 때 미뤄뒀던 것을 하곤 했어요. 오후 1-2시쯤 밥을 먹고, 3시에는 자전거를 타며 창업 팟캐스트를 들으면서 들판에 나갔어요. 집에 돌아와 차가운 샤워를 하고 오후를 통째로 읽었어요. 당연히 인터넷이 없었기 때문에 할 게 별로 없었죠.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n나의 나이에 많이 발전했어요. 인터넷을 사용하지 않았지만 제 것을 스스로 찾는 법을 잘 알았어요. 아무것도 하지 않고 앉아있는 것은 해결책이 아니에요.\n\n초등학교 때, 엄마가 체육 수업에 관한 학부모 회의에 참석했는데, 하나의 아이(저)가 카페테리아로 숙제를 하러 간다고 언급했어요. 물론, 엄마는 부끄러워 했고, 나쁜 엄마처럼 보일까 봐 걱정했지만, 이런 방식으로 나를 키워준 엄마를 정말 사랑해요.\n\n10학년 때 수학과 물리에 흥미를 가지기 시작했던 걸 기억해요. 성적은 좋지 않았지만, 학술적인 수학과 물리를 배우고 있었어요. 성적은 좋지 않았기 때문에 연습을 했지만, 기초를 이해하지 못했기 때문에 제가 이해하기 어려웠어요. 실생활에서 실용적이지 않은 것을 배울 때 특히 개념을 깨우치기 어려웠던 거죠. 마이너스(-)는 부호가 바뀌는 것이 아닌 연산이 아니라는 것을 깨달을 때까지요.\n\n당시에는 JS, CSS, HTML을 사용하여 정적이고 반응형이 아닌 웹페이지를 만들었어요. 웹 개발에 더 많이 몰입함으로써, JSON, YML/YAML, XML 등의 지속적인 정보 파일 표준 사이의 명확한 차이를 이해하게 됐어요.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n내 유리한 점은 나의 규율, 호기심, 그리고 연습했던 것이었습니다. 지성은 나에게 성공하는 데 중요한 요소가 아니었습니다. 10학년 때 나는 궁극적으로 영어를 이해하지 못하는 이유에 대해 궁금해했습니다. 왜 나는 영어 수업을 듣는 내 친구들과 동급인데 내가 못할까요? 영어 선생님인 토니에게 \"어떻게 하면 영어를 배울 수 있을까요? 이해는 되지만 말을 할 수가 없어요\"라고 물었습니다. 그때 유튜브의 영어 자막 동영상을 보며 영어를 배우기 시작했어요. 이것이 나에게 이후 영어를 이해하고 말하는 데 큰 도움이 되었습니다.\n\n고등학교를 졸업한 후에 대학에 진학하는 대신 동일한 학교의 무역 분야의 직업 프로그램을 선택했습니다. 이 선택은 좋은 선택이었습니다. 왜냐하면 제 반에는 여성 23명 정도가 있었거든요. 여성들의 행동에 대해 많은 것을 배우고 무역에 대해 큰 이해를 얻을 수 있었습니다.\n\n이제까지 이어져온 나의 변화가 있었고 이 지난 두 해는 놀라울 정도로 훌륭했으며, 많은 것을 배웠습니다. 이 기간 동안 더 많은 스트레스를 다루는 법을 배우고, 육체적 운동과 같은 자신에게 가하는 스트레스는 규율과 회복력을 향상시킨다는 것을 깨달았습니다.\n\n직업 프로그램 2학년 때 무역을 싫어한다는 것을 깨달았습니다. 경제를 공부하고 싶었지만 프로그램을 통해 SOIB 과정을 수강하게 된 것은 좋은 결정이었습니다 (비록 완료는 하지 못했지만) 새로운 사람들을 만나는 등 많은 것을 배울 기회가 되었습니다. 자신이 무언가를 싫어하고 그것을 그만두는 것이 놀라울 정도로 유익하다는 것을 알아서 기쁘게 생각했어요. 불확실함이 있더라도 시간이 지나면 변할 수 있게 하는 것입니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n표 태그를 Markdown 형식으로 변경하면 됩니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n내가 가장 좋아하는 언어는 Golang과 Rust이며, 이 두 언어는 함수형 언어입니다. 반면에 클래스 기반 프로그래밍 언어를 사용하는 것을 싫어해요.\n\n이전에 언급하지 않았지만, 지금은 17살이에요. 내 모든 성취들에 대해 정말 자랑스러워해요. to_literal이라는 PyPi 라이브러리를 만들었고, 현재는 CUDA를 활용한 GPU 가속화에 중점을 둔 또 다른 라이브러리를 개발 중이에요. 또한 Python을 사용하여 암호화 및 복호화를 가능한 간단하고 효율적으로 만드는 작업도 하고 있어요.\n\n모든 것이 쉽지만은 않았어요. 친구들로부터 중도 탈락을 했다는 이유로 받은 거부감은 좋지 않았고, 그리고 고등학교 공부와 미용실 일을 균형있게 해야 했던 높은 압력은 가장 어려웠던 시기 중 일부였어요. 직업 교육 프로그램을 완수하지 못한 것으로 부모님을 실망시킨 것도 좋은 일이 아니었어요. 그때 나는 근력 운동과 달리기를 했어요. 그만큼의 압박에 견디는 것은 정신 건강에 좋지 않지만, 포기는 결코 내 선택지가 되지 않았어요.","ogImage":{"url":"/assets/img/2024-07-01-Howtobecomethebestself-taughtprogrammer_0.png"},"coverImage":"/assets/img/2024-07-01-Howtobecomethebestself-taughtprogrammer_0.png","tag":["Tech"],"readingTime":5},{"title":"프론트엔드 주간 소식 369 2024년 6월 24일  6월 30일","description":"","date":"2024-07-01 15:50","slug":"2024-07-01-FrontendWeeklyDigest3692430Jun2024","content":"\n\n![이미지](/assets/img/2024-07-01-FrontendWeeklyDigest3692430Jun2024_0.png)\n\n# 웹 개발\n\n- 팝오버는 슬라이드 아웃 서랍으로 아주 잘 작동합니다.\n- 떠오르기\n- 등간격 이상: 완벽한 코딩 폰트를 찾다\n- 프런트엔드 개발에 대한 불평\n- 웹사이트 성능 최적화를 위한 13가지 실용적인 업데이트\n- 리액트에서 네이티브 DOM API로의 전환: 실제 사례\n\n## 도구\n- Vercel v0 및 AI 기반 UI 생성의 미래\n- window.ai - 개발자 도구에서 로컬로 AI 실행!\n\n## 접근성\n- 키보드만으로 웹 브라우징하는 방법\n- 접근성을 위한 강력한 사례 구성 방법\n\n## 효과\n- Digital meets Physical: WebGL로 Risograph 인쇄하기\n- 반짝이는 텍스트 마키 아니메이션 만들기\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# CSS\n\n• CSS에서 conic-gradient()를 사용한 텍스트 노출 효과\n• 2024 CSS Day - 제 10회\n• 유동적인 타이포그래피 크기 계산하기\n• 자동 높이 전환\n• daisyUI 채택 가이드: 개요, 예제 및 대안\n• MUI의 런타임 제로 CSS-in-JS 라이브러리인 Pigment CSS 탐색\n\n# JavaScript\n\n• Ecma International이 ECMAScript 2024를 승인: 무엇이 새로울까?\n• JavaScript Proxy를 위한 7가지 사용 사례\n• 새로운 JavaScript Set 메서드\n• 최신 웹 기능에 대한 JavaScript 브라우저 지원 테스트\n• Million.js 채택 가이드: 개요, 예제 및 대안\n• Unicode 문자열 올바르고 더 나은 처리\n• EmberConf 2024: 12개 비디오\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 리액트\n  - Yup과 Formik을 사용하여 리액트 및 리액트 네이티브에서 양식 유효성 검사하는 방법\n  - Next.js로 정적 사이트 생성 (SSG)\n  - CSS-in-JS 및 리액트 서버 컴포넌트: 개발자 가이드\n  - 리액트 18로 뉴욕 타임스 웹 성능 향상하기\n  - 개발자를 위한 포괄적인 리액트.js 치트시트\n  - 리액트에서 Chrome의 Document Picture-in-Picture API 사용하기\n\n- 뷰\n  - Vue.js Live 2024\n  - Vue 3 이전과 함께 마이크로 프론트엔드 아키텍처 구축\n  - Vue에서 퀸스 게임 재현하기\n\n- 앵귤러\n  - 현대적인 앵귤러 기능 강제하는 5가지 ESLint 규칙\n  - 웹 서버 및 프론트엔드 애플리케이션에서 ClickJacking 방지하는 방법\n  - 라우트 전환을 위한 앵귤러 애니메이션 튜토리얼","ogImage":{"url":"/assets/img/2024-07-01-FrontendWeeklyDigest3692430Jun2024_0.png"},"coverImage":"/assets/img/2024-07-01-FrontendWeeklyDigest3692430Jun2024_0.png","tag":["Tech"],"readingTime":2},{"title":"CSS로 자동 스크롤 가능한 요소 만드는 방법","description":"","date":"2024-06-30 22:42","slug":"2024-06-30-CreatinganAuto-ScrollableElementwithCSS","content":"\n\n웹 페이지에 자동으로 스크롤되어 가장 최신 콘텐츠를 표시하는 채팅이나 로그 표시를 구현해보고 싶은 적이 있으신가요? 몇 줄의 CSS 코드만으로 쉽게 이를 구현할 수 있습니다.\n\n![image](https://miro.medium.com/v2/resize:fit:1036/1*3Kw8USr6Jfn_cR0JHLw2-Q.gif)\n\n이 튜토리얼에서는 CSS를 사용하여 자동으로 스크롤되는 요소를 만들어 새로운 콘텐츠가 추가됨과 동시에 자동으로 아래로 스크롤되는 방법을 안내해 드리겠습니다.\n\n여기 필요한 CSS 코드입니다:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```css\n.autoscrollable-wrapper {\n  overflow: auto;\n  max-height: 100%;\n  display: flex;\n  flex-direction: column-reverse;\n}\n```\n\n여기에 HTML 코드가 있어요:\n\n```html\n<div class=\"autoscrollable-wrapper\">\n  <div class=\"autoscrollable-content\">\n    <!-- 여기에 자동으로 스크롤이 필요한 콘텐츠를 넣으세요 -->\n  </div>\n</div>\n```\n\nCSS 코드의 각 줄을 하나씩 살펴보면서 그 역할을 이해해 볼까요?\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 오버플로 속성은 자동으로 설정되어 있습니다. 이는 콘텐츠가 넘칠 경우 해당 요소에 스크롤바가 표시됨을 의미합니다.\n- 최대 높이 속성은 100%로 설정되어 있어 부모 요소의 높이를 100%로 제한합니다. 높이 대신 최대 높이를 설정하는 것은 요소가 높이를 동적으로 조절할 수 있게 해주기 때문에 유용합니다. 이로써 콘텐츠가 자동으로 맨 위에 표시되고 새 콘텐츠가 아래에 나타날 수 있게 됩니다. 즉시 콘텐츠를 아래쪽에 표시하려면 높이를 사용할 수 있습니다.\n- 디스플레이 속성은 플렉스로 설정되어 있어 해당 요소가 플렉스 컨테이너가 됩니다. 플렉스 방향 속성은 column-reverse로 설정되어 있어 플렉스 아이템이 수직으로 역순으로 배치됩니다. 이것이 새 콘텐츠가 아래쪽에 나타나며 자동 스크롤을 유발하는 이유입니다.\n\n요약하면 CSS에서 flex 및 flex-direction: column-reverse를 사용하면 자동 스크롤 가능한 요소가 바닥에 스크롤되고 추가됨에 따라 최신 콘텐츠가 표시되도록 유지됩니다.\n\n저는 몇 가지 자바스크립트 코드가 포함된 CodePen 예제를 만들었습니다. 해당 코드는 요소에 텍스트를 계속 출력하여 새 텍스트가 추가될 때 요소가 스크롤되는 것을 보여줍니다.\n\n# 참고문헌\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 스택 오버플로우 답변 — 이 튜토리얼을 영감을 주는 원본 솔루션입니다.","ogImage":{"url":"/assets/img/2024-06-30-CreatinganAuto-ScrollableElementwithCSS_0.png"},"coverImage":"/assets/img/2024-06-30-CreatinganAuto-ScrollableElementwithCSS_0.png","tag":["Tech"],"readingTime":3},{"title":"Tailwind CSS와 Bootstrap 종합 비교 분석","description":"","date":"2024-06-30 22:41","slug":"2024-06-30-TailwindCSSvsBootstrapAComprehensiveComparison","content":"\n\n아래는 마크다운 형식으로 나타낸 내용입니다.\n\n\n![이미지](/assets/img/2024-06-30-TailwindCSSvsBootstrapAComprehensiveComparison_0.png)\n\n프론트엔드 개발 세계에서 CSS 프레임워크는 반응형 및 시각적으로 매력적인 웹 애플리케이션을 디자인하는 프로세스를 간소화하는 데 중요한 역할을합니다. 가장 인기 있는 CSS 프레임워크 중 두 가지는 Tailwind CSS와 Bootstrap입니다. 각각이 독특한 접근 방식과 기능 세트를 갖고 있으며, 다른 요구 사항 및 기호를 고려하여 스타일링에 소요되는 시간을 줄입니다. 이 기사에서는 Tailwind CSS와 Bootstrap을 비교하고, 차이점과 두 프레임워크를 돋보이게 만드는 특징을 강조할 것입니다.\n\n## Tailwind CSS란?\n\n![이미지](/assets/img/2024-06-30-TailwindCSSvsBootstrapAComprehensiveComparison_1.png)\n\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n테일윈드 CSS는 개발자들이 HTML을 떠나지 않고 사용자 정의 디자인을 만들 수 있는 유틸리티 중심의 CSS 프레임워크입니다. 미리 디자인된 컴포넌트 대신, 테일윈드는 조합하여 마크업에서 직접 모든 디자인을 구축할 수 있는 저수준 유틸리티 클래스를 제공합니다. 버즈피드(Solid by Buzzfeed), TED(Shed by TED), Stripe, Medium, Meetup, Kickstarter, Twitch, Heroku, Starbucks, Pizza Hut, NBA 웹사이트, 유로비전, Clubhouse, GitHub CoPilot, React Beta Documentation, Netflix의 Top 10 사이트 등 많은 사이트와 프로젝트에서 테일윈드 CSS를 사용하고 있습니다.\n\n## 테일윈드 CSS의 주요 기능:\n\n유틸리티 중심 접근 방식: 테일윈드의 유틸리티 클래스는 매우 조합 가능하여 대부분의 CSS 프레임워크에서 제공하지 않는 스타일링에 대한 세심한 제어를 가능하게 합니다.\n사용자 정의: 테일윈드는 광범위한 구성 옵션을 제공하여 개발자가 프로젝트의 특정 요구 사항에 맞게 프레임워크를 맞춤화할 수 있습니다.\n반응형 디자인: 내장된 반응형 유틸리티 클래스를 사용하여 모든 화면 크기에서 멋지게 보이는 디자인을 쉽게 만들 수 있습니다.\n성능: 테일윈드와 PurgeCSS를 함께 사용하여 사용되지 않는 스타일을 최종 CSS 파일에서 제거함으로써 파일 크기가 줄어들고 더 빠른 로드 시간을 보장할 수 있습니다.\n\n## 부트스트랩이란 무엇인가요?\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Screenshot](/assets/img/2024-06-30-TailwindCSSvsBootstrapAComprehensiveComparison_2.png)\n\n부트스트랩은 트위터에서 개발한 포괄적인 CSS 프레임워크로, 미리 디자인된 구성 요소 모음과 반응형 그리드 시스템을 제공합니다. 이는 일관된 디자인 언어와 강력한 기능 세트를 제공하여 프론트엔드 개발을보다 빠르고 쉽게 만들기 위해 설계되었습니다. Mastercard, Spotify, LinkedIn, Twitter, Lyft, Snapchat, Udemy, Upwork, Duolingo, Postman, Indeed, Bloomberg 등이 부트스트랩을 자사 웹사이트에 사용하고 있습니다.\n\n## 부트스트랩의 주요 기능:\n\n구성 요소 중심: 버튼, 모달, 네비게이션 바, 폼 등 다양한 미리 디자인된 구성 요소를 제공하며 프로젝트에 쉽게 통합할 수 있습니다.\n그리드 시스템: 부트스트랩의 반응형 그리드 시스템을 사용하면 유연하고 적응 가능한 레이아웃을 쉽게 만들 수 있습니다.\n일관성: 부트스트랩은 다른 브라우저와 기기에서 일관된 외관을 제공합니다.\nJavaScript 플러그인: 사이트에 상호 작용 요소를 추가하는 다양한 JavaScript 플러그인을 포함하고 있습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# Tailwind CSS vs Bootstrap: 비교\n\n## 1. 디자인 철학\n\nTailwind CSS: 유틸리티 우선 접근을 강조하여 개발자들이 미리 정의된 스타일에 구속받지 않고 사용자 정의 UI를 설계할 수 있는 유연성을 제공합니다.\nBootstrap: 일관된 디자인 패턴을 따르는 준비된 구성 요소 세트를 제공하는 데 초점을 맞춰 빠르고 균일하며 세련된 디자인을 쉽게 만들 수 있습니다.\n\n## 2. 학습 곡선\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nTailwind CSS: 유틸리티 클래스에 익숙해지기 위해 마음가짐을 변경해야 하지만, 한 번 익숙해지면 매우 유연하며 빠른 개발이 가능합니다. \nBootstrap: 구성 요소 중심 접근 방식과 방대한 문서로 시작하기 쉽습니다.\n\n### 3. 사용자 정의\n\nTailwind CSS: 구성 파일을 통해 매우 사용자 정의가 가능하며, 개발자들이 자체 색상 팔레트, 간격 및 브레이크포인트를 정의할 수 있습니다. \nBootstrap: Sass 변수와 사용자 정의 도구를 통해 사용자 정의 옵션이 제공되지만, Tailwind와 비교하면 세부적인 제어가 적습니다.\n\n### 4. 성능\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nTailwind CSS: 사용하지 않는 스타일을 제거하면서 CSS 파일 크기를 줄이는 PurgeCSS를 사용하면 빠른 로딩 시간을 가질 수 있습니다.\n\nBootstrap: 전체 CSS 번들은 상당히 크지만, 개발자는 필요한 컴포넌트만 선택적으로 포함하여 파일 크기를 줄일 수 있습니다.\n\n## 5. 사용 사례\n\nTailwind CSS: 디자인에 완전한 제어를 원하고 사용자 정의 UI를 빌드해야 하는 프로젝트에 이상적입니다.\n\nBootstrap: 미리 디자인된 컴포넌트를 사용하여 일관된 디자인으로 빠르게 구축해야 하는 프로젝트에 적합합니다.\n\n## 결론\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n테일윈드 CSS와 부트스트랩은 각자 독특한 강점을 가지고 있으며 프로젝트 요구사항에 따라 매우 효과적일 수 있어요. 테일윈드의 유틸리티 중심 방식은 탄탄한 유연성과 맞춤 설정을 제공하며, 부트스트랩의 컴포넌트 기반 구조는 반응형 웹사이트를 빠르고 일관되게 개발하는 방법을 제공해요. 두 가지 중 어떤 것을 선택할지는 궁극적으로 여러분의 특정한 요구사항과 선호도에 달려 있어요. 사용하고 디자인을 수정할 수 있는 것으로 최대한 맞춤화하고 싶다면 테일윈드 CSS를 매우 추천하지만 이미 디자인된 컴포넌트가 필요하다면 부트스트랩이 올바른 선택이 될 거예요.\n\n## 리액트와 HNG 인턴십에서의 나의 여정\n\nHNG에서는 주로 사용자 인터페이스를 구축하는 강력한 라이브러리인 ReactJS를 사용해요. React의 컴포넌트 기반 구조와 버추얼 DOM은 많은 개발자들에게 인기 있는 선택지예요. HNG와의 이 여정에서 React를 더 깊이 탐구하면서, 훅, 컨텍스트 API, 그리고 고급 패턴을 숙달할 수 있도록 하겠어요. 강력한 응용 프로그램을 개발하고 HNG 개발자 커뮤니티로부터 배우는 것을 기대하고 있어요.\n\n만약 동적이고 지원적인 개발자 커뮤니티에 참여하고 싶다면 [HNG 인턴십](https://hng.tech/internship)을 확인하고 가능한 기회에 대해 더 알아보세요. HNG 커뮤니티에서 최고의 재능을 [고용하는 방법](https://hng.tech/hire)을 살펴보실 수도 있어요.","ogImage":{"url":"/assets/img/2024-06-30-TailwindCSSvsBootstrapAComprehensiveComparison_0.png"},"coverImage":"/assets/img/2024-06-30-TailwindCSSvsBootstrapAComprehensiveComparison_0.png","tag":["Tech"],"readingTime":6},{"title":"React에서 상태 및 스크롤 위치를 유지하는 방법","description":"","date":"2024-06-30 22:40","slug":"2024-06-30-HowtomaintainstateandscrollpositioninReact","content":"\n\n가끔 뉴스 목록에서 뉴스 세부 페이지로 전환한 후 다시 돌아오면 상태와 스크롤 위치가 손실될 수 있습니다. 이를 방지하기 위해 페이지 간 이동 시 react-router-dom을 사용하여 값을 전달할 수 있습니다.\n\n따라서 세부 페이지로 이동할 때 다음과 같이 상태 및 스크롤 위치를 전달하세요.\n\n```js\nnavigate('/userDetails', {state: {userLists: data, scrollPosition, userInfo: info}})\n```\n\n`div` 요소에서 스크롤 이벤트를 캡처하고 값을 업데이트하는 방법:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n function handleScroll(event) {\n    setScrollPosition(event.target.scrollTop)\n }\n\n<div style={{overflowY: \"scroll\",height: '100vh'}} ref={scrollRef} onScroll={handleScroll}>\n```\n\n유저가 뒤로 돌아갈 때, 상태를 다시 뉴스 페이지로 변경하세요:\n\n```js\nnavigate('/news', { state: location.state })\n```\n\n뉴스 컴포넌트에서 아래와 같이 데이터에 접근하고 업데이트하세요.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nuseEffect(()=> {\n   if(location.state){\n      const {userLists,scrollPosition} = location.state;  \n      setData(userLists)\n      scrollRef.current.style.backgroundColor = 'red'\n      setTimeout(() => {\n        scrollRef.current.scrollTop = scrollPosition\n      }, (10));\n   }else{\n      getDataFromApi();\n   }\n},[])\n```\n\n기억하세요, setTimeout 내부의 코드는 잠시 지난 후에 실행되며 스크롤 위치를 조정하기 전에 DOM이 안정화됩니다.\n\n그리고 다음은 이 기능을 적용하는 방법의 예시입니다.\n\n```js\nimport './App.css';\nimport { useEffect, useRef, useState } from 'react';\nimport axios from 'axios';\nimport { BrowserRouter, Route, Routes, useLocation, useNavigate } from 'react-router-dom';\n\nfunction App() {\n\n  return (\n    <BrowserRouter>\n     <Routes>\n       <Route path=\"/news\" element={<UserLists />}/>\n       <Route path=\"/userDetails\" element={<UserDetails />}/>\n     </Routes>\n    </BrowserRouter>\n  );\n}\n\nconst UserLists = () => {\n  const [data,setData] = useState([]);\n  const [scrollPosition,setScrollPosition] = useState();\n  const navigate = useNavigate();\n  const location = useLocation();\n  const scrollRef = useRef();\n\n  useEffect(()=> {\n    if(location.state){\n      const {userLists,scrollPosition} = location.state;  \n      setData(userLists)\n      scrollRef.current.style.backgroundColor = 'red'\n      setTimeout(() => {\n        scrollRef.current.scrollTop = scrollPosition\n      }, (10));\n    }else{\n      getDataFromApi();\n    }\n  },[])\n\n\n  const getDataFromApi = async () => {\n    try{\n      const res = await axios.get('https://reqres.in/api/users');\n      setData(res.data.data);\n    }catch(err){\n      console.log(\"error\",err)\n    }     \n  }\n\n  const handleScroll = (event) => {\n    setScrollPosition(event.target.scrollTop)\n  }\n\n  return (\n    <div className=\"App\">\n      <div style={{overflowY: \"scroll\",height: '100vh'}} ref={scrollRef} onScroll={handleScroll}>\n        {data.map((info) => {\n          return (\n            <div\n              style={{backgroundColor: \"orange\"}}\n              onClick={() => {\n                navigate('/userDetails',{state: {userLists: data,scrollPosition,userInfo: info}})\n              }\n            >\n              <h2>{info.email}</h2>\n              <h2>{info.first_name}</h2>\n              <h2>{info.last_name}</h2>\n              <img src={info.avatar} />\n            </div>\n          )\n        })}\n      </div>\n    </div>\n  )\n}\n\nconst UserDetails = () => {\n  const [userInfo,setUserInfo] = useState();\n  const navigate = useNavigate();\n  const location = useLocation();\n\n  useEffect(()=> {\n    if(location.state){\n      const {userInfo} = location.state;\n      setUserInfo(userInfo)\n    }\n  })\n\n  return (\n    <div>\n      <button\n        onClick={() => {\n          navigate('/news',{state: location.state})\n        }\n      >\n        Go back to user lists\n      </button>\n      <div\n        style={{backgroundColor: \"skyblue\"}}\n      >\n        <h2>{userInfo?.email}</h2>\n        <h2>{userInfo?.first_name}</h2>\n        <h2>{userInfo?.last_name}</h2>\n        <img src={userInfo?.avatar} />\n      </div>\n    </div>\n  )\n}\n\nexport default App;\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그게 전부에요...\n\n위의 방법은 사용자가 브라우저의 뒤로 가기 버튼을 누를 때 작동하지 않습니다. 이러한 경우에 작동하려면 로컬 스토리지에 상태와 스크롤 위치를 저장하고, 첫 렌더링 중에 useEffect에서 사용해야 합니다.\n\n질문이 있으시면 응답 섹션에서 물어봐 주세요.","ogImage":{"url":"/assets/img/2024-06-30-HowtomaintainstateandscrollpositioninReact_0.png"},"coverImage":"/assets/img/2024-06-30-HowtomaintainstateandscrollpositioninReact_0.png","tag":["Tech"],"readingTime":5}],"page":"4","totalPageCount":120,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true}