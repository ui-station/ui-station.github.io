{"pageProps":{"posts":[{"title":"2024 OWASP 모바일 탑 10 변경 사항에 대한 소식이 뭐길래","description":"","date":"2024-05-23 14:48","slug":"2024-05-23-Whatsthebuzzaboutthe2024OWASPMobileTop10changes","content":"\n# 소개\n\n먼저, 2024년 새해 복 많이 받으세요 🎉 이미 2월이 되었지만, 올해 첫 게시물이라 조금 늦었다는 점 이해해 주시면 감사하겠습니다.\n\n그 외에도, 좋은 소식은 올해 모바일 보안 분야에서 이미 흥미로운 소식으로 시작되었다는 것입니다. 이 게시물에서는 2024년을 위한 OWASP Mobile Top 10의 변경 사항을 살펴보고, 그것이 보안에 민감한 개발자인 여러분에게 무슨 의미가 있는지 알아보겠습니다!\n\n저의 OWASP Mobile Top 10 강의나 포스트에 이미 익숙한 분들은 당연히 \"OWASP의 정상\" 섹션으로 건너뛰어서 흥미로운 내용을 확인할 수 있습니다. 그러나 OWASP가 무엇이며 최근 변경 사항이 모바일 보안 분야에서 큰 영향을 미친다는 사실에 대해 잘 알지 못하거나 간단히 상기시키고 싶다면, 함께 머물러 주시면 OWASP란 무엇이며 최근 변경 사항이 모바일 보안 분야에서 왜 중요한지에 대해 다시 한 번 요약해 드리겠습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# OWASP이 뭐죠? 🐝\n\n모바일 보안에 새로 오신 분이나 제 블로그 게시물을 처음 보시는 분, 혹은 한동안 돌아본 적이 없는 분들께 질문드립니다. OWASP와 그들이 하는 훌륭한 작업에 대해 아시지 못할 수 있습니다.\n\n2001년에 설립된 OWASP(Open Worldwide Application Security Project) 재단은 비영리 단체로, 소프트웨어 보안 관행에 대한 교육 자료, 도구, 교육 자원 및 다른 다양한 커뮤니티 기반 서비스를 제공합니다. 우리 분야에서 선두적인 어플리케이션 보안 커뮤니티로 널리 인정받으며 다양한 프로젝트에서 모바일 보안을 다루는 프로젝트를 비롯한 많은 헌신적인 자원봉사자들이 있습니다.\n\nOWASP가 제공하는 안내 중 하나는 'Top 10' 위협 목록입니다. 이 목록은 OWASP가 특정 영역의 보안에 대한 자신의 상위 10위 위협 목록으로, 모든 개발자에게 매우 유용한 자원입니다¹.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저는 이전에 그들의 지난 안내에 대해 다양한 콘텐츠를 제공했습니다. 더 자세히 알고 싶다면, 제 발표 페이지와 이전 OWASP 관련 블로그를 확인해보세요. 그 곳에는 더 많은 자세한 내용과 관련 링크가 있습니다.\n\n보다 실용적인 학습자라면, 제 OWASP 발표를 위한 동반 앱도 있습니다. 그 앱은 제가 소개한 주제 중 일부를 보여줍니다.\n\n어쨌든, 2024년은 거의 10년 만에 가장 중요한 Mobile Top 10의 수정이 이루어지고 있습니다. 그래서 더 이상 말 할 필요 없이, 무엇이 변했는지 살펴보겠습니다! 👀\n\n# “OWASP의 꼭대기\" ✨\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n긴 협의 기간과 여러 차례의 수정을 거친 끝에, 최근 발표된 OWASP Mobile Top Ten 2024는 2014년 최초 발표 이후 세 번째이자 최신 주요 개정판입니다.\n\n2024년 발표 버전은 2016년 버전을 대체하며, 현재의 모바일 보안 환경을 더 잘 반영하기 위해 네 가지 새로운 위협 범주와 위협의 완전한 재배열을 포함한 명백한 변경 사항을 가져왔습니다.\n\n이 모든 것은 잘 된 일이지만, 실제로 무엇이 변경되었고 이 모든 의미가 무엇을 의미하는지 궁금하십니까? 😅 음, 진짜 Billboard 차트 스타일로 (이나 영국인으로서는 Top of the Pops 스타일로), 각 위협에 대해 순서를 거꾸로하여 번호 10부터 간단히 설명해 보겠습니다!\n\n![이미지](https://miro.medium.com/v2/resize:fit:768/1*9ESds38QHiOyqz_CkOXM7A.gif)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## #10: 부적절한 암호화 ⬇️\n\n2016년 5위에서 내려온 부적절한 암호화는 모바일 앱이 현대 암호화 최상의 방법을 채택하지 못해 겪는 위협입니다. 이는 안전하지 않은 알고리즘(SHA-1, MD5 등)을 구현하거나 안전한 데이터 전송(HTTPS)을 사용하지 않거나 심지어 키에 맛있는 소금을 쓰지 않는 것으로 나타납니다 🧂.\n\n암호화를 사용할 때, 특정 필요에 맞는 최상의 방법을 따르도록 하십시오. 예를 들어, AES와 같은 알고리즘을 사용하면서 최소 128비트 블록 크기 또는 최소 2048비트 RSA를 사용하는 것이 좋습니다. 의문이 생길 경우, 전문가에게 질의하거나 Google의 tink 라이브러리와 같은 신뢰할 수 있는 도구를 활용하십시오.\n\n앞으로 제 블로그에서 관련 포스트가 올라올 예정입니다 (희망적으로) 📝.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## #9: 안전하지 않은 데이터 저장 ⬇️\n\n2016년 목록에서 크게 순위가 변동한 항목 중 하나는 안전하지 않은 데이터 저장이었어요. 2위에서 9위로 내려왔네요. 아파요 😣\n\n만약 데이터(네트워크 호출 포함)를 로그에 출력하거나, 비밀번호나 토큰을 저장하거나, 임시 파일을 생성하거나, 또는 SQL 데이터베이스나 Shared Preferences와 같은 표준 저장 기술을 사용하고 있다면, 당신의 앱은 안전하지 않은 데이터 저장에 취약할 수 있습니다.\n\n저는 이전에도 안전하지 않은 데이터 저장에 대해 자세히 다뤘었어요. 그래서 제 글을 꼭 확인하고, 앱의 데이터가 안전하고 안전하게 저장되어 있는지 확인해보세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n언제나 강조해야 할 점은 가능한 경우 기기에 민감한 데이터를 저장하는 것을 피하는 것이 최선의 실천 방법입니다!\n\n## 8번: 보안 구성 오류 ⬆️\n\n10위에서 상승한 이 ‘보안 구성 오류’라는 새로운 명칭의 ‘Extraneous Functionality’에 대해 이야기해 보겠습니다.\n\n‘RTFM’ 개념을 알고 있다면, 이 위협이 무엇인지 알 수 있을 것입니다. 이는 종종 개발자가 제품 빌드에서 잘못된 설정을 사용하거나 필요하지 않은 상승된 액세스나 권한을 요청하거나 원래는 애플리케이션 내부로 의도된 기능을 노출하는 데 발생합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n문서화는 종종 친구가 될 수 있어요. 읽는 걸 소홀히 하지 마세요. 🥲 커피를 가져다가 실수에 갇히세요!\n\n## #7: 바이너리 보호 미비 ⬆️\n\n크림, 오디오스레이브 또는 아톰 포 피스와 같이 유명한 밴드들처럼, 2016년 8위와 9위(코드 위조 및 역공학)가 합쳐져 7위로 올라왔어요. 😎\n\n바이너리 보호는 앱의 바이너리(즉, 안드로이드의 .apk/.aar 또는 iOS의 .ipa 파일)가 정보를 유출하지 않거나 다시 패키징되지 않도록 하는 데 초점을 맞춥니다. 앱을 제대로 난독화하지 않거나 무결성 검사를 제대로 하지 않으면 공격자가 악성 코드를 주입하여 앱을 역공학하거나 재분배할 수 있는 가능성이 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n내 좋은 친구 Guardsquare과 그들의 훌륭한 도구(예: DexGuard 및 Proguard Playground)를 적극 추천합니다. 이 도구들은 특정 위협으로부터 앱을 안전하게 유지하는 데 도움이 됩니다. 또는 R8 및 Google Play 무결성 API에 대해 더 알아보는 데 투자하는 것도 도움이 될 수 있어요!\n\n## #6: 불충분한 개인정보 보호 기능 🆕\n\n6위로 새롭게 입성한 '불충분한 개인정보 보호 기능'입니다.\n\n당신의 앱이 사용자의 개인 식별 정보(예: 전체 이름, 정확한 위치, 금융 상세 정보, 성향 등)를 다룬다면, 이 정보들이 잘못된 손에 들어가면 해당 사용자를 사칭하거나 괴롭히거나 사기를 저질 수 있는 경우가 발생할 수 있습니다. 이 경우 이것이 해당될 수도 있어요! 🥸\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n애플리케이션이 저장하거나 기록하는 개인 식별 정보(PII)를 로컬에 저장하지 않도록하고 사용자로부터의 정보 최소한만 요청/전송하십시오. 이렇게 하면 저장소나 데이터 전송의 취약점을 통해 PII가 노출될 가능성이 크게 줄어듭니다.\n\n예를 들어, 영화 예매 앱에서 성적 지향이나 정확한 위치가 필요합니까? 아마 아니죠! 대신 코스 위치를 요청하여 인근 영화관을 찾고 사용자가 추천을 받기 위해 추가 개인 정보를 제공할 수 있도록 요청하고, 나중에 그것을 선택적으로 거부할 수 있도록 하는 것이 훨씬 나을 것입니다.\n\n## #5: 통신 불안전 ⬇️\n\n또 다른 이동! 2016년 3위인 '통신 불안전'이 5위로 두 단계 하락했습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n데이터 전송이나 수신과 관련된 위협을 다루고 있어요. 대부분의 응용프로그램은 인터넷을 통해 이를 수행하지만, 여러분의 앱은 NFC나 블루투스와 같은 다른 통신 방법을 사용할 수도 있어요. 데이터 통신이 있으면, 거기에는 위험이 연결되어 있을 거라고 확신할 수 있어요!\n\n이 문제에 대해 더 자세히 다루지는 않겠어요. 이전에 보안 통신에 대해 블로그를 썼었기 때문에 그 부분도 꼭 확인해보시길 바래요.\n\n## #4: 충분하지 않은 입력/출력 유효성 검사 🆕\n\n4번 항목의 새로운 주제는 사용자 입력 및 출력을 다뤄봅니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n모바일 앱 및 API가 사용자 입력을 통신하거나 출력할 때 올바로 처리되도록 하는 것이 매우 중요합니다 🛁 그렇지 않으면 SQL 인젝션 또는 교차 사이트 스크립팅 (XSS)과 같은 위협이 발생할 수 있으며 이는 민감한 사용자 데이터를 노출하거나 더 심각한 경우 기기가 위협받을 수 있습니다. 원하는 값 및 형식을 얻고 해당 기준에 충족하지 않는 경우는 버려야 합니다.\n\nWhatsApp에서 유포된 ‘Effective Power’ 또는 ‘Black Spot’ 메시지를 기억하시나요? WhatsApp 메시지에 특별히 디자인된 입력이 출력될 때 발생한 문제였는데, 이는 일종의 ‘서비스 거부’로 설계된 것이었습니다. — 여기서 살균 처리가 문제를 해결했을까요? 아마도 가능합니다!\n\n요약하면, 입출력 조심하면 ‘작은 바비 테이블’이 문제를 일으키지 않아도 안심할 수 있습니다 ⁶.\n\n## #3: 안전하지 않은 인증/인가 ⬆️\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nIn the new ranking, insecurities related to authentication and authorization have moved up to the 3rd place, combining aspects from the previous 4th and 6th spots.\n\nTo prevent confusion due to similar names, let's clarify that authentication confirms the user's identity, while authorization verifies if the user has the necessary roles or credentials to access specific resources.\n\nIt's crucial to perform authentication and authorization checks on the server side to prevent vulnerabilities from potential binary modifications or other methods.\n\nWhen interacting with APIs that need authorization, make sure to use revocable tokens linked to the device. This way, users can revoke tokens if their device is lost or stolen. Remember to refresh tokens regularly and ensure your backend team authenticates properly when authorizing access to restricted resources!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다시, Insecure Authentication에 대한 자세한 내용은 해당 주제에 대한 이전 블로그를 확인해 보세요 🤠 이어서 Insecure Authorization에 대한 더 많은 정보를 확인할 수 있을 거에요.\n\n## #2: 부적절한 공급망 보안 🆕\n\n제 2위에 새로운 항목이 추가되었는데, 이는 우리 앱을 구축하는 데 사용하는 도구와 프로세스에 초점을 맞추고 있어요.\n\n'공급망 공격'은 사용하는 도구에 대한 공격을 말하며, 감지되지 않고 도구에 취약점, 보안 위협 또는 악의적인 코드를 도입하는 것을 의미해요. 조직 내부에서는 부정직한 직원에 의해, 또는 시스템이나 도구에 특권 액세스를 얻은 악의적인 행위자에 의해 외부에서 이루어질 수 있어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n안녕하세요! 보안을 강화하기 위해 코드 검토 프로세스를 철저히 실시하는 것이 중요합니다. 뿐만 아니라 공급망의 액세스 제어에 대한 정기적인 감사도 수행해야 합니다. 앱의 종속성을 모니터링하고 이들이 정기적으로 검토되도록 하여 보안 취약성을 방지해야 합니다.\n\n이미 확인하지 않았다면, 저는 이전에 공급망 공격과 Gradle 작업 시 어떻게 완화할 수 있는지에 대해 블로그 게시 및 강의를 진행했습니다.\n\n## #1: 부적절한 자격 증명 사용 🆕\n\n대망의 순간입니다 🥁 OWASP에 따르면 모바일 보안의 가장 큰 위협은... 부적절한 자격 증명 사용입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이것은 사용자 자격 증명, API 키부터 그 사이의 모든 것에 적용되는 보안 부적절로 인한 케이스를 포괄하는 범주입니다!\n\n알람이 울리는 2021 보고서에 따르면 추정 200개 애플리케이션 중 1개가 하드코딩된 API 키를 통해 AWS 자격 증명을 유출한 것으로 추정되었습니다 😅 이처럼 API 키 또는 하드코딩된 자격 증명이 노출되면 파괴적인 결과가 초래될 수 있습니다. 이러한 종류의 자격 증명 유출은 이전에 Uber, Verizon, Accenture 등 주요 기업들에게 피해를 입히고, 고객 데이터(포함된 개인 식별 정보 및 결제 정보)가 노출된 데이터 침해를 발생시켰습니다 🙀 일반적으로 로컬에 저장해야 하는 민감한 데이터는 항상 암호화되어야하며, 암호화에 사용되는 키는 하드웨어 보호 키 저장소에 안전하게 저장되어야 합니다.\n\n이 모든 소리들이 겁나게 들리지만, 자신이 부적절한 자격 증명 처리에 걸리지 않는 방법은 꽤 간단합니다. 사용자 자격 증명(비밀번호 등)을 장치에 저장하지 않으며, 제3자 API 키를 정기적으로 교체하고, 언제나 HTTPS를 통해 자격 증명을 안전하게 전송해야 합니다. 간단하죠! 🙌\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 마무리로... 🐝\n\n마지막으로, 2016년과 2024년 목록 사이에 상당한 변화가 있었지만, 보안에 민감한 개발자로서 여러분은 항상 응용 프로그램을 잠재적인 위협에 대해 지속적으로 모니터링해야 합니다. 상위 10개가 변경되었을 수 있지만, 많은 개발자들이 모바일 보안을 제대로 이해하지 못한다는 현실은 여전합니다. 더 많이 배우고 이 지식을 공유함으로써 이를 바꿀 수 있습니다!\n\n이 글에서 하나의 교훈을 얻는다면, 모바일 애플리케이션에 대한 잠재적인 위협에 대해 여러분과 팀원들이 숙지되어 있는지 확인하고 (MASVS와 같은 훌륭한 자원이나 저의 블로그를 읽는 것처럼) AppSweep, MobSF, Snyk, 또는 SonarQube와 같은 도구를 통합하여 코드/바이너리를 이러한 문제에 계속적으로 점검해보시기 바랍니다.\n\n마지막까지 완주하셨네요! 2024년이 멋지고 안전한 한 해 되길 바랍니다 🥰 🔐\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 감사합니다 🌟\n\n언제나 읽어 주셔서 감사합니다! 이 포스트를 재밌게 보셨으면 @Sp4ghettiCode로 피드백을 트윗해 주세요. 반응이나 좋아요, 트윗, 공유, 스타 등도 잊지 말고 해 주세요 🙂\n\n## 더 읽기\n\n- OWASP Top Five Companion App (2016 버전)\n- OWASP Mobile Top Ten 2024\n- Mobile Application Security Verification Standard: MASVS\n- Mobile Application Security Testing Guide: MASTG\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 각주\n\n[1]: 보안 중심의 모바일 개발자이시라면, 업데이트된 MASVS 및 MASTG에 특히 주의를 기울여 모바일 앱의 보안 모델을 적용하고 테스트해야 합니다.\n\n[2]: 염화 나트륨과는 아무 상관이 없습니다. 이 문맥에서의 \"솔트(salt)\"는 동일한 평문이 여러 번 입력되더라도 다른 해시값이 생성되도록 보장하기 위해 평문에 연결된 임의의 데이터를 의미합니다.\n\n[3]: 불편하기는 해도, 2024년 Top 10이 5위에 있을 때 대부분 완성된 \"Insufficient Cryptography\" 글은 최종적으로 10위가 아니라는 것을 알았습니다. (그런데 누가 10부작 블로그 시리즈를 생각해냈을까요!?)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n[4]: 제발 제품에서 네트워크 호출을 로깅하는 것을 그만둬주세요. 이미 2024년이에요. 🥲\n\n[5]: 'F'는 정말 옳은 것을 가리키는 것이에요 😅\n\n[6]: https://xkcd.com/327/\n","ogImage":{"url":"/assets/img/2024-05-23-Whatsthebuzzaboutthe2024OWASPMobileTop10changes_0.png"},"coverImage":"/assets/img/2024-05-23-Whatsthebuzzaboutthe2024OWASPMobileTop10changes_0.png","tag":["Tech"],"readingTime":14},{"title":"CSRF로 인해 계정이 삭제될 수 있습니다","description":"","date":"2024-05-23 14:47","slug":"2024-05-23-CSRFLeadstoDeleteAccount","content":"\n# 안녕하세요!\n\n![이미지](/assets/img/2024-05-23-CSRFLeadstoDeleteAccount_0.png)\n\n# 소개\n\n- 대상: 안드로이드 애플리케이션\n- 날짜: 2024년 5월\n- 요약: Corp 앱에서 CSRF 취약점을 발견했습니다. 이 취약점을 이용하여 사용자 계정을 삭제할 수 있는 Deeplink와 delete-account 엔드포인트 간의 상호작용이 가능합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 복제 단계\n\n- 먼저 AndroidMainfast.xml을 살펴봅니다.\n\n```xml\n        <activity android:theme=\"@style/Theme.Thredup.Splash\" android:name=\"com.example.android.feature.splash.SplashActivity\" android:exported=\"true\" android:launchMode=\"singleTask\" android:screenOrientation=\"behind\" android:configChanges=\"screenSize|orientation\" android:noHistory=\"true\">\n            <intent-filter android:autoVerify=\"true\">\n                <action android:name=\"android.intent.action.VIEW\"/>\n                <category android:name=\"android.intent.category.DEFAULT\"/>\n                <category android:name=\"android.intent.category.BROWSABLE\"/>\n                <data android:host=\"www.example.com\" android:pathPrefix=\"/account\"/>\n                <data android:scheme=\"https\"/>\n                <data android:scheme=\"http\"/>\n            </intent-filter>\n        </activity>\n```\n\n- 'adb'를 사용하여 호출한 후에 /account/라는 Path로 이 Deeplink를 발견했습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 지금은 설정에 있어요;\n- 잠시만 android:pathPrefix=/account/는 무슨 의미일까요?\n- android:pathPrefix 속성은 Intent 객체의 경로의 초기 부분에만 일치하는 부분 경로를 지정합니다. 그래서 아마도 /account/ 뒤에 무언가를 찾을 수 있을지도 모릅니다.\n- 설정 이후에 API 호출을 가로챈 후, 비밀번호 변경이나 계정 삭제와 같은 설정 후의 API 엔드포인트를 Deeplink에서 사용해 봅시다.\n\n```js\nadb shell am start -a android.intent.action.VIEW -n com.thredup.android/com.thredup.android.feature.splash.SplashActivity -d \"https://www.example.com/account/change_password\"\n\nadb shell am start -a android.intent.action.VIEW -n com.thredup.android/com.thredup.android.feature.splash.SplashActivity -d \"https://www.example.com/account/delete_password\"\n```\n\n- 지금 CSRF로 만들어 봐요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```javascript\n<!DOCTYPE html>\n<html>\n<a href=\"https://www.example.com/account/change_password\">CSRF DEMO</a>\n</html>\n```\n\n# Proof of Concept\n","ogImage":{"url":"/assets/img/2024-05-23-CSRFLeadstoDeleteAccount_0.png"},"coverImage":"/assets/img/2024-05-23-CSRFLeadstoDeleteAccount_0.png","tag":["Tech"],"readingTime":3},{"title":"Android Kotlin 개발자를 위한 Swift 참고 자료","description":"","date":"2024-05-23 14:45","slug":"2024-05-23-SwiftCheatsheetforAndroidKotlinDevelopers","content":"\n안녕하세요! 안드로이드 개발자들은 대부분 Kotlin으로 작업합니다. 그러나 iOS에서 어떤 기능이 구현되는 방법을 참조할 때 Swift를 읽고 이해하는 것도 도움이 될 수 있습니다. 또한 Kotlin Multiplatform을 탐색하는 경우에도 유용합니다.\n\niOS 개발자도 Android 코드를 살펴볼 때 이와 같은 원리가 적용됩니다. Kotlin을 읽고 이해하는 방법을 알면 보다 쉬워집니다.\n\n우리는 iOS 코드를 살펴볼 때 볼 수 있는 몇 가지 일반적인 Swift 패턴에 대해 다루고, 이해하려고 노력하고 Kotlin에서의 구현과 비교해 볼 것입니다.\n\n<img src=\"/assets/img/2024-05-23-SwiftCheatsheetforAndroidKotlinDevelopers_0.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 1. 기본 사항\n\n## 변수\n\nSwift에서 변수와 상수는 각각 var 및 let 키워드를 사용하여 정의됩니다. 세미콜론을 사용하여 유형 주석을 제공할 수 있지만 필수는 아닙니다.\n\n```js\n// Swift\nlet animDurationMillis: Int = 500\nvar clickCount = 0\n\n// Kotlin\nval animDurationMillis: Int = 500\nvar clickCount = 0\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n현재 시점에서 두 언어의 유일한 차이점은 읽기 전용 변수를 정의하는 let 대 val 키워드입니다.\n\n## 옵셔널 / 널 가능성\n\n옵셔널이나 널 가능한 유형의 경우, 두 언어 모두 같은 ? 문자를 사용하지만, 값이 없는 상태에 대해서는 nil 대 null이 유일한 차이점입니다.\n\n```swift\n// Swift\nvar foundItem: String? = nil\n\n// Kotlin\nvar foundItem: String? = null\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nnil 상태를 처리하는 여러 가지 방법이 있습니다:\n\n- 값 확인을 위해 if 표현식을 사용하는 방법 (이 내용은 뒤에서 다룹니다),\n- 옵셔널 바인딩을 사용하는 방법 (이 내용은 뒤에서 다룹니다),\n- 대체/기본값을 제공하는 방법,\n- 강제 언래핑을 하는 방법.\n\n마지막 두 가지 접근법의 예시가 여기 있습니다. 코틀린이 거의 동일한 방식을 제공한다는 것을 알 수 있습니다. 문법에 약간의 차이가 있습니다 (?? vs ?: 및 ! vs !!).\n\n```js\n// Swift\n//  - 대체/기본값\nlet actualFoundItem = foundItem ?? \"empty\"\n//  - 강제 언래핑\nlet actualFoundItem = foundItem!\n\n// Kotlin\n//  - 대체/기본값\nval actualFoundItem = foundItem ?: \"empty\"\n//  - 강제 언래핑\nval actualFoundItem2 = foundItem!!\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 제어 흐름\n\nif 문은 Kotlin과 거의 동일한데, Swift에서는 괄호를 생략할 수 있다는 작은 차이가 있습니다.\n\n```js\n// Swift\nif foundItem != nil {\n  // 무언가를 수행\n}\n\n// Kotlin\nif (foundItem != null) {\n  // 무언가를 수행\n}\n```\n\n두 언어 모두 else if/else 분기에 대해 동일한 구문을 사용하며, 두 언어 모두 표현식으로 사용할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n// 스위프트\nlet description = if delta <= 10 {\n  \"low\"\n} else if delta >= 50 {\n  \"high\"\n} else {\n  \"medium\"\n}\n\n// 코틀린\nval description = if (delta <= 10) {\n    \"low\"\n} else if (delta >= 50) {\n    \"high\"\n} else {\n    \"medium\"\n}\n```\n\n## Functions\n\nSwift에서 함수는 func 키워드로 선언되며, 함수 이름, 입력 매개변수 및 반환 유형이 이어집니다.\n\n```js\nfunc addTwoNumbers(a: Int, b: Int) -> Int {\n    return a + b\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n코틀린에서는 fun 키워드와 :을 사용하여 반환 유형을 정의합니다. -` 대신에 Markdown 형식으로 표를 변경해주세요.\n\n```kotlin\nfun addTwoNumbers(a: Int, b: Int): Int {\n    return a + b\n}\n```\n\n# 2. 구조체 및 클래스\n\nSwift는 데이터 모델링 관점에서 비슷한 구조체와 클래스를 지원합니다. 둘 다 속성과 함수를 정의할 수 있지만, 클래스는 참조에 의해 전달되고 구조체는 값에 의해 전달됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n기본적으로 구조체를 사용하는 것이 권장됩니다. 상속, Objective-C 호환성 등 추가 기능이 필요할 때는 클래스를 사용하세요.\n\n```js\nstruct VehicleStructure {\n    var maxSpeed = 0\n\n    func printInfo() {\n        print(\"최대 속도 \\(maxSpeed)\")\n    }\n}\n\nclass VehicleClass {\n    var maxSpeed = 0\n\n    func printInfo() {\n        print(\"최대 속도 \\(maxSpeed)\")\n    }\n}\n```\n\n인스턴스를 생성하려면 구조체나 클래스 이름 뒤에 빈 괄호를 사용합니다.\n\n구조체는 기본적으로 변경 불가능하므로 속성의 값 변경이 필요한 경우 let 대신 var로 선언해야 합니다. 멤버 속성의 값을 설정하기 위해 자동으로 생성된 이니셜라이저를 사용할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n// 변경 가능한 구조체 인스턴스 생성\nvar car = VehicleStructure()\ncar.maxSpeed = 250\ncar.printInfo()\n\n// 변경 불가능한 구조체 인스턴스 생성\nlet carSimple = VehicleStructure(maxSpeed: 200)\ncarSimple.printInfo()\n\n// 클래스 인스턴스 생성\nlet bike = VehicleClass()\nbike.maxSpeed = 50\nbike.printInfo()\n```\n\n## Kotlin\n\nKotlin에서의 주요 구성 요소는 클래스입니다. 그 선언과 사용법은 Swift와 거의 동일합니다.\n\n```js\nclass Vehicle {\n    var maxSpeed = 0\n\n    fun printInfo(){\n        println(\"최대 속도는 $maxSpeed입니다.\")\n    }\n}\n\n// 클래스 인스턴스 생성\nval vehicle = Vehicle()\nvehicle.maxSpeed = 250\nvehicle.printInfo()\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nKotlin은 클래스 생성 시 모든 클래스 속성에 값을 제공해야하는 클래스 생성자도 지원합니다.\n\n```kotlin\nclass Vehicle(var maxSpeed: Int) {\n\n    fun printInfo(){\n        println(\"최대 속도는 $maxSpeed 입니다.\")\n    }\n}\n\nval vehicle = Vehicle(250)\n```\n\nKotlin은 추상 클래스, 데이터 클래스, 인터페이스 및 실드 클래스 및 인터페이스와 같은 다른 관련 구조를 지원합니다. 더 많은 내용은 https://kotlinlang.org/docs/classes.html에서 확인할 수 있습니다.\n\n# 3. Optional Binding\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## if let 사용법\n\nSwift 코드베이스에서 자주 볼 수 있는 패턴 중 하나는 다음과 같습니다:\n\n```js\nlet fetchedUserId: String? = \"Optional id of the fetched user\"\nif let userId = fetchedUserId {\n    // userId를 선택적인(non-optional) 상수로 사용할 수 있습니다.\n    print(userId)\n} else {\n    // fetchedUserId가 nil/null인 경우\n    throw Error(\"Missing user id\")\n}\n\n// fetchedUserId와 userId를 if 문 바깥에서 사용할 수 있습니다.\n// 그러나 둘 다 여전히 옵셔널이므로 unwrapping이 필요합니다.\n```\n\n이를 선택적 바인딩(optional binding)이라고 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 선택적으로 검색된 fetchedUserId 변수가 nil이 아닌 값으로 존재하는지 확인합니다.\n- true이면 새로운 선택 불가능한 상수인 userId에 값을 할당합니다.\n- 새로운 상수 userId는 코드 블록 내에서 참조할 수 있습니다.\n- fetchedUserId가 nil이라면 else 블록을 실행합니다.\n\n기존 변수 이름을 사용하여 더욱 간단하게 코드를 작성할 수 있습니다:\n\n```js\nlet fetchedUserId: String? = \"검색된 사용자의 선택 사항 ID\"\nif let fetchedUserId {\n    // fetchedUserId를 선택 불가능한 상수로 사용할 수 있습니다.\n    print(fetchedUserId)\n}\n```\n\n두 경우 모두 fetchedUserId와 userId 상수를 if 문 바깥에서 사용할 수 있지만, 두 상수 모두 여전히 선택적으로 간주되기 때문에 추가로 언래핑이 필요합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n코틀린\n코틀린에는 이에 해당하는 특수한 패턴이 없습니다. 하나의 옵션은 if/else 문을 사용하는 것입니다. 그러나 이는 로컬 변수에 대해서만 작동하며 전역 변수에는 작동하지 않습니다. 전역 변수를 지원하려면 먼저 값을 새로운 로컬 변수/상수에 할당해야 합니다.\n\n```js\n// 글로벌 클래스 속성\nvar fetchedUserId: String? = \"피치된 사용자의 선택 가능한 ID\"\n\nval userId = fetchedUserId\nif (userId != null) {\n  // userId는 선택 사항 없이 사용할 수 있습니다\n} else {\n  throw Exception(\"사용자 ID가 누락되었습니다\")\n}\n\n// userId는 선택 사항 없이 어디서든 사용할 수 있습니다\n```\n\n위의 경우에는 if 문 이후에도 userId 상수를 선택 사항 없이 참조할 수 있으며, 이는 옵셔널 바인딩 패턴을 사용한 스위프트에서는 지원되지 않습니다.\n\n대안적인 해결책은 `.let`과 같은 스코프 함수를 사용하는 것입니다. 함수 내부의 코드는 fetchedUserId가 null이 아닌 경우에만 실행됩니다. 이 코드 블록 이후에 fetchedUserId에 대한 참조는 여전히 변수가 선택 사항으로 간주되므로 널 안전성이 필요합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\nfetchedUserId?.let { userId ->\n  // userId가 옵셔널이 아닌 것으로 사용할 수 있습니다\n} ?: throw Exception(\"사용자 ID가 누락되었습니다\")\n```\n\n## 보호자\n\n또 다른 일반적인 패턴은 가드문입니다. 이는 if let 패턴과 유사합니다. 주로 함수 내에서 조기에 종료할 때 사용됩니다. 다른 점은 else 블록이 필수적이라는 것입니다.\n\n```swift\nfunc checkUsernameValid(username: String?) -> Bool {\n    guard let username else {\n        // username이 nil이므로 평가할 수 없습니다\n        return false\n    }\n    // username을 옵셔널이 아닌 것으로 사용할 수 있습니다\n    return username.count > 3\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 코드에서 함수는 선택적으로 변수 username을 받습니다. 그런 다음 guard문을 사용하여 username이 값이 있는지 확인합니다. 값이 없는 경우 함수를 종료합니다. 값이 있는 경우 나머지 함수에서는 username을 선택사항이 아닌 것처럼 사용할 수 있습니다.\n\nKotlin\nKotlin에서는 몇 가지 다른 방법으로 이를 작성할 수 있습니다. 두 가지 제안을 보여드리겠습니다:\n\n```js\nfun checkUsernameValid(username: String?): Boolean {\n    if (username.isNullOrEmpty()){\n        return false\n    }\n    return username.length > 3\n}\n\n// 또는\n\nfun checkUsernameValid(username: String?): Boolean {\n    val actualUsername = username ?: return false\n    return actualUsername.length > 3\n}\n```\n\n# 4. Enums\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nSwift에서는 enum 키워드를 사용하여 열거형을 정의합니다. 값은 case 키워드를 사용하고 그 뒤에 열거형 케이스의 이름을 작성합니다. 열거형 케이스의 이름은 소문자로 작성하는 것이 권장되며 단수형으로 작성하는 것이 좋습니다. 각 케이스를 새로운 줄에 작성해야 합니다. 여러 케이스를 한 줄에 작성할 때는 쉼표로 구분합니다.\n\n```js\nenum Direction {\n    case left\n    case up\n    case right\n    case down\n}\n\n// 또는\n\nenum Direction {\n    case left, up, right, down\n}\n```\n\nenum 케이스를 사용하려면 유형(Direction)과 사용하려는 케이스를 참조합니다. 나중에 유형을 생략하고 더 짧은 점 구문을 사용하여 케이스를 직접 참조할 수 있습니다.\n\n```js\nvar selectedDirection = Direction.up\nselectedDirection = .right\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n열거형 값 확인을 위해 switch 문을 사용할 수 있습니다. Xcode는 switch 문의 모든 분기를 자동으로 작성합니다. 열거형에 대한 switch 문이 전체적이어야 하기 때문입니다.\n\n```js\nswitch(selectedDirection){\ncase .left:\n    goLeft()\ncase .up:\n    goForward()\ncase .right:\n    goRight()\ncase .down:\n    goBackward()\n}\n```\n\nSwift 열거형은 연관 값도 지원합니다. 즉, 각 열거형 케이스마다 다른 수의 값 유형을 가질 수 있습니다. 이는 Kotlin의 sealed class와 유사한 강력한 도메인 모델링 도구 역할을 합니다.\n\n더 알아보기: https://docs.swift.org/swift-book/documentation/the-swift-programming-language/enumerations\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 코틀린\n\n코틀린에서는 enum 클래스 키워드를 사용하여 Enum을 정의합니다. 값은 쉼표로 구분하여 정의합니다. Enum 값 이름은 일반적으로 대문자로 작성하는 것이 관례이지만, 프로젝트의 스타일에 따라 다를 수 있습니다.\n\n```js\nenum class Direction {\n    LEFT, UP, RIGHT, DOWN\n}\n```\n\nEnum을 사용할 때는 클래스 이름과 사용하려는 값으로 참조합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nvar selectedDirection = Direction.UP;\n```\n\n우리는 값 확인을 위해 when 문을 사용할 수 있습니다. 가능한 모든 열거형 값을 포함해야합니다.\n\n```js\nwhen(selectedDirection){\n    Direction.LEFT -> goLeft()\n    Direction.UP -> goForward()\n    Direction.RIGHT -> goRight()\n    Direction.DOWN -> goBackward()\n}\n```\n\nKotlin 열거형 클래스는 각 열거형 값이 값을 제공해야하는 추가 속성을 정의하는 것을 지원합니다. 그러나 Swift의 관련 값과 달리 속성은 클래스 수준에 있으며 값 레벨이 아니므로 각 값에 대해 동일한 형식이어야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 Kotlin 공식 문서 링크입니다: https://kotlinlang.org/docs/enum-classes.html\n\n# 5. 사전 / 맵\n\nSwift의 딕셔너리와 Kotlin의 맵 사이의 구문은 매우 다르지만 비슷한 기본 개념을 사용합니다.\n\n## Kotlin\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n딕셔너리는 키와 값을 동일한 유형으로 연결해주는 Swift의 데이터 구조입니다. 키-값 쌍은 순서가 없이 저장됩니다. 각 키는 연결된 값을 액세스하기 위한 기준값을 나타냅니다.\n\n딕셔너리를 선언하려면 키-값 쌍을 [Key: Value] 형식으로 대괄호 안에 쉼표로 구분하여 정의합니다. 최소 하나의 키-값 쌍을 정의하면 형식 선언을 생략할 수 있어 컴파일러가 유형을 결정할 수 있습니다.\n\n```js\nvar httpErrorCodes: [Int: String] = [404: \"Not found\", 401: \"Unauthorized\"]\n```\n\n키를 사용하여 딕셔너리에서 값을 읽기 위해 서브스크립트 구문(dictionary[key])을 사용할 수 있습니다. 딕셔너리에 키가 없으면 nil을 반환합니다. ?? 연산자를 사용하여 기본값을 제공할 수도 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nfunc getHttpErrorCodeMessage(code: Int) -> String {\n    let errorCodeMessage = httpErrorCodes[code] ?? \"Unknown\"\n    return \"Http error code \\(errorCodeMessage)\"\n}\n```\n\n딕셔너리에 새로운 값을 쓰려면 키에 값을 할당합니다. 키가 존재하지 않으면 새로운 키-값 쌍을 컬렉션에 추가합니다. 키가 이미 존재하면 값을 업데이트합니다.\n\n```js\n// 새로운 키:값 쌍 추가\nhttpErrorCodes[500] = \"Internal Server Error\";\n\n// 기존 키의 값 업데이트\nhttpErrorCodes[401] = \"Requires authentication\";\n```\n\n가변 또는 불변(읽기 전용) 딕셔너리를 사용하는지는 할당에 달려있습니다. let을 사용하면 선언한 후에만 읽을 수 있는 딕셔너리를 정의합니다. 쓰기를 지원하려면 var로 선언해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n자세히 읽기: https://docs.swift.org/swift-book/documentation/the-swift-programming-language/collectiontypes#Dictionaries\n\n## Kotlin\n\n맵은 고유한 키와 값의 쌍을 보유하고 각 키에 해당하는 값을 효율적으로 가져오는 컬렉션입니다.\n\nKotlin에서 불변(읽기 전용) 맵을 선언하려면 Map`KeyType, ValueType` 유형을 사용하고 mapOf(varargs pairs: Pair`KeyType, ValueType`) 표준 라이브러리 함수를 사용하여 초기화합니다. 적어도 하나의 키-값 쌍을 제공하면 명시적인 변수 유형 선언을 생략할 수 있습니다. 컴파일러가 유형을 결정할 수 있기 때문입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n값을 선언할 때 Pair(key, value) 클래스를 직접 사용하거나 객체를 만들어주는 to 인픽스 함수를 사용할 수 있습니다.\n\n```kotlin\nval httpErrorCodes: Map<Int, String> = mapOf(\n    404 to \"찾을 수 없음\",\n    Pair(401, \"권한이 없음\"),\n)\n```\n\n키를 사용하여 맵에서 값을 읽을 때 대괄호 표기법(map[key])을 사용할 수 있습니다. 키가 맵에 존재하지 않으면 null이 반환됩니다. ?: 연산자를 사용하여 기본값을 제공할 수 있습니다.\n\n```kotlin\nfun getHttpErrorCodeMessage(code: Int): String {\n    val errorCodeMessage = httpErrorCodes[code] ?: \"알 수 없음\"\n    return \"Http 오류 코드: $errorCodeMessage\"\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n맵에 새로운 값을 작성하려면 MutableMap KeyType, ValueType 형식과 mutableMapOf() 팩토리 함수를 사용하여 가변 맵을 선언해야 합니다. 그런 다음 키에 값을 할당합니다. 키가 존재하지 않으면 새로운 키-값 쌍이 컬렉션에 추가됩니다. 키가 이미 존재하면 해당 값을 업데이트합니다.\n\n```js\n// 새 키:값 쌍 추가\nhttpErrorCodes[500] = \"내부 서버 오류\";\n\n// 기존 키에 대한 값 업데이트\nhttpErrorCodes[401] = \"인증이 필요함\";\n```\n\n더 읽어보기: https://www.baeldung.com/kotlin/maps\n\n# 6. 확장\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n확장(extension)은 기존 클래스나 구조체에 새로운 기능을 추가하는 방법입니다. 때로는 코드에 액세스할 수 없는 것들에 대해서도 확장을 적용할 수 있습니다.\n\nSwift에서는 extension 키워드를 사용하여 확장을 정의할 수 있습니다. 확장은 다른 클래스나 구조체 외부의 최상위 레벨에서 선언되어야 합니다.\n\n```js\nextension String {\n    func doubled() -> String {\n        return self + self\n    }\n}\n```\n\n위 예제에서는 String 타입에 doubled() 확장 함수를 정의했습니다. 이제 이 함수를 문자열의 인스턴스에서 호출할 수 있으며 마치 원래 정의에 포함된 것처럼 사용할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nlet originalStr = \"Swift\";\nlet doubledStr = originalStr.doubled();\nprint(doubledStr); // prints \"SwiftSwift\"\n```\n\n## Kotlin\n\nKotlin은 동일한 방식으로 작동하는 확장 함수를 사용하며 기존 클래스에 새 기능을 추가할 수 있습니다. 우리는 확장하려는 클래스 이름과 함께 점과 함수 이름이 이어지는 최상위 함수로 정의합니다.\n\n```js\nfun String.doubled(): String {\n    return this + this\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 이 함수를 사용하여 원래 정의의 일부인 문자열 인스턴스에서 호출할 수 있습니다.\n\n```js\nval originalStr = \"Kotlin\"\nval doubledStr = originalStr.doubled()\nprintln(doubledStr) // \"KotlinKotlin\" 출력\n```\n\n# 7. 프로토콜\n\nSwift에서 프로토콜은 클래스, 구조체 또는 열거형이 해당 요구 사항의 실제 구현을 제공함으로써 채택할 수 있는 속성, 메서드 및 기타 요구 사항의 집합입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n프로토콜을 정의할 때는 프로토콜 키워드 뒤에 프로토콜 이름을 붙이면 됩니다. 이는 구조체나 클래스 선언과 유사합니다. 프로토콜 내부에서는 get할 수 있는(' get ') 또는 get과 set이 모두 가능한(' get set ') 속성을 정의할 수 있습니다.\n\n```js\nprotocol RequestError {\n    var errorCode: Int { get }\n    var isRecoverable: Bool { get set }\n}\n\nprotocol PrintableError {\n    func buildErrorMessage() -> String\n}\n```\n\n위 예시에서는 RequestError라는 프로토콜을 정의했는데, 이 프로토콜에는 errorCode라는 get할 수 있는 속성과 isRecoverable이라는 set이 가능한 속성이 포함되어 있습니다. 또한, adopter가 구현해야 하는 buildErrorMessage() 함수를 포함하는 PrintableError라는 프로토콜도 정의했습니다.\n\n프로토콜을 채택하기 위해서는 클래스나 구조체를 정의하고 이름 뒤에 : ProtocolName을 추가해야 합니다. 여러 프로토콜을 선언하려면 쉼표를 사용하면 됩니다. 그런 다음 클래스나 구조체의 본문에서 프로토콜로부터 요구되는 내용을 정의해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nclass ServerHttpError: RequestError, PrintableError {\n    var errorCode: Int = 500\n    var isRecoverable: Bool = false\n\n    func buildErrorMessage() -> String {\n        return \"Server side http error with error code \\(errorCode)\"\n    }\n}\n\nstruct ConnectionError: RequestError, PrintableError {\n    var errorCode: Int\n    var isRecoverable: Bool\n\n    func buildErrorMessage() -> String {\n        return \"Local connection error\"\n    }\n}\n```\n\n우리는 RequestError와 PrintableError 프로토콜을 채택하는 ServerHttpError 클래스를 정의했고, 두 속성의 기본값과 함수의 구현을 정의했습니다. 또한 두 속성을 선언하고 함수의 구현을 제공하는 ConnectionError 구조체를 가지고 있습니다.\n\n이제 ServerHttpError 및 ConnectionError의 인스턴스를 생성하고 이들을 RequestError 또는 PrintableError 유형으로 전달할 수 있습니다. RequestError 유형을 수락하는 onRequestError() 함수에서 error가 PrintableError 프로토콜을 준수하는지 확인하여 오류 메시지를 구성합니다.\n\n```js\nfunc onRequestError(error: RequestError) {\n    if let printableError = error as? PrintableError {\n        print(printableError.buildErrorMessage())\n    }\n    print(\"Is recoverable: \\(error.isRecoverable)\")\n}\n\nlet firstError = ServerHttpError()\nfirstError.errorCode = 503\nfirstError.isRecoverable = false\n\nlet secondError = ConnectionError(errorCode: 404, isRecoverable: true)\n\n// \"Server side http error with error code 503. Is recoverable: false\"\nonRequestError(error: firstError)\n// \"Local connection error. Is recoverable: true\"\nonRequestError(error: secondError)\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이것은 프로토콜을 사용하는 간단한 예시입니다. Swift의 프로토콜은 상속, 합성, 연관 타입, 제네릭 등과 같이 더 고급적인 사용 사례를 지원합니다. 더 많은 내용은 https://docs.swift.org/swift-book/documentation/the-swift-programming-language/protocols에서 확인할 수 있어요.\n\n## Kotlin\n\n위의 예시는 인터페이스, 추상 클래스, sealed 클래스 등을 사용하여 Kotlin으로 여러 방법으로 작성할 수 있습니다. 그러나 Swift의 프로토콜을 가장 가깝게 표현하는 것은 아마도 인터페이스일 것입니다. 이는 속성과 함수를 정의하며, 상속, 구성, 그리고 제네릭을 지원합니다.\n\n인터페이스를 정의할 때는 interface 키워드를 사용하고 이름을 이어서 작성합니다. 본문에서는 속성과 함수를 정의합니다. 읽기 전용 속성은 val 키워드를 사용하여 정의하고, 읽기/쓰기 속성은 var 키워드를 사용합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 인터페이스를 구현하도록 클래스에 지정하는 방법은, 클래스 이름 뒤에 InterfaceName을 사용합니다. 여러 인터페이스를 구현하려면 쉼표를 사용합니다. 그런 다음 모든 속성과 함수를 override 키워드와 함께 정의해야 합니다.\n\n```js\ninterface RequestError {\n    val errorCode: Int\n    var isRecoverable: Boolean\n}\n\ninterface PrintableError {\n    fun buildErrorMessage(): String\n}\n\nclass ServerHttpError(\n    override val errorCode: Int,\n    override var isRecoverable: Boolean\n) : RequestError, PrintableError {\n    override fun buildErrorMessage(): String {\n        return \"Server side http error with error code $errorCode\"\n    }\n}\n\nclass ConnectionError : RequestError, PrintableError {\n    override val errorCode: Int\n        get() = 404\n    override var isRecoverable: Boolean = true\n\n    override fun buildErrorMessage(): String {\n        return \"Local connection error\"\n    }\n}\n```\n\n이제 ServerHttpError 및 ConnectionError의 인스턴스를 생성하고, 함수에 RequestError 유형으로 전달할 수 있습니다.\n\n```js\nfun onRequestError(error: RequestError) {\n    if (error is PrintableError) {\n        println(error.buildErrorMessage())\n    }\n    println(\"$errorMessage. Is recoverable: ${error.isRecoverable}\")\n}\n\nval firstError = ServerHttpError(errorCode = 503, isRecoverable = false)\nval secondError = ConnectionError()\n// \"Server side http error with error code 503. Is recoverable: false\"\nonRequestError(firstError)\n// \"Local connection error. Is recoverable: true\"\nonRequestError(secondError)\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nRead more at https://kotlinlang.org/docs/interfaces.html\n\n# 결론\n\n일반적인 Swift 패턴을 이해하고 Kotlin에서 어떻게 번역되는지 알면 코드가 하는 일을 더 잘 이해할 수 있습니다. 이웃 플랫폼에서 어떤 기능이 구현되었는지 보거나 코드 검토를 수행하거나 기술 사양/제안서를 검토하거나 작업을 Kotlin Multiplatform으로 수행하는 여러 방법이 있습니다.\n\nSwift 언어의 기본적인 내용과 Kotlin과 비교하는 방법을 살펴보았습니다. 또한, 선택적 바인딩, 딕셔너리, 익스텐션, 구조 및 프로토콜과 같은 전형적인 iOS 프로젝트에서 발견할 수 있는 일반적인 패턴에 대해서도 다루었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 문이 도움이 되었다면 댓글로 알려주세요! Swift 코드를 읽거나 검토하거나 작성하는 경험에 대해 공유하는 것을 장려합니다.\n\n참고 자료:\n\n- https://kotlinlang.org/docs/home.html\n- https://docs.swift.org/swift-book/documentation/the-swift-programming-language/thebasics\n\nAndrej Rolih 님의 검토와 피드백에 감사드립니다.\n","ogImage":{"url":"/assets/img/2024-05-23-SwiftCheatsheetforAndroidKotlinDevelopers_0.png"},"coverImage":"/assets/img/2024-05-23-SwiftCheatsheetforAndroidKotlinDevelopers_0.png","tag":["Tech"],"readingTime":25},{"title":"깔끔한 아키텍처 사용 사례의 복잡성","description":"","date":"2024-05-23 14:42","slug":"2024-05-23-TheComplexitiesofCleanArchitectureUseCases","content":"\nClean Architecture는 따라야 할 규칙이 있는데, 엄격히 준수한다고 해서 문제가 발생할 수 있습니다. 이 글에서는 정확히 이러한 규칙을 엄격히 준수할 때 발생할 수 있는 몇 가지 문제점, 특히 유스케이스와 단일 책임 원칙 (SRP)에 초점을 맞춰 구체적으로 논의하겠습니다.\n이 글은 Clean Architecture와 해당 용어에 이미 익숙한 사람들을 대상으로 합니다.\n\nClean Architecture의 주요 기반 중 하나는 레이어링입니다. 핵심 아이디어는 소프트웨어를 특정 책임을 갖는 구분된 레이어로 분리하여, 의존성이 하나의 방향으로 흐르도록 하는 것입니다: 외부 레이어에서 내부 레이어로.\n\n![이미지](/assets/img/2024-05-23-TheComplexitiesofCleanArchitectureUseCases_0.png)\n\nClean Architecture의 규칙 중 하나는 의존성 원칙인데, 이것은 소스 코드 의존성이 내부로만 향한다는 것을 말합니다. 즉, 데이터 레이어에서 뭔가를 얻거나 수행하려면 항상 중간에 프록시 역할을 하는 것을 생성해야 하며, 일반적으로 그것이 유스케이스입니다. 유스케이스는 시스템이 수행해야 하는 단일 재사용 가능한 작업에 대한 비즈니스 로직을 캡슐화합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n한 줄로 된 UseCase\n\n비즈니스 규칙이 'UI에 데이터를 표시해야 한다'는 규칙 외에는 어떤 비즈니스 규칙도 없더라도, 종속성 규칙을 따르면 데이터 레이어에서 데이터를 가져오는 UseCase를 만들어야 합니다.\n\n```kotlin\nclass GetUserUseCase(\n   private val userRepository: UserRepository\n) {\n\n operator fun invoke(userConfig: UserConfig): Result<User> {\n   return userRepository.getUser()\n }\n}\n```\n\nGetUserUseCase에는 규칙이 없고 다른 레이어로의 프록시 역할만 수행합니다. 어떻게 하면 추가적인 로직 없이 모든 사용자에 대한 CRUD를 갖을 수 있을까요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\nclass GetUserUseCase(\n   private val userRepository: UserRepository\n) {\n\n operator fun invoke(userConfig: UserConfig): Result<User> {\n   return userRepository.getUser()\n }\n\n}\n\nclass AddUserUseCase(\n   private val userRepository: UserRepository\n) {\n\n operator fun invoke(user: User) {\n   return userRepository.addUser(user)\n }\n\n}\n\nclass DeleteUserUseCase(\n   private val userRepository: UserRepository\n) {\n\n operator fun invoke(user: User) {\n   return userRepository.deleteUser(user)\n }\n\n}\n\nclass UpdateUserUseCase(\n   private val userRepository: UserRepository\n) {\n\n operator fun invoke(user: User) {\n    return userRepository.updateUser(user)\n }\n\n}\n```\n\n한 줄짜리 use case 수는 기하급수적으로 늘어날 수 있습니다. 하나의 데이터 유형에 대해 여러 개의 use case를 생성할 수 있습니다. 실제 세계에서의 상황은 더 나빠질 수도 있습니다. GetAllUsersUseCase, GetOldUserCase 등과 같은 UseCases를 가질 수 있습니다.\n\n이 use cases는 데이터 계층에 대한 프록시 역할을 하는 것 외에 아무것도 하지 않습니다. Clean Architecture의 일부 구현에서는 모델 간의 변환을 수행하는 매퍼도 존재할 수 있으며, 이는 상황을 더 악화시킵니다. 비즈니스 규칙을 행동으로 전환하지 않습니다. 어떤 문제도 해결하지 않고, 단지 Clean Architecture의 규칙을 만족시키기 위해 추가 코드를 작성합니다.\n\n조금 생각해 봅시다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n시간이 흘러감에 따라 '한 줄짜리 사용 사례'의 기여로 인해 사용 사례의 수가 너무 많아질 수 있습니다. 프로젝트에는 50, 100, 200, 500개 이상의 사용 사례가 쌓일 수 있습니다. 이 많은 수의 사용 사례는 문제를 야기할 수 있습니다.\n\n예를 들어, 새로운 화면을 작업 중이고 이미 애플리케이션에서 사용되는 데이터를 표시해야 한다고 상상해보세요. 이미 작성된 사용 사례, 저장소 등이 해당 데이터 유형과 작업하는데 사용됩니다. 그런데 이 수백 개의 사용 사례 중에서 재사용할 수 있는 것을 찾아야 합니다. 이 작업은 프로젝트 내의 다양한 요소에 따라 쉬울 수도 있고 어려울 수도 있습니다.\n\n명명 규칙이 엄격합니까? 그렇다면 사용 사례의 이름은 \"GetMyDataType\"와 같이 시작할 수 있고 이를 통해 이름으로 검색을 시작할 수 있습니다. 그러나 명명은 어렵고 엄격한 규칙이 있더라도 의도를 정확하게 나타내지 못할 수 있습니다.\n\n다중 저장소 아키텍처를 사용합니까? 이는 각 팀이 자체 저장소를 사용하여 다른 별도 프로젝트에서 작업하고, 이러한 모든 프로젝트가 라이브러리 형식으로 주 애플리케이션에 포함되는 구조를 말합니다. 이러한 경우 필요한 사용 사례가 다른 저장소에 있을 수 있으며 이를 찾고 재사용하는 것이 더 어려울 수 있습니다. 기본적으로 사용 사례를 찾기 위해 다양한 프로젝트를 검색해야 하며, 아마도 사용할 수 없을 것입니다. 사용 사례가 캡슐화되어 있을 수 있기 때문입니다. 만약 캡슐화되어 있지 않더라도 다른 팀이 변경을 가할 경우 코드가 깨질 수 있으므로 캡슐화돼 있어야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n[기능 모듈화](https://developer.android.com/topic/modularization)와 관련된 내용입니다. 기능의 코드 변경이 다른 기능 또는 애플리케이션에 영향을 미치지 않아야 합니다. 기능 모듈의 고유성(cohesion)을 높이고 싶다면, 내부(modifier)로 접근 가능하도록 하여 재사용성을 의도적으로 줄일 수 있습니다.\n\n의존성 규칙을 엄격히 준수하며 use case를 작성하는 주요 이유는 다음과 같습니다: \"언제나 use case를 사용하여 코드를 앞으로의 변경으로부터 보호하게 됩니다. 예를 들어, 지불 전송에 추가 단계가 필요한 경우 새로운 use case를 생성하고 해당 repository 기능을 사용하던 모든 ViewModel을 use case로 대체해야 합니다.\" 그러나 실제로는 어떤가요?\n\n예제를 살펴보겠습니다. 은행 앱에서 신용 카드 목록을 제공하는 use case가 있다고 가정해봅시다.\n\n```js\nclass GetCreditCartsUseCase(\n    private val creditCardRepository: CreditCardRepository\n) {\n\n operator fun invoke(): Result<List<CreditCard>> {\n    return creditCardRepository.getCreditCards()\n }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그리고 앱 전체에 이 데이터를 여러 곳에 표시해야 합니다.\n\n![이미지](/assets/img/2024-05-23-TheComplexitiesofCleanArchitectureUseCases_1.png)\n\n요구 사항이 변경되었을 때 어려움이 생길 수 있는 날이 왔습니다. 변경 사항이 다른 곳에 적용되지 않을까 걱정할 필요 없이 유스케이스를 변경할 수 있습니다. 따라서 한 곳에서만 변경하고, 한 클래스에 대한 새로운 유닛 테스트를 추가하면 됩니다.\n\n하지만 문제가 있습니다: 요구 사항이 한 화면에 대해서만 변경되었습니다. 개요 화면에서는 가장 최근에 획득한 신용카드 하나만 보여주어야 합니다. 이제 기존 유스케이스를 재사용하는 대신 새로운 유스케이스를 만들고 영향을 받는 viewModel을 수정해야 합니다. 제 경험 상, 대부분의 경우 요구 사항과 유스케이스가 이렇게 되는 것입니다. (미래를 예측할 수 있는 경우를 제외하고는, 무엇을, 어디를 재사용할 수 있는지 알 수 없습니다)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-05-23-TheComplexitiesofCleanArchitectureUseCases_2.png\" />\n\n이제 UseCase의 비즈니스 요구 사항에 대해 생각해 봅시다. 우리는 신용 카드 목록을 가져와 UI에 표시해야 합니다. 사용된 모든 곳에 영향을 미치는 추가 로직이 있을 가능성은 어떤지요? 저는 \"잘 없을 것\"이라고 생각합니다. 현재 작업 중인 앱에 대해 생각해보면 이러한 요구 사항의 본질 때문에 결코 변경될 수 없는 많은 유스케이스를 찾을 수 있다고 확신합니다.\n\n큰 프로젝트에서 발생할 수 있는 또 다른 문제는 생성자 과다 주입입니다:\n\n```js\nclass UserSettingsViewModel(\n   private val getUserUserCase: GetUserUserCase,\n   private val getAllUsersUseCase: GetAllUsersUseCase,\n   private val addUserUseCase: AddUserUseCase,\n   private val deleteUserUseCase: DeleteUserUseCase,\n   private val updateUserUseCase: UpdateUserUseCase,\n   private val getPremiumUsersUseCase: GetPremiumUsersUseCase,\n   private val getFiltersUseCase: GetFiltersUseCase,\n   private val getAppSettingsUseCase: GetAppSettingsUseCase,\n   private val selectUserUseCase: SelectUserUseCase,\n   private val selectFilterUseCase: SelectFilterUseCase,\n   private val updateAppSettingsUseCase: UpdateAppSettingsUseCase\n   //…이하 생략…\n)\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n익숙한 것 같나요? 댓글 달 건 없어요. (하지만, 공정하게 말하자면, 생성자에 10-20-40개 이상의 인수가 허용되는 경우에는 문제가 되지 않아요).\n\n그럼, 이에 대해 어떻게 처리할까요?\n\n데이터 레이어를 직접 사용하세요.\nGoogle에서 권장하는 방법입니다:\nhttps://developer.android.com/topic/architecture/domain-layer#data-access-restriction\n\n\"하지만, 잠재적으로 상당한 단점은 데이터 레이어에 대한 간단한 함수 호출일 때에도 유즈 케이스를 추가해야 하므로, 작은 혜택을 위해 복잡성을 추가할 수 있다는 것입니다.\"\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n좋은 방법은 필요한 경우에만 사용 사례를 추가하는 것입니다. UI 레이어가 대부분의 경우 사용 사례를 통해 데이터에 액세스하는 것을 발견하면 데이터에 이렇게만 액세스하는 것이 더 낫다고 할 수 있습니다.\n\n일부 경우에는 의존성 규칙을 위반하고 데이터 레이어를 UI 레이어에서 직접 사용하는 것을 제안하며, 이는 고려할 만한 사항이기도 합니다.\n\n![이미지](/assets/img/2024-05-23-TheComplexitiesofCleanArchitectureUseCases_3.png)\n\nFacade\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n하지만, 만약 관심사 분리를 유지하고 깔끔한 아키텍처 계층 원칙을 완전히 따르면서 지나치게 한 줄 논리 사용 사례의 함정에 빠지지 않으려면 Facade 패턴을 사용하는 것을 고려해보세요.\n\n```js\nclass UserFacade(\n   private val userRepository: UserRepository,\n   private val userMapper: UserMapper\n) {\n\n fun getUser(userConfig: UserConfig): Result<User> {\n   return userRepository.getUser(userConfig)\n }\n\n fun getAllUsers(): Result<List<User>> {\n   return userRepository.getUsers()\n }\n\n fun getAllPremiumUsers(): Result<List<User>> {\n   return userRepository.getPremiumUsers()\n }\n\n fun addUser(user: User): Result<User> {\n   return userRepository.addUser(user)\n }\n\n fun deleteUser(user: User): Result<User> {\n    return userRepository.deleteUser(user)\n }\n\n fun updateUser(user: User): Result<User> {\n    return userRepository.updateUser(user)\n }\n}\n```\n\nFacade 패턴은 하위 시스템을 더 쉽게 사용할 수 있도록 단일하고 더 연관성 있는 인터페이스로 복잡성을 캡슐화합니다. 코드베이스 전반에 흩어져 있는 여러 한 줄 논리 사용 사례 대신에 Facade는 이러한 작업을 통합합니다. 이렇게 하면 본질적으로 동일한 작업을 수행하는 많은 사용 사례를 가지는 중복성이 줄어듭니다 — 데이터 계층과 상호 작용하는 것과 관련이 있는 사용 사례가 많이 감소합니다.\n\n어떠한 다른 옵션들, 예를 들어 모든 데이터 형식과 재사용할 수 있는 일반 타입의 Facade, 같은 작업이 무엇을 가장 잘 수행하는지 찾아보기 위한 실험이 가능합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n단일 책임 원칙\n\n이제 SOLID 원칙 중 SRP에 대해 이야기해보겠습니다. UseCase가 단일 작업이어야 한다는 것을 기억하세요. 그리고 해당 정의에 따라 SRP를 준수해야 합니다.\n\n새 사용자 등록을 담당하는 UseCase가 있습니다:\n\n```js\nclass UserRegistrationUseCase(\n    private val userRepository: UserRepository,\n    private val appThemeRepository: AppThemeRepository,\n    private val emailService: EmailService,\n    private val securityService: SecurityService,\n    private val promotionsService: PromotionsService,\n) {\n\n    operator fun invoke(userDetails: UserDetails): Result<User> {\n        if (securityService.weak(password = userDetails.password)) {\n            return Result.failure(Exception(\"비밀번호가 약합니다\"))\n        }\n\n        val isPromotional = checkPromotionalEligibility(userDetails.email, userDetails.location)\n        val userSettings = UserSettings(\"en-US\", receiveNewsletters = isPromotional)\n        val starterPack = if (isPromotional)\n            promotionsService.getPromotionalStarterPack(userDetails.location)\n        else promotionsService.getDefaultStarterPack(userDetails.location)\n\n        val user = User.fromUserDetails(userDetails, securityService.encryptPassword(userDetails.password), isPromotional, userSettings, starterPack)\n\n        userRepository.save(user)\n        emailService.sendWelcomeEmail(userDetails.email, isPromotional)\n\n        if (isPromotional)\n            appThemeRepository.save(user.id, \"dark\")\n        else appThemeRepository.save(user.id, \"light\")\n\n        promotionsService.schedulePersonalizedFollowUps(user.id, user.email, user.isPromotional)\n        return Result.success(user)\n    }\n\n    private fun checkPromotionalEligibility(email: String, location: String): Boolean {\n        val isEmailEligible = email.endsWith(\"@example.com\")\n        val isLocationEligible = location == \"USA\" // 미국의 프로모션 자격을 가정합니다\n        return isEmailEligible && isLocationEligible\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 UseCase를 살펴보면 SRP를 위반하는 것 같네요. 아마도 맞을 겁니다. 코드가 별도의 UseCase로 추출되고 재사용될 수 있는 부분이 있습니다. 함께 해결해보죠.\n\n```js\nclass UserRegistrationFlowUseCase(\n    private val saveUserUseCase: SaveUserUseCase,\n    private val prepareNewUserUseCase: PrepareNewUserUseCase,\n    private val userFollowUpUseCase: UserFollowUpUseCase,\n    private val sendWelcomeEmailUseCase: SendWelcomeEmailUseCase,\n    private val setAppThemeUseCase: SetAppThemeUseCase,\n) {\n\n  operator fun invoke(userDetails: UserDetails): Result<User> {\n      val userResult = prepareNewUserUseCase.prepareUser(userDetails)\n      if (userResult.isError()) {\n         return userResult\n      }\n      val user = userResult.get()\n\n      saveUserUseCase(user)\n      sendWelcomeEmailUseCase(user)\n      userFollowUpUseCase(user)\n      setAppThemeUseCase(user)\n      return Result.success(user)\n  }\n}\n\nclass PromotionEligibilityUseCase(\n    private val emailPromotionEligibilityUseCase: EmailPromotionEligibilityUseCase,\n) {\n\n  fun checkEligibility(userDetails: UserDetails): Boolean {\n      val isEmailEligible = emailPromotionEligibilityUseCase(userDetails.email)\n      val isLocationEligible = userDetails.location == \"USA\" // Assume promotional eligibility for USA\n      return isEmailEligible && isLocationEligible\n  }\n\n}\n\nclass EmailPromotionEligibilityUseCase {\n\n  operator fun invoke(email: String): Boolean {\n      val emailRegex = \"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\\\.[a-zA-Z]{2,6}$\"\n      return email.endsWith(\"@example.com\") && email.matches(emailRegex.toRegex())\n  }\n}\n\nclass PrepareNewUserUseCase(\n    private val securityService: SecurityService,\n    private val getStarterPackUseCase: GetStarterPackUseCase,\n    private val promotionEligibilityUseCase: PromotionEligibilityUseCase,\n) {\n\n  fun prepareUser(userDetails: UserDetails): Result<User> {\n      if (securityService.weak(password = userDetails.password)) {\n         return Result.failure(Exception(\"Password is weak\"))\n      }\n      val isPromotional = promotionEligibilityUseCase.checkEligibility(userDetails)\n      val userSettings = UserSettings(\"en-US\", receiveNewsletters = isPromotional)\n      val starterPack = getStarterPackUseCase(userDetails.location, isPromotional)\n      val encryptedPassword = securityService.encryptPassword(userDetails.password)\n      return Result.success(User(\n          id = 0,\n          name = userDetails.name,\n          email = userDetails.email,\n          password = encryptedPassword,\n          location = userDetails.location,\n          isPromotional = isPromotional,\n          settings = userSettings,\n          starterPack = starterPack\n        )\n      )\n  }\n}\n\n(이하 계속)\n```\n\n우리는 SRP를 만족하는 새로운 8개 UseCase를 생성했어요. 모두 작고 깔끔하며 쉽게 재사용할 수 있어요. 테스트에 대해서 언급하지는 않았는데, 이 두 경우 모두 모든 것을 쉽게 테스트할 수 있어요.\n\n그러나 이 접근은 엄청난 **맥락적 오버헤드**를 초래합니다. 함수가 많아질수록 일어나게 됩니다. 이 예시에서는 전체 그림을 파악하려면 9개 파일 간을 이동해야 합니다. 한 책의 한 문장이 일어나는 것을 이해하기 위해 해당 문단을 읽은 다음 다음 페이지로 넘어가서 특정 문단을 읽은 다음 다시 원래 페이지로 돌아가서 다음 문장을 읽은 다음 책의 끝까지 가서 다른 문단을 읽는 것을 상상해보세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/assets/img/2024-05-23-TheComplexitiesofCleanArchitectureUseCases_4.png)\n\n기본적으로는 각 use case에서 함수 트리와 그들이 하는 일을 머릿속에 유지해야 합니다. 각 use case에서 무슨 일이 일어나고 있는지 읽고 기억해야 합니다. 함수가 무슨 일을 하는지 읽고 다음으로 진행 — 다시 읽고, 그리고 다음으로 진행 — 다시 읽고, 그리고 다시 처음 use case로 돌아가고, 나머지 남은 모든 함수와 함께 계속합니다. 모든 함수가 서로 다른 파일에 있기 때문에 모두 기억해야 합니다.\n\n![이미지](/assets/img/2024-05-23-TheComplexitiesofCleanArchitectureUseCases_5.png)\n\n또한 디버깅할 때도 귀찮은 작업인데, 다른 파일의 중단점 사이를 이동해야하고, 디버거의 데이터는 일반적으로 현재 클래스에만 표시됩니다. 코드 리뷰에 있어서도 마찬가지로 도전적입니다. 파일과 함수 사이를 쉽게 이동하는 것이 항상 가능한 것은 아니기 때문입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n단지 2-3-4개의 유스케이스만으로도 코드가 해독하기 어려워집니다. 예시의 기능은 간단하고 쉽지만, 실제 프로젝트에서는 보통 더 복잡하며, 이름이 항상 명확하거나 대표적이지는 않습니다 (이름 짓기가 어려워요).\n\n첫 번째 방식에서 유스케이스는 작은 디스플레이에서도 맞게 코드가 20-25줄 정도의 함수로 있습니다. 이것을 책처럼 읽을 수 있고, 20초 전에 검토했던 세 함수가 무엇이었는지 과부하가될 필요가 없이 전체 작업을 볼 수 있습니다. 또한, 단순히 한 곳에서 사용되지 않는다면 이 \"재사용성\"은 필요한 것인가요? 재사용성이 명확한 필요가 있는 경우가 오기 전에 작은 더 구체적인 구성 요소로 유스케이스를 분리하는 것은 조기 최적화입니다. 이 접근 방식은 구조를 불필요하게 복잡하게 만들 수 있고, 관리 및 유지보수해야 하는 요소를 더 많이 도입하여 실질적인 이점 없이 만들어 낼 수 있습니다.\n\n문제를 해결하려는 것인지, 아니면 코드를 작성하는 유일한 올바른 방법으로 생각해서 규칙을 엄격하게 따르려는 것인지 고민해봐야 합니다.\n\n이 룰을 엄밀히 준수할 필요가 없는 경우에도 코드를 작업하고 유지하는 것이 훨씬 쉽다고 생각해요 (그런데 이 룰들은 많은 년이 지나도 수정되지 않았죠).\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n요약\n\n- 의존성 규칙: 이 규칙은 소스 코드 의존성이 내부로만 가리킬 수 있다는 것을 말합니다. 이로 인해 종종 데이터 레이어에 프록시 역할을 하는 사용 사례가 생성됩니다.\n\n- 일줄 사용 사례: Clean Architecture 엄격히 준수하면 다른 레이어로의 프록시 역할만 하는 다수의 일줄 사용 사례가 생성되어 사용 사례 수가 기하급수적으로 증가할 수 있습니다.\n\n- 기하급수적 성장: 사용 사례 수가 급속히 증가함에 따라 코드베이스를 유지하고 탐색하는 것이 어려움을 초래할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 복잡성과 오버헤드: SRP를 엄격히 준수하면 하나의 사용 사례를 많은 작은 사용 사례로 분해하여 시스템의 복잡성과 맥락 상의 오버헤드를 증가시킬 수 있습니다.\n\n- 균형: UseCase를 설계할 때 이론적 순수성과 재사용성을 유지하는 Single Responsibility Principle (SRP)과 작동 오버헤드를 최소화하는 실용적이고 유지보수 가능한 시스템을 만드는 사이의 상충 관계를 고려해주세요.\n\n독서해 주셔서 감사합니다!\n","ogImage":{"url":"/assets/img/2024-05-23-TheComplexitiesofCleanArchitectureUseCases_0.png"},"coverImage":"/assets/img/2024-05-23-TheComplexitiesofCleanArchitectureUseCases_0.png","tag":["Tech"],"readingTime":18},{"title":"스캐니버스가 안드로이드를 지원하게 되었습니다","description":"","date":"2024-05-23 14:41","slug":"2024-05-23-ScaniverseextendssupporttoAndroid","content":"\n## 다양한 플랫폼에서 3D 스캐닝과 가우시안 스플래팅을 경험해보세요\n\n우리는 Scaniverse가 이제 Google Play Store에서 사용 가능하다는 것을 기쁘게 알려드립니다!\n\n2021년 1월에 론칭한 이후, 사용자들이 가장 많이 물어보는 질문 중 하나가 '언제 안드로이드용 Scaniverse가 출시될까요?' 였습니다. 그래서 오늘부터 Scaniverse를 Play Store에서 안드로이드 사용자들을 위해 제공할 수 있게 되어 너무 기쁩니다. 3D 스캐닝 및 크리에이션을 더 많은 사용자들에게 전 세계적으로 제공할 수 있게 되었습니다.\n\n![이미지](/assets/img/2024-05-23-ScaniverseextendssupporttoAndroid_0.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 3D 창조물을 촬영, 편집 및 공유하세요\n\n안드로이드의 Scaniverse를 통해 iOS 앱의 최상의 기능을 경험할 수 있습니다. 주변 환경을 스캔하고 모델을 자르고 편집하여 창조물을 세계와 공유하거나 내보낼 수 있습니다. 최근 추가된 3D 가우시안 스플래팅 기능도 포함되어 있어, 좋아하는 장소와 물건의 환상적인 사실적인 세부사항을 캡처할 수 있습니다. 또한 Android에서 세계 최초로 3D 기기 내 스플래트 재구성 기능도 소개되어, 속도와 개인 정보 보호를 제로 저장 비용과 함께 제공합니다. 무료, 빠르고 제한이 없습니다.\n\n# 뒷이야기: Scaniverse 이식\n\nScaniverse의 안드로이드 버전을 만드는 것은 도전적이지만 보람 있는 여정이었습니다. 여기에는 어떻게 만들었는지에 대한 소개가 있습니다. 원래의 iOS 앱은 Swift와 네이티브 C++ 코드를 사용하여 만들어졌습니다. 안드로이드에서는 가능한 경우 네이티브 C++ 구성 요소를 재사용하여 플러터 프레임워크를 선택하여 크로스 플랫폼 구현을 만들었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n현대 iPhones 중 일부는 LIDAR 센서가 장착된 반면, Android 폰은 그렇지 않아서 포토그램메트리 모드를 통해 3D 재구성할 때 카메라 데이터에만 의존해야 했습니다. 또한 다양한 SoC, CPU 및 GPU를 갖춘 Android 기기 범위에 대한 성능 및 안정성을 최적화하려면 상당한 노력이 필요했습니다. 고사양 Android 기기에서 처리 시간을 30분 이상에서 단 4~5분으로 줄였습니다. 초기 릴리스가 현대 iPhones의 속도에 미치지 못할 수도 있지만, 오늘날 Android 기기에서 훌륭한 성능과 품질을 제공합니다.\n\n자세한 내용은 [FAQ](https://faq.link)를 방문해보세요.\n\n# Android 여정에 참여하세요\n\n![이미지](https://miro.medium.com/v2/resize:fit:600/1*TfpgfZYjKOkVC_6fibRbIA.gif)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n안녕하세요! 안드로이드에서의 여정이 이제 막 시작됐습니다. 우리는 iOS 앱과 기능의 동일성을 달성하고, 스캔 품질을 향상시키며, 각 업데이트마다 성능을 향상시키겠다는 다짐을 하고 있습니다. 여러분의 피드백은 저희에게 매우 중요합니다. Scaniverse가 여러분을 어떻게 더 잘 도울 수 있는지 support@scaniverse.com으로 연락주시면 감사하겠습니다.\n\n지금 구글 플레이 스토어에서 Scaniverse를 다운로드하고 멋진 3D 콘텐츠를 만들어보세요. 좋아하는 3D 작품을 @scaniverse를 태그하여 인스타그램에서 공유하거나 해시태그 #scandroid로 X에 공유해주시면 저희가 채널에서 공유해드리겠습니다!\n\nScaniverse 팀 드림\n","ogImage":{"url":"/assets/img/2024-05-23-ScaniverseextendssupporttoAndroid_0.png"},"coverImage":"/assets/img/2024-05-23-ScaniverseextendssupporttoAndroid_0.png","tag":["Tech"],"readingTime":3},{"title":"테라스캔Terrascan이란 무엇인가요","description":"","date":"2024-05-23 14:39","slug":"2024-05-23-WhatisTerrascan","content":"\n이 기사에서는 Terrascan을 살펴볼 것입니다. 이것이 무엇인지, 왜 사용해야 하는지, 어떻게 설치해야 하는지, 그리고 그 기능을 활용하는 방법에 대해 알아볼 것입니다. 우리는 일부 사용 사례 예제를 살펴보고, Terraform, Kubernetes (K8S) 및 Helm 차트를 스캔하는 방법을 보여줄 것입니다. 그리고 사용자 정의 정책을 정의하는 방법을 살펴보고, 마지막으로 Terrascan이 Chekov 및 TFSec와 같은 다른 유사한 제품과 비교되는 방법을 자세히 살펴볼 것입니다.\n\n![What is Terrascan](/assets/img/2024-05-23-WhatisTerrascan_0.png)\n\n## Terrascan이란 무엇인가요?\n\nTerrascan은 인프라를 코드로 정의하는(Infrastructure as Code, IaC)를 위한 오픈 소스 정적 코드 분석 도구입니다. Terrascan 웹사이트 태그라인이 Terrascan을 요약합니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여기의 핵심 키워드 중 하나는 'before'입니다. Terrascan 도구의 목표는 인프라가 프로비저닝되기 전에 규정 준수나 보안 문제를 알려줌으로써 이를 해결하여 문제를 피하는 것입니다.\n\nTerrascan은 Tenable이 소유하고 있으며, 이 회사는 Cloud Native Computing Foundation (CNCF) 및 Open Source Security Foundation (OpenSSF)의 회원입니다.\n\n## Terrascan의 사용 목적\n\nTerrascan은 개발자와 DevOps 팀이 인프라 코드가 모범 사례, 보안 표준 및 규정 요구 사항을 준수하는지를 보장하는 데 도움을 줍니다. Terrascan은 500개 이상의 미리 설정된 정책을 제공하여 CIS Benchmark와 같은 공통 정책 표준에 대해 IaC를 검사할 수 있습니다. Terrascan을 처음 사용할 때 -p 플래그가 지정되지 않은 경우, Terrascan은 Terrascan 리포지토리에서 최신 정책을 다운로드합니다. terrascan init를 실행하여 로컬 환경을 리포지토리에 게시된 최신 정책으로 업데이트할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## Terrascan 특징\n\n- Terrascan은 AWS, Azure, Google Cloud Platform (GCP), K8S, ArgoCD, Atlantis, GitHub, Docker을 포함한 다양한 클라우드 제공업체 및 코드 유형과 함께 사용할 수 있어 교차 클라우드 인프라 배포에 다재다능합니다.\n- Terrascan은 사용자 정의 가능한 사전 정의된 보안 및 규정 준수 규칙 라이브러리를 제공합니다. 이러한 규칙은 암호화, 액세스 제어, 리소스 구성 등 인프라 보안 및 규정 준수의 다양한 측면을 포함합니다. 기본적으로 사용되는 정책을 자세히 보려면 terrascan 정책 문서 페이지를 확인할 수 있습니다.\n- Terrascan은 CI/CD 파이프라인, IDE(통합 개발 환경) 및 다른 개발 및 배포 워크플로에 통합할 수 있습니다. 이를 통해 IaC 코드의 자동 스캔 및 유효성 검사가 개발 프로세스의 일부로 이루어질 수 있습니다.\n- Terrascan은 클라우드 인프라의 지속적인 모니터링에 사용될 수 있습니다. 취약점이나 규정 준수 문제를 발생시킬 수 있는 변질이나 구성 변경을 정기적으로 검사하고 확인할 수 있도록 설정할 수 있습니다.\n- 보고 및 개선: Terrascan은 분석 중 발견된 문제를 강조하는 자세한 보고서를 생성합니다. 또한 이러한 문제를 어떻게 개선할지에 대한 지침을 제공하여 팀이 보안 및 규정 준수 문제를 효과적으로 해결할 수 있도록 도와줍니다.\n\n## Terrascan 설치 방법\n\n- Windows\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n인기 있는 Windows 패키지 관리자 Chocolately를 사용하거나 수동으로 다운로드하여 설치할 수 있어요.\n\n```js\nchoco install terrascan\n```\n\n릴리스 페이지에서 Terrascan을 다운로드하세요:\n\nzip 파일에서 파일을 추출하고 Windows 경로에 추가하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 시작 단추를 마우스 오른쪽 버튼으로 클릭합니다.\n- 콘텍스트 메뉴에서 “시스템”을 선택합니다.\n- “고급 시스템 설정”을 클릭합니다.\n- “고급” 탭으로 이동합니다.\n- “환경 변수…”를 클릭합니다.\n- “Path”라는 변수를 클릭하고 “편집…”을 클릭합니다.\n- “새로 만들기”를 클릭합니다.\n- PATH에 포함하려는 Terrascan 파일이 있는 폴더의 경로를 입력하세요.\n\n- MacOS\n\n```js\ncurl -L \"$(curl -s https://api.github.com/repos/tenable/terrascan/releases/latest | grep -o -E \"https://.+?_Darwin_x86_64.tar.gz\")\" > terrascan.tar.gz\ntar -xf terrascan.tar.gz terrascan && rm terrascan.tar.gz\ninstall terrascan /usr/local/bin && rm terrascan\nsudo install terrascan /usr/local/bin\n```\n\n- Linux\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\ncurl -L \"$(curl -s https://api.github.com/repos/tenable/terrascan/releases/latest | grep -o -E \"https://.+?_Linux_x86_64.tar.gz\")\" > terrascan.tar.gz\ntar -xf terrascan.tar.gz terrascan && rm terrascan.tar.gz\ninstall terrascan /usr/local/bin && rm terrascan\nsudo install terrascan /usr/local/bin\n```\n\n- 도커\n\n도커 허브에서 이미지를 다음과 같이 가져올 수도 있습니다:\n\n```js\n$ docker run --rm tenable/terrascan version\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n테라스캔을 설치한 후 설치 여부를 확인하기 위해 명령줄에서 테라스캔을 실행하세요.\n\n![Terrascan](/assets/img/2024-05-23-WhatisTerrascan_1.png)\n\n## IaC 코드를 스캔하는 방법\n\n코드를 스캔하려면 구성 파일이 있는 폴더로 이동한 후 다음 명령을 실행하세요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nterrascan scan\n```\n\n--c 옵션을 사용하여 스캔할 디렉토리를 지정할 수도 있어요.\n\n## Terrascan 사용 사례 - 예시\n\nTerrascan을 여러 유형의 구성 파일과 함께 사용할 수 있어요. 여기에 몇 가지 예시가 있어요. 이를 통해 쉽게 시작할 수 있을 거예요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 예제 1 — Terraform 코드 스캔\n\nAzure를 위한 예제 Terraform 설정 파일이 있습니다. 이 파일은 간단히 리소스 그룹을 생성합니다:\n\nmain.tf\n\n```js\nprovider \"azurerm\" {\n  features {}\n}\n\nresource \"azurerm_resource_group\" \"example\" {\n  name     = \"example-resources\"\n  location = \"East US\"\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n파일을 저장한 후 해당 디렉토리로 이동하여 terrascan scan을 실행하십시오. Terrascan이 1개의 정책 위반을 감지하고 리소스 그룹에 리소스 잠금을 활성화해야 한다고 권장함을 볼 수 있어요. 이 문제는 LOW 심각도로 표시돼요.\n\n![Terrascan Screenshot](/assets/img/2024-05-23-WhatisTerrascan_2.png)\n\n## 예제 2 - Helm 차트 스캔\n\nHelm 차트를 사용하여 Terrascan을 테스트하기 위해 demo-chart라는 새 차트를 만들어보겠어요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nhelm create demo-chart\n```\n\n이제 values.yaml 파일을 편집하여 Terrascan이 보고할 몇 가지 추가 취약점을 추가해보겠습니다.\n\n<img src=\"/assets/img/2024-05-23-WhatisTerrascan_3.png\" />\n\nvalues.yaml 파일이 있는 디렉토리로 이동한 다음 terrascan scan을 실행하세요. 보고된 위반 정책이 여러 개 표시되어야 합니다. 여기에는 위에 securityContext 라인을 추가하여 발생시킨 HIGH 심각도의 2개의 정책 위반이 포함될 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-05-23-WhatisTerrascan_4.png\" />\n\n## 예제 3 — 쿠버네티스 매니페스트 스캔하기\n\nK8S 매니페스트를 스캔하는 방법을 테스트하기 위해 간단한 nginx 배포용 파일을 작성해보겠습니다:\n\nnginx.yaml\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\n  labels:\n    app: nginx\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n        - name: nginx\n          image: nginx:latest\n          ports:\n            - containerPort: 80\n```\n\nnginx.yaml 파일이 있는 폴더로 이동하여 terrascan scan을 실행해주세요.\n\nTerrascan에서 여러 권장 사항을 보게 될 것인데, 그 중에는 2개의 HIGH 우선 순위 이슈('Minimize Admission of Root Containers' 및 'Containers Should Not Run with AllowPrivilegeEscalation')도 포함되어 있습니다.\n\n<img src=\"/assets/img/2024-05-23-WhatisTerrascan_5.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 예제 4 — Terrascan을 ArgoCD와 통합하기\n\nTerrascan은 인기있는 CI/CD 시스템인 Azure DevOps, GitHub, GitLab 및 Argo와 통합할 수 있습니다. ArgoCD의 경우, Terrascan은 ArgoCD의 리소스 후크를 사용하여 응용 프로그램 사전 동기화 프로세스 중 Argo CD 작업으로 구성될 수 있습니다. 또한 Terrascan의 K8S admission 컨트롤러를 사용하여 사전 동기화 및 컨트롤러 웹훅과 함께 구성된 저장소를 스캔할 수 있습니다.\n\nTerrascan 문서 페이지에서 전체 통합 예시를 찾을 수 있습니다.\n\n## Terrascan 사용자 정의 정책\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nTerrascan은 사용자가 Rego 쿼리 언어를 사용하여 쉽게 사용자 정의 정책을 만들 수 있도록 Open Policy Agent (OPA) 엔진을 활용합니다. 각 rego 정책에는 정책에 대한 메타데이터를 정의하는 JSON \"rule\" 파일이 포함되어 있습니다. Terrascan에 포함된 정책은 pkg/policies/opa/rego 디렉토리에 저장됩니다. rule.json 파일은 Rego 파일에서 정의된 사용자 정의 정책을 참조하는 구성 파일로, Terrascan 스캔 중에 어떤 정책이 적용되고 심각성 수준이 어떻게되는지를 제어할 수 있습니다. 사용자 정책 로직 및 규칙은 .rego 파일에 정의되며, rule.json 파일은 해당 정책을 적용하고 구성하는 방법을 지정합니다.\n\n아래 정책 예시는 Azure 리소스가 \"UK South\" 또는 \"UK West\"에만 있어야 한다는 것을 강제합니다. 다른 위치에서 리소스를 찾으면 Terrascan에서 보고됩니다.\n\nazure_region_policy.rego\n\n```js\npackage main\n\nimport input.tfplan as tfplan\n\ndefault allow = false\n\nallowed_regions = [\"UK South\", \"UK West\"]\n\n# 테라폼 계획의 모든 Azure 리소스를 반복합니다.\nazure_resources[resource_name] {\n    resource_name = input.tfplan.resource_changes[_].address\n    input.tfplan.resource_changes[_].type == \"azurerm_resource\"\n}\n\n# 각 Azure 리소스의 지역이 허용되었는지 확인합니다.\nallow {\n    resource_name\n    resource_config := input.tfplan.resource_changes[resource_name].change.after\n    resource_config.location == allowed_region\n    allowed_region = allowed_regions[_]\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n사용자 정책을 활성화하려면 rule.json 파일을 사용하여 Terrascan의 동작을 구성하고 스캔 중에 적용해야 할 정책을 지정합니다.\n\nrule.json\n\n```js\n{\n  \"rules\": {\n    \"azure_region_policy\": {\n      \"severity\": \"HIGH\",\n      \"message\": \"'UK South' 또는 'UK West' 지역에 Azure 리소스를 배포해야 합니다.\",\n      \"rules_file\": \"azure_region_policy.rego\"\n    }\n  }\n}\n```\n\n마지막으로 사용자 정책을 사용하여 스캔하려면 스캔하려는 디렉토리로 이동하고 -rules 플래그를 사용하여 json 파일 경로를 지정하십시오.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nterrascan scan -rules /path/to/rule.json\n```\n\n또한 Terrascan은 원하는 경우 정책을 준수하지 않으려면 해당 정책을 제외할 수도 있습니다. 예를 들어, 예시 1에서 구성한 Azure 리소스 그룹에 리소스 잠금을 사용하고 싶지 않다면 이 정책을 스캔에서 제외하여 이 문제로 표시되지 않게 할 수 있습니다. 이를 위해 -skip-rules 플래그를 사용하거나 특정 리소스에서 정책을 건너뛰는 파일 내부 기능을 사용합니다.\n\n## Terrascan 대 Checkov\n\n외관상으로 보면, Terrascan과 Checkov는 매우 유사합니다. 둘 다 IaC 보안 및 규정 준수 스캔을 위해 설계된 오픈 소스 정적 코드 분석 도구입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nCheckov은 Terraform에 주로 초점을 맞추고 있지만, AWS SAM을 포함한 CloudFormation, Azure Resource Manager (ARM), Serverless framework, Helm 차트, K8S 및 Docker와 같은 여러 유형의 파일을 스캔할 수 있습니다. Checkov는 활발한 기여 및 DevSecOps 커뮤니티에서 강력한 존재감을 보이는 커뮤니티 주도 프로젝트입니다.\n\nCheckov는 Python을 사용하여 구축되었으며, Terrascan은 Go를 사용하며 Rego를 사용하여 사용자 정의 정책을 작성합니다. 사용자 정의 정책을 작성하는 데 Rego를 선호한다면 Terrascan은 좋은 선택입니다.\n\n## Terrascan vs tfsec\n\nTfsec는 또 다른 오픈 소스 정적 코드 분석 도구이며, 고려할 수 있는 주요 옵션 중 하나입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nTerrascan과 달리 TFSec는 GO로 작성되었으며 사용자 정의 정책에는 Terrascan에서 사용되는 Rego 대신 YAML 정의를 사용합니다. K8S에 익숙한 사용자는 Rego 학습 대신 YAML을 사용하여 정책을 작성하는 것을 선호할 수 있습니다. 이는 TFSec를 선택하는 이유가 될 수 있습니다. 또한 커뮤니티에서 Checkov 및 Terrascan보다 가장 인기 있는 프로젝트이며 가장 많은 GitHub 스타를 가지고 있습니다.\n\n## 주요 포인트\n\nTerrascan은 IaC 템플릿 및 구성을 스캔하는 데 설계된 매우 유연하고 강력한 오픈 소스 정적 코드 분석 도구입니다. IaC 코드에서 보안 취약점, 준수 위반 및 최상의 실천 방법 문제를 식별하는 데 도움을 줍니다. 다양한 유형의 구성 파일과 함께 사용할 수 있으며 내장 정책을 제공하며 Rego를 사용하여 사용자 정의 정책을 사용할 수도 있습니다. CI/CD 시스템과 자동화 파이프라인에서 사용하는 것이 지원됩니다.\n\n여기에서 Terraform에 관한 다른 기사들도 확인해보세요!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n환호! 🍻\n\n원래 spacelift.io에서 발행되었습니다.\n","ogImage":{"url":"/assets/img/2024-05-23-WhatisTerrascan_0.png"},"coverImage":"/assets/img/2024-05-23-WhatisTerrascan_0.png","tag":["Tech"],"readingTime":14},{"title":"데브옵스DevOps란 무엇인가요","description":"","date":"2024-05-23 14:37","slug":"2024-05-23-WhatisDevOps","content":"\n## 시스템 엔지니어의 여정과 관점\n\n![이미지](/assets/img/2024-05-23-WhatisDevOps_0.png)\n\n# 소개\n\n데브옵스란 무엇일까요? 그 질문은 특정 IT 분야에 뛰어들기 전에 스스로에게 묻고 진정한 의미를 이해하기 전까지 기억하는 질문이었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저는 멜버른, 호주에서 열린 VMware 사용자 회의에 참석했던 때를 떠올립니다. 여러 다른 VMware 애호가들과 함께 있었는데, VMware 및 협력사들이 개발 중인 흥미로운 제품들에 대해 더 알아보기 위해 열정적으로 참석했었습니다. 발표를 하는 신사의 이름은 KevOps로 매우 재미있는 이름이었다고 기억해요.\n\n당시 시스템 엔지니어로서, 저는 데브옵스를 다음 단계로 여겼습니다. 상위 수준에서는 저에게 코드와 관련된 부분이라는 것은 알고 있었지만, 그 본질 자체가 이해되지 않아 솔직히 겁이 났어요. 처음으로 데브옵스를 이해할 때, 강력한 개발자여야 하고 높은 수준의 코딩 경험이 필요하다는 것을 이해했어요. 하지만 이것은 제가 잘하지 않았고 이 간극을 메우는 것은 불가능하다고 생각했어요. 하지만 더 깊이 파고들수록 더 많은 것을 발견하게 되었고, 결국은 저 스스로가 오르기 어려운 산처럼 보이던 그 직무까지 수행하고 있는 자신을 발견했습니다.\n\n# 데브옵스의 간략한 역사\n\n데브옵스가 무엇인지 알아가기 전에, 과거로 돌아가서 문제 상황을 살펴보겠습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n2007년 경, 개발 및 운영 팀이 산업 전반에 걸쳐 함께 일하는 방식에 문제가 있습니다. 서로 분리되어 있고 서로의 다음 목표가 일치하지 않는 경우가 많습니다. 개발자들은 운영팀이 서버를 관리해야 하는 많은 경쟁 우선 순위로 인해 배포를 제때에 할 수 없습니다. 이 모델로는 누구도 이길 수 없는 상황입니다.\n\n여기에서 DevOps 용어가 만들어지고, 제가 소개할 때 이 운동이 가속화되기 시작했습니다. 저의 겸손한 의견으로는 IT 산업의 일부 분야를 혁신적으로 변화시키기 위해 필요한 문제 해결을 단호히 요청하는 움직임입니다.\n\n# 그러면, DevOps란 무엇일까요?\n\n우선, DevOps는 한 문장이나 진술로 설명할 수 없습니다. 사실, 이것은 여러 요소나 측면을 갖고 있는 것입니다. 어떤 렌즈를 통해 보느냐에 따라 달라지는 정의가 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nDevOps를 설명하는 것은 다음과 같을 수 있어요:\n\n- 문화\n- 프레임워크\n- 기술적 방법론\n- 엔지니어 유형\n\n각각의 요소는 관점과 전문성에 따라 정의될 수 있어요. 이는 Agile이나 ITIL과 유사한데, 이러한 주제에 대한 이해는 당신의 역할과 책임에 따라 정말 중요해질 거예요.\n\n집과 같이, DevOps는 강력한 기초 위에 구축되어 구조를 구현하고 마무리를 지어나갈 거예요. 아래 다이어그램은 DevOps가 문화적 수준에서 시작하여 기술을 살아 숨쉬게 만들어가는 과정을 도와줍니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/assets/img/2024-05-23-WhatisDevOps_1.png)\n\n# 데브옵스란 문화\n\n현재 GenAI가 핫한 주제인 가운데, ChatGPT 또는 Gemini와 같은 대형 언어 모델(Large Language Models, LLM)에 대해 익숙할 것입니다. ChatGPT에게 데브옵스란 무엇인지 물어보면 대략 이와 같은 답을 얻을 수 있습니다:\n\n이 정의는 데브옵스의 문화적 측면을 잘 요약한 것입니다. 데브옵스는 개발팀과 운영팀 간의 장벽을 허물고 상호 유익한 관계를 구축하기 위해 함께 뭉치는 것을 목표로 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nDevOps가 추구하는 문화 중 일부 맨트는 다음과 같습니다:\n\n- 수동 및 번거로운 작업을 없애겠습니다.\n- 자동화를 촉진하여 효율성과 민첩성을 높이겠습니다.\n- 일관성을 위해 반복 가능한 패턴을 사용하겠습니다.\n- 능력과 숙련도를 향상시키기 위해 협력을 촉진하겠습니다.\n- 우리는 복잡함 대신 단숨함을 향한 태도로 새로운 도전에 대응하고 적응할 것입니다.\n\nDevOps 모델을 준수하는 문화의 예를 살펴보겠습니다.\n\n## DevOps 모델을 준수하지 않는 경우\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n운영팀:\n\n- 소프트웨어 업데이트 설치와 같은 작업은 수동으로 처리됩니다.\n- 반복 작업이 자동화되지 않습니다.\n- 새로운 인프라 요청은 수동으로 처리됩니다.\n- 소유 애플리케이션을 위한 개발자 코드는 수동으로 배포됩니다.\n- 월간 주기 내에 작업을 완료하는 것에 대한 경쟁 우선순위가 있습니다.\n- 작업은 선형적인 프로세스를 따르지 않으며 인간 에러의 영향을 받습니다.\n\n개발팀:\n\n- 운영팀에 크게 의존하므로 소유 애플리케이션 배포에 상당한 지연이 있습니다.\n- 일부 배포를 적시에 테스트할 수 없습니다.\n- 인프라에 대한 이해가 없거나, 있더라도 인프라에 액세스할 수 없습니다.\n- 운영팀으로부터의 번거로운 피드백 루프로 배포 문제를 강조합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nDevOps가 해결하는 것을 정말로 이해하려면 어떤 나쁜 환경이 무엇인지 이해해야 합니다. 난 이상한 걸 말했나? 오늘도 이런 일이 발생하고 있고 DevOps를 도입해도 모든 문제가 해결되는 것은 아닙니다. 그러나 위의 예에서 보면 타임라인과 배달 속도에 많은 도움이 될 것입니다.\n\n## DevOps 모델을 따른다\n\nDevOps 팀:\n\n- 인프라, 코드, 자동화 및 빌드 기술 간의 다양한 기술을 보유하고 있습니다.\n- 문제를 검토하고 자동화를 통해 최선의 해결 방법을 한 번 찾은 후, 향후에도 그 자동화를 의존하여 자가 치유 및 수정합니다.\n- 환경에 도입되는 변경 사항에 대해 패턴 기반 접근 방식을 사용하는 엄격한 프로세스를 따릅니다.\n- 가능한 한 많은 수동 작업을 사용하지 않습니다.\n- 변경 사항이 작고 점진적입니다.\n- 피드백 루프가 강하며 팀원과의 관계를 구축하는 데 도움이 됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 두 예시를 옆에 놓을 때, 개선 사항이 분명합니다. 이러한 사고 방식에 노출되었을 때, 여러분은 진정으로 데브옵스에서 무엇을 얻을 수 있는지 그 가치를 온전히 이해하게 됩니다.\n\n데브옵스가 전혀 적용되지 않은 예시에서, 주요 키워드는 명확해야 합니다. 데브옵스의 본질은 가능한 만큼 많은 일을 자동화하는 것입니다. 그렇지만 모든 것을 자동화할 수는 없다는 점을 명심해야 합니다. 데브옵스는 여정입니다. 즉, 데브옵스 방법을 사용할 준비가 된 환경과 그렇지 않은 환경 사이에 명확한 구분을 가져야 합니다.\n\n데브옵스로의 전환을 위해 가장 중요한 요소는 문화입니다. 우리는 이를 받아들이고 온전히 수용해야 합니다. 문화가 없으면 우리는 단일한 토대나 공동의 기반을 갖지 못합니다. 데브옵스는 협업에 관한 것이며 개인이 성공하는 것이 아니라 팀이 성공하는 것임을 이해하는 것입니다. 약속을 견고하게 지키는 것이 무엇을 뜻하며, 데브옵스가 무엇을 의미하며 그 방법론이 우리에게 보여줄 수 있는 것에 대해 말하는 속담을 들어보셨을 것입니다.\n\n문화에 동의한 후, 나머지는 바닥 규칙이 마련된 후에 쉽게 자리에 맞게 되는 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# DevOps 프레임워크\n\nDevOps를 프레임워크로 살펴볼 때, 우리는 더 많은 업무 방식을 고려합니다. 이는 다음을 포함합니다:\n\n- 팀에게 DevOps가 의미하는 것은 무엇인가요?\n- 이해해야 할 DevOps의 하위 개념은 무엇인가요?\n- 우리 팀의 모든 사람이 성공을 위해 어떻게 설정되었는지 확인하는 방법은 무엇인가요?\n\n이것들은 우리가 스스로 묻는 많은 다른 질문들 중 일부입니다. 이 프레임워크는 우리가 성공을 달성하고 현저한 혜택을 얻으면서 의미 있는 결과물을 제공하는 방식을 정의할 수 있도록 해줍니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n오랜만에 만나서 반가워요!\n\n데브옵스의 각 측면이 전문성을 갖고 있는 내용을 간단히 살펴보겠습니다:\n\n![DevOps Expertise](/assets/img/2024-05-23-WhatisDevOps_2.png)\n\n이것은 데브옵스 프레임워크 내에서 흔히 사용되는 일부 주요 개념을 샘플링한 것입니다. 물론 다른 것도 있지만, 여기서는 주요 개념을 단순히 설명하는 데에 초점을 맞추고 있습니다. 문화로서의 데브옵스 섹션과 마찬가지로 서로 유익한 전문분야를 식별하기 시작할 수 있을 겁니다.\n\n본질적으로, 데브옵스는 이러한 다양한 전문분야를 결합하여 인프라 솔루션 및 애플리케이션을 배포하고 관리하며 유지보수하기 위한 목적을 달성하려는 프레임워크입니다. 이를 이루는 방법은 다음과 같습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- SCM(소프트웨어 구성 관리) 및 CI/CD(지속적 통합/지속적 배포) 프로세스를 결합하여 인프라 기반 솔루션을 빌드하고 배포합니다. 보통 이를 GitOps 모델이라고 합니다.\n- 정기적으로 반복되는 수동 작업을 자동화합니다.\n- 수요에 따라 확장할 수 있는 용량이 탄탄하고 오류 허용이 가능한 무상태 아키텍처 개념을 활용합니다.\n- 애플리케이션 변경에 반응하는 이벤트-주도 아키텍처를 생성합니다.\n- 애자일성과 빠른 전달 속도를 향상시키기 위해 잘 알려진 패턴을 재사용합니다.\n\n# 기술적 접근으로서의 DevOps\n\nDevOps의 기술 세부 정보 및 기술 요소로 진입하기 전에, 직접 경험한 현실 시나리오를 한번 살펴보고 싶습니다.\n\n2017년 특정 환경에서, DevOps에서 언급된 것과 유사한 수동 작업을 수행했던 기억이 나네요. DevOps 모델을 따르지 않았던 윈도우 중심의 환경이었고, 가상 환경으로 VMware를 사용했습니다. 서버는 SCCM을 사용하여 수동으로 패치되었습니다. 이 프로세스는 다음과 같았습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 운영팀 구성원이 목록에서 서버를 손에 든다.\n- 관리 액세스를 사용하여 해당 서버에 로그인한다.\n- SCCM 클라이언트를 시작한다.\n- 업데이트를 설치한다.\n- 다시 부팅한다.\n\n특히 해당 방식으로 패치해야 하는 여러 서버가 있는 경우에는 번거로운 프로세스였습니다. 이 모든 것의 귀하의 유일한 상처는? 이것이 월간 행사였다는 사실입니다.\n\n이 예제는 DevOps가 개발 운영 측면에서 존재하기 전의 생활을 보여줍니다. 이는 환경을 유지하고 “불을 켜 있는” 과제 중 하나로써 정기적으로 수행되어야 하는 많은 작업 중 하나이기도 합니다. DevOps가 제공할 수 있는 가치를 실감하게 되면, 정기적으로 수동 작업을 수행하는 것은 시간의 대조적인 투자 수익이 매우 적은 것처럼 느껴집니다.\n\n기술적 접근 방법으로서의 DevOps에 관한 것은, 이제 다양한 작업 및 동작을 수행하는 데 사용되는 실제 도구에 대해 깊게 들어가 시작합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 익숙할지도 모르는 몇 가지 개념과 각각의 응용 프로그램 목록입니다:\n\n![이미지](/assets/img/2024-05-23-WhatisDevOps_3.png)\n\n이것은 그림을 보여주기 위한 목록 샘플만을 제시한 것입니다.\n\n이 도구들의 조합을 사용하여 환경을 운영하면, 플랫폼과 관련된 솔루션(대규모/확장된 환경에서 플랫폼을 지원)이나 특정 응용 프로그램을 구축할 수 있습니다. 이 다이어그램은 이러한 개념과 응용 프로그램을 실제 시나리오에 어떻게 적용할 수 있는지 보여줍니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![image](/assets/img/2024-05-23-WhatisDevOps_4.png)\n\n**포인트 1 - 코드는 GitHub에 저장됩니다**\n\n이를 통해 우리는:\n\n- 전체 팀이 사용할 일관된 진실의 원천을 적절히 유지할 수 있습니다.\n- 코드베이스의 버전을 생성하여 개발, 테스트, 프로덕션 등 다양한 환경으로 단계적이고 제어된 배포를 할 수 있습니다.\n- 동료들로부터 제안된 변경 사항을 코드베이스에 도입하려고 하는 경우 동료들의 리뷰 및 승인 프로세스를 거치도록 합니다.\n- 자동 배포를 위해 Buildkite와 통합합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n제 2점 — Terraform을 사용한 IaC\n\nTerraform은 AWS에서 자원을 생성/대체/업데이트/삭제(CRUD)하는 데 사용됩니다. Github 및 Buildkite와 함께 Terraform을 사용하여 GitOps 모델을 구현함으로써 배포를 처리할 수 있습니다. 이는 다음을 보장합니다:\n\n- 자원이 일관된 방식으로 배포됩니다.\n- 빌드카이트만을 통해 Terraform을 사용하여 배포를 수행할 수 있도록 하여 이 프로세스에서 벗어나지 않습니다.\n- 코드를 반복적으로 사용하여 매번 처음부터 작업하는 대신 개선만 하여 사용하는 DRY(Don’t Repeat Yourself) 모델을 촉진할 수 있습니다.\n\n제 3점 — CI/CD를 위한 Buildkite 사용\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nBuildkite는 검증, 계획 및 배포를 수행하는 CI/CD 플랫폼으로 사용됩니다. Buildkite는 일관성을 유지하기 위해 GitHub를 소스로 사용할 것입니다.\n\n4번 항목 — 배포 전 코드 검증 (CI/CD의 CI)\n\n검증 및 계획 파이프라인이 배포 전에 실행되어 우리가 무엇을 기대해야 하는지 알 수 있습니다.\n\n또한 이 단계를 강화하고 개발 환경에서 모의 배포를 수행할 수도 있습니다. 이렇게 하면 예기치 못한 문제가 도드라지며 접근 방식을 재고하고 조정해야 할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n점 5 — Pull request 동료 리뷰\n\n충분한 증거가 축적되면 동료에게 우리의 pull request를 검토해 달라고 요청할 수 있으며, 모든 게 제대로 된 경우 병합을 진행할 수 있습니다.\n\n협업이 최고이며, DevOps의 문화 측면에서 언급된 대로 동료의 의견을 듣고 항상 배울 수 있고 조정할 수 있는 방법이 항상 있습니다.\n\n점 6 — Pull request 병합 및 배포 (CI/CD의 CD 부분)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n한 번 pull request가 승인되고 병합되면, 자동화가 실행되어 리소스가 배포됩니다.\n\nGitOps 모델을 활용함으로써, 각 단계는 통제되며 비교적 예측 가능한 작업이어야 합니다. 이 모델을 계속 사용하여 환경에 변경 사항을 계속 적용할 수 있습니다.\n\nDevOps는 당신이 가진 도구를 통해 쉽게 삶을 만드는 방법을 찾는 것입니다.\n\n# 엔지니어로서의 DevOps\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이전 레이어가 편하게 마련된 상태에서, 우리는 DevOps 하우스의 정상인 곳에 위치하게 되었습니다. DevOps 엔지니어들에게는 하위 레이어들이 강력한 기반을 제공하여 우리가 필요한 작업을 수행하고 전체 모델을 완성하는 데 도움이 됩니다.\n\n그러나 다소 상반된 방식으로, DevOps 엔지니어로 레이블이 지어지는 것이 산업 전반에 깔끔하게 부합되지는 않습니다. 예를 들어, 온프레미스 환경에 DevOps 모델을 적용하는 것에는 문제가 없습니다. 많은 개념적 도구들이 온프레미스 동등물을 갖고 있습니다. 또한 그렇지 않더라도 SaaS(Software as a Service) 기반 제공품을 사용하여 온프레미스 환경에서 배포를 수행할 수 있습니다.\n\n이 분야에서는 대부분 DevOps가 공용 클라우드에만 해당한다고 전체적으로 가정되어 왔지만, 그렇지 않습니다. DevOps 모델이 공용 클라우드에 편안하게 적용되지만, 온프레미스 환경에 적용할 수 있는 에지 케이스 시나리오들도 여전히 있습니다. 이것이 이 섹션의 요지로 이어지면서 누군가를 DevOps 엔지니어로 정의하기가 어렵다는 것을 알 수 있습니다.\n\n기술적 접근 방식 섹션에서는 IaC 및 CI/CD와 같은 개념을 다루었습니다. 이러한 개념을 기반으로 하는 도구들은 산업 전반에서 다양한 형태로 나타날 것입니다. 이는 이러한 개념을 기반으로 하는 (어떤 면에서) 도구의 수가 매우 많기 때문입니다. 예를 들어, 회사 A의 DevOps 엔지니어로는 GitHub (SCM), GitHub Actions (CI/CD) 및 Terraform (IaC) 도구를 사용할 수 있지만, 회사 B의 DevOps 엔지니어로는 BitBucket (SCM), Bamboo (CI/CD) 및 CloudFormation (AWS의 IaC)을 사용할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n공학 수준의 DevOps는 산업 전반에 걸쳐 일관성이 없다는 것을 설명하고 있습니다. 개인적으로, 몇 가지 환경을 경험해 보았는데, 이러한 환경은 DevOps 모델을 활용하지만 정확히 같은 도구를 사용하는 환경은 없습니다. 유사점이 많지만, 완전히 동일한 것은 아닙니다.\n\n또 다른 좋은 예로는 DevOps 모델을 공개 클라우드 공간에 적용할 때를 들 수 있습니다. 비슷한 개념을 가지고 있지만 사용하는 용어 및 개념 적용 방식에서 다소 차이가 있습니다.\n\n이로 인해 누군가를 DevOps 엔지니어로 규정하는 것이 어렵습니다. 실제로, DevOps 엔지니어 역할을 볼 때, 해당 회사와 해당 환경에 대한 역할일 것입니다. 여러 클라우드 및 여러 다른 기술 스택에 대해 이야기할 때 플랫폼 엔지니어가 관련될 수 있다는 주장도 나올 수 있습니다. 그럼에도 불구하고, DevOps 엔지니어라는 용어는 계속 사용되고, 이와 관련된 일정 수준의 모호성이 예상된다는 가정이 있습니다.\n\n# 결론\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n어떠한 에셋을 가져오거나 동적으로 추가할 때 table 태그를 Markdown 형식으로 변경하세요.\n","ogImage":{"url":"/assets/img/2024-05-23-WhatisDevOps_0.png"},"coverImage":"/assets/img/2024-05-23-WhatisDevOps_0.png","tag":["Tech"],"readingTime":14},{"title":"AWS CDK이 Terraform보다 뛰어난가요","description":"","date":"2024-05-23 14:35","slug":"2024-05-23-IsAWSCDKbetterthanTerraform","content":"\n이 기사에서는 클라우드 인프라를 유지하는 데 AWS CDK를 사용하는 장점과 이해를 돕기 위한 코드 스니펫에 대해 설명하겠습니다.\n\n![AWS CDK vs Terraform](/assets/img/2024-05-23-IsAWSCDKbetterthanTerraform_0.png)\n\n저는 AWS 클라우드 엔지니어로 일하고 있으며, AWS 환경 내에서 내 프로젝트의 클라우드 인프라를 관리하는 역할을 맡고 있습니다. 이 역할에서 저는 Terraform과 AWS CDK를 모두 활용해 왔습니다. 제 경험과 인사이트를 바탕으로, 각각의 우세한 점에 대해 제 생각을 공유하겠습니다.\n\n그러나 그에 앞서, IaC를 이해해 보겠습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# IaC(Infrastructure as Code)이란 무엇인가요?\n\nIaC 또는 Infrastructure as Code는 클라우드 인프라가 코드를 통해 프로비저닝되고 관리되는 소프트웨어 엔지니어링 방법론입니다. 이는 AWS 콘솔과 같은 수동 프로세스나 대화형 구성 도구를 통해 관리하는 것이 아니라 코드를 통해 인프라를 구축하는 방식을 의미합니다.\n\n간단히 말해, 콘솔을 통해 수동으로 생성하는 대신 인프라를 배포할 코드를 작성하는 것입니다. 이는 산업의 표준적인 실천 방법입니다. 현재 클라우드 인프라에 IaC를 적용하지 않는 조직은 없다고 생각해요.\n\nIaC를 적용하는 주요 이유는 재사용성, 일관성, 자동화 및 확장성입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 Terraform과 AWS CDK를 이해해 봅시다.\n\n## Terraform\n\nTerraform은 HashiCorp가 개발한 IaC 도구입니다. Terraform을 사용하면, 인프라 구성은 도메인 특화 언어인 HashiCorp 구성 언어 (HCL)를 사용하여 코드로 정의되어 버전 관리, 협업 및 자동화가 가능해집니다. Terraform은 그런 다양한 자원들의 전체 라이프사이클을 관리하며, 프로비저닝부터 업데이트, 파괴까지 정의된 설정 파일을 기반으로 합니다.\n\nS3 버킷을 생성하는 Terraform 스크립트의 간단한 예제입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n# main.tf\n\nprovider \"aws\" {\n  region = \"us-east-1\"  # 원하는 AWS 지역을 설정하세요\n}\n\nresource \"aws_s3_bucket\" \"my_bucket\" {\n  bucket = \"my-unique-bucket-name\"  # 원하는 버킷 이름을 설정하세요 (전역적으로 고유해야 함)\n}\n```\n\n# AWS CDK\n\nAWS CDK(Cloud Development Kit)는 AWS가 개발한 오픈소스 프로젝트로, 클라우드 리소스를 프로비저닝하기 위한 더 높은 수준의 추상화를 제공합니다.\n\nAWS CDK를 사용하면 Typescript, Python, Java, Go 등과 같은 익숙한 프로그래밍 언어를 사용하여 인프라 코드를 작성할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nAWS CDK를 사용하여 Typescript로 S3 버킷을 만드는 간단한 예제입니다.\n\n```typescript\nimport * as cdk from \"aws-cdk-lib\";\nimport { Stack, StackProps } from \"aws-cdk-lib\";\nimport * as s3 from \"aws-cdk-lib/aws-s3\";\n\nexport class MyS3BucketStack extends Stack {\n  constructor(scope: cdk.Construct, id: string, props?: StackProps) {\n    super(scope, id, props);\n\n    // S3 버킷 생성\n    new s3.Bucket(this, \"MyBucket\", {\n      bucketName: \"my-unique-bucket-name\", // 원하는 버킷 이름으로 변경하세요\n    });\n  }\n}\n\n// 애플리케이션 생성\nconst app = new cdk.App();\nnew MyS3BucketStack(app, \"MyS3BucketStack\");\n```\n\n이제 Terraform 대 AWS CDK 논쟁에 대해 깊게 알아보겠습니다.\n\n# Terraform vs AWS CDK\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그것말고는 실제로 표 스타일이 아니라지만, 저희가 그 내용을 잘 이해할 수 있도록 글의 형식으로 바꿔 드릴게요.\n\n한 가지씩 살펴보며 이 도구들의 차이를 이해해 보겠습니다. 몇 가지 예시를 들어 몇 가지 포인트를 검증하겠습니다. 비교를 더 잘 이해하기 위해 마지막 부분만 주목해주세요.\n\n## 지원\n\nTerraform은 클라우드에 중립적입니다. 즉, AWS, Azure, GCP, Alibaba 등 여러 클라우드 제공업체를 지원합니다.\n\nAWS CDK는 AWS 팀이 특히 AWS 클라우드용으로 만들었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만약 다양한 클라우드 공급업체에서 작업 중이라면, Terraform이 최상의 선택일 것입니다. 몇몇 클라우드 공급업체는 자체 IaC 도구인 Azure의 Bicep과 같은 것들이 있지만, 아직 채택 초기 단계에 있습니다.\n\n## 언어\n\n이전에 언급했듯이, Terraform은 Hashicorp에서 특별히 만든 HCL(HashiCorp Configuration Language)을 사용합니다. HCL은 JSON과 유사한 구성 언어로, 배우기 쉽습니다.\n\nAWS CDK는 Typescript, Python, Java 등과 같은 일반 목적 프로그래밍 언어를 지원합니다. 따라서 새로운 언어를 배울 필요가 없습니다. 익숙한 프로그래밍 언어를 선택하고 IaC 작성을 시작할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n프로그래밍 언어는 견고하고 유연합니다. IaC에서 OOPS, 함수형 프로그래밍과 같은 다양한 프로그래밍 패러다임을 사용할 수 있어요. 이는 DSL(Domain Specific language)보다 많은 장점을 가지고 있어요.\n\n## 상태 관리\n\n테라폼은 terraform.tfstate 파일을 사용해 배포된 리소스의 상태를 저장해요. 이 파일은 인프라의 현재 상태와 배포된 리소스 및 구성을 추적합니다. 일반적으로 이 상태 파일은 중앙에 저장되며, 종종 S3 버킷에 저장되어 다양한 팀 간의 협업을 용이하게 합니다.\n\n제 경험 상으로, 테라폼 상태를 관리하는 것이 꽤 복잡할 수 있다는 것을 알았어요. 프로젝트 내에서 상태의 드리프트를 마주치는 것이 일반적이며, 이를 해결하는 데 시간이 많이 소요될 수 있어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nAWS CDK는 상태가 없는 방식으로 작동합니다. 상태를 관리하기 위해 Git과 같은 버전 관리 시스템을 신뢰합니다. 배포할 때마다 최신 변경 사항을 가져와서 발생하는 모든 충돌을 해결하고 배포를 진행합니다. 이 방식은 깔끔하며 일관성을 유지합니다.\n\n## 버전 관리\n\n우리는 AWS가 계속해서 서비스를 확장하고 있다는 것에 익숙합니다. Terraform은 실행 파일로서 매번 최신 버전을 다운로드하고 업데이트해야 하므로 인프라 코드 업데이트가 어려운 작업이 됩니다. 우리 조직의 많은 프로젝트들은 여전히 오래된 버전에 의존하여 유지보수에 어려움을 겪고 있습니다.\n\n그에 반해 AWS CDK는 AWS가 직접 유지하고 있기 때문에 의존성을 간단히 관리하여 신속한 업데이트를 제공합니다. 이를 통해 시간이 지남에 따라 부드러운 전환과 더 적은 호환성 문제를 보장합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 연결성\n\n이해하기 위해, 바로 예제로 들어가 봅시다.\n\n예를 들어, S3 버킷에 객체가 생성될 때마다 람다를 트리거해야 하는 시나리오를 생각해 봅시다. 이를 위해 S3 이벤트 알림과 람다를 결합하여 이를 달성할 수 있습니다.\n\n아래 테라폼 코드를 살펴봅시다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nprovider \"aws\" {\n  region = \"us-east-1\"\n}\n\nresource \"aws_s3_bucket\" \"my_bucket\" {\n  bucket = \"my-bucket\"\n  acl    = \"private\"\n}\n\nresource \"aws_lambda_function\" \"my_function\" {\n  filename      = \"lambda_function_payload.zip\"\n  function_name = \"my-function\"\n  role          = aws_iam_role.lambda_exec_role.arn\n  handler       = \"index.handler\"\n  runtime       = \"nodejs14.x\"\n}\n\nresource \"aws_lambda_permission\" \"s3_invoke_permission\" {\n  statement_id  = \"AllowExecutionFromS3Bucket\"\n  action        = \"lambda:InvokeFunction\"\n  function_name = aws_lambda_function.my_function.function_name\n  principal     = \"s3.amazonaws.com\"\n  source_arn    = aws_s3_bucket_notification.s3_notification.arn\n}\n\nresource \"aws_s3_bucket_notification\" \"s3_notification\" {\n  bucket = aws_s3_bucket.my_bucket.id\n\n  lambda_function {\n    lambda_function_arn = aws_lambda_function.my_function.arn\n    events              = [\"s3:ObjectCreated:*\"]\n  }\n}\n```\n\nTerraform에서 모든 것을 리소스로 취급하는 개념을 따라갑니다. 먼저 Lambda 및 S3 버킷과 같은 리소스를 정의합니다. 그런 다음 Lambda 함수와 S3 객체 간의 연결을 설정하기 위해 권한을 부여해야 합니다. 이는 aws_lambda_permission 리소스를 사용하여 달성됩니다. 권한이 부여된 후 Lambda 함수와 S3 알림을 연결하는 데 또 다른 리소스인 aws_s3_bucket_notification이 필요합니다.\n\n이제 CDK 코드를 살펴봅시다.\n\n```typescript\nimport { aws_lambda_nodejs as lambda_nodejs } from \"aws-cdk-lib\";\nimport { aws_s3 as s3 } from \"aws-cdk-lib\";\nimport { aws_s3_notifications as s3notifications } from \"aws-cdk-lib\";\nimport { App, Stack, StackProps } from \"aws-cdk-lib\";\nimport { Construct } from \"constructs\";\n\nexport class MyStack extends Stack {\n  constructor(scope: Construct, id: string, props?: StackProps) {\n    super(scope, id, props);\n\n    // S3 버킷 생성\n    const bucket = new s3.Bucket(this, \"MyBucket\");\n\n    // Lambda 함수 생성\n    const fn = new lambda_nodejs.NodejsFunction(this, \"MyFunction\", {\n      runtime: lambda_nodejs.Runtime.NODEJS_14_X,\n      handler: \"handler\",\n      entry: \"lambda/index.ts\",\n    });\n\n    // S3 버킷에 대한 이벤트 소스 추가하여 Lambda 함수를 트리거합니다\n    fn.addEventSource(\n      new s3notifications.S3EventSource(bucket, {\n        events: [s3.EventType.OBJECT_CREATED],\n        filters: [{ prefix: \"uploads/\" }], // 필요에 따라 접두사 조정\n      })\n    );\n  }\n}\n\nconst app = new App();\nnew MyStack(app, \"MyStack\");\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 코드에서는 먼저 S3 버킷을 생성한 다음 람다 함수를 생성합니다. 람다 함수 코드 자체 안에서 S3를 이벤트 소스로 생성할 수 있음을 알 수 있습니다. 이것은 멋지며 프로그래밍의 힘을 보여줍니다.\n\n위의 코드는 모든 것을 Terraform의 리소스 블록을 사용하는 것보다 훨씬 이해하기 쉽습니다.\n\n## 보안\n\nAWS 내에서 보안을 논의할 때 IAM(Identity and Access Management)이 중심에 있습니다. IAM 역할과 정책은 사용자 액세스를 관리하고 서비스 간 안전한 통신을 용이하게 하는 데 사용되는 중요한 구성 요소입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n테라폼 코드에서는 aws_lambda_permission 리소스 블록을 사용하여 S3이 람다를 호출할 수 있도록 필요한 권한을 부여했습니다. 그러나 CDK 코드에서는 그런 작업을 하지 않았습니다. CDK가 IAM 권한을 내부적으로 설정하기 때문입니다. CDK는 필요한 권한만 부여하여 더 안전합니다.\n\n다른 예시를 살펴봅시다. 람다 함수가 DynamoDB 테이블에 데이터를 추가하는 경우를 생각해보겠습니다. 인프라 개발자로서 우리는 람다가 어떻게 작동하는지 신경 쓸 필요가 없습니다. 우리는 람다와 DDB 테이블을 생성하고 람다가 DynamoDB에 데이터를 쓸 수 있는 권한을 부여하기만 하면 됩니다.\n\n먼저 CDK 코드를 살펴보겠습니다.\n\n```js\nimport * as cdk from \"aws-cdk-lib\";\nimport { Construct } from \"constructs\";\nimport * as lambda from \"aws-cdk-lib/aws-lambda\";\nimport * as dynamodb from \"aws-cdk-lib/aws-dynamodb\";\n\nexport class MyStack extends cdk.Stack {\n  constructor(scope: Construct, id: string, props?: cdk.StackProps) {\n    super(scope, id, props);\n\n    // DynamoDB 테이블 생성\n    const table = new dynamodb.Table(this, \"MyTable\", {\n      partitionKey: { name: \"id\", type: dynamodb.AttributeType.STRING },\n      billingMode: dynamodb.BillingMode.PAY_PER_REQUEST,\n    });\n\n    // 람다 함수 생성\n    const myLambda = new lambda.Function(this, \"MyLambda\", {\n      code: lambda.Code.fromAsset(\"path/to/your/lambda/code\"), // 필요한 경우 경로를 조정\n      handler: \"index.handler\",\n      runtime: lambda.Runtime.NODEJS_14_X,\n    });\n\n    // 람다 함수에 DynamoDB 테이블 쓰기 권한 부여\n    table.grantReadWriteData(myLambda);\n  }\n}\n\nconst app = new cdk.App();\nnew MyStack(app, \"MyStack\");\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n마음에 드실 정도로 간결하고 깔끔한 코드입니다. 우리는 ddb 테이블과 람다를 생성했습니다. 그 다음으로는 ddb 테이블의 grantReadWriteData 메서드를 사용하여 해당 람다를 전달했습니다. 이것으로 모든 필요한 IAM 권한을 처리합니다.\n\n이제 Terraform에서 같은 코드를 살펴보겠습니다.\n\n```js\nprovider \"aws\" {\n  region = \"us-east-1\"\n}\n\nresource \"aws_dynamodb_table\" \"my_table\" {\n  name           = \"MyTable\"\n  billing_mode   = \"PAY_PER_REQUEST\"\n  hash_key       = \"id\"\n\n  attribute {\n    name = \"id\"\n    type = \"S\"\n  }\n}\n\nresource \"aws_iam_role\" \"lambda_execution_role\" {\n  name = \"lambda_execution_role\"\n\n  assume_role_policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Action = \"sts:AssumeRole\"\n        Effect = \"Allow\"\n        Principal = {\n          Service = \"lambda.amazonaws.com\"\n        }\n      },\n    ]\n  })\n}\n\nresource \"aws_iam_policy\" \"ddb_access_policy\" {\n  name        = \"ddb_access_policy\"\n  description = \"람다가 DynamoDB 테이블에 액세스할 수 있는 정책\"\n\n  policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Action = [\n          \"dynamodb:PutItem\",\n          \"dynamodb:UpdateItem\",\n          \"dynamodb:GetItem\",\n          \"dynamodb:Scan\",\n          \"dynamodb:Query\",\n          \"dynamodb:DeleteItem\"\n        ]\n        Effect   = \"Allow\"\n        Resource = aws_dynamodb_table.my_table.arn\n      },\n    ]\n  })\n}\n\nresource \"aws_iam_role_policy_attachment\" \"ddb_access_attachment\" {\n  role       = aws_iam_role.lambda_execution_role.name\n  policy_arn = aws_iam_policy.ddb_access_policy.arn\n}\n\nresource \"aws_lambda_function\" \"my_lambda\" {\n  function_name = \"MyLambdaFunction\"\n\n  filename         = \"이동/전달/패키지.zip의/경로\"\n  source_code_hash = filebase64sha256(\"이동/전달/패키지.zip의/경로\")\n  handler          = \"index.handler\"\n  runtime          = \"nodejs14.x\"\n  role             = aws_iam_role.lambda_execution_role.arn\n}\n```\n\n이 코드가 얼마나 지루한지 보이실 것입니다. 먼저 ddb 테이블을 생성하고, 그런 다음 람다 역할을 만듭니다. 이후 필요한 권한을 지정하는 정책을 만들고 해당 역할에 첨부합니다. 마지막으로 람다를 만들고 이 역할을 사용합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 코드는 너무 길고 정책 문서에서 수동으로 권한을 지정하고 있습니다. 이렇게 하면 올바른 권한을 지정하지 않으면 액세스 문제가 발생할 수 있습니다.\n\n## 통합\n\nAWS CDK는 AWS SDK와 강력한 통합을 가지고 있습니다. 더 잘 이해하기 위해 람다 함수를 예로 들어봅시다.\n\nAWS 람다가 리눅스를 지원하고 있으며 Amd 및 Arm 기반의 두 가지 CPU 아키텍처만 지원한다는 점을 알고 있습니다. 또한 AWS는 파이썬, Node.js, Go 등 다양한 런타임을 지원합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제, 만약 람다 함수가 ARM 기반과 파이썬 런타임을 사용하고 개발자가 Windows 기계에서 작업 중이라면, 그는 OS에서 번들을 생성할 수 없을 것입니다. Lambda 런타임과 호환되지 않을 것입니다. 이 문제는 ARM 기반 리눅스 이미지를 사용하여 코드를 빌드하는 파이프라인을 사용하면 해결할 수 있습니다.\n\nCDK에서는 코드를 쉽게 Lambda에 배포할 수 있습니다. AWS CDK는 다른 런타임에 대해 다른 함수를 제공합니다.\n\n```js\n@aws-cdk/aws-lambda-python-alpha » PythonFunction\naws-cdk-lib » aws_lambda_nodejs » NodejsFunction\n@aws-cdk/aws-lambda-go-alpha » GoFunction\n```\n\n패키지를 사용하면 람다 함수의 소스 코드를 가리킬 수 있고 코드를 번들로 만들 필요가 없습니다. 번들링 옵션을 직접 선택할 수 있습니다. Node.js의 경우 esbuild, 다른 런타임의 경우 docker가 좋은 선택지입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nprivate createGetData(): PythonFunction {\n    const fn = new PythonFunction(this, \"GetData\", {\n      entry: join(__dirname, \"..\", \"src\", \"get-data\"),\n      runtime: lambda.Runtime.PYTHON_3_11,\n      bundling: {\n        assetExcludes: [\".venv\"],\n        assetHashType: AssetHashType.SOURCE\n      },\n      timeout: Duration.minutes(2),\n      index: \"lambda_handler.py\",\n      handler: \"lambda_handler\",\n      memorySize: 128\n    });\n    return fn;\n  }\n```\n\n위의 코드에서는 람다 코드 위치를 entry 매개변수에만 지정했습니다. 런타임이 파이썬이기 때문에 lambda_handler.py 및 requirements.txt 두 파일만 필요합니다.\n\n이 작업은 Terraform에서 수행할 수 없습니다.\n\n참고: AWS에서 풀 스택 개발을 수행 중이거나 AWS SDK 및 동시에 AWS 인프라 생성에 작업 중인 경우에 매우 유용합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 마지막으로\n\n내 의견으로는, AWS CDK는 논의된 요소를 기반으로 Terraform을 능가한다고 생각합니다. 그러나 이것은 프로젝트와 조직의 특정 요구 사항에 따라 달라질 수 있는 주관적인 의견으로 인식합니다. 고유한 요구 사항과 상황에 기반하여 적합한 인프라스트럭처를 코드로 관리하는 도구(IaC)를 평가하고 선택하는 것이 중요합니다.\n\n# 내 프로젝트\n\n저는 Candletower(www.candletower.com)라는 프로젝트를 만들었습니다. 이 웹사이트는 캔들스틱 패턴 분석을 기반으로 한 주식 시장 분석을 제공합니다. 투자를 하거나 주식 시장에 입문하려는 경우, 이 웹사이트를 꼭 확인해보세요. 광고 없음, 로그인 없음, 완전 무료입니다. 여러분의 생각을 알려주세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n마지막으로, 읽어 주셔서 감사합니다!\n","ogImage":{"url":"/assets/img/2024-05-23-IsAWSCDKbetterthanTerraform_0.png"},"coverImage":"/assets/img/2024-05-23-IsAWSCDKbetterthanTerraform_0.png","tag":["Tech"],"readingTime":17},{"title":"ArgoCD와 Terraform으로 클라우드 리소스 조정하기","description":"","date":"2024-05-23 14:33","slug":"2024-05-23-OrchestratingCloudResourceswithArgoCDandTerraform","content":"\n## Terraform을 사용하여 ArgoCD 자동화하기\n\n최근 몇 년간 GitOps가 핫한 주제가 되었고, ArgoCD가 이 대화의 선두에 서 있습니다. GitOps를 많이 좋아하지만, 일상적인 작업에서는 GPC, AWS 및 온프레미스에서 클라우드 인프라를 관리해야 하며, 클라우드 리소스를 조정할 때 Terraform이 제 가장 좋아하는 도구입니다.\n\n![이미지](/assets/img/2024-05-23-OrchestratingCloudResourceswithArgoCDandTerraform_0.png)\n\n최근 RKE2 Kubernetes 클러스터를 사용하여 Cilium을 기본 네트워킹 솔루션으로 활용하는 프로젝트에 착수했습니다. 여러 테넌트 및 다양한 프로젝트를 효율적으로 처리하기 위해 애플리케이션 오케스트레이션을 ArgoCD로 선택했습니다. 이는 인기 있는 선택이지만, GitLab, GitHub 및 Bitbucket과 같은 다양한 버전 컨트롤 시스템에서 설정을 산재시킬 수 있는 선언적 애플리케이션 설정 방식을 가지고 있습니다. 전체적인 오케스트레이션 시스템을 구축하는 것은 많은 구성 요소를 고려해야 합니다. 이 게시물에서는 ArgoCD와 Terraform의 통합에 초점을 맞추어 이러한 도구들이 효과적인 애플리케이션 오케스트레이션을 위해 어떻게 원활하게 함께 작동하는지 강조하겠습니다. 이 접근 방식을 다양한 프로젝트에 성공적으로 통합하여 이해하기 쉽고 원활한 관리를 나타내었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# ArgoCD\n\n아르고 CD는 Kubernetes 애플리케이션의 선언적 지속적 전달을 위해 고안된 혁신적이고 오픈 소스 도구입니다. GitOps 지속적 전달 도구로서, ArgoCD는 Kubernetes 클러스터에서 애플리케이션의 배포와 관리를 자동화하고 최적화하는 데 도움을 줍니다. ArgoCD는 Git 저장소에서 애플리케이션의 원하는 상태를 정의하는 원칙에 따라 작동하며, 클러스터 내의 애플리케이션의 실제 상태가 선언된 상태로 수렴하도록 보장합니다.\n\n아르고 CD 인프라를 살펴보면, 여러 동적 구성 요소로 이루어진 모듈식으로 설계되었음을 알 수 있습니다. 한쪽에는 사용자 또는 CI 파이프라인이 새로운 애플리케이션의 배포를 시작하고, 다른 한쪽에는 실제 배포가 대상이 되는 Kubernetes 클러스터가 있습니다. ArgoCD는 선호하는 버전 관리 시스템(VCS)과 함께 중간 역할을 수행하여 설정을 사용자의 기호에 따라 구성할 수 있는 유연성을 제공합니다.\n\n이 유연성을 통해 회사 내 다른 팀의 액세스 수준을 자동화하고 제어하는 파트를 결정할 수 있습니다. 우리가 탐구할 설정은 생산 환경에서 효과적임이 입증되었으며, 이 프로젝트에 나중에 참여한 개발자들에게도 잘 받아들여졌습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 설계 선택 사항을 다루었으니, 기술적 세부 정보로 들어가 봅시다.\n\n# 요구 사항\n\n이 안내서는 기능적인 Kubernetes 클러스터가 있고 다음 전제 조건이 이미 설치되어 있다고 가정합니다:\n\n- Bitnami의 Sealed Secrets\n- Helm CLI 도구\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n특정 쿠버네티스 배포 버전은 중요한 요소가 아닙니다. 배포 애플리케이션에 필요한 액세스만 있으면 됩니다. 저는 Rancher Kubernetes Engine 2 (RKE2)를 선택했는데, 이는 가벼우면서 다재다능한 Kubernetes 배포로 알려져 있어 간편하고 사용하기 쉽다는 장점이 있습니다. 또한 최신 보안 기준을 준수합니다. RKE2에 대한 더 깊은 통찰력을 얻으려면 이전 기사를 살펴보시고, Cilium의 기능과 어떻게 매끄럽게 통합되는지 알아보세요:\n\nSealed Secrets를 사용하기로 한 결정은 온프레미스 배포로 인해 GCP, AWS 또는 Azure에서 제공하는 관리형 솔루션과 다릅니다. 클라우드 제공업체를 활용하는 경우에는 SOPS가 배포 관련 비밀을 암호화하고 안전하게 보관하는 데 주목할만한 대안으로 제시됩니다. 하지만 우리의 온프레미스 시나리오에서는 Kubernetes에 더 네이티브한 솔루션을 채용했습니다:\n\n마지막으로, 이론적으로 OpenTofu 또는 Ansible이 유사한 결과를 달성할 수 있겠지만, HashiCorp BSL 라이선스 변경에 문제가 없어 Terraform을 계속 사용하게 되었습니다. Terraform과 Ansible 사이를 선택하는 실용적인 지침이 필요하다면 이 리소스를 확인하세요:\n\n# Terraform\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n테이블 태그를 마크다운 형식으로 변경해드리겠습니다.\n\n| 번호 | 항목 | 설명        |\n| ---- | ---- | ----------- |\n| 1    | 이름 | 샘플 사용자 |\n| 2    | 나이 | 30세        |\n| 3    | 성별 | 여성        |\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- ArgoCD 및 Sealed-Secrets Helm 차트 설치하기\n- ArgoCD 구성이 저장된 저장소를 참조 및 연결하기\n- ArgoCD 구성 저장소에서 구성 적용하기\n\n이 작업에서의 합리성은 ArgoCD 구성의 잠재적 복잡성에 있습니다. 별도의 저장소에 이를 구성함으로써 구조화된 접근 방식을 취할 수 있게 되며, 이에 대해 다음 섹션에서 보다 자세히 다루겠습니다. 또한 Terraform 구성을 포함하는 저장소가 ArgoCD 뿐만 아니라 다양한 인프라 관련 배포를 포함할 수 있다는 점을 고려할 때, 명확성과 관리 용이성을 위해 구분된 ArgoCD 구성 저장소를 선택하는 것이 도움이 됩니다. 예를 들어, 본 문서에서 철저히 논의한 Terraform을 사용한 Teleport 배포를 고려해보세요:\n\n## 비밀 관리\n\nTerraform 스크립트에서 강조되는 중요한 부분은 SSH 비밀 키를 암호화하기 위해 Sealed-secrets를 설치하고 활용하는 것입니다. 이 키는 ArgoCD가 특정 GitHub 저장소에서 응용 프로그램 구성을 검색하고 연결하는 데 필수적입니다. 이를 구성하는 다양한 방법이 있지만, 우리는 Kubernetes Secret 개체에 argocd.argoproj.io/secret-type: repo-creds 라벨을 사용하기로 선택했습니다. 이 라벨은 특정 접두사로 시작하는 저장소, 예를 들어 git@github.com:`your-github-username`,는 본인 인증을 위해 이 시크릿(우리의 경우 SSH 비밀 키)을 사용할 수 있음을 ArgoCD에 알려줍니다. 보다 명확한 이해를 위해, 이 파일 ssh-secret.yaml의 완전한 구성을 확인해보세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```yaml\napiVersion: v1\nkind: Secret\nmetadata:\n  name: argoproj-ssh-creds\n  namespace: argocd\n  labels:\n    argocd.argoproj.io/secret-type: repo-creds\nstringData:\n  url: git@github.com:<your-github-username>\n  type: git\ndata:\n  sshPrivateKey: <your-super-secret-ssh-key>\n```\n\n그러나 이것을 직접 버전 컨트롤 시스템 (VCS)에 푸시하는 것은 SSH 개인 키가 모두에게 노출되어 보안 위험이 발생한다는 것을 의미합니다. 이 우려를 해소하기 위해 Sealed-secrets를 사용하여 암호화하는 예방 조치를 취합니다. 이 조치로 sealed-ssh-secret.yaml이 생성됩니다. 이 암호화된 파일은 실제로 이전에 언급한 Terraform 스크립트에 의해 적용되며 ssh-secret.yaml을 삭제할 수 있습니다. Sealed Secrets가 작동하는 방식의 복잡성에 대해 자세히 알아가는 것은 이 글의 범위를 벗어납니다만, 자세한 탐구를 위해 다음 글을 참조할 수 있습니다:\n\n이러한 단계로 Terraform의 중요한 작업이 완료되었습니다. 그러나 이 스크립트가 참조하는 ArgoCD 구성 리포지토리 내의 컨텐츠를 이해하는 데 필요한 최종 퍼즐 조각에는 여전히 주목해야 합니다.\n\n# ArgoCD Configuration Repository\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nArgoCD의 선언적 구성을 사용하면 재배포 가능성이 권장됩니다. 이 저장소는 Argo의 구성의 기본 소스 역할을 합니다. 특히, UI를 통해 앱을 만들 경우, ArgoCD를 재배포하는 동안 자동으로 다시 생성되지 않음을 염두에 두세요.\n\n이 저장소는 다음과 같은 구조를 따릅니다. 이는 주관적 선택이며 개인적으로 매력적이고 명확하다고 생각합니다:\n\n```js\n├── apps\n│   ├── demo\n│   │   ├── config.yaml\n├── config\n│   ├── add-config.yaml\n├── projects\n│   ├── demo.yaml\n├── repositories\n│   ├── demo-app-config.yaml\n├── argo-config.yaml\n├── argo-projects.yaml\n└── argo-repositories.yaml\n```\n\n각 파일의 합리적인 근거와 이 구조를 권장하는 이유를 명확히 하기 위해 각 파일의 내용을 살펴보겠습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- ./apps: 이 디렉토리는 ArgoCD Application 객체의 구성을 관리하고 응용 프로그램 구성이 저장된 외부 저장소를 가리킵니다. /apps/demo/config.yaml 파일의 예는 다음과 같습니다:\n\n```js\napiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  name: demo\nspec:\n  destination:\n    name: 'in-cluster'\n    namespace: <app-namespace>\n  source:\n    repoURL: '<GitHub-저장소-URL>'\n    targetRevision: <대상-브랜치>\n    path: './'\n  # 이 응용 프로그램이 속한 ArgoCD 프로젝트\n  project: demo\n```\n\n- ./config: 이 디렉토리는 ArgoCD 자체에 대한 추가 구성을 지정하는 데 사용됩니다. 예를 들어 회사 Slack 채널을 연결하여 응용 프로그램 관련 문제에 대해 개발자에게 알림을 보내는 알림 정책 구성이 포함됩니다.\n- ./projects: 이 디렉토리는 ArgoCD 프로젝트의 생성을 담당하며 다양한 응용 프로그램이 속할 수 있는 공동 공간 역할을 합니다.\n- ./repositories: 이 디렉토리는 응용 프로그램 구성을 가져올 수 있는 저장소를 whitelist로 지정하는 역할을 합니다.\n- ./argo-config.yaml, ./argo-projects.yaml 및 ./argo-repositories.yaml: Terraform으로 실행되는 ArgoCD Application 객체들입니다. 이들은 앞서 설명한 디렉토리에 정의된 ArgoCD 객체를 호출합니다. 다음은 argo-config.yaml의 예시이지만 다른 구성은 다른 파일들에도 적용됩니다:\n\n```js\n# Argo의 기본 구성. 이것은 helm/terraform 배포에 의해 설치된 앱입니다.\napiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  name: argo-config\n  namespace: argocd\nspec:\n  destination:\n    namespace: argocd\n    server: https://kubernetes.default.svc\n  project: default\n  # 각 저장소의 ./config 디렉토리에 대한 적용\n  source:\n    path: ./config\n    repoURL: <argocd-구성-저장소-URL>\n    targetRevision: <대상-브랜치>\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n데모 애플리케이션을 위한 구성 파일이 이러한 폴더에 추가되었습니다:\n\n- projects/demo.yaml:\n\n```js\napiVersion: argoproj.io/v1alpha1\nkind: AppProject\nmetadata:\n  name: demo\n  namespace: argocd\n  # 해당 프로젝트가 어떠한 애플리케이션에도 참조되지 않을 때까지 삭제되지 않도록 하는 파이널 라이저\n  finalizers:\n    - resources-finalizer.argocd.argoproj.io\nspec:\n  description: 데모 애플리케이션\n  # 어떠한 Git 저장소에서도 배포할 수 있는 매니페스트 허용\n  sourceRepos:\n    - '*'\n  # 모든 애플리케이션이 모든 사용 가능한 클러스터의 모든 네임스페이스에 배포할 수 있도록 허용\n  destinations:\n    - namespace: '*'\n      server: '*'\n  # 앱에 의해 배포될 수 있는 쿠버네티스 오브젝트를 결정하는 정책\n  clusterResourceWhitelist:\n    - group: ''\n      kind: Namespace\n    - group: ''\n      kind: Deployment\n    - group: ''\n      kind: Service\n---\n\napiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  name: demo-apps\n  namespace: argocd\nspec:\n  destination:\n    namespace: argocd\n    server: https://kubernetes.default.svc\n  project: default\n  sources:\n    - path: ./apps/demo\n      repoURL: <application-repository-url>\n      targetRevision: <target-branch>\n```\n\n- repositories/demo-app-config.yaml:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```yaml\napiVersion: v1\nkind: Secret\nmetadata:\n  labels:\n    argocd.argoproj.io/secret-type: repository\n  name: repo-kubernetes-config\n  namespace: argocd\nstringData:\n  name: \"demo-app-config\"\n  type: \"git\"\n  url: <application-repository-url>\n  # No need to specify SSH Private Key since\n  # this is done by repo-creds in Terraform and applicable to all\n```\n\n이 설명은 이 리포지토리 구조를 선택한 이유와 왜 Terraform 리포지토리와 분리되었는지에 대해 밝혀줍니다. 비교적 간단한 예시라도 이 구조를 선택한 이유를 알 수 있게 해줍니다.\n\n애플리케이션 소스 코드와 분리된 별도의 Kubernetes 매니페스트용 Git 리포지토리를 활용하는 것이 여러 가지 이유로 매우 권장됩니다:\n\n- 깔끔한 분리: 응용 프로그램 코드와 구성을 명확히 구분하여 매니페스트를 격리된 수정 없이 불필요한 CI 빌드를 발생시키지 않고 수정할 수 있게 합니다.\n- 감사 로그의 명확성: 구성 전용 리포지토리는 감사 목적을 위한 더 깨끗한 Git 히스토리를 보장하여 정기 개발 활동으로 인한 잡음을 제거합니다.\n- 마이크로서비스 배포: 단일 단위로 배포되는 여러 리포지토리의 서비스로 구성된 응용 프로그램의 경우 중앙 구성 리포지토리에 매니페스트를 저장함으로써 다양한 버전 관리 체계와 릴리스 주기를 수용할 수 있습니다.\n- 접근 제어: 소스 코드와 구성 리포지토리를 분리하면 개발 중인 응용 프로그램에 작업하는 개발자가 프로덕션 환경에 직접 액세스할 수 없도록 구분된 액세스 제어를 제공합니다.\n- CI 파이프라인의 안정성: 무한한 작업 루프와 Git 커밋 트리거를 피하기 위해 매니페스트 변경을 별도 리포지토리에 푸시하여 CI 파이프라인의 안정성을 유지합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그게 전체 설정이에요 — 우리가 인프라 자원으로 흔히 참조하는 것들을 위한 한 저장소, 각 인프라 구성요소에 특화된 구성을 위한 별도의 저장소, 그리고 애플리케이션 매니페스트를 위한 세 번째 저장소가 있어요. 진짜 멋지죠?\n\n# 결론\n\n클라우드 인프라 관리 분야에서는 ArgoCD가 주도하는 GitOps 접근 방식이 상당한 인기를 얻었습니다. 클라우드 자원을 조정하는 이 여정을 통해 Terraform은 다양한 자원을 처리하는 중심 요소로 나타납니다. RKE2 Kubernetes 클러스터를 활용한 실제 프로젝트를 살펴보면, ArgoCD에 중점을 두어 애플리케이션 조정을 간소화하며, 이를 위해 Terraform과의 통합을 통해 선언적인 설정을 위한 원활한 설정을 탐구합니다. 이 게시물은 설계 선택의 이성, 깨끗한 저장소 구조의 필요성, 그리고 조율 환경에서 ArgoCD와 Terraform 사이의 조화로운 상호작용에 대한 실용적 가이드를 제공합니다.\n","ogImage":{"url":"/assets/img/2024-05-23-OrchestratingCloudResourceswithArgoCDandTerraform_0.png"},"coverImage":"/assets/img/2024-05-23-OrchestratingCloudResourceswithArgoCDandTerraform_0.png","tag":["Tech"],"readingTime":12},{"title":"웹 애플리케이션을 위한 변경 불가능한 인프라 구축하기 단계별 가이드","description":"","date":"2024-05-23 14:32","slug":"2024-05-23-BuildinganImmutableInfrastructureforYourWebApplicationAStep-by-StepGuide","content":"\n# 소개\n\n소프트웨어 개발의 빠르게 변화하는 세계에서 일관성, 확장성 및 신뢰성을 보장하는 것이 중요합니다. 데브옵스에서 핵심 개념인 불변 인프라는 인프라 구성요소를 불변하게 만들어 이러한 요구 사항을 해결합니다. 이 블로그에서는 Docker, Kubernetes 및 Terraform을 사용하여 간단한 웹 애플리케이션을 위한 불변 인프라를 생성하는 방법을 안내하겠습니다.\n\nwww.linkedin.com/in/mohammedtalhakalimi\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 불변 인프라란?\n\n불변 인프라는 서버(또는 다른 인프라 구성 요소)를 배포한 후에는 결코 수정하지 않는 방식을 말합니다. 업데이트나 변경이 필요한 경우 새로운 서버를 빌드하고 배포하며 이전 서버는 해제됩니다. 이 접근 방식은 일관성과 반복성을 보장하며 구성 드리프트를 줄이고 의도하지 않은 변경의 위험을 최소화합니다.\n\nwww.linkedin.com/in/mohammedtalhakalimi\n\n# 프로젝트 개요\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 프로젝트에서는 Node.js 웹 애플리케이션을 위한 불변 인프라를 만들 것입니다. 이 프로젝트에는 다음이 포함됩니다:\n\n- Docker를 사용하여 애플리케이션을 컨테이너화하기\n- Kubernetes를 사용하여 배포를 조정하기\n- Terraform을 사용하여 인프라 프로비저닝 및 관리하기\n- CI/CD 파이프라인을 통해 빌드, 테스트 및 배포 프로세스 자동화하기\n\nwww.linkedin.com/in/mohammedtalhakalimi\n\n# 단계 1: Docker를 사용하여 애플리케이션을 컨테이너화하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n먼저 Docker를 사용하여 웹 애플리케이션을 컨테이너화해야 합니다. 프로젝트 디렉토리에 Dockerfile을 만들어주세요:\n\n```js\nDockerfile;\n```\n\n```js\n# 부모 이미지로 공식 Node.js 런타임 사용\nFROM node:14\n```\n\n```js\n# 작업 디렉토리 설정\nWORKDIR /usr/src/app\n# package.json 복사 및 종속성 설치\nCOPY package*.json ./\nRUN npm install\n# 나머지 애플리케이션 코드 복사\nCOPY . .\n# 애플리케이션 포트 노출\nEXPOSE 3000\n# 앱 실행 명령 정의\nCMD [\"node\", \"app.js\"]\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n도커 이미지를 빌드하고 테스트해보세요:\n\n```bash\ndocker build -t my-web-app .\ndocker run -p 3000:3000 my-web-app\n```\n\n# 단계 2: 쿠버네티스로 오케스트레이션하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음으로, 도커 컨테이너를 쿠버네티스 클러스터에 배포할 것입니다. deployment.yaml 및 service.yaml 파일을 생성해주세요:\n\n```yaml\n# deployment.yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: web-app-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: web-app\n  template:\n    metadata:\n      labels:\n        app: web-app\n    spec:\n      containers:\n        - name: web-app\n          image: my-web-app:latest\n          ports:\n            - containerPort: 3000\n```\n\n```yaml\n# service.yaml\napiVersion: v1\nkind: Service\nmetadata:\n  name: web-app-service\nspec:\n  selector:\n    app: web-app\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 3000\n  type: LoadBalancer\n```\n\n쿠버네티스 구성을 적용해주세요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```yaml\nkubectl apply -f deployment.yaml\nkubectl apply -f service.yaml\n```\n\nwww.linkedin.com/in/mohammedtalhakalimi\n\n# Step 3: Terraform으로 프로비저닝하기\n\n테라폼을 사용하여 쿠버네티스 클러스터를 프로비저닝할 것입니다. main.tf 파일을 작성해주세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n# main.tf\nprovider \"aws\" {\n  region = \"us-west-2\"\n}\n```\n\n```js\nmodule \"eks\" {\n  source          = \"terraform-aws-modules/eks/aws\"\n  cluster_name    = \"my-cluster\"\n  cluster_version = \"1.20\"\n  subnets         = [\"subnet-0123456789abcdef0\", \"subnet-0123456789abcdef1\"]\n  vpc_id          = \"vpc-0123456789abcdef0\"\n  node_groups = {\n    my-node-group = {\n      desired_capacity = 2\n      max_capacity     = 3\n      min_capacity     = 1\n      instance_type = \"t3.medium\"\n    }\n  }\n}\noutput \"cluster_endpoint\" {\n  value = module.eks.cluster_endpoint\n}\n```\n\n테라폼 구성을 초기화하고 적용하십시오:\n\n```js\nterraform init\nterraform apply\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n새 클러스터를 사용하도록 kubectl을 구성하세요:\n\n```bash\naws eks --region us-west-2 update-kubeconfig --name my-cluster\n```\n\nLinkedIn 프로필: www.linkedin.com/in/mohammedtalhakalimi\n\n# 단계 4: CI/CD로 자동화\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n마지막으로, GitHub Actions를 사용하여 CI/CD 파이프라인을 설정할 것입니다. .github/workflows/ci-cd-pipeline.yaml 파일을 만들어주세요:\n\n```yaml\n# .github/workflows/ci-cd-pipeline.yaml\nname: CI/CD Pipeline\n```\n\n```yaml\non:\n  push:\n    branches:\n      - main\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Set up Docker Buildx\n        uses: docker/setup-buildx-action@v1\n      - name: Login to Docker Hub\n        uses: docker/login-action@v1\n        with:\n          username: ${secrets.DOCKER_USERNAME}\n          password: ${secrets.DOCKER_PASSWORD}\n      - name: Build and push Docker image\n        run: |\n          docker build -t my-web-app:latest .\n          docker tag my-web-app:latest ${secrets.DOCKER_USERNAME}/my-web-app:latest\n          docker push ${secrets.DOCKER_USERNAME}/my-web-app:latest\n  deploy:\n    runs-on: ubuntu-latest\n    needs: build\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Set up kubectl\n        uses: azure/setup-kubectl@v1\n        with:\n          version: \"v1.20.0\"\n      - name: Deploy to Kubernetes\n        run: |\n          kubectl apply -f deployment.yaml\n          kubectl apply -f service.yaml\n```\n\nwww.linkedin.com/in/mohammedtalhakalimi\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 결론\n\n위 단계를 따라 웹 애플리케이션을 위한 불변의 인프라를 구축했습니다. 이 방식을 통해 배포가 일관적이고 확장 가능하며 신뢰할 수 있음을 보장할 수 있습니다. 불변의 인프라 관행을 준수함으로써 응용 프로그램의 안정성과 관리 용이성을 크게 향상시킬 수 있습니다.\n\n의견이나 경험을 댓글로 공유해 주세요. 즐거운 코딩 되세요!\n\nwww.linkedin.com/in/mohammedtalhakalimi\n","ogImage":{"url":"/assets/img/2024-05-23-BuildinganImmutableInfrastructureforYourWebApplicationAStep-by-StepGuide_0.png"},"coverImage":"/assets/img/2024-05-23-BuildinganImmutableInfrastructureforYourWebApplicationAStep-by-StepGuide_0.png","tag":["Tech"],"readingTime":8}],"page":"71","totalPageCount":120,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":3},"__N_SSG":true}