{"pageProps":{"posts":[{"title":"제18장 CompactMapValues 사용 방법 Swift","description":"","date":"2024-06-23 21:28","slug":"2024-06-23-Chapter18CompactMapValues","content":"\nCompactMapValues 개요\n\n![이미지](/assets/img/2024-06-23-Chapter18CompactMapValues_0.png)\n\ncompactMapValues 함수는 Swift에서 제공되는 고차 함수로, 사전(Dictionary)의 값을 변환하고 결과적으로 발생하는 nil 값을 제거합니다.\n\n이 함수는 주어진 클로저를 사전의 각 값에 적용하고, nil이 아닌 결과만을 포함하는 새로운 사전을 반환합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 함수는 사전(Dictionary)에서 데이터를 정리하고 변환할 때 특히 유용합니다. 여기서는 유효하지 않거나 누락된 값들을 걸러내면서 기존 값들을 변환하는 작업을 할 수 있습니다.\n\n예시:\n\n```js\nlet data: [String: String] = [\"name\": \"Alice\", \"age\": \"25\", \"height\": \"five-five\"]\nlet numericData = data.compactMapValues { Int($0) }\nprint(numericData) // 결과: [\"age\": 25]\n```\n\n설명:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- let data: [String: String] = [\"name\": \"Alice\", \"age\": \"25\", \"height\": \"five-five\"] : 문자열 키와 값으로 구성된 딕셔너리를 정의합니다.\n- let numericData = data.compactMapValues { Int($0) }: compactMapValues 함수를 사용하여 딕셔너리의 값을 변환하며, 각 값을 정수로 변환을 시도합니다.\n- 변환에 실패하면 nil 값을 제거합니다.\n- print(numericData): 결과 딕셔너리 [\"age\": 25]를 출력합니다.\n\n실행 시간 복잡도: compactMapValues 함수의 시간 복잡도는 O(n)이며, 여기서 \\( n \\)은 딕셔너리의 요소 수입니다.\n\n이 복잡성은 함수가 각 값에 대해 정확히 한 번 처리하기 때문에 발생합니다.\n\n실제 사용 사례\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n사용자 입력의 Dictionary를 정리하고 변환하기 위해 CompactMapValues를 사용하기:\n\n```js\nlet userInputs: [String: String] = [\"username\": \"david\", \"age\": \"twenty-five\", \"score\": \"42\", \"height\": \"170\"]\nlet validData = userInputs.compactMapValues { Int($0) }\nprint(validData) // 출력은 [\"score\": 42, \"height\": 170] 입니다.\n```\n\n해설:\n\n- let userInputs: [String: String] = [\"username\": \"john_doe\", \"age\": \"twenty-five\", \"score\": \"42\", \"height\": \"170\"]: string 키와 사용자 입력을 나타내는 값으로 이루어진 Dictionary를 정의합니다.\n- let validData = userInputs.compactMapValues ' Int($0) ': compactMapValues 함수를 사용하여 Dictionary의 값을 변환하며 각 값을 정수로 변환을 시도합니다.\n- 변환에 실패하면 nil 값이 제거됩니다.\n- print(validData): 결과인 딕셔너리 [\"score\": 42, \"height\": 170]를 출력합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n주석: compactMapValues 함수는 특히 사용자 입력이나 외부 소스에서 가져온 데이터와 같이 유효하지 않거나 숫자가 아닌 값이 포함될 수 있는 경우에 딕셔너리를 변환하고 정리하는 데 특히 유용합니다.\n\ncompactMapValues를 사용하면 기존 값의 변환과 함께 유효하지 않은 항목을 걸러내어 단일하고 표현력 있는 문장으로 처리할 수 있습니다.\n\n결론\n\ncompactMapValues 함수는 Swift에서 강력한 고차 함수로, 딕셔너리의 값들을 변환하고 정리하여 nil 결과를 제거할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n시간 복잡도가 O(n)인 이것은 데이터 클리닝 및 변환 작업을 효율적으로 수행하는 방법을 제공합니다.\n\n이것은 예정된 무료 eBook 중 일부이며, 1분 만에 스위프트 데이터 구조 및 알고리즘 마스터하기를 시작하세요. Beginner Swift에서 구독하세요.\n","ogImage":{"url":"/assets/img/2024-06-23-Chapter18CompactMapValues_0.png"},"coverImage":"/assets/img/2024-06-23-Chapter18CompactMapValues_0.png","tag":["Tech"],"readingTime":4},{"title":"iOS 개발에서 Deep Link와 Universal Link 차이점 이해하기","description":"","date":"2024-06-23 21:27","slug":"2024-06-23-DeepLinksandUniversalLinksiniOSdevelopment","content":"\n# 이것은 인기 있는 iOS 인터뷰 질문입니다: Swift에서 Deep Linking과 Universal Linking 간의 주요 차이점을 설명해주세요. 차이를 알고 있는 것이 좋습니다.\n\n가끔 앱에서 처리할 수 있는 추가 작업이 필요할 때가 있습니다. 사용자에게 중요한 정보를 알리기 위해 푸시 알림을 사용할 수 있습니다. 그러나 앱을 시작하거나 데이터를 iOS 앱으로 전달하는 다른 방법도 있습니다. 오늘은 Deep Link와 Universal Link 간의 주요 차이점을 알려드리려고 합니다. Swift에서 어떻게 작동하는지 그리고 iOS 기기에서 어떻게 처리될 수 있는지 살펴보겠습니다.\n\nDeep Link와 Universal Link를 사용하면 이메일(비밀번호 변경 링크), 텍스트 메시지 또는 웹사이트에서 앱을 시작할 수 있습니다.\n\n앱 내에서 사용할 수 있는 추가 데이터를 포함할 수 있습니다. 링크를 통해 사용자에게 제공될 특정 뷰를 시작할 수 있습니다. 로그인, 비밀번호 변경 및 기타 작업을 자동화하는 데 매우 유용할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n물론 딥 링크와 유니버설 링크 모두 제한 사항과 취약점이 있습니다.\n\n## 딥 링크\n\n딥 링크의 주요 기능은 구현이 쉽다는 것입니다.\n\n백엔드 변경이나 새로운 엔드포인트 매핑이 필요하지 않습니다. 앱에 딥 링크를 추가하는 것은 시간이 많이 소요되지 않습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n하지만 사용 허가를 요청하거나 Android에서 문제가 발생하는 것과 같은 단점도 있습니다. Deep link는 주로 iOS용으로 설계되었기 때문에 이러한 문제가 발생할 수 있습니다.\n\n다른 한편으로는 Apple은 새로운 iOS 버전에서 Deep link를 사용하지 않도록 권장하고 있습니다. 또한 보안 문제로 인해 Deep link 사용을 권장하지 않습니다.\n\n# Deep links in Swift apps: Implementing URL Schemes\n\n위 내용을 염두에 두며, Swift 앱에서 Deep link를 구현하는 방법은 무엇인가요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-06-23-DeepLinksandUniversalLinksiniOSdevelopment_0.png\" />\n\n먼저 사용하려는 앱 스키마를 추가해야 합니다. 이를 위해 Xcode의 프로젝트 설정으로 이동한 다음 Info로 이동하세요. URL 유형이라는 섹션에서 새 URL 스키마를 추가할 수 있습니다. com.myAppAddress와 같은 URL 스킴을 포함해야 합니다.\n\n이를 추가한 후 우리의 애플리케이션이 인식할 수 있는 간단한 URL 링크를 만들 수 있습니다. com.myAppAddress로 시작하고 ://myProfile과 같이 이어져야 합니다.\n\n다음과 같이:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\ncom.myAppAddress://reset_password com.myAppAddress://open_custom_view_controller\n\n이것은 쉬웠어요. 이제 이 프로필들을 구현해야 합니다. 이를 AppDelegate 또는 SceneDelegate를 통해 할 수 있습니다. 우리의 코드는 이렇게 보일 것입니다:\n\n```js\nlet myUrlScheme = “com.myAppAddress”\n```\n\n```js\nfunc application(_ app: UIApplication, open url: URL,\n                 options: [UIApplicationOpenURLOptionsKey : Any] = [:]) -> Bool {\n    if let scheme = url.scheme,\n        scheme.localizedCaseInsensitiveCompare(myUrlScheme) == .orderedSame,\n        let view = url.host {\n        var parameters: [String: String] = [:]\n        URLComponents(url: url, resolvingAgainstBaseURL: false)?.queryItems?.forEach {\n            parameters[$0.name] = $0.value\n        }\n        redirect(to: view, with: parameters)\n    }\n    return true\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nURL을 출력하면 다음과 같이 나옵니다:\n\nurl.scheme = \"com.myAppAddress\" url.host = \"open_custom_view_controller\" (또는 \"://\" 이후에 추가될 내용)\n\nURL 스키마를 통해 매개변수를 추가할 수도 있습니다 (위의 코드를 참고하세요).\n\n이 능력 덕분에 링크로부터 특정 정보를 가져올 수 있습니다. 예를 들어 비밀번호를 재설정하고 싶다면, 다음과 같은 링크가 될 것입니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 표를 Markdown 형식으로 변경해주세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제, 웹 사이트와 앱 간 협력을 처리하기 위해 Apple이 현재 홍보하는 유니버설 링크로 넘어갑시다. 이것들은 보안이 더 우수하지만 구현이 더 어렵습니다.\n\n링크를 생성하는 방법에도 차이가 있습니다. 우리는 앱 구현과 특정 URL 링크뿐만 아니라 서버 측에 특정 JSON 파일을 생성 및 유지해야 합니다.\n\n![Universal Links](/assets/img/2024-06-23-DeepLinksandUniversalLinksiniOSdevelopment_1.png)\n\n# 유니버설 링크: iOS 앱에 JSON 추가\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nApple의 요구 사항으로 인해 JSON 파일을 작성해야합니다. 예를 들어:\n\n```js\n{\n    “applinks”: {\n        “apps”: [],\n        “details”: [\n            {\n                “appID”: “teamID.appID.specific.address”,\n                “paths”: [“*”],\n            }\n        ]\n    }\n}\n```\n\n위에서 보듯이, appID 필드에는 두 요소가 필요합니다:\n\n- 앱의 teamID,\n- 그리고 앱의 appID.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그러므로 teamID가 123456이고 appID가 com.myApp인 경우, JSON 파일에서 사용되는 결과는 123456.com.myApp가 될 것입니다.\n\npaths 필드에서는 iOS 앱에서 처리될 경로를 추가할 수 있습니다. URL Schemes의 host와 같습니다. Apple은 더 많은 기능을 제공합니다. paths에서는 특정 문자열을 포함/제외할 수 있는 정규식 솔루션을 구현할 수 있습니다.\n\n서버 측에 JSON 파일을 추가한 후에는 앱으로 이동해야 합니다.\n\n먼저 프로젝트 설정에서 새로운 능력을 추가해야 합니다. Associated domains에 대해 이야기합니다. 활성화한 후에는 링크를 처리하는 URL을 추가해야 합니다. 예를 들어, app links:myApp.com과 같습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 작업이 완료되면 Safari에서 URL 주소를 클릭하면 우리 앱이 시작됩니다.\n\n이제 딥 링크와 마찬가지로 수신된 링크를 처리해야 합니다. AppDelegate로 이동해보겠습니다. 새 함수를 추가해야 합니다.\n\n```swift\npublic func application(_ application: UIApplication,\n                        continue userActivity: NSUserActivity,\n                        restorationHandler: @escaping ([Any]?) -> Void) -> Bool {\n    if let url = userActivity.webpageURL {\n        var view = url.lastPathComponent\n        var parameters: [String: String] = [:]\n        URLComponents(url: url, resolvingAgainstBaseURL: false)?.queryItems?.forEach {\n            parameters[$0.name] = $0.value\n        }\n        redirect(to: view, with: parameters)\n    }\n    return true\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# iOS에서의 깊고 범용적인 링크: 각주\n\n보시다시피, URL Scheme과 유사하게, 본 솔루션에서는 앱에서 사용할 수 있는 매개변수가 있습니다. 하지만 이와 별도로, 유니버셜 링크와 URL Scheme의 주요 차이점은 전자가 사용자가 앱을 설치하지 않은 경우에도 사용할 수 있다는 것입니다. 그 경우에는 Safari가 링크를 열게 됩니다. 이는 기본 랜딩 페이지로 이어질 수도 있고, 우리 앱을 다운로드하기 위한 AppStore로 리디렉션될 수도 있습니다.\n\nSwift 앱에서의 깊고 범용 링크에 도움이 될 수 있는 이 간단한 자습서가 도움이 되기를 바랍니다. 궁금한 사항이나 우려 사항이 있으면 언제든지 연락해 주세요!\n","ogImage":{"url":"/assets/img/2024-06-23-DeepLinksandUniversalLinksiniOSdevelopment_0.png"},"coverImage":"/assets/img/2024-06-23-DeepLinksandUniversalLinksiniOSdevelopment_0.png","tag":["Tech"],"readingTime":8},{"title":"Swift의 모던 동시성 프로그래밍 Async Await와 Alamofire 활용 방법","description":"","date":"2024-06-23 21:26","slug":"2024-06-23-ModernConcurrencyinSwiftAsyncAwaitAlamofire","content":"\n![이미지](/assets/img/2024-06-23-ModernConcurrencyinSwiftAsyncAwaitAlamofire_0.png)\n\n안녕하세요! 모두 다시 만나서 반가워요! 이번 달에는 async/await에 대해 배운 내용을 Alamofire 네트워크 라이브러리에 적용해볼 거에요. 이 시리즈의 첫 번째 부분을 아직 읽지 못했다면, 여기서 잠시 멈추시고 읽어보시는 걸 강력히 추천드려요. 이렇게 하면 속도를 낼 수 있어요.\n\n# Alamofire란 무엇인가요?\n\nAlamofire는 iOS 개발 커뮤니티에서 널리 사용되는 네트워크 라이브러리로, 네트워크 요청을 처리하는 우아한 솔루션을 제공해요. 아마도 이미 Alamofire와 iOS 개발에서의 사용법에 익숙하실 거예요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# Alamofire을 사용한 Async-Await 구현\n\n첫 번째 부분에서 배운 개념들을 Alamofire로 통합하고, 작업 실행 및 오류 처리에 초점을 맞춥니다. 또한, 액터가 어떻게 병렬성 관리를 향상시킬 수 있는지 살펴볼 것입니다.\n\n## 네트워크 매니저 생성\n\n다음은 Alamofire를 사용하여 API 요청을 초기화하는 기본 코드 스니펫입니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n// Alamofire를 사용하여 API 요청을 수행하는 코드 조각입니다.\nclass NetworkManager {\n    func request<T: Decodable>(\n        method: HTTPMethod,\n        url: String,\n        headers: [String: String],\n        params: Parameters?,\n        of type: T.Type,\n        completion: @escaping (Result<T, Error>) -> Void\n    ) {\n        // 인코딩 설정\n        var encoding: ParameterEncoding = JSONEncoding.default\n        switch method {\n        case .post:\n            encoding = JSONEncoding.default\n        case .get:\n            encoding = URLEncoding.default\n        default:\n            encoding = JSONEncoding.default\n        }\n\n        AF.request(\n            url,\n            method: method,\n            parameters: params,\n            encoding: encoding,\n            headers: HTTPHeaders(headers)\n        ).responseDecodable(of: type) { response in\n            switch response.result {\n            case let .success(data):\n                completion(.success(data))\n\n            case let .failure(error):\n                completion(.failure(error))\n            }\n        }\n    }\n}\n```\n\n이제 이 함수에 async-await을 적용해 보겠습니다:\n\n```js\n// Async-await을 사용하여 API 요청을 수행하는 코드 조각입니다.\nclass NetworkManager {\n    func request<T: Decodable>(\n        method: HTTPMethod,\n        url: String,\n        headers: [String: String],\n        params: Parameters?,\n        of type: T.Type\n    ) async throws -> T {\n        // 인코딩 설정\n        var encoding: ParameterEncoding = JSONEncoding.default\n        switch method {\n        case .post:\n            encoding = JSONEncoding.default\n        case .get:\n            encoding = URLEncoding.default\n        default:\n            encoding = JSONEncoding.default\n        }\n\n        // 반드시 continuation을 한 번만 재개해야 합니다.\n        return try await withCheckedThrowingContinuation { continuation in\n            AF.request(\n                url,\n                method: method,\n                parameters: params,\n                encoding: encoding,\n                headers: HTTPHeaders(headers)\n            ).responseDecodable(of: type) { response in\n                switch response.result {\n                case let .success(data):\n                    continuation.resume(returning: data)\n\n                case let .failure(error):\n                    continuation.resume(throwing: error)\n                }\n            }\n        }\n    }\n}\n```\n\n하지만 여기서 멈추지 않고, 더 나아가서 actor를 도입하여 접근 방식을 더욱 세련되게 만들 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 배우자들 소개\n\n배우들은 여러 스레드 간에 안전하게 상태를 공유하기 위해 사용할 수 있는 동시적인 객체 유형입니다. 배우들은 코드를 연속적으로 실행한다는 것이 보장되어 있어서, 동시적인 응용 프로그램에서 공유 상태를 관리하는 데 이상적입니다.\n\nasync/await를 사용하여 배우들을 사용하려면, 간단히 배우를 async로 선언하고, 배우의 async 메서드를 호출하기 위해 await를 사용하면 됩니다.\n\n```js\n// 배우 사용을 보여주는 코드 스니펫\n배우 NetworkManager {\n    func request<T: Decodable>(\n        method: HTTPMethod,\n        url: String,\n        headers: [String: String],\n        params: Parameters?,\n        of type: T.Type\n    ) async throws -> T {\n        // 인코딩 설정\n        var encoding: ParameterEncoding = JSONEncoding.default\n        switch method {\n        case .post:\n            encoding = JSONEncoding.default\n        case .get:\n            encoding = URLEncoding.default\n        default:\n            encoding = JSONEncoding.default\n        }\n\n        // 계속을 정확히 한 번만 재개해야 합니다.\n        return try await withCheckedThrowingContinuation { continuation in\n            AF.request(\n                url,\n                method: method,\n                parameters: params,\n                encoding: encoding,\n                headers: HTTPHeaders(headers)\n            ).responseDecodable(of: type) { response in\n                switch response.result {\n                case let .success(data):\n                    continuation.resume(returning: data)\n\n                case let .failure(error):\n                    continuation.resume(throwing: error)\n                }\n            }\n        }\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n네트워크 매니저가 이제 async 액터로 변경되었으므로 안전하고 동시성 있는 방식으로 상호 작용하는 방법을 소개합니다:\n\n```js\n// 코드의 어딘가.\nlet network = NetworkManager()\n\n...\n\nfunc getPeople() async -> Result<ApiPeopleResponse, Error> {\n    do {\n        // API 요청 보내기\n        let response = try await network.request(method: .get, url: \"https://swapi.dev/api/people\", headers: [:], params: [:], of: ApiPeopleResponse.self)\n        return .success(response)\n    } catch {\n        return .failure(error)\n    }\n}\n\n...\n\n// 코드 어딘가에서 비동기 함수 getPeople 호출합니다.\nlet result = await getPeople()\nswitch result {\ncase .success(let response):\n    // 여기에서 데이터 응답 처리\n    break\n\ncase .failure(let error):\n    // 실패한 응답 처리.\n    print(\"불러오기 실패: \\(error.localizedDescription)\")\n    break\n}\n```\n\n아래는 async/await와 함께 작업(tasks)을 활용하는 방법을 간단히 살펴봅니다:\n\n```js\n// async/await와 Task를 함께 사용하는 예제\nfunc getPeople(completion: @escaping (Result<ApiPeopleResponse, Error>) -> Void) {\n    Task {\n        do {\n            // API 요청 보내기\n            let response = try await network.request(method: .get, url: \"https://swapi.dev/api/people\", headers: [:], params: [:], of: ApiPeopleResponse.self)\n            await MainActor.run {\n                completion(.success(response))\n            }\n        } catch {\n            await MainActor.run {\n                completion(.failure(error))\n            }\n        }\n    }\n}\n\n...\n\n// 코드 어딘가에서 완료 함수인 getPeople 호출합니다.\ngetPeople { result in\n    switch result {\n    case .success(let response):\n        // 여기에서 데이터 응답 처리\n        break\n    case .failure(let error):\n        // 실패한 응답 처리.\n        print(\"불러오기 실패: \\(error.localizedDescription)\")\n        break\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 결론\n\nSwift에서의 Async/await는 깔끔하고 유지보수 가능한 비동기 코드 작성을 위한 가능성을 열어줍니다. 이 글을 통해 우리는 이러한 기능에 대해 더 깊게 파고들어 보았고, 에러 처리, 취소, 그리고 중요한 동시성과 같은 고급 기능에 초점을 맞췄습니다. 이러한 개념을 Alamofire와 통합하면 iOS 애플리케이션의 성능과 신뢰성을 향상시킬 수 있습니다. 항상 강조하듯이, 연습이 중요하니 여러분들의 프로젝트에서 이러한 개념을 실험해보는 것을 적극 권장합니다.\n\nActor와 task의 사용은 공유 리소스 관리와 효율적인 동시 작업 실행에 대한 우리의 이해를 더욱 확고하게 만들어줍니다. 앞으로 나아가면서 이 경험이 우리에게 계속 더 나은 iOS 개발의 최신 동향을 탐색하고 통합하는 데 영감을 줄 것입니다. 이를 통해 우리의 기술과 애플리케이션이 최신 기술과 함께 선도적인 위치를 유지할 수 있도록 하세요.\n\n![이미지](/assets/img/2024-06-23-ModernConcurrencyinSwiftAsyncAwaitAlamofire_1.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\niOS 엔지니어링에 대한 더 많은 통찰을 기대해주세요! 코딩을 즐기며 행복하게 일하세요! 🌟👩‍💻👨‍💻📱\n","ogImage":{"url":"/assets/img/2024-06-23-ModernConcurrencyinSwiftAsyncAwaitAlamofire_0.png"},"coverImage":"/assets/img/2024-06-23-ModernConcurrencyinSwiftAsyncAwaitAlamofire_0.png","tag":["Tech"],"readingTime":9},{"title":"Swift 동시성 메모리 관리에서 Task Cancellation과 Weak Self의 비교","description":"","date":"2024-06-23 21:25","slug":"2024-06-23-SwiftConcurrencyTaskCancellationvsWeakSelfforMemoryManagement","content":"\n![Image](/assets/img/2024-06-23-SwiftConcurrencyTaskCancellationvsWeakSelfforMemoryManagement_0.png)\n\nSwift 개발에 관련해서, 메모리 관리를 이해하는 것은 복잡한 퍼즐을 해결하는 것과 같습니다. 이러한 퍼즐의 핵심에는 클로저와 비동기 작업을 처리하는 동안 메모리 누수에 빠지지 않는 것이라는 도전이 있습니다. 많은 개발자들이 리테인 싸이클을 피하는 데 사용해온 약한 참조(weak self) 개념은 클로저에서 탁월한 해결책이었습니다. 하지만 Swift의 동시성 모델, 특히 Task에서 이 실천이 원활하게 이어지는지 궁금할 것입니다. 실용적인 코드 예제와 통찰을 통해, 효율적인 Swift 프로그래밍을 위한 길을 밝혀보겠습니다.\n\n# 다루는 주제\n\n- 클로저에서 왜 weak self가 필요하며, 사용하지 않으면 어떻게 되는지?\n- Task 블록에서도 실제로 weak self가 필요한가?\n- Swift 동시성을 사용할 때 리테인 싸이클을 피하기 위해 어떤 조치를 취할 수 있는가?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 주요 포인트\n\n- 클로저에서의 순환 참조와 약한 self 사용의 중요성을 이해하세요.\n- 비동기 작업이 self를 강하게 캡처하면 작업 블록도 순환 참조를 생성할 수 있습니다.\n- 컴파일러는 클로저와 달리 작업 블록에서 명시적 self 사용을 요구하지 않습니다.\n- 약한 self에만 의존하지 않고 메모리를 효율적으로 관리할 대안으로 작업 취소를 사용할 수 있습니다.\n- 비동기 작업을 다룰 때 ViewModel에서 순환 참조를 방지하기 위해 작업 취소를 구현하세요.\n\n# 클로저에서의 'Weak Self' 딜레마\n\n약한 self의 필요성을 이해하려면 먼저 Swift에서 클로저의 세계로 들어가 보겠습니다. 클로저는 참조 타입이며 강하게 인스턴스(예: self)를 캡처하고 유지할 수 있습니다. 이로 인해 잠재적인 순환 참조가 발생할 수 있습니다. 이는 객체가 self를 참조하는 클로저를 소유하고, 그 클로저가 객체 자체에 의해 소유되는 경우 발생하여 서로 해제될 수 없는 루프를 만듭니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n전통적인 시나리오:\n\n```swift\nclass Repository {\n    func remoteAPICallWithClosure(onComplete: @escaping (String) -> Void) {\n        DispatchQueue.main.asyncAfter(deadline: .now() + 4) {\n            onComplete(\"완료\")\n        }\n    }\n}\n\nclass SomeBigViewModel {\n    private let repository = Repository()\n    private var result = \"\"\n\n    func doSomethingWithClosure() {\n        repository.remoteAPICallWithClosure { apiResult in\n            self.result = apiResult\n        }\n    }\n}\n```\n\n이제 SomeBigViewModel의 인스턴스를 생성하고 doSomethingWithClosure을 호출한 후에 해당 인스턴스를 해제하려고 시도합니다:\n\n```swift\nvar vm: SomeBigViewModel? = SomeBigViewModel()\nvm?.doSomethingWithClosure()\nvm = nil\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n작업이 시작됩니다. 그러나 deint print 문은 즉시 나타나지 않을 것입니다. 이는 유지 주기(순환 참조)를 나타냅니다:\n\n```js\n작업이 시작됨\n```\n\n## 주기(순환 참조) 파괴하기\n\n우리의 클로저에서 [weak self]를 사용하여 유지 주기를 피하고 SomeBigViewModel이 해제되도록 할 수 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nfunc doSomethingWithClosure() {\n    print(\"작업이 시작되었습니다.\")\n    repository.remoteAPICallWithClosure { [weak self] apiResult in\n        guard let self = self else { return }\n        self.result = apiResult\n        print(\"API 결과를 받았습니다.\")\n    }\n}\n```\n\n코드를 수정하고 다시 실행한 후, 출력 결과는 예상대로 `deinit`이 호출되어 순환 참조가 해제된다는 것을 확인합니다:\n\n```js\n작업이 시작되었습니다.\nSomeBigViewModel이 해제되고 있습니다.\n```\n\n# Swift의 병행성 모델: Task와의 사례\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nSwift의 동시성 모델 소개로 Task에 대한 유사한 질문이 제기됩니다: 여전히 순환 참조를 방지하기 위해 weak self를 사용해야 할까요?\n\n다음 비동기 작업을 고려해보세요.\n\n```swift\nfunc doSomething() {\n    print(\"비동기 작업 시작됨\")\n    Task {\n        do {\n            let result = try await repository.remoteAPICall()\n        } catch {\n            print(error)\n        }\n    }\n}\n```\n\n여기서 weak self를 사용하지 않으면, `Task`이 `self`을 강하게 캡처하면서 인스턴스가 작업이 완료되기 전에 해제되어야 하는 순환 참조가 발생합니다. 클로저와는 달리, 컴파일러는 여기서 명시적인 `self` 사용을 요구하지 않기 때문에 weak self이 모든 비동기 작업에서 필수적인지에 대한 의문이 생깁니다. 놀랍게도, 대안 전략으로 작업 취소라는 것이 있기 때문에 weak self가 모든 비동기 작업에서 꼭 필요하지는 않습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 작업 취소: 전략적 접근\n\n모든 비동기 작업에 일반적으로 `weak self`를 적용하는 대신 개발자들은 작업 취소를 더 적절한 전략으로 생각할 수 있습니다. 작업이 더 이상 필요하지 않을 때 해당 작업을 취소함으로써 `self`를 직접 관리하지 않고도 잠재적인 유지 사이클을 방지할 수 있습니다.\n\n## 작업 취소 단순화:\n\n```swift\npublic extension Task {\n    func store(in set: inout Set<AnyCancellable>) {\n        set.insert(AnyCancellable(cancel))\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 확장 프로그램은 작업 수명주기 관리를 간소화하여 집단 작업 취소를 용이하게 합니다.\n\n## ViewModel에서 작업 취소 활용:\n\n```js\n@MainActor\nclass SomeBigViewModel {\n    private let repository = Repository()\n    private var cancellableBag = Set<AnyCancellable>()\n\n    deinit {\n        print(\"deinit called\")\n    }\n\n    func send(_ action: Action) {\n        switch action {\n            case .viewWillDisappear:\n                cancellableBag.removeAll()\n        }\n    }\n\n    private func doSomething() {\n        print(\"async operation started\")\n        Task {\n            do {\n                let result = try await repository.remoteAPICall()\n            } catch {\n                print(error)\n            }\n        }\n        .store(in: &cancellableBag)\n    }\n}\n```\n\n작업 취소를 사용하면 ViewModel이 해제될 때 작업도 취소되어 명시적으로 `weak self`를 사용하지 않아도 보존 사이클을 방지합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n비동기 작업이 시작되었습니다\nSomeBigViewModel이 해제 중입니다\n```\n\n더 섬세한 작업 취소 제어를 원하는 개발자를 위해 다음 패턴을 적용할 수 있습니다:\n\n이 접근 방식을 사용하면 비동기 작업의 ViewModel 관리가 보다 구조적이고 효율적으로 되며, 기본적으로 약한 self에 의존하는 것보다 전략적인 작업 취소로서 보류 중인 사이클을 피할 수 있습니다.\n\n이 기사를 즐겼다면, Medium에 Clap으로 사랑을 보여주시고 의견을 자유롭게 공유해주세요. 이와 유사한 통찰력을 얻고 싶다면, Medium에서 저를 팔로우하고 LinkedIn 및 Twitter에서 저와 연락하십시오. 함께 더 많은 기술 토론에 참여해 봅시다!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nMedium | LinkedIn | Twitter\n","ogImage":{"url":"/assets/img/2024-06-23-SwiftConcurrencyTaskCancellationvsWeakSelfforMemoryManagement_0.png"},"coverImage":"/assets/img/2024-06-23-SwiftConcurrencyTaskCancellationvsWeakSelfforMemoryManagement_0.png","tag":["Tech"],"readingTime":7},{"title":"확률 도전 과제 50선 파트 31 생일 짝짓기 문제해결 방법","description":"","date":"2024-06-23 21:23","slug":"2024-06-23-50ChallengingProblemsinProbabilityPart31BirthdayPairings","content":"\n안녕하세요! 최근에 확률 관련 문제에 흥미를 느끼기 시작했어요. 프레드릭 모스텔러(Frederick Mosteller)의 “Fifty Challenging Problems in Probability with Solutions”라는 책을 발견했는데, 이 중에 있는 문제들을 토론하는 시리즈를 만들면 재미있을 것 같아요. 이 문제들은 면접 질문으로 나올 수 있는 매력적인 문제들이에요. 각 게시물은 1개의 문제만을 다루며, 총 50부작의 시리즈가 될 거에요. 함께 해서 두뇌를 활성화해봐요 🧠!\n\n## 문제:\n\n생일이 같은 두 사람이 있다는 확률이 1/2를 초과하는 데 필요한 최소한의 사람 수는 얼마입니까?\n\n(출생 연도는 일치할 필요가 없습니다. 2월 29일은 가능한 생일로 고려하지 않아도 됩니다. 다른 365일은 모두 동등한 가능성의 생일입니다.)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-06-23-50ChallengingProblemsinProbabilityPart31BirthdayPairings_0.png\" />\n\n## 해결 방안:\n\n(해결 방안은 곧 업로드됩니다. 풀었다면 멋져요! 답을 댓글로 공유해도 좋아요! 😊)\n\n힌트: 아무도 같은 생일이 없는 확률을 계산하는 것부터 시작하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 시리즈의 다른 문제들도 확인해보세요:\n\n읽어 주셔서 감사합니다! :)\n","ogImage":{"url":"/assets/img/2024-06-23-50ChallengingProblemsinProbabilityPart31BirthdayPairings_0.png"},"coverImage":"/assets/img/2024-06-23-50ChallengingProblemsinProbabilityPart31BirthdayPairings_0.png","tag":["Tech"],"readingTime":2},{"title":"Swift에서 클로저 사용하는 방법 - 완벽 가이드","description":"","date":"2024-06-23 21:23","slug":"2024-06-23-AGuideToClosuresInSwift","content":"\n![Closure](/assets/img/2024-06-23-AGuideToClosuresInSwift_0.png)\n\n스위프트에서 클로저는 코드에서 전달하고 사용할 수 있는 자체 포함 블록 기능입니다. 클로저는 함수와 유사하지만 구문 최적화가 있으며 주변 컨텍스트에서 변수 및 상수에 대한 참조를 캡처하고 저장할 수 있습니다. 이 동작은 클로저가 동작을 캡슐화하고 값을 전달하는 데 강력하게 만듭니다.\n\n클로저는 다양한 시나리오에서 사용할 수 있습니다. 이 글에서는 다음과 같은 내용을 배우게 됩니다:\n\n- 인수 및 반환 값으로서\n- 정렬 및 필터링을 위해\n- 비동기 작업\n- 값 캡처\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 인수 및 반환 값으로서의 클로저:\n\n클로저는 함수 및 메소드에 인수로 전달될 수 있으며, 함수에서 반환하거나 변수 또는 속성에 저장할 수도 있습니다.\n\n예시:\n\n```js\n// 클로저를 인수로 전달하는 함수\nfunc performOperation(on a: Int, and b: Int, operation: (Int, Int) -> Int) -> Int {\n    return operation(a, b)\n}\n\n// 다양한 연산을 위한 클로저 표현 정의\nlet addClosure: (Int, Int) -> Int = { $0 + $1 }\nlet subtractClosure: (Int, Int) -> Int = { $0 - $1 }\nlet multiplyClosure: (Int, Int) -> Int = { $0 * $1 }\n\nlet resultAdd = performOperation(on: 5, and: 3, operation: addClosure) // 결과: 8\nlet resultSubtract = performOperation(on: 10, and: 4, operation: subtractClosure) // 결과: 6\nlet resultMultiply = performOperation(on: 6, and: 2, operation: multiplyClosure) // 결과: 12\n\nprint(resultAdd, resultSubtract, resultMultiply)\n\n// 클로저를 반환하는 함수\nfunc makeMultiplier(factor: Int) -> (Int) -> Int {\n    return { number in\n        return number * factor\n    }\n}\n\nlet double = makeMultiplier(factor: 2)\nlet triple = makeMultiplier(factor: 3)\n\nlet resultDouble = double(5) // 결과: 10\nlet resultTriple = triple(4) // 결과: 12\n\nprint(resultDouble, resultTriple)\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 예제에서는 performOperation이라는 함수를 정의합니다. 이 함수는 두 정수와 산술 연산을 나타내는 클로저를 받습니다. 이 함수는 제공된 클로저를 두 정수에 적용합니다.\n\n또한 makeMultiplier라는 함수를 정의합니다. 이 함수는 클로저를 반환합니다. 반환된 클로저는 인수를 지정된 인수로 곱합니다.\n\n그런 다음, 덧셈, 뺄셈 및 곱셈을 위한 다른 클로저 표현식을 만듭니다. 이러한 클로저를 performOperation의 인수로 전달하고, 반환된 makeMultiplier의 클로저를 사용하여 숫자를 2배와 3배로 만듭니다.\n\n# Sorting and Filtering:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n테이블 태그를 마크다운 형식으로 변경해 주세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```swift\nstruct Person {\n    var name: String\n    var age: Int\n}\n\nlet people = [\n    Person(name: \"Alice\", age: 28),\n    Person(name: \"Bob\", age: 22),\n    Person(name: \"Charlie\", age: 35)\n]\n\n// 나이 기준으로 정렬하는 클로저 사용\nlet sortedByAge = people.sorted { (person1, person2) in\n    return person1.age < person2.age\n}\n\nprint(sortedByAge)\n// 결과: [Person(name: \"Bob\", age: 22), Person(name: \"Alice\", age: 28), Person(name: \"Charlie\", age: 35)]\n\n```\n\n이 예제에서는 sorted(by:) 메서드가 각 Person 인스턴스의 age 속성을 기준으로 people 배열을 정렬하는 클로저를 사용합니다.\n\n2. 클로저로 필터링:\n\n클로저를 사용하여 특정 조건에 따라 배열에서 요소를 필터링할 수도 있습니다. filter(\\_:) 메서드를 사용하여, 필터링된 결과에 포함되어야 하는지 여부를 나타내는 Boolean 값을 반환하는 클로저를 제공할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n예시:\n\n```js\nlet numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n// 클로저를 사용하여 짝수만 필터링하는 예시\nlet evenNumbers = numbers.filter { number in\n    return number % 2 == 0\n}\n\nprint(evenNumbers) // 출력: [2, 4, 6, 8, 10]\n```\n\n본 예시에서는 filter(\\_:) 메서드가 클로저를 사용하여 numbers 배열에서 홀수를 필터링하는 방법을 보여줍니다.\n\n# 비동기 작업:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n클로저는 네트워크 요청이나 애니메이션과 같은 비동기 작업에서 완료 핸들러로 자주 사용됩니다.\n\n비동기 예시: 네트워크 요청\n\n```swift\nfunc fetchData(completion: @escaping (Result<Data, Error>) -> Void) {\n    // 네트워크 요청 지연 시간 시뮬레이션\n    DispatchQueue.global().asyncAfter(deadline: .now() + 2) {\n        if Bool.random() { // 성공 또는 실패를 랜덤하게 시뮬레이션\n            let data = Data(\"샘플 데이터\".utf8)\n            completion(.success(data))\n        } else {\n            let error = NSError(domain: \"com.example\", code: 1, userInfo: nil)\n            completion(.failure(error))\n        }\n    }\n}\n\n// 클로저를 사용하여 fetchData 함수 호출\nfetchData { result in\n    switch result {\n    case .success(let data):\n        print(\"받은 데이터:\", data)\n    case .failure(let error):\n        print(\"에러:\", error)\n    }\n}\n```\n\n이 예시에서 fetchData 함수는 지연 후 완료되는 네트워크 요청을 시뮬레이션합니다. 네트워크 요청이 완료되면 실행되는 클로저(completion)를 인자로 받습니다. 클로저는 성공(가져온 데이터와 함께) 또는 실패(에러와 함께)를 나타내는 Result 타입을 갖습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n비동기 예제: 애니메이션\n\n```js\nimport UIKit\n\nUIView.animate(withDuration: 0.5, animations: {\n    // 애니메이션할 UI 속성 업데이트\n    someView.alpha = 0.0\n}) { _ in\n    // 이 클로저는 애니메이션이 완료될 때 실행됩니다\n    someView.removeFromSuperview()\n}\n```\n\n이 예제에서는 UIView.animate(withDuration:animations:completion:) 함수를 사용하여 뷰의 알파 속성을 애니메이션화합니다. animations로 전달된 클로저는 애니메이션 변경을 정의하며, completion 클로저는 애니메이션이 완료되면 실행됩니다.\n\n# 값 캡처하기:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n클로저는 주변 컨텍스트에서 변수와 상수에 대한 참조를 캡처하고 저장할 수 있습니다. 이는 클로저 내부에서 상태를 유지하는 데 유용할 수 있습니다.\n\n예시:\n\n```js\nfunc makeIncrementer(incrementAmount: Int) -> () -> Int {\n    var total = 0\n\n    let incrementer: () -> Int = {\n        total += incrementAmount\n        return total\n    }\n\n    return incrementer\n}\n\nlet incrementByTwo = makeIncrementer(incrementAmount: 2)\nprint(incrementByTwo()) // Prints: 2\nprint(incrementByTwo()) // Prints: 4\n\nlet incrementByFive = makeIncrementer(incrementAmount: 5)\nprint(incrementByFive()) // Prints: 5\nprint(incrementByFive()) // Prints: 10\n\nprint(incrementByTwo()) // Prints: 6\n```\n\n이 예시에서 makeIncrementer 함수는 주변 컨텍스트에서 total 변수를 캡처하는 클로저인 incrementer를 반환합니다. 반환된 클로저는 캡처된 total을 지정된 incrementAmount만큼 증가시킵니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nmakeIncrementer(incrementAmount: 2)을 호출하면 incrementByTwo 클로저를 얻게 됩니다. incrementByTwo()를 호출할 때마다 총합이 2씩 증가하고 업데이트된 값이 반환됩니다.\n\n비슷하게, makeIncrementer(incrementAmount: 5)를 호출하면 총합을 5씩 증가시키는 incrementByFive 클로저를 얻게 됩니다.\n\n클로저는 생성될 때 값을 캡처합니다. 이는 각 캡처된 값이 클로저 인스턴스에 고유하다는 것을 의미합니다. 이 예시에서 incrementByTwo와 incrementByFive는 각각 고유한 캡처된 총합 값을 갖습니다.\n\n클로저에서 값들을 캡처하는 것은 상태를 유지하고 컨텍스트를 기억하는 동작을 만들 수 있게 해줍니다. 이러한 특성으로 인해 클로저는 다양한 프로그래밍 시나리오에 강력한 도구가 됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 문법:\n\n스위프트에서 클로저의 기본 문법은 다음과 같습니다:\n\n```js\nlet closureName: (파라미터들) -> 반환타입 = { // 클로저 내용 }\n```\n\n두 정수를 더하는 클로저의 예시:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```swift\nlet addClosure: (Int, Int) -> Int = { (a, b) in\n    return a + b\n}\n\nlet result = addClosure(5, 3) // 결과는 8이 될 것입니다\n```\n\n클로저는 그들의 타입을 유추할 수 있는 경우에 더 간결한 형식으로 작성할 수 있습니다:\n\n```swift\nlet addClosure = { (a: Int, b: Int) in\n    return a + b\n}\n\nlet result = addClosure(5, 3)\n```\n\n더 간결하게도:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nlet addClosure: (Int, Int) -> Int = { $0 + $1 }\n\nlet result = addClosure(5, 3)\n```\n\n클로저는 주변 컨텍스트에서 값들을 캡쳐할 수 있어요.\n\n예를들어:\n\n```js\nfunc makeIncrementer(incrementAmount: Int) -> () -> Int {\n    var total = 0\n    let incrementer: () -> Int = {\n        total += incrementAmount\n        return total\n    }\n    return incrementer\n}\n\nlet incrementByTwo = makeIncrementer(incrementAmount: 2)\nprint(incrementByTwo()) // 2 출력\nprint(incrementByTwo()) // 4 출력\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 예시에서 증가자 클로저는 주변 함수 컨텍스트에서 total 변수와 incrementAmount 매개변수를 캡처합니다.\n\n이 게시물을 즐기셨다면 공유하고 클랩도 부탁드려요👏🏻👏🏻👏🏻👏🏻👏🏻\n\n또한 아래 연락처로 연락하실 수도 있어요📲\n\nLinkedIn\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래에서 제 코드를 확인할 수 있어요👇🏻\n\nGitHub\n\n잘 읽었나요?\n\n의견, 질문 또는 추천이 있으면 자유롭게 아래 댓글 섹션에 남겨주세요💬\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n💁🏻‍♀️ 즐거운 코딩하세요!\n\n감사합니다 😊\n","ogImage":{"url":"/assets/img/2024-06-23-AGuideToClosuresInSwift_0.png"},"coverImage":"/assets/img/2024-06-23-AGuideToClosuresInSwift_0.png","tag":["Tech"],"readingTime":11},{"title":"Keycloak으로 Spring Boot 보안 설정하는 방법","description":"","date":"2024-06-23 21:21","slug":"2024-06-23-SecuringSpringBootwithKeycloak","content":"\n![사진](/assets/img/2024-06-23-SecuringSpringBootwithKeycloak_0.png)\n\n개요\n우리 애플리케이션을 안전하게 보호하는 것은 요즘 큰 걱정이자 도전입니다. 처음부터 구축하는 것은 더 어려울 수 있고 더 많은 시간이 소요될 수 있습니다. 따라서 우리는 IDP(Identity Provider) 도구인 Keycloak과 같이 애플리케이션의 인가 서버로 구현할 수 있습니다.\n\nKeycloak이란\n\nKeycloak은 레드햇에서 개발된 오픈 소스 식별 및 액세스 관리 도구입니다. 쉬운 설정 및 애플리케이션 통합으로 여러분이 직접 모든 것을 맞춤 설정하는 것보다 훨씬 많은 시간을 절약할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n많은 회사에서 이미 보안 구성 요소로 채택되어 있어서 도구들이 검증되었고 더욱 신뢰할 수 있는 상태로 구현되어 있습니다. 많은 회사가 Keycloak을 사용하기 때문에 학습 자료를 쉽게 얻고 인터넷에서 의논할 수 있습니다.\n\n주요 기능을 갖고 있기 때문에 비즈니스나 보안 흐름에 대응해야 할 경우 애플리케이션을 미래에 대비하여 더 확장 가능하게 만들 수 있습니다.\n\n구현\nKeycloak를 구현하는 여러 방법이 있습니다. 예를 들어 SSO, 소셜 미디어 로그인 또는 액세스 토큰을 얻기 위해 API에 접근하는 방법이 있습니다.\n\n우리는 필요에 따라 구현이 필요한 사용자 정의 흐름을 처리하는 독립된 인증 서비스를 사용하여 구현할 것이지만, 자격 증명 자체를 인증하는 데 Keycloak가 책임을 집니다. 그리고 서비스 레이어의 리소스 서버에서 토큰을 확인합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n시스템 다이어그램\n\n![image](/assets/img/2024-06-23-SecuringSpringBootwithKeycloak_1.png)\n\n사용자는 자격 증명을 제출하고, 이는 인증 서비스에서 처리되어 Keycloak 측에서 유효성이 검사됩니다. 자격 증명이 유효한 경우, Keycloak은 액세스 토큰을 반환하고, 유효하지 않은 경우 응답 401 — 권한 없음을 반환합니다.\n\n물론 애플리케이션 클라이언트(FE 또는 모바일 앱)에게 다시 원시 응답을 반환하지는 않겠습니다. 인증 서비스에서 응답을 표준화하여 처리할 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nKeycloak 설치 및 설정\n다음 yml 파일을 사용하여 도커 컴포즈로 Keycloak을 설치하고 구성하세요:\n\n```js\nversion: \"3\"\n\nservices:\n  keycloak:\n    image: quay.io/keycloak/keycloak:20.0.0\n    command: start-dev\n    environment:\n      KC_DB: postgres\n      KC_DB_URL_HOST: postgres\n      KC_DB_URL_DATABASE: keycloak_v1\n      KC_DB_PASSWORD: root\n      KC_DB_USERNAME: postgres\n      KC_DB_SCHEMA: public\n      KEYCLOAK_ADMIN: admin\n      KEYCLOAK_ADMIN_PASSWORD: admin\n      KEYCLOAK_JDBC_PARAMS: 'sslmode=require'\n    ports:\n      - \"9090:8080\"\n    depends_on:\n      postgres:\n        condition: service_healthy\n    networks:\n      network_sso:\n\n  postgres:\n    image: postgres:10\n    command: [\"postgres\", \"-c\", \"max_connections=200\", \"-c\", \"shared_buffers=24MB\", \"-c\", \"listen_addresses=*\"]\n    environment:\n      POSTGRES_DB: keycloak_v1\n      POSTGRES_USER: postgres\n      POSTGRES_PASSWORD: root\n    healthcheck:\n      test: \"exit 0\"\n    ports:\n      - \"5436:5432\"\n    networks:\n      network_sso:\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n    user: postgres\n\n  redis:\n    image: redis:latest\n    ports:\n      - \"6379:6379\"\n    environment:\n      REDIS_PASSWORD: \"root\"\n    volumes:\n      - redis_data:/data\n\nvolumes:\n  postgres_data:\n  redis_data:\n\nnetworks:\n  network_sso:\n```\n\n저희 Keycloak 애플리케이션에서 사용자 저장소로 postgres 데이터베이스를 사용하세요. “docker-compose up”을 실행한 후 http://localhost:9090에 액세스하고 다음 자격 증명으로 로그인하세요:\n\n계층을 만들고 원하는 대로 계층 이름 폼을 작성하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/assets/img/2024-06-23-SecuringSpringBootwithKeycloak_2.png)\n\n이 구성대로 클라이언트를 계속 생성하세요.\n\n![이미지](/assets/img/2024-06-23-SecuringSpringBootwithKeycloak_3.png)\n\n![이미지](/assets/img/2024-06-23-SecuringSpringBootwithKeycloak_4.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n클라이언트를 성공적으로 생성한 후, 클라이언트 비밀키를 복사하려면 클라이언트 자격 증명 탭으로 이동하세요.\n\n사용자를 생성하고 사용자 자격 증명 또는 암호를 설정한 후, 임시 암호 토글을 비활성화해야 합니다. userdemo와 admindemo 두 명의 사용자를 생성하세요.\n\n![이미지](/assets/img/2024-06-23-SecuringSpringBootwithKeycloak_5.png)\n\n역할 할당\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n키클로크에는 렘 역할과 리소스 클라이언트 역할이 있어요. 둘 다 서로 다른 책임과 동작을 가지고 있어요.\n\n렘 역할을 만들어 보세요, \"admin\"과 \"user\"와 같이요.\n\n![image](/assets/img/2024-06-23-SecuringSpringBootwithKeycloak_6.png)\n\n리소스 클라이언트 역할도 만들어 보세요, \"write\"와 \"read\" 같은 역할을 만들어 보세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-06-23-SecuringSpringBootwithKeycloak_7.png\" />\n\n사용자 메뉴로 이동해서 사용자 'admindemo'에게 'admin' 및 'write' 역할을 할당하고, 'userdemo'에게 'user' 및 'read' 역할을 할당하세요.\n\n<img src=\"/assets/img/2024-06-23-SecuringSpringBootwithKeycloak_8.png\" />\n\n코드 구현\nSpring 프로젝트를 초기화하고, pom.xml에 다음 종속성을 추가하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n <modelVersion>4.0.0</modelVersion>\n <parent>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-parent</artifactId>\n  <version>3.2.2</version>\n </parent>\n <artifactId>auth-service</artifactId>\n <version>0.0.1-SNAPSHOT</version>\n <name>auth-service</name>\n <description>Demo project for Spring Boot</description>\n <properties>\n  <java.version>17</java.version>\n </properties>\n <dependencies>\n  <dependency>\n   <groupId>org.springframework.boot</groupId>\n   <artifactId>spring-boot-starter-web</artifactId>\n  </dependency>\n  <dependency>\n   <groupId>org.springframework.boot</groupId>\n   <artifactId>spring-boot-starter-security</artifactId>\n  </dependency>\n  <dependency>\n   <groupId>org.springframework.boot</groupId>\n   <artifactId>spring-boot-starter-oauth2-client</artifactId>\n  </dependency>\n  <dependency>\n   <groupId>org.springframework.boot</groupId>\n   <artifactId>spring-boot-starter-oauth2-resource-server</artifactId>\n  </dependency>\n  <dependency>\n   <groupId>org.apache.commons</groupId>\n   <artifactId>commons-collections4</artifactId>\n   <version>4.4</version>\n  </dependency>\n  <dependency>\n   <groupId>org.projectlombok</groupId>\n   <artifactId>lombok</artifactId>\n   <version>1.18.30</version>\n   <scope>provided</scope>\n  </dependency>\n </dependencies>\n\n <build>\n  <plugins>\n   <plugin>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-maven-plugin</artifactId>\n   </plugin>\n   <plugin>\n    <groupId>org.apache.maven.plugins</groupId>\n    <artifactId>maven-surefire-plugin</artifactId>\n    <version>3.2.2</version>\n   </plugin>\n  </plugins>\n </build>\n\n</project>\n```\n\nKeycloakJwtRolesResolver.java 파일은 키클로캣 액세스 토큰에서 로그인한 사용자 역할을 추출하여 GrantedAuthority 컬렉션에 저장하는 것입니다 (여기서 토큰을 디버그할 수 있습니다). 이 코드에서는 렘 역할을 구성하고 리소스 역할에 연결한 다음 대문자로 변환합니다. 결과는 ADMIN_WRITE 또는 USER_READ여야 합니다.\n\n```js\n@Slf4j\npublic class KeycloakJwtRolesConverter implements Converter<Jwt, Collection<GrantedAuthority>> {\n\n    private static final String CLAIM_REALM_ACCESS = \"realm_access\";\n    private static final String CLAIM_RESOURCE_ACCESS = \"resource_access\";\n    private static final String CLAIM_ROLES = \"roles\";\n\n    private final String kcClientId;\n\n    public KeycloakJwtRolesConverter(String kcClientId) {\n        this.kcClientId = kcClientId;\n    }\n\n    @Override\n    public Collection<GrantedAuthority> convert(Jwt jwt) {\n        Map<String, Collection<String>> realmAccess = jwt.getClaim(CLAIM_REALM_ACCESS);\n        Map<String, Map<String, Collection<String>>> resourceAccess = jwt.getClaim(CLAIM_RESOURCE_ACCESS);\n\n        Collection<GrantedAuthority> grantedAuthorities = new ArrayList<>();\n\n        if (realmAccess != null && !realmAccess.isEmpty()) {\n            Collection<String> realmRole = realmAccess.get(CLAIM_ROLES);\n            if (realmRole != null && !realmRole.isEmpty()) {\n                realmRole.forEach(r -> {\n                    if (resourceAccess != null && !resourceAccess.isEmpty() && resourceAccess.containsKey(kcClientId)) {\n                        resourceAccess.get(kcClientId).get(CLAIM_ROLES).forEach(resourceRole -> {\n                            String role = String.format(\"%s_%s\", r, resourceRole).toUpperCase(Locale.ROOT);\n                            grantedAuthorities.add(new SimpleGrantedAuthority(role));\n                        });\n                    } else {\n                        grantedAuthorities.add(new SimpleGrantedAuthority(r));\n                    }\n                });\n            }\n        }\n\n        return grantedAuthorities;\n    }\n}\n```\n\nCustomAuthenticationEntryPoint.java 파일은 요청을 인증하는 동안 예외를 처리하는 클래스이며 JSON을 반환합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```java\n@Component\npublic class CustomAuthenticationEntryPoint implements AuthenticationEntryPoint {\n\n    @Override\n    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException {\n        response.setStatus(HttpStatus.UNAUTHORIZED.value());\n        response.setContentType(\"application/json\");\n\n        BaseResponseDto errorResponse = BaseResponseDto.builder()\n                .status(\"UNAUTHORIZED\")\n                .build();\n\n        ObjectMapper mapper = new ObjectMapper();\n        mapper.writeValue(response.getWriter(), errorResponse);\n    }\n}\n```\n\nCustomAccessDenied.java은 예외 처리를 위한 클래스입니다. 로그인한 사용자가 일부 엔드포인트에서 유효한 역할이나 권한이 없는 경우 JSON을 반환합니다.\n\n```java\n@Component\npublic class CustomAccessDenied implements AccessDeniedHandler {\n    @Override\n    public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException) throws IOException, ServletException {\n        response.setStatus(HttpStatus.FORBIDDEN.value());\n        response.setContentType(MediaType.APPLICATION_JSON_VALUE);\n\n        BaseResponseDto errorResponse = BaseResponseDto.builder()\n                .status(\"ACCESS_DENIED\")\n                .build();\n\n        ObjectMapper mapper = new ObjectMapper();\n        mapper.writeValue(response.getWriter(), errorResponse);\n    }\n}\n```\n\nWebSecurityConfiguration.java에서는 보안 구성을 정의하고, 일부 엔드포인트를 역할 확인으로 보호하며, 보안 시스템 내에서 사용자 정의 예외 처리를 어떻게 구현하는지 설명합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\njwtDecoder() 함수는 요청에서 받은 JSON 웹 토큰(JWT)을 유효성 검사하고 해독하는 역할을 담당합니다. 이 함수는 토큰을 생성하고 서명하는 인증 서버로 가리키는 발급자를 가리킵니다.\n\ngrantedAuthorityDefaults() 함수는 우리 스프링 애플리케이션에서 \"ROLE\\_\" 접두사를 제거하는 역할을 합니다.\n\n```js\n@Slf4j\n@Configuration\n@EnableWebSecurity\npublic class WebSecurityConfiguration {\n\n    @Value(\"${keycloak.client-id}\")\n    private String kcClientId;\n\n    @Value(\"${keycloak.issuer-url}\")\n    private String tokenIssuerUrl;\n\n    @Bean\n    public SecurityFilterChain securityFilterChain(HttpSecurity http, CustomAuthenticationEntryPoint entryPoint,\n                                                   CustomAccessDenied accessDenied) throws Exception {\n\n        DelegatingJwtGrantedAuthoritiesConverter authoritiesConverter = new DelegatingJwtGrantedAuthoritiesConverter(\n                        new JwtGrantedAuthoritiesConverter(),\n                        new KeycloakJwtRolesConverter(kcClientId));\n\n        http.authorizeHttpRequests(authorizeRequests ->\n                authorizeRequests\n                    .requestMatchers(\"/home/admin/**\")\n                        .hasRole(\"ADMIN_WRITE\")\n                    .requestMatchers(\"/home/public/**\")\n                        .hasRole(\"USER_READ\")\n                    .requestMatchers(\"/auth/**\").permitAll()\n                    .anyRequest().authenticated()\n            )\n            .httpBasic()\n            .and()\n            .exceptionHandling()\n                .authenticationEntryPoint(entryPoint)\n                .accessDeniedHandler(accessDenied)\n            .and()\n            .csrf().disable()\n                .oauth2ResourceServer()\n                .jwt()\n                .jwtAuthenticationConverter(\n                        jwt -> new JwtAuthenticationToken(jwt, authoritiesConverter.convert(jwt))\n                );\n        return http.build();\n    }\n\n    @Bean\n    public JwtDecoder jwtDecoder() {\n        return JwtDecoders.fromIssuerLocation(tokenIssuerUrl);\n    }\n\n    @Bean\n    GrantedAuthorityDefaults grantedAuthorityDefaults() {\n        return new GrantedAuthorityDefaults(\"\");\n    }\n}\n```\n\nAuthService.java는 Keycloak의 엔드포인트에 요청을 보내 인증할 자격 증명을 제공하는 서비스 클래스입니다. client_id 및 client_secret 자격 증명은 Keycloak에 방금 등록한 클라이언트에서 얻었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n서비스에는 액세스 토큰을 가져오고 토큰을 새로 고침하는 두 가지 메서드가 있습니다. 액세스 및 새로 고침 토큰을 받았으므로 새로 고침 토큰을 Redis에 REFRESH_TOKEN 상수 키로 저장한 다음 디바이스 ID와 연결합니다. 토큰을 새로 고칠 때 Redis에서 저장할 때와 동일한 키로 가져옵니다.\n\n```js\n@Slf4j\n@Service\npublic class AuthService {\n\n    @Autowired\n    private RestTemplate restTemplate;\n\n    @Autowired\n    private SessionStorage sessionStorage;\n\n    @Value(\"${keycloak.client-id}\")\n    private String kcClientId;\n\n    @Value(\"${keycloak.client-secret}\")\n    private String kcClientSecret;\n\n    @Value(\"${keycloak.get-token-url}\")\n    private String kcGetTokenUrl;\n\n    private static final String GRANT_TYPE_PASSWORD = \"password\";\n    private static final String GRANT_TYPE_REFRESH_TOKEN = \"refresh_token\";\n\n    private static final String ACCESS_TOKEN = \"Access-Token\";\n    private static final String REFRESH_TOKEN = \"Refresh-Token\";\n    private static final String EXPIRES_IN = \"Expires-In\";\n    private static final String DEVICE_ID = \"Device-Id\";\n\n    public ResponseEntity<Object> login(LoginRequestDto request, HttpServletRequest servletRequest, HttpServletResponse servletResponse) {\n        log.info(\"액세스 토큰을 가져오기 시작\");\n\n        String deviceId = servletRequest.getHeader(DEVICE_ID);\n\n        TokenDto tokenDto = this.getAccessToken(request);\n\n        servletResponse.addHeader(ACCESS_TOKEN, tokenDto.getAccessToken());\n        servletResponse.addHeader(EXPIRES_IN, String.valueOf(tokenDto.getExpiresIn()));\n\n        sessionStorage.putCache(REFRESH_TOKEN, deviceId, tokenDto.getRefreshToken(), 1800);\n\n        return ResponseEntity.ok().body(BaseResponseDto.builder()\n                .status(\"SUCCESS\")\n                .build());\n    }\n\n    public ResponseEntity<Object> refreshToken(HttpServletRequest servletRequest, HttpServletResponse servletResponse) {\n        log.info(\"액세스 토큰을 새로 고침하기 시작\");\n\n        String deviceId = servletRequest.getHeader(DEVICE_ID);\n        String refreshToken = (String) sessionStorage.getCache(REFRESH_TOKEN, deviceId);\n\n        TokenDto tokenDto = this.getRefreshToken(refreshToken);\n\n        servletResponse.addHeader(ACCESS_TOKEN, tokenDto.getAccessToken());\n        servletResponse.addHeader(EXPIRES_IN, String.valueOf(tokenDto.getExpiresIn()));\n\n        sessionStorage.putCache(REFRESH_TOKEN, deviceId, tokenDto.getRefreshToken(), tokenDto.getRefreshExpiresIn());\n\n        return ResponseEntity.ok().body(BaseResponseDto.builder()\n                .status(\"SUCCESS\")\n                .build());\n    }\n\n    private TokenDto getAccessToken(LoginRequestDto request) {\n        HttpHeaders headers = new HttpHeaders();\n        headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);\n\n        MultiValueMap<String, String> requestBody = new LinkedMultiValueMap<>();\n        requestBody.add(\"grant_type\", GRANT_TYPE_PASSWORD);\n        requestBody.add(\"client_id\", kcClientId);\n        requestBody.add(\"client_secret\", kcClientSecret);\n        requestBody.add(\"username\", request.getUsername());\n        requestBody.add(\"password\", request.getPassword());\n\n        ResponseEntity<TokenDto> response = restTemplate.postForEntity(kcGetTokenUrl,\n                new HttpEntity<>(requestBody, headers), TokenDto.class);\n\n        return response.getBody();\n    }\n\n    private TokenDto getRefreshToken(String refreshToken) {\n        HttpHeaders headers = new HttpHeaders();\n        headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);\n\n        MultiValueMap<String, String> requestBody = new LinkedMultiValueMap<>();\n        requestBody.add(\"grant_type\", GRANT_TYPE_REFRESH_TOKEN);\n        requestBody.add(\"refresh_token\", refreshToken);\n        requestBody.add(\"client_id\", kcClientId);\n        requestBody.add(\"client_secret\", kcClientSecret);\n\n        ResponseEntity<TokenDto> response = restTemplate.postForEntity(kcGetTokenUrl,\n                new HttpEntity<>(requestBody, headers), TokenDto.class);\n\n        return response.getBody();\n    }\n}\n```\n\nAuthController.java\n\n```js\n@RestController\n@RequestMapping(value = \"/auth\")\npublic class AuthController {\n\n    @Autowired\n    private AuthService authService;\n\n    @PostMapping(value = \"/login\")\n    public ResponseEntity<Object> login(@RequestBody LoginRequestDto request, HttpServletRequest servletRequest,\n                                        HttpServletResponse servletResponse) {\n        return authService.login(request, servletRequest, servletResponse);\n    }\n\n    @PostMapping(value = \"/refresh-token\")\n    public ResponseEntity<Object> refreshToken(HttpServletRequest servletRequest, HttpServletResponse servletResponse) {\n        return authService.refreshToken(servletRequest, servletResponse);\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nHomeController.java에는 USER 역할로 로그인한 사용자를 위한 공개 엔드포인트 및 ADMIN 역할을 위한 /admin을 처리하는 컨트롤러가 있습니다.\n\n```java\n@RestController\n@RequestMapping(value = \"/home\")\npublic class HomeController {\n\n    @GetMapping(value = \"/public\")\n    public ResponseEntity<Object> home() {\n        return new ResponseEntity<>(\"PAGE_PUBLIC\", HttpStatus.OK);\n    }\n\n    @GetMapping(value = \"/admin\")\n    public ResponseEntity<Object> homeAdmin() {\n        return new ResponseEntity<>(\"PAGE_ADMIN\", HttpStatus.OK);\n    }\n}\n```\n\n테스트\n\n새로 등록한 사용자 자격 증명으로 /api/auth/login 엔드 포인트에 로그인하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\ncurl을 사용하여 테이블로 admin 엔드포인트로 이동 가능합니다.\n\n```js\ncurl --location 'http://localhost:8085/api/auth/login' \\\n--header 'Device-Id: example-my-device-id' \\\n--header 'Content-Type: application/json' \\\n--data '{\n    \"username\": \"userdemo\",\n    \"password\": \"useruser123\"\n}'\n```\n\nadmin 엔드포인트로 이동하는 curl입니다.\n\n```js\ncurl --location 'http://localhost:8085/api/home/admin' \\\n--header 'Authorization: Bearer $access_token'\n\n# 페이지_ADMIN을 반환해야 함\n```\n\npublic 엔드포인트로 이동하는 curl입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\ncurl --location 'http://localhost:8085/api/home/public' \\\n--header 'Authorization: Bearer $access_token'\n\n# 페이지_PUBLIC이 반환되어야합니다\n```\n\n사용자가 역할에 맞지 않는 엔드포인트에 액세스하려고하면 403 — 금지로 반환되어야 합니다.\n\n새로 고침 토큰 엔드포인트를 호출하여 리프레시 토큰을 갱신하고 액세스 토큰을 받아옵니다.\n\n```js\ncurl --location --request POST 'http://localhost:8085/api/auth/refresh-token' \\\n--header 'Device-Id: example-my-device-id'\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n업그레이드\n동일한 보안 구성을 적용하는 여러 서비스가 있다면, KeycloakJwtRolesResolver.java를 복제하고 중복 코드를 만드는 것은 좋지 않습니다. 더 나은 접근 방식은 해당 클래스를 독립된 스프링 프로젝트로 분리하는 것입니다. 이 프로젝트를 모듈-공통이라고 부르고, 다른 서비스에 공통으로 사용되는 클래스나 기능을 수용하도록 합니다.\n","ogImage":{"url":"/assets/img/2024-06-23-SecuringSpringBootwithKeycloak_0.png"},"coverImage":"/assets/img/2024-06-23-SecuringSpringBootwithKeycloak_0.png","tag":["Tech"],"readingTime":22},{"title":"개발자를 위한 간편한 웹훅 테스트 방법 스트레스 없는 튜토리얼","description":"","date":"2024-06-23 21:18","slug":"2024-06-23-WebhookTestingWithouttheHeadacheADevelopersSanity-SavingTutorial","content":"\n![웹훅 테스트하지 않고 괴로움을 덜어내는 개발자를 위한 튜토리얼_0.png](/assets/img/2024-06-23-WebhookTestingWithouttheHeadacheADevelopersSanity-SavingTutorial_0.png)\n\n안녕하세요! 이 튜토리얼에서는 웹훅을 효과적으로 테스트하는 방법을 알아볼 거에요. Ngrok를 사용하여 로컬 머신에서 서드파티 웹훅을 직접 수신하는 방법을 알려드릴 거에요. 이 모든 과정은 공개 도메인이 필요하지 않아요. 웹훅 테스트 과정을 전보다 더 효율적으로 운용할 수 있도록 준비하세요!\n\n또한, Wiremock를 사용하여 웹훅을 효율적으로 모킹하는 방법에 대해 알려드릴 거에요. 웹훅을 모킹하는 방법을 배우는 이유는 완전히 오프라인 테스트 환경을 갖게 되어 의존성이 없는 환경을 구축할 수 있기 때문이에요. 더불어, 일부 서비스에서 웹훅의 과도한 사용에 대해 요금을 청구하는 경우도 있으니 이를 피하도록 합시다.\n\n이 튜토리얼을 마치신 후에는\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 제 3자 서비스에서 웹훅을 로컬 응용 프로그램(로컬호스트)으로 라우팅합니다.\n- 로컬 및 오프라인 개발을 위한 웹훅 모의 테스트\n\n## 웹훅이란?\n\n![이미지](/assets/img/2024-06-23-WebhookTestingWithouttheHeadacheADevelopersSanity-SavingTutorial_1.png)\n\n웹훅은 알림 시스템처럼 작동합니다. 친구에게 전화번호를 알려주면 그들이 뉴스가 있을 때마다 전화를 합니다. 디지털 세계에서 웹훅은 전화번호 대신에 URL을 통해 동작합니다. 제 3자 소프트웨어에게 URL을 제공하면 그들이 무언가가 발생할 때 즉시 알림을 받습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n예를 들어, GitHub 저장소에서 실패한 파이프라인과 같은 변경사항이 발생하면 GitHub가 즉시 웹훅(webhook) 메시지를 지정된 URL로 보냅니다. 이 URL은 당신이 선택한 서비스로 이어져야 합니다.\n\n웹훅을 사용하기 위해 필요한 것은 서비스에 제공된 URL에서 수신하는 API입니다.\n\n## 공개 도메인 없이 Ngrok을 사용하여 웹훅 테스트하기\n\n![이미지](/assets/img/2024-06-23-WebhookTestingWithouttheHeadacheADevelopersSanity-SavingTutorial_2.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n웹훅을 테스트하는 것은 공개 URL이 필요하기 때문에 종종 귀찮을 수 있습니다. 특히 로컬에서 코드를 작성하려고 할 때 이런 장애물이 있습니다. 하지만 걱정하지 마세요. 이 문제를 해결하는 방법이 있으며 생각보다 쉽습니다.\n\nNgrok를 이용해보세요. Ngrok를 통해 개발 중에도 API를 공개 도메인에 호스팅하지 않아도 됩니다. Ngrok를 사용하면 로컬 컴퓨터와 인터넷 사이에 중간자 역할을 하는 프록시를 우리의 기기에서 설정할 수 있습니다.\n\nNgrok는 컴퓨터에서 에이전트를 실행하여 작동합니다. 그런 다음 Ngrok가 무료 도메인을 할당해주고 그 도메인으로의 모든 트래픽을 에이전트로 라우팅합니다. Ngrok 문서에서 자세한 정보를 찾을 수 있습니다.\n\nNgrok를 사용하려면 계정을 만들어야 하지만 무료로 사용할 수 있습니다. Ngrok에서 계정을 생성하여 사용을 시작해보세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그 후에는 호스트에서 실행할 수 있는 에이전트를 설치해야 합니다. Ngrok 대시보드에서 설치 지침과 권한 토큰을 찾을 수 있습니다.\n\n```js\nwget https://bin.equinox.io/c/bNyj1mQVY4c/ngrok-v3-stable-linux-amd64.tgz\nsudo tar -xvzf ngrok-v3-stable-linux-amd64.tgz -C /usr/local/bin\nngrok config add-authtoken YOURTOKEN\n```\n\n다음으로 에이전트를 시작하여 애플리케이션으로 웹훅을 받을 수 있습니다.\n\n```js\nngrok http http://localhost:8080\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n명령을 실행하면 약간의 정보가 표시됩니다. 가장 중요한 정보는 Webhooks에 사용할 수있는 URL인 Forwarding입니다.\n\n![Webhook](/assets/img/2024-06-23-WebhookTestingWithouttheHeadacheADevelopersSanity-SavingTutorial_3.png)\n\n## Webhooks를 수신하는 프로젝트 설정\n\n우리는 Webhooks를 트리거하는 서비스가 필요합니다. 간단히 하기위해 저는 이 서비스로 Github를 사용할 것입니다. GitHub 계정을 방문하십시오(또는 마음에 드는 다른 서비스를 사용하십시오)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Webhook Tutorial](/assets/img/2024-06-23-WebhookTestingWithouttheHeadacheADevelopersSanity-SavingTutorial_4.png)\n\nIf you create or select a repository you own, you can visit the settings. There should be a Webhooks tab that allows you to set up a webhook.\n\nUsually, webhook services ask you for a URL. This URL should be the domain that Ngrok prints out for you.\n\nThe secret can be used to validate requests. Read more on GitHub. The secret will be used to create a hash that we can use to validate that the request comes from GitHub.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![WebhookTestingWithouttheHeadacheADevelopersSanity-SavingTutorial_5](/assets/img/2024-06-23-WebhookTestingWithouttheHeadacheADevelopersSanity-SavingTutorial_5.png)\n\n## 웹훅을 수락하는 애플리케이션 생성하기\n\n우리는 Ngrok이 포트 8080에서 수신 대기하고 있으며 Github을 설정하여 이벤트를 Ngrok URL로 푸시하도록 했습니다.\n\n마지막으로 필요한 것은 포트 8080에서 수신 대기하는 웹훅 핸들러입니다. 이를 위해 간단한 Go HTTP 핸들러를 생성하여 요청 내용을 출력하겠습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 서비스는 우리 머신으로 전송된 모든 데이터를 출력하는 매우 간단한 서비스입니다. 테스트하는 데 충분합니다.\n\n```js\npackage main\n\nimport (\n \"io\"\n \"log/slog\"\n \"net/http\"\n)\n\nfunc main() {\n\n // /에 대한 요청 수락 및 페이로드 출력\n http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n  defer r.Body.Close()\n\n  data, err := io.ReadAll(r.Body)\n\n  if err != nil {\n   panic(err)\n  }\n  slog.Info(\"새 요청\", \"페이로드\", string(data))\n })\n\n slog.Info(\":8080 포트에서 수신 대기 중\")\n // 앱을 :8080에서 제공하며, Ngrok이 웹훅을 로컬 애플리케이션으로 라우팅할 수 있도록 동일한 포트를 사용해야 함(중요)\n http.ListenAndServe(\":8080\", nil)\n}\n```\n\n우리는 Ngrok에 사용하라고 한 것과 동일한 포트(여기서는 :8080)를 사용해야 합니다.\n\n로컬호스트:8080의 트래픽을 수신하고 Ngrok이 웹훅을 로컬 애플리케이션으로 라우팅할 수 있도록 go run main.go 명령을 실행하여 Go 애플리케이션을 실행하십시오.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nGitHub이 웹훅을 생성할 때 PING을 보내게 됩니다. \"redeliver\"를 눌러 이 PING 훅을 다시 전달할 수 있습니다. \"최근 전달\"을 방문하여 세 개의 점을 누르고 \"redeliver\"를 선택하세요.\n\n이번에는 성공적으로 실행되었다는 확인 표시가 보여야 합니다.\n\n![Webhook Testing](/assets/img/2024-06-23-WebhookTestingWithouttheHeadacheADevelopersSanity-SavingTutorial_6.png)\n\n더 검증하기 위해 Go 어플리케이션 출력을 검토해 보세요. GitHub로부터 JSON 페이로드를 출력했어야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n2024/01/24 20:59:47 INFO 포트 :8080에서 수신 대기 중\n2024/01/24 21:00:18 INFO 새로운 요청 페이로드=\"{\\\"zen\\\":\\\"Keep it logically awesome.\\\n....\n\n## WireMock을 사용한 Webhook 모의\n\n이제 진짜 서비스에서 페이로드를 보내주는 상황에서 몇 가지 문제를 해결해봅시다.\n\n- 만약 서비스가 다운되면 개발 및 테스트를 할 수 없습니다.\n- 어떤 서비스는 돈이 들기도 하니, 오프라인 솔루션을 원합니다.\n- 서비스들은 일반적으로 사용자 입력이 필요하며 웹훅을 실행하려면, 자동화하고 싶습니다.\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이런 것들은 Wiremock을 사용하여 해결할 수 있어요.\n\n만약 Wiremock이 익숙치 않다면, 꼭 언급해야겠어요. REST, gRPC, 웹훅 등 다양한 데이터를 모의(mock)하는 데에 탁월한 도구입니다.\n\n우리는 Wiremock을 Docker 컨테이너를 통해 실행할 거에요. Wiremock이 관련된 모든 데이터를 저장할 wiremock라는 새로운 폴더를 만들 거에요.\n\n이 글에서 Wiremock의 모든 내용에 대해 다루지는 않겠지만, 기본적으로 WireMock은 규칙을 정의하는 JSON 파일을 받아들입니다. 이 규칙들은 REST 엔드포인트를 설명하고, 리턴해야 하는 데이터를 정의하거나 보내야 하는 웹훅을 설명할 수 있어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nJSON 파일 안에 이러한 매핑은 mappings 폴더 안에 라이브해야 합니다. 그래서 하나를 생성할 겁니다.\n\n```js\nmkdir -p wiremock/mappings\ntouch wiremock/mappings/webhook.json\n```\n\nwebhook.json 안에 send-webhook이라는 엔드포인트를 생성할 겁니다. 이 엔드포인트가 GET 요청을 받으면 WebHook을 실행합니다. 우리는 위치 앱의 위치와 사용할 payload를 지정할 수 있습니다.\n\n```js\n{\n    \"request\": {\n        \"urlPath\": \"/send-webhook\",\n        \"method\": \"GET\"\n    },\n    \"response\": {\n        \"status\": 200\n    },\n    \"serveEventListeners\": [\n        {\n            \"name\": \"webhook\",\n            \"parameters\": {\n                \"method\": \"POST\",\n                \"url\": \"http://localhost:8080\",\n                \"headers\": {\n                    \"Content-Type\": \"application/json\"\n                },\n                \"body\": \"{ \\\"result\\\": \\\"SUCCESS\\\" }\"\n            }\n        }\n    ]\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n해당 파일이 있으면 Docker를 사용하여 WireMock를 시작하고 호스트 네트워크에서 실행되는지 확인합니다. 이렇게 하면 포트 8080에서 실행 중인 Go 애플리케이션에 연결할 수 있습니다.\n\n일반적으로 Docker compose를 사용하여 서비스 이름을 대신 사용하는 경우가 많은데, 이번 튜토리얼 중에는 편의를 위해 localhost를 사용할 것입니다. WireMock 폴더를 마운트하고, 프로젝트 루트에 위치해 있는지 확인하세요.\n\n```js\ndocker run -it --rm --name wiremock --network=host -v $PWD/wiremock:/home/wiremock wiremock/wiremock:3.3.1 --verbose --port=8081\n```\n\nWireMock는 포트 8081에서 실행 중이므로 해당 URL에 CURL을 보내고 Webhook을 활성화할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\ncurl localhost:8081/send-webhook\n```\n\n위 명령을 실행한 후 Go 서비스에서 웹훅이 도착하는 것을 확인할 수 있어요.\n\n```js\n2024/01/24 21:49:10 INFO New request payload=\"{ \\\"result\\\": \\\"SUCCESS\\\" }\"\n```\n\n실제 데이터를 모킹하기 위해 Ngrok 웹훅에서 Payload를 훔쳐와서 wiremock 매핑의 body 필드에 붙여넣을 수 있어요. 이렇게 하면 서비스에서 제공되는 실제 데이터와 유사한 데이터로 모킹할 수 있어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 결론\n\n이 튜토리얼에서는 서비스로부터 웹훅을 로컬 애플리케이션에 받아들이는 간단한 방법을 만들었습니다. 이것은 타사 애플리케이션에서 웹훅을 테스트하는 데 사용될 수 있습니다.\n\n일반적으로 저는 실제 페이로드가 전송되는 Ngrok를 설정하여 시작합니다. 타사 서비스가 어떻게 작동하며 어떤 종류의 데이터를 기대할지를 배우는 데 사용할 수 있습니다.\n또한 항상 터널을 사용하여 트래픽에 의존하는 것을 중지할 수도 있습니다.\n실제 페이로드를 받은 후에는 일반적으로 WireMock에 넣어서 종속성이나 개발 후크 지불을 피할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 세팅을 통해 개발 중에 데이터를 쉽게 목업하고, 웹훅에 의존하는 애플리케이션을 빌드하는 동안 엔드 투 엔드로 테스트할 수 있습니다.\n\n이 튜토리얼이 마음에 들었길 바라며, 아이디어나 생각이 있으시면 언제든지 연락해주세요!\n\n## 부록\n\nNgrok — https://ngrok.com/\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n**Ngrok 동작 원리** - [링크](https://ngrok.com/docs/how-ngrok-works/)\n\n**WireMock** - [링크](https://wiremock.org/docs/webhooks-and-callbacks/)\n\n**GitHub 웹훅** - [링크](https://docs.github.com/en/webhooks/using-webhooks/creating-webhooks)\n\n**GitHub 웹훅 유효성 검사** - [링크](https://docs.github.com/en/webhooks/using-webhooks/validating-webhook-deliveries)\n","ogImage":{"url":"/assets/img/2024-06-23-WebhookTestingWithouttheHeadacheADevelopersSanity-SavingTutorial_0.png"},"coverImage":"/assets/img/2024-06-23-WebhookTestingWithouttheHeadacheADevelopersSanity-SavingTutorial_0.png","tag":["Tech"],"readingTime":12},{"title":"4개의 새로운 활발한 오픈 소스 프로젝트 소개","description":"","date":"2024-06-23 21:17","slug":"2024-06-23-4NewActiveOpenSourceProjects","content":"\n이것들은 인공 지능, 데이터 분석, 시각화 및 응용 프로그램 개발의 교차로에 있는 몇 가지 최첨단 오픈 소스 플랫폼 및 도구에 대한 개요입니다. 이 목록에서는 대부분 데이터베이스 시스템을 다루고 있지만 SuperMemory에 대해서도 놀라실 것이라고 생각합니다.\n\n## 더 읽을 거리:\n\nUX를 위한 카드 정렬 이해\n\n설명 가능한 AI를 위한 4가지 오픈 소스 도구\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n값에 의한 전달과 참조에 의한 전달 이해하기\n\n봉사 기회를 찾는 새로운 앱\n\n구독 무료인 AI 뉴스레터 BrainScriblr도 쓰고 있어요.\n\n![Image](/assets/img/2024-06-23-4NewActiveOpenSourceProjects_0.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## Metabase\n\n메타베이스는 사용자가 데이터베이스에 쉽게 연결하고 데이터를 탐색하고 시각화하며 통찰을 공유할 수 있는 비즈니스 인텔리전스 및 분석 플랫폼입니다.\n\n메타베이스는 MySQL, PostgreSQL, MongoDB, Redshift, Snowflake, BigQuery 등 다양한 데이터베이스에 연결할 수 있습니다. 몇 분만에 데이터베이스 연결 설정을 구성하는 직관적인 인터페이스를 제공합니다. 대규모 데이터 집합 및 복잡한 분석 쿼리를 처리하기 위해 메타베이스는 대량 데이터를 확장 가능한 방식으로 실행하는 Redshift, Snowflake, BigQuery, Vertica 등의 데이터 웨어하우스에 연결할 수 있습니다.\n\nMySQL, PostgreSQL, Oracle, SQL Server와 같은 전통적인 관계형 데이터베이스 관리 시스템(RDBMS)에 저장된 데이터를 분석하기에 적합합니다. 이러한 데이터베이스는 데이터를 탐색하고 빠르게 통찰을 얻기 위해 Metabase를 시작하는 데 좋습니다. 또한 메타베이스는 Apache Spark(SparkSQL) 및 Presto와 같은 쿼리 엔진과 통합되어 실시간 스트리밍 데이터를 포함한 다양한 소스에서 데이터를 쿼리할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## LanceDB\n\nLanceDB는 데이터 분석 및 머신 러닝 워크플로우를 최적화하도록 특별히 설계된 오픈 소스 데이터베이스입니다. 뛰어난 성능과 확장성으로 주목받으며 대용량 및 복잡한 데이터 세트를 관리하는 데 이상적인 선택지입니다.\n\nLanceDB는 데이터 액세스와 조작이 신속하게 이루어지므로 데이터 처리와 실시간 분석을 필요로 하는 작업에 필수적입니다. 그 아키텍처는 머신 러닝 응용 프로그램의 요구 사항을 처리하도록 맞추어져 있어 방대한 데이터 세트를 효율적으로 저장하고 조회하는 견고한 기반을 제공합니다.\n\n인기 있는 데이터 과학 도구 및 프레임워크와 원활하게 통합됩니다. Pandas, TensorFlow, PyTorch 등의 라이브러리와 잘 작동하여 데이터 과학자와 엔지니어들이 기존의 워크플로에 쉽게 통합할 수 있도록 지원합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 호환성은 데이터 처리 과정을 간소화하여 사용자가 데이터 관리 복잡성보다는 분석 및 모델 구축에 더 집중할 수 있도록 돕습니다. 데이터베이스가 최소한의 대기 시간으로 복잡한 쿼리를 지원하는 능력은 요구되는 데이터 과학 환경에서의 유용성을 더욱 높여줍니다.\n\n또한 오픈 소스 프로젝트인 LanceDB는 활발하고 역동적인 커뮤니티의 혜택을 받아 지속적으로 발전하고 개선됩니다.\n\n## SuperMemory\n\n슈퍼메모리는 개인 디지털 “두 번째 뇌”로 작동하는 혁신적인 플랫폼입니다. 다양한 온라인 소스에서 정보를 통합하여 사용자가 데이터를 효율적으로 저장하고 조직할 수 있습니다. 이 도구는 방대한 지식 베이스를 관리해야 하는 연구자, 작가 및 개발자들에게 특히 유용합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n컬렉션을 생성하고, 고급 데이터 상호작용을 위해 AI를 사용하며, 강력한 검색 기능을 활용하여 빠르게 정보를 검색할 수 있습니다. 이 플랫폼의 2D 지식 캔버스는 시각적으로 조직화를 가능하게 하며, 사용자의 정보 연결 및 기억 능력을 향상시킵니다.\n\n그리고, Supermemory는 콘텐츠 생성을 돕는 글쓰기 어시스턴트를 제공하고, Twitter 북마크를 가져오는 것을 지원하여 다양한 전문적인 요구에 유연하게 대처할 수 있습니다. AI와 사용자 친화적 기능을 통합함으로써, Supermemory는 방대한 양의 정보를 관리하고 상호 작용하는 프로세스를 최적화하여 생산성과 지식 보존을 극대화합니다.\n\n![이미지](/assets/img/2024-06-23-4NewActiveOpenSourceProjects_1.png)\n\n## Tantivy\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nTantivy는 러스트로 작성된 완전한 텍스트 검색 엔진 라이브러리로, 뛰어난 성능과 신뢰성을 제공하도록 설계되었습니다. GitHub에서 제공되는 이 프로젝트는 Apache Lucene과 유사한 효율적이고 다양한 검색 엔진 프레임워크를 목표로 합니다.\n\nTantivy의 기능에는 텍스트 데이터의 색인화, 질의, 그리고 점수 매기기가 포함되어 있으며, 구문 검색, 모호한 검색, 용어 부스트, 범위 질의와 같은 고급 검색 기능을 지원합니다. 효율적인 아키텍처는 빠른 데이터 검색과 견고한 성능을 보장하여 고성능 검색 애플리케이션을 개발하는 개발자들에게 이상적인 선택지가 됩니다.\n\nTantivy는 사용자 친화적인 디자인과 포괄적인 문서를 통해 라이브러리를 효과적으로 통합하고 활용할 수 있도록 도와줍니다. 이 프로젝트는 간단한 애플리케이션에서의 검색 기능 빌드부터 기업 환경에서의 복잡한 대규모 검색 요구사항 처리에 이르기까지 다양한 사용 사례를 지원합니다.\n\n활발한 커뮤니티와 지속적인 개발 노력은 Tantivy의 견고함과 적응성에 기여하여 풀 텍스트 검색 요구사항에 대한 신뢰할 수 있고 최신의 솔루션이 되도록 보장합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n오픈 소스는 끊임없이 발전하는 공간입니다. 매주 새로운 도구가 하나 또는 두 개씩 나오고 있습니다. 특히 AI가 급속히 발전함에 따라 AI가 시스템에 통합된 도구들이 빠르게 개발되고 있습니다. 여러분이 다음 개발 프로젝트에서 사용할 가치 있는 프로젝트 중 하나를 찾기를 바랍니다. 또는 Supermemory와 같이 개인적인 용도로 사용해보세요. 그러나 Supermemory를 업무에도 사용할 수 있습니다.\n\n건배!\n","ogImage":{"url":"/assets/img/2024-06-23-4NewActiveOpenSourceProjects_0.png"},"coverImage":"/assets/img/2024-06-23-4NewActiveOpenSourceProjects_0.png","tag":["Tech"],"readingTime":5},{"title":"좋은 코드와 나쁜 코드란 비전문가를 위한 일러스트 예제","description":"","date":"2024-06-23 21:16","slug":"2024-06-23-WhatisgoodbadcodeAnillustratedexamplefornon-programmers","content":"\n한 번 어딘가에서 다음 내용을 담은 것 같은 격언을 읽은 적이 있어요:\n\n어떤 대중적인 출판물에 나온 것 같다는 기억이 나요. 기사의 주제가 “나쁜 코드에 주의하세요. 죽을 수도 있어요. 아, 그렇지만 보이지 않으니 걱정 마세요!” 정도의 내용이었던 것 같아요. 독자들에게는 진정한 위안이 되는 메시지네요, 그렇지 않나요? 회상해 보면, 그 기사는 우리 주변에 점점 늘어나는 항공기, 기차, 그리고 자율 주행 자동차들 속에 숨어 있는 ‘나쁜 코드’를 선동하는 취지였던 것 같아요. 그리고 독자들의 관심을 끌려고 한 것 같기도 해요.\n\n# 일반인으로서 ‘나쁜 코드’란 무엇일까요?\n\n하루에 약 5시간 동안 코드를 작성하고 검토하며 다시 작성하는 일(코드 리팩토링: 보다 간결하고 사용하기 편한 방식으로 재작성하는 것)을 하는 사람으로써, 코드가 무엇인지(나쁜 코드가 무엇인지도, 확실히 알아요!). 많은 사람들이 코드가 무엇인지 모른다는 것을 잊을 때가 종종 있어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위 문제에 대한 다음 대답을 제공합니다. “너는 코더인데, 무슨 일을 하는 거야?”\n\n위 대답이 언급한 대로, 소프트웨어 개발자/코더/프로그래머는 사실적인 존재를 가진 것을 만들고 있지만 그것들은 보기에는 너무 작아서 실체를 파악하기 어렵습니다 (하지만, 어셈블리 또는 작은 문 모음집으로 상상할 수 있습니다). 그 자체만으로 충분히 미친 듯한 일이지만, 적어도 그것을 상상할 수 있다면 \"코딩\"이 무엇인지 개념적으로 이해했다고 축하해요! 그러나 이 섹션 제목의 질문으로 돌아갑시다. — '나쁜 코드'란 무엇일까요?\n\n작은 문 모음집 비유를 유지하면, 나쁜 코드란 너무 많은 문이 있는데 그 문들이 불필요하게 반복되거나 복잡한 방식으로 배치된 것을 뜻합니다.\n\n문 모음집 비유로는 시각화하기나 더 설명하기 어렵기 때문에, 이 시점에서 아래에 작성하고 설명하는 다른 비유를 제공하고 싶습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 나사 돌리기 장치 만들기!\n\n우리가 나사 돌리기 장치를 만들고 싶다고 가정해 봅시다. 회전 가능한 나사를 만들어서 먼 곳에 있는 다른 나사도 함께 회전시킬 수 있는 장치입니다. 제품 요구 사항은 아래와 같습니다. 한 개의 나사를 돌리면, 멀리 떨어진 다른 나사도 회전할 것입니다:\n\n![이미지](/assets/img/2024-06-23-WhatisgoodbadcodeAnillustratedexamplefornon-programmers_0.png)\n\n나쁜 코드는 일단 문제를 해결하는 데만 집중하며, 나사와 나사 돌리기 장치를 반죽으로 연결하는 가장 쉬운 해결책을 제안합니다. 나쁜 코드는 초반에 Occam의 면도날 상을 수상합니다. 좋은 코드는 초반에는 조금 지나친 것처럼 보이며, 고무 벨트와 2개의 바퀴를 활용합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-06-23-WhatisgoodbadcodeAnillustratedexamplefornon-programmers_1.png\" />\n\n# 요구 사항 변경! 손잡이가 다시 위치로 이동되어야 합니다!\n\n개발 주기에서 항상 발생하는 것처럼 어느 순간 고객 요구 사항이 변경됩니다. 이 비유에서 고객은 이제 원래 손잡이의 앞쪽과 옆쪽에 위치한 다른 손잡이를 회전시킬 수 있는 손잡이를 원합니다. 아래 그림과 같이요:\n\n<img src=\"/assets/img/2024-06-23-WhatisgoodbadcodeAnillustratedexamplefornon-programmers_2.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n나쁜 코드는 몇 개의 간단한 부품을 추가해야 하며, 이는 전체 시스템을 보다 부서지기 쉽고 고장 발생 가능성이 높게 만듭니다. 좋은 코드는 새로운 요구 사항이 생겨도 약간의 조정만으로 문제를 해결할 수 있으며, 그냥 더 긴 고무 벨트를 사용하여 이 문제를 해결합니다.\n\n![이미지](/assets/img/2024-06-23-WhatisgoodbadcodeAnillustratedexamplefornon-programmers_3.png)\n\n# 요구 사항 변경! 손잡이의 회전 속도를 늦춰야 합니다!\n\n마침내, 고객님이 손잡이를 서로 다른 속도로 회전하길 원하는 결정을 내렸습니다. 입력 손잡이를 작게 돌리면 연결된 손잡이가 크게 회전해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n새 요구 사항에 따라, 나쁜 코드는 시스템에 더 많은 구성 요소를 추가해야 하므로 더욱 복잡해집니다. 반면에 좋은 코드는 다시 한번 조정이 필요하며 연결된 조절 부분에 더 큰 휠을 사용하는 것으로 충분합니다:\n\n![이미지](/assets/img/2024-06-23-WhatisgoodbadcodeAnillustratedexamplefornon-programmers_4.png)\n\n# 비유 후기: 그렇다면?\n\n위의 내용처럼, 요구 사항이 간단할 때 좋은 코드는 종종 과잉으로 느껴지지만, 고객 요구 사항이 변경될 때(항상 그렇듯이) 정말 빛을 발합니다. 다시 말해, 잘 확장되고 변경됩니다. 반면에 나쁜 코드는 간단한 문제에 대해 간단하고 좋아 보이지만, 시스템이 변경되거나 복잡성이 증가할 때 악몽이 됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n하지만 혹시 \"음, 위에서 설명한 두 시스템 모두 결국 같은 결과를 얻을 수 있어요 - 손잡이 회전기는 어느 경우에도 성공적으로 작동해요\" 라고 생각하고 계실지도 모릅니다.\n\n맞아요 - 혼자서 개발하거나 취미로 프로젝트를 하는 경우에는 괜찮은 방법입니다. 저도 (제 경우에는 일반 JS 코드) 수만 줄의 나쁜 코드를 작성한 적이 많았는데요, 그렇다고 문제가 없었어요. 그 코드는 작동하고, 배포하고, 한 번도 되돌아본 적이 없어요.\n\n하지만 전문적인 코딩은 본질적으로 협업의 결과물이에요. 그리고 여러분이 작성하는 코드는 현재나 미래에 다른 개발자들에 의해 계속해서 읽히고 수정될 거에요. 코드가 이해하기 쉬울수록 다른 개발자들이 더 쉽고 효율적으로 작업할 수 있으니까요.\n\n- \"여기 손잡이 회전기가 있어요. 2개의 바퀴와 벨트로 구성돼요\" 또는\n- \"이것이 연결 막대를 보관하는 삽입이에요. 이것이 연결 막대이고, 이 다른 삽입 위에 있는 작은 구멍에 막대의 끝을 넣어야 해요...\"\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n나는 당신이 시니어 개발자로부터 코드베이스를 이어받는 주니어 개발자라면 어떤 것을 더 좋아할지 궁금해요! :)\n","ogImage":{"url":"/assets/img/2024-06-23-WhatisgoodbadcodeAnillustratedexamplefornon-programmers_0.png"},"coverImage":"/assets/img/2024-06-23-WhatisgoodbadcodeAnillustratedexamplefornon-programmers_0.png","tag":["Tech"],"readingTime":5}],"page":"19","totalPageCount":120,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true}