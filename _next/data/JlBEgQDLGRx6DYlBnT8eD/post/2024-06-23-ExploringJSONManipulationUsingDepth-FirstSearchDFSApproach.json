{"pageProps":{"post":{"title":"깊이 우선 탐색DFS 방법으로 JSON 조작 탐구하기","description":"","date":"2024-06-23 20:33","slug":"2024-06-23-ExploringJSONManipulationUsingDepth-FirstSearchDFSApproach","content":"\n![2024-06-23-ExploringJSONManipulationUsingDepth-FirstSearchDFSApproach_0.png](/assets/img/2024-06-23-ExploringJSONManipulationUsingDepth-FirstSearchDFSApproach_0.png)\n\n# 소개\n\n우리 조직의 애플리케이션 기능을 향상시키는 과정에서, JSON 조작에 관련된 매력적인 문제를 만났습니다. 특정 경로에 있는 JSON 노드의 값을 수정하는 작업은 트리 구조를 탐색하는 것과 유사한 문제입니다. 이를 해결하기 위해 Depth-First Search (DFS) 접근 방식을 활용해보았고, 이 방법이 이 문제를 효과적으로 해결하는 데 도움이 되었습니다.\n\n# 문제 이해하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nJSON (JavaScript Object Notation)은 컴퓨터 과학에서 사용되는 트리와 유사한 계층 구조와 간결함으로 인해 데이터 교환에 널리 사용됩니다. 문제는 이와 같은 트리 구조 내에서 특정 경로의 값을 동적으로 액세스하고 수정해야 하는 것이 필요했습니다. 예를 들어, 경로 a.b.c에서 '\"a\": '\"b\": '\"c\": 123''를 변환하는 것은 전형적인 JSON 탐색 및 수정을 보여줍니다.\n\n# 접근 방식 및 통찰\n\n## 1. JSON을 트리로 다루기\n\nJSON의 중첩된 키-값 쌍은 트리에서 노드로 해석될 수 있으며, 객체는 내부 노드를 나타내고 배열은 노드들의 집합을 나타냅니다. 각 노드는 루트에서 리프 노드까지 탐색하는 것과 유사하게 경로를 통해 액세스할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 2. 깊이 우선 탐색 (DFS) 응용\n\nDFS는 기본적인 트리 순회 알고리즘으로, 다음 문제 해결에 중요한 역할을 했습니다:\n\n- 재귀적 탐색: 루트(최상위 객체)에서 시작하여 중첩된 객체와 배열을 재귀적으로 탐색합니다.\n- 경로 탐색: 제공된 경로 문자열 (a.b.c - `[\"a\", \"b\", \"c\"])을 사용하여 중첩된 구조물을 효율적으로 탐색합니다.\n- 유연한 수정: 대상 노드를 식별한 후, 간단한 값 업데이트 또는 배열 내 요소 변환 등 구체적인 요구에 따라 값을 수정할 수 있습니다.\n\n## 3. 구현 여정\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- JSON 파싱: Java의 org.json과 같은 라이브러리를 활용하여 JSON 객체를 분석하고 조작하는 작업을 원활하게 수행했습니다.\n- 경로 처리: 경로 문자열을 동적으로 분할하고 해석하여 중첩된 객체를 탐색하는 데 활용했습니다.\n- 시나리오 처리: JSON 객체 내에 배열이 존재하는 경우와 같은 시나리오를 다루며, 모든 요소가 수정되어야 하는 경우를 대응했습니다.\n\n# 코드 구현 예제\n\n```java\nimport org.json.*;\n\npublic class JsonManipulation {\n\n    public static String modifyJsonNode(String json, String path) {\n        JSONObject jsonObj = new JSONObject(json);\n        String[] keys = path.split(\"\\\\.\");\n        modifyNode(jsonObj, keys, 0);\n        return jsonObj.toString();\n    }\n\n    private static void modifyNode(JSONObject jsonObj, String[] keys, int index) {\n        String key = keys[index];\n        if (index == keys.length - 1) {\n            if (jsonObj.get(key) instanceof JSONArray) {\n                JSONArray array = jsonObj.getJSONArray(key);\n                for (int i = 0; i < array.length(); i++) {\n                    array.put(i, \"modified\");\n                }\n            } else {\n                jsonObj.put(key, \"modified\");\n            }\n        } else {\n            modifyNode(jsonObj.getJSONObject(key), keys, index + 1);\n        }\n    }\n\n    public static void main(String[] args) {\n        String json = \"{\\\"a\\\": {\\\"b\\\": {\\\"c\\\": 123}}\";\n        String path = \"a.b.c\";\n        System.out.println(modifyJsonNode(json, path));\n    }\n}\n```\n\n# 결론\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nDFS를 활용한 JSON 조작 탐구는 이 알고리즘이 JSON과 같은 계층 구조 데이터를 탐색하고 수정하는 다양성을 강조합니다. DFS 원칙을 적용함으로써 우리는 특정 경로를 기반으로 JSON 노드에 동적으로 접근하고 수정하는 작업을 효율적으로 처리했습니다.\n\n소프트웨어 엔지니어로서 DFS와 같은 알고리즘 기법을 받아들이면 복잡한 데이터 조작 작업을 자신 있게 다룰 수 있습니다. 이 여정은 일상적인 코딩 과제에서 알고리즘적 사고의 중요성을 강조하며 문제 해결 능력과 소프트웨어 개발 혁신 능력을 함께 향상시킵니다.\n","ogImage":{"url":"/assets/img/2024-06-23-ExploringJSONManipulationUsingDepth-FirstSearchDFSApproach_0.png"},"coverImage":"/assets/img/2024-06-23-ExploringJSONManipulationUsingDepth-FirstSearchDFSApproach_0.png","tag":["Tech"],"readingTime":4},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p><img src=\"/assets/img/2024-06-23-ExploringJSONManipulationUsingDepth-FirstSearchDFSApproach_0.png\" alt=\"2024-06-23-ExploringJSONManipulationUsingDepth-FirstSearchDFSApproach_0.png\"></p>\n<h1>소개</h1>\n<p>우리 조직의 애플리케이션 기능을 향상시키는 과정에서, JSON 조작에 관련된 매력적인 문제를 만났습니다. 특정 경로에 있는 JSON 노드의 값을 수정하는 작업은 트리 구조를 탐색하는 것과 유사한 문제입니다. 이를 해결하기 위해 Depth-First Search (DFS) 접근 방식을 활용해보았고, 이 방법이 이 문제를 효과적으로 해결하는 데 도움이 되었습니다.</p>\n<h1>문제 이해하기</h1>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>JSON (JavaScript Object Notation)은 컴퓨터 과학에서 사용되는 트리와 유사한 계층 구조와 간결함으로 인해 데이터 교환에 널리 사용됩니다. 문제는 이와 같은 트리 구조 내에서 특정 경로의 값을 동적으로 액세스하고 수정해야 하는 것이 필요했습니다. 예를 들어, 경로 a.b.c에서 '\"a\": '\"b\": '\"c\": 123''를 변환하는 것은 전형적인 JSON 탐색 및 수정을 보여줍니다.</p>\n<h1>접근 방식 및 통찰</h1>\n<h2>1. JSON을 트리로 다루기</h2>\n<p>JSON의 중첩된 키-값 쌍은 트리에서 노드로 해석될 수 있으며, 객체는 내부 노드를 나타내고 배열은 노드들의 집합을 나타냅니다. 각 노드는 루트에서 리프 노드까지 탐색하는 것과 유사하게 경로를 통해 액세스할 수 있습니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h2>2. 깊이 우선 탐색 (DFS) 응용</h2>\n<p>DFS는 기본적인 트리 순회 알고리즘으로, 다음 문제 해결에 중요한 역할을 했습니다:</p>\n<ul>\n<li>재귀적 탐색: 루트(최상위 객체)에서 시작하여 중첩된 객체와 배열을 재귀적으로 탐색합니다.</li>\n<li>경로 탐색: 제공된 경로 문자열 (a.b.c - `[\"a\", \"b\", \"c\"])을 사용하여 중첩된 구조물을 효율적으로 탐색합니다.</li>\n<li>유연한 수정: 대상 노드를 식별한 후, 간단한 값 업데이트 또는 배열 내 요소 변환 등 구체적인 요구에 따라 값을 수정할 수 있습니다.</li>\n</ul>\n<h2>3. 구현 여정</h2>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<ul>\n<li>JSON 파싱: Java의 org.json과 같은 라이브러리를 활용하여 JSON 객체를 분석하고 조작하는 작업을 원활하게 수행했습니다.</li>\n<li>경로 처리: 경로 문자열을 동적으로 분할하고 해석하여 중첩된 객체를 탐색하는 데 활용했습니다.</li>\n<li>시나리오 처리: JSON 객체 내에 배열이 존재하는 경우와 같은 시나리오를 다루며, 모든 요소가 수정되어야 하는 경우를 대응했습니다.</li>\n</ul>\n<h1>코드 구현 예제</h1>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-keyword\">import</span> org.json.*;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">JsonManipulation</span> {\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> String <span class=\"hljs-title function_\">modifyJsonNode</span><span class=\"hljs-params\">(String json, String path)</span> {\n        <span class=\"hljs-type\">JSONObject</span> <span class=\"hljs-variable\">jsonObj</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">JSONObject</span>(json);\n        String[] keys = path.split(<span class=\"hljs-string\">\"\\\\.\"</span>);\n        modifyNode(jsonObj, keys, <span class=\"hljs-number\">0</span>);\n        <span class=\"hljs-keyword\">return</span> jsonObj.toString();\n    }\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">modifyNode</span><span class=\"hljs-params\">(JSONObject jsonObj, String[] keys, <span class=\"hljs-type\">int</span> index)</span> {\n        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">key</span> <span class=\"hljs-operator\">=</span> keys[index];\n        <span class=\"hljs-keyword\">if</span> (index == keys.length - <span class=\"hljs-number\">1</span>) {\n            <span class=\"hljs-keyword\">if</span> (jsonObj.get(key) <span class=\"hljs-keyword\">instanceof</span> JSONArray) {\n                <span class=\"hljs-type\">JSONArray</span> <span class=\"hljs-variable\">array</span> <span class=\"hljs-operator\">=</span> jsonObj.getJSONArray(key);\n                <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; i &#x3C; array.length(); i++) {\n                    array.put(i, <span class=\"hljs-string\">\"modified\"</span>);\n                }\n            } <span class=\"hljs-keyword\">else</span> {\n                jsonObj.put(key, <span class=\"hljs-string\">\"modified\"</span>);\n            }\n        } <span class=\"hljs-keyword\">else</span> {\n            modifyNode(jsonObj.getJSONObject(key), keys, index + <span class=\"hljs-number\">1</span>);\n        }\n    }\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> {\n        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">json</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">\"{\\\"a\\\": {\\\"b\\\": {\\\"c\\\": 123}}\"</span>;\n        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">path</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">\"a.b.c\"</span>;\n        System.out.println(modifyJsonNode(json, path));\n    }\n}\n</code></pre>\n<h1>결론</h1>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>DFS를 활용한 JSON 조작 탐구는 이 알고리즘이 JSON과 같은 계층 구조 데이터를 탐색하고 수정하는 다양성을 강조합니다. DFS 원칙을 적용함으로써 우리는 특정 경로를 기반으로 JSON 노드에 동적으로 접근하고 수정하는 작업을 효율적으로 처리했습니다.</p>\n<p>소프트웨어 엔지니어로서 DFS와 같은 알고리즘 기법을 받아들이면 복잡한 데이터 조작 작업을 자신 있게 다룰 수 있습니다. 이 여정은 일상적인 코딩 과제에서 알고리즘적 사고의 중요성을 강조하며 문제 해결 능력과 소프트웨어 개발 혁신 능력을 함께 향상시킵니다.</p>\n</body>\n</html>\n"},"__N_SSG":true}