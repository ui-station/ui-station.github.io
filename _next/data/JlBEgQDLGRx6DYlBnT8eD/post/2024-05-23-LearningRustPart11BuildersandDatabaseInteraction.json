{"pageProps":{"post":{"title":"러스트 배우기 11부  빌더와 데이터베이스 상호작용","description":"","date":"2024-05-23 14:11","slug":"2024-05-23-LearningRustPart11BuildersandDatabaseInteraction","content":"\n다음 시리즈로 넘어가보겠습니다; 이 부분에서는 데이터 구조에 빌더 패턴을 구현하는 방법을 살펴보겠습니다. 그런 다음 sqlx와 Postgres를 사용한 데이터베이스 상호작용으로 넘어가겠습니다.\n\n![이미지](/assets/img/2024-05-23-LearningRustPart11BuildersandDatabaseInteraction_0.png)\n\n# Rust 시리즈\n\n부분 1 — 기본 개념\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nPart 2 — 메모리\n\nPart 3 — 흐름 제어와 함수\n\nPart 4 — 옵션/결과 및 컬렉션\n\nPart 5 — 트레이트, 제네릭 및 클로저\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n제 6부 — 매크로, 반복자 및 파일 처리\n\n제 7부 — 스레드 공유 상태 및 채널\n\n제 8부 — Cargo, 크레이트, 모듈 및 라이브러리\n\n제 9부 — 명령행 인수, 워크스페이스 및 테스팅\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n제 10부 — 상자 포인터 및 웹 앱\n\n제 11부 — 빌더와 데이터베이스 상호작용 (이 기사)\n\n# 소개\n\n이것은 러스트 학습 시리즈의 열한 번째 섹션입니다. 이번에는 러스트에서 빌더 패턴을 다룰 것입니다. 이 공통된 패턴은 구조체를 안전하고 투명하게 초기화하는 좋은 방법입니다. 다음으로, 우리는 포스트그레스와 SQLX 프레임워크를 사용하여 데이터베이스에서 CRUD 작업을 수행하는 방법을 살펴볼 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 준비물\n\n이 글의 데이터베이스 부분을 위한 유일한 준비물은 Rust와 Cargo가 설치되어 있고 시스템에 Docker가 설치되어 있는 것입니다. 만약 Docker를 가지고 있지 않지만 로컬 Postgres DB가 이미 설치되어 있거나 다른 서버의 DB에 액세스할 수 있다면 Docker Postgres 설정을 건너뛰고 DB에 연결하기 위한 연결 속성만 수정하면 됩니다.\n\n# 빌더 패턴\n\n빌더 패턴은 복잡한 객체의 구성을 해당 표현에서 분리하는 디자인 패턴입니다. 이 패턴을 사용하면 유효성 검사를 수행하고 기본값으로 대체하며 값을 부분적으로 할당한 후에 항목을 생성할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nRust로 그 구현하는 방법을 살펴볼 거예요. 이것이 우리의 코드입니다.\n\n```js\n#[derive(Debug)]\nstruct ChargingSession {\n    id: String,\n    watts: u32,\n    vin: String,\n}\n\nstruct ChargingSessionBuilder {\n    id: String,\n    watts: Option<u32>,\n    vin: Option<String>,\n}\n\nimpl ChargingSessionBuilder {\n    fn new(id: &str) -> ChargingSessionBuilder {\n        ChargingSessionBuilder {\n            id: id.to_string(),\n            watts: None,\n            vin: None,\n        }\n    }\n\n    fn watts(mut self, watts: u32) -> ChargingSessionBuilder {\n        self.watts = Some(watts);\n        self\n    }\n\n    fn vin(mut self, vin: &str) -> ChargingSessionBuilder {\n        self.vin = Some(vin.to_string());\n        self\n    }\n\n    fn build(self) -> ChargingSession {\n        ChargingSession {\n            id: self.id,\n            watts: self.watts.unwrap_or_else(|| 0),\n            vin: self.vin.unwrap_or_else(|| \"Unknown\".to_string()),\n        }\n    }\n}\n\nfn main() {\n    // 이것은 ChargingSession을 생성하는 표준적인 방법입니다.\n    let cs_old_way = ChargingSession {\n        id: String::from(\"11111\"),\n        watts: 420,\n        vin: String::from(\"4Y1SL65848Z411439\"),\n    };\n    println!(\"Regular way to create struct: {:?}\", cs_old_way);\n\n    // 빌더를 사용해서 생성하는 방법입니다.\n    let cs = ChargingSessionBuilder::new(\"11111\")\n        .watts(420)\n        .vin(\"4Y1SL65848Z411439\")\n        .build();\n    println!(\"Builder pattern to create struct: {:?}\", cs);\n\n    // ID만 제공하여 생성하는 예시입니다.\n    let cs_lean = ChargingSessionBuilder::new(\"11111\")\n    .build();\n     println!(\"Builder pattern to create struct (default values): {:?}\", cs_lean);\n}\n```\n\n이걸 한 번에 이해하기에 많지만, 단계적으로 진행해 봅시다.\n\n먼저, 충전 세션 정보를 저장하는 구조체를 정의했습니다. 이 시리즈의 이전 예제에서 하나의 필드인 세션용 차량 ID 번호인 vin을 추가했어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그러면 데이터 구조체와 동일한 필드를 가진 빌더를 위한 구조체를 정의합니다.\n\n빌더는 impl 블록에서 구현되며, id 및 각 추가 필드를 설정하는 함수를 정의하는 새 함수가 있습니다. 그러나 몇 가지 중요한 사항이 있습니다.\n\n- 각 함수는 ChargingSessionBuilder 유형을 반환합니다. 기본적으로 self입니다.\n- 추가 속성 필드에는 mut self를 첫 번째 매개변수로 사용하는 메서드가 있습니다. 이는 이러한 함수 호출의 체이닝을 허용하는 데 중요합니다. 또한 여기에 유효성 검사 논리를 코딩할 수 있습니다.\n- build 함수가 모두 통합되는 곳입니다. 존재하는 값들을 할당하고 나면 기본값을 결정하고 대상 구조체를 생성할 수 있습니다.\n\n이를 통해 빌더 패턴의 우아함과 Rust 내에서의 구현 방법을 살펴보았습니다. 이것이 앱이나 라이브러리에 코드를 구현하는 훌륭한 방법임을 알 수 있기를 바랍니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음 섹션인 데이터베이스로 넘어가 봅시다.\n\n# 데이터베이스 — sqlx\n\n이 섹션에서는 Rust 프로그램에서 sqlx를 사용하여 데이터베이스 작업을 살펴볼 것입니다. 먼저 일부 설정이 필요합니다.\n\n## 설정\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n새 프로젝트를 시작해봅시다. db_app이라고 이름 짓고, cargo new db_app으로 생성할 수 있어요. 기본 디렉토리에 몇 개의 파일을 생성할 거에요. 첫 번째 파일은 docker-compose.yml이라고 하며 다음 내용이 있어야 합니다. Postgres와 Pgadmin이 노출되는 임의의 포트를 선택했으며, 컴퓨터에 설치된 다른 앱들과 충돌하지 않도록 했어요.\n\n```js\nversion: '3'\nservices:\n  postgres:\n    image: postgres:latest\n    container_name: postgres\n    ports:\n      - '6500:5432'\n    volumes:\n      - postgresDB:/data/postgres\n    env_file:\n      - ./.env\n  pgAdmin:\n    image: dpage/pgadmin4\n    container_name: pgAdmin\n    env_file:\n      - ./.env\n    ports:\n      - \"5050:80\"\nvolumes:\n  postgresDB:\n```\n\n.env이라는 파일이 하나 더 필요하며, 다음 내용이 있어야 해요. 이 파일은 docker-compose 파일과 나중에 Rust 애플리케이션에서 모두 사용할 거에요.\n\n```js\nPOSTGRES_HOST=127.0.0.1\nPOSTGRES_PORT=6500\nPOSTGRES_USER=admin\nPOSTGRES_PASSWORD=password123\nPOSTGRES_DB=charging_session\n\nDATABASE_URL=postgresql://admin:password123@localhost:6500/charging_session?currentSchema=public\n\nPGADMIN_DEFAULT_EMAIL=admin@admin.com\nPGADMIN_DEFAULT_PASSWORD=password123\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 내용과 함께 데이터베이스 사용자, 비밀번호, 그리고 Pgadmin에 대한 연결 정보를 제공해 드렸습니다.\n\n이 두 가지 항목을 만들고 위의 내용을 사용하여 Docker Compose를 사용하여 로컬 DB 인스턴스를 시작할 수 있습니다. 처음에는 항상 전경에서 시작하는 것을 좋아합니다. 이미지 다운로드 및 기타 작업을 하기 때문에 여러분의 컴퓨터 및 네트워크 속도에 따라 시간이 소요될 수 있습니다. docker-compose.yml 및 .env 파일이 있는 디렉토리와 동일한 위치에서 다음을 실행하십시오.\n\n```js\ndocker-compose up\n```\n\n시작된 모든 것을 확인한 후에는 언제든지 -d 스위치를 사용하여 데몬 모드로 시작할 수 있습니다. 완료되면 두 컨테이너가 시작되었는지 확인해 봅시다. 다음과 같이 명령을 실행합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\ndocker ps\n```\n\n비슷한 결과가 표시됩니다.\n\n<img src=\"/assets/img/2024-05-23-LearningRustPart11BuildersandDatabaseInteraction_1.png\" />\n\n만약 두 개의 컨테이너가 표시되지 않는다면, docker-compose를 실행한 터미널에서 에러를 확인해보세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n한 번 이들이 실행되면 DB에 연결해 봅시다. Pgadmin을 포트 5050에서 실행하도록 구성했으니 브라우저에서 http://localhost:5050을 입력하면 pgadmin의 로그인 화면이 표시됩니다. .env 파일에 구성된 자격 증명(관리자@관리자.com/비밀번호123)을 사용하여 pgadmin에 로그인할 수 있습니다. 그런데 아직 데이터베이스에 연결되지 않았습니다. 이를 위해 다음을 실행해야 합니다.\n\n```js\ndocker inspect postgres\n```\n\n출력을 확인하여 \"NetworkSettings\" 섹션으로 이동하고 \"IPAddress\" 속성의 값을 복사합니다. 이 값은 DB에 연결하는 데 사용할 호스트(IP)입니다. 제 컴퓨터에서 이 값은 172.23.0.1 이었습니다.\n\n로그인한 후 \"새 서버 추가\" 버튼을 클릭하고, \"호스트 이름/주소\"로 이전에 복사한 IP 주소를 포함한 필수 자격 증명을 제공하고 \"저장\" 버튼을 클릭하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n서버에 로그인하면 데이터베이스 charging_session을 볼 수 있습니다.\n\n![이미지](/assets/img/2024-05-23-LearningRustPart11BuildersandDatabaseInteraction_2.png)\n\n잘 했어요. 데이터베이스를 사용할 준비가 되었고 Pgadmin에서 관리할 수 있습니다.\n\n이제 Rust 앱의 종속성을 구성해 봅시다. 처음에는 모두 필요하지 않지만 결국 필요하게 될 것이므로 지금 추가해 두는 것이 좋습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nCargo.toml 파일의 종속성 부분을 다음과 같이 수정하세요.\n\n```toml\n[dependencies]\nchrono = { version = \"0.4.31\", features = [\"serde\"] }\ndotenv = \"0.15.0\"\nenv_logger = \"0.10.1\"\nlog = \"0.4.20\"\nserde = { version = \"1.0.193\", features = [\"derive\"] }\nserde_json = \"1.0.108\"\nsqlx = { version = \"0.7.3\", features = [\"runtime-tokio-native-tls\", \"postgres\", \"uuid\", \"chrono\"] }\ntokio = { version = \"1.35.0\", features = [\"macros\", \"rt-multi-thread\"]}\nuuid = { version = \"1.6.1\", features = [\"serde\", \"v4\"] }\n```\n\n다양한 종속성에 대해 활성화된 기능을 검토하는 데도 시간을 할애하는 것이 좋습니다.\n\n다음으로, 필요한 테이블을 만들기 위해 sqlx-cli 마이그레이션 기능을 사용할 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우선 명령 줄에서 다음을 실행하여 CLI를 설치해야 합니다.\n\n```js\ncargo install sqlx-cli --no-default-features --features rustls,postgres\n```\n\n그런 다음 마이그레이션 파일을 초기화해야 합니다. 다음과 같이 실행합니다.\n\n```js\nsqlx migrate add initial-tables\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 명령어는 우리가 마이그레이션 스크립트를 작성하기 위해 새 파일 migrations/`timestamp`\\_initial-tables.sql을 생성합니다.\n\n![이미지](/assets/img/2024-05-23-LearningRustPart11BuildersandDatabaseInteraction_3.png)\n\n이 파일을 열고 아래 SQL 문을 추가하여 테이블을 생성하세요.\n\ncreate table locations (\nid bigserial primary key,\nname varchar(255) unique not null\n);\n\ncreate table sessions (\nid bigserial primary key,\nlocation_id bigint not null,\nwatts bigint not null,\nvin varchar(255) not null,\nconstraint fk_location foreign key (location_id) references locations(id) on delete cascade\n);\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위 예제에서 사용할 두 개의 테이블 정의입니다. 이 시리즈의 충전 세션에 대한 표준 예제를 확장하여, 충전 장치의 위치를 저장할 locations 테이블을 추가했습니다.\n\n이제 다음을 실행하여 테이블을 생성하세요.\n\n```js\nsqlx migrate run\n```\n\n그러면 즉시 20231212235431/migrate initial-tables (타임스탬프 부분은 달라질 수 있음)과 같은 메시지가 표시됩니다. 이제 Pgadmin에 가서 테이블을 확인할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-05-23-LearningRustPart11BuildersandDatabaseInteraction_4.png\" />\n\n위에서 보듯이 두 개의 테이블이 생성되었고, 문서 목적을 위해 Pgadmin 내에 ERD 다이어그램도 생성했습니다. 이제 초기 설정과 프로젝트 구성을 완료했습니다.\n\n# 데이터베이스 함수\n\n이 섹션에서는 데이터베이스 상호 작용의 다양한 유형과 Rust 구현을 살펴볼 것입니다. 이는 데이터베이스에 연결하는 것으로 시작됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nDB에 연결하기\n\n데이터베이스에 연결하는 방법은 PgPoolOptions connect 함수를 통해 연결을 생성하는 것입니다. 우리의 .env 파일에서 데이터베이스 연결 문자열을 읽고 로깅을 구성하며 성공 또는 오류를 기록하는 코드 전체는 아래와 같습니다.\n\n```js\nuse sqlx::{postgres::PgPoolOptions, Pool, Postgres};\nuse dotenv::dotenv;\nuse log::{info, error};\n\n#[tokio::main]\nasync fn main() {\n    if std::env::var_os(\"RUST_LOG\").is_none() {\n        std::env::set_var(\"RUST_LOG\", \"info\");\n    }\n    dotenv().ok();\n    env_logger::init();\n\n    let database_url = std::env::var(\"DATABASE_URL\").expect(\"DATABASE_URL must be set\");\n    let pool = match PgPoolOptions::new()\n        .max_connections(10)\n        .connect(&database_url)\n        .await\n    {\n        Ok(pool) => {\n            info!(\"✅ 데이터베이스에 연결되었습니다!\");\n            pool\n        }\n        Err(err) => {\n            error!(\"🔥 데이터베이스 연결에 실패했습니다: {:?}\", err);\n            std::process::exit(1);\n        }\n    };\n}\n```\n\n시작 부분의 #[tokio::main] 매크로를 주목해주세요. 이는 async fn main()을 동기 fn main()로 변환하여 런타임 인스턴스를 초기화하고 async main 함수를 실행하게 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위 코드를 실행하면 출력 로깅에서 다음 메시지가 표시됩니다.\n\n[2023-12-13T00:16:42Z INFO db_app] ✅ 데이터베이스에 연결되었습니다!\n\n우리는 데이터베이스에 연결할 수 있습니다. .env 파일에서 구성한 모든 연결 정보를 기억해 주세요. 이 정보는 docker-compose, sqlx-cli, 그리고 우리의 어플리케이션에서 공유되었습니다.\n\n## Inserts\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 연결 풀이 준비되었으니, 우리가 살펴볼 첫 번째 데이터베이스 로직은 삽입입니다. sqlx를 사용하여 삽입하는 방법은 다음과 같습니다.\n\n```rust\nlet insert_result = sqlx::query_as!(\n    Locations,\n    \"INSERT INTO locations (id,name) VALUES (1, 'Location A') RETURNING *\"\n)\n.fetch_one(&pool)\n.await;\n\nmatch insert_result {\n    Ok(location) => {\n        info!(\"✓Inserted: {:?}\", location);\n    }\n    Err(e) => {\n        error!(\"Error Insert: {}\", e.to_string())\n    }\n}\n```\n\n이 코드는 하나의 레코드를 삽입할 것입니다. 물론 매개변수를 사용할 수도 있으며, 이는 업데이트를 살펴볼 때 살펴볼 것입니다.\n\n## 질의하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음으로, 데이터베이스를 조회하는 방법을 살펴보겠습니다.\n\n```js\n    let query_result = sqlx::query_as!(Locations, \"SELECT * FROM Locations\")\n        .fetch_all(&pool)\n        .await;\n    if query_result.is_err() {\n        let message = \"모든 위치를 가져오는 동안 문제가 발생했습니다.\";\n        error!(\"{}{}\", message, query_result.err().unwrap());\n    } else {\n        info!(\"😎 위치에 대한 쿼리 결과 {:?}\", query_result.unwrap());\n    }\n```\n\n이것은 성공적으로 작동했다면 unwrap을 통해 결과에 접근할 수 있는 결과를 반환합니다. 쿼리 내의 이슈가 발생했다면 해당 에러에 접근할 수도 있습니다.\n\n## 업데이트\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음 작업은 데이터베이스를 업데이트하는 것입니다. 이는 이전에 삽입한 것과 비슷할 것입니다.\n\n```js\n    let update_result = sqlx::query_as!(\n        Sessions,\n        \"UPDATE sessions SET watts = 415 WHERE id = $1 RETURNING *\",\n        1i64,\n    )\n    .fetch_one(&pool)\n    .await;\n\n    match update_result {\n        Ok(session) => {\n            info!(\"✓Update: {:?}\", session);\n        }\n        Err(e) => {\n            error!(\"Error Update: {}\", e.to_string())\n        }\n    }\n```\n\n이 예제에서 주목할 점은 $1이라는 매개변수 자리 표시자를 사용하는 준비된 문(statement)를 사용하고 있다는 것입니다. 그런 다음 SQL 문자열 뒤에 매개변수를 전달합니다.\n\n## Deletes\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n마지막으로, 데이터베이스에서 레코드를 삭제하는 CRUD 작업을 완료합니다. 우리의 목적은 데이터베이스를 정리하는 데 사용할 것이며, 이렇게 하면 언제든지 응용 프로그램을 실행할 수 있습니다.\n\n```js\nlet rows_deleted = sqlx::query!(\"DELETE from sessions\")\n    .execute(&pool)\n    .await\n    .unwrap()\n    .rows_affected();\n\ninfo!(\"✕ 세션 테이블에서 {}개의 행 삭제됨\", rows_deleted);\n```\n\n여기서는 연산에서처럼 sqlx::query 대신 sqlx::query_as를 사용합니다. 또한 언랩 이후 .rows_affected를 추가하여 삭제된 행 수를 얻습니다.\n\n## 트랜잭션\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```rust\n   let tx = pool.begin().await.expect(\"트랜잭션을 시작할 수 없습니다\");\n\n   // 데이터베이스 작업 수행(데이터 삽입 또는 변경)\n\n   tx.commit().await.expect(\"트랜잭션을 커밋할 수 없습니다\");\n```\n\n커밋을 호출하지 않으면 트랜잭션이 범위를 벗어나면 자동으로 롤백됩니다.\n\n## 완전한 응용 프로그램\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 코드는 우리가 이전에 논의한 모든 다양한 기능이 하나의 애플리케이션에 모두 포함된 완전한 애플리케이션입니다.\n\n```js\nuse dotenv::dotenv;\nuse log::{error, info};\nuse sqlx::{postgres::PgPoolOptions, Pool, Postgres};\n\n#[derive(Debug)]\nstruct Locations {\n    id: i64,\n    name: String,\n}\n\n#[derive(Debug)]\nstruct Sessions {\n    id: i64,\n    location_id: i64,\n    watts: i64,\n    vin: String,\n}\nasync fn insert_into_locations(pool: Pool<Postgres>) {\n    let tx = pool.begin().await.expect(\"Unable to begin transaction\");\n\n    let insert_result = sqlx::query_as!(\n        Locations,\n        \"INSERT INTO locations (id,name) VALUES (1, 'Location A') RETURNING *\"\n    )\n    .fetch_one(&pool)\n    .await;\n\n    match insert_result {\n        Ok(location) => {\n            info!(\"✓Inserted: {:?}\", location);\n        }\n        Err(e) => {\n            error!(\"Error Insert: {}\", e.to_string())\n        }\n    }\n    let insert_result = sqlx::query_as!(\n        Locations,\n        \"INSERT INTO locations (id,name) VALUES (2, 'Location B') RETURNING *\"\n    )\n    .fetch_one(&pool)\n    .await;\n\n    match insert_result {\n        Ok(location) => {\n            info!(\"✓Inserted: {:?}\", location);\n        }\n        Err(e) => {\n            error!(\"Error Insert: {}\", e.to_string())\n        }\n    }\n\n    tx.commit().await.expect(\"Unable to commit the transaction\");\n}\n\nasync fn insert_into_sessions(pool: Pool<Postgres>) {\n    let tx = pool.begin().await.expect(\"Unable to begin transaction\");\n\n    let insert_result = sqlx::query_as!(\n        Sessions,\n        \"INSERT INTO sessions (id,location_id, watts, vin) VALUES (1, 1, 420, '2FMZA52286BA02033') RETURNING *\"\n    )\n    .fetch_one(&pool)\n    .await;\n\n    match insert_result {\n        Ok(session) => {\n            info!(\"✓Inserted: {:?}\", session);\n        }\n        Err(e) => {\n            error!(\"Error Insert: {}\", e.to_string())\n        }\n    }\n    let insert_result = sqlx::query_as!(\n        Sessions,\n        \"INSERT INTO sessions (id,location_id, watts, vin) VALUES (2, 2, 393, '1GMYA52286BA04055') RETURNING *\"\n)\n    .fetch_one(&pool)\n    .await;\n\n    match insert_result {\n        Ok(session) => {\n            info!(\"✓Inserted: {:?}\", session);\n        }\n        Err(e) => {\n            error!(\"Error Insert: {}\", e.to_string())\n        }\n    }\n\n    tx.commit().await.expect(\"Unable to commit the transaction\");\n}\n\nasync fn update_sessions(pool: Pool<Postgres>) {\n    let tx = pool.begin().await.expect(\"Unable to begin transaction\");\n\n    let update_result = sqlx::query_as!(\n        Sessions,\n        \"UPDATE sessions SET watts = 415 WHERE id = $1 RETURNING *\",\n        1i64,\n    )\n    .fetch_one(&pool)\n    .await;\n\n    match update_result {\n        Ok(session) => {\n            info!(\"✓Update: {:?}\", session);\n        }\n        Err(e) => {\n            error!(\"Error Update: {}\", e.to_string())\n        }\n    }\n\n    tx.commit().await.expect(\"Unable to commit the transaction\");\n}\n\nasync fn clean_db(pool: Pool<Postgres>) {\n    let rows_deleted = sqlx::query!(\"DELETE from sessions\")\n        .execute(&pool)\n        .await\n        .unwrap()\n        .rows_affected();\n\n    info!(\"✕Deleted {} rows from sessions table\", rows_deleted);\n\n    let rows_deleted = sqlx::query!(\"DELETE from locations\")\n        .execute(&pool)\n        .await\n        .unwrap()\n        .rows_affected();\n    info!(\"✕Deleted {} rows from locations table\", rows_deleted);\n}\n\nasync fn query_locations(pool: Pool<Postgres>) {\n    let query_result = sqlx::query_as!(Locations, \"SELECT * FROM Locations\")\n        .fetch_all(&pool)\n        .await;\n    if query_result.is_err() {\n        let message = \"Something bad happened while fetching all locations\";\n        error!(\"{}\", message);\n    } else {\n        info!(\"😎Query Result For Locations {:?}\", query_result);\n    }\n}\n\nasync fn query_sessions(pool: Pool<Postgres>) {\n    let query_result = sqlx::query_as!(Sessions, \"SELECT * FROM Sessions\")\n        .fetch_all(&pool)\n        .await;\n    if query_result.is_err() {\n        let message = \"Something bad happened while fetching all sessions\";\n        error!(\"{}\", message);\n    } else {\n        info!(\"😎Query Result for Sessions {:?}\", query_result);\n    }\n}\n\n#[tokio::main]\nasync fn main() {\n    if std::env::var_os(\"RUST_LOG\").is_none() {\n        std::env::set_var(\"RUST_LOG\", \"info\");\n    }\n    dotenv().ok();\n    env_logger::init();\n\n    let database_url = std::env::var(\"DATABASE_URL\").expect(\"DATABASE_URL must be set\");\n    let pool = match PgPoolOptions::new()\n        .max_connections(10)\n        .connect(&database_url)\n        .await\n    {\n        Ok(pool) => {\n            info!(\"✅Connection to the database is successful!\");\n            pool\n        }\n        Err(err) => {\n            error!(\"🔥 Failed to connect to the database: {:?}\", err);\n            std::process::exit(1);\n        }\n    };\n    clean_db(pool.clone()).await;\n\n    insert_into_locations(pool.clone()).await;\n    query_locations(pool.clone()).await;\n\n    insert_into_sessions(pool.clone()).await;\n    query_sessions(pool.clone()).await;\n\n    update_sessions(pool.clone()).await;\n    query_sessions(pool.clone()).await;\n}\n```\n\n위 애플리케이션을 실행한 결과는 다음과 같습니다.\n\n<img src=\"/assets/img/2024-05-23-LearningRustPart11BuildersandDatabaseInteraction_5.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위와 같이 데이터베이스 상호작용 토론을 마쳤습니다. sqlx를 사용하여 데이터베이스 작업을 수행하는 방법에 대해 좋은 개요를 제공했을 겁니다.\n\n# 요약\n\n저희 러스트 학습 시리즈의 이 부분을 즐기셨기를 바랍니다. 시리즈 이번 섹션에서는 먼저 러스트에서 객체 생성에 대한 매우 유용한 패턴인 빌더 패턴을 살펴보았습니다. 이는 다른 언어에서 익숙할 수 있지만, 러스트에서 어떻게 구현하는지 살펴보았습니다.\n\n다음으로, 우리는 Rust를 사용하여 데이터베이스인 특히 Postgres와 상호작용하는 방법을 검토했습니다. 우리는 마이그레이션을 실행하고 데이터베이스에 연결하는 방법을 보았으며, 그 후 DB에 대해 여러 가지 CRUD 작업을 수행하는 방법을 살펴보았습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n러스트 학습 여정에 함께해줘서 고마워요.\n\n좋은 여행 되세요!\n","ogImage":{"url":"/assets/img/2024-05-23-LearningRustPart11BuildersandDatabaseInteraction_0.png"},"coverImage":"/assets/img/2024-05-23-LearningRustPart11BuildersandDatabaseInteraction_0.png","tag":["Tech"],"readingTime":24},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p>다음 시리즈로 넘어가보겠습니다; 이 부분에서는 데이터 구조에 빌더 패턴을 구현하는 방법을 살펴보겠습니다. 그런 다음 sqlx와 Postgres를 사용한 데이터베이스 상호작용으로 넘어가겠습니다.</p>\n<p><img src=\"/assets/img/2024-05-23-LearningRustPart11BuildersandDatabaseInteraction_0.png\" alt=\"이미지\"></p>\n<h1>Rust 시리즈</h1>\n<p>부분 1 — 기본 개념</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>Part 2 — 메모리</p>\n<p>Part 3 — 흐름 제어와 함수</p>\n<p>Part 4 — 옵션/결과 및 컬렉션</p>\n<p>Part 5 — 트레이트, 제네릭 및 클로저</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>제 6부 — 매크로, 반복자 및 파일 처리</p>\n<p>제 7부 — 스레드 공유 상태 및 채널</p>\n<p>제 8부 — Cargo, 크레이트, 모듈 및 라이브러리</p>\n<p>제 9부 — 명령행 인수, 워크스페이스 및 테스팅</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>제 10부 — 상자 포인터 및 웹 앱</p>\n<p>제 11부 — 빌더와 데이터베이스 상호작용 (이 기사)</p>\n<h1>소개</h1>\n<p>이것은 러스트 학습 시리즈의 열한 번째 섹션입니다. 이번에는 러스트에서 빌더 패턴을 다룰 것입니다. 이 공통된 패턴은 구조체를 안전하고 투명하게 초기화하는 좋은 방법입니다. 다음으로, 우리는 포스트그레스와 SQLX 프레임워크를 사용하여 데이터베이스에서 CRUD 작업을 수행하는 방법을 살펴볼 것입니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h1>준비물</h1>\n<p>이 글의 데이터베이스 부분을 위한 유일한 준비물은 Rust와 Cargo가 설치되어 있고 시스템에 Docker가 설치되어 있는 것입니다. 만약 Docker를 가지고 있지 않지만 로컬 Postgres DB가 이미 설치되어 있거나 다른 서버의 DB에 액세스할 수 있다면 Docker Postgres 설정을 건너뛰고 DB에 연결하기 위한 연결 속성만 수정하면 됩니다.</p>\n<h1>빌더 패턴</h1>\n<p>빌더 패턴은 복잡한 객체의 구성을 해당 표현에서 분리하는 디자인 패턴입니다. 이 패턴을 사용하면 유효성 검사를 수행하고 기본값으로 대체하며 값을 부분적으로 할당한 후에 항목을 생성할 수 있습니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>Rust로 그 구현하는 방법을 살펴볼 거예요. 이것이 우리의 코드입니다.</p>\n<pre><code class=\"hljs language-js\">#[<span class=\"hljs-title function_\">derive</span>(<span class=\"hljs-title class_\">Debug</span>)]\nstruct <span class=\"hljs-title class_\">ChargingSession</span> {\n    <span class=\"hljs-attr\">id</span>: <span class=\"hljs-title class_\">String</span>,\n    <span class=\"hljs-attr\">watts</span>: u32,\n    <span class=\"hljs-attr\">vin</span>: <span class=\"hljs-title class_\">String</span>,\n}\n\nstruct <span class=\"hljs-title class_\">ChargingSessionBuilder</span> {\n    <span class=\"hljs-attr\">id</span>: <span class=\"hljs-title class_\">String</span>,\n    <span class=\"hljs-attr\">watts</span>: <span class=\"hljs-title class_\">Option</span>&#x3C;u32>,\n    <span class=\"hljs-attr\">vin</span>: <span class=\"hljs-title class_\">Option</span>&#x3C;<span class=\"hljs-title class_\">String</span>>,\n}\n\nimpl <span class=\"hljs-title class_\">ChargingSessionBuilder</span> {\n    fn <span class=\"hljs-title function_\">new</span>(<span class=\"hljs-attr\">id</span>: &#x26;str) -> <span class=\"hljs-title class_\">ChargingSessionBuilder</span> {\n        <span class=\"hljs-title class_\">ChargingSessionBuilder</span> {\n            <span class=\"hljs-attr\">id</span>: id.<span class=\"hljs-title function_\">to_string</span>(),\n            <span class=\"hljs-attr\">watts</span>: <span class=\"hljs-title class_\">None</span>,\n            <span class=\"hljs-attr\">vin</span>: <span class=\"hljs-title class_\">None</span>,\n        }\n    }\n\n    fn <span class=\"hljs-title function_\">watts</span>(mut self, <span class=\"hljs-attr\">watts</span>: u32) -> <span class=\"hljs-title class_\">ChargingSessionBuilder</span> {\n        self.<span class=\"hljs-property\">watts</span> = <span class=\"hljs-title class_\">Some</span>(watts);\n        self\n    }\n\n    fn <span class=\"hljs-title function_\">vin</span>(mut self, <span class=\"hljs-attr\">vin</span>: &#x26;str) -> <span class=\"hljs-title class_\">ChargingSessionBuilder</span> {\n        self.<span class=\"hljs-property\">vin</span> = <span class=\"hljs-title class_\">Some</span>(vin.<span class=\"hljs-title function_\">to_string</span>());\n        self\n    }\n\n    fn <span class=\"hljs-title function_\">build</span>(self) -> <span class=\"hljs-title class_\">ChargingSession</span> {\n        <span class=\"hljs-title class_\">ChargingSession</span> {\n            <span class=\"hljs-attr\">id</span>: self.<span class=\"hljs-property\">id</span>,\n            <span class=\"hljs-attr\">watts</span>: self.<span class=\"hljs-property\">watts</span>.<span class=\"hljs-title function_\">unwrap_or_else</span>(|| <span class=\"hljs-number\">0</span>),\n            <span class=\"hljs-attr\">vin</span>: self.<span class=\"hljs-property\">vin</span>.<span class=\"hljs-title function_\">unwrap_or_else</span>(|| <span class=\"hljs-string\">\"Unknown\"</span>.<span class=\"hljs-title function_\">to_string</span>()),\n        }\n    }\n}\n\nfn <span class=\"hljs-title function_\">main</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-comment\">// 이것은 ChargingSession을 생성하는 표준적인 방법입니다.</span>\n    <span class=\"hljs-keyword\">let</span> cs_old_way = <span class=\"hljs-title class_\">ChargingSession</span> {\n        <span class=\"hljs-attr\">id</span>: <span class=\"hljs-title class_\">String</span>::<span class=\"hljs-title function_\">from</span>(<span class=\"hljs-string\">\"11111\"</span>),\n        <span class=\"hljs-attr\">watts</span>: <span class=\"hljs-number\">420</span>,\n        <span class=\"hljs-attr\">vin</span>: <span class=\"hljs-title class_\">String</span>::<span class=\"hljs-title function_\">from</span>(<span class=\"hljs-string\">\"4Y1SL65848Z411439\"</span>),\n    };\n    println!(<span class=\"hljs-string\">\"Regular way to create struct: {:?}\"</span>, cs_old_way);\n\n    <span class=\"hljs-comment\">// 빌더를 사용해서 생성하는 방법입니다.</span>\n    <span class=\"hljs-keyword\">let</span> cs = <span class=\"hljs-title class_\">ChargingSessionBuilder</span>::<span class=\"hljs-title function_\">new</span>(<span class=\"hljs-string\">\"11111\"</span>)\n        .<span class=\"hljs-title function_\">watts</span>(<span class=\"hljs-number\">420</span>)\n        .<span class=\"hljs-title function_\">vin</span>(<span class=\"hljs-string\">\"4Y1SL65848Z411439\"</span>)\n        .<span class=\"hljs-title function_\">build</span>();\n    println!(<span class=\"hljs-string\">\"Builder pattern to create struct: {:?}\"</span>, cs);\n\n    <span class=\"hljs-comment\">// ID만 제공하여 생성하는 예시입니다.</span>\n    <span class=\"hljs-keyword\">let</span> cs_lean = <span class=\"hljs-title class_\">ChargingSessionBuilder</span>::<span class=\"hljs-title function_\">new</span>(<span class=\"hljs-string\">\"11111\"</span>)\n    .<span class=\"hljs-title function_\">build</span>();\n     println!(<span class=\"hljs-string\">\"Builder pattern to create struct (default values): {:?}\"</span>, cs_lean);\n}\n</code></pre>\n<p>이걸 한 번에 이해하기에 많지만, 단계적으로 진행해 봅시다.</p>\n<p>먼저, 충전 세션 정보를 저장하는 구조체를 정의했습니다. 이 시리즈의 이전 예제에서 하나의 필드인 세션용 차량 ID 번호인 vin을 추가했어요.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>그러면 데이터 구조체와 동일한 필드를 가진 빌더를 위한 구조체를 정의합니다.</p>\n<p>빌더는 impl 블록에서 구현되며, id 및 각 추가 필드를 설정하는 함수를 정의하는 새 함수가 있습니다. 그러나 몇 가지 중요한 사항이 있습니다.</p>\n<ul>\n<li>각 함수는 ChargingSessionBuilder 유형을 반환합니다. 기본적으로 self입니다.</li>\n<li>추가 속성 필드에는 mut self를 첫 번째 매개변수로 사용하는 메서드가 있습니다. 이는 이러한 함수 호출의 체이닝을 허용하는 데 중요합니다. 또한 여기에 유효성 검사 논리를 코딩할 수 있습니다.</li>\n<li>build 함수가 모두 통합되는 곳입니다. 존재하는 값들을 할당하고 나면 기본값을 결정하고 대상 구조체를 생성할 수 있습니다.</li>\n</ul>\n<p>이를 통해 빌더 패턴의 우아함과 Rust 내에서의 구현 방법을 살펴보았습니다. 이것이 앱이나 라이브러리에 코드를 구현하는 훌륭한 방법임을 알 수 있기를 바랍니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>다음 섹션인 데이터베이스로 넘어가 봅시다.</p>\n<h1>데이터베이스 — sqlx</h1>\n<p>이 섹션에서는 Rust 프로그램에서 sqlx를 사용하여 데이터베이스 작업을 살펴볼 것입니다. 먼저 일부 설정이 필요합니다.</p>\n<h2>설정</h2>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>새 프로젝트를 시작해봅시다. db_app이라고 이름 짓고, cargo new db_app으로 생성할 수 있어요. 기본 디렉토리에 몇 개의 파일을 생성할 거에요. 첫 번째 파일은 docker-compose.yml이라고 하며 다음 내용이 있어야 합니다. Postgres와 Pgadmin이 노출되는 임의의 포트를 선택했으며, 컴퓨터에 설치된 다른 앱들과 충돌하지 않도록 했어요.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-attr\">version</span>: <span class=\"hljs-string\">'3'</span>\n<span class=\"hljs-attr\">services</span>:\n  <span class=\"hljs-attr\">postgres</span>:\n    <span class=\"hljs-attr\">image</span>: <span class=\"hljs-attr\">postgres</span>:latest\n    <span class=\"hljs-attr\">container_name</span>: postgres\n    <span class=\"hljs-attr\">ports</span>:\n      - <span class=\"hljs-string\">'6500:5432'</span>\n    <span class=\"hljs-attr\">volumes</span>:\n      - <span class=\"hljs-attr\">postgresDB</span>:<span class=\"hljs-regexp\">/data/</span>postgres\n    <span class=\"hljs-attr\">env_file</span>:\n      - ./.<span class=\"hljs-property\">env</span>\n  <span class=\"hljs-attr\">pgAdmin</span>:\n    <span class=\"hljs-attr\">image</span>: dpage/pgadmin4\n    <span class=\"hljs-attr\">container_name</span>: pgAdmin\n    <span class=\"hljs-attr\">env_file</span>:\n      - ./.<span class=\"hljs-property\">env</span>\n    <span class=\"hljs-attr\">ports</span>:\n      - <span class=\"hljs-string\">\"5050:80\"</span>\n<span class=\"hljs-attr\">volumes</span>:\n  <span class=\"hljs-attr\">postgresDB</span>:\n</code></pre>\n<p>.env이라는 파일이 하나 더 필요하며, 다음 내용이 있어야 해요. 이 파일은 docker-compose 파일과 나중에 Rust 애플리케이션에서 모두 사용할 거에요.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable constant_\">POSTGRES_HOST</span>=<span class=\"hljs-number\">127.0</span><span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.1</span>\n<span class=\"hljs-variable constant_\">POSTGRES_PORT</span>=<span class=\"hljs-number\">6500</span>\n<span class=\"hljs-variable constant_\">POSTGRES_USER</span>=admin\n<span class=\"hljs-variable constant_\">POSTGRES_PASSWORD</span>=password123\n<span class=\"hljs-variable constant_\">POSTGRES_DB</span>=charging_session\n\n<span class=\"hljs-variable constant_\">DATABASE_URL</span>=<span class=\"hljs-attr\">postgresql</span>:<span class=\"hljs-comment\">//admin:password123@localhost:6500/charging_session?currentSchema=public</span>\n\n<span class=\"hljs-variable constant_\">PGADMIN_DEFAULT_EMAIL</span>=admin@admin.<span class=\"hljs-property\">com</span>\n<span class=\"hljs-variable constant_\">PGADMIN_DEFAULT_PASSWORD</span>=password123\n</code></pre>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>위의 내용과 함께 데이터베이스 사용자, 비밀번호, 그리고 Pgadmin에 대한 연결 정보를 제공해 드렸습니다.</p>\n<p>이 두 가지 항목을 만들고 위의 내용을 사용하여 Docker Compose를 사용하여 로컬 DB 인스턴스를 시작할 수 있습니다. 처음에는 항상 전경에서 시작하는 것을 좋아합니다. 이미지 다운로드 및 기타 작업을 하기 때문에 여러분의 컴퓨터 및 네트워크 속도에 따라 시간이 소요될 수 있습니다. docker-compose.yml 및 .env 파일이 있는 디렉토리와 동일한 위치에서 다음을 실행하십시오.</p>\n<pre><code class=\"hljs language-js\">docker-compose up\n</code></pre>\n<p>시작된 모든 것을 확인한 후에는 언제든지 -d 스위치를 사용하여 데몬 모드로 시작할 수 있습니다. 완료되면 두 컨테이너가 시작되었는지 확인해 봅시다. 다음과 같이 명령을 실행합니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-js\">docker ps\n</code></pre>\n<p>비슷한 결과가 표시됩니다.</p>\n<img src=\"/assets/img/2024-05-23-LearningRustPart11BuildersandDatabaseInteraction_1.png\">\n<p>만약 두 개의 컨테이너가 표시되지 않는다면, docker-compose를 실행한 터미널에서 에러를 확인해보세요.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>한 번 이들이 실행되면 DB에 연결해 봅시다. Pgadmin을 포트 5050에서 실행하도록 구성했으니 브라우저에서 <a href=\"http://localhost:5050%EC%9D%84\" rel=\"nofollow\" target=\"_blank\">http://localhost:5050을</a> 입력하면 pgadmin의 로그인 화면이 표시됩니다. .env 파일에 구성된 자격 증명(관리자@관리자.com/비밀번호123)을 사용하여 pgadmin에 로그인할 수 있습니다. 그런데 아직 데이터베이스에 연결되지 않았습니다. 이를 위해 다음을 실행해야 합니다.</p>\n<pre><code class=\"hljs language-js\">docker inspect postgres\n</code></pre>\n<p>출력을 확인하여 \"NetworkSettings\" 섹션으로 이동하고 \"IPAddress\" 속성의 값을 복사합니다. 이 값은 DB에 연결하는 데 사용할 호스트(IP)입니다. 제 컴퓨터에서 이 값은 172.23.0.1 이었습니다.</p>\n<p>로그인한 후 \"새 서버 추가\" 버튼을 클릭하고, \"호스트 이름/주소\"로 이전에 복사한 IP 주소를 포함한 필수 자격 증명을 제공하고 \"저장\" 버튼을 클릭하세요.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>서버에 로그인하면 데이터베이스 charging_session을 볼 수 있습니다.</p>\n<p><img src=\"/assets/img/2024-05-23-LearningRustPart11BuildersandDatabaseInteraction_2.png\" alt=\"이미지\"></p>\n<p>잘 했어요. 데이터베이스를 사용할 준비가 되었고 Pgadmin에서 관리할 수 있습니다.</p>\n<p>이제 Rust 앱의 종속성을 구성해 봅시다. 처음에는 모두 필요하지 않지만 결국 필요하게 될 것이므로 지금 추가해 두는 것이 좋습니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>Cargo.toml 파일의 종속성 부분을 다음과 같이 수정하세요.</p>\n<pre><code class=\"hljs language-toml\"><span class=\"hljs-section\">[dependencies]</span>\n<span class=\"hljs-attr\">chrono</span> = { version = <span class=\"hljs-string\">\"0.4.31\"</span>, features = [<span class=\"hljs-string\">\"serde\"</span>] }\n<span class=\"hljs-attr\">dotenv</span> = <span class=\"hljs-string\">\"0.15.0\"</span>\n<span class=\"hljs-attr\">env_logger</span> = <span class=\"hljs-string\">\"0.10.1\"</span>\n<span class=\"hljs-attr\">log</span> = <span class=\"hljs-string\">\"0.4.20\"</span>\n<span class=\"hljs-attr\">serde</span> = { version = <span class=\"hljs-string\">\"1.0.193\"</span>, features = [<span class=\"hljs-string\">\"derive\"</span>] }\n<span class=\"hljs-attr\">serde_json</span> = <span class=\"hljs-string\">\"1.0.108\"</span>\n<span class=\"hljs-attr\">sqlx</span> = { version = <span class=\"hljs-string\">\"0.7.3\"</span>, features = [<span class=\"hljs-string\">\"runtime-tokio-native-tls\"</span>, <span class=\"hljs-string\">\"postgres\"</span>, <span class=\"hljs-string\">\"uuid\"</span>, <span class=\"hljs-string\">\"chrono\"</span>] }\n<span class=\"hljs-attr\">tokio</span> = { version = <span class=\"hljs-string\">\"1.35.0\"</span>, features = [<span class=\"hljs-string\">\"macros\"</span>, <span class=\"hljs-string\">\"rt-multi-thread\"</span>]}\n<span class=\"hljs-attr\">uuid</span> = { version = <span class=\"hljs-string\">\"1.6.1\"</span>, features = [<span class=\"hljs-string\">\"serde\"</span>, <span class=\"hljs-string\">\"v4\"</span>] }\n</code></pre>\n<p>다양한 종속성에 대해 활성화된 기능을 검토하는 데도 시간을 할애하는 것이 좋습니다.</p>\n<p>다음으로, 필요한 테이블을 만들기 위해 sqlx-cli 마이그레이션 기능을 사용할 것입니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>우선 명령 줄에서 다음을 실행하여 CLI를 설치해야 합니다.</p>\n<pre><code class=\"hljs language-js\">cargo install sqlx-cli --no-<span class=\"hljs-keyword\">default</span>-features --features rustls,postgres\n</code></pre>\n<p>그런 다음 마이그레이션 파일을 초기화해야 합니다. 다음과 같이 실행합니다.</p>\n<pre><code class=\"hljs language-js\">sqlx migrate add initial-tables\n</code></pre>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>이 명령어는 우리가 마이그레이션 스크립트를 작성하기 위해 새 파일 migrations/<code>timestamp</code>_initial-tables.sql을 생성합니다.</p>\n<p><img src=\"/assets/img/2024-05-23-LearningRustPart11BuildersandDatabaseInteraction_3.png\" alt=\"이미지\"></p>\n<p>이 파일을 열고 아래 SQL 문을 추가하여 테이블을 생성하세요.</p>\n<p>create table locations (\nid bigserial primary key,\nname varchar(255) unique not null\n);</p>\n<p>create table sessions (\nid bigserial primary key,\nlocation_id bigint not null,\nwatts bigint not null,\nvin varchar(255) not null,\nconstraint fk_location foreign key (location_id) references locations(id) on delete cascade\n);</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>위 예제에서 사용할 두 개의 테이블 정의입니다. 이 시리즈의 충전 세션에 대한 표준 예제를 확장하여, 충전 장치의 위치를 저장할 locations 테이블을 추가했습니다.</p>\n<p>이제 다음을 실행하여 테이블을 생성하세요.</p>\n<pre><code class=\"hljs language-js\">sqlx migrate run\n</code></pre>\n<p>그러면 즉시 20231212235431/migrate initial-tables (타임스탬프 부분은 달라질 수 있음)과 같은 메시지가 표시됩니다. 이제 Pgadmin에 가서 테이블을 확인할 수 있습니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<img src=\"/assets/img/2024-05-23-LearningRustPart11BuildersandDatabaseInteraction_4.png\">\n<p>위에서 보듯이 두 개의 테이블이 생성되었고, 문서 목적을 위해 Pgadmin 내에 ERD 다이어그램도 생성했습니다. 이제 초기 설정과 프로젝트 구성을 완료했습니다.</p>\n<h1>데이터베이스 함수</h1>\n<p>이 섹션에서는 데이터베이스 상호 작용의 다양한 유형과 Rust 구현을 살펴볼 것입니다. 이는 데이터베이스에 연결하는 것으로 시작됩니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>DB에 연결하기</p>\n<p>데이터베이스에 연결하는 방법은 PgPoolOptions connect 함수를 통해 연결을 생성하는 것입니다. 우리의 .env 파일에서 데이터베이스 연결 문자열을 읽고 로깅을 구성하며 성공 또는 오류를 기록하는 코드 전체는 아래와 같습니다.</p>\n<pre><code class=\"hljs language-js\">use <span class=\"hljs-attr\">sqlx</span>::{<span class=\"hljs-attr\">postgres</span>::<span class=\"hljs-title class_\">PgPoolOptions</span>, <span class=\"hljs-title class_\">Pool</span>, <span class=\"hljs-title class_\">Postgres</span>};\nuse <span class=\"hljs-attr\">dotenv</span>::dotenv;\nuse <span class=\"hljs-attr\">log</span>::{info, error};\n\n#[<span class=\"hljs-attr\">tokio</span>::main]\n<span class=\"hljs-keyword\">async</span> fn <span class=\"hljs-title function_\">main</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">if</span> <span class=\"hljs-attr\">std</span>::<span class=\"hljs-attr\">env</span>::<span class=\"hljs-title function_\">var_os</span>(<span class=\"hljs-string\">\"RUST_LOG\"</span>).<span class=\"hljs-title function_\">is_none</span>(<span class=\"hljs-params\"></span>) {\n        <span class=\"hljs-attr\">std</span>::<span class=\"hljs-attr\">env</span>::<span class=\"hljs-title function_\">set_var</span>(<span class=\"hljs-string\">\"RUST_LOG\"</span>, <span class=\"hljs-string\">\"info\"</span>);\n    }\n    <span class=\"hljs-title function_\">dotenv</span>().<span class=\"hljs-title function_\">ok</span>();\n    <span class=\"hljs-attr\">env_logger</span>::<span class=\"hljs-title function_\">init</span>();\n\n    <span class=\"hljs-keyword\">let</span> database_url = <span class=\"hljs-attr\">std</span>::<span class=\"hljs-attr\">env</span>::<span class=\"hljs-title function_\">var</span>(<span class=\"hljs-string\">\"DATABASE_URL\"</span>).<span class=\"hljs-title function_\">expect</span>(<span class=\"hljs-string\">\"DATABASE_URL must be set\"</span>);\n    <span class=\"hljs-keyword\">let</span> pool = match <span class=\"hljs-title class_\">PgPoolOptions</span>::<span class=\"hljs-title function_\">new</span>()\n        .<span class=\"hljs-title function_\">max_connections</span>(<span class=\"hljs-number\">10</span>)\n        .<span class=\"hljs-title function_\">connect</span>(&#x26;database_url)\n        .<span class=\"hljs-property\">await</span>\n    {\n        <span class=\"hljs-title class_\">Ok</span>(pool) => {\n            info!(<span class=\"hljs-string\">\"✅ 데이터베이스에 연결되었습니다!\"</span>);\n            pool\n        }\n        <span class=\"hljs-title class_\">Err</span>(err) => {\n            error!(<span class=\"hljs-string\">\"🔥 데이터베이스 연결에 실패했습니다: {:?}\"</span>, err);\n            <span class=\"hljs-attr\">std</span>::<span class=\"hljs-attr\">process</span>::<span class=\"hljs-title function_\">exit</span>(<span class=\"hljs-number\">1</span>);\n        }\n    };\n}\n</code></pre>\n<p>시작 부분의 #[tokio::main] 매크로를 주목해주세요. 이는 async fn main()을 동기 fn main()로 변환하여 런타임 인스턴스를 초기화하고 async main 함수를 실행하게 합니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>위 코드를 실행하면 출력 로깅에서 다음 메시지가 표시됩니다.</p>\n<p>[2023-12-13T00:16:42Z INFO db_app] ✅ 데이터베이스에 연결되었습니다!</p>\n<p>우리는 데이터베이스에 연결할 수 있습니다. .env 파일에서 구성한 모든 연결 정보를 기억해 주세요. 이 정보는 docker-compose, sqlx-cli, 그리고 우리의 어플리케이션에서 공유되었습니다.</p>\n<h2>Inserts</h2>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>이제 연결 풀이 준비되었으니, 우리가 살펴볼 첫 번째 데이터베이스 로직은 삽입입니다. sqlx를 사용하여 삽입하는 방법은 다음과 같습니다.</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">insert_result</span> = sqlx::query_as!(\n    Locations,\n    <span class=\"hljs-string\">\"INSERT INTO locations (id,name) VALUES (1, 'Location A') RETURNING *\"</span>\n)\n.<span class=\"hljs-title function_ invoke__\">fetch_one</span>(&#x26;pool)\n.<span class=\"hljs-keyword\">await</span>;\n\n<span class=\"hljs-keyword\">match</span> insert_result {\n    <span class=\"hljs-title function_ invoke__\">Ok</span>(location) => {\n        info!(<span class=\"hljs-string\">\"✓Inserted: {:?}\"</span>, location);\n    }\n    <span class=\"hljs-title function_ invoke__\">Err</span>(e) => {\n        error!(<span class=\"hljs-string\">\"Error Insert: {}\"</span>, e.<span class=\"hljs-title function_ invoke__\">to_string</span>())\n    }\n}\n</code></pre>\n<p>이 코드는 하나의 레코드를 삽입할 것입니다. 물론 매개변수를 사용할 수도 있으며, 이는 업데이트를 살펴볼 때 살펴볼 것입니다.</p>\n<h2>질의하기</h2>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>다음으로, 데이터베이스를 조회하는 방법을 살펴보겠습니다.</p>\n<pre><code class=\"hljs language-js\">    <span class=\"hljs-keyword\">let</span> query_result = <span class=\"hljs-attr\">sqlx</span>::query_as!(<span class=\"hljs-title class_\">Locations</span>, <span class=\"hljs-string\">\"SELECT * FROM Locations\"</span>)\n        .<span class=\"hljs-title function_\">fetch_all</span>(&#x26;pool)\n        .<span class=\"hljs-property\">await</span>;\n    <span class=\"hljs-keyword\">if</span> query_result.<span class=\"hljs-title function_\">is_err</span>(<span class=\"hljs-params\"></span>) {\n        <span class=\"hljs-keyword\">let</span> message = <span class=\"hljs-string\">\"모든 위치를 가져오는 동안 문제가 발생했습니다.\"</span>;\n        error!(<span class=\"hljs-string\">\"{}{}\"</span>, message, query_result.<span class=\"hljs-title function_\">err</span>().<span class=\"hljs-title function_\">unwrap</span>());\n    } <span class=\"hljs-keyword\">else</span> {\n        info!(<span class=\"hljs-string\">\"😎 위치에 대한 쿼리 결과 {:?}\"</span>, query_result.<span class=\"hljs-title function_\">unwrap</span>());\n    }\n</code></pre>\n<p>이것은 성공적으로 작동했다면 unwrap을 통해 결과에 접근할 수 있는 결과를 반환합니다. 쿼리 내의 이슈가 발생했다면 해당 에러에 접근할 수도 있습니다.</p>\n<h2>업데이트</h2>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>다음 작업은 데이터베이스를 업데이트하는 것입니다. 이는 이전에 삽입한 것과 비슷할 것입니다.</p>\n<pre><code class=\"hljs language-js\">    <span class=\"hljs-keyword\">let</span> update_result = <span class=\"hljs-attr\">sqlx</span>::query_as!(\n        <span class=\"hljs-title class_\">Sessions</span>,\n        <span class=\"hljs-string\">\"UPDATE sessions SET watts = 415 WHERE id = $1 RETURNING *\"</span>,\n        1i64,\n    )\n    .<span class=\"hljs-title function_\">fetch_one</span>(&#x26;pool)\n    .<span class=\"hljs-property\">await</span>;\n\n    match update_result {\n        <span class=\"hljs-title class_\">Ok</span>(session) => {\n            info!(<span class=\"hljs-string\">\"✓Update: {:?}\"</span>, session);\n        }\n        <span class=\"hljs-title class_\">Err</span>(e) => {\n            error!(<span class=\"hljs-string\">\"Error Update: {}\"</span>, e.<span class=\"hljs-title function_\">to_string</span>())\n        }\n    }\n</code></pre>\n<p>이 예제에서 주목할 점은 $1이라는 매개변수 자리 표시자를 사용하는 준비된 문(statement)를 사용하고 있다는 것입니다. 그런 다음 SQL 문자열 뒤에 매개변수를 전달합니다.</p>\n<h2>Deletes</h2>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>마지막으로, 데이터베이스에서 레코드를 삭제하는 CRUD 작업을 완료합니다. 우리의 목적은 데이터베이스를 정리하는 데 사용할 것이며, 이렇게 하면 언제든지 응용 프로그램을 실행할 수 있습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">let</span> rows_deleted = <span class=\"hljs-attr\">sqlx</span>::query!(<span class=\"hljs-string\">\"DELETE from sessions\"</span>)\n    .<span class=\"hljs-title function_\">execute</span>(&#x26;pool)\n    .<span class=\"hljs-property\">await</span>\n    .<span class=\"hljs-title function_\">unwrap</span>()\n    .<span class=\"hljs-title function_\">rows_affected</span>();\n\ninfo!(<span class=\"hljs-string\">\"✕ 세션 테이블에서 {}개의 행 삭제됨\"</span>, rows_deleted);\n</code></pre>\n<p>여기서는 연산에서처럼 sqlx::query 대신 sqlx::query_as를 사용합니다. 또한 언랩 이후 .rows_affected를 추가하여 삭제된 행 수를 얻습니다.</p>\n<h2>트랜잭션</h2>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-rust\">   <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">tx</span> = pool.<span class=\"hljs-title function_ invoke__\">begin</span>().<span class=\"hljs-keyword\">await</span>.<span class=\"hljs-title function_ invoke__\">expect</span>(<span class=\"hljs-string\">\"트랜잭션을 시작할 수 없습니다\"</span>);\n\n   <span class=\"hljs-comment\">// 데이터베이스 작업 수행(데이터 삽입 또는 변경)</span>\n\n   tx.<span class=\"hljs-title function_ invoke__\">commit</span>().<span class=\"hljs-keyword\">await</span>.<span class=\"hljs-title function_ invoke__\">expect</span>(<span class=\"hljs-string\">\"트랜잭션을 커밋할 수 없습니다\"</span>);\n</code></pre>\n<p>커밋을 호출하지 않으면 트랜잭션이 범위를 벗어나면 자동으로 롤백됩니다.</p>\n<h2>완전한 응용 프로그램</h2>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>위의 코드는 우리가 이전에 논의한 모든 다양한 기능이 하나의 애플리케이션에 모두 포함된 완전한 애플리케이션입니다.</p>\n<pre><code class=\"hljs language-js\">use <span class=\"hljs-attr\">dotenv</span>::dotenv;\nuse <span class=\"hljs-attr\">log</span>::{error, info};\nuse <span class=\"hljs-attr\">sqlx</span>::{<span class=\"hljs-attr\">postgres</span>::<span class=\"hljs-title class_\">PgPoolOptions</span>, <span class=\"hljs-title class_\">Pool</span>, <span class=\"hljs-title class_\">Postgres</span>};\n\n#[<span class=\"hljs-title function_\">derive</span>(<span class=\"hljs-title class_\">Debug</span>)]\nstruct <span class=\"hljs-title class_\">Locations</span> {\n    <span class=\"hljs-attr\">id</span>: i64,\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-title class_\">String</span>,\n}\n\n#[<span class=\"hljs-title function_\">derive</span>(<span class=\"hljs-title class_\">Debug</span>)]\nstruct <span class=\"hljs-title class_\">Sessions</span> {\n    <span class=\"hljs-attr\">id</span>: i64,\n    <span class=\"hljs-attr\">location_id</span>: i64,\n    <span class=\"hljs-attr\">watts</span>: i64,\n    <span class=\"hljs-attr\">vin</span>: <span class=\"hljs-title class_\">String</span>,\n}\n<span class=\"hljs-keyword\">async</span> fn <span class=\"hljs-title function_\">insert_into_locations</span>(<span class=\"hljs-params\">pool: Pool&#x3C;Postgres></span>) {\n    <span class=\"hljs-keyword\">let</span> tx = pool.<span class=\"hljs-title function_\">begin</span>().<span class=\"hljs-property\">await</span>.<span class=\"hljs-title function_\">expect</span>(<span class=\"hljs-string\">\"Unable to begin transaction\"</span>);\n\n    <span class=\"hljs-keyword\">let</span> insert_result = <span class=\"hljs-attr\">sqlx</span>::query_as!(\n        <span class=\"hljs-title class_\">Locations</span>,\n        <span class=\"hljs-string\">\"INSERT INTO locations (id,name) VALUES (1, 'Location A') RETURNING *\"</span>\n    )\n    .<span class=\"hljs-title function_\">fetch_one</span>(&#x26;pool)\n    .<span class=\"hljs-property\">await</span>;\n\n    match insert_result {\n        <span class=\"hljs-title class_\">Ok</span>(location) => {\n            info!(<span class=\"hljs-string\">\"✓Inserted: {:?}\"</span>, location);\n        }\n        <span class=\"hljs-title class_\">Err</span>(e) => {\n            error!(<span class=\"hljs-string\">\"Error Insert: {}\"</span>, e.<span class=\"hljs-title function_\">to_string</span>())\n        }\n    }\n    <span class=\"hljs-keyword\">let</span> insert_result = <span class=\"hljs-attr\">sqlx</span>::query_as!(\n        <span class=\"hljs-title class_\">Locations</span>,\n        <span class=\"hljs-string\">\"INSERT INTO locations (id,name) VALUES (2, 'Location B') RETURNING *\"</span>\n    )\n    .<span class=\"hljs-title function_\">fetch_one</span>(&#x26;pool)\n    .<span class=\"hljs-property\">await</span>;\n\n    match insert_result {\n        <span class=\"hljs-title class_\">Ok</span>(location) => {\n            info!(<span class=\"hljs-string\">\"✓Inserted: {:?}\"</span>, location);\n        }\n        <span class=\"hljs-title class_\">Err</span>(e) => {\n            error!(<span class=\"hljs-string\">\"Error Insert: {}\"</span>, e.<span class=\"hljs-title function_\">to_string</span>())\n        }\n    }\n\n    tx.<span class=\"hljs-title function_\">commit</span>().<span class=\"hljs-property\">await</span>.<span class=\"hljs-title function_\">expect</span>(<span class=\"hljs-string\">\"Unable to commit the transaction\"</span>);\n}\n\n<span class=\"hljs-keyword\">async</span> fn <span class=\"hljs-title function_\">insert_into_sessions</span>(<span class=\"hljs-params\">pool: Pool&#x3C;Postgres></span>) {\n    <span class=\"hljs-keyword\">let</span> tx = pool.<span class=\"hljs-title function_\">begin</span>().<span class=\"hljs-property\">await</span>.<span class=\"hljs-title function_\">expect</span>(<span class=\"hljs-string\">\"Unable to begin transaction\"</span>);\n\n    <span class=\"hljs-keyword\">let</span> insert_result = <span class=\"hljs-attr\">sqlx</span>::query_as!(\n        <span class=\"hljs-title class_\">Sessions</span>,\n        <span class=\"hljs-string\">\"INSERT INTO sessions (id,location_id, watts, vin) VALUES (1, 1, 420, '2FMZA52286BA02033') RETURNING *\"</span>\n    )\n    .<span class=\"hljs-title function_\">fetch_one</span>(&#x26;pool)\n    .<span class=\"hljs-property\">await</span>;\n\n    match insert_result {\n        <span class=\"hljs-title class_\">Ok</span>(session) => {\n            info!(<span class=\"hljs-string\">\"✓Inserted: {:?}\"</span>, session);\n        }\n        <span class=\"hljs-title class_\">Err</span>(e) => {\n            error!(<span class=\"hljs-string\">\"Error Insert: {}\"</span>, e.<span class=\"hljs-title function_\">to_string</span>())\n        }\n    }\n    <span class=\"hljs-keyword\">let</span> insert_result = <span class=\"hljs-attr\">sqlx</span>::query_as!(\n        <span class=\"hljs-title class_\">Sessions</span>,\n        <span class=\"hljs-string\">\"INSERT INTO sessions (id,location_id, watts, vin) VALUES (2, 2, 393, '1GMYA52286BA04055') RETURNING *\"</span>\n)\n    .<span class=\"hljs-title function_\">fetch_one</span>(&#x26;pool)\n    .<span class=\"hljs-property\">await</span>;\n\n    match insert_result {\n        <span class=\"hljs-title class_\">Ok</span>(session) => {\n            info!(<span class=\"hljs-string\">\"✓Inserted: {:?}\"</span>, session);\n        }\n        <span class=\"hljs-title class_\">Err</span>(e) => {\n            error!(<span class=\"hljs-string\">\"Error Insert: {}\"</span>, e.<span class=\"hljs-title function_\">to_string</span>())\n        }\n    }\n\n    tx.<span class=\"hljs-title function_\">commit</span>().<span class=\"hljs-property\">await</span>.<span class=\"hljs-title function_\">expect</span>(<span class=\"hljs-string\">\"Unable to commit the transaction\"</span>);\n}\n\n<span class=\"hljs-keyword\">async</span> fn <span class=\"hljs-title function_\">update_sessions</span>(<span class=\"hljs-params\">pool: Pool&#x3C;Postgres></span>) {\n    <span class=\"hljs-keyword\">let</span> tx = pool.<span class=\"hljs-title function_\">begin</span>().<span class=\"hljs-property\">await</span>.<span class=\"hljs-title function_\">expect</span>(<span class=\"hljs-string\">\"Unable to begin transaction\"</span>);\n\n    <span class=\"hljs-keyword\">let</span> update_result = <span class=\"hljs-attr\">sqlx</span>::query_as!(\n        <span class=\"hljs-title class_\">Sessions</span>,\n        <span class=\"hljs-string\">\"UPDATE sessions SET watts = 415 WHERE id = $1 RETURNING *\"</span>,\n        1i64,\n    )\n    .<span class=\"hljs-title function_\">fetch_one</span>(&#x26;pool)\n    .<span class=\"hljs-property\">await</span>;\n\n    match update_result {\n        <span class=\"hljs-title class_\">Ok</span>(session) => {\n            info!(<span class=\"hljs-string\">\"✓Update: {:?}\"</span>, session);\n        }\n        <span class=\"hljs-title class_\">Err</span>(e) => {\n            error!(<span class=\"hljs-string\">\"Error Update: {}\"</span>, e.<span class=\"hljs-title function_\">to_string</span>())\n        }\n    }\n\n    tx.<span class=\"hljs-title function_\">commit</span>().<span class=\"hljs-property\">await</span>.<span class=\"hljs-title function_\">expect</span>(<span class=\"hljs-string\">\"Unable to commit the transaction\"</span>);\n}\n\n<span class=\"hljs-keyword\">async</span> fn <span class=\"hljs-title function_\">clean_db</span>(<span class=\"hljs-params\">pool: Pool&#x3C;Postgres></span>) {\n    <span class=\"hljs-keyword\">let</span> rows_deleted = <span class=\"hljs-attr\">sqlx</span>::query!(<span class=\"hljs-string\">\"DELETE from sessions\"</span>)\n        .<span class=\"hljs-title function_\">execute</span>(&#x26;pool)\n        .<span class=\"hljs-property\">await</span>\n        .<span class=\"hljs-title function_\">unwrap</span>()\n        .<span class=\"hljs-title function_\">rows_affected</span>();\n\n    info!(<span class=\"hljs-string\">\"✕Deleted {} rows from sessions table\"</span>, rows_deleted);\n\n    <span class=\"hljs-keyword\">let</span> rows_deleted = <span class=\"hljs-attr\">sqlx</span>::query!(<span class=\"hljs-string\">\"DELETE from locations\"</span>)\n        .<span class=\"hljs-title function_\">execute</span>(&#x26;pool)\n        .<span class=\"hljs-property\">await</span>\n        .<span class=\"hljs-title function_\">unwrap</span>()\n        .<span class=\"hljs-title function_\">rows_affected</span>();\n    info!(<span class=\"hljs-string\">\"✕Deleted {} rows from locations table\"</span>, rows_deleted);\n}\n\n<span class=\"hljs-keyword\">async</span> fn <span class=\"hljs-title function_\">query_locations</span>(<span class=\"hljs-params\">pool: Pool&#x3C;Postgres></span>) {\n    <span class=\"hljs-keyword\">let</span> query_result = <span class=\"hljs-attr\">sqlx</span>::query_as!(<span class=\"hljs-title class_\">Locations</span>, <span class=\"hljs-string\">\"SELECT * FROM Locations\"</span>)\n        .<span class=\"hljs-title function_\">fetch_all</span>(&#x26;pool)\n        .<span class=\"hljs-property\">await</span>;\n    <span class=\"hljs-keyword\">if</span> query_result.<span class=\"hljs-title function_\">is_err</span>(<span class=\"hljs-params\"></span>) {\n        <span class=\"hljs-keyword\">let</span> message = <span class=\"hljs-string\">\"Something bad happened while fetching all locations\"</span>;\n        error!(<span class=\"hljs-string\">\"{}\"</span>, message);\n    } <span class=\"hljs-keyword\">else</span> {\n        info!(<span class=\"hljs-string\">\"😎Query Result For Locations {:?}\"</span>, query_result);\n    }\n}\n\n<span class=\"hljs-keyword\">async</span> fn <span class=\"hljs-title function_\">query_sessions</span>(<span class=\"hljs-params\">pool: Pool&#x3C;Postgres></span>) {\n    <span class=\"hljs-keyword\">let</span> query_result = <span class=\"hljs-attr\">sqlx</span>::query_as!(<span class=\"hljs-title class_\">Sessions</span>, <span class=\"hljs-string\">\"SELECT * FROM Sessions\"</span>)\n        .<span class=\"hljs-title function_\">fetch_all</span>(&#x26;pool)\n        .<span class=\"hljs-property\">await</span>;\n    <span class=\"hljs-keyword\">if</span> query_result.<span class=\"hljs-title function_\">is_err</span>(<span class=\"hljs-params\"></span>) {\n        <span class=\"hljs-keyword\">let</span> message = <span class=\"hljs-string\">\"Something bad happened while fetching all sessions\"</span>;\n        error!(<span class=\"hljs-string\">\"{}\"</span>, message);\n    } <span class=\"hljs-keyword\">else</span> {\n        info!(<span class=\"hljs-string\">\"😎Query Result for Sessions {:?}\"</span>, query_result);\n    }\n}\n\n#[<span class=\"hljs-attr\">tokio</span>::main]\n<span class=\"hljs-keyword\">async</span> fn <span class=\"hljs-title function_\">main</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">if</span> <span class=\"hljs-attr\">std</span>::<span class=\"hljs-attr\">env</span>::<span class=\"hljs-title function_\">var_os</span>(<span class=\"hljs-string\">\"RUST_LOG\"</span>).<span class=\"hljs-title function_\">is_none</span>(<span class=\"hljs-params\"></span>) {\n        <span class=\"hljs-attr\">std</span>::<span class=\"hljs-attr\">env</span>::<span class=\"hljs-title function_\">set_var</span>(<span class=\"hljs-string\">\"RUST_LOG\"</span>, <span class=\"hljs-string\">\"info\"</span>);\n    }\n    <span class=\"hljs-title function_\">dotenv</span>().<span class=\"hljs-title function_\">ok</span>();\n    <span class=\"hljs-attr\">env_logger</span>::<span class=\"hljs-title function_\">init</span>();\n\n    <span class=\"hljs-keyword\">let</span> database_url = <span class=\"hljs-attr\">std</span>::<span class=\"hljs-attr\">env</span>::<span class=\"hljs-title function_\">var</span>(<span class=\"hljs-string\">\"DATABASE_URL\"</span>).<span class=\"hljs-title function_\">expect</span>(<span class=\"hljs-string\">\"DATABASE_URL must be set\"</span>);\n    <span class=\"hljs-keyword\">let</span> pool = match <span class=\"hljs-title class_\">PgPoolOptions</span>::<span class=\"hljs-title function_\">new</span>()\n        .<span class=\"hljs-title function_\">max_connections</span>(<span class=\"hljs-number\">10</span>)\n        .<span class=\"hljs-title function_\">connect</span>(&#x26;database_url)\n        .<span class=\"hljs-property\">await</span>\n    {\n        <span class=\"hljs-title class_\">Ok</span>(pool) => {\n            info!(<span class=\"hljs-string\">\"✅Connection to the database is successful!\"</span>);\n            pool\n        }\n        <span class=\"hljs-title class_\">Err</span>(err) => {\n            error!(<span class=\"hljs-string\">\"🔥 Failed to connect to the database: {:?}\"</span>, err);\n            <span class=\"hljs-attr\">std</span>::<span class=\"hljs-attr\">process</span>::<span class=\"hljs-title function_\">exit</span>(<span class=\"hljs-number\">1</span>);\n        }\n    };\n    <span class=\"hljs-title function_\">clean_db</span>(pool.<span class=\"hljs-title function_\">clone</span>()).<span class=\"hljs-property\">await</span>;\n\n    <span class=\"hljs-title function_\">insert_into_locations</span>(pool.<span class=\"hljs-title function_\">clone</span>()).<span class=\"hljs-property\">await</span>;\n    <span class=\"hljs-title function_\">query_locations</span>(pool.<span class=\"hljs-title function_\">clone</span>()).<span class=\"hljs-property\">await</span>;\n\n    <span class=\"hljs-title function_\">insert_into_sessions</span>(pool.<span class=\"hljs-title function_\">clone</span>()).<span class=\"hljs-property\">await</span>;\n    <span class=\"hljs-title function_\">query_sessions</span>(pool.<span class=\"hljs-title function_\">clone</span>()).<span class=\"hljs-property\">await</span>;\n\n    <span class=\"hljs-title function_\">update_sessions</span>(pool.<span class=\"hljs-title function_\">clone</span>()).<span class=\"hljs-property\">await</span>;\n    <span class=\"hljs-title function_\">query_sessions</span>(pool.<span class=\"hljs-title function_\">clone</span>()).<span class=\"hljs-property\">await</span>;\n}\n</code></pre>\n<p>위 애플리케이션을 실행한 결과는 다음과 같습니다.</p>\n<img src=\"/assets/img/2024-05-23-LearningRustPart11BuildersandDatabaseInteraction_5.png\">\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>위와 같이 데이터베이스 상호작용 토론을 마쳤습니다. sqlx를 사용하여 데이터베이스 작업을 수행하는 방법에 대해 좋은 개요를 제공했을 겁니다.</p>\n<h1>요약</h1>\n<p>저희 러스트 학습 시리즈의 이 부분을 즐기셨기를 바랍니다. 시리즈 이번 섹션에서는 먼저 러스트에서 객체 생성에 대한 매우 유용한 패턴인 빌더 패턴을 살펴보았습니다. 이는 다른 언어에서 익숙할 수 있지만, 러스트에서 어떻게 구현하는지 살펴보았습니다.</p>\n<p>다음으로, 우리는 Rust를 사용하여 데이터베이스인 특히 Postgres와 상호작용하는 방법을 검토했습니다. 우리는 마이그레이션을 실행하고 데이터베이스에 연결하는 방법을 보았으며, 그 후 DB에 대해 여러 가지 CRUD 작업을 수행하는 방법을 살펴보았습니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>러스트 학습 여정에 함께해줘서 고마워요.</p>\n<p>좋은 여행 되세요!</p>\n</body>\n</html>\n"},"__N_SSG":true}