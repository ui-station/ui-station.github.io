{"pageProps":{"post":{"title":"React 19가 온다, 어떤 최신 기능들이 추가됐을까","description":"","date":"2024-07-02 22:04","slug":"2024-07-02-React19isComingWhatsNew","content":"\n\n<img src=\"/assets/img/2024-07-02-React19isComingWhatsNew_0.png\" />\n\n리액트가 마지막으로 릴리즈된 버전은 2022년 6월 14일에 18.2.0 버전으로 나왔어요. 프론트엔드 개발 분야에서 이렇게 인기 있는 기술의 업데이트 속도가 느린 것은 정말 드물죠. 이로 인해 커뮤니티의 일부 중요 인물들 사이에서 불만이 커졌는데, 제 이전 게시물에서 언급했었어요. 관심 있는 분들은 이 글을 클릭해서 확인할 수 있어요: 리액트 커뮤니티 내의 의견 차이.\n\n커뮤니티에서 불만이 계속해서 증가하자, 새로운 리액트 버전의 소식이 드디어 전해졌어요.\n\n리액트 팀은 이제까지 새로운 공식 버전을 출시하지 않은 불만에 대해 응답했어요: 이전에 캐너리 버전에서 출시된 기능들은 서로 상호작용이 필요했기 때문에, 이를 안정 버전에 점진적으로 출시하기 전에 리액트 팀이 함께 작동할 수 있는지 확인하기 위해 많은 시간을 투자해야 했어요.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n사실, 거의 두 년 동안 공식 버전이 출시되지 않았지만 Canary 버전에서 몇 가지 중요한 업데이트가 있었습니다. use, useOptimistic hook, use client, use server 디렉티브와 같은 업데이트는 리액트 에코시스템을 객관적으로 풍부하게 만든 바 있습니다. 특히 Next.js와 Remix와 같은 풀 스택 프레임워크의 빠른 개발을 촉진했습니다.\n\n리액트 팀은 다음 버전이 19.0.0일 것으로 확인했습니다.\n\n# v19에서 예상되는 새로운 기능 예측\n\n이제 리액트 팀의 최신 소식을 기반으로 공식적으로 버전 19에서 출시될 수 있는 새로운 기능을 미리 살펴보겠습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 자동 메모이제이션\n\nReact Conf 2021에서 황 쉔이 소개한 React Forget을 기억하시나요?\n\n![이미지](/assets/img/2024-07-02-React19isComingWhatsNew_1.png)\n\n이제 이것이 여기 있습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n인스타그램의 제품 환경에서 이미 적용된 컴파일러입니다. React 팀은 이를 Meta의 더 많은 플랫폼에 적용할 계획이며, 향후 오픈소스로 공개할 예정입니다.\n\n새로운 컴파일러를 사용하기 전에는 useMemo, useCallback 및 memo를 사용하여 수동으로 상태를 캐시하여 불필요한 다시 렌더링을 줄였습니다. 이 구현은 가능하지만, React 팀은 이것이 그들이 상상한 이상적인 방식은 아니라고 믿습니다. React가 상태 변경 시 필요한 부분만 자동으로 다시 렌더링할 수 있는 방법을 찾고 있었습니다. 몇 년의 노력 끝에 새로운 컴파일러가 성공적으로 출시되었습니다.\n\n새로운 React 컴파일러는 즉시 사용할 수 있는 기능으로, 개발자들에게 또 다른 패러다임 전환을 제공할 것입니다. 이것은 v19의 가장 기대되는 기능입니다.\n\n재미있는 점은 새로운 컴파일러를 소개할 때 React Forget을 언급하지 않은 React 팀이었는데, 이로 인해 커뮤니티에서 우스꽝스러운 댓글이 나왔습니다: 그들은 React Forget을 잊고 Forget 섹션에서 Forget을 언급하는 것을 잊었습니다.🤣\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 작업\n\nReact Actions은 React 팀이 클라이언트에서 서버로 데이터를 전송하는 솔루션을 탐색하면서 개발한 것입니다. 이 기능을 사용하면 개발자가 DOM 요소 (예: ``form/``)에 함수를 전달할 수 있습니다:\n\n```js\n<form action={search}>\n   <input name=\"query\" />\n   <button type=\"submit\">Search</button>\n</form>\n```\n\naction 함수는 동기적 또는 비동기적일 수 있습니다. 작업을 사용할 때 React는 개발자를 위해 데이터 제출의 라이프사이클을 관리합니다. useFormStatus 및 useFormState 훅을 사용하여 현재 폼 작업의 상태와 응답에 액세스할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n클라이언트와 서버 간 상호 작용 시나리오에서 사용할 수 있는 액션은 데이터베이스 변경(데이터 추가, 삭제, 업데이트) 및 양식(예: 로그인 양식, 등록 양식) 구현과 같은 경우에 사용됩니다.\n\nuseFormStatus 및 useFormState와 결합하는 것 외에도, 액션은 useOptimistic 및 use server와 함께 사용될 수 있습니다. 이에 대해 자세히 확장하면 길고 복잡한 토론이 될 수 있지만, 곧 발표될 기사를 통해 액션의 상세 사용법을 소개할 예정이니 기대해 주세요.\n\n## 지시문: use client 및 use server\n\nuse client와 use server 지시문은 오랜 기간 동안 Canary 버전에서 사용 가능했으며, 이제 v19에서 안정 버전과 함께 사용할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이전에 Next.js가 이 두 가지 지시문을 제품으로 사용하는 것에 대한 커뮤니티에서의 빈번한 불만이 있었으며, Next.js는 React 생태계를 손상시키고 있는 것으로 비난되었고, React 팀은 Next.js가 불안정한 기능을 시간 초과로 사용할 수 있도록 허용함에 대해 비판을 받았습니다. 그러나 이 우려는 대부분 불필요합니다. 이 두 가지 지시문은 Next.js나 Remix와 같은 풀스택 프레임워크를 위해 설계되어 있으며, React를 사용하여 응용 프로그램을 개발하는 보통 개발자들은 단기적으로는 거의 필요하지 않을 것입니다.\n\nReact를 사용하는 경우 풀스택 프레임워크가 아니라면, 이 두 가지 지시문의 목적을 이해하는 것만으로 충분합니다. use client와 use server은 프론트엔드와 서버 사이드 환경 사이의 \"분할 지점\"을 표시합니다. use client는 패키지 도구에 `script` 태그를 생성하도록 지시하고, use server는 패키지 도구에 POST 엔드포인트를 생성하도록 지시합니다. 이러한 지시문을 사용하면 개발자는 동일한 파일에서 클라이언트 사이드 및 서버 사이드 코드를 작성할 수 있습니다.\n\n## 낙관적 업데이트를 위한 useOptimistic\n\nuseOptimistic는 v19에서 안정적으로 표시될 것으로 예상되는 새로운 훅입니다. useOptimistic를 사용하면 비동기 작업(예: 네트워크 요청) 중에 UI를 낙관적으로 업데이트할 수 있습니다. 현재 상태와 업데이트 함수를 매개변수로 받아들이며, 비동기 작업 중에 상태의 복사본을 반환합니다. 현재 상태와 작업의 입력을 받아 작업을 기다리는 동안 사용할 낙관적 상태를 반환하는 함수를 제공해야 합니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여기에 그 내용이 정의되어 있습니다:\n\n```js\nconst [optimisticState, addOptimistic] = useOptimistic(state, updateFn);\n\n// 또는\nconst [optimisticState, addOptimistic] = useOptimistic(\n  state,\n  // updateFn\n  (currentState, optimisticValue) => {\n    // 낙관적인 값으로 새로운 상태를 병합 및 반환합니다.\n  }\n);\n```\n\n매개변수\n\nstate: 초기 상태 값 및 작업이 진행 중이 아닐 때 반환되는 값입니다.\n\nupdateFn(currentState, optimisticValue): addOptimistic에 전달된 현재 상태 및 낙관적인 값을 사용하여 낙관적인 상태 결과를 반환하는 함수입니다. updateFn은 currentState 및 optimisticValue 두 매개변수를 받습니다. 반환 값은 currentState와 optimisticValue의 병합된 값이 됩니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n반환 값\n\noptimisticState: 생성된 낙관적인 상태입니다. 작업이 진행 중일 때는 updateFn이 반환하는 값과 동일하며, 작업이 진행 중이 아닌 경우에는 상태와 동일합니다.\naddOptimistic: 낙관적 업데이트 중에 호출되는 디스패치 함수입니다. 낙관적 값 (어떤 유형이든)을 하나의 매개변수로 받아와 상태와 낙관적 값과 함께 updateFn을 호출합니다.\n\n더 자세한 예제:\n\n```js\nimport { useOptimistic } from 'react';\nfunction AppContainer() {\n  const [state, setState] = useState(initialState); // 초기 상태가 있다고 가정합니다\n  const [optimisticState, addOptimistic] = useOptimistic(\n    state,\n    // updateFn\n    (currentState, optimisticValue) => {\n      // 병합하고 반환: 새로운 상태, 낙관적인 값\n      return { ...currentState, ...optimisticValue };\n    }\n  );\n  // 양식 제출과 같은 비동기 작업이 있는 경우를 가정합니다\n  function handleSubmit(data) {\n    // 실제 데이터 제출 전에 낙관적 업데이트 사용\n    addOptimistic({ data: '낙관적인 데이터' });\n    // 그런 다음 비동기 작업 수행\n    fetch('/api/submit', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(data),\n      })\n      .then(response => response.json())\n      .then(realData => {\n        // 실제 데이터로 상태 업데이트\n        setState(prevState => ({ ...prevState, data: realData }));\n    });\n  }\n  return (\n    // optimisticState을 사용하여 UI 렌더링\n    <div>{optimisticState.data}</div>\n  );\n}\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nuseOptimistic은 비동기 작업 중에 예상 결과를 렌더링하고, 작업이 완료되고 상태가 업데이트된 후에 실제 결과(성공 또는 실패)를 렌더링합니다.\n\n## 기타 업데이트\n\n게다가 React 팀 멤버인 Andrew Clark는 2024년에 다음과 같은 변경 사항이 있을 것을 공개했습니다:\n\n🟡 forwardRef → ref는 prop으로: 자식 컴포넌트에서 내부 요소 또는 컴포넌트에 대한 참조를 다룰 때 ref를 일반 prop으로 취급하여 간소화합니다.\n🟡 React.lazy → RSC, promise-as-child: 코드 분할과 lazy로딩 기능을 강화합니다.\n🟡 useContext → use(Context): Context에 접근하는 새로운 방법을 제공합니다.\n🟡 throw promise → use(promise): 비동기 데이터 로딩 처리를 개선합니다.\n🟡 `Context.Provider` → `Context`: 컨텍스트 프로바이더 사용을 간편화합니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그러나 공식 React 웹사이트에서는 아직 이러한 잠재적인 업데이트에 대한 자세한 정보를 제공하지 않았습니다.\n\n# 결론\n\nReact는 위대한 비전을 갖고 있습니다. 그들은 프론트엔드와 백엔드 간의 경계를 흐린 채 클라이언트 측 능력에서 우위를 유지하고 커뮤니티의 풀 스택 프레임워크를 위한 인프라를 제공하려고 합니다. 나는 그들의 방식을 매우 존경합니다. 왜냐하면 프론트엔드와 백엔드 간의 장벽을 허물면 프론트엔드 엔지니어들이 경력적으로 더 나아갈 수 있기 때문입니다.\n\nReact 19는 후크 소개를 이어받는 또 다른 마일스톤 버전이 될 것입니다. 앤드류 클락은 새로운 버전이 3월이나 4월에 출시될 것이라고 말했습니다. 기대해 봅시다!\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저에 관하여\n\nFront-End 엔지니어이자 Full-Stack 실무자이며 AI 통합 옹호자입니다.\n\nNext.js 및 Node.js 프로젝트에서 작업하며, 이 분야에 대한 지식을 공유합니다.\n\nTwitter: https://twitter.com/weijunext\nGithub: https://github.com/weijunext\nBlog: https://weijunext.com/\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 스택데믹 🎓\n\n끝까지 읽어주셔서 감사합니다. 떠나시기 전에:\n\n- 작가를 박수로 격려하고 팔로우해주세요! 👏\n- 팔로우하기: X | LinkedIn | YouTube | Discord\n- 다른 플랫폼 방문하기: In Plain English | CoFeed | Venture | Cubed\n- 더 많은 콘텐츠는 Stackademic.com에서 확인하세요","ogImage":{"url":"/assets/img/2024-07-02-React19isComingWhatsNew_0.png"},"coverImage":"/assets/img/2024-07-02-React19isComingWhatsNew_0.png","tag":["Tech"],"readingTime":10},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<img src=\"/assets/img/2024-07-02-React19isComingWhatsNew_0.png\">\n<p>리액트가 마지막으로 릴리즈된 버전은 2022년 6월 14일에 18.2.0 버전으로 나왔어요. 프론트엔드 개발 분야에서 이렇게 인기 있는 기술의 업데이트 속도가 느린 것은 정말 드물죠. 이로 인해 커뮤니티의 일부 중요 인물들 사이에서 불만이 커졌는데, 제 이전 게시물에서 언급했었어요. 관심 있는 분들은 이 글을 클릭해서 확인할 수 있어요: 리액트 커뮤니티 내의 의견 차이.</p>\n<p>커뮤니티에서 불만이 계속해서 증가하자, 새로운 리액트 버전의 소식이 드디어 전해졌어요.</p>\n<p>리액트 팀은 이제까지 새로운 공식 버전을 출시하지 않은 불만에 대해 응답했어요: 이전에 캐너리 버전에서 출시된 기능들은 서로 상호작용이 필요했기 때문에, 이를 안정 버전에 점진적으로 출시하기 전에 리액트 팀이 함께 작동할 수 있는지 확인하기 위해 많은 시간을 투자해야 했어요.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>사실, 거의 두 년 동안 공식 버전이 출시되지 않았지만 Canary 버전에서 몇 가지 중요한 업데이트가 있었습니다. use, useOptimistic hook, use client, use server 디렉티브와 같은 업데이트는 리액트 에코시스템을 객관적으로 풍부하게 만든 바 있습니다. 특히 Next.js와 Remix와 같은 풀 스택 프레임워크의 빠른 개발을 촉진했습니다.</p>\n<p>리액트 팀은 다음 버전이 19.0.0일 것으로 확인했습니다.</p>\n<h1>v19에서 예상되는 새로운 기능 예측</h1>\n<p>이제 리액트 팀의 최신 소식을 기반으로 공식적으로 버전 19에서 출시될 수 있는 새로운 기능을 미리 살펴보겠습니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h2>자동 메모이제이션</h2>\n<p>React Conf 2021에서 황 쉔이 소개한 React Forget을 기억하시나요?</p>\n<p><img src=\"/assets/img/2024-07-02-React19isComingWhatsNew_1.png\" alt=\"이미지\"></p>\n<p>이제 이것이 여기 있습니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>인스타그램의 제품 환경에서 이미 적용된 컴파일러입니다. React 팀은 이를 Meta의 더 많은 플랫폼에 적용할 계획이며, 향후 오픈소스로 공개할 예정입니다.</p>\n<p>새로운 컴파일러를 사용하기 전에는 useMemo, useCallback 및 memo를 사용하여 수동으로 상태를 캐시하여 불필요한 다시 렌더링을 줄였습니다. 이 구현은 가능하지만, React 팀은 이것이 그들이 상상한 이상적인 방식은 아니라고 믿습니다. React가 상태 변경 시 필요한 부분만 자동으로 다시 렌더링할 수 있는 방법을 찾고 있었습니다. 몇 년의 노력 끝에 새로운 컴파일러가 성공적으로 출시되었습니다.</p>\n<p>새로운 React 컴파일러는 즉시 사용할 수 있는 기능으로, 개발자들에게 또 다른 패러다임 전환을 제공할 것입니다. 이것은 v19의 가장 기대되는 기능입니다.</p>\n<p>재미있는 점은 새로운 컴파일러를 소개할 때 React Forget을 언급하지 않은 React 팀이었는데, 이로 인해 커뮤니티에서 우스꽝스러운 댓글이 나왔습니다: 그들은 React Forget을 잊고 Forget 섹션에서 Forget을 언급하는 것을 잊었습니다.🤣</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h2>작업</h2>\n<p>React Actions은 React 팀이 클라이언트에서 서버로 데이터를 전송하는 솔루션을 탐색하면서 개발한 것입니다. 이 기능을 사용하면 개발자가 DOM 요소 (예: <code>form/</code>)에 함수를 전달할 수 있습니다:</p>\n<pre><code class=\"hljs language-js\">&#x3C;form action={search}>\n   <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"query\"</span> /></span></span>\n   <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"submit\"</span>></span>Search<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">button</span>></span></span>\n&#x3C;/form>\n</code></pre>\n<p>action 함수는 동기적 또는 비동기적일 수 있습니다. 작업을 사용할 때 React는 개발자를 위해 데이터 제출의 라이프사이클을 관리합니다. useFormStatus 및 useFormState 훅을 사용하여 현재 폼 작업의 상태와 응답에 액세스할 수 있습니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>클라이언트와 서버 간 상호 작용 시나리오에서 사용할 수 있는 액션은 데이터베이스 변경(데이터 추가, 삭제, 업데이트) 및 양식(예: 로그인 양식, 등록 양식) 구현과 같은 경우에 사용됩니다.</p>\n<p>useFormStatus 및 useFormState와 결합하는 것 외에도, 액션은 useOptimistic 및 use server와 함께 사용될 수 있습니다. 이에 대해 자세히 확장하면 길고 복잡한 토론이 될 수 있지만, 곧 발표될 기사를 통해 액션의 상세 사용법을 소개할 예정이니 기대해 주세요.</p>\n<h2>지시문: use client 및 use server</h2>\n<p>use client와 use server 지시문은 오랜 기간 동안 Canary 버전에서 사용 가능했으며, 이제 v19에서 안정 버전과 함께 사용할 수 있습니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>이전에 Next.js가 이 두 가지 지시문을 제품으로 사용하는 것에 대한 커뮤니티에서의 빈번한 불만이 있었으며, Next.js는 React 생태계를 손상시키고 있는 것으로 비난되었고, React 팀은 Next.js가 불안정한 기능을 시간 초과로 사용할 수 있도록 허용함에 대해 비판을 받았습니다. 그러나 이 우려는 대부분 불필요합니다. 이 두 가지 지시문은 Next.js나 Remix와 같은 풀스택 프레임워크를 위해 설계되어 있으며, React를 사용하여 응용 프로그램을 개발하는 보통 개발자들은 단기적으로는 거의 필요하지 않을 것입니다.</p>\n<p>React를 사용하는 경우 풀스택 프레임워크가 아니라면, 이 두 가지 지시문의 목적을 이해하는 것만으로 충분합니다. use client와 use server은 프론트엔드와 서버 사이드 환경 사이의 \"분할 지점\"을 표시합니다. use client는 패키지 도구에 <code>script</code> 태그를 생성하도록 지시하고, use server는 패키지 도구에 POST 엔드포인트를 생성하도록 지시합니다. 이러한 지시문을 사용하면 개발자는 동일한 파일에서 클라이언트 사이드 및 서버 사이드 코드를 작성할 수 있습니다.</p>\n<h2>낙관적 업데이트를 위한 useOptimistic</h2>\n<p>useOptimistic는 v19에서 안정적으로 표시될 것으로 예상되는 새로운 훅입니다. useOptimistic를 사용하면 비동기 작업(예: 네트워크 요청) 중에 UI를 낙관적으로 업데이트할 수 있습니다. 현재 상태와 업데이트 함수를 매개변수로 받아들이며, 비동기 작업 중에 상태의 복사본을 반환합니다. 현재 상태와 작업의 입력을 받아 작업을 기다리는 동안 사용할 낙관적 상태를 반환하는 함수를 제공해야 합니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>여기에 그 내용이 정의되어 있습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> [optimisticState, addOptimistic] = <span class=\"hljs-title function_\">useOptimistic</span>(state, updateFn);\n\n<span class=\"hljs-comment\">// 또는</span>\n<span class=\"hljs-keyword\">const</span> [optimisticState, addOptimistic] = <span class=\"hljs-title function_\">useOptimistic</span>(\n  state,\n  <span class=\"hljs-comment\">// updateFn</span>\n  <span class=\"hljs-function\">(<span class=\"hljs-params\">currentState, optimisticValue</span>) =></span> {\n    <span class=\"hljs-comment\">// 낙관적인 값으로 새로운 상태를 병합 및 반환합니다.</span>\n  }\n);\n</code></pre>\n<p>매개변수</p>\n<p>state: 초기 상태 값 및 작업이 진행 중이 아닐 때 반환되는 값입니다.</p>\n<p>updateFn(currentState, optimisticValue): addOptimistic에 전달된 현재 상태 및 낙관적인 값을 사용하여 낙관적인 상태 결과를 반환하는 함수입니다. updateFn은 currentState 및 optimisticValue 두 매개변수를 받습니다. 반환 값은 currentState와 optimisticValue의 병합된 값이 됩니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>반환 값</p>\n<p>optimisticState: 생성된 낙관적인 상태입니다. 작업이 진행 중일 때는 updateFn이 반환하는 값과 동일하며, 작업이 진행 중이 아닌 경우에는 상태와 동일합니다.\naddOptimistic: 낙관적 업데이트 중에 호출되는 디스패치 함수입니다. 낙관적 값 (어떤 유형이든)을 하나의 매개변수로 받아와 상태와 낙관적 값과 함께 updateFn을 호출합니다.</p>\n<p>더 자세한 예제:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { useOptimistic } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react'</span>;\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">AppContainer</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">const</span> [state, setState] = <span class=\"hljs-title function_\">useState</span>(initialState); <span class=\"hljs-comment\">// 초기 상태가 있다고 가정합니다</span>\n  <span class=\"hljs-keyword\">const</span> [optimisticState, addOptimistic] = <span class=\"hljs-title function_\">useOptimistic</span>(\n    state,\n    <span class=\"hljs-comment\">// updateFn</span>\n    <span class=\"hljs-function\">(<span class=\"hljs-params\">currentState, optimisticValue</span>) =></span> {\n      <span class=\"hljs-comment\">// 병합하고 반환: 새로운 상태, 낙관적인 값</span>\n      <span class=\"hljs-keyword\">return</span> { ...currentState, ...optimisticValue };\n    }\n  );\n  <span class=\"hljs-comment\">// 양식 제출과 같은 비동기 작업이 있는 경우를 가정합니다</span>\n  <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">handleSubmit</span>(<span class=\"hljs-params\">data</span>) {\n    <span class=\"hljs-comment\">// 실제 데이터 제출 전에 낙관적 업데이트 사용</span>\n    <span class=\"hljs-title function_\">addOptimistic</span>({ <span class=\"hljs-attr\">data</span>: <span class=\"hljs-string\">'낙관적인 데이터'</span> });\n    <span class=\"hljs-comment\">// 그런 다음 비동기 작업 수행</span>\n    <span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-string\">'/api/submit'</span>, {\n      <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">'POST'</span>,\n      <span class=\"hljs-attr\">headers</span>: {\n        <span class=\"hljs-string\">'Content-Type'</span>: <span class=\"hljs-string\">'application/json'</span>,\n      },\n      <span class=\"hljs-attr\">body</span>: <span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">stringify</span>(data),\n      })\n      .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">response</span> =></span> response.<span class=\"hljs-title function_\">json</span>())\n      .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">realData</span> =></span> {\n        <span class=\"hljs-comment\">// 실제 데이터로 상태 업데이트</span>\n        <span class=\"hljs-title function_\">setState</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">prevState</span> =></span> ({ ...prevState, <span class=\"hljs-attr\">data</span>: realData }));\n    });\n  }\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"hljs-comment\">// optimisticState을 사용하여 UI 렌더링</span>\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>{optimisticState.data}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></span>\n  );\n}\n</code></pre>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>useOptimistic은 비동기 작업 중에 예상 결과를 렌더링하고, 작업이 완료되고 상태가 업데이트된 후에 실제 결과(성공 또는 실패)를 렌더링합니다.</p>\n<h2>기타 업데이트</h2>\n<p>게다가 React 팀 멤버인 Andrew Clark는 2024년에 다음과 같은 변경 사항이 있을 것을 공개했습니다:</p>\n<p>🟡 forwardRef → ref는 prop으로: 자식 컴포넌트에서 내부 요소 또는 컴포넌트에 대한 참조를 다룰 때 ref를 일반 prop으로 취급하여 간소화합니다.\n🟡 React.lazy → RSC, promise-as-child: 코드 분할과 lazy로딩 기능을 강화합니다.\n🟡 useContext → use(Context): Context에 접근하는 새로운 방법을 제공합니다.\n🟡 throw promise → use(promise): 비동기 데이터 로딩 처리를 개선합니다.\n🟡 <code>Context.Provider</code> → <code>Context</code>: 컨텍스트 프로바이더 사용을 간편화합니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>그러나 공식 React 웹사이트에서는 아직 이러한 잠재적인 업데이트에 대한 자세한 정보를 제공하지 않았습니다.</p>\n<h1>결론</h1>\n<p>React는 위대한 비전을 갖고 있습니다. 그들은 프론트엔드와 백엔드 간의 경계를 흐린 채 클라이언트 측 능력에서 우위를 유지하고 커뮤니티의 풀 스택 프레임워크를 위한 인프라를 제공하려고 합니다. 나는 그들의 방식을 매우 존경합니다. 왜냐하면 프론트엔드와 백엔드 간의 장벽을 허물면 프론트엔드 엔지니어들이 경력적으로 더 나아갈 수 있기 때문입니다.</p>\n<p>React 19는 후크 소개를 이어받는 또 다른 마일스톤 버전이 될 것입니다. 앤드류 클락은 새로운 버전이 3월이나 4월에 출시될 것이라고 말했습니다. 기대해 봅시다!</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>저에 관하여</p>\n<p>Front-End 엔지니어이자 Full-Stack 실무자이며 AI 통합 옹호자입니다.</p>\n<p>Next.js 및 Node.js 프로젝트에서 작업하며, 이 분야에 대한 지식을 공유합니다.</p>\n<p>Twitter: <a href=\"https://twitter.com/weijunext\" rel=\"nofollow\" target=\"_blank\">https://twitter.com/weijunext</a>\nGithub: <a href=\"https://github.com/weijunext\" rel=\"nofollow\" target=\"_blank\">https://github.com/weijunext</a>\nBlog: <a href=\"https://weijunext.com/\" rel=\"nofollow\" target=\"_blank\">https://weijunext.com/</a></p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h1>스택데믹 🎓</h1>\n<p>끝까지 읽어주셔서 감사합니다. 떠나시기 전에:</p>\n<ul>\n<li>작가를 박수로 격려하고 팔로우해주세요! 👏</li>\n<li>팔로우하기: X | LinkedIn | YouTube | Discord</li>\n<li>다른 플랫폼 방문하기: In Plain English | CoFeed | Venture | Cubed</li>\n<li>더 많은 콘텐츠는 Stackademic.com에서 확인하세요</li>\n</ul>\n</body>\n</html>\n"},"__N_SSG":true}