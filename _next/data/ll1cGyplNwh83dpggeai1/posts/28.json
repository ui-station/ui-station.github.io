{"pageProps":{"posts":[{"title":"Mac 장치에서 10년 이상의 macOS 지원을 볼 수 있을까요","description":"","date":"2024-05-18 17:41","slug":"2024-05-18-AreWeAboutToSeeDecadeMacOSSupportForMacs","content":"\n\n2020년은 좋은 해였다. 그 말을 취소하겠다. 2020년은 많은 면에서 형편없는 해였다. 모두 잊고 싶어하는 전 세계적 재앙이었다. 하지만 몇몇 사람들에게는 그 해를 조금 더 나은 해로 만드는 무언가가 있었고, 그것이 바로 Apple Silicon이었다. 개인 컴퓨팅의 방향을 근본적으로 바꿔놓은 것으로 여겨지는 구세주다. 이것은 전체 산업이 주목하고 Apple의 발자취를 따르는 가치가 있다고 결론지었다. 그러나 하드웨어의 이번 변화는 무언가를 열어주었고, 그것은 이제는 가능성이 희박했던 것이라고 할 수 있는 장기적인 소프트웨어 지원이다.\n\n현재로서 macOS 소노마는 2018년에 출시된 맥을 지원한다. 나쁘지 않다. 어떤 사람들은 6년이라고 말할지도 모르지만, 그것은 어떤 사람들이 기계를 보관하거나 리퍼비시하여 사용할 때를 고려하지 않은 것이다. 그때에 여러분은 많은 맥북들이 약 10년 이상 사용될 것으로 추측할 수 있다. 나는 처음으로 판매한 15인치 레티나 맥북 프로를 팔 때, 그것은 8년 된 기계였지만, 최신 macOS 버전을 실행하는 능력이 여전히 있었다. 따라서 6년의 지원은 충분하지 않다고 주장할 수 있을 것이다.\n\n그러나 현재 이것이 그럴 수 있는 이유가 있음: 인텔. Apple은 명시적으로 말하지는 않지만, 2020년 이후 많은 사람들이 유추한 것처럼 인텔 맥은 본질적으로 버려진 제품이며, Apple이 현재 인텔 기계에 제공하는 macOS 지원은 고객들을 유지하면서, 아마도 변호사들도 만족시키려는 최소한의 지원만 제공할 뿐이다. 소프트웨어 엔지니어로서, 여러 아키텍처, 브라우저, 운영 시스템 등을 지원하는 것이 얼마나 문제가 되고 비용이 많이 드는지 잘 알고 있다. 그래서 macOS 소노마의 일부 기능이 이미 인텔 기계에서 지원되지 않음에도 불구하고 이해할 수 있다.\n\n그리고 시간이 흐를수록 이것은 더 나빠질 것으로 생각된다. Apple은 기술적으로 2024년 최초로 인텔 기계 지원을 완전히 중단할 수 있으며, 하위 Mac 제품에 합리적인 가격 및 교체 프로그램이 있기 때문에 2019년 인텔 기계를 보유하고 있는 모든 사람은 최신 macOS를 원한다면 그냥 Apple Silicon으로 넘어가야 한다고 주장할 수 있다.\n\n<div class=\"content-ad\"></div>\n\n그런데 물론 Mac Pro가 있죠, 이 부분이 좀 복잡해요. Apple은 2023년에만 Apple 실리콘 Mac Pro를 출시했기 때문에 최신 인텔 머신은 실제로 2022년 머신이란 사실입니다. 그러므로 수만 달러가 든 하드웨어 지원을 중단하는 것은 매우 대담한 결정일 수 있겠죠. 그래도 그 가능성을 완전히 배제할 수는 없지만, 그들의 사이트에서 2019년 머신으로 명시했으니 (2023년 상반기까지 판매되었음) 이에 대한 고려가 필요합니다.\n\n## 10년간의 지원은 가능할까요?\n\n기술적으로 Apple 실리콘이 적어도 10년간은 유지될 것으로 가정하면 이미 3년이 지났으므로 우리는 2030년에도 여전히 Apple 디자인된 SOC를 사용할 것으로 예상할 수 있습니다. 문제는 macOS가 2030년에도 여전히 M1 및 M2 기기에서 잘 작동할지 여부입니다.\n\n역사를 보면 어떤 면에서는 모두가 10년간 소프트웨어 지원을 포기해야 한다는 주장도 나올 것입니다. 인텔 전용 머신을 위해 설계된 마지막 OS인 MacOS 카탈리나는 2019년에 출시되었고, 그가 지원하는 가장 오래된 머신은 2012년 출시된 것입니다. 8년입니다. 그러나 2010년 머신은 이미 2006년부터 Intel 기반 머신으로 운영되는 것을 고려하면 Apple은 실제로 10년까지 갈 수도 있었을 것입니다. 이론상으로 말이죠. 혹시 모르니까요.\n\n<div class=\"content-ad\"></div>\n\n애플의 역사에서 파워PC와 인텔 시대는 동일한 문제를 겪었습니다. 크릠토자이트(쿠퍼티노 옆의 도시이며 애플 본사가 있는 곳) 거인은 하드웨어 디자인과 개발을 일부만 제어했습니다. IBM-모토로라 파트너십에서 인텔로 이동하면서도 그것은 결국 파트너십이었습니다. 잘못 알아들지 마세요, 이 이동은 필요했고 애플을 크게 돕게 되었습니다. 요즘 우리가 인텔을 비웃거나 깎아내리더라도, 불과 몇 년씩 조금씩 향상된 매우 뜨거운 프로세서들은 맥을 그 어느 때보다 인기 있게 만들었습니다. 큰 그림에서 보면, 이는 인텔보다 애플을 훨씬 더 도와준 것입니다.\n\n그렇지만 12년 된 맥에서 macOS 카탈리나를 테스트해보는 것은 흥미로울 것이지만, 인텔 초기 칩들은 운영 체제를 실행하는 데도 힘들 것으로 예상됩니다. 2008년 머신에서 실행 시도는 이미 전체 UX에 걸친 렉과 같이 용납할 수 없는 결과를 야기했습니다. 그리고 이 때에는 제 3자 앱이 설치되지 않은 상태였습니다. 매 해 이루어지는 인텔 업데이트의 증분만큼은 작더라도, 애플-인텔 관계 말기에 우리는 OS가 자원을 모두 독차지하지 않도록 하는 하드웨어-소프트웨어 구성을 갖게 되었습니다.\n\n그러나 엠퓨전 바실릭(애플에서 사용 중인 칩)에 오면, 상황은 매우 다릅니다. M1 칩을 기반으로 시작해서 발생할 수 있는 유일한 하드웨어 병목은 RAM입니다. 기본 머신은 단지 8GB의 메모리만 갖추어져 있고, 그것은 서비스할 수 없는 메모리입니다. 2030년까지 운영 체제만을 위해 모두 8GB의 메모리를 필요로 할 것이라 가정하지 않을지라도, 또한 그것이 불가능하지는 않습니다. 이 기사를 쓰는 시점에서 맥 OS의 커널과 다른 핵심 구성요소 및 기능을 위해 약 4GB의 메모리가 \"와이어드\" 메모리로 설정되어 있습니다.\n\n![이미지](/assets/img/2024-05-18-AreWeAboutToSeeDecadeMacOSSupportForMacs_0.png)\n\n<div class=\"content-ad\"></div>\n\n이 흥미로운 이유는 128GB M3 Max Machine에서이 숫자를 보고 있기 때문입니다. Apple의 \"유선\" 메모리는 작업 가능한 총 메모리에 따라 동적으로 변경됩니다. 보고된 바에 의하면, 작동 중에 약 10개의 앱이 열린 상태에서 브라우저에서 몇 십 개의 탭과 함께 실행되어도 필요한 최대 메모리는 약 4GB입니다. 이것은 좋은 소식이지만, 2020 M1 MacBook Air의 8GB 메모리에서 2030 버전 macOS가 원활하게 실행될 것이라고 납득시킬만큼 충분한 이유는 아닙니다.\n\n물론, 시간이 지남에 따라 SOC에 새로운 구성 요소가 추가될 때, 특정 기능이 더 제한되고 작업 처리에 더 많은 시간이 걸릴 가능성이 있습니다. 그러나 최신과 최고의 것을 필요로 하는 사람들은 종종 10년간 자신의 기기를 보유하지 않습니다.\n\n그러나 그것도 중요하지 않을 수 있습니다. 더 예측할 수없는 상황을 만들기 위해 Apple은 악명 높은 \"불필요한 장치\" 목록으로 유명합니다. 예를 들어 2023년에는 2017 TouchBar MacBook Pro를 그 목록에 추가했습니다. 겨우 7년 된 기기인데, 이는 내 관점에서 Mac 사용자의 50% 이상에게 여전히 완벽하게 적합한 디바이스입니다.\n\nM1 머신을 사용한 우리 모두와 현재 Apple Silicon의 데뷔 SOC 능력을 이제야 발견하고 있는 사람들까지도 모두 동의하는 것은 그 속도가 엄청나게 빠르다는 것입니다. 그리고 메모리는 여전히 메모리이지만, 충분히 있다면 표준 생산성 앱을 실행하는 데 어려움이 없을 것이며, 현재 Apple은 모든 기기에 대한 블랭킷 규칙으로 7년 규칙을 적용하는 것으로 보입니다. 이것이 Mac, iPhone 또는 기타 무엇이든.\n\n<div class=\"content-ad\"></div>\n\n그 동안 앞으로 수년 동안 현명한 선택이었을 수도 있지만, Apple Silicon Mac은 단순히 더 이상 OS 업데이트가 없어서 7년 후에 그들을 버릴 수밖에 없다는 이유로 간주되기에는 훨씬 더 능숙하다고 느껴집니다. 물론, 구시 버전의 OS를 사용할 수는 있지만, 그게 반드시 필요한 이유가 없다는 점도 알 수 있습니다. 7년이 되면 기기의 배터리는 분명히 소진될 것이지만, 그 기기 자체가 사용할 수 없게 되는 것은 아닙니다. Apple은 다음과 같이 명시하고 있습니다.\n\nApple의 역사적 데이터를 살펴보고 고갈되거나 폐기된 기기에 대한 그들의 입장과 Apple Silicon SOC의 전례 없는 기능을 고려할 때, 조금의 선의를 가지고 Apple이 사실상 Mac에 대한 소프트웨어 지원을 10년 이상 제공할 수도 있을 것으로 생각합니다. 그리고 아마도 더 강력한 기기에서는 더 오래 제공될 수도 있으니, 다음으로 넘어가보겠습니다.\n\n## 불안정한 Intel 미래\n\n지난 몇 년 동안 수만 달러를 Mac Pro에 투자한 사람들은 이미 이상한 상황에 처해 있습니다. macOS Sonoma에 있는 5 가지 기능은 이미 Apple Silicon에만 적용되어 있습니다. Intel Mac Pro가 얼마나 강력하더라도, 특정 Sonoma 기능은 단순히 사용할 수 없습니다.\n\n<div class=\"content-ad\"></div>\n\n- Presenter Overlay는 Apple의 신경 엔진을 사용하여 주제를 배경에서 분리합니다. 이 기능을 자주 사용하는데, 아마 필수적이지는 않지만 정말 멋진 기능이에요.\n- \"Siri\"를 약자로 사용하게 되었네요. 인텔 맥을 사용할 때 \"Hey\"를 생략할 수 없다는 게 밝혀졌어요. 웃기지만 그게 현실이에요.\n- 게임 모드는 인텔 맥에서도 사용할 수 없고, Mac Pro를 완전히 강화한 모델이 얼마나 강력할 수 있는지 생각해보면, Mac에서 일부 게임을 훌륭하게 실행하는 데 중요한 설정을 사용할 수 없다는 것이 이를 바라게 만들어요.\n- iPhone용 제작된 청각 장치는 Intel Mac(또는 M1 기본 모델)과 연결할 수 없어요. 아마 쓰이는 경우가 제한적일 수 있지만, 이는 주목할 만한 사실이에요.\n- 화면 공유는 기술적으로 인텔 맥에서 사용할 수는 있지만, 성능이 좋지 않아서 원활한 경험을 원한다면 Apple Silicon을 사용해야 해요.\n\n그리고 이것은 단지 시작에 불과해요. 현실적으로 생각해보면, macOS의 모든 미래 버전은 Apple Silicon 전용 기능을 계속해서 추가할 것이고, 이해할 만한 일이에요. 기술 회사로서 이런 엄청난 새로운 칩을 가지고 작업하게 될 테니까요. 물론 새로운 OS 기능을 이를 최대한 활용하는 데 중점을 둘 거예요.\n\nPowerPC와 Intel에 대한 결합 지원은 4년 동안에만 지속되었고 세 개의 OS 출시로 이루어진 것이었어요 - Tiger, Leopard 그리고 Snow Leopard. 현재 우리는 다시 4년의 기간에 도달했는데 이번에는 네 가지 OS 출시로 이루어진 것이에요 - Big Sur, Monterey, Ventura, Sonoma. 이것은 - 난 다음 macOS 버전에서 인텔 머신을 완전히 덜 지원할 것으로 예상하지만 - 다음 해의 macOS가 인텔 기기를 완전히 지원하지 않게 될 수도 있지만, 이건 인텔 맥에 수십만 달러를 쓴 후에 생각해야 할 좋지 않은 전망이에요.\n\n![이미지](/assets/img/2024-05-18-AreWeAboutToSeeDecadeMacOSSupportForMacs_1.png)\n\n\n<div class=\"content-ad\"></div>\n\n![image](/assets/img/2024-05-18-AreWeAboutToSeeDecadeMacOSSupportForMacs_2.png)\n\n애플이 인텔 기기 지원을 곧 중단하며 애플 실리콘 맥스의 OS 업데이트가 얼마나 오래 지속될지는 아직 알 수 없습니다. 하드웨어가 원활하게 실행할 수 있는 한 OS 업데이트를 허용해 줬으면 좋겠습니다. 모든 시스템에 일괄 적용하는 대신 주요 업데이트를 요청하기 전에 시스템에서 벤치마크를 실행하고, 벤치마크 결과가 요구 사양을 충족하는 경우에 사용자가 업그레이드할 수 있도록 하는 것은 어떨까요?\n\nAttila Vago — 코드 한 줄씩 세상을 개선 중인 소프트웨어 엔지니어입니다. 영원한 멋쟁이, 코드와 블로그의 작가, 웹 접근성 옹호자, 레고 팬, 비닐 음반 수집가입니다. 수제 맥주를 좋아합니다! 제 Hello 이야기를 읽어보세요! 레고, 기술, 코딩, 웹 접근성에 관한 더 많은 이야기를 구독하세요! 가끔 읽는 독자를 위해 잡다한 이야기와 글쓰기에 대해도 씁니다.","ogImage":{"url":"/assets/img/2024-05-18-AreWeAboutToSeeDecadeMacOSSupportForMacs_0.png"},"coverImage":"/assets/img/2024-05-18-AreWeAboutToSeeDecadeMacOSSupportForMacs_0.png","tag":["Tech"],"readingTime":7},{"title":"생산성을 높이는 새로운 보이지 않는 강력한 AI 동료와 함께하세요","description":"","date":"2024-05-18 17:40","slug":"2024-05-18-PowerupproductivitywhitthisnewinvisiblypowerfulAIcopilot","content":"\n\n안녕하세요! 만약에 중간(Medium)에 계신 분이라면, 이 글을 우연히 발견하셨을 거예요. 제가 알겠네요, 생산성을 향상시키는 도구를 항상 찾고 계시는 분이시군요.\n\n저는 OpenAI의 열렬한 지지자이며, 최근에 새로운 ChatGPT 앱을 Mac용으로 미리 접근할 수 있게 되었어요. 아직 몇 가지 특징이 빠진 부분은 있지만, 그동안 발견한 Invisibility 는 제 기대치를 훌륭히 능가하는 도구예요. 왜 이것을 확인할 가치가 있는지 말씀드릴게요.\n\n이 소프트웨어는 GPT-4, Claude 3 Opus, Gemini, Llama 3 등 여러 유형의 AI 모델에 대한 액세스를 구독 서비스 하나로 제공해요.\n\n이는 화면 스크린샷과 실제 화면에서 실시간으로 요청을 처리해 줘요. 마치 항상 준비된 데스크톱용 끊임없는 AI 비서가 있는 것과 같아요.\n\n<div class=\"content-ad\"></div>\n\n투명성의 주요 기능:\n\n- 한 가입으로 여러 AI 액세스 가능.\n- 데스크톱 어시스턴트: 화면에 항상 활성화된 AI.\n- 실시간 처리: 스크린샷을 통해 요청에 즉각적으로 응답.\n\nChatGPT로 콘텐츠를 작성하고 투명성이 작업을 분석하고 최적화하는 것을 상상해보세요. 이 둘의 협업은 우리가 일하는 방식을 변화시켜 모든 작업을 더 원활하고 효율적으로 만들어 줄 것입니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*3sH2-U3tS5dYyYhT7Evi8g.gif)\n\n<div class=\"content-ad\"></div>\n\n일상적인 작업 관리에서의 일반적인 문제들을 해결해주는 Invisibility는 혁신적인 도구와 실시간 처리 능력 덕분에 제 효율성과 생산성이 크게 향상되었어요... 지금 이것은 저의 마음에 드는 도구가 되었답니다!\n\n이렇게 강력하고 유용한 도구를 만들어준 개발자들과 Sulaiman Ghori에게 큰 박수를 보내고 싶어요.\n\n궁금하신가요? 제 링크로 무료로 시도해보세요... 정말 멋지거든요!: https://invite.i.inc/Nicolo\n\nps. 이 신원에는 \"Arc\" 같은 것이 있어요 :)","ogImage":{"url":"/assets/img/2024-05-18-PowerupproductivitywhitthisnewinvisiblypowerfulAIcopilot_0.png"},"coverImage":"/assets/img/2024-05-18-PowerupproductivitywhitthisnewinvisiblypowerfulAIcopilot_0.png","tag":["Tech"],"readingTime":2},{"title":"맥에 PHP 설치하는 방법","description":"","date":"2024-05-18 17:39","slug":"2024-05-18-HowtoInstallPHPonMac","content":"\n\n\n![2024-05-18-HowtoInstallPHPonMac_0](/assets/img/2024-05-18-HowtoInstallPHPonMac_0.png)\n\nPHP은 웹 애플리케이션을 개발하는 데 사용되는 인기있는 프로그래밍 언어입니다. Mac을 사용하고 PHP를 사용하여 웹 애플리케이션을 개발하려면 Mac에 PHP를 설치해야 합니다. 이 기사에서는 Mac에 PHP를 설치하는 과정을 단계별로 안내해 드리겠습니다.\n\n## 단계 1: Homebrew 설치\n\nHomebrew는 macOS용 패키지 관리자로, 소프트웨어 패키지를 쉽게 설치하고 관리할 수 있게 해줍니다. Homebrew를 설치하려면 Mac의 터미널 앱을 열고 다음 명령을 실행하십시오:\n\n\n<div class=\"content-ad\"></div>\n\n```bash\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n```\n\n이 명령은 Mac에 Homebrew를 다운로드하고 설치합니다.\n\n## 단계 2: PHP 설치\n\nHomebrew를 설치하면 PHP를 설치하는 데 사용할 수 있습니다. 터미널 앱에서 다음 명령을 실행하세요:\n\n<div class=\"content-ad\"></div>\n\n\n```js\nbrew install php\n```\n\n이 명령은 Mac에 PHP의 최신 버전을 설치할 것입니다.\n\n## 단계 3: PHP 버전 확인\n\nPHP가 올바르게 설치되었는지 확인하려면 기기에 설치된 PHP 버전을 확인할 수 있습니다. 터미널 앱에서 다음 몤령을 실행하세요:\n```\n\n<div class=\"content-ad\"></div>\n\n```js\nphp -v\n```\n\n이 명령어를 실행하면 Mac에 설치된 PHP 버전이 표시됩니다.\n\n## 단계 4: PHP 구성\n\nPHP를 설치한 후에는 필요에 맞게 구성할 수 있습니다. 이를 위해 php.ini 파일을 수정하여 구성할 수 있습니다. php.ini 파일을 찾으려면 터미널 앱에서 다음 명령어를 실행하십시오:\n\n<div class=\"content-ad\"></div>\n\n```js\nphp --ini\n```\n\n이 명령어를 실행하면 php.ini 파일의 위치가 표시됩니다. 그런 다음 텍스트 편집기를 사용하여 파일을 열고 필요한 변경 사항을 적용할 수 있습니다.\n\n## 단계 5: PHP 서버 시작\n\n터미널 앱에서 다음 명령어를 실행하여 PHP 서버를 시작할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nphp -S localhost:8000\n```\n\n이 명령어는 포트 8000에서 PHP 서버를 시작합니다. 그런 다음 웹 브라우저를 열고 http://localhost:8000에 가서 PHP 애플리케이션을 볼 수 있습니다.\n\n축하합니다! Mac에 PHP를 성공적으로 설치했습니다. 이제 PHP를 사용하여 웹 애플리케이션을 개발할 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-18-HowtoInstallPHPonMac_0.png"},"coverImage":"/assets/img/2024-05-18-HowtoInstallPHPonMac_0.png","tag":["Tech"],"readingTime":2},{"title":"2024년을 위한 데이터 과학을 위한 MacBook 설정 방법","description":"","date":"2024-05-18 17:38","slug":"2024-05-18-HowtoSetupYourMacbookforDataSciencein2024","content":"\n\n<img src=\"/assets/img/2024-05-18-HowtoSetupYourMacbookforDataSciencein2024_0.png\" />\n\n최근에 새 맥북을 샀어요. 맥북을 제 마음대로 설정하기 위해 이전 맥북 경험과 인터넷 조사를 토대로 많은 시간을 보냈어요. 데이터 과학자를 위한 앱과 도구를 갖춘 매우 쾌적한 환경을 만들기 위해 취한 단계를 문서화했어요. 이 기사는 세 가지 섹션으로 나누어져 있어요:\n\n- 브라우저 설정\n- 설치할 앱\n- 터미널 설정 (파이썬 설정 포함)\n\n# 브라우저\n\n<div class=\"content-ad\"></div>\n\n먼저 브라우저부터 살펴보겠습니다. 나는 Google Chrome 또는 Arc와 같은 Chromium 기반 브라우저를 Safari보다 선호합니다. Chromium 기반 브라우저가 가지고 있는 확장 기능 라이브러리 때문에 그런데요. 나는 Chrome보다는 더 깔끔하고 우아한 느낌의 Arc를 사용합니다.\n\n나의 브라우저에 사용하는 익스텐션은 다음과 같습니다:\n\n- Vimium C-`는 웹을 탐색할 때 마우스 대신 단축키를 사용할 수 있습니다. f를 누르면 각 버튼에 대한 단축키가 표시되며 해당 버튼을 클릭할 수 있습니다. 해당 버튼의 문자를 입력하여 마우스를 사용하지 않고 버튼을 클릭할 수 있습니다! 익스텐션의 설정에서는 단축키를 표시하거나 숨기기를 쉽게 전환하기 위해 링크 힌트에 사용된 문자에서 문자 f를 제거하는 것을 권장합니다. 또한, Vimium C를 사용하면 책갈피 및 다른 탭에 신속하게 액세스할 수 있습니다.\n\n![이미지](/assets/img/2024-05-18-HowtoSetupYourMacbookforDataSciencein2024_1.png)\n\n<div class=\"content-ad\"></div>\n\n- 비트워던 -` 다양한 비밀번호 관리자가 있지만, 비트워던은 그 중 하나입니다. 모든 기기에서 작동하며 무료 티어에서 다양한 기능을 제공하므로 제 선호도입니다.\n- 원세 -` 원세는 자주 열고 싶지만 그렇게 하기 전에 한 번 더 생각해야 할 웹사이트를 구성할 수 있는 확장 프로그램입니다. 소셜 미디어 및 뉴스 웹사이트 등의 예시가 있습니다. 이러한 URL로 이동하면 원세가 일정 시간 동안 웹사이트를 차단하여 실제로 해당 웹사이트를 방문하고 싶은지 여부를 두 번 생각할 수 있습니다. 제 모든 기기에서 사용하고 있으며 소셜 미디어 및 뉴스 웹사이트에서 많은 시간을 절약하도록 도와줍니다.\n\n![이미지](/assets/img/2024-05-18-HowtoSetupYourMacbookforDataSciencein2024_2.png)\n\n# 앱\n\n- 비주얼 스튜디오 코드 -` 제 선호하는 통합 개발 환경(IDE)입니다. 물론, VS code 대 PyCharm 논쟁이 있지만, 확장 라이브러리가 넓고 PyCharm보다 훨씬 가볍기 때문에 VS Code를 선호합니다.\n- 도커 데스크톱 -` Docker를 사용할 수 있도록 멋진 UI가 제공됩니다.\n- 비트워던 -` 크롬 확장 프로그램으로 언급한 이유와 동일합니다.\n- 키클루 -` 누른 키를 두 번 눌러 누르고 두 번째로 누른 채로 최종으로 너무 많은 응용 프로그램에 대한 대부분의 단축키를 볼 수 있습니다. 사용자 정의 단축키도 추가할 수 있습니다.\n- 원세 -` 앞에서 언급한 크롬 웹 확장 프로그램과 같은 아이디어입니다.\n- 마그넷 -` Windows에서 온 경우이며 Windows 10부터 사용할 수 있는 화면 분할 기능이 맥에서도 사용 가능하게 해주는 손쉬운 방법이 부족한가요? Magnet은 맥에서도 동일한 기능을 제공하지만 무료는 아닙니다.\n\n<div class=\"content-ad\"></div>\n\n# 터미널\n\nMacOs의 기본 터미널은 괜찮아요. 저는 여러 해 동안 사용해 왔고, 많은 사람들이 아직도 사용하고 있어요. zsh에 플러그인을 사용하면 터미널을 사용하는 것이 이미 훨씬 더 즐거워집니다. 하지만 여기서 여러분이 터미널에서 절대로 얻을 수 있는 최대한의 이점에 대해 설명할게요.\n\n## Oh My Zsh\n\nOh My Zsh는 여러분의 Zsh 구성을 관리하기 위한 오픈소스, 커뮤니티 주도의 프레임워크로, 테마와 플러그인을 제공하여 터미널 경험을 향상시킵니다.\n\n<div class=\"content-ad\"></div>\n\n먼저 다음 명령어를 입력하여 터미널에서 Oh My Zsh를 설치하세요:\n\n```js\nsh -c \"$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\"\n```\n\n## Homebrew\n\n그런 다음 Homebrew를 설치하세요. Homebrew는 MacOS용 무료 오픈 소스 패키지 관리 시스템으로, 소프트웨어를 설치, 업데이트 및 관리하는 데 사용됩니다.\n\n<div class=\"content-ad\"></div>\n\n```bash\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n```\n\n## Warp\n\n그런 다음 Warp를 설치하세요. Warp는 내장 MacOs 터미널을 대체할 거의 IDE와 같은 터미널입니다. 내장 터미널처럼 계속 사용할 수 있지만, 매우 환영 받는 추가 기능(무료 커서 배치, 텍스트 바로 가기)부터 고급 기능(패널 분할, 탭, 이전 명령어 검색) 및 기타 여러 가지를 제공합니다. 또한 명령어보다 하고자 하는 것을 입력할 수 있는 A.I. 어시스턴트를 사용할 수 있습니다. 또한, autosuggestions와 color-highlighting과 같은 인기있는 oh-my-zsh 플러그인이 Warp와 함께 내장되어 있습니다.\n\n<img src=\"/assets/img/2024-05-18-HowtoSetupYourMacbookforDataSciencein2024_3.png\" />\n\n\n<div class=\"content-ad\"></div>\n\n이 튜토리얼을 따라 하면 VS Code에서 Warp를 더 원활하게 사용할 수 있습니다.\n\n## powerlevel10k\n\n저는 powerlevel10k를 터미널 테마로 좋아하는데, 깔끔하게 보이고 간단한 단계로 쉽게 사용자 정의할 수 있기 때문이죠.\n\n![이미지](/assets/img/2024-05-18-HowtoSetupYourMacbookforDataSciencein2024_4.png)\n\n<div class=\"content-ad\"></div>\n\n제가 추천하는 글꼴을 설치하는 방법부터 시작할게요. 워프에서 활성화하려면 설정 -` 외형 -` 터미널 글꼴로 이동하여 MesloLGS NF를 선택하세요.\n\n그런 다음 다음과 같이 설치하세요:\n\n```js\ngit clone --depth=1 https://github.com/romkatv/powerlevel10k.git ${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/themes/powerlevel10k\n```\n\nsource ~/.zshrc로 셸을 다시 시작하고 p10k configure를 실행하여 테마를 구성하세요! 설정 -` 외형 -` 프롬프트에서 쉘 프롬프트 대신 워프 프롬프트 설정되었는지 확인해주세요.\n\n<div class=\"content-ad\"></div>\n\n## z\n\n저는 oh-my-zsh에 z 플러그인을 사용하는 것을 좋아합니다. 이를 사용하면 전체 경로를 입력하지 않고 디렉토리 간에 이동할 수 있습니다. vim ~/.zshrc을 실행한 후 플러그인 섹션에 z를 추가하고 :wq로 vim을 나가면 됩니다.\n\n![이미지](/assets/img/2024-05-18-HowtoSetupYourMacbookforDataSciencein2024_5.png)\n\n## Python\n\n<div class=\"content-ad\"></div>\n\n대부분의 데이터 과학자들은 주 프로그래밍 언어로 Python을 사용합니다. MacBook에는 기본 설치되어 있어야 합니다. 그러나 새로 시작할 때 python --version 명령이 실패할 수 있고 python3 --version은 작동할 수 있습니다. python3 명령뿐 아니라 python 명령을 실행하려면 ~/.zshrc 파일에 다음을 추가하십시오:\n\n```js\necho 'alias python=\"python3\"' >> ~/.zshrc\n```\n\n다른 프로젝트에 대해 다른 Python 버전을 사용하려면 pyenv를 사용합니다:\n\n```js\nbrew update\nbrew install pyenv\nbrew install xz\n\necho 'export PYENV_ROOT=\"$HOME/.pyenv\"' >> ~/.zshrc\necho '[[ -d $PYENV_ROOT/bin ]] && export PATH=\"$PYENV_ROOT/bin:$PATH\"' >> ~/.zshrc\necho 'eval \"$(pyenv init -)\"' >> ~/.zshrc\n```\n\n<div class=\"content-ad\"></div>\n\n파이썬 버전을 확인하려면 pyenv install --list 명령을 사용하세요. 저는 일반적인 Python3 버전만 설치하고 싶어하여 pyenv install --list | grep ' 3\\.' 를 사용합니다.\n\n내 설치를 깨끗하게 유지하고 실수로 가상 환경이 아닌 전역적으로 의존성을 설치하는 것을 방지하기 위해 다음 두 가지 방법을 적용합니다:\n\n```js\necho 'alias pip=\"pip3 --require-virtualenv\"' >> ~/.zshrc\n```\n\n그리고 pip 설정의 전역 설정에 require-virtualenv = true를 추가합니다:\n이미 pip 설정 파일이 있는지 확인하려면 cat ~/.config/pip/pip.conf를 사용하세요. 이미 설정 파일이 있다면 [global] 섹션에 require-virtualenv = true를 추가하세요. 설정 파일이 없다면 아래 명령을 사용하세요:\n\n<div class=\"content-ad\"></div>\n\n```bash\nmkdir -p ~/.config/pip && echo \"[global]\\nrequire-virtualenv = true\" > ~/.config/pip/pip.conf\n```\n\n# 결론\n\n위에서 언급한 브라우저 확장 프로그램, 앱 및 명령줄 도구를 모두 설치하면 MacBook에서 프로그래밍하는 데 훌륭한 경험을 할 수 있을 것입니다. 물론 모든 도구가 모든 사람에게 유용하거나 호감을 받는 것은 아닙니다. 키보드 단축키보다 마우스를 선호한다면 Vimium C 같은 도구를 설치할 필요가 없습니다. 또한 VS Code 대신 PyCharm을 선호한다면 쉽게 교체할 수 있습니다.\n\n제가 사용 중인 MacBook 설정에 만족하실 것으로 기대하며 놓치고 있는 유용한 도구가 있으면 댓글로 알려주세요!```\n\n<div class=\"content-ad\"></div>\n\n## MLearning.ai의 작가 / Hacking GPTs Store / 20,000개 이상의 아트 프롬프트","ogImage":{"url":"/assets/img/2024-05-18-HowtoSetupYourMacbookforDataSciencein2024_0.png"},"coverImage":"/assets/img/2024-05-18-HowtoSetupYourMacbookforDataSciencein2024_0.png","tag":["Tech"],"readingTime":6},{"title":"파드맨으로 전환하기 도커의 오픈소스 대안","description":"","date":"2024-05-18 17:36","slug":"2024-05-18-SwitchingtoPodmananOpen-SourcealternativetoDocker","content":"\n\n2021년 8월 기준으로 Docker Desktop은 기업용 유료 구독이 필요하지만 CLI는 무료로 제공됩니다. 이 변경으로 일부 사용자들이 대안 옵션을 찾게 될 수 있습니다. 하지만 macOS 사용자로서 Docker Desktop은 Docker CLI를 실행하는 데 필수적이지만 걱정하지 마세요. 다른 옵션이 있습니다.\n\nColima와 Podman은 Docker의 가장 인기 있는 대체품 중 두 가지로, 둘 다 시도해본 결과 이 글에서는 컨테이너 관리를 위한 무료 오픈 소스 대안인 Podman에 초점을 맞출 것입니다.\n\nPodman은 제가 발견한 최고의 대안이며, 그 이유를 설명하겠습니다!\n\n- Docker 사용자이지만 CLI를 자주 사용하지 않는 경우, Podman은 데스크톱 애플리케이션을 갖추고 있어 무료이므로 훌륭한 선택입니다!\n- Docker 사용자이고 CLI만 사용하는 경우에도 Podman은 작동합니다!\n\n물론, Podman을 설치하고 docker `무언가`를 실행하려고 하면 작동하지 않을 것입니다. 그러나 이 글을 따라가면 Podman을 내 Docker 대체 도구로 사용하는 방법을 알 수 있습니다!\n\n<div class=\"content-ad\"></div>\n\n# Podman 설치 방법\n\nPodman을 설치하려면 데스크톱 앱을 포함하여 두 가지 명령어만 필요합니다:\n\n- Podman CLI 설치: brew install podman;\n- Podman 데스크톱 설치: brew install --cask podman-desktop;\n\n- 데스크톱 애플리케이션을 원하는 사용자를 위한 명령어임을 주의해주세요.\n\n<div class=\"content-ad\"></div>\n\n# 가상 머신을 시작하는 방법\n\nPodman을 설치한 후 가상 머신을 시작하려면 만들고 시작해야 합니다. 아래 단계를 따라 주세요:\n\n- podman machine init;\n- podman machine start;\n\n## 가상 머신이 성공적으로 초기화되었는지 어떻게 알 수 있나요?\n\n<div class=\"content-ad\"></div>\n\n가상 머신이 성공적으로 시작되었는지 확인하려면 터미널에서 `podman machine list`를 실행하십시오. 아래 스크린샷과 유사한 내용이 표시되어야 합니다. 여기에는 기본 머신이 현재 실행 중인 것이 표시됩니다:\n\n![스크린샷](/assets/img/2024-05-18-SwitchingtoPodmananOpen-SourcealternativetoDocker_0.png)\n\n# Podman과 함께 Docker Compose 사용하는 방법\n\n기본 설정에서 Docker Compose는 Podman을 \"Docker\" 인스턴스로 인식하지 않을 것입니다. 그러나 \"수정\"하여 사용할 수 있습니다!\n\n<div class=\"content-ad\"></div>\n\n어떤 일을 하기 전에 brew install docker-compose 명령을 사용하여 Docker Compose를 설치해야 합니다.\n\n그러나 이 시점에서 docker-compose up을 실행하면 \"Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?\"과 같은 오류 메시지가 표시될 것입니다.\n\nDocker Compose를 Podman과 함께 작동하도록 하려면 다음 단계를 따르세요:\n\n- sudo /usr/local/Cellar/podman/`podman-version`/bin/podman-mac-helper install;\n\n<div class=\"content-ad\"></div>\n\n- 참고: `podman-version`을(를) 사용 중인 Podman 버전으로 바꿔주세요.\n\n- podman machine stop && podman machine start;를 실행해주세요;\n\n이제 작동하는지 확인해볼 시간입니다! 기존의 docker-compose.yaml 파일을 사용하거나 새로 만들어서 docker-compose up -d를 실행해보세요.\n\n![이미지](/assets/img/2024-05-18-SwitchingtoPodmananOpen-SourcealternativetoDocker_1.png)\n\n<div class=\"content-ad\"></div>\n\n## 작동하지 않나요?\n\n이러한 단계를 따라도 Docker Compose가 여전히 동일한 오류(\"Docker 데몬에 연결할 수 없음...\")를 표시한다면, 아래 두 가지 해결 방법 중 하나를 시도해 보세요:\n\n- 다음 명령을 사용하여 DOCKER_HOST를 내보내려 해보세요: \n  ```sh\n  export DOCKER_HOST=`unix:///Users/your-user/.local/share/containers/podman/machine/podman-machine-default/podman.sock`\n  ```\n- rootful 권한으로 Podman Machine을 설정하려면 다음 명령을 사용하세요:\n  ```sh\n  podman machine stop && podman machine set --rootful && podman machine start\n  ```\n\n# Podman 명령어\n\n<div class=\"content-ad\"></div>\n\nDocker와 Podman 사이에는 많은 명령어가 유사하지만, 이미지 및 컨테이너 작업을 할 때 구문 및 동작에 차이가 있습니다. 특히 특정 명령어와 옵션에 대해 더 알아보려면 항상 Podman 설명서를 참고하거나 podman --help를 실행하는 것이 좋습니다.\n\n일부 예시를 살펴보겠습니다:\n\n- docker ps는 podman ps로 변경됩니다;\n- docker run은 podman run으로 변경됩니다;\n- docker rm `container`는 podman rm `container`로 변경됩니다;\n- 기타.\n\n다음은 docker와 함께 사용할 Podman 명령어에 별칭을 생성하는 단계입니다:\n\n<div class=\"content-ad\"></div>\n\n\n- 물고기 (Oh My Fish를 사용하는 경우):\n\n- IDE에서 파일 ~/.config/fish/conf.d/omf.fish을 엽니다;\n- 초기 설정 라인 (1에서 4까지) 다음에 다음 라인을 추가합니다: alias docker=\"podman\";\n- 터미널을 다시 시작하거나 source ~/.config/fish/conf.d/omf.fish을 실행합니다.\n\n- Zsh의 경우:\n\n- IDE에서 파일 ~/.zshrc을 엽니다;\n- # Example aliases 주석 다음에 다음 라인을 추가합니다: alias docker=\"podman\";\n- 터미널을 다시 시작하거나 source ~/.zshrc을 실행합니다.\n\n<div class=\"content-ad\"></div>\n\n- Bash에 대한 설명:\n\n  - IDE ****에서 파일 ~/.bashrc을 열어주세요;\n  - 다음 줄을 파일 끝에 추가해주세요: alias docker=\"podman\";\n  - 터미널을 재시작하거나 source ~/.bashrc을 실행해주세요.\n\n해당 alias를 생성한 후에는 Docker와 동일하게 docker 명령을 사용할 수 있지만 해당 명령은 Podman 명령을 실행합니다.\n\n# Podman 데스크톱\n\n<div class=\"content-ad\"></div>\n\n\n![Switching to Podman: an Open-Source alternative to Docker](/assets/img/2024-05-18-SwitchingtoPodmananOpen-SourcealternativetoDocker_2.png)\n\n이미 이전에 언급한 바와 같이, Podman은 CLI를 사용하기를 원하지 않는 경우 필요한 모든 옵션을 갖춘 데스크톱 애플리케이션을 갖고 있습니다. 아래 이미지는 일상적으로 사용할 수 있는 가장 중요한 화면을 보여줍니다.\n\nDocker Desktop과 유사하게, 이 앱은 컨테이너, 이미지 및 볼륨에 대한 메뉴를 갖고 있어 쉽게 작업을 수행할 수 있습니다.\n\n![Switching to Podman: an Open-Source alternative to Docker](/assets/img/2024-05-18-SwitchingtoPodmananOpen-SourcealternativetoDocker_3.png)\n\n\n<div class=\"content-ad\"></div>\n\n![Switching to Podman: an Open-Source Alternative to Docker](/assets/img/2024-05-18-SwitchingtoPodmananOpen-SourcealternativetoDocker_4.png)\n\n![Switching to Podman: an Open-Source Alternative to Docker](/assets/img/2024-05-18-SwitchingtoPodmananOpen-SourcealternativetoDocker_5.png)\n\n이미지만 봐도 이해하기 쉬울 거에요. 궁금한 점 있으면 댓글로 남겨주세요.\n\n참고: Podman Desktop을 설치하면 가상 머신이 로그인 시 시작하도록 설정을 변경할 수 있습니다. 이렇게 하면 매번 podman machine start를 실행할 필요가 없어요.\n\n<div class=\"content-ad\"></div>\n\n개발자로서 제 생각이에요. 아마도 당신에게는 Podman이 모든 필요를 충족시키지 못할 수도 있어요. 그러나 제 일상 사용에는 충분하고, 지금까지 어떤 문제도 만나지 않았어요.\n\n요약하면, Podman은 Docker에 대한 강력한 대안으로, 안전하고 가벼운 실행 환경, Docker와 유사한 명령줄 인터페이스, 데몬이 필요하지 않은 macOS 및 Linux 배포판에서 실행할 수 있는 기능과 같은 많은 이점을 제공해요. Docker 대체품을 찾고 있다면, Podman은 분명히 확인할 가치가 있어요.\n\n이 글이 도움이 되었으면 좋겠어요!","ogImage":{"url":"/assets/img/2024-05-18-SwitchingtoPodmananOpen-SourcealternativetoDocker_0.png"},"coverImage":"/assets/img/2024-05-18-SwitchingtoPodmananOpen-SourcealternativetoDocker_0.png","tag":["Tech"],"readingTime":5},{"title":"쿠버네티스와 커널 패닉","description":"","date":"2024-05-18 17:35","slug":"2024-05-18-KubernetesAndKernelPanics","content":"\n\n넷플릭스의 컨테이너 플랫폼이 리눅스 커널 패닉을 쿠버네티스 파드로 연결하는 방법\n\n카일 앤더슨\n\n최근에는 컨테이너 플랫폼 Titus에서 엔지니어(최종 사용자가 아닌)의 고통을 줄이기 위한 노력이 있었습니다. 나는 \"고아\" 파드를 조사하기 시작했습니다. 완료되지 못한 파드들로, 만족스럽지 못한 최종 상태로 가비지 컬렉션되어야 했습니다. 우리의 서비스 작업(ReplicatSet같이 생각하십시오) 소유자들은 그리 심하게 신경쓰지 않지만, 우리의 배치 사용자들은 신경을 많이 씁니다. 실제로 반환 코드가 없다면, 다시 시도해도 안전한지 아닌지 어떻게 알 수 있을까요?\n\n이러한 고아 파드들은 시스템 전체 파드 중 소수지만 사용자들에게 진짜 고통을 미칩니다. 정확히 어디로 가는 것인가요? 왜 사라졌나요?\n\n<div class=\"content-ad\"></div>\n\n이 블로그 포스트는 최악의 시나리오인 커널 패닉부터 Kubernetes(k8s)까지 연결하여 마침내 우리 운영자들이 우리의 k8s 노드가 왜 어떻게 사라지는지 추적할 수 있도록 안내하는 방법을 보여줍니다.\n\n# 유랑된 Pod들은 어디에서 왔을까요?\n\n유랑된 Pod들은 기본 k8s 노드 객체가 사라지기 때문에 분실됩니다. 그렇게 되면 GC 프로세스가 Pod를 삭제합니다. Titus에서는 Pod 및 Node 객체의 이력을 저장해 사용자들에게 설명을 제공할 수 있도록하는 사용자 지정 컨트롤러를 실행합니다. 우리의 UI에서 이러한 실패 모드는 다음과 같이 보입니다:\n\n![이미지](/assets/img/2024-05-18-KubernetesAndKernelPanics_0.png)\n\n<div class=\"content-ad\"></div>\n\n이 설명은 설득력이 부족했나봐요. 에이전트가 어디로 사라졌는지 궁금하죠?\n\n# 잃어버린 노드는 어디서 왔을까요?\n\n노드는 어떤 이유로든 사라질 수 있어요, 특히 \"클라우드\"에서 말이죠. 그럴 때는 일반적으로 클라우드 벤더에 의해 제공되는 k8s 클라우드 컨트롤러가 실제 서버, 이 경우에는 EC2 인스턴스,가 실제로 없어졌다는 것을 감지하고, 이에 따라 k8s 노드 객체를 삭제할 거에요. 그래도 \"왜\"라는 질문에 정말로 대답하지 못하겠죠.\n\n우리는 어떻게 해야 할까요? 모든 사라진 인스턴스에 이유를 부여하고, 그 이유를 감안하며, 이것을 포드까지 전달할 수 있을까요? 이 모든 것은 주석에서 시작돼요:\n\n<div class=\"content-ad\"></div>\n\n```js\n{\n     \"apiVersion\": \"v1\",\n     \"kind\": \"Pod\",\n     \"metadata\": {\n          \"annotations\": {\n               \"pod.titus.netflix.com/pod-termination-reason\": \"Something really bad happened!\",\n...\n```\n\n이 데이터를 넣을 수 있는 장소를 만드는 것만으로도 좋은 시작이에요. 이제 우리의 GC 컨트롤러들이 이 주석을 인식하도록 만들고, 예기치 못하게 파드나 노드를 종료시킬 수 있는 어떠한 프로세스에도 이를 뿌리는 것만 하면 돼요. 상태를 수선하는 대신 주석을 추가함으로써 기록 목적을 위해 파드의 나머지 부분을 그대로 유지할 수 있어요. (종료 이유를 나타내기 위해 종료한 것에 대한 주석을 추가합니다)\n\npod-termination-reason 주석은 다음과 같은 인간이 읽을 수 있는 메시지를 작성하는 데 유용해요:\n\n- “이 파드는 더 높은 우선 순위 작업($id)에 의해 예약 해제되었습니다”\n- “이 파드는 하부 하드웨어의 장애($failuretype)로 종료되어야 했습니다”\n- “$user가 노드에서 sudo halt 명령을 실행했기 때문에 이 파드를 종료해야 했습니다”\n- “하부 노드 커널이 패닉 상태에 빠져 이 파드가 예기치 않게 종료되었습니다!”\n  \n\n<div class=\"content-ad\"></div>\n\n하지만 기다려봐, 커널 패닉에 빠진 노드에 대한 팟을 어떻게 주석 처리할 수 있을까요?\n\n# 커널 패닉 캡처\n\n리눅스 커널이 패닉에 빠지면 할 일이 별로 없어요. 하지만 만약 \"마지막 숨통으로 커버네티스에 저주를 내립니다!\"라는 UDP 패킷을 보낼 수 있다면 어떨까요?\n\nGoogle Spanner 논문에서 영감을 받아 Spanner 노드가 리스 및 락을 해제하기 위해 \"마지막 끼통\" UDP 패킷을 보내는 것처럼, 당신도 주식 리눅스 모듈인 netconsole을 사용하여 커널 패닉 시 서버를 설정할 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n# 넷콘솔 설정\n\n리눅스 커널이 심각한 상황에서 UDP 패킷을 '커널 패닉' 문자열과 함께 전송할 수 있다는 사실은 정말 놀랍죠. 이는 netconsole이 사전에 거의 모든 IP 헤더가 채워진 상태로 구성되어 있어야 한다는 것 때문에 가능합니다. 맞아요, Linux에게 소스 MAC, IP, UDP 포트 및 대상 MAC, IP, UDP 포트를 정확히 알려주어야 합니다. 특히, 커널을 위한 UDP 패킷을 거의 만들어 주는 것과 같죠. 그러나 그 전 작업을 해두면 시간이 지나면서 커널이 쉽게 패킷을 구성하고 (미리 구성된) 네트워크 인터페이스를 통해 전송할 수 있습니다. 다행히 netconsole-setup 명령어를 통해 설정을 간단히 할 수 있습니다. 모든 구성 옵션은 동적으로 설정할 수 있어서, 대상이 변경되면 새 IP로 바로 가리킬 수 있습니다.\n\n이 설정을 하면 모듈 로딩 후 커널 메시지가 즉시 흐르기 시작합니다. 마치 dmesg | netcat -u $대상 6666와 같이 전체 프로세스가 커널 공간에서 작동하는 것을 상상해보세요.\n\n# 넷콘솔 \"마지막 발악\" 패킷\n\n<div class=\"content-ad\"></div>\n\nnetconsole을 설정하면, 충돌하는 커널로 인한 마지막 노후는 예상대로 UDP 패킷 세트처럼 보입니다. UDP 패킷의 데이터는 간단히 커널 메시지의 텍스트입니다. 커널 패닉인 경우, 다음과 같이 보일 것입니다 (한 줄에 하나의 UDP 패킷):\n\n```js\nKernel panic - not syncing: buffer overrun at 0x4ba4c73e73acce54\n[ 8374.456345] CPU: 1 PID: 139616 Comm: insmod Kdump: loaded Tainted: G OE\n[ 8374.458506] Hardware name: Amazon EC2 r5.2xlarge/, BIOS 1.0 10/16/2017\n[ 8374.555629] Call Trace:\n[ 8374.556147] <TASK>\n[ 8374.556601] dump_stack_lvl+0x45/0x5b\n[ 8374.557361] panic+0x103/0x2db\n[ 8374.558166] ? __cond_resched+0x15/0x20\n[ 8374.559019] ? do_init_module+0x22/0x20a\n[ 8374.655123] ? 0xffffffffc0f56000\n[ 8374.655810] init_module+0x11/0x1000 [kpanic]\n[ 8374.656939] do_one_initcall+0x41/0x1e0\n[ 8374.657724] ? __cond_resched+0x15/0x20\n[ 8374.658505] ? kmem_cache_alloc_trace+0x3d/0x3c0\n[ 8374.754906] do_init_module+0x4b/0x20a\n[ 8374.755703] load_module+0x2a7a/0x3030\n[ 8374.756557] ? __do_sys_finit_module+0xaa/0x110\n[ 8374.757480] __do_sys_finit_module+0xaa/0x110\n[ 8374.758537] do_syscall_64+0x3a/0xc0\n[ 8374.759331] entry_SYSCALL_64_after_hwframe+0x62/0xcc\n[ 8374.855671] RIP: 0033:0x7f2869e8ee69\n...\n```\n\n# 쿠버네티스에 접속\n\n마지막 단계는 쿠버네티스(k8s)에 연결하는 것입니다. 다음을 수행하는 k8s 컨트롤러가 필요합니다:\n\n<div class=\"content-ad\"></div>\n\n- 포트 6666에서 netconsole UDP 패킷을 수신하여 노드에서 발생하는 커널 패닉처럼 보이는 것을 감시합니다.\n- 커널 패닉 발생 시, 들어오는 netconsole 패킷의 IP 주소와 관련된 k8s 노드 객체를 찾습니다.\n- 해당 k8s 노드에서 바인딩된 모든 팟을 찾아서 주석을 추가한 후 해당 팟을 삭제합니다 (팟이 다 녹아버리겠군요!).\n- 해당 k8s 노드에 노드 주석을 추가한 다음 노드도 삭제합니다 (노드도 다 녹아버리겠군요!).\n\n1부 및 2부는 다음과 같이 보일 수 있습니다:\n\n```js\nfor {\n    n, addr, err := serverConn.ReadFromUDP(buf)\n    if err != nil {\n        klog.Errorf(\"Error ReadFromUDP: %s\", err)\n    } else {\n        line := santizeNetConsoleBuffer(buf[0:n])\n        if isKernelPanic(line) {\n            panicCounter = 20\n            go handleKernelPanicOnNode(ctx, addr, nodeInformer, podInformer, kubeClient, line)\n        }\n    }\n    if panicCounter > 0 {\n        klog.Infof(\"KernelPanic context from %s: %s\", addr.IP, line)\n        panicCounter++\n    }\n}\n```\n\n그리고 3부와 4부는 다음과 같이 보일 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nfunc handleKernelPanicOnNode(ctx context.Context, addr *net.UDPAddr, nodeInformer cache.SharedIndexInformer, podInformer cache.SharedIndexInformer, kubeClient kubernetes.Interface, line string) {\n    node := getNodeFromAddr(addr.IP.String(), nodeInformer)\n    if node == nil {\n        klog.Errorf(\"Got a kernel panic from %s, but couldn't find a k8s node object for it?\", addr.IP.String())\n    } else {\n        pods := getPodsFromNode(node, podInformer)\n        klog.Infof(\"Got a kernel panic from node %s, annotating and deleting all %d pods and that node.\", node.Name, len(pods))\n        annotateAndDeletePodsWithReason(ctx, kubeClient, pods, line)\n        err := deleteNode(ctx, kubeClient, node.Name)\n        if err != nil {\n            klog.Errorf(\"Error deleting node %s: %s\", node.Name, err)\n        } else {\n            klog.Infof(\"Deleted panicked node %s\", node.Name)\n        }\n    }\n}\n```\n\n위 코드를 넣으면 커널 패닉이 감지되자마자 pod와 노드가 즉시 사라집니다. 어떤 GC 프로세스를 기다릴 필요가 없습니다. 주석은 노드 및 pod에 무슨 일이 일어났는지 문서화하는 데 도움이 됩니다:\n\n<img src=\"/assets/img/2024-05-18-KubernetesAndKernelPanics_1.png\" />\n\n# 결론\n\n\n<div class=\"content-ad\"></div>\n\n작업이 커널 패닉 때문에 실패했다는 것을 고객님에게 알리는 것은 만족스럽지 않을 수도 있습니다. 그러나 커널 패닉을 해결하기 위해 필요한 관측 도구를 갖추게 된 사실에 기쁨을 느끼실 수 있을 거예요!\n\n시스템에서 왜 실패하는 지 정말로 깊이 파악하는 것이 즐거우셨나요? 혹은 커널 패닉이 멋지게 느껴지시나요? 저희 Compute 팀에 참여해 주세요. 저희는 엔지니어들을 위한 세계적 수준의 컨테이너 플랫폼을 구축 중이에요.","ogImage":{"url":"/assets/img/2024-05-18-KubernetesAndKernelPanics_0.png"},"coverImage":"/assets/img/2024-05-18-KubernetesAndKernelPanics_0.png","tag":["Tech"],"readingTime":7},{"title":"Samba를 사용하여 CIFS 파일 시스템 유형을 이용해 공유 폴더를 마운트하는 방법","description":"","date":"2024-05-18 17:34","slug":"2024-05-18-HowtoMountaSharedFolderUsingSambawithCIFSFilesystemType","content":"\n\n안녕하세요! 이 튜토리얼에서는 Linux 시스템에서 올바른 파일 시스템 유형(cifs)을 사용하여 Samba를 사용하여 호스트 머신의 공유 폴더를 마운트하는 단계를 살펴볼 것입니다.\n\n# 단계 1: Samba 공유 설정\n\nSamba 설치: 먼저 호스트 머신에 Samba를 설치합니다:\n\n```js\nsudo apt update\nsudo apt install samba\n```\n\n<div class=\"content-ad\"></div>\n\nSamba 구성: Samba 구성 파일을 편집하세요:\n\n```js\nsudo vim /etc/samba/smb.conf\n```\n\n파일의 끝에 다음 라인을 추가하세요:\n\n```js\n[shared_folder]\npath = /공유할/폴더/경로\nwritable = yes\nguest ok = yes\n```\n\n<div class=\"content-ad\"></div>\n\n# 단계 2: 필요한 패키지 설치\n\n시스템에 cifs-utils 패키지가 설치되어 있는지 확인하세요. 패키지 관리자를 사용하여 설치할 수 있습니다:\n\n```js\nsudo apt update\nsudo apt install cifs-utils\n```\n\n# 단계 3: 호스트 머신의 IP 주소 찾기\n\n<div class=\"content-ad\"></div>\n\n다음 명령을 사용하여 호스트 머신의 IP 주소를 찾을 수 있습니다:\n\n```js\nip addr show | grep inet | grep -v 127.0.0.1 | awk '{print $2}' | cut -d'/' -f1\n```\n\n이 명령은 호스트 머신의 IP 주소를 출력합니다.\n\n# 4단계: 마운트 포인트 만들기\n\n<div class=\"content-ad\"></div>\n\n공유 폴더를 마운트할 디렉토리를 생성해보세요. 예를 들어, 홈 디렉토리에 shared_folder라는 디렉토리를 만들어봅시다:\n\n```js\nmkdir ~/shared_folder\n```\n\n# 단계 5: 공유 폴더 마운트하기\n\n마운트 명령을 사용하여 공유 폴더를 마운트하세요. host_ip를 호스트 머신의 IP 주소로, shared_folder_name을 공유 폴더의 이름으로 대체하세요:\n\n<div class=\"content-ad\"></div>\n\n```js\nsudo mount -t cifs //호스트IP/공유폴더명 ~/공유폴더 -o guest\n```\n\n만약 공유 폴더에 인증이 필요하다면 사용자 이름과 비밀번호를 제공할 수도 있어요:\n\n```js\nsudo mount -t cifs //호스트IP/공유폴더명 ~/공유폴더 -o username=당신의사용자이름,password=당신의비밀번호\n```\n\n# 단계 6: 마운트 확인하기\n\n<div class=\"content-ad\"></div>\n\n공유된 폴더가 올바르게 마운트되었는지 확인하려면 마운트 지점 디렉터리의 내용을 나열하여 확인해보세요:\n\n```js\nls ~/shared_folder\n```\n\n이 명령을 실행하면 공유된 폴더의 내용이 나열됩니다.\n\n# 단계 7: 파일 접근 및 수정\n\n<div class=\"content-ad\"></div>\n\n이제 로컬 머신에서 공유 폴더의 파일에 직접 액세스하고 수정할 수 있어요.\n\n# 단계 8: 공유 폴더에서 마운트 해제하기 (선택 사항)\n\n공유 폴더 작업을 완료했을 때 umount 명령을 사용하여 마운트를 해제할 수 있어요:\n\n```js\nsudo umount ~/shared_folder\n```\n\n<div class=\"content-ad\"></div>\n\n# 단계 9: 자동 마운트 (선택 사항)\n\n시스템 부팅할 때마다 공유 폴더를 자동으로 마운트하려면 /etc/fstab 파일에 항목을 추가할 수 있습니다.\n\n```js\n//host_ip/shared_folder_name  /home/your_username/shared_folder  cifs  guest  0  0\n```\n\n호스트 IP, 공유 폴더 이름 및 /home/your_username/shared_folder를 세팅에 맞는 적절한 값으로 교체해주세요.\n\n<div class=\"content-ad\"></div>\n\n위 항목을 추가한 후 시스템을 재부팅하거나 다음과 같이 수동으로 공유 폴더를 마운트할 수 있습니다:\n\n```js\nsudo mount -a\n```\n\n끝났어요! 이제 올바른 파일 시스템 유형(cifs)을 사용하여 Samba를 통해 공유 폴더를 마운트했습니다. 이제 공유 폴더의 파일에 액세스하고 필요에 따라 작업할 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-18-HowtoMountaSharedFolderUsingSambawithCIFSFilesystemType_0.png"},"coverImage":"/assets/img/2024-05-18-HowtoMountaSharedFolderUsingSambawithCIFSFilesystemType_0.png","tag":["Tech"],"readingTime":3},{"title":"원격 액세스 보안하는 방법 SSH 키 사용 안내","description":"","date":"2024-05-18 17:32","slug":"2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys","content":"\n\nSSH 키 기반 인증을 사용하여 SSH 연결을 안전하게 하는 단계별 가이드\n\n![SSH Key-Based Authentication](/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_0.png)\n\n오늘의 글은 SSH 원격 세션의 보안을 강화하는 간단한 자습서를 제공합니다. Linux 서버에 SSH 키 기반 인증을 설정하는 방법에 중점을 두고 덜 안전한 암호 기반 인증에서 전환하는 방법을 안내합니다. 마지막으로 SSH 서버를 더 안전하게 하는 추가 방법에 대한 보너스 팁을 공유할 것입니다.\n\n# 개요\n\n<div class=\"content-ad\"></div>\n\nSSH (Secure Shell) 키 기반 인증은 원격 서버에서 사용자의 신원을 인증하기 위해 암호화 키 쌍을 사용하는 보안 방법입니다. 이 방법은 컴퓨터에 공개 및 비밀 키 쌍을 생성하여 저장하고, SSH 서버를 구성하여 이러한 키를 인식하고 수락하도록 설정하는 것을 포함합니다. 이는 기존 암호 기반 인증과 관련된 위험을 줄이는 것으로 보안을 크게 향상시킵니다.\n\nSSH 키는 쌍으로 생성되고 일반 텍스트 파일로 저장됩니다. 키 쌍은 두 부분으로 구성됩니다:\n\n- 🔒 공개 키: 이 부분은 SSH 서버에 저장됩니다. 안전하게 공유할 수 있어 해당 서버가 연결할 때 신원을 인식할 수 있습니다.\n- 🔑 비밀 키: 이 부분은 사용자의 컴퓨터에 저장되어야 하며 항상 안전하게 보관되어야 합니다. 이를 사용하여 서버와 인증하며, 절대로 공유해서는 안 됩니다. 비밀 키는 파일을 읽을 수 없도록 사용 권한을 설정해야 합니다.\n\n## 작동 방식\n\n<div class=\"content-ad\"></div>\n\n- 컴퓨터에서 공개 및 개인 키 쌍을 생성합니다.\n- 서버는 공개 키를 인식하고 해당하는 개인 키가 인증 중에 사용되면 액세스를 허용하도록 구성됩니다.\n- 선택적으로 개인 키에 암호를 설정하여 추가 보안을 제공할 수 있습니다. 이 암호는 잘못된 손에 키가 넘어갈 경우 추가 보호층을 제공합니다.\n\n# SSH 키를 사용한 인증의 장점\n\nSSH 키 기반 인증은 비밀번호보다 더 나은 대안이므로 보안성과 편리성이 강화됩니다. 이렇게 왜 SSH 키를 사용해야 하는지 살펴보겠습니다:\n\n- 향상된 보안: 키가 고유하고 추측하기 어려우므로 키 기반 인증은 브루트 포스 공격에 저항합니다.\n- 자격 증명 노출 위험 감소: 서버가 침해당한 경우 권한 부여 자격 증명이 노출되는 위험이 없습니다.\n- 사용의 용이성: 사용자들은 복잡한 암호를 기억하거나 적어두지 않아도 되므로, 암호 관련 위반 사례의 위험이 줄어듭니다.\n- 자동화 지원: 암호 입력이 필요하지 않기 때문에 작업을 자동화할 수 있으며, 수동 개입 없이 Ansible과 같은 스크립트 및 도구가 SSH 서버와 상호작용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# SSH를 위한 공개 키 인증 설정하기\n\n기본 사항을 다뤘으니, 이 작업을 완료하는 단계에 대해 자세히 살펴보겠습니다.\n\nSSH 키 쌍을 만드는 두 가지 옵션이 있습니다: Windows 기계 또는 Linux 기계에서. 단계는 일반적으로 비슷하지만, 각 환경에서 사용하는 소프트웨어 도구는 다릅니다.\n\n## 방법 1: Linux에서 SSH 키 쌍 생성하기\n\n<div class=\"content-ad\"></div>\n\n스텝 1: Ed25519 알고리즘을 사용하여 새 SSH 키 쌍을 생성하세요.\n\n이 단계는 키페어를 로컬 컴퓨터에서 생성한 후에 나중에 서버로 업로드할 것으로 가정합니다. 서버에서 키페어를 생성하고 개인 키를 로컬 호스트로 다운로드하는 것보다 안전합니다.\n\nEd25519 알고리즘을 사용하여 새 키 쌍을 생성하세요:\n\n```js\nssh-keygen -t ed25519 -C \"cybersecmav@warfare.systems\"\n```\n\n<div class=\"content-ad\"></div>\n\n- -t: 알고리즘의 종류 (키), 우리의 경우 Ed25519.\n- -C: SSH 키를 구분할 수 있도록 도와주는 설명 (선택 사항).\n\n파일 이름을 요구하면 기본 이름과 경로를 수락하려면 Enter 키를 누르세요. SSH 키는 일반적으로 ~/.ssh/ 디렉터리에 저장됩니다.\n\n![이미지](/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_1.png)\n\n단계 2: 원격 서버 준비하기\n\n<div class=\"content-ad\"></div>\n\n만약 ~/.ssh 디렉토리와 authorized_keys 파일이 존재하지 않는다면 다음을 실행해주세요:\n\n```js\nmkdir ~/.ssh\ntouch ~/.ssh/authorized_keys\n```\n\n~/.ssh 디렉토리에 위치한 authorized_keys 파일은 SSH 서버에 액세스할 수 있는 공개 키 목록을 포함하고 있습니다.\n\n~/.ssh 디렉토리와 authorized_keys 파일에 적절한 파일 권한을 설정해주세요:\n\n<div class=\"content-ad\"></div>\n\n```js\nchmod 700 ~/.ssh\nchmod 600 ~/.ssh/authorized_keys\n```\n\n- chmod 700 ~/.ssh: 해당 디렉토리의 파일을 읽기, 쓰기, 실행할 수 있는 권한을 소유자에게만 부여합니다.\n- chmod 600 ~/.ssh/authorized_keys: 소유자에게만 파일에 액세스할 수 있도록 제약을 두어 다른 사람이 파일을 보거나 수정하는 것을 방지하여 SSH 키를 보호합니다.\n\n로컬 머신에서 공개 키를 원격 서버로 업로드하세요:\n\n```js\nscp id_ed2551.pub cybersecmav@warfare.systems:/home/cybersecmav/id_ed2551.pub\n```  \n\n<div class=\"content-ad\"></div>\n\n아래와 같이 업로드한 공개 키를 .ssh/ 디렉터리로 이동해 주세요:\n\n```js\nmv id_ed2551.pub ~/.ssh/\nchmod 600 ~/.ssh/id_ed2551.pub\n```\n\n공개 키의 출력을 authorized_keys 파일로 복사해 주세요:\n\n```js\ncat ~/.ssh/id_ed2551.pub >> ~/.ssh/authorized_keys\n```\n\n<div class=\"content-ad\"></div>\n\nauthorized_keys의 내용을 확인하여 공개 키가 추가되었는지 확인해보세요:\n\n```js\ncat .ssh/authorized_keys\nssh-ed25519 AAA<<...REDACTED......>>1uEqXysh cybersecmav@warfare.systems\n```\n\n모든 올바른 폴더 및 파일 권한이 있는지 확인해봅시다:\n\n```js\ncybersecmav@ares:~$ cd .ssh\ncybersecmav@ares:~/.ssh$ ls -la\ntotal 16\ndrwx------ 2 cybersecmav cybersecmav 4096 Apr 26 14:32 .\ndrwxr-xr-x 5 cybersecmav cybersecmav 4096 Apr 29 13:32 ..\n-rw------- 1 cybersecmav cybersecmav  109 Apr 26 14:33 authorized_keys\n-rw-r--r-- 1 cybersecmav cybersecmav  109 Apr 23 19:49 id_ed2551.pub\n```\n\n<div class=\"content-ad\"></div>\n\nStep 3: 공개 키 인증을 지원하도록 SSH 서버 구성하기\n\n편집을 위해 SSH 서버 구성 파일을 엽니다:\n\n```js\nsudo nano /etc/ssh/sshd_config\n```\n\nPubkeyAuthentication 설정을 찾아서 아래로 스크롤합니다. \"no\"에서 \"yes\"로 변경하세요. 또한, AuthorizedKeysFile로 시작하는 줄이 주석 처리되어 있지 않은지 확인하거나 누락된 경우 추가하세요.\n\n<div class=\"content-ad\"></div>\n\n```plaintext\nPubkeyAuthentication yes\nAuthorizedKeysFile .ssh/authorized_keys .ssh/authorized_keys2\n```\n\n다음은 /etc/sshd_config 파일이 보이는 방식입니다:\n\n![2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_2.png](/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_2.png)\n\n4단계: 구성 변경을 적용하기 위해 SSH 서버를 다시로드하세요\n\n\n<div class=\"content-ad\"></div>\n\nsshd_config 파일을 변경할 때는 변경 사항이 적용되려면 SSH 서버를 다시로드하거나 다시 시작해야 합니다.\n\nDebian/Ubuntu:\n\n```js\nsudo systemctl reload ssh\nsudo systemctl restart ssh\n````\n\nRedhat/CentOS:\n\n<div class=\"content-ad\"></div>\n\n```js\nsudo systemctl reload sshd\nsudo systemctl restart sshd\n```\n\n## 방법 2: Windows에서 SSH 키 쌍 생성\n\n로컬 머신으로 Windows를 사용하고 있다면, PuTTY 클라이언트의 키 생성기인 puttygen.exe를 사용하여 SSH 키 쌍을 생성할 수 있습니다.\n\n- 다음 위치에서 PuTTY를 다운로드하세요: https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html\n- puttygen.exe를 엽니다. 기본적으로 RSA를 키 생성으로 선택하지만, 원격 SSH 서버가 지원하는 경우 ED25519를 선택할 수도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_3.png\" />\n\n- \"Generate\"를 클릭하여 새로운 공개/개인 키 쌍을 생성합니다.\n\n<img src=\"/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_4.png\" />\n\n- 나중에 원격 서버의 ~/.ssh/ 디렉토리의 authorized_keys 파일에 붙여 넣을 공개 키를 복사합니다.\n\n<div class=\"content-ad\"></div>\n\n\n![image](/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_5.png)\n\n- Save the public key as: id_ed2551.pub\n- Save the private key as: id_ed2551.ppk\n\n![image](/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_6.png)\n\n- Alternatively, you can save them using the File menu option\n\n\n<div class=\"content-ad\"></div>\n\n\n![Save and keep a copy of your SSH keys](/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_7.png)\n\n![SSH key image 2](/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_8.png)\n\n![SSH key image 3](/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_9.png)\n\n\n<div class=\"content-ad\"></div>\n\n- `/home/username/.ssh/authorized_keys` 파일에 공개 키 값을 새 줄에 붙여 넣으세요.\n\n![Step 10](/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_10.png)\n\n- 윈도우즈에서 PuTTY SSH 클라이언트를 사용하여 키 기반 인증을 통한 원격 호스트로의 SSH 연결을 테스트합니다.\n- putty.exe 클라이언트를 열고 원격 SSH 서버 세부 정보를 입력하세요.\n\n![Step 11](/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_11.png)\n\n<div class=\"content-ad\"></div>\n\n- 지금 가장 중요한 단계는 리모트 서버에 연결하기 전에 방금 생성한 올바른 개인 키를 선택했는지 확인하는 것입니다.\n\n![SSH Key](/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_12.png)\n\n- \"Open\"을 클릭하면 원격 대상과의 SSH 세션이 열립니다.\n\n- 이제 새로운 공개/개인 키 쌍을 사용하여 인증된 SSH 세션이 열려 있어야 합니다. 아래 예시를 확인해주세요.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_13.png\" />\n\n이제 SSH 키 기반 인증으로 로그인되었습니다.\n\n# 추가 정보: SSH 서버 보안 팁\n\nSSH 키 기반 인증의 기본 사항을 다룬 이제, SSH 서버를 보다 더 보호하기 위한 몇 가지 추가 보안 팁을 살펴봅시다. 이러한 모범 사례를 시행함으로써 SSH 서버의 보안성을 높일 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 팁 1: 비밀번호 인증 비활성화\n\nSSH 키 기반 인증이 작동하는지 확인한 후, SSH 구성 파일인 /etc/ssh/sshd_config에서 PasswordAuthentication을 \"no\"로 설정하여 비밀번호 기반 로그인을 비활성화하세요.\n\n```sh\nsudo nano /etc/ssh/sshd_config\n``` \n\n![이미지](/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_14.png)\n\n<div class=\"content-ad\"></div>\n\n## 팁 2: 루트 로그인 제한\n\nSSH를 통한 직접적인 루트 액세스를 방지하려면 PermitRootLogin을 \"no\"로 설정하세요. 이렇게 하면 사용자가 루트 계정으로 로그인하는 것이 불가능해지며 관리 작업을 위해 sudo를 사용해야 합니다.\n\n![이미지](/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_15.png)\n\n## 팁 3: 비표준 SSH 포트 사용\n\n<div class=\"content-ad\"></div>\n\n기본 SSH 포트를 22에서 더 높거나 보통과 다른 숫자로 변경하면 무분별한 자동 스캔 및 브루트포스 공격이 더 어려워질 수 있습니다. 이는 위협의 대부분을 이루는 것입니다. 그러나 SSH 서버를 모든 공격으로부터 완전히 보호하는 것은 아니라는 것을 명심하세요. 결정적인 해커는 여전히 SSH 포트를 찾아내고 대상으로 삼을 수 있습니다.\n\n![Image](/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_16.png)\n\n## 팁 4: SSH 로깅 및 모니터링 활성화\n\nSSH 로깅이 활성화되어 있어야 연결 시도를 추적하고 이상한 활동을 감지할 수 있습니다. 무단 액세스나 브루트포스 공격의 징후를 탐지하기 위해 로그를 정기적으로 모니터링하세요.\n\n<div class=\"content-ad\"></div>\n\n대부분의 시스템에서 SSH 로깅은 기본적으로 활성화되어 있습니다. 그러나 SSH 설정 파일 /etc/ssh/sshd_config을 확인하여 비활성화되어 있지 않은지 확인해보세요.\n\n단계 1: SSH 서비스 구성 파일에서 SSH 로깅 활성화하기\n\nSyslogFacility를 \"AUTH\"로 설정하고 LogLevel은 \"INFO\"로 설정하세요.\n\n![이미지](/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_17.png)\n\n<div class=\"content-ad\"></div>\n\n다른 로그 레벨을 탐색하려면 아래 섹션을 참조하세요. Verbose 및 Debug는 많은 로그를 생성하므로 진단 또는 디버깅에만 유용하기 때문에 권하지 않습니다.\n\nSSH 로그 레벨\n\n- QUIET: 거의 아무것도 로그하지 않아 최소한의 출력을 제공합니다.\n- FATAL: SSH 서버 작동을 중지하는 중요한 오류만 로그합니다.\n- ERROR: 중요한 문제 및 심각한 오류를 로그합니다.\n- INFO: 기본 레벨로, SSH 작업에 대한 일반 정보를 로깅합니다.\n- VERBOSE: SSH 프로세스에 대한 자세한 정보를 로그하며, 문제 해결에 유용합니다.\n- DEBUG: 디버깅을 위한 방대한 로그를 생성하며, 일반적으로 일상적으로 사용하지 않습니다.\n\n단계 2: 로그 저장소 구성\n\n<div class=\"content-ad\"></div>\n\n보통 SSH 로그는 /var/log/auth.log (Debian/Ubuntu) 또는 /var/log/secure (Red Hat/CentOS)에 저장됩니다.\n\n```js\n$ ls -la /var/log/auth.log\n-rw-r----- 1 root adm 292525 May 4 10:18 /var/log/auth.log\n```\n\n이 파일들이 존재하고 접근 가능한지 확인하세요. 소유자가 root로 설정되어 있고 파일 권한이 로그 파일을 안전하게 보호하기 위해 적절하게 설정되었는지 확인하세요.\n\n```js\nchmod 640 /var/log/auth.log\n```\n\n<div class=\"content-ad\"></div>\n\n## 팁 5: 침입 탐지 (Fail2ban) 구현하기\n\nFail2Ban은 로그인 시도를 모니터링하고 많은 실패한 시도 후 IP 주소를 차단하여 SSH 서버를 보호할 수 있습니다. 이는 브루트포스 공격의 일반적인 징후입니다. 설치한 후에는 SSH 로그를 주시하도록 설정하고 의심스러운 IP를 차단할 규칙을 구성하세요. SSH 서버의 보안에 추가적인 방어층을 더하는 효과적인 방법입니다.\n\nFail2Ban을 설정하고 구성하는 것은 이 글의 범위를 벗어납니다. 그러나 추가 보안을 위해 서버에 설치하는 것을 적극 추천합니다.\n\n# 결론\n\n<div class=\"content-ad\"></div>\n\n이 기사에서는 SSH 키 기반 인증의 혜택을 다루었는데, 이를 통해 보안을 강화하고 브루트포스 공격의 위험을 줄일 수 있다는 점을 강조했습니다. SSH 키를 생성하고 서버에 구성하는 방법을 안내하며 적절한 보안을 유지하는 방법을 보여드렸습니다. 또한 SSH 서버를 안전하게 유지하기 위한 추가 팁을 살펴봤는데, 이에는 기본 포트 변경, Fail2Ban 구현, 그리고 철저한 SSH 로깅 및 모니터링 활성화가 포함되었습니다.\n\n전체적으로 SSH 키 기반 인증은 원격 액세스를 보다 안전하고 편리하게 관리하는 방법을 제공합니다. 패스워드 기반 로그인의 효과적인 대체제로서, 미인가된 액세스 가능성을 줄이고 보안을 희생하지 않고 자동화가 가능합니다.\n\n권장 사항으로는 개인 키에 항상 암호를 설정하고, 이상한 활동을 정기적으로 모니터링하며, 키 기반 설정에 확신을 갖게 되면 패스워드 인증을 비활성화하는 것을 고려해야 합니다. Fail2Ban을 구현하면 브루트포스 공격의 징후를 보이는 IP 주소를 차단하여 자동화된 보호층을 추가할 수 있습니다.\n\n이러한 단계를 따라가면 안전하고 신뢰할 수 있는 SSH 설정으로 나아갈 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이 안내서를 통해 함께해 주셔서 감사합니다. SSH 연결을 안전하게 유지하고 서버를 안전하게 보호하는 데 도움이 되었으면 좋겠습니다! 🔐\n\n안전 유지하시고 보안 유지하시길 바랍니다!\n\nCyberSecMaverick\n\n![Guide Image](/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_18.png)","ogImage":{"url":"/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_0.png"},"coverImage":"/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_0.png","tag":["Tech"],"readingTime":11},{"title":"라이오닉실적으로는 죽지 않는 노트북","description":"","date":"2024-05-18 17:30","slug":"2024-05-18-TheLaptopThatWontDie","content":"\n\n<img src=\"/assets/img/2024-05-18-TheLaptopThatWontDie_0.png\" />\n\n위에 있는 노트북?\n\n그것은 내가 소유한 가장 튼튼하고 멈추지 않고 멀쩡한 컴퓨터야.\n\n정말 멈추지 않아요.\n\n<div class=\"content-ad\"></div>\n\n그거에 대해서 전체 포스트를 쓸 건데, 간단하게 말하자면...\n\n현대식이고 섹시하며 가벼운 고성능 노트북을 원한다면? Apple이나 Microsoft에서 비싼 녀석을 사세요.\n\n하지만 거의 돈을 들이지 않고 해가 폭발할 때까지 계속 작동하는 걸 원한다면?\n\n오래된 중고 Thinkpad을 사세요.\n\n<div class=\"content-ad\"></div>\n\n그럼 이 문장을 번역해 보겠습니다.\n\n분석해보겠습니다...\n\n하드웨어 이야기는 일주일 전, 맥북 프로에서 작업하던 때 시작되었다.\n\n2017년에 사온 제 주요 노트북인데요. Logic Pro(인류에게 제일 좋은 음악 편집 소프트웨어)가 돌아가는 a) 머신이 필요했고, b) 시력이 좋지 않아 고해상도 화면이 필요했으며, c) 1테라바이트 하드 드라이브가 필요했어요. 그 조건에 맞는 유일한 머신이었습니다.\n\n엄청 비싼 물건이긴 했지만, 노트북을 살 때 목표는 수년 동안 사용할 수 있을 만큼 훌륭한 품질의 것을 사는 것이에요. 전자 폐기물도 싫어해서 노트북을 수리해서 가능한 한 오래 사용하려고 노력해요. 2010년에 첫 맥북 프로를 샀었는데, 총 7년 이용했어요 — 중간에 고장 난 메인보드도 교체했는데, 전세계 3년 보증기간이 끝나기 전에 다행히 수리해줬어요. 그래서 비용 지불할 필요 없이 해결했답니다! 호호.\n\n<div class=\"content-ad\"></div>\n\n이 더 새로운 2017 맥북 프로? 예전에 수리를 몇 번 받기도 했어요. 사고로 물에 물려서 내부 작업이 필요했었죠. 버터플라이 키보드가 고장 나자 바꿔야 했고, 배터리도 두 번이나 교체했어요.\n\n하지만 6년이 지나도 여전히 잘 돌아가고 있었어요!\n\n지난 주에 갑자기 고장 나기 전까지 말이죠.\n\n맥북에서 작업하고 있었고, 점심 때 리드를 닫았어요. 15분 후 다시 열어보니 기계가 꺼져 있었어요. 내가 뭘 해도 살려낼 수가 없었어요.\n\n<div class=\"content-ad\"></div>\n\n자전거를 타고 현지 노트북 수리소에 가져다 놓았어요. 수 시간 후, 기술자가 무슨 일이 벌어졌는지 알려주기 위해 문자 메시지를 보냈어요. 아무래도 로직 보드에 전기 단락이 있었나 보다: “배터리와 통신하는 칩이 결함이 있는 것 같습니다,” 라고 썼어요. 그 칩이 로직 보드의 납땜된 일부라는 점에서, 해결책은 완전 새 메인보드를 설치하는 것이었어요. 부품과 인건비를 합친 비용이 충분히 높아서 — 이 기기가 이전에 고장났던 일들을 고려하면 — 그를 수리하는 것은 추천하지 않는다고 했어요.\n\n동의했죠. 6년이 지난 후 마침내 새로운 맥북 프로를 사기로 결정했어요. (a), b), c)의 요구 사항은 아직이고, 맥북 프로가 세 가지를 모두 충족하는 가장 좋은 방법이기 때문이에요.\n\n(그 죽은 맥북은, 대신에 예비로서 보관하기 위해 대체 메인보드를 구입하고 직접 고치려고 할지도 몰라. 노트북 수리에 대해 나름 능숙하지만, 이들 현대 맥북은 산업적 얇음의 복잡한 예시라서, 망칠 수도 있어요. 기회를 볼게요!)\n\n한편, 내 새 노트북을 주문할 준비를 하면서요?\n\n<div class=\"content-ad\"></div>\n\n휴대용 기계가 필요해요.\n\n그래서 제 집에 있는 유일하게 망가지지 않는 컴퓨팅 장비를 꺼냈어요.\n\n그 위에 보이는 그 고대의 Thinkpad이죠.\n\n2018년에 리눅스 머신이자 백업 노트북으로 사용할 고 대아이를 원했을 때 샀어요. 그런데 돈을 많이 쓰고 싶지 않았어요.\n\n<div class=\"content-ad\"></div>\n\n\"‘테이블’ 태그를 Markdown 형식으로 변경해드릴게요.\"\n\n<div class=\"content-ad\"></div>\n\n12살이라니 생각하면 이 기계는 정말 빠르게 작동합니다. SSD 하드 드라이브와 오래된 시스템에 부드럽게 작용하는 리눅스 덕분이죠. 어플리케이션이 내 맥북에서 하는 것과 같이 빠르게 열리고 닫히죠.\n\n아마도 이 Thinkpad에서 느린 오래된 CPU에 부담을 주는 일을 하고 있지는 않습니다. 게임을 하지 않고 있고, 비디오 편집도 음악 편집도 플러그인이 가득한 것도 하고 있지 않습니다. (그럼에도 Audacity를 사용하여 가벼운 오디오 편집은 꽤 잘되었답니다.)\n\n이 노트북에 대해 할 수 있는 최악의 말은 무거워요. 게다가 화면 해상도가 낮고 흐릿한데요, 저같은 안구가 안 좋은 사람에게는 좋지 않습니다. \n\n하지만, 웹에서 작업을 하는 데 기본적인 기계가 필요하다면, 비디오 통화하기 (Zoom, Microsoft Teams, 많은 리눅스 전용 비디오 채팅이 아주 잘 됩니다), 음악 듣기, Discord 사용하기? 그럼 완벽합니다.\n\n<div class=\"content-ad\"></div>\n\n가장 중요한 것은, 이 기계는 부숴지지 않는 것 같아요.\n\n저는 이 기계를 소유한 지 여러 해가 되었지만, 아직까지 물리적으로 손상된 부분이 없어요. 매번 내부를 열어보면, ThinkPad는 완벽하게 작동해요. 이 기계는 제 첫째 아들이 여섯 살일 때 만들어졌어요; 그 아이는 성인이 되어 대학에 입학했지만, 이 노트북은 아직도 2011년에 만들어진 것처럼 마치 새 것처럼 훌륭한 상태로 사용 중이에요. 지난 십이 년 동안, 우리 네 명 가족은 알 수 없는 수많은 노트북과 전자 기기를 사용해 왔어요 — 그 중 많은 것들이 결국 망가지거나 고장이 났거나 멈추거나 초자연적인 현상이 발생했지만요. 그런데 이건 불굴의 의지로 계속 작동해요. 멈출 기미가 없어요.\n\n솔직히 말하자면, 이 기계를 주력으로 사용하고 있진 않아요. 그렇게 한다면, 어떤 부분이 옛날에 고장 났을지도 모르겠어요.\n\n하지만… 많은 사람들이 이 노트북이 만들어진 지 오래되었음에도 불구하고, 옛날부터 오랫동안 자신의 주력 노트북으로 사용해 왔어요. 그리고 그 중 많은 기계들은 여전히 잘 작동하죠. 저가 최근 Mastodon에서 내 T420를 언급했을 때, 몇몇 사람들이 동일 연식의 ThinkPad를 사용 중이며, 모두 완벽하게 작동한다고 언급했어요.\n\n<div class=\"content-ad\"></div>\n\n옛날 노트북 Thinkpad들? 진짜로 탱크처럼 튼튼하게 만들어졌어요.\n\n그래서 결론은 뭐냐면? 저렴한 머신이 필요하다면, 중고로 구입하는 예전 Thinkpad을 사세요. 일반적으로 Craigslist에서 쉽게 찾을 수 있어요. 무료로 Linux를 설치할 수 있고, 요즘 대부분의 사람들이 하는 거의 모든 일들이 브라우저에서 처리되기 때문에, Linux를 사용하는 것은 이제 매우 간단해졌어요. (이에 대해 작년에도 블로그에 글을 썼답니다.)\n\n지금 하나 사면, 평생 동안 소유할 수도 있을 거예요.\n\n(이 내용이 마음에 들었다면? 그럼 트랙패드나 마우스를 꺼내서 \"박수\" 버튼을 찾아 클릭하세요! 독자 당 최대 50번 클랩이 가능하답니다.)\n\n<div class=\"content-ad\"></div>\n\n매주 두 번 미디엄에 글을 올리고 있어요. 제 이메일로 각 포스트를 받아보시려면 여기를 팔로우해주세요!\n\n저는 뉴욕 타임스 매거진과 와이어드(Wired)에 기고하는 작가이자 \"Coders\" 저자입니다. 마스토돈(Mastodon)이나 인스타그램(Instagram)에서도 저를 팔로우하거나 원하는 만큼 결제하는 뉴스레터 \"The Linkfest\"에 가입해주세요. 이것은 \"둠스크롤링의 반대\"라고 합니다.","ogImage":{"url":"/assets/img/2024-05-18-TheLaptopThatWontDie_0.png"},"coverImage":"/assets/img/2024-05-18-TheLaptopThatWontDie_0.png","tag":["Tech"],"readingTime":4},{"title":"유닉스 리눅스에서 ls 명령어 해부하기","description":"","date":"2024-05-18 17:28","slug":"2024-05-18-DemystifyingthelsCommandinUnixLinux","content":"\n\nls 명령어의 기능을 간소화했어요.\n\n작은 이야기가 먼저!!!!\n\n3년 넘게 매일 리눅스 시스템과 함께 일했어요. 로봇처럼 생각 없이 과제를 수행했죠. 셸 스크립트와 Python 코드를 사용해서 자동화 작업을 했어요. 그러나 2024년 1월 29일, 어떤 명령어들이 작동하는 방식에 대한 호기심을 자극하는 문제를 마주했어요. 이 호기심은 명령어들이 어떻게 내부적으로 작동하는지 고려해보지 않은 저에게 놀라운 충격이었어요.\n\n누군가는 이 깨달음이 당연히 느껴질 수도 있겠지만, 제게는 진정한 성장의 순간이에요. 이 블로그를 지나치게 복잡하게 만들기보다, 현재 배우고 있는 것에 집중하고 싶어요. 저는 발견하는 모든 새로운 사실을 문서화하기로 결심했어요.\n\n<div class=\"content-ad\"></div>\n\n제가 마주한 문제에 대해 이해하기 쉽게 설명하기 위해 나중 게시물에서 더 자세히 다룰 예정입니다. 여기서 설명하는 것이 가장 좋은 방법이 아닐 수 있으니 말이죠. 이제 첫 학습 경험을 향해 나아가 봅시다.\n\n# 그럼... 시작해봅시다!!\n\n설명에 따르면... Unix/Linux에서 ls Command 해석하기\n\n```js\nsilentstorm29@cloudmaniac ~ % ls -larth\n```\n\n<div class=\"content-ad\"></div>\n\n\n![image](/assets/img/2024-05-18-DemystifyingthelsCommandinUnixLinux_0.png)\n\n이게 일반적으로 우리가 사용하는 거잖아요??\n\nls 명령어는 Unix 및 Unix와 유사한 운영 체제의 중요한 요소입니다. 이 명령 줄 유틸리티는 디렉토리의 내용을 나열하는데, 보다 많은 기능을 제공합니다. 파일 및 디렉토리의 속성을 보기 위한 다양한 옵션을 제공하는데, 이는 권한, 소유권, 크기 및 수정 시간을 포함합니다.\n\n# ls 명령어의 힘을 발휘하기\n\n\n<div class=\"content-ad\"></div>\n\nls 명령어는 다양한 방식으로 사용할 수 있는 다재다능한 명령어입니다:\n\n- ls: 현재 디렉토리의 파일 및 디렉토리를 나열하는 간단한 방법입니다.\n- ls -l: 자세한 목록 형식으로 파일 및 디렉토리를 공개합니다.\n- ls -a: 숨겨진 파일 및 디렉토리를 모두 보여줍니다(점으로 시작하는 파일 포함).\n- ls -lh: 파일 및 디렉토리를 크기가 사용자 친화적인 형식으로 자세한 목록 형식으로 표시합니다.\n- ls /경로/디렉토리: 특정 디렉토리의 내용을 나열합니다.\nls 명령어는 유닉스와 비슷한 환경에서 중요한 위치를 차지하며 파일 시스템 탐색과 파일 관리에 필수적입니다.\n\n# 커튼 뒤: 시스템 호출\n\n유닉스와 비슷한 운영 체제에서 ls 명령어를 실행하면 여러 시스템 호출이 발생합니다. 다음은 발생하는 마법의 간소화된 순서입니다:\n\n<div class=\"content-ad\"></div>\n\n- 쉘(예: bash 또는 zsh)은 새 프로세스, 즉 쉘 프로세스의 복제본을 생성하기 위해 fork() 시스템 호출을 사용합니다.\n- 그런 다음, 새 프로세스는 exec() 시스템 호출을 사용하여 자신의 이미지를 ls 프로그램으로 대체하고 ls 프로그램을 메모리에 로드하여 실행을 시작합니다.\n- ls 프로그램은 디렉토리 내용을 읽고 파일에 대한 정보를 가져오기 위해 여러 시스템 호출을 활용합니다. 이러한 시스템 호출에는 open(), read(), getdents(), stat(), lstat(), fstat() 등이 포함됩니다.\n- ls 프로그램은 또한 write() 시스템 호출을 사용하여 디렉토리 목록을 표준 출력(일반적으로 여러분의 터미널)에 출력합니다.\n- ls 프로그램이 작업을 완료하면 exit()를 호출하여 종료합니다. ls 프로그램이 완료될 때까지 대기했던 원래 쉘 프로세스는 wait() 시스템 호출을 통해 완료 알림을 받습니다.\n\n# 옵션, 인수, 와일드카드 마스터하기\n\nls 명령은 옵션, 인수 및 와일드카드를 사용하여 동작을 수정할 수 있도록 유연하게 설계되어 있습니다. 각 구성 요소가 작동하는 방법을 살펴보겠습니다:\n\n옵션:\n\n<div class=\"content-ad\"></div>\n\n옵션은 ls 명령어의 동작을 조절합니다. 예를 들어, -l은 자세한 형식으로 출력을 보여주고, -a는 숨겨진 파일을 포함한 모든 파일을 표시하며, -h는 파일 크기를 사람이 이해하기 쉬운 형식으로 표시합니다. ls 명령어는 이러한 옵션을 구문 분석하고 동작을 조정합니다. 이 과정에서 직접 시스템 호출을 수행하지는 않지만, 나중에 수행될 시스템 호출을 영향을 줄 수 있습니다. 예를 들어, -l 옵션은 ls가 각 파일에 대한 자세한 정보를 가져오기 위해 stat() 또는 lstat() 시스템 호출을 수행하도록 유도합니다.\n\n인수:\n\n인수는 일반적으로 ls가 작용해야 할 디렉터리 또는 파일의 이름입니다. 인수를 지정하지 않으면 ls는 현재 디렉터리의 내용을 나열합니다. 디렉터리 이름을 제공하면 해당 디렉터리의 내용을 나열합니다. 파일 이름을 제공하면 해당 파일만 표시합니다 (파일이 있는 경우). ls 명령어는 인수를 파일이나 디렉터리로 처리하여 나열합니다. 이때 인수가 디렉터리인지 파일인지 확인하기 위해 stat() 또는 lstat() 시스템 호출을 사용합니다. 디렉터리일 경우 ls는 open() 및 getdents() 시스템 호출을 사용하여 내용을 읽어옵니다.\n\n와일드카드:\n\n<div class=\"content-ad\"></div>\n\n와일드카드는 다른 문자를 대표하는 기호입니다. 가장 흔한 와일드카드는 \"*\"로, 모든 문자의 어떤 개수를 나타냅니다. 예를 들어, ls *.txt는 .txt로 끝나는 모든 파일을 나열합니다. 또 다른 흔한 와일드카드는 \"?\"로, 어떤 하나의 문자를 나타냅니다. 예를 들어, ls ?.txt는 한 글자 이름을 가지고 .txt로 끝나는 모든 파일을 나열합니다. 쉘(=ls 명령어가 아닌)은 명령이 실행되기 전 와일드카드를 확장합니다. 예를 들어 ls *.txt를 실행하면 쉘은 현재 디렉토리에 있는 모든 .txt 파일의 이름으로 *.txt를 대체합니다. 이 과정에는 디렉터리 내용을 읽기 위해 open(), getdents(), close() 시스템 호출이 필요하며, 와일드카드 패턴에 따라 파일을 필터링하기 위해 stat() 또는 lstat()을 사용할 수도 있습니다. 와일드카드 확장 후, ls 명령이 확장된 인수와 함께 실행됩니다.\n\n옵션, 인수, 와일드카드를 함께 사용하는 예시는 다음과 같습니다:\n\n```js\nsilentstorm29@cloudmaniac ~ %ls -lh *.txt\n```\n\n<img src=\"/assets/img/2024-05-18-DemystifyingthelsCommandinUnixLinux_1.png\" />\n\n<div class=\"content-ad\"></div>\n\n현재 디렉터리에서 .txt 파일을 자세한 형식으로 인간이 읽을 수 있는 파일 크기로 나열하는 이 명령어를 사용할 거에요.\n\n# 마무리!!\n\n`ls` 명령어의 내부 동작에 대해 파헤치는 것은 마술사의 마술 비밀을 발견하는 것과 같아요. 단순한 명령어가 정밀한 시스템 호출들이 조화롭게 작동하는 과정을 보는 것은 매우 흥미롭죠. 다음에 `ls`를 입력할 때 눈에 보이는 것보다 훨씬 많은 일이 벌어지고 있다는 것을 알게 될 거예요. 매일 사용하는 명령어 뒤의 마법을 계속 탐험하고 발견하세요 🔎. 질문은 댓글 섹션에서 환영합니다 — 즐거운 학습을 기대해요!\n\n<img src=\"/assets/img/2024-05-18-DemystifyingthelsCommandinUnixLinux_2.png\" />\n\n<div class=\"content-ad\"></div>\n\n잘 가!!","ogImage":{"url":"/assets/img/2024-05-18-DemystifyingthelsCommandinUnixLinux_0.png"},"coverImage":"/assets/img/2024-05-18-DemystifyingthelsCommandinUnixLinux_0.png","tag":["Tech"],"readingTime":4}],"page":"28","totalPageCount":43,"totalPageGroupCount":3,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true}