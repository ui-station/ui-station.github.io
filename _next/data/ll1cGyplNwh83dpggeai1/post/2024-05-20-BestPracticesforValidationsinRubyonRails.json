{"pageProps":{"post":{"title":"루비 온 레일즈에서의 유효성 검사를 위한 모범 사례들","description":"","date":"2024-05-20 15:52","slug":"2024-05-20-BestPracticesforValidationsinRubyonRails","content":"\n\n\n![Validation](/assets/img/2024-05-20-BestPracticesforValidationsinRubyonRails_0.png)\n\n유효성 검사는 웹 응용 프로그램 개발의 중요한 측면으로, 사용자가 입력한 데이터가 처리되거나 저장되기 전에 특정 기준을 충족시키도록 하는 것을 보장합니다. 루비 온 레일즈(Ruby on Rails)에서는 ActiveRecord의 강력한 내장 유효성 검사 메서드 덕분에 유효성 검사를 구현하기가 간단합니다. 이 기사에서는 레일즈 애플리케이션에서 유효성 검사를 구현하는 최선의 방법에 대해 안내해 드리겠습니다.\n\n# 유효성 검사의 중요성\n\n유효성 검사는 응용 프로그램의 데이터 무결성과 일관성을 보장합니다. 데이터베이스에 잘못된 데이터가 저장되는 것을 방지하여 응용 프로그램 오류, 보안 취약점 및 기타 문제가 발생하는 것을 방지합니다. 모델 수준에서 데이터를 유효성 검사함으로써 데이터 무결성 논리를 집중시킴으로써, 응용 프로그램을 유지 보수 가능하고 안전하게 만듭니다.\n\n\n<div class=\"content-ad\"></div>\n\n# 일반적인 유효성 검증\n\n루비 온 레일즈는 모델을 유효성 검증하는 데 사용할 수 있는 다양한 내장 유효성 검증 도우미를 제공합니다. 여기에는 일반적으로 사용되는 몇 가지가 있습니다:\n\n1. **Presence(존재)**: 필드가 비어있지 않은지 확인합니다.\n\n```js\nvalidates :name, presence: true\n```\n\n<div class=\"content-ad\"></div>\n\n독특성: 값이 테이블 전체에서 고유한지 확인합니다.\n\n```js\nvalidates :email, uniqueness: true\n```\n\n형식: 정규 표현식을 사용하여 필드가 특정 형식에 일치하는지 확인합니다.\n\n```js\nvalidates :email, format: { with: URI::MailTo::EMAIL_REGEXP }\n```\n\n<div class=\"content-ad\"></div>\n\n숫자 정합성: 필드가 숫자임을 보장하고 숫자 제약 조건을 유효성 검사할 수도 있습니다.\n\n```js\nvalidates :age, numericality: { only_integer: true, greater_than: 0 }\n```\n\n# 유효성 검사 구현을 위한 모범 사례\n\n## 내장된 유효성 검사기 사용\n\n<div class=\"content-ad\"></div>\n\n가능한 한 Rails의 내장 유효성 검사기를 활용하세요. 이들은 테스트를 거친 상태이며 다양한 일반적인 유효성 검사 요구사항을 다룹니다. 내장 유효성 검사기를 사용하면 코드가 더 읽기 쉽고 유지보수하기 쉬워집니다.\n\n```js\nclass User < ApplicationRecord\n  validates :email, presence: true, uniqueness: true, format: { with: URI::MailTo::EMAIL_REGEXP }\nend\n```\n\n## 사용자 정의 유효성 검사\n\n내장 도우미로 다루기 어려운 복잡한 유효성 검사 로직이 필요한 경우, 사용자 정의 유효성 검사 메서드를 작성할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```ruby\nclass User < ApplicationRecord\n  validate :password_complexity\n\n  def password_complexity\n    return if password.blank? || password =~ /(?=.*\\d)(?=.*[a-z])(?=.*[A-Z])/\n\n    errors.add :password, 'must include at least one lowercase letter, one uppercase letter, and one digit'\n  end\nend\n```\n\n## 조건부 유효성 검사\n\n가끔 필드를 특정 조건에서만 유효성을 검사해야 할 때가 있습니다. Rails에서는 :if와 :unless 옵션을 통해 이를 쉽게 할 수 있습니다.\n\n```ruby\nclass User < ApplicationRecord\n  validates :ssn, presence: true, if: :adult?\n\n  def adult?\n    age >= 18\n  end\nend\n```\n\n<div class=\"content-ad\"></div>\n\n## 유효성 검사 및 데이터베이스 제약조건\n\nActiveRecord 유효성 검사는 강력하지만 애플리케이션 수준에서만 실행됩니다. 중요한 유효성 검사의 경우, 데이터베이스 수준에서도 제약조건을 강제하세요. 이렇게 하면 두 겹의 보호막이 제공됩니다.\n\n```js\n# 마이그레이션\nadd_index :users, :email, unique: true\n```\n\n## 지나치게 유효성 검사 피하기\n\n<div class=\"content-ad\"></div>\n\n너무 많은 유효성 검사를 하지 않도록 주의해주세요. 지나치게 엄격한 유효성 검사는 사용자에게 답답한 경험을 줄 수 있습니다. 필요한 유효성 검사를 실행하고 사용자에게 의미 있는 피드백을 제공해 주세요.\n\n## 오류 메시지\n\n사용자 친화적인 오류 메시지를 표시해 주세요. 기본 오류 메시지는 최종 사용자에게는 너무 기술적일 수 있습니다.\n\n```js\nclass User < ApplicationRecord\n  validates :username, presence: { message: \"빈 칸일 수 없습니다\" }\nend\n```\n\n<div class=\"content-ad\"></div>\n\n## 유효성 검사 테스트\n\n언제나 유효성 검사에 대한 테스트를 작성하세요. 이렇게 함으로써 해당 기능이 예상대로 작동하는지 확인할 수 있으며, 미래의 회귀 사항을 방지할 수 있습니다.\n\n```ruby\n# spec/models/user_spec.rb\nrequire 'rails_helper'\n\nRSpec.describe User, type: :model do\n  it '유효한 이메일로 유효성이 유효해야 합니다' do\n    user = User.new(email: 'user@example.com')\n    expect(user).to be_valid\n  end\n\n  it '이메일이 없으면 유효하지 않아야 합니다' do\n    user = User.new(email: nil)\n    user.valid?\n    expect(user.errors[:email]).to include(\"can't be blank\")\n  end\n\n  it '중복된 이메일로는 유효하지 않아야 합니다' do\n    User.create!(email: 'user@example.com')\n    user = User.new(email: 'user@example.com')\n    user.valid?\n    expect(user.errors[:email]).to include('has already been taken')\n  end\nend\n```\n\n## 결론\n\n<div class=\"content-ad\"></div>\n\n테이블 태그를 Markdown 형식으로 변경하세요.","ogImage":{"url":"/assets/img/2024-05-20-BestPracticesforValidationsinRubyonRails_0.png"},"coverImage":"/assets/img/2024-05-20-BestPracticesforValidationsinRubyonRails_0.png","tag":["Tech"],"readingTime":4},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    img: \"img\",\n    h1: \"h1\",\n    ol: \"ol\",\n    li: \"li\",\n    strong: \"strong\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\",\n    h2: \"h2\",\n    div: \"div\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-20-BestPracticesforValidationsinRubyonRails_0.png\",\n        alt: \"Validation\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"유효성 검사는 웹 응용 프로그램 개발의 중요한 측면으로, 사용자가 입력한 데이터가 처리되거나 저장되기 전에 특정 기준을 충족시키도록 하는 것을 보장합니다. 루비 온 레일즈(Ruby on Rails)에서는 ActiveRecord의 강력한 내장 유효성 검사 메서드 덕분에 유효성 검사를 구현하기가 간단합니다. 이 기사에서는 레일즈 애플리케이션에서 유효성 검사를 구현하는 최선의 방법에 대해 안내해 드리겠습니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"유효성 검사의 중요성\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"유효성 검사는 응용 프로그램의 데이터 무결성과 일관성을 보장합니다. 데이터베이스에 잘못된 데이터가 저장되는 것을 방지하여 응용 프로그램 오류, 보안 취약점 및 기타 문제가 발생하는 것을 방지합니다. 모델 수준에서 데이터를 유효성 검사함으로써 데이터 무결성 논리를 집중시킴으로써, 응용 프로그램을 유지 보수 가능하고 안전하게 만듭니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"일반적인 유효성 검증\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"루비 온 레일즈는 모델을 유효성 검증하는 데 사용할 수 있는 다양한 내장 유효성 검증 도우미를 제공합니다. 여기에는 일반적으로 사용되는 몇 가지가 있습니다:\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"Presence(존재)\"\n        }), \": 필드가 비어있지 않은지 확인합니다.\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"validates :name, \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"presence\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"true\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"독특성: 값이 테이블 전체에서 고유한지 확인합니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"validates :email, \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"uniqueness\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"true\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"형식: 정규 표현식을 사용하여 필드가 특정 형식에 일치하는지 확인합니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"validates :email, \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"format\"\n        }), \": { \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"with\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"URI\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"MailTo\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"EMAIL_REGEXP\"\n        }), \" }\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"숫자 정합성: 필드가 숫자임을 보장하고 숫자 제약 조건을 유효성 검사할 수도 있습니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"validates :age, \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"numericality\"\n        }), \": { \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"only_integer\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"true\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"greater_than\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \" }\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"유효성 검사 구현을 위한 모범 사례\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"내장된 유효성 검사기 사용\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"가능한 한 Rails의 내장 유효성 검사기를 활용하세요. 이들은 테스트를 거친 상태이며 다양한 일반적인 유효성 검사 요구사항을 다룹니다. 내장 유효성 검사기를 사용하면 코드가 더 읽기 쉽고 유지보수하기 쉬워집니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"User\"\n        }), \" < \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ApplicationRecord\"\n        }), \"\\n  validates :email, \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"presence\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"true\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"uniqueness\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"true\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"format\"\n        }), \": { \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"with\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"URI\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"MailTo\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"EMAIL_REGEXP\"\n        }), \" }\\nend\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"사용자 정의 유효성 검사\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"내장 도우미로 다루기 어려운 복잡한 유효성 검사 로직이 필요한 경우, 사용자 정의 유효성 검사 메서드를 작성할 수 있습니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-ruby\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"User\"\n        }), \" < \", _jsx(_components.span, {\n          className: \"hljs-title class_ inherited__\",\n          children: \"ApplicationRecord\"\n        }), \"\\n  validate \", _jsx(_components.span, {\n          className: \"hljs-symbol\",\n          children: \":password_complexity\"\n        }), \"\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"def\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"password_complexity\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" password.blank? |\", _jsx(_components.span, {\n          className: \"hljs-params\"\n        }), \"| password =~ \", _jsx(_components.span, {\n          className: \"hljs-regexp\",\n          children: \"/(?=.*\\\\d)(?=.*[a-z])(?=.*[A-Z])/\"\n        }), \"\\n\\n    errors.add \", _jsx(_components.span, {\n          className: \"hljs-symbol\",\n          children: \":password\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'must include at least one lowercase letter, one uppercase letter, and one digit'\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"end\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"end\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"조건부 유효성 검사\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"가끔 필드를 특정 조건에서만 유효성을 검사해야 할 때가 있습니다. Rails에서는 \", _jsx(_components.div, {}), \"와 \", _jsx(_components.div, {}), \" 옵션을 통해 이를 쉽게 할 수 있습니다.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-ruby\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"User\"\n        }), \" < \", _jsx(_components.span, {\n          className: \"hljs-title class_ inherited__\",\n          children: \"ApplicationRecord\"\n        }), \"\\n  validates \", _jsx(_components.span, {\n          className: \"hljs-symbol\",\n          children: \":ssn\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-symbol\",\n          children: \"presence:\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"true\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-symbol\",\n          children: \"if:\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-symbol\",\n          children: \":adult?\"\n        }), \"\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"def\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"adult?\"\n        }), \"\\n    age >= \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"18\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"end\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"end\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"유효성 검사 및 데이터베이스 제약조건\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"ActiveRecord 유효성 검사는 강력하지만 애플리케이션 수준에서만 실행됩니다. 중요한 유효성 검사의 경우, 데이터베이스 수준에서도 제약조건을 강제하세요. 이렇게 하면 두 겹의 보호막이 제공됩니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"# 마이그레이션\\nadd_index :users, :email, \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"unique\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"true\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"지나치게 유효성 검사 피하기\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"너무 많은 유효성 검사를 하지 않도록 주의해주세요. 지나치게 엄격한 유효성 검사는 사용자에게 답답한 경험을 줄 수 있습니다. 필요한 유효성 검사를 실행하고 사용자에게 의미 있는 피드백을 제공해 주세요.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"오류 메시지\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"사용자 친화적인 오류 메시지를 표시해 주세요. 기본 오류 메시지는 최종 사용자에게는 너무 기술적일 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"User\"\n        }), \" < \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ApplicationRecord\"\n        }), \"\\n  validates :username, \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"presence\"\n        }), \": { \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"message\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"빈 칸일 수 없습니다\\\"\"\n        }), \" }\\nend\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"유효성 검사 테스트\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"언제나 유효성 검사에 대한 테스트를 작성하세요. 이렇게 함으로써 해당 기능이 예상대로 작동하는지 확인할 수 있으며, 미래의 회귀 사항을 방지할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-ruby\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"# spec/models/user_spec.rb\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"require\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'rails_helper'\"\n        }), \"\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"RSpec\"\n        }), \".describe \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"User\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-symbol\",\n          children: \"type:\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-symbol\",\n          children: \":model\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"do\"\n        }), \"\\n  it \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'유효한 이메일로 유효성이 유효해야 합니다'\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"do\"\n        }), \"\\n    user = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"User\"\n        }), \".new(\", _jsx(_components.span, {\n          className: \"hljs-symbol\",\n          children: \"email:\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'user@example.com'\"\n        }), \")\\n    expect(user).to be_valid\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"end\"\n        }), \"\\n\\n  it \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'이메일이 없으면 유효하지 않아야 합니다'\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"do\"\n        }), \"\\n    user = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"User\"\n        }), \".new(\", _jsx(_components.span, {\n          className: \"hljs-symbol\",\n          children: \"email:\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"nil\"\n        }), \")\\n    user.valid?\\n    expect(user.errors[\", _jsx(_components.span, {\n          className: \"hljs-symbol\",\n          children: \":email\"\n        }), \"]).to \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"include\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"can't be blank\\\"\"\n        }), \")\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"end\"\n        }), \"\\n\\n  it \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'중복된 이메일로는 유효하지 않아야 합니다'\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"do\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"User\"\n        }), \".create!(\", _jsx(_components.span, {\n          className: \"hljs-symbol\",\n          children: \"email:\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'user@example.com'\"\n        }), \")\\n    user = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"User\"\n        }), \".new(\", _jsx(_components.span, {\n          className: \"hljs-symbol\",\n          children: \"email:\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'user@example.com'\"\n        }), \")\\n    user.valid?\\n    expect(user.errors[\", _jsx(_components.span, {\n          className: \"hljs-symbol\",\n          children: \":email\"\n        }), \"]).to \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"include\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'has already been taken'\"\n        }), \")\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"end\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"end\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"결론\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"테이블 태그를 Markdown 형식으로 변경하세요.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true}