{"pageProps":{"post":{"title":"위치 기반의 위성 이미지의 시계열을 표시하는 대화형 지도 만들기","description":"","date":"2024-05-18 17:58","slug":"2024-05-18-CreateanInteractiveMaptoDisplayTimeSeriesofSatelliteImagery","content":"\n\n\n![image](/assets/img/2024-05-18-CreateanInteractiveMaptoDisplayTimeSeriesofSatelliteImagery_0.png)\n\n# Table of Contents\n\n- 🌟 Introduction\n- 📌 Area of Interest (AOI)\n- 💾 Loading Sentinel-2 Imagery\n- ⏳ Extracting Time Series from Satellite Imagery\n- 🌍 Developing an Interactive Map with Time Series\n- 📄 Conclusion\n- 📚 References\n\n## 🌟 Introduction\n\n\n<div class=\"content-ad\"></div>\n\n한동안 사용자가 특정 위치를 클릭할 때 상호작용 맵에 시계열 데이터가 표시되는 쉽고 직관적인 방법을 찾고 있었습니다. 저는 folium 라이브러리를 탐색하고 위성 이미지에서 추출한 시계열 데이터베이스를 folium과 연결하는 방법을 알아냈습니다. 오늘은 내 방법을 공유하겠습니다.\n\n이 게시물에서는 두 가지 함수를 작성할 것입니다. 첫 번째 함수는 위성 데이터를 다운로드하지 않고 로드하고, 두 번째 함수는 데이터와 타임스탬프를 추출하여 데이터 형식의 시계열을 생성합니다. 그런 다음 AOIs(관심 지역)를 순환하여 두 함수를 실행하고 AOI에 대한 시계열 데이터를 추출할 것입니다. 마지막으로 생성된 시계열 데이터와 folium 라이브러리를 사용하여 이를 상호작용적인 지도에 지리적으로 표시할 것입니다.\n\n이 게시물을 마치면 어떤 변수나 매개변수에 대해 추출된 시계열 데이터를 상호작용적인 맵과 시각적으로 표시할 수 있게 될 것입니다. 예를 들어, 캘리포니아 호수 면적의 시계열을 추출하고 상호작용적 지도에 표시하겠습니다. 그러나 흥미를 갖거나 이러한 조언과 꿀팁을 찾고 있었다면 계속 읽어보세요!\n\n## 📌 관심 지역 (AOI)\n\n<div class=\"content-ad\"></div>\n\n소개에서 언급한 대로 상호작용적 지도에서 어떤 위치의 변수에 대한 시계열 데이터를 표시하려면 다음 단계를 따를 수 있습니다. 이 예시에서는 캘리포니아의 몇 개 호수의 물 픽셀을 계수하고 2024년에 촬영된 모든 Sentinel-2 이미지를 사용하여 표면적을 계산할 것입니다. QGIS에서 그 호수 주변에 폴리곤을 그리고 그것들을 shapefile로 저장했습니다. 관심 영역 (AOI)에 대한 shapefile을 만드는 방법을 배우고 싶다면, Medium의 첫 번째 스토리에서 \"🛠️ QGIS에서 Shapefile 생성\"이라는 섹션을 참조해주세요.\n\n다음은 QGIS에서 호수 주변에 그린 폴리곤의 스냅샷입니다:\n\n![lakes](/assets/img/2024-05-18-CreateanInteractiveMaptoDisplayTimeSeriesofSatelliteImagery_1.png)\n\n## 💾 Sentinel-2 영상 불러오기\n\n<div class=\"content-ad\"></div>\n\n이 섹션의 목표는 다운로드 없이 아카이브된 위성 이미지를 메모리에 로드하는 것입니다. 특정 지역에 대한 오랜 기간에 걸친 위성 이미지 다운로드는 시간이 많이 소요되며 계산 비용이 많이 들며 비효율적일 수 있습니다. 특히 전체 장면에서 작은 영역의 변화를 탐색하려면 문제가 될 수 있습니다.\n\n이러한 문제를 극복하기 위해 12줄의 코드만 사용하여 다운로드 없이 위성 이미지를 로드하는 방법을 보여주는 포스트를 작성했습니다. 해당 포스트에서 확인할 수 있습니다.\n\n이 섹션에서는 해당 포스트에서 제시된 템플릿을 사용하여 함수를 작성할 것입니다. 이 함수를 사용하면 특정 기간에 대한 AOI 위성 이미지를 쉽게 로드할 수 있습니다. 해당 기간이 길든 짧든 상관없이:\n\n```python\nfrom pystac_client import Client\nfrom odc.stac import load\n\ndef search_satellite_images(collection=\"sentinel-2-l2a\",\n                            bbox=[-120.15,38.93,-119.88,39.25],\n                            date=\"2023-01-01/2023-03-12\",\n                            cloud_cover=(0, 10)):\n    \"\"\"\n    Collection, 범위, 날짜 범위 및 구름 덮개를 기반으로 위성 이미지를 검색합니다.\n\n    :param collection: Collection 이름 (기본값: \"sentinel-2-l2a\").\n    :param bbox: 경계 상자 [min_lon, min_lat, max_lon, max_lat] (기본값: Lake Tahoe 지역).\n    :param date: 날짜 범위 \"YYYY-MM-DD/YYYY-MM-DD\" (기본값: \"2023-01-01/2023-12-30\").\n    :param cloud_cover: 구름 덮개 범위를 나타내는 Tuple (최소, 최대) (기본값: (0, 10)).\n    :return: 검색 기준에 따라 로드된 데이터.\n    \"\"\"\n    # 검색 클라이언트 정의\n    client=Client.open(\"https://earth-search.aws.element84.com/v1\")\n    search = client.search(collections=[collection],\n                            bbox=bbox,\n                            datetime=date,\n                            query=[f\"eo:cloud_cover<{cloud_cover[1]}\", f\"eo:cloud_cover>{cloud_cover[0]}\"])\n\n    # 일치하는 항목 수 출력\n    print(f\"발견된 이미지 수: {search.matched()}\")\n\n    data = load(search.items(), bbox=bbox, groupby=\"solar_day\", chunks={})\n\n    print(f\"데이터에서의 날짜 수: {len(data.time)}\")\n\n    return data\n```\n\n<div class=\"content-ad\"></div>\n\n이 함수를 사용하면 위성 이미지 검색을 위한 매개변수를 지정할 수 있어서 다양한 관심 영역 및 시간대에 유연하고 쉽게 사용할 수 있습니다. 수집, 경계 상자, 날짜 범위 및 구름 양 등과 같은 기준에 따라 위성 이미지를 검색합니다. 이는 이미지를 찾기 위해 Earth Search API를 사용하고 일치하는 수를 출력하며 큐브 형식으로 클립 된 이미지를 반환합니다.\n\n## ⏳ 위성 영상에서 시계열 추출\n\n이제 AOI를 위해 클립 된 이미지를로드하는 함수가 있으므로 찾고있는 정보를 추출하는 두 번째 함수를 정의해야합니다. 이미지와 함께 필요한 정보를 추출하고 맵에 표시하는 다음 단계에서 사용할 수 있도록 DataFrame에 넣어 시계열 데이터베이스로 고려할 수 있습니다. 다시 한 번 필요한 데이터를 추출 할 수 있지만, 전체 캘리포니아 호수의 표면적을 볼 수있는 것이 흥미로울 것으로 생각되어 2024 년에 Sentinel-2로 촬영 된 모든 이미지에서 최근 이미지를 포함하여 주요 캘리포니아 호수의 표면적을 볼 수 있습니다.\n\n이를 위해 Sentinel-2 이미지의 씬 분류 레이어에 있는 물 픽셀로 분류 된 픽셀을 추출 할 수 있습니다. 다시 말해, 각 씬에서 물 픽셀 수를 세어야합니다. 픽셀 해상도가 10m x 10m임을 감안하면 수를 100 제곱 미터 (10m x 10m)로 곱하면 각 호수의 표면적이 나올 것입니다. 그러나 여기서는 위성에 의해 촬영 된 이미지가 각 씬에서 전체 호수를 커버하도록해야합니다. 이를 설명하기 위해 1 월 7 일과 1 월 4 일에 촬영 된 이 두 장의 이미지 중 하나에 캡처된 호수 중 하나를 살펴 보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n\n<div class=\"content-ad\"></div>\n\n```python\nimport pandas as pd\nimport numpy as np\n\ndef count_water_pixels(data,lake_id):\n    \"\"\"\n    각 시점의 Sentinel-2 SCL 데이터에서 물 픽셀 수를 계산합니다.\n\n    :param data: Sentinel-2 SCL 데이터가 포함된 xarray Dataset입니다.\n    :return: 날짜, 물 횟수 및 눈 횟수가 포함된 DataFrame입니다.\n    \"\"\"\n\n    water_counts = []\n    date_labels = []\n    water_area = []\n    coverage_ratio = []\n\n    # 시간 단계 수를 확인합니다.\n    numb_days = len(data.time)\n\n    # 각 시간 단계를 반복합니다.\n    for t in range(numb_days):\n        scl_image = data[[\"scl\"]].isel(time=t).to_array()\n        dt = pd.to_datetime(scl_image.time.values)\n        year = dt.year\n        month = dt.month\n        day = dt.day\n\n        date_string = f\"{year}-{month:02d}-{day:02d}\"\n        print(date_string)\n\n        # 물에 해당하는 픽셀 수를 계산합니다.\n        count_water = np.count_nonzero(scl_image == 6)  # 물\n\n        surface_area = count_water * 10 * 10 / (10 ** 6)\n\n        count_pixels = np.count_nonzero((scl_image == 1) | (scl_image == 2) | (scl_image == 3) | (scl_image == 4) | (\n                    scl_image == 5) | (scl_image == 6) | (scl_image == 7) | (scl_image == 8) | (scl_image == 9) | (\n                                               scl_image == 10) | (scl_image == 11))\n        total_pixels = data.dims['y'] * data.dims['x']\n\n        coverage = count_pixels * 10 * 10 / 1e6\n        lake_area = total_pixels * 10 * 10 / 1e6\n\n        ratio = coverage / lake_area\n\n        print(coverage)\n        print(lake_area)\n        print(ratio)\n\n        if ratio < 0.8:\n            continue\n\n        # 추가\n        water_counts.append(count_water)\n        date_labels.append(date_string)\n        water_area.append(surface_area)\n        coverage_ratio.append(ratio)\n\n    # 날짜 레이블을 pandas datetime 형식으로 변환합니다.\n    datetime_index = pd.to_datetime(date_labels)\n\n    # DataFrame을 구성하기 위한 딕셔너리 생성\n    data_dict = {\n        'Date': datetime_index,\n        'ID': lake_id,\n        'Water Counts': water_counts,\n        'Pixel Counts': count_pixels,\n        'Total Pixels': total_pixels,\n        'Coverage Ratio': coverage_ratio,\n        'Water Surface Area': water_area\n    }\n\n    # DataFrame 생성\n    df = pd.DataFrame(data_dict)\n\n    return df\n```\n\n이 함수는 데이터셋의 각 시간 단계를 반복하여 물 픽셀 수를 계산하고 표면적을 계산하며 커버리지 비율을 계산합니다. 커버리지 비율이 80% 미만이면 시간 단계가 건너뜁니다. 그런 다음 횟수, 날짜, 표면적 및 커버리지 비율을 리스트에 추가하고 해당 값과 물 ID 및 총 픽셀 수가 포함된 DataFrame을 반환합니다.\n\n커버리지 문제와 해결하는 속임수에 대해 자세히 알아보려면 이 포스트의 섹션 (📈 통계 파일에서 대염해 지역의 시계열)을 참조해주세요:\n\n## 🌍 시계열과 함께 상호작용하는 지도 개발하기```\n\n<div class=\"content-ad\"></div>\n\n이 섹션에서는 세 개의 스크립트를 작성할 것입니다. 첫 번째 스크립트는 다각형(AOI)의 바운딩 박스와 중심 좌표를 추출하는 함수입니다. 첫 번째 함수(search_satellite_images)를 실행하려면 바운딩 박스가 필요하며, 맵에 호수를 표시하는 데 중심 좌표가 필요합니다. 다음 코드로 이 작업을 수행할 수 있습니다:\n\n```js\nimport geopandas as gpd\nimport pandas as pd\n\ndef get_centroids_and_bboxes(shapefile_path):\n    \"\"\"\n    shapefile을 처리하여 각 다각형의 ID, 중심점, 바운딩 박스(bbox)를 포함하는 DataFrame을 반환합니다.\n    :param shapefile_path: shapefile의 경로.\n    :return: 각 다각형의 ID, 중심점, 및 bbox가 있는 pandas DataFrame.\n    \"\"\"\n\n    # shapefile 불러오기\n    gdf = gpd.read_file(shapefile_path)\n\n    # EPSG:4326으로 재투영\n    gdf_proj = gdf.to_crs(\"EPSG:4326\")\n\n    centroids = []\n    bboxes = []\n\n    # 각 다각형을 처리하여 중심점과 bbox 얻기\n    for index, row in gdf_proj.iterrows():\n        # 중심점\n        centroid_lat = row.geometry.centroid.y\n        centroid_lon = row.geometry.centroid.x\n        centroids.append((centroid_lat, centroid_lon))\n\n        # 바운딩 박스\n        minx, miny, maxx, maxy = row.geometry.bounds\n        bbox = (minx, miny, maxx, maxy)\n        bboxes.append(bbox)\n\n    # DataFrame 생성\n    df = pd.DataFrame({\n        'ID': gdf_proj.index,\n        'Centroid_Lat': [lat for lat, lon in centroids],\n        'Centroid_Lon': [lon for lat, lon in centroids],\n        'BBox_Min_Lon': [bbox[0] for bbox in bboxes],\n        'BBox_Min_Lat': [bbox[1] for bbox in bboxes],\n        'BBox_Max_Lon': [bbox[2] for bbox in bboxes],\n        'BBox_Max_Lat': [bbox[3] for bbox in bboxes]\n    })\n\n    return df\n\nshapefile_path = \"lakes_boundry.shp\"\nlakes_df = get_centroids_and_bboxes(shapefile_path)\nprint(lakes_df)\n```\n\n위 단계를 따르고 코드를 성공적으로 실행하면, 다음 형식의 다각형에 대한 유사한 DataFrame이 표시될 것입니다:\n\n<img src=\"/assets/img/2024-05-18-CreateanInteractiveMaptoDisplayTimeSeriesofSatelliteImagery_4.png\" />\n\n<div class=\"content-ad\"></div>\n\n다음 스크립트는 2024년 센티넬-2에 의해 촬영된 모든 이미지를 호수 위에서 루핑하고 두 번째 함수를 실행하여 커버리지 비율이 80%보다 높은 경우 각 이미지에서 표면적을 계산하며 각 호수의 표면적을 시계열로 보여주는 DataFrame을 보고하는 것을 포함합니다:\n\n```python\nimport matplotlib.pyplot as plt\nimport pandas as pd\nfrom datetime import datetime\nimport numpy as np\n\nall_water_pixels_dfs = [] \n\nfor lake_id in lakes_df.ID:\n    print(lake_id)\n    lake_df = lakes_df[lakes_df['ID'] == lake_id]\n\n    if not lake_df.empty:\n        bbox = [lake_df.iloc[0].BBox_Min_Lon, lake_df.iloc[0].BBox_Min_Lat,\n                lake_df.iloc[0].BBox_Max_Lon, lake_df.iloc[0].BBox_Max_Lat]\n\n        data = search_satellite_images(collection=\"sentinel-2-l2a\",\n                                       date=\"2024-01-01/2024-05-14\",\n                                       cloud_cover=(0, 5),\n                                       bbox=bbox)\n        # Pass the lake_id\n        water_pixels_df = count_water_pixels(data, lake_id)\n\n        # Append\n        all_water_pixels_dfs.append(water_pixels_df)\n\n# Concatenate all DataFrames into a single DataFrame\nfinal_df = pd.concat(all_water_pixels_dfs, ignore_index=True)\n```\n\n최종 DataFrame은 이미지 날짜, 물 픽셀 수, 총 픽셀 수, 커버리지 비율 및 표면적을 요약하여 다음과 같이 보여집니다:\n\n![이미지](/assets/img/2024-05-18-CreateanInteractiveMaptoDisplayTimeSeriesofSatelliteImagery_5.png)\n\n\n<div class=\"content-ad\"></div>\n\n거의 다 왔어요!\n\n지도 상에서 시계열을 보기 위해 마지막 한 단계가 남았습니다. 이제 표면적의 시계열 데이터가 있으므로 Folium 라이브러리를 사용하여 두 가지를 표시할 수 있습니다: (1) 지도상의 호수 중심을 지점으로 표시하고 (2) 각 호수를 클릭하면 팝업으로 표면적의 시계열을 보여주는 그래프를 표시합니다. 다음 코드로 이 작업을 수행할 수 있습니다:\n\n```js\nimport folium\nimport plotly.express as px\nimport os\n\n# 시계열 플롯을 그려 HTML로 저장하는 함수\ndef plot_timeseries_for_spot(spot_id, ts_df):\n    df_spot = ts_df[ts_df['ID'] == spot_id]\n    print(df_spot)\n    fig = px.line(df_spot, x='Date', y='Water Surface Area', title=f'Time Series for Lake {spot_id}')\n\n     # X 및 Y 축 레이블 추가\n    fig.update_layout(\n        xaxis_title=\"Date\",\n        yaxis_title=\"Water Surface Area (sq km)\"\n    )\n\n    filepath = f'tmp_{int(spot_id)}.html'\n    fig.write_html(filepath, include_plotlyjs='cdn')\n    return filepath\n\n# 지도 생성\nm = folium.Map(location=[35.5, -119.5], zoom_start=7)\n\n# Plotly 시계열 팝업이 있는 마커 추가\nfor index, row in lakes_df.iterrows():\n    html_path = plot_timeseries_for_spot(row['ID'], final_df)\n    iframe = folium.IFrame(html=open(html_path).read(), width=500, height=300)\n    popup = folium.Popup(iframe, max_width=2650)\n    folium.Marker([row['Centroid_Lat'], row['Centroid_Lon']], popup=popup).add_to(m)\n\nm.save('map_with_timeseries.html')\n\n# 임시 HTML 파일 정리\nfor spot_id in lakes_df['ID']:\n    os.remove(f'tmp_{spot_id}.html')\n```\n\n이 스크립트에서는 함수가 각 호수의 시계열 데이터를 필터링하고, Plotly를 사용하여 라인 플롯을 생성하고, 플롯을 HTML 파일로 저장합니다. 다음으로 Folium을 사용하여 지도를 초기화합니다. 그런 다음 호수 DataFrame을 반복하면서, 각 호수의 중심 좌표에 마커를 추가하고, 각 마커에 팝업을 연결하여 시계열 플롯을 표시합니다. 최종 지도는 HTML 파일로 저장됩니다. 마지막으로, Plotly 플롯에 생성된 임시 HTML 파일을 삭제하여 정리합니다.```\n\n<div class=\"content-ad\"></div>\n\n완료되었습니다!\n\n콘텐츠 폴더에 생성된 HTML 파일을 열면 지도에 표시된 각 호수의 중심 좌표를 볼 수 있습니다.\n\n![지도](/assets/img/2024-05-18-CreateanInteractiveMaptoDisplayTimeSeriesofSatelliteImagery_6.png)\n\n각 호수를 클릭하여 시계열이 표시되는지 확인해 보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n이 모든 노력 끝에 이렇게 실용적인 지도가 만들어졌네요, 맞나요? :D\n\n## 📄 결론\n\n<div class=\"content-ad\"></div>\n\n거의 매달 새로운 패키지와 라이브러리들이 나와서 데이터를 추출하고 분석하며 표시하고 시각화하는 법을 실용적으로 제공합니다. 그러나 이 분야에서 아직 남아 있는 두 가지 과제가 있습니다. 첫 번째는 데이터를 정확하게 분석하기 위해서는 테라바이트 또는 페타바이트에서 추출된 데이터가 정확한지 확인하기 위해 충분한 경험이 필요합니다. 두 번째는 이러한 라이브러리들을 연결하여 의미 있는 것을 만들어내는 아키텍처를 만드는 것입니다.\n\n이미지 처리에서는 처리된 데이터에서의 간단한 실수가 중대한 오류로 이어질 수 있는 점을 강조해보았습니다. 시각화 부분에서는 Folium, Plotly, 그리고 새로운 이미지를 추출하기 위한 API를 연결하여, 리모트 센싱 관측을 사용하여 다양한 현상을 모니터링하는 유용한 도구를 만들 수 있음을 보여주었습니다. 이 글을 읽는 데 즐거움을 느끼시기를 바라며, 궁금한 사항이 있으시면 언제든지 연락 주세요.\n\n## 📚 참고 자료\n\nhttps://github.com/stac-utils/pystac-client/blob/main/docs/quickstart.rst\n\n<div class=\"content-ad\"></div>\n\nhttps://www.element84.com/earth-search/examples/\n\nSentinel 데이터용 Copernicus Sentinel 데이터 [2024]\n\nCopernicus 서비스 정보용 Copernicus 서비스 정보 [2024]\n\n📱 더 많은 흥미로운 콘텐츠를 제공하는 다른 플랫폼에서 저와 소통하세요! LinkedIn, ResearchGate, Github 및 Twitter.\n\n<div class=\"content-ad\"></div>\n\n이 링크를 통해 확인할 수 있는 관련 게시물이 있습니다:","ogImage":{"url":"/assets/img/2024-05-18-CreateanInteractiveMaptoDisplayTimeSeriesofSatelliteImagery_0.png"},"coverImage":"/assets/img/2024-05-18-CreateanInteractiveMaptoDisplayTimeSeriesofSatelliteImagery_0.png","tag":["Tech"],"readingTime":13},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    img: \"img\",\n    h1: \"h1\",\n    ul: \"ul\",\n    li: \"li\",\n    h2: \"h2\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\",\n    div: \"div\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-18-CreateanInteractiveMaptoDisplayTimeSeriesofSatelliteImagery_0.png\",\n        alt: \"image\"\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"Table of Contents\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"🌟 Introduction\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"📌 Area of Interest (AOI)\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"💾 Loading Sentinel-2 Imagery\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"⏳ Extracting Time Series from Satellite Imagery\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"🌍 Developing an Interactive Map with Time Series\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"📄 Conclusion\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"📚 References\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"🌟 Introduction\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"한동안 사용자가 특정 위치를 클릭할 때 상호작용 맵에 시계열 데이터가 표시되는 쉽고 직관적인 방법을 찾고 있었습니다. 저는 folium 라이브러리를 탐색하고 위성 이미지에서 추출한 시계열 데이터베이스를 folium과 연결하는 방법을 알아냈습니다. 오늘은 내 방법을 공유하겠습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 게시물에서는 두 가지 함수를 작성할 것입니다. 첫 번째 함수는 위성 데이터를 다운로드하지 않고 로드하고, 두 번째 함수는 데이터와 타임스탬프를 추출하여 데이터 형식의 시계열을 생성합니다. 그런 다음 AOIs(관심 지역)를 순환하여 두 함수를 실행하고 AOI에 대한 시계열 데이터를 추출할 것입니다. 마지막으로 생성된 시계열 데이터와 folium 라이브러리를 사용하여 이를 상호작용적인 지도에 지리적으로 표시할 것입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 게시물을 마치면 어떤 변수나 매개변수에 대해 추출된 시계열 데이터를 상호작용적인 맵과 시각적으로 표시할 수 있게 될 것입니다. 예를 들어, 캘리포니아 호수 면적의 시계열을 추출하고 상호작용적 지도에 표시하겠습니다. 그러나 흥미를 갖거나 이러한 조언과 꿀팁을 찾고 있었다면 계속 읽어보세요!\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"📌 관심 지역 (AOI)\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"소개에서 언급한 대로 상호작용적 지도에서 어떤 위치의 변수에 대한 시계열 데이터를 표시하려면 다음 단계를 따를 수 있습니다. 이 예시에서는 캘리포니아의 몇 개 호수의 물 픽셀을 계수하고 2024년에 촬영된 모든 Sentinel-2 이미지를 사용하여 표면적을 계산할 것입니다. QGIS에서 그 호수 주변에 폴리곤을 그리고 그것들을 shapefile로 저장했습니다. 관심 영역 (AOI)에 대한 shapefile을 만드는 방법을 배우고 싶다면, Medium의 첫 번째 스토리에서 \\\"🛠️ QGIS에서 Shapefile 생성\\\"이라는 섹션을 참조해주세요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다음은 QGIS에서 호수 주변에 그린 폴리곤의 스냅샷입니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-18-CreateanInteractiveMaptoDisplayTimeSeriesofSatelliteImagery_1.png\",\n        alt: \"lakes\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"💾 Sentinel-2 영상 불러오기\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 섹션의 목표는 다운로드 없이 아카이브된 위성 이미지를 메모리에 로드하는 것입니다. 특정 지역에 대한 오랜 기간에 걸친 위성 이미지 다운로드는 시간이 많이 소요되며 계산 비용이 많이 들며 비효율적일 수 있습니다. 특히 전체 장면에서 작은 영역의 변화를 탐색하려면 문제가 될 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이러한 문제를 극복하기 위해 12줄의 코드만 사용하여 다운로드 없이 위성 이미지를 로드하는 방법을 보여주는 포스트를 작성했습니다. 해당 포스트에서 확인할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 섹션에서는 해당 포스트에서 제시된 템플릿을 사용하여 함수를 작성할 것입니다. 이 함수를 사용하면 특정 기간에 대한 AOI 위성 이미지를 쉽게 로드할 수 있습니다. 해당 기간이 길든 짧든 상관없이:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-python\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" pystac_client \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" Client\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" odc.stac \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" load\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"def\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"search_satellite_images\"\n        }), \"(\", _jsxs(_components.span, {\n          className: \"hljs-params\",\n          children: [\"collection=\", _jsx(_components.span, {\n            className: \"hljs-string\",\n            children: \"\\\"sentinel-2-l2a\\\"\"\n          }), \",\\n                            bbox=[-\", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"120.15\"\n          }), \",\", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"38.93\"\n          }), \",-\", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"119.88\"\n          }), \",\", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"39.25\"\n          }), \"],\\n                            date=\", _jsx(_components.span, {\n            className: \"hljs-string\",\n            children: \"\\\"2023-01-01/2023-03-12\\\"\"\n          }), \",\\n                            cloud_cover=(\", _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [_jsx(_components.span, {\n              className: \"hljs-number\",\n              children: \"0\"\n            }), \", \", _jsx(_components.span, {\n              className: \"hljs-number\",\n              children: \"10\"\n            })]\n          }), \")\"]\n        }), \"):\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\\\"\\\"\\n    Collection, 범위, 날짜 범위 및 구름 덮개를 기반으로 위성 이미지를 검색합니다.\\n\\n    :param collection: Collection 이름 (기본값: \\\"sentinel-2-l2a\\\").\\n    :param bbox: 경계 상자 [min_lon, min_lat, max_lon, max_lat] (기본값: Lake Tahoe 지역).\\n    :param date: 날짜 범위 \\\"YYYY-MM-DD/YYYY-MM-DD\\\" (기본값: \\\"2023-01-01/2023-12-30\\\").\\n    :param cloud_cover: 구름 덮개 범위를 나타내는 Tuple (최소, 최대) (기본값: (0, 10)).\\n    :return: 검색 기준에 따라 로드된 데이터.\\n    \\\"\\\"\\\"\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"# 검색 클라이언트 정의\"\n        }), \"\\n    client=Client.\", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"open\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"https://earth-search.aws.element84.com/v1\\\"\"\n        }), \")\\n    search = client.search(collections=[collection],\\n                            bbox=bbox,\\n                            datetime=date,\\n                            query=[\", _jsxs(_components.span, {\n          className: \"hljs-string\",\n          children: [\"f\\\"eo:cloud_cover<\", _jsxs(_components.span, {\n            className: \"hljs-subst\",\n            children: [\"{cloud_cover[\", _jsx(_components.span, {\n              className: \"hljs-number\",\n              children: \"1\"\n            }), \"]}\"]\n          }), \"\\\"\"]\n        }), \", \", _jsxs(_components.span, {\n          className: \"hljs-string\",\n          children: [\"f\\\"eo:cloud_cover>\", _jsxs(_components.span, {\n            className: \"hljs-subst\",\n            children: [\"{cloud_cover[\", _jsx(_components.span, {\n              className: \"hljs-number\",\n              children: \"0\"\n            }), \"]}\"]\n          }), \"\\\"\"]\n        }), \"])\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"# 일치하는 항목 수 출력\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"print\"\n        }), \"(\", _jsxs(_components.span, {\n          className: \"hljs-string\",\n          children: [\"f\\\"발견된 이미지 수: \", _jsx(_components.span, {\n            className: \"hljs-subst\",\n            children: \"{search.matched()}\"\n          }), \"\\\"\"]\n        }), \")\\n\\n    data = load(search.items(), bbox=bbox, groupby=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"solar_day\\\"\"\n        }), \", chunks={})\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"print\"\n        }), \"(\", _jsxs(_components.span, {\n          className: \"hljs-string\",\n          children: [\"f\\\"데이터에서의 날짜 수: \", _jsxs(_components.span, {\n            className: \"hljs-subst\",\n            children: [\"{\", _jsx(_components.span, {\n              className: \"hljs-built_in\",\n              children: \"len\"\n            }), \"(data.time)}\"]\n          }), \"\\\"\"]\n        }), \")\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" data\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 함수를 사용하면 위성 이미지 검색을 위한 매개변수를 지정할 수 있어서 다양한 관심 영역 및 시간대에 유연하고 쉽게 사용할 수 있습니다. 수집, 경계 상자, 날짜 범위 및 구름 양 등과 같은 기준에 따라 위성 이미지를 검색합니다. 이는 이미지를 찾기 위해 Earth Search API를 사용하고 일치하는 수를 출력하며 큐브 형식으로 클립 된 이미지를 반환합니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"⏳ 위성 영상에서 시계열 추출\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 AOI를 위해 클립 된 이미지를로드하는 함수가 있으므로 찾고있는 정보를 추출하는 두 번째 함수를 정의해야합니다. 이미지와 함께 필요한 정보를 추출하고 맵에 표시하는 다음 단계에서 사용할 수 있도록 DataFrame에 넣어 시계열 데이터베이스로 고려할 수 있습니다. 다시 한 번 필요한 데이터를 추출 할 수 있지만, 전체 캘리포니아 호수의 표면적을 볼 수있는 것이 흥미로울 것으로 생각되어 2024 년에 Sentinel-2로 촬영 된 모든 이미지에서 최근 이미지를 포함하여 주요 캘리포니아 호수의 표면적을 볼 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이를 위해 Sentinel-2 이미지의 씬 분류 레이어에 있는 물 픽셀로 분류 된 픽셀을 추출 할 수 있습니다. 다시 말해, 각 씬에서 물 픽셀 수를 세어야합니다. 픽셀 해상도가 10m x 10m임을 감안하면 수를 100 제곱 미터 (10m x 10m)로 곱하면 각 호수의 표면적이 나올 것입니다. 그러나 여기서는 위성에 의해 촬영 된 이미지가 각 씬에서 전체 호수를 커버하도록해야합니다. 이를 설명하기 위해 1 월 7 일과 1 월 4 일에 촬영 된 이 두 장의 이미지 중 하나에 캡처된 호수 중 하나를 살펴 보겠습니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-python\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" pandas \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" pd\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" numpy \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" np\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"def\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"count_water_pixels\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"data,lake_id\"\n        }), \"):\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\\\"\\\"\\n    각 시점의 Sentinel-2 SCL 데이터에서 물 픽셀 수를 계산합니다.\\n\\n    :param data: Sentinel-2 SCL 데이터가 포함된 xarray Dataset입니다.\\n    :return: 날짜, 물 횟수 및 눈 횟수가 포함된 DataFrame입니다.\\n    \\\"\\\"\\\"\"\n        }), \"\\n\\n    water_counts = []\\n    date_labels = []\\n    water_area = []\\n    coverage_ratio = []\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"# 시간 단계 수를 확인합니다.\"\n        }), \"\\n    numb_days = \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"len\"\n        }), \"(data.time)\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"# 각 시간 단계를 반복합니다.\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" t \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"range\"\n        }), \"(numb_days):\\n        scl_image = data[[\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"scl\\\"\"\n        }), \"]].isel(time=t).to_array()\\n        dt = pd.to_datetime(scl_image.time.values)\\n        year = dt.year\\n        month = dt.month\\n        day = dt.day\\n\\n        date_string = \", _jsxs(_components.span, {\n          className: \"hljs-string\",\n          children: [\"f\\\"\", _jsx(_components.span, {\n            className: \"hljs-subst\",\n            children: \"{year}\"\n          }), \"-\", _jsx(_components.span, {\n            className: \"hljs-subst\",\n            children: \"{month:02d}\"\n          }), \"-\", _jsx(_components.span, {\n            className: \"hljs-subst\",\n            children: \"{day:02d}\"\n          }), \"\\\"\"]\n        }), \"\\n        \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"print\"\n        }), \"(date_string)\\n\\n        \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"# 물에 해당하는 픽셀 수를 계산합니다.\"\n        }), \"\\n        count_water = np.count_nonzero(scl_image == \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"6\"\n        }), \")  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"# 물\"\n        }), \"\\n\\n        surface_area = count_water * \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"10\"\n        }), \" * \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"10\"\n        }), \" / (\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"10\"\n        }), \" ** \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"6\"\n        }), \")\\n\\n        count_pixels = np.count_nonzero((scl_image == \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \") | (scl_image == \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"2\"\n        }), \") | (scl_image == \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"3\"\n        }), \") | (scl_image == \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"4\"\n        }), \") | (\\n                    scl_image == \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"5\"\n        }), \") | (scl_image == \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"6\"\n        }), \") | (scl_image == \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"7\"\n        }), \") | (scl_image == \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"8\"\n        }), \") | (scl_image == \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"9\"\n        }), \") | (\\n                                               scl_image == \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"10\"\n        }), \") | (scl_image == \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"11\"\n        }), \"))\\n        total_pixels = data.dims[\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'y'\"\n        }), \"] * data.dims[\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'x'\"\n        }), \"]\\n\\n        coverage = count_pixels * \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"10\"\n        }), \" * \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"10\"\n        }), \" / \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1e6\"\n        }), \"\\n        lake_area = total_pixels * \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"10\"\n        }), \" * \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"10\"\n        }), \" / \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1e6\"\n        }), \"\\n\\n        ratio = coverage / lake_area\\n\\n        \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"print\"\n        }), \"(coverage)\\n        \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"print\"\n        }), \"(lake_area)\\n        \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"print\"\n        }), \"(ratio)\\n\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" ratio < \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.8\"\n        }), \":\\n            \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"continue\"\n        }), \"\\n\\n        \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"# 추가\"\n        }), \"\\n        water_counts.append(count_water)\\n        date_labels.append(date_string)\\n        water_area.append(surface_area)\\n        coverage_ratio.append(ratio)\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"# 날짜 레이블을 pandas datetime 형식으로 변환합니다.\"\n        }), \"\\n    datetime_index = pd.to_datetime(date_labels)\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"# DataFrame을 구성하기 위한 딕셔너리 생성\"\n        }), \"\\n    data_dict = {\\n        \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Date'\"\n        }), \": datetime_index,\\n        \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'ID'\"\n        }), \": lake_id,\\n        \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Water Counts'\"\n        }), \": water_counts,\\n        \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Pixel Counts'\"\n        }), \": count_pixels,\\n        \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Total Pixels'\"\n        }), \": total_pixels,\\n        \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Coverage Ratio'\"\n        }), \": coverage_ratio,\\n        \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Water Surface Area'\"\n        }), \": water_area\\n    }\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"# DataFrame 생성\"\n        }), \"\\n    df = pd.DataFrame(data_dict)\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" df\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 함수는 데이터셋의 각 시간 단계를 반복하여 물 픽셀 수를 계산하고 표면적을 계산하며 커버리지 비율을 계산합니다. 커버리지 비율이 80% 미만이면 시간 단계가 건너뜁니다. 그런 다음 횟수, 날짜, 표면적 및 커버리지 비율을 리스트에 추가하고 해당 값과 물 ID 및 총 픽셀 수가 포함된 DataFrame을 반환합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"커버리지 문제와 해결하는 속임수에 대해 자세히 알아보려면 이 포스트의 섹션 (📈 통계 파일에서 대염해 지역의 시계열)을 참조해주세요:\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"🌍 시계열과 함께 상호작용하는 지도 개발하기```\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 섹션에서는 세 개의 스크립트를 작성할 것입니다. 첫 번째 스크립트는 다각형(AOI)의 바운딩 박스와 중심 좌표를 추출하는 함수입니다. 첫 번째 함수(search_satellite_images)를 실행하려면 바운딩 박스가 필요하며, 맵에 호수를 표시하는 데 중심 좌표가 필요합니다. 다음 코드로 이 작업을 수행할 수 있습니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" geopandas \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" gpd\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" pandas \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" pd\\n\\ndef \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"get_centroids_and_bboxes\"\n        }), \"(shapefile_path):\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\\\"\"\n        }), _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\\n    shapefile을 처리하여 각 다각형의 ID, 중심점, 바운딩 박스(bbox)를 포함하는 DataFrame을 반환합니다.\\n    :param shapefile_path: shapefile의 경로.\\n    :return: 각 다각형의 ID, 중심점, 및 bbox가 있는 pandas DataFrame.\\n    \\\"\"\n        }), _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\\\"\"\n        }), \"\\n\\n    # shapefile 불러오기\\n    gdf = gpd.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"read_file\"\n        }), \"(shapefile_path)\\n\\n    # \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"EPSG\"\n        }), \":\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"4326\"\n        }), \"으로 재투영\\n    gdf_proj = gdf.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"to_crs\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"EPSG:4326\\\"\"\n        }), \")\\n\\n    centroids = []\\n    bboxes = []\\n\\n    # 각 다각형을 처리하여 중심점과 bbox 얻기\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" index, row \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" gdf_proj.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"iterrows\"\n        }), \"():\\n        # 중심점\\n        centroid_lat = row.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"geometry\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"centroid\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"y\"\n        }), \"\\n        centroid_lon = row.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"geometry\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"centroid\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"x\"\n        }), \"\\n        centroids.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"append\"\n        }), \"((centroid_lat, centroid_lon))\\n\\n        # 바운딩 박스\\n        minx, miny, maxx, maxy = row.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"geometry\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"bounds\"\n        }), \"\\n        bbox = (minx, miny, maxx, maxy)\\n        bboxes.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"append\"\n        }), \"(bbox)\\n\\n    # \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"DataFrame\"\n        }), \" 생성\\n    df = pd.\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"DataFrame\"\n        }), \"({\\n        \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'ID'\"\n        }), \": gdf_proj.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"index\"\n        }), \",\\n        \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Centroid_Lat'\"\n        }), \": [lat \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" lat, lon \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" centroids],\\n        \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Centroid_Lon'\"\n        }), \": [lon \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" lat, lon \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" centroids],\\n        \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'BBox_Min_Lon'\"\n        }), \": [bbox[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"] \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" bbox \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" bboxes],\\n        \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'BBox_Min_Lat'\"\n        }), \": [bbox[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"] \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" bbox \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" bboxes],\\n        \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'BBox_Max_Lon'\"\n        }), \": [bbox[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"2\"\n        }), \"] \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" bbox \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" bboxes],\\n        \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'BBox_Max_Lat'\"\n        }), \": [bbox[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"3\"\n        }), \"] \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" bbox \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" bboxes]\\n    })\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" df\\n\\nshapefile_path = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"lakes_boundry.shp\\\"\"\n        }), \"\\nlakes_df = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"get_centroids_and_bboxes\"\n        }), \"(shapefile_path)\\n\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"print\"\n        }), \"(lakes_df)\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"위 단계를 따르고 코드를 성공적으로 실행하면, 다음 형식의 다각형에 대한 유사한 DataFrame이 표시될 것입니다:\"\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/assets/img/2024-05-18-CreateanInteractiveMaptoDisplayTimeSeriesofSatelliteImagery_4.png\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다음 스크립트는 2024년 센티넬-2에 의해 촬영된 모든 이미지를 호수 위에서 루핑하고 두 번째 함수를 실행하여 커버리지 비율이 80%보다 높은 경우 각 이미지에서 표면적을 계산하며 각 호수의 표면적을 시계열로 보여주는 DataFrame을 보고하는 것을 포함합니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-python\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" matplotlib.pyplot \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" plt\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" pandas \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" pd\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" datetime \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" datetime\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" numpy \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" np\\n\\nall_water_pixels_dfs = [] \\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" lake_id \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" lakes_df.ID:\\n    \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"print\"\n        }), \"(lake_id)\\n    lake_df = lakes_df[lakes_df[\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'ID'\"\n        }), \"] == lake_id]\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"not\"\n        }), \" lake_df.empty:\\n        bbox = [lake_df.iloc[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"].BBox_Min_Lon, lake_df.iloc[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"].BBox_Min_Lat,\\n                lake_df.iloc[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"].BBox_Max_Lon, lake_df.iloc[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"].BBox_Max_Lat]\\n\\n        data = search_satellite_images(collection=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"sentinel-2-l2a\\\"\"\n        }), \",\\n                                       date=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"2024-01-01/2024-05-14\\\"\"\n        }), \",\\n                                       cloud_cover=(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"5\"\n        }), \"),\\n                                       bbox=bbox)\\n        \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"# Pass the lake_id\"\n        }), \"\\n        water_pixels_df = count_water_pixels(data, lake_id)\\n\\n        \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"# Append\"\n        }), \"\\n        all_water_pixels_dfs.append(water_pixels_df)\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"# Concatenate all DataFrames into a single DataFrame\"\n        }), \"\\nfinal_df = pd.concat(all_water_pixels_dfs, ignore_index=\", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"True\"\n        }), \")\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"최종 DataFrame은 이미지 날짜, 물 픽셀 수, 총 픽셀 수, 커버리지 비율 및 표면적을 요약하여 다음과 같이 보여집니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-18-CreateanInteractiveMaptoDisplayTimeSeriesofSatelliteImagery_5.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"거의 다 왔어요!\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"지도 상에서 시계열을 보기 위해 마지막 한 단계가 남았습니다. 이제 표면적의 시계열 데이터가 있으므로 Folium 라이브러리를 사용하여 두 가지를 표시할 수 있습니다: (1) 지도상의 호수 중심을 지점으로 표시하고 (2) 각 호수를 클릭하면 팝업으로 표면적의 시계열을 보여주는 그래프를 표시합니다. 다음 코드로 이 작업을 수행할 수 있습니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" folium\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" plotly.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"express\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" px\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" os\\n\\n# 시계열 플롯을 그려 \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"HTML\"\n        }), \"로 저장하는 함수\\ndef \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"plot_timeseries_for_spot\"\n        }), \"(spot_id, ts_df):\\n    df_spot = ts_df[ts_df[\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'ID'\"\n        }), \"] == spot_id]\\n    \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"print\"\n        }), \"(df_spot)\\n    fig = px.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"line\"\n        }), \"(df_spot, x=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Date'\"\n        }), \", y=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Water Surface Area'\"\n        }), \", title=f\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Time Series for Lake {spot_id}'\"\n        }), \")\\n\\n     # X 및 Y 축 레이블 추가\\n    fig.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"update_layout\"\n        }), \"(\\n        xaxis_title=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Date\\\"\"\n        }), \",\\n        yaxis_title=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Water Surface Area (sq km)\\\"\"\n        }), \"\\n    )\\n\\n    filepath = f\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'tmp_{int(spot_id)}.html'\"\n        }), \"\\n    fig.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"write_html\"\n        }), \"(filepath, include_plotlyjs=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'cdn'\"\n        }), \")\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" filepath\\n\\n# 지도 생성\\nm = folium.\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Map\"\n        }), \"(location=[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"35.5\"\n        }), \", -\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"119.5\"\n        }), \"], zoom_start=\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"7\"\n        }), \")\\n\\n# \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Plotly\"\n        }), \" 시계열 팝업이 있는 마커 추가\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" index, row \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" lakes_df.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"iterrows\"\n        }), \"():\\n    html_path = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"plot_timeseries_for_spot\"\n        }), \"(row[\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'ID'\"\n        }), \"], final_df)\\n    iframe = folium.\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"IFrame\"\n        }), \"(html=\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"open\"\n        }), \"(html_path).\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"read\"\n        }), \"(), width=\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"500\"\n        }), \", height=\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"300\"\n        }), \")\\n    popup = folium.\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Popup\"\n        }), \"(iframe, max_width=\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"2650\"\n        }), \")\\n    folium.\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Marker\"\n        }), \"([row[\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Centroid_Lat'\"\n        }), \"], row[\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Centroid_Lon'\"\n        }), \"]], popup=popup).\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"add_to\"\n        }), \"(m)\\n\\nm.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"save\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'map_with_timeseries.html'\"\n        }), \")\\n\\n# 임시 \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"HTML\"\n        }), \" 파일 정리\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" spot_id \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" lakes_df[\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'ID'\"\n        }), \"]:\\n    os.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"remove\"\n        }), \"(f\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'tmp_{spot_id}.html'\"\n        }), \")\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 스크립트에서는 함수가 각 호수의 시계열 데이터를 필터링하고, Plotly를 사용하여 라인 플롯을 생성하고, 플롯을 HTML 파일로 저장합니다. 다음으로 Folium을 사용하여 지도를 초기화합니다. 그런 다음 호수 DataFrame을 반복하면서, 각 호수의 중심 좌표에 마커를 추가하고, 각 마커에 팝업을 연결하여 시계열 플롯을 표시합니다. 최종 지도는 HTML 파일로 저장됩니다. 마지막으로, Plotly 플롯에 생성된 임시 HTML 파일을 삭제하여 정리합니다.```\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"완료되었습니다!\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"콘텐츠 폴더에 생성된 HTML 파일을 열면 지도에 표시된 각 호수의 중심 좌표를 볼 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-18-CreateanInteractiveMaptoDisplayTimeSeriesofSatelliteImagery_6.png\",\n        alt: \"지도\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"각 호수를 클릭하여 시계열이 표시되는지 확인해 보겠습니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"이 모든 노력 끝에 이렇게 실용적인 지도가 만들어졌네요, 맞나요? \", _jsx(_components.div, {})]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"📄 결론\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"거의 매달 새로운 패키지와 라이브러리들이 나와서 데이터를 추출하고 분석하며 표시하고 시각화하는 법을 실용적으로 제공합니다. 그러나 이 분야에서 아직 남아 있는 두 가지 과제가 있습니다. 첫 번째는 데이터를 정확하게 분석하기 위해서는 테라바이트 또는 페타바이트에서 추출된 데이터가 정확한지 확인하기 위해 충분한 경험이 필요합니다. 두 번째는 이러한 라이브러리들을 연결하여 의미 있는 것을 만들어내는 아키텍처를 만드는 것입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이미지 처리에서는 처리된 데이터에서의 간단한 실수가 중대한 오류로 이어질 수 있는 점을 강조해보았습니다. 시각화 부분에서는 Folium, Plotly, 그리고 새로운 이미지를 추출하기 위한 API를 연결하여, 리모트 센싱 관측을 사용하여 다양한 현상을 모니터링하는 유용한 도구를 만들 수 있음을 보여주었습니다. 이 글을 읽는 데 즐거움을 느끼시기를 바라며, 궁금한 사항이 있으시면 언제든지 연락 주세요.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"📚 참고 자료\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"https://github.com/stac-utils/pystac-client/blob/main/docs/quickstart.rst\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"https://www.element84.com/earth-search/examples/\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Sentinel 데이터용 Copernicus Sentinel 데이터 [2024]\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Copernicus 서비스 정보용 Copernicus 서비스 정보 [2024]\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"📱 더 많은 흥미로운 콘텐츠를 제공하는 다른 플랫폼에서 저와 소통하세요! LinkedIn, ResearchGate, Github 및 Twitter.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 링크를 통해 확인할 수 있는 관련 게시물이 있습니다:\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true}