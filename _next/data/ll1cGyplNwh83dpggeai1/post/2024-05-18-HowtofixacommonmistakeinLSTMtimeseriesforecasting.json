{"pageProps":{"post":{"title":"LSTM 시계열 예측에서 흔히 발생하는 오류를 수정하는 방법","description":"","date":"2024-05-18 19:35","slug":"2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting","content":"\r\n\r\nLSTM을 시계열 예측에 사용할 때, 사람들은 흔히 범할 수 있는 함정에 빠지곤 합니다. 이를 설명하기 위해서는 회귀자와 예측자의 작동 방식을 살펴볼 필요가 있습니다. 예측 알고리즘은 시계열 데이터를 다루는 방법을 아래와 같이 보여줍니다:\r\n\r\n\r\n![How a forecasting algorithm works](/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_0.png)\r\n\r\n\r\n한편, 회귀 문제는 다음과 같이 보일 것입니다:\r\n\r\n\r\n![How a regression problem looks](/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_1.png)\r\n\r\n\r\n<div class=\"content-ad\"></div>\r\n\r\nLSTM이 회귀기이므로 시계열을 회귀 문제로 변환해야 합니다. 이를 수행하는 여러 방법이 있지만, 이 섹션에서는 창(Window) 및 다중 단계(Multi-Step) 방법에 대해 설명하고, 어떻게 작동하는지와 특히 이를 활용할 때 발생할 수 있는 일반적인 실수를 피하는 방법에 대해 논의할 것입니다.\r\n\r\n창 방법(Window Method)에서, 시계열은 이전 각 시간 단계의 값과 결합되어 창이라고 불리는 가상 특성으로 되어 있습니다. 여기서 창 크기가 3인 창이 있습니다:\r\n\r\n![창 방법 이미지](/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_2.png)\r\n\r\n다음 함수는 단일 시계열에서 창 방법 데이터 세트를 생성합니다. 사용자는 이전 값의 수(보통 look back이라고 함)를 선택해야 합니다. 결과 데이터 세트에는 대각선 반복이 있으며, look-back 값에 따라 샘플의 수가 달라집니다:\r\n\r\n<div class=\"content-ad\"></div>\r\n\r\n```js\r\ndef window(sequences, look_back):\r\n    X, y = [], []\r\n    for i in range(len(sequences)-look_back-1):\r\n        x = sequences[i:(i+look_back)]\r\n        X.append(x)\r\n        y.append(sequences[i + look_back])\r\n    return np.array(X), np.array(y)\r\n```\r\n\r\n이제 결과를 살펴보겠습니다. 모델을 훈련한 후에는 테스트 세트에서 테스트됩니다. 다양한 소스와 튜토리얼에서는 비슷한 방법을 사용하여 결과를 컴파일하는 것을 제안했습니다. 그러나 나중에 설명할 것처럼 이 방법은 신빙성이 없습니다. 그럼 지금은 코드와 결과가 어떻게 보이는지 살펴보겠습니다:\r\n\r\n```js\r\nlook_back = 3\r\nX, y = window(ts_data, look_back)\r\n\r\n# 훈련-테스트 분할\r\ntrain_ratio = 0.8\r\ntrain_size = int(train_ratio * len(ts_data))\r\nX_train, X_test = X[:train_size-look_back], X[train_size-look_back:]\r\ny_train, y_test = y[:train_size-look_back], y[train_size-look_back:]\r\n\r\n# LSTM 모델 생성 및 훈련\r\nmodel = Sequential()\r\nmodel.add(LSTM(units=72, activation='tanh', input_shape=(look_back, 1)))\r\nmodel.add(Dense(1))\r\nmodel.compile(loss='mean_squared_error', optimizer='Adam', metrics=['mape'])\r\n\r\nmodel.fit(x=X_train, y=y_train, epochs=500, batch_size=18, verbose=2)\r\n\r\n# 예측 생성\r\nforecasts = model.predict(X_test)\r\nlstm_fits = model.predict(X_train)\r\n\r\n# 메트릭스 계산\r\nmape = mean_absolute_percentage_error(y_test, forecasts)\r\nr2 = r2_score(y_train, lstm_fits)\r\n\r\n# 날짜 초기화\r\ndate_range = pd.date_range(start='1990-01-01', end='2023-09-30', freq='M')\r\n\r\n# 맞춤 값에 원래 시계열과 맞추기 위한 비어있는 값 추가\r\nfits = np.full(train_size, np.nan)\r\nfor i in range(train_size-look_back):\r\n    fits[i+look_back] = lstm_fits[i]\r\n\r\n# 실제값, 맞춤값, 예측값 플롯\r\nplt.figure(figsize=(10, 6))\r\nplt.plot(date_range, ts_data, label='Actual', color='blue')\r\nplt.plot(date_range[:train_size], fits, label='Fitted', color='green')\r\nplt.plot(date_range[train_size:], forecasts, label='Forecast', color='red')\r\nplt.title('FSC - Short - Passengers\\nOne Step Forward Forecast')\r\nplt.xlabel('Date')\r\nplt.ylabel('Passengers')\r\nplt.legend()\r\nplt.text(0.05, 0.05, f'R2 = {r2*100:.2f}%\\nMAPE = {mape*100:.2f}%', transform=plt.gca().transAxes, fontsize=12)\r\nplt.grid(True)\r\nplt.show()\r\n```\r\n\r\n<img src=\"/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_3.png\" />\r\n\r\n\r\n<div class=\"content-ad\"></div>\r\n\r\n문제: 결과는 훌륭해 보입니다. 그러나 샘플 테스트 세트를 살펴보면 특이한 결함이 보입니다:\r\n\r\n![이미지](/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_4.png)\r\n\r\n예를 들어 y9를 생성하는 데에는 y8이 입력으로 사용되었습니다. 훈련에는 사용되지 않았지만 미래 값을 포함하는 것은 이상합니다. 왜냐하면 우리는 미래의 시점을 예측하고 있기 때문입니다.\r\n\r\n해결책: 직접적으로 이전 값을 예측 값으로 대체하는 반복적 테스트 세트를 사용하면 이 문제를 해결할 수 있습니다. 이러한 배치 방식에서 모델은 자체 예측에 기반을 둔다. 일반적인 예측 알고리즘과 유사합니다.\r\n\r\n<div class=\"content-ad\"></div>\r\n\r\n아래 루프에서 다음을 수행합니다:\r\n\r\n```js\r\n# 반복적인 예측 및 대체\r\nfor i in range(len(X_test)):\r\n    forecasts[i] = model.predict(X_test[i].reshape(1, look_back, 1))\r\n    if i != len(X_test)-1:\r\n        X_test[i+1,look_back-1] = forecasts[i]\r\n        for j in range(look_back-1):\r\n            X_test[i+1,j] = X_test[i,j+1]\r\n```\r\n\r\n결과는 완벽하지는 않지만 적어도 정허하다고 할 수 있습니다:\r\n\r\n<div class=\"content-ad\"></div>\r\n\r\n\r\n<img src=\"/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_6.png\" />\r\n\r\n다중 단계 방법은 창 방법과 유사하지만 더 많은 대상 단계를 갖습니다. 다음은 두 개의 전방 단계의 샘플입니다:\r\n\r\n<img src=\"/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_7.png\" />\r\n\r\n사실, 이 방법에서 사용자는 n_steps_in과 n_steps_out을 선택해야 합니다. 다음 코드는 단순 시계열을 다중 단계 LSTM 훈련을 위해 준비된 데이터 세트로 변환합니다:\r\n\r\n\r\n<div class=\"content-ad\"></div>\r\n\r\n```js\r\n# 단변량 시퀀스를 다단계로 샘플링하기\r\ndef split_sequences(sequences, n_steps_in, n_steps_out):\r\n X, y = list(), list()\r\n for i in range(len(sequences)):\r\n     # 해당 패턴의 끝을 찾음\r\n     end_ix = i + n_steps_in\r\n     out_end_ix = end_ix + n_steps_out\r\n     # 시퀀스를 벗어나는지 확인\r\n     if out_end_ix > len(sequences):\r\n         break\r\n     # 패턴의 입력 및 출력 부분 수집\r\n     seq_x, seq_y = sequences[i:end_ix], sequences[end_ix:out_end_ix]\r\n     X.append(seq_x)\r\n     y.append(seq_y)\r\n return np.array(X), np.array(y)\r\n```\r\n\r\n이제, 특성 뿐만 아니라 타겟도 대각선 반복을 가지고 있어 시계열과 비교하려면 그들을 평균화하거나 예측 중 하나를 선택해야 합니다. 아래 코드에서는 첫 번째, 마지막 및 평균 예측의 결과가 생성되며, 그에 이어 플롯이 제시됩니다. 여기서 첫 번째 예측은 한 달 전 예측을 의미하며, 마지막 예측은 12개월 전 예측을 의미합니다.\r\n\r\n```js\r\nn_steps_in = 12\r\nn_steps_out = 12\r\n\r\nX, y = split_sequences(ts_data, n_steps_in, n_steps_out)\r\nX = X.reshape(X.shape[0], X.shape[1], 1)\r\ny = y.reshape(y.shape[0], y.shape[1], 1)\r\n\r\n# 훈련 및 테스트 세트 분리\r\ntrain_ratio = 0.8\r\ntrain_size = int(train_ratio * len(ts_data))\r\nX_train, X_test = X[:train_size-n_steps_in-n_steps_out+1], X[train_size-n_steps_in-n_steps_out+1:]\r\ny_train = y[:train_size-n_steps_in-n_steps_out+1]\r\ny_test = ts_data[train_size:]\r\n\r\n# LSTM 모델 생성 및 훈련\r\nmodel = Sequential()\r\nmodel.add(LSTM(units=72, activation='tanh', input_shape=(n_steps_in, 1)))\r\nmodel.add(Dense(units=n_steps_out))\r\nmodel.compile(loss='mean_squared_error', optimizer='Adam', metrics=['mape'])\r\n\r\nmodel.fit(x=X_train, y=y_train, epochs=500, batch_size=18, verbose=2)\r\n\r\n# 예측 생성\r\nlstm_predictions = model.predict(X_test)\r\nlstm_fitted = model.predict(X_train)\r\n\r\nforecasts = [np.diag(np.fliplr(lstm_predictions), i).mean() for i in range(0, -lstm_predictions.shape[0], -1)]\r\nfits = [np.diag(np.fliplr(lstm_fitted), i).mean() for i in range(lstm_fitted.shape[1]+n_steps_in - 1, -lstm_fitted.shape[0], -1)]\r\nforecasts1 = lstm_predictions[n_steps_out-1:,0]\r\nfits1 = model.predict(X)[:train_size-n_steps_in,0]\r\nforecasts12 = lstm_predictions[:,n_steps_out-1]\r\nfits12 = lstm_fitted[:,n_steps_out-1]\r\n\r\n# Metric\r\nav_mape = mean_absolute_percentage_error(y_test, forecasts)\r\nav_r2 = r2_score(ts_data[n_steps_in:train_size], fits[n_steps_in:])\r\none_mape = mean_absolute_percentage_error(y_test[:-n_steps_out+1], forecasts1)\r\none_r2 = r2_score(ts_data[n_steps_in:train_size], fits1)\r\ntwelve_mape = mean_absolute_percentage_error(y_test, forecasts12)\r\ntwelve_r2 = r2_score(ts_data[n_steps_in+n_steps_out-1:train_size], fits12)\r\n \r\ndate_range = pd.date_range(start='1990-01-01', end='2023-09-30', freq='M')\r\n\r\n# 실제, 적합 결과 및 예측을 플롯\r\nplt.figure(figsize=(10, 6))\r\nplt.plot(date_range, ts_data, label='Actual', color='blue')\r\nplt.plot(date_range[:train_size], fits, label='Fitted', color='green')\r\nplt.plot(date_range[train_size:], forecasts, label='Forecast', color='red')\r\nplt.title('FSC - Short - Passengers\\n. LSTM 12 Month Average Forecast')\r\nplt.xlabel('Date')\r\nplt.ylabel('Passengers')\r\nplt.legend()\r\nplt.text(0.05, 0.05, f'R2 = {av_r2*100:.2f}%\\nMAPE = {av_mape*100:.2f}%', transform=plt.gca().transAxes, fontsize=12)\r\nplt.grid(True)\r\nplt.show()\r\n\r\nplt.figure(figsize=(10, 6))\r\nplt.plot(date_range, ts_data, label='Actual', color='blue')\r\nplt.plot(date_range[n_steps_in:train_size], fits1, label='Fitted', color='green')\r\nplt.plot(date_range[train_size:-n_steps_out+1], forecasts1, label='Forecast', color='red')\r\nplt.title('FSC - Short - Passengers\\n LSTM 1 Month in advance Forecast')\r\nplt.xlabel('Date')\r\nplt.ylabel('Passengers')\r\nplt.legend()\r\nplt.text(0.05, 0.05, f'R2 = {one_r2*100:.2f}%\\nMAPE = {one_mape*100:.2f}%', transform=plt.gca().transAxes, fontsize=12)\r\nplt.grid(True)\r\nplt.show()\r\n\r\nplt.figure(figsize=(10, 6))\r\nplt.plot(date_range, ts_data, label='Actual', color='blue')\r\nplt.plot(date_range[n_steps_in+n_steps_out-1:train_size], fits12, label='Fitted', color='green')\r\nplt.plot(date_range[train_size:], forecasts12, label='Forecast', color='red')\r\nplt.title('FSC - Short - Passengers\\n LSTM 12 Months in advance Forecast')\r\nplt.xlabel('Date')\r\nplt.ylabel('Passengers')\r\nplt.legend()\r\nplt.text(0.05, 0.05, f'R2 = {twelve_r2*100:.2f}%\\nMAPE = {twelve_mape*100:.2f}%', transform=plt.gca().transAxes, fontsize=12)\r\nplt.grid(True)\r\nplt.show()\r\n```\r\n\r\n이슈: 창 메서드와 동일한 문제가 여기에도 있습니다:```\r\n\r\n<div class=\"content-ad\"></div>\r\n\r\n\r\n![이미지](/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_8.png)\r\n\r\n해상도: 창 법과 비슷한 방법을 사용할 수 있습니다. 그러나 n_steps_out을 test_size와 동일하게 선택할 수도 있습니다. 이렇게 하면 테스트 세트가 하나로 축소됩니다:\r\n\r\n![이미지](/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_9.png)\r\n\r\n다음 함수는 이를 정확히 수행합니다. 이 함수는 시계열, 학습 크기 및 샘플 수를 사용합니다. 이 버전은 다른 예측 알고리즘과 비교할 수 있기 때문에 comparable로 이름 지었습니다:\r\n\r\n\r\n<div class=\"content-ad\"></div>\r\n\r\n```js\r\ndef split_sequences_comparable(sequences, n_samples, train_size):\r\n # 단계\r\n n_steps_out = len(sequences) - train_size\r\n n_steps_in = train_size - n_steps_out - n_samples + 1\r\n # 끝 세트\r\n X_test = sequences[n_samples + n_steps_out - 1:train_size]\r\n X_forecast = sequences[-n_steps_in:]\r\n X, y = list(), list()\r\n for i in range(n_samples):\r\n     # 이 패턴의 끝을 찾습니다\r\n     end_ix = i + n_steps_in\r\n     out_end_ix = end_ix + n_steps_out\r\n     # 패턴의 입력 및 출력 부분을 수집합니다\r\n     seq_x, seq_y = sequences[i:end_ix], sequences[end_ix:out_end_ix]\r\n     X.append(seq_x)\r\n     y.append(seq_y)\r\n return np.array(X), np.array(y), np.array(X_test), np.array(X_forecast), n_steps_in, n_steps_out\r\n```\r\n\r\n이 함수에서는 단계 수가 이미 고정되었기 때문에 샘플 수와 훈련 크기는 사용자가 선택하도록 하고, 최대 가능한 단계 수를 계산하도록 결정했습니다. 아래는 실행된 코드와 그 결과입니다:\r\n\r\n```js\r\nn_samples = 12\r\ntrain_size = 321\r\nX_train, y_train, X_test, X_forecast, n_steps_in, n_steps_out = split_sequences_comparable(ts_data, n_samples, train_size)\r\ny_test = ts_data[train_size:]\r\n\r\n# Reshaping\r\nX_train = X_train.reshape(X_train.shape[0], X_train.shape[1], 1)\r\nX_test = X_test.reshape(X_test.shape[1], X_test.shape[0], 1)\r\ny_train = y_train.reshape(y_train.shape[0], y_train.shape[1])\r\ny_test = y_test.reshape(y_test.shape[1], y_test.shape[0], 1)\r\n\r\n# LSTM 모델 생성 및 훈련\r\nmodel = Sequential()\r\nmodel.add(LSTM(units=154, activation='tanh', input_shape=(n_steps_in, 1)))\r\nmodel.add(Dense(units=n_steps_out))\r\nmodel.compile(loss='mean_squared_error', optimizer='Adam', metrics=['mape'])\r\n\r\nmodel.fit(x=X_train, y=y_train, epochs=500, batch_size=18, verbose=2)\r\n\r\n# 예측\r\nlstm_predictions = model.predict(X_test)\r\npredictions = lstm_predictions.reshape(lstm_predictions.shape[1])\r\nlstm_fitted = model.predict(X_train)\r\nfits = [np.diag(np.fliplr(lstm_fitted), i).mean() for i in range(lstm_fitted.shape[1]+n_steps_in - 1, -lstm_fitted.shape[0], -1)]\r\n\r\n# 메트릭스\r\nmape = mean_absolute_percentage_error(y_test, predictions)\r\nr2 = r2_score(ts_data[n_steps_in:train_size], fits[n_steps_in:])\r\n\r\n# 실제, 적합 및 예측 플롯\r\nplt.figure(figsize=(10, 6))\r\nplt.plot(date_range, ts_data, label='Actual', color='blue')\r\nplt.plot(date_range[:train_size], fits, label='Fitted', color='green')\r\nplt.plot(date_range[train_size:], predictions, label='Forecast', color='red')\r\nplt.title('FSC - Short - Passengers\\n12 Sample Comparable LSTM Forecast')\r\nplt.xlabel('Date')\r\nplt.ylabel('Passengers')\r\nplt.legend()\r\nplt.text(0.05, 0.05, f'R2 = {r2*100:.2f}%\\nMAPE = {mape*100:.2f}%\\', transform=plt.gca().transAxes, fontsize=12)\r\nplt.grid(True)\r\nplt.show()\r\n```\r\n\r\n<img src=\"/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_10.png\" />\r\n\r\n\r\n<div class=\"content-ad\"></div>\r\n\r\n지금까지 우리가 얻은 결과는 가장 신뢰할만한 것입니다. 그러나 제가 개발한 혁신적인 방법을 사용하면 더 나은 결과를 얻을 수 있습니다. 이 방법은 나중에 시리즈에서 (순환 방법) 자세히 설명하겠습니다. 먼저 LSTM 네트워크의 하이퍼파라미터를 조정하는 방법에 대해 설명하겠습니다.\r\n\r\nLSTM은 모든 시간 단계를 특성으로 집계하기 때문에 시계열 데이터가 모든 이러한 방법에서 손실됩니다. 나중에 시리즈에서 (인코더/디코더 방법) 시계열 입력의 구조를 유지하는 다른 방법을 사용할 것입니다.\r\n\r\n계속 주목해 주세요!","ogImage":{"url":"/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_0.png"},"coverImage":"/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_0.png","tag":["Tech"],"readingTime":12},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    img: \"img\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"LSTM을 시계열 예측에 사용할 때, 사람들은 흔히 범할 수 있는 함정에 빠지곤 합니다. 이를 설명하기 위해서는 회귀자와 예측자의 작동 방식을 살펴볼 필요가 있습니다. 예측 알고리즘은 시계열 데이터를 다루는 방법을 아래와 같이 보여줍니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_0.png\",\n        alt: \"How a forecasting algorithm works\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"한편, 회귀 문제는 다음과 같이 보일 것입니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_1.png\",\n        alt: \"How a regression problem looks\"\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"LSTM이 회귀기이므로 시계열을 회귀 문제로 변환해야 합니다. 이를 수행하는 여러 방법이 있지만, 이 섹션에서는 창(Window) 및 다중 단계(Multi-Step) 방법에 대해 설명하고, 어떻게 작동하는지와 특히 이를 활용할 때 발생할 수 있는 일반적인 실수를 피하는 방법에 대해 논의할 것입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"창 방법(Window Method)에서, 시계열은 이전 각 시간 단계의 값과 결합되어 창이라고 불리는 가상 특성으로 되어 있습니다. 여기서 창 크기가 3인 창이 있습니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_2.png\",\n        alt: \"창 방법 이미지\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다음 함수는 단일 시계열에서 창 방법 데이터 세트를 생성합니다. 사용자는 이전 값의 수(보통 look back이라고 함)를 선택해야 합니다. 결과 데이터 세트에는 대각선 반복이 있으며, look-back 값에 따라 샘플의 수가 달라집니다:\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"def \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"window\"\n        }), \"(sequences, look_back):\\r\\n    X, y = [], []\\r\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" i \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"range\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"len\"\n        }), \"(sequences)-look_back-\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"):\\r\\n        x = sequences[\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"i\"\n        }), \":(i+look_back)]\\r\\n        X.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"append\"\n        }), \"(x)\\r\\n        y.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"append\"\n        }), \"(sequences[i + look_back])\\r\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" np.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"array\"\n        }), \"(X), np.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"array\"\n        }), \"(y)\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 결과를 살펴보겠습니다. 모델을 훈련한 후에는 테스트 세트에서 테스트됩니다. 다양한 소스와 튜토리얼에서는 비슷한 방법을 사용하여 결과를 컴파일하는 것을 제안했습니다. 그러나 나중에 설명할 것처럼 이 방법은 신빙성이 없습니다. 그럼 지금은 코드와 결과가 어떻게 보이는지 살펴보겠습니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"look_back = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"3\"\n        }), \"\\r\\nX, y = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"window\"\n        }), \"(ts_data, look_back)\\r\\n\\r\\n# 훈련-테스트 분할\\r\\ntrain_ratio = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.8\"\n        }), \"\\r\\ntrain_size = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"int\"\n        }), \"(train_ratio * \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"len\"\n        }), \"(ts_data))\\r\\nX_train, X_test = X[:train_size-look_back], X[train_size-\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"look_back\"\n        }), \":]\\r\\ny_train, y_test = y[:train_size-look_back], y[train_size-\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"look_back\"\n        }), \":]\\r\\n\\r\\n# \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"LSTM\"\n        }), \" 모델 생성 및 훈련\\r\\nmodel = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Sequential\"\n        }), \"()\\r\\nmodel.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"add\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"LSTM\"\n        }), \"(units=\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"72\"\n        }), \", activation=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'tanh'\"\n        }), \", input_shape=(look_back, \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \")))\\r\\nmodel.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"add\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Dense\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"))\\r\\nmodel.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"compile\"\n        }), \"(loss=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'mean_squared_error'\"\n        }), \", optimizer=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Adam'\"\n        }), \", metrics=[\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'mape'\"\n        }), \"])\\r\\n\\r\\nmodel.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"fit\"\n        }), \"(x=X_train, y=y_train, epochs=\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"500\"\n        }), \", batch_size=\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"18\"\n        }), \", verbose=\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"2\"\n        }), \")\\r\\n\\r\\n# 예측 생성\\r\\nforecasts = model.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"predict\"\n        }), \"(X_test)\\r\\nlstm_fits = model.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"predict\"\n        }), \"(X_train)\\r\\n\\r\\n# 메트릭스 계산\\r\\nmape = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"mean_absolute_percentage_error\"\n        }), \"(y_test, forecasts)\\r\\nr2 = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"r2_score\"\n        }), \"(y_train, lstm_fits)\\r\\n\\r\\n# 날짜 초기화\\r\\ndate_range = pd.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"date_range\"\n        }), \"(start=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'1990-01-01'\"\n        }), \", end=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'2023-09-30'\"\n        }), \", freq=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'M'\"\n        }), \")\\r\\n\\r\\n# 맞춤 값에 원래 시계열과 맞추기 위한 비어있는 값 추가\\r\\nfits = np.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"full\"\n        }), \"(train_size, np.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"nan\"\n        }), \")\\r\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" i \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"range\"\n        }), \"(train_size-look_back):\\r\\n    fits[i+look_back] = lstm_fits[i]\\r\\n\\r\\n# 실제값, 맞춤값, 예측값 플롯\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"figure\"\n        }), \"(figsize=(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"10\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"6\"\n        }), \"))\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"plot\"\n        }), \"(date_range, ts_data, label=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Actual'\"\n        }), \", color=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'blue'\"\n        }), \")\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"plot\"\n        }), \"(date_range[:train_size], fits, label=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Fitted'\"\n        }), \", color=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'green'\"\n        }), \")\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"plot\"\n        }), \"(date_range[\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"train_size\"\n        }), \":], forecasts, label=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Forecast'\"\n        }), \", color=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'red'\"\n        }), \")\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"title\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'FSC - Short - Passengers\\\\nOne Step Forward Forecast'\"\n        }), \")\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"xlabel\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Date'\"\n        }), \")\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"ylabel\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Passengers'\"\n        }), \")\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"legend\"\n        }), \"()\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"text\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.05\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.05\"\n        }), \", f\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'R2 = {r2*100:.2f}%\\\\nMAPE = {mape*100:.2f}%'\"\n        }), \", transform=plt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"gca\"\n        }), \"().\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"transAxes\"\n        }), \", fontsize=\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"12\"\n        }), \")\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"grid\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"True\"\n        }), \")\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"show\"\n        }), \"()\\n\"]\n      })\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_3.png\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"문제: 결과는 훌륭해 보입니다. 그러나 샘플 테스트 세트를 살펴보면 특이한 결함이 보입니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_4.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"예를 들어 y9를 생성하는 데에는 y8이 입력으로 사용되었습니다. 훈련에는 사용되지 않았지만 미래 값을 포함하는 것은 이상합니다. 왜냐하면 우리는 미래의 시점을 예측하고 있기 때문입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"해결책: 직접적으로 이전 값을 예측 값으로 대체하는 반복적 테스트 세트를 사용하면 이 문제를 해결할 수 있습니다. 이러한 배치 방식에서 모델은 자체 예측에 기반을 둔다. 일반적인 예측 알고리즘과 유사합니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"아래 루프에서 다음을 수행합니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"# 반복적인 예측 및 대체\\r\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" i \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"range\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"len\"\n        }), \"(X_test)):\\r\\n    forecasts[i] = model.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"predict\"\n        }), \"(X_test[i].\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"reshape\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \", look_back, \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"))\\r\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" i != \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"len\"\n        }), \"(X_test)-\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \":\\r\\n        X_test[i+\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \",look_back-\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"] = forecasts[i]\\r\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" j \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"range\"\n        }), \"(look_back-\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"):\\r\\n            X_test[i+\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \",j] = X_test[i,j+\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"]\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"결과는 완벽하지는 않지만 적어도 정허하다고 할 수 있습니다:\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_6.png\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다중 단계 방법은 창 방법과 유사하지만 더 많은 대상 단계를 갖습니다. 다음은 두 개의 전방 단계의 샘플입니다:\"\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_7.png\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"사실, 이 방법에서 사용자는 n_steps_in과 n_steps_out을 선택해야 합니다. 다음 코드는 단순 시계열을 다중 단계 LSTM 훈련을 위해 준비된 데이터 세트로 변환합니다:\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"# 단변량 시퀀스를 다단계로 샘플링하기\\r\\ndef \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"split_sequences\"\n        }), \"(sequences, n_steps_in, n_steps_out):\\r\\n X, y = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"list\"\n        }), \"(), \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"list\"\n        }), \"()\\r\\n \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" i \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"range\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"len\"\n        }), \"(sequences)):\\r\\n     # 해당 패턴의 끝을 찾음\\r\\n     end_ix = i + n_steps_in\\r\\n     out_end_ix = end_ix + n_steps_out\\r\\n     # 시퀀스를 벗어나는지 확인\\r\\n     \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" out_end_ix > \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"len\"\n        }), \"(sequences):\\r\\n         \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"break\"\n        }), \"\\r\\n     # 패턴의 입력 및 출력 부분 수집\\r\\n     seq_x, seq_y = sequences[\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"i\"\n        }), \":end_ix], sequences[\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"end_ix\"\n        }), \":out_end_ix]\\r\\n     X.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"append\"\n        }), \"(seq_x)\\r\\n     y.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"append\"\n        }), \"(seq_y)\\r\\n \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" np.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"array\"\n        }), \"(X), np.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"array\"\n        }), \"(y)\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제, 특성 뿐만 아니라 타겟도 대각선 반복을 가지고 있어 시계열과 비교하려면 그들을 평균화하거나 예측 중 하나를 선택해야 합니다. 아래 코드에서는 첫 번째, 마지막 및 평균 예측의 결과가 생성되며, 그에 이어 플롯이 제시됩니다. 여기서 첫 번째 예측은 한 달 전 예측을 의미하며, 마지막 예측은 12개월 전 예측을 의미합니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"n_steps_in = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"12\"\n        }), \"\\r\\nn_steps_out = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"12\"\n        }), \"\\r\\n\\r\\nX, y = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"split_sequences\"\n        }), \"(ts_data, n_steps_in, n_steps_out)\\r\\nX = X.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"reshape\"\n        }), \"(X.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"shape\"\n        }), \"[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"], X.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"shape\"\n        }), \"[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"], \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \")\\r\\ny = y.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"reshape\"\n        }), \"(y.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"shape\"\n        }), \"[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"], y.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"shape\"\n        }), \"[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"], \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \")\\r\\n\\r\\n# 훈련 및 테스트 세트 분리\\r\\ntrain_ratio = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.8\"\n        }), \"\\r\\ntrain_size = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"int\"\n        }), \"(train_ratio * \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"len\"\n        }), \"(ts_data))\\r\\nX_train, X_test = X[:train_size-n_steps_in-n_steps_out+\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"], X[train_size-n_steps_in-n_steps_out+\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \":]\\r\\ny_train = y[:train_size-n_steps_in-n_steps_out+\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"]\\r\\ny_test = ts_data[\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"train_size\"\n        }), \":]\\r\\n\\r\\n# \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"LSTM\"\n        }), \" 모델 생성 및 훈련\\r\\nmodel = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Sequential\"\n        }), \"()\\r\\nmodel.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"add\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"LSTM\"\n        }), \"(units=\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"72\"\n        }), \", activation=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'tanh'\"\n        }), \", input_shape=(n_steps_in, \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \")))\\r\\nmodel.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"add\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Dense\"\n        }), \"(units=n_steps_out))\\r\\nmodel.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"compile\"\n        }), \"(loss=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'mean_squared_error'\"\n        }), \", optimizer=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Adam'\"\n        }), \", metrics=[\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'mape'\"\n        }), \"])\\r\\n\\r\\nmodel.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"fit\"\n        }), \"(x=X_train, y=y_train, epochs=\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"500\"\n        }), \", batch_size=\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"18\"\n        }), \", verbose=\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"2\"\n        }), \")\\r\\n\\r\\n# 예측 생성\\r\\nlstm_predictions = model.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"predict\"\n        }), \"(X_test)\\r\\nlstm_fitted = model.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"predict\"\n        }), \"(X_train)\\r\\n\\r\\nforecasts = [np.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"diag\"\n        }), \"(np.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"fliplr\"\n        }), \"(lstm_predictions), i).\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"mean\"\n        }), \"() \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" i \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"range\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", -lstm_predictions.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"shape\"\n        }), \"[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"], -\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \")]\\r\\nfits = [np.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"diag\"\n        }), \"(np.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"fliplr\"\n        }), \"(lstm_fitted), i).\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"mean\"\n        }), \"() \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" i \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"range\"\n        }), \"(lstm_fitted.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"shape\"\n        }), \"[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"]+n_steps_in - \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \", -lstm_fitted.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"shape\"\n        }), \"[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"], -\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \")]\\r\\nforecasts1 = lstm_predictions[n_steps_out-\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \":,\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"]\\r\\nfits1 = model.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"predict\"\n        }), \"(X)[:train_size-n_steps_in,\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"]\\r\\nforecasts12 = lstm_predictions[:,n_steps_out-\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"]\\r\\nfits12 = lstm_fitted[:,n_steps_out-\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"]\\r\\n\\r\\n# \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Metric\"\n        }), \"\\r\\nav_mape = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"mean_absolute_percentage_error\"\n        }), \"(y_test, forecasts)\\r\\nav_r2 = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"r2_score\"\n        }), \"(ts_data[\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"n_steps_in\"\n        }), \":train_size], fits[\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"n_steps_in\"\n        }), \":])\\r\\none_mape = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"mean_absolute_percentage_error\"\n        }), \"(y_test[:-n_steps_out+\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"], forecasts1)\\r\\none_r2 = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"r2_score\"\n        }), \"(ts_data[\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"n_steps_in\"\n        }), \":train_size], fits1)\\r\\ntwelve_mape = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"mean_absolute_percentage_error\"\n        }), \"(y_test, forecasts12)\\r\\ntwelve_r2 = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"r2_score\"\n        }), \"(ts_data[n_steps_in+n_steps_out-\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \":train_size], fits12)\\r\\n \\r\\ndate_range = pd.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"date_range\"\n        }), \"(start=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'1990-01-01'\"\n        }), \", end=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'2023-09-30'\"\n        }), \", freq=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'M'\"\n        }), \")\\r\\n\\r\\n# 실제, 적합 결과 및 예측을 플롯\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"figure\"\n        }), \"(figsize=(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"10\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"6\"\n        }), \"))\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"plot\"\n        }), \"(date_range, ts_data, label=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Actual'\"\n        }), \", color=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'blue'\"\n        }), \")\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"plot\"\n        }), \"(date_range[:train_size], fits, label=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Fitted'\"\n        }), \", color=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'green'\"\n        }), \")\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"plot\"\n        }), \"(date_range[\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"train_size\"\n        }), \":], forecasts, label=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Forecast'\"\n        }), \", color=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'red'\"\n        }), \")\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"title\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'FSC - Short - Passengers\\\\n. LSTM 12 Month Average Forecast'\"\n        }), \")\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"xlabel\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Date'\"\n        }), \")\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"ylabel\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Passengers'\"\n        }), \")\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"legend\"\n        }), \"()\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"text\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.05\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.05\"\n        }), \", f\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'R2 = {av_r2*100:.2f}%\\\\nMAPE = {av_mape*100:.2f}%'\"\n        }), \", transform=plt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"gca\"\n        }), \"().\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"transAxes\"\n        }), \", fontsize=\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"12\"\n        }), \")\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"grid\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"True\"\n        }), \")\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"show\"\n        }), \"()\\r\\n\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"figure\"\n        }), \"(figsize=(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"10\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"6\"\n        }), \"))\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"plot\"\n        }), \"(date_range, ts_data, label=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Actual'\"\n        }), \", color=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'blue'\"\n        }), \")\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"plot\"\n        }), \"(date_range[\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"n_steps_in\"\n        }), \":train_size], fits1, label=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Fitted'\"\n        }), \", color=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'green'\"\n        }), \")\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"plot\"\n        }), \"(date_range[\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"train_size\"\n        }), \":-n_steps_out+\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"], forecasts1, label=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Forecast'\"\n        }), \", color=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'red'\"\n        }), \")\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"title\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'FSC - Short - Passengers\\\\n LSTM 1 Month in advance Forecast'\"\n        }), \")\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"xlabel\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Date'\"\n        }), \")\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"ylabel\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Passengers'\"\n        }), \")\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"legend\"\n        }), \"()\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"text\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.05\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.05\"\n        }), \", f\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'R2 = {one_r2*100:.2f}%\\\\nMAPE = {one_mape*100:.2f}%'\"\n        }), \", transform=plt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"gca\"\n        }), \"().\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"transAxes\"\n        }), \", fontsize=\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"12\"\n        }), \")\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"grid\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"True\"\n        }), \")\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"show\"\n        }), \"()\\r\\n\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"figure\"\n        }), \"(figsize=(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"10\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"6\"\n        }), \"))\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"plot\"\n        }), \"(date_range, ts_data, label=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Actual'\"\n        }), \", color=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'blue'\"\n        }), \")\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"plot\"\n        }), \"(date_range[n_steps_in+n_steps_out-\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \":train_size], fits12, label=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Fitted'\"\n        }), \", color=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'green'\"\n        }), \")\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"plot\"\n        }), \"(date_range[\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"train_size\"\n        }), \":], forecasts12, label=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Forecast'\"\n        }), \", color=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'red'\"\n        }), \")\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"title\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'FSC - Short - Passengers\\\\n LSTM 12 Months in advance Forecast'\"\n        }), \")\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"xlabel\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Date'\"\n        }), \")\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"ylabel\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Passengers'\"\n        }), \")\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"legend\"\n        }), \"()\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"text\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.05\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.05\"\n        }), \", f\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'R2 = {twelve_r2*100:.2f}%\\\\nMAPE = {twelve_mape*100:.2f}%'\"\n        }), \", transform=plt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"gca\"\n        }), \"().\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"transAxes\"\n        }), \", fontsize=\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"12\"\n        }), \")\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"grid\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"True\"\n        }), \")\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"show\"\n        }), \"()\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이슈: 창 메서드와 동일한 문제가 여기에도 있습니다:```\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_8.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"해상도: 창 법과 비슷한 방법을 사용할 수 있습니다. 그러나 n_steps_out을 test_size와 동일하게 선택할 수도 있습니다. 이렇게 하면 테스트 세트가 하나로 축소됩니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_9.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다음 함수는 이를 정확히 수행합니다. 이 함수는 시계열, 학습 크기 및 샘플 수를 사용합니다. 이 버전은 다른 예측 알고리즘과 비교할 수 있기 때문에 comparable로 이름 지었습니다:\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"def \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"split_sequences_comparable\"\n        }), \"(sequences, n_samples, train_size):\\r\\n # 단계\\r\\n n_steps_out = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"len\"\n        }), \"(sequences) - train_size\\r\\n n_steps_in = train_size - n_steps_out - n_samples + \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"\\r\\n # 끝 세트\\r\\n X_test = sequences[n_samples + n_steps_out - \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \":train_size]\\r\\n X_forecast = sequences[-\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"n_steps_in\"\n        }), \":]\\r\\n X, y = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"list\"\n        }), \"(), \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"list\"\n        }), \"()\\r\\n \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" i \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"range\"\n        }), \"(n_samples):\\r\\n     # 이 패턴의 끝을 찾습니다\\r\\n     end_ix = i + n_steps_in\\r\\n     out_end_ix = end_ix + n_steps_out\\r\\n     # 패턴의 입력 및 출력 부분을 수집합니다\\r\\n     seq_x, seq_y = sequences[\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"i\"\n        }), \":end_ix], sequences[\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"end_ix\"\n        }), \":out_end_ix]\\r\\n     X.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"append\"\n        }), \"(seq_x)\\r\\n     y.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"append\"\n        }), \"(seq_y)\\r\\n \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" np.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"array\"\n        }), \"(X), np.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"array\"\n        }), \"(y), np.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"array\"\n        }), \"(X_test), np.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"array\"\n        }), \"(X_forecast), n_steps_in, n_steps_out\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 함수에서는 단계 수가 이미 고정되었기 때문에 샘플 수와 훈련 크기는 사용자가 선택하도록 하고, 최대 가능한 단계 수를 계산하도록 결정했습니다. 아래는 실행된 코드와 그 결과입니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"n_samples = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"12\"\n        }), \"\\r\\ntrain_size = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"321\"\n        }), \"\\r\\nX_train, y_train, X_test, X_forecast, n_steps_in, n_steps_out = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"split_sequences_comparable\"\n        }), \"(ts_data, n_samples, train_size)\\r\\ny_test = ts_data[\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"train_size\"\n        }), \":]\\r\\n\\r\\n# \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Reshaping\"\n        }), \"\\r\\nX_train = X_train.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"reshape\"\n        }), \"(X_train.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"shape\"\n        }), \"[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"], X_train.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"shape\"\n        }), \"[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"], \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \")\\r\\nX_test = X_test.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"reshape\"\n        }), \"(X_test.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"shape\"\n        }), \"[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"], X_test.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"shape\"\n        }), \"[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"], \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \")\\r\\ny_train = y_train.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"reshape\"\n        }), \"(y_train.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"shape\"\n        }), \"[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"], y_train.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"shape\"\n        }), \"[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"])\\r\\ny_test = y_test.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"reshape\"\n        }), \"(y_test.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"shape\"\n        }), \"[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"], y_test.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"shape\"\n        }), \"[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"], \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \")\\r\\n\\r\\n# \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"LSTM\"\n        }), \" 모델 생성 및 훈련\\r\\nmodel = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Sequential\"\n        }), \"()\\r\\nmodel.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"add\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"LSTM\"\n        }), \"(units=\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"154\"\n        }), \", activation=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'tanh'\"\n        }), \", input_shape=(n_steps_in, \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \")))\\r\\nmodel.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"add\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Dense\"\n        }), \"(units=n_steps_out))\\r\\nmodel.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"compile\"\n        }), \"(loss=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'mean_squared_error'\"\n        }), \", optimizer=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Adam'\"\n        }), \", metrics=[\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'mape'\"\n        }), \"])\\r\\n\\r\\nmodel.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"fit\"\n        }), \"(x=X_train, y=y_train, epochs=\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"500\"\n        }), \", batch_size=\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"18\"\n        }), \", verbose=\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"2\"\n        }), \")\\r\\n\\r\\n# 예측\\r\\nlstm_predictions = model.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"predict\"\n        }), \"(X_test)\\r\\npredictions = lstm_predictions.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"reshape\"\n        }), \"(lstm_predictions.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"shape\"\n        }), \"[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"])\\r\\nlstm_fitted = model.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"predict\"\n        }), \"(X_train)\\r\\nfits = [np.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"diag\"\n        }), \"(np.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"fliplr\"\n        }), \"(lstm_fitted), i).\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"mean\"\n        }), \"() \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" i \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"range\"\n        }), \"(lstm_fitted.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"shape\"\n        }), \"[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"]+n_steps_in - \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \", -lstm_fitted.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"shape\"\n        }), \"[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"], -\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \")]\\r\\n\\r\\n# 메트릭스\\r\\nmape = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"mean_absolute_percentage_error\"\n        }), \"(y_test, predictions)\\r\\nr2 = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"r2_score\"\n        }), \"(ts_data[\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"n_steps_in\"\n        }), \":train_size], fits[\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"n_steps_in\"\n        }), \":])\\r\\n\\r\\n# 실제, 적합 및 예측 플롯\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"figure\"\n        }), \"(figsize=(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"10\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"6\"\n        }), \"))\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"plot\"\n        }), \"(date_range, ts_data, label=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Actual'\"\n        }), \", color=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'blue'\"\n        }), \")\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"plot\"\n        }), \"(date_range[:train_size], fits, label=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Fitted'\"\n        }), \", color=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'green'\"\n        }), \")\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"plot\"\n        }), \"(date_range[\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"train_size\"\n        }), \":], predictions, label=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Forecast'\"\n        }), \", color=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'red'\"\n        }), \")\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"title\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'FSC - Short - Passengers\\\\n12 Sample Comparable LSTM Forecast'\"\n        }), \")\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"xlabel\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Date'\"\n        }), \")\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"ylabel\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Passengers'\"\n        }), \")\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"legend\"\n        }), \"()\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"text\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.05\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.05\"\n        }), \", f\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'R2 = {r2*100:.2f}%\\\\nMAPE = {mape*100:.2f}%\\\\', transform=plt.gca().transAxes, fontsize=12)\\r\\nplt.grid(True)\\r\\nplt.show()\\n\"\n        })]\n      })\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_10.png\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"지금까지 우리가 얻은 결과는 가장 신뢰할만한 것입니다. 그러나 제가 개발한 혁신적인 방법을 사용하면 더 나은 결과를 얻을 수 있습니다. 이 방법은 나중에 시리즈에서 (순환 방법) 자세히 설명하겠습니다. 먼저 LSTM 네트워크의 하이퍼파라미터를 조정하는 방법에 대해 설명하겠습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"LSTM은 모든 시간 단계를 특성으로 집계하기 때문에 시계열 데이터가 모든 이러한 방법에서 손실됩니다. 나중에 시리즈에서 (인코더/디코더 방법) 시계열 입력의 구조를 유지하는 다른 방법을 사용할 것입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"계속 주목해 주세요!\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true}