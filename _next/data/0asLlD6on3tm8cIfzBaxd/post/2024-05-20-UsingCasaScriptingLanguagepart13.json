{"pageProps":{"post":{"title":"C를 스크립팅 언어로 활용하기, 제13부","description":"","date":"2024-05-20 16:32","slug":"2024-05-20-UsingCasaScriptingLanguagepart13","content":"\n\n힙 관련 함수 최적화\n\n게임을 만들 때 병목 구간이 되지 않는 많은 부분이 있습니다. 그런 섹션에서는 종종 안전하고 표준적인 코드를 작성합니다. 보통 임시 힙 할당이 포함된 코드입니다.\n\n프로그램이 무엇을 하는지 모니터링할 수 있는 heap 및 다른 시스템 호출에 대한 상세한 설정이 있습니다. 그러나 실제 이야기는 RISC-V 어셈블리를 읽는 데 있습니다. C++에서 new를 호출하면 먼저 빈 래퍼로 이동한 다음 실제 C++ new 함수로 이동합니다. 그러면 다시 내 힙 시스템 호출 래퍼를 호출하고 최종적으로 시스템 호출을 호출합니다. C++에서는 new가 할당이 실패하면 예외를 throw할 수 있지만 여기에선 무시됩니다. 모든 것을 제어하고 있기 때문입니다. 할당에 실패하면 에뮬레이터가 예외를 throw합니다. 메모리가 부족하거나 실행 시간이 너무 길어지면 마찬가지입니다. 그러므로 new 호출 체인을 피하고 최상의 경우에는 직접 시스템 호출을 호출하고 싶습니다.\n\n이에 대한 간단한 벤치마크를 만들었습니다:\n\n<div class=\"content-ad\"></div>\n\n```md\nBenchmarking it, it took around 50ns. That’s not too bad. But, it can be improved just by avoiding all the calls that do nothing but call another function.\n\nSo, the first thing to do is to call the system call wrapper directly. This meant that I had to forego the return value from free, because in C the free function doesn’t have a return value. Otherwise the A0 register would be clobbered, and I would have a very mysterious bug on my hands. Running it, I found that it heavily reduced the run-time, now at 31ns. A 38% run-time reduction.\n\nThe last thing to try, was to write inline functions for new and delete, which would call my inline assembly functions sys_malloc and sys_free:\n```\n\n<div class=\"content-ad\"></div>\n\n```js\n인라인 void* sys_malloc(std::size_t size) {\n  register void*   ret asm(\"a0\");\n  register size_t  a0  asm(\"a0\") = size;\n  register long syscall_id asm(\"a7\") = SYSCALL_MALLOC;\n\n  asm volatile (\"ecall\"\n  : \"=m\"(*(char(*)[size]) ret), \"=r\"(ret)\n  : \"r\"(a0), \"r\"(syscall_id));\n  return ret;\n}\n인라인 void  sys_free(void* ptr)\n{\n  register void*  a0  asm(\"a0\") = ptr;\n  register long syscall_id asm(\"a7\") = SYSCALL_FREE;\n\n  asm volatile (\"ecall\"\n  :\n  : \"r\"(a0), \"r\"(syscall_id));\n}\n\n이제 ret이 레지스터 A0을 재할당하는 것을 명시하는 것을 기억해야 했지만, 모든 테스트, 벤치마크 그리고 제 게임에서 모두 잘 실행되었습니다. 지금까지 잘 되고 있어요. 벤치마크 실행 시간은 미친 듯한 19ns로 나왔어요.\n\n0000000050000b94 <_ZL16bench_alloc_freev>:\n    50000b94:   40000513                li      a0,1024\n    50000b98:   23a00893                li      a7,570\n    50000b9c:   00000073                ecall\n    50000ba0:   00050663                beqz    a0,50000bac <_ZL16bench_alloc_freev+0x18>\n    50000ba4:   23d00893                li      a7,573\n    50000ba8:   00000073                ecall\n    50000bac:   00008067                ret\n\n어셈블리를 살펴보니, 완벽해 보이고, 더 이상 개선할 수 없을 것 같아요. 실행 속도가 너무 빨라서 당연히 이렇게 되는 거예요. 거의 네이티브 성능에 가깝습니다.\n```\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-05-20-UsingCasaScriptingLanguagepart13_0.png)\n\nwasmtime을 malloc() - free() 콤보로 실행했고, 평균 66ns가 걸린 것을 발견했어요. 48ns의 호출 오버헤드를 뺀 18ns의 런타임이 편안하게 나왔어요. 정말 빠른 속도죠. 이제는 제가 만든 힙 할당기가 문제인지 궁금해졌어요. 아마 맞겠죠? 지배적일 것입니다. 여기 차트가 있어요:\n\n![차트](/assets/img/2024-05-20-UsingCasaScriptingLanguagepart13_1.png)\n\n더 빠른 힙 할당기를 작성할 에너지가 없을 것 같아요. 특히, 내 힙 할당기가 견고하고 잘 테스트되어 있을 때 말이에요. 오랜 시간 잘 돌아가다가 이상한 메모리 조각화도 그리 심하게 일어나지 않아요. 게임을 만드는 것이 중요한데, 그럴 때 힙 할당기 같은 기본 할당기를 바꾸는 게 무서울 때가 있죠.\n  \n\n<div class=\"content-ad\"></div>\n\n그래도 괜찮네요. 제가 가까이 왔군요!\n\n-곤조","ogImage":{"url":"/assets/img/2024-05-20-UsingCasaScriptingLanguagepart13_0.png"},"coverImage":"/assets/img/2024-05-20-UsingCasaScriptingLanguagepart13_0.png","tag":["Tech"],"readingTime":3},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\",\n    img: \"img\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"힙 관련 함수 최적화\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"게임을 만들 때 병목 구간이 되지 않는 많은 부분이 있습니다. 그런 섹션에서는 종종 안전하고 표준적인 코드를 작성합니다. 보통 임시 힙 할당이 포함된 코드입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"프로그램이 무엇을 하는지 모니터링할 수 있는 heap 및 다른 시스템 호출에 대한 상세한 설정이 있습니다. 그러나 실제 이야기는 RISC-V 어셈블리를 읽는 데 있습니다. C++에서 new를 호출하면 먼저 빈 래퍼로 이동한 다음 실제 C++ new 함수로 이동합니다. 그러면 다시 내 힙 시스템 호출 래퍼를 호출하고 최종적으로 시스템 호출을 호출합니다. C++에서는 new가 할당이 실패하면 예외를 throw할 수 있지만 여기에선 무시됩니다. 모든 것을 제어하고 있기 때문입니다. 할당에 실패하면 에뮬레이터가 예외를 throw합니다. 메모리가 부족하거나 실행 시간이 너무 길어지면 마찬가지입니다. 그러므로 new 호출 체인을 피하고 최상의 경우에는 직접 시스템 호출을 호출하고 싶습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이에 대한 간단한 벤치마크를 만들었습니다:\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-md\",\n        children: [\"Benchmarking it, it took around 50ns. That’s not too bad. But, it can be improved just by avoiding all the calls that do nothing but call another function.\\n\\nSo, the first thing to do is to call the system call wrapper directly. This meant that I had to forego the return value from free, because in C the free function doesn’t have a return value. Otherwise the A0 register would be clobbered, and I would have a very mysterious bug on my hands. Running it, I found that it heavily reduced the run-time, now at 31ns. A 38% run-time reduction.\\n\\nThe last thing to try, was to write inline functions for new and delete, which would call my inline assembly functions sys\", _jsx(_components.span, {\n          className: \"hljs-emphasis\",\n          children: \"_malloc and sys_\"\n        }), \"free:\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"인라인 \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"void\"\n        }), \"* \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"sys_malloc\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"std::size_t size\"\n        }), \") {\\n  register \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"void\"\n        }), \"*   ret \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"asm\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"a0\\\"\"\n        }), \");\\n  register size_t  a0  \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"asm\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"a0\\\"\"\n        }), \") = size;\\n  register long syscall_id \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"asm\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"a7\\\"\"\n        }), \") = \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"SYSCALL_MALLOC\"\n        }), \";\\n\\n  asm volatile (\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"ecall\\\"\"\n        }), \"\\n  : \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"=m\\\"\"\n        }), \"(*(\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"char\"\n        }), \"(*)[size]) ret), \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"=r\\\"\"\n        }), \"(ret)\\n  : \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"r\\\"\"\n        }), \"(a0), \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"r\\\"\"\n        }), \"(syscall_id));\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" ret;\\n}\\n인라인 \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"void\"\n        }), \"  \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"sys_free\"\n        }), \"(\", _jsxs(_components.span, {\n          className: \"hljs-params\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"void\"\n          }), \"* ptr\"]\n        }), \")\\n{\\n  register \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"void\"\n        }), \"*  a0  \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"asm\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"a0\\\"\"\n        }), \") = ptr;\\n  register long syscall_id \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"asm\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"a7\\\"\"\n        }), \") = \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"SYSCALL_FREE\"\n        }), \";\\n\\n  asm volatile (\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"ecall\\\"\"\n        }), \"\\n  :\\n  : \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"r\\\"\"\n        }), \"(a0), \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"r\\\"\"\n        }), \"(syscall_id));\\n}\\n\\n이제 ret이 레지스터 \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"A0\"\n        }), \"을 재할당하는 것을 명시하는 것을 기억해야 했지만, 모든 테스트, 벤치마크 그리고 제 게임에서 모두 잘 실행되었습니다. 지금까지 잘 되고 있어요. 벤치마크 실행 시간은 미친 듯한 19ns로 나왔어요.\\n\\n0000000050000b94 <_ZL16bench_alloc_freev>:\\n    50000\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"b94\"\n        }), \":   \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"40000513\"\n        }), \"                li      a0,\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1024\"\n        }), \"\\n    50000\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"b98\"\n        }), \":   23a00893                li      a7,\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"570\"\n        }), \"\\n    50000\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"b9c\"\n        }), \":   \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"00000073\"\n        }), \"                ecall\\n    50000\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"ba0\"\n        }), \":   \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"00050663\"\n        }), \"                beqz    a0,50000bac <_ZL16bench_alloc_freev+\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0x18\"\n        }), \">\\n    50000\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"ba4\"\n        }), \":   23d00893                li      a7,\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"573\"\n        }), \"\\n    50000\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"ba8\"\n        }), \":   \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"00000073\"\n        }), \"                ecall\\n    50000\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"bac\"\n        }), \":   \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"00008067\"\n        }), \"                ret\\n\\n어셈블리를 살펴보니, 완벽해 보이고, 더 이상 개선할 수 없을 것 같아요. 실행 속도가 너무 빨라서 당연히 이렇게 되는 거예요. 거의 네이티브 성능에 가깝습니다.\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-20-UsingCasaScriptingLanguagepart13_0.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"wasmtime을 malloc() - free() 콤보로 실행했고, 평균 66ns가 걸린 것을 발견했어요. 48ns의 호출 오버헤드를 뺀 18ns의 런타임이 편안하게 나왔어요. 정말 빠른 속도죠. 이제는 제가 만든 힙 할당기가 문제인지 궁금해졌어요. 아마 맞겠죠? 지배적일 것입니다. 여기 차트가 있어요:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-20-UsingCasaScriptingLanguagepart13_1.png\",\n        alt: \"차트\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"더 빠른 힙 할당기를 작성할 에너지가 없을 것 같아요. 특히, 내 힙 할당기가 견고하고 잘 테스트되어 있을 때 말이에요. 오랜 시간 잘 돌아가다가 이상한 메모리 조각화도 그리 심하게 일어나지 않아요. 게임을 만드는 것이 중요한데, 그럴 때 힙 할당기 같은 기본 할당기를 바꾸는 게 무서울 때가 있죠.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그래도 괜찮네요. 제가 가까이 왔군요!\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"-곤조\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true}