{"pageProps":{"post":{"title":"테스트 속도를 높이는 parallel_tests의 힘을 활용해보세요 로컬 설정 및 실행법","description":"","date":"2024-05-20 15:50","slug":"2024-05-20-HarnessingthePowerofparallel_testsforFasterTestingLocalSetupandExecution","content":"\n\n# parallel_tests란 무엇인가요?\n\n이는 RSpec, Cucumber 및 기타 테스트 도구 그룹의 실행 속도를 높이기 위해 사용되는 Ruby gem입니다.\n\nParallelTests는 테스트를 균형 잡힌 그룹(라인 수 또는 실행 시간으로)으로 분할하고 각 그룹을 해당 데이터베이스와 함께 프로세스에서 실행합니다.\n\n# 설정 및 실행\n\n<div class=\"content-ad\"></div>\n\n- .zshrc 파일에 export PARALLEL_TEST_PROCESSORS=n을 추가하여 세그먼트 수를 지정하세요.\n- `test` 섹션 내에서 database.yml 파일에 병렬 테스트 구성을 추가하세요.\n\n```js\ntest:\n database: yourproject_test<%= ENV['TEST_ENV_NUMBER'] %>\n```\n\n- .rspec 파일에 형식 구성을 추가하세요.\n\n```js\n--format progress\n--format ParallelTests::RSpec::RuntimeLogger --out tmp/parallel_runtime_rspec.log\n--format ParallelTests::RSpec::SummaryLogger --out tmp/spec_summary.log\n--format ParallelTests::RSpec::FailuresLogger --out tmp/failing_specs.log\n```\n\n<div class=\"content-ad\"></div>\n\n- 다음 명령을 실행하여 병렬 테스트 데이터베이스를 생성하세요: rake parallel:create.\n- 마이그레이션에 업데이트가 있는 경우 rake parallel:migrate를 실행하세요.\n- rake parallel:prepare 명령을 사용하여 개발 스키마를 복사하세요.\n- 병렬로 스펙을 실행하려면 rake parallel:spec 명령을 사용하세요.\n- 모든 병렬 테스트 데이터베이스를 삭제하려면 rake parallel:drop 명령을 실행하세요.\n\n참고사항:\n\n- 기본적으로 PARALLEL_TEST_PROCESSORS의 수는 기기의 프로세서 수로 설정됩니다.\n- 모든 작업을 한 번에 처리하려면 🤩 다음 명령어를 사용하세요 \n\n```js\nRAILS_ENV=test PARALLEL_TEST_PROCESSORS=6\nrails db:drop db:create db:migrate parallel:prepare parallel:spec\n```\n\n<div class=\"content-ad\"></div>\n\n# 장점\n\n- 빠른 테스트 실행 달성\n일반적으로 병렬 테스트를 사용하지 않을 때 테스트 실행에 약 1.5시간이 소요된다고 가정해 보겠습니다. 그러나 6개 코어를 이용하여 병렬 테스트를 수행하면 이 시간을 15분에서 20분으로 줄일 수 있어 대략 85~90%의 속도 향상이 가능합니다.\n- 최적화된 자원 활용\n6개 코어를 보유한 상황을 가정해 봅시다. 병렬 테스트를 사용하지 않는다면 모든 사양은 단일 코어에서만 실행됩니다. 그러나 병렬 테스트를 활용하면 여러 코어를 이용하여 사양을 실행할 수 있습니다.\n- Rails와의 원활한 통합\n한 번만 병렬 테스트를 구성하면 여러 테스트 도구에서 사용할 수 있습니다. 예를 들어, RSpec을 사용하는 경우 rake parallel:spec을 실행할 수 있습니다. Minitest로 전환한다면 실행 명령을 rake parallel:test로 변경하기만 하면 됩니다.\n\n# 결점\n\n- 자원 부담\n병렬로 테스트를 실행하는 것은 CPU 및 메모리와 같은 추가 시스템 자원을 소비합니다.\n- 불안정성 가능성\n캐싱이나 Redis와 같은 공유 자원을 활용하는 일부 사양은 설정되어 있지만 다른 세그먼트의 사양에서는 해당 자원을 읽을 수 있습니다. 이로 인해 오류나 일관성에 문제가 발생할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 자원\n\n- 문서\n\n# 결론\n\n요약하자면, 더 빠른 테스트를 위해 병렬 테스트를 활용하는 것은 상당한 이점을 제공합니다. 자원 활용을 최적화하고 Rails와 완벽하게 통합되어 테스트 실행 시간을 크게 줄입니다. 그러나 자원 과부하 및 안정성과 같은 잠재적인 단점에 대해 주의해야 합니다. 적절한 구성과 모니터링으로 병렬 테스트가 개발 프로세스에서 유용한 자산임을 입증했습니다. 더 많은 지침을 위해서 문서를 참조하세요.","ogImage":{"url":"/assets/img/2024-05-20-HarnessingthePowerofparallel_testsforFasterTestingLocalSetupandExecution_0.png"},"coverImage":"/assets/img/2024-05-20-HarnessingthePowerofparallel_testsforFasterTestingLocalSetupandExecution_0.png","tag":["Tech"],"readingTime":3},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h1: \"h1\",\n    p: \"p\",\n    ul: \"ul\",\n    li: \"li\",\n    code: \"code\",\n    pre: \"pre\",\n    span: \"span\",\n    div: \"div\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h1, {\n      children: \"parallel_tests란 무엇인가요?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이는 RSpec, Cucumber 및 기타 테스트 도구 그룹의 실행 속도를 높이기 위해 사용되는 Ruby gem입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"ParallelTests는 테스트를 균형 잡힌 그룹(라인 수 또는 실행 시간으로)으로 분할하고 각 그룹을 해당 데이터베이스와 함께 프로세스에서 실행합니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"설정 및 실행\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \".zshrc 파일에 export PARALLEL_TEST_PROCESSORS=n을 추가하여 세그먼트 수를 지정하세요.\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"test\"\n        }), \" 섹션 내에서 database.yml 파일에 병렬 테스트 구성을 추가하세요.\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"test\"\n        }), \":\\n \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"database\"\n        }), \": yourproject_test<%= \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"ENV\"\n        }), \"[\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'TEST_ENV_NUMBER'\"\n        }), \"] %>\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \".rspec 파일에 형식 구성을 추가하세요.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"--format progress\\n--format \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ParallelTests\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"RSpec\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"RuntimeLogger\"\n        }), \" --out tmp/parallel_runtime_rspec.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"log\"\n        }), \"\\n--format \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ParallelTests\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"RSpec\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"SummaryLogger\"\n        }), \" --out tmp/spec_summary.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"log\"\n        }), \"\\n--format \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ParallelTests\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"RSpec\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"FailuresLogger\"\n        }), \" --out tmp/failing_specs.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"log\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"다음 명령을 실행하여 병렬 테스트 데이터베이스를 생성하세요: rake parallel\", _jsx(_components.div, {}), \".\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"마이그레이션에 업데이트가 있는 경우 rake parallel\", _jsx(_components.div, {}), \"를 실행하세요.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"rake parallel\", _jsx(_components.div, {}), \" 명령을 사용하여 개발 스키마를 복사하세요.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"병렬로 스펙을 실행하려면 rake parallel\", _jsx(_components.div, {}), \" 명령을 사용하세요.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"모든 병렬 테스트 데이터베이스를 삭제하려면 rake parallel\", _jsx(_components.div, {}), \" 명령을 실행하세요.\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"참고사항:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"기본적으로 PARALLEL_TEST_PROCESSORS의 수는 기기의 프로세서 수로 설정됩니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"모든 작업을 한 번에 처리하려면 🤩 다음 명령어를 사용하세요\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"RAILS_ENV\"\n        }), \"=test \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"PARALLEL_TEST_PROCESSORS\"\n        }), \"=\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"6\"\n        }), \"\\nrails \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"db\"\n        }), \":drop \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"db\"\n        }), \":create \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"db\"\n        }), \":migrate \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"parallel\"\n        }), \":prepare \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"parallel\"\n        }), \":spec\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"장점\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"빠른 테스트 실행 달성\\n일반적으로 병렬 테스트를 사용하지 않을 때 테스트 실행에 약 1.5시간이 소요된다고 가정해 보겠습니다. 그러나 6개 코어를 이용하여 병렬 테스트를 수행하면 이 시간을 15분에서 20분으로 줄일 수 있어 대략 85~90%의 속도 향상이 가능합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"최적화된 자원 활용\\n6개 코어를 보유한 상황을 가정해 봅시다. 병렬 테스트를 사용하지 않는다면 모든 사양은 단일 코어에서만 실행됩니다. 그러나 병렬 테스트를 활용하면 여러 코어를 이용하여 사양을 실행할 수 있습니다.\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Rails와의 원활한 통합\\n한 번만 병렬 테스트를 구성하면 여러 테스트 도구에서 사용할 수 있습니다. 예를 들어, RSpec을 사용하는 경우 rake parallel\", _jsx(_components.div, {}), \"을 실행할 수 있습니다. Minitest로 전환한다면 실행 명령을 rake parallel\", _jsx(_components.div, {}), \"로 변경하기만 하면 됩니다.\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"결점\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"자원 부담\\n병렬로 테스트를 실행하는 것은 CPU 및 메모리와 같은 추가 시스템 자원을 소비합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"불안정성 가능성\\n캐싱이나 Redis와 같은 공유 자원을 활용하는 일부 사양은 설정되어 있지만 다른 세그먼트의 사양에서는 해당 자원을 읽을 수 있습니다. 이로 인해 오류나 일관성에 문제가 발생할 수 있습니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"자원\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"문서\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"결론\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"요약하자면, 더 빠른 테스트를 위해 병렬 테스트를 활용하는 것은 상당한 이점을 제공합니다. 자원 활용을 최적화하고 Rails와 완벽하게 통합되어 테스트 실행 시간을 크게 줄입니다. 그러나 자원 과부하 및 안정성과 같은 잠재적인 단점에 대해 주의해야 합니다. 적절한 구성과 모니터링으로 병렬 테스트가 개발 프로세스에서 유용한 자산임을 입증했습니다. 더 많은 지침을 위해서 문서를 참조하세요.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true}