{"pageProps":{"posts":[{"title":"현재 날짜나 시간을 기준으로 데이터브릭에서 여러 파일을 동적으로 로드하는 방법","description":"","date":"2024-05-27 17:13","slug":"2024-05-27-HowToDynamicallyLoadMultipleFilesinDatabricksBasedonCurrentDateorHour","content":"\nBatch 시스템에서는 여러 번 클라이언트가 이미 추출된 파일을 동일한 경로에 유지하고, 도착한 추출 파일이 Bronze 레이어에 로드되기를 원하는 경우가 많습니다.\n\n따라서 이 경우, 개발자는 디렉토리에 있는 파일 목록 중에서 현재 날짜나 현재 시간에 도착한 파일만 고려하여 해당 파일의 내용을 Bronze 레이어에만 로드할 수 있도록 해야 합니다.\n\n이미지를 보면 오늘 날짜는 2024년 5월 25일임을 알 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n2024년 5월 22일에 첫 번째 파일이 도착했습니다.\n2024년 5월 23일에 두 번째 파일이 도착했습니다.\n2024년 5월 24일에 세 번째 파일이 도착했습니다.\n나머지 네 개의 파일은 오늘인 2024년 5월 25일에 도착했습니다.\n\n오늘 도착한 첫 번째 파일 내용은 다음과 같습니다 -\n\n![이미지](/assets/img/2024-05-27-HowToDynamicallyLoadMultipleFilesinDatabricksBasedonCurrentDateorHour_1.png)\n\n오늘 도착한 두 번째 파일 내용은 다음과 같습니다 -\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Third File](/assets/img/2024-05-27-HowToDynamicallyLoadMultipleFilesinDatabricksBasedonCurrentDateorHour_3.png)\n\nThe content of the Fourth File arrived today is as follows -\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-05-27-HowToDynamicallyLoadMultipleFilesinDatabricksBasedonCurrentDateorHour_4.png\" />\n\n# 현재 날짜 기반으로 데이터브릭에서 여러 파일 동적으로 로드하는 방법\n\n그래서, 작업은 최근 네 개의 파일을 처리하고 그 네 개 파일의 내용을 브론즈 레이어의 테이블에 추가 모드로 로드하는 것입니다.\n\n단계 1: 브론즈 테이블 생성하기 -\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n먼저 다음 \"Spark SQL\" 쿼리를 사용하여 \"practice\"라는 데이터베이스를 생성하십시오 -\n\n```js\n%sql\nUSE hive_metastore;\nCREATE DATABASE IF NOT EXISTS practice\n```\n\n데이터베이스는 Databricks 워크스페이스에 생성됩니다 -\n\n![이미지](/assets/img/2024-05-27-HowToDynamicallyLoadMultipleFilesinDatabricksBasedonCurrentDateorHour_5.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그럼 다음 \"Spark SQL\" 쿼리를 사용하여 외부 델타 테이블 \"person_bronze\"을 생성하세요 -\n\n```js\n%sql\nCREATE TABLE IF NOT EXISTS hive_metastore.practice.person_bronze\n(\n  FirstName STRING NOT NULL,\n  LastName STRING NOT NULL,\n  City STRING NOT NULL,\n  Company STRING NOT NULL\n)\nLOCATION \"dbfs:/mnt/iobdatabronze/practice-zone/delta-table/person_bronze\"\n```\n\n외부 델타 테이블은 Databricks 워크스페이스의 \"practice\" 데이터베이스 내부에 생성됩니다 -\n\n![image](/assets/img/2024-05-27-HowToDynamicallyLoadMultipleFilesinDatabricksBasedonCurrentDateorHour_6.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n생성된 External Delta Table \"person_bronze\"의 폴더 경로는 제공된 위치에 ADLS에 생성되었습니다-\n\n![image](/assets/img/2024-05-27-HowToDynamicallyLoadMultipleFilesinDatabricksBasedonCurrentDateorHour_7.png)\n\n단계 2: 현재 날짜인 2024년 5월 25일을 기준으로 Databricks에서 가장 최근 네 개의 파일을 로드하는 Python 코드를 작성해 보겠습니다.\n\n단계 2.1: Python의 \"datetime\" 모듈을 사용하여 \"현재 날짜\"의 값을 가져와, 도착 파일의 이름에 사용된 형식과 일치하도록 \"현재 날짜\"의 값을 포맷팅해 주세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nimport os\nfrom datetime import datetime\nfrom functools import reduce\n\n# Python의 \"datetime\" 모듈을 사용하여 현재 날짜 가져오기\ncurrent_date = datetime.now()\nprint(current_date)\n\n# 현재 날짜의 값을 파일 이름 형식에 맞게 포맷팅하여 출력\nfile_name_date_format = current_date.strftime(\"%Y%m%d\")\nprint(file_name_date_format)\n```\n\n출력 -\n\n<img src=\"/assets/img/2024-05-27-HowToDynamicallyLoadMultipleFilesinDatabricksBasedonCurrentDateorHour_8.png\" />\n\n단계 2.2: 파일이 보관된 ADLS 디렉토리의 \"마운트된 경로\"를 지정합니다.\n그런 다음, 해당 지정된 디렉토리에서 모든 파일을 나열합니다.\n마지막으로, 그 지정된 디렉토리의 파일 이름에 \"현재 날짜\"가 포함된 파일만 걸러내어 Python List에 저장합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n# 파일이 위치한 ADLS 디렉토리의 마운트 경로 지정하기\ndirectory_path = \"/mnt/iobdatalanding/practice-zone/input-files/\"\n\n# 지정된 디렉토리에 있는 모든 파일 나열하기\nall_files = os.listdir(\"/dbfs\" + directory_path)\nprint(all_files)\n\n# 현재 날짜가 파일 이름에 포함된 파일만 필터링하여 Python 리스트에 저장하기\nmatching_files = [matching_file for matching_file in all_files if file_name_date_format in matching_file]\nprint(matching_files)\n```\n\n출력 -\n\n<img src=\"/assets/img/2024-05-27-HowToDynamicallyLoadMultipleFilesinDatabricksBasedonCurrentDateorHour_9.png\" />\n\n단계 2.3: 먼저 \"빈 Python 리스트\"를 생성하세요.\n그런 다음 각 일치하는 파일의 내용을 각각 별도의 DataFrame에 로드하세요.\n마지막으로 각 DataFrame을 이미 생성된 \"Python 리스트\"에 \"객체\"로 추가하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n# 빈 리스트 생성\nlist_of_dfs = []\n\n# 각 일치하는 파일을 각각 별도의 데이터프레임으로 로드\nfor file_name in matching_files:\n    # 실제 파일 경로 생성\n    file_path = os.path.join(directory_path, file_name)\n    # 각 파일마다 데이터프레임 생성\n    df = spark.read.format(\"csv\").option(\"header\", \"true\").load(file_path)\n    # 각 데이터프레임을 빈 리스트에 객체로서 각각 저장\n    list_of_dfs.append(df)\n\nprint(list_of_dfs)\n```\n\n출력 -\n\n<img src=\"/assets/img/2024-05-27-HowToDynamicallyLoadMultipleFilesinDatabricksBasedonCurrentDateorHour_10.png\" />\n\n2.4단계: 각 데이터프레임의 모든 값들을 단일 데이터프레임으로 연결하고, 각 데이터프레임의 값들이 이제 \"파이썬 리스트\"의 각 객체로 되는 단일 데이터프레임을 생성하기 위해 \"reduce()\" 함수와 \"union()\" 메서드를 사용합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n# 각 데이터프레임의 모든 값을 연결하여 하나의 데이터프레임으로 만들기\n# 이때 각 데이터프레임의 값은 이제 Python List의 각 객체이며 \"reduce()\" 함수를 사용하여 \"union()\" 메서드와 함께 결합합니다.\nfinal_df = reduce(lambda df1, df2: df1.union(df2), list_of_dfs)\ndisplay(final_df)\n```\n\n결과 -\n\n<img src=\"/assets/img/2024-05-27-HowToDynamicallyLoadMultipleFilesinDatabricksBasedonCurrentDateorHour_11.png\" />\n\n따라서 위 이미지에서 오늘 도착한 네 개의 파일에서 모든 레코드의 조합이 포함된 \"final_df\" 데이터프레임이 있음을 확인할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n당신이 개발자십에 관심이 있나봐요! 친철한 톤으로 번역해 드리겠습니다.\n\n스텝 2.5: 'final_df' DataFrame의 내용을 Bronze Table \"person_bronze\"에 삽입하세요.\n\n```js\n# 'final_df' DataFrame의 내용을 Bronze Table \"person_bronze\"에 삽입\nfinal_df.write.format(\"delta\").mode(\"append\").saveAsTable(\"hive_metastore.practice.person_bronze\")\n```\n\n다음 \"스파크 SQL\" 쿼리를 사용하여 'person_bronze' Bronze Table에 방금 삽입된 데이터가 있는지 확인하세요 -\n\n```js\n%sql\n-- 'person_bronze' Bronze Table에 데이터가 있는지 확인\nSELECT * FROM hive_metastore.practice.person_bronze;\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n출력 -\n\n<img src=\"/assets/img/2024-05-27-HowToDynamicallyLoadMultipleFilesinDatabricksBasedonCurrentDateorHour_12.png\" />\n\n# 현재 시간을 기반으로 한 Databricks에서 여러 파일 로드하기\n\n<img src=\"/assets/img/2024-05-27-HowToDynamicallyLoadMultipleFilesinDatabricksBasedonCurrentDateorHour_13.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n지금은 2024년 5월 25일이고, 현재 시간은 오후 8시입니다. 위 그림에서 볼 수 있듯이, 마지막 두 파일이 \"현재 시간\"인 즉, 8시에 도착했습니다.\n\n그러므로, 마지막 두 파일을 처리하고 그 두 파일의 내용을 브론즈 레이어의 테이블에 추가 모드로 로드하는 작업입니다.\n\n# 현재 날짜 또는 시간에 따라 Databricks에서 여러 파일을 동적으로 로드하는 방법\n\n배치 시스템에서는 고객이 이미 추출된 파일을 도착한 추출된 파일과 동일한 경로에 유지하고 브론즈 레이어에 로드하길 원하는 경우가 많습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n따라서 현재 일 또는 현재 시간에 도착한 파일만 고려하여 디렉터리에있는 파일 목록에서 해당 파일의 내용을 처리하고 브론즈 계층으로 로드하는 개발자의 책임이 있습니다.\n\n![이미지](/assets/img/2024-05-27-HowToDynamicallyLoadMultipleFilesinDatabricksBasedonCurrentDateorHour_14.png)\n\n오늘은 2024년 5월 25일입니다. 위 이미지에서 볼 수 있듯이 -\n\n첫 번째 파일은 2024년 5월 22일에 도착했습니다.\n두 번째 파일은 2024년 5월 23일에 도착했습니다.\n세 번째 파일은 2024년 5월 24일에 도착했습니다.\n나머지 네 번째 파일은 2024년 5월 25일, 즉 오늘 도착했습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n오늘 도착한 첫 번째 파일 내용은 다음과 같습니다 -\n\n![First File](/assets/img/2024-05-27-HowToDynamicallyLoadMultipleFilesinDatabricksBasedonCurrentDateorHour_15.png)\n\n오늘 도착한 두 번째 파일 내용은 다음과 같습니다 -\n\n![Second File](/assets/img/2024-05-27-HowToDynamicallyLoadMultipleFilesinDatabricksBasedonCurrentDateorHour_16.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n현재 시간에 도착한 첫 번째 파일의 내용은 다음과 같습니다 -\n\n![](/assets/img/2024-05-27-HowToDynamicallyLoadMultipleFilesinDatabricksBasedonCurrentDateorHour_17.png)\n\n현재 시간에 도착한 두 번째 파일의 내용은 다음과 같습니다 -\n\n![](/assets/img/2024-05-27-HowToDynamicallyLoadMultipleFilesinDatabricksBasedonCurrentDateorHour_18.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nStep 1: Create a Bronze Table -\n\n이미 첫 번째 부분에서 생성되었습니다.\n\nStep 2: 오늘 현재 시간 기준으로 Databricks에서 마지막 두 파일을로드하는 Python 코드 작성 시작, 즉, 2024년 5월 25일 오후 8시.\n\nStep 2.1: Python의 \"datetime\" 모듈을 사용하여 \"현재 날짜\"의 \"현재 시간\" 값을 가져와서 \"현재 날짜\"의 \"현재 시간\" 값을 적시되어 파일 도착 이름 및 \"날짜\" 및 \"시간\" 부분과 일치하도록 형식화하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\nimport os\nfrom datetime import datetime\nfrom functools import reduce\n\n# Python의 \"datetime\" 모듈을 사용하여 현재 날짜의 현재 시간을 가져옵니다.\ncurrent_date_and_time = datetime.now()\nprint(current_date_and_time)\n\n# 현재 시간의 값을 파일 이름의 날짜 및 시간 형식과 일치하도록 형식화합니다.\nfile_name_date_and_hour_format = current_date_and_time.strftime(\"%Y%m%d%H\")\nprint(file_name_date_and_hour_format)\n```\n\n출력 -\n\n<img src=\"/assets/img/2024-05-27-HowToDynamicallyLoadMultipleFilesinDatabricksBasedonCurrentDateorHour_19.png\" />\n\n단계 2.2: 파일이 보관된 ADLS 디렉토리의 \"Mounted Path\"를 지정합니다.\n그런 다음, 해당 지정된 디렉토리에서 모든 파일을 나열합니다.\n마지막으로 해당 지정된 디렉토리의 파일 이름 중 \"현재 날짜\"의 \"현재 시간\"이 있는 파일만 필터링하여 Python List에 저장합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n# 파일이 위치한 ADLS 디렉토리의 마운트 경로를 지정합니다\ndirectory_path = \"/mnt/iobdatalanding/practice-zone/input-files/\"\n\n# 지정된 디렉토리에 있는 모든 파일을 나열합니다\nall_files = os.listdir(\"/dbfs\" + directory_path)\nprint(all_files)\n\n# 현재 날짜의 현재 시간을 파일 이름에 포함하는 파일만 필터링합니다\nmatching_files = [matching_file for matching_file in all_files if file_name_date_and_hour_format in matching_file]\nprint(matching_files)\n```\n\nOutput -\n\n![다이나믹 파일로드 방법](/assets/img/2024-05-27-HowToDynamicallyLoadMultipleFilesinDatabricksBasedonCurrentDateorHour_20.png)\n\n단계 2.3: 먼저 \"빈 Python List\"를 생성합니다.\n그런 다음 각 일치하는 파일의 내용을 각각 별도의 DataFrame으로 로드합니다.\n마지막으로, 각 해당 DataFrame을 이미 생성된 \"Python List\"에 \"객체\"로서 추가합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n# 빈 목록 생성\nlist_of_dfs = []\n\n# 각 일치하는 파일을 각각 별도의 데이터프레임으로 불러오기\nfor file_name in matching_files:\n    # 실제 파일 경로 생성\n    file_path = os.path.join(directory_path, file_name)\n    # 각 파일에 대한 데이터프레임 생성\n    df = spark.read.format(\"csv\").option(\"header\", \"true\").load(file_path)\n    # 각 데이터프레임을 빈 목록에 객체로 각각 저장\n    list_of_dfs.append(df)\n\nprint(list_of_dfs)\n```\n\n출력 -\n\n<img src=\"/assets/img/2024-05-27-HowToDynamicallyLoadMultipleFilesinDatabricksBasedonCurrentDateorHour_21.png\" />\n\n단계 2.4: 각 데이터프레임의 모든 값들을 단일 데이터프레임으로 연결합니다. 각 데이터프레임의 값은 이제 \"Python List\"의 각 객체이며, \"reduce()\" 함수와 \"union()\" 메소드를 사용합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 각 DataFrame의 모든 값들을 Python 리스트의 각 객체로 사용하여 하나의 DataFrame으로 결합하십시오. \"reduce()\" 함수를 사용하고 \"union()\" 메서드를 함께 사용하십시오.\n\nfinal_df = reduce(lambda df1, df2: df1.union(df2), list_of_dfs)\ndisplay(final_df)\n\n출력 -\n\n<img src=\"/assets/img/2024-05-27-HowToDynamicallyLoadMultipleFilesinDatabricksBasedonCurrentDateorHour_22.png\" />\n\n따라서 위 이미지에서 현재 시간에 도착한 두 파일의 레코드를 모두 포함하는 \"final_df\" DataFrame을 확인할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n스텝 2.5: \"final_df\" 데이터프레임의 내용을 첫 번째 부분에 표시된 PySpark 코드를 사용하여 Bronze 테이블 \"person_bronze\"에 삽입합니다.\n\n마지막으로, 첫 번째 부분에 표시된 \"Spark SQL\" 쿼리를 사용하여 방금 삽입한 데이터가 Bronze 테이블 \"person_bronze\"에 있는지 확인하세요.\n","ogImage":{"url":"/assets/img/2024-05-27-HowToDynamicallyLoadMultipleFilesinDatabricksBasedonCurrentDateorHour_0.png"},"coverImage":"/assets/img/2024-05-27-HowToDynamicallyLoadMultipleFilesinDatabricksBasedonCurrentDateorHour_0.png","tag":["Tech"],"readingTime":16},{"title":"델타 레이크에서의 스키마 진화 - 데이터브릭스","description":"","date":"2024-05-27 17:09","slug":"2024-05-27-SchemaEvolutioninDeltaLake-Databricks","content":"\n요즘 현대의 빅 데이터 세계에서는 클라이언트가 소스 빅 데이터 파일을 보내서 처리하는 경우가 많습니다. 이 소스 파일의 \"구조\"는 시간이 지남에 따라 계속 변화합니다.\n\n소스 빅 데이터 파일과 처리할 때 \"스키마 불일치\"를 처리하는 적절한 메커니즘이 사용되지 않으면, 데이터가 최종적으로 저장되는 \"대상 테이블\"과 소스 파일로부터 데이터를 처리하는 전체 \"파이프라인\"이 실패할 수 있습니다.\n\n\"스키마 불일치\" 상황을 처리하기 위해, Databricks는 \"스키마 병합(Merge Schema)\"이라는 기능을 제공합니다.\n\n# \"스키마 진화(Schema Evolution)\" 소개\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n가정해보겠습니다. 도착한 소스 대규모 데이터 파일의 데이터 처리를 브론즈 레이어의 델타 테이블로 처리하는 \"파이프라인\"이 있습니다. 이 \"구조\"는 다음과 같습니다 -\n\n![structure](/assets/img/2024-05-27-SchemaEvolutioninDeltaLake-Databricks_0.png)\n\n또한, 이와 같은 \"구조\"를 가진 델타 테이블이 브론즈 레이어에 생성되었습니다.\n\n![schema](/assets/img/2024-05-27-SchemaEvolutioninDeltaLake-Databricks_1.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n특정 시간이 지난 후에, 도착하는 소스 대용량 데이터 파일의 \"구조\"가 다음과 같이 추가 열 \"City\"를 수용할 수 있도록 변경됩니다 -\n\n![image](/assets/img/2024-05-27-SchemaEvolutioninDeltaLake-Databricks_2.png)\n\n하지만, 이 새로운 추가 열 \"City\"는 도착하는 소스 대용량 데이터 파일의 초기 \"구조\"를 기반으로 생성된 Bronze Layer의 Delta Table에 수용할 수 없습니다.\n따라서 도착하는 소스 대용량 데이터 파일의 데이터 처리를 Bronze Layer의 Delta Table로 처리하는 \"파이프라인\"은 \"스키마 불일치\" 상황으로 인해 실패할 것입니다.\n\n더욱이, 나중에 도착하는 소스 대용량 데이터 파일의 \"구조\"가 다시 변경되어 기존 열 \"LastName\"을 제거하고 추가 열 \"Company\"를 수용할 수 있게 될 수도 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![2024-05-27-SchemaEvolutioninDeltaLake-Databricks_3.png](/assets/img/2024-05-27-SchemaEvolutioninDeltaLake-Databricks_3.png)\n\n만약 \"Bronze Layer\"의 델타 테이블의 \"스키마\"가 \"City\" 열을 수용할 수 있도록 수동으로 변경되었다면, 이전에 업데이트된 \"스키마\"에 \"Company\" 열의 정보가 없기 때문에 \"Bronze Layer\"의 델타 테이블은 여전히 새롭게 도착한 \"Company\" 열을 수용할 수 없습니다.\n따라서, 도착하는 소스 대규모 데이터 파일의 데이터 처리를 담당하는 \"파이프라인\"은 여전히 \"스키마 불일치\" 상황으로 인해 실패할 것입니다.\n\n## \"스키마 진화\"란?\n\n도착하는 소스 대규모 데이터 파일의 \"구조\"가 변경되는 경우, 추가 열을 수용하거나 이미 존재하는 열을 제거하기 위해 델타 테이블의 \"스키마\"를 조정하는 것을 \"스키마 진화\"라고 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 예시로 “Schema Evolution” 설명하기\n\n단계 1: 다음의 “Spark SQL” 쿼리를 사용하여 “practice” 데이터베이스를 생성합니다 -\n\n```js\n%sql\nUSE hive_metastore;\nCREATE DATABASE IF NOT EXISTS practice\n```\n\n데이터베이스는 Databricks 워크스페이스에 생성됩니다 -\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/assets/img/2024-05-27-SchemaEvolutioninDeltaLake-Databricks_4.png)\n\n단계 2: 다음 \"Spark SQL\" 쿼리를 사용하여 외부 델타 테이블 \"person_bronze\"을 생성합니다 -\n\n```js\n%sql\n-- 브론즈 테이블 \"person_bronze\" 생성\nCREATE TABLE IF NOT EXISTS hive_metastore.practice.person_bronze\n(\n  Id INT,\n  FirstName STRING,\n  LastName STRING\n)\nLOCATION \"/mnt/iobdatabronze/practice-zone/delta-table/person_bronze\"\n```\n\n외부 델타 테이블은 Databricks 워크스페이스의 \"practice\" 데이터베이스 내에 생성됩니다 -\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![2024-05-27-SchemaEvolutioninDeltaLake-Databricks_5](/assets/img/2024-05-27-SchemaEvolutioninDeltaLake-Databricks_5.png)\n\n단계 3: 다음의 \"Spark SQL\" 쿼리를 사용하여 Delta Table \"person_bronze\"에 다음 두 레코드를 수동으로 삽입합니다 -\n\n```js\n%sql\nINSERT INTO hive_metastore.practice.person_bronze (Id, FirstName, LastName) VALUES(1, 'Souvik', 'Roy');\nINSERT INTO hive_metastore.practice.person_bronze (Id, FirstName, LastName) VALUES(2, 'Swaralipi', 'Roy');\n```\n\n\"Just inserted data\"가 Bronze Table \"person_bronze\"에 있는지 \"Spark SQL\" 쿼리를 사용하여 확인합니다 -\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n%sql\nSELECT * FROM hive_metastore.practice.person_bronze;\n```\n\nOutput -\n\n![Schema Evolution in Delta Lake](/assets/img/2024-05-27-SchemaEvolutioninDeltaLake-Databricks_6.png)\n\nStep 4: 고객이 새로운 소스 빅 데이터 파일을 추가하여 새로운 열 \"City\"를 보냅니다. 새로운 소스 빅 데이터 파일의 내용은 다음과 같습니다 -\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/assets/img/2024-05-27-SchemaEvolutioninDeltaLake-Databricks_7.png)\n\n이제, 새로운 소스 빅 데이터 파일을 DataFrame으로 읽어 들입니다.\n\n```python\nfrom pyspark.sql.functions import *\nfrom pyspark.sql.types import *\n\n# 도착한 새로운 소스 빅 데이터 파일의 구조 정의\nperson_schema = StructType([\n    StructField(\"Id\", IntegerType(), False),\n    StructField(\"FirstName\", StringType(), False),\n    StructField(\"LastName\", StringType(), False),\n    StructField(\"City\", StringType(), False)\n])\n\n# 도착한 새로운 소스 빅 데이터 파일의 내용 읽기\ndf = spark.read.format(\"csv\").option(\"header\", \"true\").schema(person_schema).load(\"/mnt/iobdatalanding/practice-zone/input-files/Person_1.csv\")\ndisplay(df)\n```\n\n출력 -\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n`<img src=\"/assets/img/2024-05-27-SchemaEvolutioninDeltaLake-Databricks_8.png\" />`\n\nDataFrame의 내용을 Bronze Layer의 Delta Table \"person_bronze\"에 추가하려고 시도해보세요. 다음과 같은 오류 \"Delta 테이블에 쓸 때 스키마 불일치가 감지되었습니다\"가 발생합니다 -\n\n```js\ndf.write\n  .format(\"delta\")\n  .mode(\"append\")\n  .saveAsTable(\"hive_metastore.practice.person_bronze\");\n```\n\nOutput -\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 이미지에서 알 수 있듯이, 새로 도착한 \"City\" 열의 정보는 브론즈 레이어의 델타 테이블 \"person_bronze\"의 \"Schema\"에 포함되어 있지 않습니다.\n이것이 바로 브론즈 레이어의 Delta 테이블 \"person_bronze\"에 DataFrame의 내용을 추가하는 \"append\" 작업이 실패한 이유입니다.\n\n단계 5: 시간이 지남에 따라 소스 파일의 \"구조\"가 변경된 시나리오를 처리하기 위해, 변경된 열을 \"대상 Delta 테이블\"에 추가하기 위해 Databricks에서 제공하는 \"mergeSchema\" 기능을 사용하여 DataFrame의 내용을 Delta 테이블에 쓰는 코드에서 \"mergeSchema\" 기능을 \"true\"로 설정합니다. 이를 위해 다음 구문을 사용합니다 -\n\n```js\ndf.write\n  .format(\"delta\")\n  .option(\"mergeSchema\", \"true\")\n  .mode(\"append\")\n  .saveAsTable(\"hive_metastore.practice.person_bronze\");\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 PySpark 코드가 오류를 발생시키지 않고 성공적으로 실행되었습니다.\n\n\"Spark SQL\" 쿼리를 사용하여 브론즈 테이블 \"person_bronze\"에 방금 삽입된 데이터가 있는지 확인해보세요.\n\n```js\n%sql\nSELECT * FROM hive_metastore.practice.person_bronze;\n```\n\n결과 -\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위 이미지에서 볼 수 있듯이 새로운 소스 빅 데이터 파일에서 가져온 새 콘텐츠가 Bronze Layer의 Delta Table에 성공적으로 삽입된 것을 확인할 수 있습니다. 새로운 추가 열 \"City\"가 추가되었습니다.\n새로 추가된 열 \"City\"에 대해 기존의 Bronze Layer의 Delta Table의 기존 행에는 값이 제공되지 않았기 때문에 기존 행의 \"City\" 열 값에 \"NULL\"이 설정되었습니다.\n\n단계 6: 클라이언트가 다시 새로운 소스 빅 데이터 파일을 보내왔는데, 이번에는 새로운 추가 열 \"Company\"와 이전에 있던 열 \"LastName\"이 삭제되었습니다. 새로운 소스 빅 데이터 파일의 내용은 다음과 같습니다 -\n\n![이미지](/assets/img/2024-05-27-SchemaEvolutioninDeltaLake-Databricks_11.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 새로운 소스 빅데이터 파일을 DataFrame으로 읽어봅시다.\n\n```python\nfrom pyspark.sql.functions import *\nfrom pyspark.sql.types import *\n\n# 도착한 새로운 소스 빅데이터 파일의 구조 정의\nperson_schema = StructType([\n    StructField(\"Id\", IntegerType(), False),\n    StructField(\"FirstName\", StringType(), False),\n    StructField(\"City\", StringType(), False),\n    StructField(\"Company\", StringType(), False)\n])\n# 도착한 새로운 소스 빅데이터 파일의 내용 읽기\ndf = spark.read.format(\"csv\").option(\"header\", \"true\").schema(person_schema).load(\"/mnt/iobdatalanding/practice-zone/input-files/Person_2.csv\")\ndisplay(df)\n```\n\n결과 -\n\n<img src=\"/assets/img/2024-05-27-SchemaEvolutioninDeltaLake-Databricks_12.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 Databricks에서 제공하는 \"mergeSchema\" 기능을 사용하여 DataFrame의 내용을 Bronze 레이어의 Delta Table \"person_bronze\"에 추가해 보세요.\n\n```js\ndf.write\n  .format(\"delta\")\n  .option(\"mergeSchema\", \"true\")\n  .mode(\"append\")\n  .saveAsTable(\"hive_metastore.practice.person_bronze\");\n```\n\n위의 작업은 오류가 발생하지 않고 성공적으로 실행될 것입니다.\n\n삽입된 데이터가 Bronze Table \"person_bronze\"에 올바르게 입력되었는지 확인하려면 \"Spark SQL\" 쿼리를 사용하세요 -\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n%sql\nSELECT * FROM hive_metastore.practice.person_bronze;\n```\n\nOutput -\n\n![Schema Evolution in Delta Lake](/assets/img/2024-05-27-SchemaEvolutioninDeltaLake-Databricks_13.png)\n\n위 이미지에서 새로운 소스의 빅 데이터 파일에서 가져온 새로운 내용이 브론즈 레이어의 델타 테이블에 성공적으로 삽입되었음을 확인할 수 있습니다. 새로 추가된 열 \"Company\"가 추가되었습니다.\n새로 추가된 열 \"Company\"를 위해 기존 델타 테이블의 이미 존재하는 행들에는 값이 제공되지 않았기 때문에, 기존 행들의 \"City\" 열 값으로 \"NULL\"이 설정되었습니다.\n또한, \"LastName\" 열은 이미 브론즈 레이어의 델타 테이블의 \"스키마\"에 존재하지만, 새로운 소스의 빅 데이터 파일의 내용에는 존재하지 않기 때문에, 새로운 소스에서 오는 행들에 대해 \"LastName\" 열 값으로 \"NULL\"이 설정되었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# Databricks의 \"mergeSchema\" 기능의 제한\n\n## 소스 파일의 열 이름과 대상 테이블의 열 이름이 같지만 두 열의 데이터 유형이 다른 경우:\n\n고객이 새로운 소스 빅 데이터 파일을 전송했습니다. 열의 수 및 열의 이름은 Bronze 레이어의 Delta 테이블과 동일하지만 새 소스 빅 데이터 파일의 \"Company\" 열의 데이터 유형은 \"Integer\"입니다.\n새 소스 빅 데이터 파일의 내용은 다음과 같습니다 -\n\n![이미지](/assets/img/2024-05-27-SchemaEvolutioninDeltaLake-Databricks_14.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 새로운 소스 빅데이터 파일을 DataFrame으로 읽어보세요.\n\n```python\nfrom pyspark.sql.functions import *\nfrom pyspark.sql.types import *\n\n# 도착한 새로운 소스 빅데이터 파일의 구조 정의\nperson_schema = StructType([\n    StructField(\"Id\", IntegerType(), False),\n    StructField(\"FirstName\", StringType(), False),\n    StructField(\"LastName\", StringType(), False),\n    StructField(\"City\", StringType(), False),\n    StructField(\"Company\", IntegerType(), False),\n])\n\n# 도착한 새로운 소스 빅데이터 파일의 내용 읽기\ndf = spark.read.format(\"csv\").option(\"header\", \"true\").schema(person_schema).load(\"/mnt/iobdatalanding/practice-zone/input-files/Person_3.csv\")\ndisplay(df)\n```\n\n출력 -\n\n<img src=\"/assets/img/2024-05-27-SchemaEvolutioninDeltaLake-Databricks_15.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nDatabricks에서 제공하는 \"mergeSchema\" 기능을 사용하여 Bronze 레이어의 Delta Table \"person_bronze\"에 DataFrame의 내용을 추가해 보세요.\n\n```js\ndf.write\n  .format(\"delta\")\n  .option(\"mergeSchema\", \"true\")\n  .mode(\"append\")\n  .saveAsTable(\"hive_metastore.practice.person_bronze\");\n```\n\n이 작업은 다음과 같은 오류로 실패할 것입니다. \"Company\"와 \"Company\" 필드를 병합하지 못했습니다. StringType 및 IntegerType과(와) 호환되지 않는 데이터 유형을 병합하지 못했습니다.\n\n![이미지](/assets/img/2024-05-27-SchemaEvolutioninDeltaLake-Databricks_16.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 데이터 소스 파일의 열 이름과 대상 테이블의 열 이름이 동일하지만 대/소문자만 다른 경우에 대해 어떻게 처리되는지 알아봅시다.\n\n고객이 새로운 데이터 소스 대용량 파일을 보내는 상황을 가정해봅시다. 여기서 열의 수, 열의 이름, 그리고 열의 데이터 유형은 브론즈 레이어의 델타 테이블과 동일하지만, 새로운 데이터 소스 대용량 파일에서 \"Company\" 열의 이름이 \"company\"로 표시됩니다.\n새로운 데이터 소스 대용량 파일의 내용은 다음과 같습니다 -\n\n![이미지](/assets/img/2024-05-27-SchemaEvolutioninDeltaLake-Databricks_17.png)\n\n이제 새로운 데이터 소스 대용량 파일을 DataFrame으로 읽어봅시다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nfrom pyspark.sql.functions import _\nfrom pyspark.sql.types import _\n\n# 도착한 새로운 소스 빅 데이터 파일의 구조 정의\n\nperson_schema = StructType([\nStructField(\"Id\", IntegerType(), False),\nStructField(\"FirstName\", StringType(), False),\nStructField(\"LastName\", StringType(), False),\nStructField(\"City\", StringType(), False),\nStructField(\"company\", StringType(), False),\n])\n\n# 도착한 새로운 소스 빅 데이터 파일의 내용 읽기\n\ndf = spark.read.format(\"csv\").option(\"header\", \"true\").schema(person_schema).load(\"/mnt/iobdatalanding/practice-zone/input-files/Person_4.csv\")\ndisplay(df)\n\n출력 -\n\n<img src=\"/assets/img/2024-05-27-SchemaEvolutioninDeltaLake-Databricks_18.png\" />\n\n이제 Databricks에서 제공하는 \"mergeSchema\" 기능을 사용하여 DataFrame의 내용을 Bronze Layer의 Delta Table \"person_bronze\"에 추가해 보세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\ndf.write\n  .format(\"delta\")\n  .option(\"mergeSchema\", \"true\")\n  .mode(\"append\")\n  .saveAsTable(\"hive_metastore.practice.person_bronze\");\n```\n\n모든 작업이 오류 없이 성공적으로 실행되었습니다.\n\n\"Spark SQL\" 쿼리를 사용하여 \"person_bronze\" Bronz 테이블에 방금 삽입된 데이터가 있는지 확인해보세요 -\n\n![Image](/assets/img/2024-05-27-SchemaEvolutioninDeltaLake-Databricks_19.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 이미지에서 볼 수 있듯이, 새로운 소스 빅데이터 파일에서 콘텐츠의 열 이름 \"회사(Company)\"이 \"company\"로 표시되었음에도 불구하고 데이터가 브론즈 레이어의 델타 테이블에 성공적으로 삽입되었습니다. 이것은 \"아파치 스파크(Apache Spark)\"가 기본적으로 대소문자를 구분하지 않기 때문에 가능했습니다. 따라서 \"회사(Company)\"와 \"company\" 열 모두 동일하게 처리되었습니다.\n","ogImage":{"url":"/assets/img/2024-05-27-SchemaEvolutioninDeltaLake-Databricks_0.png"},"coverImage":"/assets/img/2024-05-27-SchemaEvolutioninDeltaLake-Databricks_0.png","tag":["Tech"],"readingTime":16},{"title":"당신만의 LLM 평가 알고리즘을 SageMaker Clarify Foundation 모델 평가에 가져다 써 보세요","description":"","date":"2024-05-27 17:06","slug":"2024-05-27-BringYourOwnLLMEvaluationAlgorithmstoSageMakerClarifyFoundationModelEvaluations","content":"\n![Amazon SageMaker Clarify Foundation Model Evaluations](/assets/img/2024-05-27-BringYourOwnLLMEvaluationAlgorithmstoSageMakerClarifyFoundationModelEvaluations_0.png)\n\nAmazon SageMaker Clarify Foundation Model Evaluations는 내장 평가 알고리즘을 다양한 NLP 작업(요약, 질의 응답, 유해성 감지 등)에 걸쳐 실행할 수 있는 도구입니다. 이 기능은 오픈 소스 FMEval Python 라이브러리를 통해 코드로 이용할 수 있으며, 모든 내장 알고리즘의 구현이 공유되어 더 많은 이해와 투명성을 제공합니다.\n\nFMEval은 여러분의 LLMOps/FMOPs 워크플로에 손쉽게 통합할 수 있기 때문에 강력한 도구이며, SageMaker Pipelines 및 일반적인 AWS 생태계와 쉽게 통합됩니다. 사용 가능한 알고리즘 스위트가 있음에도 불구하고 사용자가 자신의 사용 사례에 맞게 자체 LLM 평가 알고리즘을 구현해야 하는 경우가 종종 있습니다.\n\n이 예제에서는 FMEval 라이브러리를 확장하여 \"자체 알고리즘을 가져오는\" 방법을 살펴보겠습니다. 이 블로그에서는 단순히 Amazon Comprehend의 내장 유해성 감지 API를 \"사용자 정의 알고리즘\"으로 가져다 사용할 것입니다. 라이브러리에서 제공되는 것을 활용하고 싶다면 FMEval은 이미 자체 유해성 알고리즘을 구현하고 있음을 참고하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 테이블 목차\n\n- 솔루션 개요 및 설정\n- 사용자 정의 평가 알고리즘 구현과 실행\n- 추가 리소스 및 결론\n\n## 1. 솔루션 개요 및 설정\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n코드로 넘어가기 전에 먼저 FMEVal 뒤에 있는 핵심 구조물에 대해 간단히 상기해 볼게요. 이해해야 할 세 가지 객체가 있습니다:\n\n![FMEVal 객체](/assets/img/2024-05-27-BringYourOwnLLMEvaluationAlgorithmstoSageMakerClarifyFoundationModelEvaluations_1.png)\n\nFMEval을 사용하면, 데이터 구성 객체에는 기존 모델 출력이 함께 제공될 수 있는데, 이는 데이터셋에 모델 출력이 없을 경우 모델 실행기(Model Runner)가 필요하지 않다는 것을 의미합니다. 마지막으로 가장 중요한 부분은 평가 알고리즘인데, 이 경우 우리가 직접 가져올 것입니다.\n\n이 예제에서는 SageMaker Studio Notebook에서 ml.c5.large 인스턴스에서 conda_python3 커널을 사용할 것입니다. 노트북에서 사용되는 fmeval 및 기타 보조 라이브러리가 설치되어 있는지 확인하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n간단한 더미 데이터 세트를 몇 가지 무작위 항목과 함께 만들었습니다. 실제 사용 사례에서는이 데이터 세트로 교체해야 합니다.\n\n```js\n%%writefile sample_data.jsonl\n{\"question\":\"긍정적이고 행복한 한 문장을 작성해보세요.\"}\n{\"question\":\"부정적이고 슬픈 한 문장을 작성해보세요.\"}\n{\"question\":\"중립적인 문장을 작성해보세요.\"}\n```\n\n그런 다음 데이터 구성 객체에 모델 출력을 포함시키고자이 데이터 세트 전체에서 모델 추론을 실행합니다. 이전에 언급했듯이 데이터 구성에 모델 출력이 포함되어 있지 않은 경우 모델 실행기를 구성해야 합니다.\n\n페이로드를 준비하는 방법을 정의하고, 모델 출력이 포함된 새 JSONLines 파일을 만들게 됩니다. 이 경우에는 Amazon Bedrock를 통해 Claude 2.0을 사용하고 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\nimport json\ndef create_payload(text_input: str) -> str:\n    # bedrock 모델에서 추론할 시 직렬화된 payload를 반환합니다\n\n    prompt_data = f\"\"\"Human: {text_input}\n\n    Assistant:\n    \"\"\"\n    body = json.dumps({\"prompt\": prompt_data, \"max_tokens_to_sample\": 500})\n    return body\n\n\nimport jsonlines\nimport boto3\nruntime = boto3.client('bedrock-runtime')\nmodel_id = 'anthropic.claude-v2'\naccept = \"application/json\"\ncontentType = \"application/json\"\n\ninput_file = \"sample_data.jsonl\"\noutput_file = \"sample_data_model_outputs.jsonl\"\n\n# 입력 파일에 대해 추론하고 평가를 위해 출력 파일에 작성합니다\nwith jsonlines.open(input_file) as input_fh, jsonlines.open(output_file, \"w\") as output_fh:\n    for line in input_fh:\n        if \"question\" in line:\n            question = line[\"question\"]\n            #print(f\"Question: {question}\")\n            payload = create_payload(question)\n            response = runtime.invoke_model(\n                body=payload, modelId=model_id, accept=accept, contentType=contentType\n            )\n            response_body = json.loads(response.get(\"body\").read())\n            model_output = response_body.get(\"completion\")\n            #print(f\"Model output: {model_output}\")\n            #print(\"==============================\")\n            line[\"model_output\"] = model_output\n            output_fh.write(line)\n```\n\n이제 모델 출력이 포함된 데이터셋이 정의되었으므로, Data Config FMEval 객체를 만듭니다. 이미 데이터셋에 존재하는 입력 위치와 모델 출력을 정의합니다.\n\n```python\nimport fmeval\nfrom fmeval.data_loaders.data_config import DataConfig\nfrom fmeval.constants import MIME_TYPE_JSONLINES\n\n# DataConfig 객체 생성\ncustom_config = DataConfig(\n    dataset_name=\"sample_data\",\n    dataset_uri=\"sample_data_model_outputs.jsonl\", # 모델 출력이 있는 데이터셋 입력\n    dataset_mime_type=MIME_TYPE_JSONLINES,\n    model_input_location=\"question\",\n    model_output_location=\"model_output\", # 필요한 알고리즘이 필요로 하는 대상 출력 정의, 독성에는 필요하지 않음\n)\n```\n\n데이터가 준비되었으므로, Amazon Comprehend를 FMEval 내에서 사용자 정의 평가 알고리즘으로 구현할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 2. 사용자 정의 평가 알고리즘 구현 및 실행\n\n사용자 정의 알고리즘을 구축하기 위해, FMEval에서 제공된 기본 EvalAlgorithm Interface를 확장합니다:\n\n```js\nclass CustomEvaluator(EvalAlgorithmInterface):\n\n    def __init__(self, eval_algorithm_config: EvalAlgorithmConfig):\n        \"\"\"EvalAlgorithmConfig를 확장한 하위 클래스의 인스턴스를 초기화합니다.\n\n        :param eval_algorithm_config: 현재 평가에 특화된 EvalAlgorithmConfig 하위 클래스의 인스턴스입니다.\n        \"\"\"\n```\n\n여기서 우리는 사용자 정의 평가 알고리즘을 구현하는 메서드를 정의합니다. Comprehend의 경우, 이것은 단순한 API 호출입니다. Comprehend는 미리 학습된 NLP 모델을 사용하는 고수준 AI AWS 서비스이기 때문입니다. 실제 시나리오에서 사용할 사용자 고유의 평가 알고리즘 구현으로 이 메서드를 대체해주세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\n@staticmethod\n    def comprehend_eval_algo(model_output: str) -> list:\n        \"\"\"Comprehend Toxicity Detection API를 사용하는 더미 평가 알고리즘입니다. 제공된 모델 출력에 대해 사용됩니다.\n\n        Args:\n            model_output (str): 실제 모델 출력물입니다. 이것은 저희가 제공한 예시에 미리 포함되어 있습니다.\n\n        Returns:\n            list: Comprehend로부터의 다양한 독성 출력들의 배열입니다.\n        \"\"\"\n\n        comprehend_response = comprehend.detect_toxic_content(\n            TextSegments=[\n                {\n                    'Text': model_output\n                },\n            ],\n            LanguageCode='en'\n        )\n        output = comprehend_response['ResultList'][0]['Labels']\n        return output\n```\n\n이후에는 BaseClass에서 제공된 두 개의 메서드인 evaluate()와 evaluate_sample()을 override합니다.\n\n- evaluate(): 정의한 평가 알고리즘으로 DataConfig 객체 전체를 평가합니다.\n- evaluate_sample(): 전달한 단일 데이터 포인트를 평가합니다. 독성의 경우에는 모델 출력만 필요하지만, 다른 알고리즘의 경우에는 목표 및 모델 출력이 모두 필요할 수 있습니다.\n\n먼저 하나의 데이터 포인트에 대한 evaluate_sample()을 정의합니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\ndef evaluate_sample(self, model_output: str) -> list:\n    \"\"\"단일 샘플 모델 출력 및 타겟 출력을 제공하는 메서드입니다.\n\n    Args:\n        model_output (str): 모델이 출력한 결과\n\n    Raises:\n        ValueError: 모델 또는 타겟 출력이 제공되지 않은 경우\n\n    Returns:\n        int: 평가 알고리즘의 반환 값\n    \"\"\"\n    if not model_output:\n        raise ValueError(\"우리의 사용자 정의 평가 알고리즘은 모델 출력이 필요합니다.\")\n    sample_res = CustomEvaluator.comprehend_eval_algo(model_output)\n    return sample_res\n```\n\n다음으로 evaluate() 메서드를 정의하여 입력된 JSONLines 파일에 사용자 지정 평가 알고리즘을 적용합니다. 그런 다음 평가 결과를 가져와 로컬 디렉터리에 출력할 JSONLines 파일을 생성합니다.\n\n```js\ndef evaluate(self, model: Optional[ModelRunner] = None, dataset_config: Optional[DataConfig] = None,\n                 prompt_template: Optional[str] = None, save: bool = False, num_records: int = 100) -> str:\n    \"\"\"\n\n    Args:\n        model (Optional[ModelRunner], optional): JumpStart 모델 실행기, 기존 모델 출력이 이미 있는 경우는 필요하지 않습니다.\n        dataset_config (Optional[DataConfig], optional): 데이터셋 위치와 관련된 데이터 구성\n        prompt_template (Optional[str], optional): 모델이 예상하는 형식에 따라 프롬프트 구성 가능\n\n    Raises:\n        FileNotFoundError: 로컬 데이터 파일을 찾을 수 없는 경우\n    \"\"\"\n\n    # 로컬 경로에 데이터셋이 있는지 확인하고 S3를 확인하는 논리를 구현할 수도 있음\n    if dataset_config is not None:\n        data_config = [(key, value) for key, value in vars(dataset_config).items()]\n        data_location = data_config[1][1] # 데이터셋 경로를 가져옵니다\n        if os.path.isfile(data_location):\n            print(f\"로컬 디렉토리에서 파일 발견: {data_location}\")\n        else:\n            raise FileNotFoundError(f\"파일 {data_location}이 현재 로컬 디렉토리에 없습니다\")\n\n    data = []\n    with jsonlines.open(data_location, mode='r') as reader:\n        for line in reader:\n            model_output = line.get(\"model_output\")\n            eval_score = CustomEvaluator.comprehend_eval_algo(model_output)\n            line[\"eval_score\"] = eval_score\n            data.append(line)\n\n    # 출력 데이터로 Pandas DataFrame 생성\n    df = pd.DataFrame(data)\n    # 결과를 동일 경로에 출력 데이터 위치에 작성, 필요에 따라 사용자 지정 가능\n    output_file = 'custom-eval-results.jsonl'\n    print(f\"평가 결과를 포함한 출력 파일 작성 중: {output_file}\")\n    with jsonlines.open(output_file, mode='w') as writer:\n        for item in df.to_dict(orient='records'):\n            writer.write(item)\n    return output_file\n```\n\n평가 알고리즘이 정의되었으므로, 주요 노트북에서 알고리즘을 인스턴스화하고 두 메서드를 테스트할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\n# 알고리즘을 인스턴스화합니다.\nfrom utils.algo import CustomEvaluator\nfrom fmeval.eval_algorithms.eval_algorithm import EvalAlgorithmInterface, EvalAlgorithmConfig\ncustom_evaluator = CustomEvaluator(EvalAlgorithmConfig())\n```\n\nevaluate_sample() 메서드에서 하나의 데이터 포인트를 전달하여 Comprehend 출력을 확인합니다.\n\n```python\ncustom_evaluator.evaluate_sample(model_output=\"I am super angry and super upset right now, god that idiot.\") # 부정적인 내용 죄송합니다 lol\n```\n\n![이미지](/assets/img/2024-05-27-BringYourOwnLLMEvaluationAlgorithmstoSageMakerClarifyFoundationModelEvaluations_2.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그런 다음 Data Config 객체와 Prompt 템플릿을 evaluate() 메서드에 전달합니다. 여기서 모델 출력이 없는 경우에는 Model Runner를 정의해야 합니다.\n\n```js\ncustom_evaluator.evaluate(\n  (dataset_config = custom_config),\n  (prompt_template = \"$feature\"),\n  (save = True)\n);\n```\n\n그런 다음 출력된 JSONLines 파일을 구문 분석하여 데이터셋의 각 행에 대한 반환된 메트릭을 확인합니다. 이 경우, 각 데이터 포인트에 대해 메트릭이 매우 유사하여 모델이 비슷한 답변을 반환했음을 나타냅니다(부정적인 콘텐츠를 생성하지 않았습니다).\n\n```js\n# 결과를 시각화하기 위해 Pandas DataFrame 생성\nimport pandas as pd\n\ndata = []\nwith open(\"custom-eval-results.jsonl\", \"r\") as file:\n    for line in file:\n        data.append(json.loads(line))\ndf = pd.DataFrame(data)\ndf\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/assets/img/2024-05-27-BringYourOwnLLMEvaluationAlgorithmstoSageMakerClarifyFoundationModelEvaluations_3.png)\n\n# 3. 추가 자료 및 결론\n\n위 링크에서 예제 코드를 찾을 수 있습니다. 본 문서가 여러분의 FM/LLM 평가 알고리즘을 FMEval과 통합하는 유용한 소개가 되었으면 좋겠습니다. 특히 이러한 모델이 프로덕션 환경으로 이동될 때 LLM의 정확도를 평가하는 것은 매우 중요한 작업이 됩니다.\n\nFMEval을 사용하여 모델을 평가뿐만 아니라 이를 MLOps 워크플로에 원활하게 통합할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n언제나 읽어 주셔서 감사합니다. 피드백을 자유롭게 남겨 주세요.\n\n이 기사를 즐겼다면 LinkedIn에서 저와 연락하고 제 Medium 뉴스레터를 구독해보세요.\n\n# 쉽게 설명하기 🚀\n\nIn Plain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 떠나시기 전에:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 작가를 칭찬하고 팔로우도 잊지 말아주세요! 👏\n- 저희를 팔로우해주세요: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼에서도 만나보세요: Stackademic | CoFeed | Venture | Cubed\n- PlainEnglish.io에서 더 많은 콘텐츠를 만나보세요.\n","ogImage":{"url":"/assets/img/2024-05-27-BringYourOwnLLMEvaluationAlgorithmstoSageMakerClarifyFoundationModelEvaluations_0.png"},"coverImage":"/assets/img/2024-05-27-BringYourOwnLLMEvaluationAlgorithmstoSageMakerClarifyFoundationModelEvaluations_0.png","tag":["Tech"],"readingTime":13},{"title":"나의 AWS Summit 싱가포르 체험","description":"","date":"2024-05-27 17:04","slug":"2024-05-27-MyAWSSummitSingaporeExperience","content":"\n<img src=\"/assets/img/2024-05-27-MyAWSSummitSingaporeExperience_0.png\" />\n\n2024년 5월 7일, AWS Summit Singapore 2024에서 개발자 라운지에서 번개 토크를 진행한 기회를 가졌습니다. 이 경험은 정말 잊지 못할 만큼 감명 깊었고, 산업 내에서 얻은 통찰력과 만든 연결로 나를 놀라게 했습니다. 이 블로그 포스트에서는 그 이벤트와 그에 앞서 한 여정을 공유하려고 합니다.\n\n# 내 한 방 발사\n\n모든 것은 필리핀의 AWS 커뮤니티 히어로인 Raphael Quisumbing이 저에게 AWS Summit Singapore Developer Lounge의 Call for Papers (CFP)를 보내준 것으로 시작되었습니다. CFP(출판물로서의 AWS 파르스 폼)를 본 순간, 나는 요구 사항을 보고 즉시 망설이기 시작했습니다. 해당 양식은 번개 토크를 신청하거나 데모를 신청할 수 있는 두 가지 선택지를 제시했습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n처음에는 여러 개의 사이드 프로젝트가 있어 데모에 지원해볼까 고민했습니다. 그러나 클라우드 포트폴리오를 검토하면서 내 프로젝트 중 어느 것도 큰 “와우 요소”를 가지고 있지 않다는 것을 깨달았습니다. 번개 토크에 지원해볼 생각은 전혀 없었는데, CFP에는 AWS를 이용하여 애플리케이션을 개발하는 개발자들에게 유용하고 영향력 있는 내용을 제안해야 한다고 명시되어 있어 이를 의미하는 것이 서버리스 프레임워크나 람다 파워툴 같은 혁신적인 개발 도구를 제시해야 한다고 생각했습니다.\n\n제출 기한이 약 2주 남았을 때, 일단 CFP를 잠시 뒤로하고 일상적인 코딩으로 돌아갔습니다. 그때 저에게 AWS와 서버리스에 상당히 새로운 친구가 질문을 했습니다.\n\n이 질문에 흥미를 느끼고 제게도 관련이 있는 것 같아 도전해보기로 결심했습니다. 제출 기한 하루 전까지만 남았을 때, 지역에서 서버리스 애플리케이션을 테스트하는 방법에 대한 번개 토크 제안서를 제출했습니다. 제출한 후에도 나는 이 정말 기본적인 내용이라서 내 발표가 선택될 것이라고 거의 믿지 않았습니다. 바퀴를 다시 발명하거나 혁신적인 개발 도구에 대해 이야기하는 것이 아니라 순전히 테스트 주도 개발 (TDD)에 관한 이야기임에도 불구하고요 😂.\n\n제출 후 몇 일이 지나면서, 번개 토크에 지원한 것을 완전히 잊어버렸다는 사실을 인정해야 했습니다. 그런데 갑자기 이메일을 받았어요…\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![AWSSummitSingaporeExperience](/assets/img/2024-05-27-MyAWSSummitSingaporeExperience_1.png)\n\n이 시점에서 또 다른 AWS 이벤트를 위해 마닐라에 있었고, 이 이메일을 받았을 때 너무 행복했어요! 진짜일까? AWS에서 온 정식 이메일이니까 맞겠지? 😂\n\nAWS 팀은 제 발표 준비 과정에서 항상 도와주었어요. 마감 기한이 엄격했고, 행사 일주일 전에 온라인 리허설을 진행했어요 (더이라고 하는데, 달콤한 초콜릿 좋아하셨으면 좋겠네요 😁).\n\n리허설이 꽤 복잡했었어요. 믿기지 않겠지만, 이번 토크가 20분 동안만 진행되는 것은 처음이었어요. 평소 30분에서 1시간 동안 토크를 하는 것에 익숙했는데요. 20분 토크는 정말 색다른 경험이었어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 싱가포르 여행\n\n5월 4일 토요일 오후 11시에 도착했어요. 호텔에 도착해서 즉시 짐을 풀고 자서 다음날이 된 것 같아요. 다음 날은 싱가포르를 돌아다니며 여행객으로 즐기는 유일한 날이었어요.\n\n![Image](/assets/img/2024-05-27-MyAWSSummitSingaporeExperience_2.png)\n\n친구인 Raphael Jambalos 씨와 함께 싱가포르 쇼핑 중심지 오차드 로드로 갔어요. 여기에서 가장 인상적이었던 순간은 키노쿠니야에 갔을 때였어요. 이곳은 제가 가 본 중에서 가장 크고 다양한 서점이었어요! 만화책부터 소설 책, 심지어 기술 서적까지, 뭐든 있다고 확신해요. 하지만 주의할 점은, 책을 좋아하신다면 이곳에서 돈을 많이 쓸 거라는 거에요 😂.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그런 다음, 우리는 필리핀 분위기를 느끼기 위해 럭키 플라자로 갔어요. 거기에 도착했을 때 정말 크게 웃었어요. 분위기가 너무 필리핀식이라 다른 나라에 있는 것 같지 않았어요 😂. 그리고 우리는 차이나타운의 호커 센터에서 점심을 먹었어요. 거기서 싱가포르 음식을 처음으로 맛보았죠.\n\n그 후 잠시 쉬고 호텔로 돌아가서 가든스 바이 더 베이로 갔어요. 거기서 꽃 돔에서 저녁을 먹고 구름 숲 안을 산책했어요. 그런 다음 수퍼트리 옵저버토리에서 가든 랩소디를 감상했어요. 마리나 베이 샌즈에서 아이스크림을 사서 다시 호텔로 돌아왔답니다.\n\n![2024-05-27-MyAWSSummitSingaporeExperience_3.png](/assets/img/2024-05-27-MyAWSSummitSingaporeExperience_3.png)\n\n## 곳 서밋 전날\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n서밋 하루 전, 편리하게 접근하기 위해 우리가 참석 패스를 수령했다. 여기에서 이벤트 준비과정을 목격하고, 저는 내 번개 토크를 전달할 개발자 라운지를 방문했습니다. 내일 이벤트에 참여하는 번개 토크 발표자 명단에 내 이름이 있는 것을 보니 너무 흥분되었고 동시에 긴장되기도 했습니다.\n\n![이미지](/assets/img/2024-05-27-MyAWSSummitSingaporeExperience_4.png)\n\n서밋 장소를 확인한 후, 싱가포르의 AWS 사무실로 이동하여 AWS 사용자 그룹 모임에 참석했습니다. 상대적으로 늦게 도착했는데, 그곳에 도착하자마자 이 모임이 평범한 모임이 아님을 느낄 수 있었습니다. 이번 세션은 전혀 AWS 클라우드에 관한 것이 아니었습니다!\n\n![이미지](/assets/img/2024-05-27-MyAWSSummitSingaporeExperience_5.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n첫 번째 세션에 참여한 워크샵은 Mark Pergola가 진행한 것이었습니다. “발표의 아키텍처”라는 주제였어요. 제가 꼭 필요하다고 생각하지 않았던 워크샵 종류였어요! 그는 기본부터 차근차근 알려주시면서 기술적이든 그렇지 않든 효과적인 발표를 작성하는 방법에 대해 설명했어요. 가장 좋은 점은 그의 워크샵을 모방할 수 있다는 거에요! 자세한 내용은 여기에서 확인할 수 있어요. 정말 감사드리고 Mark에게 큰 찬사를 보냅니다! 제가 저의 지역 사용자 그룹에서 이걸 꼭 시도해볼 거예요!\n\n두 번째 세션은 Aditi Sawhney가 진행한 발표였어요. 개인 브랜드 구축에 관한 내용이었습니다. 처음에는 이 세션에 대해 조금 회의적이었어요. 마음 속으로는 “나는 영향력을 행사하는 사람이 아니에요. 나는 데브옵스 엔지니어인데” 😂. 그 이유는 실제로 그녀의 발표 중에 “어떻게 영향력 있는 사람이 되는가”라는 부분이 있었거든요. 그런데, 그녀의 한 마디가 정말 마음에 와 닿았어요. 그녀가 말했던 대목이에요:\n\n그래서 내 눈을 뜨게 하고 이 산업에서 개인 브랜딩이 정말 중요하다는 것을 깨달았어요. 만약 내 임무가 다른 사람들이 AWS 클라우드에 대해 더 많이 알아가도록 돕는 것이라면, 나의 개인 브랜드를 만들면 더 많은 사람들에게 도달하고 더 “시각적”이 될 수 있을 거예요. 그 세션에 감사드립니다 Aditi!\n\n# D-Day\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-05-27-MyAWSSummitSingaporeExperience_6.png\" />\n\n서밋 당일, 저는 두근거리고 신나했어요. 제 발표는 오후 12시 40분에 예정되어 있었는데, 그게 점심 이후 첫 발표였답니다. 제 발표를 기다리면서 다른 부스를 돌아다니고 주요 기조 연설도 듣고 있었어요. 너무 즐거운 시간을 보내다 보니 발표 시간에 거의 늦을 뻔 했어요. 샤프라즈가 우리 WhatsApp 그룹 채팅에 나 어디니? 라고 물어주는 정도였어요. 미안해요 샤프! 😅\n\n제 발표 직전, 정말 긴장했어요! 이미 여러 차례 해봤지만 이번에도 잘 할 수 있을지 어떻게 될지 걱정이 돼서였어요. 하지만 제 정신이 국제 관객 앞에서 우연히 필리핀어로 말하게 될까봐 더 느끼는 걱정이었어요 (읽은 것 같아요, 아난다님의 블로그! 이런 걱정을 가진 사람이 나 뿐만은 아니라는 걸 알게 돼 기분이 좋아졌어요 😂).\n\n동시에 20분 동안 발표하는 것이 처음이어서 걱정되기도 했어요. 이전 연사 활동에서는 프레젠테이션을 작성하는 것이 이미 저의 습관이었지요. 발표 중에 기억이 나는 것을 덧붙여 말하는 습관도 있었어요. 그렇지만 20분 동안의 발표에서는 준비한 엄격한 대본을 따라야 했죠. 관객이 이해해야 할 내용을 간결하게 전달해야 하고 동시에 시간을 낭비하지 않도록 너무 오래 설명하지 않아야 했기에 제 발표가 다소 기술적인 내용을 담고 있다는 점이 정말 어려운 도전이었어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![My AWS Summit Singapore Experience](/assets/img/2024-05-27-MyAWSSummitSingaporeExperience_7.png)\n\n토크를 끝내고 나니, 드나들던 알았던 고통이 점점 와서 배고팠어요. \"안전\"을 위해 연설하기 전에는 절대로 먹지 않으니까요 (IYKYK 😉). 운이 좋게도 장소에는 음식이 가득했어요! 밥 먹고 난 뒤로 다른 부스들을 돌아다니며 많은 사람들과 연결을 맺었어요.\n\n나에게 국제 무대에서 연설 기회를 주어준 AWS에게 정말 감사합니다. 몇 년 전, AWS 클라우드를 배우려는 그저 이 아이였는데, 이 기술이 내 직업을 추진할 것임을 알지 못했어요.\n\n오늘까지의 내 경력을 꽤 잘 요약한 필리핀어로 된 GenZ 명언이 있어요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그 경험은 정말 나에게 또 하나의 캐논 이벤트였어요. 싱가포르를 떠날 때 큰 미소를 지으며 행복했고, 이번 경험으로 배운 모든 것을 다바오시의 로컬 테크 씬에 전달할 거예요. 지금은 다바오시를 필리핀의 주요 테크 허브로 만드는 내 미션을 계속할 열정이 더 크게 타오르고 있어요. 이를 위해 코드 한 줄 한 줄로 전진할 거예요. (그리고 물론 AWS 클라우드 기술로 뒷받침을 받으며 🤪).\n\n이것이 경력을 시작하는 이들과 테크로 전향을 고려 중인 이들 둘 다 영감을 주길 바라며, 기회를 잡으세요! 다양한 기술을 보유하게 되더라도, 가식같은 증후군은 항상 곁에 있을 거예요. 이를 가로막지 않도록 하세요. 이에 당당히 맞서보고 올 수 있는 모든 기회를 잡으세요. 기억하세요, 용감한 자를 행운이 따라다닐 거예요 😉.\n\n<img src=\"/assets/img/2024-05-27-MyAWSSummitSingaporeExperience_8.png\" />\n","ogImage":{"url":"/assets/img/2024-05-27-MyAWSSummitSingaporeExperience_0.png"},"coverImage":"/assets/img/2024-05-27-MyAWSSummitSingaporeExperience_0.png","tag":["Tech"],"readingTime":8},{"title":"4년 동안 스타트업의 인프라를 운영하면서 내가 지지하거나 후회하는 인프라 결정 거의 모든 것","description":"","date":"2024-05-27 17:01","slug":"2024-05-27-AlmostEveryinfrastructuredecisionIendorseorregretafter4yearsrunninginfrastructureatastartup","content":"\n## 기술 스타트업 인프라 추천 도구 모음\n\n![이미지](/assets/img/2024-05-27-AlmostEveryinfrastructuredecisionIendorseorregretafter4yearsrunninginfrastructureatastartup_0.png)\n\n저는 지난 4년 동안 스케일을 빠르게 키워야 했던 스타트업의 인프라를 이끌어 왔습니다. 처음부터 회사가 4년 동안 지켜야 했던 중요한 결정들을 내렸는데, 이러한 결정들을 지지하는지 또는 후회하며 다른 것을 선택하는 것이 좋을지에 대해 이 게시물에서 소개하겠습니다.\n\n# AWS\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## AWS를 Google Cloud 대신 선택한 이유\n\n🟩 추천\n\n처음에는 GCP와 AWS를 둘 다 사용했습니다. 그 시기에는 Google Cloud의 “계정 매니저”가 누구인지 몰랐는데, 동시에 AWS의 계정 매니저와는 정기적인 회의를 가졌습니다. Google은 로봇과 자동화에 의존하는 반면, Amazon은 고객 중심적으로 운영된다는 느낌을 받았습니다. 이런 지원은 새로운 AWS 서비스를 평가할 때 우리를 도와주었습니다. 지원 외에도, AWS는 안정성과 호환되지 않는 API 변경을 최소화하는 데 큰 노력을 기울였습니다.\n\n한 때 Google Cloud가 Kubernetes 클러스터를 선택할 때였습니다, 특히 AWS가 EKS에 투자할지 ECS에 투자할지에 대한 모호함이 있을 때였습니다. 그러나 이제는 AWS 서비스 주변의 추가 Kubernetes 통합(external-dns, external-secrets 등)이 많아져 이제는 더는 그런 문제가 아닙니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## EKS\n\n🟩 Endorse\n\n페니를 꿀리는 경우가 아니라면 (시간이 무료하다면), EKS 대신 자체 제어 평면을 실행할 이유가 없습니다. AWS에서 대체로 사용하는 주요 이점은 AWS 서비스와의 깊은 통합입니다. 다행히도 Kubernetes는 많은 면에서 따라잡았습니다. 예를 들어, external-dns를 사용하여 Route53과 통합할 수 있습니다.\n\n## EKS 관리 애드온\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n🟧 후회\n\nEKS 관리 애드온을 사용했던 이유는 EKS를 사용하는 \"올바른\" 방법이라고 생각했기 때문입니다. 그러나 우리는 항상 설치 자체를 사용자 정의해야 하는 상황에 직면했습니다. also 다음과 같은 CPU 요청, 이미지 태그 또는 일부 configmap일 수 있습니다. 그 이후로는 애드온들을 위해 helm 차트를 사용하도록 전환했으며, 기존의 GitOps 파이프라인과 유사하게 잘 맞는 프로모션을 이용하여 일을 진행하고 있습니다.\n\n## RDS\n\n🟩추천\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n데이터는 인프라에서 가장 중요한 부분입니다. 네트워크를 잃으면 다운타임이 발생하지만 데이터를 잃으면 회사를 끝낼 수 있는 사건이 발생합니다. RDS(또는 제어 데이터베이스)를 사용하는 표시 비용은 극도로 가치 있습니다.\n\n## Redis ElastiCache\n\n🟩추천\n\nRedis는 캐시 및 일반 제품으로 훌륭하게 작동했습니다. 빠르며 API는 간단하고 잘 문서화되어 있으며 구현이 실전에서 검증되었습니다. Memcached와 같은 다른 캐시 옵션과 달리 Redis는 캐시 이외에도 유용한 기능이 많아 더 유용합니다. \"빠른 데이터 처리\"의 스위스 아미 나이프입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n일부는 클라우드 공급업체에 대한 Redis 상태에 대해 확신이 없지만, AWS 고객이 널리 사용하고 있다는 점에서 AWS가 계속해서 잘 지원해 줄 것이라고 생각해요.\n\n## ECR\n\n🟩인증\n\n원래 quay.io에 호스팅을 했었는데, 안정성 문제가 많이 발생했어요. ECR로 이전한 이후에는 훨씬 안정적으로 운영되었어요. EKS 노드나 개발 서버와의 깊은 권한 통합도 큰 장점이었어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## AWS VPN\n\n🟩Endorse\n\nZero Trust VPN 대안은 CloudFlare와 같은 회사에서 제공합니다. 이 제품들이 잘 작동할 것이라 확신하지만 VPN은 설정하고 이해하기가 너무나 쉬워요 (\"단순함이 우선\"이 제 모토에요). 저희는 VPN 액세스를 관리하기 위해 Okta를 사용하고 있어요. 이것은 훌륭한 경험이었어요.\n\n## AWS 프리미엄 지원\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n🟧아쉬운 점\n\n가격이 무척 비싸요: 다른 엔지니어의 비용과 비슷하거나 더 비쌉니다. AWS에 대해 거의 모르는 경우에는 가치가 있을 것 같아요.\n\n## 테라폼을 위한 컨트롤 타워 계정 공장\n\n🟩 추천\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nAFT를 통합하기 전에는 제어 타워를 사용하는 것이 굉장히 귀찮았습니다. 자동화하기가 매우 어려웠어요. 하지만 AFT를 스택에 통합한 후에는 계정을 빠르게 생성하는 작업이 잘 되었습니다. AFT가 우리에게 더 쉽게 만드는 또 다른 점은 계정의 태그를 표준화하는 것입니다. 예를 들어, 우리의 프로덕션 계정에는 피어링 결정을 내릴 수 있는 태그가 있습니다. 우리에게는 태그가 구성보다 나은 이유가 있습니다. 왜냐하면 \"이 계정을 설명하는 속성은 무엇인가\"라는 결정이 항상 트리 구조가 아니기 때문입니다.\n\n# 프로세스\n\n## 슬랙 봇을 활용한 사후 분석 프로세스 자동화\n\n🟩 지지\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n모두가 바빠요. 포스트모텀을 작성하라고 사람들을 일일이 알린다는 것은 자신이 \"나쁜 사람\"인 것 같은 느낌을 줄 수 있어요. 로봇이 그 역할을 대신해 준다면 훌륭한 아이디어죠. SEV 및 포스트모텀 절차를 따르도록 사람들을 살짝 밀어줌으로써 프로세스를 간소화할 수 있어요.\n\n시작할 때 너무 복잡할 필요는 없어요. \"메시지가 한 시간 동안 없습니다. 누군가 업데이트를 올려주세요\" 또는 \"일정 초대장이 없는 날이 하루 지났습니다. 누군가 포스트모텀 미팅을 예약해주세요\"와 같이 기본 사항만으로도 많은 도움이 될 거예요.\n\n## PagerDuty의 장애 템플릿 사용하기\n\n🟩 지지하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n바퀴를 다시 발명할 필요가 있을까요? PagerDuty는 사고 발생 시 무엇을 해야 하는지에 대한 템플릿을 게시합니다. 우리는 이를 약간 수정했는데, Notion의 유연성이 유용하게 쓰였습니다. 그러나 이것은 매우 좋은 시작점이었습니다.\n\n## 정기적으로 PagerDuty 티켓을 검토하는 과정\n\n🟩 승인\n\n회사에 대한 경보는 다음과 같이 진행됩니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 전혀 경고가 없습니다. 경고가 필요합니다.\n- 경고가 있습니다. 경고가 너무 많아 무시합니다.\n- 우리는 경고를 우선순위로 두었습니다. 이제 중요한 것만 저를 깨웁니다.\n- 중요하지 않은 경고는 무시합니다.\n\n우리는 중요하고 중요하지 않은 두 단계의 경고 시스템을 가지고 있습니다. 중요한 경고는 사람들을 깨웁니다. 중요하지 않은 경고는 당직자에게 이메일로 제공됩니다. 문제는 중요하지 않은 경고가 종종 무시된다는 것입니다. 이 문제를 해결하기 위해 우리는 주기적으로 (보통 2주마다) PagerDuty 회의를 진행하여 모든 경고를 검토합니다. 중요한 경고의 경우, 그것이 중요한 상태를 유지해야 하는지 논의합니다. 그런 다음 중요하지 않은 경고를 순환 (보통 각 회의마다 몇 개씩 선정)하고 해당 사항을 해결하기 위해 어떤 조치를 취할 수 있는지 논의합니다 (일반적으로 임계치 조정 또는 자동화 생성).\n\n## 매월 비용 추적 회의\n\n🟩후원\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저는 이른 시기에 매월 SaaS 비용 (AWS, DataDog 등)을 검토하기 위한 회의를 진행했습니다. 이전에는 이를 재무적인 측면에서만 검토했었지만, \"이 비용이 올바른가요?\"와 같은 일반적인 질문에 대답하기가 어려웠습니다. 이 회의는 일반적으로 재무 및 엔지니어링팀 모두가 참석하는데, 모든 관련 소프트웨어 청구서를 검토하고 \"이 비용이 적당해 보이나요?\"라는 직감적인 판단을 내립니다. 높은 비용에 대한 숫자를 자세히 살펴보고 세부 사항을 파헤칩니다.\n\n예를 들어, AWS의 경우 태그로 항목을 그룹화하고 계정으로 분리합니다. 이 두 가지 차원은 일반 서비스 이름(예: EC2, RDS 등)과 결합되어 주요 비용 요소가 어디에 있는지에 대한 좋은 아이디어를 제공합니다. 이 데이터로 수행하는 일부 작업은 스팟 인스턴스 사용 더 깊이 파고들거나 네트워킹 비용에 가장 많은 영향을 미치는 계정을 확인하는 것입니다. AWS에만 머무르지 말고, 회사에 가장 큰 지출을 야기하는 모든 주요 요소로 들어가세요.\n\n## DataDog나 Pager Duty에서 사후 분석 관리\n\n🟥 아쉬움\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n모든 사람들은 사후 조치를 수행해야 합니다. DataDog와 PagerDuty는 각각 사후 조치 작성을 관리하기 위한 통합을 갖추고 있습니다. 우리는 각각을 시도해 봤어요. 불행하게도, 두 툴 모두 사후 조치 프로세스를 사용자 정의하기 어렵게 만들어요. Notion과 같은 강력한 위키 도구를 사용하여 사후 조치를 관리하는 것이 더 나아 보입니다.\n\n## 함수를 서비스(Functions as a Service, FaaS)를 더 활용하지 않은 점\n\n🟥아쉬움\n\nGPU 워크로드를 실행하기에 좋은 FaaS 옵션이 없기 때문에 완전히 FaaS로 전환하지 못했어요. 그러나 많은 CPU 워크로드는 FaaS(람다 등)로 처리될 수 있었어요. 사람들이 제기하는 가장 큰 반론은 비용입니다. \"이 EC2 인스턴스 유형이 24/7로 완전히 가동 중인 것은 람다보다 훨씬 저렴하다\"라고 말하는 사람들이 많아요. 이는 사실이지만, 비교 자체가 잘못되었다고 생각해요. 아무도 서비스를 100% CPU 사용량으로 가동시키고 그냥 두는 게 아니잖아요. 항상 \"100%에 도달하지 않도록. 70%에 이르면 추가로 스케일업\"이라고 하는 스케일러에 의해 실행돼요. 그리고 언제 스케일 다운할 지는 항상 모호하게 남아 있어요. 대신 \"10%에서 10분 동안 머물렀다면, 스케일 다운\"이라는 휴리스틱이에요. 그리고 사람들은 항상 온디맨드 인스턴스로 가정하지만 시장에 항상 그런 인스턴스가 있는 건 아니에요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nLambda의 또 다른 숨겨진 혜택은 비용을 매우 정확하게 추적할 수 있다는 것입니다. Kubernetes에서 서비스를 배포할 때 비용은 노드 당 개체 또는 동일한 노드에서 실행되는 다른 서비스 뒤에 숨을 수 있습니다.\n\n## GitOps\n\n🟩삭제\n\n지금까지 GitOps는 상당히 잘 확장되었으며, 우리는 서비스, 테라폼, 구성 파일 등에서 많은 부분에 사용하고 있습니다. 주된 단점은 파이프라인 중심적인 워크플로우가 \"여기는 커밋을 한 상자이고, 여기는 그 상자에서 파이프라인 끝까지 이어지는 화살표\"라는 명확한 그림을 제공한다는 것입니다. GitOps를 사용하면 \"내가 커밋을 했는데 왜 아직 배포되지 않았는지\"와 같은 질문에 답변할 수 있는 도구를 개발하는 데 투자해야 했습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아직까지 GitOps의 유연성은 큰 이점이 되었으며 귀사에 강력히 추천합니다.\n\n## 외부 요구 사항보다 팀 효율성 우선\n\n🟩지지\n\n아마도 귀사는 인프라 자체를 판매하는 것이 아니라 다른 제품을 판매하고 있을 것입니다. 이는 팀에 기능을 제공하고 귀사의 업무량 확장을 막는 압력을 줍니다. 비행기가 자신의 마스크를 먼저 착용하라고 요청하는 것과 같이 팀이 효율적인지 확인해야 합니다. 드물게 예외가 발생하더라도, 자동화 또는 문서 작성에 시간을 내는 것을 우선하기로 한 것을 후회한 적이 없습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 데이터베이스를 공유하는 여러 응용 프로그램\n\n🟥아쉬운 결정\n\n대부분의 기술 부채처럼, 우리는 이 결정을 내린 것이 아니라, 이 결정을 내리지 않았습니다. 결국, 누군가 제품이 새로운 작업을 수행하길 원하고 새로운 테이블을 만듭니다. 이것은 좋은 느낌입니다. 왜냐하면 이제 두 테이블 간에 외래 키가 있기 때문입니다. 그러나 모든 것이 누군가에 의해 소유되고 그 누군가가 테이블의 한 행이라면, 전체 스택의 모든 객체 간에 외래 키가 있습니다.\n\n데이터베이스가 모두 사용하기 때문에 아무도 관리하지 않습니다. 스타트업은 DBA(DATABASE ADMINISTRATOR)의 편애를 누릴 여유가 없으며, 아무도 소유하지 않은 모든 것은 결국 인프라가 소유하게 됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n공유 데이터베이스의 가장 큰 문제점은 다음과 같습니다:\n\n- 데이터베이스에 개발 및 삭제된 내역이 누적되며, 삭제할 수 있는지 여부가 명확하지 않습니다.\n- 성능 문제가 발생할 때 인프라(심층적인 제품 지식 없이)는 데이터베이스를 디버깅하고 어디로 리디렉션할지 파악해야 합니다.\n- 데이터베이스 사용자는 데이터베이스에 해를 끼치는 나쁜 코드를 업로드할 수 있습니다. 이러한 문제는 PagerDuty가 인프라 팀에 경보를 보내게 됩니다(데이터베이스 소유자이기 때문에). 한 팀이 다른 팀의 문제로 인해 깨어나야 하는 상황은 그 누구에게나 좋지 않습니다. 어플리케이션 소유 데이터베이스의 경우, 어플리케이션 팀이 처음 대응할 수 있습니다.\n\n그럼에도 불구하고 저는 하나의 데이터베이스를 공유하려는 스택에 반대하지 않습니다. 그러나 위에서 언급된 대가를 인식하고, 그것들을 어떻게 관리할지에 대한 좋은 전략이 있어야 합니다.\n\n# SaaS\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## Identity platform을 초기에 도입하지 않았던 것에 대한 후회\n\n🟥후회\n\n처음에 Google Workspace을 사용하여 직원을 위한 그룹을 생성하여 권한을 할당하는 방식으로 진행했었습니다. 그러나 이 방식은 충분히 유연하지 않았습니다. 되돌아보면, 우리가 훨씬 이른 시기에 Okta를 선택했으면 하는 바람이 있습니다. Okta는 매우 잘 작동하며 거의 모든 것에 대한 통합이 있고, 많은 규정 준수/보안 측면의 문제를 해결해 주었습니다. 초기에 Identity 솔루션에 주안점을 두고, 그와 통합되는 SaaS 공급 업체만 받아들이는 것이 좋습니다.\n\n## Notion\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n🟩추천\n\n모든 회사는 문서를 저장할 곳이 필요합니다. 노션은 지금까지 사용해본 Wikis, Google Docs, Confluence 등보다 훨씬 쉽고 효율적으로 작동했어요. 페이지 구성을 위한 데이터베이스 개념을 통해 어려운 페이지 조직도 만들 수 있었습니다.\n\n## Slack\n\n🟩추천\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다행히도 더 이상 HipChat을 사용할 필요가 없어졌어요. Slack은 기본 커뮤니케이션 도구로 훌륭하지만, 스트레스와 소음을 줄이기 위해 다음을 권장해요:\n\n- 커뮤니케이션을 간결하게 정리하기 위해 스레드 사용하기\n- 사람들이 빠르게 메시지에 응답하지 않을 수 있다는 기대 전달하기\n- 개인 메시지 사용을 자제하고 공개 채널을 장려하기\n\n## JIRA를 사용하여 linear로 이동\n\n🟩지지\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그거랑은 아예 달라요. 제이라는 너무 무겁다고 생각해요. 인공지능 회사에서 돌리면 그냥 완전히 감각적으로 바뀔 것 같아요. Linear를 사용할 때 종종 \"X를 할 수 있을까?\"라고 생각한 다음 시도해보니까 가능했어요!\n\n## Terraform Cloud을 사용하지 않은 이유\n\n🟩 후회 없음\n\n처음에 우리의 Terraform을 Terraform Cloud로 마이그레이션하려고 노력했어요. 가장 큰 단점은 비용을 정당화할 수 없었다는 거에요. 그래서 Atlantis로 옮겼는데 충분히 잘 작동했어요. Atlantis가 부족한 부분에서는 CI/CD 파이프라인에 자동화 조각을 조금 작성해 이를 보완했어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## GitHub Actions을 이용한 CI/CD\n\n🟧 보증적 원칙\n\n우리는 대부분의 기업들과 마찬가지로 GitHub에 코드를 호스팅하고 있어요. 처음에는 CircleCI를 사용했지만 지금은 GitHub Actions를 CI/CD에 활용하고 있어요. 워크플로우에 사용할 수 있는 액션들의 마켓플레이스가 다양하고 문법이 쉽게 읽히는 것이 장점이에요. GitHub Actions의 주된 단점은 자체 호스팅된 워크플로우에 대한 지원이 매우 제한되어 있다는 점이에요. 우리는 EKS를 사용하여 EKS에 호스팅된 자체 호스팅된 러너들에 대해 actions-runner-controller를 사용하고 있지만 통합은 종종 버그가 있어요(하지만 우회할 수 없는 문제는 아니에요). 앞으로 GitHub이 Kubernetes 자체 호스팅을 더 진지하게 다루길 바라요.\n\n## Datadog\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 값싼 호스팅 서비스를 찾고 계십니다? 카카오 클라우드는 한국 최고의 클라우드 서비스 제공업체 중 하나입니다. 친절한 가격과 뛰어난 성능을 원하신다면 카카오 클라우드를 추천드립니다. 더 자세한 정보는 [카카오 클라우드 웹사이트](https://cloud.kakao.com)를 방문해주세요.\n\n언제든지 궁금하신 사항이 있으시면 언제든지 문의해주세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nPagerduty는 멋진 제품이며 가격도 합리적입니다. 우리는 선택한 것을 후회한 적이 없습니다.\n\n# 소프트웨어\n\n## Diff를 통한 스키마 마이그레이션\n\n🟧추천-ish\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n스키마 관리는 어떻게 하든 어려운 작업이며, 대부분 무서운 이유로 그렇습니다. 데이터는 중요하며 잘못된 스키마 이동은 데이터를 삭제할 수 있습니다. 이 어려운 문제를 해결하는 무서운 방법 중 하나로 git에 전체 스키마를 체크인하고 그런 다음 데이터베이스를 스키마에 동기화하기 위한 SQL을 생성하는 도구를 사용하는 아이디어로 정말 만족했습니다.\n\n## 개발 서버용 Ubuntu\n\n🟩추천\n\n원래는 쿠버네티스 노드가 실행되는 기본 OS를 개발 서버로 사용해 개발 환경을 운영 환경과 가깝게 만들겠다고 시도해봤지만, 되돌아보니 이러한 노력은 가치가 없다고 생각했습니다. 저희가 개발 서버에 Ubuntu를 계속 사용하고 있어서 기뻐합니다. 이 운영 체제는 잘 지원되며 필요한 대부분의 패키지가 제공됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## AppSmith\n\n🟩 Endorse\n\n내부 엔지니어의 일부 프로세스를 자동화해야 하는 경우가 많습니다: 재시작/승격/진단 등. 이러한 문제를 해결하기 위해 API를 만드는 것은 쉽지만, 누군가의 CLI/OS/의존성 등을 디버깅하는 것은 약간 귀찮습니다. 엔지니어가 우리 스크립트와 상호 작용하기 위한 간단한 UI를 만들 수 있다는 것은 매우 유용합니다.\n\n우리는 AppSmith를 자체 호스팅하고 있습니다. 꽤 잘 작동합니다. 물론 변경하고 싶은 부분들이 있지만, \"무료\" 가격 대비 충분히 만족스럽습니다. 처음에 retool과의 심층적인 통합을 탐색했지만, 그 당시 몇 가지 통합만 있었기 때문에 그 가격을 정당화할 수 없었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 헬름\n\n💡 좋아요\n\n헬름 v2는 나쁜 평판을 얻었지만(v3도 그 이유가 있음), 헬름 v3는 충분히 잘 작동합니다. 여전히 CRD를 배포하는 데 문제가 있고, 개발자들에게 왜 그들의 헬름 차트가 올바르게 배포되지 않았는지에 대해 교육하는 문제가 있습니다. 그러나 전반적으로, 헬름은 버전화된 Kubernetes 객체를 패키지로 만들고 배포하기에 충분히 잘 작동하며, Go 템플릿 언어는 디버그하기 어렵지만 강력합니다.\n\n## ECR(oci)에 있는 헬름 차트\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n🟩인증\n\n원래 우리의 헬름 차트는 S3 안에 호스팅되고 플러그인을 사용하여 다운로드되었습니다. 주요 단점은 사용자 정의 헬름 플러그인을 설치하고 수동으로 라이프사이클을 관리해야 했습니다. 그러나 최근에 OCI 저장소에 있는 헬름 차트로 전환했고, 이러한 설정으로 어떤 문제도 발생하지 않았습니다.\n\n## bazel\n\n🟧확실치 않음\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n공평하게 말해서, 많은 스마트한 사람들이 bazel을 좋아합니다. 그래서 그건 나쁜 선택은 아닌 것 같아요.\n\nGo 서비스를 배포할 때 bazel을 사용하는 건 저에게 개인적으로 지나칠 것 같아요. 만약 지난 회사에서 bazel을 사용했고 그리움을 느낀다면 좋은 선택이죠. 하지만 그 외에는 다수가 사용하는 GitHub Actions과 비교해 몇몇 엔지니어만 깊게 파볼 수 있는 빌드 시스템이에요.\n\n## 초기에 OpenTelemetry 사용하지 않은 것\n\n🟥후회함\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리는 DataDog의 API를 사용하여 지표를 직접 전송하기 시작했습니다. 이렇게 하면 그들을 제거하기가 매우 어렵습니다.\n\n4년 전에는 오픈 텔레미트가 그리 성숙하지 않았지만, 지금은 훨씬 나아졌습니다. 지표 텔레미트는 아직 조금 미성숙한 것 같지만, 추적은 훌륭합니다. 어떤 회사든 처음부터 사용하는 것을 추천합니다.\n\n## dependabot 대신 renovatebot 선택\n\n🟩추천\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n솔직히 말해서, \"의존성을 최신 상태로 유지해야 한다\"라는 사항에 대해 먼저 생각했으면 좋았을 텐데요. 이 부분을 너무 오래 방치하면 버전이 너무 오래된 상태가 되어 업그레이드 과정이 오래 걸리고 결국 버그가 발생하게 됩니다. Renovatebot은 유연성을 가지고 필요에 맞게 사용자 정의할 수 있어 잘 작동했습니다. 가장 큰 단점은 매우 복잡한 설정과 디버깅이어야 한다는 것입니다. 아마도 나쁜 옵션들 가운데에서 가장 나은 선택인 것 같아요.\n\n## 쿠버네티스\n\n🟩 지지\n\n장기적으로 실행되는 서비스를 호스팅할 수 있는 것이 필요합니다. 쿠버네티스는 인기 있는 선택지이며 저희에게 잘 작동했습니다. 쿠버네티스 커뮤니티는 AWS 서비스(로드 밸런서, DNS 등)를 쿠버네티스 생태계에 효과적으로 통합한 좋은 일을 해왔습니다. 그러나 유연한 시스템의 가장 큰 단점은 다양한 방법으로 사용할 수 있기 때문에, 사용법이 많을수록 잘못된 사용법도 많다는 점입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 우리 자체 IP 구매\n\n🟩지지\n\n외부 파트너와 작업을 하는 경우, 그들을 위해 자주 IP 화이트리스트를 게시해야 할 것입니다. 안타깝게도, 나중에 자체 IP가 필요한 시스템이 더 많이 개발될 수 있습니다. 자체 IP 블록을 구매하는 것은 외부 파트너에게 더 큰 CIDR 블록을 화이트리스트로 제공하여 이를 피하는 훌륭한 방법입니다.\n\n## k8s GitOps를 위해 Flux 선택하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n🟩 후회 없는 선택\n\n쿠버네티스를 위한 초기 GitOps 선택 중 ArgoCD와 Flux 중에서 선택해야 했는데, 저는 그 당시에는 Flux(v1)를 선택했습니다. 아주 잘 작동했어요. 현재는 Flux 2를 사용 중이에요. 유일한 단점은 배포 상태를 이해하는 데 도움이 되는 우리만의 도구를 만들어야 했다는 점입니다.\n\nArgoCD에 대해 많은 좋은 이야기를 들었기 때문에, 만약 여러분이 ArgoCD를 선택했다면 안심할 수 있을 거예요.\n\n## 노드 관리를 위한 Karpenter\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n🟩추천\n\nEKS를 사용 중이라면 (그리고 완전히 Fargate를 사용하지 않는다면), Karpenter를 사용해야 합니다. 100% 확실해요. 다른 오토스케일러를 사용해봤는데 기본 Kubernetes 오토스케일러와 SpotInst를 포함해요. 이 중에서 Karpenter가 가장 신뢰할 수 있고 가장 비용 효율적입니다.\n\n## SealedSecrets를 사용하여 k8s 비밀을 관리하기\n\n🟥아쉽습니다\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n제 원래 생각은 시크릿 관리를 GitOps 스타일로 전환하는 것이었습니다. sealed-secrets를 사용하는 두 가지 주요 단점은 다음과 같습니다:\n\n- 인프라에 대한 지식이 부족한 개발자들에게 비밀을 생성/업데이트하기가 더 복잡했습니다.\n- 우리는 AWS가 비밀을 로테이션하는 데 사용하는 기존의 자동화를 모두 잃었습니다.\n\n## k8s 시크릿 관리를 위해 ExternalSecrets 사용\n\n🟩 추천\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nExternalSecrets는 AWS - Kubernetes 시크릿을 동기화하는 데 매우 잘 작동했습니다. 개발자가 이해하기 쉬운 간단한 프로세스이며, AWS 내에서 시크릿을 쉽게 생성/업데이트할 수있게 하여 terraform의 장점을 활용할 수 있습니다. 또한 사용자가 시크릿을 생성/업데이트하는 데 사용할 수있는 UI를 제공합니다.\n\n## ExternalDNS를 사용하여 DNS 관리하기\n\n🟩추천\n\nExternalDNS는 훌륭한 제품입니다. Kubernetes - Route53 DNS 항목을 동기화하고 지난 4년 동안 매우 적은 문제를 일으켰습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## SSL 인증서 관리를 위해 cert-manager 사용하기\n\n🟩좋아함\n\n환경 설정이 매우 직관적이고 문제 없이 잘 작동합니다. 쿠버네티스를 위한 Let's Encrypt 인증서를 생성하는 데 강력히 추천합니다. 유일한 단점은 때로는 고대의 (SaaS 문제, 그런 게 있죠?) 기술 스택을 사용하는 고객들이 Let's Encrypt를 신뢰하지 않아서 해당 고객들을 위해 유료 인증서를 구해야 할 수 있습니다.\n\n## EKS용 Bottlerocket\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n🟥 후회\n\n우리의 EKS 클러스터는 이전에 Bottlerocket에서 실행되었습니다. 주요 단점은 네트워킹 CSI 문제에 자주 직면했으며, Bottlerocket 이미지를 디버깅하는 것이 표준 EKS AMI를 디버깅하는 것보다 훨씬 더 어려웠습니다. 노드에 EKS 최적화 AMI를 사용하면 문제가 없고, 이상한 네트워킹 문제가 발생했을 때 노드 자체를 디버깅하기 위한 통로가 여전히 있습니다.\n\n## Cloudformation 대신 Terraform 선택\n\n🟩 지지\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n인프라스트럭처를 코드로 관리하는 것은 어떤 회사에게든 필수적입니다. AWS 환경에서 주로 사용하는 것은 CloudFormation과 Terraform입니다. 저는 두 가지 모두 사용해봤는데 Terraform을 선택한 것을 후회하지 않았어요. 다른 SaaS 공급업체(예: Pagerduty)와 쉽게 확장할 수 있었고, CloudFormation보다 읽기 쉬운 구문을 가지고 있어서 저희에게는 방해 없이 진행되었어요.\n\n## 더 코드스럽지 않은 IaC 솔루션(Pulumi, CDK 등)을 사용하지 않을 때\n\n🟩후회 없음\n\nTerraform과 CloudFormation은 인프라스트럭처를 설명하는 데이터 파일(HCL 및 YAML/JSON)이지만, Pulumi나 CDK와 같은 솔루션은 코드로 동일한 작업을 수행할 수 있게 해줍니다. 코드는 물론 강력하지만, Terraform의 HCL이 제한적인 성격이라는 것이 복잡성을 줄일 수 있는 장점이라고 생각했어요. Terraform을 통해 복잡한 작업을 수행하는 것이 불가능한 것은 아니지만, 그럴 때 더 명확하게 알 수 있었어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n일부 솔루션 중 Pulumi와 같은 것들은 많은 년전에 개발되었는데, Terraform은 현재 많은 기능이 부족했던 시기에 만들어졌습니다. 최신 버전의 Terraform에는 우리가 복잡성을 줄일 수 있는 많은 기능이 통합되어 있습니다. 대신, 저희는 우리가 추상화하고 싶은 부분들을 위해 Terraform 코드의 기본 뼈대를 생성하는 중간 방법을 사용합니다.\n\n## 네트워크 망을 사용하지 않기(istio/linkerd/등)\n\n🟩후회 없음\n\n네트워크 망은 정말 멋지고 많은 똑똑한 사람들이 그것을 지지하는 경향이 있기 때문에, 나는 그것들이 괜찮은 아이디어라고 확신합니다. 불행히도, 회사들이 일반적으로 복잡성을 과소평가한다고 생각합니다. 제 일반적인 인프라 조언은 \"덜하는 게 더 낫다\"입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## EKS 인그레스용 Nginx 로드 밸런서\n\n🟩 후회 없음\n\nNginx는 오래되었고 안정적이며 전투 검증을 거친 상태입니다.\n\n## 회사 스크립트용 홈브류\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n🟩지지\n\n귀사는 엔지니어들이 사용할 스크립트와 이진 파일을 배포할 방법이 필요할 것입니다. Homebrew는 리눅스와 맥 사용자 모두에게 스크립트와 이진 파일을 배포하는 방법으로 충분히 잘 작동했습니다.\n\n## 서비스 선택\n\n🟩지지\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nGo는 새로운 엔지니어들이 배우기 쉽고 전반적으로 좋은 선택지입니다. 대부분 네트워크 IO에 바인딩된 비 GPU 서비스의 경우, Go가 기본 언어로 적합합니다.\n","ogImage":{"url":"/assets/img/2024-05-27-AlmostEveryinfrastructuredecisionIendorseorregretafter4yearsrunninginfrastructureatastartup_0.png"},"coverImage":"/assets/img/2024-05-27-AlmostEveryinfrastructuredecisionIendorseorregretafter4yearsrunninginfrastructureatastartup_0.png","tag":["Tech"],"readingTime":26},{"title":"AWS Rekognition은 어떻게 아이들을 지킴에 도움을 주나요","description":"","date":"2024-05-27 16:59","slug":"2024-05-27-HowAWSRekognitionHelpsProtectChildhood","content":"\n## 어린이 안전을 혁신하다\n\n![이미지](/assets/img/2024-05-27-HowAWSRekognitionHelpsProtectChildhood_0.png)\n\n내 아들이 다니는 유치원에서 모든 것이 시작되었어요. 팬데믹 전날들, 외부 활동을 하고 사진을 찍어 SNS에 올리고 가족들에게 보내는 것이 흔했어요.\n\n이 맥락에서, 데이터 보호법은 미성년자의 신원이 노출되지 않도록 현명하게 규정하고 있습니다. 이를 위해 가족/부모의 명시적 허락을 받지 않으면 이러한 이미지를 배포해서는 안 된다는 요구 사항을 비롯한 다양한 제약이 설정되어 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 모든 과정은 감정 표현 아이콘을 겹쳐 놓거나 잘라내거나 삭제하는 귀찮은 익명화 수동 프로세스로 이어집니다. 수동 프로세스이기 때문에 오류가 없고 규모에 비해 잘 작동하지 않습니다.\n\n이것은 아이들의 얼굴을 찾아 숨기기 위해 자동화된 형태를 사용하여 그들의 익명성을 보장하고 교사들과 교육진들의 작업을 쉽게 만드는 아이디어로 이끈 것입니다. 지속 가능한 비즈니스 모델도 아울러 구체화할 수 있다면 한 발자국 더 나아갈 수 있겠죠.\n\n# 창의적인 프로세스\n\n이 아이디어와 함께, 나는 그것을 구현하기 시작했습니다: 간단한 웹 응용 프로그램과 서버 측 API. 나는 단순한 것을 준비했고, 준비가 끝난 후 도메인을 등록하고 처음 발표 전에 첫 번째 테스트 중에 이것이 다소 인위적인 단계임을 깨달았습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n사진을 찍고 공유하려면 대개 모바일 폰에서 하게되는데, 사진을 다듬기 위해 여러 애플리케이션을 거치고 싶지 않을 때가 있습니다 (적어도 대부분의 사람이 그러하지는 않지만), 아예 타사 웹사이트를 통해 지나치게 다듬는 것은 훨씬 더 그렇습니다. 이러한 까칠함은 애플리케이션을 받아들이기 어렵게 만들어, 다른 방법을 시도해보기로 결정했습니다: 텔레그램 봇.\n\n기존에 이미 이뤄진 작업에 대한 많은 이점을 취할 수 있게 해주었기에, 리팩토링을 거쳐 봇을 발표하고 조금씩 사용자를 모았습니다. 개발 중이었을 때 4명의 분들께서 친절하게 테스트해 주셔서 그것이 저를 격려해 다양한 기능을 추가하게 이끌었습니다. 광고 없이 3개월 만에 400명의 사용자에 도달했습니다. 여러 분야에서 공유한 후, 총 1034명의 사용자가 있는 애플리케이션을 종료했습니다.\n\n![AWSRekognitionHelpsProtectChildhood](/assets/img/2024-05-27-HowAWSRekognitionHelpsProtectChildhood_1.png)\n\n## 아키텍처 단계\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n각 건축 설계의 근거가 아래에 자세히 나와 있습니다. 이것은 솔루션의 진화를 보여줍니다.\n\n## 첫 번째 반복: 서버리스\n\n콘텐츠 배포는 CloudFront와 S3를 사용하여 이루어졌으며, 로직은 람다에서 처리되어 GW API를 통해 액세스되었습니다. 비즈니스 로직은 Rekognition과 S3 호출을 통해 지원되었습니다. 모든 것이 예상대로 작동했지만, 이미지를 생성하는 프로세스에서 Lambda에서 많은 CPU/RAM을 필요로 했습니다.\n\n![AWS Rekognition Helps Protect Childhood](/assets/img/2024-05-27-HowAWSRekognitionHelpsProtectChildhood_2.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 두 번째 반복: EC2에서 IaaS\n\n두 번째 버전은 우분투가 실행되는 EC2에 직접 배포되었습니다. 처음에는 PEM을 사용하고 나중에는 SSM을 사용했습니다. CodeCommit, Rekognition 및 DynamoDB에서 코드를 다운로드하는 역할이 있는 인스턴스였습니다.\n\n![이미지](/assets/img/2024-05-27-HowAWSRekognitionHelpsProtectChildhood_3.png)\n\n## 최종 후보 아키텍처 (실행되지 않음)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n진화와 수요가 발생하는 경우 알맞은 버전은 필요 시 스케일 업할 수 있는 ALB가 있는 작은 Fargate Spot Fleet를 생성하는 것이었습니다. 이 버전은 예비적이며, 개발된 것은 없었으며, 폴링 대신 웹소켓을 사용하고 노드 밸런싱을 위해 외부 스토리지인 Redis에 세션 관리를 포함시키기 위해 코드를 리팩토링해야 했습니다.\n\n![이미지](/assets/img/2024-05-27-HowAWSRekognitionHelpsProtectChildhood_4.png)\n\n# 유용한 코드 조각\n\n코드의 흥미로운 부분은 Rekognition 응답을 처리하는 섹션입니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그리고 그와 함께, 얼굴을 익명화하기 위해 가우시안 블러 효과를 적용하는 섹션을 변경하겠습니다:\n\n마지막으로, 궁금해하시는 분들을 위해, 여기에는 봇의 상태 머신, 애플리케이션의 나머지 비즈니스 로직 및 API 호출을 처리하는 데 필요한 헬퍼가 포함된 완전한 코드 저장소가 있습니다.\n\n# 배운 점\n\n이 섹션은 예기치 않은 도전에 직면하거나 다양한 기술을 실험하며, 무엇보다도 사이드 프로젝트로 디지털 제품을 출시하려는 노력에서 배운 교훈을 공유하는 데 전념합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 프리미엄이나 기부 기반 모델을 구현하는 것은 쉬운 일이 아닙니다.\n- 사람들은 스마트폰 상에서 봇과 상호 작용을 매우 잘합니다.\n- 사용자 경험과 명확한 지침은 플랫폼과 상호 작용하는 데 중요합니다.\n- 사용자 피드백은 반드시 필요하며, 소프트웨어를 테스트한 친구들로부터 얻은 일부 최고의 제안이 있었습니다.\n\n읽어주셔서 감사합니다! 마음에 드셨으면 여기 다른 AWS 관련 기사들이 있어요!\n\n# 쉽게 이해하는 AWS 관련 기사들 🚀\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nIn Plain English 커뮤니티에 참여해 주셔서 감사합니다! 떠나시기 전에:\n\n- 반드시 작가를 클랩하고 팔로우해 주세요! 👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | 뉴스레터\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed\n- PlainEnglish.io에서 더 많은 콘텐츠를 확인해 보세요.\n","ogImage":{"url":"/assets/img/2024-05-27-HowAWSRekognitionHelpsProtectChildhood_0.png"},"coverImage":"/assets/img/2024-05-27-HowAWSRekognitionHelpsProtectChildhood_0.png","tag":["Tech"],"readingTime":6},{"title":"AWS 비용을 절감하는 방법 CloudWatch 알람을 사용하여 유휴 상태의 EC2 인스턴스 중지하기","description":"","date":"2024-05-27 16:57","slug":"2024-05-27-ReduceAWSCostsbyStoppingIdleEC2InstanceswithCloudWatchAlarms","content":"\n클라우드 리소스를 효율적으로 관리하는 것은 클라우드 서비스를 이용하는 사람에게 매우 중요합니다, 특히 비용을 통제하는 측면에서 말이죠. 한 가지 흔한 문제는 개발, 테스트 또는 임시 작업을 위해 사용하는 EC2 인스턴스를 중지하는 것을 잊는 경우입니다. 이러한 실수는 뜻밖에 높은 청구서를 유발할 수 있습니다.\n\n제 경우에는 주로 테스트 목적으로 특정 도구를 설치한 EC2 인스턴스를 갖고 있습니다. 이 인스턴스는 짧은 기간 동안 사용됩니다. 작업을 완료한 후 인스턴스를 일반적으로 중지합니다. 그러나 때로는 산만해지거나 다른 작업으로 이동하여 그것을 잊어버리곤 합니다 😓. 다시 돌아와서 그것이 계속 실행 중인 것을 발견하면 놀라곤 합니다, 그로 인해 청구서가 높아지죠 😲.\n\n이 문제를 해결하기 위해, 나만이 중지할 것을 기억하도록 의존할 수 없다는 것을 깨달았고 자동화해야 한다는 것을 이해했습니다. 발견한 해결책은 1시간 동안 활동이 감지되지 않으면 인스턴스를 자동으로 중지하는 CloudWatch 경보를 생성하는 것입니다. 이렇게 하면 실제 사용한 만큼만 지불하게 됩니다.\n\n이 글에서는 이 해결책을 여러분과 공유하려 합니다. CloudWatch 경보를 소개하는 것부터 시작하여 비활성 EC2 인스턴스를 자동으로 중지하기 위해 AWS 관리 콘솔 및 Terraform을 사용하여 경보를 구성하는 단계별 안내서를 제공할 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# Cloudwatch Alarm\n\nAmazon CloudWatch은 AWS의 모니터링 서비스입니다. 이 서비스는 AWS 서비스, 사용자 정의 응용 프로그램 및 온프레미스 응용 프로그램에서 수집된 메트릭과 로그를 수집하는 중앙 저장소 역할을 합니다. CloudWatch 중요 기능 중 하나는 수집된 데이터를 기반으로 알람을 구성할 수 있는 CloudWatch 알람입니다.\n\nCloudWatch 알람은 단일 메트릭의 값(단일 또는 복합)을 지정한 시간 동안 확인하고, 정의한 임계값에 도달하면 지정한 작업을 실행합니다.\n\nCloudWatch 알람을 이해할 때, 필로우스트림을 모니터링하는 보안 카메라로 상상해보세요. 이 카메라의 역할은 문의 상태를 추적하는 것입니다. 문이 열려 있는지 닫혀 있는지를 확인합니다. 카메라가 문이 너무 오래 열려 있는 등 이상한 상황을 감지하면 알림을 트리거하여 경고합니다. 마찬가지로, CloudWatch 알람은 CPU 사용량과 같은 AWS 리소스의 특정 메트릭을 모니터링합니다. 메트릭이 미리 정의된 임계값을 초과하면(문이 너무 오래 열려 있는 것처럼) 알람이 트리거되어 문제를 알리고 조치를 취할 수 있도록 알려줍니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# CloudWatch 알람의 주요 구성 요소\n\n- 메트릭: 메트릭은 시간이 지남에 따라 모니터링하는 성능 데이터입니다. 시간이 지남에 따라 다른 값을 갖는 변수처럼, 이러한 값의 변동은 응용 프로그램이 원래대로 작동하는지 확인하기 위한 결정을 내릴 때 중요합니다. 메트릭에는 CPU 사용량, 디스크 I/O, 메모리 사용량 및 사용자 정의 응용 프로그램 메트릭 등이 포함될 수 있습니다. 이러한 메트릭은 정기적으로 수집되고 CloudWatch에 저장됩니다.\n- 임계값: 이것은 메트릭 데이터가 평가되는 값을 의미합니다. 예를 들어, CPU 사용량의 70%를 임계값으로 설정할 수 있습니다. 메트릭 값이 임계값보다 작거나 같거나 더 클지에 따라, 액션을 트리거할 수 있습니다.\n- 기간(초): 기간은 메트릭 값이 수집되는 빈도를 결정합니다. 이는 필요에 따라 몇 초에서 몇 시간까지 범위가 될 수 있습니다.\n- 통계량: 이것은 각 기간에 대해 메트릭 데이터가 어떻게 집계되는지를 지정합니다. 일반적인 통계량으로는 평균, 합계, 최소값 및 최대값이 있습니다. 메트릭이 매 분마다 수집되고 알람 기간을 5분으로 설정한 경우, 5분 동안 수집된 5개 값의 평균이 각 기간에 대한 메트릭 값으로 계산됩니다.\n- 평가 기간: 알람의 상태를 평가하는 데 고려할 최근 기간 수입니다.\n- 알람 데이터포인트: 알람을 트리거하려면 메트릭이 임계값을 위반해야 하는 평가 기간 수입니다. 예를 들어, 3개의 평가 기간이 있고 2개의 알람 데이터포인트를 설정한 경우, 임계값은 3개 기간 중 적어도 2개에서 위반되어야 알람이 트리거됩니다.\n- 알람 액션: 알람 상태가 변경될 때 취해지는 조치입니다. 이는 Amazon SNS를 통해 알림을 보내거나 EC2 인스턴스를 중지, 종료 또는 다시 부팅하거나 AWS Lambda 함수를 호출하거나 Auto Scaling 작업을 수행하는 것 등이 포함될 수 있습니다. 단일 알람에 여러 액션을 구성할 수 있습니다.\n\n# CloudWatch 알람 예시\n\n각 CloudWatch 알람의 구성 요소의 역할과 시간 경과에 따른 알람 상태 평가를 설명하는 예시를 살펴보겠습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n알람 예제는 EC2 인스턴스의 평균 CPU 사용률을 모니터링하도록 설정되어 있습니다. CPUUtilization 메트릭은 5분 간격으로 수집되고 집계됩니다. 알람은 연속적으로 3개의 기간 동안의 평균 CPU 사용률을 평가합니다. 평균 CPU 사용률이 최소 2개의 평가 기간 중에서 70%의 임계값을 초과하면 알람이 정의된 작업을 트리거합니다.\n\n- 메트릭 : CPUUtilization\n- 통계 : 평균\n- 기간 : 300초 (5분)\n- 임계값 : 70%\n- 알람 조건 : 크거나 같음\n- 평가 기간 : 3\n- 알람에 필요한 데이터포인트 : 2\n\n아래 표는 알람이 시간이 지남에 따라 어떻게 트리거되는지 보여줍니다 :\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 예에서는 평균 CPU 이용률이 70% 임계 값을 기간 3에서 초과하지만 알람이 트리거되지 않습니다. 이는 임계 값을 3 개의 평가 기간 중 1 회만 초과하기 때문입니다 (65-60-70).평균 CPU 이용률이 70% 임계 값을 다시 초과하는 시점은 기간 5로, 이는 평가 기간에서 2 번째 초과입니다 (70-60-75). 따라서 알람이 트리거되고 ALARM 상태로 들어갑니다.\n\n# 비활성 인스턴스를 자동으로 중지시키기 위한 CloudWatch 알람 설정\n\n![CloudWatch 알람을 사용하여 유휴 EC2 인스턴스 중단으로 AWS 비용 절감하기](/assets/img/2024-05-27-ReduceAWSCostsbyStoppingIdleEC2InstanceswithCloudWatchAlarms_1.png)\n\n나는 비활성 인스턴스를 감지하는 데 사용할 메트릭으로 CPUUtilization을 선택했습니다. 이 메트릭은 기본적으로 5분마다 수집되며 CloudWatch로 전송됩니다. 알람은 1시간 동안 (5분씩 12회) CPU 이용률이 2% 미만으로 유지된 경우에만 트리거됩니다. 알람에 의해 트리거된 작업은 인스턴스 중지 및 이메일 통지입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 메트릭: CPUUtilization\n- 통계: 평균\n- 기간: 300초 (5분)\n- 임계값: 2%\n- 경보 조건: 이하\n- 평가 기간: 12\n- 경보 발생 데이터 포인트: 12\n- 조치: SNS 이메일 알림 + EC2 인스턴스 중지\n\n# 콘솔을 이용한 해결 방법\n\n## 단계 1. 메트릭 및 조건 지정\n\n모니터링해야 하는 인스턴스의 CPUUtilization 메트릭을 선택한 후 경보 조건을 지정하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![AWS Cost Reduction Step 2](/assets/img/2024-05-27-ReduceAWSCostsbyStoppingIdleEC2InstanceswithCloudWatchAlarms_2.png)\n\n![AWS Cost Reduction Step 3](/assets/img/2024-05-27-ReduceAWSCostsbyStoppingIdleEC2InstanceswithCloudWatchAlarms_3.png)\n\n![AWS Cost Reduction Step 4](/assets/img/2024-05-27-ReduceAWSCostsbyStoppingIdleEC2InstanceswithCloudWatchAlarms_4.png)\n\n![AWS Cost Reduction Step 5](/assets/img/2024-05-27-ReduceAWSCostsbyStoppingIdleEC2InstanceswithCloudWatchAlarms_5.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 단계 2. 작업 구성\n\n첫 번째 작업은 이메일 구독이 있는 SNS 주제로 알림을 보내는 것입니다. 이렇게 하면 알람이 인스턴스를 중지할 때 알림을 받을 수 있습니다. 이 단계에서 SNS 주제를 생성할 수도 있고, 이미 생성한 경우 기존 주제를 참조할 수도 있습니다.\n\n두 번째 작업은 인스턴스를 중지하는 것입니다.\n\n![AWS 비용 절감 이미지](/assets/img/2024-05-27-ReduceAWSCostsbyStoppingIdleEC2InstanceswithCloudWatchAlarms_6.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/assets/img/2024-05-27-ReduceAWSCostsbyStoppingIdleEC2InstanceswithCloudWatchAlarms_7.png)\n\n## 단계 3. 이름 및 설명 추가\n\n알람에 이름을 지정하고 설명도 추가할 수 있습니다.\n\n![이미지](/assets/img/2024-05-27-ReduceAWSCostsbyStoppingIdleEC2InstanceswithCloudWatchAlarms_8.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 단계 4. 미리보기 및 생성\n\n모든 구성 요약을 확인하세요. 모든 것이 올바르다면 경보 생성을 확인하십시오.\n\n결과는 아래 스크린샷과 같아야 합니다.\n\n<img src=\"/assets/img/2024-05-27-ReduceAWSCostsbyStoppingIdleEC2InstanceswithCloudWatchAlarms_9.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n알람은 새로 생성되었을 때이거나 지정된 기준을 바탕으로 알람 상태를 결정하기에 충분한 데이터가 없을 때 상태가 \"데이터 부족\"으로 표시될 수 있습니다.\n\n경고 메시지는 다음과 같습니다: \"이 작업은 확인 대기 중인 엔드포인트가 있는 SNS 주제로 메시지를 보냅니다. 엔드포인트가 확인될 때까지 예상대로 작동하지 않을 수 있습니다. SNS에서 구독 확인 이메일을 찾거나 주제를 검토하세요.\" 해당 메시지는 생성된 SNS 주제에 대한 이메일 구독을 확인하는 것에 관한 것입니다. SNS 주제를 생성할 때 제공한 이메일 주소로 수신한 이메일을 열고 구독을 확인해야 합니다.\n\n![이미지](/assets/img/2024-05-27-ReduceAWSCostsbyStoppingIdleEC2InstanceswithCloudWatchAlarms_10.png)\n\n구독을 확인한 후에 알람이 지정된 메트릭에 도달하면 아래 스크린샷과 같은 결과를 얻어야 합니다. 모든 것이 잘 작동합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![CloudWatch Alarm Screenshot 1](/assets/img/2024-05-27-ReduceAWSCostsbyStoppingIdleEC2InstanceswithCloudWatchAlarms_11.png)\n\nCloudWatch 알람이 올바르게 설정되어 있고 조건을 충족하면 작업을 트리거할 준비가 되어 있습니다. 이 경우 아래 스크린샷과 같은 결과를 볼 수 있습니다.\n\n![CloudWatch Alarm Screenshot 2](/assets/img/2024-05-27-ReduceAWSCostsbyStoppingIdleEC2InstanceswithCloudWatchAlarms_12.png)\n\n![CloudWatch Alarm Screenshot 3](/assets/img/2024-05-27-ReduceAWSCostsbyStoppingIdleEC2InstanceswithCloudWatchAlarms_13.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 테라폼을 사용한 솔루션\n\n클라우드워치 알람을 빠르고 자동화되며 일관된 방식으로 설정하고 싶다면, 테라폼을 사용하는 것이 훌륭한 선택입니다. 아래에는 클라우드워치 알람을 설정하는 데 사용되는 주요 파일인 cloudwatch_alarm.tf와 sns.tf 파일을 제시합니다. 전체 테라폼 코드는 제 GitHub 저장소에서 확인할 수 있습니다.\n\n```js\nresource \"aws_cloudwatch_metric_alarm\" \"ec2_cpu_alarm\" {\n  comparison_operator       = \"LessThanOrEqualToThreshold\"\n  evaluation_periods        = \"12\"\n  datapoints_to_alarm       = \"12\"\n  metric_name               = \"CPUUtilization\"\n  namespace                 = \"AWS/EC2\"\n  period                    = \"300\" #초\n  statistic                 = \"Average\"\n  threshold                 = \"2\"\n  alarm_description         = \"이 알람은 EC2 인스턴스가 1시간 동안 비활성 상태로 유지될 경우 중지됩니다.\"\n  treat_missing_data        = \"missing\"\n  insufficient_data_actions = []\n  alarm_actions             = [aws_sns_topic.topic.arn, \"arn:aws:automate:${var.region}:ec2:stop\"]\n\n  alarm_name = \"stop_test_instance_alarm\"\n\n  dimensions = {\n    InstanceId = var.instance_ID\n  }\n}\n```\n\n```js\nresource \"aws_sns_topic\" \"topic\" {\n  name = \"stop_test_instance_alarm_topic\"\n}\n\nresource \"aws_sns_topic_subscription\" \"topic_email_subscription\" {\n  topic_arn = aws_sns_topic.topic.arn\n  protocol  = \"email\"\n  endpoint  = var.email_address\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n모든 리소스가 생성된 후에는, 생성된 SNS 주제의 구독을 확인해야 합니다. 받은 이메일 안내에 따라 (콘솔 솔루션에서 설명한 대로) 구독을 확인해주세요.\n\n이 기사가 EC2 인스턴스를 효율적으로 관리하여 불필요한 사용을 방지하는 데 도움이 되길 바랍니다.\n","ogImage":{"url":"/assets/img/2024-05-27-ReduceAWSCostsbyStoppingIdleEC2InstanceswithCloudWatchAlarms_0.png"},"coverImage":"/assets/img/2024-05-27-ReduceAWSCostsbyStoppingIdleEC2InstanceswithCloudWatchAlarms_0.png","tag":["Tech"],"readingTime":11},{"title":"게임 개발에서 빛과 색상 활용하기 초심자를 위한 가이드","description":"","date":"2024-05-27 16:54","slug":"2024-05-27-Usinglightandcoloringamedevelopmentabeginnersguide","content":"\n빛과 색은 감정을 전달하고 분위기를 조성하는 데 가장 강력한 도구 중 하나입니다. 그러나 이 도구들을 올바르게 활용하기 위해서는 일정한 예술적 지식이 필요합니다. 이 글에서는 크래시 코스와 앞으로의 방향에 대해 알아볼 거예요!\n\n![이미지](/assets/img/2024-05-27-Usinglightandcoloringamedevelopmentabeginnersguide_0.png)\n\n거의 모든 게임에서, 빛은 매우 중요한 요소입니다. 여기서 말하는 것은 현실적이고 아름다운 그래픽을 만들어내는 빛 뿐만 아니라, 게임 플레이 자체를 지원하는 요소입니다. 즉, 좋은 조명 없이는 게임이 반 준비만 된 것과 다름없습니다. 그렇다고 해서 기술적으로 올바르게 빛을 다루는 것만 중요한 것은 아닙니다. 예술적 측면에서 빛을 이해하는 것이 중요합니다.\n\n안녕하세요! 저는 알렉산더 샤로프라고 해요. 워 로봇: 프론티어 프로젝트에서 시니어 환경 아티스트로 일하고 있습니다. 7년 가까이 게임 산업에서 일하며, 모바일 개발, VR 프로젝트 및 AAA 게임 제작 경험이 있습니다. 이 글은 게임에서 빛을 다루는 기본에 대해 다룰 것이며, 그 중요성을 정확히 이해하고 싶어하는 분들을 위한 것입니다. 또한 색상과 빛이 근본적으로 관련된 개념이기 때문에 색상에 대해서도 이야기할 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 게임 및 영화 제작 시 빛의 중요성\n\n우리는 기본부터 시작해봅시다: 빛은 분위기를 표현하거나 개발자가 의도한 정확한 감정을 전달하며, 그림자, 반사 등을 만들어내어 게임 메카닉에도 영향을 미칠 수 있습니다. (짧은 예로, 생존 게임에서 빛은 어둠 속에 휩쓸리고 주변이 보이지 않을 때 플레이어에게 공포와 긴장감을 느끼도록 하는데 사용될 수 있습니다.)\n\n빛은 게임 내 중요한 강조를 만들어내는 가장 강력한 도구입니다. God of War의 2018년 리부트를 시작으로 이를 고려해 봅시다.\n\n![이미지](/assets/img/2024-05-27-Usinglightandcoloringamedevelopmentabeginnersguide_1.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여기서 빛은 플레이어의 시선을 안내하고 대조를 강조하며, 핵심 초점을 보여줍니다. 즉, 플레이어가 가야 할 곳과 거기에서 기다리는 것이 무엇인지를 보여줍니다. 조명은 또한 특정 감정을 불러일으키는 분위기를 조성하고 \"와우\" 효과를 줍니다.\n\n파란색과 빨간색 컬러 쉐이드의 대비는 그림에 더 많은 흥미를 더하며, 결과적으로 눈은 그들 사이를 왔다갔다하게 됩니다. 도로도 빛과 색상으로 강조되어 있습니다. 이는 이동 방향을 빠르게 이해할 수 있도록 합니다. 빛은 또한 전경, 중경 및 배경을 분리하여 위치의 부피를 더 잘 볼 수 있게 하고 물체가 합쳐지는 것을 방지합니다. 물론, 플레이어는 보는 것을 철저히 분석하지 않습니다. 모든 것을 무의식적으로 수행합니다.\n\n두 번째 예는 언급한 시리즈의 최신 게임인 God of War: Ragnarök에서 나온 것입니다.\n\n![image](/assets/img/2024-05-27-Usinglightandcoloringamedevelopmentabeginnersguide_2.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위 스크린샷에서 분위기는 더 어둡고 차가워졌어요. 등잔불에서 나오는 빛의 대비는 배경과 주변의 다른 것들에 명확히 보이게 하여 개발자들이 강조를 만들 수 있도록 도와줍니다. 이것은 플레이어들에게 어떤 포인트가 중요하다는 것을 알리기 가장 간편한 방법입니다. 예를 들어, 등잔불이 없었다면 이 문을 들어갈 수 있다거나 이 방향으로 가야 된다는 것이 명확하지 않았을 것입니다. 여기서 빛은 시각적인 역할뿐만 아니라 게임플레이를 강조하는 데도 도움이 됩니다. 다시 한 번 강조할 점은 눈이 차가운 파란색과 따뜻한 색조를 왔다갔다한다는 것도 있어요.\n\n세 번째와 네 번째 스크린샷은 'Horizon Forbidden West'와 'Burning Shores' 애드온에서 나왔어요.\n\n위 세 번째와 네 번째 스크린샷은 같은 기본 규칙을 따라서: 빛은 분위기를 만들고, 관심 지점을 보여주고, 규모와 방향을 보여줍니다. 이 경우, 이 효과들은 차가운 빛과 따뜻한 빛의 대비, 형상, 물체의 기울기, 그리고 다른 디자인 요소들을 통해 달성됩니다. 빛은 모든 이것들을 강조하고 강화하여, 개발자들이 상상한 아이디어를 전달합니다.\n\n더 구체적으로, 세 번째 스크린샷에서, 따뜻한 빛으로 조명이 비춰지는 거대한 입구를 볼 수 있어요; 차가운 곳 배경 앞에서 높이 서있는 이 빛은 플레이어의 시선을 끕니다. 더불어, 그 자체의 위치 디자인도 매우 효과적입니다: 입구는 다른 모든 것과 두드러지게 대조되는 독특한 형상을 가지고 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n제 4번째 스크린샷에서 삐딱하게 자라난 나무와 인물이 함께 있는 것으로 보아 플레이어의 시선을 그림의 오른쪽으로 이끄는 것 같습니다. 그곳에는 흥미로운 물건이 위치해 있는데, 이 경우엔 모든 것과 잘 어우러지는 외로운 건물이 눈에 띕니다. 여기서의 빛은 계획들을 잘 분리하고, 장소의 규모를 강조하며, 모든 것이 하나의 연속적인 질량으로 융합되지 않도록합니다. 주 건물 뒤의 버려진 도시는 강조되기 위해 특히 짙은 안개에 덮여 있고, 주인공을 다른 물건과 대비시키기 위해 사용되는 다른 여러 물건들과 함께 이 장소에 존재합니다.\n\n# 칼라 심리학\n\n그래서, 이제 일부 게임에서 빛이 어떻게 작용하는지 살펴보았으니, 어떻게 실제로 작업해야 할까요? 올바른 흥미로운 결과를 얻기 위해 따라야 할 규칙은 무엇일까요? 심리학적 측면에서 사람들에게 어떻게 영향을 미치는지에 관심을 가진 색상과 관련된 과학이 있습니다. 이러한 규칙은 예술가들이 특정 플레이어 감정, 분노, 기쁨, 슬픔, 희망 등을 불러일으키기 위해 사용되지만, 예술적 구성 요소에 더 많은 중점을 두며 어떻게 원하는 효과를 이끌어낼 수 있는지 탐구합니다. 색채 이론은 색상이 어떻게 생성되는지, 서로 상호 작용하는 방식, 그리고 어떻게 사람들의 감정과 기분에 영향을 미치는지를 탐구하고 설명합니다.\n\n![이미지](/assets/img/2024-05-27-Usinglightandcoloringamedevelopmentabeginnersguide_3.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n게임 개발 과정에서는 색이 핵심적인 역할을 하는 많은 영역이 있습니다: UI, VFX, 그리고 조명, 환경, 시네마틱 디자인 등이 있죠. 예를 들어, UI/UX에서는 종종 동맹과 적을 구별하기 위한 표식이 필요한데, 게임에서는 보통 동맹을 파란색 또는 초록색으로, 적을 빨간색으로 표시합니다. 이렇게 해야 플레이어가 즉시 친구와 적을 구별할 수 있기 때문이에요.\n\n최근 Diablo IV에서도 이를 확인할 수 있는데, 건강과 마나 바가 명확하게 빨간색과 파란색으로 나뉘어져 있습니다. 건강에 빨간색이 선택된 이유는 인간의 혈액과 활력과 연관이 있습니다. 한편, 마나는 파란-보라색조로 표현되어 있는데, 이는 과거에 무언갈 알 수 없거나 마법적인 것을 떠올리게 한다고 합니다.\n\n환경 디자인 측면에서는 빨간색이 긴장감을 조성하여, 플레이어가 적극적인 조치를 취할 수 있도록 하거나 두려움을 불러일으킵니다. 노란색조는 상호 작용 가능한 물체를 강조하여 환경 내에서 쉽게 눈에 띄게 함으로써 중요한 역할을 합니다.\n\n같은 장면의 여러 프레임을 완전히 다르게 조명할 수 있으며, 이는 게임, 영화, 애니메이션, 그리고 예술 전반에서도 해석할 수 있습니다. 한 때 모든 게 빨강과 보라로 물들여진 분위기는 긴장과 불신을 조성합니다. 그리고 다른 때에는 녹색이나 파란색일 수도 있어서 차분하고 편안한 분위기를 연출할 수 있죠.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Using light and color in game development: a beginner's guide](/assets/img/2024-05-27-Usinglightandcoloringamedevelopmentabeginnersguide_4.png)\n\n# 구성, 톤, 색상\n\n그래서 빛은 게임이나 영화 내에서 프레임 및 구성에서 중요한 요소입니다. 그러나 이 요소는 예술적인 규칙을 고려한다면에만 작용합니다: 선, 모양, 관점, 톤, 색 이론. 빛을 구성할 때 이론을 공부하고 적용하면 게임이 더 표현력 있고 흥미로워집니다.\n\n이론을 살펴보고 빛을 설정할 때 적용하는 것은 게임을 더 표현력 있고 흥미롭게 만듭니다. 기본적인 사항에 대해 알아보겠습니다. 구성부터 시작해봅시다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<table>태그를 Markdown 형식으로 변경하십시오.\n\n사진 속 가장 인기 있는 구성 기법 중 하나는 세분법입니다. 이는 클래식한 구성 원칙으로, 널리 사용되며, 표시하고자 하는 프레임 내에서 가장 흥미로운 요소와 중요한 부분이 이 프레임 내에서 어떤 상상의 선의 교차점에 위치해야 한다는 것을 명시한 것입니다. 이미지의 오른쪽 상단에 설명이 나와 있습니다.\n\n이것이 절대적인 규칙이 아니라 중요한 사항을 중점적으로 포착할 수 있도록 안내하고 편리한 템플릿으로 사용할 수 있는 것을 기억하는 것이 중요합니다. 아래에는 초점 요소의 사용 및 프레임을 요소 및 선분으로 나누는 방법이 작용하여 특정 시점에 중요한 요소나 행동에 중점을 둔 사진 몇 장을 보여줍니다.\n\n구성에 대한 공부를 소홀히 하거나 프레임을 구성하기 위한 특정 규칙을 준수하지 않는다면 전달하려는 정보가 소실될 수 있습니다. 따라서 예술적 기본 사항을 계속적으로 검토하는 것이 중요하며, 3D의 많은 측면은 고전 회화, 일러스트 및 영화 제작에서 나옵니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n일부 작곡 기법을 사용한다고 해서 사진과 장면이 즉각적으로 흥미롭고 영감을 준다는 것은 아니지만, 이를 통해 더 가깝게 다가갈 수 있게 될 거예요.\n\n영화에서 몇 가지 예시를 살펴 보겠습니다. 촬영의 구성과 무대 장치가 감독의 아이디어를 전달하는 데 어떻게 작용하는지 보여줍니다. 초점 및 프레임의 구획과 선분할은 특정 시점에 가장 중요한 요소 또는 행동에 강조를 두는 데 도움이 될 수 있어요.\n\n이제 조합이 게임에서 어떻게 적용될 수 있는지 살펴보죠. 예를 들어, God of War Ragnarök의 장소를 고려해 보세요.\n\n내 의견으로는 \"황금 삼각형\" 규칙이 여기에 잘 맞는 것 같아요. 화가들은 아마도 다른 규칙을 따랐을 것이지만, 저는 이 구체적인 방법만 분석할 거에요. 편의를 위해 관련된 선을 초록색으로 강조했습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n플레이어가 이전에 알지 못했던 장소에 도착해서 더 나아가야 할 때를 상상해 보십시오. 우리는 그들을 혼란스럽게 하고 싶지 않으며, 이동 경로를 이해하도록 도와주되 여행 중 지루함이 없도록 하고 싶습니다. 위의 이미지 속 구성은 작가들이 요소들을 배치함으로써 모든 것이 명확하고 가장 중요한 정보가 가장 눈에 띄는 위치에 있도록 하는 좋은 예시입니다.\n\n그러므로, 분명하게 영웅은 대각선으로 바로 앞에 있는 큰 문을 통해 통과해야 할 것이고, 프레임의 왼쪽에 위치한 내려가는 계단이 있습니다. 길이 강조되어 문으로 이어지고 있습니다. 물체들은 주로 양쪽에 위치하고 있는데, 이는 직진하고 싶은 본능적인 욕구를 일으킵니다.\n\n한편, 달빛은 문에 집중을 둔 상태로, 그것을 가장 밝게 보이는 장소로 만듭니다. 나머지 공간이 그림자 속에 있기 때문에 이 대조는 문을 보고 싶어하게 만듭니다. 두 개의 램프는 빛과 그림자의 대조를 보여주기 위해 전경에 놓여져 있으며, 이는 플레이어의 주의를 끌기 위한 역할을 합니다. 여기서 가장 흥미로운 점은 수목과 덩굴이 밝은 붉은 색조로 만들어졌다는 것인데, 이는 달빛과 녹색 식물과는 다르게 최대한의 주의를 끌도록 고안되었습니다. 문 뒤에 위치한 산은 문 너머에 탐험해야 할 큰 공간이 있다거나 일종의 시각적 풍경이 있다는 것을 시사합니다.\n\n이 모든 사항들: 구성, 조명, 색상, 내비게이션 및 물체 배치는 플레이어를 돕고 이야기를 전달하기 위해 설계되었습니다. (물론 싱글 플레이어 및 멀티플레이어 게임에서 작업할 때는 고유한 고려 사항이 있지만, 기본적인 접근 방식은 어디서나 동일합니다.)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 예제에서는 하나의 특정 프레임을 하나의 각도에서 살펴보았습니다. 그러나 캐릭터는 움직이고 주변을 보기도 하므로 어떻게 처리해야 할까요? 개발자들은 게임 플레이 관점에서 중요한 몇 가지 주요 각도를 선택해야 합니다. 이러한 각도는 나머지가 개발 과정 중에 확정될 때까지 기반이 될 것입니다. 개발자들은 플레이어가 위치에 들어오고 떠날 때 어떻게 할지, 게임 플레이에 따라 무엇을 보아야 할지를 숙고해야 하며, 여러 전문가들이 이 노력에 참여합니다: 컨셉 아티스트, 조명 아티스트, 환경 아티스트 등이 있습니다.\n\n구성 기초를 마스터한 후에는 빛과 색상을 다루는 또 다른 중요한 측면에 주목할 가치가 있습니다: 토널리티.\n\n토널리티는 삽화, 게임 및 영화 내에서 평면을 분리하는 기본 도구입니다. 톤이 없으면 모든 것이 하나의 평면으로 합쳐져서 프레임의 주요 아이디어를 식별하기 어렵게 될 것입니다. 프레임을 구분하기 쉽게 만들어주는 몇 가지 잘 알려진 기술이 있습니다: 지브라 조명, 대조 및 프레임을 평면으로 분할하는 것입니다.\n\n지브라 조명은 밝은 공간과 어두운 공간의 번갈아 나타남으로 인해 주목을 끌어냅니다. 이 기술을 사용하면 캐릭터를 강조하고 그들에게 강조를 둘 수 있습니다. 아래에서 캐릭터의 실루엣이 밝은 빛의 배경에 명확히 보이며 그 반대도 마찬가지입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/assets/img/2024-05-27-Usinglightandcoloringamedevelopmentabeginnersguide_6.png)\n\n대조와 색조를 다루는 또 다른 중요한 기법입니다. 지각적으로는 색이 아닌 톤이 항상 더 중요하다는 것을 기억하는 것이 중요합니다. 톤이 주로 부피를 만들고 시각적으로 그림을 나누는 역할을 합니다.\n\n아래 예시를 살펴보세요: 첫 번째 이미지에 색을 추가하는 것만으로는 색조나 강도를 다루지 않으면 큰 차이가 없습니다. 이미지는 여전히 단조롭고 부분들이 하나로 섞여있는 느낌을 줍니다. 그러나 톤을 조절하면 흑백 그림조차 돋보이며 명확한 대조가 나타납니다. 이미지의 부분들이 서로 어떻게 상호작용하는지 즉시 알아볼 수 있습니다.\n\n![이미지](/assets/img/2024-05-27-Usinglightandcoloringamedevelopmentabeginnersguide_7.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이미지의 부분을 분리하는 데 도움이 되는 또 다른 좋은 기술은 프레임을 평면으로 나누는 것입니다. 이 방식을 사용하면 플레이어(또는 다른 뷰어)가 서로 다른 객체들을 더 명확하게 구별할 수 있게 됩니다.\n\n아래 늑대 사진을 살펴보죠: 관찰자에게 얼마나 가까운지에 따라 빛과 톤으로 동물들을 그룹화한 것을 보여줍니다. 이 분할이 없다면, \"카메라\" 바로 앞에 앉아 있는 늑대와 먼 곳에 앉아 있는 늑대를 구별하기가 매우 어려울 것입니다.\n\n![늑대 사진](/assets/img/2024-05-27-Usinglightandcoloringamedevelopmentabeginnersguide_8.png)\n\n톤 키도 고려할 가치가 있는 유용한 도구입니다. 이는 사진, 프레임, 일러스트레이션의 표현 범위에 대한 정보를 제공하는 종류의 안내서입니다. 이 도구는 특히 게임에서 조명을 다룰 때 유용하며, 이야기 속에서 원하는 분위기를 원하는 시점에 달성할 수 있도록 도와줍니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n프로젝트의 전반적인 아트 디렉션과 위치의 작업 설명을 기반으로 톤 키가 선택됩니다:\n\n- 위치는 무엇입니까?\n- 어떻게 묘사해야합니까?\n- 어떤 분위기를 전달해야합니까?\n- 어떤 감정을 일으켜야합니까?\n\n보다 높은 컬러 키는 평온하고 희망을 전달할 수 있으며, 낮은 키는 긴장, 호기심, 위험을 전달할 수 있습니다.\n\n![이미지](/assets/img/2024-05-27-Usinglightandcoloringamedevelopmentabeginnersguide_9.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 개념 아티스트 스케치에서 가져온 몇 가지 예시이며, 이 중에서 고조도 및 저조도를 모두 포함하고 있습니다. 고조도는 밝은 색이 우세한 그림에서 보이며, 저조도는 어두운 톤이 우세한 그림에서 나타납니다.\n\n![image](/assets/img/2024-05-27-Usinglightandcoloringamedevelopmentabeginnersguide_10.png)\n\n# 색 조합의 종류\n\n이제 색에 대해 조금 이야기해보겠습니다. 색은 여러 가지 분리된 과학에 의해 연구되는 굉장히 거대한 주제입니다. 이에 따라, 초보자에게 유용한 색의 매우 기본적인 내용을 살펴보겠습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n색상은 다양한 구성 요소를 가지고 있으며, 다양한 조합으로 다양한 효과를 내놓습니다.\n\n![색상과 광과 색채의 사용: 게임 개발을 위한 초보자 안내서](/assets/img/2024-05-27-Usinglightandcoloringamedevelopmentabeginnersguide_11.png)\n\n색조는 본질적으로 기본 색상을 가리킵니다. 채도는 색상의 강도 또는 순도이며, 밝기(값)는 색상의 어둠 또는 밝기로 색의 모양과 깊이를 결정합니다.\n\n프레임이나 일러스트레이션에서 (전문 작업에 대한 이야기를 하고 있다면) 어떤 이유로 색상 조합이 특정 원칙에 따라 색상 바퀴에 근거하여 선택됩니다. 이 개념은 19세기로 거슬러 올라가며, 처음으로 언급된 것은 스위스 예술가 요한네스 이텐이 쓴 'The Art of Color'라는 책입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![image](/assets/img/2024-05-27-Usinglightandcoloringamedevelopmentabeginnersguide_12.png)\n\n이론에 따르면 항상 잘 어울리는 서로 다른 색상 세트가 있으며, 특별한 색상 바퀴를 사용하여 이러한 색상을 식별할 수 있습니다. 사실 다양한 조합이 있습니다: 상보적인 색상은 원의 반대편에 위치하며, 단일 색상 팔레트의 경우, 한 가지 색상을 취하고 조톤을 변경합니다; 유사한 색상은 색상 바퀴 상에서 서로 이어진 색상입니다.\n\n각각의 예시를 살펴보겠습니다.\n\n![image](/assets/img/2024-05-27-Usinglightandcoloringamedevelopmentabeginnersguide_13.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래에 보면 보충색을 볼 수 있습니다. 컬러 휠 내에서 빨강과 주홍은 초록과 연두의 반대 색상이며, 이 대비는 주목을 끕니다.\n\n![image1](/assets/img/2024-05-27-Usinglightandcoloringamedevelopmentabeginnersguide_14.png)\n\n위에서는 보충색을 볼 수 있으며, 등대로부터 나오는 따뜻한 빛과 전체 위치에 반짝이는 차가운 달빛의 대조를 관찰할 수 있습니다.\n\n![image2](/assets/img/2024-05-27-Usinglightandcoloringamedevelopmentabeginnersguide_15.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위 Firewatch 이미지에서는 유사한 색상이 따뜻한 분위기를 만들도록 도와줍니다. 동시에 밝기와 톤의 선택이 원하는 강조를 제공합니다.\n\n![Firewatch Image](/assets/img/2024-05-27-Usinglightandcoloringamedevelopmentabeginnersguide_16.png)\n\n위 그림에서는 분할 보충 색상을 사용했습니다. 확실한 파란 머리 색상과 노란색, 버건디 같이 색상 바퀴 반대편에서 온 색상들을 볼 수 있습니다.\n\n위에 보여진 방법들은 강조를 통해 프레임 안에서 관심을 끌기 위해 필요합니다. 모든 방법은 작가의 재량으로 선택되며 명확하고 명백한 경계는 없습니다. 중요한 것은 플레이어나 관람자가 의도한 아이디어를 얼마나 성공적으로 이해하는지입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 대상 관객\n\n광을 다룰 때 또 다른 중요한 측면은 대상 관객을 이해하는 것이며, 이는 작업 방법을 결정할 것입니다. 대상 관객은 대략적으로 두 가지 유형으로 나눌 수 있습니다: 현실주의와 스타일화. (이는 프로젝트, 아트 디렉션, 그리고 의도된 대상 관객에 따라 조건부이며 크게 영향을 받습니다)\n\n작업 양면에서, 현실주의는 현실 세계에 가능한 한 가깝게 사진을 전달해야 한다는 임무로 인해 항상 더 어렵습니다: 현실적인 조명, 재료, 효과 등이 필요합니다. 기술적으로 말하면, 게임이 영화와 달리 미리 녹화되지 않고 실시간으로 실행되므로 그림을 처리하는데 많은 리소스가 필요합니다. 그리고 타협할 여지가 없습니다: 뭔가를 망친다면 관객이 즉시 알아차릴 것입니다.\n\n스타일화는 강조색과 단순화된 형태에 초점을 맞춘 간소화된 방식입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n물론 창의성에 제한은 없어요: 스타일을 섞고 어울리게 조합할 수 있어요. 모든 것은 프로젝트의 총 예술적 방향에 달려 있죠.\n\n특히 빛과 색에 관한 이야기를 할 때, 사실주의는 중립적이고 차가운 색조를 특징으로 하며 뚜렷한 강조가 없어요. 예를 들어, 영화 \"덩컥\"과 게임 콜 오브 듀티: 제2차 세계대전의 이미지들이 여기 있어요.\n\n스타일화를 할 때는 완전히 다른 방식으로 작업해요. 밝은 색상과 강조로 주목을 끌며 게임의 전통을 완화하죠.\n\n여기에 포트나이트와 오버워치의 몇 장면이 있어요. 실제 세계에서는 우리가 이런 색상이나 조명을 보지 못하지만, 스타일화된 것은 관객으로 하여금 이러한 불일치를 비판하지 않고 모든 것이 조화롭게 보이게 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n라이트와 컬러는 게임과 영화 모두에서 분위기를 조성하고 감정을 전달하는 가장 강력한 도구 중 하나입니다. 그러나 이를 올바르게 활용하기 위해서는 일정 수준의 예술 지식이 필요합니다. 또한 다양한 게임을 플레이하고 분석하며 가능하다면 전문 서적을 읽어보는 것이 좋습니다 - James Gurney의 \"Color and Light\"로 시작하면 좋을 것 같아요. 이 모든 것이 여러분의 기술을 크게 향상시키는 데 도움이 될 것이며, 나머지는 이론을 계속 실천하는 문제에 불과해요!\n","ogImage":{"url":"/assets/img/2024-05-27-Usinglightandcoloringamedevelopmentabeginnersguide_0.png"},"coverImage":"/assets/img/2024-05-27-Usinglightandcoloringamedevelopmentabeginnersguide_0.png","tag":["Tech"],"readingTime":17},{"title":" 어떤 HTML5 게임 엔진이 최고일까요","description":"","date":"2024-05-27 16:51","slug":"2024-05-27-WhatAretheBestHTML5GameEngines","content":"\n![HTML5 Game Engine](/assets/img/2024-05-27-WhatAretheBestHTML5GameEngines_0.png)\n\nHTML5 게임 개발에 뛰어들 때, 프로젝트의 성공을 위해 올바른 게임 엔진을 선택하는 것이 중요합니다. 여기에는 몇 가지 최고의 HTML5 게임 엔진, 그들의 기능, 그리고 다양한 사용자 요구를 충족하는 방법에 대한 자세한 정보가 있습니다.\n\n## 🔹 1. Phaser\n\n나는 Phaser 게임 엔진으로 게임 개발 경력을 시작했습니다. 그 시절에는 카지노 게임을 만들고 있었고, Phaser는 가장 많이 분기되고 이야기된 프레임워크 중 하나였습니다. 잘 문서화된 API와 매우 다양한 기능을 이해할 수 있는 많은 예제를 제공하는 완벽한 게임 엔진으로, Phaser는 최고의 선택 중 하나였습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nPhaser에는 편집기가 없기 때문에 게임 객체의 디자인 및 배치를 볼 수 없습니다. 특히 UI 관련 변경 사항에 대해 알기 어렵습니다. 게임 객체의 배치와 동작을 상상해야 했었습니다. 제게 가장 어려웠던 부분은 게임에 물리학을 추가하는 것이었습니다. 처음 시작했을 때 게임에 물리학을 통합하는 데 능숙해지고, 교육 과정 중에 물리학에 큰 관심이 없었습니다.\n\n이러한 어려움에도 불구하고, 나는 Phaser를 좋아했습니다. 코드 중심적인 접근 방식으로 인해 게임 개발 중의 메카닉과 동작에 대한 더 깊은 이해를 얻을 수 있었습니다. 그러나 Cocos Creator를 사용한 후에 시각적 인터페이스 게임 엔진의 중요성을 깨달았습니다. Cocos Creator는 게임 UI를 디자인 미리보기대로 제작하는 데 소요되는 시간을 크게 줄여줍니다. 이를 통해 제작 프로세스가 더욱 간소하고 효율적으로 진행됩니다.\n\n특징:\n\n- 매우 인기가 높고 잘 문서화되어 있습니다.\n- 다양한 예제와 튜토리얼이 있습니다.\n- WebGL 및 Canvas 렌더링을 지원합니다.\n- 풍부한 플러그인 생태계를 보유하고 있습니다.\n- 2D 게임 개발에 탁월합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nPhaser는 강력한 2D 게임 엔진을 찾는 개발자들에게 이상적이며 뛰어난 커뮤니티와 다양한 학습 자료가 제공됩니다. 이 엔진은 아케이드 스타일 게임, 플랫포머, 그리고 캐주얼 게임을 만드는 데 적합합니다. 그러나 시각적 편집기가 부족하므로 개발자들은 게임 객체의 배치와 행동을 코딩해야 합니다. 이는 상상력과 계획력이 필요할 수 있습니다.\n\n## 🔹 2. Cocos2d-JS (Cocos Creator)\n\nCocos Creator를 배우기 시작했을 때, 처음에는 문서가 중국어로 되어 있어 어려웠습니다. 영어 문서는 주로 자명한 노트 형식이었습니다. 그러나 결국 Cocos 문서는 매우 유용해지고 이제는 그것을 잘 알게 되었습니다. Cocos에 대한 우리가 갖고 있는 매뉴얼은 항상 좋습니다. 그것은 Cocos의 핵심 개념을 잘 이해할 수 있도록 도와줍니다.\n\n특징:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 2D 및 3D 게임 개발 지원\n- 쉬운 디자인 및 객체 배치를 위한 시감 편집기\n- 물리학을 위해 Box2D 및 Chipmunk 통합\n- 모바일 및 데스크톱을 포함한 크로스 플랫폼 지원\n- JavaScript로 스크립팅\n\nCocos Creator는 게임 장면과 객체를 디자인하는 시감 인터페이스를 선호하는 개발자에게 적합합니다. 시감을 통해 개발 프로세스를 간단하게 만들어주며, 초보자와 숙련자 모두에게 적합합니다. 복잡한 물리학과 크로스 플랫폼 배포를 필요로 하는 복잡한 게임에 이상적입니다.\n\n## 🔹 3. Construct 3\n\n저는 현재 속해 있는 Gamezop에서 Construct 게임 엔진을 처음으로 접했습니다. 처음에는 이런 것을 본 적이 없어서 이상한 경험이었습니다. 우리는 전혀 코드를 작성하지 않으므로요. 하나의 게임 객체에 대해 Construct 게임 엔진에게 이것을 요청하고 다른 것을 다른 것에 요청하는 것처럼 보였습니다. 그런 다음 게임 크리에이터가 무엇인지 알게 되었습니다. Construct는 게임 엔진뿐만 아니라 게임 크리에이터입니다. 코딩 지식이 없어도 Construct를 사용하여 게임을 만들 수 있습니다. 이전에는 소프트웨어를 다운로드하여 우리 기계에서 실행했지만, 이제는 완전히 온라인으로 사용할 수 있고 많은 추가 기능이 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n기능:\n\n- 프로그래밍이 필요하지 않음; 시각적 이벤트 기반 시스템 사용.\n- 장치에서 접근할 수 있는 클라우드 기반 편집기.\n- 빠른 프로토타이핑 및 개발.\n- HTML5, Android, iOS 등 다양한 플랫폼으로 내보내기.\n- 다양한 플러그인 지원.\n\nConstruct 3은 코드 작성 없이 빠르게 게임을 만들고 싶은 개발자에게 적합합니다. 시각적 스크립팅 시스템을 통해 빠른 개발 및 프로토타이핑이 가능하며, 게임 디자이너, 취미 개발자, 교육 목적에 적합합니다. 2D 게임에 가장 적합하며 비 프로그래머에게 매우 접근하기 쉽습니다.\n\n## 🔹 4. Babylon.js\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n바빌론.js를 Phaser처럼 3D 게임 개발을 위한 도구로 보고 있어요. 바빌론.js 문서에 있는 시작 프로젝트 이외에는 처음부터 게임을 만들어보지 못했어요. 처음에는 코드 중심이었지만, 이제는 시각적 편집기도 도입되어 디자이너와 시각적 인터페이스를 선호하는 개발자들에게 접근하기 쉬워졌어요.\n\n특징:\n\n- 3D 게임 개발에 초점을 맞추고 있어요.\n- 고성능 렌더링을 위한 WebGL 기반.\n- 복잡한 3D 씬을 만들기 위한 다양한 기능.\n- 포괄적인 문서와 예제.\n- 다양한 도구와 프레임워크와의 통합.\n\n바빌론.js는 고품질 3D 게임이나 상호작용 경험을 만들고 싶은 개발자에게 이상적이에요. 3D 그래픽과 WebGL에 대한 충분한 이해가 필요하며, 현실적인 그래픽, VR 경험 또는 복잡한 3D 상호작용이 필요한 프로젝트에 적합해요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 🔹 5. Three.js\n\nThree.js은 웹 게임 개발을 위해 가장 뛰어난 3D 게임 엔진 중 하나입니다. Three.js를 사용하여 3D 게임 개발을 마스터하고 싶었는데, 그 인기와 다양한 사용 사례 때문에요. 처음 시작하는 사람들에게는 조금 어려울 수도 있지만, 코드 중심의 프레임워크이기도 하죠. 그래도 언제나 Three.js로 3D 게임 개발을 배우는 것을 권장합니다.\n\n주요 기능:\n\n- 강력한 3D 그래픽 라이브러리.\n- 고성능을 위해 WebGL 기반.\n- 광범위한 예제와 활발한 커뮤니티.\n- 어떤 유형의 3D 콘텐츠도 생성할 수 있는 유연성.\n- 다른 라이브러리와 프레임 워크와 잘 통합됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nThree.js는 웹에서 사용자 정의 3D 경험을 만드는 것을 원하는 개발자에게 좋은 도구입니다. 많은 유연성을 제공하지만 3D 수학과 그래픽 프로그래밍에 대한 튼튼한 이해가 필요합니다. 시각화, 시뮬레이션, 사용자 정의 3D 렌더링이 필요한 게임 등을 만드는 데 적합합니다.\n\n## 🔹 6. PlayCanvas\n\nPlayCanvas는 웹 기반 게임 엔진으로, 소개될 당시 독특한 존재였습니다. 현재 Construct 3도 웹 기반으로 되었지만, PlayCanvas가 처음에 이런 형태로 개발되었습니다. 자체 스크립팅 언어를 갖추고 있으며, 이 엔진을 사용하여 2D 및 3D 게임을 만들 수 있습니다. 나는 어떻게 웹에서 반응성을 갖춘 게임 엔진을 만들었는지 항상 궁금해했습니다. 내가 반응적인 게임을 만들기 어려워하는 동안에도 말이죠.\n\n주요 기능:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 웹 기반 개발 환경.\n- 실시간 협업 및 편집.\n- 3D 게임 개발에 중점.\n- 프로젝트의 쉬운 게시 및 공유.\n- WebGL과의 우수한 성능.\n\n플레이캔버스는 협업 개발 환경이 필요한 3D 게임 또는 인터랙티브 응용 프로그램을 개발하는 팀에 이상적입니다. 웹 기반 편집기를 통해 실시간 협업이 가능하므로 분산된 팀에 적합합니다. 쉬운 공유와 게시가 필요한 프로젝트에 가장 적합합니다.\n\n# 🔄 사용자 유형에 따른 차이점:\n\n![다운로드 이미지](/assets/img/2024-05-27-WhatAretheBestHTML5GameEngines_1.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- Phaser 대 Cocos Creator: Phaser는 시각적 편집기가 없는 코드 중심으로, 모든 것을 수동으로 코딩하는 것을 즐기는 개발자에게 적합합니다. Cocos Creator는 시각적 편집기를 제공하여 디자인 및 레이아웃에 GUI를 선호하는 사람들에게 더 접근하기 쉽습니다.\n\n- Construct 3 대 Phaser: Construct 3는 비 프로그래머나 코드를 작성하지 않고 빠르게 게임을 개발하고자 하는 사람들에게 이상적이며, Phaser는 프로그래밍 지식이 필요하며 사용자 정의 논리에 대해 더 많은 유연성을 제공합니다.\n\n- Babylon.js 대 Three.js: 두 프레임워크 모두 3D 게임에 탁월하지만, Babylon.js는 게임 개발을 위한 내장 기능을 제공하는 더 포괄적인 프레임워크를 제공하며, Three.js는 사용자 정의 3D 렌더링 프로젝트에 대해 더 많은 유연성과 제어를 제공합니다.\n\n- PlayCanvas 대 Babylon.js: PlayCanvas는 협업 웹 기반 환경을 제공하여 팀에 적합하며, Babylon.js는 강력한 독립형 3D 엔진을 제공하고 오프라인에서 작업하거나 자체 도구 체인과 통합하는 것을 선호하는 개발자들에게 더 중점을 둡니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 🏢 게임존의 접근 방식\n\n게임존에서는 다양한 게임 엔진을 활용하여 각 프로젝트의 복잡성과 성격에 맞는 게임 포트폴리오를 만들어냅니다. 현재 저희가 주로 사용하는 게임 엔진은 Cocos Creator입니다. 전 세계의 게임 개발자 및 스튜디오들과 협력하면서, 각 게임 엔진에 대한 철저한 이해와 실무 경험을 가지고 우리의 특정 요구사항을 충족시키기 위한 필요한 조정을 할 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-05-27-WhatAretheBestHTML5GameEngines_0.png"},"coverImage":"/assets/img/2024-05-27-WhatAretheBestHTML5GameEngines_0.png","tag":["Tech"],"readingTime":8},{"title":"모든 RPG에서 늘 같은 실수를 하곤 해","description":"","date":"2024-05-27 16:50","slug":"2024-05-27-IMakeTheSameMistakeinEveryRPG","content":"\n다이아블로 IV는 대부분의 다른 비디오 게임 RPG와 마찬가지로 다양한 플레이 메카닉과 시스템이 풍부합니다. 플레이어들은 다양한 장비, 스킬, 업그레이드, 재사용 대기시간, 회피, 공격 등을 균형 있게 유지해야 하며, 도전으로 가득한 큰 오픈 월드를 탐험합니다.\n\n최근에 출시된 업데이트는 이미 복잡한 게임에 더 많은 메카닉을 추가해 충격적으로 좋았습니다. 새로운 메뉴를 사용하고 수집할 레시피도 추가되었습니다. 그래서 때때로 이 모든 콘텐츠에 내 머리가 얽히기도 하죠, 비록 이것이 아마도 내가 가장 좋아하는 게임 장르일지라도요.\n\n이 복잡한 내용을 대부분 잘 다루며, 버튼이 많은 게임에서도 플로우 상태에 진입하는 데 뛰어납니다. 하지만 포션이라도 사용하는 것을 기억하는 데는 굉장히 별로입니다.\n\n여기서 말하는 것은 단순한 치유 포션이 아니라 게임이 제공하는 다른 어떤 포션이든 말이죠. 다이아블로 IV에서는 다양한 일시적인 스탯 부스트 포션과 엘릭서를 찾거나 제작할 수 있습니다. 이러한 포션들은 경험치 보너스나 추가 공격 속도와 같은 큰 혜택을 제공하며 종종 15분이나 30분과 같은 긴 시간 동안 지속됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n안타깝게도, 이런 유용한 아이템들은 주 인벤토리 페이지보다 더 낮은 위치에 있는 탭에 숨겨져 있습니다. 게임 초반에 한 번만 안내를 받는다는 점이 아쉬울 때가 많아요. 그 이후로 수십 시간을 플레이했는데도, 항상 포션 탭을 확인해봐야겠다는 것을 잊어버리곤 해요.\n\n가끔씩 생각해보게 되면, 다른 번거로운 문제가 생겨요. 나와 많은 RPG 팬들의 머릿속에 있는 작은 도깨비가 나타나는데, 이 도깨비는 어떤 한정된 아이템을 사용하지 말라고 제게 조언해요. \"만약에 추후에 필요할 때를 대비해 두는 게 어때?\" 라며 악몽 같은 미소를 짓죠. \"이 아이템이 주는 보너스를 사용하지 않고 낭비하게 되면 어떡해? 아이템을 낭비하고 싶지 않겠지?\" 그는 의심스러운 주장을 하지만, 매번 이게 이상하게 끌리는 거예요.\n\n이 도깨비 호더 경험을 겪는 사람은 나뿐만이 아니라는 건 알아요. YouTube 채널 VLDL의 코미디 스케치가 이 게임 고난을 잘 표현한 내가 좋아하는 콘텐츠 중 하나에요. 이러한 행동은 게임에서 아이템을 많이 주워들이고 멋진 것들을 수집하도록 가르치는 게임이 대부분인데, 그 후에는 그것들을 지키고 싶은 욕구가 자연스럽죠.\n\n숨겨진 인벤토리 탭 문제는 조금 더 수정 가능해 보여요. 만약 Diablo IV 포션이 UI의 더 자주 액세스되는 부분에 있다면, 기억하기도 쉬울 것 같아요. 아마 그런데 이 도깨비를 설득할 수만 있다면요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n많은 다른 게임에서도 같은 문제를 겪었어요. 작은 스탯 강화 아이템을 사용하는 게임들이 많거든요. 드래곤 에이지 인퀴지션에서는 무기 공격을 강화하는 다양한 물약과 독을 활용할 수 있는데, 그것들은 메뉴 안에서 더 재미난 마법 주문과 능력들 뒤에 숨겨져 있어요. 암살자의 길 리벨레이션에서는 플레이어들이 다양한 작은 투척 무기와 폭탄을 제작할 수 있는 복잡하고 인상적인 시스템이 있는데, 대부분을 사용하지 않는 이유는 게임의 핵심 메커니즘이 더 쉽게 접근 가능했기 때문이에요.\n\nUI 요소들이 잘 숨겨져 있어서 스탯 강화 물약 같은 것들이 게임 경험 전체에 미치는 중요성이 상대적으로 약해질 수 있지만, 이런 것들을 우연히 찾아 사용하면 큰 영향을 줄 수 있다는 걸 자주 깨닫곤 해요. 물론 이러한 작업은 플레이어들에게 더 많은 재미와 전투 이점을 주기 위해 이루어진 거예요. 물론 사용할 만큼 디자인되었지만, 그들이 중요한 요소로 인식되는 건 아니에요. 그래서 저는 재미있는 장식품보다는 정당한 전략으로 그들을 생각하지 않고 마음속에서 후순위로 밀어냅니다.\n\n모든 작은 스탯 혜택을 뽑아내는 것을 좋아하는 플레이어들에게는 반대의 문제가 발생할 수 있어요. 미니 보스를 빠르게 해치우는 완벽한 강화된 원소 공격을 선택할 수 있는데, 메뉴 앞에 정말 강력한 화염구가 있는 것에 제대로 주의를 기울이지 않을 수도 있어요. 모로윈드에서 물약 조합 영상을 보면 플레이어들이 최종 보스로 도약하거나 거의 무적이 되는 놀라운 것들을 할 때가 있어요. 하지만 제게는 항상 굴을 넘어서 검으로 칼을 휘두르고 있는 게 현실이에요.\n\nRPG 장르의 \"장점\" 중 하나는 매력적인 기계적 요소들이죠. 그들은 깊이와 플레이어의 선택지로 충만해요. 모든 시스템에 참여할 필요는 없지만, 가장 좋은 시간을 보내고 싶다면 그들과 상호작용해 보는 게 좋아요. 그래서, 아마 한 번에 모든 이상한 물약과 스탯 강화 아이템을 모두 소비해 보세요. 인벤토리가 완전히 비어질 때까지 모두 사용해 보세요. 다시 채우려면 더 많은 것들을 클릭해서 디지털 가방에 다시 채워 넣을 수 있으니까요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n상기 게임 제작사 중 어느 누구로부터 글을 쓰도록 요청받지도, 돈을 받지도 않았어요. 언급된 모든 게임은 제 자신이 현금으로 구입했습니다.\n","ogImage":{"url":"/assets/img/2024-05-27-IMakeTheSameMistakeinEveryRPG_0.png"},"coverImage":"/assets/img/2024-05-27-IMakeTheSameMistakeinEveryRPG_0.png","tag":["Tech"],"readingTime":4}],"page":"46","totalPageCount":110,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":2},"__N_SSG":true}