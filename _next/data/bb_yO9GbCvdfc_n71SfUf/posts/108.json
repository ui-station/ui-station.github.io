{"pageProps":{"posts":[{"title":"어이쿠, 내 앱이 성공했는데 접근성에 대해 생각하지 않았어요","description":"","date":"2024-05-17 18:44","slug":"2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility","content":"\n본인이 천재적인 앱 아이디어, 새로운 일자리, 또는 벤처 자본을 받았을 때, 새로운 기능을 배포하는 데만 시선을 집중하는 유혹이 감도는 건 이해합니다.\n\n올바른 방식으로 집중한다면, 이러한 집중은 앱을 다운로드 차트의 정상으로 랭킹시키며 성과를 거둘 수 있습니다. 그렇지만 그것으로 충분하지 않습니다. 모두가 본인의 앱을 사용하기 전까지 멈출 수 없을 겁니다.\n\n이런 믿을 수 없는 목표를 달성한 후, 현실적인 진실을 알아차립니다: 6명 중 1명이 본인의 앱이 고장나있다고 생각합니다.\n\n그런 다음, 깨닫게 됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n16%의 사람들이 어떤 형태의 접근성(a11y - 멋진 친구 중 하나라면) 요구사항을 가지고 있습니다. 그러나 자유롭게 움직이면서 일할 때, 쉽게 a11y를 뒷전에 두는 경우가 많습니다. 특히 기한에 쫓기고 리더십으로부터 제한된 참여를 받을 때 말이죠.\n\n더 성공하게 되면, 사용자들의 접근성 요구를 인정하지 못한 것으로 비판받을 확률이 커집니다. 불행히도 이를 우선적으로 다루기가 어렵습니다. 영향력 있는 누군가가 접근성을 옹호하지 않는 한 말이죠.\n\n오늘은 도와드리겠습니다. 앱을 접근성에 맞춰 빠르게 개선하는 방법을 보여드릴게요:\n\n- SwiftUI 앱에서 a11y를 점검합니다.\n- 모든 텍스트 크기에서 앱을 잘 보이도록 만듭니다.\n- 화면 낭독기를 사용할 수 있게 만듭니다.\n- 이해관계자들을 설득하여 a11y를 우선시하도록 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 기사를 위해 특별히 만든 캣 테마 동반 앱을 살펴볼 것입니다. 표면 상으로는 괜찮아 보이지만, a11y(웹 접근성) 관점에서 평가를 시작하자마자 완전히 망가진 상태입니다.\n\n기술을 완전히 이해하고 싶다면, 코드를 함께 작성해보세요! 우리는 이 기사에서 자세히 다룬 모든 기술을 구현하기 위해 Before/ 폴더에서 시작합니다 (최종 및 개선된 앱은 After/ 폴더를 참조하세요).\n\n# 앱의 접근성(A11y) 감사\n\na11y(웹 접근성)를 제대로 이해하려면 실제 장치에서 접근성을 테스트해야 합니다. 이것이 모든 사용자가 앱과 상호 작용하는 방식입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n접근성(a11y) 작업을 진행할 때는, 먼저 컨트롤 센터를 최적화해야 합니다. 정말 대단한 시간을 절약할 수 있어요.\n\n아이폰 설정으로 이동하여, 컨트롤 센터에 \"텍스트 크기\" 컨트롤과 \"접근성 바로 가기\"를 추가해보세요. \"텍스트 크기\"를 추가하면, 어떤 어플에서든 어디서든 밑으로 스와이프하여 텍스트 크기를 즉시 선택할 수 있어요. 심지어 어플당 크기 조절도 가능해요.\n\n\"접근성 바로 가기\"를 추가하면, 어시스티브터치(AssistiveTouch), 보이스오버(VoiceOver), 색상 필터, 모션 감소 등 다양한 접근성 기능을 쉽게 적용할 수 있어요. 하지만 잠금 버튼을 세 번 누르면 동일한 메뉴가 나오기 때문에 더 쉽게 접근할 수 있어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 텍스트 크기 감사\n\niOS에서는 extraSmall부터 accessibilityExtraExtraExtraLarge(즉, AX5)까지 12가지의 텍스트 크기 옵션이 있습니다. 최대 크기인 accessibilityExtraExtraExtraLarge는 기본(큰) 크기보다 약 310%\\* 더 큽니다.\n\n텍스트 크기가 정상적으로 작동하는지 확인하기 위해 두 가지 감사를 선호합니다:\n\n- 앱을 가장 큰 일반 폰트인 extraExtraExtraLarge(즉, xxxl)로 테스트하고, 가급적 볼드 텍스트 접근성 설정도 활성화하세요. 이는 상대적으로 일반적인 가장 큰 폰트로, 제 어머니도 이 폰트를 사용합니다. 앱은 이 크기에서 잘 보여야 합니다.\n- 앱을 가장 큰 접근성 폰트인 AX5로 테스트하세요. 이 크기는 익숙하지 않다면 우스꽝스러울 수 있지만, 이 크기밖에는 앱과 상호작용할 수 있는 방법이 없는 사람들이 있습니다. UI를 이 크기로 완벽하게 만드는 것은 어려울지라도, 접근성 텍스트 크기 설정에서 앱이 작동하는지조차 확인하지 않은 회사는 명백히 부족합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저희 앱을 한 번 살펴보겠습니다.\n\n![앱 스크린샷](/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_1.png)\n\n바로 앱을 실행해보면, 정성껏 디자인한 로그인 UI가 텍스트 크기 조절 시 문제가 발생합니다. 저희는 대용량의 텍스트 크기를 예상하지 못했기 때문에 내용을 스크롤할 필요가 있다는 생각조차 하지 못했습니다.\n\n더 나아가서, 색맹일 경우 로그인 버튼의 대비가 미미하여 버튼을 읽을 수 없을 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리 앱의 메인 목록 화면도 확인해 봅시다.\n\n![Main List Screen](/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_2.png)\n\n이 화면은 덜 '부서지는' 느낌이 나요. 모든 것이 보이지만 액세스 가능한 크기의 폰트를 사용하는 사람에게는 이 크기에서 앱을 테스트하지 않았다는 것이 분명합니다. 공간을 다투는 텍스트 레이블이나 순창방에서 아이콘만큼 큰 캡션을 보세요.\n\n## 스크린 리더 오디트\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n일부 사용자는 텍스트 크기 조정에 영향을 받지 않습니다 — 그들은 앱과 상호 작용하기 위해 스크린 리더기가 필요할 수 있기 때문입니다.\n\niOS VoiceOver는 여기서의 중요한 작업을 훌륭하게 처리하므로 여러분 팀의 약간의 배려가 큰 차이를 만들어냅니다.\n\n텍스트 크기 감사와 마찬가지로 스크린 리더기 감사도 실제 기기에서 하는 것이 가장 좋습니다 (잠금 버튼을 3번 눌러보세요, 기억하세요!). 또한 Xcode에 내장된 개발자 도구인 접근성 검사 도구가 VoiceOver 작업에 도움이 됩니다.\n\n![2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_3.png](/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_3.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n앱을 통해 걸어가면, 텍스트 크기 조정과 비교하면 적어도 깨진 부분이 적은 편이에요. 하지만 이미지와 같은 많은 UI 영역이 전혀 보이지 않아 사용자에게 직접적인 지원이 되지 않아요. 그 이유는 접근성 레이블을 추가하는 데 신경을 쓰지 않았기 때문이죠.\n\n![이미지1](/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_4.png)\n\n특히 VoiceOver를 사용하지 않은 경우, 화면 리더기가 모든 UI 요소를 반복하며 읽어주지만 아이콘에는 라벨이 붙어있지 않아 명확합니다.\n\n![이미지2](/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_5.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n큰 목록이 있으면 상황이 더 악화됩니다.\n\nSwiftUI에 내용에 대한 정보를 제공하지 않으면, 스크롤 가능한 내용의 아래쪽 로그아웃 버튼으로 이동하려면 100번 이상 스와이프해야 할 수도 있는 상황에 처하게 될 수 있습니다. 페이징에 대해서 시작도 하지 마세요.\n\n![앱 접근성을 고려하지 않고 앱이 성공적이라고 생각하지 않은 경우 스크린샷](/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_6.png)\n\n우리 앱을 접근성이 좋은 앱이라고 부를 수 있기 전에 해결해야 할 문제가 많습니다. 다행히 SwiftUI에는 a11y에 대해 신속하게 파악할 수 있는 도구가 가득합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 스피드런 액세시빌리티\n\n이제 문제가 어디에 있는지 알았으니, 하나씩 빠르게 해결해 나갈 수 있어요.\n\n## 스크롤 가능한 콘텐츠\n\n이것은 가장 불편한 문제입니다. 큰 텍스트 크기에 대한 스크롤 뷰로 확장되지 않아 앱 온보딩이 완전히 망가졌어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리의 감사에서는 로그인 화면 버튼이 폰트 크기가 커짐에 따라 화면 밖으로 밀렸습니다. 나머지 텍스트 내용은 서로 밀어붙여져 레이블이 겹치고 확장할 공간이 없어 잘린 것처럼 보였어요.\n\n자연스러운 해결책은 콘텐츠를 스크롤 가능하도록 만드는 것입니다. 그러나 모든 화면이 컨텐츠가 잘 맞는 경우에도 스크롤이 자유롭게 되어서는 안 됩니다. 우리는 Ionic 앱을 만드는 일이 아니에요. _억압된 기억으로 전율을 느끼며_\n\n이 문제는 사용자 지정 뷰 수정자로 해결할 수 있습니다. 제가 a11yScrollView()라고 부르는 이 뷰 수정자의 목표는 화면 내용을 스크롤 뷰로 감싸지만 필요한 경우에만 발생하도록 하는 것입니다. 이것을 작은 라이브러리 A11yUtils에 추가하여 여러분의 코드에서 사용할 수 있도록 했어요.\n\n현재 이것은 iOS 16.4 이상에서만 우리의 꿈이 되는 동작을 실현합니다 — 이미 콘텐츠가 맞는 경우 스크롤을 방지하기 위해 스크롤 뷰에 scrollBounceBehavior를 적용합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n미래에는 iOS 16에서 ViewThatFits\\* 및 iOS 15에서 GeometryReader와 함께 작동하도록하고 싶습니다.\n\nOS 버전을 지정하는 사람이 주위에 없기 때문에 저희 온보딩 뷰의 VStack에 이 수정자를 적용할 수 있습니다.\n\n```swift\n// OnboardingView.swift\n\nimport A11yUtils\nimport SwiftUI\n\nstruct OnboardingView: View {\n\n    @Binding var isLoggedIn: Bool\n\n    var body: some View {\n        NavigationStack {\n            VStack(spacing: 20) { /* ... */ }\n              .padding(.horizontal)\n              .a11yScrollView()\n              .navigationTitle(\"Create account\")\n        }\n    }\n}\n```\n\n이제 콘텐츠가 멋지게 스크롤되어 xxxl, AX3 및 AX5에서 잘 보입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_7.png\" />\n\n## 스페이서는 코드 냄새입니다\n\n온보딩 화면을 작업하는 동안, 우리가 할 수 있는 또 다른 간단한 개선 사항이 있습니다:\n\n```js\nVStack(spacing: 20) {\n    // ...\n    OnboardingReasonsText()\n    Spacer()\n    LoginButtonView()\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n텍스트 크기가 크면 화면 공간이 제한되어 Spacer()를 사용하면 문제가 발생할 수 있습니다. SwiftUI 레이아웃 엔진은 공간을 만들기 위해 열심히 노력합니다. 심지어 그 공간이 더 이상 없어도 텍스트가 절단되는 문제가 발생할 수 있습니다.\n\n이러한 시나리오에서 스페이서를 매우 좁은 높이로 압축해도 VStack에 정의된대로 위아래로 각각 20포인트의 공간이 생길 것입니다.\n\n우리는 Spacer()를 frame() 수정자로 바꿀 수 있습니다:\n\n```js\nVStack(spacing: 20) {\n    OnboardingReasonsText()\n    LoginButtonView()\n        .frame(maxHeight: .infinity, alignment: .bottom)\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n프레임은 더 신뢰할 수 있는 방식으로 작동합니다: SwiftUI는 이 버튼 위에 가능한 한 많은 공간을 제공해야 함을 알지만, 여백 자체가 UI의 중요한 부분이 아니기 때문에 공간이 부족하면 불필요한 여백이 적용되지 않습니다.\n\n이 프레임 수정자는 의미가 더 명확합니다. 즉, SwiftUI에게 우리의 의도를 명확하게 전달합니다. 이것은 a11y와 관련된 중요한 개념이므로 나중에 더 자세히 다룰 것입니다.\n\n## 이미지와 아이콘의 확대\n\n다이나믹 타입 덕분에 iOS는 사용자가 선택한 글꼴 크기에 따라 앱 내 글꼴을 자동으로 확대합니다. 이것은 사용자 정의 글꼴과도 쉽게 구현할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이는 SwiftUI에서 의미있는 글꼴 크기를 사용할 때 텍스트가 자동으로 조절된다는 것을 의미합니다.\n\n```js\nText(cat.quote)\n    .font(.body) // 이것도 잘 작동합니다\n```\n\n더 좋은 것은 SFSymbols를 사용할 때 아이콘에도 동적 글꼴 크기를 적용할 수 있다는 것입니다!\n\n```js\nImage(systemName: \"heart.circle.fill\")\n    .font(.body) // 이것도 SFSymbols와 잘 작동합니다\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n안타깝게도 대부분의 iOS 앱에는 Android 버전이 있으므로, 디자이너가 SFSymbols을 사용하는 대신 맞춤 아이콘을 만든다는 점에 유의하셔야 합니다. 대부분의 앱은 사용자 정의 이미지와 미디어를 포함합니다.\n\n따라서 우리의 예시인 Before/에서는 아이콘을 SwiftUI에 추가하는 일반 이미지처럼 처리하여, 하드코딩된 크기를 사용했습니다.\n\n```js\nImage(cat.image)\n    .resizable()\n    .aspectRatio(contentMode: .fit)\n    .frame(width: 72, height: 72) // 하드코딩된 크기 - 확장되지 않을 것입니다!\n    .clipShape(Circle())\n\nImage(systemName: cat.icon)\n    .resizable()\n    .aspectRatio(contentMode: .fit)\n    .foregroundStyle(.secondary)\n    .frame(width: 24, height: 24) // 하드코딩된 크기 - 확장되지 않을 것입니다!\n```\n\n결과는 어떻게 될까요? 가장 큰 글꼴 크기로 조정했을 때, 콘텐츠가 매우 어울리지 않게 보일 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![image](/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_8.png)\n\nSwiftUI에는 사용자 정의 이미지 및 뷰에서 동적 타입의 파워를 제공하는 멋진 도구인 @ScaledMetric 프로퍼티 래퍼가 있습니다.\n\n```swift\n@ScaledMetric(relativeTo: .largeTitle) private var imageSize: CGFloat = 72\n@ScaledMetric(relativeTo: .body) private var iconSize: CGFloat = 24\n```\n\n우리는 @ScaledMetric을 자체로 사용할 수 있으며, 이는 기본 body 글꼴 크기 조정을 사용합니다. relativeTo를 사용하면 SwiftUI가 어떻게 조정할 지 알 수 있으므로 더 좋습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nlargeTitle은 이미 상당히 크기 때문에 조금 더 확장됩니다. 캡션 스타일의 글꼴은 더 많이 확장됩니다. 이 경우 아이콘은 본문 크기 조정이 되어 동반하는 인용문 텍스트와 일치합니다.\n\n```js\nImage(cat.image)\n    .resizable()\n    .aspectRatio(contentMode: .fit)\n    .frame(width: imageSize, height: imageSize) // 동적 크기 조정\n    .clipShape(Circle())\n\nImage(systemName: cat.icon)\n    .resizable()\n    .aspectRatio(contentMode: .fit)\n    .foregroundStyle(.secondary)\n    .frame(width: iconSize, height: iconSize) // 동적 크기 조정\n```\n\n이제 이미지가 텍스트와 함께 더 합리적으로 보입니다.\n\n<img src=\"/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_9.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 콘텐츠 정렬하기\n\n이미지는 더 잘 확장되지만, 여전히 텍스트 라벨이 공간을 지배하며 UI가 깨져 보입니다. 레이아웃 엔진과의 협상을 끝내고 나니, 줄바꿈으로 가득 차 있습니다.\n\n만약 사용자의 텍스트 확장에 기반한 컨텐츠의 정렬이 가능하다면 어떨까요?\n\n다행히도, 라이브러리 A11yUtils 덕분에 A11yHStack을 활용할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n새로운 SwiftUI 도구 릴리스 속도가 빨라서 (그리고 Apple의 뒷전포기가 혹독해서), 이것은 최소 지원 OS에 기반을 둔 두 가지 다른 구현을 가지고 있어요:\n\n- iOS 16에서는 ViewThatFits를 사용하여 HStack이 모든 내용을 포함할 수 있는지 확인하고, 그렇지 않으면 내용을 정렬하기 위해 VStack을 사용합니다.\n- iOS 15에서는 더 단호한 방식을 적용하여, @Environment(\\.sizeCategory)를 확인하고, 접근성 텍스트 크기 범주 (예: AX1, AX2 또는 AX5) 가 사용된 경우에는 VStack으로 전환합니다.\n\n다음은 간단한 접근 방식입니다:\n\n```js\n@Environment(\\.sizeCategory) private var sizeCategory\n\nvar body: some View {\n    if sizeCategory.isAccessibilityCategory {\n        VStack(alignment: .leading, spacing: spacing) {\n            content()\n        }\n        .frame(maxWidth: .infinity, alignment: .leading)\n    } else {\n        HStack(alignment: alignment, spacing: spacing) {\n            content()\n        }\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n@Environment(\\.sizeCategory)은 중요한 경우에 사용할 수 있는 유용한 도구입니다. 사용자가 접근성 텍스트 크기 범주를 사용하는지 여부를 알아야 하는 경우 (isAccessibilityCategory와 함께). 때로는 이 속성을 사용하여 대량 콘텐츠 크기에 맞지 않는 이미지와 같은 불필요한 UI 요소를 제거하는 데 활용합니다.\n\n더 현대적인 구현은 비슷하게 동작하지만 ViewThatFits를 활용하여 콘텐츠가 맞지 않는 경우에만 재분배됩니다:\n\n```js\nvar body: some View {\n    ViewThatFits {\n        HStack(alignment: alignment, spacing: spacing) {\n            content()\n        }\n        VStack(alignment: .leading, spacing: spacing) {\n            content()\n        }.frame(maxWidth: .infinity, alignment: .leading)\n    }\n}\n```\n\n생각을 많이 해면 A11yHStack을 몇 군데에 적용할 수 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nimport A11yUtils\n\nA11yHStack {\n    Image(cat.image)\n    VStack {\n        A11yHStack {\n            Text(cat.name)\n            Text(\"\\(cat.age) years old\")\n        }\n        HStack {\n            Image(systemName: cat.icon)\n            Text(cat.quote)\n        }\n    }\n}\n```\n\n이제 컨텐츠가 매우 큰 텍스트 크기에서 더 적절해 보입니다.\n\n<img src=\"/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_10.png\" />\n\n## 스크린 리더 개선사항\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n보이스오버는 퍼즐 조각 중 비교적 간단한 부분입니다.\n\n앱이 스크린 리더와 잘 작동하도록 만드는 것은:\n\n- 시각적 콘텐츠가 충분히 설명되었는지 확인하기.\n- 탐색이 직관적으로 작동되도록 만들기.\n- 뷰가 의미론적으로 올바른지 확인하기.\n\n먼저 시각적 설명부터 시작해보죠. 이것은 우리 레퍼토리에서 가장 간단한 수정 사항입니다: 그래픽 콘텐츠가 VoiceOver에 의해 설명될 수 있도록 보장하는 것입니다. accessibilityLabel 수정자가 우리의 책과 버터라고 할 수 있죠.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nImage(\"catKingdom\").accessibilityLabel(\n  Text(\"나의 세 마리 고양이: 코디, 로지, 루나\")\n);\n```\n\n스크린리더가 현재 초점을 맞춘 대상을 설명하는 방법을 알려줍니다.\n\n![Cat Kingdom](/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_11.png)\n\n이제 주 뷰의 셀에 동일한 방식을 적용할 수 있습니다. Cat 데이터 모델을 약간 수정하여 각 고양이 사진과 함께 이미지 설명을 제공합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nstruct Cat {\n    // ...\n    let imageDescription: String\n}\n\nImage(cat.image)\n    .accessibilityLabel(Text(cat.imageDescription))\n```\n\n이건 들릴만큼 쉽고, Apple 플랫폼에서만 작동하는 경향이 있어요.\n\n![image](/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_12.png)\n\n우리 앱을 통해 탐색할 때, 좀 더 신중하게 할 수 있는 기회가 있어요. 기본 설정으로 VoiceOver는 SwiftUI 뷰 트리의 모든 잎 노드를 반복하며 모든 이미지, 버튼 및 텍스트를 읽어줄 거예요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n가끔 사용자에게 불필요한 탐색을 초래합니다. 저희 앱에서는 각 고양이의 아이콘과 인용구를 건너뛰려면 여러 번 탭해야 합니다. 아이콘의 이름(예: cat.fill)을 읽는 것은 경험에 별다른 도움이 되지 않습니다.\n\n이들을 단일 a11y 요소로 결합하여 screenreader가 탐색 중에 하나의 항목으로 처리할 수 있도록 할 수 있습니다.\n\n```swift\nHStack {\n    Image(systemName: cat.icon)\n    Text(cat.quote)\n}\n.accessibilityElement(children: .combine)\n```\n\n이제 screenreader가 요소를 하나로 이동하는 것을 들을 수 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![image](/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_13.png)\n\n어떤 상황에서는 그래픽적으로 시간이 표시되는 셀렉트한 타이머 요소와 같이 복잡한 UI가 있을 수 있습니다. VoiceOver는 똑똑하지만, 설명되지 않은 뷰들의 번잡한 모음에서 유용한 정보를 유추하지는 못합니다.\n\n여기서 accessibilityRepresentation 수정자가 정말 유용하게 사용됩니다. 이를 통해 뷰의 VoiceOver UI를 완전히 사용자 정의된 접근성 표현으로 대체할 수 있습니다.\n\n최근에 개발한 개인 프로젝트 'Check 'em'에서는 사용자의 2단계 인증 코드가 카운트다운과 함께 표시되어 해당 기능이 특히 유용했습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```swift\n// AccountView.swift\n\nstruct AccountView: View {\n\n    var body: some View {\n        Section(account.name) {\n            // Image, 2FA Code Text, and Countdown UI ...\n        }\n        .accessibilityRepresentation {\n            VStack {\n                Text(account.name)\n                if let code = account.code {\n                    ForEach(Array(code.enumerated()), id: \\.0) {\n                        Text(String($0.1))\n                    }\n                }\n                if let countdown = account.countdown {\n                    Text(\"Expires in \\(countdown)\")\n                }\n            }.accessibilityElement(children: .combine)\n        }\n    }\n```\n\n이 modifier를 사용하여 각 셀 요소를 순서대로 반복하는 것보다 훨씬 유용한 완전히 사용자 정의 된 VoiceOver 인터페이스를 소개할 수 있었습니다. 또한 화면 낭독기가 \"676,252\"를 \"육십 칠만 육천 이백 오십 이\"로 읽는 것을 방지했습니다.\n\n![Screenshot](/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_14.png)\n\n## Native components\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 어플리케이션의 주요 뷰는 저희 콘텐츠를 배치하는 일반적이지만 조잡한 방법을 사용합니다: ForEach 내에 있는 셀을 래핑하는 방식으로 LazyVStack을 래핑하고 ScrollView로 래핑합니다.\n\n```js\nScrollView {\n    LazyVStack(spacing: 24) {\n        ForEach(cats, id: \\.name) {\n            CatView(cat: $0)\n        }\n    }\n}\n```\n\n최적의 방법은 가능한 한 SwiftUI의 기본 구성 요소를 활용하는 것입니다. 이 경우에는 List가 가장 적합합니다.\n\nApple은 사용자 정의 UI 대신 iOS-Settings 스타일의 List를 사용하려면 모디파이어를 3개 추가해야 한다는 점을 설명할 때, 이 작업을 좀 더 어렵게 만들어 놓았습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n목록(고양이) {\n    고양이뷰(고양이: $0)\n        .목록행배경(Color.clear)\n        .목록행구분선(.숨김)\n}\n.목록스타일(일반목록스타일())\n```\n\n이제 보일러플레이트를 작성했으니 수정자들을 자유롭게 사용하여 SwiftUI 목록에서 자체 UI를 사용할 수 있습니다.\n\n<img src=\"/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_15.png\" />\n\n한 가지 질문이 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n왜 네이티브 컴포넌트를 사용하는 것에 이렇게 많은 노력을 기울일까요?\n\n먼저, 비 접근성(a11y) 관련 이유: SwiftUI List는 UICollectionView를 사용하여 구현됩니다. 이는 고성능 스크롤링을 위해 셀 재사용을 활용하며 항목이 많아도 성능을 유지합니다. 그에 반해 LazyVStack은 이전에 렌더링된 모든 셀을 메모리에 유지하므로 많은 항목을 스크롤하는 경우 성능이 뚝뚝 떨어집니다.\n\n네이티브 컴포넌트를 사용하는 a11y 관련 이유는 간단하지만 다양합니다:\n\nList는 의미론적 의미가 있습니다: 화면 판독기에게 비슷한 콘텐츠 컬렉션을 포함하는 컨테이너임을 알려줍니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이것이 많은 목록 항목이 있는 경우, 순진한 구현이 망가진 이유입니다: VoiceOver로 목록 컨테이너를 건너뛸 수 있게 해주지 않고 모든 항목을 스와이프해야만 로그아웃 버튼에 도달할 수 있었습니다.\n\nList를 사용하면 SwiftUI가 화면 판독기에게 그 내용이 단일 컨테이너임을 알려줄 수 있어, 화면 판독기가 쉽게 이동할 수 있습니다.\n\n아래는 Markdown 형식으로 변경된 이미지 링크입니다:\n\n![이미지](/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_16.png)\n\n또한 List에는 스와이프 삭제, 드래그 앤 드롭, 키보드 기반 탐색 등 많은 내장 상호작용 모드가 있습니다. 네이티브 컴포넌트를 사용할 때 이들은 자동으로 작동합니다. 사용자 지정 구현과 함께 하는 화면 판독기 작업을 어떻게 할 것인지 아시겠습니까?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n리스트는 심지어 가장 복잡한 컴포넌트도 아닙니다. 사용자 정의 그리드나 레이아웃 프로토콜을 사용하지 않는 뷰의 사용자 정의 분배에 a11y를 어떻게 구현할 것인가요?\n\n# 이해관계자 설득\n\n이제 SwiftUI 앱에서 a11y를 빠르게 실행하는 방법을 이해했으니, 작업에 착수하기 전에 남은 퍼즐 조각은 비즈니스의 나머지 구성원으로부터 승인을 얻는 것입니다. 여기서 당신이 조직적 영향력을 행사하는 소프트 스킬을 펼칠 수 있습니다.\n\n당신이 휘둘 수 있는 큰, 둔한 도구 중 하나는 입법의 망치입니다. 영국, 미국, 그리고 EU와 같은 세계 각국은 디지털 서비스가 접근성의 최소 기준을 충족해야 한다는 법률을 시행했습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n또한, 웹 접근성(웹 콘텐츠 접근성)은 실제로 비즈니스에서 큰 이점을 제공합니다. 현재 세계 인구의 16%가 중요한 장애를 겪고 있습니다. 즉, 다양한 요구에 맞게 서비스를 제공함으로써 사용자, 긍정적인 리뷰 및 수익을 놓칠 수 있습니다. 대상 시장에 따라 이는 더 또는 덜 중요할 수 있습니다.\n\n작은 규모에서는, 접근성을 제품 부채로 다루는 것보다 앱이 어떻게 오작동하는지 간단히 보여주는 것이 훨씬 효과적이라는 것을 발견했습니다. 접근성 요구사항을 추상적인 개념에서 벗어나서 버그 있는 가입 플로우를 보여주는 것이 어떤 엔지니어링 조직에게도 더 설득력있을 것입니다.\n\n제품에 쉽게 접근할 수 있도록 옹호하는 영향력 있는 리더십 속에 있는 옹호자를 가지는 것이 가장 도움이 됩니다. 물론, 모든 조직이 다르기 때문에 이 조언을 적용할 때 결과가 다를 수 있습니다.\n\n가장 중요한 것은, 이제 웹 접근성을 빠르게 적용하고 제품이 완전히 접근 가능한 상태라면?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n공을 놓치지 마세요!\n\n기술 부채와 마찬가지로, 이제 좋은 위치에 있으니 a11y를 표준 개발 워크플로에 통합할 수 있습니다. 이미 알고 계시니 빠르고 쉽게 할 수 있어요!\n\n# 결론\n\n오늘 많은 내용을 다뤘습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n먼저 앱을 감사하여 대화형 텍스트 스케일링 또는 VoiceOver를 사용할 때 발생하는 일반적인 접근성 오류를 확인하는 프로세스를 거쳤습니다.\n\n텍스트 스케일링을 사용할 때 발생하는 문제를 수정하고, a11yScrollView로 스크롤링을 적용하고, @ScaledMetric으로 콘텐츠 스케일링하고, A11yHStack으로 정렬하는 방법을 살펴보았습니다.\n\n화면 판독기에서 앱이 잘 작동하도록 만들기 위해 accessibilityLabels를 구현했고, accessibilityElements를 결합하고, 심지어 완전히 사용자 정의된 accessibilityRepresentations도 구현했습니다.\n\n네이티브 SwiftUI 구성 요소 대신 사용자 지정보기를 사용하는 이유에 대해 논의했습니다. 이유로는 의미론, 상호 작용 모드 및 성능이 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n마침내, 당신이 조직 내에서 접근성에 진지하게 대응하기 위해 소프트 스킬을 적용하는 방법을 살펴보았습니다.\n\n당신이 SwiftUI 앱에서 접근성에 진지하다면, 동반 앱을 통해 이러한 기술들을 직접 구현해보는 것을 적극 권장합니다. 도구를 체득하는 가장 좋은 방법이죠. 지금까지 작업해온 사이드 프로젝트가 있다면, 그것 역시 좋은 시작점일 것입니다.\n\n내 A11yUtils 라이브러리에 기여 (문제 포함)를 기쁘게 받아들이겠습니다. 지금도 SwiftUI에 이미 있는 API를 보완하기 위한 포괄적인 접근성 도구 모음으로 이것을 발전시키기 위해 커뮤니티와 협력하고 싶어합니다.\n","ogImage":{"url":"/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_0.png"},"coverImage":"/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_0.png","tag":["Tech"],"readingTime":27},{"title":"Jetpack Compose에서 안정성을 마스터하여 앱 성능 최적화하기","description":"","date":"2024-05-17 18:39","slug":"2024-05-17-OptimizeAppPerformanceByMasteringStabilityinJetpackCompose","content":"\n![Jetpack Compose](/assets/img/2024-05-17-OptimizeAppPerformanceByMasteringStabilityinJetpackCompose_0.png)\n\n젯팩 컴포즈는 구글의 첨단 UI 툴킷으로서, 안정적인 1.0 버전 이후 뛰어난 가능성을 보여주었습니다. Google의 보고에 따르면, 제트팩 컴포즈를 사용하여 개발된 앱이 이미 12만 5천 개 이상이 Google Play Store에서 성공적으로 출시되면서 프로덕션 목적으로의 채택이 급증했습니다.\n\n제트팩 컴포즈는 내장된 최적화 기능을 갖추고 있지만, 개발자들은 컴포즈가 UI 요소를 어떻게 렌더링하는지 이해하고, 다양한 시나리오에서 제트팩 컴포즈의 성능을 최적화하기 위한 전략을 파악해야 합니다. 이러한 지식은 애플리케이션의 성능에 잠재적인 영향을 최소화하고 더 나은 사용자 경험을 제공하기 위한 중요한 역할을 합니다.\n\n이 기사에서는 제트팩 컴포즈의 내부 작업을 이해하고, 안정성을 관리하여 애플리케이션의 성능을 향상시키는 방법을 안내하겠습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# Jetpack Compose 단계\n\n안정성에 대해 자세히 살펴보기 전에 Jetpack Compose의 단계를 이해하는 것이 중요합니다. 이 단계에서는 화면에 Compose UI 노드를 렌더링하는 과정이 여러 연속적인 단계를 통해 진행됩니다.\n\n![Jetpack Compose Phases](/assets/img/2024-05-17-OptimizeAppPerformanceByMasteringStabilityinJetpackCompose_1.png)\n\nJetpack Compose는 한 프레임의 렌더링을 세 가지 구분된 단계를 통해 실행합니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 구성: 이 단계에서는 Composable 함수에 대한 설명을 생성하고 여러 메모리 슬롯을 할당함으로써 프로세스가 시작됩니다. 이러한 슬롯은 각 Composable 함수를 메모이즈하여 런타임 중에 효율적인 호출 및 실행을 가능하게 합니다.\n- 레이아웃: 이 단계에서는 Composable 트리 내 각 노드의 위치를 설정합니다. 레이아웃 단계는 주로 각 Composable 노드를 측정하고 적절히 배치하여 UI의 전체 구조 내에서 모든 요소가 정확히 배열되도록 보장합니다.\n- 그리기: 이 마지막 단계에서는 Composable 노드가 일반적으로 장치의 화면인 캔버스에 렌더링됩니다. 이 중요한 단계는 UI를 시각적으로 구축하여 설계된 Composables을 사용자 상호 작용을 위해 사용할 수 있게 합니다.\n\n내부 메커니즘은 훨씬 더 복잡하지만, 기본적으로 Composable 함수를 작성할 때 화면에 표시되기 위해 이러한 단계를 거칩니다.\n\n이제 레이아웃의 크기 및 색상과 같은 UI 요소를 수정하려고 한다고 가정해 봅시다. 그림 그리기 단계가 완료된 경우, Compose는 이러한 새 값들을 적용하기 위해 처음부터 다시 이러한 단계를 다시 방문해야 합니다. 이러한 업데이트 사이클을 재구성이라고 합니다:\n\n![이미지](/assets/img/2024-05-17-OptimizeAppPerformanceByMasteringStabilityinJetpackCompose_2.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n재구성은 입력 변경에 대한 응담으로 조합 가능한 함수가 새롭게 실행되어 Composition 단계에서 시작됩니다. 이 프로세스는 State에서 관찰하거나 내재적으로 Compose 런타임과 컴파일러 메커니즘들이 연관된 다양한 요소에 의해 트리거될 수 있습니다.\n\n전체 UI 트리와 요소를 재구성하는 것은 상당한 계산 리소스를 필요로 하며 앱의 성능에 직접적인 영향을 미칠 수 있습니다. 필요한 경우에만 재구성을 트리거함으로써(불필요할 때 재구성을 건너뛸 경우) 계산 리소스를 최소화하여 UI 성능을 향상시킬 수 있습니다.\n\n따라서, Compose 런타임의 작동 방식을 포함한 재구성 프로세스에 대한 심층적인 이해, 재구성을 건너뛸 기회를 식별하고 재구성을 트리거하는 요소를 인식하는 것이 중요합니다.\n\n이제 안정성 개념을 탐구하고 재구성 비용을 최적화하여 응용 프로그램 성능을 향상시킬 방법을 살펴보겠습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 안정성 이해\n\n이전 섹션에서 언급된 바와 같이, 이미 렌더링된 UI를 업데이트하기 위해 다양한 방법이 존재합니다. Composable 함수의 매개변수의 안정성은 Compose 런타임과 컴파일러의 작동과 깊이 얽혀 있어, 재구성을 시작하는 결정적인 요소로 부각됩니다.\n\nCompose 컴파일러는 Composable 함수의 매개변수를 안정적인 것과 불안정한 것 두 가지로 분류합니다. 이러한 매개변수 안정성의 분류는 Compose 런타임에 의해 Composable 함수가 재구성되어야 하는지 여부를 결정하는 데 사용됩니다.\n\n# 안정함 vs. 불안정함\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제, 어떻게 매개변수가 안정적인지 불안정한지로 분류되는지 궁금할 수 있습니다. 이 결정은 Compose 컴파일러에 의해 이루어집니다. 컴파일러는 Composable 함수에서 사용된 매개변수의 유형을 검토하고 다음 기준에 따라 안정적인지를 분류합니다:\n\n- String을 포함한 기본 유형은 본질적으로 안정적입니다.\n- (Int) -` String과 같은 람다 표현식으로 나타낸 함수 유형은 안정적으로 간주됩니다.\n- 불변하고 안정적인 공개 속성으로 특징지어진 데이터 클래스 또는 안정성 주석인 @Stable이나 @Immutable과 같이 명시적으로 표시된 클래스는 안정적으로 간주됩니다. 이러한 주석의 구체적인 내용에 대해 다음 섹션에서 자세히 살펴볼 것입니다.\n\n예를 들어, 아래와 같이 데이터 클래스를 상상해 볼 수 있습니다:\n\nComposable 컴파일러에 의해 안정적으로 간주되는 불변 기본 속성으로 구성된 User 데이터 클래스입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그러나, Composable 함수 내에서 매개변수 유형을 평가하는 컴파일러는 아래 기준에 따라 해당 유형을 불안정하다고 식별합니다:\n\n- List, Map 등의 인터페이스와 Any와 같은 추상 클래스와 같이 컴파일 시간에 구현이 예측할 수 없는 유형은 불안정하다고 간주됩니다. 이 분류의 근거는 다음 섹션에서 더 자세히 논의될 예정입니다.\n- 특히 적어도 하나의 가변 또는 본질적으로 불안정한 공용 속성을 포함하는 데이터 클래스와 같은 클래스는 불안정하다고 분류됩니다.\n\n예를 들어, 다음과 같은 데이터 클래스를 상상해볼 수 있습니다:\n\nUser 데이터 클래스는 기본 속성으로 구성되어 있지만, 가변 이름 속성의 존재로 인해 Compose 컴파일러가 이를 불안정하다고 분류합니다. 이 분류는 안정성이 모든 속성의 종합적인 안정성을 평가하여 단일 가변 속성이 전체 클래스를 불안정하게 만들 수 있기 때문에 발생합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 스마트 재구성\n\n안정성의 원칙을 탐색하고 Compose 컴파일러가 안정적인지 불안정한지를 구별하는 방법을 살펴봤다면, 이러한 차이점을 활용하여 재구성을 트리거하는 실용적인 사용법에 관심이 생길 수 있습니다. Compose 컴파일러는 변경 가능 함수의 각 매개변수의 안정성을 평가하여 Compose 런타임이 이 정보를 효율적으로 활용할 수 있도록 기초를 마련합니다.\n\n클래스의 안정성이 결정되면, Compose 런타임은 이 통찰력을 활용하여 내부 메커니즘인 스마트 재구성을 통해 재구성을 시작합니다. 스마트 재구성은 제공된 안정성 정보를 활용하여 불필요한 재구성을 선택적으로 건너뛰어 Compose의 전체 성능을 향상시킵니다.\n\n스마트 재구성이 작동하는 원칙 중 일부는 다음과 같습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 등가성 확인: Composable 함수에 새 입력이 전달될 때마다 해당 입력은 반드시 클래스의 equals() 메서드를 사용하여 이전 입력과 비교됩니다.\n- 안정성에 따른 결정:\n\n- 매개변수가 안정적이고 값이 변경되지 않은 경우 (equals()가 true를 반환), Compose는 관련 UI 구성 요소를 다시 구성하지 않습니다.\n- 매개변수가 불안정하거나 안정적이지만 값이 변경된 경우 (equals()가 false를 반환), 런타임은 다시 구성을 시작하여 UI 레이아웃을 무효화하고 다시 그립니다.\n\n위 시나리오에서 불필요한 다시 구성을 피함으로써 UI 성능을 향상시킬 수 있습니다. 전체 UI 트리를 다시 구성하는 것은 상당한 계산 리소스를 필요로하며, 적절하게 처리되지 않으면 성능에 부정적인 영향을 줄 수 있습니다.\n\nJetpack Compose는 스마트한 다시 구성을 기본적으로 제공하지만, Composable 함수에서 사용되는 클래스를 안정화하고 최대한 다시 구성을 줄이는 방법을 숙지하는 것이 중요합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 합성 가능한 함수 추론하기\n\n이제 컴포즈 컴파일러가 클래스 안정성을 결정하고 컴포즈 런타임이 이 정보를 내부 메커니즘인 스마트 재구성으로 활용하는 방법을 이해했습니다. 그렇지만 이해해야 할 또 다른 중요한 개념은 합성 가능한 함수의 유형 추론입니다.\n\n컴포즈 컴파일러는 코틀린 컴파일러 플러그인을 사용하여 개발자가 작성한 소스 코드를 컴파일 시 분석할 수 있게 만들어졌습니다. 더불어, 컴포즈 함수의 고유한 특성과 더 잘 일치하도록 원본 소스 코드를 조정할 수 있습니다.\n\n컴파일러는 합성 가능한 함수를 시작 가능함, 이동 가능함, 대체 가능함 등으로 분류하여 실행을 최적화합니다. 이 게시물에서는 특히 재구성에 중요한 역할을 하는 시작 가능한 유형에 대해 자세히 살펴볼 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 다시 시작 가능한\n\n다시 시작 가능한은 Composable 함수의 일종으로, Compose 컴파일러에 의해 결정되며 recomposition 프로세스의 중추 역할을 합니다. 이전에 탐구한 대로, Compose 런타임은 입력 값의 변화를 감지하면 이러한 새 입력 값으로 함수를 다시 시작(또는 다시 호출)하여 데이터 변경을 정확하게 반영합니다.\n\nCompose 런타임에서 제공하는 특정 주석으로 Composable 함수를 명시적으로 주석 처리하지 않으면 대부분의 함수는 기본적으로 다시 시작 가능하다고 간주됩니다. 이는 Compose 런타임이 언제든지 입력 또는 상태 변경이 발생할 때 해당 Composable 함수에 대해 recomposition을 트리거할 수 있다는 것을 의미합니다.\n\n# 건너뛰기 가능한\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nSkipable은 또 다른 Composable 함수의 특성을 나타내며, 이는 이전 섹션에서 논의된 스마트 recomposition에 의해 설정된 적절한 조건 하에서 전체 recomposition 프로세스를 완전히 우회할 수 있음을 의미합니다. 따라서, skipable 함수가 바로 recomposition을 건너뛰고 UI 성능을 향상시킬 수 있는 잠재력과 직접적으로 연결된다고 단언할 수 있습니다. 이는 특정 상황에 따라서 달려있는데요.\n\n이 능력은 특히 규모가 큰 함수 호출 계층 구조의 정상 Composable 함수의 성능을 향상시키는 데 중요합니다. 이러한 루트 Composable의 recomposition을 건너뛰면, Compose는 이러한 루트 Composable의 recomposition을 건너뛰면, 해당 계층의 하위 함수들 중 어떤 것도 호출할 필요가 없어지며, 전체 recomposition 프로세스가 간소화됩니다.\n\nComposable 함수가 재시작 가능(restartable)이면서 동시에 skippable로 분류되는 경우도 있음을 기억하는 것이 중요합니다. skippable로 분류되면 재시작 가능한 recomposition을 거칠 수 있다는 것을 함축하므로요. 이제 작성한 Composable 함수가 재시작 가능 또는 skippable로 분류되는지 알아보는 방법을 살펴보겠습니다.\n\n# Compose Compiler Metrics\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nCompose 컴파일러 플러그인을 사용하면 Compose에 고유한 특정 개념에 중점을 둔 자세한 보고서와 메트릭을 생성할 수 있습니다. 이러한 통찰력은 Compose 코드의 복잡성을 파헤치는 데 유용하며, 마이크로 레벨에서 작동 방식을 정확하게 이해할 수 있도록 도와줍니다.\n\nCompose 컴파일러 메트릭을 생성하려면, 아래 예제에 설명된 대로 루트 모듈의 build.gradle 파일에 컴파일러 옵션을 추가하면 됩니다:\n\n프로젝트를 동기화하고 빌드한 후, /build/compose_metrics 디렉토리에 생성된 세 가지 다른 파일인 module.json, composablex.txt 및 classes.txt에 액세스할 수 있습니다. 이 파일들을 각각 자세히 살펴보겠습니다.\n\n## 최상위 메트릭 (modules.json)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 보고서는 Compose에 특화된 고수준 메트릭을 제공하며, 주로 추적할 수 있는 숫자 데이터 지점을 생성하는 데 목적이 있습니다. 이러한 메트릭 간의 관계는 통찰력 있는 관찰을 제공할 수 있습니다. 예를 들어, \"skippableComposables\"의 수를 \"restartableComposables\"의 수와 비교하면, Composable 함수의 재구성이 건너뛰어질 비율을 나타내는 백분율이 도출됩니다.\n\n아래는 foundation 모듈을 위한 샘플 보고서입니다:\n\n```js\n{\n \"skippableComposables\": 36,\n \"restartableComposables\": 41,\n \"readonlyComposables\": 6,\n \"totalComposables\": 60,\n \"restartGroups\": 41,\n \"totalGroups\": 82,\n \"staticArguments\": 25,\n  \"certainArguments\": 138,\n  \"knownStableArguments\": 377,\n  \"knownUnstableArguments\": 25,\n  \"unknownStableArguments\": 24,\n  ..\n```\n\n## Composable Signatures (composables.txt)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 보고서는 사람이 이해하기 쉽도록 작성된 의사 Kotlin 스타일 함수 서명을 사용합니다. 이 모듈 내의 각 구성 가능한 함수를 자세히 살펴보며 각 매개변수를 분석하고 특정 통찰을 제공합니다.\n\n이 보고서는 전체 구성 가능한 함수가 다시 시작 가능한지, 건너뛸 수 있는지 또는 읽기 전용인지를 식별합니다. 또한 각 매개변수를 안정적인지 불안정한지로 레이블링하고 각 기본 매개변수 표현을 정적인지 동적인지로 표시하여 구성 가능한 특성에 대한 포괄적인 개요를 제공합니다.\n\n기본적으로 이러한 서명들은 Composable 함수가 건너뛰기 가능한지 여부를 분석하거나 함수가 건너뛰기가 불가능하도록 제약하는 불안정한 매개변수를 식별하는 데 사용할 수 있습니다.\n\n다음은 Composable 함수에 대한 샘플 보고서입니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\nrestartable skippable scheme(\"[androidx.compose.ui.UiComposable]\") fun Avatar(\n  stable modifier: Modifier? = @static Companion\n  stable imageUrl: String? = @static null\n  stable initials: String? = @static null\n  stable shape: Shape? = @dynamic VideoTheme.<get-shapes>($composer, 0b0110).circle\n  stable textSize: StyleSize? = @static StyleSize.XL\n  stable textStyle: TextStyle? = @dynamic VideoTheme.<get-typography>($composer, 0b0110).titleM\n  stable contentScale: ContentScale? = @static Companion.Crop\n  stable contentDescription: String? = @static null\n)\n\n## Classes (classes.txt)\n\nThis report also utilizes pseudo-Kotlin style function signatures crafted for human readability. This file is designed to help you grasp how the stability inferencing algorithm has interpreted a specific class. At the top level, each class is categorized as stable, unstable, or runtime. “Runtime” indicates that the stability is contingent on other dependencies, which will be determined at runtime (such as a type parameter or a type in an external module).\n\nThe stability assessment is based on the class’s fields, with each field listed under the class and labeled as stable, unstable, or runtime stable. The bottom line reveals the “expression” employed to determine this stability at runtime, providing a comprehensive overview of how each class`s stability is evaluated.\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\nstable class StreamShapes {\n  stable val circle: Shape\n  stable val square: Shape\n  stable val button: Shape\n  stable val input: Shape\n  stable val dialog: Shape\n  stable val sheet: Shape\n  stable val indicator: Shape\n  stable val container: Shape\n}\n```\n\n일련의 Compose 컴파일러 메트릭을 생성하는 프로세스를 탐험하고, 각 파일의 중요성을 이해하며, 이 정보를 사용하여 더 많이 건너뛸 수 있는 Composable 함수를 작성하려고 노력하는 방법을 배웠어요. 이 주제를 깊이 있게 탐구하고 싶다면 상세한 통찰을 얻기 위해 Interpreting Compose Compiler Metrics를 확인해보세요.\n\n# 안정성 주석\n\n이제 Compose 컴파일러가 안정성을 처리하는 방식과 이러한 안정성 결정이 다시 구성에 어떻게 영향을 미치는지, 그리고 당신의 애플리케이션 성능에 어떻게 영향을 미칠 수 있는지 통찰력을 얻었어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nComposed of immutability and stability annotations, let's take a journey into transforming changeable classes into reliable ones using annotations from the compose-runtime library. The main actors in this process are @Immutable and @Stable.\n\n# Immutability\n\nWhen you decorate your class with the @Immutable annotation, you reassure the Compose compiler that all public properties and fields within the class will remain unchanged (immutable) once they are created. This provides a more solid guarantee compared to the val keyword at the language level. While val prevents properties from being modified via a setter, it still allows creation through mutable data structures like Lists initialized with MutableList.\n\nTo make sure your classes are distinctly marked as stable with the @Immutable annotation, adhere to the guidelines below:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 모든 공용 속성에 val 키워드를 사용하여 불변성을 보장하세요.\n- 사용자 지정 setter를 피하고 공용 속성이 변경 가능성을 지원하지 않도록 합니다.\n- 모든 공용 속성의 유형이 본질적으로 불변 또는 안정적이거나 안정성 주석으로 명시적으로 표시되었는지 확인하세요. 예를 들어 인터페이스는 불안정하다고 간주되므로 속성으로 사용되는 모든 인터페이스 유형도 안정성을 위해 주석을 달아야 합니다.\n- 컬렉션인 속성들의 경우, 안정성을 유지하기 위해 kotlinx.collections.immutable에서 제공하는 불변 컬렉션을 선택하세요.\n\n@Immutable 주석은 위의 불변성 규칙을 준수하는 클래스에 효과적이며, 불필요한 recomposition을 건너뛰어 응용프로그램 성능을 향상시킬 때 중요한 역할을 합니다.\n\n그러나 @Immutable 주석을 분별하게 사용하는 것이 중요합니다. 적절하게 사용하지 않으면 의도하지 않은 recomposition 건너뛰기로 인해 Compose 레이아웃이 예상대로 업데이트되지 않을 수 있습니다.\n\n# 안정함\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n`@Stable` 어노테이션은 `@Immutable` 어노테이션보다 Compose 컴파일러에 더 강력하지만 약간 덜 엄격한 커밋먼트를 나타냅니다. 함수나 프로퍼티에 적용되면, `@Stable` 어노테이션은 해당 유형이 가변할 수 있다는 것을 나타냅니다. 처음에는 약간 모순적으로 보일 수도 있습니다. 이 문맥에서 \"Stable\"이라는 용어는 함수가 동일한 입력에 대해 항상 동일한 결과를 반환할 것이라는 의미로, 잠재적인 가변성에도 불구하고 예측 가능한 동작을 보장합니다.\n\n따라서 `@Stable` 어노테이션은 주로 public 프로퍼티가 불변인 클래스에 적합하지만 클래스 자체가 안정적이지 않을 수 있는 경우에 사용됩니다. 예를 들어, Jetpack Compose의 State 인터페이스는 value라는 불변 프로퍼티만 노출합니다. 그러나 이 불변 프로퍼티의 내부 값은 여전히 setValue 함수를 통해 수정될 수 있으며, 일반적으로 MutableState를 생성하여 이를 수행합니다.\n\nState와 MutableState를 통한 데모로 보여 준 것처럼, MutableState에 의해 생성된 State 인스턴스는 getValue 함수(값 프로퍼티의 게터)로부터 일관되게 동일한 값을 얻을 것이며, setValue 함수에 대한 동일한 입력에 대해 동일한 결과를 반환합니다. 제공된 코드 스니펫에서는 `@Stable` 어노테이션이 지정된 State와 MutableState 인터페이스를 모두 보여줍니다.\n\n# Immutable vs Stable\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n**@Immutable**과 **@Stable** 주석 사이의 구별과 어떤 것을 사용해야 하는지 결정하는 것은 처음에는 혼란스러울 수 있습니다. 하지만 실제로는 꽤 간단합니다. 이전에 언급했듯이, **@Immutable** 주석은 클래스의 모든 공용 속성이 불변이라는 의미로, 생성된 후에 상태가 변경될 수 없음을 나타냅니다. 반면에 **@Stable** 주석은 가변 객체에 적용될 수 있으며, 동일한 입력에 대해 일관된 결과를 생성해야 하는 것을 요구합니다.\n\n**@Immutable** 주석은 대부분 도메인 모델에 적용되는데, 특히 Kotlin 데이터 클래스를 사용할 때 다음 예시에서와 같이 나타납니다:\n\n반면에 **@Stable** 주석은 여러 구현 가능성을 제공하는 인터페이스에 대해 일반적으로 사용되며, 내부 가변 상태를 가질 수 있습니다. 아래 의미 있는 예시는 이 주석을 이해하는 데 도움이 됩니다:\n\n**@Stable** 주석을 적용하면 **UiState** 클래스를 안정적으로 지정할 수 있습니다. 이는 최적화된 건너뛰기와 지능적인 재구성을 가능하게 하여 업데이트의 효율성을 향상시킵니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# NonRestartableComposable\n\nJetpack Compose의 @NonRestartableComposable 주석은 특정 구성 가능한 함수의 recomposition 동작을 최적화하기 위해 고안된 비교적 고급 기능입니다. 이 주석은 구성 가능한 함수가 호출 매개변수의 변경으로 인해 recomposition 중 자동으로 다시 시작되지 않아야 함을 Compose 컴파일러에 알리는 역할을 합니다. 일반적으로 구성 가능한 함수의 입력 값이 변경되면 Compose 런타임은 함수를 다시 시작하여 새로운 입력 값을 소비하게 할 수 있습니다.\n\n그러나 이러한 다시 시작이 항상 필요하거나 원하는 것은 아닐 수 있습니다, 특히 함수의 내부 상태나 부작용을 다시 시작해야 할 때가 아닌 경우에 해당합니다. @NonRestartableComposable을 적용하면 런타임이 함수를 다시 시작하지 않고 매개변수를 업데이트하도록 지시하여 내부 상태와 진행 중인 부작용을 유지할 수 있습니다.\n\n@NonRestartableComposable의 일부로 동작하는 대표적인 예는 Compose 런타임 라이브러리의 Side-effect API 내에서 발견됩니다. 예를 들어 LaunchedEffect의 구현은 이 주석을 사용하여 효과가 불필요하게 다시 시작되지 않도록 보장합니다. 아래 코드에서 보여진 것처럼요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그러나 @NonRestartableComposable 주석을 사용할 때 주의해야 하며 앱 성능을 향상시키기 위한 수단으로만 사용해서는 안 됩니다. 선별적으로 사용하지 않으면 원하지 않는 결과로 이어질 수 있습니다.\n\n# Composable 함수 안정화\n\n앱 성능을 최적화하는 목적으로 안정한 클래스를 작성하는 방법에 대해 알아보았습니다. 그러나 Composable 함수의 완전한 안정성 달성은 여기서 멈추지 않습니다. 왜냐하면 일부 클래스(예: Kotlin의 컬렉션 또는 제3자 라이브러리에서 제공하는 클래스)는 직접 제어할 수 없을 수 있기 때문입니다.\n\n이전에 언급했던 바와 같이 스마트 recomposition 중 Composable 함수를 건너뛸 수 있는 능력은 해당 함수의 각 매개변수의 안정성에 의해 결정됩니다. 스마트 recomposition을 위해 Composable 함수 내에서 사용되는 모든 매개변수가 안정적임을 보장하는 것이 중요합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 섹션에서는 Composable 함수를 스킵할 수 있는 네 가지 다른 전략을 탐구하여 효율적인 recomposition으로 성능을 향상시킬 수 있습니다.\n\n# Immutable Collections\n\n처음에는 List가 요소를 수정하는 것을 허용하지 않더라도, 인터페이스인 특히 kotlin.collections이 Jetpack Compose에서 불안정하게 여겨지는 이유를 의심할 수 있습니다.\n\n아래의 좋은 예제를 살펴보면 그 이유를 이해할 수 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nuserList 필드는 List로 선언되어 있습니다. List는 기본적으로 요소의 수정을 허용하지 않습니다. 그러나 첫 번째 줄에서 나와 있듯이, 이 List는 MutableList로부터 생성될 수 있습니다. 이는 List 인터페이스 자체가 수정을 제한하지만 해당 내부 구현이 변경 가능할 수 있다는 것을 의미합니다. Compose 컴파일러는 구현 유형을 추론할 수 없어, 이러한 인스턴스들을 안정적이지 않은 것으로 간주하여 정확한 동작을 보장합니다.\n\n그러므로 공식 Android 문서에서는 Composable 함수의 컬렉션 매개변수의 안정성을 보장하기 위해 kotlinx.collections.immutable 라이브러리나 Guava의 Immutable Collections를 활용할 것을 권장합니다.\n\nkotlinx.collections.immutable 라이브러리는 ImmutableList 및 ImmutableSet과 같은 여러 컬렉션을 제공하며, 이는 표준 kotlin.collections의 동작을 모방하지만 변경 불가능합니다. 이러한 컬렉션은 읽기 전용이며, 생성 후에는 수정이 불가능합니다.\n\n이제 Compose 컴파일러가 kotlinx.collections 대비 kotlinx.collections.immutable의 안정성을 결정할 때 고려하는 주요 요소에 대해 궁금해 할 수 있습니다. 구분은 Compose 컴파일러가 변경 불가능 컬렉션을 이해하는 데 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n더 자세한 통찰을 얻으려면 Compose 컴파일러 라이브러리의 일부인 KnownStableConstructs.kt 파일을 참고하십시오. 아래 코드를 보면, Compose 컴파일러가 안정적으로 간주해야 하는 클래스의 패키지 이름 목록을 수동으로 유지한다는 것을 확인할 수 있습니다:\n\n아래 코드 조각을 살펴보면, Composable 함수의 매개변수 안정성을 분석하는 Compose 컴파일러의 일부입니다. 알려진 안정 구조체 클래스에 나열된 매개변수 유형에 대한 안정성을 컴파일러가 유추하지 않는 것이 분명합니다:\n\n## Lambda\n\nCompose 컴파일러에서는 Kotlin 람다 표현식의 처리가 독특한 접근 방식을 취합니다. 이전에 설명한 바와 같이, Compose 컴파일러는 IR(Intermediate Representation) 변환을 통해 개발자가 작성한 소스 코드를 수정합니다. 따라서 컴파일러는 Composable 함수에 전달된 람다의 실행을 최적화하기 위해 Compose 런타임에 일부 규칙을 생성합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nCompose 컴파일러는 람다 표현식을 처리할 때 람다가 값을 캡처하는지 여부에 따라 다른 방식으로 다룹니다. 클로저의 맥락에서 값들을 캡처하는 것은 람다 표현식이 직접적인 범위 외부에 있는 변수에 의존한다는 의미입니다. 외부 변수에 독립적인 람다라면 아래 예시처럼 값들을 캡처하지 않는다고 말할 수 있습니다:\n\n람다 매개변수가 어떤 값도 캡처하지 않는 경우, Kotlin은 이러한 람다를 싱글톤으로 처리하여 불필요한 할당을 최소화합니다. 반면, 람다가 클로저 밖의 변수에 의존하는 경우, 아래 예시에서 볼 수 있듯이 값들을 캡처한다고 간주됩니다:\n\n람다 매개변수가 외부 값들을 캡처하는 경우, 그 실행 결과는 캡처된 값들에 따라 달라질 수 있습니다. 이를 해결하기 위해, Compose 컴파일러는 메모리제이션 전략을 사용하여 람다를 remember 함수 호출 내에 캡슐화합니다. 캡처된 값은 remember에 대한 키 매개변수로 작용하여, 캡처된 값들의 변화에 적절히 반응하여 람다가 적절하게 재호출되도록 합니다.\n\n결과적으로, 람다가 값들을 캡처하는지 여부에 관계없이, 해당 람다는 Composable 함수 내에서 안정적으로 간주됩니다. Composable 함수가 Any 유형의 매개변수를 수용하는 시나리오를 고려해보면, Any가 변경 불가능한 값을 포함하는 등 다양한 값 범위를 포함할 수 있기 때문에, Compose 컴파일러에서는 불안정하게 취급됩니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그러나 아래 예시와 같이 람다 표현식을 사용하여 값을 제공하는 경우, Compose 컴파일러는 람다 매개변수를 안정적으로 처리합니다:\n\n# Wrapper Class\n\nComposable 함수를 안정화하는 또 다른 효과적인 전략은 제어 범위를 벗어난 불안정한 클래스에 대한 래퍼 클래스를 만드는 것입니다. 이러한 경우에는 예시와 같이 안정성 주석을 직접 적용할 수 없는 클래스에 적용할 수 있습니다.\n\n그런 다음 Composable 함수의 매개변수 유형으로 이 래퍼 클래스를 활용할 수 있습니다. 아래 코드에서 보여지는 것처럼요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 파일 구성\n\nCompose 컴파일러 버전 1.5.5부터 구성 파일에서 클래스를 나열할 수 있는 옵션이 추가되었습니다. 이러한 지정된 클래스는 Compose 컴파일러에 의해 안정적으로 인식됩니다. 이 기능은 서드파티 라이브러리에서 가져온 클래스와 같이 제어할 수 없는 클래스들을 사용할 때 매우 유용합니다.\n\n이 기능을 활성화하려면 아래와 같이 앱 모듈의 build.gradle.kts 파일에 Compose 컴파일러 구성을 추가하십시오:\n\n다음으로, 앱 모듈의 루트 디렉토리에 compose_compiler_config.conf 파일을 아래와 같이 생성하십시오:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n// LocalDateTime을 안정적으로 간주합니다.\njava.time.LocalDateTime\n// Kotlin 컬렉션을 안정적으로 간주합니다.\nkotlin.collections.*\n// 내 데이터 계층과 모든 하위 모듈을 안정적으로 간주합니다.\ncom.datalayer.**\n// 제네릭 타입을 첫 번째 타입 매개변수를 기반으로 안정적으로 간주합니다.\ncom.example.GenericClass<*,_>\n```\n\n프로젝트를 빌드하고 Compose 컴파일러 메트릭을 생성하면, 구성 파일에서 지정한 클래스들이 안정적으로 인식되어 스마트 재구성을 건너뛸 수 있습니다.\n\n공식 안드로이드 가이드에 따르면, Compose 컴파일러는 각 프로젝트 모듈 별로 독립적으로 작동하므로 필요에 따라 다른 모듈에 대해 각기 다른 구성을 제공할 수 있습니다. 또는 프로젝트 루트 수준에서 단일 구성을 선택하고 각 모듈에 대해 해당 경로를 지정할 수도 있습니다.\n\n기억해야 할 중요한 점은 구성 파일이 정의된 클래스들을 기본적으로 안정적으로 만들지 않습니다. 대신, 구성 파일을 활용하여 Compose 컴파일러와 계약을 맺는 것입니다. 따라서이 기능을 분별있게 사용하여 특정 시나리오에서 스마트 재구성 프로세스를 우연히 건너뛰는 일을 피해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 멀티 모듈 아키텍처의 안정성\n\n당신의 Gradle 모듈을 모듈화하는 것은 훌륭한 전략으로, 향상된 재사용성, 병렬 빌드, 탈중앙화된 팀 집중력 등의 혜택을 제공합니다. 안드로이드 공식 가이드도 모듈화를 권장하며, 프로젝트 규모에 맞게 코드의 확장성을 향상시키고 가독성을 개선하며 전반적인 코드 품질을 높이는 수단으로 모듈화를 소개합니다.\n\n모듈화는 Jetpack Compose에서 고유한 도전 과제를 소개합니다: 독립된 모듈로부터의 클래스는 그들의 퍼블릭 프로퍼티의 불변성 여부와 상관없이 불안정하다고 간주됩니다. 이를 극복하기 위해, 데이터 모듈에 compose-runtime 라이브러리를 가져오고 데이터 클래스에 안정성 주석을 달 것을 권장합니다.\n\n그러나, Jetpack Compose 런타임 라이브러리에 직접 의존하지 않고 순수한 Kotlin/JVM 라이브러리에 초점을 맞춘 경우에는 compose 런타임 라이브러리에 의존하는 것이 이상적이지 않은 경우가 있을 수 있습니다. 이러한 시나리오에서 두 가지 주요 솔루션이 제시됩니다: compose-stable 마커 라이브러리를 채택하거나 안정성을 보장하기 위해 파일 구성을 활용하는 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 안정적인 마커 작성기\n\n\"안정적인 마커\" 라이브러리는 @Immutable 및 @Stable과 같은 안정성 주석을 제공하며, 이는 compose-runtime 라이브러리 내의 유사한 주석 기능을 반영합니다. compose-runtime 라이브러리를 직접 사용하는 것 대신 compose-stable 마커 라이브러리를 선택하면 아래에 설명된 두 가지 주요 이점이 제공됩니다:\n\n- 가벼움: 클래스, 함수 및 확장 기능이 풍부한 compose-runtime 라이브러리는 응용 프로그램의 크기를 늘릴 수 있는 가능성이 있습니다. 반면에 compose-stable 마커 라이브러리는 안정성 주석에만 초점을 맞춘 가벼운 대안을 제공합니다. 이를 통해 응용 프로그램의 크기를 줄이고 전체 compose-runtime 라이브러리를 사용하는 것보다 빌드 시간을 단축할 수 있습니다.\n- 의존성 없음: compose-runtime 라이브러리에는 SideEffect, LaunchedEffect, snapshotFlow 및 Compose 컴파일러와 관련된 기타 주석들과 같은 Compose 런타임 기능을 실행하는 데 필수적인 기능이 포함되어 있습니다. 이러한 설정은 데이터 모듈에 필요하지 않은 경우에도 모듈이 이러한 API에 액세스 할 수 있는 가능성을 발생시킬 수 있습니다. compose-stable 마커 라이브러리를 선택하면 이러한 특수화된 API에 실수로 액세스하는 위험을 제거하여 모듈이 집중되고 효율적으로 유지되도록 보장합니다.\n\n해당 라이브러리의 좋은 사용 사례는 Compose용 Stream의 적응 가능한 채팅 및 비디오 SDK의 코어 모듈에서 발견할 수 있습니다. 이러한 SDK의 코어 모듈은 compose-stable 마커를 활용하여 도메인 클래스를 안정적으로 지정합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\ncompose-stable-marker 라이브러리에 대해 더 알아보려면 GitHub 저장소를 방문해 주세요.\n\n# 파일 구성\n\n이전 섹션에서 논의한 것처럼 파일 구성은 Compose 컴파일러와의 계약을 달성하여 원본이나 가변성과 무관하게 특정 클래스를 안정적으로 다루도록 합니다. 이는 다른 모듈에서 클래스를 나열하여 파일 구성에 포함시키면 컴파일러가 자동으로 이를 안정적인 것으로 인식한다는 것을 의미합니다.\n\n한 가지 강조해야 할 점은 이 기능을 분별하여 사용해야 합니다. Compose 컴파일러는 이러한 클래스들을 안정적으로 지속적으로 다룰 것이므로 스마트한 재구성 행동을 조정하여 의도하지 않은 동작을 유발할 수 있습니다. 또한, 이러한 강제적인 안정성으로 인한 디버깅 문제는 애플리케이션 내에서 해결하기 어려울 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 강한 스킵 모드\n\n컴포저블 함수를 제작할 때 건너뛸 수 있는 또 다른 전략은 강한 스킵 모드를 활성화하는 것입니다. Compose Compiler 버전 1.5.4에서 소개된 이 기능은 불안정한 매개변수를 포함한 경우에도 컴포저블 함수를 건너뛸 수 있게 해주며, 불안정한 캡처를 포함하는 람다를 최적화된 성능을 위해 메모이즈합니다.\n\n현재 실험 단계에 있으며 아직 제품용으로 준비되지 않았지만, 강한 스킵 모드는 Compose 1.7 알파에서 기본으로 활성화될 예정입니다. 효과와 안정성은 베타 단계로 진행되기 전에 철저히 평가될 것입니다. 일시적으로 이 실험적 기능을 활성화하려면 다음 Compose 컴파일러 옵션을 포함시키면 됩니다:\n\n강한 스킵 모드는 재구성 중에 컴포저블 함수를 건너뛸 때 Compose 컴파일러가 사용하는 전통적인 안정성 기준을 수정합니다. 일반적인 상황에서 컴포저블 함수는 오직 안정적인 매개변수만 포함하고 있는 경우에만 건너뛸 수 있는 것으로 간주됩니다. 그러나 강한 스킵 모드는 이 전통을 변경합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 기능이 활성화되면 모든 다시 시작 가능한 Composable 함수가 건카볼입니다. 이전 값을 무시하고 불안정한 매개변수가 포함되었는지 여부에 관계없이. 그러나, 다시 시작할 수 없는 Composable 함수는 영향을 받지 않으며 건너뛸 수 없습니다.\n\n재조합 중 Composable 함수를 건너뛸지 여부를 평가할 때 이 모드는 불안정한 매개변수와 해당 이전 값과의 인스턴스 동등성을 비교하기 위해 사용됩니다. 반면에, 안정적 매개변수는 Object.equals()에 의해 정의된 객체 동등성을 사용하여 비교됩니다.\n\n재조합 중 이러한 기준에 모든 매개변수가 일치하는 경우 Composable 함수가 우회됩니다. 불필요한 업데이트를 줄여 성능을 최적화합니다.\n\nComposable 함수를 강력한 건카볼 모드에서 제외하고 다시 시작할 수 있지만 건너뛸 수 없도록 만들려면 @NonSkippableComposable 주석을 적용할 수 있습니다. 이는 매개변수 안정성과 관계없이 항상 재조합을 위해 해당 함수가 고려됨을 보장합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n한편, 객체 동등성(object equality)을 사용하여 객체를 비교하려면 여전히 도메인 모델 클래스에 @Stable 주석을 추가해야 합니다.\n이 기능과 람다 메모이제이션(Lambda Memoization)의 향상된 개념에 대한 더 깊은 이해를 위해 '강력한 스킵 모드(Strong Skipping Mode)'에 대한 상세 가이드를 참조해보세요.\n\n# 결론\n\n탐험이 마무리되었습니다! 안정성의 개념, 안정성 추론과 스마트 recomposition 뒤에 숨은 메커니즘, 클래스 및 Composable 함수를 안정화하는 효과적인 전략, 그리고 응용 프로그램 성능을 향상시키는 방법에 대해 다루었습니다.\n\n안정성의 중요성을 깨달으면 화면에 UI 노드를 렌더링하는 메커니즘에 영향을 줌으로써 최종적으로 응용 프로그램의 성능에 영향을 미치게 됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 테이블 태그를 마크다운 형식으로 변경해주세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n원래 getstream.io에 게시되었습니다.\n","ogImage":{"url":"/assets/img/2024-05-17-OptimizeAppPerformanceByMasteringStabilityinJetpackCompose_0.png"},"coverImage":"/assets/img/2024-05-17-OptimizeAppPerformanceByMasteringStabilityinJetpackCompose_0.png","tag":["Tech"],"readingTime":30},{"title":"앱 아키텍처 프레젠테이션 레이어","description":"","date":"2024-05-17 18:36","slug":"2024-05-17-AppArchitecturePresentationlayer","content":"\n![Presentation Layer](/assets/img/2024-05-17-AppArchitecturePresentationlayer_0.png)\n\n오늘은 우리 아키텍처의 프레젠테이션 레이어를 살펴보겠습니다. 이 레이어에는 UI 관련 로직과 사용자가 볼 수 있고 상호 작용할 수 있는 모든 것이 포함됩니다. 또한 이 레이어는 애플리케이션 데이터를 사용자가 읽을 수 있는 형태로 해석하고 반대로 사용자 상호 작용을 앱의 데이터 변경으로 변환하는 것을 담당합니다.\n\n![UI Layer](/assets/img/2024-05-17-AppArchitecturePresentationlayer_1.png)\n\n이 안내서에서는 UI 레이어를 구현하고 구성하는 방법을 보여줄 것입니다. UI 레이어를 구축하기 위해 사용할 수 있는 많은 라이브러리, 프레임워크 및 패턴이 있습니다. 오늘은 Android Fragment + Jatpack Compose + Orbit-MVI + Kotlin + Flow + Coroutines + Koin (DI) 기술 스택을 기반으로 모든 것을 구축할 것입니다. 이것은 최적의 조합 중 하나입니다. 저는 Router, Router Container, ViewModel, Screen, Navigator와 같은 UI 구성 요소에 초점을 맞출 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 라우터\n\n**라우터**는 다음과 같은 기능을 수행하는 메인 UI 유닛입니다:\n\n- ViewModel, Navigator 및 화면 구성 요소와 함께 UI 요소를 보유합니다.\n- UI 상태를 소비합니다.\n- Side Effects(일회성 액션)를 처리합니다.\n- 사용자 상호 작용을 ViewModel로 전달합니다.\n\n라우터 뒤에 있는 주요 아이디어는 UI 상태를 생성하고 관리하는 방법을 알고 있으며 탐색할 수 있는, 자체 지속 가능한 UI 유닛을 캡슐화하는 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 네이밍 규칙\n\nRoute 클래스는 해당하는 화면 이름에 따라 이름이 지정됩니다.\n\n화면 이름 + Route\n\n예를 들어: FareListRoute, ConformationRoute.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 코드에서는 Router가 어떻게 보이는지 확인할 수 있습니다. 매개변수로 전달되는 ViewModel은 Koin(DI)에 의해 주입됩니다. 이와 함께, 이전 화면에서 전달된 Navigator와 ryderId를 데이터로 전달합니다. Koin의 멋진 기능 중 하나는 ryderId를 ViewModel 생성자에 주입할 수 있다는 것입니다.\n\nViewModel 섹션에서 다룰 것입니다. Router에서는 ViewModel이 보유한 상태를 수집하고, 해당 상태를 Screen에 매개변수로 전달합니다.\n\ncollectAsState는 ViewModel이 Orbit 라이브러리에서 구현하는 ContainerHost의 확장 기능입니다.\n\nlifecycleState — 이 Flow 작업을 다시 시작하는 Lifecycle이 유지됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nMarkdown으로 표 태그를 변경하세요.\n\n| Header 1 | Header 2 |\n| -------- | -------- |\n| Data 1   | Data 2   |\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 명명 규칙\n\n이 클래스들은 그들이 책임지고 있는 UI 구성 요소에 따라 이름이 지어집니다.\n\nUI 구성 요소 이름 + Fragment.\n\n예를 들어 FareListFragment.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nUI 구성 요소 이름 + 컨트롤러.\n\n예를 들어 FareListController.\n\n프래그먼트 클래스의 코드가 작은 이유는 모든 UI 로직이 Route에 캡슐화되어 있기 때문입니다. 이는 컨테이너 구현을 쉽게 변경할 수 있습니다.\n\n이것이 왜 네비게이터의 주입 로직이 Router가 아닌 Fragment 안에 있는 이유입니다. 네비게이터는 네비게이션 로직을 구현하기 위해 Fragment NavController를 필요로하기 때문입니다. 이렇게 함으로써 Router와 컨테이너 구현이 분리되고, 우리가 컨테이너 구현을 쉽게 변경할 수 있게 해줍니다. 예를 들면 — Compose 네비게이션이나 Conductor 라이브러리의 Controller를 사용하는 것과 같이요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 네비게이터\n\n네비게이터는 다음을 담당합니다:\n\n- 라우터에서의 탐색 로직을 캡슐화합니다.\n- 특정 화면을 위한 탐색 API를 제한합니다.\n- 각 화면을 위해 명확한 API를 정의합니다.\n\n화면이 다른 화면으로 탐색해야 하는 경우, 해당 화면에 자체 네비게이터 클래스가 있어야 합니다. 이는 기본 ScreenNavigator에서 기본적인 뒤로 가기 동작을 가진 확장되어 있을 수 있으며, 다른 네비게이터와 Fragment NavController와 같은 플랫폼 의존적인 구성 요소를 포함할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 네이밍 규칙\n\n네비게이터 클래스는 해당하는 화면 이름 뒤에 붙여지는 이름입니다:\n\n화면 이름 + 네비게이터.\n\n예를 들어 FareListNavigator.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n앱 아키텍처 프레젠테이션 계층 다이어그램을 살펴보는 걸로 하죠.\n\n![다이어그램](/assets/img/2024-05-17-AppArchitecturePresentationlayer_2.png)\n\n여기서 Core, Shared와 같은 핵심 모듈, Fare 및 Profile과 같은 기능 모듈, 그리고 App 모듈을 볼 수 있어요.\n\n예를 들어, Fare 모듈이 있는데 그중 하나는 사용자의 프로필 화면으로 이동하는 버튼이 있는 기능이 있어요. 사용자 프로필 페이지는 Profile 모듈에 있죠. 이 네비게이션을 어떻게 구현하면 좋을까요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그걸 위해, 사용자 프로필 페이지로 이동하는 방법을 아는 ProfileSharedNavigator 인터페이스를 만들어야 하고, Shared 모듈에 유지해야 합니다.\n\n우리 아키텍처에 따르면 Fare 모듈은 Shared에 의존하므로 FareListNavigator에서 ProfileSharedNavigator를 사용할 수 있습니다.\n\n우리는 FareListNavigator에 ProfileSharedNavigator를 인수로 전달하고, 그곳에 있는 내비게이션 호출을 위임합니다.\n\nScreenNavigator는 이동하는 방법만을 알고 있는 베이스 클래스입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n앱 모듈은 앱 내 모두에 대해 모든 정보를 알고 있습니다. 이 모듈의 주요 목적은 프로젝트의 모든 피처 모듈 사이에 있는 모든 의존성 주입 로직을 조직화하는 것입니다.\n\nAppNavigator가 ProfileSharedNavigator 인터페이스의 실제 구현을 보유하고 있음을 확인할 수 있습니다. 이 인터페이스에 다양한 모듈에서 의존할 수 있으며, 의존성 역전 원칙 (DIP)을 따라 App 모듈에서 이를 구현할 수 있습니다.\n\n# 상태\n\n상태 파일에는 UI 상태 데이터 클래스가 포함되어 있으며, 사이드 이펙트 시그니처가 가장 적합합니다. 상태 클래스는 구성 변경을 통해 상태가 보존되길 원할 경우 Parcelable(선택 사항)할 수 있습니다. 모든 속성은 가능하다면 기본값을 가져야 합니다. Effect 클래스에는 UI에서의 일회성 작업이 포함되어 있습니다. 이는 네비게이션, 토스트, 스낵 바, 바텀 시트 또는 대화 상자와 같은 것입니다. Effect에 대해 자세히 알아보려면 Orbit Side Effect 문서를 읽어볼 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 네이밍 규칙\n\n상태 클래스는 담당하는 UI 구성 요소 유형에 따라 명명됩니다. 규칙은 다음과 같습니다:\n\nUI 구성 요소 이름 + State.\n\nUI 구성 요소 이름 + Effect.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n예를 들어, FareListState 및 FareListEffect.\n\n화면에 다른 로딩 상태가 있는 경우, 상태 클래스에서 명확하게 분리하는 것이 좋습니다. 화면에는 Idle, Loading, Refreshing, Success, Failure와 같은 몇 가지 콘텐츠 상태가 있을 수 있습니다. 초기 콘텐츠 로딩 후 서버에 요청을 보내어 사용자에게 로딩을 표시하고 싶을 때, status 필드를 사용하여 ScreenContentStatus.Loading을 설정하는 대신 별도의 showRequestLoading 속성을 사용하여 로딩 대화상자를 표시하는 것이 좋습니다. 하나의 필드를 재사용하여 다양한 로딩 케이스를 처리하려고 하지 말아야 합니다.\n\n# 모델\n\n프레젠테이션 레이어에는 도메인 레이어의 모델을 반영하지만 더 UI에 특화된 데이터 모델이 있습니다. 프레젠테이션 모델과 도메인 간의 매핑 로직은 ViewModel 클래스에 배치해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 프레젠테이션 레이어는 다른 레이어에게 UI 모델을 노출해서는 안 돼요.\n- 프레젠테이션 모델은 Parcelable 및 Serializable과 같은 플랫폼별 직렬화 방식을 구현할 수 있어요.\n- 프레젠테이션 모델은 변경 불가능해야 해요.\n\n## 네이밍 규칙\n\n모델 클래스는 그들이 책임지는 데이터 유형을 나타내는 이름으로 지어져요:\n\n데이터 유형 + Model.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n예를 들어: Ryder, Fare.\n\n## ViewModel\n\nViewModel은 비즈니스 로직 상태 보유자입니다. Android 개발에서 ViewModel은 비즈니스 로직에 액세스를 제공하고 응용 프로그램 데이터를 화면에 표시하기 위해 적합합니다. 또한 사용자 이벤트를 처리하고 데이터나 도메인 계층에서 화면 UI 상태로 데이터를 변환합니다.\n\n현재 구현에서 androidx.lifecycle.ViewModel과 Orbit-MVI lib을 사용하고 있습니다. ViewModel은 Orbit 컨테이너를 보유하고 ContainerHost를 구현합니다. 무엇이 진행 중인지 더 잘 이해하기 위해 Orbit API 문서를 확인해보세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 네이밍 규칙\n\n뷰모델 클래스는 그들이 책임지는 UI 구성 요소 유형에 따라 명명됩니다:\n\nUI 구성 요소 이름 + ViewModel.\n\n예를 들어, FareListViewModel.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 코드에서 ViewModel의 예제를 확인할 수 있습니다. 거기에서 무슨 일이 일어나고 있는지 알아보겠습니다.\n\n먼저 생성자부터 시작해 보겠습니다. 알 수 있듯이, 도메인 레이어에서 유스 케이스를 주입하고, 이전 화면에서 전달한 ryderId 및 ExceptionHandler를 주입합니다. ViewModel은 여러 개의 유스 케이스를 가질 수 있습니다.\n\n아래와 같이 래퍼 클래스에 사용 사례를 넣고\n\n그리고 ViewModel에 넣으려고 하지 마세요\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nfetchFares 메소드에서 흥미로운 일이 더 많이 진행됩니다.\n\nOrbit 라이브러리 API에 대해 간략히 설명하겠습니다. Intent 메소드는 Dispatcher.Default에서 람다를 실행합니다. Reduce 메소드는 Dispatcher.Main에서 람다를 실행합니다. 이는 상태를 줄이고 UI 상태를 업데이트합니다.\n\nexecuteUseCase는 ViewModel의 확장 메소드로, 유증 실행하고 해당 결과를 kotlin.Result`R`으로 랩핑하는 역할을 합니다. Result 클래스의 확장 메소드인 onSuccess, onFailure 등의 메소드를 사용할 수 있게 합니다. 또한, 예외를 ViewModel 핸들러에 전달합니다.\n\n하나의 작업을 위해 2개 이상의 유증을 실행해야 하는 상황에 직면하면 다음 옵션을 고려해보시기 바랍니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 새 사용 사례를 만들고 모든 로직을 그곳에 넣으세요. 필요한 사용 사례를 결합하세요.\n- 여러 사용 사례에서 결과를 기다려야하고 그 결과를 결합해야한다면:\n\nasPresentation() 메소드는 도메인 계층의 데이터 모델을 프레젠테이션 계층의 모델로 매핑하는 역할을 합니다. 계층간 데이터를 전달하는 방법은 여기에서 읽을 수 있습니다.\n\n# 화면\n\n화면 파일에는 UI 구성 구현이 모두 포함되어 있으며, 각 화면 상태에 대한 Compose 미리 보기가 포함되어 있습니다. 상태에는 비어 있는 상태, 오류 상태, 로딩 상태, 콘텐츠 상태 등이 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 네이밍 규칙\n\n화면 클래스는 해당 UI 구성 요소 유형을 책임지고 있으므로 그에 따라 명명됩니다:\n\nUI 구성 요소 이름 + Screen.\n\n예를 들어 FareListScreen.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nUI를 Compose를 사용하여 빌드할 때 따르는 것이 좋은 몇 가지 규칙이 있습니다.\n\n- 상태를 가지지 않는 Composable을 상태를 가지는 Composable보다 선택하세요. 이에 대해 더 알아보려면 여기를 읽어보세요.\n- 모든 콜백을 최상위 화면 Composable에 전달하고 모든 사용자 상호 작용을 라우터 수준의 ViewModel에 전달하세요.\n- UI 구성 요소의 다른 상태에 대한 Composable 미리보기를 만드세요.\n\nTopAppBar Composable 함수를 작성해야 한다고 상상해보세요. 타이틀을 매개변수로 전달하는 두 가지 방법이 있습니다. String으로 타이틀을 전달하거나 @Composable () -> Unit 함수로 전달하는 방법이 있습니다.\n\n옵션 1.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n옵션 2를 항상 선택하세요. 그렇게 하면 Composable 함수가 더 맞춤 설정 가능하고 강력해집니다.\n\n## 화면 미리보기\n\n화면 미리보기를 실제 시나리오와 최대한 비슷하게 보이도록 하려면 상태를 만들기 위해 무작위 데이터가 필요합니다. 이를 위해 FareModelFake 클래스를 만들어서 FareModel과 동일한 패키지에 넣을 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n model/\n├─FareModel\n├─FareModelFake\n```\n\nFareModelFake 클래스에는 미리보기에 사용할 수 있는 가짜 데이터가 포함된 FareModel이 있습니다.\n\n# 패키징 규칙\n\n```js\npresentation/\n├─ fare/\n│ ├─ component/\n│ │ ├─ FareList\n│ │ ├─ FareItem\n│ ├─ model/\n│ │ ├─ FareModel\n│ │ ├─ FareModelFake\n│ ├─ FareListFragment\n│ ├─ FareListNavigator\n│ ├─ FareListRoute\n│ ├─ FareListScreen\n│ ├─ FareListState\n│ ├─ FareListViewModel\n├─ confirmation/\n│ ├─ component/\n│ │ ├─ ConfirmationItem\n│ ├─ model/\n│ │ ├─ ConfirmationModel\n│ │ ├─ ConfirmationModelFake\n│ ├─ ConfirmationFragment\n│ ├─ ConfirmationNavigator\n│ ├─ ConfirmationRoute\n│ ├─ ConfirmationScreen\n│ ├─ ConfirmationState\n│ ├─ ConfirmationViewModel\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 마무리\n\n프레젠테이션 레이어를 구현하는 다양한 방법이 있습니다. 오늘은 프레젠테이션 레이어를 구현하는 방법에 대해 몇 가지 아이디어를 공유했습니다. 이 접근 방식을 따르거나 여러분의 구현에 몇 가지 아이디어를 활용할 수 있습니다.\n\nGitHub에서 샘플 프로젝트를 확인할 수 있습니다.\n\n다음 앱 아키텍처 주제에 대한 소식을 기다려주세요.\n","ogImage":{"url":"/assets/img/2024-05-17-AppArchitecturePresentationlayer_0.png"},"coverImage":"/assets/img/2024-05-17-AppArchitecturePresentationlayer_0.png","tag":["Tech"],"readingTime":14},{"title":"S3 이벤트 알림을 사용하여 썸네일 생성하기","description":"","date":"2024-05-17 18:32","slug":"2024-05-17-UseS3eventnotificationstogeneratethumbnails","content":"\n## 이벤트 기반 서버리스 아키텍처\n\n![이미지](/assets/img/2024-05-17-UseS3eventnotificationstogeneratethumbnails_0.png)\n\n안녕하세요!\n\n애플리케이션에서 파일을 클라우드에 저장하는 것은 파일 지속성의 한 방법으로 매우 일반적입니다. 이를 통해 애플리케이션이 어디에서 어떻게 사용될지에 대한 많은 유연성을 제공합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nAWS는 객체를 저장할 수 있는 옵션으로 관리형 서비스 S3 (Simple Storage Service)를 제공합니다. 이 서비스는 높은 가용성, 확장성 및 성능을 갖추고 있습니다. 주로 웹 애플리케이션의 저장 서비스로 사용됩니다.\n\nS3는 버킷 안에서 객체 작업에 대한 알림을 받을 수 있는 기능도 제공합니다. 이는 객체 생성, 업데이트, 이동, 삭제 등의 작업일 수 있습니다. 이를 S3 이벤트 알림이라고 합니다.\n\n이 문서에서는 이미지를 업로드할 때마다 해당 이미지에 대한 섬네일을 생성하는 서버리스 애플리케이션을 살펴보겠습니다.\n\n우리는 이벤트 알림을 수신하고 섬네일을 생성하는 Go로 작성된 람다 함수를 가질 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n해보자구요!\n\n# 요구 사항\n\n- AWS 계정\n- 좋아하는 코드 편집기 (저는 Visual Studio Code를 사용할 예정입니다)\n- GitHub 계정\n\n# 아키텍처\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-05-17-UseS3eventnotificationstogeneratethumbnails_1.png\" />\n\n버킷을 구성하여 객체 이벤트를 SNS 토픽으로 보내고 해당 메시지를 생성한 썸네일을 S3 버킷에 업로드할 람다로 전송할 것입니다.\n\nS3 버킷 이벤트에 람다를 직접 대상으로 지정하지 않을 것입니다. 이유는 각 이벤트 알림에 대해 하나의 대상 유형만 지정할 수 있기 때문입니다. SNS 토픽을 대상으로 사용하면 SQS 대기열, 이메일, 전화 알림 및 SNS가 지원하는 기타 여러 대상으로 이벤트를 전파할 수 있습니다.\n\n# Terraform을 사용하여 인프라 구성하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 이미지 S3 버킷\n\n시작하려면 우리의 테라폼 폴더를 설정하기 위해 프로젝트의 루트 레벨에 iac라는 폴더를 만들어 주세요. 그 안에 providers.tf라는 파일을 생성해 AWS 프로바이더를 구성할 수 있도록 다음 코드를 추가해 주세요:\n\n```js\nterraform {\n  required_providers {\n    aws = {\n      source  = \"hashicorp/aws\"\n      version = \"~> 5.0\"\n    }\n  }\n}\n\n// Region은 AWS_REGION 환경 변수에서 설정됩니다\nprovider \"aws\" {\n}\n```\n\n만약 테라폼이 인프라 상태를 추적하도록 하려면, AWS에서 S3 버킷을 생성하고 상태 백엔드로 설정할 수 있습니다. 아래 코드에서처럼 하시면 됩니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nterraform {\n  required_providers {\n    aws = {\n      source  = \"hashicorp/aws\"\n      version = \"~> 5.0\"\n    }\n  }\n\n  backend \"s3\" {\n    bucket = \"terraform-medium-api-notification\" // 여기가 상태 버킷입니다\n    key    = \"thumbnail-generator/state\"\n  }\n}\n\n// AWS_REGION 환경 변수에서 지역 설정됨\nprovider \"aws\" {\n}\n```\n\n이제 이미지를 호스팅하는 S3 버킷을 만들어 봅시다.\n\niac 폴더에 s3.tf라는 파일을 만들고 다음 코드를 추가해주세요:\n\n```js\nresource \"aws_s3_bucket\" \"my-app-images\" {\n  bucket = \"my-super-app-images\" // 버킷에 고유한 이름을 사용해주세요\n}\n\nresource \"aws_s3_object\" \"images_folder\" {\n  bucket = aws_s3_bucket.my-app-images.bucket\n  key    = \"images/\"\n}\n\nresource \"aws_s3_object\" \"thumbnails_folder\" {\n  bucket = aws_s3_bucket.my-app-images.bucket\n  key    = \"thumbnails/\"\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n버킷 속성에서는 버킷에 고유한 이름을 사용해야 합니다. 왜냐하면 S3 버킷 이름은 모든 AWS 전역에서 고유하기 때문입니다. 이름을 제공하지 않으려면 비워두고 AWS가 고유한 버킷 이름을 할당해 줄 것입니다.\n\n이 코드는 이미지/ 및 썸네일/ 두 개의 폴더가 있는 S3 버킷을 생성합니다. 이 폴더들은 파일을 저장하는 데 사용할 것입니다.\n\n## SNS를 사용한 메시징\n\n이제 알림 주제와 메시지 대기열을 설정해 봅시다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```yaml\n# messaging.tf\n\nresource \"aws_sns_topic\" \"topic\" {\nname   = \"image-events\"\n}\n```\n\n```yaml\n# variables.tf\n\nvariable \"region\" {\n  description = \"Default region of your resources\"\n  type        = string\n  default     = \"eu-central-1\" # Set as your default region here\n}\n\nvariable \"account_id\" {\n  description = \"The ID of the default AWS account\"\n  type        = string\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그리고 variables.tfvars라는 또 다른 파일을 만들어 변수를 설정하세요:\n\n```js\nregion = \"eu-central-1\"; // 원하는 지역을 설정하세요\n```\n\n나중에 테라폼 명령어에 전달할 account_id는 나중에 인수로 전달할 것입니다.\n\n## S3 이벤트 알림\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 S3에 대한 이벤트 알림을 설정해 봅시다.\n\ns3.tf 파일에 다음 코드를 추가하여 버킷 알림을 설정하세요:\n\n```js\nresource \"aws_s3_bucket_notification\" \"images_put_notification\" {\n  bucket = aws_s3_bucket.my-app-images.id\n  topic {\n    topic_arn = aws_sns_topic.topic.arn\n    filter_prefix = \"images/\"\n    events = [\"s3:ObjectCreated:*\"]\n  }\n}\n```\n\n이를 활성화하려면 S3 버킷이 해당 topic으로 알림을 발행할 수 있도록 SNS topic에 정책을 추가해야 합니다. messaging.tf 파일로 이동하여 다음 정책을 추가하세요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n리소스 \"aws_sns_topic\" \"topic\" {\n  name   = \"image-events\"\n  policy = data.aws_iam_policy_document.sns-topic-policy.json\n}\n\n데이터 \"aws_iam_policy_document\" \"sns-topic-policy\" {\n  policy_id = \"arn:aws:sns:${var.region}:${var.account_id}:image-events/SNSS3NotificationPolicy\"\n  statement {\n    sid    = \"s3-allow-send-messages\"\n    effect = \"Allow\"\n    principals {\n      type        = \"Service\"\n      identifiers = [\"s3.amazonaws.com\"]\n    }\n    actions = [\n      \"SNS:Publish\",\n    ]\n    resources = [\n      \"arn:aws:sns:${var.region}:${var.account_id}:image-events\",\n    ]\n    condition {\n      test     = \"ArnEquals\"\n      variable = \"aws:SourceArn\"\n      values = [\n        aws_s3_bucket.my-app-images.arn\n      ]\n    }\n  }\n}\n```\n\n여기서는 sns-topic-policy 리소스를 생성하고 해당 리소스를 policy 속성에 전달하는 topic 리소스를 생성합니다.\n\n## 기본 람다 추가하기\n\n이제 람다의 기반 인프라를 추가하기만 남았습니다. 이후에 코드를 추가할 기본 람다를 설정할 것입니다. Go 언어로 코드를 작성할 예정입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n먼저, 람다 함수를 초기화할 기본 코드가 필요합니다. 그래서 iac 폴더에 lambda_init_code라는 폴더를 만들어주세요. 여기서 소스 코드를 가져와서 메인 컴파일된 파일을 직접 사용하거나 README.md 파일의 지시에 따라 새로운 실행 가능 파일을 컴파일할 수 있습니다.\n\n이제 새 파일 lambdas.tf를 생성하고 다음 코드를 추가하여 람다 인프라를 추가할 수 있습니다:\n\n```js\nresource \"aws_iam_role\" \"iam_for_lambda\" {\n  name               = \"thumbnail-generator-lambda-role\"\n  assume_role_policy = data.aws_iam_policy_document.assume_role.json\n  inline_policy {\n    name   = \"DefaultPolicy\"\n    policy = data.aws_iam_policy_document.lambda_role_policies.json\n  }\n}\nresource \"aws_lambda_function\" \"lambda\" {\n  filename      = data.archive_file.lambda.output_path\n  function_name = \"thumbnail-generator\"\n  role          = aws_iam_role.iam_for_lambda.arn\n  handler       = \"main\"\n  runtime       = \"go1.x\"\n  timeout       = 15\n}\n\ndata \"archive_file\" \"lambda\" {\n  type        = \"zip\"\n  source_file = \"./lambda_init_code/main\"\n  output_path = \"thumbnail_generator_lambda_function_payload.zip\"\n}\n\ndata \"aws_iam_policy_document\" \"assume_role\" {\n  statement {\n    effect = \"Allow\"\n    principals {\n      type        = \"Service\"\n      identifiers = [\"lambda.amazonaws.com\"]\n    }\n    actions = [\"sts:AssumeRole\"]\n  }\n}\n\ndata \"aws_iam_policy_document\" \"lambda_role_policies\" {\n  statement {\n    effect = \"Allow\"\n    actions = [\n      \"logs:CreateLogGroup\",\n      \"logs:CreateLogStream\",\n      \"logs:PutLogEvents\",\n    ]\n    resources = [\"arn:aws:logs:*:*:*\"]\n  }\n}\n```\n\n이렇게 하면 런타임으로 Go를 사용하는 람다 함수를 생성하고 역할을 만들며, 람다 함수가 이 역할을 가정하고 클라우드워치에 로깅할 수 있도록 권한을 부여합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음으로, 람다가 트리거될 수 있도록 SNS 주제에 대한 구독을 만들어야 합니다. lambdas.tf 파일에 다음 코드를 추가할 수 있습니다:\n\n```js\nresource \"aws_sns_topic_subscription\" \"topic_subscription\" {\n  topic_arn = aws_sns_topic.topic.arn\n  protocol  = \"lambda\"\n  endpoint  = aws_lambda_function.lambda.arn\n}\n\nresource \"aws_lambda_permission\" \"apigw_lambda\" {\n  statement_id  = \"AllowExecutionFromSNS\"\n  action        = \"lambda:InvokeFunction\"\n  function_name = aws_lambda_function.lambda.arn\n  principal     = \"sns.amazonaws.com\"\n  source_arn    = aws_sns_topic.topic.arn\n}\n```\n\n최종 lambdas.tf 파일이 다음과 같이 되도록 만들어보세요:\n\n```js\nresource \"aws_iam_role\" \"iam_for_lambda\" {\n  name               = \"thumbnail-generator-lambda-role\"\n  assume_role_policy = data.aws_iam_policy_document.assume_role.json\n  inline_policy {\n    name   = \"DefaultPolicy\"\n    policy = data.aws_iam_policy_document.lambda_role_policies.json\n  }\n}\n\nresource \"aws_lambda_function\" \"lambda\" {\n  filename      = data.archive_file.lambda.output_path\n  function_name = \"thumbnail-generator\"\n  role          = aws_iam_role.iam_for_lambda.arn\n  handler       = \"main\"\n  runtime       = \"go1.x\"\n  timeout       = 15\n}\n\nresource \"aws_sns_topic_subscription\" \"topic_subscription\" {\n  topic_arn = aws_sns_topic.topic.arn\n  protocol  = \"lambda\"\n  endpoint  = aws_lambda_function.lambda.arn\n}\n\nresource \"aws_lambda_permission\" \"apigw_lambda\" {\n  statement_id  = \"AllowExecutionFromSNS\"\n  action        = \"lambda:InvokeFunction\"\n  function_name = aws_lambda_function.lambda.arn\n  principal     = \"sns.amazonaws.com\"\n  source_arn    = aws_sns_topic.topic.arn\n}\n\ndata \"archive_file\" \"lambda\" {\n  type        = \"zip\"\n  source_file = \"./lambda_init_code/main\"\n  output_path = \"thumbnail_generator_lambda_function_payload.zip\"\n}\n\ndata \"aws_iam_policy_document\" \"assume_role\" {\n  statement {\n    effect = \"Allow\"\n    principals {\n      type        = \"Service\"\n      identifiers = [\"lambda.amazonaws.com\"]\n    }\n    actions = [\"sts:AssumeRole\"]\n  }\n}\n\ndata \"aws_iam_policy_document\" \"lambda_role_policies\" {\n  statement {\n    effect = \"Allow\"\n    actions = [\n      \"logs:CreateLogGroup\",\n      \"logs:CreateLogStream\",\n      \"logs:PutLogEvents\"\n    ]\n    resources = [\"arn:aws:logs:*:*:*\"]\n  }\n\n  statement {\n    effect = \"Allow\"\n    actions = [\n      \"s3:GetObject\",\n    ]\n    resources = [\n      format(\"%s/%s*\", aws_s3_bucket.my-app-images.arn, aws_s3_object.images_folder.key)\n    ]\n  }\n\n  statement {\n    effect = \"Allow\"\n    actions = [\n      \"s3:PutObject\",\n    ]\n    resources = [\n      format(\"%s/%s*\", aws_s3_bucket.my-app-images.arn, aws_s3_object.thumbnails_folder.key)\n    ]\n  }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리의 SNS 토픽이 람다를 이벤트와 함께 호출할 수 있도록 권한을 부여할 것입니다.\n\n람다는 15초의 제한 시간을 갖고 있습니다. 이는 기본 제한 시간이 3초이기 때문에 S3로 파일을 다운로드하고 업로드하는 작업은 이미지 크기에 따라 3초보다 더 오래 걸릴 수 있기 때문입니다. 이는 S3 작업이 인터넷을 통과하기 때문에 발생하는 것입니다. 성능을 향상시키고 싶다면 VPC를 생성하고 람다와 VPC 엔드포인트를 만들어 S3 서비스에 대한 연결이 인터넷이 아닌 AWS 네트워크를 통해 이루어지도록 할 수 있습니다.\n\n## 인프라 배포하기\n\n이제 우리가 코드로 정의한 인프라를 배포하기 위해 GitHub 액션을 사용해보겠습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n코드에 .github/workflows 폴더를 만들고 deploy-infra.yml 파일을 추가하여 GitHub 액션 워크플로우를 정의하세요:\n\n```yml\nname: Deploy Infrastructure\non:\n  push:\n    branches:\n      - main\n    paths:\n      - iac/**/*\n      - .github/workflows/deploy-infra.yml\n\ndefaults:\n  run:\n    working-directory: iac/\n\njobs:\n  terraform:\n    name: \"Terraform\"\n    runs-on: ubuntu-latest\n    steps:\n      # GitHub Actions 러너에 리포지토리를 체크아웃\n      - name: Checkout\n        uses: actions/checkout@v3\n\n      - name: Configure AWS Credentials Action For GitHub Actions\n        uses: aws-actions/configure-aws-credentials@v1\n        with:\n          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY }}\n          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}\n          aws-region: eu-central-1\n\n      # 최신 버전의 Terraform CLI 설치 및 Terraform Cloud 사용자 API 토큰을 사용하여 Terraform CLI 구성 파일 설정\n      - name: Setup Terraform\n        uses: hashicorp/setup-terraform@v3\n\n      # Terraform 워킹 디렉터리를 초기화하고 초기 파일을 생성하거나 기존 파일을 로드하고 모듈 다운로드 등을 수행\n      - name: Terraform Init\n        run: terraform init\n\n      # 모든 Terraform 구성 파일이 규범적 형식을 준수하는지 확인\n      - name: Terraform Format\n        run: terraform fmt -check\n\n      # Terraform 실행 계획 생성\n      - name: Terraform Plan\n        run: |\n          terraform plan -out=plan -input=false -var-file=\"variables.tfvars\" -var account_id=${{ secrets.AWS_ACCOUNT_ID }}\n\n      # \"main\"으로 푸시되면 Terraform 구성 파일에 따라 인프라를 구축 또는 변경함\n      # 참고: \"Terraform Cloud\"에 대해 \"strict\" 상태 검사를 설정하는 것이 권장됩니다. 자세한 정보는 아래 문서를 참조하세요: https://help.github.com/en/github/administering-a-repository/types-of-required-status-checks\n      - name: Terraform Apply\n        run: terraform apply -auto-approve -input=false plan\n```\n\n- AWS_ACCESS_KEY — 자원을 생성할 권한이 있는 AWS의 액세스 키입니다\n- AWS_SECRET_ACCESS_KEY — 액세스 키와 연결된 AWS 시크릿\n- AWS_ACCOUNT_ID — AWS 대시보드 오른쪽 상단에 있는 계정 ID입니다\n- YOUR_REGION — 인프라를 배포할 기본 지역\n\n이제 코드를 GitHub에 푸시하고 워크플로우가 완료되면 인프라가 생성되는 것을 확인해보세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n테스트하려면 이미지/ 폴더에 파일을 업로드하고 CloudWatch에서 람다 로그를 확인할 수 있습니다.\n\nS3는 두 개의 폴더로 생성되어야 합니다:\n\n![image](/assets/img/2024-05-17-UseS3eventnotificationstogeneratethumbnails_2.png)\n\nSNS는 구독이 있는 상태로 생성되어야 합니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-05-17-UseS3eventnotificationstogeneratethumbnails_3.png\" />\n\nLambda를 SNS 트리거와 함께 생성해야합니다:\n\n<img src=\"/assets/img/2024-05-17-UseS3eventnotificationstogeneratethumbnails_4.png\" />\n\n# Lambda 구현\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n인프라가 설치되었으므로 썸네일 생성기 코드를 구현해야 합니다.\n\n루트 레벨에 src이라는 새 폴더를 생성하고 다음 코드를 실행하여 Go 모듈을 초기화해보세요:\n\n```js\ngo mod init example.com/thumbnail-generator\ngo get github.com/aws/aws-lambda-go\ngo get github.com/aws/aws-sdk-go-v2\ngo get github.com/aws/aws-sdk-go-v2/service/s3\ngo get github.com/aws/aws-sdk-go-v2/config\ngo get github.com/disintegration/imaging\n```\n\n원하는 경우 example.com/thumbnail-generator를 선호하는 모듈 이름으로 교체할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 main.go 파일을 만들고 다음 코드를 추가하세요:\n\n```go\npackage main\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"image\"\n\t\"image/png\"\n\t\"io\"\n\t\"log\"\n\t\"strings\"\n\n\t\"github.com/aws/aws-lambda-go/events\"\n\t\"github.com/aws/aws-lambda-go/lambda\"\n\t\"github.com/aws/aws-sdk-go-v2/aws\"\n\t\"github.com/aws/aws-sdk-go-v2/config\"\n\t\"github.com/aws/aws-sdk-go-v2/service/s3\"\n\t\"github.com/disintegration/imaging\"\n)\n\ntype awsClient struct {\n\ts3  s3.Client\n\tctx *context.Context\n}\n\nfunc handleRequest(ctx context.Context, event events.SNSEvent) error {\n\tawsConfig, err := config.LoadDefaultConfig(ctx)\n\n\tif err != nil {\n\t\tlog.Fatalf(\"AWS 기본 구성을 불러 올 수 없습니다\")\n\t\treturn err\n\t}\n\n\tawsClient := awsClient{s3: *s3.NewFromConfig(awsConfig), ctx: &ctx}\n\n\tfor _, record := range event.Records {\n\t\tvar imageEvent events.S3Event\n\n\t\terr := json.Unmarshal([]byte(record.SNS.Message), &imageEvent)\n\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"SNS 메시지 %s을 S3 이벤트 레코드로 언마샬하는 동안 오류가 발생했습니다: %v\", record.SNS.Message, err)\n\t\t\treturn err\n\t\t}\n\n\t\tfor _, imageRecord := range imageEvent.Records {\n\t\t\tbucketName := imageRecord.S3.Bucket.Name\n\t\t\tobjectKey := imageRecord.S3.Object.Key\n\n\t\t\tfile, err := awsClient.downloadFile(bucketName, objectKey)\n\n\t\t\tlog.Printf(\"이미지 다운로드 성공\")\n\n\t\t\tif err != nil {\n\t\t\t\tlog.Fatalf(\"버킷 %s에서 파일 %s을 로드하는 중 오류가 발생했습니다\", bucketName, objectKey)\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tthumbnail, err := createThumbnail(file)\n\n\t\t\tif err != nil {\n\t\t\t\tlog.Fatalf(\"버킷 %s의 파일 %s에 대한 섬네일 생성 중 오류가 발생했습니다. 오류: %v\", bucketName, objectKey, err)\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tlog.Printf(\"섬네일 생성 성공\")\n\n\t\t\terr = awsClient.uploadFile(bucketName, objectKey, thumbnail)\n\n\t\t\tlog.Printf(\"섬네일 업로드 성공\")\n\n\t\t\tif err != nil {\n\t\t\t\tlog.Fatalf(\"버킷 %s에 파일 %s을 thumbnails/에 업로드하는 중 오류가 발생했습니다\", bucketName, objectKey)\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc createThumbnail(reader io.Reader) (*bytes.Buffer, error) {\n\tsrcImage, _, err := image.Decode(reader)\n\n\tif err != nil {\n\t\tlog.Fatalf(\"오류로 인해 파일을 디코딩할 수 없습니다: %v\", err)\n\t\treturn nil, err\n\t}\n\n\t// 80x80 크기의 섬네일 생성\n\tthumbnail := imaging.Thumbnail(srcImage, 80, 80, imaging.Lanczos)\n\n\tvar bufferBytes []byte\n\tbuffer := bytes.NewBuffer(bufferBytes)\n\n\terr = png.Encode(buffer, thumbnail)\n\n\treturn buffer, err\n}\n\nfunc (client *awsClient) downloadFile(bucketName string, objectKey string) (*bytes.Reader, error) {\n\tresult, err := client.s3.GetObject(*client.ctx, &s3.GetObjectInput{\n\t\tBucket: aws.String(bucketName),\n\t\tKey:    aws.String(objectKey),\n\t})\n\n\tif err != nil {\n\t\tlog.Fatalf(\"객체를 가져올 수 없음 %v:%v. 원인: %v\", bucketName, objectKey, err)\n\t\treturn nil, err\n\t}\n\n\tdefer result.Body.Close()\n\n\tbody, err := io.ReadAll(result.Body)\n\n\tif err != nil {\n\t\tlog.Fatalf(\"파일을 읽는 중 오류 발생. 오류: %s\", err)\n\t\treturn nil, err\n\t}\n\n\tfile := bytes.NewReader(body)\n\n\treturn file, err\n}\n\nfunc (client *awsClient) uploadFile(bucketName string, originalObjectKey string, thumbnail io.Reader) error {\n\tobjectKeyParts := strings.Split(originalObjectKey, \"/\")\n\tfileNameWithoutExtensions := strings.Split(objectKeyParts[len(objectKeyParts)-1], \".\")[0]\n\tobjectKey := fmt.Sprintf(\"thumbnails/%s_thumbnail.png\", fileNameWithoutExtensions)\n\n\t_, err := client.s3.PutObject(*client.ctx, &s3.PutObjectInput{\n\t\tBucket: aws.String(bucketName),\n\t\tKey:    aws.String(objectKey),\n\t\tBody:   thumbnail,\n\t})\n\n\tif err != nil {\n\t\tlog.Fatalf(\"%v을(를) %v의 %v에 업로드할 수 없음. 원인: %v\\n\",\n\t\t\toriginalObjectKey, bucketName, objectKey, err)\n\t}\n\n\treturn err\n}\n\nfunc main() {\n\tlambda.Start(handleRequest)\n}\n```\n\n이제 GitHub workflow를 설정하여 람다 코드를 배포해야 합니다.\n\n.github/workflows 폴더에 deploy-lambda.yml이라는 새 파일을 추가하고 다음 코드를 추가하세요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```bash\nname: Deploy Thumbnail Generator Lambda\non:\n  push:\n    branches:\n      - main\n    paths:\n      - src/**/*\n      - .github/workflows/deploy-lambda.yml\n\ndefaults:\n  run:\n    working-directory: src/\n\njobs:\n  terraform:\n    name: 'Deploy Thumbnail Generator Lambda'\n    runs-on: ubuntu-latest\n    steps:\n      # Checkout the repository to the GitHub Actions runner\n      - name: Checkout\n        uses: actions/checkout@v3\n\n      - uses: actions/setup-go@v4.1.0\n        with:\n          go-version: '1.22.0'\n\n      - name: Configure AWS Credentials Action For GitHub Actions\n        uses: aws-actions/configure-aws-credentials@v1\n        with:\n          aws-access-key-id: ${ secrets.AWS_ACCESS_KEY }\n          aws-secret-access-key: ${ secrets.AWS_SECRET_ACCESS_KEY }\n          aws-region: eu-central-1\n\n      - name: Build Lambda\n        run: GOOS=linux GOARCH=amd64 CGO_ENABLED=0 go build -o build/main .\n\n      - name: Zip build\n        run: zip -r -j main.zip ./build\n\n      - name: Update Lambda code\n        run: aws lambda update-function-code --function-name=thumbnail-generator --zip-file=fileb://main.zip\n```\n\n코드를 커밋하고 레포지토리에 푸시하면 빌드가 실행됩니다.\n\n완료되면 Lambda 페이지의 \"최종 수정\" 속성을 확인하여 배포된 것을 확인할 수 있습니다:\n\n<img src=\"/assets/img/2024-05-17-UseS3eventnotificationstogeneratethumbnails_5.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n테스트하려면 S3 버킷의 images/ 폴더에 이미지를 업로드해야 합니다. 업로드가 성공하면 잠시 기다린 후 새로 만든 섬네일을 확인할 수 있습니다.\n\n# 결론\n\n이 글에서는 Terraform 인프라스트럭처를 사용하여 S3 버킷, 람다, SNS, SNS 알림 등을 생성하고 연결하는 방법을 배웠습니다.\n\n또한 S3 이벤트를 SNS 토픽에 보내어 이를 다른 소스(다른 SNS 토픽 포함)로 확산할 수 있는 방법도 배웠습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저희는 Go로 작성된 람다 함수도 만들었어요. 이 함수는 SNS 메시지를 통해 호출되어 S3 버킷에서 파일을 다운로드하고 이미지에서 썸네일을 생성한 다음 이 썸네일을 S3에 업로드합니다.\n\n이 글의 코드는 여기에서 확인할 수 있어요.\n\n즐거운 코딩하세요! 💻\n","ogImage":{"url":"/assets/img/2024-05-17-UseS3eventnotificationstogeneratethumbnails_0.png"},"coverImage":"/assets/img/2024-05-17-UseS3eventnotificationstogeneratethumbnails_0.png","tag":["Tech"],"readingTime":23},{"title":"테라폼 DevOps 안내서 보안 최상의 실천 방안","description":"","date":"2024-05-17 18:29","slug":"2024-05-17-TheGuidetoTerraformDevOpsSecurityBestPractices","content":"\n<img src=\"/assets/img/2024-05-17-TheGuidetoTerraformDevOpsSecurityBestPractices_0.png\" />\n\n# 요약\n\n전통적으로, 인프라 구축은 수동 구성을 포함하는 시간이 많이 소요되고 오류 발생 가능성이 있는 프로세스였습니다. Terraform은 코드로 인프라를 정의할 수 있도록 함으로써 이러한 관행을 바꿉니다. HashiCorp Configuration Language (HCL)로 작성된 코드는 필요한 리소스(서버, 네트워크, 데이터베이스)와 이들의 구성을 구체화합니다. 경험이 풍부한 실무자든 초보자든, 본 안내서는 현대적인 DevOps 방법론에 대한 Terraform의 패러다임 전환적인 영향에 대한 귀중한 통찰을 제공합니다.\n\n# 목차\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- Terraform DevOps 안내서: 보안 모범 사례\n- 요약\n- 목차\n- 소개\n- 전제 조건\n  - 💡해결책💡\n- Terraform 상태를 안전하게 유지 🫶\n- 비밀 정보 안전하게 관리하기 🫶\n- 역할 기반 액세스 제어 (RBAC) 구현\n- 코드 리뷰와 협업 🫶\n- CI/CD 파이프라인 구현 💣\n- Terraform 모듈 및 제공업체 안전하게 사용하기 💣\n- 로깅 및 모니터링 🫶\n- 네트워크 보안 🫶\n- 감사 및 규정 준수 👀\n- 재해 복구 및 백업 👀\n- 결론\n- 내 정보\n- 참고 문헌\n\n# 소개\n\nTerraform은 인프라스트럭처의 코드 (IaC)에 대한 필수 도구로, 여러 클라우드 제공업체 간에 자원을 통합적으로 관리할 수 있게 해줍니다. 그러나 큰 권한에는 큰 책임이 따릅니다. 어떠한 구성 오류도 전체 인프라스트럭처에 영향을 줄 수 있기 때문에 보안이 매우 중요합니다.\n\n전통적으로 인프라스트럭처 프로비저닝은 수동 구성을 필요로 하며, 시간이 많이 걸리고 오류가 발생하기 쉬운 과정이었습니다. Terraform은 이에 도전하여 인프라스트럭처를 코드로 정의할 수 있도록 해주는 접근법을 제공합니다. HashiCorp Configuration Language (HCL)로 작성된 코드는 필요한 리소스 (서버, 네트워크, 데이터베이스)와 그 구성을 지정합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 기사는 Terraform의 이점에 대해 탐구하고 IaC 배포가 안전하고 신뢰할 수 있도록 보장하기 위한 필수 보안 모범 사례를 제공합니다. 우리는 다음과 같은 주요 영역을 탐색할 것입니다:\n\n💣 취약점 감사: Terraform 구성에서 취약성을 예방적으로 식별하고 제거하는 방법을 배웁니다.\n\n💣 접근 제어 모범 사례: 접근 자격 증명을 안전하게 관리하고 최소 권한 원칙을 시행하는 전략을 발견합니다.\n\n💣 안전한 Terraform 모듈: 모듈을 안전하게 활용하고 보안을 염두에 두고 자체 모듈을 생성하는 방법을 이해합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\"IBM와 HashiCorp의 병합된 포트폴리오는 고객이 증가하는 애플리케이션 및 인프라 복잡성을 관리하고 AI 시대를 위해 설계된 포괄적인 하이브리드 클라우드 플랫폼을 만들 수 있도록 도와줍니다.\" - IBM 회장이자 최고 경영자인 아빈드 크리슈나가 말했습니다.\n\n# 준비 사항\n\n우리가 본격적인 작업에 들어가기 전에, 먼저 로컬 머신이나 개발 서버에 필요한 서비스가 있는지 확인해야 합니다:\n\n- React 및 Terraform에 대한 기본 지식.\n- AWS 계정\n- GitHub 계정\n- AWS CLI 설치 및 구성 완료.\n- 로컬에 Docker 설치.\n- Terraform\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 💡 솔루션 💡\n\n데브옵스 환경에서 Terraform을 구현하려면 인프라스트럭처 코드(IaC) 방법론이 취약점을 도입하지 않도록 보안에 중점을 두어야 합니다.\n\n<img src=\"/assets/img/2024-05-17-TheGuidetoTerraformDevOpsSecurityBestPractices_1.png\" />\n\n다음은 Terraform을 사용할 때 보안을 유지하기 위한 모베스트 프랙티스입니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 테라폼 상태 보안을 강화하세요 🫶\n\n- 원격 상태 저장소 사용: 상태 파일을 AWS S3, Azure Blob Storage 또는 Google Cloud Storage와 같은 원격 백엔드에 저장하여 무단 액세스를 방지하는 적절한 액세스 제어를 적용하세요.\n- 상태 파일 암호화: 원격 백엔드에 저장된 상태 파일에 대해 서버 측 암호화를 활성화하세요.\n- 액세스 제한: IAM 역할 및 정책을 사용하여 상태 파일에 대한 액세스를 필요한 사용자에게로 제한하세요.\n\n예시:\n\n```js\nvariable \"db_password\" {\n  type    = string\n  sensitive = true\n}\n\ndata \"terraform_remote_state\" \"foo\" {\n  backend = \"http\"\n  config = {\n    address = \"http://my.rest.api.com\"\n  }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여기에서 더 많은 정보를 얻을 수 있습니다:\n\n# **보안적으로 비밀을 관리하기 🫶**\n\n- **비밀 직접 코딩 피하기**: Terraform 파일에 비밀번호, API 키 또는 기밀 정보와 같은 중요한 정보를 직접 코딩하지 마세요.\n- **시크릿 관리 도구 사용하기**: HashiCorp Vault, AWS Secrets Manager 또는 Azure Key Vault와 같은 시크릿 관리 도구를 통합하여 Terraform 구성에 안전하게 시크릿을 관리하고 주입하세요.\n\n예를 들어 Azure Key Vault를 사용하여 비밀을 안전하게 관리하는 방법:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nprovider.tf\n\n```js\nterraform {\n  required_version = \">=1.0\"\n  required_providers {\n    azurerm = {\n      source  = \"hashicorp/azurerm\"\n      version = \"~>3.0\"\n    }\n    random = {\n      source  = \"hashicorp/random\"\n      version = \"~>3.0\"\n    }\n  }\n}\n\nprovider \"azurerm\" {\n  features {}\n}\n```\n\nmain.tf\n\n```js\nresource \"random_string\" \"secret_value\" {\n  length  = 20\n  special = true\n}\n\nresource \"azurerm_key_vault\" \"vault\" {\n  name                       = \"my-key-vault\"\n  location                   = \"East US\"\n  resource_group_name        = \"my-resource-group\"\n  tenant_id                  = data.azurerm_client_config.current.tenant_id\n  sku_name                   = \"standard\"\n  soft_delete_retention_days = 7\n\n  access_policy {\n    tenant_id = data.azurerm_client_config.current.tenant_id\n    object_id = local.current_user_id\n    secret_permissions = [\"get\", \"list\"]\n  }\n}\n\nresource \"azurerm_key_vault_secret\" \"my_secret\" {\n  name         = \"my-secret\"\n  value        = random_string.secret_value.result\n  key_vault_id = azurerm_key_vault.vault.id\n}\n\ndata \"azurerm_client_config\" \"current\" {}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# Role-Based Access Control (RBAC) 구현\n\n- IAM 정책 사용: 사용자 및 서비스가 필요한 권한만 갖도록 IAM 정책을 정의하고 강제합니다.\n- 역할 분리: 각 단계 (개발, 스테이징, 프로덕션)에 대해 서로 다른 역할을 사용하고 최소 권한의 원칙을 적용합니다.\n\n예를 들어 Azure 리소스를 위한 Role-Based Access Control (RBAC) :\n\n```js\nterraform {\n  required_providers {\n    azurerm = {\n      source  = \"hashicorp/azurerm\"\n      version = \"~>2.0\"\n    }\n    azuread = {\n      source = \"hashicorp/azuread\"\n    }\n  }\n}\n\nprovider \"azurerm\" {\n  features {}\n}\n\n// main.tf\ndata \"azuread_user\" \"aad_user\" {\n  for_each            = toset(var.avd_users)\n  user_principal_name = format(\"%s\", each.key)\n}\n\ndata \"azurerm_role_definition\" \"role\" {\n  name = \"Desktop Virtualization User\"\n}\n\nresource \"azuread_group\" \"aad_group\" {\n  display_name     = var.aad_group_name\n  security_enabled = true\n}\n\nresource \"azuread_group_member\" \"aad_group_member\" {\n  for_each         = data.azuread_user.aad_user\n  group_object_id  = azuread_group.aad_group.id\n  member_object_id = each.value[\"id\"]\n}\n\nresource \"azurerm_role_assignment\" \"role\" {\n  scope              = azurerm_virtual_desktop_application_group.dag.id\n  role_definition_id = data.azurerm_role_definition.role.id\n  principal_id       = azuread_group.aad_group.id\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 코드 리뷰 및 협업 🫶\n\n- 버전 관리 사용: 테라폼 구성을 Git과 같은 버전 관리 시스템(VCS)에 저장하세요.\n- 코드 리뷰: 잠재적인 보안 문제를 미리 발견하기 위해 테라폼 구성에 대한 모든 변경에 대해 필수 코드 리뷰를 실시하세요.\n- 풀 리퀘스트: 변경 사항을 본 브랜치로 병합하기 전에 리뷰 및 토론하기 위해 풀 리퀘스트를 사용하세요.\n\n# CI/CD 파이프라인 구현 💣\n\n```js\nname: 테라폼 CI/CD\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n    branches:\n      - main\n\nenv:\n  ARM_CLIENT_ID: ${ secrets.ARM_CLIENT_ID }\n  ARM_CLIENT_SECRET: ${ secrets.ARM_CLIENT_SECRET }\n  ARM_SUBSCRIPTION_ID: ${ secrets.ARM_SUBSCRIPTION_ID }\n  ARM_TENANT_ID: ${ secrets.ARM_TENANT_ID }\n  TF_VAR_client_id: ${ secrets.ARM_CLIENT_ID }\n  TF_VAR_client_secret: ${ secrets.ARM_CLIENT_SECRET }\n  TF_VAR_subscription_id: ${ secrets.ARM_SUBSCRIPTION_ID }\n  TF_VAR_tenant_id: ${ secrets.ARM_TENANT_ID }\n\njobs:\n  terraform:\n    name: '테라폼'\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: 코드 체크아웃\n        uses: actions/checkout@v2\n\n      - name: 테라폼 설정\n        uses: hashicorp/setup-terraform@v2\n        with:\n          terraform_version: 1.3.7\n\n      - name: 테라폼 초기화\n        run: terraform init\n\n      - name: 테라폼 포맷\n        run: terraform fmt -check\n\n      - name: 테라폼 유효성 검사\n        run: terraform validate\n\n      - name: 테라폼 계획\n        id: plan\n        run: terraform plan -out=plan.tfplan\n        continue-on-error: true\n\n      - name: 테라폼 적용\n        if: github.ref == 'refs/heads/main' && github.event_name == 'push'\n        run: terraform apply -auto-approve plan.tfplan\n\n      - name: 테라폼 삭제 (옵션)\n        if: github.event_name == 'pull_request' && github.event.action == 'closed' && github.event.pull_request.merged == false\n        run: terraform destroy -auto-approve\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 배포 자동화: CI/CD 파이프라인을 사용하여 Terraform 배포를 자동화하여 일관성을 유지하고 인간 에러의 위험을 줄입니다.\n- 취약점 검사: CI/CD 파이프라인에 보안 스캔 도구를 통합하여 배포 전에 Terraform 구성에서 취약점을 감지합니다.\n\n# Terraform 모듈과 프로바이더 안전하게 사용하기 💣\n\n- 프로바이더 확인: Terraform 레지스트리 또는 신뢰할 수 있는 소스에서 확인된 프로바이더와 모듈만 사용합니다.\n- 버전 핀: 프로바이더와 모듈의 버전을 핀하여 상위 업데이트로 인한 의도하지 않은 변경을 방지합니다.\n- 코드 검토: 모듈과 프로바이더의 코드를 정기적으로 검토하고 감사하여 보안 위험을 방지합니다.\n\n예시:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nmodule \"network\" {\n  source  = \"terraform-azure-modules/network/azurerm\"\n  version = \"2.0.0\"\n  # 기타 모듈 입력 값\n}\n```\n\n# 로깅 및 모니터링 🫶\n\n- 로깅 활성화: 테라폼에서 수행되는 모든 작업이 로깅되고, 이러한 로그가 이상 활동을 모니터링하는 데 사용될 수 있도록 합니다.\n- 상태 변경 모니터링: 테라폼 상태 및 인프라 변경에 대한 경보를 설정하여 무단 수정에 신속하게 대응할 수 있도록 합니다.\n\n# 네트워크 보안 🫶\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- VPC 및 서브넷 사용: 가상 사설 클라우드(VPC) 및 서브넷을 이용하여 리소스를 격리하도록 네트워크 아키텍처를 설계하세요.\n- 보안 그룹 및 방화벽: 엄격한 보안 그룹 규칙과 네트워크 방화벽 정책을 적용하여 트래픽 흐름을 제어하고 노출을 제한하세요.\n\n# 감사 및 규정 준수 👀\n\n- 정기 감사: Terraform 구성 및 배포된 인프라의 보안 감사와 규정 준수 점검을 정기적으로 수행하세요.\n- 규정 준수 코드: 규정 준수를 보장하기 위해 Terraform 구성에 규정 준수 점검을 통합하세요. regulatory and organizational standards을 준수합니다.\n\n# 재해 복구 및 백업 👀\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nprovider \"azurerm\" {\n  features {}\n}\n\nresource \"azurerm_resource_group\" \"rg\" {\n  name     = var.resource_group_name\n  location = var.location\n}\n\nresource \"azurerm_recovery_services_vault\" \"recovery_vault\" {\n  name                = \"myRecoveryServicesVault\"\n  resource_group_name = azurerm_resource_group.rg.name\n  location            = azurerm_resource_group.rg.location\n  sku                 = \"Standard\"\n}\n\nresource \"azurerm_backup_policy_vm\" \"backup_policy\" {\n  name                = \"myBackupPolicy\"\n  resource_group_name = azurerm_resource_group.rg.name\n  recovery_vault_name = azurerm_recovery_services_vault.recovery_vault.name\n\n  backup {\n    frequency = \"Daily\"\n    time      = \"23:00\"\n  }\n\n  retention_daily {\n    count = 7\n  }\n}\n\nresource \"azurerm_kubernetes_cluster\" \"aks\" {\n  name                = var.aks_name\n  location            = azurerm_resource_group.rg.location\n  resource_group_name = azurerm_resource_group.rg.name\n  dns_prefix          = var.dns_prefix\n\n  default_node_pool {\n    name       = \"default\"\n    node_count = var.node_count\n    vm_size    = var.vm_size\n  }\n\n  identity {\n    type = \"SystemAssigned\"\n  }\n\n  tags = {\n    environment = \"Production\"\n  }\n}\n\nresource \"azurerm_log_analytics_workspace\" \"log_analytics\" {\n  name                = var.log_analytics_workspace_name\n  location            = azurerm_resource_group.rg.location\n  resource_group_name = azurerm_resource_group.rg.name\n  sku                 = \"PerGB2018\"\n  retention_in_days   = 30\n}\n\nresource \"azurerm_kubernetes_cluster_node_pool\" \"node_pool\" {\n  name                  = \"additionalpool\"\n  kubernetes_cluster_id = azurerm_kubernetes_cluster.aks.id\n  vm_size               = \"Standard_DS2_v2\"\n  node_count            = 1\n}\n\nresource \"azurerm_backup_protected_vm\" \"protected_vm\" {\n  resource_group_name = azurerm_resource_group.rg.name\n  recovery_vault_name = azurerm_recovery_services_vault.recovery_vault.name\n  source_vm_id        = azurerm_kubernetes_cluster.aks.id\n  backup_policy_id    = azurerm_backup_policy_vm.backup_policy.id\n}\n```\n\n- 백업 상태 파일: 우연한 삭제나 손상으로부터 회복할 수 있도록 Terraform 상태 파일을 정기적으로 백업합니다.\n- 재해 복구 계획: 재해 복구 계획을 개발하고 테스트하여 치명적인 장애 발생 시 Terraform을 사용하여 인프라를 복원할 수 있도록 합니다.\n\n이런 모범 사례를 따르면 Terraform으로 관리되는 인프라의 보안을 크게 향상시키고 잠재적인 취약점과 잘못된 구성의 위험을 줄일 수 있습니다.\n\n고려해야 할 몇 가지 부가 사항이 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 데이터의 존속중 암호화 #1 — 서버 측 암호화는 데이터를 적절히 보호하지만, 특히 환경 간 전송 시 상태 파일을 암호화하는 것을 고려해보세요. 👑\n- 서비스 계정에 대한 최소 권한 부여 #2 — Terraform과 서비스 계정을 사용할 때, 해당 계정이 특정 작업에 필요한 최소한의 권한을 갖도록하십시오.\n- 인프라 제거 테스트 #3 — 자동화된 테스트를 CI/CD 파이프라인에 포함하여 Terraform이 인프라를 안전하게 제거할 수 있는지 확인하세요. 재해 복구 시나리오에 중요합니다. 👑\n- 최신 유지 #3 — 정기적으로 Terraform 자체, 모듈 및 프로바이더를 업데이트하여 보안 패치와 버그 수정의 이점을 누리세요.\n\n# 결론\n\nDevOps 환경에서 Terraform을 보안하는 데 이러한 모범 사례를 따르면 리스크를 최소화하고 인프라를 코드로 제어하는 강력한 방어수단을 확보할 수 있습니다. 안전한 상태 관리, 적절한 비밀 처리, 역할 기반 액세스 제어, 철저한 코드 리뷰, 자동화된 CI/CD 파이프라인, 주시적인 로깅 및 모니터링, 엄격한 감사 및 규정 준수 프로세스 등의 조치를 시행하여 취약점에 대응하는 인프라를 강화할 수 있습니다. 궁극적으로 보안에 대한 선제적인 접근은 시스템을 안전하게 지키는 데 도움이 되는 것뿐만 아니라 조직 내 신뢰와 신뢰성을 육성할 것입니다.\n\n읽어 주셔서 감사합니다! 🙌🏻 구독하고 CLAP을 꼭 눌러주세요 👏 다음 기사에서 만나요.🤘\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 나에 대해\n\n“안녕하세요! 저는 조엘 오웜보이라고 합니다. AWS 인증 클라우드 아키텍트, 백엔드 개발자, 그리고 AWS 커뮤니티 빌더입니다. 필리핀에 거주하고 있어요. 제가 가지고 있는 강점은 클라우드 아키텍처, 데브옵스 실천 방법, 그리고 고가용성 (HA) 원칙에 대한 깊은 이해를 결합한 것입니다. 제 지식을 활용하여 효율적인 기업 배포를 위해 오픈 소스 도구를 사용하여 견고하고 확장 가능한 클라우드 애플리케이션을 만들어내고 있습니다.”\n\n저자(Joel O. Wembo)에 대한 더 많은 정보를 원하시면 아래 링크를 확인해주세요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- Linkedin: [https://www.linkedin.com/in/joelotepawembo/](https://www.linkedin.com/in/joelotepawembo/)\n- Website: [https://joelwembo.com](https://joelwembo.com)\n- Twitter: [https://twitter.com/joelwembo1](https://twitter.com/joelwembo1)\n- GitHub: [https://github.com/joelwembo](https://github.com/joelwembo)\n- Portfolio: [joelwembo.github.io](joelwembo.github.io)\n- [https://www.patreon.com/joelwembo](https://www.patreon.com/joelwembo)\n\n# References\n","ogImage":{"url":"/assets/img/2024-05-17-TheGuidetoTerraformDevOpsSecurityBestPractices_0.png"},"coverImage":"/assets/img/2024-05-17-TheGuidetoTerraformDevOpsSecurityBestPractices_0.png","tag":["Tech"],"readingTime":16},{"title":"Vault 비밀, 엔진, 경로 및 더 많은 작동 방식","description":"","date":"2024-05-17 18:26","slug":"2024-05-17-HowVaultsecretsenginespathsandmorework","content":"\n## Hashicorp Vault은 구성 관리를 중앙 집중화하는 시크릿 관리 시스템입니다. 처음에 만났을 때 너무 방대한 설명서 때문에 헷갈렸었어요. 제게 제공된 정보가 제가 쉽게 이해할 수 있는 형태가 아니었거든요. 그래서 이 기사를 작성하여 그 간극을 좁히는 데 도움이 되길 바래봅니다.\n\n![HowVaultsecretsenginespathsandmorework](/assets/img/2024-05-17-HowVaultsecretsenginespathsandmorework_0.png)\n\n이 기사에서는 Hashicorp 자습서를 자세히 살펴보기 전에 이해해야 할 개념에 대해 설명했습니다. 여기서 목표는 작업 방법을 보여주는 것이 아니라 작동 원리를 설명하는 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n본 글에서 Vault의 설치 과정을 다루지는 않았지만 다른 문서에서 다루었으니 참고하세요.\n\n# 기본 개념\n\nVault가 작동하는 방식에 기본적으로 필요한 여러 개념이 있습니다:\n\n- 네임스페이스\n- 시크릿\n- 시크릿 엔진\n- 경로\n- 인증 방법\n- 정책\n- 토큰\n- 래핑된 토큰\n- 개체와 별칭\n- 그룹 및 별칭\n- 역할\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만약 이 내용을 이해하지 못한다면, Vault를 사용 사례에 어떻게 적용해야 하는지 이해하는 데 어려움을 겪을 수도 있어요.\n\n## 네임스페이스\n\n네임스페이스는 동일한 배포 내에서 가상 Vault 인스턴스를 만들어냅니다.\n\n네임스페이스는 서로 독립적으로 Vault의 설정을 관리하는 다른 팀, 고객 또는 테넌트를 허용합니다. 네임스페이스 내에서 비밀, 엔진, 정책 등은 다른 네임스페이스에서 완전히 격리되어 있어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n비기업 사용자의 경우, 네임스페이스를 무시할 수 있습니다.\n\n## 비밀 정보\n\n알고 계실지도 모르겠지만 Vault는 비밀 정보를 관리합니다. 그렇다면 비밀 정보란 무엇일까요?\n\n비밀 정보란 기본적으로 접근 권한을 엄격히 제어해야 하는 정보입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nVault는 모든 유형의 비밀을 관리할 수 있지만, 특정 유형의 비밀을 처리하기 위해 내장된 기능이 있습니다. 이러한 유형은 다음과 같습니다:\n\n- 키-값 쌍\n- 비밀번호\n- 데이터베이스 접근\n- TLS 키 및 인증서\n- API 키\n- 암호화 키\n- SSH 키\n- 토큰\n- 등등…\n\n배포 구성에 따라 비밀의 크기 제한이 있습니다. 기본적으로 통합(raft) 저장 계층을 사용하는 경우, 제한은 1MiB입니다.\n\n## 시크릿 엔진\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n시크릿 엔진은 Vault가 특정 유형의 시크릿을 관리할 수 있도록 하는 플러그인으로 볼 수 있습니다. 실제로, 나는 엔진을 시크릿 관리자로 생각하지만 Vault에서는 엔진이라고 부릅니다.\n\n![image](/assets/img/2024-05-17-HowVaultsecretsenginespathsandmorework_1.png)\n\n각 시크릿 엔진은 고유한 기능을 가지고 있지만, 전반적으로 시크릿을 다음과 같이 허용합니다:\n\n- 생성, 읽기, 수정 및 삭제\n- 암호화\\*\n- 만료 시간 (TTL)에 따라 만료\n- TTL 새로 고침되는지 여부에 관계없이 최대 수명 후 만료\n- 자동으로 생성되어 클라이언트 및 서버 응용 프로그램에 삽입됨\n- 취소됨\n- 버전 관리됨\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n엔진의 예로는 특정 권한 범위를 설정받은 일시적인 로그인 자격 증명을 생성할 수 있는 데이터베이스 엔진이 있습니다. 요청에 새 자격 증명을 생성함으로써 해당 자격 증명을 회전시킵니다.\n\n시크릿 엔진은 활성화 및 비활성화됩니다. 활성화되면 필요한 시크릿 관리 서비스를 제공하기 위해 구성됩니다. 비활성화되면 엔진은 모든 구성과 시크릿을 포함한 모든 정보가 삭제되며, 이것들은 저장소에서 삭제되어 되돌릴 수 없습니다.\n\n동일 유형의 엔진을 여러 인스턴스로 활성화하는 것이 가능하다는 점을 기억해야 합니다. 예를 들어 3개의 KV 엔진과 2개의 데이터베이스 엔진을 활성화할 수 있습니다. 이는 추가적인 보안을 제공합니다. 한 엔진 인스턴스는 같은 유형의 다른 엔진에서부터 아무 것도 접근할 수 없습니다.\n\nVault 내부에서 사용되는 Identity 시크릿 엔진이 있지만 이에 대해서는 나중에 자세히 알아보겠습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 경로\n\n파일 시스템과 같이 Vault는 비밀을 경로를 통해 추적합니다. 컴퓨터에서는 /my-work/docs/myreport.txt에 파일이 있을 수 있습니다. Vault를 사용할 때는 /my-secrets/my-app/login에 비밀이 있을 수 있습니다.\n\n비밀의 경로는 세 부분에서 구성됩니다:\n\n`namespace`/`엔진 마운트 지점`/`비밀 경로`\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n엔진을 활성화하면 엔진 마운트 포인트에서 그렇게 합니다. 기본적으로 이 마운트 포인트는 엔진의 이름으로 지정됩니다 (예: 데이터베이스) 하지만 이를 변경하거나 경로를 포함할 수도 있습니다. 예를 들어 my-dbs/postgres와 같이 이름을 지정할 수 있습니다. 이렇게 하면 다른 엔진을 my-dbs/my-sql과 같은 위치에서 활성화할 수 있습니다.\n\n경로의 두 번째 부분은 마운트 포인트 내의 특정 Secret의 경로를 식별합니다 (즉, 엔진 내에서).\n\n예를 들어 (이 예시에서 마운트 포인트는 ``를 사용하여 식별되었습니다):\n\n```js\n<kv>/path/to/my/kv-secret\n<database>/path/to/my/postgres-secret/credentials\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n어떤 비밀 정보도 같은 엔진 내에서 동일한 하위 경로를 가질 수 없습니다. 이것은 말이 되지만(마운트 지점과 달리) 일부 하위 경로를 공유할 수도 있습니다. 다음과 같이:\n\n```js\n<database>/path/to/my/postgres-secret/credentials\n<database>/path/to/my/mysql-secret/credentials\n<database>/path/to/my/oracle-secret/credentials\n```\n\nUI 내에서 이것은 폴더 구조처럼 작동하여 엔진(database) - `path` - `to` - `my` - `postgres-secret`까지 credentials까지 이동할 수 있습니다.\n\n경로에 연결된 것은 비밀 정보뿐만 아니라 Vault에서 관리하는 리소스에도 해당되며, 인증 방법과 정책도 경로를 가지고 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n경로를 떠나기 전에, 리소스에 대한 작업 또한 경로를 통해 참조될 수 있다는 점을 이해하는 것이 중요합니다. 이 경우 경로는 다음과 같이 생성됩니다:\n\n`namespace`/`engine mount point`/`path to secret`/`action`\n\n## 인증 방법\n\n지금까지 Secrets에 대해 이야기했지만, 이제는 어떻게 해당 Secrets에 접근하는지 살펴보아야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nVault에 액세스하는 세 가지 방법이 있습니다:\n\n- 사용자 인터페이스(UI)를 통해\n- 명령 줄 도구(CLI)를 통해\n- HTTP REST API(API)를 통해\n\n사실, 이들은 모두 주로 API를 사용합니다. 이것을 이해하는 것이 중요한데, UI나 CLI에서 수행하는 작업에 대해 curl 명령어를 구성할 수 있다는 의미입니다. 스크립트를 작성할 때 매우 유용합니다.\n\n‘우리’라는 말을 사용할 때, 물리적 서버, 애플리케이션 또는 사람 모두 식별(즉, 인증)되어야 하고, Vault를 사용하기 전에 특정 비밀(Secret)에 액세스하도록 허용(즉, 권한 부여)되어야 합니다. 권한 부여에 대해서는 나중에 다시 다루겠습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리는 고객을 '우리'라고 부르겠습니다.\n\n그래서, Vault는 고객을 어떻게 인증하나요? 사용 가능한 여러 가지 방법이 있습니다. Vault는 이러한 방법을 Auth 방법이라고 부릅니다:\n\n- AppRole\n- OAuth JWT\n- OIDC\n- TLS 인증서\n- 사용자명/암호\n- 클라우드 공급업체 (예: AWS, Azure, Google Cloud)\n- Kubernetes 서비스 계정\n- LDAP\n- 그 외...\n\n고객은 Auth 방법 중 하나를 사용하여 인증하고, 한 번 인증되면 클라이언트 토큰이 제공되어 클라이언트가 수행하려는 작업을 수행할 수 있는지 여부를 결정하는 데 사용됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![HowVaultsecretsenginespathsandmorework](/assets/img/2024-05-17-HowVaultsecretsenginespathsandmorework_2.png)\n\n각 Auth Method는 클라이언트를 인증하는 고유한 방법을 갖고 있습니다. 일부는 사전 공유된 시크릿을 사용하고, 일부는 Vault 내에 저장된 로그인 자격 증명을 사용하며, 일부는 AWS IAM과 같은 타사 서비스를 사용합니다. Kubernetes 내의 서비스 계정을 사용하여 인증하는 것도 가능합니다.\n\n동일한 유형의 여러 Engine을 활성화할 수 있는 것처럼, Auth Method도 마찬가지입니다. 엔진과 마찬가지로, 활성화된 각 Auth Method에는 마운트 지점이 지정되어 UI, CLI 및/또는 API를 통해 참조할 수 있습니다. 기본 이름이 부여되거나 고유한 이름을 정의할 수 있습니다. 모든 Auth Method는 auth/ 경로 아래에 마운트됩니다. 예: auth/`auth method 이름`.\n\n## 정책\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n클라이언트가 비밀에 액세스하는 방법을 알아보기 전에 정책에 대해 이해해야 합니다.\n\n정책은 권한을 부여합니다. 하나 이상의 정책에서 권한을 부여하지 않은 경우 권한이 부여되지 않습니다.\n\n정책을 만들 때, 명령줄을 통해 직접 만들 수도 있지만 파일에 추가한 다음 파일을 로드하는 것이 더 쉽습니다. 정책은 Hashicorp Configuration Language (HCL)로 작성됩니다.\n\n정책은 특정 경로에 부여되는 권한을 정의합니다. 액션을 포함할 수 있는데, 예를 들어 auth/token/lookup-self와 같습니다. 그런 다음 해당 경로에서 허용된 기능이 권한으로 정의됩니다. 기본 정책의 일부는 다음과 같습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```json\n# 자신의 속성을 조회할 수 있는 토큰 허용\npath \"auth/token/lookup-self\" {\n    capabilities = [\"read\"]\n}\n\n# 자신을 갱신할 수 있는 토큰 허용\npath \"auth/token/renew-self\" {\n    capabilities = [\"update\"]\n}\n\n# OIDC 공급자의 인증 엔드포인트로 요청을 보낼 수 있는 토큰 허용\npath \"identity/oidc/provider/+/authorize\" {\n    capabilities = [\"read\", \"update\"]\n}\n```\n\n위와 같이 정책은 여러 경로에 매핑되고 여러 기능을 허용할 수 있음을 알 수 있습니다. 경로 끝에 \\*를 포함하면 해당 경로의 모든 하위 경로에 정책이 적용됩니다. 경로의 leaf를 /+/로 대체하면 해당 leaf의 모든 값을 일치시킵니다. 이는 경로에 ID가 포함된 경우 유용합니다.\n\n권한은 누적되므로 사용자가 여러 정책과 관련이 있는 경우 모든 정책에서 모든 권한을 갖습니다.\n\n그러나 정책들이 함께 수집될 때 두 정책 경로가 겹칠 때, 예를 들어 secrets/\\* 및 secrets/my-secret과 같은 경우, 더 구체적인 경로의 기능이 사용됩니다. 더 정확히는 Hashicorp 문서에 따르면, 우선순위 순서로 두 유사한 경로 p1 및 p2가 주어질 때, p2가 선호되며 다음과 같은 경우 선택됩니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 만약 p1에 \\* 또는 +이 p2보다 왼쪽에 나타나면\n- p1에 \\*가 있고 p2에 없을 경우\n- p1에 +가 p2보다 더 많을 경우\n- p1이 p2보다 짧을 경우\n- 사전에 p2보다 p1이 먼저 나타나야 할 경우\n\n다시 말해, 경로가 더 구체적일수록 선호됩니다.\n\n![image](/assets/img/2024-05-17-HowVaultsecretsenginespathsandmorework_3.png)\n\n기능에는 (그들의 HTTP 동사를 포함하여):\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 생성 [POST/PUT]\n- 조회 [GET]\n- 업데이트 [POST/PUT]\n- 패치 [PATCH]\n- 삭제 [DELETE]\n- 목록 [LIST]\n\nHTTP 동사와 직접적으로 관련이 없는 세 가지 기능이 더 있습니다:\n\n- sudo — root로 보호된 경로에 액세스 허용\n- deny — 다른 기능 및 정책과 관계없이 모든 액세스 거부\n- subscribe — 이벤트 유형에 대한 구독 허용\n\n경로 일치를 통해 보안정책이 Secrets와 다른 리소스와 관련되어 있는 방식을 볼 수 있습니다. 그러나 아직 우리가 보지 않은 것은 보안정책이 요청과 어떻게 연관되어 있는지입니다. 그것을 알아보기 위해선 엔티티와 그룹을 이해해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 문서는 정책의 기본 사항만 다루었습니다. 자세한 내용은 Hashicorp 문서를 참조하십시오.\n\n## 엔티티와 별칭\n\n엔티티는 Vault 내에서 클라이언트를 나타냅니다. 클라이언트는 사람, 애플리케이션 및 시스템으로 나타낼 수 있다는 점을 알아보았습니다. 모두 엔티티로 나타낼 수 있습니다.\n\n특정 엔티티(예: 당신 또는 나)는 여러 Auth 방법(예: 사용자 이름/암호, GitHub 계정 등)을 통해 인증될 수 있습니다. 즉, 각 Auth 방법에서 엔티티를 나타내는 신원이 해당 엔티티에 연결되어야 하는 중요합니다. 이 작업은 Entity Aliases를 통해 수행됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n한 Entity는 0개 이상의 Entity Aliases를 가질 수 있습니다.\n\n![Image](/assets/img/2024-05-17-HowVaultsecretsenginespathsandmorework_4.png)\n\n이전에 Policies에 대해 이야기했습니다. 각 Entity는 하나 이상의 Policies와 관련될 수 있습니다. 클라이언트가 인증하는 방식에 상관없이, 그들은 Entity와 관련된 Policies에 제공된 권한을 받게 됩니다.\n\n우리는 이것이 Policy가 Entity에 연관될 수 있는 유일한 방법이 아니라는 것을 볼 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 그룹 및 별칭\n\nEntity는 유용하지만 액세스 관리가 어려워질 수 있습니다. 왜냐하면 각 Policy를 모든 Entity에 연결해야하기 때문입니다.\n\n대부분의 조직은 팀과 다부서 팀을 사용하여 구조화됩니다. 각 팀은 각자의 책임을 부여받습니다.\n\nVault는 이를 그룹을 사용하여 모델링합니다. 그룹은 임의의 수의 Entity를 보유할 수 있으며 Entity는 임의의 수의 그룹에 속할 수 있습니다. 그룹은 부모-자식 관계로 다른 그룹을 포함 할 수도 있습니다. Entity가 그룹의 일부인 경우 해당 그룹은 직접 그룹으로 알려집니다. 어떤 부모, 할아버지, 증조부모 등도 간접적 그룹으로 알려집니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![image](/assets/img/2024-05-17-HowVaultsecretsenginespathsandmorework_5.png)\n\n이제 그룹은 정책과 연관시킬 수 있습니다. 해당 그룹의 모든 엔티티는 해당 그룹이나 부모, 조부모 그룹의 정책을 받습니다.\n\n이제 엔티티 그룹의 액세스를 한 곳에서 관리할 수 있습니다.\n\n그룹 외에도 Vault는 그룹 별칭의 개념을 지원합니다. 이 별칭은 Active Directory 그룹과 같은 외부 그룹과 관련이 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 토큰\n\n알겠어요. 우리는 Secrets에 대해 이야기했고, Policies가 Secrets의 경로에 따라 연결되는 방법과 Policies가 엔터티 및 그룹과 연결되는 방법에 대해 이야기했어요.\n\n하지만, 우리가 본 적이 없는 것은 제가 Secret에 대한 액세스를 요청할 때 Vault가 제가 필요한 액세스를 가지고 있는지 여부를 어떻게 알 수 있는지 입니다.\n\n이는 토큰을 사용하여 달성됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n토큰은 Vault 내에서 Secrets 및 Auth Methods에 대한 액세스를 관리하는 데 필수적입니다.\n\n클라이언트가 자원(예: 생성, 읽기, 업데이트 및 삭제)을 사용하려면 유효한 토큰을 전달해야 합니다. 토큰을 통해 Vault는 해당 토큰과 관련된 정책 및 따라서 클라이언트의 기능을 결정합니다.\n\n모든 토큰에는 갱신되어야 하는 만료 시간(TTL)이 있습니다. 심지어 토큰 생성 시 최대 TTL이 있을 수 있으며 갱신 중일 때에도 해당됩니다. 이에는 초기화된 Vault에서 생성된 Root Token을 제외합니다.\n\n사용자가 토큰을 생성하도록 요청하면 해당 토큰은 사용자가 인증했을 때 제공된 정책을 상속합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제, 원래 토큰을 사용하여 새로운 토큰을 만드는 경우, 클라이언트는 새로운 토큰과 관련된 정책을 원래 토큰의 하위 집합으로 제한할 수 있습니다. 이를 통해 클라이언트는 '최소 권한' 액세스를 Vault에 요청할 수 있습니다.\n\n토큰은 인증된 클라이언트(개체)를 해당 개체에 연결된 정책과 관련시켜주며, 이러한 것들은 개체가 리소스에 액세스할 수 있는 권한을 제공합니다. 이러한 방식으로 Vault는 클라이언트가 리소스에 수행할 수 있는 권한이 있는지를 결정할 수 있습니다.\n\n예를 들어, 사용자는 사용자 이름과 비밀번호를 사용하여 로그인하고 시크릿을 생성하고 읽는 데 사용할 수 있는 토큰을 받을 수 있지만 업데이트는 할 수 없는 토큰을 받을 수 있습니다.\n\n토큰이 발급될 때 클라이언트에게 부여되는 권한은 다음의 조합입니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 인증에 사용된 토큰들\n- 클라이언트를 대표하는 엔티티에게 주어진 토큰들\n- 엔티티가 직접 속한 그룹의 토큰들\n- 엔티티가 간접적으로 속한 그룹의 토큰들\n\n토큰에는 다음과 같은 속성이 있습니다:\n\n- 선택적인 유효기간 (TTL)\n- 갱신할 수 있는 능력 (또는 그렇지 않을 수도 있음)\n- 취소할 수 있는 능력\n\n토큰을 획득한 후 원본의 자식이 되는 다른 토큰을 얻는 것이 가능합니다. 이는 두 가지 이유로 유용합니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 부모 토큰을 폐기하면 모든 하위 토큰이 재귀적으로 폐기됩니다.\n- 토큰을 요청할 때\n\n토큰에 대한 자세한 내용은 다음 해시코프 문서를 참조하십시오.\n\n## 래핑된 토큰\n\n래핑된 토큰은 일회용 토큰입니다. 클라이언트와의 핸드셰이크에 유용하며 클라이언트에게 원본 토큰을 전달하는 데 사용됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n설명된 방식은 Wrapped Token이 원래 Token을 참조하는 것이라고 합니다.\n\nWrapped Token을 받으면 Vault에 Original Token을 요청하여 얻을 수 있습니다. 이미 언래핑된 경우 오류가 발생하고 위반이 발생했음을 알 수 있습니다. 원본 Token은 취소될 수 있고 새로운 Token을 생성할 수 있습니다.\n\nVault는 임의의 정보를 래핑하는 데 필요한 도구도 제공합니다.\n\n## Roles\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n기본 개념에서 Vault의 기본 개념을 떠날 때 전통적인 보안 세계에서 역할에 대해 얘기할 가치가 있다고 생 생각해요. 역할은 하나 이상의 사용자에게 권한 집합을 적용하는 데 사용됩니다. 이렇게 하면 사용자 그룹의 구성이 더 쉬워지며, 특정 권한 집합을 가져야 하는 사용자는 그 역할을 부여받습니다.\n\n그룹에 연결된 정책은 이와 같은 방식으로 작용합니다. 그룹은 전통적인 역할과 유사하게 볼 수 있으며, 엔티티 그룹을 권한 집합(또는 Vault가 그들을 언급하는 기능)에 연결합니다.\n\n주변을 둘러보면 역할이 Vault와 관련해 다음 두 가지 방법으로 언급된다는 것을 알게 될 거예요:\n\n- 데이터베이스 역할\n- 토큰 역할\n- AppRole 역할\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n데이터베이스 역할: 이러한 역할은 실제로 데이터베이스 엔진과 연관되어 있으며 데이터베이스 내의 역할을 나타냅니다. 즉, 자격 증명이 요청될 때 특정 데이터베이스 역할을 위해 요청할 수 있습니다.\n\n토큰 역할: 토큰 역할을 생성할 수 있으며 이는 일련의 프리셋 또는 토큰의 템플릿으로 작동할 수 있습니다. 한 번 생성되면 지정된 토큰 역할에 기반한 자식 토큰을 생성할 수 있습니다.\n\n앱롤 역할: AppRole 인증 방법을 사용하는 경우 AppRole 역할을 만들 수 있습니다. 이를 통해 응용 프로그램이이 방법으로 인증할 때 수신할 권한 및 기타 특성을 정의할 수 있습니다. AppRole 역할에는 응용 프로그램이 제출해야하는 ID가 부여됩니다. 그런 다음 응용 프로그램이 제출해야하는 비밀 ID를 생성할 수도 있습니다. 이렇게하면 AppRole 역할의 정책과 관련된 토큰을 얻을 수 있습니다.\n\n# 요약\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 기사에서 Vault 뒤에 있는 기본 개념을 소개했어요. 네임스페이스, 마운트 포인트 및 경로를 통해 비밀 및 다른 리소스를 찾는 방법을 살펴봤어요.\n\n또한 엔티티 및 인증 방법이 어떻게 사용되는지, 매칭 경로를 통해 리소스 액세스를 제어하기 위해 관련 정책이 있는 토큰을 생성하는 방법도 살펴봤어요.\n\n이러한 개념을 이해하면 Hashicorp의 제공하는 문서를 더 쉽게 이해할 수 있을 거예요.\n\n이 기사가 흥미로웠다면, 제게 박수를 한 번 부탁드릴게요. 이를 통해 사람들이 유용하게 여기는 것과 앞으로 써야 할 기사에 대한 정보를 얻을 수 있어요. 아이디어가 있으시면 댓글에 추가해주세요.\n","ogImage":{"url":"/assets/img/2024-05-17-HowVaultsecretsenginespathsandmorework_0.png"},"coverImage":"/assets/img/2024-05-17-HowVaultsecretsenginespathsandmorework_0.png","tag":["Tech"],"readingTime":19},{"title":"롱혼Longhorn을 위한 최상의 관례","description":"","date":"2024-05-17 18:24","slug":"2024-05-17-BestPracticesforLonghorn","content":"\n![image](/assets/img/2024-05-17-BestPracticesforLonghorn_0.png)\n\n# 소개\n\nLonghorn은 Rancher에서 설계하고 Kubernetes 클러스터의 Storage Classes를 관리하기 위해 만들어진 오픈 소스 분산 스토리지 시스템입니다.\n\nLonghorn은 웹 UI 및 기타 도구로 설치 및 관리가 쉽게 설계되었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n하지만, 클러스터 관리와 쿠버네티스 작업을 하는 모든 사람들은 대화에서 '쉽다'는 말을 듣기 쉽지 않다는 것을 알고 있습니다.\n\n이 기사에서는 Longhorn과의 여정에서 모은 정보를 제가 아닌 다른 많은 사람들에게 유용할 수 있다고 생각하는 내용을 제공하겠습니다.\n\n# 전제 조건\n\n우선, 문서를 읽어보세요. 왜냐하면...\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n나의 어리석음 속에서, 나는 롱혼(Longhorn)을 다룰 수 있을 것이라고 생각했고, 말 그대로 황소의 뿔을 잡을 수 있을 것으로 생각했다. 내가 한 것처럼 하지 마세요. 스스로를 많은 시간과 고통으로부터 구해주세요. 문서를 읽고 나서, 롱혼의 작동 방식을 근본적으로 이해했기 때문에 문제 해결이 가속화되었어요.\n\n여기 좋은 시작점이 있어요:\n롱혼(Longhorn) - 아키텍처와 개념\n롱혼(Longhorn) - 최선의 방법론\n\n이제 우리는 스스로에게 질문해 봅시다: 우리가 분산 저장 시스템(Distributed Storage System)을 생성하길 원할 때 우리가 찾고 있는 것은 무엇인가요?\n\n그것은 빠른 I/O, 혁신적인 백업 시스템, AI 디버깅 또는 어떤 반짝이는 새로운 기능이 될 수 있지만, 제 경우에는 간단합니다: 안정성과 신뢰성이 모든 분산 저장의 안내등표(Guiding Beacons)가 되어야 한다고 생각해요. 왜냐하면 핵심 데이터 손실은 어떤 클러스터에게든 가장 최악의 일이 일어날 수 있는 것이기 때문이에요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 문맥에서의 안정성은 저장 시스템이 작업 부하나 환경 조건에 관계없이 항상 예상대로 작동하는 것을 의미합니다. 이는 대량의 데이터를 처리하고 고가용성을 지원하며, 무거운 부하나 네트워크 분할 중에도 성능 수준을 유지하는 것을 포함합니다. 안정적인 시스템은 읽기, 쓰기 및 업데이트와 같은 데이터 작업이 예상치 못한 중단이나 실패 없이 발생하도록 보장합니다.\n\n신뢰성은 시스템이 데이터 무결성을 보호하고 필요할 때 언제든지 데이터에 접근할 수 있도록 하는 능력을 말합니다. 이는 강력한 오류 검출 및 수정 메커니즘을 구현하고, 데이터를 여러 노드로 복제하여 데이터 손실을 방지하며, 하드웨어 장애나 기타 문제 발생 시 효과적인 복구 프로세스를 갖는 것을 의미합니다. 신뢰할 수 있는 시스템은 빠르게 데이터를 복원하여 장애가 발생한 경우에 데이터를 빠르게 복원하는 강력한 백업 및 재해 복구 계획을 포함합니다.\n\n그리고 이 두 가지 단어를 떠올리며 분산 저장 시스템에서 안정성과 신뢰성을 실현하는 방법에 대한 통찰을 제공하기 위해 본 문서를 작성하고 있습니다.\n\n# Best Practices\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n좋아요! 이제 문서를 읽어보았고 분산 저장 시스템에서 원하는 것을 알게 되었어요.\n\n시작해볼까요?\n\n이 가이드를 따라하면 Longhorn의 성능, 신뢰성, 그리고 Kubernetes 환경에서의 관리 기능을 최적화할 수 있을 거예요.\n\n# 시작 지점\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 안정적인 빌드만 사용하세요. 더 나아가 최신 빌드를 사용하지 않는 것이 좋습니다. 아직 발견되지 않은 버그가 있을 수 있으니까요.\n- Longhorn을 실행할 때, 네트워크가 바쁜 클러스터 트래픽으로 인해 발생하는 네트워크 중단으로 인해 마운트가 실패하는 시나리오가 발생할 수 있으므로, 전용 스토리지 네트워크에서 실행하는 것을 고려해보세요.\n\n- 전용 스토리지 네트워크의 대안 또는 보완책은 순수 LonghornNodes를 가지는 것입니다. 이는 볼륨만 관리하며 다른 형태의 워크로드를 처리하지 않는 노드를 가지는 것을 의미합니다. 즉, NoSchedule 또는 NoExecute 효과를 적용하여 Longhorn에 전용 노드를 할당하는 것을 의미합니다.\n\n# 노드 구성\n\n- 고가용성을 위해 레플리카가 여러 노드와 가용 영역에 분산되어 있는지 확인하세요.\n- Longhorn 컴포넌트에 해당하는 허용을 추가하여 전용 스토리지 노드에 스케줄되도록 할 수 있습니다.\n- StorageClass가 필요에 따라 풀을 분할해야 하는 경우 노드 태그를 Longhorn에 추가하여 nodeSelector를 통해 해당 노드를 대상으로 할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 저장 구성\n\n- 최적의 디스크 성능을 위해 전용 SATA/NVMe SSD 또는 유사한 성능의 디스크 드라이브를 사용하세요.\n- 노드 간에 10 Gbps 네트워크 대역폭을 보유하도록 하세요.\n- 루트 디스크 대신 Longhorn 저장을 위한 전용 디스크를 사용하세요.\n\n# 레플리카 개수\n\n- 데이터 가용성을 달성하고 디스크 공간 사용량을 더욱 개선하며 시스템 성능에 덜 영향을 미치도록 기본 레플리카 수를 \"2\"로 설정하세요.\n- 더 많은 레플리카는 읽기 집계를 늘리지만, 더 많은 공간과 네트워크 대역폭을 사용합니다.\n- 기본값은 \"3\"이지만 Longhorn 공식 문서에서는 \"2\"라고 명시합니다. 특히 데이터 집약적인 애플리케이션에 매우 유용합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 볼륨 구성\n\n- 볼륨에는 기본 ext4 파일 시스템을 사용하세요.\n- 네트워크가 추가 트래픽을 처리할 수 없을 경우 노드를 불안정하게 만들 수 있으므로 가능하면 ReadWriteMany (RWX) 액세스 모드를 피하십시오. 가능한 경우 볼륨에는 ReadWriteOnce (RWO) 액세스 모드를 사용하세요. RWX와 RWO 사이의 성능 문제는 무시해도 좋습니다.\n- 주기적으로 네트워크 부하로 인해 마운트할 수 없는 RWX 마운트가 있는지 확인하려면 mount | grep 10.43을 사용하세요. 이를 식별하는 데 cron 작업이 설정되어 있습니다(추후 기사에서 자세한 내용을 다룰 예정).\n\n- 모든 노드 사이에 워크로드를 균형 있게 분산하는 것은 어려울 수 있습니다. Replica Node Level Soft Anti Affinity 및 Replica Auto Balance을 확인하여 시작하세요.\n\n- 이것이 도움이 되지 않으면 워크로드를 균형 있게 분산하기 위해 Descheduler를 사용할 수 있습니다. 그러나 Descheduler는 공식 제품이 아니므로 연구를 진행해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 데이터 지역성\n\n- Longhorn StorageClasses의 기본 데이터 지역성으로 최선을 다하십시오. 최선을 다한다는 것은 Longhorn이 첫 번째 복제본을 컨트롤 엔진이 있는 동일한 노드에 배치하려고 시도한다는 것을 의미합니다. 첫 번째 볼륨을 동일한 노드에 배치하면 I/O 및 효율성이 향상될 수 있습니다. 기억해 주십시오. 최선을 다하는 것이 기본 설정이 아닙니다.\n- 데이터 복제를 지원하는 응용 프로그램의 경우 strict-local 옵션을 사용하여 볼륨 당 복제본이 하나만 생성되도록합니다.\n- NodeSelectors 또는 Taints를 사용하여 특정 storage-tagged 노드에 데이터 집중 작업을 스케줄링하십시오.\n\n# 유지 보수 및 업그레이드\n\n- Longhorn 호스트를 다시 부팅할 때, 동일한 노드의 복제본 중 하나를 의도적으로 삭제하여 다시 구축 프로세스를 트리거하고 복제본을 노드 간에 균형 있게 배치합니다.\n- 라이브 볼륨과 관련된 문제를 피하려면 Longhorn을 업그레이드하기 전에 볼륨을 분리하는 것이 항상 바람직합니다.\n- 안정적이고 지원되는 버전으로만 업그레이드하십시오.\n- 일정한 간격으로 Longhorn UI에서 손상된 마운트를 확인하십시오. 건강한 복제본 수만큼 복제본 수를 업데이트하고 다시 정상 복제본 수로 업데이트하십시오.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 스냅숏 및 백업\n\n- 필요한 만큼만 유지하면서 주기적으로 시스템에서 생성한 스냅숏을 정리하십시오.\n- 복제 기능이 있는 애플리케이션의 경우 정기적으로 모든 유형의 스냅숏을 삭제하십시오.\n- 중요한 애플리케이션 볼륨을 위한 반복 백업 작업을 생성하십시오.\n- 주기적인 시스템 백업을 실행하십시오.\n\n# 출처\n\nDevOps 이야기 LONGHORN: Best Practices — r/kubernetes Longhorn — Best Practices Rancher 포럼: Longhorn 재부팅시 Best Practice Harvester: Longhorn 디스크 성능 최적화를 위한 Best Practices Descheduling: 고가용성의 비밀\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 끝맺음\n\n본 작업은 다른 사람들의 경험과 제 경험의 결합물입니다. 이 글을 함께 만들어준 분들에게 감사를 표합니다. 또한, 저는 Longhorn 전문가가 아니므로 궁극적으로는 여러분들이 직접 조사해 보시기 바랍니다.\n\n행운을 빕니다!\n","ogImage":{"url":"/assets/img/2024-05-17-BestPracticesforLonghorn_0.png"},"coverImage":"/assets/img/2024-05-17-BestPracticesforLonghorn_0.png","tag":["Tech"],"readingTime":8},{"title":"KubeCon EU 2024 파리 주요 포인트들","description":"","date":"2024-05-17 18:20","slug":"2024-05-17-KubeConEU2024ParisKeyTakeaways","content":"\n## 회의 요약\n\n최근 파리, 프랑스에서 열린 쿠베콘 유럽 행사에 다녀온 후에 다시 여행에 대해 생각하게 되었습니다. 행사에서 주요 강연과 세션들로부터 많은 것을 배우고, 플랫폼 엔지니어링에 대한 강조와 커뮤니티에서 많은 흥미로운 사람들을 만났습니다. 12,000명 이상의 참가자들과 100여 개의 후원사들이 참석하여, 이전보다 더 붐볐습니다.\n\n다음은 쿠베콘 유럽 2024에 대한 내 주요 포인트들입니다:\n\n- 나는 우리의 새로운(클라우드 기반) AI 지배자들을 환영합니다.\n- 책임있는 혁신에 대한 요구, 즉 \"비용과 지속 가능성을 잊지 말자\"\n- 플랫폼 엔지니어링이 중심에 서 있습니다.\n- 제품 사고가 이깁니다!\n- 개발자 경험 및 내부 및 외부 개발 루프에 대한 더 많은 관심\n- 보안은 여전히 큰 사업입니다.\n- 최종 사용자 이야기가 위로 올라갑니다.\n- 도구와 프레임워크 번들링이 계속됩니다.\n- Wasm: 핫한 주제, 그러나 불확실성이 있습니다.\n- Dapr가 점점 클라우드 네이티브 ESB로 자리 잡고 있습니다(좋은 방법으로)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이러한 주요 사항을 자세히 살펴보겠습니다. 기사 맨 끝에는 보너스 \"KubeCon EU를 위한 GTM 주요 사항\" 섹션도 포함되어 있어요. 프랑스어로 말하자면, allons-y!\n\n![KubeConEU](/assets/img/2024-05-17-KubeConEU2024ParisKeyTakeaways_0.png)\n\n# 나는 새로운 (클라우드 기반의) AI 지배자들을 환영합니다\n\n작년 12월 KubeCon NA Chicago에서 AI/LMM 콘텐츠의 부족에 놀라신 분들이 많았습니다. 그런데 KubeCon EU Paris에서는 이를 보완해줬어요... 그리고 더 더해졌습니다! 오프닝 데이 키노트 중 거의 모두가 AI에 초점을 맞춘 내용이었고(AI에 대한 조급한 마음까지!), 한 주 내내 전적으로 AI에 초점을 맞춘 AI 랩도 있었으며 다양한 각도에서 AI/LLM에 집중한 분과 세션이 많았습니다. 또한 클라우드 네이티브 트렌드와 \"AI\", \"LLM\", 또는 \"Generative\"이라는 단어가 섞인 스폰서 부스를 보는 것조차 무한했을 정도에요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n농담은 물론, 나는 CNCF 생태계가 AI에 대해 매우 열려 있다는 메시지를 주로 받았어. 행사 전체에서 본 사용자 이야기들은 주로 모델 훈련이 아니라 추론에 대해 클라우드 네이티브 기술을 사용하는 데 초점을 맞췄어; 특히 엣지 근처의 추론. 이는 이전에 클레이튼 콜먼이 한 말을 반영하고 있었어: \"만약 추론이 새로운 웹 앱이라면, 쿠버네티스는 새로운 웹 서버야.\" 주요 무대와 후원사 홀에서 보여진 K8s 기반 AI 빌더들을 위한 관련 \"도구\"들도 풍부했어.\n\n오프닝 첫날 두 번째 주요 연설로 NVIDIA가 \"Kubernetes에서 GPU로 AI 워크로드 가속화\"를 주제로 성공적으로 등장한 것이 정말 흥미로웠어. 그들이 쿠버네티스 이야기를 잘 얽었지만, 이것은 주로 하드웨어/인프라스트럭처 플레이일 것 같았는데, 이는 이 대중에 조금 불편하게 느껴졌을지도 모르겠어. 또한 NVIDIA가 GPU와 AI 칩 분야에서 현재 주도적인 위치를 차지하고 있다는 것을 강하게 상기시켜 주었어.\n\n관련 주제로, 주말에 All-in 팟캐스트를 듣다가, 베타들이 AI 스택의 네 가지 계층 중 어디에서 혁신과 가치 창출이 발생할지 의문을 제기했어: 인프라스트럭처, (기초) 모델, 개발 도구, 애플리케이션. 만약 NVIDIA가 인프라스트럭처 계층을 확보했다면, 우리의 다음 주요 연설은 모델 및 개발 도구 계층을 확보하려는 다른 회사를 강조했어: Microsoft.\n\n우리가 나중에 다룰 주제를 시작으로, Microsoft가 행사에서 첫 번째로 \"Kubernetes AI Toolchain Operator (Kaito)\"라는 AI 주제의 \"번들\"을 발표했어. Kaito는 Kubernetes 클러스터에서 AI/ML 추론 모델 배포를 자동화하고 falcon 및 llama2와 같은 모델을 대상으로 하고 있어.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이어서, Ollama는 프로그램에서 많이 소개되었고, 대형 언어 모델을 로컬에서 실행하는 사실상의 방법으로 보였습니다. 우리가 파리에 있었기 때문에 Mistral AI 팀도 칭찬을 받았어요. KubeCon에 참석하지 못했다 하더라도 AI 주제의 몇 가지 모임이 근처에서 열렸어요:\n\nAI 분야에서 혁신이 빠른 속도로 일어나고 있음을 부정할 수 없어요. 후원사 홀에서 이야기를 나눈 많은 최종 사용자들은 발전에 발맞추기 위해 노력하고 있었어요. 리더십이 AI를 수용하도록 장려했지만, 그들은 소규모 실험만을 실행하고 관련 발전과 따라가려 애를 쓰고 있었어요.\n\n이 점을 더 확실하게 보여주기 위해, 회의가 진행되는 동안 나의 X/Twitter 뉴스피드에는 지금까지 언급된 두 회사의 더 많은 발전상황이 소개되었어요. 지난 주 NVIDIA의 Blackwell 칩 및 Microsoft의 AI 분야 최근 인재 영입에 대해 더 알고 싶다면, Ed Sim의 뉴스레터를 확인해보세요.\n\n키노트와 3일간의 부스 대화에서 떠날 때, AI 미래가 드디어 KubeCon에 왔다는 생각을 하지 않을 수 없었어요 — 그러나 소문처럼 고르게 퍼져 있지 않다는 게 분명해요; 특히 최종 사용자들 사이에서 그렇습니다. 이제 클라우드 네이티브 군중이 다음 세대의 AI 앱을 개발하기 시작할 때인 것은 분명해요. 그리고 저는 우리의 새로운(클라우드 기반) AI 지배자를 환영합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 비용과 지속 가능성을 잊지 말아 담당하는 혁신을 요청합니다.\n\nAI에 대한 다양한 언급과 함께, 오프닝 키노트에서는 \"책임있는 혁신\"을 촉구했습니다. 이 구문은 전시회 전체에서 여러 차례 사용되었습니다. 맥락을 고려하면 \"혁신을 지속하되 오픈 소스를 활용하고 비용 및 에너지 절감을 염두에 두어야 한다\"는 의미로 받아들였습니다.\n\nCNCF가 이벤트를 주최하고 있기 때문에 OSS를 수용하고, 이상적으로는 CNCF 생태계에서 기술을 활용하라는 명백한 요구가 있었습니다. Redis가 같은 날 오프닝 키노트에서 이중 라이선스로 전환한다고 발표함으로써 청중에 불편함을 느낀 장면이 있었는데, 이는 최근의 이러한 변경 사항을 모두 생각나게 했습니다.\n\nCNCF가 지속 가능성에 대한 일부 어려움을 인정하는 것을 볼 수 있어서 좋았습니다. 세 번째 날의 키노트에서 Gualter Barbas Baptista가 독일 철도에서의 실제(기업) 사례인 \"IT 그린 구축: Deutsche Bahn에서의 플랫폼, 데이터 및 개발자 권한 부여의 여정\"에 지속 가능성을 요구했습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 주제는 중요합니다. 키노트 시간을 충분히 할애하는 것을 보아 좋았어요.\n\n# 플랫폼 엔지니어링이 중심 무대에 서다\n\n2022년 KubeCon EU에서 몇 명이 \"플랫폼 엔지니어링\"의 신흥 트렌드에 대해 이야기했습니다. 2024년에는 플랫폼 엔지니어링이 주류로 자리 잡았습니다.\n\n스폰서 쇼케이스는 플랫폼, 플랫폼 엔지니어링, 개발자 경험에 대한 언급으로 넘쳤으며, Solomon Hykes인 Dagger와 Docker의 공동 창시자가 진행한 훌륭한 키노트 세션도 있었습니다. \"10년의 변곡점: 컨테이너화된 세계에서 애플리케이션 전달의 미래\" (말하자면, 최근 InfoQ 팟캐스트에서 Solomon과 이야기를 나누었는데, Dagger에 대해 많이 배웠어요!)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n인프라스트럭처 레이어 도구 및 프레임워크인 Kubernetes, 서비스 메쉬, 게이트웨이, CI/CD 등이 잘 발전하여 대부분의 사람들에게는 \"지루한 기술\"로 여겨집니다 (적어도 이들에게는 그렇습니다). 지금 큰 도전은 퍼즐 조각들을 조합하여 내부 고객인 개발자들에게 가치를 전달하는 것입니다. 위 트윗에 댓글로 역동적으로 관찰한 Betty Junod는 \"우리는 그 시대의 모든 PaaS를 해체했고... 모든 개별 레고로 놀아보았으며... 새로운 레고도 얻었고... 이제 그것들을 다시 조립하려고 노력하고 있다\"고 언급했습니다.\n\n최근 Syntasso 블로그에서 플랫폼 구축 레이어에 대한 내 정신적 모델을 논의했습니다. 애플리케이션 코레오그래피, 플랫폼 오케스트레이션 및 인프라스트럭처 구성이라는 세 가지 레이어 중에서, 애플리케이션 (포털) 레이어에 과도하게 집중하는 위험이 있다고 봅니다.\n\n마치 사람들이 AI 레이어에서 가치 창출 및 확보가 어디에서 일어날지에 대해 논쟁하는 것처럼, 플랫폼 공간 레이어에서도 같은 경향이 보인다고 생각합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n인프라스트럭처 레이어는 이윤이 많이 나오는 것으로 보이지만, 주로 후발주자들이 참여하는 영역입니다. 최근 Adam Jacob이 언급한 바에 따르면, OpenShift는 연간 매출이 10억 달러 이상을 올립니다. 그러나 동시에 HashiCorp와 Terraform에 대한 시장에서의 어려움을 볼 수 있습니다 (관련해서 OpenTOFU가 행사에서 많은 관심을 받았습니다).\n\n많은 기업이 내부 개발자 포털을 통해 애플리케이션 코레오그래피 레이어의 도구 및 프레임워크를 홍보하고 있습니다. Backstage, Port, Cortex 등과 같은 워크로드 사양 언어(Score, Radius) 등도 활발히 활용되고 있습니다.\n\n제 친구 Abby Bangser와 Whitney Lee는 플랫폼 사용자 경험에 관한 훌륭한 강연을 발표했습니다: \"가끔 돼지에게 필요한 건 립스틱일 수도 있어요!\"\n\n![이미지](/assets/img/2024-05-17-KubeConEU2024ParisKeyTakeaways_2.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n애플리케이션 코레오그래피 레이어에서는 명확한 가치가 창출될 수 있습니다. 그러나 이번 KubeCon에서 Backstage에 대해 최고와 최악의 순간이 겹쳐보였어요. Backstage 커뮤니티가 여러 훌륭한 세션을 제공했고, 분명히 많은 역동성이 있었습니다 (CNCF 최종 사용자에게 가장 많은 기여를 한 프로젝트였습니다). 그러나 채택자들로부터 \"외부에서 제공되는\" 기능 부재와 포털을 운영하고 유지하기 위해 필요한 노력에 대한 불평이 많았습니다.\n\n이 애플리케이션 레이어는 일컬어 말하는 \"[개발자]의 손에 [플랫폼]의 길이 만난다\" 곳이며, 아마도 개발자 경험이 여기서 제작됩니다. 그러나 제 소프트웨어 아키텍처 경험에 근거하여, 제는 올바른 추상화를 생성하는 찬성자이며, 포털은 플랫폼의 목표를 실현하기에는 필수적이지만 충분하지는 않다고 생각합니다. 플랫폼 오케스트레이션 레이어는 내년에 많은 혁신이 일어날 것으로 보입니다. 저는 현재 오픈 소스 Kratix 플랫폼 오케스트레이터를 구축 중인 Syntasso 팀과 조금 편향되어 있는 것 같습니다만, Humanitec, Upbound (Crossplane), Massdriver, Mia-Platform, Qovery 등 다른 많은 회사들도 이 공간에 투자하고 있습니다.\n\n플랫폼 구축 공간의 상대적으로 미숙함을 상기시키기 위해, 가장 많은 관람자가 참여한 내용 중 일부는 클라우드 네이티브 앱을 제공하는 기본원리에 중점을 둔 것이었습니다. 예를 들어, Adrian Mouat은 \"현대적인 방식으로 컨테이너 이미지 빌드하기\"를 가득 찬 키노트 룸에 제시했습니다. Docker 부스는 Docker Build Cloud에 중점을 두고 있었고, Docker 관련 인사들이 1년 만에 행사에 돌아온 것을 보는 것이 좋았습니다. 그리고 많은 101-레벨 세션이 가득 차서 서 있었습니다.\n\n마지막으로, AI가 플랫폼 엔지니어링에 큰 영향을 미치는 것 같지는 않았어요! 대부분 애플리케이션, 플랫폼 및 인프라 구성 요소를 오케스트레이팅하고 라이프사이클을 관리하기 때문에, \"AI ROI\"는 다른 곳에서 더 높아 보입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 제품 사고 FTW!\n\n이전에 이야기한 내용과 밀접하게 관련된 주제로, 이번 KubeCon에서는 플랫폼, 프레임워크 및 개발자 도구에 \"제품 사고\"가 훨씬 더 적용되는 것을 보았어요.\n\n저는 Platfom Engineering Day에서 함께하는 이벤트와 Spotify의 Samantha Coffman이 하는 \"제품 사고를 통한 개발자 플랫폼 팀의 지원 강화\"라는 발표를 정말 즐겼어요. 다른 몇몇 플랫폼 개발자들도 이 발표가 제일 좋았다고 했어요. 물론, 우리 모두가 Spotify가 될 수는 없겠지만, Samantha은 매우 유용한 사고 모델을 제시하고 Marty Cagan의 우수한 작업에 강한 참조를 했어요(가치, 생존 가능성, 실행 가능성, 사용 가능성과 같은 네 가지 큰 위험에 대해서).\n\nNatWest의 Chris Plank가 하는 발표 \"혁신 발휘: NatWest Bank가 클라우드 네이티브 도구를 활용하여 제품으로서의 플랫폼 제공\"도 저에게 큰 인상을 주었어요. Chris는 규제가 엄격한 환경에서 플랫폼을 전개하기 위한 도전을 잘 소개하고, 이러한 장애물을 극복하기 위해 제품 사고와 기관 간 협력을 적용하는 이점을 제시했어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n관련해서, Aviatrix의 Mitch Connors가 \"Product Market Misfit: Adventures in User Empathy\"를 발표했어요. 제 친구이자 전 동료인 Open Credo의 Nicki Watt도 \"To K8S and Beyond — Maturing Your Platform Engineering Initiative\"를 발표했는데, CNCF App Delivery TAG의 Platform Maturity Model에 대한 유용한 안내와 제품에 대한 생각의 적절한 조화를 제공해 주었어요.\n\n만약 KubeCon의 미래가 플랫폼 모양이라면, 제품 중심으로도 지속됐으면 좋겠어요!\n\n# 개발자 경험 및 내부, 외부 개발자 루프에 대한 더 큰 관심\n\n저는 당연히 주관을 가지고 있지만, 부속으로 이루어진 App Developer Con에서 발표한 \"Testing Cloud Apps: Mocks vs. Service Virtualization vs. Remote Tools\" (아직 비디오는 없어요!) 를 보았어요. 그러나 행사 전체에서 개발자 경험 및 내부, 외부 개발자 루프에 집중하는 중요성에 대한 언급이 많이 있었어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![KubeConEU2024ParisKeyTakeaways](/assets/img/2024-05-17-KubeConEU2024ParisKeyTakeaways_3.png)\n\n안녕하세요! 제 친구 AtomicJar(이제는 Docker)와 Diagrid의 Oleg Šelajev, Alice Gibbons은 \"간단화된 내부 및 외부 클라우드 네이티브 개발 루프\"를 발표했어요. 그리고 멋진 분들인 GitPod 팀에서 클라우드 개발 환경 (CDEs)에 대한 이야기를 많이 들었어요. 또한 CDE 분야의 새로운 흥미로운 소식을 Daytona팀에서 들었죠.\n\n행사에서 고위 리더들과 이야기할 때, 모두 개발자 경험의 가치를 알고 있지만 그것을 리더십에 \"팔기\"에 어려움을 겪는다는 이야기를 자주 들었어요 (특히 후기 ZIRP 시대에서). 일반적인 의견은 DORA/SPACE 지표에 초점을 맞추고 조직간의 협업을 통해 도움을 받을 수 있다는 거예요. 이전에 SNS에서 공유했듯이 Abi Noda와 함께 DX Engineering Enablement 팟캐스트 몇 에피소드를 듣는 것은 언제나 좋은 선택이라는 걸 상기시켜 드립니다.\n\n# 보안은 여전히 중요한 비즈니스입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n키노트는 상대적으로 보안에 대해 가볍게 다뤄졌지만, 세션과 후원 쇼케이스는 분명히 다르더군요. \"보안\"이라는 용어로 세션 카탈로그를 싹 훑어보면 수십 개의 이야기가 나옵니다. 안전한 공급망부터 네트워크 침입 및 플랫폼 보안까지 다양한 주제가 잘 다뤄졌어요.\n\n특정 세션들은 보안 구현 및 도구에 명확한 초점을 맞추며, Kyverno, Falco 및 OPA가 쇼를 훔쳤습니다. 안전한 공급망은 컨테이너 빌드 도구(SBOMS 및 SLSA와 함께), Keptn, Harbor 등을 자세히 다뤘죠. 또한 네트워크 보안에 많은 주목이 갔는데, Cilium(및 이 문맥에서의 eBPF에 대한 흥미로운 언급), Linkerd(Cloudflare의 Pingora에 대한 의문이 있는 상태), Istio가 언급되었습니다.\n\n# 종단 사용자 이야기가 업계에서 주목받고 있어요\n\n한번 더 강조하면, 프로그램에 참여한 종단 사용자 키노트와 세션을 보는 것이 좋았습니다. 이러한 세션 중 많은 것들이 \"업계에서 주목받고 있어요\"는 방향으로 이동하고 있었습니다. 그들이 Kubernetes(또는 다른 CNCF 기술)를 도입한 방법을 소개하는 대신에, 확장, 지속가능성, 비용 절감, 또는 개발자 생산성 향상과 같은 메시지를 주로 다뤘어요. 앞서 언급한 Deutsche Bahn의 지속가능성에 대한 키노트는 이를 잘 보여주는 좋은 예시였습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저는 닉 루티글리아노와 다니엘 드 레프렌티뇨가 진행한 “How Spotify Re-Created Our Entire Backend Without Skipping a Beat”라는 Spotify 토크도 즐겁게 감상했어요. 이 토크는 제품 사고를 사용하여 제품화되고 유지되는 K8s 기반 환경에 대해 다뤘죠. 이 분야에서 다른 좋은 토크들로는 다음과 같은 것들이 있어요:\n\n- 노르웨이 공공 부문 플랫폼 성숙도 현황\n- 레고 그룹의 제조용 플랫폼 엔지니어링 접근 방식: 기본 블록 유지하기\n- 인투잇의 서비스 메시 확장: 300개 이상 클러스터를 넘어서는 셀프 서비스\n- 블랙록의 KEDA를 사용해 몇 년 동안 수백만 달러를 절약하는 법\n- TikTok의 Edge Symphony: 멀티 클러스터 컨트롤러로 범위를 넓히는 방법\n\n# 도구 번들링이 계속됩니다\n\n이전 KubeCon 요약에서 본 것처럼, 도구와 프레임워크의 번들링이 계속되었습니다. 몇 가지 예외를 제외하고는, 공급업체들이 “클래스 최고의 솔루션”이 되려고 싸우던 시절은 사라졌어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nCould you please change the table tag to Markdown format?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n흥미를 끌기 위해, 제 플랫폼 엔지니어링에 초점을 맞춘 친구들과 얘기를 나눠본 결과, 여전히 Wasm에 대한 \"핵심 사용 사례\"를 찾고 있었어요. 이야기에 따르면 컨테이너 기반 및 서버리스 앱의 조합이 필요한 세분화와 리소스 사용 제어를 제공했습니다. 그들은 사무실로 돌아가서 AI 도구에 대해 더욱 탐구하고 싶어했습니다.\n\n일반적으로 Wasm에 대해 긍정적입니다. 예전에 프록시와 API 게이트웨이 작업을 많이 해왔기 때문에 항상 Lua와 같은 것을 대체할 수 있는 Wasm의 플러그인 사용 사례를 볼 수 있었습니다. 하지만 미래에는 기조 발표 시간 대신 뒷장에서 더 많은 사용 사례를 보게 될 지 궁금합니다.\n\n# Dapr는 클라우드 네이티브 ESB(좋은 방식으로)입니다\n\nDapr 프로젝트에 대해 오랫동안 긍정적이었던 것은 비밀이 아닙니다. 이 프레임워크는 10년 전 초기 클라우드 네이티브 앱을 개발할 때 접근할 수 있었으면 좋았을 것이라고 생각했습니다. 이번 이벤트 중에서도 기술에 관한 많은 언급을 볼 수 있어 기쁘었고, 예상치 못한 세션에서도 잘 통합된 것과 관련한 집중이 자주 있었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n평소처럼, Diagrid의 Bilgin, Mauricio 및 Mark와 흥미로운 토론을 나눴어요. 개발자 패턴, 클라우드 네이티브 응용 프로그램 미들웨어의 미래, 그리고 \"서버리스 시대 이후의 클라우드 컴퓨팅: 현재 트렌드 및 이상\"에 대해 이야기했죠.\n\n여러 명이 Dapr을 옛날 스타일의 엔터프라이즈 서비스 버스에서 언급할 때 웃음을 자아내며, Dapr을 \"클라우드 세대용 ESB\" 또는 \"그렇게 되어야 했던 ESB\"로 프레임하고 있었어요. 전 엔터프라이즈 자바 개발자로 일할 때 여러 ESB를 다뤘던 경험이 있어서 이 소리들을 들으면서 웃음과 고개를 끄덕였죠! 희망히, 새로운 세대의 개발자들은 우리가 ESB에 대해 했던 장난을 기억하지 않았으면 좋겠어요.\n\n# 보너스: KubeCon EU를 위한 GTM 요약\n\n이번에 제 일상 업무에서 여러 개발자 도구 회사들에게 Go-To-Market, 제품 마케팅 및 개발자 관계에 대한 조언을 제공하고 있어요. 그래서 한두 문단을 공유하고 싶어요. 후원사 쇼케이스를 둘러보면 현재 핫하고 판매 가능한 트렌드를 몇 가지 알 수 있었죠.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- AI 기반의 모든 것\n- 플랫폼 엔지니어링\n- 보안\n- 관찰 가능성\n- 비용 절감 (또한 흥미로운 것은 \"FinOps\" 라벨이 일관되게 적용되지 않았다.)\n\n나는 이번에 쿠베콘 정기 참가자 중에 부스를 운영하지 않는 사람들이 여러 명 있다는 것도 처음 알게 되었다, 특히 VC 지원을 받은 A/B 시리즈 펀딩 공간에 속한 사람들 중. 창립자와 GTM 직원들과 이야기를 나누면서 비용 절감, EU 시장을 대상으로 지향하지 않음, 그리고 이전 쿠베콘에서의 부스 스캔이 $$$/€€€로 전환되지 않았다는 이유로 그들의 ICP(즉, 이전 쿠베콘의 부스 스캔이 돈으로 전환이 되지 않았다는 것)의 리드 품질이 낮다고 믿는 것을 발견했다.\n\n이는 소소한 예기지만, 나는 또한 이번 이벤트에서 훨씬 더 많은 영업 사원들을 발견했다. 내가 커리어 초반(2000년대 후반의 Java 공간)에 컨퍼런스에 참석하기 시작했을 때, 스폰서 쇼케이스에서 과도하게 열정적인 영업 사원들에게 접근당하는 것은 완전히 정상적이었다. 이것은 소프트웨어 툴링이 제품 중심으로 발전하고 구매력이 개발자로 변하며 개발자 관련 역할이 나타남에 따라 서서히 변화했다(Stephen O'Grady의 \"The New Kingmakers: How Developers Conquered the World\" 참조).\n\n쿠베콘 부스는 역사적으로 개발자 관계, 기술적인 Go-To-Market, 그리고 창립자들이 중심에 있었다. 이들은 여기에도 있었지만, 나는 부스에서 만남에서 만남으로 걸어갈 때 말할 것을 찾는 영업 사원들에게 비유적으로 (가끔은 실제로도) 당한 것을 발견했다. 한 영업 사원은 나가 바쁘다고 대답하고 영업 설명에 관심이 없다고 답했을 때 거의 적대적이었는데, 그 정도로 나는 내 대답을 확인하고 입맛을 감췄다(그는 몇 가지 근거 없는 공격으로 나를 완전히 당황하게 했지만, 행동 규범은 양쪽 모두에게 적용된다!)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n시간이 까다롭고 영업 목표가 어려울 수 있다는 것을 알지만, 대상 체르의 문화를 이해해야 합니다. KubeCon 스폰서 홀에서 강하게 팔아넣는 것은 효과적이지 않다고 생각해요.\n\n저는 개인적으로 Shomik Ghosh의 Software Snack Bites 팟캐스트에서 처음 알게 된 기술 SDR 역할에 대해 열정을 가지고 있어요. 또한 개발자 관계자들이 제품 중심 역할에 더 많이 눈길을 띄게 될 것이라고 믿어요. 이에 대해 더 자세히 썼으니 링크를 참조해주세요:\n\n# 마무리: 커뮤니티, 커뮤니티, 커뮤니티!\n\nKubeCon을 포함한 모든 행사에서 이벤트를 더 포괄적으로 만들기 위해 커뮤니티의 노력에 감명을 받았어요. 저는 중요한 강연 및 다른 세션에 수어 통역자를 확보한 청각장애 및 장애인 작업 그룹에 박수를 보내요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n니키타 라그나스와 아파르나 수브라마니안이 행사를 공동 주최한 데에서 훌륭한 일을 해냈어요. 또한, 처음으로 행사 공동 주최한 클라우드 네이티브 친구 카스퍼 보그 니센에게도 큰 박수를 보냅니다! 포용에 관한 주제를 더 깊이 다루기 위해, 카스퍼는 클라우드 네이티브 커뮤니티의 포용적 성장의 10년을 주제로 한 주요 토론 패널 \"다양성 속의 통일: 클라우드 네이티브 커뮤니티의 포용적 성장\"을 주관했어요.\n\n나는 KubeCon EU에서 보낸 시간을 철저히 즐겼어요. 커뮤니티 여러분과 많은 소통을 나눌 수 있어 정말 좋았고, O'Reilly 부스에서 \"API 아키텍처 마스터링\" 책 서명 행사를 열면서 즐거운 시간을 보냈어요. 또한, PlatEngDay의 공동 주최자인 Syntasso 크루와 같이 현재 함께 일하고 있는 분들과 시간을 보낸 건 정말 즐거웠어요. 이 협력 행사의 다음 단계가 기대돼요!\n\n아직 모든 배운 것을 정리 중이라 놓친 중요한 주제나 주요 인물 언급이 있었다면 알려주세요!\n\n만나지 못한 분들과 만날 기회가 없었다면 소셜 미디어나 평소의 연락처로 연락해주세요. 11월에 솔트레이크시티에서 만나요!\n","ogImage":{"url":"/assets/img/2024-05-17-KubeConEU2024ParisKeyTakeaways_0.png"},"coverImage":"/assets/img/2024-05-17-KubeConEU2024ParisKeyTakeaways_0.png","tag":["Tech"],"readingTime":17},{"title":"DevOps 엔지니어로 빛날 5가지 간단하면서도 강력한 전략","description":"","date":"2024-05-17 18:18","slug":"2024-05-17-5simpleyetpowerfulstrategiestoshinebrightasaDevOpsengineer","content":"\n안녕하세요, 미래의 데브옵스 엔지니어 여러분!\n\n데브옵스 여정에 착수하셨군요! 이것은 단순히 도구와 프로세스를 숙달하는 것 이상의 의미가 있습니다.\n\n데브옵스에서 빛을 발하는 것은 기민성, 협력, 지속적 개선이 필요한 환경에서 돋보일 수 있는 능력을 의미합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n경험丰富한 데브옵스 엔지니어로서, 저는 여러분을 도우기 위해 다섯 가지 간단하지만 강력한 전략을 공유하려고 해요. 이 전략은 여러분을 돋보이게 하는 데에 도움이 되는 것뿐만 아니라 데브옵스 역량을 한 단계 높여줄 거예요.\n\n# 1. 지속적인 개선을 위한 지속적인 학습\n\n데브옵스는 끊임없이 발전하고 있기 때문에, 굳어버림은 적의요.\n\n지속적인 학습의 마인드를 가지세요. 최신 도구, 방법론 및 산업의 최고 관행에 대해 최신 정보를 유지하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n웨비나에 참석하고, 온라인 강좌를 수강하며, DevOps 커뮤니티에 적극적으로 참여하세요. 배울수록 팀에 더 큰 가치를 제공할 수 있습니다.\n\n# 2. 모든 것을 자동화하세요. 단, 전략적으로\n\n자동화는 DevOps의 핵심이지만 무모한 스크립팅과는 다릅니다.\n\n자동화가 실질적인 영향을 미칠 수 있는 영역을 전략적으로 선택하세요. Jenkins, Ansible 또는 GitLab CI와 같은 도구들을 숙달하여 반복적인 작업을 간소화하고, 더 복잡한 도전에 집중할 수 있도록 해보세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n효율적인 자동화는 단순히 시간을 절약하는 것뿐만이 아니라, DevOps 파이프라인 전반의 효율성을 향상시키는 것이 중요합니다.\n\n# 3. 핵심 원칙으로서의 보안\n\n보안은 나중에 고려해야 할 사항이 아니라, DevOps의 기본적인 요소입니다.\n\n프로젝트의 시작부터 보안을 중요시하십시오. 코드, 컨테이너 및 인프라를 안전하게 유지하기 위한 모범 사례를 이해하고 실행하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n안전하고 견고한 시스템을 구축하는 의지를 과시하세요. 데브옵스의 세계에서 강력한 보안 포지션은 영예의 표입니다.\n\n## 4. 지속적인 개선 문화를 육성하세요\n\n데브옵스는 도구와 프로세스뿐만이 아니라 문화적 전환입니다. 팀 내에서 지속적인 개선 문화를 육성해보세요.\n\n정기적인 회고를 추진하고 피드백을 수집하며 프로세스를 개선해보세요. 카이젠(Kaizen)의 마인드를 수용하세요 - 지속적인 개선을 추구하는 태도입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이는 당신의 데브옵스 관행의 효율성을 향상시키는 것뿐만 아니라 뛰어난 결과물을 전달하기 위한 당신의 헌신을 보여줍니다.\n\n## 5. 다양한 팀과의 효과적인 협업\n\n데브옵스는 협업에 중점을 두고 있습니다. 개발과 운영 팀 간의 간극을 좁히기 위해 강력한 커뮤니케이션과 협업 기술을 개발하세요.\n\n복잡한 기술적 개념을 간단한 용어로 설명할 수 있다면 이는 귀한 자산입니다. 팀원들과 적극 소통하고, 그들의 관점을 이해하며 통합된 목표를 향해 노력하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n협업에서 능숙한 데브옵스 엔지니어는 가치 있는 팀원입니다.\n\n# 실행 가능한 전략\n\n- 매주 학습과 탐험을 위한 전용 시간을 확보하세요.\n- 업무 흐름에서 반복되는 작업을 식별하고 점진적으로 자동화를 시작하세요.\n- 프로젝트의 보안 평가를 정기적으로 실시하고 피드백을 요청하세요.\n- 팀 회의에 적극적으로 참여하고 인사이트를 공유하며 개방적인 소통을 장려하세요.\n- 프로세스 개선에 대한 토론을 시작하고 팀으로 작은 성취를 축하하세요.\n\n# 마무리 생각\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nDevOps 엔지니어로 미래를 염두에 두려면 기술 능력, 협업 능력, 지속적인 개선에 대한 헌신이 결합된 조합이 필요합니다.\n\n이러한 전략들을 일상적인 실천에 적용함으로써, 여러분은 단순히 자신의 역할에서 뛰어나는 것뿐만 아니라 다양한 DevOps 커뮤니티에 기여할 수 있을 것입니다.\n\n여정이 목적만큼 중요하다는 것을 기억하세요. 즐거운 코딩과 협업되는 시간 보내세요!\n","ogImage":{"url":"/assets/img/2024-05-17-5simpleyetpowerfulstrategiestoshinebrightasaDevOpsengineer_0.png"},"coverImage":"/assets/img/2024-05-17-5simpleyetpowerfulstrategiestoshinebrightasaDevOpsengineer_0.png","tag":["Tech"],"readingTime":4},{"title":"우리의 오픈 데이터 플랫폼으로의 변혁 여정","description":"","date":"2024-05-17 18:16","slug":"2024-05-17-Ourtransformationjourneytowardanopendataplatform","content":"\n저자: Condé Nast의 데이터 엔지니어링 부사장 Nana Yaw Essuman, Condé Nast의 고급 엔지니어링 매니저 Ben Hall 및 Condé Nast의 엔지니어링 매니저 Zachary Bannor\n\n# 데이터 미로 헤쳐나가기: 도전에 맞서다\n\n우리 조직은 전 세계 관객에게 탁월한 콘텐츠와 매혹적인 경험을 전달하는 미션을 추진하고 있습니다. 오늘날의 디지털 환경에서 데이터의 가치를 인지한 우리는 37개의 미디어 브랜드를 32개 시장에서 대상으로 고객 상호작용과 참여를 극대화할 데이터 인사이트를 내부 팀에게 제공하기 위해 데이터 여정을 시작했습니다.\n\n그러나 우리는 기존의 복잡한 다양한 데이터 플랫폼으로 이루어진 인프라가 우리의 진전을 방해한다는 것을 빨리 깨달았습니다. 가치 있는 데이터가 조직 전체에 걸쳐 고립되어 있을 때 우리는 여러 기술을 분리해서 탐색해야 했습니다. 데이터 과학자들이 데이터에 접근하기 위해 엄청난 시간을 소비하는 반면, 비즈니스를 촉진할 수 있는 새로운 ML 모델 실험에 거의 시간을 할애할 수 없었습니다. 특히 중앙화된 기업 데이터 플랫폼인 \"에버그린\"을 내부적으로 부르는 세계 3개 주요 지역 전체 영역에 확장하는 결정으로 이 복잡한 환경의 확장이 큰 장애물이었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n에버그린의 비전을 실현하려면 3가지 과제를 해결해야 했습니다:\n\n- 높은 양과 다양성의 데이터를 이해하기: 우리는 유명 패션, 라이프스타일 및 엔터테인먼트 브랜드가 포함된 방대한 출판물, 웹사이트 및 디지털 플랫폼의 포트폴리오를 보유하고 있어 매일 수십 테라바이트의 데이터를 생성합니다. 서로 다른 비즈니스 부문 간의 데이터 솔로로 인해 이 데이터를 관리하기가 매우 어렵습니다. 일관되지 않은 보고서와 상충되는 데이터 숫자로 신뢰의 결여가 발생하며 이는 이해관계자들이 데이터에 신뢰를 하지 못하게 만듭니다. 게다가 데이터를 수집하고 분석할 중앙화된 지점의 부재는 소비자나 상업적 수익을 포함한 다양한 수익 채널의 전반적인 건강을 평가하는 것을 어렵게 만들었습니다.\n- 증가하는 비용 관리: 또 다른 장애는 저장 및 컴퓨팅 비용을 정확하게 반영하는 것이었습니다. 초기에는 특정 데이터 솔로를 위해 레드시프트를 일부로 사용했습니다. 레드시프트 및 일부 구글 빅쿼리를 사용하면, BI 사용자에게 관련 데이터를 제공하는 분석 쿼링 기능을 제공했습니다. 그러나 하류 분석적인 요구사항을 지원하기 위해 이를 다른 서비스들과 연결해야 했으며, 이는 시간과 비용이 많이 소요되는 과정이었습니다. 저장 측면에서, 데이터는 다른 Amazon S3 버킷에 저장되어 중복된 데이터, 운영 효율성의 저하 및 비용 증가를 초래했습니다. 이는 우리의 세계화된 운영 목표에 부합하지 않음을 인지했습니다.\n- 리소스 집약적인 프로세스 개선: 데이터 팀 내 많은 프로세스가 매우 수동적이었습니다. 데이터에 접근하기 어려워 데이터 엔지니어는 ML 및 분석 팀을 위한 스크립트를 작성하는 데 상당한 시간을 소비했습니다. ML 팀 또한 이러한 수동적인 프로세스로 인해 심각한 어려움을 겪었습니다. 데이터 과학팀은 자신의 클러스터를 프로비저닝하고 세부 조정하기 위해 시간을 투자할 때 ML 모델을 빌드하고 훈련하는 데 시간을 집중하지 못했습니다. 데이터 엔지니어링의 리소스 제약은 총 플랫폼 비용을 높여 그럼에 불을 붙였습니다.\n\n# 가치와 규모를 제공하기 위한 오픈 플랫폼을 활용하기\n\n저희 여정의 첫걸음은 적합한 데이터 플랫폼을 선택하는 것이었습니다. 이전 섹션에서 제시된 3가지 과제를 극복할 수 있는 플랫폼을 선택하는 것이 중요했습니다. 우리는 데이터 팀과 비즈니스 팀 모두에 걸칠 수 있는 중앙 집중식 데이터 플랫폼을 구축해야 한다는 것을 알고 있었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리는 우리의 요구 사항을 어떻게 효과적으로 해결할 수 있는지 보기 위해 Snowflake를 평가하기 시작했지만, 빠르게 적합하지 않다는 것을 깨달았습니다. 구조화된 데이터 세트를 중앙에 집중시킬 수 있는 능력을 제공했지만, 주로 분석 및 보고 작업을 위해 설계되었습니다. 우리의 데이터 과학 작업에 필요한 네이티브 지원이 부족했기 때문에 데이터 팀이 다시 기계 학습 팀과 분리되어 있는 것이었습니다. 우리의 데이터 규모를 감안할 때, Snowflake에서 ETL 프로세스를 실행하는 비용과 앞으로 구현하고자 했던 실시간 사용 사례를 지원할 수 있는지에 대해 걱정되었습니다. 우리가 정말 원했던 것은 우리의 기계 학습 요구 사항을 네이티브로 지원하고 데이터와 분석 팀 간의 협업을 촉진할 수 있는 열린 데이터 환경이었습니다.\n\n다음으로, Databricks를 데이터 플랫폼으로 채택하는 것이 우리의 과제를 해결할 수 있는지를 평가했습니다. 그 당시 이미 워크스페이스가 운영 중이었기 때문에 아직까지 확장할 수 있는 플랫폼으로 선택하지 않았습니다. 그러나 데이터 및 기계 학습 능력을 하나의 중앙 플랫폼에서 제공하는 포괄적인 솔루션을 제공했습니다. 이는 사일로를 제거하고 비즈니스 팀 뿐만 아니라 데이터 및 분석 팀 전체에 걸쳐 데이터와 프로세스를 통합하는 목표를 달성할 수 있게 해 줄 것입니다. ML을 위한 네이티브 지원 및 MLflow를 사용한 ML Ops 능력은 데이터 과학자가 효율적으로 작업할 수 있도록 허용할 것입니다.\n\n구조화된 데이터뿐만 아니라 구조화되지 않은 데이터 모두에 대한 Apache Spark™ 지원을 통해 우리는 실시간 사용 사례와 콘텐츠(편집, 비디오, 오디오) 데이터 처리와 같은 고급 기능으로 성장할 수 있었습니다. 생산성 측면에서 단일 진실의 단일 환경과 원격 개발자, 데이터 과학자가 작성한 코드 모두를 버전 관리하고 CI/CD를 사용하여 쉽고 빠르게 배포하는 것이 중요한 요구 사항이었습니다.\n\n규모 확장을 지원하기 위해 열린 플랫폼을 갖고 싶다는 우리의 욕망을 고려하여 Databricks Data Intelligence Platform으로 결정했습니다. 이 플랫폼은 오픈 소스 기술 위에 구축되어 있으며 오픈 소스 커뮤니티에 다시 기여합니다. 또한, 이들의 플랫폼이나 동등한 오픈 소스 기술을 활용하는 엔지니어들의 커뮤니티는 세계적으로 엔지니어들이 많은 도움을 받을 수 있게 해줍니다. 우리의 여정 중 가장 중요한 부분은 데이터 이전이었으며, Delta Lake의 기본 파일 형식이 Apache Parquet(다른 오픈 소스 프로젝트)인 것을 보고 데이터와 통합된 기존 시스템이 다른 파일 형식으로 변환하는 시간을 소모하지 않고도 문제없이 원활하게 작동할 것이라는 것을 간단하게 이해할 수 있었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n데이터브릭스를 도입함으로써 데이터 과학 능력이 크게 향상되었습니다. 이를 통해 우리는 데이터를 효과적으로 활용하여 다양한 사용 사례를 통해 소비자 경험을 개인화하고 타깃팅할 수 있게 되었습니다. 광범위한 사용자 행동 데이터에 접근하여, 데이터 과학자와 머신 러닝 엔지니어들은 독창적인 구독 성향 모델을 개발하는 등의 사용 사례를 구현할 수 있었으며, 독자의 참여를 높은 정확도로 예측하여 독자가 레시피를 손쉽게 찾을 수 있게 해주는 것과 사용자에게 더 정확하고 관련성 높은 광고 타켓팅을 제공하는 등의 기능을 구현할 수 있었습니다.\n\n## 데이터 오디세이에 도입된 레이크하우스 아키텍처가 우리에게 준 이점\n\n지금까지 우리는 저희의 여정과 전 세계적으로 흩어진 다양한 비즈니스 단위에 걸처있는 분열된 인프라를 실행하려고 한 도전들에 대해 살펴보았습니다. 비즈니스 단위 소유자들과 협력하여 데이터와 분석 요구 사항을 분석하여 새로운 프레임워크에 대한 요구 사항을 정의하기 시작했습니다. 우리의 목표는 데이터에 대한 새로운 신뢰를 구축하고 모든 데이터 및 플랫폼 비용을 효율적으로 향상시키고 생산성을 향상시키기 위해 모든 데이터를 한 곳에 모으는 것이었습니다.\n\n레이크하우스 아키텍처를 통합한 이후, 데이터 과학자들의 생산성이 크게 향상되었으며, 약 2.6백만 달러(USD)의 가치를 창출했습니다. 데이터브릭스의 노트북, PySpark 및 MLflow 솔루션을 결합하여 ML 실험을 빠르게 수행하고 동시에 약 6백만 달러(USD)의 클라우드 LTD에서 데이터 오케스트레이션 및 운영 비용을 줄일 수 있었습니다. 내부 라이브러리에서 모델을 배포하거나 새로운 써드파티 모델을 실험하는 것과 같은 작업들이 쉬워졌습니다. 데이터브릭스를 사용하기 전에 우리의 모델을 제공하는 서버를 배포하는 것은 상당한 노력이 필요했습니다. 자동화된 인프라, 클러스터 관리 능력 및 서버리스 추론을 이용하여 기존과 달리 모델을 즉시 제공할 수 있게 되었습니다. 이를 통해 고객에게 제공하는 데 걸리는 시간을 개념에서 고객까지의 시간을 개월에서 일 수준으로 줄일 수 있었습니다. 또한 새로운 모델을 배포하기 위해 단계적인 롤아웃을 사용하여 운영 위험을 크게 줄일 수 있었습니다. 이러한 모든 요인을 결합하여 배포되는 실험의 수와 속도가 급격히 증가하며, 이로 인해 반복 속도와 팀 간 협업이 가속화되었습니다. 결과적으로, 데이터 과학 팀의 고객에게 미치는 영향과 ML 워크플로우의 성능이 크게 향상되었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n더 많은 오픈 데이터 인텔리전스 플랫폼 제품을 사용함에 따라 우리는 생태계에서 다른 혜택을 발견했습니다. 예를 들어, Databricks 피처 스토어를 사용하면 모델 간에 기능을 쉽게 구성, 공유, 재사용할 수 있으므로 모델마다 기능을 새롭게 만들 필요가 없습니다. 실험을 위한 놀이터로서, 우리에게 가치 있는 엔지니어링 시간을 절약하고 생산 중인 모델 수를 빠르게 늘릴 수 있게 해 줍니다.\n\n# 데이터 민주화를 통한 비즈니스 지원\n\n조직 전체에 이러한 가치 있는 데이터 인사이트를 공유하기 위해 Presto를 Databricks SQL Serverless로 대체하여 데이터를 중앙 집중화하고 비용을 줄이면서 사용자에게 셀프 서비스를 제공하는 결정을 내렸습니다. SQL 데이터 웨어하우스는 이제 BI 도구를 지원하고 수백 건의 애드혹 보고서와 경영 대시보드를 생성하여 브랜드 건강, 관객 데이터 및 콘텐츠 성과를 분석할 수 있게 해 줍니다.\n\nSQL 데이터 웨어하우스를 사용하면 분석가들이 데이터 엔지니어 및 데이터 과학자들이 사용하는 동일한 데이터 세트에 액세스할 수 있습니다. 이를 통해 조직 전체에 단일 정보원을 제공하고, 분석가들이 다른 시스템에서 복사한 오래된 데이터를 기반으로 작업하는 것을 방지할 수 있습니다. SQL 데이터 웨어하우스는 BI 워크로드를 지원하고 전통적인 테이블 액세스 제어를 사용하기 때문에 사용자들이 데이터와 상호 작용하는 안전하고 확장 가능한 방법을 제공합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저희에게 데이터 거버넌스를 강화하는 것이 매우 중요합니다. 그래서 Databricks 워크스페이스 전반에 Unity Catalog를 도입했습니다. 저희 데이터는 여러 지역에 걸쳐 퍼져 있기 때문에 Unity Catalog와 Delta Sharing을 활용하여 다양한 정밀도로 데이터를 안전하게 공유했습니다. 이러한 기능들을 통해 데이터의 전체적인 시각을 갖게 되었고, 규정 요건을 준수하는 것을 확인할 수 있었습니다. 앞으로는 Unity Catalog를 기반으로 거버넌스 도구를 도입하여 데이터 거버넌스와 법률 팀이 자산 거버넌스를 강화하는 데 도움이 되기를 기대합니다.\n\n# 지출 효율과 생산성을 재상상하고 고속화하기\n\n또한 Fivetran과 dbt를 레이크하우스에 통합하여 데이터 통합을 크게 단순화하고 비즈니스 로직 변환을 중앙 집중화했습니다. Fivetran을 통해 모든 채널에서 데이터를 손쉽게 중앙 집중화할 수 있었습니다. 3rd 파티 SaaS 플랫폼에 대한 다양한 커넥터는 우리의 모든 브랜드에서 데이터를 통합하여 종합적인 데이터에 기반한 신속한 의사결정을 가능하게 했습니다. dbt를 통해 레이크하우스 아키텍처 내 골드 수준 테이블에서 SQL 쿼리를 실행할 수 있었습니다. 이를 통해 동적 플랫폼 전반의 지출을 효과적으로 관리하고 자원을 최적화하여 더 나은 ROI를 이끌어냈습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 하류 애플리케이션을 위한 데이터 인사이트 및 분석 가속화\n\nDatabricks 플랫폼을 활용하여 통합 데이터 플랫폼 아키텍처를 구축했습니다. 이를 통해 데이터 활용 방법이 혁신되어 협업과 ML 모델 실험이 촉진되었습니다. 저희의 레이크하우스에서는 월별 방문자가 1억 명을 넘는 웹 사이트를 기반으로 한 인사이트를 수집, 분석, 및 배포하고 있습니다. 횡단팀 협업과 통합된 데이터의 동력으로 현재 2000개 이상의 ML 모델이 운영 중이며 미래에 더 많은 모델을 계획 중에 있습니다.\n\n프로덕션 환경의 2000개 이상의 ML 모델을 구현하는 결정적인 솔루션 제공과 데이터 과학팀이 참여하여 참여와 충성도를 증진하는 새로운 ML 솔루션을 지속적으로 개발할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리의 비전을 가능하게 한 모든 데이터 엔지니어들에게 특별한 감사를 전합니다.\n","ogImage":{"url":"/assets/img/2024-05-17-Ourtransformationjourneytowardanopendataplatform_0.png"},"coverImage":"/assets/img/2024-05-17-Ourtransformationjourneytowardanopendataplatform_0.png","tag":["Tech"],"readingTime":9}],"page":"108","totalPageCount":110,"totalPageGroupCount":6,"lastPageGroup":10,"currentPageGroup":5},"__N_SSG":true}