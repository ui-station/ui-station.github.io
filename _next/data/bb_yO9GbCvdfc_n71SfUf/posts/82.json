{"pageProps":{"posts":[{"title":"쿠버네티스 시크릿을 암호화하는 방법","description":"","date":"2024-05-20 16:42","slug":"2024-05-20-HowtoEncryptKubernetesSecrets","content":"\n쿠버네티스 시크릿은 Kubernetes 클러스터에서 실행되는 애플리케이션에서 필요한 비밀 정보를 저장하고 관리하는 메커니즘입니다.\n\n- 민감한 데이터를 응용 프로그램 코드와 분리하여 보관합니다.\n- 시크릿을 생성, 업데이트 및 처리하기 위해 Kubernetes API를 통해 관리됩니다.\n- 시크릿 액세스를 제한하는 구성 가능한 액세스 정책이 있습니다.\n- 볼륨 내의 파일로 노출되거나 환경 변수로 포드에 노출됩니다.\n\n# 시크릿 암호화의 중요성 :\n\n- etcd에서 암호화되지 않은 시크릿은 데이터베이스가 침해당한 경우에 접근할 수 있습니다.\n- 구성이 잘못된 리소스를 통해 실수로 노출될 수 있는 위험이 있습니다.\n- 스토리지 액세스 권한이 있는 관리자 및 사용자가 액세스할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 암호화의 장점 :\n\n- 복호화 키 없이 비밀을 읽을 수 없게 만듭니다.\n- 규정 준수를 통해 데이터 보호 요구 사항 충족을 돕습니다.\n- 암호화된 데이터는 키 없이는 쓸모 없어서 침해로부터의 피해를 줄입니다.\n- 네트워크 전송 중 가로채기를 방지합니다.\n\n# Kubernetes Secrets의 예시 :\n\n- 비밀번호: 데이터베이스 자격 증명, 애플리케이션 로그인 비밀번호 또는 다른 형태의 사용자 인증 비밀번호입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 예시: MySQL 데이터베이스 비밀번호.\n\n2. API 키: 외부 서비스 및 API에 인증하고 액세스하기 위한 토큰.\n\n- 예시: 구글 맵스 API 키, Stripe API 키.\n\n3. SSH 키: 서버에 안전한 셸 액세스에 사용되는 키.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 예시: 원격 Git 저장소에 액세스하는 개인 SSH 키.\n\n4. TLS 인증서: 안전한 HTTPS 연결 설정에 사용되는 인증서.\n\n- 예시: 웹 서버용 SSL/TLS 인증서.\n\n5. OAuth 토큰: OAuth 흐름에서 권한 부여에 사용되는 토큰.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 예시: GitHub 또는 Google과 같은 타사 API에 액세스 토큰입니다.\n\n7. Docker 레지스트리 자격 증명: 개인 Docker 레지스트리에 액세스하기 위한 자격 증명입니다.\n\n- 예시: Docker Hub 또는 기타 컨테이너 레지스트리의 사용자 이름과 비밀번호입니다.\n\n8. 암호화 키: 데이터를 암호화하고 해독하는 데 사용되는 키입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 예시: 데이터를 안전하게 보관하기 위해 사용되는 AES 암호화 키.\n\n# 쿠버네티스에서 Secrets 사용법:\n\n- 환경 변수: Secrets는 컨테이너 내에서 환경 변수로 노출될 수 있습니다.\n\n```yaml\napiVersion: v1\nkind: Pod\nmetadata:\n  name: mypod\nspec:\n  containers:\n    - name: mycontainer\n      image: myimage\n      env:\n        - name: DB_PASSWORD\n          valueFrom:\n            secretKeyRef:\n              name: mysecret\n              key: db_password\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n2. 볼륨 마운트: 시크릿은 컨테이너 내에서 파일로 마운트될 수 있어요.\n\n```js\napiVersion: v1\nkind: Pod\nmetadata:\n  name: mypod\nspec:\n  containers:\n  - name: mycontainer\n    image: myimage\n    volumeMounts:\n    - name: secret-volume\n      mountPath: \"/etc/secrets\"\n  volumes:\n  - name: secret-volume\n    secret:\n      secretName: mysecret\n```\n\n# 쿠버네티스 시크릿의 암호화 유형:\n\n- 암호화 철자: 무엇을 의미하며 왜 중요한지 설명합니다.\n- 전송 중 암호화: 시크릿이 전송 중에 암호화되도록 보장하는 방법에 간단히 언급합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 암호화 구성 파일 만들기:\n\n이 파일은 암호화 공급자와 암호화에 사용되는 키를 지정합니다.\n\n```js\napiVersion: apiserver.config.k8s.io/v1\nkind: EncryptionConfiguration\nresources:\n  - resources:\n    - secrets\n    providers:\n    - aescbc:\n        keys:\n        - name: key1\n          secret: <base64-encoded-secret>\n    - identity: {}\n```\n\n# Encryption Key 생성하기:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n256비트 암호화 키를 Base64로 인코딩하세요. 다양한 도구를 사용하여 이 작업을 수행할 수 있습니다. OpenSSL을 사용하여 다음과 같이 수행할 수 있습니다:\n\n```js\nhead -c 32 /dev/urandom | base64\n```\n\n생성된 키로 구성 파일에서 `base64-encoded-secret`을(를) 교체하세요.\n\n# 암호화 구성 적용하기:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nAPI 서버 Manifest 파일을 수정해야 합니다. 일반적으로 /etc/kubernetes/manifests/kube-apiserver.yaml 경로에 위치합니다. 다음과 같이 API 서버 Manifest 파일을 수정해주세요.\n\n```yaml\napiVersion: v1\nkind: Pod\nmetadata:\n  name: kube-apiserver\n  namespace: kube-system\nspec:\n  containers:\n    - name: kube-apiserver\n      command:\n        - kube-apiserver\n        # 다른 플래그들...\n        - --encryption-provider-config=/path/to/encryption-config.yaml\n```\n\n암호화 구성 파일이 모든 제어 평면 노드의 지정된 경로에서 액세스 가능한지 확인해주세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# API 서버 재시작:\n\nAPI 서버는 새 구성을 적용하고 비밀을 안전하게 암호화하기 시작할 것입니다.\n\n# 암호화 확인:\n\n비밀이 정상적으로 암호화되고 있는지 확인하려면:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 테스트 비밀 정보 만들기:\n\n```js\nkubectl create secret generic test-secret --from-literal=key1=supersecret\n```\n\n- etcd 확인: etcd 데이터에 직접 액세스하시면서 (일반적으로 프로덕션에서 피해야 하는 직접적인 etcd 쿼리를 수행하므로 주의하세요). 데이터가 암호화되어 있는지 확인하기 위해 etcdctl 도구를 사용하세요.\n\n```js\nETCDCTL_API=3 etcdctl get /registry/secrets/default/test-secret --prefix --key-file=<path-to-key-file> --cert-file=<path-to-cert-file> --cacert=<path-to-ca-cert>\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 암호화 키 회전:\n\n보안을 강화하기 위해 주기적으로 암호화 키를 회전하세요.\n\n- 새 키 추가: 새 키를 목록 상단에 업데이트된 암호화 구성 파일에 추가하세요.\n- 비밀 정보 재암호화: 새 키로 모든 비밀 정보를 재암호화하세요.\n\n```js\nkubectl get secrets --all-namespaces -o json | kubectl replace -f -\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 이전 키 제거: 모든 비밀을 재암호화한 후, 구성에서 이전 키를 제거하십시오.\n\n# Kubernetes Secrets을 암호화하는 것은 클러스터 내의 민감한 데이터를 안전하게 보호하는 데 중요합니다. Kubernetes Secrets를 암호화하는 다양한 방법은 다음과 같습니다:\n\n## 1. 내장된 메커니즘을 사용하여 정지 상태의 Secrets 암호화\n\nKubernetes은 정지 상태의 Secrets를 암호화하는 내장 지원을 제공합니다. 이는 가장 간단한 방법이며 API 서버를 암호화 제공자로 구성하는 것이 포함됩니다. 이것이 수행하는 방법은 다음과 같습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 단계:\n\n- 암호화 구성 파일 만들기:\n\n```js\napiVersion: apiserver.config.k8s.io/v1\nkind: EncryptionConfiguration\nresources:\n- resources:\n  - secrets\n  providers:\n  - aescbc:\n      keys:\n      - name: key1\n        secret: <base64-encoded-key>\n  - identity: {}\n```\n\n2. API 서버에서 암호화 구성 지정: kube-apiserver 매니페스트를 편집하십시오 (보통 /etc/kubernetes/manifests/kube-apiserver.yaml에 위치함).\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```plaintext\n--encryption-provider-config=/path/to/encryption-config.yaml\n```\n\n3. API 서버 재시작: 매니페스트를 업데이트한 후에는 kube-apiserver가 자동으로 재시작되어 비밀을 암호화하기 시작합니다.\n\n## 2. 외부 키 관리 서비스(KMS) 사용\n\n보안을 강화하기 위해 Kubernetes는 AWS KMS, Google Cloud KMS 또는 HashiCorp Vault와 같은 외부 키 관리 서비스와 통합할 수 있습니다. 이 방법을 사용하면 Kubernetes가 외부 시스템을 사용하여 키 관리를 수행할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 단계:\n\n- KMS 프로바이더 구성:\n\n  - AWS KMS의 경우: AWS KMS 프로바이더 플러그인을 사용하고 암호화 구성 파일을 해당대로 구성합니다.\n  - Google Cloud KMS의 경우: GCP KMS 프로바이더 플러그인을 사용하고 암호화 구성 파일을 구성합니다.\n  - HashiCorp Vault의 경우: Vault를 구성하여 키를 관리하고 Vault 프로바이더를 설정합니다.\n\n2. Encryption Configuration 파일 업데이트:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```yaml\napiVersion: apiserver.config.k8s.io/v1\nkind: EncryptionConfiguration\nresources:\n  - resources:\n      - secrets\n    providers:\n      - kms:\n          name: <provider-name>\n          endpoint: <kms-endpoint>\n          cachesize: 1000\n      - identity: {}\n```\n\n3. API 서버 구성 업데이트:\n\n```bash\n--encryption-provider-config=/path/to/encryption-config.yaml\n```\n\n4. API 서버 재시작: API 서버가 새 구성을 사용하도록 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 3. 커스텀 암호화 제공자를 사용하여 시크릿 암호화\n\n더 많은 제어를 필요로 하는 경우, 커스텀 암호화 제공자를 구현할 수 있습니다. 이 방법은 커스텀 암호화 플러그인을 작성하고 배포하는 과정을 포함합니다.\n\n## 단계:\n\n- 커스텀 프로바이더 개발: 요구 사항에 기반하여 암호화 및 복호화 로직을 구현합니다.\n- 커스텀 프로바이더 배포: 커스텀 프로바이더가 API 서버에서 접근 가능하도록 합니다.\n- 암호화 구성 설정:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```yaml\napiVersion: apiserver.config.k8s.io/v1\nkind: EncryptionConfiguration\nresources:\n  - resources:\n      - secrets\n    providers:\n      - custom:\n          name: <custom-provider-name>\n          endpoint: <custom-provider-endpoint>\n      - identity: {}\n```\n\n4. API 서버 업데이트:\n\n```bash\n--encryption-provider-config=/path/to/encryption-config.yaml\n```\n\n5. API 서버 재시작: 구성 변경을 적용하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 4. 응용 프로그램 수준에서 비밀을 암호화하는 방법\n\n데이터를 안전하게 보관하기 위해 데이터를 안전하게 저장하는 대신 또는 그 외에 데이터를 Kubernetes Secrets에 저장하기 전에 응용 프로그램 수준에서 데이터를 암호화할 수 있습니다. 이 방법은 응용 프로그램이 암호화 및 복호화를 처리해야 합니다.\n\n## 단계:\n\n- 응용 프로그램에서 암호화 구현: Kubernetes Secret을 만들기 전에 민감한 데이터를 암호화하는 라이브러리나 도구를 사용합니다.\n- Kubernetes Secret으로 암호화된 데이터 저장: Secret에 저장된 데이터는 이미 암호화되어 있습니다.\n- 응용 프로그램에서 데이터 복호화: 응용 프로그램이 Secret을 검색할 때 데이터를 사용하기 전에 데이터를 복호화해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 5. Sealed Secrets 사용하기\n\nSealed Secrets는 비트나미에서 개발한 프로젝트로, Git 저장소에 암호화된 비밀을 저장할 수 있게 해줍니다.\n\n## 단계:\n\n- kubeseal 설치: kubeseal CLI 도구를 설치합니다.\n- Secret 암호화: kubeseal을 사용하여 쿠버네티스 Secret에서 SealedSecret을 생성합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nkubectl create secret generic mysecret --from-literal=username=myuser --from-literal=password=mypass -o yaml --dry-run=client > mysecret.yaml\nkubeseal < mysecret.yaml > mysealedsecret.yaml\n```\n\n3. SealedSecret 적용: SealedSecret 매니페스트를 클러스터에 적용합니다.\n\n```js\nkubectl apply -f mysealedsecret.yaml\n```\n\n4. 런타임에서 Controller 복호화: 클러스터의 Sealed Secrets 컨트롤러가 시크릿을 복호화하고 실제 시크릿 리소스를 생성합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 6. SOPS(비밀 작업) 사용하기\n\nSOPS는 Kubernetes 시크릿 매니페스트를 암호화하는 데 사용할 수 있는 도구입니다.\n\n## 단계:\n\n- SOPS 설치: SOPS CLI 도구를 설치합니다.\n- 시크릿 매니페스트 암호화: Kubernetes 시크릿 매니페스트를 작성하고 SOPS를 사용하여 암호화합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nsops --encrypt --kms arn:aws:kms:region:account-id:key/key-id secret.yaml > encrypted-secret.yaml\n```\n\n3. Apply the Encrypted Secret: 클러스터에 암호화된 매니페스트를 적용하세요.\n\n```js\nkubectl apply -f encrypted-secret.yaml\n```\n\n4. Decrypt at Runtime: CI/CD 파이프라인이나 애플리케이션 로직 내에서 런타임에 시크릿을 복호화하는 데 SOPS를 사용하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이러한 방법들은 귀하의 인프라 및 보안 요구사항에 따라 다양한 수준의 보안과 유연성을 제공합니다. Kubernetes Secrets에 대한 암호화를 구현하면, 클러스터 내에서 민감한 데이터가 수명 주기 전체에 걸쳐 보호되도록 할 수 있습니다.\n\n# 이 안내서가 도움이 되었다면 👏 버튼을 클릭해주세요.\n\n더 많은 학습을 위해 팔로우 해주세요 😊\n\n특정 주제에 궁금한 점이 있으시면, 개인적인 메모나 댓글을 남겨주세요. 궁금해하는 내용을 탐험하는 데 도움을 드리겠습니다!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 소중한 시간을 내어 지식을 향상시키기 위해 노력하셔서 감사합니다!\n","ogImage":{"url":"/assets/img/2024-05-20-HowtoEncryptKubernetesSecrets_0.png"},"coverImage":"/assets/img/2024-05-20-HowtoEncryptKubernetesSecrets_0.png","tag":["Tech"],"readingTime":15},{"title":"2024년 게임 업계의 지속적인 리소그린드에 대해 무슨 일이 일어나고 있을까요","description":"","date":"2024-05-20 16:40","slug":"2024-05-20-Whatsupwiththeconstantgaminglayoffsin2024","content":"\n![이미지](/assets/img/2024-05-20-Whatsupwiththeconstantgaminglayoffsin2024_0.png)\n\n2027년까지 게임 산업은 2820억 달러에 달하는 가치를 가질 예정입니다. 그런데 주요 게임 배급사들에서 지속적으로 보고되는 대규모 인원 감축에 뭐가 일어나고 있는 건지요?\n\n소니가 최근 많은 직원들을 대대적으로 해고한 최신의 게임 거대기업이 되었습니다. 이번 주에 900명의 직원이 해고되었는데, 소니는 놓친 판매 목표와 주식 가격 100억 달러의 급락을 해고의 동기로 지목했습니다.\n\n그 전에 EA, Microsoft, Epic, Sega, 그리고 Twitch는 2023년 동안 총 10,500명의 직원들을 해고한 적이 있었다고 신뢰할 수 있는 인원 감축 추적기에 따르면. 2024년 시작 90일이 되자 이미 이 숫자는 6,000명의 직원에 도달했고, 위기라는 단어가 분석가들 사이에서 등장하기 시작했습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n보드 게임이 대유행하면서 팬데믹으로 인한 외출 자제의 이유가 줄어들었다기보다 게임 업계 리더들은 게임이 팬데믹 기간 동안 눈부신 성공을 거두어 이 상황에 이르게 된 것이라는 데에 일치한다는 점에 동의하는 경향이 있습니다.\n\n잠정사이 극에 차 있던 외로운 사람들이 문닫혀 게임으로 회피하면서 경이로운 참여 수준은 다음 몇 년 동안 업계 성장에 대한 비현실적인 예상을 지원하기로 알려졌습니다.\n\n그러나 사로잡힌 관객이 없으면 축출했던 수익 예상에 비해 출판사 고용 폭발로 인한 무거운 급여 지급은 지속하기 어려워졌습니다. 당시에는 잠재적인 후퇴에 대비한 경계 조치가 없는 낙관적인 숫자였다고 돌아보면 그림자가 된다.\n\n몇 년이 지난 지금, 게임 사업 관계자들에게 현실은 그리 유치하지 않습니다. 2023년 게임 투자가 주요한 최저점을 기록했으며, 소니는 PS5 판매 대상을 크게 미달했으며, 미국의 수익은 4% 감소한 것으로 알려져 있습니다 — 무한한 이익이 기대되었던 것과는 크게 달라진 결과입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\"‘이제는 믿기 힘들지만, 당시 문화적 대화는 이러한 이익이 계속 유지될 것이라는 믿음에 의해 주도되었다’고 컴퓨터 산업 교수 레인 누니가 설명했습니다.\n\n‘팬데믹 기간 동안 이러한 급증에 대한 많은 미디어 관심은 스트리밍 시간이나 벌어들인 돈에 대한뿐만 아니라 모든 이것이 계속될 것이라는 집단 착각에 기여했다’고 그는 말했습니다.\n\n현실이 여러 해 뒤에 조금씩 드러나기 시작할 때 AAA 및 인디 개발자들은 재무를 균형잡는 빠르고 효과적인 수단으로 직원을 줄이고 있습니다. 지난 달만에 Microsoft가 Activision Blizzard 직원 1,900명을 해고하고 Discord가 직원의 17%를 해고하며 Unity가 전체 직원의 1/4를 해고했습니다.\n\n이 지점에 이르게 한 것은 지나치게 많은 인원 채용 뿐만 아니라, 충분하지 않은 점도 있습니다. 게임 발행사들에게는 항상 직원이 일회용으로 여겨졌으며, 게임 업계에서 오랫동안 활동한 대다수는 프로젝트마다 살아남기 위해 뛰놀며, 실제 고용 안정성이 전혀 없는 삶에 익숙할 것입니다.\"\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n비용이 품질이 향상된 제품에 대한 수요로 인해 뛰어오르면 벤처 자본이 신중한 투자자들로부터 소진되거나 새로운 기술 트렌드가 예상치 못하게 실패할 때 — 아니, 클라우드 게임 — 중복은 최고 관리자들에게 탈출구로 여겨집니다.\n\n2024년의 산업 현장에서는 위에 열거한 모든 것과 맞닥뜨린다고 합니다. 특히, 대출을 위한 상승하는 이자율과 운영 자금 조달을 위해 롤링 부채를 사용함이 경제적으로 도전적이라고 할 수 있습니다. 인플레이션은 모두에게 영향을 미칩니다.\n\n업계의 용서하지 않는 성격의 대표적 사례가 현재 진행 중이기도 합니다. 10년에 걸친 개발 노력 끝에 유비소프트의 '첫 번째 AAAA 게임'으로 소개되었던 Skull and Bones는 이미 무자비한 2억 달러의 비용에 제대로 미쳐하지 못할 운명입니다.\n\n리뷰 사이트에서 주어진 지루한 평가로 인해 출시된 이번 실패작은 이전의 해적 게임인 Assassin's Creed: Black Flag와 Sea of Thieves에 대한 관심을 다시 불러일으키기만 했습니다. 심지어 Assassin's Creed 같은 사랑받는 시리즈에 추가 요소를 넣어도 성공을 보장할 수 없습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다시 넓은 시야를 가져오면, 게임 배급사들로부터 갑자기 해고를 당한 사람들을 위해 격려하는 기초적 노력들이 있습니다.\n\n일자리를 구하는 데 많은 경쟁이 있더라도 산업 내 선한 사람들은 새로운 고용주들과 개발자들을 연결하는 포럼 및 소셜 미디어 페이지를 운영하고 있습니다. Amir Satvat의 '구직자 워크북'과 전용 LinkedIn 페이지는 커뮤니티에 큰 도움이 되고 있습니다.\n\n더 나아가, 점차 증가하는 개발자들의 단결이 게임 업계의 고용 및 해고에 대한 주기적인 태도를 개선하기 위한 희망으로 결성되고 있습니다. 어제 소니에서 대규모 퇴사가 이뤄졌기 때문에 이 분야에서의 노력들은 의심할 여지가 없이 가속화될 것입니다.\n\n최종적으로 소비자들로부터 더 많은 주의를 받을 필요가 있는 것이 아닌지, 이런 식의 '지도자들의 결정'을 고려해 볼 때가 아닌지도 모릅니다. 게임의 생명줄로써, 이러한 실천 방식은 허용 가능하거나 당연한 것으로 여겨질 수 없습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n제이미 왷츠가 Thred를 위해 작성했습니다.\n","ogImage":{"url":"/assets/img/2024-05-20-Whatsupwiththeconstantgaminglayoffsin2024_0.png"},"coverImage":"/assets/img/2024-05-20-Whatsupwiththeconstantgaminglayoffsin2024_0.png","tag":["Tech"],"readingTime":4},{"title":"모노게임 XNA에서 물 쉐이더를 만드는 방법","description":"","date":"2024-05-20 16:37","slug":"2024-05-20-HowtocreateWatershaderinMonogameXNA","content":"\n# 소개\n\n이 기사에서는 Monogame/XNA에서 간단한 물 쉐이더를 만드는 기본 개념을 다룰 것입니다. 이 쉐이더는 플레이너 반사, 굴절, 프레넬 효과 및 반사 하이라이트를 사용할 것입니다. 작성 시점에서 Monogame 버전 3.8.1로 진행되었습니다. 자세히 살펴보고 싶다면 여기 소스 코드가 있습니다.\n\n# 기본 사항\n\n우리 쉐이더가 어떻게 작동하는지 더 잘 이해하기 위해 여러 단계로 나눠 설명하겠습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 쿼드/플랫 표면 추가하기\n- 반사 및 굴절 텍스처 추가하기 (프레넬 효과를 사용하여 둘 사이의 러핑)\n- 왜곡 맵을 사용하여 작은 파도 시뮬레이션하기\n- 광택을 위한 노말 맵 추가하기\n\n# 그리기\n\n그려지는 순서는 다음과 같습니다:\n\n- 굴절 그리기\n- 반사 그리기\n- 물 그리기\n- 장면에서 다른 개체 그리기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 순서는 원하는 시각적 효과를 달성하기 위해 각 구성 요소가 올바른 순서로 렌더링되도록합니다.\n\n# 코드 설정\n\n우리의 워터 쉐이더 기술을 올바르게 구현하기 위해 코드에서 몇 가지 설정을 해야합니다. 설명을 간단히하기 위해 이미 정의된 QuadPrimitive 클래스를 사용할 것입니다. 이 클래스는 정점 버퍼(법선과 텍스처 좌표에 대한 정보를 보냄)와 인덱스 버퍼를 가집니다. 또한 FreeCamera 클래스를 사용하여 카메라 이동을 처리할 것이지만 이 튜토리얼의 주요 내용은 아니기 때문에 자세히 다루지 않겠습니다.\n\n먼저 우리는 우리의 쿼드, 그의 월드 매트릭스, 높이 및 파도 속도를 생성할 것입니다. 나중에는 쉐이더 매개변수에서 파도 속도를 사용할 것입니다. 또한 이 높이는 반사와 굴절을 계산하는 중요한 요소가 될 것입니다. 게다가 우리는 쉐이더를 선언할 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```csharp\n// 카메라\nprivate FreeCamera _freeCamera;\nprivate readonly Vector3 _cameraInitialPosition = new(0f, 50f, 300f);\n\n// 물\nprivate QuadPrimitive _quad;\nprivate const float QuadHeight = 0f;\nprivate const float WaveSpeed = 0.05f;\nprivate Matrix _quadWorld;\nprivate Effect _waterShader;\n```\n\n아울 Initialize 메소드는 다음과 같이 보여야 합니다:\n\n```csharp\nprotected override void Initialize()\n{\n  _graphicsDeviceManager.PreferredBackBufferWidth = GraphicsAdapter.DefaultAdapter.CurrentDisplayMode.Width - 100;\n  _graphicsDeviceManager.PreferredBackBufferHeight = GraphicsAdapter.DefaultAdapter.CurrentDisplayMode.Height - 100;\n  _graphicsDeviceManager.ApplyChanges();\n\n  // 카메라\n  _freeCamera = new FreeCamera(GraphicsDevice.Viewport.AspectRatio, _cameraInitialPosition);\n\n  // 물\n  _quad = new QuadPrimitive(GraphicsDevice);\n  var quadPosition = new Vector3(0f, QuadHeight, 0f);\n  _quadWorld = Matrix.CreateScale(3000f, 0f, 3000f) * Matrix.CreateTranslation(quadPosition);\n\n  base.Initialize();\n}\n```\n\n# 평면 반사\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n코드를 진행하기 전에 우리는 평면 반사가 어떻게 작동하는지 이해해야 합니다. 평면 반사의 예시를 살펴보겠습니다:\n\n![Planar Reflection](/assets/img/2024-05-20-HowtocreateWatershaderinMonogameXNA_0.png)\n\n이 예시에서 우리는 반사면, 카메라, 그리고 어떤 객체가 주어졌을 때 반사가 이렇게 보일 것이라는 것을 볼 수 있습니다. 이것을 코드로 나중에 변환하기 위해, 반사 카메라의 시각에서 새로운 뷰 매트릭스를 계산해야 합니다.\n\n## 반사 카메라 위치\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n먼저, 반사 카메라 위치를 계산하겠습니다. 이미 카메라 위치, 평면 위치 및 평면 법선을 알고 있으므로 카메라 위치에서 평면 위치를 빼면 뷰 방향 벡터를 얻을 수 있습니다:\n\n뷰 방향 = 카메라 위치 - 평면 위치\n\n![image](/assets/img/2024-05-20-HowtocreateWatershaderinMonogameXNA_1.png)\n\n또한 투영 벡터를 추가했는데 이것은 다음과 같습니다. 그런 다음 해당 투영의 길이를 사용하여 평면상의 해당 지점까지의 거리를 찾을 수 있습니다.\n이제 우리는 직각 삼각형을 가지고 있습니다. 투영 길이는 다음과 같아야 합니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n투영 길이 = 시야 방향 \\* cos(각도)\n\n각도는 평면 법선과 시야 방향 사이의 각도를 의미합니다.\n\n간단하게 표현하면 다음과 같이 다시 쓸 수 있습니다:\n\n투영 길이 = 내적(평면 법선, 시야 방향)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n좋아요, 이제 우리에게는 프로젝션 길이가 있습니다. 이것을 사용하여 반사 카메라 위치를 얻을 수 있습니다:\n\n반사 카메라 위치 = 카메라 위치 — 2 _ 평면 법선 _ 프로젝션 길이\n\n## 반사 카메라 뷰 매트릭스\n\n반사 카메라 뷰 매트릭스를 얻으려면 반사 카메라 포워드를 계산해야 합니다. 함수 Reflect(vector, normal)를 사용하여 특정 법선을 갖는 표면에서 벡터의 반사를 얻을 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n카메라 반사 벡터를 계산한 후, Reflection Camera Up을 계산하는 다음 단계입니다. 카메라의 위쪽 벡터를 반사면의 법선을 기준으로 반사하는 Vector3.Reflect 함수를 다시 사용할 것입니다.\n\nReflection Camera Up = Vector3.Reflect(Camera Up, Plane Normal)\n\nReflection Camera Position, Reflection Camera Forward 및 Reflection Camera Up 벡터가 모두 계산되었으므로 이제 Reflection Camera View Matrix를 구성하는 데 필요한 모든 구성 요소를 갖추게 되었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n리플렉션 카메라 뷰 = Matrix.CreateLookAt(리플렉션 카메라 위치, 리플렉션 카메라 위치 + 리플렉션 카메라 전방, 리플렉션 카메라 위치)\n\n# 리플렉션 그리기\n\n이제 리플렉션 카메라 뷰 행렬의 필요 구성 요소를 계산했으므로, 일반적으로 RenderTarget2D와 같은 텍스처에 리플렉션을 그릴 수 있습니다. 이를 위해 코드에서 이전에 계산한 값을 렌더링 프로세스에 통합할 수 있습니다. 다음 코드 조각은 이를 어떻게 달성할 수 있는지 보여줍니다:\n\n```js\nprivate void DrawReflection(Matrix world, Matrix view, Matrix projection, GameTime gameTime)\n{\n    // 렌더 타겟을 리플렉션 텍스처로 설정\n    GraphicsDevice.SetRenderTarget(_reflectionRenderTarget);\n    GraphicsDevice.Clear(ClearOptions.Target |\n    ClearOptions.DepthBuffer, Color.CornflowerBlue, 1f, 0);\n\n    var quadNormal = Vector3.Up;\n    var viewDirection = _freeCamera.Position - _quadWorld.Translation;\n    var projLength = Vector3.Dot(quadNormal, viewDirection);\n    var reflectionCamPos = _freeCamera.Position - 2 * quadNormal * projLength;\n    var reflectionCamForward = Vector3.Reflect(_freeCamera.FrontDirection,\n    quadNormal);\n    var reflectionCamUp = Vector3.Reflect(_freeCamera.UpDirection, quadNormal);\n    var reflectionCamView = Matrix.CreateLookAt(reflectionCamPos,\n                reflectionCamPos + reflectionCamForward, reflectionCamUp);\n\n    // 리플렉션 카메라 시점에서 씬 그리기\n    DrawScene(reflectionCamView, projection, reflectionCamPos,\n    _reflectionClippingPlane);\n\n    // 렌더 타겟을 기본(화면)으로 재설정\n    GraphicsDevice.SetRenderTarget(null);\n\n    // 물 그리기\n    DrawWater(world, view, projection, reflectionCamView, gameTime);\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nDrawWater 메서드에서는 필요한 매개변수를 전달할 것이며, 이에 대해 나중에 자세히 다룰 것입니다.\n\n## 클리핑 평면\n\n클리핑 평면 \\_reflectionClippingPlane이 아직 설명되지 않았다는 것을 눈치채셨나요? 그 목적에 대해 자세히 살펴보겠습니다. 이 클리핑 평면은 수면 위에 있는 객체만 그릴 때 사용됩니다. 이를 통해 객체의 상단 반만이 물에 반사되어 실제 반사에서 관찰되는 것과 동일하게 됩니다. 다음과 같이 선언할 수 있습니다:\n\n```js\nprivate readonly Vector4 _reflectionClippingPlane = new Vector4(0f, 1f, 0f, -QuadHeight);\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 평면은 수학적 방정식 (Ax + By + Cz + D = 0)으로 정의됩니다. 여기서 (A, B, C)는 평면에 수직인 법선 벡터를 나타내고, D는 해당 법선 벡터를 따라 원점으로부터의 거리를 나타냅니다.\n\n우리의 경우, 물 표면은 XZ 평면과 평행한 평면으로 작용하며, 그 법선 벡터는 직접 위쪽을 가리킵니다 (0, 1, 0).\n\n우리는 물 속 객체를 다루는 셰이더를 위해 반사 클리핑 평면 방정식에 -QuadHeight 값을 활용합니다. 이 값은 나중에 픽셀 셰이더에서 clip 함수를 사용하여 Reflection Plane 아래의 픽셀을 클리핑할 때 사용됩니다. 다음은 예시입니다:\n\n_Uniforms_\n\n```js\nfloat4 ClippingPlane;\n\nstruct VertexShaderInput\n{\n    float4 Position : POSITION0;\n    float4 Normal : NORMAL;\n};\n\nstruct VertexShaderOutput\n{\n    float4 Position : POSITION0;\n    float3 WorldPosition : TEXCOORD0;\n    float3 Normal : TEXCOORD1;\n    float4 Clipping : TEXCOORD2;\n};\n\nVertexShaderOutput MainVS(VertexShaderInput input)\n{\n    VertexShaderOutput output = (VertexShaderOutput) 0;\n\n    float4 worldPosition = mul(input.Position, World);\n    float4 viewPosition = mul(worldPosition, View);\n    output.Position = mul(viewPosition, Projection);\n    output.WorldPosition = worldPosition;\n    output.Normal = mul(input.Normal, InverseTransposeWorld);\n    /*\n    dot product를 사용하여 정점에서 클리핑 평면까지의 거리 계산\n    이 결과 거리는 해당 픽셀을 픽셀 셰이더에서 버릴지 여부를 결정하는 데 사용됩니다\n    */\n    output.Clipping = dot(worldPosition, ClippingPlane);\n\n    return output;\n}\n\nfloat4 MainPS(VertexShaderOutput input) : COLOR0\n{\n    clip(input.Clipping);\n\n    // 픽셀 셰이더의 나머지 부분\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n클립 함수는 지정된 조건에 따라 픽셀을 삭제하는 기능을 담당합니다. 셰이더에서 -QuadHeight를 활용하여 물 표면 아래에 있는 물체를 나타내는 픽셀들이 렌더링 중에 삭제되어 최종 반사 이미지에서 클리핑되는 효과가 있습니다.\n\n또한, 위쪽의 물 위에 있는 픽셀을 삭제하려는 경우에도 이 방법이 작동합니다. 이 경우 굴절을 위해 다음과 같이 설정할 수 있습니다:\n\n```js\nprivate readonly Vector4 _refractionClippingPlane = new(0f, -1f, 0f, QuadHeight);\n```\n\n# 굴절\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n리프렉션을 렌더 대상에 그리는 것은 반사를 렌더링하는 것과 비교할 때 간단한 프로세스입니다. 이 작업은 카메라의 관점에서 장면을 렌더링하면서 \\_refractionClippingPlane을 사용하여 수면 위의 픽셀을 버립니다.\n\n```js\nprivate void DrawRefraction()\n{\n    // Refraction Texture을 렌더 타겟으로 설정\n    GraphicsDevice.SetRenderTarget(_refractionRenderTarget);\n    GraphicsDevice.Clear(ClearOptions.Target | ClearOptions.DepthBuffer, Color.CornflowerBlue, 1f, 0);\n\n    // 수면 위에 있는 객체를 자르면서 장면을 일반적으로 그립니다\n    DrawScene(_freeCamera.View, _freeCamera.Projection, _freeCamera.Position, _refractionClippingPlane);\n\n    // 렌더 타겟을 기본값(화면)으로 재설정\n    GraphicsDevice.SetRenderTarget(null);\n}\n```\n\n좋아요, 이제 실제 수 쉐이더로 진행하여 이 모든 내용이 어떻게 결합되는지 살펴봅시다.\n\n# 수 쉐이더\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n먼저, 우리의 물 쉐이더에 필요한 균일 및 텍스처를 선언할 것입니다. 이에는 조명, 카메라 위치, 물의 움직임 및 사용할 다양한 맵에 대한 텍스처 샘플러를 위한 매개변수가 포함됩니다:\n\n```js\nfloat KSpecular;\nfloat Shininess;\nfloat3 LightPosition;\nfloat3 LightColor;\nfloat3 CameraPosition;\n\nfloat MoveFactor;\nfloat2 Tiling;\nfloat WaveStrength;\n\nfloat4x4 ReflectionView;\nfloat4x4 Projection;\nfloat4x4 WorldViewProjection;\nfloat4x4 World;\n\ntexture RefractionTexture;\nsampler2D refractionSampler = sampler_state\n{\n    Texture = (RefractionTexture);\n    ADDRESSU = Clamp;\n    ADDRESSV = Clamp;\n    MINFILTER = Linear;\n    MAGFILTER = Linear;\n    MIPFILTER = Linear;\n};\n\ntexture ReflectionTexture;\nsampler2D reflectionSampler = sampler_state\n{\n    Texture = (ReflectionTexture);\n    ADDRESSU = Clamp;\n    ADDRESSV = Clamp;\n    MINFILTER = Linear;\n    MAGFILTER = Linear;\n    MIPFILTER = Linear;\n};\n\ntexture DistortionMap;\nsampler2D distortionSampler = sampler_state\n{\n    Texture = (DistortionMap);\n    ADDRESSU = WRAP;\n    ADDRESSV = WRAP;\n    MINFILTER = Linear;\n    MAGFILTER = Linear;\n    MIPFILTER = Linear;\n};\n\ntexture NormalMap;\nsampler2D normalMapSampler = sampler_state\n{\n    Texture = (NormalMap);\n    ADDRESSU = WRAP;\n    ADDRESSV = WRAP;\n    MINFILTER = Linear;\n    MAGFILTER = Linear;\n    MIPFILTER = Linear;\n};\n```\n\n이 쉐이더에서 KSpecular, Shininess, LightPosition, LightColor, CameraPosition과 같은 균일은 조명 및 시각화 매개변수를 정의합니다. MoveFactor, Tiling, WaveStrength는 물의 움직임과 외관을 제어합니다. ReflectionView, Projection, WorldViewProjection, World와 같은 행렬은 좌표를 변환하는 데 사용됩니다. refractionSampler, reflectionSampler, distortionSampler, normalMapSampler와 같은 텍스처 샘플러는 물 표면을 렌더링하는 데 필요한 해당 텍스처를 샘플링하는 데 사용됩니다.\n\n왜곡 맵에는 다음과 같은 모양의 텍스처를 사용할 것입니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/assets/img/2024-05-20-HowtocreateWatershaderinMonogameXNA_2.png)\n\n이 텍스처를 사용하여 텍스처 좌표를 왜곡시켜 물 표면에 작은 파도 효과를 만들 수 있습니다. 이 왜곡은 물의 동적이고 현실적인 외관을 모방하는 데 도움이 됩니다.\n\nNormal Map으로는 다른 텍스처를 사용할 것입니다. 여기 예시가 있습니다:\n\n![이미지](/assets/img/2024-05-20-HowtocreateWatershaderinMonogameXNA_3.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 지도에는 물과 빛이 상호 작용하는 방식을 시뮬레이션하기 위해 필수적인 표면 법선에 대한 정보가 포함되어 있습니다. 왜곡 맵이 텍스처 좌표를 조작하는 데 사용되는 반면, 법선 맵은 빛 관련 계산에 사용됩니다.\n\n## 버텍스 셰이더\n\n우리의 버텍스 셰이더에서는 버텍스 데이터를 픽셀 셰이더에 대비하여 준비하기 위해 변환합니다. 이 과정을 자세히 살펴보겠습니다:\n\n```js\nstruct VertexShaderInput\n{\n    float4 Position : POSITION0;\n    float4 Normal : NORMAL;\n    float2 TextureCoordinates : TEXCOORD0;\n};\n\nstruct VertexShaderOutput\n{\n    float4 Position : SV_POSITION;\n    float2 TextureCoordinates : TEXCOORD0;\n    float4 WorldPosition : TEXCOORD1;\n    float4 Normal : TEXCOORD2;\n    float4 ReflectionPosition : TEXCOORD3;\n    float4 RefractionPosition : TEXCOORD4;\n};\n\nVertexShaderOutput MainVS(in VertexShaderInput input)\n{\n    VertexShaderOutput output = (VertexShaderOutput) 0;\n\n    // 버텍스 위치를 클립 공간에 변환합니다\n    output.Position = mul(input.Position, WorldViewProjection);\n\n    // 버텍스 위치를 월드 공간으로 변환합니다\n    output.WorldPosition = mul(input.Position, World);\n\n    // 어떤 변경도 없이 버텍스 법선을 전달합니다\n    output.Normal = input.Normal;\n\n    // 타일링 요소로 텍스처 좌표를 조정합니다\n    output.TextureCoordinates = input.TextureCoordinates * Tiling;\n\n    // 반사 위치와 월드 매트릭스를 계산합니다\n    float4x4 reflectProjectWorld = mul(ReflectionView, Projection);\n    reflectProjectWorld = mul(World, reflectProjectWorld);\n    output.ReflectionPosition = mul(input.Position, reflectProjectWorld);\n\n    // 굴절 위치는 클립 공간 위치와 동일합니다\n    output.RefractionPosition = output.Position;\n\n    return output;\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n좋아요, 이제 정점 셰이더 부분을 완료했으니 픽셀 셰이더로 넘어갈 수 있겠네요.\n\n# 픽셀 셰이더\n\n## 프로젝티브 텍스처 매핑\n\n먼저, 프로젝티브 굴절 텍스처 좌표를 정규화 장치 좌표 (NDC) 공간으로 변환합니다. 그런 다음, DirectX (DX) 텍스처를 정확히 샘플링할 수 있도록 xy 좌표를 적절하게 조정하여 크기를 조절하고 오프셋을 적용합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```csharp\nfloat4 MainPS(VertexShaderOutput input) : COLOR\n{\n    // 굴절\n\n    float4 refractionTexCoord;\n    refractionTexCoord = input.RefractionPosition;\n\n    // 화면 위치 좌표\n    refractionTexCoord.xyz /= refractionTexCoord.w;\n\n    // 오프셋 조정\n    refractionTexCoord.x = 0.5f * refractionTexCoord.x + 0.5f;\n    refractionTexCoord.y = -0.5f * refractionTexCoord.y + 0.5f;\n\n    // 카메라로부터의 거리에 따라 굴절 더하기\n    refractionTexCoord.z = 0.001f / refractionTexCoord.z;\n    float2 refractionTex = refractionTexCoord.xy - refractionTexCoord.z;\n\n    // 반사\n\n    float4 reflectionTexCoord;\n    reflectionTexCoord = input.ReflectionPosition;\n\n    // 화면 위치 좌표\n    reflectionTexCoord.xyz /= reflectionTexCoord.w;\n\n    // 오프셋 조정\n    reflectionTexCoord.x = 0.5f * reflectionTexCoord.x + 0.5f;\n    reflectionTexCoord.y = -0.5f * reflectionTexCoord.y + 0.5f;\n\n    // 카메라로부터의 거리에 따라 반사 더하기\n    reflectionTexCoord.z = 0.001f / reflectionTexCoord.z;\n    float2 reflectionTex = reflectionTexCoord.xy + reflectionTexCoord.z;\n\n    // 셰이더의 나머지 부분\n}\n```\n\n굴절에 대해서는 카메라로부터의 거리에 따라 텍스처 좌표를 조정하여 굴절 효과를 향상시킵니다. 이 조정을 통해 카메라로부터 더 멀리 있는 객체가 더 많이 굴절되어 물 속 장면을 더 현실적으로 렌더링할 수 있습니다.\n\n반사에 대해서도 반사 텍스처 좌표를 NDC 공간으로 변환하고 카메라로부터의 거리에 따라 조정합니다. 이것은 더 뚜렷한 반사 효과를 만들어냄과 동시에, 카메라로부터 더 멀리 있는 객체가 더 강렬하게 반사되도록 도와줍니다.\n\n## 왜곡 맵 / DuDv 맵\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 위에 표시된 왜곡 맵을 사용하여 반사 및 굴절 텍스처를 샘플링할 예정입니다.\n\n이 맵은 빨간색과 녹색으로 이뤄진, 기본적으로 float2로 이루어져 있습니다. 그러나 이 값들은 항상 이 왜곡 맵에서 양수일 것이므로, 왜곡은 항상 양수일 것이고, 값은 (0.0, 0.0)에서 (1.0, 1.0) 사이입니다. 이 전체적인 리얼리티를 위해 양수와 음수 왜곡을 가질 수 있으면 좋을 것 같습니다.\n\n이 값을 (-1.0, -1.0)에서 (1.0, 1.0) 사이로 변환하기 위해 단순히 2를 곱하고 1을 뺍니다. 그런 다음 이 값을 사용하여 간단히 반사 및 굴절 텍스처 좌표를 왜곡시킵니다.\n\n```js\nfloat2 distortion = (tex2D(distortionSampler, Input.TextureCoordinates)).rg\n                    * 2.0 - 1.0) * WaveStrength;\n\nreflectionTex += distortion;\nrefractionTex += distortion;\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 왜곡은 기본 설정에서 조금 강할 수 있습니다. 그래서 우리는 이 왜곡을 약간 낮추기 위해 이전에 선언한 WaveStrength로 사용할 것입니다.\n\n## 파도 이동하기\n\n물이 움직이는 것처럼 보이게 하는 방법은 Distortion Map을 샘플링하는 위치에 오프셋을 사용하는 것입니다. 이미 이를 선언했는데, 그것이 MoveFactor이며 이 오프셋을 시간이 지남에 따라 변경할 것입니다.\n\n이 효과를 얻기 위해 MoveFactor를 텍스처 좌표의 X 구성 요소에 추가하고 왜곡 맵을 샘플링합니다. 그 후 Y 구성 요소를 위해 두 번째 샘플링을 수행하여 다른 방향으로 추가 왜곡을 적용합니다. 이 프로세스는 왜곡 효과의 현실성을 강화하여 보다 동적인 외관을 만듭니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nfloat2 distortedTexCoords = tex2D(distortionSampler, float2(input.TextureCoordinates.x + MoveFactor, input.TextureCoordinates.y)) * 0.01;\ndistortedTexCoords = input.TextureCoordinates + float2(distortedTexCoords.x, distortedTexCoords.y + MoveFactor);\nfloat2 totalDistortion = (tex2D(distortionSampler, distortedTexCoords).rg * 2.0 - 1.0) * WaveStrength;\n\nreflectionTex += totalDistortion;\nrefractionTex += totalDistortion;\n\n// Sample both texture using the distorted texture coordinates\nfloat4 reflectionColor = tex2D(reflectionSampler, reflectionTex);\nfloat4 refractionColor = tex2D(refractionSampler, refractionTex);\n```\n\n첫 번째 줄에서 0.01을 곱하여 초기 샘플에 적용된 왜곡의 강도를 약간 조정했습니다.\n\n## 프레넬\n\n프레넬 효과가 무엇인지 모르겠다면, Dorian의 아주 좋은 설명을 보여드리겠습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 효과를 구현하려면 다음과 같이 물에서부터의 뷰 방향과 법선을 사용해야 합니다:\n\n```js\nfloat3 viewDirection = normalize(CameraPosition - input.WorldPosition.xyz);\nfloat refractiveFactor = dot(viewDirection, normalize(input.Normal.xyz));\n```\n\n그리고 결과물은 이전에 계산한 refractiveFactor 값을 사용하여 reflectionColor와 refractionColor 사이의 선형 보간값이 될 것입니다.\n\n```js\nfloat4 finalColor = lerp(reflectionColor, refractionColor, refractiveFactor);\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n하지만 아직 끝나지 않았어요! 마지막으로 추가해야 할 것은 노멀 맵과 조명입니다.\n\n## 노멀 맵\n\n노멀 맵을 사용하여 물 표면의 다른 지점에서의 노멀을 나타낼 수 있습니다. 노멀 맵의 어떤 지점의 픽셀 색상은 그 지점에서의 물의 3D 노멀 벡터를 나타낼 수 있습니다. (R, G, B) -` (X, Y, Z). 저는 위에 보여드린 노멀 맵이 대부분 파란색인 이유는 파란 값이 위쪽 축을 나타내며, 우리의 경우에는 Y 축이기 때문입니다.\n\n따라서, 우리는 노멀 맵 색의 파란 구성 요소를 노멀 벡터의 Y 구성 요소로 사용할 것이고, 노멀 맵의 빨간색과 초록색 구성 요소를 노멀 벡터의 X 및 Z 구성 요소로 사용할 수 있습니다. (R, G, B) -` (R, B, G).\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여기서 유일한 문제는 절대 음수 색상을 가질 수 없기 때문에 법선 벡터의 구성 요소도 양수여야한다는 것입니다. Y 구성 요소에 대해서는 문제가 되지 않습니다. 왜냐하면 표면 법선이 어느 정도로든 위로 향하도록 항상 원하기 때문입니다. 그러나 법선이 항상 양의 X 및 Z 방향을 가리키도록 하길 바라는 것은 아닙니다. 법선은 음의 X 및 Z 방향을 가리키도록도 할 수 있어야 합니다.\n\n이를 위해 왜곡 맵에 사용한 것과 동일한 변환을 사용할 것입니다. 2를 곱하고 1을 빼는 것입니다. 그리고 이런 식으로 법선 맵에서 법선 벡터를 추출할 수 있습니다:\n\n```js\nfloat4 normalMapColor = tex2D(normalMapSampler, distortedTexCoords);\nfloat3 normal = float3(normalMapColor.r * 2.0 - 1.0, normalMapColor.b, normalMapColor.g * 2.0 - 1.0);\nnormal = normalize(normal);\n```\n\n이 추출된 법선 벡터를 활용하여 조명 효과를 계산할 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 조명\n\n우리가 사용할 조명 기법은 기본적으로 Blinn Phong 모델입니다. 이에 대해 더 알고 싶다면 여기를 클릭해주세요. 여기서 사용되는 유니폼은 KSpecular, Shininess, LightPosition 및 LightColor 입니다.\n\n먼저, 빛의 방향과 하프 벡터를 구하기 위해 빛 위치와 빛 및 보기 방향의 합을 나타내는 벡터를 정규화합니다.\n\n```js\nfloat3 lightDirection = normalize(LightPosition - input.WorldPosition.xyz);\nfloat3 halfVector = normalize(lightDirection + viewDirection);\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 벡터들을 사용하여, 우리는 NdotL과 NdotH라는 닷 프로덕트를 계산합니다. 이는 각각 노멀 벡터와 라이트 방향, 그리고 노멀 벡터와 하프 벡터 사이의 각도를 나타냅니다.\n\n```js\nfloat NdotL = saturate(dot(normal, lightDirection));\nfloat NdotH = saturate(dot(normal, halfVector));\n```\n\n이 닷 프로덕트를 이용하여, 우리는 Phong 반사 모델 방정식을 적용하여 스펙큘러 광원 기여도를 계산합니다.\n\n```js\nfloat3 specularLight = sign(NdotL) * KSpecular * LightColor * pow(NdotH, Shininess);\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n마지막으로 반사광을 미리 계산된 반사 및 굴절 색과 결합하여 최종 색상 출력을 결정합니다.\n\n```js\n// 최종 계산\nfloat4 finalColor = lerp(reflectionColor, refractionColor, refractiveFactor) + float4(specularLight, 0.0);\n```\n\n그게 다에요! 우리는 물 셰이더를 완전히 성공적으로 만들었습니다! 원하는 대로 매개변수를 조절할 수 있어요. 저는 이렇게 했어요:\n\n```js\nprivate void DrawWater(Matrix world, Matrix view, Matrix projection, Matrix reflectionView, GameTime gameTime)\n{\n    _waterShader.CurrentTechnique = _waterShader.Techniques[\"Water\"];\n\n    _waterShader.Parameters[\"World\"].SetValue(world);\n    _waterShader.Parameters[\"WorldViewProjection\"].SetValue(world * view * projection);\n    _waterShader.Parameters[\"ReflectionView\"].SetValue(reflectionView);\n    _waterShader.Parameters[\"Projection\"].SetValue(projection);\n\n    _waterShader.Parameters[\"ReflectionTexture\"].SetValue(_reflectionRenderTarget);\n    _waterShader.Parameters[\"RefractionTexture\"].SetValue(_refractionRenderTarget);\n    _waterShader.Parameters[\"DistortionMap\"].SetValue(_distortionMap);\n    _waterShader.Parameters[\"NormalMap\"].SetValue(_normalMap);\n    _waterShader.Parameters[\"Tiling\"].SetValue(Vector2.One * 20f);\n\n    _waterShader.Parameters[\"MoveFactor\"].SetValue(WaveSpeed * (float)gameTime.TotalGameTime.TotalSeconds);\n    _waterShader.Parameters[\"WaveStrength\"].SetValue(0.01f);\n\n    _waterShader.Parameters[\"CameraPosition\"].SetValue(_freeCamera.Position);\n    _waterShader.Parameters[\"LightPosition\"].SetValue(_lightPosition);\n    _waterShader.Parameters[\"LightColor\"].SetValue(Color.White.ToVector3());\n    _waterShader.Parameters[\"Shininess\"].SetValue(25f);\n    _waterShader.Parameters[\"KSpecular\"].SetValue(0.3f);\n\n    _quad.Draw(_waterShader);\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그리고 제 경우에는 다음과 같이 보입니다:\n\n![image](/assets/img/2024-05-20-HowtocreateWatershaderinMonogameXNA_4.png)\n\n이 글이 모노게임 그래픽 애플리케이션에서 이 효과를 이해하고 구현하는 데 도움이 되었으면 좋겠어요.\n","ogImage":{"url":"/assets/img/2024-05-20-HowtocreateWatershaderinMonogameXNA_0.png"},"coverImage":"/assets/img/2024-05-20-HowtocreateWatershaderinMonogameXNA_0.png","tag":["Tech"],"readingTime":26},{"title":"AR 게임 만들기","description":"","date":"2024-05-20 16:35","slug":"2024-05-20-MakinganARGame","content":"\n## AFRAME, THREE.js 및 WebXR을 사용하여 4.5시간의 라이브 스트리밍 동안 게임을 만들었어요.\n\n게임의 최종 결과물 .gif (Jiff?)가 여기 있어요. 게임을 플레이하려면 여기를 클릭하세요. 이 게임은 WebXR DOM Overlay API와 WebXR Hit Test API를 사용해요. 그래서 지금 이 게임을 플레이하는 가장 좋은 방법은 모바일 크롬이나 삼성 인터넷 베타를 사용하는 거에요.\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/1*uxubAT7y_4V7U0cUCtEiQg.gif\" />\n\n라이브 스트림의 전체 네 시간 이상을 시청하고 싶다면 다음 URL을 참고하세요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- Part 1: [https://youtu.be/ee7PPDmPuqY](https://youtu.be/ee7PPDmPuqY)\n- Part 2: [https://youtu.be/RWFQ2FqEMi4](https://youtu.be/RWFQ2FqEMi4)\n- Part 3: [https://youtu.be/5XTDOcMU3Vg](https://youtu.be/5XTDOcMU3Vg)\n\n만약 여기서 소스 코드를 살펴보고 싶다면 아래에 있습니다:\n\n첫 번째로 전체 프로젝트를 실시간 스트리밍하는 것이었습니다. 재미있었고, 이런 작은 프로젝트에 대해서 다시 해볼 생각이 있습니다. 이 블로그 포스트에서는 제가 그것을 만드는 데 사용한 도구와 사용된 몇 가지 노하우에 대해 이야기하겠습니다.\n\n## AFrame 설정하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우선 새 HTML 파일을 만드는 것이 중요합니다. index.html이라는 파일을 생성하고 일부 HTML 뼈대를 넣어주세요. 저는 VSCode에서 Emmet 약어를 사용하여 !를 입력하여 기본 HTML을 자동으로 작성합니다.\n\n```js\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>My AR Game</title>\n</head>\n<body>\n\n</body>\n</html>\n```\n\n다음으로 AFrame 스크립트를 추가하기 위해 AFrame 문서에서 스크립트 태그를 복사하여 붙여넣습니다.\n\n```js\n<script src=\"https://aframe.io/releases/1.1.0/aframe.min.js\"></script>\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 테스트\n\n로컬 http 서버를 시작하여 컴퓨터에서 표시할 수 있도록 테스트해봅니다. node http-server 모듈을 사용하겠습니다. 만약 노드 환경이 없다면 Chrome Web Server 확장 프로그램이나 glitch.com과 같은 웹 사이트에서 구축할 수 있는 다른 옵션을 사용할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nWebXR를 실행하려면 안전한 출처가 필요합니다. 안전한 출처는 일반적으로 https://로 시작하지만 특별한 안전한 출처인 http://localhost는 로컬 http 서버에 액세스할 수 있게 합니다.\n\n만약 Glitch를 사용 중이라면 핸드폰에서 URL을 열어서 테스트할 수 있습니다.\n\n안타깝게도 안전한 출처 요구사항은 외부 장치에서 로컬 서버를 테스트하기 까다로워집니다. 일반적으로 개발 컴퓨터에서 IP 주소를 통해 서버에 액세스하지만 http://192.168.0.10:8080과 같은 IP 주소는 안전한 출처가 아니기 때문에 WebXR에 사용할 수 없습니다.\n\n핸드폰에서 테스트하려면 두 가지 옵션이 잘 동작합니다. 가장 편리한 옵션은 핸드폰을 USB로 연결하고 Chrome의 원격 디버깅을 사용하여 http 서버의 포트를 전달하는 것입니다. 이 기능에 액세스하려면 Chrome에서 chrome://inspect를 열어주세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![AR Game Screenshot](/assets/img/2024-05-20-MakinganARGame_0.png)\n\n한번 설정하면 폰에서 컴퓨터에서 하는 것처럼 http://localhost:8080 (8080은 사용 중인 포트로 대체)을 열고 테스트할 수 있어요.\n\n실시간 스트림 중에는 폰의 USB-C 포트를 사용하여 HDMI를 캡처했기 때문에 이 기능을 사용할 수 없었어요. 그래서 로컬 서버를 위한 실제 https: URL을 얻기 위해 https://ngrok.com/을 사용했어요.\n\n## AR 기능 활성화\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nAR을 사용해보면 AFRame 씬에서 장면이 표시되기 전에 장치 카메라를 잠깐 볼 수 있다는 것을 먼저 알아차릴 수 있어요. 이것은 `a-sky` 요소가 전체 장면을 가리기 때문입니다.\n\n이 문제를 해결하기 위해 AR 모드로 전환될 때 객체를 숨기는 새로운 AFrame 컴포넌트를 추가할 거에요. 이 코드는 Klaus Weidner가 AFrame 데모 중 하나에서 작업한 것을 참고했어요:\n\n```js\nAFRAME.registerComponent(\"hide-in-ar-mode\", {\n  init: function () {\n    this.el.sceneEl.addEventListener(\"enter-vr\", (ev) => {\n      if (this.el.sceneEl.is(\"ar-mode\")) {\n        this.el.setAttribute(\"visible\", false);\n      }\n    });\n    this.el.sceneEl.addEventListener(\"exit-vr\", (ev) => {\n      this.el.setAttribute(\"visible\", true);\n    });\n  },\n});\n```\n\n나는 이 스니펫을 프로젝트 간에 복사하는 유용한 컴포넌트 라이브러리에 포함했어요. 다른 유용한 부분들도 함께 있어서 페이지에 그 스크립트를 추가할 거에요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n<script src=\"https://ada.is/basketball-demo/ar-components.js\"></script>\n```\n\n여기에는 hide-in-ar-mode 구성 요소와 Aframe에서 사용할 수 있는 ar-hit-test가 추가됩니다. hide-in-ar-mode 구성 요소를 AR에서 숨기고 싶은 HTML 요소에 추가하면 `a-sky`와 같은 요소를 숨길 수 있습니다. 따라서 다음과 같이 보입니다:\n\n```js\n<a-sky color=\"#ECECEC\" hide-in-ar-mode></a-sky>\n```\n\n다른 문제는 크기입니다. AFrame의 Hello World 예제는 VR용으로 설계되었습니다. VR에서는 물리적으로 큰 장면이 잘 작동합니다. 무제한 공간을 활용할 수 있기 때문입니다. AFrame Hello World 예제에서 컨텐츠는 사용자로부터 5미터 떨어지고 높이가 2.5m인 큰 크기로 배치됩니다. 이는 VR에서 인상적으로 보이지만 AR에서는 많은 사람들의 실제 환경에 맞지 않을 정도로 매우 큽니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nAR 씬을 디자인할 때는 콘텐츠의 크기가 0.5m보다 크지 않도록 하는 것이 좋습니다. 사람들이 그것을 환경에 맞춰놓을 수 있도록 할 수 있으니까요. 작은 아파트에서 살고 있는 사람으로서 이야기하는 거예요.\n\n이 규칙을 어기고 싶을 때는, AR 씬이 외부에서만 사용되도록 설계되었거나 가상 개체가 특정한 치수를 가진 실제 개체를 대신하는 경우입니다. 가구 구매 등 특정 가구 조각을 구입하고 집에 어떻게 맞는지 보고 싶을 때와 같은 상황이죠.\n\n씬을 업데이트하기 위해, 씬 안의 모든 개체를 원래 크기의 10%로 만들었습니다. WebXR과 AFrame의 모든 단위는 미터이기 때문에, 1.25m를 0.125m로 변경했어요 (12.5cm 또는 약 6인치).\n\n## 히트 테스팅 추가하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n히트 테스트는 가상 콘텐츠에서 실제 세계로 광선을 쏘는 것을 의미합니다. 따라서 바닥, 테이블 및 벽과 같은 실제 세계 객체와 일치하게 가상 객체를 배치할 수 있습니다.\n\n히트 테스트를 사용하면 충돌 지점의 위치와 법선을 얻을 수 있어 수직 및 수평 서비스에 객체를 배치할 수 있습니다.\n\n히트 테스트 기능은 사용자 환경에 대한 추가 정보를 얻을 수 있어 WebXR에서 기본적으로 제공되지 않는 기능입니다.\n\n그러나 AFrame에서 XR 세션을 시작할 때 추가 정보를 요청할 수 있습니다. `a-scene` 요소에 webxr 구성 요소를 사용하여 다음과 같이 추가할 수 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n<a-scene webxr=\"optionalFeatures: hit-test;\">\n```\n\n사용 방법을 돕기 위해 앞서 언급한 라이브러리에서 도움이 되는 컴포넌트를 만들었습니다:\n\n```js\n<script src=\"https://ada.is/basketball-demo/ar-components.js\"></script>\n```\n\nar-hit-test 컴포넌트는 가장 관련된 사용자 입력을 사용하여 계속해서 히트 테스트를 수행하여 다양한 하드웨어에서 작동하는 무언가를 구축하는 데 도움을 줄 것입니다. 예를 들어, 헤드셋 위치를 기본으로 사용하지만 가능한 경우 VR 컨트롤러나 핸드 트래킹을 사용할 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n어디에 맞은지와 상관없이 해당 객체를 배치합니다. 이는 AR에서 목표 지시 표시기로 사용하기 편리합니다.\n\n가이드 지시 기호에 사용할 20cm 제곱형을 만들어 보겠습니다:\n\n```js\n<a-plane\n  rotation=\"-90 0 0\"\n  width=\"0.2\"\n  height=\"0.2\"\n  src=\"./arrow.png\"\n  material=\"transparent:true;\"\n></a-plane>\n```\n\n<img src=\"/assets/img/2024-05-20-MakinganARGame_1.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n`div` 태그가 HTML에서 사용되는 것과 유사하게 AFrame에서는 `a-entity`를 사용합니다. 이는 3D 모델과 같은 추가 속성이 없는 일반 요소입니다. ar-hit-test 컴포넌트를 사용하여 위치를 조정하는 새로운 `a-entity`를 만들겠습니다.\n\n```js\n<a-entity ar-hit-test=\"doHitTest:false\" visible=\"false\">\n  Reticle HTML goes here ...\n</a-entity>\n```\n\n우리는 ar-hit-test 컴포넌트가 가능해지면 자동으로 다시 보이도록하는 것이므로 이를 보이지 않도록 만들었습니다.\n\n## 농구 골대 만들기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 우리는 원하는 실제 세계 객체의 위치를 얻는 방법이 있습니다. 벽에 설치할 테스트할 방법을 만들어 보겠습니다.\n\n히트 테스트를 사용하여 표면에 배치된 객체는 그들의 y축(위아래 축)이 배치된 표면의 법선과 정렬됩니다. 이는 바닥에 배치된 객체는 보통 나타날 것이고, 벽이나 천장과 같은 표면에 배치된 객체는 회전될 것임을 의미합니다. 객체는 보통 이 법선 주위로 회전하여 히트 테스트 원본을 향해 정렬되지만, 이 행동은 명세에 포함되어 있지 않으므로 다를 수 있습니다.\n\n벽에 배치된 객체는 90도 회전될 것이므로 설계할 때 약간의 초기 회전을 시작해야 합니다. 따라서 포장 엔터티 #hoop은 rotation=\"90 0 0\"을 가질 것이며, 이는 벽에 배치된 객체와 유사합니다. 만약 바닥에 놓는다면 0 0 0의 회전이 충분합니다. 이 회전은 벽에 객체를 배치할 때 벽의 법선의 방향에 따라 재설정될 것입니다.\n\n후프는 3개의 간단한 모양으로 이루어질 것입니다. 배경 보드를 위한 평면, 후프를 위한 토러스 및 그물을 위한 열린 끝이 있는 원뿔입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 훈련 목표 설명하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n플레이어가 자신의 벽에 후프를 배치할 수 있도록 하고 싶습니다. 이 함수는 후프를 가시적으로 만들고, 선택이 발생할 때 선택한 위치에 후프를 위치시키는 역할을 합니다. 선택을 하면 함수가 호출됩니다. 하지만 이 단순한 함수는 후프를 조금 비스듬하게 만들 수 있습니다. 후프가 히트 테스트 원점을 향하도록 기울어져 있지만 정렬하기가 어려울 수 있습니다. 따라서 후프의 z 방향이 y 축과 일치하도록 하기 위해 일부 백터 수학을 사용해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n조금 더 복잡한 함수는 시야를 수직 위치로 회전시키기 위해 필요한 쿼터니온 회전을 계산할 것입니다. 그런 다음 해당 회전과 시야의 회전을 곱하여 후크의 쿼터니온 회전을 설정합니다. 결과적으로, 방향이 올바른 후크가 만들어지지만 약간 휘어져 있어 상단을 가리킵니다.\n\n## 씬에 물리학 추가하기\n\n물리는 매우 유용한 aframe-physics-system에 의해 처리됩니다. 이를 통해 씬 안의 객체들이 물리적으로 현실적인 방식으로 행동하도록 할 수 있습니다.\n\n물리학 객체에는 두 가지 유형이 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 정적 바디는 움직이지 않고 다른 객체에 부딪혀도 반응하지 않습니다. 사실상 무한한 질량을 가지고 있으며 중력의 영향을 받지 않습니다. 사용하기는 저렴하지만 움직일 수 없습니다. 움직이지 말아야 하는 것은 바닥, 벽 및 이 경우 농구 골대와 같은 정적 바디여야 합니다.\n- 동적 바디는 질량을 가지며 중력에 의해 일정한 가속도로 떨어집니다. 정적 바디에서 튕길 수 있거나 다른 동적 바디와 충돌할 수 있습니다. 장면에서 유일한 동적 바디는 공 자체입니다.\n\n물리 시스템을 설정하려면 A-Frame 스크립트 다음에 스크립트를 추가하고 물리 컴포넌트를 장면 요소에 추가하십시오.\n\n```js\n<script src=\"https://cdn.jsdelivr.net/gh/n5ro/aframe-physics-system@v4.0.1/dist/aframe-physics-system.min.js\"></script>\n...\n<a-scene physics=\"debug: false\">\n```\n\n장면을 설정하는 데 도움이 필요하면 디버그 값을 true로 설정하여 만들어진 모양을 빨간색 윤곽으로 볼 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음은 다이나믹-바디 컴포넌트가 적용된 구를 추가합니다. 이 구가 공이 될 것입니다.\n\n```js\n<a-sphere\n  id=\"ball\"\n  dynamic-body\n  radius=\"0.1\"\n  color=\"orange\"\n  position=\"0.1 2.36 -1.5\"\n></a-sphere>\n```\n\n페이지를 새로고침하면 공이 계속해서 떨어질 것입니다.\n\n다음 단계는 바닥면에 스태틱-바디를 추가하여 공을 막을 수 있는 물체를 만드는 것입니다. 또한, 공이 바닥면에 부딪히면 구를 굴릴 수 있도록 바닥면을 훨씬 크게 만들었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n<a-plane\n  rotation=\"-90 0 0\"\n  width=\"20\"\n  height=\"20\"\n  color=\"#43A367\"\n  static-body\n  hide-in-ar-mode\n></a-plane>\n```\n\n게임을 플레이할 때 후프와 상호 작용하고 싶습니다. 그래서 다음에는 백보드 평면에 static-body를 추가할 것입니다.\n\n후프에 대해 어떻게 해야 할까요? 이것은 훨씬 더 복잡합니다. 후프는 볼록한 객체이며 상당히 복잡한 위상을 가지고 있으며 3D 모델에는 많은 정점이 있어서 물리학적으로 매우 비싸지게 만듭니다.\n\n여기서 꼼수는 가능한 한 많은 다각형을 가진 보이지 않는 토러스를 가지는 것입니다. 그것을 정적 바디로 만들지만 보이지 않게 하고 고해상도 모델 위에 놓습니다. 이것은 비디오 게임에서 공개된 객체보다 훨씬 간단한 기하학을 가진 물리 객체를 가지는 것이 일반적인 꼼수입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```yaml\n<table scale=\"0.6 0.6 0.6\" static-body=\"shape: mesh;\" position=\"0 0.173 -0.1\" visible=\"false\" radius=\"0.27\" radius-tubular=\"0.02\" geometry=\"radius: 0.29; segmentsRadial: 5; segmentsTubular: 12\">\n</table>\n```\n\n훌륭한 점을 홀의 정적 객체를 홀 엔티티 안에 두면 시각적 객체와 일관되게 유지됩니다.\n\nAFrame 물리 시스템에는 두 개의 객체가 충돌했을 때 감지하거나 객체의 속도를 설정하기 위한 JavaScript API가 있습니다. 원하는 엔티티의 body 속성을 사용할 수 있습니다. 단, 이는 정적 또는 동적 body여야 합니다.\n\n볼과 같은 객체의 위치와 속도를 설정하려면 이 메서드를 사용합니다. 현재 활성 컨트롤러에서 공을 발사하는 방법은 다음과 같습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nconst ball = document.getElementById(\"ball\");\nreticle.addEventListener(\"select\", function (e) {\n  // Set the ball location to the controller position\n  const pose = e.detail.pose;\n  ball.body.position.copy(pose.transform.position); // {x, y, z}\n  // Have an initial velocity vector of 5ms into the screen\n  tempVector.set(0, 0, -5);\n  // Set our velocity vector direction to the controller orientation\n  // {x, y, z, w}\n  tempVector.applyQuaternion(pose.transform.orientation);\n  // set the velocity of the ball to our velocity vector\n  ball.body.velocity.copy(tempVector);\n});\n```\n\n## Dom Overlay\n\nThe last thing we need is to make some UI so that the user can say when they have set the hoop position and are ready to play. We can build a normal HTML interface for this:\n\n```js\n<div id=\"overlay\" class=\"container\">\n  <h1>Welcome To Basketball</h1>\n  <section class=\"overlay-content\">\n    <p id=\"instructions\">Place the basket along a wall</p>\n  </section>\n  <div style=\"display: flex; justify-content: space-between; align-self: stretch;\">\n    <button id=\"go-button\">Ready to Play!</button>\n    <button id=\"exit-button\">Stop AR</button>\n  </div>\n</div>\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그럼 웹XR 컴포넌트에서 scene 객체에 그것을 선언하여 사용할 수 있습니다:\n\n```js\n<a-scene webxr=\"optionalFeatures: hit-test, dom-overlay; overlayElement:#overlay;\" >\n```\n\n실제 HTML 버튼과 텍스트를 사용하면 사용자에게 많은 이점이 있습니다. 접근성 도구와 함께 작동하며 더 읽기 쉽습니다. 일반적인 CSS로 스타일을 지정할 수 있고 일반적인 JavaScript로 코딩할 수 있습니다.\n\n다만 유의해야 할 점은 사용자가 DOM 오버레이 요소를 탭하면 `click`, `mousedown`, `touchstart`와 같은 입력 이벤트가 일반적으로 발생하나 추가로 WebXR `select` 이벤트가 먼저 발생한다는 것입니다!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n'`select`' 이벤트에서 HTML 버튼으로부터의 입력을 기다리는 중이라면 버튼이 눌러지지 않았는지 확인하기 위해 `setTimeout`을 사용해야 할 수 있습니다.\n\nDOM 오버레이 지원을 감지하려면 xrsession.domOverlayState.type를 찾아보세요. domOverlayState가 설정되어 있지 않으면 브라우저에 domOverlay가 없습니다. type이 설정되어 있지 않으면 현재 하드웨어/브라우저 구성이 DOM Overlay를 지원하지 않으므로 다음 함수를 사용하여 확인할 수 있습니다:\n\n```js\nfunction hasDomOverlay(xrsession) {\n  if (!xrsession.domOverlayState) {\n    // DOM Overlay가 지원되지 않습니다\n    return false;\n  }\n  if (!xrsession.domOverlayState.type) {\n    // DOM Overlay가 사용되지 않았습니다\n    return false;\n  }\n  return true;\n}\n```\n\n필수 경로에 DOM 오버레이를 사용 중이라면 이를 사용하여 가용성을 감지하고 대체 동작을 제공할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 완성된 데모의 소스 코드 읽기\n\n여기 데모의 소스 코드가 있어요. 이 가이드가 도움이 되어 데모 소스 코드와 의사 결정에 대해 이해하는 데 도움이 되기를 바랍니다. 더 궁금한 점이 있다면 트위터를 통해 연락해 주세요.\n\n읽어 주셔서 정말 감사합니다!\n","ogImage":{"url":"/assets/img/2024-05-20-MakinganARGame_0.png"},"coverImage":"/assets/img/2024-05-20-MakinganARGame_0.png","tag":["Tech"],"readingTime":17},{"title":"제발, 게임을 평가할 때 재미있는이라는 단어를 그만 사용해 주세요","description":"","date":"2024-05-20 16:33","slug":"2024-05-20-PleasestopusingFuntojudgeagame","content":"\n게임은 “즐거운” 것이 될 수 있지만, 게임의 가치를 측정하는 유일한 방법은 아닙니다.\n\n![Image](/assets/img/2024-05-20-PleasestopusingFuntojudgeagame_0.png)\n\n게임 디자인 서적을 읽으며, 게임 디자인 강의를 듣고, 게임 속에서 게임 디자인을 분석하는 동안 항상 고민해왔습니다. 게임을 “좋은” 것으로 만드는 것은 무엇일까요? 중요한 이야기일까요? 매력적인 게임플레이 루프일까요? 아니면 게임의 소셜 기능들이 중요한 걸까요?\n\n하지만 일반 게이머에게 물을 때, 대개 돌아오는 말은 “즐거움”이라는 단어입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저는 항상 이 단어에 문제가 있었습니다. 이것은 완전히 주관적인 모호한 용어가 아니라 게임이 상호작용하는 예술 형태로서의 잠재력에 대한 깊은 토론을 완전히 배제하는 것입니다.\n\n계속 진행하기 전에, 우리는 \"즐거움\"이라는 단어를 명확히 정의해 봅시다. 옥스포드 사전은 \"가벼운 즐거움, 즐거움 또는 오락\"이라는 정의를 사용합니다. 저는 언어 체계에 갇히고 싶지 않기 때문에 이 정의를 사용하겠습니다.\n\n제가 어렸을 때 가장 좋아했던 게임 디자인 책 중 하나는 Scott Roger의 \"Level up! The Guide to Great Video Game Design\"이었습니다. 정말 솔직한 책이었는데, Scott은 게임 디자인에 대해 너무 소박하고 접근하기 쉽게 썼기 때문에, 저는 헌신적인 게임 디자이너로 자신의 글쓰기 스타일을 접목시켰습니다.\n\n![이미지](/assets/img/2024-05-20-PleasestopusingFuntojudgeagame_1.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n어쨌든, Scott는 자신의 책에 \"왜 '즐거움'을 싫어하는지\"라는 섹션이 있다. Scott는 \"즐거움\"이 너무 모호하고 주관적인 용어로 유용하지 않다고 주장하며, 제작 과정에서 그것을 달성하는 것은 어려운 작업이라고 말합니다. Scott는 게임 개발자들이 게임을 한 번 또 한 번, 또 한 번 해야만 모든 부분이 완벽한지 확인해야 한다고 이어집니다.\n\nScott는 여전히 게임은 \"즐거워\"야 한다고 주장하지만, \"즐거운\" 요소를 없애는 디자인 철학을 통해 그렇게 되어야 한다고 이어집니다. 이는 형편없는 카메라 각도, 이상한 컨트롤, 나쁜 레벨 디자인일 수 있습니다.\n\n그러나, 나는 여전히 우리가 대중의 의식에서 \"즐거움\"을 없애야 한다고 주장합니다. 나에게, 게임의 가치는 플레이어에게 어떤 경험을 제공하고자 하는지에 달려있습니다.\n\n철학적인 문제를 논의해 봅시다. 공포 게임을 즐기면 좋은 공포 게임인가요? 보통, 공포 게임은 플레이어를 압도하고 끊임없이 불안하게 만드는 것이 목적입니다. 플레이어가 \"즐거움\"을 느낀다면, 그것은 게임의 공포 분위기에 흠뻑 빠져들기가 매우 어려워지는 것으로 보입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n어쩌면 스토리가 중심인 게임을 살펴보자. 여기서 The Last of Us Part 2의 초기 스포일러가 포함되어 있습니다. The Last of Us: Part 2는 이전 게임의 주인공 Joel Miller가 끔찍한 방식으로 죽음을 맞이하는 초기 스토리 장면으로 인해 많은 팬들을 괴롭히는 논란이 일었어요. 이것은 \"즐거운\" 경험이 아니지만 그 의도는 그렇지 않았어요. 분노, 역겨움, 공포를 느끼게 하려는 거예요.\n\n2016년의 Final Fantasy XV에서는 약속된 감동적인 모험이 시작되는 동안 다양한 캐릭터들과 함께하는 흥미진 질주의 약속을 했어요. 상자 뒷면과 트레일러에서는 매료하는 전투 시스템과 잊지 못할 세계를 약속했어요. 그런데 게임을 10분쯤 플레이하면서 친구들과 함께 길 가운데에서 차를 밀고 가는 장면들이 나와요. 이 곳에서의 게임 요소는 앞쪽으로 방향키를 누르는 것 뿐이에요. 이 장면의 목표는 \"즐거움\"을 느끼기 위함이 아니라, 캐릭터의 신발에 서서 동정심을 느끼게 하는 것이에요. 그들은 인류를 구할 수도 있는 행동을 맡은 몹시 어리석은 사람들이에요. 이것은 결속의 순간이에요!\n\n때로는 \"즐거움\"의 완전 반대가 되는 게임들도 있어요. 이미 두 게임에 대해 깊게 다뤘지만 다시 한 번 언급해보려고 해요. 특히 나에게 Kane & Lynch 2: Dog Days와 같은 게임은 가능한 한 불쾌하게 설계되었어요. 특히, Kane & Lynch 2는 진짜처럼 처리하기 어려운 총격전을 하나 뒤에 하나 거치게 하며, 정신없이 느껴지는 무기와 만회할 가치 없는 캐릭터, 그리고 엉망인 결말이 있어요. Cruelty Squad는 플레이어에게 접근하기 어렵게 설계되었고, 계속해서 뭔가를 망치고 있다고 느끼게 해요. 게임의 컨트롤은 고의로 형편없으며, 시각적으로 사이키텔릭하고 혼란스럽게 만들어졌어요. 이 게임들은 예술의 작품이며, 그래서 나에게는 \"즐거움\"을 유일한 판단 기준으로 사용하는 것이 상호 조작 매체에 대한 큰 불친절을 의미한다고 생각해요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![](/assets/img/2024-05-20-PleasestopusingFuntojudgeagame_3.png)\n\n당연히 \"재미\"는 그 자리가 있어요. 마리오 카트와 같은 게임은 \"재미\"를 주요 목적으로하여 설계되어, 그 모든 메커니즘이 그 주위에 설계되었습니다. 그것은 분명히 작동합니다! 마리오 카트는 모두 경쾌한 \"재미\"에 초점을 맞춰서 그것이 좋습니다.\n\n하지만 전 개인적으로 게임은 단일 음절로 제대로 설명할 수 없는 것들입니다. 우리는 대신 \"매혹적인\"과 같은 다른 단어를 사용할 수 있지만, 게임들은 — 나에게는 — 일상적인 말을 초월한다고 생각합니다.\n\n둠: 에터널은 악마를 죽이는 것, 지옥을 세우는 악당이 된 느낌을 주도록 설계되어, 적들을 향한 무분별한 파괴 행위를 장려합니다. 레지던트 이블 4는 적대적인 환경에서 생존하려고 하면서 긴장하고 긴장하게 만들도록 설계되었습니다. 로보캅: 로그 시티는 당신이 로보캅이 되는 느낌을 주도록 설계되었습니다! 이러한 게임을 \"재미\"를 중심으로 설계하면, 디자이너가 만들고자 했던 취지를 달성하기가 훨씬 어려울 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![2024-05-20-PleasestopusingFuntojudgeagame_4](/assets/img/2024-05-20-PleasestopusingFuntojudgeagame_4.png)\n\n그래서 저는 상호작용 경험을 디자인할 때 \"즐거움\"을 목표로 삼는 것이 ultimately 잘못된 것이라고 생각합니다. 게임은 자신이 원하는 대로 할 수 있으며, 단일 음절 주위에 게임을 디자인하는 것은 그들의 더 넓은 잠재력을 보다 넓은 대중문화로 제한시킬 수 있습니다.\n\n물론, 이것은 매우 마음먹은 생각입니다. 게임은 물론 돈을 버는 것으로 디자인되었고, 잠재적 구매자를 이해하지 못하거나 기이하게 만드는 게임을 만드는 것은 투자가로부터 재정 파탄을 외치는 것입니다. 항상 그렇지는 않지만 종종 그렇습니다.\n\n그럼에도 불구하고, 게임이 \"즐거움\"이나 \"매료되는 정도\"로 넘어가는 제대로 된 분석을 받을 자격이 있다고 생각합니다. 가능한 한 빨리 우리가 상호작용 경험으로서 게임이 제공하는 존경을 보다 많은 사람들에게 제공할수록, 그들이 인간 문화에 자리 잡을 수 있는 독특한 경험을 제공하기 위해 노력할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\"재밌다\" 카운터: 23.\n\n제 글을 읽어주셔서 감사합니다! 제가 쓰는 만큼 여러분이 읽는 데에도 “재미”가 있었으면 좋겠네요. 아래에 의견을 남겨주시고, Twitter에서 저를 팔로우하거나 LinkedIn에서 연락을 주시는 것도 좋아요. 저의 다음 글을 기대해주세요.\n\n안녕히 가세요!\n","ogImage":{"url":"/assets/img/2024-05-20-PleasestopusingFuntojudgeagame_0.png"},"coverImage":"/assets/img/2024-05-20-PleasestopusingFuntojudgeagame_0.png","tag":["Tech"],"readingTime":6},{"title":"C를 스크립팅 언어로 활용하기, 제13부","description":"","date":"2024-05-20 16:32","slug":"2024-05-20-UsingCasaScriptingLanguagepart13","content":"\n힙 관련 함수 최적화\n\n게임을 만들 때 병목 구간이 되지 않는 많은 부분이 있습니다. 그런 섹션에서는 종종 안전하고 표준적인 코드를 작성합니다. 보통 임시 힙 할당이 포함된 코드입니다.\n\n프로그램이 무엇을 하는지 모니터링할 수 있는 heap 및 다른 시스템 호출에 대한 상세한 설정이 있습니다. 그러나 실제 이야기는 RISC-V 어셈블리를 읽는 데 있습니다. C++에서 new를 호출하면 먼저 빈 래퍼로 이동한 다음 실제 C++ new 함수로 이동합니다. 그러면 다시 내 힙 시스템 호출 래퍼를 호출하고 최종적으로 시스템 호출을 호출합니다. C++에서는 new가 할당이 실패하면 예외를 throw할 수 있지만 여기에선 무시됩니다. 모든 것을 제어하고 있기 때문입니다. 할당에 실패하면 에뮬레이터가 예외를 throw합니다. 메모리가 부족하거나 실행 시간이 너무 길어지면 마찬가지입니다. 그러므로 new 호출 체인을 피하고 최상의 경우에는 직접 시스템 호출을 호출하고 싶습니다.\n\n이에 대한 간단한 벤치마크를 만들었습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nBenchmarking it, it took around 50ns. That’s not too bad. But, it can be improved just by avoiding all the calls that do nothing but call another function.\n\nSo, the first thing to do is to call the system call wrapper directly. This meant that I had to forego the return value from free, because in C the free function doesn’t have a return value. Otherwise the A0 register would be clobbered, and I would have a very mysterious bug on my hands. Running it, I found that it heavily reduced the run-time, now at 31ns. A 38% run-time reduction.\n\nThe last thing to try, was to write inline functions for new and delete, which would call my inline assembly functions sys_malloc and sys_free:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n인라인 void* sys_malloc(std::size_t size) {\n  register void*   ret asm(\"a0\");\n  register size_t  a0  asm(\"a0\") = size;\n  register long syscall_id asm(\"a7\") = SYSCALL_MALLOC;\n\n  asm volatile (\"ecall\"\n  : \"=m\"(*(char(*)[size]) ret), \"=r\"(ret)\n  : \"r\"(a0), \"r\"(syscall_id));\n  return ret;\n}\n인라인 void  sys_free(void* ptr)\n{\n  register void*  a0  asm(\"a0\") = ptr;\n  register long syscall_id asm(\"a7\") = SYSCALL_FREE;\n\n  asm volatile (\"ecall\"\n  :\n  : \"r\"(a0), \"r\"(syscall_id));\n}\n\n이제 ret이 레지스터 A0을 재할당하는 것을 명시하는 것을 기억해야 했지만, 모든 테스트, 벤치마크 그리고 제 게임에서 모두 잘 실행되었습니다. 지금까지 잘 되고 있어요. 벤치마크 실행 시간은 미친 듯한 19ns로 나왔어요.\n\n0000000050000b94 <_ZL16bench_alloc_freev>:\n    50000b94:   40000513                li      a0,1024\n    50000b98:   23a00893                li      a7,570\n    50000b9c:   00000073                ecall\n    50000ba0:   00050663                beqz    a0,50000bac <_ZL16bench_alloc_freev+0x18>\n    50000ba4:   23d00893                li      a7,573\n    50000ba8:   00000073                ecall\n    50000bac:   00008067                ret\n\n어셈블리를 살펴보니, 완벽해 보이고, 더 이상 개선할 수 없을 것 같아요. 실행 속도가 너무 빨라서 당연히 이렇게 되는 거예요. 거의 네이티브 성능에 가깝습니다.\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/assets/img/2024-05-20-UsingCasaScriptingLanguagepart13_0.png)\n\nwasmtime을 malloc() - free() 콤보로 실행했고, 평균 66ns가 걸린 것을 발견했어요. 48ns의 호출 오버헤드를 뺀 18ns의 런타임이 편안하게 나왔어요. 정말 빠른 속도죠. 이제는 제가 만든 힙 할당기가 문제인지 궁금해졌어요. 아마 맞겠죠? 지배적일 것입니다. 여기 차트가 있어요:\n\n![차트](/assets/img/2024-05-20-UsingCasaScriptingLanguagepart13_1.png)\n\n더 빠른 힙 할당기를 작성할 에너지가 없을 것 같아요. 특히, 내 힙 할당기가 견고하고 잘 테스트되어 있을 때 말이에요. 오랜 시간 잘 돌아가다가 이상한 메모리 조각화도 그리 심하게 일어나지 않아요. 게임을 만드는 것이 중요한데, 그럴 때 힙 할당기 같은 기본 할당기를 바꾸는 게 무서울 때가 있죠.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그래도 괜찮네요. 제가 가까이 왔군요!\n\n-곤조\n","ogImage":{"url":"/assets/img/2024-05-20-UsingCasaScriptingLanguagepart13_0.png"},"coverImage":"/assets/img/2024-05-20-UsingCasaScriptingLanguagepart13_0.png","tag":["Tech"],"readingTime":4},{"title":"글 제목 스타일로 번역하면 충격 AI가 코드 품질을 파괴한다 입니다","description":"","date":"2024-05-20 16:31","slug":"2024-05-20-SHOCKINGAIDestroysCodeQuality","content":"\n![이미지](/assets/img/2024-05-20-SHOCKINGAIDestroysCodeQuality_0.png)\n\n소프트웨어 엔지니어링에서 가장 큰 적은 기술 부채가 아닙니다. 코드 회전율이죠. 코드가 작성된 직후에 바로 변경되는 것입니다. 이는 문제의 지표뿐만 아니라 문제의 원인이 될 수도 있습니다.\n\n따라서 이 그래프를 보면 무언가 잘못되었음을 알 수 있습니다. 알아요 무엇 인가요? AI입니다. AI가 우리의 코드를 파괴하고 있어요. 조금 더 이야기를 나누어서 우리가 할 수 있는 대책을 찾아봐요.\n\n![이미지](/assets/img/2024-05-20-SHOCKINGAIDestroysCodeQuality_1.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 증거를 살펴봅시다\n\nGitClear는 AI 코드 생성 도구가 코드 품질에 어떤 영향을 미쳤는지에 대한 백서를 공개했습니다. 그 영향이 좋지 않다는 것을 알아야 합니다 (그들은 1억 5천만 줄 이상의 코드를 바탕으로 판단하고 있습니다).\n\n그들이 발견한 급증하는 코드 변동은 심각한 문제를 가리킵니다. AI는 \"복사-붙여넣기\"를 촉진하고 추가적인 코드 줄을 얼마나 빨리 추가할 수 있는지에 초첨을 맞추고 있습니다. 우리는 전혀 코딩 속도를 평가 지표로 삼아서는 안됩니다.\n\n# 속도 != 품질\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nGitHub은 코파일로 코드를 \"55% 더 빠르게\" 작성할 수 있다고 주장합니다. 개발자들은 그것을 좋아하고 새로운 코드를 만들고 기능을 제공하는 것을 즐긴다.\n\n문제는 로버트 C. 마틴(저는 그의 의견에 동의하는 편이 거의 없습니다)이 코드가 작성되는 것보다 10배 더 많은 시간을 읽는다고 주장한다는 것입니다.\n\n제 경험을 듣는 편이 더 좋을 것 같아요. 초보 개발자들이 \"코드를 밀어붙이기\"에 열중하는 것을 보았습니다. 그들은 예전보다 더 빠르게 진행하고 우리 코드베이스에 더 많은 요소를 추가하고 있습니다. 그것은 나중에 그 코드를 정리해야 하기 때문에 짜증납니다. 재사용 가능한 요소를 추출하는 작업 등이 필요합니다. 최근 팀과 몇 시간 동안 싸워야 했어요. 어떤 재사용 가능한 코드가 사실 재사용 가능하지 않고 우리 코드베이스로 넣지 말아야 할 거라고 막기 위해서 싸워야 했던 일이 있었습니다.\n\n![image](/assets/img/2024-05-20-SHOCKINGAIDestroysCodeQuality_2.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n더 이상 신중하고 깊은 사고 없이 코딩하는 방식으로의 전환은 우리 저장소의 품질을 희석시킬 뿐만 아니라, 위대한 소프트웨어 개발을 정의하는 장인 정신을 약화시키는 것입니다. AI에게 직장을 잃어버릴 걱정은 없어요. 이런 상황이 계속된다면 분야에서 훌륭한 소프트웨어 개발자가 남지 않을 것을 걱정합니다.\n\n# 복사 붙여넣기의 매력\n\n복사 붙여넣기 생활. 스택 오버플로우나 좋아하는 AI를 통해 코드를 찾아서 코드베이스에 넣습니다. 개발자는 기능을 개발함으로써 도파민 분비를 받고 모든 것이 잘 되어 있습니다.\n\n개발자들은 새로운 기능을 만드는 것을 좋아하지만, 복사 붙여넣은 코드는 종종 유효기간을 초과하여 지속됩니다. 중복 코드를 제거할 권한이 있는 팀원이 있나요? 불행하게도, 우리 팀에는 중복 코드를 제거하기 위한 문화가 없어서 코드베이스가 고통받고 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n나는 이것이 기술 부채 문제뿐만 아니라 문화적 문제라고 생각해요.\n\n## ‘소방관 스타일’ 개발자 치료하기\n\n코드를 코드베이스에 넣는 것은 견고한 습관과 지식의 한 줌이 필요해요. '의존적 결정'을 내리는 AI를 훈련시키는 대신에 품질 높은 개발자를 얻을 수 있어요.\n\n나는 개발자를 위한 훈련 프로그램을 서두르라는 의미가 아니라 BOK를 개발하고 소프트웨어 개발자에게 그들의 지식과 성과에 대한 책임을 물어야 한다는 의미에요. 유지보수 가능한 코드를 생산할 전략을 이해하고 문제를 품질 높은 방식으로 해결할 지혜 있는 팀이 필요해요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그러면 우리 고문들은 낙차 코드를 이해하는 데 많은 시간과 노력을 들이지 않아도 되고, 그 코드를 유지하는 데 어려움을 겪지 않을 거에요. 어때요?\n\n# 결론\n\n우리가 이 AI 기술을 이용한 미래를 항해하는 동안, 좋은 소프트웨어 개발을 오랫동안 이끌어 온 원칙들인 명확성, 유지보수성, 그리고 무엇보다도 품질에 대한 헌신을 잊지 말아야 해요. 앞으로의 여정은 AI로 포장되어 있을 수 있지만, 우리의 작품의 질을 희생하지 않으면서 목적지에 도착할 수 있도록 하는 것은 인간의 손길이 될 거에요.\n\n# 저자 소개\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n프로 소프트웨어 개발자 \"비밀 개발자\"는 Twitter에서 @TheSDeveloper로 찾을 수 있으며 주로 Medium.com을 통해 기사를 게시합니다.\n\n비밀 개발자는 여전히 Copilot보다 빠릅니다.\n","ogImage":{"url":"/assets/img/2024-05-20-SHOCKINGAIDestroysCodeQuality_0.png"},"coverImage":"/assets/img/2024-05-20-SHOCKINGAIDestroysCodeQuality_0.png","tag":["Tech"],"readingTime":4},{"title":"Udemy의 2024년에 참여할 Top 6 시스템 디자인 인터뷰 코스","description":"","date":"2024-05-20 16:29","slug":"2024-05-20-Top6SystemDesignInterviewCoursesfromUdemytojoinin2024","content":"\n## 2024 시스템 디자인 면접을 준비하는 데 도움이 되는 내가 좋아하는 Udemy 온라인 강의\n\n![이미지](/assets/img/2024-05-20-Top6SystemDesignInterviewCoursesfromUdemytojoinin2024_0.png)\n\n안녕하세요 여러분, 소프트웨어 엔지니어 또는 소프트웨어 개발자 채용 면접을 준비하고 있다면, 시스템 디자인을 준비하는 것이 얼마나 중요한지 아실 것입니다. 특히 Amazon, Google, Meta, Apple 및 Netflix와 같은 최고의 기업에서 개발자 채용을 하길 원한다면 더욱 그렇습니다.\n\n과거에 저는 시스템 디자인 면접 준비를 위한 최고의 System Design Interview Books, 웹사이트, 인기 있는 소프트웨어 디자인 연습 문제와 같은 여러 자료를 공유했었고, 오늘은 Udemy에서의 최고의 시스템 디자인 강좌를 소개하려 합니다. 저의 기술 관련 학습을 위한 가장 좋아하는 장소 중 하나인 Udemy입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n요! Udemy를 선택한 이유는 주로 가격 때문이에요. 이 가격으로 최고 품질의 50시간 이상 강좌를 찾을 수 있는 다른 곳은 없어요.\n\n가격 외에도 선택의 다양성이 Udemy를 선호하는 이유 중 하나에요. 온라인 강좌 시장에서 가장 크며, 다양한 선택지가 준비돼 있어요.\n\n강좌를 수강하다 강사나 그의 설명 방식, 내용을 좋아하지 않는다면 환불을 요청하여 다른 강좌를 선택할 수 있어요. 이런 시설은 Educative나 Pluralsight와 같은 정기 구독 사이트를 제외하고 다른 곳에서는 찾아보지 못한 것이에요.\n\n그래서, 저는 시스템 디자인 강좌를 수강하기 위해 항상 Udemy로 가요. 오늘은 제 컬렉션에서 몇 가지 보석을 공유할 거에요. 그리고 급하다면, Frank Kane이 강의하는 'Mastering the System Design Interview'에 가입하세요. 이 강좌는 아마존 출신 채용 담당자가 시스템 디자인 면접에서 성공하기 위한 정확한 프로세스와 내부 팁을 제공하는 5시간 강좌에요. FAANG나 MAANG 회사의 시스템 디자인 면접을 통과하는 데 도움이 될 거에요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![image](/assets/img/2024-05-20-Top6SystemDesignInterviewCoursesfromUdemytojoinin2024_1.png)\n\n지금 이 강의를 $10에 구매할 수도 있어요. Udemy가 가장 큰 세일을 진행하고 있거든요. 올해에 인기 있는 기술을 배우기 위해 50개 이상의 강좌를 이미 구매했어요. 이 강좌도 할인가에 가입할 수 있어요. 나중에 감사할 거에요.\n\n# 2024년에 Udemy에서 가입할 수 있는 최고의 시스템 디자인 강좌 6가지\n\n더 이상 말이 필요 없이, 여기 Udemy에서 가입할 수 있는 내가 좋아하는 시스템 디자인 강좌들이에요. 이 시스템 디자인 강좌들은 시스템 디자인 전문가들과 현재 및 전 FAANG 직원들에 의해 만들어졌어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n친구들, 이들은 후보로서 면접에 합격한 것뿐만 아니라 채용 담당자로서도 인터뷰를 진행한 경험이 있어.\n\n이들 경험 많은 전문가들로부터 많은 것을 배울 수 있고, 이런 강좌는 여러분에게 그런 기회를 제공해줍니다. 시스템 디자인 면접 준비를 진지하게 생각한다면, 분명히 이런 강좌들을 좋아하실 거에요.\n\n## 1. Frank Kane의 Mastering the System Design Interview\n\n이 강좌는 나가 Udemy에서 가장 먼저 들은 시스템 디자인 면접 코스 중 하나에요. Frank Kane을 Big Data와 Scala 강좌에서 알고 있었고, 그의 수업 방식과 내용에 큰 팬이었어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그래서 그가 시스템 디자인 강좌를 출시했을 때, 나는 즉시 강좌에 가입했고, 실망하지 않았다고 말해야 해.\n\n이 강좌는 캐싱, 확장성, 샤딩, 보안, 그리고 소프트웨어 아키텍처와 같은 주요 시스템 디자인 개념뿐만 아니라, 수평 및 수직 스케일링의 차이, 그리고 API 게이트웨이 대 로드 밸런서와 같은 시스템 디자인 질문에 대한 자주하는 질문도 대답한다.\n\n이 강좌는 빅데이터, ACID 속성, 데이터 구조 및 알고리즘을 다루는 것뿐만 아니라, 시스템 디자인 인터뷰 압력을 처리하는 전략을 나누고 시스템 디자인 질문에 대한 대답 방법도 소개한다.\n\n실습 과정에서 URL 단축, 웹 크롤러와 같은 인기 있는 시스템 디자인 문제를 해결하고 지식을 적용하는 방법을 배운다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n소셜 증거에 대해 얘기하자면, 이미 62,373 명 이상의 학생이 이 강좌에 참여했고, 약 8800명의 평가자로부터 평균 평점이 4.6인, 놀라운 강좌입니다.\n\nFrank은 이 강좌로 놀라운 일을 해냈습니다. 2024년 시스템 디자인 면접을 준비하는 분들에게 강력히 추천합니다.\n\n다음은 이 강좌에 가입할 수 있는 링크입니다 - Frank Kane의 Mastering the System Design Interview\n\n![이미지](/assets/img/2024-05-20-Top6SystemDesignInterviewCoursesfromUdemytojoinin2024_2.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 2. Rajdeep Saha의 Rocking System Design\n\nFrank의 강좌의 대안이 필요하다면, Rajdeep Saha가 제공하는 Rocking System Design 강좌를 확인해보세요. 이 강좌는 나에게 가장 처음 접한 Rajdeep의 강좌였는데 그 전에는 그를 몰랐어요. Rajdeep은 AWS 솔루션 아키텍트이며 그의 강좌에서 그것이 드러납니다.\n\n이 강좌에서는 면접에서 시스템 디자인 질문에 대답하는 방법뿐만 아니라 클라우드 컴퓨팅, 특히 AWS 및 클라우드를 위해 응용 프로그램을 디자인하는 방법에 대해 배울 수 있습니다.\n\n9시간의 온라인 강좌는 AWS에서의 Kubernetes, Lambda, API Gateway, EC2, ALB, NLB 등을 사용한 디자인 구현뿐만 아니라, 스케일링, 샤딩, 해싱, 마이크로서비스, 로드 밸런서, 보안, 적절한 아키텍처 프레임워크 등의 핵심 시스템 디자인 개념에 대해 다룹니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 강좌에는 퀴즈와 연습 문제가 가득합니다. 최신 시스템 디자인 퀴즈로 지식을 시험해볼 수 있습니다. 소셜 증거에 대해 이야기하자면, 13,381명 이상의 엔지니어가 이미 이 강좌에 참여했으며, 평균 평점은 4.5점으로 상당히 놀라운 수치입니다.\n\n이 강좌에 가입할 수 있는 링크는 다음과 같습니다 - Rajdeep Saha의 Rocking System Design\n\n![Rocking System Design](/assets/img/2024-05-20-Top6SystemDesignInterviewCoursesfromUdemytojoinin2024_3.png)\n\n## 3. 코드칼의 소프트웨어 아키텍처를 위한 시스템 디자인 면접 안내서\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이것은 ex FAANG 엔지니어 인 Sandeep Kaul이 만든 시스템 디자인 인터뷰에 대한 또 다른 Udemy 코스입니다. Sandeep는 다양한 기술에 대한 경험을 기반으로 넓고 깊은 지식을 갖춘 경험 많은 기술 리드/아키텍트입니다. 그의 이력에 반영된 기술은 이 코스에서 확인할 수 있습니다.\n\n이 시스템 디자인 인터뷰 가이드에서는 차세대 시스템 디자인 인터뷰를 성공적으로 치르기 위한 전략 뿐만 아니라 분산 시스템, 마이크로서비스 아키텍처, 데이터베이스, 소프트웨어 아키텍처, 분석 및 디자인 패턴에 대해 배울 수 있습니다. 이는 일상 업무에서 활용되며 엔지니어로서의 역량을 높이는 데 도움이 될 것입니다.\n\nFAANGs의 가장 일반적인 인터뷰 질문에 대한 해결책도 찾을 수 있습니다. WhatsApp, Uber, Amazon, Twitter, YouTube, AirBnb 등을 어떻게 디자인할지에 대한 내용이 포함됩니다.\n\n또한 이 코스에는 지식을 더욱 확고히 하는 데 사용할 수 있는 많은 퀴즈 및 코딩 문제도 제공됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n간략히 말해서, 시스템 설계에 관한 최고의 강좌 중 하나에요. 저는 이 강좌를 정말 사랑했습니다. Sandeep은 각 주제를 충분한 세부사항으로 다루며 다양한 기술적 측면에 대한 그의 깊은 이해가 강촌 강좌 전반에 빛을 발합니다.\n\n시스템 설계 기술을 더 발전시키고 싶은 분들에게 강력히 추천합니다.\n\n이 강좌에 참여하려면 여기를 클릭해주세요 — CodeKarle가 제공하는 소프트웨어 아키텍처를 위한 시스템 설계 면접 가이드\n\n![이미지](/assets/img/2024-05-20-Top6SystemDesignInterviewCoursesfromUdemytojoinin2024_4.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 4. Alexey Soshin에 의한 Pragmatic System Design\n\n이 5시간짜리 시스템 디자인 인터뷰 강좌는 Amazon Web Services의 시니어 솔루션 아키텍트 인 Alexy Soshin이 만들었습니다. Alexy는 시스템 디자인 전문가로 잘 알려져 있으며 \"Kotlin Design Patterns and Best Practices\" 책의 저자이기도 합니다.\n\n또한 그는 \"97 Things Every Java Programmer Should Know\" 책의 공동 저자 중 한 명으로, 최근에 즐겨 읽은 자바 책 중 하나입니다. 여기에는 97개의 전문가들로부터의 핵심 기술 주제에 대한 에세이가 포함되어 있습니다.\n\n이 Udemy의 시스템 디자인 강좌에서는 FANG 인터뷰 문제를 해결하는 방법뿐만 아니라 95 Things Every Java Programmer Should Know 및 기타 중요한 기술 주제에 대한 에세이를 찾을 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 중요한 확장성 개념\n- 일반적인 통신 프로토콜\n- 캐싱 및 Redis\n- 병행성\n- 데이터베이스 설계 및 PostgreSQL\n- 샤딩 전략 등\n\n사회적 증거에 대해 이야기할 때, 이미 26,522명 이상의 소프트웨어 엔지니어가 이 강의에 참여했으며, 평균 평점은 5점 중 4.3점이니 좋은 평가입니다.\n\n이 강의에 참여하는 링크는 여기에 있습니다 - Alexey Soshin의 실용적인 시스템 설계\n\n![이미지](/assets/img/2024-05-20-Top6SystemDesignInterviewCoursesfromUdemytojoinin2024_5.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 5. \"BigTech\" 시스템 디자인 인터뷰 부트캠프\n\n2024년 시스템 디자인 인터뷰를 준비하기 위한 부트캠프 스타일의 강의를 찾고 계시다면, 이 강의를 사랑하실 것입니다. 이 강의는 Hands-On, 프로젝트 기반 학습 및 디스코드 커뮤니티를 활용하여 다음 시스템 디자인 인터뷰를 성공적으로 준비하는 완벽한 가이드를 제공합니다!\n\nAmazon의 SSE 인 Fabien HinsenKamp이 개설한 이 강의는 구성 수준 시스템 디자인 및 실제 응용을 다루며, 10가지 모의 인터뷰 과제를 통해 실전 경험을 제공합니다.\n\n또한, 이 강의는 시스템 디자인에 대한 완벽한 소개를 제공하며, 이 강의에서 가장 좋았던 것은 기술적인 정보뿐만 아니라 기술 인터뷰에서 성공하기 위한 팁도 제공된다는 점입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n파비안이 이미 마이크로소프트에서 일하고 같은 경로를 거쳐 코드를 풀었기 때문에, 그의 조언은 전투에서 단련되어 귀중합니다.\n\n파비안은 Udemy와 Discord에서 질문과 쿼리를 받는 데 아주 민첩하고 응답이 빠릅니다. 그는 답을 숟가락으로 주지는 않지만 궁금증을 자극하여 관심 있는 주제에 대해 더 배우게 하는 것을 촉구하는 훌륭한 교사의 특징이 있습니다.\n\n다음 시스템 디자인 면접을 성공적으로 통과하고자 하는 경우, 이 강좌에 가입해 보세요. 이미 22,292 명 이상의 학생들이 이 강좌에 참여했습니다.\n\n다음 링크를 통해 이 강좌에 가입할 수 있습니다 — \"BigTech\" 시스템 디자인 면접 부트캠프.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Course Image](/assets/img/2024-05-20-Top6SystemDesignInterviewCoursesfromUdemytojoinin2024_6.png)\n\n## 6. Low Level System Design [An interview perspective]\n\n이 리스트의 대부분의 강의가 고수준 시스템 설계를 다루는 반면, 낮은 수준 시스템 설계에서 하나의 강의를 포함하여 조화를 이루고 기술 면접에서 또한 중요하기 때문에 낮은 수준 시스템 설계 강의도 포함하고 싶었습니다.\n\nAbhishek Ghosh가 만든 이 강의는 확장성을 염두에 두고 코딩하는 방법을 가르쳐줄 것입니다. 불필요한 정보를 문제 정의에서 걸러내고 추적을 식별하며 클래스 다이어그램을 만드는 방법을 배울 수 있을 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n필요할 때마다 문제에 대한 테스트 케이스를 작성하는 방법과 코드 지속 가능성을 위한 API 수정 사항을 얻는 방법에 대해 배울 것입니다.\n\n또한 이 강의에서는 필요할 때 캡슐화를 사용하는 방법과 원하는 액세서 및 뮤테이터를 생성하는 방법을 가르칩니다. 무엇보다도 면접 시 코드를 완성하는 방법을 배우고 긴급 상황에서 대비 계획에 통찰력을 얻게 됩니다. 그런 상황은 언제나 발생할 수 있습니다.\n\n사회적 증거에 대해 이 강의에 이미 4,810명 이상의 학생이 참여했으며 평균 평점은 4.5점으로, 이는 저수준 시스템 설계에 좋은 평가입니다. 저수준 시스템 설계를 숙달하고 싶다면 이 강의를 적극 추천합니다.\n\n이 강의에 가입하려면 이 링크를 확인하세요 — [저수준 시스템 설계: 면접 관점에서]\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/assets/img/2024-05-20-Top6SystemDesignInterviewCoursesfromUdemytojoinin2024_7.png)\n\n요즘 시스템 설계 면접 준비를 위해 참여할 수 있는 최고의 온라인 강좌들에 대해 알아봤어요. 시스템 설계는 매우 광범위한 주제이기 때문에 실제로 다룰 몇 개의 강좌가 필요하죠. 저는 두 명의 다른 강사로부터 배울 때 더 나아졌다고 느꼈고, 따라서 이 목록에서 다른 강사의 시스템 설계 강좌를 공유했어요.\n\n또한, 이 모든 강좌는 매우 저렴하게 제공되며 현재 Udemy 할인을 통해 단지 $10에 구매할 수 있어요. 지금 강좌를 시청할 시간이 없더라도 낮은 가격에 등록하여 돈을 절약하고, 나중에 시간이 생겼을 때 나중에 수강할 수 있어요.\n\n최근 Udemy 세일에서 시스템 설계, 프로그래밍 및 다른 기술적 주제에 대한 50개 이상의 강좌를 이미 구입했어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다른 프로그래밍 기사와 자습서\n\n- 시스템 디자인 면접 준비 방법\n- 2024년에 시스템 디자인을 배워야 하는 10가지 이유\n- 시스템 디자인 모의 면접을 위한 최고의 3곳\n- ByteByteGo 시스템 디자인 코스에서 배운 10가지\n- 인쇄가 값진 5가지 시스템 디자인 치트 시트\n- 시스템 디자인을 배우기에 최적인 ByteByteGo는?\n- Exponent의 시스템 디자인 코스는 가치가 있을까?\n- ByteByteGo 시스템 디자인 코스는 가치가 있을까?\n\n이 기사를 읽어주셔서 감사합니다. Udemy에서 이러한 시스템 디자인 면접 코스를 좋아하신다면 친구들과 공유해주세요. 이 목록에 포함되어야 할 다른 시스템 디자인 코스가 있다면 댓글로 알려주세요. 모두가 좋은 자료를 좋아하며 시스템 디자인을 행복하게 배우세요.\n\n참고: 시스템 디자인을 깊이 있게 배우고 싶다면 Udemy의 Frank Kane의 'Mastering the System Design Interview' 코스도 추천합니다. Frank는 이전 채용 담당자로써 큰 FAANG 기업의 시스템 디자인 면접을 통과하는 데 필요한 요소를 잘 알고 있습니다.\n","ogImage":{"url":"/assets/img/2024-05-20-Top6SystemDesignInterviewCoursesfromUdemytojoinin2024_0.png"},"coverImage":"/assets/img/2024-05-20-Top6SystemDesignInterviewCoursesfromUdemytojoinin2024_0.png","tag":["Tech"],"readingTime":13},{"title":"고 오류 정복하기 오류 반환과 처리에 관한 안내","description":"","date":"2024-05-20 16:27","slug":"2024-05-20-ConqueringErrorsinGoAGuidetoReturningandHandlingerrors","content":"\n## Go 오류 처리 마스터하기 위한 초보자 가이드\n\n![이미지](/assets/img/2024-05-20-ConqueringErrorsinGoAGuidetoReturningandHandlingerrors_0.png)\n\n# 레벨 1: if err != nil\n\n이것은 오류를 반환하는 가장 간단한 방법입니다. 대부분의 사람들은 이 패턴에 익숙합니다. 오류를 반환할 수 있는 함수를 호출하고, 오류가 nil인지 확인하고, nil이 아니면 오류를 반환합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```Go\nimport (\n \"errors\"\n \"fmt\"\n)\n\nfunc doSomething() (float64, error) {\n result, err := mayReturnError();\n if err != nil {\n  return 0, err\n }\n return result, nil\n}\n```\n\n## 이 방식의 문제점\n\n이 방식이 가장 간단하고 사실상 가장 많이 사용되는 방법이지만 중대한 문제점이 있습니다: 컨텍스트 부족. 깊은 호출 스택이 있는 경우 어떤 함수가 오류를 발생시켰는지 알 수 없습니다.\n\nA() 함수가 B()를 호출하고, B()가 C()를 호출하고, C()가 다음과 같은 오류를 반환하는 호출 스택을 상상해보십시오:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\npackage main\n\nimport (\n \"errors\"\n \"fmt\"\n)\n\nfunc A(x int) (int, error) {\n result, err := B(x)\n if err != nil {\n  return 0, err\n }\n return result * 3, nil\n}\n\nfunc B(x int) (int, error) {\n result, err := C(x)\n if err != nil {\n  return 0, err\n }\n return result + 2, nil\n}\n\nfunc C(x int) (int, error) {\n if x < 0 {\n  return 0, errors.New(\"negative value not allowed\")\n }\n return x * x, nil\n}\n\nfunc main() {\n // Call function A with invalid input\n result, err := A(-2)\n if err == nil {\n  fmt.Println(\"결과:\", result)\n } else {\n  fmt.Println(\"에러:\", err)\n }\n}\n```\n\n만약 이 프로그램을 실행하면 다음과 같이 출력됩니다.\n\n```js\n에러: negative value not allowed\n```\n\n우리는 호출 스택에서 이 오류가 어디에서 발생했는지에 대한 컨텍스트가 없습니다. 특정 오류 문자열을 찾아 해당 오류가 어디에서 발생했는지를 알아내기 위해 프로그램을 코드 편집기에서 열어야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 레벨 2: 에러 감싸기\n\n에러에 대한 컨텍스트를 추가하기 위해 fmt.Errorf를 사용하여 에러를 감싸줍니다.\n\n```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc A(x int) (int, error) {\n\tresult, err := B(x)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"A: %w\", err)\n\t}\n\treturn result * 3, nil\n}\n\nfunc B(x int) (int, error) {\n\tresult, err := C(x)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"B: %w\", err)\n\t}\n\treturn result + 2, nil\n}\n\nfunc C(x int) (int, error) {\n\tif x < 0 {\n\t\treturn 0, fmt.Errorf(\"C: %w\", errors.New(\"음수 값은 허용되지 않습니다\"))\n\t}\n\treturn x * x, nil\n}\n\nfunc main() {\n\t// 잘못된 입력으로 함수 A를 호출합니다.\n\tresult, err := A(-2)\n\tif err == nil {\n\t\tfmt.Println(\"결과:\", result)\n\t} else {\n\t\tfmt.Println(\"에러:\", err)\n\t}\n}\n```\n\n이 프로그램을 실행하면 아래와 같은 출력을 얻게 됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n오류: A: B: C: 음수 값은 허용되지 않습니다\n```\n\n이제 우리는 콜 스택을 이해했습니다.\n\n하지만 여전히 문제가 있습니다.\n\n## 이 방법의 문제\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n에러가 발생한 위치를 알게 되었지만 여전히 어떤 부분이 잘못되었는지는 알 수 없습니다.\n\n# Level 3: 세부적인 에러\n\n에러가 충분히 설명이 되지 않았습니다. 이것을 보다 복잡한 예제로 보여주기 위해 다음과 같이 조금 더 복잡한 예제가 필요합니다.\n\n```js\nimport (\n \"errors\"\n \"fmt\"\n)\n\nfunc DoSomething() (int, error) {\n result, err := DoSomethingElseWithTwoSteps()\n if err != nil {\n  return 0, fmt.Errorf(\"DoSomething: %w\", err)\n }\n return result * 3, nil\n}\n\nfunc DoSomethingElseWithTwoSteps() (int, error) {\n stepOne, err := StepOne()\n if err != nil {\n  return 0, fmt.Errorf(\"DoSomethingElseWithTwoSteps:%w\", err)\n }\n\n stepTwo, err := StepTwo()\n if err != nil {\n  return 0, fmt.Errorf(\"DoSomethingElseWithTwoSteps: %w\", err)\n }\n\n return stepOne + StepTwo, nil\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 예시에서 오류가 반환되면 어떤 작업이 실패했는지 명확하지 않습니다. StepOne인지 StepTwo인지 알 수 없습니다. 동일한 오류인 Error: DoSomething: DoSomethingElseWithTwoSteps: UnderlyingError가 발생합니다.\n\n그 문제를 해결하려면 발생한 구체적인 문제에 대한 문맥을 추가해야 합니다.\n\n```js\nimport (\n \"errors\"\n \"fmt\"\n)\n\nfunc DoSomething() (int, error) {\n result, err := DoSomethingElseWithTwoSteps()\n if err != nil {\n  return 0, fmt.Errorf(\"DoSomething: %w\", err)\n }\n return result * 3, nil\n}\n\nfunc DoSomethingElseWithTwoSteps() (int, error) {\n stepOne, err := StepOne()\n if err != nil {\n  return 0, fmt.Errorf(\"DoSomethingElseWithTwoSteps: StepOne: %w\", err)\n }\n\n stepTwo, err := StepTwo()\n if err != nil {\n  return 0, fmt.Errorf(\"DoSomethingElseWithTwoSteps: StepTwo: %w\", err)\n }\n\n return stepOne + StepTwo, nil\n}\n```\n\n이제 StepOne이 실패하면 Error: DoSomething: DoSomethingElseWithTwoSteps: StepOne failed: UnderlyingError를 반환합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 이 방법의 문제점\n\n이 오류는 이제 함수 이름을 사용하여 호출 스택을 표현합니다. 그러나 오류의 본질을 표현하지는 않습니다. 오류는 이야기를 전달해야 합니다.\n\n좋은 예는 HTTP 상태 코드입니다. 404를 받으면 원하는 리소스가 존재하지 않음을 알 수 있습니다.\n\n# 레벨 4: 오류 표식\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n에러 센티널은 재사용할 수 있는 미리 정의된 오류 상수입니다.\n\n함수가 실패할 수 있는 원인은 다양할 수 있지만, 일반적으로 4가지 카테고리로 나눌 수 있습니다. \"찾을 수 없음\" 오류, \"이미 존재함\" 오류, \"실패한 전제조건\" 오류, 그리고 \"내부 오류\"입니다. 이는 gRPC 상태 코드에서 영감을 받았습니다. 각 카테고리를 한 문장으로 설명해 드릴게요.\n\n\"찾을 수 없음\" 오류: 호출자가 원하는 리소스가 존재하지 않습니다. 예시: 삭제된 게시물.\n\n\"이미 존재함\" 오류: 호출자가 생성하려는 리소스가 이미 존재합니다. 예시: 같은 이름을 가진 조직.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n실패한 전제조건 오류: 작업 요청자가 실행하려는 작업이 실행 조건을 충족하지 않거나 나쁜 상태에 있습니다. 예시: 잔액이 0원인 계좌에서 출금을 시도하는 경우.\n\n내부 오류: 이러한 카테고리에 속하지 않는 다른 오류로 내부 오류가 발생한 경우입니다.\n\n이러한 종류의 오류만 가지고 있어도 충분하지 않습니다. 호출자에게 어떤 종류의 오류인지 알려주어야 합니다. 이를 위해 오류 센티널 및 errors.Is를 사용합니다.\n\n사용자가 지갑 잔액을 조회하고 업데이트할 수 있는 REST API가 있다고 상상해보세요. 데이터베이스에서 지갑을 조회할 때 오류 센티널을 활용하는 방법을 살펴봅시다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nimport (\n \"fmt\"\n \"net/http\"\n \"errors\"\n)\n\n// 이것들은 에러를 표현하는 상수들입니다.\nvar (\n  WalletDoesNotExistErr = errors.New(\"지갑이 존재하지 않습니다\") // 발견되지 않은 에러 타입\n  CouldNotGetWalletErr = errors.New(\"지갑을 가져올 수 없습니다\") // 내부 에러 타입\n)\n\nfunc getWalletFromDB(id int) (int, error) {\n // 더미 구현: 데이터베이스에서 지갑을 검색하는 시뮬레이션\n balance, err := db.get(id)\n\n if err != nil {\n  if balance == nil {\n    return 0, fmt.Errorf(\"%w: Wallet(id:%s)가 존재하지 않습니다: %w\", WalletDoesNotExistErr, id, err)\n  } else {\n    return 0, fmt.Errorf(\"%w: 데이터베이스에서 Wallet(id:%s)를 가져올 수 없습니다: %w\", CouldNotGetWalletErr, id, err)\n  }\n }\n\n return *balance, nil\n}\n```\n\n이제 이제 REST 핸들러에서 다음과 같이 할 수 있는 것을 보여줍니다.\n\n```js\nfunc getWalletBalance() {\n wallet, err := getWalletFromDB(id)\n\n if errors.Is(err, WalletDoesNotExistErr) {\n  // 404 반환\n } else if errors.Is(err, CouldNotGetWalletErr) {\n  // 500 반환\n }\n}\n```\n\n다른 예제를 살펴보겠습니다. 사용자가 잔액을 업데이트하고자 하는 경우를 보겠습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nimport (\n \"fmt\"\n \"net/http\"\n \"errors\"\n)\n\nvar (\n  WalletDoesNotExistErr = errors.New(\"Wallet does not exist\") // Not Found Error Type\n  CouldNotDebitWalletErr = errors.New(\"Could not debit Wallet\") // Internal Error Type\n  InsufficientWalletBalanceErr = errors.New(\"Insufficient balance in Wallet\") // Failed Precondition Error Type\n)\n\nfunc debitWalletInDB(id int, amount int) error {\n // Dummy implementation: simulate retrieving a wallet from a database\n balance, err := db.get(id)\n\n if err != nil {\n  if balance == nil {\n    return fmt.Errorf(\"%w: Wallet(id:%s) does not exist: %w\", WalletDoesNotExistErr, id, err)\n  } else {\n    return fmt.Errorf(\"%w: could not get Wallet(id:%s) from db: %w\", CouldNotDebitWalletErr, id, err)\n  }\n }\n\n if *balance <= 0 {\n   return 0, fmt.Errorf(\"%w: Wallet(id:%s) balance is 0\", InsufficientWalletBalanceErr, id)\n }\n\n updatedBalance := *balance - amount\n\n // Dummy implementation: simulate updating a wallet in a database\n err := db.update(id, updatedBalance)\n\n if err != nil {\n   return fmt.Errorf(\"%w: could not update Wallet(id:%s) in db: %w\", CouldNotDebitWalletErr, id, err)\n }\n\n return nil\n}\n```\n\n## Using sentinels for better error messages\n\nYou might have noticed that I have a particular way of formatting errors. I prefer structuring an error message in one of two ways:\n\n- `fmt.Errorf(\"%w: description: %w\", Sentinel, err)` or\n- `fmt.Errorf(\"%w: description\", Sentinel)`\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이것은 오류가 발생한 이유와 근본적인 원인을 알려주는 이야기를 만듭니다.\n\n이것은 중요합니다. 왜냐하면 위 예제에서 보는 바와 같이 동일한 유형의 오류가 두 가지 다른 근본적인 이슈로 인해 발생할 수 있기 때문입니다. 따라서 설명이 우리가 정확히 무엇이 잘못되었는지와 그 이유를 정확히 찾게 도와줍니다.\n\n# 보너스: 에러를 기록하는 곳\n\n당신이 발견한 모든 오류를 기록해서는 안 된다는 것에 놀랄지도 모릅니다. 왜냐하면 로그가 아래와 같이 보이기 때문입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n에러: C: 음수 값은 허용되지 않습니다\n에러: B: C: 음수 값은 허용되지 않습니다\n에러: A: B: C: 음수 값은 허용되지 않습니다\n```\n\n에러를 기록하는 곳은 반드시 \"처리\"할 수 있는 경우에만 해야 합니다. 여기서 처리란 호출자가 에러를 받아서 무언가 처리하고 계속 실행할 수 있도록 하는 것을 의미합니다.\n\n전형적인 예시는 다시 말해 REST 핸들러일 것입니다. REST 핸들러가 에러를 받으면 해당 에러의 타입을 살펴보고, 적절한 상태 코드로 응답을 보내고 에러 전파를 중단할 수 있습니다.\n\n```js\nfunc getWalletBalance() {\n wallet, err := getWalletFromDB(id)\n\n if err != nil {\n  fmt.Printf(\"%w\", err) // 여기에서는 오직 에러를 로깅합니다\n }\n\n if errors.Is(err, WalletDoesNotExistErr) {\n  // 404 반환\n } else if errors.Is(err, CouldNotGetWalletErr) {\n  // 500 반환\n }\n}\n```\n","ogImage":{"url":"/assets/img/2024-05-20-ConqueringErrorsinGoAGuidetoReturningandHandlingerrors_0.png"},"coverImage":"/assets/img/2024-05-20-ConqueringErrorsinGoAGuidetoReturningandHandlingerrors_0.png","tag":["Tech"],"readingTime":12},{"title":"데이터 제품을 위한 데이터 조작","description":"","date":"2024-05-20 16:25","slug":"2024-05-20-DataOrchestrationforDataProducts","content":"\n이 문서는 Modern Data Stack 101에 처음 등장했습니다. 만일 Medium 회원이 아니라면, 무료로 여기에서 읽을 수 있어요 💸\n\n# 제 소개\n\n저는 후고 루입니다. 런던에서 M&A로 일한 후 JUUL에 합류하여 데이터 엔지니어링에 빠져들게 되었습니다. 런던을 기반으로 하는 스케일업 기업 Codat의 데이터 기능을 이끌었습니다. 지금은 Orchestra의 CEO입니다. Orchestra는 데이터 팀이 신뢰성 있고 효율적으로 데이터를 프로덕션 환경으로 릴리즈할 수 있도록 도와주는 데이터 릴리즈 파이프라인 도구입니다. 🚀\n\n⭐️ 또한 우리의 Substack와 내부 블로그도 확인해 보세요 ⭐️\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 소개\n\n현재 데이터 팀들은 오르막길을 오르는 중입니다. 한편으로, 데이터 제품에 대한 수요는 이전보다 커졌습니다. AI가 데이터 기반의 기능, 제품 및 능력에 대한 수요를 높였고, CEO들의 욕망 또한 증가했습니다. 이러한 요구는 데이터 파이프라인 및 데이터 및 데이터 수집의 효율적 관리에 의해 가능케 되었습니다.\n\n다른 한편으로, 데이터 팀의 예산은 삭감되고 인력도 줄어들고 있습니다. 이로 인해 데이터를 조직하는 능력이 저하되었고, 결과적으로 조직이 활용할 수 없는 많은 다양한 데이터 소스(구조화된 및 비구조화된 데이터)가 계속되고 있습니다.\n\n성장과 성공을 위한 가장 큰 촉매제 중 하나는 수동 데이터 사용의 고통을 없애고 데이터 조종, 데이터 관측, 계보, 메타데이터 수집 및 경보를 통합하는 통합 제어 평면을 가지고 있는 것입니다. 이 글에서는 데이터 조종 프로세스가 데이터 및 AI 제품 속도를 가속화하는 데 어떤 역할을 하는지와 채택할 수 있는 방법을 살펴보겠습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 오픈 소스 워크플로 오케스트레이션 도구 대 전체 제어 플랜\n\nAirflow 및 Prefect와 같은 오픈 소스 워크플로 오케스트레이션 도구는 데이터 워크플로 관리 및 자동화에 강력한 기능을 제공하지만, 전체 제어 플랜과 비교할 때 접근 방식과 기능이 다릅니다.\n\nAirflow는 에어비앤비에서 개발한 오픈 소스 도구로, 워크플로 스케줄링, 모니터링 및 관리에 중점을 둡니다. Airflow는 방향성 비순환 그래프(DAG)를 사용하여 워크플로를 정의하고 다양한 외부 시스템과 통합을 지원합니다. Airflow의 장점은 유연성과 확장성에 있어, 사용자가 복잡한 워크플로를 생성하고 대량의 데이터를 처리할 수 있도록 합니다.\n\n반면 Prefect는 사용 편의성, 신뢰성 및 데이터 버전 관리를 강조하는 또 다른 오픈 소스 워크플로 오케스트레이션 도구입니다. Prefect는 워크플로를 정의하는 데 더 직관적인 인터페이스를 제공하며 자동 재시도 논리, 작업 의존성 및 워크플로를 모니터링하고 관리하는 중앙 대시보드와 같은 기능을 제공합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n오픈 소스 워크플로 오케스트레이션 도구인 Airflow와 Prefect를 All-in-One 제어 플레인인 Orchestra, Apache NiFi, DataOS 또는 AWS Step Functions과 같은 플랫폼 또는 프로프리터리 솔루션과 비교할 때, All-in-One 제어 플레인은 종종 더 간편한 사용자 경험을 제공하고 학습 커브가 낮다는 큰 차이점이 있습니다. 그들은 사용자들이 기술적 지식이 적은 사용자도 접근할 수 있게끔 그래픽 표현, 드래그 앤 드롭 기능, 일반적인 워크플로를 위한 미리 구축된 템플릿과 같은 선호하는 형태의 표준 인터페이스를 제공할 수 있습니다.\n\n그러나 제어 플레인의 진정한 힘은 데이터 생태계의 모든 엔티티와 상호 작용할 수 있는 능력에 있습니다. 이로 인해 불필요한 통합 오버헤드를 완전히 줄일 수 있습니다. 더 흥미로운 점은 중앙 제어 플레인이 글로벌 메타데이터 및 거버넌스 프로토콜에 접근할 수 있어 데이터 주변의 완전한 컨텍스트와 안전하게 작동할 수 있는 오케스트레이션을 제공할 수 있다는 것입니다.\n\n# OSS 오케스트레이션 시스템이 안티 패턴을 장려\n\n기존 OSS 워크플로는 데이터 아키텍처에 대한 통합적인 접근을 장려합니다. 이는 \"모던 데이터 스택\"의 모든 구성 요소를 처리할 수 있는 단일 저장소와 단일 애플리케이션이 있다는 것을 의미합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n많은 사람들이 이 아키텍처를 간단히 갖고 있지 않습니다. 데이터 서비스를 구축하는 것은 어렵습니다. 데이터 파이프라인을 구축하는 것은 종종 파이프라인의 다른 부분에서 특화된 서비스가 필요합니다. 사실, 서로 다른 팀이 있는 것이 필요하게 만드는 경우가 많습니다.\n\n예를 들어, 데이터 엔지니어링 팀은 Kafka나 다른 이벤트 기반 스트리밍 응용 프로그램을 관리할 책임이 있을 수 있습니다. 분석 팀은 dbt 저장소를 관리할 수도 있습니다. 이들은 분리되어야 합니다.\n\n따라서 OSS Workflow Orchestration 도구로 현대 데이터 스택을 활용하는 것은 어느 정도 반대 패턴이며 추가적이고 비싼 감시 플랫폼이 필요합니다. \"Quis custodiet ipsos custodes?\" 또는 \"수호자를 지킬 자가 누구인가?\" 라는 문구가 떠오릅니다.\n\n![이미지](/assets/img/2024-05-20-DataOrchestrationforDataProducts_0.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이미지 제공: 작성자\n\n# 효율적인 마이크로서비스 아키텍처 활성화 방법\n\n데이터 제품 속도에 미치는 통합 데이터 조작의 영향\n\n데이터 조작 프로세스 자동화를 위한 통합 제어 평면을 갖는 것은 여러 가지 이점을 제공합니다.\n\n## 보일러플레이트 작업 제거\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n기존 인프라를 사용하여 모든 중요한 계산을 처리하고 데이터 Orchestration 도구가 기존 프로세스를 조정하는 데 기여함으로써 엔지니어는 새로운 기술(Airflow 등)을 배우거나 인프라를 배포(Kubernetes 등)하거나 복잡한 UI에 대처할 필요가 없습니다.\n\n엔지니어와 데이터 팀은 데이터 수집, 데이터 정리, 분석 그리고 기계 학습에 집중하며 조정이 나머지 부분을 처리하도록 의지할 수 있습니다.\n\n## 비용과 메타데이터에 대해 걱정하지 마세요\n\n통합되지 않은 데이터 또는 Workflow Orchestration 도구를 사용하면 소중한 메타데이터가 원본 시스템 내에서 통합되지 않은 상태로 남아 있고 데이터 수명 주기 정책으로 인해 심지어 사라질 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n통합 조작 및 감시는이 데이터가 실시간으로 효율적으로 수집되어 데이터 팀에서 사용할 수 있도록합니다. 이를 통해 이집트된 데이터 소스 간의 메타데이터 관리가 쉬워집니다.\n\n## 비즈니스 가치 계산\n\n통합 조작 플랫폼을 사용하면 데이터 엔지니어가 데이터 및 AI 제품의 비즈니스 가치를 정량화 할 수 있습니다. 예를 들어, 쿼리당 비용 데이터 및 AWS 컴퓨팅 비용을 가져오는 동시에 대시보드 및 머신러닝 모델 사용 통계를 볼 수 있습니다.\n\n이 비즈니스 중요한 운영 데이터를 데이터 제품 수준에서 가지면 데이터 팀은 좀 더 효율적으로 우선순위를 정할뿐만 아니라 기업에 그들의 가치와 가치를 보여줄 수있는 창문을 마침내 가질 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n통합 데이터 조율 및 데이터 가시성 플랫폼은 모든 작업을 청소하는 것, 유용한 메타데이터를 수집하고 데이터 제품 수준에서 제공함으로써 제품 속도를 빠르게 가속화할 수 있습니다. 엔지니어들이 기술적인 도전을 극복하는 데 시간을 절약하고, 다수의 감각적 이점을 얻습니다.\n\n데이터 품질을 선제적으로 모니터링하고 데이터 문제를 예방하며 비즈니스 이해관계자에게 (따라서 신뢰를 얻으며) 데이터 및 AI 이니셔티브를 무제알고 효율적으로 우선순위를 설정하는 것은 모두 통합 데이터 조율 플랫폼 또는 데이터 제어 플레인으로 가능합니다. Orchestra와 같은 제어 플레인은 기업이 전례 없는 속도로 데이터를 활용할 수 있도록 길을 열고 있습니다.\n\n# 기존 데이터 조율 솔루션의 한계점\n\n기존 조율 솔루션은 여러 가지 중요한 영역에서 종종 한계점을 지니고 있습니다. 첫째, 그들은 종종 사용자들에게 파이썬 코드를 큰 monorepo에서 작성하도록 강요하여 코드베이스가 커질수록 규모화하고 관리하기 어렵게 만듭니다. 이는 복잡성과 유지보수 도전을 증가시킬 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n또한, 많은 기존 도구들에서는 가시성과 종단간 메타데이터 추적이 부족합니다. 이로 인해 사용자들이 데이터 및 프로세스의 흐름을 이해하기 어려워지며, 디버깅과 모니터링에 문제가 발생할 수 있습니다.\n\n마지막으로, 데이터 및 AI 제품의 성능을 종합적으로 파악할 수 있는 사용자 친화적 인터페이스가 부족합니다. 이러한 UI의 부재로 사용자들은 워크플로우를 쉽게 모니터링하고 최적화하여 성능과 효율성을 향상시키기 어려워집니다.\n\n## Multi-Tenancy와 거버넌스 부재\n\n다양한 팀이 다양한 소프트웨어를 사용하는 환경에서는 전체 데이터 운영에 대한 다중 테넌트 뷰를 얻는 것이 불가능합니다. 이는 팀 간 디버깅 라인지 그래프를 어렵게 만들며, 협업에 있어서 도전을 초래하며, 데이터 파이프라인을 관리하기 어렵게 만듭니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 보안 준수\n\n단일 저장소에서는 개인 및 클러스터 모두 필요 이상의 비밀 정보에 액세스할 수 있습니다. 이는 여러 사람이 실제로 액세스할 필요가 없는 코드 베이스의 일부에 액세스할 수 있어 장애 발생 가능성을 높이게 됩니다.\n\n## 경보 및 소유권\n\n다양한 팀이 사용하는 여러 저장소가 있는 경우, 경보 및 데이터 자산 소유는 도전적일 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 원활한 지속적 통합\n\n자주 놓치는 요소 중 하나인 데이터 파이프라인 저장소의 지속적 통합은 서비스 기반의 데이터 수집 스크립트와 같은 서비스 기반의 마이크로서비스에 대해 비교적 직관적입니다.\n\n그러나 dbt를 활용한 분석 저장소의 경우, dbt Slim CI와 같은 것이 필요하거나 프로젝트 Nessie의 데이터를 위한 Git-Control이 필요합니다. 이러한 환경에서 최소한의 CI가 실행되도록 보장하는 것만으로도 챌린지입니다. 그리고 데이터 수집, 스트리밍, 변환, 운영 분석에 대한 코드가 동일한 위치에 있는 경우, 더 복잡해집니다.\n\n# 요약\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n본질적으로, 기본 사항인 제품 접근 방식으로 내려가는 것이 중요합니다. 제품 중심이 되는 것은 무엇을 의미할까요? 사용자 경험과 개선에 대한 완전한 초점. XYZ 작업 수행을 위한 노력을 줄이는 것입니다.\n\n데이터 제품을 구축할 때, 우리는 고객을 '사용자'로만 다루지 않고, 데이터 엔지니어와 분석 엔지니어도 데이터 제품 접근 방식의 '사용자'로 취급합니다. 그들의 삶은 기관이 데이터를 구축하는 방식으로 지속적으로 영향을 받는데, 그것은 최종 사용자에도 항상 영향을 줍니다.\n\n제품 접근 방식은 거대한 전략이 아닙니다. 사실, 데이터 워크플로우의 작은 구석마다 그리고 마지막 순간마다 살아있는 원자적 전략입니다. 오케스트레이션은 이 이야기에서 제외되지 않으며 사실, 이를 상당부분 이끌어 내는 요소입니다. 데이터 제품의 맥락에서 오케스트레이션도 사용자 중심 접근 방식을 채택하여 데이터 및 분석 엔지니어가 약간 더 용이하게 호흡할 수 있도록 합니다.\n","ogImage":{"url":"/assets/img/2024-05-20-DataOrchestrationforDataProducts_0.png"},"coverImage":"/assets/img/2024-05-20-DataOrchestrationforDataProducts_0.png","tag":["Tech"],"readingTime":9}],"page":"82","totalPageCount":110,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":4},"__N_SSG":true}