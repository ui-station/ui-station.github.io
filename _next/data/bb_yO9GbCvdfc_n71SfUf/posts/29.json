{"pageProps":{"posts":[{"title":"마법같은 멀티플랫폼 하나의 코드베이스로 세 플랫폼 이용하기","description":"","date":"2024-06-19 14:10","slug":"2024-06-19-MultiplatformMagicOneCodebaseThreePlatforms","content":"\n![이미지](/assets/img/2024-06-19-MultiplatformMagicOneCodebaseThreePlatforms_0.png)\n\nCompose Multiplatform은 개발자에게 뛰어난 가능성의 세계를 열어주어 안드로이드와 iOS용 네이티브 모습을 하나의 코드베이스로 구축할 수 있게 합니다. 이러한 앱에 인증을 통합하는 것은 어렵게 느껴질 수 있지만, 이 기사에서는 Firebase REST API 인증을 Compose Multiplatform과 통합하는 단계와 혜택을 탐색할 것입니다.\n\n# 왜 Firebase REST API를 사용하는가?\n\n우리는 Android, iOS 및 Web 플랫폼용 다양한 Firebase SDK가 있음을 알고 있지만 Compose Multiplatform용 안정적인 SDK는 없습니다. 또한, 다양한 Compose Multiplatform 예제에서 사용 사례를 보여주기 위해 REST API를 사용하는 것을 보았습니다. 따라서 하나의 코드베이스를 사용하고 여러 플랫폼을 대상으로 하기 위해 Firebase REST API를 인증에 사용하는 것을 선호했습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 준비물:\n\n- Compose Multiplatform 플러그인이 설치된 Android Studio 또는 IntelliJ IDEA.\n- iOS 앱을 실행하기 위한 Xcode.\n- Firebase 프로젝트.\n- 프로젝트에서 Firebase Authentication이 활성화되어 있어야 합니다.\n\n# 단계 1: Compose Multiplatform 프로젝트 생성\n\nCompose Multiplatform 프로젝트를 생성하려면 Kotlin Multiplatform Wizard를 사용할 수 있습니다. 이는 우리가 타깃팅하는 플랫폼을 선택할 수 있게 해줍니다. 이 프로젝트에서는 Android, iOS 및 데스크톱 플랫폼을 선택할 것입니다. 플랫폼을 선택하고 나면 프로젝트를 다운로드하여 선호하는 IDE에서 열 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![image](/assets/img/2024-06-19-MultiplatformMagicOneCodebaseThreePlatforms_1.png)\n\n# 단계 2: 인증을 위한 UI 생성\n\n이 프로젝트에서는 Email/Password 인증만 대상으로 하고 시작하므로 composeApp/src/commonMain/kotlin/authentication/AuthenticationView.kt 파일에서는 로그인 및 회원가입 뷰를 포함한 UI가 제공됩니다.\n\n![image](/assets/img/2024-06-19-MultiplatformMagicOneCodebaseThreePlatforms_2.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 단계 3: Firebase 프로젝트 구성하기.\n\nFirebase 프로젝트를 구성하면 프로젝트 설정을 방문하여 Firebase REST API와 함께 사용할 API Key를 얻을 수 있습니다. 이를 사용하여 사용자를 인증할 수 있습니다.\n\n![이미지](/assets/img/2024-06-19-MultiplatformMagicOneCodebaseThreePlatforms_3.png)\n\n# 단계 4: 프로젝트에서 Ktor 구성하기.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nKotlin의 Ktor 프레임워크는 강력하고 유연한 HTTP 클라이언트를 제공하여 외부 API와의 상호 작용을 원활하게 만들어줍니다. 구현에 앞서 필요한 종속성이 포함된 Kotlin 프로젝트를 설정했는지 확인해보세요. Ktor의 클라이언트 라이브러리를 포함하여 프로젝트에 Ktor 클라이언트를 추가할 수 있습니다. 이를 위해 libs.versions.toml 파일 내 gradle 폴더에 다음 종속성을 포함하면 됩니다.\n\n[versions]\n...\nkotlin = \"1.9.21\"\nkotlinx-coroutines = \"1.7.3\"\nktor = \"2.3.6\"\n\n[libraries]\n....\nktor-serialization-kotlinx-json = { module = \"io.ktor:ktor-serialization-kotlinx-json\", version.ref = \"ktor\" }\nktor-client-core = { module = \"io.ktor:ktor-client-core\", version.ref = \"ktor\" }\nktor-client-darwin = { module = \"io.ktor:ktor-client-darwin\", version.ref = \"ktor\" }\nktor-client-okhttp = { module = \"io.ktor:ktor-client-okhttp\", version.ref = \"ktor\" }\nktor-client-content-negotiation = { module = \"io.ktor:ktor-client-content-negotiation\", version.ref = \"ktor\" }\n\n[plugins]\nandroidApplication = { id = \"com.android.application\", version.ref = \"agp\" }\nandroidLibrary = { id = \"com.android.library\", version.ref = \"agp\" }\njetbrainsCompose = { id = \"org.jetbrains.compose\", version.ref = \"compose-plugin\" }\nkotlinMultiplatform = { id = \"org.jetbrains.kotlin.multiplatform\", version.ref = \"kotlin\" }\nkotlinxSerialization = { id = \"org.jetbrains.kotlin.plugin.serialization\", version.ref = \"kotlin\" }\n\nlibs.versions.toml 파일 내의 라이브러리를 추가했으면, build.gradle.kts 파일의 composeApp 내부에 종속성을 추가하고 프로젝트를 동기화해주면 됩니다:\n\nandroidMain.dependencies {\n...\nimplementation(libs.ktor.client.okhttp)\n}\ncommonMain.dependencies {\n...\nimplementation(libs.ktor.client.core)\nimplementation(libs.ktor.client.content.negotiation)\nimplementation(libs.ktor.serialization.kotlinx.json)\n}\ndesktopMain.dependencies {\n..\nimplementation(libs.ktor.client.okhttp)\n}\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 단계 5: Firebase REST API 호출하기\n\nKtor 라이브러리가 추가되고 프로젝트가 동기화된 후, Ktor 함수를 사용하여 Firebase REST API를 호출할 수 있습니다. 그 전에 HttpClient를 초기화하여 API 요청을 만들 수 있어야 합니다. 그래서, AuthenticationViewModel.kt 파일을 생성하여 모든 백엔드 작업을 처리하고 아래 코드를 추가합니다.\n\n```js\nprivate val httpClient = HttpClient() {\n    install(ContentNegotiation) {\n        json()\n    }\n}\n```\n\n## 사용자 생성 정복하기:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 새로운 사용자를 생성해 봅시다! https://identitytoolkit.googleapis.com/v1/accounts:signUp?key=$'API_KEY' 엔드포인트로 Ktor 클라이언트 호출을 만들어 보겠습니다. 사용자 데이터(이메일 및 비밀번호)를 코틀린 직렬화를 사용하여 JSON 형식으로 직렬화해야 합니다. 데이터와 함께 POST 요청을 보내고 Firebase 응답을 기다리세요. 사용자가 성공적으로 생성되면 응답을 구문 분석하여 사용자 ID 및 기타 관련 정보를 추출하세요.\nAuthenticationViewModel.kt에 추가된 signUp() 메서드의 아래 코드 스니펫을 확인해보세요.\n\n```js\nfun signUp(\n        email: String,\n        password: String,\n        confirmPassword: String,\n        onCompletion: onCompletion\n    ) {\n        if (password == confirmPassword) {\n            viewModelScope.launch {\n                val responseBody = httpClient\n                    .post(\"https://identitytoolkit.googleapis.com/v1/accounts:signUp?key=${API_KEY}\") {\n                        header(\"Content-Type\", \"application/json\")\n                        parameter(\"email\", email)\n                        parameter(\"password\", password)\n                        parameter(\"returnSecureToken\", true)\n                    }\n                if (responseBody.status.value in 200..299) {\n                    val response = Json { ignoreUnknownKeys = true }\n                        .decodeFromString<AuthResponse>(responseBody.bodyAsText())\n                    onCompletion.onSuccess(response.idToken)\n                } else {\n                    onCompletion.onError(Exception(responseBody.bodyAsText()))\n                }\n            }\n        } else {\n            onCompletion.onError(Exception(\"Password doesn't match\"))\n        }\n    }\n```\n\n## 로그인 퀘스트:\n\n이제 로그인에 도전해 봅시다! 사용자 생성과 유사하게, https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=$'API_KEY' 엔드포인트로의 Ktor 클라이언트 호출을 구성해보세요. 다시 한번 사용자 자격 증명(이메일 및 비밀번호)을 직렬화하고 POST 요청을 보내세요. 응답을 구문 분석하여 ID 토큰을 얻어 사용자 신원을 확인하고 보호된 리소스에 액세스하는 데 필수적인 요소를 확보하세요.\nAuthenticationViewModel.kt에 추가된 login() 메서드의 아래 코드 스니펫을 확인해보세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\nfun login(\n    email: String,\n    password: String,\n    onCompletion: onCompletion\n) {\n    viewModelScope.launch {\n        val responseBody = httpClient\n            .post(\"https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=${API_KEY}\") {\n                header(\"Content-Type\", \"application/json\")\n                parameter(\"email\", email)\n                parameter(\"password\", password)\n                parameter(\"returnSecureToken\", true)\n            }\n        if (responseBody.status.value in 200..299) {\n            val response = Json { ignoreUnknownKeys = true }\n                .decodeFromString(responseBody.bodyAsText())\n            storeUserDetails(response)\n            onCompletion.onSuccess(response.idToken)\n        } else {\n            onCompletion.onError(Exception(responseBody.bodyAsText()))\n        }\n    }\n}\n```\n\n# 단계 6: 캐시 지원을 위해 SQLDelight 추가.\n\nSQLDelight는 플랫폼에 중립적인 SQL 쿼리를 작성하기 위한 강력한 코틀린 라이브러리로, 캐싱과 결합하여 앱의 효율성을 높이는 동적 이중체를 형성합니다. 여기서는 login 및 signUp API 호출의 응답에서 얻은 refreshToken을 저장할 것입니다. 따라서 사용자가 앱을 다시 열 때 인증을 요청하지 않을 것입니다.\n\n## SQLDelight 종속성 설정\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n먼저 gradle 폴더 내 libs.versions.toml 파일에 필요한 SQLDelight 종속성 및 플러그인을 추가해야 합니다.\n\n```js\n[versions]\n...\n...\nsqlDelight = \"2.0.1\"\n\n[libraries]\n...\n...\nsqldelight-androidDriver = { module = \"app.cash.sqldelight:android-driver\", version.ref = \"sqlDelight\" }\nsqldelight-jvmDriver = { module = \"app.cash.sqldelight:sqlite-driver\", version.ref = \"sqlDelight\" }\nsqldelight-nativeDriver = { module = \"app.cash.sqldelight:native-driver\", version.ref = \"sqlDelight\" }\nsqldelight-coroutines = { module = \"app.cash.sqldelight:coroutines-extensions\", version.ref = \"sqlDelight\" }\nsqldelight-primitiveAdapters = { module = \"app.cash.sqldelight:coroutines-extensions\", version.ref = \"sqlDelight\" }\n\n[plugins]\nandroidApplication = { id = \"com.android.application\", version.ref = \"agp\" }\nandroidLibrary = { id = \"com.android.library\", version.ref = \"agp\" }\njetbrainsCompose = { id = \"org.jetbrains.compose\", version.ref = \"compose-plugin\" }\nkotlinMultiplatform = { id = \"org.jetbrains.kotlin.multiplatform\", version.ref = \"kotlin\" }\nkotlinxSerialization = { id = \"org.jetbrains.kotlin.plugin.serialization\", version.ref = \"kotlin\" }\nsqlDelight = { id = \"app.cash.sqldelight\", version.ref = \"sqlDelight\" }\n```\n\n다음 단계는 프로젝트 수준의 build.gradle.kts 파일에 플러그인을 추가하는 것입니다.\n\n```js\nplugins {\n    // this is necessary to avoid the plugins to be loaded multiple times\n    // in each subproject's classloader\n    alias(libs.plugins.androidApplication) apply false\n    alias(libs.plugins.androidLibrary) apply false\n    alias(libs.plugins.jetbrainsCompose) apply false\n    alias(libs.plugins.kotlinMultiplatform) apply false\n    //SQLDelight Plugin\n    alias(libs.plugins.sqlDelight) apply false\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n마지막 단계로는 composeApp build.gradle.kts 파일에서 SQLDelight를 구성해야 합니다. 여기서는 필요한 플랫폼에 따라 종속성을 추가하고 SQLDelight 데이터베이스의 이름을 추가할 것입니다. 매개변수가 포함된 데이터베이스 목록을 포함하는 sqlDelight 블록을 맨 끝에 볼 수 있을 것입니다.\n\n```js\nimport org.jetbrains.compose.ExperimentalComposeLibrary\nimport org.jetbrains.compose.desktop.application.dsl.TargetFormat\n\nplugins {\n    alias(libs.plugins.kotlinMultiplatform)\n    alias(libs.plugins.androidApplication)\n    alias(libs.plugins.jetbrainsCompose)\n    alias(libs.plugins.kotlinxSerialization)\n    alias(libs.plugins.sqlDelight)\n}\n\nkotlin {\n\n    androidTarget {\n        compilations.all {\n            kotlinOptions {\n                jvmTarget = \"1.8\"\n            }\n        }\n    }\n\n\n    jvm(\"desktop\")\n\n    listOf(\n        iosX64(),\n        iosArm64(),\n        iosSimulatorArm64()\n    ).forEach { iosTarget ->\n        iosTarget.binaries.framework {\n            baseName = \"ComposeApp\"\n            // This should be set to false to run on iOS\n            isStatic = false\n            // Add it to avoid sqllite3 issues in iOS\n            linkerOpts.add(\"-lsqlite3\")\n        }\n    }\n\n    sourceSets {\n        val desktopMain by getting\n\n        androidMain.dependencies {\n            implementation(libs.compose.ui.tooling.preview)\n            implementation(libs.androidx.activity.compose)\n            implementation(libs.ktor.client.okhttp)\n            //SqlDelight for Android\n            implementation(libs.sqldelight.androidDriver)\n        }\n        commonMain.dependencies {\n            implementation(compose.runtime)\n            implementation(compose.foundation)\n            implementation(compose.material)\n            implementation(compose.ui)\n            @OptIn(ExperimentalComposeLibrary::class)\n            implementation(compose.components.resources)\n            //Ktor\n            implementation(libs.ktor.client.core)\n            implementation(libs.ktor.client.content.negotiation)\n            implementation(libs.ktor.serialization.kotlinx.json)\n            //Moko MVVM\n            implementation(libs.moko.mvvm.core)\n            implementation(libs.moko.mvvm.compose)\n            //Kamel\n            implementation(libs.kamel)\n            // Navigator\n            implementation(libs.voyager.navigator)\n            //SqlDelight for common\n            implementation(libs.sqldelight.coroutines)\n            implementation(libs.sqldelight.primitiveAdapters)\n        }\n        desktopMain.dependencies {\n            implementation(compose.desktop.currentOs)\n            implementation(libs.kotlinx.coroutines.swing)\n            implementation(libs.ktor.client.okhttp)\n            //SqlDelight for jvm\n            implementation(libs.sqldelight.jvmDriver)\n        }\n        iosMain.dependencies {\n            //SqlDelight for iOS\n            implementation(libs.sqldelight.nativeDriver)\n        }\n    }\n}\n\nsqldelight {\n    databases {\n        //Note: Name of your Database and .sq file should be same\n        create(\"Database\") {\n            packageName.set(\"com.dwarshb.firebaseauthentication\")\n        }\n    }\n    // Add this line to avoid library linking issues\n    linkSqlite = true\n}\n\nandroid {\n    ...\n}\n\ncompose.desktop {\n    ...\n}\n```\n\n## 쿼리용 Database.sq 파일 만들기\n\n다음 단계는 모든 필요한 SQL 쿼리를 포함하는 .sq 파일을 작성하는 것입니다. 기본적으로 SQLDelight 플러그인은 sqldelight 폴더 내의 패키지 폴더에서 .sq를 읽습니다. 해당 폴더는 직접 commainMain 폴더 내에 있을 것입니다.\nDatabase.sq 파일이 위치하는 폴더 구조 스크린샷은 아래에서 확인하실 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-06-19-MultiplatformMagicOneCodebaseThreePlatforms_4.png\" />\n\n다음 코드를 Database.sq 파일에 추가하세요. 이 파일은 createTable, insertUser, removeAllUsers, getAllUsers 등의 쿼리를 포함합니다.\n\n프로젝트를 컴파일하면 생성된 Kotlin 코드가 composeApp/build/generated/sqldelight 디렉토리에 저장됩니다. 또는 터미널에서 ./gradlew generateSqlDelightInterface 명령어를 사용하여 sqldelight 코틀린 코드를 생성할 수도 있습니다.\n\n## 데이터베이스 드라이버 생성\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nSQLDelight은 SQLite 드라이버의 여러 플랫폼별 구현을 제공하므로 각 플랫폼에 대해 별도로 생성해야 합니다. 이를 기대 선언과 실제 선언을 사용하여 수행할 수 있습니다.\n\ncomposeApp/src/commonMain/kotlin에서 패키지를 만들고 그 안에 DriverFactory.kt 클래스를 만드세요.\n\n```kotlin\npackage com.dwarshb.firebaseauthentication\n\nimport app.cash.sqldelight.db.SqlDriver\n\nexpect class DriverFactory {\n    fun createDriver(): SqlDriver\n}\n```\n\n이제 각 대상 플랫폼에 대해 이를 구현해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n안드로이드에서는 AndroidSqliteDriver 클래스가 SQLite 드라이버를 구현합니다.\n그래서 composeApp/src/androidMain/kotlin에서 패키지를 만들어 그 안에 DriverFactory.kt 클래스를 생성해주세요.\n\n```kotlin\npackage com.dwarshb.firebaseauthentication\n\nimport android.content.Context\nimport app.cash.sqldelight.db.SqlDriver\nimport app.cash.sqldelight.driver.android.AndroidSqliteDriver\n\nactual class DriverFactory(var appContext: Context) {\n\n    actual fun createDriver(): SqlDriver {\n        return AndroidSqliteDriver(Database.Schema, appContext, \"firebase.db\")\n    }\n}\n```\n\n이제 Android에서 작동하도록 하기 위해 composeApp/src/androidMain/kotlin에 있는 MainActivity.kt 파일에서 해당 인스턴스를 생성해야 합니다.\n\n```kotlin\nclass MainActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        //Android용 DriverFactory의 인스턴스 생성\n        val driverFactory = DriverFactory(this)\n        setContent {\n            App(driverFactory.createDriver())\n        }\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\niOS에서 SQLite 드라이버 구현은 NativeSqliteDriver 클래스입니다.\n그래서 composeApp/src/iosMain/kotlin에 패키지를 만들고 내부에 DriverFactory.kt 클래스를 만들어 주세요.\n\n```kotlin\npackage com.dwarshb.firebaseauthentication\n\nimport app.cash.sqldelight.db.SqlDriver\nimport app.cash.sqldelight.driver.native.NativeSqliteDriver\n\nactual class DriverFactory {\n    actual fun createDriver(): SqlDriver {\n        return NativeSqliteDriver(Database.Schema, \"firebase.db\")\n    }\n}\n```\n\n이제 MainViewController.kt 파일을 만들어서 iOS에서 작업할 수 있도록 인스턴스를 만들어주세요. 이 파일은 composeApp/src/iosMain/kotlin에 있습니다.\n\n```kotlin\nimport androidx.compose.ui.window.ComposeUIViewController\nimport com.dwarshb.firebaseauthentication.DriverFactory\n\nfun MainViewController() = ComposeUIViewController {\n    val driverFactory = DriverFactory()\n    App(driverFactory.createDriver())\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n데스크톱 환경에서는 SQLite 드라이버 구현이 JdbcSqliteDriver 클래스입니다.\n그래서 composeApp/src/desktopMain/kotlin에 패키지를 만들고 그 안에 DriverFactory.kt 클래스를 생성해주세요.\n\n```js\npackage com.dwarshb.firebaseauthentication\n\nimport app.cash.sqldelight.db.SqlDriver\nimport app.cash.sqldelight.driver.jdbc.sqlite.JdbcSqliteDriver\nimport java.io.File\n\nactual class DriverFactory {\n    actual fun createDriver(): SqlDriver {\n        val databasePath = File(System.getProperty(\"java.io.tmpdir\"), \"firebase.db\")\n        val driver: SqlDriver = JdbcSqliteDriver(url = \"jdbc:sqlite:${databasePath.absolutePath}\")\n        Database.Schema.create(driver)\n        return driver\n    }\n}\n```\n\n이제 데스크톱에서 작동하도록 composeApp/src/desktopMain/kotlin의 main.kt 파일에 인스턴스를 생성해야 합니다.\n\n```js\nimport androidx.compose.ui.window.Window\nimport androidx.compose.ui.window.application\nimport com.dwarshb.firebaseauthentication.DriverFactory\n\nfun main() = application {\n    Window(onCloseRequest = ::exitApplication, title = \"FirebaseAuthentication\") {\n        val driverFactory = DriverFactory()\n        App(driverFactory.createDriver())\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-06-19-MultiplatformMagicOneCodebaseThreePlatforms_5.png\" />\n\n모든 플랫폼에서 DriverFactory를 구성하고 위 단계를 모두 따라왔다면, App() 함수를 수정하고 SqlDriver를 매개변수로 추가해야 합니다. 각 플랫폼에서 SqlDriver의 인스턴스를 가져올 수 있는 유일한 방법이기 때문입니다. 그래서 composeApp/src/commanMain/kotlin/App.kt 안에 다음과 같이 작성하세요.\n\n```js\n@Composable\nfun App(sqlDriver: SqlDriver) {\n    val authenticationViewModel = AuthenticationViewModel(sqlDriver)\n\n    MaterialTheme {\n      ...\n    }\n}\n```\n\n# 단계 7: SQLDelight 쿼리 구성하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 단계에서는 Firebase Authentication API에서 받은 토큰을 저장하여 사용자 세션을 유지하기 위해 insertUser 쿼리를 사용할 예정입니다. 또한 로컬 데이터베이스에 저장된 토큰을 얻기 위해 selectAllUser 쿼리를 사용할 것입니다. AuthenticationViewModel.kt 내에서 먼저 데이터베이스를 초기화할 것입니다.\n\n```js\n    var databaseQuery : DatabaseQueries\n\n    val database = Database(sqlDriver)\n    databaseQuery = database.databaseQueries\n```\n\n이제 API에서 받은 응답을 저장할 storeUserDetails() 메서드를 만들 것입니다. 이 메서드는 로컬 데이터베이스에 정보를 저장하는 데 insertUser 쿼리를 사용합니다. AuthenticationViewModel.kt 파일의 login()이나 signUp() 메서드 내에 이 메서드를 추가할 수 있습니다.\n\n```js\ninternal fun storeUserDetails(response: AuthResponse) {\n        databaseQuery.insertUser(\n            response.idToken, response.email, response.refreshToken,\n            response.email\n        )\n    }\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n세션 유지를 위해 시스템에 이미 토큰이 로컬 데이터베이스에 있는지 확인해야 합니다. 그래서 우리는 selectAllUsers 쿼리를 사용하여 로컬 데이터베이스에 저장된 토큰을 확인하는 checkSession()을 생성할 것입니다.\n\n```kotlin\ninternal fun checkSession(onCompletion: onCompletion) {\n    for(user in databaseQuery.selectAllUsers().executeAsList()) {\n        if (user != null) {\n            onCompletion.onSuccess(user.refreshToken.toString())\n        } else {\n            onCompletion.onError(Exception(\"세션을 찾을 수 없습니다\"))\n        }\n    }\n}\n```\n\n우리는 checkSession() 메서드를 사용하여 결과에 따라 UI를 업데이트할 수 있습니다. 예를 들어, 토큰이 있는 경우 onSuccess 내에서 앱을 MainScreen으로 이동시키고, 그렇지 않은 경우 AuthenticationView 화면이 표시됩니다.\n\n# 데모\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래의 Github 링크에서 전체 코드를 확인해보세요.\n\n# 참조 링크:\n\n- https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-ktor-sqldelight.html#build-an-sdk\n- https://firebase.google.com/docs/reference/rest/auth#section-api-usage\n","ogImage":{"url":"/assets/img/2024-06-19-MultiplatformMagicOneCodebaseThreePlatforms_0.png"},"coverImage":"/assets/img/2024-06-19-MultiplatformMagicOneCodebaseThreePlatforms_0.png","tag":["Tech"],"readingTime":23},{"title":"원활한 사용을 위해 ExecuTorch와 함께 모바일 앱에 원시 AI를 적용하기 - 파트 1 - iOS","description":"","date":"2024-06-19 14:08","slug":"2024-06-19-BringingnativeAItoyourmobileappswithExecuTorchpartIiOS","content":"\n<img src=\"/assets/img/2024-06-19-BringingnativeAItoyourmobileappswithExecuTorchpartIiOS_0.png\" />\n\nExecuTorch는 PyTorch를 기반으로 한 새로운 프레임워크로, PyTorch AI 모델을 로컬 배포에 적합한 형식으로 내보낼 수 있게 해줍니다. 이는 약간의 네이티브 코드와 함께 React Native 앱에 AI 기능을 쉽게 통합할 수 있음을 의미합니다. iOS의 경우, Apple의 Neural Engines 덕분에 고성능을 제공하는 CoreML 백엔드를 활용할 수 있습니다.\n\n이 튜토리얼 시리즈에서는 API 호출이 필요 없이 자신이 선택한 AI 모델을 앱에서 직접 사용하는 방법을 안내해 드릴 것입니다.\n\n## 1. 모델 내보내기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n가장 먼저 해야 할 일은 PyTorch 모델을 .pte 파일로 내보내는 것인데, 이는 본질적으로 PyTorch 실행 가능 파일입니다. 이 부분은 이미 처리해 드렸지만, 만약 여러분의 모델을 사용하고 싶으시다면 ExecuTorch의 Python API를 사용하여 가능합니다. 만약 재현하고 싶다면, 저희 레포지토리에서 모델을 다운로드할 수 있습니다. 여기에서 내보낸 모델들은 PyTorch 예제 레포지토리에서 가져왔습니다. 이를 하기 전에, 환경 설정이 필수적입니다. 기본 내보내기 튜토리얼은 다음을 참조하세요:\n\n전체 프로세스는 여러 단계로 이뤄져 있으며, 사용 사례에 따라 다를 수 있습니다. 모델은 먼저 그래프 표현으로 변환되며, 이후 여러분의 필요에 맞게 최적화될 수 있습니다. 이것은 컴파일, 옵셔널 양자화, 메모리 계획 등을 포함한 다단계 프로세스로, 최종적으로 실행 가능 파일로 내보냅니다. 실행 시, 특정 하드웨어 대상용으로 빌드된 ExecuTorch를 사용하여 장치에서 효율적으로 추론을 수행합니다.\n\n![이미지](/assets/img/2024-06-19-BringingnativeAItoyourmobileappswithExecuTorchpartIiOS_1.png)\n\n이 튜토리얼에서는 이미지를 멋진 아트스타일로 변환하는 스타일 전송 모델을 사용할 것입니다. 만약 웹 및 비디오에 대해 비슷한 일을 하는 방법에 궁금하다면 이전 기사를 확인해보세요. 원하는 모델을 사용하고 싶다면 아래 스크립트를 사용할 수 있습니다. 이를 통해 CoreML 백엔드에 적합한 .pte 파일이 생성될 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 2. 라이브러리 빌드 및 설정하기\n\n실제 코딩 부분에 들어가기 전에, 라이브러리를 빌드하고 Xcode 프로젝트에 연결해야 합니다. 빌드 프로세스는 문서에서 자세히 설명되어 있으므로, 익숙해지는 것을 강력히 권장합니다. 그러나 우리는 이미 빌드했으며 편의를 위해 GitHub 저장소에서 빌드를 다운로드할 수 있습니다.\n\n라이브러리를 다운로드한 후 (coreml_backend.xcframework와 executorch.xcframework), Xcode 프로젝트로 이동하여 -` 빌드 패스 -` 라이브러리와 함께 링크하기 -` +를 클릭하여 프로젝트에 추가해야 합니다. 또한 Xcode에서 기본 제공되는 CoreML.framework와 Accelerate.framework도 추가해야 합니다.\n\n코딩에 들어가기 전에 빌드 설정 -` 다른 링커 플래그로 이동하여 -all_load 플래그를 추가해야 합니다. 이를 통해 라이브러리가 제대로 연결되도록 할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 3. 코딩 파트 — Xcode\n\n구현으로 넘어가면 이제 Objective-C++ 파일을 만들어야 합니다. 이를 StyleTransferModule.mm으로 부르겠습니다. 우리 코드에서는 React Native 앱에서 네이티브 모듈을 사용하여 이 메서드를 호출합니다. 그러나 이것은 선택 사항이며 사용 사례에 맞게 조정할 수 있습니다.\n\n```js\n// StyleTransferModule.mm\n\n#import \"StyleTransferModule.h\"\n#import \"ImageProcessor.h\"\n#import <executorch/extension/module/module.h>\n\nusing namespace ::torch::executor;\n\nconst int32_t imageSize = 640;\nconst int32_t numChannels = 3;\n\n@implementation StyleTransferModule {\n  std::unique_ptr<Module> styleTransferModel;\n}\n\n\nRCT_EXPORT_METHOD(initModule:(NSString *)modelFileName resolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {\n    NSString *styleTransferPath = [[NSBundle mainBundle] pathForResource:modelFileName ofType:@\"pte\"];\n    styleTransferModel= std::make_unique<Module>(styleTransferPath.UTF8String);\n\n    if (styleTransferModel) {\n        resolve(@\"Module created successfully\");\n    } else {\n        NSError *error = [NSError errorWithDomain:@\"com.example.module\" code:1 userInfo:nil];\n        reject(@\"module_error\", @\"Failed to create module\", error);\n    }\n}\n```\n\n먼저 Module 클래스의 인스턴스를 만들어야 합니다. 이는 ExecuTorch 프레임워크의 일부입니다. 이를 통해 모델의 forward()와 같은 내보낸 메서드를 호출할 수 있습니다. 클래스를 인스턴스화하려면 이전에 언급한 .pte 파일의 경로를 전달해야 합니다. 또한 RCT_EXPORT_METHOD 매크로를 사용하여 메서드를 JS로 내보냅니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n모델을 실행하기 전에 다음 단계는 입력 텐서를 준비하는 것입니다. 머신 러닝 프레임워크와 작업을 해본 적이 있다면 텐서에 익숙할 것입니다. 고수준에서 말하면, 이것은 GPU에서 실행할 수 있는 배열입니다.\n\n텐서를 만들려면 이미지의 원시 RGB 데이터를 가져와야 합니다. 저희 저장소에서는 여러 모델을 로드하기 때문에 코드가 약간 다릅니다. 하지만 간단하게 유지하기 위해 이 튜토리얼에서는 한 모델에 집중하겠습니다.\n\n```js\n// StyleTransferModule.mm\nRCT_EXPORT_METHOD(applyStyleTransfer:(NSString *)imageUri resolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {\n{\n    if (!styleTransferModel) {\n        reject(@\"module_error\", @\"Module not initialized\", [NSError errorWithDomain:@\"com.example.module\" code:1 userInfo:nil]);\n        return;\n    }\n\n    NSURL *url = [NSURL URLWithString:imageUri];\n    NSData *data = [NSData dataWithContentsOfURL:url];\n    if (!data) {\n      reject(@\"img_loading_error\", @\"Unable to load image data\", nil);\n      return;\n    }\n    UIImage *inputImage = [UIImage imageWithData:data];\n```\n\n다시 한번 해당 메서드를 JS에 내보냅니다. applyStyleTransfer라고 부르며, NSString 포인터를 받도록 만들었습니다. 이는 표준 JS 문자열과 해당됩니다. 이 문자열은 우리 입력 이미지의 URI가 될 것입니다. 이제 모델이 예상하는 데이터 형식인 원시 RGB 데이터 배열을 만들어야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n// StyleTransferModule.mm\n// ...\n\n// StyleTransferModule.mm\n// ...\n\n  CGSize targetSize = CGSizeMake(imageSize, imageSize);\n  UIImage *resizedImage = [ImageProcessor resizeImage:inputImage toSize:targetSize];\n\n  // to float array - the input\n  float *imageData = [ImageProcessor imageToFloatArray:resizedImage size:&targetSize];\n\n  // make it a tensor\n  int32_t sizes[] = {1, numChannels, imageSize, imageSize};\n  TensorImpl inputTensorImpl(ScalarType::Float, std::size(sizes), sizes, imageData);\n  Tensor inputTensor = Tensor(&inputTensorImpl);\n\n이제 UIImage를 가져와서 사용자 정의 ImageProcessor에 전달합니다. 이것은 사용 사례와 모델에 따라 다양한 전처리 부분입니다. 여기서는 640x640 크기의 이미지 및 float 값 배열이 필요합니다. 크기 조정이 항상 필요한 것은 아니며 동적 입력 형태로 모델을 내보낼 수 있습니다. ImageProcessor가 정확히 무엇을 하는지 보려면 여기를 클릭하세요. 이후에는 해당 데이터로부터 텐서를 생성해야 하므로 데이터 및 텐서 크기를 TensorImpl 생성자에 전달해야 합니다. 마지막으로 TensorImpl을 Tensor 자체로 전달해야 합니다.\n\n다음 단계는 텐서를 모델에 전달하는 것입니다. 이 부분은 매우 간단합니다. 이전에 생성된 Tensor를 EValue로 래핑하고 벡터에 넣은 다음 forward() 메서드(또는 내보낸 다른 메서드)를 실행하기만 하면 됩니다. 벡터에 넣는 이유는 여러 입력을 예상하는 모델이 있기 때문입니다.\n\n// StyleTransferModule.mm\n// ...\n\nconst auto result = styleTransferModel->forward({EValue(inputTensor)});\nif (!result.ok()) {\nNSError *error = [NSError\n        errorWithDomain:@\"ModelForwardFailure\"\n        code:NSInteger(result.error())\n        userInfo:@{NSLocalizedDescriptionKey: [NSString stringWithFormat:@\"Failed to run forward on the torch module, error code: %i\", result.error()]}];\n  reject(@\"model_failure\", error.localizedDescription, error);\n}\nconst float *outputData = result->at(0).toTensor().const_data_ptr<float>();\nfree(imageData);\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n추론 중에 오류가 발생했는지 확인하려면 .ok() 메서드를 호출하면 됩니다. outputData 변수는 모델 호출 결과에 대한 포인터입니다. 이는 분류 작업의 확률부터 LLM 출력까지 어떤 것이든 될 수 있습니다. 마지막으로 후속 처리 단계를 수행하고 출력 이미지 URI를 JS 쪽에 반환해야 합니다.\n\n// StyleTransferModule.mm\n// ...\n\nCGSize outputSize = CGSizeMake(imageSize, imageSize);\nUIImage *outputImage = [ImageProcessor imageFromFloatArray:outputData size:outputSize];\n\n// save img to tmp dir, return URI\nNSString *outputPath = [NSTemporaryDirectory() stringByAppendingPathComponent:@\"processed_image.png\"];\nif ([UIImagePNGRepresentation(outputImage) writeToFile:outputPath atomically:YES]) {\n  NSURL *fileURL = [NSURL fileURLWithPath:outputPath];\n  resolve([fileURL absoluteString]);\n} else {\n  reject(@\"img_write_error\", @\"Failed to write processed image to file\", nil);\n}\n\n그것이 거의 다입니다. 이 접근 방식을 React Native 앱에서 어떻게 사용할 수 있는지 보여주는 데모 앱을 준비했습니다. 왼쪽에 원본 이미지, 오른쪽에 모델 출력이 표시됩니다.\n\n<img src=\"/assets/img/2024-06-19-BringingnativeAItoyourmobileappswithExecuTorchpartIiOS_2.png\" />\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 마지막으로\n\n축하해요! 모델을 성공적으로 실행했어요. ExecuTorch는 LLaMa만큼 큰 모델도 완전히 기기에서 실행할 수 있게 해 주는 거대한 프레임워크야.\n\n이 시리즈의 다음 부분에서는 Android에서도 똑같이 할 수 있는 방법을 보여줄 거에요. 또한 곧 우리의 객체 제거 데모와 관련된 꽤 인상적인 기능을 구현하는 튜토리얼을 공개할 예정이에요 👀. 우리의 AI 및 멀티미디어 작업에 대해 계속해서 소식을 받고 싶다면 RTC.ON 소식지에 가입해주세요. 계속 연락을 유지해 주세요!\n\n우리는 소프트웨어 마스터즈(Software Mansion)입니다: 소프트웨어 개발 컨설턴트, AI 탐험가, 멀티미디어 전문가, React Native 코어 기여자 및 커뮤니티 빌더들이에요. 우리를 고용하고 싶다면 projects@swmansion.com 으로 연락해 주세요.\n```\n","ogImage":{"url":"/assets/img/2024-06-19-BringingnativeAItoyourmobileappswithExecuTorchpartIiOS_0.png"},"coverImage":"/assets/img/2024-06-19-BringingnativeAItoyourmobileappswithExecuTorchpartIiOS_0.png","tag":["Tech"],"readingTime":9},{"title":"iOS 모바일 앱 보안 iOS 모바일 개발자를 위한 최선의 모범 사례","description":"","date":"2024-06-19 14:06","slug":"2024-06-19-IOSMobileAppSecurityBestPracticesforiOSMobileDevelopers","content":"\n![image](/assets/img/2024-06-19-IOSMobileAppSecurityBestPracticesforiOSMobileDevelopers_0.png)\n\niOS 개발자들은 OWASP Top 10을 기반으로 코드 보안, 데이터 저장 및 통신 보안에 중점을 두어야 합니다. iOS는 안드로이드보다 취약성이 적지만 여전히 보안 문제에 직면합니다. 코드와 데이터 통신을 안전하게 보호하여 변조 및 무단 코드 접근을 방지하는 것은 개발자/조직의 책임입니다.\n\n개발자가 주의를 기울여야 할 초보 수준의 위협을 다루기 위해 모든 iOS 개발자는 다음을 주의깊게 살펴봐야 합니다:\n\n# 1. 화면 녹화 및 화면 캡처:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n공격자가 로그인 페이지와 입력된 사용자 이름 및 비밀번호를 캡처할 수 있는 민감한 화면을 녹화할 수 있습니다. 비디오 스트리밍 애플리케이션에서는 사용자가 유료 비디오 콘텐츠를 스트리밍하고 녹화할 수 있습니다.\n은행 애플리케이션에서 스크린샷이나 화면 녹화가 진행되면 민감한 거래 세부 정보가 노출될 수 있는 높은 위험이 있습니다.\n\n우리는 UIScreen.capturedDidChangeNotification을 관찰하고 UIScreen.main.isCaptured를 확인할 수 있습니다.\n\nNotificationCenter를 사용하여 isCaptured의 변경 사항을 관찰합니다:\n\n```js\nNotificationCenter.default.addObserver(self, selector: #selector(screenCaptureDidChange),\n                                       name: UIScreen.capturedDidChangeNotification,\n                                       object: nil)\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n알림 처리를 담당하는 함수입니다.\n\n```js\n@objc func screenCaptureDidChange() {\n    print(\"screenCaptureDidChange.. isCapturing: \\(UIScreen.main.isCaptured)\")\n\n    if UIScreen.main.isCaptured {\n        //TODO: They started capturing..\n        print(\"screenCaptureDidChange - 녹화 중입니다.\")\n    } else {\n        //TODO: They stopped capturing..\n        print(\"screenCaptureDidChange - 녹화가 중지되었습니다.\")\n    }\n}\n```\n\n# 2. 약한 탈옥 탐지:\n\n중요한 점은 탈옥된 기기에서 응용 프로그램 로직 및 동작이 손상될 수 있고, 이는 응용 프로그램을 공격에 노출시킬 수 있습니다. 그러나 어떤 해커라도 이러한 기본 보안 확인을 우회할 수 있음을 인식하는 것이 중요합니다. 따라서 탈옥 탐지 방법에만 의존하여 응용 프로그램의 안전을 보장하는 것이 충분하지 않을 수 있다는 것을 명심하는 것이 좋습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음 텍스트는 기기가 탈옥되었는지 여부를 식별하는 데 관련된 지침 또는 지침으로 보입니다. 이 식별에 도움이 되는 세 가지 테스트가 포함되어 있습니다:\n\n- 기기가 탈옥되었는지 여부를 식별하는 한 가지 방법은 탈옥된 기기에 설치된 고유한 파일 및 응용 프로그램을 확인하는 것입니다. 개발자는 이 테스트를 사용하여 파일 시스템에서 이러한 파일을 찾을 수 있습니다.\n\n```js\nprivate var filesPathToCheck: [String] {\n\n    return [\"/private/var/lib/apt\",\n            \"/Applications/Cydia.app\",\n            \"/private/var/lib/cydia\",\n            \"/private/var/tmp/cydia.log\",\n            \"/Applications/RockApp.app\",\n            \"/Applications/Icy.app\",\n            \"/Applications/WinterBoard.app\",\n            \"/Applications/SBSetttings.app\",\n            \"/Applications/blackra1n.app\",\n            \"/Applications/IntelliScreen.app\",\n            \"/Applications/Snoop-itConfig.app\",\n            \"/usr/libexec/cydia/\",\n            \"/usr/sbin/frida-server\",\n            \"/usr/bin/cycript\",\n            \"/usr/local/bin/cycript\",\n            \"/usr/lib/libcycript.dylib\",\n            \"/bin/sh\",\n            \"/usr/libexec/sftp-server\",\n            \"/usr/libexec/ssh-keysign\",\n            \"/Library/MobileSubstrate/MobileSubstrate.dylib\",\n            \"/bin/bash\",\n            \"/usr/sbin/sshd\",\n            \"/etc/apt\",\n            \"/usr/bin/ssh\",\n            \"/bin.sh\",\n            \"/var/checkra1n.dmg\",\n            \"/System/Library/LaunchDaemons/com.saurik.Cydia.Startup.plist\",\n            \"/System/Library/LaunchDaemons/com.ikey.bbot.plist\",\n            \"/Library/MobileSubstrate/DynamicLibraries/LiveClock.plist\",\n            \"/Library/MobileSubstrate/DynamicLibraries/Veency.plist\"]\n}\n\nfunc isJailBrokenFilesPresentInTheDirectory() -> Bool{\n        var checkFileIfExist: Bool = false\n        filesPathToCheck.forEach {\n            checkFileIfExist =  fm.fileExists(atPath: $0) ? true : false\n            if checkFileIfExist{\n                return\n            }\n        }\n\n        return checkFileIfExist\n    }\n```\n\n2. 응용 프로그램이 탈옥되었는지 여부를 확인하는 또 다른 방법은 샌드박싱 규칙을 준수하는지 여부를 확인하는 것입니다. 파일이 응용 프로그램 번들 외부에서 수정될 수 있는지 확인함으로써 이를 식별할 수 있습니다. 개발자는 응용 프로그램이 샌드박싱 규칙을 준수하는지 확인하려면 이 테스트를 사용할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```swift\nfunc canEditSandboxFilesForJailBreakDetection() -> Bool {\n    let jailBreakTestText = \"JailBreak 테스트\"\n    do {\n        try jailBreakTestText.write(toFile: \"/private/jailBreakTestText.txt\", atomically: true, encoding: String.Encoding.utf8)\n        return true\n    } catch {\n        let resultJailBroken = isJailBrokenFilesPresentInTheDirectory()\n        return resultJailBroken\n    }\n}\n```\n\n3. 어플리케이션이 Cydia URL scheme (Cydia://)을 호출했을 때 성공하면, 기기가 탈옥되었다는 것을 의미합니다. 이 테스트는 개발자가 이 확인을 수행했는지를 확인합니다.\n\n```swift\n// JailBreak 감지를 위해 확장된 프로토콜 함수\nfunc assignJailBreakCheckType() -> Bool {\n    // 시뮬레이터에서 실행 중이라면 앱의 일반 흐름을 따릅니다\n    if !isSimulator {\n        // 기기에 Cydia 앱이 설치되어 있는지 확인\n        guard UIApplication.shared.canOpenURL(URL(string: \"cydia://\")!) else {\n            return false\n        }\n        return true\n    }\n    return true\n}\n```\n\n# 3. 키체인 데이터 보호:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nJailBroken 기기에서 취약한 접근성 옵션을 가진 키 체인 항목이 다른 애플리케이션이나 물리적으로 접근하는 공격자에게 쉽게 노출될 수 있습니다. 그러나 개발자는 이 보안 위험을 완화하기 위해 여러 작업을 선택할 수 있습니다.\n\n- kSecAttrAccessibleWhenUnlocked\n- kSecAttrAccessibleAfterFirstUnlock\n- kSecAttrAccessibleAlways\n- kSecAttrAccessibleWhenUnlockedThisDeviceOnly\n- kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly\n- kSecAttrAccessibleAlwaysThisDeviceOnly\n\n'kSecAttrAccessibleWhenUnlocked'와 같이 가장 쉬운 또는 취약할 가능성이 있는 옵션을 선택하는 것은 잠재적인 보안 위험을 유발할 수 있습니다.\n\n`kSecAttrAccessibleAfterFirstUnlock` 또는 `kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly` 모드는 애플리케이션이 백그라운드 처리를 위해 키체인 항목이 필요한 경우에만 사용해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 4. 파일 데이터 보호:\n\n새 파일을 저장할 때, 개발자는 다음 옵션 중 하나를 선택하여 데이터 보호에 더 나은 이용 방법을 선택할 수 있습니다:\n\n- atomic:\n  데이터를 먼저 보조 파일로 작성한 다음 쓰기가 완료되면 원본 파일을 보조 파일로 교체하는 옵션입니다.\n- withoutOverwriting:\n  파일에 데이터를 작성하려고 하지만 대상 파일이 이미 존재하는 경우 실패하고 에러가 발생하는 옵션입니다.\n- noFileProtection:\n  파일을 쓸 때 암호화하지 않는 옵션입니다.\n- completeFileProtection:\n  장치의 잠금이 해제된 상태에서만 파일에 접근할 수 있는 옵션입니다.\n- completeFileProtectionUnlessOpen:\n  장치가 잠금 해제된 상태이거나 파일이 이미 열려 있는 경우에만 파일에 접근할 수 있는 옵션입니다.\n- completeFileProtectionUntilFirstUserAuthentication:\n  사용자가 장치를 처음 잠금 해제한 후에만 파일에 접근할 수 있는 옵션입니다.\n- fileProtectionMask:\n  시스템이 데이터에 할당하는 파일 보호 옵션을 결정할 때 사용되는 옵션입니다.\n\n'NSFileProtectionNone'과 같이 가장 쉬운 또는 취약성이 높은 옵션을 선택하는 것은 잠재적인 보안 위험을 초래할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n모든 파일에 데이터 보호를 제공하려면 'completeFileProtectionUnlessOpen' 및 'completeFileProtectionUntilFirstUserAuthentication'을 사용하는 것이 좋습니다.\n\n첫 번째 쓰기 시 파일 암호화\n\n```js\ndo {\n    try data.write(to: fileURL, options: .completeFileProtection)\n}\ncatch {\n   // 오류 처리.\n}\n```\n\n기존 파일의 경우 NSFileManager/FileManager 또는 NSURL을 사용할 수 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nFileManager.default.setAttributes([.protectionKey: .completeFileProtection], ofItemAtPath: fileURL.path)\n// 또는\n// `fileProtection` 속성은 읽기 전용이므로 `NSURL`로 캐스트합니다.\n(fileURL as NSURL).setResourceValue(URLFileProtection.complete, forKey: .fileProtectionKey)\n```\n\nCore Data를 사용하면 영구 저장소를 추가할 때 보호 유형을 전달할 수 있습니다:\n\n```js\npersistentStoreCoordinator.addPersistentStore(ofType: NSSQLiteStoreType, configurationName: nil, at: storeURL, options: [NSPersistentStoreFileProtectionKey: .completeFileProtection])\n```\n\n# 5. 암호 필드 표시/숨기기:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n어플리케이션 비밀번호가 로그인 화면 및 기타 민감한 정보 화면을 녹화하는 동안 노출될 수 있습니다.\n\n녹화된 화면을 식별하면, 패스워드 텍스트 필드 또는 다른 민감한 텍스트 필드에 '마스크'를 사용하여 데이터 보안을 보호해주세요.\n어플이 녹화 중일 때는 키보드를 숨기거나 없애주세요.\n\n```js\nif(isRecording){\n    let maskView = UIView(frame: CGRect(x: 64, y: 0, width: 128, height: 128))\n    maskView.backgroundColor = .blue\n    maskView.layer.cornerRadius = 64\n    yourView.mask = maskView\n}\n```\n\n# 6. SSL 인증서 만료일:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n일반적으로 인증서는 1년 동안 유효하며 작업을 계속하려면 갱신이 필요합니다. 갱신이 제때 완료되지 않으면 앱이 작동을 멈출 수 있습니다.\n\n만료 날짜 이전에 인증서를 갱신하고 IPA를 업데이트하여 원활한 앱 기능을 보장하는 것이 좋습니다. 또한, 매번 실행할 때 인증서 만료를 확인하고 만료 날짜 몇 일 전에 새로운 인증서를 요청하는 것이 중요합니다.\n\n# 7. 인증서 핀 없음:\n\n공격자가 해당 도메인에 대한 유효한 인증서를 만들 수 있다면 사용자를 속여 안전한 웹사이트를 방문하고 있는 것으로 오해시킬 수 있습니다. 실제로는 사용자가 사칭된 웹사이트로 연결되는 상황이 됩니다. 이 공격은 `중간자 공격(Man-in-the-Middle attack)`으로 알려져 있으며 공격자가 사용자와 웹사이트 사이의 트래픽을 가로채고 해독하여 민감한 정보를 노출시키고 다른 취약점을 악용할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 delegate가 구현해야 하는 내용입니다:\n\nURLSession:task:didReceiveChallenge:completionHandler:\n모든 연결을 인증서 인증을 통해 처리해야 합니다.\n\n```js\nfunc urlSession(_ session: URLSession, didReceive challenge: URLAuthenticationChallenge, completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void) {\n  if let trust = challenge.protectionSpace.serverTrust, SecTrustGetCertificateCount(trust) > 0 {\n    if let certificate = SecTrustGetCertificateAtIndex(trust, 0) {\n      let data = SecCertificateCopyData(certificate) as Data\n        if certificates.contains(data) {\n          completionHandler(.useCredential, URLCredential(trust: trust))\n          return\n         } else {\n           //TODO: Throw SSL Certificate Mismatch\n         }\n      }\n  }\n  completionHandler(.cancelAuthenticationChallenge, nil)\n}\n```\n\n# 8. HTTP 요청의 사용법\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n애플리케이션은 안전하지 않은 통신 채널(HTTP)을 사용합니다. 이는 피해자와 동일한 네트워크에 있는 공격자가 공격자가 제어하는 서버로의 301 HTTP 리디렉션 응답을 주입하여 중간자 공격을 수행할 수 있다는 것을 의미합니다.\n\n## 9. 개인 정보 자원 액세스:\n\n애플리케이션은 연락처, 위치, 블루투스 장치 ID, 카메라 및 마이크와 같은 개인 장치 및/또는 사용자 자원에 액세스할 수 있습니다. 그러나 이는 데이터가 인터넷을 통해 평문으로 전송될 경우 데이터 유출로 이어질 수 있습니다. 이를 방지하기 위해 개발자는 이러한 자원에 대한 액세스가 안전한 정책을 따르도록 보장해야 합니다. 즉, 데이터를 서버로 전송하기 전에 암호화한다는 것입니다. 또한, 자원에 안전하지 않은 액세스 방식을 사용하는 써드파티 라이브러리가 사용 중이 아닌지 확인하는 것이 중요합니다. 개인 자원에 대한 모든 액세스를 검증하고 보안 정책을 준수하도록 강제해야 합니다. 광고 식별자나 ABAddressBookRef 등을 사용하는 경우와 같이요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 10. 디버그 로그 활성화:\n\n릴리스 빌드에서는 메소드 완료 세부 정보와 민감한 정보를 출력하는 디버그 로그를 피해야 합니다.\n\n#ifDef DEBUG 또는 디버그 빌드에서만 debug=1을 활성화하십시오. NSLog는 엄격히 피해야 합니다.\n\n```js\n#ifdef DEBUG\nprint(\"로그 문구\")\n#endif\n```\n","ogImage":{"url":"/assets/img/2024-06-19-IOSMobileAppSecurityBestPracticesforiOSMobileDevelopers_0.png"},"coverImage":"/assets/img/2024-06-19-IOSMobileAppSecurityBestPracticesforiOSMobileDevelopers_0.png","tag":["Tech"],"readingTime":13},{"title":"iOS 빌드 시스템을 Buck에서 Bazel로 전환하기","description":"","date":"2024-06-19 14:05","slug":"2024-06-19-MigratingOuriOSBuildSystemfromBucktoBazel","content":"\n<img src=\"/assets/img/2024-06-19-MigratingOuriOSBuildSystemfromBucktoBazel_0.png\" />\n\n## Airbnb은 Buck에서 Bazel로의 iOS 움직임을 효율적이고 투명하게 성공적으로 달성했습니다. 개발자의 작업에 최소한의 방해를 주면서요.\n\n작성자: Qing Yang, Andy Bartholomew\n\nAirbnb에서는 엔지니어들에게 최고의 경험을 제공하기 위해 노력하고 있습니다. 모든 플랫폼에서 일관되고 효율적인 빌드 경험을 제공하기 위해 저희는 빌드 시스템으로 Bazel을 도입하기로 결정했습니다. Bazel은 산업에서 널리 사용되는 견고한 빌드 시스템입니다. Airbnb의 기술 계획에 부합하여, 백엔드 및 프론트엔드 팀은 모두 Bazel로의 이관 프로세스를 시작했습니다. 첫 번째 Bazel 포스트에서는 iOS 개발에서 Buck에서 Bazel로의 이관 작업에 대해 시작합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저희는 두 가지 주요 작업으로 구성된 이주 접근 방식을 설명하겠습니다: 빌드 구성 이주 및 IDE 통합 이주. 이러한 전환은 엔지니어들의 작업 흐름을 방해하거나 새로운 기능 개발을 저해할 수 있지만, 우리는 개발자들의 일상 경험을 방해하지 않고 성공적으로 이주할 수 있었습니다. 저희 목표는 현재 유사한 이주를 진행하고 있는 분들이나 이와 유사한 이주를 계획 중인 분들을 도와드릴 수 있도록 하는 것입니다.\n\n# 빌드 구성 이주\n\n빌드 구성에 관련하여, Buck와 Bazel은 상당한 유사성을 보여줍니다. 두 빌드 시스템은 유사한 디렉토리 구조를 사용하고 유도 명령어 호출도 비슷하며 중요한 것은 둘 다 Starlark 언어를 사용한다는 점입니다. 이러한 유사성은 두 빌드 시스템 간의 구성 공유 기회를 제공합니다. 이를 통해 우리는 Buck 구성을 Bazel에서 재사용할 수 있게 되었고, 두 빌드 시스템을 모두 사용하면서 이주를 진행하고 있는 \"중첩\" 단계에서 지연을 피할 수 있었습니다.\n\n하지만, Buck와 Bazel은 서로 다른 매개변수를 가진 구별된 규칙을 사용합니다. 예를 들어, Buck은 apple_library 및 apple_binary와 같은 규칙을 제공하는 반면, Bazel은 외부 규칙 세트에 따라 swift_library와 apple_framework와 같은 규칙을 갖습니다. 두 시스템 모두 genrule과 같은 이름의 규칙이 있는 경우라도, 해당 규칙을 구성하는 구문은 종종 다릅니다. 이 두 시스템의 다른 디자인 철학은 다양한 호환성 문제로 이어집니다. 예를 들어, Bazel은 macro에서 명령줄 옵션을 읽는 read_config 함수를 갖고 있지 않습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## rules_shim으로 차이점 숨기기\n\nBuck와 Bazel의 심층 분석을 수행한 후, 두 시스템 간의 차이점을 해결하고 유사성을 활용하기 위해 빌드 구성에 대한 포괄적인 아키텍처를 개발했습니다.\n\n![이미지](/assets/img/2024-06-19-MigratingOuriOSBuildSystemfromBucktoBazel_1.png)\n\n이 아키텍처의 핵심에는 rules_shim 레이어가 있으며, Buck와 Bazel을 위한 두 세트의 규칙을 도입합니다. 이 규칙 세트는 네이티브 및 외부 규칙 주변에 래퍼 역할을 하여 상위 레이어에 대한 통합된 인터페이스를 제공합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nrules_shim이 정확히 어떻게 작동하는지 궁금하신가요? 로컬 저장소를 활용하여 rules_shim 저장소를 빌드 시스템에 따라 다른 구현으로 지정할 수 있습니다.\n\nBuck의 .buckconfig에서 결과물이 어떻게 나타나는지 살펴보겠습니다:\n\n```js\n[repositories];\nrules_shim = rules_shim / buck[buildfile];\nname = BUILD;\n```\n\n또한, 이미 존재하는 BUCK 파일들을 BUILD로 이름을 변경하고 Buck에서도 config 파일로 사용하도록 설정했으므로, Buck와 Bazel에서 동일한 구성을 인식할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nBazel의 WORKSPACE에서는 다음을 수행합니다:\n\n```js\nlocal_repository((name = \"rules_shim\"), (path = \"rules_shim/bazel\"));\n```\n\n일반적인 BUILD 파일에서는 my_library를 사용하여 네이티브 규칙을 감싸고 각 애플리케이션에 동일한 인터페이스를 제공합니다:\n\n```js\nload(\"@rules_shim//:defs.bzl\", \"my_library\", …)\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n앱별 규칙 레이어는 구현이 아닌 인터페이스만을 알아야 합니다. 그 결과로 Buck 또는 Bazel 명령을 실행할 때, 빌드 시스템은 rules_shim 레이어에서 해당 구현을 검색할 수 있습니다. 이 설계의 주목할만한 장점은 마이그레이션 이후에 rules_shim/buck를 쉽게 제거할 수 있다는 것입니다.\n\n## genrule 인터페이스 통합\n\n우리 iOS 코드베이스 내에서, 우리는 생성된 코드에 많이 의존하여 엔지니어들에 대한 유지관리 부담을 줄이는 데 사용합니다. 두 빌드 시스템 간 genrule 스크립트의 다른 구문 때문에, 우리는 genrule을 위한 통합된 인터페이스를 설계했습니다. 이로 인해 동일한 genrule 스크립트가 두 빌드 시스템 모두에서 작동할 수 있습니다. 아마도 이미 추측했겠지만, 변환 과정은 rules_shim 레이어에서 구현되었습니다.\n\n![링크 텍스트](/assets/img/2024-06-19-MigratingOuriOSBuildSystemfromBucktoBazel_2.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## read_config을 select로 교체하기\n\n조건부 구성은 피할 수 없습니다. 왜냐하면 디버그 빌드와 릴리스 빌드와 같은 빌드 제품의 다양한 변형이 항상 있기 때문입니다. Buck은 매크로에서 명령줄 옵션을 읽는 read_config라는 함수를 제공하지만, Bazel은 로딩 단계의 엄격한 분리로 인해 이 기능을 제공하지 않습니다. Buck은 select 함수를 지원하지만 문서화되어 있지 않습니다. 따라서 우리는 모든 read_config 인스턴스를 select 기반 조건으로 마이그레이션했습니다.\n\n```js\ndeps = select({\n  \"//:DebugBuild\": non_production_deps,\n  \"//:ReleaseBuild\": [],\n  # SELECT_DEFAULT는 Buck과 Bazel에서 사용하는 서로 다른 기본 문자열을 고려하기 위해 rules_shim에서 정의됩니다\n  SELECT_DEFAULT: non_production_deps,\n}),\n```\n\n전체적으로, 이 설계를 통해 빌드 시스템의 빌드 구성을 단일로 활용하며, BUILD 파일 자체에는 최소한의 변경이 있습니다. 실제로 Airbnb의 iOS 엔지니어들은 주로 BUILD 파일을 수동으로 수정할 일이 거의 없습니다. 이 파일들은 주로 기본 소스 코드 분석을 통해 자동으로 업데이트됩니다. 그러나 파일을 직접 수정해야 하는 경우에는 특정 빌드 시스템에 대한 지식이 필요하지 않고 통합된 인터페이스에 의존할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# IDE 통합 마이그레이션\n\n에어비앤비의 iOS 엔지니어들은 주로 Xcode를 통해 빌드 시스템과 상호 작용합니다. 처음 Buck를 도입한 이후로, 우리는 로컬 개발을 위해 Buck에서 생성한 Xcode 워크스페이스를 활용해 왔습니다. 몇 년 동안 이러한 설정 위에 다양한 생산성 향상 기능을 개발했습니다. 이에는 단일 모듈에 초점을 맞춘 작은 개발 애플리케이션인 Dev App, 빌드 및 원격 캐시를 활용하는 Buck Local 및 IDE 성능을 크게 향상시키는 Focus Xcode 워크스페이스도 포함됩니다. 이는 작업 중인 모듈만로드하여 IDE 성능을 크게 향상시킵니다.\n\nBazel 생태계에서는 Xcode 워크스페이스를 생성하기 위한 다양한 솔루션이 존재합니다. 그러나 우리가 평가할 당시, 이 중 어떤 것도 우리의 요구 사항을 완벽하게 충족하지 못했습니다. 또한 IDE 통합은 빌드뿐만 아니라 편집, 색인, 테스트 및 디버깅도 지원해야 합니다. 현재의 워크스페이스 설정이 검증된 track record와 안정성을 가지고 있기 때문에 완전히 새로운 것으로 전환하는 위험이 너무 높다고 판단했습니다. 그래서 우리는 현재의 설정과 유사한 워크스페이스를 생성하기 위해 우리만의 생성자를 개발하기로 결정했습니다. 빌드 시스템 구현 세부 사항을 분리하기 위한 추상화 계층으로 작동하는 YAML 구성에서 Xcode 프로젝트를 생성하는 인기 있는 도구 인 XcodeGen을 선택했습니다.\n\n![이미지](/assets/img/2024-06-19-MigratingOuriOSBuildSystemfromBucktoBazel_3.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리는 세 단계로 구성된 마이그레이션 프로세스를 구현했어요.\n\n첫째로, 우리는 코드베이스에서 필요한 모든 정보를 수집하고 Xcode 워크스페이스를 생성하기 위해 buck query를 활용했어요. 이 과정에서 buck project 명령을 대체했어요. 이 새로운 워크스페이스는 빌드 프로세스 중에 buck build를 호출했어요. 빌드 시스템을 변경하지 않고 유지함으로써, 새로운 생성기의 성능을 평가하고 호환성을 보장했어요.\n\n둘째로, 우리는 Bazel을 사용하여 bazel query와 bazel build에서 병렬 구현을 수행했어요. 생성 스크립트에 간단한 --bazel 옵션을 통합하여 Xcode 내에서 두 빌드 시스템 간에 전환할 수 있는 기능을 추가했어요. 빌드 시스템 외에는 사용자 인터페이스가 동일하게 유지되어, IDE 작업이 이전과 동일하게 작동하도록 보장했어요.\n\n마지막으로, 충분한 수의 사용자가 Bazel을 선택하고 모든 Bazel 기능이 철저히 테스트를 거친 후, --bazel 옵션을 기본값으로 설정하여 Bazel로의 원활한 전환을 완료했어요. 문제가 발생했다면 손쉽게 롤백할 수 있는 선택권이 있었어요. 수주 후에는 생성된 프로젝트에서 Buck 지원을 제거했어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 마이그레이션의 최종 결과는 인상적입니다. Buck로 생성된 프로젝트와 비교하여 XcodeGen을 사용한 생성 시간이 60% 줄어들었고, Xcode의 오픈 시간도 70% 이상 감소했습니다. 이로 인해 이 새로운 워크스페이스 설정은 내부 개발자 경험 조사에서 최상위 순위를 차지하며, 이 프로세스를 통해 달성된 중요한 개선 사항을 보여주었습니다.\n\n# 마이그레이션 완료 및 전망\n\nBuck를 사용한 부분에 대해 공통 인터페이스 추상화를 도입하고 Buck와 Bazel 간의 차이를 처리하기 위해 별도의 구현을 삽입했습니다. \"간접\" 원칙 덕분에 코드를 크게 재작성하지 않고 각 구현을 테스트하고 업데이트할 수 있었으며, 로컬 개발, CI 테스트 및 릴리스를 포함한 모든 사용 사례에서 부드럽게 Buck에서 Bazel로 이전하는 데 성공했습니다. 이 마이그레이션 프로세스는 엔지니어들의 작업 흐름을 방해하지 않고 실행되었으며, 실제로 SwiftUI 미리보기 지원을 포함한 여러 새로운 기능을 제공할 수 있었습니다.\n\nBazel이 iOS 빌드 시스템이 된 후, 증분 빌드에 특히 빌드 시간이 크게 개선되었음을 관찰했습니다. 이러한 전환으로 인해 Airbnb 내에서 원격 캐시와 같은 공유 인프라를 활용할 수 있게 되었으며, 결과적으로 여러 플랫폼 간의 협업이 촉진되었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저희 iOS 빌드 시스템을 이전하는 것은 에어비앤비에서 진행 중이거나 완료된 여러 Bazel 마이그레이션 중 첫 번째입니다. 저희는 Java/Kotlin/Scala로 된 JVM 기반 언어, JavaScript, Go용 리포지토리를 보유하고 있는데, 이미 Bazel을 사용 중인 것이나 미래에 사용할 것입니다. 전체 코드베이스에 걸쳐 함께 사용되는 단일 빌드 도구를 믿고 있어서 빌드 도구 및 교육에 대한 투자를 효과적으로 활용할 수 있을 것으로 기대합니다. 미래에는 다른 Bazel 마이그레이션에서 얻은 교훈을 공유할 예정입니다.\n\niOS Bazel 마이그레이션의 기술 리드인 Qing Yang은 구성 아키텍처와 새 프로젝트 생성기를 설계하고 구현했습니다. Andy Bartholomew는 모든 테스트의 마이그레이션을 이끌었고 스크립트 추상화 레이어를 구현했습니다. Xianwen Chen은 Bazel의 릴리스 빌드를 마이그레이션하고 관리했습니다.\n\n에어비앤비 내의 다수의 Bazel 전문가로부터 받은 귀중한 지원에 무한한 감사를 표합니다. 특히 Janusz Kudelka에게는 주제에 대한 소중한 조언과 지도를 제공해 준 것에 대해 특별히 감사드립니다.\n\n또한 Bazel iOS 커뮤니티에 우리의 마이그레이션 여정 동안 제공해준 다양한 오픈 소스 프로젝트와 지원에 대해 감사의 마음을 전합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저희가 App Store에서 최고의 iOS 앱을 만들기 위한 여정에 참여하고 싶으시다면, 열려 있는 iOS 및 개발자 플랫폼 직무를 확인해주세요.\n\n모든 제품 이름, 로고 및 브랜드는 각 소유자들의 소유입니다. 이 웹사이트에서 사용된 모든 회사, 제품 및 서비스 이름은 식별 목적으로만 사용되었습니다. 이러한 이름, 로고 및 브랜드의 사용은 승인을 시사하지 않습니다.\n","ogImage":{"url":"/assets/img/2024-06-19-MigratingOuriOSBuildSystemfromBucktoBazel_0.png"},"coverImage":"/assets/img/2024-06-19-MigratingOuriOSBuildSystemfromBucktoBazel_0.png","tag":["Tech"],"readingTime":10},{"title":"iOS 18 Early에서 새로운 Siri UI애플 인텔리전스 UI를 만나보세요","description":"","date":"2024-06-19 14:04","slug":"2024-06-19-ExperiencetheNewSiriUIEnableAppleIntelligenceUIiniOS18Early","content":"\n![이미지](/assets/img/2024-06-19-ExperiencetheNewSiriUIEnableAppleIntelligenceUIiniOS18Early_0.png)\n\n여러 플랫폼에서 iOS 18에서 새로운 Siri UI 또는 애플이 애플 인텔리전스 UI를 활성화하지 않은 것에 대한 게시물을 본 적이 있을 것입니다. 그러나 iOS 18 Developer Beta 1 (빌드 109)에는 아직 새로운 Siri 관련 기능이 포함되어 있지 않습니다.\n\n하지만 좋은 소식이 있습니다! 다음 단계를 따라 새 Siri 인터페이스의 미리보기를 볼 수 있습니다.\n\n# 중요 사항:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 새로운 Siri UI를 활성화하면 사용자 인터페이스만 변경됩니다. Apple Intelligence 기능은 아직 제공되지 않습니다.\n\n새로운 Siri UI는 iOS 18/iPadOS 18 개발자 베타 1을 실행하는 모든 iPhone 및 iPad과 호환됩니다. 그러나 출시되면 M1 또는 A17 Pro 칩 및 그 이후의 장치만 Apple Intelligence 기능을 지원할 것입니다.\n\n## 시작하기 전에\n\n- 장치 백업: 진행하기 전에 장치를 백업해야 합니다. 데이터는 중요하며 보호해야 합니다.\n- Find My iPhone/iPad 비활성화: 설정에서 `[당신의 Apple ID]` Find My ` Find My iPhone/iPad로 이동하여 일시적으로 비활성화하세요.\n- 필수 조건: 이 프로세스에는 Mac 또는 Windows PC가 필요합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-06-19-ExperiencetheNewSiriUIEnableAppleIntelligenceUIiniOS18Early_1.png\" />\n\n# 새 Siri UI를 활성화하는 단계\n\n## Mac 사용자를 위한 방법\n\n- Cowabunga Lite 다운로드 및 설치:\n  이 Github 링크로 이동하여 macOS 12 버전을 다운로드하십시오.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Step 2: Connect Your Device](/assets/img/2024-06-19-ExperiencetheNewSiriUIEnableAppleIntelligenceUIiniOS18Early_2.png)\n\n2. Connect Your Device: Use a USB cable to connect your iPhone or iPad to your Mac.\n\n![Step 3: Open Cowabunga Lite](/assets/img/2024-06-19-ExperiencetheNewSiriUIEnableAppleIntelligenceUIiniOS18Early_3.png)\n\n3. Open Cowabunga Lite. You’ll be greeted with this screen.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Image 1](/assets/img/2024-06-19-ExperiencetheNewSiriUIEnableAppleIntelligenceUIiniOS18Early_4.png)\n\n4. Navigate to the Custom Operation tab on the left.\n\n![Image 2](/assets/img/2024-06-19-ExperiencetheNewSiriUIEnableAppleIntelligenceUIiniOS18Early_5.png)\n\n5. Import the Configuration File: Click on Import .cowperation, then select the iOS_18_Siri.cowperation\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/assets/img/2024-06-19-ExperiencetheNewSiriUIEnableAppleIntelligenceUIiniOS18Early_6.png)\n\n6. 새 Siri UI 활성화: 편집을 클릭하고 \"활성화\" 옵션이 선택되었는지 확인하세요.\n\n![이미지](/assets/img/2024-06-19-ExperiencetheNewSiriUIEnableAppleIntelligenceUIiniOS18Early_7.png)\n\n7. 조정 적용: 왼쪽에있는 \"적용\" 탭으로 이동하여 조정 적용 버튼을 클릭하세요. 이 과정은 시간이 걸릴 수 있습니다. 기기가 다시 시작되고 설정 화면이 표시됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n경고: \"iPhone 부분 설정됨\"이라는 화면을 만나면 큰 파란 버튼을 누르지 마세요. 대신 데이터를 보호하려면 \"부분 설정으로 계속\"을 눌러주세요.\n\n![이미지](/assets/img/2024-06-19-ExperiencetheNewSiriUIEnableAppleIntelligenceUIiniOS18Early_8.png)\n\n직접 다운로드하기: Cowabunga Configuration\n\n## Windows 사용자를 위한\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- Cowabunga Lite 다운로드 및 설치: 구글에서 소프트웨어를 검색합니다.\n- 기기 연결: USB 케이블을 사용하여 iPhone 또는 iPad을 PC에 연결합니다.\n- 설정 옵션: Cowabunga Lite에서 설정 옵션 탭에서 SkipSetup 옵션이 선택되어 있는지 확인합니다.\n- 구성 파일 추가: 파일 탐색기에서 %APPDATA%/CowabungaLite/Workspace로 이동합니다. UUID를 찾은 다음 SkipSetup/ManagedPreferencesDomain/mobile로 이동하여 plist 파일을 추가합니다 (다운로드 가능).\n- 트윅 적용: Cowabunga Lite에서 왼쪽의 Apply 탭으로 이동하여 Apply Tweaks 버튼을 클릭합니다. 이 프로세스는 시간이 소요됩니다. 기기가 다시 시작되고 설정 화면이 나타납니다.경고: \"iPhone Partially Set Up\"이라는 화면이 표시되면 큰 파란 버튼을 탭하면 안 됩니다. 대신 \"부분 설정으로 계속\"을 탭하여 데이터를 보존합니다.\n","ogImage":{"url":"/assets/img/2024-06-19-ExperiencetheNewSiriUIEnableAppleIntelligenceUIiniOS18Early_0.png"},"coverImage":"/assets/img/2024-06-19-ExperiencetheNewSiriUIEnableAppleIntelligenceUIiniOS18Early_0.png","tag":["Tech"],"readingTime":5},{"title":"iOS SwiftUI 프로젝트에서 MVVM으로 적용하는 Clean Architecture","description":"","date":"2024-06-19 14:01","slug":"2024-06-19-TheCleanArchitecturewithMVVMintheiOSSwiftUIProject","content":"\n![Clean Architecture](/assets/img/2024-06-19-TheCleanArchitecturewithMVVMintheiOSSwiftUIProject_0.png)\n\nClean architecture는 Robert C. Martin(명칭: Uncle Bob)이 소개한 소프트웨어 디자인 원칙입니다. Hexagonal Architecture, Onion Architecture, Screaming Architecture 등 소프트웨어 아키텍처에 대한 몇 가지 아이디어가 있었습니다. 이러한 아키텍처들의 주요 개념은 관심사의 분리입니다.\n\n이 기사에서는 클린 아키텍처를 논의하고, 데모 프로젝트를 통해 iOS SwiftUI 앱에 Clean Architecture와 MVVM을 적용하는 방법을 살펴볼 것입니다.\n\n# 클린 아키텍처\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![그림](/assets/img/2024-06-19-TheCleanArchitecturewithMVVMintheiOSSwiftUIProject_1.png)\n\n위 그래프에서 확인할 수 있듯이, 원들은 소프트웨어의 서로 다른 영역을 나타냅니다. 가장 바깥쪽 층은 소프트웨어의 가장 낮은 수준이며, 깊이 들어갈수록 소프트웨어의 수준이 높아집니다. 내부 층은 외부 층에 대해 아무것도 알지 못합니다. 보통, 층이 깊어질수록 해당 층은 변하기 적은 경향이 있습니다.\n\n클린 아키텍처의 주요 규칙은 내부 층에서 외부 층으로의 의존성을 갖지 않는 것입니다. 의존성은 외부 층에서 내부 층으로 연결되어야 합니다. 바깥쪽에서 안쪽으로 향하는 화살표가 의존성 규칙입니다.\n\n클린 아키텍처에는 다양한 층이 있으며, 그룹화한 후에 프레젠테이션, 도메인 및 데이터 층 세 개로 구분할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-06-19-TheCleanArchitecturewithMVVMintheiOSSwiftUIProject_2.png\" />\n\n## 표현 계층\n\n이 계층은 View와 ViewModel로 구성되어 있습니다. View는 하나 이상의 사용 사례를 실행하는 ViewModel에 의해 조정됩니다. 표현 계층은 도메인 계층에만 의존합니다.\n\n## 도메인 계층\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이것은 가장 안쪽 레이어입니다. 이 레이어에는 Entities, Use cases 및 Repository interfaces가 포함되어 있습니다. 이 레이어는 다른 레이어에 종속적이지 않습니다. 따라서 이 레이어는 재사용이 가능하고 테스트하기 쉽습니다. 또한 비즈니스 로직이 여기에 작성됩니다.\n\n## 데이터 레이어\n\n이 레이어에는 리포지토리 구현 및 데이터 소스가 포함되어 있습니다. 리포지토리는 데이터 소스로부터 데이터를 조정하는 역할을 합니다. 데이터 소스는 원격 또는 로컬(예: 코어 데이터)일 수 있습니다. 데이터 레이어는 도메인 레이어에 종속됩니다. 이 레이어에서는 네트워크 JSON 데이터를 도메인 모델로 매핑할 수 있습니다.\n\n## 의존성 방향과 데이터 흐름\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n인터페이스(UI)는 ViewModel(프리젠터)에서 메서드를 호출합니다. ViewModel은 Use Case를 실행하고, Use Case는 데이터를 가져오기 위해 Repository를 호출합니다. Repository는 네트워크나 영구 저장 DB에서 데이터를 가져옵니다. 데이터는 다시 UI로 흐르고, 여기서 데이터를 보여줍니다.\n\n이 흐름은 다음과 같습니다:\n\n인터페이스(UI) - ViewModel(프리젠터) - Use Case(도메인) - Repository(데이터)\n\n이 흐름은 Clean Architecture의 종속성 규칙을 위배합니다. 종속성 규칙에 따르면, 가장 내부에 있는 도메인 레이어는 가장 바깥에 있는 데이터 레이어에 종속되어서는 안 됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n도메인 계층(Use Case)이 사용 사례(도메인 계층)부터 직접적으로 의존하는 대신, 사용 사례는 저장소 인터페이스/프로토콜에 의존하게 됩니다. 이 저장소 프로토콜은 도메인 계층 안에 존재할 것입니다. 이렇게 함으로써 우리는 흐름의 방향을 뒤집을 수 있습니다. 이 뒤집힌 방향이 어떻게 이뤄지는지 자세히 이해해 봅시다:\n\n![이미지](/assets/img/2024-06-19-TheCleanArchitecturewithMVVMintheiOSSwiftUIProject_3.png)\n\n의존성 역전은 데이터 계층과 도메인 계층 간에 발생합니다. 도메인 계층 내부에 저장소 인터페이스가 있기 때문에 데이터 계층은 저장소 인터페이스를 위해 도메인 계층에 의존하게 됩니다. 도메인 계층에서 인터페이스가 변경된다면 데이터 계층도 그에 따라 변경될 것입니다. 여기서는 의존성 방향이 역전되어 있습니다.\n\n인터페이스는 더 높은 수준(도메인에서)에서 결정되고 해당 수준의 클래스(사용 사례)가 이에 의존하므로 추상화에 의존하게 됩니다. 게다가 하위 수준 클래스(저장소) 구현은 더 높은 수준에서 정의된 인터페이스에 의존하므로 세부 사항은 이제 추상화에 의존하게 됩니다. 이것이 바로 의존성 역전의 원칙입니다. 기억하세요, 소프트웨어의 내부 원이 더 높은 수준의 소프트웨어 수준이므로 도메인 계층은 데이터 계층보다 높은 수준에 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그래서, 흐름이 다음과 같이 됩니다:\n\n프레젠테이션 레이어 — `도메인 레이어` — 데이터 레이어\n\n이론은 여기까지! 이제 각 레이어와 MVVM을 예제 프로젝트 및 샘플 코드를 통해 이해하는 시간입니다.\n\n# 예제 프로젝트 — ProductClean\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이것은 공개 API에서 제품 목록을 가져와 목록으로 표시하는 간단한 iOS 애플리케이션입니다. 목록에서 각 항목을 클릭하면 제품 세부 정보 페이지로 이동합니다. 이 프로젝트는 MVVM과 Clean 아키텍처를 사용하여 구축되었습니다. SwiftUI를 사용하여 UI를 구현했습니다.\n\nClean 아키텍처는 구성 요소 간의 역할 분리를 위해 사용되었고 MVVM과 Clean 아키텍처를 함께 사용하여 UI와 프리젠터 사이의 역할을 분리했습니다.\n\n앱의 HLD (고수준 설계) 및 폴더 구조를 살펴보겠습니다:\n\nHLD를 통해 이 앱에는 제품이라는 단일 모듈이 있음을 알 수 있습니다. 필요한 경우 여러 모듈을 가질 수 있습니다. 예를 들어, 이 앱에 로그인 및 결제 기능을 추가하려면 로그인 및 결제 모듈을 추가할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저희는 세 개의 레이어를 가지고 있다는 것을 알고 있어요. 각 레이어를 자세히 살펴볼게요:\n\n## 프레젠테이션 레이어\n\n프레젠테이션 레이어 = ViewModel(프레젠터) + View(UI)\n\n프레젠테이션 레이어에는 ProductListView와 ProductListViewModel이 포함되어 있어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nProductListView\n\nProductListView는 비즈니스 로직(Use cases)에 대한 접근이 없고 데이터 조작과 관련된 코드도 포함하고 있지 않아요. 오직 ViewModel에만 접근할 수 있어요. 따라서 뷰는 재사용성이 높아지고 교체가 가능해져요.\n\n뷰는 ViewModel에 제품 데이터를 가져오도록 요청하고 ViewModel에서 제품 배열을 관찰해요. 제품 배열을 받으면 해당 데이터를 목록에서 표시해요.\n\n```js\nimport SwiftUI\n\nstruct ProductListView<ViewModel>: View where ViewModel: ProductListViewModelProtocol {\n\n    @ObservedObject private var viewModel: ViewModel\n    init(viewModel: ViewModel) {\n        self.viewModel = viewModel\n    }\n\n    var body: some View {\n        NavigationStack {\n            if viewModel.shouldShowLoader() {\n                ProgressView()\n                    .progressViewStyle(.circular)\n            } else {\n                ProductListLayout(items: viewModel.products)\n                    .overlay {\n                        if viewModel.isError {\n                            ErrorView(errorTitle: AppConstant.errorTitle, errorDescription: viewModel.error) {\n                                Task {\n                                    await fetchProducts()\n                                }\n                            }\n                        }\n                    }\n                    .navigationTitle(viewModel.title)\n            }\n        }\n        .task {\n            await fetchProducts()\n        }\n    }\n\n    private func fetchProducts() async {\n        await viewModel.fetchProducts()\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n참고: @ObservedObject 프로퍼티 래퍼는 뷰 내에 observable 유형인 ViewModel을 저장하는 데 사용됩니다.\n\nProductListViewModel\n\nProductListViewModel은 어떤 UI 프레임워크도 import하지 않습니다. 따라서 재사용 가능해집니다. 이는 ProductListViewModelProtocol을 준수하며 ViewModel을 모의(mock)할 수 있고 테스트할 수 있도록 합니다.\n\n```js\nimport Foundation\n\nprotocol ProductListViewModelProtocol: ObservableObject {\n    var products: [ProductListItemViewModel] { get set }\n    var isError: Bool { get }\n    var error: String { get }\n    var isEmpty: Bool { get }\n    var title: String { get }\n    func shouldShowLoader() -> Bool\n    func fetchProducts() async\n}\n\nfinal class ProductListViewModel: ProductListViewModelProtocol {\n\n    @Published var products: [ProductListItemViewModel] = []\n    @Published var isError: Bool = false\n    @Published var error: String = \"\"\n    var isEmpty: Bool { return products.isEmpty }\n    var title: String = AppConstant.productListTitle\n    private let productListUseCase: ProductListUseCase!\n\n    init(useCase: ProductListUseCase) {\n        self.productListUseCase = useCase\n    }\n\n    /// This method fetches products and catches error if any\n    @MainActor func fetchProducts() async {\n        do {\n            let productList = try await productListUseCase.fetchProductList()\n            self.products = self.transformFetchedProducts(products: productList)\n            self.isError = false\n        } catch {\n            self.isError = true\n            if let networkError = error as? NetworkError {\n                self.error = networkError.description\n            } else {\n                self.error = error.localizedDescription\n            }\n        }\n    }\n\n    /// This method maps Product to ProductListItemViewModel\n    /// - Parameter products: array of Product\n    /// - Returns: array of ProductListItemViewModel\n    private func transformFetchedProducts(products: [ProductDomainListDTO]) -> [ProductListItemViewModel] {\n        products.map { ProductListItemViewModel(id: $0.productId,\n                                           title: $0.title,\n                                           description: $0.description,\n                                                price: $0.price.getAmountWithCurrency(),\n                                                category: $0.category.capitalized,\n                                           image: $0.thumbnail) }\n    }\n\n    /// This method checks if the loader should be shown or not\n    /// - Returns: True if there the product array is empty and error is not there\n    func shouldShowLoader() -> Bool {\n        return (isEmpty && !isError)\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nProductListViewModel은 제품 배열, 오류 및 기타 정보를 저장하기 위해 ObservableObject 프로토콜을 준수합니다. ProductListViewModel 내부의 속성에는 뷰에서 액세스되기 때문에 뷰가 업데이트되는 @Published 속성 래퍼가 추가되었습니다. 따라서 @Published 속성 (제품, isError 등) 중 하나가 변경되면 뷰가 업데이트됩니다.\n\nfetchProducts 함수에 @MainActor 속성이 사용되면 해당 작업이 주 스레드에서 실행됨을 보장합니다. fetchProducts 함수 내부에서 @Published 속성이 업데이트되는 것을 볼 수 있습니다. 이러한 속성이 뷰에서 사용되고 이러한 속성이 변경될 때 뷰가 업데이트된다는 것을 알고 있습니다. 뷰(UI)가 주 스레드에서 업데이트되기를 원합니다.\n\n## MVVM\n\nMVVM(Mode-View-ViewModel)은 ViewModel이 뷰와 모델 사이에서 중재자 역할을 하는 디자인 패턴입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![image](/assets/img/2024-06-19-TheCleanArchitecturewithMVVMintheiOSSwiftUIProject_4.png)\n\n뷰모델은 UI 프레임워크를 가져오지 않기 때문에 재사용 가능하고 테스트할 수 있습니다. 하나의 뷰모델에 대해 서로 다른 뷰 구현을 사용할 수 있습니다. 예를 들어, 같은 뷰모델에 대해 UIKit 또는 SwiftUI 뷰를 사용할 수 있습니다.\n\n위에서 논의한 대로 데이터 바인딩에는 ObservableObject 프로토콜을 사용했지만 다른 데이터 바인딩 방법도 사용할 수 있습니다. 예를 들어 델리게이트, 클로저, 알림, 구독자/발행자 등이 있습니다.\n\n저희 프로젝트에서 MVVM은 UI와 프리젠터 간의 관심을 분리하는 데 사용되었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 도메인 레이어\n\n도메인 레이어 = 유스 케이스 + 엔티티 + 리포지토리 인터페이스\n\n도메인 레이어는 ProductListUseCase, ProductDomainListDTO(엔티티) + ProductListRepository 프로토콜로 이루어져 있어요.\n\n특정 모듈의 요구 사항에 따라 여러 개의 유스 케이스가 있을 수 있고, 하나의 유스 케이스가 다른 유스 케이스에 의존할 수 있어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 계층은 Use Case에 쓰인 응용 프로그램 비즈니스 규칙 때문에 가장 중요한 계층입니다. 우리는 Use Case를 보기만 해도 응용 프로그램이 무엇을 하는지 이해할 수 있습니다. 이것을 Screaming Architecture라고 합니다.\n\nProductListUseCase\n\nProductListUseCase는 fetchProductList 함수를 포함하는 ProductListUseCase 프로토콜을 준수합니다. 이는 저장소에 접근하고 저장소로부터 제품 목록 데이터를 불러옵니다.\n\n```js\nimport Foundation\n\nprotocol ProductListUseCase {\n    func fetchProductList() async throws -> [ProductDomainListDTO]\n}\n\nfinal class DefaultProductListUseCase: ProductListUseCase {\n\n    private let repository: ProductListRepository\n\n    init(repository: ProductListRepository) {\n        self.repository = repository\n    }\n\n    func fetchProductList() async throws -> [ProductDomainListDTO] {\n        try await repository.fetchProductList()\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nProductListRepositoryProtocol\n\n도메인 레이어에는 ProductListRepositoryProtocol이 포함되어 있고 ProductListUseCase는 직접 repository 대신 ProductListRepositoryProtocol에 종속되어 있습니다. 따라서 의존성 방향이 역전되었습니다. 위의 의존성 방향 및 데이터 흐름 섹션에서 이미 자세히 논의한 바 있습니다.\n\n```js\nprotocol ProductListRepository {\n    func fetchProductList() async throws -> [ProductDomainListDTO]\n}\n```\n\n참고: ProductListRepositoryProtocol은 의존성 역전에 사용됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nProductDomainListDTO\n\nProductDomainListDTO는 도메인 데이터 전송 객체(DTO)로, 중간 객체로 작동하고 개체를 프레젠테이션 레이어에서 사용할 모델로 변환하는 역할을 담당합니다.\n\n```js\nimport Foundation\n\nstruct ProductDomainListDTO {\n    let productId: Int\n    let title: String\n    let description: String\n    let price: Double\n    var category: String\n    let thumbnail: String\n}\n```\n\n## 데이터 레이어\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n데이터 레이어 = 리포지토리 구현 + 서비스 / 데이터 저장소\n\n데이터 레이어는 DefaultProductListRepository(리포지토리 구현)와 ProductListService로 구성되어 있습니다.\n\nDefaultProductListRepository\n\nDefaultProductListRepository는 ProductListService에 액세스하고 서비스로부터 제품 데이터를 가져와 도메인으로 데이터를 반환하는 fetchProductList 함수를 갖고 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```swift\nimport Foundation\n\nfinal class DefaultProductListRepository: ProductListRepository {\n\n    private let service: ProductListService\n\n    init(service: ProductListService) {\n        self.service = service\n    }\n\n    func fetchProductList() async throws -> [ProductDomainListDTO] {\n        try await service.fetchProductListFromNetwork().products.map { $0.toDomain() }\n    }\n}\n```\n\n참고: 앱이 오프라인 지원을 하는 경우 ProductListRepository에 영속 데이터 저장소 (예: CoreData)가 주입됩니다. 먼저 리포지토리는 캐시된 데이터가 있는지 영구 저장소에서 확인하고, 캐시된 데이터를 도메인 모델로 매핑하여 데이터가 있으면 도메인에 반환합니다. 그런 다음 서비스에게 네트워크에서 데이터를 가져 오도록 요청합니다. 데이터를 가져온 후 리포지토리는 새 데이터로 영구 저장소를 업데이트하고, 도메인 모델로 매핑하여 도메인 계층에 데이터를 반환합니다.\n\nProductListService\n\nProductListService는 네트워크에서 제품 데이터를 가져 오는 fetchProductListFromNetwork 함수 내에서 사용되는 apiDataService에 액세스 권한이 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nimport Foundation\n\nprotocol ProductListService {\n    func fetchProductListFromNetwork() async throws -> ProductPageDataListDTO\n}\n\nfinal class DefaultProductListService: ProductListService {\n\n    private let apiDataService: DataTransferService\n\n    init(apiDataService: DataTransferService) {\n        self.apiDataService = apiDataService\n    }\n\n    func fetchProductListFromNetwork() async throws -> ProductPageDataListDTO {\n        let productListNetworkRequest = DefaultNetworkRequest(path: APIEndpoint.products,method: .get)\n        return try await apiDataService.request(request: productListNetworkRequest)\n    }\n}\n```\n\n## 네트워크\n\n여기서 URLSession을 사용하여 실제 API 호출이 발생합니다. 먼저 EndPoint와 HTTPMethod를 제공하여 첫 번째 네트워크 요청을 생성합니다. 그런 다음 URL 요청이 생성됩니다. URL 요청을 사용하여 데이터를 가져옵니다. 에러가 발생하면 에러를 처리합니다. 또한 Decodable을 사용하여 데이터를 매핑합니다.\n\n```js\nimport Foundation\n\nprotocol DataTransferService {\n    func request<T: Decodable>(request: NetworkRequest) async throws -> T\n}\n\nfinal class DefaultDataTransferService: DataTransferService {\n\n    private let networkManager: NetworkManager\n    init(networkManager: NetworkManager) {\n        self.networkManager = networkManager\n    }\n\n    /// 네트워크 매니저에서 데이터를 가져와 decode 메서드를 사용하여 데이터를 디코딩하는 메서드입니다.\n    /// - Parameter request: 네트워크 요청\n    /// - Returns: Decodable 유형의 객체\n    func request<T>(request: NetworkRequest) async throws -> T where T : Decodable {\n        let data = try await networkManager.fetch(request: request)\n        return try decode(data: data)\n    }\n\n    /// JSONDecoder를 사용하여 데이터를 디코딩하는 메서드입니다.\n    /// - Parameter data: 데이터\n    /// - Returns: Decodable 유형의 객체\n    func decode<T>(data: Data) throws -> T where T : Decodable {\n        do {\n            let decodedData = try JSONDecoder().decode(T.self, from: data)\n            return decodedData\n        } catch {\n            throw NetworkError.unableToDecode\n        }\n    }\n}\n\nimport Foundation\n\nprotocol NetworkSessionManager {\n    func request(with config: NetworkConfigurable, request: NetworkRequest) async throws -> (Data?, URLResponse?)\n}\nprotocol NetworkManager {\n    func fetch(request: NetworkRequest) async throws -> Data\n}\n\nfinal class DefaultNetworkManager: NetworkManager {\n\n    private let config: NetworkConfigurable\n    private let sessionManager: NetworkSessionManager\n\n    init(config: NetworkConfigurable,\n        sessionManager: NetworkSessionManager = DefaultNetworkSessionManager()) {\n        self.config = config\n        self.sessionManager = sessionManager\n    }\n\n    /// 세션 매니저에서 데이터를 가져오고 데이터 및 응답을 유효성 검사하는 메서드입니다.\n    /// - Parameter request: 네트워크 요청\n    /// - Returns: 데이터\n    func fetch(request: NetworkRequest) async throws -> Data {\n        let (data, response) = try await sessionManager.request(with: config, request: request)\n        guard let response = response as? HTTPURLResponse else { throw NetworkError.noResponse }\n        if response.statusCode != 200 { throw NetworkError.failed }\n        guard let data = data else { throw NetworkError.noData }\n        return data\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n노트: 네트워크 관련된 더 많은 코드는 예시 프로젝트의 네트워킹 폴더에 있습니다.\n\n# 의존성 주입 (DI)\n\n의존성 주입은 객체가 자체적으로 만들지 않고 필요로 하는 다른 객체들을 받는 프로그래밍 기법입니다.\n\n우리의 예시 프로젝트에서는 AppDIContainer라는 클래스를 만들었는데, 이 클래스에는 apiDataTransferService가 포함되어 있습니다. 이 apiDataTransferService 객체는 Product 모듈을 생성하는 데 필요합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```swift\nimport Foundation\n\nfinal class AppDIContainer {\n\n    lazy private var apiDataTransferService: DataTransferService = {\n        let config = ApiDataNetworkConfig(baseURL: AppConfiguration.baseURL)\n        let sessionManager = DefaultNetworkSessionManager(session: SharedURLSession.shared)\n        let networkManager = DefaultNetworkManager(config: config, sessionManager: sessionManager)\n        return DefaultDataTransferService(networkManager: networkManager)\n    }()\n\n    lazy var productListView: ProductListView = {\n        let productsModule = ProductsModule(apiDataTransferService: apiDataTransferService)\n        return productsModule.generateProductListView()\n    }()\n}\n```\n\n참고: 우리는 의존성 주입으로 apiDataTransferService를 Product Module에 전달하고 있습니다.\n\n# 결론\n\n클린 아키텍처는 매우 확장 가능하고 테스트 가능하며 유지보수 가능한 소프트웨어를 구축하는 데 도움을 줍니다. 각 계층이 특정 역할을 가지고 다른 부분과 격리되도록 응용 프로그램을 여러 계층으로 분리하여 관련성을 제공합니다. 이는 재사용성의 가능성을 높이고 비즈니스 요구 사항 및 경쟁 시장의 변화에 대응할 수 있도록 보장합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n읽어 주셔서 감사합니다. 연락 기다리겠습니다!\n\n좋은 코딩하세요 :)\n\n![image](https://miro.medium.com/v2/resize:fit:200/1*bdto5WbUfHzG7AuZXY3aGA.gif)\n\n링크드인에서 연결해요.\n","ogImage":{"url":"/assets/img/2024-06-19-TheCleanArchitecturewithMVVMintheiOSSwiftUIProject_0.png"},"coverImage":"/assets/img/2024-06-19-TheCleanArchitecturewithMVVMintheiOSSwiftUIProject_0.png","tag":["Tech"],"readingTime":22},{"title":"Swift 테스팅 프레임워크 소개","description":"","date":"2024-06-19 13:59","slug":"2024-06-19-IntroductiontoSwiftTestingFramework","content":"\n## Swift 개발 혁신: WWDC 2024에서 공개된 테스팅 도구\n\n![이미지](/assets/img/2024-06-19-IntroductiontoSwiftTestingFramework_0.png)\n\n2024년 WWDC에서 가장 흥미로운 도구 중 하나는 Swift Testing으로, Swift 코드의 테스트를 이전보다 강력하게 만듭니다. 이를 통해 개발자들은 최소한의 코드로 높은 품질의 제품을 자신 있게 제공할 수 있습니다.\n\nSwift Testing에는 동시성을 지원하는 기능, 병렬 테스트 실행, 그리고 테스트 매크로 도입과 같은 혁신적인 기능이 포함되어 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 목차\n\n- 전제 조건\n- Swift 테스트 대상 추가 방법\n- 구성 요소\n- 매개변수화된 테스트\n- XCTest와 Swift Test 비교\n- XCTest에서의 이주 팁\n- 결론\n\n# 전제 조건\n\n# Swift 테스트 대상 추가 방법?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nSwift 테스팅을 시작하려면 새 프로젝트를 생성할 때 XCTest UI 테스트와 함께 Swift Testing을 선택해야 합니다.\n\n![이미지](/assets/img/2024-06-19-IntroductiontoSwiftTestingFramework_1.png)\n\n이제 해당 테스트 대상에 테스트 케이스를 작성할 수 있습니다.\n\n# 구성 요소\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n테스트가 가독성 있게 작성되어 있는지 확인하는 것이 중요합니다, 특히 코드베이스가 복잡해지는 경우 더욱 그렇습니다. Swift Testing은 이를 돕기 위해 몇 가지 기능을 추가했으므로 표현력 있는 테스트를 작성하는 것이 더 쉬울 것입니다.\n\n총 4개의 구성 요소가 있습니다. 각각에 대한 자세한 정보를 아래에서 찾을 수 있습니다.\n\n1. 테스트 함수\n\n- 전역 함수 또는 클래스 메소드일 수 있습니다.\n- async 또는 throws로 표시할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/assets/img/2024-06-19-IntroductiontoSwiftTestingFramework_2.png)\n\n2. 기대값\n\n- #expect 매크로:\n\n![이미지](/assets/img/2024-06-19-IntroductiontoSwiftTestingFramework_3.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만약 실패가 발생하면, 실패에 대한 자세한 정보가 표시되어 어디서 잘못된 것인지 이해할 수 있습니다.\n\n![image](/assets/img/2024-06-19-IntroductiontoSwiftTestingFramework_4.png)\n\n- `#expect(.throws: (any Error).self)` 매크로:\n\n만약 이 블록에서 어떤 오류도 throw하지 않는다면 실패합니다. 그렇지 않으면 성공합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래의 테스트 케이스를 확인해보세요:\n\n![test image](/assets/img/2024-06-19-IntroductiontoSwiftTestingFramework_5.png)\n\n위의 예에서, 오류를 던지는 함수는 테스트를 성공적으로 통과했지만, 오류를 던지지 않는 함수는 테스트에 통과하지 못했습니다.\n\n- #require 매크로:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n해당 테이블 태그를 마크다운 형식으로 변경해주세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-06-19-IntroductiontoSwiftTestingFramework_7.png\" />\n\n4. 테스트 스위트\n\n설정 및 정리 로직은 각각 init()와 deinit()을 사용하여 구현됩니다. init()은 테스트 실행 전에 호출되고, deinit()은 테스트 실행 후에 호출됩니다.\n\n각 테스트 함수는 독립적으로 자체 인스턴스에서 실행되므로 실수로 데이터를 공유하지 않습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여기서 특정 테스트 이름을 가진 테스트 네비게이터에 두 개의 스위트를 볼 수 있습니다. 부 스위트는 부모 스위트 아래에 계층적으로 표시됩니다.\n\n![Test Navigator](/assets/img/2024-06-19-IntroductiontoSwiftTestingFramework_8.png)\n\n# 매개변수화 테스트\n\n매개변수화 테스트는 중복 코드나 과도한 개별 테스트 케이스 생성 없이 철저한 테스트 커버리지를 보장하는 데 도움이 됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n매개변수화된 테스트를 실습해 봅시다.\n\n![이미지](/assets/img/2024-06-19-IntroductiontoSwiftTestingFramework_9.png)\n\n위는 Swift 테스트에서 매개변수화된 테스트의 잘못된 구문을 나타냅니다. @Test 어노테이션에서 인수를 사용해야 합니다.\n\n위 예시에서 세 가지 인수가 제공되었습니다. 두 가지는 올바르고 하나는 잘못되었지만, 전체 테스트 케이스는 실패로 표시될 것입니다. 그러나 테스트 탐색기에서 실패의 원인이 된 인수를 볼 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-06-19-IntroductiontoSwiftTestingFramework_10.png\" />\n\n# XCTest와 Swift Test 비교\n\nSwift Tests와 XCTest의 구성 요소 비교:\n\n1. 테스트 함수\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/assets/img/2024-06-19-IntroductiontoSwiftTestingFramework_11.png)\n\n2. 기대\n\n두 프레임워크의 기대는 매우 다릅니다.\n\n![이미지](/assets/img/2024-06-19-IntroductiontoSwiftTestingFramework_12.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n테스트가 실패하면 테스트가 중지되는 방식도 두 프레임워크에서 차이가 있습니다.\n\n3. 테스트 스위트\n\n![이미지](/assets/img/2024-06-19-IntroductiontoSwiftTestingFramework_13.png)\n\n## XCTest에서의 이주를 위한 팁\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- XCTest와 Swift Test는 단일 타겟으로 작성할 수 있습니다. 새로운 타겟을 만드는 것은 필수적이지 않습니다.\n- 여러 메소드가 유사한 구조를 가질 때는 하나의 테스트로 결합하고 해당 함수를 매개변수화할 수 있습니다.\n- 개별 XCTest 클래스를 하나의 전역 @Test 함수로 결합합니다.\n- Swift 테스트에서는 함수 이름에 테스트 접두사를 더 이상 사용할 필요가 없습니다. 함수에서 제거할 수 있습니다.\n- Swift 테스팅에서는 XCTAssertion을 사용하지 않고, XCTest에 있는 #expect나 #require와 같은 테스팅 매크로를 피해야 합니다.\n\n# 결론\n\nSwift Testing은 매크로와 함께 표현력 높은 API를 제공하여 코드를 최소로 사용하여 테스트 동작을 선언할 수 있습니다. #expect API는 제공된 표현식을 유효성 검사하는 데 Swift 표현식과 연산자를 사용합니다. 매개변수화된 테스트는 유사한 구조의 코드를 수용하여 중복 코드를 줄이는 데 도움이 됩니다. 또한 Swift Testing은 병렬 테스트를 지원하여 전체 테스트 효율성과 생산성을 향상시킵니다. 그러나 직렬화된 테스트를 활성화하려면 직렬화된 특성을 사용해야 합니다.\n","ogImage":{"url":"/assets/img/2024-06-19-IntroductiontoSwiftTestingFramework_0.png"},"coverImage":"/assets/img/2024-06-19-IntroductiontoSwiftTestingFramework_0.png","tag":["Tech"],"readingTime":8},{"title":"Android 개발에서 향상된 디버깅 품질","description":"","date":"2024-06-19 13:56","slug":"2024-06-19-BetterDebuggingQualityinAndroidDevelopment","content":"\n![Better Debugging Quality in Android Development](/assets/img/2024-06-19-BetterDebuggingQualityinAndroidDevelopment_0.png)\n\n개발 중에는 때때로, 이 검사 또는 등록 양식을 한 번 더 다시 쓰지 않으면 안 되는 상황이 발생합니다. 와락그러면서도 작은 버그를 찾기 위해 그 순응하지 않는 작은 고집스러운 버그를 발견하게 됩니다. 바로 이 점 때문에 우리에게 현저한 피해를 줄 수 있다는 것을 잊지 마세요. 그러므로 더 이상 그만 하기로 해야 합니다.\n\n이 기사에서는 개발자로서 우리에게 매우 보편적인 보스 같은 여정을 겪어볼 것입니다. 지금 우리는 왼쪽, 오른쪽, 여기저기에 명령을 내리는 것을 좋아하는 우리 개발자들에게 익숙한 이야기죠 😀.\n\n오늘 하루, 우리는 테스트 디바이스나 에뮬레이터를 제어하는 것뿐만 아니라 그 양식을 여러 번 작성하는 본능적 욕구도 제어할 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n당신은 개발자로서. 위의 텍스트를 친근한 어조로 한국어로 번역해주세요.\n\n\"어떤가요??\"라고 물을 수 있어요. 우리는 adbcommands를 사용할 거에요. ADB(Android Debug Bridge)라는 것은 안드로이드 장치나 에뮬레이터를 제어하기 위한 명령줄 도구에요. \"안드로이드 디버그...\" \"커마...\"만 듣고 어딘가로 가지 마세요. 약간 지루해 보일 수도 있지만, 제가 가능한 한 재미있게 만들어 드릴게요.\n\n사실 마지막에는 이 명령을 한 번, 두 번, 세 번 정도만 사용할 거에요... 우리가 선택한 바로 가기로 이 명령들을 사용할 필요가 없게 할 거에요. (또는 경우에 따라 윈도우를 사용한다면 일명 하나의 명령만 남겨두게 할 거에요. 🙂).\n\n# 사용자 정의 가능한 입력 플로우 스크립트 생성\n\n우선, 장치/에뮬레이터와 상호작용할 명령어들이 여기 있어요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n# 호스트 안드로이드 장치의 터미널에서 명령을 열거나 실행합니다.\nadb shell\n\n# 현재 활성화된 TextField에 지정된 문자열을 입력합니다.\nadb shell input text \"Hello World!\"\n\n# 장치 화면의 지정된 좌표를 탭합니다.\nadb shell input tap 700 1500\n```\n\n지금 당신은 아마 \"정적 좌표를 사용하여 텍스트 필드를 찾을까?\"라고 생각할 수 있습니다. 전혀, 그렇지 않습니다. 하지만 당신이 자신을 어렵게 만들고 싶다면 사용할 수 있습니다 :D. 화면에 기대되는 UI 요소의 좌표를 찾을 때, 우리는 uiautomator의 덤프를 사용할 것입니다. 이를 다운로드하려면 Python3가 필요합니다.\n\n```js\nadb exec-out uiautomator dump /dev/tty\n```\n\n이 명령어가 마법이 시작되는 곳입니다. UI Automator는 XML 형식의 현재 화면 보기 계층에 대한 덤프를 생성합니다. 이 명령을 입력하면 이 파일이 터미널에 표시될 것입니다. 그리고 우리가 관심 있는 부분은 실제로 이 파일의 각 요소의 [bounds] 태그이며, 다음은 그 노드 중 하나의 서식이 적용된 버전입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-06-19-BetterDebuggingQualityinAndroidDevelopment_1.png\" />\n\n그렇게 말하니까 아마 이해가 가실 거에요. 우리는 각 요소의 경계를 가져오기 위한 파서를 만들어야 합니다. 물론 원하는 때마다 관련 요소에 접근 하는 방법은 그들의 이름을 호출하는 것입니다 :). 아래 스크립트에서 우리는 효과적으로 해당 목표를 달성하기 위해 터미널 명령을 사용합니다.\n\n```js\n# UI 요소를 탭하는 함수 (요소가 존재하는 경우)\nfunction tapIfExists() {\n    # UI 요소의 좌표 가져오기\n    coords=$(getCoords \"${1}\")\n\n    # 좌표가 찾아졌는지 확인\n    if [[ \"$coords\" != \"-\" ]]; then\n        # adb를 사용하여 좌표 탭하기\n        adb shell input tap \"$coords\"\n    fi\n}\n\n# 텍스트를 기반으로 UI 요소의 좌표를 가져오는 함수\nfunction getCoords() {\n    # UI 계층 구조를 덤프하고 변수에 저장\n    fastdump=$(/usr/bin/python3 -c \"import uiautomator2 as u2;d=u2.connect(); out=d.dump_hierarchy(); print(out)\")\n\n    # 지정된 텍스트가 있는 요소가 있는지 확인\n    present=$(echo \"$fastdump\" | grep \"text=\\\"${1}\\\"\")\n\n    # 요소를 찾은 경우\n    if [[ $? -eq 0 ]]; then\n        # 덤프에서 좌표 추출\n        arr=($(echo \"$fastdump\" | sed 's/></>\\n</g' | grep \"text=\\\"${1}\\\"\" | grep -o \"\\[.*\\]\" | sed 's/\\]\\[/,/g' | sed 's/\\]//g;s/\\[//g;s/,/\\n/g'))\n\n        # 중앙 x좌표 계산\n        x=$(echo \"(${arr[0]}+${arr[2]})/2\" | bc)\n\n        # 중앙 y좌표 계산\n        y=$(echo \"(${arr[1]}+${arr[3]})/2\" | bc)\n\n        # 좌표 출력\n        echo \"$x $y\"\n    else\n        # 요소를 찾지 못한 경우 \"-\" 출력\n        echo \"-\"\n    fi\n}\n```\n\n이렇게 하면 모든 것이 훨씬 더 쉬워집니다. 예를 들어 로그인 플로우를 만들었습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```javascript\n# ...\n# 파일 끝에 사용자 정의 로직을 추가하는 중...\n\ntapIfExists \"E-mail\"\nadb shell input text \"sevbanbuyer@gmail.com\"\ntapIfExists \"Password\"\nadb shell input text \"asdasdfasd\"\ntapIfExists \"SIGN IN\"\n```\n\n이 스크립트로 우리는 등록 과정을 단 한 개의 명령으로 줄였어요: ./`your-script-file-name` 하지만 아직 끝나지 않았습니다. 만약 Mac을 사용하고 계시다면 입력 과정에 대한 단축키를 만들 수 있어요. 이를 위해 먼저 Mac의 Automator 앱으로 Applescript 워크플로우를 만들어야 해요.\n\n<img src=\"/assets/img/2024-06-19-BetterDebuggingQualityinAndroidDevelopment_2.png\" />\n\n<img src=\"/assets/img/2024-06-19-BetterDebuggingQualityinAndroidDevelopment_3.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n# Automator의 applescript에 다음을 넣으세요\non run {input, parameters}\n do shell script \"<path-to-your-script>\"\nend run\n```\n\n```js\n#!/bin/bash\n\nADB_PATH=\"<adb의 전체 경로>\" # 주의 !\n\nfunction tapIfExists(){\n    coords=$(getCoords \"${1}\")\n    if [[ \"$coords\" != \"-\" ]]; then\n        $ADB_PATH shell input tap \"$coords\" # 주의 !\n    fi\n}\n\nfunction getCoords(){\n    fastdump=$(/usr/bin/python3 -c \"import uiautomator2 as u2;d=u2.connect(); out=d.dump_hierarchy(); print(out)\")\n    present=$(echo \"$fastdump\" | grep \"text\\=\\\"${1}\\\"\")\n    if [[ $? -eq 0 ]]; then\n        arr=($(echo \"$fastdump\" | sed 's/></>\\n</g' | grep \"text\\=\\\"${1}\\\"\" | grep -o \"\\[.*\\]\" | sed 's/\\]\\[/,/g' | sed 's/\\]//g;s/\\[//g;s/,/\\n/g'))\n        x=$(echo \"(${arr[0]}+${arr[2]})/2\" | bc)\n        y=$(echo \"(${arr[1]}+${arr[3]})/2\" | bc)\n        echo \"$x $y\"\n    else\n        echo \"-\"\n    fi\n}\n\ntapIfExists \"이메일\"\n$ADB_PATH shell input text \"sevbanbuyer@gmail.com\" # 주의 !\ntapIfExists \"암호\"\n$ADB_PATH input text \"asdasdfasd\"  # 주의 !\ntapIfExists \"로그인\"\n```\n\nApplescript에 완전한 경로가 포함된 스크립트를 제공하면, Settings에서 `Keyboard` Keyboard Shortcuts `Services` General로 이동하고 그 섹션에 스크립트가 표시됩니다. 이제 원하는 단축키를 할당할 수 있습니다.\n\n<img src=\"/assets/img/2024-06-19-BetterDebuggingQualityinAndroidDevelopment_4.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여기 출력물이 있어요:\n\n![Dumpsys](https://miro.medium.com/v2/resize:fit:784/1*OA1yF70mPJNjQ78lzlFoDg.gif)\n\n# Dumpsys\n\ndumpsys 명령어는 장치에서 실행 중인 모든 시스템 서비스에 대한 진단 정보를 제공합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 표를 다음과 같이 변경해 주세요:\n\n| 주제               | 설명                                      |\n| ------------------ | ----------------------------------------- |\n| 활동 및 프래그먼트 | - 활동 및 프래그먼트에 대한 정보          |\n| 배터리             | - 배터리 상태 및 관리에 관한 정보         |\n| 알람               | - 알람 설정 및 관리에 관한 정보           |\n| 패키지 정보        | - 앱 패키지 정보에 대한 정보              |\n| 작업 스케줄러      | - 작업 스케줄러 사용법과 정보에 대한 정보 |\n\n이 서비스들과 상호작용하면서 코드를 통해 어떤 일이 벌어지는지를 알아내므로 버그에 대한 효율적인 추측이 가능합니다.\n\n\"AlarmManager를 사용하여 알람을 설정했는데, 정말 설정되었을까요?\"\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\"조각을 확장했지만 아무것도 보이지 않아요. 제가 제대로 한 걸까요?\"\n\n- 리뷰 중인 앱을 분석하고 실제로 무엇을 보고 있는지 확인하기 위해 dumpsysis를 사용하는 것이 좋습니다.\n\n다음은 명령어입니다:\n\n```js\nadb shell dumpsys <service>\n\nadb shell dumpsys battery\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/assets/img/2024-06-19-BetterDebuggingQualityinAndroidDevelopment_5.png)\n\n덤프시스에서 grep을 사용하여 검색할 수 있습니다. 예를 들어:\n\n```js\nadb shell dumpsys | grep \"ACTIVITY\"\n\nadb shell dumpsys | grep \"BottomNavigationItemView\"\n```\n\n# 로컬 파일의 내용 보기/변경\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n로컬 스토리지를 다룰 때 종종 어려움을 겪곤 합니다.\n\n- 스토리지 데이터를 쿼리하기 위해 중단점을 설정하거나\n- printlines 또는 로그를 추가하는 것은 수정 및 빌드가 필요하여 시간이 많이 소요됩니다.\n\n우리는 이 디버깅 프로세스를 최적화할 수 있는 기회가 있습니다.\n\n- 앱의 내부 데이터는 data/path에 저장됩니다.\n- 이론적으로 우리는 cd, ls, echo, nano 등의 일반 터미널 명령어를 사용하여 기기에서 이 데이터를 볼 수 있지만 실제로는 이와 같은 문제가 발생합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Image](/assets/img/2024-06-19-BetterDebuggingQualityinAndroidDevelopment_6.png)\n\n안드로이드는 앱의 리소스에 쉽게 액세스할 수 없도록 허용하지 않는다는 점이 좋은 것 같아요.\n\n그런데 앱의 내부 데이터의 정확한 경로는 다음과 같아요: /data/user/0/`your.package.name` 그래도 저 정확한 경로를 알아도 들어가지 못하는 걸 보면 다른 방법이 필요할 걸요.\n\n이를 위해 안드로이드의 각 앱이 사실 별칭으로 패키지 이름을 가진 사용자라는 사실을 활용할 거에요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Screenshot 1](/assets/img/2024-06-19-BetterDebuggingQualityinAndroidDevelopment_7.png)\n\n우리는 run-as 명령어를 사용하여 앱이 셀프인 것처럼 속이는 데 사용했습니다. 이제 우리는 앱의 내부 저장소를 lsin 할 수 있고, sharedPref, 데이터베이스 또는 파일과 같은 데이터를 볼 수 있습니다. 이 데이터들은 코드베이스 내에서 파일 API를 사용하여 생성된 것입니다.\n\n![Screenshot 2](/assets/img/2024-06-19-BetterDebuggingQualityinAndroidDevelopment_8.png)\n\n그리고 BUM! 여기가 제 앱의 공유 프리퍼런스 파일이고, onboarding_key와 해당 값을 볼 수 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\\<img src=\"/assets/img/2024-06-19-BetterDebuggingQualityinAndroidDevelopment_9.png\" />\n\n이제 이 선호 값을 어떻게 편집할 수 있어서 앱을 다시 빌드하지 않고 변경 사항을 확실히 적용하는 데 시간을 낭비하지 않을 수 있는지 묻게 될 것입니다. 일반적으로 터미널에서 사용하는 텍스트 편집기를 adb 쉘에서 사용할 수는 없지만 여기에 대한 해결책이 있습니다: sedcommand. -iflag로 파일을 직접 덮어쓸 수 있으므로 여기 제 앱의 온보딩 키에 대한 적용입니다:\n\n```js\nemu64a:/data/user/0/com.sevban.tradejournal/shared_prefs $ grep \"onboarding_key\" presentation.MainActivity.xml\n    <boolean name=\"onboarding_key\" value=\"true\" />\nemu64a:/data/user/0/com.sevban.tradejournal/shared_prefs $\n\ncat presentation.MainActivity.xml |\ngrep \"onboarding_key\" |\nsed -i \"s/true/false/g\" presentation.MainActivity.xml\n\nemu64a:/data/user/0/com.sevban.tradejournal/shared_prefs $ grep \"onboarding_key\" presentation.MainActivity.xml\n    <boolean name=\"onboarding_key\" value=\"false\" />\n```\n\n# 결론\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n안드로이드 개발에서 디버깅 프로세스를 개선하는 과정은 어렵지 않을 수 있어요. ADB 및 uiautomator와 같은 도구를 활용하여 양식 작성과 같은 반복적인 작업을 자동화하고 앱의 동작에 대한 깊은 통찰력을 얻을 수 있어요.\n\n사용자 정의 입력 흐름 스크립트를 생성하면 UI 상호작용을 자동화하여 디버깅을 더 효율적이고 단조로운 일이 줄어들어요. dumpsys를 사용하고 run-as 및 sed 명령어를 사용하여 로컬 파일에 액세스하면 문제를 진단하고 효과적으로 해결할 수 있어요.\n\n이러한 기술을 활용하면 디버깅 프로세스를 변화시킬 수 있어요. 가능한 경우 자동화 도구를 적극적으로 활용하고 더욱 원활하고 생산적인 개발 경험을 누려보세요.\n\n참고 문헌:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nhttps://www.youtube.com/watch?v=DcU1czPxQ10&t=1326s\n","ogImage":{"url":"/assets/img/2024-06-19-BetterDebuggingQualityinAndroidDevelopment_0.png"},"coverImage":"/assets/img/2024-06-19-BetterDebuggingQualityinAndroidDevelopment_0.png","tag":["Tech"],"readingTime":13},{"title":"안녕하세요 오늘은 안드로이드용 5가지 최고의 무료 음악 플레이어 앱에 대해 이야기해 보려고 해요 함께 즐겁게 앱을 살펴보시죠","description":"","date":"2024-06-19 13:54","slug":"2024-06-19-5BestFreeMusicPlayerAppsforAndroid","content":"\n이 기사는 완전히 무료로 사용할 수 있고 광고가 없으며 유용한 기능이 제공되는 최고의 5가지 오프라인 음악 플레이어 앱을 소개합니다.\n\n![이미지](/assets/img/2024-06-19-5BestFreeMusicPlayerAppsforAndroid_0.png)\n\n본 기사에서는 Google Play Store에서 사용할 수 있는 안드로이드 기기용 최고의 5가지 무료 오프라인 음악 플레이어 앱을 살펴볼 예정입니다. 각 음악 플레이어를 비교하려면 우리는 최고의 음악 플레이어를 찾는 데 도움이 되는 몇 가지 주요 요소를 고려해야 합니다. 이러한 요소는 다음과 같습니다:\n\n- 좋은 디자인\n- 유용한 기능\n- 기기 호환성\n- 보안\n- 추가 기능\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다가오는 섹션에서는 각 음악 플레이어를 이 주요 요소로 평가할 것입니다.\n\n## #1: Groovy — 음악 플레이어\n\nPlay Store 링크: [여기를 클릭하세요](https://play.google.com/store/apps/details?id=com.bitmavrick.groovy)\n\nGroovy는 현재 최고의 음악 플레이어 앱 중 하나입니다. 단순하고 독특한 UI 디자인 시스템을 갖추고 있어 누구나 쉽게 이해하고 작동할 수 있으며 프로 사용자를 위한 많은 사용자 정의 옵션을 제공합니다. 이 앱은 Material-You를 따르는 디자인으로 동적 테마를 지원하고 아이콘 테마를 지원합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-06-19-5BestFreeMusicPlayerAppsforAndroid_1.png\" />\n\n유용한 기능들을 요청하면, 이 앱은 음악, 앨범, 아티스트 등을 쉽게 찾을 수 있는 트랙 조직 시스템으로 제공됩니다. 강력한 음악 검색 시스템뿐만 아니라 셔플 모드, 음악 재생 리스트 조직 시스템, 음악 정렬, 기기에서 포함하고 싶지 않은 폴더 차단 등 다양한 유용한 기능들도 제공하고 있습니다.\n\n이 앱은 거의 모든 종류의 안드로이드 기기와 호환됩니다. 예를 들어, 스마트폰, 태블릿, 폴더블 기기, 크롬북, 안드로이드 TV 등을 지원합니다. 플레이어는 세로 및 가로 디스플레이 모드를 모두 지원합니다.\n\n보안에 대해 생각해보신다면, 이 앱은 완전히 오픈 소스이며 보안에 대해 매우 투명하게 공개되어 있습니다. 사용자로부터 개인 정보를 수집하지 않습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n마지막으로 추가 기능을 이야기하자면 슬립 타이머, 이퀄라이저, 'Amoled 테마'라고 불리는 한 가지 추가 어두운 테마, 음악 슬라이더 사용자 정의 등 많은 기능이 있습니다.\n\n## #2: 바닐라 음악 플레이어\n\nPlay 스토어 링크: [https://play.google.com/store/search?q=vanilla%20music%20player&c=apps&hl=en&gl=US](https://play.google.com/store/search?q=vanilla%20music%20player&c=apps&hl=en&gl=US)\n\n바닐라 음악 플레이어는 인상적인 아름다운 디자인 미학을 가지고 있습니다. 그러나 지금은 초기 릴리스 상태입니다. 그래서 스크롤할 때 UI가 조금 느려 보일 수 있습니다. 그 외에는 매우 멋진 음악 플레이어 앱입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/assets/img/2024-06-19-5BestFreeMusicPlayerAppsforAndroid_2.png)\n\n이 플레이어의 주요 기능은 매우 멋진 UI 애니메이션이 있고 사용자 지정 재생 목록을 만들거나 음악 파일을 삭제하거나 숨길 수 있으며 음악 파일을 다양한 방식으로 정렬할 수 있다는 것입니다. 이 플레이어는 가사 지원도 하고 있습니다. 음악 파일과 함께 가사가 있는 경우 플레이어 내에서 가사를 볼 수 있습니다.\n\n호환성 부서에서는 아직 알 수 없습니다. 초기 릴리스로 인해 모든 종류의 기기를 지원해야 합니다.\n\nGroovy와는 달리이 앱은 오픈 소스가 아닙니다. 그러나 앱은 사용자의 개인 정보를 수집하지 않습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n추가 기능에 관해 이 응용 프로그램은 사용자가 원하는 UI 색상을 사용자 정의할 수 있는 색상 팔레트를 지원합니다. 정말 멋지죠!\n\n# #3: Poweramp Music Player (체험판)\n\nPlay Store 링크: https://play.google.com/store/apps/details?id=com.maxmpz.audioplayer\n\n절대적인 제어와 사용자 정의를 원한다면, 이 음악 플레이어가 바로 당신을 위한 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Image](/assets/img/2024-06-19-5BestFreeMusicPlayerAppsforAndroid_3.png)\n\nPoweramp Music Player은 음악 플레이어에 모든 것이 필요한 사람들을 위한 최고의 선택입니다. 이 앱의 주요 포커스 포인트는 견고한 이퀄라이저입니다. 10 밴드 음악 이퀄라이저 지원과 수동 베이스, 트레블 컨트롤러도 제공합니다.\n\n이 앱의 위치에 대한 주요 이유는 UI/UX입니다. 앱의 디자인은 다소 구식이며 사용하기 복잡합니다. 주요 제공 요소는 음악 사용자 정의입니다.\n\n보안 면에서는 오픈 소스 애플리케이션이 아닙니다. 그러나 사용자의 개인 정보를 수집하지는 않습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# #4: 간단한 음악 플레이어\n\nPlay Store 링크: [여기를 클릭하여 Play Store에서 확인해보세요](https://play.google.com/store/apps/details?id=com.github.anrimian.musicplayer)\n\n이름에서 알 수 있듯이, 이 음악 플레이어는 정말로 간단합니다. 설치하기만 하고 사용하면 됩니다.\n\n![이미지](/assets/img/2024-06-19-5BestFreeMusicPlayerAppsforAndroid_4.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 음악 플레이어는 추가 기능이 없지만, 단순함을 원하는 사용자에게는 정말 좋습니다. 전문가로서 이 플레이어에 누락된 몇 가지 중요한 기능을 느껴요. 예를 들어, 오디오 파일을 필터링할 수 있는 시스템이 없고, My Call 및 음성 녹음 파일이 음악 파일과 혼합되어 나타나서 저에게는 큰 문제입니다. 전체적인 디자인은 꽤 간단하며 특별한 점도 없지만 불평할 만한 점도 없어요. 일이 잘 되어요.\n\n보안 관련 부분에서 이 앱은 오픈 소스이며 보안에 대해 투명해요. 또한이 앱은 사용자의 개인 정보를 수집하지 않아요.\n\n# #5: Musicmax — 음악 플레이어\n\nPlay Store 링크: https://play.google.com/store/apps/details?id=com.maximillianleonov.musicmax&pcampaignid=web_share\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nMusicmax은 저희가 가장 추천하지 않는 음악 플레이어 앱입니다. 이 플레이어는 전반적으로 꽤 좋은 음악 재생 경험을 제공합니다.\n\n![음악 플레이어 이미지](/assets/img/2024-06-19-5BestFreeMusicPlayerAppsforAndroid_5.png)\n\n이 음악 플레이어는 꽤 양호한 UI 경험을 제공하지만, 가로 모드로 변경할 때 상황이 그리 좋지 않습니다. UI 부서에서 더 많은 작업이 필요합니다. 이 플레이어는 무료 앱으로 가지고 있기 좋은 즐겨찾기 섹션이 있습니다. 또한 다크 모드와 기본적인 기능을 지원합니다.\n\n이 앱은 스마트폰만을 지원합니다. 보안을 위해 오픈 소스로 투명하게 제공됩니다. 이 앱은 사용자의 개인 정보를 수집하지 않습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여기 있습니다. 이것이 제 의견으로는 최고의 5가지 음악 플레이어 앱입니다. 남은 하루도 좋은 하루 되세요!\n","ogImage":{"url":"/assets/img/2024-06-19-5BestFreeMusicPlayerAppsforAndroid_0.png"},"coverImage":"/assets/img/2024-06-19-5BestFreeMusicPlayerAppsforAndroid_0.png","tag":["Tech"],"readingTime":7},{"title":"접근성 강화 포용적 안드로이드 앱으로의 여정","description":"","date":"2024-06-19 13:51","slug":"2024-06-19-AccessibilityAmplifiedAJourneytoInclusiveAndroidApps","content":"\n![이미지](/assets/img/2024-06-19-AccessibilityAmplifiedAJourneytoInclusiveAndroidApps_0.png)\n\n혁신을 추구하는 것은 종종 포용성 요구를 무시하는 경향이 있습니다. 우리의 삶이 디지털 인터페이스와 더불어 점점 더 얽히게 되면, 능력에 관계없이 모든 사람이 디지털 세계에 완전히 접근할 수 있도록 하는 것이 더 중요해지고 있습니다. 특히, 수십억 명의 소비자를 연결하는 전 세계 플랫폼인 안드로이드 생태계에 대해서는 특히 그렇습니다. 이 글에서는 안드로이드의 접근성에 대해 살펴보고, 보다 포용적이고 공정한 기술 환경을 구축하는 데 어떻게 도움이 될 수 있는지 알아보겠습니다.\n\n유럽 접근성법(EAA)은 디지털 접근성의 긴급성을 증대시키는 중요한 요소입니다. 장애를 가진 사람들에게 장애를 제거하도록 제정된 EAA는 유럽 연합 내에서 운영되는 많은 기업들이 2025년까지 자사의 디지털 서비스와 제품을 접근 가능하게 만들도록 요구합니다. 이 규정은 접근성이 단순한 도덕적 필요성뿐만 아니라 법적 요구사항이라는 것을 강조하는 패러다임 변화를 대표합니다. 마감일이 다가오면 기업들은 다양한 고객 요구를 충족시키는 중요성을 인식하면서 자사의 디지털 서비스를 재평가해야 합니다.\n\n이 글은 개발자들이 자신들의 안드로이드 애플리케이션의 접근성을 향상시킬 수 있는 다양한 방법에 대해 자세히 안내합니다. 사용자 친화적인 기능을 포함하고 포용적 설계 원칙을 준수하는 등 어플리케이션을 더 접근 가능하게 만드는 실용적 기술들을 살펴봅니다. 또한, 우리는 테스트의 중요한 요소를 살펴보며 제공된 솔루션이 참으로 포괄적인지 보장하는 방법과 도구에 대해 알아봅니다. 안드로이드 접근성의 복잡한 세계를 탐험하는 과정에서, 개발자들에게 국경을 초월하고 보편적 설계의 정신을 수용하는 디지털 경험을 구축하도록 영감을 줄 수 있기를 희망합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 포용\n\n디지털 접근성 분야에서의 포용은 기술적 요구사항 이상의 의미를 갖습니다. 이는 기술이 배제의 이유가 아닌 평등을 위한 수단으로 작용하기 위한 심도 있는 약속입니다. 접근성 있는 디자인은 사람들의 삶에 광범위한 영향을 미치며, 긍정적이든 부정적이든 모든 능력을 갖춘 사람들에게 영향을 줍니다.\n\n긍정적인 면에서 접근성 있는 기술은 장애로 인해 제약을 받는 사람들을 자유롭게 해 줄 수 있는 변형력을 갖습니다. 시각 장애인이 액세스 가능한 안드로이드 앱을 사용할 때 화면 판독기를 사용한다면 어떨까요. 올바른 접근성 기능이 제대로 설계되어 있다면, 이 사용자는 프로그램을 독립적으로 탐색하고 정보에 접근하며 이전에는 이용할 수 없었던 활동에 참여할 수 있습니다. 이러한 증가된 자유는 그들의 일상을 개선하는 것뿐만 아니라 자아감과 포용감을 육성하는 데에도 도움이 됩니다.\n\n반면에 디지털 접근성 부족은 편견과 문화적 장애를 악화시킬 수 있습니다. 화면 판독기와 호환되지 않거나 그림에 대한 대체 텍스트를 제공하지 않는 웹사이트나 앱은 시각 장애를 가진 사람들을 효과적으로 배제시킬 수 있습니다. 이러한 배제는 단순히 불편을 초래하는 것 이상으로 교육, 취업 및 사회 참여에 대한 장애물을 만들어냅니다. 예를 들어 접근성 기능이 충분하지 않은 취업 지원 포털은 장애를 가진 유능한 개인이 채용 공고에 지원하는 것을 방해할 수 있어 전문적 발전 가능성을 제한할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n또한, 액세스할 수없는 기술은 디지털 격차를 악화시킬 수 있습니다. 디지털 풍경을 쉽게 탐색할 수 있는 사람과 앞을 굳이 막는 장애물을 마주치는 사람 간의 격차를 만들어 낼 수 있습니다. 학습 장애를 가진 학생이 교육 자료에 엑세스하기 어렵다면 애플리케이션이 접근성 기능을 제공하지 않는 경우 어떻게 될까요? 이는 그들의 학업 진행을 방해할 뿐만 아니라 향후 취업 및 사회적 상호작용으로 이어지는 배제의 피라미드를 유발할 수 있습니다.\n\n간략히 말하자면, 디지털 접근성의 포용의 중요성은 모든 능력을 가진 개인들의 삶의 질을 형성하는 능력에 있습니다. 규제 요건을 충족시키는 것뿐만 아니라 기술이 장벽을 만들지 않고 사람들을 연결하는 다리 역할을 하는 세상을 육성하는 데 의미가 있습니다. 안드로이드 개발에서 포용적 디자인 원칙을 수용함으로써 사용자 경험을 향상시킬 뿐 아니라 보다 공정하고 조화로운 디지털 사회에 기여할 수 있습니다.\n\n# 유럽 접근성 법안 (EAA)\n\n유럽 접근성 법안(EAA)은 유럽 연합 내에서 보다 포용적이고 접근성 있는 디지털 풍경을 창출하기 위한 전환이라고 말할 수 있습니다. 장애를 가진 사람들이 직면한 장애물을 철폐하기 위해 제정된 EAA는 디지털 서비스 및 제품 스펙트럼에 걸쳐 접근성 표준을 강제하는 포괄적인 프레임워크를 제시합니다. 그 중요성은 법률적 틀 내뿐만 아니라 수십만 명의 디지털 배제를 오래 겪어온 개인들의 삶에 미치는 영향에서도 드러납니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n핵심적으로 EAA는 기술이 방해요소가 아닌 오히려 촉진요소로 작용하는 사회 조성을 위한 의지를 반영합니다. 그 중요 조항 중 하나는 유럽 연합 내에서 운영되는 많은 기업들이 2025년까지 자사의 디지털 서비스와 제품들이 접근성을 보장해야 한다는 것을 명시하고 있습니다. 이는 웹사이트부터 모바일 애플리케이션, ATM, 그리고 e북까지 다양한 디지털 인터페이스를 포함하고 있습니다. 이 기한을 부과함으로써, EAA는 기업들이 디지털 제품을 제공하는 데 있어 접근성을 우선시하는 것을 강요하여 기술 산업에서 패러다임 변화를 촉발시킵니다.\n\nEAA의 중요성은 장애를 가진 개인들의 삶에 미칠 전환적인 영향을 고려할 때 특히 명확해집니다. 기술이 일상적인 활동에서 점점 더 중요한 역할을 하게 되는 가운데, 디지털 콘텐츠와 서비스에 접근할 수 있는 능력은 사회 전체적인 참여와 동일시되어집니다. EAA는 접근성을 강제함으로써, 장애를 가진 사람들을 위한 교육, 일자리, 그리고 사회 참여의 문을 열어주어 모두가 기여하고 번영할 수 있는 포용적 환경을 조성합니다.\n\n더불어, EAA는 유럽 연합을 넘어 국제적으로 디지털 접근성에 대한 시각을 영향을 미치는 선례를 제공합니다. 기업들이 EAA의 요구 사항에 대응하며 직면하는 도전에 대처할 때, 그들은 법적 의무뿐만 아니라 모든 사용자의 요구를 충족시키기 위한 기술을 만들어내는 도덕적 필요성을 받아들이고 있습니다. 이러한 노력을 통해 EAA는 모든 사람이 접근 가능한 디지털 시대의 혜택을 얻을 수 있도록 하는 데 있어 길잡이 역할을 하며, 디지털 포용이 규정적인 체크박스뿐만 아니라 기술 혁신의 필수 요소로 자리 잡는 미래의 길을 밝혀주고 있습니다.\n\n요약하자면, 유럽 접근성법은 디지털 접근성이 법으로 강제되는 것뿐만 아니라 사회적 필요성으로 받아들여지는 새로운 시대를 예고합니다. 비즈니스들이 포용성을 우선시하도록 강요함으로써, EAA는 장벽을 허물고 디지털 시대의 혜택이 모든 이에게 접근 가능하도록 보장하고, 보다 공정하고 조화로운 디지털 미래를 위한 기초를 마련하고 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 접근성 높은 안드로이드 앱 만들기\n\n접근성 높은 안드로이드 앱을 만드는 것은 다양한 디자인 고려 사항과 기능을 아우르는 복합적인 접근 방식이 필요합니다. 이러한 조치들은 다양한 능력을 가진 사용자들이 응용 프로그램을 원활하게 탐색하고 상호 작용할 수 있도록 보장하는 데 중요합니다. 안드로이드 앱 개발에서 접근성을 향상시키는 여러 가지 핵심 전략을 소개합니다:\n\n## 텍스트 가시성과 대비\n\n명확하고 가독성 있는 글꼴을 사용하여 가독성을 보장하세요. 글꼴 크기와 대비 비율을 조정하여 시각 장애가 있는 사용자나 작은 텍스트를 읽는 데 어려움이 있는 사용자들의 가시성을 향상시킵니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n코틀린:\n\n```kotlin\n// 가독성을 높이기 위해 텍스트 크기와 색상 설정\ntextView.setTextSize(TypedValue.COMPLEX_UNIT_SP, 18f)\ntextView.setTextColor(ContextCompat.getColor(context, R.color.textColor))\n```\n\nXML:\n\n```xml\n<TextView\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:textSize=\"18sp\"\n    android:textColor=\"@color/textColor\"/>\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n젯팩 컴포즈:\n\n```kotlin\nText(\n    text = \"Hello, World!\",\n    fontSize = 18.sp,\n    color = Color.Black // 적절한 색상 사용\n)\n```\n\n# 크고 간단한 컨트롤\n\n모터 장애가 있는 사용자나 터치 인터페이스를 사용하는 사용자들을 위해 클릭 실수의 위험을 줄이기 위해 더 큰 터치 대상과 버튼을 구현하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nKotlin:\n\n```kotlin\n// 버튼 크기 키우기\nbutton.layoutParams.width = 150\nbutton.layoutParams.height = 150\n```\n\nXML:\n\n```xml\n<Button\n    android:id=\"@+id/button\"\n    android:layout_width=\"150dp\"\n    android:layout_height=\"150dp\"/>\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n젯팩 컴포즈:\n\n```js\nButton(\n    onClick = { /* 버튼 클릭 로직 */ },\n    modifier = Modifier.size(150.dp)\n) {\n    Text(\"눌러주세요!\")\n}\n```\n\n# 콘텐츠 설명 및 대체 텍스트\n\n컨텐츠 설명 또는 대체 텍스트를 사용하여 이미지와 기타 텍스트가 아닌 요소에 대한 설명을 제공하세요. 이렇게 하면 스크린 리더를 사용하는 사용자들이 콘텐츠와 문맥을 이해할 수 있어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nKotlin (이미지용):\n\n```js\nimageView.contentDescription = \"이미지에 대한 설명 텍스트\";\n```\n\nXML (ImageView용):\n\n```js\n<ImageView\n  android:layout_width=\"wrap_content\"\n  android:layout_height=\"wrap_content\"\n  android:contentDescription=\"이미지에 대한 설명 텍스트\"\n  app:srcCompat=\"@drawable/your_image\"\n/>\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n젯팩 컴포즈 (이미지용):\n\n```kotlin\nImage(\n    painter = painterResource(id = R.drawable.your_image),\n    contentDescription = \"이미지에 대한 설명적 텍스트\",\n    modifier = Modifier.size(100.dp)\n)\n```\n\n# 색상 및 테마\n\n정보를 전달하기 위해 오로지 색상에 의존하지 말고, 색맹이나 시각 장애가 있는 사용자도 고려하여 중요 정보가 다른 시각적 신호를 통해서도 확인할 수 있도록 해주세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nKotlin:\n\n```js\n// 색상만으로 정보 전달에 의존하지 말고,\n// 아이콘이나 레이블과 같은 다른 시각적 단서를 사용하세요\ntextView.setBackgroundResource(R.drawable.rounded_corner_background);\n```\n\nXML:\n\n```js\n<TextView\n  android:layout_width=\"wrap_content\"\n  android:layout_height=\"wrap_content\"\n  android:background=\"@drawable/rounded_corner_background\"\n  android:text=\"중요 정보\"\n/>\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n젯팩 콤포즈:\n\n## 적응형 레이아웃과 반응형 디자인\n\n다양한 화면 크기와 방향에 적응하는 레이아웃을 디자인하세요. 반응형 디자인은 앱이 다양한 기기에서 사용자 친화적으로 유지되도록 하여 다양한 접근성 요구를 가진 사용자들에게 혜택을 줍니다.\n\n코틀린:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n//적응형 레이아웃을 위해 ConstraintLayout을 사용하세요\nval constraintLayout = findViewById<ConstraintLayout>(R.id.constraintLayout)\nval layoutParams = ConstraintLayout.LayoutParams(\n    ConstraintLayout.LayoutParams.MATCH_PARENT,\n    ConstraintLayout.LayoutParams.MATCH_PARENT\n)\nconstraintLayout.layoutParams = layoutParams\n```\n\nXML:\n\n```js\n<androidx.constraintlayout.widget.ConstraintLayout\n    android:id=\"@+id/constraintLayout\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n    <!-- 여기에 UI 구성 요소를 추가하세요 -->\n</androidx.constraintlayout.widget.ConstraintLayout>\n```\n\nJetpack Compose:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# TalkBack 및 화면 판독기\n\n시각 장애를 가진 사용자들을 위해 음성 피드백을 제공하는 TalkBack과 같은 화면 판독기를 통합하세요. 화면 판독기 사용자가 사용하는 제스처에 대한 앱의 호환성과 응답성을 테스트하세요.\n\n```js\n// 특정 뷰에 TalkBack 활성화\nViewCompat.setAccessibilityDelegate(view, object : AccessibilityDelegateCompat() {\n    override fun onInitializeAccessibilityNodeInfo(host: View?, info: AccessibilityNodeInfoCompat?) {\n        super.onInitializeAccessibilityNodeInfo(host, info)\n        info?.roleDescription = \"TalkBack용 사용자 정의 설명\"\n    }\n})\n```\n\nXML:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\n<View\n    android:id=\"@+id/view\"\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:contentDescription=\"TalkBack를 위한 사용자 정의 설명\"/>\n```\n\n젯팩 Compose:\n\n# 키보드 탐색\n\n터치 인터페이스 사용에 어려움을 겪을 수 있는 사용자들을 위해 키보드를 사용한 부드러운 탐색을 활성화하세요. 앱 내에서 논리적이고 직관적인 키보드 탐색 경로를 구현해주세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n코틀린:\n\n```kotlin\n// 뷰에 키보드 탐색 기능 활성화\nview.isFocusable = true\nview.isFocusableInTouchMode = true\nview.requestFocus()\n```\n\nXML:\n\n```xml\n<View\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:focusable=\"true\"\n    android:focusableInTouchMode=\"true\"/>\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n젯팩 콤포즈:\n\n```js\n// 콤포즈에서는 포커스가 일반적으로 자동으로 관리되지만 영향을 줄 수 있습니다\nTextField(\n    value = text,\n    onValueChange = { newText -> text = newText },\n    label = { Text(\"라벨\") },\n    modifier = Modifier.focusRequester(focusRequester)\n)\n```\n\n# 음성 명령 및 음성 입력\n\n음성 명령 기능을 통합하여 사용자가 음성을 사용하여 앱과 상호 작용할 수 있도록합니다. 이는 접근성이 떨어지는 개인이나 무료 경험을 선호하는 사람들에게 큰 혜택이 될 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nMarkdown:\n\n```xml\n<EditText\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:inputType=\"textMultiLine\"\n    android:imeOptions=\"actionDone\"/>\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 자막 및 대본\n\n오디오 및 비디오 콘텐츠에 자막을 포함시켜 보조기기를 사용하는 사용자들이 이용하기 쉽도록 하고, 대본을 제공하여 멀티미디어 콘텐츠를 보다 넓은 대중이 이용할 수 있도록 합니다.\n\nKotlin:\n\n```js\n// 비디오에 대한 자막 설정\nvideoView.contentDescription = \"비디오에 대한 자막\";\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nXML:\n\n```js\n<VideoView\n  android:id=\"@+id/videoView\"\n  android:layout_width=\"match_parent\"\n  android:layout_height=\"wrap_content\"\n  android:contentDescription=\"동영상을 위한 캡션\"\n/>\n```\n\nJetpack Compose:\n\n# 고대비 테마\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저시안을 가진 사용자 또는 특정 시각적 선호도를 갖는 사용자를 위해 시각성을 향상시키는 고대비 테마나 모드를 제공해보세요.\n\nKotlin:\n\n```js\n// 고대비 테마로 동적으로 전환하기\nAppCompatDelegate.setDefaultNightMode(AppCompatDelegate.MODE_NIGHT_YES);\n```\n\nMarkdown:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n<!-- styles.xml에 고대비 테마를 정의하세요 -->\n<style name=\"HighContrastTheme\" parent=\"Theme.AppCompat.DayNight\">\n    <item name=\"android:windowBackground\">@color/highContrastBackground</item>\n    <!-- 필요한 다른 속성을 추가하세요 -->\n</style>\n```\n\nJetpack Compose:\n\n```js\n// Compose 테마는 코드로 정의되며 프로그래밍 방식으로 전환할 수 있습니다\nval highContrastTheme = myTheme.copy(\n    colors = highContrastColors\n)\n```\n\n# 접근성이 좋은 폼\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n친절한 톤으로 번역해보겠습니다:\n\n친밀한 레이블, 명확한 지시사항 및 적절한 입력 유효성 검사를 갖춘 양식을 디자인하세요. 이를 통해 인지 장애가 있는 사용자나 복잡한 양식 구조에 어려움을 겪는 사용자들에게 도움이 됩니다.\n\nKotlin:\n\n```kotlin\n// 양식 필드에 적절한 레이블링과 입력 유효성 검사를 보장\neditText.hint = \"당신의 이름\"\neditText.inputType = InputType.TYPE_CLASS_TEXT\n```\n\nXML:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\n// Compose에서는 TextField 또는 기타 관련 컴포넌트를 사용하여 Form을 구축할 수 있습니다\nTextField(\n    value = text,\n    onValueChange = { newText -> text = newText },\n    label = { Text(\"Your Name\") },\n    singleLine = true\n)\n```\n\n# 동적 텍스트 및 폰트 크기 조정하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n앱 설정에서 텍스트 크기를 사용자 정의할 수 있도록 허용하여 사용자가 인터페이스를 개인적인 필요에 맞게 조정할 수 있게 합니다.\n\n이러한 접근성 기능과 디자인 원칙을 통합함으로써 안드로이드 앱 개발자는 모든 사용자에게 접근 가능한 더 포괄적인 디지털 환경에 기여할 수 있습니다. 실제 사용자와 피드백을 수렴하여 정기적인 테스트를 통해 앱의 접근성과 사용자 경험을 더욱 세련되게 할 수 있습니다.\n\n코틀린:\n\n```kotlin\n// Allow users to customize text size in the app settings\nval sharedPreferences = PreferenceManager.getDefaultSharedPreferences(context)\nval textSize = sharedPreferences.getFloat(\"text_size\", 16f)\ntextView.textSize = textSize\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nXML:\n\n```xml\n<TextView\n    android:id=\"@+id/textView\"\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:textSize=\"?attr/textSizePreference\"/>\n```\n\nJetpack Compose:\n\n이 예시들은 각 접근성 요소가 Kotlin, XML 및 Jetpack Compose에서 어떻게 처리될 수 있는지에 대한 간략한 통찰력을 제공합니다. 앱의 아키텍처 및 디자인에 따라 이러한 개념을 적절하게 조정 및 통합해야 할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 안드로이드 앱의 접근성 테스트\n\n모든 능력을 가진 사용자에게 안드로이드 앱이 접근 가능하도록 보장하려면 수동 및 자동화된 접근성 테스트 방법을 종합적으로 활용해야 합니다. 아래에서는 TalkBack 및 Switch Access를 활용한 수동 테스트부터 접근성 스캐너, APK 사전 시작 보고서, UIAutomatorViewer, Lint, Espresso, 사용자 테스트와 같은 분석 도구 및 프레임워크를 활용하는 다양한 테스트 방법을 개요로 설명합니다.\n\n# TalkBack\n\nTalkBack은 안드로이드 기기용 화면 리더기로, 시각 장애를 가진 사용자들을 위해 음성으로 피드백을 제공합니다. TalkBack로 수동 테스트하는 방법은 다음과 같습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 기기 설정에서 TalkBack을 활성화하세요.\n- 터치 제스처를 사용하여 앱을 탐색하고 TalkBack이 UI 요소를 읽는 방법을 확인해보세요.\n\n# 스위치 액세스\n\n스위치 액세스를 사용하면 기동 장애가 있는 사용자가 스위치를 사용하여 Android 기기와 상호 작용할 수 있습니다. 스위치 액세스를 수동으로 테스트하려면:\n\n- 기기 설정에서 스위치 액세스를 활성화하세요.\n- 스위치 장치를 연결하고 앱을 탐색하면서 모든 상호 작용 요소에 접근하고 사용할 수 있는지 확인하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 음성 액세스\n\n음성 액세스를 통해 사용자는 음성 명령을 사용하여 기기를 제어할 수 있습니다. 음성 액세스를 수동으로 테스트하려면:\n\n- 기기 설정에서 음성 액세스를 활성화합니다.\n- 음성 명령을 사용하여 앱을 탐색하고 모든 기능이 접근 가능한지 확인합니다.\n\n# 접근성 스캐너\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n접근성 스캐너는 잠재적인 접근성 문제를 검사하는 자동화 도구입니다. Accessibility Scanner를 사용하려면:\n\n- 테스트 기기에 Accessibility Scanner 앱을 설치하세요.\n- 앱을 열고 스캐너를 실행하여 접근성을 향상시키는 권고 사항을 받아보세요.\n\n# APK 사전 발매 보고서\n\nGoogle Play 콘솔의 APK 사전 발매 보고서는 앱의 접근성 성능에 대한 통찰을 제공합니다. 보고서를 생성하려면:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- Play Console에 앱을 업로드하세요.\n- \"릴리스 관리\"로 이동하여 \"사전 론칭 보고서\"를 확인하고 접근성 섹션을 검토하세요.\n\n## UIAutomatorViewer\n\nUIAutomatorViewer는 앱의 UI 구성 요소를 검사하는 도구입니다. UIAutomatorViewer를 사용하려면:\n\n- Android SDK 도구에서 뷰어를 실행하세요.\n- 기기를 연결하고 앱을 열어 UI 요소를 적절한 레이블과 계층 구조로 검사하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 린트\n\n안드로이드 린트에는 코드에서 잠재적인 문제를 식별하는 접근성 체크가 포함되어 있습니다. 린트를 실행하려면:\n\n- 터미널에서 다음 명령을 사용하십시오: `./gradlew lint`\n- 생성된 보고서에서 접근성 경고를 검토하십시오.\n\n# 에스프레소\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n에스프레소는 안드로이드용 강력한 테스팅 프레임워크로, UI 테스팅 및 접근성 측면에서 사용할 수 있습니다. 에스프레소를 사용하여 가시성을 테스트하는 간단한 예제를 확인해보세요:\n\n```js\nAccessibilityChecks.enable().setRunChecksFromRootView(true);\n```\n\n```js\nAccessibilityChecks.enable().apply {\n    setSuppressingResultMatcher(allOf(\n        matchesCheckNames(`is`(\"TextContrastViewCheck\")),\n        matchesViews(withId(R.id.countTV))\n    ))\n}\n```\n\n# 사용자 테스팅\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n**마지막으로, 다양한 능력을 가진 사람들을 대상으로 한 사용자 테스트는 앱의 접근성에 대한 귀중한 통찰을 제공합니다. 다음을 고려해 보세요:**\n\n- **장애를 가진 사용자를 모집하여 앱을 테스트합니다.**\n- **그들의 경험에 대한 피드백을 수집하고 반복적으로 개선합니다.**\n\n**이러한 테스트 방법을 결합하여 안드로이드 앱이 접근 가능하다는 것을 체계적으로 보장할 수 있습니다. 모든 사용자에게 긍정적이고 포괄적인 경험을 제공해 보세요.**\n\n# **결론**\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n드디어 안드로이드 앱 개발에서 접근성을 채택하는 것은 준수를 넘어서 모든 능력을 가진 사용자를 환영하는 포용적인 디지털 세계를 만들기 위한 약속입니다. 접근성 있는 앱을 개발하는 길은 다양한데, 가시성과 간결함을 우선시하는 디자인 원칙을 구현하는 것부터 첨단 테스트 방법을 활용하는 등 모든 것을 포함합니다.\n\n유럽 접근성법(EAA)은 2025년까지 회사들이 디지털 제품을 접근성 있게 하는 것을 보장하는 법적, 윤리적 필수성을 강조하는 선례를 제공했습니다. 이 지침은 디지털 포용성의 중요성을 인식하는 글로벌 이동을 강조합니다. 개발자로서, 우리는 이 변화에서 중추적인 역할을 하며, 장애요소를 제거하고 사용자가 디지털 세계를 원활하게 탐색할 수 있는 솔루션을 개발하는 역할을 맡았습니다.\n\nTalkBack, Switch Access, Voice Access와 같은 수동 테스트부터 Accessibility Scanner, APK Pre-Launch Report, UIAutomatorViewer, Lint와 같은 첨단 분석 도구를 활용하는 것까지, 개발 과정의 모든 단계가 접근성의 최종 목표에 기여합니다. Espresso와 같은 강력한 테스트 프레임워크를 통해 개발자들은 접근성 구현의 효과를 프로그래밍적으로 확인할 수 있습니다.\n\n하지만 가장 통찰력 있는 피드백은 종종 실제 사용자로부터 옵니다. 특히 다양한 능력을 가진 사용자들을 참여시키는 사용자 테스트는 접근성 평가에 질적인 차원을 제공합니다. 그들의 경험과 시각은 개발자들을 자신들의 앱을 개선하도록 이끄는 데 도움이 되며, 앱을 보다 직관적이고 탐색 가능하며 보편적으로 환영받는 것으로 만듭니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n접근성에 대한 약속은 고정적인 것이 아닙니다. 계속된 학습과 적응이 필요하며, 만능 디자인 원칙을 준수하는 디지턈 환경을 만들기 위한 변함없는 헌신이 필요합니다. 앞으로 나아가면서, 우리는 규제적인 기준을 준수하는 것뿐만 아니라, 제약을 넘어진 디지턈 경험을 개발하고 진정한 포용의 정신을 대변하는 것을 목표로 할 것입니다. 이렇게 함으로써, 법적 요구사항을 충족할 뿐만 아니라, 기술이 다양한 삶의 방식을 가진 사람들을 통합하는 다리 역할을 하며 미래에 기여할 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-06-19-AccessibilityAmplifiedAJourneytoInclusiveAndroidApps_0.png"},"coverImage":"/assets/img/2024-06-19-AccessibilityAmplifiedAJourneytoInclusiveAndroidApps_0.png","tag":["Tech"],"readingTime":24}],"page":"29","totalPageCount":110,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true}