{"pageProps":{"post":{"title":"SwiftUI TextField 심화  이벤트, 포커스, 키보드 제어 방법","description":"","date":"2024-06-23 21:35","slug":"2024-06-23-AdvancedSwiftUITextFieldEventsFocusKeyboard","content":"\n이 글은 SwiftUI TextField 이벤트, 포커스 전환, 키보드 설정 및 기타 관련 경험, 기술 및 고려 사항을 탐색할 것입니다.\n\n## 이벤트\n\n### onEditingChanged\n\nTextField가 포커스를 얻을 때(편집 가능한 상태로 전환될 때), onEditingChanged는 주어진 메서드를 호출하고 값으로 true를 전달합니다. TextField가 포커스를 잃을 때, 다시 메서드를 호출하고 값을 false로 전달합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```swift\nstruct OnEditingChangedDemo: View {\n    @State var name = \"\"\n\n    var body: some View {\n        List {\n            TextField(\"이름:\", text: $name, onEditingChanged: getFocus)\n        }\n    }\n\n    func getFocus(focused: Bool) {\n        print(\"포커스 받음: \\(focused ? \"참\" : \"거짓\")\")\n    }\n}\n```\n\n이 매개변수의 이름은 사용자에게 모호함을 초래하기 쉽습니다. 사용자가 콘텐츠를 입력했는지 확인하는 데 onEditingChanged를 사용하지 마십시오.\n\niOS 15에서는 ParseableFormatStyle을 지원하는 새로 추가된 생성자에서 이 매개변수를 제공하지 않습니다. 따라서 새로운 Formatter를 사용하는 TextFields의 경우, 포커스를 얻었는지 또는 상실했는지를 확인하기 위해 다른 수단을 사용해야 합니다.\n\n# onCommit\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nonCommit은 사용자가 입력하는 중에 리턴 키를 누를 때 (또는 클릭할 때) 트리거됩니다 (코드 시뮬레이션으로는 트리거할 수 없음). 사용자가 리턴 키를 클릭하지 않으면(예: 직접 다른 TextField로 전환하는 경우) onCommit은 트리거되지 않습니다. onCommit이 트리거되는 동시에 TextField는 포커스를 잃게 됩니다.\n\n```js\nstruct OnCommitDemo: View {\n    @State var name = \"\"\n    var body: some View {\n        List {\n            TextField(\"이름:\", text: $name, onCommit: { print(\"커밋\") })\n        }\n    }\n}\n```\n\n사용자가 입력한 내용을 확인해야 하는 경우, onCommit과 onEditingChanged를 함께 사용하는 것이 좋습니다. 사용자의 입력 데이터를 실시간으로 처리하려면 SwiftUI TextField 고급 — 형식 지정 및 유효성 검사를 참고해주세요.\n\nonCommit은 SecureField에도 적용됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\niOS 15에서 추가된 ParseableFormatStyle을 지원하는 새 생성자는 해당 매개변수를 제공하지 않습니다. 동일한 효과를 얻으려면 새롭게 추가된 onSubmit을 사용할 수 있습니다.\n\n# onSubmit\n\nonSubmit은 SwiftUI 3.0에서 새로 추가된 기능입니다. onCommit 및 onEditingChanged는 각각의 TextField의 상태를 설명하지만 onSubmit은 한 뷰 내에서 여러 TextField의 통합 관리 및 일정 관리를 가능하게 합니다.\n\n```js\n// onSubmit의 정의\nextension View {\n    public func onSubmit(of triggers: SubmitTriggers = .text, _ action: @escaping (() -> Void)) -> some View\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래 코드는 onCommit과 동일한 동작을 구현할 것입니다:\n\n```js\nstruct OnSubmitDemo:View{\n    @State var name = \"\"\n    var body: some View{\n        List{\n            TextField(\"name:\",text: $name)\n                .onSubmit {\n                    print(\"commit\")\n                }\n        }\n    }\n}\n```\n\nonSubmit의 트리거 조건은 onCommit과 동일하며, 사용자가 “return”을 활성화하도록 요구합니다.\n\nonSubmit은 SecureField에도 적용됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 범위와 중첩\n\nonSubmit의 구현은 환경 값 TriggerSubmitAction을 설정하는 것에 기반하며 (아직 개발자에게 제공되지 않음) onSubmit은 범위를 가지고 있으며 (뷰 트리로 전달될 수 있음) 중첩될 수 있습니다.\n\n```js\nstruct OnSubmitDemo: View {\n    @State var text1 = \"\"\n    @State var text2 = \"\"\n    @State var text3 = \"\"\n    var body: some View {\n        Form {\n            Group {\n                TextField(\"text1\", text: $text1)\n                    .onSubmit { print(\"text1 commit\") }\n                TextField(\"text2\", text: $text2)\n                    .onSubmit { print(\"text2 commit\") }\n            }\n            .onSubmit { print(\"textfield in group commit\") }\n            TextField(\"text3\", text: $text3)\n                .onSubmit { print(\"text3 commit\") }\n        }\n        .onSubmit { print(\"textfield in form commit1\") }\n        .onSubmit { print(\"textfield in form commit2\") }\n    }\n}\n```\n\nTextField (text1)이 commit되면, 콘솔 출력은 다음과 같습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n양식에서의 텍스트 필드 커밋2\n양식에서의 텍스트 필드 커밋1\n그룹에서의 텍스트 필드 커밋\n텍스트1 커밋\n```\n\n외부에서 내부로 호출 순서임을 참고하십시오.\n\n# 제한된 범위\n\nsubmitScope를 사용하여 범위를 차단하고 (뷰 트리 상에서의 추가 전파를 제한합니다). 예를 들어, 위 코드에서는 그룹 뒤에 submitScope를 추가하십시오.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n그룹 {\n    TextField(\"text1\", text: $text1)\n        .onSubmit { print(\"text1 commit\") }\n    TextField(\"text2\", text: $text2)\n        .onSubmit { print(\"text2 commit\") }\n}\n.submitScope()  // scope blocking\n.onSubmit { print(\"textfield in group commit\") }\n```\n\nTextField1이 커밋되면 콘솔에 다음이 표시됩니다:\n\n```js\ntext1 commit\n```\n\n이 시점에서 onSubmit의 범위는 그룹 내로 제한됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n뷰에 여러 개의 TextFields가 있는 경우, onSubmit과 FocusState를 결합하여 훌륭한 사용자 경험을 얻을 수 있습니다.\n\n# searchable 지원\n\niOS 15에서는 새로운 검색 상자도 \"return\"을 클릭할 때 onSubmit을 트리거하지만, 트리거를 검색으로 설정해야 합니다:\n\n```js\nstruct OnSubmitForSearchableDemo:View{\n    @State var name = \"\"\n    @State var searchText = \"\"\n    var body: some View{\n        NavigationView{\n            Form{\n                TextField(\"이름:\",text:$name)\n                    .onSubmit {print(\"textField 커밋\")}\n            }\n            .searchable(text: $searchText)\n            .onSubmit(of: .search) { //\n                print(\"searchField 커밋\")\n            }\n        }\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nSubmitTriggers의 타입은 OptionSet입니다. onSubmit 메서드는 환경 내에서 뷰 트리에서 SubmitTriggers에 포함된 값을 계속 전달합니다. onSubmit에서 받는 SubmitTriggers 값이 onSubmit에서 지정된 SubmitTriggers 세트에 포함되지 않으면 전달이 종료됩니다. 간단히 말해, onSubmit(of:.search)은 TextField에서 생성된 커밋 상태를 차단하고 그 반대도 마찬가지입니다.\n\n예를 들어, 위 코드에서 searchable 다음에 onSubmt(of:.text)를 추가하면 TextField의 커밋 이벤트에 응답할 수 없게 됩니다.\n\n```js\n.searchable(text: $searchText)\n            .onSubmit(of: .search) {\n                print(\"searchField commit1\")\n            }\n            .onSubmit {print(\"textField commit\")} //cannot be triggered, blocked by search\n```\n\n따라서 TextField와 검색 상자를 모두 처리할 때 호출 순서에 특별히 주의해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음 코드는 하나의 onSubmit에서 TextField와 검색 상자를 모두 지원할 수 있습니다:\n\n```js\n.onSubmit(of: [.text, .search]) {\n  print(\"무언가가 제출되었습니다\")\n}\n```\n\n다음 코드는 searchable 보다 onSubmit(of:.search)가 먼저 배치되어 있기 때문에 어느 것도 트리거하지 않습니다.\n\n```js\nNavigationView{\n    Form{\n        TextField(\"이름:\", text: $name)\n            .onSubmit {print(\"textField 제출\")}\n    }\n    .onSubmit(of: .search) { // 트리거 안 됨\n        print(\"searchField 제출1\")\n    }\n    .searchable(text: $searchText)\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 초점\n\niOS 15(몬테레이) 이전에는 SwiftUI에서 TextField(예 : becomeFirstResponder)에 초점을 맞추는 방법을 제공하지 않았습니다. 오랫동안 개발자들은 비슈위 방법에 의존하여 비슷한 기능을 구현해야 했습니다.\n\nSwiftUI 3.0에서 Apple은 개발자들에게 onSubmit과 유사한, 높은 수준의 뷰 계층 구조에서 텍스트 필드의 초점을 일관되게 결정하고 관리할 수 있는 예상보다 훨씬 더 나은 솔루션을 제공했습니다.\n\n# 기본 사용법\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nSwiftUI에서는 새 FocusState 프로퍼티 래퍼를 제공하여이 뷰 내의 TextField에 포커스가 있는지 여부를 결정하는 데 도움을 줍니다. focused를 사용하여 FocusState를 특정 TextField와 연결할 수 있습니다.\n\n```swift\nstruct OnFocusDemo: View {\n    @FocusState var isNameFocused: Bool\n    @State var name = \"\"\n\n    var body: some View {\n        List {\n            TextField(\"이름:\", text: $name)\n                .focused($isNameFocused)\n        }\n        .onChange(of: isNameFocused) { value in\n            print(value)\n        }\n    }\n}\n```\n\n위 코드는 TextField가 포커스를 얻을 때 isNameFocused를 true로 설정하고 포커스를 잃을 때 false로 설정합니다.\n\n동일한 뷰 내에 여러 개의 TextField가있는 경우 각 해당 TextField와 연결할 여러 FocusStates를 생성할 수 있습니다. 예를 들어:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 방법은 뷰에 더 많은 TextField가 있는 경우 귀찮아지고 통일된 관리에 도움이 되지 않습니다. 다행히 FocusState는 Boolean 값뿐만 아니라 모든 해시 타입도 지원합니다. Hashable 프로토콜을 준수하는 enum을 사용하여 뷰 내 여러 TextField의 포커스를 관리할 수 있습니다. 다음 코드는 위의 코드와 동일한 기능을 수행합니다:\n\n```js\nstruct OnFocusDemo:View{\n    @FocusState var focus:FocusedField?\n    @State var name = \"\"\n    @State var password = \"\"\n    var body: some View{\n        List{\n            TextField(\"name:\",text:$name)\n                .focused($focus, equals: .name)\n            SecureField(\"password:\",text:$password)\n                .focused($focus,equals: .password)\n        }\n        .onChange(of: focus, perform: {print($0)})\n    }\n\n    enum FocusedField:Hashable{\n        case name,password\n    }\n}\n```\n\n# 특정 TextField가 뷰를 표시한 직후에 즉시 포커스를 받도록 만들기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nFocusState를 사용하면 지정된 TextField가 포커스를 얻고 뷰를 표시한 후 즉시 키보드가 팝업되게 할 수 있어요:\n\n```js\nstruct OnFocusDemo: View {\n    @FocusState var focus: FocusedField?\n    @State var name = \"\"\n    @State var password = \"\"\n\n    var body: some View {\n        List {\n            TextField(\"이름:\", text: $name)\n                .focused($focus, equals: .name)\n            SecureField(\"비밀번호:\", text: $password)\n                .focused($focus, equals: .password)\n        }\n        .onAppear {\n            DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {\n                focus = .name\n            }\n        }\n    }\n\n    enum FocusedField: Hashable {\n        case name, password\n    }\n}\n```\n\n뷰 초기화 중에 값을 할당하는 것은 잘못된 방법이에요. onAppear에서도 TextField가 포커스를 얻을 시간을 지연시켜야 해요 (iOS 16에서는 지연이 필요하지 않아요).\n\n# 여러 개의 TextField 사이에서 포커스 전환하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n주의력과 onSubmit을 결합하여 한 TextField에서 입력을 완료하고(리턴을 클릭할 때) 자동으로 다음 TextField로 포커스를 전환하는 효과를 얻을 수 있어요.\n\n```js\nstruct OnFocusDemo:View{\n    @FocusState var focus:FocusedField?\n    @State var name = \"\"\n    @State var email = \"\"\n    @State var phoneNumber = \"\"\n    var body: some View{\n        List{\n            TextField(\"이름:\",text:$name)\n                .focused($focus, equals: .name)\n                .onSubmit {\n                    focus = .email\n                }\n            TextField(\"이메일:\",text:$email)\n                .focused($focus,equals: .email)\n                .onSubmit {\n                    focus = .phone\n                }\n            TextField(\"전화번호:\",text:$phoneNumber)\n                .focused($focus, equals: .phone)\n                .onSubmit {\n                    if !name.isEmpty && !email.isEmpty && !phoneNumber.isEmpty {\n                        submit()\n                    }\n                }\n        }\n    }\n\n    private func submit(){\n        // 모든 정보 제출\n        print(\"제출\")\n    }\n    enum FocusedField:Hashable{\n        case name,email,phone\n    }\n}\n```\n\n위의 코드는 onSubmit 전달 기능을 활용하여 다음과 같이 변환될 수도 있어요:\n\n```js\nList {\n    TextField(\"이름:\", text: $name)\n        .focused($focus, equals: .name)\n    TextField(\"이메일:\", text: $email)\n        .focused($focus, equals: .email)\n    TextField(\"전화번호:\", text: $phoneNumber)\n        .focused($focus, equals: .phone)\n}\n.onSubmit {\n    switch focus {\n    case .name:\n        focus = .email\n    case .email:\n        focus = .phone\n    case .phone:\n        if !name.isEmpty, !email.isEmpty, !phoneNumber.isEmpty {\n            submit()\n        }\n    default:\n        break\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n화면 버튼(예: 보조 키보드 보기) 또는 키보드 단축키를 결합하여 포커스를 전환하거나 특정 TextField로 이동할 수도 있습니다.\n\n# 포커스를 얻기 위한 키보드 단축키 사용\n\n보안 필드를 포함한 여러 개의 TextField가 있는 뷰에서는 Tab 키를 사용하여 TextField에서 포커스를 직접 전환할 수 있습니다. 그러나 SwiftUI는 키보드 단축키를 사용하여 특정 TextField에 포커스를 설정하는 기능을 직접 제공하지 않습니다. FocusState와 keyboardShortcut을 결합하여 iPad 및 MacOS에서 이 기능을 얻을 수 있습니다.\n\n키보드 단축키 바인딩을 지원하는 focused를 생성하세요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```swift\npublic extension View {\n    func focused(_ condition: FocusState<Bool>.Binding, key: KeyEquivalent, modifiers: EventModifiers = .command) -> some View {\n        focused(condition)\n            .background(Button(\"\") {\n                condition.wrappedValue = true\n            }\n            .keyboardShortcut(key, modifiers: modifiers)\n            .hidden()\n            )\n    }\n\n    func focused<Value>(_ binding: FocusState<Value>.Binding, equals value: Value, key: KeyEquivalent, modifiers: EventModifiers = .command) -> some View where Value: Hashable {\n        focused(binding, equals: value)\n            .background(Button(\"\") {\n                binding.wrappedValue = value\n            }\n            .keyboardShortcut(key, modifiers: modifiers)\n            .hidden()\n            )\n    }\n}\n```\n\n코드 사용법:\n\n```swift\nstruct ShortcutFocusDemo: View {\n    @FocusState var focus: FouceField?\n    @State private var email = \"\"\n    @State private var address = \"\"\n    var body: some View {\n        Form {\n            TextField(\"이메일\", text: $email)\n                .focused($focus, equals: .email, key: \"t\")\n            TextField(\"주소\", text: $address)\n                .focused($focus, equals: .address, key: \"a\", modifiers: [.command, .shift, .option])\n        }\n    }\n\n    enum FouceField: Hashable {\n        case email\n        case address\n    }\n}\n```\n\n사용자가 ⌘ + T를 입력하면 이메일을 처리하는 TextField에 초점이 맞춰집니다. 사용자가 ⌘ + ⌥ + ⇧ + A를 입력하면 주소를 처리하는 TextField에 초점이 맞춰집니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 자체 onEditingChanged 만들기\n\n개별 TextField의 포커스 상태를 확인하는 가장 좋은 방법은 여전히 onEditingChanged를 사용하는 것입니다. 그러나 새 포매터와 같이 onEditingChanged를 사용할 수 없는 경우에는 FocusState를 사용하여 비슷한 효과를 얻을 수 있습니다.\n\n- 개별 TextField의 포커스 상태 확인\n\n```swift\npublic extension View {\n    func focused(_ condition: FocusState<Bool>.Binding, onFocus: @escaping (Bool) -> Void) -> some View {\n        focused(condition)\n            .onChange(of: condition.wrappedValue) { value in\n                onFocus(value == true)\n            }\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n사용 방법:\n\n```js\nstruct onEditingChangedFocusVersion:View{\n    @FocusState var focus:Bool\n    @State var price = 0\n    var body: some View{\n        Form{\n            TextField(\"가격:\",value:$price,format: .number)\n                .focused($focus){ focused in\n                    print(focused)\n                }\n        }\n    }\n}\n```\n\n- 여러 TextFields 확인\n\nTextField가 포커스를 잃을 때 여러 번 호출을 피하기 위해 뷰 계층 구조에서 마지막 포커스된 TextField의 FocusState 값을 저장해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\npublic extension View {\n    func storeLastFocus<Value: Hashable>(current: FocusState<Value?>.Binding, last: Binding<Value?>) -> some View {\n        onChange(of: current.wrappedValue) { _ in\n            if current.wrappedValue != last.wrappedValue {\n                last.wrappedValue = current.wrappedValue\n            }\n        }\n    }\n\n    func focused<Value>(_ binding: FocusState<Value>.Binding, equals value: Value, last: Value?, onFocus: @escaping (Bool) -> Void) -> some View where Value: Hashable {\n        return focused(binding, equals: value)\n            .onChange(of: binding.wrappedValue) { focusValue in\n                if focusValue == value {\n                    onFocus(true)\n                } else if last == value { // only call once\n                    onFocus(false)\n                }\n            }\n    }\n}\n```\n\n호출:\n\n```js\nstruct OnFocusView: View {\n    @FocusState private var focused: Focus?\n    @State private var lastFocused: Focus?\n    @State private var name = \"\"\n    @State private var email = \"\"\n    @State private var address = \"\"\n    var body: some View {\n        List {\n            TextField(\"이름:\", text: $name)\n                .focused($focused, equals: .name, last: lastFocused) {\n                    print(\"이름:\", $0)\n                }\n            TextField(\"이메일:\", text: $email)\n                .focused($focused, equals: .email, last: lastFocused) {\n                    print(\"이메일:\", $0)\n                }\n            TextField(\"주소:\", text: $address)\n                .focused($focused, equals: .address, last: lastFocused) {\n                    print(\"주소:\", $0)\n                }\n        }\n        .storeLastFocus(current: $focused, last: $lastFocused) // 최신 포커스 값을 저장합니다.\n    }\n\n    enum Focus {\n        case name, email, address\n    }\n}\n```\n\n# 키보드\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nTextField를 사용하다보면 소프트웨어 키보드와 함께 작업해야 합니다. 이 섹션에서는 키보드와 관련된 몇 가지 예제를 소개할 것입니다.\n\n## 키보드 유형\n\niPhone에서 keyboardType를 통해 소프트웨어 키보드 유형을 설정하여 사용자 입력을 용이하게 하거나 입력 문자 범위를 제한할 수 있습니다.\n\n예시:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```swift\nstruct KeyboardTypeDemo: View {\n    @State var price: Double = 0\n    var body: some View {\n        Form {\n            TextField(\"Price:\", value: $price, format: .number.precision(.fractionLength(2)))\n                .keyboardType(.decimalPad) // 소수점 숫자 키보드 지원\n        }\n    }\n}\n```\n\n위 이미지는 \"/assets/img/2024-06-23-AdvancedSwiftUITextFieldEventsFocusKeyboard_0.png\" 입니다.\n\n현재, 지원되는 키보드 유형은 총 11가지이며, 다음과 같습니다:\n\n- asciiCapable\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 번호 및 구두점 테이블입니다.\n\n| numbersAndPunctuation   |\n| ----------------------- |\n| Numbers and punctuation |\n\nURL 테이블로 아래 내용을 변환해주세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nURL 주소를 입력하는 데 유용하며, 문자 및 '.', '/', '.com'을 포함할 수 있습니다.\n\n- numberPad\n\n해당 지역의 숫자 세트를 사용합니다(0-9, ۰-۹, ०-९ 등). 양의 정수나 PIN에 적합합니다.\n\n- phonePad\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n전화기에서 사용되는 숫자 및 다른 기호, 예를 들면 ‘\\*#+’\n\n- namePhonePad\n\n텍스트 및 전화번호 입력에 편리합니다. 문자 상태는 asciiCapable과 유사하며, 숫자 상태는 numberPad와 유사합니다.\n\n- emailAddress\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n'@'를 입력하는 데 편리한 아스키 호환 키보드입니다.\n\n- decimalPad\n\n소수점이 포함된 숫자 키패드입니다. 자세한 내용은 위의 이미지를 참조해주세요.\n\n- 트위터\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아스키 지원 키보드에는 '@#'이 포함되어 있습니다.\n\n- 웹 검색\n\n'.'을 포함한 아스키 지원 키보드이며 'return' 키는 'go'로 표시됩니다.\n\n- 아스키 지원 번호 패드\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nAn asciiCapable 키보드에는 숫자가 포함되어 있습니다.\n\nApple은 다양한 키보드 모드를 제공하지만, 경우에 따라 사용자의 요구 사항을 충족시키지 못할 수도 있습니다.\n\n예를 들어, numberPad 및 decimalPad에는 \"-\" 및 \"return\"이 없습니다. SwiftUI 3.0 이전에는 주요 뷰에 별도로 그리거나 SwiftUI 이외의 방법을 사용하여 문제를 해결해야 했습니다. 그러나 SwiftUI 3.0에서는 네이티브 설정 키보드 보조 뷰(자세한 내용은 아래에 설명되어 있음) 추가로 위 문제를 해결하는 것이 이제 더 어렵지 않아졌습니다.\n\n# TextContentType를 통해 제안을 받아보세요\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n특정 iOS 앱을 사용할 때 텍스트를 입력할 때 소프트웨어 키보드가 자동으로 입력해야 할 내용을 제안하는 경우가 있습니다. 이는 전화 번호, 이메일, 인증 코드 등을 텍스트ContentType를 통해 얻는 효과입니다.\n\nTextField의 UITextContentType을 설정함으로써 시스템은 입력 중에 입력하려는 콘텐츠를 지능적으로 추론하고 제안을 표시합니다.\n\n다음 코드는 비밀번호 입력 시 키체인을 사용할 수 있도록 합니다.\n\n```js\nstruct KeyboardTypeDemo: View {\n    @State var password = \"\"\n    var body: some View {\n        Form {\n            SecureField(\"\", text: $password)\n                .textContentType(.password)\n        }\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-06-23-AdvancedSwiftUITextFieldEventsFocusKeyboard_1.png\" />\n\n이메일 주소를 입력할 때 연락처 및 이메일에서 비슷한 이메일 주소를 제안하는 코드입니다:\n\n```js\nstruct KeyboardTypeDemo: View {\n    @State var email = \"\"\n    var body: some View {\n        Form {\n            TextField(\"\", text: $email)\n                .textContentType(.emailAddress)\n        }\n    }\n}\n```\n\n<img src=\"/assets/img/2024-06-23-AdvancedSwiftUITextFieldEventsFocusKeyboard_2.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음은 설정할 수 있는 여러 종류의 UITextContentType이 있습니다. 흔히 사용되는 것들 중 일부는 다음과 같습니다:\n\n- password\n- 이름 옵션, 예를 들어 name, givenName, middleName 등이 있습니다.\n- 주소 옵션, 예를 듀 addressCity, fullStreetAddress, postalCode 등이 있습니다.\n- telephoneNumber\n- emailAddress\n- oneTimeCode (인증 코드)\n\n# 키보드 해제\n\n일부 경우에는 사용자가 텍스트 입력을 완료한 후 소프트웨어 키보드를 해제하여 더 많은 디스플레이 공간을 확보해야 할 수 있습니다. 일부 키보드 유형에는 \"return\" 버튼이 없기 때문에 프로그래밍을 사용하여 키보드를 사라지게 해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n또한 가끔은 사용자가 \"return\" 버튼을 클릭하지 않고도 화면의 다른 영역을 클릭하거나 목록을 스크롤하여 키보드를 숨길 수 있게 하려고 할 수도 있습니다. 상호 작용 경험을 향상시키기 위해 프로그래밍을 사용하여 키보드를 사라지게 할 필요가 있습니다.\n\n- FocusState를 사용하여 키보드 숨기기\n\n해당 FocusState가 TextField에 설정되면 값을 \"false\" 또는 \"nil\"로 설정하여 키보드를 숨길 수 있습니다.\n\n```js\nstruct HideKeyboardView: View {\n    @State private var name = \"\"\n    @FocusState private var nameIsFocused: Bool\n\n    var body: some View {\n        Form {\n            TextField(\"이름을 입력하세요\", text: $name)\n                .focused($nameIsFocused)\n            Button(\"키보드 숨기기\") {\n                nameIsFocused = false\n            }\n        }\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 기타 상황\n\n대부분의 경우, 우리는 UIkit에서 제공하는 메서드를 직접 사용하여 키보드를 숨길 수 있습니다.\n\n```js\nUIApplication.shared.sendAction(#selector(UIResponder.resignFirstResponder), to: nil, from: nil, for: nil)\n```\n\n예를 들어, 사용자가 뷰를 드래그할 때 키보드를 숨기는 다음 코드가 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n구조 ResignKeyboardOnDragGesture: ViewModifier {\n    var gesture = DragGesture().onChanged { _ in\n        UIApplication.shared.sendAction(#selector(UIResponder.resignFirstResponder), to: nil, from: nil, for: nil)\n    }\n\n    func body(content: Content) -> some View {\n        content.gesture(gesture)\n    }\n}\nextension View {\n    func dismissKeyboard() -> some View {\n        return modifier(ResignKeyboardOnDragGesture())\n    }\n}\n구조 HideKeyboardView: View {\n    @State private var name = \"\"\n    var body: some View {\n        Form {\n            TextField(\"이름을 입력하세요\", text: $name)\n        }\n        .dismissKeyboard()\n    }\n}\n```\n\n# 키보드 어시스턴트 뷰\n\n# 툴바를 통해 생성됨\n\nSwiftUI 3.0에서는 ToolbarItem(placement: .keyboard, content: View)를 사용하여 키보드 어시스턴트 뷰(inputAccessoryView)를 생성할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n입력 보조 뷰를 통해 이전에 처리하기 어려웠던 많은 문제들을 해결하고 상호 작용 수단을 더 많이 제공할 수 있습니다.\n\n다음 코드는 소수점 숫자를 입력할 때 양/음수 변환 및 확인 버튼을 추가합니다:\n\n```js\nimport Introspect\nstruct ToolbarKeyboardDemo: View {\n    @State var price = \"\"\n    var body: some View {\n        Form {\n            TextField(\"가격:\", text: $price)\n                .keyboardType(.decimalPad)\n                .toolbar {\n                    ToolbarItem(placement: .keyboard) {\n                        HStack {\n                            Button(\"-/+\") {\n                                if price.hasPrefix(\"-\") {\n                                    price.removeFirst()\n                                } else {\n                                    price = \"-\" + price\n                                }\n                            }\n                            .buttonStyle(.bordered)\n                            Spacer()\n                            Button(\"완료\") {\n                                UIApplication.shared.sendAction(#selector(UIResponder.resignFirstResponder), to: nil, from: nil, for: nil)\n                                // 해야 할 일을 수행합니다\n                            }\n                            .buttonStyle(.bordered)\n                        }\n                        .padding(.horizontal, 30)\n                    }\n                }\n        }\n    }\n}\n```\n\n<img src=\"/assets/img/2024-06-23-AdvancedSwiftUITextFieldEventsFocusKeyboard_3.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n안타깝지만, ToolbarItem을 통해 입력 보조 뷰를 설정하는 데는 아직 몇 가지 제한 사항이 있습니다:\n\n- 표시 콘텐츠 제한\n\n높이가 고정되어 있어 악세서리 뷰의 전체 디스플레이 영역을 활용할 수 없습니다. 다른 종류의 툴바와 마찬가지로 SwiftUI가 콘텐츠의 레이아웃에 개입합니다.\n\n- 같은 뷰 내에서 여러 텍스트 필드에 대해 별도의 액세서리 뷰를 설정할 수 없음\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n보다 복잡한 조건부 구문은 ToolbarItem에서 사용할 수 없습니다. 다른 텍스트 필드에 대해 별도로 설정하더라도 SwiftUI는 모든 내용을 함께 표시하기 위해 병합합니다.\n\n# UIKit을 통해 생성하기\n\n현재 단계에서는 SwiftUI에 대한 키보드 액세서리 뷰를 UIKit을 통해 생성하는 것이 여전히 최적의 솔루션이 됩니다. 화면 표시에 대한 완벽한 제어를 얻을 수 있을 뿐만 아니라 동일한 뷰 내부의 여러 텍스트 필드를 별도로 설정할 수도 있습니다.\n\n```js\nextension UIView {\n    func constrainEdges(to other: UIView) {\n        translatesAutoresizingMaskIntoConstraints = false\n        NSLayoutConstraint.activate([\n            leadingAnchor.constraint(equalTo: other.leadingAnchor),\n            trailingAnchor.constraint(equalTo: other.trailingAnchor),\n            topAnchor.constraint(equalTo: other.topAnchor),\n            bottomAnchor.constraint(equalTo: other.bottomAnchor),\n        ])\n    }\n}\n\nextension View {\n    func inputAccessoryView<Content: View>(@ViewBuilder content: @escaping () -> Content) -> some View {\n        introspectTextField { td in\n            let viewController = UIHostingController(rootView: content())\n            viewController.view.constrainEdges(to: viewController.view)\n            td.inputAccessoryView = viewController.view\n        }\n    }\n    func inputAccessoryView<Content: View>(content: Content) -> some View {\n        introspectTextField { td in\n            let viewController = UIHostingController(rootView: content)\n            viewController.view.constrainEdges(to: viewController.view)\n            td.inputAccessoryView = viewController.view\n        }\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n사용법:\n\n```js\nstruct OnFocusDemo: View {\n    @FocusState var focus: FocusedField?\n    @State var name = \"\"\n    @State var email = \"\"\n    @State var phoneNumber = \"\"\n    var body: some View {\n        Form {\n            TextField(\"이름:\", text: $name)\n                .focused($focus, equals: .name)\n                .inputAccessoryView(content: accessoryView(focus: .name))\n\n            TextField(\"이메일:\", text: $email)\n                .focused($focus, equals: .email)\n                .inputAccessoryView(content: accessoryView(focus: .email))\n\n            TextField(\"전화번호:\", text: $phoneNumber)\n                .focused($focus, equals: .phone)\n        }\n        .onSubmit {\n            switch focus {\n            case .name:\n                focus = .email\n            case .email:\n                focus = .phone\n            case .phone:\n                if !name.isEmpty, !email.isEmpty, !phoneNumber.isEmpty {}\n            default:\n                break\n            }\n        }\n    }\n}\n\nstruct accessoryView: View {\n    let focus: FocusedField?\n    var body: some View {\n        switch focus {\n        case .name:\n            Button(\"이름\") {}.padding(.vertical, 10)\n        case .email:\n            Button(\"이메일\") {}.padding(.vertical, 10)\n        default:\n            EmptyView()\n        }\n    }\n}\n```\n\n# 사용자 정의 제출 레이블\n\n기본적으로 TextField (SecureField)의 키보드에 대한 제출 동작 버튼은 \"return\"입니다. SwiftUI 3.0에서 소개된 \"submitLabel\" 수정자를 사용하면 \"return\" 버튼을 입력 콘텍스트와 관련된 텍스트로 수정할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```swift\nTextField(\"사용자 이름\", text: $username)\n            .submitLabel(.next)\n```\n\n<img src=\"/assets/img/2024-06-23-AdvancedSwiftUITextFieldEventsFocusKeyboard_4.png\" />\n\n현재 지원되는 유형은 다음과 같습니다:\n\n- continue\n- done\n- go\n- join\n- next\n- return\n- route\n- search\n- send\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n예를 들어, 이전 코드에서는 이름, 이메일 및 전화번호에 대한 서로 다른 표시를 설정할 수 있습니다:\n\n```js\nTextField(\"이름:\", text: $name)\n                .focused($focus, equals: .name)\n                .submitLabel(.next)\nTextField(\"이메일:\", text: $email)\n                .focused($focus, equals: .email)\n                .submitLabel(.next)\n\nTextField(\"전화번호:\", text: $phoneNumber)\n                .focused($focus, equals: .phone)\n                .submitLabel(.return)\n```\n\n# 결론\n\nSwiftUI 1.0부터 Apple은 TextField의 기능을 지속적으로 개선해 왔습니다. 버전 3.0에서 SwiftUI는 더 많은 네이티브 수정자를 제공하는데 그치지 않고 FocusState와 onSubmit과 같은 통합 관리 논리를 제공합니다. 믿음직스러운 2~3년 뒤에는 SwiftUI의 주요 컨트롤의 네이티브 기능이 해당하는 UIKit 컨트롤과 맞먹을 것이라고 믿습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만약 이 글이 도움이 되었거나 즐겁게 읽으셨다면, 제 글을 지원하기 위해 기부를 고려해 주세요. 여러분의 기부는 저가 계속해서 가치 있는 콘텐츠를 만드는데 도움이 될 것입니다.\nPatreon, Buy Me a Coffee 또는 PayPal을 통해 기부할 수 있습니다.\n\n```js\n연락하고 싶다면?\n\nTwitter에서 @fatbobman을 팔로우하세요.\n```\n","ogImage":{"url":"/assets/img/2024-06-23-AdvancedSwiftUITextFieldEventsFocusKeyboard_0.png"},"coverImage":"/assets/img/2024-06-23-AdvancedSwiftUITextFieldEventsFocusKeyboard_0.png","tag":["Tech"],"readingTime":36},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p>이 글은 SwiftUI TextField 이벤트, 포커스 전환, 키보드 설정 및 기타 관련 경험, 기술 및 고려 사항을 탐색할 것입니다.</p>\n<h2>이벤트</h2>\n<h3>onEditingChanged</h3>\n<p>TextField가 포커스를 얻을 때(편집 가능한 상태로 전환될 때), onEditingChanged는 주어진 메서드를 호출하고 값으로 true를 전달합니다. TextField가 포커스를 잃을 때, 다시 메서드를 호출하고 값을 false로 전달합니다.</p>\n<p></p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">OnEditingChangedDemo</span>: <span class=\"hljs-title class_\">View</span> {\n    <span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">var</span> name <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">\"\"</span>\n\n    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> {\n        <span class=\"hljs-type\">List</span> {\n            <span class=\"hljs-type\">TextField</span>(<span class=\"hljs-string\">\"이름:\"</span>, text: <span class=\"hljs-variable\">$name</span>, onEditingChanged: getFocus)\n        }\n    }\n\n    <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">getFocus</span>(<span class=\"hljs-params\">focused</span>: <span class=\"hljs-type\">Bool</span>) {\n        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"포커스 받음: <span class=\"hljs-subst\">\\(focused <span class=\"hljs-operator\">?</span> <span class=\"hljs-string\">\"참\"</span> : <span class=\"hljs-string\">\"거짓\"</span>)</span>\"</span>)\n    }\n}\n</code></pre>\n<p>이 매개변수의 이름은 사용자에게 모호함을 초래하기 쉽습니다. 사용자가 콘텐츠를 입력했는지 확인하는 데 onEditingChanged를 사용하지 마십시오.</p>\n<p>iOS 15에서는 ParseableFormatStyle을 지원하는 새로 추가된 생성자에서 이 매개변수를 제공하지 않습니다. 따라서 새로운 Formatter를 사용하는 TextFields의 경우, 포커스를 얻었는지 또는 상실했는지를 확인하기 위해 다른 수단을 사용해야 합니다.</p>\n<h1>onCommit</h1>\n<p></p>\n<p>onCommit은 사용자가 입력하는 중에 리턴 키를 누를 때 (또는 클릭할 때) 트리거됩니다 (코드 시뮬레이션으로는 트리거할 수 없음). 사용자가 리턴 키를 클릭하지 않으면(예: 직접 다른 TextField로 전환하는 경우) onCommit은 트리거되지 않습니다. onCommit이 트리거되는 동시에 TextField는 포커스를 잃게 됩니다.</p>\n<pre><code class=\"hljs language-js\">struct <span class=\"hljs-title class_\">OnCommitDemo</span>: <span class=\"hljs-title class_\">View</span> {\n    @<span class=\"hljs-title class_\">State</span> <span class=\"hljs-keyword\">var</span> name = <span class=\"hljs-string\">\"\"</span>\n    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">body</span>: some <span class=\"hljs-title class_\">View</span> {\n        <span class=\"hljs-title class_\">List</span> {\n            <span class=\"hljs-title class_\">TextField</span>(<span class=\"hljs-string\">\"이름:\"</span>, <span class=\"hljs-attr\">text</span>: $name, <span class=\"hljs-attr\">onCommit</span>: { <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">\"커밋\"</span>) })\n        }\n    }\n}\n</code></pre>\n<p>사용자가 입력한 내용을 확인해야 하는 경우, onCommit과 onEditingChanged를 함께 사용하는 것이 좋습니다. 사용자의 입력 데이터를 실시간으로 처리하려면 SwiftUI TextField 고급 — 형식 지정 및 유효성 검사를 참고해주세요.</p>\n<p>onCommit은 SecureField에도 적용됩니다.</p>\n<p></p>\n<p>iOS 15에서 추가된 ParseableFormatStyle을 지원하는 새 생성자는 해당 매개변수를 제공하지 않습니다. 동일한 효과를 얻으려면 새롭게 추가된 onSubmit을 사용할 수 있습니다.</p>\n<h1>onSubmit</h1>\n<p>onSubmit은 SwiftUI 3.0에서 새로 추가된 기능입니다. onCommit 및 onEditingChanged는 각각의 TextField의 상태를 설명하지만 onSubmit은 한 뷰 내에서 여러 TextField의 통합 관리 및 일정 관리를 가능하게 합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// onSubmit의 정의</span>\nextension <span class=\"hljs-title class_\">View</span> {\n    public func <span class=\"hljs-title function_\">onSubmit</span>(<span class=\"hljs-keyword\">of</span> <span class=\"hljs-attr\">triggers</span>: <span class=\"hljs-title class_\">SubmitTriggers</span> = .<span class=\"hljs-property\">text</span>, _ <span class=\"hljs-attr\">action</span>: @escaping (() -> <span class=\"hljs-title class_\">Void</span>)) -> some <span class=\"hljs-title class_\">View</span>\n}\n</code></pre>\n<p></p>\n<p>아래 코드는 onCommit과 동일한 동작을 구현할 것입니다:</p>\n<pre><code class=\"hljs language-js\">struct <span class=\"hljs-title class_\">OnSubmitDemo</span>:<span class=\"hljs-title class_\">View</span>{\n    @<span class=\"hljs-title class_\">State</span> <span class=\"hljs-keyword\">var</span> name = <span class=\"hljs-string\">\"\"</span>\n    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">body</span>: some <span class=\"hljs-title class_\">View</span>{\n        <span class=\"hljs-title class_\">List</span>{\n            <span class=\"hljs-title class_\">TextField</span>(<span class=\"hljs-string\">\"name:\"</span>,<span class=\"hljs-attr\">text</span>: $name)\n                .<span class=\"hljs-property\">onSubmit</span> {\n                    <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">\"commit\"</span>)\n                }\n        }\n    }\n}\n</code></pre>\n<p>onSubmit의 트리거 조건은 onCommit과 동일하며, 사용자가 “return”을 활성화하도록 요구합니다.</p>\n<p>onSubmit은 SecureField에도 적용됩니다.</p>\n<p></p>\n<h1>범위와 중첩</h1>\n<p>onSubmit의 구현은 환경 값 TriggerSubmitAction을 설정하는 것에 기반하며 (아직 개발자에게 제공되지 않음) onSubmit은 범위를 가지고 있으며 (뷰 트리로 전달될 수 있음) 중첩될 수 있습니다.</p>\n<pre><code class=\"hljs language-js\">struct <span class=\"hljs-title class_\">OnSubmitDemo</span>: <span class=\"hljs-title class_\">View</span> {\n    @<span class=\"hljs-title class_\">State</span> <span class=\"hljs-keyword\">var</span> text1 = <span class=\"hljs-string\">\"\"</span>\n    @<span class=\"hljs-title class_\">State</span> <span class=\"hljs-keyword\">var</span> text2 = <span class=\"hljs-string\">\"\"</span>\n    @<span class=\"hljs-title class_\">State</span> <span class=\"hljs-keyword\">var</span> text3 = <span class=\"hljs-string\">\"\"</span>\n    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">body</span>: some <span class=\"hljs-title class_\">View</span> {\n        <span class=\"hljs-title class_\">Form</span> {\n            <span class=\"hljs-title class_\">Group</span> {\n                <span class=\"hljs-title class_\">TextField</span>(<span class=\"hljs-string\">\"text1\"</span>, <span class=\"hljs-attr\">text</span>: $text1)\n                    .<span class=\"hljs-property\">onSubmit</span> { <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">\"text1 commit\"</span>) }\n                <span class=\"hljs-title class_\">TextField</span>(<span class=\"hljs-string\">\"text2\"</span>, <span class=\"hljs-attr\">text</span>: $text2)\n                    .<span class=\"hljs-property\">onSubmit</span> { <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">\"text2 commit\"</span>) }\n            }\n            .<span class=\"hljs-property\">onSubmit</span> { <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">\"textfield in group commit\"</span>) }\n            <span class=\"hljs-title class_\">TextField</span>(<span class=\"hljs-string\">\"text3\"</span>, <span class=\"hljs-attr\">text</span>: $text3)\n                .<span class=\"hljs-property\">onSubmit</span> { <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">\"text3 commit\"</span>) }\n        }\n        .<span class=\"hljs-property\">onSubmit</span> { <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">\"textfield in form commit1\"</span>) }\n        .<span class=\"hljs-property\">onSubmit</span> { <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">\"textfield in form commit2\"</span>) }\n    }\n}\n</code></pre>\n<p>TextField (text1)이 commit되면, 콘솔 출력은 다음과 같습니다:</p>\n<p></p>\n<pre><code class=\"hljs language-js\">양식에서의 텍스트 필드 커밋<span class=\"hljs-number\">2</span>\n양식에서의 텍스트 필드 커밋<span class=\"hljs-number\">1</span>\n그룹에서의 텍스트 필드 커밋\n텍스트<span class=\"hljs-number\">1</span> 커밋\n</code></pre>\n<p>외부에서 내부로 호출 순서임을 참고하십시오.</p>\n<h1>제한된 범위</h1>\n<p>submitScope를 사용하여 범위를 차단하고 (뷰 트리 상에서의 추가 전파를 제한합니다). 예를 들어, 위 코드에서는 그룹 뒤에 submitScope를 추가하십시오.</p>\n<p></p>\n<pre><code class=\"hljs language-js\">그룹 {\n    <span class=\"hljs-title class_\">TextField</span>(<span class=\"hljs-string\">\"text1\"</span>, <span class=\"hljs-attr\">text</span>: $text1)\n        .<span class=\"hljs-property\">onSubmit</span> { <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">\"text1 commit\"</span>) }\n    <span class=\"hljs-title class_\">TextField</span>(<span class=\"hljs-string\">\"text2\"</span>, <span class=\"hljs-attr\">text</span>: $text2)\n        .<span class=\"hljs-property\">onSubmit</span> { <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">\"text2 commit\"</span>) }\n}\n.<span class=\"hljs-title function_\">submitScope</span>()  <span class=\"hljs-comment\">// scope blocking</span>\n.<span class=\"hljs-property\">onSubmit</span> { <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">\"textfield in group commit\"</span>) }\n</code></pre>\n<p>TextField1이 커밋되면 콘솔에 다음이 표시됩니다:</p>\n<pre><code class=\"hljs language-js\">text1 commit\n</code></pre>\n<p>이 시점에서 onSubmit의 범위는 그룹 내로 제한됩니다.</p>\n<p></p>\n<p>뷰에 여러 개의 TextFields가 있는 경우, onSubmit과 FocusState를 결합하여 훌륭한 사용자 경험을 얻을 수 있습니다.</p>\n<h1>searchable 지원</h1>\n<p>iOS 15에서는 새로운 검색 상자도 \"return\"을 클릭할 때 onSubmit을 트리거하지만, 트리거를 검색으로 설정해야 합니다:</p>\n<pre><code class=\"hljs language-js\">struct <span class=\"hljs-title class_\">OnSubmitForSearchableDemo</span>:<span class=\"hljs-title class_\">View</span>{\n    @<span class=\"hljs-title class_\">State</span> <span class=\"hljs-keyword\">var</span> name = <span class=\"hljs-string\">\"\"</span>\n    @<span class=\"hljs-title class_\">State</span> <span class=\"hljs-keyword\">var</span> searchText = <span class=\"hljs-string\">\"\"</span>\n    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">body</span>: some <span class=\"hljs-title class_\">View</span>{\n        <span class=\"hljs-title class_\">NavigationView</span>{\n            <span class=\"hljs-title class_\">Form</span>{\n                <span class=\"hljs-title class_\">TextField</span>(<span class=\"hljs-string\">\"이름:\"</span>,<span class=\"hljs-attr\">text</span>:$name)\n                    .<span class=\"hljs-property\">onSubmit</span> {<span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">\"textField 커밋\"</span>)}\n            }\n            .<span class=\"hljs-title function_\">searchable</span>(<span class=\"hljs-attr\">text</span>: $searchText)\n            .<span class=\"hljs-title function_\">onSubmit</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">of</span>: .search</span>) { <span class=\"hljs-comment\">//</span>\n                <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">\"searchField 커밋\"</span>)\n            }\n        }\n    }\n}\n</code></pre>\n<p></p>\n<p>SubmitTriggers의 타입은 OptionSet입니다. onSubmit 메서드는 환경 내에서 뷰 트리에서 SubmitTriggers에 포함된 값을 계속 전달합니다. onSubmit에서 받는 SubmitTriggers 값이 onSubmit에서 지정된 SubmitTriggers 세트에 포함되지 않으면 전달이 종료됩니다. 간단히 말해, onSubmit(of:.search)은 TextField에서 생성된 커밋 상태를 차단하고 그 반대도 마찬가지입니다.</p>\n<p>예를 들어, 위 코드에서 searchable 다음에 onSubmt(of:.text)를 추가하면 TextField의 커밋 이벤트에 응답할 수 없게 됩니다.</p>\n<pre><code class=\"hljs language-js\">.<span class=\"hljs-title function_\">searchable</span>(<span class=\"hljs-attr\">text</span>: $searchText)\n            .<span class=\"hljs-title function_\">onSubmit</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">of</span>: .search</span>) {\n                <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">\"searchField commit1\"</span>)\n            }\n            .<span class=\"hljs-property\">onSubmit</span> {<span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">\"textField commit\"</span>)} <span class=\"hljs-comment\">//cannot be triggered, blocked by search</span>\n</code></pre>\n<p>따라서 TextField와 검색 상자를 모두 처리할 때 호출 순서에 특별히 주의해야 합니다.</p>\n<p></p>\n<p>다음 코드는 하나의 onSubmit에서 TextField와 검색 상자를 모두 지원할 수 있습니다:</p>\n<pre><code class=\"hljs language-js\">.<span class=\"hljs-title function_\">onSubmit</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">of</span>: [.text, .search]</span>) {\n  <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">\"무언가가 제출되었습니다\"</span>)\n}\n</code></pre>\n<p>다음 코드는 searchable 보다 onSubmit(of:.search)가 먼저 배치되어 있기 때문에 어느 것도 트리거하지 않습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title class_\">NavigationView</span>{\n    <span class=\"hljs-title class_\">Form</span>{\n        <span class=\"hljs-title class_\">TextField</span>(<span class=\"hljs-string\">\"이름:\"</span>, <span class=\"hljs-attr\">text</span>: $name)\n            .<span class=\"hljs-property\">onSubmit</span> {<span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">\"textField 제출\"</span>)}\n    }\n    .<span class=\"hljs-title function_\">onSubmit</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">of</span>: .search</span>) { <span class=\"hljs-comment\">// 트리거 안 됨</span>\n        <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">\"searchField 제출1\"</span>)\n    }\n    .<span class=\"hljs-title function_\">searchable</span>(<span class=\"hljs-attr\">text</span>: $searchText)\n}\n</code></pre>\n<p></p>\n<h1>초점</h1>\n<p>iOS 15(몬테레이) 이전에는 SwiftUI에서 TextField(예 : becomeFirstResponder)에 초점을 맞추는 방법을 제공하지 않았습니다. 오랫동안 개발자들은 비슈위 방법에 의존하여 비슷한 기능을 구현해야 했습니다.</p>\n<p>SwiftUI 3.0에서 Apple은 개발자들에게 onSubmit과 유사한, 높은 수준의 뷰 계층 구조에서 텍스트 필드의 초점을 일관되게 결정하고 관리할 수 있는 예상보다 훨씬 더 나은 솔루션을 제공했습니다.</p>\n<h1>기본 사용법</h1>\n<p></p>\n<p>SwiftUI에서는 새 FocusState 프로퍼티 래퍼를 제공하여이 뷰 내의 TextField에 포커스가 있는지 여부를 결정하는 데 도움을 줍니다. focused를 사용하여 FocusState를 특정 TextField와 연결할 수 있습니다.</p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">OnFocusDemo</span>: <span class=\"hljs-title class_\">View</span> {\n    <span class=\"hljs-meta\">@FocusState</span> <span class=\"hljs-keyword\">var</span> isNameFocused: <span class=\"hljs-type\">Bool</span>\n    <span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">var</span> name <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">\"\"</span>\n\n    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> {\n        <span class=\"hljs-type\">List</span> {\n            <span class=\"hljs-type\">TextField</span>(<span class=\"hljs-string\">\"이름:\"</span>, text: <span class=\"hljs-variable\">$name</span>)\n                .focused(<span class=\"hljs-variable\">$isNameFocused</span>)\n        }\n        .onChange(of: isNameFocused) { value <span class=\"hljs-keyword\">in</span>\n            <span class=\"hljs-built_in\">print</span>(value)\n        }\n    }\n}\n</code></pre>\n<p>위 코드는 TextField가 포커스를 얻을 때 isNameFocused를 true로 설정하고 포커스를 잃을 때 false로 설정합니다.</p>\n<p>동일한 뷰 내에 여러 개의 TextField가있는 경우 각 해당 TextField와 연결할 여러 FocusStates를 생성할 수 있습니다. 예를 들어:</p>\n<p></p>\n<p>위의 방법은 뷰에 더 많은 TextField가 있는 경우 귀찮아지고 통일된 관리에 도움이 되지 않습니다. 다행히 FocusState는 Boolean 값뿐만 아니라 모든 해시 타입도 지원합니다. Hashable 프로토콜을 준수하는 enum을 사용하여 뷰 내 여러 TextField의 포커스를 관리할 수 있습니다. 다음 코드는 위의 코드와 동일한 기능을 수행합니다:</p>\n<pre><code class=\"hljs language-js\">struct <span class=\"hljs-title class_\">OnFocusDemo</span>:<span class=\"hljs-title class_\">View</span>{\n    @<span class=\"hljs-title class_\">FocusState</span> <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">focus</span>:<span class=\"hljs-title class_\">FocusedField</span>?\n    @<span class=\"hljs-title class_\">State</span> <span class=\"hljs-keyword\">var</span> name = <span class=\"hljs-string\">\"\"</span>\n    @<span class=\"hljs-title class_\">State</span> <span class=\"hljs-keyword\">var</span> password = <span class=\"hljs-string\">\"\"</span>\n    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">body</span>: some <span class=\"hljs-title class_\">View</span>{\n        <span class=\"hljs-title class_\">List</span>{\n            <span class=\"hljs-title class_\">TextField</span>(<span class=\"hljs-string\">\"name:\"</span>,<span class=\"hljs-attr\">text</span>:$name)\n                .<span class=\"hljs-title function_\">focused</span>($focus, <span class=\"hljs-attr\">equals</span>: .<span class=\"hljs-property\">name</span>)\n            <span class=\"hljs-title class_\">SecureField</span>(<span class=\"hljs-string\">\"password:\"</span>,<span class=\"hljs-attr\">text</span>:$password)\n                .<span class=\"hljs-title function_\">focused</span>($focus,<span class=\"hljs-attr\">equals</span>: .<span class=\"hljs-property\">password</span>)\n        }\n        .<span class=\"hljs-title function_\">onChange</span>(<span class=\"hljs-attr\">of</span>: focus, <span class=\"hljs-attr\">perform</span>: {<span class=\"hljs-title function_\">print</span>($0)})\n    }\n\n    enum <span class=\"hljs-title class_\">FocusedField</span>:<span class=\"hljs-title class_\">Hashable</span>{\n        <span class=\"hljs-keyword\">case</span> name,password\n    }\n}\n</code></pre>\n<h1>특정 TextField가 뷰를 표시한 직후에 즉시 포커스를 받도록 만들기</h1>\n<p></p>\n<p>FocusState를 사용하면 지정된 TextField가 포커스를 얻고 뷰를 표시한 후 즉시 키보드가 팝업되게 할 수 있어요:</p>\n<pre><code class=\"hljs language-js\">struct <span class=\"hljs-title class_\">OnFocusDemo</span>: <span class=\"hljs-title class_\">View</span> {\n    @<span class=\"hljs-title class_\">FocusState</span> <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">focus</span>: <span class=\"hljs-title class_\">FocusedField</span>?\n    @<span class=\"hljs-title class_\">State</span> <span class=\"hljs-keyword\">var</span> name = <span class=\"hljs-string\">\"\"</span>\n    @<span class=\"hljs-title class_\">State</span> <span class=\"hljs-keyword\">var</span> password = <span class=\"hljs-string\">\"\"</span>\n\n    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">body</span>: some <span class=\"hljs-title class_\">View</span> {\n        <span class=\"hljs-title class_\">List</span> {\n            <span class=\"hljs-title class_\">TextField</span>(<span class=\"hljs-string\">\"이름:\"</span>, <span class=\"hljs-attr\">text</span>: $name)\n                .<span class=\"hljs-title function_\">focused</span>($focus, <span class=\"hljs-attr\">equals</span>: .<span class=\"hljs-property\">name</span>)\n            <span class=\"hljs-title class_\">SecureField</span>(<span class=\"hljs-string\">\"비밀번호:\"</span>, <span class=\"hljs-attr\">text</span>: $password)\n                .<span class=\"hljs-title function_\">focused</span>($focus, <span class=\"hljs-attr\">equals</span>: .<span class=\"hljs-property\">password</span>)\n        }\n        .<span class=\"hljs-property\">onAppear</span> {\n            <span class=\"hljs-title class_\">DispatchQueue</span>.<span class=\"hljs-property\">main</span>.<span class=\"hljs-title function_\">asyncAfter</span>(<span class=\"hljs-params\">deadline: .now() + <span class=\"hljs-number\">0.5</span></span>) {\n                focus = .<span class=\"hljs-property\">name</span>\n            }\n        }\n    }\n\n    enum <span class=\"hljs-title class_\">FocusedField</span>: <span class=\"hljs-title class_\">Hashable</span> {\n        <span class=\"hljs-keyword\">case</span> name, password\n    }\n}\n</code></pre>\n<p>뷰 초기화 중에 값을 할당하는 것은 잘못된 방법이에요. onAppear에서도 TextField가 포커스를 얻을 시간을 지연시켜야 해요 (iOS 16에서는 지연이 필요하지 않아요).</p>\n<h1>여러 개의 TextField 사이에서 포커스 전환하기</h1>\n<p></p>\n<p>주의력과 onSubmit을 결합하여 한 TextField에서 입력을 완료하고(리턴을 클릭할 때) 자동으로 다음 TextField로 포커스를 전환하는 효과를 얻을 수 있어요.</p>\n<pre><code class=\"hljs language-js\">struct <span class=\"hljs-title class_\">OnFocusDemo</span>:<span class=\"hljs-title class_\">View</span>{\n    @<span class=\"hljs-title class_\">FocusState</span> <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">focus</span>:<span class=\"hljs-title class_\">FocusedField</span>?\n    @<span class=\"hljs-title class_\">State</span> <span class=\"hljs-keyword\">var</span> name = <span class=\"hljs-string\">\"\"</span>\n    @<span class=\"hljs-title class_\">State</span> <span class=\"hljs-keyword\">var</span> email = <span class=\"hljs-string\">\"\"</span>\n    @<span class=\"hljs-title class_\">State</span> <span class=\"hljs-keyword\">var</span> phoneNumber = <span class=\"hljs-string\">\"\"</span>\n    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">body</span>: some <span class=\"hljs-title class_\">View</span>{\n        <span class=\"hljs-title class_\">List</span>{\n            <span class=\"hljs-title class_\">TextField</span>(<span class=\"hljs-string\">\"이름:\"</span>,<span class=\"hljs-attr\">text</span>:$name)\n                .<span class=\"hljs-title function_\">focused</span>($focus, <span class=\"hljs-attr\">equals</span>: .<span class=\"hljs-property\">name</span>)\n                .<span class=\"hljs-property\">onSubmit</span> {\n                    focus = .<span class=\"hljs-property\">email</span>\n                }\n            <span class=\"hljs-title class_\">TextField</span>(<span class=\"hljs-string\">\"이메일:\"</span>,<span class=\"hljs-attr\">text</span>:$email)\n                .<span class=\"hljs-title function_\">focused</span>($focus,<span class=\"hljs-attr\">equals</span>: .<span class=\"hljs-property\">email</span>)\n                .<span class=\"hljs-property\">onSubmit</span> {\n                    focus = .<span class=\"hljs-property\">phone</span>\n                }\n            <span class=\"hljs-title class_\">TextField</span>(<span class=\"hljs-string\">\"전화번호:\"</span>,<span class=\"hljs-attr\">text</span>:$phoneNumber)\n                .<span class=\"hljs-title function_\">focused</span>($focus, <span class=\"hljs-attr\">equals</span>: .<span class=\"hljs-property\">phone</span>)\n                .<span class=\"hljs-property\">onSubmit</span> {\n                    <span class=\"hljs-keyword\">if</span> !name.<span class=\"hljs-property\">isEmpty</span> &#x26;&#x26; !email.<span class=\"hljs-property\">isEmpty</span> &#x26;&#x26; !phoneNumber.<span class=\"hljs-property\">isEmpty</span> {\n                        <span class=\"hljs-title function_\">submit</span>()\n                    }\n                }\n        }\n    }\n\n    private func <span class=\"hljs-title function_\">submit</span>(<span class=\"hljs-params\"></span>){\n        <span class=\"hljs-comment\">// 모든 정보 제출</span>\n        <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">\"제출\"</span>)\n    }\n    enum <span class=\"hljs-title class_\">FocusedField</span>:<span class=\"hljs-title class_\">Hashable</span>{\n        <span class=\"hljs-keyword\">case</span> name,email,phone\n    }\n}\n</code></pre>\n<p>위의 코드는 onSubmit 전달 기능을 활용하여 다음과 같이 변환될 수도 있어요:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title class_\">List</span> {\n    <span class=\"hljs-title class_\">TextField</span>(<span class=\"hljs-string\">\"이름:\"</span>, <span class=\"hljs-attr\">text</span>: $name)\n        .<span class=\"hljs-title function_\">focused</span>($focus, <span class=\"hljs-attr\">equals</span>: .<span class=\"hljs-property\">name</span>)\n    <span class=\"hljs-title class_\">TextField</span>(<span class=\"hljs-string\">\"이메일:\"</span>, <span class=\"hljs-attr\">text</span>: $email)\n        .<span class=\"hljs-title function_\">focused</span>($focus, <span class=\"hljs-attr\">equals</span>: .<span class=\"hljs-property\">email</span>)\n    <span class=\"hljs-title class_\">TextField</span>(<span class=\"hljs-string\">\"전화번호:\"</span>, <span class=\"hljs-attr\">text</span>: $phoneNumber)\n        .<span class=\"hljs-title function_\">focused</span>($focus, <span class=\"hljs-attr\">equals</span>: .<span class=\"hljs-property\">phone</span>)\n}\n.<span class=\"hljs-property\">onSubmit</span> {\n    <span class=\"hljs-keyword\">switch</span> focus {\n    <span class=\"hljs-keyword\">case</span> .<span class=\"hljs-property\">name</span>:\n        focus = .<span class=\"hljs-property\">email</span>\n    <span class=\"hljs-keyword\">case</span> .<span class=\"hljs-property\">email</span>:\n        focus = .<span class=\"hljs-property\">phone</span>\n    <span class=\"hljs-keyword\">case</span> .<span class=\"hljs-property\">phone</span>:\n        <span class=\"hljs-keyword\">if</span> !name.<span class=\"hljs-property\">isEmpty</span>, !email.<span class=\"hljs-property\">isEmpty</span>, !phoneNumber.<span class=\"hljs-property\">isEmpty</span> {\n            <span class=\"hljs-title function_\">submit</span>()\n        }\n    <span class=\"hljs-attr\">default</span>:\n        <span class=\"hljs-keyword\">break</span>\n    }\n}\n</code></pre>\n<p></p>\n<p>화면 버튼(예: 보조 키보드 보기) 또는 키보드 단축키를 결합하여 포커스를 전환하거나 특정 TextField로 이동할 수도 있습니다.</p>\n<h1>포커스를 얻기 위한 키보드 단축키 사용</h1>\n<p>보안 필드를 포함한 여러 개의 TextField가 있는 뷰에서는 Tab 키를 사용하여 TextField에서 포커스를 직접 전환할 수 있습니다. 그러나 SwiftUI는 키보드 단축키를 사용하여 특정 TextField에 포커스를 설정하는 기능을 직접 제공하지 않습니다. FocusState와 keyboardShortcut을 결합하여 iPad 및 MacOS에서 이 기능을 얻을 수 있습니다.</p>\n<p>키보드 단축키 바인딩을 지원하는 focused를 생성하세요:</p>\n<p></p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">extension</span> <span class=\"hljs-title class_\">View</span> {\n    <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">focused</span>(<span class=\"hljs-keyword\">_</span> <span class=\"hljs-params\">condition</span>: <span class=\"hljs-type\">FocusState</span>&#x3C;<span class=\"hljs-type\">Bool</span>>.<span class=\"hljs-type\">Binding</span>, <span class=\"hljs-params\">key</span>: <span class=\"hljs-type\">KeyEquivalent</span>, <span class=\"hljs-params\">modifiers</span>: <span class=\"hljs-type\">EventModifiers</span> <span class=\"hljs-operator\">=</span> .command) -> <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> {\n        focused(condition)\n            .background(<span class=\"hljs-type\">Button</span>(<span class=\"hljs-string\">\"\"</span>) {\n                condition.wrappedValue <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">true</span>\n            }\n            .keyboardShortcut(key, modifiers: modifiers)\n            .hidden()\n            )\n    }\n\n    <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">focused</span>&#x3C;<span class=\"hljs-type\">Value</span>>(<span class=\"hljs-keyword\">_</span> <span class=\"hljs-params\">binding</span>: <span class=\"hljs-type\">FocusState</span>&#x3C;<span class=\"hljs-type\">Value</span>>.<span class=\"hljs-type\">Binding</span>, <span class=\"hljs-params\">equals</span> <span class=\"hljs-params\">value</span>: <span class=\"hljs-type\">Value</span>, <span class=\"hljs-params\">key</span>: <span class=\"hljs-type\">KeyEquivalent</span>, <span class=\"hljs-params\">modifiers</span>: <span class=\"hljs-type\">EventModifiers</span> <span class=\"hljs-operator\">=</span> .command) -> <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> <span class=\"hljs-keyword\">where</span> <span class=\"hljs-type\">Value</span>: <span class=\"hljs-type\">Hashable</span> {\n        focused(binding, equals: value)\n            .background(<span class=\"hljs-type\">Button</span>(<span class=\"hljs-string\">\"\"</span>) {\n                binding.wrappedValue <span class=\"hljs-operator\">=</span> value\n            }\n            .keyboardShortcut(key, modifiers: modifiers)\n            .hidden()\n            )\n    }\n}\n</code></pre>\n<p>코드 사용법:</p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ShortcutFocusDemo</span>: <span class=\"hljs-title class_\">View</span> {\n    <span class=\"hljs-meta\">@FocusState</span> <span class=\"hljs-keyword\">var</span> focus: <span class=\"hljs-type\">FouceField</span>?\n    <span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> email <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">\"\"</span>\n    <span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> address <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">\"\"</span>\n    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> {\n        <span class=\"hljs-type\">Form</span> {\n            <span class=\"hljs-type\">TextField</span>(<span class=\"hljs-string\">\"이메일\"</span>, text: <span class=\"hljs-variable\">$email</span>)\n                .focused(<span class=\"hljs-variable\">$focus</span>, equals: .email, key: <span class=\"hljs-string\">\"t\"</span>)\n            <span class=\"hljs-type\">TextField</span>(<span class=\"hljs-string\">\"주소\"</span>, text: <span class=\"hljs-variable\">$address</span>)\n                .focused(<span class=\"hljs-variable\">$focus</span>, equals: .address, key: <span class=\"hljs-string\">\"a\"</span>, modifiers: [.command, .shift, .option])\n        }\n    }\n\n    <span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title class_\">FouceField</span>: <span class=\"hljs-title class_\">Hashable</span> {\n        <span class=\"hljs-keyword\">case</span> email\n        <span class=\"hljs-keyword\">case</span> address\n    }\n}\n</code></pre>\n<p>사용자가 ⌘ + T를 입력하면 이메일을 처리하는 TextField에 초점이 맞춰집니다. 사용자가 ⌘ + ⌥ + ⇧ + A를 입력하면 주소를 처리하는 TextField에 초점이 맞춰집니다.</p>\n<p></p>\n<h1>자체 onEditingChanged 만들기</h1>\n<p>개별 TextField의 포커스 상태를 확인하는 가장 좋은 방법은 여전히 onEditingChanged를 사용하는 것입니다. 그러나 새 포매터와 같이 onEditingChanged를 사용할 수 없는 경우에는 FocusState를 사용하여 비슷한 효과를 얻을 수 있습니다.</p>\n<ul>\n<li>개별 TextField의 포커스 상태 확인</li>\n</ul>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">extension</span> <span class=\"hljs-title class_\">View</span> {\n    <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">focused</span>(<span class=\"hljs-keyword\">_</span> <span class=\"hljs-params\">condition</span>: <span class=\"hljs-type\">FocusState</span>&#x3C;<span class=\"hljs-type\">Bool</span>>.<span class=\"hljs-type\">Binding</span>, <span class=\"hljs-params\">onFocus</span>: <span class=\"hljs-keyword\">@escaping</span> (<span class=\"hljs-type\">Bool</span>) -> <span class=\"hljs-type\">Void</span>) -> <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> {\n        focused(condition)\n            .onChange(of: condition.wrappedValue) { value <span class=\"hljs-keyword\">in</span>\n                onFocus(value <span class=\"hljs-operator\">==</span> <span class=\"hljs-literal\">true</span>)\n            }\n    }\n}\n</code></pre>\n<p></p>\n<p>사용 방법:</p>\n<pre><code class=\"hljs language-js\">struct <span class=\"hljs-attr\">onEditingChangedFocusVersion</span>:<span class=\"hljs-title class_\">View</span>{\n    @<span class=\"hljs-title class_\">FocusState</span> <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">focus</span>:<span class=\"hljs-title class_\">Bool</span>\n    @<span class=\"hljs-title class_\">State</span> <span class=\"hljs-keyword\">var</span> price = <span class=\"hljs-number\">0</span>\n    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">body</span>: some <span class=\"hljs-title class_\">View</span>{\n        <span class=\"hljs-title class_\">Form</span>{\n            <span class=\"hljs-title class_\">TextField</span>(<span class=\"hljs-string\">\"가격:\"</span>,<span class=\"hljs-attr\">value</span>:$price,<span class=\"hljs-attr\">format</span>: .<span class=\"hljs-property\">number</span>)\n                .<span class=\"hljs-title function_\">focused</span>(<span class=\"hljs-params\">$focus</span>){ focused <span class=\"hljs-keyword\">in</span>\n                    <span class=\"hljs-title function_\">print</span>(focused)\n                }\n        }\n    }\n}\n</code></pre>\n<ul>\n<li>여러 TextFields 확인</li>\n</ul>\n<p>TextField가 포커스를 잃을 때 여러 번 호출을 피하기 위해 뷰 계층 구조에서 마지막 포커스된 TextField의 FocusState 값을 저장해야 합니다.</p>\n<p></p>\n<pre><code class=\"hljs language-js\">public extension <span class=\"hljs-title class_\">View</span> {\n    func storeLastFocus&#x3C;<span class=\"hljs-title class_\">Value</span>: <span class=\"hljs-title class_\">Hashable</span>>(<span class=\"hljs-attr\">current</span>: <span class=\"hljs-title class_\">FocusState</span>&#x3C;<span class=\"hljs-title class_\">Value</span>?>.<span class=\"hljs-property\">Binding</span>, <span class=\"hljs-attr\">last</span>: <span class=\"hljs-title class_\">Binding</span>&#x3C;<span class=\"hljs-title class_\">Value</span>?>) -> some <span class=\"hljs-title class_\">View</span> {\n        <span class=\"hljs-title function_\">onChange</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">of</span>: current.wrappedValue</span>) { _ <span class=\"hljs-keyword\">in</span>\n            <span class=\"hljs-keyword\">if</span> current.<span class=\"hljs-property\">wrappedValue</span> != last.<span class=\"hljs-property\">wrappedValue</span> {\n                last.<span class=\"hljs-property\">wrappedValue</span> = current.<span class=\"hljs-property\">wrappedValue</span>\n            }\n        }\n    }\n\n    func focused&#x3C;<span class=\"hljs-title class_\">Value</span>>(_ <span class=\"hljs-attr\">binding</span>: <span class=\"hljs-title class_\">FocusState</span>&#x3C;<span class=\"hljs-title class_\">Value</span>>.<span class=\"hljs-property\">Binding</span>, equals <span class=\"hljs-attr\">value</span>: <span class=\"hljs-title class_\">Value</span>, <span class=\"hljs-attr\">last</span>: <span class=\"hljs-title class_\">Value</span>?, <span class=\"hljs-attr\">onFocus</span>: @escaping (<span class=\"hljs-title class_\">Bool</span>) -> <span class=\"hljs-title class_\">Void</span>) -> some <span class=\"hljs-title class_\">View</span> where <span class=\"hljs-title class_\">Value</span>: <span class=\"hljs-title class_\">Hashable</span> {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">focused</span>(binding, <span class=\"hljs-attr\">equals</span>: value)\n            .<span class=\"hljs-title function_\">onChange</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">of</span>: binding.wrappedValue</span>) { focusValue <span class=\"hljs-keyword\">in</span>\n                <span class=\"hljs-keyword\">if</span> focusValue == value {\n                    <span class=\"hljs-title function_\">onFocus</span>(<span class=\"hljs-literal\">true</span>)\n                } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> last == value { <span class=\"hljs-comment\">// only call once</span>\n                    <span class=\"hljs-title function_\">onFocus</span>(<span class=\"hljs-literal\">false</span>)\n                }\n            }\n    }\n}\n</code></pre>\n<p>호출:</p>\n<pre><code class=\"hljs language-js\">struct <span class=\"hljs-title class_\">OnFocusView</span>: <span class=\"hljs-title class_\">View</span> {\n    @<span class=\"hljs-title class_\">FocusState</span> private <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">focused</span>: <span class=\"hljs-title class_\">Focus</span>?\n    @<span class=\"hljs-title class_\">State</span> private <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">lastFocused</span>: <span class=\"hljs-title class_\">Focus</span>?\n    @<span class=\"hljs-title class_\">State</span> private <span class=\"hljs-keyword\">var</span> name = <span class=\"hljs-string\">\"\"</span>\n    @<span class=\"hljs-title class_\">State</span> private <span class=\"hljs-keyword\">var</span> email = <span class=\"hljs-string\">\"\"</span>\n    @<span class=\"hljs-title class_\">State</span> private <span class=\"hljs-keyword\">var</span> address = <span class=\"hljs-string\">\"\"</span>\n    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">body</span>: some <span class=\"hljs-title class_\">View</span> {\n        <span class=\"hljs-title class_\">List</span> {\n            <span class=\"hljs-title class_\">TextField</span>(<span class=\"hljs-string\">\"이름:\"</span>, <span class=\"hljs-attr\">text</span>: $name)\n                .<span class=\"hljs-title function_\">focused</span>(<span class=\"hljs-params\">$focused, equals: .name, last: lastFocused</span>) {\n                    <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">\"이름:\"</span>, $0)\n                }\n            <span class=\"hljs-title class_\">TextField</span>(<span class=\"hljs-string\">\"이메일:\"</span>, <span class=\"hljs-attr\">text</span>: $email)\n                .<span class=\"hljs-title function_\">focused</span>(<span class=\"hljs-params\">$focused, equals: .email, last: lastFocused</span>) {\n                    <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">\"이메일:\"</span>, $0)\n                }\n            <span class=\"hljs-title class_\">TextField</span>(<span class=\"hljs-string\">\"주소:\"</span>, <span class=\"hljs-attr\">text</span>: $address)\n                .<span class=\"hljs-title function_\">focused</span>(<span class=\"hljs-params\">$focused, equals: .address, last: lastFocused</span>) {\n                    <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">\"주소:\"</span>, $0)\n                }\n        }\n        .<span class=\"hljs-title function_\">storeLastFocus</span>(<span class=\"hljs-attr\">current</span>: $focused, <span class=\"hljs-attr\">last</span>: $lastFocused) <span class=\"hljs-comment\">// 최신 포커스 값을 저장합니다.</span>\n    }\n\n    enum <span class=\"hljs-title class_\">Focus</span> {\n        <span class=\"hljs-keyword\">case</span> name, email, address\n    }\n}\n</code></pre>\n<h1>키보드</h1>\n<p></p>\n<p>TextField를 사용하다보면 소프트웨어 키보드와 함께 작업해야 합니다. 이 섹션에서는 키보드와 관련된 몇 가지 예제를 소개할 것입니다.</p>\n<h2>키보드 유형</h2>\n<p>iPhone에서 keyboardType를 통해 소프트웨어 키보드 유형을 설정하여 사용자 입력을 용이하게 하거나 입력 문자 범위를 제한할 수 있습니다.</p>\n<p>예시:</p>\n<p></p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">KeyboardTypeDemo</span>: <span class=\"hljs-title class_\">View</span> {\n    <span class=\"hljs-meta\">@State</span> <span class=\"hljs-keyword\">var</span> price: <span class=\"hljs-type\">Double</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>\n    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> {\n        <span class=\"hljs-type\">Form</span> {\n            <span class=\"hljs-type\">TextField</span>(<span class=\"hljs-string\">\"Price:\"</span>, value: <span class=\"hljs-variable\">$price</span>, format: .number.precision(.fractionLength(<span class=\"hljs-number\">2</span>)))\n                .keyboardType(.decimalPad) <span class=\"hljs-comment\">// 소수점 숫자 키보드 지원</span>\n        }\n    }\n}\n</code></pre>\n<p>위 이미지는 \"/assets/img/2024-06-23-AdvancedSwiftUITextFieldEventsFocusKeyboard_0.png\" 입니다.</p>\n<p>현재, 지원되는 키보드 유형은 총 11가지이며, 다음과 같습니다:</p>\n<ul>\n<li>asciiCapable</li>\n</ul>\n<p></p>\n<p>아래는 번호 및 구두점 테이블입니다.</p>\n<table>\n<thead>\n<tr>\n<th>numbersAndPunctuation</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Numbers and punctuation</td>\n</tr>\n</tbody>\n</table>\n<p>URL 테이블로 아래 내용을 변환해주세요.</p>\n<p></p>\n<p>URL 주소를 입력하는 데 유용하며, 문자 및 '.', '/', '.com'을 포함할 수 있습니다.</p>\n<ul>\n<li>numberPad</li>\n</ul>\n<p>해당 지역의 숫자 세트를 사용합니다(0-9, ۰-۹, ०-९ 등). 양의 정수나 PIN에 적합합니다.</p>\n<ul>\n<li>phonePad</li>\n</ul>\n<p></p>\n<p>전화기에서 사용되는 숫자 및 다른 기호, 예를 들면 ‘*#+’</p>\n<ul>\n<li>namePhonePad</li>\n</ul>\n<p>텍스트 및 전화번호 입력에 편리합니다. 문자 상태는 asciiCapable과 유사하며, 숫자 상태는 numberPad와 유사합니다.</p>\n<ul>\n<li>emailAddress</li>\n</ul>\n<p></p>\n<p>'@'를 입력하는 데 편리한 아스키 호환 키보드입니다.</p>\n<ul>\n<li>decimalPad</li>\n</ul>\n<p>소수점이 포함된 숫자 키패드입니다. 자세한 내용은 위의 이미지를 참조해주세요.</p>\n<ul>\n<li>트위터</li>\n</ul>\n<p></p>\n<p>아스키 지원 키보드에는 '@#'이 포함되어 있습니다.</p>\n<ul>\n<li>웹 검색</li>\n</ul>\n<p>'.'을 포함한 아스키 지원 키보드이며 'return' 키는 'go'로 표시됩니다.</p>\n<ul>\n<li>아스키 지원 번호 패드</li>\n</ul>\n<p></p>\n<p>An asciiCapable 키보드에는 숫자가 포함되어 있습니다.</p>\n<p>Apple은 다양한 키보드 모드를 제공하지만, 경우에 따라 사용자의 요구 사항을 충족시키지 못할 수도 있습니다.</p>\n<p>예를 들어, numberPad 및 decimalPad에는 \"-\" 및 \"return\"이 없습니다. SwiftUI 3.0 이전에는 주요 뷰에 별도로 그리거나 SwiftUI 이외의 방법을 사용하여 문제를 해결해야 했습니다. 그러나 SwiftUI 3.0에서는 네이티브 설정 키보드 보조 뷰(자세한 내용은 아래에 설명되어 있음) 추가로 위 문제를 해결하는 것이 이제 더 어렵지 않아졌습니다.</p>\n<h1>TextContentType를 통해 제안을 받아보세요</h1>\n<p></p>\n<p>특정 iOS 앱을 사용할 때 텍스트를 입력할 때 소프트웨어 키보드가 자동으로 입력해야 할 내용을 제안하는 경우가 있습니다. 이는 전화 번호, 이메일, 인증 코드 등을 텍스트ContentType를 통해 얻는 효과입니다.</p>\n<p>TextField의 UITextContentType을 설정함으로써 시스템은 입력 중에 입력하려는 콘텐츠를 지능적으로 추론하고 제안을 표시합니다.</p>\n<p>다음 코드는 비밀번호 입력 시 키체인을 사용할 수 있도록 합니다.</p>\n<pre><code class=\"hljs language-js\">struct <span class=\"hljs-title class_\">KeyboardTypeDemo</span>: <span class=\"hljs-title class_\">View</span> {\n    @<span class=\"hljs-title class_\">State</span> <span class=\"hljs-keyword\">var</span> password = <span class=\"hljs-string\">\"\"</span>\n    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">body</span>: some <span class=\"hljs-title class_\">View</span> {\n        <span class=\"hljs-title class_\">Form</span> {\n            <span class=\"hljs-title class_\">SecureField</span>(<span class=\"hljs-string\">\"\"</span>, <span class=\"hljs-attr\">text</span>: $password)\n                .<span class=\"hljs-title function_\">textContentType</span>(.<span class=\"hljs-property\">password</span>)\n        }\n    }\n}\n</code></pre>\n<p></p>\n<p>이메일 주소를 입력할 때 연락처 및 이메일에서 비슷한 이메일 주소를 제안하는 코드입니다:</p>\n<pre><code class=\"hljs language-js\">struct <span class=\"hljs-title class_\">KeyboardTypeDemo</span>: <span class=\"hljs-title class_\">View</span> {\n    @<span class=\"hljs-title class_\">State</span> <span class=\"hljs-keyword\">var</span> email = <span class=\"hljs-string\">\"\"</span>\n    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">body</span>: some <span class=\"hljs-title class_\">View</span> {\n        <span class=\"hljs-title class_\">Form</span> {\n            <span class=\"hljs-title class_\">TextField</span>(<span class=\"hljs-string\">\"\"</span>, <span class=\"hljs-attr\">text</span>: $email)\n                .<span class=\"hljs-title function_\">textContentType</span>(.<span class=\"hljs-property\">emailAddress</span>)\n        }\n    }\n}\n</code></pre>\n<p></p>\n<p>다음은 설정할 수 있는 여러 종류의 UITextContentType이 있습니다. 흔히 사용되는 것들 중 일부는 다음과 같습니다:</p>\n<ul>\n<li>password</li>\n<li>이름 옵션, 예를 들어 name, givenName, middleName 등이 있습니다.</li>\n<li>주소 옵션, 예를 듀 addressCity, fullStreetAddress, postalCode 등이 있습니다.</li>\n<li>telephoneNumber</li>\n<li>emailAddress</li>\n<li>oneTimeCode (인증 코드)</li>\n</ul>\n<h1>키보드 해제</h1>\n<p>일부 경우에는 사용자가 텍스트 입력을 완료한 후 소프트웨어 키보드를 해제하여 더 많은 디스플레이 공간을 확보해야 할 수 있습니다. 일부 키보드 유형에는 \"return\" 버튼이 없기 때문에 프로그래밍을 사용하여 키보드를 사라지게 해야 합니다.</p>\n<p></p>\n<p>또한 가끔은 사용자가 \"return\" 버튼을 클릭하지 않고도 화면의 다른 영역을 클릭하거나 목록을 스크롤하여 키보드를 숨길 수 있게 하려고 할 수도 있습니다. 상호 작용 경험을 향상시키기 위해 프로그래밍을 사용하여 키보드를 사라지게 할 필요가 있습니다.</p>\n<ul>\n<li>FocusState를 사용하여 키보드 숨기기</li>\n</ul>\n<p>해당 FocusState가 TextField에 설정되면 값을 \"false\" 또는 \"nil\"로 설정하여 키보드를 숨길 수 있습니다.</p>\n<pre><code class=\"hljs language-js\">struct <span class=\"hljs-title class_\">HideKeyboardView</span>: <span class=\"hljs-title class_\">View</span> {\n    @<span class=\"hljs-title class_\">State</span> private <span class=\"hljs-keyword\">var</span> name = <span class=\"hljs-string\">\"\"</span>\n    @<span class=\"hljs-title class_\">FocusState</span> private <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">nameIsFocused</span>: <span class=\"hljs-title class_\">Bool</span>\n\n    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">body</span>: some <span class=\"hljs-title class_\">View</span> {\n        <span class=\"hljs-title class_\">Form</span> {\n            <span class=\"hljs-title class_\">TextField</span>(<span class=\"hljs-string\">\"이름을 입력하세요\"</span>, <span class=\"hljs-attr\">text</span>: $name)\n                .<span class=\"hljs-title function_\">focused</span>($nameIsFocused)\n            <span class=\"hljs-title class_\">Button</span>(<span class=\"hljs-string\">\"키보드 숨기기\"</span>) {\n                nameIsFocused = <span class=\"hljs-literal\">false</span>\n            }\n        }\n    }\n}\n</code></pre>\n<p></p>\n<ul>\n<li>기타 상황</li>\n</ul>\n<p>대부분의 경우, 우리는 UIkit에서 제공하는 메서드를 직접 사용하여 키보드를 숨길 수 있습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title class_\">UIApplication</span>.<span class=\"hljs-property\">shared</span>.<span class=\"hljs-title function_\">sendAction</span>(#<span class=\"hljs-title function_\">selector</span>(<span class=\"hljs-title class_\">UIResponder</span>.<span class=\"hljs-property\">resignFirstResponder</span>), <span class=\"hljs-attr\">to</span>: nil, <span class=\"hljs-attr\">from</span>: nil, <span class=\"hljs-attr\">for</span>: nil)\n</code></pre>\n<p>예를 들어, 사용자가 뷰를 드래그할 때 키보드를 숨기는 다음 코드가 있습니다:</p>\n<p></p>\n<pre><code class=\"hljs language-js\">구조 <span class=\"hljs-title class_\">ResignKeyboardOnDragGesture</span>: <span class=\"hljs-title class_\">ViewModifier</span> {\n    <span class=\"hljs-keyword\">var</span> gesture = <span class=\"hljs-title class_\">DragGesture</span>().<span class=\"hljs-property\">onChanged</span> { _ <span class=\"hljs-keyword\">in</span>\n        <span class=\"hljs-title class_\">UIApplication</span>.<span class=\"hljs-property\">shared</span>.<span class=\"hljs-title function_\">sendAction</span>(#<span class=\"hljs-title function_\">selector</span>(<span class=\"hljs-title class_\">UIResponder</span>.<span class=\"hljs-property\">resignFirstResponder</span>), <span class=\"hljs-attr\">to</span>: nil, <span class=\"hljs-attr\">from</span>: nil, <span class=\"hljs-attr\">for</span>: nil)\n    }\n\n    func <span class=\"hljs-title function_\">body</span>(<span class=\"hljs-attr\">content</span>: <span class=\"hljs-title class_\">Content</span>) -> some <span class=\"hljs-title class_\">View</span> {\n        content.<span class=\"hljs-title function_\">gesture</span>(gesture)\n    }\n}\nextension <span class=\"hljs-title class_\">View</span> {\n    func <span class=\"hljs-title function_\">dismissKeyboard</span>() -> some <span class=\"hljs-title class_\">View</span> {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">modifier</span>(<span class=\"hljs-title class_\">ResignKeyboardOnDragGesture</span>())\n    }\n}\n구조 <span class=\"hljs-title class_\">HideKeyboardView</span>: <span class=\"hljs-title class_\">View</span> {\n    @<span class=\"hljs-title class_\">State</span> private <span class=\"hljs-keyword\">var</span> name = <span class=\"hljs-string\">\"\"</span>\n    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">body</span>: some <span class=\"hljs-title class_\">View</span> {\n        <span class=\"hljs-title class_\">Form</span> {\n            <span class=\"hljs-title class_\">TextField</span>(<span class=\"hljs-string\">\"이름을 입력하세요\"</span>, <span class=\"hljs-attr\">text</span>: $name)\n        }\n        .<span class=\"hljs-title function_\">dismissKeyboard</span>()\n    }\n}\n</code></pre>\n<h1>키보드 어시스턴트 뷰</h1>\n<h1>툴바를 통해 생성됨</h1>\n<p>SwiftUI 3.0에서는 ToolbarItem(placement: .keyboard, content: View)를 사용하여 키보드 어시스턴트 뷰(inputAccessoryView)를 생성할 수 있습니다.</p>\n<p></p>\n<p>입력 보조 뷰를 통해 이전에 처리하기 어려웠던 많은 문제들을 해결하고 상호 작용 수단을 더 많이 제공할 수 있습니다.</p>\n<p>다음 코드는 소수점 숫자를 입력할 때 양/음수 변환 및 확인 버튼을 추가합니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Introspect</span>\nstruct <span class=\"hljs-title class_\">ToolbarKeyboardDemo</span>: <span class=\"hljs-title class_\">View</span> {\n    @<span class=\"hljs-title class_\">State</span> <span class=\"hljs-keyword\">var</span> price = <span class=\"hljs-string\">\"\"</span>\n    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">body</span>: some <span class=\"hljs-title class_\">View</span> {\n        <span class=\"hljs-title class_\">Form</span> {\n            <span class=\"hljs-title class_\">TextField</span>(<span class=\"hljs-string\">\"가격:\"</span>, <span class=\"hljs-attr\">text</span>: $price)\n                .<span class=\"hljs-title function_\">keyboardType</span>(.<span class=\"hljs-property\">decimalPad</span>)\n                .<span class=\"hljs-property\">toolbar</span> {\n                    <span class=\"hljs-title class_\">ToolbarItem</span>(<span class=\"hljs-attr\">placement</span>: .<span class=\"hljs-property\">keyboard</span>) {\n                        <span class=\"hljs-title class_\">HStack</span> {\n                            <span class=\"hljs-title class_\">Button</span>(<span class=\"hljs-string\">\"-/+\"</span>) {\n                                <span class=\"hljs-keyword\">if</span> price.<span class=\"hljs-title function_\">hasPrefix</span>(<span class=\"hljs-params\"><span class=\"hljs-string\">\"-\"</span></span>) {\n                                    price.<span class=\"hljs-title function_\">removeFirst</span>()\n                                } <span class=\"hljs-keyword\">else</span> {\n                                    price = <span class=\"hljs-string\">\"-\"</span> + price\n                                }\n                            }\n                            .<span class=\"hljs-title function_\">buttonStyle</span>(.<span class=\"hljs-property\">bordered</span>)\n                            <span class=\"hljs-title class_\">Spacer</span>()\n                            <span class=\"hljs-title class_\">Button</span>(<span class=\"hljs-string\">\"완료\"</span>) {\n                                <span class=\"hljs-title class_\">UIApplication</span>.<span class=\"hljs-property\">shared</span>.<span class=\"hljs-title function_\">sendAction</span>(#<span class=\"hljs-title function_\">selector</span>(<span class=\"hljs-title class_\">UIResponder</span>.<span class=\"hljs-property\">resignFirstResponder</span>), <span class=\"hljs-attr\">to</span>: nil, <span class=\"hljs-attr\">from</span>: nil, <span class=\"hljs-attr\">for</span>: nil)\n                                <span class=\"hljs-comment\">// 해야 할 일을 수행합니다</span>\n                            }\n                            .<span class=\"hljs-title function_\">buttonStyle</span>(.<span class=\"hljs-property\">bordered</span>)\n                        }\n                        .<span class=\"hljs-title function_\">padding</span>(.<span class=\"hljs-property\">horizontal</span>, <span class=\"hljs-number\">30</span>)\n                    }\n                }\n        }\n    }\n}\n</code></pre>\n<p></p>\n<p>안타깝지만, ToolbarItem을 통해 입력 보조 뷰를 설정하는 데는 아직 몇 가지 제한 사항이 있습니다:</p>\n<ul>\n<li>표시 콘텐츠 제한</li>\n</ul>\n<p>높이가 고정되어 있어 악세서리 뷰의 전체 디스플레이 영역을 활용할 수 없습니다. 다른 종류의 툴바와 마찬가지로 SwiftUI가 콘텐츠의 레이아웃에 개입합니다.</p>\n<ul>\n<li>같은 뷰 내에서 여러 텍스트 필드에 대해 별도의 액세서리 뷰를 설정할 수 없음</li>\n</ul>\n<p></p>\n<p>보다 복잡한 조건부 구문은 ToolbarItem에서 사용할 수 없습니다. 다른 텍스트 필드에 대해 별도로 설정하더라도 SwiftUI는 모든 내용을 함께 표시하기 위해 병합합니다.</p>\n<h1>UIKit을 통해 생성하기</h1>\n<p>현재 단계에서는 SwiftUI에 대한 키보드 액세서리 뷰를 UIKit을 통해 생성하는 것이 여전히 최적의 솔루션이 됩니다. 화면 표시에 대한 완벽한 제어를 얻을 수 있을 뿐만 아니라 동일한 뷰 내부의 여러 텍스트 필드를 별도로 설정할 수도 있습니다.</p>\n<pre><code class=\"hljs language-js\">extension <span class=\"hljs-title class_\">UIView</span> {\n    func <span class=\"hljs-title function_\">constrainEdges</span>(<span class=\"hljs-params\">to other: UIView</span>) {\n        translatesAutoresizingMaskIntoConstraints = <span class=\"hljs-literal\">false</span>\n        <span class=\"hljs-title class_\">NSLayoutConstraint</span>.<span class=\"hljs-title function_\">activate</span>([\n            leadingAnchor.<span class=\"hljs-title function_\">constraint</span>(<span class=\"hljs-attr\">equalTo</span>: other.<span class=\"hljs-property\">leadingAnchor</span>),\n            trailingAnchor.<span class=\"hljs-title function_\">constraint</span>(<span class=\"hljs-attr\">equalTo</span>: other.<span class=\"hljs-property\">trailingAnchor</span>),\n            topAnchor.<span class=\"hljs-title function_\">constraint</span>(<span class=\"hljs-attr\">equalTo</span>: other.<span class=\"hljs-property\">topAnchor</span>),\n            bottomAnchor.<span class=\"hljs-title function_\">constraint</span>(<span class=\"hljs-attr\">equalTo</span>: other.<span class=\"hljs-property\">bottomAnchor</span>),\n        ])\n    }\n}\n\nextension <span class=\"hljs-title class_\">View</span> {\n    func inputAccessoryView&#x3C;<span class=\"hljs-title class_\">Content</span>: <span class=\"hljs-title class_\">View</span>>(@<span class=\"hljs-title class_\">ViewBuilder</span> <span class=\"hljs-attr\">content</span>: @escaping () -> <span class=\"hljs-title class_\">Content</span>) -> some <span class=\"hljs-title class_\">View</span> {\n        introspectTextField { td <span class=\"hljs-keyword\">in</span>\n            <span class=\"hljs-keyword\">let</span> viewController = <span class=\"hljs-title class_\">UIHostingController</span>(<span class=\"hljs-attr\">rootView</span>: <span class=\"hljs-title function_\">content</span>())\n            viewController.<span class=\"hljs-property\">view</span>.<span class=\"hljs-title function_\">constrainEdges</span>(<span class=\"hljs-attr\">to</span>: viewController.<span class=\"hljs-property\">view</span>)\n            td.<span class=\"hljs-property\">inputAccessoryView</span> = viewController.<span class=\"hljs-property\">view</span>\n        }\n    }\n    func inputAccessoryView&#x3C;<span class=\"hljs-title class_\">Content</span>: <span class=\"hljs-title class_\">View</span>>(<span class=\"hljs-attr\">content</span>: <span class=\"hljs-title class_\">Content</span>) -> some <span class=\"hljs-title class_\">View</span> {\n        introspectTextField { td <span class=\"hljs-keyword\">in</span>\n            <span class=\"hljs-keyword\">let</span> viewController = <span class=\"hljs-title class_\">UIHostingController</span>(<span class=\"hljs-attr\">rootView</span>: content)\n            viewController.<span class=\"hljs-property\">view</span>.<span class=\"hljs-title function_\">constrainEdges</span>(<span class=\"hljs-attr\">to</span>: viewController.<span class=\"hljs-property\">view</span>)\n            td.<span class=\"hljs-property\">inputAccessoryView</span> = viewController.<span class=\"hljs-property\">view</span>\n        }\n    }\n}\n</code></pre>\n<p></p>\n<p>사용법:</p>\n<pre><code class=\"hljs language-js\">struct <span class=\"hljs-title class_\">OnFocusDemo</span>: <span class=\"hljs-title class_\">View</span> {\n    @<span class=\"hljs-title class_\">FocusState</span> <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">focus</span>: <span class=\"hljs-title class_\">FocusedField</span>?\n    @<span class=\"hljs-title class_\">State</span> <span class=\"hljs-keyword\">var</span> name = <span class=\"hljs-string\">\"\"</span>\n    @<span class=\"hljs-title class_\">State</span> <span class=\"hljs-keyword\">var</span> email = <span class=\"hljs-string\">\"\"</span>\n    @<span class=\"hljs-title class_\">State</span> <span class=\"hljs-keyword\">var</span> phoneNumber = <span class=\"hljs-string\">\"\"</span>\n    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">body</span>: some <span class=\"hljs-title class_\">View</span> {\n        <span class=\"hljs-title class_\">Form</span> {\n            <span class=\"hljs-title class_\">TextField</span>(<span class=\"hljs-string\">\"이름:\"</span>, <span class=\"hljs-attr\">text</span>: $name)\n                .<span class=\"hljs-title function_\">focused</span>($focus, <span class=\"hljs-attr\">equals</span>: .<span class=\"hljs-property\">name</span>)\n                .<span class=\"hljs-title function_\">inputAccessoryView</span>(<span class=\"hljs-attr\">content</span>: <span class=\"hljs-title function_\">accessoryView</span>(<span class=\"hljs-attr\">focus</span>: .<span class=\"hljs-property\">name</span>))\n\n            <span class=\"hljs-title class_\">TextField</span>(<span class=\"hljs-string\">\"이메일:\"</span>, <span class=\"hljs-attr\">text</span>: $email)\n                .<span class=\"hljs-title function_\">focused</span>($focus, <span class=\"hljs-attr\">equals</span>: .<span class=\"hljs-property\">email</span>)\n                .<span class=\"hljs-title function_\">inputAccessoryView</span>(<span class=\"hljs-attr\">content</span>: <span class=\"hljs-title function_\">accessoryView</span>(<span class=\"hljs-attr\">focus</span>: .<span class=\"hljs-property\">email</span>))\n\n            <span class=\"hljs-title class_\">TextField</span>(<span class=\"hljs-string\">\"전화번호:\"</span>, <span class=\"hljs-attr\">text</span>: $phoneNumber)\n                .<span class=\"hljs-title function_\">focused</span>($focus, <span class=\"hljs-attr\">equals</span>: .<span class=\"hljs-property\">phone</span>)\n        }\n        .<span class=\"hljs-property\">onSubmit</span> {\n            <span class=\"hljs-keyword\">switch</span> focus {\n            <span class=\"hljs-keyword\">case</span> .<span class=\"hljs-property\">name</span>:\n                focus = .<span class=\"hljs-property\">email</span>\n            <span class=\"hljs-keyword\">case</span> .<span class=\"hljs-property\">email</span>:\n                focus = .<span class=\"hljs-property\">phone</span>\n            <span class=\"hljs-keyword\">case</span> .<span class=\"hljs-property\">phone</span>:\n                <span class=\"hljs-keyword\">if</span> !name.<span class=\"hljs-property\">isEmpty</span>, !email.<span class=\"hljs-property\">isEmpty</span>, !phoneNumber.<span class=\"hljs-property\">isEmpty</span> {}\n            <span class=\"hljs-attr\">default</span>:\n                <span class=\"hljs-keyword\">break</span>\n            }\n        }\n    }\n}\n\nstruct <span class=\"hljs-attr\">accessoryView</span>: <span class=\"hljs-title class_\">View</span> {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">focus</span>: <span class=\"hljs-title class_\">FocusedField</span>?\n    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">body</span>: some <span class=\"hljs-title class_\">View</span> {\n        <span class=\"hljs-keyword\">switch</span> focus {\n        <span class=\"hljs-keyword\">case</span> .<span class=\"hljs-property\">name</span>:\n            <span class=\"hljs-title class_\">Button</span>(<span class=\"hljs-string\">\"이름\"</span>) {}.<span class=\"hljs-title function_\">padding</span>(.<span class=\"hljs-property\">vertical</span>, <span class=\"hljs-number\">10</span>)\n        <span class=\"hljs-keyword\">case</span> .<span class=\"hljs-property\">email</span>:\n            <span class=\"hljs-title class_\">Button</span>(<span class=\"hljs-string\">\"이메일\"</span>) {}.<span class=\"hljs-title function_\">padding</span>(.<span class=\"hljs-property\">vertical</span>, <span class=\"hljs-number\">10</span>)\n        <span class=\"hljs-attr\">default</span>:\n            <span class=\"hljs-title class_\">EmptyView</span>()\n        }\n    }\n}\n</code></pre>\n<h1>사용자 정의 제출 레이블</h1>\n<p>기본적으로 TextField (SecureField)의 키보드에 대한 제출 동작 버튼은 \"return\"입니다. SwiftUI 3.0에서 소개된 \"submitLabel\" 수정자를 사용하면 \"return\" 버튼을 입력 콘텍스트와 관련된 텍스트로 수정할 수 있습니다.</p>\n<p></p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-type\">TextField</span>(<span class=\"hljs-string\">\"사용자 이름\"</span>, text: <span class=\"hljs-variable\">$username</span>)\n            .submitLabel(.next)\n</code></pre>\n<p>현재 지원되는 유형은 다음과 같습니다:</p>\n<ul>\n<li>continue</li>\n<li>done</li>\n<li>go</li>\n<li>join</li>\n<li>next</li>\n<li>return</li>\n<li>route</li>\n<li>search</li>\n<li>send</li>\n</ul>\n<p></p>\n<p>예를 들어, 이전 코드에서는 이름, 이메일 및 전화번호에 대한 서로 다른 표시를 설정할 수 있습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title class_\">TextField</span>(<span class=\"hljs-string\">\"이름:\"</span>, <span class=\"hljs-attr\">text</span>: $name)\n                .<span class=\"hljs-title function_\">focused</span>($focus, <span class=\"hljs-attr\">equals</span>: .<span class=\"hljs-property\">name</span>)\n                .<span class=\"hljs-title function_\">submitLabel</span>(.<span class=\"hljs-property\">next</span>)\n<span class=\"hljs-title class_\">TextField</span>(<span class=\"hljs-string\">\"이메일:\"</span>, <span class=\"hljs-attr\">text</span>: $email)\n                .<span class=\"hljs-title function_\">focused</span>($focus, <span class=\"hljs-attr\">equals</span>: .<span class=\"hljs-property\">email</span>)\n                .<span class=\"hljs-title function_\">submitLabel</span>(.<span class=\"hljs-property\">next</span>)\n\n<span class=\"hljs-title class_\">TextField</span>(<span class=\"hljs-string\">\"전화번호:\"</span>, <span class=\"hljs-attr\">text</span>: $phoneNumber)\n                .<span class=\"hljs-title function_\">focused</span>($focus, <span class=\"hljs-attr\">equals</span>: .<span class=\"hljs-property\">phone</span>)\n                .<span class=\"hljs-title function_\">submitLabel</span>(.<span class=\"hljs-property\">return</span>)\n</code></pre>\n<h1>결론</h1>\n<p>SwiftUI 1.0부터 Apple은 TextField의 기능을 지속적으로 개선해 왔습니다. 버전 3.0에서 SwiftUI는 더 많은 네이티브 수정자를 제공하는데 그치지 않고 FocusState와 onSubmit과 같은 통합 관리 논리를 제공합니다. 믿음직스러운 2~3년 뒤에는 SwiftUI의 주요 컨트롤의 네이티브 기능이 해당하는 UIKit 컨트롤과 맞먹을 것이라고 믿습니다.</p>\n<p></p>\n<p>만약 이 글이 도움이 되었거나 즐겁게 읽으셨다면, 제 글을 지원하기 위해 기부를 고려해 주세요. 여러분의 기부는 저가 계속해서 가치 있는 콘텐츠를 만드는데 도움이 될 것입니다.\nPatreon, Buy Me a Coffee 또는 PayPal을 통해 기부할 수 있습니다.</p>\n<pre><code class=\"hljs language-js\">연락하고 싶다면?\n\n<span class=\"hljs-title class_\">Twitter</span>에서 @fatbobman을 팔로우하세요.\n</code></pre>\n</body>\n</html>\n"},"__N_SSG":true}