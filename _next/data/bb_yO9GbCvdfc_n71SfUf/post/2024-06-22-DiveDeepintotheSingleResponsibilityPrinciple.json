{"pageProps":{"post":{"title":"단일 책임 원칙SRP에 깊이 파고들기 더 좋은 코드 작성 방법 알아보기","description":"","date":"2024-06-22 23:04","slug":"2024-06-22-DiveDeepintotheSingleResponsibilityPrinciple","content":"\n## SRP를 수용하는 것이 어떻게 코딩 방법을 변화시키고 확장 가능한 소프트웨어를 이끌어낼 수 있는지 알아보세요.\n\n![SRP](/assets/img/2024-06-22-DiveDeepintotheSingleResponsibilityPrinciple_0.png)\n\n# SOLID 원칙이란 무엇인가요?\n\n모든 직업에는 준수해야 할 표준과 엄격한 규칙이 있으며, 이를 어기는 경우 중요한 결과가 발생할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n예를 들어, 건축가가 건물 규정을 준수하여 구조물의 안전과 안정성을 보장해야 하는 방법을 생각해보세요.\n\n이러한 기준들이 왜 만들어졌을까요?\n\n- 많은 사람들이 동일한 과정을 거쳤고 그 경험은 모범 사례에 대한 집단적인 이해를 기여합니다.\n- 표준을 준수하는 것은 실수 가능성을 줄입니다. 전문가들이 따를 수 있는 명확하고 검증된 방법을 제공하여 일관성과 신뢰성을 보장합니다.\n- 표준은 모든 잠재적인 문제 영역에 대한 지식을 포괄합니다. 이러한 문제를 다루고 완화하는 방식으로 정의되어 있습니다.\n\n마찬가지로, 소프트웨어 개발에서,\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nSOLID 원칙은 깨끗하고 유지보수가 쉽고 견고한 코드를 작성하기 위한 표준을 제공하기 위해 만들어졌어요.\n\n- 이러한 원칙은 많은 개발자들의 경험과 소프트웨어 설계에서 가장 잘 작동하는 것에 대한 지식을 바탕으로 합니다.\n\nSOLID 원칙을 준수함으로써, 개발자들은 오류를 최소화하고 잠재적인 문제를 해결하며 이해하기 쉽고 확장 및 유지보수가 쉬운 소프트웨어를 만들 수 있어요.\n\n# 단일 책임 원칙(SRP)란 무엇인가요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 이제 모든 개발자는 \"책임\"을 각자 다르게 해석할 수 있습니다\n- 컴포넌트를 디자인할 때, 한 명의 개발자는 전체 컴포넌트의 생성을 단일 책임으로 간주할 수 있습니다\n- 또 다른 개발자는 뷰 및 네트워크 호출을 별도의 관심사로 처리하도록 더 세분화된 책임 분할을 옹호할 수 있습니다\n\n명확하게 하기 위해, 우리는 종종 SRP를 클래스가 하나의 변경 이유만을 가져야 한다는 개념으로 표현합니다.\n\n간단히 말해서, 클래스가 여러 이유로 수정이 필요한 경우 SRP를 위반합니다.\n\n## 이젠 ProfileVC가 이 원칙을 어기는지 살펴봅시다\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```swift\nclass ProfileVC: UIViewController {\n  override func viewDidLoad() {\n    fetchImageFromAPI()\n  }\n\n  func fetchImageFromAPI() {\n    APIService.callAPI(with: url) { response in\n      handleResponse(response: response)\n    }\n  }\n\n  func handleResponse(response: Result<Data, Error>) {\n    switch response {\n    case .success(let data):\n      processImage(data: data)\n    case .failure(let error):\n      print(\"Failed to fetch data: \\(error)\")\n   }\n  }\n\n  func processImage(data: Data) {\n    // process image\n    displayDataOnUI(data: data)\n  }\n\n  func displayDataOnUI(data: Data) {\n    print(\"Updating UI with data\")\n  }\n\n}\n```\n\n`ProfileVC`는 다음과 같은 책임을 갖습니다:\n\n- 서비스에서 데이터를 가져오기 [위반]\n- 응답 처리하기 [위반]\n- 이미지 처리하기 [위반]\n- 이미지 표시하기 [유효]\n\n# ProfileVC에 단일 책임 원칙(SPR) 적용해보기\n\n- ImageLoader\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n// ImageLoader는 오직 한 가지 책임만을 가지고 있습니다.\n// 네트워크에서 이미지를 로드하고 전달하는 것입니다.\n\nclass ImageLoader {\n\nfunc fetchImageFromAPI(completion: @escaping ResultCompletion) {\nAPIService.callAPI(with: url) { response in\ncompletion(response)\n}\n}\n\n}\n\n- ImageDecoder\n\n// ImageDecoder\n// 사실상, base64 이미지를 파싱하거나\n// 유사한 작업을 통해 다음 해당 인스턴스로 전달할 것입니다.\n// 디코딩 로직이 다른 구성 요소에서 수행되어야 함을 보여주기 위한 예시입니다.\n\nclass ImageDecoder {\nlet result: ResultCompletion\n\ninit(...) {\nself.result = result\n}\n\nfunc decodeImage(completion: ...) -> Void) {\nswitch result {\ncase .success(let data):\n// 디코딩 처리\ncompletion(success(data))\ncase .failure(let error):\ncompletion (.failure(error))\n}\n}\n\n}\n\n- ImageProcessor\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n// ImageProcessor\n\nclass ImageProcessor {\n  let imageData: Data\n\n  init(...) {\n    self.imageData = imageData\n  }\n\n  func processData(completion: ...) -> Void)  {\n    // Process image and pass further to the chain\n  }\n\n}\n```\n\n- ProfileVC\n\n```js\n// ProfileVC\n\nclass ProfileVC: UIViewController {\n\n  var load: (() -> Void)?\n\n  func viewDidLoad() {\n    load()\n  }\n\n  func displayImage(_ data: Data) -> Void)  {\n    profileImage.image = UIImageFromData(data)\n  }\n\n}\n```\n\nProfileVC now only has a display method that will present the changes to the user\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 이제 조립이 시작됩니다, 실제 작업\n\n여기에 모든 구성 요소가 결합됩니다\n\n```js\n// ProfileComposer\n// 이것은 이해하기 쉽도록 가장 간단한 조합 형태입니다\n// 권장하는 방법은 디자인 패턴을 사용하는 것입니다.\n\nfinal class ProfileComposer {\n  func makeProfileVC() {\n    let profileVC = ProfileVC()\n\n    profileVC.load = {\n      imageLoader.loadImage() {\n         imageDecoder.decodeImage() {\n            imageProcessor.processImage() { data in\n                profileVC.displayImage(data)\n            }\n         }\n      }\n    }\n\n    // ProfileVC의 탐색 처리\n\n  }\n}\n```\n\n# 이점은 무엇인가요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 유지 관리성, 재사용성 및 명확성\n\nImageLoader, ImageProcessor 및 ImageResponseHandler와 같은 개별 구성 요소로 기능을 분리하면 유지 관리성이 향상되고 재사용성이 높아지며 명확한 책임을 가지므로 코드 가독성이 향상됩니다.\n\n## 추상화\n\nProfileVC는 특정 데이터 원본과 분리되어 있어 UI 표현에만 집중할 수 있도록 해 유지할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 향상된 테스트 용이성\n\n구성 요소가 격리되면 외부 종속성없이 개별 기능의 심층 테스트 또는 모의적 사용이 가능해집니다.\n\n## 결합도 감소\n\nSRP를 따르면 구성 요소 간 종속성이 최소화되어 의도하지 않은 상호 작용의 위험을 낮추고 시스템의 유연성과 견고함을 향상시킵니다.\n","ogImage":{"url":"/assets/img/2024-06-22-DiveDeepintotheSingleResponsibilityPrinciple_0.png"},"coverImage":"/assets/img/2024-06-22-DiveDeepintotheSingleResponsibilityPrinciple_0.png","tag":["Tech"],"readingTime":7},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<h2>SRP를 수용하는 것이 어떻게 코딩 방법을 변화시키고 확장 가능한 소프트웨어를 이끌어낼 수 있는지 알아보세요.</h2>\n<p><img src=\"/assets/img/2024-06-22-DiveDeepintotheSingleResponsibilityPrinciple_0.png\" alt=\"SRP\"></p>\n<h1>SOLID 원칙이란 무엇인가요?</h1>\n<p>모든 직업에는 준수해야 할 표준과 엄격한 규칙이 있으며, 이를 어기는 경우 중요한 결과가 발생할 수 있습니다.</p>\n<p></p>\n<p>예를 들어, 건축가가 건물 규정을 준수하여 구조물의 안전과 안정성을 보장해야 하는 방법을 생각해보세요.</p>\n<p>이러한 기준들이 왜 만들어졌을까요?</p>\n<ul>\n<li>많은 사람들이 동일한 과정을 거쳤고 그 경험은 모범 사례에 대한 집단적인 이해를 기여합니다.</li>\n<li>표준을 준수하는 것은 실수 가능성을 줄입니다. 전문가들이 따를 수 있는 명확하고 검증된 방법을 제공하여 일관성과 신뢰성을 보장합니다.</li>\n<li>표준은 모든 잠재적인 문제 영역에 대한 지식을 포괄합니다. 이러한 문제를 다루고 완화하는 방식으로 정의되어 있습니다.</li>\n</ul>\n<p>마찬가지로, 소프트웨어 개발에서,</p>\n<p></p>\n<p>SOLID 원칙은 깨끗하고 유지보수가 쉽고 견고한 코드를 작성하기 위한 표준을 제공하기 위해 만들어졌어요.</p>\n<ul>\n<li>이러한 원칙은 많은 개발자들의 경험과 소프트웨어 설계에서 가장 잘 작동하는 것에 대한 지식을 바탕으로 합니다.</li>\n</ul>\n<p>SOLID 원칙을 준수함으로써, 개발자들은 오류를 최소화하고 잠재적인 문제를 해결하며 이해하기 쉽고 확장 및 유지보수가 쉬운 소프트웨어를 만들 수 있어요.</p>\n<h1>단일 책임 원칙(SRP)란 무엇인가요?</h1>\n<p></p>\n<ul>\n<li>이제 모든 개발자는 \"책임\"을 각자 다르게 해석할 수 있습니다</li>\n<li>컴포넌트를 디자인할 때, 한 명의 개발자는 전체 컴포넌트의 생성을 단일 책임으로 간주할 수 있습니다</li>\n<li>또 다른 개발자는 뷰 및 네트워크 호출을 별도의 관심사로 처리하도록 더 세분화된 책임 분할을 옹호할 수 있습니다</li>\n</ul>\n<p>명확하게 하기 위해, 우리는 종종 SRP를 클래스가 하나의 변경 이유만을 가져야 한다는 개념으로 표현합니다.</p>\n<p>간단히 말해서, 클래스가 여러 이유로 수정이 필요한 경우 SRP를 위반합니다.</p>\n<h2>이젠 ProfileVC가 이 원칙을 어기는지 살펴봅시다</h2>\n<p></p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ProfileVC</span>: <span class=\"hljs-title class_\">UIViewController</span> {\n  <span class=\"hljs-keyword\">override</span> <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">viewDidLoad</span>() {\n    fetchImageFromAPI()\n  }\n\n  <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">fetchImageFromAPI</span>() {\n    <span class=\"hljs-type\">APIService</span>.callAPI(with: url) { response <span class=\"hljs-keyword\">in</span>\n      handleResponse(response: response)\n    }\n  }\n\n  <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">handleResponse</span>(<span class=\"hljs-params\">response</span>: <span class=\"hljs-type\">Result</span>&#x3C;<span class=\"hljs-type\">Data</span>, <span class=\"hljs-type\">Error</span>>) {\n    <span class=\"hljs-keyword\">switch</span> response {\n    <span class=\"hljs-keyword\">case</span> .success(<span class=\"hljs-keyword\">let</span> data):\n      processImage(data: data)\n    <span class=\"hljs-keyword\">case</span> .failure(<span class=\"hljs-keyword\">let</span> error):\n      <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Failed to fetch data: <span class=\"hljs-subst\">\\(error)</span>\"</span>)\n   }\n  }\n\n  <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">processImage</span>(<span class=\"hljs-params\">data</span>: <span class=\"hljs-type\">Data</span>) {\n    <span class=\"hljs-comment\">// process image</span>\n    displayDataOnUI(data: data)\n  }\n\n  <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">displayDataOnUI</span>(<span class=\"hljs-params\">data</span>: <span class=\"hljs-type\">Data</span>) {\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Updating UI with data\"</span>)\n  }\n\n}\n</code></pre>\n<p><code>ProfileVC</code>는 다음과 같은 책임을 갖습니다:</p>\n<ul>\n<li>서비스에서 데이터를 가져오기 [위반]</li>\n<li>응답 처리하기 [위반]</li>\n<li>이미지 처리하기 [위반]</li>\n<li>이미지 표시하기 [유효]</li>\n</ul>\n<h1>ProfileVC에 단일 책임 원칙(SPR) 적용해보기</h1>\n<ul>\n<li>ImageLoader</li>\n</ul>\n<p></p>\n<p>// ImageLoader는 오직 한 가지 책임만을 가지고 있습니다.\n// 네트워크에서 이미지를 로드하고 전달하는 것입니다.</p>\n<p>class ImageLoader {</p>\n<p>func fetchImageFromAPI(completion: @escaping ResultCompletion) {\nAPIService.callAPI(with: url) { response in\ncompletion(response)\n}\n}</p>\n<p>}</p>\n<ul>\n<li>ImageDecoder</li>\n</ul>\n<p>// ImageDecoder\n// 사실상, base64 이미지를 파싱하거나\n// 유사한 작업을 통해 다음 해당 인스턴스로 전달할 것입니다.\n// 디코딩 로직이 다른 구성 요소에서 수행되어야 함을 보여주기 위한 예시입니다.</p>\n<p>class ImageDecoder {\nlet result: ResultCompletion</p>\n<p>init(...) {\nself.result = result\n}</p>\n<p>func decodeImage(completion: ...) -> Void) {\nswitch result {\ncase .success(let data):\n// 디코딩 처리\ncompletion(success(data))\ncase .failure(let error):\ncompletion (.failure(error))\n}\n}</p>\n<p>}</p>\n<ul>\n<li>ImageProcessor</li>\n</ul>\n<p></p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// ImageProcessor</span>\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ImageProcessor</span> {\n  <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">imageData</span>: <span class=\"hljs-title class_\">Data</span>\n\n  <span class=\"hljs-title function_\">init</span>(<span class=\"hljs-params\">...</span>) {\n    self.<span class=\"hljs-property\">imageData</span> = imageData\n  }\n\n  func <span class=\"hljs-title function_\">processData</span>(<span class=\"hljs-attr\">completion</span>: ...) -> <span class=\"hljs-title class_\">Void</span>)  {\n    <span class=\"hljs-comment\">// Process image and pass further to the chain</span>\n  }\n\n}\n</code></pre>\n<ul>\n<li>ProfileVC</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// ProfileVC</span>\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ProfileVC</span>: <span class=\"hljs-title class_\">UIViewController</span> {\n\n  <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">load</span>: (() -> <span class=\"hljs-title class_\">Void</span>)?\n\n  func <span class=\"hljs-title function_\">viewDidLoad</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-title function_\">load</span>()\n  }\n\n  func <span class=\"hljs-title function_\">displayImage</span>(_ <span class=\"hljs-attr\">data</span>: <span class=\"hljs-title class_\">Data</span>) -> <span class=\"hljs-title class_\">Void</span>)  {\n    profileImage.<span class=\"hljs-property\">image</span> = <span class=\"hljs-title class_\">UIImageFromData</span>(data)\n  }\n\n}\n</code></pre>\n<p>ProfileVC now only has a display method that will present the changes to the user</p>\n<p></p>\n<h2>이제 조립이 시작됩니다, 실제 작업</h2>\n<p>여기에 모든 구성 요소가 결합됩니다</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// ProfileComposer</span>\n<span class=\"hljs-comment\">// 이것은 이해하기 쉽도록 가장 간단한 조합 형태입니다</span>\n<span class=\"hljs-comment\">// 권장하는 방법은 디자인 패턴을 사용하는 것입니다.</span>\n\nfinal <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ProfileComposer</span> {\n  func <span class=\"hljs-title function_\">makeProfileVC</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">let</span> profileVC = <span class=\"hljs-title class_\">ProfileVC</span>()\n\n    profileVC.<span class=\"hljs-property\">load</span> = {\n      imageLoader.<span class=\"hljs-title function_\">loadImage</span>(<span class=\"hljs-params\"></span>) {\n         imageDecoder.<span class=\"hljs-title function_\">decodeImage</span>(<span class=\"hljs-params\"></span>) {\n            imageProcessor.<span class=\"hljs-title function_\">processImage</span>(<span class=\"hljs-params\"></span>) { data <span class=\"hljs-keyword\">in</span>\n                profileVC.<span class=\"hljs-title function_\">displayImage</span>(data)\n            }\n         }\n      }\n    }\n\n    <span class=\"hljs-comment\">// ProfileVC의 탐색 처리</span>\n\n  }\n}\n</code></pre>\n<h1>이점은 무엇인가요?</h1>\n<p></p>\n<h2>유지 관리성, 재사용성 및 명확성</h2>\n<p>ImageLoader, ImageProcessor 및 ImageResponseHandler와 같은 개별 구성 요소로 기능을 분리하면 유지 관리성이 향상되고 재사용성이 높아지며 명확한 책임을 가지므로 코드 가독성이 향상됩니다.</p>\n<h2>추상화</h2>\n<p>ProfileVC는 특정 데이터 원본과 분리되어 있어 UI 표현에만 집중할 수 있도록 해 유지할 수 있습니다.</p>\n<p></p>\n<h2>향상된 테스트 용이성</h2>\n<p>구성 요소가 격리되면 외부 종속성없이 개별 기능의 심층 테스트 또는 모의적 사용이 가능해집니다.</p>\n<h2>결합도 감소</h2>\n<p>SRP를 따르면 구성 요소 간 종속성이 최소화되어 의도하지 않은 상호 작용의 위험을 낮추고 시스템의 유연성과 견고함을 향상시킵니다.</p>\n</body>\n</html>\n"},"__N_SSG":true}