{"pageProps":{"post":{"title":"한 줄의 코드로 Python 함수를 데코레이터로 바꿔보세요","description":"","date":"2024-05-27 16:18","slug":"2024-05-27-TurnYourPythonFunctionintoaDecoratorwithOneLineofCode","content":"\n![이미지](/assets/img/2024-05-27-TurnYourPythonFunctionintoaDecoratorwithOneLineofCode_0.png)\n\n데코레이터를 작성하고 싶지만 구문을 기억하지 못하시나요? 데코레이터는 많은 보일러플레이트 코드가 포함된 꽤 어려운 구문을 갖고 있습니다. 이 기사에서는 데코레이터를 작성하는 더 간단한 방법을 소개합니다. 이 새로운 방법은 훨씬 더 짧고 명확하며 가독성이 뛰어날 것입니다. 함께 코딩해봅시다!\n\n# 데코레이터 작성의 기본 방법\n\n아래 코드는 데코레이터를 생성하는 기본 방법입니다. 데코레이터로 래핑된 함수가 실행되는 시간을 측정합니다. 깊이 파고든 이 기사를 확인해보세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\ndef timer(name:str) -> Callable:\ndef decorator(func:Callable) -> Callable:\n@wraps(func)\ndef decorator_implementation(*args, \\*\\*kwargs):\ntry:\nprint(f\"TIMER: {name} start\")\nstrt = time.perf_counter()\nreturn func(*args, \\*\\*kwargs)\nfinally:\nprint(f\"TIMER: {name} finished in {time.perf_counter() - strt}\")\nreturn decorator_implementation\nreturn decorator\n\n이렇게 하면 코드를 다음과 같이 사용할 수 있습니다:\n\n```js\n@timer(name=\"test\")\ndef my_func(name:str, age:int) -> str:\n    return f\"{name} is {age} years old\"\n\nmy_func(name=\"mike\", age=34)\n# TIMER:   test start\n# mike is 34 years old\n# TIMER:   test finished in 5.299999999998532e-06\n```\n\n## 이 접근 방식의 문제점은 무엇인가요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저는 개발자이며 개인적으로 데코레이터를 작성하는 방법을 항상 기억하지 못하고 이전 프로젝트에서 코드를 복사하여 붙여넣어야 합니다. 이는 3개의 중첩된 함수가 포함된 약간 읽기 어려운 구문 때문에 데코레이터를 이해하기 어렵게 만들기 때문이라고 생각합니다. 우리는 이를 어떻게 단순화할 수 있는지 알아보겠습니다.\n\n# 데코레이터를 작성하는 더 쉬운 방법\n\n아래 구현은 이전 섹션의 데코레이터와 정확히 동일한 작업을 하지만 한 가지 함수만 사용합니다. 이는 훨씬 더 읽기 쉽고 @contextmanager 데코레이터를 추가하고 함수를 생성기로 변환하는 것으로 처리됩니다.\n\n```python\n@contextmanager\ndef timer(name:str) -> Generator:\n    try:\n        print(f\"TIMER:   {name} start\")\n        strt = time.perf_counter()\n        yield\n    finally:\n        print(f\"TIMER:   {name} finished in {time.perf_counter() - strt}\")\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n모두 같은 방식으로 함수를 사용할 수 있어요:\n\n```js\n@timer(name=\"AS DEC\")\ndef my_func(name:str, age:int) -> str:\n    return f\"{name}은(는) {age}살이야\"\n\n\nmy_func(name=\"마이크\", age=34)\n# TIMER:   AS DEC 시작\n# 마이크은(는) 34살이야\n# TIMER:   AS DEC 5.399999999995686e-06초 내에 완료됨\n```\n\n## 컨텍스트 매니저로서의 기능\n\n개인적으로 새로운 함수가 더 읽기 쉽고 이해하기 쉽다고 생각해요. 몇 가지 간단한 변경이 필요하지만 그만큼 다양한 기능을 제공해요. 함수에 데코레이터를 적용하는 것이 훨씬 쉬워지고 데코레이터 함수(예: 위의 timer)를 데코레이터 및 컨텍스트 매니저로 모두 사용할 수도 있어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n타이머와 함께(context manager와 함께)\n\n우리는 동일한 데코레이터 함수를 데코레이터 및 context-manager로도 사용할 수 있습니다.\n\n```js\nas ctx라는 이름의 타이머와 함께:\n    fn_with_ctx_decorator(name=\"john\", age=42)\n    print(\"컨텍스트 매니저 내부\")\n\n# 타이머:  as ctx 시작\n# 타이머:  AS DEC 시작\n# john은 42살입니다\n# 타이머:  AS DEC가 3.7000000000023126e-06초에 완료되었습니다\n# 컨텍스트 매니저 내부\n# 타이머:  as ctx가 3.0000000000002247e-05초에 완료되었습니다\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 어떻게 작동합니까?\n\n내부적으로 contextlib은 @contextmanager를 사용하여 우리의 데커레이터 함수를 감싸서 데커레이터와 컨텍스트 매니저 역할을 하는 객체로 만들어줍니다. 이 작업 방식은 꽤 기술적이고 매우 흥미로우며 독립된 기사가 필요합니다. 계속 따라와주세요!\n\n이 기사의 범위에서는 contextlib이 @contextmanager 데코레이터를 사용하여 데커레이터 함수를 데커레이터와 컨텍스트 매니저로 모두 사용할 수 있는 객체로 변환한다는 것만 알면 됩니다.\n\n## 단점\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n새 데코레이터는 많은 기능을 제공하지만 몇 가지 단점이 있습니다. 그 중 가장 중요한 것은 데코레이터 함수 내에서 실제로 데코레이션하는 함수에 액세스할 수 없다는 점입니다. 또한 해당 함수의 args와 kwargs에 액세스할 수도 없습니다. 이로 인해 이러한 변수를 수정할 수 없지만 제 생각에는 이를 드물게 해야 하는 것입니다.\n\n두 번째 단점은 데코레이터 함수가 제너레이터 함수여야 한다는 점입니다. 이는 해당 함수가 본문에서 어딘가에 yield해야 한다는 의미입니다. 이로 인해 코드를 다시 작성해야 할 수도 있습니다.\n\n# 결론\n\n@contextmanager를 사용하면 데코레이터를 쉽고 가독성있게 작성할 수 있습니다. 많은 쓰기 장치를 처리해주며 심지어 콘텍스트 매니저 역할도 수행합니다. 그러나 이 자동화와 \"하드코딩된 마법\"으로 인해 함수와 인수에 액세스할 수 있는 제어를 일부 상실하게 됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\ncontextlib은 내부에서 작동하는 방식이 상당히 복잡하며 별도의 기사가 필요하므로 관심이 있다면 저를 따라오세요!\n\n이 기사가 제가 희망하는 대로 명확하게 전달되었기를 바라지만, 그렇지 않은 경우 추가 설명이 필요하다면 알려주세요. 그동안 다른 주제들에 대한 제 다른 기사들도 확인해보세요:\n\n- 절대 초보자를 위한 Git: 비디오 게임의 도움으로 Git 이해하기\n- 나만의 Python 패키지 작성 및 게시\n- FastAPI를 사용해 5줄의 코드로 빠르고 자동 문서화되고 유지보수 가능한 쉽게 사용할 수 있는 Python API 만들기\n\n즐거운 코딩 되세요!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- Mike\n\nP.S: 제 하는 일 좋아하시나요? 제 팔로우 해주세요!\n","ogImage":{"url":"/assets/img/2024-05-27-TurnYourPythonFunctionintoaDecoratorwithOneLineofCode_0.png"},"coverImage":"/assets/img/2024-05-27-TurnYourPythonFunctionintoaDecoratorwithOneLineofCode_0.png","tag":["Tech"],"readingTime":6},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p><img src=\"/assets/img/2024-05-27-TurnYourPythonFunctionintoaDecoratorwithOneLineofCode_0.png\" alt=\"이미지\"></p>\n<p>데코레이터를 작성하고 싶지만 구문을 기억하지 못하시나요? 데코레이터는 많은 보일러플레이트 코드가 포함된 꽤 어려운 구문을 갖고 있습니다. 이 기사에서는 데코레이터를 작성하는 더 간단한 방법을 소개합니다. 이 새로운 방법은 훨씬 더 짧고 명확하며 가독성이 뛰어날 것입니다. 함께 코딩해봅시다!</p>\n<h1>데코레이터 작성의 기본 방법</h1>\n<p>아래 코드는 데코레이터를 생성하는 기본 방법입니다. 데코레이터로 래핑된 함수가 실행되는 시간을 측정합니다. 깊이 파고든 이 기사를 확인해보세요.</p>\n<p></p>\n<p>def timer(name:str) -> Callable:\ndef decorator(func:Callable) -> Callable:\n@wraps(func)\ndef decorator_implementation(*args, **kwargs):\ntry:\nprint(f\"TIMER: {name} start\")\nstrt = time.perf_counter()\nreturn func(*args, **kwargs)\nfinally:\nprint(f\"TIMER: {name} finished in {time.perf_counter() - strt}\")\nreturn decorator_implementation\nreturn decorator</p>\n<p>이렇게 하면 코드를 다음과 같이 사용할 수 있습니다:</p>\n<pre><code class=\"hljs language-js\">@<span class=\"hljs-title function_\">timer</span>(name=<span class=\"hljs-string\">\"test\"</span>)\ndef <span class=\"hljs-title function_\">my_func</span>(<span class=\"hljs-attr\">name</span>:str, <span class=\"hljs-attr\">age</span>:int) -> <span class=\"hljs-attr\">str</span>:\n    <span class=\"hljs-keyword\">return</span> f<span class=\"hljs-string\">\"{name} is {age} years old\"</span>\n\n<span class=\"hljs-title function_\">my_func</span>(name=<span class=\"hljs-string\">\"mike\"</span>, age=<span class=\"hljs-number\">34</span>)\n# <span class=\"hljs-attr\">TIMER</span>:   test start\n# mike is <span class=\"hljs-number\">34</span> years old\n# <span class=\"hljs-attr\">TIMER</span>:   test finished <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">5.299999999998532e-06</span>\n</code></pre>\n<h2>이 접근 방식의 문제점은 무엇인가요?</h2>\n<p></p>\n<p>저는 개발자이며 개인적으로 데코레이터를 작성하는 방법을 항상 기억하지 못하고 이전 프로젝트에서 코드를 복사하여 붙여넣어야 합니다. 이는 3개의 중첩된 함수가 포함된 약간 읽기 어려운 구문 때문에 데코레이터를 이해하기 어렵게 만들기 때문이라고 생각합니다. 우리는 이를 어떻게 단순화할 수 있는지 알아보겠습니다.</p>\n<h1>데코레이터를 작성하는 더 쉬운 방법</h1>\n<p>아래 구현은 이전 섹션의 데코레이터와 정확히 동일한 작업을 하지만 한 가지 함수만 사용합니다. 이는 훨씬 더 읽기 쉽고 @contextmanager 데코레이터를 추가하고 함수를 생성기로 변환하는 것으로 처리됩니다.</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-meta\">@contextmanager</span>\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">timer</span>(<span class=\"hljs-params\">name:<span class=\"hljs-built_in\">str</span></span>) -> Generator:\n    <span class=\"hljs-keyword\">try</span>:\n        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f\"TIMER:   <span class=\"hljs-subst\">{name}</span> start\"</span>)\n        strt = time.perf_counter()\n        <span class=\"hljs-keyword\">yield</span>\n    <span class=\"hljs-keyword\">finally</span>:\n        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f\"TIMER:   <span class=\"hljs-subst\">{name}</span> finished in <span class=\"hljs-subst\">{time.perf_counter() - strt}</span>\"</span>)\n</code></pre>\n<p></p>\n<p>모두 같은 방식으로 함수를 사용할 수 있어요:</p>\n<pre><code class=\"hljs language-js\">@<span class=\"hljs-title function_\">timer</span>(name=<span class=\"hljs-string\">\"AS DEC\"</span>)\ndef <span class=\"hljs-title function_\">my_func</span>(<span class=\"hljs-attr\">name</span>:str, <span class=\"hljs-attr\">age</span>:int) -> <span class=\"hljs-attr\">str</span>:\n    <span class=\"hljs-keyword\">return</span> f<span class=\"hljs-string\">\"{name}은(는) {age}살이야\"</span>\n\n\n<span class=\"hljs-title function_\">my_func</span>(name=<span class=\"hljs-string\">\"마이크\"</span>, age=<span class=\"hljs-number\">34</span>)\n# <span class=\"hljs-attr\">TIMER</span>:   <span class=\"hljs-variable constant_\">AS</span> <span class=\"hljs-variable constant_\">DEC</span> 시작\n# 마이크은(는) <span class=\"hljs-number\">34</span>살이야\n# <span class=\"hljs-attr\">TIMER</span>:   <span class=\"hljs-variable constant_\">AS</span> <span class=\"hljs-variable constant_\">DEC</span> <span class=\"hljs-number\">5.399999999995686e-06</span>초 내에 완료됨\n</code></pre>\n<h2>컨텍스트 매니저로서의 기능</h2>\n<p>개인적으로 새로운 함수가 더 읽기 쉽고 이해하기 쉽다고 생각해요. 몇 가지 간단한 변경이 필요하지만 그만큼 다양한 기능을 제공해요. 함수에 데코레이터를 적용하는 것이 훨씬 쉬워지고 데코레이터 함수(예: 위의 timer)를 데코레이터 및 컨텍스트 매니저로 모두 사용할 수도 있어요.</p>\n<p></p>\n<p>타이머와 함께(context manager와 함께)</p>\n<p>우리는 동일한 데코레이터 함수를 데코레이터 및 context-manager로도 사용할 수 있습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">as</span> ctx라는 이름의 타이머와 함께:\n    <span class=\"hljs-title function_\">fn_with_ctx_decorator</span>(name=<span class=\"hljs-string\">\"john\"</span>, age=<span class=\"hljs-number\">42</span>)\n    <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">\"컨텍스트 매니저 내부\"</span>)\n\n# 타이머:  <span class=\"hljs-keyword\">as</span> ctx 시작\n# 타이머:  <span class=\"hljs-variable constant_\">AS</span> <span class=\"hljs-variable constant_\">DEC</span> 시작\n# john은 <span class=\"hljs-number\">42</span>살입니다\n# 타이머:  <span class=\"hljs-variable constant_\">AS</span> <span class=\"hljs-variable constant_\">DEC</span>가 <span class=\"hljs-number\">3.7000000000023126e-06</span>초에 완료되었습니다\n# 컨텍스트 매니저 내부\n# 타이머:  <span class=\"hljs-keyword\">as</span> ctx가 <span class=\"hljs-number\">3.0000000000002247e-05</span>초에 완료되었습니다\n</code></pre>\n<p></p>\n<h1>어떻게 작동합니까?</h1>\n<p>내부적으로 contextlib은 @contextmanager를 사용하여 우리의 데커레이터 함수를 감싸서 데커레이터와 컨텍스트 매니저 역할을 하는 객체로 만들어줍니다. 이 작업 방식은 꽤 기술적이고 매우 흥미로우며 독립된 기사가 필요합니다. 계속 따라와주세요!</p>\n<p>이 기사의 범위에서는 contextlib이 @contextmanager 데코레이터를 사용하여 데커레이터 함수를 데커레이터와 컨텍스트 매니저로 모두 사용할 수 있는 객체로 변환한다는 것만 알면 됩니다.</p>\n<h2>단점</h2>\n<p></p>\n<p>새 데코레이터는 많은 기능을 제공하지만 몇 가지 단점이 있습니다. 그 중 가장 중요한 것은 데코레이터 함수 내에서 실제로 데코레이션하는 함수에 액세스할 수 없다는 점입니다. 또한 해당 함수의 args와 kwargs에 액세스할 수도 없습니다. 이로 인해 이러한 변수를 수정할 수 없지만 제 생각에는 이를 드물게 해야 하는 것입니다.</p>\n<p>두 번째 단점은 데코레이터 함수가 제너레이터 함수여야 한다는 점입니다. 이는 해당 함수가 본문에서 어딘가에 yield해야 한다는 의미입니다. 이로 인해 코드를 다시 작성해야 할 수도 있습니다.</p>\n<h1>결론</h1>\n<p>@contextmanager를 사용하면 데코레이터를 쉽고 가독성있게 작성할 수 있습니다. 많은 쓰기 장치를 처리해주며 심지어 콘텍스트 매니저 역할도 수행합니다. 그러나 이 자동화와 \"하드코딩된 마법\"으로 인해 함수와 인수에 액세스할 수 있는 제어를 일부 상실하게 됩니다.</p>\n<p></p>\n<p>contextlib은 내부에서 작동하는 방식이 상당히 복잡하며 별도의 기사가 필요하므로 관심이 있다면 저를 따라오세요!</p>\n<p>이 기사가 제가 희망하는 대로 명확하게 전달되었기를 바라지만, 그렇지 않은 경우 추가 설명이 필요하다면 알려주세요. 그동안 다른 주제들에 대한 제 다른 기사들도 확인해보세요:</p>\n<ul>\n<li>절대 초보자를 위한 Git: 비디오 게임의 도움으로 Git 이해하기</li>\n<li>나만의 Python 패키지 작성 및 게시</li>\n<li>FastAPI를 사용해 5줄의 코드로 빠르고 자동 문서화되고 유지보수 가능한 쉽게 사용할 수 있는 Python API 만들기</li>\n</ul>\n<p>즐거운 코딩 되세요!</p>\n<p></p>\n<ul>\n<li>Mike</li>\n</ul>\n<p>P.S: 제 하는 일 좋아하시나요? 제 팔로우 해주세요!</p>\n</body>\n</html>\n"},"__N_SSG":true}