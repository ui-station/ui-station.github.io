{"pageProps":{"post":{"title":"서버리스 EventBridge Pipes로 이벤트 처리하는 방법 최신 2024","description":"","date":"2024-06-23 22:26","slug":"2024-06-23-ServerlessEventBridgePipes","content":"\n<img src=\"/assets/img/2024-06-23-ServerlessEventBridgePipes_0.png\" />\n\n## 안내\n\n✔️ Amazon EventBridge Pipes 및 그들이 무엇인지에 대해 논의합니다.\n✔️ Python 및 AWS CDK를 사용한 예제를 통해 안내합니다.\n\n# 소개 👋🏽\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 기사에서는 AWS CDK와 Python을 사용하여 구축된 허구의 치과 앱을 만들어가면서 Amazon EventBridge Pipes에 대해 다뤄볼 것입니다.\n\n![이미지](/assets/img/2024-06-23-ServerlessEventBridgePipes_1.png)\n\n'LJ 치과 의사' 앱은 사람들이 가장 가까운 치과 의사와 예약을 잡을 수 있는 기능을 제공합니다.\n\n![이미지](/assets/img/2024-06-23-ServerlessEventBridgePipes_2.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그들이 이미 방문한 적이 있는 경우에는 이메일, SMS 또는 통신 없음을 보내기 전에 선호하는 연락 방법을 확인합니다. 이 모두는 Amazon EventBridge Pipes를 사용하여 처리됩니다.\n\n![이미지](/assets/img/2024-06-23-ServerlessEventBridgePipes_3.png)\n\n이 기사의 전체 코드 예제는 여기에서 확인할 수 있습니다:\n\n# 우리가 무엇을 만들고 있나요? 🛠️\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n환자들이 온라인으로 진료 예약을 할 수 있도록 다음 아키텍처를 사용할 예정입니다:\n\n![아키텍처](/assets/img/2024-06-23-ServerlessEventBridgePipes_4.png)\n\n환자들이 다음을 사용하여 진료를 예약할 수 있습니다:\n\n- Amazon API Gateway REST API를 사용하여 온라인으로 진료 예약을 합니다.\n- Lambda 함수가 진료 상세 내용을 DynamoDB 테이블에 기록합니다.\n- 우리는 DynamoDB 스트림을 사용하여 테이블의 변경 사항을 감지하고 레코드가 생성되었을 경우에만 필터링하여 Amazon EventBridge Pipes를 통해 해당 스트림을 소스로 사용합니다.\n- 일치하는 레코드가 연락처 선호도 테이블에 있는지 확인하는 Lambda 함수를 호출하여 스트림 레코드에 선호도를 추가합니다.\n- 마지막으로, Amazon EventBridge Pipes의 대상은 SQS로 설정되어 진료를 처리하기 위해 준비된 예약을 저장합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n👇 더 진전하기 전에 — 향후 블로그 게시물과 서버리스 뉴스를 만나보기 위해 LinkedIn에 연락해 주세요 https://www.linkedin.com/in/lee-james-gilmore/\n\n![ServerlessEventBridgePipes_5](/assets/img/2024-06-23-ServerlessEventBridgePipes_5.png)\n\n# Amazon EventBridge Pipes란 무엇인가요?\n\nAmazon EventBridge Pipes는 옵션 변환, 필터 및 풍부한 단계를 통해 이벤트 생성자와 소비자 간의 포인트 투 포인트 통합을 생성하는 데 도움을 줍니다. EventBridge Pipes를 사용하면 이벤트 중심 애플리케이션을 구축할 때 필요한 통합 코드 양을 줄이고 유지할 수 있습니다. 아래 다이어그램은 우리 예시를 위해 이를 보여줍니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위 다이어그램에서 알 수 있듯이 다음이 있습니다:\n\n- 소스로 DynamoDB 스트림을 사용합니다.\n- 새로 삽입된 레코드만 받도록 추가 필터링을 수행합니다(예: 삭제 또는 업데이트 제외).\n- 별도의 데이터베이스에서 연락처 정보를 읽는 enrichment Lambda 함수를 통해 스트림에서 약속 데이터를 추가 정보로 향상시킵니다.\n- 최종적으로 약속 레코드를 더 처리하기 위해 SQS 대기열로 설정된 대상이 있습니다.\n\n참고로 아래에 표시된 다양한 서비스와 구성을 사용할 수 있습니다:\n\n![이미지](/assets/img/2024-06-23-ServerlessEventBridgePipes_6.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 주요 코드 설명하기 👨‍💻\n\n이제 몇 가지 주요 코드에 대해 이야기해봅시다.\n\n아래에서 볼 수 있는대로 CDK 애플리케이션을 상태(Stateful) 및 상태 없음(Stateless) 리소스(스택)로 분리하기 시작합니다:\n\n```js\n#!/usr/bin/env python3\nimport os\n\nimport aws_cdk as cdk\nfrom stateful.stateful import DentistsStatefulStack\nfrom stateless.stateless import DentistsStatelessStack\n\napp = cdk.App()\n\n# 앱을 상태(Stateful) 및 상태 없음(Stateless) 리소스로 분리합니다\nDentistsStatefulStack(app, \"DentistsStatefulStack\")\nDentistsStatelessStack(app, \"DentistsStatelessStack\")\n\napp.synth()\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nStateful 스택을 먼저 살펴 보면, 두 개의 DynamoDB 테이블을 설정했음을 알 수 있습니다. 하나는 약속을, 다른 하나는 선호하는 연락처 세부 정보를 저장하는 테이블입니다:\n\n```js\nfrom aws_cdk import CfnOutput, RemovalPolicy, Stack\nfrom aws_cdk import aws_dynamodb as dynamodb\nfrom constructs import Construct\n\nclass DentistsStatefulStack(Stack):\n\n    def __init__(self, scope: Construct, construct_id: str, **kwargs) -> None:\n        super().__init__(scope, construct_id, **kwargs)\n\n        # 약속을 저장하는 DynamoDB 테이블 추가 및 스트림 활성화\n        table = dynamodb.Table(\n            self, 'DentistTable',\n            billing_mode=dynamodb.BillingMode.PAY_PER_REQUEST,\n            table_name='DentistTable',\n            stream=dynamodb.StreamViewType.NEW_IMAGE,\n            removal_policy=RemovalPolicy.DESTROY,\n            partition_key=dynamodb.Attribute(\n                name='id',\n                type=dynamodb.AttributeType.STRING\n            )\n        )\n\n        # 이메일 주소를 기반으로 하는 연락 선호도 DynamoDB 테이블 추가\n        contact_table = dynamodb.Table(\n            self, 'DentistContactsTable',\n            billing_mode=dynamodb.BillingMode.PAY_PER_REQUEST,\n            table_name='DentistContactsTable',\n            removal_policy=RemovalPolicy.DESTROY,\n            partition_key=dynamodb.Attribute(\n                name='id',\n                type=dynamodb.AttributeType.STRING\n            )\n        )\n\n        # 테이블 이름을 위한 스택 출력 추가\n        CfnOutput(\n            self, 'DentistDynamoDBTableName',\n            value=table.table_name,\n            description='DynamoDB 테이블 이름',\n            export_name='DentistDynamoDBTableName'\n        )\n\n        # 연락처 테이블 이름을 위한 스택 출력 추가\n        CfnOutput(\n            self, 'DentistContactDynamoDBTableName',\n            value=contact_table.table_name,\n            description='연락 선호도 DynamoDB 테이블 이름',\n            export_name='DentistContactDynamoDBTableName'\n        )\n\n        # 약속 테이블의 테이블 스트림 ARN을 위한 스택 출력 추가\n        CfnOutput(\n            self, 'DentistDynamoDBTableStreamArn',\n            value=table.table_stream_arn,\n            description='DynamoDB 테이블 스트림 ARN',\n            export_name='DentistDynamoDBTableStreamArn'\n        )\n```\n\n이제 Stateful 리소스가 설정됐으므로, Stateless 스택에서 먼저 약속을 생성하는 람다 함수를 생성합니다:\n\n```js\n# 약속을 생성하는 람다 함수 생성\ncreate_appointment_lambda = aws_lambda.Function(\n    self, 'CreateAppointment',\n    runtime=aws_lambda.Runtime.PYTHON_3_12,\n    handler='create_appointment.handler',\n    code=aws_lambda.Code.from_asset(os.path.join(DIRNAME, 'src')),\n    function_name='CreateAppointment',\n    environment={\n        'dynamodb_table': dynamodb_table_name,\n    },\n)\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nLambda 함수에 추가적으로 두 번째 Lambda 함수를 추가합니다. 이 함수는 DynamoDB 스트림이 제공하는 데이터를 풍부하게 하는 데 사용될 것입니다:\n\n```js\n# 연락처 세부 정보를 검색하는 람다 함수 생성\nget_contact_details = aws_lambda.Function(\n    self, 'GetContactDetails',\n    runtime=aws_lambda.Runtime.PYTHON_3_12,\n    handler='get_contact_details.handler',\n    code=aws_lambda.Code.from_asset(os.path.join(DIRNAME, 'src')),\n    function_name='GetContactDetails',\n    environment={\n        'contacts_dynamodb_table': contacts_dynamodb_table_name,\n    },\n)\n```\n\n다음으로, 우리의 파이프 대상이 될 Amazon SQS 대기열을 추가합니다:\n\n```js\n# AppointmentsQueue로 메시지를 보낼 SQS 대기열 생성\nsqs_queue = sqs.Queue(\n    self, 'AppointmentsQueue',\n    queue_name='AppointmentsQueue',\n    removal_policy=RemovalPolicy.DESTROY\n)\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그럼 Amazon EventBridge 파이프 자체에 대한 IAM 정책을 만들어서 원본, 보강 및 대상 자원과 연결할 수 있도록합니다.\n\n```js\n# 파이프 원본(다이나모DB 스트림)용 파이프 정책과 역할 생성\npipe_source_policy = iam.PolicyStatement(\n    actions=[\n        'dynamodb:DescribeStream',\n        'dynamodb:GetRecords',\n        'dynamodb:GetShardIterator',\n        'dynamodb:ListStreams'\n    ],\n    resources=[stream_arn],\n    effect=iam.Effect.ALLOW\n)\n\n# 파이프 대상(SQS)으로 메시지를 게시하는 것을 허용하는 대상 정책 작성\npipe_target_policy = iam.PolicyStatement(\n    actions=['sqs:SendMessage'],\n    resources=[sqs_queue.queue_arn],\n    effect=iam.Effect.ALLOW\n)\n\n# 파이프가 람다 기능을 호출할 수 있도록 하는 보강 정책 생성\npipe_enrichment_policy = iam.PolicyStatement(\n    actions=['lambda:InvokeFunction'],\n    resources=[get_contact_details.function_arn],\n    effect=iam.Effect.ALLOW\n)\n\n# 파이프 역할 생성\npipe_role = iam.Role(self, 'PipeRole',\n    assumed_by=iam.ServicePrincipal('pipes.amazonaws.com'),\n)\n\n# 역할에 세 가지 정책 추가\npipe_role.add_to_policy(pipe_source_policy)\npipe_role.add_to_policy(pipe_target_policy)\npipe_role.add_to_policy(pipe_enrichment_policy)\n```\n\n이제 다음과 같은 코드를 사용하여 파이프를 생성할 수 있습니다:\n\n```js\n# 다이나모DB의 새 항목에 대한 필터가 있는 이벤트브릿지 파이프 생성\npipe = pipes.CfnPipe(self, 'Pipe',\n    role_arn=pipe_role.role_arn,\n    source=stream_arn,\n    log_configuration=pipes.CfnPipe.PipeLogConfigurationProperty(\n        cloudwatch_logs_log_destination=pipes.CfnPipe.CloudwatchLogsLogDestinationProperty(\n            log_group_arn=log_group.log_group_arn\n        ),\n        level='INFO',\n    ),\n    name='DentistPipe',\n    source_parameters=pipes.CfnPipe.PipeSourceParametersProperty(\n        dynamo_db_stream_parameters=pipes.CfnPipe.PipeSourceDynamoDBStreamParametersProperty(\n            starting_position='LATEST',\n        ),\n        filter_criteria=pipes.CfnPipe.FilterCriteriaProperty(\n            filters=[pipes.CfnPipe.FilterProperty(\n                pattern=json.dumps({'eventName': [{ 'prefix': 'INSERT' }])\n            )]\n        ),\n    ),\n    enrichment=get_contact_details.function_arn,\n    target=sqs_queue.queue_arn,\n)\npipe.apply_removal_policy(RemovalPolicy.DESTROY)\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n현재 인프라가 모두 설정되어 있지만 'create_appointment.py' 파일을 시작으로 Lambda 함수 코드를 간단히 살펴보겠습니다.\n\n```js\nimport json\nimport os\nimport uuid\nfrom http import HTTPStatus\n\nimport boto3\nfrom boto3.dynamodb.types import TypeSerializer\n\ndynamodb_table = os.getenv('dynamodb_table')\ndynamodb_client = boto3.client('dynamodb')\nserializer = TypeSerializer()\n\ndef handler(event, context):\n    try:\n        # 이벤트에서 요청 데이터를 구문 분석하고 본문을 가져옵니다.\n        request_data = json.loads(event['body'])\n\n        # uuidv4를 사용하여 새로운 약속 ID를 추가합니다.\n        request_data['id'] = str(uuid.uuid4())\n\n        # 페이로드를 dynamodb 형식으로 직렬화합니다.\n        appointment_data = {k: serializer.serialize(v) for k, v in request_data.items()}\n\n        # 항목을 dynamodb 테이블에 추가합니다.\n        dynamodb_client.put_item(TableName=dynamodb_table, Item=appointment_data)\n\n        body = {\n            'message': request_data,\n            'statusCode': HTTPStatus.CREATED,\n        }\n\n        # 응답을 올바른 형식으로 API Gateway로 전송합니다.\n        response = {\n            'statusCode': HTTPStatus.CREATED,\n            'body': json.dumps(body, indent=2),\n            'headers': {\n                'content-type': 'application/json',\n            },\n        }\n\n    except Exception as e:\n        response = {\n            'statusCode': HTTPStatus.INTERNAL_SERVER_ERROR.value,\n            'body': f'Exception={e}',\n        }\n\n    return response\n```\n\n위 코드에서 볼 수 있듯, API Gateway 이벤트에서 약속을 가져와 새로운 고유 ID(uuid)를 추가하고 레코드를 약속 테이블에 기록하는 기본 함수를 생성합니다.\n\n테이블에 레코드가 추가되면 스트림이 호출되어 모든 레코드 변경에 대해 파이프가 변경 사항을 소스로 가져올 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그 다음으로, 파이프의 일부로 호출되는 Enrichment 람다 함수를 살펴보겠습니다:\n\n위 코드에서 볼 수 있듯이, 스트림 레코드에서 email_address 속성을 가져와 우리가 선호하는 연락처 DynamoDB 테이블에서 조회합니다. 레코드가 존재하면, 선호하는 방법을 가져와 약속 레코드에 추가합니다. 일치하는 레코드가 없으면, preferredMethod를 'none'으로 추가합니다.\n\n엔드 투 엔드로 테스트하려면, 애플리케이션을 배포하고 Contacts DynamoDb 테이블에 다음 항목을 추가하면 preferredMethod를 추가할 수 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```json\n{\n  \"id\": \"john.doe@example.com\",\n  \"preferredMethod\": \"email\"\n}\n```\n\n만약 레코드가 존재하지 않는다면 이전에 언급한 대로 'none'으로 기본 설정됩니다.\n\n# 결론\n\nAmazon EventBridge 파이프를 사용하는 실제 예시로 서버리스 솔루션에서의 사용법을 보여드려 유용하게 찾으셨기를 희망합니다. 파이프를 사용하면 이전에 사용해야 했던 람다 접착 코드를 제거할 수 있고 소스에서 데이터를 추출하여 해당 데이터를 타깃으로 전달하는 훌륭한 방법을 제공합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 마무리 👋🏽\n\n이 글을 즐겁게 보았으면 공유하고 피드백을 남겨주세요!\n\n비슷한 콘텐츠를 더 보시려면 제 YouTube 채널을 구독해주세요!\n\n<img src=\"/assets/img/2024-06-23-ServerlessEventBridgePipes_7.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n당신과 어느 하나라도 다음에서도 연결하고 싶어요:\n\n- [LinkedIn](https://www.linkedin.com/in/lee-james-gilmore/)\n- [Twitter](https://twitter.com/LeeJamesGilmore)\n\n포스트를 즐겼다면 추가로 포스트/시리즈를 보기 위해 내 프로필 Lee James Gilmore를 팔로우해주세요. 그리고 인사를 건네고 싶다면 절대 잊지 말고 연락해주세요 👋\n\n좋았다면 포스트 하단에 있는 '박수' 기능을 사용해주세요! (한 번 이상 박수를 칠 수 있어요!!)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 제 소개\n\n안녕하세요, 저는 영국에 거주하고 있는 AWS 커뮤니티 빌더이자 블로거인 Lee입니다. AWS 인증 클라우드 아키텍트이며 City Electrical Factors (UK) 및 City Electric Supply (US)에서 글로벌 기술 및 아키텍처 책임자로 일하고 있습니다. 지난 6년간 주로 AWS에서 풀스택 JavaScript를 사용해 왔습니다.\n\n저는 서버리스를 지지하는 사람으로, AWS, 혁신, 소프트웨어 아키텍처, 기술에 대한 애정이 있습니다.\n\n**_ 제공된 정보는 제 개인적인 견해이며 해당 정보 사용에 대한 책임을 지지 않습니다. _**\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래 내용도 참고하시면 좋을 것 같아요:\n","ogImage":{"url":"/assets/img/2024-06-23-ServerlessEventBridgePipes_0.png"},"coverImage":"/assets/img/2024-06-23-ServerlessEventBridgePipes_0.png","tag":["Tech"],"readingTime":16},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<h2>안내</h2>\n<p>✔️ Amazon EventBridge Pipes 및 그들이 무엇인지에 대해 논의합니다.\n✔️ Python 및 AWS CDK를 사용한 예제를 통해 안내합니다.</p>\n<h1>소개 👋🏽</h1>\n<p></p>\n<p>이 기사에서는 AWS CDK와 Python을 사용하여 구축된 허구의 치과 앱을 만들어가면서 Amazon EventBridge Pipes에 대해 다뤄볼 것입니다.</p>\n<p><img src=\"/assets/img/2024-06-23-ServerlessEventBridgePipes_1.png\" alt=\"이미지\"></p>\n<p>'LJ 치과 의사' 앱은 사람들이 가장 가까운 치과 의사와 예약을 잡을 수 있는 기능을 제공합니다.</p>\n<p><img src=\"/assets/img/2024-06-23-ServerlessEventBridgePipes_2.png\" alt=\"이미지\"></p>\n<p></p>\n<p>그들이 이미 방문한 적이 있는 경우에는 이메일, SMS 또는 통신 없음을 보내기 전에 선호하는 연락 방법을 확인합니다. 이 모두는 Amazon EventBridge Pipes를 사용하여 처리됩니다.</p>\n<p><img src=\"/assets/img/2024-06-23-ServerlessEventBridgePipes_3.png\" alt=\"이미지\"></p>\n<p>이 기사의 전체 코드 예제는 여기에서 확인할 수 있습니다:</p>\n<h1>우리가 무엇을 만들고 있나요? 🛠️</h1>\n<p></p>\n<p>환자들이 온라인으로 진료 예약을 할 수 있도록 다음 아키텍처를 사용할 예정입니다:</p>\n<p><img src=\"/assets/img/2024-06-23-ServerlessEventBridgePipes_4.png\" alt=\"아키텍처\"></p>\n<p>환자들이 다음을 사용하여 진료를 예약할 수 있습니다:</p>\n<ul>\n<li>Amazon API Gateway REST API를 사용하여 온라인으로 진료 예약을 합니다.</li>\n<li>Lambda 함수가 진료 상세 내용을 DynamoDB 테이블에 기록합니다.</li>\n<li>우리는 DynamoDB 스트림을 사용하여 테이블의 변경 사항을 감지하고 레코드가 생성되었을 경우에만 필터링하여 Amazon EventBridge Pipes를 통해 해당 스트림을 소스로 사용합니다.</li>\n<li>일치하는 레코드가 연락처 선호도 테이블에 있는지 확인하는 Lambda 함수를 호출하여 스트림 레코드에 선호도를 추가합니다.</li>\n<li>마지막으로, Amazon EventBridge Pipes의 대상은 SQS로 설정되어 진료를 처리하기 위해 준비된 예약을 저장합니다.</li>\n</ul>\n<p></p>\n<p>👇 더 진전하기 전에 — 향후 블로그 게시물과 서버리스 뉴스를 만나보기 위해 LinkedIn에 연락해 주세요 <a href=\"https://www.linkedin.com/in/lee-james-gilmore/\" rel=\"nofollow\" target=\"_blank\">https://www.linkedin.com/in/lee-james-gilmore/</a></p>\n<p><img src=\"/assets/img/2024-06-23-ServerlessEventBridgePipes_5.png\" alt=\"ServerlessEventBridgePipes_5\"></p>\n<h1>Amazon EventBridge Pipes란 무엇인가요?</h1>\n<p>Amazon EventBridge Pipes는 옵션 변환, 필터 및 풍부한 단계를 통해 이벤트 생성자와 소비자 간의 포인트 투 포인트 통합을 생성하는 데 도움을 줍니다. EventBridge Pipes를 사용하면 이벤트 중심 애플리케이션을 구축할 때 필요한 통합 코드 양을 줄이고 유지할 수 있습니다. 아래 다이어그램은 우리 예시를 위해 이를 보여줍니다:</p>\n<p></p>\n<p>위 다이어그램에서 알 수 있듯이 다음이 있습니다:</p>\n<ul>\n<li>소스로 DynamoDB 스트림을 사용합니다.</li>\n<li>새로 삽입된 레코드만 받도록 추가 필터링을 수행합니다(예: 삭제 또는 업데이트 제외).</li>\n<li>별도의 데이터베이스에서 연락처 정보를 읽는 enrichment Lambda 함수를 통해 스트림에서 약속 데이터를 추가 정보로 향상시킵니다.</li>\n<li>최종적으로 약속 레코드를 더 처리하기 위해 SQS 대기열로 설정된 대상이 있습니다.</li>\n</ul>\n<p>참고로 아래에 표시된 다양한 서비스와 구성을 사용할 수 있습니다:</p>\n<p><img src=\"/assets/img/2024-06-23-ServerlessEventBridgePipes_6.png\" alt=\"이미지\"></p>\n<p></p>\n<h1>주요 코드 설명하기 👨‍💻</h1>\n<p>이제 몇 가지 주요 코드에 대해 이야기해봅시다.</p>\n<p>아래에서 볼 수 있는대로 CDK 애플리케이션을 상태(Stateful) 및 상태 없음(Stateless) 리소스(스택)로 분리하기 시작합니다:</p>\n<pre><code class=\"hljs language-js\">#!<span class=\"hljs-regexp\">/usr/</span>bin/env python3\n<span class=\"hljs-keyword\">import</span> os\n\n<span class=\"hljs-keyword\">import</span> aws_cdk <span class=\"hljs-keyword\">as</span> cdk\n<span class=\"hljs-keyword\">from</span> stateful.<span class=\"hljs-property\">stateful</span> <span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">DentistsStatefulStack</span>\n<span class=\"hljs-keyword\">from</span> stateless.<span class=\"hljs-property\">stateless</span> <span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">DentistsStatelessStack</span>\n\napp = cdk.<span class=\"hljs-title class_\">App</span>()\n\n# 앱을 상태(<span class=\"hljs-title class_\">Stateful</span>) 및 상태 없음(<span class=\"hljs-title class_\">Stateless</span>) 리소스로 분리합니다\n<span class=\"hljs-title class_\">DentistsStatefulStack</span>(app, <span class=\"hljs-string\">\"DentistsStatefulStack\"</span>)\n<span class=\"hljs-title class_\">DentistsStatelessStack</span>(app, <span class=\"hljs-string\">\"DentistsStatelessStack\"</span>)\n\napp.<span class=\"hljs-title function_\">synth</span>()\n</code></pre>\n<p></p>\n<p>Stateful 스택을 먼저 살펴 보면, 두 개의 DynamoDB 테이블을 설정했음을 알 수 있습니다. 하나는 약속을, 다른 하나는 선호하는 연락처 세부 정보를 저장하는 테이블입니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">from</span> aws_cdk <span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">CfnOutput</span>, <span class=\"hljs-title class_\">RemovalPolicy</span>, <span class=\"hljs-title class_\">Stack</span>\n<span class=\"hljs-keyword\">from</span> aws_cdk <span class=\"hljs-keyword\">import</span> aws_dynamodb <span class=\"hljs-keyword\">as</span> dynamodb\n<span class=\"hljs-keyword\">from</span> constructs <span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Construct</span>\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DentistsStatefulStack</span>(<span class=\"hljs-title class_\">Stack</span>):\n\n    def <span class=\"hljs-title function_\">__init__</span>(self, <span class=\"hljs-attr\">scope</span>: <span class=\"hljs-title class_\">Construct</span>, <span class=\"hljs-attr\">construct_id</span>: str, **kwargs) -> <span class=\"hljs-title class_\">None</span>:\n        <span class=\"hljs-variable language_\">super</span>().<span class=\"hljs-title function_\">__init__</span>(scope, construct_id, **kwargs)\n\n        # 약속을 저장하는 <span class=\"hljs-title class_\">DynamoDB</span> 테이블 추가 및 스트림 활성화\n        table = dynamodb.<span class=\"hljs-title class_\">Table</span>(\n            self, <span class=\"hljs-string\">'DentistTable'</span>,\n            billing_mode=dynamodb.<span class=\"hljs-property\">BillingMode</span>.<span class=\"hljs-property\">PAY_PER_REQUEST</span>,\n            table_name=<span class=\"hljs-string\">'DentistTable'</span>,\n            stream=dynamodb.<span class=\"hljs-property\">StreamViewType</span>.<span class=\"hljs-property\">NEW_IMAGE</span>,\n            removal_policy=<span class=\"hljs-title class_\">RemovalPolicy</span>.<span class=\"hljs-property\">DESTROY</span>,\n            partition_key=dynamodb.<span class=\"hljs-title class_\">Attribute</span>(\n                name=<span class=\"hljs-string\">'id'</span>,\n                type=dynamodb.<span class=\"hljs-property\">AttributeType</span>.<span class=\"hljs-property\">STRING</span>\n            )\n        )\n\n        # 이메일 주소를 기반으로 하는 연락 선호도 <span class=\"hljs-title class_\">DynamoDB</span> 테이블 추가\n        contact_table = dynamodb.<span class=\"hljs-title class_\">Table</span>(\n            self, <span class=\"hljs-string\">'DentistContactsTable'</span>,\n            billing_mode=dynamodb.<span class=\"hljs-property\">BillingMode</span>.<span class=\"hljs-property\">PAY_PER_REQUEST</span>,\n            table_name=<span class=\"hljs-string\">'DentistContactsTable'</span>,\n            removal_policy=<span class=\"hljs-title class_\">RemovalPolicy</span>.<span class=\"hljs-property\">DESTROY</span>,\n            partition_key=dynamodb.<span class=\"hljs-title class_\">Attribute</span>(\n                name=<span class=\"hljs-string\">'id'</span>,\n                type=dynamodb.<span class=\"hljs-property\">AttributeType</span>.<span class=\"hljs-property\">STRING</span>\n            )\n        )\n\n        # 테이블 이름을 위한 스택 출력 추가\n        <span class=\"hljs-title class_\">CfnOutput</span>(\n            self, <span class=\"hljs-string\">'DentistDynamoDBTableName'</span>,\n            value=table.<span class=\"hljs-property\">table_name</span>,\n            description=<span class=\"hljs-string\">'DynamoDB 테이블 이름'</span>,\n            export_name=<span class=\"hljs-string\">'DentistDynamoDBTableName'</span>\n        )\n\n        # 연락처 테이블 이름을 위한 스택 출력 추가\n        <span class=\"hljs-title class_\">CfnOutput</span>(\n            self, <span class=\"hljs-string\">'DentistContactDynamoDBTableName'</span>,\n            value=contact_table.<span class=\"hljs-property\">table_name</span>,\n            description=<span class=\"hljs-string\">'연락 선호도 DynamoDB 테이블 이름'</span>,\n            export_name=<span class=\"hljs-string\">'DentistContactDynamoDBTableName'</span>\n        )\n\n        # 약속 테이블의 테이블 스트림 <span class=\"hljs-variable constant_\">ARN</span>을 위한 스택 출력 추가\n        <span class=\"hljs-title class_\">CfnOutput</span>(\n            self, <span class=\"hljs-string\">'DentistDynamoDBTableStreamArn'</span>,\n            value=table.<span class=\"hljs-property\">table_stream_arn</span>,\n            description=<span class=\"hljs-string\">'DynamoDB 테이블 스트림 ARN'</span>,\n            export_name=<span class=\"hljs-string\">'DentistDynamoDBTableStreamArn'</span>\n        )\n</code></pre>\n<p>이제 Stateful 리소스가 설정됐으므로, Stateless 스택에서 먼저 약속을 생성하는 람다 함수를 생성합니다:</p>\n<pre><code class=\"hljs language-js\"># 약속을 생성하는 람다 함수 생성\ncreate_appointment_lambda = aws_lambda.<span class=\"hljs-title class_\">Function</span>(\n    self, <span class=\"hljs-string\">'CreateAppointment'</span>,\n    runtime=aws_lambda.<span class=\"hljs-property\">Runtime</span>.<span class=\"hljs-property\">PYTHON_3_12</span>,\n    handler=<span class=\"hljs-string\">'create_appointment.handler'</span>,\n    code=aws_lambda.<span class=\"hljs-property\">Code</span>.<span class=\"hljs-title function_\">from_asset</span>(os.<span class=\"hljs-property\">path</span>.<span class=\"hljs-title function_\">join</span>(<span class=\"hljs-variable constant_\">DIRNAME</span>, <span class=\"hljs-string\">'src'</span>)),\n    function_name=<span class=\"hljs-string\">'CreateAppointment'</span>,\n    environment={\n        <span class=\"hljs-string\">'dynamodb_table'</span>: dynamodb_table_name,\n    },\n)\n</code></pre>\n<p></p>\n<p>Lambda 함수에 추가적으로 두 번째 Lambda 함수를 추가합니다. 이 함수는 DynamoDB 스트림이 제공하는 데이터를 풍부하게 하는 데 사용될 것입니다:</p>\n<pre><code class=\"hljs language-js\"># 연락처 세부 정보를 검색하는 람다 함수 생성\nget_contact_details = aws_lambda.<span class=\"hljs-title class_\">Function</span>(\n    self, <span class=\"hljs-string\">'GetContactDetails'</span>,\n    runtime=aws_lambda.<span class=\"hljs-property\">Runtime</span>.<span class=\"hljs-property\">PYTHON_3_12</span>,\n    handler=<span class=\"hljs-string\">'get_contact_details.handler'</span>,\n    code=aws_lambda.<span class=\"hljs-property\">Code</span>.<span class=\"hljs-title function_\">from_asset</span>(os.<span class=\"hljs-property\">path</span>.<span class=\"hljs-title function_\">join</span>(<span class=\"hljs-variable constant_\">DIRNAME</span>, <span class=\"hljs-string\">'src'</span>)),\n    function_name=<span class=\"hljs-string\">'GetContactDetails'</span>,\n    environment={\n        <span class=\"hljs-string\">'contacts_dynamodb_table'</span>: contacts_dynamodb_table_name,\n    },\n)\n</code></pre>\n<p>다음으로, 우리의 파이프 대상이 될 Amazon SQS 대기열을 추가합니다:</p>\n<pre><code class=\"hljs language-js\"># <span class=\"hljs-title class_\">AppointmentsQueue</span>로 메시지를 보낼 <span class=\"hljs-variable constant_\">SQS</span> 대기열 생성\nsqs_queue = sqs.<span class=\"hljs-title class_\">Queue</span>(\n    self, <span class=\"hljs-string\">'AppointmentsQueue'</span>,\n    queue_name=<span class=\"hljs-string\">'AppointmentsQueue'</span>,\n    removal_policy=<span class=\"hljs-title class_\">RemovalPolicy</span>.<span class=\"hljs-property\">DESTROY</span>\n)\n</code></pre>\n<p></p>\n<p>그럼 Amazon EventBridge 파이프 자체에 대한 IAM 정책을 만들어서 원본, 보강 및 대상 자원과 연결할 수 있도록합니다.</p>\n<pre><code class=\"hljs language-js\"># 파이프 원본(다이나모<span class=\"hljs-variable constant_\">DB</span> 스트림)용 파이프 정책과 역할 생성\npipe_source_policy = iam.<span class=\"hljs-title class_\">PolicyStatement</span>(\n    actions=[\n        <span class=\"hljs-string\">'dynamodb:DescribeStream'</span>,\n        <span class=\"hljs-string\">'dynamodb:GetRecords'</span>,\n        <span class=\"hljs-string\">'dynamodb:GetShardIterator'</span>,\n        <span class=\"hljs-string\">'dynamodb:ListStreams'</span>\n    ],\n    resources=[stream_arn],\n    effect=iam.<span class=\"hljs-property\">Effect</span>.<span class=\"hljs-property\">ALLOW</span>\n)\n\n# 파이프 대상(<span class=\"hljs-variable constant_\">SQS</span>)으로 메시지를 게시하는 것을 허용하는 대상 정책 작성\npipe_target_policy = iam.<span class=\"hljs-title class_\">PolicyStatement</span>(\n    actions=[<span class=\"hljs-string\">'sqs:SendMessage'</span>],\n    resources=[sqs_queue.<span class=\"hljs-property\">queue_arn</span>],\n    effect=iam.<span class=\"hljs-property\">Effect</span>.<span class=\"hljs-property\">ALLOW</span>\n)\n\n# 파이프가 람다 기능을 호출할 수 있도록 하는 보강 정책 생성\npipe_enrichment_policy = iam.<span class=\"hljs-title class_\">PolicyStatement</span>(\n    actions=[<span class=\"hljs-string\">'lambda:InvokeFunction'</span>],\n    resources=[get_contact_details.<span class=\"hljs-property\">function_arn</span>],\n    effect=iam.<span class=\"hljs-property\">Effect</span>.<span class=\"hljs-property\">ALLOW</span>\n)\n\n# 파이프 역할 생성\npipe_role = iam.<span class=\"hljs-title class_\">Role</span>(self, <span class=\"hljs-string\">'PipeRole'</span>,\n    assumed_by=iam.<span class=\"hljs-title class_\">ServicePrincipal</span>(<span class=\"hljs-string\">'pipes.amazonaws.com'</span>),\n)\n\n# 역할에 세 가지 정책 추가\npipe_role.<span class=\"hljs-title function_\">add_to_policy</span>(pipe_source_policy)\npipe_role.<span class=\"hljs-title function_\">add_to_policy</span>(pipe_target_policy)\npipe_role.<span class=\"hljs-title function_\">add_to_policy</span>(pipe_enrichment_policy)\n</code></pre>\n<p>이제 다음과 같은 코드를 사용하여 파이프를 생성할 수 있습니다:</p>\n<pre><code class=\"hljs language-js\"># 다이나모<span class=\"hljs-variable constant_\">DB</span>의 새 항목에 대한 필터가 있는 이벤트브릿지 파이프 생성\npipe = pipes.<span class=\"hljs-title class_\">CfnPipe</span>(self, <span class=\"hljs-string\">'Pipe'</span>,\n    role_arn=pipe_role.<span class=\"hljs-property\">role_arn</span>,\n    source=stream_arn,\n    log_configuration=pipes.<span class=\"hljs-property\">CfnPipe</span>.<span class=\"hljs-title class_\">PipeLogConfigurationProperty</span>(\n        cloudwatch_logs_log_destination=pipes.<span class=\"hljs-property\">CfnPipe</span>.<span class=\"hljs-title class_\">CloudwatchLogsLogDestinationProperty</span>(\n            log_group_arn=log_group.<span class=\"hljs-property\">log_group_arn</span>\n        ),\n        level=<span class=\"hljs-string\">'INFO'</span>,\n    ),\n    name=<span class=\"hljs-string\">'DentistPipe'</span>,\n    source_parameters=pipes.<span class=\"hljs-property\">CfnPipe</span>.<span class=\"hljs-title class_\">PipeSourceParametersProperty</span>(\n        dynamo_db_stream_parameters=pipes.<span class=\"hljs-property\">CfnPipe</span>.<span class=\"hljs-title class_\">PipeSourceDynamoDBStreamParametersProperty</span>(\n            starting_position=<span class=\"hljs-string\">'LATEST'</span>,\n        ),\n        filter_criteria=pipes.<span class=\"hljs-property\">CfnPipe</span>.<span class=\"hljs-title class_\">FilterCriteriaProperty</span>(\n            filters=[pipes.<span class=\"hljs-property\">CfnPipe</span>.<span class=\"hljs-title class_\">FilterProperty</span>(\n                pattern=json.<span class=\"hljs-title function_\">dumps</span>({<span class=\"hljs-string\">'eventName'</span>: [{ <span class=\"hljs-string\">'prefix'</span>: <span class=\"hljs-string\">'INSERT'</span> }])\n            )]\n        ),\n    ),\n    enrichment=get_contact_details.<span class=\"hljs-property\">function_arn</span>,\n    target=sqs_queue.<span class=\"hljs-property\">queue_arn</span>,\n)\npipe.<span class=\"hljs-title function_\">apply_removal_policy</span>(<span class=\"hljs-title class_\">RemovalPolicy</span>.<span class=\"hljs-property\">DESTROY</span>)\n</code></pre>\n<p></p>\n<p>현재 인프라가 모두 설정되어 있지만 'create_appointment.py' 파일을 시작으로 Lambda 함수 코드를 간단히 살펴보겠습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> json\n<span class=\"hljs-keyword\">import</span> os\n<span class=\"hljs-keyword\">import</span> uuid\n<span class=\"hljs-keyword\">from</span> http <span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">HTTPStatus</span>\n\n<span class=\"hljs-keyword\">import</span> boto3\n<span class=\"hljs-keyword\">from</span> boto3.<span class=\"hljs-property\">dynamodb</span>.<span class=\"hljs-property\">types</span> <span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">TypeSerializer</span>\n\ndynamodb_table = os.<span class=\"hljs-title function_\">getenv</span>(<span class=\"hljs-string\">'dynamodb_table'</span>)\ndynamodb_client = boto3.<span class=\"hljs-title function_\">client</span>(<span class=\"hljs-string\">'dynamodb'</span>)\nserializer = <span class=\"hljs-title class_\">TypeSerializer</span>()\n\ndef <span class=\"hljs-title function_\">handler</span>(event, context):\n    <span class=\"hljs-attr\">try</span>:\n        # 이벤트에서 요청 데이터를 구문 분석하고 본문을 가져옵니다.\n        request_data = json.<span class=\"hljs-title function_\">loads</span>(event[<span class=\"hljs-string\">'body'</span>])\n\n        # uuidv4를 사용하여 새로운 약속 <span class=\"hljs-variable constant_\">ID</span>를 추가합니다.\n        request_data[<span class=\"hljs-string\">'id'</span>] = <span class=\"hljs-title function_\">str</span>(uuid.<span class=\"hljs-title function_\">uuid4</span>())\n\n        # 페이로드를 dynamodb 형식으로 직렬화합니다.\n        appointment_data = {<span class=\"hljs-attr\">k</span>: serializer.<span class=\"hljs-title function_\">serialize</span>(v) <span class=\"hljs-keyword\">for</span> k, v <span class=\"hljs-keyword\">in</span> request_data.<span class=\"hljs-title function_\">items</span>()}\n\n        # 항목을 dynamodb 테이블에 추가합니다.\n        dynamodb_client.<span class=\"hljs-title function_\">put_item</span>(<span class=\"hljs-title class_\">TableName</span>=dynamodb_table, <span class=\"hljs-title class_\">Item</span>=appointment_data)\n\n        body = {\n            <span class=\"hljs-string\">'message'</span>: request_data,\n            <span class=\"hljs-string\">'statusCode'</span>: <span class=\"hljs-title class_\">HTTPStatus</span>.<span class=\"hljs-property\">CREATED</span>,\n        }\n\n        # 응답을 올바른 형식으로 <span class=\"hljs-variable constant_\">API</span> <span class=\"hljs-title class_\">Gateway</span>로 전송합니다.\n        response = {\n            <span class=\"hljs-string\">'statusCode'</span>: <span class=\"hljs-title class_\">HTTPStatus</span>.<span class=\"hljs-property\">CREATED</span>,\n            <span class=\"hljs-string\">'body'</span>: json.<span class=\"hljs-title function_\">dumps</span>(body, indent=<span class=\"hljs-number\">2</span>),\n            <span class=\"hljs-string\">'headers'</span>: {\n                <span class=\"hljs-string\">'content-type'</span>: <span class=\"hljs-string\">'application/json'</span>,\n            },\n        }\n\n    except <span class=\"hljs-title class_\">Exception</span> <span class=\"hljs-keyword\">as</span> <span class=\"hljs-attr\">e</span>:\n        response = {\n            <span class=\"hljs-string\">'statusCode'</span>: <span class=\"hljs-title class_\">HTTPStatus</span>.<span class=\"hljs-property\">INTERNAL_SERVER_ERROR</span>.<span class=\"hljs-property\">value</span>,\n            <span class=\"hljs-string\">'body'</span>: f<span class=\"hljs-string\">'Exception={e}'</span>,\n        }\n\n    <span class=\"hljs-keyword\">return</span> response\n</code></pre>\n<p>위 코드에서 볼 수 있듯, API Gateway 이벤트에서 약속을 가져와 새로운 고유 ID(uuid)를 추가하고 레코드를 약속 테이블에 기록하는 기본 함수를 생성합니다.</p>\n<p>테이블에 레코드가 추가되면 스트림이 호출되어 모든 레코드 변경에 대해 파이프가 변경 사항을 소스로 가져올 것입니다.</p>\n<p></p>\n<p>그 다음으로, 파이프의 일부로 호출되는 Enrichment 람다 함수를 살펴보겠습니다:</p>\n<p>위 코드에서 볼 수 있듯이, 스트림 레코드에서 email_address 속성을 가져와 우리가 선호하는 연락처 DynamoDB 테이블에서 조회합니다. 레코드가 존재하면, 선호하는 방법을 가져와 약속 레코드에 추가합니다. 일치하는 레코드가 없으면, preferredMethod를 'none'으로 추가합니다.</p>\n<p>엔드 투 엔드로 테스트하려면, 애플리케이션을 배포하고 Contacts DynamoDb 테이블에 다음 항목을 추가하면 preferredMethod를 추가할 수 있습니다:</p>\n<p></p>\n<pre><code class=\"hljs language-json\"><span class=\"hljs-punctuation\">{</span>\n  <span class=\"hljs-attr\">\"id\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">\"john.doe@example.com\"</span><span class=\"hljs-punctuation\">,</span>\n  <span class=\"hljs-attr\">\"preferredMethod\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">\"email\"</span>\n<span class=\"hljs-punctuation\">}</span>\n</code></pre>\n<p>만약 레코드가 존재하지 않는다면 이전에 언급한 대로 'none'으로 기본 설정됩니다.</p>\n<h1>결론</h1>\n<p>Amazon EventBridge 파이프를 사용하는 실제 예시로 서버리스 솔루션에서의 사용법을 보여드려 유용하게 찾으셨기를 희망합니다. 파이프를 사용하면 이전에 사용해야 했던 람다 접착 코드를 제거할 수 있고 소스에서 데이터를 추출하여 해당 데이터를 타깃으로 전달하는 훌륭한 방법을 제공합니다.</p>\n<p></p>\n<h1>마무리 👋🏽</h1>\n<p>이 글을 즐겁게 보았으면 공유하고 피드백을 남겨주세요!</p>\n<p>비슷한 콘텐츠를 더 보시려면 제 YouTube 채널을 구독해주세요!</p>\n<p></p>\n<p>당신과 어느 하나라도 다음에서도 연결하고 싶어요:</p>\n<ul>\n<li><a href=\"https://www.linkedin.com/in/lee-james-gilmore/\" rel=\"nofollow\" target=\"_blank\">LinkedIn</a></li>\n<li><a href=\"https://twitter.com/LeeJamesGilmore\" rel=\"nofollow\" target=\"_blank\">Twitter</a></li>\n</ul>\n<p>포스트를 즐겼다면 추가로 포스트/시리즈를 보기 위해 내 프로필 Lee James Gilmore를 팔로우해주세요. 그리고 인사를 건네고 싶다면 절대 잊지 말고 연락해주세요 👋</p>\n<p>좋았다면 포스트 하단에 있는 '박수' 기능을 사용해주세요! (한 번 이상 박수를 칠 수 있어요!!)</p>\n<p></p>\n<h1>제 소개</h1>\n<p>안녕하세요, 저는 영국에 거주하고 있는 AWS 커뮤니티 빌더이자 블로거인 Lee입니다. AWS 인증 클라우드 아키텍트이며 City Electrical Factors (UK) 및 City Electric Supply (US)에서 글로벌 기술 및 아키텍처 책임자로 일하고 있습니다. 지난 6년간 주로 AWS에서 풀스택 JavaScript를 사용해 왔습니다.</p>\n<p>저는 서버리스를 지지하는 사람으로, AWS, 혁신, 소프트웨어 아키텍처, 기술에 대한 애정이 있습니다.</p>\n<p><strong>_ 제공된 정보는 제 개인적인 견해이며 해당 정보 사용에 대한 책임을 지지 않습니다. _</strong></p>\n<p></p>\n<p>아래 내용도 참고하시면 좋을 것 같아요:</p>\n</body>\n</html>\n"},"__N_SSG":true}