{"pageProps":{"post":{"title":"ViewChild를 사용하지 말아요","description":"","date":"2024-05-27 16:16","slug":"2024-05-27-StopusingViewChild","content":"\n네이티브 DOM 요소에 액세스하는 것은 웹 개발에서 기본적인 작업입니다. 그러나 현대적인 프레임워크는 다양한 전략을 활용하여 직접 DOM 액세스의 필요성을 최소화합니다. 예를 들어 Angular는 *ngIf와 같은 디렉티브를 사용하여 요소를 조건부로 추가하거나 제거하고 *ngFor를 사용하여 요소를 반복합니다. 이러한 기술은 직접적인 DOM 조작을 추상화하여 Angular이나 유사한 프레임워크에서 어플리케이션을 개발할 때 덜 걱정해도 되도록 만듭니다.\n\n이러한 추상화에도 불구하고 직접적인 DOM 액세스가 여전히 필요한 시나리오가 있습니다. 구글 맵과 같은 일부 써드파티 라이브러리는 동작을 위해 직접적인 DOM 요소가 필요합니다. 구글 맵은 맵을 초기화하고 표시하기 위해 div 요소가 필요합니다. 일반적으로 개발자는 @ViewChild 데코레이터를 사용하여 div 요소에 액세스하고 그것을 맵 API에 제공하여 초기화합니다.\n\n```js\n/// <reference types=\"@types/google.maps\" />\nimport { AfterViewInit, Component, ElementRef, ViewChild } from '@angular/core';\n\n@Component({\n  selector: 'app-map-component',\n  template: `<div class=\"map-container\" #googleMap></div>`,\n  styles: ['.map-container {height: 500px;}'],\n})\nexport class MapComponentComponent implements AfterViewInit {\n  @ViewChild('googleMap', { read: ElementRef }) googleMapElement!: ElementRef<HTMLDivElement>;\n  map?: google.maps.Map;\n\n  async ngAfterViewInit() {\n    const { Map } = await google.maps.importLibrary(\"maps\") as google.maps.MapsLibrary;\n    // Pass the nativeElement to google map library\n    this.map = new Map(this.googleMapElement.nativeElement, {\n      center: { lat: -34.397, lng: 150.644 },\n      zoom: 8,\n    });\n  }\n}\n```\n\n이 접근 방식은 작동하지만 세 가지 주요 문제점을 도입합니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 템플릿에서 div 요소를 제거하면 코드가 깨져서 맵 기능을 재사용할 수 없게 됩니다.\n- 네이티브 요소에 대한 참조는 ngAfterViewInit 라이프사이클 후크 이후에만 사용할 수 있습니다.\n- SOLID 디자인 원칙 중 단일 책임 원칙을 위반합니다. @ViewChild를 사용하는 컴포넌트는 맵을위한 데이터를 가져오는 것, 초기화하는 것, 설정하고 사용하는 것에 대한 책임이 생깁니다.\n\n더 나은 접근 방식이 있습니다: 속성 지시자 사용.\n\n이전 컴포넌트를 리팩토링하고 맵 속성 지시자를 만들어 봅시다.\n\n```js\n/// <reference types=\"@types/google.maps\" />\nimport { Directive, ElementRef, OnInit } from '@angular/core';\n\n@Directive({\n  selector: 'div[appGoogleMap]'\n})\nexport class GoogleMapDirective implements OnInit {\n  map?: google.maps.Map;\n  constructor(private elementRef: ElementRef<HTMLDivElement>) { }\n\n  async ngOnInit() {\n    const { Map } = await google.maps.importLibrary(\"maps\") as google.maps.MapsLibrary;\n    this.map = new Map(this.elementRef.nativeElement, {\n      center: { lat: -34.397, lng: 150.644 },\n      zoom: 8,\n    });\n  }\n}\n\n// 속성 지시자 사용\n<div class=\"map-container\" appGoogleMap></div>\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다른 사용 사례를 고려해 보겠습니다: 캔버스 요소에 도형이나 이미지를 그리는 것입니다. 간단한 방법은 @ViewChild를 사용하여 네이티브 요소에서 그리기 컨텍스트를 가져오는 것입니다.\n\n더 나은 대안은 속성 지시자를 사용하고 @Input 속성을 통해 그리기 정보를 전달하는 것입니다.\n\n```js\nimport { Component, ElementRef, ViewChild } from '@angular/core';\n\n@Component({\n  selector: 'app-canvas-component',\n  template: `<canvas #myCanvas></canvas>`,\n})\nexport class CanvasComponentComponent {\n  // 빌드 시 myCanvas를 확인할 수 있는 방법이 없음\n  @ViewChild('myCanvas', { read: ElementRef }) canvasRef!: ElementRef<HTMLCanvasElement>;\n\n  ngAfterViewInit() {\n    const canvas = this.canvasRef.nativeElement;\n    const canvasContext = canvas.getContext('2d');\n    // 캔버스 컨텍스트를 사용하여 그리기\n    canvasContext?.beginPath();\n    canvasContext?.arc(75, 75, 50, 0, 2 * Math.PI);\n    canvasContext?.stroke();\n  }\n}\n\n// Vs\nimport { Directive, ElementRef } from '@angular/core';\n\n@Directive({\n  // 이 지시자는 Cavas 요소만 사용할 수 있습니다\n  selector: 'canvas[appCanvas]'\n})\nexport class CanvasDirective {\n  constructor(private elementRef: ElementRef<HTMLCanvasElement>) {\n    this.draw();\n  }\n\n  draw() {\n    const canvas = this.elementRef.nativeElement;\n    const canvasContext = canvas.getContext('2d');\n    // 캔버스 컨텍스트를 사용하여 그리기\n    canvasContext?.beginPath();\n    canvasContext?.arc(75, 75, 50, 0, 2 * Math.PI);\n    canvasContext?.stroke();\n  }\n}\n// 속성 지시자 사용\n<canvas appCanvas></canvas>\n```\n\n좋아 보이죠? 그런데 기다려 보세요, 더 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리는 첫 두 문제를 해결했지만 속성 지시자는 여전히 여러 책임을 처리하고 있습니다. 더 분해할 수 있을까요? 다음 블로그에서 그것을 더 탐구해보겠습니다.\n","ogImage":{"url":"/assets/img/2024-05-27-StopusingViewChild_0.png"},"coverImage":"/assets/img/2024-05-27-StopusingViewChild_0.png","tag":["Tech"],"readingTime":5},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p>네이티브 DOM 요소에 액세스하는 것은 웹 개발에서 기본적인 작업입니다. 그러나 현대적인 프레임워크는 다양한 전략을 활용하여 직접 DOM 액세스의 필요성을 최소화합니다. 예를 들어 Angular는 *ngIf와 같은 디렉티브를 사용하여 요소를 조건부로 추가하거나 제거하고 *ngFor를 사용하여 요소를 반복합니다. 이러한 기술은 직접적인 DOM 조작을 추상화하여 Angular이나 유사한 프레임워크에서 어플리케이션을 개발할 때 덜 걱정해도 되도록 만듭니다.</p>\n<p>이러한 추상화에도 불구하고 직접적인 DOM 액세스가 여전히 필요한 시나리오가 있습니다. 구글 맵과 같은 일부 써드파티 라이브러리는 동작을 위해 직접적인 DOM 요소가 필요합니다. 구글 맵은 맵을 초기화하고 표시하기 위해 div 요소가 필요합니다. 일반적으로 개발자는 @ViewChild 데코레이터를 사용하여 div 요소에 액세스하고 그것을 맵 API에 제공하여 초기화합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">/// &#x3C;reference types=\"@types/google.maps\" /></span>\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">AfterViewInit</span>, <span class=\"hljs-title class_\">Component</span>, <span class=\"hljs-title class_\">ElementRef</span>, <span class=\"hljs-title class_\">ViewChild</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@angular/core'</span>;\n\n@<span class=\"hljs-title class_\">Component</span>({\n  <span class=\"hljs-attr\">selector</span>: <span class=\"hljs-string\">'app-map-component'</span>,\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`&#x3C;div class=\"map-container\" #googleMap>&#x3C;/div>`</span>,\n  <span class=\"hljs-attr\">styles</span>: [<span class=\"hljs-string\">'.map-container {height: 500px;}'</span>],\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MapComponentComponent</span> implements <span class=\"hljs-title class_\">AfterViewInit</span> {\n  @<span class=\"hljs-title class_\">ViewChild</span>(<span class=\"hljs-string\">'googleMap'</span>, { <span class=\"hljs-attr\">read</span>: <span class=\"hljs-title class_\">ElementRef</span> }) googleMapElement!: <span class=\"hljs-title class_\">ElementRef</span>&#x3C;<span class=\"hljs-title class_\">HTMLDivElement</span>>;\n  map?: google.<span class=\"hljs-property\">maps</span>.<span class=\"hljs-property\">Map</span>;\n\n  <span class=\"hljs-keyword\">async</span> <span class=\"hljs-title function_\">ngAfterViewInit</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">const</span> { <span class=\"hljs-title class_\">Map</span> } = <span class=\"hljs-keyword\">await</span> google.<span class=\"hljs-property\">maps</span>.importLibrary(<span class=\"hljs-string\">\"maps\"</span>) <span class=\"hljs-keyword\">as</span> google.<span class=\"hljs-property\">maps</span>.<span class=\"hljs-property\">MapsLibrary</span>;\n    <span class=\"hljs-comment\">// Pass the nativeElement to google map library</span>\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">map</span> = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">googleMapElement</span>.<span class=\"hljs-property\">nativeElement</span>, {\n      <span class=\"hljs-attr\">center</span>: { <span class=\"hljs-attr\">lat</span>: -<span class=\"hljs-number\">34.397</span>, <span class=\"hljs-attr\">lng</span>: <span class=\"hljs-number\">150.644</span> },\n      <span class=\"hljs-attr\">zoom</span>: <span class=\"hljs-number\">8</span>,\n    });\n  }\n}\n</code></pre>\n<p>이 접근 방식은 작동하지만 세 가지 주요 문제점을 도입합니다:</p>\n<p></p>\n<ul>\n<li>템플릿에서 div 요소를 제거하면 코드가 깨져서 맵 기능을 재사용할 수 없게 됩니다.</li>\n<li>네이티브 요소에 대한 참조는 ngAfterViewInit 라이프사이클 후크 이후에만 사용할 수 있습니다.</li>\n<li>SOLID 디자인 원칙 중 단일 책임 원칙을 위반합니다. @ViewChild를 사용하는 컴포넌트는 맵을위한 데이터를 가져오는 것, 초기화하는 것, 설정하고 사용하는 것에 대한 책임이 생깁니다.</li>\n</ul>\n<p>더 나은 접근 방식이 있습니다: 속성 지시자 사용.</p>\n<p>이전 컴포넌트를 리팩토링하고 맵 속성 지시자를 만들어 봅시다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">/// &#x3C;reference types=\"@types/google.maps\" /></span>\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Directive</span>, <span class=\"hljs-title class_\">ElementRef</span>, <span class=\"hljs-title class_\">OnInit</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@angular/core'</span>;\n\n@<span class=\"hljs-title class_\">Directive</span>({\n  <span class=\"hljs-attr\">selector</span>: <span class=\"hljs-string\">'div[appGoogleMap]'</span>\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">GoogleMapDirective</span> implements <span class=\"hljs-title class_\">OnInit</span> {\n  map?: google.<span class=\"hljs-property\">maps</span>.<span class=\"hljs-property\">Map</span>;\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">private elementRef: ElementRef&#x3C;HTMLDivElement></span>) { }\n\n  <span class=\"hljs-keyword\">async</span> <span class=\"hljs-title function_\">ngOnInit</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">const</span> { <span class=\"hljs-title class_\">Map</span> } = <span class=\"hljs-keyword\">await</span> google.<span class=\"hljs-property\">maps</span>.importLibrary(<span class=\"hljs-string\">\"maps\"</span>) <span class=\"hljs-keyword\">as</span> google.<span class=\"hljs-property\">maps</span>.<span class=\"hljs-property\">MapsLibrary</span>;\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">map</span> = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">elementRef</span>.<span class=\"hljs-property\">nativeElement</span>, {\n      <span class=\"hljs-attr\">center</span>: { <span class=\"hljs-attr\">lat</span>: -<span class=\"hljs-number\">34.397</span>, <span class=\"hljs-attr\">lng</span>: <span class=\"hljs-number\">150.644</span> },\n      <span class=\"hljs-attr\">zoom</span>: <span class=\"hljs-number\">8</span>,\n    });\n  }\n}\n\n<span class=\"hljs-comment\">// 속성 지시자 사용</span>\n&#x3C;div <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">\"map-container\"</span> appGoogleMap>&#x3C;/div>\n</code></pre>\n<p></p>\n<p>다른 사용 사례를 고려해 보겠습니다: 캔버스 요소에 도형이나 이미지를 그리는 것입니다. 간단한 방법은 @ViewChild를 사용하여 네이티브 요소에서 그리기 컨텍스트를 가져오는 것입니다.</p>\n<p>더 나은 대안은 속성 지시자를 사용하고 @Input 속성을 통해 그리기 정보를 전달하는 것입니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Component</span>, <span class=\"hljs-title class_\">ElementRef</span>, <span class=\"hljs-title class_\">ViewChild</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@angular/core'</span>;\n\n@<span class=\"hljs-title class_\">Component</span>({\n  <span class=\"hljs-attr\">selector</span>: <span class=\"hljs-string\">'app-canvas-component'</span>,\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`&#x3C;canvas #myCanvas>&#x3C;/canvas>`</span>,\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">CanvasComponentComponent</span> {\n  <span class=\"hljs-comment\">// 빌드 시 myCanvas를 확인할 수 있는 방법이 없음</span>\n  @<span class=\"hljs-title class_\">ViewChild</span>(<span class=\"hljs-string\">'myCanvas'</span>, { <span class=\"hljs-attr\">read</span>: <span class=\"hljs-title class_\">ElementRef</span> }) canvasRef!: <span class=\"hljs-title class_\">ElementRef</span>&#x3C;<span class=\"hljs-title class_\">HTMLCanvasElement</span>>;\n\n  <span class=\"hljs-title function_\">ngAfterViewInit</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">const</span> canvas = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">canvasRef</span>.<span class=\"hljs-property\">nativeElement</span>;\n    <span class=\"hljs-keyword\">const</span> canvasContext = canvas.<span class=\"hljs-title function_\">getContext</span>(<span class=\"hljs-string\">'2d'</span>);\n    <span class=\"hljs-comment\">// 캔버스 컨텍스트를 사용하여 그리기</span>\n    canvasContext?.<span class=\"hljs-title function_\">beginPath</span>();\n    canvasContext?.<span class=\"hljs-title function_\">arc</span>(<span class=\"hljs-number\">75</span>, <span class=\"hljs-number\">75</span>, <span class=\"hljs-number\">50</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">2</span> * <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-property\">PI</span>);\n    canvasContext?.<span class=\"hljs-title function_\">stroke</span>();\n  }\n}\n\n<span class=\"hljs-comment\">// Vs</span>\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Directive</span>, <span class=\"hljs-title class_\">ElementRef</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@angular/core'</span>;\n\n@<span class=\"hljs-title class_\">Directive</span>({\n  <span class=\"hljs-comment\">// 이 지시자는 Cavas 요소만 사용할 수 있습니다</span>\n  <span class=\"hljs-attr\">selector</span>: <span class=\"hljs-string\">'canvas[appCanvas]'</span>\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">CanvasDirective</span> {\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">private elementRef: ElementRef&#x3C;HTMLCanvasElement></span>) {\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">draw</span>();\n  }\n\n  <span class=\"hljs-title function_\">draw</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">const</span> canvas = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">elementRef</span>.<span class=\"hljs-property\">nativeElement</span>;\n    <span class=\"hljs-keyword\">const</span> canvasContext = canvas.<span class=\"hljs-title function_\">getContext</span>(<span class=\"hljs-string\">'2d'</span>);\n    <span class=\"hljs-comment\">// 캔버스 컨텍스트를 사용하여 그리기</span>\n    canvasContext?.<span class=\"hljs-title function_\">beginPath</span>();\n    canvasContext?.<span class=\"hljs-title function_\">arc</span>(<span class=\"hljs-number\">75</span>, <span class=\"hljs-number\">75</span>, <span class=\"hljs-number\">50</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">2</span> * <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-property\">PI</span>);\n    canvasContext?.<span class=\"hljs-title function_\">stroke</span>();\n  }\n}\n<span class=\"hljs-comment\">// 속성 지시자 사용</span>\n&#x3C;canvas appCanvas>&#x3C;/canvas>\n</code></pre>\n<p>좋아 보이죠? 그런데 기다려 보세요, 더 있습니다.</p>\n<p></p>\n<p>우리는 첫 두 문제를 해결했지만 속성 지시자는 여전히 여러 책임을 처리하고 있습니다. 더 분해할 수 있을까요? 다음 블로그에서 그것을 더 탐구해보겠습니다.</p>\n</body>\n</html>\n"},"__N_SSG":true}