{"pageProps":{"post":{"title":"SwiftData로 원격 API에서 데이터 저장하는 방법","description":"","date":"2024-06-22 23:10","slug":"2024-06-22-UsingSwiftDatatoStoreDatafromaRemoteAPI","content":"\n앱 사용자에게 오프라인 기능을 제공하고 앱 운영 비용을 줄이는 데 중요한 로컬 데이터 저장은 매우 중요합니다.\n\n[![Image](/assets/img/2024-06-22-UsingSwiftDatatoStoreDatafromaRemoteAPI_0.png)](//)\n\n시작하기 전에 몇 초 동안 제 게시물을 팔로우하고 👏 클랩(clap)하여 더 많은 사람들이 이 유용한 내용을 배울 수 있도록 도와주세요.\n\n# API 호출로부터 SwiftData를 사용하여 로컬로 데이터 저장하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n코드로 넘어가기로 하겠습니다. SwiftData에 익숙하지 않으신 경우, 새로운 내용을 익히시려면 이 기사를 확인해보세요.\n\n우리는 구조체의 이름 뒤에 약어 DTO(Data Transfer Object)를 추가하기로 결정했습니다. DTO는 한 시스템에서 다른 시스템으로 데이터를 전송하는 데 사용됩니다. 우리의 예제에서는 API 응답의 데이터를 JSON에서 SwiftData entity로 전송하려고 합니다. DTO는 JSON 응답을 일시적으로 보유하여 해당 데이터를 파싱하고 Swift 객체로 변환할 수 있게 합니다. 앞으로 몇 개의 코드 블록에서는 해당 Swift 객체를 SwiftData entity로 변환할 것입니다.\n\n```swift\n// PhotoDTO.swift\nimport Foundation\n\nstruct PhotoDTO: Identifiable, Codable {\n    let albumId: Int\n    let id: Int\n    let title: String\n    let url: String\n    let thumbnailUrl: String\n}\n```\n\nSwiftData로 시작하는 기사를 읽으신 경우, 이 내용은 익숙하게 느껴질 것입니다. 클래스에 새로운 코드 조각을 추가했는데, 그것은 편의 이니셜라이저입니다. 이를 통해 DTO를 직접 전달하여 SwiftData entity를 생성할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```swift\n//  PhotoObject.swift\nimport Foundation\nimport SwiftData\n\n@Model\nclass PhotoObject {\n    var albumId: Int\n    @Attribute(.unique) var id: Int\n    var title: String\n    var url: String\n    var thumbnailUrl: String\n\n    init(albumId: Int, id: Int, title: String, url: String, thumbnailUrl: String) {\n        self.albumId = albumId\n        self.id = id\n        self.title = title\n        self.url = url\n        self.thumbnailUrl = thumbnailUrl\n    }\n\n    convenience init(item: PhotoDTO) {\n        self.init(\n            albumId: item.albumId,\n            id: item.id,\n            title: item.title,\n            url: item.url,\n            thumbnailUrl: item.thumbnailUrl\n        )\n    }\n}\n```\n\n웹 서비스도 만약 SwiftUI에서 API 호출을 만들고 파싱한 적이 있다면 익숙할 것입니다. 웹 서비스를 살펴보면, 그 기사에서 살짝 수정하여 새로운 기능을 보유한 웹 서비스를 가지고 있다는 것을 알 수 있습니다. updateDataInDatabase를 이용해 API 호출에서 데이터를 파싱할 때마다 데이터를 데이터베이스에 저장할 수 있도록 새 기능을 추가했습니다. updateDataInDatabase 함수는 PhotoDTO를 SwiftData 엔티티로 변환하고 각 레코드를 데이터베이스에 저장하는 메서드입니다. 또한, ID로 찾을 수 없는 경우 새 레코드를 생성할지 또는 기존 레코드를 업데이트할지 결정하기 위해 insert 메서드를 사용하고 있음을 알 수 있습니다.\n\n```swift\n//  WebService.swift\nimport Foundation\nimport SwiftData\n\nenum NetworkError: Error {\n    case badUrl\n    case invalidRequest\n    case badResponse\n    case badStatus\n    case failedToDecodeResponse\n}\n\nclass WebService {\n    @MainActor\n    func updateDataInDatabase(modelContext: ModelContext) async {\n        do {\n            let itemData: [PhotoDTO] = try await fetchData(fromUrl: \"https://jsonplaceholder.typicode.com/albums/1/photos\")\n            for eachItem in itemData {\n                let itemToStore = PhotoObject(item: eachItem)\n                modelContext.insert(itemToStore)\n            }\n        } catch {\n            print(\"Error fetching data\")\n            print(error.localizedDescription)\n        }\n    }\n\n    private func fetchData<T: Codable>(fromUrl: String) async throws -> [T] {\n        guard let downloadedData: [T] = await WebService().downloadData(fromURL: fromUrl) else { return [] }\n\n        return downloadedData\n    }\n\n    private func downloadData<T: Codable>(fromURL: String) async -> T? {\n        do {\n            guard let url = URL(string: fromURL) else { throw NetworkError.badUrl }\n            let (data, response) = try await URLSession.shared.data(from: url)\n            guard let response = response as? HTTPURLResponse else { throw NetworkError.badResponse }\n            guard response.statusCode >= 200 && response.statusCode < 300 else { throw NetworkError.badStatus }\n            guard let decodedResponse = try? JSONDecoder().decode(T.self, from: data) else { throw NetworkError.failedToDecodeResponse }\n\n            return decodedResponse\n        } catch NetworkError.badUrl {\n            print(\"There was an error creating the URL\")\n        } catch NetworkError.badResponse {\n            print(\"Did not get a valid response\")\n        } catch NetworkError.badStatus {\n            print(\"Did not get a 2xx status code from the response\")\n        } catch NetworkError.failedToDecodeResponse {\n            print(\"Failed to decode response into the given type\")\n        } catch {\n            print(\"An error occured downloading the data\")\n        }\n\n        return nil\n    }\n}\n```\n\n뷰 레이어에서는 데이터베이스에서 PhotoObjects를 읽어와 목록으로 표시합니다. 목록 내에서는 AsyncImage 구성 요소를 사용해 API에서 이미지를 표시하고 해당 항목의 ID를 이미지 옆에 표시합니다. 목록의 하단에는 몇 가지 다른 변형을 추가했습니다. overlay 변형은 목록이 비어 있을 때 진행 스피너를 표시합니다. task 변형은 목록이 비어 있으면 API에서 데이터를 자동으로 가져오도록 합니다. 또한, refreshable 변형을 사용해 목록 구성 요소에 pull to refresh를 추가했습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\"task\" 및 \"refreshable\" 수정자를 사용하면 사용자가 업데이트된 데이터를 확인하려고 할 때만 API가 호출되도록 보장합니다(API를 실행하는 비용을 줄임). 이는 앱을 런칭할 때마다 API에서 데이터를 가져오는 대신 두 번째로 데이터가 데이터베이스에서 가져와지게 함을 의미합니다.\n\n또한 미리보기가 일반적인 경우보다 코드가 더 많이 보일 수 있습니다. SwiftData에서 데이터를 미리보는 것은 일반적인 뷰에서 데이터를 표시하는 것보다 조금 더 복잡하기 때문입니다. 미리보기에서는 데이터가 임시로 저장되는 새 컨테이너를 만들고(미리보기 장치에 데이터를 영구적으로 저장하지 않기 위함), 그런 다음 객체를 만들어 그 컨테이너에 저장합니다. 미리보기 데이터를 저장하는 별도의 파일을 생성하는 다른 자습서도 볼 수 있지만 이는 작동하며 전혀 문제가 없습니다. 저는 미리보기에 대한 코드를 미리보기 자체에 가까이 유지하고 싶어하여 별도의 파일을 생성하지 않았습니다.\n\n```js\n//  ContentView.swift\nimport SwiftData\nimport SwiftUI\n\nstruct ContentView: View {\n    @Environment(\\.modelContext) var modelContext\n    @Query(sort: \\PhotoObject.id) var photos: [PhotoObject]\n\n    var body: some View {\n        List(photos) { item in\n            HStack {\n                Text(item.id, format: .number)\n                Spacer()\n\n                AsyncImage(url: URL(string: item.url)!) { imagePhase in\n                    switch imagePhase {\n                    case .empty:\n                        Image(systemName: \"ellipsis\")\n                    case .success(let returnedImage):\n                        returnedImage\n                            .resizable()\n                            .scaledToFit()\n                    case .failure:\n                        Image(systemName: \"xmark.circle\")\n                            .font(.headline)\n                            .foregroundColor(.red)\n                    @unknown default:\n                        Image(systemName: \"ellipsis\")\n                    }\n                }\n            }\n        }\n        .overlay {\n            if photos.isEmpty {\n                ProgressView()\n            }\n        }\n        .task {\n            if photos.isEmpty {\n                await WebService().updateDataInDatabase(modelContext: modelContext)\n            }\n        }\n        .refreshable {\n            await WebService().updateDataInDatabase(modelContext: modelContext)\n        }\n    }\n}\n\n#Preview {\n    do {\n        let config = ModelConfiguration(isStoredInMemoryOnly: true)\n        let container = try ModelContainer(for: PhotoObject.self, configurations: config)\n        let sampleObject = PhotoObject(\n            albumId: 1,\n            id: 1,\n            title: \"accusamus beatae ad facilis cum similique qui sunt\",\n            url: \"https://via.placeholder.com/600/92c952\",\n            thumbnailUrl: \"https://via.placeholder.com/150/92c952\"\n        )\n        container.mainContext.insert(sampleObject)\n\n        return ContentView().modelContainer(container)\n    } catch {\n        fatalError(\"Failed to create model container\")\n    }\n}\n```\n\n이 글이 유익하다고 느끼신다면, 제를 팔로우하는 것, 이 글에 👏 반응을 보내는 것, 또는 공유하여 다른 사람이 더 쉽게 찾을 수 있도록 돕는 것도 고려해주세요.\"\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n해당 주제에 대해 궁금한 점이 있거나 동일한 작업을 수행하는 다른 방법을 알고 계신다면, 이 게시물에 답글을 달거나 친구에게 공유하여 의견을 얻을 수 있습니다. Native 모바일 개발에 대해 더 배우고 싶다면, 여기에서 작성한 다른 기사들을 확인해보세요: [https://medium.com/@jpmtech](https://medium.com/@jpmtech). Native 모바일 개발로 제작된 앱들을 보고 싶다면, 여기에서 제가 만든 앱들을 확인해보세요: [https://jpmtech.io/apps](https://jpmtech.io/apps). 제 작품을 확인해주셔서 감사합니다!\n","ogImage":{"url":"/assets/img/2024-06-22-UsingSwiftDatatoStoreDatafromaRemoteAPI_0.png"},"coverImage":"/assets/img/2024-06-22-UsingSwiftDatatoStoreDatafromaRemoteAPI_0.png","tag":["Tech"],"readingTime":9},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p>앱 사용자에게 오프라인 기능을 제공하고 앱 운영 비용을 줄이는 데 중요한 로컬 데이터 저장은 매우 중요합니다.</p>\n<p><a href=\"//\" rel=\"nofollow\" target=\"_blank\"><img src=\"/assets/img/2024-06-22-UsingSwiftDatatoStoreDatafromaRemoteAPI_0.png\" alt=\"Image\"></a></p>\n<p>시작하기 전에 몇 초 동안 제 게시물을 팔로우하고 👏 클랩(clap)하여 더 많은 사람들이 이 유용한 내용을 배울 수 있도록 도와주세요.</p>\n<h1>API 호출로부터 SwiftData를 사용하여 로컬로 데이터 저장하기</h1>\n<p></p>\n<p>코드로 넘어가기로 하겠습니다. SwiftData에 익숙하지 않으신 경우, 새로운 내용을 익히시려면 이 기사를 확인해보세요.</p>\n<p>우리는 구조체의 이름 뒤에 약어 DTO(Data Transfer Object)를 추가하기로 결정했습니다. DTO는 한 시스템에서 다른 시스템으로 데이터를 전송하는 데 사용됩니다. 우리의 예제에서는 API 응답의 데이터를 JSON에서 SwiftData entity로 전송하려고 합니다. DTO는 JSON 응답을 일시적으로 보유하여 해당 데이터를 파싱하고 Swift 객체로 변환할 수 있게 합니다. 앞으로 몇 개의 코드 블록에서는 해당 Swift 객체를 SwiftData entity로 변환할 것입니다.</p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-comment\">// PhotoDTO.swift</span>\n<span class=\"hljs-keyword\">import</span> Foundation\n\n<span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">PhotoDTO</span>: <span class=\"hljs-title class_\">Identifiable</span>, <span class=\"hljs-title class_\">Codable</span> {\n    <span class=\"hljs-keyword\">let</span> albumId: <span class=\"hljs-type\">Int</span>\n    <span class=\"hljs-keyword\">let</span> id: <span class=\"hljs-type\">Int</span>\n    <span class=\"hljs-keyword\">let</span> title: <span class=\"hljs-type\">String</span>\n    <span class=\"hljs-keyword\">let</span> url: <span class=\"hljs-type\">String</span>\n    <span class=\"hljs-keyword\">let</span> thumbnailUrl: <span class=\"hljs-type\">String</span>\n}\n</code></pre>\n<p>SwiftData로 시작하는 기사를 읽으신 경우, 이 내용은 익숙하게 느껴질 것입니다. 클래스에 새로운 코드 조각을 추가했는데, 그것은 편의 이니셜라이저입니다. 이를 통해 DTO를 직접 전달하여 SwiftData entity를 생성할 수 있습니다.</p>\n<p></p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-comment\">//  PhotoObject.swift</span>\n<span class=\"hljs-keyword\">import</span> Foundation\n<span class=\"hljs-keyword\">import</span> SwiftData\n\n<span class=\"hljs-meta\">@Model</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">PhotoObject</span> {\n    <span class=\"hljs-keyword\">var</span> albumId: <span class=\"hljs-type\">Int</span>\n    <span class=\"hljs-meta\">@Attribute</span>(.unique) <span class=\"hljs-keyword\">var</span> id: <span class=\"hljs-type\">Int</span>\n    <span class=\"hljs-keyword\">var</span> title: <span class=\"hljs-type\">String</span>\n    <span class=\"hljs-keyword\">var</span> url: <span class=\"hljs-type\">String</span>\n    <span class=\"hljs-keyword\">var</span> thumbnailUrl: <span class=\"hljs-type\">String</span>\n\n    <span class=\"hljs-keyword\">init</span>(<span class=\"hljs-params\">albumId</span>: <span class=\"hljs-type\">Int</span>, <span class=\"hljs-params\">id</span>: <span class=\"hljs-type\">Int</span>, <span class=\"hljs-params\">title</span>: <span class=\"hljs-type\">String</span>, <span class=\"hljs-params\">url</span>: <span class=\"hljs-type\">String</span>, <span class=\"hljs-params\">thumbnailUrl</span>: <span class=\"hljs-type\">String</span>) {\n        <span class=\"hljs-keyword\">self</span>.albumId <span class=\"hljs-operator\">=</span> albumId\n        <span class=\"hljs-keyword\">self</span>.id <span class=\"hljs-operator\">=</span> id\n        <span class=\"hljs-keyword\">self</span>.title <span class=\"hljs-operator\">=</span> title\n        <span class=\"hljs-keyword\">self</span>.url <span class=\"hljs-operator\">=</span> url\n        <span class=\"hljs-keyword\">self</span>.thumbnailUrl <span class=\"hljs-operator\">=</span> thumbnailUrl\n    }\n\n    <span class=\"hljs-keyword\">convenience</span> <span class=\"hljs-keyword\">init</span>(<span class=\"hljs-params\">item</span>: <span class=\"hljs-type\">PhotoDTO</span>) {\n        <span class=\"hljs-keyword\">self</span>.<span class=\"hljs-keyword\">init</span>(\n            albumId: item.albumId,\n            id: item.id,\n            title: item.title,\n            url: item.url,\n            thumbnailUrl: item.thumbnailUrl\n        )\n    }\n}\n</code></pre>\n<p>웹 서비스도 만약 SwiftUI에서 API 호출을 만들고 파싱한 적이 있다면 익숙할 것입니다. 웹 서비스를 살펴보면, 그 기사에서 살짝 수정하여 새로운 기능을 보유한 웹 서비스를 가지고 있다는 것을 알 수 있습니다. updateDataInDatabase를 이용해 API 호출에서 데이터를 파싱할 때마다 데이터를 데이터베이스에 저장할 수 있도록 새 기능을 추가했습니다. updateDataInDatabase 함수는 PhotoDTO를 SwiftData 엔티티로 변환하고 각 레코드를 데이터베이스에 저장하는 메서드입니다. 또한, ID로 찾을 수 없는 경우 새 레코드를 생성할지 또는 기존 레코드를 업데이트할지 결정하기 위해 insert 메서드를 사용하고 있음을 알 수 있습니다.</p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-comment\">//  WebService.swift</span>\n<span class=\"hljs-keyword\">import</span> Foundation\n<span class=\"hljs-keyword\">import</span> SwiftData\n\n<span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title class_\">NetworkError</span>: <span class=\"hljs-title class_\">Error</span> {\n    <span class=\"hljs-keyword\">case</span> badUrl\n    <span class=\"hljs-keyword\">case</span> invalidRequest\n    <span class=\"hljs-keyword\">case</span> badResponse\n    <span class=\"hljs-keyword\">case</span> badStatus\n    <span class=\"hljs-keyword\">case</span> failedToDecodeResponse\n}\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">WebService</span> {\n    <span class=\"hljs-meta\">@MainActor</span>\n    <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">updateDataInDatabase</span>(<span class=\"hljs-params\">modelContext</span>: <span class=\"hljs-type\">ModelContext</span>) <span class=\"hljs-keyword\">async</span> {\n        <span class=\"hljs-keyword\">do</span> {\n            <span class=\"hljs-keyword\">let</span> itemData: [<span class=\"hljs-type\">PhotoDTO</span>] <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">try</span> <span class=\"hljs-keyword\">await</span> fetchData(fromUrl: <span class=\"hljs-string\">\"https://jsonplaceholder.typicode.com/albums/1/photos\"</span>)\n            <span class=\"hljs-keyword\">for</span> eachItem <span class=\"hljs-keyword\">in</span> itemData {\n                <span class=\"hljs-keyword\">let</span> itemToStore <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">PhotoObject</span>(item: eachItem)\n                modelContext.insert(itemToStore)\n            }\n        } <span class=\"hljs-keyword\">catch</span> {\n            <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Error fetching data\"</span>)\n            <span class=\"hljs-built_in\">print</span>(error.localizedDescription)\n        }\n    }\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">fetchData</span>&#x3C;<span class=\"hljs-type\">T</span>: <span class=\"hljs-type\">Codable</span>>(<span class=\"hljs-params\">fromUrl</span>: <span class=\"hljs-type\">String</span>) <span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">throws</span> -> [<span class=\"hljs-type\">T</span>] {\n        <span class=\"hljs-keyword\">guard</span> <span class=\"hljs-keyword\">let</span> downloadedData: [<span class=\"hljs-type\">T</span>] <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">await</span> <span class=\"hljs-type\">WebService</span>().downloadData(fromURL: fromUrl) <span class=\"hljs-keyword\">else</span> { <span class=\"hljs-keyword\">return</span> [] }\n\n        <span class=\"hljs-keyword\">return</span> downloadedData\n    }\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">downloadData</span>&#x3C;<span class=\"hljs-type\">T</span>: <span class=\"hljs-type\">Codable</span>>(<span class=\"hljs-params\">fromURL</span>: <span class=\"hljs-type\">String</span>) <span class=\"hljs-keyword\">async</span> -> <span class=\"hljs-type\">T</span>? {\n        <span class=\"hljs-keyword\">do</span> {\n            <span class=\"hljs-keyword\">guard</span> <span class=\"hljs-keyword\">let</span> url <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">URL</span>(string: fromURL) <span class=\"hljs-keyword\">else</span> { <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-type\">NetworkError</span>.badUrl }\n            <span class=\"hljs-keyword\">let</span> (data, response) <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">try</span> <span class=\"hljs-keyword\">await</span> <span class=\"hljs-type\">URLSession</span>.shared.data(from: url)\n            <span class=\"hljs-keyword\">guard</span> <span class=\"hljs-keyword\">let</span> response <span class=\"hljs-operator\">=</span> response <span class=\"hljs-keyword\">as?</span> <span class=\"hljs-type\">HTTPURLResponse</span> <span class=\"hljs-keyword\">else</span> { <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-type\">NetworkError</span>.badResponse }\n            <span class=\"hljs-keyword\">guard</span> response.statusCode <span class=\"hljs-operator\">>=</span> <span class=\"hljs-number\">200</span> <span class=\"hljs-operator\">&#x26;&#x26;</span> response.statusCode <span class=\"hljs-operator\">&#x3C;</span> <span class=\"hljs-number\">300</span> <span class=\"hljs-keyword\">else</span> { <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-type\">NetworkError</span>.badStatus }\n            <span class=\"hljs-keyword\">guard</span> <span class=\"hljs-keyword\">let</span> decodedResponse <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">try?</span> <span class=\"hljs-type\">JSONDecoder</span>().decode(<span class=\"hljs-type\">T</span>.<span class=\"hljs-keyword\">self</span>, from: data) <span class=\"hljs-keyword\">else</span> { <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-type\">NetworkError</span>.failedToDecodeResponse }\n\n            <span class=\"hljs-keyword\">return</span> decodedResponse\n        } <span class=\"hljs-keyword\">catch</span> <span class=\"hljs-type\">NetworkError</span>.badUrl {\n            <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"There was an error creating the URL\"</span>)\n        } <span class=\"hljs-keyword\">catch</span> <span class=\"hljs-type\">NetworkError</span>.badResponse {\n            <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Did not get a valid response\"</span>)\n        } <span class=\"hljs-keyword\">catch</span> <span class=\"hljs-type\">NetworkError</span>.badStatus {\n            <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Did not get a 2xx status code from the response\"</span>)\n        } <span class=\"hljs-keyword\">catch</span> <span class=\"hljs-type\">NetworkError</span>.failedToDecodeResponse {\n            <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Failed to decode response into the given type\"</span>)\n        } <span class=\"hljs-keyword\">catch</span> {\n            <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"An error occured downloading the data\"</span>)\n        }\n\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span>\n    }\n}\n</code></pre>\n<p>뷰 레이어에서는 데이터베이스에서 PhotoObjects를 읽어와 목록으로 표시합니다. 목록 내에서는 AsyncImage 구성 요소를 사용해 API에서 이미지를 표시하고 해당 항목의 ID를 이미지 옆에 표시합니다. 목록의 하단에는 몇 가지 다른 변형을 추가했습니다. overlay 변형은 목록이 비어 있을 때 진행 스피너를 표시합니다. task 변형은 목록이 비어 있으면 API에서 데이터를 자동으로 가져오도록 합니다. 또한, refreshable 변형을 사용해 목록 구성 요소에 pull to refresh를 추가했습니다.</p>\n<p></p>\n<p>\"task\" 및 \"refreshable\" 수정자를 사용하면 사용자가 업데이트된 데이터를 확인하려고 할 때만 API가 호출되도록 보장합니다(API를 실행하는 비용을 줄임). 이는 앱을 런칭할 때마다 API에서 데이터를 가져오는 대신 두 번째로 데이터가 데이터베이스에서 가져와지게 함을 의미합니다.</p>\n<p>또한 미리보기가 일반적인 경우보다 코드가 더 많이 보일 수 있습니다. SwiftData에서 데이터를 미리보는 것은 일반적인 뷰에서 데이터를 표시하는 것보다 조금 더 복잡하기 때문입니다. 미리보기에서는 데이터가 임시로 저장되는 새 컨테이너를 만들고(미리보기 장치에 데이터를 영구적으로 저장하지 않기 위함), 그런 다음 객체를 만들어 그 컨테이너에 저장합니다. 미리보기 데이터를 저장하는 별도의 파일을 생성하는 다른 자습서도 볼 수 있지만 이는 작동하며 전혀 문제가 없습니다. 저는 미리보기에 대한 코드를 미리보기 자체에 가까이 유지하고 싶어하여 별도의 파일을 생성하지 않았습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">//  ContentView.swift</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">SwiftData</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">SwiftUI</span>\n\nstruct <span class=\"hljs-title class_\">ContentView</span>: <span class=\"hljs-title class_\">View</span> {\n    @<span class=\"hljs-title class_\">Environment</span>(\\.<span class=\"hljs-property\">modelContext</span>) <span class=\"hljs-keyword\">var</span> modelContext\n    @<span class=\"hljs-title class_\">Query</span>(<span class=\"hljs-attr\">sort</span>: \\<span class=\"hljs-title class_\">PhotoObject</span>.<span class=\"hljs-property\">id</span>) <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">photos</span>: [<span class=\"hljs-title class_\">PhotoObject</span>]\n\n    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">body</span>: some <span class=\"hljs-title class_\">View</span> {\n        <span class=\"hljs-title class_\">List</span>(photos) { item <span class=\"hljs-keyword\">in</span>\n            <span class=\"hljs-title class_\">HStack</span> {\n                <span class=\"hljs-title class_\">Text</span>(item.<span class=\"hljs-property\">id</span>, <span class=\"hljs-attr\">format</span>: .<span class=\"hljs-property\">number</span>)\n                <span class=\"hljs-title class_\">Spacer</span>()\n\n                <span class=\"hljs-title class_\">AsyncImage</span>(<span class=\"hljs-attr\">url</span>: <span class=\"hljs-title function_\">URL</span>(<span class=\"hljs-attr\">string</span>: item.<span class=\"hljs-property\">url</span>)!) { imagePhase <span class=\"hljs-keyword\">in</span>\n                    <span class=\"hljs-keyword\">switch</span> imagePhase {\n                    <span class=\"hljs-keyword\">case</span> .<span class=\"hljs-property\">empty</span>:\n                        <span class=\"hljs-title class_\">Image</span>(<span class=\"hljs-attr\">systemName</span>: <span class=\"hljs-string\">\"ellipsis\"</span>)\n                    <span class=\"hljs-keyword\">case</span> .<span class=\"hljs-title function_\">success</span>(<span class=\"hljs-keyword\">let</span> returnedImage):\n                        returnedImage\n                            .<span class=\"hljs-title function_\">resizable</span>()\n                            .<span class=\"hljs-title function_\">scaledToFit</span>()\n                    <span class=\"hljs-keyword\">case</span> .<span class=\"hljs-property\">failure</span>:\n                        <span class=\"hljs-title class_\">Image</span>(<span class=\"hljs-attr\">systemName</span>: <span class=\"hljs-string\">\"xmark.circle\"</span>)\n                            .<span class=\"hljs-title function_\">font</span>(.<span class=\"hljs-property\">headline</span>)\n                            .<span class=\"hljs-title function_\">foregroundColor</span>(.<span class=\"hljs-property\">red</span>)\n                    @unknown <span class=\"hljs-attr\">default</span>:\n                        <span class=\"hljs-title class_\">Image</span>(<span class=\"hljs-attr\">systemName</span>: <span class=\"hljs-string\">\"ellipsis\"</span>)\n                    }\n                }\n            }\n        }\n        .<span class=\"hljs-property\">overlay</span> {\n            <span class=\"hljs-keyword\">if</span> photos.<span class=\"hljs-property\">isEmpty</span> {\n                <span class=\"hljs-title class_\">ProgressView</span>()\n            }\n        }\n        .<span class=\"hljs-property\">task</span> {\n            <span class=\"hljs-keyword\">if</span> photos.<span class=\"hljs-property\">isEmpty</span> {\n                <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title class_\">WebService</span>().<span class=\"hljs-title function_\">updateDataInDatabase</span>(<span class=\"hljs-attr\">modelContext</span>: modelContext)\n            }\n        }\n        .<span class=\"hljs-property\">refreshable</span> {\n            <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title class_\">WebService</span>().<span class=\"hljs-title function_\">updateDataInDatabase</span>(<span class=\"hljs-attr\">modelContext</span>: modelContext)\n        }\n    }\n}\n\n#<span class=\"hljs-title class_\">Preview</span> {\n    <span class=\"hljs-keyword\">do</span> {\n        <span class=\"hljs-keyword\">let</span> config = <span class=\"hljs-title class_\">ModelConfiguration</span>(<span class=\"hljs-attr\">isStoredInMemoryOnly</span>: <span class=\"hljs-literal\">true</span>)\n        <span class=\"hljs-keyword\">let</span> container = <span class=\"hljs-keyword\">try</span> <span class=\"hljs-title class_\">ModelContainer</span>(<span class=\"hljs-attr\">for</span>: <span class=\"hljs-title class_\">PhotoObject</span>.<span class=\"hljs-property\">self</span>, <span class=\"hljs-attr\">configurations</span>: config)\n        <span class=\"hljs-keyword\">let</span> sampleObject = <span class=\"hljs-title class_\">PhotoObject</span>(\n            <span class=\"hljs-attr\">albumId</span>: <span class=\"hljs-number\">1</span>,\n            <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">1</span>,\n            <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">\"accusamus beatae ad facilis cum similique qui sunt\"</span>,\n            <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">\"https://via.placeholder.com/600/92c952\"</span>,\n            <span class=\"hljs-attr\">thumbnailUrl</span>: <span class=\"hljs-string\">\"https://via.placeholder.com/150/92c952\"</span>\n        )\n        container.<span class=\"hljs-property\">mainContext</span>.<span class=\"hljs-title function_\">insert</span>(sampleObject)\n\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">ContentView</span>().<span class=\"hljs-title function_\">modelContainer</span>(container)\n    } <span class=\"hljs-keyword\">catch</span> {\n        <span class=\"hljs-title function_\">fatalError</span>(<span class=\"hljs-string\">\"Failed to create model container\"</span>)\n    }\n}\n</code></pre>\n<p>이 글이 유익하다고 느끼신다면, 제를 팔로우하는 것, 이 글에 👏 반응을 보내는 것, 또는 공유하여 다른 사람이 더 쉽게 찾을 수 있도록 돕는 것도 고려해주세요.\"</p>\n<p></p>\n<p>해당 주제에 대해 궁금한 점이 있거나 동일한 작업을 수행하는 다른 방법을 알고 계신다면, 이 게시물에 답글을 달거나 친구에게 공유하여 의견을 얻을 수 있습니다. Native 모바일 개발에 대해 더 배우고 싶다면, 여기에서 작성한 다른 기사들을 확인해보세요: <a href=\"https://medium.com/@jpmtech\" rel=\"nofollow\" target=\"_blank\">https://medium.com/@jpmtech</a>. Native 모바일 개발로 제작된 앱들을 보고 싶다면, 여기에서 제가 만든 앱들을 확인해보세요: <a href=\"https://jpmtech.io/apps\" rel=\"nofollow\" target=\"_blank\">https://jpmtech.io/apps</a>. 제 작품을 확인해주셔서 감사합니다!</p>\n</body>\n</html>\n"},"__N_SSG":true}