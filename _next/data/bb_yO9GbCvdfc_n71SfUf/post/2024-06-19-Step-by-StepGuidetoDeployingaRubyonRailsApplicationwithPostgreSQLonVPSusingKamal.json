{"pageProps":{"post":{"title":"Ruby on Rails 응용 프로그램을 PostgreSQL을 사용하여 VPS에 Kamal을 이용하여 배포하는 단계별 안내","description":"","date":"2024-06-19 22:12","slug":"2024-06-19-Step-by-StepGuidetoDeployingaRubyonRailsApplicationwithPostgreSQLonVPSusingKamal","content":"\n![image](/assets/img/2024-06-19-Step-by-StepGuidetoDeployingaRubyonRailsApplicationwithPostgreSQLonVPSusingKamal_0.png)\n\n이 튜토리얼에서는 DigitalOcean에서 제공하는 Virtual Private Server (VPS)에 Ruby on Rails 애플리케이션을 PostgreSQL 데이터베이스와 함께 배포하는 과정을 안내하겠습니다. Docker 기반 애플리케이션을 자동화하는 배포 도구 인 Kamal을 활용하여 배포 프로세스를 자동화할 것입니다.\n\n# 전제 조건\n\n시작하기 전에 다음 사항을 갖추었는지 확인하세요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- PostgreSQL이 구성된 Ruby on Rails 애플리케이션.\n- VPS (droplet)가 프로비저닝되어 SSH 액세스가 설정된 DigitalOcean 계정. 원하는 제공업체를 사용해도 됩니다.\n\n# 단계 1: Kamal 설치\n\n로컬 머신에 Kamal이 설치되어 있는지 확인하세요. RubyGems를 통해 설치할 수 있습니다:\n\n```js\ngem install kamal\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 단계 2: 배포 설정 구성\n\n프로젝트 디렉토리로 이동한 다음 다음을 실행하세요:\n\n```js\nkamal init\n```\n\n이 명령은 deploy.yml 설정 파일을 생성하고 다른 몇 가지 파일을 함께 생성합니다. deploy.yml 구성 파일의 여러 섹션을 이해해 봅시다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n# 애플리케이션의 이름. 고유하게 컨테이너를 구성하는 데 사용됩니다.\nservice: mynewapp\n```\n\n애플리케이션의 이름을 지정합니다. 이는 애플리케이션과 관련된 컨테이너를 고유하게 구성하는 데 사용됩니다.\n\n```js\n# 컨테이너 이미지의 이름.\nimage: talha/mynewapp\n```\n\n애플리케이션에 대한 Docker 컨테이너 이미지의 이름을 지정합니다. talha/mynewapp를 Docker Hub 저장소의 이름으로 교체하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n# 이러한 서버에 배포할 수 있습니다.\n서버:\n  웹:\n    호스트:\n      - 123.123.45.678\n    라벨:\n      traefik.http.routers.mynewapp.rule: Host(`mynewapp.com`)\n      traefik.http.routers.mynewapp.entrypoints: websecure\n      traefik.http.routers.mynewapp_secure.rule: Host(`mynewapp.com`)\n      traefik.http.routers.mynewapp_secure.tls: true\n      traefik.http.routers.mynewapp_secure.tls.certresolver: letsencrypt\n    옵션:\n      네트워크: \"private\"\n```\n\n어플리케이션이 배포될 서버를 정의하고, HTTP 요청을 앱에 라우팅하고 TLS/SSL 암호화를 활성화하기 위한 Traefik 설정을 구성합니다.\n\n```js\n# 이미지 호스트에 대한 자격 증명.\n레지스트리:\n  사용자 이름:\n    - KAMAL_REGISTRY_USERNAME\n  비밀번호:\n    - KAMAL_REGISTRY_PASSWORD\n```\n\n어플리케이션 이미지가 호스팅된 Docker 이미지 레지스트리에 액세스하는 자격 증명을 지정합니다. KAMAL_REGISTRY_USERNAME 및 KAMAL_REGISTRY_PASSWORD를 Docker 허브 자격 증명으로 교체하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```yaml\n# 컨테이너에 환경 변수 주입 (시크릿은 .env에서 온다).\n# 변경 후 `kamal env push`를 실행하는 것을 잊지 마세요!\nenv:\n  clear:\n    RAILS_ENV: production\n    RACK_ENV: production\n    RAILS_LOG_TO_STDOUT: true\n    RAILS_SERVE_STATIC_FILES: true\n  secret:\n    - RAILS_MASTER_KEY\n    - SMTP_PASSWORD\n    - SMTP_SERVER\n    - SMTP_LOGIN\n    - DB_HOST\n    - POSTGRES_USER\n    - POSTGRES_PASSWORD\n```\n\n컨테이너의 환경 변수를 지정합니다. clear 변수는 공개적으로 접근 가능하며, 시크릿 변수는 비공개로 유지됩니다. 이러한 변수는 .env 파일에서 가져옵니다.\n\n```yaml\n# root가 아닌 다른 ssh 사용자 사용\nssh:\n  user: deploy\n```\n\n- 서버에 액세스하는 데 사용할 SSH 사용자를 지정합니다. 이 경우 사용자는 deploy입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```yaml\n# 빌더 설정 구성.\n빌더:\n  원격:\n    아키텍처: amd64\n```\n\n빌더 설정을 구성하여 응용 프로그램을 빌드할 원격 서버의 아키텍처를 지정합니다. 위의 구성은 Apple Silicon에서 개발하고 있지만 amd64 도커 이미지만 빌드하려는 경우 유용합니다.\n\n```yaml\n# 부가 서비스 사용 (비밀은 .env에서 제공됨).\n부가서비스:\n  db:\n    이미지: postgres:16.0\n    호스트: 123.123.45.678\n    환경:\n      클리어:\n        POSTGRES_USER: \"mynewapp\"\n        POSTGRES_DB: \"mynewapp_production\"\n      시크릿:\n        - POSTGRES_PASSWORD\n        - POSTGRES_USER\n    파일:\n      - config/init.sql:/docker-entrypoint-initdb.d/setup.sql\n    디렉토리:\n      - data:/var/lib/postgresql/data\n    옵션:\n      네트워크: \"private\"\n```\n\n응용 프로그램에서 필요한 추가 서비스를 정의합니다. 이 경우 지정된 버전과 환경 변수를 갖는 PostgreSQL 데이터베이스 서비스를 구성합니다. 파일 지시문을 사용하여 자체 엔트리포인트를 제공할 수 있습니다. config/init.sql은 config/database.yml 구성에서 예상한대로 데이터베이스를 생성해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nCREATE DATABASE mynewapp_production;\n```\n\n위 명령어를 사용하여 새로운 파일 config/init.sql을 만들어주세요.\n\n```js\nproduction:\n  <<: *default\n  database: mynewapp_production\n  username: <%= ENV[\"POSTGRES_USER\"] %>\n  password: <%= ENV[\"POSTGRES_PASSWORD\"] %>\n  host: <%= ENV[\"DB_HOST\"] %>\n```\n\n또한, 위와 같이 database.yml 파일을 업데이트하여 프로덕션 DB 구성을 업데이트해주세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```yaml\ntraefik:\n  options:\n    publish:\n      - \"443:443\"\n    volume:\n      - \"/letsencrypt/acme.json:/letsencrypt/acme.json\"\n    network: \"private\"\n  args:\n    entryPoints.web.address: \":80\"\n    entryPoints.websecure.address: \":443\"\n    entryPoints.web.http.redirections.entryPoint.to: websecure\n    entryPoints.web.http.redirections.entryPoint.scheme: https\n    entryPoints.web.http.redirections.entrypoint.permanent: true\n    certificatesResolvers.letsencrypt.acme.email: \"info@mynewapp.com\"\n    certificatesResolvers.letsencrypt.acme.storage: \"/letsencrypt/acme.json\"\n    certificatesResolvers.letsencrypt.acme.httpchallenge: true\n    certificatesResolvers.letsencrypt.acme.httpchallenge.entrypoint: web\n```\n\nTraefik을 설정하여 HTTPS 요청을 처리하고 Let's Encrypt를 사용하여 SSL 인증서를 자동으로 관리하도록 구성합니다.\n\n아래에 완전한 deploy.yml 파일을 찾을 수 있어요:\n\n```yaml\n# 애플리케이션의 이름. 컨테이너를 고유하게 설정하는 데 사용됩니다.\nservice: mynewapp\n\n# 컨테이너 이미지의 이름입니다.\nimage: talha/mynewapp\n\n# 이 서버로 배포합니다.\nservers:\n  web:\n    hosts:\n      - 123.123.45.678\n    labels:\n      traefik.http.routers.mynewapp.rule: Host(`mynewapp.com`)\n      traefik.http.routers.mynewapp.entrypoints: websecure\n      traefik.http.routers.mynewapp_secure.rule: Host(`mynewapp.com`)\n      traefik.http.routers.mynewapp_secure.tls: true\n      traefik.http.routers.mynewapp_secure.tls.certresolver: letsencrypt\n    options:\n      network: \"private\"\n\n# 이미지 호스트의 자격 증명입니다.\nregistry:\n  username:\n    - KAMAL_REGISTRY_USERNAME\n  password:\n    - KAMAL_REGISTRY_PASSWORD\n\n# 컨테이너로 ENV 변수를 주입합니다(비밀은 .env에서 가져옵니다).\n# 변경 후 `kamal env push`를 실행하는 것을 잊지 마세요!\nenv:\n  clear:\n    RAILS_ENV: production\n    RACK_ENV: production\n    RAILS_LOG_TO_STDOUT: true\n    RAILS_SERVE_STATIC_FILES: true\n  secret:\n    - RAILS_MASTER_KEY\n    - SMTP_PASSWORD\n    - SMTP_SERVER\n    - SMTP_LOGIN\n    - DB_HOST\n    - POSTGRES_USER\n    - POSTGRES_PASSWORD\n\n# root가 아닌 다른 ssh 사용자를 사용합니다.\nssh:\n  user: deploy\n\n# 빌더 설정을 구성합니다.\nbuilder:\n  remote:\n    arch: amd64\n\n# 보조 서비스를 사용합니다(비밀은 .env에서 가져옵니다).\naccessories:\n  db:\n    image: postgres:16.0\n    host: 123.123.45.678\n    env:\n      clear:\n        POSTGRES_USER: \"mynewapp\"\n        POSTGRES_DB: \"mynewapp_production\"\n      secret:\n        - POSTGRES_PASSWORD\n        - POSTGRES_USER\n    files:\n      - config/init.sql:/docker-entrypoint-initdb.d/setup.sql\n    directories:\n      - data:/var/lib/postgresql/data\n    options:\n      network: \"private\"\n\ntraefik:\n  options:\n    publish:\n      - \"443:443\"\n    volume:\n      - \"/letsencrypt/acme.json:/letsencrypt/acme.json\"\n    network: \"private\"\n  args:\n    entryPoints.web.address: \":80\"\n    entryPoints.websecure.address: \":443\"\n    entryPoints.web.http.redirections.entryPoint.to: websecure\n    entryPoints.web.http.redirections.entryPoint.scheme: https\n    entryPoints.web.http.redirections.entrypoint.permanent: true\n    certificatesResolvers.letsencrypt.acme.email: \"info@mynewapp.com\"\n    certificatesResolvers.letsencrypt.acme.storage: \"/letsencrypt/acme.json\"\n    certificatesResolvers.letsencrypt.acme.httpchallenge: true\n    certificatesResolvers.letsencrypt.acme.httpchallenge.entrypoint: web\n\nasset_path: /rails/public/assets\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 예시를 참고하여 실제 애플리케이션 이름, 도메인 및 서버 IP 주소로 mynewapp, mynewapp.com 및 123.123.45.678와 같은 자리 표시자를 교체해주세요.\n\n# 단계 3: 배포 사용자 생성\n\nVPS에 SSH로 접속하고 새로운 사용자 deploy를 만들어보세요. 아래 명령어를 실행하세요.\n\n로컬 머신에서 터미널을 열고 SSH를 사용하여 VPS에 연결합니다. 실제 VPS의 IP 주소로 your_server_ip를 교체해주세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```sh\nssh root@your_server_ip\n```\n\n다음 명령어를 실행하여 새로운 사용자 deploy를 생성하세요:\n\n```sh\nadduser deploy\n```\n\n새 사용자에 대한 암호를 설정하고 추가 정보를 입력하라는 프롬프트가 표시됩니다. 선택 사항을 건너뛰려면 Enter 키를 누르세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n(선택사항) 배포 사용자에게 sudo 권한을 부여하고 싶다면 다음 명령을 실행하여 sudo 그룹에 추가할 수 있습니다:\n\n```js\nusermod -aG sudo deploy\n```\n\n# 단계 4: VPS에 Docker 설치하기:\n\nDocker를 설치하기 전에 패키지 인덱스를 업데이트하는 것이 좋은 실천법입니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\napt update\n```\n\nHTTPS를 통해 저장소를 사용할 수 있도록 패키지를 설치하고 Docker에 필요한 몇 가지 패키지를 설치하세요:\n\n```js\napt install -y apt-transport-https ca-certificates curl software-properties-common\n```\n\n시스템에 Docker의 공식 GPG 키를 추가하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\ncurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -\n```\n\nDocker 리포지토리를 APT 원본에 추가하세요:\n\n```js\nadd-apt-repository \"deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\"\n```\n\n한번 더 패키지 인덱스를 업데이트하세요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```bash\napt update\n```\n\n최신 버전의 Docker CE (Community Edition)와 containerd를 함께 설치하려면:\n\n```bash\napt install -y docker-ce docker-ce-cli containerd.io\n```\n\nDocker 서비스를 시작하고 부팅 시 자동으로 시작되도록 설정하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nsystemctl start docker\nsystemctl enable docker\n```\n\n다음 명령어를 실행하여 Docker가 올바르게 설치되었는지 확인하세요. 이 명령은 Docker 버전 정보를 출력해야 합니다:\n\n```js\ndocker --version\n```\n\n마지막으로, 프라이빗 Docker 네트워크를 생성하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n도커 네트워크 생성 -d bridge private\n```\n\n# 단계 5: LetsEncrypt 설치하기:\n\n로컬 머신에서 터미널을 열고 SSH를 사용하여 VPS에 연결합니다. 실제 VPS의 IP 주소로 your_server_ip를 대체하십시오.\n\n```js\nssh root@your_server_ip\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음 명령을 사용하여 Let's Encrypt 디렉토리를 설정하세요:\n\n```js\nmkdir -p /letsencrypt && touch /letsencrypt/acme.json && chmod 600 /letsencrypt/acme.json\n```\n\n# 단계 6: 애플리케이션 배포\n\n처음부터 모든 단계를 거쳐 config/deploy.yml 파일을 작성했고 배포할 준비가 되었다면, 다음을 실행하세요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nkamal setup\n```\n\n# Step 7: 일일 업무 흐름\n\n카말의 명령어를 사용하여 매일 배포 작업을 수행하세요:\n\n앱의 새 버전을 배포하려면:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nkamal deploy\n```\n\n환경 변수를 업데이트하려면:\n\n```js\nkamal env push\n```\n\n새 컨테이너에서 bash 세션을 시작하려면:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nkamal app exec -i bash\n```\n\n새로운 컨테이너에서 Rails 콘솔을 시작하려면:\n\n```js\nkamal app exec -i ‘bin/rails console’\n```\n\n로그 보기:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nkamal 앱 로그\n```\n\n# 결론\n\n축하합니다! 카말(Kamal)을 사용하여 디지턈오션(DigitalOcean) VPS에서 PostgreSQL과 함께 루비 온 레일즈(Ruby on Rails) 애플리케이션을 성공적으로 배포했습니다. 이제 구성된 도메인 이름으로 애플리케이션에 액세스할 수 있습니다. 🚀\n\n이 포스트가 마음에 들었다면 좋아요를 눌러 주시고 미디엄(Medium)과 트위터(Twitter)에서도 저를 팔로우해주세요(https://twitter.com/royalty568).\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n시간을 절약하고 앱을 즉시 구축하고자 한다면 Rails 보일러플레이트를 찾고 계신 것 같네요. https://talha345.gumroad.com/l/rails7-bootstrap5-devise-fa-psql-boldo-boilerplate 를 확인해보세요!\n","ogImage":{"url":"/assets/img/2024-06-19-Step-by-StepGuidetoDeployingaRubyonRailsApplicationwithPostgreSQLonVPSusingKamal_0.png"},"coverImage":"/assets/img/2024-06-19-Step-by-StepGuidetoDeployingaRubyonRailsApplicationwithPostgreSQLonVPSusingKamal_0.png","tag":["Tech"],"readingTime":16},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p><img src=\"/assets/img/2024-06-19-Step-by-StepGuidetoDeployingaRubyonRailsApplicationwithPostgreSQLonVPSusingKamal_0.png\" alt=\"image\"></p>\n<p>이 튜토리얼에서는 DigitalOcean에서 제공하는 Virtual Private Server (VPS)에 Ruby on Rails 애플리케이션을 PostgreSQL 데이터베이스와 함께 배포하는 과정을 안내하겠습니다. Docker 기반 애플리케이션을 자동화하는 배포 도구 인 Kamal을 활용하여 배포 프로세스를 자동화할 것입니다.</p>\n<h1>전제 조건</h1>\n<p>시작하기 전에 다음 사항을 갖추었는지 확인하세요:</p>\n<p></p>\n<ul>\n<li>PostgreSQL이 구성된 Ruby on Rails 애플리케이션.</li>\n<li>VPS (droplet)가 프로비저닝되어 SSH 액세스가 설정된 DigitalOcean 계정. 원하는 제공업체를 사용해도 됩니다.</li>\n</ul>\n<h1>단계 1: Kamal 설치</h1>\n<p>로컬 머신에 Kamal이 설치되어 있는지 확인하세요. RubyGems를 통해 설치할 수 있습니다:</p>\n<pre><code class=\"hljs language-js\">gem install kamal\n</code></pre>\n<p></p>\n<h1>단계 2: 배포 설정 구성</h1>\n<p>프로젝트 디렉토리로 이동한 다음 다음을 실행하세요:</p>\n<pre><code class=\"hljs language-js\">kamal init\n</code></pre>\n<p>이 명령은 deploy.yml 설정 파일을 생성하고 다른 몇 가지 파일을 함께 생성합니다. deploy.yml 구성 파일의 여러 섹션을 이해해 봅시다.</p>\n<p></p>\n<pre><code class=\"hljs language-js\"># 애플리케이션의 이름. 고유하게 컨테이너를 구성하는 데 사용됩니다.\n<span class=\"hljs-attr\">service</span>: mynewapp\n</code></pre>\n<p>애플리케이션의 이름을 지정합니다. 이는 애플리케이션과 관련된 컨테이너를 고유하게 구성하는 데 사용됩니다.</p>\n<pre><code class=\"hljs language-js\"># 컨테이너 이미지의 이름.\n<span class=\"hljs-attr\">image</span>: talha/mynewapp\n</code></pre>\n<p>애플리케이션에 대한 Docker 컨테이너 이미지의 이름을 지정합니다. talha/mynewapp를 Docker Hub 저장소의 이름으로 교체하세요.</p>\n<p></p>\n<pre><code class=\"hljs language-js\"># 이러한 서버에 배포할 수 있습니다.\n서버:\n  웹:\n    호스트:\n      - <span class=\"hljs-number\">123.123</span><span class=\"hljs-number\">.45</span><span class=\"hljs-number\">.678</span>\n    라벨:\n      traefik.<span class=\"hljs-property\">http</span>.<span class=\"hljs-property\">routers</span>.<span class=\"hljs-property\">mynewapp</span>.<span class=\"hljs-property\">rule</span>: <span class=\"hljs-title class_\">Host</span>(<span class=\"hljs-string\">`mynewapp.com`</span>)\n      traefik.<span class=\"hljs-property\">http</span>.<span class=\"hljs-property\">routers</span>.<span class=\"hljs-property\">mynewapp</span>.<span class=\"hljs-property\">entrypoints</span>: websecure\n      traefik.<span class=\"hljs-property\">http</span>.<span class=\"hljs-property\">routers</span>.<span class=\"hljs-property\">mynewapp_secure</span>.<span class=\"hljs-property\">rule</span>: <span class=\"hljs-title class_\">Host</span>(<span class=\"hljs-string\">`mynewapp.com`</span>)\n      traefik.<span class=\"hljs-property\">http</span>.<span class=\"hljs-property\">routers</span>.<span class=\"hljs-property\">mynewapp_secure</span>.<span class=\"hljs-property\">tls</span>: <span class=\"hljs-literal\">true</span>\n      traefik.<span class=\"hljs-property\">http</span>.<span class=\"hljs-property\">routers</span>.<span class=\"hljs-property\">mynewapp_secure</span>.<span class=\"hljs-property\">tls</span>.<span class=\"hljs-property\">certresolver</span>: letsencrypt\n    옵션:\n      네트워크: <span class=\"hljs-string\">\"private\"</span>\n</code></pre>\n<p>어플리케이션이 배포될 서버를 정의하고, HTTP 요청을 앱에 라우팅하고 TLS/SSL 암호화를 활성화하기 위한 Traefik 설정을 구성합니다.</p>\n<pre><code class=\"hljs language-js\"># 이미지 호스트에 대한 자격 증명.\n레지스트리:\n  사용자 이름:\n    - <span class=\"hljs-variable constant_\">KAMAL_REGISTRY_USERNAME</span>\n  비밀번호:\n    - <span class=\"hljs-variable constant_\">KAMAL_REGISTRY_PASSWORD</span>\n</code></pre>\n<p>어플리케이션 이미지가 호스팅된 Docker 이미지 레지스트리에 액세스하는 자격 증명을 지정합니다. KAMAL_REGISTRY_USERNAME 및 KAMAL_REGISTRY_PASSWORD를 Docker 허브 자격 증명으로 교체하세요.</p>\n<p></p>\n<pre><code class=\"hljs language-yaml\"><span class=\"hljs-comment\"># 컨테이너에 환경 변수 주입 (시크릿은 .env에서 온다).</span>\n<span class=\"hljs-comment\"># 변경 후 `kamal env push`를 실행하는 것을 잊지 마세요!</span>\n<span class=\"hljs-attr\">env:</span>\n  <span class=\"hljs-attr\">clear:</span>\n    <span class=\"hljs-attr\">RAILS_ENV:</span> <span class=\"hljs-string\">production</span>\n    <span class=\"hljs-attr\">RACK_ENV:</span> <span class=\"hljs-string\">production</span>\n    <span class=\"hljs-attr\">RAILS_LOG_TO_STDOUT:</span> <span class=\"hljs-literal\">true</span>\n    <span class=\"hljs-attr\">RAILS_SERVE_STATIC_FILES:</span> <span class=\"hljs-literal\">true</span>\n  <span class=\"hljs-attr\">secret:</span>\n    <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">RAILS_MASTER_KEY</span>\n    <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">SMTP_PASSWORD</span>\n    <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">SMTP_SERVER</span>\n    <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">SMTP_LOGIN</span>\n    <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">DB_HOST</span>\n    <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">POSTGRES_USER</span>\n    <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">POSTGRES_PASSWORD</span>\n</code></pre>\n<p>컨테이너의 환경 변수를 지정합니다. clear 변수는 공개적으로 접근 가능하며, 시크릿 변수는 비공개로 유지됩니다. 이러한 변수는 .env 파일에서 가져옵니다.</p>\n<pre><code class=\"hljs language-yaml\"><span class=\"hljs-comment\"># root가 아닌 다른 ssh 사용자 사용</span>\n<span class=\"hljs-attr\">ssh:</span>\n  <span class=\"hljs-attr\">user:</span> <span class=\"hljs-string\">deploy</span>\n</code></pre>\n<ul>\n<li>서버에 액세스하는 데 사용할 SSH 사용자를 지정합니다. 이 경우 사용자는 deploy입니다.</li>\n</ul>\n<p></p>\n<pre><code class=\"hljs language-yaml\"><span class=\"hljs-comment\"># 빌더 설정 구성.</span>\n<span class=\"hljs-string\">빌더:</span>\n  <span class=\"hljs-string\">원격:</span>\n    <span class=\"hljs-string\">아키텍처:</span> <span class=\"hljs-string\">amd64</span>\n</code></pre>\n<p>빌더 설정을 구성하여 응용 프로그램을 빌드할 원격 서버의 아키텍처를 지정합니다. 위의 구성은 Apple Silicon에서 개발하고 있지만 amd64 도커 이미지만 빌드하려는 경우 유용합니다.</p>\n<pre><code class=\"hljs language-yaml\"><span class=\"hljs-comment\"># 부가 서비스 사용 (비밀은 .env에서 제공됨).</span>\n<span class=\"hljs-string\">부가서비스:</span>\n  <span class=\"hljs-attr\">db:</span>\n    <span class=\"hljs-string\">이미지:</span> <span class=\"hljs-string\">postgres:16.0</span>\n    <span class=\"hljs-string\">호스트:</span> <span class=\"hljs-number\">123.123</span><span class=\"hljs-number\">.45</span><span class=\"hljs-number\">.678</span>\n    <span class=\"hljs-string\">환경:</span>\n      <span class=\"hljs-string\">클리어:</span>\n        <span class=\"hljs-attr\">POSTGRES_USER:</span> <span class=\"hljs-string\">\"mynewapp\"</span>\n        <span class=\"hljs-attr\">POSTGRES_DB:</span> <span class=\"hljs-string\">\"mynewapp_production\"</span>\n      <span class=\"hljs-string\">시크릿:</span>\n        <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">POSTGRES_PASSWORD</span>\n        <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">POSTGRES_USER</span>\n    <span class=\"hljs-string\">파일:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">config/init.sql:/docker-entrypoint-initdb.d/setup.sql</span>\n    <span class=\"hljs-string\">디렉토리:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">data:/var/lib/postgresql/data</span>\n    <span class=\"hljs-string\">옵션:</span>\n      <span class=\"hljs-string\">네트워크:</span> <span class=\"hljs-string\">\"private\"</span>\n</code></pre>\n<p>응용 프로그램에서 필요한 추가 서비스를 정의합니다. 이 경우 지정된 버전과 환경 변수를 갖는 PostgreSQL 데이터베이스 서비스를 구성합니다. 파일 지시문을 사용하여 자체 엔트리포인트를 제공할 수 있습니다. config/init.sql은 config/database.yml 구성에서 예상한대로 데이터베이스를 생성해야 합니다.</p>\n<p></p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable constant_\">CREATE</span> <span class=\"hljs-variable constant_\">DATABASE</span> mynewapp_production;\n</code></pre>\n<p>위 명령어를 사용하여 새로운 파일 config/init.sql을 만들어주세요.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-attr\">production</span>:\n  &#x3C;&#x3C;: *<span class=\"hljs-keyword\">default</span>\n  <span class=\"hljs-attr\">database</span>: mynewapp_production\n  <span class=\"hljs-attr\">username</span>: &#x3C;%= <span class=\"hljs-variable constant_\">ENV</span>[<span class=\"hljs-string\">\"POSTGRES_USER\"</span>] %>\n  <span class=\"hljs-attr\">password</span>: &#x3C;%= <span class=\"hljs-variable constant_\">ENV</span>[<span class=\"hljs-string\">\"POSTGRES_PASSWORD\"</span>] %>\n  <span class=\"hljs-attr\">host</span>: &#x3C;%= <span class=\"hljs-variable constant_\">ENV</span>[<span class=\"hljs-string\">\"DB_HOST\"</span>] %>\n</code></pre>\n<p>또한, 위와 같이 database.yml 파일을 업데이트하여 프로덕션 DB 구성을 업데이트해주세요.</p>\n<p></p>\n<pre><code class=\"hljs language-yaml\"><span class=\"hljs-attr\">traefik:</span>\n  <span class=\"hljs-attr\">options:</span>\n    <span class=\"hljs-attr\">publish:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">\"443:443\"</span>\n    <span class=\"hljs-attr\">volume:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">\"/letsencrypt/acme.json:/letsencrypt/acme.json\"</span>\n    <span class=\"hljs-attr\">network:</span> <span class=\"hljs-string\">\"private\"</span>\n  <span class=\"hljs-attr\">args:</span>\n    <span class=\"hljs-attr\">entryPoints.web.address:</span> <span class=\"hljs-string\">\":80\"</span>\n    <span class=\"hljs-attr\">entryPoints.websecure.address:</span> <span class=\"hljs-string\">\":443\"</span>\n    <span class=\"hljs-attr\">entryPoints.web.http.redirections.entryPoint.to:</span> <span class=\"hljs-string\">websecure</span>\n    <span class=\"hljs-attr\">entryPoints.web.http.redirections.entryPoint.scheme:</span> <span class=\"hljs-string\">https</span>\n    <span class=\"hljs-attr\">entryPoints.web.http.redirections.entrypoint.permanent:</span> <span class=\"hljs-literal\">true</span>\n    <span class=\"hljs-attr\">certificatesResolvers.letsencrypt.acme.email:</span> <span class=\"hljs-string\">\"info@mynewapp.com\"</span>\n    <span class=\"hljs-attr\">certificatesResolvers.letsencrypt.acme.storage:</span> <span class=\"hljs-string\">\"/letsencrypt/acme.json\"</span>\n    <span class=\"hljs-attr\">certificatesResolvers.letsencrypt.acme.httpchallenge:</span> <span class=\"hljs-literal\">true</span>\n    <span class=\"hljs-attr\">certificatesResolvers.letsencrypt.acme.httpchallenge.entrypoint:</span> <span class=\"hljs-string\">web</span>\n</code></pre>\n<p>Traefik을 설정하여 HTTPS 요청을 처리하고 Let's Encrypt를 사용하여 SSL 인증서를 자동으로 관리하도록 구성합니다.</p>\n<p>아래에 완전한 deploy.yml 파일을 찾을 수 있어요:</p>\n<pre><code class=\"hljs language-yaml\"><span class=\"hljs-comment\"># 애플리케이션의 이름. 컨테이너를 고유하게 설정하는 데 사용됩니다.</span>\n<span class=\"hljs-attr\">service:</span> <span class=\"hljs-string\">mynewapp</span>\n\n<span class=\"hljs-comment\"># 컨테이너 이미지의 이름입니다.</span>\n<span class=\"hljs-attr\">image:</span> <span class=\"hljs-string\">talha/mynewapp</span>\n\n<span class=\"hljs-comment\"># 이 서버로 배포합니다.</span>\n<span class=\"hljs-attr\">servers:</span>\n  <span class=\"hljs-attr\">web:</span>\n    <span class=\"hljs-attr\">hosts:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-number\">123.123</span><span class=\"hljs-number\">.45</span><span class=\"hljs-number\">.678</span>\n    <span class=\"hljs-attr\">labels:</span>\n      <span class=\"hljs-attr\">traefik.http.routers.mynewapp.rule:</span> <span class=\"hljs-string\">Host(`mynewapp.com`)</span>\n      <span class=\"hljs-attr\">traefik.http.routers.mynewapp.entrypoints:</span> <span class=\"hljs-string\">websecure</span>\n      <span class=\"hljs-attr\">traefik.http.routers.mynewapp_secure.rule:</span> <span class=\"hljs-string\">Host(`mynewapp.com`)</span>\n      <span class=\"hljs-attr\">traefik.http.routers.mynewapp_secure.tls:</span> <span class=\"hljs-literal\">true</span>\n      <span class=\"hljs-attr\">traefik.http.routers.mynewapp_secure.tls.certresolver:</span> <span class=\"hljs-string\">letsencrypt</span>\n    <span class=\"hljs-attr\">options:</span>\n      <span class=\"hljs-attr\">network:</span> <span class=\"hljs-string\">\"private\"</span>\n\n<span class=\"hljs-comment\"># 이미지 호스트의 자격 증명입니다.</span>\n<span class=\"hljs-attr\">registry:</span>\n  <span class=\"hljs-attr\">username:</span>\n    <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">KAMAL_REGISTRY_USERNAME</span>\n  <span class=\"hljs-attr\">password:</span>\n    <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">KAMAL_REGISTRY_PASSWORD</span>\n\n<span class=\"hljs-comment\"># 컨테이너로 ENV 변수를 주입합니다(비밀은 .env에서 가져옵니다).</span>\n<span class=\"hljs-comment\"># 변경 후 `kamal env push`를 실행하는 것을 잊지 마세요!</span>\n<span class=\"hljs-attr\">env:</span>\n  <span class=\"hljs-attr\">clear:</span>\n    <span class=\"hljs-attr\">RAILS_ENV:</span> <span class=\"hljs-string\">production</span>\n    <span class=\"hljs-attr\">RACK_ENV:</span> <span class=\"hljs-string\">production</span>\n    <span class=\"hljs-attr\">RAILS_LOG_TO_STDOUT:</span> <span class=\"hljs-literal\">true</span>\n    <span class=\"hljs-attr\">RAILS_SERVE_STATIC_FILES:</span> <span class=\"hljs-literal\">true</span>\n  <span class=\"hljs-attr\">secret:</span>\n    <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">RAILS_MASTER_KEY</span>\n    <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">SMTP_PASSWORD</span>\n    <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">SMTP_SERVER</span>\n    <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">SMTP_LOGIN</span>\n    <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">DB_HOST</span>\n    <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">POSTGRES_USER</span>\n    <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">POSTGRES_PASSWORD</span>\n\n<span class=\"hljs-comment\"># root가 아닌 다른 ssh 사용자를 사용합니다.</span>\n<span class=\"hljs-attr\">ssh:</span>\n  <span class=\"hljs-attr\">user:</span> <span class=\"hljs-string\">deploy</span>\n\n<span class=\"hljs-comment\"># 빌더 설정을 구성합니다.</span>\n<span class=\"hljs-attr\">builder:</span>\n  <span class=\"hljs-attr\">remote:</span>\n    <span class=\"hljs-attr\">arch:</span> <span class=\"hljs-string\">amd64</span>\n\n<span class=\"hljs-comment\"># 보조 서비스를 사용합니다(비밀은 .env에서 가져옵니다).</span>\n<span class=\"hljs-attr\">accessories:</span>\n  <span class=\"hljs-attr\">db:</span>\n    <span class=\"hljs-attr\">image:</span> <span class=\"hljs-string\">postgres:16.0</span>\n    <span class=\"hljs-attr\">host:</span> <span class=\"hljs-number\">123.123</span><span class=\"hljs-number\">.45</span><span class=\"hljs-number\">.678</span>\n    <span class=\"hljs-attr\">env:</span>\n      <span class=\"hljs-attr\">clear:</span>\n        <span class=\"hljs-attr\">POSTGRES_USER:</span> <span class=\"hljs-string\">\"mynewapp\"</span>\n        <span class=\"hljs-attr\">POSTGRES_DB:</span> <span class=\"hljs-string\">\"mynewapp_production\"</span>\n      <span class=\"hljs-attr\">secret:</span>\n        <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">POSTGRES_PASSWORD</span>\n        <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">POSTGRES_USER</span>\n    <span class=\"hljs-attr\">files:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">config/init.sql:/docker-entrypoint-initdb.d/setup.sql</span>\n    <span class=\"hljs-attr\">directories:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">data:/var/lib/postgresql/data</span>\n    <span class=\"hljs-attr\">options:</span>\n      <span class=\"hljs-attr\">network:</span> <span class=\"hljs-string\">\"private\"</span>\n\n<span class=\"hljs-attr\">traefik:</span>\n  <span class=\"hljs-attr\">options:</span>\n    <span class=\"hljs-attr\">publish:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">\"443:443\"</span>\n    <span class=\"hljs-attr\">volume:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">\"/letsencrypt/acme.json:/letsencrypt/acme.json\"</span>\n    <span class=\"hljs-attr\">network:</span> <span class=\"hljs-string\">\"private\"</span>\n  <span class=\"hljs-attr\">args:</span>\n    <span class=\"hljs-attr\">entryPoints.web.address:</span> <span class=\"hljs-string\">\":80\"</span>\n    <span class=\"hljs-attr\">entryPoints.websecure.address:</span> <span class=\"hljs-string\">\":443\"</span>\n    <span class=\"hljs-attr\">entryPoints.web.http.redirections.entryPoint.to:</span> <span class=\"hljs-string\">websecure</span>\n    <span class=\"hljs-attr\">entryPoints.web.http.redirections.entryPoint.scheme:</span> <span class=\"hljs-string\">https</span>\n    <span class=\"hljs-attr\">entryPoints.web.http.redirections.entrypoint.permanent:</span> <span class=\"hljs-literal\">true</span>\n    <span class=\"hljs-attr\">certificatesResolvers.letsencrypt.acme.email:</span> <span class=\"hljs-string\">\"info@mynewapp.com\"</span>\n    <span class=\"hljs-attr\">certificatesResolvers.letsencrypt.acme.storage:</span> <span class=\"hljs-string\">\"/letsencrypt/acme.json\"</span>\n    <span class=\"hljs-attr\">certificatesResolvers.letsencrypt.acme.httpchallenge:</span> <span class=\"hljs-literal\">true</span>\n    <span class=\"hljs-attr\">certificatesResolvers.letsencrypt.acme.httpchallenge.entrypoint:</span> <span class=\"hljs-string\">web</span>\n\n<span class=\"hljs-attr\">asset_path:</span> <span class=\"hljs-string\">/rails/public/assets</span>\n</code></pre>\n<p></p>\n<p>위의 예시를 참고하여 실제 애플리케이션 이름, 도메인 및 서버 IP 주소로 mynewapp, mynewapp.com 및 123.123.45.678와 같은 자리 표시자를 교체해주세요.</p>\n<h1>단계 3: 배포 사용자 생성</h1>\n<p>VPS에 SSH로 접속하고 새로운 사용자 deploy를 만들어보세요. 아래 명령어를 실행하세요.</p>\n<p>로컬 머신에서 터미널을 열고 SSH를 사용하여 VPS에 연결합니다. 실제 VPS의 IP 주소로 your_server_ip를 교체해주세요.</p>\n<p></p>\n<pre><code class=\"hljs language-sh\">ssh root@your_server_ip\n</code></pre>\n<p>다음 명령어를 실행하여 새로운 사용자 deploy를 생성하세요:</p>\n<pre><code class=\"hljs language-sh\">adduser deploy\n</code></pre>\n<p>새 사용자에 대한 암호를 설정하고 추가 정보를 입력하라는 프롬프트가 표시됩니다. 선택 사항을 건너뛰려면 Enter 키를 누르세요.</p>\n<p></p>\n<p>(선택사항) 배포 사용자에게 sudo 권한을 부여하고 싶다면 다음 명령을 실행하여 sudo 그룹에 추가할 수 있습니다:</p>\n<pre><code class=\"hljs language-js\">usermod -aG sudo deploy\n</code></pre>\n<h1>단계 4: VPS에 Docker 설치하기:</h1>\n<p>Docker를 설치하기 전에 패키지 인덱스를 업데이트하는 것이 좋은 실천법입니다:</p>\n<p></p>\n<pre><code class=\"hljs language-js\">apt update\n</code></pre>\n<p>HTTPS를 통해 저장소를 사용할 수 있도록 패키지를 설치하고 Docker에 필요한 몇 가지 패키지를 설치하세요:</p>\n<pre><code class=\"hljs language-js\">apt install -y apt-transport-https ca-certificates curl software-properties-common\n</code></pre>\n<p>시스템에 Docker의 공식 GPG 키를 추가하세요.</p>\n<p></p>\n<pre><code class=\"hljs language-js\">curl -fsSL <span class=\"hljs-attr\">https</span>:<span class=\"hljs-comment\">//download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span>\n</code></pre>\n<p>Docker 리포지토리를 APT 원본에 추가하세요:</p>\n<pre><code class=\"hljs language-js\">add-apt-repository <span class=\"hljs-string\">\"deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\"</span>\n</code></pre>\n<p>한번 더 패키지 인덱스를 업데이트하세요:</p>\n<p></p>\n<pre><code class=\"hljs language-bash\">apt update\n</code></pre>\n<p>최신 버전의 Docker CE (Community Edition)와 containerd를 함께 설치하려면:</p>\n<pre><code class=\"hljs language-bash\">apt install -y docker-ce docker-ce-cli containerd.io\n</code></pre>\n<p>Docker 서비스를 시작하고 부팅 시 자동으로 시작되도록 설정하세요.</p>\n<p></p>\n<pre><code class=\"hljs language-js\">systemctl start docker\nsystemctl enable docker\n</code></pre>\n<p>다음 명령어를 실행하여 Docker가 올바르게 설치되었는지 확인하세요. 이 명령은 Docker 버전 정보를 출력해야 합니다:</p>\n<pre><code class=\"hljs language-js\">docker --version\n</code></pre>\n<p>마지막으로, 프라이빗 Docker 네트워크를 생성하세요.</p>\n<p></p>\n<pre><code class=\"hljs language-js\">도커 네트워크 생성 -d bridge private\n</code></pre>\n<h1>단계 5: LetsEncrypt 설치하기:</h1>\n<p>로컬 머신에서 터미널을 열고 SSH를 사용하여 VPS에 연결합니다. 실제 VPS의 IP 주소로 your_server_ip를 대체하십시오.</p>\n<pre><code class=\"hljs language-js\">ssh root@your_server_ip\n</code></pre>\n<p></p>\n<p>다음 명령을 사용하여 Let's Encrypt 디렉토리를 설정하세요:</p>\n<pre><code class=\"hljs language-js\">mkdir -p /letsencrypt &#x26;&#x26; touch /letsencrypt/acme.<span class=\"hljs-property\">json</span> &#x26;&#x26; chmod <span class=\"hljs-number\">600</span> /letsencrypt/acme.<span class=\"hljs-property\">json</span>\n</code></pre>\n<h1>단계 6: 애플리케이션 배포</h1>\n<p>처음부터 모든 단계를 거쳐 config/deploy.yml 파일을 작성했고 배포할 준비가 되었다면, 다음을 실행하세요:</p>\n<p></p>\n<pre><code class=\"hljs language-js\">kamal setup\n</code></pre>\n<h1>Step 7: 일일 업무 흐름</h1>\n<p>카말의 명령어를 사용하여 매일 배포 작업을 수행하세요:</p>\n<p>앱의 새 버전을 배포하려면:</p>\n<p></p>\n<pre><code class=\"hljs language-js\">kamal deploy\n</code></pre>\n<p>환경 변수를 업데이트하려면:</p>\n<pre><code class=\"hljs language-js\">kamal env push\n</code></pre>\n<p>새 컨테이너에서 bash 세션을 시작하려면:</p>\n<p></p>\n<pre><code class=\"hljs language-js\">kamal app exec -i bash\n</code></pre>\n<p>새로운 컨테이너에서 Rails 콘솔을 시작하려면:</p>\n<pre><code class=\"hljs language-js\">kamal app exec -i ‘bin/rails <span class=\"hljs-variable language_\">console</span>’\n</code></pre>\n<p>로그 보기:</p>\n<p></p>\n<pre><code class=\"hljs language-js\">kamal 앱 로그\n</code></pre>\n<h1>결론</h1>\n<p>축하합니다! 카말(Kamal)을 사용하여 디지턈오션(DigitalOcean) VPS에서 PostgreSQL과 함께 루비 온 레일즈(Ruby on Rails) 애플리케이션을 성공적으로 배포했습니다. 이제 구성된 도메인 이름으로 애플리케이션에 액세스할 수 있습니다. 🚀</p>\n<p>이 포스트가 마음에 들었다면 좋아요를 눌러 주시고 미디엄(Medium)과 트위터(Twitter)에서도 저를 팔로우해주세요(<a href=\"https://twitter.com/royalty568\" rel=\"nofollow\" target=\"_blank\">https://twitter.com/royalty568</a>).</p>\n<p></p>\n<p>시간을 절약하고 앱을 즉시 구축하고자 한다면 Rails 보일러플레이트를 찾고 계신 것 같네요. <a href=\"https://talha345.gumroad.com/l/rails7-bootstrap5-devise-fa-psql-boldo-boilerplate\" rel=\"nofollow\" target=\"_blank\">https://talha345.gumroad.com/l/rails7-bootstrap5-devise-fa-psql-boldo-boilerplate</a> 를 확인해보세요!</p>\n</body>\n</html>\n"},"__N_SSG":true}