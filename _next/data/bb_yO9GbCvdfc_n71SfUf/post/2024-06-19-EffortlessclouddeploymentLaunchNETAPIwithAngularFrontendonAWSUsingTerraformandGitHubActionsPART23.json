{"pageProps":{"post":{"title":"편리한 클라우드 배포 Terraform과 GitHub Actions를 활용하여 AWS에서 NET API와 Angular 프론트엔드를 런칭하기 PART 23","description":"","date":"2024-06-19 12:54","slug":"2024-06-19-EffortlessclouddeploymentLaunchNETAPIwithAngularFrontendonAWSUsingTerraformandGitHubActionsPART23","content":"\n<img src=\"/assets/img/2024-06-19-EffortlessclouddeploymentLaunchNETAPIwithAngularFrontendonAWSUsingTerraformandGitHubActionsPART23_0.png\" />\n\n# 소개\n\n이 기사에서는 이전 기사에서 시작한 설정을 계속할 것입니다: IaC 기본: Terraform 및 GitHub Actions를 사용한 RDS 배포. 목표는 AWS에서 완전히 기능하는 .NET 백엔드(API)를 구성하는 것입니다. 응용 프로그램은 공개적으로 액세스 가능하며 RDS 데이터베이스에 연결될 것입니다. 민감한 정보 검색에 Secrets Manager를 활용할 것입니다.\n\nPART 1에서 이미 다음을 설정했습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- Terraform을 지원하기 위한 AWS 백엔드 (S3에 상태 파일, DynamoDB에 상태 잠금 기능 포함).\n- Terraform을 이용해 인프라를 배포하기 위한 GitHub Actions.\n- DBeaver를 사용하여 테스트된 공개적으로 접근 가능한 RDS 데이터베이스.\n\nPART 2에서는 다음을 다룰 예정입니다::\n\n- RDS, ECR 및 Secrets Manager를 포함한 인프라 저장소 설정.\n- Secrets Manager에 비밀을 전송하는 인프라 파이프라인 생성 (데이터베이스 호스트, 사용자, 비밀번호).\n- API용 Dockerfile 정의.\n- 어플리케이션을 위해 Docker 컨테이너를 실행하는 ECS 서비스 구성.\n- API를 노출시키기 위해 로드 밸런서 구현.\n\n이 글을 마치면 GitHub Actions와 Terraform을 이용해 CI/CD 파이프라인을 통해 AWS에서 .NET 백엔드를 완벽히 설정할 수 있게 될 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 인프라 구성하기\n\n나는 논리적 구성 요소를 별도의 저장소로 분리하기로 결정했습니다. 이 접근법은 구조를 읽기 쉽게 만들 뿐만 아니라 인프라스트럭처의 코드 (IaC) 정의를 단순화합니다.\n\n![이미지](/assets/img/2024-06-19-EffortlessclouddeploymentLaunchNETAPIwithAngularFrontendonAWSUsingTerraformandGitHubActionsPART23_1.png)\n\n인프라 프로젝트는 자주 변경되지 않는 리소스를 만드는 것에 책임을 지기 때문에 분리됩니다. 이 프로젝트에서는 RDS, ECR 및 Secrets Manager의 생성을 구성했습니다. 파이프라인은 RDS 확장, ECR 또는 Secrets Manager 이름 변경과 같은 경우에 가끔 실행해야 할 수 있지만, 이러한 인스턴스는 드물 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 설정을 사용하여 개별 환경(개발, 스테이징 및 프로덕션과 같은)을 관리하는 데 상당한 잠재력이 있습니다. 그러나 이 기사는 이 측면을 다루지 않도록 중점을 두고 있습니다.\n\n# App.Infra 프로젝트\n\n이전에 언급했듯이, 인프라 프로젝트는 RDS, ECR 저장소 및 Secrets Manager(보강에 RDS 암호 저장)를 설정합니다. 이 분리는 인프라 관점에서 상대적으로 정적인 이러한 구성 요소 때문에 의도적입니다. 또한, ECR 저장소가 준비되어 있어야 하는 것이 중요합니다. Docker 이미지의 대상 역할을 합니다. 따라서 빌드 순서도 관련이 있습니다.\n\n이제 테라폼 파일로 직접 들어가 봅시다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n공급업체 \"aws\" {\n  지역 = var.aws_region\n}\n\n리소스 \"aws_vpc\" \"main\" {\n  cidr_block = \"10.0.0.0/16\"\n\n  enable_dns_support   = true\n  enable_dns_hostnames = true\n\n  tags = {\n    Name = \"main\"\n  }\n}\n\n리소스 \"aws_subnet\" \"main_subnet_1\" {\n  vpc_id            = aws_vpc.main.id\n  cidr_block        = \"10.0.1.0/24\"\n  availability_zone = \"eu-north-1a\"\n\n  tags = {\n    Name = \"main-subnet-1\"\n  }\n}\n\n리소스 \"aws_subnet\" \"main_subnet_2\" {\n  vpc_id            = aws_vpc.main.id\n  cidr_block        = \"10.0.2.0/24\"\n  availability_zone = \"eu-north-1b\"\n\n  tags = {\n    Name = \"main-subnet-2\"\n  }\n}\n\n리소스 \"aws_security_group\" \"rds_sg\" {\n  name        = \"rds_security_group\"\n  description = \"어디서나 접근 허용하는 RDS용 보안 그룹\"\n  vpc_id      = aws_vpc.main.id\n\n  ingress {\n    from_port   = 5432\n    to_port     = 5432\n    protocol    = \"tcp\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n\n  egress {\n    from_port   = 0\n    to_port     = 0\n    protocol    = \"-1\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n\n  tags = {\n    Name = \"rds_security_group\"\n  }\n}\n\n리소스 \"aws_db_subnet_group\" \"default\" {\n  name       = \"main-subnet-group\"\n  subnet_ids = [aws_subnet.main_subnet_1.id, aws_subnet.main_subnet_2.id]\n\n  tags = {\n    Name = \"main-subnet-group\"\n  }\n}\n\n리소스 \"aws_internet_gateway\" \"main\" {\n  vpc_id = aws_vpc.main.id\n}\n\n리소스 \"aws_route_table\" \"public\" {\n  vpc_id = aws_vpc.main.id\n\n  route {\n    cidr_block = \"0.0.0.0/0\"\n    gateway_id = aws_internet_gateway.main.id\n  }\n}\n\n리소스 \"aws_route_table_association\" \"subnet_association_1\" {\n  subnet_id      = aws_subnet.main_subnet_1.id\n  route_table_id = aws_route_table.public.id\n}\n\n리소스 \"aws_route_table_association\" \"subnet_association_2\" {\n  subnet_id      = aws_subnet.main_subnet_2.id\n  route_table_id = aws_route_table.public.id\n}\n\n리소스 \"aws_db_instance\" \"default\" {\n  allocated_storage    = 20\n  engine               = \"postgres\"\n  engine_version       = \"16.2\"\n  instance_class       = var.db_instance_class\n  db_name              = var.db_name\n  username             = var.db_username\n  password             = var.db_password\n  parameter_group_name = \"default.postgres16\"\n  skip_final_snapshot  = true\n  publicly_accessible  = true\n\n  vpc_security_group_ids = [aws_security_group.rds_sg.id]\n  db_subnet_group_name   = aws_db_subnet_group.default.name\n}\n\n리소스 \"aws_ecr_repository\" \"app_repository\" {\n  name = \"app-repo\"\n  image_scanning_configuration {\n    scan_on_push = true\n  }\n  image_tag_mutability = \"MUTABLE\"\n}\n\n리소스 \"aws_secretsmanager_secret\" \"rds_secret\" {\n  name        = \"app-secrets-manager\"\n  description = \"APP 비밀\"\n}\n\n리소스 \"aws_secretsmanager_secret_version\" \"rds_secret_version\" {\n  secret_id     = aws_secretsmanager_secret.rds_secret.id\n  secret_string = jsonencode({\n    DB_HOST     = aws_db_instance.default.endpoint\n    DB_USER     = var.db_username\n    DB_PASSWORD = var.db_password\n    DB_NAME     = var.db_name\n  })\n}\n```\n\n위 글에서는 VPC 및 RDS 구성요소가 PART 1에서 다뤄졌습니다. 이제 ECR 및 Secrets Manager에 집중해 보겠습니다.\n\n## ECR 리포지토리\n\n```js\n리소스 \"aws_ecr_repository\" \"app_repository\" {\n  name = \"app-repo\"\n  image_scanning_configuration {\n    scan_on_push = true\n  }\n  image_tag_mutability = \"MUTABLE\"\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 블록은 Docker 이미지를 저장하기 위한 Elastic Container Registry (ECR) 리포지토리를 생성하며, 이미지 푸시 시 이미지 스캔이 활성화되어 있습니다.\n\n## Secrets Manager\n\n```js\nresource \"aws_secretsmanager_secret\" \"rds_secret\" {\n  name        = \"app-secrets-manager\"\n  description = \"APP secrets\"\n}\n\nresource \"aws_secretsmanager_secret_version\" \"rds_secret_version\" {\n  secret_id     = aws_secretsmanager_secret.rds_secret.id\n  secret_string = jsonencode({\n    DB_HOST     = aws_db_instance.default.endpoint\n    DB_USER     = var.db_username\n    DB_PASSWORD = var.db_password\n    db_name     = var.db_name\n  })\n}\n```\n\n이 블록은 Secrets Manager를 생성하고 그 안에 RDS 데이터베이스 자격 증명을 저장합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n액션 정의는 기사의 이전 부분과 비교해 변경되지 않았습니다. 우리는 표준 경로를 실행합니다: AWS에 로그인 - `Init` - `Validate` - `Plan` - `Apply Terraform`. Github 액션을 활성화하고 실행합니다. 결과적으로 로컬 DB 클라이언트에서 RDS와 통신할 수 있어야 하며, AWS 콘솔에서 연결 문자열을 구축하기 위한 미리 입력된 시크릿이 포함된 Secrets Manager와 ECR(컨테이너 레지스트리)를 찾아야 합니다.\n\n## C#을 사용하여 Secrets Manager에 액세스\n\n어플리케이션의 보안을 보장하는 것은 인터넷에 노출되는 서비스를 개발하는 중요한 측면입니다. 코드나 환경 변수또는 Docker 컨테이너에 비밀번호를 저장하면 민감한 정보가 노출될 수 있습니다. 더 안전한 접근 방식은 민감한 데이터를 관리하기 위해 AWS Secrets Manager를 사용하는 것입니다.\n\n아래에서는 AWS Secrets Manager에 저장된 시크릿을 사용하여 PostgreSQL 연결 문자열을 구성하는 방법을 보여드리겠습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n먼저 AWSSDK.SecretsManager nuget을 다운로드해야 합니다. 작업이 완료되면 SecretsManagerService를 빌드해 봅시다:\n\n```js\nusing Amazon;\nusing Amazon.SecretsManager;\nusing Amazon.SecretsManager.Model;\n\nnamespace AppMonitor.AWS\n{\n    public class SecretsManagerService\n    {\n        private readonly IAmazonSecretsManager _secretsManager;\n\n        public SecretsManagerService(IAmazonSecretsManager secretsManager)\n        {\n            _secretsManager = secretsManager;\n        }\n\n        public async Task<string> GetSecretValueAsync(string secretName)\n        {\n            var request = new GetSecretValueRequest\n            {\n                SecretId = secretName\n            };\n\n            var response = await _secretsManager.GetSecretValueAsync(request);\n            return response.SecretString;\n        }\n    }\n}\n```\n\n다음으로, DBConnectionStringProvider 클래스에서 SecretsManagerService를 사용합니다:\n\n```js\nusing Newtonsoft.Json.Linq;\nusing System.Configuration;\n\nnamespace AppMonitor.AWS\n{\n    public class AwsDatabaseConnectionStringProvider\n    {\n        private readonly SecretsManagerService _secretsManagerService;\n\n        public AwsDatabaseConnectionStringProvider(SecretsManagerService secretsManagerService)\n        {\n            _secretsManagerService = secretsManagerService;\n        }\n\n        public async Task<string> GetConnectionStringAsync()\n        {\n            var secretValue = await _secretsManagerService.GetSecretValueAsync(\"app-secrets-manager\");\n            var secretJson = JObject.Parse(secretValue); //newtonsoft.json\n\n            var host = secretJson[\"DB_HOST\"].ToString();\n            var user = secretJson[\"DB_USER\"].ToString();\n            var password = secretJson[\"DB_PASSWORD\"].ToString();\n            var dbName = secretJson[\"DB_NAME\"].ToString();\n\n            return $\"Host={host};Port=5432;Database={dbName};User ID={user};Password={password};\";\n        }\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n마지막으로, 우리 스타트업에서 서비스를 설정해야 합니다 (이 스니펫은 AWSSDK.Extensions.NETCore.Setup 너겟을 필요로 합니다):\n\n```js\n  context.Services.AddAWSService<IAmazonSecretsManager>();\n  context.Services.AddSingleton<SecretsManagerService>();\n  context.Services.AddSingleton<AwsDatabaseConnectionStringProvider>();\n```\n\n# .NET 앱을 위한 Docker 이미지 빌드\n\n도커는 가벼운 이식 가능한 컨테이너를 생성함으로써 응용 프로그램을 패키지화하고 배포하는 효율적인 방법을 제공합니다. 이러한 컨테이너는 쉽게 ECR로 푸시하고 AWS의 ECS 서비스로 배포할 수 있습니다. 아래는 우리 .NET 애플리케이션을 위한 Dockerfile입니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nFROM mcr.microsoft.com/dotnet/aspnet:8.0 AS base\nWORKDIR /app\nEXPOSE 44360\n\nFROM mcr.microsoft.com/dotnet/sdk:8.0 AS build\nWORKDIR /src\n\nCOPY [\"AppMonitor/\", \"AppMonitor/\"]\nRUN dotnet restore \"TheApp/TheApp.csproj\"\n\nCOPY . .\n\nWORKDIR \"/src/TheApp\"\nRUN dotnet build \"TheApp.csproj\" -c Release -o /app/build\n\nFROM build AS publish\nRUN dotnet publish \"TheApp.csproj\" -c Release -o /app/publish\n\nFROM base AS final\nWORKDIR /app\nCOPY --from=publish /app/publish .\n\nENV ASPNETCORE_URLS=http://*:44360\nENTRYPOINT [\"dotnet\", \"TheApp.dll\"]\n```\n\n다음 부분에서는 ECS를 구성하여 이 Docker 컨테이너를 실행하고 API를 노출하는 로드 밸런서를 구현할 것입니다.\n\n## ECS 및 로드 밸런서 소개\n\nAmazon Elastic Container Service (ECS)는 Docker를 사용하여 컨테이너화된 응용 프로그램을 배포, 관리 및 확장하기 쉽게 만들어주는 완전관리형 컨테이너 오케스트레이션 서비스입니다. ECS를 활용하면 기본 인프라를 관리할 필요없이 응용 프로그램을 구축하는 데 집중할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n로드 밸런서(LB)는 여러 대상(예: ECS 작업) 사이로 들어오는 응용 프로그램 트래픽을 분산하는 서비스입니다. 로드 밸런서는 트래픽을 건강한 대상으로 라우팅하고 부하를 균형있게 분배하여 리소스 활용을 최적화하여 고가용성과 신뢰성을 보장합니다.\n\n이 설정에서는 우리의 ECS 작업이 AWS Secrets Manager에 액세스하는 권한을 갖게되어 민감한 데이터의 안전한 관리를 보장합니다. 작업은 애플리케이션별 트래픽을 허용하도록 구성된 보안 그룹이 구성된 VPC에 배포될 것입니다. 애플리케이션 로드 밸런서(ALB)는 ECS 작업 간의 트래픽을 분산하여 부드럽고 신뢰할 수 있는 응용 프로그램 성능을 보장합니다.\n\n## ECS를 위한 Terraform 구성\n\n코드 예시\n\n# main.tf\n\nprovider \"aws\" {\nregion = \"eu-north-1\"\n}\n\ndata \"aws_vpc\" \"main\" {\nfilter {\nname = \"tag:Name\"\nvalues = [\"main\"]\n}\n}\n\n...\n\nresource \"aws_iam_role_policy\" \"ecs_task_secrets_policy\" {\nname = \"ecs-task-secrets-policy\"\nrole = aws_iam_role.ecs_task_execution_role.id\n\npolicy = jsonencode({\nVersion = \"2012-10-17\",\nStatement = [\n{\nEffect = \"Allow\",\nAction = [\n\"secretsmanager:GetSecretValue\"\n],\nResource = \"\\*\"\n}\n]\n})\n}\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n# load_balancer.tf\n\nresource \"aws_lb\" \"app_lb\" {\n  name               = \"app-lb\"\n  internal           = false\n  load_balancer_type = \"application\"\n  security_groups    = [aws_security_group.ecs_sg.id]\n  subnets            = [data.aws_subnet.main_subnet_1.id, data.aws_subnet.main_subnet_2.id]\n\n  enable_deletion_protection = false\n}\n\nresource \"aws_lb_listener\" \"http_listener\" {\n  load_balancer_arn = aws_lb.app_lb.arn\n  port              = \"80\"\n  protocol          = \"HTTP\"\n\n  default_action {\n    type             = \"forward\"\n    target_group_arn = aws_lb_target_group.app_tg.arn\n  }\n\n  lifecycle {\n    create_before_destroy = true\n  }\n}\n\nresource \"aws_lb_target_group\" \"app_tg\" {\n  name     = \"app-tg\"\n  port     = 80\n  protocol = \"HTTP\"\n  vpc_id   = data.aws_vpc.main.id\n  target_type = \"ip\"\n\n  health_check {\n    interval            = 30\n    protocol            = \"HTTP\"\n    timeout             = 5\n    healthy_threshold   = 5\n    unhealthy_threshold = 2\n  }\n\n  lifecycle {\n    create_before_destroy = true\n  }\n}\n\nresource \"aws_ecs_cluster\" \"main\" {\n  name = \"main-cluster\"\n}\n\nresource \"aws_ecs_service\" \"app_service\" {\n  name            = \"app-service\"\n  cluster         = aws_ecs_cluster.main.id\n  task_definition = aws_ecs_task_definition.app_task.arn\n  desired_count   = 1\n  launch_type     = \"FARGATE\"\n\n  network_configuration {\n    subnets         = [data.aws_subnet.main_subnet_1.id, data.aws_subnet.main_subnet_2.id]\n    security_groups = [aws_security_group.ecs_sg.id]\n    assign_public_ip = true\n  }\n\n  load_balancer {\n    target_group_arn = aws_lb_target_group.app_tg.arn\n    container_name   = \"app-container\"\n    container_port   = 44360\n  }\n\n  depends_on = [\n    aws_lb_listener.http_listener\n  ]\n}\n```\n\n## Provider and VPC Data Sources:\n\n- The aws provider is set to the eu-north-1 region.\n- Data sources are defined to fetch details of the existing VPC and subnets based on tags.\n\n## Security Group for ECS:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 보안 그룹 ecs_sg가 생성되어 HTTP, HTTPS 및 애플리케이션 트래픽 (포트 44360)을 허용하도록 설정되어 있습니다.\n\n## IAM 역할 및 인스턴스 프로필:\n\n- ECS 작업 실행 및 인스턴스 역할에 필요한 정책이 포함된 IAM 역할이 생성되었습니다.\n- 인스턴스 프로필이 생성되고 인스턴스 역할에 연결되었습니다.\n\n## 시작 구성 밑 오토 스케일링 그룹:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- ECS 인스턴스를 위한 ECS 최적화 AMI로 시작 구성이 생성됩니다.\n- Auto Scaling 그룹이 ECS 인스턴스의 원하는 용량을 유지하도록 구성되어 있습니다.\n\n## ECR Repository:\n\n- ECR 저장소인 app-repo가 Docker 이미지를 가져오도록 참조됩니다.\n\n## ECS 작업 정의:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 작업 정의는 Docker 컨테이너 구성을 지정하는 것으로, 이미지, 포트 매핑 및 환경 변수를 포함합니다.\n- 작업에는 AWS Secrets Manager에 액세스할 수 있도록 IAM 정책이 있습니다.\n\n## 로드 밸런서 구성:\n\n- 어플리케이션 로드 밸런서(ALB)가 설정되어 있으며, 리스너 및 타겟 그룹을 사용하여 ECS 작업으로의 트래픽 관리가 이루어집니다.\n- 건강 점검이 구성되어 ALB가 건강한 인스턴스에만 트래픽을 라우팅하도록 합니다.\n\n## ECS 클러스터 및 서비스:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- ECS 클러스터 main-cluster가 생성되었습니다.\n- ECS 서비스 app-service는 Fargate 런치 유형을 사용하도록 구성되어 있어, 자동 스케일링 기능을 갖춘 서버리스 운영이 보장됩니다.\n\n# Github 액션 정의 및 테스트\n\nGithub 액션의 워크플로우 정의는 간단하고 명확합니다. 도커 이미지 빌드 및 AWS 내 Elastic Container Registry로 푸시하는 것을 강조할 만한 유일한 사항입니다. YAML 정의로 들어가 봅시다:\n\n```js\nname: AWS로 배포\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - name: 코드 가져오기\n        uses: actions/checkout@v2\n\n      - name: .NET Core 설정\n        uses: actions/setup-dotnet@v1\n        with:\n          dotnet-version: '8.0.x'\n\n      - name: 종속성 복원\n        run: dotnet restore src\n\n      - name: 빌드\n        run: dotnet build src --configuration Release --no-restore\n\n      - name: 게시\n        run: dotnet publish src --configuration Release --output ./output\n\n      - name: 도커 빌드 설정\n        uses: docker/setup-buildx-action@v1\n\n      - name: Terraform을 위한 AWS 자격 증명 구성\n        uses: aws-actions/configure-aws-credentials@v1\n        with:\n          aws-access-key-id: ${secrets.AWS_ACCESS_KEY_ID}\n          aws-secret-access-key: ${secrets.AWS_SECRET_ACCESS_KEY}\n          aws-region: ${secrets.AWS_REGION}\n\n      - name: Amazon ECR에 로그인\n        id: login-ecr\n        uses: aws-actions/amazon-ecr-login@v1\n\n      - name: 도커 이미지 빌드 및 푸시\n        run: |\n          REPOSITORY_URI=$(aws ecr describe-repositories --repository-names app-repo --query \"repositories[0].repositoryUri\" --output text --region eu-north-1)\n          docker build -t $REPOSITORY_URI:latest -f src/Dockerfile src\n          docker push $REPOSITORY_URI:latest\n        env:\n          AWS_REGION: eu-north-1\n\n      - name: Terraform 설정\n        uses: hashicorp/setup-terraform@v1\n        with:\n          terraform_version: 1.8.5\n\n      - name: Terraform 초기화\n        run: terraform init -input=false\n        working-directory: infra\n\n      - name: Terraform 계획 수립\n        run: terraform plan -input=false\n        working-directory: infra\n        env:\n          TF_VAR_db_password: ${secrets.DB_PASSWORD}\n          TF_VAR_aws_region: ${secrets.AWS_REGION}\n\n      - name: Terraform 적용\n        id: apply\n        run: terraform apply -auto-approve -input=false\n        working-directory: infra\n        env:\n          TF_VAR_db_password: ${secrets.DB_PASSWORD}\n          TF_VAR_aws_region: ${secrets.AWS_REGION}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n상기 GitHub 액션 설정은 .NET 앱을 AWS로 쉽게 배포할 수 있도록 해주는 내용입니다. 이 설정에는 .NET Core 설정부터 의존성 복원, 앱 빌드 및 게시, 그리고 컨테이너화를 위한 Docker 통합까지 모두 다루는 여러 단계가 포함되어 있습니다. 또한 AWS 자격 증명을 처리하고 Docker 이미지를 Amazon ECR에 빌드 및 푸시하며, Terraform을 사용하여 인프라 구축도 수행합니다. 기본적으로 전체 프로세스를 자동화하여 배포가 완전히 간편해집니다.\n\n빌드가 성공적으로 완료되면 API의 URL을 얻기 위해 AWS 콘솔을 방문해보세요.\n\n![이미지](/assets/img/2024-06-19-EffortlessclouddeploymentLaunchNETAPIwithAngularFrontendonAWSUsingTerraformandGitHubActionsPART23_2.png)\n\nDNS 이름을 가져와 브라우저에서 해당 URL을 열어보세요. 모든 것이 잘 되었다면 API 백엔드가 응답해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 요약\n\n조금 길었지만, Terraform을 사용하여 AWS에 컨테이너화된 .NET API를 배포하는 모든 중요한 단계를 다루었습니다. 이 가이드가 새 프로젝트를 처음부터 시작하거나 인프라 설정의 복잡성을 탐색하는 데 도움이 되기를 바랍니다. 화이팅!\n","ogImage":{"url":"/assets/img/2024-06-19-EffortlessclouddeploymentLaunchNETAPIwithAngularFrontendonAWSUsingTerraformandGitHubActionsPART23_0.png"},"coverImage":"/assets/img/2024-06-19-EffortlessclouddeploymentLaunchNETAPIwithAngularFrontendonAWSUsingTerraformandGitHubActionsPART23_0.png","tag":["Tech"],"readingTime":21},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<h1>소개</h1>\n<p>이 기사에서는 이전 기사에서 시작한 설정을 계속할 것입니다: IaC 기본: Terraform 및 GitHub Actions를 사용한 RDS 배포. 목표는 AWS에서 완전히 기능하는 .NET 백엔드(API)를 구성하는 것입니다. 응용 프로그램은 공개적으로 액세스 가능하며 RDS 데이터베이스에 연결될 것입니다. 민감한 정보 검색에 Secrets Manager를 활용할 것입니다.</p>\n<p>PART 1에서 이미 다음을 설정했습니다:</p>\n<p></p>\n<ul>\n<li>Terraform을 지원하기 위한 AWS 백엔드 (S3에 상태 파일, DynamoDB에 상태 잠금 기능 포함).</li>\n<li>Terraform을 이용해 인프라를 배포하기 위한 GitHub Actions.</li>\n<li>DBeaver를 사용하여 테스트된 공개적으로 접근 가능한 RDS 데이터베이스.</li>\n</ul>\n<p>PART 2에서는 다음을 다룰 예정입니다::</p>\n<ul>\n<li>RDS, ECR 및 Secrets Manager를 포함한 인프라 저장소 설정.</li>\n<li>Secrets Manager에 비밀을 전송하는 인프라 파이프라인 생성 (데이터베이스 호스트, 사용자, 비밀번호).</li>\n<li>API용 Dockerfile 정의.</li>\n<li>어플리케이션을 위해 Docker 컨테이너를 실행하는 ECS 서비스 구성.</li>\n<li>API를 노출시키기 위해 로드 밸런서 구현.</li>\n</ul>\n<p>이 글을 마치면 GitHub Actions와 Terraform을 이용해 CI/CD 파이프라인을 통해 AWS에서 .NET 백엔드를 완벽히 설정할 수 있게 될 것입니다.</p>\n<p></p>\n<h1>인프라 구성하기</h1>\n<p>나는 논리적 구성 요소를 별도의 저장소로 분리하기로 결정했습니다. 이 접근법은 구조를 읽기 쉽게 만들 뿐만 아니라 인프라스트럭처의 코드 (IaC) 정의를 단순화합니다.</p>\n<p><img src=\"/assets/img/2024-06-19-EffortlessclouddeploymentLaunchNETAPIwithAngularFrontendonAWSUsingTerraformandGitHubActionsPART23_1.png\" alt=\"이미지\"></p>\n<p>인프라 프로젝트는 자주 변경되지 않는 리소스를 만드는 것에 책임을 지기 때문에 분리됩니다. 이 프로젝트에서는 RDS, ECR 및 Secrets Manager의 생성을 구성했습니다. 파이프라인은 RDS 확장, ECR 또는 Secrets Manager 이름 변경과 같은 경우에 가끔 실행해야 할 수 있지만, 이러한 인스턴스는 드물 것입니다.</p>\n<p></p>\n<p>이 설정을 사용하여 개별 환경(개발, 스테이징 및 프로덕션과 같은)을 관리하는 데 상당한 잠재력이 있습니다. 그러나 이 기사는 이 측면을 다루지 않도록 중점을 두고 있습니다.</p>\n<h1>App.Infra 프로젝트</h1>\n<p>이전에 언급했듯이, 인프라 프로젝트는 RDS, ECR 저장소 및 Secrets Manager(보강에 RDS 암호 저장)를 설정합니다. 이 분리는 인프라 관점에서 상대적으로 정적인 이러한 구성 요소 때문에 의도적입니다. 또한, ECR 저장소가 준비되어 있어야 하는 것이 중요합니다. Docker 이미지의 대상 역할을 합니다. 따라서 빌드 순서도 관련이 있습니다.</p>\n<p>이제 테라폼 파일로 직접 들어가 봅시다:</p>\n<p></p>\n<pre><code class=\"hljs language-js\">공급업체 <span class=\"hljs-string\">\"aws\"</span> {\n  지역 = <span class=\"hljs-keyword\">var</span>.<span class=\"hljs-property\">aws_region</span>\n}\n\n리소스 <span class=\"hljs-string\">\"aws_vpc\"</span> <span class=\"hljs-string\">\"main\"</span> {\n  cidr_block = <span class=\"hljs-string\">\"10.0.0.0/16\"</span>\n\n  enable_dns_support   = <span class=\"hljs-literal\">true</span>\n  enable_dns_hostnames = <span class=\"hljs-literal\">true</span>\n\n  tags = {\n    <span class=\"hljs-title class_\">Name</span> = <span class=\"hljs-string\">\"main\"</span>\n  }\n}\n\n리소스 <span class=\"hljs-string\">\"aws_subnet\"</span> <span class=\"hljs-string\">\"main_subnet_1\"</span> {\n  vpc_id            = aws_vpc.<span class=\"hljs-property\">main</span>.<span class=\"hljs-property\">id</span>\n  cidr_block        = <span class=\"hljs-string\">\"10.0.1.0/24\"</span>\n  availability_zone = <span class=\"hljs-string\">\"eu-north-1a\"</span>\n\n  tags = {\n    <span class=\"hljs-title class_\">Name</span> = <span class=\"hljs-string\">\"main-subnet-1\"</span>\n  }\n}\n\n리소스 <span class=\"hljs-string\">\"aws_subnet\"</span> <span class=\"hljs-string\">\"main_subnet_2\"</span> {\n  vpc_id            = aws_vpc.<span class=\"hljs-property\">main</span>.<span class=\"hljs-property\">id</span>\n  cidr_block        = <span class=\"hljs-string\">\"10.0.2.0/24\"</span>\n  availability_zone = <span class=\"hljs-string\">\"eu-north-1b\"</span>\n\n  tags = {\n    <span class=\"hljs-title class_\">Name</span> = <span class=\"hljs-string\">\"main-subnet-2\"</span>\n  }\n}\n\n리소스 <span class=\"hljs-string\">\"aws_security_group\"</span> <span class=\"hljs-string\">\"rds_sg\"</span> {\n  name        = <span class=\"hljs-string\">\"rds_security_group\"</span>\n  description = <span class=\"hljs-string\">\"어디서나 접근 허용하는 RDS용 보안 그룹\"</span>\n  vpc_id      = aws_vpc.<span class=\"hljs-property\">main</span>.<span class=\"hljs-property\">id</span>\n\n  ingress {\n    from_port   = <span class=\"hljs-number\">5432</span>\n    to_port     = <span class=\"hljs-number\">5432</span>\n    protocol    = <span class=\"hljs-string\">\"tcp\"</span>\n    cidr_blocks = [<span class=\"hljs-string\">\"0.0.0.0/0\"</span>]\n  }\n\n  egress {\n    from_port   = <span class=\"hljs-number\">0</span>\n    to_port     = <span class=\"hljs-number\">0</span>\n    protocol    = <span class=\"hljs-string\">\"-1\"</span>\n    cidr_blocks = [<span class=\"hljs-string\">\"0.0.0.0/0\"</span>]\n  }\n\n  tags = {\n    <span class=\"hljs-title class_\">Name</span> = <span class=\"hljs-string\">\"rds_security_group\"</span>\n  }\n}\n\n리소스 <span class=\"hljs-string\">\"aws_db_subnet_group\"</span> <span class=\"hljs-string\">\"default\"</span> {\n  name       = <span class=\"hljs-string\">\"main-subnet-group\"</span>\n  subnet_ids = [aws_subnet.<span class=\"hljs-property\">main_subnet_1</span>.<span class=\"hljs-property\">id</span>, aws_subnet.<span class=\"hljs-property\">main_subnet_2</span>.<span class=\"hljs-property\">id</span>]\n\n  tags = {\n    <span class=\"hljs-title class_\">Name</span> = <span class=\"hljs-string\">\"main-subnet-group\"</span>\n  }\n}\n\n리소스 <span class=\"hljs-string\">\"aws_internet_gateway\"</span> <span class=\"hljs-string\">\"main\"</span> {\n  vpc_id = aws_vpc.<span class=\"hljs-property\">main</span>.<span class=\"hljs-property\">id</span>\n}\n\n리소스 <span class=\"hljs-string\">\"aws_route_table\"</span> <span class=\"hljs-string\">\"public\"</span> {\n  vpc_id = aws_vpc.<span class=\"hljs-property\">main</span>.<span class=\"hljs-property\">id</span>\n\n  route {\n    cidr_block = <span class=\"hljs-string\">\"0.0.0.0/0\"</span>\n    gateway_id = aws_internet_gateway.<span class=\"hljs-property\">main</span>.<span class=\"hljs-property\">id</span>\n  }\n}\n\n리소스 <span class=\"hljs-string\">\"aws_route_table_association\"</span> <span class=\"hljs-string\">\"subnet_association_1\"</span> {\n  subnet_id      = aws_subnet.<span class=\"hljs-property\">main_subnet_1</span>.<span class=\"hljs-property\">id</span>\n  route_table_id = aws_route_table.<span class=\"hljs-property\">public</span>.<span class=\"hljs-property\">id</span>\n}\n\n리소스 <span class=\"hljs-string\">\"aws_route_table_association\"</span> <span class=\"hljs-string\">\"subnet_association_2\"</span> {\n  subnet_id      = aws_subnet.<span class=\"hljs-property\">main_subnet_2</span>.<span class=\"hljs-property\">id</span>\n  route_table_id = aws_route_table.<span class=\"hljs-property\">public</span>.<span class=\"hljs-property\">id</span>\n}\n\n리소스 <span class=\"hljs-string\">\"aws_db_instance\"</span> <span class=\"hljs-string\">\"default\"</span> {\n  allocated_storage    = <span class=\"hljs-number\">20</span>\n  engine               = <span class=\"hljs-string\">\"postgres\"</span>\n  engine_version       = <span class=\"hljs-string\">\"16.2\"</span>\n  instance_class       = <span class=\"hljs-keyword\">var</span>.<span class=\"hljs-property\">db_instance_class</span>\n  db_name              = <span class=\"hljs-keyword\">var</span>.<span class=\"hljs-property\">db_name</span>\n  username             = <span class=\"hljs-keyword\">var</span>.<span class=\"hljs-property\">db_username</span>\n  password             = <span class=\"hljs-keyword\">var</span>.<span class=\"hljs-property\">db_password</span>\n  parameter_group_name = <span class=\"hljs-string\">\"default.postgres16\"</span>\n  skip_final_snapshot  = <span class=\"hljs-literal\">true</span>\n  publicly_accessible  = <span class=\"hljs-literal\">true</span>\n\n  vpc_security_group_ids = [aws_security_group.<span class=\"hljs-property\">rds_sg</span>.<span class=\"hljs-property\">id</span>]\n  db_subnet_group_name   = aws_db_subnet_group.<span class=\"hljs-property\">default</span>.<span class=\"hljs-property\">name</span>\n}\n\n리소스 <span class=\"hljs-string\">\"aws_ecr_repository\"</span> <span class=\"hljs-string\">\"app_repository\"</span> {\n  name = <span class=\"hljs-string\">\"app-repo\"</span>\n  image_scanning_configuration {\n    scan_on_push = <span class=\"hljs-literal\">true</span>\n  }\n  image_tag_mutability = <span class=\"hljs-string\">\"MUTABLE\"</span>\n}\n\n리소스 <span class=\"hljs-string\">\"aws_secretsmanager_secret\"</span> <span class=\"hljs-string\">\"rds_secret\"</span> {\n  name        = <span class=\"hljs-string\">\"app-secrets-manager\"</span>\n  description = <span class=\"hljs-string\">\"APP 비밀\"</span>\n}\n\n리소스 <span class=\"hljs-string\">\"aws_secretsmanager_secret_version\"</span> <span class=\"hljs-string\">\"rds_secret_version\"</span> {\n  secret_id     = aws_secretsmanager_secret.<span class=\"hljs-property\">rds_secret</span>.<span class=\"hljs-property\">id</span>\n  secret_string = <span class=\"hljs-title function_\">jsonencode</span>({\n    <span class=\"hljs-variable constant_\">DB_HOST</span>     = aws_db_instance.<span class=\"hljs-property\">default</span>.<span class=\"hljs-property\">endpoint</span>\n    <span class=\"hljs-variable constant_\">DB_USER</span>     = <span class=\"hljs-keyword\">var</span>.<span class=\"hljs-property\">db_username</span>\n    <span class=\"hljs-variable constant_\">DB_PASSWORD</span> = <span class=\"hljs-keyword\">var</span>.<span class=\"hljs-property\">db_password</span>\n    <span class=\"hljs-variable constant_\">DB_NAME</span>     = <span class=\"hljs-keyword\">var</span>.<span class=\"hljs-property\">db_name</span>\n  })\n}\n</code></pre>\n<p>위 글에서는 VPC 및 RDS 구성요소가 PART 1에서 다뤄졌습니다. 이제 ECR 및 Secrets Manager에 집중해 보겠습니다.</p>\n<h2>ECR 리포지토리</h2>\n<pre><code class=\"hljs language-js\">리소스 <span class=\"hljs-string\">\"aws_ecr_repository\"</span> <span class=\"hljs-string\">\"app_repository\"</span> {\n  name = <span class=\"hljs-string\">\"app-repo\"</span>\n  image_scanning_configuration {\n    scan_on_push = <span class=\"hljs-literal\">true</span>\n  }\n  image_tag_mutability = <span class=\"hljs-string\">\"MUTABLE\"</span>\n}\n</code></pre>\n<p></p>\n<p>이 블록은 Docker 이미지를 저장하기 위한 Elastic Container Registry (ECR) 리포지토리를 생성하며, 이미지 푸시 시 이미지 스캔이 활성화되어 있습니다.</p>\n<h2>Secrets Manager</h2>\n<pre><code class=\"hljs language-js\">resource <span class=\"hljs-string\">\"aws_secretsmanager_secret\"</span> <span class=\"hljs-string\">\"rds_secret\"</span> {\n  name        = <span class=\"hljs-string\">\"app-secrets-manager\"</span>\n  description = <span class=\"hljs-string\">\"APP secrets\"</span>\n}\n\nresource <span class=\"hljs-string\">\"aws_secretsmanager_secret_version\"</span> <span class=\"hljs-string\">\"rds_secret_version\"</span> {\n  secret_id     = aws_secretsmanager_secret.<span class=\"hljs-property\">rds_secret</span>.<span class=\"hljs-property\">id</span>\n  secret_string = <span class=\"hljs-title function_\">jsonencode</span>({\n    <span class=\"hljs-variable constant_\">DB_HOST</span>     = aws_db_instance.<span class=\"hljs-property\">default</span>.<span class=\"hljs-property\">endpoint</span>\n    <span class=\"hljs-variable constant_\">DB_USER</span>     = <span class=\"hljs-keyword\">var</span>.<span class=\"hljs-property\">db_username</span>\n    <span class=\"hljs-variable constant_\">DB_PASSWORD</span> = <span class=\"hljs-keyword\">var</span>.<span class=\"hljs-property\">db_password</span>\n    db_name     = <span class=\"hljs-keyword\">var</span>.<span class=\"hljs-property\">db_name</span>\n  })\n}\n</code></pre>\n<p>이 블록은 Secrets Manager를 생성하고 그 안에 RDS 데이터베이스 자격 증명을 저장합니다.</p>\n<p></p>\n<p>액션 정의는 기사의 이전 부분과 비교해 변경되지 않았습니다. 우리는 표준 경로를 실행합니다: AWS에 로그인 - <code>Init</code> - <code>Validate</code> - <code>Plan</code> - <code>Apply Terraform</code>. Github 액션을 활성화하고 실행합니다. 결과적으로 로컬 DB 클라이언트에서 RDS와 통신할 수 있어야 하며, AWS 콘솔에서 연결 문자열을 구축하기 위한 미리 입력된 시크릿이 포함된 Secrets Manager와 ECR(컨테이너 레지스트리)를 찾아야 합니다.</p>\n<h2>C#을 사용하여 Secrets Manager에 액세스</h2>\n<p>어플리케이션의 보안을 보장하는 것은 인터넷에 노출되는 서비스를 개발하는 중요한 측면입니다. 코드나 환경 변수또는 Docker 컨테이너에 비밀번호를 저장하면 민감한 정보가 노출될 수 있습니다. 더 안전한 접근 방식은 민감한 데이터를 관리하기 위해 AWS Secrets Manager를 사용하는 것입니다.</p>\n<p>아래에서는 AWS Secrets Manager에 저장된 시크릿을 사용하여 PostgreSQL 연결 문자열을 구성하는 방법을 보여드리겠습니다.</p>\n<p></p>\n<p>먼저 AWSSDK.SecretsManager nuget을 다운로드해야 합니다. 작업이 완료되면 SecretsManagerService를 빌드해 봅시다:</p>\n<pre><code class=\"hljs language-js\">using <span class=\"hljs-title class_\">Amazon</span>;\nusing <span class=\"hljs-title class_\">Amazon</span>.<span class=\"hljs-property\">SecretsManager</span>;\nusing <span class=\"hljs-title class_\">Amazon</span>.<span class=\"hljs-property\">SecretsManager</span>.<span class=\"hljs-property\">Model</span>;\n\nnamespace <span class=\"hljs-title class_\">AppMonitor</span>.<span class=\"hljs-property\">AWS</span>\n{\n    public <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SecretsManagerService</span>\n    {\n        private readonly <span class=\"hljs-title class_\">IAmazonSecretsManager</span> _secretsManager;\n\n        public <span class=\"hljs-title class_\">SecretsManagerService</span>(<span class=\"hljs-title class_\">IAmazonSecretsManager</span> secretsManager)\n        {\n            _secretsManager = secretsManager;\n        }\n\n        public <span class=\"hljs-keyword\">async</span> <span class=\"hljs-title class_\">Task</span>&#x3C;string> <span class=\"hljs-title class_\">GetSecretValueAsync</span>(string secretName)\n        {\n            <span class=\"hljs-keyword\">var</span> request = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">GetSecretValueRequest</span>\n            {\n                <span class=\"hljs-title class_\">SecretId</span> = secretName\n            };\n\n            <span class=\"hljs-keyword\">var</span> response = <span class=\"hljs-keyword\">await</span> _secretsManager.<span class=\"hljs-title class_\">GetSecretValueAsync</span>(request);\n            <span class=\"hljs-keyword\">return</span> response.<span class=\"hljs-property\">SecretString</span>;\n        }\n    }\n}\n</code></pre>\n<p>다음으로, DBConnectionStringProvider 클래스에서 SecretsManagerService를 사용합니다:</p>\n<pre><code class=\"hljs language-js\">using <span class=\"hljs-title class_\">Newtonsoft</span>.<span class=\"hljs-property\">Json</span>.<span class=\"hljs-property\">Linq</span>;\nusing <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">Configuration</span>;\n\nnamespace <span class=\"hljs-title class_\">AppMonitor</span>.<span class=\"hljs-property\">AWS</span>\n{\n    public <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AwsDatabaseConnectionStringProvider</span>\n    {\n        private readonly <span class=\"hljs-title class_\">SecretsManagerService</span> _secretsManagerService;\n\n        public <span class=\"hljs-title class_\">AwsDatabaseConnectionStringProvider</span>(<span class=\"hljs-title class_\">SecretsManagerService</span> secretsManagerService)\n        {\n            _secretsManagerService = secretsManagerService;\n        }\n\n        public <span class=\"hljs-keyword\">async</span> <span class=\"hljs-title class_\">Task</span>&#x3C;string> <span class=\"hljs-title class_\">GetConnectionStringAsync</span>()\n        {\n            <span class=\"hljs-keyword\">var</span> secretValue = <span class=\"hljs-keyword\">await</span> _secretsManagerService.<span class=\"hljs-title class_\">GetSecretValueAsync</span>(<span class=\"hljs-string\">\"app-secrets-manager\"</span>);\n            <span class=\"hljs-keyword\">var</span> secretJson = <span class=\"hljs-title class_\">JObject</span>.<span class=\"hljs-title class_\">Parse</span>(secretValue); <span class=\"hljs-comment\">//newtonsoft.json</span>\n\n            <span class=\"hljs-keyword\">var</span> host = secretJson[<span class=\"hljs-string\">\"DB_HOST\"</span>].<span class=\"hljs-title class_\">ToString</span>();\n            <span class=\"hljs-keyword\">var</span> user = secretJson[<span class=\"hljs-string\">\"DB_USER\"</span>].<span class=\"hljs-title class_\">ToString</span>();\n            <span class=\"hljs-keyword\">var</span> password = secretJson[<span class=\"hljs-string\">\"DB_PASSWORD\"</span>].<span class=\"hljs-title class_\">ToString</span>();\n            <span class=\"hljs-keyword\">var</span> dbName = secretJson[<span class=\"hljs-string\">\"DB_NAME\"</span>].<span class=\"hljs-title class_\">ToString</span>();\n\n            <span class=\"hljs-keyword\">return</span> $<span class=\"hljs-string\">\"Host={host};Port=5432;Database={dbName};User ID={user};Password={password};\"</span>;\n        }\n    }\n}\n</code></pre>\n<p></p>\n<p>마지막으로, 우리 스타트업에서 서비스를 설정해야 합니다 (이 스니펫은 AWSSDK.Extensions.NETCore.Setup 너겟을 필요로 합니다):</p>\n<pre><code class=\"hljs language-js\">  context.<span class=\"hljs-property\">Services</span>.<span class=\"hljs-property\">AddAWSService</span>&#x3C;<span class=\"hljs-title class_\">IAmazonSecretsManager</span>>();\n  context.<span class=\"hljs-property\">Services</span>.<span class=\"hljs-property\">AddSingleton</span>&#x3C;<span class=\"hljs-title class_\">SecretsManagerService</span>>();\n  context.<span class=\"hljs-property\">Services</span>.<span class=\"hljs-property\">AddSingleton</span>&#x3C;<span class=\"hljs-title class_\">AwsDatabaseConnectionStringProvider</span>>();\n</code></pre>\n<h1>.NET 앱을 위한 Docker 이미지 빌드</h1>\n<p>도커는 가벼운 이식 가능한 컨테이너를 생성함으로써 응용 프로그램을 패키지화하고 배포하는 효율적인 방법을 제공합니다. 이러한 컨테이너는 쉽게 ECR로 푸시하고 AWS의 ECS 서비스로 배포할 수 있습니다. 아래는 우리 .NET 애플리케이션을 위한 Dockerfile입니다:</p>\n<p></p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable constant_\">FROM</span> mcr.<span class=\"hljs-property\">microsoft</span>.<span class=\"hljs-property\">com</span>/dotnet/<span class=\"hljs-attr\">aspnet</span>:<span class=\"hljs-number\">8.0</span> <span class=\"hljs-variable constant_\">AS</span> base\n<span class=\"hljs-variable constant_\">WORKDIR</span> /app\n<span class=\"hljs-variable constant_\">EXPOSE</span> <span class=\"hljs-number\">44360</span>\n\n<span class=\"hljs-variable constant_\">FROM</span> mcr.<span class=\"hljs-property\">microsoft</span>.<span class=\"hljs-property\">com</span>/dotnet/<span class=\"hljs-attr\">sdk</span>:<span class=\"hljs-number\">8.0</span> <span class=\"hljs-variable constant_\">AS</span> build\n<span class=\"hljs-variable constant_\">WORKDIR</span> /src\n\n<span class=\"hljs-variable constant_\">COPY</span> [<span class=\"hljs-string\">\"AppMonitor/\"</span>, <span class=\"hljs-string\">\"AppMonitor/\"</span>]\n<span class=\"hljs-variable constant_\">RUN</span> dotnet restore <span class=\"hljs-string\">\"TheApp/TheApp.csproj\"</span>\n\n<span class=\"hljs-variable constant_\">COPY</span> . .\n\n<span class=\"hljs-variable constant_\">WORKDIR</span> <span class=\"hljs-string\">\"/src/TheApp\"</span>\n<span class=\"hljs-variable constant_\">RUN</span> dotnet build <span class=\"hljs-string\">\"TheApp.csproj\"</span> -c <span class=\"hljs-title class_\">Release</span> -o /app/build\n\n<span class=\"hljs-variable constant_\">FROM</span> build <span class=\"hljs-variable constant_\">AS</span> publish\n<span class=\"hljs-variable constant_\">RUN</span> dotnet publish <span class=\"hljs-string\">\"TheApp.csproj\"</span> -c <span class=\"hljs-title class_\">Release</span> -o /app/publish\n\n<span class=\"hljs-variable constant_\">FROM</span> base <span class=\"hljs-variable constant_\">AS</span> final\n<span class=\"hljs-variable constant_\">WORKDIR</span> /app\n<span class=\"hljs-variable constant_\">COPY</span> --<span class=\"hljs-keyword\">from</span>=publish /app/publish .\n\n<span class=\"hljs-variable constant_\">ENV</span> <span class=\"hljs-variable constant_\">ASPNETCORE_URLS</span>=<span class=\"hljs-attr\">http</span>:<span class=\"hljs-comment\">//*:44360</span>\n<span class=\"hljs-variable constant_\">ENTRYPOINT</span> [<span class=\"hljs-string\">\"dotnet\"</span>, <span class=\"hljs-string\">\"TheApp.dll\"</span>]\n</code></pre>\n<p>다음 부분에서는 ECS를 구성하여 이 Docker 컨테이너를 실행하고 API를 노출하는 로드 밸런서를 구현할 것입니다.</p>\n<h2>ECS 및 로드 밸런서 소개</h2>\n<p>Amazon Elastic Container Service (ECS)는 Docker를 사용하여 컨테이너화된 응용 프로그램을 배포, 관리 및 확장하기 쉽게 만들어주는 완전관리형 컨테이너 오케스트레이션 서비스입니다. ECS를 활용하면 기본 인프라를 관리할 필요없이 응용 프로그램을 구축하는 데 집중할 수 있습니다.</p>\n<p></p>\n<p>로드 밸런서(LB)는 여러 대상(예: ECS 작업) 사이로 들어오는 응용 프로그램 트래픽을 분산하는 서비스입니다. 로드 밸런서는 트래픽을 건강한 대상으로 라우팅하고 부하를 균형있게 분배하여 리소스 활용을 최적화하여 고가용성과 신뢰성을 보장합니다.</p>\n<p>이 설정에서는 우리의 ECS 작업이 AWS Secrets Manager에 액세스하는 권한을 갖게되어 민감한 데이터의 안전한 관리를 보장합니다. 작업은 애플리케이션별 트래픽을 허용하도록 구성된 보안 그룹이 구성된 VPC에 배포될 것입니다. 애플리케이션 로드 밸런서(ALB)는 ECS 작업 간의 트래픽을 분산하여 부드럽고 신뢰할 수 있는 응용 프로그램 성능을 보장합니다.</p>\n<h2>ECS를 위한 Terraform 구성</h2>\n<p>코드 예시</p>\n<h1>main.tf</h1>\n<p>provider \"aws\" {\nregion = \"eu-north-1\"\n}</p>\n<p>data \"aws_vpc\" \"main\" {\nfilter {\nname = \"tag:Name\"\nvalues = [\"main\"]\n}\n}</p>\n<p>...</p>\n<p>resource \"aws_iam_role_policy\" \"ecs_task_secrets_policy\" {\nname = \"ecs-task-secrets-policy\"\nrole = aws_iam_role.ecs_task_execution_role.id</p>\n<p>policy = jsonencode({\nVersion = \"2012-10-17\",\nStatement = [\n{\nEffect = \"Allow\",\nAction = [\n\"secretsmanager:GetSecretValue\"\n],\nResource = \"*\"\n}\n]\n})\n}</p>\n<p></p>\n<pre><code class=\"hljs language-js\"># load_balancer.<span class=\"hljs-property\">tf</span>\n\nresource <span class=\"hljs-string\">\"aws_lb\"</span> <span class=\"hljs-string\">\"app_lb\"</span> {\n  name               = <span class=\"hljs-string\">\"app-lb\"</span>\n  internal           = <span class=\"hljs-literal\">false</span>\n  load_balancer_type = <span class=\"hljs-string\">\"application\"</span>\n  security_groups    = [aws_security_group.<span class=\"hljs-property\">ecs_sg</span>.<span class=\"hljs-property\">id</span>]\n  subnets            = [data.<span class=\"hljs-property\">aws_subnet</span>.<span class=\"hljs-property\">main_subnet_1</span>.<span class=\"hljs-property\">id</span>, data.<span class=\"hljs-property\">aws_subnet</span>.<span class=\"hljs-property\">main_subnet_2</span>.<span class=\"hljs-property\">id</span>]\n\n  enable_deletion_protection = <span class=\"hljs-literal\">false</span>\n}\n\nresource <span class=\"hljs-string\">\"aws_lb_listener\"</span> <span class=\"hljs-string\">\"http_listener\"</span> {\n  load_balancer_arn = aws_lb.<span class=\"hljs-property\">app_lb</span>.<span class=\"hljs-property\">arn</span>\n  port              = <span class=\"hljs-string\">\"80\"</span>\n  protocol          = <span class=\"hljs-string\">\"HTTP\"</span>\n\n  default_action {\n    type             = <span class=\"hljs-string\">\"forward\"</span>\n    target_group_arn = aws_lb_target_group.<span class=\"hljs-property\">app_tg</span>.<span class=\"hljs-property\">arn</span>\n  }\n\n  lifecycle {\n    create_before_destroy = <span class=\"hljs-literal\">true</span>\n  }\n}\n\nresource <span class=\"hljs-string\">\"aws_lb_target_group\"</span> <span class=\"hljs-string\">\"app_tg\"</span> {\n  name     = <span class=\"hljs-string\">\"app-tg\"</span>\n  port     = <span class=\"hljs-number\">80</span>\n  protocol = <span class=\"hljs-string\">\"HTTP\"</span>\n  vpc_id   = data.<span class=\"hljs-property\">aws_vpc</span>.<span class=\"hljs-property\">main</span>.<span class=\"hljs-property\">id</span>\n  target_type = <span class=\"hljs-string\">\"ip\"</span>\n\n  health_check {\n    interval            = <span class=\"hljs-number\">30</span>\n    protocol            = <span class=\"hljs-string\">\"HTTP\"</span>\n    timeout             = <span class=\"hljs-number\">5</span>\n    healthy_threshold   = <span class=\"hljs-number\">5</span>\n    unhealthy_threshold = <span class=\"hljs-number\">2</span>\n  }\n\n  lifecycle {\n    create_before_destroy = <span class=\"hljs-literal\">true</span>\n  }\n}\n\nresource <span class=\"hljs-string\">\"aws_ecs_cluster\"</span> <span class=\"hljs-string\">\"main\"</span> {\n  name = <span class=\"hljs-string\">\"main-cluster\"</span>\n}\n\nresource <span class=\"hljs-string\">\"aws_ecs_service\"</span> <span class=\"hljs-string\">\"app_service\"</span> {\n  name            = <span class=\"hljs-string\">\"app-service\"</span>\n  cluster         = aws_ecs_cluster.<span class=\"hljs-property\">main</span>.<span class=\"hljs-property\">id</span>\n  task_definition = aws_ecs_task_definition.<span class=\"hljs-property\">app_task</span>.<span class=\"hljs-property\">arn</span>\n  desired_count   = <span class=\"hljs-number\">1</span>\n  launch_type     = <span class=\"hljs-string\">\"FARGATE\"</span>\n\n  network_configuration {\n    subnets         = [data.<span class=\"hljs-property\">aws_subnet</span>.<span class=\"hljs-property\">main_subnet_1</span>.<span class=\"hljs-property\">id</span>, data.<span class=\"hljs-property\">aws_subnet</span>.<span class=\"hljs-property\">main_subnet_2</span>.<span class=\"hljs-property\">id</span>]\n    security_groups = [aws_security_group.<span class=\"hljs-property\">ecs_sg</span>.<span class=\"hljs-property\">id</span>]\n    assign_public_ip = <span class=\"hljs-literal\">true</span>\n  }\n\n  load_balancer {\n    target_group_arn = aws_lb_target_group.<span class=\"hljs-property\">app_tg</span>.<span class=\"hljs-property\">arn</span>\n    container_name   = <span class=\"hljs-string\">\"app-container\"</span>\n    container_port   = <span class=\"hljs-number\">44360</span>\n  }\n\n  depends_on = [\n    aws_lb_listener.<span class=\"hljs-property\">http_listener</span>\n  ]\n}\n</code></pre>\n<h2>Provider and VPC Data Sources:</h2>\n<ul>\n<li>The aws provider is set to the eu-north-1 region.</li>\n<li>Data sources are defined to fetch details of the existing VPC and subnets based on tags.</li>\n</ul>\n<h2>Security Group for ECS:</h2>\n<p></p>\n<ul>\n<li>보안 그룹 ecs_sg가 생성되어 HTTP, HTTPS 및 애플리케이션 트래픽 (포트 44360)을 허용하도록 설정되어 있습니다.</li>\n</ul>\n<h2>IAM 역할 및 인스턴스 프로필:</h2>\n<ul>\n<li>ECS 작업 실행 및 인스턴스 역할에 필요한 정책이 포함된 IAM 역할이 생성되었습니다.</li>\n<li>인스턴스 프로필이 생성되고 인스턴스 역할에 연결되었습니다.</li>\n</ul>\n<h2>시작 구성 밑 오토 스케일링 그룹:</h2>\n<p></p>\n<ul>\n<li>ECS 인스턴스를 위한 ECS 최적화 AMI로 시작 구성이 생성됩니다.</li>\n<li>Auto Scaling 그룹이 ECS 인스턴스의 원하는 용량을 유지하도록 구성되어 있습니다.</li>\n</ul>\n<h2>ECR Repository:</h2>\n<ul>\n<li>ECR 저장소인 app-repo가 Docker 이미지를 가져오도록 참조됩니다.</li>\n</ul>\n<h2>ECS 작업 정의:</h2>\n<p></p>\n<ul>\n<li>작업 정의는 Docker 컨테이너 구성을 지정하는 것으로, 이미지, 포트 매핑 및 환경 변수를 포함합니다.</li>\n<li>작업에는 AWS Secrets Manager에 액세스할 수 있도록 IAM 정책이 있습니다.</li>\n</ul>\n<h2>로드 밸런서 구성:</h2>\n<ul>\n<li>어플리케이션 로드 밸런서(ALB)가 설정되어 있으며, 리스너 및 타겟 그룹을 사용하여 ECS 작업으로의 트래픽 관리가 이루어집니다.</li>\n<li>건강 점검이 구성되어 ALB가 건강한 인스턴스에만 트래픽을 라우팅하도록 합니다.</li>\n</ul>\n<h2>ECS 클러스터 및 서비스:</h2>\n<p></p>\n<ul>\n<li>ECS 클러스터 main-cluster가 생성되었습니다.</li>\n<li>ECS 서비스 app-service는 Fargate 런치 유형을 사용하도록 구성되어 있어, 자동 스케일링 기능을 갖춘 서버리스 운영이 보장됩니다.</li>\n</ul>\n<h1>Github 액션 정의 및 테스트</h1>\n<p>Github 액션의 워크플로우 정의는 간단하고 명확합니다. 도커 이미지 빌드 및 AWS 내 Elastic Container Registry로 푸시하는 것을 강조할 만한 유일한 사항입니다. YAML 정의로 들어가 봅시다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-attr\">name</span>: <span class=\"hljs-variable constant_\">AWS</span>로 배포\n\n<span class=\"hljs-attr\">on</span>:\n  <span class=\"hljs-attr\">push</span>:\n    <span class=\"hljs-attr\">branches</span>:\n      - main\n\n<span class=\"hljs-attr\">jobs</span>:\n  <span class=\"hljs-attr\">build</span>:\n    runs-<span class=\"hljs-attr\">on</span>: ubuntu-latest\n    <span class=\"hljs-attr\">steps</span>:\n      - <span class=\"hljs-attr\">name</span>: 코드 가져오기\n        <span class=\"hljs-attr\">uses</span>: actions/checkout@v2\n\n      - <span class=\"hljs-attr\">name</span>: .<span class=\"hljs-property\">NET</span> <span class=\"hljs-title class_\">Core</span> 설정\n        <span class=\"hljs-attr\">uses</span>: actions/setup-dotnet@v1\n        <span class=\"hljs-attr\">with</span>:\n          dotnet-<span class=\"hljs-attr\">version</span>: <span class=\"hljs-string\">'8.0.x'</span>\n\n      - <span class=\"hljs-attr\">name</span>: 종속성 복원\n        <span class=\"hljs-attr\">run</span>: dotnet restore src\n\n      - <span class=\"hljs-attr\">name</span>: 빌드\n        <span class=\"hljs-attr\">run</span>: dotnet build src --configuration <span class=\"hljs-title class_\">Release</span> --no-restore\n\n      - <span class=\"hljs-attr\">name</span>: 게시\n        <span class=\"hljs-attr\">run</span>: dotnet publish src --configuration <span class=\"hljs-title class_\">Release</span> --output ./output\n\n      - <span class=\"hljs-attr\">name</span>: 도커 빌드 설정\n        <span class=\"hljs-attr\">uses</span>: docker/setup-buildx-action@v1\n\n      - <span class=\"hljs-attr\">name</span>: <span class=\"hljs-title class_\">Terraform</span>을 위한 <span class=\"hljs-variable constant_\">AWS</span> 자격 증명 구성\n        <span class=\"hljs-attr\">uses</span>: aws-actions/configure-aws-credentials@v1\n        <span class=\"hljs-attr\">with</span>:\n          aws-access-key-<span class=\"hljs-attr\">id</span>: ${secrets.<span class=\"hljs-property\">AWS_ACCESS_KEY_ID</span>}\n          aws-secret-access-<span class=\"hljs-attr\">key</span>: ${secrets.<span class=\"hljs-property\">AWS_SECRET_ACCESS_KEY</span>}\n          aws-<span class=\"hljs-attr\">region</span>: ${secrets.<span class=\"hljs-property\">AWS_REGION</span>}\n\n      - <span class=\"hljs-attr\">name</span>: <span class=\"hljs-title class_\">Amazon</span> <span class=\"hljs-variable constant_\">ECR</span>에 로그인\n        <span class=\"hljs-attr\">id</span>: login-ecr\n        <span class=\"hljs-attr\">uses</span>: aws-actions/amazon-ecr-login@v1\n\n      - <span class=\"hljs-attr\">name</span>: 도커 이미지 빌드 및 푸시\n        <span class=\"hljs-attr\">run</span>: |\n          <span class=\"hljs-variable constant_\">REPOSITORY_URI</span>=$(aws ecr describe-repositories --repository-names app-repo --query <span class=\"hljs-string\">\"repositories[0].repositoryUri\"</span> --output text --region eu-north-<span class=\"hljs-number\">1</span>)\n          docker build -t <span class=\"hljs-attr\">$REPOSITORY_URI</span>:latest -f src/<span class=\"hljs-title class_\">Dockerfile</span> src\n          docker push <span class=\"hljs-attr\">$REPOSITORY_URI</span>:latest\n        <span class=\"hljs-attr\">env</span>:\n          <span class=\"hljs-attr\">AWS_REGION</span>: eu-north-<span class=\"hljs-number\">1</span>\n\n      - <span class=\"hljs-attr\">name</span>: <span class=\"hljs-title class_\">Terraform</span> 설정\n        <span class=\"hljs-attr\">uses</span>: hashicorp/setup-terraform@v1\n        <span class=\"hljs-attr\">with</span>:\n          <span class=\"hljs-attr\">terraform_version</span>: <span class=\"hljs-number\">1.8</span><span class=\"hljs-number\">.5</span>\n\n      - <span class=\"hljs-attr\">name</span>: <span class=\"hljs-title class_\">Terraform</span> 초기화\n        <span class=\"hljs-attr\">run</span>: terraform init -input=<span class=\"hljs-literal\">false</span>\n        working-<span class=\"hljs-attr\">directory</span>: infra\n\n      - <span class=\"hljs-attr\">name</span>: <span class=\"hljs-title class_\">Terraform</span> 계획 수립\n        <span class=\"hljs-attr\">run</span>: terraform plan -input=<span class=\"hljs-literal\">false</span>\n        working-<span class=\"hljs-attr\">directory</span>: infra\n        <span class=\"hljs-attr\">env</span>:\n          <span class=\"hljs-attr\">TF_VAR_db_password</span>: ${secrets.<span class=\"hljs-property\">DB_PASSWORD</span>}\n          <span class=\"hljs-attr\">TF_VAR_aws_region</span>: ${secrets.<span class=\"hljs-property\">AWS_REGION</span>}\n\n      - <span class=\"hljs-attr\">name</span>: <span class=\"hljs-title class_\">Terraform</span> 적용\n        <span class=\"hljs-attr\">id</span>: apply\n        <span class=\"hljs-attr\">run</span>: terraform apply -auto-approve -input=<span class=\"hljs-literal\">false</span>\n        working-<span class=\"hljs-attr\">directory</span>: infra\n        <span class=\"hljs-attr\">env</span>:\n          <span class=\"hljs-attr\">TF_VAR_db_password</span>: ${secrets.<span class=\"hljs-property\">DB_PASSWORD</span>}\n          <span class=\"hljs-attr\">TF_VAR_aws_region</span>: ${secrets.<span class=\"hljs-property\">AWS_REGION</span>}\n</code></pre>\n<p></p>\n<p>상기 GitHub 액션 설정은 .NET 앱을 AWS로 쉽게 배포할 수 있도록 해주는 내용입니다. 이 설정에는 .NET Core 설정부터 의존성 복원, 앱 빌드 및 게시, 그리고 컨테이너화를 위한 Docker 통합까지 모두 다루는 여러 단계가 포함되어 있습니다. 또한 AWS 자격 증명을 처리하고 Docker 이미지를 Amazon ECR에 빌드 및 푸시하며, Terraform을 사용하여 인프라 구축도 수행합니다. 기본적으로 전체 프로세스를 자동화하여 배포가 완전히 간편해집니다.</p>\n<p>빌드가 성공적으로 완료되면 API의 URL을 얻기 위해 AWS 콘솔을 방문해보세요.</p>\n<p><img src=\"/assets/img/2024-06-19-EffortlessclouddeploymentLaunchNETAPIwithAngularFrontendonAWSUsingTerraformandGitHubActionsPART23_2.png\" alt=\"이미지\"></p>\n<p>DNS 이름을 가져와 브라우저에서 해당 URL을 열어보세요. 모든 것이 잘 되었다면 API 백엔드가 응답해야 합니다.</p>\n<p></p>\n<h1>요약</h1>\n<p>조금 길었지만, Terraform을 사용하여 AWS에 컨테이너화된 .NET API를 배포하는 모든 중요한 단계를 다루었습니다. 이 가이드가 새 프로젝트를 처음부터 시작하거나 인프라 설정의 복잡성을 탐색하는 데 도움이 되기를 바랍니다. 화이팅!</p>\n</body>\n</html>\n"},"__N_SSG":true}