{"pageProps":{"post":{"title":"Kotlin Flows 기본 개념 이해하기","description":"","date":"2024-06-23 23:34","slug":"2024-06-23-KotlinFlowsFundamentals","content":"\n지난 주에는 Kotlin 코루틴에 대해 더 알아보았어요. 이전 글에서는 CoroutineContext, CoroutineScope, Coroutine Builder 등 코루틴의 기초 중 일부에 초점을 맞췄죠. 약속대로, 지금은 그에 대한 후속 글로 Flows에 대해 다루려고 해요.\n\n# Flows가 뭔가요?\n\n비동기로 계산할 수 있는 데이터의 스트림을 Flow라고 합니다. Flow는 LiveData와 RxJava 스트림과 같이 옵저버 패턴을 구현할 수 있게 해줍니다. 옵저버 패턴은 상태 변경이 일어날 때 해당 상태를 관찰하는 객체(소스)와 그 상태 변경을 자동으로 알리는 의존 객체들(수집자)으로 이루어진 소프트웨어 디자인 패턴입니다. Flow는 일시 중지 함수를 사용하여 값을 비동기적으로 생성하고 소비합니다.\n\nFlow를 생성하려면 먼저 프로듀서를 만들어야 해요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nval randomFlow: Flow<Int> = flow {\nrepeat(10) { it ->\nemit(it+1) // flow에 대한 요청 결과를 내보낸다\ndelay(1000) // 코루틴을 1초 동안 일시 중단한다\n}\n}\n\nFlow를 수집하려면 먼저 Flow가 내부적으로 코루틴에서 작동하기 때문에, Coroutine을 시작해야 합니다. collect 연산자는 emit된 값들을 수집하는 데 사용됩니다.\n\n```kotlin\nlifecycleScope.launch {\n    viewModel.uiStateFlow.collect { it ->\n        binding.uiText.text = it.toString()\n    }\n}\n```\n\nFlow에는 두 가지 서로 다른 유형이 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- Cold Flow — 값을 수집하기 시작할 때까지 값을 생성하지 않습니다. 오직 하나의 구독자만 가질 수 있으며 데이터를 저장하지 않습니다.\n\n```js\n// Regular Flow 예시\nval coldFlow = flow {\n     emit(0)\n     emit(1)\n     emit(2)\n}\n\nlaunch { // 처음으로 collect를 호출\n    coldFlow.collect { value ->\n        println(\"cold flow collector 1이 받은 값: $value\")\n    }\n\n    delay(2500)\n\n  // 두 번째로 collect를 호출\n  coldFlow.collect { value ->\n        println(\"cold flow collector 2이 받은 값: $value\")\n    }\n}\n\n// 결과\n// 두 수집자는 처음부터 모든 값을 받게 됩니다.\n// 두 수집자에 대해 해당 Flow는 처음부터 시작합니다.\nflow collector 1이 받은 값: [0, 1, 2]\nflow collector 1이 받은 값: [0, 1, 2]\n```\n\n- Hot Flow — 아무도 수집하지 않아도 값을 생성합니다. 여러 구독자를 가질 수 있으며 데이터를 저장할 수 있습니다.\n\n```js\n// SharedFlow 예시\nval sharedFlow = MutableSharedFlow<Int>()\n\nsharedFlow.emit(0)\nsharedFlow.emit(1)\nsharedFlow.emit(2)\nsharedFlow.emit(3)\nsharedFlow.emit(4)\n\nlaunch {\n    sharedFlow.collect { value ->\n        println(\"SharedFlow 수집자 1이 받은 값: $value\")\n    }\n\n    delay(2500)\n\n  // 두 번째로 collect를 호출\n  sharedFlow.collect { value ->\n        println(\"SharedFlow 수집자 2이 받은 값: $value\")\n    }\n}\n\n// 결과\n// 수집자는 수집을 시작한 곳부터 값을 받습니다.\n// 여기서 1번째 수집자는 모든 값을 받게 됩니다. 하지만 2번째 수집자는\n// 2500밀리초 후에 수집을 시작했기 때문에 그 이후에 방출된 값만을 받습니다.\nSharedFlow 수집자 1이 받은 값: [0, 1, 2, 3, 4]\nSharedFlow 수집자 2이 받은 값: [2, 3, 4]\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n어떤 cold flow라도 stateIn() 및 shareIn() 연산자를 사용하여 각각 뜨거운 flow로 변환할 수 있습니다.\n\n## SharedFlow 및 StateFlow\n\n- StateFlow — StateFlow는 한 번에 하나의 값을 보유하는 상태를 나타내는 뜨거운 flow입니다. 또한 conflated flow이며, 새 값이 발행될 때 가장 최근 값이 보존되고 즉시 새 수집기에 발행됩니다. 상태에 대한 단일 진실 원천을 유지하고 모든 수집기를 자동으로 최신 상태로 업데이트해야 할 때 유용합니다. 항상 초기 값이 있으며 최신으로 발행된 값만 저장합니다.\n\n```js\nclass HomeViewModel : ViewModel() {\n\n    private val _textStateFlow = MutableStateFlow(\"Hello World\")\n    val stateFlow =_textStateFlow.asStateFlow()\n\n    fun triggerStateFlow(){\n        _textStateFlow.value=\"State flow\"\n    }\n}\n\n// Activity/Fragment에서 StateFlow 수집\nclass HomeFragment : Fragment() {\n    private val viewModel: HomeViewModel by viewModels()\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n\nlifecycleScope.launchWhenStarted {\n\n  // Flow를 트리거하고 값 수집 시작\n\n  // collectLatest()는 Kotlin의 Flow API의 고차 함수로\n  // Flow로부터 발행된 값을 수집하고 최신 값에 대해 변환할 수 있는 함수입니다.\n  // 모든 발행된 값들을 수집하는 collect()와 유사하지만,\n  // collectLatest는 최신으로 발행된 값만 처리하고\n  // 아직 처리되지 않은 이전 값들을 무시합니다.\n    viewModel.stateFlow.collectLatest {\n          binding.stateFlowButton.text = it\n    }\n  }\n}\n\n// Compose에서 StateFlow 수집\n@Compose\nfun HomeScreen() {\n // Compose는 flow에서 값을 수집하고 사용할 최신 값을 제공하는\n // collectAsStateWithLifecycle 함수를 제공합니다.\n // 새로운 flow 값이 발행되면 업데이트된 값을 얻고,\n // 재구성을 통해 값의 상태를 업데이트합니다.\n // LifeCycle.State.Started를 기본값으로 사용하여 수집을 시작합니다.\n // 지정된 상태의 라이프사이클에 있을 때 값 수집을 시작하고,\n // 해당 상태 아래로 떨어질 때 멈춥니다.\n  val someFlow by viewModel.flow.collectAsStateWithLifecycle()\n\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- SharedFlow — SharedFlow는 여러 개의 수집기(collector)를 가질 수 있는 HotFlow입니다. 수집기들과 독립적으로 값을 방출할 수 있으며, 다수의 수집기들이 동일한 flow에서 값을 수집할 수 있습니다. 하나의 값을 여러 수집기에 브로드캐스팅하거나 동일한 데이터 스트림에 대해 여러 구독자를 가질 때 유용합니다. 초기값이 없으며, 새롭게 추가된 수집기들을 위해 이전에 방출된 값을 일정 수만큼 저장할 replay 캐시를 구성할 수 있습니다.\n\n```js\nclass HomeViewModel : ViewModel() {\n    private val _events = MutableSharedFlow<Event>() // 비공개 mutable shared flow\n    val events = _events.asSharedFlow() // 외부에 노출된 읽기 전용 shared flow\n\n    suspend fun produceEvent(event: Event) {\n        _events.emit(event) // 모든 구독자가 받을 때까지 실행이 중단됩니다\n    }\n}\n\n// Activity/Fragment에서 StateFlow 수집\nclass HomeFragment : Fragment() {\n    private val viewModel: HomeViewModel by viewModels()\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n\n        lifecycleScope.launchWhenStarted {\n\n            // 플로우를 트리거하고 값을 수신하기 시작합니다\n\n            // collectLatest()는 Kotlin의 Flow API에서 제공되는 고차 함수로,\n            // Flow에서 방출된 값을 수집하고 최신 값에 대해 변환을 수행할 수 있습니다.\n            // collect()와 유사하게 모든 방출된 값을 수집하는데 사용되지만,\n            // collectLatest는 최신 값만 처리하고 아직 처리되지 않은 이전 값들을 무시합니다.\n            viewModel.events.collectLatest {\n                binding.eventFlowButton.text = it\n            }\n        }\n    }\n}\n\n// Compose에서 StateFlow 수집\n@Compose\nfun HomeScreen() {\n    // Compose는 collectAsStateWithLifecycle 함수를 제공하며,\n    // 플로우에서 값을 수집하고 필요한 최신 값을 제공합니다.\n    // 새로운 플로우 값이 방출되면 업데이트된 값을 얻고,\n    // 값의 상태를 업데이트하기 위해 다시 조합(composition)이 발생합니다.\n    // 기본적으로 LifeCycle.State.Started를 사용하여 수집을 시작하고,\n    // 지정된 상태에 있을 때 값을 수집하며, 해당 상태보다 낮아지면 중지합니다.\n    val someFlow by viewModel.events.collectAsStateWithLifecycle()\n}\n```\n\n# 플로우에서 예외 처리\n\nKotlin Flow는 예외와 오류를 처리하기 위한 여러 메커니즘을 제공합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- try-catch 블록 — 예외를 처리하는 기본적인 방법 중 하나는 흐름 내에서 try-catch 블록을 사용하는 것입니다.\n\n```js\nflow {\n    try {\n        emit(productsService.fetchProducts())\n    } catch (e: Exception) {\n        emitError(e)\n    }\n}\n```\n\n- catch 연산자 — Flow의 catch 연산자를 사용하면 예외를 한 곳에서 오류 처리 논리를 캡슐화하여 처리할 수 있습니다.\n\n```js\nflow {\n    emit(productsService.fetchProducts())\n}.catch { e ->\n    emitError(e)\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- onCompletion Operator — Flow가 성공적으로 또는 예외로 완료되고 난 후 코드를 실행할 때 사용됩니다.\n\n```js\nflow {\n    emit(productsService.fetchProducts())\n}.onCompletion { cause ->\n    if (cause != null) {\n        emitError(cause)\n    }\n}\n```\n\n- 사용자 정의 오류 처리 — Android의 복잡한 시나리오에서는 애플리케이션에 적합한 방식으로 오류를 처리하기 위해 사용자 정의 연산자나 확장 함수를 만들 수 있습니다.\n\n```js\nfun <T> Flow<T>.sampleErrorHandler(): Flow<Result<T>> = transform { value ->\n    try {\n        emit(Result.Success(value))\n    } catch (e: Exception) {\n        emit(Result.Error(e))\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# Flows vs LiveData\n\n- LiveData는 라이프사이클을 인식하므로 옵저버의 라이프사이클을 자동으로 관리하여 옵저버가 활성 상태인 경우에만 업데이트가 전달됩니다. 반면에 Flow는 기본적으로 라이프사이클을 인식하지 않습니다. Compose에서는 collectLatest() 또는 collectAsStateWithLifecycle() 함수를 사용하여 Flow로부터 결과를 수집할 수 있습니다.\n- Flow는 더 많은 유연성을 제공하며 더 복잡한 비동기 데이터 작업에 적합하며, LiveData는 일반적으로 간단한 UI 업데이트에 사용됩니다.\n- Flow는 백프레셔(backpressure)를 내장 지원하여 데이터 방출 및 처리 속도를 제어할 수 있지만, LiveData는 백프레셔 처리를 지원하지 않습니다.\n- Flow는 순차적 및 구조화된 처리를위한 다양한 연산자를 제공하며, LiveData는 옵저버에게 최신 데이터를 제공하는 데 중점을 둡니다.\n\n읽어 주셔서 감사합니다! 이 기사가 유익하고 즐거우셨기를 바랍니다. 의견은 댓글 섹션에 남겨 주세요.\n\n좋은 코딩 되세요!\n","ogImage":{"url":"/assets/img/2024-06-23-KotlinFlowsFundamentals_0.png"},"coverImage":"/assets/img/2024-06-23-KotlinFlowsFundamentals_0.png","tag":["Tech"],"readingTime":9},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p>지난 주에는 Kotlin 코루틴에 대해 더 알아보았어요. 이전 글에서는 CoroutineContext, CoroutineScope, Coroutine Builder 등 코루틴의 기초 중 일부에 초점을 맞췄죠. 약속대로, 지금은 그에 대한 후속 글로 Flows에 대해 다루려고 해요.</p>\n<h1>Flows가 뭔가요?</h1>\n<p>비동기로 계산할 수 있는 데이터의 스트림을 Flow라고 합니다. Flow는 LiveData와 RxJava 스트림과 같이 옵저버 패턴을 구현할 수 있게 해줍니다. 옵저버 패턴은 상태 변경이 일어날 때 해당 상태를 관찰하는 객체(소스)와 그 상태 변경을 자동으로 알리는 의존 객체들(수집자)으로 이루어진 소프트웨어 디자인 패턴입니다. Flow는 일시 중지 함수를 사용하여 값을 비동기적으로 생성하고 소비합니다.</p>\n<p>Flow를 생성하려면 먼저 프로듀서를 만들어야 해요.</p>\n<p></p>\n<p>val randomFlow: Flow = flow {\nrepeat(10) { it ->\nemit(it+1) // flow에 대한 요청 결과를 내보낸다\ndelay(1000) // 코루틴을 1초 동안 일시 중단한다\n}\n}</p>\n<p>Flow를 수집하려면 먼저 Flow가 내부적으로 코루틴에서 작동하기 때문에, Coroutine을 시작해야 합니다. collect 연산자는 emit된 값들을 수집하는 데 사용됩니다.</p>\n<pre><code class=\"hljs language-kotlin\">lifecycleScope.launch {\n    viewModel.uiStateFlow.collect { it ->\n        binding.uiText.text = it.toString()\n    }\n}\n</code></pre>\n<p>Flow에는 두 가지 서로 다른 유형이 있습니다.</p>\n<p></p>\n<ul>\n<li>Cold Flow — 값을 수집하기 시작할 때까지 값을 생성하지 않습니다. 오직 하나의 구독자만 가질 수 있으며 데이터를 저장하지 않습니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// Regular Flow 예시</span>\nval coldFlow = flow {\n     <span class=\"hljs-title function_\">emit</span>(<span class=\"hljs-number\">0</span>)\n     <span class=\"hljs-title function_\">emit</span>(<span class=\"hljs-number\">1</span>)\n     <span class=\"hljs-title function_\">emit</span>(<span class=\"hljs-number\">2</span>)\n}\n\nlaunch { <span class=\"hljs-comment\">// 처음으로 collect를 호출</span>\n    coldFlow.<span class=\"hljs-property\">collect</span> { value ->\n        <span class=\"hljs-title function_\">println</span>(<span class=\"hljs-string\">\"cold flow collector 1이 받은 값: $value\"</span>)\n    }\n\n    <span class=\"hljs-title function_\">delay</span>(<span class=\"hljs-number\">2500</span>)\n\n  <span class=\"hljs-comment\">// 두 번째로 collect를 호출</span>\n  coldFlow.<span class=\"hljs-property\">collect</span> { value ->\n        <span class=\"hljs-title function_\">println</span>(<span class=\"hljs-string\">\"cold flow collector 2이 받은 값: $value\"</span>)\n    }\n}\n\n<span class=\"hljs-comment\">// 결과</span>\n<span class=\"hljs-comment\">// 두 수집자는 처음부터 모든 값을 받게 됩니다.</span>\n<span class=\"hljs-comment\">// 두 수집자에 대해 해당 Flow는 처음부터 시작합니다.</span>\nflow collector <span class=\"hljs-number\">1</span>이 받은 값: [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>]\nflow collector <span class=\"hljs-number\">1</span>이 받은 값: [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>]\n</code></pre>\n<ul>\n<li>Hot Flow — 아무도 수집하지 않아도 값을 생성합니다. 여러 구독자를 가질 수 있으며 데이터를 저장할 수 있습니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// SharedFlow 예시</span>\nval sharedFlow = <span class=\"hljs-title class_\">MutableSharedFlow</span>&#x3C;<span class=\"hljs-title class_\">Int</span>>()\n\nsharedFlow.<span class=\"hljs-title function_\">emit</span>(<span class=\"hljs-number\">0</span>)\nsharedFlow.<span class=\"hljs-title function_\">emit</span>(<span class=\"hljs-number\">1</span>)\nsharedFlow.<span class=\"hljs-title function_\">emit</span>(<span class=\"hljs-number\">2</span>)\nsharedFlow.<span class=\"hljs-title function_\">emit</span>(<span class=\"hljs-number\">3</span>)\nsharedFlow.<span class=\"hljs-title function_\">emit</span>(<span class=\"hljs-number\">4</span>)\n\nlaunch {\n    sharedFlow.<span class=\"hljs-property\">collect</span> { value ->\n        <span class=\"hljs-title function_\">println</span>(<span class=\"hljs-string\">\"SharedFlow 수집자 1이 받은 값: $value\"</span>)\n    }\n\n    <span class=\"hljs-title function_\">delay</span>(<span class=\"hljs-number\">2500</span>)\n\n  <span class=\"hljs-comment\">// 두 번째로 collect를 호출</span>\n  sharedFlow.<span class=\"hljs-property\">collect</span> { value ->\n        <span class=\"hljs-title function_\">println</span>(<span class=\"hljs-string\">\"SharedFlow 수집자 2이 받은 값: $value\"</span>)\n    }\n}\n\n<span class=\"hljs-comment\">// 결과</span>\n<span class=\"hljs-comment\">// 수집자는 수집을 시작한 곳부터 값을 받습니다.</span>\n<span class=\"hljs-comment\">// 여기서 1번째 수집자는 모든 값을 받게 됩니다. 하지만 2번째 수집자는</span>\n<span class=\"hljs-comment\">// 2500밀리초 후에 수집을 시작했기 때문에 그 이후에 방출된 값만을 받습니다.</span>\n<span class=\"hljs-title class_\">SharedFlow</span> 수집자 <span class=\"hljs-number\">1</span>이 받은 값: [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>]\n<span class=\"hljs-title class_\">SharedFlow</span> 수집자 <span class=\"hljs-number\">2</span>이 받은 값: [<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>]\n</code></pre>\n<p></p>\n<p>어떤 cold flow라도 stateIn() 및 shareIn() 연산자를 사용하여 각각 뜨거운 flow로 변환할 수 있습니다.</p>\n<h2>SharedFlow 및 StateFlow</h2>\n<ul>\n<li>StateFlow — StateFlow는 한 번에 하나의 값을 보유하는 상태를 나타내는 뜨거운 flow입니다. 또한 conflated flow이며, 새 값이 발행될 때 가장 최근 값이 보존되고 즉시 새 수집기에 발행됩니다. 상태에 대한 단일 진실 원천을 유지하고 모든 수집기를 자동으로 최신 상태로 업데이트해야 할 때 유용합니다. 항상 초기 값이 있으며 최신으로 발행된 값만 저장합니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">HomeViewModel</span> : <span class=\"hljs-title class_\">ViewModel</span>() {\n\n    private val _textStateFlow = <span class=\"hljs-title class_\">MutableStateFlow</span>(<span class=\"hljs-string\">\"Hello World\"</span>)\n    val stateFlow =_textStateFlow.<span class=\"hljs-title function_\">asStateFlow</span>()\n\n    fun <span class=\"hljs-title function_\">triggerStateFlow</span>(<span class=\"hljs-params\"></span>){\n        _textStateFlow.<span class=\"hljs-property\">value</span>=<span class=\"hljs-string\">\"State flow\"</span>\n    }\n}\n\n<span class=\"hljs-comment\">// Activity/Fragment에서 StateFlow 수집</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">HomeFragment</span> : <span class=\"hljs-title class_\">Fragment</span>() {\n    private val <span class=\"hljs-attr\">viewModel</span>: <span class=\"hljs-title class_\">HomeViewModel</span> by <span class=\"hljs-title function_\">viewModels</span>()\n\n    override fun <span class=\"hljs-title function_\">onViewCreated</span>(<span class=\"hljs-params\">view: View, savedInstanceState: Bundle?</span>) {\n        <span class=\"hljs-variable language_\">super</span>.<span class=\"hljs-title function_\">onViewCreated</span>(view, savedInstanceState)\n\nlifecycleScope.<span class=\"hljs-property\">launchWhenStarted</span> {\n\n  <span class=\"hljs-comment\">// Flow를 트리거하고 값 수집 시작</span>\n\n  <span class=\"hljs-comment\">// collectLatest()는 Kotlin의 Flow API의 고차 함수로</span>\n  <span class=\"hljs-comment\">// Flow로부터 발행된 값을 수집하고 최신 값에 대해 변환할 수 있는 함수입니다.</span>\n  <span class=\"hljs-comment\">// 모든 발행된 값들을 수집하는 collect()와 유사하지만,</span>\n  <span class=\"hljs-comment\">// collectLatest는 최신으로 발행된 값만 처리하고</span>\n  <span class=\"hljs-comment\">// 아직 처리되지 않은 이전 값들을 무시합니다.</span>\n    viewModel.<span class=\"hljs-property\">stateFlow</span>.<span class=\"hljs-property\">collectLatest</span> {\n          binding.<span class=\"hljs-property\">stateFlowButton</span>.<span class=\"hljs-property\">text</span> = it\n    }\n  }\n}\n\n<span class=\"hljs-comment\">// Compose에서 StateFlow 수집</span>\n@<span class=\"hljs-title class_\">Compose</span>\nfun <span class=\"hljs-title class_\">HomeScreen</span>() {\n <span class=\"hljs-comment\">// Compose는 flow에서 값을 수집하고 사용할 최신 값을 제공하는</span>\n <span class=\"hljs-comment\">// collectAsStateWithLifecycle 함수를 제공합니다.</span>\n <span class=\"hljs-comment\">// 새로운 flow 값이 발행되면 업데이트된 값을 얻고,</span>\n <span class=\"hljs-comment\">// 재구성을 통해 값의 상태를 업데이트합니다.</span>\n <span class=\"hljs-comment\">// LifeCycle.State.Started를 기본값으로 사용하여 수집을 시작합니다.</span>\n <span class=\"hljs-comment\">// 지정된 상태의 라이프사이클에 있을 때 값 수집을 시작하고,</span>\n <span class=\"hljs-comment\">// 해당 상태 아래로 떨어질 때 멈춥니다.</span>\n  val someFlow by viewModel.<span class=\"hljs-property\">flow</span>.<span class=\"hljs-title function_\">collectAsStateWithLifecycle</span>()\n\n}\n</code></pre>\n<p></p>\n<ul>\n<li>SharedFlow — SharedFlow는 여러 개의 수집기(collector)를 가질 수 있는 HotFlow입니다. 수집기들과 독립적으로 값을 방출할 수 있으며, 다수의 수집기들이 동일한 flow에서 값을 수집할 수 있습니다. 하나의 값을 여러 수집기에 브로드캐스팅하거나 동일한 데이터 스트림에 대해 여러 구독자를 가질 때 유용합니다. 초기값이 없으며, 새롭게 추가된 수집기들을 위해 이전에 방출된 값을 일정 수만큼 저장할 replay 캐시를 구성할 수 있습니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">HomeViewModel</span> : <span class=\"hljs-title class_\">ViewModel</span>() {\n    private val _events = <span class=\"hljs-title class_\">MutableSharedFlow</span>&#x3C;<span class=\"hljs-title class_\">Event</span>>() <span class=\"hljs-comment\">// 비공개 mutable shared flow</span>\n    val events = _events.<span class=\"hljs-title function_\">asSharedFlow</span>() <span class=\"hljs-comment\">// 외부에 노출된 읽기 전용 shared flow</span>\n\n    suspend fun <span class=\"hljs-title function_\">produceEvent</span>(<span class=\"hljs-params\">event: Event</span>) {\n        _events.<span class=\"hljs-title function_\">emit</span>(event) <span class=\"hljs-comment\">// 모든 구독자가 받을 때까지 실행이 중단됩니다</span>\n    }\n}\n\n<span class=\"hljs-comment\">// Activity/Fragment에서 StateFlow 수집</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">HomeFragment</span> : <span class=\"hljs-title class_\">Fragment</span>() {\n    private val <span class=\"hljs-attr\">viewModel</span>: <span class=\"hljs-title class_\">HomeViewModel</span> by <span class=\"hljs-title function_\">viewModels</span>()\n\n    override fun <span class=\"hljs-title function_\">onViewCreated</span>(<span class=\"hljs-params\">view: View, savedInstanceState: Bundle?</span>) {\n        <span class=\"hljs-variable language_\">super</span>.<span class=\"hljs-title function_\">onViewCreated</span>(view, savedInstanceState)\n\n        lifecycleScope.<span class=\"hljs-property\">launchWhenStarted</span> {\n\n            <span class=\"hljs-comment\">// 플로우를 트리거하고 값을 수신하기 시작합니다</span>\n\n            <span class=\"hljs-comment\">// collectLatest()는 Kotlin의 Flow API에서 제공되는 고차 함수로,</span>\n            <span class=\"hljs-comment\">// Flow에서 방출된 값을 수집하고 최신 값에 대해 변환을 수행할 수 있습니다.</span>\n            <span class=\"hljs-comment\">// collect()와 유사하게 모든 방출된 값을 수집하는데 사용되지만,</span>\n            <span class=\"hljs-comment\">// collectLatest는 최신 값만 처리하고 아직 처리되지 않은 이전 값들을 무시합니다.</span>\n            viewModel.<span class=\"hljs-property\">events</span>.<span class=\"hljs-property\">collectLatest</span> {\n                binding.<span class=\"hljs-property\">eventFlowButton</span>.<span class=\"hljs-property\">text</span> = it\n            }\n        }\n    }\n}\n\n<span class=\"hljs-comment\">// Compose에서 StateFlow 수집</span>\n@<span class=\"hljs-title class_\">Compose</span>\nfun <span class=\"hljs-title class_\">HomeScreen</span>() {\n    <span class=\"hljs-comment\">// Compose는 collectAsStateWithLifecycle 함수를 제공하며,</span>\n    <span class=\"hljs-comment\">// 플로우에서 값을 수집하고 필요한 최신 값을 제공합니다.</span>\n    <span class=\"hljs-comment\">// 새로운 플로우 값이 방출되면 업데이트된 값을 얻고,</span>\n    <span class=\"hljs-comment\">// 값의 상태를 업데이트하기 위해 다시 조합(composition)이 발생합니다.</span>\n    <span class=\"hljs-comment\">// 기본적으로 LifeCycle.State.Started를 사용하여 수집을 시작하고,</span>\n    <span class=\"hljs-comment\">// 지정된 상태에 있을 때 값을 수집하며, 해당 상태보다 낮아지면 중지합니다.</span>\n    val someFlow by viewModel.<span class=\"hljs-property\">events</span>.<span class=\"hljs-title function_\">collectAsStateWithLifecycle</span>()\n}\n</code></pre>\n<h1>플로우에서 예외 처리</h1>\n<p>Kotlin Flow는 예외와 오류를 처리하기 위한 여러 메커니즘을 제공합니다.</p>\n<p></p>\n<ul>\n<li>try-catch 블록 — 예외를 처리하는 기본적인 방법 중 하나는 흐름 내에서 try-catch 블록을 사용하는 것입니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\">flow {\n    <span class=\"hljs-keyword\">try</span> {\n        <span class=\"hljs-title function_\">emit</span>(productsService.<span class=\"hljs-title function_\">fetchProducts</span>())\n    } <span class=\"hljs-keyword\">catch</span> (<span class=\"hljs-attr\">e</span>: <span class=\"hljs-title class_\">Exception</span>) {\n        <span class=\"hljs-title function_\">emitError</span>(e)\n    }\n}\n</code></pre>\n<ul>\n<li>catch 연산자 — Flow의 catch 연산자를 사용하면 예외를 한 곳에서 오류 처리 논리를 캡슐화하여 처리할 수 있습니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\">flow {\n    <span class=\"hljs-title function_\">emit</span>(productsService.<span class=\"hljs-title function_\">fetchProducts</span>())\n}.<span class=\"hljs-property\">catch</span> { e ->\n    <span class=\"hljs-title function_\">emitError</span>(e)\n}\n</code></pre>\n<p></p>\n<ul>\n<li>onCompletion Operator — Flow가 성공적으로 또는 예외로 완료되고 난 후 코드를 실행할 때 사용됩니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\">flow {\n    <span class=\"hljs-title function_\">emit</span>(productsService.<span class=\"hljs-title function_\">fetchProducts</span>())\n}.<span class=\"hljs-property\">onCompletion</span> { cause ->\n    <span class=\"hljs-keyword\">if</span> (cause != <span class=\"hljs-literal\">null</span>) {\n        <span class=\"hljs-title function_\">emitError</span>(cause)\n    }\n}\n</code></pre>\n<ul>\n<li>사용자 정의 오류 처리 — Android의 복잡한 시나리오에서는 애플리케이션에 적합한 방식으로 오류를 처리하기 위해 사용자 정의 연산자나 확장 함수를 만들 수 있습니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\">fun &#x3C;T> <span class=\"hljs-title class_\">Flow</span>&#x3C;T>.<span class=\"hljs-title function_\">sampleErrorHandler</span>(): <span class=\"hljs-title class_\">Flow</span>&#x3C;<span class=\"hljs-title class_\">Result</span>&#x3C;T>> = transform { value ->\n    <span class=\"hljs-keyword\">try</span> {\n        <span class=\"hljs-title function_\">emit</span>(<span class=\"hljs-title class_\">Result</span>.<span class=\"hljs-title class_\">Success</span>(value))\n    } <span class=\"hljs-keyword\">catch</span> (<span class=\"hljs-attr\">e</span>: <span class=\"hljs-title class_\">Exception</span>) {\n        <span class=\"hljs-title function_\">emit</span>(<span class=\"hljs-title class_\">Result</span>.<span class=\"hljs-title class_\">Error</span>(e))\n    }\n}\n</code></pre>\n<p></p>\n<h1>Flows vs LiveData</h1>\n<ul>\n<li>LiveData는 라이프사이클을 인식하므로 옵저버의 라이프사이클을 자동으로 관리하여 옵저버가 활성 상태인 경우에만 업데이트가 전달됩니다. 반면에 Flow는 기본적으로 라이프사이클을 인식하지 않습니다. Compose에서는 collectLatest() 또는 collectAsStateWithLifecycle() 함수를 사용하여 Flow로부터 결과를 수집할 수 있습니다.</li>\n<li>Flow는 더 많은 유연성을 제공하며 더 복잡한 비동기 데이터 작업에 적합하며, LiveData는 일반적으로 간단한 UI 업데이트에 사용됩니다.</li>\n<li>Flow는 백프레셔(backpressure)를 내장 지원하여 데이터 방출 및 처리 속도를 제어할 수 있지만, LiveData는 백프레셔 처리를 지원하지 않습니다.</li>\n<li>Flow는 순차적 및 구조화된 처리를위한 다양한 연산자를 제공하며, LiveData는 옵저버에게 최신 데이터를 제공하는 데 중점을 둡니다.</li>\n</ul>\n<p>읽어 주셔서 감사합니다! 이 기사가 유익하고 즐거우셨기를 바랍니다. 의견은 댓글 섹션에 남겨 주세요.</p>\n<p>좋은 코딩 되세요!</p>\n</body>\n</html>\n"},"__N_SSG":true}