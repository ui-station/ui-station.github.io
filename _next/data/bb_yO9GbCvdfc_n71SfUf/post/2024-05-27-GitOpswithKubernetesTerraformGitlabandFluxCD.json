{"pageProps":{"post":{"title":"GitOps와 Kubernetes, Terraform, Gitlab 그리고 FluxCD","description":"","date":"2024-05-27 17:43","slug":"2024-05-27-GitOpswithKubernetesTerraformGitlabandFluxCD","content":"\n<img src=\"/assets/img/2024-05-27-GitOpswithKubernetesTerraformGitlabandFluxCD_0.png\" />\n\n# 소개:\n\n이 블로그 포스트에서는 테라폼, gitlab, fluxcd 및 kustomize를 사용하여 엔드 투 엔드 gitops 워크플로를 설계하는 방법에 대해 논의하려고 합니다.\n\n그러나 구현 세부 정보에 대해 깊이 파고들기 전에, gitops가 다루는 문제 설명과 테라폼이 어떻게 관련되는지에 대해 이해해 봅시다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# GitOps의 무엇과 왜\n\n현재 우리가 인프라를 구축하는 방식을 살펴보면 대부분의 경우 인프라를 코드로 구축하거나 적어도 대부분의 클라우드 인프라가 그러한 방식으로 구축됩니다. 인프라를 코드로 사용하는 것의 하나의 어려움은 코드베이스가 성장하고 더 많은 사람들이 개발 프로세스에 참여함에 따라 코드베이스를 유지하는 것이 어려워진다는 것입니다.\n\n이것이 바로 gitops가 나타나는 곳입니다. 핵심적으로 gitops는 git을 활용하여 인프라 코드의 코드 베이스를 유지하고 설정을 대상 환경에 자동으로 매칭하는 방식을 사용합니다. 이러한 방식으로 우리는 이전보다 빠르게 배포할 수 있을 뿐만 아니라 시간이 지남에 따라 무엇이 변경되었는지 완전한 기록이 있기 때문에 이전보다 빨리 오류를 감지하고 복구할 수 있습니다.\n\n# GitOps에 대한 Terraform 선택이유\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n지금쯤이면 terraform이 어떻게 관련되며 어떻게 도움이 되는지 궁금해할 수 있습니다. 이전 섹션에서는 구성을 매치하는 자동화된 방법에 대해 이야기했습니다. 일반적인 Kubernetes 환경에서는 fluxcd와 같은 도구를 사용하여 이를 수행합니다. 그러나 이러한 추가 구성과 설정이 필요합니다. 여기서 terraform이 등장합니다. terraform을 사용하면 인프라를 구축할 뿐만 아니라 flux와 같은 도구를 설치하고 구성할 수도 있습니다. 이렇게 하면 한 번에 Kubernetes 클러스터를 구축하고 flux를 부트스트랩하며 그에 따라 gitops 워크플로우를 설정할 수 있습니다. 이렇게 하면 처음부터 완전히 기능적인 gitops 워크플로우가 구축됩니다.\n\n## 도구 개요:\n\n## FluxCD:\n\nFlux는 Kubernetes 클러스터를 구성 소스(예: Git 저장소)와 동기화하고 새 코드를 배포할 때 구성을 자동으로 업데이트하는 도구입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# Gitlab:\n\nGitLab은 응용 프로그램 빌드 및 릴리스 프로세스를 자동화하는 데 도움이되는 CI/CD 도구입니다.\n\n# Terraform:\n\nTerraform을 사용하면 선언적 구성 언어를 사용하여 가상 머신, 네트워크, 저장소 및 기타 클라우드 서비스와 같은 인프라 리소스를 정의하고 프로비저닝할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 우리가 만들 것:\n\n해결책에서는 nginx 앱을 eks 클러스터에 배포하고, flux를 사용하여 eks 클러스터에 대한 배포를 관리하며, 인프라 프로비저닝 및 flux 부트스트랩 구성을 위해 terraform을 사용합니다.\n\n# 설정\n\n# 준비 사항:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n1) AWS 계정\n2) Gitlab 클라우드 계정 / 자체 호스팅된 Gitlab\n3) 로컬 시스템에 설치된 최신 버전의 Terraform\n\n# 환경 설정:\n\n## AWS 설정:\n\nECR Repository 생성\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nAWS ECR 레지스트리에 로그인합니다.\n\n```bash\naws ecr get-login-password | docker login --username AWS --password-stdin <aws_account_id>.dkr.ecr.<region>.amazonaws.com\n```\n\nDocker Hub에서 Nginx 이미지를 가져옵니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n도커 pull nginx:latest\n```\n\n당신의 ECR 저장소에 Nginx 이미지를 태그하기\n\n```js\n도커 tag nginx:latest <aws_account_id>.dkr.ecr.<region>.amazonaws.com/nginx-repo:0.0.1\n```\n\n이미지를 ECR 저장소에 푸시하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n도커 푸시 <aws_account_id>.dkr.ecr.<region>.amazonaws.com/nginx-repo:0.0.1\n```\n\n## Gitlab 설정\n\nPAT 토큰 생성\n\n```js\n- GitLab 인스턴스에 로그인하세요\n- 프로필 아이콘을 클릭하세요\n- 환경설정을 클릭한 후에 접근 토큰을 클릭하세요\n- 토큰의 이름을 입력하고 만료 날짜를 설정하세요\n- 그 다음에 api 라는 scopes 아래의 첫 번째 확인란을 선택하세요\n- 개인 접근 토큰 만들기를 클릭한 후에 토큰을 표시하세요\n- 토큰을 저장하세요.\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n프로젝트 설정:\n\n```js\n- gitlab의 클라우드 인스턴스에서 새 프로젝트 버튼을 클릭합니다.\n- 빈 프로젝트 생성을 클릭합니다.\n- 프로젝트 이름을 제공합니다 (나중에 사용할 이름을 메모해 둡니다).\n- 프로젝트 URL 옆의 드롭 다운에서 그룹 이름을 선택하고,\n   이 그룹 이름을 나중에 사용할 것이니 메모해 둡니다.\n- 프로젝트를 위한 이름을 제공합니다.\n- 가시성을 선택합니다.\n- 프로젝트를 저장합니다.\n- 코드 버튼을 클릭하고, https용 github URL을 복사하여\n  나중에 필요할 때를 대비하여 URL을 메모해 둡니다.\n```\n\n## Terraform 설정\n\nTerraform 구성 및 스니펫을 사용하여 인프라를 구축하기 전에 아래 명령어를 사용하여 AWS 자격 증명을 설정해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nAWS 자격 증명 설정\n\n```js\n% export AWS_ACCESS_KEY_ID=\"anaccesskey\"\n% export AWS_SECRET_ACCESS_KEY=\"asecretkey\"\n% export AWS_REGION=\"us-west-2\"\n```\n\n위 설정을 완료한 후 로컬 환경에서 gitlab 토큰을 설정해야 합니다. 아래 섹션에서 그 방법을 안내하겠습니다. gitlab 설정 섹션에서 pat 토큰 섹션에서 복사한 토큰을 붙여넣어주세요.\n\nGitLab 토큰 설정 (Linux/MacOS)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nexport GITLAB_TOKEN=<Gitlab 설정에서 저장한 토큰>\n```\n\nWindows\n\n```js\n$env: GITLAB_TOKEN = \"<Gitlab 설정에서 저장한 토큰>\";\n```\n\n# 안내:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 데모 레포지토리 복제\n\n```js\ngit clone https://gitlab.com/devops5480719/devops-samples.git\n```\n\n그런 다음 인프라 디렉토리로 이동하세요\n\n```js\ncd devops-samples/gitops-gitlab/infra/\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n디렉토리 안으로 들어가시면 아래의 파일과 폴더를 찾을 수 있어요.\n\n```js\n├── config_files\n│   ├── app-nginx.yml\n│   ├── ecr-sync.yml\n│   └── nginx.yml\n├── main.tf\n├── variables.tf\n└── versions.tf\n```\n\n안에 config_files라는 폴더가 있고, 몇 개의 terraform 파일도 있어요.\n\n우선 terraform 파일들을 자세히 살펴보도록 해봐요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 변수 구성\n\n먼저 변수 구성을 살펴봅시다.\n\nvariables.tf\n\n```js\nvariable \"gitlab_group\" {\n  type = string\n  default = <gitlab 그룹의 이름>\n}\n\nvariable \"gitlab_project\" {\n  type = string\n  default = <gitlab 프로젝트의 이름>\n}\n\nvariable \"aws_region\" {\n  type = string\n  default = <리소스를 배포할 AWS 지역의 이름>\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위 코드 조각에서 기본 값 대신에 gitlab 섹션에서 이전에 복사한 이름이있는 gitlab_group으로 대체하십시오. gitlab_project에 대해서도 마찬가지입니다.\n\naws_region으로는 리소스를 배포할 지역을 선택하십시오.\n\n## 공급자 구성\n\n이제 versions.tf 파일에서 공급자 구성을 살펴봅시다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n변수.tf 파일에는 인증 및 권한 부여를 위한 각 프로바이더 블록의 필수 구성 및 필수 제공자가 포함되어 있습니다.\n\n버전.tf\n\n```js\nrequired_providers {\n    flux = {\n      source  = \"fluxcd/flux\"\n      version = \">= 1.0.0\"\n    }\n    gitlab = {\n      source  = \"gitlabhq/gitlab\"\n      version = \">=15.10.0\"\n    }\n    aws = {\n      source  = \"hashicorp/aws\"\n      version = \">= 5.0\"\n    }\n    kubernetes = {\n      source  = \"hashicorp/kubernetes\"\n      version = \">= 2.16.1\"\n    }\n  }\n}\nprovider \"gitlab\" {\n  base_url = \"https://gitlab.com/api/v4/\"\n}\nprovider \"flux\" {\n  kubernetes = {\n    host                   = module.eks.endpoint\n    cluster_ca_certificate = base64decode(module.eks.cluster_ca_certificate)\n    exec = {\n      api_version = \"client.authentication.k8s.io/v1beta1\"\n      args        = [\"eks\", \"get-token\", \"--cluster-name\", var.cluster_name]\n      command     = \"aws\"\n    }\n  }\n  git = {\n    url = \"ssh://git@gitlab.com/${data.gitlab_project.this.path_with_namespace}.git\"\n    ssh = {\n      username    = \"git\"\n      private_key = tls_private_key.flux.private_key_pem\n    }\n    branch = \"main\"\n  }\n}\n```\n\n## 리소스 구성:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n자원 구성을 살펴보겠습니다.\n\nVPC 구성\n\nmain.tf\n\n```js\nmodule \"vpc\" {\n  source = \"terraform-aws-modules/vpc/aws\"\n  name = \"flux-vpc\"\n  cidr = \"10.0.0.0/16\"\n  azs = [\"<aws-region>a\", \"<aws-region>b\", \"<aws-region>c\"]\n  private_subnets = [\"10.0.1.0/24\", \"10.0.2.0/24\", \"10.0.3.0/24\", \"10.0.4.0/24\", \"10.0.5.0/24\", \"10.0.6.0/24\"]\n  public_subnets = [\"10.0.101.0/24\", \"10.0.102.0/24\", \"10.0.103.0/24\"]\n  enable_nat_gateway = true\n  enable_vpn_gateway = false\n  single_nat_gateway = true\n  public_subnet_tags = {\n    \"kubernetes.io/role/elb\" = \"1\"\n  }\n  tags = {\n    Terraform = \"true\"\n    Environment = \"dev\"\n  }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nEKS 구성\n\nEKS를 위해 아래 리소스를 정의할 것입니다.\n\n- EKS 클러스터\n- kubeconfig를 컨텍스트에 추가하기 위한 Null 리소스\n\nmain.tf\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n모듈 \"eks\" {\nsource = \"terraform-aws-modules/eks/aws\"\nversion = \"~> 20.0\"\ncluster_name = \"flux-cluster\"\ncluster_version = \"1.29\"\ncluster_endpoint_private_access = true\ncluster_endpoint_public_access = true\ncloudwatch_log_group_retention_in_days = 7\ncloudwatch_log_group_class = \"INFREQUENT_ACCESS\"\ncluster_enabled_log_types = [\"api\"]\nvpc_id = module.vpc.vpc_id\nsubnet_ids = module.vpc.private_subnets\ncluster_addons = {\ncoredns = {\nmost_recent = true\n}\nkube-proxy = {\nmost_recent = true\n}\naws-ebs-csi-driver = {\nmost_recent = true\n}\neks-pod-identity-agent = {\nmost_recent = true\n}\nvpc-cni = {\nmost_recent = true\n}\n}\neks_managed_node_group_defaults = {\nami_type = \"AL2_x86_64\"\ndisk_size = 50\ninstance_types = [\"t3.large\"]\ncapacity_type = \"SPOT\"\nupdate_config = {\nmax_unavailable_percentage = 100\n}\n}\neks_managed_node_groups = {\nps-cluster-sample = {\nmin_size = 1\ndesired_size = 1\nmax_size = 4\ninstance_types = [\"t3.large\"]\ncapacity_type = \"SPOT\"\n}\n}\nenable_cluster_creator_admin_permissions = false\naccess_entries = {\nadmin_sso = {\nkubernetes_groups = []\nprincipal_arn = \"<arn of the role or the user to which you want to grant admin privileges>\"\npolicy_associations = {\nClusterAdmin = {\npolicy_arn = \"arn:aws:eks::aws:cluster-access-policy/AmazonEKSClusterAdminPolicy\"\naccess_scope = {\ntype = \"cluster\"\n}\n}\nEKSAdmin = {\npolicy_arn = \"arn:aws:eks::aws:cluster-access-policy/AmazonEKSAdminPolicy\"\naccess_scope = {\ntype = \"cluster\"\n}\n}\n}\n}\n}\n}\nresource \"null_resource\" \"update_kubeconfig\" {\ntriggers = {\neks_cluster_id = module.eks.cluster_id\n}\nprovisioner \"local-exec\" {\ncommand = \"aws eks update-kubeconfig --name ${module.eks.cluster_name} --region ${var.aws_region}\"\n}\n}\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n자바스크립트\n리소스 \"tls_private_key\" \"flux\" {\n  depends_on = [module.eks, module.vpc, null_resource.update_kubeconfig]\n  algorithm   = \"ECDSA\"\n  ecdsa_curve = \"P256\"\n}\n데이터 \"gitlab_project\" \"this\" {\n  path_with_namespace = \"${var.gitlab_group}/${var.gitlab_project}\"\n}\n리소스 \"gitlab_deploy_key\" \"this\" {\n  depends_on = [module.eks, module.vpc]\n  project  = data.gitlab_project.this.id\n  title    = \"Flux\"\n  key      = tls_private_key.flux.public_key_openssh\n  can_push = true\n}\n리소스 \"flux_bootstrap_git\" \"this\" {\n  depends_on = [gitlab_deploy_key.this, module.eks, module.vpc, null_resource.update_kubeconfig]\n  path = \"clusters/${module.eks.cluster_name}\"\n  components_extra = [\"image-reflector-controller\",\"image-automation-controller\"]\n}\n로컬 {\n  yaml_files = fileset(\"${path.module}/config_files\", \"*.yml\")\n  yaml_content = { for file in local.yaml_files : file => file(\"${path.module}/config_files/${file}\") }\n}\n리소스 \"gitlab_repository_file\" \"yaml_files\" {\n  depends_on = [flux_bootstrap_git.this, null_resource.update_kubeconfig]\n  for_each = local.yaml_content\n  project = data.gitlab_project.this.id // 새 프로젝트를 생성한 경우 기존 프로젝트나 gitlab_project.example_project.id의 프로젝트 ID를 사용하십시오.\n  file_path = \"clusters/${module.eks.cluster_name}/${each.key}\"\n  content   = base64encode(each.value)\n  commit_message = \"added flux image configs\"\n  branch    = \"main\"\n}\n```\n\n위의 코드 조각에서는 flux_bootstrap_git 리소스에 image-reflector-controller 및 image-automation-controller라는 두 가지 추가 컴포넌트를 추가하고 있습니다.\n\n이 두 컨트롤러는 ECR 리포지토리에서 태그를 가져오거나 업데이트할 책임을 질 것입니다.\n\nflux가 이 작업을 수행하려면 복제 데모 리포지토리의 config_files 폴더에서 찾을 수 있는 몇 가지 추가 구성 요소를 정의해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n├── config_files\n│ ├── app-nginx.yml\n│ ├── ecr-sync.yml\n│ └── nginx.yml\n├── main.tf\n├── variables.tf\n└── versions.tf\n\n이제 이 파일들 각각을 살펴보고 그 내용을 살펴보겠습니다. 우선 app-nginx.yaml 파일부터 시작해봅시다.\n\napp-nginx.yaml\n\n```yaml\n---\napiVersion: v1\nkind: Secret\nmetadata:\n  name: nginx-auth-pat\n  namespace: flux-system\ntype: Opaque\ndata:\n  password: < gitlab 토큰을 base64로 인코딩 된 문자열 >\n  username: < 사용자 이름을 base64로 인코딩 된 문자열 >\n---\napiVersion: source.toolkit.fluxcd.io/v1\nkind: GitRepository\nmetadata:\n  name: nginx\n  namespace: flux-system\nspec:\n  interval: 1m0s\n  ref:\n    branch: main\n  url: <gitlab_repo_url>\n  secretRef:\n    name: nginx-auth-pat\n---\napiVersion: kustomize.toolkit.fluxcd.io/v1\nkind: Kustomization\nmetadata:\n  name: nginx\n  namespace: flux-system\nspec:\n  prune: true\n  interval: 1m0s\n  path: \"./app/nginx/environments/production\"\n  sourceRef:\n    kind: GitRepository\n    name: nginx\n---\napiVersion: image.toolkit.fluxcd.io/v1beta2\nkind: ImageRepository\nmetadata:\n  name: nginx\n  namespace: flux-system\nspec:\n  image: <aws-account-id>.dkr.ecr.<region>.amazonaws.com/<image name>\n  interval: 1m0s\n  secretRef:\n    name: ecr-credentials\n---\napiVersion: image.toolkit.fluxcd.io/v1beta2\nkind: ImagePolicy\nmetadata:\n  name: nginx\n  namespace: flux-system\nspec:\n  imageRepositoryRef:\n    name: nginx\n  policy:\n    semver:\n      range: 0.0.x\n---\napiVersion: image.toolkit.fluxcd.io/v1beta1\nkind: ImageUpdateAutomation\nmetadata:\n  name: nginx\n  namespace: flux-system\nspec:\n  interval: 1m0s\n  sourceRef:\n    kind: GitRepository\n    name: nginx\n  git:\n    checkout:\n      ref:\n        branch: main\n    commit:\n      author:\n        email: flux@example.com\n        name: flux\n      messageTemplate: \"{range .Updated.Images}{println .}{end}\"\n    push:\n      branch: main\n  update:\n    path: ./clusters/flux-cluster/nginx.yml\n    strategy: Setters\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위 구성에서는 아래 구성 요소를 정의했습니다:\n\n- Secret: 우리는 gitlab 설정 섹션에서 만든 base64로 인코딩된 pat 토큰 및 gitlab의 git repo에 대한 사용자 이름을 정의했습니다. 사용자 이름은 terraform의 provider 섹션 구성에 따라 'git'을 사용했습니다.\n- GitRepository: 이는 flux가 yaml 파일을 폴링할 gitlab 리포지토리 URL입니다. 이는 gitlab 설정 섹션에서 만든 파일입니다.\n- ImageRepository: 특정 태그 집합을 스캔하고 저장할 리포지토리를 정의했습니다.\n- ImagePolicy: 이미지 리포지토리에서 \"latest\" 이미지를 선택하는 규칙을 정의합니다.\n- ImageUpdateAutomation: 동일한 네임스페이스 내의 이미지 정책 객체를 기반으로 git 리포지토리를 업데이트할 자동화 프로세스를 정의합니다.\n\nImageUpdateAutomation 아래 파일에서, flux가 이미지 태그를 업데이트할 경로를 .spec.update.path 아래 ./clusters/flux-cluster/nginx.yml로 정의했습니다. 이것은 flux에 이미지 태그를 업데이트할 위치를 알려줍니다.\n\n위 구성 이후에는 또한 ecr 동기화 파일을 정의해야 합니다. 이 파일은 ecr에 대한 인증을 자동화하고 이미지 자동화 컨트롤러가 ecr 리포지토리에서 이미지 태그를 가져올 수 있도록 합니다. 아래 파일은 매 6시간마다 ecr에서 인증하는 데 필요한 권한을 가진 크론 작업을 설정하고 비밀 정보를 업데이트합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```yaml\nkind: Role\napiVersion: rbac.authorization.k8s.io/v1\nmetadata:\n  name: ecr-credentials-sync\n  namespace: flux-system\nrules:\n  - apiGroups: [\"\"]\n    resources:\n      - secrets\n    verbs:\n      - get\n      - create\n      - patch\n---\nkind: RoleBinding\napiVersion: rbac.authorization.k8s.io/v1\nmetadata:\n  name: ecr-credentials-sync\n  namespace: flux-system\nsubjects:\n  - kind: ServiceAccount\n    name: ecr-credentials-sync\nroleRef:\n  kind: Role\n  name: ecr-credentials-sync\n  apiGroup: \"\"\n---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: ecr-credentials-sync\n  namespace: flux-system\n  # Uncomment and edit if using IRSA\n  # annotations:\n  #   eks.amazonaws.com/role-arn: <role arn>\n---\napiVersion: batch/v1\nkind: CronJob\nmetadata:\n  name: ecr-credentials-sync\n  namespace: flux-system\nspec:\n  suspend: false\n  schedule: 0 */6 * * *\n  failedJobsHistoryLimit: 1\n  successfulJobsHistoryLimit: 1\n  jobTemplate:\n    spec:\n      template:\n        spec:\n          serviceAccountName: ecr-credentials-sync\n          restartPolicy: Never\n          volumes:\n            - name: token\n              emptyDir:\n                medium: Memory\n          initContainers:\n            - image: amazon/aws-cli\n              name: get-token\n              imagePullPolicy: IfNotPresent\n              # You will need to set the AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY environment variables if not using\n              # IRSA. It is recommended to store the values in a Secret and load them in the container using envFrom.\n              # envFrom:\n              # - secretRef:\n              #     name: aws-credentials\n              env:\n                - name: REGION\n                  value: us-east-1 # change this if ECR repo is in a different region\n              volumeMounts:\n                - mountPath: /token\n                  name: token\n              command:\n                - /bin/sh\n                - -ce\n                - aws ecr get-login-password --region ${REGION} > /token/ecr-token\n          containers:\n            - image: ghcr.io/fluxcd/flux-cli:v0.25.2\n              name: create-secret\n              imagePullPolicy: IfNotPresent\n              env:\n                - name: SECRET_NAME\n                  value: ecr-credentials\n                - name: ECR_REGISTRY\n                  value: <account id>.dkr.ecr.<region>.amazonaws.com # fill in the account id and region\n              volumeMounts:\n                - mountPath: /token\n                  name: token\n              command:\n                - /bin/sh\n                - -ce\n                - |-\n                  kubectl create secret docker-registry $SECRET_NAME \\\n                    --dry-run=client \\\n                    --docker-server=\"$ECR_REGISTRY\" \\\n                    --docker-username=AWS \\\n                    --docker-password=\"$(cat /token/ecr-token)\" \\\n                    -o yaml | kubectl apply -f -\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 1\n  template:\n    spec:\n      containers:\n        - name: nginx\n          image: <aws-account-id>.dkr.ecr.<aws-region>.amazonaws.com/nginx:0.0.0 # {\"$imagepolicy\": \"flux-system:nginx\"}\n```\n\n위의 두 줄 # '\"$imagepolicy\": \"flux-system:nginx\"' 는 flux-system이 네임스페이스이고 nginx가 이미지 정책의 이름임을 나타내는 표식입니다. 이는 app-nginx.yml 파일에서 정의된 자동화 구성과 일치해야 합니다.\n\n이 작은 단편은 flux에게 컨테이너 이미지를 업데이트할 때 사용해야 하는 정책을 알려줍니다.\n\n이 모든 파일은 이것을 적용하기 위해 flux 폴더로 복사되어 메인.tf 파일의 아래 코드 단편을 통해 eks 클러스터에 적용될 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nlocals {\n  yaml_files = fileset(\"${path.module}/config_files\", \"*.yml\")\n  yaml_content = { for file in local.yaml_files : file => file(\"${path.module}/config_files/${file}\") }\n}\nresource \"gitlab_repository_file\" \"yaml_files\" {\n  depends_on = [flux_bootstrap_git.this, null_resource.update_kubeconfig]\n  for_each = local.yaml_content\n  project = data.gitlab_project.this.id // Use the project ID of an existing project or gitlab_project.example_project.id if you created a new project\n  file_path = \"clusters/${module.eks.cluster_name}/${each.key}\"\n  content   = base64encode(each.value)\n  commit_message = \"added flux image configs\"\n  branch    = \"main\"\n}\n```\n\n# 배포:\n\n그 다음 아래 명령어를 실행하여 Terraform 초기화를 수행하십시오.\n\n```js\nterraform init\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그럼 진행되는 모든 리소스를 확인하려면 plan 명령어를 실행해주세요.\n\n```js\nterraform plan\n```\n\n그 다음에는 테라폼 설정을 적용할 수 있어요.\n\n```js\nterraform apply --auto-approve\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래 Terraform이 다음 작업을 수행할 것입니다.\n\n```js\nVPC 및 지원 리소스 생성\nEKS 클러스터 및 지원 리소스 생성\nEKS와 함께 Flux를 부트스트랩하고 모든 구성 및 애플리케이션 파일을 GitLab 저장소에 저장\n```\n\nTerraform 실행이 완료되면 아래 명령을 실행하세요.\n\n```js\nkubectl get po -n flux-system\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래의 Flux 구성 요소가 모두 실행 중인 것을 확인해야 합니다.\n\n```js\nNAME                                           READY   STATUS    RESTARTS   AGE\nhelm-controller-5f7457c9dd-6svk8               1/1     Running   0          40s\nimage-automation-controller-79447887bb-blqp4   1/1     Running   0          40s\nimage-reflector-controller-65df777f5c-nrgsx    1/1     Running   0          40s\nkustomize-controller-5f58d55f76-tpgs6          1/1     Running   0          40s\nnotification-controller-685bdc466d-mp46f       1/1     Running   0          40s\nsource-controller-86b8b57796-vl2fp             1/1     Running   0          39s\n```\n\n이제 모든 구성 요소가 실행 중이므로, ecr 비밀 cron 작업이 실행되었는지 확인해보겠습니다. 터미널에서 다음 명령을 실행하세요.\n\n```js\nkubectl get cronjob -n flux-system\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래 출력을 얻어야 합니다.\n\n```js\nNAME                   SCHEDULE      SUSPEND   ACTIVE   LAST SCHEDULE   AGE\necr-credentials-sync   0/1 * * * *   False     0        51초           2분 42초\n```\n\n이제 flux-system 네임스페이스에 시크릿이 있는지 확인해 보겠습니다. 아래 출력이 표시되어야 합니다:\n\n```js\nk get secret -n flux-system\n\nNAME              TYPE                             DATA   AGE\necr-credentials   kubernetes.io/dockerconfigjson   1      3분 7초\nflux-system       Opaque                           3      5분 39초\nnginx-auth-pat    Opaque                           2      4분 19초\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 출력에서 확인할 수 있듯이 ecr-credentials라는 시크릿이 있습니다.\n\n이제 ecr을 확인해 봅시다.\n\n이제 flux 이미지 컨트롤러가 우리의 ecr 저장소에서 태그를 가져올 수 있는지 확인해 보겠습니다.\n\n```js\nflux get image all\nNAME                   LAST SCAN                       SUSPENDED       READY   MESSAGE\nimagerepository/nginx   2024-05-23T16:55:46+05:30       False           True    successful scan: found 2 tags\nNAME                    LATEST IMAGE                                                    READY   MESSAGE\nimagepolicy/nginx       <aws-account-id>.dkr.ecr.<aws-region>.amazonaws.com/nginx:0.0.1       True    '<aws-account-id>.dkr.ecr.<aws-region>.amazonaws.com/nginx'의 최신 이미지 태그가 0.0.1로 해결되었습니다\nNAME                            LAST RUN                        SUSPENDED       READY   MESSAGE\nimageupdateautomation/nginx     2024-05-23T16:55:39+05:30       False           True    레포지토리가 최신 상태입니다\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 출력에서 볼 수 있듯이, 이미지 정책은 ECR에서 최신 이미지 태그를 스캔하고 가져왔습니다.\n\n이제 아래 명령을 사용하여 배포에 동일한 업데이트가 반영되었는지 확인해봅시다:\n\n```js\nkubectl get deployment nginx-deployment -o=jsonpath='{.spec.template.spec.containers[*].image}' | awk -F '[:@]' '{print $1, $2}'\n```\n\n아래는 우리가 얻은 출력입니다. 이미지가 업데이트된 것을 확인할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n<aws-account-id>.dkr.ecr.<aws-region>.amazonaws.com/nginx:0.0.1\n```\n\n이제 깃랩 쪽으로 이동하여 플럭스가 필요한 변경 사항을 수행했는지 확인해보세요.\n\nUI를 통해 레포지토리의 커밋 히스토리를 확인하거나 레포지토리를 복제한 후 아래 명령어를 실행할 수 있습니다.\n\n아래 명렁어를 실행해보세요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```bash\ngit log --author=\"flux\" --since=\"today 00:00\" --until=\"today 23:59\" --pretty=format:\"%h %s\" -- clusters/flux-cluster/nginx.yml\n```\n\n아래는 출력된 내용입니다:\n\n```bash\n85e5b48 <aws-account-d>.dkr.ecr.<aws-region>.amazonaws.com/nginx:0.0.1\n```\n\n위의 출력에서 확인할 수 있듯이 flux가 nginx.yml 파일에서 임의의 이미지 번호에서 실제 태그로 이미지를 업데이트했으며, 동일한 업데이트가 배포에서 수행되었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이미지의 새로운 버전을 푸시해보고 flux가 자동으로 업데이트되는지 확인해봐요.\n\nECR 저장소에 Nginx 이미지를 태그해보세요.\n\n```js\ndocker tag nginx:latest <aws_account_id>.dkr.ecr.<region>.amazonaws.com/nginx-repo:0.0.2\n```\n\n이제 아래 명령어를 사용하여 배포가 정상적으로 업데이트되었는지 확인해보세요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 표시되는 출력 값 입니다:\n\n```bash\n<aws-account-id>.dkr.ecr.<aws-region>.amazonaws.com/nginx:0.0.2\n```\n\n# 결론\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그래서 결론적으로, 우리는 flux, gitlab, terraform, kubernetes를 사용하여 gitops 워크플로우를 설정했고, 새 이미지를 컨테이너 저장소에 푸시할 때마다 flux가 배포를 관리할 것입니다.\n\n# 참고 자료:\n\nFlux 문서: [https://fluxcd.io/flux/](https://fluxcd.io/flux/)\n","ogImage":{"url":"/assets/img/2024-05-27-GitOpswithKubernetesTerraformGitlabandFluxCD_0.png"},"coverImage":"/assets/img/2024-05-27-GitOpswithKubernetesTerraformGitlabandFluxCD_0.png","tag":["Tech"],"readingTime":30},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<h1>소개:</h1>\n<p>이 블로그 포스트에서는 테라폼, gitlab, fluxcd 및 kustomize를 사용하여 엔드 투 엔드 gitops 워크플로를 설계하는 방법에 대해 논의하려고 합니다.</p>\n<p>그러나 구현 세부 정보에 대해 깊이 파고들기 전에, gitops가 다루는 문제 설명과 테라폼이 어떻게 관련되는지에 대해 이해해 봅시다.</p>\n<p></p>\n<h1>GitOps의 무엇과 왜</h1>\n<p>현재 우리가 인프라를 구축하는 방식을 살펴보면 대부분의 경우 인프라를 코드로 구축하거나 적어도 대부분의 클라우드 인프라가 그러한 방식으로 구축됩니다. 인프라를 코드로 사용하는 것의 하나의 어려움은 코드베이스가 성장하고 더 많은 사람들이 개발 프로세스에 참여함에 따라 코드베이스를 유지하는 것이 어려워진다는 것입니다.</p>\n<p>이것이 바로 gitops가 나타나는 곳입니다. 핵심적으로 gitops는 git을 활용하여 인프라 코드의 코드 베이스를 유지하고 설정을 대상 환경에 자동으로 매칭하는 방식을 사용합니다. 이러한 방식으로 우리는 이전보다 빠르게 배포할 수 있을 뿐만 아니라 시간이 지남에 따라 무엇이 변경되었는지 완전한 기록이 있기 때문에 이전보다 빨리 오류를 감지하고 복구할 수 있습니다.</p>\n<h1>GitOps에 대한 Terraform 선택이유</h1>\n<p></p>\n<p>지금쯤이면 terraform이 어떻게 관련되며 어떻게 도움이 되는지 궁금해할 수 있습니다. 이전 섹션에서는 구성을 매치하는 자동화된 방법에 대해 이야기했습니다. 일반적인 Kubernetes 환경에서는 fluxcd와 같은 도구를 사용하여 이를 수행합니다. 그러나 이러한 추가 구성과 설정이 필요합니다. 여기서 terraform이 등장합니다. terraform을 사용하면 인프라를 구축할 뿐만 아니라 flux와 같은 도구를 설치하고 구성할 수도 있습니다. 이렇게 하면 한 번에 Kubernetes 클러스터를 구축하고 flux를 부트스트랩하며 그에 따라 gitops 워크플로우를 설정할 수 있습니다. 이렇게 하면 처음부터 완전히 기능적인 gitops 워크플로우가 구축됩니다.</p>\n<h2>도구 개요:</h2>\n<h2>FluxCD:</h2>\n<p>Flux는 Kubernetes 클러스터를 구성 소스(예: Git 저장소)와 동기화하고 새 코드를 배포할 때 구성을 자동으로 업데이트하는 도구입니다.</p>\n<p></p>\n<h1>Gitlab:</h1>\n<p>GitLab은 응용 프로그램 빌드 및 릴리스 프로세스를 자동화하는 데 도움이되는 CI/CD 도구입니다.</p>\n<h1>Terraform:</h1>\n<p>Terraform을 사용하면 선언적 구성 언어를 사용하여 가상 머신, 네트워크, 저장소 및 기타 클라우드 서비스와 같은 인프라 리소스를 정의하고 프로비저닝할 수 있습니다.</p>\n<p></p>\n<h1>우리가 만들 것:</h1>\n<p>해결책에서는 nginx 앱을 eks 클러스터에 배포하고, flux를 사용하여 eks 클러스터에 대한 배포를 관리하며, 인프라 프로비저닝 및 flux 부트스트랩 구성을 위해 terraform을 사용합니다.</p>\n<h1>설정</h1>\n<h1>준비 사항:</h1>\n<p></p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-number\">1</span>) <span class=\"hljs-variable constant_\">AWS</span> 계정\n<span class=\"hljs-number\">2</span>) <span class=\"hljs-title class_\">Gitlab</span> 클라우드 계정 / 자체 호스팅된 <span class=\"hljs-title class_\">Gitlab</span>\n<span class=\"hljs-number\">3</span>) 로컬 시스템에 설치된 최신 버전의 <span class=\"hljs-title class_\">Terraform</span>\n\n# 환경 설정:\n\n## <span class=\"hljs-variable constant_\">AWS</span> 설정:\n\n<span class=\"hljs-variable constant_\">ECR</span> <span class=\"hljs-title class_\">Repository</span> 생성\n</code></pre>\n<p></p>\n<p>AWS ECR 레지스트리에 로그인합니다.</p>\n<pre><code class=\"hljs language-bash\">aws ecr get-login-password | docker login --username AWS --password-stdin &#x3C;aws_account_id>.dkr.ecr.&#x3C;region>.amazonaws.com\n</code></pre>\n<p>Docker Hub에서 Nginx 이미지를 가져옵니다.</p>\n<p></p>\n<pre><code class=\"hljs language-js\">도커 pull <span class=\"hljs-attr\">nginx</span>:latest\n</code></pre>\n<p>당신의 ECR 저장소에 Nginx 이미지를 태그하기</p>\n<pre><code class=\"hljs language-js\">도커 tag <span class=\"hljs-attr\">nginx</span>:latest &#x3C;aws_account_id>.<span class=\"hljs-property\">dkr</span>.<span class=\"hljs-property\">ecr</span>.&#x3C;region>.<span class=\"hljs-property\">amazonaws</span>.<span class=\"hljs-property\">com</span>/nginx-<span class=\"hljs-attr\">repo</span>:<span class=\"hljs-number\">0.0</span><span class=\"hljs-number\">.1</span>\n</code></pre>\n<p>이미지를 ECR 저장소에 푸시하기</p>\n<p></p>\n<pre><code class=\"hljs language-js\">도커 푸시 &#x3C;aws_account_id>.<span class=\"hljs-property\">dkr</span>.<span class=\"hljs-property\">ecr</span>.&#x3C;region>.<span class=\"hljs-property\">amazonaws</span>.<span class=\"hljs-property\">com</span>/nginx-<span class=\"hljs-attr\">repo</span>:<span class=\"hljs-number\">0.0</span><span class=\"hljs-number\">.1</span>\n</code></pre>\n<h2>Gitlab 설정</h2>\n<p>PAT 토큰 생성</p>\n<pre><code class=\"hljs language-js\">- <span class=\"hljs-title class_\">GitLab</span> 인스턴스에 로그인하세요\n- 프로필 아이콘을 클릭하세요\n- 환경설정을 클릭한 후에 접근 토큰을 클릭하세요\n- 토큰의 이름을 입력하고 만료 날짜를 설정하세요\n- 그 다음에 api 라는 scopes 아래의 첫 번째 확인란을 선택하세요\n- 개인 접근 토큰 만들기를 클릭한 후에 토큰을 표시하세요\n- 토큰을 저장하세요.\n</code></pre>\n<p></p>\n<p>프로젝트 설정:</p>\n<pre><code class=\"hljs language-js\">- gitlab의 클라우드 인스턴스에서 새 프로젝트 버튼을 클릭합니다.\n- 빈 프로젝트 생성을 클릭합니다.\n- 프로젝트 이름을 제공합니다 (나중에 사용할 이름을 메모해 둡니다).\n- 프로젝트 <span class=\"hljs-variable constant_\">URL</span> 옆의 드롭 다운에서 그룹 이름을 선택하고,\n   이 그룹 이름을 나중에 사용할 것이니 메모해 둡니다.\n- 프로젝트를 위한 이름을 제공합니다.\n- 가시성을 선택합니다.\n- 프로젝트를 저장합니다.\n- 코드 버튼을 클릭하고, https용 github <span class=\"hljs-variable constant_\">URL</span>을 복사하여\n  나중에 필요할 때를 대비하여 <span class=\"hljs-variable constant_\">URL</span>을 메모해 둡니다.\n</code></pre>\n<h2>Terraform 설정</h2>\n<p>Terraform 구성 및 스니펫을 사용하여 인프라를 구축하기 전에 아래 명령어를 사용하여 AWS 자격 증명을 설정해야 합니다.</p>\n<p></p>\n<p>AWS 자격 증명 설정</p>\n<pre><code class=\"hljs language-js\">% <span class=\"hljs-keyword\">export</span> <span class=\"hljs-variable constant_\">AWS_ACCESS_KEY_ID</span>=<span class=\"hljs-string\">\"anaccesskey\"</span>\n% <span class=\"hljs-keyword\">export</span> <span class=\"hljs-variable constant_\">AWS_SECRET_ACCESS_KEY</span>=<span class=\"hljs-string\">\"asecretkey\"</span>\n% <span class=\"hljs-keyword\">export</span> <span class=\"hljs-variable constant_\">AWS_REGION</span>=<span class=\"hljs-string\">\"us-west-2\"</span>\n</code></pre>\n<p>위 설정을 완료한 후 로컬 환경에서 gitlab 토큰을 설정해야 합니다. 아래 섹션에서 그 방법을 안내하겠습니다. gitlab 설정 섹션에서 pat 토큰 섹션에서 복사한 토큰을 붙여넣어주세요.</p>\n<p>GitLab 토큰 설정 (Linux/MacOS)</p>\n<p></p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-variable constant_\">GITLAB_TOKEN</span>=<span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">Gitlab</span> <span class=\"hljs-attr\">설정에서</span> <span class=\"hljs-attr\">저장한</span> <span class=\"hljs-attr\">토큰</span>></span>\n</span></code></pre>\n<p>Windows</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-attr\">$env</span>: <span class=\"hljs-variable constant_\">GITLAB_TOKEN</span> = <span class=\"hljs-string\">\"&#x3C;Gitlab 설정에서 저장한 토큰>\"</span>;\n</code></pre>\n<h1>안내:</h1>\n<p></p>\n<h1>데모 레포지토리 복제</h1>\n<pre><code class=\"hljs language-js\">git clone <span class=\"hljs-attr\">https</span>:<span class=\"hljs-comment\">//gitlab.com/devops5480719/devops-samples.git</span>\n</code></pre>\n<p>그런 다음 인프라 디렉토리로 이동하세요</p>\n<pre><code class=\"hljs language-js\">cd devops-samples/gitops-gitlab/infra/\n</code></pre>\n<p></p>\n<p>디렉토리 안으로 들어가시면 아래의 파일과 폴더를 찾을 수 있어요.</p>\n<pre><code class=\"hljs language-js\">├── config_files\n│   ├── app-nginx.<span class=\"hljs-property\">yml</span>\n│   ├── ecr-sync.<span class=\"hljs-property\">yml</span>\n│   └── nginx.<span class=\"hljs-property\">yml</span>\n├── main.<span class=\"hljs-property\">tf</span>\n├── variables.<span class=\"hljs-property\">tf</span>\n└── versions.<span class=\"hljs-property\">tf</span>\n</code></pre>\n<p>안에 config_files라는 폴더가 있고, 몇 개의 terraform 파일도 있어요.</p>\n<p>우선 terraform 파일들을 자세히 살펴보도록 해봐요.</p>\n<p></p>\n<h2>변수 구성</h2>\n<p>먼저 변수 구성을 살펴봅시다.</p>\n<p>variables.tf</p>\n<pre><code class=\"hljs language-js\">variable <span class=\"hljs-string\">\"gitlab_group\"</span> {\n  type = string\n  <span class=\"hljs-keyword\">default</span> = &#x3C;gitlab 그룹의 이름>\n}\n\nvariable \"gitlab_project\" {\n  type = string\n  default = &#x3C;gitlab 프로젝트의 이름>\n}\n\nvariable \"aws_region\" {\n  type = string\n  default = &#x3C;리소스를 배포할 AWS 지역의 이름>\n}\n</code></pre>\n<p></p>\n<p>위 코드 조각에서 기본 값 대신에 gitlab 섹션에서 이전에 복사한 이름이있는 gitlab_group으로 대체하십시오. gitlab_project에 대해서도 마찬가지입니다.</p>\n<p>aws_region으로는 리소스를 배포할 지역을 선택하십시오.</p>\n<h2>공급자 구성</h2>\n<p>이제 versions.tf 파일에서 공급자 구성을 살펴봅시다.</p>\n<p></p>\n<p>변수.tf 파일에는 인증 및 권한 부여를 위한 각 프로바이더 블록의 필수 구성 및 필수 제공자가 포함되어 있습니다.</p>\n<p>버전.tf</p>\n<pre><code class=\"hljs language-js\">required_providers {\n    flux = {\n      source  = <span class=\"hljs-string\">\"fluxcd/flux\"</span>\n      version = <span class=\"hljs-string\">\">= 1.0.0\"</span>\n    }\n    gitlab = {\n      source  = <span class=\"hljs-string\">\"gitlabhq/gitlab\"</span>\n      version = <span class=\"hljs-string\">\">=15.10.0\"</span>\n    }\n    aws = {\n      source  = <span class=\"hljs-string\">\"hashicorp/aws\"</span>\n      version = <span class=\"hljs-string\">\">= 5.0\"</span>\n    }\n    kubernetes = {\n      source  = <span class=\"hljs-string\">\"hashicorp/kubernetes\"</span>\n      version = <span class=\"hljs-string\">\">= 2.16.1\"</span>\n    }\n  }\n}\nprovider <span class=\"hljs-string\">\"gitlab\"</span> {\n  base_url = <span class=\"hljs-string\">\"https://gitlab.com/api/v4/\"</span>\n}\nprovider <span class=\"hljs-string\">\"flux\"</span> {\n  kubernetes = {\n    host                   = <span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">eks</span>.<span class=\"hljs-property\">endpoint</span>\n    cluster_ca_certificate = <span class=\"hljs-title function_\">base64decode</span>(<span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">eks</span>.<span class=\"hljs-property\">cluster_ca_certificate</span>)\n    exec = {\n      api_version = <span class=\"hljs-string\">\"client.authentication.k8s.io/v1beta1\"</span>\n      args        = [<span class=\"hljs-string\">\"eks\"</span>, <span class=\"hljs-string\">\"get-token\"</span>, <span class=\"hljs-string\">\"--cluster-name\"</span>, <span class=\"hljs-keyword\">var</span>.<span class=\"hljs-property\">cluster_name</span>]\n      command     = <span class=\"hljs-string\">\"aws\"</span>\n    }\n  }\n  git = {\n    url = <span class=\"hljs-string\">\"ssh://git@gitlab.com/${data.gitlab_project.this.path_with_namespace}.git\"</span>\n    ssh = {\n      username    = <span class=\"hljs-string\">\"git\"</span>\n      private_key = tls_private_key.<span class=\"hljs-property\">flux</span>.<span class=\"hljs-property\">private_key_pem</span>\n    }\n    branch = <span class=\"hljs-string\">\"main\"</span>\n  }\n}\n</code></pre>\n<h2>리소스 구성:</h2>\n<p></p>\n<p>자원 구성을 살펴보겠습니다.</p>\n<p>VPC 구성</p>\n<p>main.tf</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable language_\">module</span> <span class=\"hljs-string\">\"vpc\"</span> {\n  source = <span class=\"hljs-string\">\"terraform-aws-modules/vpc/aws\"</span>\n  name = <span class=\"hljs-string\">\"flux-vpc\"</span>\n  cidr = <span class=\"hljs-string\">\"10.0.0.0/16\"</span>\n  azs = [<span class=\"hljs-string\">\"&#x3C;aws-region>a\"</span>, <span class=\"hljs-string\">\"&#x3C;aws-region>b\"</span>, <span class=\"hljs-string\">\"&#x3C;aws-region>c\"</span>]\n  private_subnets = [<span class=\"hljs-string\">\"10.0.1.0/24\"</span>, <span class=\"hljs-string\">\"10.0.2.0/24\"</span>, <span class=\"hljs-string\">\"10.0.3.0/24\"</span>, <span class=\"hljs-string\">\"10.0.4.0/24\"</span>, <span class=\"hljs-string\">\"10.0.5.0/24\"</span>, <span class=\"hljs-string\">\"10.0.6.0/24\"</span>]\n  public_subnets = [<span class=\"hljs-string\">\"10.0.101.0/24\"</span>, <span class=\"hljs-string\">\"10.0.102.0/24\"</span>, <span class=\"hljs-string\">\"10.0.103.0/24\"</span>]\n  enable_nat_gateway = <span class=\"hljs-literal\">true</span>\n  enable_vpn_gateway = <span class=\"hljs-literal\">false</span>\n  single_nat_gateway = <span class=\"hljs-literal\">true</span>\n  public_subnet_tags = {\n    <span class=\"hljs-string\">\"kubernetes.io/role/elb\"</span> = <span class=\"hljs-string\">\"1\"</span>\n  }\n  tags = {\n    <span class=\"hljs-title class_\">Terraform</span> = <span class=\"hljs-string\">\"true\"</span>\n    <span class=\"hljs-title class_\">Environment</span> = <span class=\"hljs-string\">\"dev\"</span>\n  }\n}\n</code></pre>\n<p></p>\n<p>EKS 구성</p>\n<p>EKS를 위해 아래 리소스를 정의할 것입니다.</p>\n<ul>\n<li>EKS 클러스터</li>\n<li>kubeconfig를 컨텍스트에 추가하기 위한 Null 리소스</li>\n</ul>\n<p>main.tf</p>\n<p></p>\n<p>모듈 \"eks\" {\nsource = \"terraform-aws-modules/eks/aws\"\nversion = \"~> 20.0\"\ncluster_name = \"flux-cluster\"\ncluster_version = \"1.29\"\ncluster_endpoint_private_access = true\ncluster_endpoint_public_access = true\ncloudwatch_log_group_retention_in_days = 7\ncloudwatch_log_group_class = \"INFREQUENT_ACCESS\"\ncluster_enabled_log_types = [\"api\"]\nvpc_id = module.vpc.vpc_id\nsubnet_ids = module.vpc.private_subnets\ncluster_addons = {\ncoredns = {\nmost_recent = true\n}\nkube-proxy = {\nmost_recent = true\n}\naws-ebs-csi-driver = {\nmost_recent = true\n}\neks-pod-identity-agent = {\nmost_recent = true\n}\nvpc-cni = {\nmost_recent = true\n}\n}\neks_managed_node_group_defaults = {\nami_type = \"AL2_x86_64\"\ndisk_size = 50\ninstance_types = [\"t3.large\"]\ncapacity_type = \"SPOT\"\nupdate_config = {\nmax_unavailable_percentage = 100\n}\n}\neks_managed_node_groups = {\nps-cluster-sample = {\nmin_size = 1\ndesired_size = 1\nmax_size = 4\ninstance_types = [\"t3.large\"]\ncapacity_type = \"SPOT\"\n}\n}\nenable_cluster_creator_admin_permissions = false\naccess_entries = {\nadmin_sso = {\nkubernetes_groups = []\nprincipal_arn = \"\"\npolicy_associations = {\nClusterAdmin = {\npolicy_arn = \"arn:aws:eks::aws:cluster-access-policy/AmazonEKSClusterAdminPolicy\"\naccess_scope = {\ntype = \"cluster\"\n}\n}\nEKSAdmin = {\npolicy_arn = \"arn:aws:eks::aws:cluster-access-policy/AmazonEKSAdminPolicy\"\naccess_scope = {\ntype = \"cluster\"\n}\n}\n}\n}\n}\n}\nresource \"null_resource\" \"update_kubeconfig\" {\ntriggers = {\neks_cluster_id = module.eks.cluster_id\n}\nprovisioner \"local-exec\" {\ncommand = \"aws eks update-kubeconfig --name ${module.eks.cluster_name} --region ${var.aws_region}\"\n}\n}</p>\n<p></p>\n<pre><code class=\"hljs language-js\">자바스크립트\n리소스 <span class=\"hljs-string\">\"tls_private_key\"</span> <span class=\"hljs-string\">\"flux\"</span> {\n  depends_on = [<span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">eks</span>, <span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">vpc</span>, null_resource.<span class=\"hljs-property\">update_kubeconfig</span>]\n  algorithm   = <span class=\"hljs-string\">\"ECDSA\"</span>\n  ecdsa_curve = <span class=\"hljs-string\">\"P256\"</span>\n}\n데이터 <span class=\"hljs-string\">\"gitlab_project\"</span> <span class=\"hljs-string\">\"this\"</span> {\n  path_with_namespace = <span class=\"hljs-string\">\"${var.gitlab_group}/${var.gitlab_project}\"</span>\n}\n리소스 <span class=\"hljs-string\">\"gitlab_deploy_key\"</span> <span class=\"hljs-string\">\"this\"</span> {\n  depends_on = [<span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">eks</span>, <span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">vpc</span>]\n  project  = data.<span class=\"hljs-property\">gitlab_project</span>.<span class=\"hljs-property\">this</span>.<span class=\"hljs-property\">id</span>\n  title    = <span class=\"hljs-string\">\"Flux\"</span>\n  key      = tls_private_key.<span class=\"hljs-property\">flux</span>.<span class=\"hljs-property\">public_key_openssh</span>\n  can_push = <span class=\"hljs-literal\">true</span>\n}\n리소스 <span class=\"hljs-string\">\"flux_bootstrap_git\"</span> <span class=\"hljs-string\">\"this\"</span> {\n  depends_on = [gitlab_deploy_key.<span class=\"hljs-property\">this</span>, <span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">eks</span>, <span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">vpc</span>, null_resource.<span class=\"hljs-property\">update_kubeconfig</span>]\n  path = <span class=\"hljs-string\">\"clusters/${module.eks.cluster_name}\"</span>\n  components_extra = [<span class=\"hljs-string\">\"image-reflector-controller\"</span>,<span class=\"hljs-string\">\"image-automation-controller\"</span>]\n}\n로컬 {\n  yaml_files = <span class=\"hljs-title function_\">fileset</span>(<span class=\"hljs-string\">\"${path.module}/config_files\"</span>, <span class=\"hljs-string\">\"*.yml\"</span>)\n  yaml_content = { <span class=\"hljs-keyword\">for</span> file <span class=\"hljs-keyword\">in</span> local.<span class=\"hljs-property\">yaml_files</span> : <span class=\"hljs-function\"><span class=\"hljs-params\">file</span> =></span> <span class=\"hljs-title function_\">file</span>(<span class=\"hljs-string\">\"${path.module}/config_files/${file}\"</span>) }\n}\n리소스 <span class=\"hljs-string\">\"gitlab_repository_file\"</span> <span class=\"hljs-string\">\"yaml_files\"</span> {\n  depends_on = [flux_bootstrap_git.<span class=\"hljs-property\">this</span>, null_resource.<span class=\"hljs-property\">update_kubeconfig</span>]\n  for_each = local.<span class=\"hljs-property\">yaml_content</span>\n  project = data.<span class=\"hljs-property\">gitlab_project</span>.<span class=\"hljs-property\">this</span>.<span class=\"hljs-property\">id</span> <span class=\"hljs-comment\">// 새 프로젝트를 생성한 경우 기존 프로젝트나 gitlab_project.example_project.id의 프로젝트 ID를 사용하십시오.</span>\n  file_path = <span class=\"hljs-string\">\"clusters/${module.eks.cluster_name}/${each.key}\"</span>\n  content   = <span class=\"hljs-title function_\">base64encode</span>(each.<span class=\"hljs-property\">value</span>)\n  commit_message = <span class=\"hljs-string\">\"added flux image configs\"</span>\n  branch    = <span class=\"hljs-string\">\"main\"</span>\n}\n</code></pre>\n<p>위의 코드 조각에서는 flux_bootstrap_git 리소스에 image-reflector-controller 및 image-automation-controller라는 두 가지 추가 컴포넌트를 추가하고 있습니다.</p>\n<p>이 두 컨트롤러는 ECR 리포지토리에서 태그를 가져오거나 업데이트할 책임을 질 것입니다.</p>\n<p>flux가 이 작업을 수행하려면 복제 데모 리포지토리의 config_files 폴더에서 찾을 수 있는 몇 가지 추가 구성 요소를 정의해야 합니다.</p>\n<p></p>\n<p>├── config_files\n│ ├── app-nginx.yml\n│ ├── ecr-sync.yml\n│ └── nginx.yml\n├── main.tf\n├── variables.tf\n└── versions.tf</p>\n<p>이제 이 파일들 각각을 살펴보고 그 내용을 살펴보겠습니다. 우선 app-nginx.yaml 파일부터 시작해봅시다.</p>\n<p>app-nginx.yaml</p>\n<pre><code class=\"hljs language-yaml\"><span class=\"hljs-meta\">---</span>\n<span class=\"hljs-attr\">apiVersion:</span> <span class=\"hljs-string\">v1</span>\n<span class=\"hljs-attr\">kind:</span> <span class=\"hljs-string\">Secret</span>\n<span class=\"hljs-attr\">metadata:</span>\n  <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">nginx-auth-pat</span>\n  <span class=\"hljs-attr\">namespace:</span> <span class=\"hljs-string\">flux-system</span>\n<span class=\"hljs-attr\">type:</span> <span class=\"hljs-string\">Opaque</span>\n<span class=\"hljs-attr\">data:</span>\n  <span class=\"hljs-attr\">password:</span> <span class=\"hljs-string\">&#x3C;</span> <span class=\"hljs-string\">gitlab</span> <span class=\"hljs-string\">토큰을</span> <span class=\"hljs-string\">base64로</span> <span class=\"hljs-string\">인코딩</span> <span class=\"hljs-string\">된</span> <span class=\"hljs-string\">문자열</span> <span class=\"hljs-string\">>\n  username: &#x3C; 사용자 이름을 base64로 인코딩 된 문자열 >\n</span><span class=\"hljs-meta\">---</span>\n<span class=\"hljs-attr\">apiVersion:</span> <span class=\"hljs-string\">source.toolkit.fluxcd.io/v1</span>\n<span class=\"hljs-attr\">kind:</span> <span class=\"hljs-string\">GitRepository</span>\n<span class=\"hljs-attr\">metadata:</span>\n  <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">nginx</span>\n  <span class=\"hljs-attr\">namespace:</span> <span class=\"hljs-string\">flux-system</span>\n<span class=\"hljs-attr\">spec:</span>\n  <span class=\"hljs-attr\">interval:</span> <span class=\"hljs-string\">1m0s</span>\n  <span class=\"hljs-attr\">ref:</span>\n    <span class=\"hljs-attr\">branch:</span> <span class=\"hljs-string\">main</span>\n  <span class=\"hljs-attr\">url:</span> <span class=\"hljs-string\">&#x3C;gitlab_repo_url></span>\n  <span class=\"hljs-attr\">secretRef:</span>\n    <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">nginx-auth-pat</span>\n<span class=\"hljs-meta\">---</span>\n<span class=\"hljs-attr\">apiVersion:</span> <span class=\"hljs-string\">kustomize.toolkit.fluxcd.io/v1</span>\n<span class=\"hljs-attr\">kind:</span> <span class=\"hljs-string\">Kustomization</span>\n<span class=\"hljs-attr\">metadata:</span>\n  <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">nginx</span>\n  <span class=\"hljs-attr\">namespace:</span> <span class=\"hljs-string\">flux-system</span>\n<span class=\"hljs-attr\">spec:</span>\n  <span class=\"hljs-attr\">prune:</span> <span class=\"hljs-literal\">true</span>\n  <span class=\"hljs-attr\">interval:</span> <span class=\"hljs-string\">1m0s</span>\n  <span class=\"hljs-attr\">path:</span> <span class=\"hljs-string\">\"./app/nginx/environments/production\"</span>\n  <span class=\"hljs-attr\">sourceRef:</span>\n    <span class=\"hljs-attr\">kind:</span> <span class=\"hljs-string\">GitRepository</span>\n    <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">nginx</span>\n<span class=\"hljs-meta\">---</span>\n<span class=\"hljs-attr\">apiVersion:</span> <span class=\"hljs-string\">image.toolkit.fluxcd.io/v1beta2</span>\n<span class=\"hljs-attr\">kind:</span> <span class=\"hljs-string\">ImageRepository</span>\n<span class=\"hljs-attr\">metadata:</span>\n  <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">nginx</span>\n  <span class=\"hljs-attr\">namespace:</span> <span class=\"hljs-string\">flux-system</span>\n<span class=\"hljs-attr\">spec:</span>\n  <span class=\"hljs-attr\">image:</span> <span class=\"hljs-string\">&#x3C;aws-account-id>.dkr.ecr.&#x3C;region>.amazonaws.com/&#x3C;image</span> <span class=\"hljs-string\">name></span>\n  <span class=\"hljs-attr\">interval:</span> <span class=\"hljs-string\">1m0s</span>\n  <span class=\"hljs-attr\">secretRef:</span>\n    <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">ecr-credentials</span>\n<span class=\"hljs-meta\">---</span>\n<span class=\"hljs-attr\">apiVersion:</span> <span class=\"hljs-string\">image.toolkit.fluxcd.io/v1beta2</span>\n<span class=\"hljs-attr\">kind:</span> <span class=\"hljs-string\">ImagePolicy</span>\n<span class=\"hljs-attr\">metadata:</span>\n  <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">nginx</span>\n  <span class=\"hljs-attr\">namespace:</span> <span class=\"hljs-string\">flux-system</span>\n<span class=\"hljs-attr\">spec:</span>\n  <span class=\"hljs-attr\">imageRepositoryRef:</span>\n    <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">nginx</span>\n  <span class=\"hljs-attr\">policy:</span>\n    <span class=\"hljs-attr\">semver:</span>\n      <span class=\"hljs-attr\">range:</span> <span class=\"hljs-number\">0.0</span><span class=\"hljs-string\">.x</span>\n<span class=\"hljs-meta\">---</span>\n<span class=\"hljs-attr\">apiVersion:</span> <span class=\"hljs-string\">image.toolkit.fluxcd.io/v1beta1</span>\n<span class=\"hljs-attr\">kind:</span> <span class=\"hljs-string\">ImageUpdateAutomation</span>\n<span class=\"hljs-attr\">metadata:</span>\n  <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">nginx</span>\n  <span class=\"hljs-attr\">namespace:</span> <span class=\"hljs-string\">flux-system</span>\n<span class=\"hljs-attr\">spec:</span>\n  <span class=\"hljs-attr\">interval:</span> <span class=\"hljs-string\">1m0s</span>\n  <span class=\"hljs-attr\">sourceRef:</span>\n    <span class=\"hljs-attr\">kind:</span> <span class=\"hljs-string\">GitRepository</span>\n    <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">nginx</span>\n  <span class=\"hljs-attr\">git:</span>\n    <span class=\"hljs-attr\">checkout:</span>\n      <span class=\"hljs-attr\">ref:</span>\n        <span class=\"hljs-attr\">branch:</span> <span class=\"hljs-string\">main</span>\n    <span class=\"hljs-attr\">commit:</span>\n      <span class=\"hljs-attr\">author:</span>\n        <span class=\"hljs-attr\">email:</span> <span class=\"hljs-string\">flux@example.com</span>\n        <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">flux</span>\n      <span class=\"hljs-attr\">messageTemplate:</span> <span class=\"hljs-string\">\"{range .Updated.Images}{println .}{end}\"</span>\n    <span class=\"hljs-attr\">push:</span>\n      <span class=\"hljs-attr\">branch:</span> <span class=\"hljs-string\">main</span>\n  <span class=\"hljs-attr\">update:</span>\n    <span class=\"hljs-attr\">path:</span> <span class=\"hljs-string\">./clusters/flux-cluster/nginx.yml</span>\n    <span class=\"hljs-attr\">strategy:</span> <span class=\"hljs-string\">Setters</span>\n</code></pre>\n<p></p>\n<p>위 구성에서는 아래 구성 요소를 정의했습니다:</p>\n<ul>\n<li>Secret: 우리는 gitlab 설정 섹션에서 만든 base64로 인코딩된 pat 토큰 및 gitlab의 git repo에 대한 사용자 이름을 정의했습니다. 사용자 이름은 terraform의 provider 섹션 구성에 따라 'git'을 사용했습니다.</li>\n<li>GitRepository: 이는 flux가 yaml 파일을 폴링할 gitlab 리포지토리 URL입니다. 이는 gitlab 설정 섹션에서 만든 파일입니다.</li>\n<li>ImageRepository: 특정 태그 집합을 스캔하고 저장할 리포지토리를 정의했습니다.</li>\n<li>ImagePolicy: 이미지 리포지토리에서 \"latest\" 이미지를 선택하는 규칙을 정의합니다.</li>\n<li>ImageUpdateAutomation: 동일한 네임스페이스 내의 이미지 정책 객체를 기반으로 git 리포지토리를 업데이트할 자동화 프로세스를 정의합니다.</li>\n</ul>\n<p>ImageUpdateAutomation 아래 파일에서, flux가 이미지 태그를 업데이트할 경로를 .spec.update.path 아래 ./clusters/flux-cluster/nginx.yml로 정의했습니다. 이것은 flux에 이미지 태그를 업데이트할 위치를 알려줍니다.</p>\n<p>위 구성 이후에는 또한 ecr 동기화 파일을 정의해야 합니다. 이 파일은 ecr에 대한 인증을 자동화하고 이미지 자동화 컨트롤러가 ecr 리포지토리에서 이미지 태그를 가져올 수 있도록 합니다. 아래 파일은 매 6시간마다 ecr에서 인증하는 데 필요한 권한을 가진 크론 작업을 설정하고 비밀 정보를 업데이트합니다.</p>\n<p></p>\n<pre><code class=\"hljs language-yaml\"><span class=\"hljs-attr\">kind:</span> <span class=\"hljs-string\">Role</span>\n<span class=\"hljs-attr\">apiVersion:</span> <span class=\"hljs-string\">rbac.authorization.k8s.io/v1</span>\n<span class=\"hljs-attr\">metadata:</span>\n  <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">ecr-credentials-sync</span>\n  <span class=\"hljs-attr\">namespace:</span> <span class=\"hljs-string\">flux-system</span>\n<span class=\"hljs-attr\">rules:</span>\n  <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">apiGroups:</span> [<span class=\"hljs-string\">\"\"</span>]\n    <span class=\"hljs-attr\">resources:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">secrets</span>\n    <span class=\"hljs-attr\">verbs:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">get</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">create</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">patch</span>\n<span class=\"hljs-meta\">---</span>\n<span class=\"hljs-attr\">kind:</span> <span class=\"hljs-string\">RoleBinding</span>\n<span class=\"hljs-attr\">apiVersion:</span> <span class=\"hljs-string\">rbac.authorization.k8s.io/v1</span>\n<span class=\"hljs-attr\">metadata:</span>\n  <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">ecr-credentials-sync</span>\n  <span class=\"hljs-attr\">namespace:</span> <span class=\"hljs-string\">flux-system</span>\n<span class=\"hljs-attr\">subjects:</span>\n  <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">kind:</span> <span class=\"hljs-string\">ServiceAccount</span>\n    <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">ecr-credentials-sync</span>\n<span class=\"hljs-attr\">roleRef:</span>\n  <span class=\"hljs-attr\">kind:</span> <span class=\"hljs-string\">Role</span>\n  <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">ecr-credentials-sync</span>\n  <span class=\"hljs-attr\">apiGroup:</span> <span class=\"hljs-string\">\"\"</span>\n<span class=\"hljs-meta\">---</span>\n<span class=\"hljs-attr\">apiVersion:</span> <span class=\"hljs-string\">v1</span>\n<span class=\"hljs-attr\">kind:</span> <span class=\"hljs-string\">ServiceAccount</span>\n<span class=\"hljs-attr\">metadata:</span>\n  <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">ecr-credentials-sync</span>\n  <span class=\"hljs-attr\">namespace:</span> <span class=\"hljs-string\">flux-system</span>\n  <span class=\"hljs-comment\"># Uncomment and edit if using IRSA</span>\n  <span class=\"hljs-comment\"># annotations:</span>\n  <span class=\"hljs-comment\">#   eks.amazonaws.com/role-arn: &#x3C;role arn></span>\n<span class=\"hljs-meta\">---</span>\n<span class=\"hljs-attr\">apiVersion:</span> <span class=\"hljs-string\">batch/v1</span>\n<span class=\"hljs-attr\">kind:</span> <span class=\"hljs-string\">CronJob</span>\n<span class=\"hljs-attr\">metadata:</span>\n  <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">ecr-credentials-sync</span>\n  <span class=\"hljs-attr\">namespace:</span> <span class=\"hljs-string\">flux-system</span>\n<span class=\"hljs-attr\">spec:</span>\n  <span class=\"hljs-attr\">suspend:</span> <span class=\"hljs-literal\">false</span>\n  <span class=\"hljs-attr\">schedule:</span> <span class=\"hljs-number\">0</span> <span class=\"hljs-string\">*/6</span> <span class=\"hljs-string\">*</span> <span class=\"hljs-string\">*</span> <span class=\"hljs-string\">*</span>\n  <span class=\"hljs-attr\">failedJobsHistoryLimit:</span> <span class=\"hljs-number\">1</span>\n  <span class=\"hljs-attr\">successfulJobsHistoryLimit:</span> <span class=\"hljs-number\">1</span>\n  <span class=\"hljs-attr\">jobTemplate:</span>\n    <span class=\"hljs-attr\">spec:</span>\n      <span class=\"hljs-attr\">template:</span>\n        <span class=\"hljs-attr\">spec:</span>\n          <span class=\"hljs-attr\">serviceAccountName:</span> <span class=\"hljs-string\">ecr-credentials-sync</span>\n          <span class=\"hljs-attr\">restartPolicy:</span> <span class=\"hljs-string\">Never</span>\n          <span class=\"hljs-attr\">volumes:</span>\n            <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">token</span>\n              <span class=\"hljs-attr\">emptyDir:</span>\n                <span class=\"hljs-attr\">medium:</span> <span class=\"hljs-string\">Memory</span>\n          <span class=\"hljs-attr\">initContainers:</span>\n            <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">image:</span> <span class=\"hljs-string\">amazon/aws-cli</span>\n              <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">get-token</span>\n              <span class=\"hljs-attr\">imagePullPolicy:</span> <span class=\"hljs-string\">IfNotPresent</span>\n              <span class=\"hljs-comment\"># You will need to set the AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY environment variables if not using</span>\n              <span class=\"hljs-comment\"># IRSA. It is recommended to store the values in a Secret and load them in the container using envFrom.</span>\n              <span class=\"hljs-comment\"># envFrom:</span>\n              <span class=\"hljs-comment\"># - secretRef:</span>\n              <span class=\"hljs-comment\">#     name: aws-credentials</span>\n              <span class=\"hljs-attr\">env:</span>\n                <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">REGION</span>\n                  <span class=\"hljs-attr\">value:</span> <span class=\"hljs-string\">us-east-1</span> <span class=\"hljs-comment\"># change this if ECR repo is in a different region</span>\n              <span class=\"hljs-attr\">volumeMounts:</span>\n                <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">mountPath:</span> <span class=\"hljs-string\">/token</span>\n                  <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">token</span>\n              <span class=\"hljs-attr\">command:</span>\n                <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">/bin/sh</span>\n                <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">-ce</span>\n                <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">aws</span> <span class=\"hljs-string\">ecr</span> <span class=\"hljs-string\">get-login-password</span> <span class=\"hljs-string\">--region</span> <span class=\"hljs-string\">${REGION}</span> <span class=\"hljs-string\">></span> <span class=\"hljs-string\">/token/ecr-token</span>\n          <span class=\"hljs-attr\">containers:</span>\n            <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">image:</span> <span class=\"hljs-string\">ghcr.io/fluxcd/flux-cli:v0.25.2</span>\n              <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">create-secret</span>\n              <span class=\"hljs-attr\">imagePullPolicy:</span> <span class=\"hljs-string\">IfNotPresent</span>\n              <span class=\"hljs-attr\">env:</span>\n                <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">SECRET_NAME</span>\n                  <span class=\"hljs-attr\">value:</span> <span class=\"hljs-string\">ecr-credentials</span>\n                <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">ECR_REGISTRY</span>\n                  <span class=\"hljs-attr\">value:</span> <span class=\"hljs-string\">&#x3C;account</span> <span class=\"hljs-string\">id>.dkr.ecr.&#x3C;region>.amazonaws.com</span> <span class=\"hljs-comment\"># fill in the account id and region</span>\n              <span class=\"hljs-attr\">volumeMounts:</span>\n                <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">mountPath:</span> <span class=\"hljs-string\">/token</span>\n                  <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">token</span>\n              <span class=\"hljs-attr\">command:</span>\n                <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">/bin/sh</span>\n                <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">-ce</span>\n                <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">|-\n                  kubectl create secret docker-registry $SECRET_NAME \\\n                    --dry-run=client \\\n                    --docker-server=\"$ECR_REGISTRY\" \\\n                    --docker-username=AWS \\\n                    --docker-password=\"$(cat /token/ecr-token)\" \\\n                    -o yaml | kubectl apply -f -\n</span></code></pre>\n<p></p>\n<pre><code class=\"hljs language-yaml\"><span class=\"hljs-attr\">apiVersion:</span> <span class=\"hljs-string\">apps/v1</span>\n<span class=\"hljs-attr\">kind:</span> <span class=\"hljs-string\">Deployment</span>\n<span class=\"hljs-attr\">metadata:</span>\n  <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">nginx-deployment</span>\n<span class=\"hljs-attr\">spec:</span>\n  <span class=\"hljs-attr\">replicas:</span> <span class=\"hljs-number\">1</span>\n  <span class=\"hljs-attr\">template:</span>\n    <span class=\"hljs-attr\">spec:</span>\n      <span class=\"hljs-attr\">containers:</span>\n        <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">nginx</span>\n          <span class=\"hljs-attr\">image:</span> <span class=\"hljs-string\">&#x3C;aws-account-id>.dkr.ecr.&#x3C;aws-region>.amazonaws.com/nginx:0.0.0</span> <span class=\"hljs-comment\"># {\"$imagepolicy\": \"flux-system:nginx\"}</span>\n</code></pre>\n<p>위의 두 줄 # '\"$imagepolicy\": \"flux-system:nginx\"' 는 flux-system이 네임스페이스이고 nginx가 이미지 정책의 이름임을 나타내는 표식입니다. 이는 app-nginx.yml 파일에서 정의된 자동화 구성과 일치해야 합니다.</p>\n<p>이 작은 단편은 flux에게 컨테이너 이미지를 업데이트할 때 사용해야 하는 정책을 알려줍니다.</p>\n<p>이 모든 파일은 이것을 적용하기 위해 flux 폴더로 복사되어 메인.tf 파일의 아래 코드 단편을 통해 eks 클러스터에 적용될 것입니다.</p>\n<p></p>\n<pre><code class=\"hljs language-js\">locals {\n  yaml_files = <span class=\"hljs-title function_\">fileset</span>(<span class=\"hljs-string\">\"${path.module}/config_files\"</span>, <span class=\"hljs-string\">\"*.yml\"</span>)\n  yaml_content = { <span class=\"hljs-keyword\">for</span> file <span class=\"hljs-keyword\">in</span> local.<span class=\"hljs-property\">yaml_files</span> : <span class=\"hljs-function\"><span class=\"hljs-params\">file</span> =></span> <span class=\"hljs-title function_\">file</span>(<span class=\"hljs-string\">\"${path.module}/config_files/${file}\"</span>) }\n}\nresource <span class=\"hljs-string\">\"gitlab_repository_file\"</span> <span class=\"hljs-string\">\"yaml_files\"</span> {\n  depends_on = [flux_bootstrap_git.<span class=\"hljs-property\">this</span>, null_resource.<span class=\"hljs-property\">update_kubeconfig</span>]\n  for_each = local.<span class=\"hljs-property\">yaml_content</span>\n  project = data.<span class=\"hljs-property\">gitlab_project</span>.<span class=\"hljs-property\">this</span>.<span class=\"hljs-property\">id</span> <span class=\"hljs-comment\">// Use the project ID of an existing project or gitlab_project.example_project.id if you created a new project</span>\n  file_path = <span class=\"hljs-string\">\"clusters/${module.eks.cluster_name}/${each.key}\"</span>\n  content   = <span class=\"hljs-title function_\">base64encode</span>(each.<span class=\"hljs-property\">value</span>)\n  commit_message = <span class=\"hljs-string\">\"added flux image configs\"</span>\n  branch    = <span class=\"hljs-string\">\"main\"</span>\n}\n</code></pre>\n<h1>배포:</h1>\n<p>그 다음 아래 명령어를 실행하여 Terraform 초기화를 수행하십시오.</p>\n<pre><code class=\"hljs language-js\">terraform init\n</code></pre>\n<p></p>\n<p>그럼 진행되는 모든 리소스를 확인하려면 plan 명령어를 실행해주세요.</p>\n<pre><code class=\"hljs language-js\">terraform plan\n</code></pre>\n<p>그 다음에는 테라폼 설정을 적용할 수 있어요.</p>\n<pre><code class=\"hljs language-js\">terraform apply --auto-approve\n</code></pre>\n<p></p>\n<p>아래 Terraform이 다음 작업을 수행할 것입니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable constant_\">VPC</span> 및 지원 리소스 생성\n<span class=\"hljs-variable constant_\">EKS</span> 클러스터 및 지원 리소스 생성\n<span class=\"hljs-variable constant_\">EKS</span>와 함께 <span class=\"hljs-title class_\">Flux</span>를 부트스트랩하고 모든 구성 및 애플리케이션 파일을 <span class=\"hljs-title class_\">GitLab</span> 저장소에 저장\n</code></pre>\n<p>Terraform 실행이 완료되면 아래 명령을 실행하세요.</p>\n<pre><code class=\"hljs language-js\">kubectl get po -n flux-system\n</code></pre>\n<p></p>\n<p>아래의 Flux 구성 요소가 모두 실행 중인 것을 확인해야 합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable constant_\">NAME</span>                                           <span class=\"hljs-variable constant_\">READY</span>   <span class=\"hljs-variable constant_\">STATUS</span>    <span class=\"hljs-variable constant_\">RESTARTS</span>   <span class=\"hljs-variable constant_\">AGE</span>\nhelm-controller-5f7457c9dd-6svk8               <span class=\"hljs-number\">1</span>/<span class=\"hljs-number\">1</span>     <span class=\"hljs-title class_\">Running</span>   <span class=\"hljs-number\">0</span>          40s\nimage-automation-controller-79447887bb-blqp4   <span class=\"hljs-number\">1</span>/<span class=\"hljs-number\">1</span>     <span class=\"hljs-title class_\">Running</span>   <span class=\"hljs-number\">0</span>          40s\nimage-reflector-controller-65df777f5c-nrgsx    <span class=\"hljs-number\">1</span>/<span class=\"hljs-number\">1</span>     <span class=\"hljs-title class_\">Running</span>   <span class=\"hljs-number\">0</span>          40s\nkustomize-controller-5f58d55f76-tpgs6          <span class=\"hljs-number\">1</span>/<span class=\"hljs-number\">1</span>     <span class=\"hljs-title class_\">Running</span>   <span class=\"hljs-number\">0</span>          40s\nnotification-controller-685bdc466d-mp46f       <span class=\"hljs-number\">1</span>/<span class=\"hljs-number\">1</span>     <span class=\"hljs-title class_\">Running</span>   <span class=\"hljs-number\">0</span>          40s\nsource-controller-86b8b57796-vl2fp             <span class=\"hljs-number\">1</span>/<span class=\"hljs-number\">1</span>     <span class=\"hljs-title class_\">Running</span>   <span class=\"hljs-number\">0</span>          39s\n</code></pre>\n<p>이제 모든 구성 요소가 실행 중이므로, ecr 비밀 cron 작업이 실행되었는지 확인해보겠습니다. 터미널에서 다음 명령을 실행하세요.</p>\n<pre><code class=\"hljs language-js\">kubectl get cronjob -n flux-system\n</code></pre>\n<p></p>\n<p>아래 출력을 얻어야 합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable constant_\">NAME</span>                   <span class=\"hljs-variable constant_\">SCHEDULE</span>      <span class=\"hljs-variable constant_\">SUSPEND</span>   <span class=\"hljs-variable constant_\">ACTIVE</span>   <span class=\"hljs-variable constant_\">LAST</span> <span class=\"hljs-variable constant_\">SCHEDULE</span>   <span class=\"hljs-variable constant_\">AGE</span>\necr-credentials-sync   <span class=\"hljs-number\">0</span>/<span class=\"hljs-number\">1</span> * * * *   <span class=\"hljs-title class_\">False</span>     <span class=\"hljs-number\">0</span>        <span class=\"hljs-number\">51</span>초           <span class=\"hljs-number\">2</span>분 <span class=\"hljs-number\">42</span>초\n</code></pre>\n<p>이제 flux-system 네임스페이스에 시크릿이 있는지 확인해 보겠습니다. 아래 출력이 표시되어야 합니다:</p>\n<pre><code class=\"hljs language-js\">k get secret -n flux-system\n\n<span class=\"hljs-variable constant_\">NAME</span>              <span class=\"hljs-variable constant_\">TYPE</span>                             <span class=\"hljs-variable constant_\">DATA</span>   <span class=\"hljs-variable constant_\">AGE</span>\necr-credentials   kubernetes.<span class=\"hljs-property\">io</span>/dockerconfigjson   <span class=\"hljs-number\">1</span>      <span class=\"hljs-number\">3</span>분 <span class=\"hljs-number\">7</span>초\nflux-system       <span class=\"hljs-title class_\">Opaque</span>                           <span class=\"hljs-number\">3</span>      <span class=\"hljs-number\">5</span>분 <span class=\"hljs-number\">39</span>초\nnginx-auth-pat    <span class=\"hljs-title class_\">Opaque</span>                           <span class=\"hljs-number\">2</span>      <span class=\"hljs-number\">4</span>분 <span class=\"hljs-number\">19</span>초\n</code></pre>\n<p></p>\n<p>위의 출력에서 확인할 수 있듯이 ecr-credentials라는 시크릿이 있습니다.</p>\n<p>이제 ecr을 확인해 봅시다.</p>\n<p>이제 flux 이미지 컨트롤러가 우리의 ecr 저장소에서 태그를 가져올 수 있는지 확인해 보겠습니다.</p>\n<pre><code class=\"hljs language-js\">flux get image all\n<span class=\"hljs-variable constant_\">NAME</span>                   <span class=\"hljs-variable constant_\">LAST</span> <span class=\"hljs-variable constant_\">SCAN</span>                       <span class=\"hljs-variable constant_\">SUSPENDED</span>       <span class=\"hljs-variable constant_\">READY</span>   <span class=\"hljs-variable constant_\">MESSAGE</span>\nimagerepository/nginx   <span class=\"hljs-number\">2024</span>-<span class=\"hljs-number\">05</span>-23<span class=\"hljs-attr\">T16</span>:<span class=\"hljs-number\">55</span>:<span class=\"hljs-number\">46</span>+<span class=\"hljs-number\">05</span>:<span class=\"hljs-number\">30</span>       <span class=\"hljs-title class_\">False</span>           <span class=\"hljs-title class_\">True</span>    successful <span class=\"hljs-attr\">scan</span>: found <span class=\"hljs-number\">2</span> tags\n<span class=\"hljs-variable constant_\">NAME</span>                    <span class=\"hljs-variable constant_\">LATEST</span> <span class=\"hljs-variable constant_\">IMAGE</span>                                                    <span class=\"hljs-variable constant_\">READY</span>   <span class=\"hljs-variable constant_\">MESSAGE</span>\nimagepolicy/nginx       &#x3C;aws-account-id>.<span class=\"hljs-property\">dkr</span>.<span class=\"hljs-property\">ecr</span>.&#x3C;aws-region>.<span class=\"hljs-property\">amazonaws</span>.<span class=\"hljs-property\">com</span>/<span class=\"hljs-attr\">nginx</span>:<span class=\"hljs-number\">0.0</span><span class=\"hljs-number\">.1</span>       <span class=\"hljs-title class_\">True</span>    <span class=\"hljs-string\">'&#x3C;aws-account-id>.dkr.ecr.&#x3C;aws-region>.amazonaws.com/nginx'</span>의 최신 이미지 태그가 <span class=\"hljs-number\">0.0</span><span class=\"hljs-number\">.1</span>로 해결되었습니다\n<span class=\"hljs-variable constant_\">NAME</span>                            <span class=\"hljs-variable constant_\">LAST</span> <span class=\"hljs-variable constant_\">RUN</span>                        <span class=\"hljs-variable constant_\">SUSPENDED</span>       <span class=\"hljs-variable constant_\">READY</span>   <span class=\"hljs-variable constant_\">MESSAGE</span>\nimageupdateautomation/nginx     <span class=\"hljs-number\">2024</span>-<span class=\"hljs-number\">05</span>-23<span class=\"hljs-attr\">T16</span>:<span class=\"hljs-number\">55</span>:<span class=\"hljs-number\">39</span>+<span class=\"hljs-number\">05</span>:<span class=\"hljs-number\">30</span>       <span class=\"hljs-title class_\">False</span>           <span class=\"hljs-title class_\">True</span>    레포지토리가 최신 상태입니다\n</code></pre>\n<p></p>\n<p>위의 출력에서 볼 수 있듯이, 이미지 정책은 ECR에서 최신 이미지 태그를 스캔하고 가져왔습니다.</p>\n<p>이제 아래 명령을 사용하여 배포에 동일한 업데이트가 반영되었는지 확인해봅시다:</p>\n<pre><code class=\"hljs language-js\">kubectl get deployment nginx-deployment -o=jsonpath=<span class=\"hljs-string\">'{.spec.template.spec.containers[*].image}'</span> | awk -F <span class=\"hljs-string\">'[:@]'</span> <span class=\"hljs-string\">'{print $1, $2}'</span>\n</code></pre>\n<p>아래는 우리가 얻은 출력입니다. 이미지가 업데이트된 것을 확인할 수 있습니다.</p>\n<p></p>\n<pre><code class=\"hljs language-js\">&#x3C;aws-account-id>.<span class=\"hljs-property\">dkr</span>.<span class=\"hljs-property\">ecr</span>.&#x3C;aws-region>.<span class=\"hljs-property\">amazonaws</span>.<span class=\"hljs-property\">com</span>/<span class=\"hljs-attr\">nginx</span>:<span class=\"hljs-number\">0.0</span><span class=\"hljs-number\">.1</span>\n</code></pre>\n<p>이제 깃랩 쪽으로 이동하여 플럭스가 필요한 변경 사항을 수행했는지 확인해보세요.</p>\n<p>UI를 통해 레포지토리의 커밋 히스토리를 확인하거나 레포지토리를 복제한 후 아래 명령어를 실행할 수 있습니다.</p>\n<p>아래 명렁어를 실행해보세요:</p>\n<p></p>\n<pre><code class=\"hljs language-bash\">git <span class=\"hljs-built_in\">log</span> --author=<span class=\"hljs-string\">\"flux\"</span> --since=<span class=\"hljs-string\">\"today 00:00\"</span> --<span class=\"hljs-keyword\">until</span>=<span class=\"hljs-string\">\"today 23:59\"</span> --pretty=format:<span class=\"hljs-string\">\"%h %s\"</span> -- clusters/flux-cluster/nginx.yml\n</code></pre>\n<p>아래는 출력된 내용입니다:</p>\n<pre><code class=\"hljs language-bash\">85e5b48 &#x3C;aws-account-d>.dkr.ecr.&#x3C;aws-region>.amazonaws.com/nginx:0.0.1\n</code></pre>\n<p>위의 출력에서 확인할 수 있듯이 flux가 nginx.yml 파일에서 임의의 이미지 번호에서 실제 태그로 이미지를 업데이트했으며, 동일한 업데이트가 배포에서 수행되었습니다.</p>\n<p></p>\n<p>이미지의 새로운 버전을 푸시해보고 flux가 자동으로 업데이트되는지 확인해봐요.</p>\n<p>ECR 저장소에 Nginx 이미지를 태그해보세요.</p>\n<pre><code class=\"hljs language-js\">docker tag <span class=\"hljs-attr\">nginx</span>:latest &#x3C;aws_account_id>.<span class=\"hljs-property\">dkr</span>.<span class=\"hljs-property\">ecr</span>.&#x3C;region>.<span class=\"hljs-property\">amazonaws</span>.<span class=\"hljs-property\">com</span>/nginx-<span class=\"hljs-attr\">repo</span>:<span class=\"hljs-number\">0.0</span><span class=\"hljs-number\">.2</span>\n</code></pre>\n<p>이제 아래 명령어를 사용하여 배포가 정상적으로 업데이트되었는지 확인해보세요:</p>\n<p></p>\n<p>아래는 표시되는 출력 값 입니다:</p>\n<pre><code class=\"hljs language-bash\">&#x3C;aws-account-id>.dkr.ecr.&#x3C;aws-region>.amazonaws.com/nginx:0.0.2\n</code></pre>\n<h1>결론</h1>\n<p></p>\n<p>그래서 결론적으로, 우리는 flux, gitlab, terraform, kubernetes를 사용하여 gitops 워크플로우를 설정했고, 새 이미지를 컨테이너 저장소에 푸시할 때마다 flux가 배포를 관리할 것입니다.</p>\n<h1>참고 자료:</h1>\n<p>Flux 문서: <a href=\"https://fluxcd.io/flux/\" rel=\"nofollow\" target=\"_blank\">https://fluxcd.io/flux/</a></p>\n</body>\n</html>\n"},"__N_SSG":true}