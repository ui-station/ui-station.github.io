{"pageProps":{"post":{"title":"루프의 길이 찾기 GFG 문제","description":"","date":"2024-05-18 15:13","slug":"2024-05-18-FindlengthofLoopGFGProblem","content":"\n## 소개\n\n연결 리스트는 컴퓨터 과학에서 중요한 데이터 구조입니다. 노드로 구성되어 있으며 각 노드는 데이터와 순서상 다음 노드를 가리키는 참조(또는 링크)를 포함합니다. 연결 리스트의 일반적인 문제 중 하나는 루프를 감지하고 해당 루프의 노드 수를 계산하는 것입니다. 이 기사에서는 연결 리스트 내의 루프에 있는 노드 수를 세는 간단하면서 효과적인 알고리즘에 대해 살펴보겠습니다.\n\n## 문제\n\n연결 리스트의 루프는 노드의 다음 포인터가 리스트 내 이전 노드 중 하나를 가리킬 때 발생하여 순환이 생성됩니다. 이러한 루프를 감지하는 것은 탐색 중 무한 루프를 방지하기 위해 중요합니다. 루프를 감지한 후에는 루프 내 노드 수를 세는 것이 구조를 이해하거나 추가 처리를 위한 여러 목적에 유용할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 알고리즘\n\n루프 내 노드 수를 세려면 먼저 루프를 감지해야 합니다. 이를 위해 Floyd의 순환 찾기 알고리즘(토끼와 거북이 알고리즘으로도 알려짐)을 사용할 수 있습니다. 루프가 감지되면 다음 단계를 통해 루프 내 노드 수를 세는 방법을 사용할 수 있습니다.\n\n다음은 루프 내 노드를 세는 코드 스니펫입니다:\n\n```js\nint count = 1;\nNode current = loopNode;\n\nwhile (current.next != loopNode) {\n    current = current.next;\n    count++;\n}\nreturn count;\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 해당 알고리즘을 자세히 살펴보겠습니다:\n\n- 초기화:\n\n  - 루프노드 자체가 루프의 일부이기 때문에 count 카운터를 1로 초기화합니다.\n  - current 포인터를 루프노드로 설정합니다.\n\n- 순회 및 카운팅:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 현재 포인터를 사용하여 루프를 트래버스(순회)합니다.\n- 각 노드마다 다음 노드로 이동하고 카운터를 증가시킵니다.\n- 이 과정을 반복하여 루프 노드에 다시 도달할 때까지 진행하여 사이클을 완료합니다.\n\n- 카운트 반환:\n\n- 루프가 완전히 트래버스(순회)된 후, 카운트에는 루프의 노드 수가 저장되며 이를 반환합니다.\n\n## 예시 해설\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음과 같이 루프를 가진 링크드 리스트를 고려해 봅시다:\n\n![image](/assets/img/2024-05-18-FindlengthofLoopGFGProblem_0.png)\n\n- 여기서 노드 5는 노드 3을 가리키므로 루프가 생성됩니다.\n- loopNode이 노드 3으로 감지되었다고 가정합니다.\n- 우리의 알고리즘은 current를 노드 3으로 초기화하고 카운팅을 시작합니다.\n- 탐색은 다음과 같이 진행됩니다: 3 - 4 - 5 - 6 - 7 - 8 - 3.\n- 각 단계마다 count가 증가하여 최종 count는 6이 됩니다.\n\nMarkdown 형식으로 테이블 태그를 변경합니다.\n\n```js\nstatic int countNodesinLoop(ListNode head) {\n    if (head == null) {\n        return 0;\n    }\n\n    ListNode slow = head;\n    ListNode fast = head;\n\n    int count = 1 ;\n\n    while (fast != null && fast.next != null) {\n        slow = slow.next;\n        fast = fast.next.next;\n\n        if (slow == fast) {\n            return countLoopLength(slow);\n        }\n    }\n\n    return 0;\n}\n\nprivate static int countLoopLength(ListNode loopNode) {\n    int count = 1;\n    ListNode current = loopNode;\n    while (current.next != loopNode) {\n        current = current.next;\n        count++;\n    }\n    return count;\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 실용적인 고려 사항\n\n- 루프 감지: 위 코드는 루프 감지가 이미 완료되었고 loopNode가 제공되었다고 가정합니다. Floyd의 순환 찾기 알고리즘을 사용하여 이를 달성할 수 있습니다.\n- 예외 경우: 루프가 없거나 루프가 하나의 노드로만 구성된 경우를 고려해야 합니다. 알고리즘은 이러한 사례를 민첩하게 처리해야 합니다.\n- 복잡성: 이 루프 카운팅의 시간 복잡도는 O(n)입니다. 여기서 n은 루프 내 노드의 수입니다. 공간 복잡도는 추가적인 공간을 상수로 사용하므로 O(1)입니다.\n\n## 결론\n\n연결 리스트 내의 루프에서 노드를 계산하는 것은 직관적인 순회 방법을 사용하여 쉽게 수행할 수 있는 기본 작업입니다. 이 알고리즘을 이해하고 구현함으로써 연결 리스트 조작에 대한 이해를 높이고 데이터 구조에서 더 복잡한 문제를 대비할 수 있습니다. 이 지식을 바탕으로 연결 리스트의 루프를 효율적으로 처리하여 알고리즘을 견고하고 신뢰성 있게 만들 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-05-18-FindlengthofLoopGFGProblem_0.png"},"coverImage":"/assets/img/2024-05-18-FindlengthofLoopGFGProblem_0.png","tag":["Tech"],"readingTime":4},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<h2>소개</h2>\n<p>연결 리스트는 컴퓨터 과학에서 중요한 데이터 구조입니다. 노드로 구성되어 있으며 각 노드는 데이터와 순서상 다음 노드를 가리키는 참조(또는 링크)를 포함합니다. 연결 리스트의 일반적인 문제 중 하나는 루프를 감지하고 해당 루프의 노드 수를 계산하는 것입니다. 이 기사에서는 연결 리스트 내의 루프에 있는 노드 수를 세는 간단하면서 효과적인 알고리즘에 대해 살펴보겠습니다.</p>\n<h2>문제</h2>\n<p>연결 리스트의 루프는 노드의 다음 포인터가 리스트 내 이전 노드 중 하나를 가리킬 때 발생하여 순환이 생성됩니다. 이러한 루프를 감지하는 것은 탐색 중 무한 루프를 방지하기 위해 중요합니다. 루프를 감지한 후에는 루프 내 노드 수를 세는 것이 구조를 이해하거나 추가 처리를 위한 여러 목적에 유용할 수 있습니다.</p>\n<p></p>\n<h2>알고리즘</h2>\n<p>루프 내 노드 수를 세려면 먼저 루프를 감지해야 합니다. 이를 위해 Floyd의 순환 찾기 알고리즘(토끼와 거북이 알고리즘으로도 알려짐)을 사용할 수 있습니다. 루프가 감지되면 다음 단계를 통해 루프 내 노드 수를 세는 방법을 사용할 수 있습니다.</p>\n<p>다음은 루프 내 노드를 세는 코드 스니펫입니다:</p>\n<pre><code class=\"hljs language-js\">int count = <span class=\"hljs-number\">1</span>;\n<span class=\"hljs-title class_\">Node</span> current = loopNode;\n\n<span class=\"hljs-keyword\">while</span> (current.<span class=\"hljs-property\">next</span> != loopNode) {\n    current = current.<span class=\"hljs-property\">next</span>;\n    count++;\n}\n<span class=\"hljs-keyword\">return</span> count;\n</code></pre>\n<p></p>\n<p>아래는 해당 알고리즘을 자세히 살펴보겠습니다:</p>\n<ul>\n<li>\n<p>초기화:</p>\n<ul>\n<li>루프노드 자체가 루프의 일부이기 때문에 count 카운터를 1로 초기화합니다.</li>\n<li>current 포인터를 루프노드로 설정합니다.</li>\n</ul>\n</li>\n<li>\n<p>순회 및 카운팅:</p>\n</li>\n</ul>\n<p></p>\n<ul>\n<li>\n<p>현재 포인터를 사용하여 루프를 트래버스(순회)합니다.</p>\n</li>\n<li>\n<p>각 노드마다 다음 노드로 이동하고 카운터를 증가시킵니다.</p>\n</li>\n<li>\n<p>이 과정을 반복하여 루프 노드에 다시 도달할 때까지 진행하여 사이클을 완료합니다.</p>\n</li>\n<li>\n<p>카운트 반환:</p>\n</li>\n<li>\n<p>루프가 완전히 트래버스(순회)된 후, 카운트에는 루프의 노드 수가 저장되며 이를 반환합니다.</p>\n</li>\n</ul>\n<h2>예시 해설</h2>\n<p></p>\n<p>다음과 같이 루프를 가진 링크드 리스트를 고려해 봅시다:</p>\n<p><img src=\"/assets/img/2024-05-18-FindlengthofLoopGFGProblem_0.png\" alt=\"image\"></p>\n<ul>\n<li>여기서 노드 5는 노드 3을 가리키므로 루프가 생성됩니다.</li>\n<li>loopNode이 노드 3으로 감지되었다고 가정합니다.</li>\n<li>우리의 알고리즘은 current를 노드 3으로 초기화하고 카운팅을 시작합니다.</li>\n<li>탐색은 다음과 같이 진행됩니다: 3 - 4 - 5 - 6 - 7 - 8 - 3.</li>\n<li>각 단계마다 count가 증가하여 최종 count는 6이 됩니다.</li>\n</ul>\n<p>Markdown 형식으로 테이블 태그를 변경합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">static</span> int <span class=\"hljs-title function_\">countNodesinLoop</span>(<span class=\"hljs-params\">ListNode head</span>) {\n    <span class=\"hljs-keyword\">if</span> (head == <span class=\"hljs-literal\">null</span>) {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n    }\n\n    <span class=\"hljs-title class_\">ListNode</span> slow = head;\n    <span class=\"hljs-title class_\">ListNode</span> fast = head;\n\n    int count = <span class=\"hljs-number\">1</span> ;\n\n    <span class=\"hljs-keyword\">while</span> (fast != <span class=\"hljs-literal\">null</span> &#x26;&#x26; fast.<span class=\"hljs-property\">next</span> != <span class=\"hljs-literal\">null</span>) {\n        slow = slow.<span class=\"hljs-property\">next</span>;\n        fast = fast.<span class=\"hljs-property\">next</span>.<span class=\"hljs-property\">next</span>;\n\n        <span class=\"hljs-keyword\">if</span> (slow == fast) {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">countLoopLength</span>(slow);\n        }\n    }\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n\nprivate <span class=\"hljs-keyword\">static</span> int <span class=\"hljs-title function_\">countLoopLength</span>(<span class=\"hljs-params\">ListNode loopNode</span>) {\n    int count = <span class=\"hljs-number\">1</span>;\n    <span class=\"hljs-title class_\">ListNode</span> current = loopNode;\n    <span class=\"hljs-keyword\">while</span> (current.<span class=\"hljs-property\">next</span> != loopNode) {\n        current = current.<span class=\"hljs-property\">next</span>;\n        count++;\n    }\n    <span class=\"hljs-keyword\">return</span> count;\n}\n</code></pre>\n<p></p>\n<h2>실용적인 고려 사항</h2>\n<ul>\n<li>루프 감지: 위 코드는 루프 감지가 이미 완료되었고 loopNode가 제공되었다고 가정합니다. Floyd의 순환 찾기 알고리즘을 사용하여 이를 달성할 수 있습니다.</li>\n<li>예외 경우: 루프가 없거나 루프가 하나의 노드로만 구성된 경우를 고려해야 합니다. 알고리즘은 이러한 사례를 민첩하게 처리해야 합니다.</li>\n<li>복잡성: 이 루프 카운팅의 시간 복잡도는 O(n)입니다. 여기서 n은 루프 내 노드의 수입니다. 공간 복잡도는 추가적인 공간을 상수로 사용하므로 O(1)입니다.</li>\n</ul>\n<h2>결론</h2>\n<p>연결 리스트 내의 루프에서 노드를 계산하는 것은 직관적인 순회 방법을 사용하여 쉽게 수행할 수 있는 기본 작업입니다. 이 알고리즘을 이해하고 구현함으로써 연결 리스트 조작에 대한 이해를 높이고 데이터 구조에서 더 복잡한 문제를 대비할 수 있습니다. 이 지식을 바탕으로 연결 리스트의 루프를 효율적으로 처리하여 알고리즘을 견고하고 신뢰성 있게 만들 수 있습니다.</p>\n</body>\n</html>\n"},"__N_SSG":true}