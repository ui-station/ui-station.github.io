{"pageProps":{"post":{"title":"Kubernetes K8s ConfigMap 또는 Secret가 업데이트될 때 배포 자동 재시작하기","description":"","date":"2024-06-19 13:11","slug":"2024-06-19-KubernetesAutoRestartDeploymentswhenK8sConfigMaporSecretisUpdated","content":"\n## 자동 롤아웃 재시작: K8s ConfigMap 또는 Secret가 업데이트될 때 배포 다시 시작하기\n\n쿠버네티스 배포는 모든 쿠버네티스 클러스터에서 가장 일반적인 리소스 중 하나입니다. 우리는 모두 pod를 K8s 배포를 사용하여 실행하여 높은 가용성을 보장하고, pod가 삭제되면 자동으로 생성되도록합니다.\n\n애플리케이션이 항상 여러 환경에서 원활하게 실행되도록하기 위해 구성이 필요한 것은 매우 흔합니다. 데이터베이스 사용자 이름, 비밀번호 등과 같은 중요한 정보가 필요할 수도 있습니다. 쿠버네티스에서는 구성 맵과 시크릿을 사용하여 응용 프로그램별 데이터를 저장하고 pod로 주입하여 응용 프로그램에서 사용할 수 있도록 할 수 있습니다.\n\n그렇다면 구성 맵이나 시크릿의 값을 업데이트했을 때는 어떨까요? 최신 값을 반영하려면 pod를 다시 시작해야합니다, 맞죠? 또는 롤아웃을 다시 시작하여 새로운 pod를 생성하게 할 수도 있습니다. 이제 상상해보세요. 공통 configmap 또는 secret을 사용하는 수백 개의 배포가 있고 그 값을 업데이트하고 사용하는 것이 최신 값이라는 것을 확실하게 해야한다고 가정해보세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저희는 AWS Secrets Manager에 비밀을 저장하고, Kubernetes Secrets Store CSI Driver를 위해 AWS Secrets 및 구성 제공자(ASCP)로부터 Kubernetes Secrets를 생성합니다.\n\n이 블로그 게시물에서는 Secret 또는 ConfigMap이 업데이트될 때 Kubernetes 배포를 자동으로 롤아웃 및 다시 시작하는 방법에 대해 설명하겠습니다.\n\n# 아키텍처 다이어그램:\n\n![Architecture Diagram](/assets/img/2024-06-19-KubernetesAutoRestartDeploymentswhenK8sConfigMaporSecretisUpdated_0.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 시작해 봅시다!\n\n### 준비물:\n\n- EKS 클러스터\n- EKS를 위한 OIDC 제공자 구성 필요\n- Kubectl\n- AWS CLI\n\n### 단계 1: ASCP를 위한 IAM 역할 및 정책 생성\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nASCP(Amazon EKS Security Token Service)는 Amazon EKS 파드 ID를 검색하여 IAM 역할로 교환합니다. 해당 IAM 역할에 대한 IAM 정책에서 권한을 설정합니다. ASCP가 IAM 역할을 가정하면 권한을 부여받은 시크릿에 액세스할 수 있습니다. 다른 컨테이너는 IAM 역할과 연결되지 않는 한 시크릿에 액세스할 수 없습니다.\n\n- IAM 정책 문서 작성\n  \"secrets_policy\"라는 이름의 파일을 만들고 다음 내용을 추가하십시오.\n\n```js\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Action\": [\n                \"secretsmanager:DescribeSecret\",\n                \"secretsmanager:GetSecretValue\"\n            ],\n            \"Effect\": \"Allow\",\n            \"Resource\": \"*\"\n        }\n}\n```\n\n2. 다음 명령을 실행하여 IAM 정책을 만듭니다.\n   IAM 정책을 IAM 역할에 연결할 때 policy ARN을 메모하십시오.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\naws iam create-policy \\\n    --policy-name my-secret-manager-policy \\\n    --policy-document file://secrets_policy\n```\n\n3. IAM 역할에 신뢰 정책 생성하기\n   \"trust_policy\"라는 이름의 파일을 생성하고 다음 내용을 추가하세요. 올바른 값으로 대체해야 합니다. `SERVICE_ACCOUNT_NAME`은 임의로 지정할 수 있지만 Kubernetes에서 실제 서비스 계정을 생성할 때 동일한 이름을 사용해야 합니다.\n\n```js\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\": \"Allow\",\n      \"Action\": \"sts:AssumeRoleWithWebIdentity\",\n      \"Principal\": {\n        \"Federated\": \"arn:aws:iam::<AWS_ACCOUNT_ID>:oidc-provider/oidc.eks.<AWS_REGION>.amazonaws.com/id/<OIDC_ID>\"\n      },\n      \"Condition\": {\n        \"StringEquals\": {\n          \"oidc.eks.<AWS_REGION>.amazonaws.com/id/<OIDC_ID>:aud\": \"sts.amazonaws.com\",\n          \"oidc.eks.<AWS_REGION>.amazonaws.com/id/<OIDC_ID>:sub\": \"system:serviceaccount:<K8S_NAMESPACE>:<SERVICE_ACCOUNT_NAME>\"\n        }\n      }\n    }\n  ]\n}\n```\n\n4. 다음 명령어를 실행하여 IAM 역할을 만드세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\naws iam create-role --role-name my-secret-manager-role --assume-role-policy-document file://trust_policy\n```\n\n5. Attach IAM policy to IAM Role\n\n```js\naws iam attach-role-policy --policy-arn <your_policy_arn> --role-name my-secret-manager-role\n```\n\n우리는 필요한 모든 IAM 역할과 정책을 생성했습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 단계 2: ASCP 설치 및 구성\n\n이제 2개의 Helm 차트를 설치해야 합니다.\n\n- AWS Secrets and Configuration Provider (ASCP) 차트 설치\n\n```js\n# ASCP Helm 차트 리포지토리 추가\nhelm repo add aws-secrets-manager https://aws.github.io/secrets-store-csi-driver-provider-aws\n\n# ASCP Helm 차트 설치\nhelm install -n kube-system secrets-provider-aws aws-secrets-manager/secrets-store-csi-driver-provider-aws\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n2. Secrets Store CSI Driver 차트 설치\n\n- Secrets Store CSI Driver 차트를 위한 helm 레포지토리 추가\n\n```js\n# Secrets Store CSI Driver 차트 레포지토리 추가\nhelm repo add secrets-store-csi-driver https://kubernetes-sigs.github.io/secrets-store-csi-driver/charts\n```\n\n- 기본값 확인\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 기본 값 가져오기\n\nhelm show values secrets-store-csi-driver/secrets-store-csi-driver > secrets-store-csi-driver.yaml\n\n- secrets-store-csi-driver.yaml 파일에서 다음 값을 업데이트하세요.\n\n## K8S Secrets 동기화에 필요한 RBAC 역할 및 바인딩 설치 여부\n\nsyncSecret:\nenabled: true\n\n## 시크릿 로테이션 기능 활성화 [알파]\n\nenableSecretRotation: true\n\n위의 구성은 \"secrets-store-csi-driver\"가 AWS Secret Manager에서 최신 값을 가져와 해당 값을 Kubernetes Secrets 객체에 업데이트할 수 있게 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n회전-투표-간격은 기본적으로 2분으로 설정되어 있지만, 속성 rotationPollInterval을 설정함으로써 변경할 수 있습니다.\n\n- Helm 차트 설치\n\n```js\n# Helm 차트 설치\nhelm install -n kube-system csi-secrets-store secrets-store-csi-driver/secrets-store-csi-driver -f secrets-store-csi-driver.yaml\n```\n\n# 단계 3: AWS Secret Manager에 테스트 시크릿 생성\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nAWS Secret Manager에서 테스트 시크릿을 생성할 것입니다.\n\n```js\naws secretsmanager create-secret \\\n    --name my-test-secret \\\n    --description \"CLI로 생성한 내 테스트 시크릿.\" \\\n    --secret-string \"{\\\"user\\\":\\\"my-user\\\",\\\"password\\\":\\\"예시-비밀번호\\\"}\"\n```\n\n# 단계 4: Kubernetes ServiceAccount 생성\n\n이제 IAM 역할을 가정할 수 있도록 파드에 허용하는 ServiceAccount를 생성할 수 있습니다. 이 ServiceAccount는 K8s 배포에서 사용될 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nserviceaccount.yaml이라는 이름의 파일을 생성해주세요.\n\n```yaml\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: <your_service_account_name> # 이 이름은 IAM 신뢰 정책을 만들 때 지정한 이름과 일치해야 합니다.\n  annotations:\n    eks.amazonaws.com/role-arn: <IAM_ROLE_ARN>\n```\n\n다음 명령을 실행하여 K8s에서 서비스 계정을 생성합니다.\n\n```bash\nkubectl apply -f serviceaccount.yaml\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 단계 5: 테스트 객체 생성하기\n\n이제 필요한 모든 리소스를 배포했습니다. 이제 테스트 객체를 만들어 봅시다.\n\n- 이름이 “my-test-secret-manifest.yaml”인 파일 생성\n\n```js\n---\napiVersion: secrets-store.csi.x-k8s.io/v1\nkind: SecretProviderClass\nmetadata:\n  name: aws-secrets-providerclass\nspec:\n  provider: aws\n  secretObjects:\n    - secretName: my-test-k8s-secret\n      type: Opaque\n      data:\n        - objectName: user\n          key: user\n        - objectName: password\n          key: password\n  parameters:\n    objects: |\n      - objectName: arn:aws:secretsmanager:<AWS_REGION>:<AWS_ACCOUNT_ID>:secret:my-test-secret\n        jmesPath:\n          - path: user\n            objectAlias: user\n          - path: password\n            objectAlias: password\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: secret-rotation-test-ubuntu-deployment\n  labels:\n    app: ubuntu\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: ubuntu\n  template:\n    metadata:\n      labels:\n        app: ubuntu\n    spec:\n      serviceAccountName: <your_service_account_name> # 이 이름은 단계 4에서 만든 서비스 계정 이름과 일치해야 합니다\n      volumes:\n      - name: mount-secrets-access\n        csi:\n          driver: secrets-store.csi.k8s.io\n          readOnly: true\n          volumeAttributes:\n            secretProviderClass: \"aws-secrets-providerclass\"\n      containers:\n      - name: ubuntu\n        image: ubuntu\n        command: [\"sleep\", \"123456\"]\n        env:\n        - name: USER\n          valueFrom:\n            secretKeyRef:\n              name: my-test-k8s-secret\n              key: user\n        - name: PASSWORD\n          valueFrom:\n            secretKeyRef:\n              name: my-test-k8s-secret\n              key: password\n        volumeMounts:\n        - name: mount-secrets-access\n          mountPath: \"/mnt/aws-secrets\"\n          readOnly: true\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n2. manifest를 적용하십시오\n\n```js\nkubectl apply -f my-test-secret-manifest.yaml\n```\n\n3. 다음 리소스가 생성됩니다.\n\n- SecretProviderClass 리소스 - AWS Secret Manager에서 데이터를 가져와 K8s Secret를 생성합니다\n- 볼륨 마운트가 있는 배포 - SecretProviderClass를 볼륨으로 마운트해야 합니다\n- Kubernetes Secret - 파드 내에서 환경 변수로 주입됩니다\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래 다이어그램은 YAML을 적용할 때 뒷단에서 무슨 일이 벌어지는지 잘 시각화한 것입니다.\n\n![다이어그램](/assets/img/2024-06-19-KubernetesAutoRestartDeploymentswhenK8sConfigMaporSecretisUpdated_1.png)\n\n4. 모든 것이 배포되었는지 확인해보세요.\n\n```js\n# SecretProviderClass 확인\nkubectl get SecretProviderClass aws-secrets-providerclass -o yaml\n\n# 배포 확인\nkubectl get deploy secret-rotation-test-ubuntu-deployment -o yaml\n\n# Pod 확인\nkubectl get po <pod_name> -o yaml\n\n# Secret 가져오기\nkubectl get secret my-test-k8s-secret -o yaml\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 단계 6: Reloader 설치하기\n\nReloader는 ConfigMap과 Secret의 변경 사항을 감지하고 관련된 DeploymentConfig, Deployment, DaemonSet, StatefulSet 및 Rollout과 함께 Pod의 롤링 업그레이드를 수행할 수 있습니다.\n\n- Reloader Helm Repo 추가\n\n```js\n# Helm Repo 추가\nhelm repo add stakater https://stakater.github.io/stakater-charts\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n2. 기본값 가져오기\n\n```js\n# 기본값 가져오기\nhelm show values stakater/reloader > reloader.yaml\n```\n\n3. reloader.yaml 파일 업데이트하기\n\n```js\nreloader:\n  # 리더십 선출을 활성화하려면 true로 설정하여 여러 레플리카를 실행할 수 있습니다.\n  enableHA: true\n  deployment:\n    # 여러 레플리카를 실행하려면 reloader.enableHA = true로 설정합니다.\n    replicas: 2\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n4. Helm 차트 설치\n\n```js\n# Helm 차트 설치\nhelm install reloader -f reloader.yaml stakater/reloader -n kube-system\n```\n\n# 단계 7: Secret 업데이트로 테스트하기\n\n- Reloader는 주석에 영향을 받습니다.\n  기본 주석 reloader.stakater.com/auto는 주요 메타데이터에 있어야 합니다. 아래 명령을 사용하여 배포에 주석을 추가하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n# 배포 주석 추가\nkubectl annotate deployment secret-rotation-test-ubuntu-deployment \"reloader.stakater.com/auto=true\"\n```\n\n또는 다음 블록으로 배포 파일을 편집하고 적용할 수도 있습니다.\n\n```js\nmetadata:\n  annotations:\n    reloader.stakater.com/auto: \"true\"\n```\n\n2. AWS Secret Manager에서 시크릿 업데이트하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\naws secretsmanager put-secret-value \\\n      --secret-id my-test-secret \\\n      --secret-string \"{\\\"user\\\":\\\"diegor\\\",\\\"password\\\":\\\"SAMPLE-PASSWORD\\\"}\"\n```\n\n3. 한 번 시크릿이 AWS 시크릿 스토어 csi 드라이버에 업데이트되면 K8s 시크릿이 즉시 업데이트됩니다. K8s 시크릿이 업데이트되면 Reloader가 롤아웃을 다시 시작하도록 트리거합니다.\n\n```js\n# K8s 시크릿을 확인하세요. 새로운 값이 있어야 합니다.\nkubectl get secret my-test-k8s-secret -o yaml\n\n# Pod를 확인하세요. 몇 초 전에 시작되었어야 합니다.\nkubectl get po\n\n# Reloader 팟의 로그를 확인하세요.\nkubectl logs <reloader-pod-name> -n kube-system\n\n# Pod로 실행 후 새로운 값을 확인하세요.\nkubectl exec -it <pod_name> -- bash\n\n# Pod에 들어간 후 `env` 명령을 실행하세요. Pod에서 사용 가능한 모든 환경 변수가 출력됩니다.\n```\n\n# 단계 8: ConfigMap 업데이트를 테스트하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- \"my-test-cm-manifest.yaml\" 파일을 생성해주세요.\n\n```yaml\n---\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: my-test-k8s-cm\ndata:\n  myvalue: \"Hello World\"\n  drink: coffee\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: reloader-poc-ubuntu-deployment\n  labels:\n    app: ubuntu\n  annotations:\n    reloader.stakater.com/auto: \"true\"\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: ubuntu\n  template:\n    metadata:\n      labels:\n        app: ubuntu\n    spec:\n      containers:\n        - name: ubuntu\n          image: ubuntu\n          command: [\"sleep\", \"123456\"]\n          env:\n            - name: DRINK\n              valueFrom:\n                configMapKeyRef:\n                  name: my-test-k8s-cm\n                  key: drink\n            - name: MYVALUE\n              valueFrom:\n                configMapKeyRef:\n                  name: my-test-k8s-cm\n                  key: myvalue\n```\n\n2. 매니페스트 적용\n\n```bash\nkubectl apply -f my-test-cm-manifest.yaml\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n3. my-test-cm-manifest.yaml 파일에서 configmap을 업데이트하세요.\n\n```yaml\n---\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: my-test-k8s-cm\ndata:\n  myvalue: \"안녕하세요\"\n  drink: 차\n```\n\n4. 파일을 다시 적용하세요.\n\n```yaml\nkubectl apply -f my-test-cm-manifest.yaml\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n5. 확인\n\n```js\n# ConfigMap 확인\nkubectl get cm my-test-k8s-cm -o yaml\n\n# Pod 확인\nkubectl get po\n\n# Pod에 접속하여 새 값 확인\nkubectl exec -it <pod_name> -- bash\n\n# Pod에 들어간 후 `env` 명령어를 실행하면 Pod 내에서 사용 가능한 모든 환경 변수가 출력됩니다\n```\n\n축하합니다!!! secret-store-csi-driver와 reloader를 성공적으로 구성했습니다.\n\n감사합니다!!!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 참고 자료:\n\n- [AWS 공식 문서 - CSI 드라이버 통합](https://docs.aws.amazon.com/secretsmanager/latest/userguide/integrating_csi_driver.html)\n- [Bootlabs 기술 블로그 - AWS Secrets Manager in Kubernetes 시크릿 회전과 리로더](https://blog.bootlabstech.com/aws-secrets-manager-in-kubernetes-secret-rotation-and-reloader)\n- [Secrets Store CSI 드라이버 공식 홈페이지 - 시크릿 자동 회전](https://secrets-store-csi-driver.sigs.k8s.io/topics/secret-auto-rotation)\n- [Secrets Store CSI 드라이버 차트 값 설정 파일](https://github.com/kubernetes-sigs/secrets-store-csi-driver/blob/main/charts/secrets-store-csi-driver/values.yaml)\n- [Reloader GitHub 저장소](https://github.com/stakater/Reloader/tree/master)\n- [Reloader 작동 확인 문서](https://github.com/stakater/Reloader/blob/master/docs/Verify-Reloader-Working.md)\n- [Reloader 작동 방식 문서](https://github.com/stakater/Reloader/blob/master/docs/How-it-works.md)\n\n# 간단히 말하자면 🚀\n\nIn Plain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 계속 참여해 주세요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 작가에게 박수를 보내고 팔로우를 눌러주세요 ️👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼에서 저희를 만나보세요: Stackademic | CoFeed | Venture | Cubed\n- 알고리즘 콘텐츠를 다뤄야 하는 블로그 플랫폼에 지쳤나요? Differ를 시도해보세요\n- PlainEnglish.io에서 더 많은 콘텐츠를 만나보세요\n","ogImage":{"url":"/assets/img/2024-06-19-KubernetesAutoRestartDeploymentswhenK8sConfigMaporSecretisUpdated_0.png"},"coverImage":"/assets/img/2024-06-19-KubernetesAutoRestartDeploymentswhenK8sConfigMaporSecretisUpdated_0.png","tag":["Tech"],"readingTime":19},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<h2>자동 롤아웃 재시작: K8s ConfigMap 또는 Secret가 업데이트될 때 배포 다시 시작하기</h2>\n<p>쿠버네티스 배포는 모든 쿠버네티스 클러스터에서 가장 일반적인 리소스 중 하나입니다. 우리는 모두 pod를 K8s 배포를 사용하여 실행하여 높은 가용성을 보장하고, pod가 삭제되면 자동으로 생성되도록합니다.</p>\n<p>애플리케이션이 항상 여러 환경에서 원활하게 실행되도록하기 위해 구성이 필요한 것은 매우 흔합니다. 데이터베이스 사용자 이름, 비밀번호 등과 같은 중요한 정보가 필요할 수도 있습니다. 쿠버네티스에서는 구성 맵과 시크릿을 사용하여 응용 프로그램별 데이터를 저장하고 pod로 주입하여 응용 프로그램에서 사용할 수 있도록 할 수 있습니다.</p>\n<p>그렇다면 구성 맵이나 시크릿의 값을 업데이트했을 때는 어떨까요? 최신 값을 반영하려면 pod를 다시 시작해야합니다, 맞죠? 또는 롤아웃을 다시 시작하여 새로운 pod를 생성하게 할 수도 있습니다. 이제 상상해보세요. 공통 configmap 또는 secret을 사용하는 수백 개의 배포가 있고 그 값을 업데이트하고 사용하는 것이 최신 값이라는 것을 확실하게 해야한다고 가정해보세요.</p>\n<p></p>\n<p>저희는 AWS Secrets Manager에 비밀을 저장하고, Kubernetes Secrets Store CSI Driver를 위해 AWS Secrets 및 구성 제공자(ASCP)로부터 Kubernetes Secrets를 생성합니다.</p>\n<p>이 블로그 게시물에서는 Secret 또는 ConfigMap이 업데이트될 때 Kubernetes 배포를 자동으로 롤아웃 및 다시 시작하는 방법에 대해 설명하겠습니다.</p>\n<h1>아키텍처 다이어그램:</h1>\n<p><img src=\"/assets/img/2024-06-19-KubernetesAutoRestartDeploymentswhenK8sConfigMaporSecretisUpdated_0.png\" alt=\"Architecture Diagram\"></p>\n<p></p>\n<h2>시작해 봅시다!</h2>\n<h3>준비물:</h3>\n<ul>\n<li>EKS 클러스터</li>\n<li>EKS를 위한 OIDC 제공자 구성 필요</li>\n<li>Kubectl</li>\n<li>AWS CLI</li>\n</ul>\n<h3>단계 1: ASCP를 위한 IAM 역할 및 정책 생성</h3>\n<p></p>\n<p>ASCP(Amazon EKS Security Token Service)는 Amazon EKS 파드 ID를 검색하여 IAM 역할로 교환합니다. 해당 IAM 역할에 대한 IAM 정책에서 권한을 설정합니다. ASCP가 IAM 역할을 가정하면 권한을 부여받은 시크릿에 액세스할 수 있습니다. 다른 컨테이너는 IAM 역할과 연결되지 않는 한 시크릿에 액세스할 수 없습니다.</p>\n<ul>\n<li>IAM 정책 문서 작성\n\"secrets_policy\"라는 이름의 파일을 만들고 다음 내용을 추가하십시오.</li>\n</ul>\n<pre><code class=\"hljs language-js\">{\n    <span class=\"hljs-string\">\"Version\"</span>: <span class=\"hljs-string\">\"2012-10-17\"</span>,\n    <span class=\"hljs-string\">\"Statement\"</span>: [\n        {\n            <span class=\"hljs-string\">\"Action\"</span>: [\n                <span class=\"hljs-string\">\"secretsmanager:DescribeSecret\"</span>,\n                <span class=\"hljs-string\">\"secretsmanager:GetSecretValue\"</span>\n            ],\n            <span class=\"hljs-string\">\"Effect\"</span>: <span class=\"hljs-string\">\"Allow\"</span>,\n            <span class=\"hljs-string\">\"Resource\"</span>: <span class=\"hljs-string\">\"*\"</span>\n        }\n}\n</code></pre>\n<ol start=\"2\">\n<li>다음 명령을 실행하여 IAM 정책을 만듭니다.\nIAM 정책을 IAM 역할에 연결할 때 policy ARN을 메모하십시오.</li>\n</ol>\n<p></p>\n<pre><code class=\"hljs language-js\">aws iam create-policy \\\n    --policy-name my-secret-manager-policy \\\n    --policy-<span class=\"hljs-variable language_\">document</span> <span class=\"hljs-attr\">file</span>:<span class=\"hljs-comment\">//secrets_policy</span>\n</code></pre>\n<ol start=\"3\">\n<li>IAM 역할에 신뢰 정책 생성하기\n\"trust_policy\"라는 이름의 파일을 생성하고 다음 내용을 추가하세요. 올바른 값으로 대체해야 합니다. <code>SERVICE_ACCOUNT_NAME</code>은 임의로 지정할 수 있지만 Kubernetes에서 실제 서비스 계정을 생성할 때 동일한 이름을 사용해야 합니다.</li>\n</ol>\n<pre><code class=\"hljs language-js\">{\n  <span class=\"hljs-string\">\"Version\"</span>: <span class=\"hljs-string\">\"2012-10-17\"</span>,\n  <span class=\"hljs-string\">\"Statement\"</span>: [\n    {\n      <span class=\"hljs-string\">\"Effect\"</span>: <span class=\"hljs-string\">\"Allow\"</span>,\n      <span class=\"hljs-string\">\"Action\"</span>: <span class=\"hljs-string\">\"sts:AssumeRoleWithWebIdentity\"</span>,\n      <span class=\"hljs-string\">\"Principal\"</span>: {\n        <span class=\"hljs-string\">\"Federated\"</span>: <span class=\"hljs-string\">\"arn:aws:iam::&#x3C;AWS_ACCOUNT_ID>:oidc-provider/oidc.eks.&#x3C;AWS_REGION>.amazonaws.com/id/&#x3C;OIDC_ID>\"</span>\n      },\n      <span class=\"hljs-string\">\"Condition\"</span>: {\n        <span class=\"hljs-string\">\"StringEquals\"</span>: {\n          <span class=\"hljs-string\">\"oidc.eks.&#x3C;AWS_REGION>.amazonaws.com/id/&#x3C;OIDC_ID>:aud\"</span>: <span class=\"hljs-string\">\"sts.amazonaws.com\"</span>,\n          <span class=\"hljs-string\">\"oidc.eks.&#x3C;AWS_REGION>.amazonaws.com/id/&#x3C;OIDC_ID>:sub\"</span>: <span class=\"hljs-string\">\"system:serviceaccount:&#x3C;K8S_NAMESPACE>:&#x3C;SERVICE_ACCOUNT_NAME>\"</span>\n        }\n      }\n    }\n  ]\n}\n</code></pre>\n<ol start=\"4\">\n<li>다음 명령어를 실행하여 IAM 역할을 만드세요.</li>\n</ol>\n<p></p>\n<pre><code class=\"hljs language-js\">aws iam create-role --role-name my-secret-manager-role --assume-role-policy-<span class=\"hljs-variable language_\">document</span> <span class=\"hljs-attr\">file</span>:<span class=\"hljs-comment\">//trust_policy</span>\n</code></pre>\n<ol start=\"5\">\n<li>Attach IAM policy to IAM Role</li>\n</ol>\n<pre><code class=\"hljs language-js\">aws iam attach-role-policy --policy-arn &#x3C;your_policy_arn> --role-name my-secret-manager-role\n</code></pre>\n<p>우리는 필요한 모든 IAM 역할과 정책을 생성했습니다.</p>\n<p></p>\n<h1>단계 2: ASCP 설치 및 구성</h1>\n<p>이제 2개의 Helm 차트를 설치해야 합니다.</p>\n<ul>\n<li>AWS Secrets and Configuration Provider (ASCP) 차트 설치</li>\n</ul>\n<pre><code class=\"hljs language-js\"># <span class=\"hljs-variable constant_\">ASCP</span> <span class=\"hljs-title class_\">Helm</span> 차트 리포지토리 추가\nhelm repo add aws-secrets-manager <span class=\"hljs-attr\">https</span>:<span class=\"hljs-comment\">//aws.github.io/secrets-store-csi-driver-provider-aws</span>\n\n# <span class=\"hljs-variable constant_\">ASCP</span> <span class=\"hljs-title class_\">Helm</span> 차트 설치\nhelm install -n kube-system secrets-provider-aws aws-secrets-manager/secrets-store-csi-driver-provider-aws\n</code></pre>\n<p></p>\n<ol start=\"2\">\n<li>Secrets Store CSI Driver 차트 설치</li>\n</ol>\n<ul>\n<li>Secrets Store CSI Driver 차트를 위한 helm 레포지토리 추가</li>\n</ul>\n<pre><code class=\"hljs language-js\"># <span class=\"hljs-title class_\">Secrets</span> <span class=\"hljs-title class_\">Store</span> <span class=\"hljs-variable constant_\">CSI</span> <span class=\"hljs-title class_\">Driver</span> 차트 레포지토리 추가\nhelm repo add secrets-store-csi-driver <span class=\"hljs-attr\">https</span>:<span class=\"hljs-comment\">//kubernetes-sigs.github.io/secrets-store-csi-driver/charts</span>\n</code></pre>\n<ul>\n<li>기본값 확인</li>\n</ul>\n<p></p>\n<h1>기본 값 가져오기</h1>\n<p>helm show values secrets-store-csi-driver/secrets-store-csi-driver > secrets-store-csi-driver.yaml</p>\n<ul>\n<li>secrets-store-csi-driver.yaml 파일에서 다음 값을 업데이트하세요.</li>\n</ul>\n<h2>K8S Secrets 동기화에 필요한 RBAC 역할 및 바인딩 설치 여부</h2>\n<p>syncSecret:\nenabled: true</p>\n<h2>시크릿 로테이션 기능 활성화 [알파]</h2>\n<p>enableSecretRotation: true</p>\n<p>위의 구성은 \"secrets-store-csi-driver\"가 AWS Secret Manager에서 최신 값을 가져와 해당 값을 Kubernetes Secrets 객체에 업데이트할 수 있게 합니다.</p>\n<p></p>\n<p>회전-투표-간격은 기본적으로 2분으로 설정되어 있지만, 속성 rotationPollInterval을 설정함으로써 변경할 수 있습니다.</p>\n<ul>\n<li>Helm 차트 설치</li>\n</ul>\n<pre><code class=\"hljs language-js\"># <span class=\"hljs-title class_\">Helm</span> 차트 설치\nhelm install -n kube-system csi-secrets-store secrets-store-csi-driver/secrets-store-csi-driver -f secrets-store-csi-driver.<span class=\"hljs-property\">yaml</span>\n</code></pre>\n<h1>단계 3: AWS Secret Manager에 테스트 시크릿 생성</h1>\n<p></p>\n<p>AWS Secret Manager에서 테스트 시크릿을 생성할 것입니다.</p>\n<pre><code class=\"hljs language-js\">aws secretsmanager create-secret \\\n    --name my-test-secret \\\n    --description <span class=\"hljs-string\">\"CLI로 생성한 내 테스트 시크릿.\"</span> \\\n    --secret-string <span class=\"hljs-string\">\"{\\\"user\\\":\\\"my-user\\\",\\\"password\\\":\\\"예시-비밀번호\\\"}\"</span>\n</code></pre>\n<h1>단계 4: Kubernetes ServiceAccount 생성</h1>\n<p>이제 IAM 역할을 가정할 수 있도록 파드에 허용하는 ServiceAccount를 생성할 수 있습니다. 이 ServiceAccount는 K8s 배포에서 사용될 것입니다.</p>\n<p></p>\n<p>serviceaccount.yaml이라는 이름의 파일을 생성해주세요.</p>\n<pre><code class=\"hljs language-yaml\"><span class=\"hljs-attr\">apiVersion:</span> <span class=\"hljs-string\">v1</span>\n<span class=\"hljs-attr\">kind:</span> <span class=\"hljs-string\">ServiceAccount</span>\n<span class=\"hljs-attr\">metadata:</span>\n  <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">&#x3C;your_service_account_name></span> <span class=\"hljs-comment\"># 이 이름은 IAM 신뢰 정책을 만들 때 지정한 이름과 일치해야 합니다.</span>\n  <span class=\"hljs-attr\">annotations:</span>\n    <span class=\"hljs-attr\">eks.amazonaws.com/role-arn:</span> <span class=\"hljs-string\">&#x3C;IAM_ROLE_ARN></span>\n</code></pre>\n<p>다음 명령을 실행하여 K8s에서 서비스 계정을 생성합니다.</p>\n<pre><code class=\"hljs language-bash\">kubectl apply -f serviceaccount.yaml\n</code></pre>\n<p></p>\n<h1>단계 5: 테스트 객체 생성하기</h1>\n<p>이제 필요한 모든 리소스를 배포했습니다. 이제 테스트 객체를 만들어 봅시다.</p>\n<ul>\n<li>이름이 “my-test-secret-manifest.yaml”인 파일 생성</li>\n</ul>\n<pre><code class=\"hljs language-js\">---\n<span class=\"hljs-attr\">apiVersion</span>: secrets-store.<span class=\"hljs-property\">csi</span>.<span class=\"hljs-property\">x</span>-k8s.<span class=\"hljs-property\">io</span>/v1\n<span class=\"hljs-attr\">kind</span>: <span class=\"hljs-title class_\">SecretProviderClass</span>\n<span class=\"hljs-attr\">metadata</span>:\n  <span class=\"hljs-attr\">name</span>: aws-secrets-provider<span class=\"hljs-keyword\">class</span>\n<span class=\"hljs-title class_\">spec</span>:\n  <span class=\"hljs-attr\">provider</span>: aws\n  <span class=\"hljs-attr\">secretObjects</span>:\n    - <span class=\"hljs-attr\">secretName</span>: my-test-k8s-secret\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-title class_\">Opaque</span>\n      <span class=\"hljs-attr\">data</span>:\n        - <span class=\"hljs-attr\">objectName</span>: user\n          <span class=\"hljs-attr\">key</span>: user\n        - <span class=\"hljs-attr\">objectName</span>: password\n          <span class=\"hljs-attr\">key</span>: password\n  <span class=\"hljs-attr\">parameters</span>:\n    <span class=\"hljs-attr\">objects</span>: |\n      - <span class=\"hljs-attr\">objectName</span>: <span class=\"hljs-attr\">arn</span>:<span class=\"hljs-attr\">aws</span>:<span class=\"hljs-attr\">secretsmanager</span>:&#x3C;<span class=\"hljs-variable constant_\">AWS_REGION</span>>:&#x3C;<span class=\"hljs-variable constant_\">AWS_ACCOUNT_ID</span>>:<span class=\"hljs-attr\">secret</span>:my-test-secret\n        <span class=\"hljs-attr\">jmesPath</span>:\n          - <span class=\"hljs-attr\">path</span>: user\n            <span class=\"hljs-attr\">objectAlias</span>: user\n          - <span class=\"hljs-attr\">path</span>: password\n            <span class=\"hljs-attr\">objectAlias</span>: password\n---\n<span class=\"hljs-attr\">apiVersion</span>: apps/v1\n<span class=\"hljs-attr\">kind</span>: <span class=\"hljs-title class_\">Deployment</span>\n<span class=\"hljs-attr\">metadata</span>:\n  <span class=\"hljs-attr\">name</span>: secret-rotation-test-ubuntu-deployment\n  <span class=\"hljs-attr\">labels</span>:\n    <span class=\"hljs-attr\">app</span>: ubuntu\n<span class=\"hljs-attr\">spec</span>:\n  <span class=\"hljs-attr\">replicas</span>: <span class=\"hljs-number\">1</span>\n  <span class=\"hljs-attr\">selector</span>:\n    <span class=\"hljs-attr\">matchLabels</span>:\n      <span class=\"hljs-attr\">app</span>: ubuntu\n  <span class=\"hljs-attr\">template</span>:\n    <span class=\"hljs-attr\">metadata</span>:\n      <span class=\"hljs-attr\">labels</span>:\n        <span class=\"hljs-attr\">app</span>: ubuntu\n    <span class=\"hljs-attr\">spec</span>:\n      <span class=\"hljs-attr\">serviceAccountName</span>: &#x3C;your_service_account_name> # 이 이름은 단계 <span class=\"hljs-number\">4</span>에서 만든 서비스 계정 이름과 일치해야 합니다\n      <span class=\"hljs-attr\">volumes</span>:\n      - <span class=\"hljs-attr\">name</span>: mount-secrets-access\n        <span class=\"hljs-attr\">csi</span>:\n          <span class=\"hljs-attr\">driver</span>: secrets-store.<span class=\"hljs-property\">csi</span>.<span class=\"hljs-property\">k8s</span>.<span class=\"hljs-property\">io</span>\n          <span class=\"hljs-attr\">readOnly</span>: <span class=\"hljs-literal\">true</span>\n          <span class=\"hljs-attr\">volumeAttributes</span>:\n            <span class=\"hljs-attr\">secretProviderClass</span>: <span class=\"hljs-string\">\"aws-secrets-providerclass\"</span>\n      <span class=\"hljs-attr\">containers</span>:\n      - <span class=\"hljs-attr\">name</span>: ubuntu\n        <span class=\"hljs-attr\">image</span>: ubuntu\n        <span class=\"hljs-attr\">command</span>: [<span class=\"hljs-string\">\"sleep\"</span>, <span class=\"hljs-string\">\"123456\"</span>]\n        <span class=\"hljs-attr\">env</span>:\n        - <span class=\"hljs-attr\">name</span>: <span class=\"hljs-variable constant_\">USER</span>\n          <span class=\"hljs-attr\">valueFrom</span>:\n            <span class=\"hljs-attr\">secretKeyRef</span>:\n              <span class=\"hljs-attr\">name</span>: my-test-k8s-secret\n              <span class=\"hljs-attr\">key</span>: user\n        - <span class=\"hljs-attr\">name</span>: <span class=\"hljs-variable constant_\">PASSWORD</span>\n          <span class=\"hljs-attr\">valueFrom</span>:\n            <span class=\"hljs-attr\">secretKeyRef</span>:\n              <span class=\"hljs-attr\">name</span>: my-test-k8s-secret\n              <span class=\"hljs-attr\">key</span>: password\n        <span class=\"hljs-attr\">volumeMounts</span>:\n        - <span class=\"hljs-attr\">name</span>: mount-secrets-access\n          <span class=\"hljs-attr\">mountPath</span>: <span class=\"hljs-string\">\"/mnt/aws-secrets\"</span>\n          <span class=\"hljs-attr\">readOnly</span>: <span class=\"hljs-literal\">true</span>\n</code></pre>\n<p></p>\n<ol start=\"2\">\n<li>manifest를 적용하십시오</li>\n</ol>\n<pre><code class=\"hljs language-js\">kubectl apply -f my-test-secret-manifest.<span class=\"hljs-property\">yaml</span>\n</code></pre>\n<ol start=\"3\">\n<li>다음 리소스가 생성됩니다.</li>\n</ol>\n<ul>\n<li>SecretProviderClass 리소스 - AWS Secret Manager에서 데이터를 가져와 K8s Secret를 생성합니다</li>\n<li>볼륨 마운트가 있는 배포 - SecretProviderClass를 볼륨으로 마운트해야 합니다</li>\n<li>Kubernetes Secret - 파드 내에서 환경 변수로 주입됩니다</li>\n</ul>\n<p></p>\n<p>아래 다이어그램은 YAML을 적용할 때 뒷단에서 무슨 일이 벌어지는지 잘 시각화한 것입니다.</p>\n<p><img src=\"/assets/img/2024-06-19-KubernetesAutoRestartDeploymentswhenK8sConfigMaporSecretisUpdated_1.png\" alt=\"다이어그램\"></p>\n<ol start=\"4\">\n<li>모든 것이 배포되었는지 확인해보세요.</li>\n</ol>\n<pre><code class=\"hljs language-js\"># <span class=\"hljs-title class_\">SecretProviderClass</span> 확인\nkubectl get <span class=\"hljs-title class_\">SecretProviderClass</span> aws-secrets-providerclass -o yaml\n\n# 배포 확인\nkubectl get deploy secret-rotation-test-ubuntu-deployment -o yaml\n\n# <span class=\"hljs-title class_\">Pod</span> 확인\nkubectl get po &#x3C;pod_name> -o yaml\n\n# <span class=\"hljs-title class_\">Secret</span> 가져오기\nkubectl get secret my-test-k8s-secret -o yaml\n</code></pre>\n<p></p>\n<h1>단계 6: Reloader 설치하기</h1>\n<p>Reloader는 ConfigMap과 Secret의 변경 사항을 감지하고 관련된 DeploymentConfig, Deployment, DaemonSet, StatefulSet 및 Rollout과 함께 Pod의 롤링 업그레이드를 수행할 수 있습니다.</p>\n<ul>\n<li>Reloader Helm Repo 추가</li>\n</ul>\n<pre><code class=\"hljs language-js\"># <span class=\"hljs-title class_\">Helm</span> <span class=\"hljs-title class_\">Repo</span> 추가\nhelm repo add stakater <span class=\"hljs-attr\">https</span>:<span class=\"hljs-comment\">//stakater.github.io/stakater-charts</span>\n</code></pre>\n<p></p>\n<ol start=\"2\">\n<li>기본값 가져오기</li>\n</ol>\n<pre><code class=\"hljs language-js\"># 기본값 가져오기\nhelm show values stakater/reloader > reloader.<span class=\"hljs-property\">yaml</span>\n</code></pre>\n<ol start=\"3\">\n<li>reloader.yaml 파일 업데이트하기</li>\n</ol>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-attr\">reloader</span>:\n  # 리더십 선출을 활성화하려면 <span class=\"hljs-literal\">true</span>로 설정하여 여러 레플리카를 실행할 수 있습니다.\n  <span class=\"hljs-attr\">enableHA</span>: <span class=\"hljs-literal\">true</span>\n  <span class=\"hljs-attr\">deployment</span>:\n    # 여러 레플리카를 실행하려면 reloader.<span class=\"hljs-property\">enableHA</span> = <span class=\"hljs-literal\">true</span>로 설정합니다.\n    <span class=\"hljs-attr\">replicas</span>: <span class=\"hljs-number\">2</span>\n</code></pre>\n<p></p>\n<ol start=\"4\">\n<li>Helm 차트 설치</li>\n</ol>\n<pre><code class=\"hljs language-js\"># <span class=\"hljs-title class_\">Helm</span> 차트 설치\nhelm install reloader -f reloader.<span class=\"hljs-property\">yaml</span> stakater/reloader -n kube-system\n</code></pre>\n<h1>단계 7: Secret 업데이트로 테스트하기</h1>\n<ul>\n<li>Reloader는 주석에 영향을 받습니다.\n기본 주석 reloader.stakater.com/auto는 주요 메타데이터에 있어야 합니다. 아래 명령을 사용하여 배포에 주석을 추가하세요.</li>\n</ul>\n<p></p>\n<pre><code class=\"hljs language-js\"># 배포 주석 추가\nkubectl annotate deployment secret-rotation-test-ubuntu-deployment <span class=\"hljs-string\">\"reloader.stakater.com/auto=true\"</span>\n</code></pre>\n<p>또는 다음 블록으로 배포 파일을 편집하고 적용할 수도 있습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-attr\">metadata</span>:\n  <span class=\"hljs-attr\">annotations</span>:\n    reloader.<span class=\"hljs-property\">stakater</span>.<span class=\"hljs-property\">com</span>/<span class=\"hljs-attr\">auto</span>: <span class=\"hljs-string\">\"true\"</span>\n</code></pre>\n<ol start=\"2\">\n<li>AWS Secret Manager에서 시크릿 업데이트하기</li>\n</ol>\n<p></p>\n<pre><code class=\"hljs language-js\">aws secretsmanager put-secret-value \\\n      --secret-id my-test-secret \\\n      --secret-string <span class=\"hljs-string\">\"{\\\"user\\\":\\\"diegor\\\",\\\"password\\\":\\\"SAMPLE-PASSWORD\\\"}\"</span>\n</code></pre>\n<ol start=\"3\">\n<li>한 번 시크릿이 AWS 시크릿 스토어 csi 드라이버에 업데이트되면 K8s 시크릿이 즉시 업데이트됩니다. K8s 시크릿이 업데이트되면 Reloader가 롤아웃을 다시 시작하도록 트리거합니다.</li>\n</ol>\n<pre><code class=\"hljs language-js\"># K8s 시크릿을 확인하세요. 새로운 값이 있어야 합니다.\nkubectl get secret my-test-k8s-secret -o yaml\n\n# <span class=\"hljs-title class_\">Pod</span>를 확인하세요. 몇 초 전에 시작되었어야 합니다.\nkubectl get po\n\n# <span class=\"hljs-title class_\">Reloader</span> 팟의 로그를 확인하세요.\nkubectl logs &#x3C;reloader-pod-name> -n kube-system\n\n# <span class=\"hljs-title class_\">Pod</span>로 실행 후 새로운 값을 확인하세요.\nkubectl exec -it &#x3C;pod_name> -- bash\n\n# <span class=\"hljs-title class_\">Pod</span>에 들어간 후 <span class=\"hljs-string\">`env`</span> 명령을 실행하세요. <span class=\"hljs-title class_\">Pod</span>에서 사용 가능한 모든 환경 변수가 출력됩니다.\n</code></pre>\n<h1>단계 8: ConfigMap 업데이트를 테스트하세요.</h1>\n<p></p>\n<ul>\n<li>\"my-test-cm-manifest.yaml\" 파일을 생성해주세요.</li>\n</ul>\n<pre><code class=\"hljs language-yaml\"><span class=\"hljs-meta\">---</span>\n<span class=\"hljs-attr\">apiVersion:</span> <span class=\"hljs-string\">v1</span>\n<span class=\"hljs-attr\">kind:</span> <span class=\"hljs-string\">ConfigMap</span>\n<span class=\"hljs-attr\">metadata:</span>\n  <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">my-test-k8s-cm</span>\n<span class=\"hljs-attr\">data:</span>\n  <span class=\"hljs-attr\">myvalue:</span> <span class=\"hljs-string\">\"Hello World\"</span>\n  <span class=\"hljs-attr\">drink:</span> <span class=\"hljs-string\">coffee</span>\n<span class=\"hljs-meta\">---</span>\n<span class=\"hljs-attr\">apiVersion:</span> <span class=\"hljs-string\">apps/v1</span>\n<span class=\"hljs-attr\">kind:</span> <span class=\"hljs-string\">Deployment</span>\n<span class=\"hljs-attr\">metadata:</span>\n  <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">reloader-poc-ubuntu-deployment</span>\n  <span class=\"hljs-attr\">labels:</span>\n    <span class=\"hljs-attr\">app:</span> <span class=\"hljs-string\">ubuntu</span>\n  <span class=\"hljs-attr\">annotations:</span>\n    <span class=\"hljs-attr\">reloader.stakater.com/auto:</span> <span class=\"hljs-string\">\"true\"</span>\n<span class=\"hljs-attr\">spec:</span>\n  <span class=\"hljs-attr\">replicas:</span> <span class=\"hljs-number\">1</span>\n  <span class=\"hljs-attr\">selector:</span>\n    <span class=\"hljs-attr\">matchLabels:</span>\n      <span class=\"hljs-attr\">app:</span> <span class=\"hljs-string\">ubuntu</span>\n  <span class=\"hljs-attr\">template:</span>\n    <span class=\"hljs-attr\">metadata:</span>\n      <span class=\"hljs-attr\">labels:</span>\n        <span class=\"hljs-attr\">app:</span> <span class=\"hljs-string\">ubuntu</span>\n    <span class=\"hljs-attr\">spec:</span>\n      <span class=\"hljs-attr\">containers:</span>\n        <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">ubuntu</span>\n          <span class=\"hljs-attr\">image:</span> <span class=\"hljs-string\">ubuntu</span>\n          <span class=\"hljs-attr\">command:</span> [<span class=\"hljs-string\">\"sleep\"</span>, <span class=\"hljs-string\">\"123456\"</span>]\n          <span class=\"hljs-attr\">env:</span>\n            <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">DRINK</span>\n              <span class=\"hljs-attr\">valueFrom:</span>\n                <span class=\"hljs-attr\">configMapKeyRef:</span>\n                  <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">my-test-k8s-cm</span>\n                  <span class=\"hljs-attr\">key:</span> <span class=\"hljs-string\">drink</span>\n            <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">MYVALUE</span>\n              <span class=\"hljs-attr\">valueFrom:</span>\n                <span class=\"hljs-attr\">configMapKeyRef:</span>\n                  <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">my-test-k8s-cm</span>\n                  <span class=\"hljs-attr\">key:</span> <span class=\"hljs-string\">myvalue</span>\n</code></pre>\n<ol start=\"2\">\n<li>매니페스트 적용</li>\n</ol>\n<pre><code class=\"hljs language-bash\">kubectl apply -f my-test-cm-manifest.yaml\n</code></pre>\n<p></p>\n<ol start=\"3\">\n<li>my-test-cm-manifest.yaml 파일에서 configmap을 업데이트하세요.</li>\n</ol>\n<pre><code class=\"hljs language-yaml\"><span class=\"hljs-meta\">---</span>\n<span class=\"hljs-attr\">apiVersion:</span> <span class=\"hljs-string\">v1</span>\n<span class=\"hljs-attr\">kind:</span> <span class=\"hljs-string\">ConfigMap</span>\n<span class=\"hljs-attr\">metadata:</span>\n  <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">my-test-k8s-cm</span>\n<span class=\"hljs-attr\">data:</span>\n  <span class=\"hljs-attr\">myvalue:</span> <span class=\"hljs-string\">\"안녕하세요\"</span>\n  <span class=\"hljs-attr\">drink:</span> <span class=\"hljs-string\">차</span>\n</code></pre>\n<ol start=\"4\">\n<li>파일을 다시 적용하세요.</li>\n</ol>\n<pre><code class=\"hljs language-yaml\"><span class=\"hljs-string\">kubectl</span> <span class=\"hljs-string\">apply</span> <span class=\"hljs-string\">-f</span> <span class=\"hljs-string\">my-test-cm-manifest.yaml</span>\n</code></pre>\n<p></p>\n<ol start=\"5\">\n<li>확인</li>\n</ol>\n<pre><code class=\"hljs language-js\"># <span class=\"hljs-title class_\">ConfigMap</span> 확인\nkubectl get cm my-test-k8s-cm -o yaml\n\n# <span class=\"hljs-title class_\">Pod</span> 확인\nkubectl get po\n\n# <span class=\"hljs-title class_\">Pod</span>에 접속하여 새 값 확인\nkubectl exec -it &#x3C;pod_name> -- bash\n\n# <span class=\"hljs-title class_\">Pod</span>에 들어간 후 <span class=\"hljs-string\">`env`</span> 명령어를 실행하면 <span class=\"hljs-title class_\">Pod</span> 내에서 사용 가능한 모든 환경 변수가 출력됩니다\n</code></pre>\n<p>축하합니다!!! secret-store-csi-driver와 reloader를 성공적으로 구성했습니다.</p>\n<p>감사합니다!!!</p>\n<p></p>\n<h2>참고 자료:</h2>\n<ul>\n<li><a href=\"https://docs.aws.amazon.com/secretsmanager/latest/userguide/integrating_csi_driver.html\" rel=\"nofollow\" target=\"_blank\">AWS 공식 문서 - CSI 드라이버 통합</a></li>\n<li><a href=\"https://blog.bootlabstech.com/aws-secrets-manager-in-kubernetes-secret-rotation-and-reloader\" rel=\"nofollow\" target=\"_blank\">Bootlabs 기술 블로그 - AWS Secrets Manager in Kubernetes 시크릿 회전과 리로더</a></li>\n<li><a href=\"https://secrets-store-csi-driver.sigs.k8s.io/topics/secret-auto-rotation\" rel=\"nofollow\" target=\"_blank\">Secrets Store CSI 드라이버 공식 홈페이지 - 시크릿 자동 회전</a></li>\n<li><a href=\"https://github.com/kubernetes-sigs/secrets-store-csi-driver/blob/main/charts/secrets-store-csi-driver/values.yaml\" rel=\"nofollow\" target=\"_blank\">Secrets Store CSI 드라이버 차트 값 설정 파일</a></li>\n<li><a href=\"https://github.com/stakater/Reloader/tree/master\" rel=\"nofollow\" target=\"_blank\">Reloader GitHub 저장소</a></li>\n<li><a href=\"https://github.com/stakater/Reloader/blob/master/docs/Verify-Reloader-Working.md\" rel=\"nofollow\" target=\"_blank\">Reloader 작동 확인 문서</a></li>\n<li><a href=\"https://github.com/stakater/Reloader/blob/master/docs/How-it-works.md\" rel=\"nofollow\" target=\"_blank\">Reloader 작동 방식 문서</a></li>\n</ul>\n<h1>간단히 말하자면 🚀</h1>\n<p>In Plain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 계속 참여해 주세요:</p>\n<p></p>\n<ul>\n<li>작가에게 박수를 보내고 팔로우를 눌러주세요 ️👏️️</li>\n<li>팔로우하기: X | LinkedIn | YouTube | Discord | Newsletter</li>\n<li>다른 플랫폼에서 저희를 만나보세요: Stackademic | CoFeed | Venture | Cubed</li>\n<li>알고리즘 콘텐츠를 다뤄야 하는 블로그 플랫폼에 지쳤나요? Differ를 시도해보세요</li>\n<li>PlainEnglish.io에서 더 많은 콘텐츠를 만나보세요</li>\n</ul>\n</body>\n</html>\n"},"__N_SSG":true}