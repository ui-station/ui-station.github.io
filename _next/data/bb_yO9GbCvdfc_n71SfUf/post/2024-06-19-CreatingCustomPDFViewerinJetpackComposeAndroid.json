{"pageProps":{"post":{"title":"Jetpack Compose 안드로이드에서 사용자 지정 PDF 뷰어 만들기","description":"","date":"2024-06-19 13:43","slug":"2024-06-19-CreatingCustomPDFViewerinJetpackComposeAndroid","content":"\n![PDFViewer](/assets/img/2024-06-19-CreatingCustomPDFViewerinJetpackComposeAndroid_0.png)\n\nPDF는 우리가 매일 사용하는 가장 일반적인 파일 형식 중 하나입니다. 그러나 Jetpack Compose에서 공식 PDF 뷰어가 아직 없습니다. 그렇다면 왜 만들지 않을까요?\n\n## 어떻게 가능한가요?\n\n우리의 계획 개요를 살펴봅시다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- PDF 파일이 있는 원격 URL 또는 전화 저장소가 있습니다.\n- 하나씩 페이지를 보여줄 수 있습니다.\n- 페이지는 확대 및 이동할 수 있어야 합니다.\n- 서버 PDF를 로컬 캐시/저장소에 다운로드하고 저장해야 합니다.\n- PDF를 '페이지'를 나타내는 '비트맵' 목록으로 변환할 수 있습니다.\n- 그런 다음 간단히, 비트맵을 지원하는 이미지 컴포저블을 사용하여 세로로 페이지를 하나씩 모두 표시할 것입니다.\n\n## 단계 1: PDF 다운로드 및 저장\n\n이 시점에서 PDF의 URL만 있습니다. 이를 다운로드하는 기능을 만들어 보겠습니다.\n\n먼저 AndroidManifest.xml에 다음 권한을 추가하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```java\n<uses-permission android:name=\"android.permission.INTERNET\" />\n<uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" />\n```\n\n우리는 HttpURLConnection 객체를 사용하여 연결을 설정하고 InputStream을 가져올 것입니다.\n\n```java\nval connection = URL(url).openConnection() as HttpURLConnection\nconnection.connect()\n```\n\n위의 코드들이 작동하여 PDF 파일을 가져올 것입니다. 작업이 완료되었고 필요한 Input stream을 얻었는지 확인해보세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\nif (connection.responseCode != HttpURLConnection.HTTP_OK) {\n    connection.disconnect()\n    return@withContext null\n}\n\nval inputStream = connection.inputStream\n```\n\n작업이 끝나면 꼭 연결을 끊어 주세요.\n\n```kotlin\nconnection.disconnect()\n```\n\n이제 다운로드 부분이 완료되었으니 사용자의 로컬 스토리지에 저장해주세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\nfile = File.createTempFile(fileName, \".pdf\")\nval outputStream = FileOutputStream(file)\ninputStream.copyTo(outputStream)\noutputStream.close()\n```\n\n변경 후 전체 함수는 다음과 같습니다:\n\n```kotlin\nsuspend fun downloadAndGetFile(url: String, fileName: String): File? {\n    if (isFileExist(fileName)) return File(fileName) // 이 줄은 중복 파일 생성을 피하기 위해 중요합니다.\n    var connection: HttpURLConnection? = null\n    var file: File? = null\n    try {\n        withContext(Dispatchers.IO) {\n            connection = URL(url).openConnection() as HttpURLConnection\n            connection!!.connect()\n\n            if (connection!!.responseCode != HttpURLConnection.HTTP_OK) {\n                return@withContext null\n            }\n\n            val inputStream = connection!!.inputStream\n            file = File.createTempFile(fileName, \".pdf\")\n            val outputStream = FileOutputStream(file)\n            inputStream.copyTo(outputStream)\n            outputStream.close()\n        }\n    } catch (e: IOException) {\n        // UI에 응답을 전송합니다.\n    } finally {\n        connection?.disconnect()\n    }\n    return file\n}\n```\n\n```kotlin\nfun isFileExist(path: String): Boolean {\n    val file = File(path)\n    return file.exists()\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 단계 2: 파일 객체를 List`Bitmap`으로 변환합니다.\n\n이 변환에는 PdfRenderer 클래스를 사용할 것입니다:\n\n```js\nPdfRenderer renderer = new PdfRenderer(ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_READ_ONLY));\n```\n\n하지만 이것을 직접 사용하는 것은 Jetpack Compose에서 좋지 않고 많은 RAM을 소비할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그럼 다음과 같이 사용할 것입니다:\n\n```js\nval rendererScope = rememberCoroutineScope()\nval mutex = remember { Mutex() }\nval renderer by produceState<PdfRenderer?>(null, file) {\n    rendererScope.launch(Dispatchers.IO) {\n        val input = ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_READ_ONLY)\n        value = PdfRenderer(input)\n    }\n    awaitDispose {\n        val currentRenderer = value\n        rendererScope.launch(Dispatchers.IO) {\n            mutex.withLock {\n                currentRenderer?.close()\n            }\n        }\n    }\n}\n```\n\n이제 우리가 만든 \"PDFRenderer\" 객체인 \"renderer\"를 사용하여 모든 페이지를 가져와 비트맵 객체에 렌더링할 것입니다.\n\n```js\nrenderer?.let {\n    it.openPage(index).use { page ->\n        page.render(destinationBitmap, null, null, PdfRenderer.Page.RENDER_MODE_FOR_DISPLAY)\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 모든 페이지에 대한 비트맵을 가져올 수 있습니다. UI에서 모든 페이지에 표시할 시간입니다.\n\n## 단계 3: UI에 목록`비트맵` 표시 + 줌 및 이동 기능 추가:\n\nPDFViewer Composable의 전체 코드가 필요하면 이를 참조하십시오:\n\n여기서 설명이 시작됩니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- BoxWithConstraints를 사용하는 이유는 페이지의 높이와 너비를 정의하고 줌 및 이동을 위해 화면의 높이와 너비가 필요하기 때문입니다.\n\n```js\n            val width = with(LocalDensity.current) { maxWidth.toPx() }.toInt()\n            val height = (width * sqrt(2f)).toInt()\n            val pageCount by remember(renderer) { derivedStateOf { renderer?.pageCount ?: 0 } }//Used ahead\n\n            var scale by rememberSaveable {\n                mutableFloatStateOf(1f)\n            }\n            var offset by remember {\n                mutableStateOf(Offset.Zero)\n            }\n            val state = //Used for Zoom and Move\n                rememberTransformableState { zoomChange, panChange, rotationChange ->\n                    scale = (scale * zoomChange).coerceIn(1f, 5f)\n\n                    val extraWidth = (scale - 1) * constraints.maxWidth\n                    val extraHeight = (scale - 1) * constraints.maxHeight\n\n                    val maxX = extraWidth / 2\n                    val maxY = extraHeight / 2\n\n                    offset = Offset(\n                        x = (offset.x + scale * panChange.x).coerceIn(-maxX, maxX),\n                        y = (offset.y + scale * panChange.y).coerceIn(-maxY, maxY),\n                    )\n                }\n```\n\nZoom 구현을 자세히 이해하려면 이 비디오를 시청하세요.\n\n2. 이 상태를 LazyColumn과 함께 간단히 사용하고 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\n            LazyColumn(\n                modifier = Modifier\n                    .fillMaxSize()\n                    .graphicsLayer {\n                        scaleX = scale\n                        scaleY = scale\n                        translationX = offset.x\n                        translationX = offset.y\n                    }\n                    .transformable(state)\n```\n\n3. 호출할 때 이미 PDF 파일을 다운로드하고 저장했습니다.\n\n```kotlin\nLaunchedEffect(key1 = Unit) {\n        file = async { downloadAndGetFile(url, fileName) }.await()\n    }\n```\n\n4. \"cacheKey\"로부터 Bitmap 객체를 만들어야 합니다. 이미지도 캐시에 저장될 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\nval cacheKey = MemoryCache.Key(\"${file!!.name}-$index\")\nval cacheValue: Bitmap? = imageLoader.memoryCache?.get(cacheKey)?.bitmap\nvar bitmap: Bitmap? by remember { mutableStateOf(cacheValue) }\n```\n\n5. 이후에는 각 페이지의 비트맵을 가져와 Coil ImageRequest 객체로 표시합니다.\n\n```kotlin\nval request = ImageRequest.Builder(context)\n    .size(width, height)\n    .memoryCacheKey(cacheKey)\n    .data(bitmap)\n    .build()\n\nImage(\n    modifier = Modifier\n        .background(Color.Transparent)\n        .border(1.dp, MaterialTheme.colors.background)\n//        .aspectRatio(1f / sqrt(2f))\n        .fillMaxSize(),\n    contentScale = ContentScale.Fit,\n    painter = rememberAsyncImagePainter(request),\n    contentDescription = \"Page ${index + 1} of $pageCount\"\n)\n```\n\n나머지 부분은 상당히 직관적이고 이해하기 쉽습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여기서 새로운 것을 배웠다면, 좋다면 팔로우 버튼을 눌러 주세요.\n","ogImage":{"url":"/assets/img/2024-06-19-CreatingCustomPDFViewerinJetpackComposeAndroid_0.png"},"coverImage":"/assets/img/2024-06-19-CreatingCustomPDFViewerinJetpackComposeAndroid_0.png","tag":["Tech"],"readingTime":10},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p><img src=\"/assets/img/2024-06-19-CreatingCustomPDFViewerinJetpackComposeAndroid_0.png\" alt=\"PDFViewer\"></p>\n<p>PDF는 우리가 매일 사용하는 가장 일반적인 파일 형식 중 하나입니다. 그러나 Jetpack Compose에서 공식 PDF 뷰어가 아직 없습니다. 그렇다면 왜 만들지 않을까요?</p>\n<h2>어떻게 가능한가요?</h2>\n<p>우리의 계획 개요를 살펴봅시다:</p>\n<p></p>\n<ul>\n<li>PDF 파일이 있는 원격 URL 또는 전화 저장소가 있습니다.</li>\n<li>하나씩 페이지를 보여줄 수 있습니다.</li>\n<li>페이지는 확대 및 이동할 수 있어야 합니다.</li>\n<li>서버 PDF를 로컬 캐시/저장소에 다운로드하고 저장해야 합니다.</li>\n<li>PDF를 '페이지'를 나타내는 '비트맵' 목록으로 변환할 수 있습니다.</li>\n<li>그런 다음 간단히, 비트맵을 지원하는 이미지 컴포저블을 사용하여 세로로 페이지를 하나씩 모두 표시할 것입니다.</li>\n</ul>\n<h2>단계 1: PDF 다운로드 및 저장</h2>\n<p>이 시점에서 PDF의 URL만 있습니다. 이를 다운로드하는 기능을 만들어 보겠습니다.</p>\n<p>먼저 AndroidManifest.xml에 다음 권한을 추가하세요.</p>\n<p></p>\n<pre><code class=\"hljs language-java\">&#x3C;uses-permission android:name=<span class=\"hljs-string\">\"android.permission.INTERNET\"</span> />\n&#x3C;uses-permission android:name=<span class=\"hljs-string\">\"android.permission.ACCESS_NETWORK_STATE\"</span> />\n</code></pre>\n<p>우리는 HttpURLConnection 객체를 사용하여 연결을 설정하고 InputStream을 가져올 것입니다.</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-type\">val</span> <span class=\"hljs-variable\">connection</span> <span class=\"hljs-operator\">=</span> URL(url).openConnection() as HttpURLConnection\nconnection.connect()\n</code></pre>\n<p>위의 코드들이 작동하여 PDF 파일을 가져올 것입니다. 작업이 완료되었고 필요한 Input stream을 얻었는지 확인해보세요.</p>\n<p></p>\n<pre><code class=\"hljs language-kotlin\"><span class=\"hljs-keyword\">if</span> (connection.responseCode != HttpURLConnection.HTTP_OK) {\n    connection.disconnect()\n    <span class=\"hljs-keyword\">return</span><span class=\"hljs-symbol\">@withContext</span> <span class=\"hljs-literal\">null</span>\n}\n\n<span class=\"hljs-keyword\">val</span> inputStream = connection.inputStream\n</code></pre>\n<p>작업이 끝나면 꼭 연결을 끊어 주세요.</p>\n<pre><code class=\"hljs language-kotlin\">connection.disconnect()\n</code></pre>\n<p>이제 다운로드 부분이 완료되었으니 사용자의 로컬 스토리지에 저장해주세요.</p>\n<p></p>\n<pre><code class=\"hljs language-kotlin\">file = File.createTempFile(fileName, <span class=\"hljs-string\">\".pdf\"</span>)\n<span class=\"hljs-keyword\">val</span> outputStream = FileOutputStream(file)\ninputStream.copyTo(outputStream)\noutputStream.close()\n</code></pre>\n<p>변경 후 전체 함수는 다음과 같습니다:</p>\n<pre><code class=\"hljs language-kotlin\"><span class=\"hljs-keyword\">suspend</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">downloadAndGetFile</span><span class=\"hljs-params\">(url: <span class=\"hljs-type\">String</span>, fileName: <span class=\"hljs-type\">String</span>)</span></span>: File? {\n    <span class=\"hljs-keyword\">if</span> (isFileExist(fileName)) <span class=\"hljs-keyword\">return</span> File(fileName) <span class=\"hljs-comment\">// 이 줄은 중복 파일 생성을 피하기 위해 중요합니다.</span>\n    <span class=\"hljs-keyword\">var</span> connection: HttpURLConnection? = <span class=\"hljs-literal\">null</span>\n    <span class=\"hljs-keyword\">var</span> file: File? = <span class=\"hljs-literal\">null</span>\n    <span class=\"hljs-keyword\">try</span> {\n        withContext(Dispatchers.IO) {\n            connection = URL(url).openConnection() <span class=\"hljs-keyword\">as</span> HttpURLConnection\n            connection!!.connect()\n\n            <span class=\"hljs-keyword\">if</span> (connection!!.responseCode != HttpURLConnection.HTTP_OK) {\n                <span class=\"hljs-keyword\">return</span><span class=\"hljs-symbol\">@withContext</span> <span class=\"hljs-literal\">null</span>\n            }\n\n            <span class=\"hljs-keyword\">val</span> inputStream = connection!!.inputStream\n            file = File.createTempFile(fileName, <span class=\"hljs-string\">\".pdf\"</span>)\n            <span class=\"hljs-keyword\">val</span> outputStream = FileOutputStream(file)\n            inputStream.copyTo(outputStream)\n            outputStream.close()\n        }\n    } <span class=\"hljs-keyword\">catch</span> (e: IOException) {\n        <span class=\"hljs-comment\">// UI에 응답을 전송합니다.</span>\n    } <span class=\"hljs-keyword\">finally</span> {\n        connection?.disconnect()\n    }\n    <span class=\"hljs-keyword\">return</span> file\n}\n</code></pre>\n<pre><code class=\"hljs language-kotlin\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">isFileExist</span><span class=\"hljs-params\">(path: <span class=\"hljs-type\">String</span>)</span></span>: <span class=\"hljs-built_in\">Boolean</span> {\n    <span class=\"hljs-keyword\">val</span> file = File(path)\n    <span class=\"hljs-keyword\">return</span> file.exists()\n}\n</code></pre>\n<p></p>\n<h2>단계 2: 파일 객체를 List<code>Bitmap</code>으로 변환합니다.</h2>\n<p>이 변환에는 PdfRenderer 클래스를 사용할 것입니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title class_\">PdfRenderer</span> renderer = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">PdfRenderer</span>(<span class=\"hljs-title class_\">ParcelFileDescriptor</span>.<span class=\"hljs-title function_\">open</span>(file, <span class=\"hljs-title class_\">ParcelFileDescriptor</span>.<span class=\"hljs-property\">MODE_READ_ONLY</span>));\n</code></pre>\n<p>하지만 이것을 직접 사용하는 것은 Jetpack Compose에서 좋지 않고 많은 RAM을 소비할 수 있습니다.</p>\n<p></p>\n<p>그럼 다음과 같이 사용할 것입니다:</p>\n<pre><code class=\"hljs language-js\">val rendererScope = <span class=\"hljs-title function_\">rememberCoroutineScope</span>()\nval mutex = remember { <span class=\"hljs-title class_\">Mutex</span>() }\nval renderer by produceState&#x3C;<span class=\"hljs-title class_\">PdfRenderer</span>?>(<span class=\"hljs-literal\">null</span>, file) {\n    rendererScope.<span class=\"hljs-title function_\">launch</span>(<span class=\"hljs-params\">Dispatchers.IO</span>) {\n        val input = <span class=\"hljs-title class_\">ParcelFileDescriptor</span>.<span class=\"hljs-title function_\">open</span>(file, <span class=\"hljs-title class_\">ParcelFileDescriptor</span>.<span class=\"hljs-property\">MODE_READ_ONLY</span>)\n        value = <span class=\"hljs-title class_\">PdfRenderer</span>(input)\n    }\n    awaitDispose {\n        val currentRenderer = value\n        rendererScope.<span class=\"hljs-title function_\">launch</span>(<span class=\"hljs-params\">Dispatchers.IO</span>) {\n            mutex.<span class=\"hljs-property\">withLock</span> {\n                currentRenderer?.<span class=\"hljs-title function_\">close</span>()\n            }\n        }\n    }\n}\n</code></pre>\n<p>이제 우리가 만든 \"PDFRenderer\" 객체인 \"renderer\"를 사용하여 모든 페이지를 가져와 비트맵 객체에 렌더링할 것입니다.</p>\n<pre><code class=\"hljs language-js\">renderer?.<span class=\"hljs-property\">let</span> {\n    it.<span class=\"hljs-title function_\">openPage</span>(index).<span class=\"hljs-property\">use</span> { page ->\n        page.<span class=\"hljs-title function_\">render</span>(destinationBitmap, <span class=\"hljs-literal\">null</span>, <span class=\"hljs-literal\">null</span>, <span class=\"hljs-title class_\">PdfRenderer</span>.<span class=\"hljs-property\">Page</span>.<span class=\"hljs-property\">RENDER_MODE_FOR_DISPLAY</span>)\n    }\n}\n</code></pre>\n<p></p>\n<p>이제 모든 페이지에 대한 비트맵을 가져올 수 있습니다. UI에서 모든 페이지에 표시할 시간입니다.</p>\n<h2>단계 3: UI에 목록<code>비트맵</code> 표시 + 줌 및 이동 기능 추가:</h2>\n<p>PDFViewer Composable의 전체 코드가 필요하면 이를 참조하십시오:</p>\n<p>여기서 설명이 시작됩니다:</p>\n<p></p>\n<ul>\n<li>BoxWithConstraints를 사용하는 이유는 페이지의 높이와 너비를 정의하고 줌 및 이동을 위해 화면의 높이와 너비가 필요하기 때문입니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\">            val width = <span class=\"hljs-title function_\">with</span>(<span class=\"hljs-params\">LocalDensity.current</span>) { maxWidth.<span class=\"hljs-title function_\">toPx</span>() }.<span class=\"hljs-title function_\">toInt</span>()\n            val height = (width * <span class=\"hljs-title function_\">sqrt</span>(2f)).<span class=\"hljs-title function_\">toInt</span>()\n            val pageCount by <span class=\"hljs-title function_\">remember</span>(<span class=\"hljs-params\">renderer</span>) { derivedStateOf { renderer?.<span class=\"hljs-property\">pageCount</span> ?: <span class=\"hljs-number\">0</span> } }<span class=\"hljs-comment\">//Used ahead</span>\n\n            <span class=\"hljs-keyword\">var</span> scale by rememberSaveable {\n                <span class=\"hljs-title function_\">mutableFloatStateOf</span>(1f)\n            }\n            <span class=\"hljs-keyword\">var</span> offset by remember {\n                <span class=\"hljs-title function_\">mutableStateOf</span>(<span class=\"hljs-title class_\">Offset</span>.<span class=\"hljs-property\">Zero</span>)\n            }\n            val state = <span class=\"hljs-comment\">//Used for Zoom and Move</span>\n                rememberTransformableState { zoomChange, panChange, rotationChange ->\n                    scale = (scale * zoomChange).<span class=\"hljs-title function_\">coerceIn</span>(1f, 5f)\n\n                    val extraWidth = (scale - <span class=\"hljs-number\">1</span>) * constraints.<span class=\"hljs-property\">maxWidth</span>\n                    val extraHeight = (scale - <span class=\"hljs-number\">1</span>) * constraints.<span class=\"hljs-property\">maxHeight</span>\n\n                    val maxX = extraWidth / <span class=\"hljs-number\">2</span>\n                    val maxY = extraHeight / <span class=\"hljs-number\">2</span>\n\n                    offset = <span class=\"hljs-title class_\">Offset</span>(\n                        x = (offset.<span class=\"hljs-property\">x</span> + scale * panChange.<span class=\"hljs-property\">x</span>).<span class=\"hljs-title function_\">coerceIn</span>(-maxX, maxX),\n                        y = (offset.<span class=\"hljs-property\">y</span> + scale * panChange.<span class=\"hljs-property\">y</span>).<span class=\"hljs-title function_\">coerceIn</span>(-maxY, maxY),\n                    )\n                }\n</code></pre>\n<p>Zoom 구현을 자세히 이해하려면 이 비디오를 시청하세요.</p>\n<ol start=\"2\">\n<li>이 상태를 LazyColumn과 함께 간단히 사용하고 있습니다:</li>\n</ol>\n<p></p>\n<pre><code class=\"hljs language-kotlin\">            LazyColumn(\n                modifier = Modifier\n                    .fillMaxSize()\n                    .graphicsLayer {\n                        scaleX = scale\n                        scaleY = scale\n                        translationX = offset.x\n                        translationX = offset.y\n                    }\n                    .transformable(state)\n</code></pre>\n<ol start=\"3\">\n<li>호출할 때 이미 PDF 파일을 다운로드하고 저장했습니다.</li>\n</ol>\n<pre><code class=\"hljs language-kotlin\">LaunchedEffect(key1 = <span class=\"hljs-built_in\">Unit</span>) {\n        file = async { downloadAndGetFile(url, fileName) }.await()\n    }\n</code></pre>\n<ol start=\"4\">\n<li>\"cacheKey\"로부터 Bitmap 객체를 만들어야 합니다. 이미지도 캐시에 저장될 것입니다.</li>\n</ol>\n<p></p>\n<pre><code class=\"hljs language-kotlin\"><span class=\"hljs-keyword\">val</span> cacheKey = MemoryCache.Key(<span class=\"hljs-string\">\"<span class=\"hljs-subst\">${file!!.name}</span>-<span class=\"hljs-variable\">$index</span>\"</span>)\n<span class=\"hljs-keyword\">val</span> cacheValue: Bitmap? = imageLoader.memoryCache?.<span class=\"hljs-keyword\">get</span>(cacheKey)?.bitmap\n<span class=\"hljs-keyword\">var</span> bitmap: Bitmap? <span class=\"hljs-keyword\">by</span> remember { mutableStateOf(cacheValue) }\n</code></pre>\n<ol start=\"5\">\n<li>이후에는 각 페이지의 비트맵을 가져와 Coil ImageRequest 객체로 표시합니다.</li>\n</ol>\n<pre><code class=\"hljs language-kotlin\"><span class=\"hljs-keyword\">val</span> request = ImageRequest.Builder(context)\n    .size(width, height)\n    .memoryCacheKey(cacheKey)\n    .<span class=\"hljs-keyword\">data</span>(bitmap)\n    .build()\n\nImage(\n    modifier = Modifier\n        .background(Color.Transparent)\n        .border(<span class=\"hljs-number\">1.</span>dp, MaterialTheme.colors.background)\n<span class=\"hljs-comment\">//        .aspectRatio(1f / sqrt(2f))</span>\n        .fillMaxSize(),\n    contentScale = ContentScale.Fit,\n    painter = rememberAsyncImagePainter(request),\n    contentDescription = <span class=\"hljs-string\">\"Page <span class=\"hljs-subst\">${index + <span class=\"hljs-number\">1</span>}</span> of <span class=\"hljs-variable\">$pageCount</span>\"</span>\n)\n</code></pre>\n<p>나머지 부분은 상당히 직관적이고 이해하기 쉽습니다.</p>\n<p></p>\n<p>여기서 새로운 것을 배웠다면, 좋다면 팔로우 버튼을 눌러 주세요.</p>\n</body>\n</html>\n"},"__N_SSG":true}