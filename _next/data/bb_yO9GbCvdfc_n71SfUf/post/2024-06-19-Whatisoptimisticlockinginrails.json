{"pageProps":{"post":{"title":"Rails에서 낙관적 락킹은 무엇인가요","description":"","date":"2024-06-19 22:17","slug":"2024-06-19-Whatisoptimisticlockinginrails","content":"\n낙관적 락킹은 데이터베이스 시스템에서 동시에 여러 사용자가 데이터에 동시 액세스를 관리하는 동시성 제어 메커니즘입니다. 충돌이 드물고 트랜잭션이 일반적으로 서로 간섭하지 않을 것으로 가정합니다. 비관적 락킹과 달리 최적적 락킹은 데이터를 처음 액세스할 때 잠그는 대신, 트랜잭션이 커밋하려고 할 때만 충돌을 확인합니다.\n\n다음은 작동 방식입니다:\n\n- 트랜잭션 시작: 트랜잭션이 레코드를 읽을 때 해당 레코드와 연관된 버전 번호 또는 타임스탬프도 검색합니다.\n- 트랜잭션 처리: 트랜잭션은 데이터를 로컬로 변경합니다.\n- 커밋: 커밋하기 전에 트랜잭션은 데이터베이스에서 레코드의 버전 번호 또는 타임스탬프를 확인합니다:\n\n  - 트랜잭션이 시작되었을 때 버전 번호나 타임스탬프가 변경되지 않았다면, 트랜잭션은 변경 사항을 커밋합니다.\n  - 버전 번호나 타임스탬프가 변경되었다면 (다른 트랜잭션이 레코드를 수정했다는 것을 나타냄), 해당 트랜잭션은 중지되고 다시 시도해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 낙관적 락킹 예시\n\n간단한 예시로 온라인 상점의 제품을 위한 데이터베이스 테이블을 고려해 봅시다:\n\n## 제품 테이블:\n\n![Products Table](/assets/img/2024-06-19-Whatisoptimisticlockinginrails_0.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 시나리오\n\n- 사용자 A는 버전 번호가 1인 \"위젯\"(ProductID=1)의 제품 세부 정보를 읽습니다.\n- 사용자 B는 동일한 제품 \"위젯\"의 버전 번호가 1인 제품 세부 정보를 읽습니다.\n- 사용자 A가 \"위젯\"의 가격을 $12.00으로 업데이트하고 트랜잭션을 커밋하려고 합니다:\n\n- 시스템은 데이터베이스 내 \"위젯\"의 현재 버전 번호를 확인합니다(아직 1).\n- 버전 번호가 일치하므로 업데이트가 진행되고, 가격이 $12.00으로 설정되고, 버전 번호가 2로 증가합니다.\n\n4. 이제 사용자 B가 \"위젯\"의 가격을 $11.00으로 업데이트하려고 합니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 시스템은 데이터베이스에서 \"위젯\"의 현재 버전 번호를 확인합니다 (현재 2).\n- 버전 번호가 변경되었으므로 다른 트랜잭션이 레코드를 수정했다는 것을 나타내어, 사용자 B의 트랜잭션이 실패합니다.\n- 사용자 B는 업데이트된 레코드(버전 2)를 읽어 트랜잭션을 다시 시도해야 합니다.\n\n# 장단점\n\n장점:\n\n- Non-blocking: 낙관적 잠금은 잠금을 유지하는 오버헤드를 피함으로써 여러 사용자가 대기없이 동일한 데이터로 작업할 수 있습니다.\n- 확장성: 충돌 비율이 낮은 환경에서 더 확장 가능하며, 이는 리소스에 대한 경합을 줄여줍니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n단점:\n\n- 다시 시도 필요: 충돌이 커밋 시간에 감지되면 트랜잭션이 다시 시도될 수 있습니다.\n- 고 갈등 환경에 적합하지 않음: 고 갈등 환경에서는 충돌 가능성이 증가하여 더 자주 다시 시도하게 되고 성능이 감소할 수 있습니다.\n\n다음은 루비 온 레일즈에서 낙관적 잠금을 구현하는 예시입니다.\n\n우리가 제품 테이블을 가지고 있다고 가정해봅시다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```ruby\nclass CreateProducts < ActiveRecord::Migration[6.1]\n  def change\n    create_table :products do |t|\n      t.string :name\n      t.decimal :price, precision: 8, scale: 2\n      t.integer :lock_version, default: 0, null: false\n\n      t.timestamps\n    end\n  end\nend\n```\n\n## 모델 정의\n\n다음으로 Product 모델을 정의하세요. lock_version 열은 Rails에서 낙관적 락킹에 자동으로 사용됩니다.\n\n```ruby\nclass Product < ApplicationRecord\nend\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 예시 사용법\n\n담아 두고 있는 상황에서는 어떻게 낙관적 락을 사용할 수 있을까요:\n\n## 사용자 A와 사용자 B가 동일한 레코드를 읽고 있는 경우\n\n```js\n# 사용자 A\nuser_a_product = Product.find(1) # id가 1인 제품을 읽음\n# user_a_product.lock_version은 0입니다\n\n# 사용자 B\nuser_b_product = Product.find(1) # 동일한 제품을 읽음\n# user_b_product.lock_version도 0입니다\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 사용자 A가 레코드를 업데이트합니다\n\n```js\n# 사용자 A가 가격을 업데이트합니다\nuser_a_product.price = 12.00\nuser_a_product.save\n# 이로써 lock_version이 1로 증가합니다\n```\n\n## 사용자 B가 레코드를 업데이트하려고 합니다\n\n```js\n# 사용자 B가 가격을 업데이트하려고 합니다\nuser_b_product.price = 11.00\nbegin\n  user_b_product.save\nrescue ActiveRecord::StaleObjectError\n  puts \"이전 정보가 감지되었습니다.\"\n  # 충돌을 처리하기 위해 레코드를 다시 불러와서 재시도할 수 있습니다\n  user_b_product.reload\n  # 이제 user_b_product.lock_version은 1입니다\n  # 사용자 B가 업데이트를 다시 시도할지 결정할 수 있습니다\nend\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 충돌 처리\n\nActiveRecord::StaleObjectError가 발생하면, 해당 레코드가 읽힌 후 다른 트랜잭션에 의해 수정되었음을 나타냅니다. 이를 처리하기 위해 레코드를 다시 불러오고 사용자에게 알릴 수도 있으며, 트랜잭션을 다시 시도하거나 애플리케이션 로직에 따라 변경 사항을 병합할 수 있습니다.\n\n## 완전한 예제\n\n```js\nclass ProductsController < ApplicationController\n  def update\n    @product = Product.find(params[:id])\n    @product.assign_attributes(product_params)\n\n    begin\n      @product.save\n      flash[:notice] = \"제품이 성공적으로 업데이트되었습니다.\"\n    rescue ActiveRecord::StaleObjectError\n      flash[:alert] = \"제품이 다른 사용자에 의해 업데이트되었습니다. 변경 사항을 검토하고 다시 시도해주세요.\"\n      @product.reload\n      # 선택적으로 사용자의 변경 사항을 다시 적용하고 통합된 양식을 사용자에게 제시할 수 있음\n    end\n\n    redirect_to @product\n  end\n\n  private\n\n  def product_params\n    params.require(:product).permit(:name, :price)\n  end\nend\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 결론\n\n이 예는 Ruby on Rails 애플리케이션에서 낙관적 잠금을 사용하는 방법을 보여줍니다. lock_version 열을 포함하고 Active Record의 내장 메커니즘을 사용하여 Rails는 버전 확인을 자동으로 처리하고 충돌이 감지되면 예외를 발생시킵니다. 이를 통해 애플리케이션이 적절하게 처리할 수 있도록 합니다.\n","ogImage":{"url":"/assets/img/2024-06-19-Whatisoptimisticlockinginrails_0.png"},"coverImage":"/assets/img/2024-06-19-Whatisoptimisticlockinginrails_0.png","tag":["Tech"],"readingTime":7},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p>낙관적 락킹은 데이터베이스 시스템에서 동시에 여러 사용자가 데이터에 동시 액세스를 관리하는 동시성 제어 메커니즘입니다. 충돌이 드물고 트랜잭션이 일반적으로 서로 간섭하지 않을 것으로 가정합니다. 비관적 락킹과 달리 최적적 락킹은 데이터를 처음 액세스할 때 잠그는 대신, 트랜잭션이 커밋하려고 할 때만 충돌을 확인합니다.</p>\n<p>다음은 작동 방식입니다:</p>\n<ul>\n<li>\n<p>트랜잭션 시작: 트랜잭션이 레코드를 읽을 때 해당 레코드와 연관된 버전 번호 또는 타임스탬프도 검색합니다.</p>\n</li>\n<li>\n<p>트랜잭션 처리: 트랜잭션은 데이터를 로컬로 변경합니다.</p>\n</li>\n<li>\n<p>커밋: 커밋하기 전에 트랜잭션은 데이터베이스에서 레코드의 버전 번호 또는 타임스탬프를 확인합니다:</p>\n<ul>\n<li>트랜잭션이 시작되었을 때 버전 번호나 타임스탬프가 변경되지 않았다면, 트랜잭션은 변경 사항을 커밋합니다.</li>\n<li>버전 번호나 타임스탬프가 변경되었다면 (다른 트랜잭션이 레코드를 수정했다는 것을 나타냄), 해당 트랜잭션은 중지되고 다시 시도해야 합니다.</li>\n</ul>\n</li>\n</ul>\n<p></p>\n<h1>낙관적 락킹 예시</h1>\n<p>간단한 예시로 온라인 상점의 제품을 위한 데이터베이스 테이블을 고려해 봅시다:</p>\n<h2>제품 테이블:</h2>\n<p><img src=\"/assets/img/2024-06-19-Whatisoptimisticlockinginrails_0.png\" alt=\"Products Table\"></p>\n<p></p>\n<h2>시나리오</h2>\n<ul>\n<li>\n<p>사용자 A는 버전 번호가 1인 \"위젯\"(ProductID=1)의 제품 세부 정보를 읽습니다.</p>\n</li>\n<li>\n<p>사용자 B는 동일한 제품 \"위젯\"의 버전 번호가 1인 제품 세부 정보를 읽습니다.</p>\n</li>\n<li>\n<p>사용자 A가 \"위젯\"의 가격을 $12.00으로 업데이트하고 트랜잭션을 커밋하려고 합니다:</p>\n</li>\n<li>\n<p>시스템은 데이터베이스 내 \"위젯\"의 현재 버전 번호를 확인합니다(아직 1).</p>\n</li>\n<li>\n<p>버전 번호가 일치하므로 업데이트가 진행되고, 가격이 $12.00으로 설정되고, 버전 번호가 2로 증가합니다.</p>\n</li>\n</ul>\n<ol start=\"4\">\n<li>이제 사용자 B가 \"위젯\"의 가격을 $11.00으로 업데이트하려고 합니다:</li>\n</ol>\n<p></p>\n<ul>\n<li>시스템은 데이터베이스에서 \"위젯\"의 현재 버전 번호를 확인합니다 (현재 2).</li>\n<li>버전 번호가 변경되었으므로 다른 트랜잭션이 레코드를 수정했다는 것을 나타내어, 사용자 B의 트랜잭션이 실패합니다.</li>\n<li>사용자 B는 업데이트된 레코드(버전 2)를 읽어 트랜잭션을 다시 시도해야 합니다.</li>\n</ul>\n<h1>장단점</h1>\n<p>장점:</p>\n<ul>\n<li>Non-blocking: 낙관적 잠금은 잠금을 유지하는 오버헤드를 피함으로써 여러 사용자가 대기없이 동일한 데이터로 작업할 수 있습니다.</li>\n<li>확장성: 충돌 비율이 낮은 환경에서 더 확장 가능하며, 이는 리소스에 대한 경합을 줄여줍니다.</li>\n</ul>\n<p></p>\n<p>단점:</p>\n<ul>\n<li>다시 시도 필요: 충돌이 커밋 시간에 감지되면 트랜잭션이 다시 시도될 수 있습니다.</li>\n<li>고 갈등 환경에 적합하지 않음: 고 갈등 환경에서는 충돌 가능성이 증가하여 더 자주 다시 시도하게 되고 성능이 감소할 수 있습니다.</li>\n</ul>\n<p>다음은 루비 온 레일즈에서 낙관적 잠금을 구현하는 예시입니다.</p>\n<p>우리가 제품 테이블을 가지고 있다고 가정해봅시다:</p>\n<p></p>\n<pre><code class=\"hljs language-ruby\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">CreateProducts</span> &#x3C; <span class=\"hljs-title class_ inherited__\">ActiveRecord::Migration</span>[<span class=\"hljs-number\">6.1</span>]\n  <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">change</span>\n    create_table <span class=\"hljs-symbol\">:products</span> <span class=\"hljs-keyword\">do</span> |<span class=\"hljs-params\">t</span>|\n      t.string <span class=\"hljs-symbol\">:name</span>\n      t.decimal <span class=\"hljs-symbol\">:price</span>, <span class=\"hljs-symbol\">precision:</span> <span class=\"hljs-number\">8</span>, <span class=\"hljs-symbol\">scale:</span> <span class=\"hljs-number\">2</span>\n      t.integer <span class=\"hljs-symbol\">:lock_version</span>, <span class=\"hljs-symbol\">default:</span> <span class=\"hljs-number\">0</span>, <span class=\"hljs-symbol\">null:</span> <span class=\"hljs-literal\">false</span>\n\n      t.timestamps\n    <span class=\"hljs-keyword\">end</span>\n  <span class=\"hljs-keyword\">end</span>\n<span class=\"hljs-keyword\">end</span>\n</code></pre>\n<h2>모델 정의</h2>\n<p>다음으로 Product 모델을 정의하세요. lock_version 열은 Rails에서 낙관적 락킹에 자동으로 사용됩니다.</p>\n<pre><code class=\"hljs language-ruby\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Product</span> &#x3C; <span class=\"hljs-title class_ inherited__\">ApplicationRecord</span>\n<span class=\"hljs-keyword\">end</span>\n</code></pre>\n<p></p>\n<h2>예시 사용법</h2>\n<p>담아 두고 있는 상황에서는 어떻게 낙관적 락을 사용할 수 있을까요:</p>\n<h2>사용자 A와 사용자 B가 동일한 레코드를 읽고 있는 경우</h2>\n<pre><code class=\"hljs language-js\"># 사용자 A\nuser_a_product = <span class=\"hljs-title class_\">Product</span>.<span class=\"hljs-title function_\">find</span>(<span class=\"hljs-number\">1</span>) # id가 <span class=\"hljs-number\">1</span>인 제품을 읽음\n# user_a_product.<span class=\"hljs-property\">lock_version</span>은 <span class=\"hljs-number\">0</span>입니다\n\n# 사용자 B\nuser_b_product = <span class=\"hljs-title class_\">Product</span>.<span class=\"hljs-title function_\">find</span>(<span class=\"hljs-number\">1</span>) # 동일한 제품을 읽음\n# user_b_product.<span class=\"hljs-property\">lock_version</span>도 <span class=\"hljs-number\">0</span>입니다\n</code></pre>\n<p></p>\n<h2>사용자 A가 레코드를 업데이트합니다</h2>\n<pre><code class=\"hljs language-js\"># 사용자 A가 가격을 업데이트합니다\nuser_a_product.<span class=\"hljs-property\">price</span> = <span class=\"hljs-number\">12.00</span>\nuser_a_product.<span class=\"hljs-property\">save</span>\n# 이로써 lock_version이 <span class=\"hljs-number\">1</span>로 증가합니다\n</code></pre>\n<h2>사용자 B가 레코드를 업데이트하려고 합니다</h2>\n<pre><code class=\"hljs language-js\"># 사용자 B가 가격을 업데이트하려고 합니다\nuser_b_product.<span class=\"hljs-property\">price</span> = <span class=\"hljs-number\">11.00</span>\nbegin\n  user_b_product.<span class=\"hljs-property\">save</span>\nrescue <span class=\"hljs-title class_\">ActiveRecord</span>::<span class=\"hljs-title class_\">StaleObjectError</span>\n  puts <span class=\"hljs-string\">\"이전 정보가 감지되었습니다.\"</span>\n  # 충돌을 처리하기 위해 레코드를 다시 불러와서 재시도할 수 있습니다\n  user_b_product.<span class=\"hljs-property\">reload</span>\n  # 이제 user_b_product.<span class=\"hljs-property\">lock_version</span>은 <span class=\"hljs-number\">1</span>입니다\n  # 사용자 B가 업데이트를 다시 시도할지 결정할 수 있습니다\nend\n</code></pre>\n<p></p>\n<h2>충돌 처리</h2>\n<p>ActiveRecord::StaleObjectError가 발생하면, 해당 레코드가 읽힌 후 다른 트랜잭션에 의해 수정되었음을 나타냅니다. 이를 처리하기 위해 레코드를 다시 불러오고 사용자에게 알릴 수도 있으며, 트랜잭션을 다시 시도하거나 애플리케이션 로직에 따라 변경 사항을 병합할 수 있습니다.</p>\n<h2>완전한 예제</h2>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ProductsController</span> &#x3C; <span class=\"hljs-title class_\">ApplicationController</span>\n  def update\n    @product = <span class=\"hljs-title class_\">Product</span>.<span class=\"hljs-title function_\">find</span>(params[:id])\n    @product.<span class=\"hljs-title function_\">assign_attributes</span>(product_params)\n\n    begin\n      @product.<span class=\"hljs-property\">save</span>\n      flash[:notice] = <span class=\"hljs-string\">\"제품이 성공적으로 업데이트되었습니다.\"</span>\n    rescue <span class=\"hljs-title class_\">ActiveRecord</span>::<span class=\"hljs-title class_\">StaleObjectError</span>\n      flash[:alert] = <span class=\"hljs-string\">\"제품이 다른 사용자에 의해 업데이트되었습니다. 변경 사항을 검토하고 다시 시도해주세요.\"</span>\n      @product.<span class=\"hljs-property\">reload</span>\n      # 선택적으로 사용자의 변경 사항을 다시 적용하고 통합된 양식을 사용자에게 제시할 수 있음\n    end\n\n    redirect_to @product\n  end\n\n  private\n\n  def product_params\n    params.<span class=\"hljs-built_in\">require</span>(:product).<span class=\"hljs-title function_\">permit</span>(:name, :price)\n  end\nend\n</code></pre>\n<p></p>\n<h2>결론</h2>\n<p>이 예는 Ruby on Rails 애플리케이션에서 낙관적 잠금을 사용하는 방법을 보여줍니다. lock_version 열을 포함하고 Active Record의 내장 메커니즘을 사용하여 Rails는 버전 확인을 자동으로 처리하고 충돌이 감지되면 예외를 발생시킵니다. 이를 통해 애플리케이션이 적절하게 처리할 수 있도록 합니다.</p>\n</body>\n</html>\n"},"__N_SSG":true}