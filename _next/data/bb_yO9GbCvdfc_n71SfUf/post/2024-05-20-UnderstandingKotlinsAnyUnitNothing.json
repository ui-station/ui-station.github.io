{"pageProps":{"post":{"title":"코틀린의 Any, Unit, Nothing 이해하기","description":"","date":"2024-05-20 17:40","slug":"2024-05-20-UnderstandingKotlinsAnyUnitNothing","content":"\n![Understanding Kotlin's Any, Unit, Nothing](/assets/img/2024-05-20-UnderstandingKotlinsAnyUnitNothing_0.png)\n\nKotlin은 Java에서 사용하던 것과는 매우 다른 독특한 유형을 제공합니다. 이 블로그에서는 Any, Unit, 그리고 Nothing과 같은 세 가지 유형을 탐색해 볼 것입니다.\n\n## Any\n\n```js\n// 소스 코드\npackage kotlin\n/**\n * 코틀린 클래스 계층 구조의 루트. 모든 코틀린 클래스는 [Any]를 슈퍼 클래스로 갖습니다.\n */\npublic open class Any {\n    public open operator fun equals(other: Any?): Boolean\n    public open fun hashCode(): Int\n    public open fun toString(): String\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 클래스 계층 구조의 루트입니다. 모든 Kotlin 클래스는 Any로부터 상속받습니다.\n- Java의 Object에 해당됩니다.\n- 우리가 오버라이드할 수 있는 세 가지 메소드를 제공합니다: equals(), hashCode(), toString(). 이것이 어떤 클래스에서 메소드를 오버라이드할 때 IDE에서 이 세 가지 옵션이 자주 제시되는 이유입니다.\n- 기본적으로 Nullable이 아닙니다. 변수가 null을 저장할 수 있도록 필요하다면 Any?를 사용할 수 있습니다.\n\n예제\n\n```js\nfun printAny(value: Any?) {\n    println(value.toString())\n}\n\nfun main() {\n    printAny(\"Hello, World!\")  // 출력: Hello, World!\n    printAny(123)  // 출력: 123\n}\n```\n\n```js\n// 디컴파일할 때 Any는 Java의 Object로 변환됩니다\npublic static final void printAny(@Nullable Object value) {\n   String var1 = String.valueOf(value);\n   System.out.println(var1);\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# Unit\n\n```js\n//SOURCE CODE\npackage kotlin\n/**\n * `Unit` 객체만 있는 유형입니다. 이 유형은 Java의 `void` 유형에 해당합니다.\n */\npublic object Unit {\n    override fun toString() = \"kotlin.Unit\"\n}\n```\n\n- Java의 void와 동등하지만 void와 달리 Unit은 하나의 인스턴스만 있는 실제 클래스입니다 (싱글톤).\n- 의미 있는 값을 반환하지 않는 함수를 나타냅니다.\n- 함수의 반환 유형을 명시하지 않으면 Kotlin은 기본 반환 유형으로 Unit을 사용합니다.\n\n예시\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nfun printMessage(message: String) { // Unit을 명시적으로 작성할 필요가 없습니다.\n    println(message)\n}\n\nfun main() {\n    printMessage(\"안녕, Unit!\")  // 출력: 안녕, Unit!\n}\n```\n\n```js\n// 변환된 결과, Unit은 Java에서 void로 변환됩니다.\npublic static final void printMessage(@NotNull String message) {\n   Intrinsics.checkNotNullParameter(message, \"message\");\n   System.out.println(message);\n}\n```\n\n예시: 함수형 타입\n\n```js\nfun runBlock(block: ()->Unit) {\n    block()\n}\n\nfun main() {\n    runBlock { println(\"여기\") } // 출력: 여기\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여기서 () -` Unit은 함수 유형을 나타내며 Unit은 해당 함수 유형이 의미 있는 값을 반환하지 않음을 나타냅니다.\n\n함수 유형을 지정할 때 Unit을 명시하는 것이 필수입니다.\n\n# Nothing\n\n```js\n//SOURCE CODE\npackage kotlin\n/**\n * Nothing에는 인스턴스가 없습니다. Nothing을 사용하여 \"존재하지 않는 값\"을 표현할 수 있습니다: 예를 들어,\n * 반환 유형이 Nothing인 함수의 경우, 이는 결코 반환하지 않음을 의미합니다 (항상 예외를 throw함).\n */\npublic class Nothing private constructor()\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 아무 값이 없음을 나타내며 함수가 일반적인 방식으로 반환하지 않을 것을 나타냅니다.\n- 사용자가 정의한 Kotlin 유형을 포함한 모든 형식의 하위 유형입니다.\n- 예외를 throw하거나 무한 루프에 들어가기 때문에 결코 반환되지 않는 함수에서 사용됩니다.\n- Nothing의 인스턴스를 만들거나 어떤 클래스도 상속할 수 없습니다.\n- 반환 유형이 Nothing인 함수는 기본 반환 유형인 Unit조차 반환하지 않습니다.\n- Kotlin의 Nothing 반환 유형은 반환하지 않는다는 것을 명확히 하여 잠재적인 버그로부터 우리를 보호합니다. 반환 유형이 Nothing인 아무 함수가 호출되면 컴파일러는 이 함수 호출을 넘어가지 않고 접근할 수 없는 코드 경고를 알려 줍니다.\n\n예시\n\n```js\nfun fail(message: String): Nothing {\n    throw IllegalArgumentException(message)\n}\n\nfun main() {\n    // 이것은 예외를 throw하고 일반적으로 반환하지 않을 것입니다.\n    fail(\"에러 발생!\")\n    println(\"안녕\") // 컴파일러가 \"접근할 수 없는 코드\" 경고를 줍니다.\n}\n```\n\n```js\n// Decompile되었을 때, Nothing은 Java에서 Void가 됩니다\n// Void는 java.lang 패키지의 일부이며, void Java 원시 유형을 래핑하는 객체에 대한 참조 역할을 합니다. 생성할 수 없습니다.\n@NotNull\npublic static final Void fail(@NotNull String message) {\n   Intrinsics.checkNotNullParameter(message, \"message\");\n   throw (Throwable)(new IllegalArgumentException(message));\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n소스 코드: 깃허브\n\n# 연락처:\n\n링크드인, 트위터\n\n코딩 즐기세요! ✌️\n","ogImage":{"url":"/assets/img/2024-05-20-UnderstandingKotlinsAnyUnitNothing_0.png"},"coverImage":"/assets/img/2024-05-20-UnderstandingKotlinsAnyUnitNothing_0.png","tag":["Tech"],"readingTime":5},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p><img src=\"/assets/img/2024-05-20-UnderstandingKotlinsAnyUnitNothing_0.png\" alt=\"Understanding Kotlin&#x27;s Any, Unit, Nothing\"></p>\n<p>Kotlin은 Java에서 사용하던 것과는 매우 다른 독특한 유형을 제공합니다. 이 블로그에서는 Any, Unit, 그리고 Nothing과 같은 세 가지 유형을 탐색해 볼 것입니다.</p>\n<h2>Any</h2>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 소스 코드</span>\npackage kotlin\n<span class=\"hljs-comment\">/**\n * 코틀린 클래스 계층 구조의 루트. 모든 코틀린 클래스는 [Any]를 슈퍼 클래스로 갖습니다.\n */</span>\npublic open <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Any</span> {\n    public open operator fun <span class=\"hljs-title function_\">equals</span>(<span class=\"hljs-attr\">other</span>: <span class=\"hljs-title class_\">Any</span>?): <span class=\"hljs-title class_\">Boolean</span>\n    public open fun <span class=\"hljs-title function_\">hashCode</span>(): <span class=\"hljs-title class_\">Int</span>\n    public open fun <span class=\"hljs-title function_\">toString</span>(): <span class=\"hljs-title class_\">String</span>\n}\n</code></pre>\n<p></p>\n<ul>\n<li>클래스 계층 구조의 루트입니다. 모든 Kotlin 클래스는 Any로부터 상속받습니다.</li>\n<li>Java의 Object에 해당됩니다.</li>\n<li>우리가 오버라이드할 수 있는 세 가지 메소드를 제공합니다: equals(), hashCode(), toString(). 이것이 어떤 클래스에서 메소드를 오버라이드할 때 IDE에서 이 세 가지 옵션이 자주 제시되는 이유입니다.</li>\n<li>기본적으로 Nullable이 아닙니다. 변수가 null을 저장할 수 있도록 필요하다면 Any?를 사용할 수 있습니다.</li>\n</ul>\n<p>예제</p>\n<pre><code class=\"hljs language-js\">fun <span class=\"hljs-title function_\">printAny</span>(<span class=\"hljs-params\">value: Any?</span>) {\n    <span class=\"hljs-title function_\">println</span>(value.<span class=\"hljs-title function_\">toString</span>())\n}\n\nfun <span class=\"hljs-title function_\">main</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-title function_\">printAny</span>(<span class=\"hljs-string\">\"Hello, World!\"</span>)  <span class=\"hljs-comment\">// 출력: Hello, World!</span>\n    <span class=\"hljs-title function_\">printAny</span>(<span class=\"hljs-number\">123</span>)  <span class=\"hljs-comment\">// 출력: 123</span>\n}\n</code></pre>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 디컴파일할 때 Any는 Java의 Object로 변환됩니다</span>\npublic <span class=\"hljs-keyword\">static</span> final <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">printAny</span>(<span class=\"hljs-params\">@Nullable <span class=\"hljs-built_in\">Object</span> value</span>) {\n   <span class=\"hljs-title class_\">String</span> var1 = <span class=\"hljs-title class_\">String</span>.<span class=\"hljs-title function_\">valueOf</span>(value);\n   <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">out</span>.<span class=\"hljs-title function_\">println</span>(var1);\n}\n</code></pre>\n<p></p>\n<h1>Unit</h1>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">//SOURCE CODE</span>\npackage kotlin\n<span class=\"hljs-comment\">/**\n * `Unit` 객체만 있는 유형입니다. 이 유형은 Java의 `void` 유형에 해당합니다.\n */</span>\npublic object <span class=\"hljs-title class_\">Unit</span> {\n    override fun <span class=\"hljs-title function_\">toString</span>() = <span class=\"hljs-string\">\"kotlin.Unit\"</span>\n}\n</code></pre>\n<ul>\n<li>Java의 void와 동등하지만 void와 달리 Unit은 하나의 인스턴스만 있는 실제 클래스입니다 (싱글톤).</li>\n<li>의미 있는 값을 반환하지 않는 함수를 나타냅니다.</li>\n<li>함수의 반환 유형을 명시하지 않으면 Kotlin은 기본 반환 유형으로 Unit을 사용합니다.</li>\n</ul>\n<p>예시</p>\n<p></p>\n<pre><code class=\"hljs language-js\">fun <span class=\"hljs-title function_\">printMessage</span>(<span class=\"hljs-params\">message: <span class=\"hljs-built_in\">String</span></span>) { <span class=\"hljs-comment\">// Unit을 명시적으로 작성할 필요가 없습니다.</span>\n    <span class=\"hljs-title function_\">println</span>(message)\n}\n\nfun <span class=\"hljs-title function_\">main</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-title function_\">printMessage</span>(<span class=\"hljs-string\">\"안녕, Unit!\"</span>)  <span class=\"hljs-comment\">// 출력: 안녕, Unit!</span>\n}\n</code></pre>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 변환된 결과, Unit은 Java에서 void로 변환됩니다.</span>\npublic <span class=\"hljs-keyword\">static</span> final <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">printMessage</span>(<span class=\"hljs-params\">@NotNull <span class=\"hljs-built_in\">String</span> message</span>) {\n   <span class=\"hljs-title class_\">Intrinsics</span>.<span class=\"hljs-title function_\">checkNotNullParameter</span>(message, <span class=\"hljs-string\">\"message\"</span>);\n   <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">out</span>.<span class=\"hljs-title function_\">println</span>(message);\n}\n</code></pre>\n<p>예시: 함수형 타입</p>\n<pre><code class=\"hljs language-js\">fun <span class=\"hljs-title function_\">runBlock</span>(<span class=\"hljs-params\">block: ()->Unit</span>) {\n    <span class=\"hljs-title function_\">block</span>()\n}\n\nfun <span class=\"hljs-title function_\">main</span>(<span class=\"hljs-params\"></span>) {\n    runBlock { <span class=\"hljs-title function_\">println</span>(<span class=\"hljs-string\">\"여기\"</span>) } <span class=\"hljs-comment\">// 출력: 여기</span>\n}\n</code></pre>\n<p></p>\n<p>여기서 () -` Unit은 함수 유형을 나타내며 Unit은 해당 함수 유형이 의미 있는 값을 반환하지 않음을 나타냅니다.</p>\n<p>함수 유형을 지정할 때 Unit을 명시하는 것이 필수입니다.</p>\n<h1>Nothing</h1>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">//SOURCE CODE</span>\npackage kotlin\n<span class=\"hljs-comment\">/**\n * Nothing에는 인스턴스가 없습니다. Nothing을 사용하여 \"존재하지 않는 값\"을 표현할 수 있습니다: 예를 들어,\n * 반환 유형이 Nothing인 함수의 경우, 이는 결코 반환하지 않음을 의미합니다 (항상 예외를 throw함).\n */</span>\npublic <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Nothing</span> private <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>)\n</code></pre>\n<p></p>\n<ul>\n<li>아무 값이 없음을 나타내며 함수가 일반적인 방식으로 반환하지 않을 것을 나타냅니다.</li>\n<li>사용자가 정의한 Kotlin 유형을 포함한 모든 형식의 하위 유형입니다.</li>\n<li>예외를 throw하거나 무한 루프에 들어가기 때문에 결코 반환되지 않는 함수에서 사용됩니다.</li>\n<li>Nothing의 인스턴스를 만들거나 어떤 클래스도 상속할 수 없습니다.</li>\n<li>반환 유형이 Nothing인 함수는 기본 반환 유형인 Unit조차 반환하지 않습니다.</li>\n<li>Kotlin의 Nothing 반환 유형은 반환하지 않는다는 것을 명확히 하여 잠재적인 버그로부터 우리를 보호합니다. 반환 유형이 Nothing인 아무 함수가 호출되면 컴파일러는 이 함수 호출을 넘어가지 않고 접근할 수 없는 코드 경고를 알려 줍니다.</li>\n</ul>\n<p>예시</p>\n<pre><code class=\"hljs language-js\">fun <span class=\"hljs-title function_\">fail</span>(<span class=\"hljs-attr\">message</span>: <span class=\"hljs-title class_\">String</span>): <span class=\"hljs-title class_\">Nothing</span> {\n    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-title class_\">IllegalArgumentException</span>(message)\n}\n\nfun <span class=\"hljs-title function_\">main</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-comment\">// 이것은 예외를 throw하고 일반적으로 반환하지 않을 것입니다.</span>\n    <span class=\"hljs-title function_\">fail</span>(<span class=\"hljs-string\">\"에러 발생!\"</span>)\n    <span class=\"hljs-title function_\">println</span>(<span class=\"hljs-string\">\"안녕\"</span>) <span class=\"hljs-comment\">// 컴파일러가 \"접근할 수 없는 코드\" 경고를 줍니다.</span>\n}\n</code></pre>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// Decompile되었을 때, Nothing은 Java에서 Void가 됩니다</span>\n<span class=\"hljs-comment\">// Void는 java.lang 패키지의 일부이며, void Java 원시 유형을 래핑하는 객체에 대한 참조 역할을 합니다. 생성할 수 없습니다.</span>\n@<span class=\"hljs-title class_\">NotNull</span>\npublic <span class=\"hljs-keyword\">static</span> final <span class=\"hljs-title class_\">Void</span> <span class=\"hljs-title function_\">fail</span>(<span class=\"hljs-params\">@NotNull <span class=\"hljs-built_in\">String</span> message</span>) {\n   <span class=\"hljs-title class_\">Intrinsics</span>.<span class=\"hljs-title function_\">checkNotNullParameter</span>(message, <span class=\"hljs-string\">\"message\"</span>);\n   <span class=\"hljs-keyword\">throw</span> (<span class=\"hljs-title class_\">Throwable</span>)(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">IllegalArgumentException</span>(message));\n}\n</code></pre>\n<p></p>\n<p>소스 코드: 깃허브</p>\n<h1>연락처:</h1>\n<p>링크드인, 트위터</p>\n<p>코딩 즐기세요! ✌️</p>\n</body>\n</html>\n"},"__N_SSG":true}