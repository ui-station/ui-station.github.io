{"pageProps":{"post":{"title":"Jetpack Compose에서 애니메이션 화살표 포인터 만들기","description":"","date":"2024-05-27 16:10","slug":"2024-05-27-CreatinganAnimatedArrowPointerinJetpackCompose","content":"\n환영합니다 👋\n\n이 기사에서는 Jetpack Compose를 사용하여 멋진 애니메이션 화살표 포인터를 만드는 방법을 탐색하고 앱의 외관을 5분 안에 향상시키는 방법에 대해 알아보겠습니다.\n\n계속 주목하고, 함께 알아보시죠! 🚀\n\n![Animated Arrow Pointer](https://miro.medium.com/v2/resize:fit:1400/1*jP0QAL3blRz6ynJ8IkjCuQ.gif)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 함수 정의하기\n\nAnimatedArrowPointer 함수를 선언하고 그 파라미터들을 살펴봅시다.\n\n```js\n@Composable\nfun AnimatedArrowPointer(\n    modifier: Modifier,\n    color: Color,\n    isVisible: Boolean = true,\n    strokeWidth: Dp = 2.dp,\n    pointerSize: Dp = 12.dp,\n    dashLength: Dp? = 4.dp,\n    strokeCap: StrokeCap = StrokeCap.Round,\n    pointerShape: Shape = SimpleArrow,\n    animationSpec: AnimationSpec<Float> = tween(3000)\n)\n```\n\n## ⚒️ 파라미터 설명\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n⚡ modifier ➜ 포인터 레이아웃에 적용할 수정자입니다.\n\n⚡ color ➜ 화살표 포인터의 색상입니다.\n\n⚡ isVisible ➜ 화살표 포인터가 표시되는지 여부를 결정합니다.\n\n⚡ strokeWidth ➜ 화살표 포인터의 선 두께입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n⚡ pointerSize ➜ 화살표 포인터의 크기입니다.\n\n⚡ dashLength ➜ 테두리 대시의 길이입니다. null은 실선을 의미합니다.\n\n⚡ strokeCap ➜ 화살표 포인터의 선 끝 스타일입니다.\n\n⚡ pointerShape ➜ 화살표 포인터의 모양입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n⚡ animationSpec ➜ 화살표 애니메이션 동작을 지정합니다.\n\n# 경로\n\n좋아요, 오늘 기사의 주요 내용으로 넘어갑시다.\n\n## ArrowPath\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n테이블 태그를 마크다운 형식으로 변경해보세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## SimplePointer\n\n다음으로 포인터를 제작해야 합니다. Shape 인터페이스를 구현하는 객체를 정의합시다:\n\n```js\nobject SimpleArrow : Shape {\n    override fun createOutline(\n        size: Size,\n        layoutDirection: LayoutDirection,\n        density: Density\n    ): Outline {\n        val width = size.width\n        val height = size.height\n\n        val path = Path().apply {\n            moveTo(0f, 0f) // 1\n            lineTo(width, height * 0.5f) // 2\n            lineTo(0f, height) // 3\n            lineTo(width * 0.5f, height * 0.5f) // 4\n            close() // line to 1\n        }\n        return Outline.Generic(path)\n    }\n}\n```\n\n이해를 돕기 위해 다음 이미지를 확인해보세요 👇\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/assets/img/2024-05-27-CreatinganAnimatedArrowPointerinJetpackCompose_1.png)\n\n# 그리기\n\n이제 함수 구현에 가까워졌어요. 하지만 그 전에, 경로와 포인터 머리를 그리기 위한 두 개의 지원 함수를 정의해야 해요.\n\n## 화살 경로 그리기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n경로를 그리는 것은 간단합니다. 지정된 속성을 가진 캔버스에 일반적인 경로를 그리기만 하면 됩니다:\n\n```js\nfun DrawScope.drawPathSegment(\n    path: Path,\n    color: Color,\n    strokeWidth: Dp,\n    strokeCap: StrokeCap,\n    dashLength: Dp? = null\n) {\n    drawPath(\n        path = path,\n        color = color,\n        style = Stroke(\n            width = strokeWidth.toPx(),\n            cap = strokeCap,\n            // dashLength가 지정되어 있다면 대시 스트로크를 그리고,\n            // 그렇지 않으면 실선을 사용합니다.\n            pathEffect = dashLength?.let { dash ->\n                PathEffect.dashPathEffect(\n                    floatArrayOf(dash.toPx(), dash.toPx())\n                )\n            }\n        )\n    )\n}\n```\n\n## 포인터 헤드 그리기\n\n현재 경로 세그먼트의 끝에 동적으로 헤드를 그리려면 PathMeasure의 getPosition 및 getTangent를 활용하여 포인터의 위치와 올바른 방향을 가리키는 각도를 얻을 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nfun DrawScope.drawPointerHead(\n    pathMeasure: PathMeasure,\n    stopDistance: Float,\n    pointerSize: Dp,\n    color: Color,\n    pointerShape: Shape\n) {\n    // 지정된 거리에서의 점과 접선을 계산합니다.\n    val headPoint = pathMeasure.getPosition(stopDistance)\n    val tangent = pathMeasure.getTangent(stopDistance)\n\n    // 접선을 기반으로 화살표 머리의 회전 각도를 계산합니다.\n    val angle = atan2(tangent.y.toDouble(), tangent.x.toDouble()).toFloat() * 180 / Math.PI.toFloat()\n\n    // 화살표 머리의 크기와 윤곽을 정의합니다.\n    val headSize = Size(pointerSize.toPx(), pointerSize.toPx())\n    val headOutline = pointerShape.createOutline(headSize, layoutDirection, this)\n\n    // 캔버스를 이동하고 회전시켜 화살표 머리의 위치와 방향을 조정합니다.\n    translate(headPoint.x - (headSize.width / 2), headPoint.y - (headSize.height / 2)) {\n        rotate(angle, pivot = headSize.center) {\n            // 화살표 머리 윤곽을 그립니다.\n            drawOutline(headOutline, color = color)\n        }\n    }\n}\n```\n\n# 구현\n\n마지막으로 모든 것을 합쳐서 애니메이션을 적용합시다.\n\n```js\n@Composable\nfun AnimatedArrowPointer(\n    /* 매개변수... */\n) {\n    // 애니메이션 진행 값을 위한 Animatable 정의\n    val pathCompletion = remember { Animatable(0f) }\n\n    // 가시성 상태 변경에 기반하여 애니메이션 시작\n    LaunchedEffect(isVisible) {\n        if (isVisible) {\n            // 경로 애니메이션\n            pathCompletion.animateTo(1f, animationSpec)\n        } else {\n            // 경로 즉시 숨기기\n            pathCompletion.snapTo(0f)\n        }\n    }\n\n    // Canvas에서 애니메이션된 화살표 그리기\n    Canvas(\n        // 경로 왜곡을 방지하기 위한 적절한 비율 보장\n        modifier.aspectRatio(0.6f)\n    ) {\n        // 캔버스 크기에 따라 화살표 경로 생성\n        val arrowPath = createArrowPath(size.width, size.height)\n\n        // 길이와 세그먼트 정보를 얻기 위해 경로 측정\n        val pathMeasure = PathMeasure().apply {\n            setPath(arrowPath, false)\n        }\n\n        // 현재 애니메이션 진행에 기반한 경로 세그먼트 생성\n        val pathSegment = Path()\n        val stopDistance = pathCompletion.value * pathMeasure.length\n        pathMeasure.getSegment(0f, stopDistance, pathSegment, true)\n\n        // 지정된 속성으로 현재 화살표 경로 세그먼트 그리기\n        drawPathSegment(pathSegment, color, strokeWidth, strokeCap, dashLength)\n\n        // 경로가 일부 그려진 경우, 화살표 머리 그리기\n        if (pathCompletion.value > 0) {\n            drawPointerHead(pathMeasure, stopDistance, pointerSize, color, pointerShape)\n        }\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n축하해요 🥳! 우리 성공적으로 만들었어요 👏. 전체 코드 구현을 확인하려면 GitHub Gist에 액세스할 수 있어요 🧑‍💻. 이제 사용 방법을 알아보아요.\n\n## 광고\n\n외국어를 배우고 새로운 어휘로 고민하고 계신가요? 그렇다면, 여러분의 학습을 쉽고 편리하게 해줄 이 어플을 확인하는 걸 강력히 추천해요!\n\n<img src=\"/assets/img/2024-05-27-CreatinganAnimatedArrowPointerinJetpackCompose_2.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 사용법\n\n배치에 간단한 변형 수정자를 적용하여 화살표 포인터의 위치를 쉽게 사용자 정의할 수 있습니다. 여기에는 일반적인 시나리오가 있습니다:\n\n## 하단-우측 (기본)\n\n하단-우측 위치는 기본 포인팅 방향입니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\nAnimatedArrowPointer(\n    modifier = Modifier.size(140.dp),\n    color = Color.Red\n)\n```\n\n![Arrow Pointer](https://miro.medium.com/v2/resize:fit:576/1*FM6yzByscqrfK0bihhE_6g.gif)\n\n## Top-Right\n\nTo point to the top-right, rotate the layout by -90 degrees:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\nAnimatedArrowPointer(\n    modifier = Modifier\n        .size(140.dp)\n        .rotate(-90f),\n    color = Color.Red\n)\n```\n\n![Animated Arrow Pointer](https://miro.medium.com/v2/resize:fit:900/1*TDE55uvzhAy-XZNn-d8bGg.gif)\n\n## Bottom-Left\n\nBottom-Left를 가리키려면 레이아웃을 x축에서 -1f로 확장하여 수평으로 반사합니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\nAnimatedArrowPointer(\n    modifier = Modifier\n        .size(140.dp)\n        .scale(-1f, 1f),\n    color = Color.Red\n)\n```\n\n![Animated arrow pointer](https://miro.medium.com/v2/resize:fit:570/1*NZ608yVkzKu7IVAwAPa8HQ.gif)\n\n## 왼쪽 위\n\n왼쪽 위 방향을 위해, 먼저 레이아웃을 수평으로 반사한 다음, -90도로 회전시킵니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\nAnimatedArrowPointer(\n    modifier = Modifier\n        .size(140.dp)\n        .scale(-1f, 1f)\n        .rotate(-90f),\n    color = Color.Red\n)\n```\n\n![Animated Arrow Pointer](https://miro.medium.com/v2/resize:fit:900/1*UaIjzfaG0aaaqpSNmN4Qpw.gif)\n\n좋아할 만한 내용이 있을 것 같아요 👇\n\n이 기사를 읽어 주셔서 감사합니다! ❤️ 즐거우시고 가치 있게 보내셨으면 좋겣습니다. 만약 좋았다면 만세 👏를 눌러서 감사를 표현해 주시고 Kappdev를 팔로우하여 더욱 흥미로운 기사를 읽어보세요 😊\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n행복한 코딩!\n\n![이미지](/assets/img/2024-05-27-CreatinganAnimatedArrowPointerinJetpackCompose_3.png)\n","ogImage":{"url":"/assets/img/2024-05-27-CreatinganAnimatedArrowPointerinJetpackCompose_0.png"},"coverImage":"/assets/img/2024-05-27-CreatinganAnimatedArrowPointerinJetpackCompose_0.png","tag":["Tech"],"readingTime":11},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p>환영합니다 👋</p>\n<p>이 기사에서는 Jetpack Compose를 사용하여 멋진 애니메이션 화살표 포인터를 만드는 방법을 탐색하고 앱의 외관을 5분 안에 향상시키는 방법에 대해 알아보겠습니다.</p>\n<p>계속 주목하고, 함께 알아보시죠! 🚀</p>\n<p><img src=\"https://miro.medium.com/v2/resize:fit:1400/1*jP0QAL3blRz6ynJ8IkjCuQ.gif\" alt=\"Animated Arrow Pointer\"></p>\n<p></p>\n<h1>함수 정의하기</h1>\n<p>AnimatedArrowPointer 함수를 선언하고 그 파라미터들을 살펴봅시다.</p>\n<pre><code class=\"hljs language-js\">@<span class=\"hljs-title class_\">Composable</span>\nfun <span class=\"hljs-title class_\">AnimatedArrowPointer</span>(\n    <span class=\"hljs-attr\">modifier</span>: <span class=\"hljs-title class_\">Modifier</span>,\n    <span class=\"hljs-attr\">color</span>: <span class=\"hljs-title class_\">Color</span>,\n    <span class=\"hljs-attr\">isVisible</span>: <span class=\"hljs-title class_\">Boolean</span> = <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">strokeWidth</span>: <span class=\"hljs-title class_\">Dp</span> = <span class=\"hljs-number\">2.</span>dp,\n    <span class=\"hljs-attr\">pointerSize</span>: <span class=\"hljs-title class_\">Dp</span> = <span class=\"hljs-number\">12.</span>dp,\n    <span class=\"hljs-attr\">dashLength</span>: <span class=\"hljs-title class_\">Dp</span>? = <span class=\"hljs-number\">4.</span>dp,\n    <span class=\"hljs-attr\">strokeCap</span>: <span class=\"hljs-title class_\">StrokeCap</span> = <span class=\"hljs-title class_\">StrokeCap</span>.<span class=\"hljs-property\">Round</span>,\n    <span class=\"hljs-attr\">pointerShape</span>: <span class=\"hljs-title class_\">Shape</span> = <span class=\"hljs-title class_\">SimpleArrow</span>,\n    <span class=\"hljs-attr\">animationSpec</span>: <span class=\"hljs-title class_\">AnimationSpec</span>&#x3C;<span class=\"hljs-title class_\">Float</span>> = <span class=\"hljs-title function_\">tween</span>(<span class=\"hljs-number\">3000</span>)\n)\n</code></pre>\n<h2>⚒️ 파라미터 설명</h2>\n<p></p>\n<p>⚡ modifier ➜ 포인터 레이아웃에 적용할 수정자입니다.</p>\n<p>⚡ color ➜ 화살표 포인터의 색상입니다.</p>\n<p>⚡ isVisible ➜ 화살표 포인터가 표시되는지 여부를 결정합니다.</p>\n<p>⚡ strokeWidth ➜ 화살표 포인터의 선 두께입니다.</p>\n<p></p>\n<p>⚡ pointerSize ➜ 화살표 포인터의 크기입니다.</p>\n<p>⚡ dashLength ➜ 테두리 대시의 길이입니다. null은 실선을 의미합니다.</p>\n<p>⚡ strokeCap ➜ 화살표 포인터의 선 끝 스타일입니다.</p>\n<p>⚡ pointerShape ➜ 화살표 포인터의 모양입니다.</p>\n<p></p>\n<p>⚡ animationSpec ➜ 화살표 애니메이션 동작을 지정합니다.</p>\n<h1>경로</h1>\n<p>좋아요, 오늘 기사의 주요 내용으로 넘어갑시다.</p>\n<h2>ArrowPath</h2>\n<p></p>\n<p>테이블 태그를 마크다운 형식으로 변경해보세요.</p>\n<p></p>\n<h2>SimplePointer</h2>\n<p>다음으로 포인터를 제작해야 합니다. Shape 인터페이스를 구현하는 객체를 정의합시다:</p>\n<pre><code class=\"hljs language-js\">object <span class=\"hljs-title class_\">SimpleArrow</span> : <span class=\"hljs-title class_\">Shape</span> {\n    override fun <span class=\"hljs-title function_\">createOutline</span>(\n        <span class=\"hljs-attr\">size</span>: <span class=\"hljs-title class_\">Size</span>,\n        <span class=\"hljs-attr\">layoutDirection</span>: <span class=\"hljs-title class_\">LayoutDirection</span>,\n        <span class=\"hljs-attr\">density</span>: <span class=\"hljs-title class_\">Density</span>\n    ): <span class=\"hljs-title class_\">Outline</span> {\n        val width = size.<span class=\"hljs-property\">width</span>\n        val height = size.<span class=\"hljs-property\">height</span>\n\n        val path = <span class=\"hljs-title class_\">Path</span>().<span class=\"hljs-property\">apply</span> {\n            <span class=\"hljs-title function_\">moveTo</span>(0f, 0f) <span class=\"hljs-comment\">// 1</span>\n            <span class=\"hljs-title function_\">lineTo</span>(width, height * <span class=\"hljs-number\">0.</span>5f) <span class=\"hljs-comment\">// 2</span>\n            <span class=\"hljs-title function_\">lineTo</span>(0f, height) <span class=\"hljs-comment\">// 3</span>\n            <span class=\"hljs-title function_\">lineTo</span>(width * <span class=\"hljs-number\">0.</span>5f, height * <span class=\"hljs-number\">0.</span>5f) <span class=\"hljs-comment\">// 4</span>\n            <span class=\"hljs-title function_\">close</span>() <span class=\"hljs-comment\">// line to 1</span>\n        }\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Outline</span>.<span class=\"hljs-title class_\">Generic</span>(path)\n    }\n}\n</code></pre>\n<p>이해를 돕기 위해 다음 이미지를 확인해보세요 👇</p>\n<p></p>\n<p><img src=\"/assets/img/2024-05-27-CreatinganAnimatedArrowPointerinJetpackCompose_1.png\" alt=\"이미지\"></p>\n<h1>그리기</h1>\n<p>이제 함수 구현에 가까워졌어요. 하지만 그 전에, 경로와 포인터 머리를 그리기 위한 두 개의 지원 함수를 정의해야 해요.</p>\n<h2>화살 경로 그리기</h2>\n<p></p>\n<p>경로를 그리는 것은 간단합니다. 지정된 속성을 가진 캔버스에 일반적인 경로를 그리기만 하면 됩니다:</p>\n<pre><code class=\"hljs language-js\">fun <span class=\"hljs-title class_\">DrawScope</span>.<span class=\"hljs-title function_\">drawPathSegment</span>(<span class=\"hljs-params\">\n    path: Path,\n    color: Color,\n    strokeWidth: Dp,\n    strokeCap: StrokeCap,\n    dashLength: Dp? = <span class=\"hljs-literal\">null</span>\n</span>) {\n    <span class=\"hljs-title function_\">drawPath</span>(\n        path = path,\n        color = color,\n        style = <span class=\"hljs-title class_\">Stroke</span>(\n            width = strokeWidth.<span class=\"hljs-title function_\">toPx</span>(),\n            cap = strokeCap,\n            <span class=\"hljs-comment\">// dashLength가 지정되어 있다면 대시 스트로크를 그리고,</span>\n            <span class=\"hljs-comment\">// 그렇지 않으면 실선을 사용합니다.</span>\n            pathEffect = dashLength?.<span class=\"hljs-property\">let</span> { dash ->\n                <span class=\"hljs-title class_\">PathEffect</span>.<span class=\"hljs-title function_\">dashPathEffect</span>(\n                    <span class=\"hljs-title function_\">floatArrayOf</span>(dash.<span class=\"hljs-title function_\">toPx</span>(), dash.<span class=\"hljs-title function_\">toPx</span>())\n                )\n            }\n        )\n    )\n}\n</code></pre>\n<h2>포인터 헤드 그리기</h2>\n<p>현재 경로 세그먼트의 끝에 동적으로 헤드를 그리려면 PathMeasure의 getPosition 및 getTangent를 활용하여 포인터의 위치와 올바른 방향을 가리키는 각도를 얻을 것입니다.</p>\n<p></p>\n<pre><code class=\"hljs language-js\">fun <span class=\"hljs-title class_\">DrawScope</span>.<span class=\"hljs-title function_\">drawPointerHead</span>(<span class=\"hljs-params\">\n    pathMeasure: PathMeasure,\n    stopDistance: Float,\n    pointerSize: Dp,\n    color: Color,\n    pointerShape: Shape\n</span>) {\n    <span class=\"hljs-comment\">// 지정된 거리에서의 점과 접선을 계산합니다.</span>\n    val headPoint = pathMeasure.<span class=\"hljs-title function_\">getPosition</span>(stopDistance)\n    val tangent = pathMeasure.<span class=\"hljs-title function_\">getTangent</span>(stopDistance)\n\n    <span class=\"hljs-comment\">// 접선을 기반으로 화살표 머리의 회전 각도를 계산합니다.</span>\n    val angle = <span class=\"hljs-title function_\">atan2</span>(tangent.<span class=\"hljs-property\">y</span>.<span class=\"hljs-title function_\">toDouble</span>(), tangent.<span class=\"hljs-property\">x</span>.<span class=\"hljs-title function_\">toDouble</span>()).<span class=\"hljs-title function_\">toFloat</span>() * <span class=\"hljs-number\">180</span> / <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-property\">PI</span>.<span class=\"hljs-title function_\">toFloat</span>()\n\n    <span class=\"hljs-comment\">// 화살표 머리의 크기와 윤곽을 정의합니다.</span>\n    val headSize = <span class=\"hljs-title class_\">Size</span>(pointerSize.<span class=\"hljs-title function_\">toPx</span>(), pointerSize.<span class=\"hljs-title function_\">toPx</span>())\n    val headOutline = pointerShape.<span class=\"hljs-title function_\">createOutline</span>(headSize, layoutDirection, <span class=\"hljs-variable language_\">this</span>)\n\n    <span class=\"hljs-comment\">// 캔버스를 이동하고 회전시켜 화살표 머리의 위치와 방향을 조정합니다.</span>\n    <span class=\"hljs-title function_\">translate</span>(<span class=\"hljs-params\">headPoint.x - (headSize.width / <span class=\"hljs-number\">2</span>), headPoint.y - (headSize.height / <span class=\"hljs-number\">2</span>)</span>) {\n        <span class=\"hljs-title function_\">rotate</span>(<span class=\"hljs-params\">angle, pivot = headSize.center</span>) {\n            <span class=\"hljs-comment\">// 화살표 머리 윤곽을 그립니다.</span>\n            <span class=\"hljs-title function_\">drawOutline</span>(headOutline, color = color)\n        }\n    }\n}\n</code></pre>\n<h1>구현</h1>\n<p>마지막으로 모든 것을 합쳐서 애니메이션을 적용합시다.</p>\n<pre><code class=\"hljs language-js\">@<span class=\"hljs-title class_\">Composable</span>\nfun <span class=\"hljs-title class_\">AnimatedArrowPointer</span>(\n    <span class=\"hljs-comment\">/* 매개변수... */</span>\n) {\n    <span class=\"hljs-comment\">// 애니메이션 진행 값을 위한 Animatable 정의</span>\n    val pathCompletion = remember { <span class=\"hljs-title class_\">Animatable</span>(0f) }\n\n    <span class=\"hljs-comment\">// 가시성 상태 변경에 기반하여 애니메이션 시작</span>\n    <span class=\"hljs-title class_\">LaunchedEffect</span>(isVisible) {\n        <span class=\"hljs-keyword\">if</span> (isVisible) {\n            <span class=\"hljs-comment\">// 경로 애니메이션</span>\n            pathCompletion.<span class=\"hljs-title function_\">animateTo</span>(1f, animationSpec)\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-comment\">// 경로 즉시 숨기기</span>\n            pathCompletion.<span class=\"hljs-title function_\">snapTo</span>(0f)\n        }\n    }\n\n    <span class=\"hljs-comment\">// Canvas에서 애니메이션된 화살표 그리기</span>\n    <span class=\"hljs-title class_\">Canvas</span>(\n        <span class=\"hljs-comment\">// 경로 왜곡을 방지하기 위한 적절한 비율 보장</span>\n        modifier.<span class=\"hljs-title function_\">aspectRatio</span>(<span class=\"hljs-number\">0.</span>6f)\n    ) {\n        <span class=\"hljs-comment\">// 캔버스 크기에 따라 화살표 경로 생성</span>\n        val arrowPath = <span class=\"hljs-title function_\">createArrowPath</span>(size.<span class=\"hljs-property\">width</span>, size.<span class=\"hljs-property\">height</span>)\n\n        <span class=\"hljs-comment\">// 길이와 세그먼트 정보를 얻기 위해 경로 측정</span>\n        val pathMeasure = <span class=\"hljs-title class_\">PathMeasure</span>().<span class=\"hljs-property\">apply</span> {\n            <span class=\"hljs-title function_\">setPath</span>(arrowPath, <span class=\"hljs-literal\">false</span>)\n        }\n\n        <span class=\"hljs-comment\">// 현재 애니메이션 진행에 기반한 경로 세그먼트 생성</span>\n        val pathSegment = <span class=\"hljs-title class_\">Path</span>()\n        val stopDistance = pathCompletion.<span class=\"hljs-property\">value</span> * pathMeasure.<span class=\"hljs-property\">length</span>\n        pathMeasure.<span class=\"hljs-title function_\">getSegment</span>(0f, stopDistance, pathSegment, <span class=\"hljs-literal\">true</span>)\n\n        <span class=\"hljs-comment\">// 지정된 속성으로 현재 화살표 경로 세그먼트 그리기</span>\n        <span class=\"hljs-title function_\">drawPathSegment</span>(pathSegment, color, strokeWidth, strokeCap, dashLength)\n\n        <span class=\"hljs-comment\">// 경로가 일부 그려진 경우, 화살표 머리 그리기</span>\n        <span class=\"hljs-keyword\">if</span> (pathCompletion.<span class=\"hljs-property\">value</span> > <span class=\"hljs-number\">0</span>) {\n            <span class=\"hljs-title function_\">drawPointerHead</span>(pathMeasure, stopDistance, pointerSize, color, pointerShape)\n        }\n    }\n}\n</code></pre>\n<p></p>\n<p>축하해요 🥳! 우리 성공적으로 만들었어요 👏. 전체 코드 구현을 확인하려면 GitHub Gist에 액세스할 수 있어요 🧑‍💻. 이제 사용 방법을 알아보아요.</p>\n<h2>광고</h2>\n<p>외국어를 배우고 새로운 어휘로 고민하고 계신가요? 그렇다면, 여러분의 학습을 쉽고 편리하게 해줄 이 어플을 확인하는 걸 강력히 추천해요!</p>\n<p></p>\n<h1>사용법</h1>\n<p>배치에 간단한 변형 수정자를 적용하여 화살표 포인터의 위치를 쉽게 사용자 정의할 수 있습니다. 여기에는 일반적인 시나리오가 있습니다:</p>\n<h2>하단-우측 (기본)</h2>\n<p>하단-우측 위치는 기본 포인팅 방향입니다:</p>\n<p></p>\n<pre><code class=\"hljs language-kotlin\">AnimatedArrowPointer(\n    modifier = Modifier.size(<span class=\"hljs-number\">140.</span>dp),\n    color = Color.Red\n)\n</code></pre>\n<p><img src=\"https://miro.medium.com/v2/resize:fit:576/1*FM6yzByscqrfK0bihhE_6g.gif\" alt=\"Arrow Pointer\"></p>\n<h2>Top-Right</h2>\n<p>To point to the top-right, rotate the layout by -90 degrees:</p>\n<p></p>\n<pre><code class=\"hljs language-kotlin\">AnimatedArrowPointer(\n    modifier = Modifier\n        .size(<span class=\"hljs-number\">140.</span>dp)\n        .rotate(-<span class=\"hljs-number\">90f</span>),\n    color = Color.Red\n)\n</code></pre>\n<p><img src=\"https://miro.medium.com/v2/resize:fit:900/1*TDE55uvzhAy-XZNn-d8bGg.gif\" alt=\"Animated Arrow Pointer\"></p>\n<h2>Bottom-Left</h2>\n<p>Bottom-Left를 가리키려면 레이아웃을 x축에서 -1f로 확장하여 수평으로 반사합니다:</p>\n<p></p>\n<pre><code class=\"hljs language-kotlin\">AnimatedArrowPointer(\n    modifier = Modifier\n        .size(<span class=\"hljs-number\">140.</span>dp)\n        .scale(-<span class=\"hljs-number\">1f</span>, <span class=\"hljs-number\">1f</span>),\n    color = Color.Red\n)\n</code></pre>\n<p><img src=\"https://miro.medium.com/v2/resize:fit:570/1*NZ608yVkzKu7IVAwAPa8HQ.gif\" alt=\"Animated arrow pointer\"></p>\n<h2>왼쪽 위</h2>\n<p>왼쪽 위 방향을 위해, 먼저 레이아웃을 수평으로 반사한 다음, -90도로 회전시킵니다:</p>\n<p></p>\n<pre><code class=\"hljs language-kotlin\">AnimatedArrowPointer(\n    modifier = Modifier\n        .size(<span class=\"hljs-number\">140.</span>dp)\n        .scale(-<span class=\"hljs-number\">1f</span>, <span class=\"hljs-number\">1f</span>)\n        .rotate(-<span class=\"hljs-number\">90f</span>),\n    color = Color.Red\n)\n</code></pre>\n<p><img src=\"https://miro.medium.com/v2/resize:fit:900/1*UaIjzfaG0aaaqpSNmN4Qpw.gif\" alt=\"Animated Arrow Pointer\"></p>\n<p>좋아할 만한 내용이 있을 것 같아요 👇</p>\n<p>이 기사를 읽어 주셔서 감사합니다! ❤️ 즐거우시고 가치 있게 보내셨으면 좋겣습니다. 만약 좋았다면 만세 👏를 눌러서 감사를 표현해 주시고 Kappdev를 팔로우하여 더욱 흥미로운 기사를 읽어보세요 😊</p>\n<p></p>\n<p>행복한 코딩!</p>\n<p><img src=\"/assets/img/2024-05-27-CreatinganAnimatedArrowPointerinJetpackCompose_3.png\" alt=\"이미지\"></p>\n</body>\n</html>\n"},"__N_SSG":true}