{"pageProps":{"posts":[{"title":"접근성 있는 비디오 게임 디자인하기","description":"","date":"2024-05-23 13:43","slug":"2024-05-23-Designingaccessiblevideogames","content":"\n\n비디오 게임은 오직 즐거움의 형태에 머무르는 것이 아닙니다; 그것들은 이야기 전달, 소셜 상호 작용, 그리고 몰입형 경험을 위한 강력한 매체입니다.\n\n사람들이 여가 시간을 게이밍에 할애하는 이유는 많습니다. 시작하기에, 그들은 현실에서 벗어나 다른 사람들과 연결되는 방법입니다. 누군가가 왜 게임을 원할 수 있는 가능한 이유들을 모두 나열할 수 있지만, 그것은 그 자체로 한 섹션이 될 것입니다.\n\n모든 사람은 게임의 독특하고 몰입적인 세계를 즐길 자격이 있지만, 불행하게도 그것이 많은 게임에는 해당되지 않습니다. 지난 몇 년 동안 접근성 있는 게임 디자인으로의 움직임이 있었지만, 아직 가야 할 길은 멀습니다.\n\n많은 게임이 일부 접근성 설정과 기능을 구현하고 있지만, 몇몇 회사만이 시간, 예산, 그리고 능력이 The Last of Us Part II만큼 멋지게 접근 가능하도록하는 게임을 만들 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n위와 같이, 접근성에 대한 대화를 중요시하고 시작부터 구현하는 것이 중요합니다. 복잡한 설정 메뉴가 모든 게임에 가능하지는 않을 수 있음을 이해합니다, 특히 소규모 스튜디오의 경우에는 더 그렇습니다.\n\n예산이 전무한 소규모 인디 스튜디오에서 근무하고 있는 사람으로서, 제가 이해한다는 것에 신뢰해 주세요.\n\n게임을 접근성 있게 디자인하는 것은 모든 플레이어에 도움이 되며, 접근성을 고려한 기능은 모든 능력을 가진 플레이어들에게 널리 사용됩니다.\n\n자막을 예로 들어 보겠습니다. 명백히 자막은 청각 장애가 있는 플레이어들에게 매우 유용한 도구이지만, 청각 장애가 없는 플레이어들도 자주 사용합니다.\n\n<div class=\"content-ad\"></div>\n\n노트: 이 기사는 접근성 있는 게임을 디자인하는 방법 중 일부만 다룹니다.\n\n더 포괄적인 목록이 궁금하시다면 '게임 접근성 지침'을 확인해보세요.\n\n여러분께서는 직접 조사를 하시고, 무엇보다도 다양한 능력을 가진 실제 사용자들로 게임을 테스트하는 것을 권장합니다.\n\n# 어시스트 모드 vs 의도한 경험\n\n<div class=\"content-ad\"></div>\n\n일부 플레이어는 게임 자체의 도움을 필요로하여 제시된 도전들을 극복할 수 있습니다. 특정 게임들은 조준장치를 추가하여 플레이어가 조준, 조향, 내비게이션, 퍼즐 해결 또는 장애물 극복 등 다양한 방식으로 도움을 받을 수 있도록 합니다. 이렇게 함으로써, 플레이어는 게임의 난이도를 맞춤 설정하고 자신의 속도에 맞춰 게임 콘텐츠를 즐길 수 있습니다.\n\n일부 게임 회사들 사이에서 이러한 보조가 어떻게 게임의 정신이나 목적을 망치는지에 대한 논쟁이 있습니다.\n\n특정 프랜차이즈의 개발자들과 팬들은 종종 \"프롬 소프트웨어의 '세키로: 섀도우 다이 트와이스(Sekiro: Shadows Die Twice)'나 Sloclap의 '시퍼(Sifu)'와 같은 게임에 쉬운 난이도나 보조 게임 설정을 추가하는 것을 반대하며, 예술적 방향성과 개발자의 목표인 형벌적인 경험을 만들려는 것을 인용하며 다른 난이도 모드 추가는 '망치게 될 것'이라고 주장합니다.\"\n\n만약 다크 소울즈(Dark Souls)이 쉬웠다면, 다크 솔울즈가 아니었을 것입니다. 이는 사실일 수 있지만, 접근성 옵션은 게임을 쉽게 만드는 것이 아니라 광범위한 대중에 渙근하게 하는 것을 목적으로 합니다.\n\n<div class=\"content-ad\"></div>\n\n게임이 제공하는 체험을 제한하거나 묽게 만드는 것이 아닙니다. 만약 당신의 게임이 숲을 통해 야생 동물을 쫓는 긴장감을 제공하길 원한다면, 그것이 플레이어 경험으로 추구해야 할 것입니다.\n\n모든 실력 수준의 플레이어는 게임을 플레이하는 동안 도전과 재미를 동시에 찾고 있습니다. 에임 어시스트와 같은 기능을 도입하면 처음에는 플레이어가 속임수를 쓰는 것을 느낄 수도 있지만, 현실은 그렇지 않습니다. 에임 어시스트를 추가하는 예시에서는, 에임에 대한 신체적 제약을 겪는 개인들에게 기회를 제공하여 게임을 원활히 탐험하고, 멋진 느낌을 느낄 수 있게 합니다.\n\n플레이어가 게임을 진행하는 데 도움이 필요하지 않은데도 어시스트 모드를 사용할까봐 걱정된다면, 경고 문구를 추가하는 것을 고려해보세요.\n\n인기 있는 인디 플랫포머인 'Celeste'는 플레이어가 게임을 자신의 요구에 맞게 조정할 수 있도록 허용하면서도, 이것이 게임을 플레이하는 방식이 아니라는 경고를 제공하는 뛰어난 작업을 합니다.\n\n<div class=\"content-ad\"></div>\n\n게임 제작자 도구킷이 말하듯이, 접근성과 게임이 의도대로 플레이되는 것 사이의 균형을 맞추는 것은 하나의 중요한 요소, 소통에 달려 있어요.\n\n우리가 제대로 소통한다면, 사용자들은 게임이 어떻게 플레이되어야 하는지 알게 될 거예요. 특정 보조 모드나 설정을 켜야 하는지 결정하는 것은 플레이어의 몫이에요. 이는 그들을 위해 디자인된 의도된 경험을 변경할 수 있어요.\n\n난이도는 게임의 일부입니다. 그러나 플레이어가 물리적 또는 정신적으로 그것을 완료할 수 없는 정도로 게임을 너무 어렵게 만들면, 그들은 그것을 전혀 플레이할 수 없게 될 거에요.\n\n# 멀티플레이어 게임에서의 접근성 균형 설정\n\n<div class=\"content-ad\"></div>\n\n지금, 지금. 방 안의 코끼리에 대해 얘기해 보죠: 멀티플레이어 게임. 멀티플레이 경험을 공정하게 유지하면서 접근성 높은 것으로 만드는 방법은 뭘까요?\n\nAPX 프레임워크는 이를 \"하우스 룰\"이라고 부릅니다.\n\n플레이어들은 온라인에서 다른 사람들과 맞붙을 때 선택지를 받을 수 있습니다. 플레이어들은 특정 설정(에임 어시스트, 매크로 등), 게임 옵션(매치 길이, 게임 모드 등), 그리고/또는 특정 실력 수준의 플레이어들과만 플레이할지 선택할 수 있습니다.\n\n![Designingaccessiblevideogames_0](/assets/img/2024-05-23-Designingaccessiblevideogames_0.png)\n\n<div class=\"content-ad\"></div>\n\n만약 플레이어들이 특정 설정으로 다른 사람들에게 이점을 준다고 느낀다면, 그들은 해당 설정을 사용하지 않는 플레이어들과 함께 대기열에 들 수 있습니다.\n\n이렇게 함으로써 플레이어 간 의사 소통에 관한 문제도 해결할 수 있습니다. 예를 들어, 음성 채팅 없이 게임을 선호하는 플레이어들 또는 그러한 방식을 수용할 수 있는 플레이어들과 온라인 멀티플레이 매치를 우선적으로 매칭하는 옵션을 제공하세요. 의사소통에 크게 의존하는 협력 게임에서는 음성 대화를 할 수 없는 플레이어들로 인해 팀원들이 좌절할 수도 있습니다. 이러한 좌절은 게임에서 해당 플레이어를 제거하거나 미래 매치에서 제외시킬 수도 있습니다.\n\n# 저장 — 자동 및 수동\n\n몇몇 사람들은 어려운 도전에 맞서고 같은 레벨을 통과하기 위해 끊임없이 시간을 보내는 것을 좋아합니다 (FromSoftware 팬들에게 주목!).\n\n<div class=\"content-ad\"></div>\n\n다른 사람들은 그렇지 않을 수도 있습니다. 원하는 때에 게임을 저장하고 싶다는 것은 단순히 개인적인 취향일 수도 있고, 신체적, 정신적 스트레스를 덜기 위한 문제일 수도 있습니다.\n\n신체적 장애를 가진 플레이어들은 힘든 동작이나 도전적인 상황을 반복하기 위해 게임을 저장해야 할 수도 있습니다. 가장 유명한 게임 메커니즘 중 하나를 예를 들어보겠습니다: 퀵타임 이벤트. 특히 버튼 누르기입니다.\n\n(이상적으로는 버튼을 연타하는 부분을 우회하거나 그 부분을 완전히 제거할 방법을 추가하고 싶지만, 이 예시를 계속 진행해 봅시다.)\n\n사용자가 방금 큰 무서운 괴물을 피하기 위해 \"X\"를 연타해야 했던 작업을 끝냈다고 상상해봅시다. 안도의 한숨을 내쉬며 그 다음 장면으로 나아갑니다. 은어, 저거는 못 봤네요; 건너 돌다가 절벽으로 떨어지고 큰 “게임 오버”가 화면에 나타납니다. 다시 시도하고, 이미 따가운 버튼 누르기 손이 아팠던 사용자는 그 섹션을 다시 해야 한다는 걸 깨달을 것입니다.\n\n<div class=\"content-ad\"></div>\n\n일부 플레이어들은 그 섹션을 다시 시작하면서 한숨을 쉴 수도 있지만, 다른 사람들은 그 섹션을 다시 완료할 물리적 또는 정신적 능력이 되지 않을 수도 있어요.\n\n버튼을 연담하다 보니 플레이어에게 신체적으로 지친 상태가 되어 하루 쉬고 다음 날 다시 시도해야 할 수도 있어요. 다음 날이 왔지만, 다시 시도하여 실패하고 다시 쉬고 다음 날 다시 시도해야 할 수도 있어요. 즐겁지 않죠.\n\n이 도전은 반드시 신체적인 것만은 아닐 수도 있어요.\n\n게임의 특정 섹션에서 플레이어가 계속해서 듣거나 보고 싶어하지 않는 매우 감정적으로 자극하는 대화나 이미지가 있는 가능성도 있어요.\n\n<div class=\"content-ad\"></div>\n\n특정 섹션이 너무 자극적이어서 진행이 어려울 수 있습니다.\n\n무엇이든 그 이유가 되더라도, 사용자들에게 저장할 수 있게 해주세요.\n\n저는 개인적으로 자동 저장과 수동 저장 둘 다 구현하는 것을 추천드립니다.\n\n왜냐하면 몇 가지 이유가 있습니다.\n\n<div class=\"content-ad\"></div>\n\n자동 저장은, 그냥 자동으로 됩니다. 사용자들은 자신이 죽거나 집의 전원이 어떤 이유로든 꺼진다고 해도 많은 진행 상황을 잃을 걱정을 할 필요가 없습니다.\n\n하지만, 자동 저장에는 몇 가지 문제가 있습니다.\n\n우리 아버지는 게임 The Callisto Protocol의 출시일에 대해 매우 흥분했습니다. 그는 잠깐 게임을 플레이하고 멋지다고 생각했지만, 가장 어려운 난이도로 플레이하더라도 실제 도전감이 전혀 느껴지지 않았다고 느꼈습니다.\n\n그는 나를 불러 자신이 특정 부분을 진행하면서 적에게 죽고, 다시 부활해서 방금 전에 있었던 곳에서 10 피트 떨어진 곳에서 되살아났다는 것을 보라고 말했습니다.\n\n<div class=\"content-ad\"></div>\n\n\"그는 말했다, '게임 전체가 이런 식이야. 내가 죽어도 걱정 안 해. 원래 있던 곳으로 돌아가는 데 10초가 걸리니까. 긴장감이 없어.'\n\n게임을 자주 저장하는 것은 일부 플레이어에게 좋을 수 있지만, 다른 사람들의 경험을 방해할 수도 있어. 나는 일정 구간을 거치고 자동 저장하는 것을 선호하지만, 사용자가 수동으로 저장할 수 있는 옵션을 제공하는 게 좋다.\n\n수동 저장 옵션이 없으면 짧은 간격으로만 게임을 플레이하거나 사전 예고 없이 갑자기 게임을 중단해야 하는 게이머에게 불리할 수 있다.\n\n더 큰 장애물을 가진 플레이어들에게는 이 제한이 게임을 할 수 있게 여부를 결정할 수도 있다.\"\n\n<div class=\"content-ad\"></div>\n\n만약 누군가가 다시 하기 싫은 섹션을 완료한다면, 저장할 수 있어요. 도전을 좋아하는 플레이어들은 계속해서 진행할 수 있어요.\n\n# 난이도 모드는 싫어\n\n비디오 게임에서 난이도를 조절하는 것에 대해 이야기해봐요.\n\n엄청나게 많은 게임들이 플레이어들이 난이도를 선택할 수 있는 옵션을 제공하지만, 그중에서 제대로 하는 게임은 매우 드데요.\n\n<div class=\"content-ad\"></div>\n\n어려움은 적의 체력, 플레이어 체력, 적의 수, 전리품 드랍 빈도, 플레이어 및 적의 공격력 등을 조절합니다.\n\n이 모든 것은 괜찮은데, 더 자세히 살펴보기 시작하면 문제가 될 수 있어요.\n\n예를 들어, 어떤 이용자는 게임의 전투 요소를 정말 좋아하지만 무슨 이유에서인지 게임의 파쿠르 부분을 완료하지 못할 수 있어요. 그들은 전투 부분에 높은 난이도를 원할지 몰라도 파쿠르 부분에는 쉬운 난이도를 원할 수 있어요. 또한 누군가는 액션을 좋아하지만 한 플랫폼을 건너는 데 2시간을 헤매다가, 이 경험이 그만한 가치가 없어지는 경우도 있을 거예요.\n\n난이도 설정을 조절할 수 없다면, 상황은 어려움의 암흑일 수 있어요. 예를 들어, 쉬운 난이도에서 게임을 플레이하면 전투가 재미없어 보일 수 있지만, 어려운 난이도에서 플레이하면 플랫폼이 불편할 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n장애를 가진 플레이어를 고려할 때 이 문제는 더욱 복잡해질 수 있습니다.\n\n보편적인 컨트롤의 접근성이 부족하여 어려움을 겪을 수 있는 사람을 고려해 봅시다. 그들은 주로 쉬운 난이도 설정을 선택하여 명령을 단순화하고 게임 플레이 속도를 늦추게 됩니다. 이러한 선택은 어떤 접근성을 제공하기는 하지만 게임에서 찾는 전반적인 도전과 흥미를 떨어뜨릴 수도 있습니다.\n\n많은 게이머들이 쉬운 난이도를 선택하는 것은 도전을 원치 않기 때문이 아니라, 그것이 접근 가능한 유일한 모드이기 때문일 수도 있습니다.\n\n일반적으로 어려움 설정을 선택하는 것은 혼란과 스트레스를 초래할 수도 있습니다. 게임의 여러 요소를 몇 가지 옵션으로 일반화하여 선택할 수 있도록 하는 어려움 모드는 게임에서 각 난이도가 실제 게임 플레이에 어떤 의미를 갖는지 명확히 설명해 주지 않는 경향이 있습니다.\n\n<div class=\"content-ad\"></div>\n\n균형 잡힌 경험. 멋지네요… 하지만… 균형이 정확히 무슨 뜻이죠?\n\n몬스터보다 내가 가진 체력이 동일한 수준이라는 걸 의미하는 건가요? 더 많은가요? 어떤 스탯이 영향을 받나요? 이 중 어떤 설정이 게임을 접근하기 쉽게 만들어줄까요?\n\n전혀 모르겠네요.\n\n그럼, 해결책은 무엇일까요?\n\n<div class=\"content-ad\"></div>\n\n그래요, 각 플레이어마다 독특하고 능력 수준 및 개인 성향에 맞는 맞춤형 경험을 얻을 수 있다는 것 같아요. 그렇다면… 그걸 한정된 난이도 옵션에 어떻게 넣을까요?\n\n음, 번들 하나 말이죠.\n\n구체적으로 말하면, 플레이어가 조절할 수 있는 설정들의 번들이죠.\n\n어찌되었든, 난이도 모드는 그냥 서로 다른 설정들의 번들일 뿐이에요; 우리는 그것을 바꿀 수 있는 옵션을 플레이어에게 일반적으로 제공하지 않을 뿐이죠.\n\n<div class=\"content-ad\"></div>\n\n플레이어들이 적의 수, 시간 제한, 보상 획득량 등을 조절할 수 있는 기능을 제공한다면, 그들이 직접 원하는 난이도 모드를 만들 수 있어요.\n\n난이도 모드에 몇 가지 사전 설정값을 사용자에게 제공하되, 이후 사용자가 직접 선호에 맞게 수정할 수 있도록 해보세요.\n\n여러 난이도 모드를 제공하는 것 외에도, 사용자가 맞춤형 난이도를 선택할 수 있도록 하는 것도 좋아요.\n\n난이도 설정이 정말 잘 된 게임 중 하나인 Pathologic 2 생존 게임이 있어요.\n\n<div class=\"content-ad\"></div>\n\n누군가는 가장 강렬하고 복잡한 퍼즐을 원할 수 있고, 또한 가장 쉬운 전투를 선호할 수도 있습니다. 또 다른 누군가는 퍼즐을 완전히 건너뛰고 가장 도전적인 전투 경험을 원할 수도 있죠.\n\n플레이어가 자신만의 플레이 스타일에 가장 적합한 경험을 만들 수 있도록 옵션을 제공해주세요.\n\n# 감각을 활용해보세요\n\n중요한 정보를 플레이어에게 전달할 때 적어도 두 가지 다른 감각을 사용하는 것이 좋은 지침입니다.\n\n<div class=\"content-ad\"></div>\n\n예를 들어, 전리품이 나온 경우 시각적인 표시뿐만 아니라 청각적인 표시도 하세요. 플레이어가 피해를 입은 경우 시각적 피드백과 함께 햅틱 피드백을 제공하세요.\n\n여러 감각을 통해 정보를 전달하는 좋은 예시는 게임 모탈 컴뱃(Mortal Kombat)에서 찾을 수 있습니다.\n\n카를로스 바스케즈, 또는 스트리머 래틀헤드로 알려진 사람은 시각 장애인 프로 모탈 컴뱃 플레이어입니다. 그는 소리에 완전히 의존하면서 최고 수준의 경기에 참가할 수 있습니다.\n\nTheGamer와의 인터뷰 중에 Rattlehead는 게임이 설계되는 동안 때로는 \"우연한 접근 가능성\"을 만들어낼 수 있다고 언급합니다. 이 우연한 접근 가능성은 게임을 플레이할 수 있게 만들어 줄 수도 있지만, 개발자들이 실제로 시각 장애인 게이머를 듣게 되면 게임이 완전히 새로운 수준으로 진화될 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n어떤 사람들은 2D 대전 게임과 같은 일부 종류의 게임만 시각 장애인 커뮤니티에 접근 가능하다고 주장합니다. 이는 사실이 될 수 있지만, 접근성을 처음부터 고려하지 않는다면 해당할 수 있습니다.\n\n접근성을 고려하여 게임을 만든다면 복잡한 3D 게임도 누구에게나 플레이할 수 있게 할 수 있습니다. 이러한 사례 중 하나가 God of War: 라그나로크에 있습니다. 시갚을 사용하지 않고도 게임을 완주할 수 있습니다.\n\n게임에서는 플레이어가 어디로 가야하는지 듣을 수 있는 핑 시스템과 적과 싸울 때 락온 시스템을 사용합니다.\n\nRoss Minor의 게임 플레이를 시청해보면, 2022 게임 어워즈에서 접근성 혁신상을 수상하더라도 해당 게임이 완벽에 가깝지 않음을 알게 될 것입니다.\n\n<div class=\"content-ad\"></div>\n\n비디오 게임은 접근성 측면에서 많은 발전을 이뤄왔지만, 아직 가야 할 길이 많습니다.\n\nGod of War: Ragnarök과 같이 철저한 접근성 시스템을 갖춘 게임들을 공부하고, 그들이 제대로 한 부분과 개선할 수 있는 부분을 주목해 보는 걸 권장합니다.\n\n이어서 청각 정보를 시각적으로 전달하는 것에 대해 이야기해 보겠습니다. 청각 장애가 있는 플레이어들은 햅틱스나 부가적인 시각적 표시를 통해 정보를 전달받아야 할 수도 있습니다.\n\n시작하려면, 생존 게임인 Raft에서 나쁜 예시를 살펴보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n(참고: 저는 Raft를 사랑하는 팬으로, 그것과 함께 많은 즐거움을 느꼈지만, 접근성 부분에는 많은 부족함이 있습니다.)\n\nRaft의 주요 기능 중 하나는 상황에 따라 플레이어에게 다가와 그들의 뗏목/기지를 먹으려는 상어를 중심으로 돌아갑니다. 플레이어는 상어를 막기 위해 어떤 종류의 막대나 무기로 상어를 때려야 합니다.\n\n플레이어는 상어가 나타날 때 상어가 나뭇결을 물거나 철퍼지는 소리를 듣고 알 수 있습니다.\n\n플레이어가 청각 장애가 있거나 청력이 떨어지거나 시끄러운 환경에서 플레이하거나 소리 없이 게임을 플레이할 때는 직접 상어를 바라봐야만 상어가 있는지 알 수 있는 방법이 없습니다. 이 문제는 플레이어가 특히 큰 기지를 건설하고 뗏목의 모든 구석을 보는 방법이 없을 때 더 큰 문제가 됩니다. 이 문제는 소리가 어디에서 시계가 오는지 표시하는 시각적 지시기를 사용하여 해결할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n포트나이트는 시각적 오디오를 활용한 게임의 좋은 예시입니다. 플레이어 주위에 나타나는 링은 다양한 소리가 어디에서 나오는지를 표시합니다. 발소리, 총 소리, 전리품 등이 링에 표시되어 플레이어가 특정 방향에서 무슨 일이 일어나고 있는지 알 수 있습니다.\n\n이 설정은 청각 장애가 있는 사용자, 소리 없이 플레이하는 사용자 또는 소음이 있는 환경에서도 사용자들이 공평하게 게임을 즐길 수 있도록 도와줍니다.\n\n각각의 감각을 통해 정보를 전달하는 것 뿐만 아니라 정보가 명확히 표시되도록 하는 것도 중요합니다.\n\n<div class=\"content-ad\"></div>\n\n시각 장애를 가진 게이머들을 위해 경험을 맞춤 설정하는 것은 배경 세부사항을 없애는 것을 포함할 수도 있습니다. 이 조정은 그들이 전경의 중요한 물체들을 쉽게 구별하고 집중할 수 있도록 돕습니다. 이에 대한 훌륭한 예시는 The Last of Us: Part II에서 볼 수 있습니다.\n\n![이미지](/assets/img/2024-05-23-Designingaccessiblevideogames_2.png)\n\n상호작용 가능한 항목들과 적들과 같은 중요한 요소들이 강조되고 배경은 회색조로 처리됩니다. 플레이어들은 화면에서 중요한 정보를 더 쉽게 파악할 수 있습니다.\n\n신경 다양성을 가진 일부 플레이어들에게는 특정 요소를 제거하여 시각적 장면을 조정하는 것이 필수적일 수 있습니다. 이 수정은 그들이 받는 시각적 자극을 줄이고, 그들의 독특한 요구에 맞는 편안한 환경을 만들어냅니다.\n\n<div class=\"content-ad\"></div>\n\n게이머들은 오디오 설정을 조절하여 볼륨 레벨을 조절하거나 다른 오디오 채널을 관리하기를 원할 수 있습니다. 예를 들어, 플레이어는 음악을 줄이고 특정 효과음을 올려서 게임 진행을 완전히 이해할 수 있을 수도 있습니다. 이 유연성은 게임의 소리 신호를 통해 중요한 정보를 신뢰할 수 있게 흡수할 수 있도록 보장합니다.\n\n# 함께 하면 더 즐겁습니다\n\n친구나 가족과 함께 플레이할 수 있는 기능을 고려해보세요.\n\n어떤 플레이어들은 게임의 일부를 다른 사람에게 맡길 필요가 있을 수도 있습니다. 예를 들어, 플레이어는 버튼을 누를 수 있지만 조이스틱을 사용할 수 없을 수도 있습니다. 다른 사람이 다른 컨트롤러를 이용하여 함께 들어와 조이스틱을 통해 모든 움직임을 제어할 수 있다면, 다른 플레이어는 버튼을 전부 누를 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n예를 들어 Xbox는 Xbox Copilot을 통해 이 문제를 깔끔하게 해결했습니다. Copilot을 켜면 두 명의 플레이어가 각각 다른 컨트롤러를 사용하여 게임을 조종할 수 있습니다. 이는 \"플레이어들이 게임을 플레이하는 데 필요한 조작을 서로 나눠서 맡도록 할 수 있게 해주는데, 이는 한 명의 플레이어가 게임을 플레이하는 데 필요한 모든 행동을 처리할 수 없는 상황이거나 플레이어들이 공동 경험을 원할 때 유용합니다.\"\n\n난이도가 있는 섹션을 완수하거나 도전적인 퍼즐을 해결하거나 감정적인 콘텐츠를 다룰 때 다른 사람이 도와주는 것은 플레이어가 진전하는 데 큰 도움이 됩니다.\n\n이것은 장애를 가진 사용자들뿐만 아니라, 능숙하지 못한 어린 가족 구성원과 함께 게임을 완주할 수 있는 상황도 고려해보세요.\n\n이것은 플레이어 사이에 공동 경험을 만들어내는 협동 요소를 추가하는 재미있는 방법입니다. 게임이 협동 모드가 아니라면, 일반적으로 한 명이 플레이하는 경험이었던 것을 커플, 친구, 가족끼리 협력하여 공유할 수 있는 방법이 될 수도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 매크로\n\n마이크로소프트에 따르면, 매크로는 \"작업을 자동으로 수행하기 위해 하나의 명령으로 그룹화된 일련의 명령과 지시\"입니다.\n\n비디오 게임의 맥락에서, 이는 하나의 버튼을 동시에 또는 순서대로 여러 작업을 수행하도록 매핑하는 것이 될 수 있습니다.\n\n매크로가 흔한 게임인 월드 오브 워크래프트(WoW)를 살펴봅시다.\n\n<div class=\"content-ad\"></div>\n\nWoW은 전투 중 사용할 능력과 액션을 다량 제공하는 것으로 유명합니다. 게임 속에서 여러 막대에 시전할 주문들이 넘치게 되면서 플레이어들 중 일부는 여러 가지 주문들로 가득 찬 액션 바를 가지게 되었습니다.\n\n아래는 너무 많은 것들이 액션 바에 할당된 극단적인 예시의 스크린샷이지만, 요점은 전달됩니다.\n\n![WoW screenshot](/assets/img/2024-05-23-Designingaccessiblevideogames_3.png)\n\n매크로를 사용하면 단일 키가 한 번의 버튼 누름으로 여러 주문을 실행할 수 있도록 할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n버튼을 10번 누르는 작업이 1번으로 줄어들 수 있어요.\n\n게이밍에서 매크로의 주요 장점 중 하나는 개별 플레이어에게 맞춤형 솔루션을 제공할 수 있다는 점입니다.\n\n예를 들어, 신체적 장애가 있는 게이머들은 복잡한 키 조합이나 마우스 이동을 실행하는 데 어려움을 겪을 수 있습니다. 매크로를 사용하면 신체적 스트레인을 줄일 수 있어 게이머가 더 오래 플레이하고 더 즐거운 경험을 할 수 있도록 도와줍니다.\n\n게다가, 매크로 기능은 kognitive 어려움이나 처리 속도에 영향을 주는 상황에 있는 플레이어들의 반응 시간을 크게 향상시킬 수 있어요. 특정 작업들을 자동화함으로써 플레이어는 더 효율적으로 명령을 실행할 수 있어 게임의 속도에 맞춰 가는 데 도움을 줄 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n이 향상된 반응 시간은 접근성을 높이는 데 훌륭하지만, 멀티플레이 경험에서 부당한 이점에 대한 명백한 우려를 제기합니다. 모든 게임에서 플레이어가 매크로를 사용하는 것이 현실적으로 가능하지는 않을 수 있지만, 고려해 볼 것을 권장합니다.\n\n접근성에서 매크로의 역할에 관심이 있다면 Laura K Buzz의 이 비디오를 확인해보세요.\n\n# 대체 입력 장치 및 키 할당 재설정\n\n일반적인 컨트롤러를 대체 입력 장치로 교체하거나 키 할당을 재설정하는 것이 게임을 접근성 있게 만드는 중요한 부분입니다.\n\n<div class=\"content-ad\"></div>\n\n활동 제약이 있는 플레이어들에게는 적응형 컨트롤러, 스위치, 또는 동작 센서와 같은 대체 입력 장치를 연결할 수 있는 능력이 플레이 여부를 결정할 수도 있어요.\n\n발판부터 QuadStick와 같은 멋진 기술들이 많이 있어요. QuadStick은 입으로 작동하는 비디오 게임 컨트롤러입니다.\n\n게다가 여러 입력 장치를 사용할 수 있는 옵션은 맞춤형이고 유동적인 게이밍 경험을 촉진해요. 플레이어들은 자신의 편안함과 능력에 가장 잘 맞는 장치 조합을 선택할 수 있어서 자기 주도성과 포용성을 유발해요. 이는 장애가 있는 개인들의 접근성을 향상시키는 뿐만 아니라 다양한 게임 취향을 가진 광범위한 관객들에게도 맞춤화됩니다.\n\n모든 종류의 대체 컨트롤러와 설정을 사용하는 플레이어들로 테스트하는 것이 중요해요. 모든 것이 올바르게 작동하는지 확인하기 위해요.\n\n<div class=\"content-ad\"></div>\n\n플레이어들이 자신의 기기를 사용할 수 있는 것 외에도, 제어를 적절하게 다시 매핑할 수 있어야 합니다.\n\n키 바인딩 다시 매핑을 통해 개인들은 편리하고 관리하기 쉬운 키나 버튼에 명령을 할당할 수 있습니다. 예를 들어, 플레이어는 \"점프\"를 발판으로 또는 움직임 제어를 별도의 조이스틱으로 다시 매핑해야 할 수도 있습니다.\n\n다시 매핑은 모든 플레이어에게 혜택을 주는데, 왜냐하면 각자가 선호하고 익숙한 제어 방식이 있기 때문입니다. 특히 PC에서 게임을 열 때마다, 처음으로 하는 일 중 하나는 설정에 들어가서 쉽게 접근할 수 없는 키 바인딩을 다시 매핑하는 것입니다.\n\n이제 모든 이 키 다시 매핑과 사용자 정의 설정을 고려해주시고, 플레이어의 설정이 세션 간에 유지되도록 해주세요. 누군가가 게임에 들어가서 자신의 플레이 스타일과 고유한 요구를 맞추기 위해 설정을 완벽하게 조정하는 데 한 두 시간을 소비한다면, 돌아왔을 때 모든 게 완벽하게 유지되어야 합니다. 아무도 그 모든 작업을 다시 해야할 필요가 없습니다.\n\n<div class=\"content-ad\"></div>\n\n# 아직 나가지 마세요\n\n제가 다룬 내용은 게임 접근성을 위한 초반 작업에 불과해요.\n\n이 글에서는 적절한 자막 및 캡션 추가, 색맹을 위한 디자인, 컨트롤 감도 조절 등을 다루지 않았습니다.\n\n아래 링크된 멋진 자료들을 확인해보는 것을 강력히 권유합니다. 게다가 AbleGamer의 APX (Accessible Player Experiences) 인증 실무자가 되기 위한 2일 과정도 적극 추천해요. (저는 어떠한 방식으로도 후원받고 있지 않아요. 진심으로 이 과정을 좋아했습니다.)\n\n<div class=\"content-ad\"></div>\n\n## 더 읽을거리\n\n- 접근성은 쉽지 않아요: 게임을 모두에게 알맞게 만드는 것에 대해 '쉬운 모드' 논의에서 빠뜨리는 것 →\n\"난이도가 높은 게임을 더 접근성 있게 만드는 것은 난이도 수준을 넘어서 하는 일입니다.\" \n- 접근 가능한 플레이어 경험 (APX) 패턴 →\n독특하고 플레이어가 자신의 Bedz어에 맞게 조절할 수 있는 플레이 경험이 확보되도록 하는 도전과 접근 패턴 목록. 정말 확인해보세요.\n- 접근 가능한 비디오 게임 디자인 →\n이 기사를 좋아하신다면, 다른 기사도 마음에 드실 거에요.\n- BBC 자막 가이드 라인 →\n여러분 모두에게 자막을 읽을 수 있고 접근할 수 있게 만드는 방법을 배워보세요.\n- 게임 접근성 지침 →\n게임을 접근성 있게 디자인하는 데 가장 필요한 도구/자료 중 하나에요.\n- 게임 제작자의 도구킷(TK) - 비디오 게임 접근성 재생 목록 →\n게임 개발자라면 꼭 봐야 할 GA 재생 목록으로, 접근성이 있는 비디오 게임을 디자인하는 방법이 가득 담겨 있어요. 이 동영상은 꼭 시청해야 할 필수영상입니다.\n\n여러분들의 생각이나 경험이 있으면, 알려주세요! 이 게시물에 응답하거나 LinkedIn에서 알려주세요. UX나 비디오 게임 관련해서 어떤 주제라도 얘기 나누는 것을 즐깁니다.\n\n✨ 누군가에게 UX 디자이너가 필요하다면, 저에게 연락해주세요!","ogImage":{"url":"/assets/img/2024-05-23-Designingaccessiblevideogames_0.png"},"coverImage":"/assets/img/2024-05-23-Designingaccessiblevideogames_0.png","tag":["Tech"],"readingTime":15},{"title":"내가 마케터가 되고 싶지 않았어요 게임","description":"","date":"2024-05-23 13:41","slug":"2024-05-23-IDidntWanttoBeaGameMarketer","content":"\n\n![image](/assets/img/2024-05-23-IDidntWanttoBeaGameMarketer_0.png)\n\n아마도 제가 거절한 사람은 오늘 인도네시아의 가장 큰 인디 게임 회사 중 하나의 마케팅 책임자로 일하고 있는 저를 보고 궁금해 할 것입니다. 저 자신도 제 결정에 대해 여전히 의문을 품고 있습니다.\n\n예전엔 마케팅이 거짓말을 하는 것이라고 생각했어요. 나라에서 가장 인기 있는 제품이 되거나, 그 지역에서 가장 인기 있는 음식점이 된다는 것... \"마케팅\"이라는 말이 별로 듣기 싫었죠. 사람들에게 실망시키는 결과를 원하지 않았어요. 아마 사람을 기쁘게 해주는 것은 고집스러운 사람의 기본적인 성격인 것 같아요. 그리고 저는 그런 사람이에요.\n\n2014년 초, 대학을 졸업한 뒤 첫 직장을 얻었습니다. 저는 그래픽 디자인을 공부했기 때문에, 한 모바일 게임 회사에 2D 아티스트로 지원했고 합격했어요! 하지만, 속은 느낌이 들었어요. 그들은 당시 회사를 떠나는 커뮤니티 매니저를 대신할 수 있느냐고 물었어요. 그냥 잠깐이라고 했어요. 그런데, 2.5년이 지나가고 나는 커뮤니티 관리 이상을 했습니다. 유저 유치, 비즈니스 개발, 약간의 모바일 게임 마케팅, 투자자들에게 프레젠테이션을 하는 법 등 Adobe Photoshop이나 Illustrator를 사용하는 일과는 관련이 없는 일들을 배웠어요.\n\n\n<div class=\"content-ad\"></div>\n\n그때, 내가 모바일 게임 마케터로 근무한 직업을 좋아했었나요? 음.\n\n2017년, 1년 동안 미술 교사로 일한 후 게임 산업으로 돌아와 다시 커뮤니티 매니저가 되었습니다. 이번에는 프리미엄 PC(및 콘솔) 인디 게임 회사에서 일하는 기회를 얻었는데, 모바일 게임과는 전혀 다른 비즈니스 모델을 가지고 있습니다. 쉽다고 생각했지만, 아니었습니다. 커뮤니티, 시장 행동, 사용해야 했던 방법 등 모든 것이 달랐습니다.\n\n하지만 그럼에도 게임 마케팅을 하는 것에서 좋아하는 점을 발견했습니다. 특히 프리미엄 게임에 대한 마케팅을 좋아하는 것이었죠.\n\nSeth Godin의 All Marketers Are Liars (Tell Stories)를 읽은 후에 다시 깨닫게 되었습니다. 책을 아직 다 읽지 못했는데, 지금은 친구가 책을 빌려가고 있어요. 그러나 지금까지는 좋은 읽을거리입니다.\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-05-23-IDidntWanttoBeaGameMarketer_1.png)\n\n책에 대해 얘기하지 않을 거예요. 대신 (프리미엄) 게임 마케터로서 이야기를 전하는 방법에 대해 조금 이야기해 볼게요.\n\n솔직하지 않을 수 없어요.\n\n모바일 및 프리미엄 게임의 마케팅을 해본 경험을 통해, 프리미엄 게임 플레이어에게는 솔직하지 않을 수 없다는 것을 배웠어요. 모바일에서는 가짜 광고를 사용하여 다운로드를 받고 설치 횟수가 중요한 반면, 프리미엄 게임 플레이어들은 언제든지 환불을 요청하거나 안 좋은 리뷰를 남겨서 당신의 게임이 사람들에게 구매되지 않도록 할 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n게이머들은 똑똑해요. Steam에서 보던 리뷰들을 구글 플레이나 앱 스토어에서 본 것과 비교했을 때 정말 놀랐어요. 거기서 1점을 주고 \"좋은 게임\"이라고 리뷰하는 것들과는 달리 PC와 콘솔 게이머들은 건설적인 피드백을 주고 게임에서 좋은 점이 무엇인지, 어떤 것이 좋았는지 등을 지적해 줘요.\n\n그저 게임의 좋은 점을 보여주세요.\n\n게임의 픽셀 아트가 잘 만들어졌다고 생각하시나요? 그것이 어떻게 만들어졌는지 보여주고, 게임 안에서 픽셀 아트가 얼마나 멋있게 보이는지 보여주세요. 게임이 가장 맛있는 전투 메카닉을 가지고 있다고 생각하시나요? 동영상을 찍어서 보여주세요. 게임의 음악이 좋으시다고 생각하시나요? 그 음악을 들려주세요.\n\n하지만 기억하세요, 마지막으로 게임을 좋아하는지 결정할 사람들은 잠재적 플레이어들이겠죠... 이것은 시장 유효성을 확인할 때 사용할 수 있어요. (이 말을 설명할 필요가 없는데요, 이것은 별도의 글이 될 수 있기 때문에)\n\n<div class=\"content-ad\"></div>\n\n진정성에 관한 이야기예요.\n\n진정성은 매우 중요해요, 특히 당신의 게임이나 회사가 오랫동안 지속되길 원하고 강력한 커뮤니티나 팬 베이스를 갖고, 당신이 즐겁게 제작하는 게임을 계속 제공하고 싶을 때입니다.\n\n저는 현재 회사에서 거의 7년째 근무하고 있어요. 만약 저가 내가 아닌 다른 사람으로 가장해야 하거나 좋아하지 않거나 즐기지 않는 것을 홍보해야 한다면, 이렇게 오래 지속되지 못할 것 같아요. 제가 알고 있는 게임의 좋은 점을 공유하고, 개발자가 이 게임을 만드는 이유를 말해요... 그리고 나는 운이 좋아 내가 게임을 홍보하고 일하는 것을 즐길 수 있는 회사에서 일하고 있다고 생각해요.\n\n이게 회사가 개발하는 모든 게임을 즐기는 것을 의미할까요? 저는 캐주얼 게이머예요. 전략이나 턴 기반 전술 게임을 할 수 없어 해전 게임, 혹은 전략을 구상해야 하는 게임을 할 수 없어요. 하지만, 우리 회사의 주력 타이틀 중 하나는 턴 기반 메카 전략 게임이에요. 그럼에도 불구하고, 팀이 이 게임을 얼마나 사랑하는지 알기 때문에, 제가 할 일은 그들이 왜 그것을 좋아하는지 물어보고, 어떤 것을 사람들에게 보여주길 원하는지 알아내는 것 뿐이에요.\n\n<div class=\"content-ad\"></div>\n\n저는 게임 마케터로 일하는 것을 좋아하나요?\n\n음, 솔직히 말하자면... 제 꿈은 고양이들과 함께 집에서 종일 게임을 하며 간식을 먹고 일하지 않아도 되는 거예요. 그렇지만 그런 꿈이지만 현재로서는 일하는 것을 즐기는 직업이에요.\n\n그런데 여러분은요? 여러분의 이야기는 무엇인가요?\n","ogImage":{"url":"/assets/img/2024-05-23-IDidntWanttoBeaGameMarketer_0.png"},"coverImage":"/assets/img/2024-05-23-IDidntWanttoBeaGameMarketer_0.png","tag":["Tech"],"readingTime":3},{"title":"Roomsxyz에서의 프로그래밍 파트 1","description":"","date":"2024-05-23 13:39","slug":"2024-05-23-ProgramminginRoomsxyzPart1","content":"\nPart 1 | Part 2 | Part 3\n\nRooms.xyz은 정확히 판타지 콘솔은 아니지만 (과거 몇 가지 기사를 써온 주제) 많은 동일한 원칙을 공유합니다. 그것은 당신이 보설 기반 미니 게임과 상호 작용 경험을 매우 쉽게 만들 수 있는 도구이며, 보설 객체와 Lua 스크립팅을 사용합니다.\n\n공개: 나는 Rooms.xyz 뒤의 3인 스타트업 \"Things, Inc.\"의 직원입니다. \"Inc\" 부분이 다소 기업적으로 보일 수 있지만, 사실은 우리는 무엇을 하는지 모르지만 멋진 것을 만들고 싶어 하는 3인 조직입니다.\n\n이 기사는 객체의 동작을 사용자 정의하기 위해 Rooms에서 Lua 코드를 작성하는 방법의 프로그래밍 모델과 기본 사항 (매우 표면적으로)을 면밀히 살펴봅니다.\n\n<div class=\"content-ad\"></div>\n\nPart 1에서는 기초 사항을 다룰 것입니다:\n\n- 방과 물건\n- 기본 프로그래밍\n- 물건 이동\n- 순서\n\n![이미지](/assets/img/2024-05-23-ProgramminginRoomsxyzPart1_0.png)\n\n# 프로그래밍을 해야 할까요?\n\n<div class=\"content-ad\"></div>\n\n음, 디저트를 먹어야 하나요? 이 기사의 전제는 당신이 프로그래밍에 흥미를 느끼며 프로그래밍이 재미있다는 것입니다. 사실 당신과 나는 당신을 프로그래밍을 하지 못하게 하는 데는 약간의 노력이 필요할 것을 알고 있어요. 만약 토스트기에 API가 있다면 당신은 그것을 프로그래밍할 것입니다. 아마 그것에 API가 있는지도 모르겠네요. 토스트기 프로그래밍을 멈추고 돌아오세요.\n\n이 모든 말의 요점은: 아니, Rooms에서 프로그래밍을 할 필요는 없어요. 단순히 기존 객체를 기반으로 아름다운 방을 만들 수 있어요(라이브러리에는 많은 객체가 있어요!), 많은 객체는 이미 기존 동작을 갖고 있어요. 그러나 높은 천장에 다다르고 동작이 재미있고 독특한 방을 만들고 싶다면, 프로그래밍이 그 방법이에요!\n\n# 방이란 무엇인가요?\n\n방은 작은 상호작용 3D 환경입니다. 그게 바로 당신이 만들고 있는 것. 방이나 상호작용 3D 환경에 흥미가 없다면, 저런, Rooms.xyz를 즐기진 못할 거예요. 방은 미니 게임이 될 수도 있고 사용자가 접근할 수 있는 즐거운(아닐 수도 있지만, 우리는 그렇길 바래요) 경험이 될 수도 있어요.\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-05-23-ProgramminginRoomsxyzPart1_1.png)\n\n이것은 미니 게임의 예시입니다. 볼링공을 클릭하여 볼링을 할 수 있는 미니 볼링 게임입니다. 아마 볼링은 이렇게 하는 거겠지요.\n\n# 물건이란?\n\n물건이란 객체입니다. 정말, 물건? 더 일반적인 이름을 선택할 수 없었을까요? 음, 네, 객체는 더 일반적이었겠죠. 가끔 커피를 충분히 마시지 않은 경우에는 그것들을 객체라고도 부르기도 합니다.\n\n<div class=\"content-ad\"></div>\n\n그래서 방 안에 있는 각 물체는 물체(Thing)입니다. 위쪽 방에서 볼링공은 물체입니다. 각 핀도 물체이고, 테이블도 물체이며, 쥬크박스도 물체입니다. 이해하시죠. 모든 것이 물체입니다.\n\n(\\*) 벽과 바닥도 물체입니다만, 누구에게도 말하지 마세요. 왜냐하면 이건 우리 디자인의 이상한 부분이라서 아직 그것이 맞는지 확신하지 못하기 때문이에요.\n\n# 물체를 그렇게 행동하게 만드는 것은 무엇인가요?\n\n스포일러 경고: 코드입니다. 다른 것으로 생각했나요?\n\n<div class=\"content-ad\"></div>\n\n수정 모드에서 물건을 클릭하고 \"Code\" 버튼을 클릭하면 코드 편집기가 표시됩니다.\n\n<img src=\"/assets/img/2024-05-23-ProgramminginRoomsxyzPart1_2.png\" />\n\n코드 편집기에 Lua 코드를 입력할 수 있습니다. Lua는 브라질인이 만든 사랑스러운 스크립트 언어입니다. 나도 브라질인은 아니에요. 다른 브라질인이 만든 거에요. 우리가 참 많죠.\n\n어쨌든, Lua를 자바스크립트의 불편한 부분 없는 버전으로 생각해보세요.\n\n<div class=\"content-ad\"></div>\n\n\n![ProgramminginRoomsxyzPart1_3](/assets/img/2024-05-23-ProgramminginRoomsxyzPart1_3.png)\n\n우리가 코드가 없기 때문에 처음부터 시작할 필요가 없다는 메시지가 나옵니다. 간단한 템플릿을 선택하여 시작하는 것이 좋습니다. Hello 템플릿을 선택해주세요. 이 템플릿을 사용하면 좋습니다. 왜냐하면 더 복잡한 것들을 탐험할 때 직접 모든 것을 배울 수 있다는 것을 깨닫고 이 기사를 읽는 것을 중단할 수도 있기 때문입니다.\n\n또한 모든 API 함수에 대한 완전한 문서가 있으므로 이 자습서를 읽은 후 (또는 중간 중간에) API가 수행할 수 있는 모든 것을 알아볼 수 있습니다.\n\n# 코딩에 들어가기 전에...\n\n\n<div class=\"content-ad\"></div>\n\nRooms.xyz에서 작업을 저장하려면 회원 계정을 만들어야 합니다. 현재 Rooms.xyz가 알파 상태이기 때문에 공식 홈페이지를 통해 초기 액세스를 요청해야 합니다. 홈페이지에서 \"초기 액세스 요청\" 버튼을 클릭하면 됩니다.\n\n그러나 계정을 만들지 않고도 이 튜토리얼을 따라할 수 있습니다. 유일한 주의점은 만든 방을 저장하고 공유할 수 없다는 것입니다.\n\n# 안녕하세요라고 말하기\n\n안녕하세요 템플릿을 클릭하면 미리 작성된 코드가 표시됩니다. 클릭하면 객체가 \"안녕하세요\"라고 말하는 매우 흥미진진한 스크립트입니다.\n\n<div class=\"content-ad\"></div>\n\n\n![Programming in Roomsxyz Part1_4](/assets/img/2024-05-23-ProgramminginRoomsxyzPart1_4.png)\n\nNow run it, either in the preview window (click Update Preview), or get out of the code editor and enter Preview mode.\n\nThis thing at the top is how you switch from Edit to Preview (that is, Play) mode. You probably already figured this out, but just in case, it's here:\n\n![Programming in Roomsxyz Part1_5](/assets/img/2024-05-23-ProgramminginRoomsxyzPart1_5.png)\n\n\n<div class=\"content-ad\"></div>\n\n테이블 태그를 마크다운 형식으로 변경해 보세요.\n\n<div class=\"content-ad\"></div>\n\n앞으로는 코드 스크린샷을 찍지 않을 거에요 (코드를 보여주는 바보 같은 방식이라서, 커피숍에서 다른 개발자들이 내 모습을 이상하게 쳐다보고 있거든). 대신에 이렇게 작은 블록 안에 코드를 직접 쓸 거에요:\n\n```js\n-- 사용자가 클릭했을 때 실행되는 함수입니다.\nfunction onClick()\n  say(\"Hello\")\nend\n```\n\n물론 그 테이블이 모든 걸 상상할 수 있는 어떤 말이라도 할 수 있도록 string을 수정할 수 있어요. 완전히 다른 문구인 아래와 같이요:\n\n<img src=\"/assets/img/2024-05-23-ProgramminginRoomsxyzPart1_7.png\" />\n\n<div class=\"content-ad\"></div>\n\n당신이 더 나은 내용을 찾을 수 있다고 확신해요.\n\n# 핸들러 (미리 정의된 함수)\n\n이전 예제에서 우리의 함수는 onClick으로 불렸어요. 이것은 우연이 아니에요: 사용자가 무언가를 클릭할 때 실행되는 함수에요. 모든 Thing은 고유의 onClick 함수를 가질 수 있어요.\n\n이것은 중복되어 보일 수 있지만, onClick 함수는 반드시 onClick으로 불러져야 해요. \"onclick\"이나 \"ONCLICK\"이나 \"clementine\"으로 불러도 작동하지 않아요. 엔진은 정확히 onClick이라는 이름을 대소문자 구분하여 찾기 때문이에요.\n\n<div class=\"content-ad\"></div>\n\n일부 다른 핸들러 함수의 예시는 다음과 같습니다:\n\n- onStart(): 방이 시작될 때 호출됩니다.\n- onCollision(): 물체가 다른 물체와 충돌할 때 호출됩니다.\n- onButtonDown(): 가상 조이스틱 버튼이 눌렸을 때 호출됩니다.\n- onButtonUp(): 가상 조이스틱 버튼이 놓였을 때 호출됩니다.\n- onUpdate(): 한 프레임당 한 번 호출됩니다 (초당 60번).\n\n지금은 이에 대해 걱정할 필요가 없어요. 다음에 일부를 살펴볼 텐데, 그 중 일부는 무시할 거에요. 하지만 그 당시에는 멀리 나아가서 당신이 이 목록을 기억할 정도가 되지 않을 거예요. 그리고 제가 이를 건너뛰었다는 걸 알아차리지 못할 거에요.\n\n# onStart() 함수\n\n<div class=\"content-ad\"></div>\n\n방이 시작할 때 사용자의 작업과 상관없이 무언가를 하고 싶을 때 유용한 기능이에요.\n\n```js\n-- 방이 시작할 때 이 함수가 실행됩니다.\nfunction onStart()\n  say(\"나를 클릭해주세요!\")\nend\n\n-- 사용자가 클릭할 때 이 함수가 실행됩니다.\nfunction onClick()\n  say(\"클릭해주셔서 감사합니다\")\nend\n```\n\n원하는 경우에는 onStart() 안에 초기화 코드를 넣는 대신 함수 밖에 초기화 코드를 놓을 수도 있어요. 이건 스타일의 문제에요:\n\n```js\n-- 방이 시작할 때 이 코드가 실행됩니다.\nsay(\"나를 클릭해주세요!\")\n\n-- 사용자가 클릭할 때 이 함수가 실행됩니다.\nfunction onClick()\n  say(\"클릭해주셔서 감사합니다\")\nend\n```\n\n<div class=\"content-ad\"></div>\n\n\n나는 onStart() 안에 있다면 더 깔끔하다고 생각해요. 개인 취향입니다.\n\n# 물리학에 대한 이야기\n\n코드를 따라하며 작업하는 경우, 작업 중인 객체가 물리 유형으로 Kinematic으로 설정되어 있는지 확인하세요. 나중에 더 설명하겠지만, Kinematic 객체는 원하는대로 동작합니다. 동적(비 키네마틱) 객체는 자기 맘대로 동작합니다. 우리는 현재 주인공이니까 그것을 키네마틱으로 설정해서 우리가 움직일 수 있게 해야 해요.\n\n\n# 물리학에 대한 이야기\n\n코드를 따라하며 작업하는 경우, 작업 중인 객체가 물리 유형으로 Kinematic으로 설정되어 있는지 확인하세요. 나중에 더 설명하겠지만, Kinematic 객체는 원하는대로 동작합니다. 동적(비 키네마틱) 객체는 자기 맘대로 동작합니다. 우리는 현재 주인공이니까 그것을 키네마틱으로 설정해서 우리가 움직일 수 있게 해야 해요.\n\n<div class=\"content-ad\"></div>\n\n# 한 번 시도해보세요!\n\n이 코드를 객체에 적용해보세요. 시작점이 필요하다면 https://rooms.xyz/btco/tutostart에서 시작해보세요. 택시를 클릭하고 코드를 다음과 같이 설정하세요:\n\n```js\n-- 사용자가 클릭했을 때 실행되는 함수입니다.\nfunction onClick()\n  startSpin()\nend\n```\n\n이제 미리보기 모드로 이동하여 클릭해보세요. 회전하기 시작해야 합니다! 실제 자동차에서는 시도하지 마세요. 일반적으로 이 튜토리얼로부터 운전 조언을 받지 마세요.\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*z8Qu3AWjVrfDKmP1mCaRfw.gif)\n\n[여기](https://rooms.xyz/btco/tutospin)에서 결과물을 확인해보세요.\n\n# 즉시 이동하기 (애니메이션 없이)\n\n만약 물체를 새로운 위치로 이동하고 싶다면, setPosition() 함수를 사용하고 새로운 좌표를 알려주면 됩니다:\n\n\n<div class=\"content-ad\"></div>\n\n```js\nfunction onClick()\n  -- 방의 중앙으로 이동합니다.\n  setPosition(0, 0, 0)\nend\n```\n\n클릭하면 빠앗, 갑자기 방의 중앙으로 이동합니다 (아마도 차의 탑승자들에게는 매우 거친 경험이 될 것입니다).\n\n결과를 확인하려면 다음 링크를 방문해 보세요: https://rooms.xyz/btco/tutosetpos.\n\n# 부드럽게 이동하기 (애니메이션 포함)\n\n<div class=\"content-ad\"></div>\n\n멋져요! 이제 객체를 순조롭게 이동시키는 방법을 알아보겠습니다. 객체를 순간이동시키는 것이 아닌 특정 양만큼 부드럽게 이동시키려면 startMoveBy() 함수를 사용하면 됩니다. 이 함수는 delta(x, y, z)와 총 시간을 인수로 받아 요청한 위치로 객체를 이동시킵니다.\n\n```js\n-- 사용자가 클릭했을 때 실행되는 함수.\nfunction onClick()\n  say(\"출발합니다!\")\n  -- 1초 동안 남쪽으로 30단위 이동합니다.\n  startMoveBy(0, 0, -30, 1)\nend\n```\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/1*VXfa4E4HAm71LVNfawS4vA.gif\" />\n\n왜 0, 0, -30일까요? 우리의 좌표 시스템이 그런식으로 작동하기 때문이죠:\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-05-23-ProgramminginRoomsxyzPart1_9.png\" />\n\n그래서 +Z는 왼쪽 벽 쪽이고, +X는 오른쪽 벽 쪽입니다. Cardinal 방향은 다음과 같이 정의합시다:\n\n- \"북쪽\"이라고 할 때, +Z 쪽을 의미합니다.\n- \"동쪽\"이라고 할 때, +X 쪽을 의미합니다.\n- \"남쪽\"이라고 할 때, -Z 쪽을 의미합니다.\n- \"서쪽\"이라고 할 때, -X 쪽을 의미합니다.\n- \"위쪽\"이라고 할 때, +Y 쪽을 의미합니다.\n- \"아래쪽\"이라고 할 때, -Y 쪽을 의미합니다.\n\n그리고 방의 중심은 (0, 0, 0) 입니다. 이는 방 중앙에 있는 바닥의 지점을 의미합니다. 방의 표면은 약 95x95의 크기이며, 높이는 75 단위입니다. 따라서 X와 Z 좌표는 약 -47.5에서 +47.5까지이며, Y 좌표는 0에서 75까지입니다.\n\n<div class=\"content-ad\"></div>\n\n결과를 확인하려면 다음 주소를 확인해보세요: [https://rooms.xyz/btco/tutomove](https://rooms.xyz/btco/tutomove)\n\n# 움직이고 멈추는 차\n\n오늘 시장에서 가장 좋은 차들은 움직이고 멈추는 기능을 갖추고 있어요. 함께 만들어 보도록 하죠. 클릭하면 차가 움직이고, 다시 클릭하면 멈추는 기능을 만들어 보겠습니다. 이제 코드를 확인해봅시다:\n\n```js\nmoving = false\n\n-- 사용자가 클릭했을 때 실행되는 함수입니다.\nfunction onClick()\n  if moving then\n    stopMove()\n    moving = false\n  else\n    startMoveBy(0, 0, -48, 10)\n    moving = true\n  end\nend\n```\n\n<div class=\"content-ad\"></div>\n\n이 예시는 startMoveBy()로 시작된 모션을 중지하기 위해 stopMove()를 호출하는 방법을 보여주며, 차량의 상태(이동 중 또는 이동 중이 아님)를 추적할 수 있는 불리언 변수를 가지는 방법을 보여줍니다. 또한 함수 외부에 변수가 존재할 수 있음을 보여주며, 이는 함수 내에서 선언된 경우 함수 호출 간에 값을 유지할 수 있음을 보여줍니다.\n\n결과를 확인하세요: https://rooms.xyz/btco/tutostartstop\n\n# 순차적 실행\n\n의도하지 않은 점 중 하나는 say(), startMoveBy() 등과 같은 함수가 비동기적이라는 것입니다. 즉, 이 함수들은 코드의 실행이 계속될 동안 백그라운드에서 실행됩니다. 따라서 이러한 함수를 여러 번 호출하는 경우 이 함수들은 함께 실행되며 순차적으로 실행되지 않습니다. 예를 들어:\n\n<div class=\"content-ad\"></div>\n\n```js\n-- 경고: 이것이 하는 것 같은 일은 하지 않습니다.\nfunction onClick()\n  -- 남쪽으로 20 단위 이동, 1초 동안에.\n  startMoveBy(0, 0, -20, 2)\n  -- 서쪽으로 20 단위 이동, 1초 동안에.\n  startMoveBy(-20, 0, 0, 2)\n  -- 작업이 완료되었다고 말합니다.\n  say(\"작업 완료\")\n  -- 회전을 시작합니다.\n  startSpin()\nend\n```\n\n자동차가 먼저 남쪽으로 20 단위 이동하고, 그런 다음 서쪽으로 20 단위 이동하고, \"작업 완료\"를 말하고 회전을 시작할 것이라고 생각할 수 있습니다. 하지만 실제로 모든 것을 동시에 시도하려고 하고 정말 엉망입니다.\n\n그래서 어떻게 해야 하나요? 다른 함수를 우리 레퍼토리에 추가해야 합니다. 그리고 레퍼토리는 멋진 프랑스어 단어이기도 하니까! 그 함수는 wait()입니다. 특정 시간을 기다렸다가 다른 함수를 호출합니다. 우리는 순서대로 수행하기 위해 이를 사용할 수 있습니다.\n\n```js\nfunction onClick()\n  -- 남쪽으로 20 단위 이동, 1초 동안에.\n  startMoveBy(0, 0, -20, 1)\n  -- 1초 기다립니다 (이동하는 데 걸리는 시간)\n  -- 그리고 moveWest를 호출합니다.\n  wait(1, moveWest)\nend\n\nfunction moveWest()\n  -- 서쪽으로 20 단위 이동, 1초 동안에.\n  startMoveBy(-20, 0, 0, 1)\n  -- 1초 기다립니다 (이동하는 데 걸리는 시간)\n  -- 그리고 sayDone을 호출합니다.\n  wait(1, sayDone)\nend\n\nfunction sayDone()\n  say(\"작업 완료\")\n  -- 회전을 시작합니다.\n  startSpin()\nend\n```\n\n<div class=\"content-ad\"></div>\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*CL1gPOlI-i0jEA8VNiiH1w.gif)\n\n이건 동작합니다. 차가 옆으로 드리프트하고 회전하지 않는다는 사실을 제외하고 잘 작동합니다. 하지만 운전 팁은 제게 말하지 않았나요?\n\n결과를 확인하세요: [여기](https://rooms.xyz/btco/tutoseq)\n\n# 주기적으로 무언가를 수행하기\n\n<div class=\"content-ad\"></div>\n\n특정 간격마다 주기적으로 함수를 호출하려면 every()를 사용할 수 있습니다.\n\n여기 한 예제가 있어요. 이러한 예제의 효과를 해소하기 위해 커피를 마셔야 합니다.\n\n이 예에서 양은 다음과 같은 코드를 가지고 있습니다:\n\n```js\nc = 0\n\nfunction onStart()\n  -- count() 함수를 1초마다 호출합니다.\n  every(1, count)\nend\n\nfunction count()\n  c = c + 1\n  say(c .. \" sheep\")\nend\n```\n\n<div class=\"content-ad\"></div>\n\n\n그래서 onStart()에서 우리는 count() 함수가 매 초 호출되기를 원한다고 말합니다. 엔진은 매 초 count() 함수를 호출하여 우리는 카운터를 증가시키고 양이 현재 카운트를 말하도록합니다.\n\n![이미지](/assets/img/2024-05-23-ProgramminginRoomsxyzPart1_10.png)\n\n결과 확인: https://rooms.xyz/btco/tutocount\n\n참고: 성능상의 이유로 간격을 0.25초보다 작게 설정할 수 없습니다. 그러나 다른 방법으로 여전히 성능을 저하시킬 수 있으니 포기하지 마세요.\n\n\n<div class=\"content-ad\"></div>\n\n# Part 1 마침\n\n와우! 이렇게 멀리 진전했고 내 유머 감각과 글쓰기 스타일을 참으셨군요. Part 2에서 더 나아갈 수는 없지만, 아래 링크를 클릭해서 계속 진행해보세요.\n\nPart 2로 이동하기 →\n","ogImage":{"url":"/assets/img/2024-05-23-ProgramminginRoomsxyzPart1_0.png"},"coverImage":"/assets/img/2024-05-23-ProgramminginRoomsxyzPart1_0.png","tag":["Tech"],"readingTime":11},{"title":"100일간의 스팀 세일 분석","description":"","date":"2024-05-23 13:36","slug":"2024-05-23-100DaysofSteamSalesAnalysis","content":"\n게임 개발 산업에 종사한 사람이라면, 성공적인 게임을 만드는 것이 얼마나 어려운지 알 것입니다. 누구도 그 공식을 알아내지 못했습니다. 모든 것을 올바르게 해도 실패할 수 있죠.\n\n우리는 소중한 성공 사례에 감격합니다. Stardew Valley, Lethal Company, Undertale. 가능합니다. 그러나 성공 사례마다 수천 개의 잊혀진 실패 사례가 있습니다.\n\n우리는 우리의 열정적인 프로젝트에 수백 시간을 투자합니다. 고용주들이 수십만 달러를 쓸 것이라고 확신할 수도 있는 노동이죠. 대신 우리는 모든 걸 스스로에게 걸어, 대부분 몇 달러만 돌려받게 됩니다.\n\n우리는 용감한 건지, 그냥 바보인 건지요?\n\n<div class=\"content-ad\"></div>\n\n이 질문을 해결하고 동료 개발자들에게 희망을 줄 수 있기를 바라며, 2023년 1월 1일부터 스팀에서 출시된 게임 100일을 살펴보고 판매 성적을 분석하여 모두가 꿈을 이루는 확률을 알아보았습니다.\n\n# 개요\n\n100일 동안 총 2823개의 유료 게임이 출시되었으며, 하루 평균 새로운 게임은 28개입니다.\n\n스팀 수수료를 고려한 평균 매출은 228,723달러(미국 달러)였습니다.\n\n<div class=\"content-ad\"></div>\n\n처음에는 좋아 보일 수 있지만, 스팀 세일은 공격적인 파레토 분포를 따릅니다. 이는 일반적으로 '80:20' 규칙으로 알려진데, 입력의 20%가 결과의 80%를 만든다는 의미입니다.\n\n스팀 세일은 조금 더 극단적입니다:\n\n\n![Steam Sales Analysis](/assets/img/2024-05-23-100DaysofSteamSalesAnalysis_0.png)\n\n\n중앙값 수익, 즉 평균 게임이 벌어들인 금액에 더 관심이 있습니다. 이를 시각화하기 쉽게 만들기 위해 10만 달러 이상 벌어든 모든 게임을 제거해 보겣습니다.\n\n<div class=\"content-ad\"></div>\n\n![Image](/assets/img/2024-05-23-100DaysofSteamSalesAnalysis_1.png)\n\n`스팀`의 수익 중앙값은 `대단한` $799 미국 달러였습니다. 처참해 보일 수 있지만, 이 데이터를 다른 말로 바꾸면 더 희망적으로 보일 수 있습니다.\n\n출시된 게임 중 1개당 $1,000,000 이상을 벌어들인 게임은 42개 중 1개이며, 매주 4개의 초대 성공적인 게임을 나타냅니다.\n\n게임 중 1개당 $100,000 이상을 벌어들인 게임은 12개 중 1개이며, 주당 17개의 성공적인 게임을 나타냅니다.\n\n<div class=\"content-ad\"></div>\n\n만약 당신의 게임이 상위 8%에 들면 생계를 유지할 수 있어요. 상위 2%에 들면 거액의 수익을 올릴 수 있어요.\n\n어렵긴 하지만 불가능하진 않아요.\n\n안타깝게도, 5개 중 1개 게임은 $100 미만 수익을 올렸어요. 매주 40개의 실패한 게임이 있어요.\n\n**방법**\n\n<div class=\"content-ad\"></div>\n\nSteams API를 사용하여 100일 간의 게임 출시를 가져 와 파싱하기 위해 파이썬을 사용했습니다. 나쁜 항목을 제거하고 JSON 구조를 단순화 한 후 CSV로 변환하여 다음과 같이 구글 스프레드 시트로 가져왔습니다:\n\n[구글 스프레드 시트 링크](https://docs.google.com/spreadsheets/d/1T-Tw6PwxEAqYMnos5pYwRbwcNVacYn9zCt6HpL9jLfQ/edit?usp=sharing)\n\n<img src=\"/assets/img/2024-05-23-100DaysofSteamSalesAnalysis_2.png\" />\n\n스팀 API에서 얻을 수 없는 유일한 측정 항목은 수익이었습니다. 그러나 스팀 게임이 소유자 대 리뷰 비율이 30 대 1로 매우 잘 알려져 있으며 이는 모든 게임에 90%의 상관 관계를 가지고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n소스: https://vginsights.com/insights/article/further-analysis-into-steam-reviews-to-sales-ratio-how-to-estimate-video-game-sales\n\n스팀은 플랫폼의 매출에서 30%의 수수료를 가져갑니다. 이는 순수 매출로 이어집니다.\n\n# 양적 데이터\n\n장르, 콘텐츠 등급 및 VR 지원과 같은 기능과 같은 요인별 중앙값 매출을 분석해 봅시다. 먼저 장르부터 시작합니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-05-23-100DaysofSteamSalesAnalysis_3.png\" />\n\n친구들 게임이 MMO RPG보다 현저히 성적이 안 좋다는 것을 알 수 있어요. 하지만 이러한 모바일 게임들이 몇 일 만에 만들어질 수 있다는 사실을 고려해야 해요. 한편 MMO는 큰 예산과 수 년의 생산 시간을 요구해요.\n\n다음은 플랫폼 분포를 살펴봅시다.\n\n<img src=\"/assets/img/2024-05-23-100DaysofSteamSalesAnalysis_4.png\" />\n\n<div class=\"content-ad\"></div>\n\n파레토 분포에 관한 보편적인 사실 중 하나는 그의 공격적인 정도가 데이터 세트의 크기와 비례한다는 것입니다. 다시 말해, 경쟁이 더 많은 시장에서는 불평등이 더 많이 나타납니다.\n\n간단히 맥(mac)의 게임이 더 적기 때문에 경쟁이 적고, 구매자가 게임을 선택할 기회가 더 많습니다.\n\n재미있게도, VR의 수익성은 크게 감소했습니다. 일정 시점에는 게임 수가 적어서 매출 중앙값이 $150,000에 이르렀습니다.\n\n마지막으로 콘텐츠 등급을 살펴보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n\n![image](/assets/img/2024-05-23-100DaysofSteamSalesAnalysis_5.png)\n\n데이터 세트에서 대략 10%의 게임이 '성인 전용'으로 표시되어 있습니다. 이들은 평균적인 게임만큼 잘 할 수 있었습니다. 다른 한편으로, 폭력은 명백히 경쟁에서 우위를 차지했습니다.\n\n이 데이터의 타당성도 살펴보겠습니다. 각 게임이 출시 월에 따라 얼마나 많은 수익을 올렸는지부터 시작해 보죠.\n\n![image](/assets/img/2024-05-23-100DaysofSteamSalesAnalysis_6.png)\n\n\n<div class=\"content-ad\"></div>\n\n2023년 1월 1일을 선택한 이유는 데이터를 최근 것으로 유지하면서도 게임이 수익을 얻을 수 있는 충분한 시간을 주기 위해서예요.\n\n여기서 볼 수 있듯이 중간 수준의 게임은 한 해 후에도 월 평균 90달러 정도의 수익을 올리고 있어요.\n\n마지막으로, 상관관계와 인과관계를 다루고 있음을 강조하기 위해, 게임 이름의 첫 글자로 매출을 시각화한 것이 재미있을 것 같아서요.\n\n![그림](/assets/img/2024-05-23-100DaysofSteamSalesAnalysis_7.png)\n\n<div class=\"content-ad\"></div>\n\n당신이 게임 제목을 'y'로 시작하게 하면 'v'로 시작하는 것보다 수익이 15배 많아진다는 정말인가요?\n\n아마 그렇지 않을 거에요.\n\n데이터를 살펴보는 것이 중요하지만, 이렇게 많은 불확실성 속에서 세세한 부분에 대해 파고들어가는 것은 그다지 유용하지 않을 수 있어요.\n\n# 질적 데이터\n\n<div class=\"content-ad\"></div>\n\n저는 확실히 첫 번째로 스팀 세일을 분석하려는 사람은 아니에요. 이미 그에 관한 전체 웹사이트들이 있어요. 이 연구를 시작한 후에야 알게 된 사실이에요:\n\n하지만, 질적 연구에 참여하는 사람을 별로 보지 못해요. 즉, 개별 항목을 보다 자세히 살피는 것이죠. 제 데이터 세트에 게임 스크린샷을 추가한 이유 중 하나는 어떤 게임이 잘 되고 있는지 감을 잡을 수 있도록 도와주고자 했기 때문이에요.\n\n그래서 이제 3가지 예시를 질적으로 분석해보려고 해요:\n\n- 데이터를 기반으로 매우 성공적인 게임이지만, 사실 그렇지 않아야 했던 게임.\n- 대부분의 개발자에게 이룰 수 있는 것처럼 보이는 성공한 게임들.\n- 실패한 게임(또는 숨겨진 보석). 실패했지만, 더 나은 성과를 이루었을지도 모르는 게임들.\n\n<div class=\"content-ad\"></div>\n\n## 놀랍게 성공한\n\nPizza Tower ($20,033,360):\n\n![Pizza Tower](/assets/img/2024-05-23-100DaysofSteamSalesAnalysis_8.png)\n\nPizzas Tower는 GameMaker로 만든 '잘 못 그린' 예술이 특징인 2D 플랫포머 게임입니다. 이런 상황에도 불구하고 Pizza Tower는 풍자, 주제, 혁신을 적절히 조합하여 성공을 거두었습니다.\n\n<div class=\"content-ad\"></div>\n\n2D 플랫포머는 가장 경쟁력이 있고 매출 성적이 가장 낮은 장르 중 하나입니다. Pizza Tower는 모든 규칙을 깨고 어떤 꿈의 게임이든 가능함을 보여줍니다.\n\n4년 개발 주기로 2,000만 달러의 매출을 달성했어요.\n\n## 중간 성공적이고 가능성 있는 게임\n\nInto the Flames ($406,627)\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-05-23-100DaysofSteamSalesAnalysis_9.png\" />\n\nhttps://store.steampowered.com/app/1222300/Into_The_Flames/\n\nInto the Flames는 활발히 개발 중인 소방 시뮬레이션 게임으로, 한 명의 개발자가 개발하고 있을 수 있습니다. 그래픽은 최고는 아니지만, 어떤 흥미를 끌고 있는 특정 주제를 다루고 있습니다.\n\n제 꿈의 세팅($255,085)\n\n<div class=\"content-ad\"></div>\n\n~~<img src=\"/assets/img/2024-05-23-100DaysofSteamSalesAnalysis_10.png\" />~~\n\n[링크](https://store.steampowered.com/app/2200780/My_Dream_Setup/)\n\n내 꿈의 세팅은 간단하지만 매우 정교한 시뮬레이션 게임으로, 최고의 게이밍 룸을 만드는 데 초점을 맞추고 있습니다.\n\n이는 모든 게이머가 익숙한 주제를 다루고 있으며, $5의 가격표로 쉽게 구매할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\nBeton Brutal ($117,945)\n\n![Screenshot](/assets/img/2024-05-23-100DaysofSteamSalesAnalysis_11.png)\n\nAnother game from a solo developer. A single player parkour game with some beautiful, brutalist inspired architecture.\n\nFinding success with any of the above games would, at the very least, fund your solo development endeavors for years to come.\n\n<div class=\"content-ad\"></div>\n\n## 실패한 게임 (숨은 보물들)\n\n지금까지 카테고리 예시를 찾는 것은 쉬웠습니다. 왜냐하면 우리는 게임 중 상위 8%만 살펴보면 되기 때문이죠. 이제 우리는 그 꿈을 이루지 못한 2600개의 다른 타이틀로 깊게 파고들어봅니다.\n\n좋은 소식은 무언가 돋보이는 게임을 발견하려고 수천 개의 게임을 스크롤해야 했다는 것입니다. 즉, 대부분의 게임들이 열등한 위치에 있는게 타당하다는 것을 뜻하는 더 좋은 방법입니다.\n\nA Rum Tale ($63)\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-05-23-100DaysofSteamSalesAnalysis_12.png)\n\n[A Rum Tale](https://store.steampowered.com/app/2246310/A_Rum_Tale/)\n\n이 게임은 정말 잘 만들어진 플랫포머 게임입니다. 하지만 리뷰가 단 3개밖에 없네요.\n\n그래픽이 탁 트이고 체적 안개 기능까지 갖추고 있는데, 이 정도면 좀 더 많은 관심을 받았으면 하는데요. 소규모 팬덤도 없는 것이 놀랍네요.\n\n<div class=\"content-ad\"></div>\n\n그 정보를 찾기 어려울 수 있습니다. 이는 마케팅 실패를 보여줄 수 있습니다.\n\n플레임 키퍼 ($9,933)\n\n![이미지](/assets/img/2024-05-23-100DaysofSteamSalesAnalysis_13.png)\n\n[링크](https://store.steampowered.com/app/1374230/Flame_Keeper/)\n\n<div class=\"content-ad\"></div>\n\n귀엽고 테마가 매력적인 액션 로그 라이트 게임입니다. $9,000에 매력적인 요소를 보였지만, 개발자가 투자금을 회수했는지 의문스럽습니다.\n\n아마도 75%의 리뷰 평점 때문에 인기를 얻지 못한 것 같아요.\n\n킹에게 공격 ($198)\n\n![이미지](/assets/img/2024-05-23-100DaysofSteamSalesAnalysis_14.png)\n\n<div class=\"content-ad\"></div>\n\nhttps://store.steampowered.com/app/2108410/Attack_on_King_Reloaded/\n\n이 VR 게임은 RPG 전략 장르를 완전히 몰입형으로 조합한 흥미로운 작품입니다. 정교한 그래픽을 갖추고 있는 것으로 보입니다.\n\n그러나 독특한 스타일에도 불구하고 주목을 받지 못하고 있다고 하네요.\n\n# 결론\n\n<div class=\"content-ad\"></div>\n\n이 연구 결과를 기반으로, 이것은 나에게 그리고 다른 인디 개발자들에게 제안할 팁입니다.\n\n## 큰 그림을 그리라아니면 집에 귀환하라.\n\n게임을 작게 유지하는 것에 대한 모든 관습적인 조언에도 불구하고, 자신이 감당할 수 있는 것 이상의 일을 성공적으로 해낸 개발자들이 가장 높은 곳에 도달하는 것처럼 보입니다.\n\n왜냐하면 이 세계는 승자가 모두를 가져가는 것이기 때문입니다. '괜찮은' 게임을 만들었다고해서 어떤 칭찬도 받을 수 없는 것이죠.\n\n<div class=\"content-ad\"></div>\n\n게임이 복잡해야 한다는 뜻은 아니에요. 간단한 게임도 충분하죠. 그저 꼭 필요한 것만 잘 갖추어 주면 돼요. 예를 들어, 예술, 상점 페이지, 음악, 시각 효과, 게임 플레이, 플레이어 경험 등이 선택한 장르에 맞게 최고 수준이어야 해요.\n\n## 향수를 활용하세요\n\n개발자로서 우리는 창의성과 독창성을 자랑스러워해요. 여러분이 좋아하는 게임을 그대로 복사해서 만들라는 건 아니에요. 그런 게임들은 대체로 성공하지 않거든요. 하지만 사랑받는 시리즈에서 영감을 받으면 플레이어들과 감성적으로 연결될 수 있어요.\n\n만일 여러분의 게임 이미지가 플레이어들에게 좋은 추억을 떠올리게 하면서 동시에 새롭고 흥미로운 것을 제공한다면, 누르는 클릭을 유도하는 데 성공할 가능성이 높아요.\n\n<div class=\"content-ad\"></div>\n\n오늘날에도 '뱀파이어 생존자' 장르 중에서 새로운 게임들이 약간 다르고 조금 더 나은 점으로 성공을 거두고 있어요.\n\n새로운 장르를 창조하는 것은 판매를 한다고 느껴질 수도 있지만, 플레이어들에게 자신의 게임을 이해하고 그 시간과 돈을 투자하는 가치가 있다고 설득하는 것은 어렵다는 문제가 있어요.\n\n## 위대함은 부정할 수 없어요.\n\n매주 스팀에서는 매출이 100만 달러 이상이 될 4개의 게임이 출시되어요. 그것은 연간 200개 이상이에요.\n\n<div class=\"content-ad\"></div>\n\n200 명 중 한 명이 될 수 있다고 믿나요? 제가 그렇게 생각해요. 그게 아니었다면 이 글을 읽고 있지 않으셨을 거예요.\n\n위대한 게임은 부정할 수 없어요. 그것들은 피할 수 없어요. 그만큼 열려 있는 가능성이 크거든요.\n\n당신의 게임에서 '출시' 버튼을 누르면, 만약 그 날 다른 27명이 출시한 게임보다 나은 퀄리티라면, 당신은 성공했다고 볼 수 있어요.\n\n그렇지 않다면, 내일이 또 있을 거예요. 함께 힘내봐요!\n","ogImage":{"url":"/assets/img/2024-05-23-100DaysofSteamSalesAnalysis_0.png"},"coverImage":"/assets/img/2024-05-23-100DaysofSteamSalesAnalysis_0.png","tag":["Tech"],"readingTime":9},{"title":"프로듀서로부터 온 편지","description":"","date":"2024-05-23 13:35","slug":"2024-05-23-LetterfromtheProducer","content":"\n# 2024년 5월\n\n![이미지](/assets/img/2024-05-23-LetterfromtheProducer_0.png)\n\n안녕하세요,\n\nBitcraft Closed Alpha(1)가 4월 30일에 종료되었고, 참으로 멋진 여정이었습니다! 먼저, 참가해 주신 모든 테스터 여러분께 감사드립니다. 피드백을 공유해 주시고 버그를 신고해 주신 노력에 진심으로 감사드리며, 가장 중요한 것은 언제나 함께하는 커뮤니티 여러분이 조금 험난한 여정 속에서도 인내심과 이해를 보여 주신 점에 감사드립니다.\n\n<div class=\"content-ad\"></div>\n\n모든 것이 처음에는 잘 진행되었지만 며칠 지나고 나면 몇 가지 문제가 발생하기 시작했고, 특히 여러 플레이어들이 긴 시간 동안 동일한 세계를 공유할 때 그 문제들이 더욱 두드러지게 나타났습니다. 바로 이것이 테스트의 요점입니다 — 하지만 어쨌든, 서버를 두 달 이상 닫아놓은 것은 우리가 희망하지 않았던 일이었습니다. BitCraft를 다시 작동시키기 위해 힘들게 노력하는 동안 커뮤니티로부터 받은 지원에 다시 한 번 감사드립니다.\n\n![LetterfromtheProducer_1](/assets/img/2024-05-23-LetterfromtheProducer_1.png)\n\n아울러, 알파 테스트 중 BitCraft의 비디오를 제작하고 스트리밍한 모든 콘텐츠 크리에이터들에게도 인사를 전합니다. 우리는 프리-알파에서 클로즈드 알파로 전환된 게임의 NDA가 없을 위험이 있었고, 그것이 완성도 있는 게임 경험을 제공하지 않을 것이라는 것을 알고 있었습니다. 여러분 모두가 스트리밍하면서 실시간으로 기술적 문제를 다루는 동안 훌륭한 대우를 해 주고 이해해 주셨습니다.\n\n다행히도 몇 번의 야행 끝에 BitCraft를 다시 발표할 수 있는 상태로 만들었으며, 두 번째 테스트의 후반부는 비교적 원활하게 진행되었습니다.\n\n<div class=\"content-ad\"></div>\n\n![LetterfromtheProducer_2](/assets/img/2024-05-23-LetterfromtheProducer_2.png)\n\n테스트 서버를 종료한 다음 주, Clockwork Labs 팀은 회사 워크샵에 참석했어요! 이번이 많은 분들이 오랜 시간 동료들을 첫 만남했던 시간이었어요! 저희는 등산, 보트 여행, 탈출 게임, 캠프파이어 모임을 통해 에너지를 모았고 BitCraft, SpacetimeDB 및 Clockwork Labs 전체의 다음 단계를 논의하고 계획했어요.\n\n![LetterfromtheProducer_3](/assets/img/2024-05-23-LetterfromtheProducer_3.png)\n\n이제 저희는 돌아와서 다가올 도전에 대처할 준비가 되었어요. 하지만 먼저, BitCraft Closed Alpha one에서 배운 내용을 간단히 살펴볼게요.\n\n<div class=\"content-ad\"></div>\n\n\n![LetterfromtheProducer_4](/assets/img/2024-05-23-LetterfromtheProducer_4.png)\n\nRound-up — Closed Alpha 1\n\nLet’s start with a few numbers. 6452 players tested BitCraft for more than one hour. A total of 2211 claim totems have been built. We will make adjustments to the onboarding experience here, to make players feel less pressured to immediately settle down but maybe join a claim during their first steps in BitCraft. 128 claims had 5 or more members and 83 players had joined the largest settlement.\n\n![LetterfromtheProducer_5](/assets/img/2024-05-23-LetterfromtheProducer_5.png)\n\nWe were excited to see testers building larger villages and cooperating to quickly leave the Stone Age and reach higher-tier technology. Many players started specializing, and we are happy with the direction the cooperative gameplay went with coordination. The tester feedback will help us further improve, polish, and continuously develop the basic systems already in place like chat and claim management. Specifically, we will also address the hurdles some solo testers faced with their claim — nobody should have to worry about losing their progress during the first hours of playing BitCraft. But everything considered, we are happy with the results and believe that the town-scale gameplay is heading in the right direction.\n\n\n<div class=\"content-ad\"></div>\n\n기본 기계 및 구현을 더 자세히 살펴봐야 하는 요소는 플레이어 간 상품 거래입니다. 시험 결과, 정착지 간 번창하는 거래에 필요한 적절한 도구와 인센티브가 아직 부족하다는 것이 확인되었습니다. 게임 디자이너들은 많은 플레이어와 이야기를 나누어 상황을 완전히 이해하고 식별된 문제를 해결할 계획을 이미 가지고 있으며, 이는 비트크래프트의 상인 생활을 재미있고 보람찬 경험으로 만들어 낼 것입니다.\n\n또한 이동 시스템이 있습니다. 우리는 클릭해서 이동하는 시스템을 구현함으로써 최상의 장기적 게임 경험을 제공할 것으로 믿지만, 사실은 거의 모든 새로운 테스터가 적응하는 데 시간이 필요하다는 것이 분명해졌습니다. 우리는 WASD 이동을 요청하는 열정적인 초기 피드백을 받았지만, 익숙해지면 포인트투클릭이 더 나은 편리한 게임 경험을 제공한다는 것에 대해 숙련된 테스터들 간에 토론이 이루어졌습니다.\n더 나은 경험을 위해 나아가면서 첫날 잠재적 플레이어를 잃는 것은 분명히 우리의 의도가 아닙니다. WASD 이동이 구현된 이후 나중에 Alpha Test(닫힌 알파 2가 아님)를 실행할 계획입니다. 이 테스트에서의 데이터와 피드백은 우리가 올바른 방향으로 나아갈 수 있도록 도와줄 것입니다.\n\n이제 다음 단계 — 닫힌 알파 2\n우리의 현재 계획은 2024년 6월 16일에 다음 테스트를 시작하는 것입니다. 알파 2는 제국 시스템의 첫 번째 반복 테스트에 초점을 맞출 것입니다. 이는 데이터 및 피드백을 수집하기 위해 진행되는 짧은 시범 테스트로 예상됩니다.\n기간, 테스터 수 및 초대 절차 등 세부 정보는 아직 논의 중에 있습니다. 추후 공지를 통해 안내해드릴 예정입니다.\n다음 테스트에서 제국 시스템이 중점이 될 것이지만, 기존 콘텐츠를 계속해서 보강할 것입니다. 게임 밸런스 개선, 새로운 아트 자산 및 다양한 세부사항이 시간이 지남에 따라 추가될 것으로 기대할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n감사합니다! 더 많은 소식을 기대해주세요!\n\n감사합니다,\nAlessandro\n","ogImage":{"url":"/assets/img/2024-05-23-LetterfromtheProducer_0.png"},"coverImage":"/assets/img/2024-05-23-LetterfromtheProducer_0.png","tag":["Tech"],"readingTime":4},{"title":"프로모션에 대한 공학 매니저의 고백","description":"","date":"2024-05-23 13:33","slug":"2024-05-23-ConfessionofanEngineeringManageronPromotions","content":"\n\n![이미지](/assets/img/2024-05-23-ConfessionofanEngineeringManageronPromotions_0.png)\n\n많이 들어온 것 중에 한 가지 예제로 좋은 매니저의 핵심 지표는 누군가를 승진시키는 능력이라고 들거나 들어 봤습니다. 표면적으로는 충분히 합리적으로 들립니다. 결국, 매니저는 자신의 사람들을 승진시킬 수 없다면 무엇을 하는 걸까요?\n\n더 깊이 들어가보면, 이 명제는 오해를 불러일으킵니다.\n\n저는 듣긴 했고, 유감스럽게도 스스로도 이를 말해본 적이 있습니다. 엔지니어링 매니저로서 승진 판정 회의에 참여하면 마치 후보를 대신해서 타석에 들어가는 것이 야구에서 대타수 비슷하다는 말씀을 들어왔습니다. 후보는 스트라이크 피치이고, 매니저의 일은 대타로서 4구짜리 패스트볼을 홈런으로 쳐야 하는 것입니다.\n\n<div class=\"content-ad\"></div>\n\n특이사항이 잘못되었습니다.\n\n다른 변수 중 두 가지만 고려하세요: 상승 시장 대 하락 시장, 대기업 대 중소기업.\n\n## 시장 상황\n\n첫째, 좋은 시기에는 기업들이 유동성과 낮은 이자율로 자극을 받고, 경영진의 목표는 성장을 위해 모두 사용하게 됩니다. 이러한 환경에서 조직은 가로 및 세로로 확장해야 하므로, 빠르게 사람을 승진시키는 것은 필수적인 일과 신입사원을 유치하는 방법입니다.\n\n<div class=\"content-ad\"></div>\n\n어려운 시기에는 프로모션이 종종 지연되거나 훨씬 더 엄격한 검토를 받을 수 있습니다. 대형 테크 기업은 일반적으로 해고(유감없는)와 이직(유감 있는)으로 구성된 최소 15%의 교체 대상을 갖고 있습니다. 시장이 활발할 때, 자발적인 이직은 일반적으로 적어도 10%는 발생하기 때문에 해고를 최소화하려고 합니다. 그러나 시장이 침체할 때, 이직은 감소하고 기업은 해고를 증가시키고 인력을 오래 유지하려고 합니다.\n\n## 자본 지출\n\n둘째로, 인재에 지출할 자본이 적은 중소기업이나 기업은 종종 직함 팽창이나 빠른 승진 경로에 의존하곤 합니다. 제 경험상으로, 기업들이 비문으로 제정하지 않은 인상과 가장 많은 이직을 두려워하는 사람에 대한 역순 스택 랭킹만을 기반으로 승진시키는 경우를 보았습니다. 그들은 성과를 보상으로 승진시킨다고 말할 수 있습니다.\n\n그에 비해 대기업들 및 특히 대규모 기술 기업들은 종종 그 반대로 행동합니다. 그들은 모든 분야에서 다음 단계에 존재함이 입증될 때까지 직원들을 현재 수준에 유지시키곤 합니다. 냉소적으로 바라보면, 누군가가 확실하게 다음 수준에 준비되어 있지 않으면 승진이 불가능하다는 뜻입니다. 또한, 그러한 기업에서는 고문련 엔지니어 포지션이 일반적으로 경력의 맥이며, 그 이후의 다음 수준으로 진출하는 탈출 속도가 다른 곳보다 훨씬 높습니다.\n\n<div class=\"content-ad\"></div>\n\n가장 나쁜 경우 — 뜨거운 시장에서 소규모 회사, 승진은 대부분 담당자가 자신의 직원을 구두로 잘 홍보하는 능력에 달려 있습니다. 지정타자의 비유가 꼭 어울립니다. 결과는 종종 잘못 계산되고 불공평할 수 있습니다. 자신의 매니저가 황금처럼 말 잘하는 사람은 다른 사람의 비용으로 승진할 수 있습니다.\n\n승진은 데이터 비교의 표준화되고 투명한 프로세스여야 하며 충분한 명확성이 있어야 합니다. 매니저의 역할은 데이터를 신중하게 기록하고 쇼케이스하며, 직원의 공헌과 영향을 양적 및 질적으로 깊게 이해해야 합니다. 아래는 예시 목록입니다:\n\n양적 데이터 샘플\n\n- 코딩: diff\\* 개수, diff 당 평균 수정 횟수, 코드 리뷰 횟수\n- 문서화: 설계 문서 (RFC\\*\\*) 개수\n\n<div class=\"content-ad\"></div>\n\n- diff는 주 코드베이스에 병합된 코드 변경의 단위이며, 병합 요청 등으로도 알려져 있어요.\n\n\\*\\* RFC(의견 요청); 디자인 및 리뷰를 위한 표준화된 문서\n\n질적 데이터 샘플\n\n- 코딩: 디자인 패턴, 코드 커버리지\n- 디자인: 디자인의 견고성, 코멘트 대응\n- 운영: 인시던트 관리, 당직 교대체제\n\n<div class=\"content-ad\"></div>\n\n아래는 제기된 비정상적인 상황을 제외하고 승진을 안정적으로 이룰 수 있는 세 가지 중요 권고 사항입니다:\n\n```js\n1. 현재 수준에서 뛰어나게 성과를 올린 후, \"위로 치“\n2. 미래 승진 추천자들과 협력\n3. 경쟁 상황 파악하기\n```\n\n## 현재 수준에서 뛰어나게 성과를 올린 후, “위로 치“\n\n어떤 사람들은 현재 수준에서 뛰어난 성과를 낸 후에야 그보다 한 단계 높은 수준의 성과를 얻으려는 실수를 범할 때가 있습니다. 예를 들어, 중급 직원에게 요구되는 평가 지표는 일반적으로 우수한 코딩 생산성입니다(시니어 직원보다 더 높은 수준). 코드 작성 능력이 탁월하고 빠른 속도로 작업을 완료하는 능력을 보여주지 않은 채 프로젝트를 주도하려는 것은 실수일 수 있습니다. 결국, 제한된 시간 내에 두 가지 모두 최적화하는 것은 매우 어려울 수 있습니다. 여기에서 매니저의 역할은 직원들의 승진 경로를 저해하지 않도록 올바르게 배치하는 일입니다.\n\n<div class=\"content-ad\"></div>\n\n## 미래 프로모션 엔도서와 협업하기\n\n프로모션을 위해 팀 외부 엔도서가 필요하기 때문에 안정적으로 지지를 받으려면 상호 기능적 프로젝트에서 기회를 찾아 수준 +2/3/4 직원과 협업해야 합니다. 인정받을만한 일을 해내고 그에 대해 인정받는 것이 유일한 방법입니다. 간단히 말해서, 외부 시니어 직원들과의 상호 기능적 프로젝트에서 협업하지 않으면 승진하기가 거의 불가능합니다.\n\n이 과정은 밀어서와 끌어서 둘 다 필요합니다: 매니저는 \"승진 가능한\" 직원을 눈에 띄는 프로젝트에 배치해야 하며 직원들도 이와 같은 프로젝트를 적극적으로 요청해야 합니다.\n\n\\*현재 수준이 중급이라면 L+2는 스태프 엔지니어, L+3은 시니어 스태프 엔지니어가 됩니다.\n\n<div class=\"content-ad\"></div>\n\n## 경쟁사 파악하기\n\n누구의 말도 믿지 마세요. 매 프로모션 주기마다, 홍보를 위한 예산과 업무 성과 향상 계획(PIP)이 할당됩니다. 즉, 경영진은 직원들을 순위에 따라 정렬하고 최상위 및 최하위 업무 성과자를 식별합니다. 일반적으로 상위 15%와 하위 15%로 나누어집니다.\n\n매니저와 성장 가능성이 있는 직원은 경영진의 최고 성과자가 누구인지 충분히 조사하고 주기적으로 그들의 양적 및 질적 지표를 모니터링해야 합니다. 기준이 어디에 있는지 주의 깊게 살펴보고 동일한 리그에 속하기 위해 노력해야 합니다. 매니저가 이를 미리 발견했고 직원이 차이를 알고 있다면, 프로모션 케이스가 이루어지지 않는다면 놀라울 일이 없을 것입니다.\n\n지표는 업무 성과의 대리품이지만 그 자체로는 아니기 때문에 조작될 수 있습니다. 매니저로서, 자신의 직원을 홍보하고 다른 직원을 방해하는 것이 아닌, 종종 칭찬받는 좋은 매니저의 질로 자신의 직원에 대해 종합적이고 진실한 데이터를 제시하는 것이 더 유익합니다. 또한 다른 매니저들이 정직하게 유지할 수 있도록 하는 것이 좋습니다.\n\n<div class=\"content-ad\"></div>\n\n후보의 코딩 생산성이 비정상적으로 높은가요? 구성 변경이 이에 포함되나요? 설계 문서의 저자로 명시된 후보가 실제 참여한 내용이 다른 공동 저자보다 적은가요? 관리자는 플랫폼 팀 대비 제품 팀의 코딩 생산성을 구분하나요? 현재 수준에서 뛰어나지 않은 상태에서 \"짧은 장면\"을 보이나요?\n\n마지막 고백: 대부분의 경우 지금 시대의 대형 기술 기업에서 수석급으로 승진하려면 어려운 과제이며, 대개 대형 기술 기업 외부의 레벨 +1에서 새로운 직장을 구하는 것보다 더 어려울 수 있다고 말하자면, 참여가 쉽지 않습니다. 내 관찰에 따르면, 가장 견고한 5시간 인터뷰 루프 조차도 흔히 판정위원회보다 더 부담을 받으며 여러 가지 눈가림이 존재합니다. 희망하는 후보에게는 단순히 새로운 직장을 찾는 것이 유리할 수 있습니다(충분한 시도만 하면).\n","ogImage":{"url":"/assets/img/2024-05-23-ConfessionofanEngineeringManageronPromotions_0.png"},"coverImage":"/assets/img/2024-05-23-ConfessionofanEngineeringManageronPromotions_0.png","tag":["Tech"],"readingTime":4},{"title":"꿈같은 원격 인턴십을 얻은 방법","description":"","date":"2024-05-23 13:32","slug":"2024-05-23-HowILandedaDreamRemoteInternship","content":"\n\n여러 인턴십과 소프트웨어 개발 분야의 다양한 경험을 쌓은 뒤, 원격 인턴십을 위한 엄격한 채용 프로세스를 거친 내 최근 여정을 기쁘게 공유하려고 합니다. 이 모든 과정이 어떻게 진행되었는지 살펴보겠습니다.\n\n# 제 소개\n\n# 경험\n\n- SDE 인턴, NewGen Software\n- 풀스택 개발자 @Infiniti Solutions\n- 프론트엔드 엔지니어 @Spotline, USA (원격 근무)\n- UI/UX 디자이너, Fiverr\n\n<div class=\"content-ad\"></div>\n\n# 기술 스택\n\n- 언어: C++, JavaScript, Java\n- 백엔드 개발: Express.js, Node.js, Backend TypeScript\n- 프론트엔드 개발: HTML, CSS, React.js, TypeScript, Next.js, Tailwind\n- 데이터베이스: Firebase, MySQL, MongoDB, Prisma, Postgres\n- 버전 관리: Git, GitHub, Docker\n\n# 기회의 출처\n\n나는 직접 연락을 받아온 맴버로부터 Twitter DM을 통해 이 기회를 발견했어.\n\n<div class=\"content-ad\"></div>\n\n# 면접 프로세스\n\n## 1차 심층 면접\n\n첫 번째 라운드는 역할과 관련 기술 스택에 대해 논의하는 간단한 30 ~ 40분간의 심층 면접이었습니다. 이 역할은 Next.js, TypeScript 및 Postgres와 AWS에 중점을 둔 풀-스택 SWE 인턴십을 위한 것이었습니다. 저는 이전 경험 및 인턴십을 자세히 설명하며 특히 Next.js 프로젝트에서의 업무를 강조했습니다.\n\n## 코딩 라운드 1\n\n<div class=\"content-ad\"></div>\n\n다음 단계는 빠른 속도의 라이브 코딩 라운드였어요. 프론트엔드에 전자 메일 콘텐츠와 여러 이메일 주소를 입력할 수 있는 두 개의 입력 상자를 만드는 것이 제 몫이었어요. 시스템은 이메일 목록을 표시하고 이메일을 삭제하고 메일링 익스텐션을 통합해야 했어요. 저는 더미 이메일을 보내기 위해 Node-mailer와 Mailtrap을 선택했어요. 압박 속에서도 이러한 기능들을 성공적으로 구현했어요.\n\n![이미지](/assets/img/2024-05-23-HowILandedaDreamRemoteInternship_0.png)\n\n# 코딩 라운드 2/시스템 디자인\n\n이 라운드는 시스템 디자인과 코딩을 결합하여 거의 2시간 동안 진행되었어요. 저에게는 Excalidraw를 사용하여 레스토랑을 위한 팁 시스템을 디자인하라는 임무가 주어졌어요. 이 작업에는 화면 계획, 업로드 서비스 또는 AWS를 사용한 이미지 저장, 그리고 빠른 로딩 시간을 보장하는 것이 포함되었어요. 시스템 디자인을 완료한 후에는 빠르게 이 시스템의 초기 프론트엔드 화면을 코딩했어요.\n\n<div class=\"content-ad\"></div>\n\n또한, 이전 라운드에서 소개했던 메일링 시스템을 새롭게 업데이트하여 Prisma DB 통합을 추가하여 사용자를 추가하고 삭제하는 기능과 이메일에 구독 해지 버튼이 추가되었습니다. 이 시연은 내 작업 능력을 강력하게 증명하는 계기가 되었습니다.\n\n# 문화적 적합성\n\n최종 라운드는 인사팀 및 팀 문화 적합성 인터뷰로, 내 사고 방식과 팀에 얼마나 잘 적응할 수 있는지에 중점을 두었습니다.\n\n# 결과\n\n<div class=\"content-ad\"></div>\n\n일주일 후에, 인턴십에 선발되었다는 이메일을 받게 되었어요! 이 경험 전체가 믿을 수 없을 정도로 보람찼고, 이 새로운 여정을 시작할 수 있어 너무 흥분되고 있어요.\n\n![이미지](/assets/img/2024-05-23-HowILandedaDreamRemoteInternship_1.png)\n\n# 회고와 조언\n\n과거의 기술 능력, 준비, 그리고 강력한 이전 작업의 시연이 성공에 중요한 역할을 했던 것으로 돌아봤을 때, 비슷한 기회에 대비하는 분들에게 다음을 추천해요:\n\n<div class=\"content-ad\"></div>\n\n- 기술 스킬: 자신의 기술 스킬을 끊임없이 향상시키세요. 특히 해당 역할과 관련된 기술에 집중해보세요.\n- 준비: 정기적으로 코딩 및 시스템 설계 문제를 연습해보세요.\n- 프레젠테이션: 이전 작업물을 선보일 준비를 하고, 여러분의 사고 과정을 명확하게 설명할 수 있도록 준비하세요.\n- 문화적합성: 회사의 문화를 이해하고, 면접 중에 어떻게 그것과 일치하는지를 보여주세요.\n\n입사 시즌은 스트레스를 유발할 수 있지만, 끈기와 지속적인 개선이 중요합니다. 때로는 기회가 예상치 못한 때에 찾아올 수 있고, 모든 경험은 여러분의 여정에 가치를 더할 것입니다. 앞으로 나아가며, 성공은 따를 것입니다.\n\n이 상세한 설명이 비슷한 채용 과정을 거치는 분들에게 유용한 통찰을 제공했으면 좋겠습니다. 궁금한 점이 있거나 추가적인 조언이 필요하시면 얼마든지 연락해주세요. 여러분의 여정에 행운을 빕니다!","ogImage":{"url":"/assets/img/2024-05-23-HowILandedaDreamRemoteInternship_0.png"},"coverImage":"/assets/img/2024-05-23-HowILandedaDreamRemoteInternship_0.png","tag":["Tech"],"readingTime":3},{"title":"50가지 코딩 법칙이 적절한 프로그래머가 되도록 만들어줄 거예요","description":"","date":"2024-05-23 13:27","slug":"2024-05-23-50CodingLawsThatWouldMakeYouADecentProgrammer","content":"\n## 이 법칙을 따르지 않으면 해고당할 수 있습니다.\n\n![이미지](/assets/img/2024-05-23-50CodingLawsThatWouldMakeYouADecentProgrammer_0.png)\n\n수백 또는 아마 수천 가지의 파이썬 최고의 관행들이 있습니다. 누구에게 물어도 다소 다른 실천 방법을 얻을 수 있습니다.\n\n인터넷은 모든 사람에게 의견 표명의 권리를 부여했습니다. 심지어 저도 말이죠. 하지만 이 기사에서는 암호화된 50가지 파이썬 최고의 관행을 살펴보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n신이라도 조작할 수 없는 기술들이 있어요. 이러한 기술들은 전문가와 아마추어를 구분하며 다양한 프로그래밍 언어에도 적용할 수 있어요.\n\n대부분의 파이썬 개발자들은 코드를 빠르게 테스트하거나 오류를 디버그할 곳이 필요해요. 제가 만든 python-fiddle.com 이라는 웹사이트를 이용하면 코드를 빠르게 테스트하고 AI/LLMs를 사용하여 가능한 오류의 해결책을 찾아줄 수 있어요.\n\n만약 웹 스크래퍼를 만들거나 데이터를 분석하거나 암호화폐 관련 프로젝트를 개발하거나 기계 학습 모델을 만들거나 Django 또는 Flask 웹사이트를 만들거나 작업을 자동화하거나 SQL 관련 프로젝트 등이 필요하다면, 이 사람에게 메시지를 보내보세요.\n\n## 법칙 1: 가능한 한 주석을 피하세요.\n\n<div class=\"content-ad\"></div>\n\n코멘트는 종종 사실과는 다른 내용을 전달할 수 있는 방식을 갖고 있어요. 코드가 실제로 무엇을 하는지가 아닌 다른 사람이 말하는대로 어떤 일을 하고 있는지를 읽는 사람의 마음을 벗어낼 수 있어요.\n\n시간이 흐르고 코드가 업데이트되거나 변경될 때 이 문제가 매우 심각해질 수 있어요. 어느 순간, 코멘트가 거짓이 되고 이제 모든 사람들은 거짓을 통해 진실을 관찰해야 할 수도 있어요.\n\n모든 비용을 피해야 하는 것이 코멘트에 대한 태도예요. 코멘트는 독자가 당신의 과거적인 생각을 상속받도록 강요해요. 함수나 클래스가 변경되면 대부분 코멘트는 함께 변경되지 않을 가능성이 높아요. 대부분, 코멘트는 독자가 앞으로 생각하도록 막을 수 있어요.\n\n코멘트는 작성자가 명확한 클래스, 함수 또는 변수 이름을 제시하지 못했다는 것을 나타냅니다. 이는 프로그래머의 태도의 부족을 드러내고 팀에 그러한 태도를 상속받도록 강요해요.\n\n<div class=\"content-ad\"></div>\n\n주석을 가능한 한 피해야 합니다.\n\n로우 14와 15에서는 언제 주석을 사용해야 하고 언제 사용하면 안 되는지 알 수 있습니다.\n\n## 로우 2: 변수에 타입 속성을 이름으로 사용하지 마세요\n\n가끔 특정 변수가 문자열인지 정수형인지를 명시하고 싶을 때가 있습니다. 따라서 일부 개발자는 변수를 다음과 같이 지정할 수 있습니다: name_of_variable_str 또는 name_of_variable_int.\n\n<div class=\"content-ad\"></div>\n\n변수가 문자열인 것이 직관적으로 이해되는 경우와 같이, 변수가 결코 int(정수) 타입이 될 수 없는 경우에는 이것이 상당히 중복될 수 있습니다.\n\n그러나 변수 타입이 직관적이지 않은 경우에는 변수명을 지정할 때 타입을 명시하는 대신 타입 어노테이션을 사용하는 것이 가장 좋은 방법입니다.\n\nname_of_variable:str = value 대신 name_of_variable_str = value를 사용하는 대신 이 방법을 사용하면 모두가 변수가 문자열인 것을 알 수 있으며 코드를 깔끔하고 간결하게 유지할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 법률 3: 클래스 이름은 명사여야 합니다.\n\n클래스 이름을 명사로 유지하는 것이 항상 최선의 실천 방법입니다.\n\n이는 대부분 클래스 객체가 특징과 동작을 식별하거나 표현하는 데 사용되기 때문입니다. 어떻게 양이 어떤 특징(뿔)과 행동(주변 사람에게 고개를 끄덕이다)을 나타내듯이요.\n\n이는 코드를 매우 가독성 있고 중복되지 않게 만듭니다. 예를 들어, Goat.get_horn_length() 대신 GetGoat.get_horn_length()을 사용하는 대신 Goat.get_horn_length()을 사용합니다.\n\n<div class=\"content-ad\"></div>\n\n## 법칙 4: 함수 이름은 동사여야 합니다\n\n함수는 인접한 개발자가 수행하는 작업을 명확하게 이해할 수 있도록 동사로 가장 잘 명명되어야 합니다.\n\n이는 주석이 필요 없어지게 하고 어떤 개발자든 원시 코드를 확인하지 않고도 정신적으로 개념화할 수 있도록 해줍니다.\n\n## 법칙 5: 함수는 매개변수와 반환 형식을 명시해야 합니다\n\n<div class=\"content-ad\"></div>\n\n함수를 정의할 때는 항상 인수의 유형 및 함수의 결과가 반환하는 데이터 유형을 명시해야 합니다.\n\n이렇게 하면 당신과 팀의 개발자들 모두 print 문을 계속 사용하지 않고도 예상되는 결과를 알 수 있게 됩니다.\n\n![이미지1](/assets/img/2024-05-23-50CodingLawsThatWouldMakeYouADecentProgrammer_1.png)\n\n![이미지2](/assets/img/2024-05-23-50CodingLawsThatWouldMakeYouADecentProgrammer_2.png)\n\n<div class=\"content-ad\"></div>\n\n## 법칙 6: 함수는 한 가지 기능만 수행해야 합니다\n\n주니어 개발자들은 종종 이 규칙을 어기기 좋아합니다. 함수가 한 가지 기능만을 수행하는 것은 버그가 어디에 있는지 노출시키고 재사용성을 높이며, 함수 이름이 하는 일을 정확히 수행하도록 해줍니다.\n\n다음과 같은 일을 하고 싶지 않을 것입니다...\n\n![Img](/assets/img/2024-05-23-50CodingLawsThatWouldMakeYouADecentProgrammer_3.png)\n\n<div class=\"content-ad\"></div>\n\n주소가 유효한지 확인하고 확인 후 위도와 경도를 반환합니다. 이 함수는 두 가지 작업을 수행합니다. 주소가 유효한지 확인하고 해당 주소의 지리적 위치를 반환합니다.\n\n다음은 더 나은 방법입니다.\n\n![Better Way](/assets/img/2024-05-23-50CodingLawsThatWouldMakeYouADecentProgrammer_4.png)\n\n위의 함수들은 하나의 일만을 하고 그 이상의 일을 하지 않습니다. 덜 간결해 보일 수 있지만 훨씬 간결하고 가독성이 높습니다.\n\n<div class=\"content-ad\"></div>\n\n함수의 \"하나\" 기능을 정확히 알아내는 것은 새로운 개발자들에게는 약간 어려울 수 있어요. 함수가 무엇을 수행해야 하는지를 매우 구체적으로 명시해야 해요.\n\n보통은 함수 내에서 일부 작업을 추출하거나 그룹화하여 다른 하나의 함수로 만들 수 있다면, 아마도 함수가 한 가지 이상의 일을 수행하고 있는 것일지도 모르겠어요.\n\n또 다른 방법은 함수가 여러 수준의 추상화를 갖는지 여부를 확인하는 것이에요...\n\n## LAW 7: 함수는 동일한 추상화 수준에 있어야 해요\n\n<div class=\"content-ad\"></div>\n\n함수가 동일한 추상화 수준에 있을 때 언급하는 것은 함수가 단일하고 명확한 작업을 수행해야 한다는 아이디어를 가리킵니다. 해당 작업은 함수 전체에서 일관된 추상화 수준에 있어야 합니다.\n\n다시 말해, 함수는 특정한 세부 사항이나 복잡성에 집중해야 하며, 모든 함수의 작업은 동일한 수준에서 작동해야 합니다.\n\n![image](/assets/img/2024-05-23-50CodingLawsThatWouldMakeYouADecentProgrammer_5.png)\n\n이 함수는 낮은 추상화 수준의 명령문을 가지고 있습니다. sum, len 등과 같은 것들이 포함되어 있습니다.\n\n<div class=\"content-ad\"></div>\n\n\n<img src=\"/assets/img/2024-05-23-50CodingLawsThatWouldMakeYouADecentProgrammer_6.png\" />\n\n예를 들어, 이 함수에는 여러 수준의 추상화가 있습니다. get_numbers()는 높은 수준의 추상화, 리스트 내포(list comprehension)는 중간 수준의 추상화이며 sum은 낮은 수준의 추상화입니다.\n\n## 제8의 법칙: 함수와 인수는 형제 자매처럼\n\n함수 이름은 매우 밀접하게 그 인수와 관련되어야 합니다. 함수 이름과 관련성이 없는 인수를 전달하는 것은 좋은 방법이 아닙니다.\n\n\n<div class=\"content-ad\"></div>\n\n아래와 같이 코드를 Markdown 형식으로 변경해보세요.\n\n\nwrite(True)\n\nwrite(name)\n\n두 번째 예시가 함수가 정확히 무엇을 하는지 더 잘 설명하고 있어요. 이것을 읽는 사람에게 이름을 작성하고 있다는 사실이 명확해요.\n\n첫 번째 예시는 두 번째 예시만큼 명시적이지 않아요. 추측을 하거나 함수 전체를 살펴봐야 할 수도 있어요.\n\n\n<div class=\"content-ad\"></div>\n\n## 법칙 9: 함수는 작아야 합니다\n\n함수는 재사용 가능하도록 설계되었습니다. 그리고 함수가 커질수록 재사용 가능성이 낮아집니다. 이는 함수가 한 가지 일만 해야 하는 이유와 관련이 있습니다. 한 가지 일만 하면 함수가 작을 가능성이 높습니다.\n\n## 법칙 10: 불필요한 단어 및 중복 단어 피하기\n\n개발자가 변수나 함수의 의미를 더 명확하게 해주는 단어가 아닌 단어를 사용하는 시간도 있습니다. 이런 목록화:\n\n<div class=\"content-ad\"></div>\n\n![Image](/assets/img/2024-05-23-50CodingLawsThatWouldMakeYouADecentProgrammer_7.png)\n\n함수의 구현에 대한 사전 지식이 없으면 이를 본 개발자는 어떤 함수를 사용해야 하는지 알 수 없습니다.\n\n## LAW 11: 더러운 프로그래머가 되지 말라\n\n시니어 개발자라면 그가 코드가 깨끗할 때에만 정신적으로 맑다고 말할 것입니다. 이것은 더러운 코드를 작성하는 것이 더러운 프로그래머를 만들기 때문입니다. 깨끗한 코드는 팀의 모든 이들에게 깨끗한 코드를 계속 작성하도록 장려합니다. 항상 깨끗한 코드를 작성하도록 노력해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n하지만 깨끗한 코드란 무엇일까요? 깨끗한 코드는 잘 구조화되어 정리되어 있습니다.\n\n깨끗한 코드는 버그를 숨기지 않습니다. 프로그래머가 버그가 숨을 수 있는 어떤 곳이든 드러내며, 완전한 리팩토링 없이 쉽게 수정할 수 있는 공간을 마련해줍니다.\n\n## LAW 12: 개방폐쇄 원칙\n\n개방폐쇄 원칙(Open Closed Principles, OCP)은 클래스, 메서드 또는 함수가 확장을 위해 열려 있지만 수정에는 닫혀 있어야 한다고 말합니다. 이는 정의된 모든 클래스, 메서드 또는 함수가 코드를 변경하지 않고 여러 인스턴스에 재사용하거나 확장할 수 있도록 만든다는 것을 의미합니다.\n\n<div class=\"content-ad\"></div>\n\n위 예제를 들어보겠습니다. address라는 클래스가 있다고 가정해 봅시다.\n\n\n![address class](/assets/img/2024-05-23-50CodingLawsThatWouldMakeYouADecentProgrammer_8.png)\n\n\n이것은 OCP를 준수하지 못한 것입니다. 새로운 국가가 추가될 때마다, 해당 국가를 보충하기 위해 새로운 if 문을 작성해야 합니다. 지금은 간단해 보일 수 있지만, 상상해 보세요. 100개 이상의 국가를 고려해야 한다면 어떻게 될까요?\n\n여기서 OCP가 중요한 역할을 합니다.\n\n<div class=\"content-ad\"></div>\n\n\n![image](/assets/img/2024-05-23-50CodingLawsThatWouldMakeYouADecentProgrammer_9.png)\n\n이제 클래스나 함수를 수정할 필요가 없어서 보다 견고한 해결책입니다. 어떤 나라와 그 나라의 수도를考え하고 싶을 때 capital 사전만 조정하면 됩니다.\n\n또 다른 흔한 예는 클래스 상속을 사용하는 것입니다.\n\n예를들어:\n\n\n<div class=\"content-ad\"></div>\n\n아래는 다른 지불 방법을 추가할 때마다 항상 PaymentProcessor 클래스를 수정해야한다는 것이 잘못된 방법입니다.\n\n더 나은 방법은 다음과 같습니다:\n\n\n![이미지](/assets/img/2024-05-23-50CodingLawsThatWouldMakeYouADecentProgrammer_11.png)\n\n\n<div class=\"content-ad\"></div>\n\n이렇게 하면 새로운 결제 옵션을 추가해야 할 때마다, 예를 들어 암호화폐나 페이팔 같은 것, 이를 달성하기 위해 어떤 클래스도 수정할 필요가 없습니다. 단순히 다음과 같이 하면 됩니다:\n\n<img src=\"/assets/img/2024-05-23-50CodingLawsThatWouldMakeYouADecentProgrammer_12.png\" />\n\n## 법칙 13: 리스코프 치환 원칙\n\n이 전 원칙을 살펴보면, 암호화폐를 사용하여 결제할 때 우리는 정확히 어떤 암호화폐를 보내는지 명시적으로 지정하지 않습니다. 금액만 명시합니다. 그래서 만약 우리가 암호화폐를 명시하고 싶어한다면, 일반적으로 다음과 같이 할 것입니다:\n\n<div class=\"content-ad\"></div>\n\n```python\nfrom abc import abstractmethod\n\nclass PaymentProcessor:\n\n   @abstractmethod\n   def pay_tax(amount, crypto):\n      pass\n```\n\n그런 다음 각 결제 프로세서를 호출할 때 crypto 인수를 None 타입으로 선언하거나 필요하지 않은 경우 인수를 전달하지 않도록 기본값을 지정합니다. 이 두 경우 모두 Liskov Substitution Principle을 준수하지 못합니다.\n\n이는 부모 클래스 또는 추상 클래스가 대부분의 하위 클래스에게 관련이 없는 인수를 포함하고 있기 때문입니다.\n\n리스코프 치환 원칙(LSP)은 \"슈퍼클래스의 객체는 하위 클래스의 객체로 교체해도 프로그램의 정확성에 영향을 미치지 않아야 한다\"는 것을 명시합니다.\n\n<div class=\"content-ad\"></div>\n\nLSP를 준수하기 위해 CryptoPaymentProcessor 클래스 내에서 암호화폐를 정의해야합니다. 이렇게 하면 다른 하위 클래스와의 불필요한 충돌을 방지할 수 있습니다.\n\n```js\nclass CryptoPaymentProcessor(PaymentProcessor):\n   def __init__(self, crypto):\n      self.crypto = crypto\n\n   def pay_tax(amount):\n      print(f'당신의 {self.crypto} 지갑으로 세금 지불이 진행됩니다')\n      print(f'{amount}을(를) 청구할 예정입니다.')\n```\n\n## LAW 14: 언제 코멘트를 사용해야 할지 알기\n\n코멘트를 사용해야 할 때마다 코드로 표현하지 못한 것에 대해 부끄러워해야 합니다. 그러나 댓글을 사용하면 실제로 코드 자체보다 코드의 기본 작업을 잘 설명하는 데 도움이 되는 경우도 있습니다. 여기 \"좋음\" 코멘트의 5가지 좋은 예제가 있습니다.\n\n<div class=\"content-ad\"></div>\n\n친절한 메모\n코드를 읽는 사람에게 코드를 더 잘 전달하는 데 도움이 되는 정보가 있는 메모를 작성하는 것은 언제나 좋습니다. 예를 들어 함수의 반환 값을 강조하는 메모는 더 많은 명확성을 제공할 수 있습니다. 그러나 이러한 메모는 명확한 함수 또는 변수 이름을 사용하여 불필요하게 만들 수 있습니다.\n\n할 일 메모\n이러한 메모는 다른 프로그래머들이 이 함수/작업이 아직 미완성이거나 수정이 필요하다는 것을 알 수 있도록 도와줍니다. 특정 함수를 구현하는 더 나은 방법이 있을 수도 있습니다. 때로는 코드가 주기적으로 실패할 수 있습니다.\n\n당신의 이유에 상관없이, 이러한 메모는 가져가는 것보다 더 많은 가치를 제공합니다. 할 일 메모는 일반적으로 과업이 완료되었거나 제대로 수정된 후에 제거되어야 한다는 것을 기억하기 때문에 코드가 변경되거나 개선될 때 거의 손대지 않는 경향이 있습니다.\n\n후행 작용 경고\n가끔은 다른 개발자들에게 잠재적인 위험을 알리고 싶을 때가 있습니다. 이 위험에 발을 딛게 되면 예기치 못한 결과가 생길 수 있습니다. 우리는 모두 하루를 생존하고 싶어합니다. 이 상황에서 메모가 문제를 해결하는 데 도움이 될 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n특정 코드가 시간이 걸리거나 특정 시스템을 과부하시킬 가능성이 있는 경우, 독자나 다른 프로그래머에게 \"#COMPUTING RESOURCES를 많이 소비함\"과 같은 경고가 도움이 될 수 있습니다.\n\n## 법칙 15: 언제 주석이 나쁜가요?\n\n소음 주석\n이러한 주석들은 당연한 것을 다시 강조하는 주석입니다. 추가 정보를 제공하지 않고 코드의 더 많은 길이만 늘립니다. 많은 시간, 우리는 이러한 주석을 건너뛰곤 합니다. 소음 주석의 예시는 다음과 같습니다:\n\n```js\n# 동물 리스트에 추가합니다\nanimal.append(dog)\n```\n\n<div class=\"content-ad\"></div>\n\n비 로컬 정보\n프로그래머들이 주석을 사용할 때 범하는 실수 중 하나는 전역 정보를 로컬에서 제공하는 것입니다. 주석을 작성할 때는 해당 함수나 문을 참조하는 것에만 관련되도록 유지하십시오. 그 외의 부분은 제거해야 합니다.\n\n명확하지 않은 주석\n우리가 알기에는 분명한 주석을 작성하기 쉽습니다만 다른 사람에게는 명확하지 않을 수 있습니다. 주석과 함수 간의 연결은 명확해야 합니다. 둘 다 동일한 단계나 절차를 따라야 합니다. 주석이 또 다른 주석을 필요로 하지 않도록 해야 합니다.\n\n짧은 함수\n짧은 함수에 대해 주석이 필요하지 않을 가능성이 높습니다. 함수가 짧을수록 좋은 이름으로 설명할 수 있는 가능성이 높습니다. 따라서 이러한 함수는 보통 자기 설명적입니다.\n\n## 법칙 16: 소스 파일을 짧게 유지하기\n\n<div class=\"content-ad\"></div>\n\n소스 파일은 최대 500줄이지만 100–200줄 사이로 유지하는 것이 좋습니다. 매우 좋은 이유가 없는 한 다른 방법을 선택하는 것을 권장하지 않습니다. 소스 파일을 짧게 유지하면 재사용성과 가독성과 같은 다양한 명백한 이점이 있습니다. 또한 연결할 내용을 찾느라 스크롤하고 시간을 낭비하는 일이 줄어들기 때문에 유지 및 업데이트하기가 더 쉽습니다.\n\n## 법칙 17: 빈 줄 사용 시점을 알아두세요\n\n빈 줄은 새로운 개념과 분리된 부분으로 진행하고 있다는 것을 독자에게 알려주는 방법입니다. 각 줄 그룹은 완전한 생각을 나타냅니다. 이는 독자가 생각이 끝났는지를 이해하는 데 도움이 됩니다.\n\n## 법칙 18: 관련된 코드/함수/클래스를 가까이 유지하세요\n\n<div class=\"content-ad\"></div>\n\n테이블 태그를 마크다운 형식으로 변경해보세요.\n\n<div class=\"content-ad\"></div>\n\n두 가지가 강하게 관련이 없음을 나타내기 위해 공백을 사용하고, 강하게 연관된 것들은 공백을 사용하지 않습니다. 예를 들어 함수를 정의할 때...\n\n```js\ndef create(name):\n    print(name)\n```\n\n함수와 이름 변수 사이에 공백이 없습니다. 만약 공백이 있다면, 매우 조화롭지 않고 조직되지 않은 모습이 될 것입니다...\n\n```js\ndef create (name):\n    print (name)\n```\n\n<div class=\"content-ad\"></div>\n\n함수에 전달되는 인수는 구별되어야 합니다.\n\n## 법칙 20: 팀 규칙 준수\n\n거의 모든 개발자는 자신만의 스타일을 갖고 있습니다. 파일 이름 짓는 방식부터 print 문 작성 방식까지.\n\n하지만 다른 개발자들과 협업할 때는 개인적인 취향을 내려놓고 팀의 선호도를 받아들이는 것이 좋습니다. 다른 사람들이 당신의 코드에서 아름다움을 느끼지 못할 수도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## LAW 21: 마법 숫자 피하기\n\n마법 숫자란 나중에 변경될 수 있는 하드 코딩된 값으로, 그래서 업데이트하기 어려울 수 있습니다.\n\n예를 들어, \"나의 주문\" 개요 페이지에서 마지막 50개 주문을 보여주는 페이지가 있다고 가정해봅시다. 여기서 50은 마법 숫자입니다. 왜냐하면 표준이나 규약으로 설정되지 않았으며, 명세서에 기술된 이유로 임의로 정한 숫자입니다.\n\n이제 50을 서로 다른 곳에 넣으시는 것입니다 — SQL 스크립트 (SELECT TOP 50 \\* FROM orders), 웹사이트 (마지막 50개 주문), 주문 로그인 (for (i = 0; i ` 50; i++)) 그리고 가능한 다른 많은 장소에.\n\n<div class=\"content-ad\"></div>\n\n\n# 나쁨\nSELECT TOP 50 * FROM orders\n\n# 좋음\nNUM_OF_ORDERS = 50\nSELECT TOP NUM_OF_ORDERS * FROM orders\n\n\n## LAW 22: 깊은 중첩 피하기\n\n루프, 조건문 또는 함수 내의 중첩 수준을 제한하여 가독성을 향상시킵니다.\n\n\n# 나쁨\nif x:\n    if y:\n        do_something()\n\n# 좋음\nif x and y:\n    do_something()\n\n\n<div class=\"content-ad\"></div>\n\n## LAW 23: 임시 변수 피하기\n\n```js\n# 나쁜 예\ntemp_result = calculate(x, y)\nfinal_result = temp_result * 2\n\n# 좋은 예\nfinal_result = calculate(x, y) * 2\n```\n\n## LAW 24: 암호적 줄임말 피하기\n\n가독성을 높이기 위해 암호적 줄임말 대신 설명적인 이름을 사용하세요.\n\n<div class=\"content-ad\"></div>\n\n```md\n# 나쁜 예시\n\ndef calc(x, y):\npass\n\n# 좋은 예시\n\ndef calculate_total_price(quantity, unit_price):\npass\n```\n\n## 법칙 25: 경로 하드코딩 피하기\n\n파일 경로나 URL을 하드코딩하지 말고, 대신 구성 파일 또는 환경 변수를 사용해주세요.\n\n```md\n# 나쁜 예시\n\nfile_path = \"/path/to/file.txt\"\n\n# 좋은 예시\n\nimport os\nfile_path = os.getenv(\"FILE_PATH\")\n```\n\n<div class=\"content-ad\"></div>\n\n## LAW 26: 항상 Try-Catch-Finally 문 사용하기\n\n코드를 작성할 때, 오류 처리를 반드시 포함하는 것이 가장 좋습니다. 이렇게 하면 디버깅 프로세스를 가속화하고 코드의 정교성을 높일 수 있을 뿐만 아니라 코드를 깔끔하고 관리하기 쉽게 유지할 수도 있습니다.\n\n특정 코드에서 오류가 발생할 가능성이 높은 경우 try-catch 문을 사용하고 싶어할 것입니다.\n\nAPI 요청, 파일 처리 등의 작업은 어떤 이유로든 실패하거나 오류를 일으킬 가능성이 높습니다. 반면에 곱셈이나 나눗셈과 같은 작업에 대해 try-catch 문을 사용하는 것은 오히려 문제를 더 만들어내기 때문에 지양해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n## 법칙 27: 예외와 함께 컨텍스트 제공하기\n\n예외가 발생했을 때는 해당 예외가 발생한 위치와 디버깅할 수 있도록 충분한 컨텍스트를 제공해야 합니다.\n\n예외와 함께 유용한 오류 메시지를 생성해야 합니다. 오류를 출력할 때 해당 작업이 실패한 컨텍스트와 실패 유형을 명시해야 합니다.\n\n## 법칙 28: 여러 예외 클래스 사용 피하기\n\n<div class=\"content-ad\"></div>\n\n아래와 같은 코드를 본 적이 있나요?\n\n```js\ntry:\n    pass\nexcept ValueError:\n    pass\nexcept TypeError:\n    pass\nexcept IndexError:\n    pass\nexcept KeyError:\n    pass\nexcept FileNotFoundError:\n    pass\n```\n\n이 코드는 매우 부적절하며, 오류 처리에 추가 도움을 제공하는 대신 가독성, 복잡성 및 유지보수 측면에서 문제를 일으킵니다.\n\n우리가 마주칠 수 있는 모든 종류의 오류를 처리하기 위해 보다 일반적인 예외를 사용하는 것이 종종 더 나은 방법입니다. 기본적으로 이 유형의 예외는 우리가 받은 오류의 유형을 포함합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\ntry:\n pass\nexcept Exception:\n pass\n```\n\n특정 유형의 오류를 잡고 싶을 때 다른 모든 오류가 통과될 수 있도록 해주세요.\n\n## 법칙 29: 함수는 변이하거나 값을 반환해야 하나 둘 다 하면 안 된다.\n\n함수를 작성할 때 해당 함수가 정확히 무엇을 해야 하는지 유의해야 합니다. 인수를 변이시킬까요? 아니면 반환해야 하나요?```\n\n<div class=\"content-ad\"></div>\n\n만약 함수가 전달된 인수를 변형시키면, 그 함수 안에서만 그 작업을 하면 됩니다. 그 이외의 곳에서는 건드릴 필요가 없어요.\n\n하지만 여기서 변형이 무엇을 의미하는 걸까요? 함수가 인수의 내용을 변경하거나 인수의 데이터 유형을 변경하는 경우 변형됩니다.\n\n```js\ndef changed(array):\n    array.append('hello')\n```\n\n만약 인수가 다른 변수를 만들기 위해 사용된다면 그것은 변형이 아닙니다. 예를 들어, 시간이라는 인수가 거리를 계산하는 데 사용된다면, 그것은 변형이 아니기 때문에 거리는 그 함수에서 반환될 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\ndef calculate_distance(time, speed):\n    distance = speed * time\n    return distance\n```\n\n하지만 두 마리 토끼를 모두 잡는 방법이 있어요. 함수의 인수를 복사하고 그에 대한 변이(mutation)를 수행할 수 있어요. 이렇게 하면 부작용을 피할 수 있어요.\n\n```js\ndef changed(array):\n    array_copy = array[:]\n    array_copy.append(4)\n    return array_copy\n```\n\n## 법칙 30: 모든 함수 이름이 동사일 필요는 없어요.\n\n<div class=\"content-ad\"></div>\n\n네, 알겠어요. 이전에 제가 언급했던 것처럼 모든 함수명은 일반적으로 동사여야 한다고 했었는데, 때로는 함수명이 명사 형태여야 하는 경우가 있습니다. 이것이 언제 그런지 아는 것은 이전 법칙/법칙 29에 근거합니다.\n\n인수를 변형하지 않고 무언가를 반환하는 함수라면, 함수명은 명사여야 합니다. 반면에 인수를 변형하고 반환하지 않는 함수는 동사여야 합니다.\n\n이것은 파이썬 자체에 내장된 일반적인 관례입니다. sort나 append와 같은 메서드는 데이터 유형을 변형하고 None을 반환하기 때문에 동사입니다. 반면에 sorted, sum, product와 같은 메서드들은 전달된 인수를 변형하지 않고 데이터의 새 복사본을 반환하기 때문에 모두 명사입니다.\n\n물론 이에는 예외가 있고, 한 번 예외 상황을 마주했을 때는 언제든지 동사를 사용하도록 되돌아가도 괜찮습니다.\n\n<div class=\"content-ad\"></div>\n\n## 법칙 31: 클래스는 작아야 합니다\n\n그렇습니다! 클래스는 가능한 작아야 합니다. 함수와 마찬가지로요.\n\n함수에서는 크기가 함수 내의 줄 수에 의해 결정되지만 클래스에서는 책임의 수에 따라 결정됩니다.\n\n일반적으로 클래스 이름은 해당 클래스가 가질 수 있는 책임의 종류를 나타냅니다. 그러나 이름이 모호하거나 너무 일반적인 경우, 대부분 너무 많은 책임을 부여하고 있는 것입니다.\n\n<div class=\"content-ad\"></div>\n\n이는 클래스가 하나의 이유, 즉 변경할 책임이 하나만 있어야 한다는 SRP(단일 책임 원칙)로 되돌아가게 됩니다.\n\n## LAW 32: 클래스는 인스턴스 변수의 개수를 적게 가져야 합니다.\n\n인스턴스 변수는 클래스가 정의되거나 인스턴스화될 때 정의된 변수입니다.\n\n```js\nclass Animal:\n    def __init__(self, name):\n        self.name = name #인스턴스 변수\n```\n\n<div class=\"content-ad\"></div>\n\n만약 모든 우리의 함수가 클래스 책임과 관련이 있다면, 많은 인스턴스 변수를 가질 이유가 없어요.\n\n수많은 인스턴스 변수가 생기기 시작하는 건, 클래스의 핵심 역할에서 벗어난 함수 때문입니다.\n\n이러한 함수들은 다른 함수가 필요하지 않은 자체 변수를 가지게 됩니다.\n\n## 법칙 33: 당신의 클래스는 응집력이 있어야 합니다.\n\n<div class=\"content-ad\"></div>\n\n클래스 내의 모든 함수는 하나 이상의 인스턴스 변수를 포함해야 합니다. 함수가 클래스 내의 인스턴스 변수와 관련이 많거나 해당 변수를 포함하면 클래스의 응집력이 더 높아집니다.\n\n## 법칙 34: 자원 관리를 위해 with 문 사용하기\n\n파일이나 데이터베이스 연결과 같은 자원을 자동으로 관리하려면 with 문을 사용하여 해당 자원이 제대로 닫히거나 해제되도록 합니다.\n\n```js\n# 나쁜 예\nfile = open(\"example.txt\", \"r\")\ndata = file.read()\nfile.close()\n\n# 좋은 예\nwith open(\"example.txt\", \"r\") as file:\n    data = file.read()\n```\n\n<div class=\"content-ad\"></div>\n\n## 법칙 35: 복잡한 삼항 표현식 피하기\n\n과도하게 복잡한 삼항 표현식 사용을 삼가하고, 코드를 더 잘 이해할 수 있도록 간결함보다 가독성을 선호하세요.\n\n```js\n# 나쁨\nresult = \"even\" if number % 2 == 0 else \"odd\" if number % 3 == 0 else \"neither\"\n\n# 좋음\nif number % 2 == 0:\n    result = \"even\"\nelif number % 3 == 0:\n    result = \"odd\"\nelse:\n    result = \"neither\"\n```\n\n## 법칙 36: 정체성 비교에 ‘is’와 ‘is not’ 사용하기\n\n<div class=\"content-ad\"></div>\n\n대부분의 경우, 우리는 두 변수 사이의 비교를 확인하기 위해 ==를 사용합니다. 불변 데이터 유형인 문자열이나 정수와 같은 경우에는 보통 두 변수가 동일한 메모리 위치에 저장되기 때문에 메모리 위치 확인은 필요하지 않습니다.\n\n그러나 list, dict 및 사용자 정의 객체와 같은 가변 데이터 유형과 작업할 때는 종종 변수의 서브 유형과 메모리 위치를 확인하는 is 비교 연산자를 사용하는 것이 더 좋습니다.\n\n가변 객체의 메모리 위치는 Python의 작동 방식 때문에 보통 같지 않습니다. Python은 가변 객체를 서로 다른 메모리 위치에 저장합니다. 이것은 언제든지 변경될 수 있으며 각 객체가 다른 객체와 독립적이어야 하기 때문입니다.\n\n문자열, 튜플 및 정수는 생성된 후에 변경할 수 없습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n아래 링크를 사용하여 이 코드를 실행해보세요:\nhttps://python-fiddle.com/saved/nV6iEIyBuHm2mevD9Bhg\n\n# 예시 2: 두 리스트가 동일한 객체를 참조하는지 확인\nlist1 = [1, 2, 3]\nlist2 = [1, 2, 3]\n\n# 선호되지 않는 방법: == 사용\nif list1 == list2:\n    print(\"리스트는 동일한 값을 가집니다\")\n\n# 선호되는 방법: is 사용\nif list1 is list2:\n    print(\"리스트는 동일한 객체를 참조합니다\")\n\n# 참고: 이 경우에, list1과 list2는 동일한 값을 가진 다른 객체이므로,\n# `is`를 사용하면 `==`와 다른 결과가 나옵니다.\n```\n\n## LAW 37: 의존 역전 원칙\n\n의존 역전 원칙(Dependency Inversion Principle, DIP)은 객체 지향 설계의 중요한 원칙으로, 컴포넌트 간의 느슨한 결합을 촉진하고 소프트웨어 시스템의 보다 쉬운 유지보수와 확장을 돕습니다.\n\n고수준 모듈은 저수준 모듈에 의존해서는 안 되며, 둘 다 추상화에 의존해야 합니다.\n\n\n<div class=\"content-ad\"></div>\n\n다시 말해서, 클래스는 구체적인 구현이 아닌 인터페이스 또는 추상 클래스에 의존해야 합니다.\n\n```js\n# 나쁜 예\nclass Logger:\n    def log(self, message):\n        with open('log.txt', 'a') as f:\n            f.write(message + '\\n')\n\nclass Calculator:\n    def __init__(self):\n        self.logger = Logger()\n\n    def add(self, x, y):\n        result = x + y\n        self.logger.log(f\"{x}와 {y}를 더했습니다. 결과 = {result}\")\n        return result\n```\n\n위 예시에서 Logger 클래스를 정의하고 Calculator 클래스에서 직접 인스턴스를 생성합니다. 이로 인해 Calculator는 이제 Logger 클래스에 의존하며, Logger 클래스를 변경하면 Calculator 클래스도 수정해야 합니다.\n\n또한 이는 개방-폐쇄 원칙(확장에는 열려 있고 수정에는 닫혀 있음)을 지키지 못하는 것을 보여줍니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n# 좋은 코드\nfrom abc import ABC, abstractmethod\n\nclass LoggerInterface(ABC):\n    @abstractmethod\n    def log(self, message):\n        pass\n\nclass Logger(LoggerInterface):\n    def log(self, message):\n      with open('log.txt', 'a') as f:\n          f.write(message + '\\n')\n\nclass Calculator:\n    def __init__(self, logger: LoggerInterface):\n        self.logger = logger\n\n    def add(self, x, y):\n        result = x + y\n        self.logger.log(f\"Added {x} and {y}, result = {result}\")\n        return result\n```\n\n이 기능은 테스트하기가 더 어려울 수 있지만, 가짜 로거 클래스를 사용하여 테스트할 수 없게 만든다는 문제가 있습니다.\n\n이렇게 하면 인터페이스가 일관성을 유지하는 한 한 요소의 변경이 다른 요소에 변경을 요구하지 않기 때문에 모듈화를 촉진합니다.\n\n이 모듈성은 코드베이스를 더 쉽게 이해, 수정 및 확장할 수 있도록 만듭니다.\n\n<div class=\"content-ad\"></div>\n\n## 법칙 38: 데이터 유효성 검사에 'assert' 사용을 피하십시오\n\n'assert' 문은 디버깅 및 개발 목적으로만 사용하고, 제품 코드에서 데이터 유효성 검사에는 사용을 피하십시오.\n\n```js\n# 안 좋은 예\nassert x > 0, \"x는 양수여야 합니다.\"\n\n# 좋은 예\nif x <= 0:\n    raise ValueError(\"x는 양수여야 합니다.\")\n```\n\n## 법칙 39: 하드 코딩된 숫자를 피하십시오\n\n<div class=\"content-ad\"></div>\n\n명확성을 높이고 코드 수정을 쉽게 만들기 위해 의미 있는 이름으로 상수를 작성하십시오.\n\n```js\nDISCOUNT_RATE = 0.1\n\ndef calculate_discount(price):\n    discount = price * DISCOUNT_RATE\n    return price - discount\n```\n\n위 예제는 10% 할인을 나타내는 하드 코딩된 숫자 0.1을 사용합니다.\n\n이로 인해 숫자의 의미를 이해하기 어렵고 다른 부분에서 필요시 할인율을 조정하는 것이 어려워집니다.\n\n<div class=\"content-ad\"></div>\n\n```python\ndef calculate_discount(price):\n    TEN_PERCENT_DISCOUNT = 0.1\n    discount = price * TEN_PERCENT_DISCOUNT\n    return price - discount\n```\n\n개선된 코드는 숫자를 하드코딩하는 대신 TEN_PERCENT_DISCOUNT라는 이름이 지정된 상수로 대체합니다. 이 이름은 값의 의미를 즉시 전달하여 코드를 자체 문서화하는 데 도움이 됩니다.\n\n## LAW 40: DRY (Don’t Repeat Yourself) 원칙을 따르세요\n\n같은 코드를 한 번 이상 작성하지 않도록 합니다. 대신 함수, 클래스, 모듈, 라이브러리 또는 기타 추상화를 사용하여 코드를 재사용하세요. 이렇게 하면 코드가 더 효율적이고 일관되며 유지 보수가 용이해집니다.\n\n```\n\n<div class=\"content-ad\"></div>\n\n위의 표를 변경하여 마크다운 형식으로 변환해보세요.\n\n```js\n# 나쁜 예\n\ndef calculate_book_price(quantity, price):\n    return quantity * price\ndef calculate_laptop_price(quantity, price):\n    return quantity * price\n\n# 좋은 예\n\ndef calculate_product_price(product_quantity, product_price):\n    return product_quantity * product_price\n```\n\n## LAW 41: 존중할 만한 코딩 기준을 따르세요.\n\n공백, 주석, 그리고 명명에 대한 일반적으로 인정받은 컨벤션을 따르는 것이 중요합니다. 대부분의 프로그래밍 언어에는 커뮤니티에서 인정하는 코딩 표준과 스타일 가이드가 있습니다. 예를 들어, Python의 경우 PEP 8가 있습니다.\n\n<div class=\"content-ad\"></div>\n\n일반적으로 사용되는 관례들은 다음과 같습니다:\n\n- 변수, 함수 및 클래스 이름에는 snake_case를 사용합니다.\n- 들여쓰기에는 탭 대신 공백을 사용합니다.\n- 들여쓰기 단계마다 4개의 공백을 사용합니다.\n- 모든 줄을 최대 79자로 제한합니다.\n- 2진 연산자 앞에 줄바꿈을 넣습니다.\n\n## 법칙 42: 데메테르의 법칙\n\n데메테르의 법칙은 간단히 말하면 모듈/함수/클래스는 주변 모듈/함수/클래스에 대한 지식이나 참조를 가질 수 있지만 그 이상의 지식은 가져서는 안 된다는 것을 의미합니다.\n\n<div class=\"content-ad\"></div>\n\n인접한 이웃이라 함은 직접 액세스할 수 있는 메소드, 함수 또는 변수를 의미합니다.\n\n예제를 통해 설명해드리겠습니다...\n\n```js\nclass Order:\n    def __init__(self, customer):\n        self.customer = customer\n\n    def get_customer_name(self):\n        # 위반 사항: 주문이 고객의 구조에 대해 너무 많이 알고 있습니다\n        return self.customer.get_profile().get_name()\n```\n\n이 예제에서 Order 클래스는 고객의 프로필에 직접 접근하여 고객의 이름을 검색합니다. Order는 고객 객체의 내부 구조에 액세스하여 프로필 및 이름에 접근하고 있으므로 이는 데메테르 법칙을 위반합니다.\n\n<div class=\"content-ad\"></div>\n\n주변 이웃을 넘어서고 이제 고객 개체에 대해 너무 많이 알게 되었습니다.\n\n```js\nclass Order:\n    def __init__(self, customer):\n        self.customer = customer\n\n    def get_customer_name(self):\n        # 준수 사항: 주문은 직접적인 협력자와만 상호 작용합니다\n        return self.customer.get_name()\n```\n\n이 준수 사례에서 Order 클래스는 해당 고객 개체와만 상호 작용하고 고객의 이름을 검색하기 위해 직접적으로 메서드를 호출합니다.\n\n고객 개체의 내부 구조에 접근하지 않으므로 Demeter의 법칙을 따릅니다.\n\n<div class=\"content-ad\"></div>\n\n## 법칙 43: 간결함보다 가독성이 중요합니다\n\n코드는 기계가 해석할 수 있어야 합니다. 그러나 다른 개발자들도 코드를 이해할 수 있어야 합니다. 특히 여러 명이 참여하는 프로젝트에서 작업할 때는 더욱 중요합니다.\n\n소프트웨어 개발에서 가독성은 항상 코드의 간결성보다 중요합니다.\n\n만약 다른 개발자들이 이해할 수 없는 간결한 코드를 작성한다면, 그것은 별 의미가 없습니다.\n\n<div class=\"content-ad\"></div>\n\n## 법칙 44: Import를 깨끗하게 유지하세요\n\n필요한 모듈과 심볼만을 가져와서 import 섹션을 깔끔하게 유지하고 가독성을 향상시키세요. 모듈에서 모든 (\\*) 것을 가져올 때, 모든 변수, 함수 및 클래스도 가져오게 되어 특정 함수/클래스가 어디서 온 것인지 알기 어려워지며, 최신 IDE를 사용할 때 번거로울 수 있습니다.\n\n예를 들어, get_file이라는 함수를 작성하고 싶다고 상상해보세요. g를 클릭하면 IDE가 g로 시작하는 함수/클래스/변수 목록을 추천해줍니다. 이렇게 되면 꽤 혼란스러워질 수 있습니다.\n\n이것이 더 큰 문제로 변하는 경우가 있습니다. 함수를 호출하려고 할 때 더욱 문제가 될 수 있습니다. 함수 이름이 추천 목록 사이에 잃어버릴 수 있고, 이제 IDE가 효율적인 해결책보다는 문제로 변할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n\n# 나쁜 예\nfrom module import *\n\n# 좋은 예\nfrom module import symbol1, symbol2\n\n\n## LAW 45: Null/None을 반환하지 마세요\n\n보통 함수를 정의할 때, 기본적으로 반환 값이 지정되지 않은 경우 None이 반환됩니다. 그렇지만 우리가 명시적으로 None을 반환할 때는, 해당 함수가 None 이외의 다른 값을 반환할 수 있다는 것을 간접적으로 읽는 사람에게 알리는 것입니다.\n\n만약 이게 사실이 아니라면, 많은 오해를 불러올 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 법률 46: 건설과 사용 분리하기\n\n관심사의 분리는 소프트웨어 공학에서 매우 기본적인 원칙이 되어왔습니다. 우리는 소프트웨어의 건설 방식을 사용 방식으로부터 분리하는 방법을 알아야 합니다.\n\n이는 종종 시작 과정, 즉 의존성 및 객체들이 결합되는 때와 실행 시간 로직, 즉 응용 프로그램 로직이 사용자 입력이나 다른 트리거로부터 실행되는 경우와 같은 것들을 분리하는 것을 의미합니다.\n\n건설과 사용을 분리하는 일반적인 방법은 main이라는 파일/함수/모듈에서 응용 프로그램 로직을 구성하는 것입니다.\n\n<div class=\"content-ad\"></div>\n\n주요 기능은 응용 프로그램이 원활하게 실행되도록 필요한 객체를 구축합니다. 이렇게 함으로써 다른 모듈이 응용 프로그램에 강하게 결합되지 않도록하고 재사용성과 모듈성을 증진시킵니다.\n\n## LAW 47: 간단한 디자인에는 모든 이러한 규칙이 포함됩니다\n\n모든 테스트 실행: 시스템은 문서상으로 완벽한 디자인을 가질 수 있지만, 시스템이 의도한 대로 작동하는지 확인할 수 있는 방법이 없다면, 문서상의 디자인은 의문스러워집니다.\n\n중복이 포함되지 않음: 중복은 잘 설계된 시스템의 주요 적인 적수입니다.\n\n<div class=\"content-ad\"></div>\n\n프로그래머의 의도를 표현합니다\n\n클래스와 메소드의 수를 최소화합니다\n\n## LAW 48: 중첩된 Try-Except 블록 피하기\n\n너무 복잡한 오류 처리 논리를 방지하기 위해 try-except 블록을 과도하게 중첩하는 것을 삼가세요.\n\n<div class=\"content-ad\"></div>\n\n```js\n# 나쁜 예시\ntry:\n    try:\n        # 오류가 발생할 수 있는 코드\n        pass\n    except ValueError:\n        # ValueError 처리\n        pass\nexcept Exception as e:\n    # 다른 예기치 않은 오류 처리\n    pass\n\n# 좋은 예시\ntry:\n    # 오류가 발생할 수 있는 코드\n    pass\nexcept ValueError:\n    # ValueError 처리\n    pass\nexcept Exception as e:\n    # 다른 예기치 않은 오류 처리\n    pass\n```\n\n## 법칙 49: 필요할 때만 동시성 사용하기\n\n동시성 기능을 구현할 때 나쁜 코드를 작성하기가 매우 쉽습니다.\n\n또한, 매우 결함이 많은 동시성 기능을 구현할 때 깔끔한 코드를 작성하는 것도 매우 쉽습니다. 보통 시스템에 많은 스트레스가 가해질 때까지 잘못되었다는 것을 인식하지 못할 수도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n너는 매우 현명하게 전투를 선택하길 원해.\n\n너의 동시성 코드가 실패할 수 있는 여러 이유들이 있다. 여기 몇 가지 예시가 있다:\n\n굶주림(Starvation): 굶주림은 스레드나 프로세스가 공유 자원에 접근할 수 없어 계속해서 시도해도 영원히 실패하는 경우 발생한다. 이는 다른 스레드나 프로세스가 계속해서 자원을 확보하고 보유하여 굶주는 스레드가 진행하지 못하게 하는 경우에 발생할 수 있다.\n\n교착상태(Deadlocks): 교착상태는 두 개 이상의 스레드나 프로세스가 상호적으로 서로 자원을 해제하기를 무한정 대기하고 있는 경우 발생한다. 이는 각 프로세스가 한 자원을 보유하고 다른 프로세스가 보유한 다른 자원을 기다리며 순환 의존성을 만들어 서로 대기하는 경우에 발생할 수 있다.\n\n<div class=\"content-ad\"></div>\n\n## LAW 50: 49가지 법칙을 따르세요\n\n이 법칙들은 당신을 소프트웨어 엔지니어로서의 여정에서 안내하기 위해 존재합니다. 필요할 때마다 이를 준수해야 합니다.\n\n그러나 경험과 기술이 쌓일수록, 특정 규칙을 따를 때와 그렇지 않을 때를 판단할 수 있는 능력을 가지고 싶을 것입니다.\n\n이 직관은 자신의 기술을 숙달한 사람들에게만 주어지며, 만약 초보자이거나 2년 전에 경력을 시작한 경우라면, 이 법칙을 하늘로 가는 유일한 티켓으로 여기는 것이 가장 좋습니다.\n\n<div class=\"content-ad\"></div>\n\n대부분의 파이썬 개발자들은 코드를 빠르게 테스트하거나 오류를 디버깅하는 곳이 필요합니다. 저는 python-fiddle.com이라는 웹사이트를 개발했습니다. 여기에서 빠르게 코드를 테스트하고 AI/LLMs를 활용하여 가능한 오류의 해결책을 찾을 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-05-23-50CodingLawsThatWouldMakeYouADecentProgrammer_0.png"},"coverImage":"/assets/img/2024-05-23-50CodingLawsThatWouldMakeYouADecentProgrammer_0.png","tag":["Tech"],"readingTime":24},{"title":"분산 애플리케이션에서 캐싱 마스터하기","description":"","date":"2024-05-23 13:23","slug":"2024-05-23-MasteringCachinginDistributedApplications","content":"\n![마스터링 분산 애플리케이션의 캐싱](/assets/img/2024-05-23-MasteringCachinginDistributedApplications_0.png)\n\n소프트웨어 시스템의 캐싱 구현에서 버그를 만날 때마다 1달러가 있다면... 아마도 Redis Enterprise의 연간 기업 구독 비용을 지불할만큼의 돈이 쌓였을 것입니다.\n\n캐싱은 거의 올바르게 할 수 있지만, 결코 완벽하게 할 수 없는 것처럼 보입니다. 그것에는 좋은 이유가 있습니다. 결국 - 캐싱(또는 캐시 무효화)은 컴퓨터 과학에서 가장 어려운 두 가지 기본 문제 중 하나로 간주됩니다. 다른 하나는 변수의 명명이겠지요.\n\n농담인지 아니든 - 캐싱을 제대로 이해하는 것은 정말 어렵습니다 - 특히 대규모 분산 애플리케이션에서. 결과적으로 팀은 종종 캐싱 전략과 구현을 조정하기 위한 반복과 실험 과정을 거치며 - 마침내, 어느 정도 합리적이고 반최적적인 상태로 이르기를 희망하며.\n\n<div class=\"content-ad\"></div>\n\n이 글에서는 종종 간과되거나 오해되는 캐싱에 대한 몇 가지 측면을 명확하게 하고자 합니다.\n\n이 글을 읽은 후에는 캐싱이 무엇인지, 캐싱의 주요 접근 방식, 주의해야 할 사항 및 다양한 캐싱 기술을 실제 사용 사례에 어떻게 적용하는지에 대해 더 명확한 이해를 가지게 될 것입니다.\n\n그러니 더 이상 미루지 말고....\n\n# 캐싱이란?\n\n<div class=\"content-ad\"></div>\n\n캐싱은 간략히 말해서 데이터를 임시 저장하는 동작으로, 데이터를 원본 저장소(기록 시스템)에서 검색하는 것보다 더 저렴하거나 빠르거나 최적화된 방법으로 검색할 수 있는 임시 매체에 데이터를 저장하는 것을 말합니다.\n\n다른 말로 하면, 다음과 같은 사용 사례를 상상해보세요.\n\n주문 관리 시스템이 재고 시스템에서 제품 정보를 검색해야 하는 상황입니다. 재고 시스템이 그다지 효율적이지 않다고 가정해보겠습니다. 요청이 들어올 때마다 제품 정보를 가져오기 위해 중앙 데이터베이스로 이동해야 합니다. 이 데이터베이스는 느리며 너무 많은 병렬 요청을 처리할 수 없습니다.\n\n![이미지](/assets/img/2024-05-23-MasteringCachinginDistributedApplications_1.png)\n\n<div class=\"content-ad\"></div>\n\n성능을 향상시키고 재고 데이터베이스에 가해지는 부담을 완화하기 위해 캐싱 레이어를 도입했습니다. 이제 동일한 제품 정보를 저장하는 캐시가 추가되었습니다. 이제 버거운 데이터베이스를 거치지 않고 먼저 캐시에 접근하며, 캐시에 데이터가 있다면 그곳에서 가져옵니다.\n\n![이미지](/assets/img/2024-05-23-MasteringCachinginDistributedApplications_2.png)\n\n여기서 한 일은 성능을 향상시키고 원본 재고 데이터베이스의 자원 사용을 최적화하기 위해 임시 저장 매체(캐시)를 도입한 것입니다.\n\n# “캐시”란 무엇을 의미할까요?\n\n<div class=\"content-ad\"></div>\n\n사람들이 혼동하기 시작하는 지점 중 하나는 캐시의 기술적 성격에 대해입니다.\n\n소프트웨어 개발 분야에 종사하는 대다수의 사람들은 \"캐시\"라는 용어를 들었을 때 매우 구체적인 연상을 갖게 됩니다. 종종 이 용어를 Redis, Memcached 또는 EHCache와 같은 분산 캐시 제품과 연관시킵니다. 때로는 브라우저 캐시, 데이터베이스 캐싱, OS 캐싱 또는 하드웨어 캐싱을 떠올리기도 합니다.\n\n이것이 바로 핵심입니다. 캐시의 개념은 컴퓨터 과학 분야 내의 특정 제품이나 영역으로 제한되지 않습니다. \"캐싱\"은 널리 생각되는 바에 따르면, 우리가 어떤 레코드 시스템으로부터 데이터를 복제하는 임시 매체의 어떤 형태라도 될 수 있습니다. 그렇게 하는 이유는 그 데이터를 임시 매체에 저장하는 것이 한 방이나 다른 방식으로 유리하기 때문입니다.\n\n이는 일반적으로 비용 절감, 성능 향상 또는 원본 저장소보다 더 나은 확장성 때문에 그렇습니다.\n\n<div class=\"content-ad\"></div>\n\n이전 주문 관리 및 재고 시스템의 예제를 살펴보면 캐싱 레이어는 이론상 여러 가지로 구성될 수 있습니다:\n\n- 분산 캐싱 제품(예: Redis)\n- 자체 데이터베이스를 갖춘 다른 마이크로서비스\n- 실제 재고 관리 시스템 내부의 인메모리 저장소\n\n위의 모든 것은 서로 다른 구현이지만 각각 캐시의 조건을 충족할 것입니다.\n\n간단히 말하면 위에 언급된 모든 것들이 캐시가 될 수 있습니다. 컴퓨터 시스템 스택의 모든 수준과 다양한 디지털 도메인에서 캐싱이 구현될 수 있다는 개념으로, 직접 적용될 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 용어정의\n\n계속하기 전에 캐싱 주제 주변의 다양한 용어를 이해하는 것이 중요합니다.\n\n- **시스템 레코드(System of Record):** 데이터가 저장되는 영구 저장소입니다. 대부분 데이터베이스일 가능성이 높습니다. 참 값 시스템(source-of-truth system)이라고도 합니다.\n\n- **캐시 미스(Cache Miss):** 응용프로그램이 캐시를 쿼리하지만 해당 레코드가 캐시에 존재하지 않을 때 발생합니다.\n\n<div class=\"content-ad\"></div>\n\n새로 고침된 데이터: 캐시에 있는 레코드가 기본 시스템과 얼마나 동기화되어 있는지를 나타냅니다.\n\n<div class=\"content-ad\"></div>\n\n캐시 만료: 캐시 레코드를 에백션 프로세스의 일부로 또는 캐시 무효화의 일부로 시간 기반으로 제거하는 것을 의미합니다.\n\n이제 우리 모두가 캐싱 용어에 완전히 익숙해졌으니, 캐시가 구현될 수 있는 몇 가지 장소와 계층에 대해 살펴보겠습니다.\n\n# 캐싱은 어디에 구현되나요?\n\n이미 언급했듯이, 캐싱은 기술 영역 전반에 걸쳐 사용되며, 모든 수준 및 다양한 기술 스택 내에서 사용됩니다.\n\n<div class=\"content-ad\"></div>\n\n하드웨어 수준에서 캐싱은 CPU 아키텍처의 일부로 사용되며, 예를 들어 레벨 1-3 (L1/L2/L3) 캐시 형식으로 사용됩니다.\n\n운영 체제 커널 수준에서는 페이지 캐시라고 알려진 디스크 캐시 형식이 있습니다. 다른 형태도 있습니다.\n\n웹 기반 시스템에서는 물론 브라우저 캐시와 CDN(Content Delivery Networks)가 있습니다. 이 캐시는 일반적으로 정적 리소스(이미지, 스타일시트 등)를 사용자에게 빠르고 효율적으로 제공하고 대역폭을 줄이는 데 사용됩니다.\n\n다양한 종류의 응용 프로그램 및 미들웨어에도 자체 캐시가 있습니다. 예를 들어, 데이터베이스는 자주 사용되는 쿼리 및 자주 반환되는 결과 집합을 저장하기 위해 캐싱을 사용합니다.\n\n<div class=\"content-ad\"></div>\n\n또한, Redis, EHCache, Memcached, Hazelcast, Infinispan 등과 같은 많은 견고한 소프트웨어 캐싱 제품이 존재합니다. 이 제품들은 분산 애플리케이션 내에서 확장 가능한 분산 캐싱을 가능하게 합니다.\n\n이제 강조할 한 가지는 \"분산\" 캐시 개념이 \"로컬\" 또는 \"지역화된\" 캐시와 대조될 수 있다는 점입니다. 분산 캐시는 네트워크 상에서 여러 기기에 분산된 캐시 형태입니다. 로컬 캐시는 한 기기에만 존재합니다.\n\n이 두 개념 간의 차이를 이해하는 가장 좋은 방법은 클러스터 서버에 배포된 애플리케이션을 상상해보는 것입니다. 다시 말해, 동시에 여러 애플리케이션 인스턴스가 실행되는 것이 큰 규모 애플리케이션 개발자에게 익숙한 상황일 것입니다.\n\n이러한 시스템에 분산 캐시를 도입한다면, 어떤 애플리케이션 인스턴스에서든 해당 캐시에 접근하고 레코드를 수정할 수 있게 됩니다.\n\n<div class=\"content-ad\"></div>\n\n다른 한편으로, 로컬 캐시가 있다면 각 인스턴스마다 자체 캐시가 있을 것입니다. 그 캐시는 대부분 해당 인스턴스의 메모리 내에 위치할 것입니다. 서로 다른 인스턴스들은 다른 인스턴스의 캐시에 접근할 수 없을 것입니다. 그들은 자신들의 캐시에만 접근할 수 있을 것입니다.\n\n이러한 두 가지 접근 방식에는 장단점이 있습니다.\n\n한편으로, 여러 인스턴스가 캐시에 접근하는 경우 - 동기화 문제, 경쟁 조건, 데이터 손상 및 분산 애플리케이션에서 발생하는 기타 도전 과제를 해결해야 할 수도 있습니다. 다른 한편으로, 공유 캐시는 강력한 개념입니다. 왜냐하면 그것으로 가능했던 사용 사례를 처리할 수 있게 해줍니다. 로컬, 더 단순한 캐시로는 불가능했던 것들도 처리할 수 있게 해주기 때문입니다.\n\n예를 들어, 여러 가용 영역 내에서 클라우드 환경에 애플리케이션을 배포할 수 있습니다. 각 가용 영역은 애플리케이션을 실행하는 VM 인스턴스 클러스터를 가질 것입니다. 이러한 클러스터는 아마도 각각 자체 분산 캐시를 가질 것입니다. 분산 캐시의 전제조건 중 하나는 그것에 빠르고 효과적으로 액세스할 수 있어야 한다는 것입니다. 이는 캐시의 인스턴스에 서비스하는 네트워크 근접성(물리적일 필요는 없지만 가상적일 수도 있음)을 가지는 것을 의미합니다.\n\n<div class=\"content-ad\"></div>\n\n동시에 분산 및 로컬 캐싱에 공통적으로 발생하는 몇 가지 도전 과제가 있습니다.\n\n주요 도전 과제는 데이터 신선도 유지, 최적의 캐시 무효화 및 제거, 그리고 캐시 관리 방식을 특정 사용 사례에 잘 맞추는 것 사이의 꾸준한 균형입니다.\n\n캐시 관리 — 캐싱 패턴은 다음에 다룰 중요한 개념입니다.\n\n소프트웨어 엔지니어링에서의 대부분의 결정과 마찬가지로, 각 접근 방식에는 각자의 절충안(또는 다른 말로 장단점)이 있습니다. 아래에서 각 접근 방식의 장단점을 다룰 것입니다.\n\n<div class=\"content-ad\"></div>\n\n캐싱은 소프트웨어 엔지니어와 소프트웨어 아키텍트 모두가 이해해야 하는 중요한 개념입니다. 그러나 이것이 유일한 개념이라고는 할 수 없습니다.\n\n내 안내서 — 소프트웨어 아키텍트의 경력을 여는 법, 에서는 시니어 이상의 소프트웨어 엔지니어 및 소프트웨어/솔루션 아키텍트가 숙달해야 할 다른 개념, 기술 및 기술을 설명합니다.\n\n여기에서 확인하세요\n\n![마스터링 분산 애플리케이션에서의 캐싱 이미지](/assets/img/2024-05-23-MasteringCachinginDistributedApplications_3.png)\n\n<div class=\"content-ad\"></div>\n\n# 로컬 및 분산 캐싱 시스템의 패턴\n\n캐싱 시스템에는 다섯 가지 주요 캐싱 패턴이 있으며, 이들은 캐시가 데이터를 읽고 쓰는 방식 및 기본 시스템과 동기화하는 방식과 관련이 있습니다.\n\n# 캐시 옆에\n\n캐시 옆에 캐싱 전략은 아마도 가장 인기 있는 전략이며 대부분의 소프트웨어 엔지니어가 익숙한 전략입니다. 이 캐싱 접근 방식은 애플리케이션에 캐시 쓰기 및 읽기 제어를 완전히 맡깁니다. 여기서 애플리케이션은 데이터베이스 또는 캐시에서 읽을 때와 쓸 때를 모두 제어합니다.\n\n<div class=\"content-ad\"></div>\n\n아래는 그것이 작동하는 방법에 대한 예시입니다.\n\n당신의 애플리케이션이 사용자의 로그인 요청을 받고, 결과적으로 사용자의 우편 주소를 가져오게 된다고 상상해보세요.\n\n- 애플리케이션은 먼저 사용자의 주소가 캐시 내에 존재하는지 확인합니다.\n- 만약 해당 사용자의 주소 항목이 없다면, 애플리케이션은 데이터를 데이터베이스에서 가져옵니다.\n- 그러나 캐시 내에서 정보가 존재한다면, 해당 데이터는 즉시 검색되어 데이터베이스로의 여행을 절약합니다.\n- 새로운 정보를 가져온 후, 애플리케이션은 해당 데이터를 캐시에 기록합니다.\n\n2단계에서, 특정 아이템을 위한 캐시에 항목이 없다면 — 이것은 \"캐시 미스\"로 자주 언급됩니다.\n\n<div class=\"content-ad\"></div>\n\n\n![Image](/assets/img/2024-05-23-MasteringCachinginDistributedApplications_4.png)\n\n## 장점\n\n- 구현이 간단합니다.\n- 제어권은 애플리케이션에 완전히 남습니다.\n- 필요할 때만 캐시된 항목을 가져오므로 (게으른 로딩), 최소한의 메모리를 사용합니다. (이론적으로는)\n\n\n<div class=\"content-ad\"></div>\n\n### Write-Through Caching\n\n- 캐시 미스 발생 시 더 느린 저장소에서 데이터를 가져와야 하므로 지연 시간이 높아집니다. 캐시 미스가 많아지면 성능에 영향을 줄 수 있습니다.\n- 애플리케이션 로직이 더 복잡해집니다 (전반적인 아이디어는 구현하기 쉽지만요).\n\n### 사용 시기\n\n- 캐시가 어떻게 채워지는지에 대한 완전한 제어를 원할 때.\n- 데이터베이스 읽기/쓰기를 관리할 수 있는 캐싱 제품이 없을 때.\n- 캐시에 대한 액세스 패턴이 불규칙할 때.\n\n<div class=\"content-ad\"></div>\n\nWrite-Through 캐싱은 캐시와 기본 영속 데이터 저장소 사이의 일관성을 보장합니다. 다시 말해, 쓰기가 발생할 때 캐시와 데이터베이스 양쪽으로 동시에 전파됩니다.\n\n다음은 예시입니다:\n\n- 재무 애플리케이션이 사용자 계정을 새로운 잔액으로 업데이트하는 요청을 받습니다.\n- 사용자 계정 잔액은 데이터베이스와 캐시 둘 다에 존재합니다.\n- 데이터베이스와 캐시가 동일한 트랜잭션 내에서 새 값으로 업데이트됩니다.\n- 다른 요청이 발생하면, 이번에는 사용자의 잔액을 읽는 요청이 옵니다. 먼저 캐시에서 값을 찾아 사용합니다. 캐시가 가장 최신 값을 가지고 있기 때문에 기본 데이터베이스와 동기화되지 않을까 걱정할 필요가 없습니다.\n\n참고로 3단계는 애플리케이션 로직을 통해 수행할 수 있습니다. 그러나 실제 캐싱 제품에서는 해당 역할을 하게 됩니다. 예를 들어 EHCache나 Infinispan을 사용하는 경우 애플리케이션은 Redis 캐시를 업데이트하고, 다시 데이터베이스를 업데이트할 수 있도록 구성됩니다.\n\n<div class=\"content-ad\"></div>\n\n아래는 코드가 Markdown 형식으로 변경된 것입니다.\n\n\n![이미지](/assets/img/2024-05-23-MasteringCachinginDistributedApplications_5.png)\n\n# 장점\n\n- 캐시와 기본 데이터 저장소 사이의 일관성을 보장합니다.\n\n# 단점\n\n\n<div class=\"content-ad\"></div>\n\n- 트랜잭션 복잡성은 이제 캐시와 데이터베이스 업데이트 모두를 보장하기 위해 어떤 종류의 2단계 커밋 로직이 필요합니다 (캐시에 의해 제어되지 않는 한)\n- 운영상의 복잡성, 위의 어느 하나가 실패하면 사용자 경험을 세련되게 처리해야 합니다.\n- 쓰기가 더 느려집니다. 왜냐하면 이제 두 군데 (캐시 및 데이터 저장소)를 업데이트해야 하기 때문에 데이터 저장소에 하나만 업데이트할 때보다 더 많은 시간이 걸리게 됩니다.\n\n# 사용 시기\n\nStrong data consistency를 필요로 하고 퇴보된 데이터를 제공할 여유가 없는 애플리케이션에 적합합니다. 데이터가 작성된 직후 즉시 정확하고 최신 상태여야 하는 환경에서 흔히 사용됩니다.\n\n# Write-Around Caching\n\n<div class=\"content-ad\"></div>\n\n이 전략은 기본 저장소를 채우지만 캐시 자체는 채우지 않습니다. 다시 말해, 이 쓰기는 캐시를 우회하고 기본 저장소에만 쓰입니다. 이 기술과 Cache-Aside 기술 간에는 일부 중첩이 있습니다.\n\n차이점은 Cache-Aside에서 읽기와 지연로딩에 초점을 맞추는 반면, Write-Around 캐싱에서는 쓰기 성능에 초점을 맞추는 것입니다. 이 기술은 자주 데이터를 쓰지만 드물게 읽을 때 캐시 오염을 피하기 위해 종종 사용됩니다.\n\n<img src=\"/assets/img/2024-05-23-MasteringCachinginDistributedApplications_6.png\" />\n\n# 장점\n\n<div class=\"content-ad\"></div>\n\n- 캐시 오염이 줄어듭니다. 이는 모든 쓰기 작업에서 캐시가 채워지지 않기 때문입니다.\n\n## 단점\n\n- 일부 레코드가 자주 읽히고 캐시에 사전으로 로드되어 첫 번째 히트 시 데이터베이스로의 전송을 방지해야 하는 경우 성능이 저하됩니다.\n\n## 언제 사용해야 할까요?\n\n<div class=\"content-ad\"></div>\n\n많은 양의 쓰기 작업이 이루어지지만 읽기 작업은 상대적으로 적을 때 자주 사용됩니다.\n\n# Write-Back (Write-Behind) 캐싱\n\n쓰기 작업이 먼저 캐시를 채우고 데이터 저장소에 기록됩니다. 이곳의 핵심은 데이터 저장소에 쓰기가 비동기적으로 발생한다는 점입니다. 그러므로 이러한 경우 두 단계 트랜잭션 커밋이 필요 없어집니다.\n\n쓰기 지연 캐싱 전략은 보통 캐싱 제품에서 처리됩니다. 캐싱 제품이 이러한 메커니즘을 갖고 있다면, 응용 프로그램은 캐시에 쓰기를 하고, 캐싱 제품은 변경 사항을 데이터베이스로 전송하는 책임이 있습니다. 만약 캐시 제품에서 이를 지원하지 않는다면, 응용 프로그램 자체가 데이터베이스로 비동기적인 업데이트를 트리거할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n\n![Image](/assets/img/2024-05-23-MasteringCachinginDistributedApplications_7.png)\n\n## 장점\n\n- 초기 트랜잭션 내에서 캐시에만 쓰기 작업이 발생하므로 쓰기 속도가 빨라집니다. 데이터베이스는 나중에 업데이트됩니다.\n- 흐름을 캐싱 제품이 처리하면 애플리케이션 로직이 덜 복잡해집니다.\n\n## 단점\n\n\n<div class=\"content-ad\"></div>\n\n- 데이터베이스와 캐시가 새로운 변경 사항을 수신하게 될 때까지 둘 사이에 불일치 가능성이 있습니다.\n- 캐시가 최종적으로 데이터베이스를 업데이트하려고 할 때 오류가 발생할 위험이 있습니다. 이 경우 데이터베이스가 가장 최신 데이터를 수신하도록 보장하기 위해 더 복잡한 메커니즘이 필요할 수 있습니다.\n\n# 사용 시기\n\n쓰기 퍼포먼스가 중요하고 데이터베이스의 데이터가 캐시와 잠시 동안 약간 동기화되어 있어도 괜찮을 때 쓰기 지연 캐싱을 사용할 수 있습니다. 높은 쓰기 부하를 처리해야 하지만 일관성 요구사항이 덜 엄격한 애플리케이션에서 적합합니다. 이 방법이 사용될 수 있는 한 예는 캐시된 콘텐츠를 빠르게 업데이트한 다음 레코드 시스템에 동기화하는 CDNs(콘텐츠 전송 네트워크)입니다.\n\n# 읽기 - 스루\n\n<div class=\"content-ad\"></div>\n\n캐시 생성 방식은 일반적으로 캐시 옆에 두어 캐시 미스 발생 시 데이터베이스로부터 데이터를 가져온후 캐시에 저장하는 것에 유사합니다. 그러나 캐시 생성 방식은 애플리케이션에게 캐시와 데이터베이스를 모두 질의하는 책임을 맡기는 반면, 읽기-스루는 해당 메카니즘을 가지고 있을 경우 해당 제품에게 질의하는 방식입니다.\n\n![이미지](/assets/img/2024-05-23-MasteringCachinginDistributedApplications_8.png)\n\n# 장점\n\n- 간편함 — 모든 로직이 캐싱 애플리케이션에 캡슐화되어 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 단점\n\n- 캐시 미스 발생 시 데이터베이스에서 데이터를 읽을 때 잠재적인 지연이 발생할 수 있습니다. 데이터 업데이트를 위한 복잡한 무효화 메커니즘이 필요합니다.\n\n# 사용 시기\n\n리드-스루 캐싱은 데이터에 접근하는 코드를 간소화하고자 할 때 사용됩니다. 또한, 캐시가 항상 데이터 저장소의 가장 최근 데이터를 포함하도록 보장하고 싶을 때 사용됩니다. 쓰기보다 읽기가 더 자주 발생하는 애플리케이션에 유용합니다. 그러나 여기서 중요한 점은 캐싱 제품이 구성 또는 기본 시스템에서 이러한 읽기를 수행할 수 있는 능력을 가져야 한다는 것입니다.\n\n<div class=\"content-ad\"></div>\n\n# 캐싱 전략 요약\n\n다섯 가지 캐싱 패턴에 대해 이야기한 내용을 아래에서 요약했습니다.\n\n## 캐시 옆에 캐싱\n\n애플리케이션이 캐시에서 데이터를 찾지 못하고 요청할 때만 요청에 따라 데이터가 캐시로 로드됩니다.\n\n<div class=\"content-ad\"></div>\n\n실제 예시: 온디맨드로 제품 세부 정보를 캐싱하는 전자 상거래 웹사이트.\n\n데이터베이스 작업 책임: 응용 프로그램\n\n## 쓰기-스루\n\n일괄 쓰기 작업은 일괄 캐시 및 기본 데이터 저장소에 동시에 작성되어 일관성을 유지합니다.\n\n<div class=\"content-ad\"></div>\n\n실제 예시: 거래마다 일관된 계좌 잔액을 유지하기 위한 은행 시스템\n\nDB 작업 책임: 캐싱 제품 또는 애플리케이션\n\n## Write-Behind (Write-Back)\n\n쓰기 작업은 먼저 캐시에 기록되고 나중에 데이터 저장소에 비동기적으로 기록됩니다.\n\n<div class=\"content-ad\"></div>\n\n실제 예시: CDN이 먼저 캐시에 콘텐츠를 업데이트하고 나중에 스토리지 시스템에 동기화하는 방식입니다.\n\nDB 작업 책임: 제품 또는 애플리케이션 캐싱\n\n## 라이트-어라운드\n\n쓰기 작업은 캐시를 우회하고 데이터 저장소를 직접 업데이트하여 즉시 필요하지 않은 데이터를 캐싱하는 것을 피합니다.\n\n<div class=\"content-ad\"></div>\n\n실제 예시: 로그 작업에 대한 어디에서 캐싱없이 직접 스토리지로 기록합니다.\n\n데이터베이스 작업 책임: 애플리케이션\n\n## Read-Through\n\n캐시는 읽기를 위한 주요 인터페이스 역할을 합니다. 캐시에 데이터가 없으면 시스템에서 해당 데이터를 가져와 캐시에 저장합니다.\n\n<div class=\"content-ad\"></div>\n\n실제 예시: 사용자 프로필 서비스가 캐시 미스 상황에서 사용자 데이터를 가져오고 캐싱하는 경우.\n\nDB 작업 책임: 제품 또는 응용 프로그램 캐싱\n\n## 캐시 무효화\n\n이제 우리는 캐시를 채우는 다양한 방법을 이해했으니, 기록 시스템과 동기화하여 유지하는 방법도 이해해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n캐시 무효화에 관한 두 가지 주요 접근 방식은 시간 기반 방식과 이벤트 기반 방식입니다. 무효화를 위한 시간 기반 접근 방식은 대부분의 캐싱 제품에서 제공되는 TTL(Time-To-Live) 설정으로 제어할 수 있습니다. 이벤트 기반 접근 방식은 응용 프로그램이나 다른 요소가 새 레코드를 캐시로 전송해야 합니다.\n\n데이터 캐시에 대한 중요한 점은 거의 항상 기본 데이터 저장소(시스템 기록)와 어느 정도 동기화되어 있지만 매우 빨리 구식이 된다는 것입니다. 다시 말해 — 구식 상태가 됩니다. 캐시를 가능한 한 시스템 기록과 동기화된 상태로 유지하기 위해 캐시 무효화 전략을 구현해야 합니다.\n\n다시 말해, 캐시 내에서 데이터 \"신선도\"를 보장해야 합니다.\n\n캐시 무효화는 새 레코드가 시스템 기록으로부터 검색되어 캐시로 입력되는 현상을 유발합니다. 따라서 캐시 무효화와 위에서 논의한 캐싱 전략 사이의 관계를 이해하는 것이 매우 중요합니다.\n\n<div class=\"content-ad\"></div>\n\n캐싱 전략은 데이터가 캐시에서 로드되고 검색되는 방식과 관련이 있습니다. 반면에 캐시 무효화는 시스템 레코드와 캐시 간 데이터 일관성과 신선도와 더 관련이 있습니다.\n\n따라서 이 두 가지 개념 사이에는 약간의 중첩이 있으며 일부 캐싱 전략에서는 무효화가 다른 것보다 간단할 수 있습니다. 예를 들어 캐시-쓰기 쓰기 방식의 경우 캐시가 모든 쓰기마다 업데이트되므로 추가 구현이 필요하지 않습니다. 하지만 삭제는 반영되지 않을 수 있기 때문에 명시적으로 이를 다루는 응용 프로그램 논리가 필요할 수 있습니다.\n\n캐싱 엔트리를 무효화하는 두 가지 방법이 있습니다:\n\n## 이벤트-드리븐\n\n<div class=\"content-ad\"></div>\n\n이벤트 기반 접근 방식을 사용하면 응용 프로그램이 기록의 기반 저장소에서 변경이 발생할 때마다 캐시를 알립니다. 레코드가 변경될 때마다 동기적 또는 비동기적으로 캐시에 알림을 트리거합니다.\n\n이 작업은 응용 프로그램을 통해 수행할 수 있으며, 코드가 캐시를 최신 상태로 유지하는 것에 책임이 있습니다. 또는 일부 캐싱 제품에서는 퍼브/섭 기능이 제공될 수 있으며, 캐싱 제품이 이러한 유형의 알림에 가입할 수 있습니다. 그 경우 응용 프로그램에서 할 작업이 덜 할 수 있지만, 여전히 이러한 알림 이벤트를 생성해야 합니다.\n\n## 시간 기반\n\n시간 기반 접근 방식을 사용하면 모든 캐시 레코드에 TTL(임시 소멸 시간)이 지정됩니다. 레코드의 TTL이 만료되면 해당 캐시 레코드가 삭제됩니다. 이것은 일반적으로 캐싱 제품에 의해 제어됩니다.\n\n<div class=\"content-ad\"></div>\n\n# 캐시 축출 전략\n\n캐시 축출은 기존 캐시 레코드를 제거하는 캐시 무효화와 유사합니다. 그러나 캐시 축출은 캐시가 가득 차서 더 이상 레코드를 수용할 수 없는 경우에 필요합니다.\n\n기억하세요, 캐시의 목적은 가장 자주 액세스되는 레코드의 부분 집합을 저장하는 것입니다. 전체 진실의 원본 시스템을 복제하는 것이 아닙니다. 따라서 캐시의 크기는 일반적으로 데이터베이스 / 진실의 원본 / 기록 시스템에 저장된 데이터의 크기보다 훨씬 작을 것입니다.\n\n따라서 레코드를 \"축출\" 또는 다른 말로 삭제할 수 있는 메커니즘이 필요합니다.\n\n<div class=\"content-ad\"></div>\n\n동시에 캐시의 존재 이유를 완전히 무의미하게 만들지 않기 위해 애플리케이션이 제일 필요하지 않을 것으로 생각되는 레코드부터 시작해야 합니다.\n\n최적으로 레코드를 제거하는 방법을 보장하기 위해 사용할 수 있는 몇 가지 퇴직 전략이 있습니다:\n\n## Least Recently Used (LRU)\n\n이 접근 방식을 통해, 얼마 동안 사용되지 않은 레코드를 제거합니다.\n\n<div class=\"content-ad\"></div>\n\n사용 시기: 데이터가 마지막으로 액세스된 후 시간이 경과함에 따라 데이터가 곧 액세스될 가능성이 줄어드는 시나리오에서 효과적입니다. 미래 액세스의 강력한 지표인 액세스 최근성을 고려하는 일반적인 캐싱에 적합합니다.\n\n사용하지 말아야 할 때: 데이터 액세스 패턴이 최근성과 관련이 없는 워크로드에는 이상적이지 않습니다.\n\n## 먼저 들어온 것이 먼저 나간다 (FIFO)\n\n다른 레코드보다 이전에 캐시에 저장된 레코드를 제거합니다.\n\n<div class=\"content-ad\"></div>\n\n사용할 때: 데이터의 나이가 액세스 빈도나 최근성보다 중요한 캐시에 유용합니다. 예측 가능한 수명을 가진 데이터를 캐싱하는 데 적합합니다.\n\n사용하지 않을 때: 이전 데이터가 여전히 빈번하게 액세스되는 워크로드에는 최적이 아닙니다.\n\n## 최소 사용 빈도 순서 (LFU)\n\n빈번하게 사용되지 않거나 액세스되지 않는 레코드를 삭제합니다.\n\n<div class=\"content-ad\"></div>\n\n사용 시기: 오랜 기간 동안 자주 액세스되는 데이터를 보관해야 하는 상황에 가장 적합합니다. 안정된 액세스 패턴을 갖는 애플리케이션에 적합합니다.\n\n사용하지 말아야 하는 경우: 액세스 패턴이 크게 변할 수 있는 환경에서는 효과가 떨어집니다. 자주 액세스되지 않는 항목들이 캐시를 오염시킬 수 있습니다.\n\n## Time To Live (TTL)\n\n미리 결정된 Time-To-Leave 기간에 따라 퇴거합니다.\n\n<div class=\"content-ad\"></div>\n\n사용 시기: 특정 기간 이후에 만료되거나 변하지 않는 데이터에 이상적입니다.\n\n사용하지 말아야 할 때: 유효성이 시간이 지나면 자연스럽게 종료되지 않고 다른 요인에 따라 캐시에 영원히 남아있어야 하는 데이터에 적합하지 않습니다.\n\n## 무작위 치환\n\n기록을 무작위로 대체합니다.\n\n<div class=\"content-ad\"></div>\n\n사용 시점: 고급 추적 메커니즘의 비용이 혜택을 상쇄하는 상황이거나 액세스 패턴이 예측할 수 없어 다른 제거 전략이 적합하지 않은 경우에 사용할 수 있습니다.\n\n사용하지 않는 시점: 대체로 다른 전략에 비해 대부분 예측 가능한 액세스 패턴이 있는 실제 시나리오에서는 효율이 떨어질 수 있습니다.\n\n# 요약\n\n분산 응용 프로그램에서 캐싱의 중요성과 올바른 캐싱 전략을 선택하는 중요성에 대해 이야기했습니다. 일반적으로 사용되는 여러 전략이 있습니다:\n\n<div class=\"content-ad\"></div>\n\n- 캐시 오프 (Cache-aside)\n- 쓰기-스루 캐시 (Write-through cache)\n- 읽기-스루 캐시 (Read-through cache)\n- 쓰기 배후 캐시 (Write-behind cache)\n- 쓰기 주변 캐시 (Write Around)\n\n우리는 또한 시간 기반 또는 이벤트 기반 접근 방식을 사용하여 캐시 무효화에 대해 이야기했습니다.\n\n캐시 제거의 중요성과 어떤 전략이 그 일을 수행하는지에 대해 주목했습니다. 이것들은 다음과 같습니다:\n\n- LRU\n- FIFO\n- LFU\n- TTL\n- 임의(Random)\n\n<div class=\"content-ad\"></div>\n\n마지막으로, 캐시는 로컬 또는 분산 형태일 수 있습니다. 전자는 단일 기계/응용프로그램 인스턴스에 한정되어 있습니다. 후자는 여러 기계에 걸쳐 확장되며 일반적으로 (필수는 아니지만) 인스턴스 클러스터에 한정되어 있습니다.\n\n많은 혁신이 시장에서 발생하고 있는 캐시 제품과 관련된 기술들과 유행에 대해 몇 가지 명확한 정보를 제공했기를 바랍니다. 왜 캐싱이 중요한지, 그리고 캐싱 기술을 다룰 때 이해해야 하는 모든 다른 용어와 미묘한 점에 대한 직관력을 향상시켜주길 바랍니다.\n\n# 캐싱: 미래\n\n다른 기술들과 마찬가지로 캐싱 제품이 시장에서 엄청난 혁신이 일어나고 있습니다. 일부 주목할만한 하이라이트는 다음과 같습니다:\n\n<div class=\"content-ad\"></div>\n\n# 에지 컴퓨팅과 통합\n\n에지 컴퓨팅이 계속해서 성장함에 따라, 캐싱 전략은 더 분산화되어 데이터를 네트워크 가장자리에 필요한 위치에 더 가까이 이동시킵니다. 이 근접성은 레이턴시, 대역폭 및 데이터 제공 비용을 줄입니다. 이는 IoT 및 모바일 앱과 같은 실시간 응용 프로그램에 매우 중요합니다.\n\n예시: 자율 주행 차량은 에지 컴퓨팅을 사용하여 실시간 데이터를 로컬에서 처리합니다. 지도 및 교통 상황과 같은 핵심 데이터를 에지 노드에서 캐싱하면 중앙 서버를 쿼리하는 레이턴시 없이 신속한 의사결정을 할 수 있습니다.\n\n# AI와 머신 러닝 기반 캐싱\n\n<div class=\"content-ad\"></div>\n\nAI와 머신 러닝은 데이터 사용 패턴을 예측하고 예상된 필요에 따라 미리 데이터를 캐싱함으로써 캐싱 메커니즘을 향상시킬 수 있습니다. 이러한 예방적인 접근 방식은 효율성을 크게 향상시킬 수 있습니다. 특히 데이터 액세스 패턴이 자주 변경되는 동적 환경에서는 더욱 그렇습니다.\n\n예시: 아마존은 머신 러닝을 사용하여 사용자 행동을 예측하고 블랙 프라이데이와 같은 피크 타임에 사용자가 구매할 가능성이 높은 제품을 미리 캐싱합니다. 이는 로드 시간을 줄이면서 사용자 경험을 향상시킵니다.\n\n# 인메모리 데이터 그리드 (IMDG)\n\nIMDG는 분산 시스템 전반에 걸쳐 저지연 복잡한 데이터 액세스를 제공하는 캐싱의 강력한 솔루션이자 빠르게 발전하고 있습니다. IMDG는 데이터를 캐싱뿐만 아니라 캐시 레이어 내에서 다양한 데이터 처리 기능, 실시간 분석 및 의사 결정 기능을 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n예시: 고주파 트레이딩 플랫폼은 IMDG를 활용하여 시장 데이터와 거래 주문을 메모리에 캐시합니다. 이를 통해 서브초 단위 거래 결정을 내리는 데 필수적인 빠른 액세스와 처리가 가능해집니다.\n\n안녕하세요, 저는 야코프입니다. CloudWay Digital Inc을 운영하고 있는 소프트웨어 아키텍처 컨설팅 기관인 Developer.Coach에서 소프트웨어 엔지니어와 아키텍트들이 경력을 향상시키는 데 도와드리고 있습니다.\n\n제 Medium 무료 기사 외에도, 소프트웨어 엔지니어링 전문가들의 경력 향상에 도움이 되는 가이드 몇 편을 작성했습니다. 아래 링크를 통해 확인해보세요:\n\n👉 소프트웨어 아키텍트의 경력 잠금 해제\n\n<div class=\"content-ad\"></div>\n\n👉 소프트웨어 아키텍트 인터뷰 마스터하기\n\n👉 소프트웨어 엔지니어링 경력 잠금 해제: 중급에서 시니어로\n\n원본 게시물: 2024년 5월 17일, https://www.cloudwaydigital.com 에서 게시됨.\n","ogImage":{"url":"/assets/img/2024-05-23-MasteringCachinginDistributedApplications_0.png"},"coverImage":"/assets/img/2024-05-23-MasteringCachinginDistributedApplications_0.png","tag":["Tech"],"readingTime":16},{"title":"AI-강화 주제 탐구로 예술 창작을 재정의하기","description":"","date":"2024-05-23 13:21","slug":"2024-05-23-TEV1RedefiningArtCreationwithAI-EnhancedThematicExploration","content":"\n![이미지](/assets/img/2024-05-23-TEV1RedefiningArtCreationwithAI-EnhancedThematicExploration_0.png)\n\n기술의 끊임없는 발전 속에서 AI는 계속해서 한계를 넓히고 가능성을 재정의합니다.\n\nAsycd에서는 스스로에게 이렇게 물었습니다: AI를 활용하여 예술적인 과정을 혁신할 수 있는 방법은 무엇일까요? 이 질문은 TEV1 – 테마틱 익스플로러 V1의 탄생으로 이어졌습니다. 그러나 TEV1의 변화의 힘에 대해 들어가기 전에, 그 탄생 배경과 갖추고 있는 탁월한 기능들을 탐험해보겠습니다.\n\n# 왜 우리가 TEV1을 만들었는가\n\n<div class=\"content-ad\"></div>\n\n\n![TEV1 Image 1](/assets/img/2024-05-23-TEV1RedefiningArtCreationwithAI-EnhancedThematicExploration_1.png)\n\nTEV1의 시작은 예술적 창작 프로세스를 단순화하고 향상시키는 욕망에서 비롯되었습니다. 우리는 작가, 작가 및 크리에이터들이 종종 자신의 비전과 일치하는 주제를 개념화하고 시각물을 생성하는 데 상당한 시간을 소비한다는 것을 인지했습니다. 우리의 목표는 이러한 시간과 노력을 줄이고, 창작자들이 핵심 창작 작업에 더 집중할 수 있는 도구를 디자인하는 것이었습니다.\n\n게다가, 특히 DALL-E 3 및 GPT-4o와 같은 도구를 통한 인공 지능의 발전으로 고품질의 특정 주제 이미지를 생성하는 잠재력이 실행 가능하고 매력적해졌습니다. TEV1은 이러한 잠재력을 활용하기 위한 우리의 대응책으로, 창작자들에게 강력하고 직관적인 도구를 제공하여 세계 어디서나 사용할 수 있도록 합니다.\n\n![TEV1 Image 2](/assets/img/2024-05-23-TEV1RedefiningArtCreationwithAI-EnhancedThematicExploration_2.png)\n\n\n<div class=\"content-ad\"></div>\n\n또한 이미지 생성 능력의 발전에 큰 투자 관심을 가지고 있습니다. 이미지 생성 도구를 사용하여 아이디어를 반영적 이미지로 변환하는 능력은 이미 훌륭하지만, 우리가 생각하는 것과 볼 수 있는 것 사이의 간격을 좁히는 것이 중요합니다.\n\n마음에 떠오르는 무작위 아이디어를 화면이나 캔버스, 심지어 의류 디자인으로 구현하는 것이 TEV1의 목적입니다.\n\n# TEV1 작동 원리\n\nTEV1은 최첨단 AI 기술인 DALL-E 3과 이미지 생성 및 콘텍스트 이해, 이미지 프롬프트 향상을 위해 GPT-4o를 사용하여 구축되었습니다. 사용자가 주제를 입력하면 TEV1은 이러한 고급 모델을 사용하여 주제를 분석하고 해당 주제의 본질을 담은 시각적 표현물을 생성합니다.\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-05-23-TEV1RedefiningArtCreationwithAI-EnhancedThematicExploration_3.png)\n\n저희 도구에는 컨텍스트 로딩, 자동 데이터 처리 및 RAG와 같은 복잡한 기능이 포함되어 있어 생성된 이미지가 관련성을 가지고 미학적으로 매력적인 것을 보장합니다. 현재는 관심도 및 성능을 측정하기 위한 샘플 생성에 제한되어 있지만, TEV1은 지속적인 사용자 피드백과 모델 훈련을 통해 발전하도록 설계되었습니다.\n\n## 데이터에서 아트로 — 우리가 새로운 아트워크를 위해 역사적 데이터를 활용하는 방법\n\n![이미지](/assets/img/2024-05-23-TEV1RedefiningArtCreationwithAI-EnhancedThematicExploration_4.png)\n\n\n<div class=\"content-ad\"></div>\n\nAsycd의 설립 이후로 우리는 예술을 생성하고 텍스트 설명을 만드는 작업을 진행해 왔습니다. 이러한 텍스트 설명은 대부분 내부에서 저장되어 사용되어 왔지만, 앞으로 출시될 웹 애플리케이션을 위한 TEV1 모델 훈련에 사용될 예정입니다.\n\n오늘을 기준으로 이러한 설명 중 일부는 저희 웹사이트에서 접근 가능한 곳에 공개되어 있습니다. 이 데이터를 사용하여 이전과 동일한 프롬프트 기술과 스타일을 활용하여 새로운 작품을 만들고 있습니다. 이 과정에 대해 자세히 다룰 예정이며, 이는 매우 상세한 과정이기 때문입니다.\n\n![이미지](/assets/img/2024-05-23-TEV1RedefiningArtCreationwithAI-EnhancedThematicExploration_5.png)\n\n우리는 이 데이터를 활용하여 이전 작품에 성공적인 프롬프트 기술과 스타일을 사용하여 새로운 작품을 생성합니다. 이를 통해 과거 작업에서 영감을 빨아들이면서도 지속적이고 고품질의 예술을 만들어낼 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# TEV1: 예시 및 사용 사례 소개\n\nTEV1은 다양한 시각 디자인 분야에서 사용되며 다양한 매체에 대한 매우 상세한 그래픽을 생성할 수 있습니다.\n\n## 예술적 영감\n\nTEV1의 주요 사용 사례 중 하나는 예술적 영감을 제공하는 것입니다. 예술가들은 '어두운 심리학'부터 '로맨티시즘'까지 다양한 주제를 입력할 수 있으며, TEV1은 이러한 주제와 일치하는 이미지를 생성할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n![Image](/assets/img/2024-05-23-TEV1RedefiningArtCreationwithAI-EnhancedThematicExploration_6.png)\n\nTEV1은 짧은 아이디어나 개념을 이야기를 담은 예술작품으로 변화시킬 수 있어요. 빠르게 떠오르는 영감을 활용하기에 안성맞춤이에요. 첨단 프롬프트 공학과 다양한 대형 언어 모델의 다층구조 덕분에, 테마 익스플로러 V1은 이미지뿐만 아니라 주제에 맞는 시각적 일치 작품을 생성해요.\n\n이 종합적인 방법론은 덧없는 생각을 다채롭고 표현력 풍부한 작품으로 변모시켜요. 이 작품들은 소셜 미디어 게시물부터 마케팅 자료 등 다양한 용도로 사용할 수 있어요.\n\n## 그래픽 디자인과 웹 디자인\n\n<div class=\"content-ad\"></div>\n\n취미로 즐기는 분들과 열정적인 창작가들을 위해 TEV1은 개인 프로젝트를 현실로 만들어 주는 견고한 플랫폼을 제공합니다. 개인 블로그를 위한 독특한 시각적 콘텐츠 작성, 소설을 위한 스토리보드 디자인, DIY 프로젝트를 위한 주제별 아트워크 초안 작성 등, TEV1은 창작하는 여러분의 작품에 전문적인 손길을 더해줍니다.\n\n우리는 이 도구를 사용하여 웹사이트의 장식을 완전히 맞춤화했고, 지속적인 개선 노력 덕분에 우리 웹사이트가 이전보다 더 멋지게 변했습니다!\n\n![TEV1 이미지](/assets/img/2024-05-23-TEV1RedefiningArtCreationwithAI-EnhancedThematicExploration_7.png)\n\n웹 디자이너들은 TEV1 이미지 생성기를 활용하여 자신들의 웹사이트에 완벽한 배경 씬을 설정할 수 있는 매료되는 이미지를 만들 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n그래픽 디자이너들에게 TEV1 세대는 가능성의 보물창고입니다. 그들은 끝없는 패턴, 생동감 넘치는 디자인, 그리고 고유한 구성에 접근하여 창의적인 과정을 시작하거나 프로젝트에 마지막 손짓을 더할 수 있습니다. 이는 올해 초부터 \"VALENHEARTS\" 컬렉션에서 작업한 예술가들에 의해 그렇게 사용되었고, 이 도구의 창의적인 힘을 조금 오박사 단계에서 목격했습니다.\n\n![TEV1](/assets/img/2024-05-23-TEV1RedefiningArtCreationwithAI-EnhancedThematicExploration_8.png)\n\n## 모든 것을\n\n우리는 이것을 창의적이거나 디자인 중심의 모든 것에 사용할 수 있다고 생각합니다. 우리는 캔버스로 시작했지만, 희망적으로 다른 모든 가능한 사용 사례를 탐색할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n- 마케팅 및 광고: 캠페인, 소셜 미디어 게시물 및 광고를 위한 독특하고 화려한 시각물을 제작합니다.\n- 게임 개발: 컨셉 아트, 캐릭터 디자인 및 환경 텍스처를 생성합니다.\n- 패션 디자인: 원단을 위한 패턴과 프린트를 개발합니다.\n- 인테리어 디자인: 커스텀 이미지로 방 구성과 장식을 시각화합니다.\n- 교육: 설명적인 다이어그램과 창의적인 이미지로 학습 자료를 향상합니다.\n- 엔터테인먼트: 음악 앨범, 책 표지 및 프로모션 포스터를 위한 아트워크를 제작합니다.\n\n# 곧 만나요!\n\nTEV1을 계속 개발하고 개선하는 동안, 여러분은 여기에서 시도해보시고 피드백을 제공해 주시기 바랍니다. 웹 앱의 예상 출시일은 6월 말이니 조금만 기다려 주시고, 계속 영감을 얻어 주세요!\n\n“항상 할 수 있는 것이 있다” - \"Asycd\"\n","ogImage":{"url":"/assets/img/2024-05-23-TEV1RedefiningArtCreationwithAI-EnhancedThematicExploration_0.png"},"coverImage":"/assets/img/2024-05-23-TEV1RedefiningArtCreationwithAI-EnhancedThematicExploration_0.png","tag":["Tech"],"readingTime":5}],"page":"22","totalPageCount":68,"totalPageGroupCount":4,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true}