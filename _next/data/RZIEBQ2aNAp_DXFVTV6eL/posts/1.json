{"pageProps":{"posts":[{"title":"iOS 174는 예상 이상으로 매우 큽니다 - 놀라운 25가지 기능을 소개합니다","description":"","date":"2024-05-27 18:04","slug":"2024-05-27-iOS174IsWayBiggerThanWeveExpected25AmazingFeatures","content":"\n애플이 이렇게 슬퍼한 적이 없었어요.\n\n조석잃는 악몽 속에서도 어느 측면에서의 독점이 이토록 가혹하게 도전받을 줄은 애플도 상상조차 못했을 거예요.\n\niOS 17.4를 소개합니다. 개발자와 경쟁 업체들에게는 좋은 날이고, 애플에게는 안 좋은 날이랍니다.\n\niOS에 대한 상당히 중요한 (그리고 매우 필요한) 업데이트이지만, 일부 변경 사항은 애플이 즐거워하기 위해 한 게 아니라는 것을 알아두세요. 오히려 EU의 강제법률과 조치들을 준수하기 위한 것으로, 이는 바로 애플의 EU 기술에 대한 통제에 직접적인 타격을 입고 있어요.\n\n<div class=\"content-ad\"></div>\n\n그러나 Apple은 이점을 위해 뭔가를 했습니다. 현재, EU가 요구하는 기능은 EU 기반 아이폰에만 적용되며, 이는 전체 수익의 7%를 차지합니다. 대단한 아이디어네요.\n\n그래서 Apple은 세계의 다른 나라에서도 독점 노래를 부를 수 있습니다. 그리고 사람들은 그 맥락에서 멜로디를 즐겨 들을 지 여부와는 상관없이 그것을 듣는 다른 선택지가 없습니다.\n\n# 본문 내용\n\n유럽 특화 변화\n1 — 사이드로딩 활성화됨!\n2 — 기본 브라우저 변경을 위한 메시지 표시\n3 — 타사 브라우저 엔진 지원\n일반적인 변화\n새로운 메시지 변화\n4 — 16가지 새로운 이모티콘\n5 — 비즈니스용 메시지\n6 — Siri가 다양한 언어로 메시지를 읽을 수 있도록\n새로운 설정 변화\n7 — 도난 단말 보호에 대한 중요한 변경\n8 — 타사 앱을 위한 '접촉 및 NFC' 접근 권한\n9 — 새로운 지역 식별자\n새로운 사파리 변화\n10 — 넓은 탭 바\n11 — 웹 페이지에서 '모든 애니메이션 재생'\n새로운 팟캐스트 변화\n12 — 실시간 대본과 함께 팟캐스트 팔로우\n13 — 정보 보기를 위해 에피소드 이름 탭하기\n새로운 시계 변화\n14 — 새로운 시계 위젯\n15 — 스톱워치에 실시간 활동 기능 추가\n새로운 지갑 변화\n16 — Apple Card를 위한 가상 카드 번호 획득\n17 — 지갑 연결 향상\n새로운 CarPlay 변화 공개\n18 — 차를 끌 때 CarPlay가 작별인사\n19 — 새로운 CarPlay 앱 및 아이콘\n새로운 백엔드 변화\n20 — 게임 스트리밍이 이제 가능해짐\n21 — 케이블용 펌웨어 업데이트!?\n일관성을 위한 변화\n22 — 개선된 iCloud 아이콘\n23 — 책, 음악 및 팟캐스트를 위한 홈 섹션\n24 — Podcasts의 '현재 재생 중' 바가 Apple Music을 모방함\n새로운 기타 변화\n25 — HomePod 및 Apple TV로 SharePlay Music 공유\n26 — 앱 스토어에서 구매 기록\n27 — 독일어에서 Siri 호출 시 ‘Hey’ 삭제\n\n<div class=\"content-ad\"></div>\n\n# — EU-SPECIFIC CHANGES —\n\n# #1. Sideloading is active!\n\niOS에서 사이드 로딩이 시작되었습니다!\n— 이게 기술 역사상 가장 대단한 소식 중 하나 아닐까요?\n\n이 기능은 기존 앱 스토어 외 다른 원본에서 앱을 설치할 수 있는 기능입니다(대체 앱 마켓이라고도 함) — 예를 들어 Play Store, Amazon Appstore, 그리고 Setapp과 같은 곳에서 (iOS로 이동할지 여부는 확실하지 않지만, 감을 잡기 위해서 들어주었습니다).\n\n<div class=\"content-ad\"></div>\n\n(App Marketplace ≈ 다른 iOS 앱을 설치할 수 있는 iOS 앱)\n\n![iOS 174 매우 예상보다 더 크고 놀랍다는 25가지 멋진 기능 이미지](/assets/img/2024-05-27-iOS174IsWayBiggerThanWeveExpected25AmazingFeatures_0.png)\n\n이것은 애플의 본래 App Store 이외에 iPhone에서 여러 앱 스토어를 동시에 사용할 수 있는 것을 의미합니다.\n\n가장 좋은 점은 다른 앱 스토어를 기본 앱 스토어로 설정할 수 있다는 것입니다 — 기본 브라우저를 변경하는 것만큼 쉽게요.\n\n<div class=\"content-ad\"></div>\n\n그러나 애플은 개인 정보보호와 보안 서약에 따라 대체 앱 스토어에서 설치된 앱에 대한 악성 코드를 경고하고, 이에 해당하는 경우 해당 앱을 열지 못하도록 막을 것입니다.\n\n또한 부모님들이 자녀들이 대체 앱 스토어에서 앱을 설치할 수 있는지를 결정할 수 있는 새로운 'Screen Time' 설정이 있습니다.\n\n##2. 기본 브라우저 변경 프롬프트\n\n이것을 주목한 적이 있나요?\n기본 브라우저가 Safari인 경우, 설정 ⚙️ ` 같이 Safari가 아닌 브라우저를 활성화한 경우, 기본 브라우저를 변경할 수 있는 섹션이 표시됩니다.\n\n<div class=\"content-ad\"></div>\n\n하지만 이것은 브라우저인 사파리의 설정에서는 표시되지 않습니다. 이것도 브라우저인데 이상하네요...\n\n\n<img src=\"/assets/img/2024-05-27-iOS174IsWayBiggerThanWeveExpected25AmazingFeatures_1.png\" />\n\n\n하지만 기본 브라우저를 크롬, 파이어폭스 또는 사파리가 아닌 다른 브라우저로 변경하면 사파리 설정에서도 이 부분이 마법처럼 나타납니다.\n\n\n<img src=\"/assets/img/2024-05-27-iOS174IsWayBiggerThanWeveExpected25AmazingFeatures_2.png\" />\n\n\n<div class=\"content-ad\"></div>\n\n애플이 여러분이 Safari를 기본 브라우저로 유지하기를 원하는 정도입니다.\n\n하지만 안타깝게도 (애플에게는) EU의 지시에 따라, 이제 iOS 17.4로 업데이트된 후 Safari를 처음 열 때 사용자에게 기본 브라우저를 선택할 수 있는 옵션을 제공하는 프롬프트를 표시해야 합니다.\n\n![이미지](/assets/img/2024-05-27-iOS174IsWayBiggerThanWeveExpected25AmazingFeatures_3.png)\n\n표시되는 브라우저는 국가마다 다르며 각 사용자마다 무작위로 지정됩니다.\n\n<div class=\"content-ad\"></div>\n\n아이폰에 설치되어 있지 않아도 브라우저가 나타납니다. 브라우저를 기본 브라우저로 설정하려면 다운로드해야 합니다.\n\n# #3. 제 3자 브라우저 엔진 지원\n\n애플은 또한 제 3자 브라우저가 자체 브라우저 엔진을 사용할 수 있도록 허용합니다.\n\n```js\n브라우저 엔진이란?\n\n기본 HTML 문서를 아름다운 페이지로 변환하는 모든 브라우저의 핵심 구성 요소입니다.\n모든 브라우저는 속도와 추가 기능을 위해 자체 엔진을 개선할 수 있습니다.\n```\n\n<div class=\"content-ad\"></div>\n\nApple는 처음부터 iOS에서 여러 브라우저를 허용해 왔지만 엔진은 한 가지뿐이었습니다 - Webkit (Apple 고유). 다른 곳에서 Blink와 Gecko를 사용하는 Chrome과 Firefox조차도 iOS에서는 WebKit에 맞춰야 했습니다.\n\n이로 인해 타사 브라우저들이 많은 기능과 개선 사항을 가져오는 자유가 제한되었습니다.\n\n하지만 이제는 Apple이 iOS에서 WebKit 이외의 브라우저 엔진에 대해 관대해지고 있어서 EU 사용자들은 자신이 선호하는 브라우저에 더 많은 기능을 기대할 수 있습니다.\n\nApple은 iOS에서 엔진을 실행하기 전에 철저한 검사를 실시할 것이지만, 가장 인기 있는 엔진들이 대부분 허용될 것이라 확신합니다.\n\n<div class=\"content-ad\"></div>\n\n# — 일반적인 변경사항 —\n\n# • 새로운 메시지 변경사항\n\n## #4. 16개의 새 이모지\n\n새롭게 도입된 이모지 15.1 표준을 준수하는 애플의 16개의 새로운 이모지입니다. 이러한 것이 있습니다:\n\n<div class=\"content-ad\"></div>\n\n![image](/assets/img/2024-05-27-iOS174IsWayBiggerThanWeveExpected25AmazingFeatures_4.png)\n\n- 처음 두 줄에 있는 이모티콘들은 완전히 새로운 개념입니다.\n- 세 번째 줄에 있는 이모티콘들은 이전에 사용자가 왼쪽을 향하고 있던 이모티콘들의 새롭게 디자인된 버전입니다.\n- 네 번째 줄에 있는 이모티콘들은 👨‍👩‍👧‍👦와 같은 가족 이모티콘의 대체품입니다.\n\n모든 새로운 이모티콘들과 그 설명을 기사 끝에 복사해 두었습니다.\n\n## #5. 비즈니스 메시지\n\n<div class=\"content-ad\"></div>\n\n설정 ⚙️ ` 메시지 💬`에서 '비즈니스 및 개인 정보에 대한 메시지'라는 하이퍼링크가 있었어요.\n\n이제는 '비즈니스용 메시지'로 대체되었는데, 아직은 비어 있지만 나중에는 메시지를 보낸 비즈니스 및 해당 옵션을 담을 수 있을 것입니다.\n\n<img src=\"/assets/img/2024-05-27-iOS174IsWayBiggerThanWeveExpected25AmazingFeatures_5.png\" />\n\n## #6. Siri can read out messages in different languages\n\n<div class=\"content-ad\"></div>\n\n요즘 Siri가 메시지를 보내기 전에 확인을 요청하는 단계를 건너뛸 수 있다는 걸 알고 계셨나요?\n\n![이미지](/assets/img/2024-05-27-iOS174IsWayBiggerThanWeveExpected25AmazingFeatures_6.png)\n\n설정 ⚙️ ` Siri 및 검색`에서 ‘메시지 자동 전송’을 켜면 됩니다. 그러면 더 이상 매번 확인 부분을 보지 않아도 됩니다. 멋지죠!\n\n하지만 iOS 17.4에서는 해당 부분이 ‘Siri로 메시지 보내기’로 대체되었는데, 메시지 자동으로 전송하는 것 외에도 Siri가 메시지를 읽을 때 사용할 몇 가지 언어를 선택할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n아래는 Markdown 형식으로 테이블 태그를 변경했습니다.\n\n![이미지](/assets/img/2024-05-27-iOS174IsWayBiggerThanWeveExpected25AmazingFeatures_7.png)\n\n만약 국제적인 친구들이 여러 언어로 메시지를 주고받는다면 이것이 최선의 방법입니다. 여기에 설정하는 언어는 Siri의 주요 언어에 영향을 미치지 않습니다.\n\n# • 새로운 설정 변경\n\n## #7. 도난 방지 기능의 중요한 변경\n\n<div class=\"content-ad\"></div>\n\niOS 17.3의 \"The Stolen Device Protection\" 기능은 사용자의 개인 정보 보호와 보안을 위한 iOS의 훌륭한 새로운 추가입니다.\n\n이는 생체 인증 확인과 중요한 시스템 설정을 변경하려고 할 때 1시간의 지연을 설정합니다. 자세한 정보는 이 기사에서 확인하세요 →\n\n그러나 가정 또는 직장과 같이 익숙한 장소에 있는 경우에는 지연이 강제로 적용되지 않습니다. 익숙한 장소가 아니라면 이 둘 다 해야 합니다.\n\n하지만 iOS 17.4에서 Apple은 iPhone이 위치와 관계없이 1시간의 지연을 강제로 적용할 수 있는 유용한 기능을 가져왔습니다. (설정에서 조정하세요 ⚙️ `Face ID & Passcode 🙂` Stolen Device Protection)\n\n<div class=\"content-ad\"></div>\n\n\n![Image](/assets/img/2024-05-27-iOS174IsWayBiggerThanWeveExpected25AmazingFeatures_8.png)\n\n- Selecting 'Always' always implements a 1-hour delay.\n- Selecting 'Away from Familiar Locations' verifies the location before implementing the delay. If it is a familiar location, you can quickly access your critical settings after a Face ID check.\n\n## #8. Access to 'Contactless & NFC' for 3rd party apps\n\nThere is a new section called 'Contactless & NFC' in Settings ⚙️ Privacy & Security ✋.\n\n\n<div class=\"content-ad\"></div>\n\n\n![Image](/assets/img/2024-05-27-iOS174IsWayBiggerThanWeveExpected25AmazingFeatures_9.png)\n\nInside, it's empty for now — but it says:\n\nSo Apple’s allowing 3rd party apps to use iPhone's built-in NFC payments feature (for tap-to-pay or cardless POS machine payments).\n\nAnd in the EU, Apple allows users to select a 3rd-party contactless payment app as default — instead of Wallet. Cool, right?\n\n\n<div class=\"content-ad\"></div>\n\n## #9. 새로운 지역 식별자\n\n새로운 것이 나타났어요! 설정 ⚙️ `일반` ⚙️ 에서 닉네임으로 IDENTIFIABLE_REGION이라고 불리는 것이 있어요. 이 기능은 애플이 식별한 국가로 당신의 지역(나라)을 보여줍니다.\n\n![이미지](/assets/img/2024-05-27-iOS174IsWayBiggerThanWeveExpected25AmazingFeatures_10.png)\n\n지금은 이에 대한 정보가 없지만, 애플이 EU에 있는지 여부를 식별하여 EU 특정 기능에 액세스할 수 있도록 하는 방법일 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n자신이 EU에 있다고 청구 주소를 변경하거나 Apple ID 지역을 변경하거나 VPN을 사용하여 속이는 것은 불가능합니다. Apple은 이를 확인하기 위해 알 수 없는 강력한 방법을 사용하고 있습니다.\n\n## 새로운 Safari 변화\n\n### 10. 탭 바가 넓어졌어요\n\nSafari에서 탭 바를 사용하는 경우 (상단이 아닌 하단에 탭이 표시되는 경우), 이제 다소 넓어졌다는 차이를 발견할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n\n![Image 1](/assets/img/2024-05-27-iOS174IsWayBiggerThanWeveExpected25AmazingFeatures_11.png)\n\nI didn’t like it, but maybe it takes some time to get used to it.\n\n## #11. ‘Play All Animations’ in a webpage\n\n![Image 2](/assets/img/2024-05-27-iOS174IsWayBiggerThanWeveExpected25AmazingFeatures_12.png)\n\n\n<div class=\"content-ad\"></div>\n\n새로운 ‘모든 애니메이션 재생’ 옵션을 Safari에서 사용하면 한 번에 웹페이지의 모든 GIF 애니메이션을 재생할 수 있어요.\n\n# • 새로운 팟캐스트 변화\n\n## #12. 라이브 트랜스크립트와 함께 팟캐스트 따르기\n\n![이미지](/assets/img/2024-05-27-iOS174IsWayBiggerThanWeveExpected25AmazingFeatures_13.png)\n\n<div class=\"content-ad\"></div>\n\n팟캐스트를 좋아하는 사용자들이 영원히 사랑할 멋진 기능이에요.\n\n팟캐스트의 Apple Music 가사 버전과 같은 기능입니다. 이제 팟캐스트를 자막과 함께 따라 들을 수 있어요. 이를 보려면 왼쪽 하단의 자막 아이콘을 클릭하면 됩니다.\n\n그리고 더 좋은 점은, 자막에서 단어나 구절을 검색할 수 있다는 거예요. 가장 좋아하는 부분으로 건너뛰고 싶을 때 매우 유용하죠.\n\n## 13번. 에피소드 이름을 눌러 정보보기\n\n<div class=\"content-ad\"></div>\n\n이 기능이 정말 멋져요. — 이제 에피소드 이름을 탭하여 해당 정보 페이지로 이동할 수 있어요.\n\nApple이 아래에 표시된 것처럼 프롬프트를 통해 제안할 거에요.\n\n![image](/assets/img/2024-05-27-iOS174IsWayBiggerThanWeveExpected25AmazingFeatures_14.png)\n\n# • 새로운 시계 변경\n\n<div class=\"content-ad\"></div>\n\n## #14. 새 시계 위젯\n\n저희가 새로운 시계 위젯을 받았어요 — 'City Digital'이라고 이름 지었습니다:\n\n![City Digital](/assets/img/2024-05-27-iOS174IsWayBiggerThanWeveExpected25AmazingFeatures_15.png)\n\n이 위젯은 다른 모든 City 위젯들이 보여주는 정보를 보여줍니다 — 그러나 정사각형 모양이고 디지털 시간을 보여줍니다.\n\n<div class=\"content-ad\"></div>\n\n## #15. 스톱워치에 라이브 활동 추가\n\n알람 및 타이머는 이미 오랜 시간 동안 라이브 활동이 있어서 클록 앱을 여는 것 없이 제어하기 쉽게 되었습니다.\n\n이제 iOS 17.4에서 스톱워치도 그런 기능이 추가되었습니다. 다음은 어떻게 보이는지에 대한 설명입니다:\n\n<img src=\"/assets/img/2024-05-27-iOS174IsWayBiggerThanWeveExpected25AmazingFeatures_16.png\" />\n\n<div class=\"content-ad\"></div>\n\n# 새로운 지갑 변경 사항\n\n## #16. Apple Card를 위한 가상 카드 번호 가져오기\n\nApple Cash Card는 Apple Wallet에 좋은 추가입니다.\n\n아마도 당신이 친구나 가족으로부터 돈을 송금하고 받는 가장 간단한 방법일 것입니다. 또한 Apple Pay를 허용하는 상점에서 다른 선불 카드와 같이 사용할 수도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n하지만 Apple Pay를 받아들이지 않고 대신 카드 세부정보를 요청하는 상점/웹사이트는 어떻게 해야 하나요?\n\n걱정하지 마세요. iOS 17.4에서는 기존 가상 Apple Cash 카드를 위한 카드 번호, 만료일 및 보안 코드 세트를 생성할 수 있습니다.\n\n![이미지](/assets/img/2024-05-27-iOS174IsWayBiggerThanWeveExpected25AmazingFeatures_17.png)\n\n가장 좋은 점은,\n\n<div class=\"content-ad\"></div>\n\n- 카드 정보가 유출됐다고 의심된다면 언제든지 새로운 정보 세트를 생성할 수 있어요 — 이전 정보는 더 이상 사용할 수 없게 됩니다.\n- 업데이트된 카드 정보는 자동으로 Safari 자동완성에 저장돼요.\n- 보안 코드는 정기적으로 변경돼 안전을 보장해요.\n\n## #17. 지갑 연결 향상\n\n![이미지](/assets/img/2024-05-27-iOS174IsWayBiggerThanWeveExpected25AmazingFeatures_18.png)\n\n이것은 설정 ⚙️ `개인정보 및 보안 ✋` 분석 및 개선의 새로운 분석 옵션입니다.\n\n<div class=\"content-ad\"></div>\n\n만약 켜 놓으면, 계정 정보를 익명으로 Apple과 공유하여 연결된 계정 경험을 향상시킵니다.\n\n하지만 항상 제안하듯이, 분석을 끄면 배터리를 절약할 수 있어요.\n\n# • 새로운 CarPlay 변화 공개됐어요\n\nApple이 WWDC22에서 차세대 CarPlay를 미리 살펴보여주었고, 우리에게 2023년 말에 도착할 것을 기대하라고 말해주었어요. 그러나 우리가 기다리던 2023년이 이미 지났군요!\n\n<div class=\"content-ad\"></div>\n\n애플이 CarPlay 웹페이지를 업데이트하여 \"첫 번째 모델은 2024년 도착 예정\"이라고 말했습니다. 그리고 𝕏의 Aaron(@aaronp613)은 iOS 17.4 코드에서 새로운 아이콘과 애니메이션 중 일부를 찾아내었습니다.\n\n## #18. 차를 껐을 때 CarPlay이 작별 인사를 합니다\n\n차를 끌 때, iPhone이나 Mac이 부팅될 때 처럼 작별 인사 애니메이션을 볼 수 있습니다.\n\n![이미지](/assets/img/2024-05-27-iOS174IsWayBiggerThanWeveExpected25AmazingFeatures_19.png)\n\n<div class=\"content-ad\"></div>\n\n## #19. 새로운 CarPlay 앱 및 아이콘들\n\nAaron은 CarPlay 2.0에서 새로운 아이콘들을 발견했습니다. 𝕏에서 그의 전체 쓰레드를 확인해보세요:\n\n또한, MacRumors가 강조한 바에 따르면, 차세대 CarPlay에 추가될 여덟 가지 새로운 앱들이 있습니다:\n\n- Auto Settings: 페어링된 아이폰을 관리하고 차량 설정을 변경할 수 있습니다.\n- Car Camera: 차량의 후방 카메라 영상을 표시합니다.\n- Charge (전기차용): 배터리 잔량, 충전 상태, 완전히 충전될 때까지 남은 시간 등을 표시합니다.\n- Climate: 차량의 기후 제어를 조절할 수 있습니다 — AC 온도, 팬 속도, 시트 및 핸들 가열 등.\n- Closures: 문이 실수로 열려있는 경우 알림하고 차량의 경고 심볼을 표시합니다.\n- Media: FM 및 AM 라디오를 재생할 수 있으며, SiriusXM도 지원합니다. 그러나 SiriusXM이 위성을 통해 되는지 인터넷 제한이 되는지에 대해서는 확실하지 않습니다.\n- Tyre Pressure: 각 타이어의 공기압을 표시하고 고 또는 낮은 압력 및 펑크된 타이어 알림을 제공합니다.\n- Trips: 여행에 대한 평균 속도, 연료 또는 에너지 효율성, 소요 시간 및 이동 거리 등의 정보를 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n많은 인기 차 제조업체가 이미 자사의 자동차에 CarPlay 2.0을 도입하기로 약속한 상태입니다.\n\n- 새로운 백엔드 변경\n\n<div class=\"content-ad\"></div>\n\n## #20. 게임 스트리밍이 이제 가능합니다\n\n애플은 최근 개발자 기사에서 게임 스트리밍에 대해 이야기합니다. 다음과 같이 씁니다:\n\n```js\n게임 스트리밍이란 무엇인가요?\n게임을 원격 클라우드 서버에서 실행하고 게임의 비디오와 사운드를 사용자의 기기로 직접 전송하는 온라인 게임의 한 유형입니다.\n이를 통해 사용자는 강력한 네트워크 연결만 있다면 저전력 기기에서도 고사양 게임을 쉽게 플레이할 수 있습니다.\n```\n\n지금까지 iOS에서 게임 스트리밍은 브라우저를 통해 웹앱을 통해서만 이용할 수 있었는데, 이는 게임을 경험하기에 편안하거나 몰입할 수 있는 방법이 아니었습니다.\n\n<div class=\"content-ad\"></div>\n\n하지만이 변경으로 Xbox Cloud Gaming과 Nvidia GeForce NOW와 같은 서비스가 독립 앱으로 앱 스토어에 진입할 수 있게됩니다. 게이머들에게는 좋은 소식이에요.\n\n## #21. 케이블의 펌웨어 업데이트!?\n\nAaron이 보도한 바에 따르면, iOS 17.4의 코드에는 다음과 같은 케이블의 펌웨어 업데이트 지원이 추가되었다고 합니다:\n\n- USB-C 커넥터가 장착된 이어팟\n- USB-C에서 3.5mm 헤드폰 잭 어댑터\n\n<div class=\"content-ad\"></div>\n\n이건 놀랍군요! 제 예상을 뛰어넘는 애플의 행보네요. 이번 펌웨어 업데이트로 플로피 와이어까지 지원한다니요.\n\n각 업데이트마다 케이블의 음질과 데이터 전송의 향상을 기대해봐도 좋을 것 같아요.\n\n# • 일관성을 위한 변경사항\n\n## #22. 프로필링 아이콘 재구성\n\n<div class=\"content-ad\"></div>\n\nFiles 앱의 iCloud 아이콘이 업데이트되었어요.\n\n![Files App](/assets/img/2024-05-27-iOS174IsWayBiggerThanWeveExpected25AmazingFeatures_20.png)\n\n이제 그 아이콘은 투명해져, 맥 아이콘과 닮았어요. 이건 좋은 일이에요 — 이렇게 하면 모든 Apple OS에서 일관성을 유지할 수 있어요.\n\n## #23. 책, 음악, & 팟캐스트를 위한 홈 섹션\n\n<div class=\"content-ad\"></div>\n\n애플이 모든 주요 섹션인 Books, Music 및 Podcasts 앱의 이름을 '홈'으로 변경하였습니다. 이는 간결함과 일관성을 가져다 줍니다.\n\n예를 들어:\n\n- Books: Read Now → Home\n- Music & Podcasts: Listen Now → Home\n\n![이미지](/assets/img/2024-05-27-iOS174IsWayBiggerThanWeveExpected25AmazingFeatures_21.png)\n\n<div class=\"content-ad\"></div>\n\n## #24. 팟캐스트의 '재생 중' 바가 Apple Music을 모방합니다.\n\n또한, 팟캐스트 앱의 '재생 중' 바(하단에 위치)가 이제 Apple Music의 것과 비슷해졌습니다. 한 번 확인해보세요:\n\n이전에는:\n\n![이전 이미지](/assets/img/2024-05-27-iOS174IsWayBiggerThanWeveExpected25AmazingFeatures_22.png)\n\n<div class=\"content-ad\"></div>\n\n이제는:\n\n<img src=\"/assets/img/2024-05-27-iOS174IsWayBiggerThanWeveExpected25AmazingFeatures_23.png\" />\n\n# • 새로운 기타 변경 사항\n\n## #25. HomePod 및 Apple TV와 함께 SharePlay Music\n\n<div class=\"content-ad\"></div>\n\n당신은 이미 아시다시피 —\niOS 17부터는 친구나 가족과 함께 차 안에서 SharePlay 음악을 공유할 수 있습니다. 허가를 받은 사람은 Apple Music 구독이 활성화되어 있지 않아도 재생을 제어할 수 있습니다.\n\n이제 HomePod와 Apple TV에도 도착했습니다. 참가자를 추가하려면,\n\n- HomePod를 사용 중이라면, iPhone에서 아래에 있는 SharePlay 아이콘을 탭하여 참가자로 참여할 수 있는 QR 코드를 받으실 수 있습니다.\n\n![image](/assets/img/2024-05-27-iOS174IsWayBiggerThanWeveExpected25AmazingFeatures_24.png)\n\n<div class=\"content-ad\"></div>\n\n- Apple TV를 tvOS 17.4 업데이트와 함께 사용 중이라면, QR 코드를 Apple TV 화면에 바로 표시할 수 있어요.\n\n![image](/assets/img/2024-05-27-iOS174IsWayBiggerThanWeveExpected25AmazingFeatures_25.png)\n\n## #26. 앱 스토어의 구매 내역\n\n앱 스토어에서 이제 ‘구매 내역’이라는 새로운 섹션에서 모든 구매 내역을 전체로 확인할 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n위의 이미지를 확인하려면 앱 스토어를 열고 프로필을 클릭한 후, ‘구매 기록’을 클릭하세요.\n\n![image](/assets/img/2024-05-27-iOS174IsWayBiggerThanWeveExpected25AmazingFeatures_26.png)\n\n구매한 앱 및 게임(유료), 구독, 그리고 인앱 구매가 모두 포함돼 있습니다.\n\n또한 ‘구매한 항목’ 섹션이 이제 ‘앱’으로 이름이 변경됐습니다. 위의 이미지를 보세요. 그것이 첫 번째입니다.\n\n<div class=\"content-ad\"></div>\n\n## #27. 독일어로 Siri를 부를 때 \"Hey\" 제외하기\n\n이전에 Siri를 깨우기 위해 \"Hey Siri\"라고 말해야 했습니다. 그러나 iOS 17부터는 그것을 \"Siri\"로 간략화할 수 있는 옵션이 제공되었습니다.\n\n![이미지](/assets/img/2024-05-27-iOS174IsWayBiggerThanWeveExpected25AmazingFeatures_27.png)\n\n그러나 아직 모든 언어와 호환되지는 않습니다. iOS 17.4에서는 독일어가 호환 언어로 포함되었습니다.\n\n<div class=\"content-ad\"></div>\n\n아니오, iOS 17이 멋지지 않나요?\n\niOS 17의 280여 가지 이상의 새로운 기능: 컴필레이션 (항상 업데이트됨):\n\n마침내,\n\n새로운 iOS 및 Mac 앱을 탐험하는 것을 좋아한다면 (제가 그렇듯), Setapp에 가입해보세요. 매달 $9.99에 놀라운 앱 240여 개의 선별된 컬렉션에 액세스할 수 있습니다. 개별 구매 시 수백 달러가 드는 앱들이군요.\n\n<div class=\"content-ad\"></div>\n\n- 지금부터 여러분의 Setapp 여정을 시작할 때 제 제휴 링크를 사용해보세요! (30일 무료 이용 가능합니다)\n- 여기에서 Setapp에서 제가 추천하는 70가지 이상의 최고의 macOS 앱 목록을 무료로 받아보세요.\n\n새 이야기를 게시할 때마다 알림을 받고 싶으신 450명 이상의 다른 분들과 함께하세요!\n\n# 부록: 새로운 이모지 목록\n\n![2024-05-27-iOS174IsWayBiggerThanWeveExpected25AmazingFeatures_28.png](/assets/img/2024-05-27-iOS174IsWayBiggerThanWeveExpected25AmazingFeatures_28.png)\n\n<div class=\"content-ad\"></div>\n\n## 처음 두 줄의 이모지\n\n- 🙂↕️ — 세로로 머리 흔들기\n- 🙂↔️ — 가로로 머리 흔들기\n- ⛓️💥 — 깨진 사슬\n- 🍄🟫 — 갈색 버섯\n- 🍋🟩 — 라임\n- 🐦🔥 — 피닉스\n\n## 세 번째 줄의 이모지\n\n- 🚶➡️ — 오른쪽을 향한 걷는 사람\n- 🏃➡️ — 오른쪽을 향한 뛰는 사람\n- 🧎➡️ — 오른쪽을 향한 무릎 꿇은 사람\n- 🧑🦯➡️ — 오른쪽을 향한 백색 이동 보조 도구를 사용하는 사람\n- 🧑🦽➡️ — 오른쪽을 향한 수동 휠체어 이용자\n- 🧑🦼➡️ — 오른쪽을 향한 전동 휠체어 이용자\n\n<div class=\"content-ad\"></div>\n\n비슷한 여러 피부색과 성별을 나타내는 이모지가 더 있어요. Emojipedia에서 모두 확인해보세요.\n\n## 가족 이모지\n\n![Family emojis](/assets/img/2024-05-27-iOS174IsWayBiggerThanWeveExpected25AmazingFeatures_29.png)\n\n이 네 개의 이모지는 가족 이모지 세트를 대체해요.\n\n<div class=\"content-ad\"></div>\n\n다음은 사용할 수 있는 이모지 대체 목록입니다:\n\n- 🧑‍🧑‍🧒‍🧒 — 가족: 어른, 어른, 아이, 아이\n- 👨‍👨‍👧‍👦 — 두 아빠와 딸, 아들이 있는 가족\n- 👩‍👩‍👧‍👦 — 두 엄마와 딸, 아들이 있는 가족\n- 👨‍👩‍👧‍👦 — 엄마, 아빠, 딸, 아들이 있는 가족\n- 👨‍👨‍👦‍👦 — 두 아빠와 둘째와 막내 아들이 있는 가족\n- 👨‍👨‍👧‍👧 — 두 아빠와 둘째와 막내 딸이 있는 가족\n- 👩‍👩‍👦‍👦 — 두 엄마와 둘째와 막내 아들이 있는 가족\n- 👩‍👩‍👧‍👧 — 두 엄마와 둘째와 막내 딸이 있는 가족\n- 👨‍👩‍👦‍👦 — 엄마, 아빠, 둘째와 막내 아들이 있는 가족\n- 👨‍👩‍👧‍👧 — 엄마, 아빠, 둘째와 막내 딸이 있는 가족\n\n다음은 두 번째로 사용할 수 있는 이모지 목록입니다:\n\n- 👨‍👨‍👦 — 두 아빠와 아들이 있는 가족\n- 👨‍👨‍👧 — 두 아빠와 딸이 있는 가족\n- 👨‍👩‍👦 — 엄마, 아빠, 아들이 있는 가족\n- 👨‍👩‍👧 — 엄마, 아빠, 딸이 있는 가족\n- 👪 — 두 부모님과 아이가 있는 가족\n- 👩‍👩‍👦 — 두 엄마와 아들이 있는 가족\n- 👩‍👩‍👧 — 두 엄마와 딸이 있는 가족\n\n<div class=\"content-ad\"></div>\n\n세 번째 이모지가 바뀝니다:\n\n- 👩‍👦‍👦 — 어머니와 두 아들이 있는 가족\n- 👩‍👧‍👦 — 어머니, 딸, 아들이 있는 가족\n- 👩‍👧‍👧 — 어머니와 두 딸이 있는 가족\n- 👨‍👦‍👦 — 아버지와 두 아들이 있는 가족\n- 👨‍👧‍👦 — 아버지, 딸, 아들이 있는 가족\n- 👨‍👧‍👧 — 아버지와 두 딸이 있는 가족\n\n네 번째 이모지가 바뀝니다:\n\n- 👨‍👦 — 아버지와 아들이 있는 가족\n- 👨‍👧 — 아버지와 딸이 있는 가족\n- 👩‍👦 — 어머니와 아들이 있는 가족\n- 👩‍👧 — 어머니와 딸이 있는 가족\n","ogImage":{"url":"/assets/img/2024-05-27-iOS174IsWayBiggerThanWeveExpected25AmazingFeatures_0.png"},"coverImage":"/assets/img/2024-05-27-iOS174IsWayBiggerThanWeveExpected25AmazingFeatures_0.png","tag":["Tech"],"readingTime":17},{"title":"Swft Data로 SwiftUI 어플리케이션 개발하기","description":"","date":"2024-05-27 18:02","slug":"2024-05-27-BuildingSwiftUIApplicationswithSwiftData","content":"\n\n![Image](/assets/img/2024-05-27-BuildingSwiftUIApplicationswithSwiftData_0.png)\n\n# Swift UI는 Swift Data를 시작하는 가장 쉬운 방법입니다\n\n- Swift UI와의 완벽한 통합\n- 간편한 구성\n- 데이터 자동 가져오기 및 뷰 업데이트\n\n# Swift Data 소개\n\n\n<div class=\"content-ad\"></div>\n\n표를 마크다운 형식으로 변경해 주세요.\n\n<div class=\"content-ad\"></div>\n\n```kotlin\n@Model\nclass Category {\n\n  @Attribute(.unique) var name: String\n  var imageName: String\n\n  init(name: String,\n       imageName: String = \"rupeesign.circle\",\n       type: CategoryType) {\n    self.name = name\n    self.imageName = imageName\n  }\n\n}\n```\n\n## Using the model macro\n\nModifies all stored properties\n\n@Model\n\n\n\n<div class=\"content-ad\"></div>\n\n- 강력한 새로운 스위프트 매크로\n- 코드로 스키마 정의하기\n- 모델 유형에 스위프트 데이터 기능 추가하기\n\n속성을 어떻게 추론할지 제어합니다.\n\n@Attributes\n\n- 속성에서 추론된 속성\n- 기본 값 유형 지원\n- 구조체, 열거형, Codable 및 값 유형의 컬렉션과 같은 복잡한 값 유형의 지원\n\n<div class=\"content-ad\"></div>\n\n@관계\n\n- 관계는 참조 유형에서 유추됩니다.\n- 다른 모델 유형\n- 모델 유형의 컬렉션\n\n@Transient로 속성 제외\n\n더 많은 정보: Swift Data로 스키마 모델링하기 (WWDC 2023)\n\n<div class=\"content-ad\"></div>\n\n# 데이터 작업하기\n\n## 모델 컨테이너\n\n- 영속성 백엔드\n- 구성에 맞게 사용자 지정\n- 스키마 마이그레이션 옵션 제공\n\n```js\n.modelContainer(for: Category.self) { result in\n    // TODO: - 결과 처리\n}\n```\n\n<div class=\"content-ad\"></div>\n\n## 모델 컨텍스트\n\n- 업데이트 추적\n- 모델 가져오기\n- 변경 내용 저장\n- 변경 내용 취소\n\n![이미지](/assets/img/2024-05-27-BuildingSwiftUIApplicationswithSwiftData_1.png)\n\n더 많은 정보: SwiftData에 대한 깊은 탐구 (WWDC 2023)\n\n<div class=\"content-ad\"></div>\n\n# SwiftUI와 통합\n\nSwiftData는 SwiftUI를 염두에 두고 만들어졌으며 함께 사용하는 것이 더 쉽습니다.\n\n뷰 수정자\n\n- 씬 및 뷰 수정자 활용\n- .modelContainer로 데이터 구성\n- SwiftUI 환경 전체에 전파됨\n\n<div class=\"content-ad\"></div>\n\n@Query Property Wrapper\n\n```swift\n@Query var categories: [Category]\nvar body: some View {\n List(categories) { category in\n  NavigationLink(category.name, destination: CategoryView(category))\n }\n}\n```\n\nSwiftData와 SwiftUI가 함께 작동하여 기본 데이터가 변경될 때 뷰에 실시간 업데이트를 제공하며 결과를 수동으로 새로 고침할 필요가 없습니다.\n\n<div class=\"content-ad\"></div>\n\n변경 사항 관찰\n\n@Published를 사용할 필요가 없습니다. SwiftUI는 관찰 대상 속성을 자동으로 새로 고칩니다.\n\n추가 정보: SwiftData(WWDC 2023)를 활용하여 앱을 개발해보세요.\n\n# 자동 지속성\n\n<div class=\"content-ad\"></div>\n\nSwiftData는 사용자 모델로 사용자 지정 스키마를 빌드하고 효율적으로 필드를 기반 저장소에 매핑합니다. SwiftData가 관리하는 객체는 필요할 때 데이터베이스에서 가져오고 추가 작업없이 적절한 시점에 자동으로 저장됩니다. 또한 ModelContext API를 사용하여 완전한 제어를 할 수도 있습니다.\n\n# CloudKit 동기화\n\n데이터는 DocumentGroup을 사용하여 파일로 저장하고 iCloud Drive를 통해 동기화하거나 CloudKit을 사용하여 장치간 데이터 동기화를 할 수 있습니다.\n\n# Core Data와 호환 가능\n\n<div class=\"content-ad\"></div>\n\nSwiftData는 Core Data의 검증된 저장 아키텍처를 사용하므로 동일한 기본 저장소를 사용하여 동일한 앱에서 둘 다 사용할 수 있습니다. 준비가 되면 Xcode가 Core Data 모델을 SwiftData와 함께 사용할 클래스로 변환할 수 있습니다.\n\n# 참고:\n","ogImage":{"url":"/assets/img/2024-05-27-BuildingSwiftUIApplicationswithSwiftData_0.png"},"coverImage":"/assets/img/2024-05-27-BuildingSwiftUIApplicationswithSwiftData_0.png","tag":["Tech"],"readingTime":3},{"title":"iOS에서 Compose Multiplatform을 사용하는 앱 이제 베타 - 2024년 개발자 인사이트","description":"","date":"2024-05-27 18:00","slug":"2024-05-27-AppsusingComposeMultiplatformoniOSnowbetain2024developerinsights","content":"\n\nCompose Multiplatform for iOS가 오늘 공식적으로 베타로 승격되었어요, 하지만 기업들이 이미 장기간 생산에 성공적으로 사용하고 있어요! 몇몇 애플리케이션을 살펴보죠. iOS에서 Compose Multiplatform (비공식적으로 CMP로 약칭)를 사용한 경험을 설명해 달라고 여러 개발자들에게 물었더니 다음과 같은 이야기를 들었어요.\n\n이것은 2023년에 Kotlin Multiplatform(KMP)을 사용하는 인기 애플리케이션들을 따르는 다음 단계이며, (포브스와 볼트와 같은) 더 많은 애플리케이션이 가입했지만, 이 게시물에서는 사용자 인터페이스를 공유하는 애플리케이션에 중점을 두었어요.\n\n안드로이드와 iOS 버전 모두의 공개 애플리케이션에 대한 링크가 포함되어 있어요, 그래서 직접 시도해 볼 수 있어요(그리고 혹시 머티리얼 리플을 발견할 수 있을지도 😉).\n\n\n\n<div class=\"content-ad\"></div>\n\n# 인스타박스 (내부 앱)\n\n스웨덴 물류 회사 인스타박스의 개발자들은 수천 명의 사용자가 사용하는 내부 iOS 앱을 SwiftUI로 개발하기 시작했습니다. 그러나 iOS에서 실행되는 Compose 데모를 보고 프로토타입을 만들어 CTO에게 보여줬고, CTO가 좋아해서 계속해서 작업을 진행했습니다. 이미 Kotlin Multiplatform을 사용하여 앱을 구조화했기 때문에 그들은 단 두 주만에 프로토타입을 만들었습니다.\n\n2023년 8월 Talking Kotlin 팟캐스트 에피소드에서 개발자들은 CMP와 함께 작업하는 선택과 프로세스에 대해 설명했습니다. 개발자들은 KMP와 함께 네이티브 API가 간단하게 사용될 수 있고, \"그냥 [공통으로] 파일을 옮길 수 있다\"는 점이 Kotlin Multiplatform의 장점이라고 특히 만족하고 있습니다.\n\n인스타비 개발자 요한네스 스벤손\n\n<div class=\"content-ad\"></div>\n\nKotlinConf 2024에서 \"Compose Multiplatform on mobile at Instabee for over a year\"이라는 주제로 발표가 있을 예정입니다. 녹화가 준비되면 이 기사를 업데이트하겠습니다.\n\n스스로 다시 써야 했던 가장 큰 것은 탐색이었습니다. 그 당시에는 아직 멀티플랫폼이 아니었지만, 주요 개발자인 Johannes는 현재 멀티플랫폼 Compose Navigation을 곧 채택할 것으로 말했습니다. 현재 앱은 일부 커스텀 코드(예: 백 제스처 처리)와 함께 Voyager를 사용하여 탐색 중입니다.\n\n# Markaz (1M+)\n\n![이미지](/assets/img/2024-05-27-AppsusingComposeMultiplatformoniOSnowbetain2024developerinsights_1.png)\n\n<div class=\"content-ad\"></div>\n\n이 앱을 통해 사용자들은 온라인으로 제품을 구매하고 판매할 수 있어요. 비즈니스 로직부터 UI까지 Kotlin 코드를 공유해요. 이 앱은 파키스탄 시장을 대상으로 하고 있기 때문에 모든 국가에서 이용 가능하지 않을 수 있어요. 최근 업데이트에서는 iOS의 백 스와이프 제스처가 추가되었어요. 또한, Compose Multiplatorm에서 기본적으로 제공되는 iOS 룩 앤 필을 통해 네이티브 스크롤링과 같은 기능을 사용할 수 있어요.\n\n마르카즈(Markaz) 개발자 카시프(Me\\nhmood)\n\nApp Store: https://apps.apple.com/pk/app/markaz-resell-and-earn-money/id6470020517 Play Store: https://play.google.com/store/apps/details?id=com.markaz.app\n\n# Wrike (1M+)\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-05-27-AppsusingComposeMultiplatformoniOSnowbetain2024developerinsights_2.png\" />\n\n오늘 KotlinConf에서 발표된 소식입니다: Wrike가 iOS에서 앱의 캘린더 부분에 Compose를 사용하고 있습니다. 리드 개발자는 키노트 비디오에서 다음과 같이 말했습니다 (게시물 맨 아래에 링크가 있습니다):\n\nWrike 기술 담당자 Alex Askerov\n\nApp Store: [여기를 클릭하여 App Store에서 확인하세요](https://apps.apple.com/ms/app/wrike-work-as-one/id890048871)\nPlay Store: [여기를 클릭하여 Play Store에서 확인하세요](https://play.google.com/store/apps/details?id=com.wrike)\n\n<div class=\"content-ad\"></div>\n\n## Campus (100K+)\n\n![Campus app](/assets/img/2024-05-27-AppsusingComposeMultiplatformoniOSnowbetain2024developerinsights_3.png)\n\n캠퍼스 - 수업 일정 (원래 이름: Кампус - Расписание занятий)은 대학생들을 위한 앱으로, 수업 일정을 추적하는 데 사용됩니다. 이 앱은 주로 네이티브이지만 \"과목\" 섹션(앱의 두 번째 탭)에서 Compose Multiplatform을 사용합니다. 개발자는 2023년 중반 CMP를 통합했는데, 이는 알파 상태에 도달한 직후입니다.\n\nIceRock (캠퍼스 개발자)의 CTO인 Aleksey Mikhailov\n\n<div class=\"content-ad\"></div>\n\n앱 스토어: [https://apps.apple.com/ru/app/кампус-расписание-занятий/id1534975833](https://apps.apple.com/ru/app/кампус-расписание-занятий/id1534975833)  \n플레이 스토어: [https://play.google.com/store/apps/details?id=ru.dewish.campus](https://play.google.com/store/apps/details?id=ru.dewish.campus)\n\n# Ashampoo Photo Organizer (예정)\n\n![이미지](/assets/img/2024-05-27-AppsusingComposeMultiplatformoniOSnowbetain2024developerinsights_4.png)\n\nAshampoo Photos의 iOS 첫 버전은 SwiftUI로 작성되었습니다. Compose Multiplatform이 사용 가능해지자 개발자는 개발 방향을 변경했습니다. 현재 작성 중인 이 포스트에서 새 버전은 Compose UI로 구축되어 테스트 중이며 아직 사용할 수 없습니다. 그러나 Compose Multiplatform이 모바일 플랫폼뿐만 아니라 Windows(그리고 곧 MacOS)에서도 실행되므로 소프트웨어를 [여기](https://www.ashampoo.com/photo-organizer)에서 사용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n아샴푸 개발자 Stefan Oltmann님\n\n앱스토어: 곧 공개 예정\n플레이 스토어: https://play.google.com/store/apps/details?id=com.ashampoo.photos\n\n# 오픈 소스: KotlinConf (5천 명 이상), Twine RSS Reader (1만 명 이상) 및 FindTravelNow\n\n이 목록의 마지막 세 개의 앱은 오픈 소스입니다! 정확히 어떻게 구축되었는지 궁금하다면 꼭 확인해보세요. 먼저 공식 KotlinConf 앱부터 차례로 살펴보겠습니다!\n\n<div class=\"content-ad\"></div>\n\n![image](/assets/img/2024-05-27-AppsusingComposeMultiplatformoniOSnowbetain2024developerinsights_5.png)\n\nKotlinConf  \nApp Store: [link](https://apps.apple.com/us/app/kotlinconf/id1299196584)  \nPlay Store: [link](https://play.google.com/store/apps/details?id=com.jetbrains.kotlinconf)  \nSource code: [link](https://github.com/JetBrains/kotlinconf-app)\n\nThen Twine, which is an RSS reader with 10K+ downloads:\n\n![image](/assets/img/2024-05-27-AppsusingComposeMultiplatformoniOSnowbetain2024developerinsights_6.png)\n\n<div class=\"content-ad\"></div>\n\nTwine — RSS 리더\n앱 스토어: [링크](https://apps.apple.com/us/app/twine-rss-reader/id6465694958)\n플레이 스토어: [링크](https://play.google.com/store/apps/details?id=dev.sasikanth.rss.reader)\n소스 코드: [링크](https://github.com/msasikanth/twine)\n\n그리고 마지막으로, FindTravelNow은 전 세계에서 저렴한 항공권을 찾기 위한 \"메타서치 여행 애플리케이션\"입니다:\n\n![이미지](/assets/img/2024-05-27-AppsusingComposeMultiplatformoniOSnowbetain2024developerinsights_7.png)\n\nFindTravelNow\n앱 스토어: [링크](https://apps.apple.com/gr/app/findtravelnow/id6471192930)\n플레이 스토어: [링크]https://play.google.com/store/apps/details?id=com.travelapp.findtravelnow)\n소스 코드: [링크](https://github.com/mirzemehdi/FindTravelNow-KMM)\n\n<div class=\"content-ad\"></div>\n\n# 마무리\n\n이 라운드업이 크로스 플랫폼 개발로 나아가고 싶어하는 분들에게 영감을 주기를 바랍니다. 일반적으로 Kotlin Multiplatform처럼, 만약 시도해보고 중단하려고 한다면 멀티플랫폼 부분을 더 나아가지 않기로 결정해도 항상 작동하는 현대적인 Android 앱을 가지고 계실 것입니다.\n\n시작하는 방법에 대한 더 많은 정보를 얻으려면 JetBrains 사이트를 확인해보세요: https://www.jetbrains.com/lp/compose-multiplatform/ 그리고 오늘의 KotlinConf 키노트에서 Compose iOS 베타 발표를 확인해보세요.\n\n이 기사의 핵심 개발자 및 커뮤니티에 유용한 정보를 제공해 준 분들에게 특별히 감사드립니다 🚀.\n","ogImage":{"url":"/assets/img/2024-05-27-AppsusingComposeMultiplatformoniOSnowbetain2024developerinsights_0.png"},"coverImage":"/assets/img/2024-05-27-AppsusingComposeMultiplatformoniOSnowbetain2024developerinsights_0.png","tag":["Tech"],"readingTime":6},{"title":"배터리 사가, 아이폰15 프로 맥스","description":"","date":"2024-05-27 17:58","slug":"2024-05-27-ThebatterysagatheiPhone15ProMax","content":"\n\n![2024-05-27-ThebatterysagatheiPhone15ProMax_0.png](/assets/img/2024-05-27-ThebatterysagatheiPhone15ProMax_0.png)\n\n# 또 다른 하루 또 다른 이야기\n\n나와 내 iPhone 15 Pro Max에게는 이상한 한 주가 지났어요.\n\n나에게는 이번 주에 두 번 모험했습니다! 나 자신을 은둔자로 묘사하려는 것이 아닌데, 본성상 나는 외로운 사람이라서 이 콘텐츠 창작 일은 나에게 완벽해요. 스스로 쓰고 편집하는 데 많은 시간을 보낼 수 있지만, 그로 인해 자리에 머무르는 습관을 낳아요. 올해 스튜디오에서 너무 멀리 나가지 않았다는 것을 깨달았기 때문에, 이번 주에는 그것을 바꾸고 살짝 변화를 주기로 결정했어요.\n\n\n<div class=\"content-ad\"></div>\n\n일자별 계획은 콘텐츠 중심으로 구성되어 있었고, 주로 iPhone 15 Pro Max에 많이 의존했습니다. 정기적으로 저를 읽는다면 삼성 S24 울트라를 구매할 생각이 있었음을 아실 것입니다. 그 제품에 흥미를 느꼈지만, 무엇보다도 콘텐츠가 필요했기 때문에 그 제품을 더욱 탐내게 되었습니다!\n\n하지만 그때에 깨달았죠. 제게 가장 소중한 것, 즉 내가 가장 즐기는 것에 집중하라는 것을요 - 바로 내 iPhone 15 Pro Max에요.\n\n작년 안드로이드를 살펴보고 사용한 후, 그것이 나에게 충분하지 않다는 것을 알았어요. 나는 결코 아이폰 사용자이며, 이번에 사용 중인 아이폰은 내가 사용하고 소유한 제품 중 최고의 제품이라고 생각해요. 늘 이 제품을 적극 지지해 왔죠. 그래서 거의 6개월이 지난 이번 주에는 이 제품과 함께 몇 마일을 달려보기로 결정했어요.\n\n이번 주 초에는 윈저, 이튼, 배터시를 방문했고, 오늘은... 오늘은 저는 런던의 웨스트 엔드에서 막 돌아왔습니다. 수도시 거리를 돌아다니며 보낸 멋진 날이었고, 애플 대리점 두 곳 - 애플 리젠트 스트리트와 애플 나이츠브리지 두 곳도 방문한 날이었답니다.\n\n<div class=\"content-ad\"></div>\n\n![iPhone 15 Pro Max](/assets/img/2024-05-27-ThebatterysagatheiPhone15ProMax_1.png)\n\n# 아이폰 15 Pro Max - 프로일까요?\n\n오늘의 여행은 배터리 수명에 집중하기로 한 것이었습니다.\n\n이번 주 초에 우연히 배터리가 주인공이 되었습니다. 그 날은 그저 멋진 비디오와 사진 몇 장을 찍기 위해 나갔는데 — 제가 한 것 같다고 생각합니다. 그러나 집에서 8시간을 벗어나서 폰을 그 의도대로 사용한 결과, 결국 집에 왔을 때 배터리가 거의 다 닳아 있었습니다. 저는 20%만 남았죠.\n\n<div class=\"content-ad\"></div>\n\nPro Max모델은 iPhone 중에서 가장 큰 배터리를 가지고 있어서 Pro라 불리며, 프로 작업을 수행할 수 있다는 의미입니다.\n\n지난 주에 운이 없었을 수도 있겠다 싶었는데, 오늘은 다시 확인해보기로 했습니다. 그때 그때일까요, 아니면 이것이 정상인가요? iPhone 15 Pro Max에서 기대해도 되는 성능인가요?\n\n![이미지](/assets/img/2024-05-27-ThebatterysagatheiPhone15ProMax_2.png)\n\n# 계속해서 이어짐\n\n<div class=\"content-ad\"></div>\n\n저번 여행 이야기를 쓴 후 누군가가 전력 소비 데이터를 살펴보라고 제안해주었어요! 정말 좋은 조언이었어요 — 감사합니다!\n\n가장 많은 전력을 사용한 것은 카메라 (당연한 일이겠지만!)으로 25%였고, 사진은 20%를 차지했어요 (찍은 사진을 확인하고 보는 동안이겠죠) 그리고 이상하게도 홈 & 잠금 화면이 14%를 차지했어요. 아마 정말 어리석은 말을 하는 것 같지만... 잠금 화면이 전원을 그래서 소모하는 건 어떻게 된 일일까요 — 아마 항상 켜진 디스플레이 기능을 켜 둔 것 때문이겠죠...\n\n저는 오전 11시 이전에 99%의 배터리로 집을 떠났어요 — 오늘은 분명 더 나은 결과를 얻을 수 있을 거예요...\n\n<div class=\"content-ad\"></div>\n\n# 너무 가까워\n\n나는 항상 내가 살고 있는 곳과 런던이 얼마나 가까운지를 잊곤 해요.\n\n모터웨이를 한 시간 운전해서 가니, 가장 흥겹고 활기찬 도시 중 하나에 도착했어요.\n\n차에서 내려서 iPhone으로 사진을 찍기 시작했어요. Mac의 사진 앱을 보니 오늘은 200장 가까운 사진과 영상을 찍은 것 같아요. 어디를 바라보아도 또 다른 사진 촬영 기회가 있었어요.\n\n<div class=\"content-ad\"></div>\n\n\n![The Battery Saga - the iPhone 15 Pro Max](/assets/img/2024-05-27-ThebatterysagatheiPhone15ProMax_4.png)\n\n# 일에 착수하기\n\n주요 광각 24mm 렌즈의 모든 초점 거리를 시험해보기로 했다. 일주일 전에 이를 조사하기 시작했지만, 런던의 모든 명소를 둘러보면서 정말 카메라를 즐길 수 있을 것이라고 생각했다.\n\n아래에 유명한 피카딜리 서커스 광고판의 몇 장의 사진이 있다. 첫 번째 사진은 1배 확대 24mm로 촬영한 것이고, 두 번째 사진은 5배 확대 120mm로 촬영한 것이다. 이미지를 200%로 확대해도 매우 많은 선명함이 유지되며, 점이 놀랍게 날카로운 것을 알 수 있다.\n\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-05-27-ThebatterysagatheiPhone15ProMax_5.png)\n\n![이미지](/assets/img/2024-05-27-ThebatterysagatheiPhone15ProMax_6.png)\n\n집을 나온 지 4시간이 조금 넘었는데 배터리 상태가 54%로 괜찮았어요. 하지만 이번 주에 배우게 된 것으로 보아 이 부분이 중요한 전환점인 것 같아요. 약 50% 정도까지 괜찮아 보이다가 부터 뚝 떨어지기 시작합니다. 오늘 하루 배터리 상태를 맹수처럼 살펴봐야겠어요.\n\n![이미지](/assets/img/2024-05-27-ThebatterysagatheiPhone15ProMax_7.png)\n\n<div class=\"content-ad\"></div>\n\n이번 주까지는 5배 줌 기능을 많이 사용하지 않았어요. 일상생활에서는 별로 필요 없는데, 오늘 같은 날에는 정말 그 밋밋함에서 벗어나야 할 때입니다. 첫 번째 1배 24mm 샷으로 내가 얼마나 떨어져 있었는지 조금 감을 잡을 수 있어요. RAF 폭격기 기억비의 뾰족한 봉우리를 5배 줌으로 얼마나 잘 찾아냈는지 볼 수 있죠. 인상적네요.\n\n![이미지](/assets/img/2024-05-27-ThebatterysagatheiPhone15ProMax_8.png)\n\n![이미지](/assets/img/2024-05-27-ThebatterysagatheiPhone15ProMax_9.png)\n\n이번 주 런던에서 시험해보지 못한 것 중 하나는 120mm 렌즈의 디지털 줌 기능이었어요. 기억하세요, 저는 5배 줌 초심자라구요!\n\n<div class=\"content-ad\"></div>\n\n![2024-05-27-ThebatterysagatheiPhone15ProMax_10.png](/assets/img/2024-05-27-ThebatterysagatheiPhone15ProMax_10.png)\n\n![2024-05-27-ThebatterysagatheiPhone15ProMax_11.png](/assets/img/2024-05-27-ThebatterysagatheiPhone15ProMax_11.png)\n\n여기서 문제가 시작됩니다.\n\n사과 로고 주변에는 120mm에서도 조리개 ƒ2.8/80 ISO, 셔터 속도 1/100으로 심하게 고스트링이 나타납니다. 하지만 400mm까지 확대하면 (ƒ2.8/ 50 ISO) 사용할 수 없을 정도로 심해집니다 — 이때의 셔터 속도는 이제 1/148이었습니다.\n\n<div class=\"content-ad\"></div>\n\n제가 다른 이야기에서 언급했지만, iPhone의 배경에서 행해지는 기기 내 계산 보정을 살펴볼 때 메타데이터에 흥미로워하곤 합니다. 사진을 촬영할 때마다 올바른 설정을 계산해 주는데, 이것에 대해 우리는 한 번도 생각해보지 않았습니다. 그 결과는 대체로 훌륭합니다. 메인 24mm 카메라의 세 개의 초점 거리는 특히 인상적합니다.\n\n오늘은 드디어 롱 노출 설정과 함께 놀아보는 것을 기억했어요. 이에 대해 많은 통제권이 없어 보이지만, 얻게 되는 것이 전부입니다. 하지만 이것으로 재미있는 시간을 가질 수 있을 것 같아요. 아, 그리고 루프 비디오로 변환할 수도 있어서 정말 멋진 효과를 줄 수 있어요...\n\n![이미지](/assets/img/2024-05-27-ThebatterysagatheiPhone15ProMax_12.png)\n\n# 최종 생각\n\n<div class=\"content-ad\"></div>\n\niPhone 15 Pro Max를 정말 탐험하기 시작한 시간을 가졌어서 기뻐요. S24 Ultra를 사서 빠르고 싸게 클릭만 하는 것이 아니라 이미 가지고 있는 것에 더 투자해봤어요.\n\n활동적으로 즐거운 경험이었어요 — 밖으로 나가서 즐기는 것 뿐만 아니라 창작자로서의 자아를 발견하는 것도요. 이번 주까지는 대중 앞에서 녹화하는 걸 싫어했는데, 이제는 그것이 직업의 일부인 것 같다는 생각이 들어요.\n\n또한 iPhone에 대해 더 깊이 알아가는 것 또한 즐거웠어요. 6개월 동안 주머니 안에 넣어두었는데, 이제야 시작해서 무엇이 가능한지 알아가기 시작한 것 같아요. 어떻게 이런 것들에 대해 몰랐을까요?\n\n하지만...그 모든 좋은 점들에도 아직은 오래 지속되는 걱정이 있어요. 지난 주에 두 번이나 Pro Max를 이용해 보았는데, 두 번 모두 거의 하루를 버텨내지 못했네요. 그 50% 문제가 실재하는 것 같아요. 약 2시간 만에 54%에서 17%로 떨어지는 것을 볼 수 있어요. 그리고 그 동안 중 일부 시간 동안 iPhone은 차 안에 있어서 음악을 스트리밍 할 뿐이었어요.\n\n<div class=\"content-ad\"></div>\n\n그래도 배터리 문제는 한쪽에 두고 — 이제 내 15 Pro Max에서 정말 많은 것을 얻고 있는 느낌을 받고 있고, 정말 즐기고 있어요.\n\n200개가 넘는 생산성 앱을 한 곳에서 쉽게 확인해 보고 싶다면 SetApp을 확인해보세요. 정말 멋지답니다 — 매월 한 번의 요금으로 Bartender, CleanShot X, Paste, iStat Menus, BetterTouchTool과 같이 멋진 앱을 고를 수 있어요. 한 번 시도해보고 30일 무료 사용해 보고 싶다면 제 제휴 링크를 클릭해서 살펴보세요. 어떤 앱이 제일 마음에 드는지 알려주세요.\n\n2024년 2월 18일에 https://talkingtechandaudio.com에서 최초 게시된 글입니다.\n","ogImage":{"url":"/assets/img/2024-05-27-ThebatterysagatheiPhone15ProMax_0.png"},"coverImage":"/assets/img/2024-05-27-ThebatterysagatheiPhone15ProMax_0.png","tag":["Tech"],"readingTime":6},{"title":"일곱 가지 데모로 이해하는 코루틴 스코프, 컨텍스트 및 작업","description":"","date":"2024-05-27 17:54","slug":"2024-05-27-SevendemostounderstandcoroutinesscopecontextandJobs","content":"\n\n코루틴을 이해하는 것은 패턴을 배우는 것이 아니라 구동 원리를 보는 것에서 나옵니다.\n\n저번 포스트에서 안드로이드의 일반적인 코루틴 패턴을 해체하여 그 원리를 살펴보았습니다. 우리가 파고들수록, 모든 것을 가로지르는 세 가지 개념인 context, scopes, 그리고 Job이 있는 것을 보게 되었습니다.\n\n그래서, 코루틴이 무엇이며, 올바르게 활용하는 데 중요한 열쇠라고 생각됩니다.\n\n이를 염두에 두고, 그 세 가지를 살펴볼까요? 함께 재미있게 알아봅시다. 😉\n\n<div class=\"content-ad\"></div>\n\n(* 약간의 유머가 있었어요)\n\n# 데모 1: 코루틴을 실행하고 잊어버리기\n\n코루틴 스코프는 코루틴을 넣는 상자입니다. 그들을 제한하는 목적으로 존재합니다.\n\n코루틴을 취소하고 싶을 때 유용함을 알 수 있습니다 — 그냥 상자를 파괴하면, 상자 안의 모든 코루틴이 취소됩니다. 이것은 훌륭한 기능입니다. 왜냐하면 코루틴을 계속 추적할 필요가 없다는 것을 의미합니다. 그들의 생명주기는 \"상자\"에 의해 관리됩니다.\n\n<div class=\"content-ad\"></div>\n\n구체적인 예를 들어보겠습니다. 아래는 클릭할 때 배경색이 변경되는 버튼입니다:\n\n![button](https://miro.medium.com/v2/resize:fit:1200/1*Xb48gAvABkH5LBhRstBB_g.gif)\n\n이전 글에서 while(true)이 안전한 이유에 대해 설명했습니다. 다른 상황에서는 끔찍한 상황이겠지만요. 하지만 더 흥미로운 부분이 있는데요!\n\n...바로 이겁니다: 9번 라인에서 코루틴을 간단히 실행시켰는데, 그냥 넘어갔습니다. 왜냐하면 해당 스코프에 안전하게 실행시켰기 때문입니다. 이 경우 rememberCoroutineScope()를 사용해 스코프를 얻었습니다. RandomColourButton이 화면에서 제거되면 해당 스코프가 취소되며 실행된 코루틴도 취소됩니다.\n\n<div class=\"content-ad\"></div>\n\n환경에서 스레드만 있는 개발자에게 온다면, 코루틴이 얼마나 큰 진전인지 과장할 수 없을 정도로 중요합니다. 스레드를 시작하고 그냥 두는 것은 상상도 못할 정도로 중요하지요. 모두를 꼼꼼하게 추적해야 하며, 이를 제대로 처리하지 않으면 이상한 버그와 자원 누수가 발생할 수 있습니다.\n\n# 데모 2: launch()된 코루틴 취소하기\n\n위 코드에서처럼 scope.launch '...'로 코루틴을 시작할 때, 실행 중인 코루틴을 나타내는 Job이 생성됩니다.\n\nJob.cancel()을 사용하여 해당 코루틴을 취소할 수 있습니다 (부모 스코프나 그 안의 다른 코루틴에는 영향을 주지 않음).\n\n<div class=\"content-ad\"></div>\n\n위의 코드로 인해 번쩍이는 버튼이 2초 후에 번쩍임이 멈춥니다. 첫 번째 coroutine의 Job을 저장하고, 지연 후에 이를 취소하기 위해 두 번째 coroutine을 시작합니다.\n\n# 데모 3: coroutine 내에서 coroutine 시작하기\n\nJob은 하위 Job을 가질 수도 있습니다. 하위 Job을 만드는 간단한 방법은 단순히 coroutine 내에서 'launch'를 사용하는 것입니다.\n\nJob이 취소되면 모든 하위 Job들도 함께 취소됩니다. 번쩍이는 버튼을 사용하여 해당 예제를 살펴보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n이번에는 카운트를 증가시키는 또 다른 코루틴을 추가했습니다:\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1200/1*ESBEwgreP7EpxnqXm4cF9A.gif\" />\n\n랜덤 색상을 선택하는 코루틴의 자식으로 증가하는 카운트를 세는 코루틴이 시작됩니다:\n\n번쩍임이 멈추면 카운트도 멈추는 것을 주목해보세요. 이는 12번 줄에서 시작된 코루틴이 10번 줄에서 시작된 코루틴의 자식이기 때문입니다. 부모가 지연 후에 취소되면 자식도 함께 취소됩니다.\n\n<div class=\"content-ad\"></div>\n\n코루틴의 세계에서, 이 부모-자식 관계를 규제하는 법칙들(코루틴을 잃어버리지 않도록 보장하는 동일한 법칙들)은 구조화된 동시성이라고 합니다.\n\n# 데모 4: 컨텍스트에서 코루틴을 실행하고 작업을 지정하는 방법\n\nJob에 코루틴을 실행할 다른 방법도 있습니다. launch 또는 async 호출에서 Job을 지정할 수 있습니다:\n\n```js\nlaunch(myJob) {\n  ...\n}\n```\n\n<div class=\"content-ad\"></div>\n\n당연히 이 작업은 당신에게 달려 있습니다. 필요할 때 myJob을 주의 깊게 추적하여 이 코루틴의 생명 주기를 올바르게 제한해야 합니다.\n\n이것이 동작하는 이유는 launch에 전달하는 인수가 CoroutineContext이며, 그 중에 job이 있는 요소이기 때문입니다.\n\n코루틴 컨텍스트는 코루틴에 대한 메타데이터의 집합에 불과합니다. 이는 해당 코루틴에 대한 Job, 이름 및 디스패처를 포함합니다. 이는 코루틴이 어떻게 실행될지 코루틴 라이브러리에 설명하는 코루틴에 부착된 수하물 태그로 생각할 수 있습니다.\n\n# 데모 5: 다른 스레드 풀로 코루틴 시작하기\n\n<div class=\"content-ad\"></div>\n\n\"‘luggage tags’ 중 하나인 이 메타데이터는 코루틴에 첨부됩니다. 디스패처는 코루틴이 실행될 스레드나 스레드 풀을 결정하기 위해 사용됩니다.\n\n따라서 위와 같은 방법을 사용하여 IO 디스패처의 스레드 풀에서 코루틴을 시작할 수 있습니다:\n\n```js\nlaunch(Dispatchers.IO) {\n  ...\n}\n```\n\n이는 디스패처를 Dispatchers.IO로 설정하는 코루틴 콘텍스트를 생성함으로써 작동합니다.\"\n\n<div class=\"content-ad\"></div>\n\n# 데모 6: 기타 코루틴 시작 옵션 (및 조합)\n\n또는, 코루틴 컨텍스트의 요소를 더하여 plus 연산자를 사용할 수 있습니다. 다음은 \"boo\"라는 코루틴을 IO 디스패처 스레드 풀에 새 작업으로 시작하는 방법입니다:\n\n```js\nlaunch(Dispatchers.IO + Job() + CoroutineName(\"boo\")) {\n  ...\n}\n```\n\n이 방법으로 코루틴 컨텍스트를 생성할 때 언급하지 않은 요소는 부모의 컨텍스트에서 상속됩니다. 즉, Dispatchers.IO에서 실행 중인 코루틴에서 Job()을 시작하면 시작된 하위 코루틴도 Dispatchers.IO에서 실행됩니다. 이는 하위 코루틴의 컨텍스트 디스패처가 부모로부터 상속되었기 때문입니다.\n\n<div class=\"content-ad\"></div>\n\n# 데모 7: 코루틴 스코프 사용하기 — 그리고 그로 인해 발생하는 일들\n\n지금까지 확인한 내용은 다음과 같습니다:\n\n- 데모 1: 코루틴 스코프는 코루틴을 넣을 수 있는 수명 제한 컨테이너입니다.\n- 데모 3: 코루틴 Job은 코루틴을 넣을 수 있는 수명 제한 컨테이너입니다.\n\n음. 그럼 차이는 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\n사실, 차이가 없다는 것을 발견했습니다. 왜냐하면:\n\n...코루틴 라이브러리 코드에서 볼 수 있듯이:\n\n```js\npublic interface CoroutineScope {\n    public val coroutineContext: CoroutineContext\n}\n```\n\n그럼에도 불구하고, 본질적으로 같은 것에 대해 별도의 타입과 전체적으로 다른 이름을 가지고 있는 이유는 무엇일까요? 코틀린 언어의 전 프로젝트 리드인 로만 엘리자로프는 선박이 \"로프\"에 대해 여러 다른 이름을 가지고 있는 것과 유사성을 들어줍니다. 왜냐하면 그들은 사용에 따라 명명되기 때문입니다. 해저고리는 주요 돛을 올리기 위한 로프이고, 다운할은 그것을 내리기 위한 로프이며, 샤트는 돛을 다루기 위한 것입니다.\n\n<div class=\"content-ad\"></div>\n\n비유적으로 말하면, 코루틴 범위는 특정 유형의 코루틴 컨텍스트로 기명됩니다. 이는 코루틴의 수명을 제한하고 제어하는 데 사용됩니다.\n\n실제로는 코루틴 범위는 특정 라이프사이클에 연결된 작업(Job)을 갖게 됩니다:\n\n- viewModelScope는 뷰 모델이 지워질 때 작업이 취소됩니다.\n- rememberCoroutineScope()는 컴포지션을 떠나는 시점에 작업이 취소됩니다.\n- viewLifecycleOwner.lifecycleScope은 Android View의 라이프사이클이 종료될 때 작업이 취소됩니다.\n\n그리고 이어서 이어지죠.\n\n<div class=\"content-ad\"></div>\n\n그래서 우리는 모두 데모 1로 돌아가서, 코루틴을 scope 내에 배치하면 안전하게 실행 및 무시할 수 있다는 것을 알 수 있었습니다. 이는 scope가 관련된 라이프사이클에 바운드된 Job을 가지고 있기 때문입니다.\n\n# 요약하자면...\n\n코루틴 컨텍스트, 스코프 및 Job의 개념은 코루틴을 사용하는 데 중요한 부분을 차지합니다. 우리는 컨텍스트가 코루틴과 관련된 메타데이터 목록과 같으며, 옵저버들에 정보를 제공하고 디스패처에게 실행 방법을 알려주는 것과 같다는 것을 보았습니다. 우리는 Job이 실행 중인 코루틴을 나타내며, 다른 코루틴에 대해 부모 역할을 할 수 있다는 것을 알았습니다. 그리고 이를 통해 코루틴 스코프를 이해할 수 있습니다. 즉, 부모 Job이 있는 컨텍스트입니다.\n\n도움이 되었으면 좋겠습니다. 계속해서 궁금한 점을 아래에 질문해 주세요!\n\n<div class=\"content-ad\"></div>\n\nTom Colvin은 20년 동안 소프트웨어 아키텍처를 담당해오고 있으며, 특히 안드로이드 작업을 좋아합니다. 그는 모바일 앱 전문가인 Apptaura의 공동 창업자이며, 컨설팅 기반으로 활동하고 있습니다.","ogImage":{"url":"/assets/img/2024-05-27-SevendemostounderstandcoroutinesscopecontextandJobs_0.png"},"coverImage":"/assets/img/2024-05-27-SevendemostounderstandcoroutinesscopecontextandJobs_0.png","tag":["Tech"],"readingTime":5},{"title":"특정 지역 자원 및 잘못된 로컬라이제이션 - 안드로이드","description":"","date":"2024-05-27 17:53","slug":"2024-05-27-RegionspecificresourcesandbrokenlocalizationAndroid","content":"\n\n![이미지](/assets/img/2024-05-27-RegionspecificresourcesandbrokenlocalizationAndroid_0.png)\n\n이 기사의 일환으로, 우리 애플리케이션에서 로컬라이제이션 지원을 망가뜨린 리소스 구성에 대한 최근 경험을 설명하겠습니다.\n\n프랑스어 번역에서 망가진 부분의 샘플은 다음과 같습니다.\n\n우리의 클라이언트 애플리케이션은 라이브러리를 사용하여 이 UI에 노출됩니다.\n\n\n<div class=\"content-ad\"></div>\n\n다음은 라이브러리 개발자들이 문자열 리소스를 넣은 파일들입니다 👇\n\n- strings.xml\n- 🇨🇦 strings.xml (fr-rCA)\n\n![이미지](/assets/img/2024-05-27-RegionspecificresourcesandbrokenlocalizationAndroid_1.png)\n\n👆에서 보듯이, 프랑스어 문자열을 캐나다 지역을 대상으로 하는 파일에 넣었습니다.\n\n<div class=\"content-ad\"></div>\n\n우리 애플리케이션에는 지역별이 아닌 프랑스어 문자열이 공통 파일에 저장되어 있어요👇\n\n\n![이미지](/assets/img/2024-05-27-RegionspecificresourcesandbrokenlocalizationAndroid_2.png)\n\n\n앱 수준 build.gradle에 다음 구성을 추가하기 전에 예상대로 작동했습니다\n\nKotlin\n\n<div class=\"content-ad\"></div>\n\n```js\n안드로이드 {\n    defaultConfig {\n        ...\n        resourceConfigurations.addAll(listOf(\"en\", \"fr\"))\n    }\n}\n```\n\n그루비\n\n```js\n안드로이드 {\n    defaultConfig {\n        ...\n        resConfigs \"en\", \"fr\"\n         // 또는\n        resourceConfigurations += [\"en\", \"fr\"]\n    }\n}\n```\n\n# 이 설정은 무엇을 하는 건가요:\n\n<div class=\"content-ad\"></div>\n\n## Android 개발자 문서에서의 정의\n\n사용되지 않는 대체 리소스 제거 👇\n\n이 방법의 주요 이점은 애플리케이션에 필요하지 않은 모든 리소스를 제거할 수 있다는 것입니다.\n\n이 시점에서 우리 케이스에서 프랑스어 지원이 깨졌다는 이유를 이해하셨으면 좋겠습니다.\n\n<div class=\"content-ad\"></div>\n\n저희 애플리케이션에는 두 가지 리소스만 필요하다는 구성이 추가되었습니다.👇\n\n```js\nresConfigs \"en\", \"fr\"\n         // 또는\nresourceConfigurations += [\"en\", \"fr\"]\n```\n\n이에 따라 Resource Shrinker는 fr-rCA 🇨🇦 리소스를 제거하고 애플리케이션에서는 [“en”, “fr”] 리소스만 사용할 수 있게 되었습니다.\n\n# 문제를 해결해보는 시간입니다.\n\n<div class=\"content-ad\"></div>\n\n- 빠르게 이 문제를 해결하기 위해 몇 가지 옵션이 있습니다:\n\n1st\n\n- build.gradle을 업데이트하여 fr-rCA 🇨🇦 리소스를 제거하지 않도록합니다.\n\n```js\nandroid {\n    defaultConfig {\n        ...\n        resConfigs \"en\", \"fr\", \"fr-rCA\"\n        // 또는\n        resourceConfigurations += [\"en\", \"fr\", \"fr-rCA\"]\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n# 2nd\n\n- 대안으로, 도서관을 제어하고 지역별 자원을 사용하고 싶지 않은 경우, 모든 지역에서 액세스할 수 있는 파일로 이동할 수 있습니다.\n\n# 함께 연결해요\n\nhttps://www.linkedin.com/in/navczydev/\n\n<div class=\"content-ad\"></div>\n\n# 참고문헌\n","ogImage":{"url":"/assets/img/2024-05-27-RegionspecificresourcesandbrokenlocalizationAndroid_0.png"},"coverImage":"/assets/img/2024-05-27-RegionspecificresourcesandbrokenlocalizationAndroid_0.png","tag":["Tech"],"readingTime":3},{"title":"적응형 컴포즈 레이아웃","description":"","date":"2024-05-27 17:51","slug":"2024-05-27-AdaptiveComposeLayouts","content":"\n\n## 모든 창 크기에 대한 흥미로운 소식\n\n![이미지](/assets/img/2024-05-27-AdaptiveComposeLayouts_0.png)\n\n올해 구글 I/O는 흥미로운 발표들로 가득 찼는데, AI 분야뿐만 아니라 (물론 그것도 하이라이트였지만) 적응형 레이아웃을 구축하기 위한 Jetpack Compose의 발전에 중점을 둔 것이 나에게는 핵심적인 교훈이었습니다. 안드로이드는 스마트폰뿐만 아니라 태블릿, 폴더블폰, 대형 화면 등으로 확장되고 있어서 다양한 형태 요소에 적응하는 앱을 개발하는 것이 더 중요해지고 있습니다.\n\n이전에 내가 이전 게시물에서 창 크기 클래스를 사용하여 반응형 레이아웃을 탐구했습니다. 그러나 Jetpack Compose의 흥미로운 새로운 발전으로 인해 해당 주제를 다시 살펴보게 되었습니다. WindowSizeClass의 새로운 구현뿐만 아니라 사용법을 간단하게 하는 새로운 Composable 함수들도 새롭게 나왔습니다. 또한 일반적인 레이아웃 동작을 단순화하는 새로운 Composable 함수들도 나왔는데, 사용자 정의 함수가 필요 없어졌습니다.\n\n<div class=\"content-ad\"></div>\n\n많은 내용을 다뤄야 하니까, 첫 번째 주요 측면으로 넘어가 볼까요? WindowSizeClass의 새로운 구현을 살펴봅시다. 이해를 돕기 위해, 제 이전 글에서의 구현을 이전해 보겠습니다. 원하신다면 확인해보세요.\n\n## WindowSizeClass의 이전\n\nGradle 파일을 업데이트하는 것부터 시작해봅시다. 이전 종속성을 제거하고 새롭게 개선된 구현을 위한 새로운 것을 추가할 겁니다.\n\n```js\n[versions]\nadaptive = \"1.0.0-beta01\"\n...\n[libraries]\n\n-- androidx-material3-windowSizeClass = { group = \"androidx.compose.material3\", name = \"material3-window-size-class\" }\nandroidx-adaptive = { module = \"androidx.compose.material3.adaptive:adaptive\", version.ref = \"adaptive\" }\n...\n```\n\n<div class=\"content-ad\"></div>\n\nGradle 종속성을 업데이트한 후 이제 이전 WindowSizeClass 구현에 의존했던 코드 섹션을 이주해 보겠습니다. 예를 들어, 창 크기에 따라 동적으로 열의 수를 결정하는 코드가 있다면 다음과 같이 업데이트할 수 있습니다:\n\n```js\nval windowWidthSize = currentWindowAdaptiveInfo().windowSizeClass.windowWidthSizeClass  \n\nval columns = when (windowWidthSize) {\n       WindowWidthSizeClass.COMPACT -> 1\n       WindowWidthSizeClass.MEDIUM -> 2\n       else -> 3\n}\n```\n\n업데이트가 함수 변경을 넘어 이동했다는 것을 알 수 있습니다! 주요 개선 사항 중 하나는 composable 함수 내에서 windowSizeClass를 직접 가져올 수 있는 능력입니다. 이제 activity를 통해 액세스할 필요 없이 이를 가져올 수 있습니다. 즉, 앱 전반에 걸쳐 창 크기 클래스를 매개변수로 전달할 필요가 없어졌습니다! 이것은 더 깨끗한 코드를 위한 중요한 발전입니다.\n\n## NavigationSuiteScaffold\n\n<div class=\"content-ad\"></div>\n\n윈도우 크기 클래스 이주를 다루었으니, 이제는 새로운 구성 가능 함수를 살펴봅시다. 먼저, NavigationSuiteScaffold가 등장합니다. 이 중요한 구성 가능 함수는 창 크기에 따라 하단 탐색 표시줄, 탐색 레일 및 서랍 사이를 전환할 때 사용자 정의 논리가 필요 없도록 해줍니다.\n\n이전 글에서는 탐색 요소 전환을 위한 사용자 정의 솔루션 구축을 탐구했습니다. 이제 NavigationSuiteScaffold가 이 프로세스를 간단하게 하는 방법을 살펴보겠습니다. 이 새로운 함수를 사용하여 동일한 결과를 얻는 방법은 다음과 같습니다:\n\n```js\n... \nNavigationSuiteScaffold(\n        modifier = Modifier, \n        navigationSuiteItems = {\n\n            bottomNavigationItems.forEach { bottomBarElement ->\n\n                val selected =\n                    currentScreen.instanceOf(bottomBarElement.screen::class)\n\n                item(\n                    icon = bottomBarElement.icon,\n                    selected = selected,\n                    alwaysShowLabel = true,\n                    label = {\n                        Text(\n                            text = stringResource(id = bottomBarElement.title),\n                            style = MaterialTheme.typography.labelMedium.copy(\n                                textAlign = TextAlign.Center,\n                                fontWeight = FontWeight.Normal\n                            ),\n                            maxLines = 1\n                        )\n                    },\n                    onClick = {\n                        if (!selected) {\n                                NavigationEvent.OnNavigateBottomBar(\n                                    bottomBarElement.screen\n                                )\n                        }\n                    }\n                )\n            }\n        }\n\n    ) {\n        Scaffold() { innerPadding ->\n            MainNavHost(\n                modifier = Modifier.padding(innerPadding),\n            )\n        }\n    }\n```\n\n이 단일 구현은 현재 창 크기에 따라 적절한 탐색 경험을 제공하도록 자동으로 동작합니다. 이는 작은 화면의 경우 하단 표시줄과 큰 화면의 경우 탐색 레일과 같은 요소 간에 전환하는 적절한 탐색 경험을 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n그러나 더 맞춤화된 접근을 선호하는 분들을 위해 NavigationSuiteScaffold는 NavigationSuiteType을 통해 유연성을 제공합니다. 여러분은 해당 스캐폴드 내에서 사용자 정의 동작을 매끄럽게 통합하여 스마트폰의 가로 모드에서도 네비게이션 레일과 같은 요소를 사용할 수 있습니다.\n\n```js\n... \nval adaptiveInfo = currentWindowAdaptiveInfo()\nval customNavSuiteType = with(adaptiveInfo) {\n            if (windowSizeClass.windowWidthSizeClass == WindowWidthSizeClass.EXPANDED) {\n                NavigationSuiteType.NavigationRail\n            } else {\n                NavigationSuiteScaffoldDefaults.calculateFromAdaptiveInfo(adaptiveInfo)\n            }\n}\n\nNavigationSuiteScaffold(\n        modifier = Modifier,\n        layoutType = customNavSuiteType,\n        navigationSuiteItems = {\n...\n```\n\n동일한 원칙이 특정 시나리오에서 네비게이션을 완전히 숨기고 싶은 경우에도 적용됩니다.\n\n```js\n... \nval adaptiveInfo = currentWindowAdaptiveInfo()\n    val customNavSuiteType = with(adaptiveInfo) {\n         when {\n            !shouldShowBottomBar -> {\n                NavigationSuiteType.None\n            }\n            windowSizeClass.windowWidthSizeClass == WindowWidthSizeClass.EXPANDED -> {\n                NavigationSuiteType.NavigationRail\n            }\n            else -> {\n                NavigationSuiteScaffoldDefaults.calculateFromAdaptiveInfo(adaptiveInfo)\n            }\n        }\n    }\n...\n```\n\n<div class=\"content-ad\"></div>\n\n## ListDetailPaneScaffold\n\n안녕하세요, 또 다른 강력한 Composable인 ListDetailPaneScaffold를 살펴보겠습니다. 이 함수는 화면 크기가 큰 경우 두 개의 화면(또는 패널로 표시)을 옆에 나란히 표시하고 싶을 때 이상적입니다. 주요 장점 중 하나는 단일 패널을 표시하거나 이중 패널 레이아웃을 활용하든 내부 내비게이션을 자동으로 처리한다는 점입니다. 이것은 개발을 간소화할 뿐만 아니라 창 크기에 관계없이 부드러운 사용자 경험을 보장합니다.\n\n```js\n[versions]\nmaterial3AdaptiveNavigationSuiteAndroid = \"1.3.0-beta01\"\n...\n[libraries]\n\nandroidx-material3-adaptive-navigation-suite-android = { group = \"androidx.compose.material3\", name = \"material3-adaptive-navigation-suite-android\", version.ref = \"material3AdaptiveNavigationSuiteAndroid\" }\n...\n```\n\n<div class=\"content-ad\"></div>\n\nGradle 종속성을 사용하여 코드를 업데이트할 수 있습니다.\n\n```js\n val navigator = rememberListDetailPaneScaffoldNavigator<String>()\n\n    BackHandler(navigator.canNavigateBack()) {\n        navigator.navigateBack()\n    }\n\n    ListDetailPaneScaffold(\n        directive = navigator.scaffoldDirective,\n        value = navigator.scaffoldValue,\n        listPane = {\n            AnimatedPane {\n                HomeScreen(\n                    onClickOnItem = {\n                        navigator.navigateTo(\n                            ListDetailPaneScaffoldRole.Detail,\n                            it\n                        )\n                    }\n                )\n            }\n        },\n        detailPane = {\n            AnimatedPane {\n                navigator.currentDestination?.content?.let {\n                    ZoomBookInitScreen(book = it.id)\n                }\n            }\n        },\n    )\n```\n\n이름에서 알 수 있듯이 navigator는 패널 내에서의 네비게이션을 관리하는 역할을 합니다. 이는 상세 패널로 이동하거나, 단일 패널 모드에서 백 네비게이션을 처리하는 것을 포함합니다. 또한 상세 패널로 전달된 데이터 객체를 포함합니다. 특히, Parcelable인 경우 사용자 정의 객체도 공유할 수 있습니다.\n\nWindowSizeClass와 함께 ListDetailPaneScaffold를 사용하여 현재 창 크기에 기반한 동작을 맞춤화할 수 있습니다. 예를 들어 (스크린샷에서 볼 수 있듯이) 단일 패널 모드에서만 뒤로 화살표와 같은 요소를 조건부로 표시할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```kotlin\nval windowWidthSize = currentWindowAdaptiveInfo().windowSizeClass.windowWidthSizeClass\nval backVisible = when (windowWidthSize) {\n    WindowWidthSizeClass.EXPANDED -> false\n    else -> true\n}\n```\n\n이 수준의 제어는 모든 다양한 디바이스 크기에서 정교한 사용자 경험을 보장합니다.\n\n## SupportingPaneScaffold\n\n새로운 적응형 레이아웃 기능을 탐색하기 위해 SupportingPaneScaffold를 간단히 살펴보겠습니다. 이 구성 요소는 핵심 기능인 탐색 관리와 창 내용 표시를 ListDetailPaneScaffold와 유사한 점을 가지고 있습니다. 하지만 SupportingPaneScaffold는 주요 콘텐츠 창과 오른쪽에 있는 더 작은 \"보조\" 창을 함께 사용하는 경우에 맞게 설계되었습니다. 이는 보조 콘텐츠가 주요 콘텐츠를 보완하거나 부가 정보를 제공하지만 동일한 화면 공간이 필요하지 않은 상황에 이상적입니다.\n\n\n<div class=\"content-ad\"></div>\n\n프로젝트에서 SupportingPaneScaffold을 구현하려면 ListDetailPaneScaffold에서 얻은 지식을 기반으로 활용할 수 있습니다. 더 깊은 이해를 위해 젯팩 코믹스의 공식 문서를 여기에 남겨 두겠습니다.\n\n# 결론\n\n본 문서를 통해 Google I/O 2024에서 젯팩 코믹스를 사용한 적응형 레이아웃 구축의 흥미로운 발전을 확인하였습니다. 새로운 WindowSizeClass 구현은 액세스 및 사용을 간단하게 만들어주며, NavigationSuiteScaffold, ListDetailPaneScaffold 및 SupportingPaneScaffold와 같은 강력한 조합 가능 함수들은 다양한 화면 크기와 형태 요인을 통해 탐색 및 콘텐츠 표현을 간소화하는 접근 방식을 제공합니다.\n\n이러한 새로운 기능은 Android 애플리케이션을 위한 정말로 반응적이고 사용자 친화적인 경험을 만들 수 있게 해줍니다. 적응형 레이아웃을 위한 최상의 실천 방법을 준수하고 이러한 도구들을 수용함으로써, 앱이 지속적으로 진화하는 Android 생태계에 매끄럽게 적응하여 모든 기기의 사용자에게 탁월한 경험을 제공할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n의견을 자유롭게 공유해주시거나, 원하신다면 LinkedIn에서 연락 주셔도 좋습니다.\n\n좋은 하루되세요!","ogImage":{"url":"/assets/img/2024-05-27-AdaptiveComposeLayouts_0.png"},"coverImage":"/assets/img/2024-05-27-AdaptiveComposeLayouts_0.png","tag":["Tech"],"readingTime":9},{"title":"앱 테마 변경하기  접근성 맞춤 설정하기","description":"","date":"2024-05-27 17:50","slug":"2024-05-27-ChangeAppThemePersonalizingAccessibility","content":"\n\n<img src=\"/assets/img/2024-05-27-ChangeAppThemePersonalizingAccessibility_0.png\" />\n\n이전 두 개의 게시물로 시작한 개인화 접근성 주제를 이어가고 있어요. 아래 링크에서 확인할 수 있어요:\n\n- 설정으로 개인화 접근성\n- 아이콘과 레이블 전환 - 개인화 접근성\n\n이전 게시물에서 설명한 것처럼, 일반적으로 개인화는 접근성을 개선하는 열쇠가 될 수 있다는 것과 아이콘과 레이블을 숨기거나 표시하는 설정을 추가하는 구체적인 예시를 제시했어요.\n\n<div class=\"content-ad\"></div>\n\n이 블로그 포스트에서는 구체적인 예시를 계속 다루겠습니다. 앱의 테마를 변경할 수 있는 설정을 추가할 것입니다. 사용자는 시스템 설정을 따르는 것(기본값), 밝은 테마, 어두운 테마, 고대비 색상 테마 중에서 선택할 수 있습니다. 함께 알아보겠습니다.\n\n# 왜?\n\n가끔 사용자들은 핸드폰의 테마와 다른 테마로 앱을 사용하고 싶어합니다. 저는 개인적으로 모든 것을 어두운 모드로 사용하지만, 제게는 사용하기 어려운 색상이 들어간 어두운 테마를 가진 몇몇 앱을 만난 적이 있습니다. 너무 많은 대비가 있는 경우도 있고, 때로는 너무 적은 경우도 있습니다. 그런 경우에는 밝은 테마로 변경하고 싶었습니다. 일반적으로 그런 옵션이 없어서 그 앱을 포기했거나, 필요할 때 최소한 사용했습니다.\n\n그래서 사용자에게 제어력을 주는 것이 중요합니다. 이런 종류의 설정을 위한 최소 옵션은 시스템 기본값, 밝은 테마, 어두운 테마입니다. 하지만 고대비 테마는 어떨까요? 왜 추가해야 하며 누가 필요로 할까요?\n\n<div class=\"content-ad\"></div>\n\n## 고대비 테마\n\n고대비 테마는 더 높은 대비를 가진 색상으로 이루어진 색상 팔레트를 가지고 있습니다. 구체적인 예로는 Windows 7 이후에 개발된 Windows 고대비 모드가 있습니다. 안드로이드는 고대비 텍스트를 설정할 수 있는 기능을 제공하지만, 그것은 텍스트에만 적용됩니다.\n\nWebAIM은 2018년에 저시력 사용자들을 대상으로 설문조사를 실시해, 응답자 중 51.4% (n=248)가 고대비 모드를 사용했다고 나타냈습니다. 저시력 사용자는 고대비 테마를 필요로 하는 큰 그룹 중 하나지만, 다른 사람들도 필요할 수 있습니다. 예를 들어, 편두통을 앓는 사람이나 아일린 증후군을 가진 사람, 또는 일부 언어 장애를 가진 사람들도 고대비 테마를 통해 혜택을 받을 수 있습니다. 또한 고대비 모드는 눈에 좋은 햇빛 속에서 모두에게 유용할 수 있습니다.\n\n# 어떻게?\n\n<div class=\"content-ad\"></div>\n\n앱 테마를 변경할 수 있는 기능을 추가하는 흐름은 이전 블로그 게시물의 레이블 및 아이콘과 유사합니다. 설정 화면에 설정을 추가하고 설정 값을 데이터 저장소에 저장한 다음 앱에서 해당 값을 사용하여 어떤 테마를 표시할지 결정합니다.\n\n먼저 설정 화면부터 시작해보겠습니다. 테마를 선택할 수 있는 섹션과 선택할 수 있는 옵션을 추가하고 싶습니다. 리스트에는 시스템 기본, 다크 테마, 라이트 테마 및 고대비 테마 네 가지 옵션이 포함되어 있습니다. 예시에서 색상이 표시됩니다:\n\n![테마 선택 화면](/assets/img/2024-05-27-ChangeAppThemePersonalizingAccessibility_1.png)\n\n## 데이터 저장하기\n\n<div class=\"content-ad\"></div>\n\n먼저, 이전 블로그 게시물에서 설정 저장에 사용한 설정 데이터 저장소에 키-값 쌍을 추가하려고 합니다. 이전 블로그 게시물에서 언급했듯이, 블로그 게시물을 단순하게 유지하기 위해 데이터 저장소는 SettingsRepository에서 정의되고 상호 작용됩니다.\n\n네 가지 옵션이 있기 때문에 이 경우에는 간단한 부울 값이 작동하지 않습니다. 코드에서는 테마에 대해 미리 정의된 값들을 사용하고자 하므로, 테마에 대한 옵션을 모두 포함하는 enum 클래스를 만들고 시스템 기본값으로 null을 사용합니다.\n\n```js\n// ThemeExt.kt\n\nenum class Theme {\n    Dark,\n    Light,\n    HighContrast;\n}\n```\n\n데이터 저장소는 enum 값들을 저장할 수 없으므로, enum을 문자열로 변환하고 다시 변환할 방법이 필요합니다. 문자열로 변환하는 부분은 쉽습니다 - toString() 함수를 사용할 수 있습니다. 다른 변환에 대해서는 도우미 함수를 정의해야 합니다. enum 클래스에 추가해보겠습니다:\n\n<div class=\"content-ad\"></div>\n\n```kotlin\nenum class Theme {\n    ...\n\n    companion object {\n        fun from(value: String?): Theme? {\n            return when (value) {\n                Dark.name -> Dark\n                Light.name -> Light\n                HighContrast.name -> HighContrast\n                else -> null\n            }\n        }\n    }\n}\n```\n\n이 메서드에서는 주어진 값과 일치하는 테마 이름이 무엇인지 확인합니다. 또한, 일치하는 것이 없을 때의 기본 케이스는 null입니다 - 일치하는 것이 없으면 시스템 기본값으로 가정하고 값을 null로 설정합니다.\n\n이제 데이터 스토어에 테마를 저장하기 위한 모든 준비가 되었습니다. 먼저 값을 읽기 위한 flow를 추가해 보겠습니다:\n\n```kotlin\n// SettingsRepository.kt\n\nprivate object PreferencesKeys {\n    ...\n    val colorTheme = stringPreferencesKey(\"color_theme\")\n}\n\nval colorThemeFlow: Flow<Theme?> = dataStore.data\n    .map {\n        Theme.from(it[PreferencesKeys.colorTheme])\n    }\n```\n\n<div class=\"content-ad\"></div>\n\n그럼, 먼저 preferences 키 오브젝트에 preferences 키를 추가합니다. 플로우를 위해 데이터 스토어에서 값을 읽은 다음, 앞서 정의한 Theme.from()을 사용하여 문자열을 Theme-enum으로 파싱합니다.\n\n값을 편집하기 위해 다음과 같은 함수를 정의합니다:\n\n```kotlin\n// SettingsRepository.kt\n\nsuspend fun setColorScheme(theme: Theme?) {\n    dataStore.edit { preferences ->\n        preferences[PreferencesKeys.colorTheme] = theme.toString()\n    }\n}\n```\n\n이 함수에서는 enum의 문자열 값을 정의한 preference 키를 사용하여 데이터 저장소에 설정합니다.\n\n<div class=\"content-ad\"></div>\n\n다음으로 할 일은 SettingsViewModel을 업데이트하는 것입니다. 먼저, 테마 값을 저장할 Mutable State Flow를 추가하고 UI에서 사용합니다:\n\n```kotlin\n// SettingsViewModel.kt\n\nprivate var _colorScheme = \n    MutableStateFlow<Theme?>(Theme.Dark)\nval colorScheme = _colorScheme.asStateFlow()\n```\n\n그런 다음, 리포지토리에서 값을 읽고 setColorScheme 함수를 사용할 수 있도록 함수를 정의합니다:\n\n```kotlin\n// SettingsViewModel.kt\n\nprivate fun getColorScheme() {\n    viewModelScope.launch {\n        settingsRepository.colorThemeFlow.collect {\n            _colorScheme.value = it\n        }\n    }\n}\n\nfun setColorScheme(theme: Theme?) {\n    viewModelScope.launch {\n        settingsRepository.setColorScheme(theme)\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n마지막으로 앱을 열 때 초기값을 얻기 위해 init 블록에서 getColorScheme()을 호출하는 것입니다:\n\n```js\n// SettingsViewModel.kt\n\ninit {\n    ...\n    getColorScheme()\n}\n```\n\n## 설정 화면\n\n지난 게시물과 마찬가지로 SettingsViewModel에서 값을 사용하는 방법을 보여주지는 않겠지만, 접근성 및 의미론적인 관점에서 몇 가지 사항을 언급하고 싶습니다: 각 색상 옵션은 선택 가능한 변경자를 가져야하며, 색상 옵션을 감싸는 구성 요소는 selectableGroup()-변경자를 가져야합니다. 내 코드에서 이러한 것들은 다음과 같습니다:\n\n<div class=\"content-ad\"></div>\n\n부모 컴포넌트에서 다음을 사용하고 있어요:\n\n```js\n// SettingsScreen.kt \n\nColumn(\n    modifier = Modifier.selectableGroup(),\n) {\n    colorOptions.map { option ->\n        ...\n    }\n}\n```\n\n이 작업이 왜 이루어지는지 더 알고 싶다면, 제 블로그 게시물인 젯팩 콤포즈에서 Modifier를 활용하여 Android 접근성 향상하기를 확인해보세요.\n\n## UI에 대한 테마 변경\n\n<div class=\"content-ad\"></div>\n\n최종 단계는 테마의 저장된 값 사용하여 해당 값을 업데이트하는 것입니다. 저장된 값에 따라 테마를 설정하는 로직을 추가해야 합니다.\n\n실제 테마 정의는 이 블로그 포스트의 범위를 벗어납니다. 저는 어두운, 밝은 및 고대비 테마에 대한 색상을 정의했고 코드에서 이를 사용할 것입니다.\n\nTheme.kt 파일에서 애플리케이션 테마의 기본 구현에 추가적인 확인을 추가해봅시다:\n\nAppTheme 코파서블에 Theme 유형의 선택적 매개변수를 추가하고 해당 값을 사용하여 MaterialTheme 구성 요소에 설정할 색상을 결정합니다. 테마가 null이 아닌 경우 값을 기준으로 색상을 설정하고, null이면 시스템의 기본 색상을 사용해야 합니다. 이를 위해 isSystemInDarkTheme 값을 확인하여 색상을 설정합니다.\n\n<div class=\"content-ad\"></div>\n\n마지막으로, 앱의 루트가 정의된 MainActivity에서 우리는 저장된 테마의 값을 읽은 다음 그 값을 AppTheme-composable에 전달합니다:\n\n```js\n// MainActivity.kt\n\nval theme = settingsViewModel.colorScheme.collectAsState()\n\nAppTheme(theme = theme.value) { ... }\n```\n\n그리고 이러한 변경 사항들로 설정에서 선택했을 때 다음 테마들을 볼 수 있게 될 것입니다:\n\n# 마무리\n\n<div class=\"content-ad\"></div>\n\n이 블로그 글에서는 앱에서 사용자가 테마를 선택할 수 있도록 설정을 추가하여 사용자가 소프트웨어의 테마를 결정하는 방법을 살펴보았어요. 제공되는 테마는 밝은 테마, 어두운 테마, 고대비 테마 또는 시스템의 기본 테마를 따를 수 있어요.\n\n당신의 앱에 테마 선택기를 구현해 보셨나요? 지금까지 고대비 테마를 경험해 보신 적이 있나요? 앞으로 다룰 수 있는 접근성 설정 유형에 대한 아이디어가 있으신가요?\n\n# 블로그 글 내 링크\n\n- 설정으로 접근성 개인화하기\n- 아이콘과 레이블을 토글하기 — 접근성 개인화\n- WebAIM\n- Jetpack Compose에서 Modifier로 안드로이드 접근성 향상하기","ogImage":{"url":"/assets/img/2024-05-27-ChangeAppThemePersonalizingAccessibility_0.png"},"coverImage":"/assets/img/2024-05-27-ChangeAppThemePersonalizingAccessibility_0.png","tag":["Tech"],"readingTime":6},{"title":"안녕하세요 이번 Android 스택 주간 소식입니다  Issue126","description":"","date":"2024-05-27 17:49","slug":"2024-05-27-AndroidStackWeeklyIssue126","content":"\n\n<img src=\"/assets/img/2024-05-27-AndroidStackWeeklyIssue126_0.png\" />\n\n# 기사\n\n## Jetpack Compose에서 공유 요소 전환으로 부드러운 탐색 경험\n\n안드로이드 앱에서 매끄러운 내비게이션 경험을 만들기 위해 Jetpack Compose에서 공유 요소 전환이 어떻게 구현되는지 배우세요. 이 안내서에는 설정, 종속성 및 코드 예시가 포함되어 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## Compose 컴파일러 보고서의 무난한 분석\n\nJetpack Compose 컴파일러 보고서를 쉽게 분석하여 안드로이드 앱의 성능을 최적화하는 방법을 알아보세요.\n\n## 접근성을 위한 앱 테마 개인화\n\n사용자가 빛, 어둠 및 고대비 옵션을 포함한 테마를 사용자 정의할 수 있도록 함으로써 앱 접근성을 향상시키는 방법을 배워보세요.\n\n<div class=\"content-ad\"></div>\n\n## 안드로이드 뷰에 예측 후진 구현 로드맵\n\n안드로이드 앱에서 뷰를 사용하여 예측 후진 애니메이션을 통합하는 단계에 대해 설명하는 블로그 포스트입니다.\n\n## 안드로이드에서 효과적인 캐싱 전략\n\n안드로이드 앱을 위한 다양한 캐싱 전략을 탐색하며 API 캐싱에 초점을 맞춥니다. 이 글은 Cache Only, Network Only, Network First 및 여러 Cache First 전략과 같은 다양한 접근 방식에 대해 논의합니다.\n\n<div class=\"content-ad\"></div>\n\n## 토끼굴 속으로: 성능 최적화 통찰\n\n안드로이드 앱 개발에서 성능 최적화의 미묘한 점들을 로맹 가이와 함께 살펴보세요.\n\n**협찬** \n\n**라이브러리 및 자원** \n\n<div class=\"content-ad\"></div>\n\n## ComposeGuard\n\nJetpack Compose에서 regression을 감지하는 Gradle 플러그인입니다.\n\n# Videos\n\n## 안드로이드 앱 경험을 향상시키는 3가지 방법: Edge to Edge, Predictive Back, 그리고 Glance\n\n<div class=\"content-ad\"></div>\n\n## 더 빠르게 만들기 - Android Developers Backstage\n\n## Jetpack Compose UI를 쉽게 디버깅하세요!\n\n## Google의 새로운 스크린샷 테스팅 프레임워크를 Compose에 어떻게 사용할 수 있을까요?\n\n## Stream SDK로 안드로이드 비디오 통화 앱 만들기\n\n<div class=\"content-ad\"></div>\n\n## 다음 주간 소식을 위한 링크를 추천해주세요\n\n의겈이나 피드백을 환영합니다!\n\n제안하고 싶은 내용이나 의견이 있으시면 Canopas Twitter 계정 @canopas_eng 로 연락주시고, 다음 주간에 고려해 드리겠습니다.","ogImage":{"url":"/assets/img/2024-05-27-AndroidStackWeeklyIssue126_0.png"},"coverImage":"/assets/img/2024-05-27-AndroidStackWeeklyIssue126_0.png","tag":["Tech"],"readingTime":2},{"title":"Terraform을 활용한 Multi-Cloud 관리 마스터하기","description":"","date":"2024-05-27 17:46","slug":"2024-05-27-MasteringMulti-CloudManagementwithTerraform","content":"\n<img src=\"/assets/img/2024-05-27-MasteringMulti-CloudManagementwithTerraform_0.png\" />\n\n여러 공개 클라우드(Azure, AWS, GCP 등)를 사용하면 유연성을 제공하고 비용을 최적화하며 벤더 락인을 줄일 수 있습니다. 그러나 다양한 클라우드 플랫폼 간에 인프라 및 서비스를 관리하는 것은 어렵습니다.\n\n테라폼을 통해 일관되고 자동화된 멀티 클라우드 관리가 가능한지 알아봅시다. 이 포함사항은 멀티 클라우드 아키텍처, 테라폼 추상화, 프로비저닝, 거버넌스, 네트워킹, 배포 패턴, 테스팅, 그리고 Azure 및 GCP 전반적인 모니터링입니다.\n\n# 개요\n\n<div class=\"content-ad\"></div>\n\n다음 주제를 다룰 것입니다:\n\n- 테라폼을 사용한 멀티 클라우드 아키텍처\n- 인프라 차이점 추상화\n- 리소스 프로비저닝 및 의존성 관리\n- 정책 강화 및 거버넌스\n- 네트워킹 토폴로지와 연결\n- 블루-그린, 카나리아, 멀티 리전 배포 패턴\n- 통합 테스트 및 목 객체(Mock) 사용\n- 중앙 집중식 로깅, 메트릭 및 관찰 가능성\n\n이 코드 예제들은 테라폼을 사용해 Azure와 GCP로 인프라 및 서비스를 배포하는 방법을 보여줍니다. 이는 테라폼을 일관된 추상화 계층으로 사용하여 실제 멀티 클라우드 관리를 보여줍니다.\n\n# 멀티 클라우드 아키텍처\n\n<div class=\"content-ad\"></div>\n\n기본적인 멀티 클라우드 아키텍처는 Terraform을 사용하면 다음과 같이 보입니다:\n\nTerraform은 여러 클라우드 계정에 인프라를 프로비저닝하고 플랫폼 간의 차이를 추상화합니다. 상태는 원격으로 저장되며 계정 간에 공유됩니다.\n\n멀티 클라우드 아키텍처를 위한 몇 가지 주요 디자인 원칙:\n\n- 차이 추상화 — 공급자별 논리를 최소화하고 차이를 추상화 뒤에 숨깁니다\n- 환경 모듈화 — 환경 및 구성 요소별로 모듈화된 파일로 구성을 분리합니다\n- 표준화된 네이밍 — 쉽게 연관을 확인하기 위해 클라우드 간에 일관된 네이밍 체계 사용\n- 정책 캡슐화 — 정책 및 거버넌스 규칙을 모듈화된 재사용 가능한 파일에 유지합니다\n- 상태 중앙화 — 원격 상태를 사용하여 서비스 및 클라우드 전체의 상태를 공유합니다\n- 공유 서비스 추출 — ID, DNS, CDN과 같은 공유 서비스를 한 번 빌드하고 재사용합니다\n- 파이프라인 통합 — 모든 클라우드 대상으로 배포하는 표준 CI/CD 파이프라인 사용\n\n<div class=\"content-ad\"></div>\n\n이러한 원칙을 따라서, 여러 대상 클라우드 간에 일관성있는 이동 가능한 구성을 구축할 수 있습니다.\n\n그 다음으로, Terraform이 클라우드 간의 차이를 추상화하는 데 어떻게 도움을 주는지 살펴보겠습니다.\n\n# 인프라 추상화\n\nTerraform의 강점 중 하나는 클라우드 플랫폼 간의 차이를 추상화하는 균일한 추상화 계층을 제공할 수 있는 능력입니다.\n\n<div class=\"content-ad\"></div>\n\n예를 들어, Azure 대 GCP에서 MySQL 데이터베이스 프로비저닝:\n\nAzure\n\n```js\nresource \"azurerm_mysql_server\" \"db\" {\n  name                = \"mysqlserver\"\n  location            = \"eastus\"\n  resource_group_name = azurerm_resource_group.rg.name\n```\n\n```js\n  sku {\n    name     = \"B_Gen5_2\"\n    capacity = 2\n  }\n}\nresource \"azurerm_mysql_database\" \"db\" {\n  name                = \"mydatabase\"\n  resource_group_name = azurerm_resource_group.rg.name\n  server_name         = azurerm_mysql_server.db.name\n  charset             = \"utf8\"\n  collation           = \"utf8_unicode_ci\"\n}\n```\n\n<div class=\"content-ad\"></div>\n\nGCP\n\n```js\nresource \"google_sql_database_instance\" \"db\" {\n  name             = \"mysql-instance\"\n  database_version = \"MYSQL_5_7\"\n  region           = \"us-central1\"\n```\n\n```js\n  settings {\n    tier = \"db-f1-micro\"\n  }\n}\nresource \"google_sql_database\" \"database\" {\n  name     = \"my-database\"\n  instance = google_sql_database_instance.db.name\n}\n```\n\nTerraform의 리소스 유형은 일관된 인터페이스를 제공하기 위해 기본 API 차이를 추상화합니다.\n\n<div class=\"content-ad\"></div>\n\n이 추상화는 대규모 변경없이 클라우드 간에 쉽게 전환할 수 있도록 도와줍니다. 필요한 경우 각 클라우드 공급업체에 맞게 엣지에서 맞춤 설정할 수 있습니다.\n\n테라폼이 다중 클라우드 추상화를 제공하는 주요 분야 몇 가지:\n\n- 컴퓨팅 — 가상 머신, 컨테이너, 쿠버네티스, 스케일링\n- 네트워크 — 서브넷, 라우팅, 보안 그룹, 로드 밸런싱\n- 스토리지 — 블롭, 디스크, 데이터베이스\n- 아이덴티티 — 역할, 권한, 액세스 제어\n- 인프라스트럭처 — DNS, VPN, 규칙, 정책\n\n최대한 다중 클라우드 추상화를 활용하여 구성을 작성하면 이동성이 높아집니다.\n\n<div class=\"content-ad\"></div>\n\n# 프로비저닝 및 의존성\n\n여러 클라우드 인프라를 프로비저닝할 때 가장 좋은 방법은 리소스를 의존성 레이어로 구조화하는 것입니다.\n\n상위 수준의 구성은 하위 수준의 구성을 의존합니다. 예를 들어:\n\n테라폼을 사용할 때, depends_on 속성을 사용하여 리소스 의존성을 명시적으로 정의하세요:\n\n<div class=\"content-ad\"></div>\n\n```md\n리소스 \"azurerm_subnet\" \"public\" {\n#...\n}\n```\n\n```md\n리소스 \"azurerm_network_interface\" \"nic\" {\n#...\nsubnet_id = azurerm_subnet.public.id\n}\n리소스 \"azurerm_virtual_machine\" \"main\" {\n#...\n\nnetwork_interface_ids = [\nazurerm_network_interface.nic.id,\n]\ndepends_on = [\nazurerm_network_interface.nic\n]\n}\n```\n\n테라폼은 리소스 간 종속성을 분석하고 변경 사항을 올바른 순서로 적용합니다.\n\n멀티 클라우드 환경에서의 종속성에 대한 팁:\n\n\n\n<div class=\"content-ad\"></div>\n\n- 공통 빌딩 블록을 기본 모듈에 네트워크와 같은 것으로 포함시킵니다.\n- 독립적인 구성 요소를 계층별로 분리합니다.\n- 암시적이어도 `depends_on`을 명시적으로 정의합니다.\n- 데드락을 일으키는 종속성 순환이 있는지 확인합니다.\n- 종속성 순서대로 계획하고 적용합니다.\n\n자원 종속성을 올바르게 설정하는 것이 여러 클라우드에서 원활한 프로비저닝을 위해 중요합니다.\n\n# 정책 집행과 거버넌스\n\n기관 정책과 규정 준수 요구사항을 강제하는 것은 여러 클라우드 관리에 있어 중요합니다.\n\n<div class=\"content-ad\"></div>\n\n다음은 운용 규칙의 몇 가지 예시입니다:\n\n- VM 유형 제한\n- 데이터 주권을 위한 지역 및 존 제어\n- 태깅 규칙과 표준 설정\n- 네트워킹 노출 제한\n- 암호화 요구 사항 강제\n- 고위험 자원 사용 제한\n\n테라폼을 통해 정책 강제를 활성화할 수 있습니다:\n\n변수\n\n<div class=\"content-ad\"></div>\n\n허용된 값 제한:\n\n```js\nvariable \"region\" {\n  type    = string\n  default = \"us-east-1\"\n}\n```\n\n```js\nresource \"aws_db_instance\" \"db\" {\n  region = var.region # us-east-1만 허용됩니다\n}\n```\n\n모듈\n\n<div class=\"content-ad\"></div>\n\n친구야, 모듈 내에서 지배 논리를 캡슐화하고 재사용하세요:\n\n```js\nmodule \"server\" {\n  source = \"./modules/certified_server\"\n# 인증된 서버는 합리적인 기본값을 설정합니다\n}\n```\n\nSentinel 정책\n\n리소스를 제한하는 대상 정책을 적용하십시오:\n\n<div class=\"content-ad\"></div>\n\n```js\naws_instance_disallowed_type = rule {\n  all aws_instance as _, instance {\n    instance.instance_type is not in [\"t2.micro\", \"t3.micro\"]\n  }\n}\n```\n\n이러한 메커니즘은 구성에 직접 규제를 포함하여 규정 준수를 쉽게 만듭니다.\n\n# 네트워킹 토폴로지\n\n다양한 클라우드 간 네트워크 연결성을 관리하는 것은 복잡성을 증가시킵니다. 일부 하이브리드 클라우드 네트워크 토폴로지는 다음과 같습니다:```\n\n<div class=\"content-ad\"></div>\n\n테이블 형식을 Markdown 형식으로 변경하실래요.\n\n\n| Pairing |\n|--------|\n| Connect cloud regions to on-prem data centers. Useful for migration and hybrid workloads. |\n\n| Hub-and-Spoke |\n|---------------|\n| Central hub VPC with connectivity to multiple cloud spokes. Enables transitivity between spokes. |\n\n\n<div class=\"content-ad\"></div>\n\n메시\n\n클라우드 간 사이트 간 VPN이 구성된 완전히 메시된 네트워크입니다. 지역 간 직접 통신을 제공합니다.\n\n테라폼은 terraform-provider-aws, terraform-provider-azurerm 및 유사한 네트워킹 제공업체를 통해 이러한 네트워크 토폴로지를 조정하는 것을 단순화합니다.\n\n예를 들어, AWS에서 Azure로 사이트 간 VPN을 생성하는 방법:\n\n<div class=\"content-ad\"></div>\n\n```js\n# AWS 측\n리소스 \"aws_customer_gateway\" \"gw\" {\n  bgp_asn    = 65002\n  ip_address = \"172.0.0.1\"\n  type       = \"ipsec.1\"\n}\n```\n\n```js\n리소스 \"aws_vpn_connection\" \"main\" {\n  vpn_gateway_id      = aws_vpn_gateway.vgw.id\n  customer_gateway_id = aws_customer_gateway.gw.id\n  type                = \"ipsec.1\"\n  static_routes_only  = true\n  tunnel1_ike_versions   = [\"ikev2\"]\n  tunnel2_ike_versions   = [\"ikev2\"]\n  tunnel1_phase1_dh_group_numbers = [31]\n  tunnel2_phase1_dh_group_numbers = [31]\n}\n# Azure 측\n리소스 \"azurerm_local_network_gateway\" \"lgw\" {\n  name                = \"aws-conn\"\n  resource_group_name = azurerm_resource_group.rg.name\n  location            = azurerm_resource_group.rg.location\n  gateway_address = aws_customer_gateway.gw.ip_address\n  address_space     = [\"172.16.0.0/16\"]\n}\n리소스 \"azurerm_virtual_network_gateway_connection\" \"main\" {\n  name                       = \"aws-conn\"\n  resource_group_name        = azurerm_resource_group.rg.name\n  location                   = azurerm_resource_group.rg.location\n  type                       = \"IPsec\"\n  virtual_network_gateway_id = azurerm_virtual_network_gateway.vgw.id\n  local_network_gateway_id   = azurerm_local_network_gateway.lgw.id\n  shared_key = aws_vpn_connection.main.tunnel1_preshared_key\n\n  ipsec_policy {\n    dh_group         = \"DHGroup31\"\n    ike_encryption   = \"AES256\"\n    ike_integrity    = \"SHA256\"\n    ipsec_encryption = \"AES256\"\n    ipsec_integrity  = \"SHA256\"\n    pfs_group        = \"PFS31\"\n    sa_datasize      = 536870912\n  }\n}\n```\n\n이 방법을 통해 멀티 클라우드에 일관된 방식으로 전체 연결 구성을 정의할 수 있습니다.\n\n# 배포 패턴\n\n\n\n<div class=\"content-ad\"></div>\n\n여러 클라우드로 배포할 때 블루-그린, 카나리아, 다중 지역과 같은 패턴을 사용하면 관리가 간단해질 수 있어요.\n\n블루-그린\n\n블루-그린은 새 버전을 병렬로 배포한 다음 트래픽을 원자적으로 전환합니다. 이는 롤백 및 점진적인 롤아웃 기능을 제공합니다.\n\n예시:\n\n<div class=\"content-ad\"></div>\n\n```js\n# 파란 환경\nmodule \"blue_env\" {\n  source = \"./env\"\n  color  = \"blue\"\n}\n```\n\n```js\n# 초록 환경\nmodule \"green_env\" {\n  source = \"./env\"\n  color  = \"green\"\n  # 처음에는 트래픽이 없음\n  traffic_weight = 0\n}\n# 트래픽 분할기\nresource \"aws_lb\" \"main\" {\n  # 100%의 트래픽을 파란 쪽에 보냅니다.\n}\n```\n\n그런 다음 로드 밸런서를 통해 점진적으로 파란 색에서 초록 색으로 트래픽을 이동합니다.\n\n카나리아\n\n\n\n<div class=\"content-ad\"></div>\n\n파란색-초록색처럼 변경되지만 처음에는 일부 사용자에게만 공개됩니다.\n\n```js\nmodule \"prod_env\" {\n  source = \"./env\"\n```\n\n```js\n  # 대부분의 트래픽이 본 프로덕션 환경으로 이동합니다.\n}\nmodule \"canary_env\" {\n  source = \"./env\"\n  # 소수의 트래픽이 canary로 이동합니다.\n  traffic_weight = 0.1\n}\n```\n\nMulti-Region\n\n<div class=\"content-ad\"></div>\n\n고가용성 및 낮은 대기 시간을 위해 여러 지역에 리소스를 프로비저닝합니다.\n\n예를 들어:\n\n```js\n# 서부 지역\nmodule \"west\" {\n  source = \"./region\"\n  providers = {\n    azurerm.west = azurerm.west\n  }\n}\n```\n\n```js\n# 동부 지역\nmodule \"east\" {\n  source = \"./region\"\n  providers = {\n    azurerm.east = azurerm.east\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n그럼 DNS와 로드 밸런싱을 사용하여 전 세계적으로 분산하세요.\n\n이러한 패턴은 멀티 클라우드 배포를 간단하게 해줍니다. 모듈 재사용은 일관성을 도와줍니다.\n\n# 통합 테스트\n\n여러 클라우드에 걸친 배포를 유효성 검사하려면 자동화된 통합 테스트가 필요합니다.\n\n<div class=\"content-ad\"></div>\n\n테라폼을 사용한 멀티 클라우드 테스팅을 위한 몇 가지 최상의 방법:\n\n- 인프라 테스트 — terraform plan 및 terraform show를 사용하여 올바른 구성의 리소스를 검증합니다.\n- 프로비저닝 테스트 — 처음부터 일회용 테스트 환경을 배포합니다.\n- 실패 테스트 — 종료된 인스턴스와 같은 실패를 시뮬레이션합니다.\n- 서비스 테스트 — 목업을 사용하여 서비스 접근성과 동작을 유효성 검사합니다.\n\n예를 들어, 일회용 테스트 환경을 생성하는 방법:\n\n```js\nmodule \"test_env\" {\n  source = \"./env\"\n  providers = {\n    aws = aws.test\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n테이블 태그를 Markdown 형식으로 변경해주세요.\n\n<div class=\"content-ad\"></div>\n\n다양한 환경에서 배포를 유효성 검사하려면 자동화된 테스트가 필요합니다.\n\nTerraform을 사용하는 몇 가지 권장사항:\n\n- 사용 및 폐기 가능한 테스트 환경 프로비저닝\n- 리소스 구성 검증\n- 다양한 장애 시나리오 시뮬레이션\n- 의존성에 대한 모의 테스트 사용\n\n예시:\n\n<div class=\"content-ad\"></div>\n\n```js\nmodule \"test_env\" {\n  source = \"./env\"\n```\n\n```js\n  # AWS 계정 자격 증명 테스트\n}\nresource \"null_resource\" \"check_connectivity\" {\n  provisioner \"local-exec\" {\n    command = \"ping.exe -n 3 ${module.test_env.ip}\"\n  }\n}\n```\n\n이렇게 하면 안전하게 변경 사항을 테스트할 수 있는 격리된 환경이 생성됩니다.\n\n다른 예시:\n\n\n\n<div class=\"content-ad\"></div>\n\n- 성능 테스트를 위해 과거 트래픽을 다시 재생합니다.\n- 종료된 인스턴스와 같은 결함을 주입합니다.\n- 결정론적 테스트를 위해 외부 서비스를 스텁 처리합니다.\n\n자동화된 테스트는 구성 요소를 리팩토링할 때 자신감을 유지하는 데 중요합니다.\n\n## 가시성\n\n이질적인 클라우드 간 로그, 지표 및 추적에 대한 가시성을 확보하는 것은 어렵습니다.\n\n<div class=\"content-ad\"></div>\n\n테라폼을 사용하면 관측 가능성 데이터를 공유 플랫폼에 집계할 수 있습니다:\n\n로그 기능\n\n```js\nresource \"aws_cloudwatch_log_group\" \"app\" {\n  name = \"/aws/lambda/app\"\n}\nresource \"azurerm_monitor_diagnostic_setting\" \"app\" {\n  name               = \"diag\"\n  target_resource_id = azurerm_function_app.app.id\n  log_analytics_workspace_id = azurerm_log_analytics_workspace.main.id\n  log {\n    category = \"FunctionAppLogs\"\n    enabled  = true\n  }\n}\nresource \"google_logging_project_sink\" \"app\" {\n  name        = \"app-sink\"\n  destination = google_storage_bucket.logs.name\n}\n```\n\nSplunk와 같은 도구에서 로그를 중앙 집계하세요.\n\n<div class=\"content-ad\"></div>\n\n메트릭\n\n```js\n리소스 \"signalfx_detector\" \"지연시간\" {\n  이름 = \"높은 지연시간\"\n  프로그램_텍스트 = <<-EOF\n    A = 데이터('지연시간', 필터=필터('클라우드', '*') and 필터('환경', '*')).게시(label='A')\n    B = (A).합계(by=['클라우드', '환경']).게시(label='B')\n    detect(when(B > 1000, '5m')).게시('높은 지연시간!')\n  EOF\n}\n```\n\nDatadog와 같은 플랫폼에서 메트릭을 통합해보세요.\n\n트레이싱\n\n<div class=\"content-ad\"></div>\n\n```js\nmodule \"opentelemetry\" {\n  source = \"./opentelemetry\"\n  providers = {\n    aws = aws\n    azure = azurerm\n    google = google\n  }\n}\n```\n\n일반적인 형식으로 OpenTelemetry을 사용하면 추적을 쉽게 연결할 수 있어요.\n\n테라폼을 사용하면 다양한 플랫폼 사이에서 공유 관찰 패턴을 구축할 수 있어요.\n\n# 예시: 멀티-클라우드 웹 애플리케이션\n\n<div class=\"content-ad\"></div>\n\n실제로 멀티 클라우드 웹 애플리케이션을 Terraform으로 배포하는 실제 사례를 살펴봅시다.\n\nAWS ECS 및 Azure Container Instances (ACI)의 클러스터 전체에 애플리케이션 인프라를 배포할 것입니다. 글로벌 로드 밸런서가 트래픽을 플랫폼 간에 분배할 것입니다.\n\n네트워킹\n\n먼저, AWS VPC와 Azure VNet을 연결해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n# AWS VPC 및 서브넷\nresource \"aws_vpc\" \"main\" {\n  cidr_block = \"10.1.0.0/16\"\n}\n```\n\n```js\nresource \"aws_subnet\" \"public\" {\n  vpc_id = aws_vpc.main.id\n  cidr_block = \"10.1.1.0/24\"\n}\n# Azure VNet\nresource \"azurerm_virtual_network\" \"main\" {\n  name                = \"app-network\"\n  address_space       = [\"10.2.0.0/16\"]\n}\nresource \"azurerm_subnet\" \"public\" {\n  name                 = \"public-subnet\"\n  resource_group_name  = azurerm_resource_group.main.name\n  virtual_network_name = azurerm_virtual_network.main.name\n  address_prefixes     = [\"10.2.1.0/24\"]\n}\n```\n\nVPC 피어링을 통해 이들을 연결하십시오:\n\n```js\n# AWS 쪽 피어링\nresource \"aws_vpc_peering_connection\" \"peer\" {\n  vpc_id      = aws_vpc.main.id\n  peer_vpc_id = azurerm_virtual_network.main.id\n  auto_accept = true\n}\n```\n\n<div class=\"content-ad\"></div>\n\n```js\n# Azure 측 피어링\nresource \"azurerm_virtual_network_peering\" \"peer\" {\n  name                      = \"peer-aws\"\n  resource_group_name       = azurerm_resource_group.main.name\n  virtual_network_name      = az\n```\n\n컴퓨팅\n\nAzure Container Instances 배포:\n\n```js\nresource \"azurerm_container_group\" \"app\" {\n  name                = \"app-aci\"\n  location            = azurerm_resource_group.main.location\n  resource_group_name = azurerm_resource_group.main.name\n  ip_address_type     = \"public\"\n  dns_name_label      = \"app-aci\"\n  os_type             = \"Linux\"\n```\n\n<div class=\"content-ad\"></div>\n\n```js\n  container {\n    name   = \"app\"\n    image  = \"myapp:v1\"\n    cpu    = \"1\"\n    memory = \"1\"\n    ports {\n      port     = 80\n      protocol = \"TCP\"\n    }\n  }\n```\n\n아마존 ECS 클러스터 및 서비스:\n\n```js\nresource \"aws_ecs_cluster\" \"main\" {\n  name = \"myapp-cluster\"\n}\n```\n\n```js\nresource \"aws_ecs_service\" \"web\" {\n  name            = \"web\"\n  cluster         = aws_ecs_cluster.main.id\n  task_definition = aws_ecs_task_definition.app.arn\n  desired_count   = 3\n  launch_type     = \"FARGATE\"\n}\n```\n\n<div class=\"content-ad\"></div>\n\n로드 밸런싱\n\n각 클라우드에 백엔드가 있는 글로벌 로드 밸런서를 배포하십시오:\n\n```js\nresource \"aws_lb\" \"web\" {\n  name               = \"myapp-lb\"\n  internal           = false\n\n  subnets = [\n    aws_subnet.public.id\n  ]\n}\n```\n\n```js\nresource \"azurerm_lb\" \"web\" {\n  name                = \"myapp-lb\"\n  location            = azurerm_resource_group.main.location\n  resource_group_name = azurerm_resource_group.main.name\n\n  frontend_ip_configuration {\n    name                 = \"public\"\n    public_ip_address_id = azurerm_public_ip.main.id\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\nMarkdown 포맷으로 DNS\n\n로드 밸런서를 통해 단일 도메인을 라우팅합니다:\n\n```js\nresource \"aws_route53_zone\" \"main\" {\n  name = \"myapp.com\"\n}\n```\n\n```js\nresource \"aws_route53_record\" \"webapp\" {\n  zone_id = aws_route53_zone.main.id\n  name    = \"webapp.myapp.com\"\n  type = \"CNAME\"\n  ttl  = \"300\"\n  records = [aws_lb.web.dns_name]\n}\nresource \"azurerm_dns_cname_record\" \"webapp\" {\n  name                = \"webapp\"\n  zone_name           = azurerm_dns_zone.main.name\n  resource_group_name = azurerm_resource_group.main.name\n  ttl                 = 300\n  record              = azurerm_lb.web.fqdn\n}\n```\n\n<div class=\"content-ad\"></div>\n\n이는 웹 애플리케이션을 다중 클라우드에서 실행하기 위한 핵심 인프라를 제공하며, 로드 밸런싱과 DNS를 통해 연결됩니다.\n\n테라폼 추상화는 우리에게 클라우드 플랫폼 간에 일관된 방식으로 아키텍처를 표현할 수 있는 기회를 제공합니다. 배포를 확장하고 필요에 따라 데이터베이스, 객체 저장소 및 캐시와 같은 추가 구성 요소를 추가할 수 있습니다.\n\n# 결론\n\n이 블로그에서는 테라폼을 사용하여 다중 클라우드 인프라, 네트워킹, 배포, 테스트 및 모니터링을 관리하는 패턴과 모범 사례를 다루었습니다.\n\n<div class=\"content-ad\"></div>\n\n- 추상화 — 추상화된 공급자 및 리소스를 사용하여 이식 가능한 구성물 생성\n- 모듈 — 복잡한 구성 요소를 재사용 가능한 모듈로 캡슐화\n- 상태 — 협업 가능하도록 원격 상태 저장\n- 네트워킹 — VPC와 VNET 간의 연결성 조정\n- 배포 — 블루-그린, 카나리아, 다중 지역 패턴 사용\n- 테스트 — 테스트 환경의 자동 프로비저닝\n- 가시성 — 로그, 메트릭 및 추적을 중앙 집중화\n\n테라폼은 각종 공용 클라우드, 개인 데이터 센터 및 SaaS 환경에서 인프라를 프로비저닝하고 관리하기 위한 일관된 워크플로우를 제공합니다. 이 가이드에서 다룬 패턴을 사용하면 다양한 API, 플랫폼 및 토폴로지를 연결하여 다중 클라우드 자동화 및 오케스트레이션을 더 쉽게 구현할 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-05-27-MasteringMulti-CloudManagementwithTerraform_0.png"},"coverImage":"/assets/img/2024-05-27-MasteringMulti-CloudManagementwithTerraform_0.png","tag":["Tech"],"readingTime":15}],"page":"1","totalPageCount":68,"totalPageGroupCount":4,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true}