{"pageProps":{"posts":[{"title":"기술 및 미디어 부문의 침체로 비윤리적인 기업들이 어떻게 이용하고 있는지 알아보기","description":"","date":"2024-05-23 13:07","slug":"2024-05-23-Howunscrupulouscompaniesaretakingadvantageofthedownturninthetechandmediasectors","content":"\n\n<img src=\"/assets/img/2024-05-23-Howunscrupulouscompaniesaretakingadvantageofthedownturninthetechandmediasectors_0.png\" />\n\n와이어드 기사인 \"테크 취업 면접이 어미잡아\"는 내 학생들이 얼마나 오랫동안 말해왔던 불쾌한 추세를 확인했어요. 몇몇 부도덕한 회사들이 취업 면접을 무료로 가치 있는 작업을 제공하도록 변형시키고 있어요.\n\n일주일 전, 한 MBA 학생이 사회 네트워크를 위한 콘텐츠를 몇 일 동안 생성하는 것을 포함한 선발 프로세스에 대한 경험을 나누었어요. 많은 전문 경험을 가진 사람들이 이런 작업을 하는 것을 요구하는 것은 \"그동안과 고생이 되었어요\"의 수준까지 이를 강요하는 것과 다를 바 없어요.\n\n기술과 미디어 기업이 대규모 인력 감축을 하고 있는 시기에, 일부 부도덕한 회사들이 개발자들에게, 예를 들어, \"데스크톱 어플리케이션을 처음부터 만들고, 백엔드 시스템 모형에 연결하고, 모든 단계를 철저히 문서화하라\" 또는 \"현재 어플리케이션에 대한 새로운 기능을 개발하고 문서화하라\"를 요구하고 있어요. 이 프로젝트들은 때로는 몇 일이 걸릴 수 있고, 후보자들은 보상받지 않은 채로 작업을 하게 되며, 제출 후 회사는 단순히 개발자에게 \"선발 프로세스에 실패했다\"고 말한 후 그 작업을 계속 사용할 수도 있어요.\n\n<div class=\"content-ad\"></div>\n\n이러한 채용 관행은 단순히 후보자들로 하여금 회사를 위해 무료로 일하도록 유도하는 방법에 불과합니다. 어떤 사람이 얼마나 그 일에 관심이 있더라도 받아들일 필요가 없으며, 이러한 관행은 거부되고 공개되어야 합니다. 윤리적이고 부도덕한 회사들에 대해 매우 주의해야 합니다. 시장 상황을 악용하여 자격있는 노동력을 착취하고 무료 노동을 얻을 수 있는 회사들입니다. 이러한 방식으로 일 하는 회사와의 전문적인 관계에서는 아무런 긍정적인 결과를 기대할 수 없습니다.","ogImage":{"url":"/assets/img/2024-05-23-Howunscrupulouscompaniesaretakingadvantageofthedownturninthetechandmediasectors_0.png"},"coverImage":"/assets/img/2024-05-23-Howunscrupulouscompaniesaretakingadvantageofthedownturninthetechandmediasectors_0.png","tag":["Tech"],"readingTime":1},{"title":"Salesforce 마케팅 클라우드에 WhatsApp 통합하기 단계별 가이드","description":"","date":"2024-05-23 13:06","slug":"2024-05-23-IntegratingWhatsAppintoSalesforceMarketingCloudAStep-by-StepGuide","content":"\n\n<img src=\"/assets/img/2024-05-23-IntegratingWhatsAppintoSalesforceMarketingCloudAStep-by-StepGuide_0.png\" />\n\n즉각적인 메시징 시대에 있어 WhatsApp와 Salesforce Marketing Cloud (SFMC)를 통합하면 고객과의 참여를 크게 향상시키고 커뮤니케이션을 간소화할 수 있습니다. 이 통합을 통해 기업은 WhatsApp의 대규모 사용자 기반과 실시간 커뮤니케이션 기능을 마케팅 자동화 워크플로 내에서 직접 활용할 수 있습니다. Salesforce Marketing Cloud에 WhatsApp를 통합하는 방법에 대한 포괄적인 안내서입니다.\n\n# 단계 1: 사전 요구 사항 이해\n\n• Salesforce Marketing Cloud 계정: 필요한 설정을 구성할 관리자 액세스 권한이 있는지 확인하세요.\n\n<div class=\"content-ad\"></div>\n\n• WhatsApp 비즈니스 계정: 공식 WhatsApp 비즈니스 솔루션 제공업체(BSP)를 통해 승인된 WhatsApp 비즈니스 계정이 필요합니다. \n\n• Twilio 계정: Twilio는 WhatsApp를 SFMC와 통합할 수 있게 해주는 인기있는 BSP입니다. 활성화된 Twilio 계정과 API 자격 증명을 보유하고 있는지 확인해주세요.\n\n# 단계 2: WhatsApp용 Twilio 설정하기\n\n1. Twilio 가입: Twilio에서 계정을 생성하고 Twilio Console로 이동하세요.\n\n<div class=\"content-ad\"></div>\n\n2. WhatsApp Business 신청: Twilio를 통해 WhatsApp 비즈니스 프로필을 제출하고 승인을 받으세요. 이 과정에는 비즈니스 정보 제공과 전화번호 인증이 포함됩니다.\n\n3. API 자격 증명 획득: 승인된 후 Twilio 계정 SID, Auth Token 및 WhatsApp 활성화된 전화번호를 받으세요.\n\n# 단계 3: Salesforce Marketing Cloud 구성\n\n1. Salesforce Marketing Cloud에 로그인: 관리자 자격 증명을 사용하여 SFMC 대시보드에 액세스하세요.\n\n<div class=\"content-ad\"></div>\n\n2. Mobile Studio로 이동하려면: SFMC 인터페이스에서 Mobile Studio로 이동합니다.\n\n3. WhatsApp 채널 만들기:\n\n- '관리'로 이동하고 '계정 설정'을 선택합니다.\n\n- '채널'을 클릭하고 'WhatsApp'을 선택합니다.\n\n<div class=\"content-ad\"></div>\n\n• 필요한 정보를 입력하세요. Twilio 계정 SID, 인증 토큰 및 WhatsApp 번호를 포함해야 합니다.\n\n4. 연락처 데이터 설정: SFMC의 연락처 데이터에는 전화번호가 WhatsApp 통신용으로 형식화되어 있어야 합니다. 이는 일반적으로 전화번호 앞에 0이나 특수 문자가 없는 국제 형식을 사용하는 것을 의미합니다.\n\n# 단계 4: WhatsApp 메시지 작성\n\n1. 메시지 템플릿 생성: WhatsApp은 비즈니스에서 시작된 대화에 대해 사전 승인된 메시지 템플릿이 필요합니다. Twilio에서 이러한 템플릿을 생성하고 승인을 요청하세요.\n\n<div class=\"content-ad\"></div>\n\n2. SFMC로 템플릿 가져오기: 승인되면 Salesforce Marketing Cloud에 이러한 템플릿을 가져옵니다.\n\n# 단계 5: SFMC에서 WhatsApp 캠페인 만들기\n\n1. Journey Builder: SFMC의 Journey Builder를 사용하여 WhatsApp을 커뮤니케이션 채널로 포함한 고객 여정을 만듭니다.\n\n- 고객 여정 워크플로에 'WhatsApp 전송' 활동을 끌어다 놓습니다.\n\n<div class=\"content-ad\"></div>\n\n• 미리 승인된 템플릿을 선택하고 연락처 데이터를 매핑하여 메시지를 개인화하세요.\n\n2. 자동화 스튜디오: 고객이 취한 특정 이벤트 또는 조치에 따라 WhatsApp 메시지를 트리거하는 자동화를 설정하세요.\n\n# 단계 6: 테스트 및 배포\n\n1. 통합 테스트: 라이브로 이동하기 전에 메시지가 올바르게 보내지고 수신되는지 확인하기 위해 철저한 테스트를 수행하세요.\n\n<div class=\"content-ad\"></div>\n\n2. 모니터링 및 최적화: 배포 후에는 SFMC의 분석 도구를 통해 WhatsApp 캠페인의 성능을 모니터링하고 최적화하세요. 참여 지표와 피드백에 기반하여 최적화하세요.\n\n시나리오: 소매 회사가 Salesforce Marketing Cloud 내에서 마케팅 및 서비스 업무에 WhatsApp을 통합하여 고객 지원 및 참여를 개선하고자 합니다.\n\n# 목표:\n\n1. WhatsApp을 통해 실시간 고객 지원 제공하기.\n\n<div class=\"content-ad\"></div>\n\n**솔루션:**\n\n- 실시간 지원: 고객은 지원 문제를 위해 WhatsApp을 통해 채팅을 시작할 수 있습니다. SFMC와의 통합을 통해 고객 서비스 담당자가 고객 데이터 및 상호 작용 기록에 액세스하여 신속하고 맞춤형 지원을 제공할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n• 프로모션 및 업데이트: 주문 확인, 배송 알림 및 개인 맞춤 프로모션 제공을 위해 자동화된 WhatsApp 메시지를 보낼 수 있어 고객들이 항상 정보를 받고 참여할 수 있도록 합니다.\n\n# 구현 단계별 순서:\n\n## 1. WhatsApp을 위한 Twilio 설정:\n\n## 2. SFMC 구성:\n\n<div class=\"content-ad\"></div>\n\n## 3. 메시지 템플릿 만들기:\n\n## 4. 고객 여정 구축:\n\n## • 환영 메시지:\n\n## • 주문 확인:\n\n<div class=\"content-ad\"></div>\n\n## • 배송 알림:\n\n## • 프로모션 제안:\n\n• SFMC의 분석 도구를 사용하여 WhatsApp 캠페인의 성능을 추적하세요.\n\n• 오픈률, 응답률 및 고객 피드백을 모니터링하세요.\n\n<div class=\"content-ad\"></div>\n\n• 데이터 통찰을 기반으로 메시지와 워크플로우를 지속적으로 최적화하세요.\n\n## • 맞춤화:\n\n고객 데이터를 활용하여 WhatsApp 메시지를 맞춤화하여 참여도와 응답률을 향상시킵니다.\n\n## • 준수:\n\n<div class=\"content-ad\"></div>\n\nWhatsApp의 비즈니스 정책과 GDPR와 같은 데이터 보호 규정을 준수해주세요.\n\n## • 세분화:\n\n대상을 분할하여 타겟팅된 및 관련성 있는 메시지를 보내어 캠페인의 효과를 향상시켜주세요.\n\nFollow Me:\n\n<div class=\"content-ad\"></div>\n\n루치카 산돌카 (함께成長합시다) 🫱🏻‍🫲🏽\n\n또는\n\n매일 Salesforce 업데이트를 받기 위해 WhatsApp 커뮤니티에 참여해주세요.\n\n참여하기 위해 스캔: 📲\n\n<div class=\"content-ad\"></div>\n\n`/assets/img/2024-05-23-IntegratingWhatsAppintoSalesforceMarketingCloudAStep-by-StepGuide_1.png`를 사용하려면 이미지 태그를 Markdown 형식으로 변경하면 됩니다.","ogImage":{"url":"/assets/img/2024-05-23-IntegratingWhatsAppintoSalesforceMarketingCloudAStep-by-StepGuide_0.png"},"coverImage":"/assets/img/2024-05-23-IntegratingWhatsAppintoSalesforceMarketingCloudAStep-by-StepGuide_0.png","tag":["Tech"],"readingTime":4},{"title":"프로그래머를 위한 11가지 어첈없이 간단한 수동 소득 아이디어","description":"","date":"2024-05-23 13:05","slug":"2024-05-23-11StupidSimplePassiveIncomeIdeasforProgrammers","content":"\n<img src=\"/assets/img/2024-05-23-11StupidSimplePassiveIncomeIdeasforProgrammers_0.png\" />\n\n프로그래머들은 창의적인 인간들이에요; 우리는 생각하고 혁신하고 만들어 냅니다.\n\n프로그래머가 되는 것도 중요하지만, 기업가적 사고를 갖춘 프로그래머가 되는 것은 또 다른 문제죠...\n\n그리고 지금 이 시점에서 이 기사를 읽고 계시다면, 여러분이 자신의 재정을 늘리기 위한 능력을 갖췄다고 믿어요.\n\n<div class=\"content-ad\"></div>\n\n이 글에서는 프로그래머를 위한 11가지 수동 소득 아이디어를 공유하겠습니다.\n\n별 거짓말 없이, 이것은 인터넷의 무작위 쓰레기가 아닌 다음과 같은 내용에 대한 심층적인 탐구입니다:\n\n- 프로그래머로써 시도해본 것 중 실제로 성공한 사례,\n- 현재 탐색 중인 새로운 긍정적인 통찰,\n- 동료들의 성공적인 사업 모험과 내부 기술 커뮤니티에서의 경험,\n- 제대로 하고 있는 프로그래머들과의 몇 가지 개인 인터뷰.\n\n바로 알아봅시다.\n\n<div class=\"content-ad\"></div>\n\n# 수동 소득 뒤의 진실\n\n수동 소득은 추가적인 노력이 없거나 최소한의 노력으로 주기적으로 돈을 발생시킬 때 이를 지칭합니다.\n\n가장 중요한 노력은 설정할 때 들이는 노력일 것입니다.\n\n사실은;\n\n<div class=\"content-ad\"></div>\n\n본질적으로 수동 소득은 당신이 직접 시간을 돈으로 교환할 필요가 없는 소득원입니다.\n\n수동 소득 사업의 3가지 핵심 특징이 있습니다:\n\n- 막대한 시간 또는 자본의 초기 투자.\n- 적극적인 작업 없이 완전히 설정된 후 소득 생성\n- 운영 유지에 필요한 최소의 노력.\n\n보통 알려진 수동 소득 아이디어와 아직 탐험되지 않은 수동 소득 아이디어에 대해 이야기해보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n프로그래머들을 위한 수익 창출 아이디어\n\n## 1. 블로깅\n\n프로그래머들이 수 pass 된소득을 발생시키는 가장 접근하기 쉬운 방법 중 하나는 블로깅이나 기술 콘텐츠 작성을 통해 이루어집니다.\n\n숙련된 프로그래머로서, 당신이 알려줄 수 있는 것들이 많습니다. 특히 새로운 개발자들에게 더 많은 것을 가르쳐줄 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n당신의 사고 패턴이나 프로세스/워크플로, 혹은 언어 전문 지식일 수 있습니다.\n\n개인 블로그를 시작하거나 Medium에 글을 쓰실 수도 있습니다.\n\n## 어떤 게 더 좋아요?\n\n저는 기술 블로그를 운영하고 있으며 Medium에도 글을 쓰고 있어요.\n\n<div class=\"content-ad\"></div>\n\n완전히 새로운 글쓰기에 입문하신 분이라면 Medium을 선택해보세요. 초보자에게 가장 적합한 글쓰기 플랫폼이에요.\n\n하지만 글을 쓰면서 돈을 벌 수 있는 방법은 무엇일까요? 처음 시작할 때 나도 궁금했던 문제였어요.\n\n여기서 간단히 알아보도록 할게요:\n\n- Medium 파트너 프로그램: Medium은 글을 쓰고 유료로 공개된 글에 게시하는 작가들에게 돈을 지급해요. Medium이 유료 사용자들로부터 수익을 올릴 때(프리미엄 글을 읽을 수 있는 사람들) 이익을 작가들과 분할해요.\n- 자체 호스팅된 블로그: 개인 블로그가 있다면 Ezoic, Mediavine 또는 Adthrive와 같은 품질 있는 광고 네트워크에 가입하여 수익을 창출할 수 있어요.\n- 제휴 마케팅과 후원: Medium/자체 호스팅 중 어느 플랫폼을 선택하든, 제휴 마케팅이나 후원을 통해 수익을 창출할 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n두 달 전에, 블로그에서 한 제품으로 제휴 마케팅으로 120달러 이상을 벌었어요.\n\n![이미지](/assets/img/2024-05-23-11StupidSimplePassiveIncomeIdeasforProgrammers_1.png)\n\n## 2. 온라인 강의\n\n자신이 잘하는 분야에 대한 강좌를 만들어보세요.\n\n<div class=\"content-ad\"></div>\n\n많은 사람들이 서면 자료 대신 비디오 강의를 선호합니다.\n\n최근 보고서에 따르면 2021년에만 Coursera에 2000만 명 이상의 신규 학습자가 등록했다고 합니다.\n\n일부 인기 있는 강의 플랫폼은 다음과 같습니다:\n\n- Udemy\n- Skillshare\n- Teachable\n\n<div class=\"content-ad\"></div>\n\n# 3. 유튜브 채널을 시작해보세요\n\n유튜브는 정보의 보고일 뿐만 아니라 Google 뒤를 이으며 두 번째로 큰 검색 엔진입니다.\n\n그러나 많은 사람들은 유튜브 채널을 시작하는 것을 힘든 작업으로만 생각하며, 특별한 사람들이나 대기업만이 할 수 있는 것으로 여기곤 합니다.\n\n하지만 이는 사실이 아닙니다. 저렴한 비디오 녹화 장비도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n아래 텍스트를 참고해주세요.\n\n\n![이미지](/assets/img/2024-05-23-11StupidSimplePassiveIncomeIdeasforProgrammers_2.png)\n\n다음으로 생각해볼 문제는:\n\n## 채널을 만들면 어떤 주제로 이야기할까요?\n\n이 모두는 당신의 전문 분야에 따라 다릅니다.\n\n\n<div class=\"content-ad\"></div>\n\n개발 스택이나 기술 면접에서 성공하기 위한 도움이 되는 비디오 가이드, 소프트웨어 엔지니어링, 웹/앱 개발 등과 관련된 것들이 있을 수 있어요.\n\n채널을 시작하기 전에 FreeCodeCamp와 같은 큰 브랜드일 필요는 없어요.\n\n## 4. 디지털 제품 판매\n\n대부분 이북, 치트 시트 및 일반 정보 제품을 가리킵니다.\n\n<div class=\"content-ad\"></div>\n\n작년에는 29달러에 데브옵스 전자책을 판매하는 개발자와 인터뷰를 했어요. 그 책은 초보자를 위한 가이드처럼 보이는데, 그의 판매 대부분은 트위터 청중에서 나옵니다. 한 달에 약 1300달러를 벌어요.\n\nGumroad와 같은 플랫폼은 디지털 제품을 판매하고 수동 소득을 얻기 위한 마켓플레이스를 제공해요.\n\n# 5. 웹사이트 테마 및 템플릿 판매:\n\n프로그래머들에게 이는 매우 수익성 높은 수동 소득 사업임이 입증되었어요.\n\n<div class=\"content-ad\"></div>\n\n다음 웹 사이트 테마, 템플릿 및 플러그인을 판매할 수 있어요:\n\n- 테마 포레스트\n- 사이트 포인트\n- 템플릿 몬스터\n- 모조 마켓플레이스\n- 크리에이티브 마켓\n- 테마스냅\n- 코데스터\n\n![이미지](/assets/img/2024-05-23-11StupidSimplePassiveIncomeIdeasforProgrammers_3.png)\n\n일반 판매 플랫폼 외에도 특정 CMS 마켓플레이스로도 직접 판매할 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n예를 들어, 다음과 같은 것들을 판매할 수 있어요:\n\n- Shopify 마켓플레이스에서 전자 상거래 테마\n- Ghost 마켓플레이스에서 Ghost 웹사이트 테마\n- WordPress.org에서 WordPress 웹사이트 테마\n\n# 6. 코드, 스크립트 및 플러그인 판매\n\nCMS 테마 이외에도, Code Canyon과 같은 웹사이트에서 직접 프로그래밍 코드, 스크립트 및 플러그인을 판매할 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n부트스트랩, 자바스크립트, PHP, HTML5, 모바일/안드로이드 앱 템플릿 및 기타 코드 및 스크립트를 판매할 수 있습니다.\n\n여기에 Ladela가 디자인한 예약 및 일정 관리 소프트웨어 시스템 플러그인이 있어요.\n\nCode Canyon에서 $89에 판매 중이에요.\n\n이 기사를 작성하는 시점에서 52,525번의 판매로 총 $4,000,000 이상의 매출을 기록했어요.\n\n<div class=\"content-ad\"></div>\n\n\n![image](/assets/img/2024-05-23-11StupidSimplePassiveIncomeIdeasforProgrammers_4.png)\n\n# 7. API 개발\n\n소프트웨어 응용 프로그램이 증가함에 따라 API 서비스에 대한 수요가 증가하고 있습니다.\n\n실제 문제를 해결하거나 개발자에게 가치 있는 서비스를 제공하는 API (Application Programming Interfaces)를 개발하고 활용하세요.\n\n\n<div class=\"content-ad\"></div>\n\n접근을 유료로 제공하거나 계층별 요금제를 제공함으로써, 개발자가 API 서비스를 구독하는 동안 수동 소득을 얻을 수 있습니다.\n\n# 8. 크롬 확장 프로그램 만들기\n\n네, 맞아요. 크롬 확장 프로그램을 만들어 돈을 벌 수 있습니다.\n\n기술 기업가인 김 댕은 그녀의 크롬 확장 프로그램인 Group Convert로 100만 달러 이상을 벌었습니다.\n\n<div class=\"content-ad\"></div>\n\n4,000 회 이상의 설치를 보유하고 있으며 매월 $10에서 $17까지의 가격대를 가지고 있어요.\n\n김의 기능 확장은 Facebook 그룹 소유자가 그룹에 들어올 때 Facebook 사용자로부터 이메일을 수집하는 데 도움을 줘요.\n\n이 수동 소득 아이디어는 들리는 대로 쉽지 않지만 할만해요.\n\n# 9. 봇 생성\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-05-23-11StupidSimplePassiveIncomeIdeasforProgrammers_5.png\" />\n\n봇은 고객 서비스부터 소셜 미디어 관리까지 다양한 플랫폼에서 작업을 자동화하는 데 중요한 역할을 합니다.\n\n특정 사용 사례나 산업을 대상으로 하는 봇을 개발할 수 있습니다. 예를 들어 고객 지원용 챗봇이나 금융 시장용 거래 봇 등이 있습니다.\n\n한 번 배포되고 운영 중이면 구독 요금제나 사용량 기반 가격 책정을 통해 패시브 수입을 얻을 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 10. iOS 및 Android 애플리케이션 출시\n\n안드로이드 앱 개발자를 위해 특별히 디자인된 이 수동 수입 사업은 모바일 앱 개발자들을 대상으로 합니다.\n\n많은 앱들이 매일 Play 스토어와 App Store에서 출시되지만, 높은 경쟁으로 인해 소수만이 성공을 거두고 있습니다.\n\nSteven Benson은 혁신적인 경로 계획 앱인 Badger Maps를 설립했습니다.\n\n<div class=\"content-ad\"></div>\n\n\n![Image](/assets/img/2024-05-23-11StupidSimplePassiveIncomeIdeasforProgrammers_6.png)\n\nWorking with a small team, he was able to quickly scale revenue to $6M ARR within a couple of years. I shared insights from an interview with him in a separate Medium article.\n\n# 11. Creating a SaaS or Micro SaaS\n\nThe last on the list and also what I'll consider the holy grail of passive income generation for programmers as it can lead to very high returns when done right.\n\n\n<div class=\"content-ad\"></div>\n\n인기 있는 SaaS 제품의 예시는 다음과 같습니다:\n\n- 프로젝트 관리를 위한 ClickUp.\n- 실시간 채팅을 위한 Zendesk.\n- 랜딩 페이지 제작을 위한 Leadpages.\n- 마케팅 보고서를 위한 Whatagraph.\n- 자동 PDF 생성을 위한 JotForm PDF 편집기.\n- 파일 및 문서 관리를 위한 Bit.ai.\n- 링크 관리를 위한 Bitly.\n- 일페이지 웹사이트 구축을 위한 Carrd.\n\n일주일 전에 여기에서 두 친구가 SaaS 비즈니스를 55,000 달러의 월 평균 반복 수익으로 확장한 방법에 대한 기사를 게시했어. 한번 확인해봐.\n\nSaaS 비즈니스를 구독 기반 가격으로 제공함으로써, 지속적인 반복 수익을 창출하고 지속 가능한 수 pass받는 소득원을 구축할 수 있어.\n\n<div class=\"content-ad\"></div>\n\n## 주의:\n\n무엇을 도와드릴까요?\n\n- 제 뉴스레터 가입하기 (글 작가 창업가를 위한 프리미어 뉴스레터).\n- 제 미디엄 계정 팔로우하기 (가치 있는 정보를 얻을 수 있습니다).\n","ogImage":{"url":"/assets/img/2024-05-23-11StupidSimplePassiveIncomeIdeasforProgrammers_0.png"},"coverImage":"/assets/img/2024-05-23-11StupidSimplePassiveIncomeIdeasforProgrammers_0.png","tag":["Tech"],"readingTime":7},{"title":"자바 개발자로 성장하기 위한 자료와 로드맵","description":"","date":"2024-05-23 13:03","slug":"2024-05-23-ResourcesandRoadmaptoUpgradeasaJavaDeveloper","content":"\n\n## DSA, 데이터베이스, 시스템 설계, 객체지향 프로그래밍, 자바, 테스팅, 그리고 더 많은 것들…\n\n![2024-05-23-ResourcesandRoadmaptoUpgradeasaJavaDeveloper_0](/assets/img/2024-05-23-ResourcesandRoadmaptoUpgradeasaJavaDeveloper_0.png)\n\n안녕하세요, 독자 여러분! 저는 인도 마이크로소프트에서 5년의 산업 경험을 가진 소프트웨어 엔지니어 II입니다.\n\nLinkedIn, Medium, 그리고 친구들로부터 제가 발전하기 위해 사용한 자원에 관한 메시지를 많이 받았어요. 기다리셨던 대로요! 이제 내가 항상 활용하는 자원들을 여러분과 공유하려고 합니다.\n\n<div class=\"content-ad\"></div>\n\n저는 현재 마이크로소프트에서 근무하기 전 주로 Java에 대한 배경을 가지고 있었습니다. 이 영역에서 자원과 고급 기술을 공유하는 데 초점을 맞출 것입니다. 하지만 다른 분야에서도 일반적인 자원 및 IT 산업에서 업그레이드하는 로드맵을 참고할 수 있습니다.\n\n## 참고 — 블로그 안내\n\n- 이 블로그에는 제가 배운 것과 경험한 것이 담겨 있습니다. 모든 것에 동의하지 않을 수도 있습니다. 각 개발자에게는 다른 여정이 있습니다.\n- 이 분야에서 전진하기 위한 순차적 기술과 이정표, 필수 기술 및 전문가 팁을 강조하는 로드맵을 공유할 것입니다. 또한 인터뷰에서 가장 많이 물어보는 주제들을 언급할 것입니다.\n- 또한 내 프로젝트에서 거의 학습하고 공식 튜토리얼을 참조하지 않은 많은 도구들을 실제로 사용한 리소스를 공유할 것입니다.\n- 섹션 사이에 관련된 Medium 블로그를 공유할 것입니다.\n- 자세히 읽어보시고 빠뜨리지 않도록 마지막까지 읽어주시기 바랍니다.\n\n질문이 있으면 언제든지 물어보시거나 LinkedIn에서 DM을 보내주시기 바랍니다.\n\n<div class=\"content-ad\"></div>\n\n# 로드맵과 자원\n\n## 1. 기초 지식\n\n## Java 핵심:\n\nJava와 여러분이 주력으로 하는 언어에서 전문가가 되도록 노력하세요. 여러분이 뛰어난 분야를 가지는 것은 유익합니다.\n\n<div class=\"content-ad\"></div>\n\n개발자님 안녕하세요!\n\n다양한 회사에서 일반적인 인터뷰를 실시하기 때문에 언어는 영구적으로 변경될 수 있어요. 특히 제품 중심 회사들이 그렇죠.\n\n저는 자바 개발자로 시작했지만 스칼라, 파이썬으로도 일해봤고 이제는 C++과 C#으로 작업 중이에요.\n\n제 자료: Java Tutorial | Learn Java Programming — javatpoint\n\n## 객체 지향 프로그래밍 (OOPs):\n\n<div class=\"content-ad\"></div>\n\n각 개념의 중요성을 이해하고 문제를 실질적으로 해결하는 방법을 배웁시다.\n\n내 자료: 자바 OOPs 개념 — Javatpoint\n\n## 데이터 구조와 알고리즘 (DSA):\n\n문제 해결을 위한 필수 데이터 구조와 알고리즘을 마스터하는 것이 중요합니다. 제품 중심 기업에서의 면접을 성공적으로 통과하는 데 필수적입니다.\n\n<div class=\"content-ad\"></div>\n\n요즘에는 서비스 기반 조직들도 클라이언트의 요구에 따라 DSA 질문을 하기도 합니다.\n\nDSA는 논리 개발과 알고리즘 구축에도 유용합니다. 예를 들어, 저는 은행 분야 프로젝트에서 슬라이딩 윈도우 기법을 활용한 적이 있습니다.\n\n나의 자료:\n\n- Scott Barrett의 \"Java 자료 구조 및 알고리즘 + LEETCODE 연습\" (Udemy)\n- Tim Buchalka, Goran Lochert의 \"자바를 사용한 자료 구조 및 알고리즘 심층 탐구\" (Udemy)\n- LeetCode (매일 연습)\n\n<div class=\"content-ad\"></div>\n\n## 2. 중급 스킬\n\n## 멀티스레딩, 동시성, 병렬성:\n\n많은 영역에서 중요하고 널리 사용되며, 회사들은 인터뷰 중 이러한 영역에 대한 능숙함을 기대하기도 합니다.\n\n저는 내 인터뷰 중 대략 60% 정도에서 이러한 주제에 관한 질문을 받았습니다.\n\n<div class=\"content-ad\"></div>\n\n내 자료:\n\n- Java 멀티스레딩, 병행성 및 성능 최적화 — Michael Pogrebinsky (Udemy)\n- Peter Lee의 글: 자바에서의 병행성과 병렬성 | Peter Lee | Medium\n- Multiprogramming vs Multiprocessing vs Multitasking vs Multithreading — Javatpoint\n- G. Abhisek의 글: 병행성, 병렬성, 스레드, 프로세스, 비동기 및 동기 — 관련되어 있나요? 🤔 | G. Abhisek | Swift India | Medium\n\n## 기본 원리, 프레임워크 및 데이터베이스:\n\nSpring Framework: 자바 개발자로서 계속 발전하려면, 의존성 주입, 제어의 역전, 그리고 관점 지향 프로그래밍과 같은 중요한 Spring Framework 개념을 탐구하고 Spring Core, Spring Data, Spring MVC 및 기타 관련 Spring 개념을 다루는 것이 중요합니다.\n\n<div class=\"content-ad\"></div>\n\n나의 자원: Spring 튜토리얼 | Baeldung\n\nMySQL: 이것은 중요하며 프로젝트와 인터뷰에서 관계형 데이터베이스, SQL 쿼리 및 데이터베이스 설계 작업에 능숙해지기 위해 항상 필요할 것입니다. \n\nHibernate: 처음에는 ORM(Object-Relational Mapping)에 대해 알아야 하고 Hibernate를 사용하여 데이터베이스와 상호 작용하는 방법을 알아야 했습니다.\n\n소프트웨어 디자인 원칙: 경험 많은 개발자로서 반드시 갖춰야 할 기술은 최적화된 시스템을 설계하는 것이므로 면접이나 지식 습득 시 빠뜨리지 마세요.\n\n<div class=\"content-ad\"></div>\n\n테이블 태그를 마크다운 형식으로 변경해주세요.\n\n<div class=\"content-ad\"></div>\n\n소프트웨어 디자인 원리:\n\n- 디자인 원칙 - 상속보다는 조합을 선호합니다 | LinkedIn\n- 소프트웨어 디자인 원리 | 추상화, 확장성, 응집도 (workat.tech)\n- 예제로 배우는 자바에서의 상속보다는 조합 선호하기 - GeeksforGeeks\n- 의존성 주입에 대한 빠른 소개: 무엇인지 및 언제 사용해야 하는지 (freecodecamp.org)\n- 소프트웨어 디자인 원리 (기본) | DRY, YAGNI, KISS 등 (workat.tech)\n\n## 3. 고급 기술\n\n## 스프링 부트:\n\n<div class=\"content-ad\"></div>\n\n스프링 부트는 스프링 플랫폼에 추가된 기능으로, 설정보다는 규약에 중점을 둔다.\n\n스프링 부트를 사용하여 서비스 및 웹 애플리케이션을 구축하는 방법에 대해 알아보세요.\n\n내 자료: Spring Boot 배우기 | Baeldung\n\n## 마이크로서비스 아키텍처:\n\n<div class=\"content-ad\"></div>\n\n제 3부에서 언급했지만, 요즘 개발자 인터뷰에서 가장 많이 묻는 주제 중 하나에요.\n\n마이크로서비스의 원리를 이해하고, 설계하고, 구현하고, 배포하는 방법을 알아보세요.\n\n## Apache Kafka/RabbitMQ:\n\n이것들은 개발자에게 추가로 좋은 기술들이에요. 널리 사용되며 개발자의 실용적인 지식을 향상시킬 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n스케일러블하고 분산 시스템을 구축하기 위한 메시지 브로커에 대해 알아보세요.\n\n가장 중요한 것은 모든 것을 왜 필요로 하는지 알아야 합니다 (왜 처음부터 그들이 필요한지).\n\n내 자료: Apache Kafka 튜토리얼 시리즈 힌디어 버전 - YouTube\n\n## AWS:\n\n<div class=\"content-ad\"></div>\n\nAWS 및 AWS, Azure, GCP 등과 같은 모든 클라우드 서비스는 중요합니다. 매일 다른 취직 공고에서 이에 관한 언급을 찾을 수 있을 거에요.\n\n회사들은 시니어 개발자들이 클라우드 플랫폼 서비스에 대해 실무 경험이 있어야 한다고 기대하며, 최소한 입문자 수준에서도 공통적인 서비스에 대한 경험이 필요합니다.\n\n이미 이러한 프로젝트 경험이 있나요? 와! 없다면, 오늘부터 시작해 볼까요? 직접 POC(Concept of Proof)를 해보세요.\n\n호스팅, 저장 및 컴퓨팅을 위한 클라우드 서비스를 탐색해보세요. 여기서 배운 것의 \"무엇\"과 \"왜\"도 알아야 합니다.\n\n<div class=\"content-ad\"></div>\n\n내 자료: [NEW] Ultimate AWS Certified Cloud Practitioner CLF-C02 — by Stephane Maarek (Udemy)\n\n## 4. 전문분야\n\n## REST API:\n\nRESTful API를 설계하고 구현하는 방법을 배워보세요. 마이크로서비스에서 RESTful API가 널리 사용되고 개발자들로부터 기대되므로 이를 숙지하는 것이 중요합니다.\n\n<div class=\"content-ad\"></div>\n\n## 통합 테스팅 및 유닛 테스팅:\n\n분산 시스템에서 컴포넌트 간의 통합 테스팅 및 독립적인 컴포넌트의 유닛 테스팅하는 중요성과 방법에 대해 이해합니다.\n\nJUnit, Mockito, Cucumber, 그리고 Chai(node.js)와 같은 도구들이 유명합니다.\n\n유닛 테스트는 온라인 평가 및 머신 코딩 인터뷰 라운드의 일부가 되기도 합니다.\n\n<div class=\"content-ad\"></div>\n\n그 외에도, 이러한 것들은 개발자가 코드에서 채택해야 하는 매우 유익한 관행들입니다.\n\n## 시스템 설계:\n\n여기서 고수준 설계 (HLDs)와 저수준 설계 (LLDs) 같은 용어가 나옵니다.\n\nSSEs에서는 HLDs가 깊게 다뤄지며, LLDs는 상위 수준에서 기대됩니다. 기본 LLDs도 SSEs로부터 요청될 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n그래서, 확장 가능하고 신뢰할 수 있는 시스템을 설계하는 기술을 숙달해보세요. 어떤 구성 요소를 사용할지, 왜 사용하는지, 그리고 어떻게 사용할지를 알아야 합니다.\n\n시스템 설계는 가장 많은 반문이 있는 면접 라운드입니다. 따라서 시스템 설계 질문에 대한 각 구성 요소의 요구 사항을 매우 잘 이해해야 합니다.\n\n나의 자료:\n\n- 시스템 설계 튜토리얼 — GeekforGeeks\n- 초보자를 위한 시스템 설계 — YouTube\n\n<div class=\"content-ad\"></div>\n\n## 5. 도구 및 기술\n\nGit, Maven, Gradle: 개발자들이 알아야 하는 기본적인 도구로 버전 관리, 의존성 관리 및 빌드 자동화 도구가 포함됩니다.\n\nDocker, Kubernetes: 애플리케이션을 배포하고 관리하기 위한 컨테이너화 및 오케스트레이션을 탐색해보세요.\n\nJenkins, JIRA: Agile 개발을 위한 CI/CD 파이프라인과 프로젝트 관리 도구에 대해 이해해보세요.\n\n<div class=\"content-ad\"></div>\n\n## 6. 전문 기술\n\n- 커뮤니케이션: 팀원 및 이해관계자들과 효율적인 협업을 위해 커뮤니케이션 기술 향상하기.\n\n- 리더십과 팀 관리: 프로젝트를 성공적으로 완료하기 위해 팀을 리드하고 관리하는 방법 익히기. 시니어 개발자로서 중요한 기술이에요.\n\n- 애자일 방법론: 요즘은 거의 80% 이상의 회사가 인터뷰 후보자가 스크럼이나 칸반 등 애자일 원칙 및 방법론, 그리고 JIRA, Confluence, SDLC와 같은 도구에 대해 이해하거나 경험이 있기를 기대해요.\n\n<div class=\"content-ad\"></div>\n\n## 요약\n\n저는 수준별로 모든 것을 나열했습니다.\n\nDSA와 함께 '||'가 있으면 DSA가 다른 모든 수준과 병렬로 처리될 수 있음을 나타내며 (이상적으로는 절대 중지하면 안 됨).\n\n2024년 현재 Java 개발자에게 필요한 최고의 기술은 DSA, 시스템 디자인, Java, 마이크로서비스, Spring Boot, AWS/Azure와 같은 클라우드 플랫폼, Apache Kafka/RabbitMQ와 같은 메시지 브로커, MySQL과 같은 데이터베이스, 그리고 Redis와 같은 캐싱 메커니즘이 있습니다.\n\n<div class=\"content-ad\"></div>\n\n경험 많은 직원들에게 기대되는 기본적인 기술은 Git, CI/CD 파이프라인에 대한 이해, 그리고 자동화 도구 구축입니다.\n\n오늘날 인터뷰에서는 'Docker'와 'Kubernetes'와 같은 용어가 특히 강조됩니다.\n\nGitHub Actions, Telemetry, Spinnaker, Datadog, New Relic 등의 APM 도구는 추가 요건으로 고려됩니다.\n\n지금까지 만난 가장 중요한 기술들이며 이러한 분야에서 뛰어나거나 이를 뛰어넘는다면 다수의 개발자들 사이에서 돋보이게 되어 어려운 인터뷰에 성공하거나 MAANGs와 같은 주요 기술 회사에서 취업할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n현재 학습하거나 복습하고 있는 개념이 있나요? 저는 레벨 5에 있어서 Docker와 Kubernetes를 배우고 있어요.\n\n또한, 아래 블로그들도 확인해보세요:\n\n질문이 있으면 답글로 물어보시거나 LinkedIn에서 메시지를 보내주세요. 또한, 다음에 다루고 싶은 다른 주제가 있다면 제안해주세요.","ogImage":{"url":"/assets/img/2024-05-23-ResourcesandRoadmaptoUpgradeasaJavaDeveloper_0.png"},"coverImage":"/assets/img/2024-05-23-ResourcesandRoadmaptoUpgradeasaJavaDeveloper_0.png","tag":["Tech"],"readingTime":7},{"title":"2024년에 경력있는 Java 개발자를 위한 카프카 인터뷰 질문","description":"","date":"2024-05-23 12:57","slug":"2024-05-23-KafkaInterviewQuestionforexperiencedJavadeveloperin2024","content":"\n\n## 안녕하세요 여러분, 카프카와 관련된 또 다른 기사에 오신 것을 환영합니다. 요즘 대부분의 기술 인터뷰에서 자바, 프런트엔드, 백엔드 및 풀스택 개발자 인터뷰에서 카프카 관련 질문이 나온다고 하죠. 하지만 왜 그럴까요? 분산 환경에서 여러 애플리케이션을 연결하기 위해 미들웨어가 필요하고 카프카는 인기 있는 미들웨어이면서 매우 강력합니다. 업계는 이를 신속하게 채택했기 때문에 카프카는 인터뷰에서 중요하다고 할 수 있습니다. 이제 물어볼 수 있는 질문 유형으로 들어가보겠습니다. 초보자나 신입 개발자는 이 부분을 건너 뛰어도 됩니다.\n\n![이미지](/assets/img/2024-05-23-KafkaInterviewQuestionforexperiencedJavadeveloperin2024_0.png)\n\n## 왜 카프카가 기술 산업에서 사용되며 왜 인기가 많을까요?\n\n아파치 카프카는 기술 산업에서 인기가 많은데, 그 이유는 몇 가지 주요한 이유로 인해입니다:\n\n<div class=\"content-ad\"></div>\n\n- 높은 처리량과 낮은 지연 시간: Kafka는 대량의 메시지를 신속하게 처리하여 실시간 데이터 처리에 적합합니다.\n- 확장성: Kafka의 분산 아키텍처로 수평적 확장이 가능하며, 더 많은 노드를 추가함으로써 데이터 요구량을 수용할 수 있습니다.\n- 고장 허용성 및 신뢰성: Kafka는 복제와 파티셔닝을 통해 데이터의 내구성과 신뢰성을 보장하여 일부 노드가 실패해도 작업을 유지합니다.\n- 스트림 처리: Kafka Streams를 사용하면 복잡한 실시간 데이터 처리 응용프로그램을 구축할 수 있습니다.\n- 데이터 통합: Kafka는 다양한 소스에서 데이터를 통합하고 여러 시스템에 분산하는 중앙 허브 역할을 합니다.\n- 오픈 소스 및 커뮤니티 지원: Kafka는 계속해서 기능을 개선하고 확장하는 거대하고 활발한 커뮤니티의 혜택을 받습니다.\n- 다양한 사용 사례: Kafka는 로그 집계, 실시간 분석, 이벤트 소싱, 메시징 및 메트릭 수집에 사용됩니다.\n- 대형 데이터 생태계와의 호환성: Kafka는 하둡, 스파크, 엘라스틱서치와 같은 기술과 잘 통합되어 종합적인 데이터 파이프라인을 용이하게 합니다.\n- 간소화된 데이터 처리: Kafka는 비동기 처리를 통해 시스템 성능과 신뢰성을 향상시킵니다.\n\nLinkedIn, Netflix, Uber, Airbnb와 같은 주요 기술 기업은 Kafka를 강력하고 확장 가능하며 효율적인 실시간 데이터 처리 능력으로 사용하며, 생산 환경에서의 효과를 입증하고 있습니다.\n\n경험이 풍부한 개발자로서, 면접에서 Kafka 지식에 대한 강한 수요를 알아챘습니다. 다른 분들이 준비하는 데 도움이 되도록, Kafka에 관한 질문 및 답변 세션을 게시할 예정입니다. 만나서 질문과 의견을 자유롭게 남겨주세요!\n\n## Kafka의 주요 구성 요소는 무엇인가요? (프로듀서, 컨슈머, 브로커, 토픽, 주키퍼)\n\n<div class=\"content-ad\"></div>\n\n프로듀서: 이들은 데이터 스트림을 Kafka에 발행하는 애플리케이션이나 서비스입니다. 특정 카테고리나 피드인 토픽에 메시지를 작성합니다 (아래에서 설명됨). 프로듀서들은 소비자와 직접 상호작용하지 않고 Kafka로 데이터를 발행합니다.\n\n컨슈머: 이들은 토픽을 구독하고 프로듀서가 발행한 데이터 스트림을 읽는 애플리케이션이나 서비스입니다. 컨슈머들은 메시지 처리 방법을 조정하기 위해 컨슈머 그룹에 속할 수 있습니다 (아래 설명됨).\n\n토픽: 토픽을 데이터 스트림을 위한 명명된 카테고리나 피드로 생각해보세요. 프로듀서들은 특정 토픽에 데이터를 발행하고, 컨슈머들은 해당 토픽을 구독하여 데이터를 받습니다.\n\n브로커: 이들은 Kafka 클러스터를 형성하는 서버들입니다. 단일 Kafka 클러스터는 함께 작동하는 하나 이상의 브로커를 가질 수 있습니다. 브로커들은 프로듀서가 발행한 메시지를 저장하고 이를 컨슈머에 제공합니다. 메시지 복제, 파티션 관리 (아래에서 설명됨) 및 전체 Kafka 클러스터 조정을 담당합니다.\n\n<div class=\"content-ad\"></div>\n\nZookeeper: 카프카 클러스터의 상태를 관리하는 외부 서비스인 Zookeeper. 토픽, 브로커, 소비자 그룹을 추적하여 클러스터 내에서 모든 것이 원활하게 작동하도록 합니다. 조정에 중요하지만, Zookeeper 자체는 실제 데이터 메시지를 저장하지는 않습니다.\n\n이러한 구성 요소는 실시간 데이터 파이프라인을 처리하는 강력하고 확장 가능한 플랫폼으로 함께 작동합니다.\n\n## Kafka는 내구성과 오류 허용을 어떻게 보장하나요? (복제)\n\nKafka는 주로 복제라는 기술을 통해 데이터 내구성과 오류 허용을 보장합니다. 작동 방식은 다음과 같습니다:\n\n<div class=\"content-ad\"></div>\n\n- 토픽 및 파티션: Kafka 토픽은 데이터 스트림의 범주입니다. 내부적으로 각 토픽은 파티션이라고 하는 작은 순서대로 정렬된 세그먼트로 나뉩니다. 이 파티션은 병렬 처리와 확장성을 가능하게 합니다.\n- 복제 팩터: 각 파티션은 Kafka 클러스터 내의 여러 브로커에 걸쳐 복제됩니다. 파티션의 복사본 수는 복제 팩터라는 구성 매개변수에 의해 결정됩니다. 더 높은 복제 팩터는 더 큰 장애 허용성을 보장합니다.\n- 리더와 팔로워: 파티션의 복사본 중 하나의 브로커가 리더로 지정됩니다. 리더는 프로듀서로부터 쓰기를 받아들이고, 이를 다른 복제본인 팔로워에게 복제합니다.\n- 데이터 지속성: 모든 브로커는 데이터(메시지)를 디스크에 지속합니다. 이를 통해 브로커가 실패하더라도 데이터가 손실되지 않습니다. 팔로워는 리더와 파티션 데이터의 동기화를 유지합니다.\n- 리더 장애 및 복구: 리더 브로커가 실패하면 Kafka는 자동으로 리더 선출 프로세스를 트리거합니다. 동기화된 팔로워 중 하나가 새 리더가 되며, 데이터 복제가 계속됩니다. 소비자는 새로운 리더에서 데이터를 최소한의 중단으로 계속 읽을 수 있습니다.\n\n프로듀서 확인: 추가로, Kafka는 내구성 보증에 영향을 주는 프로듀서 확인 설정을 제공합니다:\n\n- acks=all: 이 설정은 최대 내구성을 보장합니다. 프로듀서는 모든 복제본으로부터 확인을 받기 전에 쓰기를 성공으로 간주합니다.\n- acks=1 (기본값): 프로듀서는 리더 복제본만 확인을 받기를 기다립니다. 이는 내구성과 성능 사이의 균형을 제공합니다.\n\n복제 및 확인 전략을 통해 Kafka는 브로커 장애로 인한 데이터 손실을 방지합니다. 브로커가 다운되어도 해당 데이터는 복제본에 유지되어 시스템이 복구하고 운영을 계속할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n카프카의 내결함 허용성에 기여하는 다른 요소들이 있지만, 복제가 핵심 메커니즘입니다.\n\n## 카프카에서 리더 및 팔로워 복제본의 차이점을 설명해주세요.\n\n데이터가 토픽으로 구성되고 확장성을 위해 파티션으로 더 나눠지는 카프카 클러스터에서, 리더 및 팔로워 복제본은 데이터 가용성과 내결함성을 보장하기 위해 중요한 역할을 합니다. 이들 간 주요 차이점은 다음과 같습니다:\n\n리더 복제본:\n\n<div class=\"content-ad\"></div>\n\n- 책임:\n  - 배정된 파티션에 대한 생산자로부터 쓰기(새 메시지)를 수락합니다.\n  - 받은 메시지를 같은 파티션에 대한 모든 팔로워 레플리카에 복제합니다.\n  - 안전하게 저장되고 소비할 수 있는 메시지의 지점을 나타내는 확정 오프셋을 결정합니다.\n  - 소비자로부터의 읽기 요청을 처리합니다 (일반적으로 소비자는 아래에서 설명하는 동기화된 레플리카 세트와 주로 상호 작용합니다).\n- 선출: 리더는 파티션 내의 레플리카 중에서 선출됩니다. 이 선출은 브로커 시작 시 자동으로, 리더의 실패 시 또는 리더가 심각하게 뒤처지는 경우에 발생합니다.\n\nFollower 레플리카:\n\n- 책임:\n  - 리더로부터 복제된 메시지를 수동으로 소비합니다.\n  - 받은 메시지를 자체 로그에 적용하여 해당 파티션 데이터의 사본을 리더와 동기화 상태로 유지합니다.\n  - 복제가 성공한 경우 리더를 승인합니다.\n- 중요성: 팔로워는 리더의 실패 시 데이터 가용성을 보장하고 중복성을 제공합니다. 리더 선출이 발생할 때 팔로워는 파티션 기능을 유지하기 위해 새 리더가 될 수 있습니다.\n\n## 소비자 그룹이란 무엇이며 어떻게 작동합니까?\n\n<div class=\"content-ad\"></div>\n\n소비자 그룹은 Kafka에서 데이터 스트림의 병렬 처리를 가능하게 하고 각 메시지가 그룹 내 정확히 하나의 소비자에 전달되도록 하는 기본적인 개념입니다. 다음은 그들이 작동하는 방식입니다:\n\n소비자 그룹 지정하기:\n\n- 소비자들은 group.id라는 고유 식별자를 사용하여 그룹화될 수 있습니다. 동일 그룹에 속한 소비자들은 소비자 그룹으로 식별됩니다.\n- 소비자 인스턴스는 구성 중에 그룹 소속을 지정합니다.\n\n부하 분산 및 병렬 처리:\n\n<div class=\"content-ad\"></div>\n\n- 소비자 그룹이 주제를 구독하면 해당 주제의 파티션은 그룹 내의 소비자들 사이에 자동으로 나눠집니다. 이 분배는 소비자와 파티션의 수에 기반하여 균형을 유지하도록 지능적으로 이루어집니다.\n- 그룹 내 각 소비자는 할당된 파티션에서 메시지를 처리하는 책임이 있습니다. 이 병렬 처리를 통해 소비자 그룹이 대량의 데이터를 효율적으로 처리할 수 있습니다.\n\n소비자 독점성:\n\n- 소비자 그룹의 중요한 측면은 그룹 내 하나의 소비자에게만 메시지가 전달된다는 것입니다. 이를 통해 중복 처리가 방지되고 데이터 일관성이 보장됩니다. Kafka는 각 소비자 그룹에 대한 상태를 유지하고 현재 파티션 할당을 추적함으로써 이를 달성합니다.\n\n소비자 리밸런싱:\n\n<div class=\"content-ad\"></div>\n\n- 파티션의 분배는 소비자들 사이에서 동적으로 변경될 수 있습니다. 이는 다음과 같은 시나리오에서 발생합니다:\n  - 소비자가 그룹에 가입하거나 나가는 경우.\n  - 브로커의 장애로 인해 파티션 재할당이 필요한 경우.\n  - 카프카가 이러한 상황에서 소비자 리밸런싱이라는 프로세스를 트리거합니다. 리밸런싱은 나머지 소비자들 사이에서 파티션 할당을 재조정하여 균형있는 처리를 유지하는 과정을 말합니다.\n\n소비자 그룹의 장점:\n\n- 병렬 처리: 대용량 데이터 스트림을 효율적으로 처리할 수 있습니다.\n- 확장성: 그룹에서 소비자를 추가하거나 제거함으로써 쉽게 소비자 처리를 확장할 수 있습니다.\n- 내고장성: 소비자가 실패하면 해당 소비자의 파티션이 그룹 내 다른 소비자로 재할당되어 데이터 처리가 계속됩니다.\n- 정확히 한 번 전달 (구성에 따라): 올바르게 구성된 경우, 소비자 그룹은 그룹 내의 각 메시지가 정확히 한 번만 정확히 한 소비자에게 전달되도록 보장할 수 있습니다.\n\n소비자 그룹 사용 사례:\n\n<div class=\"content-ad\"></div>\n\n소비자 그룹은 여러 소비자 간에 데이터 처리를 병렬화해야 하는 다양한 시나리오에서 가치가 있습니다. 예를 들어 다음과 같은 경우에 사용됩니다:\n\n- 로그 집계: 여러 소비자가 중앙 주제에서 로그 데이터를 병렬로 처리할 수 있습니다.\n- 스트림 처리: 소비자 그룹은 데이터 스트림을 실시간 분석 작업에 배포하는 데 사용될 수 있습니다.\n- 마이크로서비스 통신: 소비자 그룹은 관련 주제를 구독하고 메시지를 동시에 처리할 수 있도록 허용하여 마이크로서비스 간의 통신을 용이하게 합니다.\n\n## Kafka에서 오프셋이란 무엇이며 어떻게 커밋되는가?\n\nKafka에서 오프셋은 소비자 그룹 또는 각각의 소비자가 토픽 파티션 내에서 진행 상황을 추적하는 포인터 역할을 합니다. 이것들은 본질적으로 각 파티션 내에서 0부터 시작하는 순차적으로 할당된 정수로, 각 메시지에 대한 진행 상황을 나타냅니다. 여기에 오프셋에 대한 더 깊은 내용과 커밋 방법이 나와 있습니다.\n\n<div class=\"content-ad\"></div>\n\n**Offset 이해:**\n\n- 파티션별 추적: 오프셋은 특정한 컨슈머 그룹이나 컨슈머, 그리고 토픽 내 특정 파티션에 대한 것입니다. 이를 통해 각 컨슈머는 읽은 각 파티션에 대해 독립적으로 진행 상황을 추적할 수 있습니다.\n- 소비 재개: 오프셋은 중단 후에 소비를 재개하는 데 중요한 역할을 합니다. 컨슈머가 재시작하거나 그룹에 합류할 때, 지정된 파티션에서 메시지를 읽기 시작할 위치를 결정하기 위해 커밋된 오프셋을 사용합니다. 이를 통해 컨슈머는 이미 처리한 메시지를 다시 처리하지 않게 됩니다.\n\n**오프셋 커밋:**\n\n- 컨슈머 책임: 컨슈머는 주기적으로 오프셋을 커밋하는 책임이 있습니다. 이는 컨슈머가 성공적으로 처리한 마지막 메시지에 대해 Kafka에 알립니다. 오프셋을 커밋하는 다양한 전략이 있으며, 각각의 전략은 메시지 전달 의미론(메시지가 전달되는 방식에 대한 보장)을 가지고 있습니다:\n  - 적어도 한 번: 이것은 기본 설정입니다. 컨슈머는 메시지 처리 후 오프셋을 커밋합니다. 그러나 컨슈머가 오프셋을 커밋하기 전에 충돌하면 메시지가 다시 전달될 수 있어 재시작 시 중복 처리 가능성이 있습니다.\n  - 최대 한 번: 컨슈머는 메시지를 받자마자 오프셋을 커밋합니다. 처리가 실패하면 메시지가 다시 시도되지 않을 수 있어 데이터 손실 가능성이 있습니다.\n  - 정확히 한 번 (트랜잭션): 이것은 가장 복잡하지만 각 메시지가 정확히 한 번 전달 및 처리됨을 보장합니다. Kafka 트랜잭션과 Kafka Streams API를 사용해야 합니다.\n- 오프셋 커밋 과정: 일반적으로 컨슈머는 Kafka가 유지하는 \"__consumer_offsets\"라는 특별한 내부 토픽에 오프셋을 커밋합니다. 이 토픽은 모든 컨슈머 그룹과 파티션에 대한 커밋된 오프셋을 저장합니다.\n\n<div class=\"content-ad\"></div>\n\n오프셋을 커밋하는 중요성:\n\n- 진행 상황 추적: 커밋된 오프셋을 통해 소비자는 장애 또는 재시작 후 올바른 지점에서 처리를 계속할 수 있습니다.\n- 중복 방지 (at-least-once와 함께): at-least-once 전략을 사용하여 정기적으로 커밋하면 이미 소비자가 처리한 메시지의 재처리를 방지할 수 있습니다.\n\n오프셋 커밋 전략 선택:\n\n오프셋 커밋 전략의 선택은 응용 프로그램의 요구 사항에 따라 달라집니다. 데이터 손실이 절대 허용되지 않는 경우, 정확히 한 번의 전달이 필요하며 (더 복잡하지만) 구현해야 합니다. 어느 정도의 메시지 중복은 허용되는 경우, at-least-once 전략이 더 간단한 접근 방식입니다.\n\n<div class=\"content-ad\"></div>\n\n## Kafka가 높은 처리량과 낮은 지연 시간을 어떻게 달성하는가?\n\nKafka는 설계 선택과 기술의 조합을 통해 높은 처리량과 낮은 지연 시간을 달성합니다. 여기에 중요한 요소 몇 가지가 있습니다:\n\n확장성과 병렬성:\n\n- 분산 아키텍처: Kafka의 분산 아키텍처는 클러스터 내 여러 브로커에 부하를 분산시켜 대규모 데이터 양을 처리할 수 있도록 합니다. 이를 통해 필요에 따라 더 많은 머신을 추가함으로써 수평 확장이 가능합니다.\n- 분할: Kafka의 주제는 파티션이라는 더 작은 단위로 나누어집니다. 프로듀서는 이러한 파티션에 병렬로 메시지를 발행할 수 있으며, 이는 전체 처리량을 향상시킵니다. 소비자는 할당된 파티션에서 메시지를 동시에 소비함으로써 처리를 병렬화할 수도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n효율적인 데이터 저장 및 액세스:\n\n- Append-only Logs(추가 전용 로그): 데이터는 각 브로커의 추가 전용 로그에 저장됩니다. 이렇게 하면 쓰기 작업이 간소화되고 무작위 디스크 액세스의 부하를 피할 수 있습니다. 새로운 데이터가 로그의 끝에 씌여지기 때문에 효율적으로 액세스할 수 있습니다.\n- 배칭: 프로듀서는 여러 메시지를 브로커로 보내기 전에 함께 배칭할 수 있습니다. 이렇게 하면 네트워크 왕복 횟수가 줄어들고 데이터 전송의 효율성이 향상됩니다.\n- Zero-Copy 처리: 가능한 경우에는 Kafka가 불필요한 데이터 복사를 피하기 위한 zero-copy 기술을 활용합니다. 이렇게 하면 CPU 부하가 줄어들고 처리 속도가 향상됩니다.\n- OS 기능 활용: Kafka는 Linux 페이지 캐시를 활용하여 자주 액세스되는 데이터를 메모리에 저장함으로써 디스크 I/O를 줄이고 소비자가 더 빠르게 메시지를 검색할 수 있도록 합니다.\n\n분리된 통신:\n\n- 프로듀서 및 소비자: 프로듀서와 소비자는 독립적으로 작동합니다. 프로듀서는 소비자가 구독한 것을 알 필요 없이 주제에 메시지를 발행합니다. 이 분리는 프로듀서가 소비자 확인을 기다리지 않기 때문에 전체 대기 시간이 줄어듭니다.\n\n<div class=\"content-ad\"></div>\n\n비동기 통신:\n\n- 생산자, 중개업자 및 소비자간의 통신은 비동기적으로 이루어집니다. 이는 생산자가 중개업자가 수신 확인을 기다리는 동안 블록되지 않고, 소비자가 새 메시지를 기다리는 동안 블록되지 않음을 의미합니다. 이는 전반적으로 응답성을 향상시킵니다.\n\n소비자 중심 최적화:\n\n- 미리 가져오기: 소비자는 로컬 버퍼로 구성된 메시지를 사전에 가져올 수 있습니다. 이는 후속 메시지 가져오기의 지연 시간을 줄이며 데이터가 메모리에 이미 사용 가능하게 함.\n- 효율적인 소비자 그룹 관리: 소비자 그룹은 다시 조정 알고리즘을 활용하여 파티션을 효율적으로 소비자들 사이에 분배합니다. 이로써 균형 잡힌 부하 및 전반적인 처리 시간을 줄입니다.\n\n<div class=\"content-ad\"></div>\n\n## Kafka의 실제 사용 사례는 무엇인가요? (로그 집계, 마이크로서비스 통신)\n\n아파치 카프카의 실제 사용 사례 중 일부를 살펴보면, 실시간 데이터 파이프라인을 처리하는 능력을 강조할 수 있습니다:\n\n로그 집계 및 모니터링:\n\n- Kafka는 다양한 분산 애플리케이션, 서비스 및 마이크로서비스에서 로그를 수집하는 데 뛰어납니다. 이러한 로그는 Kafka의 특정 토픽으로 스트림으로 발행됩니다.\n- 중앙 집계된 로그를 사용하면 애플리케이션의 실시간 분석, 문제 해결 및 성능 모니터링이 가능해집니다. ELK 스택(Elasticsearch, Logstash, Kibana)과 같은 도구를 Kafka와 통합하여 로그 데이터를 소비하고 시각화하여 더 깊은 인사이트를 얻을 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n마이크로서비스 통신:\n\n- 카프카는 마이크로서비스 아키텍처의 중추신경계 역할을 합니다. 마이크로서비스는 이벤트나 데이터 업데이트를 카프카의 관련 토픽에 발행할 수 있습니다.\n- 다른 마이크로서비스는 이러한 토픽을 구독하고 발행된 이벤트에 반응하여 서비스 간에 비동기적이고 느슨하게 결합된 통신을 가능케 합니다. 이는 마이크로서비스 배포에서 확장성과 유연성을 증진시킵니다.\n\n스트림 처리와 분석:\n\n- 카프카는 대량 데이터 스트림을 처리할 수 있는 능력으로 실시간 분석 애플리케이션에 이상적입니다.\n- 아파치 플링크나 아파치 스파크 스트리밍과 같은 스트림 처리 프레임워크를 카프카와 통합하여 토픽에서 데이터 스트림을 소비하고 실시간 연산, 필터링 또는 변환을 수행할 수 있습니다.\n- 이를 통해 애플리케이션은 사기 탐지, 이상 분석 또는 추천 엔진을 위한 실시간 데이터 통찰에 반응할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\nIoT 데이터 수집 및 처리:\n\n- 사물 인터넷(IoT) 영역에서 Kafka는 센서와 장치가 생성하는 대량 및 고속의 데이터를 효율적으로 처리할 수 있습니다.\n- 센서 데이터는 메시지로 Kafka 토픽에 발행될 수 있어 이 데이터의 실시간 처리, 집계 및 분석이 가능합니다.\n- 이는 예측 현상 유지, 원격 모니터링 또는 IoT 센서 데이터의 실시간 시각화에 활용될 수 있습니다.\n\n이벤트 소싱:\n\n- Kafka는 마이크로서비스 및 응용 프로그램을 위한 중앙 이벤트 저장소로 사용될 수 있습니다. 상태 변경 또는 작업을 나타내는 이벤트는 Kafka 토픽에 메시지로 발행됩니다.\n- 이 이벤트 로그는 분산 시스템에서 언제든지 응용 프로그램 상태를 재구성하거나 최종 일관성 패턴을 구현하는 데 사용될 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n**실시간 사기 탐지:**\n\n- 카프카의 고 처리량과 낮은 지연 시간은 실시간 사기 탐지 시스템을 구축하기에 적합합니다.\n- 거래 데이터는 카프카 토픽으로 스트리밍될 수 있으며, 스트림 처리 응용 프로그램은이 데이터를 실시간으로 분석하여 의심스러운 패턴이나 잠재적인 사기 활동을 식별할 수 있습니다.\n\n이것들은 몇 가지 예시일 뿐이며, 카프카의 사용 사례는 기업이 실시간 데이터 파이프라인 및 응용 프로그램을 위한 능력을 활용함에 따라 계속 발전하고 있습니다.\n\n## 카프카 소비자가 뒤처지는 상황을 어떻게 처리하시겠어요? (소비자 리밸런싱, 구성 조정)\n\n<div class=\"content-ad\"></div>\n\n카프카 소비자가 생산자를 따라잡지 못하고 메시지 처리에서 뒤처지기 시작하는 상황을 해결하는 방법을 다음과 같이 제시해 드립니다.\n\n원인 파악하기:\n\n- 소비자 랙 관찰: 먼저, 카프카 소비자 모니터링 도구나 내장된 소비자 그룹 랙 정보를 활용하여 어떤 소비자 그룹과 파티션이 랙을 겪고 있는지 식별해 보세요.\n- 소비자 성능 분석: 문제가 되는 소비자의 성능 메트릭스인 CPU, 메모리 사용량 및 처리 시간을 조사하여 소비자 애플리케이션 자체에서 발생하는 잠재적인 병목 현상을 파악해 보세요.\n\n소비자 측 해결책:\n\n<div class=\"content-ad\"></div>\n\n- 소비자 코드 최적화: 소비자 코드를 검토하고 개선할 부분을 식별합니다. 이 작업에는 다음이 포함될 수 있습니다:\n  - 메시지 처리 논리를 최적화하여 메시지당 처리 시간을 줄입니다.\n  - 여러 메시지를 한꺼번에 처리하기 위해 메시지 처리를 일괄 처리합니다.\n- 소비자 병렬화 증가: 소비자 응용 프로그램이 처리할 수 있다면, 소비자 그룹 내의 소비자 인스턴스 수를 증가시키는 것을 고려해보세요. 이렇게 하면 작업이 분산되어 뒤처진 작업을 처리할 수 있습니다.\n- 소비자 페치 크기 조정: 소비자 페치 크기는 각 요청에서 브로커로부터 검색되는 데이터 양을 제어합니다. 페치 크기를 늘림으로써(합리적인 한계 내에서) 처리량을 향상시키고 지연을 줄일 수 있습니다.\n\n카프카 구성 조정:\n\n- 소비자 리밸런스: 소비자 그룹 내에서 부분적으로 파티션이 분산되어 지연이 발생하는 경우, Kafka 소비자 그룹 관리 도구를 사용하여 소비자 리밸런스를 수동으로 트리거할 수 있습니다. 이렇게 하면 파티션이 소비자 사이에서 재분배되어 과도하게 작업이 부담스럽게 된 소비자의 지연이 완화될 수 있습니다.\n- 오토 오프셋 리셋: 극단적인 경우, 지연되는 파티션용으로 소비자 오프셋을 재설정해야 할 수도 있습니다. 그러나 이 접근 방식은 메시지 중복 (at-least-once 의미론)이나 데이터 손실 (at-most-once 의미론)로 이어질 수 있으므로 신중하게 사용해야 합니다.\n\n## 카프카에서 한 소비자로 중복 메시지 소비 방지하기를 선택하는 방법?\n\n<div class=\"content-ad\"></div>\n\n정확히 한 번만 메시지가 전달되고 소비자에 의해 한 번만 처리되는 정확히 한 번의 의미를 달성하려면 Apache Kafka에서는 적어도 한 번 또는 최대 한 번 전달보다 더 많은 노력이 필요합니다. Kafka에서 단일 소비자에 의한 중복 처리를 피하기 위한 두 가지 주요 방법은 다음과 같습니다:\n\n- Kafka Streams API를 사용한 트랜잭션 소비자:\n\n- 이것은 정확히 한 번의 처리 보장을 위한 추천 접근 방식입니다. Kafka Streams는 Kafka Consumer를 기반으로 구축된 고수준 API로 스트림 처리 작업을 간단화합니다.\n- 이는 Kafka 트랜잭션을 활용하여 프로듀서에 의한 메시지 쓰기와 소비자의 오프셋 커밋을 원자적 단위로 처리합니다. 쓰기 또는 커밋 중 하나가 실패하면 전체 트랜잭션이 롤백되어 부분 처리와 잠재적인 중복을 방지합니다.\n\n프로세스의 분해는 다음과 같습니다:\n\n<div class=\"content-ad\"></div>\n\n- 소비자는 메시지를 소비하기 전에 Kafka 트랜잭션을 시작합니다.\n- 소비자는 메시지를 처리하고 필요한 작업을 수행합니다.\n- 처리가 성공하면, 소비자는 트랜잭션 내에서 오프셋을 커밋합니다.\n- Kafka는 트랜잭션 내의 모든 작업이 성공하거나 모두 실패하도록 보장하여 중복을 방지합니다.\n- 기억해둘 중요한 점들:\n- 이 접근 방식은 메시지 소비를 위해 Kafka Streams API를 사용해야 합니다.\n- 한 번만 적용되는 의미론은 생산자 측의 트랜잭션 기능이 필요합니다.\n\n2. 수동 오프셋 관리를 통한 멱등성:\n\n- 이 방법은 소비자 응용 프로그램 내에서 멱등성을 구현하고 오프셋을 수동으로 관리하는 것을 포함합니다. 멱등성은 의도하지 않은 부작용 없이 작업을 여러 번 반복할 수 있음을 보장합니다.\n\n여기에 일반적인 아이디어가 있습니다:\n\n<div class=\"content-ad\"></div>\n\n- 사용자는 받은 각 메시지에 고유 식별자(동질성 키)를 할당합니다.\n- 메시지를 처리하기 전에 사용자는 동일한 동질성 키를 가진 메시지를 이미 처리했는지 확인합니다. 이를 위해 처리된 키를 데이터베이스나 분산 캐시에 저장하여 확인할 수 있습니다.\n- 메시지가 새로운 경우(고유 키), 사용자는 처리하고 나중을 위해 키를 저장합니다.\n- 메시지가 중복인 경우(키가 이미 존재), 사용자는 더 이상 처리하지 않고 삭제합니다.\n- 성공적인 처리 후에 사용자는 오프셋을 커밋합니다.\n\n고려해야 할 주요 사항:\n\n- 동질성 논리를 구현하는 것은 사용자 애플리케이션에 복잡성을 추가합니다.\n- 동질성 키를 저장하고 관리하기 위한 적합한 메커니즘을 선택해야 합니다.\n- 수동으로 오프셋을 커밋하면 데이터 손실이나 중복을 피하기 위해 신중히 처리해야 합니다.\n\n적절한 방법 선택하기:\n\n<div class=\"content-ad\"></div>\n\n- 트랜잭션 소비자(카프카 스트림 API)는 간단하고 정확히 한 번 배송이 보장되는 접근 방식으로 일반적으로 권장됩니다.\n- 수동 오프셋 관리와 이덤포턴스는 대안일 수 있지만, 이의 효율을 위해서 더 많은 개발 노력이 필요하며, 이덤포턴시 키 및 오프셋을 관리하는 데 잠재적인 복잡성을 도입할 수 있습니다.\n\n## 동일한 메시지를 다른 컨슘어에서 듣지 않도록 어떻게 보장할까요?\n\n기본적으로, 컨슈머 그룹 내의 카프카 컨슈머는 동일한 메시지를 듣지 않습니다. 카프카는 이를 컨슈머 그룹과 오프셋 관리라는 개념을 통해 실현합니다. 작동 방식은 다음과 같습니다:\n\n컨슈머 그룹:\n\n<div class=\"content-ad\"></div>\n\n- 소비자는 \"group.id\"라는 고유 식별자를 사용하여 그룹화될 수 있습니다. 동일한 그룹에 속하는 모든 소비자는 소비자 그룹을 형성합니다.\n- 각 소비자 인스턴스는 구성 중에 해당하는 그룹 소속을 지정합니다.\n\n파티션 및 오프셋 추적:\n\n- Kafka의 토픽은 파티션이라는 작은 단위로 분할됩니다.\n- 각 소비자 그룹은 가입한 각 파티션에 대한 오프셋 기록을 유지합니다. 오프셋은 파티션 내 메시지의 고유 식별자로, 본질적으로 0부터 시작하는 카운터입니다.\n- 소비자 그룹이 토픽을 구독하면 Kafka는 파티션을 그룹의 소비자들 사이에 분산시키기 위해 소비자 리밸런싱을 수행합니다. 이를 통해 고률한 부하 분산이 보장됩니다.\n\n독점 청취:\n\n<div class=\"content-ad\"></div>\n\n- 각 주제 내의 각 파티션은 한 번에 그룹 내의 하나의 소비자에게 할당됩니다. 이는 그룹 내에서 중복 처리를 방지합니다.\n- 소비자가 메시지를 처리하는 동안 주기적으로 오프셋을 커밋합니다. 이를 통해 Kafka에게 각 파티션의 마지막으로 성공적으로 처리한 메시지를 알립니다.\n\n장점:\n\n- 중복 방지: 파티션을 배정하고 오프셋을 추적함으로써 Kafka는 각 메시지가 그룹 내의 하나의 소비자에게만 전달되도록 보장하여 중복 처리를 방지합니다.\n- 확장성: 그룹에서 소비자를 추가하거나 제거하여 소비자 처리를 쉽게 확장할 수 있습니다. Kafka는 파티션을 자동으로 리밸런싱하여 균형 잡힌 부하를 유지합니다.\n\n예시:\n\n<div class=\"content-ad\"></div>\n\n두 명의 소비자(소비자 A 및 소비자 B)가 3개 파티션을 가진 주제에 가입한 소비자 그룹을 상상해보세요. Kafka는 파티션을 다음과 같이 분배할 수 있습니다:\n\n- 소비자 A: 파티션 0 및 1 수신\n- 소비자 B: 파티션 2 수신\n\n이렇게 함으로써 각 메시지가 그룹 내 하나의 소비자에게만 전달됩니다.\n\n중요 참고사항:\n\n<div class=\"content-ad\"></div>\n\n카프카는 소비자 그룹 내에서 중복 처리를 방지하지만, 동일한 주제에 두 개의 소비자 그룹이 모두 구독되어 있다면 메시지가 여러 소비자 그룹으로 전달될 수 있습니다. 소비자 그룹에 관계없이 메시지가 한 번만 처리되도록 보장해야 한다면, 이벤트 중복성과 같은 기술을 활용하여 소비자 내에서 추가 로직을 구현해야 합니다 (이전 질문에 다루어졌습니다).\n\n## 소비자 측의 장애 복구 방법\n\n카프카에서 소비자 측의 장애를 복구하는 것은 데이터 손실 없이 메시지 처리가 원활하게 계속되도록 보장하기 위해 몇 가지 주요 전략을 활용해야 합니다. 다음은 취할 수 있는 접근 방법에 대한 설명입니다:\n\n1. 카프카 오프셋 커밋과 소비자 리발란싱 활용하기:\n\n<div class=\"content-ad\"></div>\n\n- 오프셋 커밋: 카프카는 소비자 측 오프셋 커밋을 활용하여 진행 상황을 추적합니다. 소비자들은 주기적으로 오프셋을 커밋하여 구독 중인 각 파티션에서 마지막으로 성공적으로 처리한 메시지를 나타냅니다.\n- 소비자 리밸런싱: 소비자가 실패하거나 새로운 소비자가 그룹에 가입하면, 카프카는 소비자 리밸런싱을 트리거합니다. 이 과정은 나머지 소비자들 사이에서 파티션을 재분배합니다.\n\n복구 프로세스:\n\n- 다시 시작할 때, 실패한 소비자는 이전에 책임지고 있던 파티션에 대한 커밋된 오프셋을 검색합니다.\n- 카프카는 해당 파티션을 다시 소비자에게 할당하여 리밸런싱 동안 (같은 소비자 그룹에 다시 가입할 경우) 이어서 처리합니다.\n- 소비자는 커밋된 오프셋에서 메시지 처리를 계속하며, 장애로 인한 데이터 손실이 발생하지 않도록 합니다.\n\n2. 소비자에서 오류 처리 및 재시도 구현:\n\n<div class=\"content-ad\"></div>\n\n- 에러 처리: 소비자 애플리케이션에서 예외나 처리 실패를 감지하기 위한 견고한 에러 처리 메커니즘을 갖추는 것이 중요합니다.\n- 재시도 논리: 에러가 발생할 때 소비자는 메시지 처리를 다시 시도하는 재시도 논리를 구현해야 합니다. 이는 일시적 에러의 경우 브로커를 과도하게 사용하지 않도록 백오프 전략을 사용하여 재시도하는 것을 포함할 수 있습니다.\n- 데드 레터 큐 (선택 사항): 중요한 메시지나 지속적인 오류의 경우 데드 레터 큐 (DLQ)를 구현해야 합니다. 실패한 메시지는 DLQ로 전송되어 수동 개입이나 후속 처리 시도가 가능합니다.\n\n3. 카프카 컨슈머 오프셋 관리 도구 활용:\n\n- 카프카는 컨슈머 오프셋을 수동으로 관리하기 위한 도구와 API를 제공합니다. 이는 특정 시나리오에서 유용할 수 있습니다:\n- 오프셋 재설정: 극도의 경우에는 컨슈머 그룹이나 특정 파티션의 오프셋을 수동으로 재설정해야 할 수 있습니다. 그러나 이를 신중하게 사용해야 하며, 이로 인해 메시지 중복(at-least-once 의미론)이나 데이터 손실(at-most-once 의미론)이 발생할 수 있습니다.\n- 컨슈머 일시 중지/재개: 유지보수나 디버깅 목적으로 일시적으로 컨슈머나 컨슈머 그룹을 일시 중지할 수 있는 도구를 사용할 수 있습니다. 이를 통해 메시지 전달과 오프셋 관리를 제어할 수 있습니다.\n\n4. 올바른 오프셋 커밋 전략 선택:\n\n<div class=\"content-ad\"></div>\n\n- Kafka의 기본 옵셋 커밋 전략은 적어도 한 번은 입니다. 이는 메시지가 최소한 한 번은 전달되도록 보장하지만, 소비자가 오프셋을 커밋하기 전에 실패할 경우 중복이 발생할 수 있습니다.\n- 더 엄격한 전달 보증을 위해 Kafka Transactions 및 Kafka Streams API를 사용하여 정확히 한 번만 전달되는 의미론을 고려하십시오. 이 방식은 각 메시지가 한 번만 전달되고 처리되도록 보장하지만, 더 복잡한 구성 및 개발 노력이 필요합니다.\n\n## 스프링 부트 앱에서 Kafka 구성하는 방법은?\n\n- Kafka 종속성 추가:\n\n필요한 Kafka 종속성을 pom.xml(Maven용)이나 build.gradle(Gradle용) 파일에 추가하십시오. Spring Boot은 핵심 Kafka 종속성이 포함된 편리한 spring-kafka 스타터를 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-kafka</artifactId>\n</dependency>\n```\n\n2. Kafka 속성 구성하기:\n\nSpring Boot는 application.yml 또는 application.properties와 같은 애플리케이션 프로퍼티 파일을 사용하여 Kafka 속성을 편리하게 구성할 수 있는 방법을 제공합니다. 여기에 몇 가지 중요한 속성이 있습니다:\n\n- spring.kafka.bootstrap-servers: 이 속성은 Kafka 브로커 주소의 쉼표로 구분된 목록을 지정합니다.\n- spring.kafka.consumer.group-id: 이 속성은 응용 프로그램의 소비자 그룹 ID를 정의합니다. 동일한 그룹 ID로 동일한 주제에 구독된 소비자는 소비자 그룹을 형성하고 메시지를 효율적으로 병렬 처리합니다.\n- spring.kafka.producer.key-serializer: 이 속성은 응용 프로그램에서 생성한 메시지 키의 직렬화에 사용되는 직렬화기를 지정합니다. 기본적으로 StringSerializer가 사용됩니다. JSON 키의 경우와 같이 메시지 키 데이터 유형에 따라 다른 직렬화기를 선택할 수 있습니다 (예: JSON 키의 경우의 경우 JsonSerializer).\n- spring.kafka.producer.value-serializer: 이 속성은 응용 프로그램에서 생성한 메시지 값의 직렬화에 사용되는 직렬화기를 정의합니다. 키 직렬화기와 유사하게, 메시지 값 데이터 유형에 따라 적절한 직렬화기를 선택하세요.\n- (선택 사항) spring.kafka.consumer.auto-offset-reset: 이 속성은 소비자 그룹이 리밸런스되거나 장애 발생 후 다시 시작할 때 소비자 오프셋이 어떻게 처리되는지를 제어합니다. 기본값은 earliest로, 이는 소비자가 파티션의 처음부터 읽기를 시작함을 의미합니다. 최신 메시지부터 읽기를 시작하려면 latest로 설정할 수 있습니다.\n  \n\n<div class=\"content-ad\"></div>\n\n3. Kafka 프로듀서와 컨슈머 생성하기:\n\n- 스프링 부트는 Kafka 프로듀서와 컨슈머를 위한 추상화를 제공합니다. @Autowired를 사용하여 주입하고 Kafka 토픽과 상호 작용하는 데 사용할 수 있습니다:\n\n```java\n@SpringBootApplication\npublic class MyKafkaApp {\n\n    @Autowired\n    private KafkaTemplate<String, String> kafkaTemplate;\n\n    public void sendMessage(String topic, String message) {\n        kafkaTemplate.send(topic, message);\n    }\n\n    @KafkaListener(topics = \"myTopic\")\n    public void receiveMessage(String message) {\n        // 받은 메시지 처리\n    }\n\n    // ... (다른 애플리케이션 로직)\n}\n```\n\n## Kafka 작업 시 개발자들이 자주 하는 일반적인 실수는 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\n설정 및 사용에 대한 오류:\n\n- 소비자 그룹 이해 부족: 소비자 그룹의 개념과 그들이 작업 부하를 어떻게 분산시키는지를 이해하지 못하면 비효율적인 처리나 중복된 메시지가 발생할 수 있습니다.\n- 올바르지 않은 오프셋 커밋 전략: 적절하지 않은 오프셋 커밋 전략(적어도 한 번, 최대 한 번 또는 정확히 한 번)을 선택하면 데이터 손실이나 메시지 중복이 발생할 수 있습니다.\n- 적절하지 않은 직렬화기 선택: 메시지 키와 값의 데이터 유형에 맞는 적합한 직렬화기/역직렬화기를 선택하지 않으면 직렬화 오류나 예기치 않은 동작이 발생할 수 있습니다.\n- 불필요한 수동 오프셋 관리: 수동으로 오프셋을 관리하는 것은 오류가 발생하기 쉽고 복잡할 수 있습니다. 가능한 경우 카프카의 자동 오프셋 관리를 활용하십시오.\n\n성능 및 확장성 문제:\n\n- 파티셔닝 무시: 주제 파티셔닝을 효과적으로 활용하지 않으면 모든 그룹의 소비자가 단일 파티션에서 읽기 때문에 성능 병목이 발생할 수 있습니다.\n- 충분하지 않은 소비자 병렬성: 그룹 내 소비자가 너무 적으면 처리 지연이 발생할 수 있으며, 특히 대용량 데이터 스트림의 경우에는 더욱 그렇습니다.\n- 비효율적인 소비자 코드: 최적화되지 않은 소비자 코드는 메시지 처리 속도를 늦추고 전반적인 처리량을 저해할 수 있습니다.\n- 소비자 랙 모니터링 미흡: 소비자 랙을 모니터링하지 않으면 잠재적인 병목 현상이나 부하 분배의 불균형에 대해 알지 못할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n개발 및 오류 처리:\n\n- 정확히 한 번만 Guarantee 무시: 귀하의 애플리케이션이 엄격한 데이터 일관성을 필요로 하는 경우, Kafka Streams 및 트랜잭션을 사용하여 정확히 한 번 전달 보장을 무시하면 데이터 불일치가 발생할 수 있습니다.\n- 부족한 오류 처리: 생산자와 소비자의 견고한 오류 처리 메커니즘을 구현하지 않으면 응용 프로그램이 예외와 데이터 손실에 취약해질 수 있습니다.\n- 테스트 부족: 특히 오류 시나리오에서 적절한 테스트를 누락하면 Kafka 응용 프로그램의 오류 처리 및 복구 프로세스의 약점이 드러날 수 있습니다.\n\nKafka 대체 제품 및 비교:\n\n메시지 스트리밍 세계에서 Kafka가 우세한 플레이어이지만 귀하의 특정 요구 사항에 따라 고려할 수 있는 다른 옵션도 있습니다. 여기에는 Kafka와 두 가지 인기 있는 대체 제품인 RabbitMQ 및 Apache Pulsar의 비교가 포함됩니다:\n\n<div class=\"content-ad\"></div>\n\nRabbitMQ:\n\n- 초점: RabbitMQ는 사용하기 쉽고 유연성으로 유명한 가벼운 메시지 브로커입니다. 메시지 라우팅 및 발행/구독, RPC(원격 프로시저 호출), 팬아웃과 같은 메시지 교환 패턴에서 우수한 성과를 내며, 애플리케이션 간 유연한 통신을 지원합니다.\n\n장점:\n\n- 간단함: 간단하게 설정하고 관리하고 사용할 수 있어 복잡하지 않은 메시지 전달 요구에 적합합니다.\n- 가벼움: Kafka와 비교했을 때 더 작은 풋프린트로 리소스가 제한된 환경에 이상적입니다.\n- 유연성: 다양한 메시지 교환 패턴을 지원하여 다양한 통신 시나리오에 적합합니다.\n- 성숙하고 안정적인: 큰 커뮤니티와 포괄적인 실전 테스트로 지탱되어 안정성이 뛰어납니다.\n\n<div class=\"content-ad\"></div>\n\n약점:\n\n- 확장성: Kafka보다 수평적으로 확장하는 데 있어서 극도로 높은 메시지 양을 다루는 데 비교적 부족할 수 있습니다.\n- 처리량: 아키텍처로 인해 매우 높은 처리량 데이터 스트림에서 고난을 겪을 수 있습니다.\n- 제한된 스트림 처리: Kafka Streams나 Pulsar Functions과 비교하여 내장된 스트림 처리 기능이 부족합니다.\n- 사용 사례:\n- 작업 대기열: RabbitMQ는 작업 대기열을 관리하고 애플리케이션에서 백그라운드 작업을 트리거하는 데 적합합니다.\n- 마이크로서비스 통신: RabbitMQ는 마이크로서비스 간 가벼운 통신 및 데이터 교환에 사용될 수 있습니다.\n- 통합: RabbitMQ는 서로 다른 응용 프로그램 및 시스템 간 통합을 구현하는 데 좋은 선택입니다.\n\nApache Pulsar:\n\n- 초점: Pulsar는 상대적으로 새로운 오픈 소스 메시지 스트리밍 플랫폼으로 고성능, 확장성 및 낮은 지연 시간을 위해 설계되었습니다. Kafka와 유사한 기능을 제공하지만 멀티테넌시와 지리적 복제에 중점을 둡니다.\n\n<div class=\"content-ad\"></div>\n\n장점:\n\n- 고성능: 높은 처리량 및 낮은 지연 시간을 지원하여 요구되는 실시간 데이터 파이프라인에 적합합니다.\n- 확장성: 대용량 데이터 처리를 위해 수평적으로 높은 확장성을 제공합니다.\n- 다중 테넌시(Multi-tenancy): 단일 Pulsar 클러스터를 다중 테넌트 또는 조직간에 안전하게 공유할 수 있습니다.\n- 지역 복제(Geo-replication): 지리적으로 분산된 지역 간 데이터 복제를 지원하여 재해 복구 및 글로벌 배포를 가능하게 합니다.\n- 스트림 처리(Stream Processing): Kafka Streams와 유사한 내장형 스트림 처리 기능을 제공하여 플랫폼 내에서 데이터 변환 및 분석이 가능합니다.\n\n단점:\n\n- 성숙도: Kafka의 확립된 생태계와 비교할 때, Pulsar는 비교적 신생 프로젝트로 생태계 및 툴 통합이 덜 성숙할 수 있습니다.\n- 복잡성: 고급 기능으로 인해 Kafka보다 설정 및 관리가 다소 복잡할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n사용 사례:\n\n- 실시간 분석: 고 처리량과 낮은 지연 시간으로, Pulsar는 실시간 분석 파이프라인을 구축하는 데 좋은 선택지입니다.\n- IoT 데이터 스트리밍: Pulsar는 IoT 장치에서 생성된 대량 및 고속 데이터를 효율적으로 처리할 수 있습니다.\n- 클라우드 네이티브 배포: 다중 테넌시와 지오-레플리케이션 기능을 갖춘 Pulsar는 클라우드 네이티브 배포에 적합합니다.\n\n적절한 도구 선택:\n\nKafka, RabbitMQ 및 Pulsar 중에서 최상의 선택을 하려면 특정 요구 사항을 고려해야 합니다. 다음은 간략한 가이드라인입니다:\n\n<div class=\"content-ad\"></div>\n\n- 간단한 메시지 라우팅 및 가벼운 통신에는 RabbitMQ를 사용하세요.\n- 고 처리량과 낮은 지연 시간, 확장성을 갖춘 스트리밍에는 Kafka 또는 Pulsar를 사용하세요.\n- 멀티 테넌시, 지오 레플리케이션, 그리고 클라우드 네이티브 배포에는 Pulsar를 사용하세요.\n- 기존의 Kafka 생태계와 성숙한 도구를 활용하기 위해서는 Kafka를 사용하세요.\n\n더 많은 구성 옵션, 고급 기능, 그리고 Spring Boot를 활용한 Kafka 애플리케이션 구축을 위한 모범 사례에 대해 알아보려면 Spring Kafka 문서(https://spring.io/projects/spring-kafka)를 참고하세요.\n\n여기까지 읽어 주셔서 감사합니다. 여기에서 모두를 도울 수 있는 실제 Kafka 질문들을 공유할 수 있는 코멘트 섹션에서 스레드를 만들어 볼까요?\n\n# 읽어 주셔서 감사합니다\n\n<div class=\"content-ad\"></div>\n\n- 👏 이야기에 박수를 보내 주시고 저를 팔로우하세요 👉\n- 📰 제 Medium 페이지에서 더 많은 콘텐츠를 읽어보세요 (Java 개발자 면접을 위한 60개의 이야기)\n\n제 책은 여기서 찾아볼 수 있어요:\n\n- 아마존에서 Guide To Clear Java Developer Interview (킨들 북) 또는 Gumroad( PDF 형식)을 확인하세요.\n- Gumroad( PDF 형식) 또는 아마존(킨들 전자책)에서 Guide To Clear Spring-Boot Microservice Interview를 확인하세요.\n- 🔔 팔로우해 주세요: LinkedIn | Twitter | Youtube","ogImage":{"url":"/assets/img/2024-05-23-KafkaInterviewQuestionforexperiencedJavadeveloperin2024_0.png"},"coverImage":"/assets/img/2024-05-23-KafkaInterviewQuestionforexperiencedJavadeveloperin2024_0.png","tag":["Tech"],"readingTime":22},{"title":"안드로이드 개발 입문자를 위한 가이드 첫 앱 만들기 시작하기","description":"","date":"2024-05-23 12:56","slug":"2024-05-23-ABeginnersGuidetoAndroidDevelopmentGettingStartedwithBuildingYourFirstApp","content":"\n\n<img src=\"/assets/img/2024-05-23-ABeginnersGuidetoAndroidDevelopmentGettingStartedwithBuildingYourFirstApp_0.png\" />\n\n안드로이드 앱을 만들고 싶지만 시작할 방법을 모르시나요? 모바일 애플리케이션에 대한 수요가 증가함에 따라 안드로이드 개발은 가치 있는 기술이 되었습니다. 특정 문제를 해결하기 위한 도구를 만들거나 앱 개발 분야로 뛰어들기를 원한다면, 이 초심자를 위한 가이드는 안드로이드 개발을 시작하는 데 필수적인 단계를 안내해줍니다.\n\n# 설정하기\n\n코딩을 시작하기 전에 개발 환경을 설정해야 합니다. 다음은 필요한 기본 도구입니다.\n\n<div class=\"content-ad\"></div>\n\n- Android Studio: 안드로이드 앱 개발을 위한 공식 통합 개발 환경(IDE)입니다. 안드로이드 앱 빌드 및 디버깅을 위한 포괄적인 도구 세트를 제공합니다.\n- Java 또는 Kotlin: 안드로이드 앱은 주로 Java 또는 Kotlin 프로그래밍 언어를 사용하여 개발됩니다. Java는 전통적으로 안드로이드 개발에 사용되었지만, Kotlin은 간결한 구문과 향상된 기능으로 인해 인기를 얻고 있습니다.\n- SDK 관리자: 안드로이드 스튜디오에는 내장된 SDK 관리자가 있어서 필요한 안드로이드 SDK 구성 요소와 시스템 이미지를 다운로드하여 다양한 장치 및 안드로이드 버전에서 앱을 테스트할 수 있습니다.\n\n# 기본 개념 이해하기\n\n## 1. 활동(Activity):\n\n안드로이드에서 활동(Activity)은 사용자 인터페이스를 가진 단일 화면을 나타냅니다. 활동은 안드로이드 앱의 구성 요소이며, 각 활동은 Activity 클래스의 하위 클래스로 구현됩니다.\n\n<div class=\"content-ad\"></div>\n\n## 2. 레이아웃:\n\n레이아웃은 앱의 사용자 인터페이스 구조를 정의합니다. Android는 LinearLayout, RelativeLayout 및 ConstraintLayout과 같은 다양한 레이아웃 유형을 제공하여 화면에 UI 구성 요소를 배열하는 데 도움을 줍니다.\n\n## 3. 뷰:\n\n뷰는 화면에 표시되는 UI 구성 요소로, 버튼, 텍스트 필드 및 이미지와 같은 요소입니다. 각 뷰는 View 클래스의 서브클래스의 인스턴스이며 XML 속성 또는 프로그래밍적으로 외관과 동작을 사용자 정의할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 첫 번째 앱 만들기\n\n안드로이드 개발의 주요 개념에 대한 기본적인 이해를 얻었으니, 시작하기 위해 간단한 \"Hello World\" 앱을 만들어 보겠습니다.\n\n## 단계 1: 새 프로젝트 생성\n\nAndroid Studio를 열고 환영 화면에서 \"새 Android Studio 프로젝트 시작\"을 선택합니다. 프로젝트 템플릿 선택, 앱의 이름과 패키지 이름 설정, 최소 SDK 버전 선택 등의 프로젝트 설정을 구성하는 안내에 따릅니다.\n\n<div class=\"content-ad\"></div>\n\n## 단계 2: 사용자 인터페이스 디자인\n\n프로젝트를 설정하면 Android Studio의 레이아웃 편집기를 사용하여 앱의 사용자 인터페이스를 디자인할 수 있습니다. 팔레트에서 UI 구성요소를 끌어다가 디자인 캔버스에 놓고, 속성 패널을 사용하여 속성을 사용자 정의할 수 있습니다.\n\n\"Hello World\" 앱의 경우, 환영 메시지를 표시하기 위해 TextView 구성요소를 추가할 수 있습니다.\n\n## 단계 3: 코드 작성\n\n<div class=\"content-ad\"></div>\n\n이제 앱의 기능을 구현하는 코드를 작성해야 합니다. 주요 활동 파일 (MainActivity.java 또는 MainActivity.kt)을 열고 다음 코드를 추가하여 앱이 시작될 때 \"Hello World\" 메시지를 표시하십시오:\n\n## 단계 4: 앱 실행\n\n코드를 작성한 후 Android 에뮬레이터 또는 실제 장치에서 앱을 실행하여 작동을 확인할 수 있습니다. Android Studio에서 \"실행\" 버튼을 클릭하고 대상 장치를 선택한 다음 앱을 빌드 및 설치할 때까지 기다리십시오.\n\n축하합니다! 첫 번째 Android 앱을 만들고 실행했습니다.\n\n<div class=\"content-ad\"></div>\n\n# 다음 단계\n\n첫 번째 안드로이드 앱을 완료했으니, 안드로이드 개발의 더 고급 주제와 기능을 탐색할 수 있습니다. 예를 들면:\n\n- 다양한 UI 구성 요소와 레이아웃 작업\n- 사용자 입력 및 상호 작용 처리\n- SharedPreferences나 SQLite 데이터베이스를 사용한 데이터 저장 및 검색\n- Retrofit이나 Volley를 사용한 네트워크 요청\n- 활동 또는 프래그먼트를 이용한 내비게이션 구현\n\n안드로이드 개발의 이해를 깊이 있게 하는 데 도움이 되는 다양한 온라인 자료, 튜토리얼 및 문서가 많이 있습니다. 안드로이드 앱 개발 세계로의 여정을 계속하면서 새로운 것을 시도하고 실험해 보는 데 겁내지 마세요. 즐거운 코딩 되세요!","ogImage":{"url":"/assets/img/2024-05-23-ABeginnersGuidetoAndroidDevelopmentGettingStartedwithBuildingYourFirstApp_0.png"},"coverImage":"/assets/img/2024-05-23-ABeginnersGuidetoAndroidDevelopmentGettingStartedwithBuildingYourFirstApp_0.png","tag":["Tech"],"readingTime":3},{"title":"안녕하세요 오늘은 안드로이드에서 ExoPlayer를 사용하여 Jetpack Compose로 비디오를 표시하는 방법에 대해 알아보겠습니다","description":"","date":"2024-05-23 12:55","slug":"2024-05-23-HowtodisplayvideosusingExoPlayeronandroidwithJetpackCompose","content":"\n\n이 튜토리얼에서는 Jetpack Compose와 함께 ExoPlayer를 사용하는 간단한 방법을 보여드리기로 했어요.\n\n먼저 아래 종속성을 build.gradle(Module: app) 파일에 추가해주세요.\n\n```js\n// in .kts\nimplementation(\"androidx.media3:media3-exoplayer:1.2.0\")\nimplementation(\"androidx.media3:media3-ui:1.2.0\")\n```\n\n현재 컨텍스트를 LocalContext.current로 가져오세요.\n\n<div class=\"content-ad\"></div>\n\n```kotlin\n    // 현재 컨텍스트 가져오기\n    val context = LocalContext.current\n```\n\nComposable이나 ViewModel에서 ExoPlayer의 인스턴스를 만듭니다.\n\n```kotlin\nval exoPlayer = ExoPLayer.Builder(context).build()\n```\n\nExoPlayer의 라이프사이클을 관리하여 필요하지 않을 때 리소스를 해제해야 합니다. DisposableEffect와 LaunchedEffect를 사용하여 라이프사이클 이벤트를 처리할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n```js\n// MediaSource를 ExoPlayer에 설정합니다.\nLaunchedEffect(mediaSource) {\n    exoPlayer.setMediaItem(mediaSource)\n    exoPlayer.prepare()\n}\n\n// 라이프사이클 이벤트 관리\nDisposableEffect(Unit) {\n    onDispose {\n        exoPlayer.release()\n    }\n}\n```\n\nExoPlayer 및 해당 컨트롤을 표시하는 Android view입니다.\n\n```js\nAndroidView(\n    factory = { ctx ->\n        PlayerView(ctx).apply {\n            player = exoPlayer\n        }\n    },\n    modifier = Modifier\n        .fillMaxWidth()\n        .height(200.dp) // 원하는 높이로 설정하세요\n)\n```\n\n상수 EXAMPLE_VIDEO_URI를 만들어 샘플 비디오의 URL을 정의합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nconst val EXAMPLE_VIDEO_URI = \"https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4\"\n```\n\nmanifest.file에 인터넷 권한을 추가해주세요.\n\n```js\n<uses-permission android:name=\"android.permission.INTERNET\" />\n```\n\n이전에 만든 완성된 코드입니다.\n\n\n<div class=\"content-ad\"></div>\n\n```kotlin\n/**\n * Composable 함수로 ExoPlayer를 사용하여 비디오를 재생하는 기능을 표시합니다.\n *\n * @OptIn 어노테이션인 UnstableApi는 해당 API가 여전히 실험적이며 향후 변경될 수 있다는 것을 나타냅니다.\n *\n * @see EXAMPLE_VIDEO_URI 실제 재생할 비디오의 URI로 대체하세요.\n */\n@OptIn(UnstableApi::class)\n@Composable\nfun ExoPlayerView() {\n    // 현재 컨텍스트 가져오기\n    val context = LocalContext.current\n\n    // ExoPlayer 초기화\n    val exoPlayer = ExoPlayer.Builder(context).build()\n\n    // MediaSource 생성\n    val mediaSource = remember(EXAMPLE_VIDEO_URI) {\n        MediaItem.fromUri(EXAMPLE_VIDEO_URI)\n    }\n\n    // MediaSource를 ExoPlayer에 설정\n    LaunchedEffect(mediaSource) {\n        exoPlayer.setMediaItem(mediaSource)\n        exoPlayer.prepare()\n    }\n\n    // 라이프사이클 이벤트 관리\n    DisposableEffect(Unit) {\n        onDispose {\n            exoPlayer.release()\n        }\n    }\n\n    // AndroidView를 사용하여 Android View(PlayerView)를 Compose에 임베드\n    AndroidView(\n        factory = { ctx ->\n            PlayerView(ctx).apply {\n                player = exoPlayer\n            }\n        },\n        modifier = Modifier\n            .fillMaxWidth()\n            .height(200.dp) // 원하는 높이로 설정\n    )\n}\n```\n\n사용자 지정 UI 컨트롤이 필요하면 play, pause, seek 등을 위한 버튼으로 Composables를 생성하고 exoPlayer를 업데이트하면 됩니다.\n\n이 기능을 테스트하려면 Compose UI에서 ExoPlayeView()를 포함하면 됩니다:\n\n```kotlin\nExoPlayerView()\n```\n\n<div class=\"content-ad\"></div>\n\n코드를 실행하고 결과를 확인해보세요.\n\n![이미지](/assets/img/2024-05-23-HowtodisplayvideosusingExoPlayeronandroidwithJetpackCompose_0.png)\n\n아래에는 해당 예제의 저장소 URL이 있습니다.\n\n## 그러나, 더 복잡한 설정과 동영상 컨트롤을 숨기는 기능이 포함된 다음 두 가지 화면으로 구성된 샘플 프로젝트가 있습니다. 첫 번째는 동영상 목록이고 두 번째는 선택된 동영상의 상세 정보입니다.\n\n<div class=\"content-ad\"></div>\n\n```kotlin\n/**\n * Jetpack Compose를 사용하여 ExoPlayer를 이용한 비디오 플레이어를 표시하는 조합 가능한 함수입니다.\n *\n * @param video 비디오 재생 대상인 [VideoResultEntity]를 나타내는 매개변수입니다.\n * @param playingIndex 현재 재생 중인 인덱스를 나타내는 State입니다.\n * @param onVideoChange 비디오가 변경될 때 호출되는 콜백 함수입니다.\n * @param isVideoEnded 비디오가 종료되었는지를 결정하는 콜백 함수입니다.\n * @param modifier 스타일링 및 위치 지정을 위한 Modifier입니다.\n *\n * UnstableApi에 대한 OptIn 주석은 API가 여전히 실험적이며 미래에 변경될 수 있음을 나타냅니다.\n * \n * OpaqueUnitKey 사용에 대한 경고를 억제하기 위해 이용되는 SuppressLint 주석입니다.\n * \n * 실험적인 Animation API 사용을 위해 ExperimentalAnimationApi 주석이 적용되었습니다.\n */\n@OptIn(UnstableApi::class)\n@SuppressLint(\"OpaqueUnitKey\")\n@ExperimentalAnimationApi\n@Composable\nfun VideoPlayer(\n    video: VideoResultEntity,\n    playingIndex: State<Int>,\n    onVideoChange: (Int) -> Unit,\n    isVideoEnded: (Boolean) -> Unit,\n    modifier: Modifier = Modifier\n) {\n    // 현재 context 가져오기\n    val context = LocalContext.current\n\n    // 비디오 제목의 가시성을 제어하는 Mutable state\n    val visible = remember { mutableStateOf(true) }\n\n    // 비디오 제목을 보유하는 Mutable state\n    val videoTitle = remember { mutableStateOf(video.name) }\n\n    // ExoPlayer를 위한 MediaItems 목록 생성\n    val mediaItems = arrayListOf<MediaItem>()\n    mediaItems.add(\n        MediaItem.Builder()\n            .setUri(video.video)\n            .setMediaId(video.id.toString())\n            .setTag(video)\n            .setMediaMetadata(MediaMetadata.Builder().setDisplayTitle(video.name).build())\n            .build()\n    )\n\n    // ExoPlayer 초기화\n    val exoPlayer = remember {\n        ExoPlayer.Builder(context).build().apply {\n            this.setMediaItems(mediaItems)\n            this.prepare()\n            this.addListener(object : Player.Listener {\n                override fun onEvents(player: Player, events: Player.Events) {\n                    super.onEvents(player, events)\n                    // 200밀리초 후에 비디오 제목 숨김\n                    if (player.contentPosition >= 200) visible.value = false\n                }\n\n                override fun onMediaItemTransition(mediaItem: MediaItem?, reason: Int) {\n                    super.onMediaItemTransition(mediaItem, reason)\n                    // 비디오 변경 시 콜백\n                    onVideoChange(this@apply.currentPeriodIndex)\n                    visible.value = true\n                    videoTitle.value = mediaItem?.mediaMetadata?.displayTitle.toString()\n                }\n\n                override fun onPlaybackStateChanged(playbackState: Int) {\n                    super.onPlaybackStateChanged(playbackState)\n                    // 비디오 재생 상태가 STATE_ENDED로 변경될 때 콜백\n                    if (playbackState == ExoPlayer.STATE_ENDED) {\n                        isVideoEnded.invoke(true)\n                    }\n                }\n            })\n        }\n    }\n\n    // 지정된 인덱스로 이동하고 재생 시작\n    exoPlayer.seekTo(playingIndex.value, C.TIME_UNSET)\n    exoPlayer.playWhenReady = true\n\n    // 생명주기 이벤트에 기반한 플레이어 상태 관리를 위한 생명주기 관찰자 추가\n    LocalLifecycleOwner.current.lifecycle.addObserver(object : LifecycleEventObserver {\n        override fun onStateChanged(source: LifecycleOwner, event: Lifecycle.Event) {\n            when (event) {\n                Lifecycle.Event.ON_START -> {\n                    // Composable이 화면에 있을 때 재생 시작\n                    if (exoPlayer.isPlaying.not()) {\n                        exoPlayer.play()\n                    }\n                }\n\n                Lifecycle.Event.ON_STOP -> {\n                    // Composable이 화면에서 벗어날 때 플레이어 일시정지\n                    exoPlayer.pause()\n                }\n\n                else -> {\n                    // Nothing\n                }\n            }\n        }\n    })\n\n    // 비디오 플레이어를 포함하는 Column Composable\n    Column(modifier = modifier.background(Color.Black)) {\n        // Composable이 소멸될 때 ExoPlayer 해제를 위한 DisposableEffect\n        DisposableEffect(\n            AndroidView(\n                modifier = modifier\n                    .testTag(VIDEO_PLAYER_TAG),\n                factory = {\n                    // Compose에 PlayerView를 포함시키는 AndroidView\n                    PlayerView(context).apply {\n                        player = exoPlayer\n                        layoutParams = FrameLayout.LayoutParams(\n                            ViewGroup.LayoutParams.MATCH_PARENT,\n                            ViewGroup.LayoutParams.MATCH_PARENT\n                        )\n                        // 사용 가능한 공간을 채우는 리사이즈 모드 설정\n                        resizeMode = AspectRatioFrameLayout.RESIZE_MODE_FILL\n                        // 불필요한 플레이어 컨트롤 숨김\n                        setShowNextButton(false)\n                        setShowPreviousButton(false)\n                        setShowFastForwardButton(false)\n                        setShowRewindButton(false)\n                    }\n                })\n        ) {\n            // Composable이 소멸될 때 ExoPlayer 해제\n            onDispose {\n                exoPlayer.release()\n            }\n        }\n    }\n}\n```\n\n## VideoPlayer() 조합 가능한 함수 내용:\n\nMediaItems 및 ExoPlayer 설정:\n\n- 비디오 정보를 담을 MediaItems 목록 생성.\n- ExoPlayer를 해당 MediaItems로 구성하고 준비하며, 비디오 변경 및 재생 상태 변경과 같은 이벤트를 처리할 수 있도록 리스너가 추가됨.\n\n<div class=\"content-ad\"></div>\n\n라이프사이클 관리:\n\n- 리사이클러브 옵서버가 추가되어 Composable 라이프사이클 이벤트를 기반으로 플레이어 상태를 관리합니다. 화면이 포그라운드에 있을 때 플레이어가 재생되고, 백그라운드에 있을 때는 일시정지됩니다.\n\nAndroidView 및 PlayerView 통합:\n\n- AndroidView Composable은 안드로이드 PlayerView를 Jetpack Compose에 삽입하는 데 사용됩니다.\n- PlayerView는 ExoPlayer 인스턴스, 레이아웃 매개변수 및 리사이즈 모드와 플레이어 컨트롤의 가시성과 같은 속성과 함께 구성됩니다.\n\n<div class=\"content-ad\"></div>\n\n휴지통 효과를 위한 정리:\n\n- DisposableEffect는 Composable이 dispose될 때 ExoPlayer 자원을 해제하기 위해 사용됩니다.\n\n총적으로, VideoPlayer Composable은 Jetpack Compose UI 내에서 비디오 재생을 위해 ExoPlayer를 초기화하고 관리하는 로직을 캡슐화합니다.\n\n## 아래 저장소에서 코드를 더 주의 깊게 테스트하고 검토해 주셨으면 좋겠습니다.","ogImage":{"url":"/assets/img/2024-05-23-HowtodisplayvideosusingExoPlayeronandroidwithJetpackCompose_0.png"},"coverImage":"/assets/img/2024-05-23-HowtodisplayvideosusingExoPlayeronandroidwithJetpackCompose_0.png","tag":["Tech"],"readingTime":9},{"title":"안드로이드에서 Work Manager 이해하기","description":"","date":"2024-05-23 12:54","slug":"2024-05-23-UnderstandingWorkManagerinAndroid","content":"\n\n![Work Manager](/assets/img/2024-05-23-UnderstandingWorkManagerinAndroid_0.png)\n\n워크 매니저(Work Manager)는 안드로이드 젯팩(Android Jetpack)의 중요한 구성 요소로, 백그라운드 작업의 미룰 수 있고 보장된 실행을 간단하게 만들기 위해 설계되었습니다. 앱이 종료되거나 장치가 다시 시작되더라도 실행이 보장되어야 하는 작업을 수행해야 하는 경우, Work Manager는 견고하고 유연하며 효율적인 솔루션을 제공합니다. 다양한 안드로이드 버전에서 작동하는 통합 API를 제공하여 현대적인 안드로이드 개발에 필수적인 도구입니다.\n\n## Work Manager의 주요 기능\n\n- 보장된 실행: Work Manager는 앱이 종료되거나 장치가 다시 시작되더라도 백그라운드 작업이 완료되도록 보장합니다. 로그 업로드, 데이터 동기화, 파일 처리와 같은 작업에 특히 유용합니다.\n- 미룰 수 있고 비동기적: 미룰 수 있고 비동기적으로 실행될 수 있는 작업에 대해 설계되었습니다. 이러한 작업은 즉시 실행되지 않아도 되지만 결국 완료되어야 합니다.\n- 배터리 효율적: Work Manager는 JobScheduler, AlarmManager 및 BroadcastReceiver를 내부적으로 사용하여 API 수준과 제공된 제약 조건에 따라 가장 적합한 구현을 선택하여 배터리 수명을 최적화합니다.\n- 제약 조건: 개발자는 네트워크 가용성, 충전 상태 및 작업이 실행되기 전에 충족해야 하는 저장소 조건과 같은 제약 조건을 지정할 수 있습니다. 이는 리소스를 효율적으로 관리하는 데 도움이 됩니다.\n- 작업 연결: Work Manager를 사용하면 여러 작업을 연결하고 복잡한 작업 시퀀스를 관리할 수 있습니다. 이는 이전 작업이 완료된 후에 다음 작업이 시작되어야 하는 종속 작업에 유용합니다.\n- 모니터링 기능:LiveData 또는 콜백 리스너를 통해 작업 상태를 모니터링하고 작업 실행에 대한 제어 및 통찰력을 제공할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n## Work Manager 시작하기\n\n안드로이드 프로젝트에 Work Manager를 통합하려면 다음 단계를 따르세요:\n\n1. 의존성 추가: build.gradle 파일에 필요한 종속 항목을 포함해야 합니다:\n\n```js\nimplementation \"androidx.work:work-runtime-ktx:2.7.1\"\n```\n\n<div class=\"content-ad\"></div>\n\n테이블 태그를 마크다운 형식으로 변경해주세요.\n\n```md\n| Header One | Header Two | Header Three  |\n| ---------- | ---------- | ------------- |\n| Row 1      | Data 1     | Description 1 |\n| Row 2      | Data 2     | Description 2 |\n```\n\n<div class=\"content-ad\"></div>\n\n4. 제약 조건 처리: 작업에 제약 조건을 지정할 수 있습니다. 네트워크 연결이 필요한 경우와 같이:\n\n```js\nval constraints = Constraints.Builder()\n    .setRequiredNetworkType(NetworkType.CONNECTED)\n    .build()\n\nval workRequest = OneTimeWorkRequestBuilder<MyWorker>()\n    .setConstraints(constraints)\n    .build()\nWorkManager.getInstance(context).enqueue(workRequest)\n```\n\n## 고급 사용법\n\n1. 주기적인 작업: 정기적으로 반복되어야 하는 작업에는 PeriodicWorkRequest을 사용하세요:\n\n<div class=\"content-ad\"></div>\n\n```js\nval periodicWorkRequest = PeriodicWorkRequestBuilder<MyWorker>(1, TimeUnit.HOURS)\n    .setConstraints(constraints)\n    .build()\nWorkManager.getInstance(context).enqueue(periodicWorkRequest)\n```\n\n2. Chaining Tasks: Work Manager allows chaining multiple tasks sequentially:\n\n```js\nval workRequest1 = OneTimeWorkRequestBuilder<Worker1>().build()\nval workRequest2 = OneTimeWorkRequestBuilder<Worker2>().build()\n\nWorkManager.getInstance(context)\n    .beginWith(workRequest1)\n    .then(workRequest2)\n    .enqueue()\n```\n\n3. Observing Work Status: You can observe the status of your work requests using LiveData:```\n\n<div class=\"content-ad\"></div>\n\n```js\nWorkManager.getInstance(context).getWorkInfoByIdLiveData(workRequest.id)\n    .observe(this, Observer { workInfo ->\n        if (workInfo != null && workInfo.state.isFinished) {\n            // 작업 완료 처리\n        }\n    })\n```\n\n# 안드로이드에서 Work Manager 사용하는 데 최선의 방법\n\nWork Manager는 안드로이드 애플리케이션의 백그라운드 작업을 효율적으로 관리하는 강력한 도구입니다. 이를 효과적으로 활용하기 위해서는 특정한 최상의 방법을 준수해야 합니다. 이러한 관행은 작업이 효율적으로, 신뢰성 있게 실행되며 시스템 리소스에 미미한 영향을 미칠 수 있도록 보장합니다.\n\n## 1. 적절한 유형의 Work Request 선택하기\n\n\n<div class=\"content-ad\"></div>\n\n**일회성 작업 요청 대 비주기적 작업 요청:**\n\n- 한 번만 실행해야 하는 작업(예: 단일 파일 업로드 또는 특정 시간에 데이터 동기화)은 일회성 작업 요청을 사용합니다.\n- 주기적으로 발생하는 작업(예: 정기적 데이터 동기화 또는 주기적 정리 작업)은 비주기적 작업 요청을 사용합니다.\n\n## 2. 적절한 제약 조건 설정하기\n\n제약 조건을 현명하게 사용하세요:\n\n<div class=\"content-ad\"></div>\n\n- 필요한 제약 조건만 설정하여 작업 수행이 불필요하게 지연되지 않도록 합니다. 일반적인 제약 조건으로는 네트워크 가용성, 장치 충전 상태 및 배터리 레벨이 있습니다.\n- 예시:\n\n```js\nval constraints = Constraints.Builder()\n    .setRequiredNetworkType(NetworkType.CONNECTED)\n    .setRequiresCharging(true)\n    .build()\n```\n\n## 3. 작업 실행 적절히 처리하기\n\n긴 실행 시간이 걸리는 작업을 피하세요:\n\n<div class=\"content-ad\"></div>\n\n- 긴 실행 시간이 소요되는 작업을 작은 관리 가능한 조각으로 나눠보세요. 작업이 상당한 시간이 걸릴 것으로 예상된다면, 여러 작업 요청으로 분할하고 연결하는 것을 고려해보세요.\n\n복잡한 작업에는 ListenableWorker를 사용하세요:\n\n- 비동기 처리가 필요한 작업에는 Worker 대신 ListenableWorker를 사용하세요. 이를 통해 비동기 작업을 더 효율적으로 관리할 수 있습니다.\n\n## 4. 작업 체인 관리\n\n<div class=\"content-ad\"></div>\n\n의존 작업 체인:\n\n- 의존 작업을 연속적으로 실행하도록 작업 체이닝을 사용하십시오. 이는 한 작업의 출력이 다음 작업에서 필요한 워크플로우에 유용합니다.\n\n```js\nWorkManager.getInstance(context).beginWith(workRequest1).then(workRequest2).enqueue();\n```\n\n체인된 작업에서 오류 처리:\n\n<div class=\"content-ad\"></div>\n\n- 워커 클래스에서 적절한 오류 처리를 구현하여 연쇄적으로 발생하는 실패를 관리하세요. 필요한 경우 Result.retry()를 사용하여 작업을 다시 예약하세요.\n\n## 5. 작업 상태 관찰\n\n작업 상태 관찰을 위해 Flow 사용:\n\n- Kotlin의 Flow를 활용하여 작업 요청의 상태를 관찰하세요. 이는 LiveData보다 더 현대적이고 유연한 접근 방식을 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n```kotlin\nimport kotlinx.coroutines.flow.collect\nimport kotlinx.coroutines.flow.map\n\nval workInfoFlow = WorkManager.getInstance(context)\n    .getWorkInfoByIdLiveData(workRequest.id)\n    .asFlow()\n\nlifecycleScope.launch {\n    workInfoFlow.collect { workInfo ->\n        if (workInfo != null && workInfo.state.isFinished) {\n            // Handle the completion of the work\n        }\n    }\n}\n```\n\n## 6. 작업 요청에 태그 사용\n\n식별을 위해 태그 할당:\n\n- 작업 요청에 태그를 할당하여 특정 작업을 쉽게 관리하고 쿼리할 수 있습니다. 특히 특정 작업 세트를 취소하거나 관찰하는 데 유용합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nval workRequest = OneTimeWorkRequestBuilder<MyWorker>()\n    .addTag(\"syncWork\")\n    .build()\n```\n\n태그를 사용하여 작업 취소할 수 있어요:\n\n- 필요한 경우 태그별로 작업 요청을 취소하세요.\n\n## 7. 고유한 작업 요청 처리하기\n\n<div class=\"content-ad\"></div>\n\n유효한 작업에 고유한 작업 사용하기:\n\n- 중복 작업을 피하기 위해 고유한 작업 요청을 사용하세요. enqueueUniqueWork을 사용하면 특정 작업 요청의 인스턴스가 한 번에 하나만 실행됩니다.\n\n```js\nWorkManager.getInstance(context).enqueueUniqueWork(\"고유작업이름\", ExistingWorkPolicy.REPLACE, workRequest);\n```\n\n## 8. 자원 사용량 최적화\n\n<div class=\"content-ad\"></div>\n\n리소스 영향 최소화:\n\n- 시스템 리소스에 미치는 영향을 최소화하기 위해 적절한 제약 조건을 사용합니다. 예를 들어, 필요할 때만 네트워크 연결을 요구합니다.\n- 장치에 부하를 줄이기 위해 재시도에 지수 백오프를 고려해보세요.\n\n배경 최적화 활용:\n\n- Work Manager의 내장 최적화 기능을 활용하여 배터리 및 네트워크를 고려한 스케줄링을 통해 효율적인 작업 실행을 보장하세요.\n\n<div class=\"content-ad\"></div>\n\n## 9. 테스트 및 디버깅\n\n작업 요청을 철저히 테스트하세요:\n\n- 다양한 조건에서 작업 요청을 테스트하여 예상대로 작동하는지 확인하세요. 온라인이 아닌, 배터리 부족 또는 재부팅 중인 등 다양한 장치 상태를 포함합니다.\n\n로깅 및 디버깅 도구 사용하기:\n\n<div class=\"content-ad\"></div>\n\n- 작업 실행 문제를 해결하기 위해 로깅 및 Work Manager의 디버깅 도구를 활용해보세요. adb shell dumpsys activity service를 사용하면 Work Manager의 내부 상태를 확인할 수 있습니다.\n\n## 결론\n\nWork Manager는 Android 애플리케이션에서 백그라운드 작업을 처리하는 필수 도구로, 앱이 실행되지 않을 때에도 일을 수행할 수 있는 일관적이고 신뢰할 수 있는 방법을 제공합니다. 제약 조건, 작업 체인, 주기적 작업과 같은 기능들을 통해 다양한 유즈케이스에 유연성을 제공합니다. Android 프로젝트에 Work Manager를 통합하면 백그라운드 작업 실행의 효율성과 신뢰성이 크게 향상될 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-05-23-UnderstandingWorkManagerinAndroid_0.png"},"coverImage":"/assets/img/2024-05-23-UnderstandingWorkManagerinAndroid_0.png","tag":["Tech"],"readingTime":7},{"title":"컴포즈 멀티플랫폼Android iOS으로 UI 중심 안드로이드 라이브러리 이주하기","description":"","date":"2024-05-23 12:52","slug":"2024-05-23-MigratingUI-orientedAndroidlibrarytoComposeMultiplatformAndroidiOS","content":"\n연혁을 거듭하면서, Kotlin Multiplatform이 드디어 여기 머물 것 같습니다. 그러나 비즈니스 로직만 공유하는 것이 특히 React Native, Flutter 및 기타 기술이 더 많은 일을 할 수 있는 만큼 편리하고 경쟁력이 있다고 느끼는 어색한 느낌이 아직 남아 있었습니다. 그래서 매우 기대되었던 Compose Multiplatform for iOS의 첫 번째 알파 버전을 작년에 보게 되어 정말 기뻤습니다.\n\n퍼즐이 마침내 맞추어졌습니다. 이제 안드로이드 개발자들은 최소한의 추가 노력으로 iOS 앱을 코틀린으로 만들 수 있습니다. 그러나 이게 정말 그럴까요? 알아봅시다. 여기서는 라이브러리 이전에 대해 설명하겠습니다. 전체 애플리케이션을 이전할 때 몇 가지 점이 다를 수 있습니다.\n\n<img src=\"/assets/img/2024-05-23-MigratingUI-orientedAndroidlibrarytoComposeMultiplatformAndroidiOS_0.png\" />\n\n## 내 경우에 관하여\n\n<div class=\"content-ad\"></div>\n\n안녕하세요! 안드로이드/Kotlin과 iOS/Swift 클라이언트가 있습니다. 두 클라이언트 모두 다음 UI 기능을 갖춘 자체 제작 라이브러리를 사용합니다:\n\n- 정적으로 로드할 수 있는 이미지\n- 로드 가능한 GIF\n- 비디오 (CDN으로부터 스트리밍 로딩)\n- 모든 항목은 수직 목록에 수평 목록이 내장됩니다\n\n추가로:\n\n- 네트워크 통신\n- 디스크 캐싱\n\n언제든지 물어보세요!\n\n<div class=\"content-ad\"></div>\n\n\n![image](https://miro.medium.com/v2/resize:fit:472/1*4Eb5MmEXdZwZC8WkYBB6yA.gif)\n\n우리에게는 Compose Multiplatform 기능과 성능을 테스트하는 좋은 시작점이었습니다. 무엇이 문제가 될 수 있는지 알고 싶다면, 여기에서 확인해보세요.\n\n## 왜 Compose Multiplatform 인가요?\n\n일부 소스에서 Jetpack Compose를 선언적 API로 설명합니다. 저에게 있어 Jetpack Compose의 주요 장점은 전통적인 XML 레이아웃과 비교했을 때의 유연성입니다. 그리고 Jetpack Compose에서 레이아웃을 작성한 후에는 Compose Multiplatform로 이전하는 것이 정말 어렵지 않습니다.\n\n\n<div class=\"content-ad\"></div>\n\n비즈니스적인 관점에서 주요 방해 요인이 없이 코드베이스를 점진적으로 통합하는 것이 더 쉽습니다. 추가 개발자가 필요하지 않습니다. 그것이 Compose Multiplatform이 허용하는 것입니다.\n\nJetbrains에 따르면, 이것이 어떻게 작동하는지 간단히 상기시켜 드리겠습니다:\n\n![Jetbrains Image](/assets/img/2024-05-23-MigratingUI-orientedAndroidlibrarytoComposeMultiplatformAndroidiOS_1.png)\n\n## 코드베이스에서의 장애물\n\n<div class=\"content-ad\"></div>\n\n가끔 우리는 모두 KMP 코드가 아닌 코드를 작성하거나 사용합니다. 때로는 많을 때도 있죠.\n\n전형적인 예시는 다음과 같습니다:\n\n- Java 코드\n- Dagger 2, RxJava, Retrofit 등과 같은 호환되지 않는 라이브러리 종속성\n- XML 레이아웃, 뷰, 프래그먼트\n- 안드로이드 서비스, 푸시 알림, 인앱 구매\n- 그 밖에도...\n\n여기에는 주로 2가지 해결책이 있습니다:\n\n- 코드를 다시 작성하거나 KMP 호환 라이브러리로 이전하여 commonMain 폴더에 넣습니다.\n- 호환되지 않는 코드를 플랫폼별 서브모듈인 androidMain 및 iosMain에 넣습니다.\n\n<div class=\"content-ad\"></div>\n\n사실 platform-specific 하위 모듈에 항상 코드를 넣을 수 있습니다. 그러나 이 경우에는 iOS용으로 코드를 작성하거나 iOS에서도 구현해야 합니다.\n\n## iOS에 특정한 코드를 작성하는 방법은?\n\niOS 플랫폼별 코드를 정의하거나 사용하는 데는 2가지 주요 옵션이 있습니다:\n\n옵션 1.\niosMain 폴더에 구현된 Expect/actual 함수.\n다음은 구조가 어떻게 보이는지 예시입니다:\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-05-23-MigratingUI-orientedAndroidlibrarytoComposeMultiplatformAndroidiOS_2.png\" />\n\n옵션 2.\niOS 측에서 호출할 수 있는 몇 가지 커넥터를 제공합니다.\n다음은 commonMain에서 빈 로거를 정의하는 예입니다:\n\n```kotlin\nobject Bridge {\n    var logger: (String) -> Unit = {}\n    ...\n}\n```\n\niOS/Swift 앱에서 로거에 대한 구현을 할당합니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nimport ...\n\nBridge.shared.logger = {\n    print(\"ios log: \" + $0)\n}\n```\n\n그냥 간단한 경우일 뿐입니다. 사실 거의 모든 것을 이 방법으로 연결할 수 있습니다. commonMain에서 인터페이스를 정의하고 전체 구현을 별도로 Swift로 작성하는 것도 가능합니다.\n\n물론 작성해야 하는 플랫폼별 코드가 많아질수록 더 나쁠 수 있습니다. 제 상황에서는 iosMain에 전체 라이브러리 코드의 약 9%가 있고, androidMain에는 약 13%가 있습니다. 이 비율은 여러분의 상황에서는 낮을 수도 있습니다.\n\n## 어떻게 마이그레이션을 시작할까요?\n\n<div class=\"content-ad\"></div>\n\n우리는 Android/Kotlin 및 iOS/Swift 클라이언트를 보유하고 있습니다. 통합을 시작하는 방법은 무엇일까요?\n\nAndroid의 경우, 기존 앱 또는 라이브러리에 KMP(코틀린 멀티플랫폼)과 호환되는 코드를 단계별로 다시 작성하여 통합할 수 있습니다. 언어는 그대로 유지되지만 의존하는 접근 방식과 라이브러리는 변경될 수 있습니다.\n\n간단한 경우에는 다음과 같습니다:\n\n- 코드베이스에 KMP 모듈을 만듭니다.\n- 코드를 공통 모듈(commonMain)로 순차적으로 이동시킵니다.\n- 플랫폼에서 이동할 수 없는 부분에 대한 커넥터를 만듭니다.\n\n<div class=\"content-ad\"></div>\n\n우리는 우리의 경우에 iOS와 안드로이드 클라이언트가 의존하는 UI 중심 라이브러리를 마이그레이션하기로 결정했습니다. 그 라이브러리를 완전히 다시 작성해야 했던 이유는 RxJava와 XML 레이아웃을 기반으로 했기 때문이었습니다.\n\n## 우리의 주요 기술 변화\n\nRxJava → Coroutines / Flow\n만약 Rx를 사용 중이라면 Flow로 마이그레이션하거나 Reaktive와 같은 KMP 대안을 사용해야 합니다.\n\nRetrofit → Ktor\nKtor는 매우 편리한 네트워크 라이브러리입니다. 큰 문제는 없었습니다. 여러 번 검색해서 익숙했던 것을 어떻게 쓰는지 찾아보면 됩니다.\n\n<div class=\"content-ad\"></div>\n\nRoom → Room?\n제 경우에는 일반 디스크 캐싱을 Okio로 대체하는 것이 허용되었습니다. 하지만 사실 Room은 KMP도 지원합니다.\n\nGlide → Coil 3 + iOS용 자체 GIF 구현.\nCoil 3는 아직 알파 버전이지만 동작합니다. 제 경우 문제는 iOS에서 GIF를 재생할 수 없었던 것이었습니다. 안타깝게도 몇 일 동안 문제를 해결하고 디스크 캐싱을 통해 해결책을 구현하는 데 시간이 걸렸습니다.\n\n제 경우 이미지에 대한 기본 계약:\n\n```js\n@Composable\nexpect fun LoadableImage(\n    modifier: Modifier,\n    url: String,\n    imageColorFilter: ColorFilter? = null,\n    size: Size? = null,\n)\n```\n\n<div class=\"content-ad\"></div>\n\nJetpack ExoPlayer → ExoPlayer + AVPlayer\n우리는 각 플랫폼마다 플레이어를 대체하기 위해 expect/actual을 사용합니다.\nExoPlayer는 디스크 캐싱 및 스트리밍 재생 기능을 갖춘 안드로이드용 강력한 솔루션입니다.\nAvPlayer는 iOS의 기본 솔루션입니다.\n\n플레이어의 기본 계약:\n\n```js\n@Composable\nexpect fun VideoPlayer(\n    modifier: Modifier,\n    url: String,\n    volumeEnabled: State<Boolean>,\n)\n```\n\n## 안드로이드용 빌드 방법\n\n<div class=\"content-ad\"></div>\n\n안드로이드의 경우 일반적인 안드로이드 라이브러리와 유사합니다. 이 라이브러리는 애플리케이션의 모듈로 사용할 수 있습니다. 현재는 이것이 우리의 선택입니다.\n\n다른 옵션으로 그레이들 복합 빌드를 사용할 수도 있습니다. 자세한 내용은 다음 기사를 참조하세요:\n\n마지막으로, 그레이들 작업 bundleReleaseAar을 사용하여 라이브러리를 .aar 파일로 조립할 수 있습니다.\n\n## iOS용 빌드 방법\n\n<div class=\"content-ad\"></div>\n\n로컬 개발 중에는 XCFramework을 빌드하고 iOS 프로젝트에 넣습니다. 프로세스는 여기에 설명되어 있습니다:\n\n간단히 말하면 다음과 같습니다:\n\n- Gradle 작업을 호출합니다.\n  로컬 빌드(빠름)의 경우 iosX64Binaries 또는 iosArm64Binaries를 사용하거나 최종 이진 파일의 경우 assembleReleaseXCFramework를 사용합니다(느림).\n- build/bin/iosArm64/releaseFramework (또는 유사한 경로)에서 결과물을 iOS 프로젝트로 복사합니다.\n- Xcode에 의해 동기화될 때까지 잠시 기다립니다.\n- 완료. iOS 프로젝트에서 Kotlin 코드를 사용하세요.\n\n자동화된 CI/CD 파이프라인에서는 프로세스가 약간 다르지만 이는 다른 이야기입니다.\n\n<div class=\"content-ad\"></div>\n\n## 나의 경우의 결과\n\n현재 저희 이주 작업은 사전 제작 단계에 있지만, 이미 몇 가지 결론을 도출할 수 있습니다.\n\n🟢 기능성.\n저희 라이브러리의 모든 주요 기능이 이주되었습니다.\n일부 비중요한 예외를 제외하고 기능 요구 사항이 충족되었습니다.\n\n🟢 코드베이스.\n이와 같이 재작성하는 것은 많은 레거시 코드를 제거할 수 있는 기회입니다.\n숫자:\n이주 이전: 10,000 줄 코드, 1,200 줄 XML\n이후: 4,000 줄 코드\n결과: 기존 버전과 비교했을 때 코드 양이 약 2.5배 감소했습니다.\n\n<div class=\"content-ad\"></div>\n\n🟢 성능.\niOS에서는 iPhone SE에서도 부드럽게 스크롤됩니다.\n저사양 안드로이드 기기에서는 XML 버전과 비교했을 때 그렇게 부드럽지 않지만, 심각한 문제는 아닙니다.\n\n🟡 개발 생산성.\n일반적으로, 현대적인 안드로이드 개발과 Jetpack Compose에 익숙하다면 주요 문제가 없을 것입니다. 다만 제 경험상 한 가지 예외가 있습니다: Android Studio 및 IDEA에는 미리보기가 없습니다. Fleet에서는 작동하지만 AS/IDEA에서는 Composable 함수를 블라인드로 작성해야 합니다.\n\n🟡 이진 크기.\nAndroid APK: + 0.5 MB\niOS IPA: + 18 MB\n\n🟡 라이브러리 크기.\n거대한 XCFrameworks 크기. 300MB 이상입니다.\n\n<div class=\"content-ad\"></div>\n\n🔴 빌드 시간.\niOS의 빌드 시간이 길어요. 기계에 따라 다르지만 라이브러리 4k 줄의 코드를 가지고 17분 같은 숫자를 볼 수 있어요.\n\n## 결론\n\n2024년에는 Kotlin으로 크로스 플랫폼 UI를 작성하는 것이 전혀 가능합니다.\n\nKMP와 Compose Multiplatform의 멋진 점은 Kotlin으로 코드를 작성해야 한다면, 왜 KMP 호환 방식으로 작성하지 않을까요?\n\n<div class=\"content-ad\"></div>\n\n우리의 경우에는 결과가 수용 가능하며, 스트레스 테스트로 간주할 수 있습니다. 또한 iOS용 Compose Multiplatform이 알파 단계에 있고, Kotlin 2가 미래에 있음을 염두에 두어야 합니다.\n\n읽어 주셔서 감사합니다!\n","ogImage":{"url":"/assets/img/2024-05-23-MigratingUI-orientedAndroidlibrarytoComposeMultiplatformAndroidiOS_0.png"},"coverImage":"/assets/img/2024-05-23-MigratingUI-orientedAndroidlibrarytoComposeMultiplatformAndroidiOS_0.png","tag":["Tech"],"readingTime":7},{"title":"유용한 정보 공유 - 소셜 미디어에서 Composables 사용하는 방법","description":"","date":"2024-05-23 12:51","slug":"2024-05-23-SomethingWorthSharingHowtouseComposablesonSocialMedia","content":"\n\n![Screenshot](/assets/img/2024-05-23-SomethingWorthSharingHowtouseComposablesonSocialMedia_0.png)\n\n# 사진이 없으면 일어나지 않았어요\n\n인스타그램 게시물은 황홀한 모험의 마무리 또는 무기화된 FOMO의 조각일 수 있어요. 어쨌든 사람들은 자신의 하이라이트와 취미를 소셜 미디어에 기억하기를 좋아해요.\n\n최근에 Viz 앱에 공유 기능을 추가했어요. 이제 다이버와 스노클러도 이 의식에 참여할 수 있어요. 당시에는 Compose에서 생성된 아름다운 뷰를 Instagram, TikTok, Twitter 등에서 공유 가능한 이미지로 어떻게 변환하는지에 대해 온라인에 많이 쓰여 있지 않았어요.\n\n<div class=\"content-ad\"></div>\n\n이제 다른 쪽으로 나와서 스스로 구현하는 방법을 안내해 드릴게요! 순서는 대략 다음과 같아요:\n\n- 공유하고 싶은 모든 콘텐츠를 포함하는 컴포저블 만들기\n- 컴포저블을 이미지로 변환하기\n- 안드로이드의 Sharesheet를 사용하여 이미지를 공유하기\n\n제가 공유된 백 엔드 코드를 작성할 때 KMP를 사용하고 있지만, UI는 Android 및 iOS에 대해 별도로 네이티브로 작성했어요. Android 버전은 아래에 작성되어 있고 SwiftUI 버전은 다음 주 별도의 기사에서 공유될 예정이에요!\n\n# 공유 가능한 형식 디자인하기\n\n<div class=\"content-ad\"></div>\n\n삼격하고 상대적으로 높은 이동성을 가지고 있는 정사각형은 모든 소셜 미디어 플랫폼에서 최적의 화면 비율이에요. 인스타그램을 예로 들어보면—이 모양은 스크롤 피드에서 \"게시물\"로 공유되거나 전체 화면 \"스토리\"에 쉽게 가운데 정렬될 수 있어요.\n\n이 이상적인 크기는 두 가지 요소에 따라 다릅니다:\n\n- 이미지로 공유될 때 선명하고 뚜렷하게 보이기 위한 충분한 세부 정보가 있는 크기\n- 디자인 시스템에서 폰트 스타일 토큰을 수용할 수 있는 크기 (원시 작성, Material3 또는 다른 것)\n\n저는 안드로이드에서 400.dp부터 500.dp 크기가 이 두 목표를 모두 잘 이루어낼 수 있다고 생각해요. 대부분의 휴대폰에서 전체 화면 크기로 변환될 거예요. 그리고 이 크기에서 '제목', '헤드라인', '본문'과 같은 폰트 스타일을 사용하면 본인만의 원시 폰트 크기를 계산할 필요 없이 손쉽게 사용할 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n```kotlin\n@Composable\nfun MyShareContent() {\n    val headline = MaterialTheme.typography.headlineLarge\n    val title = MaterialTheme.typography.titleLarge\n\n    Box(\n        modifier = Modifier\n            .size(400.dp)\n            .background(color = MaterialTheme.colorScheme.surface)\n    ) {\n        Column(\n            verticalArrangement = Arrangement.SpaceBetween,\n            horizontalAlignment = Alignment.CenterHorizontally,\n            modifier = Modifier\n                .padding(12.dp)\n                .fillMaxSize(),\n        ) {\n            Icon(\n                painter = painterResource(id = R.drawable.v3_logo_with_text),\n                tint = Color.Unspecified, // 원본 SVG 색상 유지\n                contentDescription = null,\n                modifier = Modifier.height(200.dp)\n            )\n            Text(text = \"Moon Bay Marine Reserve\", style = headline)\n\n            Row(\n                horizontalArrangement = Arrangement.SpaceBetween,\n                modifier = Modifier.fillMaxWidth()\n            ) {\n                Text(text = \"Date\", style = title)\n                Text(text = \"Thursday 10 April 2024\", style = title)\n            }\n\n            Row(\n                horizontalArrangement = Arrangement.SpaceBetween,\n                modifier = Modifier.fillMaxWidth()\n            ) {\n                Text(text = \"Time\", style = title)\n                Text(text = \"10:20 - 11:45\", style = title)\n            }\n        }\n    }\n}\n```\n\n![Image](/assets/img/2024-05-23-SomethingWorthSharingHowtouseComposablesonSocialMedia_1.png)\n\n# 그래픽 레이어에 Composable 기록하기\n\nCompose의 최신 버전(1.7)에서는 훌륭한 GraphicsLayer API가 소개되었습니다. 이는 Composable의 그리기를 캡처하고 다른 위치에서 재생하는 방법을 제공합니다. 결국 이를 사용하여 Composable을 이미지 파일로 기록할 것입니다.\n\n\n<div class=\"content-ad\"></div>\n\n```kotlin\nvar graphicsLayer = rememberGraphicsLayer()\n\nBox(modifier = Modifier\n    .size(400.dp)\n    .drawWithCache {\n        // draw to graphics layer\n        graphicsLayer = obtainGraphicsLayer().apply {\n            record { drawContent() }\n        }\n        // draw to actual UI\n        onDrawWithContent { drawContent() }\n    }) {\n    // The content being recorded\n    Surface(modifier = Modifier.fillMaxSize()) {\n        MyShareContent()\n    }\n}\n```\n\n이 코드 스니펫의 주요 기능:\n\n- Box를 부모 컨테이너로 사용\n- 공유하려는 컴포저블을 Box의 콘텐츠 매개변수에 배치\n- drawWithCache 수정자를 사용하여 콘텐츠의 그리기를 캡처\n- record 메서드를 사용하여 그림을 저장된 graphicsLayer 변수로 리디렉션\n\n# 컴포저블 그리기를 완전히 건너뛰기\n  \n\n<div class=\"content-ad\"></div>\n\n컴포저블을 화면에서 숨기고 전혀 표시하지 않을 수도 있습니다.\n\nViz 앱에서 사용자가 게시물을 저장한 후에는 전체 상세 버전을 보여줍니다. 그러나 소셜 미디어에 공유하기 위한 간단한 요약 버전을 제공합니다. 이 경우 화면에 전체 버전을 표시하고 공유 가능한 버전은 오프스크린에서 생성합니다.\n\n이를 달성하려면 코드에 몇 가지 변경 사항이 필요합니다 —\n\n```js\nvar graphicsLayer = rememberGraphicsLayer()\n\nBox(modifier = Modifier\n    .size(0.dp) // UI에 공간을 사용하지 않도록 크기를 0으로\n    .drawWithCache {\n        // 그래픽 레이어에 그리기\n        graphicsLayer = obtainGraphicsLayer().apply {\n            record(\n                size = IntSize(\n                    width = 400.dp.toPx().toInt(),\n                    height = 400.dp.toPx().toInt()\n                )\n            ) {\n                drawContent()\n            }\n        }\n\n        // 화면에 그리기를 건너뛰기 위해 비워 두기\n        onDrawWithContent { }\n    }) {\n    Box(\n        // 녹화의 원하는 크기로 부모 크기를 재정의\n        modifier = Modifier\n            .wrapContentHeight(unbounded = true, align = Alignment.Top)\n            .wrapContentWidth(unbounded = true, align = Alignment.Start)\n            .requiredSize(400.dp)\n    ) {\n        // 녹화되는 내용\n        Surface(modifier = Modifier.fillMaxSize()) {\n            MyShareContent()\n        }\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n이 코드 스니펫의 주요 기능은 다음과 같습니다:\n\n- 부모 Box 콤포저블은 크기를 0.dp로 설정합니다.\n- onDrawWithContent ' '은 비워두었는데요 — 이것은 화면에 그리는 것을 건너뛸 때 사용됩니다.\n- 자식 콤포저블에는 wrapContentHeight 및 wrapContentWidth 수정자를 사용하여 unbound = true로 설정합니다.\n- 자식 콤포저블에는 desired size를 지정하기 위해 requiredSize 수정자를 사용하여 크기를 설정합니다(400.dp).\n\n# 그래픽 레이어를 이미지 파일에 작성하세요\n\nAndroid 플랫폼에 파일을 작성할 때, 성능, 권한, API의 가용성 등 여러 가지 고려할 사항이 있습니다.\n\n<div class=\"content-ad\"></div>\n\n간결함과 집중을 위해 여기에 기본적인 해결책을 제시할게요. 안드로이드 14에서 잘 작동하는데요, 미디어 저장소 API로의 이동이라는 소문에도 불구하고요. 파일을 공유 Pictures 디렉토리에 쓰고, 미디어 스캐너를 사용하여 공유 가능한 URI를 생성함으로써 대부분의 권한 고려 사항을 회피할 수 있어요.\n\n파일 작성에 대해 미묘하게 다루고 싶다면, Wan Xiao의 다음 글을 추천드려요 -\n\n지금은 다음과 같은 과정을 따를 거에요:\n\n- 그래픽 레이어를 비트맵으로 변환\n- 비트맵을 PNG로 압축\n- PNG를 Pictures 디렉토리에 파일로 쓰기\n- 새 이미지 파일의 URI 가져오기\n\n<div class=\"content-ad\"></div>\n\n```kotlin\nprivate suspend fun GraphicsLayer.saveAsShareableFile(context: Context): Uri? {\n    \n    // 비트맵으로 변환\n    val bitmap = this.toImageBitmap().asAndroidBitmap()\n\n    // 파일 생성\n    val file = File(context.getExternalFilesDir(Environment.DIRECTORY_PICTURES),\n        \"my-app-post-${System.currentTimeMillis()}.png\")\n\n    // PNG로 비트맵을 파일에 쓰기\n    file.outputStream().use { out ->\n        bitmap.compress(Bitmap.CompressFormat.PNG, 100, out)\n        out.flush()\n    }\n\n    // 공유를 위한 파일 URI 가져오기\n    return file.scanPath(context)\n}\n\nsuspend fun File.scanPath(context: Context): Uri? {\n    // 코루틴으로 자바 콜백 래핑\n    return withTimeoutOrNull(timeMillis = 5000) {\n        suspendCancellableCoroutine { continuation ->\n            MediaScannerConnection.scanFile(\n                context,\n                arrayOf(path),\n                arrayOf(\"image/png\")\n            ) { scannedPath, scannedUri ->\n                continuation.resume(scannedUri)\n            }\n        }\n    }\n}\n```\n\n사회적 공유 이미지를 위해 PNG를 사용하는 것을 추천합니다. 텍스트가 포함된 이미지일 경우 선명도를 보존하는 것이 중요합니다. 각 소셜 미디어 플랫폼은 이미지를 원하는 크기와 형식으로 압축하기 때문에 이미지의 품질을 최대로 유지해야 합니다.\n\n# 버튼으로 프로세스 시작\n\n이미지 URI를 얻은 후에는 공유 인텐트를 생성하여 어디든 전송할 수 있습니다. 이렇게 하면 Android 공유 시트가 열리고 나머지 프로세스를 자동으로 처리합니다 — 추가적인 코드는 필요하지 않습니다!\n\n\n<div class=\"content-ad\"></div>\n\n```kotlin\nval context = LocalContext.current\nval coroutineScope = rememberCoroutineScope()\nvar graphicsLayer = rememberGraphicsLayer()\n\nButton(onClick = {\n    coroutineScope.launch {\n        if (graphicsLayer.size.width > 0 && graphicsLayer.size.height > 0) {\n            val uri = graphicsLayer.saveAsShareableFile(context)\n            val shareIntent: Intent = Intent().apply {\n                action = Intent.ACTION_SEND\n                putExtra(Intent.EXTRA_STREAM, uri)\n                type = \"image/png\"\n            }\n            startActivity(\n                context, Intent.createChooser(shareIntent, \"share\"), null\n            )\n        }\n    }\n\n}) {\n    // imo - nicer than IconButton with text\n    Row(horizontalArrangement = Arrangement.spacedBy(ButtonDefaults.IconSpacing)) {\n        Icon(\n            Icons.Default.Share,\n            contentDescription = null,\n            modifier = Modifier.size(18.dp)\n        )\n        Text(\n            text = \"Share\", style = MaterialTheme.typography.labelLarge\n        )\n    }\n}\n\n// Shareable 컴포저블을 여기에 포함하세요...\n```\n\n이 코드 스니펫에서 중요한 기능:\n\n- 부모 컴포저블에 범위 지정된 코루틴 시작\n- 그래픽 레이어가 0보다 큰지 확인하여 실행 보호\n- 이전에 생성한 헬퍼 확장 기능을 사용하여 그래픽 레이어 저장\n- 공유 Intent 생성 및 시작\n\n이러한 기능은 ViewModel에서 구현하는 것이 좋을까요?```\n\n<div class=\"content-ad\"></div>\n\n전체 과정은 다른 상태와 상호 작용할 필요 없이 구성 가능한 내부에 포함될 수 있습니다.\n\n또한 컴포저블 내에 Context를 유지하고 관리하는 것이 더 쉽습니다. 이러한 이유로, 버튼의 onClick 매개변수에서 코루틴을 직접 시작하는 것을 권장합니다.\n\n# 전체 코드 — 모든 것을 함께 넣기\n\n그래 — 이제 복사/붙여넣기 시간입니다!\n\n<div class=\"content-ad\"></div>\n\n```kt\n// 모든 명확하지 않은 임포트\n// 더 짧게 하기 위해 구성 임포트는 제외\nimport android.content.Context\nimport android.content.Intent\nimport android.graphics.Bitmap\nimport android.media.MediaScannerConnection\nimport android.net.Uri\nimport android.os.Environment\nimport androidx.core.content.ContextCompat.startActivity\nimport kotlinx.coroutines.launch\nimport kotlinx.coroutines.suspendCancellableCoroutine\nimport kotlinx.coroutines.withTimeoutOrNull\nimport java.io.File\nimport kotlin.coroutines.resume\n\n@Composable\nfun MyShareScreen() {\n    val context = LocalContext.current\n    val coroutineScope = rememberCoroutineScope()\n    var graphicsLayer = rememberGraphicsLayer()\n\n    Column {\n        Button(onClick = {\n            coroutineScope.launch {\n                if (graphicsLayer.size.width > 0 && graphicsLayer.size.height > 0) {\n                    val uri = graphicsLayer.saveAsShareableFile(context)\n                    val shareIntent: Intent = Intent().apply {\n                        action = Intent.ACTION_SEND\n                        putExtra(Intent.EXTRA_STREAM, uri)\n                        type = \"image/png\"\n                    }\n                    startActivity(\n                        context, Intent.createChooser(shareIntent, \"share\"), null\n                    )\n                }\n            }\n\n        }) {\n            // IMO - nicer than IconButton with text\n            Row(horizontalArrangement = Arrangement.spacedBy(ButtonDefaults.IconSpacing)) {\n                Icon(\n                    Icons.Default.Share,\n                    contentDescription = null,\n                    modifier = Modifier.size(18.dp)\n                )\n                Text(\n                    text = \"Share\", style = MaterialTheme.typography.labelLarge\n                )\n            }\n        }\n\n        Box(modifier = Modifier\n            .size(0.dp) // size 0 so that no space is used in the UI\n            .drawWithCache {\n                // draw to graphics layer\n                graphicsLayer = obtainGraphicsLayer().apply {\n                    record(\n                        size = IntSize(\n                            width = 400.dp.toPx().toInt(),\n                            height = 400.dp.toPx().toInt()\n                        )\n                    ) {\n                        drawContent()\n                    }\n                }\n\n                // leave blank to skip drawing on the screen\n                onDrawWithContent { }\n            }) {\n            Box(\n                // override the parent size with desired size of the recording\n                modifier = Modifier\n                    .wrapContentHeight(unbounded = true, align = Alignment.Top)\n                    .wrapContentWidth(unbounded = true, align = Alignment.Start)\n                    .requiredSize(400.dp)\n            ) {\n                // The content being recorded\n                Surface(modifier = Modifier.fillMaxSize()) {\n                    Text(\"My Share Content Here\")\n                }\n            }\n        }\n    }\n}\n\nsuspend fun GraphicsLayer.saveAsShareableFile(context: Context): Uri? {\n\n    // convert to bitmap\n    val bitmap = this.toImageBitmap().asAndroidBitmap()\n\n    // create file\n    val file = File(context.getExternalFilesDir(Environment.DIRECTORY_PICTURES),\n        \"my-app-post-${System.currentTimeMillis()}.png\")\n\n    // write bitmap to file as PNG\n    file.outputStream().use { out ->\n        bitmap.compress(Bitmap.CompressFormat.PNG, 100, out)\n        out.flush()\n    }\n\n    // get file URI for sharing\n    return file.scanPath(context)\n}\n\nsuspend fun File.scanPath(context: Context): Uri? {\n    // wrap java callback in coroutine\n    return withTimeoutOrNull(timeMillis = 5000) {\n        suspendCancellableCoroutine { continuation ->\n            MediaScannerConnection.scanFile(\n                context,\n                arrayOf(path),\n                arrayOf(\"image/png\")\n            ) { scannedPath, scannedUri ->\n                continuation.resume(scannedUri)\n            }\n        }\n    }\n}\n```\n\n![이미지](https://miro.medium.com/v2/resize:fit:1200/1*wX0_iwYqjzYVOm9Qu4pv1A.gif)\n\n# 정리합니다\n\n저는 Viz 앱을 개발하고 운영하는 독립 개발자입니다. 이 앱은 Kotlin Multiplatform을 활용한 네이티브 iOS 및 Android 앱입니다. 호주에서 다이빙, 스노클링 또는 프리다이빙을 즐기는 분들에게 꼭 한번 확인해보세요! 이 앱은 사람들이 서로 물 조건을 공유하고 해저 사진을 업로드하며 다이빙 로그를 유지할 수 있는 공간입니다. 항상 무료이며 가입이 필요하지 않습니다.```\n\n<div class=\"content-ad\"></div>\n\n잘못된 부분이나 버그를 발견하셨나요? 제안이나 대안이 있으시다면 언제든지 편하게 피드백해주세요! 이 기사에 몇 가지 수정사항을 추가하는 것에 항상 열려있습니다!\n\n그렇지 않다면, 여러분들이 이 내용을 유용하게 사용하고 있는지 알기 위해 언제나 의견/좋아요 등을 감사히 받겠습니다 :)","ogImage":{"url":"/assets/img/2024-05-23-SomethingWorthSharingHowtouseComposablesonSocialMedia_0.png"},"coverImage":"/assets/img/2024-05-23-SomethingWorthSharingHowtouseComposablesonSocialMedia_0.png","tag":["Tech"],"readingTime":13}],"page":"24","totalPageCount":68,"totalPageGroupCount":4,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true}