{"pageProps":{"posts":[{"title":"안녕하세요 VSCode에서 플러터 앱을 실행하고 디버그하기 위해 안드로이드 기기를 WiFi로 연결하는 방법에 대해 이야기하겠습니다","description":"","date":"2024-05-20 16:19","slug":"2024-05-20-ConnectYourAndroidDeviceOverWiFiinVSCodetoRunandDebugYourFlutterApp","content":"\n\n<img src=\"/assets/img/2024-05-20-ConnectYourAndroidDeviceOverWiFiinVSCodetoRunandDebugYourFlutterApp_0.png\" />\n\n# 핸드폰 배터리 손상하지 말고 앱 테스트, 케이블 없이 디버깅하세요 (거의).\n\n이 게시물은 이미 USB 연결로 Android 기기에서 실행 및 디버깅을 구성했다고 가정합니다. Android 13 기기 및 Windows 10 컴퓨터에서 테스트되었습니다. 컴퓨터와 휴대폰 모두 동일한 네트워크에 연결되어 있어야 합니다.\n\n## 일회성 IDE 및 장치 구성\n\n<div class=\"content-ad\"></div>\n\n- [Optional] VSCode 확장 프로그램인 ADB Commands를 설치하세요. 안 깔았다면 adb 명령어를 사용할 수 있어요. 확장 프로그램을 사용하는 편이 더 직관적이고 설정할 게 거의 없어요.\n- 기기에서 무선 디버깅을 활성화하세요:\n  - 설정으로 이동해서 “debug”를 검색하세요.\n  - “무선 디버깅”을 탭한 후, 다시 “무선 디버깅” 옵션을 (토글이 아닌 전체 항목을 탭해서 상세 페이지로 이동하세요.\n  - “무선 디버깅 사용” 토글을 확인하세요. “이 네트워크에서 무선 디버깅 허용” 팝업에서 “이 네트워크에서 항상 허용”을 선택하고 “허용”을 탭하세요.\n  - “IP 주소 및 포트 정보”는 나중에 예약하세요 (대부분의 튜토리얼은 포트가 5555이라고 가정하지만, 제 브랜드 new Pixel 7에서는 다른 포트번호였어요).\n\n![Android Device](/assets/img/2024-05-20-ConnectYourAndroidDeviceOverWiFiinVSCodetoRunandDebugYourFlutterApp_1.png)\n\n## 기기 연결\n\n- [처음 연결할 때만] USB로 기기를 연결하세요.\n- VSCode에서 Ctrl+Shift+P를 누르고 “ADB:📱 Connect to device IP”를 검색하고 선택하세요:\n- IP 주소를 입력하고 엔터를 누르세요.\n- 포트 번호를 입력하세요.\n- “Connected to `IP`:`port`” 메시지가 나타나면 USB 케이블을 분리할 수 있어요.\n*참고: IP 주소는 사용하는 네트워크와 라우터 설정에 따라 달라질 수 있어요. 포트 번호는 매번 바뀔 수 있어요. 이렇게 되면 “ADB returned null value”나 다른 오류가 발생할 수 있어요.\n- VSCode에서 F5를 누르거나 \"Run > Start Debugging\"으로 이동하세요. 즐겁게 개발하세요!","ogImage":{"url":"/assets/img/2024-05-20-ConnectYourAndroidDeviceOverWiFiinVSCodetoRunandDebugYourFlutterApp_0.png"},"coverImage":"/assets/img/2024-05-20-ConnectYourAndroidDeviceOverWiFiinVSCodetoRunandDebugYourFlutterApp_0.png","tag":["Tech"],"readingTime":2},{"title":"플러터 앱 성능 향상을 위한 권장 사항 탐색","description":"","date":"2024-05-20 16:16","slug":"2024-05-20-ExploringFlutterappperformanceimprovementrecommendations","content":"\n\n앱 성능은 소프트웨어 제품을 개발할 때 항상 염두에 두어야 할 중요한 요소입니다. 앱 성능에 신경을 쓰면 앱을 믿을 수 있게 만들어주고 유용한 기능을 제공하고 멋진 사용자 인터페이스를 생성함으로써 기존 사용자를 유지하고 새 사용자를 유치하는 데 도움이 됩니다.\n\nFlutter 앱 성능을 향상시키는 팁을 찾을 수 있는 많은 훌륭한 기사와 비디오가 있습니다. 여기에서는 일반적인 개요를 제시하고, DevTools를 사용하여 몇 가지를 자세히 살펴볼 예정입니다.\n\nFlutter 앱은 기본적으로 성능이 우수합니다. 단순히 권장 사항을 따르기만 하면 됩니다. 이미 앱이 잘 작동하면 성능을 향상시키는 방법을 찾을 필요가 없습니다. 노력이 들어가지 않을 것입니다. 다음과 같은 주요 문제가 앱에 없는지 확인해야 합니다:\n\n- UI 지연 — 렌더링에 허용된 시간을 초과한다는 것을 의미하는 프레임을 건너뛰는 경우 (애니메이션이 끊기는 것을 관찰할 수 있음)\n- 배터리 소모가 빠른 경우\n- 기기가 과도하게 발열하는 경우\n\n<div class=\"content-ad\"></div>\n\n일부가 관찰되면 문제가 발생한 곳을 찾아야 합니다. 앱 성능은 릴리스 모드와 비슷하지만 DevTools를 사용할 수 있는 프로파일 모드에서 실제 기기에서 조사되어야 합니다:\n\n```js\nflutter run --profile\n```\n\n성능 조사 목적으로 Profiling timeline 도구를 사용할 수 있습니다. 이 도구는 기기 화면에 렌더링된 프레임의 순서를 나타내는 차트입니다. UI 스레드와 래스터 스레드에서 데이터를 사용하며, 특정 시점에 실행된 프로그램 코드를 실제로 반영합니다. 코드가 효율적이지 않으면 (프레임 당 16.66밀리초 이상이 걸리면 — 초당 60프레임이 생성되어야 함) 막대는 빨간색으로 나타납니다. 그렇지 않으면 파란색으로 표시됩니다. Performance overlay 옵션을 활성화하면 차트를 기기 화면에 바로 추가할 수 있습니다.\n\n앱 성능에 대해 이야기할 때 리소스 소비를 의미한다는 것을 언급해야 합니다:\n\n<div class=\"content-ad\"></div>\n\n- 시간 — 프로그램이나 코드의 실행에 필요한 시간량입니다. 초당 프레임 수(FPS), 앱 시작 시간, CPU 사용량 등으로 측정할 수 있습니다.\n- 공간 — 프로그램 실행에 필요한 데이터 저장 공간의 양입니다. 메모리(RAM) 사용량, 앱 크기 등으로 측정할 수 있습니다.\n\n소프트웨어 개발자들은 종종 앱 성능을 유지하기 위해 시간과 공간 소비 사이의 균형을 찾아야 합니다.\n\n더 구체적인 성능 지표는 다음 링크에서 확인할 수 있습니다: [https://docs.flutter.dev/perf/metrics](https://docs.flutter.dev/perf/metrics).\n\n# 성능 향상 권고사항 탐색\n\n<div class=\"content-ad\"></div>\n\n성능 향상을 위한 모든 권장 사항은 다음과 같이 요약할 수 있습니다:\n\n- 시간 관련:\n- 반복적인 작업을 수행하지 말고, 가능한 경우 캐싱을 사용하세요.\n- 비용이 많이 드는 작업은 필요할 때까지 지연시키세요. 이는 다소 모순적일 수 있습니다. 작업이 시간이 오래 걸리고 사용자가 결과가 필요한 높은 확률이 있다면, 사용자가 작업이 완료될 때까지 기다리지 않도록 미리 백그라운드에서 수행하는 것이 더 나은 솔루션이 됩니다.\n- 공간 관련:\n- 더 이상 필요하지 않고 나중에 필요하지도 않을 객체를 저장하지 마세요.\n- 미디어 파일 사용을 최적화하세요 (그리고 앱 크기를 일반적으로 최적화하세요).\n\n# 반복적인 작업을 수행하지 마세요\n\n반복 작업을 수행하지 말아야 한다는 권장 사항은 당연한 것처럼 들릴 수 있지만, 서두르지 마세요. 물론 필요 없이 동일한 작업을 다시 수행할 의향은 아무도 없을 것입니다. 그러나 프로젝트가 커질수록 논리도 복잡해지므로 누락될 수 있는 부분이 있을 수 있습니다. Flutter 프레임워크가 그러한 프로젝트로 간주될 수 있기 때문에 처음부터 주의 깊게 작업해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n여기서 가장 인기있는 권장 사항은 위젯의 빌드 메서드에서 실행 비용이 많이 드는 메서드를 호출하지 않는 것입니다. 빌드 메서드는 위젯을 초기화 한 후에 한 번만 호출되는 것이 아닙니다. 예를 들어 위젯이 다시 빌드될 때마다 서버 요청을 하는 것은 효율적이지 않습니다.\n\n그 외에 다시 빌드되는 횟수를 줄이는 것이 중요합니다. 다음 권장 사항을 따르면 이를 달성할 수 있습니다:\n\n- 컴파일 시간에 초기 상태를 결정할 수 있고 이후에 변경되지 않을 때만 사용할 수 있는 const 위젯을 사용하는 것. Flutter는 const 위젯의 단일 인스턴스를 만들어 위젯 트리에서 재사용하며 계속 만들고 다시 빌드하지 않습니다.\n- 위젯을 반환하는 메서드 대신 위젯을 선호하는 것. setState 메서드를 사용하여 자식 위젯이 나타내는 하위 트리만 업데이트할 때 전체 부모 위젯이 다시 빌드되는 것을 방지합니다. 위젯을 반환하는 메서드를 사용하면 전체 부모 위젯이 다시 빌드됩니다.\n- 위젯 트리의 중첩 수준(구조)과 유형을 변경하지 않는 것. Flutter는 이전 빌드에서 해당 위젯을 찾지 못하면 다시 빌드 중에 새 위젯을 만듭니다. 예를 들어 숨기려는 경우 위젯을 트리에서 제거하는 대신 IgnorePointer를 사용하여 무시 매개변수의 다른 값을 사용하는 것이 좋습니다. 중첩 수준을 변경해야 하는 경우 해당 위젯에 GlobalKey를 사용하는 것이 좋습니다.\n- 위젯에 가능한 캐싱을 사용하는 것. 예를 들어, AnimatedBuilder는 애니메이션 반복마다 다시 빌드되지 않을 위젯 서브트리를 저장하는 child 매개변수를 제공합니다. 그렇지 않으면 child 매개변수가 무시되고 해당 서브트리가 직접 builder 콜백에 지정된 경우 매번 다시 빌드될 것입니다.\n- RepaintBoundary 위젯을 사용하여 자식 위젯을 별도의 레이어로 분리하는 것. 더 많은 정보는 여기에서 확인할 수 있습니다 - https://www.youtube.com/watch?v=Nuni5VQXARo\n\n위젯이 다시 빌드되었을 때 확인하려면 안드로이드 스튜디오의 Flutter Inspector 탭에서 Widget rebuild stats를 사용하십시오. debugRepaintRainbowEnabled = true로 전역 변수를 설정하면 위젯 주변에 색상 경계가 표시되며 다시 빌드될 때 색상이 바뀝니다.\n\n<div class=\"content-ad\"></div>\n\n네! 테이블 태그를 마크다운 형식으로 변경해 주세요.\n\n<div class=\"content-ad\"></div>\n\n```dart\nclass WidgetOptimizationPage extends StatefulWidget {\n  const WidgetOptimizationPage({super.key});\n\n  @override\n  State<StatefulWidget> createState() => _WidgetOptimizationPageState();\n}\n\nclass _WidgetOptimizationPageState extends State<WidgetOptimizationPage> {\n  @override\n  void didChangeDependencies() {\n    debugPrint('didChangeDependencies');\n    super.didChangeDependencies();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        backgroundColor: Theme.of(context).colorScheme.inversePrimary,\n        title: Text(\n          'Widget Optimization',\n        ),\n      ),\n      body: Column(\n        children: [\n          Container(\n            margin: const EdgeInsets.symmetric(vertical: 8),\n            height: 44,\n            width: 0.75 * MediaQuery.of(context).size.width,\n            child: const TextField(\n              decoration: InputDecoration(\n                border: OutlineInputBorder(),\n                hintText: 'Search',\n              ),\n            ),\n          ),\n          Expanded(\n            child: ListView.separated(\n              itemCount: 10,\n              itemBuilder: (BuildContext context, int index) {\n                return ListTile(\n                  visualDensity: VisualDensity.compact,\n                  title: Text('$index'),\n                );\n              },\n              separatorBuilder: (BuildContext context, int index) => const Divider(),\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\n텍스트 필드에 포커스를 설정하여 키보드를 표시하고 Done 버튼을 클릭하여 숨기기를 시도하는 경우:\n\n<img src=\"https://miro.medium.com/v2/resize:fit:704/1*u9fTFwbb5q-HzdNF6a9yoA.gif\" />\n\n콘솔에서 didChangeDependencies 메소드가 여러 번 실행된 것을 볼 수 있을 것입니다. 여기서 요청이 호출된 곳이었습니다!\n\n\n<div class=\"content-ad\"></div>\n\n\n![image 0](/assets/img/2024-05-20-Flutter성능개선권장사항탐색_0.png)\n\n위젯이 여러 번 다시 빌드되었음을 의미합니다. TextField는 총 3번 다시 빌드되었고 (화면이 열릴 때, 키보드가 나타났을 때, 키보드가 사라질 때), WidgetOptimizationPage는 12번 다시 빌드되었습니다:\n\n![image 1](/assets/img/2024-05-20-Flutter성능개선권장사항탐색_1.png)\n\ndidChangeDependencies 메서드가 InheritedWidget에서 알림에 대한 응답으로 작업을 수행하기에 적절한 위치임을 알려져 있습니다. 위젯이 어떤 변화들을 구독하는지 찾기로 결정했습니다. 위젯이 다소 복잡했기 때문에 몇 가지 가정을 하였지만, 위의 코드 예제에서는 명확하게 인식할 수 있습니다. 이유는 MediaQuery.of(context).size.width를 사용했기 때문입니다. MediaQuery는 기본적으로 다양한 매개변수를 가진 InheritedWidget으로, viewInsets와 padding을 포함하여 여러 매개변수가 있습니다. 이들은 키보드 애니메이션 중에 변경됩니다.\n\n\n<div class=\"content-ad\"></div>\n\n문제의 해결 방법은 MediaQuery.sizeOf(context).width를 사용하는 것이었습니다. sizeOf는 해당 속성이 변경될 때마다 컨텍스트를 다시 빌드하며, MediaQueryData의 of 메서드에서 직접 속성을 가져 오는 것보다 우선해야 합니다.\n\n수정 후에 만든 아래 스크린샷에서 볼 수 있듯이 WidgetOptimizationPage가 한 번 다시 빌드되었습니다.\n\n![이미지](/assets/img/2024-05-20-ExploringFlutterappperformanceimprovementrecommendations_2.png)\n\n# 비용이 많이 드는 작업을 필요할 때까지 지연시키세요\n\n<div class=\"content-ad\"></div>\n\n성능 향상의 다음 원칙은 불필요한 작업을 하지 말아야 한다고 말합니다. 프로젝트의 구조, 상태 관리 방식, 사용하는 타사 라이브러리의 특성, 특정 화면의 내부 논리 등에 많이 따라 달라집니다. 이곳에서는 Dart에서 제공하는 몇 가지 사항을 언급하고 싶습니다.\n\n다트가 다른 프로그래밍 언어와 마찬가지로 복잡한 조건의 각 부분을 계산하지 않는다는 것을 모두 알고 있을 것입니다. 일부 조건이 일찍 결정될 수 있다면 다른 조건은 심지어 계산할 필요가 없게 됩니다. 예를 들어, 여러 조건이 OR 연산자로 연결된 조건인 경우 첫 번째 조건이 true를 반환하면 다른 조건들은 계산되지 않을 것입니다. 왜냐하면 그들은 전체 조건의 결과에 영향을 미치지 않기 때문이죠.\n\n```dart\nvoid testLateInitialization() async {\n  late final first = performCalculations();\n  late final second = performComplexCalculations();\n\n  if (first || second) {\n    debugPrint('Hello world');\n  }\n}\n\nbool performCalculations() {\n  // 여기에 일부 계산이 있다고 가정해봅시다.\n  return true;\n}\n\nbool performComplexCalculations() {\n  // 여기에 일부 복잡한 계산이 있다고 가정해봅시다.\n  return false;\n}\n```\n\n그리고 우리에게 중요한 한 가지 — late 키워드입니다. 이는 변수가 액세스하려고 시도할 때만 값을 가져온다는 것을 의미합니다. 이를 통해 조건을 의미있는 부분으로 분할하고 가독성을 향상시킬 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\nDevTools의 Debugger 섹션에서는 아래 사진에 나와 있는 목록 아이콘 버튼을 선택하여 확인할 수 있습니다:\n   \n![List Icon](/assets/img/2024-05-20-ExploringFlutterappperformanceimprovementrecommendations_3.png)\n   \n함수 이름 앞에 초록색 선은 디버그 세션 중 호출된 것을 나타내고 빨간 선은 호출되지 않은 것을 나타냅니다.\n\n그리고 'late' 키워드에 대한 추가 정보 - 우리의 경우 비동기 함수에 사용할 수 없지만, 비동기 함수는 조건식에서 직접 호출할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```dart\nvoid testLateInitialization() async {\n  late final first = performCalculations();\n\n  if (first || await performComplexCalculations()) {\n    debugPrint('Hello world');\n  }\n}\n\nbool performCalculations() {\n  // Let's suppose here are some calculations\n  return true;\n}\n\nFuture<bool> performComplexCalculations() async {\n  // Let's suppose here are some complex calculations\n  return false;\n}\n```\n\n동기 함수에 대한 영향과 동일합니다 - 함수를 호출할 가치가 없으면 호출되지 않습니다.\n\n하나의 변수에 대한 늦은 초기화가 어떻게 작동하는지를 보여드렸습니다. 이제 게으른 컬렉션에 대해 이야기해 봅시다. Dart에서 List 객체에서 호출되는 많은 메서드는 Iterable을 반환합니다. Iterable은 자신의 항목을 반복하는 방법을 제공하는 추상 mixin입니다. 사실 List나 Set과 같은 컬렉션은 Iterable mixin을 구현합니다. Iterable의 요소는 요청될 때 계산되는 특징이 있습니다. 다음 코드를 살펴보겠습니다:\n\n```dart\nclass ListObject {\n  int value;\n\n  ListObject(this.value);\n}\n\nclass IterableObject {\n  String value;\n\n  IterableObject(this.value);\n}\n\nvoid testListVsIterable() {\n  final List<int> sourceList = List.generate(10, (index) => index);\n\n  final List<ListObject> intObjectList = sourceList.map((e) => ListObject(e)).toList();\n  for (var element in intObjectList.take(5)) {\n    debugPrint('$element');\n  }\n\n  final stringObjectList = sourceList.map((e) => IterableObject('$e'));\n  for (var element in stringObjectList.take(5)) {\n    debugPrint('$element');\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n두 개의 클래스인 ListObject와 IterableObject을 만들었어요. 두 클래스는 값만을 가지고 있어서 거의 동일하며, 나중에 DevTools에서 구분하기 위해 만들었어요. testListVsIterable 함수에서 sourceList는 초기 데이터의 리스트이며, ListObject와 IterableObject의 컬렉션이 생성됩니다. map 함수는 Iterable을 반환하기 때문에 List`ListObject`를 얻기 위해 toList를 호출해야 합니다. 첫 5개 요소를 반복하고 DevTools에서 어떻게 작동하는지 살펴보세요. 어떤 클래스의 인스턴스가 할당되었는지 확인할 수 있어요. 메모리 - Trace Instances를 선택하고 검사하려는 클래스를 선택해주세요.\n\n![image](/assets/img/2024-05-20-ExploringFlutterappperformanceimprovementrecommendations_4.png)\n\n우리의 실험 결과, 10개의 ListObject 객체 인스턴스와 5개의 IterableObject 인스턴스가 할당되었어요. 사실, 나는 Iterable과 List 사이의 차이를 보여주기 위해 컬렉션의 첫 5개 요소만 반복하기로 결정했어요. 앞서 언급했듯이, Iterable은 객체가 생성되는 방법을 결정할 수 있지만 요청될 때만 생성됩니다. 반면 List는 즉시 컬렉션을 생성합니다. 따라서 전체 컬렉션을 반복한다면 차이가 없을 것입니다.\n\n특히 Iterable의 장점에도 불구하고, 이 경우에는 단점이 있어요 - 접근할 때마다 새 인스턴스가 생성됩니다.\n\n<div class=\"content-ad\"></div>\n\n우리가 두 번 반복해야 하는 경우 ListObject와 IterableObject 사이에 차이가 없어질 것입니다.\n\n```js\nvoid testListVsIterable() {\n  final List<int> sourceList = List.generate(10, (index) => index);\n\n  final List<ListObject> intObjectList = sourceList.map((e) => ListObject(e)).toList();\n  for (var element in intObjectList.take(5)) {\n    debugPrint('$element');\n  }\n  for (var element in intObjectList.take(5)) {\n    debugPrint('$element');\n  }\n\n  final stringObjectList = sourceList.map((e) => IterableObject('$e'));\n  for (var element in stringObjectList.take(5)) {\n    debugPrint('$element');\n  }\n  for (var element in stringObjectList.take(5)) {\n    debugPrint('$element');\n  }\n}\n```\n\n![이미지](/assets/img/2024-05-20-ExploringFlutterappperformanceimprovementrecommendations_5.png)\n\n그리고 더 많은 횟수로 반복해야 하는 경우 List가 Iterable보다 효율적일 것입니다.\n\n<div class=\"content-ad\"></div>\n\n그러나 Iterable은 제가 만든 그런 인위적인 시나리오 뿐만 아니라 다른 상황에서도 유용할 수 있습니다. 앱 내에서 클래스 또는 레이어 간에 데이터를 전송해야 하는 경우, 매번 List로 변환하는 대신 Iterable을 사용하는 것을 고려해보세요. toList 메서드는 실제로 컬렉션을 반복합니다.\n\n요약하면, Iterable은 유용할 수 있지만 이로부터 이득을 얻으려고 할 때 조심해야 합니다.\n\n# 필요 없는 객체를 저장하지 마세요. 이후에도 필요하지 않을 예정이기 때문입니다.\n\n다음 권장 사항을 살펴보겠습니다:\n\n<div class=\"content-ad\"></div>\n\n이 문장을 확인하기 위해 몇 개의 화면을 만들었습니다. 첫 번째 화면인 AddingCounterPage는 기본적으로 설정된 것과 매우 유사한 카운터를 구현합니다. 새로운 Flutter 프로젝트를 설정할 때 기본적으로 제공되는 것과 매우 유사합니다. 이 페이지는 값에 2를 곱하는 MultiplyingCounterPage로 전파될 BehaviorSubject를 인스턴스화합니다.\n\n이러한 화면들을 앞뒤로 표시하고 메모리 뷰를 통해 메모리에 있는 개체를 확인해보겠습니다. 스트림 구독이 취소되지 않았을 때와 두 화면의 스트림 구독이 모두 취소된 경우에 대해 각각 메모리 스냅샷이 촬영되었습니다. 각 단계별로 (흐름이 나타나 있는 아래 그림의 녹색 직사각형에 이름이 표시된) 메모리 스냅샷을 비교하여 작성된 객체와 파괴된 객체가 무엇인지 이해했습니다.\n\n다음은 구독 취소 없이 진행되는 첫 번째 시나리오의 코드 일부입니다.\n\n<div class=\"content-ad\"></div>\n\n```dart\nclass _AddingCounterPageState extends State<AddingCounterPage> {\n  final BehaviorSubject<int> counter = BehaviorSubject<int>.seeded(1);\n\n  @override\n  void initState() {\n    counter.listen((event) {\n      setState(() {});\n    });\n    super.initState();\n  }\n  //...\n}\n\nclass _MultiplyingCounterPageState extends State<MultiplyingCounterPage> {\n  @override\n  void initState() {\n    widget.counter.listen((event) {\n      setState(() {});\n    });\n    super.initState();\n  }\n}\n```\n\nmain-3 스냅샷에는 그들의 상태를 가진 AddingCounterPage와 MultiplyingCounterPage가 있었습니다 - 해당 시점에 메모리에 있었습니다. 구독과 관련된 여러 쌍의 객체도 있습니다. StartWithStreamTransformer, _StartWithStreamSink, _MultiControllerSink가 있습니다. 하나는 AddingCounterPage를 위한 것이고 다른 하나는 MultiplyingCounterPage를 위한 것입니다:\n\n![image](/assets/img/2024-05-20-ExploringFlutterappperformanceimprovementrecommendations_7.png)\n\n main-3와 main-4 스냅샷 사이에는 차이가 없습니다. MultiplyingCounterPage가 사라졌지만 모든 인스턴스가 메모리에 남아 있습니다:\n\n\n\n<div class=\"content-ad\"></div>\n\n\n![Exploring Flutter App Performance Improvement Recommendations](/assets/img/2024-05-20-ExploringFlutterappperformanceimprovementrecommendations_8.png)\n\nAnd only after closing `AddingCounterPage`, the subscription objects were released with `AddingCounterPage` and `MultiplyingCounterPage`:\n\n![Exploring Flutter App Performance Improvement Recommendations](/assets/img/2024-05-20-ExploringFlutterappperformanceimprovementrecommendations_9.png)\n\nSubscription canceling should help get rid of this memory leak. We just save a `StreamSubscription` when adding the listener and cancel it when the widget is disposed:\n\n\n<div class=\"content-ad\"></div>\n\n```dart\nclass _AddingCounterPageState extends State<AddingCounterPage> {\n  final BehaviorSubject<int> counter = BehaviorSubject<int>.seeded(1);\n  late final StreamSubscription subscription;\n\n  @override\n  void initState() {\n    subscription = counter.listen((event) {\n      setState(() {});\n    });\n    super.initState();\n  }\n  //...\n\n  @override\n  void dispose() {\n    subscription.cancel();\n    super.dispose();\n  }\n}\n\nclass _MultiplyingCounterPageState extends State<MultiplyingCounterPage> {\n  late final StreamSubscription subscription;\n\n  @override\n  void initState() {\n    subscription = widget.counter.listen((event) {\n      setState(() {});\n    });\n    super.initState();\n  }\n\n  //...\n  @override\n  void dispose() {\n    subscription.cancel();\n    super.dispose();\n  }\n}\n```\n\n두 번째 경우에서는 main-3 스냅샷은 이전 시나리오와 비슷한 모습이므로 여기에 추가하지 않았습니다. 그러나 main-3와 main-4 스냅샷 간의 차이점은 MultiplyingCounterPage 및 해당 구독 객체가 해제되었다는 것입니다:\n\n![이미지](/assets/img/2024-05-20-ExploringFlutterappperformanceimprovementrecommendations_10.png)\n\n마찬가지로, AddingCounterPage 및 해당 구독 객체는 main-5 스냅샷에서 해제되었습니다.\n\n\n<div class=\"content-ad\"></div>\n\n이 실험을 통해 이 권장이 작동한다는 것을 입증했어요. 반드시 해지해야 하는 구독과 기타 해체가 필요한 객체(TextEditingController, AnimationController 등)들을 잊지 마세요. 그렇지 않으면 앱 성능에만 영향을 미칠 뿐만 아니라 프로그램 동작을 망가뜨릴 수도 있어요.\n\n# 미디어 파일 사용 최적화\n\n이미지와 비디오와 같은 미디어 파일을 다루는 것은 앱 성능에 중대한 영향을 미칩니다. 그들의 품질이 좋을수록, 메모리에서 차지하는 공간이 더 많이 필요하고 처리 및 렌더링하는 데 더 많은 시간이 필요합니다. 그들의 품질을 희생할 수 없기 때문에 일반적으로 가장 많은 리소스를 사용하는 객체들입니다. 따라서 미디어 파일 처리 방법을 최적화해야 합니다.\n\n이미지를 처리하는 방법을 최적화하는 방법은:\n\n\n<div class=\"content-ad\"></div>\n\n- 대부분에 맞는 이미지 형식을 선택해보세요:\n- 사진과 같은 연속음 영상에는 JPEG를 사용합니다. 손실 압축 기능을 제공합니다.\n- GIF 및 PNG는 예리한 가장자리를 가진 이미지, 로고, 텍스트, 그래픽 및 투명성이 필요한 이미지에 적합합니다. 비손실 압축을 제공합니다.\n- JPEG와 PNG의 이점을 결합한 WebP 및 AVIF는 더 효율적인 압축을 제공합니다.\n- 로고, 텍스트 또는 아이콘과 같은 단순한 기하학적 모양에 대한 벡터 기반 그래픽용 SVG. XML 마크업으로 표현되며 품질 하락 없이 모든 해상도에서 렌더링할 수 있습니다.\n- 품질 압축은 이미지 크기를 바이트 수로 줄이는 방법입니다.\n- 손실 압축은 인치 당 픽셀 수의 이미지 해상도를 줄여 픽셀의 숫자를 줄임으로써 이미지 크기를 줄이는 것이 가능합니다. 소량의 품질 손실이 허용되는 경우 (예: 사진)에 적용됩니다.\n- 비손실 압축은 품질에 해를 입히지 않고 원래 이미지를 복원할 수 있는 이미지 인코딩을 제공합니다. 주로 의학 영상, 기술 도면 등의 보존 목적으로 더 적합합니다.\n- 높이와 너비처럼 이미지 크기인 차원을 줄입니다. 대규모 이미지를 작은 화면 (휴대전화 등)에 표시하는 것은 정보가 중복되어 있어 효율적이지 않습니다. 대규모 이미지를 작은 화면에 맞게 조정하려면 추가 계산이 필요합니다. 원하는 차원에 정확히 맞게 이미지를 조정함으로써 렌더링 프로세스를 더 효율적으로 처리할 수 있습니다.\n- 네트워크로부터 수신한 이미지를 캐싱합니다.\n\nFlutter의 이미지 최적화 기능을 살펴보겠습니다. 먼저 화면에 Image 위젯을 추가해야 합니다:\n\n```js\nImage.asset(\n  'lib/assets/landscape.jpg',\n),\n```\n\n하지만 이미지를 최적화해야 하는지 어떻게 알 수 있을까요? DevTools에는 과도한 크기의 이미지를 강조하는 옵션이 있어 항상 식별할 수 있습니다. Flutter Inspector 탭에서 해당 버튼을 클릭하여 이를 활성화할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n다음은 글로벌 매개변수를 프로그래밍 방식으로 설정하는 방법입니다:\n\n```js\ndebugInvertOversizedImages = true;\n```\n\n거대한 이미지는 색상이 반전되고 뒤집힙니다:\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-05-20-ExploringFlutterappperformanceimprovementrecommendations_12.png\" />\n\n로그에서 오류 메시지도 확인할 수 있습니다:\n\n```js\n이미지 lib/assets/landscape.jpg의 표시 크기는 640×360이지만 디코딩 크기는 1920×1080으로, 장치의 픽셀 비율을 2.0으로 가정하면 추가로 9600KB를 사용합니다.\n\n미리 크기를 조정하거나 cacheWidth 매개변수로 640, cacheHeight 매개변수로 360을 제공하거나 ResizeImage를 사용하는 것을 고려하십시오.\n```\n\n따라서 이미지가 비용이 많이 소비되는 자원으로 간주되는 이유는 큰 차원으로, 이는 렌더링 중에 추가 계산이 필요하다는 것을 의미합니다. 이 오류를 피하려면 cacheHeight 및 cacheWidth 매개변수를 사용해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n```dart\nImage.asset(\n  'lib/assets/landscape.jpg',\n  cacheWidth: MediaQuery.of(context).devicePixelRatio.round() * MediaQuery.of(context).size.width.round(),\n),\n```\n\n여기서 cacheWidth는 디바이스 픽셀마다 논리적인 픽셀의 수인 devicePixelRatio와 화면 너비의 곱으로 계산됩니다. size.width만 사용하면 이미지가 흐릿해집니다. 이미지 품질에 대해 고려해야 합니다!\n\n![ExploringFlutterappperformanceimprovementrecommendations_13](/assets/img/2024-05-20-ExploringFlutterappperformanceimprovementrecommendations_13.png)\n\n원활한 사용자 경험을 보장하기 위해 preacheImage 메서드를 사용할 수 있습니다. 이 메서드를 사용하면 위젯 초기화 또는 메인 메서드에서 이미지를 캐시에 미리 로드하여 활용할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n이미지 캐싱을 자동으로 처리해주는 Image.network 생성자를 사용하거나, cached_network_image와 같은 서드파티 라이브러리를 사용할 수도 있어요. cached_network_image는 이미지 다운로드 중에 플레이스홀더를 표시하고 요청이 실패한 경우 오류를 표시하는 기능을 제공해요.\n\n이미지 압축에 대해 이야기하자면 flutter_image_compress와 같은 플러그인을 사용할 수 있어요.\n\n전체 애플리케이션 크기에 대해 --analyze-size 명령어를 사용하여 더 명확한 그림을 얻고 최적화할 아이디어를 만들어볼 수 있어요. 코드 크기를 줄이려면 릴리스 버전을 빌드할 때 --split-debug-info를 사용하는 것이 좋아요.\n\n추가 권장 사항으로, 필요 없는 작업을 실행하지 않는 것이 중요해요. 예를 들어, Opacity와 ClipRRect을 필요할 때만 사용하고, 애니메이션에서 클리핑을 피해야 해요. 또한, 비싼 작업을 직접 메인 스레드에서 실행하지 않아야 해요. Isolate를 사용하여 UI에 영향을 주지 않도록 해야 해요.\n\n<div class=\"content-ad\"></div>\n\n# 결론\n\n이 글에서는 플러터 앱 개발뿐만 아니라 유용한 앱 성능의 일반 원칙을 제시했습니다. 또한 DevTools를 이용한 플러터 앱 성능 개선에 대해 좀 더 자세히 살펴보았습니다. 도움이 되었으면 좋겠네요. 자세한 정보는 아래 자료 목록에서 찾을 수 있습니다.\n\n자료:\n\n- [https://docs.flutter.dev/perf](https://docs.flutter.dev/perf)\n- [https://docs.flutter.dev/tools/devtools/performance](https://docs.flutter.dev/tools/devtools/performance)\n- [플러터 성능 향상하는 방법:](https://www.youtube.com/watch?v=KH-3tbD7NoU)\n- [DevTools 깊게 들어가기:](https://www.youtube.com/watch?v=_EYk-E29edo)\n- [플러터에서 성능 및 최적화 팁 TOP 10:](https://medium.com/@slawomirprzybylski/top-10-performance-optimization-tips-in-flutter-3a4f3f31202b)\n- [플러터 성능 개선을 위한 경계 넘기기:](https://medium.com/@parthbhanderi01/raising-the-bar-for-flutter-app-performance-52418f7fa604)\n- [RepaintBoundary로 플러터 앱 성능 향상하기:](https://www.youtube.com/watch?v=Nuni5VQXARo)\n- [플러터에서 네트워크 이미지 최적화로 메모리 사용량 절약하기:](https://medium.com/make-android/save-your-memory-usage-by-optimizing-network-image-in-flutter-cbc9f8af47cd)\n- [MediaQuery와 성능 최적화의 플러터 스킬:](https://medium.com/codex/flutter-skill-of-mediaquery-and-performance-optimization-2fbf9c532fea)","ogImage":{"url":"/assets/img/2024-05-20-ExploringFlutterappperformanceimprovementrecommendations_0.png"},"coverImage":"/assets/img/2024-05-20-ExploringFlutterappperformanceimprovementrecommendations_0.png","tag":["Tech"],"readingTime":19},{"title":"SwiftUI 모양으로 하는 심장 애니메이션","description":"","date":"2024-05-20 16:14","slug":"2024-05-20-SwiftUIHeartanimationwithshape","content":"\n\n\n![Heart Shape](/assets/img/2024-05-20-SwiftUIHeartanimationwithshape_0.png)\n\n사각형, 둥근 사각형, 원 및 캡슐은 SwiftUI에서 사용할 수 있지만 하트 모양은 제공되지 않으므로 저는 Shape Protocol을 사용하여 직접 만들었습니다.\n\n# 하트 만들기\n\n```swift\nstruct HeartShape: Shape {\n    let minX = 10\n    let centerX = 55\n    let maxX = 100\n    let minY = 10\n    let maxY = 100\n    \n    func path(in rect: CGRect) -> Path {\n        Path { path in\n            path.move(to: CGPoint(x: centerX, y: maxY))\n            path.addQuadCurve(to: CGPoint(x: minX, y: 50), control: CGPoint(x: minX, y: 70))\n            path.addQuadCurve(to: CGPoint(x: centerX, y: 30), control: CGPoint(x: minX, y: minY))\n            path.addQuadCurve(to: CGPoint(x: maxX, y: 50), control: CGPoint(x: maxX, y: minY))\n            path.addQuadCurve(to: CGPoint(x: centerX, y: maxY), control: CGPoint(x: maxX, y: 70))\n            path.closeSubpath()\n        }\n    }\n}\n```\n\n\n<div class=\"content-ad\"></div>\n\n이곳에서 도형에 대해 더 많이 배워보세요\n\n# 애니메이션 추가\n\n```js\nimport SwiftUI\n\nstruct HeartAnimation: View {\n\n    // MARK: - Properties\n    @State private var to:CGFloat = 0\n\n    // MARK: - Body\n    var body: some View {\n        HeartShape()\n            .trim(from: 0, to: to)\n            .stroke(Color.pink, style: StrokeStyle(lineWidth: 5, lineCap: .round))\n            .frame(width: 110, height: 110)\n            .onAppear {\n                withAnimation(\n                    Animation\n                        .easeInOut(duration: 0.7)\n                        .repeatForever(autoreverses: false)) {\n                            to = 1\n                        }\n            }\n    }\n}\n```\n\n![이동](https://miro.medium.com/v2/resize:fit:590/1*_RXEvVkvqCafU2ke7Fe17Q.gif)\n\n<div class=\"content-ad\"></div>\n\n감사합니다!","ogImage":{"url":"/assets/img/2024-05-20-SwiftUIHeartanimationwithshape_0.png"},"coverImage":"/assets/img/2024-05-20-SwiftUIHeartanimationwithshape_0.png","tag":["Tech"],"readingTime":2},{"title":"iOS 푸시 알림 통합하기Using Swift","description":"","date":"2024-05-20 16:12","slug":"2024-05-20-IntegratingiOSPushNotificationsUsingSwift","content":"\n\n푸시 알림은 사용자 참여와 유지에 핵심적인 역할을 합니다. 사용자를 최신 상태로 유지하고 사용자가 구매로 이어지는 FOMO를 만들어내죠. 게다가 iOS에서는 Apple의 푸시 알림 서비스 (APNs)라는 추가 혜택이 있습니다. 이 서비스는 앱 서버와 사용자 장치 사이에 중개자 역할을 하면서 앱이 활성화되지 않았거나 사용자가 다른 앱을 확인하고 있어도 푸시 알림을 전달할 수 있게 해줍니다.\n\n이 기사에서는 iOS 앱에 푸시 알림을 단계별로 통합하는 방법을 살펴보고 구현의 중요한 측면을 논의하며 사용자 참여를 간소화하고 강화할 수 있는 몇 가지 제품 및 도구를 소개할 것입니다.\n\n하지만 먼저, 푸시 알림의 혜택이 무엇인가요?\n\niOS 푸시 알림은 사용자 참여, 유지 및 전체적인 사용자 경험을 개선합니다. 푸시 알림이 전략적으로 사용될 때 모바일 앱의 효과를 다양한 비즈니스 분야 전반에 크게 향상시킬 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n일부 특정 목적을 위해 푸시 알림을 배포할 수 있습니다.\n\n- 사용자에게 예약 상태를 업데이트합니다.\n- 사용자가 배치한 주문에 대한 설명과 업데이트를 제공합니다.\n- 백 엔드에서 변경 사항을 사용자에게 알립니다.\n- 패키지를 추적하는 데 도움을 줍니다.\n- 앱과 관련된 이벤트에 대한 흥미를 자아내 줍니다.\n- 사용자에게 새로운 제안, 프로모션 및 기회를 소개합니다.\n- 호기심을 자극할 앱 기능을 시험해 보도록 사용자를 권장합니다.\n- 서버 업데이트 및 기타 백엔드 변경 사항을 알립니다.\n\n제때에 실행되면 푸시 알림은 iOS 사용자가 실제로 원하는 형식의 적시에 효과적인 정보를 제공하므로 우리의 전반적인 UX 및 확장 마케팅 전략에서 중요한 역할을 합니다.\n\n# iOS 알림의 구성 요소는 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\niOS 푸시 알림은 일반적으로 세 가지 주요 구성 요소로 구성됩니다:\n\n- Apple Push Notification Service: 이것은 iOS 기기에 알림 메시지를 전달하는 데 책임을 지는 중앙 허브입니다. APNs를 활성화하려면 개발자는 유료 Apple 개발자 계정이 필요하며 앱 ID를 생성하여 Apple의 개발자 포털에서 푸시 알림을 추가로 구성해야 합니다.\n- 디바이스 토큰: 이것은 각 iOS 기기에 대해 생성된 고유 식별자입니다. APNs는 디바이스 토큰을 생성하고 알림 메시지를 토큰으로 전송하면 해당 기기에 알림이 전달됩니다. 개발자는 AppDelegate에서 푸시 알림을 위해 앱을 등록하여 이 디바이스 토큰을 얻어야 합니다.\n- 앱 서버: 앱 서버는 푸시 알림을 트리거하는 것을 담당합니다. 메시지 페이로드와 함께 APNs와 통신하고 알림 페이로드를 대상 기기로 전송합니다. 여기서는 메시지 페이로드를 관리하고 준비하고 APNs에 요청을 보내 알림 페이로드를 사용자의 기기로 전송합니다. 페이로드는 JSON 형식으로 작성됩니다.\n\n# iOS 푸시 알림 설정\n\n좋아요, 기본 내용을 다뤘습니다. 이제 Swift를 사용하여 iOS 푸시 알림 설정에 대해 좀 더 깊게 파고들어보겠습니다. 이는 Apple 개발자 포털, Xcode, 앱 서버 및 디바이스 토큰 등에서 중요한 단계를 거쳐 설정됩니다.\n\n<div class=\"content-ad\"></div>\n\n# 앱 ID 및 프로비저닝 프로필 설정하기\n\nApple 개발자 계정을 생성했다면 Apple 개발자 포털에 로그인하여 App ID를 생성하고 푸시 알림 통합을 위해 구성할 수 있습니다.\n\nApple 개발자 포털에서 다음 단계를 따라주십시오 (참고: 소유자 또는 관리자 권한이 필요합니다).\n\n- 인증서, 식별자 및 프로필에서 식별자를 클릭합니다. 그런 다음 왼쪽 상단의 추가 버튼 (+)을 클릭합니다.\n- 옵션 목록에서 App ID를 선택하고 계속을 클릭합니다.\n- 옵션 목록에서 App ID 유형이 자동으로 선택된 것을 확인하고 계속을 클릭합니다.\n- 설명란에 App ID의 이름 또는 설명을 입력합니다.\n- 명시적 App ID를 선택하고 번들 ID 필드를 작성합니다. 여기에 입력하는 명시적 App ID는 Xcode의 타겟 요약 창에 입력한 번들 ID와 일치해야 합니다.\n- 이제 와일드카드 App ID를 선택하고 번들 ID 접미사를 번들 ID 필드에 입력합니다.\n- 사용하려는 앱 기능을 활성화하기 위해 해당 확인란을 선택합니다. 앱 및 프로그램 멤버십 유형에 따라 사용 가능한 기능은 기능 아래에 나타납니다. 확인란은 기술이 명시적 App ID를 요구하고 와일드카드 App ID를 만드는 경우에 비활성화되거나 기술이 기본적으로 활성화되어 있는 경우에 비활성화됩니다. 모든 플랫폼에 모든 기능이 적용되는 것은 아닙니다.\n- 계속을 클릭한 후 등록 정보를 검토한 다음 등록을 클릭합니다.\n\n<div class=\"content-ad\"></div>\n\n아래는 프로세스를 설명하는 비디오입니다:\n\n이제 푸시 알림 인증서를 만드는 단계를 따라 주세요:\n\n프로비저닝 프로필을 만들기 위해 다음 단계를 따를 수 있습니다:\n\n- Apple 개발자 포털을 엽니다.\n- iOS Dev 대시보드에서 Certificates, Identifiers & Profiles을 클릭합니다.\n- 개발자 대시보드에서 Profiles을 클릭하고 +를 클릭합니다.\n- iOS 앱 개발을 선택하고 계속을 클릭합니다.\n- 프로비저닝 프로필과 연결할 앱 ID를 선택하고 계속을 클릭합니다. 여러 앱에서 하나의 개발 프로비저닝 프로필을 사용하려면 가능한 경우 와일드카드 App ID를 선택하세요.\n- 프로비저닝 프로필에 포함할 하나 이상의 개발용 인증서를 선택하고 계속을 클릭합니다. 개발용 인증서만 나열됩니다.\n- 프로비저닝 프로필에 포함할 하나 이상의 장치를 선택하고 계속을 클릭합니다.\n- 프로필에 의미 있는 이름을 입력하고 생성을 클릭합니다.\n- 다운로드를 클릭하여 프로비저닝 프로필을 다운로드하고 Xcode에서 사용하세요.\n\n<div class=\"content-ad\"></div>\n\n# Xcode 설정 구성하기\n\nXcode 프로젝트 설정에서 App ID를 사용해야 합니다. 이를 통해 푸시 알림이 활성화되고 프로비저닝 프로필을 활용할 수 있습니다.\n\n또한 프로젝트 설정의 기능(capabilities)에서 푸시 알림을 활성화해야 합니다.\n\n푸시 알림 기능을 활성화한 후에는 AppDelegate 파일에 푸시 알림 코드를 구현해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n알림: 먼저 UserNotifications 프레임워크를 가져와야 합니다.\n\n```js\nimport UserNotifications\n```\n\n이제 사용자의 승인을 요청하여이 앱의 푸시 알림을 활성화해야합니다. UNUserNotificationCenter 클래스의 requestAuthorization 메서드를 사용할 수 있습니다.\n\n```js\nfunc application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {\n    // 다른 설정 코드\n```\n\n<div class=\"content-ad\"></div>\n\n```js\n// 알림 권한 요청\nUNUserNotificationCenter.current().requestAuthorization(options: [.alert, .sound, .badge]) { granted, error in\n    if granted {\n        print(\"알림 권한이 허용되었습니다\")\n        // 이제 알림을 예약하고 보낼 수 있습니다\n    } else {\n        print(\"알림 권한이 거부되었습니다\")\n        // 사용자가 알림 권한을 거부한 경우 처리\n    }\n}\nreturn true\n```\n\n사용자의 푸시 알림 권한 팝업에 대한 반응에 따라 '허용' 및 '거부된 액세스' 상황을 처리해야 합니다.\n\n# 원격 알림 등록\n\n원격 알림을 등록하려면 UIApplication의 registerForRemoteNotifications() 메서드를 호출해야 합니다. 앱의 AppDelegate에서 이를 호출하여 원격 알림을 등록하고 기기 토큰을 받아옵니다.\n\n\n<div class=\"content-ad\"></div>\n\n```swift\nclass AppDelegate: UIResponder, UIApplicationDelegate {\n```\n\n```swift\n    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {\n        // 알림 권한 요청\n        UNUserNotificationCenter.current().requestAuthorization(options: [.alert, .sound, .badge]) { granted, error in\n            if granted {\n                print(\"알림 권한 허용됨\")\n                // 원격 알림 등록\n                DispatchQueue.main.async {\n                    application.registerForRemoteNotifications()\n          UNUserNotificationCenter.current().delegate = self\n                }\n            } else {\n                print(\"알림 권한 거부됨\")\n                // 사용자가 알림 권한을 거부한 경우 처리\n            }\n        }\n        return true\n    }\n}\n```\n\n# 기기 토큰 등록 처리\n\n애플리케이션을 통해 알림을 등록한 후, 기기 토큰을 얻어야 합니다. 이는 사용자 기기를 식별하여 나중에 서버에서 알림을 보낼 수 있게 해줍니다.\n\n<div class=\"content-ad\"></div>\n\n위의 예시에서는 성공적 및 실패적인 기기 등록 방법을 구현했습니다. 등록이 올바르게 작동하면 기기 토큰을 얻게 되며, 이후 서버로 해당 사용자에게 저장할 수 있도록 전송해야 합니다. 기기 토큰이 없으면 이 기기로 알림을 보낼 수 없습니다.\n\n# 원격 알림 처리\n\n<div class=\"content-ad\"></div>\n\n기기 토큰을 받은 후에는 앱이 알림을 수신할 준비가 되었습니다. 이제 서버로부터 수신되는 알림을 처리하기 위한 관련 메서드를 구현해야 합니다. 이러한 메서드는 앱의 상태에 기반하며, 앱이 전경 또는 배경에서 작동하는지에 따라 다를 것입니다.\n\n만약 앱이 전경에서 실행 중이라면\n\n여기서는 앱이 전경에서 실행 중일 때 푸시 알림을 처리하는 메서드를 구현하고 있습니다:\n\n```swift\nextension AppDelegate: UNUserNotificationCenterDelegate {\n    // 앱이 전경에서 실행 중일 때 알림을 처리\n    func userNotificationCenter(_ center: UNUserNotificationCenter, willPresent notification: UNNotification, withCompletionHandler completionHandler: @escaping (UNNotificationPresentationOptions) -> Void) {\n        // 알림 표시를 처리합니다\n        completionHandler([.alert, .sound, .badge])\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n앱이 활성 상태로 실행 중인 경우, iOS는 알림을 알림 센터에 표시하지 않습니다. 대신, 앱으로 알림을 직접 전달할 것입니다. 사용자에게 경고를 표시하려면 코드를 작성해야 합니다.\n\n만약 앱이 백그라운드에서 실행 중인 경우,\n앱이 실행 중이 아닐 때 알림을 처리하려면 다음 메소드를 구현해야 합니다.\n\n```swift\n// 앱이 백그라운드에서 실행 중일 때 원격 알림 수신 처리\nfunc application(_ application: UIApplication, didReceiveRemoteNotification userInfo: [AnyHashable: Any], fetchCompletionHandler completionHandler: @escaping (UIBackgroundFetchResult) -> Void) {\n    // 받은 원격 알림 처리\n```\n\n<div class=\"content-ad\"></div>\n\n```js\n    // 푸시 알림 페이로드를 출력합니다\n    print(\"원격 알림 수신: \\(userInfo)\")\n    // 알림 콘텐츠 처리\n    if let aps = userInfo[\"aps\"] as? [String: Any], let alert = aps[\"alert\"] as? String {\n        // 알림 페이로드에서 정보 추출\n        print(\"알림 메시지: \\(alert)\")\n    }\n    // 백그라운드 페치 작업 결과를 시스템에 알립니다\n    completionHandler(UIBackgroundFetchResult.newData)\n}\n```\n\n이 방법을 사용하면 알림을 수신한 후에 해당 알림을 처리하고 조치를 취할 수 있습니다.\n\n이제, 사용자가 알림을 탭하면 앱이 열립니다. 이 경우, 앱은 알림과의 상호 작용으로 열렸는지 여부를 감지하고 해당 작업을 수행할 수 있습니다. 특정 뷰 컨트롤러로 이동하는 등의 작업을 수행할 수 있습니다.\n\n# 앱 서버에서 알림 보내기\n\n\n<div class=\"content-ad\"></div>\n\n서버에 저장된 디바이스 토큰을 사용하여 특정 디바이스로 알림을 보내려면 백엔드 서버에 코드를 구현해야 합니다. 이 코드는 애플 푸시 알림 서버로 요청을 트리거하고 해당 디바이스로 알림을 전송합니다.\n\nNode.JS에서 푸시 알림을 보내는 다음 코드를 사용할 수 있습니다:\n\n```js\nnpm install apn\n```\n\n```js\nconst apn = require('apn');\n// 자격 증명으로 APNs를 구성\nconst apnProvider = new apn.Provider({\n  token: {\n    key: 'path/to/APNsAuthKey.p8',  // APNs Auth Key의 경로\n    keyId: 'YourKeyID',\n    teamId: 'YourTeamID',\n  },\n  production: false,  // 운영 환경에 대해 true로 설정\n});\n// 알림 페이로드 생성\nconst notification = new apn.Notification({\n  alert: 'Hello Bugfender Testing!',\n  sound: 'default',\n  badge: 1,\n});\n// 대상 디바이스의 디바이스 토큰 지정\nconst deviceToken = 'xxxx';  // 실제 디바이스 토큰으로 대체\n// 알림 보내기\napnProvider.send(notification, deviceToken).then(result => {\n  console.log('알림을 보냈습니다:', result);\n}).catch(error => {\n  console.error('알림 보내기 오류:', error);\n});\n```\n\n<div class=\"content-ad\"></div>\n\n`table` 태그를 Markdown 형식으로 변경하세요.\n\n<div class=\"content-ad\"></div>\n\n다음은 JSON 페이로드의 예시를 살펴봅시다:\n\n```js\n{\n  \"aps\": {\n    \"alert\": {\n      \"title\": \"Notification Title\",\n      \"body\": \"Notification Body\"\n    },\n    \"badge\": 1,\n    \"sound\": \"default\"\n  },\n  \"customKey\": \"Custom Value\" //원하는 사용자 지정 데이터나 객체\n}\n```\n\n예시에서 보듯이, 페이로드에는 customKey가 있습니다. 앱으로 보낼 알림과 관련된 모든 정보를 전달하고 필요한 작업을 수행하기 위해 필요한 만큼 많은 사용자 지정 키를 추가할 수 있습니다.\n\n크기 제한을 유의하십시오. 페이로드는 JSON 객체여야 하며 최대 크기 제한이 4KB입니다. 이 제한은 알림 전달에 문제가 없도록 보장합니다.\n\n<div class=\"content-ad\"></div>\n\n# 조용한 알림\n\n조용한 알림을 보내고 싶다면 경고, 뱃지 및 사운드 키 없이 페이로드를 보내야 합니다. 조용한 알림을 사용하면 사용자에게 알리지 않고 앱에서 작업을 실행할 수 있습니다. 이러한 종류의 알림에 대한 몇 가지 사용 사례는 다음과 같습니다:\n\n- 백그라운드 데이터 새로고침: 서버에서 앱을 갱신하도록 알림을 트리거하여 사용자가 앱을 열 때 항상 최신 데이터를 받을 수 있습니다.\n- 분석: 앱을 강제로 분석 데이터 업데이트를 서버로 보내도록 하기 위해 조용한 알림을 사용할 수 있습니다. 이에는 어플 사용 통계 또는 진단 정보가 포함됩니다.\n- 데이터 동기화: 여러 장치에서 사용할 수 있는 앱이 있는 경우, 하나의 앱에서 변경이 발생하면 데이터 동기화를 강제할 수 있습니다.\n\n다음은 조용한 알림의 편리한 예시입니다:\n\n<div class=\"content-ad\"></div>\n\n```json\n{\n    \"aps\": {\n        \"content-available\": 1,\n        \"priority\": \"5\"\n    },\n    \"updateType\": \"newArticles\",\n    \"timestamp\": \"2024-01-12T10:00:00Z\"\n}\n```\n\n# 푸시 알림 로컬라이제이션\n\n서버에서 사용자의 선호 언어를 추적하면 다른 언어로 로컬라이즈된 알림 키를 보낼 수 있습니다.\n\n# 지역 알림\n\n<div class=\"content-ad\"></div>\n\niOS 로컬 알림은 특별한 분류로, 어플리케이션이 서버와 독립적으로 특정 시간에 또는 특정 이벤트에 응답하여 알림을 자체적으로 예약하는 것을 가능케 합니다. 이러한 알림은 알림, 캘린더 이벤트 또는 유사한 시나리오에 매우 유용합니다. 이를 작동시키려면 원격 푸시 알림과 마찬가지로 사용 권한을 요청해야 합니다.\n\n로컬 알림을 만드는 예시를 살펴봅시다:\n\n```js\nimport UserNotifications\n```\n\n```js\n// 알림 콘텐츠 생성\nlet content = UNMutableNotificationContent()\ncontent.title = \"리마인더\"\ncontent.body = \"새로운 업데이트를 확인하는 걸 잊지 마세요!\"\ncontent.sound = UNNotificationSound.default\n// 반복 이벤트로 트리거 생성\nlet trigger = UNTimeIntervalNotificationTrigger(timeInterval: 60, repeats: false)\n// 요청 생성\nlet uuidString = UUID().uuidString\nlet request = UNNotificationRequest(identifier: uuidString, content: content, trigger: trigger)\n// 시스템에 요청 등록\nUNUserNotificationCenter.current().add(request) { error in\n   if let error = error {\n       print(\"알림 일정 예약 에러: \\(error)\")\n   }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n# 푸시 알림을 테스트하고 실제 장치로 전송해보기\n\n푸시 알림을 성공적으로 통합한 후에는 푸시 알림 코드를 제대로 테스트하기 위해 앱을 실제 장치나 시뮬레이터(이미 Xcode 11.4 버전부터 제공되고 있습니다)에서 실행해야합니다.\n\n이전에 얻은 장치 토큰으로 서버 또는 Pusher와 같은 온라인 도구를 사용하여 테스트 알림을 전송할 수 있습니다.\n\n거기에 그치지 않아요: 서버나 도구에서 보낸 알림이 장치로 제대로 수신되었는지 확인할 수도 있고, 앱에서 구현한 경우 알림의 처리 및 리디렉션을 확인할 수도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n시뮬레이터에서 알림을 테스트하는 단계:\n\n- 시뮬레이터 장치를 선택하고 앱을 실행합니다.\n- Xcode에서 Features 메뉴로 이동하고 Push Notifications을 선택합니다.\n- 미리 정의된 알림을 선택하거나 사용자 정의 payload를 생성합니다.\n- Xcode에서 Run 버튼을 클릭합니다.\n\n알림을 보내기:\n\n다음 curl을 사용하여 테스트 푸시 알림을 보낼 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```bash\ncurl --header \"apns-topic: your.bundle.identifier\" \\\\\n     --header \"apns-push-type: alert\" \\\\\n     --header \"authorization: bearer YOUR_AUTH_KEY\" \\\\\n     --data '{\"aps\": {\"alert\": {\"title\": \"Notification Title\", \"body\": \"Notification Body\"}, \"sound\": \"default\", \"badge\": 1}' \\\\\n     --http2 \\\\\n     --cert /path/to/your/certificate.pem \\\\\n     --cert-type PEM \\\\\n     --key /path/to/your/private-key.pem \\\\\n     <https://api.push.apple.com/3/device/YOUR_DEVICE_TOKEN>\n```\n\n- 애플리케이션의 환경에 맞는 올바른 APNs 엔드포인트를 사용하는지 확인해야 합니다 (운영 환경의 경우 api.push.apple.com 또는 개발 환경의 경우 api.development.push.apple.com).\n- apns-push-type 및 apns-topic 헤더는 필수입니다.\n- 인증서와 개인 키가 PEM 형식으로 올바르게 포맷되어 있는지 확인하세요.\n\n# 푸시 알림 지원 제품\n\niOS 애플리케이션에서 푸시 알림을 쉽게 통합하고 테스트할 수 있는 여러 서드 파티 서비스 및 도구가 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n이러한 서비스들은 타겟팅된 메시지 전송, 분석 및 기타 기능을 포함하여 전체 푸시 알림 경험을 향상시키고 데이터를 분석하기 위한 다양한 기능을 제공합니다. 여기 몇 가지 주목할만한 제품들이 있습니다:\n\n- Firebase Cloud Messaging (FCM): 구글에서 제공하는 FCM은 iOS, Android 및 웹 앱에서 메시지를 신뢰성 있게 전송할 수 있는 크로스 플랫폼 메시징 솔루션입니다.\n- OneSignal: OneSignal은 다중 플랫폼을 지원하는 인기 있는 푸시 알림 서비스입니다. 고급 타겟팅, A/B 테스트, 앱 내 메시징 및 실시간 분석을 제공합니다.\n- Pusher Beams: Pusher Beams는 iOS 및 Android 기기로 푸시 알림을 전송할 수 있는 푸시 알림 API입니다.\n- Amazon Simple Notification Service (SNS): SNS는 AWS의 잘 관리되는 메시징 서비스로, 푸시 알림을 지원합니다. iOS 기기를 포함한 다양한 엔드포인트로 메시지를 보낼 수 있으며, 메시지 형식에 대해 유연성을 제공합니다.\n- Airship: Airship은 푸시 알림, 앱 내 메시징 및 자동화 기능을 포함한 모바일 참여 플랫폼을 제공합니다.\n- Pushwoosh: Pushwoosh는 다양한 플랫폼을 지원하는 푸시 알림 서비스입니다. 사용자 정의 푸시 알림, 지오 타겟팅, 그리고 실시간 분석과 같은 다양한 기능을 제공합니다.\n- IBM Push Notifications: IBM Push Notifications은 IBM 클라우드 서비스 중 하나로, iOS 및 기타 플랫폼으로 푸시 알림을 전송하는 확장 가능한 솔루션을 제공합니다.\n- CleverTap: CleverTap은 푸시 알림, 앱 내 메시징 및 사용자 참여 도구를 포함한 포괄적인 모바일 마케팅 플랫폼입니다.\n\n# iOS 푸시 알림 FAQ\n\n# iOS에서 푸시 알림이란 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\niOS에서의 푸시 알림은 서버에서 iOS 기기로 전송되는 짧은 메시지로, 사용자에게 기기에 설치된 앱과 관련된 새로운 정보, 업데이트 또는 이벤트를 알리는 데 사용됩니다. 이러한 알림은 사용자의 기기로 직접 전달되며, 앱이 실행되지 않은 상태에서도 받을 수 있습니다.\n\n# 사용자가 iOS에서 푸시 알림을 제어할 수 있나요?\n\n네, iOS 사용자는 어떤 앱이 푸시 알림을 보낼 수 있는지와 알림이 어떻게 표시되는지를 제어할 수 있습니다. 사용자는 iOS 설정 앱에서 알림 설정을 관리할 수 있으며, 특정 앱에 대한 알림을 활성화 또는 비활성화할 수 있고, 알림 스타일을 사용자 정의하거나 푸시 알림이 처리되는 방식을 제어할 수 있습니다.\n\n# 푸시 알림은 텍스트만으로 제한되나요?\n\n<div class=\"content-ad\"></div>\n\n네, iOS의 푸시 알림은 풍족한 미디어를 포함할 수 있어요. iOS 개발자로서, 이미지, 소리 및 기타 상호 작용 항목을 포함할 수 있는 풍족한 푸시 알림을 보낼 수 있는 옵션이 있어요. 개발자와 마케터가 사용자의 관심을 더 잡을 수 있는 시각적으로 매력적인 알림을 만들 수 있게 해줘요.\n\n# 푸시 알림을 받으려면 인터넷 연결이 필요한가요?\n\n대부분의 경우 iOS 기기에서 푸시 알림을 받으려면 인터넷 연결이 필요해요. 사용자의 기기로 푸시 알림이 전송될 때, 이는 셀룰러 연결을 통해 전달되어요. 한 가지 예외가 있어요: 로컬 알림은 기기 자체에서 처리되므로 인터넷 연결 없이도 표시될 수 있어요.\n\n# 모든 iOS 기기에서 푸시 알림이 지원되나요?\n\n<div class=\"content-ad\"></div>\n\n네, 모든 iOS 기기에서 푸시 알림을 지원합니다. iPhone 및 iPad를 포함한 모든 기기에서 작동합니다. 해당 기기가 호환되는 iOS 버전을 실행 중이고 사용자가 해당 앱의 알림을 허용한 경우, 모든 iOS 기기에서 푸시 알림을 보내고 받을 수 있습니다.\n\n# iOS 푸시 알림을 보내는 데 비용이 드나요?\n\n푸시 알림을 보내는 것은 일반적으로 무료입니다. 그러나 알림을 관리하기 위해 제3자 서비스를 사용하면 프로젝트의 기능 및 규모에 따라 비용이 발생할 수 있습니다.\n\n# 요약하자면\n\n<div class=\"content-ad\"></div>\n\n위의 단계와 원칙을 결합하여 개발자들은 사용자 만족도, 참여도 및 모바일 애플리케이션 전반적인 성공을 위한 동적이고 효과적인 알림 전략을 만들 수 있습니다.\n\n본 문서에서는 푸시 알림의 통합에 대한 완벽한 단계별 가이드를 제공했습니다. 앱 ID 구성부터 Xcode의 자세한 설정, 잘 구조화된 알림 페이로드 생성 및 iOS 앱에서 푸시 알림 테스트까지 다룹니다.\n\n푸시 알림 서비스를 선택하는 데 도움이 필요하다면, 손쉬운 통합, 플랫폼 지원, 확장 가능성, 분석 기능 및 가격 등의 다양한 요소를 고려해야 합니다. 각 제3자 서비스는 강점이 있으며 선택은 귀하의 요구 사항과 선호도에 따라 다릅니다.\n\n즐겁게 코딩하세요!","ogImage":{"url":"/assets/img/2024-05-20-IntegratingiOSPushNotificationsUsingSwift_0.png"},"coverImage":"/assets/img/2024-05-20-IntegratingiOSPushNotificationsUsingSwift_0.png","tag":["Tech"],"readingTime":14},{"title":"SwiftUI 웃기고 독특한 사용자 정의 얼굴 애니메이션 회전 효과","description":"","date":"2024-05-20 16:11","slug":"2024-05-20-SwiftUIFunnyCustomFaceAnimationwithrotationeffect","content":"\n\n\n![Funny Custom Face Animation](/assets/img/2024-05-20-SwiftUIFunnyCustomFaceAnimationwithrotationeffect_0.png)\n\n저는 원형과 둥근 직사각형 같은 형태를 사용하여 사용자 정의 얼굴을 만들어보았어요. 눈이 회전하는 애니메이션도 추가했답니다.\n\n```swift\nstruct FunnyFaceView: View {\n    \n    // MARK: - 속성\n    @State private var isRotate: Bool = false\n    @State private var rotationAngle: Double = 0\n    \n    // MARK: - Body\n    var body: some View {\n        ZStack {\n            faceView()\n            facePartsView()\n        }\n        .onAppear {\n            withAnimation(Animation.linear(duration: 1).repeatForever(autoreverses: false)) {\n                rotationAngle = 360\n            }\n        }\n    }\n}\n\nextension FunnyFaceView {\n    \n    @ViewBuilder\n    private func faceView() -> some View {\n        Circle()\n            .fill(Color.yellow)\n            .frame(width: 300, height: 300)\n    }\n    \n    @ViewBuilder\n    private func facePartsView() -> some View {\n        VStack {\n            eyesView()\n            mouthView()\n        }\n    }\n    \n    @ViewBuilder\n    private func eyesView() -> some View {\n        HStack {\n            eyeView(offset: 10)\n            eyeView(offset: -10)\n        }\n        .offset(y: -50)\n    }\n}\n\n// MARK: - 도우미 뷰\nextension FunnyFaceView {\n    @ViewBuilder\n    private func eyeView(offset: CGFloat) -> some View {\n        ZStack {\n            Circle()\n                .fill(Color.white)\n                .frame(width: 50, height: 50)\n            Circle()\n                .fill(Color.black)\n                .frame(width: 10, height: 10)\n                .offset(x: offset)\n                .rotationEffect(.degrees(rotationAngle))\n        }\n        .onAppear {\n            isRotate.toggle()\n        }\n    }\n    \n    @ViewBuilder\n    private func mouthView() -> some View {\n        RoundedRectangle(cornerRadius: 20, style: .continuous)\n            .fill(Color.white)\n            .frame(width: 150, height: 20)\n            .offset(y: 50)\n    }\n}\n\n#if DEBUG\n#Preview {\n    FunnyFaceView()\n}\n#endif\n```\n\n![Funny Custom Face Animation](https://miro.medium.com/v2/resize:fit:590/1*ZUIvBP0Uf6Me8MkBYtu0Sg.gif)\n\n\n<div class=\"content-ad\"></div>\n\n감사합니다!","ogImage":{"url":"/assets/img/2024-05-20-SwiftUIFunnyCustomFaceAnimationwithrotationeffect_0.png"},"coverImage":"/assets/img/2024-05-20-SwiftUIFunnyCustomFaceAnimationwithrotationeffect_0.png","tag":["Tech"],"readingTime":3},{"title":"iOS 개발자가 반드시 보유해야 할 상위 5가지 도구들을 Xcode 아ꅍ널에 소개합니다","description":"","date":"2024-05-20 16:10","slug":"2024-05-20-Top5ToolsEveryiOSDeveloperShouldHaveinTheirXcodeArsenal","content":"\n\n<img src=\"/assets/img/2024-05-20-Top5ToolsEveryiOSDeveloperShouldHaveinTheirXcodeArsenal_0.png\" />\n\niOS 개발의 동적인 세계에서 적절한 도구를 갖추는 것은 생산성, 코드 품질 및 전체 프로젝트 조직화를 크게 향상시킬 수 있습니다. Xcode 및 iOS 개발자를 위한 많은 도구 가운데, 유틸리티, 혁신성 및 개발 프로세스를 간소화하는 능력으로 눈에 띄는 몇 가지 도구가 있습니다.\n\n이 필수 도구들을 살펴보겠습니다:\n\n## 1. Xcode용 Cleaner\n\n<div class=\"content-ad\"></div>\n\nXcode용 Cleaner는 개발 환경을 최적화하고자 하는 모든 iOS 개발자에게 중요한 도구입니다. Xcode를 정리함으로써 불필요하고 사용되지 않는 파일을 제거하여 IDE를 심각하게 빠르게 만들고 디스크 공간을 확보할 수 있습니다. Cleaner for Xcode를 주간 또는 월간으로 정기적으로 사용하면 개발자 폴더가 건강한 상태를 유지하며 디스크 공간을 아낄 수 있습니다.\n\n![image](/assets/img/2024-05-20-Top5ToolsEveryiOSDeveloperShouldHaveinTheirXcodeArsenal_1.png)\n\n## 2. CodeAI: Xcode용 AI\n\nCodeAI는 OpenAI의 고급 AI 기술을 직접 Xcode에 통합하여 코딩 효율성을 향상시키는 다양한 기능을 제공하는 혁신적인 도구입니다. 코드 간소화 및 리팩터링, 보유 주기 확인, JSON을 모델로 변환 (그 반대도 가능), 심지어 Objective-C 코드를 Swift로 변환하는 기능 등을 포함하고 있습니다. CodeAI 프리미엄 구독을 통해 전체 잠재력에 액세스할 수 있으며, 코드 품질과 신뢰성을 향상시키는 필수적인 자원을 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n\n![RocketSim for Xcode Simulator](/assets/img/2024-05-20-Top5ToolsEveryiOSDeveloperShouldHaveinTheirXcodeArsenal_2.png)\n\n## 3. Xcode 시뮬레이터용 RocketSim\n\nRocketSim은 Xcode 시뮬레이터에 기능을 추가하여 앱 개발을 더 빠르고 효율적으로 만들어줍니다. 주요 기능으로는 사용자 Defaults 편집기, 시뮬레이터 비행기 모드, 소리, 터치 및 베젤을 포함한 향상된 녹화 기능이 있습니다. 또한 접근성 및 동적 유형 테스트, 위치 시뮬레이션, 푸시 알림 및 딥 링크를 테스트하는 도구뿐만 아니라 완벽한 구현을 위한 디자인 비교 도구도 제공합니다. RocketSim은 빠른 작업, 환경 재정의 및 사용자 정의 설정을 통해 생산성을 높이며 각 기능이 매끄러운 개발 경험에 기여하도록 보장합니다.\n\n![Top 5 Tools Every iOS Developer Should Have in Their Xcode Arsenal](/assets/img/2024-05-20-Top5ToolsEveryiOSDeveloperShouldHaveinTheirXcodeArsenal_3.png)\n\n\n<div class=\"content-ad\"></div>\n\n## 4. Xcode용 PrettySwift\n\nPrettySwift은 Xcode 소스 편집기 확장 프로그램으로, Swift 코드를 자동으로 형식화하고 검사합니다. swift-format을 활용하여 코드 일관성과 가독성을 유지하는데 제로 구성을 채택했습니다. 이 도구는 프로젝트 전반에 걸쳐 깔끔하고 표준화된 코드를 중요시하는 개발자들에게 필수적이며, 수동으로 서식을 지정하는 시간을 절약하고 구문 오류의 가능성을 줄이는 데 도움이 됩니다.\n\n![이미지](/assets/img/2024-05-20-Top5ToolsEveryiOSDeveloperShouldHaveinTheirXcodeArsenal_4.png)\n\n## 5. Xcode용 DevCleaner\n\n<div class=\"content-ad\"></div>\n\n클리너(Cleaner) 대신에 데브클리너(DevCleaner)를 사용해보세요. 디스크 공간을 관리하는 필수 도구인 데브클리너는 Xcode의 부수적 파일들이 차지하는 공간을 효율적으로 관리할 수 있게 도와줍니다. 이 도구는 사용 편의성과 효율성에 중점을 둔 유사한 기능을 제공하여 개발 중 생성된 불필요한 파일들을 제거함으로써 개발자들이 디스크 공간을 회수할 수 있도록 도와줍니다.\n\n<img src=\"/assets/img/2024-05-20-Top5ToolsEveryiOSDeveloperShouldHaveinTheirXcodeArsenal_5.png\" />\n\n## 결론\n\niOS 개발 세계에 몰두하는 사람들에게 이러한 도구들을 수용함으로써 보다 간소하고 효율적이며 고품질의 코딩 환경으로 한 걸음 더 나아가는 중요한 단계를 나아가게 됩니다. Xcode 정리, 코드 최적화를 위한 AI 활용, 시뮬레이터 성능 향상, 완벽한 코드 표준 보장 등 각 도구는 각자의 장점을 제공하며 이러한 반독할 수 없는 유틸리티들을 Xcode 툴킷에 통합함으로써 단순히 시간을 절약하고 코드 신뢰성을 향상시키는 것뿐만 아니라 iOS 개발 노력에서 전례 없는 성공을 거두기 위한 기반을 마련하는 것입니다.\n\n<div class=\"content-ad\"></div>\n\n만약 이 기사를 즐겼다면, 박수로 지원을 보여주세요! 더 많은 통찰과 팁을 원하시면 팔로우하고 구독도 고려해 주세요. 여러분의 참여는 크게 감사하며, 이를 통해 더 많은 내용을 제공할 수 있습니다!\n\n좋아하실 만한 몇 가지 기사:","ogImage":{"url":"/assets/img/2024-05-20-Top5ToolsEveryiOSDeveloperShouldHaveinTheirXcodeArsenal_0.png"},"coverImage":"/assets/img/2024-05-20-Top5ToolsEveryiOSDeveloperShouldHaveinTheirXcodeArsenal_0.png","tag":["Tech"],"readingTime":3},{"title":"SwfitUI 네비게이션 - 코디네이터 패턴 2부 -  경고 ","description":"","date":"2024-05-20 16:08","slug":"2024-05-20-SwiftUINavigationThecoordinatorpatternpart2Alert","content":"\n\n<img src=\"/assets/img/2024-05-20-SwiftUINavigationThecoordinatorpatternpart2Alert_0.png\" />\n\n만약 Part 1을 아직 읽지 않았다면 여기에서 찾아볼 수 있어요. 이 글은 이전 글의 연장선입니다.\n\nPart 1에서는 네비게이션 라우팅 로직을 coordinators로 격리시켰습니다. 이를 통해 앱을 위한 확장 가능하고 모듈식 네비게이션 설정을 만들었습니다. 하지만 이것은 기본에 불과해요. SwiftUI에서는 navigationPath로 push하는 것 이외에도 더 많은 종류의 네비게이션이 있어요. 이 중 하나는 \"네비게이션\"으로 팝업 알람을 표시하는 것이죠.\n\n오늘은 이 주제에 대해 이야기할 거에요.\n\n<div class=\"content-ad\"></div>\n\nSwiftUI에서는 다양한 수정자(modifier)를 제공하여 Alert를 표시할 수 있습니다. 일반적으로 이러한 Alert 수정자는 뷰(View)에 설정되며, ViewModel/View에는 Alert를 표시할지 여부를 결정하는 데 사용되는 Binding`Bool`이 있습니다. 이 논리는 저에게는 좀 더 화면에 적합하게 표현되도록 조정되어야 한다고 생각합니다. 그렇다면 그에 대비할 방법을 찾아봅시다.\n\nAlert에는 다양한 기능이 있을 수 있습니다. 타이틀, 메시지, 한 개 또는 두 개 이상의 버튼(primaryAction, cancelAction)이 포함될 수 있으며, 이러한 버튼은 .destructive 역할을 갖는 등 다양한 역할을 할 수 있습니다. 이는 시스템이 설계된 방식의 일부이며 그것이 예상대로 작동할 것으로 예상됩니다. 그래서 모든 이러한 경우의 Alert를 표시하는 데 필요한 정보를 제공하기 위한 프로토콜을 생성해 봅시다.\n\n```js\nimport SwiftUI\n\nprotocol AlertDisplayable { \n    var title: String { get }\n    var message: String? { get }\n    var buttons: [AlertButton] { get }\n}\n\nstruct AlertButton {\n    let title: String\n    let role: ButtonRole?\n    let action: () -> Void\n\n    private init(title: String, role: ButtonRole?, action: @escaping () -> Void) {\n        self.title = title\n        self.role = role\n        self.action = action\n    }\n    \n    static func actionButton(title: String, action: @escaping () -> Void) -> Self {\n        AlertButton(title: title, role: nil, action: action)\n    }\n\n    static func cancelButton(title: String, action: @escaping () -> Void) -> Self {\n        AlertButton(title: title, role: .cancel, action: action)\n    }\n\n    static func destructiveButton(title: String, action: @escaping () -> Void) -> Self {\n        AlertButton(title: title, role: .destructive, action: action)\n    }\n}\n```\n\n이제 part 1에서 생성한 NavigationController에 다음을 추가할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```swift\n@Observable final class NavigationController {\n    var navigationPath = NavigationPath()\n    var alertPath = AlertPath()\n\n    func presentAlert<T>(_ alert: T) where T: AlertDisplayable {\n        alertPath.setAlert(alert)\n    }\n}\n```\n\n일관성을 유지하기 위해 ****Path 규칙을 따르고 있지만 원하는 대로 이름을 지정할 수 있습니다.\n\n```swift\nimport SwiftUI\n\nstruct AlertPath {\n\n    var alert: AlertDisplayable?\n\n    mutating func setAlert<T>(_ alert: T) where T: AlertDisplayable {\n        self.alert = alert\n    }\n}\n```\n\n또한 설정한 후 경고를 처리하는 CoordinatedView를 업데이트해야 합니다.```\n\n<div class=\"content-ad\"></div>\n\n```swift\nstruct CoordinatedView<C: Coordinator>: View {\n    private let coordinator: C\n\n    init(_ coordinator: C) {\n        self.coordinator = coordinator\n    }\n\n    var body: some View {\n        @Bindable var navigationController = coordinator.navigationController\n        NavigationStack(path: $navigationController.navigationPath) {\n            coordinator.rootView\n        }\n        .alert(for: $navigationController.alertPath) // <-- Here we add a new viewModifier\n    }\n}\n```\n\n이 alert modifier는 alertPath의 바인딩을 받아 설정된 알림이 있을 경우 알림을 표시하는 사용자 정의 ViewModifier입니다.\n\n```swift\nextension View {\n    func alert(for alertPath: Binding<AlertPath>) -> some View {\n        self.modifier(AlertModifier(alertPath: alertPath))\n    }\n}\n\nstruct AlertModifier: ViewModifier {\n\n    @Binding var alertPath: AlertPath\n\n    init(alertPath: Binding<AlertPath>) {\n        self._alertPath = alertPath\n    }\n\n    func body(content: Content) -> some View {\n        content\n            .alert(\n                alertPath.alert?.title ?? \"\",\n                isPresented: Binding(get: { alertPath.alert != nil }, set: { _ in alertPath.alert = nil }),\n                actions: {\n                    if let buttons = alertPath.alert?.buttons {\n                        ForEach(buttons) { button in\n                            Button(button.title, role: button.role, action: button.action)\n                        }\n                    }\n\n                }, message: {\n                    if let message = alertPath.alert?.message {\n                        Text(message)\n                    }\n                })\n    }\n}\n```\n\n- 알림의 제목은 title 속성에서 가져옵니다.\n- alertPath의 존재 여부에 따라 수동으로 getter 및 setter를 설정한 Binding`Bool`를 전달합니다. 따라서 alert가 존재하는 경우 알림을 표시합니다. 그리고 알림이 닫힐 때 alert를 nil로 설정합니다.\n- 사용 가능한 각 버튼에 대해 제공된 title, role 및 action으로 SwiftUI Button을 만듭니다. 버튼을 하나도 보내지 않으면 시스템이 단일 'OK' 버튼 알림으로 기본 설정됩니다.\n- 필요에 따라 알림 아래에 제목 아래에 알림에 대한 일부 설명 정보가 포함될 수 있습니다.```\n\n<div class=\"content-ad\"></div>\n\n한 번 시도해 보고 실제로 잘 작동하는지 확인해 봅시다. 알림 유형을 생성해 보겠습니다.\n\n```js\n// 비슷한 알림을 그룹화하거나 케이스별 알림을 만들고 싶다면 emum을 생성할 수 있습니다.\nenum SomeAlert: AlertDisplayable {\n    case alert(buttons: [AlertButton]) // <-- 액션을 주입합니다\n    case alertWithTitleAndMessage(buttons: [AlertButton])\n\n    var title: String {\n        switch self {\n        case .alert:                        return \"제목만 있는 알림\"\n        case .alertWithTitleAndMessage:     return \"제목과 메시지가 있는 알림\"\n        }\n    }\n\n    var message: String? {\n        switch self {\n        case .alert:                    return nil\n        case .alertWithTitleAndMessage: return \"이것은 메시지입니다\"\n        }\n    }\n\n    var buttons: [AlertButton] {\n        switch self {\n        case .alert(let buttons),\n             .alertWithTitleAndMessage(let buttons):    return buttons\n        }\n    }\n}\n\n// 또는\n// 알림을 따로 모델로 사용하고 싶다면 하드코딩된 값들을 가진 구조체를 만들 수 있습니다.\nstruct SomeSpecificAlertType: AlertDisplayable {\n    var title: String = \"특정 알림 제목\"\n    var message: String? = \"특정 메시지\"\n    var buttons: [AlertButton]\n\n    init(onAction: () -> Void, onCancel: () -> Void) { // <- 액션을 주입하고 해당 액션을 처리합니다\n      self.buttons = [\n          .actionButton(title: \"두 번째 작업\", action: onAction),\n          .cancelButton(title: \"취소\", action: onCancel)\n      ]\n    }\n}\n```\n\n알 수 있듯이, enum 케이스별로 Alert 유형을 생성하고 비슷한 알림 유형을 하나의 개체로 그룹화할 수 있습니다. 예를 들어, 모든 권한 알림을 한 곳에 유지하고 싶다면, 개별 알림 구조체/객체로 만들거나 선택은 여러분의 몫입니다. 중요한 점은 처음에 생성한 AlertDisplayable 프로토콜을 준수하는지입니다. 이제 모바일 앱에서 구현이 어떻게 보일지 살펴보겠습니다.\n\n```js\nstruct FirstView: View {\n    let viewModel: FirstViewModel\n\n    var body: some View {\n        VStack {\n            Text(\"첫 번째 화면\")\n            Button(\"알림 표시\") {\n                viewModel.didTapButton()\n            }\n        }\n    }\n}\n\n@Observable class FirstViewModel {\n    let coordinator: FirstCoordinator\n\n    init(coordinator: FirstCoordinator) {\n        self.coordinator = coordinator\n    }\n\n    func didTapButton() {\n        coordinator.presentAlert(\n                SomeAlert.alert(buttons: [\n                    .actionButton(title: \"주요 작업\") {\n                        print(\"작업 버튼 누름\") // <- 버튼 클릭 시 호출되는 클로저 \n                    },\n                    .cancelButton(title: \"취소\") {\n                        print(\"취소 버튼 누름\") // <- 버튼 클릭 시 호출되는 클로저 \n                    }\n                ]))\n    }\n}\n\n@Observable final class FirstCoordinator: Coordinator {\n    typealias Route = FirstCoordinatorRoute\n\n    let navigationController: NavigationController\n\n    @MainActor @ViewBuilder var rootView: some View {\n        FirstView(FirstViewModel(self)).navigationDestination(for: Route.self, destination: coordinate(_:))\n    }\n\n    func presentAlert<T>(_ alert: T) where T: AlertDisplayable {\n        navigationController.presentAlert(alert)\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n이는 viewModel에서 프로그래밍 방식으로 알림을 표시할 수 있게 해주며, 사용자가 버튼을 클릭할 때 viewModel이 선택적으로 콜백을 처리할 수 있게 합니다. 이 경우 뷰 자체 \"FirstView\"는 무엇이 일어나는지 전혀 모릅니다. 알고 있는 것은 didTapButton뿐입니다.\n\n![image](/assets/img/2024-05-20-SwiftUINavigationThecoordinatorpatternpart2Alert_1.png)\n\n부분 2에 대한 내용은 여기까지입니다.\n\n이 내용이 유용하다고 생각되면 좋겠습니다. 피드백이나 개선 제안이 있으면 알려주세요. 이 글이 유익했다면 공유해 주세요!\n\n<div class=\"content-ad\"></div>\n\n좋은 하루 보내세요!","ogImage":{"url":"/assets/img/2024-05-20-SwiftUINavigationThecoordinatorpatternpart2Alert_0.png"},"coverImage":"/assets/img/2024-05-20-SwiftUINavigationThecoordinatorpatternpart2Alert_0.png","tag":["Tech"],"readingTime":8},{"title":"1970년대 STEM 취업을 통해 엄마가 되기 위한 리스크를 감수하다","description":"","date":"2024-05-20 16:06","slug":"2024-05-20-RiskingBecomingaMomWith1970sSTEMEmployment","content":"\n\n![이미지](/assets/img/2024-05-20-RiskingBecomingaMomWith1970sSTEMEmployment_0.png)\n\n내 화학 학위는 주변 남성들과 동등한 지식을 갖고 있다는 것을 보여줬어요, 마치 \"오즈의 마법사\"에 나오는 스케어크로우처럼 말이에요. 하지만 그것은 1974년 직장에서의 성차별을 막아주지 않았죠. 당신은 2024년에 그것을 피할 수 있었나요?\n\n가족을 가정하면서 STEM 분야에서 무슨 일이 벌어지는지에 대해 생각해본 적이 있나요? 기본사항을 고려해봅시다. 화학 실험실에서 일할 때, 전기기계 장치를 사용할 때, 코딩에 오랜 시간을 할 때 오는 위험들은 한 몸만 책임져야 할 때는 견딜만했을 겁니다. 그렇지만 여신이 자라는 잠재적인 존재는 어떨까요? 그 가능성을 고려하여 어떤 선택을 했나요?\n\n어린이가 내 몸 안에서 자라는 것에 대해 고려하기 시작하면서, 실험실에서 수은 온도계를 사용하지 않았어요. (부서진 온도계에서 노출된 수은은 태아에게 유해합니다.) 다른 유독 화학물질을 다룰 때 장갑을 착용했죠. 당시에는 광전자 스펙트로포토미터가 난자에 영향을 줄 수도 있다는 생각이 들지 않았어요. 나는 \"충분히 안전하다\"고 느꼈었죠.\n\n<div class=\"content-ad\"></div>\n\n그 것은 잇따른 조심이 오늘처럼 소문되기 힘들었던, 실험실에서 임신이 매우 드물었기 때문이었습니다.\n\n하지만 저는 실험실에 들어가기까지 힘들었기 때문에 바쁘게 서두를 필요가 없었습니다. 1970년대에는 STEM 분야 직장에서 임신한 여성을 본 적이 없었습니다. 나의 어머니가 1950년대에 가르치는 직업에 종사했을 때와 같이, 임신의 결과로 일자리를 잃을 것이며, 최선의 경우에는 일부 \"질병 휴가\"와 애도의 표현을 받을 것임을 알고 있었습니다.\n\n이미 여성이 동료들과 침대를 바꾸어가며 잘 놀다가 속담들이 크게 퍼질 때만 문제가 될 수 있다는 것을 발견했습니다. 그러나 육아? 그것은 \"직장에 있는 남성들\"이 \"집에 있는 여성들\"에게 맡겨둔 일이었습니다. 그런 방식이 나의 앞으로 나아가는 방식이 되지는 않았습니다.\n\n남편과 함께 안전을 위해 피임을 그만두기로 결정했을 때, 실험실을 떠나기로 했습니다. 옛 친구들이 운영하는 \"광고 대행사\"에서 코딩을 하는 프리랜서 일을 찾았습니다. 이것은 정확히 창의적인 코딩은 아니었지만, 파일 내의 지정사항을 페이지에 원하는 출력물과 일치시키는 것이 목적이었습니다. 또한, 일부 작업은 종이신문을 준비하는 날에 밤에 이루어졌습니다. 문제 없어요 – 키보드를 주시고 시작하게 해주세요. 임신 초기 3개월 동안 가끔 키보드 위에서 잠들기도 했지만, 누군가는 항상 제게 다시 깨워주셨습니다.\n\n<div class=\"content-ad\"></div>\n\n거의 실수로 샘플을 뽑아봤는데, 내가 잘 다듬고 있는 글쓰기 기술이 뜻밖으로 도움이 되었어(3년 동안 연구실을 벗어나 키보드에서 멀어져 있을 때 하던 일 중의 하나야). 그래서 누군가의 책을 쓰기 시작했지. 사실 처음에는 그런 식으로 생각한 적이 없었어. 그냥 \"광고 대행사\"가 디자이너에게 제공하는 또 하나의 서비스 같은 거라 생각했지만, 나는 연구자의 열정으로 새로운 역할에 뛰어들었어. 게다가 디자이너가 텍스트와 이미지를 페이지의 새로운 코딩 형태로 바꾸는 모습에 매료되기도 했어. 그는 평면의 형태가 두 차원적인 과학으로 나타나는 걸 보여줬거든.\n\n한편으로는 화학 학위를 활용할 프리랜서 프로젝트도 찾고 있었어. 배가 부풀며 연구실에 다시 들어갈 수 있을 것 같진 않았지만, 가끔 이력서를 보내기도 했어.\n\n잡지 뒷면의 프리랜서 작가 광고를 훑어보던 어느 오후 - 전략적으로 정보를 나누어 올 때 우리의 랜드로버 여행 이야기를 통해 돈을 벌 수 있을 거라 생각하게 된 것 - 유망해 보이는 걸 하나 발견했어.\n\n어? 내가 할 수 있겠네. (당신도 할 수 있을 거야.)\n\n<div class=\"content-ad\"></div>\n\n생각도 없이 광고에 있는 전화번호를 눌렀어요. 한 남자가 전화를 받았고, 그는 출판 회사에서 사무실에서 일할 필요가 없다고 내게 약속했어요 (원격 근무! 초기 버전, 그렇지?), 그리고 내 자격 요건을 물었어요.\n\n내 날이 갈수록 더 드러나는 7개월임임을 바라보고, 미래 소설의 비디오 폰이 아직 나오지 않은 것에 기뻐했어요.\n\n![이미지](/assets/img/2024-05-20-RiskingBecomingaMomWith1970sSTEMEmployment_1.png)\n\n# 종이 위에 있을 수 있지만, 그것은 진짜 화학이었어요\n\n<div class=\"content-ad\"></div>\n\n그는 그것보다 몇 일 더 걸렸지만, 나에게는 맞는 일이었습니다. 나는 코딩이 많은 광고 회사에 어느 정도 사전 통보를 하고 싶었기 때문에 그것이 좋았고, 그래서 몇 일 동안 그들과 일하고자 했습니다. 여성 소유의 그 팀은 내가 임실이 어떻든 상관하지 않았습니다. 그들은 출산, 수유 등에 관한 책을 주었습니다. 멋지네요!\n\n그러나 나는 STEM 분야로 돌아가려 했습니다. 내가 이해하고 즐기는 화학에 깊이 파고든 것은 안도 였습니다. \"가족을 지원해야 하는지\", \"볼링 리그에 참여해야 하는지\" 물어보는 사람이 없어져서 안도가 되었습니다. 대신에 내 모든 교과서를 꺼내어 몇 권의 참고 자료를 줍고 사용했고, 그것들을 이용하여 소파 앞 테이블에서 일을 하게 되었습니다.\n\n겨울이 왔습니다. 산장을 둘러싼 눈이 내리기 시작했습니다. 내가 화학을 처음 가르치는 것처럼 화학을 다시 쓰는 데 빠져들었고, 그런 다음 나의 \"쪽지\"를 보내면서 가끔씩 수표가 도착했습니다. 그것은 하이테크는 아니었지만, 적어도 나는 여전히 \"STEM\"에 남아 있었습니다.\n\n50년이 지난 후에 생각할 때, 나는 가장 경쟁력 있는 분야에서 스스로를 증명했고 휴식을 취할 수 있다고 느꼈습니다.\n\n<div class=\"content-ad\"></div>\n\n아주 추운 시멘트 블록 \"사냥캠프\"에서 임신하고, 북부 뉴저지의 두 피트 눈 폭풍을 파내며, 켈리시 병원까지 빠른 스노모바일 타고 이동해야 할지도 모를 상황에서 주의보를 보냈고, 다음 날 아기를 낳았던 세부사항은 알 필요 없긔. (모든 것이 잘 해결되었지만.) 그러나 그런 어려운 상황에 있을 때 \"베이비 대디\"가 며칠 후에 이야기한 것을 생각해보면,\n\n나는 확실히 그렇지 왜냐하면... 아직 저는 STEM 경력이 있고, 모든 것이 우편을 통해 이뤄지기 때문에 저도 엄마라는 것을 아무도 알 수 없어요.\n\n![이미지](/assets/img/2024-05-20-RiskingBecomingaMomWith1970sSTEMEmployment_2.png)\n\n# 그 코드에는 문제가 있어요\n\n<div class=\"content-ad\"></div>\n\n스릴러 소설 속의 반전을 좋아해요. 하지만 실제 삶에서는 조금... 노노. 내가 강의하던 화학교재를 재작성 중이었을 때, 노동력과 직접적인 면담이 전혀 없는 채 출판사가 예정된 대로 내 임금을 몇 달 동안 보내주지 않은 채 자금을 털어 파산 신청한 걸 알게 되었을 때의 반전은 좀 그랬어. 그때쯤에는 또 눈이 내리기 시작했는데, 이번에는 버몬트에서였어. 거기서는 눈이 일찍 시작되고 늦게 끝나며 쌓일 정도로 많아.\n\n그때 남편은 심각한 철학 서적을 쓰느라 몰락한 상태였고 (젠장, 또 다른 문제가), 집 밖에서 일하기를 거부하는데, 그에 반해 내가 쓰는 능력을 신문 보도로 돌렸어. 그랬더니 금방이면, 봉사자인 나는 태어난 지 얼마 안 된 우리 아이를 데리고 홍수에 참여해 불을 끄거나, 백 번째 팔찌를 뜯었어. 그것은 전문가다운 느낌을 주지 않았고, 마음을 노래할 수도 없게 했어.\n\n그래서 화학교재에 대한 무급 노동을 이력에 추가해 보내고, 거대한 전문 과학 출판사를 찾아내었어. 소속 없는 노동자를 선호하고, 당신의 전공을 알고 일을 시일내에 완료한다면 성별은 중요하지 않다는 걸 이미 알고 있었어. (게다가 그들의 임금은 규칙적으로 들어왔어.)\n\nUPS 소포를 통해 받은 대학원 수준과 석사 과정 자료를 따라가는 게 항상 쉽지만은 않았어. 나는 어린아이를 데리고 대학 도서관에 여행을 다녀 미적분을 넘어 높은 수학을 공부하거나 내 참고 도서관을 찾았어. 하지만 내가 이 일을 좋아하게 되었어. STEM 분야는 만일 당신이 내 빨간 연필이나 시험관이나 분광광도를 싫어하지 않았다면. (아마도 나는 \"산\"과 \"염기\"와 같은 용어를 아는 아이가 \"산\"과 \"염기\"를 섞을 수 있게 허용해야 한다고 주장하는 동네의 유일한 유아를 가지고 있었을 거야.)\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-05-20-RiskingBecomingaMomWith1970sSTEMEmployment_3.png\" />\n\n당연히 연구소와 컴퓨터를 잃어 아쉽기도 했지만, 지금은 내가 복잡한 삶을 살아가는 시기라고 생각해서, 더 많은 과학 기반의 고객들과 노력을 더하면서 소설을 쓰기 시작하고 두 번째 임신까지 했어.\n\n이번에는 5월에 분만하게 되었고, 눈이 녹았을 때였어. 아기가 태어나고 나는 아침을 먹고 난 후에 아기를 무릎에 얹고 흔들의자에 앉아, 어린이가 나와 숫자 게임을 하면서, 테이블 위에 있는 반쯤 끝난 적색 연필로 쓰인 고분자 원고를 기다리고 있었어. 나는 그것이 조금 더 여유를 가질 수 있겠다고 생각했어.\n\n그러다가 문에 쾅 쾅 하는 소리가 들리더니 UPS 운송인이 독성학 저널을 위한 원고를 가져왔어. 좋아, 더 배울 것이 또 생겼군!\n\n<div class=\"content-ad\"></div>\n\n내가 내 흔들 의자에서 외쳤어:\n\n내 속에 있는 담요로 싸인 새로운 작은 소년을 놓고 놀라고 있는 시선을 던지며, 갈색 군복의 젊은 남자가 옆으로 기울어 들어가서 묶여진 페이지들을 문을 통과시켰고 도망쳤어.\n\n# 어려운 시기와 주요 동향: 컴퓨터\n\n이 모든 일에 나의 파트너는 어디에 있었을까? 좋은 질문이네. 그는 철학 서적을 쓰고 스릴러를 쓰기 시작했어. 그러나 어찌됐건 둘 다에서 소득은 없었어. 결혼이 끝나는 이유가 아니었지만, 분명 도움이 되지는 않았어. 나는 돈이 부족한 삶의 어려운 경계에서, 멋진 두 아이를 키우며 부엌 기술을 꾸준히 했고, 내 STEM 편집과 글쓰기에서 벌어들일 수 있는 돈을 늘려가며 살았어.\n\n<div class=\"content-ad\"></div>\n\n\n![Risking Becoming a Mom With 1970s STEM Employment](/assets/img/2024-05-20-RiskingBecomingaMomWith1970sSTEMEmployment_4.png)\n\n일이 조금 더 쉬워지기 시작했을 때, 전환점은 1985년으로 설명할 수 있어요: 엔지니어인 누나와 그녀의 맥을 중심으로하는 만능 동반자가 필요하다고 말하며 컴퓨터를 보내 준 해였어요.\n\n갑자기 북부 버몬트에서 방정식을 균형잡는 적적 선생님으로만 남아있던 저가 엔지니어링, 물리학 및 미생물학을 한 달에 모두 다루게 되었답니다. 그 후 몇 년 뒤에는 UPS 배송원이 매일 방문하는 것이 중닃으로 이전할 정도로 컴퓨터 네트워크를 통해서도 과제가 할당되기 시작했어요.\n\n그때쯤에는 제 아이들이 일하면서 단순히 식초와 베이킹 소다를 섞어보는 것에 만족하지 않았답니다 (클래식 산·염기 반응). 부엌 카운터에서 중합체를 만들고 가르쳐주기에 준비가 안 된 것 같아요 — 그러나 커모도 64로 코딩을 시작했어요. (그리고 곧이어 게임도.)\n\n\n<div class=\"content-ad\"></div>\n\n내 삶의 황홀한 모험은 과학, 코딩, 수학, 그리고 해결책을 찾는 즐거움의 완전한 순환에서 그래프로 표현될 시작을 했다.\n\n![image](/assets/img/2024-05-20-RiskingBecomingaMomWith1970sSTEMEmployment_5.png)\n\n나는 STEM 경력에 매달린 내 모습을 마무리하며 주변의 변화를 보게 되었다. 손자 두 명은 남성으로 나타났지만, 원격 근무하는 아버지가 벤처 캐피털 스타트업을 위해 코딩하는 동안 기르기와 조화롭게 어울리는 걸 지켜봤다. 그들은 나의 경험하지 못한 것을 목도했다: 업무 생활에서 성별이 거의 중요치 않다는 것을.\n\n임신과 STEM 주변의 문제들이 해결된 것 같진 않다. 여전히 주변에 약초살포나 살충제를 뿌리는 기업들과 논쟁 중이다. 그들이 세대를 걸쳐 영향을 끼칠 수 있다는 것을 알기에. (STEM, 그 안에 모두가 있어요!) 반면에, 오늘의 연합은 우리를 더 강력하게 앞으로 나아가게 만든다.\n\n<div class=\"content-ad\"></div>\n\n변경 사항이 무엇인가요? 어디에서 괴로움을 느끼시나요? 태아가 있는 경우와 없는 경우 모두에게 안전하고 환영받는 STEM 직장을 만들기 위해 어떤 그룹이 도움이 될 것 같나요? (의견란을 사용하여 다른 사람들에게 당신이 생각하는 것에 대해 생각하게 하세요.)\n\n코딩이나 엔지니어링, 방정식 해결이나 원자와 화합물을 새로운 상호 작용으로 이끌어 내는 것, 변화를 이끈 힘은 우리의 손에 있습니다... 함께요.","ogImage":{"url":"/assets/img/2024-05-20-RiskingBecomingaMomWith1970sSTEMEmployment_0.png"},"coverImage":"/assets/img/2024-05-20-RiskingBecomingaMomWith1970sSTEMEmployment_0.png","tag":["Tech"],"readingTime":7},{"title":"마법 같은 우체통에서 발생하는 HTTP Parameter Pollution HPP 공격","description":"","date":"2024-05-20 16:04","slug":"2024-05-20-HTTPParameterPollutionHPPAttacksinamagicalmailbox","content":"\n\n\n![Magic Mailbox](/assets/img/2024-05-20-HTTPParameterPollutionHPPAttacksinamagicalmailbox_0.png)\n\n# H-PP란 무엇인가요?\n\n마법 같이 작동하는 우체통을 상상해보세요. 마법사에게 영감을 주는 편지를 보내는 우체통이 있습니다. 보내는 각 편지에는 \"쿠키 만들기\"나 \"방 청소하기\"와 같이 마법사에게 특별한 일을 할 것을 알려주는 지시사항을 적습니다. 이 지시사항을 파라미터라고 하는 종이에 기록합니다. 마법사에게 두 가지 이상의 일을 시키고 싶을 때는 \"쿠키 만들기\"와 \"방 청소하기\"와 같이 여러 개의 파라미터를 적습니다.\n\n그런데 어느 날 장난기 많은 친구가 장난을 치려고 합니다. 당신이 알아차리지 못하는 사이에 편지에 추가적인 지시 사항을 몰래 넣습니다. 그래서 \"쿠키 만들기\"와 \"방 청소하기\"만 있는 대신에 마법사가 \"쿠키 만들기\", \"멍멍이 키우기\", \"방 청소하기\"와 같이 추가 지시서를 받게 됩니다. 더 많은 지시사항 때문에 마법사가 헷갈리게 되고, 때로는 어떤 것을 따를지 모를 때도 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n## 이 음모적인 트릭은 HTTP 매개 변수 공격(HPP)과 비슷합니다. 이를 단계별로 분석해 보죠:\n\n## HTTP란 무엇인가요?\n\nHTTP (하이퍼텍스트 전송 프로토콜)은 인터넷을 위한 마법의 우편함 시스템과 비슷합니다. 이는 컴퓨터가 웹사이트와 소통하는 방법이죠. 웹사이트를 방문하거나 그곳에서 무언가를 하려고 할 때, 컴퓨터는 명령(매개 변수로 된 편지처럼)을 웹사이트 서버(마법사)에게 보냅니다.\n\n## 매개 변수란 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\n파라미터는 웹 사이트 서버에 보내는 명령입니다. 무엇을 해야 하는지 알려줍니다. 예를 들어, 웹 사이트에서 \"고양이\"를 검색하려면, 파라미터는 이렇게 보일 수 있습니다: search=고양이. 이것은 서버에게 고양이에 대한 정보를 찾으라고 말해주는 것입니다.\n\n## HTTP 파라미터 오염(HPP)이란?\n\nHTTP 파라미터 오염은 교활한 공격자 (장난스러운 친구와 같은)가 서버에 보내는 메시지에 추가적인 파라미터를 추가하는 것입니다. 이렇게하면 서버가 혼란스러워질 수 있습니다. 어떤 지침을 따를지 모를 수 있습니다. 여러 가지 모순된 지침을 받아 어떤 것을 따를지 모르는 것과 비슷합니다.\n\n## HPP가 문제가 되는 이유?\n\n<div class=\"content-ad\"></div>\n\n1. Serve에 혼란: 마법사가 뒤죽박죽된 지시를 받는 것처럼, 서버도 혼란스러워서 제대로 작동하지 않을 수 있습니다. 의도하지 않은 일을 할 수도 있습니다.\n\n2. 보안 위험: 공격자는 HPP를 사용하여 서버를 속여 민감한 정보를 드러내도록 할 수 있어, 서버에 접근할 수 없어야 할 곳으로 침입할 수 있습니다.\n\n3. 원하지 않는 작업: 공격자는 서버가 중요한 데이터를 삭제하거나 개인 정보에 접근하도록 하는 등 나쁜 작업을 수행할 수 있습니다.\n\n## HPP 공격은 어떻게 발생하나요?\n\n<div class=\"content-ad\"></div>\n\n1. 다중 매개변수 전송: 공격자는 동일한 이름을 가진 여러 매개변수를 서버로 보냅니다. 예를 들어, 단순히 search=cats가 아니라 search=cats&search=dogs와 같이 보낼 수 있습니다.\n\n2. 서버 동작 악용: 서로 다른 서버는 이러한 추가 매개변수를 다른 방식으로 처리합니다. 일부 서버는 중복을 무시할 수도 있고, 일부는 첫 번째 것을 선택할 수도 있으며, 다른 서버는 마지막 것을 선택할 수도 있습니다. 이러한 예측 불가능성이 바로 공격자가 악용하는 부분입니다.\n\n3. 악의적인 매개변수 삽입: 공격자는 추가 매개변수에 해로운 지시문을 포함합니다. 예를 들어, admin=true와 같이 서버를 속여 관리자로 인식하도록 시도할 수 있습니다.\n\n## HPP에 대한 어떻게 방어할 수 있을까요?\n\n<div class=\"content-ad\"></div>\n\n1. 입력 유효성 검사: 서버가 모든 들어오는 매개변수를 확인하고 정리하여 필요한 것들만 받아들이고 올바르게 포맷되었는지 확인해주세요.\n\n2. 매개변수 제한: 서버가 추가 매개변수를 무시하거나 중복을 일관되고 안전한 방식으로 처리하도록 설계해주세요.\n\n3. 보안 테스트: 정기적으로 웹사이트와 서버를 취약점을 확인하기 위해 테스트해주세요, 특히 많은 매개변수를 다루는 방식을 확인해봐주세요.\n\n## 결론\n\n<div class=\"content-ad\"></div>\n\nHTTP 매개변수 오염은 친구가 마법사에게 편지에 혼란스러운 추가 지시를 넣는 것과 같아요. 이는 마법사(서버)가 당신이 요청하지 않은 일을 하거나 심지어 나쁜 일을 할 수 있게 합니다. 이를 방지하기 위해 지시사항을 주의 깊게 확인하고 올바른 지시사항만 따르는 것이 중요해요.\n\n따라서, 장난꾸러기로부터 마법 사서함을 보호하듯이, 웹사이트는 이런 간굿한 속임수로부터 서버를 보호하여 모든 것이 원할하고 안전하게 유지되도록 해야 해요!\n\n## 일부 참고자료:\n\n- OWASP: HTTP 매개변수 오염에 대한 테스트\n- Portswigger: 서버측 매개변수 오염\n- HackTricks: 매개변수 오염\n\n<div class=\"content-ad\"></div>\n\n다시 만나기까지, 행복한 마법을 부리세요!","ogImage":{"url":"/assets/img/2024-05-20-HTTPParameterPollutionHPPAttacksinamagicalmailbox_0.png"},"coverImage":"/assets/img/2024-05-20-HTTPParameterPollutionHPPAttacksinamagicalmailbox_0.png","tag":["Tech"],"readingTime":3},{"title":"자바 불변 객체에 관한 인터뷰 톱 질문","description":"","date":"2024-05-20 16:03","slug":"2024-05-20-JavaImmutabilitytopInterviewquestions","content":"\n\nby Abhishek Talakeri\n\n![Java Immutability Interview Questions](/assets/img/2024-05-20-JavaImmutabilitytopInterviewquestions_0.png)\n\n안녕하세요 여러분! 오늘은 자바 불변성 개념과 관련된 최상위 면접 질문을 탐구하며 명확한 설명과 간단한 예제를 제공할 것입니다. 이 자료는 면접 준비를 돕기 위해 특별히 설계되었습니다. 기술 면접을 되풀이하거나 이해를 향상시키려는 분들에게 유용한 자료가 되도록 이 시리즈는 여러분의 성공을 향한 여정에서 가치 있는 자산이 되도록 목표하고 있습니다.\n\n- 자바에서 불변 클래스란 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\n자바에서 불변 클래스는 생성된 후 수정할 수 없는 인스턴스를 의미합니다. 불변 객체가 인스턴스화된 후에는 상태가 수명 동안 일정합니다. 이는 필드의 값이 변경될 수 없으며 값을 수정하려는 모든 시도는 새 개체의 생성으로 이어집니다.\n\n불변 클래스를 사용하는 장점은 무엇인가요?\n\n스레드 안전성: 불변 객체는 생성 후 상태 수정을 허용하지 않으므로 동기화 메커니즘이 필요하지 않아 스레드 안전성을 보장합니다.\n\n일관된 상태: 불변 객체는 존재하는 동안 일정한 상태를 유지하여 프로그램 동작을 명확히 이해하고 예상치 못한 상태 변경을 최소화합니다.\n\n<div class=\"content-ad\"></div>\n\n안전한 공유: 변경할 수 없는(Immutable) 객체는 여러 스레드 또는 컴포넌트 간 안전한 공유를 허용하여 코드의 재사용성과 의도하지 않은 수정의 위험이 없이 원활한 상호 운용성을 보장합니다.\n\n동시성 제어: 변경할 수 없는(Immutable) 객체는 복잡한 동시성 제어 메커니즘을 완화시켜 더 간단하고 확장 가능한 동시 프로그래밍 모델로 이끕니다.\n\n3. Java 표준 라이브러리에서 변경할 수 없는(Immutable) 클래스의 몇 가지 예시를 제공할 수 있나요?\n\ni. java.lang.String\n\n<div class=\"content-ad\"></div>\n\nii. java.lang.Integer, java.lang.Double, java.lang.Boolean 등\n\niii. java.lang.Character\n\niv. java.time.LocalDate, java.time.LocalDateTime, java.time.LocalTime\n\nv. java.time.Duration, java.time.Period\n\n<div class=\"content-ad\"></div>\n\nvi. java.math.BigInteger, java.math.BigDecimal\n\nvii. java.awt.Color\n\n4. 수정할 수 없는 클래스를 사용하는 잠재적인 단점은 무엇인가요?\n\n수정할 수 없는 클래스를 사용하면 스레드 안전성 및 예측 가능한 동작과 같은 이점이 있지만, 단점이 있을 수 있습니다. 이러한 단점으로는 각 수정마다 새 인스턴스를 생성하여 메모리 사용량이 증가하고 성능에 영향을 줄 수 있다는 것이 포함됩니다. 불변성은 코드 베이스에 복잡성을 추가하고 특정 시나리오에서 유연성을 제한할 수도 있습니다. 또한, 방어적 복사 오버헤드와 가비지 수집 문제가 발생할 수 있습니다. 그러나 많은 프로그래밍 시나리오에서 불변성의 장점이 이러한 단점을 능가하기도 합니다.\n\n<div class=\"content-ad\"></div>\n\n5. 변경 빈번한 객체 상태 조작이 성능 또는 기능 상 필요한 시나리오에서는 불변성이 적합하지 않을 수 있습니다. 예를 들어, 비디오 스트리밍이나 게임과 같은 실시간 데이터 처리를 다루는 응용 프로그램에서는 반응성을 유지하기 위해 가변 상태에 대한 지속적인 업데이트가 필요한 경우가 있습니다. 또한 대규모 데이터 조작이나 복잡한 알고리즘이 포함된 시나리오에서 불변성은 메모리 사용량이 증가하고 성능 오버헤드가 발생할 수 있습니다. 마찬가지로 라이브러리나 프레임워크와 상호 운용성이 필수인 경우, 불변성은 최적의 선택이 아닐 수 있습니다.\n\n6. 불변 클래스를 설계할 때 주의해야 할 사항은 무엇인가요?\n\ni. 클래스를 Final로 선언: 클래스를 final로 선언하여 하위 클래스화를 방지하여 클래스의 동작이 변경되지 않도록 보장합니다.\n\n<div class=\"content-ad\"></div>\n\nii. 필드를 final로 선언해주세요: 객체 생성 후에는 수정할 수 없도록 모든 필드를 final로 선언해주세요.\n\niii. 필드를 private로 만들기: 필드를 private로 캡슐화하여, getter 메서드를 통해서만 제어된 접근을 허용해주세요.\n\niv. Setter 메서드를 제공하지 말기: 객체의 상태를 수정하는 Setter 메서드를 제공하지 않도록 지양해주세요. 그렇게 하면 불변성이 깨질 수 있습니다.\n\nv. 깊은 불변성 보장하기: 클래스가 변경 가능한 객체에 대한 참조를 포함하더라도 불변성을 유지하도록 보장해주세요. 필요에 따라 방어적 복사를 구현하거나 참조된 객체의 불변 버전을 사용해주세요.\n\n<div class=\"content-ad\"></div>\n\nvi. Equals와 HashCode 재정의: 객체 상태에 기반하여 올바른 동작을 보장하기 위해 올바른 equals()와 hashCode() 메소드를 구현하세요.\n\n7. 변경되지 않은 개념을 구현하는 Java 클래스를 작성하십시오.\n\n```java\npublic final class BankAccount {\n  \n  private final String accountNumber;\n  private final String accountHolderName;\n  private final double balance;\n  \n  public BankAccount(String accountNumber, String accountHolderName, double balance) {\n    this.accountNumber = accountNumber;\n    this.accountHolderName = accountHolderName;\n    this.balance = balance;\n  }\n  \n  public String getAccountNumber() {\n    return accountNumber;\n  }\n  \n  public String getAccountHolderName() {\n    return accountHolderName;\n  }\n  \n  public double getBalance() {\n    return balance;\n  }\n  \n}\n```\n\n8. Date와 같은 가변 필드를 가진 불변 클래스에서 변경 불가성을 어떻게 보장하나요?\n\n<div class=\"content-ad\"></div>\n\n```java\nimport java.util.Date;\n\npublic final class ImmutableWithMutableField {\n\n    private final int id;\n    private final Date date;\n\n    public ImmutableWithMutableField(int id, Date date) {\n\n        this.id = id;\n        this.date = new Date(date.getTime());\n    }\n\n    public int getId() {\n        return id;\n    }\n\n    public Date getDate() {\n        return new Date(date.getTime());\n    }\n\n    @Override\n    public String toString() {\n        return \"ImmutableWithMutableField [id=\" + id + \", date=\" + date + \"]\";\n    }\n\n    // testing\n\n    public static void main(String[] args) throws InterruptedException {\n\n        ImmutableWithMutableField a = new ImmutableWithMutableField(1, new Date());\n\n        System.out.println(a);\n        Thread.sleep(3000);\n        System.out.println(a);\n        Thread.sleep(1000);\n        ImmutableWithMutableField a1 = new ImmutableWithMutableField(1, new Date());\n        System.out.println(a1);\n        Thread.sleep(1000);\n        ImmutableWithMutableField a2 = new ImmutableWithMutableField(1, new Date());\n        System.out.println(a2);\n\n    }\n\n}\n```\n\nResult:\n\n![Image](/assets/img/2024-05-20-JavaImmutabilitytopInterviewquestions_1.png)\n\n9. Immutable 클래스 내에서 가변 컬렉션을 어떻게 처리하시겠습니까?\n\n\n<div class=\"content-ad\"></div>\n\n```java\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic final class ImmutableWithMutableCollection {\n\n    private final int id;\n    private final List<String> mutableList;\n\n    public ImmutableWithMutableCollection(int id, List<String> mutableList) {\n\n        this.id = id;\n        this.mutableList = new ArrayList<>(mutableList);\n    }\n\n    public int getId() {\n        return id;\n    }\n\n    public List<String> getMutableList() {\n        return Collections.unmodifiableList(mutableList);\n    }\n\n}\n```\n\n10. 불변 클래스(Immutable Class)에서 가변 객체 참조를 어떻게 처리하시겠습니까?\n\n```java\npublic class MutableClass {\n    private String name;\n\n    public MutableClass(String name) {\n        this.name = name;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    @Override\n    public String toString() {\n        return \"MutableClass [name=\" + name + \"]\";\n    }\n\n}\n```\n\n```java\npublic final class ImmutableClass {\n\n    private final MutableClass mutable;\n    private final String city;\n\n    public ImmutableClass(MutableClass mutable, String city) {\n\n        this.mutable = new MutableClass(mutable.getName());\n        this.city = city;\n    }\n\n    public MutableClass getMutable() {\n        return mutable;\n    }\n\n    public String getCity() {\n        return city;\n    }\n\n    @Override\n    public String toString() {\n        return \"ImmutableClass [mutable=\" + mutable + \", city=\" + city + \"]\";\n    }\n\n    public static void main(String[] args) {\n\n        MutableClass m = new MutableClass(\"Abhishek\");\n        ImmutableClass i = new ImmutableClass(m, \"Mumbai\");\n\n        System.out.println(i);\n        m.setName(\"Appu\");\n        System.out.println(i);\n\n    }\n\n}\n```\n\n<div class=\"content-ad\"></div>\n\n<table>\n    <tr>\n        <td>11. Explain defensive copying.</td>\n    </tr>\n    <tr>\n        <td>Defensive copying is a programming technique used to protect against unintended modifications to mutable objects by creating copies of them. When dealing with mutable data structures or objects, defensive copying involves creating a duplicate instance of the object and working with the copy instead of the original. This ensures that changes made to the copy do not affect the original object’s state, maintaining data integrity and preventing unexpected side effects. Defensive copying is commonly employed in scenarios where immutability is desired or when sharing data between different parts of a program to maintain consistency and prevent concurrency issues.</td>\n     </tr>\n    <tr>\n        <td>12. What are stateless objects? How are they different from immutable objects? Which of these two is thread safe?</td>\n    </tr>\n</table>\n\n<div class=\"content-ad\"></div>\n\n상태가 없는 객체(Stateless objects)는 인스턴스 필드(인스턴스 변수)가 없는 객체들을 말합니다. 해당 클래스에는 컴파일 시간 상수, 즉 static final 필드가 있을 수 있습니다. 불변 객체(Immutable objects)는 상태를 가지지만 초기화 이후에 상태를 변경할 수 없는 객체를 의미합니다. 이 두 가지는 스레드 안전합니다.\n\n13. 해시맵(HashMap)에서 불변 객체가 키로 사용되면 어떤 이점이 있을까요?\n\n불변 객체가 해시맵에서 키로 사용되면 그 안정성(Stability)으로 인해 이점을 가집니다. 생성 이후에 상태를 수정할 수 없기 때문에 해시 코드는 수명 동안 일정하게 유지됩니다. 이 특성은 키의 해시 코드가 일관되게 유지되어 해싱 및 해시맵에서 값 검색을 효율적으로 수행할 수 있도록 합니다. 게다가, 불변성은 키의 상태가 예기치 않게 변경되지 않음을 보장하여 해시맵에서 키 충돌 또는 예기치 않은 동작과 같은 문제를 방지합니다. 이러한 안정성과 예측 가능성은 해시맵의 무결성과 효율성을 보장하기 위해 불변 객체를 이상적으로 만듭니다.\n\n끝까지 제 글을 읽어주셔서 감사합니다. 이 글로부터 유익한 통찰과 지식을 얻으셨기를 진심으로 바랍니다. 만약 글이 즐거우시고 유익하다고 느꼈다면, 제바랍니다 여러분의 친구들과 동료들과 공유해 주시기를 부탁드립니다.\n\n<div class=\"content-ad\"></div>\n\n이 기사를 즐겨 보셨다면, 부디 팔로우하고 구독하며 박수를 보내 주시면 감사하겠습니다.\n\n제 다른 기사들도 한 번 살펴보세요.","ogImage":{"url":"/assets/img/2024-05-20-JavaImmutabilitytopInterviewquestions_0.png"},"coverImage":"/assets/img/2024-05-20-JavaImmutabilitytopInterviewquestions_0.png","tag":["Tech"],"readingTime":9}],"page":"41","totalPageCount":68,"totalPageGroupCount":4,"lastPageGroup":20,"currentPageGroup":2},"__N_SSG":true}