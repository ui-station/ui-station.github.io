{"pageProps":{"post":{"title":"Swift에서의 관점 지향 프로그래밍","description":"","date":"2024-05-20 17:49","slug":"2024-05-20-Aspect-OrientedProgramminginSwift","content":"\n\n<img src=\"/assets/img/2024-05-20-Aspect-OrientedProgramminginSwift_0.png\" />\n\n# 소개\n\nAspect-oriented programming (AOP로 앞으로 표기함)은 코드 베이스에 교차하는 관심사를 확장 가능한 방식으로 추가하는 것에 관한 것입니다.\n\n\"Aspect Oriented Programming\"이라는 용어를 처음 만났던 그 때를 아직 기억합니다. 많은 시간이 흘렀고, Swift가 아직 존재하지 않았으며, 우리는 기쁘게 Objective-C 코드를 작성하고 있었습니다. ARAnalytics는 AOP 패러다임을 채택하여 코드 베이스 전반에 걸쳐 분석을 추가하는 것을 간단하게 한 최초의 라이브러리 중 하나였습니다.\n\n<div class=\"content-ad\"></div>\n\n코드를 더 자세히 살펴보면 Objective-C에서 AOP를 구현하는 것이 Peter Steinberger가 그의 Aspects 라이브러리에서 언급한 것처럼 메소드 스위즐링을 구현하는 것이라는 것을 알 수 있어요.\n\nObjective-C와는 달리 Swift는 메시지를 가로채고 실행 중에 동작을 변경할 기능이 많지 않은 엄격하고 정적으로 타입이 지정된 언어에요. 실제로는, 이것은 우리의 코드에 교차 관심을 적용하는 영향을 최소화하기 위해 좋은 디자인의 기초를 설정해야 한다는 의미에요. 우리는 두 가지 주요 구성요소가 필요할 거에요:\n\n- 지연 바인딩을 적용하고 필요에 따라 기반이 되는 구현을 변경할 수 있도록 하는 종속성 주입 기능이 필요해요.\n- 런타임에서 우리가 원하는 동작을 변경할 수 있도록 해주는 가로채기 디자인 패턴인 데코레이터 패턴이 필요해요.\n\n시작해봐요!\n\n<div class=\"content-ad\"></div>\n\n# Swift에서의 AOP: 좋은 디자인을 향해서\n\n우리 애플리케이션을 모델링하는 매우 일반적인 접근 방식은 특정 도메인 모델 주변의 모든 기능을 번들로 묶는 단일 “store/repository/service/aggregate”를 가지는 것입니다. 만약 애플리케이션이 할 일을 관리하는 것이라면, 어떤 형식의 “TodoService”가 있을 것입니다. 만약 TV 프로그램을 관리하는 앱이라면, “ShowService”가 있을 것입니다. 아이디어를 얻으셨죠. 이러한 접근 방식은 많은 중간 규모의 앱에 대해 완벽하게 유효한 것이지만, 다른, 더 복잡한 애플리케이션에는 문제가 될 수 있습니다. 소프트웨어의 대부분은 마찬가지로 모든 것이 의존합니다.\n\n다음과 같이 보이는 ShowService를 상상해보십시오:\n\n```js\nprotocol ShowService {\n    func allShows() async -> [Show]\n    func allEpisodes(for show: Show) async -> [Episode]\n    func markEpisodeAsWatched(episode: Episode) async\n    func markShowAsWatched(_ show: Show, until episode: Episode?) async\n}\n```\n\n<div class=\"content-ad\"></div>\n\n우리가 말했던 대로 소프트웨어의 대부분은 주관적이며 특정 맥락에 따라 토론의 여지가 있음에도 불구하고, 우리를 안내하는 \"원칙\"들이 있으면 좋습니다. 그 원칙들은 보통 SOLID 원칙들입니다.\n\n## ISP 위반\n\n대부분의 대규모 인터페이스와 마찬가지로, ShowService가 인터페이스 분리 원칙을 위반할 가능성이 매우 높습니다. 이는 클라이언트가 필요하지 않은 메서드를 구현하도록 강제함으로써 나타납니다. 특히 목업을 구현할 때 XCTFail과 같은 메서드들을 사용하여 이를 확인하는 것이 매우 흔합니다.\n\n```js\nstruct ShowServiceMock: ShowService {\n    var shows: [Show]\n\n    func allShows() -> [Show] {\n        shows\n    }\n    \n    func allEpisodes(for show: Show) -> [Episode] {\n        XCTFail(\"호출되지 않아야 함\")\n        return []\n    }\n\n    func markEpisodeAsWatched(episode: Episode) {\n        XCTFail(\"호출되지 않아야 함\")\n    }\n\n    func markShowAsWatched(_ show: Show, until episode: Episode?) {\n        XCTFail(\"호출되지 않아야 함\")\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n## SRP 위반\n\nISP를 위반할 때, SRP를 위반하는 일도 상당히 흔합니다. SRP는 응집성과 한 가지 이유로만 변경해야 한다는 것과 관련이 있습니다. ShowService 인터페이스에 있는 메서드 수가 늘어날수록, 그 응집성과 SRP를 유지하기가 더욱 어려워질 것입니다.\n\n## OCP 위반\n\nTV 프로그램과 관련된 새로운 기능을 추가하려면 ShowService에 새로운 메서드를 추가해야 하며, 서비스의 모든 구현이 그 변경 사항을 수용하고 컴파일 오류를 수정해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n## 큰 인터페이스는 병목 현상을 유발하기 쉽습니다\n\n하루의 끝에 이렇게 큰 인터페이스를 갖고 있다면, 해당 도메인 모델과 관련된 새로운 동작을 추가할 때 병목 현상이 발생할 것입니다. 어떠한 새로운 변경이라도 앱 전체에서 컴파일 오류 및 다시 컴파일을 유발합니다. 좋은 소프트웨어 디자인의 한 가지 주의사항은 자주 변경되지 않는 모듈에 의존하는 것입니다. 우리의 의존성 그래프에서 잎 모듈은 가장 안정된 것이어야 합니다. 왜냐하면 그들이 변경될 때마다 전체 그래프가 다시 컴파일되도록 강제할 것입니다. ShowService를 더 자세히 살펴보면, 매우 빈번하게 변경되는 매우 불안정한 모듈에 전체 앱이 의존한다는 점을 알 수 있습니다. 그런 해롭은 일종의 재앙이네요 😅. 참고로, 이러한 병목 현상은 백엔드 및 마이크로서비스 아키텍처에서도 매우 흔히 발생하며, \"엔티티 서비스 안티패턴(The Entity Service Antipattern)\"이라고 불립니다.\n\n## 첫 번째 접근 방식: CQRS\n\n첫 번째 접근 방식은 큰 인터페이스를 읽기와 쓰기를 위한 두 가지 구분된 인터페이스로 분리하는 것입니다. 이를 Command Query Responsibility Segregation(CQRS)이라고 합니다.\n\n<div class=\"content-ad\"></div>\n\n```bash\n// 읽기\nprotocol ShowQueryService {\n    func allShows() async -> [Show]\n    func allEpisodes(for show: Show) async -> [Episode]\n}\n\n// 쓰기\nprotocol ShowCommandService {\n    func markEpisodeAsWatched(episode: Episode) async\n    func markShowAsWatched(_ show: Show, until episode: Episode?) async\n}\n```\n\n보통 이렇게 분리하는 것이 읽기와 쓰기에 필요한 기능이 매우 다르기 때문에 합리적입니다. 예를 들어 상태를 변경할 때(쓰기)만 적용되는 보안 정책이 있을 수 있습니다.\n\n하지만 상상할 수 있듯이, 이것은 큰 개선이 아닙니다. 변경의 영향을 더 잘 제한했지만 여전히 자주 변경될 두 가지 \"큰 인터페이스\"가 존재합니다. 더 좋은 방법이 있을 수 있습니다.\n\n## 두 번째 접근 방법: 작은 서비스\n\n<div class=\"content-ad\"></div>\n\n당신이 깨끗한 아키텍처와 유즈 케이스로 작업하는 데 익숙하다면, 이것들이 정확히 그것입니다.\n\n일부 장단점이 있습니다. 각 메서드 당 프로토콜을 갖는 것은 인터페이스의 폭발을 일으킬 수 있습니다. 그러나 이것은 이전에 이야기한 일부 SOLID 원칙을 준수하는 주요 이점도 가지고 있습니다. 이제 ISP(인터페이스 분리 원칙)를 준수하고 있고 아마도 SRP(단일 책임 원칙)을 준수하고 있을 것입니다. 또한 새로운 기능을 추가할 때는 새로운 튜플(인터페이스, 구현)을 만들기만 하면 되므로 코드를 많이 수정하거나 재컴파일하는 영향을 최소화할 수 있습니다. 그러니 전체가 나쁜 것만은 아닙니다. 기억하세요, 모든 것은 의존합니다. 소프트웨어는 모든 것이 트레이드오프에 관한 것입니다.\n\n<div class=\"content-ad\"></div>\n\n하지만 \"Aspects\"에 대해 생각해보면, 필요한 각 측면마다 프로토콜 당 하나의 구현을 해야 합니다. 예를 들어 \"로그 기록 Aspect\"를 구현하려면 AllShowsLoggingService와 MarkShowAsWatchedLoggingService 등이 필요합니다. 그래서 우리 앱에서 관심사를 구현하는 데 적합한 방법이 아닌 것 같습니다.\n\n세 번째, 마지막 방법으로 가봅시다.\n\n## 세 번째 방법: 통합된 서비스 인터페이스\n\nAOP를 확장 가능한 방식으로 구현하려면 \"aspects\"를 적용할 모든 서비스에 대해 단일 인터페이스/시마가 필요합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n프로토콜 Service<Input, Output> {\n    associatedtype Input\n    associatedtype Output\n\n    func callAsFunction(input: Input) async throws -> Output\n}\n```\n\n편의성을 위해 다음도 추가해 봅시다.\n\n```js\nextension Service where Input == Void{\n    func callAsFunction() async throws -> Output {\n        try await callAsFunction(input: ())\n    }\n}\n```\n\n단일 인터페이스를 가지고 있어, 다음과 같은 것을 할 수 있습니다.```\n\n<div class=\"content-ad\"></div>\n\n```kotlin\nclass AllShowsService: Service {\n    suspend operator fun invoke(input: Void): List<Show> {\n        // Implementation...\n    }\n}\n\nclass MarkShowAsWatchedService: Service {\n    suspend operator fun invoke(input: Pair<Show, Episode?>) {\n        // Implementation...\n    }\n}\n\ntypealias AllShowsServiceType = Service<Void, List<Show>>\ntypealias MarkShowAsWatchedServiceType = Service<Pair<Show, Episode?>, Void>\n\nclass ViewModel<AllShowsService: AllShowsServiceType, MarkShowAsWatchedService: MarkShowAsWatchedServiceType> {\n    private val allShowsService: AllShowsService\n    private val markShowAsWatchedService: MarkShowAsWatchedService\n\n    init(allShowsService: AllShowsService, markShowAsWatchedService: MarkShowAsWatchedService) {\n        this.allShowsService = allShowsService\n        this.markShowAsWatchedService = markShowAsWatchedService\n    }\n\n    suspend fun markAllShowsAsWatchedButtonTapped() {\n        try {\n            val allShows = allShowsService(Void)\n            coroutineScope {\n                allShows.map { show ->\n                    launch {\n                        markShowAsWatchedService(Pair(show, null))\n                    }\n                }\n            }\n        } catch (e: Exception) {\n            println(\"Some error happened $error\")\n        }\n    }\n}\n```\n\n지금은 ViewModel을 생성할 때 두 개의 입력값을 주입하면 됩니다:\n\n- Service`Void, [Show]`\n- Service`(show: Show, episode: Episode?), Void`\n\nService가 단일 인터페이스이기 때문에 앱 전체의 모든 서비스에 적용할 수 있는 각 측면마다 인터페이스의 구현만 있으면 됩니다.```\n\n<div class=\"content-ad\"></div>\n\n그러면 몇 가지를 구현해 보겠습니다! 확인하시겠지만, 모든 측면은 데코레이터 패턴을 따라 매우 유사합니다.\n\n## 로깅 측면\n\n서비스에 몇 가지 로깅 기능을 추가하는 것은 매우 일반적이고 유용한 측면입니다. 다음과 같이 간단히 구현할 수 있습니다:\n\n```js\nclass LoggingService<Decoratee: Service>: Service {\n    typealias Input = Decoratee.Input\n    typealias Output = Decoratee.Output\n\n    let decoratee: Decoratee\n    \n    init(decoratee: Decoratee) {\n        self.decoratee = decoratee\n    }\n\n    func callAsFunction(input: Input) async throws -> Output {\n        let output = try await decoratee(input: input)\n        dump(output)\n        return output\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n## 프리미엄 사용자 측면\n\n애플리케이션에서 매우 유용한 교차 기능 중 하나는 사용자가 프리미엄 사용자인 경우에만 일부 작업을 수행할 수 있도록 허용하는 것일 수 있습니다. 사용자가 프리미엄 사용자인지 여부를 확인하는 방법을 추상화하기 위해 간단한 `async` 함수를 주입하여 PremiumService 데코레이터를 다음과 같이 만들 수 있습니다:\n\n```js\nclass PremiumService<Decoratee: Service>: Service {\n    struct Error: Swift.Error {}\n\n    typealias Input = Decoratee.Input\n    typealias Output = Decoratee.Output\n\n    let decoratee: Decoratee\n    let isPremiumUser: () async -> Bool\n\n    init(decoratee: Decoratee, isPremiumUser: @escaping () async -> Bool) {\n        self.decoratee = decoratee\n        self.isPremiumUser = isPremiumUser\n    }\n\n    func callAsFunction(input: Input) async throws -> Output {\n        guard await isPremiumUser() else {\n            throw Error()\n        }\n        return try await decoratee(input: input)\n    }\n}\n```\n\n## 캐싱 측면\n\n<div class=\"content-ad\"></div>\n\n또 다른 일반적인 측면은 캐싱 또는 메모이제이션입니다. 단순히 서비스 입력을 해시 가능한 것으로 제한하고 출력을 Codable로 정의함으로써 모든 서비스에 대해 구현할 수 있습니다.\n\n```js\nprivate(set) var cache: [AnyHashable: Data] = [:]\n\nclass CachingService<Decoratee: Service>: Service where Decoratee.Output: Codable, Decoratee.Input: Hashable {\n    typealias Input = Decoratee.Input\n    typealias Output = Decoratee.Output\n\n    let decoratee: Decoratee\n\n    init(decoratee: Decoratee) {\n        self.decoratee = decoratee\n    }\n\n    func callAsFunction(input: Input) async throws -> Output {\n        if let cachedData = cache[input] {\n            return try JSONDecoder().decode(Output.self, from: cachedData)\n        }\n\n        let output = try await decoratee(input: input)\n        cache[input] = try JSONEncoder().encode(output)\n        return output\n    }\n}\n```\n\n## 지연 측면\n\n네트워크 링크 조절기(Network Link Conditioner)는 다양한 유형의 네트워크 상황을 시뮬레이션하고 인터넷 연결을 매우 나쁘게 만드는 매우 유용한 도구입니다. 우리는 여기에 측면(Aspect)을 활용하여 정확히 그것을 할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nclass DelayService<Decoratee: Service>: Service {\n    typealias Input = Decoratee.Input\n    typealias Output = Decoratee.Output\n\n    let decoratee: Decoratee\n    let duration: UInt64\n\n    init(decoratee: Decoratee, nanoseconds duration: UInt64) {\n        self.decoratee = decoratee\n        self.duration = duration\n    }\n\n    func callAsFunction(input: Input) async throws -> Output {\n        try await Task.sleep(nanoseconds: duration)\n        return try await decoratee(input: input)\n    }\n}\n```\n\n또는 예를 들어 항상 오류를 강제할 수 있는 다른 측면을 추가할 수도 있습니다.\n\n## 측면은 조립 가능합니다.\n\n모든 측면을 준비한 후에는 간단히 뷰 모델을 수정하여 필요한 서비스 유형을 주입하고 여러 측면으로 꾸밀 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n```js\nlet viewModel = ViewModel( allShowsService: DelayService(decoratee: LoggingService(decoratee: AllShowsService()), nanoseconds: 5 * NSEC_PER_SEC), markShowAsWatchedService: LoggingService(decoratee: MarkShowAsWatchedService()) )\n```\n\n이렇게 보시다시피 서로 다른 측면을 연쇄시켰습니다. 조립 가능한 요소들이죠.\n\n하지만 중요한 점은 데코레이터 추가는 어플리케이션의 메인 모듈에서 할 수 있다는 것입니다. 여기서 전체 오브젝트 그래프를 구성할 것으로 가정하고, 일종의 구성 루트 패턴을 통해 서비스의 동작을 변경할 수 있습니다. 이렇게 함으로써, 모듈 중 어느 것도 건드리거나 다시 컴파일할 필요 없이 서비스의 행동을 변경할 수 있게 됩니다.\n\n## 편의성\n\n<div class=\"content-ad\"></div>\n\n데코레이터를 연결하는 것은 조금 귀찮을 수 있지만, 확장 기능을 활용하여 작업성을 개선하고 더 관용적으로 조합할 수 있습니다.\n\n```js\nextension Service {\n    var withLogging: LoggingService<Self> {\n        LoggingService(decoratee: self)\n    }\n\n    func withDelay(nanoseconds duration: UInt64) -> DelayService<Self> {\n        DelayService(decoratee: self, nanoseconds: duration)\n    }\n}\n\n// 이렇게 하는 대신\nDelayService(decoratee: LoggingService(decoratee: AllShowsService()), nanoseconds: 5 * NSEC_PER_SEC),\n\n// 이제 이렇게 할 수 있습니다\nAllShowsService()\n    .withLogging\n    .withDelay(nanoseconds: 5 * NSEC_PER_SEC)\n```\n\n## 데코레이터 자동화\n\nSourcery는 많은 보일러플레이트 코드를 자동화하는 훌륭한 메타프로그래밍 도구입니다. 데코레이터는 이 도구를 적용하기에 좋은 후보입니다. 특히 동일한 측면을 많은 다른 인터페이스에 적용하려는 경우에 유용합니다. 여기를 확인해보세요.```\n\n<div class=\"content-ad\"></div>\n\n# 결론\n\n이러한 작업에 Objective-C의 동적 특성이 그립다는 것은 사실이지만, Swift에서 쉽게 AOP를 적용할 수 있는 런타임 지원의 부족은 좋은 설계 원칙을 적용하여 해결할 기회로 보고 있습니다.\n\nAOP를 활성화하는 것이 코드를 더 좋게 만든다는 보장은 없습니다. 마찬가지로 테스트 가능한 코드를 가지고 있다고 해서 좋은 코드라는 보장도 없습니다. 오히려 반대의 경우가 더 맞습니다. 코드를 테스트할 수 없는 것은 문제입니다. 테스트할 수 있는 것이라고 해서 그게 무조건 좋은 것은 아닙니다. AOP도 비슷한 맥락에서 볼 수 있습니다.\n\n우리는 코드에서 AOP 기능을 활성화하기 위한 흥미로운 연습을 했습니다. 하지만 우리가 추가한 복잡성을 잊어서는 안 됩니다. 미래에 더 잘 적응하기 위해 추가된 복잡성과 느슨한 결합 사이의 균형을 찾는 것은 개발자로서 가장 어려운 일 중 하나입니다. 이 글은 그저 도구에 불과합니다. 항상 올바른 도구를 올바르게 사용하세요.","ogImage":{"url":"/assets/img/2024-05-20-Aspect-OrientedProgramminginSwift_0.png"},"coverImage":"/assets/img/2024-05-20-Aspect-OrientedProgramminginSwift_0.png","tag":["Tech"],"readingTime":12},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<h1>소개</h1>\n<p>Aspect-oriented programming (AOP로 앞으로 표기함)은 코드 베이스에 교차하는 관심사를 확장 가능한 방식으로 추가하는 것에 관한 것입니다.</p>\n<p>\"Aspect Oriented Programming\"이라는 용어를 처음 만났던 그 때를 아직 기억합니다. 많은 시간이 흘렀고, Swift가 아직 존재하지 않았으며, 우리는 기쁘게 Objective-C 코드를 작성하고 있었습니다. ARAnalytics는 AOP 패러다임을 채택하여 코드 베이스 전반에 걸쳐 분석을 추가하는 것을 간단하게 한 최초의 라이브러리 중 하나였습니다.</p>\n<p>코드를 더 자세히 살펴보면 Objective-C에서 AOP를 구현하는 것이 Peter Steinberger가 그의 Aspects 라이브러리에서 언급한 것처럼 메소드 스위즐링을 구현하는 것이라는 것을 알 수 있어요.</p>\n<p>Objective-C와는 달리 Swift는 메시지를 가로채고 실행 중에 동작을 변경할 기능이 많지 않은 엄격하고 정적으로 타입이 지정된 언어에요. 실제로는, 이것은 우리의 코드에 교차 관심을 적용하는 영향을 최소화하기 위해 좋은 디자인의 기초를 설정해야 한다는 의미에요. 우리는 두 가지 주요 구성요소가 필요할 거에요:</p>\n<ul>\n<li>지연 바인딩을 적용하고 필요에 따라 기반이 되는 구현을 변경할 수 있도록 하는 종속성 주입 기능이 필요해요.</li>\n<li>런타임에서 우리가 원하는 동작을 변경할 수 있도록 해주는 가로채기 디자인 패턴인 데코레이터 패턴이 필요해요.</li>\n</ul>\n<p>시작해봐요!</p>\n<h1>Swift에서의 AOP: 좋은 디자인을 향해서</h1>\n<p>우리 애플리케이션을 모델링하는 매우 일반적인 접근 방식은 특정 도메인 모델 주변의 모든 기능을 번들로 묶는 단일 “store/repository/service/aggregate”를 가지는 것입니다. 만약 애플리케이션이 할 일을 관리하는 것이라면, 어떤 형식의 “TodoService”가 있을 것입니다. 만약 TV 프로그램을 관리하는 앱이라면, “ShowService”가 있을 것입니다. 아이디어를 얻으셨죠. 이러한 접근 방식은 많은 중간 규모의 앱에 대해 완벽하게 유효한 것이지만, 다른, 더 복잡한 애플리케이션에는 문제가 될 수 있습니다. 소프트웨어의 대부분은 마찬가지로 모든 것이 의존합니다.</p>\n<p>다음과 같이 보이는 ShowService를 상상해보십시오:</p>\n<pre><code class=\"hljs language-js\">protocol <span class=\"hljs-title class_\">ShowService</span> {\n    func <span class=\"hljs-title function_\">allShows</span>() <span class=\"hljs-keyword\">async</span> -> [<span class=\"hljs-title class_\">Show</span>]\n    func <span class=\"hljs-title function_\">allEpisodes</span>(<span class=\"hljs-keyword\">for</span> <span class=\"hljs-attr\">show</span>: <span class=\"hljs-title class_\">Show</span>) <span class=\"hljs-keyword\">async</span> -> [<span class=\"hljs-title class_\">Episode</span>]\n    func <span class=\"hljs-title function_\">markEpisodeAsWatched</span>(<span class=\"hljs-attr\">episode</span>: <span class=\"hljs-title class_\">Episode</span>) <span class=\"hljs-keyword\">async</span>\n    func <span class=\"hljs-title function_\">markShowAsWatched</span>(_ <span class=\"hljs-attr\">show</span>: <span class=\"hljs-title class_\">Show</span>, until <span class=\"hljs-attr\">episode</span>: <span class=\"hljs-title class_\">Episode</span>?) <span class=\"hljs-keyword\">async</span>\n}\n</code></pre>\n<p>우리가 말했던 대로 소프트웨어의 대부분은 주관적이며 특정 맥락에 따라 토론의 여지가 있음에도 불구하고, 우리를 안내하는 \"원칙\"들이 있으면 좋습니다. 그 원칙들은 보통 SOLID 원칙들입니다.</p>\n<h2>ISP 위반</h2>\n<p>대부분의 대규모 인터페이스와 마찬가지로, ShowService가 인터페이스 분리 원칙을 위반할 가능성이 매우 높습니다. 이는 클라이언트가 필요하지 않은 메서드를 구현하도록 강제함으로써 나타납니다. 특히 목업을 구현할 때 XCTFail과 같은 메서드들을 사용하여 이를 확인하는 것이 매우 흔합니다.</p>\n<pre><code class=\"hljs language-js\">struct <span class=\"hljs-title class_\">ShowServiceMock</span>: <span class=\"hljs-title class_\">ShowService</span> {\n    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">shows</span>: [<span class=\"hljs-title class_\">Show</span>]\n\n    func <span class=\"hljs-title function_\">allShows</span>() -> [<span class=\"hljs-title class_\">Show</span>] {\n        shows\n    }\n    \n    func <span class=\"hljs-title function_\">allEpisodes</span>(<span class=\"hljs-keyword\">for</span> <span class=\"hljs-attr\">show</span>: <span class=\"hljs-title class_\">Show</span>) -> [<span class=\"hljs-title class_\">Episode</span>] {\n        <span class=\"hljs-title class_\">XCTFail</span>(<span class=\"hljs-string\">\"호출되지 않아야 함\"</span>)\n        <span class=\"hljs-keyword\">return</span> []\n    }\n\n    func <span class=\"hljs-title function_\">markEpisodeAsWatched</span>(<span class=\"hljs-params\">episode: Episode</span>) {\n        <span class=\"hljs-title class_\">XCTFail</span>(<span class=\"hljs-string\">\"호출되지 않아야 함\"</span>)\n    }\n\n    func <span class=\"hljs-title function_\">markShowAsWatched</span>(<span class=\"hljs-params\">_ show: Show, until episode: Episode?</span>) {\n        <span class=\"hljs-title class_\">XCTFail</span>(<span class=\"hljs-string\">\"호출되지 않아야 함\"</span>)\n    }\n}\n</code></pre>\n<h2>SRP 위반</h2>\n<p>ISP를 위반할 때, SRP를 위반하는 일도 상당히 흔합니다. SRP는 응집성과 한 가지 이유로만 변경해야 한다는 것과 관련이 있습니다. ShowService 인터페이스에 있는 메서드 수가 늘어날수록, 그 응집성과 SRP를 유지하기가 더욱 어려워질 것입니다.</p>\n<h2>OCP 위반</h2>\n<p>TV 프로그램과 관련된 새로운 기능을 추가하려면 ShowService에 새로운 메서드를 추가해야 하며, 서비스의 모든 구현이 그 변경 사항을 수용하고 컴파일 오류를 수정해야 합니다.</p>\n<h2>큰 인터페이스는 병목 현상을 유발하기 쉽습니다</h2>\n<p>하루의 끝에 이렇게 큰 인터페이스를 갖고 있다면, 해당 도메인 모델과 관련된 새로운 동작을 추가할 때 병목 현상이 발생할 것입니다. 어떠한 새로운 변경이라도 앱 전체에서 컴파일 오류 및 다시 컴파일을 유발합니다. 좋은 소프트웨어 디자인의 한 가지 주의사항은 자주 변경되지 않는 모듈에 의존하는 것입니다. 우리의 의존성 그래프에서 잎 모듈은 가장 안정된 것이어야 합니다. 왜냐하면 그들이 변경될 때마다 전체 그래프가 다시 컴파일되도록 강제할 것입니다. ShowService를 더 자세히 살펴보면, 매우 빈번하게 변경되는 매우 불안정한 모듈에 전체 앱이 의존한다는 점을 알 수 있습니다. 그런 해롭은 일종의 재앙이네요 😅. 참고로, 이러한 병목 현상은 백엔드 및 마이크로서비스 아키텍처에서도 매우 흔히 발생하며, \"엔티티 서비스 안티패턴(The Entity Service Antipattern)\"이라고 불립니다.</p>\n<h2>첫 번째 접근 방식: CQRS</h2>\n<p>첫 번째 접근 방식은 큰 인터페이스를 읽기와 쓰기를 위한 두 가지 구분된 인터페이스로 분리하는 것입니다. 이를 Command Query Responsibility Segregation(CQRS)이라고 합니다.</p>\n<pre><code class=\"hljs language-bash\">// 읽기\nprotocol ShowQueryService {\n    func allShows() async -> [Show]\n    func allEpisodes(<span class=\"hljs-keyword\">for</span> show: Show) async -> [Episode]\n}\n\n// 쓰기\nprotocol ShowCommandService {\n    func markEpisodeAsWatched(episode: Episode) async\n    func markShowAsWatched(_ show: Show, <span class=\"hljs-keyword\">until</span> episode: Episode?) async\n}\n</code></pre>\n<p>보통 이렇게 분리하는 것이 읽기와 쓰기에 필요한 기능이 매우 다르기 때문에 합리적입니다. 예를 들어 상태를 변경할 때(쓰기)만 적용되는 보안 정책이 있을 수 있습니다.</p>\n<p>하지만 상상할 수 있듯이, 이것은 큰 개선이 아닙니다. 변경의 영향을 더 잘 제한했지만 여전히 자주 변경될 두 가지 \"큰 인터페이스\"가 존재합니다. 더 좋은 방법이 있을 수 있습니다.</p>\n<h2>두 번째 접근 방법: 작은 서비스</h2>\n<p>당신이 깨끗한 아키텍처와 유즈 케이스로 작업하는 데 익숙하다면, 이것들이 정확히 그것입니다.</p>\n<p>일부 장단점이 있습니다. 각 메서드 당 프로토콜을 갖는 것은 인터페이스의 폭발을 일으킬 수 있습니다. 그러나 이것은 이전에 이야기한 일부 SOLID 원칙을 준수하는 주요 이점도 가지고 있습니다. 이제 ISP(인터페이스 분리 원칙)를 준수하고 있고 아마도 SRP(단일 책임 원칙)을 준수하고 있을 것입니다. 또한 새로운 기능을 추가할 때는 새로운 튜플(인터페이스, 구현)을 만들기만 하면 되므로 코드를 많이 수정하거나 재컴파일하는 영향을 최소화할 수 있습니다. 그러니 전체가 나쁜 것만은 아닙니다. 기억하세요, 모든 것은 의존합니다. 소프트웨어는 모든 것이 트레이드오프에 관한 것입니다.</p>\n<p>하지만 \"Aspects\"에 대해 생각해보면, 필요한 각 측면마다 프로토콜 당 하나의 구현을 해야 합니다. 예를 들어 \"로그 기록 Aspect\"를 구현하려면 AllShowsLoggingService와 MarkShowAsWatchedLoggingService 등이 필요합니다. 그래서 우리 앱에서 관심사를 구현하는 데 적합한 방법이 아닌 것 같습니다.</p>\n<p>세 번째, 마지막 방법으로 가봅시다.</p>\n<h2>세 번째 방법: 통합된 서비스 인터페이스</h2>\n<p>AOP를 확장 가능한 방식으로 구현하려면 \"aspects\"를 적용할 모든 서비스에 대해 단일 인터페이스/시마가 필요합니다.</p>\n<pre><code class=\"hljs language-js\">프로토콜 <span class=\"hljs-title class_\">Service</span>&#x3C;<span class=\"hljs-title class_\">Input</span>, <span class=\"hljs-title class_\">Output</span>> {\n    associatedtype <span class=\"hljs-title class_\">Input</span>\n    associatedtype <span class=\"hljs-title class_\">Output</span>\n\n    func <span class=\"hljs-title function_\">callAsFunction</span>(<span class=\"hljs-attr\">input</span>: <span class=\"hljs-title class_\">Input</span>) <span class=\"hljs-keyword\">async</span> throws -> <span class=\"hljs-title class_\">Output</span>\n}\n</code></pre>\n<p>편의성을 위해 다음도 추가해 봅시다.</p>\n<pre><code class=\"hljs language-js\">extension <span class=\"hljs-title class_\">Service</span> where <span class=\"hljs-title class_\">Input</span> == <span class=\"hljs-title class_\">Void</span>{\n    func <span class=\"hljs-title function_\">callAsFunction</span>() <span class=\"hljs-keyword\">async</span> throws -> <span class=\"hljs-title class_\">Output</span> {\n        <span class=\"hljs-keyword\">try</span> <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">callAsFunction</span>(<span class=\"hljs-attr\">input</span>: ())\n    }\n}\n</code></pre>\n<p>단일 인터페이스를 가지고 있어, 다음과 같은 것을 할 수 있습니다.```</p>\n<pre><code class=\"hljs language-kotlin\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AllShowsService</span>: <span class=\"hljs-type\">Service</span> {\n    <span class=\"hljs-keyword\">suspend</span> <span class=\"hljs-keyword\">operator</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">invoke</span><span class=\"hljs-params\">(input: <span class=\"hljs-type\">Void</span>)</span></span>: List&#x3C;Show> {\n        <span class=\"hljs-comment\">// Implementation...</span>\n    }\n}\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MarkShowAsWatchedService</span>: <span class=\"hljs-type\">Service</span> {\n    <span class=\"hljs-keyword\">suspend</span> <span class=\"hljs-keyword\">operator</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">invoke</span><span class=\"hljs-params\">(input: <span class=\"hljs-type\">Pair</span>&#x3C;<span class=\"hljs-type\">Show</span>, Episode?>)</span></span> {\n        <span class=\"hljs-comment\">// Implementation...</span>\n    }\n}\n\n<span class=\"hljs-keyword\">typealias</span> AllShowsServiceType = Service&#x3C;<span class=\"hljs-built_in\">Void</span>, List&#x3C;Show>>\n<span class=\"hljs-keyword\">typealias</span> MarkShowAsWatchedServiceType = Service&#x3C;Pair&#x3C;Show, Episode?>, <span class=\"hljs-built_in\">Void</span>>\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ViewModel</span>&#x3C;<span class=\"hljs-type\">AllShowsService: AllShowsServiceType, MarkShowAsWatchedService: MarkShowAsWatchedServiceType</span>> {\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">val</span> allShowsService: AllShowsService\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">val</span> markShowAsWatchedService: MarkShowAsWatchedService\n\n    <span class=\"hljs-keyword\">init</span>(allShowsService: AllShowsService, markShowAsWatchedService: MarkShowAsWatchedService) {\n        <span class=\"hljs-keyword\">this</span>.allShowsService = allShowsService\n        <span class=\"hljs-keyword\">this</span>.markShowAsWatchedService = markShowAsWatchedService\n    }\n\n    <span class=\"hljs-keyword\">suspend</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">markAllShowsAsWatchedButtonTapped</span><span class=\"hljs-params\">()</span></span> {\n        <span class=\"hljs-keyword\">try</span> {\n            <span class=\"hljs-keyword\">val</span> allShows = allShowsService(<span class=\"hljs-built_in\">Void</span>)\n            coroutineScope {\n                allShows.map { show ->\n                    launch {\n                        markShowAsWatchedService(Pair(show, <span class=\"hljs-literal\">null</span>))\n                    }\n                }\n            }\n        } <span class=\"hljs-keyword\">catch</span> (e: Exception) {\n            println(<span class=\"hljs-string\">\"Some error happened <span class=\"hljs-variable\">$error</span>\"</span>)\n        }\n    }\n}\n</code></pre>\n<p>지금은 ViewModel을 생성할 때 두 개의 입력값을 주입하면 됩니다:</p>\n<ul>\n<li>Service<code>Void, [Show]</code></li>\n<li>Service<code>(show: Show, episode: Episode?), Void</code></li>\n</ul>\n<p>Service가 단일 인터페이스이기 때문에 앱 전체의 모든 서비스에 적용할 수 있는 각 측면마다 인터페이스의 구현만 있으면 됩니다.```</p>\n<p>그러면 몇 가지를 구현해 보겠습니다! 확인하시겠지만, 모든 측면은 데코레이터 패턴을 따라 매우 유사합니다.</p>\n<h2>로깅 측면</h2>\n<p>서비스에 몇 가지 로깅 기능을 추가하는 것은 매우 일반적이고 유용한 측면입니다. 다음과 같이 간단히 구현할 수 있습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">LoggingService</span>&#x3C;<span class=\"hljs-title class_\">Decoratee</span>: <span class=\"hljs-title class_\">Service</span>>: <span class=\"hljs-title class_\">Service</span> {\n    typealias <span class=\"hljs-title class_\">Input</span> = <span class=\"hljs-title class_\">Decoratee</span>.<span class=\"hljs-property\">Input</span>\n    typealias <span class=\"hljs-title class_\">Output</span> = <span class=\"hljs-title class_\">Decoratee</span>.<span class=\"hljs-property\">Output</span>\n\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">decoratee</span>: <span class=\"hljs-title class_\">Decoratee</span>\n    \n    <span class=\"hljs-title function_\">init</span>(<span class=\"hljs-params\">decoratee: Decoratee</span>) {\n        self.<span class=\"hljs-property\">decoratee</span> = decoratee\n    }\n\n    func <span class=\"hljs-title function_\">callAsFunction</span>(<span class=\"hljs-attr\">input</span>: <span class=\"hljs-title class_\">Input</span>) <span class=\"hljs-keyword\">async</span> throws -> <span class=\"hljs-title class_\">Output</span> {\n        <span class=\"hljs-keyword\">let</span> output = <span class=\"hljs-keyword\">try</span> <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">decoratee</span>(<span class=\"hljs-attr\">input</span>: input)\n        <span class=\"hljs-title function_\">dump</span>(output)\n        <span class=\"hljs-keyword\">return</span> output\n    }\n}\n</code></pre>\n<h2>프리미엄 사용자 측면</h2>\n<p>애플리케이션에서 매우 유용한 교차 기능 중 하나는 사용자가 프리미엄 사용자인 경우에만 일부 작업을 수행할 수 있도록 허용하는 것일 수 있습니다. 사용자가 프리미엄 사용자인지 여부를 확인하는 방법을 추상화하기 위해 간단한 <code>async</code> 함수를 주입하여 PremiumService 데코레이터를 다음과 같이 만들 수 있습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">PremiumService</span>&#x3C;<span class=\"hljs-title class_\">Decoratee</span>: <span class=\"hljs-title class_\">Service</span>>: <span class=\"hljs-title class_\">Service</span> {\n    struct <span class=\"hljs-title class_\">Error</span>: <span class=\"hljs-title class_\">Swift</span>.<span class=\"hljs-property\">Error</span> {}\n\n    typealias <span class=\"hljs-title class_\">Input</span> = <span class=\"hljs-title class_\">Decoratee</span>.<span class=\"hljs-property\">Input</span>\n    typealias <span class=\"hljs-title class_\">Output</span> = <span class=\"hljs-title class_\">Decoratee</span>.<span class=\"hljs-property\">Output</span>\n\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">decoratee</span>: <span class=\"hljs-title class_\">Decoratee</span>\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">isPremiumUser</span>: () <span class=\"hljs-keyword\">async</span> -> <span class=\"hljs-title class_\">Bool</span>\n\n    <span class=\"hljs-title function_\">init</span>(<span class=\"hljs-params\">decoratee: Decoratee, isPremiumUser: @escaping () <span class=\"hljs-keyword\">async</span> -> Bool</span>) {\n        self.<span class=\"hljs-property\">decoratee</span> = decoratee\n        self.<span class=\"hljs-property\">isPremiumUser</span> = isPremiumUser\n    }\n\n    func <span class=\"hljs-title function_\">callAsFunction</span>(<span class=\"hljs-attr\">input</span>: <span class=\"hljs-title class_\">Input</span>) <span class=\"hljs-keyword\">async</span> throws -> <span class=\"hljs-title class_\">Output</span> {\n        guard <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">isPremiumUser</span>() <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-title class_\">Error</span>()\n        }\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">try</span> <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">decoratee</span>(<span class=\"hljs-attr\">input</span>: input)\n    }\n}\n</code></pre>\n<h2>캐싱 측면</h2>\n<p>또 다른 일반적인 측면은 캐싱 또는 메모이제이션입니다. 단순히 서비스 입력을 해시 가능한 것으로 제한하고 출력을 Codable로 정의함으로써 모든 서비스에 대해 구현할 수 있습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title function_\">private</span>(set) <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">cache</span>: [<span class=\"hljs-title class_\">AnyHashable</span>: <span class=\"hljs-title class_\">Data</span>] = [:]\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">CachingService</span>&#x3C;<span class=\"hljs-title class_\">Decoratee</span>: <span class=\"hljs-title class_\">Service</span>>: <span class=\"hljs-title class_\">Service</span> where <span class=\"hljs-title class_\">Decoratee</span>.<span class=\"hljs-property\">Output</span>: <span class=\"hljs-title class_\">Codable</span>, <span class=\"hljs-title class_\">Decoratee</span>.<span class=\"hljs-property\">Input</span>: <span class=\"hljs-title class_\">Hashable</span> {\n    typealias <span class=\"hljs-title class_\">Input</span> = <span class=\"hljs-title class_\">Decoratee</span>.<span class=\"hljs-property\">Input</span>\n    typealias <span class=\"hljs-title class_\">Output</span> = <span class=\"hljs-title class_\">Decoratee</span>.<span class=\"hljs-property\">Output</span>\n\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">decoratee</span>: <span class=\"hljs-title class_\">Decoratee</span>\n\n    <span class=\"hljs-title function_\">init</span>(<span class=\"hljs-params\">decoratee: Decoratee</span>) {\n        self.<span class=\"hljs-property\">decoratee</span> = decoratee\n    }\n\n    func <span class=\"hljs-title function_\">callAsFunction</span>(<span class=\"hljs-attr\">input</span>: <span class=\"hljs-title class_\">Input</span>) <span class=\"hljs-keyword\">async</span> throws -> <span class=\"hljs-title class_\">Output</span> {\n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">let</span> cachedData = cache[input] {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">try</span> <span class=\"hljs-title class_\">JSON</span>Decoder().<span class=\"hljs-title function_\">decode</span>(<span class=\"hljs-title class_\">Output</span>.<span class=\"hljs-property\">self</span>, <span class=\"hljs-attr\">from</span>: cachedData)\n        }\n\n        <span class=\"hljs-keyword\">let</span> output = <span class=\"hljs-keyword\">try</span> <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">decoratee</span>(<span class=\"hljs-attr\">input</span>: input)\n        cache[input] = <span class=\"hljs-keyword\">try</span> <span class=\"hljs-title class_\">JSON</span>Encoder().<span class=\"hljs-title function_\">encode</span>(output)\n        <span class=\"hljs-keyword\">return</span> output\n    }\n}\n</code></pre>\n<h2>지연 측면</h2>\n<p>네트워크 링크 조절기(Network Link Conditioner)는 다양한 유형의 네트워크 상황을 시뮬레이션하고 인터넷 연결을 매우 나쁘게 만드는 매우 유용한 도구입니다. 우리는 여기에 측면(Aspect)을 활용하여 정확히 그것을 할 수 있습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DelayService</span>&#x3C;<span class=\"hljs-title class_\">Decoratee</span>: <span class=\"hljs-title class_\">Service</span>>: <span class=\"hljs-title class_\">Service</span> {\n    typealias <span class=\"hljs-title class_\">Input</span> = <span class=\"hljs-title class_\">Decoratee</span>.<span class=\"hljs-property\">Input</span>\n    typealias <span class=\"hljs-title class_\">Output</span> = <span class=\"hljs-title class_\">Decoratee</span>.<span class=\"hljs-property\">Output</span>\n\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">decoratee</span>: <span class=\"hljs-title class_\">Decoratee</span>\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">duration</span>: <span class=\"hljs-title class_\">UInt64</span>\n\n    <span class=\"hljs-title function_\">init</span>(<span class=\"hljs-params\">decoratee: Decoratee, nanoseconds duration: UInt64</span>) {\n        self.<span class=\"hljs-property\">decoratee</span> = decoratee\n        self.<span class=\"hljs-property\">duration</span> = duration\n    }\n\n    func <span class=\"hljs-title function_\">callAsFunction</span>(<span class=\"hljs-attr\">input</span>: <span class=\"hljs-title class_\">Input</span>) <span class=\"hljs-keyword\">async</span> throws -> <span class=\"hljs-title class_\">Output</span> {\n        <span class=\"hljs-keyword\">try</span> <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title class_\">Task</span>.<span class=\"hljs-title function_\">sleep</span>(<span class=\"hljs-attr\">nanoseconds</span>: duration)\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">try</span> <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">decoratee</span>(<span class=\"hljs-attr\">input</span>: input)\n    }\n}\n</code></pre>\n<p>또는 예를 들어 항상 오류를 강제할 수 있는 다른 측면을 추가할 수도 있습니다.</p>\n<h2>측면은 조립 가능합니다.</h2>\n<p>모든 측면을 준비한 후에는 간단히 뷰 모델을 수정하여 필요한 서비스 유형을 주입하고 여러 측면으로 꾸밀 수 있습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">let</span> viewModel = <span class=\"hljs-title class_\">ViewModel</span>( <span class=\"hljs-attr\">allShowsService</span>: <span class=\"hljs-title class_\">DelayService</span>(<span class=\"hljs-attr\">decoratee</span>: <span class=\"hljs-title class_\">LoggingService</span>(<span class=\"hljs-attr\">decoratee</span>: <span class=\"hljs-title class_\">AllShowsService</span>()), <span class=\"hljs-attr\">nanoseconds</span>: <span class=\"hljs-number\">5</span> * <span class=\"hljs-variable constant_\">NSEC_PER_SEC</span>), <span class=\"hljs-attr\">markShowAsWatchedService</span>: <span class=\"hljs-title class_\">LoggingService</span>(<span class=\"hljs-attr\">decoratee</span>: <span class=\"hljs-title class_\">MarkShowAsWatchedService</span>()) )\n</code></pre>\n<p>이렇게 보시다시피 서로 다른 측면을 연쇄시켰습니다. 조립 가능한 요소들이죠.</p>\n<p>하지만 중요한 점은 데코레이터 추가는 어플리케이션의 메인 모듈에서 할 수 있다는 것입니다. 여기서 전체 오브젝트 그래프를 구성할 것으로 가정하고, 일종의 구성 루트 패턴을 통해 서비스의 동작을 변경할 수 있습니다. 이렇게 함으로써, 모듈 중 어느 것도 건드리거나 다시 컴파일할 필요 없이 서비스의 행동을 변경할 수 있게 됩니다.</p>\n<h2>편의성</h2>\n<p>데코레이터를 연결하는 것은 조금 귀찮을 수 있지만, 확장 기능을 활용하여 작업성을 개선하고 더 관용적으로 조합할 수 있습니다.</p>\n<pre><code class=\"hljs language-js\">extension <span class=\"hljs-title class_\">Service</span> {\n    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">withLogging</span>: <span class=\"hljs-title class_\">LoggingService</span>&#x3C;<span class=\"hljs-title class_\">Self</span>> {\n        <span class=\"hljs-title class_\">LoggingService</span>(<span class=\"hljs-attr\">decoratee</span>: self)\n    }\n\n    func <span class=\"hljs-title function_\">withDelay</span>(nanoseconds <span class=\"hljs-attr\">duration</span>: <span class=\"hljs-title class_\">UInt64</span>) -> <span class=\"hljs-title class_\">DelayService</span>&#x3C;<span class=\"hljs-title class_\">Self</span>> {\n        <span class=\"hljs-title class_\">DelayService</span>(<span class=\"hljs-attr\">decoratee</span>: self, <span class=\"hljs-attr\">nanoseconds</span>: duration)\n    }\n}\n\n<span class=\"hljs-comment\">// 이렇게 하는 대신</span>\n<span class=\"hljs-title class_\">DelayService</span>(<span class=\"hljs-attr\">decoratee</span>: <span class=\"hljs-title class_\">LoggingService</span>(<span class=\"hljs-attr\">decoratee</span>: <span class=\"hljs-title class_\">AllShowsService</span>()), <span class=\"hljs-attr\">nanoseconds</span>: <span class=\"hljs-number\">5</span> * <span class=\"hljs-variable constant_\">NSEC_PER_SEC</span>),\n\n<span class=\"hljs-comment\">// 이제 이렇게 할 수 있습니다</span>\n<span class=\"hljs-title class_\">AllShowsService</span>()\n    .<span class=\"hljs-property\">withLogging</span>\n    .<span class=\"hljs-title function_\">withDelay</span>(<span class=\"hljs-attr\">nanoseconds</span>: <span class=\"hljs-number\">5</span> * <span class=\"hljs-variable constant_\">NSEC_PER_SEC</span>)\n</code></pre>\n<h2>데코레이터 자동화</h2>\n<p>Sourcery는 많은 보일러플레이트 코드를 자동화하는 훌륭한 메타프로그래밍 도구입니다. 데코레이터는 이 도구를 적용하기에 좋은 후보입니다. 특히 동일한 측면을 많은 다른 인터페이스에 적용하려는 경우에 유용합니다. 여기를 확인해보세요.```</p>\n<h1>결론</h1>\n<p>이러한 작업에 Objective-C의 동적 특성이 그립다는 것은 사실이지만, Swift에서 쉽게 AOP를 적용할 수 있는 런타임 지원의 부족은 좋은 설계 원칙을 적용하여 해결할 기회로 보고 있습니다.</p>\n<p>AOP를 활성화하는 것이 코드를 더 좋게 만든다는 보장은 없습니다. 마찬가지로 테스트 가능한 코드를 가지고 있다고 해서 좋은 코드라는 보장도 없습니다. 오히려 반대의 경우가 더 맞습니다. 코드를 테스트할 수 없는 것은 문제입니다. 테스트할 수 있는 것이라고 해서 그게 무조건 좋은 것은 아닙니다. AOP도 비슷한 맥락에서 볼 수 있습니다.</p>\n<p>우리는 코드에서 AOP 기능을 활성화하기 위한 흥미로운 연습을 했습니다. 하지만 우리가 추가한 복잡성을 잊어서는 안 됩니다. 미래에 더 잘 적응하기 위해 추가된 복잡성과 느슨한 결합 사이의 균형을 찾는 것은 개발자로서 가장 어려운 일 중 하나입니다. 이 글은 그저 도구에 불과합니다. 항상 올바른 도구를 올바르게 사용하세요.</p>\n</body>\n</html>\n"},"__N_SSG":true}