{"pageProps":{"post":{"title":"데브옵스 제로 투 히어로 3  도커에 대해 알아야 할 모든 것","description":"","date":"2024-05-18 16:42","slug":"2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers","content":"\n\n## 데브옵스 업무 흐름에서 도커 사용을 시작하는 완벽한 가이드\n\n### 이 블로그 포스트에서 무엇을 기대해야 하는가?\n\n### 왜 Docker를 사용해야 하는가?\n\n20~30년 전으로 돌아가면, 하드웨어와 설치된 운영 체제(커널 및 UI)가 있었습니다. 어플리케이션을 실행하기 위해서 코드를 컴파일하고 모든 앱 의존성을 정렬해야 했습니다. 다른 어플리케이션이나 어플리케이션 작업량의 증가를 수용하기 위해 새 하드웨어를 구매하고 설치 및 구성해야 했습니다.\n\n<div class=\"content-ad\"></div>\n\n가상화는 하드웨어와 운영 체제 사이에 추가 계층인 하이퍼바이저라는 것을 추가했습니다. 이를 통해 사용자들은 독립된 여러 애플리케이션을 실행하여 가상 머신을 자체 운영 체제와 함께 실행할 수 있었습니다.\n\n그럼에도 불구하고, 우리는 모든 가상 머신에 소프트웨어를 설치하고 종속성을 설정해주어야 했습니다. 애플리케이션이 휴대 가능하지 않았습니다. 일부 기기에서는 작동하지만 다른 기기에서는 작동하지 않았습니다.\n\n![이미지](/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_0.png)\n\n# 도커란 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\n도커는 마이크로서비스 기반 응용 프로그램 개발이 가능하도록 함으로써 소프트웨어 빌드 방법을 혁신했습니다.\n\n# 도커는 어떻게 작동하나요?\n\n도커 엔진은 호스트 운영 체제 위에서 실행됩니다. 도커 엔진에는 호스트 시스템에서 도커 컨테이너를 관리하는 서버 프로세스(dockerd)가 포함되어 있습니다. 도커 컨테이너는 응용 프로그램과 그 의존성을 격리시켜 다른 환경에서도 일관되게 실행할 수 있도록 설계되었습니다.\n\n![이미지](/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_1.png)\n\n<div class=\"content-ad\"></div>\n\n도커를 사용하려면 Dockerfile, Docker 이미지, Docker 컨테이너라는 세 가지 개념을 이해해야 합니다.\n\n## Docker 파일(Dockerfile)이란?\n\n## Docker 이미지란 무엇인가요?\n\nDocker 이미지에는 컨테이너 내에서 코드를 실행하는 데 필요한 모든 종속성이 포함되어 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## Docker 컨테이너란 무엇인가요?\n\n# Docker로 시작하기\n\n## 사전 요구 사항\n\nDocker는 로컬 머신 또는 클라우드 VM에 설치되어 있어야 합니다.\n\n<div class=\"content-ad\"></div>\n\nLinux:\n\n로컬 노트북, 가상 머신 또는 클라우드 VM에서 Linux를 실행 중이라면 패키지 관리자를 사용하여 Docker를 설치할 수 있습니다. 이 블로그 포스트의 지시사항을 따라주세요.\n\nMac 및 Windows:\n\n로컬 머신에서 Docker를 실행할 수 있게 해주는 Docker Desktop을 설치할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n도커를 시작하는 것은 쉬운 일이에요. 아래 명령을 실행하기만 하면 돼요\n\n```js\n도커 런 -d -t --name Thor alpine\n도커 런 -d -t busybox\n```\n\n이 명령은 도커 이미지 alpine과 busybox로부터 2개의 컨테이너를 생성할 거에요. 이 둘은 도커 허브에 저장된 미니멀리스트이면서 퍼블릭인 리눅스 도커 이미지에요.\n\n- -d 옵션은 컨테이너를 백그라운드에서 실행(detach mode)\n- -t 옵션은 tty 터미널을 연결해 줘요.\n- --name 옵션은 컨테이너에 이름을 부여할 수 있어요. 제공하지 않으면 컨테이너는 랜덤 이름을 받게 돼요\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_2.png\" />\n\n참고: 위에 언급된 이미지로 처음 docker run을 실행하면 도커가 로컬 머신에서 이미지를 다운로드(풀)해야 합니다.\n\n## 로컬 머신에서 실행 중인/중지된 컨테이너 목록\n\n```js\ndocker ps # 실행 중인 컨테이너 확인\ndocker ps -a # 모든 컨테이너 목록\n```\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_3.png\" />\n\n## 로컬 머신에 있는 도커 이미지 목록\n\n```js\ndocker image ls\n```\n\n<img src=\"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_4.png\" />\n\n<div class=\"content-ad\"></div>\n\nLinux 기반 도커 컨테이너에 사용된 이미지 크기를 확인할 수 있어요. 우분투, 아마존 리눅스, CentOS 등과 같은 일반적인 Linux 기반 머신과 비교하면 작아요.\n\n실행 중인 컨테이너와 상호 작용하는 방법은 명령을 전달하거나 대화형 세션을 여는 두 가지 방법이 있어요.\n\n```js\n# docker exec -it <컨테이너 ID> <셸>\n```\n\n- docker exec를 사용하면 실행 중인 도커 컨테이너 내부로 진입할 수 있어요.\n- --it는 도커와 대화형 세션을 열어줘요.\n- 셸은 sh, bash, zsh 등을 사용할 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n컨테이너 정보를 얻기 위해 몇 가지 명령을 실행해 봅시다.\n\n```js\ndocker exec -t Thor ls ; ps\n# -t는 tty 세션을 열기 위한 옵션입니다.\n# Thor는 컨테이너 이름입니다.\n# ls ; ps는 ls와 ps 두 개의 명령을 실행합니다.\n\ndocker exec -t 8ad10d1d0660 free -m \n# 8ad10d1d0660은 컨테이너 ID이며, free -m은 메모리 사용량을 확인하는 명령입니다.\n```\n\n![이미지](/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_5.png)\n\n이제 -it 옵션을 사용하여 컨테이너와 대화형 쉘 세션을 열어보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n도커 exec -it 16fb1c59fbea sh \n# 세션을 종료하려면 \"exit\"을 입력하세요\n```\n\n![이미지](/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_6.png)\n\n# 컨테이너 시작, 중지, 삭제\n\n```js\n# 실행 중인 컨테이너를 중지하는 방법\ndocker stop <컨테이너 이름 또는 ID>\n\n# 중지된 컨테이너를 시작하는 방법\ndocker start <컨테이너 이름 또는 ID>\n```\n\n<div class=\"content-ad\"></div>\n\n\n![Image](/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_7.png)\n\n```js\n# 실행 중인 컨테이너를 종료한 후에 삭제하려면 다음과 같이 명령을 사용합니다.\n# docker stop <컨테이너 이름 또는 ID>\n# docker rm <컨테이너 이름 또는 ID>\ndocker stop 16fb1c59fbea\ndocker rm 16fb1c59fbea\n\n# 아니면 -f 플래그를 사용하여 강제로 컨테이너를 삭제합니다.\ndocker rm -f Thor\n```\n\n![Image](/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_8.png)\n\n# 도커 이미지 빌드하기\n\n\n<div class=\"content-ad\"></div>\n\n# Docker 네트워킹\n\n도커는 다양한 종류의 네트워크를 제공합니다.\n\n## 1. 기본 브릿지\n\n만약 도커허브에서 nginx 이미지를 사용하여 nginx 컨테이너를 실행 중이고 웹 서버에 액세스하려고 한다면요.\n\n<div class=\"content-ad\"></div>\n\n![screenshot](/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_9.png)\n\n스크린샷을 통해 Nginx 웹 서버가 80번 포트에서 실행 중임을 확인할 수 있습니다. NGINX 컨테이너에 로그인하여 curl 127.0.0.1:80을 실행하면 웹 서버에서 HTML 응답을 반환합니다.\n\n- 127.0.0.1은 루프백 주소로 현재 장치(로컬호스트)를 항상 가리킵니다.\n\n![screenshot](/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_10.png)\n\n<div class=\"content-ad\"></div>\n\n위에서 본 것처럼, 컨테이너 내부의 웹 서버가 우리가 기대한 대로 작동했습니다.\n\n이제 호스트 머신 (랩톱/가상 머신)에서 웹 서버에 연결해 보겠습니다.\n\n![이미지](/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_11.png)\n\n컨테이너에서 실행 중인 nginx 웹 서버에 연결할 수 없었습니다.\n\n<div class=\"content-ad\"></div>\n\n네트워크 깊이 파고들기\n\n도커 컨테이너를 검사하려면 docker inspect 명령을 실행하고 맨 아래로 스크롤하면 도커가 브릿지 네트워크를 사용하고 네트워크에 대한 자세한 내용을 볼 수 있습니다.\n\n```js\ndocker inspect nginx-container\n```\n\n<img src=\"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_12.png\" />\n\n<div class=\"content-ad\"></div>\n\n```js\n도커 네트워크 목록\n```\n\n<img src=\"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_13.png\" />\n\n네트워크를 검사하면 기본 브릿지 네트워크를 사용하는 컨테이너를 찾을 수 있습니다.\n\n```js\n도커 네트워크 검사 브릿지\n```\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_14.png\" />\n\n## 포트 전달\n\n```js\n도커 실행 -d -p <호스트 포트>:<컨테이너 포트> --name <컨테이너 이름> 이미지\n\n# 포트 전달 -> 컨테이너의 포트 80을 호스트 머신의 포트 5000으로 전달\n도커 실행 -t -d -p 5000:80 --name nginx-container nginx:latest\n```\n\n<img src=\"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_15.png\" />\n\n<div class=\"content-ad\"></div>\n\n![](/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_16.png)\n\n도커는 기본 네트워크를 사용하지 말라고 권장하고 대신에 우리만의 네트워크를 생성하도록 하고 있습니다.\n\nbusybox 이미지를 사용하여 2개의 컨테이너를 생성해 봅시다. 컨테이너를 실행한 후, 컨테이너 내부에서 서로 핑을 시도해 봅시다.\n\n2개의 컨테이너를 생성하고, 각 컨테이너의 IP 주소를 얻기 위해 docker inspect를 사용해 보세요.\n\n<div class=\"content-ad\"></div>\n\n아래는 두 컨테이너의 IP 주소가 동일한 네트워크에 있음을 확인할 수 있습니다(기본 브리지 네트워크).\n\n이름과 IP 주소로 서로 핑을 보내 봅시다.\n\n![image1](/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_17.png)\n\n![image2](/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_18.png)\n\n<div class=\"content-ad\"></div>\n\n위 스크린샷을 보면 두 컨테이너 모두 서로 통신할 수 있지만 이름으로는 연결할 수 없습니다.\n\n## 2. 사용자 정의 브리지 네트워크\n\n네트워크 생성\n\n```js\ndocker network create blog-network\n```\n\n<div class=\"content-ad\"></div>\n\n새로운 네트워크를 사용하여 이름이 nginx-con인 nginx 컨테이너를 만들어보세요.\n\n```bash\ndocker run -itd --network blog-network --name nginx-con nginx\ndocker ps\n```\n\n![이미지](/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_19.png)\n\n도커 컨테이너와 네트워크를 검사해봅시다.\n\n<div class=\"content-ad\"></div>\n\n```js\n도커 네트워크를 검사하는 방법: \n\n```docker network inspect blog-network```\n\n![사진](/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_20.png)\n\nNginx 컨테이너를 검사하는 방법: \n\n```docker inspect nginx-con```\n\n![사진](/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_21.png)\n```\n\n<div class=\"content-ad\"></div>\n\n이제 호스트 포트를 통해 컨테이너에서 실행 중인 nginx 웹 서버에 액세스하려고 하면 작동하지 않을 것입니다. 여전히 컨테이너에서 실행 중인 웹 서버에 액세스하려면 호스트 포트로의 포트 포워딩을 수행해야 합니다.\n\n그러나 하나가 정리되었습니다 — 이름 해결입니다. 이제 사용자 정의 브리지 네트워크에서 컨테이너를 핑하면 작동해야 합니다.\n\n한 가지 busybox 컨테이너를 만들고 nginx-con 컨테이너를 핑해 보겠습니다.\n\n![이미지](/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_22.png)\n\n<div class=\"content-ad\"></div>\n\n## 3. 호스트 네트워크\n\n```js\ndocker run -td --network host --name nginx-server nginx:latest\ndocker ps\n```\n\n![image](/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_23.png)\n\n이렇게 하면 nginx 컨테이너가 호스트 네트워크에서 실행됩니다.\n\n<div class=\"content-ad\"></div>\n\n만약 로컬 호스트에서 nginx 서버에 접근하려고 하면, 작동해야 합니다.\n\n만약 컨테이너의 IP 주소를 확인하려면\n\n```js\ndocker inspect nginx-server | grep IPAddress\n```\n\n아래 그림을 참고하세요:\n\n![이미지](/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_24.png)\n\n<div class=\"content-ad\"></div>\n\n뭐라구요? 해당 IP 주소가 없나봐요. 호스트 머신의 IP 주소를 사용한 모양이에요.\n\n다른 종류의 네트워크에 대해 더 알려드릴게요. 하지만 블로그가 너무 길어지고 있네요.\n\n# 도커 볼륨\n\n도커는 로컬 파일 시스템에서 컨테이너의 모든 콘텐츠, 코드 및 데이터를 분리합니다. 이는 도커 데스크탑에서 컨테이너를 삭제하면 그 안의 모든 콘텐츠가 삭제된다는 뜻이에요.\n\n<div class=\"content-ad\"></div>\n\n가끔은 컨테이너가 생성한 데이터를 유지하기를 원할 수 있습니다. 이때 볼륨을 사용할 수 있습니다.\n\n## 바인드 마운트\n\n바인드 마운트를 사용하면 호스트 머신의 파일 또는 디렉토리가 컨테이너로 마운트됩니다.\n\n## 도커 볼륨\n\n<div class=\"content-ad\"></div>\n\n체적은 도커에서 관리하는 로컬 파일 시스템의 위치입니다.\n\n체적은 사용 중인 컨테이너의 크기를 늘리지 않으며, 체적의 내용은 특정 컨테이너의 생명 주기 외부에 존재합니다.\n\n# 도커에서 체적 사용하는 방법\n\n도커에서 체적을 사용하는 방법에는 --mount 및 -v (또는 --volume ) 두 가지가 있습니다. -v 구문은 모든 옵션을 하나의 필드에 결합하며, --mount 구문은 옵션을 분리합니다.\n\n<div class=\"content-ad\"></div>\n\n- -v 또는 --volume: 콜론 문자(:)로 구분된 세 개의 필드로 구성됩니다.\n\n   - 첫 번째 필드는 바인드 마운트의 경우 호스트 머신의 파일 또는 디렉터리 경로이거나 볼륨의 이름입니다.\n   - 두 번째 필드는 컨테이너 내에서 파일 또는 디렉터리가 마운트된 경로입니다.\n   - 세 번째 필드는 선택 사항입니다. ro, z, Z와 같은 옵션들의 쉼표로 구분된 목록입니다.\n\n--mount: 쉼표로 구분된 여러 개의 키-값 페어로 구성됩니다.\n\n   - 마운트의 유형(bind, volume 또는 tmpfs).\n   - 마운트의 소스.\n   - 목적지는 파일 또는 디렉터리가 컨테이너 내에서 마운트된 경로로 값을 취합니다.\n\n<div class=\"content-ad\"></div>\n\n# 예시: Docker 컨테이너와 바인드 마운트\n\n우리는 호스트 머신의 동일한 디렉토리/폴더를 4개의 컨테이너에 마운트했습니다.\n\n```js\nmkdir docker-bind-mount\ndocker run -t -d  -v docker-bind-mount:/app/log  --name captain-america busybox\ndocker run -t -d  -v docker-bind-mount:/app/log  --name thor busybox\ndocker run -t -d  -v docker-bind-mount:/app/log  --name hulk  busybox\ndocker run -t -d  -v docker-bind-mount:/app/log  --name iron-man  alpine\n\n# --mount 옵션을 사용한 명령어\ndocker run -t -d --mount type=bind,source=docker-bind-mount,target=/app/log \\\n  --name captain-america busybox\n```\n\n<img src=\"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_25.png\" />\n\n<div class=\"content-ad\"></div>\n\n\n![image](/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_26.png)\n\n각 컨테이너 안에 저장된 로그를 작성해봅시다. 바인드-마운트가 연결된 경로인 /app/log에\n\n![image](/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_27.png)\n\n자세히 살펴보면, 1번째와 2번째 컨테이너에서 생성한 파일들이 3번째 컨테이너에서 보이며, 1번째에서 3번째 컨테이너에서 생성한 파일이 4번째(Captain-America) 컨테이너에서도 보인다는 점을 알 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n일반적으로 도커 데이터 파일에는 다른 컨테이너의 내용이 포함되어 있습니다.\n\n이 예시는 우리가 어떻게 간단하게 여러 컨테이너 간에 파일/로그를 공유할 수 있는지 보여줍니다.\n\n하지만, 한 가지 주의할 점이 있습니다. 만약 우리가 로컬 호스트로 이동하여 모든 컨테이너에 바인드 마운트한 디렉터리를 목록으로 보면 아무것도 찾을 수 없을 것입니다.\n\n이것은 즉, 도커가 바인드 마운트한 데이터를 다른 컨테이너와 공유할 수 있었지만 데이터가 로컬 호스트에서는 보이지 않는다는 것을 의미합니다.\n\n<div class=\"content-ad\"></div>\n\n이 파일들은 바인드 마운트 시 도커 컨테이너 간에 저장되고 공유됩니다.\n\n![Image](/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_28.png)\n\n도커 컨테이너 중 하나를 검사하고 마운트 섹션으로 이동하면 마운트에 관련된 세부 정보를 볼 수 있습니다.\n\n참고: 도커 inspect 명령은 도커 컨테이너에 대해 더 많은 정보를 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n# 도커 컨테이너 조회 명령어: docker inspect <컨테이너 이름 또는 컨테이너 ID>\ndocker inspect hulk\n```\n\n![도커 컨테이너 및 볼륨에 대한 자세한 정보](/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_29.png)\n\n# 예제: 볼륨을 사용하는 Docker 컨테이너\n\n볼륨 생성하기\n\n\n<div class=\"content-ad\"></div>\n\n```md\n# 도커 볼륨 생성하기\n도커 볼륨 생성 thor-vol\n도커 볼륨 생성 hulk-vol\n\n# 도커 볼륨 목록 확인\n도커 볼륨 목록 보기\n\n# 도커 볼륨   \n# 명령어:\n#  create      볼륨 생성\n#  inspect     한 개 이상의 볼륨에 대한 자세한 정보 표시\n#  ls          볼륨 목록 보기\n#  prune       사용하지 않는 로컬 볼륨 제거\n#  rm          한 개 이상의 볼륨 제거\n```\n\n<img src=\"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_30.png\" />\n\n볼륨 검사하기\n\n```md\n도커 볼륨 inspect thor-vol\n```\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_31.png)\n\n새 컨테이너를 생성하는 동안 이 볼륨을 마운트해 봅시다. 이번에는 — — mount 옵션을 사용할 거에요.\n\n```js\ndocker run -d \\\n  --name thor-container \\\n  --mount type=volume,source=thor-vol,target=/app \\\n  nginx:latest\n\n# 볼륨을 source로 명시할 때 type의 기본 값은 volume입니다.\ndocker run -d \\ \n  --name hulk-container \\\n  --mount source=thor-vol,target=/app \\\n  nginx:latest\n```\n\n```js\ndocker inspect hulk-container\n```   \n  \n\n<div class=\"content-ad\"></div>\n\n\n![Image 1](/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_32.png)\n\nLet’s create some logs in both containers and see if the files/logs are visible to both containers.\n\n![Image 2](/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_33.png)\n\nAs you can see from the above screenshot, we can share data/logs across containers.\n\n\n<div class=\"content-ad\"></div>\n\n# 도커 볼륨 삭제\n\n```js\n# 도커 볼륨을 제거하기\n# 한 번에 하나 이상의 볼륨을 삭제할 수 있습니다\ndocker volume rm <volume-names> \n```\n\n![이미지](/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_34.png)\n\n# 도커 이미지 빌드\n\n<div class=\"content-ad\"></div>\n\n이제 기본적인 도커 개념을 살펴 보았으니, 실습 예제를 해 봅시다.\n\n## 여기서 무엇을 할 건가요?\n\n도커 이미지를 만들어 기본적인 Flask 애플리케이션을 내장시킬 거에요. 그리고 만든 도커 이미지를 도커 허브에 푸시할 거에요.\n\n한 폴더를 만들고 app.py, requirements.txt, 그리고 Dockerfile 이라는 3개의 파일을 생성해 볼까요?\n\n<div class=\"content-ad\"></div>\n\n```js\nDockerfile, app.py, requirements.txt 파일들을 만들었습니다.\n\n<img src=\"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_35.png\" />\n\n각 파일에 아래 코드를 붙여 넣어주세요.\n\napp.py\n```\n\n<div class=\"content-ad\"></div>\n\n```python\nfrom flask import Flask\n\napp = Flask(__name__)\n\n@app.route('/')\ndef hello_docker():\n    return 'Hello, Docker!'\n\nif __name__ == '__main__':\n    app.run(debug=True, host='0.0.0.0')\n```\n\nrequirements.txt\n\n```python\nFlask\n```\n\n이제 Docker 이미지를 빌드하기 위한 Dockerfile을 생성할 것입니다.```\n\n<div class=\"content-ad\"></div>\n\nDockerfile\n\n```js\n# 부모 이미지로 공식 Python 실행 환경 사용\nFROM python:3.11\n\n# 작업 디렉토리를 /app으로 설정\nWORKDIR /app\n\n# Python 종속성 파일을 컨테이너의 /app 디렉토리로 복사\nCOPY requirements.txt /app\n\n# requirements.txt에 명시된 필요한 패키지 설치\nRUN pip install --no-cache-dir -r requirements.txt\n\n# flask 앱 파일을 컨테이너의 /app 디렉토리로 복사\nCOPY app.py /app\n\n# 포트 5000을 이 컨테이너 외부에 노출\nEXPOSE 5000\n\n# 컨테이너가 시작될 때 app.py 실행\nCMD [\"python\", \"app.py\"]\n```\n\n도커 이미지 생성\n\n```js\n# docker build -t <이미지-이름> <Dockerfile 경로>\ndocker build -t flask-image .\n```\n\n<div class=\"content-ad\"></div>\n\n아래는 Markdown 형식으로 변경되었습니다:\n\n\n![Docker Image](/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_36.png)\n\nDocker Hub repository를 만들어보겠습니다. 아직 계정이 없다면 만드세요 - livingdevopswithakhilesh라는 이름으로 만들었어요.\n\n![Image 태깅](/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_37.png)\n\n\n<div class=\"content-ad\"></div>\n\n```md\n# docker tag <local image> <docker hub username>/<repository name>:<tag>\ndocker tag flask-image livingdevopswithakhilesh/docker-demo-docker:1.0\n```\n\n![Image](/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_38.png)\n\n도커 허브에 이미지를 푸시하세요. 이미지를 푸시하기 전에 docker login을 실행해주세요.\n\n```sh\ndocker login\n# docker push <tagged-image>\ndocker push livingdevopswithakhilesh/docker-demo-docker:1.0\n```\n\n<div class=\"content-ad\"></div>\n\n![Image](/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_39.png)\n\n로컬 이미지를 삭제하고 Docker Hub에서 이미지를 가져와서 해당 이미지를 사용하여 컨테이너를 실행합니다.\n\n```js\ndocker pull livingdevopswithakhilesh/docker-demo-docker:1.0\n```\n\n![Image](/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_40.png)\n\n<div class=\"content-ad\"></div>\n\n```js\ndocker run -td -p 8080:5000 --name flask livingdevopswithakhilesh/docker-demo-docker:1.0\n```\n\n![Image](/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_41.png)\n\n이 블로그는 여기까지입니다. 다음 블로그에서 뵙겠습니다. 저와 함께 더 유용한 콘텐츠를 확인하려면 팔로우해주세요.\n\nLinkedin에서 연락하기: [https://www.linkedin.com/in/akhilesh-mishra-0ab886124/](https://www.linkedin.com/in/akhilesh-mishra-0ab886124/)\n\n<div class=\"content-ad\"></div>\n\n시리즈 Devops Zero to Hero의 세 번째 블로그였습니다. 첫 두 개 블로그를 확인해보세요 —","ogImage":{"url":"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_0.png"},"coverImage":"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_0.png","tag":["Tech"],"readingTime":16},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<h2>데브옵스 업무 흐름에서 도커 사용을 시작하는 완벽한 가이드</h2>\n<h3>이 블로그 포스트에서 무엇을 기대해야 하는가?</h3>\n<h3>왜 Docker를 사용해야 하는가?</h3>\n<p>20~30년 전으로 돌아가면, 하드웨어와 설치된 운영 체제(커널 및 UI)가 있었습니다. 어플리케이션을 실행하기 위해서 코드를 컴파일하고 모든 앱 의존성을 정렬해야 했습니다. 다른 어플리케이션이나 어플리케이션 작업량의 증가를 수용하기 위해 새 하드웨어를 구매하고 설치 및 구성해야 했습니다.</p>\n<p>가상화는 하드웨어와 운영 체제 사이에 추가 계층인 하이퍼바이저라는 것을 추가했습니다. 이를 통해 사용자들은 독립된 여러 애플리케이션을 실행하여 가상 머신을 자체 운영 체제와 함께 실행할 수 있었습니다.</p>\n<p>그럼에도 불구하고, 우리는 모든 가상 머신에 소프트웨어를 설치하고 종속성을 설정해주어야 했습니다. 애플리케이션이 휴대 가능하지 않았습니다. 일부 기기에서는 작동하지만 다른 기기에서는 작동하지 않았습니다.</p>\n<p><img src=\"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_0.png\" alt=\"이미지\"></p>\n<h1>도커란 무엇인가요?</h1>\n<p>도커는 마이크로서비스 기반 응용 프로그램 개발이 가능하도록 함으로써 소프트웨어 빌드 방법을 혁신했습니다.</p>\n<h1>도커는 어떻게 작동하나요?</h1>\n<p>도커 엔진은 호스트 운영 체제 위에서 실행됩니다. 도커 엔진에는 호스트 시스템에서 도커 컨테이너를 관리하는 서버 프로세스(dockerd)가 포함되어 있습니다. 도커 컨테이너는 응용 프로그램과 그 의존성을 격리시켜 다른 환경에서도 일관되게 실행할 수 있도록 설계되었습니다.</p>\n<p><img src=\"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_1.png\" alt=\"이미지\"></p>\n<p>도커를 사용하려면 Dockerfile, Docker 이미지, Docker 컨테이너라는 세 가지 개념을 이해해야 합니다.</p>\n<h2>Docker 파일(Dockerfile)이란?</h2>\n<h2>Docker 이미지란 무엇인가요?</h2>\n<p>Docker 이미지에는 컨테이너 내에서 코드를 실행하는 데 필요한 모든 종속성이 포함되어 있습니다.</p>\n<h2>Docker 컨테이너란 무엇인가요?</h2>\n<h1>Docker로 시작하기</h1>\n<h2>사전 요구 사항</h2>\n<p>Docker는 로컬 머신 또는 클라우드 VM에 설치되어 있어야 합니다.</p>\n<p>Linux:</p>\n<p>로컬 노트북, 가상 머신 또는 클라우드 VM에서 Linux를 실행 중이라면 패키지 관리자를 사용하여 Docker를 설치할 수 있습니다. 이 블로그 포스트의 지시사항을 따라주세요.</p>\n<p>Mac 및 Windows:</p>\n<p>로컬 머신에서 Docker를 실행할 수 있게 해주는 Docker Desktop을 설치할 수 있습니다.</p>\n<p>도커를 시작하는 것은 쉬운 일이에요. 아래 명령을 실행하기만 하면 돼요</p>\n<pre><code class=\"hljs language-js\">도커 런 -d -t --name <span class=\"hljs-title class_\">Thor</span> alpine\n도커 런 -d -t busybox\n</code></pre>\n<p>이 명령은 도커 이미지 alpine과 busybox로부터 2개의 컨테이너를 생성할 거에요. 이 둘은 도커 허브에 저장된 미니멀리스트이면서 퍼블릭인 리눅스 도커 이미지에요.</p>\n<ul>\n<li>-d 옵션은 컨테이너를 백그라운드에서 실행(detach mode)</li>\n<li>-t 옵션은 tty 터미널을 연결해 줘요.</li>\n<li>--name 옵션은 컨테이너에 이름을 부여할 수 있어요. 제공하지 않으면 컨테이너는 랜덤 이름을 받게 돼요</li>\n</ul>\n<p>참고: 위에 언급된 이미지로 처음 docker run을 실행하면 도커가 로컬 머신에서 이미지를 다운로드(풀)해야 합니다.</p>\n<h2>로컬 머신에서 실행 중인/중지된 컨테이너 목록</h2>\n<pre><code class=\"hljs language-js\">docker ps # 실행 중인 컨테이너 확인\ndocker ps -a # 모든 컨테이너 목록\n</code></pre>\n<h2>로컬 머신에 있는 도커 이미지 목록</h2>\n<pre><code class=\"hljs language-js\">docker image ls\n</code></pre>\n<p>Linux 기반 도커 컨테이너에 사용된 이미지 크기를 확인할 수 있어요. 우분투, 아마존 리눅스, CentOS 등과 같은 일반적인 Linux 기반 머신과 비교하면 작아요.</p>\n<p>실행 중인 컨테이너와 상호 작용하는 방법은 명령을 전달하거나 대화형 세션을 여는 두 가지 방법이 있어요.</p>\n<pre><code class=\"hljs language-js\"># docker exec -it &#x3C;컨테이너 <span class=\"hljs-variable constant_\">ID</span>> &#x3C;셸>\n</code></pre>\n<ul>\n<li>docker exec를 사용하면 실행 중인 도커 컨테이너 내부로 진입할 수 있어요.</li>\n<li>--it는 도커와 대화형 세션을 열어줘요.</li>\n<li>셸은 sh, bash, zsh 등을 사용할 수 있어요.</li>\n</ul>\n<p>컨테이너 정보를 얻기 위해 몇 가지 명령을 실행해 봅시다.</p>\n<pre><code class=\"hljs language-js\">docker exec -t <span class=\"hljs-title class_\">Thor</span> ls ; ps\n# -t는 tty 세션을 열기 위한 옵션입니다.\n# <span class=\"hljs-title class_\">Thor</span>는 컨테이너 이름입니다.\n# ls ; ps는 ls와 ps 두 개의 명령을 실행합니다.\n\ndocker exec -t 8ad10d1d0660 free -m \n# 8ad10d1d0660은 컨테이너 <span class=\"hljs-variable constant_\">ID</span>이며, free -m은 메모리 사용량을 확인하는 명령입니다.\n</code></pre>\n<p><img src=\"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_5.png\" alt=\"이미지\"></p>\n<p>이제 -it 옵션을 사용하여 컨테이너와 대화형 쉘 세션을 열어보겠습니다.</p>\n<pre><code class=\"hljs language-js\">도커 exec -it 16fb1c59fbea sh \n# 세션을 종료하려면 <span class=\"hljs-string\">\"exit\"</span>을 입력하세요\n</code></pre>\n<p><img src=\"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_6.png\" alt=\"이미지\"></p>\n<h1>컨테이너 시작, 중지, 삭제</h1>\n<pre><code class=\"hljs language-js\"># 실행 중인 컨테이너를 중지하는 방법\ndocker stop &#x3C;컨테이너 이름 또는 <span class=\"hljs-variable constant_\">ID</span>>\n\n# 중지된 컨테이너를 시작하는 방법\ndocker start &#x3C;컨테이너 이름 또는 <span class=\"hljs-variable constant_\">ID</span>>\n</code></pre>\n<p><img src=\"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_7.png\" alt=\"Image\"></p>\n<pre><code class=\"hljs language-js\"># 실행 중인 컨테이너를 종료한 후에 삭제하려면 다음과 같이 명령을 사용합니다.\n# docker stop &#x3C;컨테이너 이름 또는 <span class=\"hljs-variable constant_\">ID</span>>\n# docker rm &#x3C;컨테이너 이름 또는 <span class=\"hljs-variable constant_\">ID</span>>\ndocker stop 16fb1c59fbea\ndocker rm 16fb1c59fbea\n\n# 아니면 -f 플래그를 사용하여 강제로 컨테이너를 삭제합니다.\ndocker rm -f <span class=\"hljs-title class_\">Thor</span>\n</code></pre>\n<p><img src=\"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_8.png\" alt=\"Image\"></p>\n<h1>도커 이미지 빌드하기</h1>\n<h1>Docker 네트워킹</h1>\n<p>도커는 다양한 종류의 네트워크를 제공합니다.</p>\n<h2>1. 기본 브릿지</h2>\n<p>만약 도커허브에서 nginx 이미지를 사용하여 nginx 컨테이너를 실행 중이고 웹 서버에 액세스하려고 한다면요.</p>\n<p><img src=\"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_9.png\" alt=\"screenshot\"></p>\n<p>스크린샷을 통해 Nginx 웹 서버가 80번 포트에서 실행 중임을 확인할 수 있습니다. NGINX 컨테이너에 로그인하여 curl 127.0.0.1:80을 실행하면 웹 서버에서 HTML 응답을 반환합니다.</p>\n<ul>\n<li>127.0.0.1은 루프백 주소로 현재 장치(로컬호스트)를 항상 가리킵니다.</li>\n</ul>\n<p><img src=\"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_10.png\" alt=\"screenshot\"></p>\n<p>위에서 본 것처럼, 컨테이너 내부의 웹 서버가 우리가 기대한 대로 작동했습니다.</p>\n<p>이제 호스트 머신 (랩톱/가상 머신)에서 웹 서버에 연결해 보겠습니다.</p>\n<p><img src=\"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_11.png\" alt=\"이미지\"></p>\n<p>컨테이너에서 실행 중인 nginx 웹 서버에 연결할 수 없었습니다.</p>\n<p>네트워크 깊이 파고들기</p>\n<p>도커 컨테이너를 검사하려면 docker inspect 명령을 실행하고 맨 아래로 스크롤하면 도커가 브릿지 네트워크를 사용하고 네트워크에 대한 자세한 내용을 볼 수 있습니다.</p>\n<pre><code class=\"hljs language-js\">docker inspect nginx-container\n</code></pre>\n<pre><code class=\"hljs language-js\">도커 네트워크 목록\n</code></pre>\n<p>네트워크를 검사하면 기본 브릿지 네트워크를 사용하는 컨테이너를 찾을 수 있습니다.</p>\n<pre><code class=\"hljs language-js\">도커 네트워크 검사 브릿지\n</code></pre>\n<h2>포트 전달</h2>\n<pre><code class=\"hljs language-js\">도커 실행 -d -p &#x3C;호스트 포트>:&#x3C;컨테이너 포트> --name &#x3C;컨테이너 이름> 이미지\n\n# 포트 전달 -> 컨테이너의 포트 <span class=\"hljs-number\">80</span>을 호스트 머신의 포트 <span class=\"hljs-number\">5000</span>으로 전달\n도커 실행 -t -d -p <span class=\"hljs-number\">5000</span>:<span class=\"hljs-number\">80</span> --name nginx-container <span class=\"hljs-attr\">nginx</span>:latest\n</code></pre>\n<p><img src=\"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_16.png\" alt=\"\"></p>\n<p>도커는 기본 네트워크를 사용하지 말라고 권장하고 대신에 우리만의 네트워크를 생성하도록 하고 있습니다.</p>\n<p>busybox 이미지를 사용하여 2개의 컨테이너를 생성해 봅시다. 컨테이너를 실행한 후, 컨테이너 내부에서 서로 핑을 시도해 봅시다.</p>\n<p>2개의 컨테이너를 생성하고, 각 컨테이너의 IP 주소를 얻기 위해 docker inspect를 사용해 보세요.</p>\n<p>아래는 두 컨테이너의 IP 주소가 동일한 네트워크에 있음을 확인할 수 있습니다(기본 브리지 네트워크).</p>\n<p>이름과 IP 주소로 서로 핑을 보내 봅시다.</p>\n<p><img src=\"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_17.png\" alt=\"image1\"></p>\n<p><img src=\"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_18.png\" alt=\"image2\"></p>\n<p>위 스크린샷을 보면 두 컨테이너 모두 서로 통신할 수 있지만 이름으로는 연결할 수 없습니다.</p>\n<h2>2. 사용자 정의 브리지 네트워크</h2>\n<p>네트워크 생성</p>\n<pre><code class=\"hljs language-js\">docker network create blog-network\n</code></pre>\n<p>새로운 네트워크를 사용하여 이름이 nginx-con인 nginx 컨테이너를 만들어보세요.</p>\n<pre><code class=\"hljs language-bash\">docker run -itd --network blog-network --name nginx-con nginx\ndocker ps\n</code></pre>\n<p><img src=\"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_19.png\" alt=\"이미지\"></p>\n<p>도커 컨테이너와 네트워크를 검사해봅시다.</p>\n<pre><code class=\"hljs language-js\">도커 네트워크를 검사하는 방법: \n\n<span class=\"hljs-string\">``</span><span class=\"hljs-string\">`docker network inspect blog-network`</span><span class=\"hljs-string\">``</span>\n\n![사진](<span class=\"hljs-regexp\">/assets/img</span><span class=\"hljs-regexp\">/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_20.png)\n\nNginx 컨테이너를 검사하는 방법: \n\n```docker inspect nginx-con```\n\n![사진](/</span>assets/img/<span class=\"hljs-number\">2024</span>-<span class=\"hljs-number\">05</span>-<span class=\"hljs-number\">18</span>-<span class=\"hljs-title class_\">Devopszerotohero3EverythingyouneedtoknowaboutDockers</span>_21.<span class=\"hljs-property\">png</span>)\n</code></pre>\n<p>이제 호스트 포트를 통해 컨테이너에서 실행 중인 nginx 웹 서버에 액세스하려고 하면 작동하지 않을 것입니다. 여전히 컨테이너에서 실행 중인 웹 서버에 액세스하려면 호스트 포트로의 포트 포워딩을 수행해야 합니다.</p>\n<p>그러나 하나가 정리되었습니다 — 이름 해결입니다. 이제 사용자 정의 브리지 네트워크에서 컨테이너를 핑하면 작동해야 합니다.</p>\n<p>한 가지 busybox 컨테이너를 만들고 nginx-con 컨테이너를 핑해 보겠습니다.</p>\n<p><img src=\"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_22.png\" alt=\"이미지\"></p>\n<h2>3. 호스트 네트워크</h2>\n<pre><code class=\"hljs language-js\">docker run -td --network host --name nginx-server <span class=\"hljs-attr\">nginx</span>:latest\ndocker ps\n</code></pre>\n<p><img src=\"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_23.png\" alt=\"image\"></p>\n<p>이렇게 하면 nginx 컨테이너가 호스트 네트워크에서 실행됩니다.</p>\n<p>만약 로컬 호스트에서 nginx 서버에 접근하려고 하면, 작동해야 합니다.</p>\n<p>만약 컨테이너의 IP 주소를 확인하려면</p>\n<pre><code class=\"hljs language-js\">docker inspect nginx-server | grep <span class=\"hljs-title class_\">IPAddress</span>\n</code></pre>\n<p>아래 그림을 참고하세요:</p>\n<p><img src=\"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_24.png\" alt=\"이미지\"></p>\n<p>뭐라구요? 해당 IP 주소가 없나봐요. 호스트 머신의 IP 주소를 사용한 모양이에요.</p>\n<p>다른 종류의 네트워크에 대해 더 알려드릴게요. 하지만 블로그가 너무 길어지고 있네요.</p>\n<h1>도커 볼륨</h1>\n<p>도커는 로컬 파일 시스템에서 컨테이너의 모든 콘텐츠, 코드 및 데이터를 분리합니다. 이는 도커 데스크탑에서 컨테이너를 삭제하면 그 안의 모든 콘텐츠가 삭제된다는 뜻이에요.</p>\n<p>가끔은 컨테이너가 생성한 데이터를 유지하기를 원할 수 있습니다. 이때 볼륨을 사용할 수 있습니다.</p>\n<h2>바인드 마운트</h2>\n<p>바인드 마운트를 사용하면 호스트 머신의 파일 또는 디렉토리가 컨테이너로 마운트됩니다.</p>\n<h2>도커 볼륨</h2>\n<p>체적은 도커에서 관리하는 로컬 파일 시스템의 위치입니다.</p>\n<p>체적은 사용 중인 컨테이너의 크기를 늘리지 않으며, 체적의 내용은 특정 컨테이너의 생명 주기 외부에 존재합니다.</p>\n<h1>도커에서 체적 사용하는 방법</h1>\n<p>도커에서 체적을 사용하는 방법에는 --mount 및 -v (또는 --volume ) 두 가지가 있습니다. -v 구문은 모든 옵션을 하나의 필드에 결합하며, --mount 구문은 옵션을 분리합니다.</p>\n<ul>\n<li>\n<p>-v 또는 --volume: 콜론 문자(:)로 구분된 세 개의 필드로 구성됩니다.</p>\n<ul>\n<li>첫 번째 필드는 바인드 마운트의 경우 호스트 머신의 파일 또는 디렉터리 경로이거나 볼륨의 이름입니다.</li>\n<li>두 번째 필드는 컨테이너 내에서 파일 또는 디렉터리가 마운트된 경로입니다.</li>\n<li>세 번째 필드는 선택 사항입니다. ro, z, Z와 같은 옵션들의 쉼표로 구분된 목록입니다.</li>\n</ul>\n</li>\n</ul>\n<p>--mount: 쉼표로 구분된 여러 개의 키-값 페어로 구성됩니다.</p>\n<ul>\n<li>마운트의 유형(bind, volume 또는 tmpfs).</li>\n<li>마운트의 소스.</li>\n<li>목적지는 파일 또는 디렉터리가 컨테이너 내에서 마운트된 경로로 값을 취합니다.</li>\n</ul>\n<h1>예시: Docker 컨테이너와 바인드 마운트</h1>\n<p>우리는 호스트 머신의 동일한 디렉토리/폴더를 4개의 컨테이너에 마운트했습니다.</p>\n<pre><code class=\"hljs language-js\">mkdir docker-bind-mount\ndocker run -t -d  -v docker-bind-<span class=\"hljs-attr\">mount</span>:<span class=\"hljs-regexp\">/app/</span>log  --name captain-america busybox\ndocker run -t -d  -v docker-bind-<span class=\"hljs-attr\">mount</span>:<span class=\"hljs-regexp\">/app/</span>log  --name thor busybox\ndocker run -t -d  -v docker-bind-<span class=\"hljs-attr\">mount</span>:<span class=\"hljs-regexp\">/app/</span>log  --name hulk  busybox\ndocker run -t -d  -v docker-bind-<span class=\"hljs-attr\">mount</span>:<span class=\"hljs-regexp\">/app/</span>log  --name iron-man  alpine\n\n# --mount 옵션을 사용한 명령어\ndocker run -t -d --mount type=bind,source=docker-bind-mount,target=<span class=\"hljs-regexp\">/app/</span>log \\\n  --name captain-america busybox\n</code></pre>\n<p><img src=\"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_26.png\" alt=\"image\"></p>\n<p>각 컨테이너 안에 저장된 로그를 작성해봅시다. 바인드-마운트가 연결된 경로인 /app/log에</p>\n<p><img src=\"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_27.png\" alt=\"image\"></p>\n<p>자세히 살펴보면, 1번째와 2번째 컨테이너에서 생성한 파일들이 3번째 컨테이너에서 보이며, 1번째에서 3번째 컨테이너에서 생성한 파일이 4번째(Captain-America) 컨테이너에서도 보인다는 점을 알 수 있습니다.</p>\n<p>일반적으로 도커 데이터 파일에는 다른 컨테이너의 내용이 포함되어 있습니다.</p>\n<p>이 예시는 우리가 어떻게 간단하게 여러 컨테이너 간에 파일/로그를 공유할 수 있는지 보여줍니다.</p>\n<p>하지만, 한 가지 주의할 점이 있습니다. 만약 우리가 로컬 호스트로 이동하여 모든 컨테이너에 바인드 마운트한 디렉터리를 목록으로 보면 아무것도 찾을 수 없을 것입니다.</p>\n<p>이것은 즉, 도커가 바인드 마운트한 데이터를 다른 컨테이너와 공유할 수 있었지만 데이터가 로컬 호스트에서는 보이지 않는다는 것을 의미합니다.</p>\n<p>이 파일들은 바인드 마운트 시 도커 컨테이너 간에 저장되고 공유됩니다.</p>\n<p><img src=\"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_28.png\" alt=\"Image\"></p>\n<p>도커 컨테이너 중 하나를 검사하고 마운트 섹션으로 이동하면 마운트에 관련된 세부 정보를 볼 수 있습니다.</p>\n<p>참고: 도커 inspect 명령은 도커 컨테이너에 대해 더 많은 정보를 제공합니다.</p>\n<pre><code class=\"hljs language-js\"># 도커 컨테이너 조회 명령어: docker inspect &#x3C;컨테이너 이름 또는 컨테이너 <span class=\"hljs-variable constant_\">ID</span>>\ndocker inspect hulk\n</code></pre>\n<p><img src=\"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_29.png\" alt=\"도커 컨테이너 및 볼륨에 대한 자세한 정보\"></p>\n<h1>예제: 볼륨을 사용하는 Docker 컨테이너</h1>\n<p>볼륨 생성하기</p>\n<pre><code class=\"hljs language-md\"><span class=\"hljs-section\"># 도커 볼륨 생성하기</span>\n도커 볼륨 생성 thor-vol\n도커 볼륨 생성 hulk-vol\n\n<span class=\"hljs-section\"># 도커 볼륨 목록 확인</span>\n도커 볼륨 목록 보기\n\n<span class=\"hljs-section\"># 도커 볼륨   </span>\n<span class=\"hljs-section\"># 명령어:</span>\n<span class=\"hljs-section\">#  create      볼륨 생성</span>\n<span class=\"hljs-section\">#  inspect     한 개 이상의 볼륨에 대한 자세한 정보 표시</span>\n<span class=\"hljs-section\">#  ls          볼륨 목록 보기</span>\n<span class=\"hljs-section\">#  prune       사용하지 않는 로컬 볼륨 제거</span>\n<span class=\"hljs-section\">#  rm          한 개 이상의 볼륨 제거</span>\n</code></pre>\n<p>볼륨 검사하기</p>\n<pre><code class=\"hljs language-md\">도커 볼륨 inspect thor-vol\n</code></pre>\n<p><img src=\"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_31.png\" alt=\"이미지\"></p>\n<p>새 컨테이너를 생성하는 동안 이 볼륨을 마운트해 봅시다. 이번에는 — — mount 옵션을 사용할 거에요.</p>\n<pre><code class=\"hljs language-js\">docker run -d \\\n  --name thor-container \\\n  --mount type=volume,source=thor-vol,target=/app \\\n  <span class=\"hljs-attr\">nginx</span>:latest\n\n# 볼륨을 source로 명시할 때 type의 기본 값은 volume입니다.\ndocker run -d \\ \n  --name hulk-container \\\n  --mount source=thor-vol,target=/app \\\n  <span class=\"hljs-attr\">nginx</span>:latest\n</code></pre>\n<pre><code class=\"hljs language-js\">docker inspect hulk-container\n</code></pre>\n<p><img src=\"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_32.png\" alt=\"Image 1\"></p>\n<p>Let’s create some logs in both containers and see if the files/logs are visible to both containers.</p>\n<p><img src=\"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_33.png\" alt=\"Image 2\"></p>\n<p>As you can see from the above screenshot, we can share data/logs across containers.</p>\n<h1>도커 볼륨 삭제</h1>\n<pre><code class=\"hljs language-js\"># 도커 볼륨을 제거하기\n# 한 번에 하나 이상의 볼륨을 삭제할 수 있습니다\ndocker volume rm &#x3C;volume-names> \n</code></pre>\n<p><img src=\"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_34.png\" alt=\"이미지\"></p>\n<h1>도커 이미지 빌드</h1>\n<p>이제 기본적인 도커 개념을 살펴 보았으니, 실습 예제를 해 봅시다.</p>\n<h2>여기서 무엇을 할 건가요?</h2>\n<p>도커 이미지를 만들어 기본적인 Flask 애플리케이션을 내장시킬 거에요. 그리고 만든 도커 이미지를 도커 허브에 푸시할 거에요.</p>\n<p>한 폴더를 만들고 app.py, requirements.txt, 그리고 Dockerfile 이라는 3개의 파일을 생성해 볼까요?</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title class_\">Dockerfile</span>, app.<span class=\"hljs-property\">py</span>, requirements.<span class=\"hljs-property\">txt</span> 파일들을 만들었습니다.\n\n&#x3C;img src=<span class=\"hljs-string\">\"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_35.png\"</span> />\n\n각 파일에 아래 코드를 붙여 넣어주세요.\n\napp.<span class=\"hljs-property\">py</span>\n</code></pre>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">from</span> flask <span class=\"hljs-keyword\">import</span> Flask\n\napp = Flask(__name__)\n\n<span class=\"hljs-meta\">@app.route(<span class=\"hljs-params\"><span class=\"hljs-string\">'/'</span></span>)</span>\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">hello_docker</span>():\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">'Hello, Docker!'</span>\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n    app.run(debug=<span class=\"hljs-literal\">True</span>, host=<span class=\"hljs-string\">'0.0.0.0'</span>)\n</code></pre>\n<p>requirements.txt</p>\n<pre><code class=\"hljs language-python\">Flask\n</code></pre>\n<p>이제 Docker 이미지를 빌드하기 위한 Dockerfile을 생성할 것입니다.```</p>\n<p>Dockerfile</p>\n<pre><code class=\"hljs language-js\"># 부모 이미지로 공식 <span class=\"hljs-title class_\">Python</span> 실행 환경 사용\n<span class=\"hljs-variable constant_\">FROM</span> <span class=\"hljs-attr\">python</span>:<span class=\"hljs-number\">3.11</span>\n\n# 작업 디렉토리를 /app으로 설정\n<span class=\"hljs-variable constant_\">WORKDIR</span> /app\n\n# <span class=\"hljs-title class_\">Python</span> 종속성 파일을 컨테이너의 /app 디렉토리로 복사\n<span class=\"hljs-variable constant_\">COPY</span> requirements.<span class=\"hljs-property\">txt</span> /app\n\n# requirements.<span class=\"hljs-property\">txt</span>에 명시된 필요한 패키지 설치\n<span class=\"hljs-variable constant_\">RUN</span> pip install --no-cache-dir -r requirements.<span class=\"hljs-property\">txt</span>\n\n# flask 앱 파일을 컨테이너의 /app 디렉토리로 복사\n<span class=\"hljs-variable constant_\">COPY</span> app.<span class=\"hljs-property\">py</span> /app\n\n# 포트 <span class=\"hljs-number\">5000</span>을 이 컨테이너 외부에 노출\n<span class=\"hljs-variable constant_\">EXPOSE</span> <span class=\"hljs-number\">5000</span>\n\n# 컨테이너가 시작될 때 app.<span class=\"hljs-property\">py</span> 실행\n<span class=\"hljs-variable constant_\">CMD</span> [<span class=\"hljs-string\">\"python\"</span>, <span class=\"hljs-string\">\"app.py\"</span>]\n</code></pre>\n<p>도커 이미지 생성</p>\n<pre><code class=\"hljs language-js\"># docker build -t &#x3C;이미지-이름> <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">Dockerfile</span> <span class=\"hljs-attr\">경로</span>></span>\ndocker build -t flask-image .\n</span></code></pre>\n<p>아래는 Markdown 형식으로 변경되었습니다:</p>\n<p><img src=\"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_36.png\" alt=\"Docker Image\"></p>\n<p>Docker Hub repository를 만들어보겠습니다. 아직 계정이 없다면 만드세요 - livingdevopswithakhilesh라는 이름으로 만들었어요.</p>\n<p><img src=\"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_37.png\" alt=\"Image 태깅\"></p>\n<pre><code class=\"hljs language-md\"><span class=\"hljs-section\"># docker tag <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">local</span> <span class=\"hljs-attr\">image</span>></span></span> <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">docker</span> <span class=\"hljs-attr\">hub</span> <span class=\"hljs-attr\">username</span>></span></span>/<span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">repository</span> <span class=\"hljs-attr\">name</span>></span></span>:<span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">tag</span>></span></span></span>\ndocker tag flask-image livingdevopswithakhilesh/docker-demo-docker:1.0\n</code></pre>\n<p><img src=\"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_38.png\" alt=\"Image\"></p>\n<p>도커 허브에 이미지를 푸시하세요. 이미지를 푸시하기 전에 docker login을 실행해주세요.</p>\n<pre><code class=\"hljs language-sh\">docker login\n<span class=\"hljs-comment\"># docker push &#x3C;tagged-image></span>\ndocker push livingdevopswithakhilesh/docker-demo-docker:1.0\n</code></pre>\n<p><img src=\"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_39.png\" alt=\"Image\"></p>\n<p>로컬 이미지를 삭제하고 Docker Hub에서 이미지를 가져와서 해당 이미지를 사용하여 컨테이너를 실행합니다.</p>\n<pre><code class=\"hljs language-js\">docker pull livingdevopswithakhilesh/docker-demo-<span class=\"hljs-attr\">docker</span>:<span class=\"hljs-number\">1.0</span>\n</code></pre>\n<p><img src=\"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_40.png\" alt=\"Image\"></p>\n<pre><code class=\"hljs language-js\">docker run -td -p <span class=\"hljs-number\">8080</span>:<span class=\"hljs-number\">5000</span> --name flask livingdevopswithakhilesh/docker-demo-<span class=\"hljs-attr\">docker</span>:<span class=\"hljs-number\">1.0</span>\n</code></pre>\n<p><img src=\"/assets/img/2024-05-18-Devopszerotohero3EverythingyouneedtoknowaboutDockers_41.png\" alt=\"Image\"></p>\n<p>이 블로그는 여기까지입니다. 다음 블로그에서 뵙겠습니다. 저와 함께 더 유용한 콘텐츠를 확인하려면 팔로우해주세요.</p>\n<p>Linkedin에서 연락하기: <a href=\"https://www.linkedin.com/in/akhilesh-mishra-0ab886124/\" rel=\"nofollow\" target=\"_blank\">https://www.linkedin.com/in/akhilesh-mishra-0ab886124/</a></p>\n<p>시리즈 Devops Zero to Hero의 세 번째 블로그였습니다. 첫 두 개 블로그를 확인해보세요 —</p>\n</body>\n</html>\n"},"__N_SSG":true}