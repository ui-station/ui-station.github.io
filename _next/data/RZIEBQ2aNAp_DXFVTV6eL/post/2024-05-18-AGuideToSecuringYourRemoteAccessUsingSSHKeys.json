{"pageProps":{"post":{"title":"원격 액세스 보안하는 방법 SSH 키 사용 안내","description":"","date":"2024-05-18 17:32","slug":"2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys","content":"\n\nSSH 키 기반 인증을 사용하여 SSH 연결을 안전하게 하는 단계별 가이드\n\n![SSH Key-Based Authentication](/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_0.png)\n\n오늘의 글은 SSH 원격 세션의 보안을 강화하는 간단한 자습서를 제공합니다. Linux 서버에 SSH 키 기반 인증을 설정하는 방법에 중점을 두고 덜 안전한 암호 기반 인증에서 전환하는 방법을 안내합니다. 마지막으로 SSH 서버를 더 안전하게 하는 추가 방법에 대한 보너스 팁을 공유할 것입니다.\n\n# 개요\n\n<div class=\"content-ad\"></div>\n\nSSH (Secure Shell) 키 기반 인증은 원격 서버에서 사용자의 신원을 인증하기 위해 암호화 키 쌍을 사용하는 보안 방법입니다. 이 방법은 컴퓨터에 공개 및 비밀 키 쌍을 생성하여 저장하고, SSH 서버를 구성하여 이러한 키를 인식하고 수락하도록 설정하는 것을 포함합니다. 이는 기존 암호 기반 인증과 관련된 위험을 줄이는 것으로 보안을 크게 향상시킵니다.\n\nSSH 키는 쌍으로 생성되고 일반 텍스트 파일로 저장됩니다. 키 쌍은 두 부분으로 구성됩니다:\n\n- 🔒 공개 키: 이 부분은 SSH 서버에 저장됩니다. 안전하게 공유할 수 있어 해당 서버가 연결할 때 신원을 인식할 수 있습니다.\n- 🔑 비밀 키: 이 부분은 사용자의 컴퓨터에 저장되어야 하며 항상 안전하게 보관되어야 합니다. 이를 사용하여 서버와 인증하며, 절대로 공유해서는 안 됩니다. 비밀 키는 파일을 읽을 수 없도록 사용 권한을 설정해야 합니다.\n\n## 작동 방식\n\n<div class=\"content-ad\"></div>\n\n- 컴퓨터에서 공개 및 개인 키 쌍을 생성합니다.\n- 서버는 공개 키를 인식하고 해당하는 개인 키가 인증 중에 사용되면 액세스를 허용하도록 구성됩니다.\n- 선택적으로 개인 키에 암호를 설정하여 추가 보안을 제공할 수 있습니다. 이 암호는 잘못된 손에 키가 넘어갈 경우 추가 보호층을 제공합니다.\n\n# SSH 키를 사용한 인증의 장점\n\nSSH 키 기반 인증은 비밀번호보다 더 나은 대안이므로 보안성과 편리성이 강화됩니다. 이렇게 왜 SSH 키를 사용해야 하는지 살펴보겠습니다:\n\n- 향상된 보안: 키가 고유하고 추측하기 어려우므로 키 기반 인증은 브루트 포스 공격에 저항합니다.\n- 자격 증명 노출 위험 감소: 서버가 침해당한 경우 권한 부여 자격 증명이 노출되는 위험이 없습니다.\n- 사용의 용이성: 사용자들은 복잡한 암호를 기억하거나 적어두지 않아도 되므로, 암호 관련 위반 사례의 위험이 줄어듭니다.\n- 자동화 지원: 암호 입력이 필요하지 않기 때문에 작업을 자동화할 수 있으며, 수동 개입 없이 Ansible과 같은 스크립트 및 도구가 SSH 서버와 상호작용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# SSH를 위한 공개 키 인증 설정하기\n\n기본 사항을 다뤘으니, 이 작업을 완료하는 단계에 대해 자세히 살펴보겠습니다.\n\nSSH 키 쌍을 만드는 두 가지 옵션이 있습니다: Windows 기계 또는 Linux 기계에서. 단계는 일반적으로 비슷하지만, 각 환경에서 사용하는 소프트웨어 도구는 다릅니다.\n\n## 방법 1: Linux에서 SSH 키 쌍 생성하기\n\n<div class=\"content-ad\"></div>\n\n스텝 1: Ed25519 알고리즘을 사용하여 새 SSH 키 쌍을 생성하세요.\n\n이 단계는 키페어를 로컬 컴퓨터에서 생성한 후에 나중에 서버로 업로드할 것으로 가정합니다. 서버에서 키페어를 생성하고 개인 키를 로컬 호스트로 다운로드하는 것보다 안전합니다.\n\nEd25519 알고리즘을 사용하여 새 키 쌍을 생성하세요:\n\n```js\nssh-keygen -t ed25519 -C \"cybersecmav@warfare.systems\"\n```\n\n<div class=\"content-ad\"></div>\n\n- -t: 알고리즘의 종류 (키), 우리의 경우 Ed25519.\n- -C: SSH 키를 구분할 수 있도록 도와주는 설명 (선택 사항).\n\n파일 이름을 요구하면 기본 이름과 경로를 수락하려면 Enter 키를 누르세요. SSH 키는 일반적으로 ~/.ssh/ 디렉터리에 저장됩니다.\n\n![이미지](/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_1.png)\n\n단계 2: 원격 서버 준비하기\n\n<div class=\"content-ad\"></div>\n\n만약 ~/.ssh 디렉토리와 authorized_keys 파일이 존재하지 않는다면 다음을 실행해주세요:\n\n```js\nmkdir ~/.ssh\ntouch ~/.ssh/authorized_keys\n```\n\n~/.ssh 디렉토리에 위치한 authorized_keys 파일은 SSH 서버에 액세스할 수 있는 공개 키 목록을 포함하고 있습니다.\n\n~/.ssh 디렉토리와 authorized_keys 파일에 적절한 파일 권한을 설정해주세요:\n\n<div class=\"content-ad\"></div>\n\n```js\nchmod 700 ~/.ssh\nchmod 600 ~/.ssh/authorized_keys\n```\n\n- chmod 700 ~/.ssh: 해당 디렉토리의 파일을 읽기, 쓰기, 실행할 수 있는 권한을 소유자에게만 부여합니다.\n- chmod 600 ~/.ssh/authorized_keys: 소유자에게만 파일에 액세스할 수 있도록 제약을 두어 다른 사람이 파일을 보거나 수정하는 것을 방지하여 SSH 키를 보호합니다.\n\n로컬 머신에서 공개 키를 원격 서버로 업로드하세요:\n\n```js\nscp id_ed2551.pub cybersecmav@warfare.systems:/home/cybersecmav/id_ed2551.pub\n```  \n\n<div class=\"content-ad\"></div>\n\n아래와 같이 업로드한 공개 키를 .ssh/ 디렉터리로 이동해 주세요:\n\n```js\nmv id_ed2551.pub ~/.ssh/\nchmod 600 ~/.ssh/id_ed2551.pub\n```\n\n공개 키의 출력을 authorized_keys 파일로 복사해 주세요:\n\n```js\ncat ~/.ssh/id_ed2551.pub >> ~/.ssh/authorized_keys\n```\n\n<div class=\"content-ad\"></div>\n\nauthorized_keys의 내용을 확인하여 공개 키가 추가되었는지 확인해보세요:\n\n```js\ncat .ssh/authorized_keys\nssh-ed25519 AAA<<...REDACTED......>>1uEqXysh cybersecmav@warfare.systems\n```\n\n모든 올바른 폴더 및 파일 권한이 있는지 확인해봅시다:\n\n```js\ncybersecmav@ares:~$ cd .ssh\ncybersecmav@ares:~/.ssh$ ls -la\ntotal 16\ndrwx------ 2 cybersecmav cybersecmav 4096 Apr 26 14:32 .\ndrwxr-xr-x 5 cybersecmav cybersecmav 4096 Apr 29 13:32 ..\n-rw------- 1 cybersecmav cybersecmav  109 Apr 26 14:33 authorized_keys\n-rw-r--r-- 1 cybersecmav cybersecmav  109 Apr 23 19:49 id_ed2551.pub\n```\n\n<div class=\"content-ad\"></div>\n\nStep 3: 공개 키 인증을 지원하도록 SSH 서버 구성하기\n\n편집을 위해 SSH 서버 구성 파일을 엽니다:\n\n```js\nsudo nano /etc/ssh/sshd_config\n```\n\nPubkeyAuthentication 설정을 찾아서 아래로 스크롤합니다. \"no\"에서 \"yes\"로 변경하세요. 또한, AuthorizedKeysFile로 시작하는 줄이 주석 처리되어 있지 않은지 확인하거나 누락된 경우 추가하세요.\n\n<div class=\"content-ad\"></div>\n\n```plaintext\nPubkeyAuthentication yes\nAuthorizedKeysFile .ssh/authorized_keys .ssh/authorized_keys2\n```\n\n다음은 /etc/sshd_config 파일이 보이는 방식입니다:\n\n![2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_2.png](/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_2.png)\n\n4단계: 구성 변경을 적용하기 위해 SSH 서버를 다시로드하세요\n\n\n<div class=\"content-ad\"></div>\n\nsshd_config 파일을 변경할 때는 변경 사항이 적용되려면 SSH 서버를 다시로드하거나 다시 시작해야 합니다.\n\nDebian/Ubuntu:\n\n```js\nsudo systemctl reload ssh\nsudo systemctl restart ssh\n```\n\nRedhat/CentOS:\n\n<div class=\"content-ad\"></div>\n\n```js\nsudo systemctl reload sshd\nsudo systemctl restart sshd\n```\n\n## 방법 2: Windows에서 SSH 키 쌍 생성\n\n로컬 머신으로 Windows를 사용하고 있다면, PuTTY 클라이언트의 키 생성기인 puttygen.exe를 사용하여 SSH 키 쌍을 생성할 수 있습니다.\n\n- 다음 위치에서 PuTTY를 다운로드하세요: https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html\n- puttygen.exe를 엽니다. 기본적으로 RSA를 키 생성으로 선택하지만, 원격 SSH 서버가 지원하는 경우 ED25519를 선택할 수도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_3.png\" />\n\n- \"Generate\"를 클릭하여 새로운 공개/개인 키 쌍을 생성합니다.\n\n<img src=\"/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_4.png\" />\n\n- 나중에 원격 서버의 ~/.ssh/ 디렉토리의 authorized_keys 파일에 붙여 넣을 공개 키를 복사합니다.\n\n<div class=\"content-ad\"></div>\n\n\n![image](/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_5.png)\n\n- Save the public key as: id_ed2551.pub\n- Save the private key as: id_ed2551.ppk\n\n![image](/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_6.png)\n\n- Alternatively, you can save them using the File menu option\n\n\n<div class=\"content-ad\"></div>\n\n\n![Save and keep a copy of your SSH keys](/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_7.png)\n\n![SSH key image 2](/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_8.png)\n\n![SSH key image 3](/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_9.png)\n\n\n<div class=\"content-ad\"></div>\n\n- `/home/username/.ssh/authorized_keys` 파일에 공개 키 값을 새 줄에 붙여 넣으세요.\n\n![Step 10](/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_10.png)\n\n- 윈도우즈에서 PuTTY SSH 클라이언트를 사용하여 키 기반 인증을 통한 원격 호스트로의 SSH 연결을 테스트합니다.\n- putty.exe 클라이언트를 열고 원격 SSH 서버 세부 정보를 입력하세요.\n\n![Step 11](/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_11.png)\n\n<div class=\"content-ad\"></div>\n\n- 지금 가장 중요한 단계는 리모트 서버에 연결하기 전에 방금 생성한 올바른 개인 키를 선택했는지 확인하는 것입니다.\n\n![SSH Key](/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_12.png)\n\n- \"Open\"을 클릭하면 원격 대상과의 SSH 세션이 열립니다.\n\n- 이제 새로운 공개/개인 키 쌍을 사용하여 인증된 SSH 세션이 열려 있어야 합니다. 아래 예시를 확인해주세요.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_13.png\" />\n\n이제 SSH 키 기반 인증으로 로그인되었습니다.\n\n# 추가 정보: SSH 서버 보안 팁\n\nSSH 키 기반 인증의 기본 사항을 다룬 이제, SSH 서버를 보다 더 보호하기 위한 몇 가지 추가 보안 팁을 살펴봅시다. 이러한 모범 사례를 시행함으로써 SSH 서버의 보안성을 높일 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 팁 1: 비밀번호 인증 비활성화\n\nSSH 키 기반 인증이 작동하는지 확인한 후, SSH 구성 파일인 /etc/ssh/sshd_config에서 PasswordAuthentication을 \"no\"로 설정하여 비밀번호 기반 로그인을 비활성화하세요.\n\n```sh\nsudo nano /etc/ssh/sshd_config\n``` \n\n![이미지](/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_14.png)\n\n<div class=\"content-ad\"></div>\n\n## 팁 2: 루트 로그인 제한\n\nSSH를 통한 직접적인 루트 액세스를 방지하려면 PermitRootLogin을 \"no\"로 설정하세요. 이렇게 하면 사용자가 루트 계정으로 로그인하는 것이 불가능해지며 관리 작업을 위해 sudo를 사용해야 합니다.\n\n![이미지](/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_15.png)\n\n## 팁 3: 비표준 SSH 포트 사용\n\n<div class=\"content-ad\"></div>\n\n기본 SSH 포트를 22에서 더 높거나 보통과 다른 숫자로 변경하면 무분별한 자동 스캔 및 브루트포스 공격이 더 어려워질 수 있습니다. 이는 위협의 대부분을 이루는 것입니다. 그러나 SSH 서버를 모든 공격으로부터 완전히 보호하는 것은 아니라는 것을 명심하세요. 결정적인 해커는 여전히 SSH 포트를 찾아내고 대상으로 삼을 수 있습니다.\n\n![Image](/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_16.png)\n\n## 팁 4: SSH 로깅 및 모니터링 활성화\n\nSSH 로깅이 활성화되어 있어야 연결 시도를 추적하고 이상한 활동을 감지할 수 있습니다. 무단 액세스나 브루트포스 공격의 징후를 탐지하기 위해 로그를 정기적으로 모니터링하세요.\n\n<div class=\"content-ad\"></div>\n\n대부분의 시스템에서 SSH 로깅은 기본적으로 활성화되어 있습니다. 그러나 SSH 설정 파일 /etc/ssh/sshd_config을 확인하여 비활성화되어 있지 않은지 확인해보세요.\n\n단계 1: SSH 서비스 구성 파일에서 SSH 로깅 활성화하기\n\nSyslogFacility를 \"AUTH\"로 설정하고 LogLevel은 \"INFO\"로 설정하세요.\n\n![이미지](/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_17.png)\n\n<div class=\"content-ad\"></div>\n\n다른 로그 레벨을 탐색하려면 아래 섹션을 참조하세요. Verbose 및 Debug는 많은 로그를 생성하므로 진단 또는 디버깅에만 유용하기 때문에 권하지 않습니다.\n\nSSH 로그 레벨\n\n- QUIET: 거의 아무것도 로그하지 않아 최소한의 출력을 제공합니다.\n- FATAL: SSH 서버 작동을 중지하는 중요한 오류만 로그합니다.\n- ERROR: 중요한 문제 및 심각한 오류를 로그합니다.\n- INFO: 기본 레벨로, SSH 작업에 대한 일반 정보를 로깅합니다.\n- VERBOSE: SSH 프로세스에 대한 자세한 정보를 로그하며, 문제 해결에 유용합니다.\n- DEBUG: 디버깅을 위한 방대한 로그를 생성하며, 일반적으로 일상적으로 사용하지 않습니다.\n\n단계 2: 로그 저장소 구성\n\n<div class=\"content-ad\"></div>\n\n보통 SSH 로그는 /var/log/auth.log (Debian/Ubuntu) 또는 /var/log/secure (Red Hat/CentOS)에 저장됩니다.\n\n```js\n$ ls -la /var/log/auth.log\n-rw-r----- 1 root adm 292525 May 4 10:18 /var/log/auth.log\n```\n\n이 파일들이 존재하고 접근 가능한지 확인하세요. 소유자가 root로 설정되어 있고 파일 권한이 로그 파일을 안전하게 보호하기 위해 적절하게 설정되었는지 확인하세요.\n\n```js\nchmod 640 /var/log/auth.log\n```\n\n<div class=\"content-ad\"></div>\n\n## 팁 5: 침입 탐지 (Fail2ban) 구현하기\n\nFail2Ban은 로그인 시도를 모니터링하고 많은 실패한 시도 후 IP 주소를 차단하여 SSH 서버를 보호할 수 있습니다. 이는 브루트포스 공격의 일반적인 징후입니다. 설치한 후에는 SSH 로그를 주시하도록 설정하고 의심스러운 IP를 차단할 규칙을 구성하세요. SSH 서버의 보안에 추가적인 방어층을 더하는 효과적인 방법입니다.\n\nFail2Ban을 설정하고 구성하는 것은 이 글의 범위를 벗어납니다. 그러나 추가 보안을 위해 서버에 설치하는 것을 적극 추천합니다.\n\n# 결론\n\n<div class=\"content-ad\"></div>\n\n이 기사에서는 SSH 키 기반 인증의 혜택을 다루었는데, 이를 통해 보안을 강화하고 브루트포스 공격의 위험을 줄일 수 있다는 점을 강조했습니다. SSH 키를 생성하고 서버에 구성하는 방법을 안내하며 적절한 보안을 유지하는 방법을 보여드렸습니다. 또한 SSH 서버를 안전하게 유지하기 위한 추가 팁을 살펴봤는데, 이에는 기본 포트 변경, Fail2Ban 구현, 그리고 철저한 SSH 로깅 및 모니터링 활성화가 포함되었습니다.\n\n전체적으로 SSH 키 기반 인증은 원격 액세스를 보다 안전하고 편리하게 관리하는 방법을 제공합니다. 패스워드 기반 로그인의 효과적인 대체제로서, 미인가된 액세스 가능성을 줄이고 보안을 희생하지 않고 자동화가 가능합니다.\n\n권장 사항으로는 개인 키에 항상 암호를 설정하고, 이상한 활동을 정기적으로 모니터링하며, 키 기반 설정에 확신을 갖게 되면 패스워드 인증을 비활성화하는 것을 고려해야 합니다. Fail2Ban을 구현하면 브루트포스 공격의 징후를 보이는 IP 주소를 차단하여 자동화된 보호층을 추가할 수 있습니다.\n\n이러한 단계를 따라가면 안전하고 신뢰할 수 있는 SSH 설정으로 나아갈 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이 안내서를 통해 함께해 주셔서 감사합니다. SSH 연결을 안전하게 유지하고 서버를 안전하게 보호하는 데 도움이 되었으면 좋겠습니다! 🔐\n\n안전 유지하시고 보안 유지하시길 바랍니다!\n\nCyberSecMaverick\n\n![Guide Image](/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_18.png)","ogImage":{"url":"/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_0.png"},"coverImage":"/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_0.png","tag":["Tech"],"readingTime":11},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p>SSH 키 기반 인증을 사용하여 SSH 연결을 안전하게 하는 단계별 가이드</p>\n<p><img src=\"/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_0.png\" alt=\"SSH Key-Based Authentication\"></p>\n<p>오늘의 글은 SSH 원격 세션의 보안을 강화하는 간단한 자습서를 제공합니다. Linux 서버에 SSH 키 기반 인증을 설정하는 방법에 중점을 두고 덜 안전한 암호 기반 인증에서 전환하는 방법을 안내합니다. 마지막으로 SSH 서버를 더 안전하게 하는 추가 방법에 대한 보너스 팁을 공유할 것입니다.</p>\n<h1>개요</h1>\n<p>SSH (Secure Shell) 키 기반 인증은 원격 서버에서 사용자의 신원을 인증하기 위해 암호화 키 쌍을 사용하는 보안 방법입니다. 이 방법은 컴퓨터에 공개 및 비밀 키 쌍을 생성하여 저장하고, SSH 서버를 구성하여 이러한 키를 인식하고 수락하도록 설정하는 것을 포함합니다. 이는 기존 암호 기반 인증과 관련된 위험을 줄이는 것으로 보안을 크게 향상시킵니다.</p>\n<p>SSH 키는 쌍으로 생성되고 일반 텍스트 파일로 저장됩니다. 키 쌍은 두 부분으로 구성됩니다:</p>\n<ul>\n<li>🔒 공개 키: 이 부분은 SSH 서버에 저장됩니다. 안전하게 공유할 수 있어 해당 서버가 연결할 때 신원을 인식할 수 있습니다.</li>\n<li>🔑 비밀 키: 이 부분은 사용자의 컴퓨터에 저장되어야 하며 항상 안전하게 보관되어야 합니다. 이를 사용하여 서버와 인증하며, 절대로 공유해서는 안 됩니다. 비밀 키는 파일을 읽을 수 없도록 사용 권한을 설정해야 합니다.</li>\n</ul>\n<h2>작동 방식</h2>\n<ul>\n<li>컴퓨터에서 공개 및 개인 키 쌍을 생성합니다.</li>\n<li>서버는 공개 키를 인식하고 해당하는 개인 키가 인증 중에 사용되면 액세스를 허용하도록 구성됩니다.</li>\n<li>선택적으로 개인 키에 암호를 설정하여 추가 보안을 제공할 수 있습니다. 이 암호는 잘못된 손에 키가 넘어갈 경우 추가 보호층을 제공합니다.</li>\n</ul>\n<h1>SSH 키를 사용한 인증의 장점</h1>\n<p>SSH 키 기반 인증은 비밀번호보다 더 나은 대안이므로 보안성과 편리성이 강화됩니다. 이렇게 왜 SSH 키를 사용해야 하는지 살펴보겠습니다:</p>\n<ul>\n<li>향상된 보안: 키가 고유하고 추측하기 어려우므로 키 기반 인증은 브루트 포스 공격에 저항합니다.</li>\n<li>자격 증명 노출 위험 감소: 서버가 침해당한 경우 권한 부여 자격 증명이 노출되는 위험이 없습니다.</li>\n<li>사용의 용이성: 사용자들은 복잡한 암호를 기억하거나 적어두지 않아도 되므로, 암호 관련 위반 사례의 위험이 줄어듭니다.</li>\n<li>자동화 지원: 암호 입력이 필요하지 않기 때문에 작업을 자동화할 수 있으며, 수동 개입 없이 Ansible과 같은 스크립트 및 도구가 SSH 서버와 상호작용할 수 있습니다.</li>\n</ul>\n<h1>SSH를 위한 공개 키 인증 설정하기</h1>\n<p>기본 사항을 다뤘으니, 이 작업을 완료하는 단계에 대해 자세히 살펴보겠습니다.</p>\n<p>SSH 키 쌍을 만드는 두 가지 옵션이 있습니다: Windows 기계 또는 Linux 기계에서. 단계는 일반적으로 비슷하지만, 각 환경에서 사용하는 소프트웨어 도구는 다릅니다.</p>\n<h2>방법 1: Linux에서 SSH 키 쌍 생성하기</h2>\n<p>스텝 1: Ed25519 알고리즘을 사용하여 새 SSH 키 쌍을 생성하세요.</p>\n<p>이 단계는 키페어를 로컬 컴퓨터에서 생성한 후에 나중에 서버로 업로드할 것으로 가정합니다. 서버에서 키페어를 생성하고 개인 키를 로컬 호스트로 다운로드하는 것보다 안전합니다.</p>\n<p>Ed25519 알고리즘을 사용하여 새 키 쌍을 생성하세요:</p>\n<pre><code class=\"hljs language-js\">ssh-keygen -t ed25519 -C <span class=\"hljs-string\">\"cybersecmav@warfare.systems\"</span>\n</code></pre>\n<ul>\n<li>-t: 알고리즘의 종류 (키), 우리의 경우 Ed25519.</li>\n<li>-C: SSH 키를 구분할 수 있도록 도와주는 설명 (선택 사항).</li>\n</ul>\n<p>파일 이름을 요구하면 기본 이름과 경로를 수락하려면 Enter 키를 누르세요. SSH 키는 일반적으로 ~/.ssh/ 디렉터리에 저장됩니다.</p>\n<p><img src=\"/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_1.png\" alt=\"이미지\"></p>\n<p>단계 2: 원격 서버 준비하기</p>\n<p>만약 ~/.ssh 디렉토리와 authorized_keys 파일이 존재하지 않는다면 다음을 실행해주세요:</p>\n<pre><code class=\"hljs language-js\">mkdir ~/.<span class=\"hljs-property\">ssh</span>\ntouch ~<span class=\"hljs-regexp\">/.ssh/</span>authorized_keys\n</code></pre>\n<p>~/.ssh 디렉토리에 위치한 authorized_keys 파일은 SSH 서버에 액세스할 수 있는 공개 키 목록을 포함하고 있습니다.</p>\n<p>~/.ssh 디렉토리와 authorized_keys 파일에 적절한 파일 권한을 설정해주세요:</p>\n<pre><code class=\"hljs language-js\">chmod <span class=\"hljs-number\">700</span> ~/.<span class=\"hljs-property\">ssh</span>\nchmod <span class=\"hljs-number\">600</span> ~<span class=\"hljs-regexp\">/.ssh/</span>authorized_keys\n</code></pre>\n<ul>\n<li>chmod 700 ~/.ssh: 해당 디렉토리의 파일을 읽기, 쓰기, 실행할 수 있는 권한을 소유자에게만 부여합니다.</li>\n<li>chmod 600 ~/.ssh/authorized_keys: 소유자에게만 파일에 액세스할 수 있도록 제약을 두어 다른 사람이 파일을 보거나 수정하는 것을 방지하여 SSH 키를 보호합니다.</li>\n</ul>\n<p>로컬 머신에서 공개 키를 원격 서버로 업로드하세요:</p>\n<pre><code class=\"hljs language-js\">scp id_ed2551.<span class=\"hljs-property\">pub</span> cybersecmav@warfare.<span class=\"hljs-property\">systems</span>:<span class=\"hljs-regexp\">/home/</span>cybersecmav/id_ed2551.<span class=\"hljs-property\">pub</span>\n</code></pre>\n<p>아래와 같이 업로드한 공개 키를 .ssh/ 디렉터리로 이동해 주세요:</p>\n<pre><code class=\"hljs language-js\">mv id_ed2551.<span class=\"hljs-property\">pub</span> ~<span class=\"hljs-regexp\">/.ssh/</span>\nchmod <span class=\"hljs-number\">600</span> ~<span class=\"hljs-regexp\">/.ssh/i</span>d_ed2551.<span class=\"hljs-property\">pub</span>\n</code></pre>\n<p>공개 키의 출력을 authorized_keys 파일로 복사해 주세요:</p>\n<pre><code class=\"hljs language-js\">cat ~<span class=\"hljs-regexp\">/.ssh/i</span>d_ed2551.<span class=\"hljs-property\">pub</span> >> ~<span class=\"hljs-regexp\">/.ssh/</span>authorized_keys\n</code></pre>\n<p>authorized_keys의 내용을 확인하여 공개 키가 추가되었는지 확인해보세요:</p>\n<pre><code class=\"hljs language-js\">cat .<span class=\"hljs-property\">ssh</span>/authorized_keys\nssh-ed25519 <span class=\"hljs-variable constant_\">AAA</span>&#x3C;&#x3C;...<span class=\"hljs-variable constant_\">REDACTED</span>......>>1uEqXysh cybersecmav@warfare.<span class=\"hljs-property\">systems</span>\n</code></pre>\n<p>모든 올바른 폴더 및 파일 권한이 있는지 확인해봅시다:</p>\n<pre><code class=\"hljs language-js\">cybersecmav@<span class=\"hljs-attr\">ares</span>:~$ cd .<span class=\"hljs-property\">ssh</span>\ncybersecmav@<span class=\"hljs-attr\">ares</span>:~/.<span class=\"hljs-property\">ssh$</span> ls -la\ntotal <span class=\"hljs-number\">16</span>\ndrwx------ <span class=\"hljs-number\">2</span> cybersecmav cybersecmav <span class=\"hljs-number\">4096</span> <span class=\"hljs-title class_\">Apr</span> <span class=\"hljs-number\">26</span> <span class=\"hljs-number\">14</span>:<span class=\"hljs-number\">32</span> .\ndrwxr-xr-x <span class=\"hljs-number\">5</span> cybersecmav cybersecmav <span class=\"hljs-number\">4096</span> <span class=\"hljs-title class_\">Apr</span> <span class=\"hljs-number\">29</span> <span class=\"hljs-number\">13</span>:<span class=\"hljs-number\">32</span> ..\n-rw------- <span class=\"hljs-number\">1</span> cybersecmav cybersecmav  <span class=\"hljs-number\">109</span> <span class=\"hljs-title class_\">Apr</span> <span class=\"hljs-number\">26</span> <span class=\"hljs-number\">14</span>:<span class=\"hljs-number\">33</span> authorized_keys\n-rw-r--r-- <span class=\"hljs-number\">1</span> cybersecmav cybersecmav  <span class=\"hljs-number\">109</span> <span class=\"hljs-title class_\">Apr</span> <span class=\"hljs-number\">23</span> <span class=\"hljs-number\">19</span>:<span class=\"hljs-number\">49</span> id_ed2551.<span class=\"hljs-property\">pub</span>\n</code></pre>\n<p>Step 3: 공개 키 인증을 지원하도록 SSH 서버 구성하기</p>\n<p>편집을 위해 SSH 서버 구성 파일을 엽니다:</p>\n<pre><code class=\"hljs language-js\">sudo nano /etc/ssh/sshd_config\n</code></pre>\n<p>PubkeyAuthentication 설정을 찾아서 아래로 스크롤합니다. \"no\"에서 \"yes\"로 변경하세요. 또한, AuthorizedKeysFile로 시작하는 줄이 주석 처리되어 있지 않은지 확인하거나 누락된 경우 추가하세요.</p>\n<pre><code class=\"hljs language-plaintext\">PubkeyAuthentication yes\nAuthorizedKeysFile .ssh/authorized_keys .ssh/authorized_keys2\n</code></pre>\n<p>다음은 /etc/sshd_config 파일이 보이는 방식입니다:</p>\n<p><img src=\"/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_2.png\" alt=\"2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_2.png\"></p>\n<p>4단계: 구성 변경을 적용하기 위해 SSH 서버를 다시로드하세요</p>\n<p>sshd_config 파일을 변경할 때는 변경 사항이 적용되려면 SSH 서버를 다시로드하거나 다시 시작해야 합니다.</p>\n<p>Debian/Ubuntu:</p>\n<pre><code class=\"hljs language-js\">sudo systemctl reload ssh\nsudo systemctl restart ssh\n</code></pre>\n<p>Redhat/CentOS:</p>\n<pre><code class=\"hljs language-js\">sudo systemctl reload sshd\nsudo systemctl restart sshd\n</code></pre>\n<h2>방법 2: Windows에서 SSH 키 쌍 생성</h2>\n<p>로컬 머신으로 Windows를 사용하고 있다면, PuTTY 클라이언트의 키 생성기인 puttygen.exe를 사용하여 SSH 키 쌍을 생성할 수 있습니다.</p>\n<ul>\n<li>다음 위치에서 PuTTY를 다운로드하세요: <a href=\"https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html\" rel=\"nofollow\" target=\"_blank\">https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html</a></li>\n<li>puttygen.exe를 엽니다. 기본적으로 RSA를 키 생성으로 선택하지만, 원격 SSH 서버가 지원하는 경우 ED25519를 선택할 수도 있습니다.</li>\n</ul>\n<ul>\n<li>\"Generate\"를 클릭하여 새로운 공개/개인 키 쌍을 생성합니다.</li>\n</ul>\n<ul>\n<li>나중에 원격 서버의 ~/.ssh/ 디렉토리의 authorized_keys 파일에 붙여 넣을 공개 키를 복사합니다.</li>\n</ul>\n<p><img src=\"/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_5.png\" alt=\"image\"></p>\n<ul>\n<li>Save the public key as: id_ed2551.pub</li>\n<li>Save the private key as: id_ed2551.ppk</li>\n</ul>\n<p><img src=\"/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_6.png\" alt=\"image\"></p>\n<ul>\n<li>Alternatively, you can save them using the File menu option</li>\n</ul>\n<p><img src=\"/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_7.png\" alt=\"Save and keep a copy of your SSH keys\"></p>\n<p><img src=\"/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_8.png\" alt=\"SSH key image 2\"></p>\n<p><img src=\"/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_9.png\" alt=\"SSH key image 3\"></p>\n<ul>\n<li><code>/home/username/.ssh/authorized_keys</code> 파일에 공개 키 값을 새 줄에 붙여 넣으세요.</li>\n</ul>\n<p><img src=\"/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_10.png\" alt=\"Step 10\"></p>\n<ul>\n<li>윈도우즈에서 PuTTY SSH 클라이언트를 사용하여 키 기반 인증을 통한 원격 호스트로의 SSH 연결을 테스트합니다.</li>\n<li>putty.exe 클라이언트를 열고 원격 SSH 서버 세부 정보를 입력하세요.</li>\n</ul>\n<p><img src=\"/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_11.png\" alt=\"Step 11\"></p>\n<ul>\n<li>지금 가장 중요한 단계는 리모트 서버에 연결하기 전에 방금 생성한 올바른 개인 키를 선택했는지 확인하는 것입니다.</li>\n</ul>\n<p><img src=\"/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_12.png\" alt=\"SSH Key\"></p>\n<ul>\n<li>\n<p>\"Open\"을 클릭하면 원격 대상과의 SSH 세션이 열립니다.</p>\n</li>\n<li>\n<p>이제 새로운 공개/개인 키 쌍을 사용하여 인증된 SSH 세션이 열려 있어야 합니다. 아래 예시를 확인해주세요.</p>\n</li>\n</ul>\n<p>이제 SSH 키 기반 인증으로 로그인되었습니다.</p>\n<h1>추가 정보: SSH 서버 보안 팁</h1>\n<p>SSH 키 기반 인증의 기본 사항을 다룬 이제, SSH 서버를 보다 더 보호하기 위한 몇 가지 추가 보안 팁을 살펴봅시다. 이러한 모범 사례를 시행함으로써 SSH 서버의 보안성을 높일 수 있습니다.</p>\n<h2>팁 1: 비밀번호 인증 비활성화</h2>\n<p>SSH 키 기반 인증이 작동하는지 확인한 후, SSH 구성 파일인 /etc/ssh/sshd_config에서 PasswordAuthentication을 \"no\"로 설정하여 비밀번호 기반 로그인을 비활성화하세요.</p>\n<pre><code class=\"hljs language-sh\">sudo nano /etc/ssh/sshd_config\n</code></pre>\n<p><img src=\"/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_14.png\" alt=\"이미지\"></p>\n<h2>팁 2: 루트 로그인 제한</h2>\n<p>SSH를 통한 직접적인 루트 액세스를 방지하려면 PermitRootLogin을 \"no\"로 설정하세요. 이렇게 하면 사용자가 루트 계정으로 로그인하는 것이 불가능해지며 관리 작업을 위해 sudo를 사용해야 합니다.</p>\n<p><img src=\"/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_15.png\" alt=\"이미지\"></p>\n<h2>팁 3: 비표준 SSH 포트 사용</h2>\n<p>기본 SSH 포트를 22에서 더 높거나 보통과 다른 숫자로 변경하면 무분별한 자동 스캔 및 브루트포스 공격이 더 어려워질 수 있습니다. 이는 위협의 대부분을 이루는 것입니다. 그러나 SSH 서버를 모든 공격으로부터 완전히 보호하는 것은 아니라는 것을 명심하세요. 결정적인 해커는 여전히 SSH 포트를 찾아내고 대상으로 삼을 수 있습니다.</p>\n<p><img src=\"/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_16.png\" alt=\"Image\"></p>\n<h2>팁 4: SSH 로깅 및 모니터링 활성화</h2>\n<p>SSH 로깅이 활성화되어 있어야 연결 시도를 추적하고 이상한 활동을 감지할 수 있습니다. 무단 액세스나 브루트포스 공격의 징후를 탐지하기 위해 로그를 정기적으로 모니터링하세요.</p>\n<p>대부분의 시스템에서 SSH 로깅은 기본적으로 활성화되어 있습니다. 그러나 SSH 설정 파일 /etc/ssh/sshd_config을 확인하여 비활성화되어 있지 않은지 확인해보세요.</p>\n<p>단계 1: SSH 서비스 구성 파일에서 SSH 로깅 활성화하기</p>\n<p>SyslogFacility를 \"AUTH\"로 설정하고 LogLevel은 \"INFO\"로 설정하세요.</p>\n<p><img src=\"/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_17.png\" alt=\"이미지\"></p>\n<p>다른 로그 레벨을 탐색하려면 아래 섹션을 참조하세요. Verbose 및 Debug는 많은 로그를 생성하므로 진단 또는 디버깅에만 유용하기 때문에 권하지 않습니다.</p>\n<p>SSH 로그 레벨</p>\n<ul>\n<li>QUIET: 거의 아무것도 로그하지 않아 최소한의 출력을 제공합니다.</li>\n<li>FATAL: SSH 서버 작동을 중지하는 중요한 오류만 로그합니다.</li>\n<li>ERROR: 중요한 문제 및 심각한 오류를 로그합니다.</li>\n<li>INFO: 기본 레벨로, SSH 작업에 대한 일반 정보를 로깅합니다.</li>\n<li>VERBOSE: SSH 프로세스에 대한 자세한 정보를 로그하며, 문제 해결에 유용합니다.</li>\n<li>DEBUG: 디버깅을 위한 방대한 로그를 생성하며, 일반적으로 일상적으로 사용하지 않습니다.</li>\n</ul>\n<p>단계 2: 로그 저장소 구성</p>\n<p>보통 SSH 로그는 /var/log/auth.log (Debian/Ubuntu) 또는 /var/log/secure (Red Hat/CentOS)에 저장됩니다.</p>\n<pre><code class=\"hljs language-js\">$ ls -la /<span class=\"hljs-keyword\">var</span>/log/auth.<span class=\"hljs-property\">log</span>\n-rw-r----- <span class=\"hljs-number\">1</span> root adm <span class=\"hljs-number\">292525</span> <span class=\"hljs-title class_\">May</span> <span class=\"hljs-number\">4</span> <span class=\"hljs-number\">10</span>:<span class=\"hljs-number\">18</span> /<span class=\"hljs-keyword\">var</span>/log/auth.<span class=\"hljs-property\">log</span>\n</code></pre>\n<p>이 파일들이 존재하고 접근 가능한지 확인하세요. 소유자가 root로 설정되어 있고 파일 권한이 로그 파일을 안전하게 보호하기 위해 적절하게 설정되었는지 확인하세요.</p>\n<pre><code class=\"hljs language-js\">chmod <span class=\"hljs-number\">640</span> /<span class=\"hljs-keyword\">var</span>/log/auth.<span class=\"hljs-property\">log</span>\n</code></pre>\n<h2>팁 5: 침입 탐지 (Fail2ban) 구현하기</h2>\n<p>Fail2Ban은 로그인 시도를 모니터링하고 많은 실패한 시도 후 IP 주소를 차단하여 SSH 서버를 보호할 수 있습니다. 이는 브루트포스 공격의 일반적인 징후입니다. 설치한 후에는 SSH 로그를 주시하도록 설정하고 의심스러운 IP를 차단할 규칙을 구성하세요. SSH 서버의 보안에 추가적인 방어층을 더하는 효과적인 방법입니다.</p>\n<p>Fail2Ban을 설정하고 구성하는 것은 이 글의 범위를 벗어납니다. 그러나 추가 보안을 위해 서버에 설치하는 것을 적극 추천합니다.</p>\n<h1>결론</h1>\n<p>이 기사에서는 SSH 키 기반 인증의 혜택을 다루었는데, 이를 통해 보안을 강화하고 브루트포스 공격의 위험을 줄일 수 있다는 점을 강조했습니다. SSH 키를 생성하고 서버에 구성하는 방법을 안내하며 적절한 보안을 유지하는 방법을 보여드렸습니다. 또한 SSH 서버를 안전하게 유지하기 위한 추가 팁을 살펴봤는데, 이에는 기본 포트 변경, Fail2Ban 구현, 그리고 철저한 SSH 로깅 및 모니터링 활성화가 포함되었습니다.</p>\n<p>전체적으로 SSH 키 기반 인증은 원격 액세스를 보다 안전하고 편리하게 관리하는 방법을 제공합니다. 패스워드 기반 로그인의 효과적인 대체제로서, 미인가된 액세스 가능성을 줄이고 보안을 희생하지 않고 자동화가 가능합니다.</p>\n<p>권장 사항으로는 개인 키에 항상 암호를 설정하고, 이상한 활동을 정기적으로 모니터링하며, 키 기반 설정에 확신을 갖게 되면 패스워드 인증을 비활성화하는 것을 고려해야 합니다. Fail2Ban을 구현하면 브루트포스 공격의 징후를 보이는 IP 주소를 차단하여 자동화된 보호층을 추가할 수 있습니다.</p>\n<p>이러한 단계를 따라가면 안전하고 신뢰할 수 있는 SSH 설정으로 나아갈 수 있습니다.</p>\n<p>이 안내서를 통해 함께해 주셔서 감사합니다. SSH 연결을 안전하게 유지하고 서버를 안전하게 보호하는 데 도움이 되었으면 좋겠습니다! 🔐</p>\n<p>안전 유지하시고 보안 유지하시길 바랍니다!</p>\n<p>CyberSecMaverick</p>\n<p><img src=\"/assets/img/2024-05-18-AGuideToSecuringYourRemoteAccessUsingSSHKeys_18.png\" alt=\"Guide Image\"></p>\n</body>\n</html>\n"},"__N_SSG":true}