{"pageProps":{"post":{"title":"Terraform을 활용한 Multi-Cloud 관리 마스터하기","description":"","date":"2024-05-27 17:46","slug":"2024-05-27-MasteringMulti-CloudManagementwithTerraform","content":"\n<img src=\"/assets/img/2024-05-27-MasteringMulti-CloudManagementwithTerraform_0.png\" />\n\n여러 공개 클라우드(Azure, AWS, GCP 등)를 사용하면 유연성을 제공하고 비용을 최적화하며 벤더 락인을 줄일 수 있습니다. 그러나 다양한 클라우드 플랫폼 간에 인프라 및 서비스를 관리하는 것은 어렵습니다.\n\n테라폼을 통해 일관되고 자동화된 멀티 클라우드 관리가 가능한지 알아봅시다. 이 포함사항은 멀티 클라우드 아키텍처, 테라폼 추상화, 프로비저닝, 거버넌스, 네트워킹, 배포 패턴, 테스팅, 그리고 Azure 및 GCP 전반적인 모니터링입니다.\n\n# 개요\n\n<div class=\"content-ad\"></div>\n\n다음 주제를 다룰 것입니다:\n\n- 테라폼을 사용한 멀티 클라우드 아키텍처\n- 인프라 차이점 추상화\n- 리소스 프로비저닝 및 의존성 관리\n- 정책 강화 및 거버넌스\n- 네트워킹 토폴로지와 연결\n- 블루-그린, 카나리아, 멀티 리전 배포 패턴\n- 통합 테스트 및 목 객체(Mock) 사용\n- 중앙 집중식 로깅, 메트릭 및 관찰 가능성\n\n이 코드 예제들은 테라폼을 사용해 Azure와 GCP로 인프라 및 서비스를 배포하는 방법을 보여줍니다. 이는 테라폼을 일관된 추상화 계층으로 사용하여 실제 멀티 클라우드 관리를 보여줍니다.\n\n# 멀티 클라우드 아키텍처\n\n<div class=\"content-ad\"></div>\n\n기본적인 멀티 클라우드 아키텍처는 Terraform을 사용하면 다음과 같이 보입니다:\n\nTerraform은 여러 클라우드 계정에 인프라를 프로비저닝하고 플랫폼 간의 차이를 추상화합니다. 상태는 원격으로 저장되며 계정 간에 공유됩니다.\n\n멀티 클라우드 아키텍처를 위한 몇 가지 주요 디자인 원칙:\n\n- 차이 추상화 — 공급자별 논리를 최소화하고 차이를 추상화 뒤에 숨깁니다\n- 환경 모듈화 — 환경 및 구성 요소별로 모듈화된 파일로 구성을 분리합니다\n- 표준화된 네이밍 — 쉽게 연관을 확인하기 위해 클라우드 간에 일관된 네이밍 체계 사용\n- 정책 캡슐화 — 정책 및 거버넌스 규칙을 모듈화된 재사용 가능한 파일에 유지합니다\n- 상태 중앙화 — 원격 상태를 사용하여 서비스 및 클라우드 전체의 상태를 공유합니다\n- 공유 서비스 추출 — ID, DNS, CDN과 같은 공유 서비스를 한 번 빌드하고 재사용합니다\n- 파이프라인 통합 — 모든 클라우드 대상으로 배포하는 표준 CI/CD 파이프라인 사용\n\n<div class=\"content-ad\"></div>\n\n이러한 원칙을 따라서, 여러 대상 클라우드 간에 일관성있는 이동 가능한 구성을 구축할 수 있습니다.\n\n그 다음으로, Terraform이 클라우드 간의 차이를 추상화하는 데 어떻게 도움을 주는지 살펴보겠습니다.\n\n# 인프라 추상화\n\nTerraform의 강점 중 하나는 클라우드 플랫폼 간의 차이를 추상화하는 균일한 추상화 계층을 제공할 수 있는 능력입니다.\n\n<div class=\"content-ad\"></div>\n\n예를 들어, Azure 대 GCP에서 MySQL 데이터베이스 프로비저닝:\n\nAzure\n\n```js\nresource \"azurerm_mysql_server\" \"db\" {\n  name                = \"mysqlserver\"\n  location            = \"eastus\"\n  resource_group_name = azurerm_resource_group.rg.name\n```\n\n```js\n  sku {\n    name     = \"B_Gen5_2\"\n    capacity = 2\n  }\n}\nresource \"azurerm_mysql_database\" \"db\" {\n  name                = \"mydatabase\"\n  resource_group_name = azurerm_resource_group.rg.name\n  server_name         = azurerm_mysql_server.db.name\n  charset             = \"utf8\"\n  collation           = \"utf8_unicode_ci\"\n}\n```\n\n<div class=\"content-ad\"></div>\n\nGCP\n\n```js\nresource \"google_sql_database_instance\" \"db\" {\n  name             = \"mysql-instance\"\n  database_version = \"MYSQL_5_7\"\n  region           = \"us-central1\"\n```\n\n```js\n  settings {\n    tier = \"db-f1-micro\"\n  }\n}\nresource \"google_sql_database\" \"database\" {\n  name     = \"my-database\"\n  instance = google_sql_database_instance.db.name\n}\n```\n\nTerraform의 리소스 유형은 일관된 인터페이스를 제공하기 위해 기본 API 차이를 추상화합니다.\n\n<div class=\"content-ad\"></div>\n\n이 추상화는 대규모 변경없이 클라우드 간에 쉽게 전환할 수 있도록 도와줍니다. 필요한 경우 각 클라우드 공급업체에 맞게 엣지에서 맞춤 설정할 수 있습니다.\n\n테라폼이 다중 클라우드 추상화를 제공하는 주요 분야 몇 가지:\n\n- 컴퓨팅 — 가상 머신, 컨테이너, 쿠버네티스, 스케일링\n- 네트워크 — 서브넷, 라우팅, 보안 그룹, 로드 밸런싱\n- 스토리지 — 블롭, 디스크, 데이터베이스\n- 아이덴티티 — 역할, 권한, 액세스 제어\n- 인프라스트럭처 — DNS, VPN, 규칙, 정책\n\n최대한 다중 클라우드 추상화를 활용하여 구성을 작성하면 이동성이 높아집니다.\n\n<div class=\"content-ad\"></div>\n\n# 프로비저닝 및 의존성\n\n여러 클라우드 인프라를 프로비저닝할 때 가장 좋은 방법은 리소스를 의존성 레이어로 구조화하는 것입니다.\n\n상위 수준의 구성은 하위 수준의 구성을 의존합니다. 예를 들어:\n\n테라폼을 사용할 때, depends_on 속성을 사용하여 리소스 의존성을 명시적으로 정의하세요:\n\n<div class=\"content-ad\"></div>\n\n```md\n리소스 \"azurerm_subnet\" \"public\" {\n#...\n}\n```\n\n```md\n리소스 \"azurerm_network_interface\" \"nic\" {\n#...\nsubnet_id = azurerm_subnet.public.id\n}\n리소스 \"azurerm_virtual_machine\" \"main\" {\n#...\n\nnetwork_interface_ids = [\nazurerm_network_interface.nic.id,\n]\ndepends_on = [\nazurerm_network_interface.nic\n]\n}\n```\n\n테라폼은 리소스 간 종속성을 분석하고 변경 사항을 올바른 순서로 적용합니다.\n\n멀티 클라우드 환경에서의 종속성에 대한 팁:\n\n\n\n<div class=\"content-ad\"></div>\n\n- 공통 빌딩 블록을 기본 모듈에 네트워크와 같은 것으로 포함시킵니다.\n- 독립적인 구성 요소를 계층별로 분리합니다.\n- 암시적이어도 `depends_on`을 명시적으로 정의합니다.\n- 데드락을 일으키는 종속성 순환이 있는지 확인합니다.\n- 종속성 순서대로 계획하고 적용합니다.\n\n자원 종속성을 올바르게 설정하는 것이 여러 클라우드에서 원활한 프로비저닝을 위해 중요합니다.\n\n# 정책 집행과 거버넌스\n\n기관 정책과 규정 준수 요구사항을 강제하는 것은 여러 클라우드 관리에 있어 중요합니다.\n\n<div class=\"content-ad\"></div>\n\n다음은 운용 규칙의 몇 가지 예시입니다:\n\n- VM 유형 제한\n- 데이터 주권을 위한 지역 및 존 제어\n- 태깅 규칙과 표준 설정\n- 네트워킹 노출 제한\n- 암호화 요구 사항 강제\n- 고위험 자원 사용 제한\n\n테라폼을 통해 정책 강제를 활성화할 수 있습니다:\n\n변수\n\n<div class=\"content-ad\"></div>\n\n허용된 값 제한:\n\n```js\nvariable \"region\" {\n  type    = string\n  default = \"us-east-1\"\n}\n```\n\n```js\nresource \"aws_db_instance\" \"db\" {\n  region = var.region # us-east-1만 허용됩니다\n}\n```\n\n모듈\n\n<div class=\"content-ad\"></div>\n\n친구야, 모듈 내에서 지배 논리를 캡슐화하고 재사용하세요:\n\n```js\nmodule \"server\" {\n  source = \"./modules/certified_server\"\n# 인증된 서버는 합리적인 기본값을 설정합니다\n}\n```\n\nSentinel 정책\n\n리소스를 제한하는 대상 정책을 적용하십시오:\n\n<div class=\"content-ad\"></div>\n\n```js\naws_instance_disallowed_type = rule {\n  all aws_instance as _, instance {\n    instance.instance_type is not in [\"t2.micro\", \"t3.micro\"]\n  }\n}\n```\n\n이러한 메커니즘은 구성에 직접 규제를 포함하여 규정 준수를 쉽게 만듭니다.\n\n# 네트워킹 토폴로지\n\n다양한 클라우드 간 네트워크 연결성을 관리하는 것은 복잡성을 증가시킵니다. 일부 하이브리드 클라우드 네트워크 토폴로지는 다음과 같습니다:```\n\n<div class=\"content-ad\"></div>\n\n테이블 형식을 Markdown 형식으로 변경하실래요.\n\n\n| Pairing |\n|--------|\n| Connect cloud regions to on-prem data centers. Useful for migration and hybrid workloads. |\n\n| Hub-and-Spoke |\n|---------------|\n| Central hub VPC with connectivity to multiple cloud spokes. Enables transitivity between spokes. |\n\n\n<div class=\"content-ad\"></div>\n\n메시\n\n클라우드 간 사이트 간 VPN이 구성된 완전히 메시된 네트워크입니다. 지역 간 직접 통신을 제공합니다.\n\n테라폼은 terraform-provider-aws, terraform-provider-azurerm 및 유사한 네트워킹 제공업체를 통해 이러한 네트워크 토폴로지를 조정하는 것을 단순화합니다.\n\n예를 들어, AWS에서 Azure로 사이트 간 VPN을 생성하는 방법:\n\n<div class=\"content-ad\"></div>\n\n```js\n# AWS 측\n리소스 \"aws_customer_gateway\" \"gw\" {\n  bgp_asn    = 65002\n  ip_address = \"172.0.0.1\"\n  type       = \"ipsec.1\"\n}\n```\n\n```js\n리소스 \"aws_vpn_connection\" \"main\" {\n  vpn_gateway_id      = aws_vpn_gateway.vgw.id\n  customer_gateway_id = aws_customer_gateway.gw.id\n  type                = \"ipsec.1\"\n  static_routes_only  = true\n  tunnel1_ike_versions   = [\"ikev2\"]\n  tunnel2_ike_versions   = [\"ikev2\"]\n  tunnel1_phase1_dh_group_numbers = [31]\n  tunnel2_phase1_dh_group_numbers = [31]\n}\n# Azure 측\n리소스 \"azurerm_local_network_gateway\" \"lgw\" {\n  name                = \"aws-conn\"\n  resource_group_name = azurerm_resource_group.rg.name\n  location            = azurerm_resource_group.rg.location\n  gateway_address = aws_customer_gateway.gw.ip_address\n  address_space     = [\"172.16.0.0/16\"]\n}\n리소스 \"azurerm_virtual_network_gateway_connection\" \"main\" {\n  name                       = \"aws-conn\"\n  resource_group_name        = azurerm_resource_group.rg.name\n  location                   = azurerm_resource_group.rg.location\n  type                       = \"IPsec\"\n  virtual_network_gateway_id = azurerm_virtual_network_gateway.vgw.id\n  local_network_gateway_id   = azurerm_local_network_gateway.lgw.id\n  shared_key = aws_vpn_connection.main.tunnel1_preshared_key\n\n  ipsec_policy {\n    dh_group         = \"DHGroup31\"\n    ike_encryption   = \"AES256\"\n    ike_integrity    = \"SHA256\"\n    ipsec_encryption = \"AES256\"\n    ipsec_integrity  = \"SHA256\"\n    pfs_group        = \"PFS31\"\n    sa_datasize      = 536870912\n  }\n}\n```\n\n이 방법을 통해 멀티 클라우드에 일관된 방식으로 전체 연결 구성을 정의할 수 있습니다.\n\n# 배포 패턴\n\n\n\n<div class=\"content-ad\"></div>\n\n여러 클라우드로 배포할 때 블루-그린, 카나리아, 다중 지역과 같은 패턴을 사용하면 관리가 간단해질 수 있어요.\n\n블루-그린\n\n블루-그린은 새 버전을 병렬로 배포한 다음 트래픽을 원자적으로 전환합니다. 이는 롤백 및 점진적인 롤아웃 기능을 제공합니다.\n\n예시:\n\n<div class=\"content-ad\"></div>\n\n```js\n# 파란 환경\nmodule \"blue_env\" {\n  source = \"./env\"\n  color  = \"blue\"\n}\n```\n\n```js\n# 초록 환경\nmodule \"green_env\" {\n  source = \"./env\"\n  color  = \"green\"\n  # 처음에는 트래픽이 없음\n  traffic_weight = 0\n}\n# 트래픽 분할기\nresource \"aws_lb\" \"main\" {\n  # 100%의 트래픽을 파란 쪽에 보냅니다.\n}\n```\n\n그런 다음 로드 밸런서를 통해 점진적으로 파란 색에서 초록 색으로 트래픽을 이동합니다.\n\n카나리아\n\n\n\n<div class=\"content-ad\"></div>\n\n파란색-초록색처럼 변경되지만 처음에는 일부 사용자에게만 공개됩니다.\n\n```js\nmodule \"prod_env\" {\n  source = \"./env\"\n```\n\n```js\n  # 대부분의 트래픽이 본 프로덕션 환경으로 이동합니다.\n}\nmodule \"canary_env\" {\n  source = \"./env\"\n  # 소수의 트래픽이 canary로 이동합니다.\n  traffic_weight = 0.1\n}\n```\n\nMulti-Region\n\n<div class=\"content-ad\"></div>\n\n고가용성 및 낮은 대기 시간을 위해 여러 지역에 리소스를 프로비저닝합니다.\n\n예를 들어:\n\n```js\n# 서부 지역\nmodule \"west\" {\n  source = \"./region\"\n  providers = {\n    azurerm.west = azurerm.west\n  }\n}\n```\n\n```js\n# 동부 지역\nmodule \"east\" {\n  source = \"./region\"\n  providers = {\n    azurerm.east = azurerm.east\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n그럼 DNS와 로드 밸런싱을 사용하여 전 세계적으로 분산하세요.\n\n이러한 패턴은 멀티 클라우드 배포를 간단하게 해줍니다. 모듈 재사용은 일관성을 도와줍니다.\n\n# 통합 테스트\n\n여러 클라우드에 걸친 배포를 유효성 검사하려면 자동화된 통합 테스트가 필요합니다.\n\n<div class=\"content-ad\"></div>\n\n테라폼을 사용한 멀티 클라우드 테스팅을 위한 몇 가지 최상의 방법:\n\n- 인프라 테스트 — terraform plan 및 terraform show를 사용하여 올바른 구성의 리소스를 검증합니다.\n- 프로비저닝 테스트 — 처음부터 일회용 테스트 환경을 배포합니다.\n- 실패 테스트 — 종료된 인스턴스와 같은 실패를 시뮬레이션합니다.\n- 서비스 테스트 — 목업을 사용하여 서비스 접근성과 동작을 유효성 검사합니다.\n\n예를 들어, 일회용 테스트 환경을 생성하는 방법:\n\n```js\nmodule \"test_env\" {\n  source = \"./env\"\n  providers = {\n    aws = aws.test\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n테이블 태그를 Markdown 형식으로 변경해주세요.\n\n<div class=\"content-ad\"></div>\n\n다양한 환경에서 배포를 유효성 검사하려면 자동화된 테스트가 필요합니다.\n\nTerraform을 사용하는 몇 가지 권장사항:\n\n- 사용 및 폐기 가능한 테스트 환경 프로비저닝\n- 리소스 구성 검증\n- 다양한 장애 시나리오 시뮬레이션\n- 의존성에 대한 모의 테스트 사용\n\n예시:\n\n<div class=\"content-ad\"></div>\n\n```js\nmodule \"test_env\" {\n  source = \"./env\"\n```\n\n```js\n  # AWS 계정 자격 증명 테스트\n}\nresource \"null_resource\" \"check_connectivity\" {\n  provisioner \"local-exec\" {\n    command = \"ping.exe -n 3 ${module.test_env.ip}\"\n  }\n}\n```\n\n이렇게 하면 안전하게 변경 사항을 테스트할 수 있는 격리된 환경이 생성됩니다.\n\n다른 예시:\n\n\n\n<div class=\"content-ad\"></div>\n\n- 성능 테스트를 위해 과거 트래픽을 다시 재생합니다.\n- 종료된 인스턴스와 같은 결함을 주입합니다.\n- 결정론적 테스트를 위해 외부 서비스를 스텁 처리합니다.\n\n자동화된 테스트는 구성 요소를 리팩토링할 때 자신감을 유지하는 데 중요합니다.\n\n## 가시성\n\n이질적인 클라우드 간 로그, 지표 및 추적에 대한 가시성을 확보하는 것은 어렵습니다.\n\n<div class=\"content-ad\"></div>\n\n테라폼을 사용하면 관측 가능성 데이터를 공유 플랫폼에 집계할 수 있습니다:\n\n로그 기능\n\n```js\nresource \"aws_cloudwatch_log_group\" \"app\" {\n  name = \"/aws/lambda/app\"\n}\nresource \"azurerm_monitor_diagnostic_setting\" \"app\" {\n  name               = \"diag\"\n  target_resource_id = azurerm_function_app.app.id\n  log_analytics_workspace_id = azurerm_log_analytics_workspace.main.id\n  log {\n    category = \"FunctionAppLogs\"\n    enabled  = true\n  }\n}\nresource \"google_logging_project_sink\" \"app\" {\n  name        = \"app-sink\"\n  destination = google_storage_bucket.logs.name\n}\n```\n\nSplunk와 같은 도구에서 로그를 중앙 집계하세요.\n\n<div class=\"content-ad\"></div>\n\n메트릭\n\n```js\n리소스 \"signalfx_detector\" \"지연시간\" {\n  이름 = \"높은 지연시간\"\n  프로그램_텍스트 = <<-EOF\n    A = 데이터('지연시간', 필터=필터('클라우드', '*') and 필터('환경', '*')).게시(label='A')\n    B = (A).합계(by=['클라우드', '환경']).게시(label='B')\n    detect(when(B > 1000, '5m')).게시('높은 지연시간!')\n  EOF\n}\n```\n\nDatadog와 같은 플랫폼에서 메트릭을 통합해보세요.\n\n트레이싱\n\n<div class=\"content-ad\"></div>\n\n```js\nmodule \"opentelemetry\" {\n  source = \"./opentelemetry\"\n  providers = {\n    aws = aws\n    azure = azurerm\n    google = google\n  }\n}\n```\n\n일반적인 형식으로 OpenTelemetry을 사용하면 추적을 쉽게 연결할 수 있어요.\n\n테라폼을 사용하면 다양한 플랫폼 사이에서 공유 관찰 패턴을 구축할 수 있어요.\n\n# 예시: 멀티-클라우드 웹 애플리케이션\n\n<div class=\"content-ad\"></div>\n\n실제로 멀티 클라우드 웹 애플리케이션을 Terraform으로 배포하는 실제 사례를 살펴봅시다.\n\nAWS ECS 및 Azure Container Instances (ACI)의 클러스터 전체에 애플리케이션 인프라를 배포할 것입니다. 글로벌 로드 밸런서가 트래픽을 플랫폼 간에 분배할 것입니다.\n\n네트워킹\n\n먼저, AWS VPC와 Azure VNet을 연결해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n# AWS VPC 및 서브넷\nresource \"aws_vpc\" \"main\" {\n  cidr_block = \"10.1.0.0/16\"\n}\n```\n\n```js\nresource \"aws_subnet\" \"public\" {\n  vpc_id = aws_vpc.main.id\n  cidr_block = \"10.1.1.0/24\"\n}\n# Azure VNet\nresource \"azurerm_virtual_network\" \"main\" {\n  name                = \"app-network\"\n  address_space       = [\"10.2.0.0/16\"]\n}\nresource \"azurerm_subnet\" \"public\" {\n  name                 = \"public-subnet\"\n  resource_group_name  = azurerm_resource_group.main.name\n  virtual_network_name = azurerm_virtual_network.main.name\n  address_prefixes     = [\"10.2.1.0/24\"]\n}\n```\n\nVPC 피어링을 통해 이들을 연결하십시오:\n\n```js\n# AWS 쪽 피어링\nresource \"aws_vpc_peering_connection\" \"peer\" {\n  vpc_id      = aws_vpc.main.id\n  peer_vpc_id = azurerm_virtual_network.main.id\n  auto_accept = true\n}\n```\n\n<div class=\"content-ad\"></div>\n\n```js\n# Azure 측 피어링\nresource \"azurerm_virtual_network_peering\" \"peer\" {\n  name                      = \"peer-aws\"\n  resource_group_name       = azurerm_resource_group.main.name\n  virtual_network_name      = az\n```\n\n컴퓨팅\n\nAzure Container Instances 배포:\n\n```js\nresource \"azurerm_container_group\" \"app\" {\n  name                = \"app-aci\"\n  location            = azurerm_resource_group.main.location\n  resource_group_name = azurerm_resource_group.main.name\n  ip_address_type     = \"public\"\n  dns_name_label      = \"app-aci\"\n  os_type             = \"Linux\"\n```\n\n<div class=\"content-ad\"></div>\n\n```js\n  container {\n    name   = \"app\"\n    image  = \"myapp:v1\"\n    cpu    = \"1\"\n    memory = \"1\"\n    ports {\n      port     = 80\n      protocol = \"TCP\"\n    }\n  }\n```\n\n아마존 ECS 클러스터 및 서비스:\n\n```js\nresource \"aws_ecs_cluster\" \"main\" {\n  name = \"myapp-cluster\"\n}\n```\n\n```js\nresource \"aws_ecs_service\" \"web\" {\n  name            = \"web\"\n  cluster         = aws_ecs_cluster.main.id\n  task_definition = aws_ecs_task_definition.app.arn\n  desired_count   = 3\n  launch_type     = \"FARGATE\"\n}\n```\n\n<div class=\"content-ad\"></div>\n\n로드 밸런싱\n\n각 클라우드에 백엔드가 있는 글로벌 로드 밸런서를 배포하십시오:\n\n```js\nresource \"aws_lb\" \"web\" {\n  name               = \"myapp-lb\"\n  internal           = false\n\n  subnets = [\n    aws_subnet.public.id\n  ]\n}\n```\n\n```js\nresource \"azurerm_lb\" \"web\" {\n  name                = \"myapp-lb\"\n  location            = azurerm_resource_group.main.location\n  resource_group_name = azurerm_resource_group.main.name\n\n  frontend_ip_configuration {\n    name                 = \"public\"\n    public_ip_address_id = azurerm_public_ip.main.id\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\nMarkdown 포맷으로 DNS\n\n로드 밸런서를 통해 단일 도메인을 라우팅합니다:\n\n```js\nresource \"aws_route53_zone\" \"main\" {\n  name = \"myapp.com\"\n}\n```\n\n```js\nresource \"aws_route53_record\" \"webapp\" {\n  zone_id = aws_route53_zone.main.id\n  name    = \"webapp.myapp.com\"\n  type = \"CNAME\"\n  ttl  = \"300\"\n  records = [aws_lb.web.dns_name]\n}\nresource \"azurerm_dns_cname_record\" \"webapp\" {\n  name                = \"webapp\"\n  zone_name           = azurerm_dns_zone.main.name\n  resource_group_name = azurerm_resource_group.main.name\n  ttl                 = 300\n  record              = azurerm_lb.web.fqdn\n}\n```\n\n<div class=\"content-ad\"></div>\n\n이는 웹 애플리케이션을 다중 클라우드에서 실행하기 위한 핵심 인프라를 제공하며, 로드 밸런싱과 DNS를 통해 연결됩니다.\n\n테라폼 추상화는 우리에게 클라우드 플랫폼 간에 일관된 방식으로 아키텍처를 표현할 수 있는 기회를 제공합니다. 배포를 확장하고 필요에 따라 데이터베이스, 객체 저장소 및 캐시와 같은 추가 구성 요소를 추가할 수 있습니다.\n\n# 결론\n\n이 블로그에서는 테라폼을 사용하여 다중 클라우드 인프라, 네트워킹, 배포, 테스트 및 모니터링을 관리하는 패턴과 모범 사례를 다루었습니다.\n\n<div class=\"content-ad\"></div>\n\n- 추상화 — 추상화된 공급자 및 리소스를 사용하여 이식 가능한 구성물 생성\n- 모듈 — 복잡한 구성 요소를 재사용 가능한 모듈로 캡슐화\n- 상태 — 협업 가능하도록 원격 상태 저장\n- 네트워킹 — VPC와 VNET 간의 연결성 조정\n- 배포 — 블루-그린, 카나리아, 다중 지역 패턴 사용\n- 테스트 — 테스트 환경의 자동 프로비저닝\n- 가시성 — 로그, 메트릭 및 추적을 중앙 집중화\n\n테라폼은 각종 공용 클라우드, 개인 데이터 센터 및 SaaS 환경에서 인프라를 프로비저닝하고 관리하기 위한 일관된 워크플로우를 제공합니다. 이 가이드에서 다룬 패턴을 사용하면 다양한 API, 플랫폼 및 토폴로지를 연결하여 다중 클라우드 자동화 및 오케스트레이션을 더 쉽게 구현할 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-05-27-MasteringMulti-CloudManagementwithTerraform_0.png"},"coverImage":"/assets/img/2024-05-27-MasteringMulti-CloudManagementwithTerraform_0.png","tag":["Tech"],"readingTime":15},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p>여러 공개 클라우드(Azure, AWS, GCP 등)를 사용하면 유연성을 제공하고 비용을 최적화하며 벤더 락인을 줄일 수 있습니다. 그러나 다양한 클라우드 플랫폼 간에 인프라 및 서비스를 관리하는 것은 어렵습니다.</p>\n<p>테라폼을 통해 일관되고 자동화된 멀티 클라우드 관리가 가능한지 알아봅시다. 이 포함사항은 멀티 클라우드 아키텍처, 테라폼 추상화, 프로비저닝, 거버넌스, 네트워킹, 배포 패턴, 테스팅, 그리고 Azure 및 GCP 전반적인 모니터링입니다.</p>\n<h1>개요</h1>\n<p>다음 주제를 다룰 것입니다:</p>\n<ul>\n<li>테라폼을 사용한 멀티 클라우드 아키텍처</li>\n<li>인프라 차이점 추상화</li>\n<li>리소스 프로비저닝 및 의존성 관리</li>\n<li>정책 강화 및 거버넌스</li>\n<li>네트워킹 토폴로지와 연결</li>\n<li>블루-그린, 카나리아, 멀티 리전 배포 패턴</li>\n<li>통합 테스트 및 목 객체(Mock) 사용</li>\n<li>중앙 집중식 로깅, 메트릭 및 관찰 가능성</li>\n</ul>\n<p>이 코드 예제들은 테라폼을 사용해 Azure와 GCP로 인프라 및 서비스를 배포하는 방법을 보여줍니다. 이는 테라폼을 일관된 추상화 계층으로 사용하여 실제 멀티 클라우드 관리를 보여줍니다.</p>\n<h1>멀티 클라우드 아키텍처</h1>\n<p>기본적인 멀티 클라우드 아키텍처는 Terraform을 사용하면 다음과 같이 보입니다:</p>\n<p>Terraform은 여러 클라우드 계정에 인프라를 프로비저닝하고 플랫폼 간의 차이를 추상화합니다. 상태는 원격으로 저장되며 계정 간에 공유됩니다.</p>\n<p>멀티 클라우드 아키텍처를 위한 몇 가지 주요 디자인 원칙:</p>\n<ul>\n<li>차이 추상화 — 공급자별 논리를 최소화하고 차이를 추상화 뒤에 숨깁니다</li>\n<li>환경 모듈화 — 환경 및 구성 요소별로 모듈화된 파일로 구성을 분리합니다</li>\n<li>표준화된 네이밍 — 쉽게 연관을 확인하기 위해 클라우드 간에 일관된 네이밍 체계 사용</li>\n<li>정책 캡슐화 — 정책 및 거버넌스 규칙을 모듈화된 재사용 가능한 파일에 유지합니다</li>\n<li>상태 중앙화 — 원격 상태를 사용하여 서비스 및 클라우드 전체의 상태를 공유합니다</li>\n<li>공유 서비스 추출 — ID, DNS, CDN과 같은 공유 서비스를 한 번 빌드하고 재사용합니다</li>\n<li>파이프라인 통합 — 모든 클라우드 대상으로 배포하는 표준 CI/CD 파이프라인 사용</li>\n</ul>\n<p>이러한 원칙을 따라서, 여러 대상 클라우드 간에 일관성있는 이동 가능한 구성을 구축할 수 있습니다.</p>\n<p>그 다음으로, Terraform이 클라우드 간의 차이를 추상화하는 데 어떻게 도움을 주는지 살펴보겠습니다.</p>\n<h1>인프라 추상화</h1>\n<p>Terraform의 강점 중 하나는 클라우드 플랫폼 간의 차이를 추상화하는 균일한 추상화 계층을 제공할 수 있는 능력입니다.</p>\n<p>예를 들어, Azure 대 GCP에서 MySQL 데이터베이스 프로비저닝:</p>\n<p>Azure</p>\n<pre><code class=\"hljs language-js\">resource <span class=\"hljs-string\">\"azurerm_mysql_server\"</span> <span class=\"hljs-string\">\"db\"</span> {\n  name                = <span class=\"hljs-string\">\"mysqlserver\"</span>\n  location            = <span class=\"hljs-string\">\"eastus\"</span>\n  resource_group_name = azurerm_resource_group.<span class=\"hljs-property\">rg</span>.<span class=\"hljs-property\">name</span>\n</code></pre>\n<pre><code class=\"hljs language-js\">  sku {\n    name     = <span class=\"hljs-string\">\"B_Gen5_2\"</span>\n    capacity = <span class=\"hljs-number\">2</span>\n  }\n}\nresource <span class=\"hljs-string\">\"azurerm_mysql_database\"</span> <span class=\"hljs-string\">\"db\"</span> {\n  name                = <span class=\"hljs-string\">\"mydatabase\"</span>\n  resource_group_name = azurerm_resource_group.<span class=\"hljs-property\">rg</span>.<span class=\"hljs-property\">name</span>\n  server_name         = azurerm_mysql_server.<span class=\"hljs-property\">db</span>.<span class=\"hljs-property\">name</span>\n  charset             = <span class=\"hljs-string\">\"utf8\"</span>\n  collation           = <span class=\"hljs-string\">\"utf8_unicode_ci\"</span>\n}\n</code></pre>\n<p>GCP</p>\n<pre><code class=\"hljs language-js\">resource <span class=\"hljs-string\">\"google_sql_database_instance\"</span> <span class=\"hljs-string\">\"db\"</span> {\n  name             = <span class=\"hljs-string\">\"mysql-instance\"</span>\n  database_version = <span class=\"hljs-string\">\"MYSQL_5_7\"</span>\n  region           = <span class=\"hljs-string\">\"us-central1\"</span>\n</code></pre>\n<pre><code class=\"hljs language-js\">  settings {\n    tier = <span class=\"hljs-string\">\"db-f1-micro\"</span>\n  }\n}\nresource <span class=\"hljs-string\">\"google_sql_database\"</span> <span class=\"hljs-string\">\"database\"</span> {\n  name     = <span class=\"hljs-string\">\"my-database\"</span>\n  instance = google_sql_database_instance.<span class=\"hljs-property\">db</span>.<span class=\"hljs-property\">name</span>\n}\n</code></pre>\n<p>Terraform의 리소스 유형은 일관된 인터페이스를 제공하기 위해 기본 API 차이를 추상화합니다.</p>\n<p>이 추상화는 대규모 변경없이 클라우드 간에 쉽게 전환할 수 있도록 도와줍니다. 필요한 경우 각 클라우드 공급업체에 맞게 엣지에서 맞춤 설정할 수 있습니다.</p>\n<p>테라폼이 다중 클라우드 추상화를 제공하는 주요 분야 몇 가지:</p>\n<ul>\n<li>컴퓨팅 — 가상 머신, 컨테이너, 쿠버네티스, 스케일링</li>\n<li>네트워크 — 서브넷, 라우팅, 보안 그룹, 로드 밸런싱</li>\n<li>스토리지 — 블롭, 디스크, 데이터베이스</li>\n<li>아이덴티티 — 역할, 권한, 액세스 제어</li>\n<li>인프라스트럭처 — DNS, VPN, 규칙, 정책</li>\n</ul>\n<p>최대한 다중 클라우드 추상화를 활용하여 구성을 작성하면 이동성이 높아집니다.</p>\n<h1>프로비저닝 및 의존성</h1>\n<p>여러 클라우드 인프라를 프로비저닝할 때 가장 좋은 방법은 리소스를 의존성 레이어로 구조화하는 것입니다.</p>\n<p>상위 수준의 구성은 하위 수준의 구성을 의존합니다. 예를 들어:</p>\n<p>테라폼을 사용할 때, depends_on 속성을 사용하여 리소스 의존성을 명시적으로 정의하세요:</p>\n<pre><code class=\"hljs language-md\">리소스 \"azurerm<span class=\"hljs-emphasis\">_subnet\" \"public\" {\n#...\n}\n</span></code></pre>\n<pre><code class=\"hljs language-md\">리소스 \"azurerm<span class=\"hljs-emphasis\">_network_</span>interface\" \"nic\" {\n<span class=\"hljs-section\">#...</span>\nsubnet<span class=\"hljs-emphasis\">_id = azurerm_</span>subnet.public.id\n}\n리소스 \"azurerm<span class=\"hljs-emphasis\">_virtual_</span>machine\" \"main\" {\n<span class=\"hljs-section\">#...</span>\n\nnetwork<span class=\"hljs-emphasis\">_interface_</span>ids = [\nazurerm<span class=\"hljs-emphasis\">_network_</span>interface.nic.id,\n]\ndepends<span class=\"hljs-emphasis\">_on = [\nazurerm_</span>network<span class=\"hljs-emphasis\">_interface.nic\n]\n}\n</span></code></pre>\n<p>테라폼은 리소스 간 종속성을 분석하고 변경 사항을 올바른 순서로 적용합니다.</p>\n<p>멀티 클라우드 환경에서의 종속성에 대한 팁:</p>\n<ul>\n<li>공통 빌딩 블록을 기본 모듈에 네트워크와 같은 것으로 포함시킵니다.</li>\n<li>독립적인 구성 요소를 계층별로 분리합니다.</li>\n<li>암시적이어도 <code>depends_on</code>을 명시적으로 정의합니다.</li>\n<li>데드락을 일으키는 종속성 순환이 있는지 확인합니다.</li>\n<li>종속성 순서대로 계획하고 적용합니다.</li>\n</ul>\n<p>자원 종속성을 올바르게 설정하는 것이 여러 클라우드에서 원활한 프로비저닝을 위해 중요합니다.</p>\n<h1>정책 집행과 거버넌스</h1>\n<p>기관 정책과 규정 준수 요구사항을 강제하는 것은 여러 클라우드 관리에 있어 중요합니다.</p>\n<p>다음은 운용 규칙의 몇 가지 예시입니다:</p>\n<ul>\n<li>VM 유형 제한</li>\n<li>데이터 주권을 위한 지역 및 존 제어</li>\n<li>태깅 규칙과 표준 설정</li>\n<li>네트워킹 노출 제한</li>\n<li>암호화 요구 사항 강제</li>\n<li>고위험 자원 사용 제한</li>\n</ul>\n<p>테라폼을 통해 정책 강제를 활성화할 수 있습니다:</p>\n<p>변수</p>\n<p>허용된 값 제한:</p>\n<pre><code class=\"hljs language-js\">variable <span class=\"hljs-string\">\"region\"</span> {\n  type    = string\n  <span class=\"hljs-keyword\">default</span> = <span class=\"hljs-string\">\"us-east-1\"</span>\n}\n</code></pre>\n<pre><code class=\"hljs language-js\">resource <span class=\"hljs-string\">\"aws_db_instance\"</span> <span class=\"hljs-string\">\"db\"</span> {\n  region = <span class=\"hljs-keyword\">var</span>.<span class=\"hljs-property\">region</span> # us-east-<span class=\"hljs-number\">1</span>만 허용됩니다\n}\n</code></pre>\n<p>모듈</p>\n<p>친구야, 모듈 내에서 지배 논리를 캡슐화하고 재사용하세요:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable language_\">module</span> <span class=\"hljs-string\">\"server\"</span> {\n  source = <span class=\"hljs-string\">\"./modules/certified_server\"</span>\n# 인증된 서버는 합리적인 기본값을 설정합니다\n}\n</code></pre>\n<p>Sentinel 정책</p>\n<p>리소스를 제한하는 대상 정책을 적용하십시오:</p>\n<pre><code class=\"hljs language-js\">aws_instance_disallowed_type = rule {\n  all aws_instance <span class=\"hljs-keyword\">as</span> _, instance {\n    instance.<span class=\"hljs-property\">instance_type</span> is not <span class=\"hljs-keyword\">in</span> [<span class=\"hljs-string\">\"t2.micro\"</span>, <span class=\"hljs-string\">\"t3.micro\"</span>]\n  }\n}\n</code></pre>\n<p>이러한 메커니즘은 구성에 직접 규제를 포함하여 규정 준수를 쉽게 만듭니다.</p>\n<h1>네트워킹 토폴로지</h1>\n<p>다양한 클라우드 간 네트워크 연결성을 관리하는 것은 복잡성을 증가시킵니다. 일부 하이브리드 클라우드 네트워크 토폴로지는 다음과 같습니다:```</p>\n<p>테이블 형식을 Markdown 형식으로 변경하실래요.</p>\n<table>\n<thead>\n<tr>\n<th>Pairing</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Connect cloud regions to on-prem data centers. Useful for migration and hybrid workloads.</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th>Hub-and-Spoke</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Central hub VPC with connectivity to multiple cloud spokes. Enables transitivity between spokes.</td>\n</tr>\n</tbody>\n</table>\n<p>메시</p>\n<p>클라우드 간 사이트 간 VPN이 구성된 완전히 메시된 네트워크입니다. 지역 간 직접 통신을 제공합니다.</p>\n<p>테라폼은 terraform-provider-aws, terraform-provider-azurerm 및 유사한 네트워킹 제공업체를 통해 이러한 네트워크 토폴로지를 조정하는 것을 단순화합니다.</p>\n<p>예를 들어, AWS에서 Azure로 사이트 간 VPN을 생성하는 방법:</p>\n<pre><code class=\"hljs language-js\"># <span class=\"hljs-variable constant_\">AWS</span> 측\n리소스 <span class=\"hljs-string\">\"aws_customer_gateway\"</span> <span class=\"hljs-string\">\"gw\"</span> {\n  bgp_asn    = <span class=\"hljs-number\">65002</span>\n  ip_address = <span class=\"hljs-string\">\"172.0.0.1\"</span>\n  type       = <span class=\"hljs-string\">\"ipsec.1\"</span>\n}\n</code></pre>\n<pre><code class=\"hljs language-js\">리소스 <span class=\"hljs-string\">\"aws_vpn_connection\"</span> <span class=\"hljs-string\">\"main\"</span> {\n  vpn_gateway_id      = aws_vpn_gateway.<span class=\"hljs-property\">vgw</span>.<span class=\"hljs-property\">id</span>\n  customer_gateway_id = aws_customer_gateway.<span class=\"hljs-property\">gw</span>.<span class=\"hljs-property\">id</span>\n  type                = <span class=\"hljs-string\">\"ipsec.1\"</span>\n  static_routes_only  = <span class=\"hljs-literal\">true</span>\n  tunnel1_ike_versions   = [<span class=\"hljs-string\">\"ikev2\"</span>]\n  tunnel2_ike_versions   = [<span class=\"hljs-string\">\"ikev2\"</span>]\n  tunnel1_phase1_dh_group_numbers = [<span class=\"hljs-number\">31</span>]\n  tunnel2_phase1_dh_group_numbers = [<span class=\"hljs-number\">31</span>]\n}\n# <span class=\"hljs-title class_\">Azure</span> 측\n리소스 <span class=\"hljs-string\">\"azurerm_local_network_gateway\"</span> <span class=\"hljs-string\">\"lgw\"</span> {\n  name                = <span class=\"hljs-string\">\"aws-conn\"</span>\n  resource_group_name = azurerm_resource_group.<span class=\"hljs-property\">rg</span>.<span class=\"hljs-property\">name</span>\n  location            = azurerm_resource_group.<span class=\"hljs-property\">rg</span>.<span class=\"hljs-property\">location</span>\n  gateway_address = aws_customer_gateway.<span class=\"hljs-property\">gw</span>.<span class=\"hljs-property\">ip_address</span>\n  address_space     = [<span class=\"hljs-string\">\"172.16.0.0/16\"</span>]\n}\n리소스 <span class=\"hljs-string\">\"azurerm_virtual_network_gateway_connection\"</span> <span class=\"hljs-string\">\"main\"</span> {\n  name                       = <span class=\"hljs-string\">\"aws-conn\"</span>\n  resource_group_name        = azurerm_resource_group.<span class=\"hljs-property\">rg</span>.<span class=\"hljs-property\">name</span>\n  location                   = azurerm_resource_group.<span class=\"hljs-property\">rg</span>.<span class=\"hljs-property\">location</span>\n  type                       = <span class=\"hljs-string\">\"IPsec\"</span>\n  virtual_network_gateway_id = azurerm_virtual_network_gateway.<span class=\"hljs-property\">vgw</span>.<span class=\"hljs-property\">id</span>\n  local_network_gateway_id   = azurerm_local_network_gateway.<span class=\"hljs-property\">lgw</span>.<span class=\"hljs-property\">id</span>\n  shared_key = aws_vpn_connection.<span class=\"hljs-property\">main</span>.<span class=\"hljs-property\">tunnel1_preshared_key</span>\n\n  ipsec_policy {\n    dh_group         = <span class=\"hljs-string\">\"DHGroup31\"</span>\n    ike_encryption   = <span class=\"hljs-string\">\"AES256\"</span>\n    ike_integrity    = <span class=\"hljs-string\">\"SHA256\"</span>\n    ipsec_encryption = <span class=\"hljs-string\">\"AES256\"</span>\n    ipsec_integrity  = <span class=\"hljs-string\">\"SHA256\"</span>\n    pfs_group        = <span class=\"hljs-string\">\"PFS31\"</span>\n    sa_datasize      = <span class=\"hljs-number\">536870912</span>\n  }\n}\n</code></pre>\n<p>이 방법을 통해 멀티 클라우드에 일관된 방식으로 전체 연결 구성을 정의할 수 있습니다.</p>\n<h1>배포 패턴</h1>\n<p>여러 클라우드로 배포할 때 블루-그린, 카나리아, 다중 지역과 같은 패턴을 사용하면 관리가 간단해질 수 있어요.</p>\n<p>블루-그린</p>\n<p>블루-그린은 새 버전을 병렬로 배포한 다음 트래픽을 원자적으로 전환합니다. 이는 롤백 및 점진적인 롤아웃 기능을 제공합니다.</p>\n<p>예시:</p>\n<pre><code class=\"hljs language-js\"># 파란 환경\n<span class=\"hljs-variable language_\">module</span> <span class=\"hljs-string\">\"blue_env\"</span> {\n  source = <span class=\"hljs-string\">\"./env\"</span>\n  color  = <span class=\"hljs-string\">\"blue\"</span>\n}\n</code></pre>\n<pre><code class=\"hljs language-js\"># 초록 환경\n<span class=\"hljs-variable language_\">module</span> <span class=\"hljs-string\">\"green_env\"</span> {\n  source = <span class=\"hljs-string\">\"./env\"</span>\n  color  = <span class=\"hljs-string\">\"green\"</span>\n  # 처음에는 트래픽이 없음\n  traffic_weight = <span class=\"hljs-number\">0</span>\n}\n# 트래픽 분할기\nresource <span class=\"hljs-string\">\"aws_lb\"</span> <span class=\"hljs-string\">\"main\"</span> {\n  # <span class=\"hljs-number\">100</span>%의 트래픽을 파란 쪽에 보냅니다.\n}\n</code></pre>\n<p>그런 다음 로드 밸런서를 통해 점진적으로 파란 색에서 초록 색으로 트래픽을 이동합니다.</p>\n<p>카나리아</p>\n<p>파란색-초록색처럼 변경되지만 처음에는 일부 사용자에게만 공개됩니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable language_\">module</span> <span class=\"hljs-string\">\"prod_env\"</span> {\n  source = <span class=\"hljs-string\">\"./env\"</span>\n</code></pre>\n<pre><code class=\"hljs language-js\">  # 대부분의 트래픽이 본 프로덕션 환경으로 이동합니다.\n}\n<span class=\"hljs-variable language_\">module</span> <span class=\"hljs-string\">\"canary_env\"</span> {\n  source = <span class=\"hljs-string\">\"./env\"</span>\n  # 소수의 트래픽이 canary로 이동합니다.\n  traffic_weight = <span class=\"hljs-number\">0.1</span>\n}\n</code></pre>\n<p>Multi-Region</p>\n<p>고가용성 및 낮은 대기 시간을 위해 여러 지역에 리소스를 프로비저닝합니다.</p>\n<p>예를 들어:</p>\n<pre><code class=\"hljs language-js\"># 서부 지역\n<span class=\"hljs-variable language_\">module</span> <span class=\"hljs-string\">\"west\"</span> {\n  source = <span class=\"hljs-string\">\"./region\"</span>\n  providers = {\n    azurerm.<span class=\"hljs-property\">west</span> = azurerm.<span class=\"hljs-property\">west</span>\n  }\n}\n</code></pre>\n<pre><code class=\"hljs language-js\"># 동부 지역\n<span class=\"hljs-variable language_\">module</span> <span class=\"hljs-string\">\"east\"</span> {\n  source = <span class=\"hljs-string\">\"./region\"</span>\n  providers = {\n    azurerm.<span class=\"hljs-property\">east</span> = azurerm.<span class=\"hljs-property\">east</span>\n  }\n}\n</code></pre>\n<p>그럼 DNS와 로드 밸런싱을 사용하여 전 세계적으로 분산하세요.</p>\n<p>이러한 패턴은 멀티 클라우드 배포를 간단하게 해줍니다. 모듈 재사용은 일관성을 도와줍니다.</p>\n<h1>통합 테스트</h1>\n<p>여러 클라우드에 걸친 배포를 유효성 검사하려면 자동화된 통합 테스트가 필요합니다.</p>\n<p>테라폼을 사용한 멀티 클라우드 테스팅을 위한 몇 가지 최상의 방법:</p>\n<ul>\n<li>인프라 테스트 — terraform plan 및 terraform show를 사용하여 올바른 구성의 리소스를 검증합니다.</li>\n<li>프로비저닝 테스트 — 처음부터 일회용 테스트 환경을 배포합니다.</li>\n<li>실패 테스트 — 종료된 인스턴스와 같은 실패를 시뮬레이션합니다.</li>\n<li>서비스 테스트 — 목업을 사용하여 서비스 접근성과 동작을 유효성 검사합니다.</li>\n</ul>\n<p>예를 들어, 일회용 테스트 환경을 생성하는 방법:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable language_\">module</span> <span class=\"hljs-string\">\"test_env\"</span> {\n  source = <span class=\"hljs-string\">\"./env\"</span>\n  providers = {\n    aws = aws.<span class=\"hljs-property\">test</span>\n  }\n}\n</code></pre>\n<p>테이블 태그를 Markdown 형식으로 변경해주세요.</p>\n<p>다양한 환경에서 배포를 유효성 검사하려면 자동화된 테스트가 필요합니다.</p>\n<p>Terraform을 사용하는 몇 가지 권장사항:</p>\n<ul>\n<li>사용 및 폐기 가능한 테스트 환경 프로비저닝</li>\n<li>리소스 구성 검증</li>\n<li>다양한 장애 시나리오 시뮬레이션</li>\n<li>의존성에 대한 모의 테스트 사용</li>\n</ul>\n<p>예시:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable language_\">module</span> <span class=\"hljs-string\">\"test_env\"</span> {\n  source = <span class=\"hljs-string\">\"./env\"</span>\n</code></pre>\n<pre><code class=\"hljs language-js\">  # <span class=\"hljs-variable constant_\">AWS</span> 계정 자격 증명 테스트\n}\nresource <span class=\"hljs-string\">\"null_resource\"</span> <span class=\"hljs-string\">\"check_connectivity\"</span> {\n  provisioner <span class=\"hljs-string\">\"local-exec\"</span> {\n    command = <span class=\"hljs-string\">\"ping.exe -n 3 ${module.test_env.ip}\"</span>\n  }\n}\n</code></pre>\n<p>이렇게 하면 안전하게 변경 사항을 테스트할 수 있는 격리된 환경이 생성됩니다.</p>\n<p>다른 예시:</p>\n<ul>\n<li>성능 테스트를 위해 과거 트래픽을 다시 재생합니다.</li>\n<li>종료된 인스턴스와 같은 결함을 주입합니다.</li>\n<li>결정론적 테스트를 위해 외부 서비스를 스텁 처리합니다.</li>\n</ul>\n<p>자동화된 테스트는 구성 요소를 리팩토링할 때 자신감을 유지하는 데 중요합니다.</p>\n<h2>가시성</h2>\n<p>이질적인 클라우드 간 로그, 지표 및 추적에 대한 가시성을 확보하는 것은 어렵습니다.</p>\n<p>테라폼을 사용하면 관측 가능성 데이터를 공유 플랫폼에 집계할 수 있습니다:</p>\n<p>로그 기능</p>\n<pre><code class=\"hljs language-js\">resource <span class=\"hljs-string\">\"aws_cloudwatch_log_group\"</span> <span class=\"hljs-string\">\"app\"</span> {\n  name = <span class=\"hljs-string\">\"/aws/lambda/app\"</span>\n}\nresource <span class=\"hljs-string\">\"azurerm_monitor_diagnostic_setting\"</span> <span class=\"hljs-string\">\"app\"</span> {\n  name               = <span class=\"hljs-string\">\"diag\"</span>\n  target_resource_id = azurerm_function_app.<span class=\"hljs-property\">app</span>.<span class=\"hljs-property\">id</span>\n  log_analytics_workspace_id = azurerm_log_analytics_workspace.<span class=\"hljs-property\">main</span>.<span class=\"hljs-property\">id</span>\n  log {\n    category = <span class=\"hljs-string\">\"FunctionAppLogs\"</span>\n    enabled  = <span class=\"hljs-literal\">true</span>\n  }\n}\nresource <span class=\"hljs-string\">\"google_logging_project_sink\"</span> <span class=\"hljs-string\">\"app\"</span> {\n  name        = <span class=\"hljs-string\">\"app-sink\"</span>\n  destination = google_storage_bucket.<span class=\"hljs-property\">logs</span>.<span class=\"hljs-property\">name</span>\n}\n</code></pre>\n<p>Splunk와 같은 도구에서 로그를 중앙 집계하세요.</p>\n<p>메트릭</p>\n<pre><code class=\"hljs language-js\">리소스 <span class=\"hljs-string\">\"signalfx_detector\"</span> <span class=\"hljs-string\">\"지연시간\"</span> {\n  이름 = <span class=\"hljs-string\">\"높은 지연시간\"</span>\n  프로그램_텍스트 = &#x3C;&#x3C;-<span class=\"hljs-variable constant_\">EOF</span>\n    A = 데이터(<span class=\"hljs-string\">'지연시간'</span>, 필터=필터(<span class=\"hljs-string\">'클라우드'</span>, <span class=\"hljs-string\">'*'</span>) and 필터(<span class=\"hljs-string\">'환경'</span>, <span class=\"hljs-string\">'*'</span>)).게시(label=<span class=\"hljs-string\">'A'</span>)\n    B = (A).합계(by=[<span class=\"hljs-string\">'클라우드'</span>, <span class=\"hljs-string\">'환경'</span>]).게시(label=<span class=\"hljs-string\">'B'</span>)\n    <span class=\"hljs-title function_\">detect</span>(<span class=\"hljs-title function_\">when</span>(B > <span class=\"hljs-number\">1000</span>, <span class=\"hljs-string\">'5m'</span>)).게시(<span class=\"hljs-string\">'높은 지연시간!'</span>)\n  <span class=\"hljs-variable constant_\">EOF</span>\n}\n</code></pre>\n<p>Datadog와 같은 플랫폼에서 메트릭을 통합해보세요.</p>\n<p>트레이싱</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable language_\">module</span> <span class=\"hljs-string\">\"opentelemetry\"</span> {\n  source = <span class=\"hljs-string\">\"./opentelemetry\"</span>\n  providers = {\n    aws = aws\n    azure = azurerm\n    google = google\n  }\n}\n</code></pre>\n<p>일반적인 형식으로 OpenTelemetry을 사용하면 추적을 쉽게 연결할 수 있어요.</p>\n<p>테라폼을 사용하면 다양한 플랫폼 사이에서 공유 관찰 패턴을 구축할 수 있어요.</p>\n<h1>예시: 멀티-클라우드 웹 애플리케이션</h1>\n<p>실제로 멀티 클라우드 웹 애플리케이션을 Terraform으로 배포하는 실제 사례를 살펴봅시다.</p>\n<p>AWS ECS 및 Azure Container Instances (ACI)의 클러스터 전체에 애플리케이션 인프라를 배포할 것입니다. 글로벌 로드 밸런서가 트래픽을 플랫폼 간에 분배할 것입니다.</p>\n<p>네트워킹</p>\n<p>먼저, AWS VPC와 Azure VNet을 연결해야 합니다.</p>\n<pre><code class=\"hljs language-js\"># <span class=\"hljs-variable constant_\">AWS</span> <span class=\"hljs-variable constant_\">VPC</span> 및 서브넷\nresource <span class=\"hljs-string\">\"aws_vpc\"</span> <span class=\"hljs-string\">\"main\"</span> {\n  cidr_block = <span class=\"hljs-string\">\"10.1.0.0/16\"</span>\n}\n</code></pre>\n<pre><code class=\"hljs language-js\">resource <span class=\"hljs-string\">\"aws_subnet\"</span> <span class=\"hljs-string\">\"public\"</span> {\n  vpc_id = aws_vpc.<span class=\"hljs-property\">main</span>.<span class=\"hljs-property\">id</span>\n  cidr_block = <span class=\"hljs-string\">\"10.1.1.0/24\"</span>\n}\n# <span class=\"hljs-title class_\">Azure</span> <span class=\"hljs-title class_\">VNet</span>\nresource <span class=\"hljs-string\">\"azurerm_virtual_network\"</span> <span class=\"hljs-string\">\"main\"</span> {\n  name                = <span class=\"hljs-string\">\"app-network\"</span>\n  address_space       = [<span class=\"hljs-string\">\"10.2.0.0/16\"</span>]\n}\nresource <span class=\"hljs-string\">\"azurerm_subnet\"</span> <span class=\"hljs-string\">\"public\"</span> {\n  name                 = <span class=\"hljs-string\">\"public-subnet\"</span>\n  resource_group_name  = azurerm_resource_group.<span class=\"hljs-property\">main</span>.<span class=\"hljs-property\">name</span>\n  virtual_network_name = azurerm_virtual_network.<span class=\"hljs-property\">main</span>.<span class=\"hljs-property\">name</span>\n  address_prefixes     = [<span class=\"hljs-string\">\"10.2.1.0/24\"</span>]\n}\n</code></pre>\n<p>VPC 피어링을 통해 이들을 연결하십시오:</p>\n<pre><code class=\"hljs language-js\"># <span class=\"hljs-variable constant_\">AWS</span> 쪽 피어링\nresource <span class=\"hljs-string\">\"aws_vpc_peering_connection\"</span> <span class=\"hljs-string\">\"peer\"</span> {\n  vpc_id      = aws_vpc.<span class=\"hljs-property\">main</span>.<span class=\"hljs-property\">id</span>\n  peer_vpc_id = azurerm_virtual_network.<span class=\"hljs-property\">main</span>.<span class=\"hljs-property\">id</span>\n  auto_accept = <span class=\"hljs-literal\">true</span>\n}\n</code></pre>\n<pre><code class=\"hljs language-js\"># <span class=\"hljs-title class_\">Azure</span> 측 피어링\nresource <span class=\"hljs-string\">\"azurerm_virtual_network_peering\"</span> <span class=\"hljs-string\">\"peer\"</span> {\n  name                      = <span class=\"hljs-string\">\"peer-aws\"</span>\n  resource_group_name       = azurerm_resource_group.<span class=\"hljs-property\">main</span>.<span class=\"hljs-property\">name</span>\n  virtual_network_name      = az\n</code></pre>\n<p>컴퓨팅</p>\n<p>Azure Container Instances 배포:</p>\n<pre><code class=\"hljs language-js\">resource <span class=\"hljs-string\">\"azurerm_container_group\"</span> <span class=\"hljs-string\">\"app\"</span> {\n  name                = <span class=\"hljs-string\">\"app-aci\"</span>\n  location            = azurerm_resource_group.<span class=\"hljs-property\">main</span>.<span class=\"hljs-property\">location</span>\n  resource_group_name = azurerm_resource_group.<span class=\"hljs-property\">main</span>.<span class=\"hljs-property\">name</span>\n  ip_address_type     = <span class=\"hljs-string\">\"public\"</span>\n  dns_name_label      = <span class=\"hljs-string\">\"app-aci\"</span>\n  os_type             = <span class=\"hljs-string\">\"Linux\"</span>\n</code></pre>\n<pre><code class=\"hljs language-js\">  container {\n    name   = <span class=\"hljs-string\">\"app\"</span>\n    image  = <span class=\"hljs-string\">\"myapp:v1\"</span>\n    cpu    = <span class=\"hljs-string\">\"1\"</span>\n    memory = <span class=\"hljs-string\">\"1\"</span>\n    ports {\n      port     = <span class=\"hljs-number\">80</span>\n      protocol = <span class=\"hljs-string\">\"TCP\"</span>\n    }\n  }\n</code></pre>\n<p>아마존 ECS 클러스터 및 서비스:</p>\n<pre><code class=\"hljs language-js\">resource <span class=\"hljs-string\">\"aws_ecs_cluster\"</span> <span class=\"hljs-string\">\"main\"</span> {\n  name = <span class=\"hljs-string\">\"myapp-cluster\"</span>\n}\n</code></pre>\n<pre><code class=\"hljs language-js\">resource <span class=\"hljs-string\">\"aws_ecs_service\"</span> <span class=\"hljs-string\">\"web\"</span> {\n  name            = <span class=\"hljs-string\">\"web\"</span>\n  cluster         = aws_ecs_cluster.<span class=\"hljs-property\">main</span>.<span class=\"hljs-property\">id</span>\n  task_definition = aws_ecs_task_definition.<span class=\"hljs-property\">app</span>.<span class=\"hljs-property\">arn</span>\n  desired_count   = <span class=\"hljs-number\">3</span>\n  launch_type     = <span class=\"hljs-string\">\"FARGATE\"</span>\n}\n</code></pre>\n<p>로드 밸런싱</p>\n<p>각 클라우드에 백엔드가 있는 글로벌 로드 밸런서를 배포하십시오:</p>\n<pre><code class=\"hljs language-js\">resource <span class=\"hljs-string\">\"aws_lb\"</span> <span class=\"hljs-string\">\"web\"</span> {\n  name               = <span class=\"hljs-string\">\"myapp-lb\"</span>\n  internal           = <span class=\"hljs-literal\">false</span>\n\n  subnets = [\n    aws_subnet.<span class=\"hljs-property\">public</span>.<span class=\"hljs-property\">id</span>\n  ]\n}\n</code></pre>\n<pre><code class=\"hljs language-js\">resource <span class=\"hljs-string\">\"azurerm_lb\"</span> <span class=\"hljs-string\">\"web\"</span> {\n  name                = <span class=\"hljs-string\">\"myapp-lb\"</span>\n  location            = azurerm_resource_group.<span class=\"hljs-property\">main</span>.<span class=\"hljs-property\">location</span>\n  resource_group_name = azurerm_resource_group.<span class=\"hljs-property\">main</span>.<span class=\"hljs-property\">name</span>\n\n  frontend_ip_configuration {\n    name                 = <span class=\"hljs-string\">\"public\"</span>\n    public_ip_address_id = azurerm_public_ip.<span class=\"hljs-property\">main</span>.<span class=\"hljs-property\">id</span>\n  }\n}\n</code></pre>\n<p>Markdown 포맷으로 DNS</p>\n<p>로드 밸런서를 통해 단일 도메인을 라우팅합니다:</p>\n<pre><code class=\"hljs language-js\">resource <span class=\"hljs-string\">\"aws_route53_zone\"</span> <span class=\"hljs-string\">\"main\"</span> {\n  name = <span class=\"hljs-string\">\"myapp.com\"</span>\n}\n</code></pre>\n<pre><code class=\"hljs language-js\">resource <span class=\"hljs-string\">\"aws_route53_record\"</span> <span class=\"hljs-string\">\"webapp\"</span> {\n  zone_id = aws_route53_zone.<span class=\"hljs-property\">main</span>.<span class=\"hljs-property\">id</span>\n  name    = <span class=\"hljs-string\">\"webapp.myapp.com\"</span>\n  type = <span class=\"hljs-string\">\"CNAME\"</span>\n  ttl  = <span class=\"hljs-string\">\"300\"</span>\n  records = [aws_lb.<span class=\"hljs-property\">web</span>.<span class=\"hljs-property\">dns_name</span>]\n}\nresource <span class=\"hljs-string\">\"azurerm_dns_cname_record\"</span> <span class=\"hljs-string\">\"webapp\"</span> {\n  name                = <span class=\"hljs-string\">\"webapp\"</span>\n  zone_name           = azurerm_dns_zone.<span class=\"hljs-property\">main</span>.<span class=\"hljs-property\">name</span>\n  resource_group_name = azurerm_resource_group.<span class=\"hljs-property\">main</span>.<span class=\"hljs-property\">name</span>\n  ttl                 = <span class=\"hljs-number\">300</span>\n  record              = azurerm_lb.<span class=\"hljs-property\">web</span>.<span class=\"hljs-property\">fqdn</span>\n}\n</code></pre>\n<p>이는 웹 애플리케이션을 다중 클라우드에서 실행하기 위한 핵심 인프라를 제공하며, 로드 밸런싱과 DNS를 통해 연결됩니다.</p>\n<p>테라폼 추상화는 우리에게 클라우드 플랫폼 간에 일관된 방식으로 아키텍처를 표현할 수 있는 기회를 제공합니다. 배포를 확장하고 필요에 따라 데이터베이스, 객체 저장소 및 캐시와 같은 추가 구성 요소를 추가할 수 있습니다.</p>\n<h1>결론</h1>\n<p>이 블로그에서는 테라폼을 사용하여 다중 클라우드 인프라, 네트워킹, 배포, 테스트 및 모니터링을 관리하는 패턴과 모범 사례를 다루었습니다.</p>\n<ul>\n<li>추상화 — 추상화된 공급자 및 리소스를 사용하여 이식 가능한 구성물 생성</li>\n<li>모듈 — 복잡한 구성 요소를 재사용 가능한 모듈로 캡슐화</li>\n<li>상태 — 협업 가능하도록 원격 상태 저장</li>\n<li>네트워킹 — VPC와 VNET 간의 연결성 조정</li>\n<li>배포 — 블루-그린, 카나리아, 다중 지역 패턴 사용</li>\n<li>테스트 — 테스트 환경의 자동 프로비저닝</li>\n<li>가시성 — 로그, 메트릭 및 추적을 중앙 집중화</li>\n</ul>\n<p>테라폼은 각종 공용 클라우드, 개인 데이터 센터 및 SaaS 환경에서 인프라를 프로비저닝하고 관리하기 위한 일관된 워크플로우를 제공합니다. 이 가이드에서 다룬 패턴을 사용하면 다양한 API, 플랫폼 및 토폴로지를 연결하여 다중 클라우드 자동화 및 오케스트레이션을 더 쉽게 구현할 수 있습니다.</p>\n</body>\n</html>\n"},"__N_SSG":true}