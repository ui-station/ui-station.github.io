{"pageProps":{"post":{"title":"유용한 정보 공유 - 소셜 미디어에서 Composables 사용하는 방법","description":"","date":"2024-05-23 12:51","slug":"2024-05-23-SomethingWorthSharingHowtouseComposablesonSocialMedia","content":"\n\n![Screenshot](/assets/img/2024-05-23-SomethingWorthSharingHowtouseComposablesonSocialMedia_0.png)\n\n# 사진이 없으면 일어나지 않았어요\n\n인스타그램 게시물은 황홀한 모험의 마무리 또는 무기화된 FOMO의 조각일 수 있어요. 어쨌든 사람들은 자신의 하이라이트와 취미를 소셜 미디어에 기억하기를 좋아해요.\n\n최근에 Viz 앱에 공유 기능을 추가했어요. 이제 다이버와 스노클러도 이 의식에 참여할 수 있어요. 당시에는 Compose에서 생성된 아름다운 뷰를 Instagram, TikTok, Twitter 등에서 공유 가능한 이미지로 어떻게 변환하는지에 대해 온라인에 많이 쓰여 있지 않았어요.\n\n<div class=\"content-ad\"></div>\n\n이제 다른 쪽으로 나와서 스스로 구현하는 방법을 안내해 드릴게요! 순서는 대략 다음과 같아요:\n\n- 공유하고 싶은 모든 콘텐츠를 포함하는 컴포저블 만들기\n- 컴포저블을 이미지로 변환하기\n- 안드로이드의 Sharesheet를 사용하여 이미지를 공유하기\n\n제가 공유된 백 엔드 코드를 작성할 때 KMP를 사용하고 있지만, UI는 Android 및 iOS에 대해 별도로 네이티브로 작성했어요. Android 버전은 아래에 작성되어 있고 SwiftUI 버전은 다음 주 별도의 기사에서 공유될 예정이에요!\n\n# 공유 가능한 형식 디자인하기\n\n<div class=\"content-ad\"></div>\n\n삼격하고 상대적으로 높은 이동성을 가지고 있는 정사각형은 모든 소셜 미디어 플랫폼에서 최적의 화면 비율이에요. 인스타그램을 예로 들어보면—이 모양은 스크롤 피드에서 \"게시물\"로 공유되거나 전체 화면 \"스토리\"에 쉽게 가운데 정렬될 수 있어요.\n\n이 이상적인 크기는 두 가지 요소에 따라 다릅니다:\n\n- 이미지로 공유될 때 선명하고 뚜렷하게 보이기 위한 충분한 세부 정보가 있는 크기\n- 디자인 시스템에서 폰트 스타일 토큰을 수용할 수 있는 크기 (원시 작성, Material3 또는 다른 것)\n\n저는 안드로이드에서 400.dp부터 500.dp 크기가 이 두 목표를 모두 잘 이루어낼 수 있다고 생각해요. 대부분의 휴대폰에서 전체 화면 크기로 변환될 거예요. 그리고 이 크기에서 '제목', '헤드라인', '본문'과 같은 폰트 스타일을 사용하면 본인만의 원시 폰트 크기를 계산할 필요 없이 손쉽게 사용할 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n```kotlin\n@Composable\nfun MyShareContent() {\n    val headline = MaterialTheme.typography.headlineLarge\n    val title = MaterialTheme.typography.titleLarge\n\n    Box(\n        modifier = Modifier\n            .size(400.dp)\n            .background(color = MaterialTheme.colorScheme.surface)\n    ) {\n        Column(\n            verticalArrangement = Arrangement.SpaceBetween,\n            horizontalAlignment = Alignment.CenterHorizontally,\n            modifier = Modifier\n                .padding(12.dp)\n                .fillMaxSize(),\n        ) {\n            Icon(\n                painter = painterResource(id = R.drawable.v3_logo_with_text),\n                tint = Color.Unspecified, // 원본 SVG 색상 유지\n                contentDescription = null,\n                modifier = Modifier.height(200.dp)\n            )\n            Text(text = \"Moon Bay Marine Reserve\", style = headline)\n\n            Row(\n                horizontalArrangement = Arrangement.SpaceBetween,\n                modifier = Modifier.fillMaxWidth()\n            ) {\n                Text(text = \"Date\", style = title)\n                Text(text = \"Thursday 10 April 2024\", style = title)\n            }\n\n            Row(\n                horizontalArrangement = Arrangement.SpaceBetween,\n                modifier = Modifier.fillMaxWidth()\n            ) {\n                Text(text = \"Time\", style = title)\n                Text(text = \"10:20 - 11:45\", style = title)\n            }\n        }\n    }\n}\n```\n\n![Image](/assets/img/2024-05-23-SomethingWorthSharingHowtouseComposablesonSocialMedia_1.png)\n\n# 그래픽 레이어에 Composable 기록하기\n\nCompose의 최신 버전(1.7)에서는 훌륭한 GraphicsLayer API가 소개되었습니다. 이는 Composable의 그리기를 캡처하고 다른 위치에서 재생하는 방법을 제공합니다. 결국 이를 사용하여 Composable을 이미지 파일로 기록할 것입니다.\n\n\n<div class=\"content-ad\"></div>\n\n```kotlin\nvar graphicsLayer = rememberGraphicsLayer()\n\nBox(modifier = Modifier\n    .size(400.dp)\n    .drawWithCache {\n        // draw to graphics layer\n        graphicsLayer = obtainGraphicsLayer().apply {\n            record { drawContent() }\n        }\n        // draw to actual UI\n        onDrawWithContent { drawContent() }\n    }) {\n    // The content being recorded\n    Surface(modifier = Modifier.fillMaxSize()) {\n        MyShareContent()\n    }\n}\n```\n\n이 코드 스니펫의 주요 기능:\n\n- Box를 부모 컨테이너로 사용\n- 공유하려는 컴포저블을 Box의 콘텐츠 매개변수에 배치\n- drawWithCache 수정자를 사용하여 콘텐츠의 그리기를 캡처\n- record 메서드를 사용하여 그림을 저장된 graphicsLayer 변수로 리디렉션\n\n# 컴포저블 그리기를 완전히 건너뛰기\n  \n\n<div class=\"content-ad\"></div>\n\n컴포저블을 화면에서 숨기고 전혀 표시하지 않을 수도 있습니다.\n\nViz 앱에서 사용자가 게시물을 저장한 후에는 전체 상세 버전을 보여줍니다. 그러나 소셜 미디어에 공유하기 위한 간단한 요약 버전을 제공합니다. 이 경우 화면에 전체 버전을 표시하고 공유 가능한 버전은 오프스크린에서 생성합니다.\n\n이를 달성하려면 코드에 몇 가지 변경 사항이 필요합니다 —\n\n```js\nvar graphicsLayer = rememberGraphicsLayer()\n\nBox(modifier = Modifier\n    .size(0.dp) // UI에 공간을 사용하지 않도록 크기를 0으로\n    .drawWithCache {\n        // 그래픽 레이어에 그리기\n        graphicsLayer = obtainGraphicsLayer().apply {\n            record(\n                size = IntSize(\n                    width = 400.dp.toPx().toInt(),\n                    height = 400.dp.toPx().toInt()\n                )\n            ) {\n                drawContent()\n            }\n        }\n\n        // 화면에 그리기를 건너뛰기 위해 비워 두기\n        onDrawWithContent { }\n    }) {\n    Box(\n        // 녹화의 원하는 크기로 부모 크기를 재정의\n        modifier = Modifier\n            .wrapContentHeight(unbounded = true, align = Alignment.Top)\n            .wrapContentWidth(unbounded = true, align = Alignment.Start)\n            .requiredSize(400.dp)\n    ) {\n        // 녹화되는 내용\n        Surface(modifier = Modifier.fillMaxSize()) {\n            MyShareContent()\n        }\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n이 코드 스니펫의 주요 기능은 다음과 같습니다:\n\n- 부모 Box 콤포저블은 크기를 0.dp로 설정합니다.\n- onDrawWithContent ' '은 비워두었는데요 — 이것은 화면에 그리는 것을 건너뛸 때 사용됩니다.\n- 자식 콤포저블에는 wrapContentHeight 및 wrapContentWidth 수정자를 사용하여 unbound = true로 설정합니다.\n- 자식 콤포저블에는 desired size를 지정하기 위해 requiredSize 수정자를 사용하여 크기를 설정합니다(400.dp).\n\n# 그래픽 레이어를 이미지 파일에 작성하세요\n\nAndroid 플랫폼에 파일을 작성할 때, 성능, 권한, API의 가용성 등 여러 가지 고려할 사항이 있습니다.\n\n<div class=\"content-ad\"></div>\n\n간결함과 집중을 위해 여기에 기본적인 해결책을 제시할게요. 안드로이드 14에서 잘 작동하는데요, 미디어 저장소 API로의 이동이라는 소문에도 불구하고요. 파일을 공유 Pictures 디렉토리에 쓰고, 미디어 스캐너를 사용하여 공유 가능한 URI를 생성함으로써 대부분의 권한 고려 사항을 회피할 수 있어요.\n\n파일 작성에 대해 미묘하게 다루고 싶다면, Wan Xiao의 다음 글을 추천드려요 -\n\n지금은 다음과 같은 과정을 따를 거에요:\n\n- 그래픽 레이어를 비트맵으로 변환\n- 비트맵을 PNG로 압축\n- PNG를 Pictures 디렉토리에 파일로 쓰기\n- 새 이미지 파일의 URI 가져오기\n\n<div class=\"content-ad\"></div>\n\n```kotlin\nprivate suspend fun GraphicsLayer.saveAsShareableFile(context: Context): Uri? {\n    \n    // 비트맵으로 변환\n    val bitmap = this.toImageBitmap().asAndroidBitmap()\n\n    // 파일 생성\n    val file = File(context.getExternalFilesDir(Environment.DIRECTORY_PICTURES),\n        \"my-app-post-${System.currentTimeMillis()}.png\")\n\n    // PNG로 비트맵을 파일에 쓰기\n    file.outputStream().use { out ->\n        bitmap.compress(Bitmap.CompressFormat.PNG, 100, out)\n        out.flush()\n    }\n\n    // 공유를 위한 파일 URI 가져오기\n    return file.scanPath(context)\n}\n\nsuspend fun File.scanPath(context: Context): Uri? {\n    // 코루틴으로 자바 콜백 래핑\n    return withTimeoutOrNull(timeMillis = 5000) {\n        suspendCancellableCoroutine { continuation ->\n            MediaScannerConnection.scanFile(\n                context,\n                arrayOf(path),\n                arrayOf(\"image/png\")\n            ) { scannedPath, scannedUri ->\n                continuation.resume(scannedUri)\n            }\n        }\n    }\n}\n```\n\n사회적 공유 이미지를 위해 PNG를 사용하는 것을 추천합니다. 텍스트가 포함된 이미지일 경우 선명도를 보존하는 것이 중요합니다. 각 소셜 미디어 플랫폼은 이미지를 원하는 크기와 형식으로 압축하기 때문에 이미지의 품질을 최대로 유지해야 합니다.\n\n# 버튼으로 프로세스 시작\n\n이미지 URI를 얻은 후에는 공유 인텐트를 생성하여 어디든 전송할 수 있습니다. 이렇게 하면 Android 공유 시트가 열리고 나머지 프로세스를 자동으로 처리합니다 — 추가적인 코드는 필요하지 않습니다!\n\n\n<div class=\"content-ad\"></div>\n\n```kotlin\nval context = LocalContext.current\nval coroutineScope = rememberCoroutineScope()\nvar graphicsLayer = rememberGraphicsLayer()\n\nButton(onClick = {\n    coroutineScope.launch {\n        if (graphicsLayer.size.width > 0 && graphicsLayer.size.height > 0) {\n            val uri = graphicsLayer.saveAsShareableFile(context)\n            val shareIntent: Intent = Intent().apply {\n                action = Intent.ACTION_SEND\n                putExtra(Intent.EXTRA_STREAM, uri)\n                type = \"image/png\"\n            }\n            startActivity(\n                context, Intent.createChooser(shareIntent, \"share\"), null\n            )\n        }\n    }\n\n}) {\n    // imo - nicer than IconButton with text\n    Row(horizontalArrangement = Arrangement.spacedBy(ButtonDefaults.IconSpacing)) {\n        Icon(\n            Icons.Default.Share,\n            contentDescription = null,\n            modifier = Modifier.size(18.dp)\n        )\n        Text(\n            text = \"Share\", style = MaterialTheme.typography.labelLarge\n        )\n    }\n}\n\n// Shareable 컴포저블을 여기에 포함하세요...\n```\n\n이 코드 스니펫에서 중요한 기능:\n\n- 부모 컴포저블에 범위 지정된 코루틴 시작\n- 그래픽 레이어가 0보다 큰지 확인하여 실행 보호\n- 이전에 생성한 헬퍼 확장 기능을 사용하여 그래픽 레이어 저장\n- 공유 Intent 생성 및 시작\n\n이러한 기능은 ViewModel에서 구현하는 것이 좋을까요?```\n\n<div class=\"content-ad\"></div>\n\n전체 과정은 다른 상태와 상호 작용할 필요 없이 구성 가능한 내부에 포함될 수 있습니다.\n\n또한 컴포저블 내에 Context를 유지하고 관리하는 것이 더 쉽습니다. 이러한 이유로, 버튼의 onClick 매개변수에서 코루틴을 직접 시작하는 것을 권장합니다.\n\n# 전체 코드 — 모든 것을 함께 넣기\n\n그래 — 이제 복사/붙여넣기 시간입니다!\n\n<div class=\"content-ad\"></div>\n\n```kt\n// 모든 명확하지 않은 임포트\n// 더 짧게 하기 위해 구성 임포트는 제외\nimport android.content.Context\nimport android.content.Intent\nimport android.graphics.Bitmap\nimport android.media.MediaScannerConnection\nimport android.net.Uri\nimport android.os.Environment\nimport androidx.core.content.ContextCompat.startActivity\nimport kotlinx.coroutines.launch\nimport kotlinx.coroutines.suspendCancellableCoroutine\nimport kotlinx.coroutines.withTimeoutOrNull\nimport java.io.File\nimport kotlin.coroutines.resume\n\n@Composable\nfun MyShareScreen() {\n    val context = LocalContext.current\n    val coroutineScope = rememberCoroutineScope()\n    var graphicsLayer = rememberGraphicsLayer()\n\n    Column {\n        Button(onClick = {\n            coroutineScope.launch {\n                if (graphicsLayer.size.width > 0 && graphicsLayer.size.height > 0) {\n                    val uri = graphicsLayer.saveAsShareableFile(context)\n                    val shareIntent: Intent = Intent().apply {\n                        action = Intent.ACTION_SEND\n                        putExtra(Intent.EXTRA_STREAM, uri)\n                        type = \"image/png\"\n                    }\n                    startActivity(\n                        context, Intent.createChooser(shareIntent, \"share\"), null\n                    )\n                }\n            }\n\n        }) {\n            // IMO - nicer than IconButton with text\n            Row(horizontalArrangement = Arrangement.spacedBy(ButtonDefaults.IconSpacing)) {\n                Icon(\n                    Icons.Default.Share,\n                    contentDescription = null,\n                    modifier = Modifier.size(18.dp)\n                )\n                Text(\n                    text = \"Share\", style = MaterialTheme.typography.labelLarge\n                )\n            }\n        }\n\n        Box(modifier = Modifier\n            .size(0.dp) // size 0 so that no space is used in the UI\n            .drawWithCache {\n                // draw to graphics layer\n                graphicsLayer = obtainGraphicsLayer().apply {\n                    record(\n                        size = IntSize(\n                            width = 400.dp.toPx().toInt(),\n                            height = 400.dp.toPx().toInt()\n                        )\n                    ) {\n                        drawContent()\n                    }\n                }\n\n                // leave blank to skip drawing on the screen\n                onDrawWithContent { }\n            }) {\n            Box(\n                // override the parent size with desired size of the recording\n                modifier = Modifier\n                    .wrapContentHeight(unbounded = true, align = Alignment.Top)\n                    .wrapContentWidth(unbounded = true, align = Alignment.Start)\n                    .requiredSize(400.dp)\n            ) {\n                // The content being recorded\n                Surface(modifier = Modifier.fillMaxSize()) {\n                    Text(\"My Share Content Here\")\n                }\n            }\n        }\n    }\n}\n\nsuspend fun GraphicsLayer.saveAsShareableFile(context: Context): Uri? {\n\n    // convert to bitmap\n    val bitmap = this.toImageBitmap().asAndroidBitmap()\n\n    // create file\n    val file = File(context.getExternalFilesDir(Environment.DIRECTORY_PICTURES),\n        \"my-app-post-${System.currentTimeMillis()}.png\")\n\n    // write bitmap to file as PNG\n    file.outputStream().use { out ->\n        bitmap.compress(Bitmap.CompressFormat.PNG, 100, out)\n        out.flush()\n    }\n\n    // get file URI for sharing\n    return file.scanPath(context)\n}\n\nsuspend fun File.scanPath(context: Context): Uri? {\n    // wrap java callback in coroutine\n    return withTimeoutOrNull(timeMillis = 5000) {\n        suspendCancellableCoroutine { continuation ->\n            MediaScannerConnection.scanFile(\n                context,\n                arrayOf(path),\n                arrayOf(\"image/png\")\n            ) { scannedPath, scannedUri ->\n                continuation.resume(scannedUri)\n            }\n        }\n    }\n}\n```\n\n![이미지](https://miro.medium.com/v2/resize:fit:1200/1*wX0_iwYqjzYVOm9Qu4pv1A.gif)\n\n# 정리합니다\n\n저는 Viz 앱을 개발하고 운영하는 독립 개발자입니다. 이 앱은 Kotlin Multiplatform을 활용한 네이티브 iOS 및 Android 앱입니다. 호주에서 다이빙, 스노클링 또는 프리다이빙을 즐기는 분들에게 꼭 한번 확인해보세요! 이 앱은 사람들이 서로 물 조건을 공유하고 해저 사진을 업로드하며 다이빙 로그를 유지할 수 있는 공간입니다. 항상 무료이며 가입이 필요하지 않습니다.```\n\n<div class=\"content-ad\"></div>\n\n잘못된 부분이나 버그를 발견하셨나요? 제안이나 대안이 있으시다면 언제든지 편하게 피드백해주세요! 이 기사에 몇 가지 수정사항을 추가하는 것에 항상 열려있습니다!\n\n그렇지 않다면, 여러분들이 이 내용을 유용하게 사용하고 있는지 알기 위해 언제나 의견/좋아요 등을 감사히 받겠습니다 :)","ogImage":{"url":"/assets/img/2024-05-23-SomethingWorthSharingHowtouseComposablesonSocialMedia_0.png"},"coverImage":"/assets/img/2024-05-23-SomethingWorthSharingHowtouseComposablesonSocialMedia_0.png","tag":["Tech"],"readingTime":13},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p><img src=\"/assets/img/2024-05-23-SomethingWorthSharingHowtouseComposablesonSocialMedia_0.png\" alt=\"Screenshot\"></p>\n<h1>사진이 없으면 일어나지 않았어요</h1>\n<p>인스타그램 게시물은 황홀한 모험의 마무리 또는 무기화된 FOMO의 조각일 수 있어요. 어쨌든 사람들은 자신의 하이라이트와 취미를 소셜 미디어에 기억하기를 좋아해요.</p>\n<p>최근에 Viz 앱에 공유 기능을 추가했어요. 이제 다이버와 스노클러도 이 의식에 참여할 수 있어요. 당시에는 Compose에서 생성된 아름다운 뷰를 Instagram, TikTok, Twitter 등에서 공유 가능한 이미지로 어떻게 변환하는지에 대해 온라인에 많이 쓰여 있지 않았어요.</p>\n<p>이제 다른 쪽으로 나와서 스스로 구현하는 방법을 안내해 드릴게요! 순서는 대략 다음과 같아요:</p>\n<ul>\n<li>공유하고 싶은 모든 콘텐츠를 포함하는 컴포저블 만들기</li>\n<li>컴포저블을 이미지로 변환하기</li>\n<li>안드로이드의 Sharesheet를 사용하여 이미지를 공유하기</li>\n</ul>\n<p>제가 공유된 백 엔드 코드를 작성할 때 KMP를 사용하고 있지만, UI는 Android 및 iOS에 대해 별도로 네이티브로 작성했어요. Android 버전은 아래에 작성되어 있고 SwiftUI 버전은 다음 주 별도의 기사에서 공유될 예정이에요!</p>\n<h1>공유 가능한 형식 디자인하기</h1>\n<p>삼격하고 상대적으로 높은 이동성을 가지고 있는 정사각형은 모든 소셜 미디어 플랫폼에서 최적의 화면 비율이에요. 인스타그램을 예로 들어보면—이 모양은 스크롤 피드에서 \"게시물\"로 공유되거나 전체 화면 \"스토리\"에 쉽게 가운데 정렬될 수 있어요.</p>\n<p>이 이상적인 크기는 두 가지 요소에 따라 다릅니다:</p>\n<ul>\n<li>이미지로 공유될 때 선명하고 뚜렷하게 보이기 위한 충분한 세부 정보가 있는 크기</li>\n<li>디자인 시스템에서 폰트 스타일 토큰을 수용할 수 있는 크기 (원시 작성, Material3 또는 다른 것)</li>\n</ul>\n<p>저는 안드로이드에서 400.dp부터 500.dp 크기가 이 두 목표를 모두 잘 이루어낼 수 있다고 생각해요. 대부분의 휴대폰에서 전체 화면 크기로 변환될 거예요. 그리고 이 크기에서 '제목', '헤드라인', '본문'과 같은 폰트 스타일을 사용하면 본인만의 원시 폰트 크기를 계산할 필요 없이 손쉽게 사용할 수 있어요.</p>\n<pre><code class=\"hljs language-kotlin\"><span class=\"hljs-meta\">@Composable</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">MyShareContent</span><span class=\"hljs-params\">()</span></span> {\n    <span class=\"hljs-keyword\">val</span> headline = MaterialTheme.typography.headlineLarge\n    <span class=\"hljs-keyword\">val</span> title = MaterialTheme.typography.titleLarge\n\n    Box(\n        modifier = Modifier\n            .size(<span class=\"hljs-number\">400.</span>dp)\n            .background(color = MaterialTheme.colorScheme.surface)\n    ) {\n        Column(\n            verticalArrangement = Arrangement.SpaceBetween,\n            horizontalAlignment = Alignment.CenterHorizontally,\n            modifier = Modifier\n                .padding(<span class=\"hljs-number\">12.</span>dp)\n                .fillMaxSize(),\n        ) {\n            Icon(\n                painter = painterResource(id = R.drawable.v3_logo_with_text),\n                tint = Color.Unspecified, <span class=\"hljs-comment\">// 원본 SVG 색상 유지</span>\n                contentDescription = <span class=\"hljs-literal\">null</span>,\n                modifier = Modifier.height(<span class=\"hljs-number\">200.</span>dp)\n            )\n            Text(text = <span class=\"hljs-string\">\"Moon Bay Marine Reserve\"</span>, style = headline)\n\n            Row(\n                horizontalArrangement = Arrangement.SpaceBetween,\n                modifier = Modifier.fillMaxWidth()\n            ) {\n                Text(text = <span class=\"hljs-string\">\"Date\"</span>, style = title)\n                Text(text = <span class=\"hljs-string\">\"Thursday 10 April 2024\"</span>, style = title)\n            }\n\n            Row(\n                horizontalArrangement = Arrangement.SpaceBetween,\n                modifier = Modifier.fillMaxWidth()\n            ) {\n                Text(text = <span class=\"hljs-string\">\"Time\"</span>, style = title)\n                Text(text = <span class=\"hljs-string\">\"10:20 - 11:45\"</span>, style = title)\n            }\n        }\n    }\n}\n</code></pre>\n<p><img src=\"/assets/img/2024-05-23-SomethingWorthSharingHowtouseComposablesonSocialMedia_1.png\" alt=\"Image\"></p>\n<h1>그래픽 레이어에 Composable 기록하기</h1>\n<p>Compose의 최신 버전(1.7)에서는 훌륭한 GraphicsLayer API가 소개되었습니다. 이는 Composable의 그리기를 캡처하고 다른 위치에서 재생하는 방법을 제공합니다. 결국 이를 사용하여 Composable을 이미지 파일로 기록할 것입니다.</p>\n<pre><code class=\"hljs language-kotlin\"><span class=\"hljs-keyword\">var</span> graphicsLayer = rememberGraphicsLayer()\n\nBox(modifier = Modifier\n    .size(<span class=\"hljs-number\">400.</span>dp)\n    .drawWithCache {\n        <span class=\"hljs-comment\">// draw to graphics layer</span>\n        graphicsLayer = obtainGraphicsLayer().apply {\n            record { drawContent() }\n        }\n        <span class=\"hljs-comment\">// draw to actual UI</span>\n        onDrawWithContent { drawContent() }\n    }) {\n    <span class=\"hljs-comment\">// The content being recorded</span>\n    Surface(modifier = Modifier.fillMaxSize()) {\n        MyShareContent()\n    }\n}\n</code></pre>\n<p>이 코드 스니펫의 주요 기능:</p>\n<ul>\n<li>Box를 부모 컨테이너로 사용</li>\n<li>공유하려는 컴포저블을 Box의 콘텐츠 매개변수에 배치</li>\n<li>drawWithCache 수정자를 사용하여 콘텐츠의 그리기를 캡처</li>\n<li>record 메서드를 사용하여 그림을 저장된 graphicsLayer 변수로 리디렉션</li>\n</ul>\n<h1>컴포저블 그리기를 완전히 건너뛰기</h1>\n<p>컴포저블을 화면에서 숨기고 전혀 표시하지 않을 수도 있습니다.</p>\n<p>Viz 앱에서 사용자가 게시물을 저장한 후에는 전체 상세 버전을 보여줍니다. 그러나 소셜 미디어에 공유하기 위한 간단한 요약 버전을 제공합니다. 이 경우 화면에 전체 버전을 표시하고 공유 가능한 버전은 오프스크린에서 생성합니다.</p>\n<p>이를 달성하려면 코드에 몇 가지 변경 사항이 필요합니다 —</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">var</span> graphicsLayer = <span class=\"hljs-title function_\">rememberGraphicsLayer</span>()\n\n<span class=\"hljs-title class_\">Box</span>(modifier = <span class=\"hljs-title class_\">Modifier</span>\n    .<span class=\"hljs-title function_\">size</span>(<span class=\"hljs-number\">0.</span>dp) <span class=\"hljs-comment\">// UI에 공간을 사용하지 않도록 크기를 0으로</span>\n    .<span class=\"hljs-property\">drawWithCache</span> {\n        <span class=\"hljs-comment\">// 그래픽 레이어에 그리기</span>\n        graphicsLayer = <span class=\"hljs-title function_\">obtainGraphicsLayer</span>().<span class=\"hljs-property\">apply</span> {\n            <span class=\"hljs-title function_\">record</span>(<span class=\"hljs-params\">\n                size = IntSize(\n                    width = <span class=\"hljs-number\">400.</span>dp.toPx().toInt(),\n                    height = <span class=\"hljs-number\">400.</span>dp.toPx().toInt()\n                )\n            </span>) {\n                <span class=\"hljs-title function_\">drawContent</span>()\n            }\n        }\n\n        <span class=\"hljs-comment\">// 화면에 그리기를 건너뛰기 위해 비워 두기</span>\n        onDrawWithContent { }\n    }) {\n    <span class=\"hljs-title class_\">Box</span>(\n        <span class=\"hljs-comment\">// 녹화의 원하는 크기로 부모 크기를 재정의</span>\n        modifier = <span class=\"hljs-title class_\">Modifier</span>\n            .<span class=\"hljs-title function_\">wrapContentHeight</span>(unbounded = <span class=\"hljs-literal\">true</span>, align = <span class=\"hljs-title class_\">Alignment</span>.<span class=\"hljs-property\">Top</span>)\n            .<span class=\"hljs-title function_\">wrapContentWidth</span>(unbounded = <span class=\"hljs-literal\">true</span>, align = <span class=\"hljs-title class_\">Alignment</span>.<span class=\"hljs-property\">Start</span>)\n            .requiredSize(<span class=\"hljs-number\">400.</span>dp)\n    ) {\n        <span class=\"hljs-comment\">// 녹화되는 내용</span>\n        <span class=\"hljs-title class_\">Surface</span>(modifier = <span class=\"hljs-title class_\">Modifier</span>.<span class=\"hljs-title function_\">fillMaxSize</span>()) {\n            <span class=\"hljs-title class_\">MyShareContent</span>()\n        }\n    }\n}\n</code></pre>\n<p>이 코드 스니펫의 주요 기능은 다음과 같습니다:</p>\n<ul>\n<li>부모 Box 콤포저블은 크기를 0.dp로 설정합니다.</li>\n<li>onDrawWithContent ' '은 비워두었는데요 — 이것은 화면에 그리는 것을 건너뛸 때 사용됩니다.</li>\n<li>자식 콤포저블에는 wrapContentHeight 및 wrapContentWidth 수정자를 사용하여 unbound = true로 설정합니다.</li>\n<li>자식 콤포저블에는 desired size를 지정하기 위해 requiredSize 수정자를 사용하여 크기를 설정합니다(400.dp).</li>\n</ul>\n<h1>그래픽 레이어를 이미지 파일에 작성하세요</h1>\n<p>Android 플랫폼에 파일을 작성할 때, 성능, 권한, API의 가용성 등 여러 가지 고려할 사항이 있습니다.</p>\n<p>간결함과 집중을 위해 여기에 기본적인 해결책을 제시할게요. 안드로이드 14에서 잘 작동하는데요, 미디어 저장소 API로의 이동이라는 소문에도 불구하고요. 파일을 공유 Pictures 디렉토리에 쓰고, 미디어 스캐너를 사용하여 공유 가능한 URI를 생성함으로써 대부분의 권한 고려 사항을 회피할 수 있어요.</p>\n<p>파일 작성에 대해 미묘하게 다루고 싶다면, Wan Xiao의 다음 글을 추천드려요 -</p>\n<p>지금은 다음과 같은 과정을 따를 거에요:</p>\n<ul>\n<li>그래픽 레이어를 비트맵으로 변환</li>\n<li>비트맵을 PNG로 압축</li>\n<li>PNG를 Pictures 디렉토리에 파일로 쓰기</li>\n<li>새 이미지 파일의 URI 가져오기</li>\n</ul>\n<pre><code class=\"hljs language-kotlin\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">suspend</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> GraphicsLayer.<span class=\"hljs-title\">saveAsShareableFile</span><span class=\"hljs-params\">(context: <span class=\"hljs-type\">Context</span>)</span></span>: Uri? {\n    \n    <span class=\"hljs-comment\">// 비트맵으로 변환</span>\n    <span class=\"hljs-keyword\">val</span> bitmap = <span class=\"hljs-keyword\">this</span>.toImageBitmap().asAndroidBitmap()\n\n    <span class=\"hljs-comment\">// 파일 생성</span>\n    <span class=\"hljs-keyword\">val</span> file = File(context.getExternalFilesDir(Environment.DIRECTORY_PICTURES),\n        <span class=\"hljs-string\">\"my-app-post-<span class=\"hljs-subst\">${System.currentTimeMillis()}</span>.png\"</span>)\n\n    <span class=\"hljs-comment\">// PNG로 비트맵을 파일에 쓰기</span>\n    file.outputStream().use { <span class=\"hljs-keyword\">out</span> ->\n        bitmap.compress(Bitmap.CompressFormat.PNG, <span class=\"hljs-number\">100</span>, <span class=\"hljs-keyword\">out</span>)\n        <span class=\"hljs-keyword\">out</span>.flush()\n    }\n\n    <span class=\"hljs-comment\">// 공유를 위한 파일 URI 가져오기</span>\n    <span class=\"hljs-keyword\">return</span> file.scanPath(context)\n}\n\n<span class=\"hljs-keyword\">suspend</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> File.<span class=\"hljs-title\">scanPath</span><span class=\"hljs-params\">(context: <span class=\"hljs-type\">Context</span>)</span></span>: Uri? {\n    <span class=\"hljs-comment\">// 코루틴으로 자바 콜백 래핑</span>\n    <span class=\"hljs-keyword\">return</span> withTimeoutOrNull(timeMillis = <span class=\"hljs-number\">5000</span>) {\n        suspendCancellableCoroutine { continuation ->\n            MediaScannerConnection.scanFile(\n                context,\n                arrayOf(path),\n                arrayOf(<span class=\"hljs-string\">\"image/png\"</span>)\n            ) { scannedPath, scannedUri ->\n                continuation.resume(scannedUri)\n            }\n        }\n    }\n}\n</code></pre>\n<p>사회적 공유 이미지를 위해 PNG를 사용하는 것을 추천합니다. 텍스트가 포함된 이미지일 경우 선명도를 보존하는 것이 중요합니다. 각 소셜 미디어 플랫폼은 이미지를 원하는 크기와 형식으로 압축하기 때문에 이미지의 품질을 최대로 유지해야 합니다.</p>\n<h1>버튼으로 프로세스 시작</h1>\n<p>이미지 URI를 얻은 후에는 공유 인텐트를 생성하여 어디든 전송할 수 있습니다. 이렇게 하면 Android 공유 시트가 열리고 나머지 프로세스를 자동으로 처리합니다 — 추가적인 코드는 필요하지 않습니다!</p>\n<pre><code class=\"hljs language-kotlin\"><span class=\"hljs-keyword\">val</span> context = LocalContext.current\n<span class=\"hljs-keyword\">val</span> coroutineScope = rememberCoroutineScope()\n<span class=\"hljs-keyword\">var</span> graphicsLayer = rememberGraphicsLayer()\n\nButton(onClick = {\n    coroutineScope.launch {\n        <span class=\"hljs-keyword\">if</span> (graphicsLayer.size.width > <span class=\"hljs-number\">0</span> &#x26;&#x26; graphicsLayer.size.height > <span class=\"hljs-number\">0</span>) {\n            <span class=\"hljs-keyword\">val</span> uri = graphicsLayer.saveAsShareableFile(context)\n            <span class=\"hljs-keyword\">val</span> shareIntent: Intent = Intent().apply {\n                action = Intent.ACTION_SEND\n                putExtra(Intent.EXTRA_STREAM, uri)\n                type = <span class=\"hljs-string\">\"image/png\"</span>\n            }\n            startActivity(\n                context, Intent.createChooser(shareIntent, <span class=\"hljs-string\">\"share\"</span>), <span class=\"hljs-literal\">null</span>\n            )\n        }\n    }\n\n}) {\n    <span class=\"hljs-comment\">// imo - nicer than IconButton with text</span>\n    Row(horizontalArrangement = Arrangement.spacedBy(ButtonDefaults.IconSpacing)) {\n        Icon(\n            Icons.Default.Share,\n            contentDescription = <span class=\"hljs-literal\">null</span>,\n            modifier = Modifier.size(<span class=\"hljs-number\">18.</span>dp)\n        )\n        Text(\n            text = <span class=\"hljs-string\">\"Share\"</span>, style = MaterialTheme.typography.labelLarge\n        )\n    }\n}\n\n<span class=\"hljs-comment\">// Shareable 컴포저블을 여기에 포함하세요...</span>\n</code></pre>\n<p>이 코드 스니펫에서 중요한 기능:</p>\n<ul>\n<li>부모 컴포저블에 범위 지정된 코루틴 시작</li>\n<li>그래픽 레이어가 0보다 큰지 확인하여 실행 보호</li>\n<li>이전에 생성한 헬퍼 확장 기능을 사용하여 그래픽 레이어 저장</li>\n<li>공유 Intent 생성 및 시작</li>\n</ul>\n<p>이러한 기능은 ViewModel에서 구현하는 것이 좋을까요?```</p>\n<p>전체 과정은 다른 상태와 상호 작용할 필요 없이 구성 가능한 내부에 포함될 수 있습니다.</p>\n<p>또한 컴포저블 내에 Context를 유지하고 관리하는 것이 더 쉽습니다. 이러한 이유로, 버튼의 onClick 매개변수에서 코루틴을 직접 시작하는 것을 권장합니다.</p>\n<h1>전체 코드 — 모든 것을 함께 넣기</h1>\n<p>그래 — 이제 복사/붙여넣기 시간입니다!</p>\n<pre><code class=\"hljs language-kt\"><span class=\"hljs-comment\">// 모든 명확하지 않은 임포트</span>\n<span class=\"hljs-comment\">// 더 짧게 하기 위해 구성 임포트는 제외</span>\n<span class=\"hljs-keyword\">import</span> android.content.Context\n<span class=\"hljs-keyword\">import</span> android.content.Intent\n<span class=\"hljs-keyword\">import</span> android.graphics.Bitmap\n<span class=\"hljs-keyword\">import</span> android.media.MediaScannerConnection\n<span class=\"hljs-keyword\">import</span> android.net.Uri\n<span class=\"hljs-keyword\">import</span> android.os.Environment\n<span class=\"hljs-keyword\">import</span> androidx.core.content.ContextCompat.startActivity\n<span class=\"hljs-keyword\">import</span> kotlinx.coroutines.launch\n<span class=\"hljs-keyword\">import</span> kotlinx.coroutines.suspendCancellableCoroutine\n<span class=\"hljs-keyword\">import</span> kotlinx.coroutines.withTimeoutOrNull\n<span class=\"hljs-keyword\">import</span> java.io.File\n<span class=\"hljs-keyword\">import</span> kotlin.coroutines.resume\n\n<span class=\"hljs-meta\">@Composable</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">MyShareScreen</span><span class=\"hljs-params\">()</span></span> {\n    <span class=\"hljs-keyword\">val</span> context = LocalContext.current\n    <span class=\"hljs-keyword\">val</span> coroutineScope = rememberCoroutineScope()\n    <span class=\"hljs-keyword\">var</span> graphicsLayer = rememberGraphicsLayer()\n\n    Column {\n        Button(onClick = {\n            coroutineScope.launch {\n                <span class=\"hljs-keyword\">if</span> (graphicsLayer.size.width > <span class=\"hljs-number\">0</span> &#x26;&#x26; graphicsLayer.size.height > <span class=\"hljs-number\">0</span>) {\n                    <span class=\"hljs-keyword\">val</span> uri = graphicsLayer.saveAsShareableFile(context)\n                    <span class=\"hljs-keyword\">val</span> shareIntent: Intent = Intent().apply {\n                        action = Intent.ACTION_SEND\n                        putExtra(Intent.EXTRA_STREAM, uri)\n                        type = <span class=\"hljs-string\">\"image/png\"</span>\n                    }\n                    startActivity(\n                        context, Intent.createChooser(shareIntent, <span class=\"hljs-string\">\"share\"</span>), <span class=\"hljs-literal\">null</span>\n                    )\n                }\n            }\n\n        }) {\n            <span class=\"hljs-comment\">// IMO - nicer than IconButton with text</span>\n            Row(horizontalArrangement = Arrangement.spacedBy(ButtonDefaults.IconSpacing)) {\n                Icon(\n                    Icons.Default.Share,\n                    contentDescription = <span class=\"hljs-literal\">null</span>,\n                    modifier = Modifier.size(<span class=\"hljs-number\">18.</span>dp)\n                )\n                Text(\n                    text = <span class=\"hljs-string\">\"Share\"</span>, style = MaterialTheme.typography.labelLarge\n                )\n            }\n        }\n\n        Box(modifier = Modifier\n            .size(<span class=\"hljs-number\">0.</span>dp) <span class=\"hljs-comment\">// size 0 so that no space is used in the UI</span>\n            .drawWithCache {\n                <span class=\"hljs-comment\">// draw to graphics layer</span>\n                graphicsLayer = obtainGraphicsLayer().apply {\n                    record(\n                        size = IntSize(\n                            width = <span class=\"hljs-number\">400.</span>dp.toPx().toInt(),\n                            height = <span class=\"hljs-number\">400.</span>dp.toPx().toInt()\n                        )\n                    ) {\n                        drawContent()\n                    }\n                }\n\n                <span class=\"hljs-comment\">// leave blank to skip drawing on the screen</span>\n                onDrawWithContent { }\n            }) {\n            Box(\n                <span class=\"hljs-comment\">// override the parent size with desired size of the recording</span>\n                modifier = Modifier\n                    .wrapContentHeight(unbounded = <span class=\"hljs-literal\">true</span>, align = Alignment.Top)\n                    .wrapContentWidth(unbounded = <span class=\"hljs-literal\">true</span>, align = Alignment.Start)\n                    .requiredSize(<span class=\"hljs-number\">400.</span>dp)\n            ) {\n                <span class=\"hljs-comment\">// The content being recorded</span>\n                Surface(modifier = Modifier.fillMaxSize()) {\n                    Text(<span class=\"hljs-string\">\"My Share Content Here\"</span>)\n                }\n            }\n        }\n    }\n}\n\n<span class=\"hljs-keyword\">suspend</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> GraphicsLayer.<span class=\"hljs-title\">saveAsShareableFile</span><span class=\"hljs-params\">(context: <span class=\"hljs-type\">Context</span>)</span></span>: Uri? {\n\n    <span class=\"hljs-comment\">// convert to bitmap</span>\n    <span class=\"hljs-keyword\">val</span> bitmap = <span class=\"hljs-keyword\">this</span>.toImageBitmap().asAndroidBitmap()\n\n    <span class=\"hljs-comment\">// create file</span>\n    <span class=\"hljs-keyword\">val</span> file = File(context.getExternalFilesDir(Environment.DIRECTORY_PICTURES),\n        <span class=\"hljs-string\">\"my-app-post-<span class=\"hljs-subst\">${System.currentTimeMillis()}</span>.png\"</span>)\n\n    <span class=\"hljs-comment\">// write bitmap to file as PNG</span>\n    file.outputStream().use { <span class=\"hljs-keyword\">out</span> ->\n        bitmap.compress(Bitmap.CompressFormat.PNG, <span class=\"hljs-number\">100</span>, <span class=\"hljs-keyword\">out</span>)\n        <span class=\"hljs-keyword\">out</span>.flush()\n    }\n\n    <span class=\"hljs-comment\">// get file URI for sharing</span>\n    <span class=\"hljs-keyword\">return</span> file.scanPath(context)\n}\n\n<span class=\"hljs-keyword\">suspend</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> File.<span class=\"hljs-title\">scanPath</span><span class=\"hljs-params\">(context: <span class=\"hljs-type\">Context</span>)</span></span>: Uri? {\n    <span class=\"hljs-comment\">// wrap java callback in coroutine</span>\n    <span class=\"hljs-keyword\">return</span> withTimeoutOrNull(timeMillis = <span class=\"hljs-number\">5000</span>) {\n        suspendCancellableCoroutine { continuation ->\n            MediaScannerConnection.scanFile(\n                context,\n                arrayOf(path),\n                arrayOf(<span class=\"hljs-string\">\"image/png\"</span>)\n            ) { scannedPath, scannedUri ->\n                continuation.resume(scannedUri)\n            }\n        }\n    }\n}\n</code></pre>\n<p><img src=\"https://miro.medium.com/v2/resize:fit:1200/1*wX0_iwYqjzYVOm9Qu4pv1A.gif\" alt=\"이미지\"></p>\n<h1>정리합니다</h1>\n<p>저는 Viz 앱을 개발하고 운영하는 독립 개발자입니다. 이 앱은 Kotlin Multiplatform을 활용한 네이티브 iOS 및 Android 앱입니다. 호주에서 다이빙, 스노클링 또는 프리다이빙을 즐기는 분들에게 꼭 한번 확인해보세요! 이 앱은 사람들이 서로 물 조건을 공유하고 해저 사진을 업로드하며 다이빙 로그를 유지할 수 있는 공간입니다. 항상 무료이며 가입이 필요하지 않습니다.```</p>\n<p>잘못된 부분이나 버그를 발견하셨나요? 제안이나 대안이 있으시다면 언제든지 편하게 피드백해주세요! 이 기사에 몇 가지 수정사항을 추가하는 것에 항상 열려있습니다!</p>\n<p>그렇지 않다면, 여러분들이 이 내용을 유용하게 사용하고 있는지 알기 위해 언제나 의견/좋아요 등을 감사히 받겠습니다 :)</p>\n</body>\n</html>\n"},"__N_SSG":true}