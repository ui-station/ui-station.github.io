{"pageProps":{"post":{"title":"제목 Python, Jinja2 및 NiceGUI를 사용하여 독특한 Gemini AI-챗봇 만들기","description":"","date":"2024-05-20 18:41","slug":"2024-05-20-CreateyourownGeminiAI-chatbotwithatwistusingPythonJinja2andNiceGUI","content":"\n\n## 파이썬을 사용하여 베르텍스AI를 통해 Gemini의 기본 사항을 알아보고 NiceGUI를 사용하여 웹 UI를 만들며 모듈식 프롬프트를 구성하는 Jinja2를 사용하는 방법\n\n![이미지](/assets/img/2024-05-20-CreateyourownGeminiAI-chatbotwithatwistusingPythonJinja2andNiceGUI_0.png)\n\n본문에서는 Python, NiceGUI, Jinja2 및 VertexAI를 사용하여 LLM 기반 웹 애플리케이션을 만들어보겠습니다. 이 프로젝트를 처음부터 만드는 방법과 기본 개념의 개요를 얻을 수 있습니다.\n\n먼저 🚀 기술 스택에 대한 간단한 개요로 시작해 보겠습니다:\n\n<div class=\"content-ad\"></div>\n\n- Python 3.12\n- NiceGUI를 사용하여 파이썬으로 프론트엔드를 코딩합니다.\n- 의존성 관리를 위해 Poetry 사용\n- 모듈식 프롬프트 생성을 위해 Jinja2 템플릿 사용\n\n# Poetry를 사용한 프로젝트 설정\n\n우리는 Python에서 의존성 관리와 패키징을 위한 도구인 Poetry를 사용하여 프로젝트를 생성하고 의존성을 어떻게 관리하는지 살펴볼 것입니다.\n\nPoetry가 도와줄 수 있는 세 가지 주요 작업은 빌드, 게시 및 추적입니다. 의존성을 관리하고 프로젝트를 공유하며 의존성 상태를 추적할 수 있는 결정론적인 방법이 되는 것이 아이디어입니다.\n\n<div class=\"content-ad\"></div>\n\n시, Poetry는 가상 환경을 생성하는 작업도 담당합니다. 기본적으로 시스템 내의 중앙 폴더에 위치하는데요. 하지만 저와 같이 프로젝트 관련 가상 환경을 프로젝트 폴더 내에 가지고 싶다면, 간단한 설정 변경이 필요합니다:\n\n```js\npoetry config virtualenvs.in-project true\n```\n\nPoetry new를 사용하여 새로운 Python 프로젝트를 만들 수 있습니다. 이 작업은 시스템의 기본 Python과 링크되는 가상 환경이 생성됩니다. 이것을 pyenv와 결합하면 특정 버전을 사용하는 프로젝트를 유연하게 만들 수 있습니다. 또한, Poetry에 직접 사용할 Python 버전을 알려줄 수도 있습니다: poetry env use /full/path/to/python.\n\n새 프로젝트를 생성하면, poetry add로 종속성을 추가할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n새 프로젝트를 만들어 시작해봐요:\n\n```js\npoetry config virtualenvs.in-project true\npoetry new my-gemini-chatbot\ncd my-gemini-chatbot\n```\n\n프로젝트에 대한 메타데이터 및 해당 버전과 종속성은 .toml 및 .lock 파일에 저장됩니다.\n\n<img src=\"/assets/img/2024-05-20-CreateyourownGeminiAI-chatbotwithatwistusingPythonJinja2andNiceGUI_1.png\" />\n\n<div class=\"content-ad\"></div>\n\n이제 시작하기 위해 필요한 종속성을 추가해 봅시다:\n\n```js\npoetry add 'google-cloud-aiplatform>=1.38'\npoetry add 'nicegui'\n```\n\n# NiceGUI를 사용한 기본 웹 UI\n\nNiceGUI는 웹 브라우저용 그래픽 사용자 인터페이스(GUI)를 만들 수 있게 해주는 Python 라이브러리입니다. 초보자들도 빠르게 시작할 수 있지만, 고급 사용자들을 위한 맞춤 설정 옵션도 풍부하게 제공합니다. 웹 뷰는 Quasar Framework를 기반으로 하며, 다양한 구성 요소를 제공합니다. 그리고 이는 TailwindCSS를 사용하기 때문에 NiceGUI 페이지에서도 직접 TailwindCSS 클래스를 사용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n특히 나에게는 백엔드 소프트웨어 개발에서 온 데이터 엔지니어로써, Python을 사용하여 작은 웹 UI를 만드는 것은 좋은 방법입니다. 물론 더 복잡한 프론트엔드에 대해서는 충분한 해결책이 되지 않을 수도 있지만, 범위가 상대적으로 작다면 빠르게 결과를 확인할 수 있습니다. NiceGUI를 사용하면 Python 코드에 집중할 수 있습니다. 왜냐하면 NiceGUI가 모든 웹 개발 작업을 처리하기 때문입니다.\n\nNiceGUI는 버튼, 슬라이더, 텍스트 상자와 같은 일반적인 UI 구성 요소를 사용하고 유연한 레이아웃을 사용하여 페이지에 배열합니다. 이러한 구성 요소는 Python 코드의 데이터와 연결될 수 있어 데이터가 변경될 때 인터페이스가 자동으로 업데이트됩니다. 또한 응용 프로그램의 외관을 필요에 맞게 스타일링할 수도 있습니다.\n\n이 작업 방식을 설명하는 가장 쉬운 방법은 직접 보여주는 것입니다. 그래서 최소 예제를 만들기 시작해 봅시다.\n\n내 경우에는 내 모듈의 main.py (내 경우 my_gemini_chatbot)를 생성합니다. 이 파일은 모든 어플리케이션과 프론트엔드 로직에 사용될 것입니다.\n\n<div class=\"content-ad\"></div>\n\n다음 코드로 간단한 레이블이 포함된 페이지를 얻을 수 있습니다:\n\n```js\nfrom nicegui import ui\n\nui.label('Hello NiceGUI!')\nui.run()\n```\n\n<img src=\"/assets/img/2024-05-20-CreateyourownGeminiAI-chatbotwithatwistusingPythonJinja2andNiceGUI_2.png\" />\n\n애플리케이션을 실행하면 포트 8080에서 사용할 수 있습니다. 또한 스크립트를 실행할 때 페이지가 자동으로 열립니다. 이것이 페이지가 보이는 방법입니다:\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-05-20-CreateyourownGeminiAI-chatbotwithatwistusingPythonJinja2andNiceGUI_3.png\" />\n\n축하합니다: 순수 Python으로 만든 첫 프론트엔드 😉.\n\n# 챗봇 웹 UI 준비\n\n다음 단계는 우리 챗봇을 위한 웹 UI를 준비하는 것입니다. 물론, 위의 예제보다는 조금 더 복잡할 것이지만 NiceGUI를 사용하여 컴포넌트를 배치하는 기본 아이디어를 알면 더 쉬워질 것입니다.\n\n<div class=\"content-ad\"></div>\n\n먼저 몇 가지 레이아웃 기본 사항을 이해해야 합니다. 컴포넌트가 페이지 상에 배치되는 방식을 제어하는 여러 가지 방법이 있습니다. 일반적인 방법 중 하나는 그리드 레이아웃인데, 우리는 이를 사용할 것입니다.\n\nNiceGUI에서 우리는 다음과 같이 그리드를 생성할 수 있습니다:\n\n```js\nfrom nicegui import ui\n\nwith ui.grid(columns=16).classes(\"w-3/4 place-self-center gap-4\"):\n    ui.markdown(\"# 🚀 My Gemini Chatbot\").classes(\"col-span-full\")\n\nui.run()\n```\n\n이를 하나씩 분해하여 더 잘 이해해 봅시다. ui.grid(columns=16)은 16개의 열로 분할된 그리드 레이아웃을 초기화합니다. 이들은 모두 동일한 너비를 갖습니다. 이것은 그리드의 실제 너비에 대해 아무 말도 하지 않으며 그리드가 몇 개의 열로 나눠질지만을 지정합니다. 16개의 열로, 우리는 충분한 유연성을 얻을 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n우리는 .classes를 통해 사용자 정의 TailwindCSS 클래스를 추가할 수 있습니다. 여기서 우리는 그리드에 3가지 클래스를 추가했습니다:\n\n- w-3/4: 그리드는 항상 브라우저 전체 너비의 3/4을 차지해야 합니다.\n- place-self-center: 그리드 자체가 브라우저 창 가운데에 위치해야 합니다.\n- gap-4: 그리드 내 요소 사이에는 4개의 픽셀 간격이 있어야 합니다.\n\n위 예시에서는 그리드 안에 요소 하나를 배치했습니다:\n\n```js\nwith ui.grid(columns=16).classes(\"w-3/4 place-self-center gap-4\"):\n    ui.markdown(\"# 🚀 My Gemini Chatbot\").classes(\"col-span-full\")\n```\n\n<div class=\"content-ad\"></div>\n\n위에서 확인할 수 있듯이, 우리는 다시 col-span-full이라는 사용자 정의 클래스를 할당했습니다. 이는 NiceGUI에게 이 요소가 첫 번째 행의 모든 사용 가능한 열을 사용해야 함을 알려줍니다. 우리의 경우: 모든 16열을 사용합니다.\n\n모든 열의 양에 대한 클래스가 있으므로 첫 번째 요소에 col-span-10을 할당하고 두 번째 요소에 col-span-6을 할당하여 한 행에 2개의 요소를 채울 수도 있습니다.\n\n<img src=\"/assets/img/2024-05-20-CreateyourownGeminiAI-chatbotwithatwistusingPythonJinja2andNiceGUI_4.png\" />\n\n이 지식을 바탕으로 우리의 챗봇에 필요한 모든 요소를 추가할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```python\nfrom nicegui import ui\n\nwith ui.grid(columns=16).classes(\"w-3/4 place-self-center gap-4\"):\n    ui.markdown(\"# 🚀 우리의 Gemini 챗봇\").classes(\"col-span-full\")\n    ui.input(label=\"프롬프트\").classes(\"col-span-10\")\n    ui.select(\n        options=[\"기본\", \"산타 클로스\"],\n        value=\"기본\",\n        label=\"성격 선택\"\n    ).classes(\"col-span-6\")\n    ui.button(\"Gemini로 전송\").classes(\"col-span-full\")\n\n    with ui.card().classes(\"col-span-full\"):\n        ui.markdown(\"## Gemini 응답\")\n        ui.separator()\n        ui.label(\"Gemini에 프롬프트를 보내고 응답을 여기서 확인하세요.\")\n\nui.run()\n```\n\n위의 코드는 다음과 같은 웹 UI를 만들어냅니다:\n\n<img src=\"/assets/img/2024-05-20-CreateyourownGeminiAI-chatbotwithatwistusingPythonJinja2andNiceGUI_5.png\" />\n\nPython으로 완전히 작성된 UI로는 꽤 괜찮은 결과가 나온 것 같네요.```\n\n<div class=\"content-ad\"></div>\n\n# 기본 기능 추가하기\n\n우리의 다음 작업은 기본 기능을 추가하는 것입니다. 아직 VertexAI나 Gemini와 상호 작용하지는 않겠지만, Gemini로 전송 버튼을 클릭하면 사용자 입력을 반영하는 알림이 표시되도록 기능을 추가하려고 합니다.\n\n중요한 개념 하나를 설명해 드리겠습니다: 우리의 프론트엔드는 우리 Python 스크립트의 한 인스턴스에 의해 제공됩니다. 이제 사용자 입력을 전역 변수에 저장하고 있는데, 동시에 챗봇을 사용하고 있는 다른 사용자가 다른 값을 제출한다고 상상해 보십시오. 그러면 첫 번째 사용자의 값이 덮어쓰여지기 때문에 재밌지만 예상치 못한 동작이 발생할 것입니다.\n\n최근 NiceGUI에서는 이러한 상황을 다루기 위해 '저장소' 기능을 소개했습니다. 이는 데이터 지속성을 위한 간단한 메커니즘으로, 클라이언트 측에 데이터를 저장하는 것과 서버 측에 데이터를 저장하는 것을 포함한 다섯 가지 내장 저장 유형을 기반으로 합니다.\n\n<div class=\"content-ad\"></div>\n\n그러나 저장소 기능은 페이지 빌더의 컨텍스트에서만 사용할 수 있습니다. 기본적으로 이것은 다음을 의미합니다: 메인 스크립트에서 웹 페이지를 간단히 코딩하는 대신, 각 페이지마다 함수로 래핑합니다. 우리는 한 페이지만 가지고 있으므로 하나의 함수만 필요합니다: index(). 그런 다음 해당 함수가 메인 인덱스 페이지인 /로 정의된 페이지를 나타낸다고 NiceGUI에 알리기 위해 데코레이터를 사용합니다.\n\n이제 페이지 데코레이터를 사용하면 저장소 기능도 사용할 수 있습니다. 간단한 클라이언트 측 저장소를 사용할 것입니다. 이를 위해 nicegui에서 app을 가져와야하며, 다음과 같이 사전 기반 저장소인 app.storage.client에 액세스할 수 있습니다.\n\nNiceGUI의 또 다른 기능으로 데이터 작업을 쉽게 만들어주는 기능이 있습니다. 그 방법은 입력 요소를 변수에 바인딩하는 것입니다. 이렇게 함으로써 사용자 프롬프트를위한 입력 요소를 앞서 언급한 클라이언트 저장소에 저장된 변수에 바인딩할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nui.input(label=\"Prompt\").bind_value(app.storage.client, \"prompt\").classes(\"col-span-10\")\n```\n\n이제 입력 요소의 값은 항상 다음과 같이 액세스할 수 있습니다: app.storage.client.get(\"personality\").\n\n그리고 NiceGUI는 버튼 및 기타 요소에 on_click 매개변수를 정의할 수 있도록 합니다. 이 매개변수는 일반 Python 함수에 대한 참조를 취합니다. 이렇게 하면 웹 애플리케이션을 상호 작용 가능하게 할 수 있습니다.\n\n먼저 send() 함수를 소개하겠습니다. 나중에 Gemini LLM과 상호 작용하기 위해 사용할 것입니다. 현재 입력 양식의 현재 입력 값을 사용자에게 간단히 보여줄 것입니다.```\n\n<div class=\"content-ad\"></div>\n\n```js\nfrom nicegui import ui, app\n\ndef send():\n    prompt = app.storage.client.get(\"prompt\")\n    personality = app.storage.client.get(\"personality\")\n    ui.notify(\n        f\"Prompt: {prompt}, Personality: {personality}\",\n        type=\"info\"\n    )\n\n@ui.page('/')\ndef index():\n    with ui.grid(columns=16).classes(\"w-3/4 place-self-center gap-4\"):\n        ui.markdown(\"# 🚀 My Gemini Chatbot\").classes(\"col-span-full\")\n        ui.input(label=\"Prompt\").bind_value(app.storage.client, \"prompt\").classes(\"col-span-10\")\n        ui.select(\n            options=[\"Default\", \"Santa Claus\"],\n            value=\"Default\",\n            label=\"Personality\"\n        ).bind_value(app.storage.client, \"personality\").classes(\"col-span-6\")\n        ui.button(\"Send to Gemini\", on_click=send).classes(\"col-span-full\")\n\n        with ui.card().classes(\"col-span-full\"):\n            ui.markdown(\"## Gemini Response\")\n            ui.separator()\n            ui.label(\"Send your prompt to Gemini and see the response here.\")\n\nui.run()\n```\n\n이제 사용자가 \"Send to Gemini\" 버튼을 클릭할 때마다, 입력 요소의 값이 표시되는 send() 함수를 통해 알림이 표시됩니다.\n\n![image](/assets/img/2024-05-20-CreateyourownGeminiAI-chatbotwithatwistusingPythonJinja2andNiceGUI_6.png)\n\n# Jinja2를 활용한 모듈화된 프롬프트들```\n\n<div class=\"content-ad\"></div>\n\n시간이 되었어요! 🌪️ 사용자 프롬프트를 Gemini에 단순히 전송하는 대신, 사용자 입력을 기반으로 모듈식 프롬프트를 구성할 거에요. 그러면 프롬프트에 개성 부분을 프로그래밍적으로 추가해서 AI가 선택한 사용자에 따라 다른 성격으로 응답할 수 있어요.\n\nJinja2는 파이썬을 위한 템플릿 엔진이에요. Jinja2는 다양한 영역에서 동적 콘텐츠를 생성하는 데 도움이 되죠. 이는 로직과 표현을 분리하여 깨끗하고 유지보수 가능한 코드베이스를 유지할 수 있게 해줘요.\n\nJinja2는 다음과 같은 핵심 개념을 사용해요:\n\n- 템플릿: 사용 사례에 따라 내용이 포함된 텍스트 파일 (예: HTML, 설정 파일, SQL 쿼리).\n- 환경: 템플릿 구성을 관리해요 (예: 구분자, 자동 이스케이핑).\n- 변수: 이중 중괄호 ('' 변수 '')를 사용하여 템플릿에 삽입돼요.\n- 블록: '% ... %' 태그로 정의돼요 (예: 반복, 조건문을 위한) 제어 흐름.\n- 주석: 코드 가독성을 위해 '# ... #'로 묶여 있어요.\n\n<div class=\"content-ad\"></div>\n\nJinja2은 웹 개발에서 많이 사용되지만, 동적 콘텐츠를 생성하는 데 유용하기 때문에 Airflow와 같은 다른 경우에도 사용됩니다.\n\n이 프로젝트에서는 특정 인격과 사용자 프롬프트로 대체되는 변수를 포함하는 일반 템플릿을 정의하는 데 사용할 것입니다. 이렇게 하면 Python 코드가 깔끔하게 유지되고 쉽게 확장할 수 있는 모듈식 솔루션을 갖게 됩니다. 스포일러: 나중에 매우 재미있는 인격을 소개할 예정입니다.\n\nJinja2를 사용하기 전에 프로젝트 의존성에 추가해야 합니다. Poetry를 사용하고 있으므로 다음을 통해 수행할 수 있습니다:\n\n```js\npoetry add jinja2\n```\n\n<div class=\"content-ad\"></div>\n\n우리는 템플릿을 저장할 폴더도 필요합니다. 좋은 기본 사례는 모듈 폴더에 templates라는 폴더를 추가하는 것입니다. 그러니 이 경우에는:\n\n```js\nmkdir my_gemini_chatbot/templates\n```\n\n<img src=\"/assets/img/2024-05-20-CreateyourownGeminiAI-chatbotwithatwistusingPythonJinja2andNiceGUI_7.png\" />\n\nJinja2를 사용하려면 환경을 설정해야 합니다. 위에서 설명한 대로, 환경은 일반 템플릿 구성을 관리합니다. 우리는 간단하게 유지하고 Jinja2가 우리의 폴더에서 템플릿을 찾도록 만들겠습니다:\n\n<div class=\"content-ad\"></div>\n\n\nenv = Environment(\n    loader=PackageLoader(\"my_gemini_chatbot\"),\n    autoescape=select_autoescape()\n)\n\n\n이제 템플릿을 준비할 시간입니다. templates/ 폴더 내에 prompt.jinja, default.jinja 및 santaclaus.jinja 세 개의 파일을 생성하십시오. default.jinja 파일은 비워두세요. 기본 펄스널리티는 Gemini의 정상 동작일 것이므로요.\n\n![image](/assets/img/2024-05-20-CreateyourownGeminiAI-chatbotwithatwistusingPythonJinja2andNiceGUI_8.png)\n\n다음 내용을 prompt.jinja 템플릿에 추가해 봅시다. 이것은 기본 템플릿입니다:```\n\n<div class=\"content-ad\"></div>\n\n```md\n{ 성격 }\n\n{ 프롬프트 }\n```\n\n이제, santaclaus.jinja에 다음 내용을 추가하여 산타클로스 성격을 정의해 봅시다:\n\n```js\n당신은 산타클로스이며 크리스마스를 사랑합니다. 당신의 답변에는 크리스마스와 관련된 사실과 퀴즈를 최대한 추가해 보세요. 또한 답변을 항상 엄격하게 \"Ho ho ho\"로 시작하고 \"메리 크리스마스\"로 끝내세요. 당신은 진정한 크리스마스 애호가입니다.\n```\n\n빠른 알림: 웹 UI에는 성격을 선택하는 select 요소가 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nui.select(\n    options=[\"Default\", \"Santa Claus\"],\n    value=\"Default\",\n    label=\"성격\"\n).bind_value(app.storage.client, \"personality\").classes(\"col-span-6\")\n```\n\n작은 도우미 함수를 사용하겠습니다. 이 함수는 선택한 값을 템플릿 파일로 매핑합니다:\n\n```js\ndef get_personality_file(value):\n    match value:\n        case \"Default\":\n            return \"default.jinja\"\n        case \"Santa Claus\":\n            return \"santaclaus.jinja\"\n        case _:\n            return \"default.jinja\"\n```\n\n이제 이 도우미 함수와 Jinja2 환경의 get_template 기능을 사용하여 템플릿을 사용한 프롬프트를 만들 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```python\nfrom jinja2 import Environment, PackageLoader, select_autoescape\nfrom nicegui import ui, app\n\n\nenv = Environment(\n    loader=PackageLoader(\"my_gemini_chatbot\"),\n    autoescape=select_autoescape()\n)\n\n\ndef get_personality_file(value):\n    match value:\n        case \"Default\":\n            return \"default.jinja\"\n        case \"Santa Claus\":\n            return \"santaclaus.jinja\"\n        case _:\n            return \"default.jinja\"\n\n\ndef send():\n    user_prompt = app.storage.client.get(\"prompt\")\n    personality = app.storage.client.get(\"personality\")\n\n    personality_template = env.get_template(get_personality_file(personality))\n    prompt_template = env.get_template(\"prompt.jinja\")\n\n    prompt = prompt_template.render(\n        prompt=user_prompt,\n        personality=personality_template.render()\n    )\n\n    ui.notify(\n        f\"Prompt: {prompt}\",\n        type=\"info\"\n    )\n\n\n@ui.page('/')\ndef index():\n    with ui.grid(columns=16).classes(\"w-3/4 place-self-center gap-4\"):\n        ui.markdown(\"# 🚀 My Gemini Chatbot\").classes(\"col-span-full\")\n        ui.input(label=\"Prompt\").bind_value(app.storage.client, \"prompt\").classes(\"col-span-10\")\n        ui.select(\n            options=[\"Default\", \"Santa Claus\"],\n            value=\"Default\",\n            label=\"Personality\"\n        ).bind_value(app.storage.client, \"personality\").classes(\"col-span-6\")\n        ui.button(\"Send to Gemini\", on_click=send).classes(\"col-span-full\")\n\n        with ui.card().classes(\"col-span-full\"):\n            ui.markdown(\"## Gemini Response\")\n            ui.separator()\n            ui.label(\"Send your prompt to Gemini and see the response here.\")\n\n\nui.run()\n```\n\n지금 \"Send to Gemini\"을 클릭하면 Jinja2 템플릿을 기반으로 만든 모듈화된 프롬프트를 볼 수 있습니다.\n\n<img src=\"/assets/img/2024-05-20-CreateyourownGeminiAI-chatbotwithatwistusingPythonJinja2andNiceGUI_9.png\" />\n\n# VertexAI를 통해 Gemini LLM 통합하기\n\n\n<div class=\"content-ad\"></div>\n\n젬니아이(GeminiAI)를 사용하기 위해서는 VertexAI를 통해 Gemini에 연결하려면, VertexAI가 활성화된 Google Cloud 프로젝트와 충분한 액세스 권한을 가진 서비스 계정 및 해당 계정의 JSON 키 파일이 필요합니다.\n\n![](/assets/img/2024-05-20-CreateyourownGeminiAI-chatbotwithatwistusingPythonJinja2andNiceGUI_10.png)\n\n새 프로젝트를 생성한 후, APIs 및 서비스 - ` API 및 서비스 활성화 - ` VertexAI API 검색 - ` 활성화로 이동합니다.\n\n![](/assets/img/2024-05-20-CreateyourownGeminiAI-chatbotwithatwistusingPythonJinja2andNiceGUI_11.png)\n\n<div class=\"content-ad\"></div>\n\n서비스 계정을 생성하려면 IAM 및 관리 - 서비스 계정 - 서비스 계정 만들기로 이동하십시오. 적절한 이름을 선택하고 다음 단계로 이동하십시오.\n\n![이미지](/assets/img/2024-05-20-CreateyourownGeminiAI-chatbotwithatwistusingPythonJinja2andNiceGUI_12.png)\n\n이제 계정에 미리 정의된 역할 Vertex AI 사용자를 할당하는지 확인하십시오.\n\n![이미지](/assets/img/2024-05-20-CreateyourownGeminiAI-chatbotwithatwistusingPythonJinja2andNiceGUI_13.png)\n\n<div class=\"content-ad\"></div>\n\n마침내 새로운 사용자 → 키 → 키 추가 → 새 키 생성 → JSON을 클릭하여 JSON 키 파일을 생성하고 다운로드할 수 있습니다. 이 파일이 있으면 사용할 준비가 된 것입니다.\n\n![이미지](/assets/img/2024-05-20-CreateyourownGeminiAI-chatbotwithatwistusingPythonJinja2andNiceGUI_14.png)\n\nJSON 자격 증명 키 파일을 준비하고 프로젝트 내에 저장한 후에는 VertexAI를 초기화할 수 있습니다.\n\n```js\ncredentials = service_account.Credentials.from_service_account_file(\n    \"gcp-vojay-gemini.json\"\n)\nvertexai.init(project=\"vojay-329716\", location=\"us-central1\", credentials=credentials)\n```\n\n<div class=\"content-ad\"></div>\n\n이제 VertexAI를 통해 모델을 로드할 수 있어요. 저희는 Gemini Pro 모델을 사용할 거예요.\n\n```js\nmodel = GenerativeModel(\"gemini-pro\")\n```\n\n이 모델은 대화를 시작하는 start_chat 함수를 제공해요. 이 함수는 Gemini에 데이터를 보내는 send_message 함수를 가진 Chat 객체를 반환해요. 여기서 generation config 매개변수를 조정할 수도 있어요. 여기서는 기본값을 사용할 거예요. Gemini로부터의 응답을 스트리밍하기 때문에, 전체 채팅 응답을 받기 위해 도우미 함수를 사용할 거에요:\n\n```js\ndef get_chat_response(chat, prompt):\n    text_response = []\n    responses = chat.send_message(prompt, stream=True)\n    for chunk in responses:\n        text_response.append(chunk.text)\n    return ''.join(text_response)\n```\n\n<div class=\"content-ad\"></div>\n\n그럼 이 정도면 괜찮네요. 우리는 준비된 프롬프트와 VertexAI가 초기화된 상태이며, 채팅 응답을 가져오는 도우미 함수를 사용하여 마침내 Gemini를 통합할 수 있게 되었어요.\n\n클라이언트 스토리지에서 변수에 바인딩된 레이블을 추가할 것이고, 이 레이블은 Gemini 응답을 저장하고 렌더링하는 데 사용될 거에요:\n\n```js\nui.label().bind_text(app.storage.client, \"response\")\n```\n\n이제 첫 번째 버전이 준비되었습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nimport vertexai\nfrom google.oauth2 import service_account\nfrom jinja2 import Environment, PackageLoader, select_autoescape\nfrom nicegui import ui, app\nfrom vertexai.generative_models import GenerativeModel\n\ncredentials = service_account.Credentials.from_service_account_file(\n    \"../gcp-vojay-gemini.json\"\n)\nvertexai.init(project=\"vojay-329716\", location=\"us-central1\", credentials=credentials)\n\nenv = Environment(\n    loader=PackageLoader(\"my_gemini_chatbot\"),\n    autoescape=select_autoescape()\n)\n\nmodel = GenerativeModel(\"gemini-pro\")\n\n\ndef get_chat_response(chat, prompt):\n    text_response = []\n    responses = chat.send_message(prompt, stream=True)\n    for chunk in responses:\n        text_response.append(chunk.text)\n    return ''.join(text_response)\n\n\ndef get_personality_file(value):\n    match value:\n        case \"Default\":\n            return \"default.jinja\"\n        case \"Santa Claus\":\n            return \"santaclaus.jinja\"\n        case _:\n            return \"default.jinja\"\n\n\ndef send():\n    user_prompt = app.storage.client.get(\"prompt\")\n    personality = app.storage.client.get(\"personality\")\n\n    personality_template = env.get_template(get_personality_file(personality))\n    prompt_template = env.get_template(\"prompt.jinja\")\n\n    prompt = prompt_template.render(\n        prompt=user_prompt,\n        personality=personality_template.render()\n    )\n\n    ui.notify(\"Sending to Gemini...\", type=\"info\")\n    chat = model.start_chat()\n    response = get_chat_response(chat, prompt)\n    ui.notify(\"Received response...\", type=\"info\")\n\n    app.storage.client[\"response\"] = response\n\n\n@ui.page('/')\ndef index():\n    with ui.grid(columns=16).classes(\"w-3/4 place-self-center gap-4\"):\n        ui.markdown(\"# 🚀 My Gemini Chatbot\").classes(\"col-span-full\")\n        ui.input(label=\"Prompt\").bind_value(app.storage.client, \"prompt\").classes(\"col-span-10\")\n        ui.select(\n            options=[\"Default\", \"Santa Claus\"],\n            value=\"Default\",\n            label=\"Personality\"\n        ).bind_value(app.storage.client, \"personality\").classes(\"col-span-6\")\n        ui.button(\"Send to Gemini\", on_click=send).classes(\"col-span-full\")\n\n        with ui.card().classes(\"col-span-full\"):\n            ui.markdown(\"## Gemini Response\")\n            ui.separator()\n            ui.label().bind_text(app.storage.client, \"response\")\n\n\nui.run()\n```\n\n<div class=\"content-ad\"></div>\n\n![GeminiAI Chatbot](/assets/img/2024-05-20-CreateyourownGeminiAI-chatbotwithatwistusingPythonJinja2andNiceGUI_16.png)\n\n# AI가 바에 들어가다\n\n저는 아빠가 된 이후로, 가능한 경우에 아빠 농담을 해주는 기회를 즐기고 있어요. 이 장에서는 Jinja2를 사용한 모듈식 접근 방법과 NiceGUI를 사용한 간단한 웹 UI의 이점을 설명하고 싶어 합니다.\n\n새로운 개성을 소개해보죠. dadjokes.jinja와 같이 다른 파일 옆에 새로운 템플릿 파일을 만들어 다음 내용을 추가하세요.\n\n<div class=\"content-ad\"></div>\n\n넌 자랍니다. 하지만, 거의 모든 문장에 아빠 농담을 추가해야 합니다. 답변에 가능한 한 많은 아빠 농담을 넣고, 입력과 관련된 농담을 만드려고 노력해주세요. 또한, 답변에 많은 이모지를 추가하고 싶어 금을 참지 못할 겁니다. 😉👨‍👧‍👦\n\n이를 실행하기 위해 우리는 우리의 도우미 함수인 get_personality_file을 확장해야 합니다. 👨‍💻\n\n```js\ndef get_personality_file(value):\n    match value:\n        case \"Default\":\n            return \"default.jinja\"\n        case \"Santa Claus\":\n            return \"santaclaus.jinja\"\n        case \"Dad Jokes\":\n            return \"dadjokes.jinja\"\n        case _:\n            return \"default.jinja\" 😄\n```\n\n그리고 우리의 입력 요소에 새 옵션을 추가하여 사용자가 새로운 옵션을 선택할 수 있도록 합시다. 🎁🧔\n\n\n<div class=\"content-ad\"></div>\n\n```js\nui.select(\n    options=[\"기본\", \"산타 클로스\", \"아빠 Jokes\"],\n    value=\"기본\",\n    label=\"성격\"\n).bind_value(app.storage.client, \"personality\").classes(\"col-span-6\")\n```\n\n이제 해보기 전에 한 가지 더 구현해 봅시다. 다크 모드를 도입해 보겠습니다! NiceGUI를 사용하면 이 작업이 매우 간단합니다. ui.dark_mode()를 통해 UI 모드를 전환하기 위한 disable 및 enable 두 가지 함수를 제공하는 dark 객체를 얻을 수 있습니다. 그리드 접근 방식과 함께 사용하여 \"젬니니로 전송\" 버튼 옆에 UI 모드를 전환하는 두 개의 버튼을 쉽게 배치할 수 있습니다. 다음과 같이 코드 작성하세요:\n\n```js\nui.button(\"젬니니로 전송\", on_click=send).classes(\"col-span-8\")\n\ndark = ui.dark_mode()\nui.button(\"라이트 UI\", on_click=dark.disable).classes(\"col-span-4\")\nui.button(\"다크 UI\", on_click=dark.enable).classes(\"col-span-4\")\n```\n\n\"젬니니로 전송\" 버튼이 col-span-full 클래스 대신 col-span-8 클래스를 사용하고 있음을 알 수 있습니다. 또한 16개 열의 그리드를 사용하므로 바로 옆에 각각 col-span-4를 사용하여 두 개의 새로운 버튼을 추가할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n표를 Markdown 형식으로 바꾸는 방법은 다음과 같아요:\n\n\n| Function | Description         |\n|----------|---------------------|\n| ui.run() | 애플리케이션 실행   |\n| ui.page()| 페이지 만들기       |\n| ui.button()| 버튼 생성         |\n\n\n위와 같이 수정하시면 Markdown 형식으로 표를 작성할 수 있어요!\n\n<div class=\"content-ad\"></div>\n\n아빠로서 이걸 승인합니다 😂.\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*9xgCK0hrAI4XznUwk44o-w.gif)\n\n# 결론\n\n농담은 농담이고, 이 글을 통해 Gemini LLM을 기반으로 자체 AI 챗봇을 만들고 VertexAI와 함께 파이썬을 사용하여 NiceGUI로 간단한 웹 UI를 만드는 방법을 배웠습니다. Jinja2 템플릿을 사용하여, 이 비교적 짧은 예제조차도 확장하기 쉬운 모듈식 AI 애플리케이션을 제공했습니다.\n\n<div class=\"content-ad\"></div>\n\n\n![GeminiAI Chatbot](/assets/img/2024-05-20-CreateyourownGeminiAI-chatbotwithatwistusingPythonJinja2andNiceGUI_18.png)\n\n파이썬, Jinja2 및 NiceGUI를 사용하면 VertexAI의 Gemini LLM과 상호 작용하는 사용자 친화적 인터페이스를 구축할 수 있습니다. 이를 통해 교육용 챗봇부터 재미있는 개성 기반 챗 체험까지 다양한 창의적인 응용 프로그램이 가능해집니다.\n\n이 블로그 글이 여러분들에게 VertexAI의 잠재력을 탐험하고 자체 AI 애플리케이션을 구축해보는데 영감을 줬기를 희망합니다.\n\n즐기고, 지시를 따르는 데 서툰 AI를 무엇이라고 부를까요? — 절망적 절자 없는 반란자.\n","ogImage":{"url":"/assets/img/2024-05-20-CreateyourownGeminiAI-chatbotwithatwistusingPythonJinja2andNiceGUI_0.png"},"coverImage":"/assets/img/2024-05-20-CreateyourownGeminiAI-chatbotwithatwistusingPythonJinja2andNiceGUI_0.png","tag":["Tech"],"readingTime":20},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<h2>파이썬을 사용하여 베르텍스AI를 통해 Gemini의 기본 사항을 알아보고 NiceGUI를 사용하여 웹 UI를 만들며 모듈식 프롬프트를 구성하는 Jinja2를 사용하는 방법</h2>\n<p><img src=\"/assets/img/2024-05-20-CreateyourownGeminiAI-chatbotwithatwistusingPythonJinja2andNiceGUI_0.png\" alt=\"이미지\"></p>\n<p>본문에서는 Python, NiceGUI, Jinja2 및 VertexAI를 사용하여 LLM 기반 웹 애플리케이션을 만들어보겠습니다. 이 프로젝트를 처음부터 만드는 방법과 기본 개념의 개요를 얻을 수 있습니다.</p>\n<p>먼저 🚀 기술 스택에 대한 간단한 개요로 시작해 보겠습니다:</p>\n<ul>\n<li>Python 3.12</li>\n<li>NiceGUI를 사용하여 파이썬으로 프론트엔드를 코딩합니다.</li>\n<li>의존성 관리를 위해 Poetry 사용</li>\n<li>모듈식 프롬프트 생성을 위해 Jinja2 템플릿 사용</li>\n</ul>\n<h1>Poetry를 사용한 프로젝트 설정</h1>\n<p>우리는 Python에서 의존성 관리와 패키징을 위한 도구인 Poetry를 사용하여 프로젝트를 생성하고 의존성을 어떻게 관리하는지 살펴볼 것입니다.</p>\n<p>Poetry가 도와줄 수 있는 세 가지 주요 작업은 빌드, 게시 및 추적입니다. 의존성을 관리하고 프로젝트를 공유하며 의존성 상태를 추적할 수 있는 결정론적인 방법이 되는 것이 아이디어입니다.</p>\n<p>시, Poetry는 가상 환경을 생성하는 작업도 담당합니다. 기본적으로 시스템 내의 중앙 폴더에 위치하는데요. 하지만 저와 같이 프로젝트 관련 가상 환경을 프로젝트 폴더 내에 가지고 싶다면, 간단한 설정 변경이 필요합니다:</p>\n<pre><code class=\"hljs language-js\">poetry config virtualenvs.<span class=\"hljs-property\">in</span>-project <span class=\"hljs-literal\">true</span>\n</code></pre>\n<p>Poetry new를 사용하여 새로운 Python 프로젝트를 만들 수 있습니다. 이 작업은 시스템의 기본 Python과 링크되는 가상 환경이 생성됩니다. 이것을 pyenv와 결합하면 특정 버전을 사용하는 프로젝트를 유연하게 만들 수 있습니다. 또한, Poetry에 직접 사용할 Python 버전을 알려줄 수도 있습니다: poetry env use /full/path/to/python.</p>\n<p>새 프로젝트를 생성하면, poetry add로 종속성을 추가할 수 있습니다.</p>\n<p>새 프로젝트를 만들어 시작해봐요:</p>\n<pre><code class=\"hljs language-js\">poetry config virtualenvs.<span class=\"hljs-property\">in</span>-project <span class=\"hljs-literal\">true</span>\npoetry <span class=\"hljs-keyword\">new</span> my-gemini-chatbot\ncd my-gemini-chatbot\n</code></pre>\n<p>프로젝트에 대한 메타데이터 및 해당 버전과 종속성은 .toml 및 .lock 파일에 저장됩니다.</p>\n<p>이제 시작하기 위해 필요한 종속성을 추가해 봅시다:</p>\n<pre><code class=\"hljs language-js\">poetry add <span class=\"hljs-string\">'google-cloud-aiplatform>=1.38'</span>\npoetry add <span class=\"hljs-string\">'nicegui'</span>\n</code></pre>\n<h1>NiceGUI를 사용한 기본 웹 UI</h1>\n<p>NiceGUI는 웹 브라우저용 그래픽 사용자 인터페이스(GUI)를 만들 수 있게 해주는 Python 라이브러리입니다. 초보자들도 빠르게 시작할 수 있지만, 고급 사용자들을 위한 맞춤 설정 옵션도 풍부하게 제공합니다. 웹 뷰는 Quasar Framework를 기반으로 하며, 다양한 구성 요소를 제공합니다. 그리고 이는 TailwindCSS를 사용하기 때문에 NiceGUI 페이지에서도 직접 TailwindCSS 클래스를 사용할 수 있습니다.</p>\n<p>특히 나에게는 백엔드 소프트웨어 개발에서 온 데이터 엔지니어로써, Python을 사용하여 작은 웹 UI를 만드는 것은 좋은 방법입니다. 물론 더 복잡한 프론트엔드에 대해서는 충분한 해결책이 되지 않을 수도 있지만, 범위가 상대적으로 작다면 빠르게 결과를 확인할 수 있습니다. NiceGUI를 사용하면 Python 코드에 집중할 수 있습니다. 왜냐하면 NiceGUI가 모든 웹 개발 작업을 처리하기 때문입니다.</p>\n<p>NiceGUI는 버튼, 슬라이더, 텍스트 상자와 같은 일반적인 UI 구성 요소를 사용하고 유연한 레이아웃을 사용하여 페이지에 배열합니다. 이러한 구성 요소는 Python 코드의 데이터와 연결될 수 있어 데이터가 변경될 때 인터페이스가 자동으로 업데이트됩니다. 또한 응용 프로그램의 외관을 필요에 맞게 스타일링할 수도 있습니다.</p>\n<p>이 작업 방식을 설명하는 가장 쉬운 방법은 직접 보여주는 것입니다. 그래서 최소 예제를 만들기 시작해 봅시다.</p>\n<p>내 경우에는 내 모듈의 main.py (내 경우 my_gemini_chatbot)를 생성합니다. 이 파일은 모든 어플리케이션과 프론트엔드 로직에 사용될 것입니다.</p>\n<p>다음 코드로 간단한 레이블이 포함된 페이지를 얻을 수 있습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">from</span> nicegui <span class=\"hljs-keyword\">import</span> ui\n\nui.<span class=\"hljs-title function_\">label</span>(<span class=\"hljs-string\">'Hello NiceGUI!'</span>)\nui.<span class=\"hljs-title function_\">run</span>()\n</code></pre>\n<p>애플리케이션을 실행하면 포트 8080에서 사용할 수 있습니다. 또한 스크립트를 실행할 때 페이지가 자동으로 열립니다. 이것이 페이지가 보이는 방법입니다:</p>\n<p>축하합니다: 순수 Python으로 만든 첫 프론트엔드 😉.</p>\n<h1>챗봇 웹 UI 준비</h1>\n<p>다음 단계는 우리 챗봇을 위한 웹 UI를 준비하는 것입니다. 물론, 위의 예제보다는 조금 더 복잡할 것이지만 NiceGUI를 사용하여 컴포넌트를 배치하는 기본 아이디어를 알면 더 쉬워질 것입니다.</p>\n<p>먼저 몇 가지 레이아웃 기본 사항을 이해해야 합니다. 컴포넌트가 페이지 상에 배치되는 방식을 제어하는 여러 가지 방법이 있습니다. 일반적인 방법 중 하나는 그리드 레이아웃인데, 우리는 이를 사용할 것입니다.</p>\n<p>NiceGUI에서 우리는 다음과 같이 그리드를 생성할 수 있습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">from</span> nicegui <span class=\"hljs-keyword\">import</span> ui\n\n<span class=\"hljs-keyword\">with</span> ui.<span class=\"hljs-title function_\">grid</span>(columns=<span class=\"hljs-number\">16</span>).<span class=\"hljs-title function_\">classes</span>(<span class=\"hljs-string\">\"w-3/4 place-self-center gap-4\"</span>):\n    ui.<span class=\"hljs-title function_\">markdown</span>(<span class=\"hljs-string\">\"# 🚀 My Gemini Chatbot\"</span>).<span class=\"hljs-title function_\">classes</span>(<span class=\"hljs-string\">\"col-span-full\"</span>)\n\nui.<span class=\"hljs-title function_\">run</span>()\n</code></pre>\n<p>이를 하나씩 분해하여 더 잘 이해해 봅시다. ui.grid(columns=16)은 16개의 열로 분할된 그리드 레이아웃을 초기화합니다. 이들은 모두 동일한 너비를 갖습니다. 이것은 그리드의 실제 너비에 대해 아무 말도 하지 않으며 그리드가 몇 개의 열로 나눠질지만을 지정합니다. 16개의 열로, 우리는 충분한 유연성을 얻을 수 있습니다.</p>\n<p>우리는 .classes를 통해 사용자 정의 TailwindCSS 클래스를 추가할 수 있습니다. 여기서 우리는 그리드에 3가지 클래스를 추가했습니다:</p>\n<ul>\n<li>w-3/4: 그리드는 항상 브라우저 전체 너비의 3/4을 차지해야 합니다.</li>\n<li>place-self-center: 그리드 자체가 브라우저 창 가운데에 위치해야 합니다.</li>\n<li>gap-4: 그리드 내 요소 사이에는 4개의 픽셀 간격이 있어야 합니다.</li>\n</ul>\n<p>위 예시에서는 그리드 안에 요소 하나를 배치했습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">with</span> ui.<span class=\"hljs-title function_\">grid</span>(columns=<span class=\"hljs-number\">16</span>).<span class=\"hljs-title function_\">classes</span>(<span class=\"hljs-string\">\"w-3/4 place-self-center gap-4\"</span>):\n    ui.<span class=\"hljs-title function_\">markdown</span>(<span class=\"hljs-string\">\"# 🚀 My Gemini Chatbot\"</span>).<span class=\"hljs-title function_\">classes</span>(<span class=\"hljs-string\">\"col-span-full\"</span>)\n</code></pre>\n<p>위에서 확인할 수 있듯이, 우리는 다시 col-span-full이라는 사용자 정의 클래스를 할당했습니다. 이는 NiceGUI에게 이 요소가 첫 번째 행의 모든 사용 가능한 열을 사용해야 함을 알려줍니다. 우리의 경우: 모든 16열을 사용합니다.</p>\n<p>모든 열의 양에 대한 클래스가 있으므로 첫 번째 요소에 col-span-10을 할당하고 두 번째 요소에 col-span-6을 할당하여 한 행에 2개의 요소를 채울 수도 있습니다.</p>\n<p>이 지식을 바탕으로 우리의 챗봇에 필요한 모든 요소를 추가할 수 있습니다:</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">from</span> nicegui <span class=\"hljs-keyword\">import</span> ui\n\n<span class=\"hljs-keyword\">with</span> ui.grid(columns=<span class=\"hljs-number\">16</span>).classes(<span class=\"hljs-string\">\"w-3/4 place-self-center gap-4\"</span>):\n    ui.markdown(<span class=\"hljs-string\">\"# 🚀 우리의 Gemini 챗봇\"</span>).classes(<span class=\"hljs-string\">\"col-span-full\"</span>)\n    ui.<span class=\"hljs-built_in\">input</span>(label=<span class=\"hljs-string\">\"프롬프트\"</span>).classes(<span class=\"hljs-string\">\"col-span-10\"</span>)\n    ui.select(\n        options=[<span class=\"hljs-string\">\"기본\"</span>, <span class=\"hljs-string\">\"산타 클로스\"</span>],\n        value=<span class=\"hljs-string\">\"기본\"</span>,\n        label=<span class=\"hljs-string\">\"성격 선택\"</span>\n    ).classes(<span class=\"hljs-string\">\"col-span-6\"</span>)\n    ui.button(<span class=\"hljs-string\">\"Gemini로 전송\"</span>).classes(<span class=\"hljs-string\">\"col-span-full\"</span>)\n\n    <span class=\"hljs-keyword\">with</span> ui.card().classes(<span class=\"hljs-string\">\"col-span-full\"</span>):\n        ui.markdown(<span class=\"hljs-string\">\"## Gemini 응답\"</span>)\n        ui.separator()\n        ui.label(<span class=\"hljs-string\">\"Gemini에 프롬프트를 보내고 응답을 여기서 확인하세요.\"</span>)\n\nui.run()\n</code></pre>\n<p>위의 코드는 다음과 같은 웹 UI를 만들어냅니다:</p>\n<p>Python으로 완전히 작성된 UI로는 꽤 괜찮은 결과가 나온 것 같네요.```</p>\n<h1>기본 기능 추가하기</h1>\n<p>우리의 다음 작업은 기본 기능을 추가하는 것입니다. 아직 VertexAI나 Gemini와 상호 작용하지는 않겠지만, Gemini로 전송 버튼을 클릭하면 사용자 입력을 반영하는 알림이 표시되도록 기능을 추가하려고 합니다.</p>\n<p>중요한 개념 하나를 설명해 드리겠습니다: 우리의 프론트엔드는 우리 Python 스크립트의 한 인스턴스에 의해 제공됩니다. 이제 사용자 입력을 전역 변수에 저장하고 있는데, 동시에 챗봇을 사용하고 있는 다른 사용자가 다른 값을 제출한다고 상상해 보십시오. 그러면 첫 번째 사용자의 값이 덮어쓰여지기 때문에 재밌지만 예상치 못한 동작이 발생할 것입니다.</p>\n<p>최근 NiceGUI에서는 이러한 상황을 다루기 위해 '저장소' 기능을 소개했습니다. 이는 데이터 지속성을 위한 간단한 메커니즘으로, 클라이언트 측에 데이터를 저장하는 것과 서버 측에 데이터를 저장하는 것을 포함한 다섯 가지 내장 저장 유형을 기반으로 합니다.</p>\n<p>그러나 저장소 기능은 페이지 빌더의 컨텍스트에서만 사용할 수 있습니다. 기본적으로 이것은 다음을 의미합니다: 메인 스크립트에서 웹 페이지를 간단히 코딩하는 대신, 각 페이지마다 함수로 래핑합니다. 우리는 한 페이지만 가지고 있으므로 하나의 함수만 필요합니다: index(). 그런 다음 해당 함수가 메인 인덱스 페이지인 /로 정의된 페이지를 나타낸다고 NiceGUI에 알리기 위해 데코레이터를 사용합니다.</p>\n<p>이제 페이지 데코레이터를 사용하면 저장소 기능도 사용할 수 있습니다. 간단한 클라이언트 측 저장소를 사용할 것입니다. 이를 위해 nicegui에서 app을 가져와야하며, 다음과 같이 사전 기반 저장소인 app.storage.client에 액세스할 수 있습니다.</p>\n<p>NiceGUI의 또 다른 기능으로 데이터 작업을 쉽게 만들어주는 기능이 있습니다. 그 방법은 입력 요소를 변수에 바인딩하는 것입니다. 이렇게 함으로써 사용자 프롬프트를위한 입력 요소를 앞서 언급한 클라이언트 저장소에 저장된 변수에 바인딩할 수 있습니다:</p>\n<pre><code class=\"hljs language-js\">ui.<span class=\"hljs-title function_\">input</span>(label=<span class=\"hljs-string\">\"Prompt\"</span>).<span class=\"hljs-title function_\">bind_value</span>(app.<span class=\"hljs-property\">storage</span>.<span class=\"hljs-property\">client</span>, <span class=\"hljs-string\">\"prompt\"</span>).<span class=\"hljs-title function_\">classes</span>(<span class=\"hljs-string\">\"col-span-10\"</span>)\n</code></pre>\n<p>이제 입력 요소의 값은 항상 다음과 같이 액세스할 수 있습니다: app.storage.client.get(\"personality\").</p>\n<p>그리고 NiceGUI는 버튼 및 기타 요소에 on_click 매개변수를 정의할 수 있도록 합니다. 이 매개변수는 일반 Python 함수에 대한 참조를 취합니다. 이렇게 하면 웹 애플리케이션을 상호 작용 가능하게 할 수 있습니다.</p>\n<p>먼저 send() 함수를 소개하겠습니다. 나중에 Gemini LLM과 상호 작용하기 위해 사용할 것입니다. 현재 입력 양식의 현재 입력 값을 사용자에게 간단히 보여줄 것입니다.```</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">from</span> nicegui <span class=\"hljs-keyword\">import</span> ui, app\n\ndef <span class=\"hljs-title function_\">send</span>():\n    prompt = app.<span class=\"hljs-property\">storage</span>.<span class=\"hljs-property\">client</span>.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">\"prompt\"</span>)\n    personality = app.<span class=\"hljs-property\">storage</span>.<span class=\"hljs-property\">client</span>.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">\"personality\"</span>)\n    ui.<span class=\"hljs-title function_\">notify</span>(\n        f<span class=\"hljs-string\">\"Prompt: {prompt}, Personality: {personality}\"</span>,\n        type=<span class=\"hljs-string\">\"info\"</span>\n    )\n\n@ui.<span class=\"hljs-title function_\">page</span>(<span class=\"hljs-string\">'/'</span>)\ndef <span class=\"hljs-title function_\">index</span>():\n    <span class=\"hljs-keyword\">with</span> ui.<span class=\"hljs-title function_\">grid</span>(columns=<span class=\"hljs-number\">16</span>).<span class=\"hljs-title function_\">classes</span>(<span class=\"hljs-string\">\"w-3/4 place-self-center gap-4\"</span>):\n        ui.<span class=\"hljs-title function_\">markdown</span>(<span class=\"hljs-string\">\"# 🚀 My Gemini Chatbot\"</span>).<span class=\"hljs-title function_\">classes</span>(<span class=\"hljs-string\">\"col-span-full\"</span>)\n        ui.<span class=\"hljs-title function_\">input</span>(label=<span class=\"hljs-string\">\"Prompt\"</span>).<span class=\"hljs-title function_\">bind_value</span>(app.<span class=\"hljs-property\">storage</span>.<span class=\"hljs-property\">client</span>, <span class=\"hljs-string\">\"prompt\"</span>).<span class=\"hljs-title function_\">classes</span>(<span class=\"hljs-string\">\"col-span-10\"</span>)\n        ui.<span class=\"hljs-title function_\">select</span>(\n            options=[<span class=\"hljs-string\">\"Default\"</span>, <span class=\"hljs-string\">\"Santa Claus\"</span>],\n            value=<span class=\"hljs-string\">\"Default\"</span>,\n            label=<span class=\"hljs-string\">\"Personality\"</span>\n        ).<span class=\"hljs-title function_\">bind_value</span>(app.<span class=\"hljs-property\">storage</span>.<span class=\"hljs-property\">client</span>, <span class=\"hljs-string\">\"personality\"</span>).<span class=\"hljs-title function_\">classes</span>(<span class=\"hljs-string\">\"col-span-6\"</span>)\n        ui.<span class=\"hljs-title function_\">button</span>(<span class=\"hljs-string\">\"Send to Gemini\"</span>, on_click=send).<span class=\"hljs-title function_\">classes</span>(<span class=\"hljs-string\">\"col-span-full\"</span>)\n\n        <span class=\"hljs-keyword\">with</span> ui.<span class=\"hljs-title function_\">card</span>().<span class=\"hljs-title function_\">classes</span>(<span class=\"hljs-string\">\"col-span-full\"</span>):\n            ui.<span class=\"hljs-title function_\">markdown</span>(<span class=\"hljs-string\">\"## Gemini Response\"</span>)\n            ui.<span class=\"hljs-title function_\">separator</span>()\n            ui.<span class=\"hljs-title function_\">label</span>(<span class=\"hljs-string\">\"Send your prompt to Gemini and see the response here.\"</span>)\n\nui.<span class=\"hljs-title function_\">run</span>()\n</code></pre>\n<p>이제 사용자가 \"Send to Gemini\" 버튼을 클릭할 때마다, 입력 요소의 값이 표시되는 send() 함수를 통해 알림이 표시됩니다.</p>\n<p><img src=\"/assets/img/2024-05-20-CreateyourownGeminiAI-chatbotwithatwistusingPythonJinja2andNiceGUI_6.png\" alt=\"image\"></p>\n<h1>Jinja2를 활용한 모듈화된 프롬프트들```</h1>\n<p>시간이 되었어요! 🌪️ 사용자 프롬프트를 Gemini에 단순히 전송하는 대신, 사용자 입력을 기반으로 모듈식 프롬프트를 구성할 거에요. 그러면 프롬프트에 개성 부분을 프로그래밍적으로 추가해서 AI가 선택한 사용자에 따라 다른 성격으로 응답할 수 있어요.</p>\n<p>Jinja2는 파이썬을 위한 템플릿 엔진이에요. Jinja2는 다양한 영역에서 동적 콘텐츠를 생성하는 데 도움이 되죠. 이는 로직과 표현을 분리하여 깨끗하고 유지보수 가능한 코드베이스를 유지할 수 있게 해줘요.</p>\n<p>Jinja2는 다음과 같은 핵심 개념을 사용해요:</p>\n<ul>\n<li>템플릿: 사용 사례에 따라 내용이 포함된 텍스트 파일 (예: HTML, 설정 파일, SQL 쿼리).</li>\n<li>환경: 템플릿 구성을 관리해요 (예: 구분자, 자동 이스케이핑).</li>\n<li>변수: 이중 중괄호 ('' 변수 '')를 사용하여 템플릿에 삽입돼요.</li>\n<li>블록: '% ... %' 태그로 정의돼요 (예: 반복, 조건문을 위한) 제어 흐름.</li>\n<li>주석: 코드 가독성을 위해 '# ... #'로 묶여 있어요.</li>\n</ul>\n<p>Jinja2은 웹 개발에서 많이 사용되지만, 동적 콘텐츠를 생성하는 데 유용하기 때문에 Airflow와 같은 다른 경우에도 사용됩니다.</p>\n<p>이 프로젝트에서는 특정 인격과 사용자 프롬프트로 대체되는 변수를 포함하는 일반 템플릿을 정의하는 데 사용할 것입니다. 이렇게 하면 Python 코드가 깔끔하게 유지되고 쉽게 확장할 수 있는 모듈식 솔루션을 갖게 됩니다. 스포일러: 나중에 매우 재미있는 인격을 소개할 예정입니다.</p>\n<p>Jinja2를 사용하기 전에 프로젝트 의존성에 추가해야 합니다. Poetry를 사용하고 있으므로 다음을 통해 수행할 수 있습니다:</p>\n<pre><code class=\"hljs language-js\">poetry add jinja2\n</code></pre>\n<p>우리는 템플릿을 저장할 폴더도 필요합니다. 좋은 기본 사례는 모듈 폴더에 templates라는 폴더를 추가하는 것입니다. 그러니 이 경우에는:</p>\n<pre><code class=\"hljs language-js\">mkdir my_gemini_chatbot/templates\n</code></pre>\n<p>Jinja2를 사용하려면 환경을 설정해야 합니다. 위에서 설명한 대로, 환경은 일반 템플릿 구성을 관리합니다. 우리는 간단하게 유지하고 Jinja2가 우리의 폴더에서 템플릿을 찾도록 만들겠습니다:</p>\n<p>env = Environment(\nloader=PackageLoader(\"my_gemini_chatbot\"),\nautoescape=select_autoescape()\n)</p>\n<p>이제 템플릿을 준비할 시간입니다. templates/ 폴더 내에 prompt.jinja, default.jinja 및 santaclaus.jinja 세 개의 파일을 생성하십시오. default.jinja 파일은 비워두세요. 기본 펄스널리티는 Gemini의 정상 동작일 것이므로요.</p>\n<p><img src=\"/assets/img/2024-05-20-CreateyourownGeminiAI-chatbotwithatwistusingPythonJinja2andNiceGUI_8.png\" alt=\"image\"></p>\n<p>다음 내용을 prompt.jinja 템플릿에 추가해 봅시다. 이것은 기본 템플릿입니다:```</p>\n<pre><code class=\"hljs language-md\">{ 성격 }\n\n{ 프롬프트 }\n</code></pre>\n<p>이제, santaclaus.jinja에 다음 내용을 추가하여 산타클로스 성격을 정의해 봅시다:</p>\n<pre><code class=\"hljs language-js\">당신은 산타클로스이며 크리스마스를 사랑합니다. 당신의 답변에는 크리스마스와 관련된 사실과 퀴즈를 최대한 추가해 보세요. 또한 답변을 항상 엄격하게 <span class=\"hljs-string\">\"Ho ho ho\"</span>로 시작하고 <span class=\"hljs-string\">\"메리 크리스마스\"</span>로 끝내세요. 당신은 진정한 크리스마스 애호가입니다.\n</code></pre>\n<p>빠른 알림: 웹 UI에는 성격을 선택하는 select 요소가 있습니다.</p>\n<pre><code class=\"hljs language-js\">ui.<span class=\"hljs-title function_\">select</span>(\n    options=[<span class=\"hljs-string\">\"Default\"</span>, <span class=\"hljs-string\">\"Santa Claus\"</span>],\n    value=<span class=\"hljs-string\">\"Default\"</span>,\n    label=<span class=\"hljs-string\">\"성격\"</span>\n).<span class=\"hljs-title function_\">bind_value</span>(app.<span class=\"hljs-property\">storage</span>.<span class=\"hljs-property\">client</span>, <span class=\"hljs-string\">\"personality\"</span>).<span class=\"hljs-title function_\">classes</span>(<span class=\"hljs-string\">\"col-span-6\"</span>)\n</code></pre>\n<p>작은 도우미 함수를 사용하겠습니다. 이 함수는 선택한 값을 템플릿 파일로 매핑합니다:</p>\n<pre><code class=\"hljs language-js\">def <span class=\"hljs-title function_\">get_personality_file</span>(value):\n    match <span class=\"hljs-attr\">value</span>:\n        <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">\"Default\"</span>:\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"default.jinja\"</span>\n        <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">\"Santa Claus\"</span>:\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"santaclaus.jinja\"</span>\n        <span class=\"hljs-keyword\">case</span> <span class=\"hljs-attr\">_</span>:\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"default.jinja\"</span>\n</code></pre>\n<p>이제 이 도우미 함수와 Jinja2 환경의 get_template 기능을 사용하여 템플릿을 사용한 프롬프트를 만들 수 있습니다:</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">from</span> jinja2 <span class=\"hljs-keyword\">import</span> Environment, PackageLoader, select_autoescape\n<span class=\"hljs-keyword\">from</span> nicegui <span class=\"hljs-keyword\">import</span> ui, app\n\n\nenv = Environment(\n    loader=PackageLoader(<span class=\"hljs-string\">\"my_gemini_chatbot\"</span>),\n    autoescape=select_autoescape()\n)\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">get_personality_file</span>(<span class=\"hljs-params\">value</span>):\n    <span class=\"hljs-keyword\">match</span> value:\n        <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">\"Default\"</span>:\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"default.jinja\"</span>\n        <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">\"Santa Claus\"</span>:\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"santaclaus.jinja\"</span>\n        <span class=\"hljs-keyword\">case</span> _:\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"default.jinja\"</span>\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">send</span>():\n    user_prompt = app.storage.client.get(<span class=\"hljs-string\">\"prompt\"</span>)\n    personality = app.storage.client.get(<span class=\"hljs-string\">\"personality\"</span>)\n\n    personality_template = env.get_template(get_personality_file(personality))\n    prompt_template = env.get_template(<span class=\"hljs-string\">\"prompt.jinja\"</span>)\n\n    prompt = prompt_template.render(\n        prompt=user_prompt,\n        personality=personality_template.render()\n    )\n\n    ui.notify(\n        <span class=\"hljs-string\">f\"Prompt: <span class=\"hljs-subst\">{prompt}</span>\"</span>,\n        <span class=\"hljs-built_in\">type</span>=<span class=\"hljs-string\">\"info\"</span>\n    )\n\n\n<span class=\"hljs-meta\">@ui.page(<span class=\"hljs-params\"><span class=\"hljs-string\">'/'</span></span>)</span>\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">index</span>():\n    <span class=\"hljs-keyword\">with</span> ui.grid(columns=<span class=\"hljs-number\">16</span>).classes(<span class=\"hljs-string\">\"w-3/4 place-self-center gap-4\"</span>):\n        ui.markdown(<span class=\"hljs-string\">\"# 🚀 My Gemini Chatbot\"</span>).classes(<span class=\"hljs-string\">\"col-span-full\"</span>)\n        ui.<span class=\"hljs-built_in\">input</span>(label=<span class=\"hljs-string\">\"Prompt\"</span>).bind_value(app.storage.client, <span class=\"hljs-string\">\"prompt\"</span>).classes(<span class=\"hljs-string\">\"col-span-10\"</span>)\n        ui.select(\n            options=[<span class=\"hljs-string\">\"Default\"</span>, <span class=\"hljs-string\">\"Santa Claus\"</span>],\n            value=<span class=\"hljs-string\">\"Default\"</span>,\n            label=<span class=\"hljs-string\">\"Personality\"</span>\n        ).bind_value(app.storage.client, <span class=\"hljs-string\">\"personality\"</span>).classes(<span class=\"hljs-string\">\"col-span-6\"</span>)\n        ui.button(<span class=\"hljs-string\">\"Send to Gemini\"</span>, on_click=send).classes(<span class=\"hljs-string\">\"col-span-full\"</span>)\n\n        <span class=\"hljs-keyword\">with</span> ui.card().classes(<span class=\"hljs-string\">\"col-span-full\"</span>):\n            ui.markdown(<span class=\"hljs-string\">\"## Gemini Response\"</span>)\n            ui.separator()\n            ui.label(<span class=\"hljs-string\">\"Send your prompt to Gemini and see the response here.\"</span>)\n\n\nui.run()\n</code></pre>\n<p>지금 \"Send to Gemini\"을 클릭하면 Jinja2 템플릿을 기반으로 만든 모듈화된 프롬프트를 볼 수 있습니다.</p>\n<h1>VertexAI를 통해 Gemini LLM 통합하기</h1>\n<p>젬니아이(GeminiAI)를 사용하기 위해서는 VertexAI를 통해 Gemini에 연결하려면, VertexAI가 활성화된 Google Cloud 프로젝트와 충분한 액세스 권한을 가진 서비스 계정 및 해당 계정의 JSON 키 파일이 필요합니다.</p>\n<p><img src=\"/assets/img/2024-05-20-CreateyourownGeminiAI-chatbotwithatwistusingPythonJinja2andNiceGUI_10.png\" alt=\"\"></p>\n<p>새 프로젝트를 생성한 후, APIs 및 서비스 - <code>API 및 서비스 활성화 -</code> VertexAI API 검색 - ` 활성화로 이동합니다.</p>\n<p><img src=\"/assets/img/2024-05-20-CreateyourownGeminiAI-chatbotwithatwistusingPythonJinja2andNiceGUI_11.png\" alt=\"\"></p>\n<p>서비스 계정을 생성하려면 IAM 및 관리 - 서비스 계정 - 서비스 계정 만들기로 이동하십시오. 적절한 이름을 선택하고 다음 단계로 이동하십시오.</p>\n<p><img src=\"/assets/img/2024-05-20-CreateyourownGeminiAI-chatbotwithatwistusingPythonJinja2andNiceGUI_12.png\" alt=\"이미지\"></p>\n<p>이제 계정에 미리 정의된 역할 Vertex AI 사용자를 할당하는지 확인하십시오.</p>\n<p><img src=\"/assets/img/2024-05-20-CreateyourownGeminiAI-chatbotwithatwistusingPythonJinja2andNiceGUI_13.png\" alt=\"이미지\"></p>\n<p>마침내 새로운 사용자 → 키 → 키 추가 → 새 키 생성 → JSON을 클릭하여 JSON 키 파일을 생성하고 다운로드할 수 있습니다. 이 파일이 있으면 사용할 준비가 된 것입니다.</p>\n<p><img src=\"/assets/img/2024-05-20-CreateyourownGeminiAI-chatbotwithatwistusingPythonJinja2andNiceGUI_14.png\" alt=\"이미지\"></p>\n<p>JSON 자격 증명 키 파일을 준비하고 프로젝트 내에 저장한 후에는 VertexAI를 초기화할 수 있습니다.</p>\n<pre><code class=\"hljs language-js\">credentials = service_account.<span class=\"hljs-property\">Credentials</span>.<span class=\"hljs-title function_\">from_service_account_file</span>(\n    <span class=\"hljs-string\">\"gcp-vojay-gemini.json\"</span>\n)\nvertexai.<span class=\"hljs-title function_\">init</span>(project=<span class=\"hljs-string\">\"vojay-329716\"</span>, location=<span class=\"hljs-string\">\"us-central1\"</span>, credentials=credentials)\n</code></pre>\n<p>이제 VertexAI를 통해 모델을 로드할 수 있어요. 저희는 Gemini Pro 모델을 사용할 거예요.</p>\n<pre><code class=\"hljs language-js\">model = <span class=\"hljs-title class_\">GenerativeModel</span>(<span class=\"hljs-string\">\"gemini-pro\"</span>)\n</code></pre>\n<p>이 모델은 대화를 시작하는 start_chat 함수를 제공해요. 이 함수는 Gemini에 데이터를 보내는 send_message 함수를 가진 Chat 객체를 반환해요. 여기서 generation config 매개변수를 조정할 수도 있어요. 여기서는 기본값을 사용할 거예요. Gemini로부터의 응답을 스트리밍하기 때문에, 전체 채팅 응답을 받기 위해 도우미 함수를 사용할 거에요:</p>\n<pre><code class=\"hljs language-js\">def <span class=\"hljs-title function_\">get_chat_response</span>(chat, prompt):\n    text_response = []\n    responses = chat.<span class=\"hljs-title function_\">send_message</span>(prompt, stream=<span class=\"hljs-title class_\">True</span>)\n    <span class=\"hljs-keyword\">for</span> chunk <span class=\"hljs-keyword\">in</span> <span class=\"hljs-attr\">responses</span>:\n        text_response.<span class=\"hljs-title function_\">append</span>(chunk.<span class=\"hljs-property\">text</span>)\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">''</span>.<span class=\"hljs-title function_\">join</span>(text_response)\n</code></pre>\n<p>그럼 이 정도면 괜찮네요. 우리는 준비된 프롬프트와 VertexAI가 초기화된 상태이며, 채팅 응답을 가져오는 도우미 함수를 사용하여 마침내 Gemini를 통합할 수 있게 되었어요.</p>\n<p>클라이언트 스토리지에서 변수에 바인딩된 레이블을 추가할 것이고, 이 레이블은 Gemini 응답을 저장하고 렌더링하는 데 사용될 거에요:</p>\n<pre><code class=\"hljs language-js\">ui.<span class=\"hljs-title function_\">label</span>().<span class=\"hljs-title function_\">bind_text</span>(app.<span class=\"hljs-property\">storage</span>.<span class=\"hljs-property\">client</span>, <span class=\"hljs-string\">\"response\"</span>)\n</code></pre>\n<p>이제 첫 번째 버전이 준비되었습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> vertexai\n<span class=\"hljs-keyword\">from</span> google.<span class=\"hljs-property\">oauth2</span> <span class=\"hljs-keyword\">import</span> service_account\n<span class=\"hljs-keyword\">from</span> jinja2 <span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Environment</span>, <span class=\"hljs-title class_\">PackageLoader</span>, select_autoescape\n<span class=\"hljs-keyword\">from</span> nicegui <span class=\"hljs-keyword\">import</span> ui, app\n<span class=\"hljs-keyword\">from</span> vertexai.<span class=\"hljs-property\">generative_models</span> <span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">GenerativeModel</span>\n\ncredentials = service_account.<span class=\"hljs-property\">Credentials</span>.<span class=\"hljs-title function_\">from_service_account_file</span>(\n    <span class=\"hljs-string\">\"../gcp-vojay-gemini.json\"</span>\n)\nvertexai.<span class=\"hljs-title function_\">init</span>(project=<span class=\"hljs-string\">\"vojay-329716\"</span>, location=<span class=\"hljs-string\">\"us-central1\"</span>, credentials=credentials)\n\nenv = <span class=\"hljs-title class_\">Environment</span>(\n    loader=<span class=\"hljs-title class_\">PackageLoader</span>(<span class=\"hljs-string\">\"my_gemini_chatbot\"</span>),\n    autoescape=<span class=\"hljs-title function_\">select_autoescape</span>()\n)\n\nmodel = <span class=\"hljs-title class_\">GenerativeModel</span>(<span class=\"hljs-string\">\"gemini-pro\"</span>)\n\n\ndef <span class=\"hljs-title function_\">get_chat_response</span>(chat, prompt):\n    text_response = []\n    responses = chat.<span class=\"hljs-title function_\">send_message</span>(prompt, stream=<span class=\"hljs-title class_\">True</span>)\n    <span class=\"hljs-keyword\">for</span> chunk <span class=\"hljs-keyword\">in</span> <span class=\"hljs-attr\">responses</span>:\n        text_response.<span class=\"hljs-title function_\">append</span>(chunk.<span class=\"hljs-property\">text</span>)\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">''</span>.<span class=\"hljs-title function_\">join</span>(text_response)\n\n\ndef <span class=\"hljs-title function_\">get_personality_file</span>(value):\n    match <span class=\"hljs-attr\">value</span>:\n        <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">\"Default\"</span>:\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"default.jinja\"</span>\n        <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">\"Santa Claus\"</span>:\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"santaclaus.jinja\"</span>\n        <span class=\"hljs-keyword\">case</span> <span class=\"hljs-attr\">_</span>:\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"default.jinja\"</span>\n\n\ndef <span class=\"hljs-title function_\">send</span>():\n    user_prompt = app.<span class=\"hljs-property\">storage</span>.<span class=\"hljs-property\">client</span>.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">\"prompt\"</span>)\n    personality = app.<span class=\"hljs-property\">storage</span>.<span class=\"hljs-property\">client</span>.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">\"personality\"</span>)\n\n    personality_template = env.<span class=\"hljs-title function_\">get_template</span>(<span class=\"hljs-title function_\">get_personality_file</span>(personality))\n    prompt_template = env.<span class=\"hljs-title function_\">get_template</span>(<span class=\"hljs-string\">\"prompt.jinja\"</span>)\n\n    prompt = prompt_template.<span class=\"hljs-title function_\">render</span>(\n        prompt=user_prompt,\n        personality=personality_template.<span class=\"hljs-title function_\">render</span>()\n    )\n\n    ui.<span class=\"hljs-title function_\">notify</span>(<span class=\"hljs-string\">\"Sending to Gemini...\"</span>, type=<span class=\"hljs-string\">\"info\"</span>)\n    chat = model.<span class=\"hljs-title function_\">start_chat</span>()\n    response = <span class=\"hljs-title function_\">get_chat_response</span>(chat, prompt)\n    ui.<span class=\"hljs-title function_\">notify</span>(<span class=\"hljs-string\">\"Received response...\"</span>, type=<span class=\"hljs-string\">\"info\"</span>)\n\n    app.<span class=\"hljs-property\">storage</span>.<span class=\"hljs-property\">client</span>[<span class=\"hljs-string\">\"response\"</span>] = response\n\n\n@ui.<span class=\"hljs-title function_\">page</span>(<span class=\"hljs-string\">'/'</span>)\ndef <span class=\"hljs-title function_\">index</span>():\n    <span class=\"hljs-keyword\">with</span> ui.<span class=\"hljs-title function_\">grid</span>(columns=<span class=\"hljs-number\">16</span>).<span class=\"hljs-title function_\">classes</span>(<span class=\"hljs-string\">\"w-3/4 place-self-center gap-4\"</span>):\n        ui.<span class=\"hljs-title function_\">markdown</span>(<span class=\"hljs-string\">\"# 🚀 My Gemini Chatbot\"</span>).<span class=\"hljs-title function_\">classes</span>(<span class=\"hljs-string\">\"col-span-full\"</span>)\n        ui.<span class=\"hljs-title function_\">input</span>(label=<span class=\"hljs-string\">\"Prompt\"</span>).<span class=\"hljs-title function_\">bind_value</span>(app.<span class=\"hljs-property\">storage</span>.<span class=\"hljs-property\">client</span>, <span class=\"hljs-string\">\"prompt\"</span>).<span class=\"hljs-title function_\">classes</span>(<span class=\"hljs-string\">\"col-span-10\"</span>)\n        ui.<span class=\"hljs-title function_\">select</span>(\n            options=[<span class=\"hljs-string\">\"Default\"</span>, <span class=\"hljs-string\">\"Santa Claus\"</span>],\n            value=<span class=\"hljs-string\">\"Default\"</span>,\n            label=<span class=\"hljs-string\">\"Personality\"</span>\n        ).<span class=\"hljs-title function_\">bind_value</span>(app.<span class=\"hljs-property\">storage</span>.<span class=\"hljs-property\">client</span>, <span class=\"hljs-string\">\"personality\"</span>).<span class=\"hljs-title function_\">classes</span>(<span class=\"hljs-string\">\"col-span-6\"</span>)\n        ui.<span class=\"hljs-title function_\">button</span>(<span class=\"hljs-string\">\"Send to Gemini\"</span>, on_click=send).<span class=\"hljs-title function_\">classes</span>(<span class=\"hljs-string\">\"col-span-full\"</span>)\n\n        <span class=\"hljs-keyword\">with</span> ui.<span class=\"hljs-title function_\">card</span>().<span class=\"hljs-title function_\">classes</span>(<span class=\"hljs-string\">\"col-span-full\"</span>):\n            ui.<span class=\"hljs-title function_\">markdown</span>(<span class=\"hljs-string\">\"## Gemini Response\"</span>)\n            ui.<span class=\"hljs-title function_\">separator</span>()\n            ui.<span class=\"hljs-title function_\">label</span>().<span class=\"hljs-title function_\">bind_text</span>(app.<span class=\"hljs-property\">storage</span>.<span class=\"hljs-property\">client</span>, <span class=\"hljs-string\">\"response\"</span>)\n\n\nui.<span class=\"hljs-title function_\">run</span>()\n</code></pre>\n<p><img src=\"/assets/img/2024-05-20-CreateyourownGeminiAI-chatbotwithatwistusingPythonJinja2andNiceGUI_16.png\" alt=\"GeminiAI Chatbot\"></p>\n<h1>AI가 바에 들어가다</h1>\n<p>저는 아빠가 된 이후로, 가능한 경우에 아빠 농담을 해주는 기회를 즐기고 있어요. 이 장에서는 Jinja2를 사용한 모듈식 접근 방법과 NiceGUI를 사용한 간단한 웹 UI의 이점을 설명하고 싶어 합니다.</p>\n<p>새로운 개성을 소개해보죠. dadjokes.jinja와 같이 다른 파일 옆에 새로운 템플릿 파일을 만들어 다음 내용을 추가하세요.</p>\n<p>넌 자랍니다. 하지만, 거의 모든 문장에 아빠 농담을 추가해야 합니다. 답변에 가능한 한 많은 아빠 농담을 넣고, 입력과 관련된 농담을 만드려고 노력해주세요. 또한, 답변에 많은 이모지를 추가하고 싶어 금을 참지 못할 겁니다. 😉👨‍👧‍👦</p>\n<p>이를 실행하기 위해 우리는 우리의 도우미 함수인 get_personality_file을 확장해야 합니다. 👨‍💻</p>\n<pre><code class=\"hljs language-js\">def <span class=\"hljs-title function_\">get_personality_file</span>(value):\n    match <span class=\"hljs-attr\">value</span>:\n        <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">\"Default\"</span>:\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"default.jinja\"</span>\n        <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">\"Santa Claus\"</span>:\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"santaclaus.jinja\"</span>\n        <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">\"Dad Jokes\"</span>:\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"dadjokes.jinja\"</span>\n        <span class=\"hljs-keyword\">case</span> <span class=\"hljs-attr\">_</span>:\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"default.jinja\"</span> 😄\n</code></pre>\n<p>그리고 우리의 입력 요소에 새 옵션을 추가하여 사용자가 새로운 옵션을 선택할 수 있도록 합시다. 🎁🧔</p>\n<pre><code class=\"hljs language-js\">ui.<span class=\"hljs-title function_\">select</span>(\n    options=[<span class=\"hljs-string\">\"기본\"</span>, <span class=\"hljs-string\">\"산타 클로스\"</span>, <span class=\"hljs-string\">\"아빠 Jokes\"</span>],\n    value=<span class=\"hljs-string\">\"기본\"</span>,\n    label=<span class=\"hljs-string\">\"성격\"</span>\n).<span class=\"hljs-title function_\">bind_value</span>(app.<span class=\"hljs-property\">storage</span>.<span class=\"hljs-property\">client</span>, <span class=\"hljs-string\">\"personality\"</span>).<span class=\"hljs-title function_\">classes</span>(<span class=\"hljs-string\">\"col-span-6\"</span>)\n</code></pre>\n<p>이제 해보기 전에 한 가지 더 구현해 봅시다. 다크 모드를 도입해 보겠습니다! NiceGUI를 사용하면 이 작업이 매우 간단합니다. ui.dark_mode()를 통해 UI 모드를 전환하기 위한 disable 및 enable 두 가지 함수를 제공하는 dark 객체를 얻을 수 있습니다. 그리드 접근 방식과 함께 사용하여 \"젬니니로 전송\" 버튼 옆에 UI 모드를 전환하는 두 개의 버튼을 쉽게 배치할 수 있습니다. 다음과 같이 코드 작성하세요:</p>\n<pre><code class=\"hljs language-js\">ui.<span class=\"hljs-title function_\">button</span>(<span class=\"hljs-string\">\"젬니니로 전송\"</span>, on_click=send).<span class=\"hljs-title function_\">classes</span>(<span class=\"hljs-string\">\"col-span-8\"</span>)\n\ndark = ui.<span class=\"hljs-title function_\">dark_mode</span>()\nui.<span class=\"hljs-title function_\">button</span>(<span class=\"hljs-string\">\"라이트 UI\"</span>, on_click=dark.<span class=\"hljs-property\">disable</span>).<span class=\"hljs-title function_\">classes</span>(<span class=\"hljs-string\">\"col-span-4\"</span>)\nui.<span class=\"hljs-title function_\">button</span>(<span class=\"hljs-string\">\"다크 UI\"</span>, on_click=dark.<span class=\"hljs-property\">enable</span>).<span class=\"hljs-title function_\">classes</span>(<span class=\"hljs-string\">\"col-span-4\"</span>)\n</code></pre>\n<p>\"젬니니로 전송\" 버튼이 col-span-full 클래스 대신 col-span-8 클래스를 사용하고 있음을 알 수 있습니다. 또한 16개 열의 그리드를 사용하므로 바로 옆에 각각 col-span-4를 사용하여 두 개의 새로운 버튼을 추가할 수 있습니다.</p>\n<p>표를 Markdown 형식으로 바꾸는 방법은 다음과 같아요:</p>\n<table>\n<thead>\n<tr>\n<th>Function</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ui.run()</td>\n<td>애플리케이션 실행</td>\n</tr>\n<tr>\n<td>ui.page()</td>\n<td>페이지 만들기</td>\n</tr>\n<tr>\n<td>ui.button()</td>\n<td>버튼 생성</td>\n</tr>\n</tbody>\n</table>\n<p>위와 같이 수정하시면 Markdown 형식으로 표를 작성할 수 있어요!</p>\n<p>아빠로서 이걸 승인합니다 😂.</p>\n<p><img src=\"https://miro.medium.com/v2/resize:fit:1400/1*9xgCK0hrAI4XznUwk44o-w.gif\" alt=\"image\"></p>\n<h1>결론</h1>\n<p>농담은 농담이고, 이 글을 통해 Gemini LLM을 기반으로 자체 AI 챗봇을 만들고 VertexAI와 함께 파이썬을 사용하여 NiceGUI로 간단한 웹 UI를 만드는 방법을 배웠습니다. Jinja2 템플릿을 사용하여, 이 비교적 짧은 예제조차도 확장하기 쉬운 모듈식 AI 애플리케이션을 제공했습니다.</p>\n<p><img src=\"/assets/img/2024-05-20-CreateyourownGeminiAI-chatbotwithatwistusingPythonJinja2andNiceGUI_18.png\" alt=\"GeminiAI Chatbot\"></p>\n<p>파이썬, Jinja2 및 NiceGUI를 사용하면 VertexAI의 Gemini LLM과 상호 작용하는 사용자 친화적 인터페이스를 구축할 수 있습니다. 이를 통해 교육용 챗봇부터 재미있는 개성 기반 챗 체험까지 다양한 창의적인 응용 프로그램이 가능해집니다.</p>\n<p>이 블로그 글이 여러분들에게 VertexAI의 잠재력을 탐험하고 자체 AI 애플리케이션을 구축해보는데 영감을 줬기를 희망합니다.</p>\n<p>즐기고, 지시를 따르는 데 서툰 AI를 무엇이라고 부를까요? — 절망적 절자 없는 반란자.</p>\n</body>\n</html>\n"},"__N_SSG":true}