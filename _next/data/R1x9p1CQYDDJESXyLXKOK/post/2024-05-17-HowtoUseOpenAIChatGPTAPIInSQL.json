{"pageProps":{"post":{"title":"오픈AI ChatGPT API를 SQL에서 사용하는 방법","description":"","date":"2024-05-17 19:12","slug":"2024-05-17-HowtoUseOpenAIChatGPTAPIInSQL","content":"\n\n<img src=\"/assets/img/2024-05-17-HowtoUseOpenAIChatGPTAPIInSQL_0.png\" />\n\n챗GPT 및 OpenAI API를 사용할 때 SQL이 먼저 떠오르지는 않겠지만, 데이터의 언어이기 때문에 SQL을 활용할 수 있다는 사실을 명심해야 합니다. SQL에서 HTTP 요청을 보낼 수 있다는 점은 다양한 가능성을 열어 줍니다.\n\n오늘의 글에서는 PL/SQL을 사용하여 사용자 지정 Oracle SQL 함수를 작성하는 방법을 보여 드리겠습니다. 질문 문자열을 입력으로 받아서 형식화된 JSON을 반환합니다. Oracle의 dbms_cloud 패키지가 API 호출을 수행하는 데 주로 사용되며, 다른 데이터베이스 공급업체를 사용하는 경우 해당 작업을 수행할 수 있는 대체 패키지 및 함수 세트를 찾을 수 있을 것입니다.\n\n따라서, 먼저 함께 따라 해야 할 전제 조건에 대해 설명하겠습니다.\n\n<div class=\"content-ad\"></div>\n\n# ChatGPT in SQL — 필수 사항\n\n소개에서 언급했듯이, 저는 오라클 클라우드에서 프로비저닝된 항상 무료 인스턴스에서 실행되는 Oracle SQL을 사용하고 있습니다. 만약 따라하기를 원한다면 무료 계정을 등록하고 데이터베이스 인스턴스를 프로비저닝하고 연결 지갑을 다운로드해야 합니다.\n\n또한 필요한 것은 OpenAI API 키입니다. 링크된 기사를 통해 몇 분 안에 얻는 방법을 알 수 있습니다.\n\n그게 거의 다에요! 이제 본격적으로 시작해 봅시다.\n\n<div class=\"content-ad\"></div>\n\n# OpenAI API — 대화 완성 엔드포인트 테스트\n\nSQL에서 구현할 대화 완성 예제는 매우 간단합니다. OpenAI의 공식 문서에서는 API에 요청하는 방법을 보여줍니다:\n\n![image](/assets/img/2024-05-17-HowtoUseOpenAIChatGPTAPIInSQL_1.png)\n\nSQL에서는 Python과 같이 OpenAI를 위한 서드파티 라이브러리가 없기 때문에 좀 더 수동적인 방법을 선택해야 합니다. 이론적으로는 — 위의 curl 명령을 실행하고 응답을 받는다면 SQL에서도 동일한 작업을 수행할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이것을 시연하는 가장 쉬운 방법은 Postman을 통해 하는 것입니다. https://api.openai.com/v1/chat/completions에 새로운 POST 요청의 헤더와 JSON 본문을 채우고, 나와 비슷한 응답을 받을 수 있습니다:\n\n![이미지](/assets/img/2024-05-17-HowtoUseOpenAIChatGPTAPIInSQL_2.png)\n\n가장 인상적인 GPT 응답은 아닙니다만, 동작은 합니다. 이제 SQL로 가져와 봅시다.\n\n# SQL에서 ChatGPT 사용하기 — 사용자 지정 PL/SQL 함수에서 OpenAI API 사용 방법\n\n<div class=\"content-ad\"></div>\n\nPL/SQL을 사용하면 사용자 정의 함수를 정의할 수 있습니다. get_gpt_response() 함수는 문자열 질문을 받아 CLOB를 반환합니다. CLOB는 기본 VARCHAR2 타입으로는 너무 큰 문자열을 저장하는 데 사용되는 특별한 데이터 유형입니다.\n\n이 함수 내에서 v_api_key 상수는 OpenAI API 키의 값을 보유하고 있습니다. 따라서 꼭 바꾸지 않도록 주의하세요.\n\n이 함수는 Oracle의 dbms_cloud 패키지를 사용하여 OpenAI의 채팅 완료 엔드포인트로 HTTP 요청을 보냅니다. send_request() 프로시저는 다음 매개변수가 필요합니다:\n\n- uri — 엔드포인트의 URL입니다.\n- method — 요청에 사용되는 HTTP 메서드입니다. 여러분은 POST로 설정해야 합니다.\n- headers — 요청 헤더를 지정하는 JSON 객체입니다. 이전에 본 바와 같이 Content-Type 및 Authorization을 명시해야 합니다.\n- body — BLOB로 변환된 JSON 객체입니다. 보내는 데이터를 포함하며, 사용할 모델, 온도 매개변수(랜덤성) 및 GPT가 답변할 질문과 같은 정보가 포함됩니다.\n\n<div class=\"content-ad\"></div>\n\nsend_request() 함수의 결과는 v_response 변수에 저장되며, 그것은 사용자에게 텍스트로 반환됩니다:\n\n```js\ncreate or replace function get_gpt_response(\n    p_question varchar2\n) return clob\nis\n    v_api_key constant varchar2(100) := '<your-api-key>';\n    v_response dbms_cloud_types.resp;\nbegin\n    v_response := dbms_cloud.send_request(\n        uri     => 'https://api.openai.com/v1/chat/completions',\n        method  => dbms_cloud.method_post,\n        -- Headers must be of type JSON_OBJECT\n        headers => json_object(\n            'Content-Type'  value 'application/json',\n            'Authorization' value 'Bearer ' || v_api_key\n        ),\n        -- Request body must be a JSON structure converted to BLOB\n        body    => utl_raw.cast_to_raw(\n            json_object(\n                'model'    value 'gpt-3.5-turbo',\n                'messages' value json_array(\n                    json_object(\n                        'role'    value 'user',\n                        'content' value p_question\n                    )\n                ),\n                'temperature' value 0.5\n            )\n        )\n    );\n    return dbms_cloud.get_response_text(v_response);\nend get_gpt_response;\n/\n```\n\n위 스니펫을 실행하면 해당 함수를 사용할 수 있게 됩니다.\n\n예상대로 작동하는지 확인해 봅시다:\n\n<div class=\"content-ad\"></div>\n\n```js\nselect \n    json_query(get_gpt_response('What is the capital of United States?'), '$' returning clob pretty) as response \nfrom dual;\n```\n\n여기에 얻은 응답이 있어요:\n\n<img src=\"/assets/img/2024-05-17-HowtoUseOpenAIChatGPTAPIInSQL_3.png\" />\n\n매우 좋은 결과 나왔네요! 하지만 하나 문제가 있는데요 — 반환된 응답이 JSON 형식으로 표시되는데, 이는 관계형 데이터베이스를 다룰 때 기본적으로 원하는 형식은 아니죠.\n\n<div class=\"content-ad\"></div>\n\n다행히도, Oracle은 탁월한 JSON 지원을 제공하기 때문에 관련 필드를 추출하고 응답을 일반 데이터베이스 테이블 형식으로 포맷할 수 있습니다:\n\n```js\nwith response as (\n    select get_gpt_response('What is the capital of United States?') as data\n    from dual\n)\nselect\n    jt.*\nfrom response r,\n    json_table(\n        r.data,\n        '$'\n        columns(\n            id                varchar2(50)   path '$.id',\n            answer            varchar2(1000) path '$.choices[0].message.content',\n            prompt_tokens     number         path '$.usage.prompt_tokens',\n            completion_tokens number         path '$.usage.completion_tokens',\n            total_tokens      number         path '$.usage.total_tokens'\n        )\n    ) jt;\n```\n\n아래는 출력 결과입니다:\n\n![출력 이미지](/assets/img/2024-05-17-HowtoUseOpenAIChatGPTAPIInSQL_4.png)\n\n<div class=\"content-ad\"></div>\n\n여기서부터는 세상이 당신의 조개껍질처럼 열립니다. 결과를 그대로 사용하거나 표로 저장할 수도 있습니다. 토큰 사용 정보는 자주 이 함수를 실행할 계획이 있다면 사용된 리소스를 잘 보여주는 지표가 될 것입니다.\n\n# 개선할 수 있는 점 (하고야 할 것)\n\n오늘 구현한 솔루션은 작동하지만 상당히 기본적이며 몇 가지 조정이 필요합니다:\n\n- 예외 처리 — 현재 전혀 구현되지 않았습니다. dbms_cloud 오류뿐만 아니라 일반적인 다른 오류도 잡을 수 있도록 해야 합니다.\n- 하드코딩된 엔드포인트 — 현재 상태에서 함수는 채팅 완성 엔드포인트로만 요청을 보냅니다. 엔드포인트를 동적으로 만드는 것이 더 좋을 것입니다.\n- 응답이 저장되지 않음 — 사용자에게 반환하기 전에 응답을 데이터베이스 테이블에 저장하는 것이 좋을 것입니다.\n\n<div class=\"content-ad\"></div>\n\n위의 모든 부분은 기본적인 SQL 기술이 있다면 쉽게 해결할 수 있기 때문에 여러분에게 맡기겠습니다.\n\n# SQL에서 OpenAI API 요약\n\n많은 사람들이 SQL이 OpenAI API에 HTTP 호출을 위한 유효한 옵션으로 여겨지지 않는다고 생각하지만, 실제로 많은 신입사원들은 SQL이 기본적인 데이터 조작 이상의 기능을 수행할 수 있다는 것을 알지 못합니다. SQL은 데이터의 언어이며, 이에 따라 Python이 할 수 있는 거의 모든 작업을 데이터 이동 없이 수행할 수 있습니다.\n\n오늘의 예시는 Oracle SQL과 PL/SQL로 한정되어 있지만, 여러분이 나의 해결책을 SQL Server, MySQL 및 Postgres에 구현할 방법을 찾을 수 있을 것입니다.\n\n<div class=\"content-ad\"></div>\n\nSQL 사용 사례 중에서 머신 러닝과 공간 데이터 분석과 같은 더 흥미로운 내용이 추가로 올라올 예정이니 기대해 주세요.\n\n읽어 주셔서 감사합니다.","ogImage":{"url":"/assets/img/2024-05-17-HowtoUseOpenAIChatGPTAPIInSQL_0.png"},"coverImage":"/assets/img/2024-05-17-HowtoUseOpenAIChatGPTAPIInSQL_0.png","tag":["Tech"],"readingTime":6},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    h1: \"h1\",\n    img: \"img\",\n    ul: \"ul\",\n    li: \"li\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(\"img\", {\n      src: \"/assets/img/2024-05-17-HowtoUseOpenAIChatGPTAPIInSQL_0.png\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"챗GPT 및 OpenAI API를 사용할 때 SQL이 먼저 떠오르지는 않겠지만, 데이터의 언어이기 때문에 SQL을 활용할 수 있다는 사실을 명심해야 합니다. SQL에서 HTTP 요청을 보낼 수 있다는 점은 다양한 가능성을 열어 줍니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"오늘의 글에서는 PL/SQL을 사용하여 사용자 지정 Oracle SQL 함수를 작성하는 방법을 보여 드리겠습니다. 질문 문자열을 입력으로 받아서 형식화된 JSON을 반환합니다. Oracle의 dbms_cloud 패키지가 API 호출을 수행하는 데 주로 사용되며, 다른 데이터베이스 공급업체를 사용하는 경우 해당 작업을 수행할 수 있는 대체 패키지 및 함수 세트를 찾을 수 있을 것입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"따라서, 먼저 함께 따라 해야 할 전제 조건에 대해 설명하겠습니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"ChatGPT in SQL — 필수 사항\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"소개에서 언급했듯이, 저는 오라클 클라우드에서 프로비저닝된 항상 무료 인스턴스에서 실행되는 Oracle SQL을 사용하고 있습니다. 만약 따라하기를 원한다면 무료 계정을 등록하고 데이터베이스 인스턴스를 프로비저닝하고 연결 지갑을 다운로드해야 합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"또한 필요한 것은 OpenAI API 키입니다. 링크된 기사를 통해 몇 분 안에 얻는 방법을 알 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그게 거의 다에요! 이제 본격적으로 시작해 봅시다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"OpenAI API — 대화 완성 엔드포인트 테스트\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"SQL에서 구현할 대화 완성 예제는 매우 간단합니다. OpenAI의 공식 문서에서는 API에 요청하는 방법을 보여줍니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-17-HowtoUseOpenAIChatGPTAPIInSQL_1.png\",\n        alt: \"image\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"SQL에서는 Python과 같이 OpenAI를 위한 서드파티 라이브러리가 없기 때문에 좀 더 수동적인 방법을 선택해야 합니다. 이론적으로는 — 위의 curl 명령을 실행하고 응답을 받는다면 SQL에서도 동일한 작업을 수행할 수 있습니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이것을 시연하는 가장 쉬운 방법은 Postman을 통해 하는 것입니다. https://api.openai.com/v1/chat/completions에 새로운 POST 요청의 헤더와 JSON 본문을 채우고, 나와 비슷한 응답을 받을 수 있습니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-17-HowtoUseOpenAIChatGPTAPIInSQL_2.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"가장 인상적인 GPT 응답은 아닙니다만, 동작은 합니다. 이제 SQL로 가져와 봅시다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"SQL에서 ChatGPT 사용하기 — 사용자 지정 PL/SQL 함수에서 OpenAI API 사용 방법\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"PL/SQL을 사용하면 사용자 정의 함수를 정의할 수 있습니다. get_gpt_response() 함수는 문자열 질문을 받아 CLOB를 반환합니다. CLOB는 기본 VARCHAR2 타입으로는 너무 큰 문자열을 저장하는 데 사용되는 특별한 데이터 유형입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 함수 내에서 v_api_key 상수는 OpenAI API 키의 값을 보유하고 있습니다. 따라서 꼭 바꾸지 않도록 주의하세요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 함수는 Oracle의 dbms_cloud 패키지를 사용하여 OpenAI의 채팅 완료 엔드포인트로 HTTP 요청을 보냅니다. send_request() 프로시저는 다음 매개변수가 필요합니다:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"uri — 엔드포인트의 URL입니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"method — 요청에 사용되는 HTTP 메서드입니다. 여러분은 POST로 설정해야 합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"headers — 요청 헤더를 지정하는 JSON 객체입니다. 이전에 본 바와 같이 Content-Type 및 Authorization을 명시해야 합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"body — BLOB로 변환된 JSON 객체입니다. 보내는 데이터를 포함하며, 사용할 모델, 온도 매개변수(랜덤성) 및 GPT가 답변할 질문과 같은 정보가 포함됩니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"send_request() 함수의 결과는 v_response 변수에 저장되며, 그것은 사용자에게 텍스트로 반환됩니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"create or replace \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"function\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"get_gpt_response\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"\\n    p_question varchar2\\n\"\n        }), \") \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" clob\\nis\\n    v_api_key constant \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"varchar2\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"100\"\n        }), \") := \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'<your-api-key>'\"\n        }), \";\\n    v_response dbms_cloud_types.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"resp\"\n        }), \";\\nbegin\\n    v_response := dbms_cloud.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"send_request\"\n        }), \"(\\n        \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"uri\"\n          }), \"     =>\"]\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'https://api.openai.com/v1/chat/completions'\"\n        }), \",\\n        \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"method\"\n          }), \"  =>\"]\n        }), \" dbms_cloud.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"method_post\"\n        }), \",\\n        -- \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Headers\"\n        }), \" must be \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"of\"\n        }), \" type \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"JSON\"\n        }), \"_OBJECT\\n        headers => \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"json_object\"\n        }), \"(\\n            \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Content-Type'\"\n        }), \"  value \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'application/json'\"\n        }), \",\\n            \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Authorization'\"\n        }), \" value \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Bearer '\"\n        }), \" || v_api_key\\n        ),\\n        -- \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Request\"\n        }), \" body must be a \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"JSON\"\n        }), \" structure converted to \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"BLOB\"\n        }), \"\\n        body    => utl_raw.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"cast_to_raw\"\n        }), \"(\\n            \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"json_object\"\n        }), \"(\\n                \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'model'\"\n        }), \"    value \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'gpt-3.5-turbo'\"\n        }), \",\\n                \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'messages'\"\n        }), \" value \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"json_array\"\n        }), \"(\\n                    \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"json_object\"\n        }), \"(\\n                        \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'role'\"\n        }), \"    value \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'user'\"\n        }), \",\\n                        \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'content'\"\n        }), \" value p_question\\n                    )\\n                ),\\n                \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'temperature'\"\n        }), \" value \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.5\"\n        }), \"\\n            )\\n        )\\n    );\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" dbms_cloud.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"get_response_text\"\n        }), \"(v_response);\\nend get_gpt_response;\\n/\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"위 스니펫을 실행하면 해당 함수를 사용할 수 있게 됩니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"예상대로 작동하는지 확인해 봅시다:\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"select \\n    \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"json_query\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"get_gpt_response\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'What is the capital of United States?'\"\n        }), \"), \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'$'\"\n        }), \" returning clob pretty) \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" response \\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" dual;\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"여기에 얻은 응답이 있어요:\"\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/assets/img/2024-05-17-HowtoUseOpenAIChatGPTAPIInSQL_3.png\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"매우 좋은 결과 나왔네요! 하지만 하나 문제가 있는데요 — 반환된 응답이 JSON 형식으로 표시되는데, 이는 관계형 데이터베이스를 다룰 때 기본적으로 원하는 형식은 아니죠.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다행히도, Oracle은 탁월한 JSON 지원을 제공하기 때문에 관련 필드를 추출하고 응답을 일반 데이터베이스 테이블 형식으로 포맷할 수 있습니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"with\"\n        }), \" response \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" (\\n    select \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"get_gpt_response\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'What is the capital of United States?'\"\n        }), \") \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" data\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" dual\\n)\\nselect\\n    jt.*\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" response r,\\n    \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"json_table\"\n        }), \"(\\n        r.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"data\"\n        }), \",\\n        \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'$'\"\n        }), \"\\n        \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"columns\"\n        }), \"(\\n            id                \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"varchar2\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"50\"\n        }), \")   path \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'$.id'\"\n        }), \",\\n            answer            \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"varchar2\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1000\"\n        }), \") path \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'$.choices[0].message.content'\"\n        }), \",\\n            prompt_tokens     number         path \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'$.usage.prompt_tokens'\"\n        }), \",\\n            completion_tokens number         path \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'$.usage.completion_tokens'\"\n        }), \",\\n            total_tokens      number         path \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'$.usage.total_tokens'\"\n        }), \"\\n        )\\n    ) jt;\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"아래는 출력 결과입니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-17-HowtoUseOpenAIChatGPTAPIInSQL_4.png\",\n        alt: \"출력 이미지\"\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"여기서부터는 세상이 당신의 조개껍질처럼 열립니다. 결과를 그대로 사용하거나 표로 저장할 수도 있습니다. 토큰 사용 정보는 자주 이 함수를 실행할 계획이 있다면 사용된 리소스를 잘 보여주는 지표가 될 것입니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"개선할 수 있는 점 (하고야 할 것)\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"오늘 구현한 솔루션은 작동하지만 상당히 기본적이며 몇 가지 조정이 필요합니다:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"예외 처리 — 현재 전혀 구현되지 않았습니다. dbms_cloud 오류뿐만 아니라 일반적인 다른 오류도 잡을 수 있도록 해야 합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"하드코딩된 엔드포인트 — 현재 상태에서 함수는 채팅 완성 엔드포인트로만 요청을 보냅니다. 엔드포인트를 동적으로 만드는 것이 더 좋을 것입니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"응답이 저장되지 않음 — 사용자에게 반환하기 전에 응답을 데이터베이스 테이블에 저장하는 것이 좋을 것입니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"위의 모든 부분은 기본적인 SQL 기술이 있다면 쉽게 해결할 수 있기 때문에 여러분에게 맡기겠습니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"SQL에서 OpenAI API 요약\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"많은 사람들이 SQL이 OpenAI API에 HTTP 호출을 위한 유효한 옵션으로 여겨지지 않는다고 생각하지만, 실제로 많은 신입사원들은 SQL이 기본적인 데이터 조작 이상의 기능을 수행할 수 있다는 것을 알지 못합니다. SQL은 데이터의 언어이며, 이에 따라 Python이 할 수 있는 거의 모든 작업을 데이터 이동 없이 수행할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"오늘의 예시는 Oracle SQL과 PL/SQL로 한정되어 있지만, 여러분이 나의 해결책을 SQL Server, MySQL 및 Postgres에 구현할 방법을 찾을 수 있을 것입니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"SQL 사용 사례 중에서 머신 러닝과 공간 데이터 분석과 같은 더 흥미로운 내용이 추가로 올라올 예정이니 기대해 주세요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"읽어 주셔서 감사합니다.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true}