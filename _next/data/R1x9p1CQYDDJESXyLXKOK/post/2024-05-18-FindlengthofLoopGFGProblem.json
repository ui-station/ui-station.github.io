{"pageProps":{"post":{"title":"루프의 길이 찾기 GFG 문제","description":"","date":"2024-05-18 15:13","slug":"2024-05-18-FindlengthofLoopGFGProblem","content":"\n\n## 소개\n\n연결 리스트는 컴퓨터 과학에서 중요한 데이터 구조입니다. 노드로 구성되어 있으며 각 노드는 데이터와 순서상 다음 노드를 가리키는 참조(또는 링크)를 포함합니다. 연결 리스트의 일반적인 문제 중 하나는 루프를 감지하고 해당 루프의 노드 수를 계산하는 것입니다. 이 기사에서는 연결 리스트 내의 루프에 있는 노드 수를 세는 간단하면서 효과적인 알고리즘에 대해 살펴보겠습니다.\n\n## 문제\n\n연결 리스트의 루프는 노드의 다음 포인터가 리스트 내 이전 노드 중 하나를 가리킬 때 발생하여 순환이 생성됩니다. 이러한 루프를 감지하는 것은 탐색 중 무한 루프를 방지하기 위해 중요합니다. 루프를 감지한 후에는 루프 내 노드 수를 세는 것이 구조를 이해하거나 추가 처리를 위한 여러 목적에 유용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 알고리즘\n\n루프 내 노드 수를 세려면 먼저 루프를 감지해야 합니다. 이를 위해 Floyd의 순환 찾기 알고리즘(토끼와 거북이 알고리즘으로도 알려짐)을 사용할 수 있습니다. 루프가 감지되면 다음 단계를 통해 루프 내 노드 수를 세는 방법을 사용할 수 있습니다.\n\n다음은 루프 내 노드를 세는 코드 스니펫입니다:\n\n```js\nint count = 1;\nNode current = loopNode;\n\nwhile (current.next != loopNode) {\n    current = current.next;\n    count++;\n}\nreturn count;\n```\n\n<div class=\"content-ad\"></div>\n\n아래는 해당 알고리즘을 자세히 살펴보겠습니다:\n\n- 초기화:\n\n    - 루프노드 자체가 루프의 일부이기 때문에 count 카운터를 1로 초기화합니다.\n    - current 포인터를 루프노드로 설정합니다.\n\n- 순회 및 카운팅:\n\n<div class=\"content-ad\"></div>\n\n- 현재 포인터를 사용하여 루프를 트래버스(순회)합니다.\n- 각 노드마다 다음 노드로 이동하고 카운터를 증가시킵니다.\n- 이 과정을 반복하여 루프 노드에 다시 도달할 때까지 진행하여 사이클을 완료합니다.\n\n- 카운트 반환:\n\n- 루프가 완전히 트래버스(순회)된 후, 카운트에는 루프의 노드 수가 저장되며 이를 반환합니다.\n\n## 예시 해설\n\n<div class=\"content-ad\"></div>\n\n다음과 같이 루프를 가진 링크드 리스트를 고려해 봅시다:\n\n![image](/assets/img/2024-05-18-FindlengthofLoopGFGProblem_0.png)\n\n- 여기서 노드 5는 노드 3을 가리키므로 루프가 생성됩니다.\n- loopNode이 노드 3으로 감지되었다고 가정합니다.\n- 우리의 알고리즘은 current를 노드 3으로 초기화하고 카운팅을 시작합니다.\n- 탐색은 다음과 같이 진행됩니다: 3 - 4 - 5 - 6 - 7 - 8 - 3.\n- 각 단계마다 count가 증가하여 최종 count는 6이 됩니다.\n\nMarkdown 형식으로 테이블 태그를 변경합니다.\n\n```js\nstatic int countNodesinLoop(ListNode head) {\n    if (head == null) {\n        return 0;\n    }\n\n    ListNode slow = head;\n    ListNode fast = head;\n\n    int count = 1 ;\n\n    while (fast != null && fast.next != null) {\n        slow = slow.next;\n        fast = fast.next.next;\n\n        if (slow == fast) {\n            return countLoopLength(slow);\n        }\n    }\n\n    return 0;\n}\n\nprivate static int countLoopLength(ListNode loopNode) {\n    int count = 1;\n    ListNode current = loopNode;\n    while (current.next != loopNode) {\n        current = current.next;\n        count++;\n    }\n    return count;\n}\n```\n\n<div class=\"content-ad\"></div>\n\n## 실용적인 고려 사항\n\n- 루프 감지: 위 코드는 루프 감지가 이미 완료되었고 loopNode가 제공되었다고 가정합니다. Floyd의 순환 찾기 알고리즘을 사용하여 이를 달성할 수 있습니다.\n- 예외 경우: 루프가 없거나 루프가 하나의 노드로만 구성된 경우를 고려해야 합니다. 알고리즘은 이러한 사례를 민첩하게 처리해야 합니다.\n- 복잡성: 이 루프 카운팅의 시간 복잡도는 O(n)입니다. 여기서 n은 루프 내 노드의 수입니다. 공간 복잡도는 추가적인 공간을 상수로 사용하므로 O(1)입니다.\n\n## 결론\n\n연결 리스트 내의 루프에서 노드를 계산하는 것은 직관적인 순회 방법을 사용하여 쉽게 수행할 수 있는 기본 작업입니다. 이 알고리즘을 이해하고 구현함으로써 연결 리스트 조작에 대한 이해를 높이고 데이터 구조에서 더 복잡한 문제를 대비할 수 있습니다. 이 지식을 바탕으로 연결 리스트의 루프를 효율적으로 처리하여 알고리즘을 견고하고 신뢰성 있게 만들 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-18-FindlengthofLoopGFGProblem_0.png"},"coverImage":"/assets/img/2024-05-18-FindlengthofLoopGFGProblem_0.png","tag":["Tech"],"readingTime":3},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h2: \"h2\",\n    p: \"p\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\",\n    ul: \"ul\",\n    li: \"li\",\n    img: \"img\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h2, {\n      children: \"소개\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"연결 리스트는 컴퓨터 과학에서 중요한 데이터 구조입니다. 노드로 구성되어 있으며 각 노드는 데이터와 순서상 다음 노드를 가리키는 참조(또는 링크)를 포함합니다. 연결 리스트의 일반적인 문제 중 하나는 루프를 감지하고 해당 루프의 노드 수를 계산하는 것입니다. 이 기사에서는 연결 리스트 내의 루프에 있는 노드 수를 세는 간단하면서 효과적인 알고리즘에 대해 살펴보겠습니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"문제\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"연결 리스트의 루프는 노드의 다음 포인터가 리스트 내 이전 노드 중 하나를 가리킬 때 발생하여 순환이 생성됩니다. 이러한 루프를 감지하는 것은 탐색 중 무한 루프를 방지하기 위해 중요합니다. 루프를 감지한 후에는 루프 내 노드 수를 세는 것이 구조를 이해하거나 추가 처리를 위한 여러 목적에 유용할 수 있습니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"알고리즘\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"루프 내 노드 수를 세려면 먼저 루프를 감지해야 합니다. 이를 위해 Floyd의 순환 찾기 알고리즘(토끼와 거북이 알고리즘으로도 알려짐)을 사용할 수 있습니다. 루프가 감지되면 다음 단계를 통해 루프 내 노드 수를 세는 방법을 사용할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다음은 루프 내 노드를 세는 코드 스니펫입니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"int count = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \";\\n\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Node\"\n        }), \" current = loopNode;\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"while\"\n        }), \" (current.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"next\"\n        }), \" != loopNode) {\\n    current = current.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"next\"\n        }), \";\\n    count++;\\n}\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" count;\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"아래는 해당 알고리즘을 자세히 살펴보겠습니다:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"초기화:\"\n        }), \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsx(_components.li, {\n            children: \"루프노드 자체가 루프의 일부이기 때문에 count 카운터를 1로 초기화합니다.\"\n          }), \"\\n\", _jsx(_components.li, {\n            children: \"current 포인터를 루프노드로 설정합니다.\"\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"순회 및 카운팅:\"\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"현재 포인터를 사용하여 루프를 트래버스(순회)합니다.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"각 노드마다 다음 노드로 이동하고 카운터를 증가시킵니다.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"이 과정을 반복하여 루프 노드에 다시 도달할 때까지 진행하여 사이클을 완료합니다.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"카운트 반환:\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"루프가 완전히 트래버스(순회)된 후, 카운트에는 루프의 노드 수가 저장되며 이를 반환합니다.\"\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"예시 해설\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다음과 같이 루프를 가진 링크드 리스트를 고려해 봅시다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-18-FindlengthofLoopGFGProblem_0.png\",\n        alt: \"image\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"여기서 노드 5는 노드 3을 가리키므로 루프가 생성됩니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"loopNode이 노드 3으로 감지되었다고 가정합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"우리의 알고리즘은 current를 노드 3으로 초기화하고 카운팅을 시작합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"탐색은 다음과 같이 진행됩니다: 3 - 4 - 5 - 6 - 7 - 8 - 3.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"각 단계마다 count가 증가하여 최종 count는 6이 됩니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Markdown 형식으로 테이블 태그를 변경합니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"static\"\n        }), \" int \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"countNodesinLoop\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"ListNode head\"\n        }), \") {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (head == \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"null\"\n        }), \") {\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \";\\n    }\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ListNode\"\n        }), \" slow = head;\\n    \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ListNode\"\n        }), \" fast = head;\\n\\n    int count = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \" ;\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"while\"\n        }), \" (fast != \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"null\"\n        }), \" && fast.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"next\"\n        }), \" != \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"null\"\n        }), \") {\\n        slow = slow.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"next\"\n        }), \";\\n        fast = fast.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"next\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"next\"\n        }), \";\\n\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (slow == fast) {\\n            \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"countLoopLength\"\n        }), \"(slow);\\n        }\\n    }\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \";\\n}\\n\\nprivate \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"static\"\n        }), \" int \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"countLoopLength\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"ListNode loopNode\"\n        }), \") {\\n    int count = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \";\\n    \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ListNode\"\n        }), \" current = loopNode;\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"while\"\n        }), \" (current.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"next\"\n        }), \" != loopNode) {\\n        current = current.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"next\"\n        }), \";\\n        count++;\\n    }\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" count;\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"실용적인 고려 사항\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"루프 감지: 위 코드는 루프 감지가 이미 완료되었고 loopNode가 제공되었다고 가정합니다. Floyd의 순환 찾기 알고리즘을 사용하여 이를 달성할 수 있습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"예외 경우: 루프가 없거나 루프가 하나의 노드로만 구성된 경우를 고려해야 합니다. 알고리즘은 이러한 사례를 민첩하게 처리해야 합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"복잡성: 이 루프 카운팅의 시간 복잡도는 O(n)입니다. 여기서 n은 루프 내 노드의 수입니다. 공간 복잡도는 추가적인 공간을 상수로 사용하므로 O(1)입니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"결론\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"연결 리스트 내의 루프에서 노드를 계산하는 것은 직관적인 순회 방법을 사용하여 쉽게 수행할 수 있는 기본 작업입니다. 이 알고리즘을 이해하고 구현함으로써 연결 리스트 조작에 대한 이해를 높이고 데이터 구조에서 더 복잡한 문제를 대비할 수 있습니다. 이 지식을 바탕으로 연결 리스트의 루프를 효율적으로 처리하여 알고리즘을 견고하고 신뢰성 있게 만들 수 있습니다.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true}