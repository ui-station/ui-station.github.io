<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>파이썬을 사용하여 쌓인 지역 효과 플롯ALE에 대해 깊이 파헤쳐 보기 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-05-23-DeepDiveonAccumulatedLocalEffectPlotsALEswithPython" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="파이썬을 사용하여 쌓인 지역 효과 플롯ALE에 대해 깊이 파헤쳐 보기 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="파이썬을 사용하여 쌓인 지역 효과 플롯ALE에 대해 깊이 파헤쳐 보기 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-23-DeepDiveonAccumulatedLocalEffectPlotsALEswithPython_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-05-23-DeepDiveonAccumulatedLocalEffectPlotsALEswithPython" data-gatsby-head="true"/><meta name="twitter:title" content="파이썬을 사용하여 쌓인 지역 효과 플롯ALE에 대해 깊이 파헤쳐 보기 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-23-DeepDiveonAccumulatedLocalEffectPlotsALEswithPython_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-23 15:34" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-V5DKFTZ6BX"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-V5DKFTZ6BX');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/cd012fc8787133d0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cd012fc8787133d0.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/551-3069cf29fe274aab.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-561ae49ab5aab7f5.js" defer=""></script><script src="/_next/static/R1x9p1CQYDDJESXyLXKOK/_buildManifest.js" defer=""></script><script src="/_next/static/R1x9p1CQYDDJESXyLXKOK/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">파이썬을 사용하여 쌓인 지역 효과 플롯ALE에 대해 깊이 파헤쳐 보기</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="파이썬을 사용하여 쌓인 지역 효과 플롯ALE에 대해 깊이 파헤쳐 보기" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 23, 2024</span><span class="posts_reading_time__f7YPP">9<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-23-DeepDiveonAccumulatedLocalEffectPlotsALEswithPython&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><p>고도로 상관된 기능들은 모델 해석에 혼란을 야기할 수 있습니다. 이러한 기능들은 많은 XAI 방법의 가정을 위반하며, 특성과 타겟 간의 관계를 이해하기 어렵게 만듭니다. 동시에 이러한 기능들을 제거하지 않고는 성능에 영향을 미치지 않으면서 제거할 수 없는 경우도 있습니다. 다중공선성이 있어도 명확한 해석을 제공할 수 있는 방법이 필요합니다. 다행히 ALE(Accumulated Local Effects)에 의존할 수 있습니다.</p>
<p>ALE은 전역 해석 방법입니다. PDP와 비슷하게 모델에 포착된 추세를 보여줍니다. 즉, 특성이 타겟 변수와 선형적, 비선형적 또는 상관 관계가 없는지를 보여줍니다. 그러나 이러한 추세를 식별하는 방법이 매우 다르다는 것을 알게 될 것입니다.</p>
<ul>
<li>ALE가 생성되는 방식에 대한 직관을 제공합니다.</li>
<li>ALE을 생성하는 데 사용되는 알고리즘을 형식적으로 정의합니다.</li>
<li>Alibi Explain 패키지를 사용하여 ALE을 적용합니다.</li>
</ul>
<div class="content-ad"></div>
<p>타 도움말 비교했을 때 SHAP, LIME, ICE Plots, 그리고 프리드만의 H 통계치와 달리, ALE(Accumulated Local Effects)은 다중공선성에 강건한 해석을 제공합니다.
해당 주제에 대한 이 비디오도 즐길 수 있을 것입니다. 그리고 더 배우고 싶다면, XAI with Python과 같은 내 코스도 확인해보세요. 뉴스레터 가입 시 무료로 액세스할 수 있습니다.</p>
<h1>ALE 이해하기</h1>
<p>우리는 전복 데이터셋을 사용하여 ALE이 어떻게 작용하는지 이해할 것입니다. 전복은 조개류의 한 종입니다. 우리는 조개 안의 반지 수를 예측하고 싶은데, 그때 조개 쉘 무게와 살 총량(살의 무게)과 같은 특징을 사용합니다. 이 데이터셋 내 모든 숫자형 특징에 대한 상관 관계 열지도를 보여주는 그림 1을 확인하세요. 우리는 상당히 상관관계가 높은 특징들을 다뤄야 합니다!</p>
<div class="content-ad"></div>
<img src="/assets/img/2024-05-23-DeepDiveonAccumulatedLocalEffectPlotsALEswithPython_1.png"/>
<p>그림 2는 이러한 두 가지 기능에 대한 산포도를 제공합니다. – 셀과 껍질 무게. 이들이 0.9의 상관 값이 있는 이유를 볼 수 있습니다. 이제 빨간 색의 인스턴스를 고려해보세요. 이것은 0.2의 껍질 무게를 가지고 있으며, 이와 유사한 인스턴스들은 대략 0.2에서 0.5 정도의 껍질 무게를 가질 것입니다. 많은 XAI 방법들은 이를 고려하지 않을 것입니다.</p>
<ul>
<li>PDPs는 전체 범위의 껍질 무게를 샘플링할 것입니다.</li>
<li>순열 특성 중요도는 껍질 무게 값을 무작위로 섞을 것입니다.</li>
</ul>
<p>다시 말해, 이러한 방법을 사용하면 발생하기 힘든 또는 불가능한 특성 쌍이 발생할 수 있습니다. 이 문제를 해결하는 핵심은 범위를 고려하는 것입니다.</p>
<div class="content-ad"></div>
<p><img src="/assets/img/2024-05-23-DeepDiveonAccumulatedLocalEffectPlotsALEswithPython_2.png" alt="Image"/></p>
<p>상관관계는 두 특성의 전체 범위를 사용하여 계산할 수 있습니다. 작은 간격 내의 인스턴스만을 살펴보면 상관관계는 무의미해집니다. Figure 3에서 이를 확인할 수 있습니다. 우리는 1.5에서 2.5 사이의 조개 무게를 갖는 인스턴스들만을 고려하여 붉은 색 인스턴스 주변의 간격을 만들었습니다. 오른쪽의 그래프에서 이 간격 내에서 상관관계가 명확하지 않음을 볼 수 있습니다. 더 작은 간격에서는 더 명확하지 않을 것입니다. ALEs는 이를 활용합니다.</p>
<p><img src="/assets/img/2024-05-23-DeepDiveonAccumulatedLocalEffectPlotsALEswithPython_3.png" alt="Image"/></p>
<p>상관관계를 피하기 위해 이 간격 내에서 조개 무게의 영향을 결정할 수 있습니다. 이를 위해 우리는 간격 내 모든 인스턴스에서 두 개의 샘플을 만듭니다. 이를 샘플 쌍이라고 부릅니다. Figure 4에서 볼 수 있듯이, 간격 내에서의 최소 및 최대 조개 무게 값으로 대체하여 이를 생성합니다. 다른 모든 특성 값은 동일하게 유지됩니다.</p>
<div class="content-ad"></div>
<p><img src="/assets/img/2024-05-23-DeepDiveonAccumulatedLocalEffectPlotsALEswithPython_4.png" alt="Image"/></p>
<p>다음 단계는 샘플 쌍의 두 샘플에 대한 블랙박스 모델 예측을 가져오는 것입니다. 그런 다음 최소 샘플(주황색)의 예측값을 최대 샘플(녹색)의 예측값에서 뺍니다. 이 작업을 모든 샘플 쌍에 대해 수행하고 평균을 계산합니다. 이는 이 간격 내에서 껍질 무게의 변화로 인한 예측에 대한 추정치를 제공합니다. 중요한 점은 살아있는 무게와의 상관관계가 이 추정치를 왜곡시키지 않는다는 것입니다.</p>
<p><img src="/assets/img/2024-05-23-DeepDiveonAccumulatedLocalEffectPlotsALEswithPython_5.png" alt="Image"/></p>
<p>좋아요, 이는 특정 간격 내에서의 효과를 제공합니다. 전반적인 추세를 얻으려면 기능 범위 내의 모든 연속적인 간격에 대해 이 작업을 수행하고 개별 효과를 더해야 합니다. 새로운 간격으로 이동할 때마다 효과를 누적 효과에 추가하고 점을 그립니다. 이를 수행하면 껍질 무게에 대한 ALE를 얻을 수 있습니다. 이제 이름의 유래를 확인할 수 있습니다. 간겭(지역) 내에서 기능 효과를 누적하고 있는 것입니다.</p>
<div class="content-ad"></div>
<p>ALEs를 바라보는 또 다른 방법은 적분 또는 적어도 적분을 근사하는 Riemann 합과 유사하다는 것입니다. 지역 효과는 함수의 변화율 또는 도함수입니다. 효과를 누적함으로써 우리는 블랙 박스 모델 곡선을 찾아갑니다. 간격이 작아질수록 우리는 진정한 곡선에 더 가까워집니다. 안타깝게도 ALE에 대해 우리는 간격을 무한히 작게 만들 수 없습니다.</p>
<p><img src="/assets/img/2024-05-23-DeepDiveonAccumulatedLocalEffectPlotsALEswithPython_6.png" alt="image"/></p>
<h1>형식적인 알고리즘</h1>
<p>ALE에 대한 수학적 공식이 있습니다. 이번에는 그걸 넘기겠습니다. 그래도 ALE 알고리즘을 좀 더 형식적으로 정의하는 것은 가치가 있습니다.</p>
<div class="content-ad"></div>
<p><img src="/assets/img/2024-05-23-DeepDiveonAccumulatedLocalEffectPlotsALEswithPython_7.png" alt="Deep Dive on Accumulated Local Effect Plots with Python"/></p>
<p>다양한 구현 방법은 이 알고리즘에 약간의 차이를 줄 수 있습니다. 예를 들어, 제 2 단계에서 간격을 정의하는 방식입니다. 아래 구현은 각 간격에 최소한의 피처가 포함되도록 정의합니다. 또한 각 간격의 너비가 일정한 것으로 정의할 수도 있습니다.</p>
<h1>Alibi를 사용한 ALE 적용</h1>
<p>ALE을 적용하기 위해 alibi 패키지를 사용할 것입니다. 이 패키지는 다양한 XAI 방법을 제공합니다. 현재는 ALE 및 plot_ale 함수 (라인 8-9)에 관심이 있습니다. 이 패키지를 적용하고 플롯을 해석하는 방법을 살펴볼 것이며, 여러 ALE을 결합하고 간격 길이를 변경하는 방법에 대해 알아볼 것입니다.</p>
<div class="content-ad"></div>
<p>#데이터셋 및 모델</p>
<p>이전에 언급한 전복 데이터 세트에 이 방법을 적용할 것입니다. 데이터 세트를 로드하고 타겟을 선택합니다. 또한 몇 가지 특성 엔지니어링을 진행합니다. 먼저, 직경과 전체 무게를 특성 목록에서 제외합니다. 그 이유는 Figure 1에서 다른 특성들과의 상관 관계가 1임을 확인했기 때문입니다. 마지막으로 성별 특성에 대해 원-핫 인코딩을 생성합니다. 최종 특성 세트의 스냅샷을 Figure 5에서 확인할 수 있습니다.</p>
<pre><code class="hljs language-js">#데이터셋을 가져옵니다
data = pd.<span class="hljs-title function_">read_csv</span>(<span class="hljs-string">&quot;../../data/abalone.data&quot;</span>,
                  names=[<span class="hljs-string">&quot;sex&quot;</span>,<span class="hljs-string">&quot;length&quot;</span>,<span class="hljs-string">&quot;diameter&quot;</span>,<span class="hljs-string">&quot;height&quot;</span>,<span class="hljs-string">&quot;whole weight&quot;</span>,
                         <span class="hljs-string">&quot;shucked weight&quot;</span>,<span class="hljs-string">&quot;viscera weight&quot;</span>,<span class="hljs-string">&quot;shell weight&quot;</span>,<span class="hljs-string">&quot;rings&quot;</span>])

y = data[<span class="hljs-string">&quot;rings&quot;</span>]
X = data[[<span class="hljs-string">&quot;sex&quot;</span>, <span class="hljs-string">&quot;length&quot;</span>, <span class="hljs-string">&quot;height&quot;</span>, <span class="hljs-string">&quot;shucked weight&quot;</span>, <span class="hljs-string">&quot;viscera weight&quot;</span>, <span class="hljs-string">&quot;shell weight&quot;</span>]]

# 더미 변수 생성
X[<span class="hljs-string">&#x27;sex.M&#x27;</span>] = [<span class="hljs-number">1</span> <span class="hljs-keyword">if</span> s == <span class="hljs-string">&#x27;M&#x27;</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span> <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> X[<span class="hljs-string">&#x27;sex&#x27;</span>]]
X[<span class="hljs-string">&#x27;sex.F&#x27;</span>] = [<span class="hljs-number">1</span> <span class="hljs-keyword">if</span> s == <span class="hljs-string">&#x27;F&#x27;</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span> <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> X[<span class="hljs-string">&#x27;sex&#x27;</span>]]
X[<span class="hljs-string">&#x27;sex.I&#x27;</span>] = [<span class="hljs-number">1</span> <span class="hljs-keyword">if</span> s == <span class="hljs-string">&#x27;I&#x27;</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span> <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> X[<span class="hljs-string">&#x27;sex&#x27;</span>]]
X = X.<span class="hljs-title function_">drop</span>(<span class="hljs-string">&#x27;sex&#x27;</span>, axis=<span class="hljs-number">1</span>)

X.<span class="hljs-title function_">head</span>()
</code></pre>
<div class="content-ad"></div>
<img src="/assets/img/2024-05-23-DeepDiveonAccumulatedLocalEffectPlotsALEswithPython_8.png"/>
<p>우리는 이러한 특성들을 사용하여 모델을 훈련시켜 반지의 개수를 예측합니다 (lines 2-3). 모델을 훈련할 때 특성 매트릭스를 numpy 배열로 변환합니다. ALEs를 생성할 때 경고 메시지가 표시되지 않도록 하기 위함입니다.</p>
<pre><code class="hljs language-js"># 모델 훈련
model = <span class="hljs-title class_">RandomForestRegressor</span>()
model.<span class="hljs-title function_">fit</span>(X.<span class="hljs-title function_">to_numpy</span>(), y)
</code></pre>
<h2>ALE 그래프 그리기</h2>
<div class="content-ad"></div>
<p>ALE 플롯을 생성하려면, 먼저 ale 객체를 생성해야 합니다 (2번째 줄). 이를 위해 모델의 예측 함수 (model.predict), 피처 이름 및 타겟 이름을 전달합니다. 그런 다음 이 객체를 사용하여 X 피처 매트릭스에 대한 설명 (exp)을 생성합니다 (3번째 줄). 설명 함수를 사용하려면 이 매트릭스가 넘파이 배열이어야 합니다.</p>
<pre><code class="hljs language-js"># <span class="hljs-variable constant_">ALE</span> 설명 가져오기
ale = <span class="hljs-title function_">ALE</span>(model.<span class="hljs-property">predict</span>, feature_names=X.<span class="hljs-property">columns</span>, target_names=[<span class="hljs-string">&#x27;rings&#x27;</span>])
exp = ale.<span class="hljs-title function_">explain</span>(X.<span class="hljs-title function_">to_numpy</span>())
</code></pre>
<p>ALE 플롯을 생성하려면 설명과 표시하려는 피처를 plot_ale에 전달합니다. 위치 배열 [0,1,2]를 사용하면 처음 3개 피처에 대한 ALE를 표시합니다. Figure 6에서 확인할 수 있습니다.</p>
<pre><code class="hljs language-js"># 처음 <span class="hljs-number">3</span>개 피처에 대한 <span class="hljs-variable constant_">ALE</span> 설명 플롯하기
<span class="hljs-title function_">plot_ale</span>(exp, features=[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], fig_kw={<span class="hljs-string">&#x27;figwidth&#x27;</span>:<span class="hljs-number">15</span>, <span class="hljs-string">&#x27;figheight&#x27;</span>: <span class="hljs-number">5</span>})
</code></pre>
<div class="content-ad"></div>
<p><img src="/assets/img/2024-05-23-DeepDiveonAccumulatedLocalEffectPlotsALEswithPython_9.png" alt="image"/></p>
<p>제 6번 그림에서 얻을 수 있는 몇 가지 결론은 다음과 같습니다:</p>
<ul>
<li>길이와 높이가 예측된 링 개수에 미치는 영향은 껍질 무게와 비교할 때 낮습니다.</li>
<li>껍질 무게에 대한 내려가는 선은 껍질 무게가 증가함에 따라 예측된 링 개수가 감소하는 경향을 보입니다.</li>
</ul>
<p>또한 플롯에서 개별 점을 해석할 수도 있지만, 먼저 플롯이 어떻게 중심화되었는지 이해해야 합니다. Figure 7에서 껍질 무게 관계에 초점을 맞추어 봅시다.</p>
<div class="content-ad"></div>
<p><img src="/assets/img/2024-05-23-DeepDiveonAccumulatedLocalEffectPlotsALEswithPython_10.png" alt="그림 7"/></p>
<p>ALE는 0을 중심으로 설정되었습니다. 이것은 각 ALE의 미중심 누적 지역 효과에서 평균을 뺌으로써 수행됩니다. 처음에는 혼란스러울 수 있습니다. ALE의 평균을 찾기 위해서는 먼저 ALE의 각 지점에서 누적 지역 효과를 합산해야 합니다. 결과적으로 ALE의 각 지점은 해당 특징값과 해당 특징의 평균 효과를 비교했을 때의 효과를 나타냅니다. 또는 더 간단히 말하면, 평균 예측과 비교했을 때의 효과입니다.</p>
<p>따라서, 그림 7의 터플 중량에 대한 플롯을 살펴보면 다음과 같은 결론을 내릴 수 있습니다:</p>
<ul>
<li>터플 중량이 0이면 평균 예측 대비 6개의 고리 예측이 증가합니다.</li>
<li>터플 중량이 1.4인 경우에 비해 0의 터플 중량은 예측이 12개 증가합니다.</li>
</ul>
<div class="content-ad"></div>
<h2>ALE 결합하기</h2>
<p>그럼 alibi 패키지로 무엇을 더 할 수 있는지 알아보겠습니다. 특징들이 유사한 값을 갖고 있다면, ALE을 동일한 축에 플롯하는 것이 유용할 수 있습니다. 아래에서는 이를 3개의 무게 특징에 대해 수행합니다. 그림 8을 보면, 이러한 특징들의 영향을 비교하는 것이 얼마나 쉬운지 알 수 있습니다.</p>
<pre><code class="hljs language-python"><span class="hljs-comment"># 무게 특징에 대한 ALE 플롯</span>
fig, ax = plt.subplots(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, figsize=(<span class="hljs-number">8</span>, <span class="hljs-number">4</span>))

plot_ale(exp, features=[<span class="hljs-number">2</span>], ax=ax, line_kw={<span class="hljs-string">&#x27;label&#x27;</span>: <span class="hljs-string">&#x27;shucked weight&#x27;</span>})
plot_ale(exp, features=[<span class="hljs-number">3</span>], ax=ax, line_kw={<span class="hljs-string">&#x27;label&#x27;</span>: <span class="hljs-string">&#x27;viscera weight&#x27;</span>})
plot_ale(exp, features=[<span class="hljs-number">4</span>], ax=ax, line_kw={<span class="hljs-string">&#x27;label&#x27;</span>: <span class="hljs-string">&#x27;shell weight&#x27;</span>})

ax.set_xlabel(<span class="hljs-string">&#x27;weight&#x27;</span>)
</code></pre>
<p>shucked weight와 shell weight가 예측에 상당한 영향을 미치는 것을 알 수 있습니다. 그러나 그들은 반대 방향에 있습니다. 흥미로운 사실입니다! 이러한 특징들은 상호 관련이 높지만 예측과는 서로 다른 관계를 가지고 있습니다. 이는 두 특징 간의 상호 작용 때문입니다 — 이를 알아보기 위해 H-통계를 사용할 수 있습니다(향후 게시될 기사를 기대해주세요).</p>
<div class="content-ad"></div>
<p><img src="/assets/img/2024-05-23-DeepDiveonAccumulatedLocalEffectPlotsALEswithPython_11.png" alt="Screenshot"/></p>
<p>여기서 변수 간격이 다른 것을 알 수 있습니다. 이는 패키지가 간격을 선택하는 방식과 관련이 있습니다. 기본적으로 적어도 4개의 인스턴스가 포함된 간격을 선택합니다. 따라서 ALEs에서 끝에서 두 번째와 마지막 포인트 사이에 상대적으로 큰 거리를 볼 수 있습니다. 이러한 가중치 값에 대해 데이터 세트가 희소해지고 적어도 4개의 인스턴스를 포착하기 위해 더 큰 간격이 필요합니다.</p>
<h2>간격 길이 증가</h2>
<p>아래 코드에서는 동일한 차트를 만들되 한 가지 주요 차이가 있습니다. 간격 내의 최소 인스턴스 수를 50으로 변경했습니다 (3번째 줄). 이는 min_bin_points 매개변수를 사용하여 수행됩니다. Figure 9에서 볼 수 있듯이 결과는 더 부드러운 ALE 및 큰 간격입니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-python"><span class="hljs-comment"># 간격 조정</span>
ale = ALE(model.predict, feature_names=X.columns, target_names=[<span class="hljs-string">&#x27;rings&#x27;</span>])
exp = ale.explain(X.to_numpy(), min_bin_points=<span class="hljs-number">50</span>)

fig, ax = plt.subplots(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, figsize=(<span class="hljs-number">8</span>, <span class="hljs-number">4</span>))

plot_ale(exp, features=[<span class="hljs-number">2</span>], ax=ax, line_kw={<span class="hljs-string">&#x27;label&#x27;</span>: <span class="hljs-string">&#x27;shucked weight&#x27;</span>})
plot_ale(exp, features=[<span class="hljs-number">3</span>], ax=ax, line_kw={<span class="hljs-string">&#x27;label&#x27;</span>: <span class="hljs-string">&#x27;viscera weight&#x27;</span>})
plot_ale(exp, features=[<span class="hljs-number">4</span>], ax=ax, line_kw={<span class="hljs-string">&#x27;label&#x27;</span>: <span class="hljs-string">&#x27;shell weight&#x27;</span>})

ax.set_xlabel(<span class="hljs-string">&#x27;weight&#x27;</span>)
</code></pre>
<p><img src="/assets/img/2024-05-23-DeepDiveonAccumulatedLocalEffectPlotsALEswithPython_12.png" alt="image"/></p>
<p><code>min_bin_points</code>는 ALE를 만들 때 trade-off를 도입합니다. 이 값을 줄이면 간격의 크기가 줄어듭니다. 이는 곡선의 진정한 모양에 더 가까워질 것입니다. 그러나 이러한 간격 내에서 효과를 추정하는 데 사용할 수 있는 샘플 크기가 줄어들어 불확실성에 직면하게 됩니다. 일반적으로 이 불확실성으로 인해 구간 간 변화보다는 전반적인 추세에 중점을 두어야 합니다.</p>
<p>다른 고려사항은 ALE의 해석은 명료하지만 해당 해석을 얻는 방법을 설명하기는 복잡할 수 있다는 것입니다. PDP가 어떻게 생성되는지 비교할 때 적어도 그렇습니다. 따라서 두 방법을 함께 사용하는 것이 유용합니다. 결과가 일치하면 언제든 PDP를 제시할 수 있습니다. 이렇게 하면 평균 누적 로컬 효과가 무엇인지 설명하는 머리 아픈 작업이 절약될 수 있습니다!</p>
<div class="content-ad"></div>
<p>만약 PDPs가 어떻게 만들어지는지 알고 싶다면 이 기사를 참조해보세요:</p>
<p>다른 XAI 기사들도 유용하게 사용할 수 있을 거예요:</p>
<p>이 기사를 즐겁게 읽으셨으면 좋겠어요! 무료로 파이썬 XAI 코스에 접근할 수 있는 Threads | YouTube | Newsletter에서 저를 찾아보세요</p>
<h2>참고문헌</h2>
<div class="content-ad"></div>
<p>[1] Daniel W Apley 및 Jingyu Zhu. 블랙 박스 지도 학습 모델에서 예측 변수의 효과를 시각화하는 방법. Journal of the Royal Statistical Society Series B: Statistical Methodology, 82(4):1059–1086, 2020.</p></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"파이썬을 사용하여 쌓인 지역 효과 플롯ALE에 대해 깊이 파헤쳐 보기","description":"","date":"2024-05-23 15:34","slug":"2024-05-23-DeepDiveonAccumulatedLocalEffectPlotsALEswithPython","content":"\n고도로 상관된 기능들은 모델 해석에 혼란을 야기할 수 있습니다. 이러한 기능들은 많은 XAI 방법의 가정을 위반하며, 특성과 타겟 간의 관계를 이해하기 어렵게 만듭니다. 동시에 이러한 기능들을 제거하지 않고는 성능에 영향을 미치지 않으면서 제거할 수 없는 경우도 있습니다. 다중공선성이 있어도 명확한 해석을 제공할 수 있는 방법이 필요합니다. 다행히 ALE(Accumulated Local Effects)에 의존할 수 있습니다.\n\nALE은 전역 해석 방법입니다. PDP와 비슷하게 모델에 포착된 추세를 보여줍니다. 즉, 특성이 타겟 변수와 선형적, 비선형적 또는 상관 관계가 없는지를 보여줍니다. 그러나 이러한 추세를 식별하는 방법이 매우 다르다는 것을 알게 될 것입니다.\n\n- ALE가 생성되는 방식에 대한 직관을 제공합니다.\n- ALE을 생성하는 데 사용되는 알고리즘을 형식적으로 정의합니다.\n- Alibi Explain 패키지를 사용하여 ALE을 적용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n타 도움말 비교했을 때 SHAP, LIME, ICE Plots, 그리고 프리드만의 H 통계치와 달리, ALE(Accumulated Local Effects)은 다중공선성에 강건한 해석을 제공합니다.\n해당 주제에 대한 이 비디오도 즐길 수 있을 것입니다. 그리고 더 배우고 싶다면, XAI with Python과 같은 내 코스도 확인해보세요. 뉴스레터 가입 시 무료로 액세스할 수 있습니다.\n\n# ALE 이해하기\n\n우리는 전복 데이터셋을 사용하여 ALE이 어떻게 작용하는지 이해할 것입니다. 전복은 조개류의 한 종입니다. 우리는 조개 안의 반지 수를 예측하고 싶은데, 그때 조개 쉘 무게와 살 총량(살의 무게)과 같은 특징을 사용합니다. 이 데이터셋 내 모든 숫자형 특징에 대한 상관 관계 열지도를 보여주는 그림 1을 확인하세요. 우리는 상당히 상관관계가 높은 특징들을 다뤄야 합니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-05-23-DeepDiveonAccumulatedLocalEffectPlotsALEswithPython_1.png\" /\u003e\n\n그림 2는 이러한 두 가지 기능에 대한 산포도를 제공합니다. – 셀과 껍질 무게. 이들이 0.9의 상관 값이 있는 이유를 볼 수 있습니다. 이제 빨간 색의 인스턴스를 고려해보세요. 이것은 0.2의 껍질 무게를 가지고 있으며, 이와 유사한 인스턴스들은 대략 0.2에서 0.5 정도의 껍질 무게를 가질 것입니다. 많은 XAI 방법들은 이를 고려하지 않을 것입니다.\n\n- PDPs는 전체 범위의 껍질 무게를 샘플링할 것입니다.\n- 순열 특성 중요도는 껍질 무게 값을 무작위로 섞을 것입니다.\n\n다시 말해, 이러한 방법을 사용하면 발생하기 힘든 또는 불가능한 특성 쌍이 발생할 수 있습니다. 이 문제를 해결하는 핵심은 범위를 고려하는 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![Image](/assets/img/2024-05-23-DeepDiveonAccumulatedLocalEffectPlotsALEswithPython_2.png)\n\n상관관계는 두 특성의 전체 범위를 사용하여 계산할 수 있습니다. 작은 간격 내의 인스턴스만을 살펴보면 상관관계는 무의미해집니다. Figure 3에서 이를 확인할 수 있습니다. 우리는 1.5에서 2.5 사이의 조개 무게를 갖는 인스턴스들만을 고려하여 붉은 색 인스턴스 주변의 간격을 만들었습니다. 오른쪽의 그래프에서 이 간격 내에서 상관관계가 명확하지 않음을 볼 수 있습니다. 더 작은 간격에서는 더 명확하지 않을 것입니다. ALEs는 이를 활용합니다.\n\n![Image](/assets/img/2024-05-23-DeepDiveonAccumulatedLocalEffectPlotsALEswithPython_3.png)\n\n상관관계를 피하기 위해 이 간격 내에서 조개 무게의 영향을 결정할 수 있습니다. 이를 위해 우리는 간격 내 모든 인스턴스에서 두 개의 샘플을 만듭니다. 이를 샘플 쌍이라고 부릅니다. Figure 4에서 볼 수 있듯이, 간격 내에서의 최소 및 최대 조개 무게 값으로 대체하여 이를 생성합니다. 다른 모든 특성 값은 동일하게 유지됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Image](/assets/img/2024-05-23-DeepDiveonAccumulatedLocalEffectPlotsALEswithPython_4.png)\n\n다음 단계는 샘플 쌍의 두 샘플에 대한 블랙박스 모델 예측을 가져오는 것입니다. 그런 다음 최소 샘플(주황색)의 예측값을 최대 샘플(녹색)의 예측값에서 뺍니다. 이 작업을 모든 샘플 쌍에 대해 수행하고 평균을 계산합니다. 이는 이 간격 내에서 껍질 무게의 변화로 인한 예측에 대한 추정치를 제공합니다. 중요한 점은 살아있는 무게와의 상관관계가 이 추정치를 왜곡시키지 않는다는 것입니다.\n\n![Image](/assets/img/2024-05-23-DeepDiveonAccumulatedLocalEffectPlotsALEswithPython_5.png)\n\n좋아요, 이는 특정 간격 내에서의 효과를 제공합니다. 전반적인 추세를 얻으려면 기능 범위 내의 모든 연속적인 간격에 대해 이 작업을 수행하고 개별 효과를 더해야 합니다. 새로운 간격으로 이동할 때마다 효과를 누적 효과에 추가하고 점을 그립니다. 이를 수행하면 껍질 무게에 대한 ALE를 얻을 수 있습니다. 이제 이름의 유래를 확인할 수 있습니다. 간겭(지역) 내에서 기능 효과를 누적하고 있는 것입니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nALEs를 바라보는 또 다른 방법은 적분 또는 적어도 적분을 근사하는 Riemann 합과 유사하다는 것입니다. 지역 효과는 함수의 변화율 또는 도함수입니다. 효과를 누적함으로써 우리는 블랙 박스 모델 곡선을 찾아갑니다. 간격이 작아질수록 우리는 진정한 곡선에 더 가까워집니다. 안타깝게도 ALE에 대해 우리는 간격을 무한히 작게 만들 수 없습니다.\n\n![image](/assets/img/2024-05-23-DeepDiveonAccumulatedLocalEffectPlotsALEswithPython_6.png)\n\n# 형식적인 알고리즘\n\nALE에 대한 수학적 공식이 있습니다. 이번에는 그걸 넘기겠습니다. 그래도 ALE 알고리즘을 좀 더 형식적으로 정의하는 것은 가치가 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Deep Dive on Accumulated Local Effect Plots with Python](/assets/img/2024-05-23-DeepDiveonAccumulatedLocalEffectPlotsALEswithPython_7.png)\n\n다양한 구현 방법은 이 알고리즘에 약간의 차이를 줄 수 있습니다. 예를 들어, 제 2 단계에서 간격을 정의하는 방식입니다. 아래 구현은 각 간격에 최소한의 피처가 포함되도록 정의합니다. 또한 각 간격의 너비가 일정한 것으로 정의할 수도 있습니다.\n\n# Alibi를 사용한 ALE 적용\n\nALE을 적용하기 위해 alibi 패키지를 사용할 것입니다. 이 패키지는 다양한 XAI 방법을 제공합니다. 현재는 ALE 및 plot_ale 함수 (라인 8-9)에 관심이 있습니다. 이 패키지를 적용하고 플롯을 해석하는 방법을 살펴볼 것이며, 여러 ALE을 결합하고 간격 길이를 변경하는 방법에 대해 알아볼 것입니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n#데이터셋 및 모델\n\n이전에 언급한 전복 데이터 세트에 이 방법을 적용할 것입니다. 데이터 세트를 로드하고 타겟을 선택합니다. 또한 몇 가지 특성 엔지니어링을 진행합니다. 먼저, 직경과 전체 무게를 특성 목록에서 제외합니다. 그 이유는 Figure 1에서 다른 특성들과의 상관 관계가 1임을 확인했기 때문입니다. 마지막으로 성별 특성에 대해 원-핫 인코딩을 생성합니다. 최종 특성 세트의 스냅샷을 Figure 5에서 확인할 수 있습니다.\n\n```js\n#데이터셋을 가져옵니다\ndata = pd.read_csv(\"../../data/abalone.data\",\n                  names=[\"sex\",\"length\",\"diameter\",\"height\",\"whole weight\",\n                         \"shucked weight\",\"viscera weight\",\"shell weight\",\"rings\"])\n\ny = data[\"rings\"]\nX = data[[\"sex\", \"length\", \"height\", \"shucked weight\", \"viscera weight\", \"shell weight\"]]\n\n# 더미 변수 생성\nX['sex.M'] = [1 if s == 'M' else 0 for s in X['sex']]\nX['sex.F'] = [1 if s == 'F' else 0 for s in X['sex']]\nX['sex.I'] = [1 if s == 'I' else 0 for s in X['sex']]\nX = X.drop('sex', axis=1)\n\nX.head()\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-05-23-DeepDiveonAccumulatedLocalEffectPlotsALEswithPython_8.png\" /\u003e\n\n우리는 이러한 특성들을 사용하여 모델을 훈련시켜 반지의 개수를 예측합니다 (lines 2-3). 모델을 훈련할 때 특성 매트릭스를 numpy 배열로 변환합니다. ALEs를 생성할 때 경고 메시지가 표시되지 않도록 하기 위함입니다.\n\n```js\n# 모델 훈련\nmodel = RandomForestRegressor()\nmodel.fit(X.to_numpy(), y)\n```\n\n## ALE 그래프 그리기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nALE 플롯을 생성하려면, 먼저 ale 객체를 생성해야 합니다 (2번째 줄). 이를 위해 모델의 예측 함수 (model.predict), 피처 이름 및 타겟 이름을 전달합니다. 그런 다음 이 객체를 사용하여 X 피처 매트릭스에 대한 설명 (exp)을 생성합니다 (3번째 줄). 설명 함수를 사용하려면 이 매트릭스가 넘파이 배열이어야 합니다.\n\n```js\n# ALE 설명 가져오기\nale = ALE(model.predict, feature_names=X.columns, target_names=['rings'])\nexp = ale.explain(X.to_numpy())\n```\n\nALE 플롯을 생성하려면 설명과 표시하려는 피처를 plot_ale에 전달합니다. 위치 배열 [0,1,2]를 사용하면 처음 3개 피처에 대한 ALE를 표시합니다. Figure 6에서 확인할 수 있습니다.\n\n```js\n# 처음 3개 피처에 대한 ALE 설명 플롯하기\nplot_ale(exp, features=[0,1,2], fig_kw={'figwidth':15, 'figheight': 5})\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![image](/assets/img/2024-05-23-DeepDiveonAccumulatedLocalEffectPlotsALEswithPython_9.png)\n\n제 6번 그림에서 얻을 수 있는 몇 가지 결론은 다음과 같습니다:\n\n- 길이와 높이가 예측된 링 개수에 미치는 영향은 껍질 무게와 비교할 때 낮습니다.\n- 껍질 무게에 대한 내려가는 선은 껍질 무게가 증가함에 따라 예측된 링 개수가 감소하는 경향을 보입니다.\n\n또한 플롯에서 개별 점을 해석할 수도 있지만, 먼저 플롯이 어떻게 중심화되었는지 이해해야 합니다. Figure 7에서 껍질 무게 관계에 초점을 맞추어 봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![그림 7](/assets/img/2024-05-23-DeepDiveonAccumulatedLocalEffectPlotsALEswithPython_10.png)\n\nALE는 0을 중심으로 설정되었습니다. 이것은 각 ALE의 미중심 누적 지역 효과에서 평균을 뺌으로써 수행됩니다. 처음에는 혼란스러울 수 있습니다. ALE의 평균을 찾기 위해서는 먼저 ALE의 각 지점에서 누적 지역 효과를 합산해야 합니다. 결과적으로 ALE의 각 지점은 해당 특징값과 해당 특징의 평균 효과를 비교했을 때의 효과를 나타냅니다. 또는 더 간단히 말하면, 평균 예측과 비교했을 때의 효과입니다.\n\n따라서, 그림 7의 터플 중량에 대한 플롯을 살펴보면 다음과 같은 결론을 내릴 수 있습니다:\n\n- 터플 중량이 0이면 평균 예측 대비 6개의 고리 예측이 증가합니다.\n- 터플 중량이 1.4인 경우에 비해 0의 터플 중량은 예측이 12개 증가합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## ALE 결합하기\n\n그럼 alibi 패키지로 무엇을 더 할 수 있는지 알아보겠습니다. 특징들이 유사한 값을 갖고 있다면, ALE을 동일한 축에 플롯하는 것이 유용할 수 있습니다. 아래에서는 이를 3개의 무게 특징에 대해 수행합니다. 그림 8을 보면, 이러한 특징들의 영향을 비교하는 것이 얼마나 쉬운지 알 수 있습니다.\n\n```python\n# 무게 특징에 대한 ALE 플롯\nfig, ax = plt.subplots(1, 1, figsize=(8, 4))\n\nplot_ale(exp, features=[2], ax=ax, line_kw={'label': 'shucked weight'})\nplot_ale(exp, features=[3], ax=ax, line_kw={'label': 'viscera weight'})\nplot_ale(exp, features=[4], ax=ax, line_kw={'label': 'shell weight'})\n\nax.set_xlabel('weight')\n```\n\nshucked weight와 shell weight가 예측에 상당한 영향을 미치는 것을 알 수 있습니다. 그러나 그들은 반대 방향에 있습니다. 흥미로운 사실입니다! 이러한 특징들은 상호 관련이 높지만 예측과는 서로 다른 관계를 가지고 있습니다. 이는 두 특징 간의 상호 작용 때문입니다 — 이를 알아보기 위해 H-통계를 사용할 수 있습니다(향후 게시될 기사를 기대해주세요).\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Screenshot](/assets/img/2024-05-23-DeepDiveonAccumulatedLocalEffectPlotsALEswithPython_11.png)\n\n여기서 변수 간격이 다른 것을 알 수 있습니다. 이는 패키지가 간격을 선택하는 방식과 관련이 있습니다. 기본적으로 적어도 4개의 인스턴스가 포함된 간격을 선택합니다. 따라서 ALEs에서 끝에서 두 번째와 마지막 포인트 사이에 상대적으로 큰 거리를 볼 수 있습니다. 이러한 가중치 값에 대해 데이터 세트가 희소해지고 적어도 4개의 인스턴스를 포착하기 위해 더 큰 간격이 필요합니다.\n\n## 간격 길이 증가\n\n아래 코드에서는 동일한 차트를 만들되 한 가지 주요 차이가 있습니다. 간격 내의 최소 인스턴스 수를 50으로 변경했습니다 (3번째 줄). 이는 min_bin_points 매개변수를 사용하여 수행됩니다. Figure 9에서 볼 수 있듯이 결과는 더 부드러운 ALE 및 큰 간격입니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```python\n# 간격 조정\nale = ALE(model.predict, feature_names=X.columns, target_names=['rings'])\nexp = ale.explain(X.to_numpy(), min_bin_points=50)\n\nfig, ax = plt.subplots(1, 1, figsize=(8, 4))\n\nplot_ale(exp, features=[2], ax=ax, line_kw={'label': 'shucked weight'})\nplot_ale(exp, features=[3], ax=ax, line_kw={'label': 'viscera weight'})\nplot_ale(exp, features=[4], ax=ax, line_kw={'label': 'shell weight'})\n\nax.set_xlabel('weight')\n```\n\n![image](/assets/img/2024-05-23-DeepDiveonAccumulatedLocalEffectPlotsALEswithPython_12.png)\n\n`min_bin_points`는 ALE를 만들 때 trade-off를 도입합니다. 이 값을 줄이면 간격의 크기가 줄어듭니다. 이는 곡선의 진정한 모양에 더 가까워질 것입니다. 그러나 이러한 간격 내에서 효과를 추정하는 데 사용할 수 있는 샘플 크기가 줄어들어 불확실성에 직면하게 됩니다. 일반적으로 이 불확실성으로 인해 구간 간 변화보다는 전반적인 추세에 중점을 두어야 합니다.\n\n다른 고려사항은 ALE의 해석은 명료하지만 해당 해석을 얻는 방법을 설명하기는 복잡할 수 있다는 것입니다. PDP가 어떻게 생성되는지 비교할 때 적어도 그렇습니다. 따라서 두 방법을 함께 사용하는 것이 유용합니다. 결과가 일치하면 언제든 PDP를 제시할 수 있습니다. 이렇게 하면 평균 누적 로컬 효과가 무엇인지 설명하는 머리 아픈 작업이 절약될 수 있습니다!\n\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 PDPs가 어떻게 만들어지는지 알고 싶다면 이 기사를 참조해보세요:\n\n다른 XAI 기사들도 유용하게 사용할 수 있을 거예요:\n\n이 기사를 즐겁게 읽으셨으면 좋겠어요! 무료로 파이썬 XAI 코스에 접근할 수 있는 Threads | YouTube | Newsletter에서 저를 찾아보세요\n\n## 참고문헌\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n[1] Daniel W Apley 및 Jingyu Zhu. 블랙 박스 지도 학습 모델에서 예측 변수의 효과를 시각화하는 방법. Journal of the Royal Statistical Society Series B: Statistical Methodology, 82(4):1059–1086, 2020.\n\n","ogImage":{"url":"/assets/img/2024-05-23-DeepDiveonAccumulatedLocalEffectPlotsALEswithPython_0.png"},"coverImage":"/assets/img/2024-05-23-DeepDiveonAccumulatedLocalEffectPlotsALEswithPython_0.png","tag":["Tech"],"readingTime":9},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    ul: \"ul\",\n    li: \"li\",\n    h1: \"h1\",\n    img: \"img\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\",\n    h2: \"h2\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"고도로 상관된 기능들은 모델 해석에 혼란을 야기할 수 있습니다. 이러한 기능들은 많은 XAI 방법의 가정을 위반하며, 특성과 타겟 간의 관계를 이해하기 어렵게 만듭니다. 동시에 이러한 기능들을 제거하지 않고는 성능에 영향을 미치지 않으면서 제거할 수 없는 경우도 있습니다. 다중공선성이 있어도 명확한 해석을 제공할 수 있는 방법이 필요합니다. 다행히 ALE(Accumulated Local Effects)에 의존할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"ALE은 전역 해석 방법입니다. PDP와 비슷하게 모델에 포착된 추세를 보여줍니다. 즉, 특성이 타겟 변수와 선형적, 비선형적 또는 상관 관계가 없는지를 보여줍니다. 그러나 이러한 추세를 식별하는 방법이 매우 다르다는 것을 알게 될 것입니다.\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"ALE가 생성되는 방식에 대한 직관을 제공합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"ALE을 생성하는 데 사용되는 알고리즘을 형식적으로 정의합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Alibi Explain 패키지를 사용하여 ALE을 적용합니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"타 도움말 비교했을 때 SHAP, LIME, ICE Plots, 그리고 프리드만의 H 통계치와 달리, ALE(Accumulated Local Effects)은 다중공선성에 강건한 해석을 제공합니다.\\n해당 주제에 대한 이 비디오도 즐길 수 있을 것입니다. 그리고 더 배우고 싶다면, XAI with Python과 같은 내 코스도 확인해보세요. 뉴스레터 가입 시 무료로 액세스할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"ALE 이해하기\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우리는 전복 데이터셋을 사용하여 ALE이 어떻게 작용하는지 이해할 것입니다. 전복은 조개류의 한 종입니다. 우리는 조개 안의 반지 수를 예측하고 싶은데, 그때 조개 쉘 무게와 살 총량(살의 무게)과 같은 특징을 사용합니다. 이 데이터셋 내 모든 숫자형 특징에 대한 상관 관계 열지도를 보여주는 그림 1을 확인하세요. 우리는 상당히 상관관계가 높은 특징들을 다뤄야 합니다!\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/assets/img/2024-05-23-DeepDiveonAccumulatedLocalEffectPlotsALEswithPython_1.png\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그림 2는 이러한 두 가지 기능에 대한 산포도를 제공합니다. – 셀과 껍질 무게. 이들이 0.9의 상관 값이 있는 이유를 볼 수 있습니다. 이제 빨간 색의 인스턴스를 고려해보세요. 이것은 0.2의 껍질 무게를 가지고 있으며, 이와 유사한 인스턴스들은 대략 0.2에서 0.5 정도의 껍질 무게를 가질 것입니다. 많은 XAI 방법들은 이를 고려하지 않을 것입니다.\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"PDPs는 전체 범위의 껍질 무게를 샘플링할 것입니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"순열 특성 중요도는 껍질 무게 값을 무작위로 섞을 것입니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다시 말해, 이러한 방법을 사용하면 발생하기 힘든 또는 불가능한 특성 쌍이 발생할 수 있습니다. 이 문제를 해결하는 핵심은 범위를 고려하는 것입니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-23-DeepDiveonAccumulatedLocalEffectPlotsALEswithPython_2.png\",\n        alt: \"Image\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"상관관계는 두 특성의 전체 범위를 사용하여 계산할 수 있습니다. 작은 간격 내의 인스턴스만을 살펴보면 상관관계는 무의미해집니다. Figure 3에서 이를 확인할 수 있습니다. 우리는 1.5에서 2.5 사이의 조개 무게를 갖는 인스턴스들만을 고려하여 붉은 색 인스턴스 주변의 간격을 만들었습니다. 오른쪽의 그래프에서 이 간격 내에서 상관관계가 명확하지 않음을 볼 수 있습니다. 더 작은 간격에서는 더 명확하지 않을 것입니다. ALEs는 이를 활용합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-23-DeepDiveonAccumulatedLocalEffectPlotsALEswithPython_3.png\",\n        alt: \"Image\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"상관관계를 피하기 위해 이 간격 내에서 조개 무게의 영향을 결정할 수 있습니다. 이를 위해 우리는 간격 내 모든 인스턴스에서 두 개의 샘플을 만듭니다. 이를 샘플 쌍이라고 부릅니다. Figure 4에서 볼 수 있듯이, 간격 내에서의 최소 및 최대 조개 무게 값으로 대체하여 이를 생성합니다. 다른 모든 특성 값은 동일하게 유지됩니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-23-DeepDiveonAccumulatedLocalEffectPlotsALEswithPython_4.png\",\n        alt: \"Image\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다음 단계는 샘플 쌍의 두 샘플에 대한 블랙박스 모델 예측을 가져오는 것입니다. 그런 다음 최소 샘플(주황색)의 예측값을 최대 샘플(녹색)의 예측값에서 뺍니다. 이 작업을 모든 샘플 쌍에 대해 수행하고 평균을 계산합니다. 이는 이 간격 내에서 껍질 무게의 변화로 인한 예측에 대한 추정치를 제공합니다. 중요한 점은 살아있는 무게와의 상관관계가 이 추정치를 왜곡시키지 않는다는 것입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-23-DeepDiveonAccumulatedLocalEffectPlotsALEswithPython_5.png\",\n        alt: \"Image\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"좋아요, 이는 특정 간격 내에서의 효과를 제공합니다. 전반적인 추세를 얻으려면 기능 범위 내의 모든 연속적인 간격에 대해 이 작업을 수행하고 개별 효과를 더해야 합니다. 새로운 간격으로 이동할 때마다 효과를 누적 효과에 추가하고 점을 그립니다. 이를 수행하면 껍질 무게에 대한 ALE를 얻을 수 있습니다. 이제 이름의 유래를 확인할 수 있습니다. 간겭(지역) 내에서 기능 효과를 누적하고 있는 것입니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"ALEs를 바라보는 또 다른 방법은 적분 또는 적어도 적분을 근사하는 Riemann 합과 유사하다는 것입니다. 지역 효과는 함수의 변화율 또는 도함수입니다. 효과를 누적함으로써 우리는 블랙 박스 모델 곡선을 찾아갑니다. 간격이 작아질수록 우리는 진정한 곡선에 더 가까워집니다. 안타깝게도 ALE에 대해 우리는 간격을 무한히 작게 만들 수 없습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-23-DeepDiveonAccumulatedLocalEffectPlotsALEswithPython_6.png\",\n        alt: \"image\"\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"형식적인 알고리즘\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"ALE에 대한 수학적 공식이 있습니다. 이번에는 그걸 넘기겠습니다. 그래도 ALE 알고리즘을 좀 더 형식적으로 정의하는 것은 가치가 있습니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-23-DeepDiveonAccumulatedLocalEffectPlotsALEswithPython_7.png\",\n        alt: \"Deep Dive on Accumulated Local Effect Plots with Python\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다양한 구현 방법은 이 알고리즘에 약간의 차이를 줄 수 있습니다. 예를 들어, 제 2 단계에서 간격을 정의하는 방식입니다. 아래 구현은 각 간격에 최소한의 피처가 포함되도록 정의합니다. 또한 각 간격의 너비가 일정한 것으로 정의할 수도 있습니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"Alibi를 사용한 ALE 적용\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"ALE을 적용하기 위해 alibi 패키지를 사용할 것입니다. 이 패키지는 다양한 XAI 방법을 제공합니다. 현재는 ALE 및 plot_ale 함수 (라인 8-9)에 관심이 있습니다. 이 패키지를 적용하고 플롯을 해석하는 방법을 살펴볼 것이며, 여러 ALE을 결합하고 간격 길이를 변경하는 방법에 대해 알아볼 것입니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"#데이터셋 및 모델\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이전에 언급한 전복 데이터 세트에 이 방법을 적용할 것입니다. 데이터 세트를 로드하고 타겟을 선택합니다. 또한 몇 가지 특성 엔지니어링을 진행합니다. 먼저, 직경과 전체 무게를 특성 목록에서 제외합니다. 그 이유는 Figure 1에서 다른 특성들과의 상관 관계가 1임을 확인했기 때문입니다. 마지막으로 성별 특성에 대해 원-핫 인코딩을 생성합니다. 최종 특성 세트의 스냅샷을 Figure 5에서 확인할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"#데이터셋을 가져옵니다\\ndata = pd.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"read_csv\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"../../data/abalone.data\\\"\"\n        }), \",\\n                  names=[\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"sex\\\"\"\n        }), \",\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"length\\\"\"\n        }), \",\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"diameter\\\"\"\n        }), \",\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"height\\\"\"\n        }), \",\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"whole weight\\\"\"\n        }), \",\\n                         \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"shucked weight\\\"\"\n        }), \",\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"viscera weight\\\"\"\n        }), \",\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"shell weight\\\"\"\n        }), \",\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"rings\\\"\"\n        }), \"])\\n\\ny = data[\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"rings\\\"\"\n        }), \"]\\nX = data[[\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"sex\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"length\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"height\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"shucked weight\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"viscera weight\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"shell weight\\\"\"\n        }), \"]]\\n\\n# 더미 변수 생성\\nX[\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'sex.M'\"\n        }), \"] = [\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" s == \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'M'\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"else\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" s \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" X[\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'sex'\"\n        }), \"]]\\nX[\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'sex.F'\"\n        }), \"] = [\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" s == \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'F'\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"else\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" s \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" X[\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'sex'\"\n        }), \"]]\\nX[\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'sex.I'\"\n        }), \"] = [\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" s == \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'I'\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"else\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" s \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" X[\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'sex'\"\n        }), \"]]\\nX = X.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"drop\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'sex'\"\n        }), \", axis=\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \")\\n\\nX.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"head\"\n        }), \"()\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/assets/img/2024-05-23-DeepDiveonAccumulatedLocalEffectPlotsALEswithPython_8.png\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우리는 이러한 특성들을 사용하여 모델을 훈련시켜 반지의 개수를 예측합니다 (lines 2-3). 모델을 훈련할 때 특성 매트릭스를 numpy 배열로 변환합니다. ALEs를 생성할 때 경고 메시지가 표시되지 않도록 하기 위함입니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"# 모델 훈련\\nmodel = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"RandomForestRegressor\"\n        }), \"()\\nmodel.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"fit\"\n        }), \"(X.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"to_numpy\"\n        }), \"(), y)\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"ALE 그래프 그리기\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"ALE 플롯을 생성하려면, 먼저 ale 객체를 생성해야 합니다 (2번째 줄). 이를 위해 모델의 예측 함수 (model.predict), 피처 이름 및 타겟 이름을 전달합니다. 그런 다음 이 객체를 사용하여 X 피처 매트릭스에 대한 설명 (exp)을 생성합니다 (3번째 줄). 설명 함수를 사용하려면 이 매트릭스가 넘파이 배열이어야 합니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"# \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"ALE\"\n        }), \" 설명 가져오기\\nale = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"ALE\"\n        }), \"(model.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"predict\"\n        }), \", feature_names=X.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"columns\"\n        }), \", target_names=[\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'rings'\"\n        }), \"])\\nexp = ale.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"explain\"\n        }), \"(X.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"to_numpy\"\n        }), \"())\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"ALE 플롯을 생성하려면 설명과 표시하려는 피처를 plot_ale에 전달합니다. 위치 배열 [0,1,2]를 사용하면 처음 3개 피처에 대한 ALE를 표시합니다. Figure 6에서 확인할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"# 처음 \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"3\"\n        }), \"개 피처에 대한 \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"ALE\"\n        }), \" 설명 플롯하기\\n\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"plot_ale\"\n        }), \"(exp, features=[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \",\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \",\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"2\"\n        }), \"], fig_kw={\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'figwidth'\"\n        }), \":\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"15\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'figheight'\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"5\"\n        }), \"})\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-23-DeepDiveonAccumulatedLocalEffectPlotsALEswithPython_9.png\",\n        alt: \"image\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"제 6번 그림에서 얻을 수 있는 몇 가지 결론은 다음과 같습니다:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"길이와 높이가 예측된 링 개수에 미치는 영향은 껍질 무게와 비교할 때 낮습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"껍질 무게에 대한 내려가는 선은 껍질 무게가 증가함에 따라 예측된 링 개수가 감소하는 경향을 보입니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"또한 플롯에서 개별 점을 해석할 수도 있지만, 먼저 플롯이 어떻게 중심화되었는지 이해해야 합니다. Figure 7에서 껍질 무게 관계에 초점을 맞추어 봅시다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-23-DeepDiveonAccumulatedLocalEffectPlotsALEswithPython_10.png\",\n        alt: \"그림 7\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"ALE는 0을 중심으로 설정되었습니다. 이것은 각 ALE의 미중심 누적 지역 효과에서 평균을 뺌으로써 수행됩니다. 처음에는 혼란스러울 수 있습니다. ALE의 평균을 찾기 위해서는 먼저 ALE의 각 지점에서 누적 지역 효과를 합산해야 합니다. 결과적으로 ALE의 각 지점은 해당 특징값과 해당 특징의 평균 효과를 비교했을 때의 효과를 나타냅니다. 또는 더 간단히 말하면, 평균 예측과 비교했을 때의 효과입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"따라서, 그림 7의 터플 중량에 대한 플롯을 살펴보면 다음과 같은 결론을 내릴 수 있습니다:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"터플 중량이 0이면 평균 예측 대비 6개의 고리 예측이 증가합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"터플 중량이 1.4인 경우에 비해 0의 터플 중량은 예측이 12개 증가합니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"ALE 결합하기\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그럼 alibi 패키지로 무엇을 더 할 수 있는지 알아보겠습니다. 특징들이 유사한 값을 갖고 있다면, ALE을 동일한 축에 플롯하는 것이 유용할 수 있습니다. 아래에서는 이를 3개의 무게 특징에 대해 수행합니다. 그림 8을 보면, 이러한 특징들의 영향을 비교하는 것이 얼마나 쉬운지 알 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-python\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"# 무게 특징에 대한 ALE 플롯\"\n        }), \"\\nfig, ax = plt.subplots(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \", figsize=(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"8\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"4\"\n        }), \"))\\n\\nplot_ale(exp, features=[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"2\"\n        }), \"], ax=ax, line_kw={\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'label'\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'shucked weight'\"\n        }), \"})\\nplot_ale(exp, features=[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"3\"\n        }), \"], ax=ax, line_kw={\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'label'\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'viscera weight'\"\n        }), \"})\\nplot_ale(exp, features=[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"4\"\n        }), \"], ax=ax, line_kw={\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'label'\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'shell weight'\"\n        }), \"})\\n\\nax.set_xlabel(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'weight'\"\n        }), \")\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"shucked weight와 shell weight가 예측에 상당한 영향을 미치는 것을 알 수 있습니다. 그러나 그들은 반대 방향에 있습니다. 흥미로운 사실입니다! 이러한 특징들은 상호 관련이 높지만 예측과는 서로 다른 관계를 가지고 있습니다. 이는 두 특징 간의 상호 작용 때문입니다 — 이를 알아보기 위해 H-통계를 사용할 수 있습니다(향후 게시될 기사를 기대해주세요).\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-23-DeepDiveonAccumulatedLocalEffectPlotsALEswithPython_11.png\",\n        alt: \"Screenshot\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"여기서 변수 간격이 다른 것을 알 수 있습니다. 이는 패키지가 간격을 선택하는 방식과 관련이 있습니다. 기본적으로 적어도 4개의 인스턴스가 포함된 간격을 선택합니다. 따라서 ALEs에서 끝에서 두 번째와 마지막 포인트 사이에 상대적으로 큰 거리를 볼 수 있습니다. 이러한 가중치 값에 대해 데이터 세트가 희소해지고 적어도 4개의 인스턴스를 포착하기 위해 더 큰 간격이 필요합니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"간격 길이 증가\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"아래 코드에서는 동일한 차트를 만들되 한 가지 주요 차이가 있습니다. 간격 내의 최소 인스턴스 수를 50으로 변경했습니다 (3번째 줄). 이는 min_bin_points 매개변수를 사용하여 수행됩니다. Figure 9에서 볼 수 있듯이 결과는 더 부드러운 ALE 및 큰 간격입니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-python\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"# 간격 조정\"\n        }), \"\\nale = ALE(model.predict, feature_names=X.columns, target_names=[\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'rings'\"\n        }), \"])\\nexp = ale.explain(X.to_numpy(), min_bin_points=\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"50\"\n        }), \")\\n\\nfig, ax = plt.subplots(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \", figsize=(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"8\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"4\"\n        }), \"))\\n\\nplot_ale(exp, features=[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"2\"\n        }), \"], ax=ax, line_kw={\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'label'\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'shucked weight'\"\n        }), \"})\\nplot_ale(exp, features=[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"3\"\n        }), \"], ax=ax, line_kw={\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'label'\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'viscera weight'\"\n        }), \"})\\nplot_ale(exp, features=[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"4\"\n        }), \"], ax=ax, line_kw={\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'label'\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'shell weight'\"\n        }), \"})\\n\\nax.set_xlabel(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'weight'\"\n        }), \")\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-23-DeepDiveonAccumulatedLocalEffectPlotsALEswithPython_12.png\",\n        alt: \"image\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"min_bin_points\"\n      }), \"는 ALE를 만들 때 trade-off를 도입합니다. 이 값을 줄이면 간격의 크기가 줄어듭니다. 이는 곡선의 진정한 모양에 더 가까워질 것입니다. 그러나 이러한 간격 내에서 효과를 추정하는 데 사용할 수 있는 샘플 크기가 줄어들어 불확실성에 직면하게 됩니다. 일반적으로 이 불확실성으로 인해 구간 간 변화보다는 전반적인 추세에 중점을 두어야 합니다.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다른 고려사항은 ALE의 해석은 명료하지만 해당 해석을 얻는 방법을 설명하기는 복잡할 수 있다는 것입니다. PDP가 어떻게 생성되는지 비교할 때 적어도 그렇습니다. 따라서 두 방법을 함께 사용하는 것이 유용합니다. 결과가 일치하면 언제든 PDP를 제시할 수 있습니다. 이렇게 하면 평균 누적 로컬 효과가 무엇인지 설명하는 머리 아픈 작업이 절약될 수 있습니다!\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"만약 PDPs가 어떻게 만들어지는지 알고 싶다면 이 기사를 참조해보세요:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다른 XAI 기사들도 유용하게 사용할 수 있을 거예요:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 기사를 즐겁게 읽으셨으면 좋겠어요! 무료로 파이썬 XAI 코스에 접근할 수 있는 Threads | YouTube | Newsletter에서 저를 찾아보세요\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"참고문헌\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"[1] Daniel W Apley 및 Jingyu Zhu. 블랙 박스 지도 학습 모델에서 예측 변수의 효과를 시각화하는 방법. Journal of the Royal Statistical Society Series B: Statistical Methodology, 82(4):1059–1086, 2020.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-23-DeepDiveonAccumulatedLocalEffectPlotsALEswithPython"},"buildId":"R1x9p1CQYDDJESXyLXKOK","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>