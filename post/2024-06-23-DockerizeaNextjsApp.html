<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Nextjs 앱을 Dockerize하는 방법 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-06-23-DockerizeaNextjsApp" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Nextjs 앱을 Dockerize하는 방법 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="Nextjs 앱을 Dockerize하는 방법 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-23-DockerizeaNextjsApp_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-06-23-DockerizeaNextjsApp" data-gatsby-head="true"/><meta name="twitter:title" content="Nextjs 앱을 Dockerize하는 방법 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-23-DockerizeaNextjsApp_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-23 00:47" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-4f7b40c1114f0d09.js" defer=""></script><script src="/_next/static/-dPCbnM2yhdKNgXe92VJV/_buildManifest.js" defer=""></script><script src="/_next/static/-dPCbnM2yhdKNgXe92VJV/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Nextjs 앱을 Dockerize하는 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Nextjs 앱을 Dockerize하는 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 23, 2024</span><span class="posts_reading_time__f7YPP">10<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-23-DockerizeaNextjsApp&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>만약 Vercel에 Next.js 앱을 배포하고 싶다면, 이 경우에는 컨테이너가 필요하지 않습니다. Next.js는 Vercel에서 만들어지고 유지보수되기 때문에 배포가 쉽게 가능합니다. 그러나 AWS, Google Cloud Run 또는 다른 클라우드 공급업체를 통해 앱을 실행하려는 경우에는 컨테이너가 필요합니다.</p>
<p>온라인에서 찾은 대부분의 기사들은 Node.js 앱을 도커라이즈하는 방법을 설명하지만, Next.js 앱에 초점을 많이 두지 않았습니다. 해결책들은 있지만, 그 해결책들은 몇 가지 오류를 발생시켜 몇 시간이 걸렸습니다. 그래서 제가 그것을 어떻게 했는지, 부딪힌 문제점들, 그리고 그에 대한 제 해결책을 공유하려고 합니다.</p>
<h1>시작하기!</h1>
<p>가지고 계신 Next.js 프로젝트 중 하나를 사용하거나, 공식 Vercel에서 제공하는 예제 중 하나를 클론해 시작하세요. 온라인에서 찾은 다른 해결책들은 애플리케이션을 독립 실행형 애플리케이션으로 빌드하기 위해 next.config.js에 다음 라인들을 추가하는 것이 필수적이라고 제안했지만, 그것을 추가하지 않고도 모든 것이 잘 작동하는 것을 발견했습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> nextConfig = {
  <span class="hljs-attr">output</span>: <span class="hljs-string">"standalone"</span>, <span class="hljs-comment">// 이 줄이 없어도 잘 작동했다.</span>
  <span class="hljs-comment">// ... 다른 설정</span>
};
</code></pre>
<h2>DockerFile</h2>
<p>루트 저장소에 동일한 이름을 가진 Dockerfile을 추가하세요. 이 파일에는 빌드할 도커 이미지에 대한 명령을 추가할 것입니다.</p>
<p>제가 만든 두 가지 버전의 Dockerfile을 공유하겠습니다. 하나는 개발 단계/서버 테스트용으로 확실하고 기본적인 단일 단계 버전이며, 다른 하나는 개발 및 프로덕션 모두에 사용할 수 있는 docker-compose.yml과 함께 다중 단계 버전입니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>단계별 DockerFile</p>
<p>아래는 파일이 어떻게 생겼는지를 보여주고, 한 줄씩 내가 한 작업을 설명하겠어.</p>
<pre><code class="hljs language-js"><span class="hljs-variable constant_">FROM</span> <span class="hljs-attr">node</span>:<span class="hljs-number">18</span>

<span class="hljs-variable constant_">WORKDIR</span> /app
<span class="hljs-variable constant_">COPY</span> package*.<span class="hljs-property">json</span> ./
<span class="hljs-variable constant_">RUN</span> npm install
<span class="hljs-variable constant_">COPY</span> . .
<span class="hljs-variable constant_">EXPOSE</span> <span class="hljs-number">3000</span>
<span class="hljs-variable constant_">CMD</span> npm run dev
</code></pre>
<p>먼저, Docker에 공식 Docker Node 이미지 버전 18을 사용하도록 From node:18을 통해 설정한다. FROM 뒤에 오는 내용을 변경하여 사용하고 싶은 이미지로 변경할 수 있다. 지원되는 목록은 여기에서 확인할 수 있다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>WORKDIR은 이후 명령의 컨텍스트를 설정합니다. 이름은 원하는 대로 지정할 수 있어요. 저는 제 앱을 app이라고 부르겠습니다. 그리고 package.json과 package-lock.json 파일을 컨테이너로 복사한 다음 npm install을 실행하여 모든 종속성을 설치합니다.</p>
<p>그 다음, 프로젝트의 모든 코드(현재 루트 디렉토리)를 WORKDIR로 복사합니다. 제 경우에는 /app이에요.</p>
<p>Expose 3000은 컨테이너에게 앱이 3000 포트에서 실행된다는 것을 알려줍니다.</p>
<p>모든 설정을 끝낸 후에는 CMD npm run dev로 컨테이너에게 개발 서버를 시작하도록 요청합니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이제 Dockerfile로 작업을 마쳤습니다!!</p>
<p>우리가 방금 만든 Dockerfile로부터 Docker 이미지를 빌드하려면, 다음 명령어를 실행하세요. 저는 이를 my-app이라고 이름 지었지만, 원하는 대로 변경해도 상관없습니다. 마지막에 .을 꼭 입력하지 않도록 주의해주세요.</p>
<pre><code class="hljs language-js">docker build -t my-app .
</code></pre>
<p>이미지가 생성되면, 다음과 같이 실행할 수 있습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js">도커 런 -p <span class="hljs-number">3000</span>:<span class="hljs-number">3000</span> my-app
</code></pre>
<p>3000:3000은 앱을 실행할 포트를 지정하는 것이에요. 저는 3000번 포트에서 실행할 거예요. 그리고 <a href="http://localhost:3000" rel="nofollow" target="_blank">http://localhost:3000</a> 에 접속하면 작동 중인 앱을 볼 수 있어요!</p>
<p>다중 단계 DockerFile</p>
<p>이제 다중 단계 Dockerfile을 만들어서 더 빠르고 효율적인 빌드를 할 수 있게 하고, 운영 환경과 개발 환경을 쉽게 전환할 수 있게 될 거예요.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>도커 파일에 있는 내용을 모두 삭제하고 다음 내용으로 대체해주세요.</p>
<pre><code class="hljs language-js"><span class="hljs-variable constant_">FROM</span> <span class="hljs-attr">node</span>:<span class="hljs-number">18</span>-alpine <span class="hljs-keyword">as</span> base
<span class="hljs-variable constant_">RUN</span> apk add --no-cache g++ make py3-pip libc6-compat
<span class="hljs-variable constant_">WORKDIR</span> /app
<span class="hljs-variable constant_">COPY</span> package*.<span class="hljs-property">json</span> ./
<span class="hljs-variable constant_">EXPOSE</span> <span class="hljs-number">3000</span>

<span class="hljs-variable constant_">FROM</span> base <span class="hljs-keyword">as</span> builder
<span class="hljs-variable constant_">WORKDIR</span> /app
<span class="hljs-variable constant_">COPY</span> . .
<span class="hljs-variable constant_">RUN</span> npm run build


<span class="hljs-variable constant_">FROM</span> base <span class="hljs-keyword">as</span> production
<span class="hljs-variable constant_">WORKDIR</span> /app

<span class="hljs-variable constant_">ENV</span> <span class="hljs-variable constant_">NODE_ENV</span>=production
<span class="hljs-variable constant_">RUN</span> npm ci

<span class="hljs-variable constant_">RUN</span> addgroup -g <span class="hljs-number">1001</span> -S nodejs
<span class="hljs-variable constant_">RUN</span> adduser -S nextjs -u <span class="hljs-number">1001</span>
<span class="hljs-variable constant_">USER</span> nextjs


<span class="hljs-variable constant_">COPY</span> --<span class="hljs-keyword">from</span>=builder --chown=<span class="hljs-attr">nextjs</span>:nodejs /app/.<span class="hljs-property">next</span> ./.<span class="hljs-property">next</span>
<span class="hljs-variable constant_">COPY</span> --<span class="hljs-keyword">from</span>=builder /app/node_modules ./node_modules
<span class="hljs-variable constant_">COPY</span> --<span class="hljs-keyword">from</span>=builder /app/package.<span class="hljs-property">json</span> ./package.<span class="hljs-property">json</span>
<span class="hljs-variable constant_">COPY</span> --<span class="hljs-keyword">from</span>=builder /app/public ./public

<span class="hljs-variable constant_">CMD</span> npm start

<span class="hljs-variable constant_">FROM</span> base <span class="hljs-keyword">as</span> dev
<span class="hljs-variable constant_">ENV</span> <span class="hljs-variable constant_">NODE_ENV</span>=development
<span class="hljs-variable constant_">RUN</span> npm install
<span class="hljs-variable constant_">COPY</span> . .
<span class="hljs-variable constant_">CMD</span> npm run dev
</code></pre>
<p>이 경우 node:18-alpine를 사용하겠습니다. 이것은 기본 이미지보다 훨씬 작습니다. -alpine를 사용하려면 모든 다른 것보다 먼저 파이썬을 설치해야 합니다. 그래서 그 추가 명령(RUN apk add — no-cache g++ make py3-pip libc6-compat)이 있는 것입니다. 공통 설정을 base 단계에 넣어서 나중에 다른 단계에서 재사용할 수 있도록 했습니다. 원하는 경우 단계 이름을 변경하여 as 다음에 오는 내용을 변경할 수 있습니다.</p>
<p>빌더 단계는 사실상 npm run build를 담당합니다. 이 단계는 production 단계에서 이미 존재하지 않은 경우 COPY — from=builder를 시도할 때 호출됩니다. 보세요? 다중 단계 Dockerfile이 유용한 점이 여기에 있습니다. 빌더 단계는 필요할 때만 호출됩니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>저희는 프로덕션 단계에서 NODE_ENV를 production으로 설정하고, 이렇게 하면 성능이 세 배 향상된다고 합니다. 그 다음으로, npm ci를 실행합니다. 이것은 npm install 대신에 지속적인 통합을 위해 사용됩니다.</p>
<p>그 후, 보안상의 이유로 앱을 실행할 비루트 사용자를 추가합니다. 제가 게으른 터라 사용자를 nextjs로 그룹을 nodejs로 설정했습니다.</p>
<p>그 후에, 빌더 단계에서 필요한 에셋을 COPY — from=builder를 통해 복사합니다.</p>
<p>마지막으로, npm start를 호출하여 어플리케이션을 시작합니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>개발 스테이지에서는 싱글 스테이지 Dockerfile에서 한 것과 기본적으로 똑같은 작업을 하고 있기 때문에 넘어가도록 할게요.</p>
<p>docker-compose.yml을 생성하기 전에 Dockerfile이 실제로 빌드되는지 확인하고 싶다면 docker build -t my-app . 및 docker run -p 3000:3000 my-app를 실행할 수 있어요. 테스트하고 싶은 스테이지를 주석 처리하는 것을 잊지 마세요. 예를 들어, 프로덕션 스테이지가 성공적으로 빌드되고 실행되는지 확인하려면 FROM base로 시작하는 부분 이후에 오는 모든 것을 주석 처리해주세요.</p>
<h2>Docker Compose</h2>
<p>Docker Compose를 사용하면 긴 명령어를 기억할 필요가 없어요. docker-compose build 및 docker-compose up 명령어를 간편하게 사용할 수 있어요.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>루트 디렉토리에 다음 내용을 가진 docker-compose.yml 파일을 추가해주세요.</p>
<pre><code class="hljs language-js"><span class="hljs-attr">version</span>: <span class="hljs-string">'3.8'</span>
<span class="hljs-attr">services</span>:
  <span class="hljs-attr">app</span>:
    <span class="hljs-attr">image</span>: openai-demo-app
    <span class="hljs-attr">build</span>:
      <span class="hljs-attr">context</span>: ./
      <span class="hljs-attr">target</span>: dev
      <span class="hljs-attr">dockerfile</span>: <span class="hljs-title class_">Dockerfile</span>
    <span class="hljs-attr">volumes</span>:
        - .:/app
        - <span class="hljs-regexp">/app/</span>node_modules
        - <span class="hljs-regexp">/app/</span>.<span class="hljs-property">next</span>
    <span class="hljs-attr">ports</span>:
      - <span class="hljs-string">"3000:3000"</span>
</code></pre>
<p>여기서 <code>3.8</code> 버전은 사용할 Docker Compose 버전을 지정합니다. 이 경우에는 한 개의 서비스인 app을 가지고 있지만, 필요에 따라 더 추가할 수 있습니다.</p>
<p>Build context는 현재 디렉토리를 지정하며, target은 Docker 이미지를 빌드할 단계를 지정합니다. 프로덕션에서 실행하려면 단순히 target:production으로 설정하시면 됩니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>Volume은 호스트의 ./ 로컬 디렉토리의 내용을 Docker 컨테이너의 /app 디렉토리로 복사하도록 지시합니다.</p>
<p>마지막으로, 호스트 머신의 포트 3000을 컨테이너의 포트 3000으로 매핑합니다. 우리는 컨테이너를 빌드할 때 포트 3000을 노출했으며, 우리의 앱도 3000 포트에서 실행될 것입니다.</p>
<h2>Docker Compose로 테스트하기</h2>
<p>마침내 Docker 이미지를 빌드하는 과정에 도달했습니다. 더 빠른 빌드를 위해 Docker의 BuildKit 기능을 사용할 것입니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js"><span class="hljs-variable constant_">COMPOSE_DOCKER_CLI_BUILD</span>=<span class="hljs-number">1</span> <span class="hljs-variable constant_">DOCKER_BUILDKIT</span>=<span class="hljs-number">1</span> docker-compose build
</code></pre>
<p>빌드가 완료되면 이미지를 실행하여 앱을 시작할 수 있어요.</p>
<pre><code class="hljs language-js">docker-compose up
</code></pre>
<p>그 다음에 브라우저에서 <a href="http://localhost:3000" rel="nofollow" target="_blank">http://localhost:3000</a> 로 이동하면 앱이 실행 중인 것을 볼 수 있어요!!!</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>그게 다야!</p>
<p>아래에는 몇 가지 문제가 있었어요. 내 Docker 컨테이너가 작동하지 않거나 문제의 원인을 찾고 싶다면 고생 중일 수도 있으니 빠르게 공유할게요.</p>
<h1>내가 겪은 문제들</h1>
<ul>
<li>Python이 명령줄이나 npm 구성에서 설정되지 않았습니다: (맥 사용자로서) python을 경로에 추가하거나 python을 python3로 별칭 지정, python 삭제 및 다시 설치 등 많은 시도를 해보았지만 어떤 것도 제겐 도움이 되지 않았어요. 그래서 제가 찾아낸 두 가지 해결책을 여기에 소개할게요. (1) node:18(또는 기호하는 다른 버전) 대신 node:18-alpine을 사용하세요. (2) 패키지 설치 전에 RUN apk add --no-cache g++ make py3-pip libc6-compat 를 추가하세요.</li>
<li>Docker-compose up을 사용할 때 '/app/.next' 디렉토리에서 프로덕션 빌드를 찾을 수 없음: docker run을 통해 이미지를 실행했을 때는 모든 것이 예상대로 작동했습니다. 해결 방법은 Dockerfile에서 CMD npm start 앞에 CMD ["npm","run","build"]를 추가하는 것을 제안하는 솔루션이 있지만, 이렇게 하면 두 개의 CMD를 허용하지 않는 오류가 발생했어요. 제 해결책은 Docker-compose.yml의 volumes에 — /app/.next를 추가하는 것이었습니다.</li>
</ul>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>오늘은 여기까지입니다!</p>
<p>읽어 주셔서 감사합니다! 이 팁들이 도움이 되길 바랍니다!</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Nextjs 앱을 Dockerize하는 방법","description":"","date":"2024-06-23 00:47","slug":"2024-06-23-DockerizeaNextjsApp","content":"\n만약 Vercel에 Next.js 앱을 배포하고 싶다면, 이 경우에는 컨테이너가 필요하지 않습니다. Next.js는 Vercel에서 만들어지고 유지보수되기 때문에 배포가 쉽게 가능합니다. 그러나 AWS, Google Cloud Run 또는 다른 클라우드 공급업체를 통해 앱을 실행하려는 경우에는 컨테이너가 필요합니다.\n\n온라인에서 찾은 대부분의 기사들은 Node.js 앱을 도커라이즈하는 방법을 설명하지만, Next.js 앱에 초점을 많이 두지 않았습니다. 해결책들은 있지만, 그 해결책들은 몇 가지 오류를 발생시켜 몇 시간이 걸렸습니다. 그래서 제가 그것을 어떻게 했는지, 부딪힌 문제점들, 그리고 그에 대한 제 해결책을 공유하려고 합니다.\n\n# 시작하기!\n\n가지고 계신 Next.js 프로젝트 중 하나를 사용하거나, 공식 Vercel에서 제공하는 예제 중 하나를 클론해 시작하세요. 온라인에서 찾은 다른 해결책들은 애플리케이션을 독립 실행형 애플리케이션으로 빌드하기 위해 next.config.js에 다음 라인들을 추가하는 것이 필수적이라고 제안했지만, 그것을 추가하지 않고도 모든 것이 잘 작동하는 것을 발견했습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nconst nextConfig = {\n  output: \"standalone\", // 이 줄이 없어도 잘 작동했다.\n  // ... 다른 설정\n};\n```\n\n## DockerFile\n\n루트 저장소에 동일한 이름을 가진 Dockerfile을 추가하세요. 이 파일에는 빌드할 도커 이미지에 대한 명령을 추가할 것입니다.\n\n제가 만든 두 가지 버전의 Dockerfile을 공유하겠습니다. 하나는 개발 단계/서버 테스트용으로 확실하고 기본적인 단일 단계 버전이며, 다른 하나는 개발 및 프로덕션 모두에 사용할 수 있는 docker-compose.yml과 함께 다중 단계 버전입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n단계별 DockerFile\n\n아래는 파일이 어떻게 생겼는지를 보여주고, 한 줄씩 내가 한 작업을 설명하겠어.\n\n```js\nFROM node:18\n\nWORKDIR /app\nCOPY package*.json ./\nRUN npm install\nCOPY . .\nEXPOSE 3000\nCMD npm run dev\n```\n\n먼저, Docker에 공식 Docker Node 이미지 버전 18을 사용하도록 From node:18을 통해 설정한다. FROM 뒤에 오는 내용을 변경하여 사용하고 싶은 이미지로 변경할 수 있다. 지원되는 목록은 여기에서 확인할 수 있다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nWORKDIR은 이후 명령의 컨텍스트를 설정합니다. 이름은 원하는 대로 지정할 수 있어요. 저는 제 앱을 app이라고 부르겠습니다. 그리고 package.json과 package-lock.json 파일을 컨테이너로 복사한 다음 npm install을 실행하여 모든 종속성을 설치합니다.\n\n그 다음, 프로젝트의 모든 코드(현재 루트 디렉토리)를 WORKDIR로 복사합니다. 제 경우에는 /app이에요.\n\nExpose 3000은 컨테이너에게 앱이 3000 포트에서 실행된다는 것을 알려줍니다.\n\n모든 설정을 끝낸 후에는 CMD npm run dev로 컨테이너에게 개발 서버를 시작하도록 요청합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 Dockerfile로 작업을 마쳤습니다!!\n\n우리가 방금 만든 Dockerfile로부터 Docker 이미지를 빌드하려면, 다음 명령어를 실행하세요. 저는 이를 my-app이라고 이름 지었지만, 원하는 대로 변경해도 상관없습니다. 마지막에 .을 꼭 입력하지 않도록 주의해주세요.\n\n```js\ndocker build -t my-app .\n```\n\n이미지가 생성되면, 다음과 같이 실행할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n도커 런 -p 3000:3000 my-app\n```\n\n3000:3000은 앱을 실행할 포트를 지정하는 것이에요. 저는 3000번 포트에서 실행할 거예요. 그리고 http://localhost:3000 에 접속하면 작동 중인 앱을 볼 수 있어요!\n\n다중 단계 DockerFile\n\n이제 다중 단계 Dockerfile을 만들어서 더 빠르고 효율적인 빌드를 할 수 있게 하고, 운영 환경과 개발 환경을 쉽게 전환할 수 있게 될 거예요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n도커 파일에 있는 내용을 모두 삭제하고 다음 내용으로 대체해주세요.\n\n```js\nFROM node:18-alpine as base\nRUN apk add --no-cache g++ make py3-pip libc6-compat\nWORKDIR /app\nCOPY package*.json ./\nEXPOSE 3000\n\nFROM base as builder\nWORKDIR /app\nCOPY . .\nRUN npm run build\n\n\nFROM base as production\nWORKDIR /app\n\nENV NODE_ENV=production\nRUN npm ci\n\nRUN addgroup -g 1001 -S nodejs\nRUN adduser -S nextjs -u 1001\nUSER nextjs\n\n\nCOPY --from=builder --chown=nextjs:nodejs /app/.next ./.next\nCOPY --from=builder /app/node_modules ./node_modules\nCOPY --from=builder /app/package.json ./package.json\nCOPY --from=builder /app/public ./public\n\nCMD npm start\n\nFROM base as dev\nENV NODE_ENV=development\nRUN npm install\nCOPY . .\nCMD npm run dev\n```\n\n이 경우 node:18-alpine를 사용하겠습니다. 이것은 기본 이미지보다 훨씬 작습니다. -alpine를 사용하려면 모든 다른 것보다 먼저 파이썬을 설치해야 합니다. 그래서 그 추가 명령(RUN apk add — no-cache g++ make py3-pip libc6-compat)이 있는 것입니다. 공통 설정을 base 단계에 넣어서 나중에 다른 단계에서 재사용할 수 있도록 했습니다. 원하는 경우 단계 이름을 변경하여 as 다음에 오는 내용을 변경할 수 있습니다.\n\n빌더 단계는 사실상 npm run build를 담당합니다. 이 단계는 production 단계에서 이미 존재하지 않은 경우 COPY — from=builder를 시도할 때 호출됩니다. 보세요? 다중 단계 Dockerfile이 유용한 점이 여기에 있습니다. 빌더 단계는 필요할 때만 호출됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n저희는 프로덕션 단계에서 NODE_ENV를 production으로 설정하고, 이렇게 하면 성능이 세 배 향상된다고 합니다. 그 다음으로, npm ci를 실행합니다. 이것은 npm install 대신에 지속적인 통합을 위해 사용됩니다.\n\n그 후, 보안상의 이유로 앱을 실행할 비루트 사용자를 추가합니다. 제가 게으른 터라 사용자를 nextjs로 그룹을 nodejs로 설정했습니다.\n\n그 후에, 빌더 단계에서 필요한 에셋을 COPY — from=builder를 통해 복사합니다.\n\n마지막으로, npm start를 호출하여 어플리케이션을 시작합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n개발 스테이지에서는 싱글 스테이지 Dockerfile에서 한 것과 기본적으로 똑같은 작업을 하고 있기 때문에 넘어가도록 할게요.\n\ndocker-compose.yml을 생성하기 전에 Dockerfile이 실제로 빌드되는지 확인하고 싶다면 docker build -t my-app . 및 docker run -p 3000:3000 my-app를 실행할 수 있어요. 테스트하고 싶은 스테이지를 주석 처리하는 것을 잊지 마세요. 예를 들어, 프로덕션 스테이지가 성공적으로 빌드되고 실행되는지 확인하려면 FROM base로 시작하는 부분 이후에 오는 모든 것을 주석 처리해주세요.\n\n## Docker Compose\n\nDocker Compose를 사용하면 긴 명령어를 기억할 필요가 없어요. docker-compose build 및 docker-compose up 명령어를 간편하게 사용할 수 있어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n루트 디렉토리에 다음 내용을 가진 docker-compose.yml 파일을 추가해주세요.\n\n```js\nversion: '3.8'\nservices:\n  app:\n    image: openai-demo-app\n    build:\n      context: ./\n      target: dev\n      dockerfile: Dockerfile\n    volumes:\n        - .:/app\n        - /app/node_modules\n        - /app/.next\n    ports:\n      - \"3000:3000\"\n```\n\n여기서 `3.8` 버전은 사용할 Docker Compose 버전을 지정합니다. 이 경우에는 한 개의 서비스인 app을 가지고 있지만, 필요에 따라 더 추가할 수 있습니다.\n\nBuild context는 현재 디렉토리를 지정하며, target은 Docker 이미지를 빌드할 단계를 지정합니다. 프로덕션에서 실행하려면 단순히 target:production으로 설정하시면 됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nVolume은 호스트의 ./ 로컬 디렉토리의 내용을 Docker 컨테이너의 /app 디렉토리로 복사하도록 지시합니다.\n\n마지막으로, 호스트 머신의 포트 3000을 컨테이너의 포트 3000으로 매핑합니다. 우리는 컨테이너를 빌드할 때 포트 3000을 노출했으며, 우리의 앱도 3000 포트에서 실행될 것입니다.\n\n## Docker Compose로 테스트하기\n\n마침내 Docker 이미지를 빌드하는 과정에 도달했습니다. 더 빠른 빌드를 위해 Docker의 BuildKit 기능을 사용할 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nCOMPOSE_DOCKER_CLI_BUILD=1 DOCKER_BUILDKIT=1 docker-compose build\n```\n\n빌드가 완료되면 이미지를 실행하여 앱을 시작할 수 있어요.\n\n```js\ndocker-compose up\n```\n\n그 다음에 브라우저에서 http://localhost:3000 로 이동하면 앱이 실행 중인 것을 볼 수 있어요!!!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그게 다야!\n\n아래에는 몇 가지 문제가 있었어요. 내 Docker 컨테이너가 작동하지 않거나 문제의 원인을 찾고 싶다면 고생 중일 수도 있으니 빠르게 공유할게요.\n\n# 내가 겪은 문제들\n\n- Python이 명령줄이나 npm 구성에서 설정되지 않았습니다: (맥 사용자로서) python을 경로에 추가하거나 python을 python3로 별칭 지정, python 삭제 및 다시 설치 등 많은 시도를 해보았지만 어떤 것도 제겐 도움이 되지 않았어요. 그래서 제가 찾아낸 두 가지 해결책을 여기에 소개할게요. (1) node:18(또는 기호하는 다른 버전) 대신 node:18-alpine을 사용하세요. (2) 패키지 설치 전에 RUN apk add --no-cache g++ make py3-pip libc6-compat 를 추가하세요.\n- Docker-compose up을 사용할 때 '/app/.next' 디렉토리에서 프로덕션 빌드를 찾을 수 없음: docker run을 통해 이미지를 실행했을 때는 모든 것이 예상대로 작동했습니다. 해결 방법은 Dockerfile에서 CMD npm start 앞에 CMD [\"npm\",\"run\",\"build\"]를 추가하는 것을 제안하는 솔루션이 있지만, 이렇게 하면 두 개의 CMD를 허용하지 않는 오류가 발생했어요. 제 해결책은 Docker-compose.yml의 volumes에 — /app/.next를 추가하는 것이었습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n오늘은 여기까지입니다!\n\n읽어 주셔서 감사합니다! 이 팁들이 도움이 되길 바랍니다!\n","ogImage":{"url":"/assets/img/2024-06-23-DockerizeaNextjsApp_0.png"},"coverImage":"/assets/img/2024-06-23-DockerizeaNextjsApp_0.png","tag":["Tech"],"readingTime":10},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e만약 Vercel에 Next.js 앱을 배포하고 싶다면, 이 경우에는 컨테이너가 필요하지 않습니다. Next.js는 Vercel에서 만들어지고 유지보수되기 때문에 배포가 쉽게 가능합니다. 그러나 AWS, Google Cloud Run 또는 다른 클라우드 공급업체를 통해 앱을 실행하려는 경우에는 컨테이너가 필요합니다.\u003c/p\u003e\n\u003cp\u003e온라인에서 찾은 대부분의 기사들은 Node.js 앱을 도커라이즈하는 방법을 설명하지만, Next.js 앱에 초점을 많이 두지 않았습니다. 해결책들은 있지만, 그 해결책들은 몇 가지 오류를 발생시켜 몇 시간이 걸렸습니다. 그래서 제가 그것을 어떻게 했는지, 부딪힌 문제점들, 그리고 그에 대한 제 해결책을 공유하려고 합니다.\u003c/p\u003e\n\u003ch1\u003e시작하기!\u003c/h1\u003e\n\u003cp\u003e가지고 계신 Next.js 프로젝트 중 하나를 사용하거나, 공식 Vercel에서 제공하는 예제 중 하나를 클론해 시작하세요. 온라인에서 찾은 다른 해결책들은 애플리케이션을 독립 실행형 애플리케이션으로 빌드하기 위해 next.config.js에 다음 라인들을 추가하는 것이 필수적이라고 제안했지만, 그것을 추가하지 않고도 모든 것이 잘 작동하는 것을 발견했습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e nextConfig = {\n  \u003cspan class=\"hljs-attr\"\u003eoutput\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"standalone\"\u003c/span\u003e, \u003cspan class=\"hljs-comment\"\u003e// 이 줄이 없어도 잘 작동했다.\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// ... 다른 설정\u003c/span\u003e\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eDockerFile\u003c/h2\u003e\n\u003cp\u003e루트 저장소에 동일한 이름을 가진 Dockerfile을 추가하세요. 이 파일에는 빌드할 도커 이미지에 대한 명령을 추가할 것입니다.\u003c/p\u003e\n\u003cp\u003e제가 만든 두 가지 버전의 Dockerfile을 공유하겠습니다. 하나는 개발 단계/서버 테스트용으로 확실하고 기본적인 단일 단계 버전이며, 다른 하나는 개발 및 프로덕션 모두에 사용할 수 있는 docker-compose.yml과 함께 다중 단계 버전입니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e단계별 DockerFile\u003c/p\u003e\n\u003cp\u003e아래는 파일이 어떻게 생겼는지를 보여주고, 한 줄씩 내가 한 작업을 설명하겠어.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003enode\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e18\u003c/span\u003e\n\n\u003cspan class=\"hljs-variable constant_\"\u003eWORKDIR\u003c/span\u003e /app\n\u003cspan class=\"hljs-variable constant_\"\u003eCOPY\u003c/span\u003e package*.\u003cspan class=\"hljs-property\"\u003ejson\u003c/span\u003e ./\n\u003cspan class=\"hljs-variable constant_\"\u003eRUN\u003c/span\u003e npm install\n\u003cspan class=\"hljs-variable constant_\"\u003eCOPY\u003c/span\u003e . .\n\u003cspan class=\"hljs-variable constant_\"\u003eEXPOSE\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e3000\u003c/span\u003e\n\u003cspan class=\"hljs-variable constant_\"\u003eCMD\u003c/span\u003e npm run dev\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e먼저, Docker에 공식 Docker Node 이미지 버전 18을 사용하도록 From node:18을 통해 설정한다. FROM 뒤에 오는 내용을 변경하여 사용하고 싶은 이미지로 변경할 수 있다. 지원되는 목록은 여기에서 확인할 수 있다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eWORKDIR은 이후 명령의 컨텍스트를 설정합니다. 이름은 원하는 대로 지정할 수 있어요. 저는 제 앱을 app이라고 부르겠습니다. 그리고 package.json과 package-lock.json 파일을 컨테이너로 복사한 다음 npm install을 실행하여 모든 종속성을 설치합니다.\u003c/p\u003e\n\u003cp\u003e그 다음, 프로젝트의 모든 코드(현재 루트 디렉토리)를 WORKDIR로 복사합니다. 제 경우에는 /app이에요.\u003c/p\u003e\n\u003cp\u003eExpose 3000은 컨테이너에게 앱이 3000 포트에서 실행된다는 것을 알려줍니다.\u003c/p\u003e\n\u003cp\u003e모든 설정을 끝낸 후에는 CMD npm run dev로 컨테이너에게 개발 서버를 시작하도록 요청합니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이제 Dockerfile로 작업을 마쳤습니다!!\u003c/p\u003e\n\u003cp\u003e우리가 방금 만든 Dockerfile로부터 Docker 이미지를 빌드하려면, 다음 명령어를 실행하세요. 저는 이를 my-app이라고 이름 지었지만, 원하는 대로 변경해도 상관없습니다. 마지막에 .을 꼭 입력하지 않도록 주의해주세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edocker build -t my-app .\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이미지가 생성되면, 다음과 같이 실행할 수 있습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e도커 런 -p \u003cspan class=\"hljs-number\"\u003e3000\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e3000\u003c/span\u003e my-app\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e3000:3000은 앱을 실행할 포트를 지정하는 것이에요. 저는 3000번 포트에서 실행할 거예요. 그리고 \u003ca href=\"http://localhost:3000\" rel=\"nofollow\" target=\"_blank\"\u003ehttp://localhost:3000\u003c/a\u003e 에 접속하면 작동 중인 앱을 볼 수 있어요!\u003c/p\u003e\n\u003cp\u003e다중 단계 DockerFile\u003c/p\u003e\n\u003cp\u003e이제 다중 단계 Dockerfile을 만들어서 더 빠르고 효율적인 빌드를 할 수 있게 하고, 운영 환경과 개발 환경을 쉽게 전환할 수 있게 될 거예요.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e도커 파일에 있는 내용을 모두 삭제하고 다음 내용으로 대체해주세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003enode\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e18\u003c/span\u003e-alpine \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e base\n\u003cspan class=\"hljs-variable constant_\"\u003eRUN\u003c/span\u003e apk add --no-cache g++ make py3-pip libc6-compat\n\u003cspan class=\"hljs-variable constant_\"\u003eWORKDIR\u003c/span\u003e /app\n\u003cspan class=\"hljs-variable constant_\"\u003eCOPY\u003c/span\u003e package*.\u003cspan class=\"hljs-property\"\u003ejson\u003c/span\u003e ./\n\u003cspan class=\"hljs-variable constant_\"\u003eEXPOSE\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e3000\u003c/span\u003e\n\n\u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e base \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e builder\n\u003cspan class=\"hljs-variable constant_\"\u003eWORKDIR\u003c/span\u003e /app\n\u003cspan class=\"hljs-variable constant_\"\u003eCOPY\u003c/span\u003e . .\n\u003cspan class=\"hljs-variable constant_\"\u003eRUN\u003c/span\u003e npm run build\n\n\n\u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e base \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e production\n\u003cspan class=\"hljs-variable constant_\"\u003eWORKDIR\u003c/span\u003e /app\n\n\u003cspan class=\"hljs-variable constant_\"\u003eENV\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eNODE_ENV\u003c/span\u003e=production\n\u003cspan class=\"hljs-variable constant_\"\u003eRUN\u003c/span\u003e npm ci\n\n\u003cspan class=\"hljs-variable constant_\"\u003eRUN\u003c/span\u003e addgroup -g \u003cspan class=\"hljs-number\"\u003e1001\u003c/span\u003e -S nodejs\n\u003cspan class=\"hljs-variable constant_\"\u003eRUN\u003c/span\u003e adduser -S nextjs -u \u003cspan class=\"hljs-number\"\u003e1001\u003c/span\u003e\n\u003cspan class=\"hljs-variable constant_\"\u003eUSER\u003c/span\u003e nextjs\n\n\n\u003cspan class=\"hljs-variable constant_\"\u003eCOPY\u003c/span\u003e --\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e=builder --chown=\u003cspan class=\"hljs-attr\"\u003enextjs\u003c/span\u003e:nodejs /app/.\u003cspan class=\"hljs-property\"\u003enext\u003c/span\u003e ./.\u003cspan class=\"hljs-property\"\u003enext\u003c/span\u003e\n\u003cspan class=\"hljs-variable constant_\"\u003eCOPY\u003c/span\u003e --\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e=builder /app/node_modules ./node_modules\n\u003cspan class=\"hljs-variable constant_\"\u003eCOPY\u003c/span\u003e --\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e=builder /app/package.\u003cspan class=\"hljs-property\"\u003ejson\u003c/span\u003e ./package.\u003cspan class=\"hljs-property\"\u003ejson\u003c/span\u003e\n\u003cspan class=\"hljs-variable constant_\"\u003eCOPY\u003c/span\u003e --\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e=builder /app/public ./public\n\n\u003cspan class=\"hljs-variable constant_\"\u003eCMD\u003c/span\u003e npm start\n\n\u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e base \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e dev\n\u003cspan class=\"hljs-variable constant_\"\u003eENV\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eNODE_ENV\u003c/span\u003e=development\n\u003cspan class=\"hljs-variable constant_\"\u003eRUN\u003c/span\u003e npm install\n\u003cspan class=\"hljs-variable constant_\"\u003eCOPY\u003c/span\u003e . .\n\u003cspan class=\"hljs-variable constant_\"\u003eCMD\u003c/span\u003e npm run dev\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 경우 node:18-alpine를 사용하겠습니다. 이것은 기본 이미지보다 훨씬 작습니다. -alpine를 사용하려면 모든 다른 것보다 먼저 파이썬을 설치해야 합니다. 그래서 그 추가 명령(RUN apk add — no-cache g++ make py3-pip libc6-compat)이 있는 것입니다. 공통 설정을 base 단계에 넣어서 나중에 다른 단계에서 재사용할 수 있도록 했습니다. 원하는 경우 단계 이름을 변경하여 as 다음에 오는 내용을 변경할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e빌더 단계는 사실상 npm run build를 담당합니다. 이 단계는 production 단계에서 이미 존재하지 않은 경우 COPY — from=builder를 시도할 때 호출됩니다. 보세요? 다중 단계 Dockerfile이 유용한 점이 여기에 있습니다. 빌더 단계는 필요할 때만 호출됩니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e저희는 프로덕션 단계에서 NODE_ENV를 production으로 설정하고, 이렇게 하면 성능이 세 배 향상된다고 합니다. 그 다음으로, npm ci를 실행합니다. 이것은 npm install 대신에 지속적인 통합을 위해 사용됩니다.\u003c/p\u003e\n\u003cp\u003e그 후, 보안상의 이유로 앱을 실행할 비루트 사용자를 추가합니다. 제가 게으른 터라 사용자를 nextjs로 그룹을 nodejs로 설정했습니다.\u003c/p\u003e\n\u003cp\u003e그 후에, 빌더 단계에서 필요한 에셋을 COPY — from=builder를 통해 복사합니다.\u003c/p\u003e\n\u003cp\u003e마지막으로, npm start를 호출하여 어플리케이션을 시작합니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e개발 스테이지에서는 싱글 스테이지 Dockerfile에서 한 것과 기본적으로 똑같은 작업을 하고 있기 때문에 넘어가도록 할게요.\u003c/p\u003e\n\u003cp\u003edocker-compose.yml을 생성하기 전에 Dockerfile이 실제로 빌드되는지 확인하고 싶다면 docker build -t my-app . 및 docker run -p 3000:3000 my-app를 실행할 수 있어요. 테스트하고 싶은 스테이지를 주석 처리하는 것을 잊지 마세요. 예를 들어, 프로덕션 스테이지가 성공적으로 빌드되고 실행되는지 확인하려면 FROM base로 시작하는 부분 이후에 오는 모든 것을 주석 처리해주세요.\u003c/p\u003e\n\u003ch2\u003eDocker Compose\u003c/h2\u003e\n\u003cp\u003eDocker Compose를 사용하면 긴 명령어를 기억할 필요가 없어요. docker-compose build 및 docker-compose up 명령어를 간편하게 사용할 수 있어요.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e루트 디렉토리에 다음 내용을 가진 docker-compose.yml 파일을 추가해주세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-attr\"\u003eversion\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'3.8'\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003eservices\u003c/span\u003e:\n  \u003cspan class=\"hljs-attr\"\u003eapp\u003c/span\u003e:\n    \u003cspan class=\"hljs-attr\"\u003eimage\u003c/span\u003e: openai-demo-app\n    \u003cspan class=\"hljs-attr\"\u003ebuild\u003c/span\u003e:\n      \u003cspan class=\"hljs-attr\"\u003econtext\u003c/span\u003e: ./\n      \u003cspan class=\"hljs-attr\"\u003etarget\u003c/span\u003e: dev\n      \u003cspan class=\"hljs-attr\"\u003edockerfile\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eDockerfile\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003evolumes\u003c/span\u003e:\n        - .:/app\n        - \u003cspan class=\"hljs-regexp\"\u003e/app/\u003c/span\u003enode_modules\n        - \u003cspan class=\"hljs-regexp\"\u003e/app/\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003enext\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003eports\u003c/span\u003e:\n      - \u003cspan class=\"hljs-string\"\u003e\"3000:3000\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 \u003ccode\u003e3.8\u003c/code\u003e 버전은 사용할 Docker Compose 버전을 지정합니다. 이 경우에는 한 개의 서비스인 app을 가지고 있지만, 필요에 따라 더 추가할 수 있습니다.\u003c/p\u003e\n\u003cp\u003eBuild context는 현재 디렉토리를 지정하며, target은 Docker 이미지를 빌드할 단계를 지정합니다. 프로덕션에서 실행하려면 단순히 target:production으로 설정하시면 됩니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eVolume은 호스트의 ./ 로컬 디렉토리의 내용을 Docker 컨테이너의 /app 디렉토리로 복사하도록 지시합니다.\u003c/p\u003e\n\u003cp\u003e마지막으로, 호스트 머신의 포트 3000을 컨테이너의 포트 3000으로 매핑합니다. 우리는 컨테이너를 빌드할 때 포트 3000을 노출했으며, 우리의 앱도 3000 포트에서 실행될 것입니다.\u003c/p\u003e\n\u003ch2\u003eDocker Compose로 테스트하기\u003c/h2\u003e\n\u003cp\u003e마침내 Docker 이미지를 빌드하는 과정에 도달했습니다. 더 빠른 빌드를 위해 Docker의 BuildKit 기능을 사용할 것입니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable constant_\"\u003eCOMPOSE_DOCKER_CLI_BUILD\u003c/span\u003e=\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eDOCKER_BUILDKIT\u003c/span\u003e=\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e docker-compose build\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e빌드가 완료되면 이미지를 실행하여 앱을 시작할 수 있어요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edocker-compose up\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그 다음에 브라우저에서 \u003ca href=\"http://localhost:3000\" rel=\"nofollow\" target=\"_blank\"\u003ehttp://localhost:3000\u003c/a\u003e 로 이동하면 앱이 실행 중인 것을 볼 수 있어요!!!\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e그게 다야!\u003c/p\u003e\n\u003cp\u003e아래에는 몇 가지 문제가 있었어요. 내 Docker 컨테이너가 작동하지 않거나 문제의 원인을 찾고 싶다면 고생 중일 수도 있으니 빠르게 공유할게요.\u003c/p\u003e\n\u003ch1\u003e내가 겪은 문제들\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003ePython이 명령줄이나 npm 구성에서 설정되지 않았습니다: (맥 사용자로서) python을 경로에 추가하거나 python을 python3로 별칭 지정, python 삭제 및 다시 설치 등 많은 시도를 해보았지만 어떤 것도 제겐 도움이 되지 않았어요. 그래서 제가 찾아낸 두 가지 해결책을 여기에 소개할게요. (1) node:18(또는 기호하는 다른 버전) 대신 node:18-alpine을 사용하세요. (2) 패키지 설치 전에 RUN apk add --no-cache g++ make py3-pip libc6-compat 를 추가하세요.\u003c/li\u003e\n\u003cli\u003eDocker-compose up을 사용할 때 '/app/.next' 디렉토리에서 프로덕션 빌드를 찾을 수 없음: docker run을 통해 이미지를 실행했을 때는 모든 것이 예상대로 작동했습니다. 해결 방법은 Dockerfile에서 CMD npm start 앞에 CMD [\"npm\",\"run\",\"build\"]를 추가하는 것을 제안하는 솔루션이 있지만, 이렇게 하면 두 개의 CMD를 허용하지 않는 오류가 발생했어요. 제 해결책은 Docker-compose.yml의 volumes에 — /app/.next를 추가하는 것이었습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e오늘은 여기까지입니다!\u003c/p\u003e\n\u003cp\u003e읽어 주셔서 감사합니다! 이 팁들이 도움이 되길 바랍니다!\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-23-DockerizeaNextjsApp"},"buildId":"-dPCbnM2yhdKNgXe92VJV","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>