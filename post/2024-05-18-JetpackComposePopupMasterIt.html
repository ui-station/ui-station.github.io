<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Jetpack Compose 팝업  마스터하기 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-05-18-JetpackComposePopupMasterIt" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Jetpack Compose 팝업  마스터하기 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="Jetpack Compose 팝업  마스터하기 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-18-JetpackComposePopupMasterIt_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-05-18-JetpackComposePopupMasterIt" data-gatsby-head="true"/><meta name="twitter:title" content="Jetpack Compose 팝업  마스터하기 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-18-JetpackComposePopupMasterIt_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-18 15:27" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-V5DKFTZ6BX"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-V5DKFTZ6BX');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/cd012fc8787133d0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cd012fc8787133d0.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/551-3069cf29fe274aab.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-561ae49ab5aab7f5.js" defer=""></script><script src="/_next/static/ll1cGyplNwh83dpggeai1/_buildManifest.js" defer=""></script><script src="/_next/static/ll1cGyplNwh83dpggeai1/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Jetpack Compose 팝업  마스터하기</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Jetpack Compose 팝업  마스터하기" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 18, 2024</span><span class="posts_reading_time__f7YPP">9<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-18-JetpackComposePopupMasterIt&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><h2>안드로이드 개발 배우기</h2>
<p><img src="/assets/img/2024-05-18-JetpackComposePopupMasterIt_0.png" alt="이미지"/></p>
<p>저희가 Jetpack Compose 뷰를 프로그래밍할 때, 단순한 Jetpack Compose 뷰 프로그래밍으로 어떤 제약이 있다는 것을 깨닫지 못할 수 있습니다.</p>
<p>해당 제약은 다음과 같습니다. 어떤 Compose 뷰에서도, 부모 뷰에 비해 큰 뷰나 뷰 외부에서 다른 뷰를 작성하는 것이 불가능합니다 (아래 다이어그램에 표시됨).</p>
<div class="content-ad"></div>
<p>아래는 새로운 코드 블록을 Markdown 형식으로 바꾼 예시입니다.</p>
<img src="/assets/img/2024-05-18-JetpackComposePopupMasterIt_1.png"/>
<p>자, 다행히도 Jetpack Compose는 이 목적으로 활용할 수 있는 두 개의 Compose 구성 요소를 제공해줍니다.</p>
<ul>
<li>Dialog</li>
<li>Popup</li>
</ul>
<p>이 글의 주제는 Popup에 대해 모든 것을 공유하고, 그림을 통해 사용자가 쉽게 익힐 수 있도록 합니다. 또 기타 재미있는 세부사항이나 화면 보안, 제스처 사용 방지 등에 대해 알 수도 있습니다.</p>
<div class="content-ad"></div>
<p>한번 확인해 보세요.</p>
<h1>팝업 기본</h1>
<h2>팝업 표시</h2>
<p>기본적으로, 다음과 같이 팝업을 표시할 수 있습니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-title class_">Popup</span> { 
    <span class="hljs-comment">// 팝업에서 표시할 합성 콘텐츠</span>
}
</code></pre>
<p>그러나 우리가 그냥 호출하면 팝업이 항상 표시됩니다.</p>
<p>버튼 클릭시에만 표시되도록하려면 몇 가지 제어 로직을 둘러싸야합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> popupControl by remember { <span class="hljs-title function_">mutableStateOf</span>(<span class="hljs-literal">false</span>) }
<span class="hljs-title class_">TextButton</span>(onClick = { popupControl = <span class="hljs-literal">true</span> }) {
    <span class="hljs-title class_">Text</span>(<span class="hljs-string">&quot;일반 팝업 열기&quot;</span>)
}

<span class="hljs-keyword">if</span> (popupControl) {
    <span class="hljs-title class_">Popup</span> {
      <span class="hljs-comment">// 팝업에서 표시할 합성 콘텐츠</span>
    }
}
</code></pre>
<div class="content-ad"></div>
<p>기본적으로 팝업은 아래와 같이 부모 컨테이너의 상단-왼쪽에 맞춰 표시됩니다.</p>
<p><img src="https://miro.medium.com/v2/resize:fit:470/1*jpGDSCT0yj7bk1I2Bf-tPA.gif" alt="Popup Default Alignment"/></p>
<h2>팝업 정렬</h2>
<p>팝업을 재정렬하려면 제공할 수 있는 정렬 매개변수가 있습니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-title class_">Popup</span>(
    정렬 = <span class="hljs-title class_">Alignment</span>.<span class="hljs-property">Center</span>,
)
</code></pre>
<p>설정 가능한 값으로는 Center, CenterStart, CenterEnd, TopCenter, TopStart (기본값), TopEnd, BottomCenter, BottomStart, BottomEnd이 있습니다.</p>
<p>물론 항상 이상적인 상황은 아닐 수 있습니다. 따라서 사용자가 제공할 수 있는 Offset 값도 몇 가지 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">Popup</span>(
    정렬 = <span class="hljs-title class_">Alignment</span>.<span class="hljs-property">CenterStart</span>,
    offset = <span class="hljs-title class_">IntOffset</span>(<span class="hljs-number">0</span>, <span class="hljs-number">700</span>),
)
</code></pre>
<div class="content-ad"></div>
<h2>Popup onDismissRequest</h2>
<p>기본적으로 팝업 콘텐츠 외부를 누르면 팝업이 닫힙니다. 그러나 다음을 따르면 결코 닫히지 않습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> popupControl by remember { <span class="hljs-title function_">mutableStateOf</span>(<span class="hljs-literal">false</span>) }
<span class="hljs-title class_">TextButton</span>(onClick = { popupControl = <span class="hljs-literal">true</span> }) {
    <span class="hljs-title class_">Text</span>(<span class="hljs-string">&quot;Open normal popup&quot;</span>)
}

<span class="hljs-keyword">if</span> (popupControl) {
    <span class="hljs-title class_">Popup</span>(
        alignment = <span class="hljs-title class_">Alignment</span>.<span class="hljs-property">CenterStart</span>,
        offset = <span class="hljs-title class_">IntOffset</span>(<span class="hljs-number">0</span>, <span class="hljs-number">700</span>),
    ) {
      <span class="hljs-comment">// 팝업에 표시할 컴포저블 콘텐츠</span>
    }
}
</code></pre>
<p>팝업이 닫히지 않는 것은 팝업이 사라지지 않았기 때문이 아닙니다. 실제로 닫혔지만, 팝업 컨트롤이 여전히 true 상태이며, recomposition되면 Popup이 다시 나타납니다 (닫혔다고 느끼지 않게 합니다).</p>
<div class="content-ad"></div>
<p>해당 문제를 해결하기 위해 팝업이 닫힐 때 popupControl을 false로 설정하도록 팝업에 알려주어야 합니다. 아래와 같이 onDismissRequest 매개변수를 사용하여 그 작업을 수행할 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> popupControl by remember { <span class="hljs-title function_">mutableStateOf</span>(<span class="hljs-literal">false</span>) }
<span class="hljs-title class_">TextButton</span>(onClick = { popupControl = <span class="hljs-literal">true</span> }) {
    <span class="hljs-title class_">Text</span>(<span class="hljs-string">&quot;일반 팝업 열기&quot;</span>)
}

<span class="hljs-keyword">if</span> (popupControl) {
    <span class="hljs-title class_">Popup</span>(
        alignment = <span class="hljs-title class_">Alignment</span>.<span class="hljs-property">CenterStart</span>,
        offset = <span class="hljs-title class_">IntOffset</span>(<span class="hljs-number">0</span>, <span class="hljs-number">700</span>),
        onDismissRequest = { popupControl = <span class="hljs-literal">false</span> },
    ) {
      <span class="hljs-comment">// 팝업에서 표시할 컴포저블 내용</span>
    }
}
</code></pre>
<h1>팝업 속성</h1>
<p>팝업의 기본을 배웠으니, 좀 더 고급 기능 중 하나인 PopupProerties 매개변수에 대해 살펴보겠습니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PopupProperties</span>(
    <span class="hljs-attr">focusable</span>: <span class="hljs-title class_">Boolean</span> = <span class="hljs-literal">false</span>,
    <span class="hljs-attr">dismissOnBackPress</span>: <span class="hljs-title class_">Boolean</span> = <span class="hljs-literal">true</span>,
    <span class="hljs-attr">dismissOnClickOutside</span>: <span class="hljs-title class_">Boolean</span> = <span class="hljs-literal">true</span>,
    <span class="hljs-attr">securePolicy</span>: <span class="hljs-title class_">SecureFlagPolicy</span> = <span class="hljs-title class_">SecureFlagPolicy</span>.<span class="hljs-property">Inherit</span>,
    <span class="hljs-attr">excludeFromSystemGesture</span>: <span class="hljs-title class_">Boolean</span> = <span class="hljs-literal">true</span>,
    <span class="hljs-attr">clippingEnabled</span>: <span class="hljs-title class_">Boolean</span> = <span class="hljs-literal">true</span>,
    @<span class="hljs-attr">get</span>:<span class="hljs-title class_">ExperimentalComposeUiApi</span> <span class="hljs-comment">//현재시점에서</span>
    val <span class="hljs-attr">usePlatformDefaultWidth</span>: <span class="hljs-title class_">Boolean</span> = <span class="hljs-literal">false</span>
)
</code></pre>
<p>상기 내용이 기본값으로 제공되지만 우리는 이를 재정의할 수 있습니다. 아래에서 각각 설명하겠습니다.</p>
<h2>Focusable 및 DismissOnBackPress</h2>
<p>focusable이 true일 때 팝업은 IME 이벤트와 키 입력을 수신하고, 뒤로 가기 버튼이 눌렸을 때와 같이 역할을 합니다. 그러나 팝업 뒤에 있는 것에 대한 터치가 비활성화됩니다.```</p>
<div class="content-ad"></div>
<p><img src="/assets/img/2024-05-18-JetpackComposePopupMasterIt_2.png" alt="Popup"/></p>
<p>If we couple <code>focusable = true</code> with <code>dismissOnBackPress</code> is true, then the Popup will be dismissed if the user clicks the back button (the older Android phone).</p>
<h2>DismissOnClickOutside</h2>
<p>As mentioned previously, by default, when the user clicks outside the Popup area, it will be dismissed</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js">enum <span class="hljs-keyword">class</span> <span class="hljs-title class_">SecureFlagPolicy</span> {
    <span class="hljs-title class_">Inherit</span>, <span class="hljs-comment">// 부모를 따름, 기본값입니다</span>
    <span class="hljs-title class_">SecureOn</span>,
    <span class="hljs-title class_">SecureOff</span>
}
</code></pre>
<p>다음 그림을 보면 이제 모두 명확해졌습니다.</p>
<p><img src="/assets/img/2024-05-18-JetpackComposePopupMasterIt_3.png" alt="Jetpack Compose Popup Master It"/></p>
<h2>시스템 제스처에서 제외하기</h2>
<div class="content-ad"></div>
<p>안드로이드 Q부터는 Android 하드웨어 백 버튼 대신에 사용자가 왼쪽으로 스와이프하여 뒤로 이동할 수 있습니다.</p>
<p>하지만, 이것은 사이드바가 넓은 경우와 같이 앱 제스처와 겹칠 수 있습니다. 좋은 설명은 여기서 (가장자리에서 가장자리 밝기 슬라이더 섹션에서) 공유되어 있습니다.</p>
<p>상황을 모방하기 위해, 제가 큰 팝업을 만들고 이를 켜고 끕니다.</p>
<p>기본값으로 ON 상태일 때, 아래 설정을 한다면, 스와이프를 하려고 할 것입니다.</p>
<div class="content-ad"></div>
<p>PopupProperties(
focusable = true,
dismissOnBackPress = false,
dismissOnClickOutside = false,
excludeFromSystemGesture = true,
)</p>
<p>아래 GIF에서 왼쪽에서 스와이프해도 아무 일도 일어나지 않습니다.</p>
<img src="https://miro.medium.com/v2/resize:fit:470/1*8keelwDUflGe_U2LT9_7-g.gif"/>
<p>하지만, OFF로 변경해보면</p>
<div class="content-ad"></div>
<pre><code class="hljs language-javascript"><span class="hljs-title class_">PopupProperties</span>(
    focusable = <span class="hljs-literal">true</span>,
    dismissOnBackPress = <span class="hljs-literal">false</span>,
    dismissOnClickOutside = <span class="hljs-literal">false</span>,
    excludeFromSystemGesture = <span class="hljs-literal">false</span>,
)
</code></pre>
<p>이제 왼쪽에서 스와이프를 할 때 “뒤로 가기”가 트리거되었습니다 (‘`’ 기호로 표시됨)</p>
<p><img src="https://miro.medium.com/v2/resize:fit:470/1*lIPOkC6ucBMDt0yUOWWAPg.gif" alt="이미지"/></p>
<h2>ClippingEnabled</h2>
<div class="content-ad"></div>
<p>기본적으로는 그렇습니다. 이것은 팝업을 앱 장치 화면 바깥으로 실수로 배치할 수 없게 한다는 것을 의미합니다. Offset 값이 너무 크거나 팝업이 너무 커지면 아래에 나와 있는 것처럼 팝업이 축소되어 앱 장치에 고정됩니다.</p>
<p>그러나 화면을 벗어나도 상관없다면 이 값을 false로 설정할 수 있습니다.</p>
<img src="/assets/img/2024-05-18-JetpackComposePopupMasterIt_4.png"/>
<h2>UsePlatformDefaultWidth</h2>
<div class="content-ad"></div>
<p>작성 시점에는 이것이 여전히 실험 중입니다. 잘라내기와 거의 동일하지만 다음과 같은 차이가 있습니다.</p>
<ul>
<li>너비만 잘라냅니다 (높이는 잘라내지 않음)</li>
<li>위치를 재조정하지 않습니다 (X 좌표).</li>
</ul>
<p>아래는 Clipping과 함께 사용했을 때의 결과입니다.</p>
<p><img src="/assets/img/2024-05-18-JetpackComposePopupMasterIt_5.png" alt="Image"/></p>
<div class="content-ad"></div>
<h1>위치 조정 사용자 정의</h1>
<p>PopupProperty에 대해 배웠습니다. 또한 일반 Popup을 알고 있으며, Parent Composable View와 정렬하여 위치를 조정할 수 있습니다.</p>
<p>그러나 Popup이 Parent Composable View에 의존하지 않도록하려면 어떻게해야 합니까?</p>
<p>좋은 소식은 PopupPositionProvider를 제공할 수 있는 또 다른 Popup API가 있다는 것입니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-kotlin"><span class="hljs-meta">@Composable</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">Popup</span><span class="hljs-params">(
    popupPositionProvider: <span class="hljs-type">PopupPositionProvider</span>,
    onDismissRequest: (() -&gt; <span class="hljs-type">Unit</span>)? = <span class="hljs-literal">null</span>,
    properties: <span class="hljs-type">PopupProperties</span> = PopupProperties()</span></span>,
    content: <span class="hljs-meta">@Composable</span> () -&gt; <span class="hljs-built_in">Unit</span>
) {
</code></pre>
<h2>PopupPositionProvider</h2>
<p>이 인터페이스는 사용자가 원하는 위치를 계산하는 데 사용됩니다.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-meta">@Immutable</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">PopupPositionProvider</span> {
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">calculatePosition</span><span class="hljs-params">(
        anchorBounds: <span class="hljs-type">IntRect</span>,
        windowSize: <span class="hljs-type">IntSize</span>,
        layoutDirection: <span class="hljs-type">LayoutDirection</span>,
        popupContentSize: <span class="hljs-type">IntSize</span>
    )</span></span>: IntOffset
}
</code></pre>
<div class="content-ad"></div>
<p>제 경우에는 항상 창의 중앙에 위치한 사용자 정의 팝업 위치를 원합니다.</p>
<p>그래서 아래처럼 Position을 쉽게 만들 수 있어요. 여기에는 창의 중앙 위치에 대한 상대적인 OffSet도 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">WindowCenterOffsetPositionProvider</span>(
    private val <span class="hljs-attr">x</span>: <span class="hljs-title class_">Int</span> = <span class="hljs-number">0</span>,
    private val <span class="hljs-attr">y</span>: <span class="hljs-title class_">Int</span> = <span class="hljs-number">0</span>
) : <span class="hljs-title class_">PopupPositionProvider</span> {
    override fun <span class="hljs-title function_">calculatePosition</span>(
        <span class="hljs-attr">anchorBounds</span>: <span class="hljs-title class_">IntRect</span>,
        <span class="hljs-attr">windowSize</span>: <span class="hljs-title class_">IntSize</span>,
        <span class="hljs-attr">layoutDirection</span>: <span class="hljs-title class_">LayoutDirection</span>,
        <span class="hljs-attr">popupContentSize</span>: <span class="hljs-title class_">IntSize</span>
    ): <span class="hljs-title class_">IntOffset</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">IntOffset</span>(
            (windowSize.<span class="hljs-property">width</span> - popupContentSize.<span class="hljs-property">width</span>) / <span class="hljs-number">2</span> + x,
            (windowSize.<span class="hljs-property">height</span> - popupContentSize.<span class="hljs-property">height</span>) / <span class="hljs-number">2</span> + y
        )
    }
}
</code></pre>
<p>이제 아래와 같이 Popup에 할당하기만 하면 됩니다. 그러면 그에 맞게 동작합니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">var</span> popupControl <span class="hljs-keyword">by</span> remember { mutableStateOf(<span class="hljs-literal">false</span>) }
TextButton(onClick = { popupControl = <span class="hljs-literal">true</span> }) {
    Text(<span class="hljs-string">&quot;일반 팝업 열기&quot;</span>)
}

<span class="hljs-keyword">if</span> (popupControl) {
    Popup(
        popupPositionProvider = 
           WindowCenterOffsetPositionProvider(),
        onDismissRequest = { popupControl = <span class="hljs-literal">false</span> },
    ) {
      <span class="hljs-comment">// 팝업에 표시할 콘텐츠</span>
    }
}
</code></pre>
<img src="https://miro.medium.com/v2/resize:fit:476/1*Gd9kg-HENkrcawasnU1IZw.gif"/>
<p>여기서 코드 디자인을 얻을 수 있습니다.</p>
<div class="content-ad"></div>
<p>팝업은 호출자의 Compose 기능이 호출자의 Compose 뷰 경계 밖의 내용을 표시할 수 있게 하는 Jetpack Compose 구성 요소입니다.</p>
<p>삭제되는 방법, 레이아웃, 호출자 Compose 뷰와의 위치 맞춤과 같이 사용자 정의할 수 있는 여러 팝업 속성이 있습니다.</p>
<p>창과 맞춤을 맞출 수 있게 하는 Positioning 같은 위치 지정도 사용자 정의할 수 있습니다.</p>
<p>예를 들어 사용 가능한 여러 제한 사항이 있습니다.</p>
<div class="content-ad"></div>
<ul>
<li>표시 여부를 결정하는 외부 변수 (팝업 외부의 변수)에 의해 외부에서 제어되어야 합니다.</li>
<li>Composable 함수이므로 onClick 내에서 호출하거나 큐에 넣어 시기적절한 닫기를 할 수 없습니다. (예: 토스트로 만들어 호출), 코루틴 스코프에서.</li>
</ul>
<p>위의 제한사항을 고려하여 Popup에서 영향을 받은 사용자 정의 AbstractComposeView를 시도해보려고 합니다. 발견한 내용은 아래와 같습니다.</p></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Jetpack Compose 팝업  마스터하기","description":"","date":"2024-05-18 15:27","slug":"2024-05-18-JetpackComposePopupMasterIt","content":"\n\n## 안드로이드 개발 배우기\n\n![이미지](/assets/img/2024-05-18-JetpackComposePopupMasterIt_0.png)\n\n저희가 Jetpack Compose 뷰를 프로그래밍할 때, 단순한 Jetpack Compose 뷰 프로그래밍으로 어떤 제약이 있다는 것을 깨닫지 못할 수 있습니다.\n\n해당 제약은 다음과 같습니다. 어떤 Compose 뷰에서도, 부모 뷰에 비해 큰 뷰나 뷰 외부에서 다른 뷰를 작성하는 것이 불가능합니다 (아래 다이어그램에 표시됨).\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 새로운 코드 블록을 Markdown 형식으로 바꾼 예시입니다.\n\n\n\u003cimg src=\"/assets/img/2024-05-18-JetpackComposePopupMasterIt_1.png\" /\u003e\n\n자, 다행히도 Jetpack Compose는 이 목적으로 활용할 수 있는 두 개의 Compose 구성 요소를 제공해줍니다.\n\n- Dialog\n- Popup\n\n이 글의 주제는 Popup에 대해 모든 것을 공유하고, 그림을 통해 사용자가 쉽게 익힐 수 있도록 합니다. 또 기타 재미있는 세부사항이나 화면 보안, 제스처 사용 방지 등에 대해 알 수도 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n한번 확인해 보세요.\n\n# 팝업 기본\n\n## 팝업 표시\n\n기본적으로, 다음과 같이 팝업을 표시할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nPopup { \n    // 팝업에서 표시할 합성 콘텐츠\n}\n```\n\n그러나 우리가 그냥 호출하면 팝업이 항상 표시됩니다.\n\n버튼 클릭시에만 표시되도록하려면 몇 가지 제어 로직을 둘러싸야합니다.\n\n```js\nvar popupControl by remember { mutableStateOf(false) }\nTextButton(onClick = { popupControl = true }) {\n    Text(\"일반 팝업 열기\")\n}\n\nif (popupControl) {\n    Popup {\n      // 팝업에서 표시할 합성 콘텐츠\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n기본적으로 팝업은 아래와 같이 부모 컨테이너의 상단-왼쪽에 맞춰 표시됩니다.\n\n![Popup Default Alignment](https://miro.medium.com/v2/resize:fit:470/1*jpGDSCT0yj7bk1I2Bf-tPA.gif)\n\n## 팝업 정렬\n\n팝업을 재정렬하려면 제공할 수 있는 정렬 매개변수가 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nPopup(\n    정렬 = Alignment.Center,\n)\n```\n\n설정 가능한 값으로는 Center, CenterStart, CenterEnd, TopCenter, TopStart (기본값), TopEnd, BottomCenter, BottomStart, BottomEnd이 있습니다.\n\n물론 항상 이상적인 상황은 아닐 수 있습니다. 따라서 사용자가 제공할 수 있는 Offset 값도 몇 가지 있습니다.\n\n```js\nPopup(\n    정렬 = Alignment.CenterStart,\n    offset = IntOffset(0, 700),\n)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## Popup onDismissRequest\n\n기본적으로 팝업 콘텐츠 외부를 누르면 팝업이 닫힙니다. 그러나 다음을 따르면 결코 닫히지 않습니다.\n\n```js\nvar popupControl by remember { mutableStateOf(false) }\nTextButton(onClick = { popupControl = true }) {\n    Text(\"Open normal popup\")\n}\n\nif (popupControl) {\n    Popup(\n        alignment = Alignment.CenterStart,\n        offset = IntOffset(0, 700),\n    ) {\n      // 팝업에 표시할 컴포저블 콘텐츠\n    }\n}\n```\n\n팝업이 닫히지 않는 것은 팝업이 사라지지 않았기 때문이 아닙니다. 실제로 닫혔지만, 팝업 컨트롤이 여전히 true 상태이며, recomposition되면 Popup이 다시 나타납니다 (닫혔다고 느끼지 않게 합니다).\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n해당 문제를 해결하기 위해 팝업이 닫힐 때 popupControl을 false로 설정하도록 팝업에 알려주어야 합니다. 아래와 같이 onDismissRequest 매개변수를 사용하여 그 작업을 수행할 수 있습니다.\n\n```js\nvar popupControl by remember { mutableStateOf(false) }\nTextButton(onClick = { popupControl = true }) {\n    Text(\"일반 팝업 열기\")\n}\n\nif (popupControl) {\n    Popup(\n        alignment = Alignment.CenterStart,\n        offset = IntOffset(0, 700),\n        onDismissRequest = { popupControl = false },\n    ) {\n      // 팝업에서 표시할 컴포저블 내용\n    }\n}\n```\n\n# 팝업 속성\n\n팝업의 기본을 배웠으니, 좀 더 고급 기능 중 하나인 PopupProerties 매개변수에 대해 살펴보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nclass PopupProperties(\n    focusable: Boolean = false,\n    dismissOnBackPress: Boolean = true,\n    dismissOnClickOutside: Boolean = true,\n    securePolicy: SecureFlagPolicy = SecureFlagPolicy.Inherit,\n    excludeFromSystemGesture: Boolean = true,\n    clippingEnabled: Boolean = true,\n    @get:ExperimentalComposeUiApi //현재시점에서\n    val usePlatformDefaultWidth: Boolean = false\n)\n```\n\n상기 내용이 기본값으로 제공되지만 우리는 이를 재정의할 수 있습니다. 아래에서 각각 설명하겠습니다.\n\n## Focusable 및 DismissOnBackPress\n\nfocusable이 true일 때 팝업은 IME 이벤트와 키 입력을 수신하고, 뒤로 가기 버튼이 눌렸을 때와 같이 역할을 합니다. 그러나 팝업 뒤에 있는 것에 대한 터치가 비활성화됩니다.```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Popup](/assets/img/2024-05-18-JetpackComposePopupMasterIt_2.png)\n\nIf we couple `focusable = true` with `dismissOnBackPress` is true, then the Popup will be dismissed if the user clicks the back button (the older Android phone).\n\n## DismissOnClickOutside\n\nAs mentioned previously, by default, when the user clicks outside the Popup area, it will be dismissed\n \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n```js\nenum class SecureFlagPolicy {\n    Inherit, // 부모를 따름, 기본값입니다\n    SecureOn,\n    SecureOff\n}\n```\n\n다음 그림을 보면 이제 모두 명확해졌습니다.\n\n![Jetpack Compose Popup Master It](/assets/img/2024-05-18-JetpackComposePopupMasterIt_3.png)\n\n## 시스템 제스처에서 제외하기\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n안드로이드 Q부터는 Android 하드웨어 백 버튼 대신에 사용자가 왼쪽으로 스와이프하여 뒤로 이동할 수 있습니다.\n\n하지만, 이것은 사이드바가 넓은 경우와 같이 앱 제스처와 겹칠 수 있습니다. 좋은 설명은 여기서 (가장자리에서 가장자리 밝기 슬라이더 섹션에서) 공유되어 있습니다.\n\n상황을 모방하기 위해, 제가 큰 팝업을 만들고 이를 켜고 끕니다.\n\n기본값으로 ON 상태일 때, 아래 설정을 한다면, 스와이프를 하려고 할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\nPopupProperties(\n    focusable = true,\n    dismissOnBackPress = false,\n    dismissOnClickOutside = false,\n    excludeFromSystemGesture = true,\n)\n\n\n아래 GIF에서 왼쪽에서 스와이프해도 아무 일도 일어나지 않습니다.\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:470/1*8keelwDUflGe_U2LT9_7-g.gif\" /\u003e\n\n하지만, OFF로 변경해보면\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```javascript\nPopupProperties(\n    focusable = true,\n    dismissOnBackPress = false,\n    dismissOnClickOutside = false,\n    excludeFromSystemGesture = false,\n)\n```\n\n이제 왼쪽에서 스와이프를 할 때 “뒤로 가기”가 트리거되었습니다 (‘`’ 기호로 표시됨)\n\n![이미지](https://miro.medium.com/v2/resize:fit:470/1*lIPOkC6ucBMDt0yUOWWAPg.gif)\n\n## ClippingEnabled\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n기본적으로는 그렇습니다. 이것은 팝업을 앱 장치 화면 바깥으로 실수로 배치할 수 없게 한다는 것을 의미합니다. Offset 값이 너무 크거나 팝업이 너무 커지면 아래에 나와 있는 것처럼 팝업이 축소되어 앱 장치에 고정됩니다.\n\n그러나 화면을 벗어나도 상관없다면 이 값을 false로 설정할 수 있습니다.\n\n\u003cimg src=\"/assets/img/2024-05-18-JetpackComposePopupMasterIt_4.png\" /\u003e\n\n## UsePlatformDefaultWidth\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n작성 시점에는 이것이 여전히 실험 중입니다. 잘라내기와 거의 동일하지만 다음과 같은 차이가 있습니다.\n\n- 너비만 잘라냅니다 (높이는 잘라내지 않음)\n- 위치를 재조정하지 않습니다 (X 좌표).\n\n아래는 Clipping과 함께 사용했을 때의 결과입니다.\n\n![Image](/assets/img/2024-05-18-JetpackComposePopupMasterIt_5.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 위치 조정 사용자 정의\n\nPopupProperty에 대해 배웠습니다. 또한 일반 Popup을 알고 있으며, Parent Composable View와 정렬하여 위치를 조정할 수 있습니다.\n\n그러나 Popup이 Parent Composable View에 의존하지 않도록하려면 어떻게해야 합니까?\n\n좋은 소식은 PopupPositionProvider를 제공할 수 있는 또 다른 Popup API가 있다는 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```kotlin\n@Composable\nfun Popup(\n    popupPositionProvider: PopupPositionProvider,\n    onDismissRequest: (() -\u003e Unit)? = null,\n    properties: PopupProperties = PopupProperties(),\n    content: @Composable () -\u003e Unit\n) {\n```\n\n## PopupPositionProvider\n\n이 인터페이스는 사용자가 원하는 위치를 계산하는 데 사용됩니다.\n\n```kotlin\n@Immutable\ninterface PopupPositionProvider {\n    fun calculatePosition(\n        anchorBounds: IntRect,\n        windowSize: IntSize,\n        layoutDirection: LayoutDirection,\n        popupContentSize: IntSize\n    ): IntOffset\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n제 경우에는 항상 창의 중앙에 위치한 사용자 정의 팝업 위치를 원합니다.\n\n그래서 아래처럼 Position을 쉽게 만들 수 있어요. 여기에는 창의 중앙 위치에 대한 상대적인 OffSet도 있습니다.\n\n```js\nclass WindowCenterOffsetPositionProvider(\n    private val x: Int = 0,\n    private val y: Int = 0\n) : PopupPositionProvider {\n    override fun calculatePosition(\n        anchorBounds: IntRect,\n        windowSize: IntSize,\n        layoutDirection: LayoutDirection,\n        popupContentSize: IntSize\n    ): IntOffset {\n        return IntOffset(\n            (windowSize.width - popupContentSize.width) / 2 + x,\n            (windowSize.height - popupContentSize.height) / 2 + y\n        )\n    }\n}\n```\n\n이제 아래와 같이 Popup에 할당하기만 하면 됩니다. 그러면 그에 맞게 동작합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```kotlin\nvar popupControl by remember { mutableStateOf(false) }\nTextButton(onClick = { popupControl = true }) {\n    Text(\"일반 팝업 열기\")\n}\n\nif (popupControl) {\n    Popup(\n        popupPositionProvider = \n           WindowCenterOffsetPositionProvider(),\n        onDismissRequest = { popupControl = false },\n    ) {\n      // 팝업에 표시할 콘텐츠\n    }\n}\n```\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:476/1*Gd9kg-HENkrcawasnU1IZw.gif\" /\u003e\n\n여기서 코드 디자인을 얻을 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n팝업은 호출자의 Compose 기능이 호출자의 Compose 뷰 경계 밖의 내용을 표시할 수 있게 하는 Jetpack Compose 구성 요소입니다.\n\n삭제되는 방법, 레이아웃, 호출자 Compose 뷰와의 위치 맞춤과 같이 사용자 정의할 수 있는 여러 팝업 속성이 있습니다.\n\n창과 맞춤을 맞출 수 있게 하는 Positioning 같은 위치 지정도 사용자 정의할 수 있습니다.\n\n예를 들어 사용 가능한 여러 제한 사항이 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 표시 여부를 결정하는 외부 변수 (팝업 외부의 변수)에 의해 외부에서 제어되어야 합니다.\n- Composable 함수이므로 onClick 내에서 호출하거나 큐에 넣어 시기적절한 닫기를 할 수 없습니다. (예: 토스트로 만들어 호출), 코루틴 스코프에서.\n\n위의 제한사항을 고려하여 Popup에서 영향을 받은 사용자 정의 AbstractComposeView를 시도해보려고 합니다. 발견한 내용은 아래와 같습니다.","ogImage":{"url":"/assets/img/2024-05-18-JetpackComposePopupMasterIt_0.png"},"coverImage":"/assets/img/2024-05-18-JetpackComposePopupMasterIt_0.png","tag":["Tech"],"readingTime":9},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h2: \"h2\",\n    p: \"p\",\n    img: \"img\",\n    ul: \"ul\",\n    li: \"li\",\n    h1: \"h1\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h2, {\n      children: \"안드로이드 개발 배우기\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-18-JetpackComposePopupMasterIt_0.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"저희가 Jetpack Compose 뷰를 프로그래밍할 때, 단순한 Jetpack Compose 뷰 프로그래밍으로 어떤 제약이 있다는 것을 깨닫지 못할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"해당 제약은 다음과 같습니다. 어떤 Compose 뷰에서도, 부모 뷰에 비해 큰 뷰나 뷰 외부에서 다른 뷰를 작성하는 것이 불가능합니다 (아래 다이어그램에 표시됨).\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"아래는 새로운 코드 블록을 Markdown 형식으로 바꾼 예시입니다.\"\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/assets/img/2024-05-18-JetpackComposePopupMasterIt_1.png\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"자, 다행히도 Jetpack Compose는 이 목적으로 활용할 수 있는 두 개의 Compose 구성 요소를 제공해줍니다.\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Dialog\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Popup\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 글의 주제는 Popup에 대해 모든 것을 공유하고, 그림을 통해 사용자가 쉽게 익힐 수 있도록 합니다. 또 기타 재미있는 세부사항이나 화면 보안, 제스처 사용 방지 등에 대해 알 수도 있습니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"한번 확인해 보세요.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"팝업 기본\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"팝업 표시\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"기본적으로, 다음과 같이 팝업을 표시할 수 있습니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Popup\"\n        }), \" { \\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 팝업에서 표시할 합성 콘텐츠\"\n        }), \"\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그러나 우리가 그냥 호출하면 팝업이 항상 표시됩니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"버튼 클릭시에만 표시되도록하려면 몇 가지 제어 로직을 둘러싸야합니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"var\"\n        }), \" popupControl by remember { \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"mutableStateOf\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"false\"\n        }), \") }\\n\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"TextButton\"\n        }), \"(onClick = { popupControl = \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"true\"\n        }), \" }) {\\n    \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Text\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"일반 팝업 열기\\\"\"\n        }), \")\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (popupControl) {\\n    \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Popup\"\n        }), \" {\\n      \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 팝업에서 표시할 합성 콘텐츠\"\n        }), \"\\n    }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"기본적으로 팝업은 아래와 같이 부모 컨테이너의 상단-왼쪽에 맞춰 표시됩니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://miro.medium.com/v2/resize:fit:470/1*jpGDSCT0yj7bk1I2Bf-tPA.gif\",\n        alt: \"Popup Default Alignment\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"팝업 정렬\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"팝업을 재정렬하려면 제공할 수 있는 정렬 매개변수가 있습니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Popup\"\n        }), \"(\\n    정렬 = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Alignment\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"Center\"\n        }), \",\\n)\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"설정 가능한 값으로는 Center, CenterStart, CenterEnd, TopCenter, TopStart (기본값), TopEnd, BottomCenter, BottomStart, BottomEnd이 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"물론 항상 이상적인 상황은 아닐 수 있습니다. 따라서 사용자가 제공할 수 있는 Offset 값도 몇 가지 있습니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Popup\"\n        }), \"(\\n    정렬 = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Alignment\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"CenterStart\"\n        }), \",\\n    offset = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"IntOffset\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"700\"\n        }), \"),\\n)\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Popup onDismissRequest\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"기본적으로 팝업 콘텐츠 외부를 누르면 팝업이 닫힙니다. 그러나 다음을 따르면 결코 닫히지 않습니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"var\"\n        }), \" popupControl by remember { \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"mutableStateOf\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"false\"\n        }), \") }\\n\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"TextButton\"\n        }), \"(onClick = { popupControl = \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"true\"\n        }), \" }) {\\n    \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Text\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Open normal popup\\\"\"\n        }), \")\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (popupControl) {\\n    \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Popup\"\n        }), \"(\\n        alignment = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Alignment\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"CenterStart\"\n        }), \",\\n        offset = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"IntOffset\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"700\"\n        }), \"),\\n    ) {\\n      \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 팝업에 표시할 컴포저블 콘텐츠\"\n        }), \"\\n    }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"팝업이 닫히지 않는 것은 팝업이 사라지지 않았기 때문이 아닙니다. 실제로 닫혔지만, 팝업 컨트롤이 여전히 true 상태이며, recomposition되면 Popup이 다시 나타납니다 (닫혔다고 느끼지 않게 합니다).\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"해당 문제를 해결하기 위해 팝업이 닫힐 때 popupControl을 false로 설정하도록 팝업에 알려주어야 합니다. 아래와 같이 onDismissRequest 매개변수를 사용하여 그 작업을 수행할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"var\"\n        }), \" popupControl by remember { \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"mutableStateOf\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"false\"\n        }), \") }\\n\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"TextButton\"\n        }), \"(onClick = { popupControl = \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"true\"\n        }), \" }) {\\n    \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Text\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"일반 팝업 열기\\\"\"\n        }), \")\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (popupControl) {\\n    \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Popup\"\n        }), \"(\\n        alignment = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Alignment\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"CenterStart\"\n        }), \",\\n        offset = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"IntOffset\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"700\"\n        }), \"),\\n        onDismissRequest = { popupControl = \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"false\"\n        }), \" },\\n    ) {\\n      \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 팝업에서 표시할 컴포저블 내용\"\n        }), \"\\n    }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"팝업 속성\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"팝업의 기본을 배웠으니, 좀 더 고급 기능 중 하나인 PopupProerties 매개변수에 대해 살펴보겠습니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"PopupProperties\"\n        }), \"(\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"focusable\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Boolean\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"false\"\n        }), \",\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"dismissOnBackPress\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Boolean\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"true\"\n        }), \",\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"dismissOnClickOutside\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Boolean\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"true\"\n        }), \",\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"securePolicy\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"SecureFlagPolicy\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"SecureFlagPolicy\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"Inherit\"\n        }), \",\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"excludeFromSystemGesture\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Boolean\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"true\"\n        }), \",\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"clippingEnabled\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Boolean\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"true\"\n        }), \",\\n    @\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"get\"\n        }), \":\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ExperimentalComposeUiApi\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"//현재시점에서\"\n        }), \"\\n    val \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"usePlatformDefaultWidth\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Boolean\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"false\"\n        }), \"\\n)\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"상기 내용이 기본값으로 제공되지만 우리는 이를 재정의할 수 있습니다. 아래에서 각각 설명하겠습니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Focusable 및 DismissOnBackPress\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"focusable이 true일 때 팝업은 IME 이벤트와 키 입력을 수신하고, 뒤로 가기 버튼이 눌렸을 때와 같이 역할을 합니다. 그러나 팝업 뒤에 있는 것에 대한 터치가 비활성화됩니다.```\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-18-JetpackComposePopupMasterIt_2.png\",\n        alt: \"Popup\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"If we couple \", _jsx(_components.code, {\n        children: \"focusable = true\"\n      }), \" with \", _jsx(_components.code, {\n        children: \"dismissOnBackPress\"\n      }), \" is true, then the Popup will be dismissed if the user clicks the back button (the older Android phone).\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"DismissOnClickOutside\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"As mentioned previously, by default, when the user clicks outside the Popup area, it will be dismissed\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"enum \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"SecureFlagPolicy\"\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Inherit\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 부모를 따름, 기본값입니다\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"SecureOn\"\n        }), \",\\n    \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"SecureOff\"\n        }), \"\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다음 그림을 보면 이제 모두 명확해졌습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-18-JetpackComposePopupMasterIt_3.png\",\n        alt: \"Jetpack Compose Popup Master It\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"시스템 제스처에서 제외하기\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"안드로이드 Q부터는 Android 하드웨어 백 버튼 대신에 사용자가 왼쪽으로 스와이프하여 뒤로 이동할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"하지만, 이것은 사이드바가 넓은 경우와 같이 앱 제스처와 겹칠 수 있습니다. 좋은 설명은 여기서 (가장자리에서 가장자리 밝기 슬라이더 섹션에서) 공유되어 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"상황을 모방하기 위해, 제가 큰 팝업을 만들고 이를 켜고 끕니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"기본값으로 ON 상태일 때, 아래 설정을 한다면, 스와이프를 하려고 할 것입니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"PopupProperties(\\nfocusable = true,\\ndismissOnBackPress = false,\\ndismissOnClickOutside = false,\\nexcludeFromSystemGesture = true,\\n)\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"아래 GIF에서 왼쪽에서 스와이프해도 아무 일도 일어나지 않습니다.\"\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"https://miro.medium.com/v2/resize:fit:470/1*8keelwDUflGe_U2LT9_7-g.gif\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"하지만, OFF로 변경해보면\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-javascript\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"PopupProperties\"\n        }), \"(\\n    focusable = \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"true\"\n        }), \",\\n    dismissOnBackPress = \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"false\"\n        }), \",\\n    dismissOnClickOutside = \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"false\"\n        }), \",\\n    excludeFromSystemGesture = \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"false\"\n        }), \",\\n)\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 왼쪽에서 스와이프를 할 때 “뒤로 가기”가 트리거되었습니다 (‘`’ 기호로 표시됨)\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://miro.medium.com/v2/resize:fit:470/1*lIPOkC6ucBMDt0yUOWWAPg.gif\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"ClippingEnabled\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"기본적으로는 그렇습니다. 이것은 팝업을 앱 장치 화면 바깥으로 실수로 배치할 수 없게 한다는 것을 의미합니다. Offset 값이 너무 크거나 팝업이 너무 커지면 아래에 나와 있는 것처럼 팝업이 축소되어 앱 장치에 고정됩니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그러나 화면을 벗어나도 상관없다면 이 값을 false로 설정할 수 있습니다.\"\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/assets/img/2024-05-18-JetpackComposePopupMasterIt_4.png\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"UsePlatformDefaultWidth\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"작성 시점에는 이것이 여전히 실험 중입니다. 잘라내기와 거의 동일하지만 다음과 같은 차이가 있습니다.\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"너비만 잘라냅니다 (높이는 잘라내지 않음)\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"위치를 재조정하지 않습니다 (X 좌표).\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"아래는 Clipping과 함께 사용했을 때의 결과입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-18-JetpackComposePopupMasterIt_5.png\",\n        alt: \"Image\"\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"위치 조정 사용자 정의\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"PopupProperty에 대해 배웠습니다. 또한 일반 Popup을 알고 있으며, Parent Composable View와 정렬하여 위치를 조정할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그러나 Popup이 Parent Composable View에 의존하지 않도록하려면 어떻게해야 합니까?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"좋은 소식은 PopupPositionProvider를 제공할 수 있는 또 다른 Popup API가 있다는 것입니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-meta\",\n          children: \"@Composable\"\n        }), \"\\n\", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"Popup\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(\\n    popupPositionProvider: \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"PopupPositionProvider\"\n            }), \",\\n    onDismissRequest: (() -\u003e \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"Unit\"\n            }), \")? = \", _jsx(_components.span, {\n              className: \"hljs-literal\",\n              children: \"null\"\n            }), \",\\n    properties: \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"PopupProperties\"\n            }), \" = PopupProperties()\"]\n          })]\n        }), \",\\n    content: \", _jsx(_components.span, {\n          className: \"hljs-meta\",\n          children: \"@Composable\"\n        }), \" () -\u003e \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"Unit\"\n        }), \"\\n) {\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"PopupPositionProvider\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 인터페이스는 사용자가 원하는 위치를 계산하는 데 사용됩니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-meta\",\n          children: \"@Immutable\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"interface\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"PopupPositionProvider\"\n        }), \" {\\n    \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"calculatePosition\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(\\n        anchorBounds: \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"IntRect\"\n            }), \",\\n        windowSize: \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"IntSize\"\n            }), \",\\n        layoutDirection: \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"LayoutDirection\"\n            }), \",\\n        popupContentSize: \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"IntSize\"\n            }), \"\\n    )\"]\n          })]\n        }), \": IntOffset\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"제 경우에는 항상 창의 중앙에 위치한 사용자 정의 팝업 위치를 원합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그래서 아래처럼 Position을 쉽게 만들 수 있어요. 여기에는 창의 중앙 위치에 대한 상대적인 OffSet도 있습니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"WindowCenterOffsetPositionProvider\"\n        }), \"(\\n    private val \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"x\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Int\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \",\\n    private val \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"y\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Int\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"\\n) : \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"PopupPositionProvider\"\n        }), \" {\\n    override fun \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"calculatePosition\"\n        }), \"(\\n        \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"anchorBounds\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"IntRect\"\n        }), \",\\n        \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"windowSize\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"IntSize\"\n        }), \",\\n        \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"layoutDirection\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"LayoutDirection\"\n        }), \",\\n        \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"popupContentSize\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"IntSize\"\n        }), \"\\n    ): \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"IntOffset\"\n        }), \" {\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"IntOffset\"\n        }), \"(\\n            (windowSize.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"width\"\n        }), \" - popupContentSize.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"width\"\n        }), \") / \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"2\"\n        }), \" + x,\\n            (windowSize.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"height\"\n        }), \" - popupContentSize.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"height\"\n        }), \") / \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"2\"\n        }), \" + y\\n        )\\n    }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 아래와 같이 Popup에 할당하기만 하면 됩니다. 그러면 그에 맞게 동작합니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"var\"\n        }), \" popupControl \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"by\"\n        }), \" remember { mutableStateOf(\", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"false\"\n        }), \") }\\nTextButton(onClick = { popupControl = \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"true\"\n        }), \" }) {\\n    Text(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"일반 팝업 열기\\\"\"\n        }), \")\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (popupControl) {\\n    Popup(\\n        popupPositionProvider = \\n           WindowCenterOffsetPositionProvider(),\\n        onDismissRequest = { popupControl = \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"false\"\n        }), \" },\\n    ) {\\n      \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 팝업에 표시할 콘텐츠\"\n        }), \"\\n    }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"https://miro.medium.com/v2/resize:fit:476/1*Gd9kg-HENkrcawasnU1IZw.gif\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"여기서 코드 디자인을 얻을 수 있습니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"팝업은 호출자의 Compose 기능이 호출자의 Compose 뷰 경계 밖의 내용을 표시할 수 있게 하는 Jetpack Compose 구성 요소입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"삭제되는 방법, 레이아웃, 호출자 Compose 뷰와의 위치 맞춤과 같이 사용자 정의할 수 있는 여러 팝업 속성이 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"창과 맞춤을 맞출 수 있게 하는 Positioning 같은 위치 지정도 사용자 정의할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"예를 들어 사용 가능한 여러 제한 사항이 있습니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"표시 여부를 결정하는 외부 변수 (팝업 외부의 변수)에 의해 외부에서 제어되어야 합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Composable 함수이므로 onClick 내에서 호출하거나 큐에 넣어 시기적절한 닫기를 할 수 없습니다. (예: 토스트로 만들어 호출), 코루틴 스코프에서.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"위의 제한사항을 고려하여 Popup에서 영향을 받은 사용자 정의 AbstractComposeView를 시도해보려고 합니다. 발견한 내용은 아래와 같습니다.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-18-JetpackComposePopupMasterIt"},"buildId":"ll1cGyplNwh83dpggeai1","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>