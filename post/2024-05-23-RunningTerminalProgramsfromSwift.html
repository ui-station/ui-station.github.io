<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>스위프트로 터미널 프로그램 실행하기 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-05-23-RunningTerminalProgramsfromSwift" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="스위프트로 터미널 프로그램 실행하기 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="스위프트로 터미널 프로그램 실행하기 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-23-RunningTerminalProgramsfromSwift_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-05-23-RunningTerminalProgramsfromSwift" data-gatsby-head="true"/><meta name="twitter:title" content="스위프트로 터미널 프로그램 실행하기 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-23-RunningTerminalProgramsfromSwift_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-23 15:14" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-70e5ce89f3d962ac.js" defer=""></script><script src="/_next/static/JlBEgQDLGRx6DYlBnT8eD/_buildManifest.js" defer=""></script><script src="/_next/static/JlBEgQDLGRx6DYlBnT8eD/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">스위프트로 터미널 프로그램 실행하기</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="스위프트로 터미널 프로그램 실행하기" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 23, 2024</span><span class="posts_reading_time__f7YPP">9<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-23-RunningTerminalProgramsfromSwift&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>스위프트와 명령 줄을 통합하면 개발자가 스위프트 애플리케이션 내에서 쉘 명령어의 기능을 활용할 수 있습니다. 이 기능은 주로 작업 자동화, 스크립트 실행 또는 시스템 수준 기능에 직접 액세스하는 데 유용합니다. 이 기사에서는 실용적인 예제를 사용하여 스위프트에서 터미널 프로그램을 실행하는 방법을 살펴보겠습니다.</p>
<h1>종속성 가져오기</h1>
<p>프로세스 실행에는 Foundation 라이브러리가 필요합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Foundation</span>
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>Foundation 라이브러리는 애플의 개발 생태계의 핵심 부분으로, 필수적인 데이터 유형, 컬렉션 및 운영 체제 서비스를 제공하여 날짜, 시간 및 프로세스와 같은 작업을 관리합니다. Foundation을 사용하여 프로세스를 실행하면 시스템의 명령 줄과 상호 작용하기 위한 강력하고 테스트된 API를 활용할 수 있습니다.</p>
<h1>프로세스 실행</h1>
<p>Swift에서 터미널 애플리케이션을 실행하는 것은 본질적으로 직접 프로그램을 실행하는 대신 zsh와 같은 쉘에서 명령 줄 프로그램을 실행해야 한다는 것을 의미합니다.</p>
<p>따라서 다른 프로그램을 실행하도록 지시하는 /bin/zsh를 실행해야 합니다. 여러분은 bash 스크립트에서처럼 유사한 개념인 #!/bin/bash를 알고 있을 수 있습니다. 이는 “bash를 사용하여 이 프로그램을 실행”을 의미합니다. 이는 터미널과 상호 작용하는 이진 프로그램에 대한 비슷한 개념입니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>본질적으로, 우리는 환경 변수를 전달하여 터미널 프로그램을 실행하도록 Swift에 지시할 것입니다 (예: PATH=/usr/bin, 실행 쉘(예: /bin/zsh), 그리고 실행할 프로그램 및 옵션을 포함한 내용(예: ls ~)):</p>
<p><img src="/assets/img/2024-05-23-RunningTerminalProgramsfromSwift_0.png" alt="Running Terminal Programs from Swift"></p>
<h2>1. 프로세스 설정하기</h2>
<p>우선, Process의 인스턴스를 생성합니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> process = <span class="hljs-title class_">Process</span>();
</code></pre>
<p>Shell 명령어의 실행은 Process 인스턴스에서 처리되며, 출력과 에러 스트림은 Pipe 인스턴스가 캡처합니다.</p>
<h2>2. Process 구성</h2>
<p>다음으로, 인수와 사용할 쉘을 정의합니다. 우리는 zsh 쉘에 명령을 실행하도록 지시할 것이므로, 프로세스의 launchPath를 /bin/zsh로 설정하고 프로그램 및 인수를 쉘의 인수로 -c <code>프로그램 및 인수</code>를 전달할 것입니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> command = <span class="hljs-string">"ls ~"</span>;
process.<span class="hljs-property">launchPath</span> = <span class="hljs-string">"/bin/zsh"</span>; <span class="hljs-comment">// 또는 "/bin/bash" 당신의 셸에 따라 다름</span>
process.<span class="hljs-property">arguments</span> = [<span class="hljs-string">"-c"</span>, command];
</code></pre>
<p>-c 인자는 쉘이 명령어 문자열을 실행하도록 지시합니다. command는 예를 들어 ls ~나 echo "Hello world"와 같은 표준 프로그램 실행을 나타내는 문자열일 수 있습니다.</p>
<p>일부 프로그램은 MacOS의 보안 제약으로 인해 실행할 수 없습니다. 예를 들어, Swift 프로그램에서 /bin/ps를 실행할 수 없는 이유는 특정 보안 제약을 위반하기 때문입니다.</p>
<p>많은 프로그램은 환경 변수가 설정되어야 합니다. 예를 들어, 프로그램이 다른 프로그램을 찾기 위해 PATH 환경 변수에 의존하는 것이 일반적입니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>테이블 태그를 Markdown 형식으로 변경해주세요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> environment = [
  <span class="hljs-string">"TERM"</span>: <span class="hljs-string">"xterm"</span>,
  <span class="hljs-string">"HOME"</span>: <span class="hljs-string">"/Users/example-user/"</span>,
  <span class="hljs-string">"PATH"</span>: <span class="hljs-string">"/opt/homebrew/bin:/opt/homebrew/sbin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin"</span>
]
process.<span class="hljs-property">environment</span> = environment
</code></pre>
<p>터미널에서 env를 실행하여 시스템 환경 변수를 실행 중에 확인할 수 있습니다.</p>
<img src="/assets/img/2024-05-23-RunningTerminalProgramsfromSwift_1.png">
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>3. 프로세스 실행하기</h2>
<p>그런 다음 macOS 버전을 확인하여 Foundation 라이브러리와의 호환성을 보장한 후 프로세스를 실행합니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">if</span> #<span class="hljs-title function_">available</span>(<span class="hljs-params">macOS <span class="hljs-number">13.0</span>, *</span>) {
    <span class="hljs-keyword">try</span>! process.<span class="hljs-title function_">run</span>()
} <span class="hljs-keyword">else</span> {
    process.<span class="hljs-title function_">launch</span>()
}
</code></pre>
<p>macOS 13용 Foundation에서는 응용 프로그램 실행 중 예기치 않은 오류가 발생하면 오류를 throw하는 기능이 도입되었고 .launch() 메서드는 사용이 중단되었습니다. 이러한 이유로 macOS 버전이 13 이상인지 테스트하고 .run() 메서드를 시도하고 이전 버전의 경우 .launch() 메서드로 넘어갈 수 있습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>에러를 잡아내는 것은 사용자나 개발자가 앱이 올바르게 작동하지 않음을 알 수 있는 가장 좋은 방법입니다.</p>
<h1>출력 및 에러 잡기</h1>
<p>출력을 잡기 위해서는 Pipe를 만들고, 이를 프로세스의 출력에 연결해야 합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> pipe = <span class="hljs-title class_">Pipe</span>();
process.<span class="hljs-property">standardOutput</span> = pipe;
process.<span class="hljs-property">standardError</span> = pipe;
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>프로세스가 완료되면, pipe는 프로세스 응답을 바이너리 배열로 수집할 것입니다. 대부분의 터미널 출력은 사람이 읽을 수 있는 텍스트이므로 UTF-8로 인코딩된 문자열로 변환할 수 있습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> data = pipe.<span class="hljs-property">fileHandleForReading</span>.<span class="hljs-title function_">readDataToEndOfFile</span>()
<span class="hljs-keyword">let</span> output = <span class="hljs-title class_">String</span>(<span class="hljs-attr">data</span>: data, <span class="hljs-attr">encoding</span>: .<span class="hljs-property">utf8</span>) ?? <span class="hljs-string">""</span>
</code></pre>
<h2>모두 함께 넣기</h2>
<p>이러한 개념들을 결합하여, 터미널 명령을 실행하고 결과를 반환하는 함수를 만들 수 있습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-swift"><span class="hljs-keyword">func</span> <span class="hljs-title function_">executeProcessAndReturnResult</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">command</span>: <span class="hljs-type">String</span>) -> <span class="hljs-type">String</span> {
  <span class="hljs-keyword">let</span> process <span class="hljs-operator">=</span> <span class="hljs-type">Process</span>()
  <span class="hljs-keyword">let</span> pipe <span class="hljs-operator">=</span> <span class="hljs-type">Pipe</span>()
  <span class="hljs-keyword">let</span> environment <span class="hljs-operator">=</span> [
    <span class="hljs-string">"TERM"</span>: <span class="hljs-string">"xterm"</span>,
    <span class="hljs-string">"HOME"</span>: <span class="hljs-string">"/Users/example-user/"</span>,
    <span class="hljs-string">"PATH"</span>: <span class="hljs-string">"/opt/homebrew/bin:/opt/homebrew/sbin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin"</span>
  ]
  process.standardOutput <span class="hljs-operator">=</span> pipe
  process.standardError <span class="hljs-operator">=</span> pipe
  process.environment <span class="hljs-operator">=</span> environment
  process.launchPath <span class="hljs-operator">=</span> <span class="hljs-string">"/bin/zsh"</span>
  process.arguments <span class="hljs-operator">=</span> [<span class="hljs-string">"-c"</span>, command]
  <span class="hljs-keyword">if</span> <span class="hljs-keyword">#available</span>(<span class="hljs-keyword">macOS</span> <span class="hljs-number">13.0</span>, <span class="hljs-operator">*</span>) {
    <span class="hljs-keyword">try!</span> process.run()
  } <span class="hljs-keyword">else</span> {
    process.launch()
  }
  <span class="hljs-keyword">let</span> data <span class="hljs-operator">=</span> pipe.fileHandleForReading.readDataToEndOfFile()
  <span class="hljs-keyword">let</span> output <span class="hljs-operator">=</span> <span class="hljs-type">String</span>(data: data, encoding: .utf8) <span class="hljs-operator">??</span> <span class="hljs-string">""</span>
  <span class="hljs-keyword">return</span> output
}
</code></pre>
<p>따라서 다른 프로그램에서 이러한 함수를 호출할 수 있습니다. 예를 들어 사용자의 홈 폴더에있는 폴더를 나열하는 프로그램에서 ls ~을 사용하여 호출할 수 있습니다:</p>
<pre><code class="hljs language-swift"><span class="hljs-keyword">let</span> response <span class="hljs-operator">=</span> executeProcessAndReturnResult(<span class="hljs-string">"ls ~"</span>)
<span class="hljs-built_in">print</span>(response)
<span class="hljs-comment">// Desktop Documents Downloads Library Movies Pictures Public</span>
</code></pre>
<h1>데몬 프로세스 시작하기</h1>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>긴 시간이 걸리는 프로세스, 예를 들어 데몬(daemon) 같은 것을 시작하고 주 스레드와 바인딩을 해제하려면, 프로세스를 실행하기 전에 "불확정 상태"로 설정합니다:</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// ... let process = Process()</span>
process.<span class="hljs-title function_">unbind</span>(.<span class="hljs-property">isIndeterminate</span>)
<span class="hljs-comment">// ... process.run()</span>
</code></pre>
<p>이렇게 하면 프로세스가 독립적으로 계속 실행되지만, 앱에서 출력을 캡처하는 것이 더 어려워집니다.</p>
<p>이러한 개념을 결합하여 터미널 명령어를 실행하고 출력을 반환하는 함수를 만들 수 있습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-swift"><span class="hljs-keyword">func</span> <span class="hljs-title function_">executeDaemonProcess</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">command</span>: <span class="hljs-type">String</span>) -> <span class="hljs-type">String</span> {
  <span class="hljs-keyword">let</span> process <span class="hljs-operator">=</span> <span class="hljs-type">Process</span>()
  process.environment <span class="hljs-operator">=</span> environment
  process.launchPath <span class="hljs-operator">=</span> <span class="hljs-string">"/bin/zsh"</span>
  process.arguments <span class="hljs-operator">=</span> [<span class="hljs-string">"-c"</span>, command]
  process.qualityOfService <span class="hljs-operator">=</span> .background
  <span class="hljs-keyword">if</span> <span class="hljs-keyword">#available</span>(<span class="hljs-keyword">macOS</span> <span class="hljs-number">13.0</span>, <span class="hljs-operator">*</span>) {
    <span class="hljs-keyword">try!</span> process.run()
  } <span class="hljs-keyword">else</span> {
    process.launch()
  }
}
</code></pre>
<p>그래서 백그라운드에서 실행되는 이러한 함수를 호출할 수 있습니다. 예를 들어 ~/Public 폴더에서 파일을 제공하는 Python HTTP 서버를 시작할 수 있습니다.</p>
<pre><code class="hljs language-swift">executeDaemonProcess(<span class="hljs-string">"/usr/bin/python3 -m http.server -d ~/Public"</span>)
</code></pre>
<p>이 프로세스를 실행하면 ~/Public 폴더에서 파일을 제공하는 <a href="http://localhost:8080%EC%9D%98" rel="nofollow" target="_blank">http://localhost:8080의</a> 웹 서버가 생성됩니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>결론</h1>
<p>Process 클래스를 사용하여 Swift 프로젝트에서 셸 명령 실행을 원활하게 통합할 수 있습니다. 이 기술을 사용하면 Swift 프로젝트 내에서 커맨드 라인 프로그램 및 RPC의 프론트 엔드를 만들거나 자동화 및 시스템 수준 스크립팅을 수행하는 다양한 가능성이 열립니다.</p>
<p>실제 구현에서는 강제 언래핑을 사용하고 모든 잠재적인 오류 및 예외 상황을 처리해야 함을 기억하세요. 위 예제는 모든 실패 시나리오를 처리하지 않으므로 주의해야 합니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"스위프트로 터미널 프로그램 실행하기","description":"","date":"2024-05-23 15:14","slug":"2024-05-23-RunningTerminalProgramsfromSwift","content":"\n스위프트와 명령 줄을 통합하면 개발자가 스위프트 애플리케이션 내에서 쉘 명령어의 기능을 활용할 수 있습니다. 이 기능은 주로 작업 자동화, 스크립트 실행 또는 시스템 수준 기능에 직접 액세스하는 데 유용합니다. 이 기사에서는 실용적인 예제를 사용하여 스위프트에서 터미널 프로그램을 실행하는 방법을 살펴보겠습니다.\n\n# 종속성 가져오기\n\n프로세스 실행에는 Foundation 라이브러리가 필요합니다.\n\n```js\nimport Foundation\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nFoundation 라이브러리는 애플의 개발 생태계의 핵심 부분으로, 필수적인 데이터 유형, 컬렉션 및 운영 체제 서비스를 제공하여 날짜, 시간 및 프로세스와 같은 작업을 관리합니다. Foundation을 사용하여 프로세스를 실행하면 시스템의 명령 줄과 상호 작용하기 위한 강력하고 테스트된 API를 활용할 수 있습니다.\n\n# 프로세스 실행\n\nSwift에서 터미널 애플리케이션을 실행하는 것은 본질적으로 직접 프로그램을 실행하는 대신 zsh와 같은 쉘에서 명령 줄 프로그램을 실행해야 한다는 것을 의미합니다.\n\n따라서 다른 프로그램을 실행하도록 지시하는 /bin/zsh를 실행해야 합니다. 여러분은 bash 스크립트에서처럼 유사한 개념인 #!/bin/bash를 알고 있을 수 있습니다. 이는 “bash를 사용하여 이 프로그램을 실행”을 의미합니다. 이는 터미널과 상호 작용하는 이진 프로그램에 대한 비슷한 개념입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n본질적으로, 우리는 환경 변수를 전달하여 터미널 프로그램을 실행하도록 Swift에 지시할 것입니다 (예: PATH=/usr/bin, 실행 쉘(예: /bin/zsh), 그리고 실행할 프로그램 및 옵션을 포함한 내용(예: ls ~)):\n\n![Running Terminal Programs from Swift](/assets/img/2024-05-23-RunningTerminalProgramsfromSwift_0.png)\n\n## 1. 프로세스 설정하기\n\n우선, Process의 인스턴스를 생성합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nlet process = Process();\n```\n\nShell 명령어의 실행은 Process 인스턴스에서 처리되며, 출력과 에러 스트림은 Pipe 인스턴스가 캡처합니다.\n\n## 2. Process 구성\n\n다음으로, 인수와 사용할 쉘을 정의합니다. 우리는 zsh 쉘에 명령을 실행하도록 지시할 것이므로, 프로세스의 launchPath를 /bin/zsh로 설정하고 프로그램 및 인수를 쉘의 인수로 -c `프로그램 및 인수`를 전달할 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nlet command = \"ls ~\";\nprocess.launchPath = \"/bin/zsh\"; // 또는 \"/bin/bash\" 당신의 셸에 따라 다름\nprocess.arguments = [\"-c\", command];\n```\n\n-c 인자는 쉘이 명령어 문자열을 실행하도록 지시합니다. command는 예를 들어 ls ~나 echo \"Hello world\"와 같은 표준 프로그램 실행을 나타내는 문자열일 수 있습니다.\n\n일부 프로그램은 MacOS의 보안 제약으로 인해 실행할 수 없습니다. 예를 들어, Swift 프로그램에서 /bin/ps를 실행할 수 없는 이유는 특정 보안 제약을 위반하기 때문입니다.\n\n많은 프로그램은 환경 변수가 설정되어야 합니다. 예를 들어, 프로그램이 다른 프로그램을 찾기 위해 PATH 환경 변수에 의존하는 것이 일반적입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n테이블 태그를 Markdown 형식으로 변경해주세요.\n\n```js\nlet environment = [\n  \"TERM\": \"xterm\",\n  \"HOME\": \"/Users/example-user/\",\n  \"PATH\": \"/opt/homebrew/bin:/opt/homebrew/sbin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin\"\n]\nprocess.environment = environment\n```\n\n터미널에서 env를 실행하여 시스템 환경 변수를 실행 중에 확인할 수 있습니다.\n\n\u003cimg src=\"/assets/img/2024-05-23-RunningTerminalProgramsfromSwift_1.png\" /\u003e\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 3. 프로세스 실행하기\n\n그런 다음 macOS 버전을 확인하여 Foundation 라이브러리와의 호환성을 보장한 후 프로세스를 실행합니다:\n\n```js\nif #available(macOS 13.0, *) {\n    try! process.run()\n} else {\n    process.launch()\n}\n```\n\nmacOS 13용 Foundation에서는 응용 프로그램 실행 중 예기치 않은 오류가 발생하면 오류를 throw하는 기능이 도입되었고 .launch() 메서드는 사용이 중단되었습니다. 이러한 이유로 macOS 버전이 13 이상인지 테스트하고 .run() 메서드를 시도하고 이전 버전의 경우 .launch() 메서드로 넘어갈 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n에러를 잡아내는 것은 사용자나 개발자가 앱이 올바르게 작동하지 않음을 알 수 있는 가장 좋은 방법입니다.\n\n# 출력 및 에러 잡기\n\n출력을 잡기 위해서는 Pipe를 만들고, 이를 프로세스의 출력에 연결해야 합니다.\n\n```js\nlet pipe = Pipe();\nprocess.standardOutput = pipe;\nprocess.standardError = pipe;\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n프로세스가 완료되면, pipe는 프로세스 응답을 바이너리 배열로 수집할 것입니다. 대부분의 터미널 출력은 사람이 읽을 수 있는 텍스트이므로 UTF-8로 인코딩된 문자열로 변환할 수 있습니다:\n\n```js\nlet data = pipe.fileHandleForReading.readDataToEndOfFile()\nlet output = String(data: data, encoding: .utf8) ?? \"\"\n```\n\n## 모두 함께 넣기\n\n이러한 개념들을 결합하여, 터미널 명령을 실행하고 결과를 반환하는 함수를 만들 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```swift\nfunc executeProcessAndReturnResult(_ command: String) -\u003e String {\n  let process = Process()\n  let pipe = Pipe()\n  let environment = [\n    \"TERM\": \"xterm\",\n    \"HOME\": \"/Users/example-user/\",\n    \"PATH\": \"/opt/homebrew/bin:/opt/homebrew/sbin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin\"\n  ]\n  process.standardOutput = pipe\n  process.standardError = pipe\n  process.environment = environment\n  process.launchPath = \"/bin/zsh\"\n  process.arguments = [\"-c\", command]\n  if #available(macOS 13.0, *) {\n    try! process.run()\n  } else {\n    process.launch()\n  }\n  let data = pipe.fileHandleForReading.readDataToEndOfFile()\n  let output = String(data: data, encoding: .utf8) ?? \"\"\n  return output\n}\n```\n\n따라서 다른 프로그램에서 이러한 함수를 호출할 수 있습니다. 예를 들어 사용자의 홈 폴더에있는 폴더를 나열하는 프로그램에서 ls ~을 사용하여 호출할 수 있습니다:\n\n```swift\nlet response = executeProcessAndReturnResult(\"ls ~\")\nprint(response)\n// Desktop Documents Downloads Library Movies Pictures Public\n```\n\n# 데몬 프로세스 시작하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n긴 시간이 걸리는 프로세스, 예를 들어 데몬(daemon) 같은 것을 시작하고 주 스레드와 바인딩을 해제하려면, 프로세스를 실행하기 전에 \"불확정 상태\"로 설정합니다:\n\n```js\n// ... let process = Process()\nprocess.unbind(.isIndeterminate)\n// ... process.run()\n```\n\n이렇게 하면 프로세스가 독립적으로 계속 실행되지만, 앱에서 출력을 캡처하는 것이 더 어려워집니다.\n\n이러한 개념을 결합하여 터미널 명령어를 실행하고 출력을 반환하는 함수를 만들 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```swift\nfunc executeDaemonProcess(_ command: String) -\u003e String {\n  let process = Process()\n  process.environment = environment\n  process.launchPath = \"/bin/zsh\"\n  process.arguments = [\"-c\", command]\n  process.qualityOfService = .background\n  if #available(macOS 13.0, *) {\n    try! process.run()\n  } else {\n    process.launch()\n  }\n}\n```\n\n그래서 백그라운드에서 실행되는 이러한 함수를 호출할 수 있습니다. 예를 들어 ~/Public 폴더에서 파일을 제공하는 Python HTTP 서버를 시작할 수 있습니다.\n\n```swift\nexecuteDaemonProcess(\"/usr/bin/python3 -m http.server -d ~/Public\")\n```\n\n이 프로세스를 실행하면 ~/Public 폴더에서 파일을 제공하는 http://localhost:8080의 웹 서버가 생성됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 결론\n\nProcess 클래스를 사용하여 Swift 프로젝트에서 셸 명령 실행을 원활하게 통합할 수 있습니다. 이 기술을 사용하면 Swift 프로젝트 내에서 커맨드 라인 프로그램 및 RPC의 프론트 엔드를 만들거나 자동화 및 시스템 수준 스크립팅을 수행하는 다양한 가능성이 열립니다.\n\n실제 구현에서는 강제 언래핑을 사용하고 모든 잠재적인 오류 및 예외 상황을 처리해야 함을 기억하세요. 위 예제는 모든 실패 시나리오를 처리하지 않으므로 주의해야 합니다.\n","ogImage":{"url":"/assets/img/2024-05-23-RunningTerminalProgramsfromSwift_0.png"},"coverImage":"/assets/img/2024-05-23-RunningTerminalProgramsfromSwift_0.png","tag":["Tech"],"readingTime":9},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e스위프트와 명령 줄을 통합하면 개발자가 스위프트 애플리케이션 내에서 쉘 명령어의 기능을 활용할 수 있습니다. 이 기능은 주로 작업 자동화, 스크립트 실행 또는 시스템 수준 기능에 직접 액세스하는 데 유용합니다. 이 기사에서는 실용적인 예제를 사용하여 스위프트에서 터미널 프로그램을 실행하는 방법을 살펴보겠습니다.\u003c/p\u003e\n\u003ch1\u003e종속성 가져오기\u003c/h1\u003e\n\u003cp\u003e프로세스 실행에는 Foundation 라이브러리가 필요합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFoundation\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eFoundation 라이브러리는 애플의 개발 생태계의 핵심 부분으로, 필수적인 데이터 유형, 컬렉션 및 운영 체제 서비스를 제공하여 날짜, 시간 및 프로세스와 같은 작업을 관리합니다. Foundation을 사용하여 프로세스를 실행하면 시스템의 명령 줄과 상호 작용하기 위한 강력하고 테스트된 API를 활용할 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e프로세스 실행\u003c/h1\u003e\n\u003cp\u003eSwift에서 터미널 애플리케이션을 실행하는 것은 본질적으로 직접 프로그램을 실행하는 대신 zsh와 같은 쉘에서 명령 줄 프로그램을 실행해야 한다는 것을 의미합니다.\u003c/p\u003e\n\u003cp\u003e따라서 다른 프로그램을 실행하도록 지시하는 /bin/zsh를 실행해야 합니다. 여러분은 bash 스크립트에서처럼 유사한 개념인 #!/bin/bash를 알고 있을 수 있습니다. 이는 “bash를 사용하여 이 프로그램을 실행”을 의미합니다. 이는 터미널과 상호 작용하는 이진 프로그램에 대한 비슷한 개념입니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e본질적으로, 우리는 환경 변수를 전달하여 터미널 프로그램을 실행하도록 Swift에 지시할 것입니다 (예: PATH=/usr/bin, 실행 쉘(예: /bin/zsh), 그리고 실행할 프로그램 및 옵션을 포함한 내용(예: ls ~)):\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-23-RunningTerminalProgramsfromSwift_0.png\" alt=\"Running Terminal Programs from Swift\"\u003e\u003c/p\u003e\n\u003ch2\u003e1. 프로세스 설정하기\u003c/h2\u003e\n\u003cp\u003e우선, Process의 인스턴스를 생성합니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e process = \u003cspan class=\"hljs-title class_\"\u003eProcess\u003c/span\u003e();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eShell 명령어의 실행은 Process 인스턴스에서 처리되며, 출력과 에러 스트림은 Pipe 인스턴스가 캡처합니다.\u003c/p\u003e\n\u003ch2\u003e2. Process 구성\u003c/h2\u003e\n\u003cp\u003e다음으로, 인수와 사용할 쉘을 정의합니다. 우리는 zsh 쉘에 명령을 실행하도록 지시할 것이므로, 프로세스의 launchPath를 /bin/zsh로 설정하고 프로그램 및 인수를 쉘의 인수로 -c \u003ccode\u003e프로그램 및 인수\u003c/code\u003e를 전달할 것입니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e command = \u003cspan class=\"hljs-string\"\u003e\"ls ~\"\u003c/span\u003e;\nprocess.\u003cspan class=\"hljs-property\"\u003elaunchPath\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\"/bin/zsh\"\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// 또는 \"/bin/bash\" 당신의 셸에 따라 다름\u003c/span\u003e\nprocess.\u003cspan class=\"hljs-property\"\u003earguments\u003c/span\u003e = [\u003cspan class=\"hljs-string\"\u003e\"-c\"\u003c/span\u003e, command];\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e-c 인자는 쉘이 명령어 문자열을 실행하도록 지시합니다. command는 예를 들어 ls ~나 echo \"Hello world\"와 같은 표준 프로그램 실행을 나타내는 문자열일 수 있습니다.\u003c/p\u003e\n\u003cp\u003e일부 프로그램은 MacOS의 보안 제약으로 인해 실행할 수 없습니다. 예를 들어, Swift 프로그램에서 /bin/ps를 실행할 수 없는 이유는 특정 보안 제약을 위반하기 때문입니다.\u003c/p\u003e\n\u003cp\u003e많은 프로그램은 환경 변수가 설정되어야 합니다. 예를 들어, 프로그램이 다른 프로그램을 찾기 위해 PATH 환경 변수에 의존하는 것이 일반적입니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e테이블 태그를 Markdown 형식으로 변경해주세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e environment = [\n  \u003cspan class=\"hljs-string\"\u003e\"TERM\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"xterm\"\u003c/span\u003e,\n  \u003cspan class=\"hljs-string\"\u003e\"HOME\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"/Users/example-user/\"\u003c/span\u003e,\n  \u003cspan class=\"hljs-string\"\u003e\"PATH\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"/opt/homebrew/bin:/opt/homebrew/sbin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin\"\u003c/span\u003e\n]\nprocess.\u003cspan class=\"hljs-property\"\u003eenvironment\u003c/span\u003e = environment\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e터미널에서 env를 실행하여 시스템 환경 변수를 실행 중에 확인할 수 있습니다.\u003c/p\u003e\n\u003cimg src=\"/assets/img/2024-05-23-RunningTerminalProgramsfromSwift_1.png\"\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003e3. 프로세스 실행하기\u003c/h2\u003e\n\u003cp\u003e그런 다음 macOS 버전을 확인하여 Foundation 라이브러리와의 호환성을 보장한 후 프로세스를 실행합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e #\u003cspan class=\"hljs-title function_\"\u003eavailable\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003emacOS \u003cspan class=\"hljs-number\"\u003e13.0\u003c/span\u003e, *\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e! process.\u003cspan class=\"hljs-title function_\"\u003erun\u003c/span\u003e()\n} \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    process.\u003cspan class=\"hljs-title function_\"\u003elaunch\u003c/span\u003e()\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003emacOS 13용 Foundation에서는 응용 프로그램 실행 중 예기치 않은 오류가 발생하면 오류를 throw하는 기능이 도입되었고 .launch() 메서드는 사용이 중단되었습니다. 이러한 이유로 macOS 버전이 13 이상인지 테스트하고 .run() 메서드를 시도하고 이전 버전의 경우 .launch() 메서드로 넘어갈 수 있습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e에러를 잡아내는 것은 사용자나 개발자가 앱이 올바르게 작동하지 않음을 알 수 있는 가장 좋은 방법입니다.\u003c/p\u003e\n\u003ch1\u003e출력 및 에러 잡기\u003c/h1\u003e\n\u003cp\u003e출력을 잡기 위해서는 Pipe를 만들고, 이를 프로세스의 출력에 연결해야 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e pipe = \u003cspan class=\"hljs-title class_\"\u003ePipe\u003c/span\u003e();\nprocess.\u003cspan class=\"hljs-property\"\u003estandardOutput\u003c/span\u003e = pipe;\nprocess.\u003cspan class=\"hljs-property\"\u003estandardError\u003c/span\u003e = pipe;\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e프로세스가 완료되면, pipe는 프로세스 응답을 바이너리 배열로 수집할 것입니다. 대부분의 터미널 출력은 사람이 읽을 수 있는 텍스트이므로 UTF-8로 인코딩된 문자열로 변환할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e data = pipe.\u003cspan class=\"hljs-property\"\u003efileHandleForReading\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ereadDataToEndOfFile\u003c/span\u003e()\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e output = \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003edata\u003c/span\u003e: data, \u003cspan class=\"hljs-attr\"\u003eencoding\u003c/span\u003e: .\u003cspan class=\"hljs-property\"\u003eutf8\u003c/span\u003e) ?? \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e모두 함께 넣기\u003c/h2\u003e\n\u003cp\u003e이러한 개념들을 결합하여, 터미널 명령을 실행하고 결과를 반환하는 함수를 만들 수 있습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-swift\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eexecuteProcessAndReturnResult\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003e_\u003c/span\u003e \u003cspan class=\"hljs-params\"\u003ecommand\u003c/span\u003e: \u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e) -\u003e \u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e process \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eProcess\u003c/span\u003e()\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e pipe \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003ePipe\u003c/span\u003e()\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e environment \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e [\n    \u003cspan class=\"hljs-string\"\u003e\"TERM\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"xterm\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"HOME\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"/Users/example-user/\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"PATH\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"/opt/homebrew/bin:/opt/homebrew/sbin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin\"\u003c/span\u003e\n  ]\n  process.standardOutput \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e pipe\n  process.standardError \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e pipe\n  process.environment \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e environment\n  process.launchPath \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"/bin/zsh\"\u003c/span\u003e\n  process.arguments \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e [\u003cspan class=\"hljs-string\"\u003e\"-c\"\u003c/span\u003e, command]\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e#available\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003emacOS\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e13.0\u003c/span\u003e, \u003cspan class=\"hljs-operator\"\u003e*\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003etry!\u003c/span\u003e process.run()\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    process.launch()\n  }\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e data \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e pipe.fileHandleForReading.readDataToEndOfFile()\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e output \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e(data: data, encoding: .utf8) \u003cspan class=\"hljs-operator\"\u003e??\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e output\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e따라서 다른 프로그램에서 이러한 함수를 호출할 수 있습니다. 예를 들어 사용자의 홈 폴더에있는 폴더를 나열하는 프로그램에서 ls ~을 사용하여 호출할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-swift\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e response \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e executeProcessAndReturnResult(\u003cspan class=\"hljs-string\"\u003e\"ls ~\"\u003c/span\u003e)\n\u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(response)\n\u003cspan class=\"hljs-comment\"\u003e// Desktop Documents Downloads Library Movies Pictures Public\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e데몬 프로세스 시작하기\u003c/h1\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e긴 시간이 걸리는 프로세스, 예를 들어 데몬(daemon) 같은 것을 시작하고 주 스레드와 바인딩을 해제하려면, 프로세스를 실행하기 전에 \"불확정 상태\"로 설정합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// ... let process = Process()\u003c/span\u003e\nprocess.\u003cspan class=\"hljs-title function_\"\u003eunbind\u003c/span\u003e(.\u003cspan class=\"hljs-property\"\u003eisIndeterminate\u003c/span\u003e)\n\u003cspan class=\"hljs-comment\"\u003e// ... process.run()\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이렇게 하면 프로세스가 독립적으로 계속 실행되지만, 앱에서 출력을 캡처하는 것이 더 어려워집니다.\u003c/p\u003e\n\u003cp\u003e이러한 개념을 결합하여 터미널 명령어를 실행하고 출력을 반환하는 함수를 만들 수 있습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-swift\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eexecuteDaemonProcess\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003e_\u003c/span\u003e \u003cspan class=\"hljs-params\"\u003ecommand\u003c/span\u003e: \u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e) -\u003e \u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e process \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eProcess\u003c/span\u003e()\n  process.environment \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e environment\n  process.launchPath \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"/bin/zsh\"\u003c/span\u003e\n  process.arguments \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e [\u003cspan class=\"hljs-string\"\u003e\"-c\"\u003c/span\u003e, command]\n  process.qualityOfService \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e .background\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003e#available\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003emacOS\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e13.0\u003c/span\u003e, \u003cspan class=\"hljs-operator\"\u003e*\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003etry!\u003c/span\u003e process.run()\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    process.launch()\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그래서 백그라운드에서 실행되는 이러한 함수를 호출할 수 있습니다. 예를 들어 ~/Public 폴더에서 파일을 제공하는 Python HTTP 서버를 시작할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-swift\"\u003eexecuteDaemonProcess(\u003cspan class=\"hljs-string\"\u003e\"/usr/bin/python3 -m http.server -d ~/Public\"\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 프로세스를 실행하면 ~/Public 폴더에서 파일을 제공하는 \u003ca href=\"http://localhost:8080%EC%9D%98\" rel=\"nofollow\" target=\"_blank\"\u003ehttp://localhost:8080의\u003c/a\u003e 웹 서버가 생성됩니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003eProcess 클래스를 사용하여 Swift 프로젝트에서 셸 명령 실행을 원활하게 통합할 수 있습니다. 이 기술을 사용하면 Swift 프로젝트 내에서 커맨드 라인 프로그램 및 RPC의 프론트 엔드를 만들거나 자동화 및 시스템 수준 스크립팅을 수행하는 다양한 가능성이 열립니다.\u003c/p\u003e\n\u003cp\u003e실제 구현에서는 강제 언래핑을 사용하고 모든 잠재적인 오류 및 예외 상황을 처리해야 함을 기억하세요. 위 예제는 모든 실패 시나리오를 처리하지 않으므로 주의해야 합니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-23-RunningTerminalProgramsfromSwift"},"buildId":"JlBEgQDLGRx6DYlBnT8eD","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>