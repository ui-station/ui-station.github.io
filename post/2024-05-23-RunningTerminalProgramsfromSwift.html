<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>스위프트로 터미널 프로그램 실행하기 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-05-23-RunningTerminalProgramsfromSwift" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="스위프트로 터미널 프로그램 실행하기 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="스위프트로 터미널 프로그램 실행하기 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-23-RunningTerminalProgramsfromSwift_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-05-23-RunningTerminalProgramsfromSwift" data-gatsby-head="true"/><meta name="twitter:title" content="스위프트로 터미널 프로그램 실행하기 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-23-RunningTerminalProgramsfromSwift_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-23 15:14" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-V5DKFTZ6BX"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-V5DKFTZ6BX');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/cd012fc8787133d0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cd012fc8787133d0.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/551-3069cf29fe274aab.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-561ae49ab5aab7f5.js" defer=""></script><script src="/_next/static/PgdIX9e0tvkvkdAmDT6qR/_buildManifest.js" defer=""></script><script src="/_next/static/PgdIX9e0tvkvkdAmDT6qR/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">스위프트로 터미널 프로그램 실행하기</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="스위프트로 터미널 프로그램 실행하기" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 23, 2024</span><span class="posts_reading_time__f7YPP">6<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-23-RunningTerminalProgramsfromSwift&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><p>스위프트와 명령 줄을 통합하면 개발자가 스위프트 애플리케이션 내에서 쉘 명령어의 기능을 활용할 수 있습니다. 이 기능은 주로 작업 자동화, 스크립트 실행 또는 시스템 수준 기능에 직접 액세스하는 데 유용합니다. 이 기사에서는 실용적인 예제를 사용하여 스위프트에서 터미널 프로그램을 실행하는 방법을 살펴보겠습니다.</p>
<h1>종속성 가져오기</h1>
<p>프로세스 실행에는 Foundation 라이브러리가 필요합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Foundation</span>
</code></pre>
<div class="content-ad"></div>
<p>Foundation 라이브러리는 애플의 개발 생태계의 핵심 부분으로, 필수적인 데이터 유형, 컬렉션 및 운영 체제 서비스를 제공하여 날짜, 시간 및 프로세스와 같은 작업을 관리합니다. Foundation을 사용하여 프로세스를 실행하면 시스템의 명령 줄과 상호 작용하기 위한 강력하고 테스트된 API를 활용할 수 있습니다.</p>
<h1>프로세스 실행</h1>
<p>Swift에서 터미널 애플리케이션을 실행하는 것은 본질적으로 직접 프로그램을 실행하는 대신 zsh와 같은 쉘에서 명령 줄 프로그램을 실행해야 한다는 것을 의미합니다.</p>
<p>따라서 다른 프로그램을 실행하도록 지시하는 /bin/zsh를 실행해야 합니다. 여러분은 bash 스크립트에서처럼 유사한 개념인 #!/bin/bash를 알고 있을 수 있습니다. 이는 “bash를 사용하여 이 프로그램을 실행”을 의미합니다. 이는 터미널과 상호 작용하는 이진 프로그램에 대한 비슷한 개념입니다.</p>
<div class="content-ad"></div>
<p>본질적으로, 우리는 환경 변수를 전달하여 터미널 프로그램을 실행하도록 Swift에 지시할 것입니다 (예: PATH=/usr/bin, 실행 쉘(예: /bin/zsh), 그리고 실행할 프로그램 및 옵션을 포함한 내용(예: ls ~)):</p>
<p><img src="/assets/img/2024-05-23-RunningTerminalProgramsfromSwift_0.png" alt="Running Terminal Programs from Swift"/></p>
<h2>1. 프로세스 설정하기</h2>
<p>우선, Process의 인스턴스를 생성합니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> process = <span class="hljs-title class_">Process</span>()
</code></pre>
<p>Shell 명령어의 실행은 Process 인스턴스에서 처리되며, 출력과 에러 스트림은 Pipe 인스턴스가 캡처합니다.</p>
<h2>2. Process 구성</h2>
<p>다음으로, 인수와 사용할 쉘을 정의합니다. 우리는 zsh 쉘에 명령을 실행하도록 지시할 것이므로, 프로세스의 launchPath를 /bin/zsh로 설정하고 프로그램 및 인수를 쉘의 인수로 -c <code>프로그램 및 인수</code>를 전달할 것입니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> command = <span class="hljs-string">&quot;ls ~&quot;</span>
process.<span class="hljs-property">launchPath</span> = <span class="hljs-string">&quot;/bin/zsh&quot;</span> <span class="hljs-comment">// 또는 &quot;/bin/bash&quot; 당신의 셸에 따라 다름</span>
process.<span class="hljs-property">arguments</span> = [<span class="hljs-string">&quot;-c&quot;</span>, command]
</code></pre>
<p>-c 인자는 쉘이 명령어 문자열을 실행하도록 지시합니다. command는 예를 들어 ls ~나 echo &quot;Hello world&quot;와 같은 표준 프로그램 실행을 나타내는 문자열일 수 있습니다.</p>
<p>일부 프로그램은 MacOS의 보안 제약으로 인해 실행할 수 없습니다. 예를 들어, Swift 프로그램에서 /bin/ps를 실행할 수 없는 이유는 특정 보안 제약을 위반하기 때문입니다.</p>
<p>많은 프로그램은 환경 변수가 설정되어야 합니다. 예를 들어, 프로그램이 다른 프로그램을 찾기 위해 PATH 환경 변수에 의존하는 것이 일반적입니다.</p>
<div class="content-ad"></div>
<p>테이블 태그를 Markdown 형식으로 변경해주세요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> environment = [
  <span class="hljs-string">&quot;TERM&quot;</span>: <span class="hljs-string">&quot;xterm&quot;</span>,
  <span class="hljs-string">&quot;HOME&quot;</span>: <span class="hljs-string">&quot;/Users/example-user/&quot;</span>,
  <span class="hljs-string">&quot;PATH&quot;</span>: <span class="hljs-string">&quot;/opt/homebrew/bin:/opt/homebrew/sbin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin&quot;</span>
]
process.<span class="hljs-property">environment</span> = environment
</code></pre>
<p>터미널에서 env를 실행하여 시스템 환경 변수를 실행 중에 확인할 수 있습니다.</p>
<img src="/assets/img/2024-05-23-RunningTerminalProgramsfromSwift_1.png"/>
<div class="content-ad"></div>
<h2>3. 프로세스 실행하기</h2>
<p>그런 다음 macOS 버전을 확인하여 Foundation 라이브러리와의 호환성을 보장한 후 프로세스를 실행합니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">if</span> #<span class="hljs-title function_">available</span>(<span class="hljs-params">macOS <span class="hljs-number">13.0</span>, *</span>) {
    <span class="hljs-keyword">try</span>! process.<span class="hljs-title function_">run</span>()
} <span class="hljs-keyword">else</span> {
    process.<span class="hljs-title function_">launch</span>()
}
</code></pre>
<p>macOS 13용 Foundation에서는 응용 프로그램 실행 중 예기치 않은 오류가 발생하면 오류를 throw하는 기능이 도입되었고 .launch() 메서드는 사용이 중단되었습니다. 이러한 이유로 macOS 버전이 13 이상인지 테스트하고 .run() 메서드를 시도하고 이전 버전의 경우 .launch() 메서드로 넘어갈 수 있습니다.</p>
<div class="content-ad"></div>
<p>에러를 잡아내는 것은 사용자나 개발자가 앱이 올바르게 작동하지 않음을 알 수 있는 가장 좋은 방법입니다.</p>
<h1>출력 및 에러 잡기</h1>
<p>출력을 잡기 위해서는 Pipe를 만들고, 이를 프로세스의 출력에 연결해야 합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> pipe = <span class="hljs-title class_">Pipe</span>();
process.<span class="hljs-property">standardOutput</span> = pipe;
process.<span class="hljs-property">standardError</span> = pipe;
</code></pre>
<div class="content-ad"></div>
<p>프로세스가 완료되면, pipe는 프로세스 응답을 바이너리 배열로 수집할 것입니다. 대부분의 터미널 출력은 사람이 읽을 수 있는 텍스트이므로 UTF-8로 인코딩된 문자열로 변환할 수 있습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> data = pipe.<span class="hljs-property">fileHandleForReading</span>.<span class="hljs-title function_">readDataToEndOfFile</span>()
<span class="hljs-keyword">let</span> output = <span class="hljs-title class_">String</span>(<span class="hljs-attr">data</span>: data, <span class="hljs-attr">encoding</span>: .<span class="hljs-property">utf8</span>) ?? <span class="hljs-string">&quot;&quot;</span>
</code></pre>
<h2>모두 함께 넣기</h2>
<p>이러한 개념들을 결합하여, 터미널 명령을 실행하고 결과를 반환하는 함수를 만들 수 있습니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-swift"><span class="hljs-keyword">func</span> <span class="hljs-title function_">executeProcessAndReturnResult</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">command</span>: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">String</span> {
  <span class="hljs-keyword">let</span> process <span class="hljs-operator">=</span> <span class="hljs-type">Process</span>()
  <span class="hljs-keyword">let</span> pipe <span class="hljs-operator">=</span> <span class="hljs-type">Pipe</span>()
  <span class="hljs-keyword">let</span> environment <span class="hljs-operator">=</span> [
    <span class="hljs-string">&quot;TERM&quot;</span>: <span class="hljs-string">&quot;xterm&quot;</span>,
    <span class="hljs-string">&quot;HOME&quot;</span>: <span class="hljs-string">&quot;/Users/example-user/&quot;</span>,
    <span class="hljs-string">&quot;PATH&quot;</span>: <span class="hljs-string">&quot;/opt/homebrew/bin:/opt/homebrew/sbin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin&quot;</span>
  ]
  process.standardOutput <span class="hljs-operator">=</span> pipe
  process.standardError <span class="hljs-operator">=</span> pipe
  process.environment <span class="hljs-operator">=</span> environment
  process.launchPath <span class="hljs-operator">=</span> <span class="hljs-string">&quot;/bin/zsh&quot;</span>
  process.arguments <span class="hljs-operator">=</span> [<span class="hljs-string">&quot;-c&quot;</span>, command]
  <span class="hljs-keyword">if</span> <span class="hljs-keyword">#available</span>(<span class="hljs-keyword">macOS</span> <span class="hljs-number">13.0</span>, <span class="hljs-operator">*</span>) {
    <span class="hljs-keyword">try!</span> process.run()
  } <span class="hljs-keyword">else</span> {
    process.launch()
  }
  <span class="hljs-keyword">let</span> data <span class="hljs-operator">=</span> pipe.fileHandleForReading.readDataToEndOfFile()
  <span class="hljs-keyword">let</span> output <span class="hljs-operator">=</span> <span class="hljs-type">String</span>(data: data, encoding: .utf8) <span class="hljs-operator">??</span> <span class="hljs-string">&quot;&quot;</span>
  <span class="hljs-keyword">return</span> output
}
</code></pre>
<p>따라서 다른 프로그램에서 이러한 함수를 호출할 수 있습니다. 예를 들어 사용자의 홈 폴더에있는 폴더를 나열하는 프로그램에서 ls ~을 사용하여 호출할 수 있습니다:</p>
<pre><code class="hljs language-swift"><span class="hljs-keyword">let</span> response <span class="hljs-operator">=</span> executeProcessAndReturnResult(<span class="hljs-string">&quot;ls ~&quot;</span>)
<span class="hljs-built_in">print</span>(response)
<span class="hljs-comment">// Desktop Documents Downloads Library Movies Pictures Public</span>
</code></pre>
<h1>데몬 프로세스 시작하기</h1>
<div class="content-ad"></div>
<p>긴 시간이 걸리는 프로세스, 예를 들어 데몬(daemon) 같은 것을 시작하고 주 스레드와 바인딩을 해제하려면, 프로세스를 실행하기 전에 &quot;불확정 상태&quot;로 설정합니다:</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// ... let process = Process()</span>
process.<span class="hljs-title function_">unbind</span>(.<span class="hljs-property">isIndeterminate</span>)
<span class="hljs-comment">// ... process.run()</span>
</code></pre>
<p>이렇게 하면 프로세스가 독립적으로 계속 실행되지만, 앱에서 출력을 캡처하는 것이 더 어려워집니다.</p>
<p>이러한 개념을 결합하여 터미널 명령어를 실행하고 출력을 반환하는 함수를 만들 수 있습니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-swift"><span class="hljs-keyword">func</span> <span class="hljs-title function_">executeDaemonProcess</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">command</span>: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">String</span> {
  <span class="hljs-keyword">let</span> process <span class="hljs-operator">=</span> <span class="hljs-type">Process</span>()
  process.environment <span class="hljs-operator">=</span> environment
  process.launchPath <span class="hljs-operator">=</span> <span class="hljs-string">&quot;/bin/zsh&quot;</span>
  process.arguments <span class="hljs-operator">=</span> [<span class="hljs-string">&quot;-c&quot;</span>, command]
  process.qualityOfService <span class="hljs-operator">=</span> .background
  <span class="hljs-keyword">if</span> <span class="hljs-keyword">#available</span>(<span class="hljs-keyword">macOS</span> <span class="hljs-number">13.0</span>, <span class="hljs-operator">*</span>) {
    <span class="hljs-keyword">try!</span> process.run()
  } <span class="hljs-keyword">else</span> {
    process.launch()
  }
}
</code></pre>
<p>그래서 백그라운드에서 실행되는 이러한 함수를 호출할 수 있습니다. 예를 들어 ~/Public 폴더에서 파일을 제공하는 Python HTTP 서버를 시작할 수 있습니다.</p>
<pre><code class="hljs language-swift">executeDaemonProcess(<span class="hljs-string">&quot;/usr/bin/python3 -m http.server -d ~/Public&quot;</span>)
</code></pre>
<p>이 프로세스를 실행하면 ~/Public 폴더에서 파일을 제공하는 http://localhost:8080의 웹 서버가 생성됩니다.</p>
<div class="content-ad"></div>
<h1>결론</h1>
<p>Process 클래스를 사용하여 Swift 프로젝트에서 셸 명령 실행을 원활하게 통합할 수 있습니다. 이 기술을 사용하면 Swift 프로젝트 내에서 커맨드 라인 프로그램 및 RPC의 프론트 엔드를 만들거나 자동화 및 시스템 수준 스크립팅을 수행하는 다양한 가능성이 열립니다.</p>
<p>실제 구현에서는 강제 언래핑을 사용하고 모든 잠재적인 오류 및 예외 상황을 처리해야 함을 기억하세요. 위 예제는 모든 실패 시나리오를 처리하지 않으므로 주의해야 합니다.</p></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"스위프트로 터미널 프로그램 실행하기","description":"","date":"2024-05-23 15:14","slug":"2024-05-23-RunningTerminalProgramsfromSwift","content":"\n스위프트와 명령 줄을 통합하면 개발자가 스위프트 애플리케이션 내에서 쉘 명령어의 기능을 활용할 수 있습니다. 이 기능은 주로 작업 자동화, 스크립트 실행 또는 시스템 수준 기능에 직접 액세스하는 데 유용합니다. 이 기사에서는 실용적인 예제를 사용하여 스위프트에서 터미널 프로그램을 실행하는 방법을 살펴보겠습니다.\n\n# 종속성 가져오기\n\n프로세스 실행에는 Foundation 라이브러리가 필요합니다.\n\n```js\nimport Foundation\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nFoundation 라이브러리는 애플의 개발 생태계의 핵심 부분으로, 필수적인 데이터 유형, 컬렉션 및 운영 체제 서비스를 제공하여 날짜, 시간 및 프로세스와 같은 작업을 관리합니다. Foundation을 사용하여 프로세스를 실행하면 시스템의 명령 줄과 상호 작용하기 위한 강력하고 테스트된 API를 활용할 수 있습니다.\n\n# 프로세스 실행\n\nSwift에서 터미널 애플리케이션을 실행하는 것은 본질적으로 직접 프로그램을 실행하는 대신 zsh와 같은 쉘에서 명령 줄 프로그램을 실행해야 한다는 것을 의미합니다.\n\n따라서 다른 프로그램을 실행하도록 지시하는 /bin/zsh를 실행해야 합니다. 여러분은 bash 스크립트에서처럼 유사한 개념인 #!/bin/bash를 알고 있을 수 있습니다. 이는 “bash를 사용하여 이 프로그램을 실행”을 의미합니다. 이는 터미널과 상호 작용하는 이진 프로그램에 대한 비슷한 개념입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n본질적으로, 우리는 환경 변수를 전달하여 터미널 프로그램을 실행하도록 Swift에 지시할 것입니다 (예: PATH=/usr/bin, 실행 쉘(예: /bin/zsh), 그리고 실행할 프로그램 및 옵션을 포함한 내용(예: ls ~)):\n\n![Running Terminal Programs from Swift](/assets/img/2024-05-23-RunningTerminalProgramsfromSwift_0.png)\n\n## 1. 프로세스 설정하기\n\n우선, Process의 인스턴스를 생성합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nlet process = Process()\n```\n\nShell 명령어의 실행은 Process 인스턴스에서 처리되며, 출력과 에러 스트림은 Pipe 인스턴스가 캡처합니다.\n\n## 2. Process 구성\n\n다음으로, 인수와 사용할 쉘을 정의합니다. 우리는 zsh 쉘에 명령을 실행하도록 지시할 것이므로, 프로세스의 launchPath를 /bin/zsh로 설정하고 프로그램 및 인수를 쉘의 인수로 -c `프로그램 및 인수`를 전달할 것입니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nlet command = \"ls ~\"\nprocess.launchPath = \"/bin/zsh\" // 또는 \"/bin/bash\" 당신의 셸에 따라 다름\nprocess.arguments = [\"-c\", command]\n```\n\n-c 인자는 쉘이 명령어 문자열을 실행하도록 지시합니다. command는 예를 들어 ls ~나 echo \"Hello world\"와 같은 표준 프로그램 실행을 나타내는 문자열일 수 있습니다.\n\n일부 프로그램은 MacOS의 보안 제약으로 인해 실행할 수 없습니다. 예를 들어, Swift 프로그램에서 /bin/ps를 실행할 수 없는 이유는 특정 보안 제약을 위반하기 때문입니다.\n\n많은 프로그램은 환경 변수가 설정되어야 합니다. 예를 들어, 프로그램이 다른 프로그램을 찾기 위해 PATH 환경 변수에 의존하는 것이 일반적입니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테이블 태그를 Markdown 형식으로 변경해주세요.\n\n```js\nlet environment = [\n  \"TERM\": \"xterm\",\n  \"HOME\": \"/Users/example-user/\",\n  \"PATH\": \"/opt/homebrew/bin:/opt/homebrew/sbin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin\"\n]\nprocess.environment = environment\n````\n\n터미널에서 env를 실행하여 시스템 환경 변수를 실행 중에 확인할 수 있습니다.\n\n\u003cimg src=\"/assets/img/2024-05-23-RunningTerminalProgramsfromSwift_1.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 3. 프로세스 실행하기\n\n그런 다음 macOS 버전을 확인하여 Foundation 라이브러리와의 호환성을 보장한 후 프로세스를 실행합니다:\n\n```js\nif #available(macOS 13.0, *) {\n    try! process.run()\n} else {\n    process.launch()\n}\n```\n\nmacOS 13용 Foundation에서는 응용 프로그램 실행 중 예기치 않은 오류가 발생하면 오류를 throw하는 기능이 도입되었고 .launch() 메서드는 사용이 중단되었습니다. 이러한 이유로 macOS 버전이 13 이상인지 테스트하고 .run() 메서드를 시도하고 이전 버전의 경우 .launch() 메서드로 넘어갈 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n에러를 잡아내는 것은 사용자나 개발자가 앱이 올바르게 작동하지 않음을 알 수 있는 가장 좋은 방법입니다.\n\n# 출력 및 에러 잡기\n\n출력을 잡기 위해서는 Pipe를 만들고, 이를 프로세스의 출력에 연결해야 합니다.\n\n```js\nlet pipe = Pipe();\nprocess.standardOutput = pipe;\nprocess.standardError = pipe;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프로세스가 완료되면, pipe는 프로세스 응답을 바이너리 배열로 수집할 것입니다. 대부분의 터미널 출력은 사람이 읽을 수 있는 텍스트이므로 UTF-8로 인코딩된 문자열로 변환할 수 있습니다:\n\n```js\nlet data = pipe.fileHandleForReading.readDataToEndOfFile()\nlet output = String(data: data, encoding: .utf8) ?? \"\"\n```\n\n## 모두 함께 넣기\n\n이러한 개념들을 결합하여, 터미널 명령을 실행하고 결과를 반환하는 함수를 만들 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```swift\nfunc executeProcessAndReturnResult(_ command: String) -\u003e String {\n  let process = Process()\n  let pipe = Pipe()\n  let environment = [\n    \"TERM\": \"xterm\",\n    \"HOME\": \"/Users/example-user/\",\n    \"PATH\": \"/opt/homebrew/bin:/opt/homebrew/sbin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin\"\n  ]\n  process.standardOutput = pipe\n  process.standardError = pipe\n  process.environment = environment\n  process.launchPath = \"/bin/zsh\"\n  process.arguments = [\"-c\", command]\n  if #available(macOS 13.0, *) {\n    try! process.run()\n  } else {\n    process.launch()\n  }\n  let data = pipe.fileHandleForReading.readDataToEndOfFile()\n  let output = String(data: data, encoding: .utf8) ?? \"\"\n  return output\n}\n```\n\n따라서 다른 프로그램에서 이러한 함수를 호출할 수 있습니다. 예를 들어 사용자의 홈 폴더에있는 폴더를 나열하는 프로그램에서 ls ~을 사용하여 호출할 수 있습니다:\n\n```swift\nlet response = executeProcessAndReturnResult(\"ls ~\")\nprint(response)\n// Desktop Documents Downloads Library Movies Pictures Public\n```\n\n# 데몬 프로세스 시작하기\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n긴 시간이 걸리는 프로세스, 예를 들어 데몬(daemon) 같은 것을 시작하고 주 스레드와 바인딩을 해제하려면, 프로세스를 실행하기 전에 \"불확정 상태\"로 설정합니다:\n\n```js\n// ... let process = Process()\nprocess.unbind(.isIndeterminate)\n// ... process.run()\n````\n\n이렇게 하면 프로세스가 독립적으로 계속 실행되지만, 앱에서 출력을 캡처하는 것이 더 어려워집니다.\n\n이러한 개념을 결합하여 터미널 명령어를 실행하고 출력을 반환하는 함수를 만들 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```swift\nfunc executeDaemonProcess(_ command: String) -\u003e String {\n  let process = Process()\n  process.environment = environment\n  process.launchPath = \"/bin/zsh\"\n  process.arguments = [\"-c\", command]\n  process.qualityOfService = .background\n  if #available(macOS 13.0, *) {\n    try! process.run()\n  } else {\n    process.launch()\n  }\n}\n```\n\n그래서 백그라운드에서 실행되는 이러한 함수를 호출할 수 있습니다. 예를 들어 ~/Public 폴더에서 파일을 제공하는 Python HTTP 서버를 시작할 수 있습니다.\n\n```swift\nexecuteDaemonProcess(\"/usr/bin/python3 -m http.server -d ~/Public\")\n```\n\n이 프로세스를 실행하면 ~/Public 폴더에서 파일을 제공하는 http://localhost:8080의 웹 서버가 생성됩니다.\n\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\nProcess 클래스를 사용하여 Swift 프로젝트에서 셸 명령 실행을 원활하게 통합할 수 있습니다. 이 기술을 사용하면 Swift 프로젝트 내에서 커맨드 라인 프로그램 및 RPC의 프론트 엔드를 만들거나 자동화 및 시스템 수준 스크립팅을 수행하는 다양한 가능성이 열립니다.\n\n실제 구현에서는 강제 언래핑을 사용하고 모든 잠재적인 오류 및 예외 상황을 처리해야 함을 기억하세요. 위 예제는 모든 실패 시나리오를 처리하지 않으므로 주의해야 합니다.\n\n","ogImage":{"url":"/assets/img/2024-05-23-RunningTerminalProgramsfromSwift_0.png"},"coverImage":"/assets/img/2024-05-23-RunningTerminalProgramsfromSwift_0.png","tag":["Tech"],"readingTime":6},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    h1: \"h1\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\",\n    img: \"img\",\n    h2: \"h2\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"스위프트와 명령 줄을 통합하면 개발자가 스위프트 애플리케이션 내에서 쉘 명령어의 기능을 활용할 수 있습니다. 이 기능은 주로 작업 자동화, 스크립트 실행 또는 시스템 수준 기능에 직접 액세스하는 데 유용합니다. 이 기사에서는 실용적인 예제를 사용하여 스위프트에서 터미널 프로그램을 실행하는 방법을 살펴보겠습니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"종속성 가져오기\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"프로세스 실행에는 Foundation 라이브러리가 필요합니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Foundation\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Foundation 라이브러리는 애플의 개발 생태계의 핵심 부분으로, 필수적인 데이터 유형, 컬렉션 및 운영 체제 서비스를 제공하여 날짜, 시간 및 프로세스와 같은 작업을 관리합니다. Foundation을 사용하여 프로세스를 실행하면 시스템의 명령 줄과 상호 작용하기 위한 강력하고 테스트된 API를 활용할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"프로세스 실행\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Swift에서 터미널 애플리케이션을 실행하는 것은 본질적으로 직접 프로그램을 실행하는 대신 zsh와 같은 쉘에서 명령 줄 프로그램을 실행해야 한다는 것을 의미합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"따라서 다른 프로그램을 실행하도록 지시하는 /bin/zsh를 실행해야 합니다. 여러분은 bash 스크립트에서처럼 유사한 개념인 #!/bin/bash를 알고 있을 수 있습니다. 이는 “bash를 사용하여 이 프로그램을 실행”을 의미합니다. 이는 터미널과 상호 작용하는 이진 프로그램에 대한 비슷한 개념입니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"본질적으로, 우리는 환경 변수를 전달하여 터미널 프로그램을 실행하도록 Swift에 지시할 것입니다 (예: PATH=/usr/bin, 실행 쉘(예: /bin/zsh), 그리고 실행할 프로그램 및 옵션을 포함한 내용(예: ls ~)):\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-23-RunningTerminalProgramsfromSwift_0.png\",\n        alt: \"Running Terminal Programs from Swift\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"1. 프로세스 설정하기\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우선, Process의 인스턴스를 생성합니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" process = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Process\"\n        }), \"()\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Shell 명령어의 실행은 Process 인스턴스에서 처리되며, 출력과 에러 스트림은 Pipe 인스턴스가 캡처합니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"2. Process 구성\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"다음으로, 인수와 사용할 쉘을 정의합니다. 우리는 zsh 쉘에 명령을 실행하도록 지시할 것이므로, 프로세스의 launchPath를 /bin/zsh로 설정하고 프로그램 및 인수를 쉘의 인수로 -c \", _jsx(_components.code, {\n        children: \"프로그램 및 인수\"\n      }), \"를 전달할 것입니다.\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" command = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"ls ~\\\"\"\n        }), \"\\nprocess.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"launchPath\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"/bin/zsh\\\"\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 또는 \\\"/bin/bash\\\" 당신의 셸에 따라 다름\"\n        }), \"\\nprocess.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"arguments\"\n        }), \" = [\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"-c\\\"\"\n        }), \", command]\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"-c 인자는 쉘이 명령어 문자열을 실행하도록 지시합니다. command는 예를 들어 ls ~나 echo \\\"Hello world\\\"와 같은 표준 프로그램 실행을 나타내는 문자열일 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"일부 프로그램은 MacOS의 보안 제약으로 인해 실행할 수 없습니다. 예를 들어, Swift 프로그램에서 /bin/ps를 실행할 수 없는 이유는 특정 보안 제약을 위반하기 때문입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"많은 프로그램은 환경 변수가 설정되어야 합니다. 예를 들어, 프로그램이 다른 프로그램을 찾기 위해 PATH 환경 변수에 의존하는 것이 일반적입니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"테이블 태그를 Markdown 형식으로 변경해주세요.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" environment = [\\n  \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"TERM\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"xterm\\\"\"\n        }), \",\\n  \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"HOME\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"/Users/example-user/\\\"\"\n        }), \",\\n  \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"PATH\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"/opt/homebrew/bin:/opt/homebrew/sbin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin\\\"\"\n        }), \"\\n]\\nprocess.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"environment\"\n        }), \" = environment\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"터미널에서 env를 실행하여 시스템 환경 변수를 실행 중에 확인할 수 있습니다.\"\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/assets/img/2024-05-23-RunningTerminalProgramsfromSwift_1.png\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"3. 프로세스 실행하기\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그런 다음 macOS 버전을 확인하여 Foundation 라이브러리와의 호환성을 보장한 후 프로세스를 실행합니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" #\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"available\"\n        }), \"(\", _jsxs(_components.span, {\n          className: \"hljs-params\",\n          children: [\"macOS \", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"13.0\"\n          }), \", *\"]\n        }), \") {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"try\"\n        }), \"! process.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"run\"\n        }), \"()\\n} \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"else\"\n        }), \" {\\n    process.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"launch\"\n        }), \"()\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"macOS 13용 Foundation에서는 응용 프로그램 실행 중 예기치 않은 오류가 발생하면 오류를 throw하는 기능이 도입되었고 .launch() 메서드는 사용이 중단되었습니다. 이러한 이유로 macOS 버전이 13 이상인지 테스트하고 .run() 메서드를 시도하고 이전 버전의 경우 .launch() 메서드로 넘어갈 수 있습니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"에러를 잡아내는 것은 사용자나 개발자가 앱이 올바르게 작동하지 않음을 알 수 있는 가장 좋은 방법입니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"출력 및 에러 잡기\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"출력을 잡기 위해서는 Pipe를 만들고, 이를 프로세스의 출력에 연결해야 합니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" pipe = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Pipe\"\n        }), \"();\\nprocess.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"standardOutput\"\n        }), \" = pipe;\\nprocess.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"standardError\"\n        }), \" = pipe;\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"프로세스가 완료되면, pipe는 프로세스 응답을 바이너리 배열로 수집할 것입니다. 대부분의 터미널 출력은 사람이 읽을 수 있는 텍스트이므로 UTF-8로 인코딩된 문자열로 변환할 수 있습니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" data = pipe.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"fileHandleForReading\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"readDataToEndOfFile\"\n        }), \"()\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" output = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"String\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"data\"\n        }), \": data, \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"encoding\"\n        }), \": .\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"utf8\"\n        }), \") ?? \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\\\"\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"모두 함께 넣기\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이러한 개념들을 결합하여, 터미널 명령을 실행하고 결과를 반환하는 함수를 만들 수 있습니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-swift\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"func\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"executeProcessAndReturnResult\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"_\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"command\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"String\"\n        }), \") -\u003e \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"String\"\n        }), \" {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" process \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"Process\"\n        }), \"()\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" pipe \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"Pipe\"\n        }), \"()\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" environment \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" [\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"TERM\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"xterm\\\"\"\n        }), \",\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"HOME\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"/Users/example-user/\\\"\"\n        }), \",\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"PATH\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"/opt/homebrew/bin:/opt/homebrew/sbin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin\\\"\"\n        }), \"\\n  ]\\n  process.standardOutput \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" pipe\\n  process.standardError \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" pipe\\n  process.environment \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" environment\\n  process.launchPath \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"/bin/zsh\\\"\"\n        }), \"\\n  process.arguments \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" [\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"-c\\\"\"\n        }), \", command]\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"#available\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"macOS\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"13.0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"*\"\n        }), \") {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"try!\"\n        }), \" process.run()\\n  } \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"else\"\n        }), \" {\\n    process.launch()\\n  }\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" data \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" pipe.fileHandleForReading.readDataToEndOfFile()\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" output \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"String\"\n        }), \"(data: data, encoding: .utf8) \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"??\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\\\"\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" output\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"따라서 다른 프로그램에서 이러한 함수를 호출할 수 있습니다. 예를 들어 사용자의 홈 폴더에있는 폴더를 나열하는 프로그램에서 ls ~을 사용하여 호출할 수 있습니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-swift\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" response \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" executeProcessAndReturnResult(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"ls ~\\\"\"\n        }), \")\\n\", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"print\"\n        }), \"(response)\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// Desktop Documents Downloads Library Movies Pictures Public\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"데몬 프로세스 시작하기\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"긴 시간이 걸리는 프로세스, 예를 들어 데몬(daemon) 같은 것을 시작하고 주 스레드와 바인딩을 해제하려면, 프로세스를 실행하기 전에 \\\"불확정 상태\\\"로 설정합니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// ... let process = Process()\"\n        }), \"\\nprocess.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"unbind\"\n        }), \"(.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"isIndeterminate\"\n        }), \")\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// ... process.run()\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이렇게 하면 프로세스가 독립적으로 계속 실행되지만, 앱에서 출력을 캡처하는 것이 더 어려워집니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이러한 개념을 결합하여 터미널 명령어를 실행하고 출력을 반환하는 함수를 만들 수 있습니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-swift\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"func\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"executeDaemonProcess\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"_\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"command\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"String\"\n        }), \") -\u003e \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"String\"\n        }), \" {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" process \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"Process\"\n        }), \"()\\n  process.environment \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" environment\\n  process.launchPath \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"/bin/zsh\\\"\"\n        }), \"\\n  process.arguments \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" [\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"-c\\\"\"\n        }), \", command]\\n  process.qualityOfService \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" .background\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"#available\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"macOS\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"13.0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"*\"\n        }), \") {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"try!\"\n        }), \" process.run()\\n  } \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"else\"\n        }), \" {\\n    process.launch()\\n  }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그래서 백그라운드에서 실행되는 이러한 함수를 호출할 수 있습니다. 예를 들어 ~/Public 폴더에서 파일을 제공하는 Python HTTP 서버를 시작할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-swift\",\n        children: [\"executeDaemonProcess(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"/usr/bin/python3 -m http.server -d ~/Public\\\"\"\n        }), \")\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 프로세스를 실행하면 ~/Public 폴더에서 파일을 제공하는 http://localhost:8080의 웹 서버가 생성됩니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"결론\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Process 클래스를 사용하여 Swift 프로젝트에서 셸 명령 실행을 원활하게 통합할 수 있습니다. 이 기술을 사용하면 Swift 프로젝트 내에서 커맨드 라인 프로그램 및 RPC의 프론트 엔드를 만들거나 자동화 및 시스템 수준 스크립팅을 수행하는 다양한 가능성이 열립니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"실제 구현에서는 강제 언래핑을 사용하고 모든 잠재적인 오류 및 예외 상황을 처리해야 함을 기억하세요. 위 예제는 모든 실패 시나리오를 처리하지 않으므로 주의해야 합니다.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-23-RunningTerminalProgramsfromSwift"},"buildId":"PgdIX9e0tvkvkdAmDT6qR","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>