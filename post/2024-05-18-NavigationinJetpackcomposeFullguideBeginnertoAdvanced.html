<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Jetpack Compose 내비게이션 초보부터 고급까지 전체 가이드 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-05-18-NavigationinJetpackcomposeFullguideBeginnertoAdvanced" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Jetpack Compose 내비게이션 초보부터 고급까지 전체 가이드 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="Jetpack Compose 내비게이션 초보부터 고급까지 전체 가이드 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-18-NavigationinJetpackcomposeFullguideBeginnertoAdvanced_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-05-18-NavigationinJetpackcomposeFullguideBeginnertoAdvanced" data-gatsby-head="true"/><meta name="twitter:title" content="Jetpack Compose 내비게이션 초보부터 고급까지 전체 가이드 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-18-NavigationinJetpackcomposeFullguideBeginnertoAdvanced_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-18 17:13" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/acd99c507555fdc6.css" as="style"/><link rel="stylesheet" href="/_next/static/css/acd99c507555fdc6.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-4f7b40c1114f0d09.js" defer=""></script><script src="/_next/static/RZIEBQ2aNAp_DXFVTV6eL/_buildManifest.js" defer=""></script><script src="/_next/static/RZIEBQ2aNAp_DXFVTV6eL/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Jetpack Compose 내비게이션 초보부터 고급까지 전체 가이드</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Jetpack Compose 내비게이션 초보부터 고급까지 전체 가이드" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 18, 2024</span><span class="posts_reading_time__f7YPP">19<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-18-NavigationinJetpackcomposeFullguideBeginnertoAdvanced&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>아래는 Markdown 형식으로 변환되었습니다.</p>
<p><img src="/assets/img/2024-05-18-NavigationinJetpackcomposeFullguideBeginnertoAdvanced_0.png" alt="이미지"></p>
<h1>안드로이드에서의 네비게이션은 무엇인가요?</h1>
<p>네비게이션은 애플리케이션의 다른 구성 요소 간에 이동하는 방법을 이해하는 데 도움이 됩니다.</p>
<p>Android JetPack 네비게이션은 고수준의 네비게이션을 간편하게 구현하는 데 도움을 줍니다.</p>
<p>네비게이션 컴포넌트는 세 가지 주요 부분으로 구성되어 있어요:</p>
<ul>
<li>네비게이션 그래프: 이는 모든 네비게이션 관련 데이터를 한 곳에 모아 둔 리소스입니다. 이에는 앱 내의 모든 위치인 목적지들과 사용자가 앱을 통해 이동할 수 있는 가능한 경로들이 포함됩니다. 앱에서 갈 수 있는 모든 장소와 그 있는 방법을 담은 큰 책처럼 생각하시면 좋아요. 이것은 지도와 안내서가 결합된 것으로 이해할 수 있어요.</li>
<li>NavHost: 이는 레이아웃에 포함할 수 있는 독특한 컴포저블(composable)입니다. 네비게이션 그래프에서 다양한 목적지를 표시해줘요. NavHost는 NavController를 네비게이션 그래프에 연결하여 네비게이션 사이를 이동할 수 있는 컴포저블 목적지를 지정하는 링크 역할을 합니다. 컴포저블 간을 이동하는 동안 NavHost의 내용은 자동으로 recompose됩니다. 네비게이션 그래프의 각 컴포저블 목적지는 경로에 연결돼 있어요.</li>
<li>NavController: NavController는 네비게이션 컴포넌트의 중심 API입니다. 이는 상태를 가지고 있으며, 앱의 화면을 구성하는 컴포저블들의 백 스택과 각 화면의 상태를 추적합니다.</li>
</ul>
<h1>Jetpack Compose에서의 네비게이션</h1>
<p>네비게이션 컴포넌트는 Jetpack Compose 애플리케이션을 지원해줍니다. 네비게이션 컴포넌트의 인프라와 기능을 활용하면서 컴포저블들 간을 이동할 수 있어요.</p>
<p>Jetpack Compose에서 탐색을 시작하려면 프로젝트의 build.gradle 파일에 필수 종속성을 포함해야 합니다:</p>
<pre><code class="hljs language-js">implementation <span class="hljs-string">"androidx.navigation:navigation-compose:2.7.1"</span>
</code></pre>
<p>Jetpack Compose에서 탐색에 대한 기본 개념.</p>
<h2>NavController:</h2>
<p>NavController은 네비게이션 컴포넌트의 중심 API입니다. 상태를 유지하며, 앱의 화면을 구성하는 컴포저블의 백 스택 및 각 화면의 상태를 추적합니다.</p>
<p>이러한 NavController는 다음과 같이 rememberNavController() 메서드를 사용하여 만들 수 있습니다:</p>
<pre><code class="hljs language-js">val navController = <span class="hljs-title function_">rememberNavController</span>()
</code></pre>
<p>NavController를 만들 때는 모든 컴포저블이 해당 NavController에 액세스할 수 있는 컴포저블 계층구조의 적절한 위치에서 만들어야 합니다. 이는 상태 끌어올리기(state hoisting)의 원리를 따르며, 현재 currentBackStackEntryAsState()를 통해 제공되는 NavController 및 상태를 통해 화면 외부의 컴포저블을 업데이트하는 데 참고할 수 있도록 합니다. 이러한 기능의 예시는 바텀 네비게이션바와의 통합을 참고하세요.</p>
<h2>NavHost:</h2>
<p>각 NavController는 단일 NavHost composable과 연결되어야 합니다. NavHost는 NavController를 네비게이션 그래프와 연결하여 이동할 수 있는 composable 목적지를 지정합니다. composable 사이를 이동하면 NavHost의 내용이 자동으로 recomposed됩니다. 네비게이션 그래프의 각 composable 목적지는 route와 연결됩니다.</p>
<p>NavHost를 생성하려면 이전에 rememberNavController()를 통해 생성한 NavController와 그래프의 시작 목적지인 route가 필요합니다. NavHost 생성은 네비게이션 Kotlin DSL에서 lambda 구문을 사용하여 네비게이션 그래프를 구성합니다. composable() 메서드를 사용하여 네비게이션 구조를 추가할 수 있습니다. 이 메서드는 route 및 목적지에 연결할 composable를 제공해야 합니다:</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">NavHost</span>(navController = navController, startDestination = <span class="hljs-string">"profile"</span>) {
    <span class="hljs-title function_">composable</span>(<span class="hljs-params"><span class="hljs-string">"profile"</span></span>) { <span class="hljs-title class_">Profile</span>(<span class="hljs-comment">/*...*/</span>) }
    <span class="hljs-title function_">composable</span>(<span class="hljs-params"><span class="hljs-string">"friendslist"</span></span>) { <span class="hljs-title class_">FriendsList</span>(<span class="hljs-comment">/*...*/</span>) }
    <span class="hljs-comment">/*...*/</span>
}
</code></pre>
<p>예시: 네비게이션 그래프, 네브호스트 및 네비게이션 아이템 설정하는 방법</p>
<p>단계 1: 네비게이션을 위한 화면 이름 및 라우트를 하나의 파일에 정의합니다. 예시. AppNavigation.kt</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">enum</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Screen</span> {
    HOME,    
    LOGIN,
}
<span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NavigationItem</span>(<span class="hljs-keyword">val</span> route: String) {
    <span class="hljs-keyword">object</span> Home : NavigationItem(Screen.HOME.name)
    <span class="hljs-keyword">object</span> Login : NavigationItem(Screen.LOGIN.name)
}
</code></pre>
<p>단계 2: NavHost 및 화면을 정의합니다. 예시. AppNavHost.kt</p>
<pre><code class="hljs language-kotlin"><span class="hljs-meta">@Composable</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">AppNavHost</span><span class="hljs-params">(
    modifier: <span class="hljs-type">Modifier</span> = Modifier,
    navController: <span class="hljs-type">NavHostController</span>,
    startDestination: <span class="hljs-type">String</span> = NavigationItem.Splash.route,
    ... <span class="hljs-comment">// 다른 매개변수</span>
)</span></span> {
    NavHost(
        modifier = modifier,
        navController = navController,
        startDestination = startDestination
    ) {
        composable(NavigationItem.Splash.route) {
            SplashScreen(navController)
        }
        composable(NavigationItem.Login.route) {
            LoginScreen(navController)
        }
    }
}
</code></pre>
<p>단계 3: MainActivity.kt 파일에서 AppNavHost를 호출합니다.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">ComponentActivity</span>() {
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> {
        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)
        setContent {
            AutoPartsAppTheme {
               Surface(
                    modifier = Modifier.fillMaxSize(),
                    color = MaterialTheme.colorScheme.background
                ) {
                    AppNavHost(navController = rememberNavController())
                }
            }
        }
    }
}
</code></pre>
<h2>네비게이션 인자:</h2>
<p>네비게이션 Compose는 코틀린을 사용하여 콤포저블 목적지 간에 인수를 전달하는 것을 지원합니다. 이를 위해 기본 네비게이션 라이브러리를 사용할 때 딥 링크에 인수를 추가하는 방식과 유사한 방식으로 라우트에 인수 자리 표시자를 추가해야 합니다.</p>
<h2>사용 사례:</h2>
<ul>
<li>인수가 없을 때</li>
<li>Int, String 등 미리 정의된 데이터 유형과 같은 간단한 인수를 사용할 때</li>
</ul>
<ol start="3">
<li>사용자가 정의한 데이터 유형 같은 복잡한 인수를 사용할 때</li>
</ol>
<ol start="4">
<li>
<p>선택적 매개변수</p>
</li>
<li>
<p>결과값으로 되돌아가기</p>
</li>
</ol>
<h2>매개변수 없이:</h2>
<pre><code class="hljs language-js"><span class="hljs-title class_">NavHost</span>(navController = navController, startDestination = <span class="hljs-string">"profile"</span>) {
    <span class="hljs-title function_">composable</span>(<span class="hljs-params"><span class="hljs-string">"profile"</span></span>) { <span class="hljs-title class_">Profile</span>(<span class="hljs-comment">/*...*/</span>) }
    <span class="hljs-title function_">composable</span>(<span class="hljs-params"><span class="hljs-string">"friendslist"</span></span>) { <span class="hljs-title class_">FriendsList</span>(<span class="hljs-comment">/*...*/</span>) }
    <span class="hljs-comment">/*...*/</span>
}
</code></pre>
<h2>간단한 인수로:</h2>
<p>기본적으로 모든 인수는 문자열로 구문 분석됩니다. composable()의 인수 매개변수는 NamedNavArguments의 목록을 허용합니다. navArgument 메서드를 사용하여 NamedNavArgument를 빠르게 만들고 그 정확한 유형을 지정할 수 있습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">NavHost</span>(startDestination = <span class="hljs-string">"profile/{userId}"</span>) {
    ...
    <span class="hljs-title function_">composable</span>(<span class="hljs-params"><span class="hljs-string">"profile/{userId}"</span></span>) {...}
}
</code></pre>
<p>기본적으로 모든 인수는 문자열로 구문 분석됩니다. composable()의 인수 매개변수는 NamedNavArguments의 목록을 허용합니다. navArgument 메서드를 사용하여 NamedNavArgument를 빠르게 만들고 그 정확한 유형을 지정할 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">NavHost</span>(startDestination = <span class="hljs-string">"profile/{userId}"</span>) {
    ...
    <span class="hljs-title function_">composable</span>(<span class="hljs-params">
        <span class="hljs-string">"profile/{userId}"</span>,
        <span class="hljs-variable language_">arguments</span> = listOf(navArgument(<span class="hljs-string">"userId"</span>){
           type = NavType.StringType 
        })
    </span>) {...}
}
</code></pre>
<p><code>composable("profile/{userId}") { backStackEntry ->    val userId = backStackEntry.arguments?.getString("userId")    // 여기서 사용자 데이터를 가져와야 합니다    Profile(       navController,        // 사용자 데이터를 가져와서 전달하세요. 예: UserInfo    ) } </code></p>
<p>대상으로 전달하려면 navigate 호출 시 경로에 추가해야 합니다:</p>
<pre><code class="hljs language-js">navController.<span class="hljs-title function_">navigate</span>(<span class="hljs-string">"profile/user1234"</span>)
</code></pre>
<p>지원되는 유형 목록을 보려면 전달 방법을 참조하세요.</p>
<h2>복잡하거나 사용자 정의 인수로:</h2>
<p>이동할 때 복잡한 데이터 객체를 전달하는 것은 권장되지 않지만 대신 고유 식별자 또는 기타 형식의 ID와 같이 최소한의 정보를 인수로 전달해야합니다. 이를 통해 이동 작업 수행 가능합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 새로운 대상으로 이동할 때 사용자 ID만 전달하실 때</span>
navController.<span class="hljs-title function_">navigate</span>(<span class="hljs-string">"profile/user1234"</span>)
</code></pre>
<p>복잡한 객체는 데이터 레이어와 같은 단일 진실의 원천으로 저장해야 합니다. 이동 후 목적지에 도착하면 전달된 ID를 사용하여 단일 진실의 원천에서 필요한 정보를로드할 수 있습니다. 데이터 레이어에 액세스하는 ViewModel에서 인수를 검색하려면 SavedStateHandle를 사용할 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserViewModel</span>(
    <span class="hljs-attr">savedStateHandle</span>: <span class="hljs-title class_">SavedStateHandle</span>,
    private val <span class="hljs-attr">userInfoRepository</span>: <span class="hljs-title class_">UserInfoRepository</span>
) : <span class="hljs-title class_">ViewModel</span>() {

    private val <span class="hljs-attr">userId</span>: <span class="hljs-title class_">String</span> = <span class="hljs-title function_">checkNotNull</span>(savedStateHandle[<span class="hljs-string">"userId"</span>])

    <span class="hljs-comment">// 전달된 userId 인수를 기반으로 데이터 레이어(예: userInfoRepository)에서 관련 사용자 정보 검색</span>
    private val <span class="hljs-attr">userInfo</span>: <span class="hljs-title class_">Flow</span>&#x3C;<span class="hljs-title class_">UserInfo</span>> = userInfoRepository.<span class="hljs-title function_">getUserInfo</span>(userId)

   --------------- <span class="hljs-variable constant_">OR</span> -----------------
 
    <span class="hljs-comment">// 네트워크 또는 데이터베이스에서 데이터 가져오기    </span>
    private val _dataFlow =
            <span class="hljs-title class_">MutableStateFlow</span>&#x3C;<span class="hljs-title class_">UserInfo</span>>(userInfoRepository.<span class="hljs-title function_">getUserInfo</span>(userId))
    val dataFlow <span class="hljs-title function_">get</span>() = _dataFlow.<span class="hljs-title function_">asStateFlow</span>()
}
</code></pre>
<p>적합한 기능</p>
<pre><code class="hljs language-kotlin"><span class="hljs-comment">//Navhost</span>
composable(<span class="hljs-string">"profile/{userId}"</span>) { backStackEntry ->
   <span class="hljs-keyword">val</span> userId = backStackEntry.arguments?.getString(<span class="hljs-string">"userId"</span>)
   <span class="hljs-comment">// 여기서 사용자 데이터를 가져와야 합니다</span>
   <span class="hljs-keyword">val</span> userInfo <span class="hljs-keyword">by</span> taskViewModel.dataFlow.collectAsState()   
   Profile(
      navController, 
      userInfo
   )
}

<span class="hljs-comment">// 프로필 화면</span>
<span class="hljs-meta">@Composable</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">Profile</span><span class="hljs-params">(navController: <span class="hljs-type">NavController</span>, userInfo: <span class="hljs-type">UserInfo</span>)</span></span>{
    <span class="hljs-comment">// 여기서 작업을 수행합니다</span>
}
</code></pre>
<p>이 접근 방식은 구성 변경 중에 데이터 유실을 방지하고 해당 객체가 업데이트되거나 변경될 때 불일치를 방지합니다.</p>
<p>복잡한 데이터를 인수로 전달하는 것을 피해야 하는 이유 및 지원되는 인수 유형 목록에 대한 보다 자세한 설명은 Best practice를 참조하세요.</p>
<h2>선택적 인수 추가하기</h2>
<p>Navigation Compose는 선택적 네비게이션 인수도 지원합니다. 선택적 인수는 필수 인수와 두 가지 방법으로 다릅니다:</p>
<ul>
<li>쿼리 매개변수 구문("?argName='argName'")을 사용하여 포함되어야 합니다.</li>
<li>defaultValue가 설정되어 있어야 하거나 nullable = true이어야 합니다(이는 기본 값을 자동으로 null로 설정합니다).</li>
</ul>
<p>이는 모든 선택적 인수가 콤포저블() 함수에 명시적으로 추가되어야 한다는 것을 의미합니다:</p>
<pre><code class="hljs language-js"><span class="hljs-title function_">composable</span>(<span class="hljs-params">
    <span class="hljs-string">"profile?userId={userId}/{isMember}"</span>,
    <span class="hljs-variable language_">arguments</span> = listOf(
         navArgument(<span class="hljs-string">"userId"</span>) {
            type = NavType.StringType
            defaultValue = <span class="hljs-string">"user1234"</span>
           // 또는
            type = NavType.StringType
            nullable = <span class="hljs-literal">true</span>
         },
         navArgument(<span class="hljs-string">"isNewTask"</span>) {
            type = NavType.BoolType
         }
     )
</span>) { backStackEntry ->
    val userId = backStackEntry.<span class="hljs-property">arguments</span>?.<span class="hljs-title function_">getString</span>(<span class="hljs-string">"userId"</span>)
    val isMember = backStackEntry.<span class="hljs-property">arguments</span>?.<span class="hljs-title function_">getBoolean</span>(<span class="hljs-string">"isMember"</span>)?:<span class="hljs-literal">false</span>
    <span class="hljs-title class_">Profile</span>(navController, userId, isMember)
}
</code></pre>
<p>이제 대상에 인수가 전달되지 않더라도 defaultValue = "user1234"가 대신 사용됩니다.</p>
<p>경로를 통해 인수를 처리하는 구조는 Composable이 Navigation과 완전히 독립되도록 하며 이로 인해 테스트하기 훨씬 더 용이해집니다.</p>
<h2>결과 값으로 되돌아가기</h2>
<p>결과 값을 사용하여 되돌아가는 것이 가장 일반적인 작업입니다. 즉, 필터 대화상자를 열고 필터를 선택한 다음 해당 필터를 적용하기 위해 선택된 필터와 함께 되돌아가는 경우입니다.</p>
<p>두 개의 화면이 있습니다. 1. 첫 번째 화면과 2. 두 번째 화면입니다. 우리는 두 번째 화면에서 첫 번째 화면으로 데이터를 필요로 합니다.</p>
<p>NavHost.kt : 내비게이션 그래프 설정.</p>
<pre><code class="hljs language-js"> val navController = <span class="hljs-title function_">rememberNavController</span>()
 <span class="hljs-title class_">NavHost</span>(
     navController = navController,
     startDestination = <span class="hljs-string">"firstscreen"</span>
 ) {
    <span class="hljs-title function_">composable</span>(<span class="hljs-params"><span class="hljs-string">"firstscreen"</span></span>) {
        <span class="hljs-title class_">FirstScreen</span>(navController)
    }
    <span class="hljs-title function_">composable</span>(<span class="hljs-params"><span class="hljs-string">"secondscreen"</span></span>) {
        <span class="hljs-title class_">SecondScreen</span>(navController)
    }
}
</code></pre>
<p>FirstScreen.kt: NavController의 현재 백 스택 항목의 savedStateHandle를 사용하여 두 번째 화면에서 다시 이동한 후 데이터를 검색합니다.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-meta">@Composable</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">FirstScreen</span><span class="hljs-params">(navController: <span class="hljs-type">NavController</span>)</span></span> {
    <span class="hljs-comment">// 다음 화면에서 데이터를 가져옵니다</span>
    <span class="hljs-keyword">val</span> msg = 
        navController.currentBackStackEntry?.savedStateHandle?.<span class="hljs-keyword">get</span>&#x3C;String>(<span class="hljs-string">"msg"</span>)
    Column(
        Modifier.fillMaxSize(),
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.Center
    ) {
        Button(onClick = { navController.navigate(<span class="hljs-string">"secondscreen"</span>) }) {
            Text(<span class="hljs-string">"다음 화면으로 이동"</span>)
        }
        Spacer(modifier = Modifier.height(<span class="hljs-number">8.</span>dp))
        msg?.let {
            Text(it)
        }
    }
}
</code></pre>
<p>SecondScreen.kt: 이전 백 스택 항목의 savedStateHandle 내에 데이터를 넣습니다.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-meta">@Composable</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">SecondScreen</span><span class="hljs-params">(navController: <span class="hljs-type">NavController</span>)</span></span> {
    <span class="hljs-keyword">var</span> text <span class="hljs-keyword">by</span> remember {
        mutableStateOf(<span class="hljs-string">""</span>)
    }
    Column(
        Modifier.fillMaxSize(),
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.Center
    ) {
        TextField(
            value = text, onValueChange = { text = it },
            placeholder = {
                Text(<span class="hljs-string">"텍스트를 입력하세요"</span>, color = Color.Gray)
            }
        )
        Spacer(Modifier.height(<span class="hljs-number">8.</span>dp))
        Button(onClick = {

           <span class="hljs-comment">// 데이터를 savedStateHandle에 넣어 이전 화면에서 데이터를 가져옵니다</span>
   
            navController.previousBackStackEntry?.savedStateHandle?.<span class="hljs-keyword">set</span>(<span class="hljs-string">"msg"</span>, text)
            navController.popBackStack()
        }) {
            Text(text = <span class="hljs-string">"제출"</span>)
        }
    }
}
</code></pre>
<p>비디오:</p>
<p><a href="https://github.com/KaushalVasava/JetPackCompose_Basic/assets/49050597/1d96d44f-66e1-4f3b-bba1-2844ab6553cc" rel="nofollow" target="_blank">https://github.com/KaushalVasava/JetPackCompose_Basic/assets/49050597/1d96d44f-66e1-4f3b-bba1-2844ab6553cc</a></p>
<p>GitHub 저장소: <a href="https://github.com/KaushalVasava/JetPackCompose_Basic/tree/navigate-back-with-result" rel="nofollow" target="_blank">https://github.com/KaushalVasava/JetPackCompose_Basic/tree/navigate-back-with-result</a></p>
<h1>딥 링크</h1>
<p>Navigation Compose은 암시적 딥 링크를 지원하며 composable() 함수의 일부로 정의할 수 있습니다. 딥 링크 매개변수 deepLinks는 navDeepLink 메소드를 사용하여 빠르게 생성할 수 있는 NavDeepLinks 목록을 수용합니다:</p>
<pre><code class="hljs language-js">val uri = <span class="hljs-string">"https://www.example.com"</span>
<span class="hljs-title function_">composable</span>(<span class="hljs-params">
    <span class="hljs-string">"profile?id={id}"</span>,
    deepLinks = listOf(navDeepLink { uriPattern = <span class="hljs-string">"$uri/{id}"</span> })
</span>) { backStackEntry ->
    <span class="hljs-title class_">Profile</span>(navController, backStackEntry.<span class="hljs-property">arguments</span>?.<span class="hljs-title function_">getString</span>(<span class="hljs-string">"id"</span>))
}
</code></pre>
<p>이러한 딥 링크를 사용하면 특정 URL, 액션 또는 MIME 유형을 composable과 연결할 수 있습니다. 기본적으로 이러한 딥 링크는 외부 앱에 노출되지 않습니다. 이러한 딥 링크를 외부에서 사용 가능하게 하려면 앱의 manifest.xml 파일에 적절한 <code>intent-filter</code> 요소를 추가해야 합니다. 위의 딥 링크를 활성화하려면 manifest의 <code>activity</code> 요소 내에 다음을 추가해야 합니다:</p>
<pre><code class="hljs language-js">&#x3C;activity …>
  <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">intent-filter</span>></span>
    ...
    <span class="hljs-tag">&#x3C;<span class="hljs-name">data</span> <span class="hljs-attr">android:scheme</span>=<span class="hljs-string">"https"</span> <span class="hljs-attr">android:host</span>=<span class="hljs-string">"www.example.com"</span> /></span>
  <span class="hljs-tag">&#x3C;/<span class="hljs-name">intent-filter</span>></span></span>
&#x3C;/activity>
</code></pre>
<p>다른 앱에 의해 트리거된 경우 딥 링크가 활성화될 때 해당 composable로 자동으로 이동합니다.</p>
<p>이러한 동일한 딥 링크는 콤포저블에서 적절한 딥 링크와 함께 PendingIntent를 작성하는 데 사용할 수도 있습니다:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> id = <span class="hljs-string">"exampleId"</span>
<span class="hljs-keyword">val</span> context = LocalContext.current
<span class="hljs-keyword">val</span> deepLinkIntent = Intent(
    Intent.ACTION_VIEW,
    <span class="hljs-string">"https://www.example.com/<span class="hljs-variable">$id</span>"</span>.toUri(),
    context,
    MyActivity::<span class="hljs-keyword">class</span>.java
)
<span class="hljs-keyword">val</span> deepLinkPendingIntent: PendingIntent? = TaskStackBuilder.create(context).run {
    addNextIntentWithParentStack(deepLinkIntent)
    
    <span class="hljs-keyword">val</span> flag = <span class="hljs-keyword">if</span>(Build.VERSION.SDK_INT > Build.VERSION_CODES.S){
                    PendingIntent.FLAG_IMMUTABLE
                } 
                <span class="hljs-keyword">else</span> 
                    PendingIntent.FLAG_UPDATE_CURRENT
    getPendingIntent(<span class="hljs-number">0</span>, flag)
}
</code></pre>
<p>그런 다음 이 deepLinkPendingIntent를 다른 PendingIntent와 마찬가지로 사용하여 앱을 딥 링크 대상지에서 열 수 있습니다.</p>
<h1>중첩된 내비게이션</h1>
<p><img src="/assets/img/2024-05-18-NavigationinJetpackcomposeFullguideBeginnertoAdvanced_1.png" alt="Image"></p>
<p>앱의 UI에서 특정 플로우를 모듈화하기 위해 대상을 중첩 그래프로 그룹화할 수 있습니다. 이러한 예로는 독립적인 로그인 플로우가 있을 수 있습니다.</p>
<p>중첩 그래프는 메인 그래프처럼 대상을 그룹화하며 해당 경로에 대한 지정된 시작 대상이 필요합니다. 이것은 중첩된 그래프의 경로에 액세스할 때 이동할 위치입니다.</p>
<p>NavHost에 중첩된 그래프를 추가하려면 네비게이션 익스텐션 함수를 사용할 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">NavHost</span>(navController, startDestination = <span class="hljs-string">"home"</span>) {
    ...
    <span class="hljs-comment">// 그래프를 통해 경로('login')로 이동하면 자동으로</span>
    <span class="hljs-comment">// 그래프의 시작 대상인 'username'으로 이동합니다.</span>
    <span class="hljs-comment">// 이로써 그래프의 내부 라우팅 로직을 캡슐화합니다.</span>
    <span class="hljs-title function_">navigation</span>(<span class="hljs-params">startDestination = <span class="hljs-string">"username"</span>, route = <span class="hljs-string">"login"</span></span>) {
        <span class="hljs-title function_">composable</span>(<span class="hljs-params"><span class="hljs-string">"username"</span></span>) { ... }
        <span class="hljs-title function_">composable</span>(<span class="hljs-params"><span class="hljs-string">"password"</span></span>) { ... }
        <span class="hljs-title function_">composable</span>(<span class="hljs-params"><span class="hljs-string">"registration"</span></span>) { ... }
    }
    ...
}
</code></pre>
<p>그래프가 커질수록 여러 메소드로 나누는 것이 좋습니다. 이렇게 하면 여러 모듈이 각자의 네비게이션 그래프를 기여할 수 있습니다.</p>
<pre><code class="hljs language-js">fun <span class="hljs-title class_">NavGraphBuilder</span>.<span class="hljs-title function_">loginGraph</span>(<span class="hljs-params">navController: NavController</span>) {
    <span class="hljs-title function_">navigation</span>(<span class="hljs-params">startDestination = <span class="hljs-string">"username"</span>, route = <span class="hljs-string">"login"</span></span>) {
        <span class="hljs-title function_">composable</span>(<span class="hljs-params"><span class="hljs-string">"username"</span></span>) { ... }
        <span class="hljs-title function_">composable</span>(<span class="hljs-params"><span class="hljs-string">"password"</span></span>) { ... }
        <span class="hljs-title function_">composable</span>(<span class="hljs-params"><span class="hljs-string">"registration"</span></span>) { ... }
    }
}
</code></pre>
<p>NavGraphBuilder를 확장 메소드로 만들면 미리 작성된 navigation, composable, dialog 익스텐션 메소드와 함께 사용할 수 있습니다.```</p>
<pre><code class="hljs language-kotlin">NavHost(navController, startDestination = <span class="hljs-string">"home"</span>) {
    ...
    loginGraph(navController)
    ...
}
</code></pre>
<p>예시:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> navController = rememberNavController()
NavHost(navController = navController, startDestination = <span class="hljs-string">"home"</span>) {
    composable(<span class="hljs-string">"about"</span>) {}
    navigation(
        startDestination = <span class="hljs-string">"login"</span>,
        route = <span class="hljs-string">"auth"</span>
    ) {
        composable(<span class="hljs-string">"login"</span>) {
            <span class="hljs-keyword">val</span> viewModel = it.sharedViewModel&#x3C;SampleViewModel>(navController)

            Button(onClick = {
                navController.navigate(<span class="hljs-string">"calendar"</span>) {
                    popUpTo(<span class="hljs-string">"auth"</span>) {
                        inclusive = <span class="hljs-literal">true</span>
                    }
                }
            }) {
            }
        }
        composable(<span class="hljs-string">"register"</span>) {
            <span class="hljs-keyword">val</span> viewModel = it.sharedViewModel&#x3C;SampleViewModel>(navController)
        } 
        composable(<span class="hljs-string">"forgot_password"</span>) {
            <span class="hljs-keyword">val</span> viewModel = it.sharedViewModel&#x3C;SampleViewModel>(navController)
        }
    }
    navigation(
        startDestination = <span class="hljs-string">"calendar_overview"</span>,
        route = <span class="hljs-string">"calendar"</span>
    ) {
        composable(<span class="hljs-string">"calendar_overview"</span>) { }
        composable(<span class="hljs-string">"calendar_entry"</span>) { }
    }
}
</code></pre>
<p>NavBackStack entry를 위한 확장 함수</p>
<pre><code class="hljs language-kotlin"><span class="hljs-meta">@Composable</span>
<span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&#x3C;<span class="hljs-keyword">reified</span> T : ViewModel></span> NavBackStackEntry.<span class="hljs-title">sharedViewModel</span><span class="hljs-params">(navController: <span class="hljs-type">NavController</span>)</span></span>: T {
    <span class="hljs-keyword">val</span> navGraphRoute = destination.parent?.route ?: <span class="hljs-keyword">return</span> viewModel()
    <span class="hljs-keyword">val</span> parentEntry = remember(<span class="hljs-keyword">this</span>) {
        navController.getBackStackEntry(navGraphRoute)
    }
    <span class="hljs-keyword">return</span> viewModel(parentEntry)
}
</code></pre>
<h1>하단 탐색 막대와 통합</h1>
<p>조합 가능한 구조의 위쪽 수준에서 NavController를 정의함으로써, 네비게이션을 하단 탐색 막대와 같은 다른 구성 요소와 연결할 수 있습니다. 이를 통해 하단 막대에서 아이콘을 선택하여 탐색할 수 있습니다.</p>
<p>BottomNavigation 및 BottomNavigationItem 구성 요소를 사용하려면 Android 애플리케이션에 androidx.compose.material 종속성을 추가하십시오.</p>
<pre><code class="hljs language-js">좌측 테이블을 <span class="hljs-title class_">Markdown</span> 형식으로 변환했습니다.
</code></pre>
<p>하단 네비게이션바의 항목을 네비게이션 그래프의 루트에 링크하려면 Screen과 같은 sealed class를 정의하는 것이 좋습니다. 이 클래스는 목적지의 루트와 문자열 리소스 ID를 포함합니다.</p>
<pre><code class="hljs language-js">sealed <span class="hljs-keyword">class</span> <span class="hljs-title class_">Screen</span>(val <span class="hljs-attr">route</span>: <span class="hljs-title class_">String</span>, @<span class="hljs-title class_">StringRes</span> val <span class="hljs-attr">resourceId</span>: <span class="hljs-title class_">Int</span>) {
    object <span class="hljs-title class_">Profile</span> : <span class="hljs-title class_">Screen</span>(<span class="hljs-string">"profile"</span>, R.<span class="hljs-property">string</span>.<span class="hljs-property">profile</span>)
    object <span class="hljs-title class_">FriendsList</span> : <span class="hljs-title class_">Screen</span>(<span class="hljs-string">"friendslist"</span>, R.<span class="hljs-property">string</span>.<span class="hljs-property">friends_list</span>)
}
</code></pre>
<p>이후 BottomNavigationItem에서 사용할 수 있는 리스트에 해당 항목을 넣으십시오.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> items = listOf(
    Screen.Profile,
    Screen.FriendsList
)
</code></pre>
<p>BottomNavigation 컴포저에서 currentBackStackEntryAsState() 함수를 사용하여 현재 NavBackStackEntry를 가져옵니다. 이 엔트리를 통해 현재 NavDestination에 액세스할 수 있습니다. 각 BottomNavigationItem의 선택 상태는 아이템의 경로를 현재 목적지 및 부모 목적지의 경로와 비교하여 결정할 수 있습니다 (중첩된 내비게이션을 사용하는 경우 처리하기 위해 NavDestination 계층구조를 통해).</p>
<p>아이템의 경로는 또한 onClick 람다를 navigate 호출과 연결하는 데 사용되어 해당 아이템을 탭하면 해당 아이템으로 이동합니다. saveState 및 restoreState 플래그를 사용하여 해당 아이템의 상태와 백 스택이 올바르게 저장되고 전환될 때 해당 아이템의 상태가 올바르게 복원됩니다.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> navController = rememberNavController()
Scaffold(
    bottomBar = {
        BottomNavigation {
            <span class="hljs-keyword">val</span> navBackStackEntry <span class="hljs-keyword">by</span> navController.currentBackStackEntryAsState()
            <span class="hljs-keyword">val</span> currentDestination = navBackStackEntry?.destination
            items.forEach { screen ->
                BottomNavigationItem(
                    icon = { Icon(Icons.Filled.Favorite, contentDescription = <span class="hljs-literal">null</span>) },
                    label = { Text(stringResource(screen.resourceId)) },
                    selected = currentDestination?.hierarchy?.any { it.route == screen.route } == <span class="hljs-literal">true</span>,
                    onClick = {
                        navController.navigate(screen.route) {
                            popUpTo(navController.graph.findStartDestination().id) {
                                saveState = <span class="hljs-literal">true</span>
                            }
                            launchSingleTop = <span class="hljs-literal">true</span>
                            restoreState = <span class="hljs-literal">true</span>
                        }
                    }
                )
            }
        }
    }
) { innerPadding ->
    NavHost(navController, startDestination = Screen.Profile.route, Modifier.padding(innerPadding)) {
        composable(Screen.Profile.route) { Profile(navController) }
        composable(Screen.FriendsList.route) { FriendsList(navController) }
    }
}
</code></pre>
<p>NavController.currentBackStackEntryAsState() 메소드를 활용하여 네비게이션 컨트롤러 상태를 NavHost 함수 밖으로 빼내어 BottomNavigation 컴포넌트와 공유합니다. 이렇게 하면 BottomNavigation이 항상 최신 상태를 가지게 됩니다.</p>
<p>읽어 주셔서 감사합니다. 🙌🙏✌</p>
<p>더 많은 안드로이드 개발, 코틀린 및 KMP에 관한 유용한 기사를 보시려면 박수를 날려주세요 👏 그리고 팔로우해 주세요.</p>
<p>안드로이드, 코틀린 및 KMP 관련 도움이 필요하시다면 언제든지 도와드리겠습니다.</p>
<p>Medium, LinkedIn, Twitter, GitHub, Instagram에서 나를 팔로우하고 DM으로 앱 개발 프리랜싱 업무를 문의해주세요.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Jetpack Compose 내비게이션 초보부터 고급까지 전체 가이드","description":"","date":"2024-05-18 17:13","slug":"2024-05-18-NavigationinJetpackcomposeFullguideBeginnertoAdvanced","content":"\n\n아래는 Markdown 형식으로 변환되었습니다.\n\n![이미지](/assets/img/2024-05-18-NavigationinJetpackcomposeFullguideBeginnertoAdvanced_0.png)\n\n# 안드로이드에서의 네비게이션은 무엇인가요?\n\n네비게이션은 애플리케이션의 다른 구성 요소 간에 이동하는 방법을 이해하는 데 도움이 됩니다.\n\nAndroid JetPack 네비게이션은 고수준의 네비게이션을 간편하게 구현하는 데 도움을 줍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n네비게이션 컴포넌트는 세 가지 주요 부분으로 구성되어 있어요:\n\n- 네비게이션 그래프: 이는 모든 네비게이션 관련 데이터를 한 곳에 모아 둔 리소스입니다. 이에는 앱 내의 모든 위치인 목적지들과 사용자가 앱을 통해 이동할 수 있는 가능한 경로들이 포함됩니다. 앱에서 갈 수 있는 모든 장소와 그 있는 방법을 담은 큰 책처럼 생각하시면 좋아요. 이것은 지도와 안내서가 결합된 것으로 이해할 수 있어요.\n- NavHost: 이는 레이아웃에 포함할 수 있는 독특한 컴포저블(composable)입니다. 네비게이션 그래프에서 다양한 목적지를 표시해줘요. NavHost는 NavController를 네비게이션 그래프에 연결하여 네비게이션 사이를 이동할 수 있는 컴포저블 목적지를 지정하는 링크 역할을 합니다. 컴포저블 간을 이동하는 동안 NavHost의 내용은 자동으로 recompose됩니다. 네비게이션 그래프의 각 컴포저블 목적지는 경로에 연결돼 있어요.\n- NavController: NavController는 네비게이션 컴포넌트의 중심 API입니다. 이는 상태를 가지고 있으며, 앱의 화면을 구성하는 컴포저블들의 백 스택과 각 화면의 상태를 추적합니다.\n\n# Jetpack Compose에서의 네비게이션\n\n네비게이션 컴포넌트는 Jetpack Compose 애플리케이션을 지원해줍니다. 네비게이션 컴포넌트의 인프라와 기능을 활용하면서 컴포저블들 간을 이동할 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nJetpack Compose에서 탐색을 시작하려면 프로젝트의 build.gradle 파일에 필수 종속성을 포함해야 합니다:\n\n```js\nimplementation \"androidx.navigation:navigation-compose:2.7.1\"\n```\n\nJetpack Compose에서 탐색에 대한 기본 개념.\n\n## NavController:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNavController은 네비게이션 컴포넌트의 중심 API입니다. 상태를 유지하며, 앱의 화면을 구성하는 컴포저블의 백 스택 및 각 화면의 상태를 추적합니다.\n\n이러한 NavController는 다음과 같이 rememberNavController() 메서드를 사용하여 만들 수 있습니다:\n\n```js\nval navController = rememberNavController()\n```\n\nNavController를 만들 때는 모든 컴포저블이 해당 NavController에 액세스할 수 있는 컴포저블 계층구조의 적절한 위치에서 만들어야 합니다. 이는 상태 끌어올리기(state hoisting)의 원리를 따르며, 현재 currentBackStackEntryAsState()를 통해 제공되는 NavController 및 상태를 통해 화면 외부의 컴포저블을 업데이트하는 데 참고할 수 있도록 합니다. 이러한 기능의 예시는 바텀 네비게이션바와의 통합을 참고하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## NavHost:\n\n각 NavController는 단일 NavHost composable과 연결되어야 합니다. NavHost는 NavController를 네비게이션 그래프와 연결하여 이동할 수 있는 composable 목적지를 지정합니다. composable 사이를 이동하면 NavHost의 내용이 자동으로 recomposed됩니다. 네비게이션 그래프의 각 composable 목적지는 route와 연결됩니다.\n\nNavHost를 생성하려면 이전에 rememberNavController()를 통해 생성한 NavController와 그래프의 시작 목적지인 route가 필요합니다. NavHost 생성은 네비게이션 Kotlin DSL에서 lambda 구문을 사용하여 네비게이션 그래프를 구성합니다. composable() 메서드를 사용하여 네비게이션 구조를 추가할 수 있습니다. 이 메서드는 route 및 목적지에 연결할 composable를 제공해야 합니다:\n\n```js\nNavHost(navController = navController, startDestination = \"profile\") {\n    composable(\"profile\") { Profile(/*...*/) }\n    composable(\"friendslist\") { FriendsList(/*...*/) }\n    /*...*/\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예시: 네비게이션 그래프, 네브호스트 및 네비게이션 아이템 설정하는 방법\n\n단계 1: 네비게이션을 위한 화면 이름 및 라우트를 하나의 파일에 정의합니다. 예시. AppNavigation.kt\n\n```kotlin\nenum class Screen {\n    HOME,    \n    LOGIN,\n}\nsealed class NavigationItem(val route: String) {\n    object Home : NavigationItem(Screen.HOME.name)\n    object Login : NavigationItem(Screen.LOGIN.name)\n}\n```\n\n단계 2: NavHost 및 화면을 정의합니다. 예시. AppNavHost.kt\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```kotlin\n@Composable\nfun AppNavHost(\n    modifier: Modifier = Modifier,\n    navController: NavHostController,\n    startDestination: String = NavigationItem.Splash.route,\n    ... // 다른 매개변수\n) {\n    NavHost(\n        modifier = modifier,\n        navController = navController,\n        startDestination = startDestination\n    ) {\n        composable(NavigationItem.Splash.route) {\n            SplashScreen(navController)\n        }\n        composable(NavigationItem.Login.route) {\n            LoginScreen(navController)\n        }\n    }\n}\n```\n\n단계 3: MainActivity.kt 파일에서 AppNavHost를 호출합니다.\n\n```kotlin\nclass MainActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            AutoPartsAppTheme {\n               Surface(\n                    modifier = Modifier.fillMaxSize(),\n                    color = MaterialTheme.colorScheme.background\n                ) {\n                    AppNavHost(navController = rememberNavController())\n                }\n            }\n        }\n    }\n}\n```\n\n## 네비게이션 인자:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n네비게이션 Compose는 코틀린을 사용하여 콤포저블 목적지 간에 인수를 전달하는 것을 지원합니다. 이를 위해 기본 네비게이션 라이브러리를 사용할 때 딥 링크에 인수를 추가하는 방식과 유사한 방식으로 라우트에 인수 자리 표시자를 추가해야 합니다. \n\n## 사용 사례:\n\n- 인수가 없을 때\n- Int, String 등 미리 정의된 데이터 유형과 같은 간단한 인수를 사용할 때\n\n3. 사용자가 정의한 데이터 유형 같은 복잡한 인수를 사용할 때\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n4. 선택적 매개변수\n\n5. 결과값으로 되돌아가기\n\n## 매개변수 없이:\n\n```js\nNavHost(navController = navController, startDestination = \"profile\") {\n    composable(\"profile\") { Profile(/*...*/) }\n    composable(\"friendslist\") { FriendsList(/*...*/) }\n    /*...*/\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 간단한 인수로:\n\n기본적으로 모든 인수는 문자열로 구문 분석됩니다. composable()의 인수 매개변수는 NamedNavArguments의 목록을 허용합니다. navArgument 메서드를 사용하여 NamedNavArgument를 빠르게 만들고 그 정확한 유형을 지정할 수 있습니다:\n\n```js\nNavHost(startDestination = \"profile/{userId}\") {\n    ...\n    composable(\"profile/{userId}\") {...}\n}\n```\n\n기본적으로 모든 인수는 문자열로 구문 분석됩니다. composable()의 인수 매개변수는 NamedNavArguments의 목록을 허용합니다. navArgument 메서드를 사용하여 NamedNavArgument를 빠르게 만들고 그 정확한 유형을 지정할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nNavHost(startDestination = \"profile/{userId}\") {\n    ...\n    composable(\n        \"profile/{userId}\",\n        arguments = listOf(navArgument(\"userId\"){\n           type = NavType.StringType \n        })\n    ) {...}\n}\n```\n\n`composable(\"profile/{userId}\") { backStackEntry -\u003e\n   val userId = backStackEntry.arguments?.getString(\"userId\")\n   // 여기서 사용자 데이터를 가져와야 합니다\n   Profile(\n      navController, \n      // 사용자 데이터를 가져와서 전달하세요. 예: UserInfo\n   )\n}\n`\n\n대상으로 전달하려면 navigate 호출 시 경로에 추가해야 합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nnavController.navigate(\"profile/user1234\")\n```\n\n지원되는 유형 목록을 보려면 전달 방법을 참조하세요.\n\n## 복잡하거나 사용자 정의 인수로:\n\n이동할 때 복잡한 데이터 객체를 전달하는 것은 권장되지 않지만 대신 고유 식별자 또는 기타 형식의 ID와 같이 최소한의 정보를 인수로 전달해야합니다. 이를 통해 이동 작업 수행 가능합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// 새로운 대상으로 이동할 때 사용자 ID만 전달하실 때\nnavController.navigate(\"profile/user1234\")\n```\n\n복잡한 객체는 데이터 레이어와 같은 단일 진실의 원천으로 저장해야 합니다. 이동 후 목적지에 도착하면 전달된 ID를 사용하여 단일 진실의 원천에서 필요한 정보를로드할 수 있습니다. 데이터 레이어에 액세스하는 ViewModel에서 인수를 검색하려면 SavedStateHandle를 사용할 수 있습니다.\n\n```js\nclass UserViewModel(\n    savedStateHandle: SavedStateHandle,\n    private val userInfoRepository: UserInfoRepository\n) : ViewModel() {\n\n    private val userId: String = checkNotNull(savedStateHandle[\"userId\"])\n\n    // 전달된 userId 인수를 기반으로 데이터 레이어(예: userInfoRepository)에서 관련 사용자 정보 검색\n    private val userInfo: Flow\u003cUserInfo\u003e = userInfoRepository.getUserInfo(userId)\n\n   --------------- OR -----------------\n \n    // 네트워크 또는 데이터베이스에서 데이터 가져오기    \n    private val _dataFlow =\n            MutableStateFlow\u003cUserInfo\u003e(userInfoRepository.getUserInfo(userId))\n    val dataFlow get() = _dataFlow.asStateFlow()\n}\n```\n\n적합한 기능\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```kotlin\n//Navhost\ncomposable(\"profile/{userId}\") { backStackEntry -\u003e\n   val userId = backStackEntry.arguments?.getString(\"userId\")\n   // 여기서 사용자 데이터를 가져와야 합니다\n   val userInfo by taskViewModel.dataFlow.collectAsState()   \n   Profile(\n      navController, \n      userInfo\n   )\n}\n\n// 프로필 화면\n@Composable\nfun Profile(navController: NavController, userInfo: UserInfo){\n    // 여기서 작업을 수행합니다\n}\n```\n\n이 접근 방식은 구성 변경 중에 데이터 유실을 방지하고 해당 객체가 업데이트되거나 변경될 때 불일치를 방지합니다.\n\n복잡한 데이터를 인수로 전달하는 것을 피해야 하는 이유 및 지원되는 인수 유형 목록에 대한 보다 자세한 설명은 Best practice를 참조하세요.\n\n## 선택적 인수 추가하기\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNavigation Compose는 선택적 네비게이션 인수도 지원합니다. 선택적 인수는 필수 인수와 두 가지 방법으로 다릅니다:\n\n- 쿼리 매개변수 구문(\"?argName='argName'\")을 사용하여 포함되어야 합니다.\n- defaultValue가 설정되어 있어야 하거나 nullable = true이어야 합니다(이는 기본 값을 자동으로 null로 설정합니다).\n\n이는 모든 선택적 인수가 콤포저블() 함수에 명시적으로 추가되어야 한다는 것을 의미합니다:\n\n```js\ncomposable(\n    \"profile?userId={userId}/{isMember}\",\n    arguments = listOf(\n         navArgument(\"userId\") {\n            type = NavType.StringType\n            defaultValue = \"user1234\"\n           // 또는\n            type = NavType.StringType\n            nullable = true\n         },\n         navArgument(\"isNewTask\") {\n            type = NavType.BoolType\n         }\n     )\n) { backStackEntry -\u003e\n    val userId = backStackEntry.arguments?.getString(\"userId\")\n    val isMember = backStackEntry.arguments?.getBoolean(\"isMember\")?:false\n    Profile(navController, userId, isMember)\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 대상에 인수가 전달되지 않더라도 defaultValue = \"user1234\"가 대신 사용됩니다.\n\n경로를 통해 인수를 처리하는 구조는 Composable이 Navigation과 완전히 독립되도록 하며 이로 인해 테스트하기 훨씬 더 용이해집니다.\n\n## 결과 값으로 되돌아가기\n\n결과 값을 사용하여 되돌아가는 것이 가장 일반적인 작업입니다. 즉, 필터 대화상자를 열고 필터를 선택한 다음 해당 필터를 적용하기 위해 선택된 필터와 함께 되돌아가는 경우입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n두 개의 화면이 있습니다. 1. 첫 번째 화면과 2. 두 번째 화면입니다. 우리는 두 번째 화면에서 첫 번째 화면으로 데이터를 필요로 합니다.\n\nNavHost.kt : 내비게이션 그래프 설정.\n\n```js\n val navController = rememberNavController()\n NavHost(\n     navController = navController,\n     startDestination = \"firstscreen\"\n ) {\n    composable(\"firstscreen\") {\n        FirstScreen(navController)\n    }\n    composable(\"secondscreen\") {\n        SecondScreen(navController)\n    }\n}\n```\n\nFirstScreen.kt: NavController의 현재 백 스택 항목의 savedStateHandle를 사용하여 두 번째 화면에서 다시 이동한 후 데이터를 검색합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```kotlin\n@Composable\nfun FirstScreen(navController: NavController) {\n    // 다음 화면에서 데이터를 가져옵니다\n    val msg = \n        navController.currentBackStackEntry?.savedStateHandle?.get\u003cString\u003e(\"msg\")\n    Column(\n        Modifier.fillMaxSize(),\n        horizontalAlignment = Alignment.CenterHorizontally,\n        verticalArrangement = Arrangement.Center\n    ) {\n        Button(onClick = { navController.navigate(\"secondscreen\") }) {\n            Text(\"다음 화면으로 이동\")\n        }\n        Spacer(modifier = Modifier.height(8.dp))\n        msg?.let {\n            Text(it)\n        }\n    }\n}\n```\n\nSecondScreen.kt: 이전 백 스택 항목의 savedStateHandle 내에 데이터를 넣습니다.\n\n```kotlin\n@Composable\nfun SecondScreen(navController: NavController) {\n    var text by remember {\n        mutableStateOf(\"\")\n    }\n    Column(\n        Modifier.fillMaxSize(),\n        horizontalAlignment = Alignment.CenterHorizontally,\n        verticalArrangement = Arrangement.Center\n    ) {\n        TextField(\n            value = text, onValueChange = { text = it },\n            placeholder = {\n                Text(\"텍스트를 입력하세요\", color = Color.Gray)\n            }\n        )\n        Spacer(Modifier.height(8.dp))\n        Button(onClick = {\n\n           // 데이터를 savedStateHandle에 넣어 이전 화면에서 데이터를 가져옵니다\n   \n            navController.previousBackStackEntry?.savedStateHandle?.set(\"msg\", text)\n            navController.popBackStack()\n        }) {\n            Text(text = \"제출\")\n        }\n    }\n}\n```\n\n비디오: \n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nhttps://github.com/KaushalVasava/JetPackCompose_Basic/assets/49050597/1d96d44f-66e1-4f3b-bba1-2844ab6553cc\n\nGitHub 저장소: https://github.com/KaushalVasava/JetPackCompose_Basic/tree/navigate-back-with-result\n\n# 딥 링크\n\nNavigation Compose은 암시적 딥 링크를 지원하며 composable() 함수의 일부로 정의할 수 있습니다. 딥 링크 매개변수 deepLinks는 navDeepLink 메소드를 사용하여 빠르게 생성할 수 있는 NavDeepLinks 목록을 수용합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nval uri = \"https://www.example.com\"\ncomposable(\n    \"profile?id={id}\",\n    deepLinks = listOf(navDeepLink { uriPattern = \"$uri/{id}\" })\n) { backStackEntry -\u003e\n    Profile(navController, backStackEntry.arguments?.getString(\"id\"))\n}\n```\n\n이러한 딥 링크를 사용하면 특정 URL, 액션 또는 MIME 유형을 composable과 연결할 수 있습니다. 기본적으로 이러한 딥 링크는 외부 앱에 노출되지 않습니다. 이러한 딥 링크를 외부에서 사용 가능하게 하려면 앱의 manifest.xml 파일에 적절한 `intent-filter` 요소를 추가해야 합니다. 위의 딥 링크를 활성화하려면 manifest의 `activity` 요소 내에 다음을 추가해야 합니다:\n\n```js\n\u003cactivity …\u003e\n  \u003cintent-filter\u003e\n    ...\n    \u003cdata android:scheme=\"https\" android:host=\"www.example.com\" /\u003e\n  \u003c/intent-filter\u003e\n\u003c/activity\u003e\n```\n\n다른 앱에 의해 트리거된 경우 딥 링크가 활성화될 때 해당 composable로 자동으로 이동합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이러한 동일한 딥 링크는 콤포저블에서 적절한 딥 링크와 함께 PendingIntent를 작성하는 데 사용할 수도 있습니다:\n\n```kotlin\nval id = \"exampleId\"\nval context = LocalContext.current\nval deepLinkIntent = Intent(\n    Intent.ACTION_VIEW,\n    \"https://www.example.com/$id\".toUri(),\n    context,\n    MyActivity::class.java\n)\nval deepLinkPendingIntent: PendingIntent? = TaskStackBuilder.create(context).run {\n    addNextIntentWithParentStack(deepLinkIntent)\n    \n    val flag = if(Build.VERSION.SDK_INT \u003e Build.VERSION_CODES.S){\n                    PendingIntent.FLAG_IMMUTABLE\n                } \n                else \n                    PendingIntent.FLAG_UPDATE_CURRENT\n    getPendingIntent(0, flag)\n}\n```\n\n그런 다음 이 deepLinkPendingIntent를 다른 PendingIntent와 마찬가지로 사용하여 앱을 딥 링크 대상지에서 열 수 있습니다.\n\n# 중첩된 내비게이션\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Image](/assets/img/2024-05-18-NavigationinJetpackcomposeFullguideBeginnertoAdvanced_1.png)\n\n앱의 UI에서 특정 플로우를 모듈화하기 위해 대상을 중첩 그래프로 그룹화할 수 있습니다. 이러한 예로는 독립적인 로그인 플로우가 있을 수 있습니다.\n\n중첩 그래프는 메인 그래프처럼 대상을 그룹화하며 해당 경로에 대한 지정된 시작 대상이 필요합니다. 이것은 중첩된 그래프의 경로에 액세스할 때 이동할 위치입니다.\n\nNavHost에 중첩된 그래프를 추가하려면 네비게이션 익스텐션 함수를 사용할 수 있습니다.\n  \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nNavHost(navController, startDestination = \"home\") {\n    ...\n    // 그래프를 통해 경로('login')로 이동하면 자동으로\n    // 그래프의 시작 대상인 'username'으로 이동합니다.\n    // 이로써 그래프의 내부 라우팅 로직을 캡슐화합니다.\n    navigation(startDestination = \"username\", route = \"login\") {\n        composable(\"username\") { ... }\n        composable(\"password\") { ... }\n        composable(\"registration\") { ... }\n    }\n    ...\n}\n```\n\n그래프가 커질수록 여러 메소드로 나누는 것이 좋습니다. 이렇게 하면 여러 모듈이 각자의 네비게이션 그래프를 기여할 수 있습니다.\n\n```js\nfun NavGraphBuilder.loginGraph(navController: NavController) {\n    navigation(startDestination = \"username\", route = \"login\") {\n        composable(\"username\") { ... }\n        composable(\"password\") { ... }\n        composable(\"registration\") { ... }\n    }\n}\n```\n\nNavGraphBuilder를 확장 메소드로 만들면 미리 작성된 navigation, composable, dialog 익스텐션 메소드와 함께 사용할 수 있습니다.```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```kotlin\nNavHost(navController, startDestination = \"home\") {\n    ...\n    loginGraph(navController)\n    ...\n}\n```\n\n예시:\n\n```kotlin\nval navController = rememberNavController()\nNavHost(navController = navController, startDestination = \"home\") {\n    composable(\"about\") {}\n    navigation(\n        startDestination = \"login\",\n        route = \"auth\"\n    ) {\n        composable(\"login\") {\n            val viewModel = it.sharedViewModel\u003cSampleViewModel\u003e(navController)\n\n            Button(onClick = {\n                navController.navigate(\"calendar\") {\n                    popUpTo(\"auth\") {\n                        inclusive = true\n                    }\n                }\n            }) {\n            }\n        }\n        composable(\"register\") {\n            val viewModel = it.sharedViewModel\u003cSampleViewModel\u003e(navController)\n        } \n        composable(\"forgot_password\") {\n            val viewModel = it.sharedViewModel\u003cSampleViewModel\u003e(navController)\n        }\n    }\n    navigation(\n        startDestination = \"calendar_overview\",\n        route = \"calendar\"\n    ) {\n        composable(\"calendar_overview\") { }\n        composable(\"calendar_entry\") { }\n    }\n}\n```\n\nNavBackStack entry를 위한 확장 함수\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```kotlin\n@Composable\ninline fun \u003creified T : ViewModel\u003e NavBackStackEntry.sharedViewModel(navController: NavController): T {\n    val navGraphRoute = destination.parent?.route ?: return viewModel()\n    val parentEntry = remember(this) {\n        navController.getBackStackEntry(navGraphRoute)\n    }\n    return viewModel(parentEntry)\n}\n```\n\n# 하단 탐색 막대와 통합\n\n조합 가능한 구조의 위쪽 수준에서 NavController를 정의함으로써, 네비게이션을 하단 탐색 막대와 같은 다른 구성 요소와 연결할 수 있습니다. 이를 통해 하단 막대에서 아이콘을 선택하여 탐색할 수 있습니다.\n\nBottomNavigation 및 BottomNavigationItem 구성 요소를 사용하려면 Android 애플리케이션에 androidx.compose.material 종속성을 추가하십시오.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n좌측 테이블을 Markdown 형식으로 변환했습니다.\n```\n\n하단 네비게이션바의 항목을 네비게이션 그래프의 루트에 링크하려면 Screen과 같은 sealed class를 정의하는 것이 좋습니다. 이 클래스는 목적지의 루트와 문자열 리소스 ID를 포함합니다.\n\n```js\nsealed class Screen(val route: String, @StringRes val resourceId: Int) {\n    object Profile : Screen(\"profile\", R.string.profile)\n    object FriendsList : Screen(\"friendslist\", R.string.friends_list)\n}\n```\n\n이후 BottomNavigationItem에서 사용할 수 있는 리스트에 해당 항목을 넣으십시오.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```kotlin\nval items = listOf(\n    Screen.Profile,\n    Screen.FriendsList\n)\n```\n\nBottomNavigation 컴포저에서 currentBackStackEntryAsState() 함수를 사용하여 현재 NavBackStackEntry를 가져옵니다. 이 엔트리를 통해 현재 NavDestination에 액세스할 수 있습니다. 각 BottomNavigationItem의 선택 상태는 아이템의 경로를 현재 목적지 및 부모 목적지의 경로와 비교하여 결정할 수 있습니다 (중첩된 내비게이션을 사용하는 경우 처리하기 위해 NavDestination 계층구조를 통해).\n\n아이템의 경로는 또한 onClick 람다를 navigate 호출과 연결하는 데 사용되어 해당 아이템을 탭하면 해당 아이템으로 이동합니다. saveState 및 restoreState 플래그를 사용하여 해당 아이템의 상태와 백 스택이 올바르게 저장되고 전환될 때 해당 아이템의 상태가 올바르게 복원됩니다.\n\n```kotlin\nval navController = rememberNavController()\nScaffold(\n    bottomBar = {\n        BottomNavigation {\n            val navBackStackEntry by navController.currentBackStackEntryAsState()\n            val currentDestination = navBackStackEntry?.destination\n            items.forEach { screen -\u003e\n                BottomNavigationItem(\n                    icon = { Icon(Icons.Filled.Favorite, contentDescription = null) },\n                    label = { Text(stringResource(screen.resourceId)) },\n                    selected = currentDestination?.hierarchy?.any { it.route == screen.route } == true,\n                    onClick = {\n                        navController.navigate(screen.route) {\n                            popUpTo(navController.graph.findStartDestination().id) {\n                                saveState = true\n                            }\n                            launchSingleTop = true\n                            restoreState = true\n                        }\n                    }\n                )\n            }\n        }\n    }\n) { innerPadding -\u003e\n    NavHost(navController, startDestination = Screen.Profile.route, Modifier.padding(innerPadding)) {\n        composable(Screen.Profile.route) { Profile(navController) }\n        composable(Screen.FriendsList.route) { FriendsList(navController) }\n    }\n}\n```  \n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNavController.currentBackStackEntryAsState() 메소드를 활용하여 네비게이션 컨트롤러 상태를 NavHost 함수 밖으로 빼내어 BottomNavigation 컴포넌트와 공유합니다. 이렇게 하면 BottomNavigation이 항상 최신 상태를 가지게 됩니다.\n\n읽어 주셔서 감사합니다. 🙌🙏✌\n\n더 많은 안드로이드 개발, 코틀린 및 KMP에 관한 유용한 기사를 보시려면 박수를 날려주세요 👏 그리고 팔로우해 주세요.\n\n안드로이드, 코틀린 및 KMP 관련 도움이 필요하시다면 언제든지 도와드리겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nMedium, LinkedIn, Twitter, GitHub, Instagram에서 나를 팔로우하고 DM으로 앱 개발 프리랜싱 업무를 문의해주세요.","ogImage":{"url":"/assets/img/2024-05-18-NavigationinJetpackcomposeFullguideBeginnertoAdvanced_0.png"},"coverImage":"/assets/img/2024-05-18-NavigationinJetpackcomposeFullguideBeginnertoAdvanced_0.png","tag":["Tech"],"readingTime":19},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e아래는 Markdown 형식으로 변환되었습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-18-NavigationinJetpackcomposeFullguideBeginnertoAdvanced_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch1\u003e안드로이드에서의 네비게이션은 무엇인가요?\u003c/h1\u003e\n\u003cp\u003e네비게이션은 애플리케이션의 다른 구성 요소 간에 이동하는 방법을 이해하는 데 도움이 됩니다.\u003c/p\u003e\n\u003cp\u003eAndroid JetPack 네비게이션은 고수준의 네비게이션을 간편하게 구현하는 데 도움을 줍니다.\u003c/p\u003e\n\u003cp\u003e네비게이션 컴포넌트는 세 가지 주요 부분으로 구성되어 있어요:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e네비게이션 그래프: 이는 모든 네비게이션 관련 데이터를 한 곳에 모아 둔 리소스입니다. 이에는 앱 내의 모든 위치인 목적지들과 사용자가 앱을 통해 이동할 수 있는 가능한 경로들이 포함됩니다. 앱에서 갈 수 있는 모든 장소와 그 있는 방법을 담은 큰 책처럼 생각하시면 좋아요. 이것은 지도와 안내서가 결합된 것으로 이해할 수 있어요.\u003c/li\u003e\n\u003cli\u003eNavHost: 이는 레이아웃에 포함할 수 있는 독특한 컴포저블(composable)입니다. 네비게이션 그래프에서 다양한 목적지를 표시해줘요. NavHost는 NavController를 네비게이션 그래프에 연결하여 네비게이션 사이를 이동할 수 있는 컴포저블 목적지를 지정하는 링크 역할을 합니다. 컴포저블 간을 이동하는 동안 NavHost의 내용은 자동으로 recompose됩니다. 네비게이션 그래프의 각 컴포저블 목적지는 경로에 연결돼 있어요.\u003c/li\u003e\n\u003cli\u003eNavController: NavController는 네비게이션 컴포넌트의 중심 API입니다. 이는 상태를 가지고 있으며, 앱의 화면을 구성하는 컴포저블들의 백 스택과 각 화면의 상태를 추적합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003eJetpack Compose에서의 네비게이션\u003c/h1\u003e\n\u003cp\u003e네비게이션 컴포넌트는 Jetpack Compose 애플리케이션을 지원해줍니다. 네비게이션 컴포넌트의 인프라와 기능을 활용하면서 컴포저블들 간을 이동할 수 있어요.\u003c/p\u003e\n\u003cp\u003eJetpack Compose에서 탐색을 시작하려면 프로젝트의 build.gradle 파일에 필수 종속성을 포함해야 합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eimplementation \u003cspan class=\"hljs-string\"\u003e\"androidx.navigation:navigation-compose:2.7.1\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eJetpack Compose에서 탐색에 대한 기본 개념.\u003c/p\u003e\n\u003ch2\u003eNavController:\u003c/h2\u003e\n\u003cp\u003eNavController은 네비게이션 컴포넌트의 중심 API입니다. 상태를 유지하며, 앱의 화면을 구성하는 컴포저블의 백 스택 및 각 화면의 상태를 추적합니다.\u003c/p\u003e\n\u003cp\u003e이러한 NavController는 다음과 같이 rememberNavController() 메서드를 사용하여 만들 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eval navController = \u003cspan class=\"hljs-title function_\"\u003erememberNavController\u003c/span\u003e()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNavController를 만들 때는 모든 컴포저블이 해당 NavController에 액세스할 수 있는 컴포저블 계층구조의 적절한 위치에서 만들어야 합니다. 이는 상태 끌어올리기(state hoisting)의 원리를 따르며, 현재 currentBackStackEntryAsState()를 통해 제공되는 NavController 및 상태를 통해 화면 외부의 컴포저블을 업데이트하는 데 참고할 수 있도록 합니다. 이러한 기능의 예시는 바텀 네비게이션바와의 통합을 참고하세요.\u003c/p\u003e\n\u003ch2\u003eNavHost:\u003c/h2\u003e\n\u003cp\u003e각 NavController는 단일 NavHost composable과 연결되어야 합니다. NavHost는 NavController를 네비게이션 그래프와 연결하여 이동할 수 있는 composable 목적지를 지정합니다. composable 사이를 이동하면 NavHost의 내용이 자동으로 recomposed됩니다. 네비게이션 그래프의 각 composable 목적지는 route와 연결됩니다.\u003c/p\u003e\n\u003cp\u003eNavHost를 생성하려면 이전에 rememberNavController()를 통해 생성한 NavController와 그래프의 시작 목적지인 route가 필요합니다. NavHost 생성은 네비게이션 Kotlin DSL에서 lambda 구문을 사용하여 네비게이션 그래프를 구성합니다. composable() 메서드를 사용하여 네비게이션 구조를 추가할 수 있습니다. 이 메서드는 route 및 목적지에 연결할 composable를 제공해야 합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eNavHost\u003c/span\u003e(navController = navController, startDestination = \u003cspan class=\"hljs-string\"\u003e\"profile\"\u003c/span\u003e) {\n    \u003cspan class=\"hljs-title function_\"\u003ecomposable\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-string\"\u003e\"profile\"\u003c/span\u003e\u003c/span\u003e) { \u003cspan class=\"hljs-title class_\"\u003eProfile\u003c/span\u003e(\u003cspan class=\"hljs-comment\"\u003e/*...*/\u003c/span\u003e) }\n    \u003cspan class=\"hljs-title function_\"\u003ecomposable\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-string\"\u003e\"friendslist\"\u003c/span\u003e\u003c/span\u003e) { \u003cspan class=\"hljs-title class_\"\u003eFriendsList\u003c/span\u003e(\u003cspan class=\"hljs-comment\"\u003e/*...*/\u003c/span\u003e) }\n    \u003cspan class=\"hljs-comment\"\u003e/*...*/\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e예시: 네비게이션 그래프, 네브호스트 및 네비게이션 아이템 설정하는 방법\u003c/p\u003e\n\u003cp\u003e단계 1: 네비게이션을 위한 화면 이름 및 라우트를 하나의 파일에 정의합니다. 예시. AppNavigation.kt\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-kotlin\"\u003e\u003cspan class=\"hljs-keyword\"\u003eenum\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eScreen\u003c/span\u003e {\n    HOME,    \n    LOGIN,\n}\n\u003cspan class=\"hljs-keyword\"\u003esealed\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eNavigationItem\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e route: String) {\n    \u003cspan class=\"hljs-keyword\"\u003eobject\u003c/span\u003e Home : NavigationItem(Screen.HOME.name)\n    \u003cspan class=\"hljs-keyword\"\u003eobject\u003c/span\u003e Login : NavigationItem(Screen.LOGIN.name)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e단계 2: NavHost 및 화면을 정의합니다. 예시. AppNavHost.kt\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-kotlin\"\u003e\u003cspan class=\"hljs-meta\"\u003e@Composable\u003c/span\u003e\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efun\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eAppNavHost\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(\n    modifier: \u003cspan class=\"hljs-type\"\u003eModifier\u003c/span\u003e = Modifier,\n    navController: \u003cspan class=\"hljs-type\"\u003eNavHostController\u003c/span\u003e,\n    startDestination: \u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e = NavigationItem.Splash.route,\n    ... \u003cspan class=\"hljs-comment\"\u003e// 다른 매개변수\u003c/span\u003e\n)\u003c/span\u003e\u003c/span\u003e {\n    NavHost(\n        modifier = modifier,\n        navController = navController,\n        startDestination = startDestination\n    ) {\n        composable(NavigationItem.Splash.route) {\n            SplashScreen(navController)\n        }\n        composable(NavigationItem.Login.route) {\n            LoginScreen(navController)\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e단계 3: MainActivity.kt 파일에서 AppNavHost를 호출합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-kotlin\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMainActivity\u003c/span\u003e : \u003cspan class=\"hljs-type\"\u003eComponentActivity\u003c/span\u003e() {\n    \u003cspan class=\"hljs-keyword\"\u003eoverride\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efun\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eonCreate\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(savedInstanceState: \u003cspan class=\"hljs-type\"\u003eBundle\u003c/span\u003e?)\u003c/span\u003e\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003esuper\u003c/span\u003e.onCreate(savedInstanceState)\n        setContent {\n            AutoPartsAppTheme {\n               Surface(\n                    modifier = Modifier.fillMaxSize(),\n                    color = MaterialTheme.colorScheme.background\n                ) {\n                    AppNavHost(navController = rememberNavController())\n                }\n            }\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e네비게이션 인자:\u003c/h2\u003e\n\u003cp\u003e네비게이션 Compose는 코틀린을 사용하여 콤포저블 목적지 간에 인수를 전달하는 것을 지원합니다. 이를 위해 기본 네비게이션 라이브러리를 사용할 때 딥 링크에 인수를 추가하는 방식과 유사한 방식으로 라우트에 인수 자리 표시자를 추가해야 합니다.\u003c/p\u003e\n\u003ch2\u003e사용 사례:\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e인수가 없을 때\u003c/li\u003e\n\u003cli\u003eInt, String 등 미리 정의된 데이터 유형과 같은 간단한 인수를 사용할 때\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003e사용자가 정의한 데이터 유형 같은 복잡한 인수를 사용할 때\u003c/li\u003e\n\u003c/ol\u003e\n\u003col start=\"4\"\u003e\n\u003cli\u003e\n\u003cp\u003e선택적 매개변수\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e결과값으로 되돌아가기\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2\u003e매개변수 없이:\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eNavHost\u003c/span\u003e(navController = navController, startDestination = \u003cspan class=\"hljs-string\"\u003e\"profile\"\u003c/span\u003e) {\n    \u003cspan class=\"hljs-title function_\"\u003ecomposable\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-string\"\u003e\"profile\"\u003c/span\u003e\u003c/span\u003e) { \u003cspan class=\"hljs-title class_\"\u003eProfile\u003c/span\u003e(\u003cspan class=\"hljs-comment\"\u003e/*...*/\u003c/span\u003e) }\n    \u003cspan class=\"hljs-title function_\"\u003ecomposable\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-string\"\u003e\"friendslist\"\u003c/span\u003e\u003c/span\u003e) { \u003cspan class=\"hljs-title class_\"\u003eFriendsList\u003c/span\u003e(\u003cspan class=\"hljs-comment\"\u003e/*...*/\u003c/span\u003e) }\n    \u003cspan class=\"hljs-comment\"\u003e/*...*/\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e간단한 인수로:\u003c/h2\u003e\n\u003cp\u003e기본적으로 모든 인수는 문자열로 구문 분석됩니다. composable()의 인수 매개변수는 NamedNavArguments의 목록을 허용합니다. navArgument 메서드를 사용하여 NamedNavArgument를 빠르게 만들고 그 정확한 유형을 지정할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eNavHost\u003c/span\u003e(startDestination = \u003cspan class=\"hljs-string\"\u003e\"profile/{userId}\"\u003c/span\u003e) {\n    ...\n    \u003cspan class=\"hljs-title function_\"\u003ecomposable\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-string\"\u003e\"profile/{userId}\"\u003c/span\u003e\u003c/span\u003e) {...}\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e기본적으로 모든 인수는 문자열로 구문 분석됩니다. composable()의 인수 매개변수는 NamedNavArguments의 목록을 허용합니다. navArgument 메서드를 사용하여 NamedNavArgument를 빠르게 만들고 그 정확한 유형을 지정할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eNavHost\u003c/span\u003e(startDestination = \u003cspan class=\"hljs-string\"\u003e\"profile/{userId}\"\u003c/span\u003e) {\n    ...\n    \u003cspan class=\"hljs-title function_\"\u003ecomposable\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\n        \u003cspan class=\"hljs-string\"\u003e\"profile/{userId}\"\u003c/span\u003e,\n        \u003cspan class=\"hljs-variable language_\"\u003earguments\u003c/span\u003e = listOf(navArgument(\u003cspan class=\"hljs-string\"\u003e\"userId\"\u003c/span\u003e){\n           type = NavType.StringType \n        })\n    \u003c/span\u003e) {...}\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003ecomposable(\"profile/{userId}\") { backStackEntry -\u003e    val userId = backStackEntry.arguments?.getString(\"userId\")    // 여기서 사용자 데이터를 가져와야 합니다    Profile(       navController,        // 사용자 데이터를 가져와서 전달하세요. 예: UserInfo    ) } \u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e대상으로 전달하려면 navigate 호출 시 경로에 추가해야 합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003enavController.\u003cspan class=\"hljs-title function_\"\u003enavigate\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"profile/user1234\"\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e지원되는 유형 목록을 보려면 전달 방법을 참조하세요.\u003c/p\u003e\n\u003ch2\u003e복잡하거나 사용자 정의 인수로:\u003c/h2\u003e\n\u003cp\u003e이동할 때 복잡한 데이터 객체를 전달하는 것은 권장되지 않지만 대신 고유 식별자 또는 기타 형식의 ID와 같이 최소한의 정보를 인수로 전달해야합니다. 이를 통해 이동 작업 수행 가능합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 새로운 대상으로 이동할 때 사용자 ID만 전달하실 때\u003c/span\u003e\nnavController.\u003cspan class=\"hljs-title function_\"\u003enavigate\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"profile/user1234\"\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e복잡한 객체는 데이터 레이어와 같은 단일 진실의 원천으로 저장해야 합니다. 이동 후 목적지에 도착하면 전달된 ID를 사용하여 단일 진실의 원천에서 필요한 정보를로드할 수 있습니다. 데이터 레이어에 액세스하는 ViewModel에서 인수를 검색하려면 SavedStateHandle를 사용할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUserViewModel\u003c/span\u003e(\n    \u003cspan class=\"hljs-attr\"\u003esavedStateHandle\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eSavedStateHandle\u003c/span\u003e,\n    private val \u003cspan class=\"hljs-attr\"\u003euserInfoRepository\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eUserInfoRepository\u003c/span\u003e\n) : \u003cspan class=\"hljs-title class_\"\u003eViewModel\u003c/span\u003e() {\n\n    private val \u003cspan class=\"hljs-attr\"\u003euserId\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e = \u003cspan class=\"hljs-title function_\"\u003echeckNotNull\u003c/span\u003e(savedStateHandle[\u003cspan class=\"hljs-string\"\u003e\"userId\"\u003c/span\u003e])\n\n    \u003cspan class=\"hljs-comment\"\u003e// 전달된 userId 인수를 기반으로 데이터 레이어(예: userInfoRepository)에서 관련 사용자 정보 검색\u003c/span\u003e\n    private val \u003cspan class=\"hljs-attr\"\u003euserInfo\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eFlow\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eUserInfo\u003c/span\u003e\u003e = userInfoRepository.\u003cspan class=\"hljs-title function_\"\u003egetUserInfo\u003c/span\u003e(userId)\n\n   --------------- \u003cspan class=\"hljs-variable constant_\"\u003eOR\u003c/span\u003e -----------------\n \n    \u003cspan class=\"hljs-comment\"\u003e// 네트워크 또는 데이터베이스에서 데이터 가져오기    \u003c/span\u003e\n    private val _dataFlow =\n            \u003cspan class=\"hljs-title class_\"\u003eMutableStateFlow\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eUserInfo\u003c/span\u003e\u003e(userInfoRepository.\u003cspan class=\"hljs-title function_\"\u003egetUserInfo\u003c/span\u003e(userId))\n    val dataFlow \u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e() = _dataFlow.\u003cspan class=\"hljs-title function_\"\u003easStateFlow\u003c/span\u003e()\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e적합한 기능\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-kotlin\"\u003e\u003cspan class=\"hljs-comment\"\u003e//Navhost\u003c/span\u003e\ncomposable(\u003cspan class=\"hljs-string\"\u003e\"profile/{userId}\"\u003c/span\u003e) { backStackEntry -\u003e\n   \u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e userId = backStackEntry.arguments?.getString(\u003cspan class=\"hljs-string\"\u003e\"userId\"\u003c/span\u003e)\n   \u003cspan class=\"hljs-comment\"\u003e// 여기서 사용자 데이터를 가져와야 합니다\u003c/span\u003e\n   \u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e userInfo \u003cspan class=\"hljs-keyword\"\u003eby\u003c/span\u003e taskViewModel.dataFlow.collectAsState()   \n   Profile(\n      navController, \n      userInfo\n   )\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// 프로필 화면\u003c/span\u003e\n\u003cspan class=\"hljs-meta\"\u003e@Composable\u003c/span\u003e\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efun\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eProfile\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(navController: \u003cspan class=\"hljs-type\"\u003eNavController\u003c/span\u003e, userInfo: \u003cspan class=\"hljs-type\"\u003eUserInfo\u003c/span\u003e)\u003c/span\u003e\u003c/span\u003e{\n    \u003cspan class=\"hljs-comment\"\u003e// 여기서 작업을 수행합니다\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 접근 방식은 구성 변경 중에 데이터 유실을 방지하고 해당 객체가 업데이트되거나 변경될 때 불일치를 방지합니다.\u003c/p\u003e\n\u003cp\u003e복잡한 데이터를 인수로 전달하는 것을 피해야 하는 이유 및 지원되는 인수 유형 목록에 대한 보다 자세한 설명은 Best practice를 참조하세요.\u003c/p\u003e\n\u003ch2\u003e선택적 인수 추가하기\u003c/h2\u003e\n\u003cp\u003eNavigation Compose는 선택적 네비게이션 인수도 지원합니다. 선택적 인수는 필수 인수와 두 가지 방법으로 다릅니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e쿼리 매개변수 구문(\"?argName='argName'\")을 사용하여 포함되어야 합니다.\u003c/li\u003e\n\u003cli\u003edefaultValue가 설정되어 있어야 하거나 nullable = true이어야 합니다(이는 기본 값을 자동으로 null로 설정합니다).\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이는 모든 선택적 인수가 콤포저블() 함수에 명시적으로 추가되어야 한다는 것을 의미합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title function_\"\u003ecomposable\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\n    \u003cspan class=\"hljs-string\"\u003e\"profile?userId={userId}/{isMember}\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-variable language_\"\u003earguments\u003c/span\u003e = listOf(\n         navArgument(\u003cspan class=\"hljs-string\"\u003e\"userId\"\u003c/span\u003e) {\n            type = NavType.StringType\n            defaultValue = \u003cspan class=\"hljs-string\"\u003e\"user1234\"\u003c/span\u003e\n           // 또는\n            type = NavType.StringType\n            nullable = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e\n         },\n         navArgument(\u003cspan class=\"hljs-string\"\u003e\"isNewTask\"\u003c/span\u003e) {\n            type = NavType.BoolType\n         }\n     )\n\u003c/span\u003e) { backStackEntry -\u003e\n    val userId = backStackEntry.\u003cspan class=\"hljs-property\"\u003earguments\u003c/span\u003e?.\u003cspan class=\"hljs-title function_\"\u003egetString\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"userId\"\u003c/span\u003e)\n    val isMember = backStackEntry.\u003cspan class=\"hljs-property\"\u003earguments\u003c/span\u003e?.\u003cspan class=\"hljs-title function_\"\u003egetBoolean\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"isMember\"\u003c/span\u003e)?:\u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e\n    \u003cspan class=\"hljs-title class_\"\u003eProfile\u003c/span\u003e(navController, userId, isMember)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 대상에 인수가 전달되지 않더라도 defaultValue = \"user1234\"가 대신 사용됩니다.\u003c/p\u003e\n\u003cp\u003e경로를 통해 인수를 처리하는 구조는 Composable이 Navigation과 완전히 독립되도록 하며 이로 인해 테스트하기 훨씬 더 용이해집니다.\u003c/p\u003e\n\u003ch2\u003e결과 값으로 되돌아가기\u003c/h2\u003e\n\u003cp\u003e결과 값을 사용하여 되돌아가는 것이 가장 일반적인 작업입니다. 즉, 필터 대화상자를 열고 필터를 선택한 다음 해당 필터를 적용하기 위해 선택된 필터와 함께 되돌아가는 경우입니다.\u003c/p\u003e\n\u003cp\u003e두 개의 화면이 있습니다. 1. 첫 번째 화면과 2. 두 번째 화면입니다. 우리는 두 번째 화면에서 첫 번째 화면으로 데이터를 필요로 합니다.\u003c/p\u003e\n\u003cp\u003eNavHost.kt : 내비게이션 그래프 설정.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e val navController = \u003cspan class=\"hljs-title function_\"\u003erememberNavController\u003c/span\u003e()\n \u003cspan class=\"hljs-title class_\"\u003eNavHost\u003c/span\u003e(\n     navController = navController,\n     startDestination = \u003cspan class=\"hljs-string\"\u003e\"firstscreen\"\u003c/span\u003e\n ) {\n    \u003cspan class=\"hljs-title function_\"\u003ecomposable\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-string\"\u003e\"firstscreen\"\u003c/span\u003e\u003c/span\u003e) {\n        \u003cspan class=\"hljs-title class_\"\u003eFirstScreen\u003c/span\u003e(navController)\n    }\n    \u003cspan class=\"hljs-title function_\"\u003ecomposable\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-string\"\u003e\"secondscreen\"\u003c/span\u003e\u003c/span\u003e) {\n        \u003cspan class=\"hljs-title class_\"\u003eSecondScreen\u003c/span\u003e(navController)\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFirstScreen.kt: NavController의 현재 백 스택 항목의 savedStateHandle를 사용하여 두 번째 화면에서 다시 이동한 후 데이터를 검색합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-kotlin\"\u003e\u003cspan class=\"hljs-meta\"\u003e@Composable\u003c/span\u003e\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efun\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eFirstScreen\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(navController: \u003cspan class=\"hljs-type\"\u003eNavController\u003c/span\u003e)\u003c/span\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-comment\"\u003e// 다음 화면에서 데이터를 가져옵니다\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e msg = \n        navController.currentBackStackEntry?.savedStateHandle?.\u003cspan class=\"hljs-keyword\"\u003eget\u003c/span\u003e\u0026#x3C;String\u003e(\u003cspan class=\"hljs-string\"\u003e\"msg\"\u003c/span\u003e)\n    Column(\n        Modifier.fillMaxSize(),\n        horizontalAlignment = Alignment.CenterHorizontally,\n        verticalArrangement = Arrangement.Center\n    ) {\n        Button(onClick = { navController.navigate(\u003cspan class=\"hljs-string\"\u003e\"secondscreen\"\u003c/span\u003e) }) {\n            Text(\u003cspan class=\"hljs-string\"\u003e\"다음 화면으로 이동\"\u003c/span\u003e)\n        }\n        Spacer(modifier = Modifier.height(\u003cspan class=\"hljs-number\"\u003e8.\u003c/span\u003edp))\n        msg?.let {\n            Text(it)\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSecondScreen.kt: 이전 백 스택 항목의 savedStateHandle 내에 데이터를 넣습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-kotlin\"\u003e\u003cspan class=\"hljs-meta\"\u003e@Composable\u003c/span\u003e\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efun\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eSecondScreen\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(navController: \u003cspan class=\"hljs-type\"\u003eNavController\u003c/span\u003e)\u003c/span\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e text \u003cspan class=\"hljs-keyword\"\u003eby\u003c/span\u003e remember {\n        mutableStateOf(\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e)\n    }\n    Column(\n        Modifier.fillMaxSize(),\n        horizontalAlignment = Alignment.CenterHorizontally,\n        verticalArrangement = Arrangement.Center\n    ) {\n        TextField(\n            value = text, onValueChange = { text = it },\n            placeholder = {\n                Text(\u003cspan class=\"hljs-string\"\u003e\"텍스트를 입력하세요\"\u003c/span\u003e, color = Color.Gray)\n            }\n        )\n        Spacer(Modifier.height(\u003cspan class=\"hljs-number\"\u003e8.\u003c/span\u003edp))\n        Button(onClick = {\n\n           \u003cspan class=\"hljs-comment\"\u003e// 데이터를 savedStateHandle에 넣어 이전 화면에서 데이터를 가져옵니다\u003c/span\u003e\n   \n            navController.previousBackStackEntry?.savedStateHandle?.\u003cspan class=\"hljs-keyword\"\u003eset\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"msg\"\u003c/span\u003e, text)\n            navController.popBackStack()\n        }) {\n            Text(text = \u003cspan class=\"hljs-string\"\u003e\"제출\"\u003c/span\u003e)\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e비디오:\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/KaushalVasava/JetPackCompose_Basic/assets/49050597/1d96d44f-66e1-4f3b-bba1-2844ab6553cc\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://github.com/KaushalVasava/JetPackCompose_Basic/assets/49050597/1d96d44f-66e1-4f3b-bba1-2844ab6553cc\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eGitHub 저장소: \u003ca href=\"https://github.com/KaushalVasava/JetPackCompose_Basic/tree/navigate-back-with-result\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://github.com/KaushalVasava/JetPackCompose_Basic/tree/navigate-back-with-result\u003c/a\u003e\u003c/p\u003e\n\u003ch1\u003e딥 링크\u003c/h1\u003e\n\u003cp\u003eNavigation Compose은 암시적 딥 링크를 지원하며 composable() 함수의 일부로 정의할 수 있습니다. 딥 링크 매개변수 deepLinks는 navDeepLink 메소드를 사용하여 빠르게 생성할 수 있는 NavDeepLinks 목록을 수용합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eval uri = \u003cspan class=\"hljs-string\"\u003e\"https://www.example.com\"\u003c/span\u003e\n\u003cspan class=\"hljs-title function_\"\u003ecomposable\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\n    \u003cspan class=\"hljs-string\"\u003e\"profile?id={id}\"\u003c/span\u003e,\n    deepLinks = listOf(navDeepLink { uriPattern = \u003cspan class=\"hljs-string\"\u003e\"$uri/{id}\"\u003c/span\u003e })\n\u003c/span\u003e) { backStackEntry -\u003e\n    \u003cspan class=\"hljs-title class_\"\u003eProfile\u003c/span\u003e(navController, backStackEntry.\u003cspan class=\"hljs-property\"\u003earguments\u003c/span\u003e?.\u003cspan class=\"hljs-title function_\"\u003egetString\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"id\"\u003c/span\u003e))\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이러한 딥 링크를 사용하면 특정 URL, 액션 또는 MIME 유형을 composable과 연결할 수 있습니다. 기본적으로 이러한 딥 링크는 외부 앱에 노출되지 않습니다. 이러한 딥 링크를 외부에서 사용 가능하게 하려면 앱의 manifest.xml 파일에 적절한 \u003ccode\u003eintent-filter\u003c/code\u003e 요소를 추가해야 합니다. 위의 딥 링크를 활성화하려면 manifest의 \u003ccode\u003eactivity\u003c/code\u003e 요소 내에 다음을 추가해야 합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u0026#x3C;activity …\u003e\n  \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eintent-filter\u003c/span\u003e\u003e\u003c/span\u003e\n    ...\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003edata\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eandroid:scheme\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"https\"\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eandroid:host\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"www.example.com\"\u003c/span\u003e /\u003e\u003c/span\u003e\n  \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eintent-filter\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\u0026#x3C;/activity\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다른 앱에 의해 트리거된 경우 딥 링크가 활성화될 때 해당 composable로 자동으로 이동합니다.\u003c/p\u003e\n\u003cp\u003e이러한 동일한 딥 링크는 콤포저블에서 적절한 딥 링크와 함께 PendingIntent를 작성하는 데 사용할 수도 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-kotlin\"\u003e\u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e id = \u003cspan class=\"hljs-string\"\u003e\"exampleId\"\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e context = LocalContext.current\n\u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e deepLinkIntent = Intent(\n    Intent.ACTION_VIEW,\n    \u003cspan class=\"hljs-string\"\u003e\"https://www.example.com/\u003cspan class=\"hljs-variable\"\u003e$id\u003c/span\u003e\"\u003c/span\u003e.toUri(),\n    context,\n    MyActivity::\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e.java\n)\n\u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e deepLinkPendingIntent: PendingIntent? = TaskStackBuilder.create(context).run {\n    addNextIntentWithParentStack(deepLinkIntent)\n    \n    \u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e flag = \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e(Build.VERSION.SDK_INT \u003e Build.VERSION_CODES.S){\n                    PendingIntent.FLAG_IMMUTABLE\n                } \n                \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \n                    PendingIntent.FLAG_UPDATE_CURRENT\n    getPendingIntent(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, flag)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그런 다음 이 deepLinkPendingIntent를 다른 PendingIntent와 마찬가지로 사용하여 앱을 딥 링크 대상지에서 열 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e중첩된 내비게이션\u003c/h1\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-18-NavigationinJetpackcomposeFullguideBeginnertoAdvanced_1.png\" alt=\"Image\"\u003e\u003c/p\u003e\n\u003cp\u003e앱의 UI에서 특정 플로우를 모듈화하기 위해 대상을 중첩 그래프로 그룹화할 수 있습니다. 이러한 예로는 독립적인 로그인 플로우가 있을 수 있습니다.\u003c/p\u003e\n\u003cp\u003e중첩 그래프는 메인 그래프처럼 대상을 그룹화하며 해당 경로에 대한 지정된 시작 대상이 필요합니다. 이것은 중첩된 그래프의 경로에 액세스할 때 이동할 위치입니다.\u003c/p\u003e\n\u003cp\u003eNavHost에 중첩된 그래프를 추가하려면 네비게이션 익스텐션 함수를 사용할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eNavHost\u003c/span\u003e(navController, startDestination = \u003cspan class=\"hljs-string\"\u003e\"home\"\u003c/span\u003e) {\n    ...\n    \u003cspan class=\"hljs-comment\"\u003e// 그래프를 통해 경로('login')로 이동하면 자동으로\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e// 그래프의 시작 대상인 'username'으로 이동합니다.\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e// 이로써 그래프의 내부 라우팅 로직을 캡슐화합니다.\u003c/span\u003e\n    \u003cspan class=\"hljs-title function_\"\u003enavigation\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003estartDestination = \u003cspan class=\"hljs-string\"\u003e\"username\"\u003c/span\u003e, route = \u003cspan class=\"hljs-string\"\u003e\"login\"\u003c/span\u003e\u003c/span\u003e) {\n        \u003cspan class=\"hljs-title function_\"\u003ecomposable\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-string\"\u003e\"username\"\u003c/span\u003e\u003c/span\u003e) { ... }\n        \u003cspan class=\"hljs-title function_\"\u003ecomposable\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-string\"\u003e\"password\"\u003c/span\u003e\u003c/span\u003e) { ... }\n        \u003cspan class=\"hljs-title function_\"\u003ecomposable\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-string\"\u003e\"registration\"\u003c/span\u003e\u003c/span\u003e) { ... }\n    }\n    ...\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그래프가 커질수록 여러 메소드로 나누는 것이 좋습니다. 이렇게 하면 여러 모듈이 각자의 네비게이션 그래프를 기여할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003efun \u003cspan class=\"hljs-title class_\"\u003eNavGraphBuilder\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eloginGraph\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003enavController: NavController\u003c/span\u003e) {\n    \u003cspan class=\"hljs-title function_\"\u003enavigation\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003estartDestination = \u003cspan class=\"hljs-string\"\u003e\"username\"\u003c/span\u003e, route = \u003cspan class=\"hljs-string\"\u003e\"login\"\u003c/span\u003e\u003c/span\u003e) {\n        \u003cspan class=\"hljs-title function_\"\u003ecomposable\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-string\"\u003e\"username\"\u003c/span\u003e\u003c/span\u003e) { ... }\n        \u003cspan class=\"hljs-title function_\"\u003ecomposable\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-string\"\u003e\"password\"\u003c/span\u003e\u003c/span\u003e) { ... }\n        \u003cspan class=\"hljs-title function_\"\u003ecomposable\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-string\"\u003e\"registration\"\u003c/span\u003e\u003c/span\u003e) { ... }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNavGraphBuilder를 확장 메소드로 만들면 미리 작성된 navigation, composable, dialog 익스텐션 메소드와 함께 사용할 수 있습니다.```\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-kotlin\"\u003eNavHost(navController, startDestination = \u003cspan class=\"hljs-string\"\u003e\"home\"\u003c/span\u003e) {\n    ...\n    loginGraph(navController)\n    ...\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e예시:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-kotlin\"\u003e\u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e navController = rememberNavController()\nNavHost(navController = navController, startDestination = \u003cspan class=\"hljs-string\"\u003e\"home\"\u003c/span\u003e) {\n    composable(\u003cspan class=\"hljs-string\"\u003e\"about\"\u003c/span\u003e) {}\n    navigation(\n        startDestination = \u003cspan class=\"hljs-string\"\u003e\"login\"\u003c/span\u003e,\n        route = \u003cspan class=\"hljs-string\"\u003e\"auth\"\u003c/span\u003e\n    ) {\n        composable(\u003cspan class=\"hljs-string\"\u003e\"login\"\u003c/span\u003e) {\n            \u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e viewModel = it.sharedViewModel\u0026#x3C;SampleViewModel\u003e(navController)\n\n            Button(onClick = {\n                navController.navigate(\u003cspan class=\"hljs-string\"\u003e\"calendar\"\u003c/span\u003e) {\n                    popUpTo(\u003cspan class=\"hljs-string\"\u003e\"auth\"\u003c/span\u003e) {\n                        inclusive = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e\n                    }\n                }\n            }) {\n            }\n        }\n        composable(\u003cspan class=\"hljs-string\"\u003e\"register\"\u003c/span\u003e) {\n            \u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e viewModel = it.sharedViewModel\u0026#x3C;SampleViewModel\u003e(navController)\n        } \n        composable(\u003cspan class=\"hljs-string\"\u003e\"forgot_password\"\u003c/span\u003e) {\n            \u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e viewModel = it.sharedViewModel\u0026#x3C;SampleViewModel\u003e(navController)\n        }\n    }\n    navigation(\n        startDestination = \u003cspan class=\"hljs-string\"\u003e\"calendar_overview\"\u003c/span\u003e,\n        route = \u003cspan class=\"hljs-string\"\u003e\"calendar\"\u003c/span\u003e\n    ) {\n        composable(\u003cspan class=\"hljs-string\"\u003e\"calendar_overview\"\u003c/span\u003e) { }\n        composable(\u003cspan class=\"hljs-string\"\u003e\"calendar_entry\"\u003c/span\u003e) { }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNavBackStack entry를 위한 확장 함수\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-kotlin\"\u003e\u003cspan class=\"hljs-meta\"\u003e@Composable\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003einline\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efun\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003e\u0026#x3C;\u003cspan class=\"hljs-keyword\"\u003ereified\u003c/span\u003e T : ViewModel\u003e\u003c/span\u003e NavBackStackEntry.\u003cspan class=\"hljs-title\"\u003esharedViewModel\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(navController: \u003cspan class=\"hljs-type\"\u003eNavController\u003c/span\u003e)\u003c/span\u003e\u003c/span\u003e: T {\n    \u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e navGraphRoute = destination.parent?.route ?: \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e viewModel()\n    \u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e parentEntry = remember(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e) {\n        navController.getBackStackEntry(navGraphRoute)\n    }\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e viewModel(parentEntry)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e하단 탐색 막대와 통합\u003c/h1\u003e\n\u003cp\u003e조합 가능한 구조의 위쪽 수준에서 NavController를 정의함으로써, 네비게이션을 하단 탐색 막대와 같은 다른 구성 요소와 연결할 수 있습니다. 이를 통해 하단 막대에서 아이콘을 선택하여 탐색할 수 있습니다.\u003c/p\u003e\n\u003cp\u003eBottomNavigation 및 BottomNavigationItem 구성 요소를 사용하려면 Android 애플리케이션에 androidx.compose.material 종속성을 추가하십시오.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e좌측 테이블을 \u003cspan class=\"hljs-title class_\"\u003eMarkdown\u003c/span\u003e 형식으로 변환했습니다.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e하단 네비게이션바의 항목을 네비게이션 그래프의 루트에 링크하려면 Screen과 같은 sealed class를 정의하는 것이 좋습니다. 이 클래스는 목적지의 루트와 문자열 리소스 ID를 포함합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003esealed \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eScreen\u003c/span\u003e(val \u003cspan class=\"hljs-attr\"\u003eroute\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e, @\u003cspan class=\"hljs-title class_\"\u003eStringRes\u003c/span\u003e val \u003cspan class=\"hljs-attr\"\u003eresourceId\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eInt\u003c/span\u003e) {\n    object \u003cspan class=\"hljs-title class_\"\u003eProfile\u003c/span\u003e : \u003cspan class=\"hljs-title class_\"\u003eScreen\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"profile\"\u003c/span\u003e, R.\u003cspan class=\"hljs-property\"\u003estring\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eprofile\u003c/span\u003e)\n    object \u003cspan class=\"hljs-title class_\"\u003eFriendsList\u003c/span\u003e : \u003cspan class=\"hljs-title class_\"\u003eScreen\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"friendslist\"\u003c/span\u003e, R.\u003cspan class=\"hljs-property\"\u003estring\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003efriends_list\u003c/span\u003e)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이후 BottomNavigationItem에서 사용할 수 있는 리스트에 해당 항목을 넣으십시오.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-kotlin\"\u003e\u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e items = listOf(\n    Screen.Profile,\n    Screen.FriendsList\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eBottomNavigation 컴포저에서 currentBackStackEntryAsState() 함수를 사용하여 현재 NavBackStackEntry를 가져옵니다. 이 엔트리를 통해 현재 NavDestination에 액세스할 수 있습니다. 각 BottomNavigationItem의 선택 상태는 아이템의 경로를 현재 목적지 및 부모 목적지의 경로와 비교하여 결정할 수 있습니다 (중첩된 내비게이션을 사용하는 경우 처리하기 위해 NavDestination 계층구조를 통해).\u003c/p\u003e\n\u003cp\u003e아이템의 경로는 또한 onClick 람다를 navigate 호출과 연결하는 데 사용되어 해당 아이템을 탭하면 해당 아이템으로 이동합니다. saveState 및 restoreState 플래그를 사용하여 해당 아이템의 상태와 백 스택이 올바르게 저장되고 전환될 때 해당 아이템의 상태가 올바르게 복원됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-kotlin\"\u003e\u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e navController = rememberNavController()\nScaffold(\n    bottomBar = {\n        BottomNavigation {\n            \u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e navBackStackEntry \u003cspan class=\"hljs-keyword\"\u003eby\u003c/span\u003e navController.currentBackStackEntryAsState()\n            \u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e currentDestination = navBackStackEntry?.destination\n            items.forEach { screen -\u003e\n                BottomNavigationItem(\n                    icon = { Icon(Icons.Filled.Favorite, contentDescription = \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) },\n                    label = { Text(stringResource(screen.resourceId)) },\n                    selected = currentDestination?.hierarchy?.any { it.route == screen.route } == \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n                    onClick = {\n                        navController.navigate(screen.route) {\n                            popUpTo(navController.graph.findStartDestination().id) {\n                                saveState = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e\n                            }\n                            launchSingleTop = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e\n                            restoreState = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e\n                        }\n                    }\n                )\n            }\n        }\n    }\n) { innerPadding -\u003e\n    NavHost(navController, startDestination = Screen.Profile.route, Modifier.padding(innerPadding)) {\n        composable(Screen.Profile.route) { Profile(navController) }\n        composable(Screen.FriendsList.route) { FriendsList(navController) }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNavController.currentBackStackEntryAsState() 메소드를 활용하여 네비게이션 컨트롤러 상태를 NavHost 함수 밖으로 빼내어 BottomNavigation 컴포넌트와 공유합니다. 이렇게 하면 BottomNavigation이 항상 최신 상태를 가지게 됩니다.\u003c/p\u003e\n\u003cp\u003e읽어 주셔서 감사합니다. 🙌🙏✌\u003c/p\u003e\n\u003cp\u003e더 많은 안드로이드 개발, 코틀린 및 KMP에 관한 유용한 기사를 보시려면 박수를 날려주세요 👏 그리고 팔로우해 주세요.\u003c/p\u003e\n\u003cp\u003e안드로이드, 코틀린 및 KMP 관련 도움이 필요하시다면 언제든지 도와드리겠습니다.\u003c/p\u003e\n\u003cp\u003eMedium, LinkedIn, Twitter, GitHub, Instagram에서 나를 팔로우하고 DM으로 앱 개발 프리랜싱 업무를 문의해주세요.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-18-NavigationinJetpackcomposeFullguideBeginnertoAdvanced"},"buildId":"RZIEBQ2aNAp_DXFVTV6eL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>