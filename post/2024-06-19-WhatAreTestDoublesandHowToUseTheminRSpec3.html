<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>테스트 더블이란 무엇이며 RSpec 3에서 어떻게 사용하는 지 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-06-19-WhatAreTestDoublesandHowToUseTheminRSpec3" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="테스트 더블이란 무엇이며 RSpec 3에서 어떻게 사용하는 지 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="테스트 더블이란 무엇이며 RSpec 3에서 어떻게 사용하는 지 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-19-WhatAreTestDoublesandHowToUseTheminRSpec3_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-06-19-WhatAreTestDoublesandHowToUseTheminRSpec3" data-gatsby-head="true"/><meta name="twitter:title" content="테스트 더블이란 무엇이며 RSpec 3에서 어떻게 사용하는 지 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-19-WhatAreTestDoublesandHowToUseTheminRSpec3_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-19 22:21" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-4f7b40c1114f0d09.js" defer=""></script><script src="/_next/static/bb_yO9GbCvdfc_n71SfUf/_buildManifest.js" defer=""></script><script src="/_next/static/bb_yO9GbCvdfc_n71SfUf/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">테스트 더블이란 무엇이며 RSpec 3에서 어떻게 사용하는 지</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="테스트 더블이란 무엇이며 RSpec 3에서 어떻게 사용하는 지" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 19, 2024</span><span class="posts_reading_time__f7YPP">4<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-19-WhatAreTestDoublesandHowToUseTheminRSpec3&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/assets/img/2024-06-19-WhatAreTestDoublesandHowToUseTheminRSpec3_0.png" alt="Test Doubles"></p>
<h1>소프트웨어 개발에서의 테스트 더블 이해</h1>
<p>소프트웨어에 대한 테스트를 작성할 때, 종종 실제 객체나 의존성의 동작을 시뮬레이션하기 위해 "테스트 더블" 또는 "모의 객체"를 만들어야 합니다. 각각 특정 목적을 위해 사용되는 다양한 종류의 테스트 더블이 있습니다.</p>
<h1>테스트 더블의 종류</h1>
<p></p>
<p>테스트 더블은 사용 모드와 원본에 따라 분류할 수 있어요.</p>
<h2>사용 모드</h2>
<p>Stub: Stub은 사이드 이펙트를 발생시키지 않고 값을 반환하는 쿼리 메소드를 시뮬레이트하는 데 사용돼요. 미리 정의된 캐너드 응답을 반환합니다.</p>
<pre><code class="hljs language-js"># <span class="hljs-variable constant_">LMS</span> 코스 모델을 위한 <span class="hljs-title class_">Stub</span>
stub_course = <span class="hljs-title function_">double</span>(<span class="hljs-string">'Course'</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'Ruby 입문'</span>, <span class="hljs-attr">description</span>: <span class="hljs-string">'루비 기초 학습'</span>)
</code></pre>
<p></p>
<p>모의 객체: 모의 객체는 값을 반환하는 것보다 부작용을 수행하는 명령 메서드를 테스트할 때 유용합니다. 특정 메시지가 수신되었는지 확인하고, 예상한 메시지가 수신되지 않으면 오류를 발생시킵니다.</p>
<pre><code class="hljs language-js"># <span class="hljs-variable constant_">LMS</span> 등록 서비스용 모의 객체
mock_enrollment_service = <span class="hljs-title function_">double</span>(<span class="hljs-string">'EnrollmentService'</span>)
<span class="hljs-title function_">expect</span>(mock_enrollment_service).<span class="hljs-property">to</span> <span class="hljs-title function_">receive</span>(:enroll).<span class="hljs-title function_">with</span>(user, course)
</code></pre>
<p>널 객체: 널 객체는 어떤 메시지에 대해 자신을 반환하는 친화적인 테스트 대역입니다. 여러 협력자가 있는 객체를 테스트할 때 유용합니다.</p>
<pre><code class="hljs language-js"># <span class="hljs-variable constant_">LMS</span> 사용자용 널 객체
null_user = <span class="hljs-title function_">double</span>(<span class="hljs-string">'User'</span>).<span class="hljs-property">as_null_object</span>
null_user.<span class="hljs-title function_">enroll_in_course</span>(course)
</code></pre>
<p></p>
<p>스파이: 스파이들은 받은 메시지를 기록하여 특정 메시지가 올바른 매개변수로 호출되었음을 확인할 수 있게 해줍니다.</p>
<pre><code class="hljs language-js"># <span class="hljs-variable constant_">LMS</span> 알림 서비스용 스파이
spy_notification_service = <span class="hljs-title function_">spy</span>(<span class="hljs-string">'NotificationService'</span>)
spy_notification_service.<span class="hljs-title function_">send_notification</span>(user, <span class="hljs-string">'환영합니다!'</span>)
<span class="hljs-title function_">expect</span>(spy_notification_service).<span class="hljs-property">to</span> <span class="hljs-title function_">have_received</span>(:send_notification).<span class="hljs-title function_">with</span>(user, <span class="hljs-string">'환영합니다!'</span>)
</code></pre>
<h2>원점</h2>
<p>테스트 더블의 사용 모드를 이해하는 것 외에도, 그 원점과 유형을 알아야 합니다. 테스트 더블은 순수한(pure), 부분적인(partial), 또는 확인(verify)할 수 있는 것으로, 각각 다른 목적을 제공합니다.</p>
<p></p>
<p>순수 더블: 순수 더블은 RSpec과 같은 테스트 프레임워크에 의해 목적에 맞게 생성되며 해당 행동이 완전히 추가된 것으로 구성됩니다. 의존성을 전달할 수 있는 코드를 테스트하기 위해 유연하고 사용하기 쉽습니다.</p>
<pre><code class="hljs language-js"># <span class="hljs-variable constant_">LMS</span> 강좌를 위한 순수 더블
pure_course = <span class="hljs-title function_">double</span>(<span class="hljs-string">'Course'</span>)
<span class="hljs-title function_">allow</span>(pure_course).<span class="hljs-property">to</span> <span class="hljs-title function_">receive</span>(:name).<span class="hljs-title function_">and_return</span>(<span class="hljs-string">'루비 입문'</span>)
</code></pre>
<p>부분 더블: 때로는 테스트 중인 코드가 간단한 의존성 주입을 허용하지 않을 수 있습니다. 이러한 경우 기존 Ruby 객체에 모의(Mocking) 및 스텁(Stubbing) 행동을 추가하는 부분 더블을 사용할 수 있습니다.</p>
<pre><code class="hljs language-js"># 내장된 <span class="hljs-title class_">Ruby</span> <span class="hljs-title class_">Time</span> 클래스의 부분 더블
<span class="hljs-title function_">allow</span>(<span class="hljs-title class_">Time</span>).<span class="hljs-property">to</span> <span class="hljs-title function_">receive</span>(:now).<span class="hljs-title function_">and_return</span>(<span class="hljs-title class_">Time</span>.<span class="hljs-title function_">new</span>(<span class="hljs-number">2023</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>))
</code></pre>
<p></p>
<p>더블 검증: 더블 검증은 테스트 더블과 실제 의존성이 동기화되지 않을 때 문제를 찾는 데 도움이 됩니다. 더블의 인터페이스를 실제 클래스나 객체에 기반하여 제한하여 메서드 변경을 감지합니다.</p>
<pre><code class="hljs language-js"># <span class="hljs-variable constant_">LMS</span> 사용자 클래스의 더블 검증
user = <span class="hljs-title function_">instance_double</span>(<span class="hljs-string">'User'</span>)
<span class="hljs-title function_">allow</span>(user).<span class="hljs-property">to</span> <span class="hljs-title function_">receive</span>(:enroll_in_course)
</code></pre>
<p>오버로드된 상수: 테스트 더블은 루비 상수를 바꾸거나 제거하여 테스트 기간 동안 환경을 제어할 수 있습니다.</p>
<pre><code class="hljs language-js"># 기본 등록 기간을 위한 상수 스텁
<span class="hljs-title function_">stub_const</span>(<span class="hljs-string">'LMS::DEFAULT_ENROLLMENT_PERIOD'</span>, <span class="hljs-number">7</span>)
</code></pre>
<p></p>
<p>테스트 더블은 사용 모드와 원본을 모두 결합할 수 있어요. 예를 들어, 순수한 더블이 스텁으로 작동하거나 검증 더블이 스파이로 작동하는 경우가 있을 수 있어요.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"테스트 더블이란 무엇이며 RSpec 3에서 어떻게 사용하는 지","description":"","date":"2024-06-19 22:21","slug":"2024-06-19-WhatAreTestDoublesandHowToUseTheminRSpec3","content":"\n![Test Doubles](/assets/img/2024-06-19-WhatAreTestDoublesandHowToUseTheminRSpec3_0.png)\n\n# 소프트웨어 개발에서의 테스트 더블 이해\n\n소프트웨어에 대한 테스트를 작성할 때, 종종 실제 객체나 의존성의 동작을 시뮬레이션하기 위해 \"테스트 더블\" 또는 \"모의 객체\"를 만들어야 합니다. 각각 특정 목적을 위해 사용되는 다양한 종류의 테스트 더블이 있습니다.\n\n# 테스트 더블의 종류\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n테스트 더블은 사용 모드와 원본에 따라 분류할 수 있어요.\n\n## 사용 모드\n\nStub: Stub은 사이드 이펙트를 발생시키지 않고 값을 반환하는 쿼리 메소드를 시뮬레이트하는 데 사용돼요. 미리 정의된 캐너드 응답을 반환합니다.\n\n```js\n# LMS 코스 모델을 위한 Stub\nstub_course = double('Course', name: 'Ruby 입문', description: '루비 기초 학습')\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n모의 객체: 모의 객체는 값을 반환하는 것보다 부작용을 수행하는 명령 메서드를 테스트할 때 유용합니다. 특정 메시지가 수신되었는지 확인하고, 예상한 메시지가 수신되지 않으면 오류를 발생시킵니다.\n\n```js\n# LMS 등록 서비스용 모의 객체\nmock_enrollment_service = double('EnrollmentService')\nexpect(mock_enrollment_service).to receive(:enroll).with(user, course)\n```\n\n널 객체: 널 객체는 어떤 메시지에 대해 자신을 반환하는 친화적인 테스트 대역입니다. 여러 협력자가 있는 객체를 테스트할 때 유용합니다.\n\n```js\n# LMS 사용자용 널 객체\nnull_user = double('User').as_null_object\nnull_user.enroll_in_course(course)\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n스파이: 스파이들은 받은 메시지를 기록하여 특정 메시지가 올바른 매개변수로 호출되었음을 확인할 수 있게 해줍니다.\n\n```js\n# LMS 알림 서비스용 스파이\nspy_notification_service = spy('NotificationService')\nspy_notification_service.send_notification(user, '환영합니다!')\nexpect(spy_notification_service).to have_received(:send_notification).with(user, '환영합니다!')\n```\n\n## 원점\n\n테스트 더블의 사용 모드를 이해하는 것 외에도, 그 원점과 유형을 알아야 합니다. 테스트 더블은 순수한(pure), 부분적인(partial), 또는 확인(verify)할 수 있는 것으로, 각각 다른 목적을 제공합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n순수 더블: 순수 더블은 RSpec과 같은 테스트 프레임워크에 의해 목적에 맞게 생성되며 해당 행동이 완전히 추가된 것으로 구성됩니다. 의존성을 전달할 수 있는 코드를 테스트하기 위해 유연하고 사용하기 쉽습니다.\n\n```js\n# LMS 강좌를 위한 순수 더블\npure_course = double('Course')\nallow(pure_course).to receive(:name).and_return('루비 입문')\n```\n\n부분 더블: 때로는 테스트 중인 코드가 간단한 의존성 주입을 허용하지 않을 수 있습니다. 이러한 경우 기존 Ruby 객체에 모의(Mocking) 및 스텁(Stubbing) 행동을 추가하는 부분 더블을 사용할 수 있습니다.\n\n```js\n# 내장된 Ruby Time 클래스의 부분 더블\nallow(Time).to receive(:now).and_return(Time.new(2023, 6, 1))\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n더블 검증: 더블 검증은 테스트 더블과 실제 의존성이 동기화되지 않을 때 문제를 찾는 데 도움이 됩니다. 더블의 인터페이스를 실제 클래스나 객체에 기반하여 제한하여 메서드 변경을 감지합니다.\n\n```js\n# LMS 사용자 클래스의 더블 검증\nuser = instance_double('User')\nallow(user).to receive(:enroll_in_course)\n```\n\n오버로드된 상수: 테스트 더블은 루비 상수를 바꾸거나 제거하여 테스트 기간 동안 환경을 제어할 수 있습니다.\n\n```js\n# 기본 등록 기간을 위한 상수 스텁\nstub_const('LMS::DEFAULT_ENROLLMENT_PERIOD', 7)\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n테스트 더블은 사용 모드와 원본을 모두 결합할 수 있어요. 예를 들어, 순수한 더블이 스텁으로 작동하거나 검증 더블이 스파이로 작동하는 경우가 있을 수 있어요.\n","ogImage":{"url":"/assets/img/2024-06-19-WhatAreTestDoublesandHowToUseTheminRSpec3_0.png"},"coverImage":"/assets/img/2024-06-19-WhatAreTestDoublesandHowToUseTheminRSpec3_0.png","tag":["Tech"],"readingTime":4},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-WhatAreTestDoublesandHowToUseTheminRSpec3_0.png\" alt=\"Test Doubles\"\u003e\u003c/p\u003e\n\u003ch1\u003e소프트웨어 개발에서의 테스트 더블 이해\u003c/h1\u003e\n\u003cp\u003e소프트웨어에 대한 테스트를 작성할 때, 종종 실제 객체나 의존성의 동작을 시뮬레이션하기 위해 \"테스트 더블\" 또는 \"모의 객체\"를 만들어야 합니다. 각각 특정 목적을 위해 사용되는 다양한 종류의 테스트 더블이 있습니다.\u003c/p\u003e\n\u003ch1\u003e테스트 더블의 종류\u003c/h1\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e테스트 더블은 사용 모드와 원본에 따라 분류할 수 있어요.\u003c/p\u003e\n\u003ch2\u003e사용 모드\u003c/h2\u003e\n\u003cp\u003eStub: Stub은 사이드 이펙트를 발생시키지 않고 값을 반환하는 쿼리 메소드를 시뮬레이트하는 데 사용돼요. 미리 정의된 캐너드 응답을 반환합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# \u003cspan class=\"hljs-variable constant_\"\u003eLMS\u003c/span\u003e 코스 모델을 위한 \u003cspan class=\"hljs-title class_\"\u003eStub\u003c/span\u003e\nstub_course = \u003cspan class=\"hljs-title function_\"\u003edouble\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Course'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'Ruby 입문'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003edescription\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'루비 기초 학습'\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e모의 객체: 모의 객체는 값을 반환하는 것보다 부작용을 수행하는 명령 메서드를 테스트할 때 유용합니다. 특정 메시지가 수신되었는지 확인하고, 예상한 메시지가 수신되지 않으면 오류를 발생시킵니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# \u003cspan class=\"hljs-variable constant_\"\u003eLMS\u003c/span\u003e 등록 서비스용 모의 객체\nmock_enrollment_service = \u003cspan class=\"hljs-title function_\"\u003edouble\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'EnrollmentService'\u003c/span\u003e)\n\u003cspan class=\"hljs-title function_\"\u003eexpect\u003c/span\u003e(mock_enrollment_service).\u003cspan class=\"hljs-property\"\u003eto\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ereceive\u003c/span\u003e(:enroll).\u003cspan class=\"hljs-title function_\"\u003ewith\u003c/span\u003e(user, course)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e널 객체: 널 객체는 어떤 메시지에 대해 자신을 반환하는 친화적인 테스트 대역입니다. 여러 협력자가 있는 객체를 테스트할 때 유용합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# \u003cspan class=\"hljs-variable constant_\"\u003eLMS\u003c/span\u003e 사용자용 널 객체\nnull_user = \u003cspan class=\"hljs-title function_\"\u003edouble\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'User'\u003c/span\u003e).\u003cspan class=\"hljs-property\"\u003eas_null_object\u003c/span\u003e\nnull_user.\u003cspan class=\"hljs-title function_\"\u003eenroll_in_course\u003c/span\u003e(course)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e스파이: 스파이들은 받은 메시지를 기록하여 특정 메시지가 올바른 매개변수로 호출되었음을 확인할 수 있게 해줍니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# \u003cspan class=\"hljs-variable constant_\"\u003eLMS\u003c/span\u003e 알림 서비스용 스파이\nspy_notification_service = \u003cspan class=\"hljs-title function_\"\u003espy\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'NotificationService'\u003c/span\u003e)\nspy_notification_service.\u003cspan class=\"hljs-title function_\"\u003esend_notification\u003c/span\u003e(user, \u003cspan class=\"hljs-string\"\u003e'환영합니다!'\u003c/span\u003e)\n\u003cspan class=\"hljs-title function_\"\u003eexpect\u003c/span\u003e(spy_notification_service).\u003cspan class=\"hljs-property\"\u003eto\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ehave_received\u003c/span\u003e(:send_notification).\u003cspan class=\"hljs-title function_\"\u003ewith\u003c/span\u003e(user, \u003cspan class=\"hljs-string\"\u003e'환영합니다!'\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e원점\u003c/h2\u003e\n\u003cp\u003e테스트 더블의 사용 모드를 이해하는 것 외에도, 그 원점과 유형을 알아야 합니다. 테스트 더블은 순수한(pure), 부분적인(partial), 또는 확인(verify)할 수 있는 것으로, 각각 다른 목적을 제공합니다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e순수 더블: 순수 더블은 RSpec과 같은 테스트 프레임워크에 의해 목적에 맞게 생성되며 해당 행동이 완전히 추가된 것으로 구성됩니다. 의존성을 전달할 수 있는 코드를 테스트하기 위해 유연하고 사용하기 쉽습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# \u003cspan class=\"hljs-variable constant_\"\u003eLMS\u003c/span\u003e 강좌를 위한 순수 더블\npure_course = \u003cspan class=\"hljs-title function_\"\u003edouble\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Course'\u003c/span\u003e)\n\u003cspan class=\"hljs-title function_\"\u003eallow\u003c/span\u003e(pure_course).\u003cspan class=\"hljs-property\"\u003eto\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ereceive\u003c/span\u003e(:name).\u003cspan class=\"hljs-title function_\"\u003eand_return\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'루비 입문'\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e부분 더블: 때로는 테스트 중인 코드가 간단한 의존성 주입을 허용하지 않을 수 있습니다. 이러한 경우 기존 Ruby 객체에 모의(Mocking) 및 스텁(Stubbing) 행동을 추가하는 부분 더블을 사용할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 내장된 \u003cspan class=\"hljs-title class_\"\u003eRuby\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTime\u003c/span\u003e 클래스의 부분 더블\n\u003cspan class=\"hljs-title function_\"\u003eallow\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eTime\u003c/span\u003e).\u003cspan class=\"hljs-property\"\u003eto\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ereceive\u003c/span\u003e(:now).\u003cspan class=\"hljs-title function_\"\u003eand_return\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eTime\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003enew\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e2023\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e더블 검증: 더블 검증은 테스트 더블과 실제 의존성이 동기화되지 않을 때 문제를 찾는 데 도움이 됩니다. 더블의 인터페이스를 실제 클래스나 객체에 기반하여 제한하여 메서드 변경을 감지합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# \u003cspan class=\"hljs-variable constant_\"\u003eLMS\u003c/span\u003e 사용자 클래스의 더블 검증\nuser = \u003cspan class=\"hljs-title function_\"\u003einstance_double\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'User'\u003c/span\u003e)\n\u003cspan class=\"hljs-title function_\"\u003eallow\u003c/span\u003e(user).\u003cspan class=\"hljs-property\"\u003eto\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ereceive\u003c/span\u003e(:enroll_in_course)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e오버로드된 상수: 테스트 더블은 루비 상수를 바꾸거나 제거하여 테스트 기간 동안 환경을 제어할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 기본 등록 기간을 위한 상수 스텁\n\u003cspan class=\"hljs-title function_\"\u003estub_const\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'LMS::DEFAULT_ENROLLMENT_PERIOD'\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e테스트 더블은 사용 모드와 원본을 모두 결합할 수 있어요. 예를 들어, 순수한 더블이 스텁으로 작동하거나 검증 더블이 스파이로 작동하는 경우가 있을 수 있어요.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-19-WhatAreTestDoublesandHowToUseTheminRSpec3"},"buildId":"bb_yO9GbCvdfc_n71SfUf","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>