<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>SwiftUI TextField 심화  이벤트, 포커스, 키보드 제어 방법 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-06-23-AdvancedSwiftUITextFieldEventsFocusKeyboard" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="SwiftUI TextField 심화  이벤트, 포커스, 키보드 제어 방법 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="SwiftUI TextField 심화  이벤트, 포커스, 키보드 제어 방법 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-23-AdvancedSwiftUITextFieldEventsFocusKeyboard_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-06-23-AdvancedSwiftUITextFieldEventsFocusKeyboard" data-gatsby-head="true"/><meta name="twitter:title" content="SwiftUI TextField 심화  이벤트, 포커스, 키보드 제어 방법 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-23-AdvancedSwiftUITextFieldEventsFocusKeyboard_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-23 21:35" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-4f7b40c1114f0d09.js" defer=""></script><script src="/_next/static/bb_yO9GbCvdfc_n71SfUf/_buildManifest.js" defer=""></script><script src="/_next/static/bb_yO9GbCvdfc_n71SfUf/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">SwiftUI TextField 심화  이벤트, 포커스, 키보드 제어 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="SwiftUI TextField 심화  이벤트, 포커스, 키보드 제어 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 23, 2024</span><span class="posts_reading_time__f7YPP">36<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-23-AdvancedSwiftUITextFieldEventsFocusKeyboard&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>이 글은 SwiftUI TextField 이벤트, 포커스 전환, 키보드 설정 및 기타 관련 경험, 기술 및 고려 사항을 탐색할 것입니다.</p>
<h2>이벤트</h2>
<h3>onEditingChanged</h3>
<p>TextField가 포커스를 얻을 때(편집 가능한 상태로 전환될 때), onEditingChanged는 주어진 메서드를 호출하고 값으로 true를 전달합니다. TextField가 포커스를 잃을 때, 다시 메서드를 호출하고 값을 false로 전달합니다.</p>
<p></p>
<pre><code class="hljs language-swift"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">OnEditingChangedDemo</span>: <span class="hljs-title class_">View</span> {
    <span class="hljs-meta">@State</span> <span class="hljs-keyword">var</span> name <span class="hljs-operator">=</span> <span class="hljs-string">""</span>

    <span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> {
        <span class="hljs-type">List</span> {
            <span class="hljs-type">TextField</span>(<span class="hljs-string">"이름:"</span>, text: <span class="hljs-variable">$name</span>, onEditingChanged: getFocus)
        }
    }

    <span class="hljs-keyword">func</span> <span class="hljs-title function_">getFocus</span>(<span class="hljs-params">focused</span>: <span class="hljs-type">Bool</span>) {
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"포커스 받음: <span class="hljs-subst">\(focused <span class="hljs-operator">?</span> <span class="hljs-string">"참"</span> : <span class="hljs-string">"거짓"</span>)</span>"</span>)
    }
}
</code></pre>
<p>이 매개변수의 이름은 사용자에게 모호함을 초래하기 쉽습니다. 사용자가 콘텐츠를 입력했는지 확인하는 데 onEditingChanged를 사용하지 마십시오.</p>
<p>iOS 15에서는 ParseableFormatStyle을 지원하는 새로 추가된 생성자에서 이 매개변수를 제공하지 않습니다. 따라서 새로운 Formatter를 사용하는 TextFields의 경우, 포커스를 얻었는지 또는 상실했는지를 확인하기 위해 다른 수단을 사용해야 합니다.</p>
<h1>onCommit</h1>
<p></p>
<p>onCommit은 사용자가 입력하는 중에 리턴 키를 누를 때 (또는 클릭할 때) 트리거됩니다 (코드 시뮬레이션으로는 트리거할 수 없음). 사용자가 리턴 키를 클릭하지 않으면(예: 직접 다른 TextField로 전환하는 경우) onCommit은 트리거되지 않습니다. onCommit이 트리거되는 동시에 TextField는 포커스를 잃게 됩니다.</p>
<pre><code class="hljs language-js">struct <span class="hljs-title class_">OnCommitDemo</span>: <span class="hljs-title class_">View</span> {
    @<span class="hljs-title class_">State</span> <span class="hljs-keyword">var</span> name = <span class="hljs-string">""</span>
    <span class="hljs-keyword">var</span> <span class="hljs-attr">body</span>: some <span class="hljs-title class_">View</span> {
        <span class="hljs-title class_">List</span> {
            <span class="hljs-title class_">TextField</span>(<span class="hljs-string">"이름:"</span>, <span class="hljs-attr">text</span>: $name, <span class="hljs-attr">onCommit</span>: { <span class="hljs-title function_">print</span>(<span class="hljs-string">"커밋"</span>) })
        }
    }
}
</code></pre>
<p>사용자가 입력한 내용을 확인해야 하는 경우, onCommit과 onEditingChanged를 함께 사용하는 것이 좋습니다. 사용자의 입력 데이터를 실시간으로 처리하려면 SwiftUI TextField 고급 — 형식 지정 및 유효성 검사를 참고해주세요.</p>
<p>onCommit은 SecureField에도 적용됩니다.</p>
<p></p>
<p>iOS 15에서 추가된 ParseableFormatStyle을 지원하는 새 생성자는 해당 매개변수를 제공하지 않습니다. 동일한 효과를 얻으려면 새롭게 추가된 onSubmit을 사용할 수 있습니다.</p>
<h1>onSubmit</h1>
<p>onSubmit은 SwiftUI 3.0에서 새로 추가된 기능입니다. onCommit 및 onEditingChanged는 각각의 TextField의 상태를 설명하지만 onSubmit은 한 뷰 내에서 여러 TextField의 통합 관리 및 일정 관리를 가능하게 합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// onSubmit의 정의</span>
extension <span class="hljs-title class_">View</span> {
    public func <span class="hljs-title function_">onSubmit</span>(<span class="hljs-keyword">of</span> <span class="hljs-attr">triggers</span>: <span class="hljs-title class_">SubmitTriggers</span> = .<span class="hljs-property">text</span>, _ <span class="hljs-attr">action</span>: @escaping (() -> <span class="hljs-title class_">Void</span>)) -> some <span class="hljs-title class_">View</span>
}
</code></pre>
<p></p>
<p>아래 코드는 onCommit과 동일한 동작을 구현할 것입니다:</p>
<pre><code class="hljs language-js">struct <span class="hljs-title class_">OnSubmitDemo</span>:<span class="hljs-title class_">View</span>{
    @<span class="hljs-title class_">State</span> <span class="hljs-keyword">var</span> name = <span class="hljs-string">""</span>
    <span class="hljs-keyword">var</span> <span class="hljs-attr">body</span>: some <span class="hljs-title class_">View</span>{
        <span class="hljs-title class_">List</span>{
            <span class="hljs-title class_">TextField</span>(<span class="hljs-string">"name:"</span>,<span class="hljs-attr">text</span>: $name)
                .<span class="hljs-property">onSubmit</span> {
                    <span class="hljs-title function_">print</span>(<span class="hljs-string">"commit"</span>)
                }
        }
    }
}
</code></pre>
<p>onSubmit의 트리거 조건은 onCommit과 동일하며, 사용자가 “return”을 활성화하도록 요구합니다.</p>
<p>onSubmit은 SecureField에도 적용됩니다.</p>
<p></p>
<h1>범위와 중첩</h1>
<p>onSubmit의 구현은 환경 값 TriggerSubmitAction을 설정하는 것에 기반하며 (아직 개발자에게 제공되지 않음) onSubmit은 범위를 가지고 있으며 (뷰 트리로 전달될 수 있음) 중첩될 수 있습니다.</p>
<pre><code class="hljs language-js">struct <span class="hljs-title class_">OnSubmitDemo</span>: <span class="hljs-title class_">View</span> {
    @<span class="hljs-title class_">State</span> <span class="hljs-keyword">var</span> text1 = <span class="hljs-string">""</span>
    @<span class="hljs-title class_">State</span> <span class="hljs-keyword">var</span> text2 = <span class="hljs-string">""</span>
    @<span class="hljs-title class_">State</span> <span class="hljs-keyword">var</span> text3 = <span class="hljs-string">""</span>
    <span class="hljs-keyword">var</span> <span class="hljs-attr">body</span>: some <span class="hljs-title class_">View</span> {
        <span class="hljs-title class_">Form</span> {
            <span class="hljs-title class_">Group</span> {
                <span class="hljs-title class_">TextField</span>(<span class="hljs-string">"text1"</span>, <span class="hljs-attr">text</span>: $text1)
                    .<span class="hljs-property">onSubmit</span> { <span class="hljs-title function_">print</span>(<span class="hljs-string">"text1 commit"</span>) }
                <span class="hljs-title class_">TextField</span>(<span class="hljs-string">"text2"</span>, <span class="hljs-attr">text</span>: $text2)
                    .<span class="hljs-property">onSubmit</span> { <span class="hljs-title function_">print</span>(<span class="hljs-string">"text2 commit"</span>) }
            }
            .<span class="hljs-property">onSubmit</span> { <span class="hljs-title function_">print</span>(<span class="hljs-string">"textfield in group commit"</span>) }
            <span class="hljs-title class_">TextField</span>(<span class="hljs-string">"text3"</span>, <span class="hljs-attr">text</span>: $text3)
                .<span class="hljs-property">onSubmit</span> { <span class="hljs-title function_">print</span>(<span class="hljs-string">"text3 commit"</span>) }
        }
        .<span class="hljs-property">onSubmit</span> { <span class="hljs-title function_">print</span>(<span class="hljs-string">"textfield in form commit1"</span>) }
        .<span class="hljs-property">onSubmit</span> { <span class="hljs-title function_">print</span>(<span class="hljs-string">"textfield in form commit2"</span>) }
    }
}
</code></pre>
<p>TextField (text1)이 commit되면, 콘솔 출력은 다음과 같습니다:</p>
<p></p>
<pre><code class="hljs language-js">양식에서의 텍스트 필드 커밋<span class="hljs-number">2</span>
양식에서의 텍스트 필드 커밋<span class="hljs-number">1</span>
그룹에서의 텍스트 필드 커밋
텍스트<span class="hljs-number">1</span> 커밋
</code></pre>
<p>외부에서 내부로 호출 순서임을 참고하십시오.</p>
<h1>제한된 범위</h1>
<p>submitScope를 사용하여 범위를 차단하고 (뷰 트리 상에서의 추가 전파를 제한합니다). 예를 들어, 위 코드에서는 그룹 뒤에 submitScope를 추가하십시오.</p>
<p></p>
<pre><code class="hljs language-js">그룹 {
    <span class="hljs-title class_">TextField</span>(<span class="hljs-string">"text1"</span>, <span class="hljs-attr">text</span>: $text1)
        .<span class="hljs-property">onSubmit</span> { <span class="hljs-title function_">print</span>(<span class="hljs-string">"text1 commit"</span>) }
    <span class="hljs-title class_">TextField</span>(<span class="hljs-string">"text2"</span>, <span class="hljs-attr">text</span>: $text2)
        .<span class="hljs-property">onSubmit</span> { <span class="hljs-title function_">print</span>(<span class="hljs-string">"text2 commit"</span>) }
}
.<span class="hljs-title function_">submitScope</span>()  <span class="hljs-comment">// scope blocking</span>
.<span class="hljs-property">onSubmit</span> { <span class="hljs-title function_">print</span>(<span class="hljs-string">"textfield in group commit"</span>) }
</code></pre>
<p>TextField1이 커밋되면 콘솔에 다음이 표시됩니다:</p>
<pre><code class="hljs language-js">text1 commit
</code></pre>
<p>이 시점에서 onSubmit의 범위는 그룹 내로 제한됩니다.</p>
<p></p>
<p>뷰에 여러 개의 TextFields가 있는 경우, onSubmit과 FocusState를 결합하여 훌륭한 사용자 경험을 얻을 수 있습니다.</p>
<h1>searchable 지원</h1>
<p>iOS 15에서는 새로운 검색 상자도 "return"을 클릭할 때 onSubmit을 트리거하지만, 트리거를 검색으로 설정해야 합니다:</p>
<pre><code class="hljs language-js">struct <span class="hljs-title class_">OnSubmitForSearchableDemo</span>:<span class="hljs-title class_">View</span>{
    @<span class="hljs-title class_">State</span> <span class="hljs-keyword">var</span> name = <span class="hljs-string">""</span>
    @<span class="hljs-title class_">State</span> <span class="hljs-keyword">var</span> searchText = <span class="hljs-string">""</span>
    <span class="hljs-keyword">var</span> <span class="hljs-attr">body</span>: some <span class="hljs-title class_">View</span>{
        <span class="hljs-title class_">NavigationView</span>{
            <span class="hljs-title class_">Form</span>{
                <span class="hljs-title class_">TextField</span>(<span class="hljs-string">"이름:"</span>,<span class="hljs-attr">text</span>:$name)
                    .<span class="hljs-property">onSubmit</span> {<span class="hljs-title function_">print</span>(<span class="hljs-string">"textField 커밋"</span>)}
            }
            .<span class="hljs-title function_">searchable</span>(<span class="hljs-attr">text</span>: $searchText)
            .<span class="hljs-title function_">onSubmit</span>(<span class="hljs-params"><span class="hljs-keyword">of</span>: .search</span>) { <span class="hljs-comment">//</span>
                <span class="hljs-title function_">print</span>(<span class="hljs-string">"searchField 커밋"</span>)
            }
        }
    }
}
</code></pre>
<p></p>
<p>SubmitTriggers의 타입은 OptionSet입니다. onSubmit 메서드는 환경 내에서 뷰 트리에서 SubmitTriggers에 포함된 값을 계속 전달합니다. onSubmit에서 받는 SubmitTriggers 값이 onSubmit에서 지정된 SubmitTriggers 세트에 포함되지 않으면 전달이 종료됩니다. 간단히 말해, onSubmit(of:.search)은 TextField에서 생성된 커밋 상태를 차단하고 그 반대도 마찬가지입니다.</p>
<p>예를 들어, 위 코드에서 searchable 다음에 onSubmt(of:.text)를 추가하면 TextField의 커밋 이벤트에 응답할 수 없게 됩니다.</p>
<pre><code class="hljs language-js">.<span class="hljs-title function_">searchable</span>(<span class="hljs-attr">text</span>: $searchText)
            .<span class="hljs-title function_">onSubmit</span>(<span class="hljs-params"><span class="hljs-keyword">of</span>: .search</span>) {
                <span class="hljs-title function_">print</span>(<span class="hljs-string">"searchField commit1"</span>)
            }
            .<span class="hljs-property">onSubmit</span> {<span class="hljs-title function_">print</span>(<span class="hljs-string">"textField commit"</span>)} <span class="hljs-comment">//cannot be triggered, blocked by search</span>
</code></pre>
<p>따라서 TextField와 검색 상자를 모두 처리할 때 호출 순서에 특별히 주의해야 합니다.</p>
<p></p>
<p>다음 코드는 하나의 onSubmit에서 TextField와 검색 상자를 모두 지원할 수 있습니다:</p>
<pre><code class="hljs language-js">.<span class="hljs-title function_">onSubmit</span>(<span class="hljs-params"><span class="hljs-keyword">of</span>: [.text, .search]</span>) {
  <span class="hljs-title function_">print</span>(<span class="hljs-string">"무언가가 제출되었습니다"</span>)
}
</code></pre>
<p>다음 코드는 searchable 보다 onSubmit(of:.search)가 먼저 배치되어 있기 때문에 어느 것도 트리거하지 않습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">NavigationView</span>{
    <span class="hljs-title class_">Form</span>{
        <span class="hljs-title class_">TextField</span>(<span class="hljs-string">"이름:"</span>, <span class="hljs-attr">text</span>: $name)
            .<span class="hljs-property">onSubmit</span> {<span class="hljs-title function_">print</span>(<span class="hljs-string">"textField 제출"</span>)}
    }
    .<span class="hljs-title function_">onSubmit</span>(<span class="hljs-params"><span class="hljs-keyword">of</span>: .search</span>) { <span class="hljs-comment">// 트리거 안 됨</span>
        <span class="hljs-title function_">print</span>(<span class="hljs-string">"searchField 제출1"</span>)
    }
    .<span class="hljs-title function_">searchable</span>(<span class="hljs-attr">text</span>: $searchText)
}
</code></pre>
<p></p>
<h1>초점</h1>
<p>iOS 15(몬테레이) 이전에는 SwiftUI에서 TextField(예 : becomeFirstResponder)에 초점을 맞추는 방법을 제공하지 않았습니다. 오랫동안 개발자들은 비슈위 방법에 의존하여 비슷한 기능을 구현해야 했습니다.</p>
<p>SwiftUI 3.0에서 Apple은 개발자들에게 onSubmit과 유사한, 높은 수준의 뷰 계층 구조에서 텍스트 필드의 초점을 일관되게 결정하고 관리할 수 있는 예상보다 훨씬 더 나은 솔루션을 제공했습니다.</p>
<h1>기본 사용법</h1>
<p></p>
<p>SwiftUI에서는 새 FocusState 프로퍼티 래퍼를 제공하여이 뷰 내의 TextField에 포커스가 있는지 여부를 결정하는 데 도움을 줍니다. focused를 사용하여 FocusState를 특정 TextField와 연결할 수 있습니다.</p>
<pre><code class="hljs language-swift"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">OnFocusDemo</span>: <span class="hljs-title class_">View</span> {
    <span class="hljs-meta">@FocusState</span> <span class="hljs-keyword">var</span> isNameFocused: <span class="hljs-type">Bool</span>
    <span class="hljs-meta">@State</span> <span class="hljs-keyword">var</span> name <span class="hljs-operator">=</span> <span class="hljs-string">""</span>

    <span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> {
        <span class="hljs-type">List</span> {
            <span class="hljs-type">TextField</span>(<span class="hljs-string">"이름:"</span>, text: <span class="hljs-variable">$name</span>)
                .focused(<span class="hljs-variable">$isNameFocused</span>)
        }
        .onChange(of: isNameFocused) { value <span class="hljs-keyword">in</span>
            <span class="hljs-built_in">print</span>(value)
        }
    }
}
</code></pre>
<p>위 코드는 TextField가 포커스를 얻을 때 isNameFocused를 true로 설정하고 포커스를 잃을 때 false로 설정합니다.</p>
<p>동일한 뷰 내에 여러 개의 TextField가있는 경우 각 해당 TextField와 연결할 여러 FocusStates를 생성할 수 있습니다. 예를 들어:</p>
<p></p>
<p>위의 방법은 뷰에 더 많은 TextField가 있는 경우 귀찮아지고 통일된 관리에 도움이 되지 않습니다. 다행히 FocusState는 Boolean 값뿐만 아니라 모든 해시 타입도 지원합니다. Hashable 프로토콜을 준수하는 enum을 사용하여 뷰 내 여러 TextField의 포커스를 관리할 수 있습니다. 다음 코드는 위의 코드와 동일한 기능을 수행합니다:</p>
<pre><code class="hljs language-js">struct <span class="hljs-title class_">OnFocusDemo</span>:<span class="hljs-title class_">View</span>{
    @<span class="hljs-title class_">FocusState</span> <span class="hljs-keyword">var</span> <span class="hljs-attr">focus</span>:<span class="hljs-title class_">FocusedField</span>?
    @<span class="hljs-title class_">State</span> <span class="hljs-keyword">var</span> name = <span class="hljs-string">""</span>
    @<span class="hljs-title class_">State</span> <span class="hljs-keyword">var</span> password = <span class="hljs-string">""</span>
    <span class="hljs-keyword">var</span> <span class="hljs-attr">body</span>: some <span class="hljs-title class_">View</span>{
        <span class="hljs-title class_">List</span>{
            <span class="hljs-title class_">TextField</span>(<span class="hljs-string">"name:"</span>,<span class="hljs-attr">text</span>:$name)
                .<span class="hljs-title function_">focused</span>($focus, <span class="hljs-attr">equals</span>: .<span class="hljs-property">name</span>)
            <span class="hljs-title class_">SecureField</span>(<span class="hljs-string">"password:"</span>,<span class="hljs-attr">text</span>:$password)
                .<span class="hljs-title function_">focused</span>($focus,<span class="hljs-attr">equals</span>: .<span class="hljs-property">password</span>)
        }
        .<span class="hljs-title function_">onChange</span>(<span class="hljs-attr">of</span>: focus, <span class="hljs-attr">perform</span>: {<span class="hljs-title function_">print</span>($0)})
    }

    enum <span class="hljs-title class_">FocusedField</span>:<span class="hljs-title class_">Hashable</span>{
        <span class="hljs-keyword">case</span> name,password
    }
}
</code></pre>
<h1>특정 TextField가 뷰를 표시한 직후에 즉시 포커스를 받도록 만들기</h1>
<p></p>
<p>FocusState를 사용하면 지정된 TextField가 포커스를 얻고 뷰를 표시한 후 즉시 키보드가 팝업되게 할 수 있어요:</p>
<pre><code class="hljs language-js">struct <span class="hljs-title class_">OnFocusDemo</span>: <span class="hljs-title class_">View</span> {
    @<span class="hljs-title class_">FocusState</span> <span class="hljs-keyword">var</span> <span class="hljs-attr">focus</span>: <span class="hljs-title class_">FocusedField</span>?
    @<span class="hljs-title class_">State</span> <span class="hljs-keyword">var</span> name = <span class="hljs-string">""</span>
    @<span class="hljs-title class_">State</span> <span class="hljs-keyword">var</span> password = <span class="hljs-string">""</span>

    <span class="hljs-keyword">var</span> <span class="hljs-attr">body</span>: some <span class="hljs-title class_">View</span> {
        <span class="hljs-title class_">List</span> {
            <span class="hljs-title class_">TextField</span>(<span class="hljs-string">"이름:"</span>, <span class="hljs-attr">text</span>: $name)
                .<span class="hljs-title function_">focused</span>($focus, <span class="hljs-attr">equals</span>: .<span class="hljs-property">name</span>)
            <span class="hljs-title class_">SecureField</span>(<span class="hljs-string">"비밀번호:"</span>, <span class="hljs-attr">text</span>: $password)
                .<span class="hljs-title function_">focused</span>($focus, <span class="hljs-attr">equals</span>: .<span class="hljs-property">password</span>)
        }
        .<span class="hljs-property">onAppear</span> {
            <span class="hljs-title class_">DispatchQueue</span>.<span class="hljs-property">main</span>.<span class="hljs-title function_">asyncAfter</span>(<span class="hljs-params">deadline: .now() + <span class="hljs-number">0.5</span></span>) {
                focus = .<span class="hljs-property">name</span>
            }
        }
    }

    enum <span class="hljs-title class_">FocusedField</span>: <span class="hljs-title class_">Hashable</span> {
        <span class="hljs-keyword">case</span> name, password
    }
}
</code></pre>
<p>뷰 초기화 중에 값을 할당하는 것은 잘못된 방법이에요. onAppear에서도 TextField가 포커스를 얻을 시간을 지연시켜야 해요 (iOS 16에서는 지연이 필요하지 않아요).</p>
<h1>여러 개의 TextField 사이에서 포커스 전환하기</h1>
<p></p>
<p>주의력과 onSubmit을 결합하여 한 TextField에서 입력을 완료하고(리턴을 클릭할 때) 자동으로 다음 TextField로 포커스를 전환하는 효과를 얻을 수 있어요.</p>
<pre><code class="hljs language-js">struct <span class="hljs-title class_">OnFocusDemo</span>:<span class="hljs-title class_">View</span>{
    @<span class="hljs-title class_">FocusState</span> <span class="hljs-keyword">var</span> <span class="hljs-attr">focus</span>:<span class="hljs-title class_">FocusedField</span>?
    @<span class="hljs-title class_">State</span> <span class="hljs-keyword">var</span> name = <span class="hljs-string">""</span>
    @<span class="hljs-title class_">State</span> <span class="hljs-keyword">var</span> email = <span class="hljs-string">""</span>
    @<span class="hljs-title class_">State</span> <span class="hljs-keyword">var</span> phoneNumber = <span class="hljs-string">""</span>
    <span class="hljs-keyword">var</span> <span class="hljs-attr">body</span>: some <span class="hljs-title class_">View</span>{
        <span class="hljs-title class_">List</span>{
            <span class="hljs-title class_">TextField</span>(<span class="hljs-string">"이름:"</span>,<span class="hljs-attr">text</span>:$name)
                .<span class="hljs-title function_">focused</span>($focus, <span class="hljs-attr">equals</span>: .<span class="hljs-property">name</span>)
                .<span class="hljs-property">onSubmit</span> {
                    focus = .<span class="hljs-property">email</span>
                }
            <span class="hljs-title class_">TextField</span>(<span class="hljs-string">"이메일:"</span>,<span class="hljs-attr">text</span>:$email)
                .<span class="hljs-title function_">focused</span>($focus,<span class="hljs-attr">equals</span>: .<span class="hljs-property">email</span>)
                .<span class="hljs-property">onSubmit</span> {
                    focus = .<span class="hljs-property">phone</span>
                }
            <span class="hljs-title class_">TextField</span>(<span class="hljs-string">"전화번호:"</span>,<span class="hljs-attr">text</span>:$phoneNumber)
                .<span class="hljs-title function_">focused</span>($focus, <span class="hljs-attr">equals</span>: .<span class="hljs-property">phone</span>)
                .<span class="hljs-property">onSubmit</span> {
                    <span class="hljs-keyword">if</span> !name.<span class="hljs-property">isEmpty</span> &#x26;&#x26; !email.<span class="hljs-property">isEmpty</span> &#x26;&#x26; !phoneNumber.<span class="hljs-property">isEmpty</span> {
                        <span class="hljs-title function_">submit</span>()
                    }
                }
        }
    }

    private func <span class="hljs-title function_">submit</span>(<span class="hljs-params"></span>){
        <span class="hljs-comment">// 모든 정보 제출</span>
        <span class="hljs-title function_">print</span>(<span class="hljs-string">"제출"</span>)
    }
    enum <span class="hljs-title class_">FocusedField</span>:<span class="hljs-title class_">Hashable</span>{
        <span class="hljs-keyword">case</span> name,email,phone
    }
}
</code></pre>
<p>위의 코드는 onSubmit 전달 기능을 활용하여 다음과 같이 변환될 수도 있어요:</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">List</span> {
    <span class="hljs-title class_">TextField</span>(<span class="hljs-string">"이름:"</span>, <span class="hljs-attr">text</span>: $name)
        .<span class="hljs-title function_">focused</span>($focus, <span class="hljs-attr">equals</span>: .<span class="hljs-property">name</span>)
    <span class="hljs-title class_">TextField</span>(<span class="hljs-string">"이메일:"</span>, <span class="hljs-attr">text</span>: $email)
        .<span class="hljs-title function_">focused</span>($focus, <span class="hljs-attr">equals</span>: .<span class="hljs-property">email</span>)
    <span class="hljs-title class_">TextField</span>(<span class="hljs-string">"전화번호:"</span>, <span class="hljs-attr">text</span>: $phoneNumber)
        .<span class="hljs-title function_">focused</span>($focus, <span class="hljs-attr">equals</span>: .<span class="hljs-property">phone</span>)
}
.<span class="hljs-property">onSubmit</span> {
    <span class="hljs-keyword">switch</span> focus {
    <span class="hljs-keyword">case</span> .<span class="hljs-property">name</span>:
        focus = .<span class="hljs-property">email</span>
    <span class="hljs-keyword">case</span> .<span class="hljs-property">email</span>:
        focus = .<span class="hljs-property">phone</span>
    <span class="hljs-keyword">case</span> .<span class="hljs-property">phone</span>:
        <span class="hljs-keyword">if</span> !name.<span class="hljs-property">isEmpty</span>, !email.<span class="hljs-property">isEmpty</span>, !phoneNumber.<span class="hljs-property">isEmpty</span> {
            <span class="hljs-title function_">submit</span>()
        }
    <span class="hljs-attr">default</span>:
        <span class="hljs-keyword">break</span>
    }
}
</code></pre>
<p></p>
<p>화면 버튼(예: 보조 키보드 보기) 또는 키보드 단축키를 결합하여 포커스를 전환하거나 특정 TextField로 이동할 수도 있습니다.</p>
<h1>포커스를 얻기 위한 키보드 단축키 사용</h1>
<p>보안 필드를 포함한 여러 개의 TextField가 있는 뷰에서는 Tab 키를 사용하여 TextField에서 포커스를 직접 전환할 수 있습니다. 그러나 SwiftUI는 키보드 단축키를 사용하여 특정 TextField에 포커스를 설정하는 기능을 직접 제공하지 않습니다. FocusState와 keyboardShortcut을 결합하여 iPad 및 MacOS에서 이 기능을 얻을 수 있습니다.</p>
<p>키보드 단축키 바인딩을 지원하는 focused를 생성하세요:</p>
<p></p>
<pre><code class="hljs language-swift"><span class="hljs-keyword">public</span> <span class="hljs-keyword">extension</span> <span class="hljs-title class_">View</span> {
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">focused</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">condition</span>: <span class="hljs-type">FocusState</span>&#x3C;<span class="hljs-type">Bool</span>>.<span class="hljs-type">Binding</span>, <span class="hljs-params">key</span>: <span class="hljs-type">KeyEquivalent</span>, <span class="hljs-params">modifiers</span>: <span class="hljs-type">EventModifiers</span> <span class="hljs-operator">=</span> .command) -> <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> {
        focused(condition)
            .background(<span class="hljs-type">Button</span>(<span class="hljs-string">""</span>) {
                condition.wrappedValue <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>
            }
            .keyboardShortcut(key, modifiers: modifiers)
            .hidden()
            )
    }

    <span class="hljs-keyword">func</span> <span class="hljs-title function_">focused</span>&#x3C;<span class="hljs-type">Value</span>>(<span class="hljs-keyword">_</span> <span class="hljs-params">binding</span>: <span class="hljs-type">FocusState</span>&#x3C;<span class="hljs-type">Value</span>>.<span class="hljs-type">Binding</span>, <span class="hljs-params">equals</span> <span class="hljs-params">value</span>: <span class="hljs-type">Value</span>, <span class="hljs-params">key</span>: <span class="hljs-type">KeyEquivalent</span>, <span class="hljs-params">modifiers</span>: <span class="hljs-type">EventModifiers</span> <span class="hljs-operator">=</span> .command) -> <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> <span class="hljs-keyword">where</span> <span class="hljs-type">Value</span>: <span class="hljs-type">Hashable</span> {
        focused(binding, equals: value)
            .background(<span class="hljs-type">Button</span>(<span class="hljs-string">""</span>) {
                binding.wrappedValue <span class="hljs-operator">=</span> value
            }
            .keyboardShortcut(key, modifiers: modifiers)
            .hidden()
            )
    }
}
</code></pre>
<p>코드 사용법:</p>
<pre><code class="hljs language-swift"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ShortcutFocusDemo</span>: <span class="hljs-title class_">View</span> {
    <span class="hljs-meta">@FocusState</span> <span class="hljs-keyword">var</span> focus: <span class="hljs-type">FouceField</span>?
    <span class="hljs-meta">@State</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> email <span class="hljs-operator">=</span> <span class="hljs-string">""</span>
    <span class="hljs-meta">@State</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> address <span class="hljs-operator">=</span> <span class="hljs-string">""</span>
    <span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> {
        <span class="hljs-type">Form</span> {
            <span class="hljs-type">TextField</span>(<span class="hljs-string">"이메일"</span>, text: <span class="hljs-variable">$email</span>)
                .focused(<span class="hljs-variable">$focus</span>, equals: .email, key: <span class="hljs-string">"t"</span>)
            <span class="hljs-type">TextField</span>(<span class="hljs-string">"주소"</span>, text: <span class="hljs-variable">$address</span>)
                .focused(<span class="hljs-variable">$focus</span>, equals: .address, key: <span class="hljs-string">"a"</span>, modifiers: [.command, .shift, .option])
        }
    }

    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">FouceField</span>: <span class="hljs-title class_">Hashable</span> {
        <span class="hljs-keyword">case</span> email
        <span class="hljs-keyword">case</span> address
    }
}
</code></pre>
<p>사용자가 ⌘ + T를 입력하면 이메일을 처리하는 TextField에 초점이 맞춰집니다. 사용자가 ⌘ + ⌥ + ⇧ + A를 입력하면 주소를 처리하는 TextField에 초점이 맞춰집니다.</p>
<p></p>
<h1>자체 onEditingChanged 만들기</h1>
<p>개별 TextField의 포커스 상태를 확인하는 가장 좋은 방법은 여전히 onEditingChanged를 사용하는 것입니다. 그러나 새 포매터와 같이 onEditingChanged를 사용할 수 없는 경우에는 FocusState를 사용하여 비슷한 효과를 얻을 수 있습니다.</p>
<ul>
<li>개별 TextField의 포커스 상태 확인</li>
</ul>
<pre><code class="hljs language-swift"><span class="hljs-keyword">public</span> <span class="hljs-keyword">extension</span> <span class="hljs-title class_">View</span> {
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">focused</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">condition</span>: <span class="hljs-type">FocusState</span>&#x3C;<span class="hljs-type">Bool</span>>.<span class="hljs-type">Binding</span>, <span class="hljs-params">onFocus</span>: <span class="hljs-keyword">@escaping</span> (<span class="hljs-type">Bool</span>) -> <span class="hljs-type">Void</span>) -> <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> {
        focused(condition)
            .onChange(of: condition.wrappedValue) { value <span class="hljs-keyword">in</span>
                onFocus(value <span class="hljs-operator">==</span> <span class="hljs-literal">true</span>)
            }
    }
}
</code></pre>
<p></p>
<p>사용 방법:</p>
<pre><code class="hljs language-js">struct <span class="hljs-attr">onEditingChangedFocusVersion</span>:<span class="hljs-title class_">View</span>{
    @<span class="hljs-title class_">FocusState</span> <span class="hljs-keyword">var</span> <span class="hljs-attr">focus</span>:<span class="hljs-title class_">Bool</span>
    @<span class="hljs-title class_">State</span> <span class="hljs-keyword">var</span> price = <span class="hljs-number">0</span>
    <span class="hljs-keyword">var</span> <span class="hljs-attr">body</span>: some <span class="hljs-title class_">View</span>{
        <span class="hljs-title class_">Form</span>{
            <span class="hljs-title class_">TextField</span>(<span class="hljs-string">"가격:"</span>,<span class="hljs-attr">value</span>:$price,<span class="hljs-attr">format</span>: .<span class="hljs-property">number</span>)
                .<span class="hljs-title function_">focused</span>(<span class="hljs-params">$focus</span>){ focused <span class="hljs-keyword">in</span>
                    <span class="hljs-title function_">print</span>(focused)
                }
        }
    }
}
</code></pre>
<ul>
<li>여러 TextFields 확인</li>
</ul>
<p>TextField가 포커스를 잃을 때 여러 번 호출을 피하기 위해 뷰 계층 구조에서 마지막 포커스된 TextField의 FocusState 값을 저장해야 합니다.</p>
<p></p>
<pre><code class="hljs language-js">public extension <span class="hljs-title class_">View</span> {
    func storeLastFocus&#x3C;<span class="hljs-title class_">Value</span>: <span class="hljs-title class_">Hashable</span>>(<span class="hljs-attr">current</span>: <span class="hljs-title class_">FocusState</span>&#x3C;<span class="hljs-title class_">Value</span>?>.<span class="hljs-property">Binding</span>, <span class="hljs-attr">last</span>: <span class="hljs-title class_">Binding</span>&#x3C;<span class="hljs-title class_">Value</span>?>) -> some <span class="hljs-title class_">View</span> {
        <span class="hljs-title function_">onChange</span>(<span class="hljs-params"><span class="hljs-keyword">of</span>: current.wrappedValue</span>) { _ <span class="hljs-keyword">in</span>
            <span class="hljs-keyword">if</span> current.<span class="hljs-property">wrappedValue</span> != last.<span class="hljs-property">wrappedValue</span> {
                last.<span class="hljs-property">wrappedValue</span> = current.<span class="hljs-property">wrappedValue</span>
            }
        }
    }

    func focused&#x3C;<span class="hljs-title class_">Value</span>>(_ <span class="hljs-attr">binding</span>: <span class="hljs-title class_">FocusState</span>&#x3C;<span class="hljs-title class_">Value</span>>.<span class="hljs-property">Binding</span>, equals <span class="hljs-attr">value</span>: <span class="hljs-title class_">Value</span>, <span class="hljs-attr">last</span>: <span class="hljs-title class_">Value</span>?, <span class="hljs-attr">onFocus</span>: @escaping (<span class="hljs-title class_">Bool</span>) -> <span class="hljs-title class_">Void</span>) -> some <span class="hljs-title class_">View</span> where <span class="hljs-title class_">Value</span>: <span class="hljs-title class_">Hashable</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">focused</span>(binding, <span class="hljs-attr">equals</span>: value)
            .<span class="hljs-title function_">onChange</span>(<span class="hljs-params"><span class="hljs-keyword">of</span>: binding.wrappedValue</span>) { focusValue <span class="hljs-keyword">in</span>
                <span class="hljs-keyword">if</span> focusValue == value {
                    <span class="hljs-title function_">onFocus</span>(<span class="hljs-literal">true</span>)
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> last == value { <span class="hljs-comment">// only call once</span>
                    <span class="hljs-title function_">onFocus</span>(<span class="hljs-literal">false</span>)
                }
            }
    }
}
</code></pre>
<p>호출:</p>
<pre><code class="hljs language-js">struct <span class="hljs-title class_">OnFocusView</span>: <span class="hljs-title class_">View</span> {
    @<span class="hljs-title class_">FocusState</span> private <span class="hljs-keyword">var</span> <span class="hljs-attr">focused</span>: <span class="hljs-title class_">Focus</span>?
    @<span class="hljs-title class_">State</span> private <span class="hljs-keyword">var</span> <span class="hljs-attr">lastFocused</span>: <span class="hljs-title class_">Focus</span>?
    @<span class="hljs-title class_">State</span> private <span class="hljs-keyword">var</span> name = <span class="hljs-string">""</span>
    @<span class="hljs-title class_">State</span> private <span class="hljs-keyword">var</span> email = <span class="hljs-string">""</span>
    @<span class="hljs-title class_">State</span> private <span class="hljs-keyword">var</span> address = <span class="hljs-string">""</span>
    <span class="hljs-keyword">var</span> <span class="hljs-attr">body</span>: some <span class="hljs-title class_">View</span> {
        <span class="hljs-title class_">List</span> {
            <span class="hljs-title class_">TextField</span>(<span class="hljs-string">"이름:"</span>, <span class="hljs-attr">text</span>: $name)
                .<span class="hljs-title function_">focused</span>(<span class="hljs-params">$focused, equals: .name, last: lastFocused</span>) {
                    <span class="hljs-title function_">print</span>(<span class="hljs-string">"이름:"</span>, $0)
                }
            <span class="hljs-title class_">TextField</span>(<span class="hljs-string">"이메일:"</span>, <span class="hljs-attr">text</span>: $email)
                .<span class="hljs-title function_">focused</span>(<span class="hljs-params">$focused, equals: .email, last: lastFocused</span>) {
                    <span class="hljs-title function_">print</span>(<span class="hljs-string">"이메일:"</span>, $0)
                }
            <span class="hljs-title class_">TextField</span>(<span class="hljs-string">"주소:"</span>, <span class="hljs-attr">text</span>: $address)
                .<span class="hljs-title function_">focused</span>(<span class="hljs-params">$focused, equals: .address, last: lastFocused</span>) {
                    <span class="hljs-title function_">print</span>(<span class="hljs-string">"주소:"</span>, $0)
                }
        }
        .<span class="hljs-title function_">storeLastFocus</span>(<span class="hljs-attr">current</span>: $focused, <span class="hljs-attr">last</span>: $lastFocused) <span class="hljs-comment">// 최신 포커스 값을 저장합니다.</span>
    }

    enum <span class="hljs-title class_">Focus</span> {
        <span class="hljs-keyword">case</span> name, email, address
    }
}
</code></pre>
<h1>키보드</h1>
<p></p>
<p>TextField를 사용하다보면 소프트웨어 키보드와 함께 작업해야 합니다. 이 섹션에서는 키보드와 관련된 몇 가지 예제를 소개할 것입니다.</p>
<h2>키보드 유형</h2>
<p>iPhone에서 keyboardType를 통해 소프트웨어 키보드 유형을 설정하여 사용자 입력을 용이하게 하거나 입력 문자 범위를 제한할 수 있습니다.</p>
<p>예시:</p>
<p></p>
<pre><code class="hljs language-swift"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">KeyboardTypeDemo</span>: <span class="hljs-title class_">View</span> {
    <span class="hljs-meta">@State</span> <span class="hljs-keyword">var</span> price: <span class="hljs-type">Double</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>
    <span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> {
        <span class="hljs-type">Form</span> {
            <span class="hljs-type">TextField</span>(<span class="hljs-string">"Price:"</span>, value: <span class="hljs-variable">$price</span>, format: .number.precision(.fractionLength(<span class="hljs-number">2</span>)))
                .keyboardType(.decimalPad) <span class="hljs-comment">// 소수점 숫자 키보드 지원</span>
        }
    }
}
</code></pre>
<p>위 이미지는 "/assets/img/2024-06-23-AdvancedSwiftUITextFieldEventsFocusKeyboard_0.png" 입니다.</p>
<p>현재, 지원되는 키보드 유형은 총 11가지이며, 다음과 같습니다:</p>
<ul>
<li>asciiCapable</li>
</ul>
<p></p>
<p>아래는 번호 및 구두점 테이블입니다.</p>
<table>
<thead>
<tr>
<th>numbersAndPunctuation</th>
</tr>
</thead>
<tbody>
<tr>
<td>Numbers and punctuation</td>
</tr>
</tbody>
</table>
<p>URL 테이블로 아래 내용을 변환해주세요.</p>
<p></p>
<p>URL 주소를 입력하는 데 유용하며, 문자 및 '.', '/', '.com'을 포함할 수 있습니다.</p>
<ul>
<li>numberPad</li>
</ul>
<p>해당 지역의 숫자 세트를 사용합니다(0-9, ۰-۹, ०-९ 등). 양의 정수나 PIN에 적합합니다.</p>
<ul>
<li>phonePad</li>
</ul>
<p></p>
<p>전화기에서 사용되는 숫자 및 다른 기호, 예를 들면 ‘*#+’</p>
<ul>
<li>namePhonePad</li>
</ul>
<p>텍스트 및 전화번호 입력에 편리합니다. 문자 상태는 asciiCapable과 유사하며, 숫자 상태는 numberPad와 유사합니다.</p>
<ul>
<li>emailAddress</li>
</ul>
<p></p>
<p>'@'를 입력하는 데 편리한 아스키 호환 키보드입니다.</p>
<ul>
<li>decimalPad</li>
</ul>
<p>소수점이 포함된 숫자 키패드입니다. 자세한 내용은 위의 이미지를 참조해주세요.</p>
<ul>
<li>트위터</li>
</ul>
<p></p>
<p>아스키 지원 키보드에는 '@#'이 포함되어 있습니다.</p>
<ul>
<li>웹 검색</li>
</ul>
<p>'.'을 포함한 아스키 지원 키보드이며 'return' 키는 'go'로 표시됩니다.</p>
<ul>
<li>아스키 지원 번호 패드</li>
</ul>
<p></p>
<p>An asciiCapable 키보드에는 숫자가 포함되어 있습니다.</p>
<p>Apple은 다양한 키보드 모드를 제공하지만, 경우에 따라 사용자의 요구 사항을 충족시키지 못할 수도 있습니다.</p>
<p>예를 들어, numberPad 및 decimalPad에는 "-" 및 "return"이 없습니다. SwiftUI 3.0 이전에는 주요 뷰에 별도로 그리거나 SwiftUI 이외의 방법을 사용하여 문제를 해결해야 했습니다. 그러나 SwiftUI 3.0에서는 네이티브 설정 키보드 보조 뷰(자세한 내용은 아래에 설명되어 있음) 추가로 위 문제를 해결하는 것이 이제 더 어렵지 않아졌습니다.</p>
<h1>TextContentType를 통해 제안을 받아보세요</h1>
<p></p>
<p>특정 iOS 앱을 사용할 때 텍스트를 입력할 때 소프트웨어 키보드가 자동으로 입력해야 할 내용을 제안하는 경우가 있습니다. 이는 전화 번호, 이메일, 인증 코드 등을 텍스트ContentType를 통해 얻는 효과입니다.</p>
<p>TextField의 UITextContentType을 설정함으로써 시스템은 입력 중에 입력하려는 콘텐츠를 지능적으로 추론하고 제안을 표시합니다.</p>
<p>다음 코드는 비밀번호 입력 시 키체인을 사용할 수 있도록 합니다.</p>
<pre><code class="hljs language-js">struct <span class="hljs-title class_">KeyboardTypeDemo</span>: <span class="hljs-title class_">View</span> {
    @<span class="hljs-title class_">State</span> <span class="hljs-keyword">var</span> password = <span class="hljs-string">""</span>
    <span class="hljs-keyword">var</span> <span class="hljs-attr">body</span>: some <span class="hljs-title class_">View</span> {
        <span class="hljs-title class_">Form</span> {
            <span class="hljs-title class_">SecureField</span>(<span class="hljs-string">""</span>, <span class="hljs-attr">text</span>: $password)
                .<span class="hljs-title function_">textContentType</span>(.<span class="hljs-property">password</span>)
        }
    }
}
</code></pre>
<p></p>
<p>이메일 주소를 입력할 때 연락처 및 이메일에서 비슷한 이메일 주소를 제안하는 코드입니다:</p>
<pre><code class="hljs language-js">struct <span class="hljs-title class_">KeyboardTypeDemo</span>: <span class="hljs-title class_">View</span> {
    @<span class="hljs-title class_">State</span> <span class="hljs-keyword">var</span> email = <span class="hljs-string">""</span>
    <span class="hljs-keyword">var</span> <span class="hljs-attr">body</span>: some <span class="hljs-title class_">View</span> {
        <span class="hljs-title class_">Form</span> {
            <span class="hljs-title class_">TextField</span>(<span class="hljs-string">""</span>, <span class="hljs-attr">text</span>: $email)
                .<span class="hljs-title function_">textContentType</span>(.<span class="hljs-property">emailAddress</span>)
        }
    }
}
</code></pre>
<p></p>
<p>다음은 설정할 수 있는 여러 종류의 UITextContentType이 있습니다. 흔히 사용되는 것들 중 일부는 다음과 같습니다:</p>
<ul>
<li>password</li>
<li>이름 옵션, 예를 들어 name, givenName, middleName 등이 있습니다.</li>
<li>주소 옵션, 예를 듀 addressCity, fullStreetAddress, postalCode 등이 있습니다.</li>
<li>telephoneNumber</li>
<li>emailAddress</li>
<li>oneTimeCode (인증 코드)</li>
</ul>
<h1>키보드 해제</h1>
<p>일부 경우에는 사용자가 텍스트 입력을 완료한 후 소프트웨어 키보드를 해제하여 더 많은 디스플레이 공간을 확보해야 할 수 있습니다. 일부 키보드 유형에는 "return" 버튼이 없기 때문에 프로그래밍을 사용하여 키보드를 사라지게 해야 합니다.</p>
<p></p>
<p>또한 가끔은 사용자가 "return" 버튼을 클릭하지 않고도 화면의 다른 영역을 클릭하거나 목록을 스크롤하여 키보드를 숨길 수 있게 하려고 할 수도 있습니다. 상호 작용 경험을 향상시키기 위해 프로그래밍을 사용하여 키보드를 사라지게 할 필요가 있습니다.</p>
<ul>
<li>FocusState를 사용하여 키보드 숨기기</li>
</ul>
<p>해당 FocusState가 TextField에 설정되면 값을 "false" 또는 "nil"로 설정하여 키보드를 숨길 수 있습니다.</p>
<pre><code class="hljs language-js">struct <span class="hljs-title class_">HideKeyboardView</span>: <span class="hljs-title class_">View</span> {
    @<span class="hljs-title class_">State</span> private <span class="hljs-keyword">var</span> name = <span class="hljs-string">""</span>
    @<span class="hljs-title class_">FocusState</span> private <span class="hljs-keyword">var</span> <span class="hljs-attr">nameIsFocused</span>: <span class="hljs-title class_">Bool</span>

    <span class="hljs-keyword">var</span> <span class="hljs-attr">body</span>: some <span class="hljs-title class_">View</span> {
        <span class="hljs-title class_">Form</span> {
            <span class="hljs-title class_">TextField</span>(<span class="hljs-string">"이름을 입력하세요"</span>, <span class="hljs-attr">text</span>: $name)
                .<span class="hljs-title function_">focused</span>($nameIsFocused)
            <span class="hljs-title class_">Button</span>(<span class="hljs-string">"키보드 숨기기"</span>) {
                nameIsFocused = <span class="hljs-literal">false</span>
            }
        }
    }
}
</code></pre>
<p></p>
<ul>
<li>기타 상황</li>
</ul>
<p>대부분의 경우, 우리는 UIkit에서 제공하는 메서드를 직접 사용하여 키보드를 숨길 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">UIApplication</span>.<span class="hljs-property">shared</span>.<span class="hljs-title function_">sendAction</span>(#<span class="hljs-title function_">selector</span>(<span class="hljs-title class_">UIResponder</span>.<span class="hljs-property">resignFirstResponder</span>), <span class="hljs-attr">to</span>: nil, <span class="hljs-attr">from</span>: nil, <span class="hljs-attr">for</span>: nil)
</code></pre>
<p>예를 들어, 사용자가 뷰를 드래그할 때 키보드를 숨기는 다음 코드가 있습니다:</p>
<p></p>
<pre><code class="hljs language-js">구조 <span class="hljs-title class_">ResignKeyboardOnDragGesture</span>: <span class="hljs-title class_">ViewModifier</span> {
    <span class="hljs-keyword">var</span> gesture = <span class="hljs-title class_">DragGesture</span>().<span class="hljs-property">onChanged</span> { _ <span class="hljs-keyword">in</span>
        <span class="hljs-title class_">UIApplication</span>.<span class="hljs-property">shared</span>.<span class="hljs-title function_">sendAction</span>(#<span class="hljs-title function_">selector</span>(<span class="hljs-title class_">UIResponder</span>.<span class="hljs-property">resignFirstResponder</span>), <span class="hljs-attr">to</span>: nil, <span class="hljs-attr">from</span>: nil, <span class="hljs-attr">for</span>: nil)
    }

    func <span class="hljs-title function_">body</span>(<span class="hljs-attr">content</span>: <span class="hljs-title class_">Content</span>) -> some <span class="hljs-title class_">View</span> {
        content.<span class="hljs-title function_">gesture</span>(gesture)
    }
}
extension <span class="hljs-title class_">View</span> {
    func <span class="hljs-title function_">dismissKeyboard</span>() -> some <span class="hljs-title class_">View</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">modifier</span>(<span class="hljs-title class_">ResignKeyboardOnDragGesture</span>())
    }
}
구조 <span class="hljs-title class_">HideKeyboardView</span>: <span class="hljs-title class_">View</span> {
    @<span class="hljs-title class_">State</span> private <span class="hljs-keyword">var</span> name = <span class="hljs-string">""</span>
    <span class="hljs-keyword">var</span> <span class="hljs-attr">body</span>: some <span class="hljs-title class_">View</span> {
        <span class="hljs-title class_">Form</span> {
            <span class="hljs-title class_">TextField</span>(<span class="hljs-string">"이름을 입력하세요"</span>, <span class="hljs-attr">text</span>: $name)
        }
        .<span class="hljs-title function_">dismissKeyboard</span>()
    }
}
</code></pre>
<h1>키보드 어시스턴트 뷰</h1>
<h1>툴바를 통해 생성됨</h1>
<p>SwiftUI 3.0에서는 ToolbarItem(placement: .keyboard, content: View)를 사용하여 키보드 어시스턴트 뷰(inputAccessoryView)를 생성할 수 있습니다.</p>
<p></p>
<p>입력 보조 뷰를 통해 이전에 처리하기 어려웠던 많은 문제들을 해결하고 상호 작용 수단을 더 많이 제공할 수 있습니다.</p>
<p>다음 코드는 소수점 숫자를 입력할 때 양/음수 변환 및 확인 버튼을 추가합니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Introspect</span>
struct <span class="hljs-title class_">ToolbarKeyboardDemo</span>: <span class="hljs-title class_">View</span> {
    @<span class="hljs-title class_">State</span> <span class="hljs-keyword">var</span> price = <span class="hljs-string">""</span>
    <span class="hljs-keyword">var</span> <span class="hljs-attr">body</span>: some <span class="hljs-title class_">View</span> {
        <span class="hljs-title class_">Form</span> {
            <span class="hljs-title class_">TextField</span>(<span class="hljs-string">"가격:"</span>, <span class="hljs-attr">text</span>: $price)
                .<span class="hljs-title function_">keyboardType</span>(.<span class="hljs-property">decimalPad</span>)
                .<span class="hljs-property">toolbar</span> {
                    <span class="hljs-title class_">ToolbarItem</span>(<span class="hljs-attr">placement</span>: .<span class="hljs-property">keyboard</span>) {
                        <span class="hljs-title class_">HStack</span> {
                            <span class="hljs-title class_">Button</span>(<span class="hljs-string">"-/+"</span>) {
                                <span class="hljs-keyword">if</span> price.<span class="hljs-title function_">hasPrefix</span>(<span class="hljs-params"><span class="hljs-string">"-"</span></span>) {
                                    price.<span class="hljs-title function_">removeFirst</span>()
                                } <span class="hljs-keyword">else</span> {
                                    price = <span class="hljs-string">"-"</span> + price
                                }
                            }
                            .<span class="hljs-title function_">buttonStyle</span>(.<span class="hljs-property">bordered</span>)
                            <span class="hljs-title class_">Spacer</span>()
                            <span class="hljs-title class_">Button</span>(<span class="hljs-string">"완료"</span>) {
                                <span class="hljs-title class_">UIApplication</span>.<span class="hljs-property">shared</span>.<span class="hljs-title function_">sendAction</span>(#<span class="hljs-title function_">selector</span>(<span class="hljs-title class_">UIResponder</span>.<span class="hljs-property">resignFirstResponder</span>), <span class="hljs-attr">to</span>: nil, <span class="hljs-attr">from</span>: nil, <span class="hljs-attr">for</span>: nil)
                                <span class="hljs-comment">// 해야 할 일을 수행합니다</span>
                            }
                            .<span class="hljs-title function_">buttonStyle</span>(.<span class="hljs-property">bordered</span>)
                        }
                        .<span class="hljs-title function_">padding</span>(.<span class="hljs-property">horizontal</span>, <span class="hljs-number">30</span>)
                    }
                }
        }
    }
}
</code></pre>
<p></p>
<p>안타깝지만, ToolbarItem을 통해 입력 보조 뷰를 설정하는 데는 아직 몇 가지 제한 사항이 있습니다:</p>
<ul>
<li>표시 콘텐츠 제한</li>
</ul>
<p>높이가 고정되어 있어 악세서리 뷰의 전체 디스플레이 영역을 활용할 수 없습니다. 다른 종류의 툴바와 마찬가지로 SwiftUI가 콘텐츠의 레이아웃에 개입합니다.</p>
<ul>
<li>같은 뷰 내에서 여러 텍스트 필드에 대해 별도의 액세서리 뷰를 설정할 수 없음</li>
</ul>
<p></p>
<p>보다 복잡한 조건부 구문은 ToolbarItem에서 사용할 수 없습니다. 다른 텍스트 필드에 대해 별도로 설정하더라도 SwiftUI는 모든 내용을 함께 표시하기 위해 병합합니다.</p>
<h1>UIKit을 통해 생성하기</h1>
<p>현재 단계에서는 SwiftUI에 대한 키보드 액세서리 뷰를 UIKit을 통해 생성하는 것이 여전히 최적의 솔루션이 됩니다. 화면 표시에 대한 완벽한 제어를 얻을 수 있을 뿐만 아니라 동일한 뷰 내부의 여러 텍스트 필드를 별도로 설정할 수도 있습니다.</p>
<pre><code class="hljs language-js">extension <span class="hljs-title class_">UIView</span> {
    func <span class="hljs-title function_">constrainEdges</span>(<span class="hljs-params">to other: UIView</span>) {
        translatesAutoresizingMaskIntoConstraints = <span class="hljs-literal">false</span>
        <span class="hljs-title class_">NSLayoutConstraint</span>.<span class="hljs-title function_">activate</span>([
            leadingAnchor.<span class="hljs-title function_">constraint</span>(<span class="hljs-attr">equalTo</span>: other.<span class="hljs-property">leadingAnchor</span>),
            trailingAnchor.<span class="hljs-title function_">constraint</span>(<span class="hljs-attr">equalTo</span>: other.<span class="hljs-property">trailingAnchor</span>),
            topAnchor.<span class="hljs-title function_">constraint</span>(<span class="hljs-attr">equalTo</span>: other.<span class="hljs-property">topAnchor</span>),
            bottomAnchor.<span class="hljs-title function_">constraint</span>(<span class="hljs-attr">equalTo</span>: other.<span class="hljs-property">bottomAnchor</span>),
        ])
    }
}

extension <span class="hljs-title class_">View</span> {
    func inputAccessoryView&#x3C;<span class="hljs-title class_">Content</span>: <span class="hljs-title class_">View</span>>(@<span class="hljs-title class_">ViewBuilder</span> <span class="hljs-attr">content</span>: @escaping () -> <span class="hljs-title class_">Content</span>) -> some <span class="hljs-title class_">View</span> {
        introspectTextField { td <span class="hljs-keyword">in</span>
            <span class="hljs-keyword">let</span> viewController = <span class="hljs-title class_">UIHostingController</span>(<span class="hljs-attr">rootView</span>: <span class="hljs-title function_">content</span>())
            viewController.<span class="hljs-property">view</span>.<span class="hljs-title function_">constrainEdges</span>(<span class="hljs-attr">to</span>: viewController.<span class="hljs-property">view</span>)
            td.<span class="hljs-property">inputAccessoryView</span> = viewController.<span class="hljs-property">view</span>
        }
    }
    func inputAccessoryView&#x3C;<span class="hljs-title class_">Content</span>: <span class="hljs-title class_">View</span>>(<span class="hljs-attr">content</span>: <span class="hljs-title class_">Content</span>) -> some <span class="hljs-title class_">View</span> {
        introspectTextField { td <span class="hljs-keyword">in</span>
            <span class="hljs-keyword">let</span> viewController = <span class="hljs-title class_">UIHostingController</span>(<span class="hljs-attr">rootView</span>: content)
            viewController.<span class="hljs-property">view</span>.<span class="hljs-title function_">constrainEdges</span>(<span class="hljs-attr">to</span>: viewController.<span class="hljs-property">view</span>)
            td.<span class="hljs-property">inputAccessoryView</span> = viewController.<span class="hljs-property">view</span>
        }
    }
}
</code></pre>
<p></p>
<p>사용법:</p>
<pre><code class="hljs language-js">struct <span class="hljs-title class_">OnFocusDemo</span>: <span class="hljs-title class_">View</span> {
    @<span class="hljs-title class_">FocusState</span> <span class="hljs-keyword">var</span> <span class="hljs-attr">focus</span>: <span class="hljs-title class_">FocusedField</span>?
    @<span class="hljs-title class_">State</span> <span class="hljs-keyword">var</span> name = <span class="hljs-string">""</span>
    @<span class="hljs-title class_">State</span> <span class="hljs-keyword">var</span> email = <span class="hljs-string">""</span>
    @<span class="hljs-title class_">State</span> <span class="hljs-keyword">var</span> phoneNumber = <span class="hljs-string">""</span>
    <span class="hljs-keyword">var</span> <span class="hljs-attr">body</span>: some <span class="hljs-title class_">View</span> {
        <span class="hljs-title class_">Form</span> {
            <span class="hljs-title class_">TextField</span>(<span class="hljs-string">"이름:"</span>, <span class="hljs-attr">text</span>: $name)
                .<span class="hljs-title function_">focused</span>($focus, <span class="hljs-attr">equals</span>: .<span class="hljs-property">name</span>)
                .<span class="hljs-title function_">inputAccessoryView</span>(<span class="hljs-attr">content</span>: <span class="hljs-title function_">accessoryView</span>(<span class="hljs-attr">focus</span>: .<span class="hljs-property">name</span>))

            <span class="hljs-title class_">TextField</span>(<span class="hljs-string">"이메일:"</span>, <span class="hljs-attr">text</span>: $email)
                .<span class="hljs-title function_">focused</span>($focus, <span class="hljs-attr">equals</span>: .<span class="hljs-property">email</span>)
                .<span class="hljs-title function_">inputAccessoryView</span>(<span class="hljs-attr">content</span>: <span class="hljs-title function_">accessoryView</span>(<span class="hljs-attr">focus</span>: .<span class="hljs-property">email</span>))

            <span class="hljs-title class_">TextField</span>(<span class="hljs-string">"전화번호:"</span>, <span class="hljs-attr">text</span>: $phoneNumber)
                .<span class="hljs-title function_">focused</span>($focus, <span class="hljs-attr">equals</span>: .<span class="hljs-property">phone</span>)
        }
        .<span class="hljs-property">onSubmit</span> {
            <span class="hljs-keyword">switch</span> focus {
            <span class="hljs-keyword">case</span> .<span class="hljs-property">name</span>:
                focus = .<span class="hljs-property">email</span>
            <span class="hljs-keyword">case</span> .<span class="hljs-property">email</span>:
                focus = .<span class="hljs-property">phone</span>
            <span class="hljs-keyword">case</span> .<span class="hljs-property">phone</span>:
                <span class="hljs-keyword">if</span> !name.<span class="hljs-property">isEmpty</span>, !email.<span class="hljs-property">isEmpty</span>, !phoneNumber.<span class="hljs-property">isEmpty</span> {}
            <span class="hljs-attr">default</span>:
                <span class="hljs-keyword">break</span>
            }
        }
    }
}

struct <span class="hljs-attr">accessoryView</span>: <span class="hljs-title class_">View</span> {
    <span class="hljs-keyword">let</span> <span class="hljs-attr">focus</span>: <span class="hljs-title class_">FocusedField</span>?
    <span class="hljs-keyword">var</span> <span class="hljs-attr">body</span>: some <span class="hljs-title class_">View</span> {
        <span class="hljs-keyword">switch</span> focus {
        <span class="hljs-keyword">case</span> .<span class="hljs-property">name</span>:
            <span class="hljs-title class_">Button</span>(<span class="hljs-string">"이름"</span>) {}.<span class="hljs-title function_">padding</span>(.<span class="hljs-property">vertical</span>, <span class="hljs-number">10</span>)
        <span class="hljs-keyword">case</span> .<span class="hljs-property">email</span>:
            <span class="hljs-title class_">Button</span>(<span class="hljs-string">"이메일"</span>) {}.<span class="hljs-title function_">padding</span>(.<span class="hljs-property">vertical</span>, <span class="hljs-number">10</span>)
        <span class="hljs-attr">default</span>:
            <span class="hljs-title class_">EmptyView</span>()
        }
    }
}
</code></pre>
<h1>사용자 정의 제출 레이블</h1>
<p>기본적으로 TextField (SecureField)의 키보드에 대한 제출 동작 버튼은 "return"입니다. SwiftUI 3.0에서 소개된 "submitLabel" 수정자를 사용하면 "return" 버튼을 입력 콘텍스트와 관련된 텍스트로 수정할 수 있습니다.</p>
<p></p>
<pre><code class="hljs language-swift"><span class="hljs-type">TextField</span>(<span class="hljs-string">"사용자 이름"</span>, text: <span class="hljs-variable">$username</span>)
            .submitLabel(.next)
</code></pre>
<p>현재 지원되는 유형은 다음과 같습니다:</p>
<ul>
<li>continue</li>
<li>done</li>
<li>go</li>
<li>join</li>
<li>next</li>
<li>return</li>
<li>route</li>
<li>search</li>
<li>send</li>
</ul>
<p></p>
<p>예를 들어, 이전 코드에서는 이름, 이메일 및 전화번호에 대한 서로 다른 표시를 설정할 수 있습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">TextField</span>(<span class="hljs-string">"이름:"</span>, <span class="hljs-attr">text</span>: $name)
                .<span class="hljs-title function_">focused</span>($focus, <span class="hljs-attr">equals</span>: .<span class="hljs-property">name</span>)
                .<span class="hljs-title function_">submitLabel</span>(.<span class="hljs-property">next</span>)
<span class="hljs-title class_">TextField</span>(<span class="hljs-string">"이메일:"</span>, <span class="hljs-attr">text</span>: $email)
                .<span class="hljs-title function_">focused</span>($focus, <span class="hljs-attr">equals</span>: .<span class="hljs-property">email</span>)
                .<span class="hljs-title function_">submitLabel</span>(.<span class="hljs-property">next</span>)

<span class="hljs-title class_">TextField</span>(<span class="hljs-string">"전화번호:"</span>, <span class="hljs-attr">text</span>: $phoneNumber)
                .<span class="hljs-title function_">focused</span>($focus, <span class="hljs-attr">equals</span>: .<span class="hljs-property">phone</span>)
                .<span class="hljs-title function_">submitLabel</span>(.<span class="hljs-property">return</span>)
</code></pre>
<h1>결론</h1>
<p>SwiftUI 1.0부터 Apple은 TextField의 기능을 지속적으로 개선해 왔습니다. 버전 3.0에서 SwiftUI는 더 많은 네이티브 수정자를 제공하는데 그치지 않고 FocusState와 onSubmit과 같은 통합 관리 논리를 제공합니다. 믿음직스러운 2~3년 뒤에는 SwiftUI의 주요 컨트롤의 네이티브 기능이 해당하는 UIKit 컨트롤과 맞먹을 것이라고 믿습니다.</p>
<p></p>
<p>만약 이 글이 도움이 되었거나 즐겁게 읽으셨다면, 제 글을 지원하기 위해 기부를 고려해 주세요. 여러분의 기부는 저가 계속해서 가치 있는 콘텐츠를 만드는데 도움이 될 것입니다.
Patreon, Buy Me a Coffee 또는 PayPal을 통해 기부할 수 있습니다.</p>
<pre><code class="hljs language-js">연락하고 싶다면?

<span class="hljs-title class_">Twitter</span>에서 @fatbobman을 팔로우하세요.
</code></pre>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"SwiftUI TextField 심화  이벤트, 포커스, 키보드 제어 방법","description":"","date":"2024-06-23 21:35","slug":"2024-06-23-AdvancedSwiftUITextFieldEventsFocusKeyboard","content":"\n이 글은 SwiftUI TextField 이벤트, 포커스 전환, 키보드 설정 및 기타 관련 경험, 기술 및 고려 사항을 탐색할 것입니다.\n\n## 이벤트\n\n### onEditingChanged\n\nTextField가 포커스를 얻을 때(편집 가능한 상태로 전환될 때), onEditingChanged는 주어진 메서드를 호출하고 값으로 true를 전달합니다. TextField가 포커스를 잃을 때, 다시 메서드를 호출하고 값을 false로 전달합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```swift\nstruct OnEditingChangedDemo: View {\n    @State var name = \"\"\n\n    var body: some View {\n        List {\n            TextField(\"이름:\", text: $name, onEditingChanged: getFocus)\n        }\n    }\n\n    func getFocus(focused: Bool) {\n        print(\"포커스 받음: \\(focused ? \"참\" : \"거짓\")\")\n    }\n}\n```\n\n이 매개변수의 이름은 사용자에게 모호함을 초래하기 쉽습니다. 사용자가 콘텐츠를 입력했는지 확인하는 데 onEditingChanged를 사용하지 마십시오.\n\niOS 15에서는 ParseableFormatStyle을 지원하는 새로 추가된 생성자에서 이 매개변수를 제공하지 않습니다. 따라서 새로운 Formatter를 사용하는 TextFields의 경우, 포커스를 얻었는지 또는 상실했는지를 확인하기 위해 다른 수단을 사용해야 합니다.\n\n# onCommit\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nonCommit은 사용자가 입력하는 중에 리턴 키를 누를 때 (또는 클릭할 때) 트리거됩니다 (코드 시뮬레이션으로는 트리거할 수 없음). 사용자가 리턴 키를 클릭하지 않으면(예: 직접 다른 TextField로 전환하는 경우) onCommit은 트리거되지 않습니다. onCommit이 트리거되는 동시에 TextField는 포커스를 잃게 됩니다.\n\n```js\nstruct OnCommitDemo: View {\n    @State var name = \"\"\n    var body: some View {\n        List {\n            TextField(\"이름:\", text: $name, onCommit: { print(\"커밋\") })\n        }\n    }\n}\n```\n\n사용자가 입력한 내용을 확인해야 하는 경우, onCommit과 onEditingChanged를 함께 사용하는 것이 좋습니다. 사용자의 입력 데이터를 실시간으로 처리하려면 SwiftUI TextField 고급 — 형식 지정 및 유효성 검사를 참고해주세요.\n\nonCommit은 SecureField에도 적용됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\niOS 15에서 추가된 ParseableFormatStyle을 지원하는 새 생성자는 해당 매개변수를 제공하지 않습니다. 동일한 효과를 얻으려면 새롭게 추가된 onSubmit을 사용할 수 있습니다.\n\n# onSubmit\n\nonSubmit은 SwiftUI 3.0에서 새로 추가된 기능입니다. onCommit 및 onEditingChanged는 각각의 TextField의 상태를 설명하지만 onSubmit은 한 뷰 내에서 여러 TextField의 통합 관리 및 일정 관리를 가능하게 합니다.\n\n```js\n// onSubmit의 정의\nextension View {\n    public func onSubmit(of triggers: SubmitTriggers = .text, _ action: @escaping (() -\u003e Void)) -\u003e some View\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래 코드는 onCommit과 동일한 동작을 구현할 것입니다:\n\n```js\nstruct OnSubmitDemo:View{\n    @State var name = \"\"\n    var body: some View{\n        List{\n            TextField(\"name:\",text: $name)\n                .onSubmit {\n                    print(\"commit\")\n                }\n        }\n    }\n}\n```\n\nonSubmit의 트리거 조건은 onCommit과 동일하며, 사용자가 “return”을 활성화하도록 요구합니다.\n\nonSubmit은 SecureField에도 적용됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 범위와 중첩\n\nonSubmit의 구현은 환경 값 TriggerSubmitAction을 설정하는 것에 기반하며 (아직 개발자에게 제공되지 않음) onSubmit은 범위를 가지고 있으며 (뷰 트리로 전달될 수 있음) 중첩될 수 있습니다.\n\n```js\nstruct OnSubmitDemo: View {\n    @State var text1 = \"\"\n    @State var text2 = \"\"\n    @State var text3 = \"\"\n    var body: some View {\n        Form {\n            Group {\n                TextField(\"text1\", text: $text1)\n                    .onSubmit { print(\"text1 commit\") }\n                TextField(\"text2\", text: $text2)\n                    .onSubmit { print(\"text2 commit\") }\n            }\n            .onSubmit { print(\"textfield in group commit\") }\n            TextField(\"text3\", text: $text3)\n                .onSubmit { print(\"text3 commit\") }\n        }\n        .onSubmit { print(\"textfield in form commit1\") }\n        .onSubmit { print(\"textfield in form commit2\") }\n    }\n}\n```\n\nTextField (text1)이 commit되면, 콘솔 출력은 다음과 같습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n양식에서의 텍스트 필드 커밋2\n양식에서의 텍스트 필드 커밋1\n그룹에서의 텍스트 필드 커밋\n텍스트1 커밋\n```\n\n외부에서 내부로 호출 순서임을 참고하십시오.\n\n# 제한된 범위\n\nsubmitScope를 사용하여 범위를 차단하고 (뷰 트리 상에서의 추가 전파를 제한합니다). 예를 들어, 위 코드에서는 그룹 뒤에 submitScope를 추가하십시오.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n그룹 {\n    TextField(\"text1\", text: $text1)\n        .onSubmit { print(\"text1 commit\") }\n    TextField(\"text2\", text: $text2)\n        .onSubmit { print(\"text2 commit\") }\n}\n.submitScope()  // scope blocking\n.onSubmit { print(\"textfield in group commit\") }\n```\n\nTextField1이 커밋되면 콘솔에 다음이 표시됩니다:\n\n```js\ntext1 commit\n```\n\n이 시점에서 onSubmit의 범위는 그룹 내로 제한됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n뷰에 여러 개의 TextFields가 있는 경우, onSubmit과 FocusState를 결합하여 훌륭한 사용자 경험을 얻을 수 있습니다.\n\n# searchable 지원\n\niOS 15에서는 새로운 검색 상자도 \"return\"을 클릭할 때 onSubmit을 트리거하지만, 트리거를 검색으로 설정해야 합니다:\n\n```js\nstruct OnSubmitForSearchableDemo:View{\n    @State var name = \"\"\n    @State var searchText = \"\"\n    var body: some View{\n        NavigationView{\n            Form{\n                TextField(\"이름:\",text:$name)\n                    .onSubmit {print(\"textField 커밋\")}\n            }\n            .searchable(text: $searchText)\n            .onSubmit(of: .search) { //\n                print(\"searchField 커밋\")\n            }\n        }\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nSubmitTriggers의 타입은 OptionSet입니다. onSubmit 메서드는 환경 내에서 뷰 트리에서 SubmitTriggers에 포함된 값을 계속 전달합니다. onSubmit에서 받는 SubmitTriggers 값이 onSubmit에서 지정된 SubmitTriggers 세트에 포함되지 않으면 전달이 종료됩니다. 간단히 말해, onSubmit(of:.search)은 TextField에서 생성된 커밋 상태를 차단하고 그 반대도 마찬가지입니다.\n\n예를 들어, 위 코드에서 searchable 다음에 onSubmt(of:.text)를 추가하면 TextField의 커밋 이벤트에 응답할 수 없게 됩니다.\n\n```js\n.searchable(text: $searchText)\n            .onSubmit(of: .search) {\n                print(\"searchField commit1\")\n            }\n            .onSubmit {print(\"textField commit\")} //cannot be triggered, blocked by search\n```\n\n따라서 TextField와 검색 상자를 모두 처리할 때 호출 순서에 특별히 주의해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음 코드는 하나의 onSubmit에서 TextField와 검색 상자를 모두 지원할 수 있습니다:\n\n```js\n.onSubmit(of: [.text, .search]) {\n  print(\"무언가가 제출되었습니다\")\n}\n```\n\n다음 코드는 searchable 보다 onSubmit(of:.search)가 먼저 배치되어 있기 때문에 어느 것도 트리거하지 않습니다.\n\n```js\nNavigationView{\n    Form{\n        TextField(\"이름:\", text: $name)\n            .onSubmit {print(\"textField 제출\")}\n    }\n    .onSubmit(of: .search) { // 트리거 안 됨\n        print(\"searchField 제출1\")\n    }\n    .searchable(text: $searchText)\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 초점\n\niOS 15(몬테레이) 이전에는 SwiftUI에서 TextField(예 : becomeFirstResponder)에 초점을 맞추는 방법을 제공하지 않았습니다. 오랫동안 개발자들은 비슈위 방법에 의존하여 비슷한 기능을 구현해야 했습니다.\n\nSwiftUI 3.0에서 Apple은 개발자들에게 onSubmit과 유사한, 높은 수준의 뷰 계층 구조에서 텍스트 필드의 초점을 일관되게 결정하고 관리할 수 있는 예상보다 훨씬 더 나은 솔루션을 제공했습니다.\n\n# 기본 사용법\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nSwiftUI에서는 새 FocusState 프로퍼티 래퍼를 제공하여이 뷰 내의 TextField에 포커스가 있는지 여부를 결정하는 데 도움을 줍니다. focused를 사용하여 FocusState를 특정 TextField와 연결할 수 있습니다.\n\n```swift\nstruct OnFocusDemo: View {\n    @FocusState var isNameFocused: Bool\n    @State var name = \"\"\n\n    var body: some View {\n        List {\n            TextField(\"이름:\", text: $name)\n                .focused($isNameFocused)\n        }\n        .onChange(of: isNameFocused) { value in\n            print(value)\n        }\n    }\n}\n```\n\n위 코드는 TextField가 포커스를 얻을 때 isNameFocused를 true로 설정하고 포커스를 잃을 때 false로 설정합니다.\n\n동일한 뷰 내에 여러 개의 TextField가있는 경우 각 해당 TextField와 연결할 여러 FocusStates를 생성할 수 있습니다. 예를 들어:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위의 방법은 뷰에 더 많은 TextField가 있는 경우 귀찮아지고 통일된 관리에 도움이 되지 않습니다. 다행히 FocusState는 Boolean 값뿐만 아니라 모든 해시 타입도 지원합니다. Hashable 프로토콜을 준수하는 enum을 사용하여 뷰 내 여러 TextField의 포커스를 관리할 수 있습니다. 다음 코드는 위의 코드와 동일한 기능을 수행합니다:\n\n```js\nstruct OnFocusDemo:View{\n    @FocusState var focus:FocusedField?\n    @State var name = \"\"\n    @State var password = \"\"\n    var body: some View{\n        List{\n            TextField(\"name:\",text:$name)\n                .focused($focus, equals: .name)\n            SecureField(\"password:\",text:$password)\n                .focused($focus,equals: .password)\n        }\n        .onChange(of: focus, perform: {print($0)})\n    }\n\n    enum FocusedField:Hashable{\n        case name,password\n    }\n}\n```\n\n# 특정 TextField가 뷰를 표시한 직후에 즉시 포커스를 받도록 만들기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nFocusState를 사용하면 지정된 TextField가 포커스를 얻고 뷰를 표시한 후 즉시 키보드가 팝업되게 할 수 있어요:\n\n```js\nstruct OnFocusDemo: View {\n    @FocusState var focus: FocusedField?\n    @State var name = \"\"\n    @State var password = \"\"\n\n    var body: some View {\n        List {\n            TextField(\"이름:\", text: $name)\n                .focused($focus, equals: .name)\n            SecureField(\"비밀번호:\", text: $password)\n                .focused($focus, equals: .password)\n        }\n        .onAppear {\n            DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {\n                focus = .name\n            }\n        }\n    }\n\n    enum FocusedField: Hashable {\n        case name, password\n    }\n}\n```\n\n뷰 초기화 중에 값을 할당하는 것은 잘못된 방법이에요. onAppear에서도 TextField가 포커스를 얻을 시간을 지연시켜야 해요 (iOS 16에서는 지연이 필요하지 않아요).\n\n# 여러 개의 TextField 사이에서 포커스 전환하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n주의력과 onSubmit을 결합하여 한 TextField에서 입력을 완료하고(리턴을 클릭할 때) 자동으로 다음 TextField로 포커스를 전환하는 효과를 얻을 수 있어요.\n\n```js\nstruct OnFocusDemo:View{\n    @FocusState var focus:FocusedField?\n    @State var name = \"\"\n    @State var email = \"\"\n    @State var phoneNumber = \"\"\n    var body: some View{\n        List{\n            TextField(\"이름:\",text:$name)\n                .focused($focus, equals: .name)\n                .onSubmit {\n                    focus = .email\n                }\n            TextField(\"이메일:\",text:$email)\n                .focused($focus,equals: .email)\n                .onSubmit {\n                    focus = .phone\n                }\n            TextField(\"전화번호:\",text:$phoneNumber)\n                .focused($focus, equals: .phone)\n                .onSubmit {\n                    if !name.isEmpty \u0026\u0026 !email.isEmpty \u0026\u0026 !phoneNumber.isEmpty {\n                        submit()\n                    }\n                }\n        }\n    }\n\n    private func submit(){\n        // 모든 정보 제출\n        print(\"제출\")\n    }\n    enum FocusedField:Hashable{\n        case name,email,phone\n    }\n}\n```\n\n위의 코드는 onSubmit 전달 기능을 활용하여 다음과 같이 변환될 수도 있어요:\n\n```js\nList {\n    TextField(\"이름:\", text: $name)\n        .focused($focus, equals: .name)\n    TextField(\"이메일:\", text: $email)\n        .focused($focus, equals: .email)\n    TextField(\"전화번호:\", text: $phoneNumber)\n        .focused($focus, equals: .phone)\n}\n.onSubmit {\n    switch focus {\n    case .name:\n        focus = .email\n    case .email:\n        focus = .phone\n    case .phone:\n        if !name.isEmpty, !email.isEmpty, !phoneNumber.isEmpty {\n            submit()\n        }\n    default:\n        break\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n화면 버튼(예: 보조 키보드 보기) 또는 키보드 단축키를 결합하여 포커스를 전환하거나 특정 TextField로 이동할 수도 있습니다.\n\n# 포커스를 얻기 위한 키보드 단축키 사용\n\n보안 필드를 포함한 여러 개의 TextField가 있는 뷰에서는 Tab 키를 사용하여 TextField에서 포커스를 직접 전환할 수 있습니다. 그러나 SwiftUI는 키보드 단축키를 사용하여 특정 TextField에 포커스를 설정하는 기능을 직접 제공하지 않습니다. FocusState와 keyboardShortcut을 결합하여 iPad 및 MacOS에서 이 기능을 얻을 수 있습니다.\n\n키보드 단축키 바인딩을 지원하는 focused를 생성하세요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```swift\npublic extension View {\n    func focused(_ condition: FocusState\u003cBool\u003e.Binding, key: KeyEquivalent, modifiers: EventModifiers = .command) -\u003e some View {\n        focused(condition)\n            .background(Button(\"\") {\n                condition.wrappedValue = true\n            }\n            .keyboardShortcut(key, modifiers: modifiers)\n            .hidden()\n            )\n    }\n\n    func focused\u003cValue\u003e(_ binding: FocusState\u003cValue\u003e.Binding, equals value: Value, key: KeyEquivalent, modifiers: EventModifiers = .command) -\u003e some View where Value: Hashable {\n        focused(binding, equals: value)\n            .background(Button(\"\") {\n                binding.wrappedValue = value\n            }\n            .keyboardShortcut(key, modifiers: modifiers)\n            .hidden()\n            )\n    }\n}\n```\n\n코드 사용법:\n\n```swift\nstruct ShortcutFocusDemo: View {\n    @FocusState var focus: FouceField?\n    @State private var email = \"\"\n    @State private var address = \"\"\n    var body: some View {\n        Form {\n            TextField(\"이메일\", text: $email)\n                .focused($focus, equals: .email, key: \"t\")\n            TextField(\"주소\", text: $address)\n                .focused($focus, equals: .address, key: \"a\", modifiers: [.command, .shift, .option])\n        }\n    }\n\n    enum FouceField: Hashable {\n        case email\n        case address\n    }\n}\n```\n\n사용자가 ⌘ + T를 입력하면 이메일을 처리하는 TextField에 초점이 맞춰집니다. 사용자가 ⌘ + ⌥ + ⇧ + A를 입력하면 주소를 처리하는 TextField에 초점이 맞춰집니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 자체 onEditingChanged 만들기\n\n개별 TextField의 포커스 상태를 확인하는 가장 좋은 방법은 여전히 onEditingChanged를 사용하는 것입니다. 그러나 새 포매터와 같이 onEditingChanged를 사용할 수 없는 경우에는 FocusState를 사용하여 비슷한 효과를 얻을 수 있습니다.\n\n- 개별 TextField의 포커스 상태 확인\n\n```swift\npublic extension View {\n    func focused(_ condition: FocusState\u003cBool\u003e.Binding, onFocus: @escaping (Bool) -\u003e Void) -\u003e some View {\n        focused(condition)\n            .onChange(of: condition.wrappedValue) { value in\n                onFocus(value == true)\n            }\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n사용 방법:\n\n```js\nstruct onEditingChangedFocusVersion:View{\n    @FocusState var focus:Bool\n    @State var price = 0\n    var body: some View{\n        Form{\n            TextField(\"가격:\",value:$price,format: .number)\n                .focused($focus){ focused in\n                    print(focused)\n                }\n        }\n    }\n}\n```\n\n- 여러 TextFields 확인\n\nTextField가 포커스를 잃을 때 여러 번 호출을 피하기 위해 뷰 계층 구조에서 마지막 포커스된 TextField의 FocusState 값을 저장해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\npublic extension View {\n    func storeLastFocus\u003cValue: Hashable\u003e(current: FocusState\u003cValue?\u003e.Binding, last: Binding\u003cValue?\u003e) -\u003e some View {\n        onChange(of: current.wrappedValue) { _ in\n            if current.wrappedValue != last.wrappedValue {\n                last.wrappedValue = current.wrappedValue\n            }\n        }\n    }\n\n    func focused\u003cValue\u003e(_ binding: FocusState\u003cValue\u003e.Binding, equals value: Value, last: Value?, onFocus: @escaping (Bool) -\u003e Void) -\u003e some View where Value: Hashable {\n        return focused(binding, equals: value)\n            .onChange(of: binding.wrappedValue) { focusValue in\n                if focusValue == value {\n                    onFocus(true)\n                } else if last == value { // only call once\n                    onFocus(false)\n                }\n            }\n    }\n}\n```\n\n호출:\n\n```js\nstruct OnFocusView: View {\n    @FocusState private var focused: Focus?\n    @State private var lastFocused: Focus?\n    @State private var name = \"\"\n    @State private var email = \"\"\n    @State private var address = \"\"\n    var body: some View {\n        List {\n            TextField(\"이름:\", text: $name)\n                .focused($focused, equals: .name, last: lastFocused) {\n                    print(\"이름:\", $0)\n                }\n            TextField(\"이메일:\", text: $email)\n                .focused($focused, equals: .email, last: lastFocused) {\n                    print(\"이메일:\", $0)\n                }\n            TextField(\"주소:\", text: $address)\n                .focused($focused, equals: .address, last: lastFocused) {\n                    print(\"주소:\", $0)\n                }\n        }\n        .storeLastFocus(current: $focused, last: $lastFocused) // 최신 포커스 값을 저장합니다.\n    }\n\n    enum Focus {\n        case name, email, address\n    }\n}\n```\n\n# 키보드\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nTextField를 사용하다보면 소프트웨어 키보드와 함께 작업해야 합니다. 이 섹션에서는 키보드와 관련된 몇 가지 예제를 소개할 것입니다.\n\n## 키보드 유형\n\niPhone에서 keyboardType를 통해 소프트웨어 키보드 유형을 설정하여 사용자 입력을 용이하게 하거나 입력 문자 범위를 제한할 수 있습니다.\n\n예시:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```swift\nstruct KeyboardTypeDemo: View {\n    @State var price: Double = 0\n    var body: some View {\n        Form {\n            TextField(\"Price:\", value: $price, format: .number.precision(.fractionLength(2)))\n                .keyboardType(.decimalPad) // 소수점 숫자 키보드 지원\n        }\n    }\n}\n```\n\n위 이미지는 \"/assets/img/2024-06-23-AdvancedSwiftUITextFieldEventsFocusKeyboard_0.png\" 입니다.\n\n현재, 지원되는 키보드 유형은 총 11가지이며, 다음과 같습니다:\n\n- asciiCapable\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 번호 및 구두점 테이블입니다.\n\n| numbersAndPunctuation   |\n| ----------------------- |\n| Numbers and punctuation |\n\nURL 테이블로 아래 내용을 변환해주세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nURL 주소를 입력하는 데 유용하며, 문자 및 '.', '/', '.com'을 포함할 수 있습니다.\n\n- numberPad\n\n해당 지역의 숫자 세트를 사용합니다(0-9, ۰-۹, ०-९ 등). 양의 정수나 PIN에 적합합니다.\n\n- phonePad\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n전화기에서 사용되는 숫자 및 다른 기호, 예를 들면 ‘\\*#+’\n\n- namePhonePad\n\n텍스트 및 전화번호 입력에 편리합니다. 문자 상태는 asciiCapable과 유사하며, 숫자 상태는 numberPad와 유사합니다.\n\n- emailAddress\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n'@'를 입력하는 데 편리한 아스키 호환 키보드입니다.\n\n- decimalPad\n\n소수점이 포함된 숫자 키패드입니다. 자세한 내용은 위의 이미지를 참조해주세요.\n\n- 트위터\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아스키 지원 키보드에는 '@#'이 포함되어 있습니다.\n\n- 웹 검색\n\n'.'을 포함한 아스키 지원 키보드이며 'return' 키는 'go'로 표시됩니다.\n\n- 아스키 지원 번호 패드\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nAn asciiCapable 키보드에는 숫자가 포함되어 있습니다.\n\nApple은 다양한 키보드 모드를 제공하지만, 경우에 따라 사용자의 요구 사항을 충족시키지 못할 수도 있습니다.\n\n예를 들어, numberPad 및 decimalPad에는 \"-\" 및 \"return\"이 없습니다. SwiftUI 3.0 이전에는 주요 뷰에 별도로 그리거나 SwiftUI 이외의 방법을 사용하여 문제를 해결해야 했습니다. 그러나 SwiftUI 3.0에서는 네이티브 설정 키보드 보조 뷰(자세한 내용은 아래에 설명되어 있음) 추가로 위 문제를 해결하는 것이 이제 더 어렵지 않아졌습니다.\n\n# TextContentType를 통해 제안을 받아보세요\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n특정 iOS 앱을 사용할 때 텍스트를 입력할 때 소프트웨어 키보드가 자동으로 입력해야 할 내용을 제안하는 경우가 있습니다. 이는 전화 번호, 이메일, 인증 코드 등을 텍스트ContentType를 통해 얻는 효과입니다.\n\nTextField의 UITextContentType을 설정함으로써 시스템은 입력 중에 입력하려는 콘텐츠를 지능적으로 추론하고 제안을 표시합니다.\n\n다음 코드는 비밀번호 입력 시 키체인을 사용할 수 있도록 합니다.\n\n```js\nstruct KeyboardTypeDemo: View {\n    @State var password = \"\"\n    var body: some View {\n        Form {\n            SecureField(\"\", text: $password)\n                .textContentType(.password)\n        }\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-AdvancedSwiftUITextFieldEventsFocusKeyboard_1.png\" /\u003e\n\n이메일 주소를 입력할 때 연락처 및 이메일에서 비슷한 이메일 주소를 제안하는 코드입니다:\n\n```js\nstruct KeyboardTypeDemo: View {\n    @State var email = \"\"\n    var body: some View {\n        Form {\n            TextField(\"\", text: $email)\n                .textContentType(.emailAddress)\n        }\n    }\n}\n```\n\n\u003cimg src=\"/assets/img/2024-06-23-AdvancedSwiftUITextFieldEventsFocusKeyboard_2.png\" /\u003e\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음은 설정할 수 있는 여러 종류의 UITextContentType이 있습니다. 흔히 사용되는 것들 중 일부는 다음과 같습니다:\n\n- password\n- 이름 옵션, 예를 들어 name, givenName, middleName 등이 있습니다.\n- 주소 옵션, 예를 듀 addressCity, fullStreetAddress, postalCode 등이 있습니다.\n- telephoneNumber\n- emailAddress\n- oneTimeCode (인증 코드)\n\n# 키보드 해제\n\n일부 경우에는 사용자가 텍스트 입력을 완료한 후 소프트웨어 키보드를 해제하여 더 많은 디스플레이 공간을 확보해야 할 수 있습니다. 일부 키보드 유형에는 \"return\" 버튼이 없기 때문에 프로그래밍을 사용하여 키보드를 사라지게 해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n또한 가끔은 사용자가 \"return\" 버튼을 클릭하지 않고도 화면의 다른 영역을 클릭하거나 목록을 스크롤하여 키보드를 숨길 수 있게 하려고 할 수도 있습니다. 상호 작용 경험을 향상시키기 위해 프로그래밍을 사용하여 키보드를 사라지게 할 필요가 있습니다.\n\n- FocusState를 사용하여 키보드 숨기기\n\n해당 FocusState가 TextField에 설정되면 값을 \"false\" 또는 \"nil\"로 설정하여 키보드를 숨길 수 있습니다.\n\n```js\nstruct HideKeyboardView: View {\n    @State private var name = \"\"\n    @FocusState private var nameIsFocused: Bool\n\n    var body: some View {\n        Form {\n            TextField(\"이름을 입력하세요\", text: $name)\n                .focused($nameIsFocused)\n            Button(\"키보드 숨기기\") {\n                nameIsFocused = false\n            }\n        }\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 기타 상황\n\n대부분의 경우, 우리는 UIkit에서 제공하는 메서드를 직접 사용하여 키보드를 숨길 수 있습니다.\n\n```js\nUIApplication.shared.sendAction(#selector(UIResponder.resignFirstResponder), to: nil, from: nil, for: nil)\n```\n\n예를 들어, 사용자가 뷰를 드래그할 때 키보드를 숨기는 다음 코드가 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n구조 ResignKeyboardOnDragGesture: ViewModifier {\n    var gesture = DragGesture().onChanged { _ in\n        UIApplication.shared.sendAction(#selector(UIResponder.resignFirstResponder), to: nil, from: nil, for: nil)\n    }\n\n    func body(content: Content) -\u003e some View {\n        content.gesture(gesture)\n    }\n}\nextension View {\n    func dismissKeyboard() -\u003e some View {\n        return modifier(ResignKeyboardOnDragGesture())\n    }\n}\n구조 HideKeyboardView: View {\n    @State private var name = \"\"\n    var body: some View {\n        Form {\n            TextField(\"이름을 입력하세요\", text: $name)\n        }\n        .dismissKeyboard()\n    }\n}\n```\n\n# 키보드 어시스턴트 뷰\n\n# 툴바를 통해 생성됨\n\nSwiftUI 3.0에서는 ToolbarItem(placement: .keyboard, content: View)를 사용하여 키보드 어시스턴트 뷰(inputAccessoryView)를 생성할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n입력 보조 뷰를 통해 이전에 처리하기 어려웠던 많은 문제들을 해결하고 상호 작용 수단을 더 많이 제공할 수 있습니다.\n\n다음 코드는 소수점 숫자를 입력할 때 양/음수 변환 및 확인 버튼을 추가합니다:\n\n```js\nimport Introspect\nstruct ToolbarKeyboardDemo: View {\n    @State var price = \"\"\n    var body: some View {\n        Form {\n            TextField(\"가격:\", text: $price)\n                .keyboardType(.decimalPad)\n                .toolbar {\n                    ToolbarItem(placement: .keyboard) {\n                        HStack {\n                            Button(\"-/+\") {\n                                if price.hasPrefix(\"-\") {\n                                    price.removeFirst()\n                                } else {\n                                    price = \"-\" + price\n                                }\n                            }\n                            .buttonStyle(.bordered)\n                            Spacer()\n                            Button(\"완료\") {\n                                UIApplication.shared.sendAction(#selector(UIResponder.resignFirstResponder), to: nil, from: nil, for: nil)\n                                // 해야 할 일을 수행합니다\n                            }\n                            .buttonStyle(.bordered)\n                        }\n                        .padding(.horizontal, 30)\n                    }\n                }\n        }\n    }\n}\n```\n\n\u003cimg src=\"/assets/img/2024-06-23-AdvancedSwiftUITextFieldEventsFocusKeyboard_3.png\" /\u003e\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n안타깝지만, ToolbarItem을 통해 입력 보조 뷰를 설정하는 데는 아직 몇 가지 제한 사항이 있습니다:\n\n- 표시 콘텐츠 제한\n\n높이가 고정되어 있어 악세서리 뷰의 전체 디스플레이 영역을 활용할 수 없습니다. 다른 종류의 툴바와 마찬가지로 SwiftUI가 콘텐츠의 레이아웃에 개입합니다.\n\n- 같은 뷰 내에서 여러 텍스트 필드에 대해 별도의 액세서리 뷰를 설정할 수 없음\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n보다 복잡한 조건부 구문은 ToolbarItem에서 사용할 수 없습니다. 다른 텍스트 필드에 대해 별도로 설정하더라도 SwiftUI는 모든 내용을 함께 표시하기 위해 병합합니다.\n\n# UIKit을 통해 생성하기\n\n현재 단계에서는 SwiftUI에 대한 키보드 액세서리 뷰를 UIKit을 통해 생성하는 것이 여전히 최적의 솔루션이 됩니다. 화면 표시에 대한 완벽한 제어를 얻을 수 있을 뿐만 아니라 동일한 뷰 내부의 여러 텍스트 필드를 별도로 설정할 수도 있습니다.\n\n```js\nextension UIView {\n    func constrainEdges(to other: UIView) {\n        translatesAutoresizingMaskIntoConstraints = false\n        NSLayoutConstraint.activate([\n            leadingAnchor.constraint(equalTo: other.leadingAnchor),\n            trailingAnchor.constraint(equalTo: other.trailingAnchor),\n            topAnchor.constraint(equalTo: other.topAnchor),\n            bottomAnchor.constraint(equalTo: other.bottomAnchor),\n        ])\n    }\n}\n\nextension View {\n    func inputAccessoryView\u003cContent: View\u003e(@ViewBuilder content: @escaping () -\u003e Content) -\u003e some View {\n        introspectTextField { td in\n            let viewController = UIHostingController(rootView: content())\n            viewController.view.constrainEdges(to: viewController.view)\n            td.inputAccessoryView = viewController.view\n        }\n    }\n    func inputAccessoryView\u003cContent: View\u003e(content: Content) -\u003e some View {\n        introspectTextField { td in\n            let viewController = UIHostingController(rootView: content)\n            viewController.view.constrainEdges(to: viewController.view)\n            td.inputAccessoryView = viewController.view\n        }\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n사용법:\n\n```js\nstruct OnFocusDemo: View {\n    @FocusState var focus: FocusedField?\n    @State var name = \"\"\n    @State var email = \"\"\n    @State var phoneNumber = \"\"\n    var body: some View {\n        Form {\n            TextField(\"이름:\", text: $name)\n                .focused($focus, equals: .name)\n                .inputAccessoryView(content: accessoryView(focus: .name))\n\n            TextField(\"이메일:\", text: $email)\n                .focused($focus, equals: .email)\n                .inputAccessoryView(content: accessoryView(focus: .email))\n\n            TextField(\"전화번호:\", text: $phoneNumber)\n                .focused($focus, equals: .phone)\n        }\n        .onSubmit {\n            switch focus {\n            case .name:\n                focus = .email\n            case .email:\n                focus = .phone\n            case .phone:\n                if !name.isEmpty, !email.isEmpty, !phoneNumber.isEmpty {}\n            default:\n                break\n            }\n        }\n    }\n}\n\nstruct accessoryView: View {\n    let focus: FocusedField?\n    var body: some View {\n        switch focus {\n        case .name:\n            Button(\"이름\") {}.padding(.vertical, 10)\n        case .email:\n            Button(\"이메일\") {}.padding(.vertical, 10)\n        default:\n            EmptyView()\n        }\n    }\n}\n```\n\n# 사용자 정의 제출 레이블\n\n기본적으로 TextField (SecureField)의 키보드에 대한 제출 동작 버튼은 \"return\"입니다. SwiftUI 3.0에서 소개된 \"submitLabel\" 수정자를 사용하면 \"return\" 버튼을 입력 콘텍스트와 관련된 텍스트로 수정할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```swift\nTextField(\"사용자 이름\", text: $username)\n            .submitLabel(.next)\n```\n\n\u003cimg src=\"/assets/img/2024-06-23-AdvancedSwiftUITextFieldEventsFocusKeyboard_4.png\" /\u003e\n\n현재 지원되는 유형은 다음과 같습니다:\n\n- continue\n- done\n- go\n- join\n- next\n- return\n- route\n- search\n- send\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n예를 들어, 이전 코드에서는 이름, 이메일 및 전화번호에 대한 서로 다른 표시를 설정할 수 있습니다:\n\n```js\nTextField(\"이름:\", text: $name)\n                .focused($focus, equals: .name)\n                .submitLabel(.next)\nTextField(\"이메일:\", text: $email)\n                .focused($focus, equals: .email)\n                .submitLabel(.next)\n\nTextField(\"전화번호:\", text: $phoneNumber)\n                .focused($focus, equals: .phone)\n                .submitLabel(.return)\n```\n\n# 결론\n\nSwiftUI 1.0부터 Apple은 TextField의 기능을 지속적으로 개선해 왔습니다. 버전 3.0에서 SwiftUI는 더 많은 네이티브 수정자를 제공하는데 그치지 않고 FocusState와 onSubmit과 같은 통합 관리 논리를 제공합니다. 믿음직스러운 2~3년 뒤에는 SwiftUI의 주요 컨트롤의 네이티브 기능이 해당하는 UIKit 컨트롤과 맞먹을 것이라고 믿습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 이 글이 도움이 되었거나 즐겁게 읽으셨다면, 제 글을 지원하기 위해 기부를 고려해 주세요. 여러분의 기부는 저가 계속해서 가치 있는 콘텐츠를 만드는데 도움이 될 것입니다.\nPatreon, Buy Me a Coffee 또는 PayPal을 통해 기부할 수 있습니다.\n\n```js\n연락하고 싶다면?\n\nTwitter에서 @fatbobman을 팔로우하세요.\n```\n","ogImage":{"url":"/assets/img/2024-06-23-AdvancedSwiftUITextFieldEventsFocusKeyboard_0.png"},"coverImage":"/assets/img/2024-06-23-AdvancedSwiftUITextFieldEventsFocusKeyboard_0.png","tag":["Tech"],"readingTime":36},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e이 글은 SwiftUI TextField 이벤트, 포커스 전환, 키보드 설정 및 기타 관련 경험, 기술 및 고려 사항을 탐색할 것입니다.\u003c/p\u003e\n\u003ch2\u003e이벤트\u003c/h2\u003e\n\u003ch3\u003eonEditingChanged\u003c/h3\u003e\n\u003cp\u003eTextField가 포커스를 얻을 때(편집 가능한 상태로 전환될 때), onEditingChanged는 주어진 메서드를 호출하고 값으로 true를 전달합니다. TextField가 포커스를 잃을 때, 다시 메서드를 호출하고 값을 false로 전달합니다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-swift\"\u003e\u003cspan class=\"hljs-keyword\"\u003estruct\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eOnEditingChangedDemo\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e {\n    \u003cspan class=\"hljs-meta\"\u003e@State\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e name \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e body: \u003cspan class=\"hljs-keyword\"\u003esome\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eView\u003c/span\u003e {\n        \u003cspan class=\"hljs-type\"\u003eList\u003c/span\u003e {\n            \u003cspan class=\"hljs-type\"\u003eTextField\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"이름:\"\u003c/span\u003e, text: \u003cspan class=\"hljs-variable\"\u003e$name\u003c/span\u003e, onEditingChanged: getFocus)\n        }\n    }\n\n    \u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003egetFocus\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003efocused\u003c/span\u003e: \u003cspan class=\"hljs-type\"\u003eBool\u003c/span\u003e) {\n        \u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"포커스 받음: \u003cspan class=\"hljs-subst\"\u003e\\(focused \u003cspan class=\"hljs-operator\"\u003e?\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"참\"\u003c/span\u003e : \u003cspan class=\"hljs-string\"\u003e\"거짓\"\u003c/span\u003e)\u003c/span\u003e\"\u003c/span\u003e)\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 매개변수의 이름은 사용자에게 모호함을 초래하기 쉽습니다. 사용자가 콘텐츠를 입력했는지 확인하는 데 onEditingChanged를 사용하지 마십시오.\u003c/p\u003e\n\u003cp\u003eiOS 15에서는 ParseableFormatStyle을 지원하는 새로 추가된 생성자에서 이 매개변수를 제공하지 않습니다. 따라서 새로운 Formatter를 사용하는 TextFields의 경우, 포커스를 얻었는지 또는 상실했는지를 확인하기 위해 다른 수단을 사용해야 합니다.\u003c/p\u003e\n\u003ch1\u003eonCommit\u003c/h1\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003eonCommit은 사용자가 입력하는 중에 리턴 키를 누를 때 (또는 클릭할 때) 트리거됩니다 (코드 시뮬레이션으로는 트리거할 수 없음). 사용자가 리턴 키를 클릭하지 않으면(예: 직접 다른 TextField로 전환하는 경우) onCommit은 트리거되지 않습니다. onCommit이 트리거되는 동시에 TextField는 포커스를 잃게 됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003estruct \u003cspan class=\"hljs-title class_\"\u003eOnCommitDemo\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e {\n    @\u003cspan class=\"hljs-title class_\"\u003eState\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e name = \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ebody\u003c/span\u003e: some \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e {\n        \u003cspan class=\"hljs-title class_\"\u003eList\u003c/span\u003e {\n            \u003cspan class=\"hljs-title class_\"\u003eTextField\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"이름:\"\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003etext\u003c/span\u003e: $name, \u003cspan class=\"hljs-attr\"\u003eonCommit\u003c/span\u003e: { \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"커밋\"\u003c/span\u003e) })\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e사용자가 입력한 내용을 확인해야 하는 경우, onCommit과 onEditingChanged를 함께 사용하는 것이 좋습니다. 사용자의 입력 데이터를 실시간으로 처리하려면 SwiftUI TextField 고급 — 형식 지정 및 유효성 검사를 참고해주세요.\u003c/p\u003e\n\u003cp\u003eonCommit은 SecureField에도 적용됩니다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003eiOS 15에서 추가된 ParseableFormatStyle을 지원하는 새 생성자는 해당 매개변수를 제공하지 않습니다. 동일한 효과를 얻으려면 새롭게 추가된 onSubmit을 사용할 수 있습니다.\u003c/p\u003e\n\u003ch1\u003eonSubmit\u003c/h1\u003e\n\u003cp\u003eonSubmit은 SwiftUI 3.0에서 새로 추가된 기능입니다. onCommit 및 onEditingChanged는 각각의 TextField의 상태를 설명하지만 onSubmit은 한 뷰 내에서 여러 TextField의 통합 관리 및 일정 관리를 가능하게 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// onSubmit의 정의\u003c/span\u003e\nextension \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e {\n    public func \u003cspan class=\"hljs-title function_\"\u003eonSubmit\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003eof\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etriggers\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eSubmitTriggers\u003c/span\u003e = .\u003cspan class=\"hljs-property\"\u003etext\u003c/span\u003e, _ \u003cspan class=\"hljs-attr\"\u003eaction\u003c/span\u003e: @escaping (() -\u003e \u003cspan class=\"hljs-title class_\"\u003eVoid\u003c/span\u003e)) -\u003e some \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e아래 코드는 onCommit과 동일한 동작을 구현할 것입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003estruct \u003cspan class=\"hljs-title class_\"\u003eOnSubmitDemo\u003c/span\u003e:\u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e{\n    @\u003cspan class=\"hljs-title class_\"\u003eState\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e name = \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ebody\u003c/span\u003e: some \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e{\n        \u003cspan class=\"hljs-title class_\"\u003eList\u003c/span\u003e{\n            \u003cspan class=\"hljs-title class_\"\u003eTextField\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"name:\"\u003c/span\u003e,\u003cspan class=\"hljs-attr\"\u003etext\u003c/span\u003e: $name)\n                .\u003cspan class=\"hljs-property\"\u003eonSubmit\u003c/span\u003e {\n                    \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"commit\"\u003c/span\u003e)\n                }\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eonSubmit의 트리거 조건은 onCommit과 동일하며, 사용자가 “return”을 활성화하도록 요구합니다.\u003c/p\u003e\n\u003cp\u003eonSubmit은 SecureField에도 적용됩니다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003ch1\u003e범위와 중첩\u003c/h1\u003e\n\u003cp\u003eonSubmit의 구현은 환경 값 TriggerSubmitAction을 설정하는 것에 기반하며 (아직 개발자에게 제공되지 않음) onSubmit은 범위를 가지고 있으며 (뷰 트리로 전달될 수 있음) 중첩될 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003estruct \u003cspan class=\"hljs-title class_\"\u003eOnSubmitDemo\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e {\n    @\u003cspan class=\"hljs-title class_\"\u003eState\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e text1 = \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n    @\u003cspan class=\"hljs-title class_\"\u003eState\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e text2 = \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n    @\u003cspan class=\"hljs-title class_\"\u003eState\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e text3 = \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ebody\u003c/span\u003e: some \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e {\n        \u003cspan class=\"hljs-title class_\"\u003eForm\u003c/span\u003e {\n            \u003cspan class=\"hljs-title class_\"\u003eGroup\u003c/span\u003e {\n                \u003cspan class=\"hljs-title class_\"\u003eTextField\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"text1\"\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003etext\u003c/span\u003e: $text1)\n                    .\u003cspan class=\"hljs-property\"\u003eonSubmit\u003c/span\u003e { \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"text1 commit\"\u003c/span\u003e) }\n                \u003cspan class=\"hljs-title class_\"\u003eTextField\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"text2\"\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003etext\u003c/span\u003e: $text2)\n                    .\u003cspan class=\"hljs-property\"\u003eonSubmit\u003c/span\u003e { \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"text2 commit\"\u003c/span\u003e) }\n            }\n            .\u003cspan class=\"hljs-property\"\u003eonSubmit\u003c/span\u003e { \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"textfield in group commit\"\u003c/span\u003e) }\n            \u003cspan class=\"hljs-title class_\"\u003eTextField\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"text3\"\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003etext\u003c/span\u003e: $text3)\n                .\u003cspan class=\"hljs-property\"\u003eonSubmit\u003c/span\u003e { \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"text3 commit\"\u003c/span\u003e) }\n        }\n        .\u003cspan class=\"hljs-property\"\u003eonSubmit\u003c/span\u003e { \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"textfield in form commit1\"\u003c/span\u003e) }\n        .\u003cspan class=\"hljs-property\"\u003eonSubmit\u003c/span\u003e { \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"textfield in form commit2\"\u003c/span\u003e) }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTextField (text1)이 commit되면, 콘솔 출력은 다음과 같습니다:\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e양식에서의 텍스트 필드 커밋\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e\n양식에서의 텍스트 필드 커밋\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n그룹에서의 텍스트 필드 커밋\n텍스트\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e 커밋\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e외부에서 내부로 호출 순서임을 참고하십시오.\u003c/p\u003e\n\u003ch1\u003e제한된 범위\u003c/h1\u003e\n\u003cp\u003esubmitScope를 사용하여 범위를 차단하고 (뷰 트리 상에서의 추가 전파를 제한합니다). 예를 들어, 위 코드에서는 그룹 뒤에 submitScope를 추가하십시오.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e그룹 {\n    \u003cspan class=\"hljs-title class_\"\u003eTextField\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"text1\"\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003etext\u003c/span\u003e: $text1)\n        .\u003cspan class=\"hljs-property\"\u003eonSubmit\u003c/span\u003e { \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"text1 commit\"\u003c/span\u003e) }\n    \u003cspan class=\"hljs-title class_\"\u003eTextField\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"text2\"\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003etext\u003c/span\u003e: $text2)\n        .\u003cspan class=\"hljs-property\"\u003eonSubmit\u003c/span\u003e { \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"text2 commit\"\u003c/span\u003e) }\n}\n.\u003cspan class=\"hljs-title function_\"\u003esubmitScope\u003c/span\u003e()  \u003cspan class=\"hljs-comment\"\u003e// scope blocking\u003c/span\u003e\n.\u003cspan class=\"hljs-property\"\u003eonSubmit\u003c/span\u003e { \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"textfield in group commit\"\u003c/span\u003e) }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTextField1이 커밋되면 콘솔에 다음이 표시됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003etext1 commit\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 시점에서 onSubmit의 범위는 그룹 내로 제한됩니다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e뷰에 여러 개의 TextFields가 있는 경우, onSubmit과 FocusState를 결합하여 훌륭한 사용자 경험을 얻을 수 있습니다.\u003c/p\u003e\n\u003ch1\u003esearchable 지원\u003c/h1\u003e\n\u003cp\u003eiOS 15에서는 새로운 검색 상자도 \"return\"을 클릭할 때 onSubmit을 트리거하지만, 트리거를 검색으로 설정해야 합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003estruct \u003cspan class=\"hljs-title class_\"\u003eOnSubmitForSearchableDemo\u003c/span\u003e:\u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e{\n    @\u003cspan class=\"hljs-title class_\"\u003eState\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e name = \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n    @\u003cspan class=\"hljs-title class_\"\u003eState\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e searchText = \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ebody\u003c/span\u003e: some \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e{\n        \u003cspan class=\"hljs-title class_\"\u003eNavigationView\u003c/span\u003e{\n            \u003cspan class=\"hljs-title class_\"\u003eForm\u003c/span\u003e{\n                \u003cspan class=\"hljs-title class_\"\u003eTextField\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"이름:\"\u003c/span\u003e,\u003cspan class=\"hljs-attr\"\u003etext\u003c/span\u003e:$name)\n                    .\u003cspan class=\"hljs-property\"\u003eonSubmit\u003c/span\u003e {\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"textField 커밋\"\u003c/span\u003e)}\n            }\n            .\u003cspan class=\"hljs-title function_\"\u003esearchable\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003etext\u003c/span\u003e: $searchText)\n            .\u003cspan class=\"hljs-title function_\"\u003eonSubmit\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-keyword\"\u003eof\u003c/span\u003e: .search\u003c/span\u003e) { \u003cspan class=\"hljs-comment\"\u003e//\u003c/span\u003e\n                \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"searchField 커밋\"\u003c/span\u003e)\n            }\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003eSubmitTriggers의 타입은 OptionSet입니다. onSubmit 메서드는 환경 내에서 뷰 트리에서 SubmitTriggers에 포함된 값을 계속 전달합니다. onSubmit에서 받는 SubmitTriggers 값이 onSubmit에서 지정된 SubmitTriggers 세트에 포함되지 않으면 전달이 종료됩니다. 간단히 말해, onSubmit(of:.search)은 TextField에서 생성된 커밋 상태를 차단하고 그 반대도 마찬가지입니다.\u003c/p\u003e\n\u003cp\u003e예를 들어, 위 코드에서 searchable 다음에 onSubmt(of:.text)를 추가하면 TextField의 커밋 이벤트에 응답할 수 없게 됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e.\u003cspan class=\"hljs-title function_\"\u003esearchable\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003etext\u003c/span\u003e: $searchText)\n            .\u003cspan class=\"hljs-title function_\"\u003eonSubmit\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-keyword\"\u003eof\u003c/span\u003e: .search\u003c/span\u003e) {\n                \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"searchField commit1\"\u003c/span\u003e)\n            }\n            .\u003cspan class=\"hljs-property\"\u003eonSubmit\u003c/span\u003e {\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"textField commit\"\u003c/span\u003e)} \u003cspan class=\"hljs-comment\"\u003e//cannot be triggered, blocked by search\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e따라서 TextField와 검색 상자를 모두 처리할 때 호출 순서에 특별히 주의해야 합니다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e다음 코드는 하나의 onSubmit에서 TextField와 검색 상자를 모두 지원할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e.\u003cspan class=\"hljs-title function_\"\u003eonSubmit\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-keyword\"\u003eof\u003c/span\u003e: [.text, .search]\u003c/span\u003e) {\n  \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"무언가가 제출되었습니다\"\u003c/span\u003e)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다음 코드는 searchable 보다 onSubmit(of:.search)가 먼저 배치되어 있기 때문에 어느 것도 트리거하지 않습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eNavigationView\u003c/span\u003e{\n    \u003cspan class=\"hljs-title class_\"\u003eForm\u003c/span\u003e{\n        \u003cspan class=\"hljs-title class_\"\u003eTextField\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"이름:\"\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003etext\u003c/span\u003e: $name)\n            .\u003cspan class=\"hljs-property\"\u003eonSubmit\u003c/span\u003e {\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"textField 제출\"\u003c/span\u003e)}\n    }\n    .\u003cspan class=\"hljs-title function_\"\u003eonSubmit\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-keyword\"\u003eof\u003c/span\u003e: .search\u003c/span\u003e) { \u003cspan class=\"hljs-comment\"\u003e// 트리거 안 됨\u003c/span\u003e\n        \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"searchField 제출1\"\u003c/span\u003e)\n    }\n    .\u003cspan class=\"hljs-title function_\"\u003esearchable\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003etext\u003c/span\u003e: $searchText)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003ch1\u003e초점\u003c/h1\u003e\n\u003cp\u003eiOS 15(몬테레이) 이전에는 SwiftUI에서 TextField(예 : becomeFirstResponder)에 초점을 맞추는 방법을 제공하지 않았습니다. 오랫동안 개발자들은 비슈위 방법에 의존하여 비슷한 기능을 구현해야 했습니다.\u003c/p\u003e\n\u003cp\u003eSwiftUI 3.0에서 Apple은 개발자들에게 onSubmit과 유사한, 높은 수준의 뷰 계층 구조에서 텍스트 필드의 초점을 일관되게 결정하고 관리할 수 있는 예상보다 훨씬 더 나은 솔루션을 제공했습니다.\u003c/p\u003e\n\u003ch1\u003e기본 사용법\u003c/h1\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003eSwiftUI에서는 새 FocusState 프로퍼티 래퍼를 제공하여이 뷰 내의 TextField에 포커스가 있는지 여부를 결정하는 데 도움을 줍니다. focused를 사용하여 FocusState를 특정 TextField와 연결할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-swift\"\u003e\u003cspan class=\"hljs-keyword\"\u003estruct\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eOnFocusDemo\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e {\n    \u003cspan class=\"hljs-meta\"\u003e@FocusState\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e isNameFocused: \u003cspan class=\"hljs-type\"\u003eBool\u003c/span\u003e\n    \u003cspan class=\"hljs-meta\"\u003e@State\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e name \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e body: \u003cspan class=\"hljs-keyword\"\u003esome\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eView\u003c/span\u003e {\n        \u003cspan class=\"hljs-type\"\u003eList\u003c/span\u003e {\n            \u003cspan class=\"hljs-type\"\u003eTextField\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"이름:\"\u003c/span\u003e, text: \u003cspan class=\"hljs-variable\"\u003e$name\u003c/span\u003e)\n                .focused(\u003cspan class=\"hljs-variable\"\u003e$isNameFocused\u003c/span\u003e)\n        }\n        .onChange(of: isNameFocused) { value \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e\n            \u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(value)\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 코드는 TextField가 포커스를 얻을 때 isNameFocused를 true로 설정하고 포커스를 잃을 때 false로 설정합니다.\u003c/p\u003e\n\u003cp\u003e동일한 뷰 내에 여러 개의 TextField가있는 경우 각 해당 TextField와 연결할 여러 FocusStates를 생성할 수 있습니다. 예를 들어:\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e위의 방법은 뷰에 더 많은 TextField가 있는 경우 귀찮아지고 통일된 관리에 도움이 되지 않습니다. 다행히 FocusState는 Boolean 값뿐만 아니라 모든 해시 타입도 지원합니다. Hashable 프로토콜을 준수하는 enum을 사용하여 뷰 내 여러 TextField의 포커스를 관리할 수 있습니다. 다음 코드는 위의 코드와 동일한 기능을 수행합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003estruct \u003cspan class=\"hljs-title class_\"\u003eOnFocusDemo\u003c/span\u003e:\u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e{\n    @\u003cspan class=\"hljs-title class_\"\u003eFocusState\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003efocus\u003c/span\u003e:\u003cspan class=\"hljs-title class_\"\u003eFocusedField\u003c/span\u003e?\n    @\u003cspan class=\"hljs-title class_\"\u003eState\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e name = \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n    @\u003cspan class=\"hljs-title class_\"\u003eState\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e password = \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ebody\u003c/span\u003e: some \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e{\n        \u003cspan class=\"hljs-title class_\"\u003eList\u003c/span\u003e{\n            \u003cspan class=\"hljs-title class_\"\u003eTextField\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"name:\"\u003c/span\u003e,\u003cspan class=\"hljs-attr\"\u003etext\u003c/span\u003e:$name)\n                .\u003cspan class=\"hljs-title function_\"\u003efocused\u003c/span\u003e($focus, \u003cspan class=\"hljs-attr\"\u003eequals\u003c/span\u003e: .\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e)\n            \u003cspan class=\"hljs-title class_\"\u003eSecureField\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"password:\"\u003c/span\u003e,\u003cspan class=\"hljs-attr\"\u003etext\u003c/span\u003e:$password)\n                .\u003cspan class=\"hljs-title function_\"\u003efocused\u003c/span\u003e($focus,\u003cspan class=\"hljs-attr\"\u003eequals\u003c/span\u003e: .\u003cspan class=\"hljs-property\"\u003epassword\u003c/span\u003e)\n        }\n        .\u003cspan class=\"hljs-title function_\"\u003eonChange\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eof\u003c/span\u003e: focus, \u003cspan class=\"hljs-attr\"\u003eperform\u003c/span\u003e: {\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e($0)})\n    }\n\n    enum \u003cspan class=\"hljs-title class_\"\u003eFocusedField\u003c/span\u003e:\u003cspan class=\"hljs-title class_\"\u003eHashable\u003c/span\u003e{\n        \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e name,password\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e특정 TextField가 뷰를 표시한 직후에 즉시 포커스를 받도록 만들기\u003c/h1\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003eFocusState를 사용하면 지정된 TextField가 포커스를 얻고 뷰를 표시한 후 즉시 키보드가 팝업되게 할 수 있어요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003estruct \u003cspan class=\"hljs-title class_\"\u003eOnFocusDemo\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e {\n    @\u003cspan class=\"hljs-title class_\"\u003eFocusState\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003efocus\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eFocusedField\u003c/span\u003e?\n    @\u003cspan class=\"hljs-title class_\"\u003eState\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e name = \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n    @\u003cspan class=\"hljs-title class_\"\u003eState\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e password = \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ebody\u003c/span\u003e: some \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e {\n        \u003cspan class=\"hljs-title class_\"\u003eList\u003c/span\u003e {\n            \u003cspan class=\"hljs-title class_\"\u003eTextField\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"이름:\"\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003etext\u003c/span\u003e: $name)\n                .\u003cspan class=\"hljs-title function_\"\u003efocused\u003c/span\u003e($focus, \u003cspan class=\"hljs-attr\"\u003eequals\u003c/span\u003e: .\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e)\n            \u003cspan class=\"hljs-title class_\"\u003eSecureField\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"비밀번호:\"\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003etext\u003c/span\u003e: $password)\n                .\u003cspan class=\"hljs-title function_\"\u003efocused\u003c/span\u003e($focus, \u003cspan class=\"hljs-attr\"\u003eequals\u003c/span\u003e: .\u003cspan class=\"hljs-property\"\u003epassword\u003c/span\u003e)\n        }\n        .\u003cspan class=\"hljs-property\"\u003eonAppear\u003c/span\u003e {\n            \u003cspan class=\"hljs-title class_\"\u003eDispatchQueue\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003emain\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003easyncAfter\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003edeadline: .now() + \u003cspan class=\"hljs-number\"\u003e0.5\u003c/span\u003e\u003c/span\u003e) {\n                focus = .\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e\n            }\n        }\n    }\n\n    enum \u003cspan class=\"hljs-title class_\"\u003eFocusedField\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eHashable\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e name, password\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e뷰 초기화 중에 값을 할당하는 것은 잘못된 방법이에요. onAppear에서도 TextField가 포커스를 얻을 시간을 지연시켜야 해요 (iOS 16에서는 지연이 필요하지 않아요).\u003c/p\u003e\n\u003ch1\u003e여러 개의 TextField 사이에서 포커스 전환하기\u003c/h1\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e주의력과 onSubmit을 결합하여 한 TextField에서 입력을 완료하고(리턴을 클릭할 때) 자동으로 다음 TextField로 포커스를 전환하는 효과를 얻을 수 있어요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003estruct \u003cspan class=\"hljs-title class_\"\u003eOnFocusDemo\u003c/span\u003e:\u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e{\n    @\u003cspan class=\"hljs-title class_\"\u003eFocusState\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003efocus\u003c/span\u003e:\u003cspan class=\"hljs-title class_\"\u003eFocusedField\u003c/span\u003e?\n    @\u003cspan class=\"hljs-title class_\"\u003eState\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e name = \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n    @\u003cspan class=\"hljs-title class_\"\u003eState\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e email = \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n    @\u003cspan class=\"hljs-title class_\"\u003eState\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e phoneNumber = \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ebody\u003c/span\u003e: some \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e{\n        \u003cspan class=\"hljs-title class_\"\u003eList\u003c/span\u003e{\n            \u003cspan class=\"hljs-title class_\"\u003eTextField\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"이름:\"\u003c/span\u003e,\u003cspan class=\"hljs-attr\"\u003etext\u003c/span\u003e:$name)\n                .\u003cspan class=\"hljs-title function_\"\u003efocused\u003c/span\u003e($focus, \u003cspan class=\"hljs-attr\"\u003eequals\u003c/span\u003e: .\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e)\n                .\u003cspan class=\"hljs-property\"\u003eonSubmit\u003c/span\u003e {\n                    focus = .\u003cspan class=\"hljs-property\"\u003eemail\u003c/span\u003e\n                }\n            \u003cspan class=\"hljs-title class_\"\u003eTextField\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"이메일:\"\u003c/span\u003e,\u003cspan class=\"hljs-attr\"\u003etext\u003c/span\u003e:$email)\n                .\u003cspan class=\"hljs-title function_\"\u003efocused\u003c/span\u003e($focus,\u003cspan class=\"hljs-attr\"\u003eequals\u003c/span\u003e: .\u003cspan class=\"hljs-property\"\u003eemail\u003c/span\u003e)\n                .\u003cspan class=\"hljs-property\"\u003eonSubmit\u003c/span\u003e {\n                    focus = .\u003cspan class=\"hljs-property\"\u003ephone\u003c/span\u003e\n                }\n            \u003cspan class=\"hljs-title class_\"\u003eTextField\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"전화번호:\"\u003c/span\u003e,\u003cspan class=\"hljs-attr\"\u003etext\u003c/span\u003e:$phoneNumber)\n                .\u003cspan class=\"hljs-title function_\"\u003efocused\u003c/span\u003e($focus, \u003cspan class=\"hljs-attr\"\u003eequals\u003c/span\u003e: .\u003cspan class=\"hljs-property\"\u003ephone\u003c/span\u003e)\n                .\u003cspan class=\"hljs-property\"\u003eonSubmit\u003c/span\u003e {\n                    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e !name.\u003cspan class=\"hljs-property\"\u003eisEmpty\u003c/span\u003e \u0026#x26;\u0026#x26; !email.\u003cspan class=\"hljs-property\"\u003eisEmpty\u003c/span\u003e \u0026#x26;\u0026#x26; !phoneNumber.\u003cspan class=\"hljs-property\"\u003eisEmpty\u003c/span\u003e {\n                        \u003cspan class=\"hljs-title function_\"\u003esubmit\u003c/span\u003e()\n                    }\n                }\n        }\n    }\n\n    private func \u003cspan class=\"hljs-title function_\"\u003esubmit\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e){\n        \u003cspan class=\"hljs-comment\"\u003e// 모든 정보 제출\u003c/span\u003e\n        \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"제출\"\u003c/span\u003e)\n    }\n    enum \u003cspan class=\"hljs-title class_\"\u003eFocusedField\u003c/span\u003e:\u003cspan class=\"hljs-title class_\"\u003eHashable\u003c/span\u003e{\n        \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e name,email,phone\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위의 코드는 onSubmit 전달 기능을 활용하여 다음과 같이 변환될 수도 있어요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eList\u003c/span\u003e {\n    \u003cspan class=\"hljs-title class_\"\u003eTextField\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"이름:\"\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003etext\u003c/span\u003e: $name)\n        .\u003cspan class=\"hljs-title function_\"\u003efocused\u003c/span\u003e($focus, \u003cspan class=\"hljs-attr\"\u003eequals\u003c/span\u003e: .\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e)\n    \u003cspan class=\"hljs-title class_\"\u003eTextField\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"이메일:\"\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003etext\u003c/span\u003e: $email)\n        .\u003cspan class=\"hljs-title function_\"\u003efocused\u003c/span\u003e($focus, \u003cspan class=\"hljs-attr\"\u003eequals\u003c/span\u003e: .\u003cspan class=\"hljs-property\"\u003eemail\u003c/span\u003e)\n    \u003cspan class=\"hljs-title class_\"\u003eTextField\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"전화번호:\"\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003etext\u003c/span\u003e: $phoneNumber)\n        .\u003cspan class=\"hljs-title function_\"\u003efocused\u003c/span\u003e($focus, \u003cspan class=\"hljs-attr\"\u003eequals\u003c/span\u003e: .\u003cspan class=\"hljs-property\"\u003ephone\u003c/span\u003e)\n}\n.\u003cspan class=\"hljs-property\"\u003eonSubmit\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003eswitch\u003c/span\u003e focus {\n    \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e .\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e:\n        focus = .\u003cspan class=\"hljs-property\"\u003eemail\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e .\u003cspan class=\"hljs-property\"\u003eemail\u003c/span\u003e:\n        focus = .\u003cspan class=\"hljs-property\"\u003ephone\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e .\u003cspan class=\"hljs-property\"\u003ephone\u003c/span\u003e:\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e !name.\u003cspan class=\"hljs-property\"\u003eisEmpty\u003c/span\u003e, !email.\u003cspan class=\"hljs-property\"\u003eisEmpty\u003c/span\u003e, !phoneNumber.\u003cspan class=\"hljs-property\"\u003eisEmpty\u003c/span\u003e {\n            \u003cspan class=\"hljs-title function_\"\u003esubmit\u003c/span\u003e()\n        }\n    \u003cspan class=\"hljs-attr\"\u003edefault\u003c/span\u003e:\n        \u003cspan class=\"hljs-keyword\"\u003ebreak\u003c/span\u003e\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e화면 버튼(예: 보조 키보드 보기) 또는 키보드 단축키를 결합하여 포커스를 전환하거나 특정 TextField로 이동할 수도 있습니다.\u003c/p\u003e\n\u003ch1\u003e포커스를 얻기 위한 키보드 단축키 사용\u003c/h1\u003e\n\u003cp\u003e보안 필드를 포함한 여러 개의 TextField가 있는 뷰에서는 Tab 키를 사용하여 TextField에서 포커스를 직접 전환할 수 있습니다. 그러나 SwiftUI는 키보드 단축키를 사용하여 특정 TextField에 포커스를 설정하는 기능을 직접 제공하지 않습니다. FocusState와 keyboardShortcut을 결합하여 iPad 및 MacOS에서 이 기능을 얻을 수 있습니다.\u003c/p\u003e\n\u003cp\u003e키보드 단축키 바인딩을 지원하는 focused를 생성하세요:\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-swift\"\u003e\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextension\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efocused\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003e_\u003c/span\u003e \u003cspan class=\"hljs-params\"\u003econdition\u003c/span\u003e: \u003cspan class=\"hljs-type\"\u003eFocusState\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-type\"\u003eBool\u003c/span\u003e\u003e.\u003cspan class=\"hljs-type\"\u003eBinding\u003c/span\u003e, \u003cspan class=\"hljs-params\"\u003ekey\u003c/span\u003e: \u003cspan class=\"hljs-type\"\u003eKeyEquivalent\u003c/span\u003e, \u003cspan class=\"hljs-params\"\u003emodifiers\u003c/span\u003e: \u003cspan class=\"hljs-type\"\u003eEventModifiers\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e .command) -\u003e \u003cspan class=\"hljs-keyword\"\u003esome\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eView\u003c/span\u003e {\n        focused(condition)\n            .background(\u003cspan class=\"hljs-type\"\u003eButton\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e) {\n                condition.wrappedValue \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e\n            }\n            .keyboardShortcut(key, modifiers: modifiers)\n            .hidden()\n            )\n    }\n\n    \u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efocused\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-type\"\u003eValue\u003c/span\u003e\u003e(\u003cspan class=\"hljs-keyword\"\u003e_\u003c/span\u003e \u003cspan class=\"hljs-params\"\u003ebinding\u003c/span\u003e: \u003cspan class=\"hljs-type\"\u003eFocusState\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-type\"\u003eValue\u003c/span\u003e\u003e.\u003cspan class=\"hljs-type\"\u003eBinding\u003c/span\u003e, \u003cspan class=\"hljs-params\"\u003eequals\u003c/span\u003e \u003cspan class=\"hljs-params\"\u003evalue\u003c/span\u003e: \u003cspan class=\"hljs-type\"\u003eValue\u003c/span\u003e, \u003cspan class=\"hljs-params\"\u003ekey\u003c/span\u003e: \u003cspan class=\"hljs-type\"\u003eKeyEquivalent\u003c/span\u003e, \u003cspan class=\"hljs-params\"\u003emodifiers\u003c/span\u003e: \u003cspan class=\"hljs-type\"\u003eEventModifiers\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e .command) -\u003e \u003cspan class=\"hljs-keyword\"\u003esome\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eView\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ewhere\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eValue\u003c/span\u003e: \u003cspan class=\"hljs-type\"\u003eHashable\u003c/span\u003e {\n        focused(binding, equals: value)\n            .background(\u003cspan class=\"hljs-type\"\u003eButton\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e) {\n                binding.wrappedValue \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e value\n            }\n            .keyboardShortcut(key, modifiers: modifiers)\n            .hidden()\n            )\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e코드 사용법:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-swift\"\u003e\u003cspan class=\"hljs-keyword\"\u003estruct\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eShortcutFocusDemo\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e {\n    \u003cspan class=\"hljs-meta\"\u003e@FocusState\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e focus: \u003cspan class=\"hljs-type\"\u003eFouceField\u003c/span\u003e?\n    \u003cspan class=\"hljs-meta\"\u003e@State\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e email \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n    \u003cspan class=\"hljs-meta\"\u003e@State\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e address \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e body: \u003cspan class=\"hljs-keyword\"\u003esome\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eView\u003c/span\u003e {\n        \u003cspan class=\"hljs-type\"\u003eForm\u003c/span\u003e {\n            \u003cspan class=\"hljs-type\"\u003eTextField\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"이메일\"\u003c/span\u003e, text: \u003cspan class=\"hljs-variable\"\u003e$email\u003c/span\u003e)\n                .focused(\u003cspan class=\"hljs-variable\"\u003e$focus\u003c/span\u003e, equals: .email, key: \u003cspan class=\"hljs-string\"\u003e\"t\"\u003c/span\u003e)\n            \u003cspan class=\"hljs-type\"\u003eTextField\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"주소\"\u003c/span\u003e, text: \u003cspan class=\"hljs-variable\"\u003e$address\u003c/span\u003e)\n                .focused(\u003cspan class=\"hljs-variable\"\u003e$focus\u003c/span\u003e, equals: .address, key: \u003cspan class=\"hljs-string\"\u003e\"a\"\u003c/span\u003e, modifiers: [.command, .shift, .option])\n        }\n    }\n\n    \u003cspan class=\"hljs-keyword\"\u003eenum\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFouceField\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eHashable\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e email\n        \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e address\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e사용자가 ⌘ + T를 입력하면 이메일을 처리하는 TextField에 초점이 맞춰집니다. 사용자가 ⌘ + ⌥ + ⇧ + A를 입력하면 주소를 처리하는 TextField에 초점이 맞춰집니다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003ch1\u003e자체 onEditingChanged 만들기\u003c/h1\u003e\n\u003cp\u003e개별 TextField의 포커스 상태를 확인하는 가장 좋은 방법은 여전히 onEditingChanged를 사용하는 것입니다. 그러나 새 포매터와 같이 onEditingChanged를 사용할 수 없는 경우에는 FocusState를 사용하여 비슷한 효과를 얻을 수 있습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e개별 TextField의 포커스 상태 확인\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-swift\"\u003e\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextension\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efocused\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003e_\u003c/span\u003e \u003cspan class=\"hljs-params\"\u003econdition\u003c/span\u003e: \u003cspan class=\"hljs-type\"\u003eFocusState\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-type\"\u003eBool\u003c/span\u003e\u003e.\u003cspan class=\"hljs-type\"\u003eBinding\u003c/span\u003e, \u003cspan class=\"hljs-params\"\u003eonFocus\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003e@escaping\u003c/span\u003e (\u003cspan class=\"hljs-type\"\u003eBool\u003c/span\u003e) -\u003e \u003cspan class=\"hljs-type\"\u003eVoid\u003c/span\u003e) -\u003e \u003cspan class=\"hljs-keyword\"\u003esome\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eView\u003c/span\u003e {\n        focused(condition)\n            .onChange(of: condition.wrappedValue) { value \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e\n                onFocus(value \u003cspan class=\"hljs-operator\"\u003e==\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e)\n            }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e사용 방법:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003estruct \u003cspan class=\"hljs-attr\"\u003eonEditingChangedFocusVersion\u003c/span\u003e:\u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e{\n    @\u003cspan class=\"hljs-title class_\"\u003eFocusState\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003efocus\u003c/span\u003e:\u003cspan class=\"hljs-title class_\"\u003eBool\u003c/span\u003e\n    @\u003cspan class=\"hljs-title class_\"\u003eState\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e price = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ebody\u003c/span\u003e: some \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e{\n        \u003cspan class=\"hljs-title class_\"\u003eForm\u003c/span\u003e{\n            \u003cspan class=\"hljs-title class_\"\u003eTextField\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"가격:\"\u003c/span\u003e,\u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e:$price,\u003cspan class=\"hljs-attr\"\u003eformat\u003c/span\u003e: .\u003cspan class=\"hljs-property\"\u003enumber\u003c/span\u003e)\n                .\u003cspan class=\"hljs-title function_\"\u003efocused\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e$focus\u003c/span\u003e){ focused \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e\n                    \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(focused)\n                }\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e여러 TextFields 확인\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eTextField가 포커스를 잃을 때 여러 번 호출을 피하기 위해 뷰 계층 구조에서 마지막 포커스된 TextField의 FocusState 값을 저장해야 합니다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003epublic extension \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e {\n    func storeLastFocus\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eValue\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eHashable\u003c/span\u003e\u003e(\u003cspan class=\"hljs-attr\"\u003ecurrent\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eFocusState\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eValue\u003c/span\u003e?\u003e.\u003cspan class=\"hljs-property\"\u003eBinding\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003elast\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eBinding\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eValue\u003c/span\u003e?\u003e) -\u003e some \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e {\n        \u003cspan class=\"hljs-title function_\"\u003eonChange\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-keyword\"\u003eof\u003c/span\u003e: current.wrappedValue\u003c/span\u003e) { _ \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e\n            \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e current.\u003cspan class=\"hljs-property\"\u003ewrappedValue\u003c/span\u003e != last.\u003cspan class=\"hljs-property\"\u003ewrappedValue\u003c/span\u003e {\n                last.\u003cspan class=\"hljs-property\"\u003ewrappedValue\u003c/span\u003e = current.\u003cspan class=\"hljs-property\"\u003ewrappedValue\u003c/span\u003e\n            }\n        }\n    }\n\n    func focused\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eValue\u003c/span\u003e\u003e(_ \u003cspan class=\"hljs-attr\"\u003ebinding\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eFocusState\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eValue\u003c/span\u003e\u003e.\u003cspan class=\"hljs-property\"\u003eBinding\u003c/span\u003e, equals \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eValue\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003elast\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eValue\u003c/span\u003e?, \u003cspan class=\"hljs-attr\"\u003eonFocus\u003c/span\u003e: @escaping (\u003cspan class=\"hljs-title class_\"\u003eBool\u003c/span\u003e) -\u003e \u003cspan class=\"hljs-title class_\"\u003eVoid\u003c/span\u003e) -\u003e some \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e where \u003cspan class=\"hljs-title class_\"\u003eValue\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eHashable\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efocused\u003c/span\u003e(binding, \u003cspan class=\"hljs-attr\"\u003eequals\u003c/span\u003e: value)\n            .\u003cspan class=\"hljs-title function_\"\u003eonChange\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-keyword\"\u003eof\u003c/span\u003e: binding.wrappedValue\u003c/span\u003e) { focusValue \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e\n                \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e focusValue == value {\n                    \u003cspan class=\"hljs-title function_\"\u003eonFocus\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e)\n                } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e last == value { \u003cspan class=\"hljs-comment\"\u003e// only call once\u003c/span\u003e\n                    \u003cspan class=\"hljs-title function_\"\u003eonFocus\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e)\n                }\n            }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e호출:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003estruct \u003cspan class=\"hljs-title class_\"\u003eOnFocusView\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e {\n    @\u003cspan class=\"hljs-title class_\"\u003eFocusState\u003c/span\u003e private \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003efocused\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eFocus\u003c/span\u003e?\n    @\u003cspan class=\"hljs-title class_\"\u003eState\u003c/span\u003e private \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003elastFocused\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eFocus\u003c/span\u003e?\n    @\u003cspan class=\"hljs-title class_\"\u003eState\u003c/span\u003e private \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e name = \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n    @\u003cspan class=\"hljs-title class_\"\u003eState\u003c/span\u003e private \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e email = \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n    @\u003cspan class=\"hljs-title class_\"\u003eState\u003c/span\u003e private \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e address = \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ebody\u003c/span\u003e: some \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e {\n        \u003cspan class=\"hljs-title class_\"\u003eList\u003c/span\u003e {\n            \u003cspan class=\"hljs-title class_\"\u003eTextField\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"이름:\"\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003etext\u003c/span\u003e: $name)\n                .\u003cspan class=\"hljs-title function_\"\u003efocused\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e$focused, equals: .name, last: lastFocused\u003c/span\u003e) {\n                    \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"이름:\"\u003c/span\u003e, $0)\n                }\n            \u003cspan class=\"hljs-title class_\"\u003eTextField\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"이메일:\"\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003etext\u003c/span\u003e: $email)\n                .\u003cspan class=\"hljs-title function_\"\u003efocused\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e$focused, equals: .email, last: lastFocused\u003c/span\u003e) {\n                    \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"이메일:\"\u003c/span\u003e, $0)\n                }\n            \u003cspan class=\"hljs-title class_\"\u003eTextField\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"주소:\"\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003etext\u003c/span\u003e: $address)\n                .\u003cspan class=\"hljs-title function_\"\u003efocused\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e$focused, equals: .address, last: lastFocused\u003c/span\u003e) {\n                    \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"주소:\"\u003c/span\u003e, $0)\n                }\n        }\n        .\u003cspan class=\"hljs-title function_\"\u003estoreLastFocus\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003ecurrent\u003c/span\u003e: $focused, \u003cspan class=\"hljs-attr\"\u003elast\u003c/span\u003e: $lastFocused) \u003cspan class=\"hljs-comment\"\u003e// 최신 포커스 값을 저장합니다.\u003c/span\u003e\n    }\n\n    enum \u003cspan class=\"hljs-title class_\"\u003eFocus\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e name, email, address\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e키보드\u003c/h1\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003eTextField를 사용하다보면 소프트웨어 키보드와 함께 작업해야 합니다. 이 섹션에서는 키보드와 관련된 몇 가지 예제를 소개할 것입니다.\u003c/p\u003e\n\u003ch2\u003e키보드 유형\u003c/h2\u003e\n\u003cp\u003eiPhone에서 keyboardType를 통해 소프트웨어 키보드 유형을 설정하여 사용자 입력을 용이하게 하거나 입력 문자 범위를 제한할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e예시:\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-swift\"\u003e\u003cspan class=\"hljs-keyword\"\u003estruct\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eKeyboardTypeDemo\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e {\n    \u003cspan class=\"hljs-meta\"\u003e@State\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e price: \u003cspan class=\"hljs-type\"\u003eDouble\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e body: \u003cspan class=\"hljs-keyword\"\u003esome\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eView\u003c/span\u003e {\n        \u003cspan class=\"hljs-type\"\u003eForm\u003c/span\u003e {\n            \u003cspan class=\"hljs-type\"\u003eTextField\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Price:\"\u003c/span\u003e, value: \u003cspan class=\"hljs-variable\"\u003e$price\u003c/span\u003e, format: .number.precision(.fractionLength(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e)))\n                .keyboardType(.decimalPad) \u003cspan class=\"hljs-comment\"\u003e// 소수점 숫자 키보드 지원\u003c/span\u003e\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 이미지는 \"/assets/img/2024-06-23-AdvancedSwiftUITextFieldEventsFocusKeyboard_0.png\" 입니다.\u003c/p\u003e\n\u003cp\u003e현재, 지원되는 키보드 유형은 총 11가지이며, 다음과 같습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003easciiCapable\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e아래는 번호 및 구두점 테이블입니다.\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003enumbersAndPunctuation\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003eNumbers and punctuation\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eURL 테이블로 아래 내용을 변환해주세요.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003eURL 주소를 입력하는 데 유용하며, 문자 및 '.', '/', '.com'을 포함할 수 있습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003enumberPad\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e해당 지역의 숫자 세트를 사용합니다(0-9, ۰-۹, ०-९ 등). 양의 정수나 PIN에 적합합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ephonePad\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e전화기에서 사용되는 숫자 및 다른 기호, 예를 들면 ‘*#+’\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003enamePhonePad\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e텍스트 및 전화번호 입력에 편리합니다. 문자 상태는 asciiCapable과 유사하며, 숫자 상태는 numberPad와 유사합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eemailAddress\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e'@'를 입력하는 데 편리한 아스키 호환 키보드입니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003edecimalPad\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e소수점이 포함된 숫자 키패드입니다. 자세한 내용은 위의 이미지를 참조해주세요.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e트위터\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e아스키 지원 키보드에는 '@#'이 포함되어 있습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e웹 검색\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e'.'을 포함한 아스키 지원 키보드이며 'return' 키는 'go'로 표시됩니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e아스키 지원 번호 패드\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003eAn asciiCapable 키보드에는 숫자가 포함되어 있습니다.\u003c/p\u003e\n\u003cp\u003eApple은 다양한 키보드 모드를 제공하지만, 경우에 따라 사용자의 요구 사항을 충족시키지 못할 수도 있습니다.\u003c/p\u003e\n\u003cp\u003e예를 들어, numberPad 및 decimalPad에는 \"-\" 및 \"return\"이 없습니다. SwiftUI 3.0 이전에는 주요 뷰에 별도로 그리거나 SwiftUI 이외의 방법을 사용하여 문제를 해결해야 했습니다. 그러나 SwiftUI 3.0에서는 네이티브 설정 키보드 보조 뷰(자세한 내용은 아래에 설명되어 있음) 추가로 위 문제를 해결하는 것이 이제 더 어렵지 않아졌습니다.\u003c/p\u003e\n\u003ch1\u003eTextContentType를 통해 제안을 받아보세요\u003c/h1\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e특정 iOS 앱을 사용할 때 텍스트를 입력할 때 소프트웨어 키보드가 자동으로 입력해야 할 내용을 제안하는 경우가 있습니다. 이는 전화 번호, 이메일, 인증 코드 등을 텍스트ContentType를 통해 얻는 효과입니다.\u003c/p\u003e\n\u003cp\u003eTextField의 UITextContentType을 설정함으로써 시스템은 입력 중에 입력하려는 콘텐츠를 지능적으로 추론하고 제안을 표시합니다.\u003c/p\u003e\n\u003cp\u003e다음 코드는 비밀번호 입력 시 키체인을 사용할 수 있도록 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003estruct \u003cspan class=\"hljs-title class_\"\u003eKeyboardTypeDemo\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e {\n    @\u003cspan class=\"hljs-title class_\"\u003eState\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e password = \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ebody\u003c/span\u003e: some \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e {\n        \u003cspan class=\"hljs-title class_\"\u003eForm\u003c/span\u003e {\n            \u003cspan class=\"hljs-title class_\"\u003eSecureField\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003etext\u003c/span\u003e: $password)\n                .\u003cspan class=\"hljs-title function_\"\u003etextContentType\u003c/span\u003e(.\u003cspan class=\"hljs-property\"\u003epassword\u003c/span\u003e)\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e이메일 주소를 입력할 때 연락처 및 이메일에서 비슷한 이메일 주소를 제안하는 코드입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003estruct \u003cspan class=\"hljs-title class_\"\u003eKeyboardTypeDemo\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e {\n    @\u003cspan class=\"hljs-title class_\"\u003eState\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e email = \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ebody\u003c/span\u003e: some \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e {\n        \u003cspan class=\"hljs-title class_\"\u003eForm\u003c/span\u003e {\n            \u003cspan class=\"hljs-title class_\"\u003eTextField\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003etext\u003c/span\u003e: $email)\n                .\u003cspan class=\"hljs-title function_\"\u003etextContentType\u003c/span\u003e(.\u003cspan class=\"hljs-property\"\u003eemailAddress\u003c/span\u003e)\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e다음은 설정할 수 있는 여러 종류의 UITextContentType이 있습니다. 흔히 사용되는 것들 중 일부는 다음과 같습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003epassword\u003c/li\u003e\n\u003cli\u003e이름 옵션, 예를 들어 name, givenName, middleName 등이 있습니다.\u003c/li\u003e\n\u003cli\u003e주소 옵션, 예를 듀 addressCity, fullStreetAddress, postalCode 등이 있습니다.\u003c/li\u003e\n\u003cli\u003etelephoneNumber\u003c/li\u003e\n\u003cli\u003eemailAddress\u003c/li\u003e\n\u003cli\u003eoneTimeCode (인증 코드)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e키보드 해제\u003c/h1\u003e\n\u003cp\u003e일부 경우에는 사용자가 텍스트 입력을 완료한 후 소프트웨어 키보드를 해제하여 더 많은 디스플레이 공간을 확보해야 할 수 있습니다. 일부 키보드 유형에는 \"return\" 버튼이 없기 때문에 프로그래밍을 사용하여 키보드를 사라지게 해야 합니다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e또한 가끔은 사용자가 \"return\" 버튼을 클릭하지 않고도 화면의 다른 영역을 클릭하거나 목록을 스크롤하여 키보드를 숨길 수 있게 하려고 할 수도 있습니다. 상호 작용 경험을 향상시키기 위해 프로그래밍을 사용하여 키보드를 사라지게 할 필요가 있습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFocusState를 사용하여 키보드 숨기기\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e해당 FocusState가 TextField에 설정되면 값을 \"false\" 또는 \"nil\"로 설정하여 키보드를 숨길 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003estruct \u003cspan class=\"hljs-title class_\"\u003eHideKeyboardView\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e {\n    @\u003cspan class=\"hljs-title class_\"\u003eState\u003c/span\u003e private \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e name = \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n    @\u003cspan class=\"hljs-title class_\"\u003eFocusState\u003c/span\u003e private \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003enameIsFocused\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eBool\u003c/span\u003e\n\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ebody\u003c/span\u003e: some \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e {\n        \u003cspan class=\"hljs-title class_\"\u003eForm\u003c/span\u003e {\n            \u003cspan class=\"hljs-title class_\"\u003eTextField\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"이름을 입력하세요\"\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003etext\u003c/span\u003e: $name)\n                .\u003cspan class=\"hljs-title function_\"\u003efocused\u003c/span\u003e($nameIsFocused)\n            \u003cspan class=\"hljs-title class_\"\u003eButton\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"키보드 숨기기\"\u003c/span\u003e) {\n                nameIsFocused = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e\n            }\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e기타 상황\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e대부분의 경우, 우리는 UIkit에서 제공하는 메서드를 직접 사용하여 키보드를 숨길 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eUIApplication\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eshared\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003esendAction\u003c/span\u003e(#\u003cspan class=\"hljs-title function_\"\u003eselector\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eUIResponder\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eresignFirstResponder\u003c/span\u003e), \u003cspan class=\"hljs-attr\"\u003eto\u003c/span\u003e: nil, \u003cspan class=\"hljs-attr\"\u003efrom\u003c/span\u003e: nil, \u003cspan class=\"hljs-attr\"\u003efor\u003c/span\u003e: nil)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e예를 들어, 사용자가 뷰를 드래그할 때 키보드를 숨기는 다음 코드가 있습니다:\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e구조 \u003cspan class=\"hljs-title class_\"\u003eResignKeyboardOnDragGesture\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eViewModifier\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e gesture = \u003cspan class=\"hljs-title class_\"\u003eDragGesture\u003c/span\u003e().\u003cspan class=\"hljs-property\"\u003eonChanged\u003c/span\u003e { _ \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e\n        \u003cspan class=\"hljs-title class_\"\u003eUIApplication\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eshared\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003esendAction\u003c/span\u003e(#\u003cspan class=\"hljs-title function_\"\u003eselector\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eUIResponder\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eresignFirstResponder\u003c/span\u003e), \u003cspan class=\"hljs-attr\"\u003eto\u003c/span\u003e: nil, \u003cspan class=\"hljs-attr\"\u003efrom\u003c/span\u003e: nil, \u003cspan class=\"hljs-attr\"\u003efor\u003c/span\u003e: nil)\n    }\n\n    func \u003cspan class=\"hljs-title function_\"\u003ebody\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003econtent\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eContent\u003c/span\u003e) -\u003e some \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e {\n        content.\u003cspan class=\"hljs-title function_\"\u003egesture\u003c/span\u003e(gesture)\n    }\n}\nextension \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e {\n    func \u003cspan class=\"hljs-title function_\"\u003edismissKeyboard\u003c/span\u003e() -\u003e some \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emodifier\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eResignKeyboardOnDragGesture\u003c/span\u003e())\n    }\n}\n구조 \u003cspan class=\"hljs-title class_\"\u003eHideKeyboardView\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e {\n    @\u003cspan class=\"hljs-title class_\"\u003eState\u003c/span\u003e private \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e name = \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ebody\u003c/span\u003e: some \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e {\n        \u003cspan class=\"hljs-title class_\"\u003eForm\u003c/span\u003e {\n            \u003cspan class=\"hljs-title class_\"\u003eTextField\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"이름을 입력하세요\"\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003etext\u003c/span\u003e: $name)\n        }\n        .\u003cspan class=\"hljs-title function_\"\u003edismissKeyboard\u003c/span\u003e()\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e키보드 어시스턴트 뷰\u003c/h1\u003e\n\u003ch1\u003e툴바를 통해 생성됨\u003c/h1\u003e\n\u003cp\u003eSwiftUI 3.0에서는 ToolbarItem(placement: .keyboard, content: View)를 사용하여 키보드 어시스턴트 뷰(inputAccessoryView)를 생성할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e입력 보조 뷰를 통해 이전에 처리하기 어려웠던 많은 문제들을 해결하고 상호 작용 수단을 더 많이 제공할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e다음 코드는 소수점 숫자를 입력할 때 양/음수 변환 및 확인 버튼을 추가합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eIntrospect\u003c/span\u003e\nstruct \u003cspan class=\"hljs-title class_\"\u003eToolbarKeyboardDemo\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e {\n    @\u003cspan class=\"hljs-title class_\"\u003eState\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e price = \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ebody\u003c/span\u003e: some \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e {\n        \u003cspan class=\"hljs-title class_\"\u003eForm\u003c/span\u003e {\n            \u003cspan class=\"hljs-title class_\"\u003eTextField\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"가격:\"\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003etext\u003c/span\u003e: $price)\n                .\u003cspan class=\"hljs-title function_\"\u003ekeyboardType\u003c/span\u003e(.\u003cspan class=\"hljs-property\"\u003edecimalPad\u003c/span\u003e)\n                .\u003cspan class=\"hljs-property\"\u003etoolbar\u003c/span\u003e {\n                    \u003cspan class=\"hljs-title class_\"\u003eToolbarItem\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eplacement\u003c/span\u003e: .\u003cspan class=\"hljs-property\"\u003ekeyboard\u003c/span\u003e) {\n                        \u003cspan class=\"hljs-title class_\"\u003eHStack\u003c/span\u003e {\n                            \u003cspan class=\"hljs-title class_\"\u003eButton\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"-/+\"\u003c/span\u003e) {\n                                \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e price.\u003cspan class=\"hljs-title function_\"\u003ehasPrefix\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-string\"\u003e\"-\"\u003c/span\u003e\u003c/span\u003e) {\n                                    price.\u003cspan class=\"hljs-title function_\"\u003eremoveFirst\u003c/span\u003e()\n                                } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n                                    price = \u003cspan class=\"hljs-string\"\u003e\"-\"\u003c/span\u003e + price\n                                }\n                            }\n                            .\u003cspan class=\"hljs-title function_\"\u003ebuttonStyle\u003c/span\u003e(.\u003cspan class=\"hljs-property\"\u003ebordered\u003c/span\u003e)\n                            \u003cspan class=\"hljs-title class_\"\u003eSpacer\u003c/span\u003e()\n                            \u003cspan class=\"hljs-title class_\"\u003eButton\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"완료\"\u003c/span\u003e) {\n                                \u003cspan class=\"hljs-title class_\"\u003eUIApplication\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eshared\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003esendAction\u003c/span\u003e(#\u003cspan class=\"hljs-title function_\"\u003eselector\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eUIResponder\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eresignFirstResponder\u003c/span\u003e), \u003cspan class=\"hljs-attr\"\u003eto\u003c/span\u003e: nil, \u003cspan class=\"hljs-attr\"\u003efrom\u003c/span\u003e: nil, \u003cspan class=\"hljs-attr\"\u003efor\u003c/span\u003e: nil)\n                                \u003cspan class=\"hljs-comment\"\u003e// 해야 할 일을 수행합니다\u003c/span\u003e\n                            }\n                            .\u003cspan class=\"hljs-title function_\"\u003ebuttonStyle\u003c/span\u003e(.\u003cspan class=\"hljs-property\"\u003ebordered\u003c/span\u003e)\n                        }\n                        .\u003cspan class=\"hljs-title function_\"\u003epadding\u003c/span\u003e(.\u003cspan class=\"hljs-property\"\u003ehorizontal\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e30\u003c/span\u003e)\n                    }\n                }\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e안타깝지만, ToolbarItem을 통해 입력 보조 뷰를 설정하는 데는 아직 몇 가지 제한 사항이 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e표시 콘텐츠 제한\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e높이가 고정되어 있어 악세서리 뷰의 전체 디스플레이 영역을 활용할 수 없습니다. 다른 종류의 툴바와 마찬가지로 SwiftUI가 콘텐츠의 레이아웃에 개입합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e같은 뷰 내에서 여러 텍스트 필드에 대해 별도의 액세서리 뷰를 설정할 수 없음\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e보다 복잡한 조건부 구문은 ToolbarItem에서 사용할 수 없습니다. 다른 텍스트 필드에 대해 별도로 설정하더라도 SwiftUI는 모든 내용을 함께 표시하기 위해 병합합니다.\u003c/p\u003e\n\u003ch1\u003eUIKit을 통해 생성하기\u003c/h1\u003e\n\u003cp\u003e현재 단계에서는 SwiftUI에 대한 키보드 액세서리 뷰를 UIKit을 통해 생성하는 것이 여전히 최적의 솔루션이 됩니다. 화면 표시에 대한 완벽한 제어를 얻을 수 있을 뿐만 아니라 동일한 뷰 내부의 여러 텍스트 필드를 별도로 설정할 수도 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eextension \u003cspan class=\"hljs-title class_\"\u003eUIView\u003c/span\u003e {\n    func \u003cspan class=\"hljs-title function_\"\u003econstrainEdges\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eto other: UIView\u003c/span\u003e) {\n        translatesAutoresizingMaskIntoConstraints = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e\n        \u003cspan class=\"hljs-title class_\"\u003eNSLayoutConstraint\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eactivate\u003c/span\u003e([\n            leadingAnchor.\u003cspan class=\"hljs-title function_\"\u003econstraint\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eequalTo\u003c/span\u003e: other.\u003cspan class=\"hljs-property\"\u003eleadingAnchor\u003c/span\u003e),\n            trailingAnchor.\u003cspan class=\"hljs-title function_\"\u003econstraint\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eequalTo\u003c/span\u003e: other.\u003cspan class=\"hljs-property\"\u003etrailingAnchor\u003c/span\u003e),\n            topAnchor.\u003cspan class=\"hljs-title function_\"\u003econstraint\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eequalTo\u003c/span\u003e: other.\u003cspan class=\"hljs-property\"\u003etopAnchor\u003c/span\u003e),\n            bottomAnchor.\u003cspan class=\"hljs-title function_\"\u003econstraint\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eequalTo\u003c/span\u003e: other.\u003cspan class=\"hljs-property\"\u003ebottomAnchor\u003c/span\u003e),\n        ])\n    }\n}\n\nextension \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e {\n    func inputAccessoryView\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eContent\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e\u003e(@\u003cspan class=\"hljs-title class_\"\u003eViewBuilder\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003econtent\u003c/span\u003e: @escaping () -\u003e \u003cspan class=\"hljs-title class_\"\u003eContent\u003c/span\u003e) -\u003e some \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e {\n        introspectTextField { td \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e\n            \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e viewController = \u003cspan class=\"hljs-title class_\"\u003eUIHostingController\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003erootView\u003c/span\u003e: \u003cspan class=\"hljs-title function_\"\u003econtent\u003c/span\u003e())\n            viewController.\u003cspan class=\"hljs-property\"\u003eview\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003econstrainEdges\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eto\u003c/span\u003e: viewController.\u003cspan class=\"hljs-property\"\u003eview\u003c/span\u003e)\n            td.\u003cspan class=\"hljs-property\"\u003einputAccessoryView\u003c/span\u003e = viewController.\u003cspan class=\"hljs-property\"\u003eview\u003c/span\u003e\n        }\n    }\n    func inputAccessoryView\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eContent\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e\u003e(\u003cspan class=\"hljs-attr\"\u003econtent\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eContent\u003c/span\u003e) -\u003e some \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e {\n        introspectTextField { td \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e\n            \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e viewController = \u003cspan class=\"hljs-title class_\"\u003eUIHostingController\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003erootView\u003c/span\u003e: content)\n            viewController.\u003cspan class=\"hljs-property\"\u003eview\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003econstrainEdges\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eto\u003c/span\u003e: viewController.\u003cspan class=\"hljs-property\"\u003eview\u003c/span\u003e)\n            td.\u003cspan class=\"hljs-property\"\u003einputAccessoryView\u003c/span\u003e = viewController.\u003cspan class=\"hljs-property\"\u003eview\u003c/span\u003e\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e사용법:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003estruct \u003cspan class=\"hljs-title class_\"\u003eOnFocusDemo\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e {\n    @\u003cspan class=\"hljs-title class_\"\u003eFocusState\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003efocus\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eFocusedField\u003c/span\u003e?\n    @\u003cspan class=\"hljs-title class_\"\u003eState\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e name = \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n    @\u003cspan class=\"hljs-title class_\"\u003eState\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e email = \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n    @\u003cspan class=\"hljs-title class_\"\u003eState\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e phoneNumber = \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ebody\u003c/span\u003e: some \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e {\n        \u003cspan class=\"hljs-title class_\"\u003eForm\u003c/span\u003e {\n            \u003cspan class=\"hljs-title class_\"\u003eTextField\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"이름:\"\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003etext\u003c/span\u003e: $name)\n                .\u003cspan class=\"hljs-title function_\"\u003efocused\u003c/span\u003e($focus, \u003cspan class=\"hljs-attr\"\u003eequals\u003c/span\u003e: .\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e)\n                .\u003cspan class=\"hljs-title function_\"\u003einputAccessoryView\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003econtent\u003c/span\u003e: \u003cspan class=\"hljs-title function_\"\u003eaccessoryView\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003efocus\u003c/span\u003e: .\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e))\n\n            \u003cspan class=\"hljs-title class_\"\u003eTextField\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"이메일:\"\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003etext\u003c/span\u003e: $email)\n                .\u003cspan class=\"hljs-title function_\"\u003efocused\u003c/span\u003e($focus, \u003cspan class=\"hljs-attr\"\u003eequals\u003c/span\u003e: .\u003cspan class=\"hljs-property\"\u003eemail\u003c/span\u003e)\n                .\u003cspan class=\"hljs-title function_\"\u003einputAccessoryView\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003econtent\u003c/span\u003e: \u003cspan class=\"hljs-title function_\"\u003eaccessoryView\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003efocus\u003c/span\u003e: .\u003cspan class=\"hljs-property\"\u003eemail\u003c/span\u003e))\n\n            \u003cspan class=\"hljs-title class_\"\u003eTextField\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"전화번호:\"\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003etext\u003c/span\u003e: $phoneNumber)\n                .\u003cspan class=\"hljs-title function_\"\u003efocused\u003c/span\u003e($focus, \u003cspan class=\"hljs-attr\"\u003eequals\u003c/span\u003e: .\u003cspan class=\"hljs-property\"\u003ephone\u003c/span\u003e)\n        }\n        .\u003cspan class=\"hljs-property\"\u003eonSubmit\u003c/span\u003e {\n            \u003cspan class=\"hljs-keyword\"\u003eswitch\u003c/span\u003e focus {\n            \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e .\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e:\n                focus = .\u003cspan class=\"hljs-property\"\u003eemail\u003c/span\u003e\n            \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e .\u003cspan class=\"hljs-property\"\u003eemail\u003c/span\u003e:\n                focus = .\u003cspan class=\"hljs-property\"\u003ephone\u003c/span\u003e\n            \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e .\u003cspan class=\"hljs-property\"\u003ephone\u003c/span\u003e:\n                \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e !name.\u003cspan class=\"hljs-property\"\u003eisEmpty\u003c/span\u003e, !email.\u003cspan class=\"hljs-property\"\u003eisEmpty\u003c/span\u003e, !phoneNumber.\u003cspan class=\"hljs-property\"\u003eisEmpty\u003c/span\u003e {}\n            \u003cspan class=\"hljs-attr\"\u003edefault\u003c/span\u003e:\n                \u003cspan class=\"hljs-keyword\"\u003ebreak\u003c/span\u003e\n            }\n        }\n    }\n}\n\nstruct \u003cspan class=\"hljs-attr\"\u003eaccessoryView\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003efocus\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eFocusedField\u003c/span\u003e?\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ebody\u003c/span\u003e: some \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003eswitch\u003c/span\u003e focus {\n        \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e .\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e:\n            \u003cspan class=\"hljs-title class_\"\u003eButton\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"이름\"\u003c/span\u003e) {}.\u003cspan class=\"hljs-title function_\"\u003epadding\u003c/span\u003e(.\u003cspan class=\"hljs-property\"\u003evertical\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e)\n        \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e .\u003cspan class=\"hljs-property\"\u003eemail\u003c/span\u003e:\n            \u003cspan class=\"hljs-title class_\"\u003eButton\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"이메일\"\u003c/span\u003e) {}.\u003cspan class=\"hljs-title function_\"\u003epadding\u003c/span\u003e(.\u003cspan class=\"hljs-property\"\u003evertical\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e)\n        \u003cspan class=\"hljs-attr\"\u003edefault\u003c/span\u003e:\n            \u003cspan class=\"hljs-title class_\"\u003eEmptyView\u003c/span\u003e()\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e사용자 정의 제출 레이블\u003c/h1\u003e\n\u003cp\u003e기본적으로 TextField (SecureField)의 키보드에 대한 제출 동작 버튼은 \"return\"입니다. SwiftUI 3.0에서 소개된 \"submitLabel\" 수정자를 사용하면 \"return\" 버튼을 입력 콘텍스트와 관련된 텍스트로 수정할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-swift\"\u003e\u003cspan class=\"hljs-type\"\u003eTextField\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"사용자 이름\"\u003c/span\u003e, text: \u003cspan class=\"hljs-variable\"\u003e$username\u003c/span\u003e)\n            .submitLabel(.next)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e현재 지원되는 유형은 다음과 같습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003econtinue\u003c/li\u003e\n\u003cli\u003edone\u003c/li\u003e\n\u003cli\u003ego\u003c/li\u003e\n\u003cli\u003ejoin\u003c/li\u003e\n\u003cli\u003enext\u003c/li\u003e\n\u003cli\u003ereturn\u003c/li\u003e\n\u003cli\u003eroute\u003c/li\u003e\n\u003cli\u003esearch\u003c/li\u003e\n\u003cli\u003esend\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e예를 들어, 이전 코드에서는 이름, 이메일 및 전화번호에 대한 서로 다른 표시를 설정할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eTextField\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"이름:\"\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003etext\u003c/span\u003e: $name)\n                .\u003cspan class=\"hljs-title function_\"\u003efocused\u003c/span\u003e($focus, \u003cspan class=\"hljs-attr\"\u003eequals\u003c/span\u003e: .\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e)\n                .\u003cspan class=\"hljs-title function_\"\u003esubmitLabel\u003c/span\u003e(.\u003cspan class=\"hljs-property\"\u003enext\u003c/span\u003e)\n\u003cspan class=\"hljs-title class_\"\u003eTextField\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"이메일:\"\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003etext\u003c/span\u003e: $email)\n                .\u003cspan class=\"hljs-title function_\"\u003efocused\u003c/span\u003e($focus, \u003cspan class=\"hljs-attr\"\u003eequals\u003c/span\u003e: .\u003cspan class=\"hljs-property\"\u003eemail\u003c/span\u003e)\n                .\u003cspan class=\"hljs-title function_\"\u003esubmitLabel\u003c/span\u003e(.\u003cspan class=\"hljs-property\"\u003enext\u003c/span\u003e)\n\n\u003cspan class=\"hljs-title class_\"\u003eTextField\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"전화번호:\"\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003etext\u003c/span\u003e: $phoneNumber)\n                .\u003cspan class=\"hljs-title function_\"\u003efocused\u003c/span\u003e($focus, \u003cspan class=\"hljs-attr\"\u003eequals\u003c/span\u003e: .\u003cspan class=\"hljs-property\"\u003ephone\u003c/span\u003e)\n                .\u003cspan class=\"hljs-title function_\"\u003esubmitLabel\u003c/span\u003e(.\u003cspan class=\"hljs-property\"\u003ereturn\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003eSwiftUI 1.0부터 Apple은 TextField의 기능을 지속적으로 개선해 왔습니다. 버전 3.0에서 SwiftUI는 더 많은 네이티브 수정자를 제공하는데 그치지 않고 FocusState와 onSubmit과 같은 통합 관리 논리를 제공합니다. 믿음직스러운 2~3년 뒤에는 SwiftUI의 주요 컨트롤의 네이티브 기능이 해당하는 UIKit 컨트롤과 맞먹을 것이라고 믿습니다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e만약 이 글이 도움이 되었거나 즐겁게 읽으셨다면, 제 글을 지원하기 위해 기부를 고려해 주세요. 여러분의 기부는 저가 계속해서 가치 있는 콘텐츠를 만드는데 도움이 될 것입니다.\nPatreon, Buy Me a Coffee 또는 PayPal을 통해 기부할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e연락하고 싶다면?\n\n\u003cspan class=\"hljs-title class_\"\u003eTwitter\u003c/span\u003e에서 @fatbobman을 팔로우하세요.\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-23-AdvancedSwiftUITextFieldEventsFocusKeyboard"},"buildId":"bb_yO9GbCvdfc_n71SfUf","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>