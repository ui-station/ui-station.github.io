<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Redis를 S3 Express로 재구축하기 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-06-19-RebuildingRedisonS3Express" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Redis를 S3 Express로 재구축하기 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="Redis를 S3 Express로 재구축하기 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-19-RebuildingRedisonS3Express_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-06-19-RebuildingRedisonS3Express" data-gatsby-head="true"/><meta name="twitter:title" content="Redis를 S3 Express로 재구축하기 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-19-RebuildingRedisonS3Express_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-19 12:10" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-70e5ce89f3d962ac.js" defer=""></script><script src="/_next/static/T_Nz0g9U1yttYMSEma95P/_buildManifest.js" defer=""></script><script src="/_next/static/T_Nz0g9U1yttYMSEma95P/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Redis를 S3 Express로 재구축하기</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Redis를 S3 Express로 재구축하기" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 19, 2024</span><span class="posts_reading_time__f7YPP">8<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-19-RebuildingRedisonS3Express&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h2>느린, 저렴하고 확장 가능한 키-값 저장소</h2>
<h2>느린-저렴 대 빠른-비싼</h2>
<p>다년간 "최고의 데이터베이스"로 선정된 Redis는 빠르고 신뢰성 있으며 고처리량의 키-값 저장소로 탄생했습니다 (훨씬 더 발전하기 전). 오늘날에도 가장 많이 사용되는 용도는 캐싱입니다 — 사용자를 위해 작고 자주 액세스하는 데이터를 빠르게 저장합니다 (예: 몇 줄의 파이썬 코드로):</p>
<pre><code class="hljs language-js">>>> <span class="hljs-keyword">import</span> redis
>>> r = redis.<span class="hljs-title class_">Redis</span>(host=<span class="hljs-string">'myhost'</span>, port=<span class="hljs-number">6379</span>, db=<span class="hljs-number">0</span>)
>>> r.<span class="hljs-title function_">set</span>(<span class="hljs-string">'userId:10'</span>, <span class="hljs-string">'1701743088'</span>)
<span class="hljs-title class_">True</span>
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>그리고 키 기반 쿼리로 나중에 다시 검색하세요:</p>
<pre><code class="hljs language-js">>>> r.<span class="hljs-title function_">get</span>(<span class="hljs-string">'userId:10'</span>)
<span class="hljs-number">1701743088</span>
</code></pre>
<p>쉽고 빠르죠. Redis의 가치와 비밀은 데이터 전문가들에게 분명히 비밀이 아니며, 비용도 마찬가지입니다. 메모리는 비싸며, 캐시는 클라우드 요금에 빠르게 영향을 줄 수 있습니다. AWS ElasticCache의 25GB(cache.m7g.2xlarge)는 약 500달러 / 월입니다.</p>
<p>다른 한편으로, S3와 같은 객체 저장소는 다른 가격 / 성능 트레이드오프를 약속했습니다. 25GB 저장 비용은 약 0.5달러 / 월이지만, S3 지연 시간(평균 및 테일)은 당신의 응용 프로그램에 심각한 영향을 미칠 수 있습니다. 만약 일관적이고 빠른 작업에 의존하고 있다면요:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>요즘까지는 아니었지만, S3 익스프레스의 공개로 파레토 프런티어에 또 다른 포인트가 추가되었습니다. "익스프레스 저장소 클래스는 최대 10배 더 나은 성능을 제공하기 위해 설계되었으며 (...), 가장 자주 액세스하는 데이터에 탁월한 적합성을 갖추고 있습니다."</p>
<p>이러한 새로운 기능에 매료되어, 우리는 AWS의 신제품을 테스트하기 위해 Redis와 유사한 키-값 워크로드를 완전히 S3로 백업하는 새로운 인터페이스를 재구성해 보았습니다(적절하게 "redis3"라고 합니다). 우리는 이를 프로토타입화하고 테스트하며 오픈소스로 공유했는데, 우리가 배운 것은 이렇습니다: 저장소를 복제하고 스타를 추가하며 함께하세요!</p>
<p><img src="/assets/img/2024-06-19-RebuildingRedisonS3Express_0.png" alt="이미지"></p>
<h2>Redis3: 개발자 시각</h2>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>요즘 데이터 랜드의 모든 사람들이 개발자 경험에 집착하고 있기 때문에, 우리는 redis3를 최종 사용자인 개발자에게 어떻게 보이는지부터 살펴보겠습니다. GET/SET 연산이 실제로 Redis의 핵심 기능이므로, redis-py 명령어를 redis3와 비교하여 시작합니다.</p>
<pre><code class="hljs language-js">>>> <span class="hljs-keyword">from</span> redis3 <span class="hljs-keyword">import</span> redis3Client
>>> r = <span class="hljs-title function_">redis3Client</span>(cache_name=<span class="hljs-string">'mytestcache'</span>, db=<span class="hljs-number">0</span>)
>>> r.<span class="hljs-title function_">set</span>(<span class="hljs-string">'userId:10'</span>, <span class="hljs-string">'1701743088'</span>)
<span class="hljs-title class_">True</span>
>>> r.<span class="hljs-title function_">get</span>(<span class="hljs-string">'userId:10'</span>)
<span class="hljs-number">1701743088</span>
</code></pre>
<p>알 수 있는 독자들은 이미 알고 계실 것이지만, 위 명령어는 기본적으로 동일합니다: URL 및 포트는 클라이언트 초기화에 없지만 (이유는 아래에서 자세히 설명되어 있습니다. 심지어 GET 및 SET에 대해 동일한 간결한 구문과 의미론을 가지고 있습니다.</p>
<p>Redis3에서는 데이터베이스의 모든 키를 나열하거나 Redis에서의 MSET 및 MGET을 모방할 수 있습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js">key_list = [<span class="hljs-string">'playground_{}'</span>.<span class="hljs-title function_">format</span>(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-title function_">range</span>(<span class="hljs-number">5</span>)]
val_list = [<span class="hljs-string">'bar_{}'</span>.<span class="hljs-title function_">format</span>(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-title function_">range</span>(<span class="hljs-number">5</span>)]
r = my_client.<span class="hljs-title function_">mset</span>(key_list, val_list)
val_list_back = my_client.<span class="hljs-title function_">mget</span>(key_list)
assert val_list == val_list_back
</code></pre>
<p>그리고 key를 삭제할 수도 있어요 (DEL):</p>
<pre><code class="hljs language-js">r = my_client.<span class="hljs-title function_">delete</span>(<span class="hljs-string">"userId:10"</span>);
</code></pre>
<p>마지막으로, db 매개변수를 사용하여 키를 자동으로 네임스페이스 할 수 있어요 (물론 16에 제한되지 않아요):</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js">r = <span class="hljs-title function_">redis3Client</span>((cache_name = <span class="hljs-string">"mytestcache"</span>), (db = <span class="hljs-number">133</span>));
</code></pre>
<h2>Redis3: 아키텍처</h2>
<p>자세히 살펴보면, redis3Client는 boto3 작업을 매우 얇게 래핑한 것입니다. 특히 S3 Express 버킷에 대한 작업을 합니다. 다음과 같이 클라이언트를 초기화합니다:</p>
<pre><code class="hljs language-js">r = <span class="hljs-title function_">redis3Client</span>((cache_name = <span class="hljs-string">"mytestcache"</span>), (db = <span class="hljs-number">0</span>));
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>버킷 redis3-mytestcache -- use1-az5 -- x-s3 를 생성하는 시도를 합니다. 즉, use1-az5 가용 영역에서 명명 규칙을 따르는 익스프레스 버킷을 생성합니다. 그런 다음 db 매개변수가 AWS 폴더 내에 키를 이름 공간으로 사용합니다:</p>
<pre><code class="hljs language-js">redis3-mytestcache -- use1-az5 -- x-s3
    <span class="hljs-number">0</span>/
        my_key_1
        my_key_2
    <span class="hljs-number">1</span>/
        my_key_1
    ...
</code></pre>
<p>이 설계에는 일반 캐싱 서버와 비교할 때 몇 가지 장단점이 있습니다. (가격-성능 외에, 이는 다음에 다룹니다):</p>
<ul>
<li>배포, 유지 관리, 이해하는 데 추가 인프라가 필요하지 않습니다.</li>
<li>보안, 연결 및 권한 부여를 IAM 세분성으로 처리할 수 있습니다. 사용자는 예를 들어 새 캐시를 생성할 수 없지만 기존 캐시에서 키를 가져올 수 있는 권한을 가질 수 있습니다. redis3Client는 스크립트 실행 시 적용되는 AWS 권한을 상속하고 존중합니다 (마치 boto3.client('s3') 와 같이);</li>
<li>redis3Client는 연결 풀이 필요하지 않으며 공간이 부족해지지 않고 대량 처리를 지원합니다 (결국 S3 이기 때문에!). 최근에는 이 용어가 남발되고 있지만, 여기에는 분명히 "서버리스 경험"이 있습니다.</li>
</ul>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>그러나 Redis의 동시성 모델은 이해하기 매우 쉽습니다. 병행성이 많지 않기 때문에 원자 연산 지원이 시스템의 정확성을 보장하는 데 중요합니다. 안타깝게도 S3는 그러한 보장을 제공하지 않습니다. S3는 강력한 쓰기 후 읽기 일관성을 제공하지만(예를 들어 SET 직후에 DB 내용을 나열할 때 유용함), 여전히 INCR과 같은 것을 흉내 내는 방법은 없습니다. 이로 인해 누군가가 이전 my_value를 읽고 있는 동안에도 코드가 해당 값을 증가시키고 다시 저장하는 것을 피할 방법이 없습니다:</p>
<pre><code class="hljs language-js">v = <span class="hljs-variable constant_">GET</span> my_value
v = v + <span class="hljs-number">1</span>
<span class="hljs-variable constant_">SET</span> my_value v
</code></pre>
<p>이에 대해 어떤 사람들은 redis3Client MSET 및 MGET 명령어가 잘못된 이름을 가졌으며, Redis 파이프라인으로 보내는 키 목록과 관련된 것보다 원래의 원자적 명령어와 더 유사하다고 주장할 수 있습니다 (사실 이름 짓기와 캐싱을 한다는 것이 컴퓨터 과학에서 가장 어려운 두 가지일이라는 것이 밝혀졌습니다!).</p>
<h2>빠르고 비교적 저렴한 방법</h2>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>우리의 파이썬 메소드가 얼마나 좋은지는 중요하지 않아요. 캐시는 빠르고 신뢰할 수 있어야 해요. 저희는 EC2에서 테스트 스크립트를 실행하고, 같은 가용 영역에 위치한 redis3 캐시와 표준 S3 버킷, Redis 인스턴스(그냥 편하게 Redis Labs에서 호스팅해요! ) 결과(초 단위)를 비교해요:</p>
<p><img src="/assets/img/2024-06-19-RebuildingRedisonS3Express_1.png" alt="image"></p>
<p>Redis보다는 여전히 느리지만, redis3는 실제로 새로운 가격 성능 옵션으로, "미숙한 S3 캐시"보다 평균적으로 훨씬 더 빠를 뿐만 아니라 신뢰할 수 있음을 입증했어요(95백분위에서 5배).</p>
<p>공식 가격표를 빠르게 살펴보면, AWS Redis 인스턴스와 비교했을 때 더 분명하게 알 수 있어요:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p><img src="/assets/img/2024-06-19-RebuildingRedisonS3Express_2.png" alt="image"></p>
<p>1GB의 redis3 캐시는 메모리 지원 캐시보다 훨씬 저렴하게 구입할 수 있습니다 (추가 인프라 및 유지보수를 고려하지 않음).</p>
<h2>수괴카우보이, 다음에 봐요</h2>
<p>S3를 캐시로 사용하는 것은 미친 것처럼 보일 수 있지만, 새로운 익스프레스 버킷을 사용하면 그렇게 보이지 않습니다: Redis가 어디론가 사라지지 않는 한, 객체 스토리지와 데이터 애플리케이션의 상호 진화는 계속해서 새로운 트레이드 오프를 활용하는 흥미로운 패턴을 만들어냅니다. 이 실험을 좋아하셨다면, redis3 클래스를 직접 사용해보고 어떻게 생각하는지 알려주세요!</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>마지막으로, EC2를 S3 위에 올려 데이터 작업을 수행할 때 무엇이 발생하는지 신경 쓰신다면, Bauplan에 대한 최신 정보를 따르는 것을 잊지 마세요.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Redis를 S3 Express로 재구축하기","description":"","date":"2024-06-19 12:10","slug":"2024-06-19-RebuildingRedisonS3Express","content":"\n## 느린, 저렴하고 확장 가능한 키-값 저장소\n\n## 느린-저렴 대 빠른-비싼\n\n다년간 \"최고의 데이터베이스\"로 선정된 Redis는 빠르고 신뢰성 있으며 고처리량의 키-값 저장소로 탄생했습니다 (훨씬 더 발전하기 전). 오늘날에도 가장 많이 사용되는 용도는 캐싱입니다 — 사용자를 위해 작고 자주 액세스하는 데이터를 빠르게 저장합니다 (예: 몇 줄의 파이썬 코드로):\n\n```js\n\u003e\u003e\u003e import redis\n\u003e\u003e\u003e r = redis.Redis(host='myhost', port=6379, db=0)\n\u003e\u003e\u003e r.set('userId:10', '1701743088')\nTrue\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그리고 키 기반 쿼리로 나중에 다시 검색하세요:\n\n```js\n\u003e\u003e\u003e r.get('userId:10')\n1701743088\n```\n\n쉽고 빠르죠. Redis의 가치와 비밀은 데이터 전문가들에게 분명히 비밀이 아니며, 비용도 마찬가지입니다. 메모리는 비싸며, 캐시는 클라우드 요금에 빠르게 영향을 줄 수 있습니다. AWS ElasticCache의 25GB(cache.m7g.2xlarge)는 약 500달러 / 월입니다.\n\n다른 한편으로, S3와 같은 객체 저장소는 다른 가격 / 성능 트레이드오프를 약속했습니다. 25GB 저장 비용은 약 0.5달러 / 월이지만, S3 지연 시간(평균 및 테일)은 당신의 응용 프로그램에 심각한 영향을 미칠 수 있습니다. 만약 일관적이고 빠른 작업에 의존하고 있다면요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n요즘까지는 아니었지만, S3 익스프레스의 공개로 파레토 프런티어에 또 다른 포인트가 추가되었습니다. \"익스프레스 저장소 클래스는 최대 10배 더 나은 성능을 제공하기 위해 설계되었으며 (...), 가장 자주 액세스하는 데이터에 탁월한 적합성을 갖추고 있습니다.\"\n\n이러한 새로운 기능에 매료되어, 우리는 AWS의 신제품을 테스트하기 위해 Redis와 유사한 키-값 워크로드를 완전히 S3로 백업하는 새로운 인터페이스를 재구성해 보았습니다(적절하게 \"redis3\"라고 합니다). 우리는 이를 프로토타입화하고 테스트하며 오픈소스로 공유했는데, 우리가 배운 것은 이렇습니다: 저장소를 복제하고 스타를 추가하며 함께하세요!\n\n![이미지](/assets/img/2024-06-19-RebuildingRedisonS3Express_0.png)\n\n## Redis3: 개발자 시각\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n요즘 데이터 랜드의 모든 사람들이 개발자 경험에 집착하고 있기 때문에, 우리는 redis3를 최종 사용자인 개발자에게 어떻게 보이는지부터 살펴보겠습니다. GET/SET 연산이 실제로 Redis의 핵심 기능이므로, redis-py 명령어를 redis3와 비교하여 시작합니다.\n\n```js\n\u003e\u003e\u003e from redis3 import redis3Client\n\u003e\u003e\u003e r = redis3Client(cache_name='mytestcache', db=0)\n\u003e\u003e\u003e r.set('userId:10', '1701743088')\nTrue\n\u003e\u003e\u003e r.get('userId:10')\n1701743088\n```\n\n알 수 있는 독자들은 이미 알고 계실 것이지만, 위 명령어는 기본적으로 동일합니다: URL 및 포트는 클라이언트 초기화에 없지만 (이유는 아래에서 자세히 설명되어 있습니다. 심지어 GET 및 SET에 대해 동일한 간결한 구문과 의미론을 가지고 있습니다.\n\nRedis3에서는 데이터베이스의 모든 키를 나열하거나 Redis에서의 MSET 및 MGET을 모방할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nkey_list = ['playground_{}'.format(i) for i in range(5)]\nval_list = ['bar_{}'.format(i) for i in range(5)]\nr = my_client.mset(key_list, val_list)\nval_list_back = my_client.mget(key_list)\nassert val_list == val_list_back\n```\n\n그리고 key를 삭제할 수도 있어요 (DEL):\n\n```js\nr = my_client.delete(\"userId:10\");\n```\n\n마지막으로, db 매개변수를 사용하여 키를 자동으로 네임스페이스 할 수 있어요 (물론 16에 제한되지 않아요):\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nr = redis3Client((cache_name = \"mytestcache\"), (db = 133));\n```\n\n## Redis3: 아키텍처\n\n자세히 살펴보면, redis3Client는 boto3 작업을 매우 얇게 래핑한 것입니다. 특히 S3 Express 버킷에 대한 작업을 합니다. 다음과 같이 클라이언트를 초기화합니다:\n\n```js\nr = redis3Client((cache_name = \"mytestcache\"), (db = 0));\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n버킷 redis3-mytestcache -- use1-az5 -- x-s3 를 생성하는 시도를 합니다. 즉, use1-az5 가용 영역에서 명명 규칙을 따르는 익스프레스 버킷을 생성합니다. 그런 다음 db 매개변수가 AWS 폴더 내에 키를 이름 공간으로 사용합니다:\n\n```js\nredis3-mytestcache -- use1-az5 -- x-s3\n    0/\n        my_key_1\n        my_key_2\n    1/\n        my_key_1\n    ...\n```\n\n이 설계에는 일반 캐싱 서버와 비교할 때 몇 가지 장단점이 있습니다. (가격-성능 외에, 이는 다음에 다룹니다):\n\n- 배포, 유지 관리, 이해하는 데 추가 인프라가 필요하지 않습니다.\n- 보안, 연결 및 권한 부여를 IAM 세분성으로 처리할 수 있습니다. 사용자는 예를 들어 새 캐시를 생성할 수 없지만 기존 캐시에서 키를 가져올 수 있는 권한을 가질 수 있습니다. redis3Client는 스크립트 실행 시 적용되는 AWS 권한을 상속하고 존중합니다 (마치 boto3.client('s3') 와 같이);\n- redis3Client는 연결 풀이 필요하지 않으며 공간이 부족해지지 않고 대량 처리를 지원합니다 (결국 S3 이기 때문에!). 최근에는 이 용어가 남발되고 있지만, 여기에는 분명히 \"서버리스 경험\"이 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그러나 Redis의 동시성 모델은 이해하기 매우 쉽습니다. 병행성이 많지 않기 때문에 원자 연산 지원이 시스템의 정확성을 보장하는 데 중요합니다. 안타깝게도 S3는 그러한 보장을 제공하지 않습니다. S3는 강력한 쓰기 후 읽기 일관성을 제공하지만(예를 들어 SET 직후에 DB 내용을 나열할 때 유용함), 여전히 INCR과 같은 것을 흉내 내는 방법은 없습니다. 이로 인해 누군가가 이전 my_value를 읽고 있는 동안에도 코드가 해당 값을 증가시키고 다시 저장하는 것을 피할 방법이 없습니다:\n\n```js\nv = GET my_value\nv = v + 1\nSET my_value v\n```\n\n이에 대해 어떤 사람들은 redis3Client MSET 및 MGET 명령어가 잘못된 이름을 가졌으며, Redis 파이프라인으로 보내는 키 목록과 관련된 것보다 원래의 원자적 명령어와 더 유사하다고 주장할 수 있습니다 (사실 이름 짓기와 캐싱을 한다는 것이 컴퓨터 과학에서 가장 어려운 두 가지일이라는 것이 밝혀졌습니다!).\n\n## 빠르고 비교적 저렴한 방법\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리의 파이썬 메소드가 얼마나 좋은지는 중요하지 않아요. 캐시는 빠르고 신뢰할 수 있어야 해요. 저희는 EC2에서 테스트 스크립트를 실행하고, 같은 가용 영역에 위치한 redis3 캐시와 표준 S3 버킷, Redis 인스턴스(그냥 편하게 Redis Labs에서 호스팅해요! ) 결과(초 단위)를 비교해요:\n\n![image](/assets/img/2024-06-19-RebuildingRedisonS3Express_1.png)\n\nRedis보다는 여전히 느리지만, redis3는 실제로 새로운 가격 성능 옵션으로, \"미숙한 S3 캐시\"보다 평균적으로 훨씬 더 빠를 뿐만 아니라 신뢰할 수 있음을 입증했어요(95백분위에서 5배).\n\n공식 가격표를 빠르게 살펴보면, AWS Redis 인스턴스와 비교했을 때 더 분명하게 알 수 있어요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](/assets/img/2024-06-19-RebuildingRedisonS3Express_2.png)\n\n1GB의 redis3 캐시는 메모리 지원 캐시보다 훨씬 저렴하게 구입할 수 있습니다 (추가 인프라 및 유지보수를 고려하지 않음).\n\n## 수괴카우보이, 다음에 봐요\n\nS3를 캐시로 사용하는 것은 미친 것처럼 보일 수 있지만, 새로운 익스프레스 버킷을 사용하면 그렇게 보이지 않습니다: Redis가 어디론가 사라지지 않는 한, 객체 스토리지와 데이터 애플리케이션의 상호 진화는 계속해서 새로운 트레이드 오프를 활용하는 흥미로운 패턴을 만들어냅니다. 이 실험을 좋아하셨다면, redis3 클래스를 직접 사용해보고 어떻게 생각하는지 알려주세요!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n마지막으로, EC2를 S3 위에 올려 데이터 작업을 수행할 때 무엇이 발생하는지 신경 쓰신다면, Bauplan에 대한 최신 정보를 따르는 것을 잊지 마세요.\n","ogImage":{"url":"/assets/img/2024-06-19-RebuildingRedisonS3Express_0.png"},"coverImage":"/assets/img/2024-06-19-RebuildingRedisonS3Express_0.png","tag":["Tech"],"readingTime":8},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch2\u003e느린, 저렴하고 확장 가능한 키-값 저장소\u003c/h2\u003e\n\u003ch2\u003e느린-저렴 대 빠른-비싼\u003c/h2\u003e\n\u003cp\u003e다년간 \"최고의 데이터베이스\"로 선정된 Redis는 빠르고 신뢰성 있으며 고처리량의 키-값 저장소로 탄생했습니다 (훨씬 더 발전하기 전). 오늘날에도 가장 많이 사용되는 용도는 캐싱입니다 — 사용자를 위해 작고 자주 액세스하는 데이터를 빠르게 저장합니다 (예: 몇 줄의 파이썬 코드로):\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003e\u003e\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e redis\n\u003e\u003e\u003e r = redis.\u003cspan class=\"hljs-title class_\"\u003eRedis\u003c/span\u003e(host=\u003cspan class=\"hljs-string\"\u003e'myhost'\u003c/span\u003e, port=\u003cspan class=\"hljs-number\"\u003e6379\u003c/span\u003e, db=\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e)\n\u003e\u003e\u003e r.\u003cspan class=\"hljs-title function_\"\u003eset\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'userId:10'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'1701743088'\u003c/span\u003e)\n\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e그리고 키 기반 쿼리로 나중에 다시 검색하세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003e\u003e\u003e r.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'userId:10'\u003c/span\u003e)\n\u003cspan class=\"hljs-number\"\u003e1701743088\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e쉽고 빠르죠. Redis의 가치와 비밀은 데이터 전문가들에게 분명히 비밀이 아니며, 비용도 마찬가지입니다. 메모리는 비싸며, 캐시는 클라우드 요금에 빠르게 영향을 줄 수 있습니다. AWS ElasticCache의 25GB(cache.m7g.2xlarge)는 약 500달러 / 월입니다.\u003c/p\u003e\n\u003cp\u003e다른 한편으로, S3와 같은 객체 저장소는 다른 가격 / 성능 트레이드오프를 약속했습니다. 25GB 저장 비용은 약 0.5달러 / 월이지만, S3 지연 시간(평균 및 테일)은 당신의 응용 프로그램에 심각한 영향을 미칠 수 있습니다. 만약 일관적이고 빠른 작업에 의존하고 있다면요:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e요즘까지는 아니었지만, S3 익스프레스의 공개로 파레토 프런티어에 또 다른 포인트가 추가되었습니다. \"익스프레스 저장소 클래스는 최대 10배 더 나은 성능을 제공하기 위해 설계되었으며 (...), 가장 자주 액세스하는 데이터에 탁월한 적합성을 갖추고 있습니다.\"\u003c/p\u003e\n\u003cp\u003e이러한 새로운 기능에 매료되어, 우리는 AWS의 신제품을 테스트하기 위해 Redis와 유사한 키-값 워크로드를 완전히 S3로 백업하는 새로운 인터페이스를 재구성해 보았습니다(적절하게 \"redis3\"라고 합니다). 우리는 이를 프로토타입화하고 테스트하며 오픈소스로 공유했는데, 우리가 배운 것은 이렇습니다: 저장소를 복제하고 스타를 추가하며 함께하세요!\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-RebuildingRedisonS3Express_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch2\u003eRedis3: 개발자 시각\u003c/h2\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e요즘 데이터 랜드의 모든 사람들이 개발자 경험에 집착하고 있기 때문에, 우리는 redis3를 최종 사용자인 개발자에게 어떻게 보이는지부터 살펴보겠습니다. GET/SET 연산이 실제로 Redis의 핵심 기능이므로, redis-py 명령어를 redis3와 비교하여 시작합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003e\u003e\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e redis3 \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e redis3Client\n\u003e\u003e\u003e r = \u003cspan class=\"hljs-title function_\"\u003eredis3Client\u003c/span\u003e(cache_name=\u003cspan class=\"hljs-string\"\u003e'mytestcache'\u003c/span\u003e, db=\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e)\n\u003e\u003e\u003e r.\u003cspan class=\"hljs-title function_\"\u003eset\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'userId:10'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'1701743088'\u003c/span\u003e)\n\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e\n\u003e\u003e\u003e r.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'userId:10'\u003c/span\u003e)\n\u003cspan class=\"hljs-number\"\u003e1701743088\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e알 수 있는 독자들은 이미 알고 계실 것이지만, 위 명령어는 기본적으로 동일합니다: URL 및 포트는 클라이언트 초기화에 없지만 (이유는 아래에서 자세히 설명되어 있습니다. 심지어 GET 및 SET에 대해 동일한 간결한 구문과 의미론을 가지고 있습니다.\u003c/p\u003e\n\u003cp\u003eRedis3에서는 데이터베이스의 모든 키를 나열하거나 Redis에서의 MSET 및 MGET을 모방할 수 있습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ekey_list = [\u003cspan class=\"hljs-string\"\u003e'playground_{}'\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eformat\u003c/span\u003e(i) \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e i \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erange\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e)]\nval_list = [\u003cspan class=\"hljs-string\"\u003e'bar_{}'\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eformat\u003c/span\u003e(i) \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e i \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erange\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e)]\nr = my_client.\u003cspan class=\"hljs-title function_\"\u003emset\u003c/span\u003e(key_list, val_list)\nval_list_back = my_client.\u003cspan class=\"hljs-title function_\"\u003emget\u003c/span\u003e(key_list)\nassert val_list == val_list_back\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그리고 key를 삭제할 수도 있어요 (DEL):\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003er = my_client.\u003cspan class=\"hljs-title function_\"\u003edelete\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"userId:10\"\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e마지막으로, db 매개변수를 사용하여 키를 자동으로 네임스페이스 할 수 있어요 (물론 16에 제한되지 않아요):\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003er = \u003cspan class=\"hljs-title function_\"\u003eredis3Client\u003c/span\u003e((cache_name = \u003cspan class=\"hljs-string\"\u003e\"mytestcache\"\u003c/span\u003e), (db = \u003cspan class=\"hljs-number\"\u003e133\u003c/span\u003e));\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eRedis3: 아키텍처\u003c/h2\u003e\n\u003cp\u003e자세히 살펴보면, redis3Client는 boto3 작업을 매우 얇게 래핑한 것입니다. 특히 S3 Express 버킷에 대한 작업을 합니다. 다음과 같이 클라이언트를 초기화합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003er = \u003cspan class=\"hljs-title function_\"\u003eredis3Client\u003c/span\u003e((cache_name = \u003cspan class=\"hljs-string\"\u003e\"mytestcache\"\u003c/span\u003e), (db = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e));\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e버킷 redis3-mytestcache -- use1-az5 -- x-s3 를 생성하는 시도를 합니다. 즉, use1-az5 가용 영역에서 명명 규칙을 따르는 익스프레스 버킷을 생성합니다. 그런 다음 db 매개변수가 AWS 폴더 내에 키를 이름 공간으로 사용합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eredis3-mytestcache -- use1-az5 -- x-s3\n    \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e/\n        my_key_1\n        my_key_2\n    \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e/\n        my_key_1\n    ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 설계에는 일반 캐싱 서버와 비교할 때 몇 가지 장단점이 있습니다. (가격-성능 외에, 이는 다음에 다룹니다):\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e배포, 유지 관리, 이해하는 데 추가 인프라가 필요하지 않습니다.\u003c/li\u003e\n\u003cli\u003e보안, 연결 및 권한 부여를 IAM 세분성으로 처리할 수 있습니다. 사용자는 예를 들어 새 캐시를 생성할 수 없지만 기존 캐시에서 키를 가져올 수 있는 권한을 가질 수 있습니다. redis3Client는 스크립트 실행 시 적용되는 AWS 권한을 상속하고 존중합니다 (마치 boto3.client('s3') 와 같이);\u003c/li\u003e\n\u003cli\u003eredis3Client는 연결 풀이 필요하지 않으며 공간이 부족해지지 않고 대량 처리를 지원합니다 (결국 S3 이기 때문에!). 최근에는 이 용어가 남발되고 있지만, 여기에는 분명히 \"서버리스 경험\"이 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e그러나 Redis의 동시성 모델은 이해하기 매우 쉽습니다. 병행성이 많지 않기 때문에 원자 연산 지원이 시스템의 정확성을 보장하는 데 중요합니다. 안타깝게도 S3는 그러한 보장을 제공하지 않습니다. S3는 강력한 쓰기 후 읽기 일관성을 제공하지만(예를 들어 SET 직후에 DB 내용을 나열할 때 유용함), 여전히 INCR과 같은 것을 흉내 내는 방법은 없습니다. 이로 인해 누군가가 이전 my_value를 읽고 있는 동안에도 코드가 해당 값을 증가시키고 다시 저장하는 것을 피할 방법이 없습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ev = \u003cspan class=\"hljs-variable constant_\"\u003eGET\u003c/span\u003e my_value\nv = v + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n\u003cspan class=\"hljs-variable constant_\"\u003eSET\u003c/span\u003e my_value v\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이에 대해 어떤 사람들은 redis3Client MSET 및 MGET 명령어가 잘못된 이름을 가졌으며, Redis 파이프라인으로 보내는 키 목록과 관련된 것보다 원래의 원자적 명령어와 더 유사하다고 주장할 수 있습니다 (사실 이름 짓기와 캐싱을 한다는 것이 컴퓨터 과학에서 가장 어려운 두 가지일이라는 것이 밝혀졌습니다!).\u003c/p\u003e\n\u003ch2\u003e빠르고 비교적 저렴한 방법\u003c/h2\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e우리의 파이썬 메소드가 얼마나 좋은지는 중요하지 않아요. 캐시는 빠르고 신뢰할 수 있어야 해요. 저희는 EC2에서 테스트 스크립트를 실행하고, 같은 가용 영역에 위치한 redis3 캐시와 표준 S3 버킷, Redis 인스턴스(그냥 편하게 Redis Labs에서 호스팅해요! ) 결과(초 단위)를 비교해요:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-RebuildingRedisonS3Express_1.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003eRedis보다는 여전히 느리지만, redis3는 실제로 새로운 가격 성능 옵션으로, \"미숙한 S3 캐시\"보다 평균적으로 훨씬 더 빠를 뿐만 아니라 신뢰할 수 있음을 입증했어요(95백분위에서 5배).\u003c/p\u003e\n\u003cp\u003e공식 가격표를 빠르게 살펴보면, AWS Redis 인스턴스와 비교했을 때 더 분명하게 알 수 있어요:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-RebuildingRedisonS3Express_2.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e1GB의 redis3 캐시는 메모리 지원 캐시보다 훨씬 저렴하게 구입할 수 있습니다 (추가 인프라 및 유지보수를 고려하지 않음).\u003c/p\u003e\n\u003ch2\u003e수괴카우보이, 다음에 봐요\u003c/h2\u003e\n\u003cp\u003eS3를 캐시로 사용하는 것은 미친 것처럼 보일 수 있지만, 새로운 익스프레스 버킷을 사용하면 그렇게 보이지 않습니다: Redis가 어디론가 사라지지 않는 한, 객체 스토리지와 데이터 애플리케이션의 상호 진화는 계속해서 새로운 트레이드 오프를 활용하는 흥미로운 패턴을 만들어냅니다. 이 실험을 좋아하셨다면, redis3 클래스를 직접 사용해보고 어떻게 생각하는지 알려주세요!\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e마지막으로, EC2를 S3 위에 올려 데이터 작업을 수행할 때 무엇이 발생하는지 신경 쓰신다면, Bauplan에 대한 최신 정보를 따르는 것을 잊지 마세요.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-19-RebuildingRedisonS3Express"},"buildId":"T_Nz0g9U1yttYMSEma95P","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>