<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>어이쿠, 내 앱이 성공했는데 접근성에 대해 생각하지 않았어요 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="어이쿠, 내 앱이 성공했는데 접근성에 대해 생각하지 않았어요 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="어이쿠, 내 앱이 성공했는데 접근성에 대해 생각하지 않았어요 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility" data-gatsby-head="true"/><meta name="twitter:title" content="어이쿠, 내 앱이 성공했는데 접근성에 대해 생각하지 않았어요 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-17 18:44" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-4f7b40c1114f0d09.js" defer=""></script><script src="/_next/static/o1YmnmSuZvAX2O4TI9r41/_buildManifest.js" defer=""></script><script src="/_next/static/o1YmnmSuZvAX2O4TI9r41/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">어이쿠, 내 앱이 성공했는데 접근성에 대해 생각하지 않았어요</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="어이쿠, 내 앱이 성공했는데 접근성에 대해 생각하지 않았어요" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 17, 2024</span><span class="posts_reading_time__f7YPP">17<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>본인이 천재적인 앱 아이디어, 새로운 일자리, 또는 벤처 자본을 받았을 때, 새로운 기능을 배포하는 데만 시선을 집중하는 유혹이 감도는 건 이해합니다.</p>
<p>올바른 방식으로 집중한다면, 이러한 집중은 앱을 다운로드 차트의 정상으로 랭킹시키며 성과를 거둘 수 있습니다. 그렇지만 그것으로 충분하지 않습니다. 모두가 본인의 앱을 사용하기 전까지 멈출 수 없을 겁니다.</p>
<p>이런 믿을 수 없는 목표를 달성한 후, 현실적인 진실을 알아차립니다: 6명 중 1명이 본인의 앱이 고장나있다고 생각합니다.</p>
<p>그런 다음, 깨닫게 됩니다.</p>
<p>16%의 사람들이 어떤 형태의 접근성(a11y - 멋진 친구 중 하나라면) 요구사항을 가지고 있습니다. 그러나 자유롭게 움직이면서 일할 때, 쉽게 a11y를 뒷전에 두는 경우가 많습니다. 특히 기한에 쫓기고 리더십으로부터 제한된 참여를 받을 때 말이죠.</p>
<p>더 성공하게 되면, 사용자들의 접근성 요구를 인정하지 못한 것으로 비판받을 확률이 커집니다. 불행히도 이를 우선적으로 다루기가 어렵습니다. 영향력 있는 누군가가 접근성을 옹호하지 않는 한 말이죠.</p>
<p>오늘은 도와드리겠습니다. 앱을 접근성에 맞춰 빠르게 개선하는 방법을 보여드릴게요:</p>
<ul>
<li>SwiftUI 앱에서 a11y를 점검합니다.</li>
<li>모든 텍스트 크기에서 앱을 잘 보이도록 만듭니다.</li>
<li>화면 낭독기를 사용할 수 있게 만듭니다.</li>
<li>이해관계자들을 설득하여 a11y를 우선시하도록 합니다.</li>
</ul>
<p>이 기사를 위해 특별히 만든 캣 테마 동반 앱을 살펴볼 것입니다. 표면 상으로는 괜찮아 보이지만, a11y(웹 접근성) 관점에서 평가를 시작하자마자 완전히 망가진 상태입니다.</p>
<p>기술을 완전히 이해하고 싶다면, 코드를 함께 작성해보세요! 우리는 이 기사에서 자세히 다룬 모든 기술을 구현하기 위해 Before/ 폴더에서 시작합니다 (최종 및 개선된 앱은 After/ 폴더를 참조하세요).</p>
<h1>앱의 접근성(A11y) 감사</h1>
<p>a11y(웹 접근성)를 제대로 이해하려면 실제 장치에서 접근성을 테스트해야 합니다. 이것이 모든 사용자가 앱과 상호 작용하는 방식입니다.</p>
<p>접근성(a11y) 작업을 진행할 때는, 먼저 컨트롤 센터를 최적화해야 합니다. 정말 대단한 시간을 절약할 수 있어요.</p>
<p>아이폰 설정으로 이동하여, 컨트롤 센터에 "텍스트 크기" 컨트롤과 "접근성 바로 가기"를 추가해보세요. "텍스트 크기"를 추가하면, 어떤 어플에서든 어디서든 밑으로 스와이프하여 텍스트 크기를 즉시 선택할 수 있어요. 심지어 어플당 크기 조절도 가능해요.</p>
<p>"접근성 바로 가기"를 추가하면, 어시스티브터치(AssistiveTouch), 보이스오버(VoiceOver), 색상 필터, 모션 감소 등 다양한 접근성 기능을 쉽게 적용할 수 있어요. 하지만 잠금 버튼을 세 번 누르면 동일한 메뉴가 나오기 때문에 더 쉽게 접근할 수 있어요.</p>
<h2>텍스트 크기 감사</h2>
<p>iOS에서는 extraSmall부터 accessibilityExtraExtraExtraLarge(즉, AX5)까지 12가지의 텍스트 크기 옵션이 있습니다. 최대 크기인 accessibilityExtraExtraExtraLarge는 기본(큰) 크기보다 약 310%* 더 큽니다.</p>
<p>텍스트 크기가 정상적으로 작동하는지 확인하기 위해 두 가지 감사를 선호합니다:</p>
<ul>
<li>앱을 가장 큰 일반 폰트인 extraExtraExtraLarge(즉, xxxl)로 테스트하고, 가급적 볼드 텍스트 접근성 설정도 활성화하세요. 이는 상대적으로 일반적인 가장 큰 폰트로, 제 어머니도 이 폰트를 사용합니다. 앱은 이 크기에서 잘 보여야 합니다.</li>
<li>앱을 가장 큰 접근성 폰트인 AX5로 테스트하세요. 이 크기는 익숙하지 않다면 우스꽝스러울 수 있지만, 이 크기밖에는 앱과 상호작용할 수 있는 방법이 없는 사람들이 있습니다. UI를 이 크기로 완벽하게 만드는 것은 어려울지라도, 접근성 텍스트 크기 설정에서 앱이 작동하는지조차 확인하지 않은 회사는 명백히 부족합니다.</li>
</ul>
<p>저희 앱을 한 번 살펴보겠습니다.</p>
<p><img src="/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_1.png" alt="앱 스크린샷"></p>
<p>바로 앱을 실행해보면, 정성껏 디자인한 로그인 UI가 텍스트 크기 조절 시 문제가 발생합니다. 저희는 대용량의 텍스트 크기를 예상하지 못했기 때문에 내용을 스크롤할 필요가 있다는 생각조차 하지 못했습니다.</p>
<p>더 나아가서, 색맹일 경우 로그인 버튼의 대비가 미미하여 버튼을 읽을 수 없을 것입니다.</p>
<p>우리 앱의 메인 목록 화면도 확인해 봅시다.</p>
<p><img src="/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_2.png" alt="Main List Screen"></p>
<p>이 화면은 덜 '부서지는' 느낌이 나요. 모든 것이 보이지만 액세스 가능한 크기의 폰트를 사용하는 사람에게는 이 크기에서 앱을 테스트하지 않았다는 것이 분명합니다. 공간을 다투는 텍스트 레이블이나 순창방에서 아이콘만큼 큰 캡션을 보세요.</p>
<h2>스크린 리더 오디트</h2>
<p>일부 사용자는 텍스트 크기 조정에 영향을 받지 않습니다 — 그들은 앱과 상호 작용하기 위해 스크린 리더기가 필요할 수 있기 때문입니다.</p>
<p>iOS VoiceOver는 여기서의 중요한 작업을 훌륭하게 처리하므로 여러분 팀의 약간의 배려가 큰 차이를 만들어냅니다.</p>
<p>텍스트 크기 감사와 마찬가지로 스크린 리더기 감사도 실제 기기에서 하는 것이 가장 좋습니다 (잠금 버튼을 3번 눌러보세요, 기억하세요!). 또한 Xcode에 내장된 개발자 도구인 접근성 검사 도구가 VoiceOver 작업에 도움이 됩니다.</p>
<p><img src="/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_3.png" alt="2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_3.png"></p>
<p>앱을 통해 걸어가면, 텍스트 크기 조정과 비교하면 적어도 깨진 부분이 적은 편이에요. 하지만 이미지와 같은 많은 UI 영역이 전혀 보이지 않아 사용자에게 직접적인 지원이 되지 않아요. 그 이유는 접근성 레이블을 추가하는 데 신경을 쓰지 않았기 때문이죠.</p>
<p><img src="/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_4.png" alt="이미지1"></p>
<p>특히 VoiceOver를 사용하지 않은 경우, 화면 리더기가 모든 UI 요소를 반복하며 읽어주지만 아이콘에는 라벨이 붙어있지 않아 명확합니다.</p>
<p><img src="/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_5.png" alt="이미지2"></p>
<p>큰 목록이 있으면 상황이 더 악화됩니다.</p>
<p>SwiftUI에 내용에 대한 정보를 제공하지 않으면, 스크롤 가능한 내용의 아래쪽 로그아웃 버튼으로 이동하려면 100번 이상 스와이프해야 할 수도 있는 상황에 처하게 될 수 있습니다. 페이징에 대해서 시작도 하지 마세요.</p>
<p><img src="/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_6.png" alt="앱 접근성을 고려하지 않고 앱이 성공적이라고 생각하지 않은 경우 스크린샷"></p>
<p>우리 앱을 접근성이 좋은 앱이라고 부를 수 있기 전에 해결해야 할 문제가 많습니다. 다행히 SwiftUI에는 a11y에 대해 신속하게 파악할 수 있는 도구가 가득합니다.</p>
<h1>스피드런 액세시빌리티</h1>
<p>이제 문제가 어디에 있는지 알았으니, 하나씩 빠르게 해결해 나갈 수 있어요.</p>
<h2>스크롤 가능한 콘텐츠</h2>
<p>이것은 가장 불편한 문제입니다. 큰 텍스트 크기에 대한 스크롤 뷰로 확장되지 않아 앱 온보딩이 완전히 망가졌어요.</p>
<p>우리의 감사에서는 로그인 화면 버튼이 폰트 크기가 커짐에 따라 화면 밖으로 밀렸습니다. 나머지 텍스트 내용은 서로 밀어붙여져 레이블이 겹치고 확장할 공간이 없어 잘린 것처럼 보였어요.</p>
<p>자연스러운 해결책은 콘텐츠를 스크롤 가능하도록 만드는 것입니다. 그러나 모든 화면이 컨텐츠가 잘 맞는 경우에도 스크롤이 자유롭게 되어서는 안 됩니다. 우리는 Ionic 앱을 만드는 일이 아니에요. <em>억압된 기억으로 전율을 느끼며</em></p>
<p>이 문제는 사용자 지정 뷰 수정자로 해결할 수 있습니다. 제가 a11yScrollView()라고 부르는 이 뷰 수정자의 목표는 화면 내용을 스크롤 뷰로 감싸지만 필요한 경우에만 발생하도록 하는 것입니다. 이것을 작은 라이브러리 A11yUtils에 추가하여 여러분의 코드에서 사용할 수 있도록 했어요.</p>
<p>현재 이것은 iOS 16.4 이상에서만 우리의 꿈이 되는 동작을 실현합니다 — 이미 콘텐츠가 맞는 경우 스크롤을 방지하기 위해 스크롤 뷰에 scrollBounceBehavior를 적용합니다.</p>
<p>미래에는 iOS 16에서 ViewThatFits* 및 iOS 15에서 GeometryReader와 함께 작동하도록하고 싶습니다.</p>
<p>OS 버전을 지정하는 사람이 주위에 없기 때문에 저희 온보딩 뷰의 VStack에 이 수정자를 적용할 수 있습니다.</p>
<pre><code class="hljs language-swift"><span class="hljs-comment">// OnboardingView.swift</span>

<span class="hljs-keyword">import</span> A11yUtils
<span class="hljs-keyword">import</span> SwiftUI

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">OnboardingView</span>: <span class="hljs-title class_">View</span> {
    
    <span class="hljs-meta">@Binding</span> <span class="hljs-keyword">var</span> isLoggedIn: <span class="hljs-type">Bool</span>
    
    <span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> {
        <span class="hljs-type">NavigationStack</span> {
            <span class="hljs-type">VStack</span>(spacing: <span class="hljs-number">20</span>) { <span class="hljs-comment">/* ... */</span> }
              .padding(.horizontal)
              .a11yScrollView()
              .navigationTitle(<span class="hljs-string">"Create account"</span>)
        }
    }
}
</code></pre>
<p>이제 콘텐츠가 멋지게 스크롤되어 xxxl, AX3 및 AX5에서 잘 보입니다.</p>
<h2>스페이서는 코드 냄새입니다</h2>
<p>온보딩 화면을 작업하는 동안, 우리가 할 수 있는 또 다른 간단한 개선 사항이 있습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">VStack</span>(<span class="hljs-attr">spacing</span>: <span class="hljs-number">20</span>) {
    <span class="hljs-comment">// ...</span>
    <span class="hljs-title class_">OnboardingReasonsText</span>()
    <span class="hljs-title class_">Spacer</span>()
    <span class="hljs-title class_">LoginButtonView</span>()
}
</code></pre>
<p>텍스트 크기가 크면 화면 공간이 제한되어 Spacer()를 사용하면 문제가 발생할 수 있습니다. SwiftUI 레이아웃 엔진은 공간을 만들기 위해 열심히 노력합니다. 심지어 그 공간이 더 이상 없어도 텍스트가 절단되는 문제가 발생할 수 있습니다.</p>
<p>이러한 시나리오에서 스페이서를 매우 좁은 높이로 압축해도 VStack에 정의된대로 위아래로 각각 20포인트의 공간이 생길 것입니다.</p>
<p>우리는 Spacer()를 frame() 수정자로 바꿀 수 있습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">VStack</span>(<span class="hljs-attr">spacing</span>: <span class="hljs-number">20</span>) {
    <span class="hljs-title class_">OnboardingReasonsText</span>()
    <span class="hljs-title class_">LoginButtonView</span>()
        .<span class="hljs-title function_">frame</span>(<span class="hljs-attr">maxHeight</span>: .<span class="hljs-property">infinity</span>, <span class="hljs-attr">alignment</span>: .<span class="hljs-property">bottom</span>)
}
</code></pre>
<p>프레임은 더 신뢰할 수 있는 방식으로 작동합니다: SwiftUI는 이 버튼 위에 가능한 한 많은 공간을 제공해야 함을 알지만, 여백 자체가 UI의 중요한 부분이 아니기 때문에 공간이 부족하면 불필요한 여백이 적용되지 않습니다.</p>
<p>이 프레임 수정자는 의미가 더 명확합니다. 즉, SwiftUI에게 우리의 의도를 명확하게 전달합니다. 이것은 a11y와 관련된 중요한 개념이므로 나중에 더 자세히 다룰 것입니다.</p>
<h2>이미지와 아이콘의 확대</h2>
<p>다이나믹 타입 덕분에 iOS는 사용자가 선택한 글꼴 크기에 따라 앱 내 글꼴을 자동으로 확대합니다. 이것은 사용자 정의 글꼴과도 쉽게 구현할 수 있습니다.</p>
<p>이는 SwiftUI에서 의미있는 글꼴 크기를 사용할 때 텍스트가 자동으로 조절된다는 것을 의미합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">Text</span>(cat.<span class="hljs-property">quote</span>)
    .<span class="hljs-title function_">font</span>(.<span class="hljs-property">body</span>) <span class="hljs-comment">// 이것도 잘 작동합니다</span>
</code></pre>
<p>더 좋은 것은 SFSymbols를 사용할 때 아이콘에도 동적 글꼴 크기를 적용할 수 있다는 것입니다!</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">Image</span>(<span class="hljs-attr">systemName</span>: <span class="hljs-string">"heart.circle.fill"</span>)
    .<span class="hljs-title function_">font</span>(.<span class="hljs-property">body</span>) <span class="hljs-comment">// 이것도 SFSymbols와 잘 작동합니다</span>
</code></pre>
<p>안타깝게도 대부분의 iOS 앱에는 Android 버전이 있으므로, 디자이너가 SFSymbols을 사용하는 대신 맞춤 아이콘을 만든다는 점에 유의하셔야 합니다. 대부분의 앱은 사용자 정의 이미지와 미디어를 포함합니다.</p>
<p>따라서 우리의 예시인 Before/에서는 아이콘을 SwiftUI에 추가하는 일반 이미지처럼 처리하여, 하드코딩된 크기를 사용했습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">Image</span>(cat.<span class="hljs-property">image</span>)
    .<span class="hljs-title function_">resizable</span>()
    .<span class="hljs-title function_">aspectRatio</span>(<span class="hljs-attr">contentMode</span>: .<span class="hljs-property">fit</span>)
    .<span class="hljs-title function_">frame</span>(<span class="hljs-attr">width</span>: <span class="hljs-number">72</span>, <span class="hljs-attr">height</span>: <span class="hljs-number">72</span>) <span class="hljs-comment">// 하드코딩된 크기 - 확장되지 않을 것입니다!</span>
    .<span class="hljs-title function_">clipShape</span>(<span class="hljs-title class_">Circle</span>())

<span class="hljs-title class_">Image</span>(<span class="hljs-attr">systemName</span>: cat.<span class="hljs-property">icon</span>)
    .<span class="hljs-title function_">resizable</span>()
    .<span class="hljs-title function_">aspectRatio</span>(<span class="hljs-attr">contentMode</span>: .<span class="hljs-property">fit</span>)
    .<span class="hljs-title function_">foregroundStyle</span>(.<span class="hljs-property">secondary</span>)
    .<span class="hljs-title function_">frame</span>(<span class="hljs-attr">width</span>: <span class="hljs-number">24</span>, <span class="hljs-attr">height</span>: <span class="hljs-number">24</span>) <span class="hljs-comment">// 하드코딩된 크기 - 확장되지 않을 것입니다!</span>
</code></pre>
<p>결과는 어떻게 될까요? 가장 큰 글꼴 크기로 조정했을 때, 콘텐츠가 매우 어울리지 않게 보일 수 있습니다.</p>
<p><img src="/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_8.png" alt="image"></p>
<p>SwiftUI에는 사용자 정의 이미지 및 뷰에서 동적 타입의 파워를 제공하는 멋진 도구인 @ScaledMetric 프로퍼티 래퍼가 있습니다.</p>
<pre><code class="hljs language-swift"><span class="hljs-meta">@ScaledMetric</span>(relativeTo: .largeTitle) <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> imageSize: <span class="hljs-type">CGFloat</span> <span class="hljs-operator">=</span> <span class="hljs-number">72</span>
<span class="hljs-meta">@ScaledMetric</span>(relativeTo: .body) <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> iconSize: <span class="hljs-type">CGFloat</span> <span class="hljs-operator">=</span> <span class="hljs-number">24</span>
</code></pre>
<p>우리는 @ScaledMetric을 자체로 사용할 수 있으며, 이는 기본 body 글꼴 크기 조정을 사용합니다. relativeTo를 사용하면 SwiftUI가 어떻게 조정할 지 알 수 있으므로 더 좋습니다.</p>
<p>largeTitle은 이미 상당히 크기 때문에 조금 더 확장됩니다. 캡션 스타일의 글꼴은 더 많이 확장됩니다. 이 경우 아이콘은 본문 크기 조정이 되어 동반하는 인용문 텍스트와 일치합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">Image</span>(cat.<span class="hljs-property">image</span>)
    .<span class="hljs-title function_">resizable</span>()
    .<span class="hljs-title function_">aspectRatio</span>(<span class="hljs-attr">contentMode</span>: .<span class="hljs-property">fit</span>)
    .<span class="hljs-title function_">frame</span>(<span class="hljs-attr">width</span>: imageSize, <span class="hljs-attr">height</span>: imageSize) <span class="hljs-comment">// 동적 크기 조정</span>
    .<span class="hljs-title function_">clipShape</span>(<span class="hljs-title class_">Circle</span>())

<span class="hljs-title class_">Image</span>(<span class="hljs-attr">systemName</span>: cat.<span class="hljs-property">icon</span>)
    .<span class="hljs-title function_">resizable</span>()
    .<span class="hljs-title function_">aspectRatio</span>(<span class="hljs-attr">contentMode</span>: .<span class="hljs-property">fit</span>)
    .<span class="hljs-title function_">foregroundStyle</span>(.<span class="hljs-property">secondary</span>)
    .<span class="hljs-title function_">frame</span>(<span class="hljs-attr">width</span>: iconSize, <span class="hljs-attr">height</span>: iconSize) <span class="hljs-comment">// 동적 크기 조정</span>
</code></pre>
<p>이제 이미지가 텍스트와 함께 더 합리적으로 보입니다.</p>
<h2>콘텐츠 정렬하기</h2>
<p>이미지는 더 잘 확장되지만, 여전히 텍스트 라벨이 공간을 지배하며 UI가 깨져 보입니다. 레이아웃 엔진과의 협상을 끝내고 나니, 줄바꿈으로 가득 차 있습니다.</p>
<p>만약 사용자의 텍스트 확장에 기반한 컨텐츠의 정렬이 가능하다면 어떨까요?</p>
<p>다행히도, 라이브러리 A11yUtils 덕분에 A11yHStack을 활용할 수 있습니다.</p>
<p>새로운 SwiftUI 도구 릴리스 속도가 빨라서 (그리고 Apple의 뒷전포기가 혹독해서), 이것은 최소 지원 OS에 기반을 둔 두 가지 다른 구현을 가지고 있어요:</p>
<ul>
<li>iOS 16에서는 ViewThatFits를 사용하여 HStack이 모든 내용을 포함할 수 있는지 확인하고, 그렇지 않으면 내용을 정렬하기 위해 VStack을 사용합니다.</li>
<li>iOS 15에서는 더 단호한 방식을 적용하여, @Environment(.sizeCategory)를 확인하고, 접근성 텍스트 크기 범주 (예: AX1, AX2 또는 AX5) 가 사용된 경우에는 VStack으로 전환합니다.</li>
</ul>
<p>다음은 간단한 접근 방식입니다:</p>
<pre><code class="hljs language-js">@<span class="hljs-title class_">Environment</span>(\.<span class="hljs-property">sizeCategory</span>) private <span class="hljs-keyword">var</span> sizeCategory

<span class="hljs-keyword">var</span> <span class="hljs-attr">body</span>: some <span class="hljs-title class_">View</span> {
    <span class="hljs-keyword">if</span> sizeCategory.<span class="hljs-property">isAccessibilityCategory</span> {
        <span class="hljs-title class_">VStack</span>(<span class="hljs-attr">alignment</span>: .<span class="hljs-property">leading</span>, <span class="hljs-attr">spacing</span>: spacing) {
            <span class="hljs-title function_">content</span>()
        }
        .<span class="hljs-title function_">frame</span>(<span class="hljs-attr">maxWidth</span>: .<span class="hljs-property">infinity</span>, <span class="hljs-attr">alignment</span>: .<span class="hljs-property">leading</span>)
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-title class_">HStack</span>(<span class="hljs-attr">alignment</span>: alignment, <span class="hljs-attr">spacing</span>: spacing) {
            <span class="hljs-title function_">content</span>()
        }
    }
}
</code></pre>
<p>@Environment(.sizeCategory)은 중요한 경우에 사용할 수 있는 유용한 도구입니다. 사용자가 접근성 텍스트 크기 범주를 사용하는지 여부를 알아야 하는 경우 (isAccessibilityCategory와 함께). 때로는 이 속성을 사용하여 대량 콘텐츠 크기에 맞지 않는 이미지와 같은 불필요한 UI 요소를 제거하는 데 활용합니다.</p>
<p>더 현대적인 구현은 비슷하게 동작하지만 ViewThatFits를 활용하여 콘텐츠가 맞지 않는 경우에만 재분배됩니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> <span class="hljs-attr">body</span>: some <span class="hljs-title class_">View</span> {
    <span class="hljs-title class_">ViewThatFits</span> {
        <span class="hljs-title class_">HStack</span>(<span class="hljs-attr">alignment</span>: alignment, <span class="hljs-attr">spacing</span>: spacing) {
            <span class="hljs-title function_">content</span>()
        }
        <span class="hljs-title class_">VStack</span>(<span class="hljs-attr">alignment</span>: .<span class="hljs-property">leading</span>, <span class="hljs-attr">spacing</span>: spacing) {
            <span class="hljs-title function_">content</span>()
        }.<span class="hljs-title function_">frame</span>(<span class="hljs-attr">maxWidth</span>: .<span class="hljs-property">infinity</span>, <span class="hljs-attr">alignment</span>: .<span class="hljs-property">leading</span>)
    }
}
</code></pre>
<p>생각을 많이 해면 A11yHStack을 몇 군데에 적용할 수 있습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> A11yUtils 

A11yHStack {
    <span class="hljs-title class_">Image</span>(cat.<span class="hljs-property">image</span>)
    <span class="hljs-title class_">VStack</span> {
        A11yHStack {
            <span class="hljs-title class_">Text</span>(cat.<span class="hljs-property">name</span>)
            <span class="hljs-title class_">Text</span>(<span class="hljs-string">"\(cat.age) years old"</span>)
        }
        <span class="hljs-title class_">HStack</span> {
            <span class="hljs-title class_">Image</span>(<span class="hljs-attr">systemName</span>: cat.<span class="hljs-property">icon</span>)
            <span class="hljs-title class_">Text</span>(cat.<span class="hljs-property">quote</span>)
        }
    }
}
</code></pre>
<p>이제 컨텐츠가 매우 큰 텍스트 크기에서 더 적절해 보입니다.</p>
<h2>스크린 리더 개선사항</h2>
<p>보이스오버는 퍼즐 조각 중 비교적 간단한 부분입니다.</p>
<p>앱이 스크린 리더와 잘 작동하도록 만드는 것은:</p>
<ul>
<li>시각적 콘텐츠가 충분히 설명되었는지 확인하기.</li>
<li>탐색이 직관적으로 작동되도록 만들기.</li>
<li>뷰가 의미론적으로 올바른지 확인하기.</li>
</ul>
<p>먼저 시각적 설명부터 시작해보죠. 이것은 우리 레퍼토리에서 가장 간단한 수정 사항입니다: 그래픽 콘텐츠가 VoiceOver에 의해 설명될 수 있도록 보장하는 것입니다. accessibilityLabel 수정자가 우리의 책과 버터라고 할 수 있죠.</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">Image</span>(<span class="hljs-string">"catKingdom"</span>)
    .<span class="hljs-title function_">accessibilityLabel</span>(<span class="hljs-title class_">Text</span>(<span class="hljs-string">"나의 세 마리 고양이: 코디, 로지, 루나"</span>))
</code></pre>
<p>스크린리더가 현재 초점을 맞춘 대상을 설명하는 방법을 알려줍니다.</p>
<p><img src="/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_11.png" alt="Cat Kingdom"></p>
<p>이제 주 뷰의 셀에 동일한 방식을 적용할 수 있습니다. Cat 데이터 모델을 약간 수정하여 각 고양이 사진과 함께 이미지 설명을 제공합니다.</p>
<pre><code class="hljs language-js">struct <span class="hljs-title class_">Cat</span> {
    <span class="hljs-comment">// ...</span>
    <span class="hljs-keyword">let</span> <span class="hljs-attr">imageDescription</span>: <span class="hljs-title class_">String</span>
}

<span class="hljs-title class_">Image</span>(cat.<span class="hljs-property">image</span>)
    .<span class="hljs-title function_">accessibilityLabel</span>(<span class="hljs-title class_">Text</span>(cat.<span class="hljs-property">imageDescription</span>))
</code></pre>
<p>이건 들릴만큼 쉽고, Apple 플랫폼에서만 작동하는 경향이 있어요.</p>
<p><img src="/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_12.png" alt="image"></p>
<p>우리 앱을 통해 탐색할 때, 좀 더 신중하게 할 수 있는 기회가 있어요. 기본 설정으로 VoiceOver는 SwiftUI 뷰 트리의 모든 잎 노드를 반복하며 모든 이미지, 버튼 및 텍스트를 읽어줄 거예요.</p>
<p>가끔 사용자에게 불필요한 탐색을 초래합니다. 저희 앱에서는 각 고양이의 아이콘과 인용구를 건너뛰려면 여러 번 탭해야 합니다. 아이콘의 이름(예: cat.fill)을 읽는 것은 경험에 별다른 도움이 되지 않습니다.</p>
<p>이들을 단일 a11y 요소로 결합하여 screenreader가 탐색 중에 하나의 항목으로 처리할 수 있도록 할 수 있습니다.</p>
<pre><code class="hljs language-swift"><span class="hljs-type">HStack</span> {
    <span class="hljs-type">Image</span>(systemName: cat.icon)
    <span class="hljs-type">Text</span>(cat.quote)
}
.accessibilityElement(children: .combine)
</code></pre>
<p>이제 screenreader가 요소를 하나로 이동하는 것을 들을 수 있습니다:</p>
<p><img src="/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_13.png" alt="image"></p>
<p>어떤 상황에서는 그래픽적으로 시간이 표시되는 셀렉트한 타이머 요소와 같이 복잡한 UI가 있을 수 있습니다. VoiceOver는 똑똑하지만, 설명되지 않은 뷰들의 번잡한 모음에서 유용한 정보를 유추하지는 못합니다.</p>
<p>여기서 accessibilityRepresentation 수정자가 정말 유용하게 사용됩니다. 이를 통해 뷰의 VoiceOver UI를 완전히 사용자 정의된 접근성 표현으로 대체할 수 있습니다.</p>
<p>최근에 개발한 개인 프로젝트 'Check 'em'에서는 사용자의 2단계 인증 코드가 카운트다운과 함께 표시되어 해당 기능이 특히 유용했습니다:</p>
<pre><code class="hljs language-swift"><span class="hljs-comment">// AccountView.swift</span>

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">AccountView</span>: <span class="hljs-title class_">View</span> {
    
    <span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> {
        <span class="hljs-type">Section</span>(account.name) {
            <span class="hljs-comment">// Image, 2FA Code Text, and Countdown UI ...</span>
        }
        .accessibilityRepresentation {
            <span class="hljs-type">VStack</span> {
                <span class="hljs-type">Text</span>(account.name)
                <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> code <span class="hljs-operator">=</span> account.code {
                    <span class="hljs-type">ForEach</span>(<span class="hljs-type">Array</span>(code.enumerated()), id: \.<span class="hljs-number">0</span>) {
                        <span class="hljs-type">Text</span>(<span class="hljs-type">String</span>(<span class="hljs-variable">$0</span>.<span class="hljs-number">1</span>))
                    }
                }
                <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> countdown <span class="hljs-operator">=</span> account.countdown {
                    <span class="hljs-type">Text</span>(<span class="hljs-string">"Expires in <span class="hljs-subst">\(countdown)</span>"</span>)
                }
            }.accessibilityElement(children: .combine)
        }
    }
</code></pre>
<p>이 modifier를 사용하여 각 셀 요소를 순서대로 반복하는 것보다 훨씬 유용한 완전히 사용자 정의 된 VoiceOver 인터페이스를 소개할 수 있었습니다. 또한 화면 낭독기가 "676,252"를 "육십 칠만 육천 이백 오십 이"로 읽는 것을 방지했습니다.</p>
<p><img src="/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_14.png" alt="Screenshot"></p>
<h2>Native components</h2>
<p>이 어플리케이션의 주요 뷰는 저희 콘텐츠를 배치하는 일반적이지만 조잡한 방법을 사용합니다: ForEach 내에 있는 셀을 래핑하는 방식으로 LazyVStack을 래핑하고 ScrollView로 래핑합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">ScrollView</span> {
    <span class="hljs-title class_">LazyVStack</span>(<span class="hljs-attr">spacing</span>: <span class="hljs-number">24</span>) {
        <span class="hljs-title class_">ForEach</span>(cats, <span class="hljs-attr">id</span>: \.<span class="hljs-property">name</span>) {
            <span class="hljs-title class_">CatView</span>(<span class="hljs-attr">cat</span>: $0)
        }
    }
}
</code></pre>
<p>최적의 방법은 가능한 한 SwiftUI의 기본 구성 요소를 활용하는 것입니다. 이 경우에는 List가 가장 적합합니다.</p>
<p>Apple은 사용자 정의 UI 대신 iOS-Settings 스타일의 List를 사용하려면 모디파이어를 3개 추가해야 한다는 점을 설명할 때, 이 작업을 좀 더 어렵게 만들어 놓았습니다.</p>
<pre><code class="hljs language-js">목록(고양이) {
    고양이뷰(고양이: $0)
        .목록행배경(<span class="hljs-title class_">Color</span>.<span class="hljs-property">clear</span>)
        .목록행구분선(.숨김)
}
.목록스타일(일반목록스타일())
</code></pre>
<p>이제 보일러플레이트를 작성했으니 수정자들을 자유롭게 사용하여 SwiftUI 목록에서 자체 UI를 사용할 수 있습니다.</p>
<p>한 가지 질문이 있습니다.</p>
<p>왜 네이티브 컴포넌트를 사용하는 것에 이렇게 많은 노력을 기울일까요?</p>
<p>먼저, 비 접근성(a11y) 관련 이유: SwiftUI List는 UICollectionView를 사용하여 구현됩니다. 이는 고성능 스크롤링을 위해 셀 재사용을 활용하며 항목이 많아도 성능을 유지합니다. 그에 반해 LazyVStack은 이전에 렌더링된 모든 셀을 메모리에 유지하므로 많은 항목을 스크롤하는 경우 성능이 뚝뚝 떨어집니다.</p>
<p>네이티브 컴포넌트를 사용하는 a11y 관련 이유는 간단하지만 다양합니다:</p>
<p>List는 의미론적 의미가 있습니다: 화면 판독기에게 비슷한 콘텐츠 컬렉션을 포함하는 컨테이너임을 알려줍니다.</p>
<p>이것이 많은 목록 항목이 있는 경우, 순진한 구현이 망가진 이유입니다: VoiceOver로 목록 컨테이너를 건너뛸 수 있게 해주지 않고 모든 항목을 스와이프해야만 로그아웃 버튼에 도달할 수 있었습니다.</p>
<p>List를 사용하면 SwiftUI가 화면 판독기에게 그 내용이 단일 컨테이너임을 알려줄 수 있어, 화면 판독기가 쉽게 이동할 수 있습니다.</p>
<p>아래는 Markdown 형식으로 변경된 이미지 링크입니다:</p>
<p><img src="/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_16.png" alt="이미지"></p>
<p>또한 List에는 스와이프 삭제, 드래그 앤 드롭, 키보드 기반 탐색 등 많은 내장 상호작용 모드가 있습니다. 네이티브 컴포넌트를 사용할 때 이들은 자동으로 작동합니다. 사용자 지정 구현과 함께 하는 화면 판독기 작업을 어떻게 할 것인지 아시겠습니까?</p>
<p>리스트는 심지어 가장 복잡한 컴포넌트도 아닙니다. 사용자 정의 그리드나 레이아웃 프로토콜을 사용하지 않는 뷰의 사용자 정의 분배에 a11y를 어떻게 구현할 것인가요?</p>
<h1>이해관계자 설득</h1>
<p>이제 SwiftUI 앱에서 a11y를 빠르게 실행하는 방법을 이해했으니, 작업에 착수하기 전에 남은 퍼즐 조각은 비즈니스의 나머지 구성원으로부터 승인을 얻는 것입니다. 여기서 당신이 조직적 영향력을 행사하는 소프트 스킬을 펼칠 수 있습니다.</p>
<p>당신이 휘둘 수 있는 큰, 둔한 도구 중 하나는 입법의 망치입니다. 영국, 미국, 그리고 EU와 같은 세계 각국은 디지털 서비스가 접근성의 최소 기준을 충족해야 한다는 법률을 시행했습니다.</p>
<p>또한, 웹 접근성(웹 콘텐츠 접근성)은 실제로 비즈니스에서 큰 이점을 제공합니다. 현재 세계 인구의 16%가 중요한 장애를 겪고 있습니다. 즉, 다양한 요구에 맞게 서비스를 제공함으로써 사용자, 긍정적인 리뷰 및 수익을 놓칠 수 있습니다. 대상 시장에 따라 이는 더 또는 덜 중요할 수 있습니다.</p>
<p>작은 규모에서는, 접근성을 제품 부채로 다루는 것보다 앱이 어떻게 오작동하는지 간단히 보여주는 것이 훨씬 효과적이라는 것을 발견했습니다. 접근성 요구사항을 추상적인 개념에서 벗어나서 버그 있는 가입 플로우를 보여주는 것이 어떤 엔지니어링 조직에게도 더 설득력있을 것입니다.</p>
<p>제품에 쉽게 접근할 수 있도록 옹호하는 영향력 있는 리더십 속에 있는 옹호자를 가지는 것이 가장 도움이 됩니다. 물론, 모든 조직이 다르기 때문에 이 조언을 적용할 때 결과가 다를 수 있습니다.</p>
<p>가장 중요한 것은, 이제 웹 접근성을 빠르게 적용하고 제품이 완전히 접근 가능한 상태라면?</p>
<p>공을 놓치지 마세요!</p>
<p>기술 부채와 마찬가지로, 이제 좋은 위치에 있으니 a11y를 표준 개발 워크플로에 통합할 수 있습니다. 이미 알고 계시니 빠르고 쉽게 할 수 있어요!</p>
<h1>결론</h1>
<p>오늘 많은 내용을 다뤘습니다.</p>
<p>먼저 앱을 감사하여 대화형 텍스트 스케일링 또는 VoiceOver를 사용할 때 발생하는 일반적인 접근성 오류를 확인하는 프로세스를 거쳤습니다.</p>
<p>텍스트 스케일링을 사용할 때 발생하는 문제를 수정하고, a11yScrollView로 스크롤링을 적용하고, @ScaledMetric으로 콘텐츠 스케일링하고, A11yHStack으로 정렬하는 방법을 살펴보았습니다.</p>
<p>화면 판독기에서 앱이 잘 작동하도록 만들기 위해 accessibilityLabels를 구현했고, accessibilityElements를 결합하고, 심지어 완전히 사용자 정의된 accessibilityRepresentations도 구현했습니다.</p>
<p>네이티브 SwiftUI 구성 요소 대신 사용자 지정보기를 사용하는 이유에 대해 논의했습니다. 이유로는 의미론, 상호 작용 모드 및 성능이 있습니다.</p>
<p>마침내, 당신이 조직 내에서 접근성에 진지하게 대응하기 위해 소프트 스킬을 적용하는 방법을 살펴보았습니다.</p>
<p>당신이 SwiftUI 앱에서 접근성에 진지하다면, 동반 앱을 통해 이러한 기술들을 직접 구현해보는 것을 적극 권장합니다. 도구를 체득하는 가장 좋은 방법이죠. 지금까지 작업해온 사이드 프로젝트가 있다면, 그것 역시 좋은 시작점일 것입니다.</p>
<p>내 A11yUtils 라이브러리에 기여 (문제 포함)를 기쁘게 받아들이겠습니다. 지금도 SwiftUI에 이미 있는 API를 보완하기 위한 포괄적인 접근성 도구 모음으로 이것을 발전시키기 위해 커뮤니티와 협력하고 싶어합니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"어이쿠, 내 앱이 성공했는데 접근성에 대해 생각하지 않았어요","description":"","date":"2024-05-17 18:44","slug":"2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility","content":"\n\n본인이 천재적인 앱 아이디어, 새로운 일자리, 또는 벤처 자본을 받았을 때, 새로운 기능을 배포하는 데만 시선을 집중하는 유혹이 감도는 건 이해합니다.\n\n올바른 방식으로 집중한다면, 이러한 집중은 앱을 다운로드 차트의 정상으로 랭킹시키며 성과를 거둘 수 있습니다. 그렇지만 그것으로 충분하지 않습니다. 모두가 본인의 앱을 사용하기 전까지 멈출 수 없을 겁니다.\n\n이런 믿을 수 없는 목표를 달성한 후, 현실적인 진실을 알아차립니다: 6명 중 1명이 본인의 앱이 고장나있다고 생각합니다.\n\n그런 다음, 깨닫게 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n16%의 사람들이 어떤 형태의 접근성(a11y - 멋진 친구 중 하나라면) 요구사항을 가지고 있습니다. 그러나 자유롭게 움직이면서 일할 때, 쉽게 a11y를 뒷전에 두는 경우가 많습니다. 특히 기한에 쫓기고 리더십으로부터 제한된 참여를 받을 때 말이죠.\n\n더 성공하게 되면, 사용자들의 접근성 요구를 인정하지 못한 것으로 비판받을 확률이 커집니다. 불행히도 이를 우선적으로 다루기가 어렵습니다. 영향력 있는 누군가가 접근성을 옹호하지 않는 한 말이죠.\n\n오늘은 도와드리겠습니다. 앱을 접근성에 맞춰 빠르게 개선하는 방법을 보여드릴게요:\n\n- SwiftUI 앱에서 a11y를 점검합니다.\n- 모든 텍스트 크기에서 앱을 잘 보이도록 만듭니다.\n- 화면 낭독기를 사용할 수 있게 만듭니다.\n- 이해관계자들을 설득하여 a11y를 우선시하도록 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 기사를 위해 특별히 만든 캣 테마 동반 앱을 살펴볼 것입니다. 표면 상으로는 괜찮아 보이지만, a11y(웹 접근성) 관점에서 평가를 시작하자마자 완전히 망가진 상태입니다.\n\n기술을 완전히 이해하고 싶다면, 코드를 함께 작성해보세요! 우리는 이 기사에서 자세히 다룬 모든 기술을 구현하기 위해 Before/ 폴더에서 시작합니다 (최종 및 개선된 앱은 After/ 폴더를 참조하세요).\n\n# 앱의 접근성(A11y) 감사\n\na11y(웹 접근성)를 제대로 이해하려면 실제 장치에서 접근성을 테스트해야 합니다. 이것이 모든 사용자가 앱과 상호 작용하는 방식입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n접근성(a11y) 작업을 진행할 때는, 먼저 컨트롤 센터를 최적화해야 합니다. 정말 대단한 시간을 절약할 수 있어요.\n\n아이폰 설정으로 이동하여, 컨트롤 센터에 \"텍스트 크기\" 컨트롤과 \"접근성 바로 가기\"를 추가해보세요. \"텍스트 크기\"를 추가하면, 어떤 어플에서든 어디서든 밑으로 스와이프하여 텍스트 크기를 즉시 선택할 수 있어요. 심지어 어플당 크기 조절도 가능해요.\n\n\"접근성 바로 가기\"를 추가하면, 어시스티브터치(AssistiveTouch), 보이스오버(VoiceOver), 색상 필터, 모션 감소 등 다양한 접근성 기능을 쉽게 적용할 수 있어요. 하지만 잠금 버튼을 세 번 누르면 동일한 메뉴가 나오기 때문에 더 쉽게 접근할 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 텍스트 크기 감사\n\niOS에서는 extraSmall부터 accessibilityExtraExtraExtraLarge(즉, AX5)까지 12가지의 텍스트 크기 옵션이 있습니다. 최대 크기인 accessibilityExtraExtraExtraLarge는 기본(큰) 크기보다 약 310%* 더 큽니다.\n\n텍스트 크기가 정상적으로 작동하는지 확인하기 위해 두 가지 감사를 선호합니다:\n\n- 앱을 가장 큰 일반 폰트인 extraExtraExtraLarge(즉, xxxl)로 테스트하고, 가급적 볼드 텍스트 접근성 설정도 활성화하세요. 이는 상대적으로 일반적인 가장 큰 폰트로, 제 어머니도 이 폰트를 사용합니다. 앱은 이 크기에서 잘 보여야 합니다.\n- 앱을 가장 큰 접근성 폰트인 AX5로 테스트하세요. 이 크기는 익숙하지 않다면 우스꽝스러울 수 있지만, 이 크기밖에는 앱과 상호작용할 수 있는 방법이 없는 사람들이 있습니다. UI를 이 크기로 완벽하게 만드는 것은 어려울지라도, 접근성 텍스트 크기 설정에서 앱이 작동하는지조차 확인하지 않은 회사는 명백히 부족합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저희 앱을 한 번 살펴보겠습니다.\n\n![앱 스크린샷](/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_1.png)\n\n바로 앱을 실행해보면, 정성껏 디자인한 로그인 UI가 텍스트 크기 조절 시 문제가 발생합니다. 저희는 대용량의 텍스트 크기를 예상하지 못했기 때문에 내용을 스크롤할 필요가 있다는 생각조차 하지 못했습니다.\n\n더 나아가서, 색맹일 경우 로그인 버튼의 대비가 미미하여 버튼을 읽을 수 없을 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리 앱의 메인 목록 화면도 확인해 봅시다.\n\n![Main List Screen](/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_2.png)\n\n이 화면은 덜 '부서지는' 느낌이 나요. 모든 것이 보이지만 액세스 가능한 크기의 폰트를 사용하는 사람에게는 이 크기에서 앱을 테스트하지 않았다는 것이 분명합니다. 공간을 다투는 텍스트 레이블이나 순창방에서 아이콘만큼 큰 캡션을 보세요.\n\n## 스크린 리더 오디트\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n일부 사용자는 텍스트 크기 조정에 영향을 받지 않습니다 — 그들은 앱과 상호 작용하기 위해 스크린 리더기가 필요할 수 있기 때문입니다.\n\niOS VoiceOver는 여기서의 중요한 작업을 훌륭하게 처리하므로 여러분 팀의 약간의 배려가 큰 차이를 만들어냅니다.\n\n텍스트 크기 감사와 마찬가지로 스크린 리더기 감사도 실제 기기에서 하는 것이 가장 좋습니다 (잠금 버튼을 3번 눌러보세요, 기억하세요!). 또한 Xcode에 내장된 개발자 도구인 접근성 검사 도구가 VoiceOver 작업에 도움이 됩니다.\n\n![2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_3.png](/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n앱을 통해 걸어가면, 텍스트 크기 조정과 비교하면 적어도 깨진 부분이 적은 편이에요. 하지만 이미지와 같은 많은 UI 영역이 전혀 보이지 않아 사용자에게 직접적인 지원이 되지 않아요. 그 이유는 접근성 레이블을 추가하는 데 신경을 쓰지 않았기 때문이죠.\n\n![이미지1](/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_4.png)\n\n특히 VoiceOver를 사용하지 않은 경우, 화면 리더기가 모든 UI 요소를 반복하며 읽어주지만 아이콘에는 라벨이 붙어있지 않아 명확합니다.\n\n![이미지2](/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_5.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n큰 목록이 있으면 상황이 더 악화됩니다.\n\nSwiftUI에 내용에 대한 정보를 제공하지 않으면, 스크롤 가능한 내용의 아래쪽 로그아웃 버튼으로 이동하려면 100번 이상 스와이프해야 할 수도 있는 상황에 처하게 될 수 있습니다. 페이징에 대해서 시작도 하지 마세요.\n\n![앱 접근성을 고려하지 않고 앱이 성공적이라고 생각하지 않은 경우 스크린샷](/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_6.png)\n\n우리 앱을 접근성이 좋은 앱이라고 부를 수 있기 전에 해결해야 할 문제가 많습니다. 다행히 SwiftUI에는 a11y에 대해 신속하게 파악할 수 있는 도구가 가득합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 스피드런 액세시빌리티\n\n이제 문제가 어디에 있는지 알았으니, 하나씩 빠르게 해결해 나갈 수 있어요.\n\n## 스크롤 가능한 콘텐츠\n\n이것은 가장 불편한 문제입니다. 큰 텍스트 크기에 대한 스크롤 뷰로 확장되지 않아 앱 온보딩이 완전히 망가졌어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리의 감사에서는 로그인 화면 버튼이 폰트 크기가 커짐에 따라 화면 밖으로 밀렸습니다. 나머지 텍스트 내용은 서로 밀어붙여져 레이블이 겹치고 확장할 공간이 없어 잘린 것처럼 보였어요.\n\n자연스러운 해결책은 콘텐츠를 스크롤 가능하도록 만드는 것입니다. 그러나 모든 화면이 컨텐츠가 잘 맞는 경우에도 스크롤이 자유롭게 되어서는 안 됩니다. 우리는 Ionic 앱을 만드는 일이 아니에요. *억압된 기억으로 전율을 느끼며*\n\n이 문제는 사용자 지정 뷰 수정자로 해결할 수 있습니다. 제가 a11yScrollView()라고 부르는 이 뷰 수정자의 목표는 화면 내용을 스크롤 뷰로 감싸지만 필요한 경우에만 발생하도록 하는 것입니다. 이것을 작은 라이브러리 A11yUtils에 추가하여 여러분의 코드에서 사용할 수 있도록 했어요.\n\n현재 이것은 iOS 16.4 이상에서만 우리의 꿈이 되는 동작을 실현합니다 — 이미 콘텐츠가 맞는 경우 스크롤을 방지하기 위해 스크롤 뷰에 scrollBounceBehavior를 적용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n미래에는 iOS 16에서 ViewThatFits* 및 iOS 15에서 GeometryReader와 함께 작동하도록하고 싶습니다.\n\nOS 버전을 지정하는 사람이 주위에 없기 때문에 저희 온보딩 뷰의 VStack에 이 수정자를 적용할 수 있습니다.\n\n```swift\n// OnboardingView.swift\n\nimport A11yUtils\nimport SwiftUI\n\nstruct OnboardingView: View {\n    \n    @Binding var isLoggedIn: Bool\n    \n    var body: some View {\n        NavigationStack {\n            VStack(spacing: 20) { /* ... */ }\n              .padding(.horizontal)\n              .a11yScrollView()\n              .navigationTitle(\"Create account\")\n        }\n    }\n}\n```\n\n이제 콘텐츠가 멋지게 스크롤되어 xxxl, AX3 및 AX5에서 잘 보입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_7.png\" /\u003e\n\n## 스페이서는 코드 냄새입니다\n\n온보딩 화면을 작업하는 동안, 우리가 할 수 있는 또 다른 간단한 개선 사항이 있습니다:\n\n```js\nVStack(spacing: 20) {\n    // ...\n    OnboardingReasonsText()\n    Spacer()\n    LoginButtonView()\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n텍스트 크기가 크면 화면 공간이 제한되어 Spacer()를 사용하면 문제가 발생할 수 있습니다. SwiftUI 레이아웃 엔진은 공간을 만들기 위해 열심히 노력합니다. 심지어 그 공간이 더 이상 없어도 텍스트가 절단되는 문제가 발생할 수 있습니다.\n\n이러한 시나리오에서 스페이서를 매우 좁은 높이로 압축해도 VStack에 정의된대로 위아래로 각각 20포인트의 공간이 생길 것입니다.\n\n우리는 Spacer()를 frame() 수정자로 바꿀 수 있습니다:\n\n```js\nVStack(spacing: 20) {\n    OnboardingReasonsText()\n    LoginButtonView()\n        .frame(maxHeight: .infinity, alignment: .bottom)\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프레임은 더 신뢰할 수 있는 방식으로 작동합니다: SwiftUI는 이 버튼 위에 가능한 한 많은 공간을 제공해야 함을 알지만, 여백 자체가 UI의 중요한 부분이 아니기 때문에 공간이 부족하면 불필요한 여백이 적용되지 않습니다.\n\n이 프레임 수정자는 의미가 더 명확합니다. 즉, SwiftUI에게 우리의 의도를 명확하게 전달합니다. 이것은 a11y와 관련된 중요한 개념이므로 나중에 더 자세히 다룰 것입니다.\n\n## 이미지와 아이콘의 확대\n\n다이나믹 타입 덕분에 iOS는 사용자가 선택한 글꼴 크기에 따라 앱 내 글꼴을 자동으로 확대합니다. 이것은 사용자 정의 글꼴과도 쉽게 구현할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이는 SwiftUI에서 의미있는 글꼴 크기를 사용할 때 텍스트가 자동으로 조절된다는 것을 의미합니다.\n\n```js\nText(cat.quote)\n    .font(.body) // 이것도 잘 작동합니다\n```\n\n더 좋은 것은 SFSymbols를 사용할 때 아이콘에도 동적 글꼴 크기를 적용할 수 있다는 것입니다!\n\n```js\nImage(systemName: \"heart.circle.fill\")\n    .font(.body) // 이것도 SFSymbols와 잘 작동합니다\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n안타깝게도 대부분의 iOS 앱에는 Android 버전이 있으므로, 디자이너가 SFSymbols을 사용하는 대신 맞춤 아이콘을 만든다는 점에 유의하셔야 합니다. 대부분의 앱은 사용자 정의 이미지와 미디어를 포함합니다.\n\n따라서 우리의 예시인 Before/에서는 아이콘을 SwiftUI에 추가하는 일반 이미지처럼 처리하여, 하드코딩된 크기를 사용했습니다.\n\n```js\nImage(cat.image)\n    .resizable()\n    .aspectRatio(contentMode: .fit)\n    .frame(width: 72, height: 72) // 하드코딩된 크기 - 확장되지 않을 것입니다!\n    .clipShape(Circle())\n\nImage(systemName: cat.icon)\n    .resizable()\n    .aspectRatio(contentMode: .fit)\n    .foregroundStyle(.secondary)\n    .frame(width: 24, height: 24) // 하드코딩된 크기 - 확장되지 않을 것입니다!\n```\n\n결과는 어떻게 될까요? 가장 큰 글꼴 크기로 조정했을 때, 콘텐츠가 매우 어울리지 않게 보일 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![image](/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_8.png)\n\nSwiftUI에는 사용자 정의 이미지 및 뷰에서 동적 타입의 파워를 제공하는 멋진 도구인 @ScaledMetric 프로퍼티 래퍼가 있습니다.\n\n```swift\n@ScaledMetric(relativeTo: .largeTitle) private var imageSize: CGFloat = 72\n@ScaledMetric(relativeTo: .body) private var iconSize: CGFloat = 24\n```\n\n우리는 @ScaledMetric을 자체로 사용할 수 있으며, 이는 기본 body 글꼴 크기 조정을 사용합니다. relativeTo를 사용하면 SwiftUI가 어떻게 조정할 지 알 수 있으므로 더 좋습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nlargeTitle은 이미 상당히 크기 때문에 조금 더 확장됩니다. 캡션 스타일의 글꼴은 더 많이 확장됩니다. 이 경우 아이콘은 본문 크기 조정이 되어 동반하는 인용문 텍스트와 일치합니다.\n\n```js\nImage(cat.image)\n    .resizable()\n    .aspectRatio(contentMode: .fit)\n    .frame(width: imageSize, height: imageSize) // 동적 크기 조정\n    .clipShape(Circle())\n\nImage(systemName: cat.icon)\n    .resizable()\n    .aspectRatio(contentMode: .fit)\n    .foregroundStyle(.secondary)\n    .frame(width: iconSize, height: iconSize) // 동적 크기 조정\n```\n\n이제 이미지가 텍스트와 함께 더 합리적으로 보입니다.\n\n\u003cimg src=\"/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_9.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 콘텐츠 정렬하기\n\n이미지는 더 잘 확장되지만, 여전히 텍스트 라벨이 공간을 지배하며 UI가 깨져 보입니다. 레이아웃 엔진과의 협상을 끝내고 나니, 줄바꿈으로 가득 차 있습니다.\n\n만약 사용자의 텍스트 확장에 기반한 컨텐츠의 정렬이 가능하다면 어떨까요?\n\n다행히도, 라이브러리 A11yUtils 덕분에 A11yHStack을 활용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n새로운 SwiftUI 도구 릴리스 속도가 빨라서 (그리고 Apple의 뒷전포기가 혹독해서), 이것은 최소 지원 OS에 기반을 둔 두 가지 다른 구현을 가지고 있어요:\n\n- iOS 16에서는 ViewThatFits를 사용하여 HStack이 모든 내용을 포함할 수 있는지 확인하고, 그렇지 않으면 내용을 정렬하기 위해 VStack을 사용합니다.\n- iOS 15에서는 더 단호한 방식을 적용하여, @Environment(\\.sizeCategory)를 확인하고, 접근성 텍스트 크기 범주 (예: AX1, AX2 또는 AX5) 가 사용된 경우에는 VStack으로 전환합니다.\n\n다음은 간단한 접근 방식입니다:\n\n```js\n@Environment(\\.sizeCategory) private var sizeCategory\n\nvar body: some View {\n    if sizeCategory.isAccessibilityCategory {\n        VStack(alignment: .leading, spacing: spacing) {\n            content()\n        }\n        .frame(maxWidth: .infinity, alignment: .leading)\n    } else {\n        HStack(alignment: alignment, spacing: spacing) {\n            content()\n        }\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n@Environment(\\.sizeCategory)은 중요한 경우에 사용할 수 있는 유용한 도구입니다. 사용자가 접근성 텍스트 크기 범주를 사용하는지 여부를 알아야 하는 경우 (isAccessibilityCategory와 함께). 때로는 이 속성을 사용하여 대량 콘텐츠 크기에 맞지 않는 이미지와 같은 불필요한 UI 요소를 제거하는 데 활용합니다.\n\n더 현대적인 구현은 비슷하게 동작하지만 ViewThatFits를 활용하여 콘텐츠가 맞지 않는 경우에만 재분배됩니다:\n\n```js\nvar body: some View {\n    ViewThatFits {\n        HStack(alignment: alignment, spacing: spacing) {\n            content()\n        }\n        VStack(alignment: .leading, spacing: spacing) {\n            content()\n        }.frame(maxWidth: .infinity, alignment: .leading)\n    }\n}\n```\n\n생각을 많이 해면 A11yHStack을 몇 군데에 적용할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport A11yUtils \n\nA11yHStack {\n    Image(cat.image)\n    VStack {\n        A11yHStack {\n            Text(cat.name)\n            Text(\"\\(cat.age) years old\")\n        }\n        HStack {\n            Image(systemName: cat.icon)\n            Text(cat.quote)\n        }\n    }\n}\n```\n\n이제 컨텐츠가 매우 큰 텍스트 크기에서 더 적절해 보입니다.\n\n\u003cimg src=\"/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_10.png\" /\u003e\n\n## 스크린 리더 개선사항\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n보이스오버는 퍼즐 조각 중 비교적 간단한 부분입니다.\n\n앱이 스크린 리더와 잘 작동하도록 만드는 것은:\n\n- 시각적 콘텐츠가 충분히 설명되었는지 확인하기.\n- 탐색이 직관적으로 작동되도록 만들기.\n- 뷰가 의미론적으로 올바른지 확인하기.\n\n먼저 시각적 설명부터 시작해보죠. 이것은 우리 레퍼토리에서 가장 간단한 수정 사항입니다: 그래픽 콘텐츠가 VoiceOver에 의해 설명될 수 있도록 보장하는 것입니다. accessibilityLabel 수정자가 우리의 책과 버터라고 할 수 있죠.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nImage(\"catKingdom\")\n    .accessibilityLabel(Text(\"나의 세 마리 고양이: 코디, 로지, 루나\"))\n```\n\n스크린리더가 현재 초점을 맞춘 대상을 설명하는 방법을 알려줍니다.\n\n![Cat Kingdom](/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_11.png)\n\n이제 주 뷰의 셀에 동일한 방식을 적용할 수 있습니다. Cat 데이터 모델을 약간 수정하여 각 고양이 사진과 함께 이미지 설명을 제공합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nstruct Cat {\n    // ...\n    let imageDescription: String\n}\n\nImage(cat.image)\n    .accessibilityLabel(Text(cat.imageDescription))\n```\n\n\n이건 들릴만큼 쉽고, Apple 플랫폼에서만 작동하는 경향이 있어요.\n\n![image](/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_12.png)\n\n우리 앱을 통해 탐색할 때, 좀 더 신중하게 할 수 있는 기회가 있어요. 기본 설정으로 VoiceOver는 SwiftUI 뷰 트리의 모든 잎 노드를 반복하며 모든 이미지, 버튼 및 텍스트를 읽어줄 거예요.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n가끔 사용자에게 불필요한 탐색을 초래합니다. 저희 앱에서는 각 고양이의 아이콘과 인용구를 건너뛰려면 여러 번 탭해야 합니다. 아이콘의 이름(예: cat.fill)을 읽는 것은 경험에 별다른 도움이 되지 않습니다.\n\n이들을 단일 a11y 요소로 결합하여 screenreader가 탐색 중에 하나의 항목으로 처리할 수 있도록 할 수 있습니다.\n\n```swift\nHStack {\n    Image(systemName: cat.icon)\n    Text(cat.quote)\n}\n.accessibilityElement(children: .combine)\n```\n\n이제 screenreader가 요소를 하나로 이동하는 것을 들을 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![image](/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_13.png)\n\n어떤 상황에서는 그래픽적으로 시간이 표시되는 셀렉트한 타이머 요소와 같이 복잡한 UI가 있을 수 있습니다. VoiceOver는 똑똑하지만, 설명되지 않은 뷰들의 번잡한 모음에서 유용한 정보를 유추하지는 못합니다.\n\n여기서 accessibilityRepresentation 수정자가 정말 유용하게 사용됩니다. 이를 통해 뷰의 VoiceOver UI를 완전히 사용자 정의된 접근성 표현으로 대체할 수 있습니다.\n\n최근에 개발한 개인 프로젝트 'Check 'em'에서는 사용자의 2단계 인증 코드가 카운트다운과 함께 표시되어 해당 기능이 특히 유용했습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```swift\n// AccountView.swift\n\nstruct AccountView: View {\n    \n    var body: some View {\n        Section(account.name) {\n            // Image, 2FA Code Text, and Countdown UI ...\n        }\n        .accessibilityRepresentation {\n            VStack {\n                Text(account.name)\n                if let code = account.code {\n                    ForEach(Array(code.enumerated()), id: \\.0) {\n                        Text(String($0.1))\n                    }\n                }\n                if let countdown = account.countdown {\n                    Text(\"Expires in \\(countdown)\")\n                }\n            }.accessibilityElement(children: .combine)\n        }\n    }\n```\n\n이 modifier를 사용하여 각 셀 요소를 순서대로 반복하는 것보다 훨씬 유용한 완전히 사용자 정의 된 VoiceOver 인터페이스를 소개할 수 있었습니다. 또한 화면 낭독기가 \"676,252\"를 \"육십 칠만 육천 이백 오십 이\"로 읽는 것을 방지했습니다.\n\n![Screenshot](/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_14.png)\n\n## Native components\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 어플리케이션의 주요 뷰는 저희 콘텐츠를 배치하는 일반적이지만 조잡한 방법을 사용합니다: ForEach 내에 있는 셀을 래핑하는 방식으로 LazyVStack을 래핑하고 ScrollView로 래핑합니다.\n\n```js\nScrollView {\n    LazyVStack(spacing: 24) {\n        ForEach(cats, id: \\.name) {\n            CatView(cat: $0)\n        }\n    }\n}\n```\n\n최적의 방법은 가능한 한 SwiftUI의 기본 구성 요소를 활용하는 것입니다. 이 경우에는 List가 가장 적합합니다.\n\nApple은 사용자 정의 UI 대신 iOS-Settings 스타일의 List를 사용하려면 모디파이어를 3개 추가해야 한다는 점을 설명할 때, 이 작업을 좀 더 어렵게 만들어 놓았습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n목록(고양이) {\n    고양이뷰(고양이: $0)\n        .목록행배경(Color.clear)\n        .목록행구분선(.숨김)\n}\n.목록스타일(일반목록스타일())\n```\n\n이제 보일러플레이트를 작성했으니 수정자들을 자유롭게 사용하여 SwiftUI 목록에서 자체 UI를 사용할 수 있습니다.\n\n\u003cimg src=\"/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_15.png\" /\u003e\n\n한 가지 질문이 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n왜 네이티브 컴포넌트를 사용하는 것에 이렇게 많은 노력을 기울일까요?\n\n먼저, 비 접근성(a11y) 관련 이유: SwiftUI List는 UICollectionView를 사용하여 구현됩니다. 이는 고성능 스크롤링을 위해 셀 재사용을 활용하며 항목이 많아도 성능을 유지합니다. 그에 반해 LazyVStack은 이전에 렌더링된 모든 셀을 메모리에 유지하므로 많은 항목을 스크롤하는 경우 성능이 뚝뚝 떨어집니다.\n\n네이티브 컴포넌트를 사용하는 a11y 관련 이유는 간단하지만 다양합니다:\n\nList는 의미론적 의미가 있습니다: 화면 판독기에게 비슷한 콘텐츠 컬렉션을 포함하는 컨테이너임을 알려줍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이것이 많은 목록 항목이 있는 경우, 순진한 구현이 망가진 이유입니다: VoiceOver로 목록 컨테이너를 건너뛸 수 있게 해주지 않고 모든 항목을 스와이프해야만 로그아웃 버튼에 도달할 수 있었습니다.\n\nList를 사용하면 SwiftUI가 화면 판독기에게 그 내용이 단일 컨테이너임을 알려줄 수 있어, 화면 판독기가 쉽게 이동할 수 있습니다.\n\n아래는 Markdown 형식으로 변경된 이미지 링크입니다:\n\n![이미지](/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_16.png)\n\n또한 List에는 스와이프 삭제, 드래그 앤 드롭, 키보드 기반 탐색 등 많은 내장 상호작용 모드가 있습니다. 네이티브 컴포넌트를 사용할 때 이들은 자동으로 작동합니다. 사용자 지정 구현과 함께 하는 화면 판독기 작업을 어떻게 할 것인지 아시겠습니까?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n리스트는 심지어 가장 복잡한 컴포넌트도 아닙니다. 사용자 정의 그리드나 레이아웃 프로토콜을 사용하지 않는 뷰의 사용자 정의 분배에 a11y를 어떻게 구현할 것인가요?\n\n# 이해관계자 설득\n\n이제 SwiftUI 앱에서 a11y를 빠르게 실행하는 방법을 이해했으니, 작업에 착수하기 전에 남은 퍼즐 조각은 비즈니스의 나머지 구성원으로부터 승인을 얻는 것입니다. 여기서 당신이 조직적 영향력을 행사하는 소프트 스킬을 펼칠 수 있습니다.\n\n당신이 휘둘 수 있는 큰, 둔한 도구 중 하나는 입법의 망치입니다. 영국, 미국, 그리고 EU와 같은 세계 각국은 디지털 서비스가 접근성의 최소 기준을 충족해야 한다는 법률을 시행했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n또한, 웹 접근성(웹 콘텐츠 접근성)은 실제로 비즈니스에서 큰 이점을 제공합니다. 현재 세계 인구의 16%가 중요한 장애를 겪고 있습니다. 즉, 다양한 요구에 맞게 서비스를 제공함으로써 사용자, 긍정적인 리뷰 및 수익을 놓칠 수 있습니다. 대상 시장에 따라 이는 더 또는 덜 중요할 수 있습니다.\n\n작은 규모에서는, 접근성을 제품 부채로 다루는 것보다 앱이 어떻게 오작동하는지 간단히 보여주는 것이 훨씬 효과적이라는 것을 발견했습니다. 접근성 요구사항을 추상적인 개념에서 벗어나서 버그 있는 가입 플로우를 보여주는 것이 어떤 엔지니어링 조직에게도 더 설득력있을 것입니다.\n\n제품에 쉽게 접근할 수 있도록 옹호하는 영향력 있는 리더십 속에 있는 옹호자를 가지는 것이 가장 도움이 됩니다. 물론, 모든 조직이 다르기 때문에 이 조언을 적용할 때 결과가 다를 수 있습니다.\n\n가장 중요한 것은, 이제 웹 접근성을 빠르게 적용하고 제품이 완전히 접근 가능한 상태라면?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n공을 놓치지 마세요!\n\n기술 부채와 마찬가지로, 이제 좋은 위치에 있으니 a11y를 표준 개발 워크플로에 통합할 수 있습니다. 이미 알고 계시니 빠르고 쉽게 할 수 있어요!\n\n# 결론\n\n오늘 많은 내용을 다뤘습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n먼저 앱을 감사하여 대화형 텍스트 스케일링 또는 VoiceOver를 사용할 때 발생하는 일반적인 접근성 오류를 확인하는 프로세스를 거쳤습니다.\n\n텍스트 스케일링을 사용할 때 발생하는 문제를 수정하고, a11yScrollView로 스크롤링을 적용하고, @ScaledMetric으로 콘텐츠 스케일링하고, A11yHStack으로 정렬하는 방법을 살펴보았습니다.\n\n화면 판독기에서 앱이 잘 작동하도록 만들기 위해 accessibilityLabels를 구현했고, accessibilityElements를 결합하고, 심지어 완전히 사용자 정의된 accessibilityRepresentations도 구현했습니다.\n\n네이티브 SwiftUI 구성 요소 대신 사용자 지정보기를 사용하는 이유에 대해 논의했습니다. 이유로는 의미론, 상호 작용 모드 및 성능이 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마침내, 당신이 조직 내에서 접근성에 진지하게 대응하기 위해 소프트 스킬을 적용하는 방법을 살펴보았습니다.\n\n당신이 SwiftUI 앱에서 접근성에 진지하다면, 동반 앱을 통해 이러한 기술들을 직접 구현해보는 것을 적극 권장합니다. 도구를 체득하는 가장 좋은 방법이죠. 지금까지 작업해온 사이드 프로젝트가 있다면, 그것 역시 좋은 시작점일 것입니다.\n\n내 A11yUtils 라이브러리에 기여 (문제 포함)를 기쁘게 받아들이겠습니다. 지금도 SwiftUI에 이미 있는 API를 보완하기 위한 포괄적인 접근성 도구 모음으로 이것을 발전시키기 위해 커뮤니티와 협력하고 싶어합니다.","ogImage":{"url":"/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_0.png"},"coverImage":"/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_0.png","tag":["Tech"],"readingTime":17},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e본인이 천재적인 앱 아이디어, 새로운 일자리, 또는 벤처 자본을 받았을 때, 새로운 기능을 배포하는 데만 시선을 집중하는 유혹이 감도는 건 이해합니다.\u003c/p\u003e\n\u003cp\u003e올바른 방식으로 집중한다면, 이러한 집중은 앱을 다운로드 차트의 정상으로 랭킹시키며 성과를 거둘 수 있습니다. 그렇지만 그것으로 충분하지 않습니다. 모두가 본인의 앱을 사용하기 전까지 멈출 수 없을 겁니다.\u003c/p\u003e\n\u003cp\u003e이런 믿을 수 없는 목표를 달성한 후, 현실적인 진실을 알아차립니다: 6명 중 1명이 본인의 앱이 고장나있다고 생각합니다.\u003c/p\u003e\n\u003cp\u003e그런 다음, 깨닫게 됩니다.\u003c/p\u003e\n\u003cp\u003e16%의 사람들이 어떤 형태의 접근성(a11y - 멋진 친구 중 하나라면) 요구사항을 가지고 있습니다. 그러나 자유롭게 움직이면서 일할 때, 쉽게 a11y를 뒷전에 두는 경우가 많습니다. 특히 기한에 쫓기고 리더십으로부터 제한된 참여를 받을 때 말이죠.\u003c/p\u003e\n\u003cp\u003e더 성공하게 되면, 사용자들의 접근성 요구를 인정하지 못한 것으로 비판받을 확률이 커집니다. 불행히도 이를 우선적으로 다루기가 어렵습니다. 영향력 있는 누군가가 접근성을 옹호하지 않는 한 말이죠.\u003c/p\u003e\n\u003cp\u003e오늘은 도와드리겠습니다. 앱을 접근성에 맞춰 빠르게 개선하는 방법을 보여드릴게요:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eSwiftUI 앱에서 a11y를 점검합니다.\u003c/li\u003e\n\u003cli\u003e모든 텍스트 크기에서 앱을 잘 보이도록 만듭니다.\u003c/li\u003e\n\u003cli\u003e화면 낭독기를 사용할 수 있게 만듭니다.\u003c/li\u003e\n\u003cli\u003e이해관계자들을 설득하여 a11y를 우선시하도록 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이 기사를 위해 특별히 만든 캣 테마 동반 앱을 살펴볼 것입니다. 표면 상으로는 괜찮아 보이지만, a11y(웹 접근성) 관점에서 평가를 시작하자마자 완전히 망가진 상태입니다.\u003c/p\u003e\n\u003cp\u003e기술을 완전히 이해하고 싶다면, 코드를 함께 작성해보세요! 우리는 이 기사에서 자세히 다룬 모든 기술을 구현하기 위해 Before/ 폴더에서 시작합니다 (최종 및 개선된 앱은 After/ 폴더를 참조하세요).\u003c/p\u003e\n\u003ch1\u003e앱의 접근성(A11y) 감사\u003c/h1\u003e\n\u003cp\u003ea11y(웹 접근성)를 제대로 이해하려면 실제 장치에서 접근성을 테스트해야 합니다. 이것이 모든 사용자가 앱과 상호 작용하는 방식입니다.\u003c/p\u003e\n\u003cp\u003e접근성(a11y) 작업을 진행할 때는, 먼저 컨트롤 센터를 최적화해야 합니다. 정말 대단한 시간을 절약할 수 있어요.\u003c/p\u003e\n\u003cp\u003e아이폰 설정으로 이동하여, 컨트롤 센터에 \"텍스트 크기\" 컨트롤과 \"접근성 바로 가기\"를 추가해보세요. \"텍스트 크기\"를 추가하면, 어떤 어플에서든 어디서든 밑으로 스와이프하여 텍스트 크기를 즉시 선택할 수 있어요. 심지어 어플당 크기 조절도 가능해요.\u003c/p\u003e\n\u003cp\u003e\"접근성 바로 가기\"를 추가하면, 어시스티브터치(AssistiveTouch), 보이스오버(VoiceOver), 색상 필터, 모션 감소 등 다양한 접근성 기능을 쉽게 적용할 수 있어요. 하지만 잠금 버튼을 세 번 누르면 동일한 메뉴가 나오기 때문에 더 쉽게 접근할 수 있어요.\u003c/p\u003e\n\u003ch2\u003e텍스트 크기 감사\u003c/h2\u003e\n\u003cp\u003eiOS에서는 extraSmall부터 accessibilityExtraExtraExtraLarge(즉, AX5)까지 12가지의 텍스트 크기 옵션이 있습니다. 최대 크기인 accessibilityExtraExtraExtraLarge는 기본(큰) 크기보다 약 310%* 더 큽니다.\u003c/p\u003e\n\u003cp\u003e텍스트 크기가 정상적으로 작동하는지 확인하기 위해 두 가지 감사를 선호합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e앱을 가장 큰 일반 폰트인 extraExtraExtraLarge(즉, xxxl)로 테스트하고, 가급적 볼드 텍스트 접근성 설정도 활성화하세요. 이는 상대적으로 일반적인 가장 큰 폰트로, 제 어머니도 이 폰트를 사용합니다. 앱은 이 크기에서 잘 보여야 합니다.\u003c/li\u003e\n\u003cli\u003e앱을 가장 큰 접근성 폰트인 AX5로 테스트하세요. 이 크기는 익숙하지 않다면 우스꽝스러울 수 있지만, 이 크기밖에는 앱과 상호작용할 수 있는 방법이 없는 사람들이 있습니다. UI를 이 크기로 완벽하게 만드는 것은 어려울지라도, 접근성 텍스트 크기 설정에서 앱이 작동하는지조차 확인하지 않은 회사는 명백히 부족합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e저희 앱을 한 번 살펴보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_1.png\" alt=\"앱 스크린샷\"\u003e\u003c/p\u003e\n\u003cp\u003e바로 앱을 실행해보면, 정성껏 디자인한 로그인 UI가 텍스트 크기 조절 시 문제가 발생합니다. 저희는 대용량의 텍스트 크기를 예상하지 못했기 때문에 내용을 스크롤할 필요가 있다는 생각조차 하지 못했습니다.\u003c/p\u003e\n\u003cp\u003e더 나아가서, 색맹일 경우 로그인 버튼의 대비가 미미하여 버튼을 읽을 수 없을 것입니다.\u003c/p\u003e\n\u003cp\u003e우리 앱의 메인 목록 화면도 확인해 봅시다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_2.png\" alt=\"Main List Screen\"\u003e\u003c/p\u003e\n\u003cp\u003e이 화면은 덜 '부서지는' 느낌이 나요. 모든 것이 보이지만 액세스 가능한 크기의 폰트를 사용하는 사람에게는 이 크기에서 앱을 테스트하지 않았다는 것이 분명합니다. 공간을 다투는 텍스트 레이블이나 순창방에서 아이콘만큼 큰 캡션을 보세요.\u003c/p\u003e\n\u003ch2\u003e스크린 리더 오디트\u003c/h2\u003e\n\u003cp\u003e일부 사용자는 텍스트 크기 조정에 영향을 받지 않습니다 — 그들은 앱과 상호 작용하기 위해 스크린 리더기가 필요할 수 있기 때문입니다.\u003c/p\u003e\n\u003cp\u003eiOS VoiceOver는 여기서의 중요한 작업을 훌륭하게 처리하므로 여러분 팀의 약간의 배려가 큰 차이를 만들어냅니다.\u003c/p\u003e\n\u003cp\u003e텍스트 크기 감사와 마찬가지로 스크린 리더기 감사도 실제 기기에서 하는 것이 가장 좋습니다 (잠금 버튼을 3번 눌러보세요, 기억하세요!). 또한 Xcode에 내장된 개발자 도구인 접근성 검사 도구가 VoiceOver 작업에 도움이 됩니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_3.png\" alt=\"2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_3.png\"\u003e\u003c/p\u003e\n\u003cp\u003e앱을 통해 걸어가면, 텍스트 크기 조정과 비교하면 적어도 깨진 부분이 적은 편이에요. 하지만 이미지와 같은 많은 UI 영역이 전혀 보이지 않아 사용자에게 직접적인 지원이 되지 않아요. 그 이유는 접근성 레이블을 추가하는 데 신경을 쓰지 않았기 때문이죠.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_4.png\" alt=\"이미지1\"\u003e\u003c/p\u003e\n\u003cp\u003e특히 VoiceOver를 사용하지 않은 경우, 화면 리더기가 모든 UI 요소를 반복하며 읽어주지만 아이콘에는 라벨이 붙어있지 않아 명확합니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_5.png\" alt=\"이미지2\"\u003e\u003c/p\u003e\n\u003cp\u003e큰 목록이 있으면 상황이 더 악화됩니다.\u003c/p\u003e\n\u003cp\u003eSwiftUI에 내용에 대한 정보를 제공하지 않으면, 스크롤 가능한 내용의 아래쪽 로그아웃 버튼으로 이동하려면 100번 이상 스와이프해야 할 수도 있는 상황에 처하게 될 수 있습니다. 페이징에 대해서 시작도 하지 마세요.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_6.png\" alt=\"앱 접근성을 고려하지 않고 앱이 성공적이라고 생각하지 않은 경우 스크린샷\"\u003e\u003c/p\u003e\n\u003cp\u003e우리 앱을 접근성이 좋은 앱이라고 부를 수 있기 전에 해결해야 할 문제가 많습니다. 다행히 SwiftUI에는 a11y에 대해 신속하게 파악할 수 있는 도구가 가득합니다.\u003c/p\u003e\n\u003ch1\u003e스피드런 액세시빌리티\u003c/h1\u003e\n\u003cp\u003e이제 문제가 어디에 있는지 알았으니, 하나씩 빠르게 해결해 나갈 수 있어요.\u003c/p\u003e\n\u003ch2\u003e스크롤 가능한 콘텐츠\u003c/h2\u003e\n\u003cp\u003e이것은 가장 불편한 문제입니다. 큰 텍스트 크기에 대한 스크롤 뷰로 확장되지 않아 앱 온보딩이 완전히 망가졌어요.\u003c/p\u003e\n\u003cp\u003e우리의 감사에서는 로그인 화면 버튼이 폰트 크기가 커짐에 따라 화면 밖으로 밀렸습니다. 나머지 텍스트 내용은 서로 밀어붙여져 레이블이 겹치고 확장할 공간이 없어 잘린 것처럼 보였어요.\u003c/p\u003e\n\u003cp\u003e자연스러운 해결책은 콘텐츠를 스크롤 가능하도록 만드는 것입니다. 그러나 모든 화면이 컨텐츠가 잘 맞는 경우에도 스크롤이 자유롭게 되어서는 안 됩니다. 우리는 Ionic 앱을 만드는 일이 아니에요. \u003cem\u003e억압된 기억으로 전율을 느끼며\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e이 문제는 사용자 지정 뷰 수정자로 해결할 수 있습니다. 제가 a11yScrollView()라고 부르는 이 뷰 수정자의 목표는 화면 내용을 스크롤 뷰로 감싸지만 필요한 경우에만 발생하도록 하는 것입니다. 이것을 작은 라이브러리 A11yUtils에 추가하여 여러분의 코드에서 사용할 수 있도록 했어요.\u003c/p\u003e\n\u003cp\u003e현재 이것은 iOS 16.4 이상에서만 우리의 꿈이 되는 동작을 실현합니다 — 이미 콘텐츠가 맞는 경우 스크롤을 방지하기 위해 스크롤 뷰에 scrollBounceBehavior를 적용합니다.\u003c/p\u003e\n\u003cp\u003e미래에는 iOS 16에서 ViewThatFits* 및 iOS 15에서 GeometryReader와 함께 작동하도록하고 싶습니다.\u003c/p\u003e\n\u003cp\u003eOS 버전을 지정하는 사람이 주위에 없기 때문에 저희 온보딩 뷰의 VStack에 이 수정자를 적용할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-swift\"\u003e\u003cspan class=\"hljs-comment\"\u003e// OnboardingView.swift\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e A11yUtils\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e SwiftUI\n\n\u003cspan class=\"hljs-keyword\"\u003estruct\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eOnboardingView\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e {\n    \n    \u003cspan class=\"hljs-meta\"\u003e@Binding\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e isLoggedIn: \u003cspan class=\"hljs-type\"\u003eBool\u003c/span\u003e\n    \n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e body: \u003cspan class=\"hljs-keyword\"\u003esome\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eView\u003c/span\u003e {\n        \u003cspan class=\"hljs-type\"\u003eNavigationStack\u003c/span\u003e {\n            \u003cspan class=\"hljs-type\"\u003eVStack\u003c/span\u003e(spacing: \u003cspan class=\"hljs-number\"\u003e20\u003c/span\u003e) { \u003cspan class=\"hljs-comment\"\u003e/* ... */\u003c/span\u003e }\n              .padding(.horizontal)\n              .a11yScrollView()\n              .navigationTitle(\u003cspan class=\"hljs-string\"\u003e\"Create account\"\u003c/span\u003e)\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 콘텐츠가 멋지게 스크롤되어 xxxl, AX3 및 AX5에서 잘 보입니다.\u003c/p\u003e\n\u003ch2\u003e스페이서는 코드 냄새입니다\u003c/h2\u003e\n\u003cp\u003e온보딩 화면을 작업하는 동안, 우리가 할 수 있는 또 다른 간단한 개선 사항이 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eVStack\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003espacing\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e20\u003c/span\u003e) {\n    \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n    \u003cspan class=\"hljs-title class_\"\u003eOnboardingReasonsText\u003c/span\u003e()\n    \u003cspan class=\"hljs-title class_\"\u003eSpacer\u003c/span\u003e()\n    \u003cspan class=\"hljs-title class_\"\u003eLoginButtonView\u003c/span\u003e()\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e텍스트 크기가 크면 화면 공간이 제한되어 Spacer()를 사용하면 문제가 발생할 수 있습니다. SwiftUI 레이아웃 엔진은 공간을 만들기 위해 열심히 노력합니다. 심지어 그 공간이 더 이상 없어도 텍스트가 절단되는 문제가 발생할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이러한 시나리오에서 스페이서를 매우 좁은 높이로 압축해도 VStack에 정의된대로 위아래로 각각 20포인트의 공간이 생길 것입니다.\u003c/p\u003e\n\u003cp\u003e우리는 Spacer()를 frame() 수정자로 바꿀 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eVStack\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003espacing\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e20\u003c/span\u003e) {\n    \u003cspan class=\"hljs-title class_\"\u003eOnboardingReasonsText\u003c/span\u003e()\n    \u003cspan class=\"hljs-title class_\"\u003eLoginButtonView\u003c/span\u003e()\n        .\u003cspan class=\"hljs-title function_\"\u003eframe\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003emaxHeight\u003c/span\u003e: .\u003cspan class=\"hljs-property\"\u003einfinity\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003ealignment\u003c/span\u003e: .\u003cspan class=\"hljs-property\"\u003ebottom\u003c/span\u003e)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e프레임은 더 신뢰할 수 있는 방식으로 작동합니다: SwiftUI는 이 버튼 위에 가능한 한 많은 공간을 제공해야 함을 알지만, 여백 자체가 UI의 중요한 부분이 아니기 때문에 공간이 부족하면 불필요한 여백이 적용되지 않습니다.\u003c/p\u003e\n\u003cp\u003e이 프레임 수정자는 의미가 더 명확합니다. 즉, SwiftUI에게 우리의 의도를 명확하게 전달합니다. 이것은 a11y와 관련된 중요한 개념이므로 나중에 더 자세히 다룰 것입니다.\u003c/p\u003e\n\u003ch2\u003e이미지와 아이콘의 확대\u003c/h2\u003e\n\u003cp\u003e다이나믹 타입 덕분에 iOS는 사용자가 선택한 글꼴 크기에 따라 앱 내 글꼴을 자동으로 확대합니다. 이것은 사용자 정의 글꼴과도 쉽게 구현할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이는 SwiftUI에서 의미있는 글꼴 크기를 사용할 때 텍스트가 자동으로 조절된다는 것을 의미합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e(cat.\u003cspan class=\"hljs-property\"\u003equote\u003c/span\u003e)\n    .\u003cspan class=\"hljs-title function_\"\u003efont\u003c/span\u003e(.\u003cspan class=\"hljs-property\"\u003ebody\u003c/span\u003e) \u003cspan class=\"hljs-comment\"\u003e// 이것도 잘 작동합니다\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e더 좋은 것은 SFSymbols를 사용할 때 아이콘에도 동적 글꼴 크기를 적용할 수 있다는 것입니다!\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eImage\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003esystemName\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"heart.circle.fill\"\u003c/span\u003e)\n    .\u003cspan class=\"hljs-title function_\"\u003efont\u003c/span\u003e(.\u003cspan class=\"hljs-property\"\u003ebody\u003c/span\u003e) \u003cspan class=\"hljs-comment\"\u003e// 이것도 SFSymbols와 잘 작동합니다\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e안타깝게도 대부분의 iOS 앱에는 Android 버전이 있으므로, 디자이너가 SFSymbols을 사용하는 대신 맞춤 아이콘을 만든다는 점에 유의하셔야 합니다. 대부분의 앱은 사용자 정의 이미지와 미디어를 포함합니다.\u003c/p\u003e\n\u003cp\u003e따라서 우리의 예시인 Before/에서는 아이콘을 SwiftUI에 추가하는 일반 이미지처럼 처리하여, 하드코딩된 크기를 사용했습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eImage\u003c/span\u003e(cat.\u003cspan class=\"hljs-property\"\u003eimage\u003c/span\u003e)\n    .\u003cspan class=\"hljs-title function_\"\u003eresizable\u003c/span\u003e()\n    .\u003cspan class=\"hljs-title function_\"\u003easpectRatio\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003econtentMode\u003c/span\u003e: .\u003cspan class=\"hljs-property\"\u003efit\u003c/span\u003e)\n    .\u003cspan class=\"hljs-title function_\"\u003eframe\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003ewidth\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e72\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003eheight\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e72\u003c/span\u003e) \u003cspan class=\"hljs-comment\"\u003e// 하드코딩된 크기 - 확장되지 않을 것입니다!\u003c/span\u003e\n    .\u003cspan class=\"hljs-title function_\"\u003eclipShape\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eCircle\u003c/span\u003e())\n\n\u003cspan class=\"hljs-title class_\"\u003eImage\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003esystemName\u003c/span\u003e: cat.\u003cspan class=\"hljs-property\"\u003eicon\u003c/span\u003e)\n    .\u003cspan class=\"hljs-title function_\"\u003eresizable\u003c/span\u003e()\n    .\u003cspan class=\"hljs-title function_\"\u003easpectRatio\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003econtentMode\u003c/span\u003e: .\u003cspan class=\"hljs-property\"\u003efit\u003c/span\u003e)\n    .\u003cspan class=\"hljs-title function_\"\u003eforegroundStyle\u003c/span\u003e(.\u003cspan class=\"hljs-property\"\u003esecondary\u003c/span\u003e)\n    .\u003cspan class=\"hljs-title function_\"\u003eframe\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003ewidth\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e24\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003eheight\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e24\u003c/span\u003e) \u003cspan class=\"hljs-comment\"\u003e// 하드코딩된 크기 - 확장되지 않을 것입니다!\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e결과는 어떻게 될까요? 가장 큰 글꼴 크기로 조정했을 때, 콘텐츠가 매우 어울리지 않게 보일 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_8.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003eSwiftUI에는 사용자 정의 이미지 및 뷰에서 동적 타입의 파워를 제공하는 멋진 도구인 @ScaledMetric 프로퍼티 래퍼가 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-swift\"\u003e\u003cspan class=\"hljs-meta\"\u003e@ScaledMetric\u003c/span\u003e(relativeTo: .largeTitle) \u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e imageSize: \u003cspan class=\"hljs-type\"\u003eCGFloat\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e72\u003c/span\u003e\n\u003cspan class=\"hljs-meta\"\u003e@ScaledMetric\u003c/span\u003e(relativeTo: .body) \u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e iconSize: \u003cspan class=\"hljs-type\"\u003eCGFloat\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e24\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e우리는 @ScaledMetric을 자체로 사용할 수 있으며, 이는 기본 body 글꼴 크기 조정을 사용합니다. relativeTo를 사용하면 SwiftUI가 어떻게 조정할 지 알 수 있으므로 더 좋습니다.\u003c/p\u003e\n\u003cp\u003elargeTitle은 이미 상당히 크기 때문에 조금 더 확장됩니다. 캡션 스타일의 글꼴은 더 많이 확장됩니다. 이 경우 아이콘은 본문 크기 조정이 되어 동반하는 인용문 텍스트와 일치합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eImage\u003c/span\u003e(cat.\u003cspan class=\"hljs-property\"\u003eimage\u003c/span\u003e)\n    .\u003cspan class=\"hljs-title function_\"\u003eresizable\u003c/span\u003e()\n    .\u003cspan class=\"hljs-title function_\"\u003easpectRatio\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003econtentMode\u003c/span\u003e: .\u003cspan class=\"hljs-property\"\u003efit\u003c/span\u003e)\n    .\u003cspan class=\"hljs-title function_\"\u003eframe\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003ewidth\u003c/span\u003e: imageSize, \u003cspan class=\"hljs-attr\"\u003eheight\u003c/span\u003e: imageSize) \u003cspan class=\"hljs-comment\"\u003e// 동적 크기 조정\u003c/span\u003e\n    .\u003cspan class=\"hljs-title function_\"\u003eclipShape\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eCircle\u003c/span\u003e())\n\n\u003cspan class=\"hljs-title class_\"\u003eImage\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003esystemName\u003c/span\u003e: cat.\u003cspan class=\"hljs-property\"\u003eicon\u003c/span\u003e)\n    .\u003cspan class=\"hljs-title function_\"\u003eresizable\u003c/span\u003e()\n    .\u003cspan class=\"hljs-title function_\"\u003easpectRatio\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003econtentMode\u003c/span\u003e: .\u003cspan class=\"hljs-property\"\u003efit\u003c/span\u003e)\n    .\u003cspan class=\"hljs-title function_\"\u003eforegroundStyle\u003c/span\u003e(.\u003cspan class=\"hljs-property\"\u003esecondary\u003c/span\u003e)\n    .\u003cspan class=\"hljs-title function_\"\u003eframe\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003ewidth\u003c/span\u003e: iconSize, \u003cspan class=\"hljs-attr\"\u003eheight\u003c/span\u003e: iconSize) \u003cspan class=\"hljs-comment\"\u003e// 동적 크기 조정\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 이미지가 텍스트와 함께 더 합리적으로 보입니다.\u003c/p\u003e\n\u003ch2\u003e콘텐츠 정렬하기\u003c/h2\u003e\n\u003cp\u003e이미지는 더 잘 확장되지만, 여전히 텍스트 라벨이 공간을 지배하며 UI가 깨져 보입니다. 레이아웃 엔진과의 협상을 끝내고 나니, 줄바꿈으로 가득 차 있습니다.\u003c/p\u003e\n\u003cp\u003e만약 사용자의 텍스트 확장에 기반한 컨텐츠의 정렬이 가능하다면 어떨까요?\u003c/p\u003e\n\u003cp\u003e다행히도, 라이브러리 A11yUtils 덕분에 A11yHStack을 활용할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e새로운 SwiftUI 도구 릴리스 속도가 빨라서 (그리고 Apple의 뒷전포기가 혹독해서), 이것은 최소 지원 OS에 기반을 둔 두 가지 다른 구현을 가지고 있어요:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eiOS 16에서는 ViewThatFits를 사용하여 HStack이 모든 내용을 포함할 수 있는지 확인하고, 그렇지 않으면 내용을 정렬하기 위해 VStack을 사용합니다.\u003c/li\u003e\n\u003cli\u003eiOS 15에서는 더 단호한 방식을 적용하여, @Environment(.sizeCategory)를 확인하고, 접근성 텍스트 크기 범주 (예: AX1, AX2 또는 AX5) 가 사용된 경우에는 VStack으로 전환합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e다음은 간단한 접근 방식입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e@\u003cspan class=\"hljs-title class_\"\u003eEnvironment\u003c/span\u003e(\\.\u003cspan class=\"hljs-property\"\u003esizeCategory\u003c/span\u003e) private \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e sizeCategory\n\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ebody\u003c/span\u003e: some \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e sizeCategory.\u003cspan class=\"hljs-property\"\u003eisAccessibilityCategory\u003c/span\u003e {\n        \u003cspan class=\"hljs-title class_\"\u003eVStack\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003ealignment\u003c/span\u003e: .\u003cspan class=\"hljs-property\"\u003eleading\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003espacing\u003c/span\u003e: spacing) {\n            \u003cspan class=\"hljs-title function_\"\u003econtent\u003c/span\u003e()\n        }\n        .\u003cspan class=\"hljs-title function_\"\u003eframe\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003emaxWidth\u003c/span\u003e: .\u003cspan class=\"hljs-property\"\u003einfinity\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003ealignment\u003c/span\u003e: .\u003cspan class=\"hljs-property\"\u003eleading\u003c/span\u003e)\n    } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n        \u003cspan class=\"hljs-title class_\"\u003eHStack\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003ealignment\u003c/span\u003e: alignment, \u003cspan class=\"hljs-attr\"\u003espacing\u003c/span\u003e: spacing) {\n            \u003cspan class=\"hljs-title function_\"\u003econtent\u003c/span\u003e()\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e@Environment(.sizeCategory)은 중요한 경우에 사용할 수 있는 유용한 도구입니다. 사용자가 접근성 텍스트 크기 범주를 사용하는지 여부를 알아야 하는 경우 (isAccessibilityCategory와 함께). 때로는 이 속성을 사용하여 대량 콘텐츠 크기에 맞지 않는 이미지와 같은 불필요한 UI 요소를 제거하는 데 활용합니다.\u003c/p\u003e\n\u003cp\u003e더 현대적인 구현은 비슷하게 동작하지만 ViewThatFits를 활용하여 콘텐츠가 맞지 않는 경우에만 재분배됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ebody\u003c/span\u003e: some \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e {\n    \u003cspan class=\"hljs-title class_\"\u003eViewThatFits\u003c/span\u003e {\n        \u003cspan class=\"hljs-title class_\"\u003eHStack\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003ealignment\u003c/span\u003e: alignment, \u003cspan class=\"hljs-attr\"\u003espacing\u003c/span\u003e: spacing) {\n            \u003cspan class=\"hljs-title function_\"\u003econtent\u003c/span\u003e()\n        }\n        \u003cspan class=\"hljs-title class_\"\u003eVStack\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003ealignment\u003c/span\u003e: .\u003cspan class=\"hljs-property\"\u003eleading\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003espacing\u003c/span\u003e: spacing) {\n            \u003cspan class=\"hljs-title function_\"\u003econtent\u003c/span\u003e()\n        }.\u003cspan class=\"hljs-title function_\"\u003eframe\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003emaxWidth\u003c/span\u003e: .\u003cspan class=\"hljs-property\"\u003einfinity\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003ealignment\u003c/span\u003e: .\u003cspan class=\"hljs-property\"\u003eleading\u003c/span\u003e)\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e생각을 많이 해면 A11yHStack을 몇 군데에 적용할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e A11yUtils \n\nA11yHStack {\n    \u003cspan class=\"hljs-title class_\"\u003eImage\u003c/span\u003e(cat.\u003cspan class=\"hljs-property\"\u003eimage\u003c/span\u003e)\n    \u003cspan class=\"hljs-title class_\"\u003eVStack\u003c/span\u003e {\n        A11yHStack {\n            \u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e(cat.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e)\n            \u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"\\(cat.age) years old\"\u003c/span\u003e)\n        }\n        \u003cspan class=\"hljs-title class_\"\u003eHStack\u003c/span\u003e {\n            \u003cspan class=\"hljs-title class_\"\u003eImage\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003esystemName\u003c/span\u003e: cat.\u003cspan class=\"hljs-property\"\u003eicon\u003c/span\u003e)\n            \u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e(cat.\u003cspan class=\"hljs-property\"\u003equote\u003c/span\u003e)\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 컨텐츠가 매우 큰 텍스트 크기에서 더 적절해 보입니다.\u003c/p\u003e\n\u003ch2\u003e스크린 리더 개선사항\u003c/h2\u003e\n\u003cp\u003e보이스오버는 퍼즐 조각 중 비교적 간단한 부분입니다.\u003c/p\u003e\n\u003cp\u003e앱이 스크린 리더와 잘 작동하도록 만드는 것은:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e시각적 콘텐츠가 충분히 설명되었는지 확인하기.\u003c/li\u003e\n\u003cli\u003e탐색이 직관적으로 작동되도록 만들기.\u003c/li\u003e\n\u003cli\u003e뷰가 의미론적으로 올바른지 확인하기.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e먼저 시각적 설명부터 시작해보죠. 이것은 우리 레퍼토리에서 가장 간단한 수정 사항입니다: 그래픽 콘텐츠가 VoiceOver에 의해 설명될 수 있도록 보장하는 것입니다. accessibilityLabel 수정자가 우리의 책과 버터라고 할 수 있죠.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eImage\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"catKingdom\"\u003c/span\u003e)\n    .\u003cspan class=\"hljs-title function_\"\u003eaccessibilityLabel\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"나의 세 마리 고양이: 코디, 로지, 루나\"\u003c/span\u003e))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e스크린리더가 현재 초점을 맞춘 대상을 설명하는 방법을 알려줍니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_11.png\" alt=\"Cat Kingdom\"\u003e\u003c/p\u003e\n\u003cp\u003e이제 주 뷰의 셀에 동일한 방식을 적용할 수 있습니다. Cat 데이터 모델을 약간 수정하여 각 고양이 사진과 함께 이미지 설명을 제공합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003estruct \u003cspan class=\"hljs-title class_\"\u003eCat\u003c/span\u003e {\n    \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eimageDescription\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e\n}\n\n\u003cspan class=\"hljs-title class_\"\u003eImage\u003c/span\u003e(cat.\u003cspan class=\"hljs-property\"\u003eimage\u003c/span\u003e)\n    .\u003cspan class=\"hljs-title function_\"\u003eaccessibilityLabel\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e(cat.\u003cspan class=\"hljs-property\"\u003eimageDescription\u003c/span\u003e))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이건 들릴만큼 쉽고, Apple 플랫폼에서만 작동하는 경향이 있어요.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_12.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e우리 앱을 통해 탐색할 때, 좀 더 신중하게 할 수 있는 기회가 있어요. 기본 설정으로 VoiceOver는 SwiftUI 뷰 트리의 모든 잎 노드를 반복하며 모든 이미지, 버튼 및 텍스트를 읽어줄 거예요.\u003c/p\u003e\n\u003cp\u003e가끔 사용자에게 불필요한 탐색을 초래합니다. 저희 앱에서는 각 고양이의 아이콘과 인용구를 건너뛰려면 여러 번 탭해야 합니다. 아이콘의 이름(예: cat.fill)을 읽는 것은 경험에 별다른 도움이 되지 않습니다.\u003c/p\u003e\n\u003cp\u003e이들을 단일 a11y 요소로 결합하여 screenreader가 탐색 중에 하나의 항목으로 처리할 수 있도록 할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-swift\"\u003e\u003cspan class=\"hljs-type\"\u003eHStack\u003c/span\u003e {\n    \u003cspan class=\"hljs-type\"\u003eImage\u003c/span\u003e(systemName: cat.icon)\n    \u003cspan class=\"hljs-type\"\u003eText\u003c/span\u003e(cat.quote)\n}\n.accessibilityElement(children: .combine)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 screenreader가 요소를 하나로 이동하는 것을 들을 수 있습니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_13.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e어떤 상황에서는 그래픽적으로 시간이 표시되는 셀렉트한 타이머 요소와 같이 복잡한 UI가 있을 수 있습니다. VoiceOver는 똑똑하지만, 설명되지 않은 뷰들의 번잡한 모음에서 유용한 정보를 유추하지는 못합니다.\u003c/p\u003e\n\u003cp\u003e여기서 accessibilityRepresentation 수정자가 정말 유용하게 사용됩니다. 이를 통해 뷰의 VoiceOver UI를 완전히 사용자 정의된 접근성 표현으로 대체할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e최근에 개발한 개인 프로젝트 'Check 'em'에서는 사용자의 2단계 인증 코드가 카운트다운과 함께 표시되어 해당 기능이 특히 유용했습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-swift\"\u003e\u003cspan class=\"hljs-comment\"\u003e// AccountView.swift\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003estruct\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eAccountView\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e {\n    \n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e body: \u003cspan class=\"hljs-keyword\"\u003esome\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eView\u003c/span\u003e {\n        \u003cspan class=\"hljs-type\"\u003eSection\u003c/span\u003e(account.name) {\n            \u003cspan class=\"hljs-comment\"\u003e// Image, 2FA Code Text, and Countdown UI ...\u003c/span\u003e\n        }\n        .accessibilityRepresentation {\n            \u003cspan class=\"hljs-type\"\u003eVStack\u003c/span\u003e {\n                \u003cspan class=\"hljs-type\"\u003eText\u003c/span\u003e(account.name)\n                \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e code \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e account.code {\n                    \u003cspan class=\"hljs-type\"\u003eForEach\u003c/span\u003e(\u003cspan class=\"hljs-type\"\u003eArray\u003c/span\u003e(code.enumerated()), id: \\.\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e) {\n                        \u003cspan class=\"hljs-type\"\u003eText\u003c/span\u003e(\u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e(\u003cspan class=\"hljs-variable\"\u003e$0\u003c/span\u003e.\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e))\n                    }\n                }\n                \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e countdown \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e account.countdown {\n                    \u003cspan class=\"hljs-type\"\u003eText\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Expires in \u003cspan class=\"hljs-subst\"\u003e\\(countdown)\u003c/span\u003e\"\u003c/span\u003e)\n                }\n            }.accessibilityElement(children: .combine)\n        }\n    }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 modifier를 사용하여 각 셀 요소를 순서대로 반복하는 것보다 훨씬 유용한 완전히 사용자 정의 된 VoiceOver 인터페이스를 소개할 수 있었습니다. 또한 화면 낭독기가 \"676,252\"를 \"육십 칠만 육천 이백 오십 이\"로 읽는 것을 방지했습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_14.png\" alt=\"Screenshot\"\u003e\u003c/p\u003e\n\u003ch2\u003eNative components\u003c/h2\u003e\n\u003cp\u003e이 어플리케이션의 주요 뷰는 저희 콘텐츠를 배치하는 일반적이지만 조잡한 방법을 사용합니다: ForEach 내에 있는 셀을 래핑하는 방식으로 LazyVStack을 래핑하고 ScrollView로 래핑합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eScrollView\u003c/span\u003e {\n    \u003cspan class=\"hljs-title class_\"\u003eLazyVStack\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003espacing\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e24\u003c/span\u003e) {\n        \u003cspan class=\"hljs-title class_\"\u003eForEach\u003c/span\u003e(cats, \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: \\.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e) {\n            \u003cspan class=\"hljs-title class_\"\u003eCatView\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003ecat\u003c/span\u003e: $0)\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e최적의 방법은 가능한 한 SwiftUI의 기본 구성 요소를 활용하는 것입니다. 이 경우에는 List가 가장 적합합니다.\u003c/p\u003e\n\u003cp\u003eApple은 사용자 정의 UI 대신 iOS-Settings 스타일의 List를 사용하려면 모디파이어를 3개 추가해야 한다는 점을 설명할 때, 이 작업을 좀 더 어렵게 만들어 놓았습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e목록(고양이) {\n    고양이뷰(고양이: $0)\n        .목록행배경(\u003cspan class=\"hljs-title class_\"\u003eColor\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eclear\u003c/span\u003e)\n        .목록행구분선(.숨김)\n}\n.목록스타일(일반목록스타일())\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 보일러플레이트를 작성했으니 수정자들을 자유롭게 사용하여 SwiftUI 목록에서 자체 UI를 사용할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e한 가지 질문이 있습니다.\u003c/p\u003e\n\u003cp\u003e왜 네이티브 컴포넌트를 사용하는 것에 이렇게 많은 노력을 기울일까요?\u003c/p\u003e\n\u003cp\u003e먼저, 비 접근성(a11y) 관련 이유: SwiftUI List는 UICollectionView를 사용하여 구현됩니다. 이는 고성능 스크롤링을 위해 셀 재사용을 활용하며 항목이 많아도 성능을 유지합니다. 그에 반해 LazyVStack은 이전에 렌더링된 모든 셀을 메모리에 유지하므로 많은 항목을 스크롤하는 경우 성능이 뚝뚝 떨어집니다.\u003c/p\u003e\n\u003cp\u003e네이티브 컴포넌트를 사용하는 a11y 관련 이유는 간단하지만 다양합니다:\u003c/p\u003e\n\u003cp\u003eList는 의미론적 의미가 있습니다: 화면 판독기에게 비슷한 콘텐츠 컬렉션을 포함하는 컨테이너임을 알려줍니다.\u003c/p\u003e\n\u003cp\u003e이것이 많은 목록 항목이 있는 경우, 순진한 구현이 망가진 이유입니다: VoiceOver로 목록 컨테이너를 건너뛸 수 있게 해주지 않고 모든 항목을 스와이프해야만 로그아웃 버튼에 도달할 수 있었습니다.\u003c/p\u003e\n\u003cp\u003eList를 사용하면 SwiftUI가 화면 판독기에게 그 내용이 단일 컨테이너임을 알려줄 수 있어, 화면 판독기가 쉽게 이동할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e아래는 Markdown 형식으로 변경된 이미지 링크입니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_16.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e또한 List에는 스와이프 삭제, 드래그 앤 드롭, 키보드 기반 탐색 등 많은 내장 상호작용 모드가 있습니다. 네이티브 컴포넌트를 사용할 때 이들은 자동으로 작동합니다. 사용자 지정 구현과 함께 하는 화면 판독기 작업을 어떻게 할 것인지 아시겠습니까?\u003c/p\u003e\n\u003cp\u003e리스트는 심지어 가장 복잡한 컴포넌트도 아닙니다. 사용자 정의 그리드나 레이아웃 프로토콜을 사용하지 않는 뷰의 사용자 정의 분배에 a11y를 어떻게 구현할 것인가요?\u003c/p\u003e\n\u003ch1\u003e이해관계자 설득\u003c/h1\u003e\n\u003cp\u003e이제 SwiftUI 앱에서 a11y를 빠르게 실행하는 방법을 이해했으니, 작업에 착수하기 전에 남은 퍼즐 조각은 비즈니스의 나머지 구성원으로부터 승인을 얻는 것입니다. 여기서 당신이 조직적 영향력을 행사하는 소프트 스킬을 펼칠 수 있습니다.\u003c/p\u003e\n\u003cp\u003e당신이 휘둘 수 있는 큰, 둔한 도구 중 하나는 입법의 망치입니다. 영국, 미국, 그리고 EU와 같은 세계 각국은 디지털 서비스가 접근성의 최소 기준을 충족해야 한다는 법률을 시행했습니다.\u003c/p\u003e\n\u003cp\u003e또한, 웹 접근성(웹 콘텐츠 접근성)은 실제로 비즈니스에서 큰 이점을 제공합니다. 현재 세계 인구의 16%가 중요한 장애를 겪고 있습니다. 즉, 다양한 요구에 맞게 서비스를 제공함으로써 사용자, 긍정적인 리뷰 및 수익을 놓칠 수 있습니다. 대상 시장에 따라 이는 더 또는 덜 중요할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e작은 규모에서는, 접근성을 제품 부채로 다루는 것보다 앱이 어떻게 오작동하는지 간단히 보여주는 것이 훨씬 효과적이라는 것을 발견했습니다. 접근성 요구사항을 추상적인 개념에서 벗어나서 버그 있는 가입 플로우를 보여주는 것이 어떤 엔지니어링 조직에게도 더 설득력있을 것입니다.\u003c/p\u003e\n\u003cp\u003e제품에 쉽게 접근할 수 있도록 옹호하는 영향력 있는 리더십 속에 있는 옹호자를 가지는 것이 가장 도움이 됩니다. 물론, 모든 조직이 다르기 때문에 이 조언을 적용할 때 결과가 다를 수 있습니다.\u003c/p\u003e\n\u003cp\u003e가장 중요한 것은, 이제 웹 접근성을 빠르게 적용하고 제품이 완전히 접근 가능한 상태라면?\u003c/p\u003e\n\u003cp\u003e공을 놓치지 마세요!\u003c/p\u003e\n\u003cp\u003e기술 부채와 마찬가지로, 이제 좋은 위치에 있으니 a11y를 표준 개발 워크플로에 통합할 수 있습니다. 이미 알고 계시니 빠르고 쉽게 할 수 있어요!\u003c/p\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003e오늘 많은 내용을 다뤘습니다.\u003c/p\u003e\n\u003cp\u003e먼저 앱을 감사하여 대화형 텍스트 스케일링 또는 VoiceOver를 사용할 때 발생하는 일반적인 접근성 오류를 확인하는 프로세스를 거쳤습니다.\u003c/p\u003e\n\u003cp\u003e텍스트 스케일링을 사용할 때 발생하는 문제를 수정하고, a11yScrollView로 스크롤링을 적용하고, @ScaledMetric으로 콘텐츠 스케일링하고, A11yHStack으로 정렬하는 방법을 살펴보았습니다.\u003c/p\u003e\n\u003cp\u003e화면 판독기에서 앱이 잘 작동하도록 만들기 위해 accessibilityLabels를 구현했고, accessibilityElements를 결합하고, 심지어 완전히 사용자 정의된 accessibilityRepresentations도 구현했습니다.\u003c/p\u003e\n\u003cp\u003e네이티브 SwiftUI 구성 요소 대신 사용자 지정보기를 사용하는 이유에 대해 논의했습니다. 이유로는 의미론, 상호 작용 모드 및 성능이 있습니다.\u003c/p\u003e\n\u003cp\u003e마침내, 당신이 조직 내에서 접근성에 진지하게 대응하기 위해 소프트 스킬을 적용하는 방법을 살펴보았습니다.\u003c/p\u003e\n\u003cp\u003e당신이 SwiftUI 앱에서 접근성에 진지하다면, 동반 앱을 통해 이러한 기술들을 직접 구현해보는 것을 적극 권장합니다. 도구를 체득하는 가장 좋은 방법이죠. 지금까지 작업해온 사이드 프로젝트가 있다면, 그것 역시 좋은 시작점일 것입니다.\u003c/p\u003e\n\u003cp\u003e내 A11yUtils 라이브러리에 기여 (문제 포함)를 기쁘게 받아들이겠습니다. 지금도 SwiftUI에 이미 있는 API를 보완하기 위한 포괄적인 접근성 도구 모음으로 이것을 발전시키기 위해 커뮤니티와 협력하고 싶어합니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility"},"buildId":"o1YmnmSuZvAX2O4TI9r41","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>