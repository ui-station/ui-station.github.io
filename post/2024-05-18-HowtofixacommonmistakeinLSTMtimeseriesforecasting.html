<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>LSTM 시계열 예측에서 흔히 발생하는 오류를 수정하는 방법 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="LSTM 시계열 예측에서 흔히 발생하는 오류를 수정하는 방법 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="LSTM 시계열 예측에서 흔히 발생하는 오류를 수정하는 방법 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting" data-gatsby-head="true"/><meta name="twitter:title" content="LSTM 시계열 예측에서 흔히 발생하는 오류를 수정하는 방법 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-18 19:35" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-4f7b40c1114f0d09.js" defer=""></script><script src="/_next/static/YUMR4jSyk_WlOHHc7UfOk/_buildManifest.js" defer=""></script><script src="/_next/static/YUMR4jSyk_WlOHHc7UfOk/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">LSTM 시계열 예측에서 흔히 발생하는 오류를 수정하는 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="LSTM 시계열 예측에서 흔히 발생하는 오류를 수정하는 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 18, 2024</span><span class="posts_reading_time__f7YPP">15<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>LSTM을 시계열 예측에 사용할 때, 사람들은 흔히 범할 수 있는 함정에 빠지곤 합니다. 이를 설명하기 위해서는 회귀자와 예측자의 작동 방식을 살펴볼 필요가 있습니다. 예측 알고리즘은 시계열 데이터를 다루는 방법을 아래와 같이 보여줍니다:</p>
<p><img src="/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_0.png" alt="How a forecasting algorithm works"></p>
<p>한편, 회귀 문제는 다음과 같이 보일 것입니다:</p>
<p><img src="/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_1.png" alt="How a regression problem looks"></p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>LSTM이 회귀기이므로 시계열을 회귀 문제로 변환해야 합니다. 이를 수행하는 여러 방법이 있지만, 이 섹션에서는 창(Window) 및 다중 단계(Multi-Step) 방법에 대해 설명하고, 어떻게 작동하는지와 특히 이를 활용할 때 발생할 수 있는 일반적인 실수를 피하는 방법에 대해 논의할 것입니다.</p>
<p>창 방법(Window Method)에서, 시계열은 이전 각 시간 단계의 값과 결합되어 창이라고 불리는 가상 특성으로 되어 있습니다. 여기서 창 크기가 3인 창이 있습니다:</p>
<p><img src="/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_2.png" alt="창 방법 이미지"></p>
<p>다음 함수는 단일 시계열에서 창 방법 데이터 세트를 생성합니다. 사용자는 이전 값의 수(보통 look back이라고 함)를 선택해야 합니다. 결과 데이터 세트에는 대각선 반복이 있으며, look-back 값에 따라 샘플의 수가 달라집니다:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js">def <span class="hljs-title function_">window</span>(sequences, look_back):
    X, y = [], []
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-title function_">range</span>(<span class="hljs-title function_">len</span>(sequences)-look_back-<span class="hljs-number">1</span>):
        x = sequences[<span class="hljs-attr">i</span>:(i+look_back)]
        X.<span class="hljs-title function_">append</span>(x)
        y.<span class="hljs-title function_">append</span>(sequences[i + look_back])
    <span class="hljs-keyword">return</span> np.<span class="hljs-title function_">array</span>(X), np.<span class="hljs-title function_">array</span>(y)
</code></pre>
<p>이제 결과를 살펴보겠습니다. 모델을 훈련한 후에는 테스트 세트에서 테스트됩니다. 다양한 소스와 튜토리얼에서는 비슷한 방법을 사용하여 결과를 컴파일하는 것을 제안했습니다. 그러나 나중에 설명할 것처럼 이 방법은 신빙성이 없습니다. 그럼 지금은 코드와 결과가 어떻게 보이는지 살펴보겠습니다:</p>
<pre><code class="hljs language-js">look_back = <span class="hljs-number">3</span>
X, y = <span class="hljs-title function_">window</span>(ts_data, look_back)

# 훈련-테스트 분할
train_ratio = <span class="hljs-number">0.8</span>
train_size = <span class="hljs-title function_">int</span>(train_ratio * <span class="hljs-title function_">len</span>(ts_data))
X_train, X_test = X[:train_size-look_back], X[train_size-<span class="hljs-attr">look_back</span>:]
y_train, y_test = y[:train_size-look_back], y[train_size-<span class="hljs-attr">look_back</span>:]

# <span class="hljs-variable constant_">LSTM</span> 모델 생성 및 훈련
model = <span class="hljs-title class_">Sequential</span>()
model.<span class="hljs-title function_">add</span>(<span class="hljs-title function_">LSTM</span>(units=<span class="hljs-number">72</span>, activation=<span class="hljs-string">'tanh'</span>, input_shape=(look_back, <span class="hljs-number">1</span>)))
model.<span class="hljs-title function_">add</span>(<span class="hljs-title class_">Dense</span>(<span class="hljs-number">1</span>))
model.<span class="hljs-title function_">compile</span>(loss=<span class="hljs-string">'mean_squared_error'</span>, optimizer=<span class="hljs-string">'Adam'</span>, metrics=[<span class="hljs-string">'mape'</span>])

model.<span class="hljs-title function_">fit</span>(x=X_train, y=y_train, epochs=<span class="hljs-number">500</span>, batch_size=<span class="hljs-number">18</span>, verbose=<span class="hljs-number">2</span>)

# 예측 생성
forecasts = model.<span class="hljs-title function_">predict</span>(X_test)
lstm_fits = model.<span class="hljs-title function_">predict</span>(X_train)

# 메트릭스 계산
mape = <span class="hljs-title function_">mean_absolute_percentage_error</span>(y_test, forecasts)
r2 = <span class="hljs-title function_">r2_score</span>(y_train, lstm_fits)

# 날짜 초기화
date_range = pd.<span class="hljs-title function_">date_range</span>(start=<span class="hljs-string">'1990-01-01'</span>, end=<span class="hljs-string">'2023-09-30'</span>, freq=<span class="hljs-string">'M'</span>)

# 맞춤 값에 원래 시계열과 맞추기 위한 비어있는 값 추가
fits = np.<span class="hljs-title function_">full</span>(train_size, np.<span class="hljs-property">nan</span>)
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-title function_">range</span>(train_size-look_back):
    fits[i+look_back] = lstm_fits[i]

# 실제값, 맞춤값, 예측값 플롯
plt.<span class="hljs-title function_">figure</span>(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">6</span>))
plt.<span class="hljs-title function_">plot</span>(date_range, ts_data, label=<span class="hljs-string">'Actual'</span>, color=<span class="hljs-string">'blue'</span>)
plt.<span class="hljs-title function_">plot</span>(date_range[:train_size], fits, label=<span class="hljs-string">'Fitted'</span>, color=<span class="hljs-string">'green'</span>)
plt.<span class="hljs-title function_">plot</span>(date_range[<span class="hljs-attr">train_size</span>:], forecasts, label=<span class="hljs-string">'Forecast'</span>, color=<span class="hljs-string">'red'</span>)
plt.<span class="hljs-title function_">title</span>(<span class="hljs-string">'FSC - Short - Passengers\nOne Step Forward Forecast'</span>)
plt.<span class="hljs-title function_">xlabel</span>(<span class="hljs-string">'Date'</span>)
plt.<span class="hljs-title function_">ylabel</span>(<span class="hljs-string">'Passengers'</span>)
plt.<span class="hljs-title function_">legend</span>()
plt.<span class="hljs-title function_">text</span>(<span class="hljs-number">0.05</span>, <span class="hljs-number">0.05</span>, f<span class="hljs-string">'R2 = {r2*100:.2f}%\nMAPE = {mape*100:.2f}%'</span>, transform=plt.<span class="hljs-title function_">gca</span>().<span class="hljs-property">transAxes</span>, fontsize=<span class="hljs-number">12</span>)
plt.<span class="hljs-title function_">grid</span>(<span class="hljs-title class_">True</span>)
plt.<span class="hljs-title function_">show</span>()
</code></pre>
<img src="/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_3.png">
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>문제: 결과는 훌륭해 보입니다. 그러나 샘플 테스트 세트를 살펴보면 특이한 결함이 보입니다:</p>
<p><img src="/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_4.png" alt="이미지"></p>
<p>예를 들어 y9를 생성하는 데에는 y8이 입력으로 사용되었습니다. 훈련에는 사용되지 않았지만 미래 값을 포함하는 것은 이상합니다. 왜냐하면 우리는 미래의 시점을 예측하고 있기 때문입니다.</p>
<p>해결책: 직접적으로 이전 값을 예측 값으로 대체하는 반복적 테스트 세트를 사용하면 이 문제를 해결할 수 있습니다. 이러한 배치 방식에서 모델은 자체 예측에 기반을 둔다. 일반적인 예측 알고리즘과 유사합니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>아래 루프에서 다음을 수행합니다:</p>
<pre><code class="hljs language-js"># 반복적인 예측 및 대체
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-title function_">range</span>(<span class="hljs-title function_">len</span>(X_test)):
    forecasts[i] = model.<span class="hljs-title function_">predict</span>(X_test[i].<span class="hljs-title function_">reshape</span>(<span class="hljs-number">1</span>, look_back, <span class="hljs-number">1</span>))
    <span class="hljs-keyword">if</span> i != <span class="hljs-title function_">len</span>(X_test)-<span class="hljs-number">1</span>:
        X_test[i+<span class="hljs-number">1</span>,look_back-<span class="hljs-number">1</span>] = forecasts[i]
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-title function_">range</span>(look_back-<span class="hljs-number">1</span>):
            X_test[i+<span class="hljs-number">1</span>,j] = X_test[i,j+<span class="hljs-number">1</span>]
</code></pre>
<p>결과는 완벽하지는 않지만 적어도 정허하다고 할 수 있습니다:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<img src="/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_6.png">
<p>다중 단계 방법은 창 방법과 유사하지만 더 많은 대상 단계를 갖습니다. 다음은 두 개의 전방 단계의 샘플입니다:</p>
<img src="/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_7.png">
<p>사실, 이 방법에서 사용자는 n_steps_in과 n_steps_out을 선택해야 합니다. 다음 코드는 단순 시계열을 다중 단계 LSTM 훈련을 위해 준비된 데이터 세트로 변환합니다:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js"># 단변량 시퀀스를 다단계로 샘플링하기
def <span class="hljs-title function_">split_sequences</span>(sequences, n_steps_in, n_steps_out):
 X, y = <span class="hljs-title function_">list</span>(), <span class="hljs-title function_">list</span>()
 <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-title function_">range</span>(<span class="hljs-title function_">len</span>(sequences)):
     # 해당 패턴의 끝을 찾음
     end_ix = i + n_steps_in
     out_end_ix = end_ix + n_steps_out
     # 시퀀스를 벗어나는지 확인
     <span class="hljs-keyword">if</span> out_end_ix > <span class="hljs-title function_">len</span>(sequences):
         <span class="hljs-keyword">break</span>
     # 패턴의 입력 및 출력 부분 수집
     seq_x, seq_y = sequences[<span class="hljs-attr">i</span>:end_ix], sequences[<span class="hljs-attr">end_ix</span>:out_end_ix]
     X.<span class="hljs-title function_">append</span>(seq_x)
     y.<span class="hljs-title function_">append</span>(seq_y)
 <span class="hljs-keyword">return</span> np.<span class="hljs-title function_">array</span>(X), np.<span class="hljs-title function_">array</span>(y)
</code></pre>
<p>이제, 특성 뿐만 아니라 타겟도 대각선 반복을 가지고 있어 시계열과 비교하려면 그들을 평균화하거나 예측 중 하나를 선택해야 합니다. 아래 코드에서는 첫 번째, 마지막 및 평균 예측의 결과가 생성되며, 그에 이어 플롯이 제시됩니다. 여기서 첫 번째 예측은 한 달 전 예측을 의미하며, 마지막 예측은 12개월 전 예측을 의미합니다.</p>
<pre><code class="hljs language-js">n_steps_in = <span class="hljs-number">12</span>
n_steps_out = <span class="hljs-number">12</span>

X, y = <span class="hljs-title function_">split_sequences</span>(ts_data, n_steps_in, n_steps_out)
X = X.<span class="hljs-title function_">reshape</span>(X.<span class="hljs-property">shape</span>[<span class="hljs-number">0</span>], X.<span class="hljs-property">shape</span>[<span class="hljs-number">1</span>], <span class="hljs-number">1</span>)
y = y.<span class="hljs-title function_">reshape</span>(y.<span class="hljs-property">shape</span>[<span class="hljs-number">0</span>], y.<span class="hljs-property">shape</span>[<span class="hljs-number">1</span>], <span class="hljs-number">1</span>)

# 훈련 및 테스트 세트 분리
train_ratio = <span class="hljs-number">0.8</span>
train_size = <span class="hljs-title function_">int</span>(train_ratio * <span class="hljs-title function_">len</span>(ts_data))
X_train, X_test = X[:train_size-n_steps_in-n_steps_out+<span class="hljs-number">1</span>], X[train_size-n_steps_in-n_steps_out+<span class="hljs-number">1</span>:]
y_train = y[:train_size-n_steps_in-n_steps_out+<span class="hljs-number">1</span>]
y_test = ts_data[<span class="hljs-attr">train_size</span>:]

# <span class="hljs-variable constant_">LSTM</span> 모델 생성 및 훈련
model = <span class="hljs-title class_">Sequential</span>()
model.<span class="hljs-title function_">add</span>(<span class="hljs-title function_">LSTM</span>(units=<span class="hljs-number">72</span>, activation=<span class="hljs-string">'tanh'</span>, input_shape=(n_steps_in, <span class="hljs-number">1</span>)))
model.<span class="hljs-title function_">add</span>(<span class="hljs-title class_">Dense</span>(units=n_steps_out))
model.<span class="hljs-title function_">compile</span>(loss=<span class="hljs-string">'mean_squared_error'</span>, optimizer=<span class="hljs-string">'Adam'</span>, metrics=[<span class="hljs-string">'mape'</span>])

model.<span class="hljs-title function_">fit</span>(x=X_train, y=y_train, epochs=<span class="hljs-number">500</span>, batch_size=<span class="hljs-number">18</span>, verbose=<span class="hljs-number">2</span>)

# 예측 생성
lstm_predictions = model.<span class="hljs-title function_">predict</span>(X_test)
lstm_fitted = model.<span class="hljs-title function_">predict</span>(X_train)

forecasts = [np.<span class="hljs-title function_">diag</span>(np.<span class="hljs-title function_">fliplr</span>(lstm_predictions), i).<span class="hljs-title function_">mean</span>() <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-title function_">range</span>(<span class="hljs-number">0</span>, -lstm_predictions.<span class="hljs-property">shape</span>[<span class="hljs-number">0</span>], -<span class="hljs-number">1</span>)]
fits = [np.<span class="hljs-title function_">diag</span>(np.<span class="hljs-title function_">fliplr</span>(lstm_fitted), i).<span class="hljs-title function_">mean</span>() <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-title function_">range</span>(lstm_fitted.<span class="hljs-property">shape</span>[<span class="hljs-number">1</span>]+n_steps_in - <span class="hljs-number">1</span>, -lstm_fitted.<span class="hljs-property">shape</span>[<span class="hljs-number">0</span>], -<span class="hljs-number">1</span>)]
forecasts1 = lstm_predictions[n_steps_out-<span class="hljs-number">1</span>:,<span class="hljs-number">0</span>]
fits1 = model.<span class="hljs-title function_">predict</span>(X)[:train_size-n_steps_in,<span class="hljs-number">0</span>]
forecasts12 = lstm_predictions[:,n_steps_out-<span class="hljs-number">1</span>]
fits12 = lstm_fitted[:,n_steps_out-<span class="hljs-number">1</span>]

# <span class="hljs-title class_">Metric</span>
av_mape = <span class="hljs-title function_">mean_absolute_percentage_error</span>(y_test, forecasts)
av_r2 = <span class="hljs-title function_">r2_score</span>(ts_data[<span class="hljs-attr">n_steps_in</span>:train_size], fits[<span class="hljs-attr">n_steps_in</span>:])
one_mape = <span class="hljs-title function_">mean_absolute_percentage_error</span>(y_test[:-n_steps_out+<span class="hljs-number">1</span>], forecasts1)
one_r2 = <span class="hljs-title function_">r2_score</span>(ts_data[<span class="hljs-attr">n_steps_in</span>:train_size], fits1)
twelve_mape = <span class="hljs-title function_">mean_absolute_percentage_error</span>(y_test, forecasts12)
twelve_r2 = <span class="hljs-title function_">r2_score</span>(ts_data[n_steps_in+n_steps_out-<span class="hljs-number">1</span>:train_size], fits12)

date_range = pd.<span class="hljs-title function_">date_range</span>(start=<span class="hljs-string">'1990-01-01'</span>, end=<span class="hljs-string">'2023-09-30'</span>, freq=<span class="hljs-string">'M'</span>)

# 실제, 적합 결과 및 예측을 플롯
plt.<span class="hljs-title function_">figure</span>(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">6</span>))
plt.<span class="hljs-title function_">plot</span>(date_range, ts_data, label=<span class="hljs-string">'Actual'</span>, color=<span class="hljs-string">'blue'</span>)
plt.<span class="hljs-title function_">plot</span>(date_range[:train_size], fits, label=<span class="hljs-string">'Fitted'</span>, color=<span class="hljs-string">'green'</span>)
plt.<span class="hljs-title function_">plot</span>(date_range[<span class="hljs-attr">train_size</span>:], forecasts, label=<span class="hljs-string">'Forecast'</span>, color=<span class="hljs-string">'red'</span>)
plt.<span class="hljs-title function_">title</span>(<span class="hljs-string">'FSC - Short - Passengers\n. LSTM 12 Month Average Forecast'</span>)
plt.<span class="hljs-title function_">xlabel</span>(<span class="hljs-string">'Date'</span>)
plt.<span class="hljs-title function_">ylabel</span>(<span class="hljs-string">'Passengers'</span>)
plt.<span class="hljs-title function_">legend</span>()
plt.<span class="hljs-title function_">text</span>(<span class="hljs-number">0.05</span>, <span class="hljs-number">0.05</span>, f<span class="hljs-string">'R2 = {av_r2*100:.2f}%\nMAPE = {av_mape*100:.2f}%'</span>, transform=plt.<span class="hljs-title function_">gca</span>().<span class="hljs-property">transAxes</span>, fontsize=<span class="hljs-number">12</span>)
plt.<span class="hljs-title function_">grid</span>(<span class="hljs-title class_">True</span>)
plt.<span class="hljs-title function_">show</span>()

plt.<span class="hljs-title function_">figure</span>(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">6</span>))
plt.<span class="hljs-title function_">plot</span>(date_range, ts_data, label=<span class="hljs-string">'Actual'</span>, color=<span class="hljs-string">'blue'</span>)
plt.<span class="hljs-title function_">plot</span>(date_range[<span class="hljs-attr">n_steps_in</span>:train_size], fits1, label=<span class="hljs-string">'Fitted'</span>, color=<span class="hljs-string">'green'</span>)
plt.<span class="hljs-title function_">plot</span>(date_range[<span class="hljs-attr">train_size</span>:-n_steps_out+<span class="hljs-number">1</span>], forecasts1, label=<span class="hljs-string">'Forecast'</span>, color=<span class="hljs-string">'red'</span>)
plt.<span class="hljs-title function_">title</span>(<span class="hljs-string">'FSC - Short - Passengers\n LSTM 1 Month in advance Forecast'</span>)
plt.<span class="hljs-title function_">xlabel</span>(<span class="hljs-string">'Date'</span>)
plt.<span class="hljs-title function_">ylabel</span>(<span class="hljs-string">'Passengers'</span>)
plt.<span class="hljs-title function_">legend</span>()
plt.<span class="hljs-title function_">text</span>(<span class="hljs-number">0.05</span>, <span class="hljs-number">0.05</span>, f<span class="hljs-string">'R2 = {one_r2*100:.2f}%\nMAPE = {one_mape*100:.2f}%'</span>, transform=plt.<span class="hljs-title function_">gca</span>().<span class="hljs-property">transAxes</span>, fontsize=<span class="hljs-number">12</span>)
plt.<span class="hljs-title function_">grid</span>(<span class="hljs-title class_">True</span>)
plt.<span class="hljs-title function_">show</span>()

plt.<span class="hljs-title function_">figure</span>(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">6</span>))
plt.<span class="hljs-title function_">plot</span>(date_range, ts_data, label=<span class="hljs-string">'Actual'</span>, color=<span class="hljs-string">'blue'</span>)
plt.<span class="hljs-title function_">plot</span>(date_range[n_steps_in+n_steps_out-<span class="hljs-number">1</span>:train_size], fits12, label=<span class="hljs-string">'Fitted'</span>, color=<span class="hljs-string">'green'</span>)
plt.<span class="hljs-title function_">plot</span>(date_range[<span class="hljs-attr">train_size</span>:], forecasts12, label=<span class="hljs-string">'Forecast'</span>, color=<span class="hljs-string">'red'</span>)
plt.<span class="hljs-title function_">title</span>(<span class="hljs-string">'FSC - Short - Passengers\n LSTM 12 Months in advance Forecast'</span>)
plt.<span class="hljs-title function_">xlabel</span>(<span class="hljs-string">'Date'</span>)
plt.<span class="hljs-title function_">ylabel</span>(<span class="hljs-string">'Passengers'</span>)
plt.<span class="hljs-title function_">legend</span>()
plt.<span class="hljs-title function_">text</span>(<span class="hljs-number">0.05</span>, <span class="hljs-number">0.05</span>, f<span class="hljs-string">'R2 = {twelve_r2*100:.2f}%\nMAPE = {twelve_mape*100:.2f}%'</span>, transform=plt.<span class="hljs-title function_">gca</span>().<span class="hljs-property">transAxes</span>, fontsize=<span class="hljs-number">12</span>)
plt.<span class="hljs-title function_">grid</span>(<span class="hljs-title class_">True</span>)
plt.<span class="hljs-title function_">show</span>()
</code></pre>
<p>이슈: 창 메서드와 동일한 문제가 여기에도 있습니다:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p><img src="/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_8.png" alt="이미지"></p>
<p>해상도: 창 법과 비슷한 방법을 사용할 수 있습니다. 그러나 n_steps_out을 test_size와 동일하게 선택할 수도 있습니다. 이렇게 하면 테스트 세트가 하나로 축소됩니다:</p>
<p><img src="/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_9.png" alt="이미지"></p>
<p>다음 함수는 이를 정확히 수행합니다. 이 함수는 시계열, 학습 크기 및 샘플 수를 사용합니다. 이 버전은 다른 예측 알고리즘과 비교할 수 있기 때문에 comparable로 이름 지었습니다:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js">def <span class="hljs-title function_">split_sequences_comparable</span>(sequences, n_samples, train_size):
 # 단계
 n_steps_out = <span class="hljs-title function_">len</span>(sequences) - train_size
 n_steps_in = train_size - n_steps_out - n_samples + <span class="hljs-number">1</span>
 # 끝 세트
 X_test = sequences[n_samples + n_steps_out - <span class="hljs-number">1</span>:train_size]
 X_forecast = sequences[-<span class="hljs-attr">n_steps_in</span>:]
 X, y = <span class="hljs-title function_">list</span>(), <span class="hljs-title function_">list</span>()
 <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-title function_">range</span>(n_samples):
     # 이 패턴의 끝을 찾습니다
     end_ix = i + n_steps_in
     out_end_ix = end_ix + n_steps_out
     # 패턴의 입력 및 출력 부분을 수집합니다
     seq_x, seq_y = sequences[<span class="hljs-attr">i</span>:end_ix], sequences[<span class="hljs-attr">end_ix</span>:out_end_ix]
     X.<span class="hljs-title function_">append</span>(seq_x)
     y.<span class="hljs-title function_">append</span>(seq_y)
 <span class="hljs-keyword">return</span> np.<span class="hljs-title function_">array</span>(X), np.<span class="hljs-title function_">array</span>(y), np.<span class="hljs-title function_">array</span>(X_test), np.<span class="hljs-title function_">array</span>(X_forecast), n_steps_in, n_steps_out
</code></pre>
<p>이 함수에서는 단계 수가 이미 고정되었기 때문에 샘플 수와 훈련 크기는 사용자가 선택하도록 하고, 최대 가능한 단계 수를 계산하도록 결정했습니다. 아래는 실행된 코드와 그 결과입니다:</p>
<pre><code class="hljs language-js">n_samples = <span class="hljs-number">12</span>
train_size = <span class="hljs-number">321</span>
X_train, y_train, X_test, X_forecast, n_steps_in, n_steps_out = <span class="hljs-title function_">split_sequences_comparable</span>(ts_data, n_samples, train_size)
y_test = ts_data[<span class="hljs-attr">train_size</span>:]

# <span class="hljs-title class_">Reshaping</span>
X_train = X_train.<span class="hljs-title function_">reshape</span>(X_train.<span class="hljs-property">shape</span>[<span class="hljs-number">0</span>], X_train.<span class="hljs-property">shape</span>[<span class="hljs-number">1</span>], <span class="hljs-number">1</span>)
X_test = X_test.<span class="hljs-title function_">reshape</span>(X_test.<span class="hljs-property">shape</span>[<span class="hljs-number">1</span>], X_test.<span class="hljs-property">shape</span>[<span class="hljs-number">0</span>], <span class="hljs-number">1</span>)
y_train = y_train.<span class="hljs-title function_">reshape</span>(y_train.<span class="hljs-property">shape</span>[<span class="hljs-number">0</span>], y_train.<span class="hljs-property">shape</span>[<span class="hljs-number">1</span>])
y_test = y_test.<span class="hljs-title function_">reshape</span>(y_test.<span class="hljs-property">shape</span>[<span class="hljs-number">1</span>], y_test.<span class="hljs-property">shape</span>[<span class="hljs-number">0</span>], <span class="hljs-number">1</span>)

# <span class="hljs-variable constant_">LSTM</span> 모델 생성 및 훈련
model = <span class="hljs-title class_">Sequential</span>()
model.<span class="hljs-title function_">add</span>(<span class="hljs-title function_">LSTM</span>(units=<span class="hljs-number">154</span>, activation=<span class="hljs-string">'tanh'</span>, input_shape=(n_steps_in, <span class="hljs-number">1</span>)))
model.<span class="hljs-title function_">add</span>(<span class="hljs-title class_">Dense</span>(units=n_steps_out))
model.<span class="hljs-title function_">compile</span>(loss=<span class="hljs-string">'mean_squared_error'</span>, optimizer=<span class="hljs-string">'Adam'</span>, metrics=[<span class="hljs-string">'mape'</span>])

model.<span class="hljs-title function_">fit</span>(x=X_train, y=y_train, epochs=<span class="hljs-number">500</span>, batch_size=<span class="hljs-number">18</span>, verbose=<span class="hljs-number">2</span>)

# 예측
lstm_predictions = model.<span class="hljs-title function_">predict</span>(X_test)
predictions = lstm_predictions.<span class="hljs-title function_">reshape</span>(lstm_predictions.<span class="hljs-property">shape</span>[<span class="hljs-number">1</span>])
lstm_fitted = model.<span class="hljs-title function_">predict</span>(X_train)
fits = [np.<span class="hljs-title function_">diag</span>(np.<span class="hljs-title function_">fliplr</span>(lstm_fitted), i).<span class="hljs-title function_">mean</span>() <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-title function_">range</span>(lstm_fitted.<span class="hljs-property">shape</span>[<span class="hljs-number">1</span>]+n_steps_in - <span class="hljs-number">1</span>, -lstm_fitted.<span class="hljs-property">shape</span>[<span class="hljs-number">0</span>], -<span class="hljs-number">1</span>)]

# 메트릭스
mape = <span class="hljs-title function_">mean_absolute_percentage_error</span>(y_test, predictions)
r2 = <span class="hljs-title function_">r2_score</span>(ts_data[<span class="hljs-attr">n_steps_in</span>:train_size], fits[<span class="hljs-attr">n_steps_in</span>:])

# 실제, 적합 및 예측 플롯
plt.<span class="hljs-title function_">figure</span>(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">6</span>))
plt.<span class="hljs-title function_">plot</span>(date_range, ts_data, label=<span class="hljs-string">'Actual'</span>, color=<span class="hljs-string">'blue'</span>)
plt.<span class="hljs-title function_">plot</span>(date_range[:train_size], fits, label=<span class="hljs-string">'Fitted'</span>, color=<span class="hljs-string">'green'</span>)
plt.<span class="hljs-title function_">plot</span>(date_range[<span class="hljs-attr">train_size</span>:], predictions, label=<span class="hljs-string">'Forecast'</span>, color=<span class="hljs-string">'red'</span>)
plt.<span class="hljs-title function_">title</span>(<span class="hljs-string">'FSC - Short - Passengers\n12 Sample Comparable LSTM Forecast'</span>)
plt.<span class="hljs-title function_">xlabel</span>(<span class="hljs-string">'Date'</span>)
plt.<span class="hljs-title function_">ylabel</span>(<span class="hljs-string">'Passengers'</span>)
plt.<span class="hljs-title function_">legend</span>()
plt.<span class="hljs-title function_">text</span>(<span class="hljs-number">0.05</span>, <span class="hljs-number">0.05</span>, f<span class="hljs-string">'R2 = {r2*100:.2f}%\nMAPE = {mape*100:.2f}%\', transform=plt.gca().transAxes, fontsize=12)
plt.grid(True)
plt.show()
</span></code></pre>
<img src="/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_10.png">
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>지금까지 우리가 얻은 결과는 가장 신뢰할만한 것입니다. 그러나 제가 개발한 혁신적인 방법을 사용하면 더 나은 결과를 얻을 수 있습니다. 이 방법은 나중에 시리즈에서 (순환 방법) 자세히 설명하겠습니다. 먼저 LSTM 네트워크의 하이퍼파라미터를 조정하는 방법에 대해 설명하겠습니다.</p>
<p>LSTM은 모든 시간 단계를 특성으로 집계하기 때문에 시계열 데이터가 모든 이러한 방법에서 손실됩니다. 나중에 시리즈에서 (인코더/디코더 방법) 시계열 입력의 구조를 유지하는 다른 방법을 사용할 것입니다.</p>
<p>계속 주목해 주세요!</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"LSTM 시계열 예측에서 흔히 발생하는 오류를 수정하는 방법","description":"","date":"2024-05-18 19:35","slug":"2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting","content":"\r\nLSTM을 시계열 예측에 사용할 때, 사람들은 흔히 범할 수 있는 함정에 빠지곤 합니다. 이를 설명하기 위해서는 회귀자와 예측자의 작동 방식을 살펴볼 필요가 있습니다. 예측 알고리즘은 시계열 데이터를 다루는 방법을 아래와 같이 보여줍니다:\r\n\r\n![How a forecasting algorithm works](/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_0.png)\r\n\r\n한편, 회귀 문제는 다음과 같이 보일 것입니다:\r\n\r\n![How a regression problem looks](/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_1.png)\r\n\r\n\u003c!-- ui-station 사각형 --\u003e\r\n\r\n\u003cins class=\"adsbygoogle\"\r\nstyle=\"display:block\"\r\ndata-ad-client=\"ca-pub-4877378276818686\"\r\ndata-ad-slot=\"7249294152\"\r\ndata-ad-format=\"auto\"\r\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\r\n\r\n\u003cscript\u003e\r\n(adsbygoogle = window.adsbygoogle || []).push({});\r\n\u003c/script\u003e\r\n\r\nLSTM이 회귀기이므로 시계열을 회귀 문제로 변환해야 합니다. 이를 수행하는 여러 방법이 있지만, 이 섹션에서는 창(Window) 및 다중 단계(Multi-Step) 방법에 대해 설명하고, 어떻게 작동하는지와 특히 이를 활용할 때 발생할 수 있는 일반적인 실수를 피하는 방법에 대해 논의할 것입니다.\r\n\r\n창 방법(Window Method)에서, 시계열은 이전 각 시간 단계의 값과 결합되어 창이라고 불리는 가상 특성으로 되어 있습니다. 여기서 창 크기가 3인 창이 있습니다:\r\n\r\n![창 방법 이미지](/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_2.png)\r\n\r\n다음 함수는 단일 시계열에서 창 방법 데이터 세트를 생성합니다. 사용자는 이전 값의 수(보통 look back이라고 함)를 선택해야 합니다. 결과 데이터 세트에는 대각선 반복이 있으며, look-back 값에 따라 샘플의 수가 달라집니다:\r\n\r\n\u003c!-- ui-station 사각형 --\u003e\r\n\r\n\u003cins class=\"adsbygoogle\"\r\nstyle=\"display:block\"\r\ndata-ad-client=\"ca-pub-4877378276818686\"\r\ndata-ad-slot=\"7249294152\"\r\ndata-ad-format=\"auto\"\r\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\r\n\r\n\u003cscript\u003e\r\n(adsbygoogle = window.adsbygoogle || []).push({});\r\n\u003c/script\u003e\r\n\r\n```js\r\ndef window(sequences, look_back):\r\n    X, y = [], []\r\n    for i in range(len(sequences)-look_back-1):\r\n        x = sequences[i:(i+look_back)]\r\n        X.append(x)\r\n        y.append(sequences[i + look_back])\r\n    return np.array(X), np.array(y)\r\n```\r\n\r\n이제 결과를 살펴보겠습니다. 모델을 훈련한 후에는 테스트 세트에서 테스트됩니다. 다양한 소스와 튜토리얼에서는 비슷한 방법을 사용하여 결과를 컴파일하는 것을 제안했습니다. 그러나 나중에 설명할 것처럼 이 방법은 신빙성이 없습니다. 그럼 지금은 코드와 결과가 어떻게 보이는지 살펴보겠습니다:\r\n\r\n```js\r\nlook_back = 3\r\nX, y = window(ts_data, look_back)\r\n\r\n# 훈련-테스트 분할\r\ntrain_ratio = 0.8\r\ntrain_size = int(train_ratio * len(ts_data))\r\nX_train, X_test = X[:train_size-look_back], X[train_size-look_back:]\r\ny_train, y_test = y[:train_size-look_back], y[train_size-look_back:]\r\n\r\n# LSTM 모델 생성 및 훈련\r\nmodel = Sequential()\r\nmodel.add(LSTM(units=72, activation='tanh', input_shape=(look_back, 1)))\r\nmodel.add(Dense(1))\r\nmodel.compile(loss='mean_squared_error', optimizer='Adam', metrics=['mape'])\r\n\r\nmodel.fit(x=X_train, y=y_train, epochs=500, batch_size=18, verbose=2)\r\n\r\n# 예측 생성\r\nforecasts = model.predict(X_test)\r\nlstm_fits = model.predict(X_train)\r\n\r\n# 메트릭스 계산\r\nmape = mean_absolute_percentage_error(y_test, forecasts)\r\nr2 = r2_score(y_train, lstm_fits)\r\n\r\n# 날짜 초기화\r\ndate_range = pd.date_range(start='1990-01-01', end='2023-09-30', freq='M')\r\n\r\n# 맞춤 값에 원래 시계열과 맞추기 위한 비어있는 값 추가\r\nfits = np.full(train_size, np.nan)\r\nfor i in range(train_size-look_back):\r\n    fits[i+look_back] = lstm_fits[i]\r\n\r\n# 실제값, 맞춤값, 예측값 플롯\r\nplt.figure(figsize=(10, 6))\r\nplt.plot(date_range, ts_data, label='Actual', color='blue')\r\nplt.plot(date_range[:train_size], fits, label='Fitted', color='green')\r\nplt.plot(date_range[train_size:], forecasts, label='Forecast', color='red')\r\nplt.title('FSC - Short - Passengers\\nOne Step Forward Forecast')\r\nplt.xlabel('Date')\r\nplt.ylabel('Passengers')\r\nplt.legend()\r\nplt.text(0.05, 0.05, f'R2 = {r2*100:.2f}%\\nMAPE = {mape*100:.2f}%', transform=plt.gca().transAxes, fontsize=12)\r\nplt.grid(True)\r\nplt.show()\r\n```\r\n\r\n\u003cimg src=\"/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_3.png\" /\u003e\r\n\r\n\u003c!-- ui-station 사각형 --\u003e\r\n\r\n\u003cins class=\"adsbygoogle\"\r\nstyle=\"display:block\"\r\ndata-ad-client=\"ca-pub-4877378276818686\"\r\ndata-ad-slot=\"7249294152\"\r\ndata-ad-format=\"auto\"\r\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\r\n\r\n\u003cscript\u003e\r\n(adsbygoogle = window.adsbygoogle || []).push({});\r\n\u003c/script\u003e\r\n\r\n문제: 결과는 훌륭해 보입니다. 그러나 샘플 테스트 세트를 살펴보면 특이한 결함이 보입니다:\r\n\r\n![이미지](/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_4.png)\r\n\r\n예를 들어 y9를 생성하는 데에는 y8이 입력으로 사용되었습니다. 훈련에는 사용되지 않았지만 미래 값을 포함하는 것은 이상합니다. 왜냐하면 우리는 미래의 시점을 예측하고 있기 때문입니다.\r\n\r\n해결책: 직접적으로 이전 값을 예측 값으로 대체하는 반복적 테스트 세트를 사용하면 이 문제를 해결할 수 있습니다. 이러한 배치 방식에서 모델은 자체 예측에 기반을 둔다. 일반적인 예측 알고리즘과 유사합니다.\r\n\r\n\u003c!-- ui-station 사각형 --\u003e\r\n\r\n\u003cins class=\"adsbygoogle\"\r\nstyle=\"display:block\"\r\ndata-ad-client=\"ca-pub-4877378276818686\"\r\ndata-ad-slot=\"7249294152\"\r\ndata-ad-format=\"auto\"\r\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\r\n\r\n\u003cscript\u003e\r\n(adsbygoogle = window.adsbygoogle || []).push({});\r\n\u003c/script\u003e\r\n\r\n아래 루프에서 다음을 수행합니다:\r\n\r\n```js\r\n# 반복적인 예측 및 대체\r\nfor i in range(len(X_test)):\r\n    forecasts[i] = model.predict(X_test[i].reshape(1, look_back, 1))\r\n    if i != len(X_test)-1:\r\n        X_test[i+1,look_back-1] = forecasts[i]\r\n        for j in range(look_back-1):\r\n            X_test[i+1,j] = X_test[i,j+1]\r\n```\r\n\r\n결과는 완벽하지는 않지만 적어도 정허하다고 할 수 있습니다:\r\n\r\n\u003c!-- ui-station 사각형 --\u003e\r\n\r\n\u003cins class=\"adsbygoogle\"\r\nstyle=\"display:block\"\r\ndata-ad-client=\"ca-pub-4877378276818686\"\r\ndata-ad-slot=\"7249294152\"\r\ndata-ad-format=\"auto\"\r\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\r\n\r\n\u003cscript\u003e\r\n(adsbygoogle = window.adsbygoogle || []).push({});\r\n\u003c/script\u003e\r\n\r\n\u003cimg src=\"/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_6.png\" /\u003e\r\n\r\n다중 단계 방법은 창 방법과 유사하지만 더 많은 대상 단계를 갖습니다. 다음은 두 개의 전방 단계의 샘플입니다:\r\n\r\n\u003cimg src=\"/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_7.png\" /\u003e\r\n\r\n사실, 이 방법에서 사용자는 n_steps_in과 n_steps_out을 선택해야 합니다. 다음 코드는 단순 시계열을 다중 단계 LSTM 훈련을 위해 준비된 데이터 세트로 변환합니다:\r\n\r\n\u003c!-- ui-station 사각형 --\u003e\r\n\r\n\u003cins class=\"adsbygoogle\"\r\nstyle=\"display:block\"\r\ndata-ad-client=\"ca-pub-4877378276818686\"\r\ndata-ad-slot=\"7249294152\"\r\ndata-ad-format=\"auto\"\r\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\r\n\r\n\u003cscript\u003e\r\n(adsbygoogle = window.adsbygoogle || []).push({});\r\n\u003c/script\u003e\r\n\r\n```js\r\n# 단변량 시퀀스를 다단계로 샘플링하기\r\ndef split_sequences(sequences, n_steps_in, n_steps_out):\r\n X, y = list(), list()\r\n for i in range(len(sequences)):\r\n     # 해당 패턴의 끝을 찾음\r\n     end_ix = i + n_steps_in\r\n     out_end_ix = end_ix + n_steps_out\r\n     # 시퀀스를 벗어나는지 확인\r\n     if out_end_ix \u003e len(sequences):\r\n         break\r\n     # 패턴의 입력 및 출력 부분 수집\r\n     seq_x, seq_y = sequences[i:end_ix], sequences[end_ix:out_end_ix]\r\n     X.append(seq_x)\r\n     y.append(seq_y)\r\n return np.array(X), np.array(y)\r\n```\r\n\r\n이제, 특성 뿐만 아니라 타겟도 대각선 반복을 가지고 있어 시계열과 비교하려면 그들을 평균화하거나 예측 중 하나를 선택해야 합니다. 아래 코드에서는 첫 번째, 마지막 및 평균 예측의 결과가 생성되며, 그에 이어 플롯이 제시됩니다. 여기서 첫 번째 예측은 한 달 전 예측을 의미하며, 마지막 예측은 12개월 전 예측을 의미합니다.\r\n\r\n```js\r\nn_steps_in = 12\r\nn_steps_out = 12\r\n\r\nX, y = split_sequences(ts_data, n_steps_in, n_steps_out)\r\nX = X.reshape(X.shape[0], X.shape[1], 1)\r\ny = y.reshape(y.shape[0], y.shape[1], 1)\r\n\r\n# 훈련 및 테스트 세트 분리\r\ntrain_ratio = 0.8\r\ntrain_size = int(train_ratio * len(ts_data))\r\nX_train, X_test = X[:train_size-n_steps_in-n_steps_out+1], X[train_size-n_steps_in-n_steps_out+1:]\r\ny_train = y[:train_size-n_steps_in-n_steps_out+1]\r\ny_test = ts_data[train_size:]\r\n\r\n# LSTM 모델 생성 및 훈련\r\nmodel = Sequential()\r\nmodel.add(LSTM(units=72, activation='tanh', input_shape=(n_steps_in, 1)))\r\nmodel.add(Dense(units=n_steps_out))\r\nmodel.compile(loss='mean_squared_error', optimizer='Adam', metrics=['mape'])\r\n\r\nmodel.fit(x=X_train, y=y_train, epochs=500, batch_size=18, verbose=2)\r\n\r\n# 예측 생성\r\nlstm_predictions = model.predict(X_test)\r\nlstm_fitted = model.predict(X_train)\r\n\r\nforecasts = [np.diag(np.fliplr(lstm_predictions), i).mean() for i in range(0, -lstm_predictions.shape[0], -1)]\r\nfits = [np.diag(np.fliplr(lstm_fitted), i).mean() for i in range(lstm_fitted.shape[1]+n_steps_in - 1, -lstm_fitted.shape[0], -1)]\r\nforecasts1 = lstm_predictions[n_steps_out-1:,0]\r\nfits1 = model.predict(X)[:train_size-n_steps_in,0]\r\nforecasts12 = lstm_predictions[:,n_steps_out-1]\r\nfits12 = lstm_fitted[:,n_steps_out-1]\r\n\r\n# Metric\r\nav_mape = mean_absolute_percentage_error(y_test, forecasts)\r\nav_r2 = r2_score(ts_data[n_steps_in:train_size], fits[n_steps_in:])\r\none_mape = mean_absolute_percentage_error(y_test[:-n_steps_out+1], forecasts1)\r\none_r2 = r2_score(ts_data[n_steps_in:train_size], fits1)\r\ntwelve_mape = mean_absolute_percentage_error(y_test, forecasts12)\r\ntwelve_r2 = r2_score(ts_data[n_steps_in+n_steps_out-1:train_size], fits12)\r\n\r\ndate_range = pd.date_range(start='1990-01-01', end='2023-09-30', freq='M')\r\n\r\n# 실제, 적합 결과 및 예측을 플롯\r\nplt.figure(figsize=(10, 6))\r\nplt.plot(date_range, ts_data, label='Actual', color='blue')\r\nplt.plot(date_range[:train_size], fits, label='Fitted', color='green')\r\nplt.plot(date_range[train_size:], forecasts, label='Forecast', color='red')\r\nplt.title('FSC - Short - Passengers\\n. LSTM 12 Month Average Forecast')\r\nplt.xlabel('Date')\r\nplt.ylabel('Passengers')\r\nplt.legend()\r\nplt.text(0.05, 0.05, f'R2 = {av_r2*100:.2f}%\\nMAPE = {av_mape*100:.2f}%', transform=plt.gca().transAxes, fontsize=12)\r\nplt.grid(True)\r\nplt.show()\r\n\r\nplt.figure(figsize=(10, 6))\r\nplt.plot(date_range, ts_data, label='Actual', color='blue')\r\nplt.plot(date_range[n_steps_in:train_size], fits1, label='Fitted', color='green')\r\nplt.plot(date_range[train_size:-n_steps_out+1], forecasts1, label='Forecast', color='red')\r\nplt.title('FSC - Short - Passengers\\n LSTM 1 Month in advance Forecast')\r\nplt.xlabel('Date')\r\nplt.ylabel('Passengers')\r\nplt.legend()\r\nplt.text(0.05, 0.05, f'R2 = {one_r2*100:.2f}%\\nMAPE = {one_mape*100:.2f}%', transform=plt.gca().transAxes, fontsize=12)\r\nplt.grid(True)\r\nplt.show()\r\n\r\nplt.figure(figsize=(10, 6))\r\nplt.plot(date_range, ts_data, label='Actual', color='blue')\r\nplt.plot(date_range[n_steps_in+n_steps_out-1:train_size], fits12, label='Fitted', color='green')\r\nplt.plot(date_range[train_size:], forecasts12, label='Forecast', color='red')\r\nplt.title('FSC - Short - Passengers\\n LSTM 12 Months in advance Forecast')\r\nplt.xlabel('Date')\r\nplt.ylabel('Passengers')\r\nplt.legend()\r\nplt.text(0.05, 0.05, f'R2 = {twelve_r2*100:.2f}%\\nMAPE = {twelve_mape*100:.2f}%', transform=plt.gca().transAxes, fontsize=12)\r\nplt.grid(True)\r\nplt.show()\r\n```\r\n\r\n이슈: 창 메서드와 동일한 문제가 여기에도 있습니다:\r\n\r\n\u003c!-- ui-station 사각형 --\u003e\r\n\r\n\u003cins class=\"adsbygoogle\"\r\nstyle=\"display:block\"\r\ndata-ad-client=\"ca-pub-4877378276818686\"\r\ndata-ad-slot=\"7249294152\"\r\ndata-ad-format=\"auto\"\r\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\r\n\r\n\u003cscript\u003e\r\n(adsbygoogle = window.adsbygoogle || []).push({});\r\n\u003c/script\u003e\r\n\r\n![이미지](/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_8.png)\r\n\r\n해상도: 창 법과 비슷한 방법을 사용할 수 있습니다. 그러나 n_steps_out을 test_size와 동일하게 선택할 수도 있습니다. 이렇게 하면 테스트 세트가 하나로 축소됩니다:\r\n\r\n![이미지](/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_9.png)\r\n\r\n다음 함수는 이를 정확히 수행합니다. 이 함수는 시계열, 학습 크기 및 샘플 수를 사용합니다. 이 버전은 다른 예측 알고리즘과 비교할 수 있기 때문에 comparable로 이름 지었습니다:\r\n\r\n\u003c!-- ui-station 사각형 --\u003e\r\n\r\n\u003cins class=\"adsbygoogle\"\r\nstyle=\"display:block\"\r\ndata-ad-client=\"ca-pub-4877378276818686\"\r\ndata-ad-slot=\"7249294152\"\r\ndata-ad-format=\"auto\"\r\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\r\n\r\n\u003cscript\u003e\r\n(adsbygoogle = window.adsbygoogle || []).push({});\r\n\u003c/script\u003e\r\n\r\n```js\r\ndef split_sequences_comparable(sequences, n_samples, train_size):\r\n # 단계\r\n n_steps_out = len(sequences) - train_size\r\n n_steps_in = train_size - n_steps_out - n_samples + 1\r\n # 끝 세트\r\n X_test = sequences[n_samples + n_steps_out - 1:train_size]\r\n X_forecast = sequences[-n_steps_in:]\r\n X, y = list(), list()\r\n for i in range(n_samples):\r\n     # 이 패턴의 끝을 찾습니다\r\n     end_ix = i + n_steps_in\r\n     out_end_ix = end_ix + n_steps_out\r\n     # 패턴의 입력 및 출력 부분을 수집합니다\r\n     seq_x, seq_y = sequences[i:end_ix], sequences[end_ix:out_end_ix]\r\n     X.append(seq_x)\r\n     y.append(seq_y)\r\n return np.array(X), np.array(y), np.array(X_test), np.array(X_forecast), n_steps_in, n_steps_out\r\n```\r\n\r\n이 함수에서는 단계 수가 이미 고정되었기 때문에 샘플 수와 훈련 크기는 사용자가 선택하도록 하고, 최대 가능한 단계 수를 계산하도록 결정했습니다. 아래는 실행된 코드와 그 결과입니다:\r\n\r\n```js\r\nn_samples = 12\r\ntrain_size = 321\r\nX_train, y_train, X_test, X_forecast, n_steps_in, n_steps_out = split_sequences_comparable(ts_data, n_samples, train_size)\r\ny_test = ts_data[train_size:]\r\n\r\n# Reshaping\r\nX_train = X_train.reshape(X_train.shape[0], X_train.shape[1], 1)\r\nX_test = X_test.reshape(X_test.shape[1], X_test.shape[0], 1)\r\ny_train = y_train.reshape(y_train.shape[0], y_train.shape[1])\r\ny_test = y_test.reshape(y_test.shape[1], y_test.shape[0], 1)\r\n\r\n# LSTM 모델 생성 및 훈련\r\nmodel = Sequential()\r\nmodel.add(LSTM(units=154, activation='tanh', input_shape=(n_steps_in, 1)))\r\nmodel.add(Dense(units=n_steps_out))\r\nmodel.compile(loss='mean_squared_error', optimizer='Adam', metrics=['mape'])\r\n\r\nmodel.fit(x=X_train, y=y_train, epochs=500, batch_size=18, verbose=2)\r\n\r\n# 예측\r\nlstm_predictions = model.predict(X_test)\r\npredictions = lstm_predictions.reshape(lstm_predictions.shape[1])\r\nlstm_fitted = model.predict(X_train)\r\nfits = [np.diag(np.fliplr(lstm_fitted), i).mean() for i in range(lstm_fitted.shape[1]+n_steps_in - 1, -lstm_fitted.shape[0], -1)]\r\n\r\n# 메트릭스\r\nmape = mean_absolute_percentage_error(y_test, predictions)\r\nr2 = r2_score(ts_data[n_steps_in:train_size], fits[n_steps_in:])\r\n\r\n# 실제, 적합 및 예측 플롯\r\nplt.figure(figsize=(10, 6))\r\nplt.plot(date_range, ts_data, label='Actual', color='blue')\r\nplt.plot(date_range[:train_size], fits, label='Fitted', color='green')\r\nplt.plot(date_range[train_size:], predictions, label='Forecast', color='red')\r\nplt.title('FSC - Short - Passengers\\n12 Sample Comparable LSTM Forecast')\r\nplt.xlabel('Date')\r\nplt.ylabel('Passengers')\r\nplt.legend()\r\nplt.text(0.05, 0.05, f'R2 = {r2*100:.2f}%\\nMAPE = {mape*100:.2f}%\\', transform=plt.gca().transAxes, fontsize=12)\r\nplt.grid(True)\r\nplt.show()\r\n```\r\n\r\n\u003cimg src=\"/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_10.png\" /\u003e\r\n\r\n\u003c!-- ui-station 사각형 --\u003e\r\n\r\n\u003cins class=\"adsbygoogle\"\r\nstyle=\"display:block\"\r\ndata-ad-client=\"ca-pub-4877378276818686\"\r\ndata-ad-slot=\"7249294152\"\r\ndata-ad-format=\"auto\"\r\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\r\n\r\n\u003cscript\u003e\r\n(adsbygoogle = window.adsbygoogle || []).push({});\r\n\u003c/script\u003e\r\n\r\n지금까지 우리가 얻은 결과는 가장 신뢰할만한 것입니다. 그러나 제가 개발한 혁신적인 방법을 사용하면 더 나은 결과를 얻을 수 있습니다. 이 방법은 나중에 시리즈에서 (순환 방법) 자세히 설명하겠습니다. 먼저 LSTM 네트워크의 하이퍼파라미터를 조정하는 방법에 대해 설명하겠습니다.\r\n\r\nLSTM은 모든 시간 단계를 특성으로 집계하기 때문에 시계열 데이터가 모든 이러한 방법에서 손실됩니다. 나중에 시리즈에서 (인코더/디코더 방법) 시계열 입력의 구조를 유지하는 다른 방법을 사용할 것입니다.\r\n\r\n계속 주목해 주세요!\r\n","ogImage":{"url":"/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_0.png"},"coverImage":"/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_0.png","tag":["Tech"],"readingTime":15},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003eLSTM을 시계열 예측에 사용할 때, 사람들은 흔히 범할 수 있는 함정에 빠지곤 합니다. 이를 설명하기 위해서는 회귀자와 예측자의 작동 방식을 살펴볼 필요가 있습니다. 예측 알고리즘은 시계열 데이터를 다루는 방법을 아래와 같이 보여줍니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_0.png\" alt=\"How a forecasting algorithm works\"\u003e\u003c/p\u003e\n\u003cp\u003e한편, 회귀 문제는 다음과 같이 보일 것입니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_1.png\" alt=\"How a regression problem looks\"\u003e\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eLSTM이 회귀기이므로 시계열을 회귀 문제로 변환해야 합니다. 이를 수행하는 여러 방법이 있지만, 이 섹션에서는 창(Window) 및 다중 단계(Multi-Step) 방법에 대해 설명하고, 어떻게 작동하는지와 특히 이를 활용할 때 발생할 수 있는 일반적인 실수를 피하는 방법에 대해 논의할 것입니다.\u003c/p\u003e\n\u003cp\u003e창 방법(Window Method)에서, 시계열은 이전 각 시간 단계의 값과 결합되어 창이라고 불리는 가상 특성으로 되어 있습니다. 여기서 창 크기가 3인 창이 있습니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_2.png\" alt=\"창 방법 이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e다음 함수는 단일 시계열에서 창 방법 데이터 세트를 생성합니다. 사용자는 이전 값의 수(보통 look back이라고 함)를 선택해야 합니다. 결과 데이터 세트에는 대각선 반복이 있으며, look-back 값에 따라 샘플의 수가 달라집니다:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edef \u003cspan class=\"hljs-title function_\"\u003ewindow\u003c/span\u003e(sequences, look_back):\r\n    X, y = [], []\r\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e i \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erange\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003elen\u003c/span\u003e(sequences)-look_back-\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e):\r\n        x = sequences[\u003cspan class=\"hljs-attr\"\u003ei\u003c/span\u003e:(i+look_back)]\r\n        X.\u003cspan class=\"hljs-title function_\"\u003eappend\u003c/span\u003e(x)\r\n        y.\u003cspan class=\"hljs-title function_\"\u003eappend\u003c/span\u003e(sequences[i + look_back])\r\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e np.\u003cspan class=\"hljs-title function_\"\u003earray\u003c/span\u003e(X), np.\u003cspan class=\"hljs-title function_\"\u003earray\u003c/span\u003e(y)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 결과를 살펴보겠습니다. 모델을 훈련한 후에는 테스트 세트에서 테스트됩니다. 다양한 소스와 튜토리얼에서는 비슷한 방법을 사용하여 결과를 컴파일하는 것을 제안했습니다. 그러나 나중에 설명할 것처럼 이 방법은 신빙성이 없습니다. 그럼 지금은 코드와 결과가 어떻게 보이는지 살펴보겠습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003elook_back = \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e\r\nX, y = \u003cspan class=\"hljs-title function_\"\u003ewindow\u003c/span\u003e(ts_data, look_back)\r\n\r\n# 훈련-테스트 분할\r\ntrain_ratio = \u003cspan class=\"hljs-number\"\u003e0.8\u003c/span\u003e\r\ntrain_size = \u003cspan class=\"hljs-title function_\"\u003eint\u003c/span\u003e(train_ratio * \u003cspan class=\"hljs-title function_\"\u003elen\u003c/span\u003e(ts_data))\r\nX_train, X_test = X[:train_size-look_back], X[train_size-\u003cspan class=\"hljs-attr\"\u003elook_back\u003c/span\u003e:]\r\ny_train, y_test = y[:train_size-look_back], y[train_size-\u003cspan class=\"hljs-attr\"\u003elook_back\u003c/span\u003e:]\r\n\r\n# \u003cspan class=\"hljs-variable constant_\"\u003eLSTM\u003c/span\u003e 모델 생성 및 훈련\r\nmodel = \u003cspan class=\"hljs-title class_\"\u003eSequential\u003c/span\u003e()\r\nmodel.\u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003eLSTM\u003c/span\u003e(units=\u003cspan class=\"hljs-number\"\u003e72\u003c/span\u003e, activation=\u003cspan class=\"hljs-string\"\u003e'tanh'\u003c/span\u003e, input_shape=(look_back, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)))\r\nmodel.\u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eDense\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e))\r\nmodel.\u003cspan class=\"hljs-title function_\"\u003ecompile\u003c/span\u003e(loss=\u003cspan class=\"hljs-string\"\u003e'mean_squared_error'\u003c/span\u003e, optimizer=\u003cspan class=\"hljs-string\"\u003e'Adam'\u003c/span\u003e, metrics=[\u003cspan class=\"hljs-string\"\u003e'mape'\u003c/span\u003e])\r\n\r\nmodel.\u003cspan class=\"hljs-title function_\"\u003efit\u003c/span\u003e(x=X_train, y=y_train, epochs=\u003cspan class=\"hljs-number\"\u003e500\u003c/span\u003e, batch_size=\u003cspan class=\"hljs-number\"\u003e18\u003c/span\u003e, verbose=\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e)\r\n\r\n# 예측 생성\r\nforecasts = model.\u003cspan class=\"hljs-title function_\"\u003epredict\u003c/span\u003e(X_test)\r\nlstm_fits = model.\u003cspan class=\"hljs-title function_\"\u003epredict\u003c/span\u003e(X_train)\r\n\r\n# 메트릭스 계산\r\nmape = \u003cspan class=\"hljs-title function_\"\u003emean_absolute_percentage_error\u003c/span\u003e(y_test, forecasts)\r\nr2 = \u003cspan class=\"hljs-title function_\"\u003er2_score\u003c/span\u003e(y_train, lstm_fits)\r\n\r\n# 날짜 초기화\r\ndate_range = pd.\u003cspan class=\"hljs-title function_\"\u003edate_range\u003c/span\u003e(start=\u003cspan class=\"hljs-string\"\u003e'1990-01-01'\u003c/span\u003e, end=\u003cspan class=\"hljs-string\"\u003e'2023-09-30'\u003c/span\u003e, freq=\u003cspan class=\"hljs-string\"\u003e'M'\u003c/span\u003e)\r\n\r\n# 맞춤 값에 원래 시계열과 맞추기 위한 비어있는 값 추가\r\nfits = np.\u003cspan class=\"hljs-title function_\"\u003efull\u003c/span\u003e(train_size, np.\u003cspan class=\"hljs-property\"\u003enan\u003c/span\u003e)\r\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e i \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erange\u003c/span\u003e(train_size-look_back):\r\n    fits[i+look_back] = lstm_fits[i]\r\n\r\n# 실제값, 맞춤값, 예측값 플롯\r\nplt.\u003cspan class=\"hljs-title function_\"\u003efigure\u003c/span\u003e(figsize=(\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e))\r\nplt.\u003cspan class=\"hljs-title function_\"\u003eplot\u003c/span\u003e(date_range, ts_data, label=\u003cspan class=\"hljs-string\"\u003e'Actual'\u003c/span\u003e, color=\u003cspan class=\"hljs-string\"\u003e'blue'\u003c/span\u003e)\r\nplt.\u003cspan class=\"hljs-title function_\"\u003eplot\u003c/span\u003e(date_range[:train_size], fits, label=\u003cspan class=\"hljs-string\"\u003e'Fitted'\u003c/span\u003e, color=\u003cspan class=\"hljs-string\"\u003e'green'\u003c/span\u003e)\r\nplt.\u003cspan class=\"hljs-title function_\"\u003eplot\u003c/span\u003e(date_range[\u003cspan class=\"hljs-attr\"\u003etrain_size\u003c/span\u003e:], forecasts, label=\u003cspan class=\"hljs-string\"\u003e'Forecast'\u003c/span\u003e, color=\u003cspan class=\"hljs-string\"\u003e'red'\u003c/span\u003e)\r\nplt.\u003cspan class=\"hljs-title function_\"\u003etitle\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'FSC - Short - Passengers\\nOne Step Forward Forecast'\u003c/span\u003e)\r\nplt.\u003cspan class=\"hljs-title function_\"\u003exlabel\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Date'\u003c/span\u003e)\r\nplt.\u003cspan class=\"hljs-title function_\"\u003eylabel\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Passengers'\u003c/span\u003e)\r\nplt.\u003cspan class=\"hljs-title function_\"\u003elegend\u003c/span\u003e()\r\nplt.\u003cspan class=\"hljs-title function_\"\u003etext\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0.05\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0.05\u003c/span\u003e, f\u003cspan class=\"hljs-string\"\u003e'R2 = {r2*100:.2f}%\\nMAPE = {mape*100:.2f}%'\u003c/span\u003e, transform=plt.\u003cspan class=\"hljs-title function_\"\u003egca\u003c/span\u003e().\u003cspan class=\"hljs-property\"\u003etransAxes\u003c/span\u003e, fontsize=\u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e)\r\nplt.\u003cspan class=\"hljs-title function_\"\u003egrid\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e)\r\nplt.\u003cspan class=\"hljs-title function_\"\u003eshow\u003c/span\u003e()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_3.png\"\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e문제: 결과는 훌륭해 보입니다. 그러나 샘플 테스트 세트를 살펴보면 특이한 결함이 보입니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_4.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e예를 들어 y9를 생성하는 데에는 y8이 입력으로 사용되었습니다. 훈련에는 사용되지 않았지만 미래 값을 포함하는 것은 이상합니다. 왜냐하면 우리는 미래의 시점을 예측하고 있기 때문입니다.\u003c/p\u003e\n\u003cp\u003e해결책: 직접적으로 이전 값을 예측 값으로 대체하는 반복적 테스트 세트를 사용하면 이 문제를 해결할 수 있습니다. 이러한 배치 방식에서 모델은 자체 예측에 기반을 둔다. 일반적인 예측 알고리즘과 유사합니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e아래 루프에서 다음을 수행합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 반복적인 예측 및 대체\r\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e i \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erange\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003elen\u003c/span\u003e(X_test)):\r\n    forecasts[i] = model.\u003cspan class=\"hljs-title function_\"\u003epredict\u003c/span\u003e(X_test[i].\u003cspan class=\"hljs-title function_\"\u003ereshape\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, look_back, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e))\r\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e i != \u003cspan class=\"hljs-title function_\"\u003elen\u003c/span\u003e(X_test)-\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e:\r\n        X_test[i+\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,look_back-\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e] = forecasts[i]\r\n        \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e j \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erange\u003c/span\u003e(look_back-\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e):\r\n            X_test[i+\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,j] = X_test[i,j+\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e결과는 완벽하지는 않지만 적어도 정허하다고 할 수 있습니다:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cimg src=\"/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_6.png\"\u003e\n\u003cp\u003e다중 단계 방법은 창 방법과 유사하지만 더 많은 대상 단계를 갖습니다. 다음은 두 개의 전방 단계의 샘플입니다:\u003c/p\u003e\n\u003cimg src=\"/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_7.png\"\u003e\n\u003cp\u003e사실, 이 방법에서 사용자는 n_steps_in과 n_steps_out을 선택해야 합니다. 다음 코드는 단순 시계열을 다중 단계 LSTM 훈련을 위해 준비된 데이터 세트로 변환합니다:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 단변량 시퀀스를 다단계로 샘플링하기\r\ndef \u003cspan class=\"hljs-title function_\"\u003esplit_sequences\u003c/span\u003e(sequences, n_steps_in, n_steps_out):\r\n X, y = \u003cspan class=\"hljs-title function_\"\u003elist\u003c/span\u003e(), \u003cspan class=\"hljs-title function_\"\u003elist\u003c/span\u003e()\r\n \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e i \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erange\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003elen\u003c/span\u003e(sequences)):\r\n     # 해당 패턴의 끝을 찾음\r\n     end_ix = i + n_steps_in\r\n     out_end_ix = end_ix + n_steps_out\r\n     # 시퀀스를 벗어나는지 확인\r\n     \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e out_end_ix \u003e \u003cspan class=\"hljs-title function_\"\u003elen\u003c/span\u003e(sequences):\r\n         \u003cspan class=\"hljs-keyword\"\u003ebreak\u003c/span\u003e\r\n     # 패턴의 입력 및 출력 부분 수집\r\n     seq_x, seq_y = sequences[\u003cspan class=\"hljs-attr\"\u003ei\u003c/span\u003e:end_ix], sequences[\u003cspan class=\"hljs-attr\"\u003eend_ix\u003c/span\u003e:out_end_ix]\r\n     X.\u003cspan class=\"hljs-title function_\"\u003eappend\u003c/span\u003e(seq_x)\r\n     y.\u003cspan class=\"hljs-title function_\"\u003eappend\u003c/span\u003e(seq_y)\r\n \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e np.\u003cspan class=\"hljs-title function_\"\u003earray\u003c/span\u003e(X), np.\u003cspan class=\"hljs-title function_\"\u003earray\u003c/span\u003e(y)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제, 특성 뿐만 아니라 타겟도 대각선 반복을 가지고 있어 시계열과 비교하려면 그들을 평균화하거나 예측 중 하나를 선택해야 합니다. 아래 코드에서는 첫 번째, 마지막 및 평균 예측의 결과가 생성되며, 그에 이어 플롯이 제시됩니다. 여기서 첫 번째 예측은 한 달 전 예측을 의미하며, 마지막 예측은 12개월 전 예측을 의미합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003en_steps_in = \u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e\r\nn_steps_out = \u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e\r\n\r\nX, y = \u003cspan class=\"hljs-title function_\"\u003esplit_sequences\u003c/span\u003e(ts_data, n_steps_in, n_steps_out)\r\nX = X.\u003cspan class=\"hljs-title function_\"\u003ereshape\u003c/span\u003e(X.\u003cspan class=\"hljs-property\"\u003eshape\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e], X.\u003cspan class=\"hljs-property\"\u003eshape\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e], \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)\r\ny = y.\u003cspan class=\"hljs-title function_\"\u003ereshape\u003c/span\u003e(y.\u003cspan class=\"hljs-property\"\u003eshape\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e], y.\u003cspan class=\"hljs-property\"\u003eshape\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e], \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)\r\n\r\n# 훈련 및 테스트 세트 분리\r\ntrain_ratio = \u003cspan class=\"hljs-number\"\u003e0.8\u003c/span\u003e\r\ntrain_size = \u003cspan class=\"hljs-title function_\"\u003eint\u003c/span\u003e(train_ratio * \u003cspan class=\"hljs-title function_\"\u003elen\u003c/span\u003e(ts_data))\r\nX_train, X_test = X[:train_size-n_steps_in-n_steps_out+\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e], X[train_size-n_steps_in-n_steps_out+\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e:]\r\ny_train = y[:train_size-n_steps_in-n_steps_out+\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e]\r\ny_test = ts_data[\u003cspan class=\"hljs-attr\"\u003etrain_size\u003c/span\u003e:]\r\n\r\n# \u003cspan class=\"hljs-variable constant_\"\u003eLSTM\u003c/span\u003e 모델 생성 및 훈련\r\nmodel = \u003cspan class=\"hljs-title class_\"\u003eSequential\u003c/span\u003e()\r\nmodel.\u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003eLSTM\u003c/span\u003e(units=\u003cspan class=\"hljs-number\"\u003e72\u003c/span\u003e, activation=\u003cspan class=\"hljs-string\"\u003e'tanh'\u003c/span\u003e, input_shape=(n_steps_in, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)))\r\nmodel.\u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eDense\u003c/span\u003e(units=n_steps_out))\r\nmodel.\u003cspan class=\"hljs-title function_\"\u003ecompile\u003c/span\u003e(loss=\u003cspan class=\"hljs-string\"\u003e'mean_squared_error'\u003c/span\u003e, optimizer=\u003cspan class=\"hljs-string\"\u003e'Adam'\u003c/span\u003e, metrics=[\u003cspan class=\"hljs-string\"\u003e'mape'\u003c/span\u003e])\r\n\r\nmodel.\u003cspan class=\"hljs-title function_\"\u003efit\u003c/span\u003e(x=X_train, y=y_train, epochs=\u003cspan class=\"hljs-number\"\u003e500\u003c/span\u003e, batch_size=\u003cspan class=\"hljs-number\"\u003e18\u003c/span\u003e, verbose=\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e)\r\n\r\n# 예측 생성\r\nlstm_predictions = model.\u003cspan class=\"hljs-title function_\"\u003epredict\u003c/span\u003e(X_test)\r\nlstm_fitted = model.\u003cspan class=\"hljs-title function_\"\u003epredict\u003c/span\u003e(X_train)\r\n\r\nforecasts = [np.\u003cspan class=\"hljs-title function_\"\u003ediag\u003c/span\u003e(np.\u003cspan class=\"hljs-title function_\"\u003efliplr\u003c/span\u003e(lstm_predictions), i).\u003cspan class=\"hljs-title function_\"\u003emean\u003c/span\u003e() \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e i \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erange\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, -lstm_predictions.\u003cspan class=\"hljs-property\"\u003eshape\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e], -\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)]\r\nfits = [np.\u003cspan class=\"hljs-title function_\"\u003ediag\u003c/span\u003e(np.\u003cspan class=\"hljs-title function_\"\u003efliplr\u003c/span\u003e(lstm_fitted), i).\u003cspan class=\"hljs-title function_\"\u003emean\u003c/span\u003e() \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e i \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erange\u003c/span\u003e(lstm_fitted.\u003cspan class=\"hljs-property\"\u003eshape\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e]+n_steps_in - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, -lstm_fitted.\u003cspan class=\"hljs-property\"\u003eshape\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e], -\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)]\r\nforecasts1 = lstm_predictions[n_steps_out-\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e:,\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]\r\nfits1 = model.\u003cspan class=\"hljs-title function_\"\u003epredict\u003c/span\u003e(X)[:train_size-n_steps_in,\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]\r\nforecasts12 = lstm_predictions[:,n_steps_out-\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e]\r\nfits12 = lstm_fitted[:,n_steps_out-\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e]\r\n\r\n# \u003cspan class=\"hljs-title class_\"\u003eMetric\u003c/span\u003e\r\nav_mape = \u003cspan class=\"hljs-title function_\"\u003emean_absolute_percentage_error\u003c/span\u003e(y_test, forecasts)\r\nav_r2 = \u003cspan class=\"hljs-title function_\"\u003er2_score\u003c/span\u003e(ts_data[\u003cspan class=\"hljs-attr\"\u003en_steps_in\u003c/span\u003e:train_size], fits[\u003cspan class=\"hljs-attr\"\u003en_steps_in\u003c/span\u003e:])\r\none_mape = \u003cspan class=\"hljs-title function_\"\u003emean_absolute_percentage_error\u003c/span\u003e(y_test[:-n_steps_out+\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e], forecasts1)\r\none_r2 = \u003cspan class=\"hljs-title function_\"\u003er2_score\u003c/span\u003e(ts_data[\u003cspan class=\"hljs-attr\"\u003en_steps_in\u003c/span\u003e:train_size], fits1)\r\ntwelve_mape = \u003cspan class=\"hljs-title function_\"\u003emean_absolute_percentage_error\u003c/span\u003e(y_test, forecasts12)\r\ntwelve_r2 = \u003cspan class=\"hljs-title function_\"\u003er2_score\u003c/span\u003e(ts_data[n_steps_in+n_steps_out-\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e:train_size], fits12)\r\n\r\ndate_range = pd.\u003cspan class=\"hljs-title function_\"\u003edate_range\u003c/span\u003e(start=\u003cspan class=\"hljs-string\"\u003e'1990-01-01'\u003c/span\u003e, end=\u003cspan class=\"hljs-string\"\u003e'2023-09-30'\u003c/span\u003e, freq=\u003cspan class=\"hljs-string\"\u003e'M'\u003c/span\u003e)\r\n\r\n# 실제, 적합 결과 및 예측을 플롯\r\nplt.\u003cspan class=\"hljs-title function_\"\u003efigure\u003c/span\u003e(figsize=(\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e))\r\nplt.\u003cspan class=\"hljs-title function_\"\u003eplot\u003c/span\u003e(date_range, ts_data, label=\u003cspan class=\"hljs-string\"\u003e'Actual'\u003c/span\u003e, color=\u003cspan class=\"hljs-string\"\u003e'blue'\u003c/span\u003e)\r\nplt.\u003cspan class=\"hljs-title function_\"\u003eplot\u003c/span\u003e(date_range[:train_size], fits, label=\u003cspan class=\"hljs-string\"\u003e'Fitted'\u003c/span\u003e, color=\u003cspan class=\"hljs-string\"\u003e'green'\u003c/span\u003e)\r\nplt.\u003cspan class=\"hljs-title function_\"\u003eplot\u003c/span\u003e(date_range[\u003cspan class=\"hljs-attr\"\u003etrain_size\u003c/span\u003e:], forecasts, label=\u003cspan class=\"hljs-string\"\u003e'Forecast'\u003c/span\u003e, color=\u003cspan class=\"hljs-string\"\u003e'red'\u003c/span\u003e)\r\nplt.\u003cspan class=\"hljs-title function_\"\u003etitle\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'FSC - Short - Passengers\\n. LSTM 12 Month Average Forecast'\u003c/span\u003e)\r\nplt.\u003cspan class=\"hljs-title function_\"\u003exlabel\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Date'\u003c/span\u003e)\r\nplt.\u003cspan class=\"hljs-title function_\"\u003eylabel\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Passengers'\u003c/span\u003e)\r\nplt.\u003cspan class=\"hljs-title function_\"\u003elegend\u003c/span\u003e()\r\nplt.\u003cspan class=\"hljs-title function_\"\u003etext\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0.05\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0.05\u003c/span\u003e, f\u003cspan class=\"hljs-string\"\u003e'R2 = {av_r2*100:.2f}%\\nMAPE = {av_mape*100:.2f}%'\u003c/span\u003e, transform=plt.\u003cspan class=\"hljs-title function_\"\u003egca\u003c/span\u003e().\u003cspan class=\"hljs-property\"\u003etransAxes\u003c/span\u003e, fontsize=\u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e)\r\nplt.\u003cspan class=\"hljs-title function_\"\u003egrid\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e)\r\nplt.\u003cspan class=\"hljs-title function_\"\u003eshow\u003c/span\u003e()\r\n\r\nplt.\u003cspan class=\"hljs-title function_\"\u003efigure\u003c/span\u003e(figsize=(\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e))\r\nplt.\u003cspan class=\"hljs-title function_\"\u003eplot\u003c/span\u003e(date_range, ts_data, label=\u003cspan class=\"hljs-string\"\u003e'Actual'\u003c/span\u003e, color=\u003cspan class=\"hljs-string\"\u003e'blue'\u003c/span\u003e)\r\nplt.\u003cspan class=\"hljs-title function_\"\u003eplot\u003c/span\u003e(date_range[\u003cspan class=\"hljs-attr\"\u003en_steps_in\u003c/span\u003e:train_size], fits1, label=\u003cspan class=\"hljs-string\"\u003e'Fitted'\u003c/span\u003e, color=\u003cspan class=\"hljs-string\"\u003e'green'\u003c/span\u003e)\r\nplt.\u003cspan class=\"hljs-title function_\"\u003eplot\u003c/span\u003e(date_range[\u003cspan class=\"hljs-attr\"\u003etrain_size\u003c/span\u003e:-n_steps_out+\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e], forecasts1, label=\u003cspan class=\"hljs-string\"\u003e'Forecast'\u003c/span\u003e, color=\u003cspan class=\"hljs-string\"\u003e'red'\u003c/span\u003e)\r\nplt.\u003cspan class=\"hljs-title function_\"\u003etitle\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'FSC - Short - Passengers\\n LSTM 1 Month in advance Forecast'\u003c/span\u003e)\r\nplt.\u003cspan class=\"hljs-title function_\"\u003exlabel\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Date'\u003c/span\u003e)\r\nplt.\u003cspan class=\"hljs-title function_\"\u003eylabel\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Passengers'\u003c/span\u003e)\r\nplt.\u003cspan class=\"hljs-title function_\"\u003elegend\u003c/span\u003e()\r\nplt.\u003cspan class=\"hljs-title function_\"\u003etext\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0.05\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0.05\u003c/span\u003e, f\u003cspan class=\"hljs-string\"\u003e'R2 = {one_r2*100:.2f}%\\nMAPE = {one_mape*100:.2f}%'\u003c/span\u003e, transform=plt.\u003cspan class=\"hljs-title function_\"\u003egca\u003c/span\u003e().\u003cspan class=\"hljs-property\"\u003etransAxes\u003c/span\u003e, fontsize=\u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e)\r\nplt.\u003cspan class=\"hljs-title function_\"\u003egrid\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e)\r\nplt.\u003cspan class=\"hljs-title function_\"\u003eshow\u003c/span\u003e()\r\n\r\nplt.\u003cspan class=\"hljs-title function_\"\u003efigure\u003c/span\u003e(figsize=(\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e))\r\nplt.\u003cspan class=\"hljs-title function_\"\u003eplot\u003c/span\u003e(date_range, ts_data, label=\u003cspan class=\"hljs-string\"\u003e'Actual'\u003c/span\u003e, color=\u003cspan class=\"hljs-string\"\u003e'blue'\u003c/span\u003e)\r\nplt.\u003cspan class=\"hljs-title function_\"\u003eplot\u003c/span\u003e(date_range[n_steps_in+n_steps_out-\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e:train_size], fits12, label=\u003cspan class=\"hljs-string\"\u003e'Fitted'\u003c/span\u003e, color=\u003cspan class=\"hljs-string\"\u003e'green'\u003c/span\u003e)\r\nplt.\u003cspan class=\"hljs-title function_\"\u003eplot\u003c/span\u003e(date_range[\u003cspan class=\"hljs-attr\"\u003etrain_size\u003c/span\u003e:], forecasts12, label=\u003cspan class=\"hljs-string\"\u003e'Forecast'\u003c/span\u003e, color=\u003cspan class=\"hljs-string\"\u003e'red'\u003c/span\u003e)\r\nplt.\u003cspan class=\"hljs-title function_\"\u003etitle\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'FSC - Short - Passengers\\n LSTM 12 Months in advance Forecast'\u003c/span\u003e)\r\nplt.\u003cspan class=\"hljs-title function_\"\u003exlabel\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Date'\u003c/span\u003e)\r\nplt.\u003cspan class=\"hljs-title function_\"\u003eylabel\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Passengers'\u003c/span\u003e)\r\nplt.\u003cspan class=\"hljs-title function_\"\u003elegend\u003c/span\u003e()\r\nplt.\u003cspan class=\"hljs-title function_\"\u003etext\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0.05\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0.05\u003c/span\u003e, f\u003cspan class=\"hljs-string\"\u003e'R2 = {twelve_r2*100:.2f}%\\nMAPE = {twelve_mape*100:.2f}%'\u003c/span\u003e, transform=plt.\u003cspan class=\"hljs-title function_\"\u003egca\u003c/span\u003e().\u003cspan class=\"hljs-property\"\u003etransAxes\u003c/span\u003e, fontsize=\u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e)\r\nplt.\u003cspan class=\"hljs-title function_\"\u003egrid\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e)\r\nplt.\u003cspan class=\"hljs-title function_\"\u003eshow\u003c/span\u003e()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이슈: 창 메서드와 동일한 문제가 여기에도 있습니다:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_8.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e해상도: 창 법과 비슷한 방법을 사용할 수 있습니다. 그러나 n_steps_out을 test_size와 동일하게 선택할 수도 있습니다. 이렇게 하면 테스트 세트가 하나로 축소됩니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_9.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e다음 함수는 이를 정확히 수행합니다. 이 함수는 시계열, 학습 크기 및 샘플 수를 사용합니다. 이 버전은 다른 예측 알고리즘과 비교할 수 있기 때문에 comparable로 이름 지었습니다:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edef \u003cspan class=\"hljs-title function_\"\u003esplit_sequences_comparable\u003c/span\u003e(sequences, n_samples, train_size):\r\n # 단계\r\n n_steps_out = \u003cspan class=\"hljs-title function_\"\u003elen\u003c/span\u003e(sequences) - train_size\r\n n_steps_in = train_size - n_steps_out - n_samples + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\r\n # 끝 세트\r\n X_test = sequences[n_samples + n_steps_out - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e:train_size]\r\n X_forecast = sequences[-\u003cspan class=\"hljs-attr\"\u003en_steps_in\u003c/span\u003e:]\r\n X, y = \u003cspan class=\"hljs-title function_\"\u003elist\u003c/span\u003e(), \u003cspan class=\"hljs-title function_\"\u003elist\u003c/span\u003e()\r\n \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e i \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erange\u003c/span\u003e(n_samples):\r\n     # 이 패턴의 끝을 찾습니다\r\n     end_ix = i + n_steps_in\r\n     out_end_ix = end_ix + n_steps_out\r\n     # 패턴의 입력 및 출력 부분을 수집합니다\r\n     seq_x, seq_y = sequences[\u003cspan class=\"hljs-attr\"\u003ei\u003c/span\u003e:end_ix], sequences[\u003cspan class=\"hljs-attr\"\u003eend_ix\u003c/span\u003e:out_end_ix]\r\n     X.\u003cspan class=\"hljs-title function_\"\u003eappend\u003c/span\u003e(seq_x)\r\n     y.\u003cspan class=\"hljs-title function_\"\u003eappend\u003c/span\u003e(seq_y)\r\n \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e np.\u003cspan class=\"hljs-title function_\"\u003earray\u003c/span\u003e(X), np.\u003cspan class=\"hljs-title function_\"\u003earray\u003c/span\u003e(y), np.\u003cspan class=\"hljs-title function_\"\u003earray\u003c/span\u003e(X_test), np.\u003cspan class=\"hljs-title function_\"\u003earray\u003c/span\u003e(X_forecast), n_steps_in, n_steps_out\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 함수에서는 단계 수가 이미 고정되었기 때문에 샘플 수와 훈련 크기는 사용자가 선택하도록 하고, 최대 가능한 단계 수를 계산하도록 결정했습니다. 아래는 실행된 코드와 그 결과입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003en_samples = \u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e\r\ntrain_size = \u003cspan class=\"hljs-number\"\u003e321\u003c/span\u003e\r\nX_train, y_train, X_test, X_forecast, n_steps_in, n_steps_out = \u003cspan class=\"hljs-title function_\"\u003esplit_sequences_comparable\u003c/span\u003e(ts_data, n_samples, train_size)\r\ny_test = ts_data[\u003cspan class=\"hljs-attr\"\u003etrain_size\u003c/span\u003e:]\r\n\r\n# \u003cspan class=\"hljs-title class_\"\u003eReshaping\u003c/span\u003e\r\nX_train = X_train.\u003cspan class=\"hljs-title function_\"\u003ereshape\u003c/span\u003e(X_train.\u003cspan class=\"hljs-property\"\u003eshape\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e], X_train.\u003cspan class=\"hljs-property\"\u003eshape\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e], \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)\r\nX_test = X_test.\u003cspan class=\"hljs-title function_\"\u003ereshape\u003c/span\u003e(X_test.\u003cspan class=\"hljs-property\"\u003eshape\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e], X_test.\u003cspan class=\"hljs-property\"\u003eshape\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e], \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)\r\ny_train = y_train.\u003cspan class=\"hljs-title function_\"\u003ereshape\u003c/span\u003e(y_train.\u003cspan class=\"hljs-property\"\u003eshape\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e], y_train.\u003cspan class=\"hljs-property\"\u003eshape\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e])\r\ny_test = y_test.\u003cspan class=\"hljs-title function_\"\u003ereshape\u003c/span\u003e(y_test.\u003cspan class=\"hljs-property\"\u003eshape\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e], y_test.\u003cspan class=\"hljs-property\"\u003eshape\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e], \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)\r\n\r\n# \u003cspan class=\"hljs-variable constant_\"\u003eLSTM\u003c/span\u003e 모델 생성 및 훈련\r\nmodel = \u003cspan class=\"hljs-title class_\"\u003eSequential\u003c/span\u003e()\r\nmodel.\u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003eLSTM\u003c/span\u003e(units=\u003cspan class=\"hljs-number\"\u003e154\u003c/span\u003e, activation=\u003cspan class=\"hljs-string\"\u003e'tanh'\u003c/span\u003e, input_shape=(n_steps_in, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)))\r\nmodel.\u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eDense\u003c/span\u003e(units=n_steps_out))\r\nmodel.\u003cspan class=\"hljs-title function_\"\u003ecompile\u003c/span\u003e(loss=\u003cspan class=\"hljs-string\"\u003e'mean_squared_error'\u003c/span\u003e, optimizer=\u003cspan class=\"hljs-string\"\u003e'Adam'\u003c/span\u003e, metrics=[\u003cspan class=\"hljs-string\"\u003e'mape'\u003c/span\u003e])\r\n\r\nmodel.\u003cspan class=\"hljs-title function_\"\u003efit\u003c/span\u003e(x=X_train, y=y_train, epochs=\u003cspan class=\"hljs-number\"\u003e500\u003c/span\u003e, batch_size=\u003cspan class=\"hljs-number\"\u003e18\u003c/span\u003e, verbose=\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e)\r\n\r\n# 예측\r\nlstm_predictions = model.\u003cspan class=\"hljs-title function_\"\u003epredict\u003c/span\u003e(X_test)\r\npredictions = lstm_predictions.\u003cspan class=\"hljs-title function_\"\u003ereshape\u003c/span\u003e(lstm_predictions.\u003cspan class=\"hljs-property\"\u003eshape\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e])\r\nlstm_fitted = model.\u003cspan class=\"hljs-title function_\"\u003epredict\u003c/span\u003e(X_train)\r\nfits = [np.\u003cspan class=\"hljs-title function_\"\u003ediag\u003c/span\u003e(np.\u003cspan class=\"hljs-title function_\"\u003efliplr\u003c/span\u003e(lstm_fitted), i).\u003cspan class=\"hljs-title function_\"\u003emean\u003c/span\u003e() \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e i \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erange\u003c/span\u003e(lstm_fitted.\u003cspan class=\"hljs-property\"\u003eshape\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e]+n_steps_in - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, -lstm_fitted.\u003cspan class=\"hljs-property\"\u003eshape\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e], -\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)]\r\n\r\n# 메트릭스\r\nmape = \u003cspan class=\"hljs-title function_\"\u003emean_absolute_percentage_error\u003c/span\u003e(y_test, predictions)\r\nr2 = \u003cspan class=\"hljs-title function_\"\u003er2_score\u003c/span\u003e(ts_data[\u003cspan class=\"hljs-attr\"\u003en_steps_in\u003c/span\u003e:train_size], fits[\u003cspan class=\"hljs-attr\"\u003en_steps_in\u003c/span\u003e:])\r\n\r\n# 실제, 적합 및 예측 플롯\r\nplt.\u003cspan class=\"hljs-title function_\"\u003efigure\u003c/span\u003e(figsize=(\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e))\r\nplt.\u003cspan class=\"hljs-title function_\"\u003eplot\u003c/span\u003e(date_range, ts_data, label=\u003cspan class=\"hljs-string\"\u003e'Actual'\u003c/span\u003e, color=\u003cspan class=\"hljs-string\"\u003e'blue'\u003c/span\u003e)\r\nplt.\u003cspan class=\"hljs-title function_\"\u003eplot\u003c/span\u003e(date_range[:train_size], fits, label=\u003cspan class=\"hljs-string\"\u003e'Fitted'\u003c/span\u003e, color=\u003cspan class=\"hljs-string\"\u003e'green'\u003c/span\u003e)\r\nplt.\u003cspan class=\"hljs-title function_\"\u003eplot\u003c/span\u003e(date_range[\u003cspan class=\"hljs-attr\"\u003etrain_size\u003c/span\u003e:], predictions, label=\u003cspan class=\"hljs-string\"\u003e'Forecast'\u003c/span\u003e, color=\u003cspan class=\"hljs-string\"\u003e'red'\u003c/span\u003e)\r\nplt.\u003cspan class=\"hljs-title function_\"\u003etitle\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'FSC - Short - Passengers\\n12 Sample Comparable LSTM Forecast'\u003c/span\u003e)\r\nplt.\u003cspan class=\"hljs-title function_\"\u003exlabel\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Date'\u003c/span\u003e)\r\nplt.\u003cspan class=\"hljs-title function_\"\u003eylabel\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Passengers'\u003c/span\u003e)\r\nplt.\u003cspan class=\"hljs-title function_\"\u003elegend\u003c/span\u003e()\r\nplt.\u003cspan class=\"hljs-title function_\"\u003etext\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0.05\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0.05\u003c/span\u003e, f\u003cspan class=\"hljs-string\"\u003e'R2 = {r2*100:.2f}%\\nMAPE = {mape*100:.2f}%\\', transform=plt.gca().transAxes, fontsize=12)\r\nplt.grid(True)\r\nplt.show()\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_10.png\"\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e지금까지 우리가 얻은 결과는 가장 신뢰할만한 것입니다. 그러나 제가 개발한 혁신적인 방법을 사용하면 더 나은 결과를 얻을 수 있습니다. 이 방법은 나중에 시리즈에서 (순환 방법) 자세히 설명하겠습니다. 먼저 LSTM 네트워크의 하이퍼파라미터를 조정하는 방법에 대해 설명하겠습니다.\u003c/p\u003e\n\u003cp\u003eLSTM은 모든 시간 단계를 특성으로 집계하기 때문에 시계열 데이터가 모든 이러한 방법에서 손실됩니다. 나중에 시리즈에서 (인코더/디코더 방법) 시계열 입력의 구조를 유지하는 다른 방법을 사용할 것입니다.\u003c/p\u003e\n\u003cp\u003e계속 주목해 주세요!\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting"},"buildId":"YUMR4jSyk_WlOHHc7UfOk","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>