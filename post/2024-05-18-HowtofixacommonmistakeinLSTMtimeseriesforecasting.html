<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>LSTM 시계열 예측에서 흔히 발생하는 오류를 수정하는 방법 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="LSTM 시계열 예측에서 흔히 발생하는 오류를 수정하는 방법 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="LSTM 시계열 예측에서 흔히 발생하는 오류를 수정하는 방법 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting" data-gatsby-head="true"/><meta name="twitter:title" content="LSTM 시계열 예측에서 흔히 발생하는 오류를 수정하는 방법 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-18 19:35" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/cd012fc8787133d0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cd012fc8787133d0.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/551-3069cf29fe274aab.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-561ae49ab5aab7f5.js" defer=""></script><script src="/_next/static/0asLlD6on3tm8cIfzBaxd/_buildManifest.js" defer=""></script><script src="/_next/static/0asLlD6on3tm8cIfzBaxd/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">LSTM 시계열 예측에서 흔히 발생하는 오류를 수정하는 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="LSTM 시계열 예측에서 흔히 발생하는 오류를 수정하는 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 18, 2024</span><span class="posts_reading_time__f7YPP">12<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><p>LSTM을 시계열 예측에 사용할 때, 사람들은 흔히 범할 수 있는 함정에 빠지곤 합니다. 이를 설명하기 위해서는 회귀자와 예측자의 작동 방식을 살펴볼 필요가 있습니다. 예측 알고리즘은 시계열 데이터를 다루는 방법을 아래와 같이 보여줍니다:</p>
<p><img src="/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_0.png" alt="How a forecasting algorithm works"/></p>
<p>한편, 회귀 문제는 다음과 같이 보일 것입니다:</p>
<p><img src="/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_1.png" alt="How a regression problem looks"/></p>
<div class="content-ad"></div>
<p>LSTM이 회귀기이므로 시계열을 회귀 문제로 변환해야 합니다. 이를 수행하는 여러 방법이 있지만, 이 섹션에서는 창(Window) 및 다중 단계(Multi-Step) 방법에 대해 설명하고, 어떻게 작동하는지와 특히 이를 활용할 때 발생할 수 있는 일반적인 실수를 피하는 방법에 대해 논의할 것입니다.</p>
<p>창 방법(Window Method)에서, 시계열은 이전 각 시간 단계의 값과 결합되어 창이라고 불리는 가상 특성으로 되어 있습니다. 여기서 창 크기가 3인 창이 있습니다:</p>
<p><img src="/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_2.png" alt="창 방법 이미지"/></p>
<p>다음 함수는 단일 시계열에서 창 방법 데이터 세트를 생성합니다. 사용자는 이전 값의 수(보통 look back이라고 함)를 선택해야 합니다. 결과 데이터 세트에는 대각선 반복이 있으며, look-back 값에 따라 샘플의 수가 달라집니다:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js">def <span class="hljs-title function_">window</span>(sequences, look_back):
    X, y = [], []
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-title function_">range</span>(<span class="hljs-title function_">len</span>(sequences)-look_back-<span class="hljs-number">1</span>):
        x = sequences[<span class="hljs-attr">i</span>:(i+look_back)]
        X.<span class="hljs-title function_">append</span>(x)
        y.<span class="hljs-title function_">append</span>(sequences[i + look_back])
    <span class="hljs-keyword">return</span> np.<span class="hljs-title function_">array</span>(X), np.<span class="hljs-title function_">array</span>(y)
</code></pre>
<p>이제 결과를 살펴보겠습니다. 모델을 훈련한 후에는 테스트 세트에서 테스트됩니다. 다양한 소스와 튜토리얼에서는 비슷한 방법을 사용하여 결과를 컴파일하는 것을 제안했습니다. 그러나 나중에 설명할 것처럼 이 방법은 신빙성이 없습니다. 그럼 지금은 코드와 결과가 어떻게 보이는지 살펴보겠습니다:</p>
<pre><code class="hljs language-js">look_back = <span class="hljs-number">3</span>
X, y = <span class="hljs-title function_">window</span>(ts_data, look_back)

# 훈련-테스트 분할
train_ratio = <span class="hljs-number">0.8</span>
train_size = <span class="hljs-title function_">int</span>(train_ratio * <span class="hljs-title function_">len</span>(ts_data))
X_train, X_test = X[:train_size-look_back], X[train_size-<span class="hljs-attr">look_back</span>:]
y_train, y_test = y[:train_size-look_back], y[train_size-<span class="hljs-attr">look_back</span>:]

# <span class="hljs-variable constant_">LSTM</span> 모델 생성 및 훈련
model = <span class="hljs-title class_">Sequential</span>()
model.<span class="hljs-title function_">add</span>(<span class="hljs-title function_">LSTM</span>(units=<span class="hljs-number">72</span>, activation=<span class="hljs-string">&#x27;tanh&#x27;</span>, input_shape=(look_back, <span class="hljs-number">1</span>)))
model.<span class="hljs-title function_">add</span>(<span class="hljs-title class_">Dense</span>(<span class="hljs-number">1</span>))
model.<span class="hljs-title function_">compile</span>(loss=<span class="hljs-string">&#x27;mean_squared_error&#x27;</span>, optimizer=<span class="hljs-string">&#x27;Adam&#x27;</span>, metrics=[<span class="hljs-string">&#x27;mape&#x27;</span>])

model.<span class="hljs-title function_">fit</span>(x=X_train, y=y_train, epochs=<span class="hljs-number">500</span>, batch_size=<span class="hljs-number">18</span>, verbose=<span class="hljs-number">2</span>)

# 예측 생성
forecasts = model.<span class="hljs-title function_">predict</span>(X_test)
lstm_fits = model.<span class="hljs-title function_">predict</span>(X_train)

# 메트릭스 계산
mape = <span class="hljs-title function_">mean_absolute_percentage_error</span>(y_test, forecasts)
r2 = <span class="hljs-title function_">r2_score</span>(y_train, lstm_fits)

# 날짜 초기화
date_range = pd.<span class="hljs-title function_">date_range</span>(start=<span class="hljs-string">&#x27;1990-01-01&#x27;</span>, end=<span class="hljs-string">&#x27;2023-09-30&#x27;</span>, freq=<span class="hljs-string">&#x27;M&#x27;</span>)

# 맞춤 값에 원래 시계열과 맞추기 위한 비어있는 값 추가
fits = np.<span class="hljs-title function_">full</span>(train_size, np.<span class="hljs-property">nan</span>)
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-title function_">range</span>(train_size-look_back):
    fits[i+look_back] = lstm_fits[i]

# 실제값, 맞춤값, 예측값 플롯
plt.<span class="hljs-title function_">figure</span>(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">6</span>))
plt.<span class="hljs-title function_">plot</span>(date_range, ts_data, label=<span class="hljs-string">&#x27;Actual&#x27;</span>, color=<span class="hljs-string">&#x27;blue&#x27;</span>)
plt.<span class="hljs-title function_">plot</span>(date_range[:train_size], fits, label=<span class="hljs-string">&#x27;Fitted&#x27;</span>, color=<span class="hljs-string">&#x27;green&#x27;</span>)
plt.<span class="hljs-title function_">plot</span>(date_range[<span class="hljs-attr">train_size</span>:], forecasts, label=<span class="hljs-string">&#x27;Forecast&#x27;</span>, color=<span class="hljs-string">&#x27;red&#x27;</span>)
plt.<span class="hljs-title function_">title</span>(<span class="hljs-string">&#x27;FSC - Short - Passengers\nOne Step Forward Forecast&#x27;</span>)
plt.<span class="hljs-title function_">xlabel</span>(<span class="hljs-string">&#x27;Date&#x27;</span>)
plt.<span class="hljs-title function_">ylabel</span>(<span class="hljs-string">&#x27;Passengers&#x27;</span>)
plt.<span class="hljs-title function_">legend</span>()
plt.<span class="hljs-title function_">text</span>(<span class="hljs-number">0.05</span>, <span class="hljs-number">0.05</span>, f<span class="hljs-string">&#x27;R2 = {r2*100:.2f}%\nMAPE = {mape*100:.2f}%&#x27;</span>, transform=plt.<span class="hljs-title function_">gca</span>().<span class="hljs-property">transAxes</span>, fontsize=<span class="hljs-number">12</span>)
plt.<span class="hljs-title function_">grid</span>(<span class="hljs-title class_">True</span>)
plt.<span class="hljs-title function_">show</span>()
</code></pre>
<img src="/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_3.png"/>
<div class="content-ad"></div>
<p>문제: 결과는 훌륭해 보입니다. 그러나 샘플 테스트 세트를 살펴보면 특이한 결함이 보입니다:</p>
<p><img src="/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_4.png" alt="이미지"/></p>
<p>예를 들어 y9를 생성하는 데에는 y8이 입력으로 사용되었습니다. 훈련에는 사용되지 않았지만 미래 값을 포함하는 것은 이상합니다. 왜냐하면 우리는 미래의 시점을 예측하고 있기 때문입니다.</p>
<p>해결책: 직접적으로 이전 값을 예측 값으로 대체하는 반복적 테스트 세트를 사용하면 이 문제를 해결할 수 있습니다. 이러한 배치 방식에서 모델은 자체 예측에 기반을 둔다. 일반적인 예측 알고리즘과 유사합니다.</p>
<div class="content-ad"></div>
<p>아래 루프에서 다음을 수행합니다:</p>
<pre><code class="hljs language-js"># 반복적인 예측 및 대체
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-title function_">range</span>(<span class="hljs-title function_">len</span>(X_test)):
    forecasts[i] = model.<span class="hljs-title function_">predict</span>(X_test[i].<span class="hljs-title function_">reshape</span>(<span class="hljs-number">1</span>, look_back, <span class="hljs-number">1</span>))
    <span class="hljs-keyword">if</span> i != <span class="hljs-title function_">len</span>(X_test)-<span class="hljs-number">1</span>:
        X_test[i+<span class="hljs-number">1</span>,look_back-<span class="hljs-number">1</span>] = forecasts[i]
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-title function_">range</span>(look_back-<span class="hljs-number">1</span>):
            X_test[i+<span class="hljs-number">1</span>,j] = X_test[i,j+<span class="hljs-number">1</span>]
</code></pre>
<p>결과는 완벽하지는 않지만 적어도 정허하다고 할 수 있습니다:</p>
<div class="content-ad"></div>
<img src="/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_6.png"/>
<p>다중 단계 방법은 창 방법과 유사하지만 더 많은 대상 단계를 갖습니다. 다음은 두 개의 전방 단계의 샘플입니다:</p>
<img src="/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_7.png"/>
<p>사실, 이 방법에서 사용자는 n_steps_in과 n_steps_out을 선택해야 합니다. 다음 코드는 단순 시계열을 다중 단계 LSTM 훈련을 위해 준비된 데이터 세트로 변환합니다:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"># 단변량 시퀀스를 다단계로 샘플링하기
def <span class="hljs-title function_">split_sequences</span>(sequences, n_steps_in, n_steps_out):
 X, y = <span class="hljs-title function_">list</span>(), <span class="hljs-title function_">list</span>()
 <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-title function_">range</span>(<span class="hljs-title function_">len</span>(sequences)):
     # 해당 패턴의 끝을 찾음
     end_ix = i + n_steps_in
     out_end_ix = end_ix + n_steps_out
     # 시퀀스를 벗어나는지 확인
     <span class="hljs-keyword">if</span> out_end_ix &gt; <span class="hljs-title function_">len</span>(sequences):
         <span class="hljs-keyword">break</span>
     # 패턴의 입력 및 출력 부분 수집
     seq_x, seq_y = sequences[<span class="hljs-attr">i</span>:end_ix], sequences[<span class="hljs-attr">end_ix</span>:out_end_ix]
     X.<span class="hljs-title function_">append</span>(seq_x)
     y.<span class="hljs-title function_">append</span>(seq_y)
 <span class="hljs-keyword">return</span> np.<span class="hljs-title function_">array</span>(X), np.<span class="hljs-title function_">array</span>(y)
</code></pre>
<p>이제, 특성 뿐만 아니라 타겟도 대각선 반복을 가지고 있어 시계열과 비교하려면 그들을 평균화하거나 예측 중 하나를 선택해야 합니다. 아래 코드에서는 첫 번째, 마지막 및 평균 예측의 결과가 생성되며, 그에 이어 플롯이 제시됩니다. 여기서 첫 번째 예측은 한 달 전 예측을 의미하며, 마지막 예측은 12개월 전 예측을 의미합니다.</p>
<pre><code class="hljs language-js">n_steps_in = <span class="hljs-number">12</span>
n_steps_out = <span class="hljs-number">12</span>

X, y = <span class="hljs-title function_">split_sequences</span>(ts_data, n_steps_in, n_steps_out)
X = X.<span class="hljs-title function_">reshape</span>(X.<span class="hljs-property">shape</span>[<span class="hljs-number">0</span>], X.<span class="hljs-property">shape</span>[<span class="hljs-number">1</span>], <span class="hljs-number">1</span>)
y = y.<span class="hljs-title function_">reshape</span>(y.<span class="hljs-property">shape</span>[<span class="hljs-number">0</span>], y.<span class="hljs-property">shape</span>[<span class="hljs-number">1</span>], <span class="hljs-number">1</span>)

# 훈련 및 테스트 세트 분리
train_ratio = <span class="hljs-number">0.8</span>
train_size = <span class="hljs-title function_">int</span>(train_ratio * <span class="hljs-title function_">len</span>(ts_data))
X_train, X_test = X[:train_size-n_steps_in-n_steps_out+<span class="hljs-number">1</span>], X[train_size-n_steps_in-n_steps_out+<span class="hljs-number">1</span>:]
y_train = y[:train_size-n_steps_in-n_steps_out+<span class="hljs-number">1</span>]
y_test = ts_data[<span class="hljs-attr">train_size</span>:]

# <span class="hljs-variable constant_">LSTM</span> 모델 생성 및 훈련
model = <span class="hljs-title class_">Sequential</span>()
model.<span class="hljs-title function_">add</span>(<span class="hljs-title function_">LSTM</span>(units=<span class="hljs-number">72</span>, activation=<span class="hljs-string">&#x27;tanh&#x27;</span>, input_shape=(n_steps_in, <span class="hljs-number">1</span>)))
model.<span class="hljs-title function_">add</span>(<span class="hljs-title class_">Dense</span>(units=n_steps_out))
model.<span class="hljs-title function_">compile</span>(loss=<span class="hljs-string">&#x27;mean_squared_error&#x27;</span>, optimizer=<span class="hljs-string">&#x27;Adam&#x27;</span>, metrics=[<span class="hljs-string">&#x27;mape&#x27;</span>])

model.<span class="hljs-title function_">fit</span>(x=X_train, y=y_train, epochs=<span class="hljs-number">500</span>, batch_size=<span class="hljs-number">18</span>, verbose=<span class="hljs-number">2</span>)

# 예측 생성
lstm_predictions = model.<span class="hljs-title function_">predict</span>(X_test)
lstm_fitted = model.<span class="hljs-title function_">predict</span>(X_train)

forecasts = [np.<span class="hljs-title function_">diag</span>(np.<span class="hljs-title function_">fliplr</span>(lstm_predictions), i).<span class="hljs-title function_">mean</span>() <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-title function_">range</span>(<span class="hljs-number">0</span>, -lstm_predictions.<span class="hljs-property">shape</span>[<span class="hljs-number">0</span>], -<span class="hljs-number">1</span>)]
fits = [np.<span class="hljs-title function_">diag</span>(np.<span class="hljs-title function_">fliplr</span>(lstm_fitted), i).<span class="hljs-title function_">mean</span>() <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-title function_">range</span>(lstm_fitted.<span class="hljs-property">shape</span>[<span class="hljs-number">1</span>]+n_steps_in - <span class="hljs-number">1</span>, -lstm_fitted.<span class="hljs-property">shape</span>[<span class="hljs-number">0</span>], -<span class="hljs-number">1</span>)]
forecasts1 = lstm_predictions[n_steps_out-<span class="hljs-number">1</span>:,<span class="hljs-number">0</span>]
fits1 = model.<span class="hljs-title function_">predict</span>(X)[:train_size-n_steps_in,<span class="hljs-number">0</span>]
forecasts12 = lstm_predictions[:,n_steps_out-<span class="hljs-number">1</span>]
fits12 = lstm_fitted[:,n_steps_out-<span class="hljs-number">1</span>]

# <span class="hljs-title class_">Metric</span>
av_mape = <span class="hljs-title function_">mean_absolute_percentage_error</span>(y_test, forecasts)
av_r2 = <span class="hljs-title function_">r2_score</span>(ts_data[<span class="hljs-attr">n_steps_in</span>:train_size], fits[<span class="hljs-attr">n_steps_in</span>:])
one_mape = <span class="hljs-title function_">mean_absolute_percentage_error</span>(y_test[:-n_steps_out+<span class="hljs-number">1</span>], forecasts1)
one_r2 = <span class="hljs-title function_">r2_score</span>(ts_data[<span class="hljs-attr">n_steps_in</span>:train_size], fits1)
twelve_mape = <span class="hljs-title function_">mean_absolute_percentage_error</span>(y_test, forecasts12)
twelve_r2 = <span class="hljs-title function_">r2_score</span>(ts_data[n_steps_in+n_steps_out-<span class="hljs-number">1</span>:train_size], fits12)
 
date_range = pd.<span class="hljs-title function_">date_range</span>(start=<span class="hljs-string">&#x27;1990-01-01&#x27;</span>, end=<span class="hljs-string">&#x27;2023-09-30&#x27;</span>, freq=<span class="hljs-string">&#x27;M&#x27;</span>)

# 실제, 적합 결과 및 예측을 플롯
plt.<span class="hljs-title function_">figure</span>(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">6</span>))
plt.<span class="hljs-title function_">plot</span>(date_range, ts_data, label=<span class="hljs-string">&#x27;Actual&#x27;</span>, color=<span class="hljs-string">&#x27;blue&#x27;</span>)
plt.<span class="hljs-title function_">plot</span>(date_range[:train_size], fits, label=<span class="hljs-string">&#x27;Fitted&#x27;</span>, color=<span class="hljs-string">&#x27;green&#x27;</span>)
plt.<span class="hljs-title function_">plot</span>(date_range[<span class="hljs-attr">train_size</span>:], forecasts, label=<span class="hljs-string">&#x27;Forecast&#x27;</span>, color=<span class="hljs-string">&#x27;red&#x27;</span>)
plt.<span class="hljs-title function_">title</span>(<span class="hljs-string">&#x27;FSC - Short - Passengers\n. LSTM 12 Month Average Forecast&#x27;</span>)
plt.<span class="hljs-title function_">xlabel</span>(<span class="hljs-string">&#x27;Date&#x27;</span>)
plt.<span class="hljs-title function_">ylabel</span>(<span class="hljs-string">&#x27;Passengers&#x27;</span>)
plt.<span class="hljs-title function_">legend</span>()
plt.<span class="hljs-title function_">text</span>(<span class="hljs-number">0.05</span>, <span class="hljs-number">0.05</span>, f<span class="hljs-string">&#x27;R2 = {av_r2*100:.2f}%\nMAPE = {av_mape*100:.2f}%&#x27;</span>, transform=plt.<span class="hljs-title function_">gca</span>().<span class="hljs-property">transAxes</span>, fontsize=<span class="hljs-number">12</span>)
plt.<span class="hljs-title function_">grid</span>(<span class="hljs-title class_">True</span>)
plt.<span class="hljs-title function_">show</span>()

plt.<span class="hljs-title function_">figure</span>(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">6</span>))
plt.<span class="hljs-title function_">plot</span>(date_range, ts_data, label=<span class="hljs-string">&#x27;Actual&#x27;</span>, color=<span class="hljs-string">&#x27;blue&#x27;</span>)
plt.<span class="hljs-title function_">plot</span>(date_range[<span class="hljs-attr">n_steps_in</span>:train_size], fits1, label=<span class="hljs-string">&#x27;Fitted&#x27;</span>, color=<span class="hljs-string">&#x27;green&#x27;</span>)
plt.<span class="hljs-title function_">plot</span>(date_range[<span class="hljs-attr">train_size</span>:-n_steps_out+<span class="hljs-number">1</span>], forecasts1, label=<span class="hljs-string">&#x27;Forecast&#x27;</span>, color=<span class="hljs-string">&#x27;red&#x27;</span>)
plt.<span class="hljs-title function_">title</span>(<span class="hljs-string">&#x27;FSC - Short - Passengers\n LSTM 1 Month in advance Forecast&#x27;</span>)
plt.<span class="hljs-title function_">xlabel</span>(<span class="hljs-string">&#x27;Date&#x27;</span>)
plt.<span class="hljs-title function_">ylabel</span>(<span class="hljs-string">&#x27;Passengers&#x27;</span>)
plt.<span class="hljs-title function_">legend</span>()
plt.<span class="hljs-title function_">text</span>(<span class="hljs-number">0.05</span>, <span class="hljs-number">0.05</span>, f<span class="hljs-string">&#x27;R2 = {one_r2*100:.2f}%\nMAPE = {one_mape*100:.2f}%&#x27;</span>, transform=plt.<span class="hljs-title function_">gca</span>().<span class="hljs-property">transAxes</span>, fontsize=<span class="hljs-number">12</span>)
plt.<span class="hljs-title function_">grid</span>(<span class="hljs-title class_">True</span>)
plt.<span class="hljs-title function_">show</span>()

plt.<span class="hljs-title function_">figure</span>(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">6</span>))
plt.<span class="hljs-title function_">plot</span>(date_range, ts_data, label=<span class="hljs-string">&#x27;Actual&#x27;</span>, color=<span class="hljs-string">&#x27;blue&#x27;</span>)
plt.<span class="hljs-title function_">plot</span>(date_range[n_steps_in+n_steps_out-<span class="hljs-number">1</span>:train_size], fits12, label=<span class="hljs-string">&#x27;Fitted&#x27;</span>, color=<span class="hljs-string">&#x27;green&#x27;</span>)
plt.<span class="hljs-title function_">plot</span>(date_range[<span class="hljs-attr">train_size</span>:], forecasts12, label=<span class="hljs-string">&#x27;Forecast&#x27;</span>, color=<span class="hljs-string">&#x27;red&#x27;</span>)
plt.<span class="hljs-title function_">title</span>(<span class="hljs-string">&#x27;FSC - Short - Passengers\n LSTM 12 Months in advance Forecast&#x27;</span>)
plt.<span class="hljs-title function_">xlabel</span>(<span class="hljs-string">&#x27;Date&#x27;</span>)
plt.<span class="hljs-title function_">ylabel</span>(<span class="hljs-string">&#x27;Passengers&#x27;</span>)
plt.<span class="hljs-title function_">legend</span>()
plt.<span class="hljs-title function_">text</span>(<span class="hljs-number">0.05</span>, <span class="hljs-number">0.05</span>, f<span class="hljs-string">&#x27;R2 = {twelve_r2*100:.2f}%\nMAPE = {twelve_mape*100:.2f}%&#x27;</span>, transform=plt.<span class="hljs-title function_">gca</span>().<span class="hljs-property">transAxes</span>, fontsize=<span class="hljs-number">12</span>)
plt.<span class="hljs-title function_">grid</span>(<span class="hljs-title class_">True</span>)
plt.<span class="hljs-title function_">show</span>()
</code></pre>
<p>이슈: 창 메서드와 동일한 문제가 여기에도 있습니다:```</p>
<div class="content-ad"></div>
<p><img src="/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_8.png" alt="이미지"/></p>
<p>해상도: 창 법과 비슷한 방법을 사용할 수 있습니다. 그러나 n_steps_out을 test_size와 동일하게 선택할 수도 있습니다. 이렇게 하면 테스트 세트가 하나로 축소됩니다:</p>
<p><img src="/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_9.png" alt="이미지"/></p>
<p>다음 함수는 이를 정확히 수행합니다. 이 함수는 시계열, 학습 크기 및 샘플 수를 사용합니다. 이 버전은 다른 예측 알고리즘과 비교할 수 있기 때문에 comparable로 이름 지었습니다:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js">def <span class="hljs-title function_">split_sequences_comparable</span>(sequences, n_samples, train_size):
 # 단계
 n_steps_out = <span class="hljs-title function_">len</span>(sequences) - train_size
 n_steps_in = train_size - n_steps_out - n_samples + <span class="hljs-number">1</span>
 # 끝 세트
 X_test = sequences[n_samples + n_steps_out - <span class="hljs-number">1</span>:train_size]
 X_forecast = sequences[-<span class="hljs-attr">n_steps_in</span>:]
 X, y = <span class="hljs-title function_">list</span>(), <span class="hljs-title function_">list</span>()
 <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-title function_">range</span>(n_samples):
     # 이 패턴의 끝을 찾습니다
     end_ix = i + n_steps_in
     out_end_ix = end_ix + n_steps_out
     # 패턴의 입력 및 출력 부분을 수집합니다
     seq_x, seq_y = sequences[<span class="hljs-attr">i</span>:end_ix], sequences[<span class="hljs-attr">end_ix</span>:out_end_ix]
     X.<span class="hljs-title function_">append</span>(seq_x)
     y.<span class="hljs-title function_">append</span>(seq_y)
 <span class="hljs-keyword">return</span> np.<span class="hljs-title function_">array</span>(X), np.<span class="hljs-title function_">array</span>(y), np.<span class="hljs-title function_">array</span>(X_test), np.<span class="hljs-title function_">array</span>(X_forecast), n_steps_in, n_steps_out
</code></pre>
<p>이 함수에서는 단계 수가 이미 고정되었기 때문에 샘플 수와 훈련 크기는 사용자가 선택하도록 하고, 최대 가능한 단계 수를 계산하도록 결정했습니다. 아래는 실행된 코드와 그 결과입니다:</p>
<pre><code class="hljs language-js">n_samples = <span class="hljs-number">12</span>
train_size = <span class="hljs-number">321</span>
X_train, y_train, X_test, X_forecast, n_steps_in, n_steps_out = <span class="hljs-title function_">split_sequences_comparable</span>(ts_data, n_samples, train_size)
y_test = ts_data[<span class="hljs-attr">train_size</span>:]

# <span class="hljs-title class_">Reshaping</span>
X_train = X_train.<span class="hljs-title function_">reshape</span>(X_train.<span class="hljs-property">shape</span>[<span class="hljs-number">0</span>], X_train.<span class="hljs-property">shape</span>[<span class="hljs-number">1</span>], <span class="hljs-number">1</span>)
X_test = X_test.<span class="hljs-title function_">reshape</span>(X_test.<span class="hljs-property">shape</span>[<span class="hljs-number">1</span>], X_test.<span class="hljs-property">shape</span>[<span class="hljs-number">0</span>], <span class="hljs-number">1</span>)
y_train = y_train.<span class="hljs-title function_">reshape</span>(y_train.<span class="hljs-property">shape</span>[<span class="hljs-number">0</span>], y_train.<span class="hljs-property">shape</span>[<span class="hljs-number">1</span>])
y_test = y_test.<span class="hljs-title function_">reshape</span>(y_test.<span class="hljs-property">shape</span>[<span class="hljs-number">1</span>], y_test.<span class="hljs-property">shape</span>[<span class="hljs-number">0</span>], <span class="hljs-number">1</span>)

# <span class="hljs-variable constant_">LSTM</span> 모델 생성 및 훈련
model = <span class="hljs-title class_">Sequential</span>()
model.<span class="hljs-title function_">add</span>(<span class="hljs-title function_">LSTM</span>(units=<span class="hljs-number">154</span>, activation=<span class="hljs-string">&#x27;tanh&#x27;</span>, input_shape=(n_steps_in, <span class="hljs-number">1</span>)))
model.<span class="hljs-title function_">add</span>(<span class="hljs-title class_">Dense</span>(units=n_steps_out))
model.<span class="hljs-title function_">compile</span>(loss=<span class="hljs-string">&#x27;mean_squared_error&#x27;</span>, optimizer=<span class="hljs-string">&#x27;Adam&#x27;</span>, metrics=[<span class="hljs-string">&#x27;mape&#x27;</span>])

model.<span class="hljs-title function_">fit</span>(x=X_train, y=y_train, epochs=<span class="hljs-number">500</span>, batch_size=<span class="hljs-number">18</span>, verbose=<span class="hljs-number">2</span>)

# 예측
lstm_predictions = model.<span class="hljs-title function_">predict</span>(X_test)
predictions = lstm_predictions.<span class="hljs-title function_">reshape</span>(lstm_predictions.<span class="hljs-property">shape</span>[<span class="hljs-number">1</span>])
lstm_fitted = model.<span class="hljs-title function_">predict</span>(X_train)
fits = [np.<span class="hljs-title function_">diag</span>(np.<span class="hljs-title function_">fliplr</span>(lstm_fitted), i).<span class="hljs-title function_">mean</span>() <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-title function_">range</span>(lstm_fitted.<span class="hljs-property">shape</span>[<span class="hljs-number">1</span>]+n_steps_in - <span class="hljs-number">1</span>, -lstm_fitted.<span class="hljs-property">shape</span>[<span class="hljs-number">0</span>], -<span class="hljs-number">1</span>)]

# 메트릭스
mape = <span class="hljs-title function_">mean_absolute_percentage_error</span>(y_test, predictions)
r2 = <span class="hljs-title function_">r2_score</span>(ts_data[<span class="hljs-attr">n_steps_in</span>:train_size], fits[<span class="hljs-attr">n_steps_in</span>:])

# 실제, 적합 및 예측 플롯
plt.<span class="hljs-title function_">figure</span>(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">6</span>))
plt.<span class="hljs-title function_">plot</span>(date_range, ts_data, label=<span class="hljs-string">&#x27;Actual&#x27;</span>, color=<span class="hljs-string">&#x27;blue&#x27;</span>)
plt.<span class="hljs-title function_">plot</span>(date_range[:train_size], fits, label=<span class="hljs-string">&#x27;Fitted&#x27;</span>, color=<span class="hljs-string">&#x27;green&#x27;</span>)
plt.<span class="hljs-title function_">plot</span>(date_range[<span class="hljs-attr">train_size</span>:], predictions, label=<span class="hljs-string">&#x27;Forecast&#x27;</span>, color=<span class="hljs-string">&#x27;red&#x27;</span>)
plt.<span class="hljs-title function_">title</span>(<span class="hljs-string">&#x27;FSC - Short - Passengers\n12 Sample Comparable LSTM Forecast&#x27;</span>)
plt.<span class="hljs-title function_">xlabel</span>(<span class="hljs-string">&#x27;Date&#x27;</span>)
plt.<span class="hljs-title function_">ylabel</span>(<span class="hljs-string">&#x27;Passengers&#x27;</span>)
plt.<span class="hljs-title function_">legend</span>()
plt.<span class="hljs-title function_">text</span>(<span class="hljs-number">0.05</span>, <span class="hljs-number">0.05</span>, f<span class="hljs-string">&#x27;R2 = {r2*100:.2f}%\nMAPE = {mape*100:.2f}%\&#x27;, transform=plt.gca().transAxes, fontsize=12)
plt.grid(True)
plt.show()
</span></code></pre>
<img src="/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_10.png"/>
<div class="content-ad"></div>
<p>지금까지 우리가 얻은 결과는 가장 신뢰할만한 것입니다. 그러나 제가 개발한 혁신적인 방법을 사용하면 더 나은 결과를 얻을 수 있습니다. 이 방법은 나중에 시리즈에서 (순환 방법) 자세히 설명하겠습니다. 먼저 LSTM 네트워크의 하이퍼파라미터를 조정하는 방법에 대해 설명하겠습니다.</p>
<p>LSTM은 모든 시간 단계를 특성으로 집계하기 때문에 시계열 데이터가 모든 이러한 방법에서 손실됩니다. 나중에 시리즈에서 (인코더/디코더 방법) 시계열 입력의 구조를 유지하는 다른 방법을 사용할 것입니다.</p>
<p>계속 주목해 주세요!</p></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"LSTM 시계열 예측에서 흔히 발생하는 오류를 수정하는 방법","description":"","date":"2024-05-18 19:35","slug":"2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting","content":"\r\n\r\nLSTM을 시계열 예측에 사용할 때, 사람들은 흔히 범할 수 있는 함정에 빠지곤 합니다. 이를 설명하기 위해서는 회귀자와 예측자의 작동 방식을 살펴볼 필요가 있습니다. 예측 알고리즘은 시계열 데이터를 다루는 방법을 아래와 같이 보여줍니다:\r\n\r\n\r\n![How a forecasting algorithm works](/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_0.png)\r\n\r\n\r\n한편, 회귀 문제는 다음과 같이 보일 것입니다:\r\n\r\n\r\n![How a regression problem looks](/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_1.png)\r\n\r\n\r\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\r\n\r\nLSTM이 회귀기이므로 시계열을 회귀 문제로 변환해야 합니다. 이를 수행하는 여러 방법이 있지만, 이 섹션에서는 창(Window) 및 다중 단계(Multi-Step) 방법에 대해 설명하고, 어떻게 작동하는지와 특히 이를 활용할 때 발생할 수 있는 일반적인 실수를 피하는 방법에 대해 논의할 것입니다.\r\n\r\n창 방법(Window Method)에서, 시계열은 이전 각 시간 단계의 값과 결합되어 창이라고 불리는 가상 특성으로 되어 있습니다. 여기서 창 크기가 3인 창이 있습니다:\r\n\r\n![창 방법 이미지](/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_2.png)\r\n\r\n다음 함수는 단일 시계열에서 창 방법 데이터 세트를 생성합니다. 사용자는 이전 값의 수(보통 look back이라고 함)를 선택해야 합니다. 결과 데이터 세트에는 대각선 반복이 있으며, look-back 값에 따라 샘플의 수가 달라집니다:\r\n\r\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\r\n\r\n```js\r\ndef window(sequences, look_back):\r\n    X, y = [], []\r\n    for i in range(len(sequences)-look_back-1):\r\n        x = sequences[i:(i+look_back)]\r\n        X.append(x)\r\n        y.append(sequences[i + look_back])\r\n    return np.array(X), np.array(y)\r\n```\r\n\r\n이제 결과를 살펴보겠습니다. 모델을 훈련한 후에는 테스트 세트에서 테스트됩니다. 다양한 소스와 튜토리얼에서는 비슷한 방법을 사용하여 결과를 컴파일하는 것을 제안했습니다. 그러나 나중에 설명할 것처럼 이 방법은 신빙성이 없습니다. 그럼 지금은 코드와 결과가 어떻게 보이는지 살펴보겠습니다:\r\n\r\n```js\r\nlook_back = 3\r\nX, y = window(ts_data, look_back)\r\n\r\n# 훈련-테스트 분할\r\ntrain_ratio = 0.8\r\ntrain_size = int(train_ratio * len(ts_data))\r\nX_train, X_test = X[:train_size-look_back], X[train_size-look_back:]\r\ny_train, y_test = y[:train_size-look_back], y[train_size-look_back:]\r\n\r\n# LSTM 모델 생성 및 훈련\r\nmodel = Sequential()\r\nmodel.add(LSTM(units=72, activation='tanh', input_shape=(look_back, 1)))\r\nmodel.add(Dense(1))\r\nmodel.compile(loss='mean_squared_error', optimizer='Adam', metrics=['mape'])\r\n\r\nmodel.fit(x=X_train, y=y_train, epochs=500, batch_size=18, verbose=2)\r\n\r\n# 예측 생성\r\nforecasts = model.predict(X_test)\r\nlstm_fits = model.predict(X_train)\r\n\r\n# 메트릭스 계산\r\nmape = mean_absolute_percentage_error(y_test, forecasts)\r\nr2 = r2_score(y_train, lstm_fits)\r\n\r\n# 날짜 초기화\r\ndate_range = pd.date_range(start='1990-01-01', end='2023-09-30', freq='M')\r\n\r\n# 맞춤 값에 원래 시계열과 맞추기 위한 비어있는 값 추가\r\nfits = np.full(train_size, np.nan)\r\nfor i in range(train_size-look_back):\r\n    fits[i+look_back] = lstm_fits[i]\r\n\r\n# 실제값, 맞춤값, 예측값 플롯\r\nplt.figure(figsize=(10, 6))\r\nplt.plot(date_range, ts_data, label='Actual', color='blue')\r\nplt.plot(date_range[:train_size], fits, label='Fitted', color='green')\r\nplt.plot(date_range[train_size:], forecasts, label='Forecast', color='red')\r\nplt.title('FSC - Short - Passengers\\nOne Step Forward Forecast')\r\nplt.xlabel('Date')\r\nplt.ylabel('Passengers')\r\nplt.legend()\r\nplt.text(0.05, 0.05, f'R2 = {r2*100:.2f}%\\nMAPE = {mape*100:.2f}%', transform=plt.gca().transAxes, fontsize=12)\r\nplt.grid(True)\r\nplt.show()\r\n```\r\n\r\n\u003cimg src=\"/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_3.png\" /\u003e\r\n\r\n\r\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\r\n\r\n문제: 결과는 훌륭해 보입니다. 그러나 샘플 테스트 세트를 살펴보면 특이한 결함이 보입니다:\r\n\r\n![이미지](/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_4.png)\r\n\r\n예를 들어 y9를 생성하는 데에는 y8이 입력으로 사용되었습니다. 훈련에는 사용되지 않았지만 미래 값을 포함하는 것은 이상합니다. 왜냐하면 우리는 미래의 시점을 예측하고 있기 때문입니다.\r\n\r\n해결책: 직접적으로 이전 값을 예측 값으로 대체하는 반복적 테스트 세트를 사용하면 이 문제를 해결할 수 있습니다. 이러한 배치 방식에서 모델은 자체 예측에 기반을 둔다. 일반적인 예측 알고리즘과 유사합니다.\r\n\r\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\r\n\r\n아래 루프에서 다음을 수행합니다:\r\n\r\n```js\r\n# 반복적인 예측 및 대체\r\nfor i in range(len(X_test)):\r\n    forecasts[i] = model.predict(X_test[i].reshape(1, look_back, 1))\r\n    if i != len(X_test)-1:\r\n        X_test[i+1,look_back-1] = forecasts[i]\r\n        for j in range(look_back-1):\r\n            X_test[i+1,j] = X_test[i,j+1]\r\n```\r\n\r\n결과는 완벽하지는 않지만 적어도 정허하다고 할 수 있습니다:\r\n\r\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\r\n\r\n\r\n\u003cimg src=\"/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_6.png\" /\u003e\r\n\r\n다중 단계 방법은 창 방법과 유사하지만 더 많은 대상 단계를 갖습니다. 다음은 두 개의 전방 단계의 샘플입니다:\r\n\r\n\u003cimg src=\"/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_7.png\" /\u003e\r\n\r\n사실, 이 방법에서 사용자는 n_steps_in과 n_steps_out을 선택해야 합니다. 다음 코드는 단순 시계열을 다중 단계 LSTM 훈련을 위해 준비된 데이터 세트로 변환합니다:\r\n\r\n\r\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\r\n\r\n```js\r\n# 단변량 시퀀스를 다단계로 샘플링하기\r\ndef split_sequences(sequences, n_steps_in, n_steps_out):\r\n X, y = list(), list()\r\n for i in range(len(sequences)):\r\n     # 해당 패턴의 끝을 찾음\r\n     end_ix = i + n_steps_in\r\n     out_end_ix = end_ix + n_steps_out\r\n     # 시퀀스를 벗어나는지 확인\r\n     if out_end_ix \u003e len(sequences):\r\n         break\r\n     # 패턴의 입력 및 출력 부분 수집\r\n     seq_x, seq_y = sequences[i:end_ix], sequences[end_ix:out_end_ix]\r\n     X.append(seq_x)\r\n     y.append(seq_y)\r\n return np.array(X), np.array(y)\r\n```\r\n\r\n이제, 특성 뿐만 아니라 타겟도 대각선 반복을 가지고 있어 시계열과 비교하려면 그들을 평균화하거나 예측 중 하나를 선택해야 합니다. 아래 코드에서는 첫 번째, 마지막 및 평균 예측의 결과가 생성되며, 그에 이어 플롯이 제시됩니다. 여기서 첫 번째 예측은 한 달 전 예측을 의미하며, 마지막 예측은 12개월 전 예측을 의미합니다.\r\n\r\n```js\r\nn_steps_in = 12\r\nn_steps_out = 12\r\n\r\nX, y = split_sequences(ts_data, n_steps_in, n_steps_out)\r\nX = X.reshape(X.shape[0], X.shape[1], 1)\r\ny = y.reshape(y.shape[0], y.shape[1], 1)\r\n\r\n# 훈련 및 테스트 세트 분리\r\ntrain_ratio = 0.8\r\ntrain_size = int(train_ratio * len(ts_data))\r\nX_train, X_test = X[:train_size-n_steps_in-n_steps_out+1], X[train_size-n_steps_in-n_steps_out+1:]\r\ny_train = y[:train_size-n_steps_in-n_steps_out+1]\r\ny_test = ts_data[train_size:]\r\n\r\n# LSTM 모델 생성 및 훈련\r\nmodel = Sequential()\r\nmodel.add(LSTM(units=72, activation='tanh', input_shape=(n_steps_in, 1)))\r\nmodel.add(Dense(units=n_steps_out))\r\nmodel.compile(loss='mean_squared_error', optimizer='Adam', metrics=['mape'])\r\n\r\nmodel.fit(x=X_train, y=y_train, epochs=500, batch_size=18, verbose=2)\r\n\r\n# 예측 생성\r\nlstm_predictions = model.predict(X_test)\r\nlstm_fitted = model.predict(X_train)\r\n\r\nforecasts = [np.diag(np.fliplr(lstm_predictions), i).mean() for i in range(0, -lstm_predictions.shape[0], -1)]\r\nfits = [np.diag(np.fliplr(lstm_fitted), i).mean() for i in range(lstm_fitted.shape[1]+n_steps_in - 1, -lstm_fitted.shape[0], -1)]\r\nforecasts1 = lstm_predictions[n_steps_out-1:,0]\r\nfits1 = model.predict(X)[:train_size-n_steps_in,0]\r\nforecasts12 = lstm_predictions[:,n_steps_out-1]\r\nfits12 = lstm_fitted[:,n_steps_out-1]\r\n\r\n# Metric\r\nav_mape = mean_absolute_percentage_error(y_test, forecasts)\r\nav_r2 = r2_score(ts_data[n_steps_in:train_size], fits[n_steps_in:])\r\none_mape = mean_absolute_percentage_error(y_test[:-n_steps_out+1], forecasts1)\r\none_r2 = r2_score(ts_data[n_steps_in:train_size], fits1)\r\ntwelve_mape = mean_absolute_percentage_error(y_test, forecasts12)\r\ntwelve_r2 = r2_score(ts_data[n_steps_in+n_steps_out-1:train_size], fits12)\r\n \r\ndate_range = pd.date_range(start='1990-01-01', end='2023-09-30', freq='M')\r\n\r\n# 실제, 적합 결과 및 예측을 플롯\r\nplt.figure(figsize=(10, 6))\r\nplt.plot(date_range, ts_data, label='Actual', color='blue')\r\nplt.plot(date_range[:train_size], fits, label='Fitted', color='green')\r\nplt.plot(date_range[train_size:], forecasts, label='Forecast', color='red')\r\nplt.title('FSC - Short - Passengers\\n. LSTM 12 Month Average Forecast')\r\nplt.xlabel('Date')\r\nplt.ylabel('Passengers')\r\nplt.legend()\r\nplt.text(0.05, 0.05, f'R2 = {av_r2*100:.2f}%\\nMAPE = {av_mape*100:.2f}%', transform=plt.gca().transAxes, fontsize=12)\r\nplt.grid(True)\r\nplt.show()\r\n\r\nplt.figure(figsize=(10, 6))\r\nplt.plot(date_range, ts_data, label='Actual', color='blue')\r\nplt.plot(date_range[n_steps_in:train_size], fits1, label='Fitted', color='green')\r\nplt.plot(date_range[train_size:-n_steps_out+1], forecasts1, label='Forecast', color='red')\r\nplt.title('FSC - Short - Passengers\\n LSTM 1 Month in advance Forecast')\r\nplt.xlabel('Date')\r\nplt.ylabel('Passengers')\r\nplt.legend()\r\nplt.text(0.05, 0.05, f'R2 = {one_r2*100:.2f}%\\nMAPE = {one_mape*100:.2f}%', transform=plt.gca().transAxes, fontsize=12)\r\nplt.grid(True)\r\nplt.show()\r\n\r\nplt.figure(figsize=(10, 6))\r\nplt.plot(date_range, ts_data, label='Actual', color='blue')\r\nplt.plot(date_range[n_steps_in+n_steps_out-1:train_size], fits12, label='Fitted', color='green')\r\nplt.plot(date_range[train_size:], forecasts12, label='Forecast', color='red')\r\nplt.title('FSC - Short - Passengers\\n LSTM 12 Months in advance Forecast')\r\nplt.xlabel('Date')\r\nplt.ylabel('Passengers')\r\nplt.legend()\r\nplt.text(0.05, 0.05, f'R2 = {twelve_r2*100:.2f}%\\nMAPE = {twelve_mape*100:.2f}%', transform=plt.gca().transAxes, fontsize=12)\r\nplt.grid(True)\r\nplt.show()\r\n```\r\n\r\n이슈: 창 메서드와 동일한 문제가 여기에도 있습니다:```\r\n\r\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\r\n\r\n\r\n![이미지](/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_8.png)\r\n\r\n해상도: 창 법과 비슷한 방법을 사용할 수 있습니다. 그러나 n_steps_out을 test_size와 동일하게 선택할 수도 있습니다. 이렇게 하면 테스트 세트가 하나로 축소됩니다:\r\n\r\n![이미지](/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_9.png)\r\n\r\n다음 함수는 이를 정확히 수행합니다. 이 함수는 시계열, 학습 크기 및 샘플 수를 사용합니다. 이 버전은 다른 예측 알고리즘과 비교할 수 있기 때문에 comparable로 이름 지었습니다:\r\n\r\n\r\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\r\n\r\n```js\r\ndef split_sequences_comparable(sequences, n_samples, train_size):\r\n # 단계\r\n n_steps_out = len(sequences) - train_size\r\n n_steps_in = train_size - n_steps_out - n_samples + 1\r\n # 끝 세트\r\n X_test = sequences[n_samples + n_steps_out - 1:train_size]\r\n X_forecast = sequences[-n_steps_in:]\r\n X, y = list(), list()\r\n for i in range(n_samples):\r\n     # 이 패턴의 끝을 찾습니다\r\n     end_ix = i + n_steps_in\r\n     out_end_ix = end_ix + n_steps_out\r\n     # 패턴의 입력 및 출력 부분을 수집합니다\r\n     seq_x, seq_y = sequences[i:end_ix], sequences[end_ix:out_end_ix]\r\n     X.append(seq_x)\r\n     y.append(seq_y)\r\n return np.array(X), np.array(y), np.array(X_test), np.array(X_forecast), n_steps_in, n_steps_out\r\n```\r\n\r\n이 함수에서는 단계 수가 이미 고정되었기 때문에 샘플 수와 훈련 크기는 사용자가 선택하도록 하고, 최대 가능한 단계 수를 계산하도록 결정했습니다. 아래는 실행된 코드와 그 결과입니다:\r\n\r\n```js\r\nn_samples = 12\r\ntrain_size = 321\r\nX_train, y_train, X_test, X_forecast, n_steps_in, n_steps_out = split_sequences_comparable(ts_data, n_samples, train_size)\r\ny_test = ts_data[train_size:]\r\n\r\n# Reshaping\r\nX_train = X_train.reshape(X_train.shape[0], X_train.shape[1], 1)\r\nX_test = X_test.reshape(X_test.shape[1], X_test.shape[0], 1)\r\ny_train = y_train.reshape(y_train.shape[0], y_train.shape[1])\r\ny_test = y_test.reshape(y_test.shape[1], y_test.shape[0], 1)\r\n\r\n# LSTM 모델 생성 및 훈련\r\nmodel = Sequential()\r\nmodel.add(LSTM(units=154, activation='tanh', input_shape=(n_steps_in, 1)))\r\nmodel.add(Dense(units=n_steps_out))\r\nmodel.compile(loss='mean_squared_error', optimizer='Adam', metrics=['mape'])\r\n\r\nmodel.fit(x=X_train, y=y_train, epochs=500, batch_size=18, verbose=2)\r\n\r\n# 예측\r\nlstm_predictions = model.predict(X_test)\r\npredictions = lstm_predictions.reshape(lstm_predictions.shape[1])\r\nlstm_fitted = model.predict(X_train)\r\nfits = [np.diag(np.fliplr(lstm_fitted), i).mean() for i in range(lstm_fitted.shape[1]+n_steps_in - 1, -lstm_fitted.shape[0], -1)]\r\n\r\n# 메트릭스\r\nmape = mean_absolute_percentage_error(y_test, predictions)\r\nr2 = r2_score(ts_data[n_steps_in:train_size], fits[n_steps_in:])\r\n\r\n# 실제, 적합 및 예측 플롯\r\nplt.figure(figsize=(10, 6))\r\nplt.plot(date_range, ts_data, label='Actual', color='blue')\r\nplt.plot(date_range[:train_size], fits, label='Fitted', color='green')\r\nplt.plot(date_range[train_size:], predictions, label='Forecast', color='red')\r\nplt.title('FSC - Short - Passengers\\n12 Sample Comparable LSTM Forecast')\r\nplt.xlabel('Date')\r\nplt.ylabel('Passengers')\r\nplt.legend()\r\nplt.text(0.05, 0.05, f'R2 = {r2*100:.2f}%\\nMAPE = {mape*100:.2f}%\\', transform=plt.gca().transAxes, fontsize=12)\r\nplt.grid(True)\r\nplt.show()\r\n```\r\n\r\n\u003cimg src=\"/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_10.png\" /\u003e\r\n\r\n\r\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\r\n\r\n지금까지 우리가 얻은 결과는 가장 신뢰할만한 것입니다. 그러나 제가 개발한 혁신적인 방법을 사용하면 더 나은 결과를 얻을 수 있습니다. 이 방법은 나중에 시리즈에서 (순환 방법) 자세히 설명하겠습니다. 먼저 LSTM 네트워크의 하이퍼파라미터를 조정하는 방법에 대해 설명하겠습니다.\r\n\r\nLSTM은 모든 시간 단계를 특성으로 집계하기 때문에 시계열 데이터가 모든 이러한 방법에서 손실됩니다. 나중에 시리즈에서 (인코더/디코더 방법) 시계열 입력의 구조를 유지하는 다른 방법을 사용할 것입니다.\r\n\r\n계속 주목해 주세요!","ogImage":{"url":"/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_0.png"},"coverImage":"/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_0.png","tag":["Tech"],"readingTime":12},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    img: \"img\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"LSTM을 시계열 예측에 사용할 때, 사람들은 흔히 범할 수 있는 함정에 빠지곤 합니다. 이를 설명하기 위해서는 회귀자와 예측자의 작동 방식을 살펴볼 필요가 있습니다. 예측 알고리즘은 시계열 데이터를 다루는 방법을 아래와 같이 보여줍니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_0.png\",\n        alt: \"How a forecasting algorithm works\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"한편, 회귀 문제는 다음과 같이 보일 것입니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_1.png\",\n        alt: \"How a regression problem looks\"\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"LSTM이 회귀기이므로 시계열을 회귀 문제로 변환해야 합니다. 이를 수행하는 여러 방법이 있지만, 이 섹션에서는 창(Window) 및 다중 단계(Multi-Step) 방법에 대해 설명하고, 어떻게 작동하는지와 특히 이를 활용할 때 발생할 수 있는 일반적인 실수를 피하는 방법에 대해 논의할 것입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"창 방법(Window Method)에서, 시계열은 이전 각 시간 단계의 값과 결합되어 창이라고 불리는 가상 특성으로 되어 있습니다. 여기서 창 크기가 3인 창이 있습니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_2.png\",\n        alt: \"창 방법 이미지\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다음 함수는 단일 시계열에서 창 방법 데이터 세트를 생성합니다. 사용자는 이전 값의 수(보통 look back이라고 함)를 선택해야 합니다. 결과 데이터 세트에는 대각선 반복이 있으며, look-back 값에 따라 샘플의 수가 달라집니다:\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"def \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"window\"\n        }), \"(sequences, look_back):\\r\\n    X, y = [], []\\r\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" i \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"range\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"len\"\n        }), \"(sequences)-look_back-\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"):\\r\\n        x = sequences[\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"i\"\n        }), \":(i+look_back)]\\r\\n        X.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"append\"\n        }), \"(x)\\r\\n        y.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"append\"\n        }), \"(sequences[i + look_back])\\r\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" np.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"array\"\n        }), \"(X), np.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"array\"\n        }), \"(y)\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 결과를 살펴보겠습니다. 모델을 훈련한 후에는 테스트 세트에서 테스트됩니다. 다양한 소스와 튜토리얼에서는 비슷한 방법을 사용하여 결과를 컴파일하는 것을 제안했습니다. 그러나 나중에 설명할 것처럼 이 방법은 신빙성이 없습니다. 그럼 지금은 코드와 결과가 어떻게 보이는지 살펴보겠습니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"look_back = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"3\"\n        }), \"\\r\\nX, y = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"window\"\n        }), \"(ts_data, look_back)\\r\\n\\r\\n# 훈련-테스트 분할\\r\\ntrain_ratio = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.8\"\n        }), \"\\r\\ntrain_size = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"int\"\n        }), \"(train_ratio * \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"len\"\n        }), \"(ts_data))\\r\\nX_train, X_test = X[:train_size-look_back], X[train_size-\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"look_back\"\n        }), \":]\\r\\ny_train, y_test = y[:train_size-look_back], y[train_size-\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"look_back\"\n        }), \":]\\r\\n\\r\\n# \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"LSTM\"\n        }), \" 모델 생성 및 훈련\\r\\nmodel = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Sequential\"\n        }), \"()\\r\\nmodel.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"add\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"LSTM\"\n        }), \"(units=\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"72\"\n        }), \", activation=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'tanh'\"\n        }), \", input_shape=(look_back, \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \")))\\r\\nmodel.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"add\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Dense\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"))\\r\\nmodel.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"compile\"\n        }), \"(loss=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'mean_squared_error'\"\n        }), \", optimizer=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Adam'\"\n        }), \", metrics=[\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'mape'\"\n        }), \"])\\r\\n\\r\\nmodel.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"fit\"\n        }), \"(x=X_train, y=y_train, epochs=\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"500\"\n        }), \", batch_size=\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"18\"\n        }), \", verbose=\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"2\"\n        }), \")\\r\\n\\r\\n# 예측 생성\\r\\nforecasts = model.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"predict\"\n        }), \"(X_test)\\r\\nlstm_fits = model.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"predict\"\n        }), \"(X_train)\\r\\n\\r\\n# 메트릭스 계산\\r\\nmape = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"mean_absolute_percentage_error\"\n        }), \"(y_test, forecasts)\\r\\nr2 = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"r2_score\"\n        }), \"(y_train, lstm_fits)\\r\\n\\r\\n# 날짜 초기화\\r\\ndate_range = pd.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"date_range\"\n        }), \"(start=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'1990-01-01'\"\n        }), \", end=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'2023-09-30'\"\n        }), \", freq=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'M'\"\n        }), \")\\r\\n\\r\\n# 맞춤 값에 원래 시계열과 맞추기 위한 비어있는 값 추가\\r\\nfits = np.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"full\"\n        }), \"(train_size, np.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"nan\"\n        }), \")\\r\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" i \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"range\"\n        }), \"(train_size-look_back):\\r\\n    fits[i+look_back] = lstm_fits[i]\\r\\n\\r\\n# 실제값, 맞춤값, 예측값 플롯\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"figure\"\n        }), \"(figsize=(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"10\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"6\"\n        }), \"))\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"plot\"\n        }), \"(date_range, ts_data, label=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Actual'\"\n        }), \", color=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'blue'\"\n        }), \")\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"plot\"\n        }), \"(date_range[:train_size], fits, label=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Fitted'\"\n        }), \", color=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'green'\"\n        }), \")\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"plot\"\n        }), \"(date_range[\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"train_size\"\n        }), \":], forecasts, label=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Forecast'\"\n        }), \", color=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'red'\"\n        }), \")\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"title\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'FSC - Short - Passengers\\\\nOne Step Forward Forecast'\"\n        }), \")\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"xlabel\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Date'\"\n        }), \")\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"ylabel\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Passengers'\"\n        }), \")\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"legend\"\n        }), \"()\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"text\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.05\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.05\"\n        }), \", f\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'R2 = {r2*100:.2f}%\\\\nMAPE = {mape*100:.2f}%'\"\n        }), \", transform=plt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"gca\"\n        }), \"().\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"transAxes\"\n        }), \", fontsize=\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"12\"\n        }), \")\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"grid\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"True\"\n        }), \")\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"show\"\n        }), \"()\\n\"]\n      })\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_3.png\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"문제: 결과는 훌륭해 보입니다. 그러나 샘플 테스트 세트를 살펴보면 특이한 결함이 보입니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_4.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"예를 들어 y9를 생성하는 데에는 y8이 입력으로 사용되었습니다. 훈련에는 사용되지 않았지만 미래 값을 포함하는 것은 이상합니다. 왜냐하면 우리는 미래의 시점을 예측하고 있기 때문입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"해결책: 직접적으로 이전 값을 예측 값으로 대체하는 반복적 테스트 세트를 사용하면 이 문제를 해결할 수 있습니다. 이러한 배치 방식에서 모델은 자체 예측에 기반을 둔다. 일반적인 예측 알고리즘과 유사합니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"아래 루프에서 다음을 수행합니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"# 반복적인 예측 및 대체\\r\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" i \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"range\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"len\"\n        }), \"(X_test)):\\r\\n    forecasts[i] = model.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"predict\"\n        }), \"(X_test[i].\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"reshape\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \", look_back, \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"))\\r\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" i != \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"len\"\n        }), \"(X_test)-\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \":\\r\\n        X_test[i+\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \",look_back-\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"] = forecasts[i]\\r\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" j \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"range\"\n        }), \"(look_back-\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"):\\r\\n            X_test[i+\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \",j] = X_test[i,j+\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"]\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"결과는 완벽하지는 않지만 적어도 정허하다고 할 수 있습니다:\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_6.png\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다중 단계 방법은 창 방법과 유사하지만 더 많은 대상 단계를 갖습니다. 다음은 두 개의 전방 단계의 샘플입니다:\"\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_7.png\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"사실, 이 방법에서 사용자는 n_steps_in과 n_steps_out을 선택해야 합니다. 다음 코드는 단순 시계열을 다중 단계 LSTM 훈련을 위해 준비된 데이터 세트로 변환합니다:\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"# 단변량 시퀀스를 다단계로 샘플링하기\\r\\ndef \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"split_sequences\"\n        }), \"(sequences, n_steps_in, n_steps_out):\\r\\n X, y = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"list\"\n        }), \"(), \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"list\"\n        }), \"()\\r\\n \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" i \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"range\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"len\"\n        }), \"(sequences)):\\r\\n     # 해당 패턴의 끝을 찾음\\r\\n     end_ix = i + n_steps_in\\r\\n     out_end_ix = end_ix + n_steps_out\\r\\n     # 시퀀스를 벗어나는지 확인\\r\\n     \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" out_end_ix \u003e \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"len\"\n        }), \"(sequences):\\r\\n         \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"break\"\n        }), \"\\r\\n     # 패턴의 입력 및 출력 부분 수집\\r\\n     seq_x, seq_y = sequences[\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"i\"\n        }), \":end_ix], sequences[\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"end_ix\"\n        }), \":out_end_ix]\\r\\n     X.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"append\"\n        }), \"(seq_x)\\r\\n     y.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"append\"\n        }), \"(seq_y)\\r\\n \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" np.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"array\"\n        }), \"(X), np.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"array\"\n        }), \"(y)\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제, 특성 뿐만 아니라 타겟도 대각선 반복을 가지고 있어 시계열과 비교하려면 그들을 평균화하거나 예측 중 하나를 선택해야 합니다. 아래 코드에서는 첫 번째, 마지막 및 평균 예측의 결과가 생성되며, 그에 이어 플롯이 제시됩니다. 여기서 첫 번째 예측은 한 달 전 예측을 의미하며, 마지막 예측은 12개월 전 예측을 의미합니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"n_steps_in = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"12\"\n        }), \"\\r\\nn_steps_out = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"12\"\n        }), \"\\r\\n\\r\\nX, y = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"split_sequences\"\n        }), \"(ts_data, n_steps_in, n_steps_out)\\r\\nX = X.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"reshape\"\n        }), \"(X.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"shape\"\n        }), \"[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"], X.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"shape\"\n        }), \"[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"], \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \")\\r\\ny = y.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"reshape\"\n        }), \"(y.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"shape\"\n        }), \"[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"], y.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"shape\"\n        }), \"[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"], \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \")\\r\\n\\r\\n# 훈련 및 테스트 세트 분리\\r\\ntrain_ratio = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.8\"\n        }), \"\\r\\ntrain_size = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"int\"\n        }), \"(train_ratio * \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"len\"\n        }), \"(ts_data))\\r\\nX_train, X_test = X[:train_size-n_steps_in-n_steps_out+\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"], X[train_size-n_steps_in-n_steps_out+\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \":]\\r\\ny_train = y[:train_size-n_steps_in-n_steps_out+\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"]\\r\\ny_test = ts_data[\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"train_size\"\n        }), \":]\\r\\n\\r\\n# \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"LSTM\"\n        }), \" 모델 생성 및 훈련\\r\\nmodel = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Sequential\"\n        }), \"()\\r\\nmodel.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"add\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"LSTM\"\n        }), \"(units=\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"72\"\n        }), \", activation=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'tanh'\"\n        }), \", input_shape=(n_steps_in, \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \")))\\r\\nmodel.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"add\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Dense\"\n        }), \"(units=n_steps_out))\\r\\nmodel.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"compile\"\n        }), \"(loss=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'mean_squared_error'\"\n        }), \", optimizer=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Adam'\"\n        }), \", metrics=[\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'mape'\"\n        }), \"])\\r\\n\\r\\nmodel.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"fit\"\n        }), \"(x=X_train, y=y_train, epochs=\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"500\"\n        }), \", batch_size=\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"18\"\n        }), \", verbose=\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"2\"\n        }), \")\\r\\n\\r\\n# 예측 생성\\r\\nlstm_predictions = model.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"predict\"\n        }), \"(X_test)\\r\\nlstm_fitted = model.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"predict\"\n        }), \"(X_train)\\r\\n\\r\\nforecasts = [np.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"diag\"\n        }), \"(np.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"fliplr\"\n        }), \"(lstm_predictions), i).\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"mean\"\n        }), \"() \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" i \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"range\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", -lstm_predictions.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"shape\"\n        }), \"[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"], -\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \")]\\r\\nfits = [np.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"diag\"\n        }), \"(np.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"fliplr\"\n        }), \"(lstm_fitted), i).\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"mean\"\n        }), \"() \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" i \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"range\"\n        }), \"(lstm_fitted.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"shape\"\n        }), \"[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"]+n_steps_in - \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \", -lstm_fitted.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"shape\"\n        }), \"[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"], -\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \")]\\r\\nforecasts1 = lstm_predictions[n_steps_out-\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \":,\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"]\\r\\nfits1 = model.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"predict\"\n        }), \"(X)[:train_size-n_steps_in,\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"]\\r\\nforecasts12 = lstm_predictions[:,n_steps_out-\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"]\\r\\nfits12 = lstm_fitted[:,n_steps_out-\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"]\\r\\n\\r\\n# \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Metric\"\n        }), \"\\r\\nav_mape = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"mean_absolute_percentage_error\"\n        }), \"(y_test, forecasts)\\r\\nav_r2 = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"r2_score\"\n        }), \"(ts_data[\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"n_steps_in\"\n        }), \":train_size], fits[\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"n_steps_in\"\n        }), \":])\\r\\none_mape = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"mean_absolute_percentage_error\"\n        }), \"(y_test[:-n_steps_out+\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"], forecasts1)\\r\\none_r2 = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"r2_score\"\n        }), \"(ts_data[\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"n_steps_in\"\n        }), \":train_size], fits1)\\r\\ntwelve_mape = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"mean_absolute_percentage_error\"\n        }), \"(y_test, forecasts12)\\r\\ntwelve_r2 = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"r2_score\"\n        }), \"(ts_data[n_steps_in+n_steps_out-\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \":train_size], fits12)\\r\\n \\r\\ndate_range = pd.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"date_range\"\n        }), \"(start=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'1990-01-01'\"\n        }), \", end=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'2023-09-30'\"\n        }), \", freq=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'M'\"\n        }), \")\\r\\n\\r\\n# 실제, 적합 결과 및 예측을 플롯\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"figure\"\n        }), \"(figsize=(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"10\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"6\"\n        }), \"))\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"plot\"\n        }), \"(date_range, ts_data, label=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Actual'\"\n        }), \", color=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'blue'\"\n        }), \")\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"plot\"\n        }), \"(date_range[:train_size], fits, label=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Fitted'\"\n        }), \", color=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'green'\"\n        }), \")\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"plot\"\n        }), \"(date_range[\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"train_size\"\n        }), \":], forecasts, label=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Forecast'\"\n        }), \", color=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'red'\"\n        }), \")\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"title\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'FSC - Short - Passengers\\\\n. LSTM 12 Month Average Forecast'\"\n        }), \")\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"xlabel\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Date'\"\n        }), \")\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"ylabel\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Passengers'\"\n        }), \")\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"legend\"\n        }), \"()\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"text\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.05\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.05\"\n        }), \", f\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'R2 = {av_r2*100:.2f}%\\\\nMAPE = {av_mape*100:.2f}%'\"\n        }), \", transform=plt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"gca\"\n        }), \"().\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"transAxes\"\n        }), \", fontsize=\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"12\"\n        }), \")\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"grid\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"True\"\n        }), \")\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"show\"\n        }), \"()\\r\\n\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"figure\"\n        }), \"(figsize=(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"10\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"6\"\n        }), \"))\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"plot\"\n        }), \"(date_range, ts_data, label=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Actual'\"\n        }), \", color=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'blue'\"\n        }), \")\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"plot\"\n        }), \"(date_range[\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"n_steps_in\"\n        }), \":train_size], fits1, label=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Fitted'\"\n        }), \", color=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'green'\"\n        }), \")\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"plot\"\n        }), \"(date_range[\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"train_size\"\n        }), \":-n_steps_out+\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"], forecasts1, label=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Forecast'\"\n        }), \", color=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'red'\"\n        }), \")\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"title\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'FSC - Short - Passengers\\\\n LSTM 1 Month in advance Forecast'\"\n        }), \")\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"xlabel\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Date'\"\n        }), \")\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"ylabel\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Passengers'\"\n        }), \")\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"legend\"\n        }), \"()\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"text\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.05\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.05\"\n        }), \", f\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'R2 = {one_r2*100:.2f}%\\\\nMAPE = {one_mape*100:.2f}%'\"\n        }), \", transform=plt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"gca\"\n        }), \"().\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"transAxes\"\n        }), \", fontsize=\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"12\"\n        }), \")\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"grid\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"True\"\n        }), \")\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"show\"\n        }), \"()\\r\\n\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"figure\"\n        }), \"(figsize=(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"10\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"6\"\n        }), \"))\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"plot\"\n        }), \"(date_range, ts_data, label=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Actual'\"\n        }), \", color=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'blue'\"\n        }), \")\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"plot\"\n        }), \"(date_range[n_steps_in+n_steps_out-\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \":train_size], fits12, label=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Fitted'\"\n        }), \", color=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'green'\"\n        }), \")\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"plot\"\n        }), \"(date_range[\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"train_size\"\n        }), \":], forecasts12, label=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Forecast'\"\n        }), \", color=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'red'\"\n        }), \")\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"title\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'FSC - Short - Passengers\\\\n LSTM 12 Months in advance Forecast'\"\n        }), \")\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"xlabel\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Date'\"\n        }), \")\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"ylabel\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Passengers'\"\n        }), \")\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"legend\"\n        }), \"()\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"text\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.05\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.05\"\n        }), \", f\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'R2 = {twelve_r2*100:.2f}%\\\\nMAPE = {twelve_mape*100:.2f}%'\"\n        }), \", transform=plt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"gca\"\n        }), \"().\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"transAxes\"\n        }), \", fontsize=\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"12\"\n        }), \")\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"grid\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"True\"\n        }), \")\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"show\"\n        }), \"()\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이슈: 창 메서드와 동일한 문제가 여기에도 있습니다:```\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_8.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"해상도: 창 법과 비슷한 방법을 사용할 수 있습니다. 그러나 n_steps_out을 test_size와 동일하게 선택할 수도 있습니다. 이렇게 하면 테스트 세트가 하나로 축소됩니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_9.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다음 함수는 이를 정확히 수행합니다. 이 함수는 시계열, 학습 크기 및 샘플 수를 사용합니다. 이 버전은 다른 예측 알고리즘과 비교할 수 있기 때문에 comparable로 이름 지었습니다:\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"def \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"split_sequences_comparable\"\n        }), \"(sequences, n_samples, train_size):\\r\\n # 단계\\r\\n n_steps_out = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"len\"\n        }), \"(sequences) - train_size\\r\\n n_steps_in = train_size - n_steps_out - n_samples + \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"\\r\\n # 끝 세트\\r\\n X_test = sequences[n_samples + n_steps_out - \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \":train_size]\\r\\n X_forecast = sequences[-\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"n_steps_in\"\n        }), \":]\\r\\n X, y = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"list\"\n        }), \"(), \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"list\"\n        }), \"()\\r\\n \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" i \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"range\"\n        }), \"(n_samples):\\r\\n     # 이 패턴의 끝을 찾습니다\\r\\n     end_ix = i + n_steps_in\\r\\n     out_end_ix = end_ix + n_steps_out\\r\\n     # 패턴의 입력 및 출력 부분을 수집합니다\\r\\n     seq_x, seq_y = sequences[\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"i\"\n        }), \":end_ix], sequences[\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"end_ix\"\n        }), \":out_end_ix]\\r\\n     X.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"append\"\n        }), \"(seq_x)\\r\\n     y.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"append\"\n        }), \"(seq_y)\\r\\n \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" np.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"array\"\n        }), \"(X), np.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"array\"\n        }), \"(y), np.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"array\"\n        }), \"(X_test), np.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"array\"\n        }), \"(X_forecast), n_steps_in, n_steps_out\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 함수에서는 단계 수가 이미 고정되었기 때문에 샘플 수와 훈련 크기는 사용자가 선택하도록 하고, 최대 가능한 단계 수를 계산하도록 결정했습니다. 아래는 실행된 코드와 그 결과입니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"n_samples = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"12\"\n        }), \"\\r\\ntrain_size = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"321\"\n        }), \"\\r\\nX_train, y_train, X_test, X_forecast, n_steps_in, n_steps_out = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"split_sequences_comparable\"\n        }), \"(ts_data, n_samples, train_size)\\r\\ny_test = ts_data[\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"train_size\"\n        }), \":]\\r\\n\\r\\n# \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Reshaping\"\n        }), \"\\r\\nX_train = X_train.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"reshape\"\n        }), \"(X_train.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"shape\"\n        }), \"[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"], X_train.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"shape\"\n        }), \"[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"], \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \")\\r\\nX_test = X_test.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"reshape\"\n        }), \"(X_test.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"shape\"\n        }), \"[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"], X_test.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"shape\"\n        }), \"[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"], \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \")\\r\\ny_train = y_train.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"reshape\"\n        }), \"(y_train.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"shape\"\n        }), \"[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"], y_train.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"shape\"\n        }), \"[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"])\\r\\ny_test = y_test.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"reshape\"\n        }), \"(y_test.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"shape\"\n        }), \"[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"], y_test.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"shape\"\n        }), \"[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"], \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \")\\r\\n\\r\\n# \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"LSTM\"\n        }), \" 모델 생성 및 훈련\\r\\nmodel = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Sequential\"\n        }), \"()\\r\\nmodel.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"add\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"LSTM\"\n        }), \"(units=\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"154\"\n        }), \", activation=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'tanh'\"\n        }), \", input_shape=(n_steps_in, \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \")))\\r\\nmodel.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"add\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Dense\"\n        }), \"(units=n_steps_out))\\r\\nmodel.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"compile\"\n        }), \"(loss=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'mean_squared_error'\"\n        }), \", optimizer=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Adam'\"\n        }), \", metrics=[\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'mape'\"\n        }), \"])\\r\\n\\r\\nmodel.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"fit\"\n        }), \"(x=X_train, y=y_train, epochs=\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"500\"\n        }), \", batch_size=\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"18\"\n        }), \", verbose=\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"2\"\n        }), \")\\r\\n\\r\\n# 예측\\r\\nlstm_predictions = model.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"predict\"\n        }), \"(X_test)\\r\\npredictions = lstm_predictions.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"reshape\"\n        }), \"(lstm_predictions.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"shape\"\n        }), \"[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"])\\r\\nlstm_fitted = model.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"predict\"\n        }), \"(X_train)\\r\\nfits = [np.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"diag\"\n        }), \"(np.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"fliplr\"\n        }), \"(lstm_fitted), i).\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"mean\"\n        }), \"() \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" i \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"range\"\n        }), \"(lstm_fitted.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"shape\"\n        }), \"[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"]+n_steps_in - \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \", -lstm_fitted.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"shape\"\n        }), \"[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"], -\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \")]\\r\\n\\r\\n# 메트릭스\\r\\nmape = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"mean_absolute_percentage_error\"\n        }), \"(y_test, predictions)\\r\\nr2 = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"r2_score\"\n        }), \"(ts_data[\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"n_steps_in\"\n        }), \":train_size], fits[\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"n_steps_in\"\n        }), \":])\\r\\n\\r\\n# 실제, 적합 및 예측 플롯\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"figure\"\n        }), \"(figsize=(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"10\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"6\"\n        }), \"))\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"plot\"\n        }), \"(date_range, ts_data, label=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Actual'\"\n        }), \", color=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'blue'\"\n        }), \")\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"plot\"\n        }), \"(date_range[:train_size], fits, label=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Fitted'\"\n        }), \", color=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'green'\"\n        }), \")\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"plot\"\n        }), \"(date_range[\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"train_size\"\n        }), \":], predictions, label=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Forecast'\"\n        }), \", color=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'red'\"\n        }), \")\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"title\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'FSC - Short - Passengers\\\\n12 Sample Comparable LSTM Forecast'\"\n        }), \")\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"xlabel\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Date'\"\n        }), \")\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"ylabel\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Passengers'\"\n        }), \")\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"legend\"\n        }), \"()\\r\\nplt.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"text\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.05\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.05\"\n        }), \", f\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'R2 = {r2*100:.2f}%\\\\nMAPE = {mape*100:.2f}%\\\\', transform=plt.gca().transAxes, fontsize=12)\\r\\nplt.grid(True)\\r\\nplt.show()\\n\"\n        })]\n      })\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/assets/img/2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting_10.png\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"지금까지 우리가 얻은 결과는 가장 신뢰할만한 것입니다. 그러나 제가 개발한 혁신적인 방법을 사용하면 더 나은 결과를 얻을 수 있습니다. 이 방법은 나중에 시리즈에서 (순환 방법) 자세히 설명하겠습니다. 먼저 LSTM 네트워크의 하이퍼파라미터를 조정하는 방법에 대해 설명하겠습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"LSTM은 모든 시간 단계를 특성으로 집계하기 때문에 시계열 데이터가 모든 이러한 방법에서 손실됩니다. 나중에 시리즈에서 (인코더/디코더 방법) 시계열 입력의 구조를 유지하는 다른 방법을 사용할 것입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"계속 주목해 주세요!\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-18-HowtofixacommonmistakeinLSTMtimeseriesforecasting"},"buildId":"0asLlD6on3tm8cIfzBaxd","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>