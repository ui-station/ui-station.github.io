<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Kubernetes 클러스터에서 노드 회전 자동화 머신 이미지 업데이트 최적화하기 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-06-19-StreamliningMachineImageUpdatesAutomatingNodeRotationinKubernetesClusters" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Kubernetes 클러스터에서 노드 회전 자동화 머신 이미지 업데이트 최적화하기 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="Kubernetes 클러스터에서 노드 회전 자동화 머신 이미지 업데이트 최적화하기 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-19-StreamliningMachineImageUpdatesAutomatingNodeRotationinKubernetesClusters_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-06-19-StreamliningMachineImageUpdatesAutomatingNodeRotationinKubernetesClusters" data-gatsby-head="true"/><meta name="twitter:title" content="Kubernetes 클러스터에서 노드 회전 자동화 머신 이미지 업데이트 최적화하기 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-19-StreamliningMachineImageUpdatesAutomatingNodeRotationinKubernetesClusters_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-19 13:13" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-4f7b40c1114f0d09.js" defer=""></script><script src="/_next/static/-dPCbnM2yhdKNgXe92VJV/_buildManifest.js" defer=""></script><script src="/_next/static/-dPCbnM2yhdKNgXe92VJV/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Kubernetes 클러스터에서 노드 회전 자동화 머신 이미지 업데이트 최적화하기</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Kubernetes 클러스터에서 노드 회전 자동화 머신 이미지 업데이트 최적화하기" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 19, 2024</span><span class="posts_reading_time__f7YPP">7<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-19-StreamliningMachineImageUpdatesAutomatingNodeRotationinKubernetesClusters&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<img src="/assets/img/2024-06-19-StreamliningMachineImageUpdatesAutomatingNodeRotationinKubernetesClusters_0.png">
<h1>문제</h1>
<p>Sage AI 인프라 팀은 모든 환경에서 우리의 서비스 및 시스템의 유지 보수와 안정성을 담당합니다. 때로는 현재 머신 이미지에 보안 취약점이 발견된 경우와 같이 상대적으로 짧은 시간 내에 Kubernetes 클러스터의 노드를 새로운 머신 이미지로 업데이트해야 할 때도 있습니다. 우리는 Amazon 클라우드를 사용하기 때문에 작업하는 것은 Amazon Machine Images (AMIs)이지만, 문제와 해결책은 어떤 클라우드 환경의 Kubernetes 클러스터에도 적용 가능합니다.</p>
<p>우리의 경우, 새로운 AMI ID를 적용할 것이지만, 그런 다음 노드가 새 AMI를 적용할 수 있도록 시간 내에 회전되도록 보장해야 합니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>과거에는 오래된 AMI를 감지하여 해당 노드를 드레인하고 있는 사용자 정의 쉘 스크립트를 사용했습니다(해당 노드에서 실행 중인 파드는 제어된 방식으로 종료되어야 하며, 해당 서비스에 중단이 발생하지 않도록해야 합니다). 이 방법을 사용하면 몇 가지 단점이 있었습니다. 첫째, 누군가가 수동으로 스크립트를 호출하고 모니터링해야 했습니다. 둘째, 클러스터에 액세스하기 위해 인증 프록시를 사용하고 있으며, 해당 프록시가 있는 노드를 드레인하면 스크립트가 서버 연결을 잃고 오류가 발생할 수 있습니다. 때로는 이러한 일이 연이어 발생할 수도 있었습니다. 당연히 노드를 회전시키는 작업은 해당 작업을 담당하는 엔지니어에게 상당한 시간, 주의 및 수동 노력이 필요했습니다.</p>
<h1>솔루션 설계</h1>
<p>우리는 클러스터에서 AMI를 업데이트하는 엔지니어들에게 주는 부담을 크게 줄일 수 있는 솔루션을 찾기로 결정했습니다. 오래된 AMI가 있는 노드를 자동으로 회전시킬 수 있는 도구가 필요했다는 것을 알았지만, 이 요구 사항은 넓은 범위를 요구합니다. 조금 더 세부적으로 이를 분석해보면 프로젝트에 대한 몇 가지 요구 사항이 있었습니다;</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>우리는 쉽게 운영할 수 있는 도구를 원했습니다. 가장 이상적인 경우에는 감독이 필요하지 않은 것이 좋습니다. 엔지니어의 시간은 귀중하며 딱딱한 도구를 감시하는 데 그 시간을 낭비하는 것은 별 의미가 없습니다.</li>
<li>필요한 경우에는 간편하게 유지 및 업데이트할 수 있는 도구를 원했습니다. 우리는 많은 서드파티 도구를 사용하고 주기적으로 모두를 업그레이드해야 할 때가 있습니다. 그 중 일부는 다른 것들보다 업데이트하기가 훨씬 어려웠습니다.</li>
<li>우리는 쿠버네티스 클러스터에서 실행 중인 워크로드에 대한 설정한 모니터링 및 가시성 프로세스를 사용할 수 있는 솔루션을 원했습니다.</li>
</ul>
<h2>우리의 솔루션</h2>
<p>우리는 시스템을 두 단계로 작동하도록 설계하기로 결정했습니다. 교체해야 할 노드를 확인하고 해당 노드의 워크로드를 소진하는 것입니다.</p>
<p>간단히 말해서, 노드를 소진한다는 것은 쿠버네티스가 해당 노드에 대해 어떠한 새로운 워크로드도 시도하지 않도록 태그를 달아놓고, 해당 노드의 프로세스와 상태가 해체되고, 새로운 노드가 대신 생성될 때까지 대기하는 것을 의미합니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이 작업을 하는 데 몇 가지 이유가 있었습니다.</p>
<ul>
<li>이를 통해 두 가지 구성 요소를 독립적으로 발전 및 유지할 수 있습니다.</li>
<li>구성 요소에는 각각 다른 수명 주기 기대치가 있으며, 노드 선택 구성 요소는 선택 기준 또는 기본 인프라 변경에 따라 변경될 필요가 있습니다. 반면, 노드를 비우는 구성 요소는 비교적 안정적인 상태로 유지됩니다.</li>
<li>노드 선택 구성 요소는 주로 AWS API와 상호 작용하고, 노드 비우기는 Kubernetes 컨트롤러입니다.</li>
</ul>
<p>두 구성 요소가 별도로 개발되는 또 다른 이유는 필요에 따라 서로 다른 언어로 작성되어 있으며, 선택 노드를 선택하는 구성 요소는 Bash 및 AWS CLI와 같은 성숙한 도구 및 jq와 같은 JSON 조작 도구 사용의 용이성과 간결성이 더 높을 것입니다. 반면에 우리는 솔루션을 Go 생태계에서 구현하기로 선택했습니다. 왜냐하면 Kubernetes 컨트롤러를 작성하는 데 라이브러리 및 문서 지원이 많기 때문에 노드를 비우는 구성 요소를 Go로 작성하는 것이 유리했기 때문입니다.</p>
<p>다음으로, 부분 간 통신 방식을 결정해야 했습니다. 일반적으로 노드에 작업을 표시하는 방법은 레이블을 지정하는 것입니다. 그러나 이 경우에는 taint를 사용하기로 결정했습니다. 장점은 taint를 한 번 설정하면 해당 노드에는 pod를 실행할 수 없으며, 추방된 pod가 해당 노드에 실행되는 것을 방지합니다. 따라서 노드 선택 작업은 노드에 taint를 설정하고, 비우기 작업은 노드 선택 작업에 의해 tainted된 노드를 식별하고 해당 pod를 비웁니다. 그런 다음 비워진 노드의 후속 종료는 클러스터 자동 확장기에 의해 처리됩니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>거부된 방식</h1>
<p>AWS Lambda를 기반으로 한 노드 드레이너 구현체가 여러 가지 있습니다(예: <a href="https://github.com/aws-samples/amazon-k8s-node-drainer" rel="nofollow" target="_blank">https://github.com/aws-samples/amazon-k8s-node-drainer</a>) 하지만, 우리는 클러스터 내에서 실행되도록 설계된 도구가 필요했습니다. 이는 이미 우리가 갖고 있는 모니터링 기능을 사용하기 위함입니다.</p>
<p>AWS Auto Scaling 그룹 노드 새로 고침 프로세스를 기반으로 한 노드 드레이닝을 구현한 프로젝트들이 이미 존재하며, <a href="https://github.com/rebuy-de/node-drainer%EA%B0%80" rel="nofollow" target="_blank">https://github.com/rebuy-de/node-drainer가</a> 대표적인 예입니다. 이 프로젝트를 고려해 보았지만, 해당 프로젝트는 2023년 3월 이후에 어떠한 업데이트도 릴리스하지 않았기 때문에 채택하는 것이 리스크가 될 수 있습니다. 만약 이 프로젝트나 관련 종속성에 심각한 취약점이 발견된다면, 업데이트된 이미지를 얻을 수 없게 될 수 있으며, 우리 자신의 포크를 유지보수해야 할 수도 있습니다.</p>
<h1>구현</h1>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>해결 방법의 두 번째 부분은 nodes를 감시하고 지정된 draining taint가 설정되면 node의 포드를 제거하기 시작하는 Kubernetes 컨트롤러로 구현되었습니다. 포드가 떠날 때까지 노드를 제거하는 작업은 타임 아웃 될 때까지 계속 됩니다 (가끔 포드가 떠나고 싶어하지 않을 수도 있어요) 또는 타임아웃 시간이 경과할 때까지입니다. 일정 시간이 지나면 그 노드를 다시 시도합니다. 프로그램은 항상 노드 제거를 직렬화하고, 노드를 처리한 후 클러스터에 보류 중인 포드가 없을 때까지 기다린 후 계속합니다. 이는 클러스터의 용량 문제를 최소화하기 위해 수행됩니다 - 모든 포드가 제거를 위해 tainted되어 있으면 새로운 노드가 생성될 때까지 새로운 포드를 시작할 수 없습니다.</p>
<p><img src="/assets/img/2024-06-19-StreamliningMachineImageUpdatesAutomatingNodeRotationinKubernetesClusters_1.png" alt="이미지"></p>
<h1>첫 번째 오픈 소스 기여물로 발표 결정</h1>
<p>Sage AI 팀은 우리가 내부적으로 개발한 프로젝트들을 확인하여 일반 커뮤니티에 혜택을 줄 수 있다고 판단한 프로젝트들을 식별하기로 결정했습니다. 우리 인프라 팀은 MLOps 분야에서 많은 훌륭한 작업을 수행했고, 위에서 설명한 워크플로우의 자동화가 오픈 소스 커뮤니티에 공개되었다는 것을 자랑스럽게 발표합니다!</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>우리의 방식은 내부에서 이미 1년 넘게 사용되어 왔고, 이제 코드는 여기에서 찾을 수 있습니다; <a href="https://github.com/sageailabs/ektopistis" rel="nofollow" target="_blank">https://github.com/sageailabs/ektopistis</a> .</p>
<p>관심이 있으시면 자유롭게 살펴보고, 유용하다고 판단되면 귀하의 환경에서 사용하거나 피드백이나 코드로 기여해 주시기 바랍니다!</p>
<p>프로젝트 README의 설치 섹션의 지침을 따라 Helm을 사용하여 클러스터에 설치할 수 있습니다. 노드 선택 구성 요소의 의미론은 임의적이며, 원하는 선택 기준과 태깅 의미론에 기반하여 구성할 수 있습니다. 예를 들어, AWS 오토 스케일링 그룹에서 시작된 모든 클러스터 노드를 표시하고 설정이 ASG의 론칭 템플릿과 일치하지 않는 스크립트가 있습니다.</p>
<p>우리는 우리의 도구를 공유함으로써 더 나은 해결책으로 이어질 것이라고 믿습니다. 귀하의 피드백과 기여를 기대하며, 즐거운 협업을 기대하고 있습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>계획된 미래 작업에 대한 참고사항</h1>
<p>저희 노드 드레이너 구현은 중요한 작업 부하의 업데이트를 방해하지 않기 위해 클러스터에 보류 중인 파드가 있을 때 작업을 중지합니다. 그러나 이에는 중요한 하다고 할 수 있는 단점이 있습니다. 클러스터가 클수록 활동이 많을수록 파드의 순환율이 높아집니다. 이로 인해 보류 중인 파드가 계속 발생하여 노드 드레이너의 현재 버전이 멈춰있는 장기간이 발생할 수 있습니다. 저희는 이 대기 정책을 개선하여 프로세스를 가속화하는 계획이 있습니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Kubernetes 클러스터에서 노드 회전 자동화 머신 이미지 업데이트 최적화하기","description":"","date":"2024-06-19 13:13","slug":"2024-06-19-StreamliningMachineImageUpdatesAutomatingNodeRotationinKubernetesClusters","content":"\n\u003cimg src=\"/assets/img/2024-06-19-StreamliningMachineImageUpdatesAutomatingNodeRotationinKubernetesClusters_0.png\" /\u003e\n\n# 문제\n\nSage AI 인프라 팀은 모든 환경에서 우리의 서비스 및 시스템의 유지 보수와 안정성을 담당합니다. 때로는 현재 머신 이미지에 보안 취약점이 발견된 경우와 같이 상대적으로 짧은 시간 내에 Kubernetes 클러스터의 노드를 새로운 머신 이미지로 업데이트해야 할 때도 있습니다. 우리는 Amazon 클라우드를 사용하기 때문에 작업하는 것은 Amazon Machine Images (AMIs)이지만, 문제와 해결책은 어떤 클라우드 환경의 Kubernetes 클러스터에도 적용 가능합니다.\n\n우리의 경우, 새로운 AMI ID를 적용할 것이지만, 그런 다음 노드가 새 AMI를 적용할 수 있도록 시간 내에 회전되도록 보장해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n과거에는 오래된 AMI를 감지하여 해당 노드를 드레인하고 있는 사용자 정의 쉘 스크립트를 사용했습니다(해당 노드에서 실행 중인 파드는 제어된 방식으로 종료되어야 하며, 해당 서비스에 중단이 발생하지 않도록해야 합니다). 이 방법을 사용하면 몇 가지 단점이 있었습니다. 첫째, 누군가가 수동으로 스크립트를 호출하고 모니터링해야 했습니다. 둘째, 클러스터에 액세스하기 위해 인증 프록시를 사용하고 있으며, 해당 프록시가 있는 노드를 드레인하면 스크립트가 서버 연결을 잃고 오류가 발생할 수 있습니다. 때로는 이러한 일이 연이어 발생할 수도 있었습니다. 당연히 노드를 회전시키는 작업은 해당 작업을 담당하는 엔지니어에게 상당한 시간, 주의 및 수동 노력이 필요했습니다.\n\n# 솔루션 설계\n\n우리는 클러스터에서 AMI를 업데이트하는 엔지니어들에게 주는 부담을 크게 줄일 수 있는 솔루션을 찾기로 결정했습니다. 오래된 AMI가 있는 노드를 자동으로 회전시킬 수 있는 도구가 필요했다는 것을 알았지만, 이 요구 사항은 넓은 범위를 요구합니다. 조금 더 세부적으로 이를 분석해보면 프로젝트에 대한 몇 가지 요구 사항이 있었습니다;\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 우리는 쉽게 운영할 수 있는 도구를 원했습니다. 가장 이상적인 경우에는 감독이 필요하지 않은 것이 좋습니다. 엔지니어의 시간은 귀중하며 딱딱한 도구를 감시하는 데 그 시간을 낭비하는 것은 별 의미가 없습니다.\n- 필요한 경우에는 간편하게 유지 및 업데이트할 수 있는 도구를 원했습니다. 우리는 많은 서드파티 도구를 사용하고 주기적으로 모두를 업그레이드해야 할 때가 있습니다. 그 중 일부는 다른 것들보다 업데이트하기가 훨씬 어려웠습니다.\n- 우리는 쿠버네티스 클러스터에서 실행 중인 워크로드에 대한 설정한 모니터링 및 가시성 프로세스를 사용할 수 있는 솔루션을 원했습니다.\n\n## 우리의 솔루션\n\n우리는 시스템을 두 단계로 작동하도록 설계하기로 결정했습니다. 교체해야 할 노드를 확인하고 해당 노드의 워크로드를 소진하는 것입니다.\n\n간단히 말해서, 노드를 소진한다는 것은 쿠버네티스가 해당 노드에 대해 어떠한 새로운 워크로드도 시도하지 않도록 태그를 달아놓고, 해당 노드의 프로세스와 상태가 해체되고, 새로운 노드가 대신 생성될 때까지 대기하는 것을 의미합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 작업을 하는 데 몇 가지 이유가 있었습니다.\n\n- 이를 통해 두 가지 구성 요소를 독립적으로 발전 및 유지할 수 있습니다.\n- 구성 요소에는 각각 다른 수명 주기 기대치가 있으며, 노드 선택 구성 요소는 선택 기준 또는 기본 인프라 변경에 따라 변경될 필요가 있습니다. 반면, 노드를 비우는 구성 요소는 비교적 안정적인 상태로 유지됩니다.\n- 노드 선택 구성 요소는 주로 AWS API와 상호 작용하고, 노드 비우기는 Kubernetes 컨트롤러입니다.\n\n두 구성 요소가 별도로 개발되는 또 다른 이유는 필요에 따라 서로 다른 언어로 작성되어 있으며, 선택 노드를 선택하는 구성 요소는 Bash 및 AWS CLI와 같은 성숙한 도구 및 jq와 같은 JSON 조작 도구 사용의 용이성과 간결성이 더 높을 것입니다. 반면에 우리는 솔루션을 Go 생태계에서 구현하기로 선택했습니다. 왜냐하면 Kubernetes 컨트롤러를 작성하는 데 라이브러리 및 문서 지원이 많기 때문에 노드를 비우는 구성 요소를 Go로 작성하는 것이 유리했기 때문입니다.\n\n다음으로, 부분 간 통신 방식을 결정해야 했습니다. 일반적으로 노드에 작업을 표시하는 방법은 레이블을 지정하는 것입니다. 그러나 이 경우에는 taint를 사용하기로 결정했습니다. 장점은 taint를 한 번 설정하면 해당 노드에는 pod를 실행할 수 없으며, 추방된 pod가 해당 노드에 실행되는 것을 방지합니다. 따라서 노드 선택 작업은 노드에 taint를 설정하고, 비우기 작업은 노드 선택 작업에 의해 tainted된 노드를 식별하고 해당 pod를 비웁니다. 그런 다음 비워진 노드의 후속 종료는 클러스터 자동 확장기에 의해 처리됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 거부된 방식\n\nAWS Lambda를 기반으로 한 노드 드레이너 구현체가 여러 가지 있습니다(예: https://github.com/aws-samples/amazon-k8s-node-drainer) 하지만, 우리는 클러스터 내에서 실행되도록 설계된 도구가 필요했습니다. 이는 이미 우리가 갖고 있는 모니터링 기능을 사용하기 위함입니다.\n\nAWS Auto Scaling 그룹 노드 새로 고침 프로세스를 기반으로 한 노드 드레이닝을 구현한 프로젝트들이 이미 존재하며, https://github.com/rebuy-de/node-drainer가 대표적인 예입니다. 이 프로젝트를 고려해 보았지만, 해당 프로젝트는 2023년 3월 이후에 어떠한 업데이트도 릴리스하지 않았기 때문에 채택하는 것이 리스크가 될 수 있습니다. 만약 이 프로젝트나 관련 종속성에 심각한 취약점이 발견된다면, 업데이트된 이미지를 얻을 수 없게 될 수 있으며, 우리 자신의 포크를 유지보수해야 할 수도 있습니다.\n\n# 구현\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n해결 방법의 두 번째 부분은 nodes를 감시하고 지정된 draining taint가 설정되면 node의 포드를 제거하기 시작하는 Kubernetes 컨트롤러로 구현되었습니다. 포드가 떠날 때까지 노드를 제거하는 작업은 타임 아웃 될 때까지 계속 됩니다 (가끔 포드가 떠나고 싶어하지 않을 수도 있어요) 또는 타임아웃 시간이 경과할 때까지입니다. 일정 시간이 지나면 그 노드를 다시 시도합니다. 프로그램은 항상 노드 제거를 직렬화하고, 노드를 처리한 후 클러스터에 보류 중인 포드가 없을 때까지 기다린 후 계속합니다. 이는 클러스터의 용량 문제를 최소화하기 위해 수행됩니다 - 모든 포드가 제거를 위해 tainted되어 있으면 새로운 노드가 생성될 때까지 새로운 포드를 시작할 수 없습니다.\n\n![이미지](/assets/img/2024-06-19-StreamliningMachineImageUpdatesAutomatingNodeRotationinKubernetesClusters_1.png)\n\n# 첫 번째 오픈 소스 기여물로 발표 결정\n\nSage AI 팀은 우리가 내부적으로 개발한 프로젝트들을 확인하여 일반 커뮤니티에 혜택을 줄 수 있다고 판단한 프로젝트들을 식별하기로 결정했습니다. 우리 인프라 팀은 MLOps 분야에서 많은 훌륭한 작업을 수행했고, 위에서 설명한 워크플로우의 자동화가 오픈 소스 커뮤니티에 공개되었다는 것을 자랑스럽게 발표합니다!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리의 방식은 내부에서 이미 1년 넘게 사용되어 왔고, 이제 코드는 여기에서 찾을 수 있습니다; https://github.com/sageailabs/ektopistis .\n\n관심이 있으시면 자유롭게 살펴보고, 유용하다고 판단되면 귀하의 환경에서 사용하거나 피드백이나 코드로 기여해 주시기 바랍니다!\n\n프로젝트 README의 설치 섹션의 지침을 따라 Helm을 사용하여 클러스터에 설치할 수 있습니다. 노드 선택 구성 요소의 의미론은 임의적이며, 원하는 선택 기준과 태깅 의미론에 기반하여 구성할 수 있습니다. 예를 들어, AWS 오토 스케일링 그룹에서 시작된 모든 클러스터 노드를 표시하고 설정이 ASG의 론칭 템플릿과 일치하지 않는 스크립트가 있습니다.\n\n우리는 우리의 도구를 공유함으로써 더 나은 해결책으로 이어질 것이라고 믿습니다. 귀하의 피드백과 기여를 기대하며, 즐거운 협업을 기대하고 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 계획된 미래 작업에 대한 참고사항\n\n저희 노드 드레이너 구현은 중요한 작업 부하의 업데이트를 방해하지 않기 위해 클러스터에 보류 중인 파드가 있을 때 작업을 중지합니다. 그러나 이에는 중요한 하다고 할 수 있는 단점이 있습니다. 클러스터가 클수록 활동이 많을수록 파드의 순환율이 높아집니다. 이로 인해 보류 중인 파드가 계속 발생하여 노드 드레이너의 현재 버전이 멈춰있는 장기간이 발생할 수 있습니다. 저희는 이 대기 정책을 개선하여 프로세스를 가속화하는 계획이 있습니다.\n","ogImage":{"url":"/assets/img/2024-06-19-StreamliningMachineImageUpdatesAutomatingNodeRotationinKubernetesClusters_0.png"},"coverImage":"/assets/img/2024-06-19-StreamliningMachineImageUpdatesAutomatingNodeRotationinKubernetesClusters_0.png","tag":["Tech"],"readingTime":7},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cimg src=\"/assets/img/2024-06-19-StreamliningMachineImageUpdatesAutomatingNodeRotationinKubernetesClusters_0.png\"\u003e\n\u003ch1\u003e문제\u003c/h1\u003e\n\u003cp\u003eSage AI 인프라 팀은 모든 환경에서 우리의 서비스 및 시스템의 유지 보수와 안정성을 담당합니다. 때로는 현재 머신 이미지에 보안 취약점이 발견된 경우와 같이 상대적으로 짧은 시간 내에 Kubernetes 클러스터의 노드를 새로운 머신 이미지로 업데이트해야 할 때도 있습니다. 우리는 Amazon 클라우드를 사용하기 때문에 작업하는 것은 Amazon Machine Images (AMIs)이지만, 문제와 해결책은 어떤 클라우드 환경의 Kubernetes 클러스터에도 적용 가능합니다.\u003c/p\u003e\n\u003cp\u003e우리의 경우, 새로운 AMI ID를 적용할 것이지만, 그런 다음 노드가 새 AMI를 적용할 수 있도록 시간 내에 회전되도록 보장해야 합니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e과거에는 오래된 AMI를 감지하여 해당 노드를 드레인하고 있는 사용자 정의 쉘 스크립트를 사용했습니다(해당 노드에서 실행 중인 파드는 제어된 방식으로 종료되어야 하며, 해당 서비스에 중단이 발생하지 않도록해야 합니다). 이 방법을 사용하면 몇 가지 단점이 있었습니다. 첫째, 누군가가 수동으로 스크립트를 호출하고 모니터링해야 했습니다. 둘째, 클러스터에 액세스하기 위해 인증 프록시를 사용하고 있으며, 해당 프록시가 있는 노드를 드레인하면 스크립트가 서버 연결을 잃고 오류가 발생할 수 있습니다. 때로는 이러한 일이 연이어 발생할 수도 있었습니다. 당연히 노드를 회전시키는 작업은 해당 작업을 담당하는 엔지니어에게 상당한 시간, 주의 및 수동 노력이 필요했습니다.\u003c/p\u003e\n\u003ch1\u003e솔루션 설계\u003c/h1\u003e\n\u003cp\u003e우리는 클러스터에서 AMI를 업데이트하는 엔지니어들에게 주는 부담을 크게 줄일 수 있는 솔루션을 찾기로 결정했습니다. 오래된 AMI가 있는 노드를 자동으로 회전시킬 수 있는 도구가 필요했다는 것을 알았지만, 이 요구 사항은 넓은 범위를 요구합니다. 조금 더 세부적으로 이를 분석해보면 프로젝트에 대한 몇 가지 요구 사항이 있었습니다;\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003e우리는 쉽게 운영할 수 있는 도구를 원했습니다. 가장 이상적인 경우에는 감독이 필요하지 않은 것이 좋습니다. 엔지니어의 시간은 귀중하며 딱딱한 도구를 감시하는 데 그 시간을 낭비하는 것은 별 의미가 없습니다.\u003c/li\u003e\n\u003cli\u003e필요한 경우에는 간편하게 유지 및 업데이트할 수 있는 도구를 원했습니다. 우리는 많은 서드파티 도구를 사용하고 주기적으로 모두를 업그레이드해야 할 때가 있습니다. 그 중 일부는 다른 것들보다 업데이트하기가 훨씬 어려웠습니다.\u003c/li\u003e\n\u003cli\u003e우리는 쿠버네티스 클러스터에서 실행 중인 워크로드에 대한 설정한 모니터링 및 가시성 프로세스를 사용할 수 있는 솔루션을 원했습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e우리의 솔루션\u003c/h2\u003e\n\u003cp\u003e우리는 시스템을 두 단계로 작동하도록 설계하기로 결정했습니다. 교체해야 할 노드를 확인하고 해당 노드의 워크로드를 소진하는 것입니다.\u003c/p\u003e\n\u003cp\u003e간단히 말해서, 노드를 소진한다는 것은 쿠버네티스가 해당 노드에 대해 어떠한 새로운 워크로드도 시도하지 않도록 태그를 달아놓고, 해당 노드의 프로세스와 상태가 해체되고, 새로운 노드가 대신 생성될 때까지 대기하는 것을 의미합니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이 작업을 하는 데 몇 가지 이유가 있었습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e이를 통해 두 가지 구성 요소를 독립적으로 발전 및 유지할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e구성 요소에는 각각 다른 수명 주기 기대치가 있으며, 노드 선택 구성 요소는 선택 기준 또는 기본 인프라 변경에 따라 변경될 필요가 있습니다. 반면, 노드를 비우는 구성 요소는 비교적 안정적인 상태로 유지됩니다.\u003c/li\u003e\n\u003cli\u003e노드 선택 구성 요소는 주로 AWS API와 상호 작용하고, 노드 비우기는 Kubernetes 컨트롤러입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e두 구성 요소가 별도로 개발되는 또 다른 이유는 필요에 따라 서로 다른 언어로 작성되어 있으며, 선택 노드를 선택하는 구성 요소는 Bash 및 AWS CLI와 같은 성숙한 도구 및 jq와 같은 JSON 조작 도구 사용의 용이성과 간결성이 더 높을 것입니다. 반면에 우리는 솔루션을 Go 생태계에서 구현하기로 선택했습니다. 왜냐하면 Kubernetes 컨트롤러를 작성하는 데 라이브러리 및 문서 지원이 많기 때문에 노드를 비우는 구성 요소를 Go로 작성하는 것이 유리했기 때문입니다.\u003c/p\u003e\n\u003cp\u003e다음으로, 부분 간 통신 방식을 결정해야 했습니다. 일반적으로 노드에 작업을 표시하는 방법은 레이블을 지정하는 것입니다. 그러나 이 경우에는 taint를 사용하기로 결정했습니다. 장점은 taint를 한 번 설정하면 해당 노드에는 pod를 실행할 수 없으며, 추방된 pod가 해당 노드에 실행되는 것을 방지합니다. 따라서 노드 선택 작업은 노드에 taint를 설정하고, 비우기 작업은 노드 선택 작업에 의해 tainted된 노드를 식별하고 해당 pod를 비웁니다. 그런 다음 비워진 노드의 후속 종료는 클러스터 자동 확장기에 의해 처리됩니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e거부된 방식\u003c/h1\u003e\n\u003cp\u003eAWS Lambda를 기반으로 한 노드 드레이너 구현체가 여러 가지 있습니다(예: \u003ca href=\"https://github.com/aws-samples/amazon-k8s-node-drainer\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://github.com/aws-samples/amazon-k8s-node-drainer\u003c/a\u003e) 하지만, 우리는 클러스터 내에서 실행되도록 설계된 도구가 필요했습니다. 이는 이미 우리가 갖고 있는 모니터링 기능을 사용하기 위함입니다.\u003c/p\u003e\n\u003cp\u003eAWS Auto Scaling 그룹 노드 새로 고침 프로세스를 기반으로 한 노드 드레이닝을 구현한 프로젝트들이 이미 존재하며, \u003ca href=\"https://github.com/rebuy-de/node-drainer%EA%B0%80\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://github.com/rebuy-de/node-drainer가\u003c/a\u003e 대표적인 예입니다. 이 프로젝트를 고려해 보았지만, 해당 프로젝트는 2023년 3월 이후에 어떠한 업데이트도 릴리스하지 않았기 때문에 채택하는 것이 리스크가 될 수 있습니다. 만약 이 프로젝트나 관련 종속성에 심각한 취약점이 발견된다면, 업데이트된 이미지를 얻을 수 없게 될 수 있으며, 우리 자신의 포크를 유지보수해야 할 수도 있습니다.\u003c/p\u003e\n\u003ch1\u003e구현\u003c/h1\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e해결 방법의 두 번째 부분은 nodes를 감시하고 지정된 draining taint가 설정되면 node의 포드를 제거하기 시작하는 Kubernetes 컨트롤러로 구현되었습니다. 포드가 떠날 때까지 노드를 제거하는 작업은 타임 아웃 될 때까지 계속 됩니다 (가끔 포드가 떠나고 싶어하지 않을 수도 있어요) 또는 타임아웃 시간이 경과할 때까지입니다. 일정 시간이 지나면 그 노드를 다시 시도합니다. 프로그램은 항상 노드 제거를 직렬화하고, 노드를 처리한 후 클러스터에 보류 중인 포드가 없을 때까지 기다린 후 계속합니다. 이는 클러스터의 용량 문제를 최소화하기 위해 수행됩니다 - 모든 포드가 제거를 위해 tainted되어 있으면 새로운 노드가 생성될 때까지 새로운 포드를 시작할 수 없습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-StreamliningMachineImageUpdatesAutomatingNodeRotationinKubernetesClusters_1.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch1\u003e첫 번째 오픈 소스 기여물로 발표 결정\u003c/h1\u003e\n\u003cp\u003eSage AI 팀은 우리가 내부적으로 개발한 프로젝트들을 확인하여 일반 커뮤니티에 혜택을 줄 수 있다고 판단한 프로젝트들을 식별하기로 결정했습니다. 우리 인프라 팀은 MLOps 분야에서 많은 훌륭한 작업을 수행했고, 위에서 설명한 워크플로우의 자동화가 오픈 소스 커뮤니티에 공개되었다는 것을 자랑스럽게 발표합니다!\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e우리의 방식은 내부에서 이미 1년 넘게 사용되어 왔고, 이제 코드는 여기에서 찾을 수 있습니다; \u003ca href=\"https://github.com/sageailabs/ektopistis\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://github.com/sageailabs/ektopistis\u003c/a\u003e .\u003c/p\u003e\n\u003cp\u003e관심이 있으시면 자유롭게 살펴보고, 유용하다고 판단되면 귀하의 환경에서 사용하거나 피드백이나 코드로 기여해 주시기 바랍니다!\u003c/p\u003e\n\u003cp\u003e프로젝트 README의 설치 섹션의 지침을 따라 Helm을 사용하여 클러스터에 설치할 수 있습니다. 노드 선택 구성 요소의 의미론은 임의적이며, 원하는 선택 기준과 태깅 의미론에 기반하여 구성할 수 있습니다. 예를 들어, AWS 오토 스케일링 그룹에서 시작된 모든 클러스터 노드를 표시하고 설정이 ASG의 론칭 템플릿과 일치하지 않는 스크립트가 있습니다.\u003c/p\u003e\n\u003cp\u003e우리는 우리의 도구를 공유함으로써 더 나은 해결책으로 이어질 것이라고 믿습니다. 귀하의 피드백과 기여를 기대하며, 즐거운 협업을 기대하고 있습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e계획된 미래 작업에 대한 참고사항\u003c/h1\u003e\n\u003cp\u003e저희 노드 드레이너 구현은 중요한 작업 부하의 업데이트를 방해하지 않기 위해 클러스터에 보류 중인 파드가 있을 때 작업을 중지합니다. 그러나 이에는 중요한 하다고 할 수 있는 단점이 있습니다. 클러스터가 클수록 활동이 많을수록 파드의 순환율이 높아집니다. 이로 인해 보류 중인 파드가 계속 발생하여 노드 드레이너의 현재 버전이 멈춰있는 장기간이 발생할 수 있습니다. 저희는 이 대기 정책을 개선하여 프로세스를 가속화하는 계획이 있습니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-19-StreamliningMachineImageUpdatesAutomatingNodeRotationinKubernetesClusters"},"buildId":"-dPCbnM2yhdKNgXe92VJV","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>