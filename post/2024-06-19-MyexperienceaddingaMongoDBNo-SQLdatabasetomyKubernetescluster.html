<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>나의 쿠버네티스 클러스터에 MongoDB No-SQL 데이터베이스를 추가한 경험 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-06-19-MyexperienceaddingaMongoDBNo-SQLdatabasetomyKubernetescluster" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="나의 쿠버네티스 클러스터에 MongoDB No-SQL 데이터베이스를 추가한 경험 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="나의 쿠버네티스 클러스터에 MongoDB No-SQL 데이터베이스를 추가한 경험 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-19-MyexperienceaddingaMongoDBNo-SQLdatabasetomyKubernetescluster_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-06-19-MyexperienceaddingaMongoDBNo-SQLdatabasetomyKubernetescluster" data-gatsby-head="true"/><meta name="twitter:title" content="나의 쿠버네티스 클러스터에 MongoDB No-SQL 데이터베이스를 추가한 경험 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-19-MyexperienceaddingaMongoDBNo-SQLdatabasetomyKubernetescluster_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-19 13:00" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-70e5ce89f3d962ac.js" defer=""></script><script src="/_next/static/GsgRekSb--BvxYwv9FPn6/_buildManifest.js" defer=""></script><script src="/_next/static/GsgRekSb--BvxYwv9FPn6/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">나의 쿠버네티스 클러스터에 MongoDB No-SQL 데이터베이스를 추가한 경험</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="나의 쿠버네티스 클러스터에 MongoDB No-SQL 데이터베이스를 추가한 경험" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 19, 2024</span><span class="posts_reading_time__f7YPP">29<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-19-MyexperienceaddingaMongoDBNo-SQLdatabasetomyKubernetescluster&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h2>SQL과 No-SQL 데이터베이스 사이를 선택하는 방법에 대해 읽었다면, Kubernetes 클러스터에 No-SQL MongoDB 데이터베이스를 추가할 수 있는지 궁금할 것입니다. 이 글에서는 그것을 어떻게 수행했는지 설명하고 Spring Boot 애플리케이션과 함께 사용하는 방법에 대해 알려드리겠습니다.</h2>
<p><img src="/assets/img/2024-06-19-MyexperienceaddingaMongoDBNo-SQLdatabasetomyKubernetescluster_0.png" alt="이미지"></p>
<h1>시작하기</h1>
<p>일반적으로 Kubernetes 서비스를 개발할 때는, 개발을 위해 로컬 Kind Kubernetes 클러스터에서 시작합니다. Kind를 설정하는 방법에 대해 이전에 썼었고, 이 글에 관련된 GitHub 저장소에는 이를 수행하는 데 필요한 구성 파일이 포함되어 있습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>클론하기 위해 저장소를 다음과 같이 복제할 수 있어요:</p>
<pre><code class="hljs language-js">git clone git@github.<span class="hljs-property">com</span>:<span class="hljs-title class_">MartinHodges</span>/aquarium-<span class="hljs-keyword">with</span>-mongo-db.<span class="hljs-property">git</span>
</code></pre>
<h1>왜 MongoDB를 사용해야 하나요?</h1>
<p>이전 기사에서 SQL 대 No-SQL 결정에 대해 다뤄 보았어요. 여러분이 이 글을 읽고 계신다면 No-SQL을 선택하겠다고 결정하신 거겠죠.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>일단 그 결정이 내렸다면, 이제 No-SQL 데이터베이스를 어떤 것을 선택할지가 문제가 됩니다. MongoDB는 가장 가까운 경쟁상대보다 2배 더 높은 시장 점유율을 보유하고 있습니다. 그것은 매우 정교하며 커뮤니티 버전과 엔터프라이즈 버전 둘 다 가지고 있습니다. 전형적으로 가장 많이 사용되는 No-SQL 데이터베이스입니다.</p>
<p>다른 데이터베이스와의 기술적인 비교는 이 기사의 범위를 벗어나지만, MongoDB가 인기 있는 이유와 일하도록 충분히 할 수 있는 사실에 기반하여 이 기사에서는 MongoDB를 선택했습니다!</p>
<h1>MongoDB 설치</h1>
<p>Kubernetes 클러스터에 MongoDB를 설치하는 방법은 다른 응용프로그램과 유사하게 operator를 사용하여 수행됩니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<img src="/assets/img/2024-06-19-MyexperienceaddingaMongoDBNo-SQLdatabasetomyKubernetescluster_1.png">
<p>쿠버네티스 오퍼레이터는 당신을 대신하여 응용 프로그램을 관리합니다. 응용 프로그램의 라이프사이클을 설치하고 관리하며 모니터링하고 필요한 조치를 취할 수 있습니다.</p>
<p>데이터베이스의 경우 데이터베이스 클러스터를 생성하거나 확장하거나 백업하는 등의 작업을 수행할 수 있습니다. 일반적으로 오퍼레이터는 그 자체의 '쿠버네티스 구성 언어'를 제공하는 사용자 정의 리소스 정의 (CRD)를 설치하기에 의존합니다. 이는 클러스터에 사용자 정의 리소스를 추가하기 위한 요청을 감지하고 당신을 대신하여 작동합니다.</p>
<h2>개발용 쿠버네티스 클러스터 생성</h2>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>Kind를 설치했다고 가정하면, 다음 구성을 사용하여 Kind 클러스터를 만들 수 있습니다:</p>
<p>kind/kind-config.yml</p>
<pre><code class="hljs language-js"><span class="hljs-attr">apiVersion</span>: kind.<span class="hljs-property">x</span>-k8s.<span class="hljs-property">io</span>/v1alpha4
<span class="hljs-attr">kind</span>: <span class="hljs-title class_">Cluster</span>
<span class="hljs-attr">nodes</span>:
- <span class="hljs-attr">role</span>: control-plane
  <span class="hljs-attr">extraPortMappings</span>:
  # apis
  - <span class="hljs-attr">containerPort</span>: <span class="hljs-number">30080</span>
    <span class="hljs-attr">hostPort</span>: <span class="hljs-number">30080</span>
- <span class="hljs-attr">role</span>: worker
- <span class="hljs-attr">role</span>: worker
- <span class="hljs-attr">role</span>: worker
</code></pre>
<p>이렇게 하면 1개의 컨트롤러 및 3개의 워커로 구성된 4개 노드 클러스터가 생성됩니다. 또한 개발 머신의 포트 30080을 사용할 수 있습니다. 이를 사용하여 로컬 Kubernetes 클러스터를 생성할 수 있습니다:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-shell">kind create cluster --config kind/kind-config.yml
</code></pre>
<h2>오퍼레이터 설치</h2>
<p>Helm을 사용하여 커뮤니티 지원 오퍼레이터를 설치할 수 있습니다.</p>
<p>먼저 다음과 같이 로컬 리포지토리에 Helm 링크를 추가하세요:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js">helm repo add mongodb <span class="hljs-attr">https</span>:<span class="hljs-comment">//mongodb.github.io/helm-charts</span>
</code></pre>
<p>아래 명령어로 이 리포지토리가 추가한 차트를 확인할 수 있어요:</p>
<pre><code class="hljs language-js">helm search repo mongo
</code></pre>
<p>리스트에서 커뮤니티 오퍼레이터를 확인할 수 있을 거에요. 이것을 사용할 거에요.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>저희는 오퍼레이터와 데이터베이스를 별도의 네임스페이스로 mongo라는 이름으로 분리해서 배치할 겁니다. 다음과 같이 생성해보겠습니다:</p>
<pre><code class="hljs language-js">kubectl create namespace mongo
</code></pre>
<p>이제 다음 명령으로 오퍼레이터를 설치할 수 있어요:</p>
<pre><code class="hljs language-js">helm install community-operator mongodb/community-operator -n mongo
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>다음 명령어를 사용하여 준비 상태가 1/1로 Running인지 확인할 수 있어요:</p>
<pre><code class="hljs language-sh">kubectl get pods -n mongo
</code></pre>
<p>이제 운영자가 작동 중인 것을 볼 수 있습니다. 설치된 CRD는 다음을 통해 확인할 수 있어요:</p>
<pre><code class="hljs language-sh">kubectl get crds
kubectl describe crd mongodbcommunity.mongodbcommunity.mongodb.com
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이제 MongoDB 클러스터를 생성할 준비가 되었습니다.</p>
<h2>클러스터 생성</h2>
<p>오퍼레이터가 설치되었으므로 MongoDB 데이터베이스를 생성하는 요청을 대기 중입니다. 우리는 오퍼레이터에 의해 로드된 CRD를 사용하여 쿠버네티스 클러스터에 MongoDB 매니페스트를 적용하여 요청을 할 수 있습니다.</p>
<p>이를 하기 전에 데이터베이스 사용자의 비밀번호를 쿠버네티스 시크릿으로 설정해야 합니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>다음과 같이 비밀을 생성하세요 (‘…’를 선택한 비밀번호로 교체하세요):</p>
<pre><code class="hljs language-js">kubectl create secret generic my-user-password -n mongo --<span class="hljs-keyword">from</span>-literal=<span class="hljs-string">"password=&#x3C;당신의 비밀번호>"</span>
</code></pre>
<p>다음 명령어로 확인할 수 있어요:</p>
<pre><code class="hljs language-js">kubectl get secrets -n mongo my-user-password -o jsonpath={.<span class="hljs-property">data</span>.<span class="hljs-property">password</span>} | base64 -d; echo
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>모든 쿠버네티스 시크릿은 base64로 인코드되어 있기 때문에 비밀번호를 디코딩하는 데 base64 -d를 사용하는 것을 알 수 있습니다. 우리가 --from-literal을 사용하였기 때문에 create secret 명령어에 의해 비밀번호가 자동으로 base64로 인코드되었습니다.</p>
<p>이제 비밀번호가 준비되었으니, 이 비밀번호를 사용하는 관리자 사용자가 있는 MonogoDB 클러스터와 데이터베이스를 생성할 수 있습니다.</p>
<p>매니페스트 파일을 생성해 보세요:</p>
<p>k8s/my-mongo-db.yml</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">mongodbcommunity.mongodb.com/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">MongoDBCommunity</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">my-mongo-db</span>
  <span class="hljs-attr">namespace:</span> <span class="hljs-string">mongo</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">members:</span> <span class="hljs-number">3</span>
  <span class="hljs-attr">type:</span> <span class="hljs-string">ReplicaSet</span>
  <span class="hljs-attr">version:</span> <span class="hljs-string">"7.0.11"</span>
  <span class="hljs-attr">security:</span>
    <span class="hljs-attr">authentication:</span>
      <span class="hljs-attr">modes:</span> [<span class="hljs-string">"SCRAM"</span>]
  <span class="hljs-attr">users:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">my-user</span>
      <span class="hljs-attr">db:</span> <span class="hljs-string">admin</span>
      <span class="hljs-attr">passwordSecretRef:</span> <span class="hljs-comment"># a reference to the secret that will be used to generate the user's password</span>
        <span class="hljs-attr">name:</span> <span class="hljs-string">my-user-password</span>
        <span class="hljs-attr">key:</span> <span class="hljs-string">password</span>
      <span class="hljs-attr">roles:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">clusterAdmin</span>
          <span class="hljs-attr">db:</span> <span class="hljs-string">admin</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">userAdminAnyDatabase</span>
          <span class="hljs-attr">db:</span> <span class="hljs-string">admin</span>
      <span class="hljs-attr">scramCredentialsSecretName:</span> <span class="hljs-string">my-user-scram</span>
  <span class="hljs-attr">additionalMongodConfig:</span>
    <span class="hljs-attr">storage.wiredTiger.engineConfig.journalCompressor:</span> <span class="hljs-string">zlib</span>
</code></pre>
<p>이제 다음과 같이 적용할 수 있습니다:</p>
<pre><code class="hljs language-bash">kubectl apply -f k8s/my-mongo-db.yml
</code></pre>
<p>그리고 진행 상황을 다음과 같이 확인할 수 있습니다:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js">kubectl get pods -n mongo
</code></pre>
<p>3개의 인스턴스가 생성될 때까지 기다리고 있어요. 제 MacBook Pro(M2 Max Apple 실리콘)에서 4노드 Kind 클러스터를 사용하면, 모든 3개의 인스턴스를 시작하는 데 약 5분 정도 걸렸어요.</p>
<p>시작되고 나면, 다음 명령어로 서비스가 정상적으로 작동하는지 확인할 수 있어요:</p>
<pre><code class="hljs language-js">kubectl get svc -n mongo
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이렇게 하면:</p>
<pre><code class="hljs language-js"><span class="hljs-variable constant_">NAME</span>              <span class="hljs-variable constant_">TYPE</span>        <span class="hljs-variable constant_">CLUSTER</span>-<span class="hljs-variable constant_">IP</span>   <span class="hljs-variable constant_">EXTERNAL</span>-<span class="hljs-variable constant_">IP</span>   <span class="hljs-title function_">PORT</span>(S)     <span class="hljs-variable constant_">AGE</span>
my-mongo-db-svc   <span class="hljs-title class_">ClusterIP</span>   <span class="hljs-title class_">None</span>         &#x3C;none>        <span class="hljs-number">27017</span>/<span class="hljs-variable constant_">TCP</span>   6m
</code></pre>
<h2>데이터베이스 테스트</h2>
<p>우리 애플리케이션에서는 쿠버네티스 내부에서 직접 데이터베이스에 연결할 것입니다. 데이터베이스의 서비스를 이용해 DNS 이름으로 연결하려고 하지만, 테스트 목적으로는 로컬 개발 머신에서 연결하고 싶습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>처음으로 이를 시도할 때 로컬 개발 머신으로 MonogoDB 파드 중 하나를 포워딩하기 위해 포트 포워딩을 사용했고, 어떤 변경을 시도했을 때 다음과 같은 오류 메시지를 받았습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">MongoServerError</span>[<span class="hljs-title class_">NotWriteablePrimary</span>]: not primary
</code></pre>
<p>이것은 포트 포워딩한 파드가 클러스터의 주 파드가 아니기 때문에 발생한 문제입니다. 보조 파드는 읽기 전용 복사본이기 때문에 모든 쓰기 작업은 주 파드를 통해 이루어져야 합니다.</p>
<p>이 문제를 피하려면 주 파드에 연결해야 합니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>어떤 노드가 기본 노드인지 알고 싶다면 다음 노드 중 하나의 로그를 조사하면 됩니다:</p>
<pre><code class="hljs language-js">kubectl logs my-mongo-db-<span class="hljs-number">0</span> -n mongo -c mongod | grep <span class="hljs-string">"\"primary\":"</span>
</code></pre>
<p>만약 결과가 없다면, 기본 노드에 도달한 것입니다.</p>
<p>만약 결과를 얻는다면, 몇 줄만 출력될 수 있지만, 그것들은 매우 길고 읽기 어려울 수 있습니다. JSON pretty printer 같은 것(jq와 같은)을 가지고 있다면 다음을 사용할 수 있습니다:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js">kubectl logs my-mongo-db-<span class="hljs-number">0</span> -n mongo -c mongod | grep <span class="hljs-string">"\"primary\":"</span> | jq
</code></pre>
<p>그러면 다음과 같은 줄을 볼 수 있습니다:</p>
<pre><code class="hljs language-js">...
<span class="hljs-string">"primary"</span>: <span class="hljs-string">"my-mongo-db-1.my-mongo-db-svc.mongo.svc.cluster.local:27017"</span>,
...
</code></pre>
<p>여기에 연결해야 하는 pod의 이름이 나옵니다 (제 경우: my-mongo-db-1). 이제 해당 pod를 포트 포워드할 수 있습니다:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js">kubectl port-forward my-mongo-db-<span class="hljs-number">1</span> -n mongo <span class="hljs-number">27017</span>:<span class="hljs-number">27017</span>
</code></pre>
<p>이 포트 포워딩이 설정되면 데이터베이스에 연결해야 합니다. MongoDB Compass 클라이언트를 사용할 수 있습니다. 해당 클라이언트는 <a href="https://www.mongodb.com/try/download/compass" rel="nofollow" target="_blank">https://www.mongodb.com/try/download/compass</a> 에서 다운로드할 수 있습니다.</p>
<p>설치 후 데이터베이스에 연결할 수 있어야 합니다. 연결 문자열(mongodb://localhost:27017)이 제안됩니다만, 몇 가지 설정을 변경해야합니다.</p>
<p>고급 연결 옵션을 클릭하고 직접 연결을 클릭하십시오 (이 설정을 변경하지 않으면 내부 쿠버네티스 주소를 사용하려고 시도하여 찾을 수 없는 주소가 발생합니다).</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>인증 탭을 클릭해주세요. 사용자 이름/비밀번호를 선택하고 이전에 선택한 사용자 이름(my-user)과 비밀번호를 입력해주세요. Admin을 데이터베이스로 추가하고 SCRAM-SHA-256 인증 메커니즘을 선택해주세요 (필요하다면 아래로 스크롤).</p>
<p>저장 및 연결을 클릭하고 연결 이름을 지정한 후, 데이터베이스에 연결된 Compass 콘솔이 표시됩니다.</p>
<p>클러스터 내에서 admin, config 및 local 데이터베이스가 생성된 것을 확인하실 수 있습니다.</p>
<p>여기까지 오셨다면, MongoDB 클러스터가 정상적으로 실행 중임을 의미합니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>애플리케이션 사용자 생성</h1>
<p>우리의 MongoDB에 연결할 모든 애플리케이션이 우리가 생성한 my-user를 사용할 수 있을 것이라고 생각할 수 있습니다. 하지만, 이 사용자는 실제로 데이터베이스 유지 관리를 위한 것이기 때문에 그렇지 않습니다.</p>
<p>애플리케이션이 데이터베이스 클러스터를 사용할 수 있도록하려면 데이터베이스와 해당 데이터에 액세스할 사용자를 생성해야 합니다.</p>
<p>Compass 창의 맨 아래에 <code>_MONGOSH</code> 프롬프트가 나타납니다. 이를 클릭하여 명령줄에 액세스할 수 있습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이제 다음과 같이 사용자를 생성할 것입니다:</p>
<pre><code class="hljs language-js">use aquarium
db.<span class="hljs-title function_">createUser</span>( { <span class="hljs-attr">user</span>: <span class="hljs-string">"my-app-user"</span>,
              <span class="hljs-attr">pwd</span>: <span class="hljs-string">"&#x3C;password>"</span>,
              <span class="hljs-attr">roles</span>: [ {<span class="hljs-attr">db</span>: <span class="hljs-string">"aquarium"</span>, <span class="hljs-attr">role</span>: <span class="hljs-string">"dbOwner"</span>} ] } )
</code></pre>
<p>알아둬야 할 몇 가지 사항이 있습니다. 첫번째로, 생성되기 전에 존재하지 않는 데이터베이스(aquarium)로 전환합니다. 이는 사용하기 전에 아무 것도 정의할 필요가 없다는 원칙에 부합합니다. 데이터베이스 및 모든 컬렉션은 문서를 추가할 때 처음 생성됩니다.</p>
<p>두번째는 새 데이터베이스에 할당된 역할입니다. MongoDB에는 사용자에게 부여할 수 있는 소수의 기본 역할이 있습니다. 이 경우 dbOwner 역할은 사용자가 데이터베이스를 읽고 쓰고 관리할 수 있도록 합니다. 실제 운영에서는 사용자 권한을 적절히 제한해야 합니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js">...
<span class="hljs-attr">ok</span>: <span class="hljs-number">1</span>,
...
</code></pre>
<p>사용자를 확인하기 위해 새 Compass 연결을 열어보세요. 이는 메뉴를 통해 할 수 있습니다. 혹은 MacOS에서는 Cmd N을 누르세요. 창이 열릴 때까지 몇 초가 걸릴 수 있는데, 아무런 표시가 없으므로 한 번만 누르세요!</p>
<p>새 연결 창이 나타나면, 이전에 저장한 연결을 복제하는 것이 더 쉽다고 생각합니다(연결 옆의 ... 메뉴를 사용하세요).</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>사용자 이름과 비밀번호를 변경해주세요. 또한 Authentication Database를 aquarium으로 변경해주세요. 그런 다음 연결하세요.</p>
<p>이제 새로운 aquarium 데이터베이스를 확인할 수 있어야 합니다. "fishes"라는 collection을 생성해보면서 테스트해 볼 수 있습니다. 데이터베이스에 문서 형태로 데이터를 추가할 수 있습니다.</p>
<pre><code class="hljs language-js">{
  <span class="hljs-string">"_id"</span>: <span class="hljs-number">123</span>,
  <span class="hljs-string">"fish"</span>: <span class="hljs-string">"Guppy"</span>
}
</code></pre>
<p>이 시점에서 Spring Boot 애플리케이션과 함께 사용할 준비가 된 MongoDB가 준비되었습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>스프링 부트 애플리케이션 만들기</h1>
<p>간단한 데이터베이스 지원 예제를 만들 때는 제가 제일 먼저 수족관 애플리케이션을 사용합니다. REST API를 사용하여 물고기와 수족관을 만들고 관리할 수 있습니다. 그런 다음 물고기를 여러분의 수족관 중 하나에 추가할 수 있습니다.</p>
<h2>코드</h2>
<p>저는 코드를 여기에 포함하려는 의도는 없지만 관련된 GitHub 저장소에서 확인할 수 있습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>종속성</h2>
<p>Spring Boot 애플리케이션을 시작하는 것은 항상 <a href="https://start.spring.io/%EC%97%90%EC%84%9C" rel="nofollow" target="_blank">https://start.spring.io/에서</a> Spring Initializr를 사용하는 것이 더 쉽습니다. 사용 방법을 알고 있다고 가정합니다.</p>
<p>이 프로젝트에서 Spring Web과 Spring Data MongoDB를 종속성으로 추가하고 프로젝트를 생성합니다.</p>
<h2>패키지 구조</h2>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>내가 만드는 애플리케이션에 따라, 패키지 구조를 구성하는 데 컴포넌트 유형(예: 컨트롤러, 서비스 및 리포지토리)에 기반을 둘 수도 있고, 비즈니스 도메인에 기반을 둘 수도 있습니다.</p>
<p>물고기와 수조 두 가지 비즈니스 도메인만 있는 작은 애플리케이션인 경우, 이 프로젝트를 이러한 도메인을 기반으로 해서 다음과 같이 만들 것입니다:</p>
<pre><code class="hljs language-js">fishes;
<span class="hljs-title class_">FishController</span>;
<span class="hljs-title class_">FishService</span>;
<span class="hljs-title class_">FishRepository</span>;
fishtanks;
<span class="hljs-title class_">FishTankController</span>;
<span class="hljs-title class_">FishTankService</span>;
<span class="hljs-title class_">FishTankRepository</span>;
</code></pre>
<p>보시다시피, 컨트롤러, 서비스 및 리포지토리 레이어를 사용하여 표준 계층 구조를 따르고 있습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>API 엔드포인트</h2>
<p>이 컨트롤러들은 각각의 API에 대해 생성, 조회, 업데이트 및 삭제 (CRUD) 엔드포인트를 제공합니다.</p>
<h2>엔티티 및 문서</h2>
<p>만약 JPA와 Postgres와 같은 SQL 데이터베이스에 익숙하다면, 엔티티와 리포지토리로 익숙할 것입니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>No-SQL 데이터베이스에서는 테이블이 컬렉션으로 대체되고, 테이블 내의 행은 문서로 대체됩니다.</p>
<p>이는 No-SQL 데이터베이스를 위한 리포지토리가 SQL 데이터베이스와는 조금 다르다는 것을 의미합니다.</p>
<p>No-SQL 데이터베이스는 어떤 구조든 다룰 수 있기 때문에, 엔티티(또는 문서)는 간단한 Plain Old Java Objects (POJOs)가 됩니다. 이는 우리 예시 애플리케이션에서 다음과 같이 엔티티를 생성할 수 있다는 것을 의미합니다:</p>
<p>aquarium/fishes/Fish.java</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js">...

@<span class="hljs-title class_">Setter</span>
@<span class="hljs-title class_">Getter</span>
@<span class="hljs-title class_">Document</span>(<span class="hljs-string">"fishes"</span>)
@<span class="hljs-title class_">NoArgsConstructor</span>
public <span class="hljs-keyword">class</span> <span class="hljs-title class_">Fish</span> {

  @<span class="hljs-title class_">Id</span>
  public <span class="hljs-variable constant_">UUID</span> id;

  public <span class="hljs-title class_">String</span> type;

  public <span class="hljs-title class_">Fish</span>(<span class="hljs-title class_">String</span> type) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span> = <span class="hljs-variable constant_">UUID</span>.<span class="hljs-title function_">randomUUID</span>();
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">type</span> = type;
  }
  ...
}
</code></pre>
<p>친구야, 여기 몇 가지 주의할 점이 있어요:</p>
<ul>
<li>@Entity를 정의하는 대신 컬렉션의 이름을 사용하는 @Document를 정의하고 있어요.</li>
<li>자체 UUID Id를 관리할 수 있도록 @mongoId 대신에 (필수는 아니지만 MongoDB가 제공하지 않은 경우 MongoDB로 제공할 수 있기 때문에) @Id를 사용하고 있어요.</li>
<li>Lombok(예: @Getter)을 사용하여 보일러플레이트 코드 일부를 제거하는 것을 좋아해요.</li>
</ul>
<p>이제 비슷한 방식으로 물고기 수조를 만들 수 있어요:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>수족관/fishtanks/FishTank.java</p>
<pre><code class="hljs language-java"><span class="hljs-meta">@Setter</span>
<span class="hljs-meta">@Getter</span>
<span class="hljs-meta">@Document("fish tanks")</span>
<span class="hljs-meta">@NoArgsConstructor</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FishTank</span> {

    <span class="hljs-meta">@Id</span>
    <span class="hljs-keyword">public</span> UUID id;

    <span class="hljs-keyword">public</span> String name;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">FishTank</span><span class="hljs-params">(String name)</span> {
        <span class="hljs-built_in">this</span>.id = UUID.randomUUID();
        <span class="hljs-built_in">this</span>.name = name;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> String.format(
                <span class="hljs-string">"FishTank[id=%s, type='%s']"</span>,
                id.toString(), name);
    }
}
</code></pre>
<h2>Repositories</h2>
<p>자, 이제 우리의 문서들이 준비되었어요. 이제 이들에 어떻게 접근할까요?</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>제가 보여드릴 것은 우리 저장소의 변경 사항입니다. 물고기 저장소를 예로 들어보겠습니다:</p>
<pre><code class="hljs language-js">...
public interface <span class="hljs-title class_">FishRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">MongoRepository</span>&#x3C;<span class="hljs-title class_">Fish</span>, <span class="hljs-variable constant_">UUID</span>> {

    public <span class="hljs-title class_">List</span>&#x3C;<span class="hljs-title class_">Fish</span>> <span class="hljs-title function_">findAll</span>();

    public <span class="hljs-title class_">Optional</span>&#x3C;<span class="hljs-title class_">Fish</span>> <span class="hljs-title function_">findFirstById</span>(<span class="hljs-variable constant_">UUID</span> id);

    public <span class="hljs-title class_">Optional</span>&#x3C;<span class="hljs-title class_">Fish</span>> <span class="hljs-title function_">findFirstByType</span>(<span class="hljs-title class_">String</span> type);
}
...
</code></pre>
<p>이것이 SQL 데이터베이스에서 찾을 수 있는 Repository 유형과 거의 동일하다는 것을 알 수 있습니다. 유일한 차이점은 인터페이스가 CrudRepository가 아닌 MongoRespository를 확장한다는 것뿐입니다.</p>
<p>한 대 다 및 다른 매핑 주제는 다른 기사로 미루겠습니다. 그래서 현재로서는 물고기와 어항을 생성하고 관리할 수 있을 것입니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>어플리케이션 속성</h2>
<p>데이터베이스와 작업할 때는 어플리케이션이 어떻게 연결해야 하는지를 알려줘야 합니다. 우리는 SQL 데이터베이스와 마찬가지로 어플리케이션 속성을 통해 이를 수행합니다.</p>
<p>나는 Spring Boot 속성 파일에 YAML 파일을 사용하는 것을 선호하며, 내 구성은 다음과 같이 보입니다 (나의 값으로 <code> </code> 필드를 교체해주시기 바랍니다):</p>
<p>resources/application.yml</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">application:</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">aquarium-with-mongo-db</span>

  <span class="hljs-attr">data:</span>
    <span class="hljs-attr">mongodb:</span>
      <span class="hljs-attr">host:</span> <span class="hljs-string">localhost</span>
      <span class="hljs-attr">port:</span> <span class="hljs-number">27017</span>
      <span class="hljs-attr">database:</span> <span class="hljs-string">aquarium</span>
      <span class="hljs-attr">username:</span> <span class="hljs-string">my-app-user</span>
      <span class="hljs-attr">password:</span> <span class="hljs-string">&#x3C;password></span>
</code></pre>
<p>나중에 프로필에 대해 이야기할 때 다시 돌아올게요.</p>
<h2>컨트롤러 및 서비스</h2>
<p>이제 SQL 데이터베이스와 마찬가지로 컨트롤러와 서비스를 추가할 수 있습니다. GitHub 저장소에서 이용 가능하므로 별도로 제시하지 않겠습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>애플리케이션 테스트</h2>
<p>코드를 완성하거나(또는 제 저장소를 복제)하여 IDE 내에서 애플리케이션을 실행하십시오. 여전히 주 서버로 포트 포워딩 중인 경우, 애플리케이션이 시작되어야 합니다.</p>
<p>그런 다음 다음 curl 명령을 사용하여 테스트할 수 있습니다:</p>
<pre><code class="hljs language-js">curl <span class="hljs-attr">localhost</span>:<span class="hljs-number">8080</span>/api/v1/fishes -H <span class="hljs-string">"Content-Type: application/json"</span> -d <span class="hljs-string">'{"type": "guppy2"}'</span>
curl <span class="hljs-attr">localhost</span>:<span class="hljs-number">8080</span>/api/v1/fish-tanks -H <span class="hljs-string">"Content-Type: application/json"</span> -d <span class="hljs-string">'{"name": "big one"}'</span>
curl <span class="hljs-attr">localhost</span>:<span class="hljs-number">8080</span>/api/v1/fishes
curl <span class="hljs-attr">localhost</span>:<span class="hljs-number">8080</span>/api/v1/fish-tanks
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이제 컴퍼스 클라이언트로 이동하여 아쿠아리움 데이터베이스를 새로 고침하면 fishes 및 fish tanks 두 개의 컬렉션이 표시됩니다. 이러한 컬렉션 내에는 만든 fishes 및 fish tanks가 표시됩니다.</p>
<h1>최종 단계</h1>
<p>이 시점에서 저희는 쿠버네티스 클러스터에서 실행 중인 MongoDB에 연결된 Spring Boot 애플리케이션을 갖추었습니다. 이제 해야 할 마지막 단계, 즉 Spring Boot 애플리케이션을 쿠버네티스 클러스터에 로드하는 것이 남았습니다.</p>
<p>이를 위해 다음을 수행해야 합니다:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>팻 JAR 파일을 생성합니다 (모든 종속성이 포함됨)</li>
<li>해당 JAR에서 Docker 이미지를 생성합니다</li>
<li>이미지를 Docker 저장소에 업로드합니다</li>
<li>배포 매니페스트 파일을 생성합니다</li>
<li>배포 매니페스트를 Kubernetes 클러스터에 적용합니다</li>
</ul>
<p>제가 Kind를 사용하고 있기 때문에, 3단계를 간단한 로드 단계로 대체할 수 있습니다. 이렇게 하면 Docker 저장소를 사용할 필요가 없습니다.</p>
<h2>프로필</h2>
<p>JAR 파일을 생성하기 전에 Spring Boot 프로필 두 개를 생성하는 것이 유용합니다. 이를 통해 애플리케이션을 연결된 모드 (지금까지 한 것처럼) 및 Kubernetes 클러스터 내에서 실행할 수 있습니다. Spring Boot 프로필 두 개를 생성하겠습니다:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li><code>connected</code> ... 클러스터 외부에서 실행 중일 때 사용되는 모드</li>
<li><code>local-cluster</code> ... 클러스터 내부에서 실행 중일 때 사용되는 모드</li>
</ul>
<p>현재 실행 중인 모드는 첫 번째입니다. 이는 우리가 간단히 application.yml(또는 application.properties) 파일을 application-connected.yml로 복사할 수 있다는 것을 의미합니다. 그런 다음 JVM 명령줄에 다음 JVM 인수를 추가할 수 있습니다:</p>
<pre><code class="hljs language-js">-<span class="hljs-title class_">Dspring</span>.<span class="hljs-property">profiles</span>.<span class="hljs-property">active</span>=connected
</code></pre>
<p>로컬 클러스터 파일에 대해서도 동일한 작업을 수행하지만 이번에는 변경이 필요합니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js">...
  <span class="hljs-attr">data</span>:
    <span class="hljs-attr">mongodb</span>:
      <span class="hljs-attr">host</span>: my-mongo-db-svc.<span class="hljs-property">mongo</span>.<span class="hljs-property">svc</span>.<span class="hljs-property">cluster</span>.<span class="hljs-property">local</span>
      <span class="hljs-attr">port</span>: <span class="hljs-number">27017</span>
...
</code></pre>
<p>DNS 이름을 사용하여 올바른 팟에 연결할 수 있습니다. 팟에서 DNS 검색 규칙이 설정되어 있어 my-mongo-db-svc.mongo.svc와 같은 이름 일부를 생략할 수 있습니다. 이를 통해 다른 클러스터로 배포하고도 응용 프로그램이 작동할 수 있습니다.</p>
<h2>이미지 생성</h2>
<p>이제 이미지를 만드는 방법을 살펴보겠습니다. GitHub에 있는 프로젝트가 Gradle 프로젝트이므로 루트 프로젝트 폴더에서 다음과 같이 JAR 파일을 생성할 수 있습니다:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js">gradle build
</code></pre>
<p>gradle.build에 아래 내용이 추가되었음을 유의해주세요. 이는 manifest가 주 애플리케이션 파일을 가리키도록 합니다:</p>
<p>gradle.build</p>
<pre><code class="hljs language-js">jar {
    manifest {
        attributes <span class="hljs-string">"Main-Class"</span>: <span class="hljs-string">"com.requillion_solutions.aquarium.AquariumWithMongoDbApplication"</span>
    }
}
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이렇게 하면 jar 파일이 생성됩니다: build/libs/aquarium-with-mongo-db-0.0.1-SNAPSHOT.jar.</p>
<p>도커 이미지를 만들기 위해서는 도커 파일이 필요합니다. 아래 내용대로 만들어보세요:</p>
<p>Dockerfile</p>
<pre><code class="hljs language-js"><span class="hljs-variable constant_">FROM</span> <span class="hljs-attr">openjdk</span>:<span class="hljs-number">17.0</span><span class="hljs-number">.2</span>-slim-buster
<span class="hljs-variable constant_">RUN</span> addgroup --system spring &#x26;&#x26; useradd --system spring -g spring
<span class="hljs-variable constant_">USER</span> <span class="hljs-attr">spring</span>:spring
<span class="hljs-variable constant_">ARG</span> <span class="hljs-variable constant_">JAR_FILE</span>=build/libs<span class="hljs-comment">/*.jar
COPY ${JAR_FILE} app.jar
ENTRYPOINT ["java","-jar","/app.jar"]
EXPOSE 8080
</span></code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이는 Java 17 기반 이미지를 시작으로 합니다 (이것은 롬복과의 문제를 피하기 위해 필요합니다) 그리고 새 사용자 (spring)를 추가하여 루트로 실행하지 않도록 합니다. 그런 다음 JAR 파일이 이미지로 복사되고 응용 프로그램을 실행하는 엔트리포인트가 생성됩니다.</p>
<p>다음 명령어로 도커 이미지를 생성하세요:</p>
<pre><code class="hljs language-bash">docker build -t aquarium .
</code></pre>
<p>그리고 만약 Kind를 사용 중이라면, 다음 명령어로 직접 Kubernetes 클러스터에 로드하세요:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js">kind load docker-image aquarium
</code></pre>
<p>이 작업이 완료되면 클러스터에서 실행하기 위한 배포 매니페스트를 생성할 준비가 되었습니다.</p>
<h2>배포 매니페스트</h2>
<p>이제 쿠버네티스 클러스터에 도커 이미지를 로드했으므로 배포 매니페스트를 사용하여 배포할 수 있습니다. 다음 파일을 만들어주세요:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>k8s/deployment.yml</p>
<pre><code class="hljs language-yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">aquarium</span>
  <span class="hljs-attr">namespace:</span> <span class="hljs-string">default</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span>
  <span class="hljs-attr">selector:</span>
    <span class="hljs-attr">matchLabels:</span>
      <span class="hljs-attr">app:</span> <span class="hljs-string">aquarium</span>
  <span class="hljs-attr">template:</span>
    <span class="hljs-attr">metadata:</span>
      <span class="hljs-attr">labels:</span>
        <span class="hljs-attr">app:</span> <span class="hljs-string">aquarium</span>
    <span class="hljs-attr">spec:</span>
      <span class="hljs-attr">containers:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">aquarium</span>
          <span class="hljs-attr">image:</span> <span class="hljs-string">aquarium</span>
          <span class="hljs-attr">imagePullPolicy:</span> <span class="hljs-string">IfNotPresent</span>
          <span class="hljs-attr">ports:</span>
            <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">8080</span>
          <span class="hljs-attr">env:</span>
            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">SPRING_PROFILES_ACTIVE</span>
              <span class="hljs-attr">value:</span> <span class="hljs-string">local-cluster</span>
<span class="hljs-meta">---</span>
<span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">aquarium</span>
  <span class="hljs-attr">namespace:</span> <span class="hljs-string">default</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">selector:</span>
    <span class="hljs-attr">app:</span> <span class="hljs-string">aquarium</span>
  <span class="hljs-attr">type:</span> <span class="hljs-string">NodePort</span>
  <span class="hljs-attr">ports:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span>
      <span class="hljs-attr">targetPort:</span> <span class="hljs-number">8080</span>
      <span class="hljs-attr">nodePort:</span> <span class="hljs-number">30080</span>
</code></pre>
<p>알아두어야 할 사항이 몇 가지 있어요:</p>
<ul>
<li>어플리케이션이 default 네임스페이스에 배포되었어요 (네임스페이스가 지정되지 않으면 사용되는 곳이죠)</li>
<li>레플리카는 1개뿐이에요</li>
<li>이미지는 이전에 불러왔으므로, 이미지가 없을 때만 불러와요</li>
<li>프로필은 local-cluster로 설정돼요</li>
<li>서비스가 생성되어 어플리케이션의 포트 8080을 개발 머신의 포트 30080으로 매핑돼요</li>
</ul>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이제 다음과 같이 배포할 수 있습니다:</p>
<pre><code class="hljs language-js">kubectl apply -f k8s/deployment.<span class="hljs-property">yml</span>
</code></pre>
<p>시작이 성공적으로 이루어졌는지 확인해보세요:</p>
<pre><code class="hljs language-js">kubectl get pods
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>한 번이 배포되면 API는 이전에 사용한 것과 동일한 curl 명령으로 테스트할 수 있습니다. 단, 포트를 30080으로 변경해 주세요.</p>
<pre><code class="hljs language-js">curl <span class="hljs-attr">localhost</span>:<span class="hljs-number">30080</span>/api/v1/fishes -H <span class="hljs-string">"Content-Type: application/json"</span> -d <span class="hljs-string">'{"type": "guppy2"}'</span>
curl <span class="hljs-attr">localhost</span>:<span class="hljs-number">30080</span>/api/v1/fish-tanks -H <span class="hljs-string">"Content-Type: application/json"</span> -d <span class="hljs-string">'{"name": "big one"}'</span>
curl <span class="hljs-attr">localhost</span>:<span class="hljs-number">30080</span>/api/v1/fishes
curl <span class="hljs-attr">localhost</span>:<span class="hljs-number">30080</span>/api/v1/fish-tanks
</code></pre>
<p>Compass UI에서 새 문서를 확인할 수도 있습니다 (포트 포워드가 여전히 유지되는지 확인해 주세요).</p>
<h1>요약</h1>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이 기사는 Kind Kubernetes 클러스터로 MongoDB를 설치하고 Spring Boot 애플리케이션과 통합하는 과정에 대해 다루었습니다.</p>
<p>이 연습은 꽤 간단하지만 그냥 어떻게 하는지 보여주는 것뿐입니다. 실제로는 보안, 백업 및 장애 조치에 작업이 필요할 것입니다.</p>
<p>다른 기사에서는 문서간의 관계를 어떻게 관리할 수 있는지도 보여드릴 예정입니다.</p>
<p>이 연습을 통해 No-SQL 데이터베이스가 Kubernetes와 Spring Boot와 간단하게 사용될 수 있다는 것을 보여줬으면 좋겠습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이 글을 즐겁게 읽으셨기를 바라며, 새로운 것을 배우며 기술을 향상시켰기를 바랍니다. 작은 거라도 새로운 지식을 얻었다면 좋겠네요.</p>
<p>이 글이 유익하게 느껴진다면, 박수 한 번 부탁드립니다. 그렇게 하면 미래에 어떤 글을 써야 하는지 파악할 수 있고, 다음 글을 결정하는 데 도움이 됩니다. 개선 사항이나 제안 사항이 있다면 메모나 답글로 추가해 주세요.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"나의 쿠버네티스 클러스터에 MongoDB No-SQL 데이터베이스를 추가한 경험","description":"","date":"2024-06-19 13:00","slug":"2024-06-19-MyexperienceaddingaMongoDBNo-SQLdatabasetomyKubernetescluster","content":"\n## SQL과 No-SQL 데이터베이스 사이를 선택하는 방법에 대해 읽었다면, Kubernetes 클러스터에 No-SQL MongoDB 데이터베이스를 추가할 수 있는지 궁금할 것입니다. 이 글에서는 그것을 어떻게 수행했는지 설명하고 Spring Boot 애플리케이션과 함께 사용하는 방법에 대해 알려드리겠습니다.\n\n![이미지](/assets/img/2024-06-19-MyexperienceaddingaMongoDBNo-SQLdatabasetomyKubernetescluster_0.png)\n\n# 시작하기\n\n일반적으로 Kubernetes 서비스를 개발할 때는, 개발을 위해 로컬 Kind Kubernetes 클러스터에서 시작합니다. Kind를 설정하는 방법에 대해 이전에 썼었고, 이 글에 관련된 GitHub 저장소에는 이를 수행하는 데 필요한 구성 파일이 포함되어 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n클론하기 위해 저장소를 다음과 같이 복제할 수 있어요:\n\n```js\ngit clone git@github.com:MartinHodges/aquarium-with-mongo-db.git\n```\n\n# 왜 MongoDB를 사용해야 하나요?\n\n이전 기사에서 SQL 대 No-SQL 결정에 대해 다뤄 보았어요. 여러분이 이 글을 읽고 계신다면 No-SQL을 선택하겠다고 결정하신 거겠죠.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n일단 그 결정이 내렸다면, 이제 No-SQL 데이터베이스를 어떤 것을 선택할지가 문제가 됩니다. MongoDB는 가장 가까운 경쟁상대보다 2배 더 높은 시장 점유율을 보유하고 있습니다. 그것은 매우 정교하며 커뮤니티 버전과 엔터프라이즈 버전 둘 다 가지고 있습니다. 전형적으로 가장 많이 사용되는 No-SQL 데이터베이스입니다.\n\n다른 데이터베이스와의 기술적인 비교는 이 기사의 범위를 벗어나지만, MongoDB가 인기 있는 이유와 일하도록 충분히 할 수 있는 사실에 기반하여 이 기사에서는 MongoDB를 선택했습니다!\n\n# MongoDB 설치\n\nKubernetes 클러스터에 MongoDB를 설치하는 방법은 다른 응용프로그램과 유사하게 operator를 사용하여 수행됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-MyexperienceaddingaMongoDBNo-SQLdatabasetomyKubernetescluster_1.png\" /\u003e\n\n쿠버네티스 오퍼레이터는 당신을 대신하여 응용 프로그램을 관리합니다. 응용 프로그램의 라이프사이클을 설치하고 관리하며 모니터링하고 필요한 조치를 취할 수 있습니다.\n\n데이터베이스의 경우 데이터베이스 클러스터를 생성하거나 확장하거나 백업하는 등의 작업을 수행할 수 있습니다. 일반적으로 오퍼레이터는 그 자체의 '쿠버네티스 구성 언어'를 제공하는 사용자 정의 리소스 정의 (CRD)를 설치하기에 의존합니다. 이는 클러스터에 사용자 정의 리소스를 추가하기 위한 요청을 감지하고 당신을 대신하여 작동합니다.\n\n## 개발용 쿠버네티스 클러스터 생성\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nKind를 설치했다고 가정하면, 다음 구성을 사용하여 Kind 클러스터를 만들 수 있습니다:\n\nkind/kind-config.yml\n\n```js\napiVersion: kind.x-k8s.io/v1alpha4\nkind: Cluster\nnodes:\n- role: control-plane\n  extraPortMappings:\n  # apis\n  - containerPort: 30080\n    hostPort: 30080\n- role: worker\n- role: worker\n- role: worker\n```\n\n이렇게 하면 1개의 컨트롤러 및 3개의 워커로 구성된 4개 노드 클러스터가 생성됩니다. 또한 개발 머신의 포트 30080을 사용할 수 있습니다. 이를 사용하여 로컬 Kubernetes 클러스터를 생성할 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```shell\nkind create cluster --config kind/kind-config.yml\n```\n\n## 오퍼레이터 설치\n\nHelm을 사용하여 커뮤니티 지원 오퍼레이터를 설치할 수 있습니다.\n\n먼저 다음과 같이 로컬 리포지토리에 Helm 링크를 추가하세요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nhelm repo add mongodb https://mongodb.github.io/helm-charts\n```\n\n아래 명령어로 이 리포지토리가 추가한 차트를 확인할 수 있어요:\n\n```js\nhelm search repo mongo\n```\n\n리스트에서 커뮤니티 오퍼레이터를 확인할 수 있을 거에요. 이것을 사용할 거에요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n저희는 오퍼레이터와 데이터베이스를 별도의 네임스페이스로 mongo라는 이름으로 분리해서 배치할 겁니다. 다음과 같이 생성해보겠습니다:\n\n```js\nkubectl create namespace mongo\n```\n\n이제 다음 명령으로 오퍼레이터를 설치할 수 있어요:\n\n```js\nhelm install community-operator mongodb/community-operator -n mongo\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음 명령어를 사용하여 준비 상태가 1/1로 Running인지 확인할 수 있어요:\n\n```sh\nkubectl get pods -n mongo\n```\n\n이제 운영자가 작동 중인 것을 볼 수 있습니다. 설치된 CRD는 다음을 통해 확인할 수 있어요:\n\n```sh\nkubectl get crds\nkubectl describe crd mongodbcommunity.mongodbcommunity.mongodb.com\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 MongoDB 클러스터를 생성할 준비가 되었습니다.\n\n## 클러스터 생성\n\n오퍼레이터가 설치되었으므로 MongoDB 데이터베이스를 생성하는 요청을 대기 중입니다. 우리는 오퍼레이터에 의해 로드된 CRD를 사용하여 쿠버네티스 클러스터에 MongoDB 매니페스트를 적용하여 요청을 할 수 있습니다.\n\n이를 하기 전에 데이터베이스 사용자의 비밀번호를 쿠버네티스 시크릿으로 설정해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음과 같이 비밀을 생성하세요 (‘…’를 선택한 비밀번호로 교체하세요):\n\n```js\nkubectl create secret generic my-user-password -n mongo --from-literal=\"password=\u003c당신의 비밀번호\u003e\"\n```\n\n다음 명령어로 확인할 수 있어요:\n\n```js\nkubectl get secrets -n mongo my-user-password -o jsonpath={.data.password} | base64 -d; echo\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n모든 쿠버네티스 시크릿은 base64로 인코드되어 있기 때문에 비밀번호를 디코딩하는 데 base64 -d를 사용하는 것을 알 수 있습니다. 우리가 --from-literal을 사용하였기 때문에 create secret 명령어에 의해 비밀번호가 자동으로 base64로 인코드되었습니다.\n\n이제 비밀번호가 준비되었으니, 이 비밀번호를 사용하는 관리자 사용자가 있는 MonogoDB 클러스터와 데이터베이스를 생성할 수 있습니다.\n\n매니페스트 파일을 생성해 보세요:\n\nk8s/my-mongo-db.yml\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```yaml\napiVersion: mongodbcommunity.mongodb.com/v1\nkind: MongoDBCommunity\nmetadata:\n  name: my-mongo-db\n  namespace: mongo\nspec:\n  members: 3\n  type: ReplicaSet\n  version: \"7.0.11\"\n  security:\n    authentication:\n      modes: [\"SCRAM\"]\n  users:\n    - name: my-user\n      db: admin\n      passwordSecretRef: # a reference to the secret that will be used to generate the user's password\n        name: my-user-password\n        key: password\n      roles:\n        - name: clusterAdmin\n          db: admin\n        - name: userAdminAnyDatabase\n          db: admin\n      scramCredentialsSecretName: my-user-scram\n  additionalMongodConfig:\n    storage.wiredTiger.engineConfig.journalCompressor: zlib\n```\n\n이제 다음과 같이 적용할 수 있습니다:\n\n```bash\nkubectl apply -f k8s/my-mongo-db.yml\n```\n\n그리고 진행 상황을 다음과 같이 확인할 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nkubectl get pods -n mongo\n```\n\n3개의 인스턴스가 생성될 때까지 기다리고 있어요. 제 MacBook Pro(M2 Max Apple 실리콘)에서 4노드 Kind 클러스터를 사용하면, 모든 3개의 인스턴스를 시작하는 데 약 5분 정도 걸렸어요.\n\n시작되고 나면, 다음 명령어로 서비스가 정상적으로 작동하는지 확인할 수 있어요:\n\n```js\nkubectl get svc -n mongo\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이렇게 하면:\n\n```js\nNAME              TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)     AGE\nmy-mongo-db-svc   ClusterIP   None         \u003cnone\u003e        27017/TCP   6m\n```\n\n## 데이터베이스 테스트\n\n우리 애플리케이션에서는 쿠버네티스 내부에서 직접 데이터베이스에 연결할 것입니다. 데이터베이스의 서비스를 이용해 DNS 이름으로 연결하려고 하지만, 테스트 목적으로는 로컬 개발 머신에서 연결하고 싶습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n처음으로 이를 시도할 때 로컬 개발 머신으로 MonogoDB 파드 중 하나를 포워딩하기 위해 포트 포워딩을 사용했고, 어떤 변경을 시도했을 때 다음과 같은 오류 메시지를 받았습니다:\n\n```js\nMongoServerError[NotWriteablePrimary]: not primary\n```\n\n이것은 포트 포워딩한 파드가 클러스터의 주 파드가 아니기 때문에 발생한 문제입니다. 보조 파드는 읽기 전용 복사본이기 때문에 모든 쓰기 작업은 주 파드를 통해 이루어져야 합니다.\n\n이 문제를 피하려면 주 파드에 연결해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n어떤 노드가 기본 노드인지 알고 싶다면 다음 노드 중 하나의 로그를 조사하면 됩니다:\n\n```js\nkubectl logs my-mongo-db-0 -n mongo -c mongod | grep \"\\\"primary\\\":\"\n```\n\n만약 결과가 없다면, 기본 노드에 도달한 것입니다.\n\n만약 결과를 얻는다면, 몇 줄만 출력될 수 있지만, 그것들은 매우 길고 읽기 어려울 수 있습니다. JSON pretty printer 같은 것(jq와 같은)을 가지고 있다면 다음을 사용할 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nkubectl logs my-mongo-db-0 -n mongo -c mongod | grep \"\\\"primary\\\":\" | jq\n```\n\n그러면 다음과 같은 줄을 볼 수 있습니다:\n\n```js\n...\n\"primary\": \"my-mongo-db-1.my-mongo-db-svc.mongo.svc.cluster.local:27017\",\n...\n```\n\n여기에 연결해야 하는 pod의 이름이 나옵니다 (제 경우: my-mongo-db-1). 이제 해당 pod를 포트 포워드할 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nkubectl port-forward my-mongo-db-1 -n mongo 27017:27017\n```\n\n이 포트 포워딩이 설정되면 데이터베이스에 연결해야 합니다. MongoDB Compass 클라이언트를 사용할 수 있습니다. 해당 클라이언트는 https://www.mongodb.com/try/download/compass 에서 다운로드할 수 있습니다.\n\n설치 후 데이터베이스에 연결할 수 있어야 합니다. 연결 문자열(mongodb://localhost:27017)이 제안됩니다만, 몇 가지 설정을 변경해야합니다.\n\n고급 연결 옵션을 클릭하고 직접 연결을 클릭하십시오 (이 설정을 변경하지 않으면 내부 쿠버네티스 주소를 사용하려고 시도하여 찾을 수 없는 주소가 발생합니다).\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n인증 탭을 클릭해주세요. 사용자 이름/비밀번호를 선택하고 이전에 선택한 사용자 이름(my-user)과 비밀번호를 입력해주세요. Admin을 데이터베이스로 추가하고 SCRAM-SHA-256 인증 메커니즘을 선택해주세요 (필요하다면 아래로 스크롤).\n\n저장 및 연결을 클릭하고 연결 이름을 지정한 후, 데이터베이스에 연결된 Compass 콘솔이 표시됩니다.\n\n클러스터 내에서 admin, config 및 local 데이터베이스가 생성된 것을 확인하실 수 있습니다.\n\n여기까지 오셨다면, MongoDB 클러스터가 정상적으로 실행 중임을 의미합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 애플리케이션 사용자 생성\n\n우리의 MongoDB에 연결할 모든 애플리케이션이 우리가 생성한 my-user를 사용할 수 있을 것이라고 생각할 수 있습니다. 하지만, 이 사용자는 실제로 데이터베이스 유지 관리를 위한 것이기 때문에 그렇지 않습니다.\n\n애플리케이션이 데이터베이스 클러스터를 사용할 수 있도록하려면 데이터베이스와 해당 데이터에 액세스할 사용자를 생성해야 합니다.\n\nCompass 창의 맨 아래에 `_MONGOSH` 프롬프트가 나타납니다. 이를 클릭하여 명령줄에 액세스할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 다음과 같이 사용자를 생성할 것입니다:\n\n```js\nuse aquarium\ndb.createUser( { user: \"my-app-user\",\n              pwd: \"\u003cpassword\u003e\",\n              roles: [ {db: \"aquarium\", role: \"dbOwner\"} ] } )\n```\n\n알아둬야 할 몇 가지 사항이 있습니다. 첫번째로, 생성되기 전에 존재하지 않는 데이터베이스(aquarium)로 전환합니다. 이는 사용하기 전에 아무 것도 정의할 필요가 없다는 원칙에 부합합니다. 데이터베이스 및 모든 컬렉션은 문서를 추가할 때 처음 생성됩니다.\n\n두번째는 새 데이터베이스에 할당된 역할입니다. MongoDB에는 사용자에게 부여할 수 있는 소수의 기본 역할이 있습니다. 이 경우 dbOwner 역할은 사용자가 데이터베이스를 읽고 쓰고 관리할 수 있도록 합니다. 실제 운영에서는 사용자 권한을 적절히 제한해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n...\nok: 1,\n...\n```\n\n사용자를 확인하기 위해 새 Compass 연결을 열어보세요. 이는 메뉴를 통해 할 수 있습니다. 혹은 MacOS에서는 Cmd N을 누르세요. 창이 열릴 때까지 몇 초가 걸릴 수 있는데, 아무런 표시가 없으므로 한 번만 누르세요!\n\n새 연결 창이 나타나면, 이전에 저장한 연결을 복제하는 것이 더 쉽다고 생각합니다(연결 옆의 ... 메뉴를 사용하세요).\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n사용자 이름과 비밀번호를 변경해주세요. 또한 Authentication Database를 aquarium으로 변경해주세요. 그런 다음 연결하세요.\n\n이제 새로운 aquarium 데이터베이스를 확인할 수 있어야 합니다. \"fishes\"라는 collection을 생성해보면서 테스트해 볼 수 있습니다. 데이터베이스에 문서 형태로 데이터를 추가할 수 있습니다.\n\n```js\n{\n  \"_id\": 123,\n  \"fish\": \"Guppy\"\n}\n```\n\n이 시점에서 Spring Boot 애플리케이션과 함께 사용할 준비가 된 MongoDB가 준비되었습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 스프링 부트 애플리케이션 만들기\n\n간단한 데이터베이스 지원 예제를 만들 때는 제가 제일 먼저 수족관 애플리케이션을 사용합니다. REST API를 사용하여 물고기와 수족관을 만들고 관리할 수 있습니다. 그런 다음 물고기를 여러분의 수족관 중 하나에 추가할 수 있습니다.\n\n## 코드\n\n저는 코드를 여기에 포함하려는 의도는 없지만 관련된 GitHub 저장소에서 확인할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 종속성\n\nSpring Boot 애플리케이션을 시작하는 것은 항상 https://start.spring.io/에서 Spring Initializr를 사용하는 것이 더 쉽습니다. 사용 방법을 알고 있다고 가정합니다.\n\n이 프로젝트에서 Spring Web과 Spring Data MongoDB를 종속성으로 추가하고 프로젝트를 생성합니다.\n\n## 패키지 구조\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n내가 만드는 애플리케이션에 따라, 패키지 구조를 구성하는 데 컴포넌트 유형(예: 컨트롤러, 서비스 및 리포지토리)에 기반을 둘 수도 있고, 비즈니스 도메인에 기반을 둘 수도 있습니다.\n\n물고기와 수조 두 가지 비즈니스 도메인만 있는 작은 애플리케이션인 경우, 이 프로젝트를 이러한 도메인을 기반으로 해서 다음과 같이 만들 것입니다:\n\n```js\nfishes;\nFishController;\nFishService;\nFishRepository;\nfishtanks;\nFishTankController;\nFishTankService;\nFishTankRepository;\n```\n\n보시다시피, 컨트롤러, 서비스 및 리포지토리 레이어를 사용하여 표준 계층 구조를 따르고 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## API 엔드포인트\n\n이 컨트롤러들은 각각의 API에 대해 생성, 조회, 업데이트 및 삭제 (CRUD) 엔드포인트를 제공합니다.\n\n## 엔티티 및 문서\n\n만약 JPA와 Postgres와 같은 SQL 데이터베이스에 익숙하다면, 엔티티와 리포지토리로 익숙할 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNo-SQL 데이터베이스에서는 테이블이 컬렉션으로 대체되고, 테이블 내의 행은 문서로 대체됩니다.\n\n이는 No-SQL 데이터베이스를 위한 리포지토리가 SQL 데이터베이스와는 조금 다르다는 것을 의미합니다.\n\nNo-SQL 데이터베이스는 어떤 구조든 다룰 수 있기 때문에, 엔티티(또는 문서)는 간단한 Plain Old Java Objects (POJOs)가 됩니다. 이는 우리 예시 애플리케이션에서 다음과 같이 엔티티를 생성할 수 있다는 것을 의미합니다:\n\naquarium/fishes/Fish.java\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n...\n\n@Setter\n@Getter\n@Document(\"fishes\")\n@NoArgsConstructor\npublic class Fish {\n\n  @Id\n  public UUID id;\n\n  public String type;\n\n  public Fish(String type) {\n      this.id = UUID.randomUUID();\n      this.type = type;\n  }\n  ...\n}\n```\n\n친구야, 여기 몇 가지 주의할 점이 있어요:\n\n- @Entity를 정의하는 대신 컬렉션의 이름을 사용하는 @Document를 정의하고 있어요.\n- 자체 UUID Id를 관리할 수 있도록 @mongoId 대신에 (필수는 아니지만 MongoDB가 제공하지 않은 경우 MongoDB로 제공할 수 있기 때문에) @Id를 사용하고 있어요.\n- Lombok(예: @Getter)을 사용하여 보일러플레이트 코드 일부를 제거하는 것을 좋아해요.\n\n이제 비슷한 방식으로 물고기 수조를 만들 수 있어요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n수족관/fishtanks/FishTank.java\n\n```java\n@Setter\n@Getter\n@Document(\"fish tanks\")\n@NoArgsConstructor\npublic class FishTank {\n\n    @Id\n    public UUID id;\n\n    public String name;\n\n    public FishTank(String name) {\n        this.id = UUID.randomUUID();\n        this.name = name;\n    }\n\n    @Override\n    public String toString() {\n        return String.format(\n                \"FishTank[id=%s, type='%s']\",\n                id.toString(), name);\n    }\n}\n```\n\n## Repositories\n\n자, 이제 우리의 문서들이 준비되었어요. 이제 이들에 어떻게 접근할까요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n제가 보여드릴 것은 우리 저장소의 변경 사항입니다. 물고기 저장소를 예로 들어보겠습니다:\n\n```js\n...\npublic interface FishRepository extends MongoRepository\u003cFish, UUID\u003e {\n\n    public List\u003cFish\u003e findAll();\n\n    public Optional\u003cFish\u003e findFirstById(UUID id);\n\n    public Optional\u003cFish\u003e findFirstByType(String type);\n}\n...\n```\n\n이것이 SQL 데이터베이스에서 찾을 수 있는 Repository 유형과 거의 동일하다는 것을 알 수 있습니다. 유일한 차이점은 인터페이스가 CrudRepository가 아닌 MongoRespository를 확장한다는 것뿐입니다.\n\n한 대 다 및 다른 매핑 주제는 다른 기사로 미루겠습니다. 그래서 현재로서는 물고기와 어항을 생성하고 관리할 수 있을 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 어플리케이션 속성\n\n데이터베이스와 작업할 때는 어플리케이션이 어떻게 연결해야 하는지를 알려줘야 합니다. 우리는 SQL 데이터베이스와 마찬가지로 어플리케이션 속성을 통해 이를 수행합니다.\n\n나는 Spring Boot 속성 파일에 YAML 파일을 사용하는 것을 선호하며, 내 구성은 다음과 같이 보입니다 (나의 값으로 ` ` 필드를 교체해주시기 바랍니다):\n\nresources/application.yml\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```yaml\nspring:\n  application:\n    name: aquarium-with-mongo-db\n\n  data:\n    mongodb:\n      host: localhost\n      port: 27017\n      database: aquarium\n      username: my-app-user\n      password: \u003cpassword\u003e\n```\n\n나중에 프로필에 대해 이야기할 때 다시 돌아올게요.\n\n## 컨트롤러 및 서비스\n\n이제 SQL 데이터베이스와 마찬가지로 컨트롤러와 서비스를 추가할 수 있습니다. GitHub 저장소에서 이용 가능하므로 별도로 제시하지 않겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 애플리케이션 테스트\n\n코드를 완성하거나(또는 제 저장소를 복제)하여 IDE 내에서 애플리케이션을 실행하십시오. 여전히 주 서버로 포트 포워딩 중인 경우, 애플리케이션이 시작되어야 합니다.\n\n그런 다음 다음 curl 명령을 사용하여 테스트할 수 있습니다:\n\n```js\ncurl localhost:8080/api/v1/fishes -H \"Content-Type: application/json\" -d '{\"type\": \"guppy2\"}'\ncurl localhost:8080/api/v1/fish-tanks -H \"Content-Type: application/json\" -d '{\"name\": \"big one\"}'\ncurl localhost:8080/api/v1/fishes\ncurl localhost:8080/api/v1/fish-tanks\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 컴퍼스 클라이언트로 이동하여 아쿠아리움 데이터베이스를 새로 고침하면 fishes 및 fish tanks 두 개의 컬렉션이 표시됩니다. 이러한 컬렉션 내에는 만든 fishes 및 fish tanks가 표시됩니다.\n\n# 최종 단계\n\n이 시점에서 저희는 쿠버네티스 클러스터에서 실행 중인 MongoDB에 연결된 Spring Boot 애플리케이션을 갖추었습니다. 이제 해야 할 마지막 단계, 즉 Spring Boot 애플리케이션을 쿠버네티스 클러스터에 로드하는 것이 남았습니다.\n\n이를 위해 다음을 수행해야 합니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 팻 JAR 파일을 생성합니다 (모든 종속성이 포함됨)\n- 해당 JAR에서 Docker 이미지를 생성합니다\n- 이미지를 Docker 저장소에 업로드합니다\n- 배포 매니페스트 파일을 생성합니다\n- 배포 매니페스트를 Kubernetes 클러스터에 적용합니다\n\n제가 Kind를 사용하고 있기 때문에, 3단계를 간단한 로드 단계로 대체할 수 있습니다. 이렇게 하면 Docker 저장소를 사용할 필요가 없습니다.\n\n## 프로필\n\nJAR 파일을 생성하기 전에 Spring Boot 프로필 두 개를 생성하는 것이 유용합니다. 이를 통해 애플리케이션을 연결된 모드 (지금까지 한 것처럼) 및 Kubernetes 클러스터 내에서 실행할 수 있습니다. Spring Boot 프로필 두 개를 생성하겠습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- `connected` ... 클러스터 외부에서 실행 중일 때 사용되는 모드\n- `local-cluster` ... 클러스터 내부에서 실행 중일 때 사용되는 모드\n\n현재 실행 중인 모드는 첫 번째입니다. 이는 우리가 간단히 application.yml(또는 application.properties) 파일을 application-connected.yml로 복사할 수 있다는 것을 의미합니다. 그런 다음 JVM 명령줄에 다음 JVM 인수를 추가할 수 있습니다:\n\n```js\n-Dspring.profiles.active=connected\n```\n\n로컬 클러스터 파일에 대해서도 동일한 작업을 수행하지만 이번에는 변경이 필요합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n...\n  data:\n    mongodb:\n      host: my-mongo-db-svc.mongo.svc.cluster.local\n      port: 27017\n...\n```\n\nDNS 이름을 사용하여 올바른 팟에 연결할 수 있습니다. 팟에서 DNS 검색 규칙이 설정되어 있어 my-mongo-db-svc.mongo.svc와 같은 이름 일부를 생략할 수 있습니다. 이를 통해 다른 클러스터로 배포하고도 응용 프로그램이 작동할 수 있습니다.\n\n## 이미지 생성\n\n이제 이미지를 만드는 방법을 살펴보겠습니다. GitHub에 있는 프로젝트가 Gradle 프로젝트이므로 루트 프로젝트 폴더에서 다음과 같이 JAR 파일을 생성할 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\ngradle build\n```\n\ngradle.build에 아래 내용이 추가되었음을 유의해주세요. 이는 manifest가 주 애플리케이션 파일을 가리키도록 합니다:\n\ngradle.build\n\n```js\njar {\n    manifest {\n        attributes \"Main-Class\": \"com.requillion_solutions.aquarium.AquariumWithMongoDbApplication\"\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이렇게 하면 jar 파일이 생성됩니다: build/libs/aquarium-with-mongo-db-0.0.1-SNAPSHOT.jar.\n\n도커 이미지를 만들기 위해서는 도커 파일이 필요합니다. 아래 내용대로 만들어보세요:\n\nDockerfile\n\n```js\nFROM openjdk:17.0.2-slim-buster\nRUN addgroup --system spring \u0026\u0026 useradd --system spring -g spring\nUSER spring:spring\nARG JAR_FILE=build/libs/*.jar\nCOPY ${JAR_FILE} app.jar\nENTRYPOINT [\"java\",\"-jar\",\"/app.jar\"]\nEXPOSE 8080\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이는 Java 17 기반 이미지를 시작으로 합니다 (이것은 롬복과의 문제를 피하기 위해 필요합니다) 그리고 새 사용자 (spring)를 추가하여 루트로 실행하지 않도록 합니다. 그런 다음 JAR 파일이 이미지로 복사되고 응용 프로그램을 실행하는 엔트리포인트가 생성됩니다.\n\n다음 명령어로 도커 이미지를 생성하세요:\n\n```bash\ndocker build -t aquarium .\n```\n\n그리고 만약 Kind를 사용 중이라면, 다음 명령어로 직접 Kubernetes 클러스터에 로드하세요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nkind load docker-image aquarium\n```\n\n이 작업이 완료되면 클러스터에서 실행하기 위한 배포 매니페스트를 생성할 준비가 되었습니다.\n\n## 배포 매니페스트\n\n이제 쿠버네티스 클러스터에 도커 이미지를 로드했으므로 배포 매니페스트를 사용하여 배포할 수 있습니다. 다음 파일을 만들어주세요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nk8s/deployment.yml\n\n```yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: aquarium\n  namespace: default\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: aquarium\n  template:\n    metadata:\n      labels:\n        app: aquarium\n    spec:\n      containers:\n        - name: aquarium\n          image: aquarium\n          imagePullPolicy: IfNotPresent\n          ports:\n            - containerPort: 8080\n          env:\n            - name: SPRING_PROFILES_ACTIVE\n              value: local-cluster\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: aquarium\n  namespace: default\nspec:\n  selector:\n    app: aquarium\n  type: NodePort\n  ports:\n    - port: 8080\n      targetPort: 8080\n      nodePort: 30080\n```\n\n알아두어야 할 사항이 몇 가지 있어요:\n\n- 어플리케이션이 default 네임스페이스에 배포되었어요 (네임스페이스가 지정되지 않으면 사용되는 곳이죠)\n- 레플리카는 1개뿐이에요\n- 이미지는 이전에 불러왔으므로, 이미지가 없을 때만 불러와요\n- 프로필은 local-cluster로 설정돼요\n- 서비스가 생성되어 어플리케이션의 포트 8080을 개발 머신의 포트 30080으로 매핑돼요\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 다음과 같이 배포할 수 있습니다:\n\n```js\nkubectl apply -f k8s/deployment.yml\n```\n\n시작이 성공적으로 이루어졌는지 확인해보세요:\n\n```js\nkubectl get pods\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n한 번이 배포되면 API는 이전에 사용한 것과 동일한 curl 명령으로 테스트할 수 있습니다. 단, 포트를 30080으로 변경해 주세요.\n\n```js\ncurl localhost:30080/api/v1/fishes -H \"Content-Type: application/json\" -d '{\"type\": \"guppy2\"}'\ncurl localhost:30080/api/v1/fish-tanks -H \"Content-Type: application/json\" -d '{\"name\": \"big one\"}'\ncurl localhost:30080/api/v1/fishes\ncurl localhost:30080/api/v1/fish-tanks\n```\n\nCompass UI에서 새 문서를 확인할 수도 있습니다 (포트 포워드가 여전히 유지되는지 확인해 주세요).\n\n# 요약\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 기사는 Kind Kubernetes 클러스터로 MongoDB를 설치하고 Spring Boot 애플리케이션과 통합하는 과정에 대해 다루었습니다.\n\n이 연습은 꽤 간단하지만 그냥 어떻게 하는지 보여주는 것뿐입니다. 실제로는 보안, 백업 및 장애 조치에 작업이 필요할 것입니다.\n\n다른 기사에서는 문서간의 관계를 어떻게 관리할 수 있는지도 보여드릴 예정입니다.\n\n이 연습을 통해 No-SQL 데이터베이스가 Kubernetes와 Spring Boot와 간단하게 사용될 수 있다는 것을 보여줬으면 좋겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 글을 즐겁게 읽으셨기를 바라며, 새로운 것을 배우며 기술을 향상시켰기를 바랍니다. 작은 거라도 새로운 지식을 얻었다면 좋겠네요.\n\n이 글이 유익하게 느껴진다면, 박수 한 번 부탁드립니다. 그렇게 하면 미래에 어떤 글을 써야 하는지 파악할 수 있고, 다음 글을 결정하는 데 도움이 됩니다. 개선 사항이나 제안 사항이 있다면 메모나 답글로 추가해 주세요.\n","ogImage":{"url":"/assets/img/2024-06-19-MyexperienceaddingaMongoDBNo-SQLdatabasetomyKubernetescluster_0.png"},"coverImage":"/assets/img/2024-06-19-MyexperienceaddingaMongoDBNo-SQLdatabasetomyKubernetescluster_0.png","tag":["Tech"],"readingTime":29},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch2\u003eSQL과 No-SQL 데이터베이스 사이를 선택하는 방법에 대해 읽었다면, Kubernetes 클러스터에 No-SQL MongoDB 데이터베이스를 추가할 수 있는지 궁금할 것입니다. 이 글에서는 그것을 어떻게 수행했는지 설명하고 Spring Boot 애플리케이션과 함께 사용하는 방법에 대해 알려드리겠습니다.\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-MyexperienceaddingaMongoDBNo-SQLdatabasetomyKubernetescluster_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch1\u003e시작하기\u003c/h1\u003e\n\u003cp\u003e일반적으로 Kubernetes 서비스를 개발할 때는, 개발을 위해 로컬 Kind Kubernetes 클러스터에서 시작합니다. Kind를 설정하는 방법에 대해 이전에 썼었고, 이 글에 관련된 GitHub 저장소에는 이를 수행하는 데 필요한 구성 파일이 포함되어 있습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e클론하기 위해 저장소를 다음과 같이 복제할 수 있어요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003egit clone git@github.\u003cspan class=\"hljs-property\"\u003ecom\u003c/span\u003e:\u003cspan class=\"hljs-title class_\"\u003eMartinHodges\u003c/span\u003e/aquarium-\u003cspan class=\"hljs-keyword\"\u003ewith\u003c/span\u003e-mongo-db.\u003cspan class=\"hljs-property\"\u003egit\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e왜 MongoDB를 사용해야 하나요?\u003c/h1\u003e\n\u003cp\u003e이전 기사에서 SQL 대 No-SQL 결정에 대해 다뤄 보았어요. 여러분이 이 글을 읽고 계신다면 No-SQL을 선택하겠다고 결정하신 거겠죠.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e일단 그 결정이 내렸다면, 이제 No-SQL 데이터베이스를 어떤 것을 선택할지가 문제가 됩니다. MongoDB는 가장 가까운 경쟁상대보다 2배 더 높은 시장 점유율을 보유하고 있습니다. 그것은 매우 정교하며 커뮤니티 버전과 엔터프라이즈 버전 둘 다 가지고 있습니다. 전형적으로 가장 많이 사용되는 No-SQL 데이터베이스입니다.\u003c/p\u003e\n\u003cp\u003e다른 데이터베이스와의 기술적인 비교는 이 기사의 범위를 벗어나지만, MongoDB가 인기 있는 이유와 일하도록 충분히 할 수 있는 사실에 기반하여 이 기사에서는 MongoDB를 선택했습니다!\u003c/p\u003e\n\u003ch1\u003eMongoDB 설치\u003c/h1\u003e\n\u003cp\u003eKubernetes 클러스터에 MongoDB를 설치하는 방법은 다른 응용프로그램과 유사하게 operator를 사용하여 수행됩니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cimg src=\"/assets/img/2024-06-19-MyexperienceaddingaMongoDBNo-SQLdatabasetomyKubernetescluster_1.png\"\u003e\n\u003cp\u003e쿠버네티스 오퍼레이터는 당신을 대신하여 응용 프로그램을 관리합니다. 응용 프로그램의 라이프사이클을 설치하고 관리하며 모니터링하고 필요한 조치를 취할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e데이터베이스의 경우 데이터베이스 클러스터를 생성하거나 확장하거나 백업하는 등의 작업을 수행할 수 있습니다. 일반적으로 오퍼레이터는 그 자체의 '쿠버네티스 구성 언어'를 제공하는 사용자 정의 리소스 정의 (CRD)를 설치하기에 의존합니다. 이는 클러스터에 사용자 정의 리소스를 추가하기 위한 요청을 감지하고 당신을 대신하여 작동합니다.\u003c/p\u003e\n\u003ch2\u003e개발용 쿠버네티스 클러스터 생성\u003c/h2\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eKind를 설치했다고 가정하면, 다음 구성을 사용하여 Kind 클러스터를 만들 수 있습니다:\u003c/p\u003e\n\u003cp\u003ekind/kind-config.yml\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-attr\"\u003eapiVersion\u003c/span\u003e: kind.\u003cspan class=\"hljs-property\"\u003ex\u003c/span\u003e-k8s.\u003cspan class=\"hljs-property\"\u003eio\u003c/span\u003e/v1alpha4\n\u003cspan class=\"hljs-attr\"\u003ekind\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eCluster\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003enodes\u003c/span\u003e:\n- \u003cspan class=\"hljs-attr\"\u003erole\u003c/span\u003e: control-plane\n  \u003cspan class=\"hljs-attr\"\u003eextraPortMappings\u003c/span\u003e:\n  # apis\n  - \u003cspan class=\"hljs-attr\"\u003econtainerPort\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e30080\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003ehostPort\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e30080\u003c/span\u003e\n- \u003cspan class=\"hljs-attr\"\u003erole\u003c/span\u003e: worker\n- \u003cspan class=\"hljs-attr\"\u003erole\u003c/span\u003e: worker\n- \u003cspan class=\"hljs-attr\"\u003erole\u003c/span\u003e: worker\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이렇게 하면 1개의 컨트롤러 및 3개의 워커로 구성된 4개 노드 클러스터가 생성됩니다. 또한 개발 머신의 포트 30080을 사용할 수 있습니다. 이를 사용하여 로컬 Kubernetes 클러스터를 생성할 수 있습니다:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-shell\"\u003ekind create cluster --config kind/kind-config.yml\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e오퍼레이터 설치\u003c/h2\u003e\n\u003cp\u003eHelm을 사용하여 커뮤니티 지원 오퍼레이터를 설치할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e먼저 다음과 같이 로컬 리포지토리에 Helm 링크를 추가하세요:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ehelm repo add mongodb \u003cspan class=\"hljs-attr\"\u003ehttps\u003c/span\u003e:\u003cspan class=\"hljs-comment\"\u003e//mongodb.github.io/helm-charts\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e아래 명령어로 이 리포지토리가 추가한 차트를 확인할 수 있어요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ehelm search repo mongo\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e리스트에서 커뮤니티 오퍼레이터를 확인할 수 있을 거에요. 이것을 사용할 거에요.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e저희는 오퍼레이터와 데이터베이스를 별도의 네임스페이스로 mongo라는 이름으로 분리해서 배치할 겁니다. 다음과 같이 생성해보겠습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ekubectl create namespace mongo\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 다음 명령으로 오퍼레이터를 설치할 수 있어요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ehelm install community-operator mongodb/community-operator -n mongo\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e다음 명령어를 사용하여 준비 상태가 1/1로 Running인지 확인할 수 있어요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-sh\"\u003ekubectl get pods -n mongo\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 운영자가 작동 중인 것을 볼 수 있습니다. 설치된 CRD는 다음을 통해 확인할 수 있어요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-sh\"\u003ekubectl get crds\nkubectl describe crd mongodbcommunity.mongodbcommunity.mongodb.com\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이제 MongoDB 클러스터를 생성할 준비가 되었습니다.\u003c/p\u003e\n\u003ch2\u003e클러스터 생성\u003c/h2\u003e\n\u003cp\u003e오퍼레이터가 설치되었으므로 MongoDB 데이터베이스를 생성하는 요청을 대기 중입니다. 우리는 오퍼레이터에 의해 로드된 CRD를 사용하여 쿠버네티스 클러스터에 MongoDB 매니페스트를 적용하여 요청을 할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이를 하기 전에 데이터베이스 사용자의 비밀번호를 쿠버네티스 시크릿으로 설정해야 합니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e다음과 같이 비밀을 생성하세요 (‘…’를 선택한 비밀번호로 교체하세요):\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ekubectl create secret generic my-user-password -n mongo --\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e-literal=\u003cspan class=\"hljs-string\"\u003e\"password=\u0026#x3C;당신의 비밀번호\u003e\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다음 명령어로 확인할 수 있어요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ekubectl get secrets -n mongo my-user-password -o jsonpath={.\u003cspan class=\"hljs-property\"\u003edata\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003epassword\u003c/span\u003e} | base64 -d; echo\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e모든 쿠버네티스 시크릿은 base64로 인코드되어 있기 때문에 비밀번호를 디코딩하는 데 base64 -d를 사용하는 것을 알 수 있습니다. 우리가 --from-literal을 사용하였기 때문에 create secret 명령어에 의해 비밀번호가 자동으로 base64로 인코드되었습니다.\u003c/p\u003e\n\u003cp\u003e이제 비밀번호가 준비되었으니, 이 비밀번호를 사용하는 관리자 사용자가 있는 MonogoDB 클러스터와 데이터베이스를 생성할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e매니페스트 파일을 생성해 보세요:\u003c/p\u003e\n\u003cp\u003ek8s/my-mongo-db.yml\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-yaml\"\u003e\u003cspan class=\"hljs-attr\"\u003eapiVersion:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003emongodbcommunity.mongodb.com/v1\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003ekind:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eMongoDBCommunity\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003emetadata:\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003ename:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003emy-mongo-db\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003enamespace:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003emongo\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003espec:\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003emembers:\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003etype:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eReplicaSet\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003eversion:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"7.0.11\"\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003esecurity:\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003eauthentication:\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003emodes:\u003c/span\u003e [\u003cspan class=\"hljs-string\"\u003e\"SCRAM\"\u003c/span\u003e]\n  \u003cspan class=\"hljs-attr\"\u003eusers:\u003c/span\u003e\n    \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ename:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003emy-user\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003edb:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eadmin\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003epasswordSecretRef:\u003c/span\u003e \u003cspan class=\"hljs-comment\"\u003e# a reference to the secret that will be used to generate the user's password\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003ename:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003emy-user-password\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003ekey:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003epassword\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003eroles:\u003c/span\u003e\n        \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ename:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eclusterAdmin\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003edb:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eadmin\u003c/span\u003e\n        \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ename:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003euserAdminAnyDatabase\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003edb:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eadmin\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003escramCredentialsSecretName:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003emy-user-scram\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003eadditionalMongodConfig:\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003estorage.wiredTiger.engineConfig.journalCompressor:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ezlib\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 다음과 같이 적용할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003ekubectl apply -f k8s/my-mongo-db.yml\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그리고 진행 상황을 다음과 같이 확인할 수 있습니다:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ekubectl get pods -n mongo\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e3개의 인스턴스가 생성될 때까지 기다리고 있어요. 제 MacBook Pro(M2 Max Apple 실리콘)에서 4노드 Kind 클러스터를 사용하면, 모든 3개의 인스턴스를 시작하는 데 약 5분 정도 걸렸어요.\u003c/p\u003e\n\u003cp\u003e시작되고 나면, 다음 명령어로 서비스가 정상적으로 작동하는지 확인할 수 있어요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ekubectl get svc -n mongo\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이렇게 하면:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable constant_\"\u003eNAME\u003c/span\u003e              \u003cspan class=\"hljs-variable constant_\"\u003eTYPE\u003c/span\u003e        \u003cspan class=\"hljs-variable constant_\"\u003eCLUSTER\u003c/span\u003e-\u003cspan class=\"hljs-variable constant_\"\u003eIP\u003c/span\u003e   \u003cspan class=\"hljs-variable constant_\"\u003eEXTERNAL\u003c/span\u003e-\u003cspan class=\"hljs-variable constant_\"\u003eIP\u003c/span\u003e   \u003cspan class=\"hljs-title function_\"\u003ePORT\u003c/span\u003e(S)     \u003cspan class=\"hljs-variable constant_\"\u003eAGE\u003c/span\u003e\nmy-mongo-db-svc   \u003cspan class=\"hljs-title class_\"\u003eClusterIP\u003c/span\u003e   \u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e         \u0026#x3C;none\u003e        \u003cspan class=\"hljs-number\"\u003e27017\u003c/span\u003e/\u003cspan class=\"hljs-variable constant_\"\u003eTCP\u003c/span\u003e   6m\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e데이터베이스 테스트\u003c/h2\u003e\n\u003cp\u003e우리 애플리케이션에서는 쿠버네티스 내부에서 직접 데이터베이스에 연결할 것입니다. 데이터베이스의 서비스를 이용해 DNS 이름으로 연결하려고 하지만, 테스트 목적으로는 로컬 개발 머신에서 연결하고 싶습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e처음으로 이를 시도할 때 로컬 개발 머신으로 MonogoDB 파드 중 하나를 포워딩하기 위해 포트 포워딩을 사용했고, 어떤 변경을 시도했을 때 다음과 같은 오류 메시지를 받았습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eMongoServerError\u003c/span\u003e[\u003cspan class=\"hljs-title class_\"\u003eNotWriteablePrimary\u003c/span\u003e]: not primary\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이것은 포트 포워딩한 파드가 클러스터의 주 파드가 아니기 때문에 발생한 문제입니다. 보조 파드는 읽기 전용 복사본이기 때문에 모든 쓰기 작업은 주 파드를 통해 이루어져야 합니다.\u003c/p\u003e\n\u003cp\u003e이 문제를 피하려면 주 파드에 연결해야 합니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e어떤 노드가 기본 노드인지 알고 싶다면 다음 노드 중 하나의 로그를 조사하면 됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ekubectl logs my-mongo-db-\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e -n mongo -c mongod | grep \u003cspan class=\"hljs-string\"\u003e\"\\\"primary\\\":\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e만약 결과가 없다면, 기본 노드에 도달한 것입니다.\u003c/p\u003e\n\u003cp\u003e만약 결과를 얻는다면, 몇 줄만 출력될 수 있지만, 그것들은 매우 길고 읽기 어려울 수 있습니다. JSON pretty printer 같은 것(jq와 같은)을 가지고 있다면 다음을 사용할 수 있습니다:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ekubectl logs my-mongo-db-\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e -n mongo -c mongod | grep \u003cspan class=\"hljs-string\"\u003e\"\\\"primary\\\":\"\u003c/span\u003e | jq\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그러면 다음과 같은 줄을 볼 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e...\n\u003cspan class=\"hljs-string\"\u003e\"primary\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"my-mongo-db-1.my-mongo-db-svc.mongo.svc.cluster.local:27017\"\u003c/span\u003e,\n...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기에 연결해야 하는 pod의 이름이 나옵니다 (제 경우: my-mongo-db-1). 이제 해당 pod를 포트 포워드할 수 있습니다:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ekubectl port-forward my-mongo-db-\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e -n mongo \u003cspan class=\"hljs-number\"\u003e27017\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e27017\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 포트 포워딩이 설정되면 데이터베이스에 연결해야 합니다. MongoDB Compass 클라이언트를 사용할 수 있습니다. 해당 클라이언트는 \u003ca href=\"https://www.mongodb.com/try/download/compass\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://www.mongodb.com/try/download/compass\u003c/a\u003e 에서 다운로드할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e설치 후 데이터베이스에 연결할 수 있어야 합니다. 연결 문자열(mongodb://localhost:27017)이 제안됩니다만, 몇 가지 설정을 변경해야합니다.\u003c/p\u003e\n\u003cp\u003e고급 연결 옵션을 클릭하고 직접 연결을 클릭하십시오 (이 설정을 변경하지 않으면 내부 쿠버네티스 주소를 사용하려고 시도하여 찾을 수 없는 주소가 발생합니다).\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e인증 탭을 클릭해주세요. 사용자 이름/비밀번호를 선택하고 이전에 선택한 사용자 이름(my-user)과 비밀번호를 입력해주세요. Admin을 데이터베이스로 추가하고 SCRAM-SHA-256 인증 메커니즘을 선택해주세요 (필요하다면 아래로 스크롤).\u003c/p\u003e\n\u003cp\u003e저장 및 연결을 클릭하고 연결 이름을 지정한 후, 데이터베이스에 연결된 Compass 콘솔이 표시됩니다.\u003c/p\u003e\n\u003cp\u003e클러스터 내에서 admin, config 및 local 데이터베이스가 생성된 것을 확인하실 수 있습니다.\u003c/p\u003e\n\u003cp\u003e여기까지 오셨다면, MongoDB 클러스터가 정상적으로 실행 중임을 의미합니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e애플리케이션 사용자 생성\u003c/h1\u003e\n\u003cp\u003e우리의 MongoDB에 연결할 모든 애플리케이션이 우리가 생성한 my-user를 사용할 수 있을 것이라고 생각할 수 있습니다. 하지만, 이 사용자는 실제로 데이터베이스 유지 관리를 위한 것이기 때문에 그렇지 않습니다.\u003c/p\u003e\n\u003cp\u003e애플리케이션이 데이터베이스 클러스터를 사용할 수 있도록하려면 데이터베이스와 해당 데이터에 액세스할 사용자를 생성해야 합니다.\u003c/p\u003e\n\u003cp\u003eCompass 창의 맨 아래에 \u003ccode\u003e_MONGOSH\u003c/code\u003e 프롬프트가 나타납니다. 이를 클릭하여 명령줄에 액세스할 수 있습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이제 다음과 같이 사용자를 생성할 것입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003euse aquarium\ndb.\u003cspan class=\"hljs-title function_\"\u003ecreateUser\u003c/span\u003e( { \u003cspan class=\"hljs-attr\"\u003euser\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"my-app-user\"\u003c/span\u003e,\n              \u003cspan class=\"hljs-attr\"\u003epwd\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"\u0026#x3C;password\u003e\"\u003c/span\u003e,\n              \u003cspan class=\"hljs-attr\"\u003eroles\u003c/span\u003e: [ {\u003cspan class=\"hljs-attr\"\u003edb\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"aquarium\"\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003erole\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"dbOwner\"\u003c/span\u003e} ] } )\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e알아둬야 할 몇 가지 사항이 있습니다. 첫번째로, 생성되기 전에 존재하지 않는 데이터베이스(aquarium)로 전환합니다. 이는 사용하기 전에 아무 것도 정의할 필요가 없다는 원칙에 부합합니다. 데이터베이스 및 모든 컬렉션은 문서를 추가할 때 처음 생성됩니다.\u003c/p\u003e\n\u003cp\u003e두번째는 새 데이터베이스에 할당된 역할입니다. MongoDB에는 사용자에게 부여할 수 있는 소수의 기본 역할이 있습니다. 이 경우 dbOwner 역할은 사용자가 데이터베이스를 읽고 쓰고 관리할 수 있도록 합니다. 실제 운영에서는 사용자 권한을 적절히 제한해야 합니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e...\n\u003cspan class=\"hljs-attr\"\u003eok\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,\n...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e사용자를 확인하기 위해 새 Compass 연결을 열어보세요. 이는 메뉴를 통해 할 수 있습니다. 혹은 MacOS에서는 Cmd N을 누르세요. 창이 열릴 때까지 몇 초가 걸릴 수 있는데, 아무런 표시가 없으므로 한 번만 누르세요!\u003c/p\u003e\n\u003cp\u003e새 연결 창이 나타나면, 이전에 저장한 연결을 복제하는 것이 더 쉽다고 생각합니다(연결 옆의 ... 메뉴를 사용하세요).\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e사용자 이름과 비밀번호를 변경해주세요. 또한 Authentication Database를 aquarium으로 변경해주세요. 그런 다음 연결하세요.\u003c/p\u003e\n\u003cp\u003e이제 새로운 aquarium 데이터베이스를 확인할 수 있어야 합니다. \"fishes\"라는 collection을 생성해보면서 테스트해 볼 수 있습니다. 데이터베이스에 문서 형태로 데이터를 추가할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e{\n  \u003cspan class=\"hljs-string\"\u003e\"_id\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e123\u003c/span\u003e,\n  \u003cspan class=\"hljs-string\"\u003e\"fish\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"Guppy\"\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 시점에서 Spring Boot 애플리케이션과 함께 사용할 준비가 된 MongoDB가 준비되었습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e스프링 부트 애플리케이션 만들기\u003c/h1\u003e\n\u003cp\u003e간단한 데이터베이스 지원 예제를 만들 때는 제가 제일 먼저 수족관 애플리케이션을 사용합니다. REST API를 사용하여 물고기와 수족관을 만들고 관리할 수 있습니다. 그런 다음 물고기를 여러분의 수족관 중 하나에 추가할 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e코드\u003c/h2\u003e\n\u003cp\u003e저는 코드를 여기에 포함하려는 의도는 없지만 관련된 GitHub 저장소에서 확인할 수 있습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003e종속성\u003c/h2\u003e\n\u003cp\u003eSpring Boot 애플리케이션을 시작하는 것은 항상 \u003ca href=\"https://start.spring.io/%EC%97%90%EC%84%9C\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://start.spring.io/에서\u003c/a\u003e Spring Initializr를 사용하는 것이 더 쉽습니다. 사용 방법을 알고 있다고 가정합니다.\u003c/p\u003e\n\u003cp\u003e이 프로젝트에서 Spring Web과 Spring Data MongoDB를 종속성으로 추가하고 프로젝트를 생성합니다.\u003c/p\u003e\n\u003ch2\u003e패키지 구조\u003c/h2\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e내가 만드는 애플리케이션에 따라, 패키지 구조를 구성하는 데 컴포넌트 유형(예: 컨트롤러, 서비스 및 리포지토리)에 기반을 둘 수도 있고, 비즈니스 도메인에 기반을 둘 수도 있습니다.\u003c/p\u003e\n\u003cp\u003e물고기와 수조 두 가지 비즈니스 도메인만 있는 작은 애플리케이션인 경우, 이 프로젝트를 이러한 도메인을 기반으로 해서 다음과 같이 만들 것입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003efishes;\n\u003cspan class=\"hljs-title class_\"\u003eFishController\u003c/span\u003e;\n\u003cspan class=\"hljs-title class_\"\u003eFishService\u003c/span\u003e;\n\u003cspan class=\"hljs-title class_\"\u003eFishRepository\u003c/span\u003e;\nfishtanks;\n\u003cspan class=\"hljs-title class_\"\u003eFishTankController\u003c/span\u003e;\n\u003cspan class=\"hljs-title class_\"\u003eFishTankService\u003c/span\u003e;\n\u003cspan class=\"hljs-title class_\"\u003eFishTankRepository\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e보시다시피, 컨트롤러, 서비스 및 리포지토리 레이어를 사용하여 표준 계층 구조를 따르고 있습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003eAPI 엔드포인트\u003c/h2\u003e\n\u003cp\u003e이 컨트롤러들은 각각의 API에 대해 생성, 조회, 업데이트 및 삭제 (CRUD) 엔드포인트를 제공합니다.\u003c/p\u003e\n\u003ch2\u003e엔티티 및 문서\u003c/h2\u003e\n\u003cp\u003e만약 JPA와 Postgres와 같은 SQL 데이터베이스에 익숙하다면, 엔티티와 리포지토리로 익숙할 것입니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eNo-SQL 데이터베이스에서는 테이블이 컬렉션으로 대체되고, 테이블 내의 행은 문서로 대체됩니다.\u003c/p\u003e\n\u003cp\u003e이는 No-SQL 데이터베이스를 위한 리포지토리가 SQL 데이터베이스와는 조금 다르다는 것을 의미합니다.\u003c/p\u003e\n\u003cp\u003eNo-SQL 데이터베이스는 어떤 구조든 다룰 수 있기 때문에, 엔티티(또는 문서)는 간단한 Plain Old Java Objects (POJOs)가 됩니다. 이는 우리 예시 애플리케이션에서 다음과 같이 엔티티를 생성할 수 있다는 것을 의미합니다:\u003c/p\u003e\n\u003cp\u003eaquarium/fishes/Fish.java\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e...\n\n@\u003cspan class=\"hljs-title class_\"\u003eSetter\u003c/span\u003e\n@\u003cspan class=\"hljs-title class_\"\u003eGetter\u003c/span\u003e\n@\u003cspan class=\"hljs-title class_\"\u003eDocument\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"fishes\"\u003c/span\u003e)\n@\u003cspan class=\"hljs-title class_\"\u003eNoArgsConstructor\u003c/span\u003e\npublic \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFish\u003c/span\u003e {\n\n  @\u003cspan class=\"hljs-title class_\"\u003eId\u003c/span\u003e\n  public \u003cspan class=\"hljs-variable constant_\"\u003eUUID\u003c/span\u003e id;\n\n  public \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e type;\n\n  public \u003cspan class=\"hljs-title class_\"\u003eFish\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e type) {\n      \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eid\u003c/span\u003e = \u003cspan class=\"hljs-variable constant_\"\u003eUUID\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003erandomUUID\u003c/span\u003e();\n      \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003etype\u003c/span\u003e = type;\n  }\n  ...\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e친구야, 여기 몇 가지 주의할 점이 있어요:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e@Entity를 정의하는 대신 컬렉션의 이름을 사용하는 @Document를 정의하고 있어요.\u003c/li\u003e\n\u003cli\u003e자체 UUID Id를 관리할 수 있도록 @mongoId 대신에 (필수는 아니지만 MongoDB가 제공하지 않은 경우 MongoDB로 제공할 수 있기 때문에) @Id를 사용하고 있어요.\u003c/li\u003e\n\u003cli\u003eLombok(예: @Getter)을 사용하여 보일러플레이트 코드 일부를 제거하는 것을 좋아해요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이제 비슷한 방식으로 물고기 수조를 만들 수 있어요:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e수족관/fishtanks/FishTank.java\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-meta\"\u003e@Setter\u003c/span\u003e\n\u003cspan class=\"hljs-meta\"\u003e@Getter\u003c/span\u003e\n\u003cspan class=\"hljs-meta\"\u003e@Document(\"fish tanks\")\u003c/span\u003e\n\u003cspan class=\"hljs-meta\"\u003e@NoArgsConstructor\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFishTank\u003c/span\u003e {\n\n    \u003cspan class=\"hljs-meta\"\u003e@Id\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e UUID id;\n\n    \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e String name;\n\n    \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eFishTank\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(String name)\u003c/span\u003e {\n        \u003cspan class=\"hljs-built_in\"\u003ethis\u003c/span\u003e.id = UUID.randomUUID();\n        \u003cspan class=\"hljs-built_in\"\u003ethis\u003c/span\u003e.name = name;\n    }\n\n    \u003cspan class=\"hljs-meta\"\u003e@Override\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e String \u003cspan class=\"hljs-title function_\"\u003etoString\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e String.format(\n                \u003cspan class=\"hljs-string\"\u003e\"FishTank[id=%s, type='%s']\"\u003c/span\u003e,\n                id.toString(), name);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eRepositories\u003c/h2\u003e\n\u003cp\u003e자, 이제 우리의 문서들이 준비되었어요. 이제 이들에 어떻게 접근할까요?\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e제가 보여드릴 것은 우리 저장소의 변경 사항입니다. 물고기 저장소를 예로 들어보겠습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e...\npublic interface \u003cspan class=\"hljs-title class_\"\u003eFishRepository\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMongoRepository\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eFish\u003c/span\u003e, \u003cspan class=\"hljs-variable constant_\"\u003eUUID\u003c/span\u003e\u003e {\n\n    public \u003cspan class=\"hljs-title class_\"\u003eList\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eFish\u003c/span\u003e\u003e \u003cspan class=\"hljs-title function_\"\u003efindAll\u003c/span\u003e();\n\n    public \u003cspan class=\"hljs-title class_\"\u003eOptional\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eFish\u003c/span\u003e\u003e \u003cspan class=\"hljs-title function_\"\u003efindFirstById\u003c/span\u003e(\u003cspan class=\"hljs-variable constant_\"\u003eUUID\u003c/span\u003e id);\n\n    public \u003cspan class=\"hljs-title class_\"\u003eOptional\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eFish\u003c/span\u003e\u003e \u003cspan class=\"hljs-title function_\"\u003efindFirstByType\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e type);\n}\n...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이것이 SQL 데이터베이스에서 찾을 수 있는 Repository 유형과 거의 동일하다는 것을 알 수 있습니다. 유일한 차이점은 인터페이스가 CrudRepository가 아닌 MongoRespository를 확장한다는 것뿐입니다.\u003c/p\u003e\n\u003cp\u003e한 대 다 및 다른 매핑 주제는 다른 기사로 미루겠습니다. 그래서 현재로서는 물고기와 어항을 생성하고 관리할 수 있을 것입니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003e어플리케이션 속성\u003c/h2\u003e\n\u003cp\u003e데이터베이스와 작업할 때는 어플리케이션이 어떻게 연결해야 하는지를 알려줘야 합니다. 우리는 SQL 데이터베이스와 마찬가지로 어플리케이션 속성을 통해 이를 수행합니다.\u003c/p\u003e\n\u003cp\u003e나는 Spring Boot 속성 파일에 YAML 파일을 사용하는 것을 선호하며, 내 구성은 다음과 같이 보입니다 (나의 값으로 \u003ccode\u003e \u003c/code\u003e 필드를 교체해주시기 바랍니다):\u003c/p\u003e\n\u003cp\u003eresources/application.yml\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-yaml\"\u003e\u003cspan class=\"hljs-attr\"\u003espring:\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003eapplication:\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003ename:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eaquarium-with-mongo-db\u003c/span\u003e\n\n  \u003cspan class=\"hljs-attr\"\u003edata:\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003emongodb:\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003ehost:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003elocalhost\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003eport:\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e27017\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003edatabase:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eaquarium\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003eusername:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003emy-app-user\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003epassword:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x3C;password\u003e\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e나중에 프로필에 대해 이야기할 때 다시 돌아올게요.\u003c/p\u003e\n\u003ch2\u003e컨트롤러 및 서비스\u003c/h2\u003e\n\u003cp\u003e이제 SQL 데이터베이스와 마찬가지로 컨트롤러와 서비스를 추가할 수 있습니다. GitHub 저장소에서 이용 가능하므로 별도로 제시하지 않겠습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003e애플리케이션 테스트\u003c/h2\u003e\n\u003cp\u003e코드를 완성하거나(또는 제 저장소를 복제)하여 IDE 내에서 애플리케이션을 실행하십시오. 여전히 주 서버로 포트 포워딩 중인 경우, 애플리케이션이 시작되어야 합니다.\u003c/p\u003e\n\u003cp\u003e그런 다음 다음 curl 명령을 사용하여 테스트할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ecurl \u003cspan class=\"hljs-attr\"\u003elocalhost\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e8080\u003c/span\u003e/api/v1/fishes -H \u003cspan class=\"hljs-string\"\u003e\"Content-Type: application/json\"\u003c/span\u003e -d \u003cspan class=\"hljs-string\"\u003e'{\"type\": \"guppy2\"}'\u003c/span\u003e\ncurl \u003cspan class=\"hljs-attr\"\u003elocalhost\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e8080\u003c/span\u003e/api/v1/fish-tanks -H \u003cspan class=\"hljs-string\"\u003e\"Content-Type: application/json\"\u003c/span\u003e -d \u003cspan class=\"hljs-string\"\u003e'{\"name\": \"big one\"}'\u003c/span\u003e\ncurl \u003cspan class=\"hljs-attr\"\u003elocalhost\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e8080\u003c/span\u003e/api/v1/fishes\ncurl \u003cspan class=\"hljs-attr\"\u003elocalhost\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e8080\u003c/span\u003e/api/v1/fish-tanks\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이제 컴퍼스 클라이언트로 이동하여 아쿠아리움 데이터베이스를 새로 고침하면 fishes 및 fish tanks 두 개의 컬렉션이 표시됩니다. 이러한 컬렉션 내에는 만든 fishes 및 fish tanks가 표시됩니다.\u003c/p\u003e\n\u003ch1\u003e최종 단계\u003c/h1\u003e\n\u003cp\u003e이 시점에서 저희는 쿠버네티스 클러스터에서 실행 중인 MongoDB에 연결된 Spring Boot 애플리케이션을 갖추었습니다. 이제 해야 할 마지막 단계, 즉 Spring Boot 애플리케이션을 쿠버네티스 클러스터에 로드하는 것이 남았습니다.\u003c/p\u003e\n\u003cp\u003e이를 위해 다음을 수행해야 합니다:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003e팻 JAR 파일을 생성합니다 (모든 종속성이 포함됨)\u003c/li\u003e\n\u003cli\u003e해당 JAR에서 Docker 이미지를 생성합니다\u003c/li\u003e\n\u003cli\u003e이미지를 Docker 저장소에 업로드합니다\u003c/li\u003e\n\u003cli\u003e배포 매니페스트 파일을 생성합니다\u003c/li\u003e\n\u003cli\u003e배포 매니페스트를 Kubernetes 클러스터에 적용합니다\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e제가 Kind를 사용하고 있기 때문에, 3단계를 간단한 로드 단계로 대체할 수 있습니다. 이렇게 하면 Docker 저장소를 사용할 필요가 없습니다.\u003c/p\u003e\n\u003ch2\u003e프로필\u003c/h2\u003e\n\u003cp\u003eJAR 파일을 생성하기 전에 Spring Boot 프로필 두 개를 생성하는 것이 유용합니다. 이를 통해 애플리케이션을 연결된 모드 (지금까지 한 것처럼) 및 Kubernetes 클러스터 내에서 실행할 수 있습니다. Spring Boot 프로필 두 개를 생성하겠습니다:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003econnected\u003c/code\u003e ... 클러스터 외부에서 실행 중일 때 사용되는 모드\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003elocal-cluster\u003c/code\u003e ... 클러스터 내부에서 실행 중일 때 사용되는 모드\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e현재 실행 중인 모드는 첫 번째입니다. 이는 우리가 간단히 application.yml(또는 application.properties) 파일을 application-connected.yml로 복사할 수 있다는 것을 의미합니다. 그런 다음 JVM 명령줄에 다음 JVM 인수를 추가할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e-\u003cspan class=\"hljs-title class_\"\u003eDspring\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eprofiles\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eactive\u003c/span\u003e=connected\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e로컬 클러스터 파일에 대해서도 동일한 작업을 수행하지만 이번에는 변경이 필요합니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e...\n  \u003cspan class=\"hljs-attr\"\u003edata\u003c/span\u003e:\n    \u003cspan class=\"hljs-attr\"\u003emongodb\u003c/span\u003e:\n      \u003cspan class=\"hljs-attr\"\u003ehost\u003c/span\u003e: my-mongo-db-svc.\u003cspan class=\"hljs-property\"\u003emongo\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003esvc\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ecluster\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003elocal\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003eport\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e27017\u003c/span\u003e\n...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eDNS 이름을 사용하여 올바른 팟에 연결할 수 있습니다. 팟에서 DNS 검색 규칙이 설정되어 있어 my-mongo-db-svc.mongo.svc와 같은 이름 일부를 생략할 수 있습니다. 이를 통해 다른 클러스터로 배포하고도 응용 프로그램이 작동할 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e이미지 생성\u003c/h2\u003e\n\u003cp\u003e이제 이미지를 만드는 방법을 살펴보겠습니다. GitHub에 있는 프로젝트가 Gradle 프로젝트이므로 루트 프로젝트 폴더에서 다음과 같이 JAR 파일을 생성할 수 있습니다:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003egradle build\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003egradle.build에 아래 내용이 추가되었음을 유의해주세요. 이는 manifest가 주 애플리케이션 파일을 가리키도록 합니다:\u003c/p\u003e\n\u003cp\u003egradle.build\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ejar {\n    manifest {\n        attributes \u003cspan class=\"hljs-string\"\u003e\"Main-Class\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"com.requillion_solutions.aquarium.AquariumWithMongoDbApplication\"\u003c/span\u003e\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이렇게 하면 jar 파일이 생성됩니다: build/libs/aquarium-with-mongo-db-0.0.1-SNAPSHOT.jar.\u003c/p\u003e\n\u003cp\u003e도커 이미지를 만들기 위해서는 도커 파일이 필요합니다. 아래 내용대로 만들어보세요:\u003c/p\u003e\n\u003cp\u003eDockerfile\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eopenjdk\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e17.0\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.2\u003c/span\u003e-slim-buster\n\u003cspan class=\"hljs-variable constant_\"\u003eRUN\u003c/span\u003e addgroup --system spring \u0026#x26;\u0026#x26; useradd --system spring -g spring\n\u003cspan class=\"hljs-variable constant_\"\u003eUSER\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003espring\u003c/span\u003e:spring\n\u003cspan class=\"hljs-variable constant_\"\u003eARG\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eJAR_FILE\u003c/span\u003e=build/libs\u003cspan class=\"hljs-comment\"\u003e/*.jar\nCOPY ${JAR_FILE} app.jar\nENTRYPOINT [\"java\",\"-jar\",\"/app.jar\"]\nEXPOSE 8080\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이는 Java 17 기반 이미지를 시작으로 합니다 (이것은 롬복과의 문제를 피하기 위해 필요합니다) 그리고 새 사용자 (spring)를 추가하여 루트로 실행하지 않도록 합니다. 그런 다음 JAR 파일이 이미지로 복사되고 응용 프로그램을 실행하는 엔트리포인트가 생성됩니다.\u003c/p\u003e\n\u003cp\u003e다음 명령어로 도커 이미지를 생성하세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003edocker build -t aquarium .\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그리고 만약 Kind를 사용 중이라면, 다음 명령어로 직접 Kubernetes 클러스터에 로드하세요:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ekind load docker-image aquarium\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 작업이 완료되면 클러스터에서 실행하기 위한 배포 매니페스트를 생성할 준비가 되었습니다.\u003c/p\u003e\n\u003ch2\u003e배포 매니페스트\u003c/h2\u003e\n\u003cp\u003e이제 쿠버네티스 클러스터에 도커 이미지를 로드했으므로 배포 매니페스트를 사용하여 배포할 수 있습니다. 다음 파일을 만들어주세요:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003ek8s/deployment.yml\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-yaml\"\u003e\u003cspan class=\"hljs-attr\"\u003eapiVersion:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eapps/v1\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003ekind:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eDeployment\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003emetadata:\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003ename:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eaquarium\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003enamespace:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003edefault\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003espec:\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003ereplicas:\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003eselector:\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003ematchLabels:\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003eapp:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eaquarium\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003etemplate:\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003emetadata:\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003elabels:\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003eapp:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eaquarium\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003espec:\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003econtainers:\u003c/span\u003e\n        \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ename:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eaquarium\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003eimage:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eaquarium\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003eimagePullPolicy:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eIfNotPresent\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003eports:\u003c/span\u003e\n            \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003econtainerPort:\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e8080\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003eenv:\u003c/span\u003e\n            \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ename:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eSPRING_PROFILES_ACTIVE\u003c/span\u003e\n              \u003cspan class=\"hljs-attr\"\u003evalue:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003elocal-cluster\u003c/span\u003e\n\u003cspan class=\"hljs-meta\"\u003e---\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003eapiVersion:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ev1\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003ekind:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eService\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003emetadata:\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003ename:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eaquarium\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003enamespace:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003edefault\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003espec:\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003eselector:\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003eapp:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eaquarium\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003etype:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eNodePort\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003eports:\u003c/span\u003e\n    \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eport:\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e8080\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003etargetPort:\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e8080\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003enodePort:\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e30080\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e알아두어야 할 사항이 몇 가지 있어요:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e어플리케이션이 default 네임스페이스에 배포되었어요 (네임스페이스가 지정되지 않으면 사용되는 곳이죠)\u003c/li\u003e\n\u003cli\u003e레플리카는 1개뿐이에요\u003c/li\u003e\n\u003cli\u003e이미지는 이전에 불러왔으므로, 이미지가 없을 때만 불러와요\u003c/li\u003e\n\u003cli\u003e프로필은 local-cluster로 설정돼요\u003c/li\u003e\n\u003cli\u003e서비스가 생성되어 어플리케이션의 포트 8080을 개발 머신의 포트 30080으로 매핑돼요\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이제 다음과 같이 배포할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ekubectl apply -f k8s/deployment.\u003cspan class=\"hljs-property\"\u003eyml\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e시작이 성공적으로 이루어졌는지 확인해보세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ekubectl get pods\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e한 번이 배포되면 API는 이전에 사용한 것과 동일한 curl 명령으로 테스트할 수 있습니다. 단, 포트를 30080으로 변경해 주세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ecurl \u003cspan class=\"hljs-attr\"\u003elocalhost\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e30080\u003c/span\u003e/api/v1/fishes -H \u003cspan class=\"hljs-string\"\u003e\"Content-Type: application/json\"\u003c/span\u003e -d \u003cspan class=\"hljs-string\"\u003e'{\"type\": \"guppy2\"}'\u003c/span\u003e\ncurl \u003cspan class=\"hljs-attr\"\u003elocalhost\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e30080\u003c/span\u003e/api/v1/fish-tanks -H \u003cspan class=\"hljs-string\"\u003e\"Content-Type: application/json\"\u003c/span\u003e -d \u003cspan class=\"hljs-string\"\u003e'{\"name\": \"big one\"}'\u003c/span\u003e\ncurl \u003cspan class=\"hljs-attr\"\u003elocalhost\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e30080\u003c/span\u003e/api/v1/fishes\ncurl \u003cspan class=\"hljs-attr\"\u003elocalhost\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e30080\u003c/span\u003e/api/v1/fish-tanks\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eCompass UI에서 새 문서를 확인할 수도 있습니다 (포트 포워드가 여전히 유지되는지 확인해 주세요).\u003c/p\u003e\n\u003ch1\u003e요약\u003c/h1\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이 기사는 Kind Kubernetes 클러스터로 MongoDB를 설치하고 Spring Boot 애플리케이션과 통합하는 과정에 대해 다루었습니다.\u003c/p\u003e\n\u003cp\u003e이 연습은 꽤 간단하지만 그냥 어떻게 하는지 보여주는 것뿐입니다. 실제로는 보안, 백업 및 장애 조치에 작업이 필요할 것입니다.\u003c/p\u003e\n\u003cp\u003e다른 기사에서는 문서간의 관계를 어떻게 관리할 수 있는지도 보여드릴 예정입니다.\u003c/p\u003e\n\u003cp\u003e이 연습을 통해 No-SQL 데이터베이스가 Kubernetes와 Spring Boot와 간단하게 사용될 수 있다는 것을 보여줬으면 좋겠습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이 글을 즐겁게 읽으셨기를 바라며, 새로운 것을 배우며 기술을 향상시켰기를 바랍니다. 작은 거라도 새로운 지식을 얻었다면 좋겠네요.\u003c/p\u003e\n\u003cp\u003e이 글이 유익하게 느껴진다면, 박수 한 번 부탁드립니다. 그렇게 하면 미래에 어떤 글을 써야 하는지 파악할 수 있고, 다음 글을 결정하는 데 도움이 됩니다. 개선 사항이나 제안 사항이 있다면 메모나 답글로 추가해 주세요.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-19-MyexperienceaddingaMongoDBNo-SQLdatabasetomyKubernetescluster"},"buildId":"GsgRekSb--BvxYwv9FPn6","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>