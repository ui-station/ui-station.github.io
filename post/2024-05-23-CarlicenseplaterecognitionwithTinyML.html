<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>작은 인공지능을 활용한 자동차 번호판 인식 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-05-23-CarlicenseplaterecognitionwithTinyML" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="작은 인공지능을 활용한 자동차 번호판 인식 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="작은 인공지능을 활용한 자동차 번호판 인식 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-23-CarlicenseplaterecognitionwithTinyML_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-05-23-CarlicenseplaterecognitionwithTinyML" data-gatsby-head="true"/><meta name="twitter:title" content="작은 인공지능을 활용한 자동차 번호판 인식 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-23-CarlicenseplaterecognitionwithTinyML_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-23 16:37" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-4f7b40c1114f0d09.js" defer=""></script><script src="/_next/static/YUMR4jSyk_WlOHHc7UfOk/_buildManifest.js" defer=""></script><script src="/_next/static/YUMR4jSyk_WlOHHc7UfOk/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">작은 인공지능을 활용한 자동차 번호판 인식</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="작은 인공지능을 활용한 자동차 번호판 인식" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 23, 2024</span><span class="posts_reading_time__f7YPP">13<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-23-CarlicenseplaterecognitionwithTinyML&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h2>엣지 임펄스와 아두이노를 이용해 엣지에서 클라우드까지</h2>
<p>본 기사는 EU 및 스위스 차량 번호판을 감지하는 용도로 설계된 자동차 번호판 인식 시스템에 대한 자세한 소개를 제공합니다. 컴퓨터 비전과 머신 러닝 기술을 활용하여, 이 시스템은 번호판을 식별하고 분류하여 결과를 화면에 표시합니다. 해당 시스템은 차량 출입지역에서 차량의 출발지에 따라 적용되는 요금이 다른 유료 주차장 시나리오에 사용하기 위한 것입니다.</p>
<p>사용자들은 원격 웹 대시보드를 통해 주차 지역으로의 출입 횟수 통계를 확인할 수도 있습니다.</p>
<p><img src="/assets/img/2024-05-23-CarlicenseplaterecognitionwithTinyML_0.png" alt="차량 번호판 인식 시스템"></p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>어떻게 하나요?</h1>
<p>이 시스템의 구현은 Arduino와 Edge Impulse를 사용하여 하드웨어, 소프트웨어 및 클라우드 서비스를 결합하는 과정을 포함합니다.</p>
<ul>
<li>Arduino는 사용하기 쉬운 하드웨어와 소프트웨어에 기반한 오픈 소스 플랫폼입니다. Arduino는 Arduino IoT Cloud라는 클라우드 서비스도 제공하는데, 이를 통해 장치의 손쉬운 연결, 데이터 저장 및 원격 관리가 가능합니다.</li>
<li>Edge Impulse는 임베디드 장치용 머신 러닝 모델을 생성하고 배포하는 플랫폼입니다. 개발자들이 Arduino와 같은 하드웨어에 직접 머신 러닝 모델을 생성, 훈련 및 배포할 수 있도록 지원합니다.</li>
</ul>
<p><img src="/assets/img/2024-05-23-CarlicenseplaterecognitionwithTinyML_1.png" alt="이미지"></p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>하드웨어 시스템은 세 가지 주요 노드로 구성되어 있습니다:</p>
<ul>
<li>Nicla Vision: 이미지 획득과 엣지 임퍼스로 생성된 ML 모델을 사용한 번호판 인식에 특화된 노드입니다. 이미지를 캡처하고 훈련된 머신 러닝 모델을 통해 처리합니다. 인식된 번호판 유형 데이터는 이후 Giga R1 WiFi 보드로 전송됩니다.</li>
<li>Giga R1 WiFi: Nicla Vision 노드에서 데이터 수신을 처리하고 Arduino IoT Cloud와 통신하여 원격 대시보드를 관리합니다. 또한 로컬 대시보드 시각화를 위한 디스플레이를 제어합니다.</li>
<li>Giga Display Shield: Giga R1 WiFi 보드에 연결된 디스플레이 구성 요소입니다. 로컬 대시보드의 시각화를 위한 인터페이스로 작동합니다.</li>
</ul>
<p><img src="/assets/img/2024-05-23-CarlicenseplaterecognitionwithTinyML_2.png" alt="이미지"></p>
<p><img src="/assets/img/2024-05-23-CarlicenseplaterecognitionwithTinyML_3.png" alt="이미지"></p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>엣지 컴퓨팅에 관해...</h1>
<p>엣지 컴퓨팅은 데이터를 원산지에 더 가까운 위치에서 처리하는 것을 의미하며, 원격 서버로 데이터를 보내서 처리하는 방식보다 더 빠르고 효율적입니다.</p>
<p>주차 관리 시스템에서는 Nicla Vision이 엣지 노드로 작동하여 이미지를 처리하고 로컬에서 머신러닝 모델을 실행합니다.
엣지 기기에서 머신러닝 모델을 실행하는 것을 TinyML이라고 합니다.</p>
<p>TinyML은 마이크로컨트롤러와 같은 작고 저전력 장치에 머신러닝 모델을 배포하는 것을 의미합니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이 프로젝트의 ML 모델은 이미지를 입력으로 받아들이고 이를 EU 및 Swiss 두 가지 카테고리로 분류합니다.
이 작업은 이미지 분류로 알려져 있으며 지도학습(machine learning)의 범주에 속합니다. 지도학습은 각 입력이 해당하는 출력 레이블과 관련된 레이블이 있는 데이터 집합을 기반으로 모델을 교육하는 것을 포함합니다.</p>
<p><img src="/assets/img/2024-05-23-CarlicenseplaterecognitionwithTinyML_4.png" alt="이미지"></p>
<h2>ML 모델을 어떻게 구축할까요?</h2>
<p>Tiny Machine Learning 모델을 구축하는 과정은 4단계로 이루어집니다:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>데이터 수집</li>
<li>데이터 전처리</li>
<li>모델 학습</li>
<li>엣지에 배포</li>
</ul>
<p><img src="/assets/img/2024-05-23-CarlicenseplaterecognitionwithTinyML_5.png" alt="image"></p>
<h2>OpenMV 및 Edge Impulse를 사용한 데이터 수집</h2>
<p>이 단계에서는 기계 학습 모델을 훈련시키기 위한 관련 데이터를 수집합니다. 이 프로젝트의 경우 OpenMV를 사용하여 EU 및 스위스의 번호판이 포함된 이미지 세트를 수집하는 것을 포함합니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>OpenMV는 머신 비전 작업에 디자인된 마이크로컨트롤러 기반 플랫폼으로, 다양한 카메라 센서와 MicroPython을 실행할 수 있습니다. 엣지 디바이스에서 이미지를 캡처하는 간단하고 효율적인 솔루션을 제공합니다.</p>
<p><img src="/assets/img/2024-05-23-CarlicenseplaterecognitionwithTinyML_6.png" alt="이미지"></p>
<p>OpenMV를 사용하면 빠르게 MicroPython 스크립트를 만들어 다양한 이미지 데이터셋을 효율적으로 생성할 수 있습니다.</p>
<p><img src="/assets/img/2024-05-23-CarlicenseplaterecognitionwithTinyML_7.png" alt="이미지"></p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>Edge Impulse</h2>
<p>이전에 설명했듯이, Edge Impulse는 개발자가 모든 단계에서 도움을 받으며 TinyML 모델을 생성하는 과정을 완전히 지원합니다.</p>
<p><img src="/assets/img/2024-05-23-CarlicenseplaterecognitionwithTinyML_8.png" alt="image"></p>
<h2>데이터 수집 및 전처리</h2>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>OpenMV는 Edge Impulse와 통합하여 데이터 수집 프로세스를 더욱 간단하게 만들어줍니다. 이를 통해 외부 도구가 필요하지 않고 이미지 데이터셋을 직접 업로드할 수 있습니다.</p>
<p><img src="/assets/img/2024-05-23-CarlicenseplaterecognitionwithTinyML_9.png" alt="이미지"></p>
<p>데이터 수집 후에는 특성 추출을 수행하는 것이 중요합니다. 이는 원시 데이터가 특성 집합으로 변환되는 과정입니다.</p>
<p>머신 러닝에서 특성은 특정 작업을 해결하는 데 관련이 있는 원시 데이터에서 추출된 특정한 특징을 가리킵니다. 이미지 처리 문제에서는 이미지에 존재하는 가장자리, 질감, 모양 또는 패턴과 같은 특성이 포함될 수 있습니다. Edge Impulse는 이미지에서 자동으로 특성을 추출할 수 있어 이를 통해 데이터 내에서 가장 관련성이 높은 정보를 식별하고 집중함으로써 모델 학습 프로세스를 간소화할 수 있습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>모델 훈련</h2>
<p>모델 훈련은 사전 처리된 데이터를 기계 학습 알고리즘에 공급하여 입력 특성(플레이트의 이미지 특성)과 출력 레이블(EU 또는 Swiss) 간의 관계를 학습하는 과정을 말합니다.</p>
<p>Edge Impulse는 미리 제작된 모델 아키텍처 또는 사용자 정의 모델 아키텍처를 선택하고, 훈련 주기와 학습률과 같은 모델 설정을 조정할 수 있는 기능을 제공합니다.</p>
<p><img src="/assets/img/2024-05-23-CarlicenseplaterecognitionwithTinyML_10.png" alt="Image"></p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>모델의 효과성은 정확도 지표(F1 점수)를 사용하여 평가되며, 이는 모델이 예측에서 얼마나 정확한지를 나타냅니다.</p>
<p>첫 번째 시도에서 우리는 72%의 정확도를 달성했지만 아직 허용할만한 수준이 아닙니다. F1 점수를 향상시키려면, 훈련 주기를 늘리거나 모델 아키텍처를 변경하거나 데이터셋의 품질을 개선할 수 있습니다(잡음을 줄이고, 서로 다른 배경을 처리하고, 정확하게 라벨을 지정하고, 양을 늘리는 등).</p>
<p><img src="/assets/img/2024-05-23-CarlicenseplaterecognitionwithTinyML_11.png" alt="이미지"></p>
<h2>배포</h2>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>Edge Impulse는 하드웨어에 독립적이므로 모델을 어떤 엣지 장치에도 배포할 수 있어요.</p>
<p><img src="/assets/img/2024-05-23-CarlicenseplaterecognitionwithTinyML_12.png" alt="image1"></p>
<p>대부분의 아두이노 보드와 호환되는 아두이노 라이브러리를 빌드하고 다운로드할 수 있어요. 모델은 .c 및 .h 파일로 변환되어 /src 디렉토리에 저장되며, /examples 디렉토리에 다양한 예제도 포함돼요.</p>
<p><img src="/assets/img/2024-05-23-CarlicenseplaterecognitionwithTinyML_13.png" alt="image2"></p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>The Edge sketch</h2>
<p>Nicla Vision에서 실행되는 스케치의 주요 기능은 다음과 같습니다:</p>
<ul>
<li>내장 카메라에서 이미지 획득.</li>
<li>라이선스 플레이트 클래스를 결정하기 위해 머신 러닝 모델 실행.</li>
<li>처리 결과를 시리얼 통신을 통해 로컬 및 원격 대시보드를 관리하는 노드에 전송합니다.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-comment">// Edge Impulse 모델 라이브러리 포함</span>
#include &#x3C;eu-swiss-plate-recognition_inferencing.<span class="hljs-property">h</span>>

<span class="hljs-keyword">void</span> <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>)
{
  <span class="hljs-comment">// ...</span>
  <span class="hljs-comment">// 내장 카메라 초기화</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">ei_camera_init</span>() == <span class="hljs-literal">false</span>) {
      <span class="hljs-title function_">ei_printf</span>(<span class="hljs-string">"Failed to initialize Camera!\r\n"</span>);
      <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) ;
  }
  <span class="hljs-comment">// ...</span>
  <span class="hljs-comment">// 대시보드 노드와의 시리얼 통신 초기화</span>
  <span class="hljs-title class_">Serial1</span>.<span class="hljs-title function_">begin</span>(<span class="hljs-number">115200</span>);
}

<span class="hljs-keyword">void</span> <span class="hljs-title function_">loop</span>(<span class="hljs-params"></span>)
{
  <span class="hljs-comment">// ...</span>
  <span class="hljs-comment">// 내장 카메라에서 이미지 획득</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">ei_camera_capture</span>(...) == <span class="hljs-literal">false</span>) {
      <span class="hljs-title function_">ei_printf</span>(<span class="hljs-string">"Failed to capture image\r\n"</span>);
      <span class="hljs-keyword">return</span>;
  }

  <span class="hljs-comment">// ...</span>
  <span class="hljs-comment">// ML 모델 실행</span>
  ei_impulse_result_t result = { <span class="hljs-number">0</span> };
  <span class="hljs-variable constant_">EI_IMPULSE_ERROR</span> err = <span class="hljs-title function_">run_classifier</span>(&#x26;signal, &#x26;result, debug_nn);

  <span class="hljs-comment">// ...</span>
  <span class="hljs-comment">// 예측 결과 파싱</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">strcmp</span>(..., <span class="hljs-string">"swiss"</span>) == <span class="hljs-number">0</span>) {
      pred_result = <span class="hljs-string">'S'</span>;
      <span class="hljs-keyword">break</span>;
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-title function_">strcmp</span>(..., <span class="hljs-string">"eu"</span>) == <span class="hljs-number">0</span>) {
      pred_result = <span class="hljs-string">'E'</span>;
      <span class="hljs-keyword">break</span>;
  }

  <span class="hljs-comment">// ...</span>
  <span class="hljs-comment">// 처리 결과를 시리얼을 통해 대시보드 노드로 전송</span>
  <span class="hljs-title class_">Serial1</span>.<span class="hljs-title function_">print</span>(pred_result);
}
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>…클라우드로</h1>
<p>아두이노 IoT 클라우드는 아두이노의 클라우드에서 IoT 프로젝트를 개발하기 위한 솔루션입니다. 이를 통해 사용자는 장치에서 보낸 데이터를 저장하고 검색하여 실시간 모니터링과 제어를 할 수 있습니다.</p>
<p>알림 기능을 제공하며 사전 구축된 위젯을 사용하여 제어 대시보드를 만들기 위한 사용자 친화적 인터페이스를 제공하여 데이터 시각화 및 관리를 간소화합니다.</p>
<p>이 플랫폼은 아두이노 보드 및 ESP32과 같은 제3자 장치를 포함한 다양한 장치와 호환됩니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>클라우드 스케치</h2>
<p>아두이노 IoT 클라우드 플랫폼에서는 프로젝트 설계 중 사용자가 지정한 구성 및 설정에 기초하여 장치를 위한 스케치가 자동으로 생성됩니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 클라우드 변수 및 네트워크 인증 정보를 포함한 파일</span>
#include <span class="hljs-string">"thingProperties.h"</span>

<span class="hljs-keyword">void</span> <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">// ...</span>
  <span class="hljs-comment">// thingProperties.h에서 정의된 속성 초기화</span>
  <span class="hljs-title function_">initProperties</span>();

  <span class="hljs-comment">// 아두이노 IoT 클라우드에 연결</span>
  <span class="hljs-title class_">ArduinoCloud</span>.<span class="hljs-title function_">begin</span>(<span class="hljs-title class_">ArduinoIoTPreferredConnection</span>);
  <span class="hljs-comment">// ...</span>
}

<span class="hljs-keyword">void</span> <span class="hljs-title function_">loop</span>(<span class="hljs-params"></span>) {
  <span class="hljs-title class_">ArduinoCloud</span>.<span class="hljs-title function_">update</span>();  <span class="hljs-comment">// 클라우드 변수와 통신 업데이트</span>
  <span class="hljs-comment">// ...</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Serial1</span>.<span class="hljs-title function_">available</span>()) {
    char inByte = <span class="hljs-title class_">Serial1</span>.<span class="hljs-title function_">read</span>(); <span class="hljs-comment">// 에지 노드에서 오는 결과 읽기</span>

    <span class="hljs-keyword">if</span> (inByte == <span class="hljs-string">'E'</span>) {
      region = <span class="hljs-variable constant_">REGION_EU</span>; <span class="hljs-comment">// 'region'은 클라우드 변수입니다</span>
      <span class="hljs-comment">// ...</span>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (inByte == <span class="hljs-string">'S'</span>) {
      region = <span class="hljs-variable constant_">REGION_SWISS</span>;
      <span class="hljs-comment">// ...</span>
    }
    <span class="hljs-comment">// ...</span>
  }
  <span class="hljs-comment">// ...</span>
}
</code></pre>
<h2>대시보드</h2>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>아두이노 IoT 클라우드는 사용자가 쉽게 사용할 수 있는 위젯을 활용하여 직관적인 대시보드를 생성할 수 있는 기능을 제공합니다. 사용자들은 이러한 위젯을 장치에서 사용되는 클라우드 변수에 쉽게 연결할 수 있어 데이터 시각화와 관리 과정을 간편화할 수 있습니다.</p>
<p><img src="/assets/img/2024-05-23-CarlicenseplaterecognitionwithTinyML_14.png" alt="image"></p>
<p><img src="/assets/img/2024-05-23-CarlicenseplaterecognitionwithTinyML_15.png" alt="image"></p>
<h1>GUI 소개</h1>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>Giga Display Shield로 관리되는 GUI는 로컬 대시보드인 인식된 자동차 번호판 유형을 보여줍니다. 디스플레이 관리는 Arduino_GigaDisplay_GFX 라이브러리에 의해 제어됩니다.</p>
<p>Arduino_GigaDisplay_GFX는 Adafruit_GFX 라이브러리 위에 구축된 라이브러리입니다. 개별 픽셀, 선, 사각형 및 기타 기하학적 모양을 그리는 기능을 제공합니다. 또한 숫자 값 및 문자열을 출력하는 기능을 지원합니다.</p>
<pre><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"Arduino_GigaDisplay_GFX.h"</span></span>

GigaDisplay_GFX display;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-comment">// ...</span>
  display.<span class="hljs-built_in">begin</span>();
  display.<span class="hljs-built_in">setRotation</span>(<span class="hljs-number">1</span>);
  <span class="hljs-comment">// ...</span>
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">loop</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">if</span> (Serial1.<span class="hljs-built_in">available</span>()) {
    <span class="hljs-comment">// ...</span>
    <span class="hljs-keyword">if</span> (inByte == <span class="hljs-string">'E'</span>) {
      <span class="hljs-comment">// ...</span>
      <span class="hljs-built_in">drawEUFlag</span>();
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (inByte == <span class="hljs-string">'S'</span>) {
      <span class="hljs-comment">// ...</span>
      <span class="hljs-built_in">drawSwissFlag</span>();
    }
    <span class="hljs-comment">// ...</span>
  }
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">drawEUFlag</span><span class="hljs-params">()</span> </span>{
  display.<span class="hljs-built_in">fillScreen</span>(BLUE);
  display.<span class="hljs-built_in">setCursor</span>(<span class="hljs-number">350</span>, <span class="hljs-number">400</span>);
  display.<span class="hljs-built_in">setTextSize</span>(<span class="hljs-number">10</span>);
  display.<span class="hljs-built_in">print</span>(<span class="hljs-string">"EU"</span>);

  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &#x3C; <span class="hljs-number">12</span>; i++) {
    <span class="hljs-built_in">drawStar</span>(CENTER_X + (UE_FLAG_RADIUS * <span class="hljs-built_in">cos</span>(i * PI / <span class="hljs-number">6</span>)), CENTER_Y + (UE_FLAG_RADIUS * <span class="hljs-built_in">sin</span>(i * PI / <span class="hljs-number">6</span>)));
  }
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">drawStar</span><span class="hljs-params">(uint x, uint y)</span> </span>{
  display.<span class="hljs-built_in">setCursor</span>(x, y);
  display.<span class="hljs-built_in">setTextColor</span>(YELLOW);
  display.<span class="hljs-built_in">setTextSize</span>(<span class="hljs-number">3</span>);
  display.<span class="hljs-built_in">print</span>(<span class="hljs-string">"*"</span>);
  display.<span class="hljs-built_in">setTextColor</span>(WHITE);
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">drawSwissFlag</span><span class="hljs-params">()</span> </span>{
  display.<span class="hljs-built_in">fillScreen</span>(RED);
  display.<span class="hljs-built_in">setCursor</span>(<span class="hljs-number">350</span>, <span class="hljs-number">400</span>);
  display.<span class="hljs-built_in">setTextSize</span>(<span class="hljs-number">10</span>);
  display.<span class="hljs-built_in">print</span>(<span class="hljs-string">"CH"</span>);

  display.<span class="hljs-built_in">fillRect</span>(CENTER_X - SWISS_FLAG_THICKNESS / <span class="hljs-number">2</span>, CENTER_Y - SWISS_FLAG_LENGTH / <span class="hljs-number">2</span>, SWISS_FLAG_THICKNESS, SWISS_FLAG_LENGTH, WHITE);
  display.<span class="hljs-built_in">fillRect</span>(CENTER_X - SWISS_FLAG_LENGTH / <span class="hljs-number">2</span>, CENTER_Y - SWISS_FLAG_THICKNESS / <span class="hljs-number">2</span>, SWISS_FLAG_LENGTH, SWISS_FLAG_THICKNESS, WHITE);
}
</code></pre>
<p><img src="/assets/img/2024-05-23-CarlicenseplaterecognitionwithTinyML_16.png" alt="Car License Plate Recognition with TinyML"></p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>참고 자료</h1>
<ul>
<li>코드:
<a href="https://github.com/csarnataro/arduino-tinyml-plate-recognition" rel="nofollow" target="_blank">https://github.com/csarnataro/arduino-tinyml-plate-recognition</a></li>
<li>이탈리안 임베디드 이벤트: <a href="https://www.italianembedded.com/events/arduino-ml/" rel="nofollow" target="_blank">https://www.italianembedded.com/events/arduino-ml/</a></li>
</ul>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"작은 인공지능을 활용한 자동차 번호판 인식","description":"","date":"2024-05-23 16:37","slug":"2024-05-23-CarlicenseplaterecognitionwithTinyML","content":"\n## 엣지 임펄스와 아두이노를 이용해 엣지에서 클라우드까지\n\n본 기사는 EU 및 스위스 차량 번호판을 감지하는 용도로 설계된 자동차 번호판 인식 시스템에 대한 자세한 소개를 제공합니다. 컴퓨터 비전과 머신 러닝 기술을 활용하여, 이 시스템은 번호판을 식별하고 분류하여 결과를 화면에 표시합니다. 해당 시스템은 차량 출입지역에서 차량의 출발지에 따라 적용되는 요금이 다른 유료 주차장 시나리오에 사용하기 위한 것입니다.\n\n사용자들은 원격 웹 대시보드를 통해 주차 지역으로의 출입 횟수 통계를 확인할 수도 있습니다.\n\n![차량 번호판 인식 시스템](/assets/img/2024-05-23-CarlicenseplaterecognitionwithTinyML_0.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 어떻게 하나요?\n\n이 시스템의 구현은 Arduino와 Edge Impulse를 사용하여 하드웨어, 소프트웨어 및 클라우드 서비스를 결합하는 과정을 포함합니다.\n\n- Arduino는 사용하기 쉬운 하드웨어와 소프트웨어에 기반한 오픈 소스 플랫폼입니다. Arduino는 Arduino IoT Cloud라는 클라우드 서비스도 제공하는데, 이를 통해 장치의 손쉬운 연결, 데이터 저장 및 원격 관리가 가능합니다.\n- Edge Impulse는 임베디드 장치용 머신 러닝 모델을 생성하고 배포하는 플랫폼입니다. 개발자들이 Arduino와 같은 하드웨어에 직접 머신 러닝 모델을 생성, 훈련 및 배포할 수 있도록 지원합니다.\n\n![이미지](/assets/img/2024-05-23-CarlicenseplaterecognitionwithTinyML_1.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n하드웨어 시스템은 세 가지 주요 노드로 구성되어 있습니다:\n\n- Nicla Vision: 이미지 획득과 엣지 임퍼스로 생성된 ML 모델을 사용한 번호판 인식에 특화된 노드입니다. 이미지를 캡처하고 훈련된 머신 러닝 모델을 통해 처리합니다. 인식된 번호판 유형 데이터는 이후 Giga R1 WiFi 보드로 전송됩니다.\n- Giga R1 WiFi: Nicla Vision 노드에서 데이터 수신을 처리하고 Arduino IoT Cloud와 통신하여 원격 대시보드를 관리합니다. 또한 로컬 대시보드 시각화를 위한 디스플레이를 제어합니다.\n- Giga Display Shield: Giga R1 WiFi 보드에 연결된 디스플레이 구성 요소입니다. 로컬 대시보드의 시각화를 위한 인터페이스로 작동합니다.\n\n![이미지](/assets/img/2024-05-23-CarlicenseplaterecognitionwithTinyML_2.png)\n\n![이미지](/assets/img/2024-05-23-CarlicenseplaterecognitionwithTinyML_3.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 엣지 컴퓨팅에 관해...\n\n엣지 컴퓨팅은 데이터를 원산지에 더 가까운 위치에서 처리하는 것을 의미하며, 원격 서버로 데이터를 보내서 처리하는 방식보다 더 빠르고 효율적입니다.\n\n주차 관리 시스템에서는 Nicla Vision이 엣지 노드로 작동하여 이미지를 처리하고 로컬에서 머신러닝 모델을 실행합니다.\n엣지 기기에서 머신러닝 모델을 실행하는 것을 TinyML이라고 합니다.\n\nTinyML은 마이크로컨트롤러와 같은 작고 저전력 장치에 머신러닝 모델을 배포하는 것을 의미합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 프로젝트의 ML 모델은 이미지를 입력으로 받아들이고 이를 EU 및 Swiss 두 가지 카테고리로 분류합니다.\n이 작업은 이미지 분류로 알려져 있으며 지도학습(machine learning)의 범주에 속합니다. 지도학습은 각 입력이 해당하는 출력 레이블과 관련된 레이블이 있는 데이터 집합을 기반으로 모델을 교육하는 것을 포함합니다.\n\n![이미지](/assets/img/2024-05-23-CarlicenseplaterecognitionwithTinyML_4.png)\n\n## ML 모델을 어떻게 구축할까요?\n\nTiny Machine Learning 모델을 구축하는 과정은 4단계로 이루어집니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 데이터 수집\n- 데이터 전처리\n- 모델 학습\n- 엣지에 배포\n\n![image](/assets/img/2024-05-23-CarlicenseplaterecognitionwithTinyML_5.png)\n\n## OpenMV 및 Edge Impulse를 사용한 데이터 수집\n\n이 단계에서는 기계 학습 모델을 훈련시키기 위한 관련 데이터를 수집합니다. 이 프로젝트의 경우 OpenMV를 사용하여 EU 및 스위스의 번호판이 포함된 이미지 세트를 수집하는 것을 포함합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nOpenMV는 머신 비전 작업에 디자인된 마이크로컨트롤러 기반 플랫폼으로, 다양한 카메라 센서와 MicroPython을 실행할 수 있습니다. 엣지 디바이스에서 이미지를 캡처하는 간단하고 효율적인 솔루션을 제공합니다.\n\n![이미지](/assets/img/2024-05-23-CarlicenseplaterecognitionwithTinyML_6.png)\n\nOpenMV를 사용하면 빠르게 MicroPython 스크립트를 만들어 다양한 이미지 데이터셋을 효율적으로 생성할 수 있습니다.\n\n![이미지](/assets/img/2024-05-23-CarlicenseplaterecognitionwithTinyML_7.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## Edge Impulse\n\n이전에 설명했듯이, Edge Impulse는 개발자가 모든 단계에서 도움을 받으며 TinyML 모델을 생성하는 과정을 완전히 지원합니다.\n\n![image](/assets/img/2024-05-23-CarlicenseplaterecognitionwithTinyML_8.png)\n\n## 데이터 수집 및 전처리\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nOpenMV는 Edge Impulse와 통합하여 데이터 수집 프로세스를 더욱 간단하게 만들어줍니다. 이를 통해 외부 도구가 필요하지 않고 이미지 데이터셋을 직접 업로드할 수 있습니다.\n\n![이미지](/assets/img/2024-05-23-CarlicenseplaterecognitionwithTinyML_9.png)\n\n데이터 수집 후에는 특성 추출을 수행하는 것이 중요합니다. 이는 원시 데이터가 특성 집합으로 변환되는 과정입니다.\n\n머신 러닝에서 특성은 특정 작업을 해결하는 데 관련이 있는 원시 데이터에서 추출된 특정한 특징을 가리킵니다. 이미지 처리 문제에서는 이미지에 존재하는 가장자리, 질감, 모양 또는 패턴과 같은 특성이 포함될 수 있습니다. Edge Impulse는 이미지에서 자동으로 특성을 추출할 수 있어 이를 통해 데이터 내에서 가장 관련성이 높은 정보를 식별하고 집중함으로써 모델 학습 프로세스를 간소화할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 모델 훈련\n\n모델 훈련은 사전 처리된 데이터를 기계 학습 알고리즘에 공급하여 입력 특성(플레이트의 이미지 특성)과 출력 레이블(EU 또는 Swiss) 간의 관계를 학습하는 과정을 말합니다.\n\nEdge Impulse는 미리 제작된 모델 아키텍처 또는 사용자 정의 모델 아키텍처를 선택하고, 훈련 주기와 학습률과 같은 모델 설정을 조정할 수 있는 기능을 제공합니다.\n\n![Image](/assets/img/2024-05-23-CarlicenseplaterecognitionwithTinyML_10.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n모델의 효과성은 정확도 지표(F1 점수)를 사용하여 평가되며, 이는 모델이 예측에서 얼마나 정확한지를 나타냅니다.\n\n첫 번째 시도에서 우리는 72%의 정확도를 달성했지만 아직 허용할만한 수준이 아닙니다. F1 점수를 향상시키려면, 훈련 주기를 늘리거나 모델 아키텍처를 변경하거나 데이터셋의 품질을 개선할 수 있습니다(잡음을 줄이고, 서로 다른 배경을 처리하고, 정확하게 라벨을 지정하고, 양을 늘리는 등).\n\n![이미지](/assets/img/2024-05-23-CarlicenseplaterecognitionwithTinyML_11.png)\n\n## 배포\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nEdge Impulse는 하드웨어에 독립적이므로 모델을 어떤 엣지 장치에도 배포할 수 있어요.\n\n![image1](/assets/img/2024-05-23-CarlicenseplaterecognitionwithTinyML_12.png)\n\n대부분의 아두이노 보드와 호환되는 아두이노 라이브러리를 빌드하고 다운로드할 수 있어요. 모델은 .c 및 .h 파일로 변환되어 /src 디렉토리에 저장되며, /examples 디렉토리에 다양한 예제도 포함돼요.\n\n![image2](/assets/img/2024-05-23-CarlicenseplaterecognitionwithTinyML_13.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## The Edge sketch\n\nNicla Vision에서 실행되는 스케치의 주요 기능은 다음과 같습니다:\n\n- 내장 카메라에서 이미지 획득.\n- 라이선스 플레이트 클래스를 결정하기 위해 머신 러닝 모델 실행.\n- 처리 결과를 시리얼 통신을 통해 로컬 및 원격 대시보드를 관리하는 노드에 전송합니다.\n\n```js\n// Edge Impulse 모델 라이브러리 포함\n#include \u003ceu-swiss-plate-recognition_inferencing.h\u003e\n\nvoid setup()\n{\n  // ...\n  // 내장 카메라 초기화\n  if (ei_camera_init() == false) {\n      ei_printf(\"Failed to initialize Camera!\\r\\n\");\n      while(1) ;\n  }\n  // ...\n  // 대시보드 노드와의 시리얼 통신 초기화\n  Serial1.begin(115200);\n}\n\nvoid loop()\n{\n  // ...\n  // 내장 카메라에서 이미지 획득\n  if (ei_camera_capture(...) == false) {\n      ei_printf(\"Failed to capture image\\r\\n\");\n      return;\n  }\n\n  // ...\n  // ML 모델 실행\n  ei_impulse_result_t result = { 0 };\n  EI_IMPULSE_ERROR err = run_classifier(\u0026signal, \u0026result, debug_nn);\n\n  // ...\n  // 예측 결과 파싱\n  if (strcmp(..., \"swiss\") == 0) {\n      pred_result = 'S';\n      break;\n  } else if(strcmp(..., \"eu\") == 0) {\n      pred_result = 'E';\n      break;\n  }\n\n  // ...\n  // 처리 결과를 시리얼을 통해 대시보드 노드로 전송\n  Serial1.print(pred_result);\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# …클라우드로\n\n아두이노 IoT 클라우드는 아두이노의 클라우드에서 IoT 프로젝트를 개발하기 위한 솔루션입니다. 이를 통해 사용자는 장치에서 보낸 데이터를 저장하고 검색하여 실시간 모니터링과 제어를 할 수 있습니다.\n\n알림 기능을 제공하며 사전 구축된 위젯을 사용하여 제어 대시보드를 만들기 위한 사용자 친화적 인터페이스를 제공하여 데이터 시각화 및 관리를 간소화합니다.\n\n이 플랫폼은 아두이노 보드 및 ESP32과 같은 제3자 장치를 포함한 다양한 장치와 호환됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 클라우드 스케치\n\n아두이노 IoT 클라우드 플랫폼에서는 프로젝트 설계 중 사용자가 지정한 구성 및 설정에 기초하여 장치를 위한 스케치가 자동으로 생성됩니다.\n\n```js\n// 클라우드 변수 및 네트워크 인증 정보를 포함한 파일\n#include \"thingProperties.h\"\n\nvoid setup() {\n  // ...\n  // thingProperties.h에서 정의된 속성 초기화\n  initProperties();\n\n  // 아두이노 IoT 클라우드에 연결\n  ArduinoCloud.begin(ArduinoIoTPreferredConnection);\n  // ...\n}\n\nvoid loop() {\n  ArduinoCloud.update();  // 클라우드 변수와 통신 업데이트\n  // ...\n  if (Serial1.available()) {\n    char inByte = Serial1.read(); // 에지 노드에서 오는 결과 읽기\n\n    if (inByte == 'E') {\n      region = REGION_EU; // 'region'은 클라우드 변수입니다\n      // ...\n    } else if (inByte == 'S') {\n      region = REGION_SWISS;\n      // ...\n    }\n    // ...\n  }\n  // ...\n}\n```\n\n## 대시보드\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아두이노 IoT 클라우드는 사용자가 쉽게 사용할 수 있는 위젯을 활용하여 직관적인 대시보드를 생성할 수 있는 기능을 제공합니다. 사용자들은 이러한 위젯을 장치에서 사용되는 클라우드 변수에 쉽게 연결할 수 있어 데이터 시각화와 관리 과정을 간편화할 수 있습니다.\n\n![image](/assets/img/2024-05-23-CarlicenseplaterecognitionwithTinyML_14.png)\n\n![image](/assets/img/2024-05-23-CarlicenseplaterecognitionwithTinyML_15.png)\n\n# GUI 소개\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nGiga Display Shield로 관리되는 GUI는 로컬 대시보드인 인식된 자동차 번호판 유형을 보여줍니다. 디스플레이 관리는 Arduino_GigaDisplay_GFX 라이브러리에 의해 제어됩니다.\n\nArduino_GigaDisplay_GFX는 Adafruit_GFX 라이브러리 위에 구축된 라이브러리입니다. 개별 픽셀, 선, 사각형 및 기타 기하학적 모양을 그리는 기능을 제공합니다. 또한 숫자 값 및 문자열을 출력하는 기능을 지원합니다.\n\n```cpp\n#include \"Arduino_GigaDisplay_GFX.h\"\n\nGigaDisplay_GFX display;\n\nvoid setup() {\n  // ...\n  display.begin();\n  display.setRotation(1);\n  // ...\n}\n\nvoid loop() {\n  if (Serial1.available()) {\n    // ...\n    if (inByte == 'E') {\n      // ...\n      drawEUFlag();\n    } else if (inByte == 'S') {\n      // ...\n      drawSwissFlag();\n    }\n    // ...\n  }\n}\n\nvoid drawEUFlag() {\n  display.fillScreen(BLUE);\n  display.setCursor(350, 400);\n  display.setTextSize(10);\n  display.print(\"EU\");\n\n  for (int i = 0; i \u003c 12; i++) {\n    drawStar(CENTER_X + (UE_FLAG_RADIUS * cos(i * PI / 6)), CENTER_Y + (UE_FLAG_RADIUS * sin(i * PI / 6)));\n  }\n}\n\nvoid drawStar(uint x, uint y) {\n  display.setCursor(x, y);\n  display.setTextColor(YELLOW);\n  display.setTextSize(3);\n  display.print(\"*\");\n  display.setTextColor(WHITE);\n}\n\nvoid drawSwissFlag() {\n  display.fillScreen(RED);\n  display.setCursor(350, 400);\n  display.setTextSize(10);\n  display.print(\"CH\");\n\n  display.fillRect(CENTER_X - SWISS_FLAG_THICKNESS / 2, CENTER_Y - SWISS_FLAG_LENGTH / 2, SWISS_FLAG_THICKNESS, SWISS_FLAG_LENGTH, WHITE);\n  display.fillRect(CENTER_X - SWISS_FLAG_LENGTH / 2, CENTER_Y - SWISS_FLAG_THICKNESS / 2, SWISS_FLAG_LENGTH, SWISS_FLAG_THICKNESS, WHITE);\n}\n```\n\n![Car License Plate Recognition with TinyML](/assets/img/2024-05-23-CarlicenseplaterecognitionwithTinyML_16.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 참고 자료\n\n- 코드:\n  https://github.com/csarnataro/arduino-tinyml-plate-recognition\n- 이탈리안 임베디드 이벤트: https://www.italianembedded.com/events/arduino-ml/\n","ogImage":{"url":"/assets/img/2024-05-23-CarlicenseplaterecognitionwithTinyML_0.png"},"coverImage":"/assets/img/2024-05-23-CarlicenseplaterecognitionwithTinyML_0.png","tag":["Tech"],"readingTime":13},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch2\u003e엣지 임펄스와 아두이노를 이용해 엣지에서 클라우드까지\u003c/h2\u003e\n\u003cp\u003e본 기사는 EU 및 스위스 차량 번호판을 감지하는 용도로 설계된 자동차 번호판 인식 시스템에 대한 자세한 소개를 제공합니다. 컴퓨터 비전과 머신 러닝 기술을 활용하여, 이 시스템은 번호판을 식별하고 분류하여 결과를 화면에 표시합니다. 해당 시스템은 차량 출입지역에서 차량의 출발지에 따라 적용되는 요금이 다른 유료 주차장 시나리오에 사용하기 위한 것입니다.\u003c/p\u003e\n\u003cp\u003e사용자들은 원격 웹 대시보드를 통해 주차 지역으로의 출입 횟수 통계를 확인할 수도 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-23-CarlicenseplaterecognitionwithTinyML_0.png\" alt=\"차량 번호판 인식 시스템\"\u003e\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e어떻게 하나요?\u003c/h1\u003e\n\u003cp\u003e이 시스템의 구현은 Arduino와 Edge Impulse를 사용하여 하드웨어, 소프트웨어 및 클라우드 서비스를 결합하는 과정을 포함합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eArduino는 사용하기 쉬운 하드웨어와 소프트웨어에 기반한 오픈 소스 플랫폼입니다. Arduino는 Arduino IoT Cloud라는 클라우드 서비스도 제공하는데, 이를 통해 장치의 손쉬운 연결, 데이터 저장 및 원격 관리가 가능합니다.\u003c/li\u003e\n\u003cli\u003eEdge Impulse는 임베디드 장치용 머신 러닝 모델을 생성하고 배포하는 플랫폼입니다. 개발자들이 Arduino와 같은 하드웨어에 직접 머신 러닝 모델을 생성, 훈련 및 배포할 수 있도록 지원합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-23-CarlicenseplaterecognitionwithTinyML_1.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e하드웨어 시스템은 세 가지 주요 노드로 구성되어 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eNicla Vision: 이미지 획득과 엣지 임퍼스로 생성된 ML 모델을 사용한 번호판 인식에 특화된 노드입니다. 이미지를 캡처하고 훈련된 머신 러닝 모델을 통해 처리합니다. 인식된 번호판 유형 데이터는 이후 Giga R1 WiFi 보드로 전송됩니다.\u003c/li\u003e\n\u003cli\u003eGiga R1 WiFi: Nicla Vision 노드에서 데이터 수신을 처리하고 Arduino IoT Cloud와 통신하여 원격 대시보드를 관리합니다. 또한 로컬 대시보드 시각화를 위한 디스플레이를 제어합니다.\u003c/li\u003e\n\u003cli\u003eGiga Display Shield: Giga R1 WiFi 보드에 연결된 디스플레이 구성 요소입니다. 로컬 대시보드의 시각화를 위한 인터페이스로 작동합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-23-CarlicenseplaterecognitionwithTinyML_2.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-23-CarlicenseplaterecognitionwithTinyML_3.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e엣지 컴퓨팅에 관해...\u003c/h1\u003e\n\u003cp\u003e엣지 컴퓨팅은 데이터를 원산지에 더 가까운 위치에서 처리하는 것을 의미하며, 원격 서버로 데이터를 보내서 처리하는 방식보다 더 빠르고 효율적입니다.\u003c/p\u003e\n\u003cp\u003e주차 관리 시스템에서는 Nicla Vision이 엣지 노드로 작동하여 이미지를 처리하고 로컬에서 머신러닝 모델을 실행합니다.\n엣지 기기에서 머신러닝 모델을 실행하는 것을 TinyML이라고 합니다.\u003c/p\u003e\n\u003cp\u003eTinyML은 마이크로컨트롤러와 같은 작고 저전력 장치에 머신러닝 모델을 배포하는 것을 의미합니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이 프로젝트의 ML 모델은 이미지를 입력으로 받아들이고 이를 EU 및 Swiss 두 가지 카테고리로 분류합니다.\n이 작업은 이미지 분류로 알려져 있으며 지도학습(machine learning)의 범주에 속합니다. 지도학습은 각 입력이 해당하는 출력 레이블과 관련된 레이블이 있는 데이터 집합을 기반으로 모델을 교육하는 것을 포함합니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-23-CarlicenseplaterecognitionwithTinyML_4.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch2\u003eML 모델을 어떻게 구축할까요?\u003c/h2\u003e\n\u003cp\u003eTiny Machine Learning 모델을 구축하는 과정은 4단계로 이루어집니다:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003e데이터 수집\u003c/li\u003e\n\u003cli\u003e데이터 전처리\u003c/li\u003e\n\u003cli\u003e모델 학습\u003c/li\u003e\n\u003cli\u003e엣지에 배포\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-23-CarlicenseplaterecognitionwithTinyML_5.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ch2\u003eOpenMV 및 Edge Impulse를 사용한 데이터 수집\u003c/h2\u003e\n\u003cp\u003e이 단계에서는 기계 학습 모델을 훈련시키기 위한 관련 데이터를 수집합니다. 이 프로젝트의 경우 OpenMV를 사용하여 EU 및 스위스의 번호판이 포함된 이미지 세트를 수집하는 것을 포함합니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eOpenMV는 머신 비전 작업에 디자인된 마이크로컨트롤러 기반 플랫폼으로, 다양한 카메라 센서와 MicroPython을 실행할 수 있습니다. 엣지 디바이스에서 이미지를 캡처하는 간단하고 효율적인 솔루션을 제공합니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-23-CarlicenseplaterecognitionwithTinyML_6.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003eOpenMV를 사용하면 빠르게 MicroPython 스크립트를 만들어 다양한 이미지 데이터셋을 효율적으로 생성할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-23-CarlicenseplaterecognitionwithTinyML_7.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003eEdge Impulse\u003c/h2\u003e\n\u003cp\u003e이전에 설명했듯이, Edge Impulse는 개발자가 모든 단계에서 도움을 받으며 TinyML 모델을 생성하는 과정을 완전히 지원합니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-23-CarlicenseplaterecognitionwithTinyML_8.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ch2\u003e데이터 수집 및 전처리\u003c/h2\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eOpenMV는 Edge Impulse와 통합하여 데이터 수집 프로세스를 더욱 간단하게 만들어줍니다. 이를 통해 외부 도구가 필요하지 않고 이미지 데이터셋을 직접 업로드할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-23-CarlicenseplaterecognitionwithTinyML_9.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e데이터 수집 후에는 특성 추출을 수행하는 것이 중요합니다. 이는 원시 데이터가 특성 집합으로 변환되는 과정입니다.\u003c/p\u003e\n\u003cp\u003e머신 러닝에서 특성은 특정 작업을 해결하는 데 관련이 있는 원시 데이터에서 추출된 특정한 특징을 가리킵니다. 이미지 처리 문제에서는 이미지에 존재하는 가장자리, 질감, 모양 또는 패턴과 같은 특성이 포함될 수 있습니다. Edge Impulse는 이미지에서 자동으로 특성을 추출할 수 있어 이를 통해 데이터 내에서 가장 관련성이 높은 정보를 식별하고 집중함으로써 모델 학습 프로세스를 간소화할 수 있습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003e모델 훈련\u003c/h2\u003e\n\u003cp\u003e모델 훈련은 사전 처리된 데이터를 기계 학습 알고리즘에 공급하여 입력 특성(플레이트의 이미지 특성)과 출력 레이블(EU 또는 Swiss) 간의 관계를 학습하는 과정을 말합니다.\u003c/p\u003e\n\u003cp\u003eEdge Impulse는 미리 제작된 모델 아키텍처 또는 사용자 정의 모델 아키텍처를 선택하고, 훈련 주기와 학습률과 같은 모델 설정을 조정할 수 있는 기능을 제공합니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-23-CarlicenseplaterecognitionwithTinyML_10.png\" alt=\"Image\"\u003e\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e모델의 효과성은 정확도 지표(F1 점수)를 사용하여 평가되며, 이는 모델이 예측에서 얼마나 정확한지를 나타냅니다.\u003c/p\u003e\n\u003cp\u003e첫 번째 시도에서 우리는 72%의 정확도를 달성했지만 아직 허용할만한 수준이 아닙니다. F1 점수를 향상시키려면, 훈련 주기를 늘리거나 모델 아키텍처를 변경하거나 데이터셋의 품질을 개선할 수 있습니다(잡음을 줄이고, 서로 다른 배경을 처리하고, 정확하게 라벨을 지정하고, 양을 늘리는 등).\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-23-CarlicenseplaterecognitionwithTinyML_11.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch2\u003e배포\u003c/h2\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eEdge Impulse는 하드웨어에 독립적이므로 모델을 어떤 엣지 장치에도 배포할 수 있어요.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-23-CarlicenseplaterecognitionwithTinyML_12.png\" alt=\"image1\"\u003e\u003c/p\u003e\n\u003cp\u003e대부분의 아두이노 보드와 호환되는 아두이노 라이브러리를 빌드하고 다운로드할 수 있어요. 모델은 .c 및 .h 파일로 변환되어 /src 디렉토리에 저장되며, /examples 디렉토리에 다양한 예제도 포함돼요.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-23-CarlicenseplaterecognitionwithTinyML_13.png\" alt=\"image2\"\u003e\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003eThe Edge sketch\u003c/h2\u003e\n\u003cp\u003eNicla Vision에서 실행되는 스케치의 주요 기능은 다음과 같습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e내장 카메라에서 이미지 획득.\u003c/li\u003e\n\u003cli\u003e라이선스 플레이트 클래스를 결정하기 위해 머신 러닝 모델 실행.\u003c/li\u003e\n\u003cli\u003e처리 결과를 시리얼 통신을 통해 로컬 및 원격 대시보드를 관리하는 노드에 전송합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// Edge Impulse 모델 라이브러리 포함\u003c/span\u003e\n#include \u0026#x3C;eu-swiss-plate-recognition_inferencing.\u003cspan class=\"hljs-property\"\u003eh\u003c/span\u003e\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003esetup\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e)\n{\n  \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// 내장 카메라 초기화\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-title function_\"\u003eei_camera_init\u003c/span\u003e() == \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e) {\n      \u003cspan class=\"hljs-title function_\"\u003eei_printf\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Failed to initialize Camera!\\r\\n\"\u003c/span\u003e);\n      \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e) ;\n  }\n  \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// 대시보드 노드와의 시리얼 통신 초기화\u003c/span\u003e\n  \u003cspan class=\"hljs-title class_\"\u003eSerial1\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ebegin\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e115200\u003c/span\u003e);\n}\n\n\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eloop\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e)\n{\n  \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// 내장 카메라에서 이미지 획득\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-title function_\"\u003eei_camera_capture\u003c/span\u003e(...) == \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e) {\n      \u003cspan class=\"hljs-title function_\"\u003eei_printf\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Failed to capture image\\r\\n\"\u003c/span\u003e);\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e;\n  }\n\n  \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// ML 모델 실행\u003c/span\u003e\n  ei_impulse_result_t result = { \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e };\n  \u003cspan class=\"hljs-variable constant_\"\u003eEI_IMPULSE_ERROR\u003c/span\u003e err = \u003cspan class=\"hljs-title function_\"\u003erun_classifier\u003c/span\u003e(\u0026#x26;signal, \u0026#x26;result, debug_nn);\n\n  \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// 예측 결과 파싱\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-title function_\"\u003estrcmp\u003c/span\u003e(..., \u003cspan class=\"hljs-string\"\u003e\"swiss\"\u003c/span\u003e) == \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e) {\n      pred_result = \u003cspan class=\"hljs-string\"\u003e'S'\u003c/span\u003e;\n      \u003cspan class=\"hljs-keyword\"\u003ebreak\u003c/span\u003e;\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003estrcmp\u003c/span\u003e(..., \u003cspan class=\"hljs-string\"\u003e\"eu\"\u003c/span\u003e) == \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e) {\n      pred_result = \u003cspan class=\"hljs-string\"\u003e'E'\u003c/span\u003e;\n      \u003cspan class=\"hljs-keyword\"\u003ebreak\u003c/span\u003e;\n  }\n\n  \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// 처리 결과를 시리얼을 통해 대시보드 노드로 전송\u003c/span\u003e\n  \u003cspan class=\"hljs-title class_\"\u003eSerial1\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(pred_result);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e…클라우드로\u003c/h1\u003e\n\u003cp\u003e아두이노 IoT 클라우드는 아두이노의 클라우드에서 IoT 프로젝트를 개발하기 위한 솔루션입니다. 이를 통해 사용자는 장치에서 보낸 데이터를 저장하고 검색하여 실시간 모니터링과 제어를 할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e알림 기능을 제공하며 사전 구축된 위젯을 사용하여 제어 대시보드를 만들기 위한 사용자 친화적 인터페이스를 제공하여 데이터 시각화 및 관리를 간소화합니다.\u003c/p\u003e\n\u003cp\u003e이 플랫폼은 아두이노 보드 및 ESP32과 같은 제3자 장치를 포함한 다양한 장치와 호환됩니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003e클라우드 스케치\u003c/h2\u003e\n\u003cp\u003e아두이노 IoT 클라우드 플랫폼에서는 프로젝트 설계 중 사용자가 지정한 구성 및 설정에 기초하여 장치를 위한 스케치가 자동으로 생성됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 클라우드 변수 및 네트워크 인증 정보를 포함한 파일\u003c/span\u003e\n#include \u003cspan class=\"hljs-string\"\u003e\"thingProperties.h\"\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003esetup\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// thingProperties.h에서 정의된 속성 초기화\u003c/span\u003e\n  \u003cspan class=\"hljs-title function_\"\u003einitProperties\u003c/span\u003e();\n\n  \u003cspan class=\"hljs-comment\"\u003e// 아두이노 IoT 클라우드에 연결\u003c/span\u003e\n  \u003cspan class=\"hljs-title class_\"\u003eArduinoCloud\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ebegin\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eArduinoIoTPreferredConnection\u003c/span\u003e);\n  \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n}\n\n\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eloop\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-title class_\"\u003eArduinoCloud\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eupdate\u003c/span\u003e();  \u003cspan class=\"hljs-comment\"\u003e// 클라우드 변수와 통신 업데이트\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-title class_\"\u003eSerial1\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eavailable\u003c/span\u003e()) {\n    char inByte = \u003cspan class=\"hljs-title class_\"\u003eSerial1\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eread\u003c/span\u003e(); \u003cspan class=\"hljs-comment\"\u003e// 에지 노드에서 오는 결과 읽기\u003c/span\u003e\n\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (inByte == \u003cspan class=\"hljs-string\"\u003e'E'\u003c/span\u003e) {\n      region = \u003cspan class=\"hljs-variable constant_\"\u003eREGION_EU\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// 'region'은 클라우드 변수입니다\u003c/span\u003e\n      \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n    } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (inByte == \u003cspan class=\"hljs-string\"\u003e'S'\u003c/span\u003e) {\n      region = \u003cspan class=\"hljs-variable constant_\"\u003eREGION_SWISS\u003c/span\u003e;\n      \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n    }\n    \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n  }\n  \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e대시보드\u003c/h2\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e아두이노 IoT 클라우드는 사용자가 쉽게 사용할 수 있는 위젯을 활용하여 직관적인 대시보드를 생성할 수 있는 기능을 제공합니다. 사용자들은 이러한 위젯을 장치에서 사용되는 클라우드 변수에 쉽게 연결할 수 있어 데이터 시각화와 관리 과정을 간편화할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-23-CarlicenseplaterecognitionwithTinyML_14.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-23-CarlicenseplaterecognitionwithTinyML_15.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ch1\u003eGUI 소개\u003c/h1\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eGiga Display Shield로 관리되는 GUI는 로컬 대시보드인 인식된 자동차 번호판 유형을 보여줍니다. 디스플레이 관리는 Arduino_GigaDisplay_GFX 라이브러리에 의해 제어됩니다.\u003c/p\u003e\n\u003cp\u003eArduino_GigaDisplay_GFX는 Adafruit_GFX 라이브러리 위에 구축된 라이브러리입니다. 개별 픽셀, 선, 사각형 및 기타 기하학적 모양을 그리는 기능을 제공합니다. 또한 숫자 값 및 문자열을 출력하는 기능을 지원합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-cpp\"\u003e\u003cspan class=\"hljs-meta\"\u003e#\u003cspan class=\"hljs-keyword\"\u003einclude\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"Arduino_GigaDisplay_GFX.h\"\u003c/span\u003e\u003c/span\u003e\n\nGigaDisplay_GFX display;\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-type\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003esetup\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e \u003c/span\u003e{\n  \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n  display.\u003cspan class=\"hljs-built_in\"\u003ebegin\u003c/span\u003e();\n  display.\u003cspan class=\"hljs-built_in\"\u003esetRotation\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\n  \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n}\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-type\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eloop\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (Serial1.\u003cspan class=\"hljs-built_in\"\u003eavailable\u003c/span\u003e()) {\n    \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (inByte == \u003cspan class=\"hljs-string\"\u003e'E'\u003c/span\u003e) {\n      \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n      \u003cspan class=\"hljs-built_in\"\u003edrawEUFlag\u003c/span\u003e();\n    } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (inByte == \u003cspan class=\"hljs-string\"\u003e'S'\u003c/span\u003e) {\n      \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n      \u003cspan class=\"hljs-built_in\"\u003edrawSwissFlag\u003c/span\u003e();\n    }\n    \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n  }\n}\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-type\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003edrawEUFlag\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e \u003c/span\u003e{\n  display.\u003cspan class=\"hljs-built_in\"\u003efillScreen\u003c/span\u003e(BLUE);\n  display.\u003cspan class=\"hljs-built_in\"\u003esetCursor\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e350\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e400\u003c/span\u003e);\n  display.\u003cspan class=\"hljs-built_in\"\u003esetTextSize\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e);\n  display.\u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"EU\"\u003c/span\u003e);\n\n  \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e i = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e; i \u0026#x3C; \u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e; i++) {\n    \u003cspan class=\"hljs-built_in\"\u003edrawStar\u003c/span\u003e(CENTER_X + (UE_FLAG_RADIUS * \u003cspan class=\"hljs-built_in\"\u003ecos\u003c/span\u003e(i * PI / \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e)), CENTER_Y + (UE_FLAG_RADIUS * \u003cspan class=\"hljs-built_in\"\u003esin\u003c/span\u003e(i * PI / \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e)));\n  }\n}\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-type\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003edrawStar\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(uint x, uint y)\u003c/span\u003e \u003c/span\u003e{\n  display.\u003cspan class=\"hljs-built_in\"\u003esetCursor\u003c/span\u003e(x, y);\n  display.\u003cspan class=\"hljs-built_in\"\u003esetTextColor\u003c/span\u003e(YELLOW);\n  display.\u003cspan class=\"hljs-built_in\"\u003esetTextSize\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e);\n  display.\u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"*\"\u003c/span\u003e);\n  display.\u003cspan class=\"hljs-built_in\"\u003esetTextColor\u003c/span\u003e(WHITE);\n}\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-type\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003edrawSwissFlag\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e \u003c/span\u003e{\n  display.\u003cspan class=\"hljs-built_in\"\u003efillScreen\u003c/span\u003e(RED);\n  display.\u003cspan class=\"hljs-built_in\"\u003esetCursor\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e350\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e400\u003c/span\u003e);\n  display.\u003cspan class=\"hljs-built_in\"\u003esetTextSize\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e);\n  display.\u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"CH\"\u003c/span\u003e);\n\n  display.\u003cspan class=\"hljs-built_in\"\u003efillRect\u003c/span\u003e(CENTER_X - SWISS_FLAG_THICKNESS / \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, CENTER_Y - SWISS_FLAG_LENGTH / \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, SWISS_FLAG_THICKNESS, SWISS_FLAG_LENGTH, WHITE);\n  display.\u003cspan class=\"hljs-built_in\"\u003efillRect\u003c/span\u003e(CENTER_X - SWISS_FLAG_LENGTH / \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, CENTER_Y - SWISS_FLAG_THICKNESS / \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, SWISS_FLAG_LENGTH, SWISS_FLAG_THICKNESS, WHITE);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-23-CarlicenseplaterecognitionwithTinyML_16.png\" alt=\"Car License Plate Recognition with TinyML\"\u003e\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e참고 자료\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e코드:\n\u003ca href=\"https://github.com/csarnataro/arduino-tinyml-plate-recognition\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://github.com/csarnataro/arduino-tinyml-plate-recognition\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e이탈리안 임베디드 이벤트: \u003ca href=\"https://www.italianembedded.com/events/arduino-ml/\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://www.italianembedded.com/events/arduino-ml/\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-23-CarlicenseplaterecognitionwithTinyML"},"buildId":"YUMR4jSyk_WlOHHc7UfOk","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>