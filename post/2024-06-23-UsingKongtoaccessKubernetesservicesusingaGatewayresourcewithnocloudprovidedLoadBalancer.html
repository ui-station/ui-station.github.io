<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>클라우드 제공 로드밸런서 없이 Kong과 Gateway를 사용하여 Kubernetes 서비스에 접근하는 방법 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-06-23-UsingKongtoaccessKubernetesservicesusingaGatewayresourcewithnocloudprovidedLoadBalancer" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="클라우드 제공 로드밸런서 없이 Kong과 Gateway를 사용하여 Kubernetes 서비스에 접근하는 방법 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="클라우드 제공 로드밸런서 없이 Kong과 Gateway를 사용하여 Kubernetes 서비스에 접근하는 방법 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-23-UsingKongtoaccessKubernetesservicesusingaGatewayresourcewithnocloudprovidedLoadBalancer_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-06-23-UsingKongtoaccessKubernetesservicesusingaGatewayresourcewithnocloudprovidedLoadBalancer" data-gatsby-head="true"/><meta name="twitter:title" content="클라우드 제공 로드밸런서 없이 Kong과 Gateway를 사용하여 Kubernetes 서비스에 접근하는 방법 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-23-UsingKongtoaccessKubernetesservicesusingaGatewayresourcewithnocloudprovidedLoadBalancer_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-23 23:10" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-4f7b40c1114f0d09.js" defer=""></script><script src="/_next/static/YUMR4jSyk_WlOHHc7UfOk/_buildManifest.js" defer=""></script><script src="/_next/static/YUMR4jSyk_WlOHHc7UfOk/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">클라우드 제공 로드밸런서 없이 Kong과 Gateway를 사용하여 Kubernetes 서비스에 접근하는 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="클라우드 제공 로드밸런서 없이 Kong과 Gateway를 사용하여 Kubernetes 서비스에 접근하는 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 23, 2024</span><span class="posts_reading_time__f7YPP">27<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-23-UsingKongtoaccessKubernetesservicesusingaGatewayresourcewithnocloudprovidedLoadBalancer&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h2>이 기사에서는 쿠버네티스 클러스터 내에서 Kong을 API 게이트웨이로 배포하여 서비스에 관리된 액세스를 제공하는 방법을 살펴봅니다. 이를 클라우드 서비스에서 수행합니다. 이 클라우드 서비스는 쿠버네티스 호환 외부 로드 밸런서 서비스를 제공하지 않습니다. 또한 Ingress 리소스 대신 최신 Kubernetes Gateway를 사용합니다.</h2>
<p>저와 이전 기사 중 한 가지 이상을 따르신 분들은 저의 이전 기사들 중 하나를 따라오셨을 것입니다. 저는 신뢰할 수 있고 비용 효율적이지만 제한된 범위의 서비스를 제공하는 호주 클라우드 제공자인 Binary Lane을 사용합니다.</p>
<p>제한된 범위의 서비스만 제공하는 것은 모든 쿠버네티스 작업을 직접해야 하므로, 배우고 솔루션의 작동 방식을 제어할 수 있는 기회를 제공합니다. 또한 어떤 클라우드 공급 업체에도 얽매이지 않을 수 있습니다. 또한 비용 효율적입니다.</p>
<p>이 기사에서는 Kubernetes 클러스터에 Kong API 게이트웨이를 추가하여 서비스에 액세스하는 방법을 살펴봅니다. 할 일이 꽤 많기 때문에 이 기사는 좀 길지만, API 게이트웨이의 역할에 대한 이론 부분을 별도의 기사로 분리했습니다. API 게이트웨이의 역할을 이해하지 못하신다면 먼저 해당 기사를 읽는 것을 권장합니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>Kong은 신뢰할 만한 엔터프라이즈급 API 게이트웨이이지만 설정하기가 매우 까다로울 수 있습니다. 이 기사의 끝에서 문제를 디버그하는 방법에 대한 일부 힌트를 제공하겠습니다. 이 기사에서 설계를 조정하는 경우, 이름과 포트를 올바르게 구성했는지 확인하세요.</p>
<h1>네트워크 디자인</h1>
<p>Kubernetes 네트워킹은 복잡한 주제이며 여기서 다루기 어렵지만, 고수준에서 네트워크 디자인에 대해 생각해야 합니다.</p>
<p><img src="/assets/img/2024-06-23-UsingKongtoaccessKubernetesservicesusingaGatewayresourcewithnocloudprovidedLoadBalancer_0.png" alt="네트워크 디자인"></p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이전 기사를 따라오셨다면, 이제 이진 레인(또는 다른 클라우드 제공업체) 서버에 Kubernetes 클러스터가 설치되어 있어야 합니다. 인터넷에서 접근이 불가능한 가상 사설 클라우드 (VPC) 개인 서브넷에 세 개의 노드가 설치되어 있을 것입니다. 이러한 노드들은 인터넷을 통해 접속이 가능한 전용 VPN을 통해서만 연결됩니다(위에는 표시되지 않음). 인터넷 및 VPC 인터페이스를 모두 가지고 있는 게이트웨이 서버가 있어서, 인터넷에서 클러스터로 들어오는 접속(inress)과 클러스터에서 인터넷으로 나가는 접속(egress)을 제공합니다.</p>
<p>기본 네트워크 토폴로지가 이제 갖추어 졌습니다. 이제 우리는 서비스가 외부 세계에 제공하는 API를 관리할 수 있기를 원합니다. 이 작업은 Kong Gateway API를 통해 수행됩니다.</p>
<h1>인터넷에서 연결 설정하기 (인그레스)</h1>
<p>AWS, 구글 클라우드 또는 Azure와 같은 풀 서비스 제공업체를 사용하면, LoadBalancer 유형의 Kubernetes 서비스를 사용하여 인터넷 연결이 자동으로 생성되는 방식으로 Kubernetes를 설정할 수 있습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>바이너리 레인에는 로드 밸런서 서비스가 있지만 쿠버네티스를 통해 관리할 수는 없으므로 로드 밸런서를 직접 생성하고 구성하거나 고유한 인그레스 포인트를 만들어야 합니다. 특정 클라우드 제공 업체의 기능에 구속되지 않기 위해, 저는 개인적으로 내 gw 서버에서 NGINX 역방향 프록시를 실행하여 고유한 인그레스 포인트를 만드는 것을 선호합니다.</p>
<p>이 아키텍처에서 gw 서버에서 실행되는 NGINX는 두 가지 기능을 수행합니다:</p>
<ul>
<li>유효한 요청을 모두 쿠버네티스 클러스터로 라우팅하여 Kong이 처리</li>
<li>쿠버네티스 노드 간 요청을 로드 밸런싱</li>
</ul>
<p>Kong이 NodePort 서비스로 노출될 것이므로 클러스터의 모든 노드에서 액세스할 수 있습니다. 이를 통해 NGINX가 노드 간 요청을 로드 밸런싱할 수 있습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>서비스 자체가 사용 가능한 파드 전체에 무작위로 로드 밸런싱을 수행하므로 NGINX에 의한 로드 밸런싱이 노드 장애나 과부하 상황을 견딜 목적으로만 사용된다는 것을 유의한 점입니다. 서비스 로드 밸런싱에 대해 더 읽어보실 수 있습니다.</p>
<p>본 솔루션에서 NGINX를 수동으로 구성된, 대체될 수 있는 외부 로드 밸런서로 간주하실 수 있습니다.</p>
<h1>쿠버네티스 서비스</h1>
<p>쿠버네티스 서비스는 하나 이상의 파드가 제공하는 서비스에 대한 액세스를 허용합니다. 이를 통해 파드가 종료되고 재예약되더라도 특정 노드에서 요청이 발생하더라도 서비스가 계속하여 요구에 따른 대로 요청을 라우팅하는 단일 접점으로 유지됩니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p><img src="/assets/img/2024-06-23-UsingKongtoaccessKubernetesservicesusingaGatewayresourcewithnocloudprovidedLoadBalancer_1.png" alt="image"></p>
<p>서비스를 사용함으로써 요청을 보낼 수 있는 단일하고 안정적인 IP 주소가 제공됩니다. 서비스는 사용 가능한 Pod들 사이에서 부하 분산 기능을 제공합니다. Kubernetes는 또한 클러스터의 DNS에 서비스에 대한 참조를 추가함으로써 서비스가 이름으로 액세스될 수 있게 합니다. 여러 가지 다른 변형이 등록됩니다:</p>
<pre><code class="hljs language-js">&#x3C;서비스 이름>.&#x3C;네임스페이스>.<span class="hljs-property">svc</span>.<span class="hljs-property">local</span>
&#x3C;서비스 이름>.&#x3C;네임스페이스>.<span class="hljs-property">svc</span>
&#x3C;서비스 이름>.&#x3C;네임스페이스>
&#x3C;서비스 이름>
</code></pre>
<h1>API 게이트웨이</h1>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>NGINX 게이트웨이와 쿠버네티스 서비스는 서비스에 대한 외부 인터페이스를 제공하는 데 도움이 되지만 기능이 제한적이며 수동으로 설정해야 합니다.</p>
<p>API 게이트웨이는 이 문제를 해결하는 클러스터 구성 요소입니다. 이 게이트웨이는 솔루션의 일부로 구성되며 서비스 앞에 위치하여 여기서 설명하는 추가 기능을 제공합니다.</p>
<p><img src="/assets/img/2024-06-23-UsingKongtoaccessKubernetesservicesusingaGatewayresourcewithnocloudprovidedLoadBalancer_2.png" alt="image"></p>
<p>API 게이트웨이는 클러스터의 일부로 있기 때문에 클러스터 내 리소스의 변경에 따라 자동으로 구성될 수 있습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>Kong API Gateway</h1>
<p>다양한 API 게이트웨이 기술이 있지만, 이 글에서는 무료 오픈 소스 솔루션인 Kong을 선택했습니다. 유료 엔터프라이즈 설치도 가능합니다. 여기에서 Kong에 대한 포괄적인 공식 문서를 찾을 수 있습니다.</p>
<p>Kong은 쿠버네티스 커뮤니티와 적극적으로 협력하여 클러스터 내에서 게이트웨이에 대한 새로운 표준을 정의하고 있습니다. 이로 인해 게이트웨이 자체와 혼동되어서는 안 되는 새로운 쿠버네티스 리소스 유형인 게이트웨이 API가 만들어졌습니다.</p>
<p>이것이 Kong이 어떻게 작동하는지 대략적으로 설명했습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p><img src="/assets/img/2024-06-23-UsingKongtoaccessKubernetesservicesusingaGatewayresourcewithnocloudprovidedLoadBalancer_3.png" alt="이미지"></p>
<p>클러스터 외부의 모든 클라이언트로부터 들어오는 트래픽이 Kong에 도달합니다. Kong은 구성 내의 규칙에 따라 요청을 처리하고 클러스터 내외의 적절한 서비스로 요청을 전달합니다.</p>
<p>Kong은 Kubernetes 리소스 매니페스트에서 정적으로 또는 데이터베이스에서 구성을 가져올 수 있습니다 (DB-less 설치). Kong은 이제 DB-less 설치를 새로운 설치에 사용할 것을 권장하며, 이를 따를 것입니다.</p>
<p>Kong은 성숙한 플러그인 기능을 갖추고 있습니다. 이를 통해 제3자가 Kong의 플러그인으로 기능 확장을 개발할 수 있습니다. 플러그인은 트래픽 흐름에 위치하여 속도 제한 및 인증과 같은 작업에 도움을 줄 수 있습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>마지막으로 Kong을 관리하기 위해 플러그인, 구성 등을 관리할 수 있도록 Management UI를 제공합니다. Management UI는 Admin API를 통해 Kong과 상호 작용합니다.</p>
<p>Kong에 대해 상세한 문서를 살펴보면 여기서 다룰 수 있는 내용보다 더 많음을 알 수 있습니다. 그래서 제가 다루는 내용은 기본 사항에만 초점을 맞추겠습니다.</p>
<h2>DB-less 설치</h2>
<p>DB-less 설치가 어떻게 작동하는지 이해하는 것이 중요하다고 생 생각합니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이 구성에서 Kong은 두 가지 구성요소를 설치합니다:</p>
<ul>
<li>Kong Ingress Controller (KIC)</li>
<li>Kong Gateway</li>
</ul>
<p>게이트웨이는 프록시를 통해 모든 사용자 트래픽의 경로 지정을 처리합니다. Kong Ingress Controller (KIC)는 Kubernetes 리소스 정의 (예: HTTPRoute)에서 구성을 가져와서 프록시가 이해하는 규칙으로 변환하고 실시간으로 프록시에 규칙을 업로드합니다. 이러한 방식으로 Kubernetes 구성의 변경 사항이 자동으로 프록시에 적용됩니다.</p>
<p>KIC는 내부 Kubernetes API를 사용하여 Kubernetes 클러스터에 대한 정보를 얻습니다. 이 API는 클러스터를 관리하는 데 사용되는 것으로, kubectl을 사용할 때 실제로는 Kubernetes API와 상호 작용합니다. 이 API를 통해 Kong 및 kubectl과 같은 애플리케이션은 클러스터에 대한 정보를 찾거나 변경할 수 있습니다. KIC는 이 API를 통해 백업 데이터베이스가 필요 없이 클러스터 리소스 파일과 Gateway를 동기화할 수 있습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>테스트할 서비스</h1>
<p>Kong 배포에 들어가기 전에 Kong을 통해 접근할 수 있는 서비스를 가지고 있어야 합니다. 어차피 API Gateway에 API가 없다면 그리 유용하지 않을 것이니까요!</p>
<p>가장 간단한 방법은 NGINX를 웹 서버로 배포하고 정적 콘텐츠로 구성하는 것입니다. Kubernetes에서 이 작업을 한 적이 없다면 다른 기사 하나에서 그 방법을 읽어볼 수 있습니다.</p>
<p>2개의 서비스를 생성하는 것을 제안합니다:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>안녕하세요 world 1: 2개의 레플리카</li>
<li>안녕하세요 world 2: 1개의 레플리카</li>
</ul>
<p>이들은 클러스터 내 파드에서 ClusterIP 서비스를 통해 접근할 수 있어야 합니다. 이러한 서비스를 설정하는 내 기사에서는 브라우저에서 서비스를 확인할 수 있도록 NodePort 서비스를 생성합니다. 이를 수행할 경우 내부 클러스터 IP 및 포트를 사용해야 합니다. 서비스 유형에 대한 자세한 내용은 다른 기사에서 확인할 수 있습니다.</p>
<p>두 서비스가 올바르게 실행되고 Hello World HTML을 제공할 수 있는지 확인하세요.</p>
<p>내가 여기서 설명하는 예제에서, 내 두 서비스는 다음과 같이 위치해 있습니다:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>http://<code>node IP 주소</code>:30082 — 'Hello World 1 !!'라고 응답합니다.</li>
<li>http://<code>node IP 주소</code>:30082 — 'Hello World 2 !!'라고 응답합니다.</li>
</ul>
<p>어느 경로도 필요하지 않으며 경로를 추가하면 (예: http://<code>node IP 주소</code>:30082/world1) 404 오류가 발생합니다. 이 사실을 인식하지 못하면 나중에 문제가 될 수 있으므로 주의해야 합니다.</p>
<p>이제 서비스가 실행 중이므로 Kong을 통해 액세스해 보겠습니다.</p>
<h1>쿠버네티스 게이트웨이 자원 생성하기</h1>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>DB 미사용 모드에서는 Kong API 게이트웨이를 구성할 때 Kubernetes Ingress 또는 HTTPRoute 리소스를 생성합니다. 이러한 리소스를 클러스터에 적용하면 Kong이 프록시 구성 요소 내에서 라우팅 규칙을 정의하는 데 사용됩니다. 이를 통해 들어오는 트래픽이 서비스로 전달됩니다.</p>
<p>Ingress 리소스는 작동하지만 기능이 제한적입니다. Kubernetes 커뮤니티와 함께 Kong에서 개발한 새 Gateway 리소스를 사용하면 API를 더 정교하게 관리할 수 있습니다.</p>
<p>우리는 Kong과 함께 Gateway 리소스를 사용할 것입니다. 이를 위해 먼저 GatewayClass 및 Gateway 리소스를 지원하는 새로운 Custom Resource Definitions (CRD)를 클러스터에 적용해야 합니다. 클러스터에서 kubectl을 실행하는 위치에서 다음 명령을 실행하여 이 작업을 수행할 수 있습니다. 저의 경우에는 제 k8s-master 서버에서 이를 실행합니다.</p>
<pre><code class="hljs language-js">kubectl apply -f <span class="hljs-attr">https</span>:<span class="hljs-comment">//github.com/kubernetes-sigs/gateway-api/releases/download/v1.0.0/standard-install.yaml</span>
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>본 문서에서는 사용하지 않을 실험적 기능 몇 가지를 소개해드리겠습니다만, 참고용으로 여기에 추가해두었습니다.</p>
<pre><code class="hljs language-js">kubectl apply -f <span class="hljs-attr">https</span>:<span class="hljs-comment">//github.com/kubernetes-sigs/gateway-api/releases/download/v1.0.0/experimental-install.yaml</span>
</code></pre>
<p>이제 Kubernetes를 위해 GatewayClass 및 Gateway 두 리소스를 정의할 수 있습니다. 이들이 무엇을 하는 지에 대해 설명했으니, 이를 다시 반복하지는 않겠습니다. 간결함을 위해 해당 내용은 여기서 생략합니다.</p>
<h2>GatewayClass</h2>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>Kong 기술을 클러스터에 소개하는 GatewayClass를 정의할 것입니다. 다음 파일을 생성해주세요:</p>
<p>kong-gw-class.yml</p>
<pre><code class="hljs language-yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">gateway.networking.k8s.io/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">GatewayClass</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">kong-class</span>
  <span class="hljs-attr">annotations:</span>
    <span class="hljs-attr">konghq.com/gatewayclass-unmanaged:</span> <span class="hljs-string">"true"</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">controllerName:</span> <span class="hljs-string">konghq.com/kic-gateway-controller</span>
</code></pre>
<p>이 파일에 대해 몇 가지 주의할 사항이 있습니다:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>이것은 클러스터 수준 리소스이기 때문에 네임스페이스가 없습니다.</li>
<li>주석은 솔루션별 옵션을 정의하며 Kong의 경우 konghq로 시작합니다.</li>
<li>konghq.com/gatewayclass-unmanaged 주석은 'true'(문자열)로 설정되어 있습니다. 왜냐하면 Kong이 오퍼레이터를 통해 자동으로 설정되는 것이 아니라 수동으로 설정되고 있기 때문입니다.(다른 옵션도 있으니 여기를 참조하세요)</li>
<li>인그레스 컨트롤러는 Kong 인그레스 컨트롤러(konghq.com/kic-gateway-controller)이며 contollerName 필드에서 구성됩니다.</li>
</ul>
<p>이제 다음과 같이 클래스를 생성하세요:</p>
<pre><code class="hljs language-js">kubectl apply -f kong-gw-<span class="hljs-keyword">class</span>.<span class="hljs-property">yml</span>
</code></pre>
<p>이제 이 클래스를 사용하는 게이트웨이를 생성할 수 있습니다. 동일한 GatewayClass를 참조하는 여러 Gateway 인스턴스를 생성할 수 있다는 점을 유의하세요.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>게이트웨이</h2>
<p>수동으로 설치된 Kong 게이트웨이의 경우 (우리가 생성중인 것과 같이), 다음 파일을 만들어야 합니다:</p>
<p>kong-gw-gateway.yml</p>
<pre><code class="hljs language-yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">gateway.networking.k8s.io/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">Gateway</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">kong-gateway</span>
  <span class="hljs-attr">namespace:</span> <span class="hljs-string">kong</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">gatewayClassName:</span> <span class="hljs-string">kong-class</span>
  <span class="hljs-attr">listeners:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">world-selector</span>
      <span class="hljs-attr">hostname:</span> <span class="hljs-string">worlds.com</span>
      <span class="hljs-attr">port:</span> <span class="hljs-number">80</span>
      <span class="hljs-attr">protocol:</span> <span class="hljs-string">HTTP</span>
      <span class="hljs-attr">allowedRoutes:</span>
        <span class="hljs-attr">namespaces:</span>
          <span class="hljs-attr">from:</span> <span class="hljs-string">All</span>
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>파일에서 유의해야 할 몇 가지 사항이 또 있습니다:</p>
<ul>
<li>나중에 참조할 수 있는 이름이 있습니다 (kong-gateway)</li>
<li>GatewayClass는 위에서 생성한 GatewayClass의 이름을 의미합니다</li>
<li>이 Gateway는 이 API Gateway의 진입점인 하나의 리스너만 정의합니다</li>
<li>리스너에는 URL 호환성이 있는 고유한 이름이 지정됩니다</li>
<li>리스너는 포트 80에 바인드됩니다</li>
<li>호스트명은 일치 필드로 사용되며 옵션입니다</li>
<li>이 리스너에 연결할 서비스(allowedRoutes)를 제어할 수 있으며 해당 서비스들은 네임스페이스를 통해 연결됩니다 - 동일한 네임스페이스를 기본으로 사용하여 다른 네임스페이스로 연결하기 위해 모든 네임스페이스로 변경됩니다</li>
<li>Gateway 사양은 게이트웨이가 HTTP를 통해 단일 포트(80)에서 수신하는 것을 예상합니다.</li>
</ul>
<p>Gateways는 네임스페이스에 특정하며 API Gateway를 설치하기 전에 생성해야 합니다:</p>
<pre><code class="hljs language-js">kubectl create namespace kong
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이제 다음 명령을 사용하여 리소스를 만드세요:</p>
<pre><code class="hljs language-js">kubectl apply -f kong-gw-gateway.<span class="hljs-property">yml</span>
</code></pre>
<p>이제 GatewayClass 및 Gateway 리소스가 정의되었으므로, 애플리케이션 자체를 설치하여 이 두 리소스의 구현을 형성할 수 있습니다.</p>
<h1>Kong 설치</h1>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>지금은 Helm 차트를 사용하여 Kong을 설치할 것입니다. 만약 Helm이 없다면, Helm을 설치하는 방법은 여기에서 찾을 수 있습니다.</p>
<h2>Kong CRDs</h2>
<p>Kong을 설치하기 전에 Kong Custom Resource Definitions (CRDs)를 설치해야 합니다. 이 작업은 클러스터에서 kubectl을 실행하는 위치에서 다음 명령을 실행하여 수행할 수 있습니다. 제 경우에는 k8s-master 서버에서 이 작업을 수행하고 있습니다.</p>
<pre><code class="hljs language-js">kubectl apply -k <span class="hljs-attr">https</span>:<span class="hljs-comment">//github.com/Kong/kubernetes-ingress-controller/config/crd</span>
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>Kong Application</h2>
<p>Kong을 Kubernetes 클러스터에 설치할 때, 두 가지 구성 요소가 설치됩니다:</p>
<ul>
<li>Kong 인그레스 컨트롤러 (KIC) — 쿠버네티스 리소스 정의를 Kong 게이트웨이 구성으로 변환합니다.</li>
<li>Kong 게이트웨이 — Kong 인그레스 컨트롤러 (KIC)에 의해 삽입된 구성을 기반으로 서비스로의 라우팅을 담당합니다.</li>
</ul>
<p>먼저, 로컬 헬름에 Kong 저장소를 추가하십시오:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js">helm repo add kong <span class="hljs-attr">https</span>:<span class="hljs-comment">//charts.konghq.com</span>
helm repo update
</code></pre>
<p>만약 다음 명령어로 Helm 차트를 검색하면:</p>
<pre><code class="hljs language-js">helm search repo kong
</code></pre>
<p>두 개의 항목을 찾을 수 있습니다:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js">이름           차트 버전  앱 버전  설명
kong/kong    <span class="hljs-number">2.33</span><span class="hljs-number">.3</span>    <span class="hljs-number">3.5</span>       클라우드 네이티브 인그레스 및 <span class="hljs-variable constant_">API</span> 관리
kong/ingress <span class="hljs-number">0.10</span><span class="hljs-number">.2</span>    <span class="hljs-number">3.4</span>       콩 인그레스 컨트롤러 및 콩 게이트웨이 배포
</code></pre>
<p>DB 레스 구성을 사용할 것이므로 kong/ingress를 사용할 것입니다. 설치하기 전에 몇 가지 값을 재정의해야 합니다. 다음 파일을 만들어주세요:</p>
<p>kong-values.yml</p>
<pre><code class="hljs language-js">#<span class="hljs-attr">controller</span>:
#  <span class="hljs-attr">ingressController</span>:
#    <span class="hljs-attr">env</span>:
#      <span class="hljs-attr">LOG_LEVEL</span>: trace
#      <span class="hljs-attr">dump_config</span>: <span class="hljs-literal">true</span>

<span class="hljs-attr">gateway</span>:
  <span class="hljs-attr">admin</span>:
    <span class="hljs-attr">http</span>:
      <span class="hljs-attr">enabled</span>: <span class="hljs-literal">true</span>
  <span class="hljs-attr">proxy</span>:
    <span class="hljs-attr">type</span>: <span class="hljs-title class_">NodePort</span>
    <span class="hljs-attr">http</span>:
      <span class="hljs-attr">enabled</span>: <span class="hljs-literal">true</span>
      <span class="hljs-attr">nodePort</span>: <span class="hljs-number">32001</span>
    <span class="hljs-attr">tls</span>:
      <span class="hljs-attr">enabled</span>: <span class="hljs-literal">false</span>
#  <span class="hljs-attr">ingressController</span>:
#    <span class="hljs-attr">env</span>:
#      <span class="hljs-attr">LOG_LEVEL</span>: trace
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>KIC 및 Kong Gateway를 부모 Helm 차트를 통해 설치하고 있기 때문에 이 두 애플리케이션의 구성은 각각 컨트롤러 및 게이트웨이 레이블 아래에 있습니다. 컨트롤러는 단순히 알림으로 남겨두었습니다.</p>
<p>또한, 주석 처리된 여러 줄을 볼 수 있습니다. 이것들은 Pod 로그를 통해 무엇이 발생하는지 디버그하고 싶을 때 유용합니다.</p>
<p>Binary Lane은 Kubernetes가 구성할 수 있는 로드 밸런서를 제공하지 않기 때문에 프록시 구성을 재정의하고 있습니다. Kubernetes에게 LoadBalancer 서비스 대신 NodePort 서비스를 설정하도록 지시하고 있습니다. 게이트웨이를 클러스터의 모든 노드에서 사용할 수 있도록 포트 32001에 노출하고 있습니다.</p>
<p>이전에 kong 네임스페이스를 생성했으므로 이제 Kong을 설치할 준비가 되었습니다:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js">helm install kong kong/ingress -f kong-values.<span class="hljs-property">yml</span> -n kong
</code></pre>
<p>이제 설치가 예상대로 작동하는지 확인할 수 있습니다. 준비되는 데 1-2분 정도 걸릴 수 있습니다:</p>
<pre><code class="hljs language-js">kubectl get all -n kong
</code></pre>
<p>다음과 같은 결과를 얻어야 합니다:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h3>NAME READY STATUS RESTARTS AGE</h3>
<ul>
<li>pod/kong-controller-68cddcbcb7-z46lh 1/1 Running 0 45s</li>
<li>pod/kong-gateway-687c5b78db-5qvgd 1/1 Running 0 45s</li>
</ul>
<h3>NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE</h3>
<ul>
<li>service/kong-controller-validation-webhook ClusterIP 10.110.172.40 <none> 443/TCP 46s</none></li>
<li>service/kong-gateway-admin ClusterIP None <none> 8444/TCP 46s</none></li>
<li>service/kong-gateway-manager NodePort 10.100.254.169 <none> 8002:30698/TCP,8445:30393/TCP 46s</none></li>
<li>service/kong-gateway-proxy NodePort 10.96.24.196 <none> 80:32001/TCP 46s</none></li>
</ul>
<h3>NAME READY UP-TO-DATE AVAILABLE AGE</h3>
<ul>
<li>deployment.apps/kong-controller 1/1 1 1 45s</li>
<li>deployment.apps/kong-gateway 1/1 1 1 45s</li>
</ul>
<h3>NAME DESIRED CURRENT READY AGE</h3>
<ul>
<li>replicaset.apps/kong-controller-68cddcbcb7 1 1 1 45s</li>
<li>replicaset.apps/kong-gateway-687c5b78db 1 1 1 45s</li>
</ul>
<p>Management UI 서비스가 NodePort를 통해 노출됩니다. 이는 관리 API를 볼 수 있는 것을 기대하고 작동하지 않을 것입니다. DB-less 설치를 하고 있기 때문에, 관리 UI의 유일한 사용은 설정을 확인하는 것뿐입니다.</p>
<p>클러스터 내 노드에서 프록시 주소를 curl로 테스트할 수 있습니다:</p>
<pre><code class="hljs language-js">curl <span class="hljs-attr">localhost</span>:<span class="hljs-number">32001</span>
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>요청한 표는 Markdown 형식으로 변경해야 합니다.</p>
<pre><code class="hljs language-json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"message"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"해당 값으로 일치하는 경로가 없습니다."</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"request_id"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"7fc9db053e3029105581890e81effe12"</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p>요청 ID는 해당 거래에 고유하며 curl 명령을 다시 실행하면 다른 값을 볼 수 있습니다. 이는 Kong에서 추가되어 시스템을 통해 요청을 추적할 수 있게 합니다. 멋지죠?</p>
<p>이제 새 API 게이트웨이를 구성하여 이전에 생성한 테스트 서비스로 요청을 라우트할 준비가 되었습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>라우트 추가하기</h1>
<p>게이트웨이 리소스에 라우트를 추가하려면 HTTPRoute 리소스를 사용합니다. 다른 수준의 라우팅을 위한 다른 리소스 유형도 있습니다. 이제 worlds.com/world1을 hello-world-1-svc에, worlds.com/world2를 hello-world-2-svc에 연결하기 위해 이러한 리소스 중 하나를 생성할 것입니다.</p>
<p>저는 하나의 HTTPRoute 리소스를 설명하겠고, 다른 하나는 여러분에게 만들어 달라고 요청할 것입니다. 리소스 파일을 생성해주세요:</p>
<p>hello-world-1-route.yml</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">gateway.networking.k8s.io/v1</span>
<span class="hljs-attr">kind:</span> <span class="hljs-string">HTTPRoute</span>
<span class="hljs-attr">metadata:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">example-1</span>
  <span class="hljs-attr">annotations:</span>
    <span class="hljs-attr">konghq.com/strip-path:</span> <span class="hljs-string">"true"</span>
<span class="hljs-attr">spec:</span>
  <span class="hljs-attr">parentRefs:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">kong-gateway</span>
      <span class="hljs-attr">namespace:</span> <span class="hljs-string">kong</span>
  <span class="hljs-attr">hostnames:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">worlds.com</span>
  <span class="hljs-attr">rules:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">matches:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span>
            <span class="hljs-attr">type:</span> <span class="hljs-string">PathPrefix</span>
            <span class="hljs-attr">value:</span> <span class="hljs-string">/world1</span>
      <span class="hljs-attr">backendRefs:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">hello-world-1-svc</span>
          <span class="hljs-attr">port:</span> <span class="hljs-number">80</span>
          <span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span>
</code></pre>
<p>이 파일에서는 'true'로 설정된 Kong 특정 주석인 konghq.com/strip-path를 추가했습니다. 이는 수신된 일치하는 경로를 요청에서 southbound 서비스로 줄일 것입니다. 다른 줄에는 다음이 포함되어 있습니다:</p>
<ul>
<li>사용할 게이트웨이의 정의(ParentRefs에서)는 이름과 네임스페이스로 참조됩니다.</li>
<li>게이트웨이에서 적절한 수신기에 일치시킬 호스트명에 대한 선택적 참조</li>
<li>이 경로에 대해 들어오는 요청과 일치시키는 규칙</li>
<li>요청을 이 일치에 대해 경로지정할 서비스를 정의하는 backendRefs(서비스의 내부 DNS 이름이름이며 포트는 서비스에 대한 매핑되지 않은 클러스터 IP 포트임을 주의하세요)</li>
</ul>
<p>이 경로에서 일치는 /world1의 접두사이며, 그 후 서비스로 전달되기 전에 제거됩니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이제 다음 라우트를 만듭니다:</p>
<pre><code class="hljs language-js">kubectl apply -f hello-world-<span class="hljs-number">1</span>-route.<span class="hljs-property">yml</span>
</code></pre>
<p>NodePort 서비스를 사용하여 게이트웨이를 만들었습니다. 이제 서비스를 테스트할 수 있습니다. NodePort 서비스는 클러스터의 모든 노드에서 사용할 수 있습니다. 보통 저는 k8s-master 노드를 사용하지만 다른 노드도 사용할 수 있습니다. 다음 명령어로 테스트할 수 있습니다:</p>
<pre><code class="hljs language-js">curl -H <span class="hljs-string">"Host: worlds.com"</span> &#x3C;k8s-master <span class="hljs-variable constant_">IP</span> 주소>:<span class="hljs-number">32001</span>/world2
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>원하는 요청 라우팅을 위해 Host 헤더로 호스트명을 worlds.com으로 설정했습니다. 테스트 서비스 응답이 돌아오는 것을 확인할 수 있어야 합니다.</p>
<p>이제 두 번째 HTTPRoute 리소스를 추가하여 두 번째 서비스의 요청을 관리할 수 있습니다.</p>
<p>이제 클러스터 노드에서 서비스에 액세스할 수 있으므로 최종 단계 진행할 수 있습니다 - gw 서버 구성.</p>
<h1>인그레스 지점 구성</h1>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>만약 AWS, Azure, 또는 Google Cloud에서 작업 중이었다면, Gateway 서비스를 LoadBalancer로 유지하고 자동으로 인그레스 포인트가 생성되도록 할 수 있었을 텐데 Binary Lane에서 작업 중이므로 직접 만들어야 합니다.</p>
<p>제 글을 따라오셨다면 알겠지만, 저희는 클러스터로부터 인터넷으로의 인그레스 포인트로 작용하는 gw 서버가 있다는 것을 알고 계실 것입니다. 이 서버는 간단하게 NGINX를 사용하여 구성되어 있습니다.</p>
<p>우리는 이것을 모든 요청을 라운드 로빈 로드 밸런서를 사용하여 클러스터 내 모든 노드로 경로를 설정하도록 구성할 것입니다.</p>
<p>gw 서버에 로그인하고 root 사용자로 다음 파일을 업데이트하십시오 (``에 자신의 값으로 필드를 교체하는 것을 잊지 마세요):</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>아래는 worlds.conf 파일의 내용입니다.</p>
<pre><code class="hljs language-js">upstream k8s_cluster {
  server &#x3C;k8s-master>:<span class="hljs-number">32001</span>;
  server &#x3C;k8s-node1>:<span class="hljs-number">32001</span>;
  server &#x3C;k8s-node2>:<span class="hljs-number">32001</span>;
}

server {
    listen <span class="hljs-number">80</span>;
    listen [::]:<span class="hljs-number">80</span>;

    server_name worlds.<span class="hljs-property">com</span>;

    location / {
        proxy_pass <span class="hljs-attr">http</span>:<span class="hljs-comment">//k8s_cluster;</span>
        include proxy_params;
    }
}
</code></pre>
<p>일반적으로 프록시 매개변수는 별도의 파일에 설정됩니다:</p>
<p><code>/etc/nginx/proxy_params</code></p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js">proxy_set_header <span class="hljs-title class_">Host</span> $http_host;
proxy_set_header X-<span class="hljs-title class_">Real</span>-<span class="hljs-variable constant_">IP</span> $remote_addr;
proxy_set_header X-<span class="hljs-title class_">Forwarded</span>-<span class="hljs-title class_">For</span> $proxy_add_x_forwarded_for;
proxy_set_header X-<span class="hljs-title class_">Forwarded</span>-<span class="hljs-title class_">Proto</span> $scheme;
</code></pre>
<p>이렇게 하면 Host 헤더 및 기타 세부 정보가 전달되어 라우팅이 효율적으로 작동할 수 있습니다.</p>
<p>이제 사이트를 활성화하고 구성을 테스트한 다음 NGINX를 재시작하십시오:</p>
<pre><code class="hljs language-js">ln -s /etc/nginx/sites-available/worlds.<span class="hljs-property">conf</span> /etc/nginx/sites-enabled/
nginx -t
systemctl restart nginx
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>다음과 같이 테스트할 수 있습니다 ( ' '필드를 귀하의 값으로 대체하세요):</p>
<pre><code class="hljs language-js">curl -H <span class="hljs-string">"Host: worlds.com"</span> &#x3C;gw 서버 공인 <span class="hljs-variable constant_">IP</span> 주소>/world1
</code></pre>
<p>서버로부터 응답을 받아야 합니다.</p>
<p>축하합니다! 이제 콩(Kong)을 설치하고 서비스에 연결하도록 구성하는 데 성공했습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>Kong 디버깅</h1>
<p>만약 Kong에서 문제가 발생하면 디버깅하는 것이 어려울 수 있어요. 제가 Kong 설치 과정에서 발견한 몇 가지 지침을 공유해드릴게요:</p>
<ul>
<li>GatewayClass, Gateway, 그리고 controller/gateway 포드에 kubectl describe를 사용해서 결과물을 주의깊게 살펴보세요. 이런 방법을 이용해 해결책을 찾을 때까지 곤란한 상황에 직면한 적이 있어요.</li>
<li>controller와 gateway 로그를 다음과 같이 확인해보세요:</li>
</ul>
<pre><code class="hljs language-js">kubectl logs &#x3C;pod name> -n kong
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>kong-values.yml 파일을 사용하여 로깅 레벨을 높이세요 (이전에 보여준 라인의 주석을 제거하세요)</li>
<li>NodePort 주소를 얻기 위해 kubectl get svc -n kong를 사용하여 관리 UI에 접속하세요 — HTTP 포트를 사용하고 Admin API를 포트 포워딩하세요 (서비스를 외부로 바인딩하기 위해 --address 옵션을 추가하세요):</li>
</ul>
<pre><code class="hljs language-js">kubectl port--forward &#x3C;게이트웨이 파드 이름> <span class="hljs-number">8001</span>:<span class="hljs-number">8001</span> --address &#x3C;k8s-마스터 <span class="hljs-variable constant_">IP</span> 주소>
</code></pre>
<ul>
<li>포트 8001을 포워딩한 이후, Postman와 같은 REST API 도구를 사용하여 Admin UI에 접속하세요</li>
<li>접속할 수 있는 디버그 포트가 있습니다:</li>
</ul>
<pre><code class="hljs language-js">kubectl port-forward -n kong &#x3C;컨트롤러 파드 이름>  <span class="hljs-number">10256</span>:<span class="hljs-number">10256</span> --address &#x3C;k8s-마스터 <span class="hljs-variable constant_">IP</span> 주소>
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>요약</h1>
<p>이 글은 API Gateway인 Kong을 설치하기 위해 필요한 모든 단계를 함께 수행해야 하기 때문에 길었습니다.</p>
<p>이 글에서 우리는:</p>
<ul>
<li>네트워크 토폴로지를 검토했습니다.</li>
<li>서비스가 서비스에 접근하는 데 도움이 되는 방법을 살펐습니다.</li>
<li>Kong이 Kubernetes와 어떻게 작동하는지 살펐습니다.</li>
<li>사용할 테스트 서비스를 생성했습니다.</li>
<li>GatewayClass 및 Gateway 리소스를 설치하고 구성했습니다.</li>
<li>Kong을 설치하고 구성했습니다.</li>
<li>자체 외부 로드 밸런서를 구성했습니다.</li>
<li>API Gateway 설치 문제를 해결하는 방법을 고려했습니다.</li>
</ul>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>마침내 저희는 Kong API 게이트웨이를 통해 인터넷에서 저희의 테스트 서비스에 접속할 수 있었습니다.</p>
<p>이 기사가 흥미롭게 여겨진다면 박수를 부탁드립니다. 이는 미래에 어떤 기사를 쓸지 판단하는 데 도움이 됩니다. 의견이 있으시면 댓글에 남겨주시기 바랍니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"클라우드 제공 로드밸런서 없이 Kong과 Gateway를 사용하여 Kubernetes 서비스에 접근하는 방법","description":"","date":"2024-06-23 23:10","slug":"2024-06-23-UsingKongtoaccessKubernetesservicesusingaGatewayresourcewithnocloudprovidedLoadBalancer","content":"\n## 이 기사에서는 쿠버네티스 클러스터 내에서 Kong을 API 게이트웨이로 배포하여 서비스에 관리된 액세스를 제공하는 방법을 살펴봅니다. 이를 클라우드 서비스에서 수행합니다. 이 클라우드 서비스는 쿠버네티스 호환 외부 로드 밸런서 서비스를 제공하지 않습니다. 또한 Ingress 리소스 대신 최신 Kubernetes Gateway를 사용합니다.\n\n저와 이전 기사 중 한 가지 이상을 따르신 분들은 저의 이전 기사들 중 하나를 따라오셨을 것입니다. 저는 신뢰할 수 있고 비용 효율적이지만 제한된 범위의 서비스를 제공하는 호주 클라우드 제공자인 Binary Lane을 사용합니다.\n\n제한된 범위의 서비스만 제공하는 것은 모든 쿠버네티스 작업을 직접해야 하므로, 배우고 솔루션의 작동 방식을 제어할 수 있는 기회를 제공합니다. 또한 어떤 클라우드 공급 업체에도 얽매이지 않을 수 있습니다. 또한 비용 효율적입니다.\n\n이 기사에서는 Kubernetes 클러스터에 Kong API 게이트웨이를 추가하여 서비스에 액세스하는 방법을 살펴봅니다. 할 일이 꽤 많기 때문에 이 기사는 좀 길지만, API 게이트웨이의 역할에 대한 이론 부분을 별도의 기사로 분리했습니다. API 게이트웨이의 역할을 이해하지 못하신다면 먼저 해당 기사를 읽는 것을 권장합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nKong은 신뢰할 만한 엔터프라이즈급 API 게이트웨이이지만 설정하기가 매우 까다로울 수 있습니다. 이 기사의 끝에서 문제를 디버그하는 방법에 대한 일부 힌트를 제공하겠습니다. 이 기사에서 설계를 조정하는 경우, 이름과 포트를 올바르게 구성했는지 확인하세요.\n\n# 네트워크 디자인\n\nKubernetes 네트워킹은 복잡한 주제이며 여기서 다루기 어렵지만, 고수준에서 네트워크 디자인에 대해 생각해야 합니다.\n\n![네트워크 디자인](/assets/img/2024-06-23-UsingKongtoaccessKubernetesservicesusingaGatewayresourcewithnocloudprovidedLoadBalancer_0.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이전 기사를 따라오셨다면, 이제 이진 레인(또는 다른 클라우드 제공업체) 서버에 Kubernetes 클러스터가 설치되어 있어야 합니다. 인터넷에서 접근이 불가능한 가상 사설 클라우드 (VPC) 개인 서브넷에 세 개의 노드가 설치되어 있을 것입니다. 이러한 노드들은 인터넷을 통해 접속이 가능한 전용 VPN을 통해서만 연결됩니다(위에는 표시되지 않음). 인터넷 및 VPC 인터페이스를 모두 가지고 있는 게이트웨이 서버가 있어서, 인터넷에서 클러스터로 들어오는 접속(inress)과 클러스터에서 인터넷으로 나가는 접속(egress)을 제공합니다.\n\n기본 네트워크 토폴로지가 이제 갖추어 졌습니다. 이제 우리는 서비스가 외부 세계에 제공하는 API를 관리할 수 있기를 원합니다. 이 작업은 Kong Gateway API를 통해 수행됩니다.\n\n# 인터넷에서 연결 설정하기 (인그레스)\n\nAWS, 구글 클라우드 또는 Azure와 같은 풀 서비스 제공업체를 사용하면, LoadBalancer 유형의 Kubernetes 서비스를 사용하여 인터넷 연결이 자동으로 생성되는 방식으로 Kubernetes를 설정할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n바이너리 레인에는 로드 밸런서 서비스가 있지만 쿠버네티스를 통해 관리할 수는 없으므로 로드 밸런서를 직접 생성하고 구성하거나 고유한 인그레스 포인트를 만들어야 합니다. 특정 클라우드 제공 업체의 기능에 구속되지 않기 위해, 저는 개인적으로 내 gw 서버에서 NGINX 역방향 프록시를 실행하여 고유한 인그레스 포인트를 만드는 것을 선호합니다.\n\n이 아키텍처에서 gw 서버에서 실행되는 NGINX는 두 가지 기능을 수행합니다:\n\n- 유효한 요청을 모두 쿠버네티스 클러스터로 라우팅하여 Kong이 처리\n- 쿠버네티스 노드 간 요청을 로드 밸런싱\n\nKong이 NodePort 서비스로 노출될 것이므로 클러스터의 모든 노드에서 액세스할 수 있습니다. 이를 통해 NGINX가 노드 간 요청을 로드 밸런싱할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n서비스 자체가 사용 가능한 파드 전체에 무작위로 로드 밸런싱을 수행하므로 NGINX에 의한 로드 밸런싱이 노드 장애나 과부하 상황을 견딜 목적으로만 사용된다는 것을 유의한 점입니다. 서비스 로드 밸런싱에 대해 더 읽어보실 수 있습니다.\n\n본 솔루션에서 NGINX를 수동으로 구성된, 대체될 수 있는 외부 로드 밸런서로 간주하실 수 있습니다.\n\n# 쿠버네티스 서비스\n\n쿠버네티스 서비스는 하나 이상의 파드가 제공하는 서비스에 대한 액세스를 허용합니다. 이를 통해 파드가 종료되고 재예약되더라도 특정 노드에서 요청이 발생하더라도 서비스가 계속하여 요구에 따른 대로 요청을 라우팅하는 단일 접점으로 유지됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](/assets/img/2024-06-23-UsingKongtoaccessKubernetesservicesusingaGatewayresourcewithnocloudprovidedLoadBalancer_1.png)\n\n서비스를 사용함으로써 요청을 보낼 수 있는 단일하고 안정적인 IP 주소가 제공됩니다. 서비스는 사용 가능한 Pod들 사이에서 부하 분산 기능을 제공합니다. Kubernetes는 또한 클러스터의 DNS에 서비스에 대한 참조를 추가함으로써 서비스가 이름으로 액세스될 수 있게 합니다. 여러 가지 다른 변형이 등록됩니다:\n\n```js\n\u003c서비스 이름\u003e.\u003c네임스페이스\u003e.svc.local\n\u003c서비스 이름\u003e.\u003c네임스페이스\u003e.svc\n\u003c서비스 이름\u003e.\u003c네임스페이스\u003e\n\u003c서비스 이름\u003e\n```\n\n# API 게이트웨이\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNGINX 게이트웨이와 쿠버네티스 서비스는 서비스에 대한 외부 인터페이스를 제공하는 데 도움이 되지만 기능이 제한적이며 수동으로 설정해야 합니다.\n\nAPI 게이트웨이는 이 문제를 해결하는 클러스터 구성 요소입니다. 이 게이트웨이는 솔루션의 일부로 구성되며 서비스 앞에 위치하여 여기서 설명하는 추가 기능을 제공합니다.\n\n![image](/assets/img/2024-06-23-UsingKongtoaccessKubernetesservicesusingaGatewayresourcewithnocloudprovidedLoadBalancer_2.png)\n\nAPI 게이트웨이는 클러스터의 일부로 있기 때문에 클러스터 내 리소스의 변경에 따라 자동으로 구성될 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# Kong API Gateway\n\n다양한 API 게이트웨이 기술이 있지만, 이 글에서는 무료 오픈 소스 솔루션인 Kong을 선택했습니다. 유료 엔터프라이즈 설치도 가능합니다. 여기에서 Kong에 대한 포괄적인 공식 문서를 찾을 수 있습니다.\n\nKong은 쿠버네티스 커뮤니티와 적극적으로 협력하여 클러스터 내에서 게이트웨이에 대한 새로운 표준을 정의하고 있습니다. 이로 인해 게이트웨이 자체와 혼동되어서는 안 되는 새로운 쿠버네티스 리소스 유형인 게이트웨이 API가 만들어졌습니다.\n\n이것이 Kong이 어떻게 작동하는지 대략적으로 설명했습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/assets/img/2024-06-23-UsingKongtoaccessKubernetesservicesusingaGatewayresourcewithnocloudprovidedLoadBalancer_3.png)\n\n클러스터 외부의 모든 클라이언트로부터 들어오는 트래픽이 Kong에 도달합니다. Kong은 구성 내의 규칙에 따라 요청을 처리하고 클러스터 내외의 적절한 서비스로 요청을 전달합니다.\n\nKong은 Kubernetes 리소스 매니페스트에서 정적으로 또는 데이터베이스에서 구성을 가져올 수 있습니다 (DB-less 설치). Kong은 이제 DB-less 설치를 새로운 설치에 사용할 것을 권장하며, 이를 따를 것입니다.\n\nKong은 성숙한 플러그인 기능을 갖추고 있습니다. 이를 통해 제3자가 Kong의 플러그인으로 기능 확장을 개발할 수 있습니다. 플러그인은 트래픽 흐름에 위치하여 속도 제한 및 인증과 같은 작업에 도움을 줄 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n마지막으로 Kong을 관리하기 위해 플러그인, 구성 등을 관리할 수 있도록 Management UI를 제공합니다. Management UI는 Admin API를 통해 Kong과 상호 작용합니다.\n\nKong에 대해 상세한 문서를 살펴보면 여기서 다룰 수 있는 내용보다 더 많음을 알 수 있습니다. 그래서 제가 다루는 내용은 기본 사항에만 초점을 맞추겠습니다.\n\n## DB-less 설치\n\nDB-less 설치가 어떻게 작동하는지 이해하는 것이 중요하다고 생 생각합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 구성에서 Kong은 두 가지 구성요소를 설치합니다:\n\n- Kong Ingress Controller (KIC)\n- Kong Gateway\n\n게이트웨이는 프록시를 통해 모든 사용자 트래픽의 경로 지정을 처리합니다. Kong Ingress Controller (KIC)는 Kubernetes 리소스 정의 (예: HTTPRoute)에서 구성을 가져와서 프록시가 이해하는 규칙으로 변환하고 실시간으로 프록시에 규칙을 업로드합니다. 이러한 방식으로 Kubernetes 구성의 변경 사항이 자동으로 프록시에 적용됩니다.\n\nKIC는 내부 Kubernetes API를 사용하여 Kubernetes 클러스터에 대한 정보를 얻습니다. 이 API는 클러스터를 관리하는 데 사용되는 것으로, kubectl을 사용할 때 실제로는 Kubernetes API와 상호 작용합니다. 이 API를 통해 Kong 및 kubectl과 같은 애플리케이션은 클러스터에 대한 정보를 찾거나 변경할 수 있습니다. KIC는 이 API를 통해 백업 데이터베이스가 필요 없이 클러스터 리소스 파일과 Gateway를 동기화할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 테스트할 서비스\n\nKong 배포에 들어가기 전에 Kong을 통해 접근할 수 있는 서비스를 가지고 있어야 합니다. 어차피 API Gateway에 API가 없다면 그리 유용하지 않을 것이니까요!\n\n가장 간단한 방법은 NGINX를 웹 서버로 배포하고 정적 콘텐츠로 구성하는 것입니다. Kubernetes에서 이 작업을 한 적이 없다면 다른 기사 하나에서 그 방법을 읽어볼 수 있습니다.\n\n2개의 서비스를 생성하는 것을 제안합니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 안녕하세요 world 1: 2개의 레플리카\n- 안녕하세요 world 2: 1개의 레플리카\n\n이들은 클러스터 내 파드에서 ClusterIP 서비스를 통해 접근할 수 있어야 합니다. 이러한 서비스를 설정하는 내 기사에서는 브라우저에서 서비스를 확인할 수 있도록 NodePort 서비스를 생성합니다. 이를 수행할 경우 내부 클러스터 IP 및 포트를 사용해야 합니다. 서비스 유형에 대한 자세한 내용은 다른 기사에서 확인할 수 있습니다.\n\n두 서비스가 올바르게 실행되고 Hello World HTML을 제공할 수 있는지 확인하세요.\n\n내가 여기서 설명하는 예제에서, 내 두 서비스는 다음과 같이 위치해 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- http://`node IP 주소`:30082 — 'Hello World 1 !!'라고 응답합니다.\n- http://`node IP 주소`:30082 — 'Hello World 2 !!'라고 응답합니다.\n\n어느 경로도 필요하지 않으며 경로를 추가하면 (예: http://`node IP 주소`:30082/world1) 404 오류가 발생합니다. 이 사실을 인식하지 못하면 나중에 문제가 될 수 있으므로 주의해야 합니다.\n\n이제 서비스가 실행 중이므로 Kong을 통해 액세스해 보겠습니다.\n\n# 쿠버네티스 게이트웨이 자원 생성하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nDB 미사용 모드에서는 Kong API 게이트웨이를 구성할 때 Kubernetes Ingress 또는 HTTPRoute 리소스를 생성합니다. 이러한 리소스를 클러스터에 적용하면 Kong이 프록시 구성 요소 내에서 라우팅 규칙을 정의하는 데 사용됩니다. 이를 통해 들어오는 트래픽이 서비스로 전달됩니다.\n\nIngress 리소스는 작동하지만 기능이 제한적입니다. Kubernetes 커뮤니티와 함께 Kong에서 개발한 새 Gateway 리소스를 사용하면 API를 더 정교하게 관리할 수 있습니다.\n\n우리는 Kong과 함께 Gateway 리소스를 사용할 것입니다. 이를 위해 먼저 GatewayClass 및 Gateway 리소스를 지원하는 새로운 Custom Resource Definitions (CRD)를 클러스터에 적용해야 합니다. 클러스터에서 kubectl을 실행하는 위치에서 다음 명령을 실행하여 이 작업을 수행할 수 있습니다. 저의 경우에는 제 k8s-master 서버에서 이를 실행합니다.\n\n```js\nkubectl apply -f https://github.com/kubernetes-sigs/gateway-api/releases/download/v1.0.0/standard-install.yaml\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n본 문서에서는 사용하지 않을 실험적 기능 몇 가지를 소개해드리겠습니다만, 참고용으로 여기에 추가해두었습니다.\n\n```js\nkubectl apply -f https://github.com/kubernetes-sigs/gateway-api/releases/download/v1.0.0/experimental-install.yaml\n```\n\n이제 Kubernetes를 위해 GatewayClass 및 Gateway 두 리소스를 정의할 수 있습니다. 이들이 무엇을 하는 지에 대해 설명했으니, 이를 다시 반복하지는 않겠습니다. 간결함을 위해 해당 내용은 여기서 생략합니다.\n\n## GatewayClass\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nKong 기술을 클러스터에 소개하는 GatewayClass를 정의할 것입니다. 다음 파일을 생성해주세요:\n\nkong-gw-class.yml\n\n```yaml\napiVersion: gateway.networking.k8s.io/v1\nkind: GatewayClass\nmetadata:\n  name: kong-class\n  annotations:\n    konghq.com/gatewayclass-unmanaged: \"true\"\nspec:\n  controllerName: konghq.com/kic-gateway-controller\n```\n\n이 파일에 대해 몇 가지 주의할 사항이 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 이것은 클러스터 수준 리소스이기 때문에 네임스페이스가 없습니다.\n- 주석은 솔루션별 옵션을 정의하며 Kong의 경우 konghq로 시작합니다.\n- konghq.com/gatewayclass-unmanaged 주석은 'true'(문자열)로 설정되어 있습니다. 왜냐하면 Kong이 오퍼레이터를 통해 자동으로 설정되는 것이 아니라 수동으로 설정되고 있기 때문입니다.(다른 옵션도 있으니 여기를 참조하세요)\n- 인그레스 컨트롤러는 Kong 인그레스 컨트롤러(konghq.com/kic-gateway-controller)이며 contollerName 필드에서 구성됩니다.\n\n이제 다음과 같이 클래스를 생성하세요:\n\n```js\nkubectl apply -f kong-gw-class.yml\n```\n\n이제 이 클래스를 사용하는 게이트웨이를 생성할 수 있습니다. 동일한 GatewayClass를 참조하는 여러 Gateway 인스턴스를 생성할 수 있다는 점을 유의하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 게이트웨이\n\n수동으로 설치된 Kong 게이트웨이의 경우 (우리가 생성중인 것과 같이), 다음 파일을 만들어야 합니다:\n\nkong-gw-gateway.yml\n\n```yaml\napiVersion: gateway.networking.k8s.io/v1\nkind: Gateway\nmetadata:\n  name: kong-gateway\n  namespace: kong\nspec:\n  gatewayClassName: kong-class\n  listeners:\n    - name: world-selector\n      hostname: worlds.com\n      port: 80\n      protocol: HTTP\n      allowedRoutes:\n        namespaces:\n          from: All\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n파일에서 유의해야 할 몇 가지 사항이 또 있습니다:\n\n- 나중에 참조할 수 있는 이름이 있습니다 (kong-gateway)\n- GatewayClass는 위에서 생성한 GatewayClass의 이름을 의미합니다\n- 이 Gateway는 이 API Gateway의 진입점인 하나의 리스너만 정의합니다\n- 리스너에는 URL 호환성이 있는 고유한 이름이 지정됩니다\n- 리스너는 포트 80에 바인드됩니다\n- 호스트명은 일치 필드로 사용되며 옵션입니다\n- 이 리스너에 연결할 서비스(allowedRoutes)를 제어할 수 있으며 해당 서비스들은 네임스페이스를 통해 연결됩니다 - 동일한 네임스페이스를 기본으로 사용하여 다른 네임스페이스로 연결하기 위해 모든 네임스페이스로 변경됩니다\n- Gateway 사양은 게이트웨이가 HTTP를 통해 단일 포트(80)에서 수신하는 것을 예상합니다.\n\nGateways는 네임스페이스에 특정하며 API Gateway를 설치하기 전에 생성해야 합니다:\n\n```js\nkubectl create namespace kong\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 다음 명령을 사용하여 리소스를 만드세요:\n\n```js\nkubectl apply -f kong-gw-gateway.yml\n```\n\n이제 GatewayClass 및 Gateway 리소스가 정의되었으므로, 애플리케이션 자체를 설치하여 이 두 리소스의 구현을 형성할 수 있습니다.\n\n# Kong 설치\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n지금은 Helm 차트를 사용하여 Kong을 설치할 것입니다. 만약 Helm이 없다면, Helm을 설치하는 방법은 여기에서 찾을 수 있습니다.\n\n## Kong CRDs\n\nKong을 설치하기 전에 Kong Custom Resource Definitions (CRDs)를 설치해야 합니다. 이 작업은 클러스터에서 kubectl을 실행하는 위치에서 다음 명령을 실행하여 수행할 수 있습니다. 제 경우에는 k8s-master 서버에서 이 작업을 수행하고 있습니다.\n\n```js\nkubectl apply -k https://github.com/Kong/kubernetes-ingress-controller/config/crd\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## Kong Application\n\nKong을 Kubernetes 클러스터에 설치할 때, 두 가지 구성 요소가 설치됩니다:\n\n- Kong 인그레스 컨트롤러 (KIC) — 쿠버네티스 리소스 정의를 Kong 게이트웨이 구성으로 변환합니다.\n- Kong 게이트웨이 — Kong 인그레스 컨트롤러 (KIC)에 의해 삽입된 구성을 기반으로 서비스로의 라우팅을 담당합니다.\n\n먼저, 로컬 헬름에 Kong 저장소를 추가하십시오:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nhelm repo add kong https://charts.konghq.com\nhelm repo update\n```\n\n만약 다음 명령어로 Helm 차트를 검색하면:\n\n```js\nhelm search repo kong\n```\n\n두 개의 항목을 찾을 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n이름           차트 버전  앱 버전  설명\nkong/kong    2.33.3    3.5       클라우드 네이티브 인그레스 및 API 관리\nkong/ingress 0.10.2    3.4       콩 인그레스 컨트롤러 및 콩 게이트웨이 배포\n```\n\nDB 레스 구성을 사용할 것이므로 kong/ingress를 사용할 것입니다. 설치하기 전에 몇 가지 값을 재정의해야 합니다. 다음 파일을 만들어주세요:\n\nkong-values.yml\n\n```js\n#controller:\n#  ingressController:\n#    env:\n#      LOG_LEVEL: trace\n#      dump_config: true\n\ngateway:\n  admin:\n    http:\n      enabled: true\n  proxy:\n    type: NodePort\n    http:\n      enabled: true\n      nodePort: 32001\n    tls:\n      enabled: false\n#  ingressController:\n#    env:\n#      LOG_LEVEL: trace\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nKIC 및 Kong Gateway를 부모 Helm 차트를 통해 설치하고 있기 때문에 이 두 애플리케이션의 구성은 각각 컨트롤러 및 게이트웨이 레이블 아래에 있습니다. 컨트롤러는 단순히 알림으로 남겨두었습니다.\n\n또한, 주석 처리된 여러 줄을 볼 수 있습니다. 이것들은 Pod 로그를 통해 무엇이 발생하는지 디버그하고 싶을 때 유용합니다.\n\nBinary Lane은 Kubernetes가 구성할 수 있는 로드 밸런서를 제공하지 않기 때문에 프록시 구성을 재정의하고 있습니다. Kubernetes에게 LoadBalancer 서비스 대신 NodePort 서비스를 설정하도록 지시하고 있습니다. 게이트웨이를 클러스터의 모든 노드에서 사용할 수 있도록 포트 32001에 노출하고 있습니다.\n\n이전에 kong 네임스페이스를 생성했으므로 이제 Kong을 설치할 준비가 되었습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nhelm install kong kong/ingress -f kong-values.yml -n kong\n```\n\n이제 설치가 예상대로 작동하는지 확인할 수 있습니다. 준비되는 데 1-2분 정도 걸릴 수 있습니다:\n\n```js\nkubectl get all -n kong\n```\n\n다음과 같은 결과를 얻어야 합니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### NAME READY STATUS RESTARTS AGE\n\n- pod/kong-controller-68cddcbcb7-z46lh 1/1 Running 0 45s\n- pod/kong-gateway-687c5b78db-5qvgd 1/1 Running 0 45s\n\n### NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE\n\n- service/kong-controller-validation-webhook ClusterIP 10.110.172.40 \u003cnone\u003e 443/TCP 46s\n- service/kong-gateway-admin ClusterIP None \u003cnone\u003e 8444/TCP 46s\n- service/kong-gateway-manager NodePort 10.100.254.169 \u003cnone\u003e 8002:30698/TCP,8445:30393/TCP 46s\n- service/kong-gateway-proxy NodePort 10.96.24.196 \u003cnone\u003e 80:32001/TCP 46s\n\n### NAME READY UP-TO-DATE AVAILABLE AGE\n\n- deployment.apps/kong-controller 1/1 1 1 45s\n- deployment.apps/kong-gateway 1/1 1 1 45s\n\n### NAME DESIRED CURRENT READY AGE\n\n- replicaset.apps/kong-controller-68cddcbcb7 1 1 1 45s\n- replicaset.apps/kong-gateway-687c5b78db 1 1 1 45s\n\nManagement UI 서비스가 NodePort를 통해 노출됩니다. 이는 관리 API를 볼 수 있는 것을 기대하고 작동하지 않을 것입니다. DB-less 설치를 하고 있기 때문에, 관리 UI의 유일한 사용은 설정을 확인하는 것뿐입니다.\n\n클러스터 내 노드에서 프록시 주소를 curl로 테스트할 수 있습니다:\n\n```js\ncurl localhost:32001\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n요청한 표는 Markdown 형식으로 변경해야 합니다.\n\n```json\n{\n  \"message\": \"해당 값으로 일치하는 경로가 없습니다.\",\n  \"request_id\": \"7fc9db053e3029105581890e81effe12\"\n}\n```\n\n요청 ID는 해당 거래에 고유하며 curl 명령을 다시 실행하면 다른 값을 볼 수 있습니다. 이는 Kong에서 추가되어 시스템을 통해 요청을 추적할 수 있게 합니다. 멋지죠?\n\n이제 새 API 게이트웨이를 구성하여 이전에 생성한 테스트 서비스로 요청을 라우트할 준비가 되었습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 라우트 추가하기\n\n게이트웨이 리소스에 라우트를 추가하려면 HTTPRoute 리소스를 사용합니다. 다른 수준의 라우팅을 위한 다른 리소스 유형도 있습니다. 이제 worlds.com/world1을 hello-world-1-svc에, worlds.com/world2를 hello-world-2-svc에 연결하기 위해 이러한 리소스 중 하나를 생성할 것입니다.\n\n저는 하나의 HTTPRoute 리소스를 설명하겠고, 다른 하나는 여러분에게 만들어 달라고 요청할 것입니다. 리소스 파일을 생성해주세요:\n\nhello-world-1-route.yml\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```yaml\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: example-1\n  annotations:\n    konghq.com/strip-path: \"true\"\nspec:\n  parentRefs:\n    - name: kong-gateway\n      namespace: kong\n  hostnames:\n    - worlds.com\n  rules:\n    - matches:\n        - path:\n            type: PathPrefix\n            value: /world1\n      backendRefs:\n        - name: hello-world-1-svc\n          port: 80\n          kind: Service\n```\n\n이 파일에서는 'true'로 설정된 Kong 특정 주석인 konghq.com/strip-path를 추가했습니다. 이는 수신된 일치하는 경로를 요청에서 southbound 서비스로 줄일 것입니다. 다른 줄에는 다음이 포함되어 있습니다:\n\n- 사용할 게이트웨이의 정의(ParentRefs에서)는 이름과 네임스페이스로 참조됩니다.\n- 게이트웨이에서 적절한 수신기에 일치시킬 호스트명에 대한 선택적 참조\n- 이 경로에 대해 들어오는 요청과 일치시키는 규칙\n- 요청을 이 일치에 대해 경로지정할 서비스를 정의하는 backendRefs(서비스의 내부 DNS 이름이름이며 포트는 서비스에 대한 매핑되지 않은 클러스터 IP 포트임을 주의하세요)\n\n이 경로에서 일치는 /world1의 접두사이며, 그 후 서비스로 전달되기 전에 제거됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 다음 라우트를 만듭니다:\n\n```js\nkubectl apply -f hello-world-1-route.yml\n```\n\nNodePort 서비스를 사용하여 게이트웨이를 만들었습니다. 이제 서비스를 테스트할 수 있습니다. NodePort 서비스는 클러스터의 모든 노드에서 사용할 수 있습니다. 보통 저는 k8s-master 노드를 사용하지만 다른 노드도 사용할 수 있습니다. 다음 명령어로 테스트할 수 있습니다:\n\n```js\ncurl -H \"Host: worlds.com\" \u003ck8s-master IP 주소\u003e:32001/world2\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n원하는 요청 라우팅을 위해 Host 헤더로 호스트명을 worlds.com으로 설정했습니다. 테스트 서비스 응답이 돌아오는 것을 확인할 수 있어야 합니다.\n\n이제 두 번째 HTTPRoute 리소스를 추가하여 두 번째 서비스의 요청을 관리할 수 있습니다.\n\n이제 클러스터 노드에서 서비스에 액세스할 수 있으므로 최종 단계 진행할 수 있습니다 - gw 서버 구성.\n\n# 인그레스 지점 구성\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 AWS, Azure, 또는 Google Cloud에서 작업 중이었다면, Gateway 서비스를 LoadBalancer로 유지하고 자동으로 인그레스 포인트가 생성되도록 할 수 있었을 텐데 Binary Lane에서 작업 중이므로 직접 만들어야 합니다.\n\n제 글을 따라오셨다면 알겠지만, 저희는 클러스터로부터 인터넷으로의 인그레스 포인트로 작용하는 gw 서버가 있다는 것을 알고 계실 것입니다. 이 서버는 간단하게 NGINX를 사용하여 구성되어 있습니다.\n\n우리는 이것을 모든 요청을 라운드 로빈 로드 밸런서를 사용하여 클러스터 내 모든 노드로 경로를 설정하도록 구성할 것입니다.\n\ngw 서버에 로그인하고 root 사용자로 다음 파일을 업데이트하십시오 (``에 자신의 값으로 필드를 교체하는 것을 잊지 마세요):\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 worlds.conf 파일의 내용입니다.\n\n```js\nupstream k8s_cluster {\n  server \u003ck8s-master\u003e:32001;\n  server \u003ck8s-node1\u003e:32001;\n  server \u003ck8s-node2\u003e:32001;\n}\n\nserver {\n    listen 80;\n    listen [::]:80;\n\n    server_name worlds.com;\n\n    location / {\n        proxy_pass http://k8s_cluster;\n        include proxy_params;\n    }\n}\n```\n\n일반적으로 프록시 매개변수는 별도의 파일에 설정됩니다:\n\n`/etc/nginx/proxy_params`\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nproxy_set_header Host $http_host;\nproxy_set_header X-Real-IP $remote_addr;\nproxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\nproxy_set_header X-Forwarded-Proto $scheme;\n```\n\n이렇게 하면 Host 헤더 및 기타 세부 정보가 전달되어 라우팅이 효율적으로 작동할 수 있습니다.\n\n이제 사이트를 활성화하고 구성을 테스트한 다음 NGINX를 재시작하십시오:\n\n```js\nln -s /etc/nginx/sites-available/worlds.conf /etc/nginx/sites-enabled/\nnginx -t\nsystemctl restart nginx\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음과 같이 테스트할 수 있습니다 ( ' '필드를 귀하의 값으로 대체하세요):\n\n```js\ncurl -H \"Host: worlds.com\" \u003cgw 서버 공인 IP 주소\u003e/world1\n```\n\n서버로부터 응답을 받아야 합니다.\n\n축하합니다! 이제 콩(Kong)을 설치하고 서비스에 연결하도록 구성하는 데 성공했습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# Kong 디버깅\n\n만약 Kong에서 문제가 발생하면 디버깅하는 것이 어려울 수 있어요. 제가 Kong 설치 과정에서 발견한 몇 가지 지침을 공유해드릴게요:\n\n- GatewayClass, Gateway, 그리고 controller/gateway 포드에 kubectl describe를 사용해서 결과물을 주의깊게 살펴보세요. 이런 방법을 이용해 해결책을 찾을 때까지 곤란한 상황에 직면한 적이 있어요.\n- controller와 gateway 로그를 다음과 같이 확인해보세요:\n\n```js\nkubectl logs \u003cpod name\u003e -n kong\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- kong-values.yml 파일을 사용하여 로깅 레벨을 높이세요 (이전에 보여준 라인의 주석을 제거하세요)\n- NodePort 주소를 얻기 위해 kubectl get svc -n kong를 사용하여 관리 UI에 접속하세요 — HTTP 포트를 사용하고 Admin API를 포트 포워딩하세요 (서비스를 외부로 바인딩하기 위해 --address 옵션을 추가하세요):\n\n```js\nkubectl port--forward \u003c게이트웨이 파드 이름\u003e 8001:8001 --address \u003ck8s-마스터 IP 주소\u003e\n```\n\n- 포트 8001을 포워딩한 이후, Postman와 같은 REST API 도구를 사용하여 Admin UI에 접속하세요\n- 접속할 수 있는 디버그 포트가 있습니다:\n\n```js\nkubectl port-forward -n kong \u003c컨트롤러 파드 이름\u003e  10256:10256 --address \u003ck8s-마스터 IP 주소\u003e\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 요약\n\n이 글은 API Gateway인 Kong을 설치하기 위해 필요한 모든 단계를 함께 수행해야 하기 때문에 길었습니다.\n\n이 글에서 우리는:\n\n- 네트워크 토폴로지를 검토했습니다.\n- 서비스가 서비스에 접근하는 데 도움이 되는 방법을 살펐습니다.\n- Kong이 Kubernetes와 어떻게 작동하는지 살펐습니다.\n- 사용할 테스트 서비스를 생성했습니다.\n- GatewayClass 및 Gateway 리소스를 설치하고 구성했습니다.\n- Kong을 설치하고 구성했습니다.\n- 자체 외부 로드 밸런서를 구성했습니다.\n- API Gateway 설치 문제를 해결하는 방법을 고려했습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n마침내 저희는 Kong API 게이트웨이를 통해 인터넷에서 저희의 테스트 서비스에 접속할 수 있었습니다.\n\n이 기사가 흥미롭게 여겨진다면 박수를 부탁드립니다. 이는 미래에 어떤 기사를 쓸지 판단하는 데 도움이 됩니다. 의견이 있으시면 댓글에 남겨주시기 바랍니다.\n","ogImage":{"url":"/assets/img/2024-06-23-UsingKongtoaccessKubernetesservicesusingaGatewayresourcewithnocloudprovidedLoadBalancer_0.png"},"coverImage":"/assets/img/2024-06-23-UsingKongtoaccessKubernetesservicesusingaGatewayresourcewithnocloudprovidedLoadBalancer_0.png","tag":["Tech"],"readingTime":27},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch2\u003e이 기사에서는 쿠버네티스 클러스터 내에서 Kong을 API 게이트웨이로 배포하여 서비스에 관리된 액세스를 제공하는 방법을 살펴봅니다. 이를 클라우드 서비스에서 수행합니다. 이 클라우드 서비스는 쿠버네티스 호환 외부 로드 밸런서 서비스를 제공하지 않습니다. 또한 Ingress 리소스 대신 최신 Kubernetes Gateway를 사용합니다.\u003c/h2\u003e\n\u003cp\u003e저와 이전 기사 중 한 가지 이상을 따르신 분들은 저의 이전 기사들 중 하나를 따라오셨을 것입니다. 저는 신뢰할 수 있고 비용 효율적이지만 제한된 범위의 서비스를 제공하는 호주 클라우드 제공자인 Binary Lane을 사용합니다.\u003c/p\u003e\n\u003cp\u003e제한된 범위의 서비스만 제공하는 것은 모든 쿠버네티스 작업을 직접해야 하므로, 배우고 솔루션의 작동 방식을 제어할 수 있는 기회를 제공합니다. 또한 어떤 클라우드 공급 업체에도 얽매이지 않을 수 있습니다. 또한 비용 효율적입니다.\u003c/p\u003e\n\u003cp\u003e이 기사에서는 Kubernetes 클러스터에 Kong API 게이트웨이를 추가하여 서비스에 액세스하는 방법을 살펴봅니다. 할 일이 꽤 많기 때문에 이 기사는 좀 길지만, API 게이트웨이의 역할에 대한 이론 부분을 별도의 기사로 분리했습니다. API 게이트웨이의 역할을 이해하지 못하신다면 먼저 해당 기사를 읽는 것을 권장합니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eKong은 신뢰할 만한 엔터프라이즈급 API 게이트웨이이지만 설정하기가 매우 까다로울 수 있습니다. 이 기사의 끝에서 문제를 디버그하는 방법에 대한 일부 힌트를 제공하겠습니다. 이 기사에서 설계를 조정하는 경우, 이름과 포트를 올바르게 구성했는지 확인하세요.\u003c/p\u003e\n\u003ch1\u003e네트워크 디자인\u003c/h1\u003e\n\u003cp\u003eKubernetes 네트워킹은 복잡한 주제이며 여기서 다루기 어렵지만, 고수준에서 네트워크 디자인에 대해 생각해야 합니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-UsingKongtoaccessKubernetesservicesusingaGatewayresourcewithnocloudprovidedLoadBalancer_0.png\" alt=\"네트워크 디자인\"\u003e\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이전 기사를 따라오셨다면, 이제 이진 레인(또는 다른 클라우드 제공업체) 서버에 Kubernetes 클러스터가 설치되어 있어야 합니다. 인터넷에서 접근이 불가능한 가상 사설 클라우드 (VPC) 개인 서브넷에 세 개의 노드가 설치되어 있을 것입니다. 이러한 노드들은 인터넷을 통해 접속이 가능한 전용 VPN을 통해서만 연결됩니다(위에는 표시되지 않음). 인터넷 및 VPC 인터페이스를 모두 가지고 있는 게이트웨이 서버가 있어서, 인터넷에서 클러스터로 들어오는 접속(inress)과 클러스터에서 인터넷으로 나가는 접속(egress)을 제공합니다.\u003c/p\u003e\n\u003cp\u003e기본 네트워크 토폴로지가 이제 갖추어 졌습니다. 이제 우리는 서비스가 외부 세계에 제공하는 API를 관리할 수 있기를 원합니다. 이 작업은 Kong Gateway API를 통해 수행됩니다.\u003c/p\u003e\n\u003ch1\u003e인터넷에서 연결 설정하기 (인그레스)\u003c/h1\u003e\n\u003cp\u003eAWS, 구글 클라우드 또는 Azure와 같은 풀 서비스 제공업체를 사용하면, LoadBalancer 유형의 Kubernetes 서비스를 사용하여 인터넷 연결이 자동으로 생성되는 방식으로 Kubernetes를 설정할 수 있습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e바이너리 레인에는 로드 밸런서 서비스가 있지만 쿠버네티스를 통해 관리할 수는 없으므로 로드 밸런서를 직접 생성하고 구성하거나 고유한 인그레스 포인트를 만들어야 합니다. 특정 클라우드 제공 업체의 기능에 구속되지 않기 위해, 저는 개인적으로 내 gw 서버에서 NGINX 역방향 프록시를 실행하여 고유한 인그레스 포인트를 만드는 것을 선호합니다.\u003c/p\u003e\n\u003cp\u003e이 아키텍처에서 gw 서버에서 실행되는 NGINX는 두 가지 기능을 수행합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e유효한 요청을 모두 쿠버네티스 클러스터로 라우팅하여 Kong이 처리\u003c/li\u003e\n\u003cli\u003e쿠버네티스 노드 간 요청을 로드 밸런싱\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eKong이 NodePort 서비스로 노출될 것이므로 클러스터의 모든 노드에서 액세스할 수 있습니다. 이를 통해 NGINX가 노드 간 요청을 로드 밸런싱할 수 있습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e서비스 자체가 사용 가능한 파드 전체에 무작위로 로드 밸런싱을 수행하므로 NGINX에 의한 로드 밸런싱이 노드 장애나 과부하 상황을 견딜 목적으로만 사용된다는 것을 유의한 점입니다. 서비스 로드 밸런싱에 대해 더 읽어보실 수 있습니다.\u003c/p\u003e\n\u003cp\u003e본 솔루션에서 NGINX를 수동으로 구성된, 대체될 수 있는 외부 로드 밸런서로 간주하실 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e쿠버네티스 서비스\u003c/h1\u003e\n\u003cp\u003e쿠버네티스 서비스는 하나 이상의 파드가 제공하는 서비스에 대한 액세스를 허용합니다. 이를 통해 파드가 종료되고 재예약되더라도 특정 노드에서 요청이 발생하더라도 서비스가 계속하여 요구에 따른 대로 요청을 라우팅하는 단일 접점으로 유지됩니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-UsingKongtoaccessKubernetesservicesusingaGatewayresourcewithnocloudprovidedLoadBalancer_1.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e서비스를 사용함으로써 요청을 보낼 수 있는 단일하고 안정적인 IP 주소가 제공됩니다. 서비스는 사용 가능한 Pod들 사이에서 부하 분산 기능을 제공합니다. Kubernetes는 또한 클러스터의 DNS에 서비스에 대한 참조를 추가함으로써 서비스가 이름으로 액세스될 수 있게 합니다. 여러 가지 다른 변형이 등록됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u0026#x3C;서비스 이름\u003e.\u0026#x3C;네임스페이스\u003e.\u003cspan class=\"hljs-property\"\u003esvc\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003elocal\u003c/span\u003e\n\u0026#x3C;서비스 이름\u003e.\u0026#x3C;네임스페이스\u003e.\u003cspan class=\"hljs-property\"\u003esvc\u003c/span\u003e\n\u0026#x3C;서비스 이름\u003e.\u0026#x3C;네임스페이스\u003e\n\u0026#x3C;서비스 이름\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003eAPI 게이트웨이\u003c/h1\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eNGINX 게이트웨이와 쿠버네티스 서비스는 서비스에 대한 외부 인터페이스를 제공하는 데 도움이 되지만 기능이 제한적이며 수동으로 설정해야 합니다.\u003c/p\u003e\n\u003cp\u003eAPI 게이트웨이는 이 문제를 해결하는 클러스터 구성 요소입니다. 이 게이트웨이는 솔루션의 일부로 구성되며 서비스 앞에 위치하여 여기서 설명하는 추가 기능을 제공합니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-UsingKongtoaccessKubernetesservicesusingaGatewayresourcewithnocloudprovidedLoadBalancer_2.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003eAPI 게이트웨이는 클러스터의 일부로 있기 때문에 클러스터 내 리소스의 변경에 따라 자동으로 구성될 수 있습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003eKong API Gateway\u003c/h1\u003e\n\u003cp\u003e다양한 API 게이트웨이 기술이 있지만, 이 글에서는 무료 오픈 소스 솔루션인 Kong을 선택했습니다. 유료 엔터프라이즈 설치도 가능합니다. 여기에서 Kong에 대한 포괄적인 공식 문서를 찾을 수 있습니다.\u003c/p\u003e\n\u003cp\u003eKong은 쿠버네티스 커뮤니티와 적극적으로 협력하여 클러스터 내에서 게이트웨이에 대한 새로운 표준을 정의하고 있습니다. 이로 인해 게이트웨이 자체와 혼동되어서는 안 되는 새로운 쿠버네티스 리소스 유형인 게이트웨이 API가 만들어졌습니다.\u003c/p\u003e\n\u003cp\u003e이것이 Kong이 어떻게 작동하는지 대략적으로 설명했습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-UsingKongtoaccessKubernetesservicesusingaGatewayresourcewithnocloudprovidedLoadBalancer_3.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e클러스터 외부의 모든 클라이언트로부터 들어오는 트래픽이 Kong에 도달합니다. Kong은 구성 내의 규칙에 따라 요청을 처리하고 클러스터 내외의 적절한 서비스로 요청을 전달합니다.\u003c/p\u003e\n\u003cp\u003eKong은 Kubernetes 리소스 매니페스트에서 정적으로 또는 데이터베이스에서 구성을 가져올 수 있습니다 (DB-less 설치). Kong은 이제 DB-less 설치를 새로운 설치에 사용할 것을 권장하며, 이를 따를 것입니다.\u003c/p\u003e\n\u003cp\u003eKong은 성숙한 플러그인 기능을 갖추고 있습니다. 이를 통해 제3자가 Kong의 플러그인으로 기능 확장을 개발할 수 있습니다. 플러그인은 트래픽 흐름에 위치하여 속도 제한 및 인증과 같은 작업에 도움을 줄 수 있습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e마지막으로 Kong을 관리하기 위해 플러그인, 구성 등을 관리할 수 있도록 Management UI를 제공합니다. Management UI는 Admin API를 통해 Kong과 상호 작용합니다.\u003c/p\u003e\n\u003cp\u003eKong에 대해 상세한 문서를 살펴보면 여기서 다룰 수 있는 내용보다 더 많음을 알 수 있습니다. 그래서 제가 다루는 내용은 기본 사항에만 초점을 맞추겠습니다.\u003c/p\u003e\n\u003ch2\u003eDB-less 설치\u003c/h2\u003e\n\u003cp\u003eDB-less 설치가 어떻게 작동하는지 이해하는 것이 중요하다고 생 생각합니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이 구성에서 Kong은 두 가지 구성요소를 설치합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eKong Ingress Controller (KIC)\u003c/li\u003e\n\u003cli\u003eKong Gateway\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e게이트웨이는 프록시를 통해 모든 사용자 트래픽의 경로 지정을 처리합니다. Kong Ingress Controller (KIC)는 Kubernetes 리소스 정의 (예: HTTPRoute)에서 구성을 가져와서 프록시가 이해하는 규칙으로 변환하고 실시간으로 프록시에 규칙을 업로드합니다. 이러한 방식으로 Kubernetes 구성의 변경 사항이 자동으로 프록시에 적용됩니다.\u003c/p\u003e\n\u003cp\u003eKIC는 내부 Kubernetes API를 사용하여 Kubernetes 클러스터에 대한 정보를 얻습니다. 이 API는 클러스터를 관리하는 데 사용되는 것으로, kubectl을 사용할 때 실제로는 Kubernetes API와 상호 작용합니다. 이 API를 통해 Kong 및 kubectl과 같은 애플리케이션은 클러스터에 대한 정보를 찾거나 변경할 수 있습니다. KIC는 이 API를 통해 백업 데이터베이스가 필요 없이 클러스터 리소스 파일과 Gateway를 동기화할 수 있습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e테스트할 서비스\u003c/h1\u003e\n\u003cp\u003eKong 배포에 들어가기 전에 Kong을 통해 접근할 수 있는 서비스를 가지고 있어야 합니다. 어차피 API Gateway에 API가 없다면 그리 유용하지 않을 것이니까요!\u003c/p\u003e\n\u003cp\u003e가장 간단한 방법은 NGINX를 웹 서버로 배포하고 정적 콘텐츠로 구성하는 것입니다. Kubernetes에서 이 작업을 한 적이 없다면 다른 기사 하나에서 그 방법을 읽어볼 수 있습니다.\u003c/p\u003e\n\u003cp\u003e2개의 서비스를 생성하는 것을 제안합니다:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003e안녕하세요 world 1: 2개의 레플리카\u003c/li\u003e\n\u003cli\u003e안녕하세요 world 2: 1개의 레플리카\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이들은 클러스터 내 파드에서 ClusterIP 서비스를 통해 접근할 수 있어야 합니다. 이러한 서비스를 설정하는 내 기사에서는 브라우저에서 서비스를 확인할 수 있도록 NodePort 서비스를 생성합니다. 이를 수행할 경우 내부 클러스터 IP 및 포트를 사용해야 합니다. 서비스 유형에 대한 자세한 내용은 다른 기사에서 확인할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e두 서비스가 올바르게 실행되고 Hello World HTML을 제공할 수 있는지 확인하세요.\u003c/p\u003e\n\u003cp\u003e내가 여기서 설명하는 예제에서, 내 두 서비스는 다음과 같이 위치해 있습니다:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003ehttp://\u003ccode\u003enode IP 주소\u003c/code\u003e:30082 — 'Hello World 1 !!'라고 응답합니다.\u003c/li\u003e\n\u003cli\u003ehttp://\u003ccode\u003enode IP 주소\u003c/code\u003e:30082 — 'Hello World 2 !!'라고 응답합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e어느 경로도 필요하지 않으며 경로를 추가하면 (예: http://\u003ccode\u003enode IP 주소\u003c/code\u003e:30082/world1) 404 오류가 발생합니다. 이 사실을 인식하지 못하면 나중에 문제가 될 수 있으므로 주의해야 합니다.\u003c/p\u003e\n\u003cp\u003e이제 서비스가 실행 중이므로 Kong을 통해 액세스해 보겠습니다.\u003c/p\u003e\n\u003ch1\u003e쿠버네티스 게이트웨이 자원 생성하기\u003c/h1\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eDB 미사용 모드에서는 Kong API 게이트웨이를 구성할 때 Kubernetes Ingress 또는 HTTPRoute 리소스를 생성합니다. 이러한 리소스를 클러스터에 적용하면 Kong이 프록시 구성 요소 내에서 라우팅 규칙을 정의하는 데 사용됩니다. 이를 통해 들어오는 트래픽이 서비스로 전달됩니다.\u003c/p\u003e\n\u003cp\u003eIngress 리소스는 작동하지만 기능이 제한적입니다. Kubernetes 커뮤니티와 함께 Kong에서 개발한 새 Gateway 리소스를 사용하면 API를 더 정교하게 관리할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e우리는 Kong과 함께 Gateway 리소스를 사용할 것입니다. 이를 위해 먼저 GatewayClass 및 Gateway 리소스를 지원하는 새로운 Custom Resource Definitions (CRD)를 클러스터에 적용해야 합니다. 클러스터에서 kubectl을 실행하는 위치에서 다음 명령을 실행하여 이 작업을 수행할 수 있습니다. 저의 경우에는 제 k8s-master 서버에서 이를 실행합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ekubectl apply -f \u003cspan class=\"hljs-attr\"\u003ehttps\u003c/span\u003e:\u003cspan class=\"hljs-comment\"\u003e//github.com/kubernetes-sigs/gateway-api/releases/download/v1.0.0/standard-install.yaml\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e본 문서에서는 사용하지 않을 실험적 기능 몇 가지를 소개해드리겠습니다만, 참고용으로 여기에 추가해두었습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ekubectl apply -f \u003cspan class=\"hljs-attr\"\u003ehttps\u003c/span\u003e:\u003cspan class=\"hljs-comment\"\u003e//github.com/kubernetes-sigs/gateway-api/releases/download/v1.0.0/experimental-install.yaml\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 Kubernetes를 위해 GatewayClass 및 Gateway 두 리소스를 정의할 수 있습니다. 이들이 무엇을 하는 지에 대해 설명했으니, 이를 다시 반복하지는 않겠습니다. 간결함을 위해 해당 내용은 여기서 생략합니다.\u003c/p\u003e\n\u003ch2\u003eGatewayClass\u003c/h2\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eKong 기술을 클러스터에 소개하는 GatewayClass를 정의할 것입니다. 다음 파일을 생성해주세요:\u003c/p\u003e\n\u003cp\u003ekong-gw-class.yml\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-yaml\"\u003e\u003cspan class=\"hljs-attr\"\u003eapiVersion:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003egateway.networking.k8s.io/v1\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003ekind:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eGatewayClass\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003emetadata:\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003ename:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ekong-class\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003eannotations:\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003ekonghq.com/gatewayclass-unmanaged:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"true\"\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003espec:\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003econtrollerName:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ekonghq.com/kic-gateway-controller\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 파일에 대해 몇 가지 주의할 사항이 있습니다:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003e이것은 클러스터 수준 리소스이기 때문에 네임스페이스가 없습니다.\u003c/li\u003e\n\u003cli\u003e주석은 솔루션별 옵션을 정의하며 Kong의 경우 konghq로 시작합니다.\u003c/li\u003e\n\u003cli\u003ekonghq.com/gatewayclass-unmanaged 주석은 'true'(문자열)로 설정되어 있습니다. 왜냐하면 Kong이 오퍼레이터를 통해 자동으로 설정되는 것이 아니라 수동으로 설정되고 있기 때문입니다.(다른 옵션도 있으니 여기를 참조하세요)\u003c/li\u003e\n\u003cli\u003e인그레스 컨트롤러는 Kong 인그레스 컨트롤러(konghq.com/kic-gateway-controller)이며 contollerName 필드에서 구성됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이제 다음과 같이 클래스를 생성하세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ekubectl apply -f kong-gw-\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eyml\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 이 클래스를 사용하는 게이트웨이를 생성할 수 있습니다. 동일한 GatewayClass를 참조하는 여러 Gateway 인스턴스를 생성할 수 있다는 점을 유의하세요.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003e게이트웨이\u003c/h2\u003e\n\u003cp\u003e수동으로 설치된 Kong 게이트웨이의 경우 (우리가 생성중인 것과 같이), 다음 파일을 만들어야 합니다:\u003c/p\u003e\n\u003cp\u003ekong-gw-gateway.yml\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-yaml\"\u003e\u003cspan class=\"hljs-attr\"\u003eapiVersion:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003egateway.networking.k8s.io/v1\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003ekind:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eGateway\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003emetadata:\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003ename:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ekong-gateway\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003enamespace:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ekong\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003espec:\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003egatewayClassName:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ekong-class\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003elisteners:\u003c/span\u003e\n    \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ename:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eworld-selector\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003ehostname:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eworlds.com\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003eport:\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e80\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003eprotocol:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eHTTP\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003eallowedRoutes:\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003enamespaces:\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003efrom:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eAll\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e파일에서 유의해야 할 몇 가지 사항이 또 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e나중에 참조할 수 있는 이름이 있습니다 (kong-gateway)\u003c/li\u003e\n\u003cli\u003eGatewayClass는 위에서 생성한 GatewayClass의 이름을 의미합니다\u003c/li\u003e\n\u003cli\u003e이 Gateway는 이 API Gateway의 진입점인 하나의 리스너만 정의합니다\u003c/li\u003e\n\u003cli\u003e리스너에는 URL 호환성이 있는 고유한 이름이 지정됩니다\u003c/li\u003e\n\u003cli\u003e리스너는 포트 80에 바인드됩니다\u003c/li\u003e\n\u003cli\u003e호스트명은 일치 필드로 사용되며 옵션입니다\u003c/li\u003e\n\u003cli\u003e이 리스너에 연결할 서비스(allowedRoutes)를 제어할 수 있으며 해당 서비스들은 네임스페이스를 통해 연결됩니다 - 동일한 네임스페이스를 기본으로 사용하여 다른 네임스페이스로 연결하기 위해 모든 네임스페이스로 변경됩니다\u003c/li\u003e\n\u003cli\u003eGateway 사양은 게이트웨이가 HTTP를 통해 단일 포트(80)에서 수신하는 것을 예상합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eGateways는 네임스페이스에 특정하며 API Gateway를 설치하기 전에 생성해야 합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ekubectl create namespace kong\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이제 다음 명령을 사용하여 리소스를 만드세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ekubectl apply -f kong-gw-gateway.\u003cspan class=\"hljs-property\"\u003eyml\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 GatewayClass 및 Gateway 리소스가 정의되었으므로, 애플리케이션 자체를 설치하여 이 두 리소스의 구현을 형성할 수 있습니다.\u003c/p\u003e\n\u003ch1\u003eKong 설치\u003c/h1\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e지금은 Helm 차트를 사용하여 Kong을 설치할 것입니다. 만약 Helm이 없다면, Helm을 설치하는 방법은 여기에서 찾을 수 있습니다.\u003c/p\u003e\n\u003ch2\u003eKong CRDs\u003c/h2\u003e\n\u003cp\u003eKong을 설치하기 전에 Kong Custom Resource Definitions (CRDs)를 설치해야 합니다. 이 작업은 클러스터에서 kubectl을 실행하는 위치에서 다음 명령을 실행하여 수행할 수 있습니다. 제 경우에는 k8s-master 서버에서 이 작업을 수행하고 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ekubectl apply -k \u003cspan class=\"hljs-attr\"\u003ehttps\u003c/span\u003e:\u003cspan class=\"hljs-comment\"\u003e//github.com/Kong/kubernetes-ingress-controller/config/crd\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003eKong Application\u003c/h2\u003e\n\u003cp\u003eKong을 Kubernetes 클러스터에 설치할 때, 두 가지 구성 요소가 설치됩니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eKong 인그레스 컨트롤러 (KIC) — 쿠버네티스 리소스 정의를 Kong 게이트웨이 구성으로 변환합니다.\u003c/li\u003e\n\u003cli\u003eKong 게이트웨이 — Kong 인그레스 컨트롤러 (KIC)에 의해 삽입된 구성을 기반으로 서비스로의 라우팅을 담당합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e먼저, 로컬 헬름에 Kong 저장소를 추가하십시오:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ehelm repo add kong \u003cspan class=\"hljs-attr\"\u003ehttps\u003c/span\u003e:\u003cspan class=\"hljs-comment\"\u003e//charts.konghq.com\u003c/span\u003e\nhelm repo update\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e만약 다음 명령어로 Helm 차트를 검색하면:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ehelm search repo kong\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e두 개의 항목을 찾을 수 있습니다:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e이름           차트 버전  앱 버전  설명\nkong/kong    \u003cspan class=\"hljs-number\"\u003e2.33\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.3\u003c/span\u003e    \u003cspan class=\"hljs-number\"\u003e3.5\u003c/span\u003e       클라우드 네이티브 인그레스 및 \u003cspan class=\"hljs-variable constant_\"\u003eAPI\u003c/span\u003e 관리\nkong/ingress \u003cspan class=\"hljs-number\"\u003e0.10\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.2\u003c/span\u003e    \u003cspan class=\"hljs-number\"\u003e3.4\u003c/span\u003e       콩 인그레스 컨트롤러 및 콩 게이트웨이 배포\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eDB 레스 구성을 사용할 것이므로 kong/ingress를 사용할 것입니다. 설치하기 전에 몇 가지 값을 재정의해야 합니다. 다음 파일을 만들어주세요:\u003c/p\u003e\n\u003cp\u003ekong-values.yml\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e#\u003cspan class=\"hljs-attr\"\u003econtroller\u003c/span\u003e:\n#  \u003cspan class=\"hljs-attr\"\u003eingressController\u003c/span\u003e:\n#    \u003cspan class=\"hljs-attr\"\u003eenv\u003c/span\u003e:\n#      \u003cspan class=\"hljs-attr\"\u003eLOG_LEVEL\u003c/span\u003e: trace\n#      \u003cspan class=\"hljs-attr\"\u003edump_config\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e\n\n\u003cspan class=\"hljs-attr\"\u003egateway\u003c/span\u003e:\n  \u003cspan class=\"hljs-attr\"\u003eadmin\u003c/span\u003e:\n    \u003cspan class=\"hljs-attr\"\u003ehttp\u003c/span\u003e:\n      \u003cspan class=\"hljs-attr\"\u003eenabled\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003eproxy\u003c/span\u003e:\n    \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eNodePort\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003ehttp\u003c/span\u003e:\n      \u003cspan class=\"hljs-attr\"\u003eenabled\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003enodePort\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e32001\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003etls\u003c/span\u003e:\n      \u003cspan class=\"hljs-attr\"\u003eenabled\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e\n#  \u003cspan class=\"hljs-attr\"\u003eingressController\u003c/span\u003e:\n#    \u003cspan class=\"hljs-attr\"\u003eenv\u003c/span\u003e:\n#      \u003cspan class=\"hljs-attr\"\u003eLOG_LEVEL\u003c/span\u003e: trace\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eKIC 및 Kong Gateway를 부모 Helm 차트를 통해 설치하고 있기 때문에 이 두 애플리케이션의 구성은 각각 컨트롤러 및 게이트웨이 레이블 아래에 있습니다. 컨트롤러는 단순히 알림으로 남겨두었습니다.\u003c/p\u003e\n\u003cp\u003e또한, 주석 처리된 여러 줄을 볼 수 있습니다. 이것들은 Pod 로그를 통해 무엇이 발생하는지 디버그하고 싶을 때 유용합니다.\u003c/p\u003e\n\u003cp\u003eBinary Lane은 Kubernetes가 구성할 수 있는 로드 밸런서를 제공하지 않기 때문에 프록시 구성을 재정의하고 있습니다. Kubernetes에게 LoadBalancer 서비스 대신 NodePort 서비스를 설정하도록 지시하고 있습니다. 게이트웨이를 클러스터의 모든 노드에서 사용할 수 있도록 포트 32001에 노출하고 있습니다.\u003c/p\u003e\n\u003cp\u003e이전에 kong 네임스페이스를 생성했으므로 이제 Kong을 설치할 준비가 되었습니다:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ehelm install kong kong/ingress -f kong-values.\u003cspan class=\"hljs-property\"\u003eyml\u003c/span\u003e -n kong\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 설치가 예상대로 작동하는지 확인할 수 있습니다. 준비되는 데 1-2분 정도 걸릴 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ekubectl get all -n kong\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다음과 같은 결과를 얻어야 합니다:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch3\u003eNAME READY STATUS RESTARTS AGE\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003epod/kong-controller-68cddcbcb7-z46lh 1/1 Running 0 45s\u003c/li\u003e\n\u003cli\u003epod/kong-gateway-687c5b78db-5qvgd 1/1 Running 0 45s\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eservice/kong-controller-validation-webhook ClusterIP 10.110.172.40 \u003cnone\u003e 443/TCP 46s\u003c/none\u003e\u003c/li\u003e\n\u003cli\u003eservice/kong-gateway-admin ClusterIP None \u003cnone\u003e 8444/TCP 46s\u003c/none\u003e\u003c/li\u003e\n\u003cli\u003eservice/kong-gateway-manager NodePort 10.100.254.169 \u003cnone\u003e 8002:30698/TCP,8445:30393/TCP 46s\u003c/none\u003e\u003c/li\u003e\n\u003cli\u003eservice/kong-gateway-proxy NodePort 10.96.24.196 \u003cnone\u003e 80:32001/TCP 46s\u003c/none\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNAME READY UP-TO-DATE AVAILABLE AGE\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003edeployment.apps/kong-controller 1/1 1 1 45s\u003c/li\u003e\n\u003cli\u003edeployment.apps/kong-gateway 1/1 1 1 45s\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNAME DESIRED CURRENT READY AGE\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003ereplicaset.apps/kong-controller-68cddcbcb7 1 1 1 45s\u003c/li\u003e\n\u003cli\u003ereplicaset.apps/kong-gateway-687c5b78db 1 1 1 45s\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eManagement UI 서비스가 NodePort를 통해 노출됩니다. 이는 관리 API를 볼 수 있는 것을 기대하고 작동하지 않을 것입니다. DB-less 설치를 하고 있기 때문에, 관리 UI의 유일한 사용은 설정을 확인하는 것뿐입니다.\u003c/p\u003e\n\u003cp\u003e클러스터 내 노드에서 프록시 주소를 curl로 테스트할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ecurl \u003cspan class=\"hljs-attr\"\u003elocalhost\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e32001\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e요청한 표는 Markdown 형식으로 변경해야 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-json\"\u003e\u003cspan class=\"hljs-punctuation\"\u003e{\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003e\"message\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"해당 값으로 일치하는 경로가 없습니다.\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003e\"request_id\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"7fc9db053e3029105581890e81effe12\"\u003c/span\u003e\n\u003cspan class=\"hljs-punctuation\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e요청 ID는 해당 거래에 고유하며 curl 명령을 다시 실행하면 다른 값을 볼 수 있습니다. 이는 Kong에서 추가되어 시스템을 통해 요청을 추적할 수 있게 합니다. 멋지죠?\u003c/p\u003e\n\u003cp\u003e이제 새 API 게이트웨이를 구성하여 이전에 생성한 테스트 서비스로 요청을 라우트할 준비가 되었습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e라우트 추가하기\u003c/h1\u003e\n\u003cp\u003e게이트웨이 리소스에 라우트를 추가하려면 HTTPRoute 리소스를 사용합니다. 다른 수준의 라우팅을 위한 다른 리소스 유형도 있습니다. 이제 worlds.com/world1을 hello-world-1-svc에, worlds.com/world2를 hello-world-2-svc에 연결하기 위해 이러한 리소스 중 하나를 생성할 것입니다.\u003c/p\u003e\n\u003cp\u003e저는 하나의 HTTPRoute 리소스를 설명하겠고, 다른 하나는 여러분에게 만들어 달라고 요청할 것입니다. 리소스 파일을 생성해주세요:\u003c/p\u003e\n\u003cp\u003ehello-world-1-route.yml\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-yaml\"\u003e\u003cspan class=\"hljs-attr\"\u003eapiVersion:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003egateway.networking.k8s.io/v1\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003ekind:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eHTTPRoute\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003emetadata:\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003ename:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eexample-1\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003eannotations:\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003ekonghq.com/strip-path:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"true\"\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003espec:\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003eparentRefs:\u003c/span\u003e\n    \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ename:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ekong-gateway\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003enamespace:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ekong\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003ehostnames:\u003c/span\u003e\n    \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eworlds.com\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003erules:\u003c/span\u003e\n    \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ematches:\u003c/span\u003e\n        \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003epath:\u003c/span\u003e\n            \u003cspan class=\"hljs-attr\"\u003etype:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ePathPrefix\u003c/span\u003e\n            \u003cspan class=\"hljs-attr\"\u003evalue:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e/world1\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003ebackendRefs:\u003c/span\u003e\n        \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ename:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ehello-world-1-svc\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003eport:\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e80\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003ekind:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eService\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 파일에서는 'true'로 설정된 Kong 특정 주석인 konghq.com/strip-path를 추가했습니다. 이는 수신된 일치하는 경로를 요청에서 southbound 서비스로 줄일 것입니다. 다른 줄에는 다음이 포함되어 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e사용할 게이트웨이의 정의(ParentRefs에서)는 이름과 네임스페이스로 참조됩니다.\u003c/li\u003e\n\u003cli\u003e게이트웨이에서 적절한 수신기에 일치시킬 호스트명에 대한 선택적 참조\u003c/li\u003e\n\u003cli\u003e이 경로에 대해 들어오는 요청과 일치시키는 규칙\u003c/li\u003e\n\u003cli\u003e요청을 이 일치에 대해 경로지정할 서비스를 정의하는 backendRefs(서비스의 내부 DNS 이름이름이며 포트는 서비스에 대한 매핑되지 않은 클러스터 IP 포트임을 주의하세요)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이 경로에서 일치는 /world1의 접두사이며, 그 후 서비스로 전달되기 전에 제거됩니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이제 다음 라우트를 만듭니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ekubectl apply -f hello-world-\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e-route.\u003cspan class=\"hljs-property\"\u003eyml\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNodePort 서비스를 사용하여 게이트웨이를 만들었습니다. 이제 서비스를 테스트할 수 있습니다. NodePort 서비스는 클러스터의 모든 노드에서 사용할 수 있습니다. 보통 저는 k8s-master 노드를 사용하지만 다른 노드도 사용할 수 있습니다. 다음 명령어로 테스트할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ecurl -H \u003cspan class=\"hljs-string\"\u003e\"Host: worlds.com\"\u003c/span\u003e \u0026#x3C;k8s-master \u003cspan class=\"hljs-variable constant_\"\u003eIP\u003c/span\u003e 주소\u003e:\u003cspan class=\"hljs-number\"\u003e32001\u003c/span\u003e/world2\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e원하는 요청 라우팅을 위해 Host 헤더로 호스트명을 worlds.com으로 설정했습니다. 테스트 서비스 응답이 돌아오는 것을 확인할 수 있어야 합니다.\u003c/p\u003e\n\u003cp\u003e이제 두 번째 HTTPRoute 리소스를 추가하여 두 번째 서비스의 요청을 관리할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이제 클러스터 노드에서 서비스에 액세스할 수 있으므로 최종 단계 진행할 수 있습니다 - gw 서버 구성.\u003c/p\u003e\n\u003ch1\u003e인그레스 지점 구성\u003c/h1\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e만약 AWS, Azure, 또는 Google Cloud에서 작업 중이었다면, Gateway 서비스를 LoadBalancer로 유지하고 자동으로 인그레스 포인트가 생성되도록 할 수 있었을 텐데 Binary Lane에서 작업 중이므로 직접 만들어야 합니다.\u003c/p\u003e\n\u003cp\u003e제 글을 따라오셨다면 알겠지만, 저희는 클러스터로부터 인터넷으로의 인그레스 포인트로 작용하는 gw 서버가 있다는 것을 알고 계실 것입니다. 이 서버는 간단하게 NGINX를 사용하여 구성되어 있습니다.\u003c/p\u003e\n\u003cp\u003e우리는 이것을 모든 요청을 라운드 로빈 로드 밸런서를 사용하여 클러스터 내 모든 노드로 경로를 설정하도록 구성할 것입니다.\u003c/p\u003e\n\u003cp\u003egw 서버에 로그인하고 root 사용자로 다음 파일을 업데이트하십시오 (``에 자신의 값으로 필드를 교체하는 것을 잊지 마세요):\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e아래는 worlds.conf 파일의 내용입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eupstream k8s_cluster {\n  server \u0026#x3C;k8s-master\u003e:\u003cspan class=\"hljs-number\"\u003e32001\u003c/span\u003e;\n  server \u0026#x3C;k8s-node1\u003e:\u003cspan class=\"hljs-number\"\u003e32001\u003c/span\u003e;\n  server \u0026#x3C;k8s-node2\u003e:\u003cspan class=\"hljs-number\"\u003e32001\u003c/span\u003e;\n}\n\nserver {\n    listen \u003cspan class=\"hljs-number\"\u003e80\u003c/span\u003e;\n    listen [::]:\u003cspan class=\"hljs-number\"\u003e80\u003c/span\u003e;\n\n    server_name worlds.\u003cspan class=\"hljs-property\"\u003ecom\u003c/span\u003e;\n\n    location / {\n        proxy_pass \u003cspan class=\"hljs-attr\"\u003ehttp\u003c/span\u003e:\u003cspan class=\"hljs-comment\"\u003e//k8s_cluster;\u003c/span\u003e\n        include proxy_params;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e일반적으로 프록시 매개변수는 별도의 파일에 설정됩니다:\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e/etc/nginx/proxy_params\u003c/code\u003e\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eproxy_set_header \u003cspan class=\"hljs-title class_\"\u003eHost\u003c/span\u003e $http_host;\nproxy_set_header X-\u003cspan class=\"hljs-title class_\"\u003eReal\u003c/span\u003e-\u003cspan class=\"hljs-variable constant_\"\u003eIP\u003c/span\u003e $remote_addr;\nproxy_set_header X-\u003cspan class=\"hljs-title class_\"\u003eForwarded\u003c/span\u003e-\u003cspan class=\"hljs-title class_\"\u003eFor\u003c/span\u003e $proxy_add_x_forwarded_for;\nproxy_set_header X-\u003cspan class=\"hljs-title class_\"\u003eForwarded\u003c/span\u003e-\u003cspan class=\"hljs-title class_\"\u003eProto\u003c/span\u003e $scheme;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이렇게 하면 Host 헤더 및 기타 세부 정보가 전달되어 라우팅이 효율적으로 작동할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이제 사이트를 활성화하고 구성을 테스트한 다음 NGINX를 재시작하십시오:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eln -s /etc/nginx/sites-available/worlds.\u003cspan class=\"hljs-property\"\u003econf\u003c/span\u003e /etc/nginx/sites-enabled/\nnginx -t\nsystemctl restart nginx\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e다음과 같이 테스트할 수 있습니다 ( ' '필드를 귀하의 값으로 대체하세요):\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ecurl -H \u003cspan class=\"hljs-string\"\u003e\"Host: worlds.com\"\u003c/span\u003e \u0026#x3C;gw 서버 공인 \u003cspan class=\"hljs-variable constant_\"\u003eIP\u003c/span\u003e 주소\u003e/world1\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e서버로부터 응답을 받아야 합니다.\u003c/p\u003e\n\u003cp\u003e축하합니다! 이제 콩(Kong)을 설치하고 서비스에 연결하도록 구성하는 데 성공했습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003eKong 디버깅\u003c/h1\u003e\n\u003cp\u003e만약 Kong에서 문제가 발생하면 디버깅하는 것이 어려울 수 있어요. 제가 Kong 설치 과정에서 발견한 몇 가지 지침을 공유해드릴게요:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eGatewayClass, Gateway, 그리고 controller/gateway 포드에 kubectl describe를 사용해서 결과물을 주의깊게 살펴보세요. 이런 방법을 이용해 해결책을 찾을 때까지 곤란한 상황에 직면한 적이 있어요.\u003c/li\u003e\n\u003cli\u003econtroller와 gateway 로그를 다음과 같이 확인해보세요:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ekubectl logs \u0026#x3C;pod name\u003e -n kong\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003ekong-values.yml 파일을 사용하여 로깅 레벨을 높이세요 (이전에 보여준 라인의 주석을 제거하세요)\u003c/li\u003e\n\u003cli\u003eNodePort 주소를 얻기 위해 kubectl get svc -n kong를 사용하여 관리 UI에 접속하세요 — HTTP 포트를 사용하고 Admin API를 포트 포워딩하세요 (서비스를 외부로 바인딩하기 위해 --address 옵션을 추가하세요):\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ekubectl port--forward \u0026#x3C;게이트웨이 파드 이름\u003e \u003cspan class=\"hljs-number\"\u003e8001\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e8001\u003c/span\u003e --address \u0026#x3C;k8s-마스터 \u003cspan class=\"hljs-variable constant_\"\u003eIP\u003c/span\u003e 주소\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e포트 8001을 포워딩한 이후, Postman와 같은 REST API 도구를 사용하여 Admin UI에 접속하세요\u003c/li\u003e\n\u003cli\u003e접속할 수 있는 디버그 포트가 있습니다:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ekubectl port-forward -n kong \u0026#x3C;컨트롤러 파드 이름\u003e  \u003cspan class=\"hljs-number\"\u003e10256\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e10256\u003c/span\u003e --address \u0026#x3C;k8s-마스터 \u003cspan class=\"hljs-variable constant_\"\u003eIP\u003c/span\u003e 주소\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e요약\u003c/h1\u003e\n\u003cp\u003e이 글은 API Gateway인 Kong을 설치하기 위해 필요한 모든 단계를 함께 수행해야 하기 때문에 길었습니다.\u003c/p\u003e\n\u003cp\u003e이 글에서 우리는:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e네트워크 토폴로지를 검토했습니다.\u003c/li\u003e\n\u003cli\u003e서비스가 서비스에 접근하는 데 도움이 되는 방법을 살펐습니다.\u003c/li\u003e\n\u003cli\u003eKong이 Kubernetes와 어떻게 작동하는지 살펐습니다.\u003c/li\u003e\n\u003cli\u003e사용할 테스트 서비스를 생성했습니다.\u003c/li\u003e\n\u003cli\u003eGatewayClass 및 Gateway 리소스를 설치하고 구성했습니다.\u003c/li\u003e\n\u003cli\u003eKong을 설치하고 구성했습니다.\u003c/li\u003e\n\u003cli\u003e자체 외부 로드 밸런서를 구성했습니다.\u003c/li\u003e\n\u003cli\u003eAPI Gateway 설치 문제를 해결하는 방법을 고려했습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e마침내 저희는 Kong API 게이트웨이를 통해 인터넷에서 저희의 테스트 서비스에 접속할 수 있었습니다.\u003c/p\u003e\n\u003cp\u003e이 기사가 흥미롭게 여겨진다면 박수를 부탁드립니다. 이는 미래에 어떤 기사를 쓸지 판단하는 데 도움이 됩니다. 의견이 있으시면 댓글에 남겨주시기 바랍니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-23-UsingKongtoaccessKubernetesservicesusingaGatewayresourcewithnocloudprovidedLoadBalancer"},"buildId":"YUMR4jSyk_WlOHHc7UfOk","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>