<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Nodejs와 Express 앱에서 역할 기반 접근 제어RBAC 구현하는 방법 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-06-30-ImplementingRoleBasedAccessControlRBACinNodejsandExpressApp" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Nodejs와 Express 앱에서 역할 기반 접근 제어RBAC 구현하는 방법 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="Nodejs와 Express 앱에서 역할 기반 접근 제어RBAC 구현하는 방법 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-30-ImplementingRoleBasedAccessControlRBACinNodejsandExpressApp_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-06-30-ImplementingRoleBasedAccessControlRBACinNodejsandExpressApp" data-gatsby-head="true"/><meta name="twitter:title" content="Nodejs와 Express 앱에서 역할 기반 접근 제어RBAC 구현하는 방법 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-30-ImplementingRoleBasedAccessControlRBACinNodejsandExpressApp_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-30 21:53" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-70e5ce89f3d962ac.js" defer=""></script><script src="/_next/static/GsgRekSb--BvxYwv9FPn6/_buildManifest.js" defer=""></script><script src="/_next/static/GsgRekSb--BvxYwv9FPn6/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Nodejs와 Express 앱에서 역할 기반 접근 제어RBAC 구현하는 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Nodejs와 Express 앱에서 역할 기반 접근 제어RBAC 구현하는 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 30, 2024</span><span class="posts_reading_time__f7YPP">21<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-30-ImplementingRoleBasedAccessControlRBACinNodejsandExpressApp&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>이 기사에서는 단 몇 분 안에 Node.js 및 Express 애플리케이션에 Role Based Access Control (RBAC)을 구현하는 방법을 알려드립니다.</p>
<p><img src="/assets/img/2024-06-30-ImplementingRoleBasedAccessControlRBACinNodejsandExpressApp_0.png" alt="이미지"></p>
<p>응용 프로그램 내에서 특정 기능 및 데이터에 액세스할 수 있는 권한이 있는 사용자만이 액세스할 수 있도록 보장하기 위해 Role-Based Access Control (RBAC)을 구현하는 것이 중요합니다.</p>
<p>이 기사에서는 Permify를 사용하여 Node.js 및 Express 애플리케이션에 RBAC을 구현하는 방법을 안내해드릴 것입니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>Node.js Express 프로젝트 설정하기</h1>
<p>Express.js 프로젝트를 위한 애플리케이션 뼈대를 빠르게 생성하려면 express-generator 도구를 사용할 수 있습니다. 시작하기 위해 다음 단계를 따르세요:</p>
<h2>단계 1. express-generator 설치하기:</h2>
<p>Node.js 버전 8.2.0 이상을 사용 중이라면 npx 명령어를 사용하여 애플리케이션 생성기를 실행할 수 있습니다:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js">npx express-generator
</code></pre>
<p>이전 Node 버전의 경우, 애플리케이션 생성기를 글로벌 npm 패키지로 설치할 수 있어요:</p>
<pre><code class="hljs language-js">npm install -g express-generator
</code></pre>
<h1>단계 2. Express 애플리케이션 생성하기:</h1>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>express-generator을 설치하셨으면 Express 애플리케이션을 생성할 수 있어요. 다음 명령어를 사용하여 옵션을 확인할 수 있어요:</p>
<pre><code class="hljs language-js">express -h
</code></pre>
<p>이렇게 하면 Express 애플리케이션 생성을 위한 가능한 옵션을 확인할 수 있어요.</p>
<p>예를 들어, Pug 뷰 엔진을 사용하여 permify-rbac-app이라는 Express 앱을 생성하려면 다음과 같이 실행할 수 있어요.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js">express --view=pug permify-rbac-app
</code></pre>
<p>이 명령어는 현재 작업 디렉토리에 permify-rbac-app이라는 폴더를 생성하고 Express 애플리케이션에 필요한 파일과 폴더를 함께 만듭니다.</p>
<h1>단계 3. 종속성 설치:</h1>
<p>새로 만든 Express 애플리케이션 디렉토리로 이동하세요:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js">cd permify-rbac-app
</code></pre>
<p>그런 다음 npm을 사용하여 프로젝트 종속성을 설치하세요:</p>
<pre><code class="hljs language-js">npm install express &#x26;&#x26; npm install @permify-node
</code></pre>
<h1>단계 4. Express 애플리케이션 시작하기:</h1>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>MacOS 또는 Linux에서는 다음 명령어로 앱을 시작할 수 있어요:</p>
<pre><code class="hljs language-js"><span class="hljs-variable constant_">DEBUG</span>=permify-rbac-<span class="hljs-attr">app</span>:* npm start
</code></pre>
<h1>단계 5. 애플리케이션에 액세스하기:</h1>
<p>Express 애플리케이션이 실행되면 브라우저에서 <a href="http://localhost:3000/%EC%9D%84" rel="nofollow" target="_blank">http://localhost:3000/을</a> 통해 액세스할 수 있어요.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>디렉토리 구조:</h1>
<p>생성된 Express 애플리케이션은 다음과 같은 디렉토리 구조를 가지게 됩니다:</p>
<pre><code class="hljs language-js">permify-rbac-app/
├── app.<span class="hljs-property">js</span>
├── bin/
│   └── www
├── package.<span class="hljs-property">json</span>
├── public/
│   ├── images/
│   ├── javascripts/
│   └── stylesheets/
│       └── style.<span class="hljs-property">css</span>
├── routes/
│   ├── index.<span class="hljs-property">js</span>
│   └── users.<span class="hljs-property">js</span>
└── views/
    ├── error.<span class="hljs-property">pug</span>
    ├── index.<span class="hljs-property">pug</span>
    └── layout.<span class="hljs-property">pug</span>
</code></pre>
<p>이 구조에는 주요 애플리케이션 파일(app.js), 서버 구성(bin/www), 라우트(routes), 뷰(views), 공용 에셋(public assets), 그리고 프로젝트 종속성이 포함된 package.json 파일이 포함되어 있습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>Express.js 프로젝트를 설정했으니, 이제 Express 애플리케이션에 RBAC를 구현해 보겠습니다.</p>
<h1>Node.js 및 Express에서 RBAC 구현하기</h1>
<p>Node.js 및 Express 애플리케이션에 Role-Based Access Control (RBAC)을 구현하는 것에는 몇 가지 단계가 연루됩니다. 다음은 기본적인 구현 방법입니다:</p>
<h1>단계 1: Permify를 사용하여 RBAC 모델 설계하기</h1>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>Permify는 개방 소스 권한 부여 서비스로, 개발자들이 권한 시스템을 만들 수 있게 합니다. Permify를 이용하면 권한을 모델링하고, 환경에 중앙 권한 서비스를 만들어 애플리케이션 및 서비스에서 액세스 확인을 수행할 수 있습니다.</p>
<p>이를 위해 클라이언트 SDKs를 제공하여, 미들웨어에 추가하여 접근 확인과 같은 권한 요청을 보낼 수 있습니다.</p>
<p>Permify는 역할, 권한 및 관계를 정의하기 위한 강력한 도메인 특화 언어(DSL)를 제공합니다. Permify Playground를 활용하여 RBAC 모델을 실험하고 시각화할 수 있습니다.</p>
<p><img src="/assets/img/2024-06-30-ImplementingRoleBasedAccessControlRBACinNodejsandExpressApp_1.png" alt="이미지"></p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이 게시물에서는 귀하의 조직 내 사용자가 역할에 따라 문서에 액세스할 수 있는 간단한 파일 기반 권한 부여 시스템을 개발할 것입니다.</p>
<p>행정자, 관리자 및 직원과 같은 다양한 역할은 파일을 보기, 편집 또는 삭제하는 데 서로 다른 수준의 액세스 권한을 가질 수 있습니다.</p>
<h2>Permify DSL을 사용한 역할 및 권한 정의</h2>
<p>다음은 RBAC 모델을 위한 Permify DSL 스키마 예시입니다:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js">entity user {} 

entity organization {
    <span class="hljs-comment">// roles </span>
    relation admin @user    
    relation member @user    
    relation manager @user    
    relation agent @user  
    
    <span class="hljs-comment">// organization files access permissions</span>
    permission view_files = admin or manager or (member not agent)
    permission delete_file = admin 
    
    <span class="hljs-comment">// vendor files access permissions</span>
    permission view_vendor_files = admin or manager or agent
    permission delete_vendor_file = agent
}
</code></pre>
<p>Roles and Permissions:</p>
<ul>
<li>Roles: The schema defines roles for the organization entity, including admin, member, manager, and agent. These roles determine the level of access and permissions users have within the organization.</li>
<li>Permissions: Actions such as <code>view_files</code>, <code>edit_files</code>, <code>delete_file</code>, <code>view_vendor_files</code>, <code>edit_vendor_files</code>, and <code>delete_vendor_file</code> define the specific permissions associated with each role. For example, only admins can delete organization files, while managers and members have different levels of access.</li>
</ul>
<p>Resource Types:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>스키마는 조직 파일과 공급 업체 파일을 구별하여 각각의 권한 집합을 가지고 있습니다. 이는 응용 프로그램 내의 다른 유형의 리소스에 대한 접근을 세밀하게 제어할 수 있도록 합니다.</li>
</ul>
<p>이제 RBAC 스키마를 정의했으니 Permify Local Server를 설정하는 단계로 넘어갈 것입니다.</p>
<h1>단계 2: Docker를 사용하여 Permify Local Server 설정하기</h1>
<p>Docker는 컨테이너화된 환경을 제공함으로써 우리의 설정에서 중요한 역할을 합니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이 환경은 모든 권한 쿼리를 처리하는 마이크로서비스인 Permify의 효율적인 작동을 위한 필수 요소입니다.</p>
<p>이제 Docker Container를 사용하여 Permify Server를 설정하는 필요한 단계를 설명하겠습니다:</p>
<h2>Docker Container를 사용하여 Permify Server 실행</h2>
<ul>
<li>터미널 창을 열고 다음 명령을 실행하여 Permify Server Docker 이미지를 가져오고 컨테이너를 시작합니다:</li>
</ul>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>sudo docker run -p 3476:3476 -p 3478:3478 ghcr.io/permify/permify serve</p>
<p>이 명령어는 GitHub Container Registry에서 Permify Server 이미지를 다운로드하고 다음의 기본 설정으로 Permify, 저희의 권한 부여 서비스를 설정합니다:</p>
<ul>
<li>REST API는 3476 포트에서 실행됩니다.</li>
<li>gRPC 서비스는 3478 포트에서 실행됩니다.</li>
<li>권한 데이터는 컴퓨터 메모리에 저장됩니다.</li>
</ul>
<p>다음과 유사한 메시지가 표시됩니다:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>┌────────────────────────────────────────────────────────┐
│                    Permify v0.9.5                      │
│          Fine-grained Authorization Service            │
│                                                        │
│    docs: ............... <a href="https://docs.permify.co" rel="nofollow" target="_blank">https://docs.permify.co</a>       │
│    github: .. <a href="https://github.com/Permify/permify" rel="nofollow" target="_blank">https://github.com/Permify/permify</a>       │
│    blog: ............... <a href="https://permify.co/blog" rel="nofollow" target="_blank">https://permify.co/blog</a>       │
│                                                        │
└────────────────────────────────────────────────────────┘
time=2024-03-22T14:59:09.851Z level=INFO msg="🚀 starting permify service..."
time=2024-03-22T14:59:09.851Z level=ERROR msg="Account ID is not set. Please fill in the Account ID for better support. Get your Account ID from <a href="https://permify.co/account" rel="nofollow" target="_blank">https://permify.co/account</a>"
time=2024-03-22T14:59:09.859Z level=INFO msg="🚀 grpc server successfully started: 3478"
time=2024-03-22T14:59:09.859Z level=INFO msg="🚀 invoker grpc server successfully started: 5000"
time=2024-03-22T14:59:09.867Z level=INFO msg="🚀 http server successfully started: 3476"</p>
<h2>Permify 서버 확인</h2>
<p>컨테이너가 실행 중이면 health check endpoint에 액세스하여 Permify 서버가 정상적으로 작동하는지 확인할 수 있습니다. Postman을 열고 <a href="http://localhost:3476/healthz%EB%A1%9C" rel="nofollow" target="_blank">http://localhost:3476/healthz로</a> GET 요청을 보내세요. Permify 서버가 올바르게 실행 중이면 서비스가 건강한 것을 나타내는 응답을 볼 수 있어요.</p>
<img src="/assets/img/2024-06-30-ImplementingRoleBasedAccessControlRBACinNodejsandExpressApp_2.png">
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>위의 이미지를 보면 Permify 서버가 작동 중이라는 것을 확인할 수 있습니다. 이제 Node.js 및 Express 애플리케이션에 통합하는 작업을 진행할 수 있습니다.</p>
<h1>단계 3: Permify Node.js 클라이언트 초기화</h1>
<p>이 튜토리얼에서는 Permify Node 클라이언트를 사용하여 응용 프로그램의 권한 부여를 제어합니다. Permify Swagger 문서에서 사용 가능한 엔드포인트 목록을 찾을 수 있습니다. 우리는 Permify의 접근 제어 체크를 사용하여 엔드포인트를 안전하게 보호할 것입니다.</p>
<p>이제 클라이언트를 초기화해 봅시다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// create-tenant.js</span>
<span class="hljs-keyword">const</span> permify = <span class="hljs-built_in">require</span>(<span class="hljs-string">"@permify/permify-node"</span>);

<span class="hljs-keyword">const</span> client = <span class="hljs-keyword">new</span> permify.<span class="hljs-property">grpc</span>.<span class="hljs-title function_">newClient</span>({
    <span class="hljs-attr">endpoint</span>: <span class="hljs-string">"localhost:3478"</span>,
})
</code></pre>
<h1>단계 4: 권한 모델 구성</h1>
<p>이제 Permify 서버가 실행 중이므로 권한 모델을 구성해야 합니다. 이후에 테스트 액세스 확인을 수행할 준비가 될 것입니다.</p>
<p>권한 모델을 구성하려면 생성한 스키마를 Permify에게 Permify schema.write 메서드를 사용하여 전송합니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js"><span class="hljs-comment">//create-schema.js</span>

<span class="hljs-keyword">const</span> permify = <span class="hljs-built_in">require</span>(<span class="hljs-string">"@permify/permify-node"</span>);

<span class="hljs-keyword">const</span> client = <span class="hljs-keyword">new</span> permify.<span class="hljs-property">grpc</span>.<span class="hljs-title function_">newClient</span>({
    <span class="hljs-attr">endpoint</span>: <span class="hljs-string">"localhost:3478"</span>,
})

client.<span class="hljs-property">schema</span>.<span class="hljs-title function_">write</span>({
    <span class="hljs-attr">tenantId</span>: <span class="hljs-string">"t1"</span>,
    <span class="hljs-attr">schema</span>: <span class="hljs-string">"entity user {} \n\nentity organization {\n\n    relation admin @user    \n    relation member @user    \n    relation manager @user    \n    relation agent @user  \n\n    action view_files = admin or manager or (member not agent)\n    action edit_files = admin or manager\n    action delete_file = admin\n    action view_vendor_files = admin or manager or agent\n    action edit_vendor_files = admin or agent\n    action delete_vendor_file = agent\n\n} "</span>
}).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">response</span>) =></span> {
    <span class="hljs-comment">// handle response</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response)
})
</code></pre>
<p>위 코드는 Permify 라이브러리를 사용하여 새로운 스키마를 생성합니다.</p>
<p>이 코드는 localhost의 3478 포트에서 실행 중인 Permify 서버에 연결하도록 구축되었으며, write 메서드를 호출하여 t1 테넌트를 위한 스키마를 정의합니다.</p>
<p>이 스키마는 사용자 및 조직과 관련관계 및 작업과 같은 엔티티를 정의합니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이제 이 스크립트를 실행해 볼게요</p>
<pre><code class="hljs language-js">node create-schema.<span class="hljs-property">js</span>
</code></pre>
<p><img src="/assets/img/2024-06-30-ImplementingRoleBasedAccessControlRBACinNodejsandExpressApp_3.png" alt="스크린샷 이미지"></p>
<p>위 스크린샷에서 새로운 스키마가 Permify Node Js Client를 사용하여 성공적으로 구성되었음을 확인할 수 있어요.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>만세! 🥳 Permify 권한 부여 서비스 설정을 성공적으로 마쳤어요. 이제 권한 모델이 설정되었고 사용할 준비가 끝났답니다!</p>
<p>다음 단계에서는 액세스 제어를 위한 미들웨어를 만들 것입니다.</p>
<h1>단계 5: 액세스 제어 미들웨어 생성</h1>
<p>여기서는 Express 미들웨어를 개발해서 경로에 기반한 역할 기반 액세스 제어를 강제하는 방법을 한 예제로 보여줄게요.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>Permify 액세스 확인 엔드포인트를 미들웨어에 구현하여 보호된 리소스에 액세스하기 전에 사용자의 역할과 권한을 확인하는 방법도 배울 것입니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// auth.js</span>

<span class="hljs-comment">// Permify 클라이언트 가져오기</span>
<span class="hljs-keyword">const</span> permify = <span class="hljs-built_in">require</span>(<span class="hljs-string">'@permify/permify-node'</span>);

<span class="hljs-keyword">const</span> client = <span class="hljs-keyword">new</span> permify.<span class="hljs-property">grpc</span>.<span class="hljs-title function_">newClient</span>({
  <span class="hljs-attr">endpoint</span>: <span class="hljs-string">"localhost:3478"</span>,
});

<span class="hljs-comment">// 사용자의 권한을 확인하는 미들웨어 함수</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">checkPermissions</span> = (<span class="hljs-params">permissionType</span>) => {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">async</span> (req, res, next) => {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-comment">// req.params.id가 존재하는지 확인</span>
      <span class="hljs-keyword">if</span> (!req.<span class="hljs-property">params</span>.<span class="hljs-property">id</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'요청 매개변수에서 사용자 ID가 누락되었습니다'</span>);
      }

      <span class="hljs-comment">// 필요에 따라 permissionType을 문자열로 변환</span>
      <span class="hljs-keyword">const</span> permTypeString = <span class="hljs-title class_">String</span>(permissionType);

      <span class="hljs-comment">// Permify 확인 요청을 위한 데이터 준비</span>
      <span class="hljs-keyword">const</span> checkRes = <span class="hljs-keyword">await</span> client.<span class="hljs-property">permission</span>.<span class="hljs-title function_">check</span>({
        <span class="hljs-attr">tenantId</span>: <span class="hljs-string">'t1'</span>,
        <span class="hljs-attr">metadata</span>: {
          <span class="hljs-attr">schemaVersion</span>: <span class="hljs-string">''</span>,
          <span class="hljs-attr">snapToken</span>: <span class="hljs-string">''</span>,
          <span class="hljs-attr">depth</span>: <span class="hljs-number">20</span>,
        },
        <span class="hljs-attr">entity</span>: {
          <span class="hljs-attr">type</span>: <span class="hljs-string">'organization'</span>,
          <span class="hljs-attr">id</span>: <span class="hljs-string">"1"</span>,
        },
        <span class="hljs-attr">permission</span>: permTypeString, <span class="hljs-comment">// 변환된 permissionType 사용</span>
        <span class="hljs-attr">subject</span>: {
          <span class="hljs-attr">type</span>: <span class="hljs-string">'user'</span>,
          <span class="hljs-attr">id</span>: req.<span class="hljs-property">params</span>.<span class="hljs-property">id</span>,
        },
      });

      <span class="hljs-keyword">if</span> (checkRes.<span class="hljs-property">can</span> === <span class="hljs-number">1</span>) {
        <span class="hljs-comment">// 사용자가 권한이 있는 경우</span>
        req.<span class="hljs-property">authorized</span> = <span class="hljs-string">'authorized'</span>;
        <span class="hljs-title function_">next</span>();
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// 사용자가 권한이 없는 경우</span>
        req.<span class="hljs-property">authorized</span> = <span class="hljs-string">'not authorized'</span>;
        <span class="hljs-title function_">next</span>();
      }
    } <span class="hljs-keyword">catch</span> (err) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'권한 확인 중 오류 발생:'</span>, err.<span class="hljs-property">message</span>); <span class="hljs-comment">// 실제 오류 메시지 기록</span>
      res.<span class="hljs-title function_">status</span>(<span class="hljs-number">500</span>).<span class="hljs-title function_">send</span>(err.<span class="hljs-property">message</span>); <span class="hljs-comment">// 디버깅을 위해 실제 오류 메시지를 클라이언트로 보냄</span>
    }
  };
};

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = checkPermissions;
</code></pre>
<p>위 코드는 사용자 권한을 확인하기 위해 Permify 라이브러리를 활용한 checkPermission 미들웨어 함수를 구현하는 것을 목표로 구성되었습니다.</p>
<p>실행시 요청 매개변수에서 사용자 ID를 추출하고, 필요에 따라 권한 유형을 문자열로 변환한 후, Permify의 "permission.check" 메서드를 사용하여 Permify 서버에 권한 확인 요청을 보냅니다. 권한이 부여된 경우 요청 객체에 "authorized"를 추가하며, 그렇지 않은 경우 "not authorized"를 추가합니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>오류는 디버깅을 위해 더 자세히 기록되고 클라이언트에 반환됩니다.</p>
<p>다음으로, 이전에 만든 미들웨어를 Node.js 및 Express 애플리케이션에 통합하여 역할 기반 접근 제어 (RBAC)를 강제하고 적절한 역할 및 권한이 있는 인증된 사용자만 특정 경로에 액세스할 수 있도록 보장할 것입니다.</p>
<h1>단계 6: RBAC로 경로 보호하기</h1>
<p>이제 만든 미들웨어를 사용하여 경로를 안전하게 만들어봅시다. 우리의 애플리케이션에서 다양한 경로를 보호하기 위해 checkPermissions 미들웨어를 적용할 것입니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js"><span class="hljs-comment">// app.js</span>

<span class="hljs-comment">// 필요한 모듈 가져오기</span>
<span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>);
<span class="hljs-keyword">const</span> permify = <span class="hljs-built_in">require</span>(<span class="hljs-string">"@permify/permify-node"</span>);
<span class="hljs-keyword">const</span> authMiddleware = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./auth'</span>); <span class="hljs-comment">// 인증 미들웨어 가져오기</span>

<span class="hljs-comment">// Express 앱 생성</span>
<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();

<span class="hljs-comment">// userInfo를 채우는 사용자 지정 미들웨어 정의</span>
app.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =></span> {
  <span class="hljs-comment">// 사용자 인증 시뮬레이션 및 userInfo 채우기</span>
  req.<span class="hljs-property">userInfo</span> = {
    <span class="hljs-attr">id</span>: req.<span class="hljs-property">params</span>.<span class="hljs-property">id</span> <span class="hljs-comment">// 요청 매개변수에서 id 추출</span>
    <span class="hljs-comment">// 필요한 경우 다른 사용자 정보 추가</span>
  };
  <span class="hljs-title function_">next</span>();
});

<span class="hljs-comment">// 라우트 정의</span>

<span class="hljs-comment">// '/users/:id' 경로에 대한 권한 확인을 적용하려는 경우</span>
app.<span class="hljs-title function_">get</span>(<span class="hljs-string">'/users/viewFiles/:id'</span>, <span class="hljs-title function_">authMiddleware</span>(<span class="hljs-string">'view_files'</span>), <span class="hljs-function">(<span class="hljs-params">req, res</span>) =></span> {
  <span class="hljs-comment">// 미들웨어가 요청을 통과시키면 라우트 로직 처리</span>
  <span class="hljs-keyword">if</span> (req.<span class="hljs-property">authorized</span> === <span class="hljs-string">'authorized'</span>) {
    res.<span class="hljs-title function_">send</span>(<span class="hljs-string">'이 사용자 경로에 액세스할 수 있습니다'</span>);
  } <span class="hljs-keyword">else</span> {
    res.<span class="hljs-title function_">status</span>(<span class="hljs-number">403</span>).<span class="hljs-title function_">send</span>(<span class="hljs-string">'이 사용자 리소스에 액세스할 권한이 없습니다'</span>);
  }
});

<span class="hljs-comment">// '/admin/deleteVendorFiles/:id' 경로에 대한 권한 확인을 적용하려는 경우</span>
app.<span class="hljs-title function_">get</span>(<span class="hljs-string">'/admin/deleteVendorFiles/:id'</span>, <span class="hljs-title function_">authMiddleware</span>(<span class="hljs-string">'delete_vendor_file'</span>), <span class="hljs-function">(<span class="hljs-params">req, res</span>) =></span> {
  <span class="hljs-comment">// 미들웨어가 요청을 통과시키면 라우트 로직 처리</span>
  <span class="hljs-keyword">if</span> (req.<span class="hljs-property">authorized</span> === <span class="hljs-string">'authorized'</span>) {
    res.<span class="hljs-title function_">send</span>(<span class="hljs-string">'이 관리자 경로에 액세스할 수 있습니다'</span>);
  } <span class="hljs-keyword">else</span> {
    res.<span class="hljs-title function_">status</span>(<span class="hljs-number">403</span>).<span class="hljs-title function_">send</span>(<span class="hljs-string">'이 관리자 리소스에 액세스할 권한이 없습니다'</span>);
  }
});

<span class="hljs-comment">// 서버 시작</span>
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PORT</span> = process.<span class="hljs-property">env</span>.<span class="hljs-property">PORT</span> || <span class="hljs-number">3000</span>;
app.<span class="hljs-title function_">listen</span>(<span class="hljs-variable constant_">PORT</span>, <span class="hljs-function">() =></span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`서버가 <span class="hljs-subst">${PORT}</span>포트에서 실행 중입니다`</span>);
});
</code></pre>
<p>이 코드는 특정 라우트가 authMiddleware라는 사용자 지정 미들웨어를 사용하여 보호되는 Express 애플리케이션을 포트 3000에서 설정합니다.</p>
<p>이 authMiddleware라는 미들웨어는 auth.js 파일에서 가져온 Permify와 통합하여 권한 확인을 수행합니다. 아래는 미들웨어에 의해 보호되는 라우트입니다;</p>
<p>authMiddleware에 의해 보호되는 라우트:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>/users/viewFiles/:id 경로: 이 경로는 파일을 볼 권한을 가진 사용자만 접근할 수 있도록 보장합니다.</li>
<li>/admin/viewFiles/:id 경로: 이 경로는 업체 파일을 삭제할 권한을 가진 관리자만 접근할 수 있도록 보장합니다.</li>
</ul>
<p>이러한 경로에 authMiddleware를 적용하여 Permify가 부여한 권한에 따라 접근이 제한됩니다.</p>
<p>구현을 테스트해봅시다!</p>
<h1>RBAC 구현 테스트</h1>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>아래는 Markdown 형식으로 표를 작성하였습니다.</p>













<table><thead><tr><th>사용자ID</th><th>역할</th></tr></thead><tbody><tr><td>alice</td><td>멤버</td></tr></tbody></table>
<p>이 표는 사용자 alice에게 멤버 역할을 부여하기 위한 Permify Nodejs 클라이언트의 data.write 메소드를 사용하는 예시 코드입니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>그 코드를 실행하고 Postman을 사용하여 /users/viewFiles/ API 엔드포인트에 방문해 보세요.</p>
<p><img src="/assets/img/2024-06-30-ImplementingRoleBasedAccessControlRBACinNodejsandExpressApp_5.png" alt="image"></p>
<p>이제 코드를 실행한 후 Alice는 /users/viewFiles/ API 엔드포인트에 성공적으로 액세스할 수 있습니다.</p>
<h1>결론</h1>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>인가(authorization)가 한 번만 설정하는 것이 아니라 계속된 과정이라는 것을 인지하는 것이 중요합니다.</p>
<p>따라서 모델을 정기적으로 검토하고 철저한 테스트를 수행하며 애플리케이션이 발전함에 따라 적응시키는 것이 중요합니다.</p>
<p>이 가이드는 Node.js 애플리케이션에 RBAC(Role-Based Access Control)을 구현하는 데 튼튼한 기초 역할을 합니다.</p>
<p>그러나 개별 요구 사항에 정확히 맞게 RBAC 모델을 맞춤화하는 데 더 심층적으로 파고들고 망설이지 마세요.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>Permify의 기능을 활용하면 권한 관리를 최적화하고 견고하고 안전한 애플리케이션 환경을 육성할 수 있어요.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Nodejs와 Express 앱에서 역할 기반 접근 제어RBAC 구현하는 방법","description":"","date":"2024-06-30 21:53","slug":"2024-06-30-ImplementingRoleBasedAccessControlRBACinNodejsandExpressApp","content":"\n\n이 기사에서는 단 몇 분 안에 Node.js 및 Express 애플리케이션에 Role Based Access Control (RBAC)을 구현하는 방법을 알려드립니다.\n\n![이미지](/assets/img/2024-06-30-ImplementingRoleBasedAccessControlRBACinNodejsandExpressApp_0.png)\n\n응용 프로그램 내에서 특정 기능 및 데이터에 액세스할 수 있는 권한이 있는 사용자만이 액세스할 수 있도록 보장하기 위해 Role-Based Access Control (RBAC)을 구현하는 것이 중요합니다.\n\n이 기사에서는 Permify를 사용하여 Node.js 및 Express 애플리케이션에 RBAC을 구현하는 방법을 안내해드릴 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# Node.js Express 프로젝트 설정하기\n\nExpress.js 프로젝트를 위한 애플리케이션 뼈대를 빠르게 생성하려면 express-generator 도구를 사용할 수 있습니다. 시작하기 위해 다음 단계를 따르세요:\n\n## 단계 1. express-generator 설치하기:\n\nNode.js 버전 8.2.0 이상을 사용 중이라면 npx 명령어를 사용하여 애플리케이션 생성기를 실행할 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nnpx express-generator\n```\n\n이전 Node 버전의 경우, 애플리케이션 생성기를 글로벌 npm 패키지로 설치할 수 있어요:\n\n```js\nnpm install -g express-generator\n```\n\n# 단계 2. Express 애플리케이션 생성하기:\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nexpress-generator을 설치하셨으면 Express 애플리케이션을 생성할 수 있어요. 다음 명령어를 사용하여 옵션을 확인할 수 있어요:\n\n```js\nexpress -h\n```\n\n이렇게 하면 Express 애플리케이션 생성을 위한 가능한 옵션을 확인할 수 있어요.\n\n예를 들어, Pug 뷰 엔진을 사용하여 permify-rbac-app이라는 Express 앱을 생성하려면 다음과 같이 실행할 수 있어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nexpress --view=pug permify-rbac-app\n```\n\n이 명령어는 현재 작업 디렉토리에 permify-rbac-app이라는 폴더를 생성하고 Express 애플리케이션에 필요한 파일과 폴더를 함께 만듭니다.\n\n# 단계 3. 종속성 설치:\n\n새로 만든 Express 애플리케이션 디렉토리로 이동하세요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\ncd permify-rbac-app\n```\n\n그런 다음 npm을 사용하여 프로젝트 종속성을 설치하세요:\n\n```js\nnpm install express \u0026\u0026 npm install @permify-node\n```\n\n# 단계 4. Express 애플리케이션 시작하기:\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nMacOS 또는 Linux에서는 다음 명령어로 앱을 시작할 수 있어요:\n\n```js\nDEBUG=permify-rbac-app:* npm start\n```\n\n# 단계 5. 애플리케이션에 액세스하기:\n\nExpress 애플리케이션이 실행되면 브라우저에서 http://localhost:3000/을 통해 액세스할 수 있어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 디렉토리 구조:\n\n생성된 Express 애플리케이션은 다음과 같은 디렉토리 구조를 가지게 됩니다:\n\n```js\npermify-rbac-app/\n├── app.js\n├── bin/\n│   └── www\n├── package.json\n├── public/\n│   ├── images/\n│   ├── javascripts/\n│   └── stylesheets/\n│       └── style.css\n├── routes/\n│   ├── index.js\n│   └── users.js\n└── views/\n    ├── error.pug\n    ├── index.pug\n    └── layout.pug\n```\n\n이 구조에는 주요 애플리케이션 파일(app.js), 서버 구성(bin/www), 라우트(routes), 뷰(views), 공용 에셋(public assets), 그리고 프로젝트 종속성이 포함된 package.json 파일이 포함되어 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nExpress.js 프로젝트를 설정했으니, 이제 Express 애플리케이션에 RBAC를 구현해 보겠습니다.\n\n# Node.js 및 Express에서 RBAC 구현하기\n\nNode.js 및 Express 애플리케이션에 Role-Based Access Control (RBAC)을 구현하는 것에는 몇 가지 단계가 연루됩니다. 다음은 기본적인 구현 방법입니다:\n\n# 단계 1: Permify를 사용하여 RBAC 모델 설계하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nPermify는 개방 소스 권한 부여 서비스로, 개발자들이 권한 시스템을 만들 수 있게 합니다. Permify를 이용하면 권한을 모델링하고, 환경에 중앙 권한 서비스를 만들어 애플리케이션 및 서비스에서 액세스 확인을 수행할 수 있습니다.\n\n이를 위해 클라이언트 SDKs를 제공하여, 미들웨어에 추가하여 접근 확인과 같은 권한 요청을 보낼 수 있습니다.\n\nPermify는 역할, 권한 및 관계를 정의하기 위한 강력한 도메인 특화 언어(DSL)를 제공합니다. Permify Playground를 활용하여 RBAC 모델을 실험하고 시각화할 수 있습니다.\n\n![이미지](/assets/img/2024-06-30-ImplementingRoleBasedAccessControlRBACinNodejsandExpressApp_1.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 게시물에서는 귀하의 조직 내 사용자가 역할에 따라 문서에 액세스할 수 있는 간단한 파일 기반 권한 부여 시스템을 개발할 것입니다.\n\n행정자, 관리자 및 직원과 같은 다양한 역할은 파일을 보기, 편집 또는 삭제하는 데 서로 다른 수준의 액세스 권한을 가질 수 있습니다.\n\n## Permify DSL을 사용한 역할 및 권한 정의\n\n다음은 RBAC 모델을 위한 Permify DSL 스키마 예시입니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nentity user {} \n\nentity organization {\n    // roles \n    relation admin @user    \n    relation member @user    \n    relation manager @user    \n    relation agent @user  \n    \n    // organization files access permissions\n    permission view_files = admin or manager or (member not agent)\n    permission delete_file = admin \n    \n    // vendor files access permissions\n    permission view_vendor_files = admin or manager or agent\n    permission delete_vendor_file = agent\n}\n```\n\nRoles and Permissions:\n\n- Roles: The schema defines roles for the organization entity, including admin, member, manager, and agent. These roles determine the level of access and permissions users have within the organization.\n- Permissions: Actions such as `view_files`, `edit_files`, `delete_file`, `view_vendor_files`, `edit_vendor_files`, and `delete_vendor_file` define the specific permissions associated with each role. For example, only admins can delete organization files, while managers and members have different levels of access.\n\nResource Types:\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 스키마는 조직 파일과 공급 업체 파일을 구별하여 각각의 권한 집합을 가지고 있습니다. 이는 응용 프로그램 내의 다른 유형의 리소스에 대한 접근을 세밀하게 제어할 수 있도록 합니다.\n\n이제 RBAC 스키마를 정의했으니 Permify Local Server를 설정하는 단계로 넘어갈 것입니다.\n\n# 단계 2: Docker를 사용하여 Permify Local Server 설정하기\n\nDocker는 컨테이너화된 환경을 제공함으로써 우리의 설정에서 중요한 역할을 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 환경은 모든 권한 쿼리를 처리하는 마이크로서비스인 Permify의 효율적인 작동을 위한 필수 요소입니다.\n\n이제 Docker Container를 사용하여 Permify Server를 설정하는 필요한 단계를 설명하겠습니다:\n\n## Docker Container를 사용하여 Permify Server 실행\n\n- 터미널 창을 열고 다음 명령을 실행하여 Permify Server Docker 이미지를 가져오고 컨테이너를 시작합니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\nsudo docker run -p 3476:3476 -p 3478:3478 ghcr.io/permify/permify serve\n\n\n이 명령어는 GitHub Container Registry에서 Permify Server 이미지를 다운로드하고 다음의 기본 설정으로 Permify, 저희의 권한 부여 서비스를 설정합니다:\n\n- REST API는 3476 포트에서 실행됩니다.\n- gRPC 서비스는 3478 포트에서 실행됩니다.\n- 권한 데이터는 컴퓨터 메모리에 저장됩니다.\n\n다음과 유사한 메시지가 표시됩니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n┌────────────────────────────────────────────────────────┐\r\n│                    Permify v0.9.5                      │\r\n│          Fine-grained Authorization Service            │\r\n│                                                        │\r\n│    docs: ............... https://docs.permify.co       │\r\n│    github: .. https://github.com/Permify/permify       │\r\n│    blog: ............... https://permify.co/blog       │\r\n│                                                        │\r\n└────────────────────────────────────────────────────────┘\r\ntime=2024-03-22T14:59:09.851Z level=INFO msg=\"🚀 starting permify service...\"\r\ntime=2024-03-22T14:59:09.851Z level=ERROR msg=\"Account ID is not set. Please fill in the Account ID for better support. Get your Account ID from https://permify.co/account\"\r\ntime=2024-03-22T14:59:09.859Z level=INFO msg=\"🚀 grpc server successfully started: 3478\"\r\ntime=2024-03-22T14:59:09.859Z level=INFO msg=\"🚀 invoker grpc server successfully started: 5000\"\r\ntime=2024-03-22T14:59:09.867Z level=INFO msg=\"🚀 http server successfully started: 3476\"\r\n\n\r\n## Permify 서버 확인\r\n\r\n컨테이너가 실행 중이면 health check endpoint에 액세스하여 Permify 서버가 정상적으로 작동하는지 확인할 수 있습니다. Postman을 열고 http://localhost:3476/healthz로 GET 요청을 보내세요. Permify 서버가 올바르게 실행 중이면 서비스가 건강한 것을 나타내는 응답을 볼 수 있어요.\r\n\r\n\u003cimg src=\"/assets/img/2024-06-30-ImplementingRoleBasedAccessControlRBACinNodejsandExpressApp_2.png\" /\u003e\r\n\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위의 이미지를 보면 Permify 서버가 작동 중이라는 것을 확인할 수 있습니다. 이제 Node.js 및 Express 애플리케이션에 통합하는 작업을 진행할 수 있습니다.\n\n# 단계 3: Permify Node.js 클라이언트 초기화\n\n이 튜토리얼에서는 Permify Node 클라이언트를 사용하여 응용 프로그램의 권한 부여를 제어합니다. Permify Swagger 문서에서 사용 가능한 엔드포인트 목록을 찾을 수 있습니다. 우리는 Permify의 접근 제어 체크를 사용하여 엔드포인트를 안전하게 보호할 것입니다.\n\n이제 클라이언트를 초기화해 봅시다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```javascript\n// create-tenant.js\nconst permify = require(\"@permify/permify-node\");\n\nconst client = new permify.grpc.newClient({\n    endpoint: \"localhost:3478\",\n})\n```\n\n# 단계 4: 권한 모델 구성\n\n이제 Permify 서버가 실행 중이므로 권한 모델을 구성해야 합니다. 이후에 테스트 액세스 확인을 수행할 준비가 될 것입니다.\n\n권한 모델을 구성하려면 생성한 스키마를 Permify에게 Permify schema.write 메서드를 사용하여 전송합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n//create-schema.js\n\nconst permify = require(\"@permify/permify-node\");\n\nconst client = new permify.grpc.newClient({\n    endpoint: \"localhost:3478\",\n})\n\nclient.schema.write({\n    tenantId: \"t1\",\n    schema: \"entity user {} \\n\\nentity organization {\\n\\n    relation admin @user    \\n    relation member @user    \\n    relation manager @user    \\n    relation agent @user  \\n\\n    action view_files = admin or manager or (member not agent)\\n    action edit_files = admin or manager\\n    action delete_file = admin\\n    action view_vendor_files = admin or manager or agent\\n    action edit_vendor_files = admin or agent\\n    action delete_vendor_file = agent\\n\\n} \"\n}).then((response) =\u003e {\n    // handle response\n    console.log(response)\n})\n```\n\n위 코드는 Permify 라이브러리를 사용하여 새로운 스키마를 생성합니다.\n\n이 코드는 localhost의 3478 포트에서 실행 중인 Permify 서버에 연결하도록 구축되었으며, write 메서드를 호출하여 t1 테넌트를 위한 스키마를 정의합니다.\n\n이 스키마는 사용자 및 조직과 관련관계 및 작업과 같은 엔티티를 정의합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 이 스크립트를 실행해 볼게요\n\n```js\nnode create-schema.js\n```\n\n![스크린샷 이미지](/assets/img/2024-06-30-ImplementingRoleBasedAccessControlRBACinNodejsandExpressApp_3.png)\n\n위 스크린샷에서 새로운 스키마가 Permify Node Js Client를 사용하여 성공적으로 구성되었음을 확인할 수 있어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만세! 🥳 Permify 권한 부여 서비스 설정을 성공적으로 마쳤어요. 이제 권한 모델이 설정되었고 사용할 준비가 끝났답니다!\n\n다음 단계에서는 액세스 제어를 위한 미들웨어를 만들 것입니다.\n\n# 단계 5: 액세스 제어 미들웨어 생성\n\n여기서는 Express 미들웨어를 개발해서 경로에 기반한 역할 기반 액세스 제어를 강제하는 방법을 한 예제로 보여줄게요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nPermify 액세스 확인 엔드포인트를 미들웨어에 구현하여 보호된 리소스에 액세스하기 전에 사용자의 역할과 권한을 확인하는 방법도 배울 것입니다.\n\n```js\n// auth.js\n\n// Permify 클라이언트 가져오기\nconst permify = require('@permify/permify-node');\n\nconst client = new permify.grpc.newClient({\n  endpoint: \"localhost:3478\",\n});\n\n// 사용자의 권한을 확인하는 미들웨어 함수\nconst checkPermissions = (permissionType) =\u003e {\n  return async (req, res, next) =\u003e {\n    try {\n      // req.params.id가 존재하는지 확인\n      if (!req.params.id) {\n        throw new Error('요청 매개변수에서 사용자 ID가 누락되었습니다');\n      }\n\n      // 필요에 따라 permissionType을 문자열로 변환\n      const permTypeString = String(permissionType);\n\n      // Permify 확인 요청을 위한 데이터 준비\n      const checkRes = await client.permission.check({\n        tenantId: 't1',\n        metadata: {\n          schemaVersion: '',\n          snapToken: '',\n          depth: 20,\n        },\n        entity: {\n          type: 'organization',\n          id: \"1\",\n        },\n        permission: permTypeString, // 변환된 permissionType 사용\n        subject: {\n          type: 'user',\n          id: req.params.id,\n        },\n      });\n\n      if (checkRes.can === 1) {\n        // 사용자가 권한이 있는 경우\n        req.authorized = 'authorized';\n        next();\n      } else {\n        // 사용자가 권한이 없는 경우\n        req.authorized = 'not authorized';\n        next();\n      }\n    } catch (err) {\n      console.error('권한 확인 중 오류 발생:', err.message); // 실제 오류 메시지 기록\n      res.status(500).send(err.message); // 디버깅을 위해 실제 오류 메시지를 클라이언트로 보냄\n    }\n  };\n};\n\nmodule.exports = checkPermissions;\n```\n\n위 코드는 사용자 권한을 확인하기 위해 Permify 라이브러리를 활용한 checkPermission 미들웨어 함수를 구현하는 것을 목표로 구성되었습니다.\n\n실행시 요청 매개변수에서 사용자 ID를 추출하고, 필요에 따라 권한 유형을 문자열로 변환한 후, Permify의 \"permission.check\" 메서드를 사용하여 Permify 서버에 권한 확인 요청을 보냅니다. 권한이 부여된 경우 요청 객체에 \"authorized\"를 추가하며, 그렇지 않은 경우 \"not authorized\"를 추가합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n오류는 디버깅을 위해 더 자세히 기록되고 클라이언트에 반환됩니다.\n\n다음으로, 이전에 만든 미들웨어를 Node.js 및 Express 애플리케이션에 통합하여 역할 기반 접근 제어 (RBAC)를 강제하고 적절한 역할 및 권한이 있는 인증된 사용자만 특정 경로에 액세스할 수 있도록 보장할 것입니다.\n\n# 단계 6: RBAC로 경로 보호하기\n\n이제 만든 미들웨어를 사용하여 경로를 안전하게 만들어봅시다. 우리의 애플리케이션에서 다양한 경로를 보호하기 위해 checkPermissions 미들웨어를 적용할 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\r\n// app.js\n\n// 필요한 모듈 가져오기\nconst express = require('express');\nconst permify = require(\"@permify/permify-node\");\nconst authMiddleware = require('./auth'); // 인증 미들웨어 가져오기\n\n// Express 앱 생성\nconst app = express();\n\n// userInfo를 채우는 사용자 지정 미들웨어 정의\napp.use((req, res, next) =\u003e {\n  // 사용자 인증 시뮬레이션 및 userInfo 채우기\n  req.userInfo = {\n    id: req.params.id // 요청 매개변수에서 id 추출\n    // 필요한 경우 다른 사용자 정보 추가\n  };\n  next();\n});\n\n// 라우트 정의\n\n// '/users/:id' 경로에 대한 권한 확인을 적용하려는 경우\napp.get('/users/viewFiles/:id', authMiddleware('view_files'), (req, res) =\u003e {\n  // 미들웨어가 요청을 통과시키면 라우트 로직 처리\n  if (req.authorized === 'authorized') {\n    res.send('이 사용자 경로에 액세스할 수 있습니다');\n  } else {\n    res.status(403).send('이 사용자 리소스에 액세스할 권한이 없습니다');\n  }\n});\n\n// '/admin/deleteVendorFiles/:id' 경로에 대한 권한 확인을 적용하려는 경우\napp.get('/admin/deleteVendorFiles/:id', authMiddleware('delete_vendor_file'), (req, res) =\u003e {\n  // 미들웨어가 요청을 통과시키면 라우트 로직 처리\n  if (req.authorized === 'authorized') {\n    res.send('이 관리자 경로에 액세스할 수 있습니다');\n  } else {\n    res.status(403).send('이 관리자 리소스에 액세스할 권한이 없습니다');\n  }\n});\n\n// 서버 시작\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () =\u003e {\n  console.log(`서버가 ${PORT}포트에서 실행 중입니다`);\n});\r\n```\n\n이 코드는 특정 라우트가 authMiddleware라는 사용자 지정 미들웨어를 사용하여 보호되는 Express 애플리케이션을 포트 3000에서 설정합니다.\n\n이 authMiddleware라는 미들웨어는 auth.js 파일에서 가져온 Permify와 통합하여 권한 확인을 수행합니다. 아래는 미들웨어에 의해 보호되는 라우트입니다;\n\nauthMiddleware에 의해 보호되는 라우트:\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- /users/viewFiles/:id 경로: 이 경로는 파일을 볼 권한을 가진 사용자만 접근할 수 있도록 보장합니다.\n- /admin/viewFiles/:id 경로: 이 경로는 업체 파일을 삭제할 권한을 가진 관리자만 접근할 수 있도록 보장합니다.\n\n이러한 경로에 authMiddleware를 적용하여 Permify가 부여한 권한에 따라 접근이 제한됩니다.\n\n구현을 테스트해봅시다!\n\n# RBAC 구현 테스트\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 Markdown 형식으로 표를 작성하였습니다.\n\n\n| 사용자ID | 역할         | \n|--------|--------------|\n| alice  | 멤버         | \n\n\n이 표는 사용자 alice에게 멤버 역할을 부여하기 위한 Permify Nodejs 클라이언트의 data.write 메소드를 사용하는 예시 코드입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그 코드를 실행하고 Postman을 사용하여 /users/viewFiles/ API 엔드포인트에 방문해 보세요.\n\n![image](/assets/img/2024-06-30-ImplementingRoleBasedAccessControlRBACinNodejsandExpressApp_5.png)\n\n이제 코드를 실행한 후 Alice는 /users/viewFiles/ API 엔드포인트에 성공적으로 액세스할 수 있습니다.\n\n# 결론\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n인가(authorization)가 한 번만 설정하는 것이 아니라 계속된 과정이라는 것을 인지하는 것이 중요합니다.\n\n따라서 모델을 정기적으로 검토하고 철저한 테스트를 수행하며 애플리케이션이 발전함에 따라 적응시키는 것이 중요합니다.\n\n이 가이드는 Node.js 애플리케이션에 RBAC(Role-Based Access Control)을 구현하는 데 튼튼한 기초 역할을 합니다.\n\n그러나 개별 요구 사항에 정확히 맞게 RBAC 모델을 맞춤화하는 데 더 심층적으로 파고들고 망설이지 마세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nPermify의 기능을 활용하면 권한 관리를 최적화하고 견고하고 안전한 애플리케이션 환경을 육성할 수 있어요.","ogImage":{"url":"/assets/img/2024-06-30-ImplementingRoleBasedAccessControlRBACinNodejsandExpressApp_0.png"},"coverImage":"/assets/img/2024-06-30-ImplementingRoleBasedAccessControlRBACinNodejsandExpressApp_0.png","tag":["Tech"],"readingTime":21},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e이 기사에서는 단 몇 분 안에 Node.js 및 Express 애플리케이션에 Role Based Access Control (RBAC)을 구현하는 방법을 알려드립니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-30-ImplementingRoleBasedAccessControlRBACinNodejsandExpressApp_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e응용 프로그램 내에서 특정 기능 및 데이터에 액세스할 수 있는 권한이 있는 사용자만이 액세스할 수 있도록 보장하기 위해 Role-Based Access Control (RBAC)을 구현하는 것이 중요합니다.\u003c/p\u003e\n\u003cp\u003e이 기사에서는 Permify를 사용하여 Node.js 및 Express 애플리케이션에 RBAC을 구현하는 방법을 안내해드릴 것입니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003eNode.js Express 프로젝트 설정하기\u003c/h1\u003e\n\u003cp\u003eExpress.js 프로젝트를 위한 애플리케이션 뼈대를 빠르게 생성하려면 express-generator 도구를 사용할 수 있습니다. 시작하기 위해 다음 단계를 따르세요:\u003c/p\u003e\n\u003ch2\u003e단계 1. express-generator 설치하기:\u003c/h2\u003e\n\u003cp\u003eNode.js 버전 8.2.0 이상을 사용 중이라면 npx 명령어를 사용하여 애플리케이션 생성기를 실행할 수 있습니다:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003enpx express-generator\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이전 Node 버전의 경우, 애플리케이션 생성기를 글로벌 npm 패키지로 설치할 수 있어요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003enpm install -g express-generator\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e단계 2. Express 애플리케이션 생성하기:\u003c/h1\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eexpress-generator을 설치하셨으면 Express 애플리케이션을 생성할 수 있어요. 다음 명령어를 사용하여 옵션을 확인할 수 있어요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eexpress -h\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이렇게 하면 Express 애플리케이션 생성을 위한 가능한 옵션을 확인할 수 있어요.\u003c/p\u003e\n\u003cp\u003e예를 들어, Pug 뷰 엔진을 사용하여 permify-rbac-app이라는 Express 앱을 생성하려면 다음과 같이 실행할 수 있어요.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eexpress --view=pug permify-rbac-app\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 명령어는 현재 작업 디렉토리에 permify-rbac-app이라는 폴더를 생성하고 Express 애플리케이션에 필요한 파일과 폴더를 함께 만듭니다.\u003c/p\u003e\n\u003ch1\u003e단계 3. 종속성 설치:\u003c/h1\u003e\n\u003cp\u003e새로 만든 Express 애플리케이션 디렉토리로 이동하세요:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ecd permify-rbac-app\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그런 다음 npm을 사용하여 프로젝트 종속성을 설치하세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003enpm install express \u0026#x26;\u0026#x26; npm install @permify-node\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e단계 4. Express 애플리케이션 시작하기:\u003c/h1\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eMacOS 또는 Linux에서는 다음 명령어로 앱을 시작할 수 있어요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable constant_\"\u003eDEBUG\u003c/span\u003e=permify-rbac-\u003cspan class=\"hljs-attr\"\u003eapp\u003c/span\u003e:* npm start\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e단계 5. 애플리케이션에 액세스하기:\u003c/h1\u003e\n\u003cp\u003eExpress 애플리케이션이 실행되면 브라우저에서 \u003ca href=\"http://localhost:3000/%EC%9D%84\" rel=\"nofollow\" target=\"_blank\"\u003ehttp://localhost:3000/을\u003c/a\u003e 통해 액세스할 수 있어요.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e디렉토리 구조:\u003c/h1\u003e\n\u003cp\u003e생성된 Express 애플리케이션은 다음과 같은 디렉토리 구조를 가지게 됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003epermify-rbac-app/\n├── app.\u003cspan class=\"hljs-property\"\u003ejs\u003c/span\u003e\n├── bin/\n│   └── www\n├── package.\u003cspan class=\"hljs-property\"\u003ejson\u003c/span\u003e\n├── public/\n│   ├── images/\n│   ├── javascripts/\n│   └── stylesheets/\n│       └── style.\u003cspan class=\"hljs-property\"\u003ecss\u003c/span\u003e\n├── routes/\n│   ├── index.\u003cspan class=\"hljs-property\"\u003ejs\u003c/span\u003e\n│   └── users.\u003cspan class=\"hljs-property\"\u003ejs\u003c/span\u003e\n└── views/\n    ├── error.\u003cspan class=\"hljs-property\"\u003epug\u003c/span\u003e\n    ├── index.\u003cspan class=\"hljs-property\"\u003epug\u003c/span\u003e\n    └── layout.\u003cspan class=\"hljs-property\"\u003epug\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 구조에는 주요 애플리케이션 파일(app.js), 서버 구성(bin/www), 라우트(routes), 뷰(views), 공용 에셋(public assets), 그리고 프로젝트 종속성이 포함된 package.json 파일이 포함되어 있습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eExpress.js 프로젝트를 설정했으니, 이제 Express 애플리케이션에 RBAC를 구현해 보겠습니다.\u003c/p\u003e\n\u003ch1\u003eNode.js 및 Express에서 RBAC 구현하기\u003c/h1\u003e\n\u003cp\u003eNode.js 및 Express 애플리케이션에 Role-Based Access Control (RBAC)을 구현하는 것에는 몇 가지 단계가 연루됩니다. 다음은 기본적인 구현 방법입니다:\u003c/p\u003e\n\u003ch1\u003e단계 1: Permify를 사용하여 RBAC 모델 설계하기\u003c/h1\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003ePermify는 개방 소스 권한 부여 서비스로, 개발자들이 권한 시스템을 만들 수 있게 합니다. Permify를 이용하면 권한을 모델링하고, 환경에 중앙 권한 서비스를 만들어 애플리케이션 및 서비스에서 액세스 확인을 수행할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이를 위해 클라이언트 SDKs를 제공하여, 미들웨어에 추가하여 접근 확인과 같은 권한 요청을 보낼 수 있습니다.\u003c/p\u003e\n\u003cp\u003ePermify는 역할, 권한 및 관계를 정의하기 위한 강력한 도메인 특화 언어(DSL)를 제공합니다. Permify Playground를 활용하여 RBAC 모델을 실험하고 시각화할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-30-ImplementingRoleBasedAccessControlRBACinNodejsandExpressApp_1.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이 게시물에서는 귀하의 조직 내 사용자가 역할에 따라 문서에 액세스할 수 있는 간단한 파일 기반 권한 부여 시스템을 개발할 것입니다.\u003c/p\u003e\n\u003cp\u003e행정자, 관리자 및 직원과 같은 다양한 역할은 파일을 보기, 편집 또는 삭제하는 데 서로 다른 수준의 액세스 권한을 가질 수 있습니다.\u003c/p\u003e\n\u003ch2\u003ePermify DSL을 사용한 역할 및 권한 정의\u003c/h2\u003e\n\u003cp\u003e다음은 RBAC 모델을 위한 Permify DSL 스키마 예시입니다:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eentity user {} \n\nentity organization {\n    \u003cspan class=\"hljs-comment\"\u003e// roles \u003c/span\u003e\n    relation admin @user    \n    relation member @user    \n    relation manager @user    \n    relation agent @user  \n    \n    \u003cspan class=\"hljs-comment\"\u003e// organization files access permissions\u003c/span\u003e\n    permission view_files = admin or manager or (member not agent)\n    permission delete_file = admin \n    \n    \u003cspan class=\"hljs-comment\"\u003e// vendor files access permissions\u003c/span\u003e\n    permission view_vendor_files = admin or manager or agent\n    permission delete_vendor_file = agent\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eRoles and Permissions:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eRoles: The schema defines roles for the organization entity, including admin, member, manager, and agent. These roles determine the level of access and permissions users have within the organization.\u003c/li\u003e\n\u003cli\u003ePermissions: Actions such as \u003ccode\u003eview_files\u003c/code\u003e, \u003ccode\u003eedit_files\u003c/code\u003e, \u003ccode\u003edelete_file\u003c/code\u003e, \u003ccode\u003eview_vendor_files\u003c/code\u003e, \u003ccode\u003eedit_vendor_files\u003c/code\u003e, and \u003ccode\u003edelete_vendor_file\u003c/code\u003e define the specific permissions associated with each role. For example, only admins can delete organization files, while managers and members have different levels of access.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eResource Types:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003e스키마는 조직 파일과 공급 업체 파일을 구별하여 각각의 권한 집합을 가지고 있습니다. 이는 응용 프로그램 내의 다른 유형의 리소스에 대한 접근을 세밀하게 제어할 수 있도록 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이제 RBAC 스키마를 정의했으니 Permify Local Server를 설정하는 단계로 넘어갈 것입니다.\u003c/p\u003e\n\u003ch1\u003e단계 2: Docker를 사용하여 Permify Local Server 설정하기\u003c/h1\u003e\n\u003cp\u003eDocker는 컨테이너화된 환경을 제공함으로써 우리의 설정에서 중요한 역할을 합니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이 환경은 모든 권한 쿼리를 처리하는 마이크로서비스인 Permify의 효율적인 작동을 위한 필수 요소입니다.\u003c/p\u003e\n\u003cp\u003e이제 Docker Container를 사용하여 Permify Server를 설정하는 필요한 단계를 설명하겠습니다:\u003c/p\u003e\n\u003ch2\u003eDocker Container를 사용하여 Permify Server 실행\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e터미널 창을 열고 다음 명령을 실행하여 Permify Server Docker 이미지를 가져오고 컨테이너를 시작합니다:\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003esudo docker run -p 3476:3476 -p 3478:3478 ghcr.io/permify/permify serve\u003c/p\u003e\n\u003cp\u003e이 명령어는 GitHub Container Registry에서 Permify Server 이미지를 다운로드하고 다음의 기본 설정으로 Permify, 저희의 권한 부여 서비스를 설정합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eREST API는 3476 포트에서 실행됩니다.\u003c/li\u003e\n\u003cli\u003egRPC 서비스는 3478 포트에서 실행됩니다.\u003c/li\u003e\n\u003cli\u003e권한 데이터는 컴퓨터 메모리에 저장됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e다음과 유사한 메시지가 표시됩니다:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e┌────────────────────────────────────────────────────────┐\r\n│                    Permify v0.9.5                      │\r\n│          Fine-grained Authorization Service            │\r\n│                                                        │\r\n│    docs: ............... \u003ca href=\"https://docs.permify.co\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://docs.permify.co\u003c/a\u003e       │\r\n│    github: .. \u003ca href=\"https://github.com/Permify/permify\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://github.com/Permify/permify\u003c/a\u003e       │\r\n│    blog: ............... \u003ca href=\"https://permify.co/blog\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://permify.co/blog\u003c/a\u003e       │\r\n│                                                        │\r\n└────────────────────────────────────────────────────────┘\r\ntime=2024-03-22T14:59:09.851Z level=INFO msg=\"🚀 starting permify service...\"\r\ntime=2024-03-22T14:59:09.851Z level=ERROR msg=\"Account ID is not set. Please fill in the Account ID for better support. Get your Account ID from \u003ca href=\"https://permify.co/account\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://permify.co/account\u003c/a\u003e\"\r\ntime=2024-03-22T14:59:09.859Z level=INFO msg=\"🚀 grpc server successfully started: 3478\"\r\ntime=2024-03-22T14:59:09.859Z level=INFO msg=\"🚀 invoker grpc server successfully started: 5000\"\r\ntime=2024-03-22T14:59:09.867Z level=INFO msg=\"🚀 http server successfully started: 3476\"\u003c/p\u003e\n\u003ch2\u003ePermify 서버 확인\u003c/h2\u003e\n\u003cp\u003e컨테이너가 실행 중이면 health check endpoint에 액세스하여 Permify 서버가 정상적으로 작동하는지 확인할 수 있습니다. Postman을 열고 \u003ca href=\"http://localhost:3476/healthz%EB%A1%9C\" rel=\"nofollow\" target=\"_blank\"\u003ehttp://localhost:3476/healthz로\u003c/a\u003e GET 요청을 보내세요. Permify 서버가 올바르게 실행 중이면 서비스가 건강한 것을 나타내는 응답을 볼 수 있어요.\u003c/p\u003e\n\u003cimg src=\"/assets/img/2024-06-30-ImplementingRoleBasedAccessControlRBACinNodejsandExpressApp_2.png\"\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e위의 이미지를 보면 Permify 서버가 작동 중이라는 것을 확인할 수 있습니다. 이제 Node.js 및 Express 애플리케이션에 통합하는 작업을 진행할 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e단계 3: Permify Node.js 클라이언트 초기화\u003c/h1\u003e\n\u003cp\u003e이 튜토리얼에서는 Permify Node 클라이언트를 사용하여 응용 프로그램의 권한 부여를 제어합니다. Permify Swagger 문서에서 사용 가능한 엔드포인트 목록을 찾을 수 있습니다. 우리는 Permify의 접근 제어 체크를 사용하여 엔드포인트를 안전하게 보호할 것입니다.\u003c/p\u003e\n\u003cp\u003e이제 클라이언트를 초기화해 봅시다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-javascript\"\u003e\u003cspan class=\"hljs-comment\"\u003e// create-tenant.js\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e permify = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"@permify/permify-node\"\u003c/span\u003e);\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e client = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e permify.\u003cspan class=\"hljs-property\"\u003egrpc\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003enewClient\u003c/span\u003e({\n    \u003cspan class=\"hljs-attr\"\u003eendpoint\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"localhost:3478\"\u003c/span\u003e,\n})\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e단계 4: 권한 모델 구성\u003c/h1\u003e\n\u003cp\u003e이제 Permify 서버가 실행 중이므로 권한 모델을 구성해야 합니다. 이후에 테스트 액세스 확인을 수행할 준비가 될 것입니다.\u003c/p\u003e\n\u003cp\u003e권한 모델을 구성하려면 생성한 스키마를 Permify에게 Permify schema.write 메서드를 사용하여 전송합니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e//create-schema.js\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e permify = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"@permify/permify-node\"\u003c/span\u003e);\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e client = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e permify.\u003cspan class=\"hljs-property\"\u003egrpc\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003enewClient\u003c/span\u003e({\n    \u003cspan class=\"hljs-attr\"\u003eendpoint\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"localhost:3478\"\u003c/span\u003e,\n})\n\nclient.\u003cspan class=\"hljs-property\"\u003eschema\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ewrite\u003c/span\u003e({\n    \u003cspan class=\"hljs-attr\"\u003etenantId\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"t1\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003eschema\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"entity user {} \\n\\nentity organization {\\n\\n    relation admin @user    \\n    relation member @user    \\n    relation manager @user    \\n    relation agent @user  \\n\\n    action view_files = admin or manager or (member not agent)\\n    action edit_files = admin or manager\\n    action delete_file = admin\\n    action view_vendor_files = admin or manager or agent\\n    action edit_vendor_files = admin or agent\\n    action delete_vendor_file = agent\\n\\n} \"\u003c/span\u003e\n}).\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eresponse\u003c/span\u003e) =\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-comment\"\u003e// handle response\u003c/span\u003e\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(response)\n})\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 코드는 Permify 라이브러리를 사용하여 새로운 스키마를 생성합니다.\u003c/p\u003e\n\u003cp\u003e이 코드는 localhost의 3478 포트에서 실행 중인 Permify 서버에 연결하도록 구축되었으며, write 메서드를 호출하여 t1 테넌트를 위한 스키마를 정의합니다.\u003c/p\u003e\n\u003cp\u003e이 스키마는 사용자 및 조직과 관련관계 및 작업과 같은 엔티티를 정의합니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이제 이 스크립트를 실행해 볼게요\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003enode create-schema.\u003cspan class=\"hljs-property\"\u003ejs\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-30-ImplementingRoleBasedAccessControlRBACinNodejsandExpressApp_3.png\" alt=\"스크린샷 이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e위 스크린샷에서 새로운 스키마가 Permify Node Js Client를 사용하여 성공적으로 구성되었음을 확인할 수 있어요.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e만세! 🥳 Permify 권한 부여 서비스 설정을 성공적으로 마쳤어요. 이제 권한 모델이 설정되었고 사용할 준비가 끝났답니다!\u003c/p\u003e\n\u003cp\u003e다음 단계에서는 액세스 제어를 위한 미들웨어를 만들 것입니다.\u003c/p\u003e\n\u003ch1\u003e단계 5: 액세스 제어 미들웨어 생성\u003c/h1\u003e\n\u003cp\u003e여기서는 Express 미들웨어를 개발해서 경로에 기반한 역할 기반 액세스 제어를 강제하는 방법을 한 예제로 보여줄게요.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003ePermify 액세스 확인 엔드포인트를 미들웨어에 구현하여 보호된 리소스에 액세스하기 전에 사용자의 역할과 권한을 확인하는 방법도 배울 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// auth.js\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// Permify 클라이언트 가져오기\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e permify = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'@permify/permify-node'\u003c/span\u003e);\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e client = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e permify.\u003cspan class=\"hljs-property\"\u003egrpc\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003enewClient\u003c/span\u003e({\n  \u003cspan class=\"hljs-attr\"\u003eendpoint\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"localhost:3478\"\u003c/span\u003e,\n});\n\n\u003cspan class=\"hljs-comment\"\u003e// 사용자의 권한을 확인하는 미들웨어 함수\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003echeckPermissions\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003epermissionType\u003c/span\u003e) =\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e (req, res, next) =\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e {\n      \u003cspan class=\"hljs-comment\"\u003e// req.params.id가 존재하는지 확인\u003c/span\u003e\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!req.\u003cspan class=\"hljs-property\"\u003eparams\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eid\u003c/span\u003e) {\n        \u003cspan class=\"hljs-keyword\"\u003ethrow\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eError\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'요청 매개변수에서 사용자 ID가 누락되었습니다'\u003c/span\u003e);\n      }\n\n      \u003cspan class=\"hljs-comment\"\u003e// 필요에 따라 permissionType을 문자열로 변환\u003c/span\u003e\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e permTypeString = \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e(permissionType);\n\n      \u003cspan class=\"hljs-comment\"\u003e// Permify 확인 요청을 위한 데이터 준비\u003c/span\u003e\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e checkRes = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e client.\u003cspan class=\"hljs-property\"\u003epermission\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003echeck\u003c/span\u003e({\n        \u003cspan class=\"hljs-attr\"\u003etenantId\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e't1'\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003emetadata\u003c/span\u003e: {\n          \u003cspan class=\"hljs-attr\"\u003eschemaVersion\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e''\u003c/span\u003e,\n          \u003cspan class=\"hljs-attr\"\u003esnapToken\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e''\u003c/span\u003e,\n          \u003cspan class=\"hljs-attr\"\u003edepth\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e20\u003c/span\u003e,\n        },\n        \u003cspan class=\"hljs-attr\"\u003eentity\u003c/span\u003e: {\n          \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'organization'\u003c/span\u003e,\n          \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"1\"\u003c/span\u003e,\n        },\n        \u003cspan class=\"hljs-attr\"\u003epermission\u003c/span\u003e: permTypeString, \u003cspan class=\"hljs-comment\"\u003e// 변환된 permissionType 사용\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003esubject\u003c/span\u003e: {\n          \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'user'\u003c/span\u003e,\n          \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: req.\u003cspan class=\"hljs-property\"\u003eparams\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eid\u003c/span\u003e,\n        },\n      });\n\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (checkRes.\u003cspan class=\"hljs-property\"\u003ecan\u003c/span\u003e === \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e) {\n        \u003cspan class=\"hljs-comment\"\u003e// 사용자가 권한이 있는 경우\u003c/span\u003e\n        req.\u003cspan class=\"hljs-property\"\u003eauthorized\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e'authorized'\u003c/span\u003e;\n        \u003cspan class=\"hljs-title function_\"\u003enext\u003c/span\u003e();\n      } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n        \u003cspan class=\"hljs-comment\"\u003e// 사용자가 권한이 없는 경우\u003c/span\u003e\n        req.\u003cspan class=\"hljs-property\"\u003eauthorized\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e'not authorized'\u003c/span\u003e;\n        \u003cspan class=\"hljs-title function_\"\u003enext\u003c/span\u003e();\n      }\n    } \u003cspan class=\"hljs-keyword\"\u003ecatch\u003c/span\u003e (err) {\n      \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eerror\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'권한 확인 중 오류 발생:'\u003c/span\u003e, err.\u003cspan class=\"hljs-property\"\u003emessage\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// 실제 오류 메시지 기록\u003c/span\u003e\n      res.\u003cspan class=\"hljs-title function_\"\u003estatus\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e500\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003esend\u003c/span\u003e(err.\u003cspan class=\"hljs-property\"\u003emessage\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// 디버깅을 위해 실제 오류 메시지를 클라이언트로 보냄\u003c/span\u003e\n    }\n  };\n};\n\n\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eexports\u003c/span\u003e = checkPermissions;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 코드는 사용자 권한을 확인하기 위해 Permify 라이브러리를 활용한 checkPermission 미들웨어 함수를 구현하는 것을 목표로 구성되었습니다.\u003c/p\u003e\n\u003cp\u003e실행시 요청 매개변수에서 사용자 ID를 추출하고, 필요에 따라 권한 유형을 문자열로 변환한 후, Permify의 \"permission.check\" 메서드를 사용하여 Permify 서버에 권한 확인 요청을 보냅니다. 권한이 부여된 경우 요청 객체에 \"authorized\"를 추가하며, 그렇지 않은 경우 \"not authorized\"를 추가합니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e오류는 디버깅을 위해 더 자세히 기록되고 클라이언트에 반환됩니다.\u003c/p\u003e\n\u003cp\u003e다음으로, 이전에 만든 미들웨어를 Node.js 및 Express 애플리케이션에 통합하여 역할 기반 접근 제어 (RBAC)를 강제하고 적절한 역할 및 권한이 있는 인증된 사용자만 특정 경로에 액세스할 수 있도록 보장할 것입니다.\u003c/p\u003e\n\u003ch1\u003e단계 6: RBAC로 경로 보호하기\u003c/h1\u003e\n\u003cp\u003e이제 만든 미들웨어를 사용하여 경로를 안전하게 만들어봅시다. 우리의 애플리케이션에서 다양한 경로를 보호하기 위해 checkPermissions 미들웨어를 적용할 것입니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// app.js\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// 필요한 모듈 가져오기\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e express = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'express'\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e permify = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"@permify/permify-node\"\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e authMiddleware = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'./auth'\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// 인증 미들웨어 가져오기\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// Express 앱 생성\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e app = \u003cspan class=\"hljs-title function_\"\u003eexpress\u003c/span\u003e();\n\n\u003cspan class=\"hljs-comment\"\u003e// userInfo를 채우는 사용자 지정 미들웨어 정의\u003c/span\u003e\napp.\u003cspan class=\"hljs-title function_\"\u003euse\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003ereq, res, next\u003c/span\u003e) =\u003e\u003c/span\u003e {\n  \u003cspan class=\"hljs-comment\"\u003e// 사용자 인증 시뮬레이션 및 userInfo 채우기\u003c/span\u003e\n  req.\u003cspan class=\"hljs-property\"\u003euserInfo\u003c/span\u003e = {\n    \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: req.\u003cspan class=\"hljs-property\"\u003eparams\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eid\u003c/span\u003e \u003cspan class=\"hljs-comment\"\u003e// 요청 매개변수에서 id 추출\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e// 필요한 경우 다른 사용자 정보 추가\u003c/span\u003e\n  };\n  \u003cspan class=\"hljs-title function_\"\u003enext\u003c/span\u003e();\n});\n\n\u003cspan class=\"hljs-comment\"\u003e// 라우트 정의\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// '/users/:id' 경로에 대한 권한 확인을 적용하려는 경우\u003c/span\u003e\napp.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'/users/viewFiles/:id'\u003c/span\u003e, \u003cspan class=\"hljs-title function_\"\u003eauthMiddleware\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'view_files'\u003c/span\u003e), \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003ereq, res\u003c/span\u003e) =\u003e\u003c/span\u003e {\n  \u003cspan class=\"hljs-comment\"\u003e// 미들웨어가 요청을 통과시키면 라우트 로직 처리\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (req.\u003cspan class=\"hljs-property\"\u003eauthorized\u003c/span\u003e === \u003cspan class=\"hljs-string\"\u003e'authorized'\u003c/span\u003e) {\n    res.\u003cspan class=\"hljs-title function_\"\u003esend\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'이 사용자 경로에 액세스할 수 있습니다'\u003c/span\u003e);\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    res.\u003cspan class=\"hljs-title function_\"\u003estatus\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e403\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003esend\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'이 사용자 리소스에 액세스할 권한이 없습니다'\u003c/span\u003e);\n  }\n});\n\n\u003cspan class=\"hljs-comment\"\u003e// '/admin/deleteVendorFiles/:id' 경로에 대한 권한 확인을 적용하려는 경우\u003c/span\u003e\napp.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'/admin/deleteVendorFiles/:id'\u003c/span\u003e, \u003cspan class=\"hljs-title function_\"\u003eauthMiddleware\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'delete_vendor_file'\u003c/span\u003e), \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003ereq, res\u003c/span\u003e) =\u003e\u003c/span\u003e {\n  \u003cspan class=\"hljs-comment\"\u003e// 미들웨어가 요청을 통과시키면 라우트 로직 처리\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (req.\u003cspan class=\"hljs-property\"\u003eauthorized\u003c/span\u003e === \u003cspan class=\"hljs-string\"\u003e'authorized'\u003c/span\u003e) {\n    res.\u003cspan class=\"hljs-title function_\"\u003esend\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'이 관리자 경로에 액세스할 수 있습니다'\u003c/span\u003e);\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    res.\u003cspan class=\"hljs-title function_\"\u003estatus\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e403\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003esend\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'이 관리자 리소스에 액세스할 권한이 없습니다'\u003c/span\u003e);\n  }\n});\n\n\u003cspan class=\"hljs-comment\"\u003e// 서버 시작\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003ePORT\u003c/span\u003e = process.\u003cspan class=\"hljs-property\"\u003eenv\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ePORT\u003c/span\u003e || \u003cspan class=\"hljs-number\"\u003e3000\u003c/span\u003e;\napp.\u003cspan class=\"hljs-title function_\"\u003elisten\u003c/span\u003e(\u003cspan class=\"hljs-variable constant_\"\u003ePORT\u003c/span\u003e, \u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`서버가 \u003cspan class=\"hljs-subst\"\u003e${PORT}\u003c/span\u003e포트에서 실행 중입니다`\u003c/span\u003e);\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 코드는 특정 라우트가 authMiddleware라는 사용자 지정 미들웨어를 사용하여 보호되는 Express 애플리케이션을 포트 3000에서 설정합니다.\u003c/p\u003e\n\u003cp\u003e이 authMiddleware라는 미들웨어는 auth.js 파일에서 가져온 Permify와 통합하여 권한 확인을 수행합니다. 아래는 미들웨어에 의해 보호되는 라우트입니다;\u003c/p\u003e\n\u003cp\u003eauthMiddleware에 의해 보호되는 라우트:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003e/users/viewFiles/:id 경로: 이 경로는 파일을 볼 권한을 가진 사용자만 접근할 수 있도록 보장합니다.\u003c/li\u003e\n\u003cli\u003e/admin/viewFiles/:id 경로: 이 경로는 업체 파일을 삭제할 권한을 가진 관리자만 접근할 수 있도록 보장합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이러한 경로에 authMiddleware를 적용하여 Permify가 부여한 권한에 따라 접근이 제한됩니다.\u003c/p\u003e\n\u003cp\u003e구현을 테스트해봅시다!\u003c/p\u003e\n\u003ch1\u003eRBAC 구현 테스트\u003c/h1\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e아래는 Markdown 형식으로 표를 작성하였습니다.\u003c/p\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e사용자ID\u003c/th\u003e\u003cth\u003e역할\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003ealice\u003c/td\u003e\u003ctd\u003e멤버\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e이 표는 사용자 alice에게 멤버 역할을 부여하기 위한 Permify Nodejs 클라이언트의 data.write 메소드를 사용하는 예시 코드입니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e그 코드를 실행하고 Postman을 사용하여 /users/viewFiles/ API 엔드포인트에 방문해 보세요.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-30-ImplementingRoleBasedAccessControlRBACinNodejsandExpressApp_5.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e이제 코드를 실행한 후 Alice는 /users/viewFiles/ API 엔드포인트에 성공적으로 액세스할 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e인가(authorization)가 한 번만 설정하는 것이 아니라 계속된 과정이라는 것을 인지하는 것이 중요합니다.\u003c/p\u003e\n\u003cp\u003e따라서 모델을 정기적으로 검토하고 철저한 테스트를 수행하며 애플리케이션이 발전함에 따라 적응시키는 것이 중요합니다.\u003c/p\u003e\n\u003cp\u003e이 가이드는 Node.js 애플리케이션에 RBAC(Role-Based Access Control)을 구현하는 데 튼튼한 기초 역할을 합니다.\u003c/p\u003e\n\u003cp\u003e그러나 개별 요구 사항에 정확히 맞게 RBAC 모델을 맞춤화하는 데 더 심층적으로 파고들고 망설이지 마세요.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003ePermify의 기능을 활용하면 권한 관리를 최적화하고 견고하고 안전한 애플리케이션 환경을 육성할 수 있어요.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-30-ImplementingRoleBasedAccessControlRBACinNodejsandExpressApp"},"buildId":"GsgRekSb--BvxYwv9FPn6","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>