<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>간단한 안드로이드 Compose Flow 라이프사이클 처리 및 카운터로 배우기 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-05-18-LearnSimpleAndroidComposeFlowLifecycleHandlingWithCounter" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="간단한 안드로이드 Compose Flow 라이프사이클 처리 및 카운터로 배우기 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="간단한 안드로이드 Compose Flow 라이프사이클 처리 및 카운터로 배우기 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-18-LearnSimpleAndroidComposeFlowLifecycleHandlingWithCounter_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-05-18-LearnSimpleAndroidComposeFlowLifecycleHandlingWithCounter" data-gatsby-head="true"/><meta name="twitter:title" content="간단한 안드로이드 Compose Flow 라이프사이클 처리 및 카운터로 배우기 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-18-LearnSimpleAndroidComposeFlowLifecycleHandlingWithCounter_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-18 15:24" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/cd012fc8787133d0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cd012fc8787133d0.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/551-3069cf29fe274aab.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-561ae49ab5aab7f5.js" defer=""></script><script src="/_next/static/0asLlD6on3tm8cIfzBaxd/_buildManifest.js" defer=""></script><script src="/_next/static/0asLlD6on3tm8cIfzBaxd/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">간단한 안드로이드 Compose Flow 라이프사이클 처리 및 카운터로 배우기</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="간단한 안드로이드 Compose Flow 라이프사이클 처리 및 카운터로 배우기" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 18, 2024</span><span class="posts_reading_time__f7YPP">7<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-18-LearnSimpleAndroidComposeFlowLifecycleHandlingWithCounter&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><h2>안드로이드 개발 배우기</h2>
<p><img src="/assets/img/2024-05-18-LearnSimpleAndroidComposeFlowLifecycleHandlingWithCounter_0.png" alt="이미지"/></p>
<p>가끔 안드로이드 라이프사이클을 이해하려고 머리를 싸매면서, 정말 중요한 시나리오는 무엇인지 궁금해 할 때가 있습니다. 이해하지 못하면 적절하게 활용을 놓치게 될 수 있습니다.</p>
<p>여기, 매우 간단한 디자인인 카운터를 고안해 보았습니다. 이를 통해 각종 간단한 라이프사이클 시나리오를 살펴볼 수 있습니다. 도움이 되길 바랍니다.</p>
<div class="content-ad"></div>
<h1>간단한 흐름</h1>
<p>간단한 카운터를 만들기 위해, 제 ViewModel에 아래와 같은 흐름이 있습니다. 매 초마다 1씩 증가하는 흐름입니다.</p>
<pre><code class="hljs language-js">val counter = flow {
    <span class="hljs-keyword">var</span> value = <span class="hljs-number">0</span>
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
       <span class="hljs-title function_">emit</span>(value++)
       <span class="hljs-title function_">delay</span>(<span class="hljs-number">1000</span>)
    }
}
</code></pre>
<p>MainActivity에서 트리거된 Composable 함수에서는, 상태 변수로 수집하고 표시합니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> stateVariable = viewModel.counter.collectAsState(<span class="hljs-number">0</span>)
Text(<span class="hljs-string">&quot;<span class="hljs-subst">${stateVariable.value}</span>&quot;</span>)
</code></pre>
<p>작동은 됩니다. 하지만 한 가지 문제가 있어요.</p>
<h2>화면을 회전하면 초기화돼요!</h2>
<p>화면을 회전할 때마다(세로에서 가로로 변경할 때) 숫자가 다시 시작돼요!</p>
<div class="content-ad"></div>
<img src="/assets/img/2024-05-18-LearnSimpleAndroidComposeFlowLifecycleHandlingWithCounter_1.png"/>
<p>처음에는 카운터가 재설정되어 깜짝 놀랐습니다. ViewModel이 화면 회전(구성 변경)을 통해 유지되는 것에 대해 생각해 보았더니, 화면이 회전될 때마다 MainActivity가 파괴되고 카운터가 다시 수집된다는 것을 깨달았습니다.</p>
<pre><code class="hljs language-js">val stateVariable = viewModel.<span class="hljs-property">counter</span>.<span class="hljs-title function_">collectAsState</span>(<span class="hljs-number">0</span>)
</code></pre>
<div class="content-ad"></div>
<p>각 컬렉션은 새로운 플로우 이벤트를 시작합니다. 따라서 화면을 회전할 때 카운터가 재설정됩니다.</p>
<p><img src="/assets/img/2024-05-18-LearnSimpleAndroidComposeFlowLifecycleHandlingWithCounter_2.png" alt="이미지"/></p>
<h1>외부 변수를 플로우로 변경</h1>
<p>이 문제를 해결하기 위해 제가 고안한 해결책은 다음과 같습니다. 카운터 값을 플로우에 저장하는 대신 외부에서 정의하겠습니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">var</span> value = <span class="hljs-number">0</span>
<span class="hljs-keyword">val</span> counter = flow {
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
       emit(value++)
       delay(<span class="hljs-number">1000</span>)
    }
}
</code></pre>
<p>제 MainActivity에서 트리거된 Composable Function에서는 상태 변수로만 수집하고 표시합니다.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> stateVariable = viewModel.counter.collectAsState(<span class="hljs-number">0</span>)
Text(<span class="hljs-string">&quot;<span class="hljs-subst">${stateVariable.value}</span>&quot;</span>)
</code></pre>
<img src="/assets/img/2024-05-18-LearnSimpleAndroidComposeFlowLifecycleHandlingWithCounter_3.png"/>
<div class="content-ad"></div>
<p>이 방법은 작동합니다. 그리고 꾸준히 계속 작동합니다.</p>
<p><img src="/assets/img/2024-05-18-LearnSimpleAndroidComposeFlowLifecycleHandlingWithCounter_4.png" alt="이미지"/></p>
<h2>백그라운드에서 멈추지 않음</h2>
<p>하지만 한 가지 문제가 있습니다. 앱을 백그라운드로 이동시키면 작동이 멈추지 않고 계속 실행됩니다 (활동이 종료되지 않고 계속 활성 상태로 남아 있음).</p>
<div class="content-ad"></div>
<img src="/assets/img/2024-05-18-LearnSimpleAndroidComposeFlowLifecycleHandlingWithCounter_5.png"/>
<p>이게 이상적이지 않아요. 우리가 백그라운드로 가면(즉, 액티비티가 onPause되면), 일시 중지되기를 원했고, 다시 포어그라운드로 돌아오면 계속되기를 원했어요.</p>
<p>그 이유는 collectAsState는 라이프사이클 변경을 인식하지 못하기 때문에, 흐름을 멈추거나 일시 중지시키지 못하기 때문이에요.</p>
<h2>CollectAsStateWithLifecycle가 구조안으로 와서 구원을 줍니다</h2>
<div class="content-ad"></div>
<p>좋은 소식이 있어요. 구글에서 Manuel Vivo가 공유한 collectAsStateWithLifecycle을 소개했어요.</p>
<p>우리는 이렇게만 하면 돼요:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> stateVariable = viewModel.counter.collectAsStateWithLifecycle(<span class="hljs-number">0</span>)
Text(<span class="hljs-string">&quot;<span class="hljs-subst">${stateVariable.value}</span>&quot;</span>)
</code></pre>
<img src="/assets/img/2024-05-18-LearnSimpleAndroidComposeFlowLifecycleHandlingWithCounter_6.png"/>
<div class="content-ad"></div>
<p>잠시 일시 중단해볼게요</p>
<p><img src="/assets/img/2024-05-18-LearnSimpleAndroidComposeFlowLifecycleHandlingWithCounter_7.png" alt="image"/></p>
<h2>시스템에 의해 종료될 때 상태를 저장하지 않음</h2>
<p>ViewModel은 회전되더라도 앱이 계속 실행되도록 할 수 있어 좋습니다. 그러나 시스템에 의해 앱이 종료될 경우 계속 실행되지 않을 수 있습니다. 기기 메모리가 부족한 경우에는 OS가 백그라운드에서 실행 중인 앱을 종료할 수 있습니다.</p>
<div class="content-ad"></div>
<p>이렇게 되면 우리 카운터에 무슨 일이 벌어집니다.</p>
<p><img src="/assets/img/2024-05-18-LearnSimpleAndroidComposeFlowLifecycleHandlingWithCounter_8.png" alt="LearnSimpleAndroidComposeFlowLifecycleHandlingWithCounter_8"/></p>
<p>우리는 savedStateHandle을 사용하여 외부 값 저장 및 복원할 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> value = savedStateHandle[<span class="hljs-variable constant_">KEY</span>] ?: <span class="hljs-number">0</span>
val counter = flow {
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
       <span class="hljs-title function_">emit</span>(value++)
       savedStateHandle[<span class="hljs-variable constant_">KEY</span>] = value
       <span class="hljs-title function_">delay</span>(<span class="hljs-number">1000</span>)
    }
}
</code></pre>
<div class="content-ad"></div>
<h1>StateFlow With Lifecycle Aware</h1>
<p>하지만 flow를 사용하고 있기 때문에, savedStateHandle에서 stateFlow를 직접 얻을 수 있다면 stateFlow를 사용해보는 것은 어떨까요?</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> stateFlow = savedStateHandle.getStateFlow(KEY, <span class="hljs-number">0</span>)
</code></pre>
<p>flow와는 달리, stateFlow는 hot flow입니다. 이는 stateFlow 자체에서 값이 발행되지 않고, 외부에서 값을 받는다는 것을 의미합니다.</p>
<div class="content-ad"></div>
<p>그래서, ViewModel에서 아래의 간단한 코드를 가지고 있어요.</p>
<pre><code class="hljs language-js">val stateFlowCounter = savedStateHandle.<span class="hljs-title function_">getStateFlow</span>(<span class="hljs-variable constant_">KEY</span>, <span class="hljs-number">0</span>)
init {
    viewModelScope.<span class="hljs-property">launch</span> {
        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
           <span class="hljs-title function_">delay</span>(<span class="hljs-number">1000</span>)
           savedStateHandle[<span class="hljs-variable constant_">KEY</span>] = stateFlowCounter.<span class="hljs-property">value</span> + <span class="hljs-number">1</span>
        }
    }
}
</code></pre>
<p>그리고 Activity에서는 아래와 같이 수집도 해요.</p>
<pre><code class="hljs language-js">val stateVariable 
    = viewModel.<span class="hljs-property">stateFlowCounter</span>.<span class="hljs-title function_">collectAsStateWithLifecycle</span>()
<span class="hljs-title class_">Text</span>(<span class="hljs-string">&quot;${stateVariable.value}&quot;</span>)
</code></pre>
<div class="content-ad"></div>
<p>이 방법은 상태Flow 변수를 저장하고 복원하므로 좋습니다.</p>
<p><img src="/assets/img/2024-05-18-LearnSimpleAndroidComposeFlowLifecycleHandlingWithCounter_9.png" alt="이미지"/></p>
<p>그러나 이 방식에는 문제가 있습니다. collectAsStateWithLifecycle를 사용하더라도 수집 부분이 MainActivity에 있습니다.</p>
<p>stateFlow는 핫 플로우이며, 발행 프로세스도 ViewModel에 있기 때문에 발행 프로세스는 라이프사이클을 인식하지 못한 채 계속 실행됩니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js">init {
    viewModelScope.<span class="hljs-property">launch</span> {
        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
           <span class="hljs-title function_">delay</span>(<span class="hljs-number">1000</span>)
           savedStateHandle[<span class="hljs-variable constant_">KEY</span>] = stateFlowCounter.<span class="hljs-property">value</span> + <span class="hljs-number">1</span>
        }
    }
}
</code></pre>
<p>따라서 결과는 아래와 같습니다.</p>
<img src="/assets/img/2024-05-18-LearnSimpleAndroidComposeFlowLifecycleHandlingWithCounter_10.png"/>
<p>회전 문제와 저장 및 복원 문제를 해결했습니다. 그러나 백그라운드에서 일시 중지되지 않는 문제가 되돌아왔습니다.</p>
<div class="content-ad"></div>
<p>아래 이미지를 참고해 주세요.</p>
<h2>WhileSubcribed가 도와 주었어요</h2>
<p>답을 찾기 위해 검색한 후, 답을 찾도록 도와준
Manuel Vivo님에게 감사드립니다.</p>
<div class="content-ad"></div>
<p>간략하게 말하자면, stateFlow에 대해 WhileSubscribed를 사용하여 구독자(수집 중인)가 있는 경우에만 stateFlow가 활성화되도록 해야합니다.</p>
<p>이를 위해 아래와 같이 stateIn을 추가해야 합니다.</p>
<pre><code class="hljs language-js">val stateFlowCounter = savedStateHandle
    .<span class="hljs-title function_">getStateFlow</span>(<span class="hljs-variable constant_">KEY</span>, <span class="hljs-number">0</span>)
    .<span class="hljs-title function_">stateIn</span>(
        viewModelScope,
        <span class="hljs-title class_">SharingStarted</span>.<span class="hljs-title class_">WhileSubscribed</span>(<span class="hljs-number">0</span>),
        <span class="hljs-number">0</span>
    )
init {
    viewModelScope.<span class="hljs-property">launch</span> {
        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
           <span class="hljs-title function_">delay</span>(<span class="hljs-number">1000</span>)
           savedStateHandle[<span class="hljs-variable constant_">KEY</span>] = stateFlowCounter.<span class="hljs-property">value</span> + <span class="hljs-number">1</span>
        }
    }
}
</code></pre>
<p>이렇게 해야합니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> stateVariable
    = viewModel.stateFlowCounter.collectAsStateWithLifecycle()
Text(<span class="hljs-string">&quot;<span class="hljs-subst">${stateVariable.value}</span>&quot;</span>)
</code></pre>
<p>아래에 최신 코드가 설명되어 있습니다.</p>
<img src="/assets/img/2024-05-18-LearnSimpleAndroidComposeFlowLifecycleHandlingWithCounter_12.png"/>
<p>원하는 동작을 모두 갖게 될 것입니다.</p>
<div class="content-ad"></div>
<p><img src="/assets/img/2024-05-18-LearnSimpleAndroidComposeFlowLifecycleHandlingWithCounter_13.png" alt="이미지1"/></p>
<p><img src="/assets/img/2024-05-18-LearnSimpleAndroidComposeFlowLifecycleHandlingWithCounter_14.png" alt="이미지2"/></p>
<p><img src="/assets/img/2024-05-18-LearnSimpleAndroidComposeFlowLifecycleHandlingWithCounter_15.png" alt="이미지3"/></p>
<h1>TL;DR</h1>
<div class="content-ad"></div>
<p>만약 Google에서 권장하는 Lifecycle Aware한 Flow를 원한다면,</p>
<ul>
<li>보통 플로우나 핫 플로우와 관계없이 collectAsStateWithLifecycle을 사용하세요.</li>
<li>모든 핫 플로우 (예: StateFlow)에는 WhileSubscribed를 적용하세요.</li>
</ul>
<p>이 내용이 유용하고 상태로 수집된 Flow 및 해당 라이프사이클 처리를 설명했기를 바랍니다.</p>
<p>여기에서 코드와 디자인을 가져와 직접 실험해 볼 수 있습니다.</p></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"간단한 안드로이드 Compose Flow 라이프사이클 처리 및 카운터로 배우기","description":"","date":"2024-05-18 15:24","slug":"2024-05-18-LearnSimpleAndroidComposeFlowLifecycleHandlingWithCounter","content":"\n\n## 안드로이드 개발 배우기\n\n![이미지](/assets/img/2024-05-18-LearnSimpleAndroidComposeFlowLifecycleHandlingWithCounter_0.png)\n\n가끔 안드로이드 라이프사이클을 이해하려고 머리를 싸매면서, 정말 중요한 시나리오는 무엇인지 궁금해 할 때가 있습니다. 이해하지 못하면 적절하게 활용을 놓치게 될 수 있습니다.\n\n여기, 매우 간단한 디자인인 카운터를 고안해 보았습니다. 이를 통해 각종 간단한 라이프사이클 시나리오를 살펴볼 수 있습니다. 도움이 되길 바랍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 간단한 흐름\n\n간단한 카운터를 만들기 위해, 제 ViewModel에 아래와 같은 흐름이 있습니다. 매 초마다 1씩 증가하는 흐름입니다.\n\n```js\nval counter = flow {\n    var value = 0\n    while (true) {\n       emit(value++)\n       delay(1000)\n    }\n}\n```\n\nMainActivity에서 트리거된 Composable 함수에서는, 상태 변수로 수집하고 표시합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```kotlin\nval stateVariable = viewModel.counter.collectAsState(0)\nText(\"${stateVariable.value}\")\n```\n\n작동은 됩니다. 하지만 한 가지 문제가 있어요.\n\n## 화면을 회전하면 초기화돼요!\n\n화면을 회전할 때마다(세로에서 가로로 변경할 때) 숫자가 다시 시작돼요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-05-18-LearnSimpleAndroidComposeFlowLifecycleHandlingWithCounter_1.png\" /\u003e\n\n처음에는 카운터가 재설정되어 깜짝 놀랐습니다. ViewModel이 화면 회전(구성 변경)을 통해 유지되는 것에 대해 생각해 보았더니, 화면이 회전될 때마다 MainActivity가 파괴되고 카운터가 다시 수집된다는 것을 깨달았습니다.\n\n```js\nval stateVariable = viewModel.counter.collectAsState(0)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n각 컬렉션은 새로운 플로우 이벤트를 시작합니다. 따라서 화면을 회전할 때 카운터가 재설정됩니다.\n\n![이미지](/assets/img/2024-05-18-LearnSimpleAndroidComposeFlowLifecycleHandlingWithCounter_2.png)\n\n# 외부 변수를 플로우로 변경\n\n이 문제를 해결하기 위해 제가 고안한 해결책은 다음과 같습니다. 카운터 값을 플로우에 저장하는 대신 외부에서 정의하겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```kotlin\nvar value = 0\nval counter = flow {\n    while (true) {\n       emit(value++)\n       delay(1000)\n    }\n}\n```\n\n제 MainActivity에서 트리거된 Composable Function에서는 상태 변수로만 수집하고 표시합니다.\n\n```kotlin\nval stateVariable = viewModel.counter.collectAsState(0)\nText(\"${stateVariable.value}\")\n```\n\n\u003cimg src=\"/assets/img/2024-05-18-LearnSimpleAndroidComposeFlowLifecycleHandlingWithCounter_3.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 방법은 작동합니다. 그리고 꾸준히 계속 작동합니다.\n\n![이미지](/assets/img/2024-05-18-LearnSimpleAndroidComposeFlowLifecycleHandlingWithCounter_4.png)\n\n## 백그라운드에서 멈추지 않음\n\n하지만 한 가지 문제가 있습니다. 앱을 백그라운드로 이동시키면 작동이 멈추지 않고 계속 실행됩니다 (활동이 종료되지 않고 계속 활성 상태로 남아 있음).\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-05-18-LearnSimpleAndroidComposeFlowLifecycleHandlingWithCounter_5.png\" /\u003e\n\n이게 이상적이지 않아요. 우리가 백그라운드로 가면(즉, 액티비티가 onPause되면), 일시 중지되기를 원했고, 다시 포어그라운드로 돌아오면 계속되기를 원했어요.\n\n그 이유는 collectAsState는 라이프사이클 변경을 인식하지 못하기 때문에, 흐름을 멈추거나 일시 중지시키지 못하기 때문이에요.\n\n## CollectAsStateWithLifecycle가 구조안으로 와서 구원을 줍니다\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n좋은 소식이 있어요. 구글에서 Manuel Vivo가 공유한 collectAsStateWithLifecycle을 소개했어요.\n\n우리는 이렇게만 하면 돼요:\n\n```kotlin\nval stateVariable = viewModel.counter.collectAsStateWithLifecycle(0)\nText(\"${stateVariable.value}\")\n```\n\n\u003cimg src=\"/assets/img/2024-05-18-LearnSimpleAndroidComposeFlowLifecycleHandlingWithCounter_6.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n잠시 일시 중단해볼게요\n\n![image](/assets/img/2024-05-18-LearnSimpleAndroidComposeFlowLifecycleHandlingWithCounter_7.png)\n\n## 시스템에 의해 종료될 때 상태를 저장하지 않음\n\nViewModel은 회전되더라도 앱이 계속 실행되도록 할 수 있어 좋습니다. 그러나 시스템에 의해 앱이 종료될 경우 계속 실행되지 않을 수 있습니다. 기기 메모리가 부족한 경우에는 OS가 백그라운드에서 실행 중인 앱을 종료할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이렇게 되면 우리 카운터에 무슨 일이 벌어집니다.\n\n![LearnSimpleAndroidComposeFlowLifecycleHandlingWithCounter_8](/assets/img/2024-05-18-LearnSimpleAndroidComposeFlowLifecycleHandlingWithCounter_8.png)\n\n우리는 savedStateHandle을 사용하여 외부 값 저장 및 복원할 수 있습니다.\n\n```js\nvar value = savedStateHandle[KEY] ?: 0\nval counter = flow {\n    while (true) {\n       emit(value++)\n       savedStateHandle[KEY] = value\n       delay(1000)\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# StateFlow With Lifecycle Aware\n\n하지만 flow를 사용하고 있기 때문에, savedStateHandle에서 stateFlow를 직접 얻을 수 있다면 stateFlow를 사용해보는 것은 어떨까요?\n\n```kotlin\nval stateFlow = savedStateHandle.getStateFlow(KEY, 0)\n```\n\nflow와는 달리, stateFlow는 hot flow입니다. 이는 stateFlow 자체에서 값이 발행되지 않고, 외부에서 값을 받는다는 것을 의미합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그래서, ViewModel에서 아래의 간단한 코드를 가지고 있어요.\n\n```js\nval stateFlowCounter = savedStateHandle.getStateFlow(KEY, 0)\ninit {\n    viewModelScope.launch {\n        while (true) {\n           delay(1000)\n           savedStateHandle[KEY] = stateFlowCounter.value + 1\n        }\n    }\n}\n```\n\n그리고 Activity에서는 아래와 같이 수집도 해요.\n\n```js\nval stateVariable \n    = viewModel.stateFlowCounter.collectAsStateWithLifecycle()\nText(\"${stateVariable.value}\")\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 방법은 상태Flow 변수를 저장하고 복원하므로 좋습니다.\n\n![이미지](/assets/img/2024-05-18-LearnSimpleAndroidComposeFlowLifecycleHandlingWithCounter_9.png)\n\n그러나 이 방식에는 문제가 있습니다. collectAsStateWithLifecycle를 사용하더라도 수집 부분이 MainActivity에 있습니다.\n\nstateFlow는 핫 플로우이며, 발행 프로세스도 ViewModel에 있기 때문에 발행 프로세스는 라이프사이클을 인식하지 못한 채 계속 실행됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\ninit {\n    viewModelScope.launch {\n        while (true) {\n           delay(1000)\n           savedStateHandle[KEY] = stateFlowCounter.value + 1\n        }\n    }\n}\n```\n\n따라서 결과는 아래와 같습니다.\n\n\u003cimg src=\"/assets/img/2024-05-18-LearnSimpleAndroidComposeFlowLifecycleHandlingWithCounter_10.png\" /\u003e\n\n회전 문제와 저장 및 복원 문제를 해결했습니다. 그러나 백그라운드에서 일시 중지되지 않는 문제가 되돌아왔습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래 이미지를 참고해 주세요.\n\n## WhileSubcribed가 도와 주었어요\n\n답을 찾기 위해 검색한 후, 답을 찾도록 도와준\nManuel Vivo님에게 감사드립니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n간략하게 말하자면, stateFlow에 대해 WhileSubscribed를 사용하여 구독자(수집 중인)가 있는 경우에만 stateFlow가 활성화되도록 해야합니다.\n\n이를 위해 아래와 같이 stateIn을 추가해야 합니다.\n\n```js\nval stateFlowCounter = savedStateHandle\n    .getStateFlow(KEY, 0)\n    .stateIn(\n        viewModelScope,\n        SharingStarted.WhileSubscribed(0),\n        0\n    )\ninit {\n    viewModelScope.launch {\n        while (true) {\n           delay(1000)\n           savedStateHandle[KEY] = stateFlowCounter.value + 1\n        }\n    }\n}\n```\n\n이렇게 해야합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```kotlin\nval stateVariable\n    = viewModel.stateFlowCounter.collectAsStateWithLifecycle()\nText(\"${stateVariable.value}\")\n```\n\n아래에 최신 코드가 설명되어 있습니다.\n\n\u003cimg src=\"/assets/img/2024-05-18-LearnSimpleAndroidComposeFlowLifecycleHandlingWithCounter_12.png\" /\u003e\n\n원하는 동작을 모두 갖게 될 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지1](/assets/img/2024-05-18-LearnSimpleAndroidComposeFlowLifecycleHandlingWithCounter_13.png)\n\n![이미지2](/assets/img/2024-05-18-LearnSimpleAndroidComposeFlowLifecycleHandlingWithCounter_14.png)\n\n![이미지3](/assets/img/2024-05-18-LearnSimpleAndroidComposeFlowLifecycleHandlingWithCounter_15.png)\n\n# TL;DR\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 Google에서 권장하는 Lifecycle Aware한 Flow를 원한다면,\n\n- 보통 플로우나 핫 플로우와 관계없이 collectAsStateWithLifecycle을 사용하세요.\n- 모든 핫 플로우 (예: StateFlow)에는 WhileSubscribed를 적용하세요.\n\n이 내용이 유용하고 상태로 수집된 Flow 및 해당 라이프사이클 처리를 설명했기를 바랍니다.\n\n여기에서 코드와 디자인을 가져와 직접 실험해 볼 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-18-LearnSimpleAndroidComposeFlowLifecycleHandlingWithCounter_0.png"},"coverImage":"/assets/img/2024-05-18-LearnSimpleAndroidComposeFlowLifecycleHandlingWithCounter_0.png","tag":["Tech"],"readingTime":7},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h2: \"h2\",\n    p: \"p\",\n    img: \"img\",\n    h1: \"h1\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\",\n    ul: \"ul\",\n    li: \"li\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h2, {\n      children: \"안드로이드 개발 배우기\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-18-LearnSimpleAndroidComposeFlowLifecycleHandlingWithCounter_0.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"가끔 안드로이드 라이프사이클을 이해하려고 머리를 싸매면서, 정말 중요한 시나리오는 무엇인지 궁금해 할 때가 있습니다. 이해하지 못하면 적절하게 활용을 놓치게 될 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"여기, 매우 간단한 디자인인 카운터를 고안해 보았습니다. 이를 통해 각종 간단한 라이프사이클 시나리오를 살펴볼 수 있습니다. 도움이 되길 바랍니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"간단한 흐름\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"간단한 카운터를 만들기 위해, 제 ViewModel에 아래와 같은 흐름이 있습니다. 매 초마다 1씩 증가하는 흐름입니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"val counter = flow {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"var\"\n        }), \" value = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"while\"\n        }), \" (\", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"true\"\n        }), \") {\\n       \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"emit\"\n        }), \"(value++)\\n       \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"delay\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1000\"\n        }), \")\\n    }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"MainActivity에서 트리거된 Composable 함수에서는, 상태 변수로 수집하고 표시합니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" stateVariable = viewModel.counter.collectAsState(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \")\\nText(\", _jsxs(_components.span, {\n          className: \"hljs-string\",\n          children: [\"\\\"\", _jsx(_components.span, {\n            className: \"hljs-subst\",\n            children: \"${stateVariable.value}\"\n          }), \"\\\"\"]\n        }), \")\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"작동은 됩니다. 하지만 한 가지 문제가 있어요.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"화면을 회전하면 초기화돼요!\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"화면을 회전할 때마다(세로에서 가로로 변경할 때) 숫자가 다시 시작돼요!\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/assets/img/2024-05-18-LearnSimpleAndroidComposeFlowLifecycleHandlingWithCounter_1.png\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"처음에는 카운터가 재설정되어 깜짝 놀랐습니다. ViewModel이 화면 회전(구성 변경)을 통해 유지되는 것에 대해 생각해 보았더니, 화면이 회전될 때마다 MainActivity가 파괴되고 카운터가 다시 수집된다는 것을 깨달았습니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"val stateVariable = viewModel.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"counter\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"collectAsState\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \")\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"각 컬렉션은 새로운 플로우 이벤트를 시작합니다. 따라서 화면을 회전할 때 카운터가 재설정됩니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-18-LearnSimpleAndroidComposeFlowLifecycleHandlingWithCounter_2.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"외부 변수를 플로우로 변경\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 문제를 해결하기 위해 제가 고안한 해결책은 다음과 같습니다. 카운터 값을 플로우에 저장하는 대신 외부에서 정의하겠습니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"var\"\n        }), \" value = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" counter = flow {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"while\"\n        }), \" (\", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"true\"\n        }), \") {\\n       emit(value++)\\n       delay(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1000\"\n        }), \")\\n    }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"제 MainActivity에서 트리거된 Composable Function에서는 상태 변수로만 수집하고 표시합니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" stateVariable = viewModel.counter.collectAsState(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \")\\nText(\", _jsxs(_components.span, {\n          className: \"hljs-string\",\n          children: [\"\\\"\", _jsx(_components.span, {\n            className: \"hljs-subst\",\n            children: \"${stateVariable.value}\"\n          }), \"\\\"\"]\n        }), \")\\n\"]\n      })\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/assets/img/2024-05-18-LearnSimpleAndroidComposeFlowLifecycleHandlingWithCounter_3.png\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 방법은 작동합니다. 그리고 꾸준히 계속 작동합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-18-LearnSimpleAndroidComposeFlowLifecycleHandlingWithCounter_4.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"백그라운드에서 멈추지 않음\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"하지만 한 가지 문제가 있습니다. 앱을 백그라운드로 이동시키면 작동이 멈추지 않고 계속 실행됩니다 (활동이 종료되지 않고 계속 활성 상태로 남아 있음).\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/assets/img/2024-05-18-LearnSimpleAndroidComposeFlowLifecycleHandlingWithCounter_5.png\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이게 이상적이지 않아요. 우리가 백그라운드로 가면(즉, 액티비티가 onPause되면), 일시 중지되기를 원했고, 다시 포어그라운드로 돌아오면 계속되기를 원했어요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그 이유는 collectAsState는 라이프사이클 변경을 인식하지 못하기 때문에, 흐름을 멈추거나 일시 중지시키지 못하기 때문이에요.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"CollectAsStateWithLifecycle가 구조안으로 와서 구원을 줍니다\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"좋은 소식이 있어요. 구글에서 Manuel Vivo가 공유한 collectAsStateWithLifecycle을 소개했어요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우리는 이렇게만 하면 돼요:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" stateVariable = viewModel.counter.collectAsStateWithLifecycle(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \")\\nText(\", _jsxs(_components.span, {\n          className: \"hljs-string\",\n          children: [\"\\\"\", _jsx(_components.span, {\n            className: \"hljs-subst\",\n            children: \"${stateVariable.value}\"\n          }), \"\\\"\"]\n        }), \")\\n\"]\n      })\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/assets/img/2024-05-18-LearnSimpleAndroidComposeFlowLifecycleHandlingWithCounter_6.png\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"잠시 일시 중단해볼게요\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-18-LearnSimpleAndroidComposeFlowLifecycleHandlingWithCounter_7.png\",\n        alt: \"image\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"시스템에 의해 종료될 때 상태를 저장하지 않음\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"ViewModel은 회전되더라도 앱이 계속 실행되도록 할 수 있어 좋습니다. 그러나 시스템에 의해 앱이 종료될 경우 계속 실행되지 않을 수 있습니다. 기기 메모리가 부족한 경우에는 OS가 백그라운드에서 실행 중인 앱을 종료할 수 있습니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이렇게 되면 우리 카운터에 무슨 일이 벌어집니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-18-LearnSimpleAndroidComposeFlowLifecycleHandlingWithCounter_8.png\",\n        alt: \"LearnSimpleAndroidComposeFlowLifecycleHandlingWithCounter_8\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우리는 savedStateHandle을 사용하여 외부 값 저장 및 복원할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"var\"\n        }), \" value = savedStateHandle[\", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"KEY\"\n        }), \"] ?: \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"\\nval counter = flow {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"while\"\n        }), \" (\", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"true\"\n        }), \") {\\n       \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"emit\"\n        }), \"(value++)\\n       savedStateHandle[\", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"KEY\"\n        }), \"] = value\\n       \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"delay\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1000\"\n        }), \")\\n    }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"StateFlow With Lifecycle Aware\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"하지만 flow를 사용하고 있기 때문에, savedStateHandle에서 stateFlow를 직접 얻을 수 있다면 stateFlow를 사용해보는 것은 어떨까요?\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" stateFlow = savedStateHandle.getStateFlow(KEY, \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \")\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"flow와는 달리, stateFlow는 hot flow입니다. 이는 stateFlow 자체에서 값이 발행되지 않고, 외부에서 값을 받는다는 것을 의미합니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그래서, ViewModel에서 아래의 간단한 코드를 가지고 있어요.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"val stateFlowCounter = savedStateHandle.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"getStateFlow\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"KEY\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \")\\ninit {\\n    viewModelScope.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"launch\"\n        }), \" {\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"while\"\n        }), \" (\", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"true\"\n        }), \") {\\n           \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"delay\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1000\"\n        }), \")\\n           savedStateHandle[\", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"KEY\"\n        }), \"] = stateFlowCounter.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"value\"\n        }), \" + \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"\\n        }\\n    }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그리고 Activity에서는 아래와 같이 수집도 해요.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"val stateVariable \\n    = viewModel.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"stateFlowCounter\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"collectAsStateWithLifecycle\"\n        }), \"()\\n\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Text\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"${stateVariable.value}\\\"\"\n        }), \")\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 방법은 상태Flow 변수를 저장하고 복원하므로 좋습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-18-LearnSimpleAndroidComposeFlowLifecycleHandlingWithCounter_9.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그러나 이 방식에는 문제가 있습니다. collectAsStateWithLifecycle를 사용하더라도 수집 부분이 MainActivity에 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"stateFlow는 핫 플로우이며, 발행 프로세스도 ViewModel에 있기 때문에 발행 프로세스는 라이프사이클을 인식하지 못한 채 계속 실행됩니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"init {\\n    viewModelScope.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"launch\"\n        }), \" {\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"while\"\n        }), \" (\", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"true\"\n        }), \") {\\n           \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"delay\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1000\"\n        }), \")\\n           savedStateHandle[\", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"KEY\"\n        }), \"] = stateFlowCounter.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"value\"\n        }), \" + \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"\\n        }\\n    }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"따라서 결과는 아래와 같습니다.\"\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/assets/img/2024-05-18-LearnSimpleAndroidComposeFlowLifecycleHandlingWithCounter_10.png\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"회전 문제와 저장 및 복원 문제를 해결했습니다. 그러나 백그라운드에서 일시 중지되지 않는 문제가 되돌아왔습니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"아래 이미지를 참고해 주세요.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"WhileSubcribed가 도와 주었어요\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"답을 찾기 위해 검색한 후, 답을 찾도록 도와준\\nManuel Vivo님에게 감사드립니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"간략하게 말하자면, stateFlow에 대해 WhileSubscribed를 사용하여 구독자(수집 중인)가 있는 경우에만 stateFlow가 활성화되도록 해야합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이를 위해 아래와 같이 stateIn을 추가해야 합니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"val stateFlowCounter = savedStateHandle\\n    .\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"getStateFlow\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"KEY\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \")\\n    .\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"stateIn\"\n        }), \"(\\n        viewModelScope,\\n        \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"SharingStarted\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"WhileSubscribed\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"),\\n        \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"\\n    )\\ninit {\\n    viewModelScope.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"launch\"\n        }), \" {\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"while\"\n        }), \" (\", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"true\"\n        }), \") {\\n           \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"delay\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1000\"\n        }), \")\\n           savedStateHandle[\", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"KEY\"\n        }), \"] = stateFlowCounter.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"value\"\n        }), \" + \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"\\n        }\\n    }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이렇게 해야합니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" stateVariable\\n    = viewModel.stateFlowCounter.collectAsStateWithLifecycle()\\nText(\", _jsxs(_components.span, {\n          className: \"hljs-string\",\n          children: [\"\\\"\", _jsx(_components.span, {\n            className: \"hljs-subst\",\n            children: \"${stateVariable.value}\"\n          }), \"\\\"\"]\n        }), \")\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"아래에 최신 코드가 설명되어 있습니다.\"\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/assets/img/2024-05-18-LearnSimpleAndroidComposeFlowLifecycleHandlingWithCounter_12.png\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"원하는 동작을 모두 갖게 될 것입니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-18-LearnSimpleAndroidComposeFlowLifecycleHandlingWithCounter_13.png\",\n        alt: \"이미지1\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-18-LearnSimpleAndroidComposeFlowLifecycleHandlingWithCounter_14.png\",\n        alt: \"이미지2\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-18-LearnSimpleAndroidComposeFlowLifecycleHandlingWithCounter_15.png\",\n        alt: \"이미지3\"\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"TL;DR\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"만약 Google에서 권장하는 Lifecycle Aware한 Flow를 원한다면,\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"보통 플로우나 핫 플로우와 관계없이 collectAsStateWithLifecycle을 사용하세요.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"모든 핫 플로우 (예: StateFlow)에는 WhileSubscribed를 적용하세요.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 내용이 유용하고 상태로 수집된 Flow 및 해당 라이프사이클 처리를 설명했기를 바랍니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"여기에서 코드와 디자인을 가져와 직접 실험해 볼 수 있습니다.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-18-LearnSimpleAndroidComposeFlowLifecycleHandlingWithCounter"},"buildId":"0asLlD6on3tm8cIfzBaxd","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>