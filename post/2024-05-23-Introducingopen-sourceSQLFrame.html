<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>오픈소스 SQLFrame을 소개합니다  | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-05-23-Introducingopen-sourceSQLFrame" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="오픈소스 SQLFrame을 소개합니다  | ui-station" data-gatsby-head="true"/><meta property="og:title" content="오픈소스 SQLFrame을 소개합니다  | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-23-Introducingopen-sourceSQLFrame_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-05-23-Introducingopen-sourceSQLFrame" data-gatsby-head="true"/><meta name="twitter:title" content="오픈소스 SQLFrame을 소개합니다  | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-23-Introducingopen-sourceSQLFrame_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-23 16:00" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-V5DKFTZ6BX"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-V5DKFTZ6BX');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/cd012fc8787133d0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cd012fc8787133d0.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/551-3069cf29fe274aab.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-561ae49ab5aab7f5.js" defer=""></script><script src="/_next/static/PgdIX9e0tvkvkdAmDT6qR/_buildManifest.js" defer=""></script><script src="/_next/static/PgdIX9e0tvkvkdAmDT6qR/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">오픈소스 SQLFrame을 소개합니다 </h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="오픈소스 SQLFrame을 소개합니다 " loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 23, 2024</span><span class="posts_reading_time__f7YPP">6<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-23-Introducingopen-sourceSQLFrame&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><p>13년간 데이터 엔지니어로 근무하면서 변화에 익숙해졌어요. 클라우드 이전과 같은 중요한 변화나 노트북 활용과 같은 작은 트렌드와 같은 것들이죠. 이 모든 변화 속에서도 하나는 불변해 왔어요: SQL이죠. 스타트업부터 FAANG까지 다양한 회사에서 일한 경험을 통해 알게 된 것은 SQL을 잘 이해하고 작성해야 한다는 것이었어요. SQL은 모든 데이터 전문가들을 통합하는 보편적 언어이며, 복잡한 분산 처리의 세부사항을 처리하는 쿼리 플래너와 옵티마이저를 통해 효율적인 데이터 파이프라인을 구축할 수 있게 해줘요.</p>
<p>SQL의 강점에도 불구하고, 이 언어는 종종 데이터 파이프라인 유지 관리에는 적합하지 않아 보일 수 있어요. 이 언어는 일반적인 작업을 추상화하거나 코드의 특정 세그먼트에 대한 단위 테스트를 지원하지 않아서, 많은 사람들이 임시 방법으로 Jinja를 사용하곤 해요. Jinja SQL은 SQL의 Pig Latin과 같은 관계로, 작은 량에서는 재미있을 수도 있지만, 대규모로 확장하면 이해하기 어려워지기도 해요. 더구나, SQL의 반복적인 특성은 열을 반복해서 지정해야 하는 것으로, 종종 데이터 전문가들 사이에서 피로감을 일으킬 수 있어요.
결국, 데이터 전문가들은 SELECT *의 유혹에 반응하며 불확실성의 바다에서 침몰하게 되기도 해요.</p>
<p>이로써 데이터 전문가들이 어려운 선택을 하게 되었어요: 접근성을 우선시하여 SQL로 파이프라인을 작성할 것인가요, 아니면 유지보수성을 우선시하여 Python으로 작성할 것인가요? 오늘부터는 더 이상 선택할 필요가 없어요. 이제 여러분은 동시에 케이크를 먹고 가질 수 있게 되었어요.</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*JZ4jUIBrQAf-oovf3IFN1w.gif" alt="image"/></p>
<div class="content-ad"></div>
<h1>오픈소스 SQLFrame 소개! 🎉</h1>
<p><img src="/assets/img/2024-05-23-Introducingopen-sourceSQLFrame_0.png" alt="이미지"/></p>
<p>SQLFrame은 데이터 전문가들이 SQL 및 PySpark 데이터프레임과 상호 작용하는 방식을 혁신합니다. 전통적인 PySpark과 달리 SQLFrame은 DataFrame 작업을 직접 SQL로 변환하여 개발 중에 실시간 SQL 스크립트 생성을 가능하게 합니다. 작동 방법은 다음과 같습니다:</p>
<p>공개적으로 접근 가능한 출생 데이터를 기반으로 단일 아동을 선택한 새 가족의 수를 분석하는 시나리오를 고려해 보겠습니다.</p>
<div class="content-ad"></div>
<p>js
from sqlframe.bigquery import BigQuerySession
from sqlframe.bigquery import functions as F
from sqlframe.bigquery import Window</p>
<h1>SQLFrame에서 제공하는 고유 기능: 빅쿼리에 직접 연결할 수 있는 능력</h1>
<p>session = BigQuerySession(default_dataset=&quot;sqlframe.db1&quot;)
table_path = &quot;bigquery-public-data.samples.natality&quot;
df = (
session.read.table(table_path)
.where(F.col(&quot;ever_born&quot;) == 1)
.groupBy(&quot;year&quot;)
.agg(F.count(&quot;*&quot;).alias(&quot;num_single_child_families&quot;))
.withColumn(&quot;percent_change&quot;, 1 - F.lag(F.col(&quot;num_single_child_families&quot;), 1).over(Window.orderBy(&quot;year&quot;)) / F.col(&quot;num_single_child_families&quot;))
.orderBy(F.abs(F.col(&quot;percent_change&quot;)).desc())
.select(
F.col(&quot;year&quot;).alias(&quot;Year&quot;),
F.format_number(&quot;num_single_child_families&quot;, 0).alias(&quot;number of new families single child&quot;),
F.format_number(F.col(&quot;percent_change&quot;) * 100, 2).alias(&quot;percent change&quot;),
)
.limit(5)
)</p>
<h1>SQLFrame에서 제공하는 고유 기능: DataFrame의 SQL 확인 가능</h1>
<p>df.sql()</p>
<p>SQLFrame를 사용하면 특별한 빅쿼리 클래스를 활용하여 빅쿼리 환경과 시스템을 원활하게 통합할 수 있습니다. DataFrame 작업은 PySpark에서 수행하는 것과 유사하지만 SQLFrame를 이용하면 df.sql() 메서드를 사용하여 실시간으로 생성 및 검토하는 대응하는 SQL 쿼리도 볼 수 있습니다.</p>
<p>js
WITH <code>t94228</code> AS (
SELECT
<code>natality</code>.<code>year</code> AS <code>year</code>,
COUNT(*) AS <code>num_single_child_families</code>
FROM <code>bigquery-public-data</code>.<code>samples</code>.<code>natality</code> AS <code>natality</code>
WHERE
<code>natality</code>.<code>ever_born</code> = 1
GROUP BY
<code>natality</code>.<code>year</code>
), <code>t34770</code> AS (
SELECT
<code>t94228</code>.<code>year</code> AS <code>year</code>,
<code>t94228</code>.<code>num_single_child_families</code> AS <code>num_single_child_families</code>,
1 - LAG(<code>t94228</code>.<code>num_single_child_families</code>, 1) OVER (ORDER BY <code>t94228</code>.<code>year</code>) / <code>t94228</code>.<code>num_single_child_families</code> AS <code>percent_change</code>
FROM <code>t94228</code> AS <code>t94228</code>
ORDER BY
ABS(<code>percent_change</code>) DESC
)
SELECT
<code>t34770</code>.<code>year</code> AS <code>year</code>,
FORMAT(&#x27;%&#x27;.0f&#x27;, ROUND(CAST(<code>t34770</code>.<code>num_single_child_families</code> AS FLOAT64), 0)) AS <code>number of new families single child</code>,
FORMAT(&#x27;%&#x27;.2f&#x27;, ROUND(CAST(<code>t34770</code>.<code>percent_change</code> * 100 AS FLOAT64), 2)) AS <code>percent change</code>
FROM <code>t34770</code> AS <code>t34770</code>
LIMIT 5</p>
<p>이 기능은 이해를 증진시킬 뿐만 아니라 SQL 출력이 결정론적이어서 버전 관리에 적합하게 만듭니다. 이렇게 함으로써 파이썬 및 SQL 파이프라인의 표현을 모두 버전 관리할 수 있고 동료들이 가장 잘 맞는 형식을 선택할 수 있게 합니다!</p>
<div class="content-ad"></div>
<p><img src="https://miro.medium.com/v2/resize:fit:808/1*y_ZC1qkDPllTA3Yk3XiC8A.gif" alt="SQLFrame"/></p>
<p>SQLFrame은 SQL을 생성하는 것 이상을 제공합니다: PySpark DataFrame API가 모든 주요 데이터 웨어하우스에서 네이티브 DataFrame API처럼 느껴지게 하는 것이 목표입니다. 따라서 사용자들은 스파크 클러스터나 라이브러리 없이 데이터 웨어하우스에서 DataFrame API 파이프라인을 직접 실행할 수 있습니다!</p>
<p>예를 들어, .sql()을 .show()로 바꾸면 파이프라인에서 빅쿼리에서 결과를 직접 표시할 수 있습니다. 이는 PySpark에서와 같은 방식으로 작동합니다.</p>
<p>python</p>
<blockquote>
<blockquote>
<blockquote>
<p>df.show()
+------+-------------------------------------+----------------+
| year | number of new families single child | percent change |
+------+-------------------------------------+----------------+
| 1989 |              1,650,246              |     20.01      |
| 1974 |               783,448               |     12.66      |
| 1977 |              1,057,379              |     10.22      |
| 1985 |              1,308,476              |     10.03      |
| 1975 |               868,985               |      9.84      |
+------+-------------------------------------+----------------+</p>
</blockquote>
</blockquote>
</blockquote>
<p>`</p>
<div class="content-ad"></div>
<p>많은 카탈로그 작업이 지원되며 listColumns와 같은 것이 지원됩니다:</p>
<pre><code class="hljs language-js">&gt;&gt;&gt; columns = session.<span class="hljs-property">catalog</span>.<span class="hljs-title function_">listColumns</span>(table_path)
&gt;&gt;&gt; <span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;\n&quot;</span>.<span class="hljs-title function_">join</span>([f<span class="hljs-string">&quot;Name: {x.name}, Data Type: {x.dataType}, Desc: {x.description}&quot;</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> columns]))
<span class="hljs-title class_">Name</span>: source_year, <span class="hljs-title class_">Data</span> <span class="hljs-title class_">Type</span>: <span class="hljs-title class_">INT64</span>, <span class="hljs-title class_">Desc</span>: <span class="hljs-title class_">Four</span>-digit year <span class="hljs-keyword">of</span> the birth. <span class="hljs-title class_">Example</span>: <span class="hljs-number">1975.</span>
<span class="hljs-title class_">Name</span>: year, <span class="hljs-title class_">Data</span> <span class="hljs-title class_">Type</span>: <span class="hljs-title class_">INT64</span>, <span class="hljs-title class_">Desc</span>: <span class="hljs-title class_">Four</span>-digit year <span class="hljs-keyword">of</span> the birth. <span class="hljs-title class_">Example</span>: <span class="hljs-number">1975.</span>
<span class="hljs-title class_">Name</span>: month, <span class="hljs-title class_">Data</span> <span class="hljs-title class_">Type</span>: <span class="hljs-title class_">INT64</span>, <span class="hljs-title class_">Desc</span>: <span class="hljs-title class_">Month</span> index <span class="hljs-keyword">of</span> the date <span class="hljs-keyword">of</span> birth, where <span class="hljs-number">1</span>=<span class="hljs-title class_">January</span>.
<span class="hljs-title class_">Name</span>: day, <span class="hljs-title class_">Data</span> <span class="hljs-title class_">Type</span>: <span class="hljs-title class_">INT64</span>, <span class="hljs-title class_">Desc</span>: <span class="hljs-title class_">Day</span> <span class="hljs-keyword">of</span> birth, starting <span class="hljs-keyword">from</span> <span class="hljs-number">1.</span>
<span class="hljs-title class_">Name</span>: wday, <span class="hljs-title class_">Data</span> <span class="hljs-title class_">Type</span>: <span class="hljs-title class_">INT64</span>, <span class="hljs-title class_">Desc</span>: <span class="hljs-title class_">Day</span> <span class="hljs-keyword">of</span> the week, where <span class="hljs-number">1</span> is <span class="hljs-title class_">Sunday</span> and <span class="hljs-number">7</span> is <span class="hljs-title class_">Saturday</span>.
<span class="hljs-title class_">Name</span>: state, <span class="hljs-title class_">Data</span> <span class="hljs-title class_">Type</span>: <span class="hljs-variable constant_">STRING</span>, <span class="hljs-title class_">Desc</span>: <span class="hljs-title class_">The</span> two character postal code <span class="hljs-keyword">for</span> the state. <span class="hljs-title class_">Entries</span> after <span class="hljs-number">2004</span> <span class="hljs-keyword">do</span> not include <span class="hljs-variable language_">this</span> value.
</code></pre>
<p>따라서 SQLFrame은 단순히 DataFrame 파이프라인을 더욱 접근 가능하게 만들 뿐만 아니라, PySpark DataFrame API를 보다 범용의 DataFrame API로 변환하여 모든 데이터 전문가가 즐길 수 있습니다!</p>
<img src="https://miro.medium.com/v2/resize:fit:720/1*JQ7uBfQn-4VWWWlfl5D_sA.gif"/>
<div class="content-ad"></div>
<p>SQLFrame은 현재 BigQuery, DuckDB 및 Postgres를 지원하고 있으며, Clickhouse, Redshift, Snowflake, Spark 및 Trino가 개발 중에 있습니다. 다른 엔진을 위한 SQL 생성 실험을 원하는 경우 Standalone 세션에서 유연한 테스트 환경을 제공합니다.</p>
<p>SQLFrame을 시작하려면 GitHub 리포지토리를 확인해보세요!</p>
<p><img src="/assets/img/2024-05-23-Introducingopen-sourceSQLFrame_1.png" alt="SQLFrame 소개"/></p></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"오픈소스 SQLFrame을 소개합니다 ","description":"","date":"2024-05-23 16:00","slug":"2024-05-23-Introducingopen-sourceSQLFrame","content":"\n13년간 데이터 엔지니어로 근무하면서 변화에 익숙해졌어요. 클라우드 이전과 같은 중요한 변화나 노트북 활용과 같은 작은 트렌드와 같은 것들이죠. 이 모든 변화 속에서도 하나는 불변해 왔어요: SQL이죠. 스타트업부터 FAANG까지 다양한 회사에서 일한 경험을 통해 알게 된 것은 SQL을 잘 이해하고 작성해야 한다는 것이었어요. SQL은 모든 데이터 전문가들을 통합하는 보편적 언어이며, 복잡한 분산 처리의 세부사항을 처리하는 쿼리 플래너와 옵티마이저를 통해 효율적인 데이터 파이프라인을 구축할 수 있게 해줘요.\n\nSQL의 강점에도 불구하고, 이 언어는 종종 데이터 파이프라인 유지 관리에는 적합하지 않아 보일 수 있어요. 이 언어는 일반적인 작업을 추상화하거나 코드의 특정 세그먼트에 대한 단위 테스트를 지원하지 않아서, 많은 사람들이 임시 방법으로 Jinja를 사용하곤 해요. Jinja SQL은 SQL의 Pig Latin과 같은 관계로, 작은 량에서는 재미있을 수도 있지만, 대규모로 확장하면 이해하기 어려워지기도 해요. 더구나, SQL의 반복적인 특성은 열을 반복해서 지정해야 하는 것으로, 종종 데이터 전문가들 사이에서 피로감을 일으킬 수 있어요.\n결국, 데이터 전문가들은 SELECT \\*의 유혹에 반응하며 불확실성의 바다에서 침몰하게 되기도 해요.\n\n이로써 데이터 전문가들이 어려운 선택을 하게 되었어요: 접근성을 우선시하여 SQL로 파이프라인을 작성할 것인가요, 아니면 유지보수성을 우선시하여 Python으로 작성할 것인가요? 오늘부터는 더 이상 선택할 필요가 없어요. 이제 여러분은 동시에 케이크를 먹고 가질 수 있게 되었어요.\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*JZ4jUIBrQAf-oovf3IFN1w.gif)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 오픈소스 SQLFrame 소개! 🎉\n\n![이미지](/assets/img/2024-05-23-Introducingopen-sourceSQLFrame_0.png)\n\nSQLFrame은 데이터 전문가들이 SQL 및 PySpark 데이터프레임과 상호 작용하는 방식을 혁신합니다. 전통적인 PySpark과 달리 SQLFrame은 DataFrame 작업을 직접 SQL로 변환하여 개발 중에 실시간 SQL 스크립트 생성을 가능하게 합니다. 작동 방법은 다음과 같습니다:\n\n공개적으로 접근 가능한 출생 데이터를 기반으로 단일 아동을 선택한 새 가족의 수를 분석하는 시나리오를 고려해 보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\njs\nfrom sqlframe.bigquery import BigQuerySession\nfrom sqlframe.bigquery import functions as F\nfrom sqlframe.bigquery import Window\n\n# SQLFrame에서 제공하는 고유 기능: 빅쿼리에 직접 연결할 수 있는 능력\nsession = BigQuerySession(default_dataset=\"sqlframe.db1\")\ntable_path = \"bigquery-public-data.samples.natality\"\ndf = (\n    session.read.table(table_path)\n    .where(F.col(\"ever_born\") == 1)\n    .groupBy(\"year\")\n    .agg(F.count(\"*\").alias(\"num_single_child_families\"))\n    .withColumn(\"percent_change\", 1 - F.lag(F.col(\"num_single_child_families\"), 1).over(Window.orderBy(\"year\")) / F.col(\"num_single_child_families\"))\n    .orderBy(F.abs(F.col(\"percent_change\")).desc())\n    .select(\n        F.col(\"year\").alias(\"Year\"),\n        F.format_number(\"num_single_child_families\", 0).alias(\"number of new families single child\"),\n        F.format_number(F.col(\"percent_change\") * 100, 2).alias(\"percent change\"),\n    )\n    .limit(5)\n)\n# SQLFrame에서 제공하는 고유 기능: DataFrame의 SQL 확인 가능\ndf.sql()\n\n\nSQLFrame를 사용하면 특별한 빅쿼리 클래스를 활용하여 빅쿼리 환경과 시스템을 원활하게 통합할 수 있습니다. DataFrame 작업은 PySpark에서 수행하는 것과 유사하지만 SQLFrame를 이용하면 df.sql() 메서드를 사용하여 실시간으로 생성 및 검토하는 대응하는 SQL 쿼리도 볼 수 있습니다.\n\njs\nWITH `t94228` AS (\n  SELECT\n    `natality`.`year` AS `year`,\n    COUNT(*) AS `num_single_child_families`\n  FROM `bigquery-public-data`.`samples`.`natality` AS `natality`\n  WHERE\n    `natality`.`ever_born` = 1\n  GROUP BY\n    `natality`.`year`\n), `t34770` AS (\n  SELECT\n    `t94228`.`year` AS `year`,\n    `t94228`.`num_single_child_families` AS `num_single_child_families`,\n    1 - LAG(`t94228`.`num_single_child_families`, 1) OVER (ORDER BY `t94228`.`year`) / `t94228`.`num_single_child_families` AS `percent_change`\n  FROM `t94228` AS `t94228`\n  ORDER BY\n    ABS(`percent_change`) DESC\n)\nSELECT\n  `t34770`.`year` AS `year`,\n  FORMAT('%\\'.0f', ROUND(CAST(`t34770`.`num_single_child_families` AS FLOAT64), 0)) AS `number of new families single child`,\n  FORMAT('%\\'.2f', ROUND(CAST(`t34770`.`percent_change` * 100 AS FLOAT64), 2)) AS `percent change`\nFROM `t34770` AS `t34770`\nLIMIT 5\n\n\n이 기능은 이해를 증진시킬 뿐만 아니라 SQL 출력이 결정론적이어서 버전 관리에 적합하게 만듭니다. 이렇게 함으로써 파이썬 및 SQL 파이프라인의 표현을 모두 버전 관리할 수 있고 동료들이 가장 잘 맞는 형식을 선택할 수 있게 합니다!\n\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n\n![SQLFrame](https://miro.medium.com/v2/resize:fit:808/1*y_ZC1qkDPllTA3Yk3XiC8A.gif)\n\nSQLFrame은 SQL을 생성하는 것 이상을 제공합니다: PySpark DataFrame API가 모든 주요 데이터 웨어하우스에서 네이티브 DataFrame API처럼 느껴지게 하는 것이 목표입니다. 따라서 사용자들은 스파크 클러스터나 라이브러리 없이 데이터 웨어하우스에서 DataFrame API 파이프라인을 직접 실행할 수 있습니다!\n\n예를 들어, .sql()을 .show()로 바꾸면 파이프라인에서 빅쿼리에서 결과를 직접 표시할 수 있습니다. 이는 PySpark에서와 같은 방식으로 작동합니다.\n\npython\n\u003e\u003e\u003e df.show()\n+------+-------------------------------------+----------------+\n| year | number of new families single child | percent change |\n+------+-------------------------------------+----------------+\n| 1989 |              1,650,246              |     20.01      |\n| 1974 |               783,448               |     12.66      |\n| 1977 |              1,057,379              |     10.22      |\n| 1985 |              1,308,476              |     10.03      |\n| 1975 |               868,985               |      9.84      |\n+------+-------------------------------------+----------------+\n\n\n`\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n많은 카탈로그 작업이 지원되며 listColumns와 같은 것이 지원됩니다:\n\n```js\n\u003e\u003e\u003e columns = session.catalog.listColumns(table_path)\n\u003e\u003e\u003e print(\"\\n\".join([f\"Name: {x.name}, Data Type: {x.dataType}, Desc: {x.description}\" for x in columns]))\nName: source_year, Data Type: INT64, Desc: Four-digit year of the birth. Example: 1975.\nName: year, Data Type: INT64, Desc: Four-digit year of the birth. Example: 1975.\nName: month, Data Type: INT64, Desc: Month index of the date of birth, where 1=January.\nName: day, Data Type: INT64, Desc: Day of birth, starting from 1.\nName: wday, Data Type: INT64, Desc: Day of the week, where 1 is Sunday and 7 is Saturday.\nName: state, Data Type: STRING, Desc: The two character postal code for the state. Entries after 2004 do not include this value.\n```\n\n따라서 SQLFrame은 단순히 DataFrame 파이프라인을 더욱 접근 가능하게 만들 뿐만 아니라, PySpark DataFrame API를 보다 범용의 DataFrame API로 변환하여 모든 데이터 전문가가 즐길 수 있습니다!\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:720/1*JQ7uBfQn-4VWWWlfl5D_sA.gif\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSQLFrame은 현재 BigQuery, DuckDB 및 Postgres를 지원하고 있으며, Clickhouse, Redshift, Snowflake, Spark 및 Trino가 개발 중에 있습니다. 다른 엔진을 위한 SQL 생성 실험을 원하는 경우 Standalone 세션에서 유연한 테스트 환경을 제공합니다.\n\nSQLFrame을 시작하려면 GitHub 리포지토리를 확인해보세요!\n\n![SQLFrame 소개](/assets/img/2024-05-23-Introducingopen-sourceSQLFrame_1.png)\n","ogImage":{"url":"/assets/img/2024-05-23-Introducingopen-sourceSQLFrame_0.png"},"coverImage":"/assets/img/2024-05-23-Introducingopen-sourceSQLFrame_0.png","tag":["Tech"],"readingTime":6},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    img: \"img\",\n    h1: \"h1\",\n    code: \"code\",\n    blockquote: \"blockquote\",\n    pre: \"pre\",\n    span: \"span\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"13년간 데이터 엔지니어로 근무하면서 변화에 익숙해졌어요. 클라우드 이전과 같은 중요한 변화나 노트북 활용과 같은 작은 트렌드와 같은 것들이죠. 이 모든 변화 속에서도 하나는 불변해 왔어요: SQL이죠. 스타트업부터 FAANG까지 다양한 회사에서 일한 경험을 통해 알게 된 것은 SQL을 잘 이해하고 작성해야 한다는 것이었어요. SQL은 모든 데이터 전문가들을 통합하는 보편적 언어이며, 복잡한 분산 처리의 세부사항을 처리하는 쿼리 플래너와 옵티마이저를 통해 효율적인 데이터 파이프라인을 구축할 수 있게 해줘요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"SQL의 강점에도 불구하고, 이 언어는 종종 데이터 파이프라인 유지 관리에는 적합하지 않아 보일 수 있어요. 이 언어는 일반적인 작업을 추상화하거나 코드의 특정 세그먼트에 대한 단위 테스트를 지원하지 않아서, 많은 사람들이 임시 방법으로 Jinja를 사용하곤 해요. Jinja SQL은 SQL의 Pig Latin과 같은 관계로, 작은 량에서는 재미있을 수도 있지만, 대규모로 확장하면 이해하기 어려워지기도 해요. 더구나, SQL의 반복적인 특성은 열을 반복해서 지정해야 하는 것으로, 종종 데이터 전문가들 사이에서 피로감을 일으킬 수 있어요.\\n결국, 데이터 전문가들은 SELECT *의 유혹에 반응하며 불확실성의 바다에서 침몰하게 되기도 해요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이로써 데이터 전문가들이 어려운 선택을 하게 되었어요: 접근성을 우선시하여 SQL로 파이프라인을 작성할 것인가요, 아니면 유지보수성을 우선시하여 Python으로 작성할 것인가요? 오늘부터는 더 이상 선택할 필요가 없어요. 이제 여러분은 동시에 케이크를 먹고 가질 수 있게 되었어요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://miro.medium.com/v2/resize:fit:1400/1*JZ4jUIBrQAf-oovf3IFN1w.gif\",\n        alt: \"image\"\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"오픈소스 SQLFrame 소개! 🎉\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-23-Introducingopen-sourceSQLFrame_0.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"SQLFrame은 데이터 전문가들이 SQL 및 PySpark 데이터프레임과 상호 작용하는 방식을 혁신합니다. 전통적인 PySpark과 달리 SQLFrame은 DataFrame 작업을 직접 SQL로 변환하여 개발 중에 실시간 SQL 스크립트 생성을 가능하게 합니다. 작동 방법은 다음과 같습니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"공개적으로 접근 가능한 출생 데이터를 기반으로 단일 아동을 선택한 새 가족의 수를 분석하는 시나리오를 고려해 보겠습니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"js\\nfrom sqlframe.bigquery import BigQuerySession\\nfrom sqlframe.bigquery import functions as F\\nfrom sqlframe.bigquery import Window\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"SQLFrame에서 제공하는 고유 기능: 빅쿼리에 직접 연결할 수 있는 능력\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"session = BigQuerySession(default_dataset=\\\"sqlframe.db1\\\")\\ntable_path = \\\"bigquery-public-data.samples.natality\\\"\\ndf = (\\nsession.read.table(table_path)\\n.where(F.col(\\\"ever_born\\\") == 1)\\n.groupBy(\\\"year\\\")\\n.agg(F.count(\\\"*\\\").alias(\\\"num_single_child_families\\\"))\\n.withColumn(\\\"percent_change\\\", 1 - F.lag(F.col(\\\"num_single_child_families\\\"), 1).over(Window.orderBy(\\\"year\\\")) / F.col(\\\"num_single_child_families\\\"))\\n.orderBy(F.abs(F.col(\\\"percent_change\\\")).desc())\\n.select(\\nF.col(\\\"year\\\").alias(\\\"Year\\\"),\\nF.format_number(\\\"num_single_child_families\\\", 0).alias(\\\"number of new families single child\\\"),\\nF.format_number(F.col(\\\"percent_change\\\") * 100, 2).alias(\\\"percent change\\\"),\\n)\\n.limit(5)\\n)\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"SQLFrame에서 제공하는 고유 기능: DataFrame의 SQL 확인 가능\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"df.sql()\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"SQLFrame를 사용하면 특별한 빅쿼리 클래스를 활용하여 빅쿼리 환경과 시스템을 원활하게 통합할 수 있습니다. DataFrame 작업은 PySpark에서 수행하는 것과 유사하지만 SQLFrame를 이용하면 df.sql() 메서드를 사용하여 실시간으로 생성 및 검토하는 대응하는 SQL 쿼리도 볼 수 있습니다.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"js\\nWITH \", _jsx(_components.code, {\n        children: \"t94228\"\n      }), \" AS (\\nSELECT\\n\", _jsx(_components.code, {\n        children: \"natality\"\n      }), \".\", _jsx(_components.code, {\n        children: \"year\"\n      }), \" AS \", _jsx(_components.code, {\n        children: \"year\"\n      }), \",\\nCOUNT(*) AS \", _jsx(_components.code, {\n        children: \"num_single_child_families\"\n      }), \"\\nFROM \", _jsx(_components.code, {\n        children: \"bigquery-public-data\"\n      }), \".\", _jsx(_components.code, {\n        children: \"samples\"\n      }), \".\", _jsx(_components.code, {\n        children: \"natality\"\n      }), \" AS \", _jsx(_components.code, {\n        children: \"natality\"\n      }), \"\\nWHERE\\n\", _jsx(_components.code, {\n        children: \"natality\"\n      }), \".\", _jsx(_components.code, {\n        children: \"ever_born\"\n      }), \" = 1\\nGROUP BY\\n\", _jsx(_components.code, {\n        children: \"natality\"\n      }), \".\", _jsx(_components.code, {\n        children: \"year\"\n      }), \"\\n), \", _jsx(_components.code, {\n        children: \"t34770\"\n      }), \" AS (\\nSELECT\\n\", _jsx(_components.code, {\n        children: \"t94228\"\n      }), \".\", _jsx(_components.code, {\n        children: \"year\"\n      }), \" AS \", _jsx(_components.code, {\n        children: \"year\"\n      }), \",\\n\", _jsx(_components.code, {\n        children: \"t94228\"\n      }), \".\", _jsx(_components.code, {\n        children: \"num_single_child_families\"\n      }), \" AS \", _jsx(_components.code, {\n        children: \"num_single_child_families\"\n      }), \",\\n1 - LAG(\", _jsx(_components.code, {\n        children: \"t94228\"\n      }), \".\", _jsx(_components.code, {\n        children: \"num_single_child_families\"\n      }), \", 1) OVER (ORDER BY \", _jsx(_components.code, {\n        children: \"t94228\"\n      }), \".\", _jsx(_components.code, {\n        children: \"year\"\n      }), \") / \", _jsx(_components.code, {\n        children: \"t94228\"\n      }), \".\", _jsx(_components.code, {\n        children: \"num_single_child_families\"\n      }), \" AS \", _jsx(_components.code, {\n        children: \"percent_change\"\n      }), \"\\nFROM \", _jsx(_components.code, {\n        children: \"t94228\"\n      }), \" AS \", _jsx(_components.code, {\n        children: \"t94228\"\n      }), \"\\nORDER BY\\nABS(\", _jsx(_components.code, {\n        children: \"percent_change\"\n      }), \") DESC\\n)\\nSELECT\\n\", _jsx(_components.code, {\n        children: \"t34770\"\n      }), \".\", _jsx(_components.code, {\n        children: \"year\"\n      }), \" AS \", _jsx(_components.code, {\n        children: \"year\"\n      }), \",\\nFORMAT('%'.0f', ROUND(CAST(\", _jsx(_components.code, {\n        children: \"t34770\"\n      }), \".\", _jsx(_components.code, {\n        children: \"num_single_child_families\"\n      }), \" AS FLOAT64), 0)) AS \", _jsx(_components.code, {\n        children: \"number of new families single child\"\n      }), \",\\nFORMAT('%'.2f', ROUND(CAST(\", _jsx(_components.code, {\n        children: \"t34770\"\n      }), \".\", _jsx(_components.code, {\n        children: \"percent_change\"\n      }), \" * 100 AS FLOAT64), 2)) AS \", _jsx(_components.code, {\n        children: \"percent change\"\n      }), \"\\nFROM \", _jsx(_components.code, {\n        children: \"t34770\"\n      }), \" AS \", _jsx(_components.code, {\n        children: \"t34770\"\n      }), \"\\nLIMIT 5\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 기능은 이해를 증진시킬 뿐만 아니라 SQL 출력이 결정론적이어서 버전 관리에 적합하게 만듭니다. 이렇게 함으로써 파이썬 및 SQL 파이프라인의 표현을 모두 버전 관리할 수 있고 동료들이 가장 잘 맞는 형식을 선택할 수 있게 합니다!\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://miro.medium.com/v2/resize:fit:808/1*y_ZC1qkDPllTA3Yk3XiC8A.gif\",\n        alt: \"SQLFrame\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"SQLFrame은 SQL을 생성하는 것 이상을 제공합니다: PySpark DataFrame API가 모든 주요 데이터 웨어하우스에서 네이티브 DataFrame API처럼 느껴지게 하는 것이 목표입니다. 따라서 사용자들은 스파크 클러스터나 라이브러리 없이 데이터 웨어하우스에서 DataFrame API 파이프라인을 직접 실행할 수 있습니다!\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"예를 들어, .sql()을 .show()로 바꾸면 파이프라인에서 빅쿼리에서 결과를 직접 표시할 수 있습니다. 이는 PySpark에서와 같은 방식으로 작동합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"python\"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsxs(_components.blockquote, {\n          children: [\"\\n\", _jsx(_components.p, {\n            children: \"df.show()\\n+------+-------------------------------------+----------------+\\n| year | number of new families single child | percent change |\\n+------+-------------------------------------+----------------+\\n| 1989 |              1,650,246              |     20.01      |\\n| 1974 |               783,448               |     12.66      |\\n| 1977 |              1,057,379              |     10.22      |\\n| 1985 |              1,308,476              |     10.03      |\\n| 1975 |               868,985               |      9.84      |\\n+------+-------------------------------------+----------------+\"\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"`\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"많은 카탈로그 작업이 지원되며 listColumns와 같은 것이 지원됩니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"\u003e\u003e\u003e columns = session.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"catalog\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"listColumns\"\n        }), \"(table_path)\\n\u003e\u003e\u003e \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"print\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\\\\n\\\"\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"join\"\n        }), \"([f\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Name: {x.name}, Data Type: {x.dataType}, Desc: {x.description}\\\"\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" x \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" columns]))\\n\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Name\"\n        }), \": source_year, \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Data\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Type\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"INT64\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Desc\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Four\"\n        }), \"-digit year \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"of\"\n        }), \" the birth. \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Example\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1975.\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Name\"\n        }), \": year, \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Data\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Type\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"INT64\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Desc\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Four\"\n        }), \"-digit year \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"of\"\n        }), \" the birth. \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Example\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1975.\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Name\"\n        }), \": month, \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Data\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Type\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"INT64\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Desc\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Month\"\n        }), \" index \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"of\"\n        }), \" the date \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"of\"\n        }), \" birth, where \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"=\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"January\"\n        }), \".\\n\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Name\"\n        }), \": day, \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Data\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Type\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"INT64\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Desc\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Day\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"of\"\n        }), \" birth, starting \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1.\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Name\"\n        }), \": wday, \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Data\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Type\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"INT64\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Desc\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Day\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"of\"\n        }), \" the week, where \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \" is \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Sunday\"\n        }), \" and \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"7\"\n        }), \" is \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Saturday\"\n        }), \".\\n\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Name\"\n        }), \": state, \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Data\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Type\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"STRING\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Desc\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"The\"\n        }), \" two character postal code \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" the state. \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Entries\"\n        }), \" after \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"2004\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"do\"\n        }), \" not include \", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"this\"\n        }), \" value.\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"따라서 SQLFrame은 단순히 DataFrame 파이프라인을 더욱 접근 가능하게 만들 뿐만 아니라, PySpark DataFrame API를 보다 범용의 DataFrame API로 변환하여 모든 데이터 전문가가 즐길 수 있습니다!\"\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"https://miro.medium.com/v2/resize:fit:720/1*JQ7uBfQn-4VWWWlfl5D_sA.gif\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"SQLFrame은 현재 BigQuery, DuckDB 및 Postgres를 지원하고 있으며, Clickhouse, Redshift, Snowflake, Spark 및 Trino가 개발 중에 있습니다. 다른 엔진을 위한 SQL 생성 실험을 원하는 경우 Standalone 세션에서 유연한 테스트 환경을 제공합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"SQLFrame을 시작하려면 GitHub 리포지토리를 확인해보세요!\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-23-Introducingopen-sourceSQLFrame_1.png\",\n        alt: \"SQLFrame 소개\"\n      })\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-23-Introducingopen-sourceSQLFrame"},"buildId":"PgdIX9e0tvkvkdAmDT6qR","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>