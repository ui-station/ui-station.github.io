<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>젯팩 컴포즈 부가 효과 자세히 알아보기 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-05-27-JetpackComposeSideEffectsinDetails" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="젯팩 컴포즈 부가 효과 자세히 알아보기 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="젯팩 컴포즈 부가 효과 자세히 알아보기 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-27-JetpackComposeSideEffectsinDetails_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-05-27-JetpackComposeSideEffectsinDetails" data-gatsby-head="true"/><meta name="twitter:title" content="젯팩 컴포즈 부가 효과 자세히 알아보기 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-27-JetpackComposeSideEffectsinDetails_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-27 16:11" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-70e5ce89f3d962ac.js" defer=""></script><script src="/_next/static/GsgRekSb--BvxYwv9FPn6/_buildManifest.js" defer=""></script><script src="/_next/static/GsgRekSb--BvxYwv9FPn6/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">젯팩 컴포즈 부가 효과 자세히 알아보기</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="젯팩 컴포즈 부가 효과 자세히 알아보기" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 27, 2024</span><span class="posts_reading_time__f7YPP">14<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-27-JetpackComposeSideEffectsinDetails&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/assets/img/2024-05-27-JetpackComposeSideEffectsinDetails_0.png" alt="Jetpack Compose"></p>
<p>Jetpack Compose는 Android에서 UI 개발을 훨씬 쉽게 만들었지만, UI 효과를 효율적으로 관리하는 방법을 이해하는 것이 성능 향상에 매우 중요합니다. 본 문서에서는 UI 효과를 효과적으로 관리하는 데 도움이 되는 세 가지 중요한 Composable 함수인 SideEffect, LaunchedEffect 및 DisposableEffect을 살펴보겠습니다.</p>
<h1>왜 부작용(side-effect)이 필요한가요?</h1>
<p>Jetpack Compose에서 부작용의 목적은 Composable 함수 외부에서 앱의 상태를 변경하는 UI와 관련 없는 작업을 제어 가능하고 예측 가능한 방식으로 실행할 수 있게 하는 것입니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>부작용은 데이터베이스 업데이트나 네트워크 호출과 같은 작업을 UI 렌더링 로직과 분리하여 코드의 성능과 유지 보수성을 향상시켜야 합니다.</p>
<p>젯팩 컴포즈는 SideEffect, LaunchedEffect, DisposableEffect와 같은 여러 컴포저블 함수를 제공하여 개발자가 사이드 이펙트를 효과적으로 관리할 수 있도록 해줍니다. 이를 통해 UI 렌더링 로직과 분리하고 별도의 코루틴 범위에서 실행함으로써 사이드 이펙트를 처리할 수 있습니다.</p>
<p>젯팩 컴포즈에서 사이드 이펙트를 사용하는 주요 이점은 다음과 같습니다:</p>
<ul>
<li>성능 향상: 비 UI 관련 작업을 컴포저블 함수 외부에서 실행함으로써 UI 렌더링 로직이 반응성이 있고 성능이 좋아집니다.</li>
<li>코드 구성 개선: UI 렌더링 로직에서 비 UI 관련 작업을 분리함으로써 코드베이스가 이해하기 쉬워지고 유지 보수가 용이해집니다.</li>
<li>디버깅 개선: 사이드 이펙트는 로깅 및 분석 작업에 사용될 수 있으며, 이를 통해 개발자가 앱의 동작을 더 잘 이해하고 문제점을 식별할 수 있습니다.</li>
</ul>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>요약하면 Jetpack Compose에서의 부작용의 목적은 UI 렌더링 로직에서 UI와 상관없는 작업을 분리함으로써 코드베이스의 성능, 유지 관리 및 디버깅을 개선하는 것입니다.</p>
<h2>SideEffect</h2>
<p>SideEffect는 부모 Composable이 recomposed될 때 부작용을 실행할 수 있게 해주는 Composable 함수입니다. 부작용이란 직접적으로 UI에 영향을 주지 않는 작업으로, 로깅, 분석 또는 외부 상태 갱신과 같은 작업을 의미합니다. 이 함수는 Composable의 상태나 props에 의존하지 않는 작업을 실행하는 데 유용합니다.</p>
<p>Composable이 recomposed되면 Composable 함수 내의 모든 코드가 다시 실행되며, 이 과정에서 모든 부작용도 다시 실행됩니다. 그러나 UI는 Composable의 상태나 props에 대한 변경 사항만 반영하여 업데이트됩니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>SideEffect를 사용하는 방법</h1>
<p>SideEffect를 사용하려면 Composable 함수 내부에서 호출하고 실행하려는 사이드 이펙트를 포함한 람다를 전달해야 합니다. 다음은 예시입니다:</p>
<pre><code class="hljs language-js">@<span class="hljs-title class_">Composable</span>
fun <span class="hljs-title class_">Counter</span>() {
    <span class="hljs-comment">// Count를 위한 상태 변수 정의</span>
    val count = remember { <span class="hljs-title function_">mutableStateOf</span>(<span class="hljs-number">0</span>) }

    <span class="hljs-comment">// SideEffect를 사용하여 count 변수의 현재 값 로깅</span>
    <span class="hljs-title class_">SideEffect</span> {
        <span class="hljs-comment">// 재구성할 때마다 호출됨</span>
        <span class="hljs-title function_">log</span>(<span class="hljs-string">"Count is ${count.value}"</span>)
    }

    <span class="hljs-title class_">Column</span> {
        <span class="hljs-title class_">Button</span>(onClick = { count.<span class="hljs-property">value</span>++ }) {
            <span class="hljs-title class_">Text</span>(<span class="hljs-string">"Increase Count"</span>)
        }

        <span class="hljs-comment">// 상태가 업데이트될 때마다 텍스트가 변경되고 재구성이 트리거됩니다</span>
        <span class="hljs-title class_">Text</span>(<span class="hljs-string">"Counter ${count.value}"</span>)
    }
}
</code></pre>
<p>이 예시에서 SideEffect 함수는 Counter 함수가 재구성될 때마다 count 상태 변수의 현재 값이 로깅됩니다. 이는 디버깅 및 Composable 동작 모니터링에 유용합니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>현재 Composable 함수가 recomposed될 때만 부작용이 발생합니다. 중첩된 Composable 함수에는 해당되지 않습니다. 즉, 다른 Composable 함수를 호출하는 Composable 함수가 있는 경우, 내부 Composable 함수가 recomposed될 때 외부 Composable 함수의 SideEffect가 트리거되지 않습니다. 이를 이해하기 위해 코드를 다음과 같이 변경해보겠습니다:</p>
<pre><code class="hljs language-js">@<span class="hljs-title class_">Composable</span>
fun <span class="hljs-title class_">Counter</span>() {
    <span class="hljs-comment">// count를 위한 상태 변수 정의</span>
    val count = remember { <span class="hljs-title function_">mutableStateOf</span>(<span class="hljs-number">0</span>) }

    <span class="hljs-comment">// count의 현재 값 로그 남기기 위해 SideEffect 사용</span>
    <span class="hljs-title class_">SideEffect</span> {
        <span class="hljs-comment">// 재구성마다 호출됨</span>
        <span class="hljs-title function_">log</span>(<span class="hljs-string">"Count is ${count.value}"</span>)
    }

    <span class="hljs-title class_">Column</span> {
        <span class="hljs-title class_">Button</span>(onClick = { count.<span class="hljs-property">value</span>++ }) {
            <span class="hljs-comment">// 버튼이 탭될 때마다 바깥쪽 부작용이 트리거되지 않음</span>
            <span class="hljs-comment">// 매번 버튼이 탭될 때마다 Text가 recompose됨</span>
            <span class="hljs-title class_">Text</span>(<span class="hljs-string">"Increase Count ${count.value}"</span>)
        }
    }
}
</code></pre>
<p>위의 코드에서 앱이 처음 시작될 때, Counter Composable 함수가 compose되고 SideEffect가 count의 초기 값으로 console에 로그를 남깁니다. 버튼을 클릭하면 Text Composable이 count의 새 값으로 recompose되지만, 이는 SideEffect를 다시 트리거하지 않습니다.</p>
<p>이제 이 작동 방식을 보기 위해 inner side effect를 추가해봅시다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-kotlin"><span class="hljs-meta">@Composable</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">Counter</span><span class="hljs-params">()</span></span> {
    <span class="hljs-comment">// 카운트를 위한 상태 변수 정의</span>
    <span class="hljs-keyword">val</span> count = remember { mutableStateOf(<span class="hljs-number">0</span>) }

    <span class="hljs-comment">// SideEffect를 사용하여 count의 현재 값 로깅</span>
    SideEffect {
        <span class="hljs-comment">// 재구성마다 호출</span>
        log(<span class="hljs-string">"Outer Count is <span class="hljs-subst">${count.value}</span>"</span>)
    }

    Column {
        Button(onClick = { count.value++ }) {
            <span class="hljs-comment">// SideEffect를 사용하여 count의 현재 값 로깅</span>
            SideEffect {
                <span class="hljs-comment">// 재구성마다 호출</span>
                log(<span class="hljs-string">"Inner Count is <span class="hljs-subst">${count.value}</span>"</span>)
            }

            <span class="hljs-comment">// 이 재구성은 버튼을 누를 때마다</span>
            <span class="hljs-comment">// 외부 SideEffect를 계속해서 트리거하지 않습니다</span>
            Text(<span class="hljs-string">"Increase Count <span class="hljs-subst">${count.value}</span>"</span>)
        }
    }
}
</code></pre>
<p>위의 코드를 사용하여 버튼을 클릭하면 출력 결과가 다음과 같이 나타납니다:</p>
<pre><code class="hljs language-kotlin">Outer Count <span class="hljs-keyword">is</span> <span class="hljs-number">0</span>
Inner Count <span class="hljs-keyword">is</span> <span class="hljs-number">0</span>
Inner Count <span class="hljs-keyword">is</span> <span class="hljs-number">1</span>
Inner Count <span class="hljs-keyword">is</span> <span class="hljs-number">2</span>
Inner Count <span class="hljs-keyword">is</span> <span class="hljs-number">3</span>
</code></pre>
<p>지금 이유를 알 것 같아요 :)</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>LaunchedEffect</h1>
<p>LaunchedEffect은 별도의 코루틴 스코프에서 부작용을 실행하는 Composable 함수입니다. 이 함수는 UI 스레드를 차단하지 않고 네트워크 호출 또는 애니메이션과 같은 오랜 시간이 걸리는 작업을 실행하는데 유용합니다.</p>
<p>아래는 LaunchedEffect를 사용하는 예시입니다:</p>
<pre><code class="hljs language-kt"><span class="hljs-meta">@Composable</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">MyComposable</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">val</span> isLoading = remember { mutableStateOf(<span class="hljs-literal">false</span>) }
    <span class="hljs-keyword">val</span> <span class="hljs-keyword">data</span> = remember { mutableStateOf(listOf&#x3C;String>()) }

    <span class="hljs-comment">// LaunchedEffect를 정의하여 오랜 시간 동안 비동기적으로 작업을 수행합니다</span>
    <span class="hljs-comment">// `isLoading.value`가 변경될 때마다 `LaunchedEffect`가 취소되고 다시 시작됩니다</span>
    LaunchedEffect(isLoading.value) {
        <span class="hljs-keyword">if</span> (isLoading.value) {
            <span class="hljs-comment">// 네트워크에서 데이터를 가져오는 등 오랜 시간 동안 실행해야 할 작업을 수행합니다</span>
            <span class="hljs-keyword">val</span> newData = fetchData()
            <span class="hljs-comment">// 새 데이터로 상태를 업데이트합니다</span>
            <span class="hljs-keyword">data</span>.value = newData
            isLoading.value = <span class="hljs-literal">false</span>
        }
    }

    Column {
        Button(onClick = { isLoading.value = <span class="hljs-literal">true</span> }) {
            Text(<span class="hljs-string">"데이터 가져오기"</span>)
        }
        <span class="hljs-keyword">if</span> (isLoading.value) {
            <span class="hljs-comment">// 로딩 인디케이터를 표시합니다</span>
            CircularProgressIndicator()
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// 데이터를 표시합니다</span>
            LazyColumn {
                items(<span class="hljs-keyword">data</span>.value.size) { index ->
                    Text(text = <span class="hljs-keyword">data</span>.value[index])
                }
            }
        }
    }
}

<span class="hljs-comment">// 2초 동안 코루틴을 일시 중단하여 네트워크 호출 시뮬레이션</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">fetchData</span><span class="hljs-params">()</span></span>: List&#x3C;String> {
    <span class="hljs-comment">// 네트워크 지연 시간을 시뮬레이션합니다</span>
    delay(<span class="hljs-number">2000</span>)
    <span class="hljs-keyword">return</span> listOf(<span class="hljs-string">"항목 1"</span>, <span class="hljs-string">"항목 2"</span>, <span class="hljs-string">"항목 3"</span>, <span class="hljs-string">"항목 4"</span>, <span class="hljs-string">"항목 5"</span>,)
}
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이 예시에서 LaunchedEffect 함수는 isLoading 상태 변수가 true로 설정될 때 네트워크 호출을 실행하여 API에서 데이터를 가져옵니다. 이 함수는 별도의 코루틴 스코프에서 실행되므로 작업이 수행되는 동안 UI가 반응할 수 있게 유지됩니다.</p>
<p>LaunchedEffect 함수는 두 개의 매개변수를 사용합니다: key는 isLoading.value로 설정되고 block은 실행할 부작용을 정의하는 람다입니다. 이 경우 block 람다는 fetchData() 함수를 호출하며, 이 함수는 코루틴을 2초 동안 일시 중단하여 네트워크 호출을 시뮬레이트합니다. 데이터를 가져오면 데이터 상태 변수를 업데이트하고 isLoading을 false로 설정하여 로딩 지시자를 숨기고 가져온 데이터를 표시합니다.</p>
<h2>key 매개변수 뒤의 논리는 무엇인가요?</h2>
<p>LaunchedEffect에서 key 매개변수는 LaunchedEffect 인스턴스를 식별하고 불필요하게 recompose되지 않도록 방지하는 데 사용됩니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>컴포저가 recomposed될 때, Jetpack Compose는 다시 그려야 하는지 여부를 결정합니다. 만약 Composable의 상태나 프로퍼티가 변경되었거나 Composable이 invalidate를 호출했다면, Jetpack Compose는 Composable을 다시 그릴 것입니다. Composable을 다시 그리는 것은 비용이 많이 드는 작업일 수 있습니다. 특히 Composable에 장기 실행 작업이 포함되어 있거나 매번 recomposed될 때마다 다시 실행할 필요가 없는 부작용이 있는 경우에도 그렇습니다.</p>
<p>LaunchedEffect에 key 매개변수를 제공함으로써, LaunchedEffect 인스턴스를 고유하게 식별하는 값을 지정할 수 있습니다. key 매개변수의 값이 변경되면, Jetpack Compose는 LaunchedEffect 인스턴스를 새로운 인스턴스로 간주하고 부작용을 다시 실행할 것입니다. key 매개변수의 값이 동일하면, Jetpack Compose는 부작용의 실행을 건너뛰고 이전 결과를 재사용하여 불필요한 recomposition을 방지할 것입니다.</p>
<p>LaunchedEffect에 여러 키를 사용할 수도 있습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// LaunchedEffect에 임의의 UUID를 키로 사용합니다</span>
val key = remember { <span class="hljs-variable constant_">UUID</span>.<span class="hljs-title function_">randomUUID</span>().<span class="hljs-title function_">toString</span>() }

<span class="hljs-title class_">LaunchedEffect</span>(key, isLoading.<span class="hljs-property">value</span>) {
  ....
}
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>DisposableEffect</h1>
<p>DisposableEffect은 부모 Composable이 처음으로 렌더링될 때 사이드 이펙트를 실행하고, Composable이 UI 계층구조에서 제거될 때 효과를 삭제하는 Composable 함수입니다. 이 함수는 이벤트 리스너나 애니메이션과 같이 Composable이 더 이상 사용되지 않을 때 정리해야 하는 리소스를 관리하는 데 유용합니다.</p>
<p>다음은 DisposableEffect를 사용하는 예시입니다:</p>
<pre><code class="hljs language-js">@<span class="hljs-title class_">Composable</span>
fun <span class="hljs-title class_">TimerScreen</span>() {
    val elapsedTime = remember { <span class="hljs-title function_">mutableStateOf</span>(<span class="hljs-number">0</span>) }

    <span class="hljs-title class_">DisposableEffect</span>(<span class="hljs-title class_">Unit</span>) {
        val scope = <span class="hljs-title class_">CoroutineScope</span>(<span class="hljs-title class_">Dispatchers</span>.<span class="hljs-property">Default</span>)
        val job = scope.<span class="hljs-property">launch</span> {
            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
                <span class="hljs-title function_">delay</span>(<span class="hljs-number">1000</span>)
                elapsedTime.<span class="hljs-property">value</span> += <span class="hljs-number">1</span>
                <span class="hljs-title function_">log</span>(<span class="hljs-string">"Timer is still working ${elapsedTime.value}"</span>)
            }
        }

        onDispose {
            job.<span class="hljs-title function_">cancel</span>()
        }
    }

    <span class="hljs-title class_">Text</span>(
        text = <span class="hljs-string">"Elapsed Time: ${elapsedTime.value}"</span>,
        modifier = <span class="hljs-title class_">Modifier</span>.<span class="hljs-title function_">padding</span>(<span class="hljs-number">16.</span>dp),
        fontSize = <span class="hljs-number">24.</span>sp
    )
}
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이 코드에서는 DisposableEffect를 사용하여 매 초마다 elapsedTime 상태 값을 증가시키는 코루틴을 실행합니다. 또한 DisposableEffect를 사용하여 Composable이 사용되지 않을 때 코루틴이 취소되고 코루틴에서 사용하는 리소스가 정리되도록 합니다.</p>
<p>DisposableEffect의 정리 함수에서 우리는 job에 저장된 Job 인스턴스의 cancel() 메서드를 사용하여 코루틴을 취소합니다.</p>
<p>onDispose 함수는 Composable이 UI 계층에서 제거될 때 호출되며, Composable에서 사용된 모든 리소스를 정리하는 방법을 제공합니다. 이 경우에는 onDispose를 사용하여 코루틴을 취소하고 코루틴에서 사용하는 모든 리소스가 정리되도록 합니다.</p>
<p>이 DisposableEffect가 작동하는 방법을 확인하려면 다음 코드를 실행하여 결과를 확인해보세요:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-kotlin"><span class="hljs-meta">@Composable</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">RunTimerScreen</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">val</span> isVisible = remember { mutableStateOf(<span class="hljs-literal">true</span>) }

    Column(
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.Bottom
    ) {
        Spacer(modifier = Modifier.height(<span class="hljs-number">10.</span>dp))

        <span class="hljs-keyword">if</span> (isVisible.value)
            TimerScreen()

        Button(onClick = { isVisible.value = <span class="hljs-literal">false</span> }) {
           Text(<span class="hljs-string">"타이머 숨기기"</span>)
        }
    }
}
</code></pre>
<p>새로운 RunTimerScreen Composable을 추가했습니다. 이를 통해 사용자는 TimerScreen의 가시성을 토글할 수 있습니다. 사용자가 "타이머 숨기기" 버튼을 클릭하면 TimerScreen Composable이 UI 계층에서 제거되고 코루틴이 취소되고 정리됩니다.</p>
<p>onDispose 함수에서 job.cancel() 호출을 제거하면, TimerScreen Composable이 더 이상 사용되지 않더라도 코루틴이 계속 실행되어 메모리 누수 및 다른 성능 문제를 야기할 수 있습니다.</p>
<p>DisposableEffect와 CoroutineScope를 이렇게 함께 사용함으로써, CoroutineScope에서 시작된 코루틴이 TimerScreen Composable이 더 이상 사용되지 않을 때 취소되고 리소스가 정리되도록 합니다. 이를 통해 메모리 누수 및 다른 성능 문제를 방지하고 앱의 성능과 안정성을 향상시킬 수 있습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>각각 사용하는 시기</h1>
<p>DisposableEffect 사용 사례</p>
<ul>
<li>이벤트 리스너 추가 및 제거</li>
<li>애니메이션 시작 및 중지</li>
<li>카메라, 위치 관리자 등과 같은 센서 자원 바인딩 및 언바인딩</li>
<li>데이터베이스 연결 관리</li>
</ul>
<p>LaunchedEffect 사용 사례</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>네트워크로부터 데이터 가져오기</li>
<li>이미지 처리 수행</li>
<li>데이터베이스 업데이트</li>
</ul>
<p>SideEffect의 사용 사례</p>
<ul>
<li>로깅 및 분석</li>
<li>블루투스 장치에 연결 설정, 파일에서 데이터 불러오기 또는 라이브러리 초기화와 같은 일회성 초기화 수행.</li>
</ul>
<p>한 번 설정할 때 SideEffect를 사용하는 예시:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-kotlin"><span class="hljs-meta">@Composable</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">MyComposable</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">val</span> isInitialized = remember { mutableStateOf(<span class="hljs-literal">false</span>) }

    SideEffect {
        <span class="hljs-keyword">if</span> (!isInitialized.value) {
            <span class="hljs-comment">// 여기에 일회성 초기화 작업 실행</span>
            initializeBluetooth()
            loadDataFromFile()
            initializeLibrary()

            isInitialized.value = <span class="hljs-literal">true</span>
        }
    }

    <span class="hljs-comment">// UI 코드 여기에 작성</span>
}
</code></pre>
<h1>요약</h1>
<p>SideEffect, DisposableEffect 및 LaunchedEffect 간의 차이 요약:</p>
<ul>
<li>SideEffect는 부모 Composable이 recomposed될 때 실행되며, Composable의 상태나 props에 의존하지 않는 작업을 실행하는 데 유용합니다.</li>
<li>DisposableEffect는 부모 Composable이 처음 렌더링될 때 실행되며, Composable이 더 이상 사용되지 않을 때 정리해야하는 리소스를 관리하는 데 유용합니다. 첫 번째 구성 또는 키 변경시 트리거되며, 종료시 onDispose 메서드를 호출합니다.</li>
<li>LaunchedEffect는 별도의 코루틴 스코프에서 부작용을 실행하며, UI 스레드를 블로킹하지 않고 긴 작업을 실행하는 데 유용합니다. 첫 번째 구성 또는 키 변경시 트리거됩니다.</li>
</ul>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"젯팩 컴포즈 부가 효과 자세히 알아보기","description":"","date":"2024-05-27 16:11","slug":"2024-05-27-JetpackComposeSideEffectsinDetails","content":"\n![Jetpack Compose](/assets/img/2024-05-27-JetpackComposeSideEffectsinDetails_0.png)\n\nJetpack Compose는 Android에서 UI 개발을 훨씬 쉽게 만들었지만, UI 효과를 효율적으로 관리하는 방법을 이해하는 것이 성능 향상에 매우 중요합니다. 본 문서에서는 UI 효과를 효과적으로 관리하는 데 도움이 되는 세 가지 중요한 Composable 함수인 SideEffect, LaunchedEffect 및 DisposableEffect을 살펴보겠습니다.\n\n# 왜 부작용(side-effect)이 필요한가요?\n\nJetpack Compose에서 부작용의 목적은 Composable 함수 외부에서 앱의 상태를 변경하는 UI와 관련 없는 작업을 제어 가능하고 예측 가능한 방식으로 실행할 수 있게 하는 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n부작용은 데이터베이스 업데이트나 네트워크 호출과 같은 작업을 UI 렌더링 로직과 분리하여 코드의 성능과 유지 보수성을 향상시켜야 합니다.\n\n젯팩 컴포즈는 SideEffect, LaunchedEffect, DisposableEffect와 같은 여러 컴포저블 함수를 제공하여 개발자가 사이드 이펙트를 효과적으로 관리할 수 있도록 해줍니다. 이를 통해 UI 렌더링 로직과 분리하고 별도의 코루틴 범위에서 실행함으로써 사이드 이펙트를 처리할 수 있습니다.\n\n젯팩 컴포즈에서 사이드 이펙트를 사용하는 주요 이점은 다음과 같습니다:\n\n- 성능 향상: 비 UI 관련 작업을 컴포저블 함수 외부에서 실행함으로써 UI 렌더링 로직이 반응성이 있고 성능이 좋아집니다.\n- 코드 구성 개선: UI 렌더링 로직에서 비 UI 관련 작업을 분리함으로써 코드베이스가 이해하기 쉬워지고 유지 보수가 용이해집니다.\n- 디버깅 개선: 사이드 이펙트는 로깅 및 분석 작업에 사용될 수 있으며, 이를 통해 개발자가 앱의 동작을 더 잘 이해하고 문제점을 식별할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n요약하면 Jetpack Compose에서의 부작용의 목적은 UI 렌더링 로직에서 UI와 상관없는 작업을 분리함으로써 코드베이스의 성능, 유지 관리 및 디버깅을 개선하는 것입니다.\n\n## SideEffect\n\nSideEffect는 부모 Composable이 recomposed될 때 부작용을 실행할 수 있게 해주는 Composable 함수입니다. 부작용이란 직접적으로 UI에 영향을 주지 않는 작업으로, 로깅, 분석 또는 외부 상태 갱신과 같은 작업을 의미합니다. 이 함수는 Composable의 상태나 props에 의존하지 않는 작업을 실행하는 데 유용합니다.\n\nComposable이 recomposed되면 Composable 함수 내의 모든 코드가 다시 실행되며, 이 과정에서 모든 부작용도 다시 실행됩니다. 그러나 UI는 Composable의 상태나 props에 대한 변경 사항만 반영하여 업데이트됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# SideEffect를 사용하는 방법\n\nSideEffect를 사용하려면 Composable 함수 내부에서 호출하고 실행하려는 사이드 이펙트를 포함한 람다를 전달해야 합니다. 다음은 예시입니다:\n\n```js\n@Composable\nfun Counter() {\n    // Count를 위한 상태 변수 정의\n    val count = remember { mutableStateOf(0) }\n\n    // SideEffect를 사용하여 count 변수의 현재 값 로깅\n    SideEffect {\n        // 재구성할 때마다 호출됨\n        log(\"Count is ${count.value}\")\n    }\n\n    Column {\n        Button(onClick = { count.value++ }) {\n            Text(\"Increase Count\")\n        }\n\n        // 상태가 업데이트될 때마다 텍스트가 변경되고 재구성이 트리거됩니다\n        Text(\"Counter ${count.value}\")\n    }\n}\n```\n\n이 예시에서 SideEffect 함수는 Counter 함수가 재구성될 때마다 count 상태 변수의 현재 값이 로깅됩니다. 이는 디버깅 및 Composable 동작 모니터링에 유용합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n현재 Composable 함수가 recomposed될 때만 부작용이 발생합니다. 중첩된 Composable 함수에는 해당되지 않습니다. 즉, 다른 Composable 함수를 호출하는 Composable 함수가 있는 경우, 내부 Composable 함수가 recomposed될 때 외부 Composable 함수의 SideEffect가 트리거되지 않습니다. 이를 이해하기 위해 코드를 다음과 같이 변경해보겠습니다:\n\n```js\n@Composable\nfun Counter() {\n    // count를 위한 상태 변수 정의\n    val count = remember { mutableStateOf(0) }\n\n    // count의 현재 값 로그 남기기 위해 SideEffect 사용\n    SideEffect {\n        // 재구성마다 호출됨\n        log(\"Count is ${count.value}\")\n    }\n\n    Column {\n        Button(onClick = { count.value++ }) {\n            // 버튼이 탭될 때마다 바깥쪽 부작용이 트리거되지 않음\n            // 매번 버튼이 탭될 때마다 Text가 recompose됨\n            Text(\"Increase Count ${count.value}\")\n        }\n    }\n}\n```\n\n위의 코드에서 앱이 처음 시작될 때, Counter Composable 함수가 compose되고 SideEffect가 count의 초기 값으로 console에 로그를 남깁니다. 버튼을 클릭하면 Text Composable이 count의 새 값으로 recompose되지만, 이는 SideEffect를 다시 트리거하지 않습니다.\n\n이제 이 작동 방식을 보기 위해 inner side effect를 추가해봅시다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\n@Composable\nfun Counter() {\n    // 카운트를 위한 상태 변수 정의\n    val count = remember { mutableStateOf(0) }\n\n    // SideEffect를 사용하여 count의 현재 값 로깅\n    SideEffect {\n        // 재구성마다 호출\n        log(\"Outer Count is ${count.value}\")\n    }\n\n    Column {\n        Button(onClick = { count.value++ }) {\n            // SideEffect를 사용하여 count의 현재 값 로깅\n            SideEffect {\n                // 재구성마다 호출\n                log(\"Inner Count is ${count.value}\")\n            }\n\n            // 이 재구성은 버튼을 누를 때마다\n            // 외부 SideEffect를 계속해서 트리거하지 않습니다\n            Text(\"Increase Count ${count.value}\")\n        }\n    }\n}\n```\n\n위의 코드를 사용하여 버튼을 클릭하면 출력 결과가 다음과 같이 나타납니다:\n\n```kotlin\nOuter Count is 0\nInner Count is 0\nInner Count is 1\nInner Count is 2\nInner Count is 3\n```\n\n지금 이유를 알 것 같아요 :)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# LaunchedEffect\n\nLaunchedEffect은 별도의 코루틴 스코프에서 부작용을 실행하는 Composable 함수입니다. 이 함수는 UI 스레드를 차단하지 않고 네트워크 호출 또는 애니메이션과 같은 오랜 시간이 걸리는 작업을 실행하는데 유용합니다.\n\n아래는 LaunchedEffect를 사용하는 예시입니다:\n\n```kt\n@Composable\nfun MyComposable() {\n    val isLoading = remember { mutableStateOf(false) }\n    val data = remember { mutableStateOf(listOf\u003cString\u003e()) }\n\n    // LaunchedEffect를 정의하여 오랜 시간 동안 비동기적으로 작업을 수행합니다\n    // `isLoading.value`가 변경될 때마다 `LaunchedEffect`가 취소되고 다시 시작됩니다\n    LaunchedEffect(isLoading.value) {\n        if (isLoading.value) {\n            // 네트워크에서 데이터를 가져오는 등 오랜 시간 동안 실행해야 할 작업을 수행합니다\n            val newData = fetchData()\n            // 새 데이터로 상태를 업데이트합니다\n            data.value = newData\n            isLoading.value = false\n        }\n    }\n\n    Column {\n        Button(onClick = { isLoading.value = true }) {\n            Text(\"데이터 가져오기\")\n        }\n        if (isLoading.value) {\n            // 로딩 인디케이터를 표시합니다\n            CircularProgressIndicator()\n        } else {\n            // 데이터를 표시합니다\n            LazyColumn {\n                items(data.value.size) { index -\u003e\n                    Text(text = data.value[index])\n                }\n            }\n        }\n    }\n}\n\n// 2초 동안 코루틴을 일시 중단하여 네트워크 호출 시뮬레이션\nprivate suspend fun fetchData(): List\u003cString\u003e {\n    // 네트워크 지연 시간을 시뮬레이션합니다\n    delay(2000)\n    return listOf(\"항목 1\", \"항목 2\", \"항목 3\", \"항목 4\", \"항목 5\",)\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 예시에서 LaunchedEffect 함수는 isLoading 상태 변수가 true로 설정될 때 네트워크 호출을 실행하여 API에서 데이터를 가져옵니다. 이 함수는 별도의 코루틴 스코프에서 실행되므로 작업이 수행되는 동안 UI가 반응할 수 있게 유지됩니다.\n\nLaunchedEffect 함수는 두 개의 매개변수를 사용합니다: key는 isLoading.value로 설정되고 block은 실행할 부작용을 정의하는 람다입니다. 이 경우 block 람다는 fetchData() 함수를 호출하며, 이 함수는 코루틴을 2초 동안 일시 중단하여 네트워크 호출을 시뮬레이트합니다. 데이터를 가져오면 데이터 상태 변수를 업데이트하고 isLoading을 false로 설정하여 로딩 지시자를 숨기고 가져온 데이터를 표시합니다.\n\n## key 매개변수 뒤의 논리는 무엇인가요?\n\nLaunchedEffect에서 key 매개변수는 LaunchedEffect 인스턴스를 식별하고 불필요하게 recompose되지 않도록 방지하는 데 사용됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n컴포저가 recomposed될 때, Jetpack Compose는 다시 그려야 하는지 여부를 결정합니다. 만약 Composable의 상태나 프로퍼티가 변경되었거나 Composable이 invalidate를 호출했다면, Jetpack Compose는 Composable을 다시 그릴 것입니다. Composable을 다시 그리는 것은 비용이 많이 드는 작업일 수 있습니다. 특히 Composable에 장기 실행 작업이 포함되어 있거나 매번 recomposed될 때마다 다시 실행할 필요가 없는 부작용이 있는 경우에도 그렇습니다.\n\nLaunchedEffect에 key 매개변수를 제공함으로써, LaunchedEffect 인스턴스를 고유하게 식별하는 값을 지정할 수 있습니다. key 매개변수의 값이 변경되면, Jetpack Compose는 LaunchedEffect 인스턴스를 새로운 인스턴스로 간주하고 부작용을 다시 실행할 것입니다. key 매개변수의 값이 동일하면, Jetpack Compose는 부작용의 실행을 건너뛰고 이전 결과를 재사용하여 불필요한 recomposition을 방지할 것입니다.\n\nLaunchedEffect에 여러 키를 사용할 수도 있습니다:\n\n```js\n// LaunchedEffect에 임의의 UUID를 키로 사용합니다\nval key = remember { UUID.randomUUID().toString() }\n\nLaunchedEffect(key, isLoading.value) {\n  ....\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# DisposableEffect\n\nDisposableEffect은 부모 Composable이 처음으로 렌더링될 때 사이드 이펙트를 실행하고, Composable이 UI 계층구조에서 제거될 때 효과를 삭제하는 Composable 함수입니다. 이 함수는 이벤트 리스너나 애니메이션과 같이 Composable이 더 이상 사용되지 않을 때 정리해야 하는 리소스를 관리하는 데 유용합니다.\n\n다음은 DisposableEffect를 사용하는 예시입니다:\n\n```js\n@Composable\nfun TimerScreen() {\n    val elapsedTime = remember { mutableStateOf(0) }\n\n    DisposableEffect(Unit) {\n        val scope = CoroutineScope(Dispatchers.Default)\n        val job = scope.launch {\n            while (true) {\n                delay(1000)\n                elapsedTime.value += 1\n                log(\"Timer is still working ${elapsedTime.value}\")\n            }\n        }\n\n        onDispose {\n            job.cancel()\n        }\n    }\n\n    Text(\n        text = \"Elapsed Time: ${elapsedTime.value}\",\n        modifier = Modifier.padding(16.dp),\n        fontSize = 24.sp\n    )\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 코드에서는 DisposableEffect를 사용하여 매 초마다 elapsedTime 상태 값을 증가시키는 코루틴을 실행합니다. 또한 DisposableEffect를 사용하여 Composable이 사용되지 않을 때 코루틴이 취소되고 코루틴에서 사용하는 리소스가 정리되도록 합니다.\n\nDisposableEffect의 정리 함수에서 우리는 job에 저장된 Job 인스턴스의 cancel() 메서드를 사용하여 코루틴을 취소합니다.\n\nonDispose 함수는 Composable이 UI 계층에서 제거될 때 호출되며, Composable에서 사용된 모든 리소스를 정리하는 방법을 제공합니다. 이 경우에는 onDispose를 사용하여 코루틴을 취소하고 코루틴에서 사용하는 모든 리소스가 정리되도록 합니다.\n\n이 DisposableEffect가 작동하는 방법을 확인하려면 다음 코드를 실행하여 결과를 확인해보세요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\n@Composable\nfun RunTimerScreen() {\n    val isVisible = remember { mutableStateOf(true) }\n\n    Column(\n        horizontalAlignment = Alignment.CenterHorizontally,\n        verticalArrangement = Arrangement.Bottom\n    ) {\n        Spacer(modifier = Modifier.height(10.dp))\n\n        if (isVisible.value)\n            TimerScreen()\n\n        Button(onClick = { isVisible.value = false }) {\n           Text(\"타이머 숨기기\")\n        }\n    }\n}\n```\n\n새로운 RunTimerScreen Composable을 추가했습니다. 이를 통해 사용자는 TimerScreen의 가시성을 토글할 수 있습니다. 사용자가 \"타이머 숨기기\" 버튼을 클릭하면 TimerScreen Composable이 UI 계층에서 제거되고 코루틴이 취소되고 정리됩니다.\n\nonDispose 함수에서 job.cancel() 호출을 제거하면, TimerScreen Composable이 더 이상 사용되지 않더라도 코루틴이 계속 실행되어 메모리 누수 및 다른 성능 문제를 야기할 수 있습니다.\n\nDisposableEffect와 CoroutineScope를 이렇게 함께 사용함으로써, CoroutineScope에서 시작된 코루틴이 TimerScreen Composable이 더 이상 사용되지 않을 때 취소되고 리소스가 정리되도록 합니다. 이를 통해 메모리 누수 및 다른 성능 문제를 방지하고 앱의 성능과 안정성을 향상시킬 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 각각 사용하는 시기\n\nDisposableEffect 사용 사례\n\n- 이벤트 리스너 추가 및 제거\n- 애니메이션 시작 및 중지\n- 카메라, 위치 관리자 등과 같은 센서 자원 바인딩 및 언바인딩\n- 데이터베이스 연결 관리\n\nLaunchedEffect 사용 사례\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 네트워크로부터 데이터 가져오기\n- 이미지 처리 수행\n- 데이터베이스 업데이트\n\nSideEffect의 사용 사례\n\n- 로깅 및 분석\n- 블루투스 장치에 연결 설정, 파일에서 데이터 불러오기 또는 라이브러리 초기화와 같은 일회성 초기화 수행.\n\n한 번 설정할 때 SideEffect를 사용하는 예시:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\n@Composable\nfun MyComposable() {\n    val isInitialized = remember { mutableStateOf(false) }\n\n    SideEffect {\n        if (!isInitialized.value) {\n            // 여기에 일회성 초기화 작업 실행\n            initializeBluetooth()\n            loadDataFromFile()\n            initializeLibrary()\n\n            isInitialized.value = true\n        }\n    }\n\n    // UI 코드 여기에 작성\n}\n```\n\n# 요약\n\nSideEffect, DisposableEffect 및 LaunchedEffect 간의 차이 요약:\n\n- SideEffect는 부모 Composable이 recomposed될 때 실행되며, Composable의 상태나 props에 의존하지 않는 작업을 실행하는 데 유용합니다.\n- DisposableEffect는 부모 Composable이 처음 렌더링될 때 실행되며, Composable이 더 이상 사용되지 않을 때 정리해야하는 리소스를 관리하는 데 유용합니다. 첫 번째 구성 또는 키 변경시 트리거되며, 종료시 onDispose 메서드를 호출합니다.\n- LaunchedEffect는 별도의 코루틴 스코프에서 부작용을 실행하며, UI 스레드를 블로킹하지 않고 긴 작업을 실행하는 데 유용합니다. 첫 번째 구성 또는 키 변경시 트리거됩니다.\n","ogImage":{"url":"/assets/img/2024-05-27-JetpackComposeSideEffectsinDetails_0.png"},"coverImage":"/assets/img/2024-05-27-JetpackComposeSideEffectsinDetails_0.png","tag":["Tech"],"readingTime":14},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-27-JetpackComposeSideEffectsinDetails_0.png\" alt=\"Jetpack Compose\"\u003e\u003c/p\u003e\n\u003cp\u003eJetpack Compose는 Android에서 UI 개발을 훨씬 쉽게 만들었지만, UI 효과를 효율적으로 관리하는 방법을 이해하는 것이 성능 향상에 매우 중요합니다. 본 문서에서는 UI 효과를 효과적으로 관리하는 데 도움이 되는 세 가지 중요한 Composable 함수인 SideEffect, LaunchedEffect 및 DisposableEffect을 살펴보겠습니다.\u003c/p\u003e\n\u003ch1\u003e왜 부작용(side-effect)이 필요한가요?\u003c/h1\u003e\n\u003cp\u003eJetpack Compose에서 부작용의 목적은 Composable 함수 외부에서 앱의 상태를 변경하는 UI와 관련 없는 작업을 제어 가능하고 예측 가능한 방식으로 실행할 수 있게 하는 것입니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e부작용은 데이터베이스 업데이트나 네트워크 호출과 같은 작업을 UI 렌더링 로직과 분리하여 코드의 성능과 유지 보수성을 향상시켜야 합니다.\u003c/p\u003e\n\u003cp\u003e젯팩 컴포즈는 SideEffect, LaunchedEffect, DisposableEffect와 같은 여러 컴포저블 함수를 제공하여 개발자가 사이드 이펙트를 효과적으로 관리할 수 있도록 해줍니다. 이를 통해 UI 렌더링 로직과 분리하고 별도의 코루틴 범위에서 실행함으로써 사이드 이펙트를 처리할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e젯팩 컴포즈에서 사이드 이펙트를 사용하는 주요 이점은 다음과 같습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e성능 향상: 비 UI 관련 작업을 컴포저블 함수 외부에서 실행함으로써 UI 렌더링 로직이 반응성이 있고 성능이 좋아집니다.\u003c/li\u003e\n\u003cli\u003e코드 구성 개선: UI 렌더링 로직에서 비 UI 관련 작업을 분리함으로써 코드베이스가 이해하기 쉬워지고 유지 보수가 용이해집니다.\u003c/li\u003e\n\u003cli\u003e디버깅 개선: 사이드 이펙트는 로깅 및 분석 작업에 사용될 수 있으며, 이를 통해 개발자가 앱의 동작을 더 잘 이해하고 문제점을 식별할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e요약하면 Jetpack Compose에서의 부작용의 목적은 UI 렌더링 로직에서 UI와 상관없는 작업을 분리함으로써 코드베이스의 성능, 유지 관리 및 디버깅을 개선하는 것입니다.\u003c/p\u003e\n\u003ch2\u003eSideEffect\u003c/h2\u003e\n\u003cp\u003eSideEffect는 부모 Composable이 recomposed될 때 부작용을 실행할 수 있게 해주는 Composable 함수입니다. 부작용이란 직접적으로 UI에 영향을 주지 않는 작업으로, 로깅, 분석 또는 외부 상태 갱신과 같은 작업을 의미합니다. 이 함수는 Composable의 상태나 props에 의존하지 않는 작업을 실행하는 데 유용합니다.\u003c/p\u003e\n\u003cp\u003eComposable이 recomposed되면 Composable 함수 내의 모든 코드가 다시 실행되며, 이 과정에서 모든 부작용도 다시 실행됩니다. 그러나 UI는 Composable의 상태나 props에 대한 변경 사항만 반영하여 업데이트됩니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003eSideEffect를 사용하는 방법\u003c/h1\u003e\n\u003cp\u003eSideEffect를 사용하려면 Composable 함수 내부에서 호출하고 실행하려는 사이드 이펙트를 포함한 람다를 전달해야 합니다. 다음은 예시입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e@\u003cspan class=\"hljs-title class_\"\u003eComposable\u003c/span\u003e\nfun \u003cspan class=\"hljs-title class_\"\u003eCounter\u003c/span\u003e() {\n    \u003cspan class=\"hljs-comment\"\u003e// Count를 위한 상태 변수 정의\u003c/span\u003e\n    val count = remember { \u003cspan class=\"hljs-title function_\"\u003emutableStateOf\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e) }\n\n    \u003cspan class=\"hljs-comment\"\u003e// SideEffect를 사용하여 count 변수의 현재 값 로깅\u003c/span\u003e\n    \u003cspan class=\"hljs-title class_\"\u003eSideEffect\u003c/span\u003e {\n        \u003cspan class=\"hljs-comment\"\u003e// 재구성할 때마다 호출됨\u003c/span\u003e\n        \u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Count is ${count.value}\"\u003c/span\u003e)\n    }\n\n    \u003cspan class=\"hljs-title class_\"\u003eColumn\u003c/span\u003e {\n        \u003cspan class=\"hljs-title class_\"\u003eButton\u003c/span\u003e(onClick = { count.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e++ }) {\n            \u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Increase Count\"\u003c/span\u003e)\n        }\n\n        \u003cspan class=\"hljs-comment\"\u003e// 상태가 업데이트될 때마다 텍스트가 변경되고 재구성이 트리거됩니다\u003c/span\u003e\n        \u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Counter ${count.value}\"\u003c/span\u003e)\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 예시에서 SideEffect 함수는 Counter 함수가 재구성될 때마다 count 상태 변수의 현재 값이 로깅됩니다. 이는 디버깅 및 Composable 동작 모니터링에 유용합니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e현재 Composable 함수가 recomposed될 때만 부작용이 발생합니다. 중첩된 Composable 함수에는 해당되지 않습니다. 즉, 다른 Composable 함수를 호출하는 Composable 함수가 있는 경우, 내부 Composable 함수가 recomposed될 때 외부 Composable 함수의 SideEffect가 트리거되지 않습니다. 이를 이해하기 위해 코드를 다음과 같이 변경해보겠습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e@\u003cspan class=\"hljs-title class_\"\u003eComposable\u003c/span\u003e\nfun \u003cspan class=\"hljs-title class_\"\u003eCounter\u003c/span\u003e() {\n    \u003cspan class=\"hljs-comment\"\u003e// count를 위한 상태 변수 정의\u003c/span\u003e\n    val count = remember { \u003cspan class=\"hljs-title function_\"\u003emutableStateOf\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e) }\n\n    \u003cspan class=\"hljs-comment\"\u003e// count의 현재 값 로그 남기기 위해 SideEffect 사용\u003c/span\u003e\n    \u003cspan class=\"hljs-title class_\"\u003eSideEffect\u003c/span\u003e {\n        \u003cspan class=\"hljs-comment\"\u003e// 재구성마다 호출됨\u003c/span\u003e\n        \u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Count is ${count.value}\"\u003c/span\u003e)\n    }\n\n    \u003cspan class=\"hljs-title class_\"\u003eColumn\u003c/span\u003e {\n        \u003cspan class=\"hljs-title class_\"\u003eButton\u003c/span\u003e(onClick = { count.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e++ }) {\n            \u003cspan class=\"hljs-comment\"\u003e// 버튼이 탭될 때마다 바깥쪽 부작용이 트리거되지 않음\u003c/span\u003e\n            \u003cspan class=\"hljs-comment\"\u003e// 매번 버튼이 탭될 때마다 Text가 recompose됨\u003c/span\u003e\n            \u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Increase Count ${count.value}\"\u003c/span\u003e)\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위의 코드에서 앱이 처음 시작될 때, Counter Composable 함수가 compose되고 SideEffect가 count의 초기 값으로 console에 로그를 남깁니다. 버튼을 클릭하면 Text Composable이 count의 새 값으로 recompose되지만, 이는 SideEffect를 다시 트리거하지 않습니다.\u003c/p\u003e\n\u003cp\u003e이제 이 작동 방식을 보기 위해 inner side effect를 추가해봅시다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-kotlin\"\u003e\u003cspan class=\"hljs-meta\"\u003e@Composable\u003c/span\u003e\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efun\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eCounter\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-comment\"\u003e// 카운트를 위한 상태 변수 정의\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e count = remember { mutableStateOf(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e) }\n\n    \u003cspan class=\"hljs-comment\"\u003e// SideEffect를 사용하여 count의 현재 값 로깅\u003c/span\u003e\n    SideEffect {\n        \u003cspan class=\"hljs-comment\"\u003e// 재구성마다 호출\u003c/span\u003e\n        log(\u003cspan class=\"hljs-string\"\u003e\"Outer Count is \u003cspan class=\"hljs-subst\"\u003e${count.value}\u003c/span\u003e\"\u003c/span\u003e)\n    }\n\n    Column {\n        Button(onClick = { count.value++ }) {\n            \u003cspan class=\"hljs-comment\"\u003e// SideEffect를 사용하여 count의 현재 값 로깅\u003c/span\u003e\n            SideEffect {\n                \u003cspan class=\"hljs-comment\"\u003e// 재구성마다 호출\u003c/span\u003e\n                log(\u003cspan class=\"hljs-string\"\u003e\"Inner Count is \u003cspan class=\"hljs-subst\"\u003e${count.value}\u003c/span\u003e\"\u003c/span\u003e)\n            }\n\n            \u003cspan class=\"hljs-comment\"\u003e// 이 재구성은 버튼을 누를 때마다\u003c/span\u003e\n            \u003cspan class=\"hljs-comment\"\u003e// 외부 SideEffect를 계속해서 트리거하지 않습니다\u003c/span\u003e\n            Text(\u003cspan class=\"hljs-string\"\u003e\"Increase Count \u003cspan class=\"hljs-subst\"\u003e${count.value}\u003c/span\u003e\"\u003c/span\u003e)\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위의 코드를 사용하여 버튼을 클릭하면 출력 결과가 다음과 같이 나타납니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-kotlin\"\u003eOuter Count \u003cspan class=\"hljs-keyword\"\u003eis\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\nInner Count \u003cspan class=\"hljs-keyword\"\u003eis\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\nInner Count \u003cspan class=\"hljs-keyword\"\u003eis\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\nInner Count \u003cspan class=\"hljs-keyword\"\u003eis\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e\nInner Count \u003cspan class=\"hljs-keyword\"\u003eis\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e지금 이유를 알 것 같아요 :)\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003eLaunchedEffect\u003c/h1\u003e\n\u003cp\u003eLaunchedEffect은 별도의 코루틴 스코프에서 부작용을 실행하는 Composable 함수입니다. 이 함수는 UI 스레드를 차단하지 않고 네트워크 호출 또는 애니메이션과 같은 오랜 시간이 걸리는 작업을 실행하는데 유용합니다.\u003c/p\u003e\n\u003cp\u003e아래는 LaunchedEffect를 사용하는 예시입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-kt\"\u003e\u003cspan class=\"hljs-meta\"\u003e@Composable\u003c/span\u003e\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efun\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eMyComposable\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e isLoading = remember { mutableStateOf(\u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e) }\n    \u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edata\u003c/span\u003e = remember { mutableStateOf(listOf\u0026#x3C;String\u003e()) }\n\n    \u003cspan class=\"hljs-comment\"\u003e// LaunchedEffect를 정의하여 오랜 시간 동안 비동기적으로 작업을 수행합니다\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e// `isLoading.value`가 변경될 때마다 `LaunchedEffect`가 취소되고 다시 시작됩니다\u003c/span\u003e\n    LaunchedEffect(isLoading.value) {\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (isLoading.value) {\n            \u003cspan class=\"hljs-comment\"\u003e// 네트워크에서 데이터를 가져오는 등 오랜 시간 동안 실행해야 할 작업을 수행합니다\u003c/span\u003e\n            \u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e newData = fetchData()\n            \u003cspan class=\"hljs-comment\"\u003e// 새 데이터로 상태를 업데이트합니다\u003c/span\u003e\n            \u003cspan class=\"hljs-keyword\"\u003edata\u003c/span\u003e.value = newData\n            isLoading.value = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e\n        }\n    }\n\n    Column {\n        Button(onClick = { isLoading.value = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e }) {\n            Text(\u003cspan class=\"hljs-string\"\u003e\"데이터 가져오기\"\u003c/span\u003e)\n        }\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (isLoading.value) {\n            \u003cspan class=\"hljs-comment\"\u003e// 로딩 인디케이터를 표시합니다\u003c/span\u003e\n            CircularProgressIndicator()\n        } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n            \u003cspan class=\"hljs-comment\"\u003e// 데이터를 표시합니다\u003c/span\u003e\n            LazyColumn {\n                items(\u003cspan class=\"hljs-keyword\"\u003edata\u003c/span\u003e.value.size) { index -\u003e\n                    Text(text = \u003cspan class=\"hljs-keyword\"\u003edata\u003c/span\u003e.value[index])\n                }\n            }\n        }\n    }\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// 2초 동안 코루틴을 일시 중단하여 네트워크 호출 시뮬레이션\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003esuspend\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efun\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003efetchData\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e: List\u0026#x3C;String\u003e {\n    \u003cspan class=\"hljs-comment\"\u003e// 네트워크 지연 시간을 시뮬레이션합니다\u003c/span\u003e\n    delay(\u003cspan class=\"hljs-number\"\u003e2000\u003c/span\u003e)\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e listOf(\u003cspan class=\"hljs-string\"\u003e\"항목 1\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"항목 2\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"항목 3\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"항목 4\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"항목 5\"\u003c/span\u003e,)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이 예시에서 LaunchedEffect 함수는 isLoading 상태 변수가 true로 설정될 때 네트워크 호출을 실행하여 API에서 데이터를 가져옵니다. 이 함수는 별도의 코루틴 스코프에서 실행되므로 작업이 수행되는 동안 UI가 반응할 수 있게 유지됩니다.\u003c/p\u003e\n\u003cp\u003eLaunchedEffect 함수는 두 개의 매개변수를 사용합니다: key는 isLoading.value로 설정되고 block은 실행할 부작용을 정의하는 람다입니다. 이 경우 block 람다는 fetchData() 함수를 호출하며, 이 함수는 코루틴을 2초 동안 일시 중단하여 네트워크 호출을 시뮬레이트합니다. 데이터를 가져오면 데이터 상태 변수를 업데이트하고 isLoading을 false로 설정하여 로딩 지시자를 숨기고 가져온 데이터를 표시합니다.\u003c/p\u003e\n\u003ch2\u003ekey 매개변수 뒤의 논리는 무엇인가요?\u003c/h2\u003e\n\u003cp\u003eLaunchedEffect에서 key 매개변수는 LaunchedEffect 인스턴스를 식별하고 불필요하게 recompose되지 않도록 방지하는 데 사용됩니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e컴포저가 recomposed될 때, Jetpack Compose는 다시 그려야 하는지 여부를 결정합니다. 만약 Composable의 상태나 프로퍼티가 변경되었거나 Composable이 invalidate를 호출했다면, Jetpack Compose는 Composable을 다시 그릴 것입니다. Composable을 다시 그리는 것은 비용이 많이 드는 작업일 수 있습니다. 특히 Composable에 장기 실행 작업이 포함되어 있거나 매번 recomposed될 때마다 다시 실행할 필요가 없는 부작용이 있는 경우에도 그렇습니다.\u003c/p\u003e\n\u003cp\u003eLaunchedEffect에 key 매개변수를 제공함으로써, LaunchedEffect 인스턴스를 고유하게 식별하는 값을 지정할 수 있습니다. key 매개변수의 값이 변경되면, Jetpack Compose는 LaunchedEffect 인스턴스를 새로운 인스턴스로 간주하고 부작용을 다시 실행할 것입니다. key 매개변수의 값이 동일하면, Jetpack Compose는 부작용의 실행을 건너뛰고 이전 결과를 재사용하여 불필요한 recomposition을 방지할 것입니다.\u003c/p\u003e\n\u003cp\u003eLaunchedEffect에 여러 키를 사용할 수도 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// LaunchedEffect에 임의의 UUID를 키로 사용합니다\u003c/span\u003e\nval key = remember { \u003cspan class=\"hljs-variable constant_\"\u003eUUID\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003erandomUUID\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003etoString\u003c/span\u003e() }\n\n\u003cspan class=\"hljs-title class_\"\u003eLaunchedEffect\u003c/span\u003e(key, isLoading.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e) {\n  ....\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003eDisposableEffect\u003c/h1\u003e\n\u003cp\u003eDisposableEffect은 부모 Composable이 처음으로 렌더링될 때 사이드 이펙트를 실행하고, Composable이 UI 계층구조에서 제거될 때 효과를 삭제하는 Composable 함수입니다. 이 함수는 이벤트 리스너나 애니메이션과 같이 Composable이 더 이상 사용되지 않을 때 정리해야 하는 리소스를 관리하는 데 유용합니다.\u003c/p\u003e\n\u003cp\u003e다음은 DisposableEffect를 사용하는 예시입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e@\u003cspan class=\"hljs-title class_\"\u003eComposable\u003c/span\u003e\nfun \u003cspan class=\"hljs-title class_\"\u003eTimerScreen\u003c/span\u003e() {\n    val elapsedTime = remember { \u003cspan class=\"hljs-title function_\"\u003emutableStateOf\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e) }\n\n    \u003cspan class=\"hljs-title class_\"\u003eDisposableEffect\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eUnit\u003c/span\u003e) {\n        val scope = \u003cspan class=\"hljs-title class_\"\u003eCoroutineScope\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eDispatchers\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eDefault\u003c/span\u003e)\n        val job = scope.\u003cspan class=\"hljs-property\"\u003elaunch\u003c/span\u003e {\n            \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e (\u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e) {\n                \u003cspan class=\"hljs-title function_\"\u003edelay\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e)\n                elapsedTime.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e += \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n                \u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Timer is still working ${elapsedTime.value}\"\u003c/span\u003e)\n            }\n        }\n\n        onDispose {\n            job.\u003cspan class=\"hljs-title function_\"\u003ecancel\u003c/span\u003e()\n        }\n    }\n\n    \u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e(\n        text = \u003cspan class=\"hljs-string\"\u003e\"Elapsed Time: ${elapsedTime.value}\"\u003c/span\u003e,\n        modifier = \u003cspan class=\"hljs-title class_\"\u003eModifier\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003epadding\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e16.\u003c/span\u003edp),\n        fontSize = \u003cspan class=\"hljs-number\"\u003e24.\u003c/span\u003esp\n    )\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이 코드에서는 DisposableEffect를 사용하여 매 초마다 elapsedTime 상태 값을 증가시키는 코루틴을 실행합니다. 또한 DisposableEffect를 사용하여 Composable이 사용되지 않을 때 코루틴이 취소되고 코루틴에서 사용하는 리소스가 정리되도록 합니다.\u003c/p\u003e\n\u003cp\u003eDisposableEffect의 정리 함수에서 우리는 job에 저장된 Job 인스턴스의 cancel() 메서드를 사용하여 코루틴을 취소합니다.\u003c/p\u003e\n\u003cp\u003eonDispose 함수는 Composable이 UI 계층에서 제거될 때 호출되며, Composable에서 사용된 모든 리소스를 정리하는 방법을 제공합니다. 이 경우에는 onDispose를 사용하여 코루틴을 취소하고 코루틴에서 사용하는 모든 리소스가 정리되도록 합니다.\u003c/p\u003e\n\u003cp\u003e이 DisposableEffect가 작동하는 방법을 확인하려면 다음 코드를 실행하여 결과를 확인해보세요:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-kotlin\"\u003e\u003cspan class=\"hljs-meta\"\u003e@Composable\u003c/span\u003e\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efun\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eRunTimerScreen\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e isVisible = remember { mutableStateOf(\u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e) }\n\n    Column(\n        horizontalAlignment = Alignment.CenterHorizontally,\n        verticalArrangement = Arrangement.Bottom\n    ) {\n        Spacer(modifier = Modifier.height(\u003cspan class=\"hljs-number\"\u003e10.\u003c/span\u003edp))\n\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (isVisible.value)\n            TimerScreen()\n\n        Button(onClick = { isVisible.value = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e }) {\n           Text(\u003cspan class=\"hljs-string\"\u003e\"타이머 숨기기\"\u003c/span\u003e)\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e새로운 RunTimerScreen Composable을 추가했습니다. 이를 통해 사용자는 TimerScreen의 가시성을 토글할 수 있습니다. 사용자가 \"타이머 숨기기\" 버튼을 클릭하면 TimerScreen Composable이 UI 계층에서 제거되고 코루틴이 취소되고 정리됩니다.\u003c/p\u003e\n\u003cp\u003eonDispose 함수에서 job.cancel() 호출을 제거하면, TimerScreen Composable이 더 이상 사용되지 않더라도 코루틴이 계속 실행되어 메모리 누수 및 다른 성능 문제를 야기할 수 있습니다.\u003c/p\u003e\n\u003cp\u003eDisposableEffect와 CoroutineScope를 이렇게 함께 사용함으로써, CoroutineScope에서 시작된 코루틴이 TimerScreen Composable이 더 이상 사용되지 않을 때 취소되고 리소스가 정리되도록 합니다. 이를 통해 메모리 누수 및 다른 성능 문제를 방지하고 앱의 성능과 안정성을 향상시킬 수 있습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e각각 사용하는 시기\u003c/h1\u003e\n\u003cp\u003eDisposableEffect 사용 사례\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e이벤트 리스너 추가 및 제거\u003c/li\u003e\n\u003cli\u003e애니메이션 시작 및 중지\u003c/li\u003e\n\u003cli\u003e카메라, 위치 관리자 등과 같은 센서 자원 바인딩 및 언바인딩\u003c/li\u003e\n\u003cli\u003e데이터베이스 연결 관리\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eLaunchedEffect 사용 사례\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003e네트워크로부터 데이터 가져오기\u003c/li\u003e\n\u003cli\u003e이미지 처리 수행\u003c/li\u003e\n\u003cli\u003e데이터베이스 업데이트\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSideEffect의 사용 사례\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e로깅 및 분석\u003c/li\u003e\n\u003cli\u003e블루투스 장치에 연결 설정, 파일에서 데이터 불러오기 또는 라이브러리 초기화와 같은 일회성 초기화 수행.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e한 번 설정할 때 SideEffect를 사용하는 예시:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-kotlin\"\u003e\u003cspan class=\"hljs-meta\"\u003e@Composable\u003c/span\u003e\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efun\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eMyComposable\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e isInitialized = remember { mutableStateOf(\u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e) }\n\n    SideEffect {\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!isInitialized.value) {\n            \u003cspan class=\"hljs-comment\"\u003e// 여기에 일회성 초기화 작업 실행\u003c/span\u003e\n            initializeBluetooth()\n            loadDataFromFile()\n            initializeLibrary()\n\n            isInitialized.value = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e\n        }\n    }\n\n    \u003cspan class=\"hljs-comment\"\u003e// UI 코드 여기에 작성\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e요약\u003c/h1\u003e\n\u003cp\u003eSideEffect, DisposableEffect 및 LaunchedEffect 간의 차이 요약:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eSideEffect는 부모 Composable이 recomposed될 때 실행되며, Composable의 상태나 props에 의존하지 않는 작업을 실행하는 데 유용합니다.\u003c/li\u003e\n\u003cli\u003eDisposableEffect는 부모 Composable이 처음 렌더링될 때 실행되며, Composable이 더 이상 사용되지 않을 때 정리해야하는 리소스를 관리하는 데 유용합니다. 첫 번째 구성 또는 키 변경시 트리거되며, 종료시 onDispose 메서드를 호출합니다.\u003c/li\u003e\n\u003cli\u003eLaunchedEffect는 별도의 코루틴 스코프에서 부작용을 실행하며, UI 스레드를 블로킹하지 않고 긴 작업을 실행하는 데 유용합니다. 첫 번째 구성 또는 키 변경시 트리거됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-27-JetpackComposeSideEffectsinDetails"},"buildId":"GsgRekSb--BvxYwv9FPn6","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>