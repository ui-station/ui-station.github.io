<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Terraform을 활용한 Multi-Cloud 관리 마스터하기 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-05-27-MasteringMulti-CloudManagementwithTerraform" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Terraform을 활용한 Multi-Cloud 관리 마스터하기 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="Terraform을 활용한 Multi-Cloud 관리 마스터하기 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-27-MasteringMulti-CloudManagementwithTerraform_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-05-27-MasteringMulti-CloudManagementwithTerraform" data-gatsby-head="true"/><meta name="twitter:title" content="Terraform을 활용한 Multi-Cloud 관리 마스터하기 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-27-MasteringMulti-CloudManagementwithTerraform_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-27 17:46" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-4f7b40c1114f0d09.js" defer=""></script><script src="/_next/static/o1YmnmSuZvAX2O4TI9r41/_buildManifest.js" defer=""></script><script src="/_next/static/o1YmnmSuZvAX2O4TI9r41/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Terraform을 활용한 Multi-Cloud 관리 마스터하기</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Terraform을 활용한 Multi-Cloud 관리 마스터하기" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 27, 2024</span><span class="posts_reading_time__f7YPP">15<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-27-MasteringMulti-CloudManagementwithTerraform&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>여러 공개 클라우드(Azure, AWS, GCP 등)를 사용하면 유연성을 제공하고 비용을 최적화하며 벤더 락인을 줄일 수 있습니다. 그러나 다양한 클라우드 플랫폼 간에 인프라 및 서비스를 관리하는 것은 어렵습니다.</p>
<p>테라폼을 통해 일관되고 자동화된 멀티 클라우드 관리가 가능한지 알아봅시다. 이 포함사항은 멀티 클라우드 아키텍처, 테라폼 추상화, 프로비저닝, 거버넌스, 네트워킹, 배포 패턴, 테스팅, 그리고 Azure 및 GCP 전반적인 모니터링입니다.</p>
<h1>개요</h1>
<p>다음 주제를 다룰 것입니다:</p>
<ul>
<li>테라폼을 사용한 멀티 클라우드 아키텍처</li>
<li>인프라 차이점 추상화</li>
<li>리소스 프로비저닝 및 의존성 관리</li>
<li>정책 강화 및 거버넌스</li>
<li>네트워킹 토폴로지와 연결</li>
<li>블루-그린, 카나리아, 멀티 리전 배포 패턴</li>
<li>통합 테스트 및 목 객체(Mock) 사용</li>
<li>중앙 집중식 로깅, 메트릭 및 관찰 가능성</li>
</ul>
<p>이 코드 예제들은 테라폼을 사용해 Azure와 GCP로 인프라 및 서비스를 배포하는 방법을 보여줍니다. 이는 테라폼을 일관된 추상화 계층으로 사용하여 실제 멀티 클라우드 관리를 보여줍니다.</p>
<h1>멀티 클라우드 아키텍처</h1>
<p>기본적인 멀티 클라우드 아키텍처는 Terraform을 사용하면 다음과 같이 보입니다:</p>
<p>Terraform은 여러 클라우드 계정에 인프라를 프로비저닝하고 플랫폼 간의 차이를 추상화합니다. 상태는 원격으로 저장되며 계정 간에 공유됩니다.</p>
<p>멀티 클라우드 아키텍처를 위한 몇 가지 주요 디자인 원칙:</p>
<ul>
<li>차이 추상화 — 공급자별 논리를 최소화하고 차이를 추상화 뒤에 숨깁니다</li>
<li>환경 모듈화 — 환경 및 구성 요소별로 모듈화된 파일로 구성을 분리합니다</li>
<li>표준화된 네이밍 — 쉽게 연관을 확인하기 위해 클라우드 간에 일관된 네이밍 체계 사용</li>
<li>정책 캡슐화 — 정책 및 거버넌스 규칙을 모듈화된 재사용 가능한 파일에 유지합니다</li>
<li>상태 중앙화 — 원격 상태를 사용하여 서비스 및 클라우드 전체의 상태를 공유합니다</li>
<li>공유 서비스 추출 — ID, DNS, CDN과 같은 공유 서비스를 한 번 빌드하고 재사용합니다</li>
<li>파이프라인 통합 — 모든 클라우드 대상으로 배포하는 표준 CI/CD 파이프라인 사용</li>
</ul>
<p>이러한 원칙을 따라서, 여러 대상 클라우드 간에 일관성있는 이동 가능한 구성을 구축할 수 있습니다.</p>
<p>그 다음으로, Terraform이 클라우드 간의 차이를 추상화하는 데 어떻게 도움을 주는지 살펴보겠습니다.</p>
<h1>인프라 추상화</h1>
<p>Terraform의 강점 중 하나는 클라우드 플랫폼 간의 차이를 추상화하는 균일한 추상화 계층을 제공할 수 있는 능력입니다.</p>
<p>예를 들어, Azure 대 GCP에서 MySQL 데이터베이스 프로비저닝:</p>
<p>Azure</p>
<pre><code class="hljs language-js">resource <span class="hljs-string">"azurerm_mysql_server"</span> <span class="hljs-string">"db"</span> {
  name                = <span class="hljs-string">"mysqlserver"</span>
  location            = <span class="hljs-string">"eastus"</span>
  resource_group_name = azurerm_resource_group.<span class="hljs-property">rg</span>.<span class="hljs-property">name</span>
</code></pre>
<pre><code class="hljs language-js">  sku {
    name     = <span class="hljs-string">"B_Gen5_2"</span>
    capacity = <span class="hljs-number">2</span>
  }
}
resource <span class="hljs-string">"azurerm_mysql_database"</span> <span class="hljs-string">"db"</span> {
  name                = <span class="hljs-string">"mydatabase"</span>
  resource_group_name = azurerm_resource_group.<span class="hljs-property">rg</span>.<span class="hljs-property">name</span>
  server_name         = azurerm_mysql_server.<span class="hljs-property">db</span>.<span class="hljs-property">name</span>
  charset             = <span class="hljs-string">"utf8"</span>
  collation           = <span class="hljs-string">"utf8_unicode_ci"</span>
}
</code></pre>
<p>GCP</p>
<pre><code class="hljs language-js">resource <span class="hljs-string">"google_sql_database_instance"</span> <span class="hljs-string">"db"</span> {
  name             = <span class="hljs-string">"mysql-instance"</span>
  database_version = <span class="hljs-string">"MYSQL_5_7"</span>
  region           = <span class="hljs-string">"us-central1"</span>
</code></pre>
<pre><code class="hljs language-js">  settings {
    tier = <span class="hljs-string">"db-f1-micro"</span>
  }
}
resource <span class="hljs-string">"google_sql_database"</span> <span class="hljs-string">"database"</span> {
  name     = <span class="hljs-string">"my-database"</span>
  instance = google_sql_database_instance.<span class="hljs-property">db</span>.<span class="hljs-property">name</span>
}
</code></pre>
<p>Terraform의 리소스 유형은 일관된 인터페이스를 제공하기 위해 기본 API 차이를 추상화합니다.</p>
<p>이 추상화는 대규모 변경없이 클라우드 간에 쉽게 전환할 수 있도록 도와줍니다. 필요한 경우 각 클라우드 공급업체에 맞게 엣지에서 맞춤 설정할 수 있습니다.</p>
<p>테라폼이 다중 클라우드 추상화를 제공하는 주요 분야 몇 가지:</p>
<ul>
<li>컴퓨팅 — 가상 머신, 컨테이너, 쿠버네티스, 스케일링</li>
<li>네트워크 — 서브넷, 라우팅, 보안 그룹, 로드 밸런싱</li>
<li>스토리지 — 블롭, 디스크, 데이터베이스</li>
<li>아이덴티티 — 역할, 권한, 액세스 제어</li>
<li>인프라스트럭처 — DNS, VPN, 규칙, 정책</li>
</ul>
<p>최대한 다중 클라우드 추상화를 활용하여 구성을 작성하면 이동성이 높아집니다.</p>
<h1>프로비저닝 및 의존성</h1>
<p>여러 클라우드 인프라를 프로비저닝할 때 가장 좋은 방법은 리소스를 의존성 레이어로 구조화하는 것입니다.</p>
<p>상위 수준의 구성은 하위 수준의 구성을 의존합니다. 예를 들어:</p>
<p>테라폼을 사용할 때, depends_on 속성을 사용하여 리소스 의존성을 명시적으로 정의하세요:</p>
<p>리소스 "azurerm_subnet" "public" {
#...
}</p>
<p>리소스 "azurerm_network_interface" "nic" {
#...
subnet_id = azurerm_subnet.public.id
}
리소스 "azurerm_virtual_machine" "main" {
#...</p>
<p>network_interface_ids = [
azurerm_network_interface.nic.id,
]
depends_on = [
azurerm_network_interface.nic
]
}</p>
<p>테라폼은 리소스 간 종속성을 분석하고 변경 사항을 올바른 순서로 적용합니다.</p>
<p>멀티 클라우드 환경에서의 종속성에 대한 팁:</p>
<ul>
<li>공통 빌딩 블록을 기본 모듈에 네트워크와 같은 것으로 포함시킵니다.</li>
<li>독립적인 구성 요소를 계층별로 분리합니다.</li>
<li>암시적이어도 <code>depends_on</code>을 명시적으로 정의합니다.</li>
<li>데드락을 일으키는 종속성 순환이 있는지 확인합니다.</li>
<li>종속성 순서대로 계획하고 적용합니다.</li>
</ul>
<p>자원 종속성을 올바르게 설정하는 것이 여러 클라우드에서 원활한 프로비저닝을 위해 중요합니다.</p>
<h1>정책 집행과 거버넌스</h1>
<p>기관 정책과 규정 준수 요구사항을 강제하는 것은 여러 클라우드 관리에 있어 중요합니다.</p>
<p>다음은 운용 규칙의 몇 가지 예시입니다:</p>
<ul>
<li>VM 유형 제한</li>
<li>데이터 주권을 위한 지역 및 존 제어</li>
<li>태깅 규칙과 표준 설정</li>
<li>네트워킹 노출 제한</li>
<li>암호화 요구 사항 강제</li>
<li>고위험 자원 사용 제한</li>
</ul>
<p>테라폼을 통해 정책 강제를 활성화할 수 있습니다:</p>
<p>변수</p>
<p>허용된 값 제한:</p>
<pre><code class="hljs language-js">variable <span class="hljs-string">"region"</span> {
  type    = string
  <span class="hljs-keyword">default</span> = <span class="hljs-string">"us-east-1"</span>
}
</code></pre>
<pre><code class="hljs language-js">resource <span class="hljs-string">"aws_db_instance"</span> <span class="hljs-string">"db"</span> {
  region = <span class="hljs-keyword">var</span>.<span class="hljs-property">region</span> # us-east-<span class="hljs-number">1</span>만 허용됩니다
}
</code></pre>
<p>모듈</p>
<p>친구야, 모듈 내에서 지배 논리를 캡슐화하고 재사용하세요:</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span> <span class="hljs-string">"server"</span> {
  source = <span class="hljs-string">"./modules/certified_server"</span>
# 인증된 서버는 합리적인 기본값을 설정합니다
}
</code></pre>
<p>Sentinel 정책</p>
<p>리소스를 제한하는 대상 정책을 적용하십시오:</p>
<pre><code class="hljs language-js">aws_instance_disallowed_type = rule {
  all aws_instance <span class="hljs-keyword">as</span> _, instance {
    instance.<span class="hljs-property">instance_type</span> is not <span class="hljs-keyword">in</span> [<span class="hljs-string">"t2.micro"</span>, <span class="hljs-string">"t3.micro"</span>]
  }
}
</code></pre>
<p>이러한 메커니즘은 구성에 직접 규제를 포함하여 규정 준수를 쉽게 만듭니다.</p>
<h1>네트워킹 토폴로지</h1>
<p>다양한 클라우드 간 네트워크 연결성을 관리하는 것은 복잡성을 증가시킵니다. 일부 하이브리드 클라우드 네트워크 토폴로지는 다음과 같습니다:</p>
<p>테이블 형식을 Markdown 형식으로 변경하실래요.</p>
<table>
<thead>
<tr>
<th>Pairing</th>
</tr>
</thead>
<tbody>
<tr>
<td>Connect cloud regions to on-prem data centers. Useful for migration and hybrid workloads.</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Hub-and-Spoke</th>
</tr>
</thead>
<tbody>
<tr>
<td>Central hub VPC with connectivity to multiple cloud spokes. Enables transitivity between spokes.</td>
</tr>
</tbody>
</table>
<p>메시</p>
<p>클라우드 간 사이트 간 VPN이 구성된 완전히 메시된 네트워크입니다. 지역 간 직접 통신을 제공합니다.</p>
<p>테라폼은 terraform-provider-aws, terraform-provider-azurerm 및 유사한 네트워킹 제공업체를 통해 이러한 네트워크 토폴로지를 조정하는 것을 단순화합니다.</p>
<p>예를 들어, AWS에서 Azure로 사이트 간 VPN을 생성하는 방법:</p>
<pre><code class="hljs language-js"># <span class="hljs-variable constant_">AWS</span> 측
리소스 <span class="hljs-string">"aws_customer_gateway"</span> <span class="hljs-string">"gw"</span> {
  bgp_asn    = <span class="hljs-number">65002</span>
  ip_address = <span class="hljs-string">"172.0.0.1"</span>
  type       = <span class="hljs-string">"ipsec.1"</span>
}
</code></pre>
<pre><code class="hljs language-js">리소스 <span class="hljs-string">"aws_vpn_connection"</span> <span class="hljs-string">"main"</span> {
  vpn_gateway_id      = aws_vpn_gateway.<span class="hljs-property">vgw</span>.<span class="hljs-property">id</span>
  customer_gateway_id = aws_customer_gateway.<span class="hljs-property">gw</span>.<span class="hljs-property">id</span>
  type                = <span class="hljs-string">"ipsec.1"</span>
  static_routes_only  = <span class="hljs-literal">true</span>
  tunnel1_ike_versions   = [<span class="hljs-string">"ikev2"</span>]
  tunnel2_ike_versions   = [<span class="hljs-string">"ikev2"</span>]
  tunnel1_phase1_dh_group_numbers = [<span class="hljs-number">31</span>]
  tunnel2_phase1_dh_group_numbers = [<span class="hljs-number">31</span>]
}
# <span class="hljs-title class_">Azure</span> 측
리소스 <span class="hljs-string">"azurerm_local_network_gateway"</span> <span class="hljs-string">"lgw"</span> {
  name                = <span class="hljs-string">"aws-conn"</span>
  resource_group_name = azurerm_resource_group.<span class="hljs-property">rg</span>.<span class="hljs-property">name</span>
  location            = azurerm_resource_group.<span class="hljs-property">rg</span>.<span class="hljs-property">location</span>
  gateway_address = aws_customer_gateway.<span class="hljs-property">gw</span>.<span class="hljs-property">ip_address</span>
  address_space     = [<span class="hljs-string">"172.16.0.0/16"</span>]
}
리소스 <span class="hljs-string">"azurerm_virtual_network_gateway_connection"</span> <span class="hljs-string">"main"</span> {
  name                       = <span class="hljs-string">"aws-conn"</span>
  resource_group_name        = azurerm_resource_group.<span class="hljs-property">rg</span>.<span class="hljs-property">name</span>
  location                   = azurerm_resource_group.<span class="hljs-property">rg</span>.<span class="hljs-property">location</span>
  type                       = <span class="hljs-string">"IPsec"</span>
  virtual_network_gateway_id = azurerm_virtual_network_gateway.<span class="hljs-property">vgw</span>.<span class="hljs-property">id</span>
  local_network_gateway_id   = azurerm_local_network_gateway.<span class="hljs-property">lgw</span>.<span class="hljs-property">id</span>
  shared_key = aws_vpn_connection.<span class="hljs-property">main</span>.<span class="hljs-property">tunnel1_preshared_key</span>

  ipsec_policy {
    dh_group         = <span class="hljs-string">"DHGroup31"</span>
    ike_encryption   = <span class="hljs-string">"AES256"</span>
    ike_integrity    = <span class="hljs-string">"SHA256"</span>
    ipsec_encryption = <span class="hljs-string">"AES256"</span>
    ipsec_integrity  = <span class="hljs-string">"SHA256"</span>
    pfs_group        = <span class="hljs-string">"PFS31"</span>
    sa_datasize      = <span class="hljs-number">536870912</span>
  }
}
</code></pre>
<p>이 방법을 통해 멀티 클라우드에 일관된 방식으로 전체 연결 구성을 정의할 수 있습니다.</p>
<h1>배포 패턴</h1>
<p>여러 클라우드로 배포할 때 블루-그린, 카나리아, 다중 지역과 같은 패턴을 사용하면 관리가 간단해질 수 있어요.</p>
<p>블루-그린</p>
<p>블루-그린은 새 버전을 병렬로 배포한 다음 트래픽을 원자적으로 전환합니다. 이는 롤백 및 점진적인 롤아웃 기능을 제공합니다.</p>
<p>예시:</p>
<pre><code class="hljs language-js"># 파란 환경
<span class="hljs-variable language_">module</span> <span class="hljs-string">"blue_env"</span> {
  source = <span class="hljs-string">"./env"</span>
  color  = <span class="hljs-string">"blue"</span>
}
</code></pre>
<pre><code class="hljs language-js"># 초록 환경
<span class="hljs-variable language_">module</span> <span class="hljs-string">"green_env"</span> {
  source = <span class="hljs-string">"./env"</span>
  color  = <span class="hljs-string">"green"</span>
  # 처음에는 트래픽이 없음
  traffic_weight = <span class="hljs-number">0</span>
}
# 트래픽 분할기
resource <span class="hljs-string">"aws_lb"</span> <span class="hljs-string">"main"</span> {
  # <span class="hljs-number">100</span>%의 트래픽을 파란 쪽에 보냅니다.
}
</code></pre>
<p>그런 다음 로드 밸런서를 통해 점진적으로 파란 색에서 초록 색으로 트래픽을 이동합니다.</p>
<p>카나리아</p>
<p>파란색-초록색처럼 변경되지만 처음에는 일부 사용자에게만 공개됩니다.</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span> <span class="hljs-string">"prod_env"</span> {
  source = <span class="hljs-string">"./env"</span>
</code></pre>
<pre><code class="hljs language-js">  # 대부분의 트래픽이 본 프로덕션 환경으로 이동합니다.
}
<span class="hljs-variable language_">module</span> <span class="hljs-string">"canary_env"</span> {
  source = <span class="hljs-string">"./env"</span>
  # 소수의 트래픽이 canary로 이동합니다.
  traffic_weight = <span class="hljs-number">0.1</span>
}
</code></pre>
<p>Multi-Region</p>
<p>고가용성 및 낮은 대기 시간을 위해 여러 지역에 리소스를 프로비저닝합니다.</p>
<p>예를 들어:</p>
<pre><code class="hljs language-js"># 서부 지역
<span class="hljs-variable language_">module</span> <span class="hljs-string">"west"</span> {
  source = <span class="hljs-string">"./region"</span>
  providers = {
    azurerm.<span class="hljs-property">west</span> = azurerm.<span class="hljs-property">west</span>
  }
}
</code></pre>
<pre><code class="hljs language-js"># 동부 지역
<span class="hljs-variable language_">module</span> <span class="hljs-string">"east"</span> {
  source = <span class="hljs-string">"./region"</span>
  providers = {
    azurerm.<span class="hljs-property">east</span> = azurerm.<span class="hljs-property">east</span>
  }
}
</code></pre>
<p>그럼 DNS와 로드 밸런싱을 사용하여 전 세계적으로 분산하세요.</p>
<p>이러한 패턴은 멀티 클라우드 배포를 간단하게 해줍니다. 모듈 재사용은 일관성을 도와줍니다.</p>
<h1>통합 테스트</h1>
<p>여러 클라우드에 걸친 배포를 유효성 검사하려면 자동화된 통합 테스트가 필요합니다.</p>
<p>테라폼을 사용한 멀티 클라우드 테스팅을 위한 몇 가지 최상의 방법:</p>
<ul>
<li>인프라 테스트 — terraform plan 및 terraform show를 사용하여 올바른 구성의 리소스를 검증합니다.</li>
<li>프로비저닝 테스트 — 처음부터 일회용 테스트 환경을 배포합니다.</li>
<li>실패 테스트 — 종료된 인스턴스와 같은 실패를 시뮬레이션합니다.</li>
<li>서비스 테스트 — 목업을 사용하여 서비스 접근성과 동작을 유효성 검사합니다.</li>
</ul>
<p>예를 들어, 일회용 테스트 환경을 생성하는 방법:</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span> <span class="hljs-string">"test_env"</span> {
  source = <span class="hljs-string">"./env"</span>
  providers = {
    aws = aws.<span class="hljs-property">test</span>
  }
}
</code></pre>
<p>테이블 태그를 Markdown 형식으로 변경해주세요.</p>
<p>다양한 환경에서 배포를 유효성 검사하려면 자동화된 테스트가 필요합니다.</p>
<p>Terraform을 사용하는 몇 가지 권장사항:</p>
<ul>
<li>사용 및 폐기 가능한 테스트 환경 프로비저닝</li>
<li>리소스 구성 검증</li>
<li>다양한 장애 시나리오 시뮬레이션</li>
<li>의존성에 대한 모의 테스트 사용</li>
</ul>
<p>예시:</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span> <span class="hljs-string">"test_env"</span> {
  source = <span class="hljs-string">"./env"</span>
</code></pre>
<pre><code class="hljs language-js">  # <span class="hljs-variable constant_">AWS</span> 계정 자격 증명 테스트
}
resource <span class="hljs-string">"null_resource"</span> <span class="hljs-string">"check_connectivity"</span> {
  provisioner <span class="hljs-string">"local-exec"</span> {
    command = <span class="hljs-string">"ping.exe -n 3 ${module.test_env.ip}"</span>
  }
}
</code></pre>
<p>이렇게 하면 안전하게 변경 사항을 테스트할 수 있는 격리된 환경이 생성됩니다.</p>
<p>다른 예시:</p>
<ul>
<li>성능 테스트를 위해 과거 트래픽을 다시 재생합니다.</li>
<li>종료된 인스턴스와 같은 결함을 주입합니다.</li>
<li>결정론적 테스트를 위해 외부 서비스를 스텁 처리합니다.</li>
</ul>
<p>자동화된 테스트는 구성 요소를 리팩토링할 때 자신감을 유지하는 데 중요합니다.</p>
<h2>가시성</h2>
<p>이질적인 클라우드 간 로그, 지표 및 추적에 대한 가시성을 확보하는 것은 어렵습니다.</p>
<p>테라폼을 사용하면 관측 가능성 데이터를 공유 플랫폼에 집계할 수 있습니다:</p>
<p>로그 기능</p>
<pre><code class="hljs language-js">resource <span class="hljs-string">"aws_cloudwatch_log_group"</span> <span class="hljs-string">"app"</span> {
  name = <span class="hljs-string">"/aws/lambda/app"</span>
}
resource <span class="hljs-string">"azurerm_monitor_diagnostic_setting"</span> <span class="hljs-string">"app"</span> {
  name               = <span class="hljs-string">"diag"</span>
  target_resource_id = azurerm_function_app.<span class="hljs-property">app</span>.<span class="hljs-property">id</span>
  log_analytics_workspace_id = azurerm_log_analytics_workspace.<span class="hljs-property">main</span>.<span class="hljs-property">id</span>
  log {
    category = <span class="hljs-string">"FunctionAppLogs"</span>
    enabled  = <span class="hljs-literal">true</span>
  }
}
resource <span class="hljs-string">"google_logging_project_sink"</span> <span class="hljs-string">"app"</span> {
  name        = <span class="hljs-string">"app-sink"</span>
  destination = google_storage_bucket.<span class="hljs-property">logs</span>.<span class="hljs-property">name</span>
}
</code></pre>
<p>Splunk와 같은 도구에서 로그를 중앙 집계하세요.</p>
<p>메트릭</p>
<pre><code class="hljs language-js">리소스 <span class="hljs-string">"signalfx_detector"</span> <span class="hljs-string">"지연시간"</span> {
  이름 = <span class="hljs-string">"높은 지연시간"</span>
  프로그램_텍스트 = &#x3C;&#x3C;-<span class="hljs-variable constant_">EOF</span>
    A = 데이터(<span class="hljs-string">'지연시간'</span>, 필터=필터(<span class="hljs-string">'클라우드'</span>, <span class="hljs-string">'*'</span>) and 필터(<span class="hljs-string">'환경'</span>, <span class="hljs-string">'*'</span>)).게시(label=<span class="hljs-string">'A'</span>)
    B = (A).합계(by=[<span class="hljs-string">'클라우드'</span>, <span class="hljs-string">'환경'</span>]).게시(label=<span class="hljs-string">'B'</span>)
    <span class="hljs-title function_">detect</span>(<span class="hljs-title function_">when</span>(B > <span class="hljs-number">1000</span>, <span class="hljs-string">'5m'</span>)).게시(<span class="hljs-string">'높은 지연시간!'</span>)
  <span class="hljs-variable constant_">EOF</span>
}
</code></pre>
<p>Datadog와 같은 플랫폼에서 메트릭을 통합해보세요.</p>
<p>트레이싱</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span> <span class="hljs-string">"opentelemetry"</span> {
  source = <span class="hljs-string">"./opentelemetry"</span>
  providers = {
    aws = aws
    azure = azurerm
    google = google
  }
}
</code></pre>
<p>일반적인 형식으로 OpenTelemetry을 사용하면 추적을 쉽게 연결할 수 있어요.</p>
<p>테라폼을 사용하면 다양한 플랫폼 사이에서 공유 관찰 패턴을 구축할 수 있어요.</p>
<h1>예시: 멀티-클라우드 웹 애플리케이션</h1>
<p>실제로 멀티 클라우드 웹 애플리케이션을 Terraform으로 배포하는 실제 사례를 살펴봅시다.</p>
<p>AWS ECS 및 Azure Container Instances (ACI)의 클러스터 전체에 애플리케이션 인프라를 배포할 것입니다. 글로벌 로드 밸런서가 트래픽을 플랫폼 간에 분배할 것입니다.</p>
<p>네트워킹</p>
<p>먼저, AWS VPC와 Azure VNet을 연결해야 합니다.</p>
<pre><code class="hljs language-js"># <span class="hljs-variable constant_">AWS</span> <span class="hljs-variable constant_">VPC</span> 및 서브넷
resource <span class="hljs-string">"aws_vpc"</span> <span class="hljs-string">"main"</span> {
  cidr_block = <span class="hljs-string">"10.1.0.0/16"</span>
}
</code></pre>
<pre><code class="hljs language-js">resource <span class="hljs-string">"aws_subnet"</span> <span class="hljs-string">"public"</span> {
  vpc_id = aws_vpc.<span class="hljs-property">main</span>.<span class="hljs-property">id</span>
  cidr_block = <span class="hljs-string">"10.1.1.0/24"</span>
}
# <span class="hljs-title class_">Azure</span> <span class="hljs-title class_">VNet</span>
resource <span class="hljs-string">"azurerm_virtual_network"</span> <span class="hljs-string">"main"</span> {
  name                = <span class="hljs-string">"app-network"</span>
  address_space       = [<span class="hljs-string">"10.2.0.0/16"</span>]
}
resource <span class="hljs-string">"azurerm_subnet"</span> <span class="hljs-string">"public"</span> {
  name                 = <span class="hljs-string">"public-subnet"</span>
  resource_group_name  = azurerm_resource_group.<span class="hljs-property">main</span>.<span class="hljs-property">name</span>
  virtual_network_name = azurerm_virtual_network.<span class="hljs-property">main</span>.<span class="hljs-property">name</span>
  address_prefixes     = [<span class="hljs-string">"10.2.1.0/24"</span>]
}
</code></pre>
<p>VPC 피어링을 통해 이들을 연결하십시오:</p>
<pre><code class="hljs language-js"># <span class="hljs-variable constant_">AWS</span> 쪽 피어링
resource <span class="hljs-string">"aws_vpc_peering_connection"</span> <span class="hljs-string">"peer"</span> {
  vpc_id      = aws_vpc.<span class="hljs-property">main</span>.<span class="hljs-property">id</span>
  peer_vpc_id = azurerm_virtual_network.<span class="hljs-property">main</span>.<span class="hljs-property">id</span>
  auto_accept = <span class="hljs-literal">true</span>
}
</code></pre>
<pre><code class="hljs language-js"># <span class="hljs-title class_">Azure</span> 측 피어링
resource <span class="hljs-string">"azurerm_virtual_network_peering"</span> <span class="hljs-string">"peer"</span> {
  name                      = <span class="hljs-string">"peer-aws"</span>
  resource_group_name       = azurerm_resource_group.<span class="hljs-property">main</span>.<span class="hljs-property">name</span>
  virtual_network_name      = az
</code></pre>
<p>컴퓨팅</p>
<p>Azure Container Instances 배포:</p>
<pre><code class="hljs language-js">resource <span class="hljs-string">"azurerm_container_group"</span> <span class="hljs-string">"app"</span> {
  name                = <span class="hljs-string">"app-aci"</span>
  location            = azurerm_resource_group.<span class="hljs-property">main</span>.<span class="hljs-property">location</span>
  resource_group_name = azurerm_resource_group.<span class="hljs-property">main</span>.<span class="hljs-property">name</span>
  ip_address_type     = <span class="hljs-string">"public"</span>
  dns_name_label      = <span class="hljs-string">"app-aci"</span>
  os_type             = <span class="hljs-string">"Linux"</span>
</code></pre>
<pre><code class="hljs language-js">  container {
    name   = <span class="hljs-string">"app"</span>
    image  = <span class="hljs-string">"myapp:v1"</span>
    cpu    = <span class="hljs-string">"1"</span>
    memory = <span class="hljs-string">"1"</span>
    ports {
      port     = <span class="hljs-number">80</span>
      protocol = <span class="hljs-string">"TCP"</span>
    }
  }
</code></pre>
<p>아마존 ECS 클러스터 및 서비스:</p>
<pre><code class="hljs language-js">resource <span class="hljs-string">"aws_ecs_cluster"</span> <span class="hljs-string">"main"</span> {
  name = <span class="hljs-string">"myapp-cluster"</span>
}
</code></pre>
<pre><code class="hljs language-js">resource <span class="hljs-string">"aws_ecs_service"</span> <span class="hljs-string">"web"</span> {
  name            = <span class="hljs-string">"web"</span>
  cluster         = aws_ecs_cluster.<span class="hljs-property">main</span>.<span class="hljs-property">id</span>
  task_definition = aws_ecs_task_definition.<span class="hljs-property">app</span>.<span class="hljs-property">arn</span>
  desired_count   = <span class="hljs-number">3</span>
  launch_type     = <span class="hljs-string">"FARGATE"</span>
}
</code></pre>
<p>로드 밸런싱</p>
<p>각 클라우드에 백엔드가 있는 글로벌 로드 밸런서를 배포하십시오:</p>
<pre><code class="hljs language-js">resource <span class="hljs-string">"aws_lb"</span> <span class="hljs-string">"web"</span> {
  name               = <span class="hljs-string">"myapp-lb"</span>
  internal           = <span class="hljs-literal">false</span>

  subnets = [
    aws_subnet.<span class="hljs-property">public</span>.<span class="hljs-property">id</span>
  ]
}
</code></pre>
<pre><code class="hljs language-js">resource <span class="hljs-string">"azurerm_lb"</span> <span class="hljs-string">"web"</span> {
  name                = <span class="hljs-string">"myapp-lb"</span>
  location            = azurerm_resource_group.<span class="hljs-property">main</span>.<span class="hljs-property">location</span>
  resource_group_name = azurerm_resource_group.<span class="hljs-property">main</span>.<span class="hljs-property">name</span>

  frontend_ip_configuration {
    name                 = <span class="hljs-string">"public"</span>
    public_ip_address_id = azurerm_public_ip.<span class="hljs-property">main</span>.<span class="hljs-property">id</span>
  }
}
</code></pre>
<p>Markdown 포맷으로 DNS</p>
<p>로드 밸런서를 통해 단일 도메인을 라우팅합니다:</p>
<pre><code class="hljs language-js">resource <span class="hljs-string">"aws_route53_zone"</span> <span class="hljs-string">"main"</span> {
  name = <span class="hljs-string">"myapp.com"</span>
}
</code></pre>
<pre><code class="hljs language-js">resource <span class="hljs-string">"aws_route53_record"</span> <span class="hljs-string">"webapp"</span> {
  zone_id = aws_route53_zone.<span class="hljs-property">main</span>.<span class="hljs-property">id</span>
  name    = <span class="hljs-string">"webapp.myapp.com"</span>
  type = <span class="hljs-string">"CNAME"</span>
  ttl  = <span class="hljs-string">"300"</span>
  records = [aws_lb.<span class="hljs-property">web</span>.<span class="hljs-property">dns_name</span>]
}
resource <span class="hljs-string">"azurerm_dns_cname_record"</span> <span class="hljs-string">"webapp"</span> {
  name                = <span class="hljs-string">"webapp"</span>
  zone_name           = azurerm_dns_zone.<span class="hljs-property">main</span>.<span class="hljs-property">name</span>
  resource_group_name = azurerm_resource_group.<span class="hljs-property">main</span>.<span class="hljs-property">name</span>
  ttl                 = <span class="hljs-number">300</span>
  record              = azurerm_lb.<span class="hljs-property">web</span>.<span class="hljs-property">fqdn</span>
}
</code></pre>
<p>이는 웹 애플리케이션을 다중 클라우드에서 실행하기 위한 핵심 인프라를 제공하며, 로드 밸런싱과 DNS를 통해 연결됩니다.</p>
<p>테라폼 추상화는 우리에게 클라우드 플랫폼 간에 일관된 방식으로 아키텍처를 표현할 수 있는 기회를 제공합니다. 배포를 확장하고 필요에 따라 데이터베이스, 객체 저장소 및 캐시와 같은 추가 구성 요소를 추가할 수 있습니다.</p>
<h1>결론</h1>
<p>이 블로그에서는 테라폼을 사용하여 다중 클라우드 인프라, 네트워킹, 배포, 테스트 및 모니터링을 관리하는 패턴과 모범 사례를 다루었습니다.</p>
<ul>
<li>추상화 — 추상화된 공급자 및 리소스를 사용하여 이식 가능한 구성물 생성</li>
<li>모듈 — 복잡한 구성 요소를 재사용 가능한 모듈로 캡슐화</li>
<li>상태 — 협업 가능하도록 원격 상태 저장</li>
<li>네트워킹 — VPC와 VNET 간의 연결성 조정</li>
<li>배포 — 블루-그린, 카나리아, 다중 지역 패턴 사용</li>
<li>테스트 — 테스트 환경의 자동 프로비저닝</li>
<li>가시성 — 로그, 메트릭 및 추적을 중앙 집중화</li>
</ul>
<p>테라폼은 각종 공용 클라우드, 개인 데이터 센터 및 SaaS 환경에서 인프라를 프로비저닝하고 관리하기 위한 일관된 워크플로우를 제공합니다. 이 가이드에서 다룬 패턴을 사용하면 다양한 API, 플랫폼 및 토폴로지를 연결하여 다중 클라우드 자동화 및 오케스트레이션을 더 쉽게 구현할 수 있습니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Terraform을 활용한 Multi-Cloud 관리 마스터하기","description":"","date":"2024-05-27 17:46","slug":"2024-05-27-MasteringMulti-CloudManagementwithTerraform","content":"\n\u003cimg src=\"/assets/img/2024-05-27-MasteringMulti-CloudManagementwithTerraform_0.png\" /\u003e\n\n여러 공개 클라우드(Azure, AWS, GCP 등)를 사용하면 유연성을 제공하고 비용을 최적화하며 벤더 락인을 줄일 수 있습니다. 그러나 다양한 클라우드 플랫폼 간에 인프라 및 서비스를 관리하는 것은 어렵습니다.\n\n테라폼을 통해 일관되고 자동화된 멀티 클라우드 관리가 가능한지 알아봅시다. 이 포함사항은 멀티 클라우드 아키텍처, 테라폼 추상화, 프로비저닝, 거버넌스, 네트워킹, 배포 패턴, 테스팅, 그리고 Azure 및 GCP 전반적인 모니터링입니다.\n\n# 개요\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음 주제를 다룰 것입니다:\n\n- 테라폼을 사용한 멀티 클라우드 아키텍처\n- 인프라 차이점 추상화\n- 리소스 프로비저닝 및 의존성 관리\n- 정책 강화 및 거버넌스\n- 네트워킹 토폴로지와 연결\n- 블루-그린, 카나리아, 멀티 리전 배포 패턴\n- 통합 테스트 및 목 객체(Mock) 사용\n- 중앙 집중식 로깅, 메트릭 및 관찰 가능성\n\n이 코드 예제들은 테라폼을 사용해 Azure와 GCP로 인프라 및 서비스를 배포하는 방법을 보여줍니다. 이는 테라폼을 일관된 추상화 계층으로 사용하여 실제 멀티 클라우드 관리를 보여줍니다.\n\n# 멀티 클라우드 아키텍처\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n기본적인 멀티 클라우드 아키텍처는 Terraform을 사용하면 다음과 같이 보입니다:\n\nTerraform은 여러 클라우드 계정에 인프라를 프로비저닝하고 플랫폼 간의 차이를 추상화합니다. 상태는 원격으로 저장되며 계정 간에 공유됩니다.\n\n멀티 클라우드 아키텍처를 위한 몇 가지 주요 디자인 원칙:\n\n- 차이 추상화 — 공급자별 논리를 최소화하고 차이를 추상화 뒤에 숨깁니다\n- 환경 모듈화 — 환경 및 구성 요소별로 모듈화된 파일로 구성을 분리합니다\n- 표준화된 네이밍 — 쉽게 연관을 확인하기 위해 클라우드 간에 일관된 네이밍 체계 사용\n- 정책 캡슐화 — 정책 및 거버넌스 규칙을 모듈화된 재사용 가능한 파일에 유지합니다\n- 상태 중앙화 — 원격 상태를 사용하여 서비스 및 클라우드 전체의 상태를 공유합니다\n- 공유 서비스 추출 — ID, DNS, CDN과 같은 공유 서비스를 한 번 빌드하고 재사용합니다\n- 파이프라인 통합 — 모든 클라우드 대상으로 배포하는 표준 CI/CD 파이프라인 사용\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이러한 원칙을 따라서, 여러 대상 클라우드 간에 일관성있는 이동 가능한 구성을 구축할 수 있습니다.\n\n그 다음으로, Terraform이 클라우드 간의 차이를 추상화하는 데 어떻게 도움을 주는지 살펴보겠습니다.\n\n# 인프라 추상화\n\nTerraform의 강점 중 하나는 클라우드 플랫폼 간의 차이를 추상화하는 균일한 추상화 계층을 제공할 수 있는 능력입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예를 들어, Azure 대 GCP에서 MySQL 데이터베이스 프로비저닝:\n\nAzure\n\n```js\nresource \"azurerm_mysql_server\" \"db\" {\n  name                = \"mysqlserver\"\n  location            = \"eastus\"\n  resource_group_name = azurerm_resource_group.rg.name\n```\n\n```js\n  sku {\n    name     = \"B_Gen5_2\"\n    capacity = 2\n  }\n}\nresource \"azurerm_mysql_database\" \"db\" {\n  name                = \"mydatabase\"\n  resource_group_name = azurerm_resource_group.rg.name\n  server_name         = azurerm_mysql_server.db.name\n  charset             = \"utf8\"\n  collation           = \"utf8_unicode_ci\"\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nGCP\n\n```js\nresource \"google_sql_database_instance\" \"db\" {\n  name             = \"mysql-instance\"\n  database_version = \"MYSQL_5_7\"\n  region           = \"us-central1\"\n```\n\n```js\n  settings {\n    tier = \"db-f1-micro\"\n  }\n}\nresource \"google_sql_database\" \"database\" {\n  name     = \"my-database\"\n  instance = google_sql_database_instance.db.name\n}\n```\n\nTerraform의 리소스 유형은 일관된 인터페이스를 제공하기 위해 기본 API 차이를 추상화합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 추상화는 대규모 변경없이 클라우드 간에 쉽게 전환할 수 있도록 도와줍니다. 필요한 경우 각 클라우드 공급업체에 맞게 엣지에서 맞춤 설정할 수 있습니다.\n\n테라폼이 다중 클라우드 추상화를 제공하는 주요 분야 몇 가지:\n\n- 컴퓨팅 — 가상 머신, 컨테이너, 쿠버네티스, 스케일링\n- 네트워크 — 서브넷, 라우팅, 보안 그룹, 로드 밸런싱\n- 스토리지 — 블롭, 디스크, 데이터베이스\n- 아이덴티티 — 역할, 권한, 액세스 제어\n- 인프라스트럭처 — DNS, VPN, 규칙, 정책\n\n최대한 다중 클라우드 추상화를 활용하여 구성을 작성하면 이동성이 높아집니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 프로비저닝 및 의존성\n\n여러 클라우드 인프라를 프로비저닝할 때 가장 좋은 방법은 리소스를 의존성 레이어로 구조화하는 것입니다.\n\n상위 수준의 구성은 하위 수준의 구성을 의존합니다. 예를 들어:\n\n테라폼을 사용할 때, depends_on 속성을 사용하여 리소스 의존성을 명시적으로 정의하세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n리소스 \"azurerm_subnet\" \"public\" {\n#...\n}\n\n\n\n리소스 \"azurerm_network_interface\" \"nic\" {\n#...\nsubnet_id = azurerm_subnet.public.id\n}\n리소스 \"azurerm_virtual_machine\" \"main\" {\n#...\n\nnetwork_interface_ids = [\nazurerm_network_interface.nic.id,\n]\ndepends_on = [\nazurerm_network_interface.nic\n]\n}\n\n\n테라폼은 리소스 간 종속성을 분석하고 변경 사항을 올바른 순서로 적용합니다.\n\n멀티 클라우드 환경에서의 종속성에 대한 팁:\n\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 공통 빌딩 블록을 기본 모듈에 네트워크와 같은 것으로 포함시킵니다.\n- 독립적인 구성 요소를 계층별로 분리합니다.\n- 암시적이어도 `depends_on`을 명시적으로 정의합니다.\n- 데드락을 일으키는 종속성 순환이 있는지 확인합니다.\n- 종속성 순서대로 계획하고 적용합니다.\n\n자원 종속성을 올바르게 설정하는 것이 여러 클라우드에서 원활한 프로비저닝을 위해 중요합니다.\n\n# 정책 집행과 거버넌스\n\n기관 정책과 규정 준수 요구사항을 강제하는 것은 여러 클라우드 관리에 있어 중요합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음은 운용 규칙의 몇 가지 예시입니다:\n\n- VM 유형 제한\n- 데이터 주권을 위한 지역 및 존 제어\n- 태깅 규칙과 표준 설정\n- 네트워킹 노출 제한\n- 암호화 요구 사항 강제\n- 고위험 자원 사용 제한\n\n테라폼을 통해 정책 강제를 활성화할 수 있습니다:\n\n변수\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n허용된 값 제한:\n\n```js\nvariable \"region\" {\n  type    = string\n  default = \"us-east-1\"\n}\n```\n\n```js\nresource \"aws_db_instance\" \"db\" {\n  region = var.region # us-east-1만 허용됩니다\n}\n```\n\n모듈\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n친구야, 모듈 내에서 지배 논리를 캡슐화하고 재사용하세요:\n\n```js\nmodule \"server\" {\n  source = \"./modules/certified_server\"\n# 인증된 서버는 합리적인 기본값을 설정합니다\n}\n```\n\nSentinel 정책\n\n리소스를 제한하는 대상 정책을 적용하십시오:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\naws_instance_disallowed_type = rule {\n  all aws_instance as _, instance {\n    instance.instance_type is not in [\"t2.micro\", \"t3.micro\"]\n  }\n}\n```\n\n이러한 메커니즘은 구성에 직접 규제를 포함하여 규정 준수를 쉽게 만듭니다.\n\n# 네트워킹 토폴로지\n\n다양한 클라우드 간 네트워크 연결성을 관리하는 것은 복잡성을 증가시킵니다. 일부 하이브리드 클라우드 네트워크 토폴로지는 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테이블 형식을 Markdown 형식으로 변경하실래요.\n\n\n| Pairing |\n|--------|\n| Connect cloud regions to on-prem data centers. Useful for migration and hybrid workloads. |\n\n| Hub-and-Spoke |\n|---------------|\n| Central hub VPC with connectivity to multiple cloud spokes. Enables transitivity between spokes. |\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n메시\n\n클라우드 간 사이트 간 VPN이 구성된 완전히 메시된 네트워크입니다. 지역 간 직접 통신을 제공합니다.\n\n테라폼은 terraform-provider-aws, terraform-provider-azurerm 및 유사한 네트워킹 제공업체를 통해 이러한 네트워크 토폴로지를 조정하는 것을 단순화합니다.\n\n예를 들어, AWS에서 Azure로 사이트 간 VPN을 생성하는 방법:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# AWS 측\n리소스 \"aws_customer_gateway\" \"gw\" {\n  bgp_asn    = 65002\n  ip_address = \"172.0.0.1\"\n  type       = \"ipsec.1\"\n}\n```\n\n```js\n리소스 \"aws_vpn_connection\" \"main\" {\n  vpn_gateway_id      = aws_vpn_gateway.vgw.id\n  customer_gateway_id = aws_customer_gateway.gw.id\n  type                = \"ipsec.1\"\n  static_routes_only  = true\n  tunnel1_ike_versions   = [\"ikev2\"]\n  tunnel2_ike_versions   = [\"ikev2\"]\n  tunnel1_phase1_dh_group_numbers = [31]\n  tunnel2_phase1_dh_group_numbers = [31]\n}\n# Azure 측\n리소스 \"azurerm_local_network_gateway\" \"lgw\" {\n  name                = \"aws-conn\"\n  resource_group_name = azurerm_resource_group.rg.name\n  location            = azurerm_resource_group.rg.location\n  gateway_address = aws_customer_gateway.gw.ip_address\n  address_space     = [\"172.16.0.0/16\"]\n}\n리소스 \"azurerm_virtual_network_gateway_connection\" \"main\" {\n  name                       = \"aws-conn\"\n  resource_group_name        = azurerm_resource_group.rg.name\n  location                   = azurerm_resource_group.rg.location\n  type                       = \"IPsec\"\n  virtual_network_gateway_id = azurerm_virtual_network_gateway.vgw.id\n  local_network_gateway_id   = azurerm_local_network_gateway.lgw.id\n  shared_key = aws_vpn_connection.main.tunnel1_preshared_key\n\n  ipsec_policy {\n    dh_group         = \"DHGroup31\"\n    ike_encryption   = \"AES256\"\n    ike_integrity    = \"SHA256\"\n    ipsec_encryption = \"AES256\"\n    ipsec_integrity  = \"SHA256\"\n    pfs_group        = \"PFS31\"\n    sa_datasize      = 536870912\n  }\n}\n```\n\n이 방법을 통해 멀티 클라우드에 일관된 방식으로 전체 연결 구성을 정의할 수 있습니다.\n\n# 배포 패턴\n\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여러 클라우드로 배포할 때 블루-그린, 카나리아, 다중 지역과 같은 패턴을 사용하면 관리가 간단해질 수 있어요.\n\n블루-그린\n\n블루-그린은 새 버전을 병렬로 배포한 다음 트래픽을 원자적으로 전환합니다. 이는 롤백 및 점진적인 롤아웃 기능을 제공합니다.\n\n예시:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# 파란 환경\nmodule \"blue_env\" {\n  source = \"./env\"\n  color  = \"blue\"\n}\n```\n\n```js\n# 초록 환경\nmodule \"green_env\" {\n  source = \"./env\"\n  color  = \"green\"\n  # 처음에는 트래픽이 없음\n  traffic_weight = 0\n}\n# 트래픽 분할기\nresource \"aws_lb\" \"main\" {\n  # 100%의 트래픽을 파란 쪽에 보냅니다.\n}\n```\n\n그런 다음 로드 밸런서를 통해 점진적으로 파란 색에서 초록 색으로 트래픽을 이동합니다.\n\n카나리아\n\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n파란색-초록색처럼 변경되지만 처음에는 일부 사용자에게만 공개됩니다.\n\n```js\nmodule \"prod_env\" {\n  source = \"./env\"\n```\n\n```js\n  # 대부분의 트래픽이 본 프로덕션 환경으로 이동합니다.\n}\nmodule \"canary_env\" {\n  source = \"./env\"\n  # 소수의 트래픽이 canary로 이동합니다.\n  traffic_weight = 0.1\n}\n```\n\nMulti-Region\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n고가용성 및 낮은 대기 시간을 위해 여러 지역에 리소스를 프로비저닝합니다.\n\n예를 들어:\n\n```js\n# 서부 지역\nmodule \"west\" {\n  source = \"./region\"\n  providers = {\n    azurerm.west = azurerm.west\n  }\n}\n```\n\n```js\n# 동부 지역\nmodule \"east\" {\n  source = \"./region\"\n  providers = {\n    azurerm.east = azurerm.east\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그럼 DNS와 로드 밸런싱을 사용하여 전 세계적으로 분산하세요.\n\n이러한 패턴은 멀티 클라우드 배포를 간단하게 해줍니다. 모듈 재사용은 일관성을 도와줍니다.\n\n# 통합 테스트\n\n여러 클라우드에 걸친 배포를 유효성 검사하려면 자동화된 통합 테스트가 필요합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테라폼을 사용한 멀티 클라우드 테스팅을 위한 몇 가지 최상의 방법:\n\n- 인프라 테스트 — terraform plan 및 terraform show를 사용하여 올바른 구성의 리소스를 검증합니다.\n- 프로비저닝 테스트 — 처음부터 일회용 테스트 환경을 배포합니다.\n- 실패 테스트 — 종료된 인스턴스와 같은 실패를 시뮬레이션합니다.\n- 서비스 테스트 — 목업을 사용하여 서비스 접근성과 동작을 유효성 검사합니다.\n\n예를 들어, 일회용 테스트 환경을 생성하는 방법:\n\n```js\nmodule \"test_env\" {\n  source = \"./env\"\n  providers = {\n    aws = aws.test\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테이블 태그를 Markdown 형식으로 변경해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다양한 환경에서 배포를 유효성 검사하려면 자동화된 테스트가 필요합니다.\n\nTerraform을 사용하는 몇 가지 권장사항:\n\n- 사용 및 폐기 가능한 테스트 환경 프로비저닝\n- 리소스 구성 검증\n- 다양한 장애 시나리오 시뮬레이션\n- 의존성에 대한 모의 테스트 사용\n\n예시:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nmodule \"test_env\" {\n  source = \"./env\"\n```\n\n```js\n  # AWS 계정 자격 증명 테스트\n}\nresource \"null_resource\" \"check_connectivity\" {\n  provisioner \"local-exec\" {\n    command = \"ping.exe -n 3 ${module.test_env.ip}\"\n  }\n}\n```\n\n이렇게 하면 안전하게 변경 사항을 테스트할 수 있는 격리된 환경이 생성됩니다.\n\n다른 예시:\n\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 성능 테스트를 위해 과거 트래픽을 다시 재생합니다.\n- 종료된 인스턴스와 같은 결함을 주입합니다.\n- 결정론적 테스트를 위해 외부 서비스를 스텁 처리합니다.\n\n자동화된 테스트는 구성 요소를 리팩토링할 때 자신감을 유지하는 데 중요합니다.\n\n## 가시성\n\n이질적인 클라우드 간 로그, 지표 및 추적에 대한 가시성을 확보하는 것은 어렵습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테라폼을 사용하면 관측 가능성 데이터를 공유 플랫폼에 집계할 수 있습니다:\n\n로그 기능\n\n```js\nresource \"aws_cloudwatch_log_group\" \"app\" {\n  name = \"/aws/lambda/app\"\n}\nresource \"azurerm_monitor_diagnostic_setting\" \"app\" {\n  name               = \"diag\"\n  target_resource_id = azurerm_function_app.app.id\n  log_analytics_workspace_id = azurerm_log_analytics_workspace.main.id\n  log {\n    category = \"FunctionAppLogs\"\n    enabled  = true\n  }\n}\nresource \"google_logging_project_sink\" \"app\" {\n  name        = \"app-sink\"\n  destination = google_storage_bucket.logs.name\n}\n```\n\nSplunk와 같은 도구에서 로그를 중앙 집계하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n메트릭\n\n```js\n리소스 \"signalfx_detector\" \"지연시간\" {\n  이름 = \"높은 지연시간\"\n  프로그램_텍스트 = \u003c\u003c-EOF\n    A = 데이터('지연시간', 필터=필터('클라우드', '*') and 필터('환경', '*')).게시(label='A')\n    B = (A).합계(by=['클라우드', '환경']).게시(label='B')\n    detect(when(B \u003e 1000, '5m')).게시('높은 지연시간!')\n  EOF\n}\n```\n\nDatadog와 같은 플랫폼에서 메트릭을 통합해보세요.\n\n트레이싱\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nmodule \"opentelemetry\" {\n  source = \"./opentelemetry\"\n  providers = {\n    aws = aws\n    azure = azurerm\n    google = google\n  }\n}\n```\n\n일반적인 형식으로 OpenTelemetry을 사용하면 추적을 쉽게 연결할 수 있어요.\n\n테라폼을 사용하면 다양한 플랫폼 사이에서 공유 관찰 패턴을 구축할 수 있어요.\n\n# 예시: 멀티-클라우드 웹 애플리케이션\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n실제로 멀티 클라우드 웹 애플리케이션을 Terraform으로 배포하는 실제 사례를 살펴봅시다.\n\nAWS ECS 및 Azure Container Instances (ACI)의 클러스터 전체에 애플리케이션 인프라를 배포할 것입니다. 글로벌 로드 밸런서가 트래픽을 플랫폼 간에 분배할 것입니다.\n\n네트워킹\n\n먼저, AWS VPC와 Azure VNet을 연결해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# AWS VPC 및 서브넷\nresource \"aws_vpc\" \"main\" {\n  cidr_block = \"10.1.0.0/16\"\n}\n```\n\n```js\nresource \"aws_subnet\" \"public\" {\n  vpc_id = aws_vpc.main.id\n  cidr_block = \"10.1.1.0/24\"\n}\n# Azure VNet\nresource \"azurerm_virtual_network\" \"main\" {\n  name                = \"app-network\"\n  address_space       = [\"10.2.0.0/16\"]\n}\nresource \"azurerm_subnet\" \"public\" {\n  name                 = \"public-subnet\"\n  resource_group_name  = azurerm_resource_group.main.name\n  virtual_network_name = azurerm_virtual_network.main.name\n  address_prefixes     = [\"10.2.1.0/24\"]\n}\n```\n\nVPC 피어링을 통해 이들을 연결하십시오:\n\n```js\n# AWS 쪽 피어링\nresource \"aws_vpc_peering_connection\" \"peer\" {\n  vpc_id      = aws_vpc.main.id\n  peer_vpc_id = azurerm_virtual_network.main.id\n  auto_accept = true\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# Azure 측 피어링\nresource \"azurerm_virtual_network_peering\" \"peer\" {\n  name                      = \"peer-aws\"\n  resource_group_name       = azurerm_resource_group.main.name\n  virtual_network_name      = az\n```\n\n컴퓨팅\n\nAzure Container Instances 배포:\n\n```js\nresource \"azurerm_container_group\" \"app\" {\n  name                = \"app-aci\"\n  location            = azurerm_resource_group.main.location\n  resource_group_name = azurerm_resource_group.main.name\n  ip_address_type     = \"public\"\n  dns_name_label      = \"app-aci\"\n  os_type             = \"Linux\"\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n  container {\n    name   = \"app\"\n    image  = \"myapp:v1\"\n    cpu    = \"1\"\n    memory = \"1\"\n    ports {\n      port     = 80\n      protocol = \"TCP\"\n    }\n  }\n```\n\n아마존 ECS 클러스터 및 서비스:\n\n```js\nresource \"aws_ecs_cluster\" \"main\" {\n  name = \"myapp-cluster\"\n}\n```\n\n```js\nresource \"aws_ecs_service\" \"web\" {\n  name            = \"web\"\n  cluster         = aws_ecs_cluster.main.id\n  task_definition = aws_ecs_task_definition.app.arn\n  desired_count   = 3\n  launch_type     = \"FARGATE\"\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n로드 밸런싱\n\n각 클라우드에 백엔드가 있는 글로벌 로드 밸런서를 배포하십시오:\n\n```js\nresource \"aws_lb\" \"web\" {\n  name               = \"myapp-lb\"\n  internal           = false\n\n  subnets = [\n    aws_subnet.public.id\n  ]\n}\n```\n\n```js\nresource \"azurerm_lb\" \"web\" {\n  name                = \"myapp-lb\"\n  location            = azurerm_resource_group.main.location\n  resource_group_name = azurerm_resource_group.main.name\n\n  frontend_ip_configuration {\n    name                 = \"public\"\n    public_ip_address_id = azurerm_public_ip.main.id\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nMarkdown 포맷으로 DNS\n\n로드 밸런서를 통해 단일 도메인을 라우팅합니다:\n\n```js\nresource \"aws_route53_zone\" \"main\" {\n  name = \"myapp.com\"\n}\n```\n\n```js\nresource \"aws_route53_record\" \"webapp\" {\n  zone_id = aws_route53_zone.main.id\n  name    = \"webapp.myapp.com\"\n  type = \"CNAME\"\n  ttl  = \"300\"\n  records = [aws_lb.web.dns_name]\n}\nresource \"azurerm_dns_cname_record\" \"webapp\" {\n  name                = \"webapp\"\n  zone_name           = azurerm_dns_zone.main.name\n  resource_group_name = azurerm_resource_group.main.name\n  ttl                 = 300\n  record              = azurerm_lb.web.fqdn\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이는 웹 애플리케이션을 다중 클라우드에서 실행하기 위한 핵심 인프라를 제공하며, 로드 밸런싱과 DNS를 통해 연결됩니다.\n\n테라폼 추상화는 우리에게 클라우드 플랫폼 간에 일관된 방식으로 아키텍처를 표현할 수 있는 기회를 제공합니다. 배포를 확장하고 필요에 따라 데이터베이스, 객체 저장소 및 캐시와 같은 추가 구성 요소를 추가할 수 있습니다.\n\n# 결론\n\n이 블로그에서는 테라폼을 사용하여 다중 클라우드 인프라, 네트워킹, 배포, 테스트 및 모니터링을 관리하는 패턴과 모범 사례를 다루었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 추상화 — 추상화된 공급자 및 리소스를 사용하여 이식 가능한 구성물 생성\n- 모듈 — 복잡한 구성 요소를 재사용 가능한 모듈로 캡슐화\n- 상태 — 협업 가능하도록 원격 상태 저장\n- 네트워킹 — VPC와 VNET 간의 연결성 조정\n- 배포 — 블루-그린, 카나리아, 다중 지역 패턴 사용\n- 테스트 — 테스트 환경의 자동 프로비저닝\n- 가시성 — 로그, 메트릭 및 추적을 중앙 집중화\n\n테라폼은 각종 공용 클라우드, 개인 데이터 센터 및 SaaS 환경에서 인프라를 프로비저닝하고 관리하기 위한 일관된 워크플로우를 제공합니다. 이 가이드에서 다룬 패턴을 사용하면 다양한 API, 플랫폼 및 토폴로지를 연결하여 다중 클라우드 자동화 및 오케스트레이션을 더 쉽게 구현할 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-05-27-MasteringMulti-CloudManagementwithTerraform_0.png"},"coverImage":"/assets/img/2024-05-27-MasteringMulti-CloudManagementwithTerraform_0.png","tag":["Tech"],"readingTime":15},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e여러 공개 클라우드(Azure, AWS, GCP 등)를 사용하면 유연성을 제공하고 비용을 최적화하며 벤더 락인을 줄일 수 있습니다. 그러나 다양한 클라우드 플랫폼 간에 인프라 및 서비스를 관리하는 것은 어렵습니다.\u003c/p\u003e\n\u003cp\u003e테라폼을 통해 일관되고 자동화된 멀티 클라우드 관리가 가능한지 알아봅시다. 이 포함사항은 멀티 클라우드 아키텍처, 테라폼 추상화, 프로비저닝, 거버넌스, 네트워킹, 배포 패턴, 테스팅, 그리고 Azure 및 GCP 전반적인 모니터링입니다.\u003c/p\u003e\n\u003ch1\u003e개요\u003c/h1\u003e\n\u003cp\u003e다음 주제를 다룰 것입니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e테라폼을 사용한 멀티 클라우드 아키텍처\u003c/li\u003e\n\u003cli\u003e인프라 차이점 추상화\u003c/li\u003e\n\u003cli\u003e리소스 프로비저닝 및 의존성 관리\u003c/li\u003e\n\u003cli\u003e정책 강화 및 거버넌스\u003c/li\u003e\n\u003cli\u003e네트워킹 토폴로지와 연결\u003c/li\u003e\n\u003cli\u003e블루-그린, 카나리아, 멀티 리전 배포 패턴\u003c/li\u003e\n\u003cli\u003e통합 테스트 및 목 객체(Mock) 사용\u003c/li\u003e\n\u003cli\u003e중앙 집중식 로깅, 메트릭 및 관찰 가능성\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이 코드 예제들은 테라폼을 사용해 Azure와 GCP로 인프라 및 서비스를 배포하는 방법을 보여줍니다. 이는 테라폼을 일관된 추상화 계층으로 사용하여 실제 멀티 클라우드 관리를 보여줍니다.\u003c/p\u003e\n\u003ch1\u003e멀티 클라우드 아키텍처\u003c/h1\u003e\n\u003cp\u003e기본적인 멀티 클라우드 아키텍처는 Terraform을 사용하면 다음과 같이 보입니다:\u003c/p\u003e\n\u003cp\u003eTerraform은 여러 클라우드 계정에 인프라를 프로비저닝하고 플랫폼 간의 차이를 추상화합니다. 상태는 원격으로 저장되며 계정 간에 공유됩니다.\u003c/p\u003e\n\u003cp\u003e멀티 클라우드 아키텍처를 위한 몇 가지 주요 디자인 원칙:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e차이 추상화 — 공급자별 논리를 최소화하고 차이를 추상화 뒤에 숨깁니다\u003c/li\u003e\n\u003cli\u003e환경 모듈화 — 환경 및 구성 요소별로 모듈화된 파일로 구성을 분리합니다\u003c/li\u003e\n\u003cli\u003e표준화된 네이밍 — 쉽게 연관을 확인하기 위해 클라우드 간에 일관된 네이밍 체계 사용\u003c/li\u003e\n\u003cli\u003e정책 캡슐화 — 정책 및 거버넌스 규칙을 모듈화된 재사용 가능한 파일에 유지합니다\u003c/li\u003e\n\u003cli\u003e상태 중앙화 — 원격 상태를 사용하여 서비스 및 클라우드 전체의 상태를 공유합니다\u003c/li\u003e\n\u003cli\u003e공유 서비스 추출 — ID, DNS, CDN과 같은 공유 서비스를 한 번 빌드하고 재사용합니다\u003c/li\u003e\n\u003cli\u003e파이프라인 통합 — 모든 클라우드 대상으로 배포하는 표준 CI/CD 파이프라인 사용\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이러한 원칙을 따라서, 여러 대상 클라우드 간에 일관성있는 이동 가능한 구성을 구축할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e그 다음으로, Terraform이 클라우드 간의 차이를 추상화하는 데 어떻게 도움을 주는지 살펴보겠습니다.\u003c/p\u003e\n\u003ch1\u003e인프라 추상화\u003c/h1\u003e\n\u003cp\u003eTerraform의 강점 중 하나는 클라우드 플랫폼 간의 차이를 추상화하는 균일한 추상화 계층을 제공할 수 있는 능력입니다.\u003c/p\u003e\n\u003cp\u003e예를 들어, Azure 대 GCP에서 MySQL 데이터베이스 프로비저닝:\u003c/p\u003e\n\u003cp\u003eAzure\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eresource \u003cspan class=\"hljs-string\"\u003e\"azurerm_mysql_server\"\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"db\"\u003c/span\u003e {\n  name                = \u003cspan class=\"hljs-string\"\u003e\"mysqlserver\"\u003c/span\u003e\n  location            = \u003cspan class=\"hljs-string\"\u003e\"eastus\"\u003c/span\u003e\n  resource_group_name = azurerm_resource_group.\u003cspan class=\"hljs-property\"\u003erg\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e  sku {\n    name     = \u003cspan class=\"hljs-string\"\u003e\"B_Gen5_2\"\u003c/span\u003e\n    capacity = \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e\n  }\n}\nresource \u003cspan class=\"hljs-string\"\u003e\"azurerm_mysql_database\"\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"db\"\u003c/span\u003e {\n  name                = \u003cspan class=\"hljs-string\"\u003e\"mydatabase\"\u003c/span\u003e\n  resource_group_name = azurerm_resource_group.\u003cspan class=\"hljs-property\"\u003erg\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e\n  server_name         = azurerm_mysql_server.\u003cspan class=\"hljs-property\"\u003edb\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e\n  charset             = \u003cspan class=\"hljs-string\"\u003e\"utf8\"\u003c/span\u003e\n  collation           = \u003cspan class=\"hljs-string\"\u003e\"utf8_unicode_ci\"\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eGCP\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eresource \u003cspan class=\"hljs-string\"\u003e\"google_sql_database_instance\"\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"db\"\u003c/span\u003e {\n  name             = \u003cspan class=\"hljs-string\"\u003e\"mysql-instance\"\u003c/span\u003e\n  database_version = \u003cspan class=\"hljs-string\"\u003e\"MYSQL_5_7\"\u003c/span\u003e\n  region           = \u003cspan class=\"hljs-string\"\u003e\"us-central1\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e  settings {\n    tier = \u003cspan class=\"hljs-string\"\u003e\"db-f1-micro\"\u003c/span\u003e\n  }\n}\nresource \u003cspan class=\"hljs-string\"\u003e\"google_sql_database\"\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"database\"\u003c/span\u003e {\n  name     = \u003cspan class=\"hljs-string\"\u003e\"my-database\"\u003c/span\u003e\n  instance = google_sql_database_instance.\u003cspan class=\"hljs-property\"\u003edb\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTerraform의 리소스 유형은 일관된 인터페이스를 제공하기 위해 기본 API 차이를 추상화합니다.\u003c/p\u003e\n\u003cp\u003e이 추상화는 대규모 변경없이 클라우드 간에 쉽게 전환할 수 있도록 도와줍니다. 필요한 경우 각 클라우드 공급업체에 맞게 엣지에서 맞춤 설정할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e테라폼이 다중 클라우드 추상화를 제공하는 주요 분야 몇 가지:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e컴퓨팅 — 가상 머신, 컨테이너, 쿠버네티스, 스케일링\u003c/li\u003e\n\u003cli\u003e네트워크 — 서브넷, 라우팅, 보안 그룹, 로드 밸런싱\u003c/li\u003e\n\u003cli\u003e스토리지 — 블롭, 디스크, 데이터베이스\u003c/li\u003e\n\u003cli\u003e아이덴티티 — 역할, 권한, 액세스 제어\u003c/li\u003e\n\u003cli\u003e인프라스트럭처 — DNS, VPN, 규칙, 정책\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e최대한 다중 클라우드 추상화를 활용하여 구성을 작성하면 이동성이 높아집니다.\u003c/p\u003e\n\u003ch1\u003e프로비저닝 및 의존성\u003c/h1\u003e\n\u003cp\u003e여러 클라우드 인프라를 프로비저닝할 때 가장 좋은 방법은 리소스를 의존성 레이어로 구조화하는 것입니다.\u003c/p\u003e\n\u003cp\u003e상위 수준의 구성은 하위 수준의 구성을 의존합니다. 예를 들어:\u003c/p\u003e\n\u003cp\u003e테라폼을 사용할 때, depends_on 속성을 사용하여 리소스 의존성을 명시적으로 정의하세요:\u003c/p\u003e\n\u003cp\u003e리소스 \"azurerm_subnet\" \"public\" {\n#...\n}\u003c/p\u003e\n\u003cp\u003e리소스 \"azurerm_network_interface\" \"nic\" {\n#...\nsubnet_id = azurerm_subnet.public.id\n}\n리소스 \"azurerm_virtual_machine\" \"main\" {\n#...\u003c/p\u003e\n\u003cp\u003enetwork_interface_ids = [\nazurerm_network_interface.nic.id,\n]\ndepends_on = [\nazurerm_network_interface.nic\n]\n}\u003c/p\u003e\n\u003cp\u003e테라폼은 리소스 간 종속성을 분석하고 변경 사항을 올바른 순서로 적용합니다.\u003c/p\u003e\n\u003cp\u003e멀티 클라우드 환경에서의 종속성에 대한 팁:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e공통 빌딩 블록을 기본 모듈에 네트워크와 같은 것으로 포함시킵니다.\u003c/li\u003e\n\u003cli\u003e독립적인 구성 요소를 계층별로 분리합니다.\u003c/li\u003e\n\u003cli\u003e암시적이어도 \u003ccode\u003edepends_on\u003c/code\u003e을 명시적으로 정의합니다.\u003c/li\u003e\n\u003cli\u003e데드락을 일으키는 종속성 순환이 있는지 확인합니다.\u003c/li\u003e\n\u003cli\u003e종속성 순서대로 계획하고 적용합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e자원 종속성을 올바르게 설정하는 것이 여러 클라우드에서 원활한 프로비저닝을 위해 중요합니다.\u003c/p\u003e\n\u003ch1\u003e정책 집행과 거버넌스\u003c/h1\u003e\n\u003cp\u003e기관 정책과 규정 준수 요구사항을 강제하는 것은 여러 클라우드 관리에 있어 중요합니다.\u003c/p\u003e\n\u003cp\u003e다음은 운용 규칙의 몇 가지 예시입니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eVM 유형 제한\u003c/li\u003e\n\u003cli\u003e데이터 주권을 위한 지역 및 존 제어\u003c/li\u003e\n\u003cli\u003e태깅 규칙과 표준 설정\u003c/li\u003e\n\u003cli\u003e네트워킹 노출 제한\u003c/li\u003e\n\u003cli\u003e암호화 요구 사항 강제\u003c/li\u003e\n\u003cli\u003e고위험 자원 사용 제한\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e테라폼을 통해 정책 강제를 활성화할 수 있습니다:\u003c/p\u003e\n\u003cp\u003e변수\u003c/p\u003e\n\u003cp\u003e허용된 값 제한:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003evariable \u003cspan class=\"hljs-string\"\u003e\"region\"\u003c/span\u003e {\n  type    = string\n  \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\"us-east-1\"\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eresource \u003cspan class=\"hljs-string\"\u003e\"aws_db_instance\"\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"db\"\u003c/span\u003e {\n  region = \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eregion\u003c/span\u003e # us-east-\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e만 허용됩니다\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e모듈\u003c/p\u003e\n\u003cp\u003e친구야, 모듈 내에서 지배 논리를 캡슐화하고 재사용하세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"server\"\u003c/span\u003e {\n  source = \u003cspan class=\"hljs-string\"\u003e\"./modules/certified_server\"\u003c/span\u003e\n# 인증된 서버는 합리적인 기본값을 설정합니다\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSentinel 정책\u003c/p\u003e\n\u003cp\u003e리소스를 제한하는 대상 정책을 적용하십시오:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eaws_instance_disallowed_type = rule {\n  all aws_instance \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e _, instance {\n    instance.\u003cspan class=\"hljs-property\"\u003einstance_type\u003c/span\u003e is not \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e [\u003cspan class=\"hljs-string\"\u003e\"t2.micro\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"t3.micro\"\u003c/span\u003e]\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이러한 메커니즘은 구성에 직접 규제를 포함하여 규정 준수를 쉽게 만듭니다.\u003c/p\u003e\n\u003ch1\u003e네트워킹 토폴로지\u003c/h1\u003e\n\u003cp\u003e다양한 클라우드 간 네트워크 연결성을 관리하는 것은 복잡성을 증가시킵니다. 일부 하이브리드 클라우드 네트워크 토폴로지는 다음과 같습니다:\u003c/p\u003e\n\u003cp\u003e테이블 형식을 Markdown 형식으로 변경하실래요.\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003ePairing\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003eConnect cloud regions to on-prem data centers. Useful for migration and hybrid workloads.\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003eHub-and-Spoke\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003eCentral hub VPC with connectivity to multiple cloud spokes. Enables transitivity between spokes.\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e메시\u003c/p\u003e\n\u003cp\u003e클라우드 간 사이트 간 VPN이 구성된 완전히 메시된 네트워크입니다. 지역 간 직접 통신을 제공합니다.\u003c/p\u003e\n\u003cp\u003e테라폼은 terraform-provider-aws, terraform-provider-azurerm 및 유사한 네트워킹 제공업체를 통해 이러한 네트워크 토폴로지를 조정하는 것을 단순화합니다.\u003c/p\u003e\n\u003cp\u003e예를 들어, AWS에서 Azure로 사이트 간 VPN을 생성하는 방법:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# \u003cspan class=\"hljs-variable constant_\"\u003eAWS\u003c/span\u003e 측\n리소스 \u003cspan class=\"hljs-string\"\u003e\"aws_customer_gateway\"\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"gw\"\u003c/span\u003e {\n  bgp_asn    = \u003cspan class=\"hljs-number\"\u003e65002\u003c/span\u003e\n  ip_address = \u003cspan class=\"hljs-string\"\u003e\"172.0.0.1\"\u003c/span\u003e\n  type       = \u003cspan class=\"hljs-string\"\u003e\"ipsec.1\"\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e리소스 \u003cspan class=\"hljs-string\"\u003e\"aws_vpn_connection\"\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"main\"\u003c/span\u003e {\n  vpn_gateway_id      = aws_vpn_gateway.\u003cspan class=\"hljs-property\"\u003evgw\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eid\u003c/span\u003e\n  customer_gateway_id = aws_customer_gateway.\u003cspan class=\"hljs-property\"\u003egw\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eid\u003c/span\u003e\n  type                = \u003cspan class=\"hljs-string\"\u003e\"ipsec.1\"\u003c/span\u003e\n  static_routes_only  = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e\n  tunnel1_ike_versions   = [\u003cspan class=\"hljs-string\"\u003e\"ikev2\"\u003c/span\u003e]\n  tunnel2_ike_versions   = [\u003cspan class=\"hljs-string\"\u003e\"ikev2\"\u003c/span\u003e]\n  tunnel1_phase1_dh_group_numbers = [\u003cspan class=\"hljs-number\"\u003e31\u003c/span\u003e]\n  tunnel2_phase1_dh_group_numbers = [\u003cspan class=\"hljs-number\"\u003e31\u003c/span\u003e]\n}\n# \u003cspan class=\"hljs-title class_\"\u003eAzure\u003c/span\u003e 측\n리소스 \u003cspan class=\"hljs-string\"\u003e\"azurerm_local_network_gateway\"\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"lgw\"\u003c/span\u003e {\n  name                = \u003cspan class=\"hljs-string\"\u003e\"aws-conn\"\u003c/span\u003e\n  resource_group_name = azurerm_resource_group.\u003cspan class=\"hljs-property\"\u003erg\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e\n  location            = azurerm_resource_group.\u003cspan class=\"hljs-property\"\u003erg\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003elocation\u003c/span\u003e\n  gateway_address = aws_customer_gateway.\u003cspan class=\"hljs-property\"\u003egw\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eip_address\u003c/span\u003e\n  address_space     = [\u003cspan class=\"hljs-string\"\u003e\"172.16.0.0/16\"\u003c/span\u003e]\n}\n리소스 \u003cspan class=\"hljs-string\"\u003e\"azurerm_virtual_network_gateway_connection\"\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"main\"\u003c/span\u003e {\n  name                       = \u003cspan class=\"hljs-string\"\u003e\"aws-conn\"\u003c/span\u003e\n  resource_group_name        = azurerm_resource_group.\u003cspan class=\"hljs-property\"\u003erg\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e\n  location                   = azurerm_resource_group.\u003cspan class=\"hljs-property\"\u003erg\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003elocation\u003c/span\u003e\n  type                       = \u003cspan class=\"hljs-string\"\u003e\"IPsec\"\u003c/span\u003e\n  virtual_network_gateway_id = azurerm_virtual_network_gateway.\u003cspan class=\"hljs-property\"\u003evgw\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eid\u003c/span\u003e\n  local_network_gateway_id   = azurerm_local_network_gateway.\u003cspan class=\"hljs-property\"\u003elgw\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eid\u003c/span\u003e\n  shared_key = aws_vpn_connection.\u003cspan class=\"hljs-property\"\u003emain\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003etunnel1_preshared_key\u003c/span\u003e\n\n  ipsec_policy {\n    dh_group         = \u003cspan class=\"hljs-string\"\u003e\"DHGroup31\"\u003c/span\u003e\n    ike_encryption   = \u003cspan class=\"hljs-string\"\u003e\"AES256\"\u003c/span\u003e\n    ike_integrity    = \u003cspan class=\"hljs-string\"\u003e\"SHA256\"\u003c/span\u003e\n    ipsec_encryption = \u003cspan class=\"hljs-string\"\u003e\"AES256\"\u003c/span\u003e\n    ipsec_integrity  = \u003cspan class=\"hljs-string\"\u003e\"SHA256\"\u003c/span\u003e\n    pfs_group        = \u003cspan class=\"hljs-string\"\u003e\"PFS31\"\u003c/span\u003e\n    sa_datasize      = \u003cspan class=\"hljs-number\"\u003e536870912\u003c/span\u003e\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 방법을 통해 멀티 클라우드에 일관된 방식으로 전체 연결 구성을 정의할 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e배포 패턴\u003c/h1\u003e\n\u003cp\u003e여러 클라우드로 배포할 때 블루-그린, 카나리아, 다중 지역과 같은 패턴을 사용하면 관리가 간단해질 수 있어요.\u003c/p\u003e\n\u003cp\u003e블루-그린\u003c/p\u003e\n\u003cp\u003e블루-그린은 새 버전을 병렬로 배포한 다음 트래픽을 원자적으로 전환합니다. 이는 롤백 및 점진적인 롤아웃 기능을 제공합니다.\u003c/p\u003e\n\u003cp\u003e예시:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 파란 환경\n\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"blue_env\"\u003c/span\u003e {\n  source = \u003cspan class=\"hljs-string\"\u003e\"./env\"\u003c/span\u003e\n  color  = \u003cspan class=\"hljs-string\"\u003e\"blue\"\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 초록 환경\n\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"green_env\"\u003c/span\u003e {\n  source = \u003cspan class=\"hljs-string\"\u003e\"./env\"\u003c/span\u003e\n  color  = \u003cspan class=\"hljs-string\"\u003e\"green\"\u003c/span\u003e\n  # 처음에는 트래픽이 없음\n  traffic_weight = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n}\n# 트래픽 분할기\nresource \u003cspan class=\"hljs-string\"\u003e\"aws_lb\"\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"main\"\u003c/span\u003e {\n  # \u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e%의 트래픽을 파란 쪽에 보냅니다.\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그런 다음 로드 밸런서를 통해 점진적으로 파란 색에서 초록 색으로 트래픽을 이동합니다.\u003c/p\u003e\n\u003cp\u003e카나리아\u003c/p\u003e\n\u003cp\u003e파란색-초록색처럼 변경되지만 처음에는 일부 사용자에게만 공개됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"prod_env\"\u003c/span\u003e {\n  source = \u003cspan class=\"hljs-string\"\u003e\"./env\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e  # 대부분의 트래픽이 본 프로덕션 환경으로 이동합니다.\n}\n\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"canary_env\"\u003c/span\u003e {\n  source = \u003cspan class=\"hljs-string\"\u003e\"./env\"\u003c/span\u003e\n  # 소수의 트래픽이 canary로 이동합니다.\n  traffic_weight = \u003cspan class=\"hljs-number\"\u003e0.1\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eMulti-Region\u003c/p\u003e\n\u003cp\u003e고가용성 및 낮은 대기 시간을 위해 여러 지역에 리소스를 프로비저닝합니다.\u003c/p\u003e\n\u003cp\u003e예를 들어:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 서부 지역\n\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"west\"\u003c/span\u003e {\n  source = \u003cspan class=\"hljs-string\"\u003e\"./region\"\u003c/span\u003e\n  providers = {\n    azurerm.\u003cspan class=\"hljs-property\"\u003ewest\u003c/span\u003e = azurerm.\u003cspan class=\"hljs-property\"\u003ewest\u003c/span\u003e\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 동부 지역\n\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"east\"\u003c/span\u003e {\n  source = \u003cspan class=\"hljs-string\"\u003e\"./region\"\u003c/span\u003e\n  providers = {\n    azurerm.\u003cspan class=\"hljs-property\"\u003eeast\u003c/span\u003e = azurerm.\u003cspan class=\"hljs-property\"\u003eeast\u003c/span\u003e\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그럼 DNS와 로드 밸런싱을 사용하여 전 세계적으로 분산하세요.\u003c/p\u003e\n\u003cp\u003e이러한 패턴은 멀티 클라우드 배포를 간단하게 해줍니다. 모듈 재사용은 일관성을 도와줍니다.\u003c/p\u003e\n\u003ch1\u003e통합 테스트\u003c/h1\u003e\n\u003cp\u003e여러 클라우드에 걸친 배포를 유효성 검사하려면 자동화된 통합 테스트가 필요합니다.\u003c/p\u003e\n\u003cp\u003e테라폼을 사용한 멀티 클라우드 테스팅을 위한 몇 가지 최상의 방법:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e인프라 테스트 — terraform plan 및 terraform show를 사용하여 올바른 구성의 리소스를 검증합니다.\u003c/li\u003e\n\u003cli\u003e프로비저닝 테스트 — 처음부터 일회용 테스트 환경을 배포합니다.\u003c/li\u003e\n\u003cli\u003e실패 테스트 — 종료된 인스턴스와 같은 실패를 시뮬레이션합니다.\u003c/li\u003e\n\u003cli\u003e서비스 테스트 — 목업을 사용하여 서비스 접근성과 동작을 유효성 검사합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e예를 들어, 일회용 테스트 환경을 생성하는 방법:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"test_env\"\u003c/span\u003e {\n  source = \u003cspan class=\"hljs-string\"\u003e\"./env\"\u003c/span\u003e\n  providers = {\n    aws = aws.\u003cspan class=\"hljs-property\"\u003etest\u003c/span\u003e\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e테이블 태그를 Markdown 형식으로 변경해주세요.\u003c/p\u003e\n\u003cp\u003e다양한 환경에서 배포를 유효성 검사하려면 자동화된 테스트가 필요합니다.\u003c/p\u003e\n\u003cp\u003eTerraform을 사용하는 몇 가지 권장사항:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e사용 및 폐기 가능한 테스트 환경 프로비저닝\u003c/li\u003e\n\u003cli\u003e리소스 구성 검증\u003c/li\u003e\n\u003cli\u003e다양한 장애 시나리오 시뮬레이션\u003c/li\u003e\n\u003cli\u003e의존성에 대한 모의 테스트 사용\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e예시:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"test_env\"\u003c/span\u003e {\n  source = \u003cspan class=\"hljs-string\"\u003e\"./env\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e  # \u003cspan class=\"hljs-variable constant_\"\u003eAWS\u003c/span\u003e 계정 자격 증명 테스트\n}\nresource \u003cspan class=\"hljs-string\"\u003e\"null_resource\"\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"check_connectivity\"\u003c/span\u003e {\n  provisioner \u003cspan class=\"hljs-string\"\u003e\"local-exec\"\u003c/span\u003e {\n    command = \u003cspan class=\"hljs-string\"\u003e\"ping.exe -n 3 ${module.test_env.ip}\"\u003c/span\u003e\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이렇게 하면 안전하게 변경 사항을 테스트할 수 있는 격리된 환경이 생성됩니다.\u003c/p\u003e\n\u003cp\u003e다른 예시:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e성능 테스트를 위해 과거 트래픽을 다시 재생합니다.\u003c/li\u003e\n\u003cli\u003e종료된 인스턴스와 같은 결함을 주입합니다.\u003c/li\u003e\n\u003cli\u003e결정론적 테스트를 위해 외부 서비스를 스텁 처리합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e자동화된 테스트는 구성 요소를 리팩토링할 때 자신감을 유지하는 데 중요합니다.\u003c/p\u003e\n\u003ch2\u003e가시성\u003c/h2\u003e\n\u003cp\u003e이질적인 클라우드 간 로그, 지표 및 추적에 대한 가시성을 확보하는 것은 어렵습니다.\u003c/p\u003e\n\u003cp\u003e테라폼을 사용하면 관측 가능성 데이터를 공유 플랫폼에 집계할 수 있습니다:\u003c/p\u003e\n\u003cp\u003e로그 기능\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eresource \u003cspan class=\"hljs-string\"\u003e\"aws_cloudwatch_log_group\"\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"app\"\u003c/span\u003e {\n  name = \u003cspan class=\"hljs-string\"\u003e\"/aws/lambda/app\"\u003c/span\u003e\n}\nresource \u003cspan class=\"hljs-string\"\u003e\"azurerm_monitor_diagnostic_setting\"\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"app\"\u003c/span\u003e {\n  name               = \u003cspan class=\"hljs-string\"\u003e\"diag\"\u003c/span\u003e\n  target_resource_id = azurerm_function_app.\u003cspan class=\"hljs-property\"\u003eapp\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eid\u003c/span\u003e\n  log_analytics_workspace_id = azurerm_log_analytics_workspace.\u003cspan class=\"hljs-property\"\u003emain\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eid\u003c/span\u003e\n  log {\n    category = \u003cspan class=\"hljs-string\"\u003e\"FunctionAppLogs\"\u003c/span\u003e\n    enabled  = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e\n  }\n}\nresource \u003cspan class=\"hljs-string\"\u003e\"google_logging_project_sink\"\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"app\"\u003c/span\u003e {\n  name        = \u003cspan class=\"hljs-string\"\u003e\"app-sink\"\u003c/span\u003e\n  destination = google_storage_bucket.\u003cspan class=\"hljs-property\"\u003elogs\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSplunk와 같은 도구에서 로그를 중앙 집계하세요.\u003c/p\u003e\n\u003cp\u003e메트릭\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e리소스 \u003cspan class=\"hljs-string\"\u003e\"signalfx_detector\"\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"지연시간\"\u003c/span\u003e {\n  이름 = \u003cspan class=\"hljs-string\"\u003e\"높은 지연시간\"\u003c/span\u003e\n  프로그램_텍스트 = \u0026#x3C;\u0026#x3C;-\u003cspan class=\"hljs-variable constant_\"\u003eEOF\u003c/span\u003e\n    A = 데이터(\u003cspan class=\"hljs-string\"\u003e'지연시간'\u003c/span\u003e, 필터=필터(\u003cspan class=\"hljs-string\"\u003e'클라우드'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'*'\u003c/span\u003e) and 필터(\u003cspan class=\"hljs-string\"\u003e'환경'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'*'\u003c/span\u003e)).게시(label=\u003cspan class=\"hljs-string\"\u003e'A'\u003c/span\u003e)\n    B = (A).합계(by=[\u003cspan class=\"hljs-string\"\u003e'클라우드'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'환경'\u003c/span\u003e]).게시(label=\u003cspan class=\"hljs-string\"\u003e'B'\u003c/span\u003e)\n    \u003cspan class=\"hljs-title function_\"\u003edetect\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003ewhen\u003c/span\u003e(B \u003e \u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'5m'\u003c/span\u003e)).게시(\u003cspan class=\"hljs-string\"\u003e'높은 지연시간!'\u003c/span\u003e)\n  \u003cspan class=\"hljs-variable constant_\"\u003eEOF\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eDatadog와 같은 플랫폼에서 메트릭을 통합해보세요.\u003c/p\u003e\n\u003cp\u003e트레이싱\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"opentelemetry\"\u003c/span\u003e {\n  source = \u003cspan class=\"hljs-string\"\u003e\"./opentelemetry\"\u003c/span\u003e\n  providers = {\n    aws = aws\n    azure = azurerm\n    google = google\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e일반적인 형식으로 OpenTelemetry을 사용하면 추적을 쉽게 연결할 수 있어요.\u003c/p\u003e\n\u003cp\u003e테라폼을 사용하면 다양한 플랫폼 사이에서 공유 관찰 패턴을 구축할 수 있어요.\u003c/p\u003e\n\u003ch1\u003e예시: 멀티-클라우드 웹 애플리케이션\u003c/h1\u003e\n\u003cp\u003e실제로 멀티 클라우드 웹 애플리케이션을 Terraform으로 배포하는 실제 사례를 살펴봅시다.\u003c/p\u003e\n\u003cp\u003eAWS ECS 및 Azure Container Instances (ACI)의 클러스터 전체에 애플리케이션 인프라를 배포할 것입니다. 글로벌 로드 밸런서가 트래픽을 플랫폼 간에 분배할 것입니다.\u003c/p\u003e\n\u003cp\u003e네트워킹\u003c/p\u003e\n\u003cp\u003e먼저, AWS VPC와 Azure VNet을 연결해야 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# \u003cspan class=\"hljs-variable constant_\"\u003eAWS\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eVPC\u003c/span\u003e 및 서브넷\nresource \u003cspan class=\"hljs-string\"\u003e\"aws_vpc\"\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"main\"\u003c/span\u003e {\n  cidr_block = \u003cspan class=\"hljs-string\"\u003e\"10.1.0.0/16\"\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eresource \u003cspan class=\"hljs-string\"\u003e\"aws_subnet\"\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"public\"\u003c/span\u003e {\n  vpc_id = aws_vpc.\u003cspan class=\"hljs-property\"\u003emain\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eid\u003c/span\u003e\n  cidr_block = \u003cspan class=\"hljs-string\"\u003e\"10.1.1.0/24\"\u003c/span\u003e\n}\n# \u003cspan class=\"hljs-title class_\"\u003eAzure\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eVNet\u003c/span\u003e\nresource \u003cspan class=\"hljs-string\"\u003e\"azurerm_virtual_network\"\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"main\"\u003c/span\u003e {\n  name                = \u003cspan class=\"hljs-string\"\u003e\"app-network\"\u003c/span\u003e\n  address_space       = [\u003cspan class=\"hljs-string\"\u003e\"10.2.0.0/16\"\u003c/span\u003e]\n}\nresource \u003cspan class=\"hljs-string\"\u003e\"azurerm_subnet\"\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"public\"\u003c/span\u003e {\n  name                 = \u003cspan class=\"hljs-string\"\u003e\"public-subnet\"\u003c/span\u003e\n  resource_group_name  = azurerm_resource_group.\u003cspan class=\"hljs-property\"\u003emain\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e\n  virtual_network_name = azurerm_virtual_network.\u003cspan class=\"hljs-property\"\u003emain\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e\n  address_prefixes     = [\u003cspan class=\"hljs-string\"\u003e\"10.2.1.0/24\"\u003c/span\u003e]\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eVPC 피어링을 통해 이들을 연결하십시오:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# \u003cspan class=\"hljs-variable constant_\"\u003eAWS\u003c/span\u003e 쪽 피어링\nresource \u003cspan class=\"hljs-string\"\u003e\"aws_vpc_peering_connection\"\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"peer\"\u003c/span\u003e {\n  vpc_id      = aws_vpc.\u003cspan class=\"hljs-property\"\u003emain\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eid\u003c/span\u003e\n  peer_vpc_id = azurerm_virtual_network.\u003cspan class=\"hljs-property\"\u003emain\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eid\u003c/span\u003e\n  auto_accept = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# \u003cspan class=\"hljs-title class_\"\u003eAzure\u003c/span\u003e 측 피어링\nresource \u003cspan class=\"hljs-string\"\u003e\"azurerm_virtual_network_peering\"\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"peer\"\u003c/span\u003e {\n  name                      = \u003cspan class=\"hljs-string\"\u003e\"peer-aws\"\u003c/span\u003e\n  resource_group_name       = azurerm_resource_group.\u003cspan class=\"hljs-property\"\u003emain\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e\n  virtual_network_name      = az\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e컴퓨팅\u003c/p\u003e\n\u003cp\u003eAzure Container Instances 배포:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eresource \u003cspan class=\"hljs-string\"\u003e\"azurerm_container_group\"\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"app\"\u003c/span\u003e {\n  name                = \u003cspan class=\"hljs-string\"\u003e\"app-aci\"\u003c/span\u003e\n  location            = azurerm_resource_group.\u003cspan class=\"hljs-property\"\u003emain\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003elocation\u003c/span\u003e\n  resource_group_name = azurerm_resource_group.\u003cspan class=\"hljs-property\"\u003emain\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e\n  ip_address_type     = \u003cspan class=\"hljs-string\"\u003e\"public\"\u003c/span\u003e\n  dns_name_label      = \u003cspan class=\"hljs-string\"\u003e\"app-aci\"\u003c/span\u003e\n  os_type             = \u003cspan class=\"hljs-string\"\u003e\"Linux\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e  container {\n    name   = \u003cspan class=\"hljs-string\"\u003e\"app\"\u003c/span\u003e\n    image  = \u003cspan class=\"hljs-string\"\u003e\"myapp:v1\"\u003c/span\u003e\n    cpu    = \u003cspan class=\"hljs-string\"\u003e\"1\"\u003c/span\u003e\n    memory = \u003cspan class=\"hljs-string\"\u003e\"1\"\u003c/span\u003e\n    ports {\n      port     = \u003cspan class=\"hljs-number\"\u003e80\u003c/span\u003e\n      protocol = \u003cspan class=\"hljs-string\"\u003e\"TCP\"\u003c/span\u003e\n    }\n  }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e아마존 ECS 클러스터 및 서비스:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eresource \u003cspan class=\"hljs-string\"\u003e\"aws_ecs_cluster\"\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"main\"\u003c/span\u003e {\n  name = \u003cspan class=\"hljs-string\"\u003e\"myapp-cluster\"\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eresource \u003cspan class=\"hljs-string\"\u003e\"aws_ecs_service\"\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"web\"\u003c/span\u003e {\n  name            = \u003cspan class=\"hljs-string\"\u003e\"web\"\u003c/span\u003e\n  cluster         = aws_ecs_cluster.\u003cspan class=\"hljs-property\"\u003emain\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eid\u003c/span\u003e\n  task_definition = aws_ecs_task_definition.\u003cspan class=\"hljs-property\"\u003eapp\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003earn\u003c/span\u003e\n  desired_count   = \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e\n  launch_type     = \u003cspan class=\"hljs-string\"\u003e\"FARGATE\"\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e로드 밸런싱\u003c/p\u003e\n\u003cp\u003e각 클라우드에 백엔드가 있는 글로벌 로드 밸런서를 배포하십시오:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eresource \u003cspan class=\"hljs-string\"\u003e\"aws_lb\"\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"web\"\u003c/span\u003e {\n  name               = \u003cspan class=\"hljs-string\"\u003e\"myapp-lb\"\u003c/span\u003e\n  internal           = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e\n\n  subnets = [\n    aws_subnet.\u003cspan class=\"hljs-property\"\u003epublic\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eid\u003c/span\u003e\n  ]\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eresource \u003cspan class=\"hljs-string\"\u003e\"azurerm_lb\"\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"web\"\u003c/span\u003e {\n  name                = \u003cspan class=\"hljs-string\"\u003e\"myapp-lb\"\u003c/span\u003e\n  location            = azurerm_resource_group.\u003cspan class=\"hljs-property\"\u003emain\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003elocation\u003c/span\u003e\n  resource_group_name = azurerm_resource_group.\u003cspan class=\"hljs-property\"\u003emain\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e\n\n  frontend_ip_configuration {\n    name                 = \u003cspan class=\"hljs-string\"\u003e\"public\"\u003c/span\u003e\n    public_ip_address_id = azurerm_public_ip.\u003cspan class=\"hljs-property\"\u003emain\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eid\u003c/span\u003e\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eMarkdown 포맷으로 DNS\u003c/p\u003e\n\u003cp\u003e로드 밸런서를 통해 단일 도메인을 라우팅합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eresource \u003cspan class=\"hljs-string\"\u003e\"aws_route53_zone\"\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"main\"\u003c/span\u003e {\n  name = \u003cspan class=\"hljs-string\"\u003e\"myapp.com\"\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eresource \u003cspan class=\"hljs-string\"\u003e\"aws_route53_record\"\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"webapp\"\u003c/span\u003e {\n  zone_id = aws_route53_zone.\u003cspan class=\"hljs-property\"\u003emain\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eid\u003c/span\u003e\n  name    = \u003cspan class=\"hljs-string\"\u003e\"webapp.myapp.com\"\u003c/span\u003e\n  type = \u003cspan class=\"hljs-string\"\u003e\"CNAME\"\u003c/span\u003e\n  ttl  = \u003cspan class=\"hljs-string\"\u003e\"300\"\u003c/span\u003e\n  records = [aws_lb.\u003cspan class=\"hljs-property\"\u003eweb\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003edns_name\u003c/span\u003e]\n}\nresource \u003cspan class=\"hljs-string\"\u003e\"azurerm_dns_cname_record\"\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"webapp\"\u003c/span\u003e {\n  name                = \u003cspan class=\"hljs-string\"\u003e\"webapp\"\u003c/span\u003e\n  zone_name           = azurerm_dns_zone.\u003cspan class=\"hljs-property\"\u003emain\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e\n  resource_group_name = azurerm_resource_group.\u003cspan class=\"hljs-property\"\u003emain\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e\n  ttl                 = \u003cspan class=\"hljs-number\"\u003e300\u003c/span\u003e\n  record              = azurerm_lb.\u003cspan class=\"hljs-property\"\u003eweb\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003efqdn\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이는 웹 애플리케이션을 다중 클라우드에서 실행하기 위한 핵심 인프라를 제공하며, 로드 밸런싱과 DNS를 통해 연결됩니다.\u003c/p\u003e\n\u003cp\u003e테라폼 추상화는 우리에게 클라우드 플랫폼 간에 일관된 방식으로 아키텍처를 표현할 수 있는 기회를 제공합니다. 배포를 확장하고 필요에 따라 데이터베이스, 객체 저장소 및 캐시와 같은 추가 구성 요소를 추가할 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003e이 블로그에서는 테라폼을 사용하여 다중 클라우드 인프라, 네트워킹, 배포, 테스트 및 모니터링을 관리하는 패턴과 모범 사례를 다루었습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e추상화 — 추상화된 공급자 및 리소스를 사용하여 이식 가능한 구성물 생성\u003c/li\u003e\n\u003cli\u003e모듈 — 복잡한 구성 요소를 재사용 가능한 모듈로 캡슐화\u003c/li\u003e\n\u003cli\u003e상태 — 협업 가능하도록 원격 상태 저장\u003c/li\u003e\n\u003cli\u003e네트워킹 — VPC와 VNET 간의 연결성 조정\u003c/li\u003e\n\u003cli\u003e배포 — 블루-그린, 카나리아, 다중 지역 패턴 사용\u003c/li\u003e\n\u003cli\u003e테스트 — 테스트 환경의 자동 프로비저닝\u003c/li\u003e\n\u003cli\u003e가시성 — 로그, 메트릭 및 추적을 중앙 집중화\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e테라폼은 각종 공용 클라우드, 개인 데이터 센터 및 SaaS 환경에서 인프라를 프로비저닝하고 관리하기 위한 일관된 워크플로우를 제공합니다. 이 가이드에서 다룬 패턴을 사용하면 다양한 API, 플랫폼 및 토폴로지를 연결하여 다중 클라우드 자동화 및 오케스트레이션을 더 쉽게 구현할 수 있습니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-27-MasteringMulti-CloudManagementwithTerraform"},"buildId":"o1YmnmSuZvAX2O4TI9r41","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>