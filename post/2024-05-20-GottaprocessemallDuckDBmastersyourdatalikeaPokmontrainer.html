<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>모두 처리해야 해요  DuckDB가 데이터를 마스터하는 방법을 포켓몬 트레이너처럼 소개합니다 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-05-20-GottaprocessemallDuckDBmastersyourdatalikeaPokmontrainer" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="모두 처리해야 해요  DuckDB가 데이터를 마스터하는 방법을 포켓몬 트레이너처럼 소개합니다 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="모두 처리해야 해요  DuckDB가 데이터를 마스터하는 방법을 포켓몬 트레이너처럼 소개합니다 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-20-GottaprocessemallDuckDBmastersyourdatalikeaPokmontrainer_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-05-20-GottaprocessemallDuckDBmastersyourdatalikeaPokmontrainer" data-gatsby-head="true"/><meta name="twitter:title" content="모두 처리해야 해요  DuckDB가 데이터를 마스터하는 방법을 포켓몬 트레이너처럼 소개합니다 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-20-GottaprocessemallDuckDBmastersyourdatalikeaPokmontrainer_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-20 18:56" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-V5DKFTZ6BX"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-V5DKFTZ6BX');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/cd012fc8787133d0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cd012fc8787133d0.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/551-3069cf29fe274aab.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-561ae49ab5aab7f5.js" defer=""></script><script src="/_next/static/PgdIX9e0tvkvkdAmDT6qR/_buildManifest.js" defer=""></script><script src="/_next/static/PgdIX9e0tvkvkdAmDT6qR/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">모두 처리해야 해요  DuckDB가 데이터를 마스터하는 방법을 포켓몬 트레이너처럼 소개합니다</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="모두 처리해야 해요  DuckDB가 데이터를 마스터하는 방법을 포켓몬 트레이너처럼 소개합니다" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 20, 2024</span><span class="posts_reading_time__f7YPP">16<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-20-GottaprocessemallDuckDBmastersyourdatalikeaPokmontrainer&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><h2>DuckDB을 데이터 처리 도구로 사용하는 실용적인 예제</h2>
<ul>
<li>소개</li>
<li>API 개요<!-- -->
<ul>
<li>포켓몬 가져오기</li>
<li>포켓몬 세부 정보 가져오기</li>
</ul>
</li>
<li>프로젝트 설정</li>
<li>데모 1: 간단한 선택</li>
<li>데모 2: API에서 JSON 읽기</li>
<li>데모 3: Unnest</li>
<li>데모 4: 세부 정보 가져오는 UDF</li>
<li>데모 5: 목록 표현식</li>
<li>데모 6: DuckDB를 Pandas로 변환하고 다시 변환하기</li>
<li>데모 7: 데이터 유지 및 로드</li>
<li>결론</li>
</ul>
<h1>소개</h1>
<p>캉토 지방을 탐험하여 놀라운 생물을 포획하고 훈련하는 포켓몬 트레이너가 되는 꿈을 꾸어 본 적이 있나요? 90년대에 Game Boy에서 포켓몬 레드 버전과 포켓몬 블루 버전을 즐길 때, 제가 확실히 꾸었던 꿈입니다.</p>
<div class="content-ad"></div>
<p>포켓몬 비디오 게임 시리즈가 시간이 지남에 따라 얼마나 인기 있어졌고 지금도 그랬는지 정말 놀라운 일이에요. 마치 비디오 게임 산업에서 떠오르는 별처럼 말이죠. 그 얘기를 하자면: DuckDB, 진행 중인 SQL 분석 엔진, 지난 몇 년간 데이터 엔지니어링 커뮤니티에서 떠오르는 별처럼 인기를 끌었어요.</p>
<p><a href="/assets/img/2024-05-20-GottaprocessemallDuckDBmastersyourdatalikeaPokmontrainer_0.png">이미지</a></p>
<p>마치 포켓몬 트레이너가 전투를 위해 완벽한 팀을 선택하는 것처럼, 경험이 풍부한 데이터 엔지니어는 작업에 적합한 올바른 도구를 선택하는 중요성을 알아요. 본 문서를 통해 DuckDB가 여러분의 도구 상자에 완벽한 도구가 될 이유를 보여드리고 싶어요.</p>
<p>DuckDB는 큰 데이터베이스와 매끄럽게 통합되어 인메모리 및 영속적 저장 솔루션 사이의 원활한 전환을 도와줘요. 마치 어떤 도전이든 쉽게 적응하는 다재다능한 포켓몬과 같죠. 작은 데이터 세트를 빠르게 분석해야 한다면? DuckDB는 여러분의 마초크, 쉽게 과업을 수행할 준비가 돼 있어요. 더 강력한 처리가 필요한 대규모 데이터 세트와 작업하고 있다면? DuckDB는 마샴으로 변신하여 과중한 분석을 위해 외부 데이터베이스에 매끄럽게 연결할 수 있어요.</p>
<div class="content-ad"></div>
<p>DuckDB를 설치하기 쉽고 휴대용이며 오픈 소스입니다. SQL 방언 측면에서 기능이 풍부하고 CSV, Parquet 및 JSON과 같은 다양한 형식을 기준으로 데이터를 가져오고 내보낼 수 있습니다. 또한 Pandas 데이터프레임과 원활하게 통합되어 데이터 조작 스크립트에서 강력한 데이터 조작 도구로 사용할 수 있습니다.</p>
<p>다음 장에서는 DuckDB를 사용하여 Pokémon API를 활용해 데이터를 처리하는 방법을 예시로 살펴보며 강력한 기능을 보여줄 것입니다.</p>
<p><img src="/assets/img/2024-05-20-GottaprocessemallDuckDBmastersyourdatalikeaPokmontrainer_1.png" alt="이미지"/></p>
<h2>API 개요</h2>
<div class="content-ad"></div>
<p>포켓몬 API는 포켓몬 비디오 게임 시리즈와 관련된 JSON 데이터에 대한 RESTful API 인터페이스를 제공합니다. 이 API를 사용하면 포켓몬, 그들의 기술, 능력, 유형 등에 대한 정보를 소비할 수 있습니다.</p>
<p>이 기사는 주로 DuckDB 기능에 초점을 맞춰야 하므로 일부 엔드포인트만 사용할 것입니다. 개요를 얻기 위해 curl과 jq를 사용하여 관련 엔드포인트를 탐색해 보겠습니다. jq를 잘 모르는 경우, 이것은 터미널에서 JSON을 필터링, 수정 또는 간단히 형식화하는 많은 기능을 가진 경량 CLI JSON 프로세서입니다. macOS를 사용하고 Homebrew를 사용 중이라면 brew install jq를 통해 jq를 설치할 수 있습니다.</p>
<h2>포켓몬 가져오기</h2>
<pre><code class="hljs language-js">curl -s <span class="hljs-attr">https</span>:<span class="hljs-comment">//pokeapi.co/api/v2/pokemon/ | jq .</span>
</code></pre>
<div class="content-ad"></div>
<pre><code class="hljs language-js">{
  <span class="hljs-string">&quot;count&quot;</span>: <span class="hljs-number">1302</span>,
  <span class="hljs-string">&quot;next&quot;</span>: <span class="hljs-string">&quot;https://pokeapi.co/api/v2/pokemon/?offset=20&amp;limit=20&quot;</span>,
  <span class="hljs-string">&quot;previous&quot;</span>: <span class="hljs-literal">null</span>,
  <span class="hljs-string">&quot;results&quot;</span>: [
    {
      <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;bulbasaur&quot;</span>,
      <span class="hljs-string">&quot;url&quot;</span>: <span class="hljs-string">&quot;https://pokeapi.co/api/v2/pokemon/1/&quot;</span>
    },
    {
      <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;ivysaur&quot;</span>,
      <span class="hljs-string">&quot;url&quot;</span>: <span class="hljs-string">&quot;https://pokeapi.co/api/v2/pokemon/2/&quot;</span>
    },
    ...
</code></pre>
<p><img src="/assets/img/2024-05-20-GottaprocessemallDuckDBmastersyourdatalikeaPokmontrainer_2.png" alt="Gotta Process Em All: DuckDB masters your data like a Pokémon trainer"/></p>
<h2>포켓몬 세부 정보 가져오기</h2>
<pre><code class="hljs language-js">curl -s <span class="hljs-attr">https</span>:<span class="hljs-comment">//pokeapi.co/api/v2/pokemon/bulbasaur | jq .</span>
</code></pre>
<div class="content-ad"></div>
<pre><code class="hljs language-json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">&quot;abilities&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
    <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">&quot;ability&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
        <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;overgrow&quot;</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">&quot;url&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;https://pokeapi.co/api/v2/ability/65/&quot;</span>
      <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">&quot;is_hidden&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">&quot;slot&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span>
    <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
    ...
  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">&quot;base_experience&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">64</span><span class="hljs-punctuation">,</span>
  ...
</code></pre>
<p><img src="/assets/img/2024-05-20-GottaprocessemallDuckDBmastersyourdatalikeaPokmontrainer_3.png" alt="Screenshot"/></p>
<h1>프로젝트 설정</h1>
<p>새로운 Python 프로젝트를 만들기 시작합니다. 이를 위해 새 폴더를 만듭니다. 이 폴더 내에서 내장된 venv 모듈을 사용하여 가상 환경을 생성합니다:```</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js">mkdir duckdb-pokemon
cd duckdb-pokemon
python -m venv .<span class="hljs-property">venv</span>
source .<span class="hljs-property">venv</span>/bin/activate
</code></pre>
<p>마지막 명령으로 가상 환경을 활성화했습니다. 이는 현재 터미널 세션에서는 시스템 전역 Python 대신 가상 Python을 사용한다는 의미입니다. 이것은 다음에 설치할 종속성을 프로젝트 내에서 격리시키려는 우리의 목적상 중요합니다. 다음 단계는 모든 요구 사항을 설치하는 것입니다:</p>
<pre><code class="hljs language-js">pip install duckdb
pip install pandas
pip install requests
</code></pre>
<p>여기까지 준비가 되었습니다. 다음 장에서는 포켓몬 API를 활용한 DuckDB의 일부 기능을 살펴볼 것입니다. 이 코드를 프로젝트 내의 Python 파일로 복사하여 실행할 수 있습니다.```</p>
<div class="content-ad"></div>
<h1>데모 1: 간단한 선택</h1>
<p>첫 번째 데모는 시작하는 방법이 얼마나 간단한지 보여줍니다. DuckDB를 pip install duckdb로 설치한 후에는 직접 가져와서 SQL 문을 실행할 수 있습니다. 복잡한 데이터베이스 설정이나 다른 요구 사항이 없습니다. 광고대로, 이것은 빠른 내장형 분석용 데이터베이스입니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> duckdb

duckdb.<span class="hljs-title function_">sql</span>(<span class="hljs-string">&quot;SELECT 42&quot;</span>).<span class="hljs-title function_">show</span>()
</code></pre>
<p>이 코드를 실행하면 예상한 출력인 하나의 열과 하나의 행이 포함된 값 42를 가진 테이블을 얻을 수 있습니다. 이는 삶, 우주, 그리고 모든 것에 대한 궁극적인 질문의 답입니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js">┌───────┐
│  <span class="hljs-number">42</span>   │
│ int32 │
├───────┤
│    <span class="hljs-number">42</span> │
└───────┘
</code></pre>
<h1>데모 2: API로부터 JSON 읽기</h1>
<p>이제 상황이 급속하게 변화할 것이니, 포켓몬볼을 준비해두세요. 일반적으로 API에서 JSON 데이터를 가져올 때, requests.get을 시작으로 클라이언트 로직을 구현하여 데이터를 데이터베이스에로드하거나 Pandas와 같은 데이터 처리 프레임워크를 사용할 수 있습니다. 다음 예제는 당신을 확실히 놀라게 할 것입니다. 우리는 데이터를 가져와 SQL을 사용하여 직접 테이블로 만들 것입니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> duckdb

duckdb.<span class="hljs-title function_">sql</span>(<span class="hljs-string">&quot;&quot;</span><span class="hljs-string">&quot;
    CREATE TABLE pokemon AS
    SELECT *
    FROM read_json_auto(&#x27;https://pokeapi.co/api/v2/pokemon?limit=1000&#x27;);

    SELECT * FROM pokemon;
&quot;</span><span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">show</span>()
</code></pre>
<div class="content-ad"></div>
<p>read_json_auto를 사용하면 JSON 데이터를로드하는 가장 간단한 방법을 사용할 수 있습니다. 이는 JSON 리더를 자동으로 구성하고 데이터에서 열 유형을 파생합니다.</p>
<p>위의 코드는 API의 해당 응답에 따라 네 개의 열이 있는 테이블을 제공합니다. 즉: count, next, previous, results이며, results는 구조체의 목록이며 각 구조체는 이름과 URL이 포함된 포켓몬으로 구성됩니다.</p>
<p>유연성은 DuckDB가 정말 빛나는 곳입니다. DuckDB는 여러분의 신속한 피카츄이며 JSON 데이터를로드하는 것은 단지 한 가지 예입니다. CSV 파일이나 심지어 하이브 파티셔닝이 있는 Parquet 파일에서 데이터를 읽을 수도 있습니다:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-variable constant_">SELECT</span> *
<span class="hljs-variable constant_">FROM</span> <span class="hljs-title function_">read_parquet</span>(<span class="hljs-string">&quot;some_table/*/*/*.parquet&quot;</span>, hive_partitioning = <span class="hljs-literal">true</span>);
</code></pre>
<p>또는 Pandas 데이터프레임에서 데이터를 직접 읽어보세요:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-keyword">import</span> duckdb

df = pd.<span class="hljs-title class_">DataFrame</span>({<span class="hljs-string">&quot;some_values&quot;</span> : [<span class="hljs-number">42</span>, <span class="hljs-number">7411</span>, <span class="hljs-number">4</span>]})
<span class="hljs-title function_">print</span>(duckdb.<span class="hljs-title function_">query</span>(<span class="hljs-string">&quot;SELECT SUM(some_values) FROM df&quot;</span>).<span class="hljs-title function_">to_df</span>())
</code></pre>
<p>하지만 일단은 포켓몬으로 계속해 봅시다.```</p>
<div class="content-ad"></div>
<h1>데모 3: Unnest</h1>
<p>이전 예제에서 결과, 즉 실제 포켓몬은 모두 한 행과 열 안에 구조체 목록 형식으로 있습니다. 그러나 추가 처리를 위해 각 포켓몬 당 하나의 행을 원합니다. 이를 위해 unnest 함수를 사용할 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> duckdb

duckdb.<span class="hljs-title function_">sql</span>(<span class="hljs-string">&quot;&quot;</span><span class="hljs-string">&quot;
    CREATE TABLE pokemon AS
    SELECT unnest(results) AS pokemon
    FROM read_json_auto(&#x27;https://pokeapi.co/api/v2/pokemon?limit=1000&#x27;);

    SELECT
        pokemon.name,
        pokemon.url
    FROM pokemon;
&quot;</span><span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">show</span>()
</code></pre>
<p>포켓몬 당 한 행씩 이름 및 URL이 포함된 결과를 얻을 수 있습니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js">┌──────────────┬─────────────────────────────────────────┐
│     name     │                   url                   │
│   varchar    │                 varchar                 │
├──────────────┼─────────────────────────────────────────┤
│ bulbasaur    │ <span class="hljs-attr">https</span>:<span class="hljs-comment">//pokeapi.co/api/v2/pokemon/1/    │</span>
│ ivysaur      │ <span class="hljs-attr">https</span>:<span class="hljs-comment">//pokeapi.co/api/v2/pokemon/2/    │</span>
│ venusaur     │ <span class="hljs-attr">https</span>:<span class="hljs-comment">//pokeapi.co/api/v2/pokemon/3/    │</span>
│    ·         │                   ·                     │
│    ·         │                   ·                     │
│ baxcalibur   │ <span class="hljs-attr">https</span>:<span class="hljs-comment">//pokeapi.co/api/v2/pokemon/998/  │</span>
│ gimmighoul   │ <span class="hljs-attr">https</span>:<span class="hljs-comment">//pokeapi.co/api/v2/pokemon/999/  │</span>
│ gholdengo    │ <span class="hljs-attr">https</span>:<span class="hljs-comment">//pokeapi.co/api/v2/pokemon/1000/ │</span>
├──────────────┴─────────────────────────────────────────┤
│ <span class="hljs-number">1000</span> rows (<span class="hljs-number">20</span> shown)                         <span class="hljs-number">2</span> columns │
└────────────────────────────────────────────────────────┘
</code></pre>
<h1>데모 4: 세부 정보 가져오기를 위한 UDF</h1>
<p>피카츄를 라이츄로 진화시킬 수 있을까요? 물론 가능합니다! 이전 예제의 결과를 사용하면, url이라는 열을 가지고 있어 각 포켓몬에 대한 더 많은 세부 정보를 얻기 위해 요청해야 합니다. read_json_auto와 같은 함수는 테이블 수준 함수이기 때문에 각 행에 적용할 수 없습니다.</p>
<p>DuckDB는 Python과 완벽하게 통합되어 있어 열에 있는 각 url 값에 대해 간단히 Python 함수를 호출할 수 있는 방법이 있습니다. 이는 다른 데이터베이스 시스템에서 알 수 있는 사용자 정의 함수(UDF)와 유사합니다.```</p>
<div class="content-ad"></div>
<p>API로부터 데이터를 가져오기 위해 파이썬 함수를 정의해야 합니다:</p>
<pre><code class="hljs language-python"><span class="hljs-keyword">import</span> requests

<span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">url</span>):
    <span class="hljs-keyword">return</span> requests.get(url).text
</code></pre>
<p>그런 다음 DuckDB에 등록해야 합니다:</p>
<pre><code class="hljs language-python"><span class="hljs-keyword">from</span> duckdb.typing <span class="hljs-keyword">import</span> VARCHAR

duckdb.create_function(<span class="hljs-string">&quot;get&quot;</span>, get, [VARCHAR], VARCHAR)
</code></pre>
<div class="content-ad"></div>
<p>create_function을 사용할 때는 SQL 스크립트에서 UDF에 참조할 이름을 지정해야 합니다. 또한 호출할 실제 Python 함수와 매개변수 유형 및 반환 유형 목록을 전달해야 합니다.</p>
<p>그런 다음 SQL에서 다음과 같이 사용할 수 있습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-title function_">json</span>(<span class="hljs-title function_">get</span>(pokemon.<span class="hljs-property">url</span>)) <span class="hljs-variable constant_">AS</span> details
</code></pre>
<p>다시 말해, 우리는 포켓몬 목록에서 각 pokemon.url에 대해 Python 함수 get을 호출합니다. 우리가 얻는 것은 JSON 응답 텍스트이며, json 함수를 사용하여 적절한 유형의 결과를 얻습니다.</p>
<div class="content-ad"></div>
<p>다음은 스스로 시도해볼 수 있는 최종 코드입니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> duckdb
<span class="hljs-keyword">import</span> requests
<span class="hljs-keyword">from</span> duckdb.<span class="hljs-property">typing</span> <span class="hljs-keyword">import</span> <span class="hljs-variable constant_">VARCHAR</span>


def <span class="hljs-title function_">get</span>(url):
    <span class="hljs-keyword">return</span> requests.<span class="hljs-title function_">get</span>(url).<span class="hljs-property">text</span>


duckdb.<span class="hljs-title function_">create_function</span>(<span class="hljs-string">&quot;get&quot;</span>, get, [<span class="hljs-variable constant_">VARCHAR</span>], <span class="hljs-variable constant_">VARCHAR</span>)
duckdb.<span class="hljs-title function_">sql</span>(<span class="hljs-string">&quot;&quot;</span><span class="hljs-string">&quot;
    CREATE TABLE pokemon AS
    SELECT unnest(results) AS pokemon
    FROM read_json_auto(&#x27;https://pokeapi.co/api/v2/pokemon?limit=10&#x27;);

    WITH base AS (
        SELECT
            pokemon.name AS name,
            json(get(pokemon.url)) AS details
        FROM pokemon
    )
    SELECT *
    FROM base;
&quot;</span><span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">show</span>()
</code></pre>
<p>각 포켓몬에 대해 API를 호출하므로 실행에 몇 초가 걸릴 수 있습니다. 결과는 이름과 모든 세부 정보가 JSON으로 표시된 테이블입니다.</p>
<img src="/assets/img/2024-05-20-GottaprocessemallDuckDBmastersyourdatalikeaPokmontrainer_5.png"/>
<div class="content-ad"></div>
<h1>데모 5: 리스트 컴프리헨션</h1>
<p>파이썬의 리스트 컴프리헨션은 제가 가장 좋아하는 기능 중 하나에요. DuckDB에서도 리스트 컴프리헨션을 사용할 수 있어요! 우리의 목표는 세부 정보를 추가 처리하여 개별 열로 추출하는 것이에요. 하지만 모든 세부 정보가 아니라, 포켓몬의 ID, 이름, 키, 그리고 무게만 추출할 거에요.</p>
<p>또한 포켓몬이 사용할 수 있는 능력들을 능력 이름으로 이루어진 간단한 리스트로 줄이고 다른 열에 저장할 거에요.</p>
<p>SQL을 더 읽기 쉽게 만들기 위해, 우리는 공통 테이블 표현식 (CTE)도 사용할 거예요.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-python"><span class="hljs-keyword">import</span> duckdb
<span class="hljs-keyword">import</span> requests
<span class="hljs-keyword">from</span> duckdb.typing <span class="hljs-keyword">import</span> VARCHAR

<span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">url</span>):
    <span class="hljs-keyword">return</span> requests.get(url).text

duckdb.create_function(<span class="hljs-string">&quot;get&quot;</span>, get, [VARCHAR], VARCHAR)
duckdb.sql(<span class="hljs-string">&quot;&quot;&quot;
    CREATE TABLE pokemon AS
    SELECT unnest(results) AS pokemon
    FROM read_json_auto(&#x27;https://pokeapi.co/api/v2/pokemon?limit=10&#x27;);

    WITH base AS (
        SELECT
            pokemon.name AS name,
            json(get(pokemon.url)) AS details
        FROM pokemon
    ), pokemon_details AS (
        SELECT
            details.id,
            name,
            details.abilities::STRUCT(ability STRUCT(name VARCHAR, url VARCHAR), is_hidden BOOLEAN, slot INTEGER)[] AS abilities,
            details.height,
            details.weight
        FROM base
    )
    SELECT
        id,
        name,
        [x.ability.name FOR x IN abilities] AS abilities,
        height,
        weight
    FROM pokemon_details;
&quot;&quot;&quot;</span>).show()
</code></pre>
<p>CTE인 pokemon_details가 필요한 세부 정보를 추출합니다. 그러나 여기에는 한 가지 숨겨진 기능이 더 있습니다: 현재 details 열의 abilities가 JSON 유형이지만 리스트 표현식에는 실제 목록 유형이 필요합니다. 다음 문으로:</p>
<pre><code class="hljs language-python">details.abilities::STRUCT(ability STRUCT(name VARCHAR, url VARCHAR), is_hidden BOOLEAN, slot INTEGER)[] AS abilities,
</code></pre>
<p>abilities의 유형을 구조 목록으로 변환합니다. 각 구조에는 더 자세한 정보를 위해 능력 이름과 URL뿐만 아니라, 숨겨진 플래그와 슬롯 번호를 포함하는 또 다른 구조가 포함됩니다.</p>
<div class="content-ad"></div>
<p>지금 능력은 목록이므로 SQL에서 목록 표현을 적용할 수 있습니다. 이는 기본적으로 파이썬의 목록 표현과 동일하게 작동합니다. 따라서 다음 SQL 코드를 사용해보세요:</p>
<pre><code class="hljs language-js">[x.<span class="hljs-property">ability</span>.<span class="hljs-property">name</span> <span class="hljs-variable constant_">FOR</span> x <span class="hljs-variable constant_">IN</span> abilities] <span class="hljs-variable constant_">AS</span> abilities,
</code></pre>
<p>이를 통해 각 포켓몬이 사용할 수 있는 각 능력의 이름만 포함된 새 목록을 만듭니다.</p>
<pre><code class="hljs language-js">| id   | name       | abilities               | height | weight |
|------|------------|-------------------------|--------|--------|
| <span class="hljs-number">1</span>    | bulbasaur  | [overgrow, chlorophyll] | <span class="hljs-number">7</span>      | <span class="hljs-number">69</span>     |
| <span class="hljs-number">2</span>    | ivysaur    | [overgrow, chlorophyll] | <span class="hljs-number">10</span>     | <span class="hljs-number">130</span>    |
| <span class="hljs-number">3</span>    | venusaur   | [overgrow, chlorophyll] | <span class="hljs-number">20</span>     | <span class="hljs-number">1000</span>   |
| <span class="hljs-number">4</span>    | charmander | [blaze, solar-power]    | <span class="hljs-number">6</span>      | <span class="hljs-number">85</span>     |
| <span class="hljs-number">5</span>    | charmeleon | [blaze, solar-power]    | <span class="hljs-number">11</span>     | <span class="hljs-number">190</span>    |
| <span class="hljs-number">6</span>    | charizard  | [blaze, solar-power]    | <span class="hljs-number">17</span>     | <span class="hljs-number">905</span>    |
| <span class="hljs-number">7</span>    | squirtle   | [torrent, rain-dish]    | <span class="hljs-number">5</span>      | <span class="hljs-number">90</span>     |
| <span class="hljs-number">8</span>    | wartortle  | [torrent, rain-dish]    | <span class="hljs-number">10</span>     | <span class="hljs-number">225</span>    |
| <span class="hljs-number">9</span>    | blastoise  | [torrent, rain-dish]    | <span class="hljs-number">16</span>     | <span class="hljs-number">855</span>    |
| <span class="hljs-number">10</span>   | caterpie   | [shield-dust, run-away] | <span class="hljs-number">3</span>      | <span class="hljs-number">29</span>     |
</code></pre>
<div class="content-ad"></div>
<h1>데모 6: DuckDB에서 Pandas로 그리고 다시 되돌아 오기</h1>
<p>지금쯤이면 DuckDB가 휴대용 분석 데이터베이스뿐만 아니라 다양한 데이터 조작 도구임이 분명해졌을 것입니다.</p>
<p>DuckDB의 핵심은 SQL 기반 작업과 Pandas와 같은 다른 데이터 처리 도구 간에 원활한 통합을 제공합니다. 이 독특한 기능은 데이터 처리 스크립트 내에서 서로 다른 기술 간에 쉽게 전환할 수 있도록 가능하게 합니다.</p>
<p>전혀 SQL에서 데이터 처리를 하거나 Pandas나 NumPy와 같은 전형적인 라이브러리를 사용하여 Python 스크립트 내에서 데이터 정제를 완전히 구현하는 대신, 복잡한 데이터베이스 통합 설정이 필요 없이 이러한 환경 간을 전환할 수 있습니다.</p>
<div class="content-ad"></div>
<p>지금까지의 예제를 기반으로, Pandas를 사용하여 추가 처리를 수행하고 싶다고 가정해 봅시다. DuckDB를 사용하면 SQL 쿼리의 결과를 데이터프레임으로 쉽게 내보낼 수 있습니다. .df() 함수를 사용하면 됩니다.</p>
<p>또한 DuckDB를 사용하면 Pandas 데이터프레임에서 직접 데이터를 쿼리할 수도 있습니다!</p>
<pre><code class="hljs language-python"><span class="hljs-keyword">import</span> duckdb
<span class="hljs-keyword">import</span> requests
<span class="hljs-keyword">from</span> duckdb.typing <span class="hljs-keyword">import</span> VARCHAR

<span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">url</span>):
    <span class="hljs-keyword">return</span> requests.get(url).text

duckdb.create_function(<span class="hljs-string">&quot;get&quot;</span>, get, [VARCHAR], VARCHAR)

<span class="hljs-comment"># DuckDB에서 작업 시작</span>
df = duckdb.sql(<span class="hljs-string">&quot;&quot;&quot;
    CREATE TABLE pokemon AS
    SELECT unnest(results) AS pokemon
    FROM read_json_auto(&#x27;https://pokeapi.co/api/v2/pokemon?limit=10&#x27;);

    WITH base AS (
        SELECT
            pokemon.name AS name,
            json(get(pokemon.url)) AS details
        FROM pokemon
    ), pokemon_details AS (
        SELECT
            details.id,
            name,
            details.abilities::STRUCT(ability STRUCT(name VARCHAR, url VARCHAR), is_hidden BOOLEAN, slot INTEGER)[] AS abilities,
            details.height,
            details.weight
        FROM base
    )
    SELECT
        id,
        name,
        [x.ability.name FOR x IN abilities] AS abilities,
        height,
        weight
    FROM pokemon_details;
&quot;&quot;&quot;</span>).df()

<span class="hljs-comment"># Pandas에서 데이터 처리 계속</span>
df_agg = df.explode(<span class="hljs-string">&quot;abilities&quot;</span>).groupby(<span class="hljs-string">&quot;abilities&quot;</span>, as_index=<span class="hljs-literal">False</span>).agg(count=(<span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-string">&quot;count&quot;</span>))

<span class="hljs-comment"># DuckDB로 돌아가기</span>
duckdb.sql(<span class="hljs-string">&quot;&quot;&quot;
    SELECT abilities AS ability, count
    FROM df_agg
    ORDER BY count DESC
    LIMIT 8;
&quot;&quot;&quot;</span>).show()
</code></pre>
<p>위 코드는 다음 결과를 출력합니다:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js">┌─────────────┬───────┐
│   능력       │ 개수  │
│   varchar   │ int64 │
├─────────────┼───────┤
│ blaze       │     <span class="hljs-number">3</span> │
│ chlorophyll │     <span class="hljs-number">3</span> │
│ overgrow    │     <span class="hljs-number">3</span> │
│ rain-dish   │     <span class="hljs-number">3</span> │
│ solar-power │     <span class="hljs-number">3</span> │
│ torrent     │     <span class="hljs-number">3</span> │
│ run-away    │     <span class="hljs-number">1</span> │
│ shield-dust │     <span class="hljs-number">1</span> │
└─────────────┴───────┘
</code></pre>
<p>앞서 언급한 대로, .df()를 사용하면 SQL 결과를 Pandas 데이터프레임으로 얻을 수 있습니다. 그런 다음 다음과 같이 추가적인 변환을 적용할 수 있습니다.</p>
<pre><code class="hljs language-js">df_agg = df.<span class="hljs-title function_">explode</span>(<span class="hljs-string">&quot;abilities&quot;</span>).<span class="hljs-title function_">groupby</span>(<span class="hljs-string">&quot;abilities&quot;</span>, as_index=<span class="hljs-title class_">False</span>).<span class="hljs-title function_">agg</span>(count=(<span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-string">&quot;count&quot;</span>))
</code></pre>
<p>그리고 df_agg 변수에 저장된 데이터프레임을 SQL에서 사용할 수 있습니다. 처음 보았을 때 정말 놀랐던 부분이죠.```</p>
<div class="content-ad"></div>
<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> abilities <span class="hljs-keyword">AS</span> ability, count
<span class="hljs-keyword">FROM</span> df_agg
<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> count <span class="hljs-keyword">DESC</span>
LIMIT <span class="hljs-number">8</span>;
</code></pre>
<p>데이터 처리 도구로 DuckDB가 좋은 도구인 이유는 어떤 접착 코드도 추가하지 않기 때문입니다.</p>
<h1>데모 7: 데이터 유지 및 로드</h1>
<p>매번 실행할 때마다 API를 호출하는 것은 가장 효율적인 해결책은 아닙니다. 물론 결과를 기다리는 동안 맛있는 커피 한 잔을 마실 수 있는 기회를 제공하지만, DuckDB는 데이터를 유지할 수도 있습니다. 예를 들어 데이터를 파일로 직렬화하여 파일 시스템에 저장할 수 있습니다.```</p>
<div class="content-ad"></div>
<p>위의 예제를 다음 코드와 함께 확장해 봅시다:</p>
<pre><code class="hljs language-js"># 판다스에서 데이터 처리 계속하기
df_agg = df.<span class="hljs-title function_">explode</span>(<span class="hljs-string">&quot;abilities&quot;</span>).<span class="hljs-title function_">groupby</span>(<span class="hljs-string">&quot;abilities&quot;</span>, as_index=<span class="hljs-title class_">False</span>).<span class="hljs-title function_">agg</span>(count=(<span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-string">&quot;count&quot;</span>))

# 데이터 유지하기
<span class="hljs-keyword">with</span> duckdb.<span class="hljs-title function_">connect</span>(database=<span class="hljs-string">&quot;pokemon.db&quot;</span>) <span class="hljs-keyword">as</span> <span class="hljs-attr">conn</span>:
    conn.<span class="hljs-title function_">sql</span>(<span class="hljs-string">&quot;&quot;</span><span class="hljs-string">&quot;
        DROP TABLE IF EXISTS pokemon_abilities;
        CREATE TABLE pokemon_abilities AS
        SELECT abilities AS ability, count
        FROM df_agg
        ORDER BY count DESC;
    &quot;</span><span class="hljs-string">&quot;&quot;</span>)
</code></pre>
<p>우리는 pokemon.db라는 파일에 연결을 열고 데이터를 저장합니다.</p>
<div class="content-ad"></div>
<p>다른 스크립트에서 데이터를로드하고 사전 처리 된 데이터에 액세스 할 수 있습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> duckdb

# 데이터 로드
<span class="hljs-keyword">with</span> duckdb.<span class="hljs-title function_">connect</span>(database=<span class="hljs-string">&quot;pokemon.db&quot;</span>) <span class="hljs-keyword">as</span> <span class="hljs-attr">conn</span>:
    conn.<span class="hljs-title function_">sql</span>(<span class="hljs-string">&quot;&quot;</span><span class="hljs-string">&quot;
        SELECT * FROM pokemon_abilities;
    &quot;</span><span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">show</span>()
</code></pre>
<img src="/assets/img/2024-05-20-GottaprocessemallDuckDBmastersyourdatalikeaPokmontrainer_7.png"/>
<h1>결론</h1>
<div class="content-ad"></div>
<p>DuckDB은 데이터 처리 도전에서 강력한 동료로 나타났습니다. Pandas 데이터프레임과 고급 분석 SQL 기능과의 매끄러운 통합을 제공하여 자원 제한적 환경에서 분석 작업에 적합함을 강조했습니다.</p>
<p><a href="https://github.com/vojay-dev/duckdb-pokemon">Github</a>에서 모든 데모를 찾을 수 있어요! 🪄</p>
<p>DuckDB가 함께하면 금방 성공적인 포켓몬 트레이너가 될 거에요!</p>
<img src="/assets/img/2024-05-20-GottaprocessemallDuckDBmastersyourdatalikeaPokmontrainer_8.png"/>
<div class="content-ad"></div>
<p>경험을 공유해주시고 즐거운 독서를 즐기세요!</p></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"모두 처리해야 해요  DuckDB가 데이터를 마스터하는 방법을 포켓몬 트레이너처럼 소개합니다","description":"","date":"2024-05-20 18:56","slug":"2024-05-20-GottaprocessemallDuckDBmastersyourdatalikeaPokmontrainer","content":"\n\n## DuckDB을 데이터 처리 도구로 사용하는 실용적인 예제\n\n- 소개\n- API 개요\n  - 포켓몬 가져오기\n  - 포켓몬 세부 정보 가져오기\n- 프로젝트 설정\n- 데모 1: 간단한 선택\n- 데모 2: API에서 JSON 읽기\n- 데모 3: Unnest\n- 데모 4: 세부 정보 가져오는 UDF\n- 데모 5: 목록 표현식\n- 데모 6: DuckDB를 Pandas로 변환하고 다시 변환하기\n- 데모 7: 데이터 유지 및 로드\n- 결론\n\n# 소개\n\n캉토 지방을 탐험하여 놀라운 생물을 포획하고 훈련하는 포켓몬 트레이너가 되는 꿈을 꾸어 본 적이 있나요? 90년대에 Game Boy에서 포켓몬 레드 버전과 포켓몬 블루 버전을 즐길 때, 제가 확실히 꾸었던 꿈입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n포켓몬 비디오 게임 시리즈가 시간이 지남에 따라 얼마나 인기 있어졌고 지금도 그랬는지 정말 놀라운 일이에요. 마치 비디오 게임 산업에서 떠오르는 별처럼 말이죠. 그 얘기를 하자면: DuckDB, 진행 중인 SQL 분석 엔진, 지난 몇 년간 데이터 엔지니어링 커뮤니티에서 떠오르는 별처럼 인기를 끌었어요.\n\n[이미지](/assets/img/2024-05-20-GottaprocessemallDuckDBmastersyourdatalikeaPokmontrainer_0.png)\n\n마치 포켓몬 트레이너가 전투를 위해 완벽한 팀을 선택하는 것처럼, 경험이 풍부한 데이터 엔지니어는 작업에 적합한 올바른 도구를 선택하는 중요성을 알아요. 본 문서를 통해 DuckDB가 여러분의 도구 상자에 완벽한 도구가 될 이유를 보여드리고 싶어요.\n\nDuckDB는 큰 데이터베이스와 매끄럽게 통합되어 인메모리 및 영속적 저장 솔루션 사이의 원활한 전환을 도와줘요. 마치 어떤 도전이든 쉽게 적응하는 다재다능한 포켓몬과 같죠. 작은 데이터 세트를 빠르게 분석해야 한다면? DuckDB는 여러분의 마초크, 쉽게 과업을 수행할 준비가 돼 있어요. 더 강력한 처리가 필요한 대규모 데이터 세트와 작업하고 있다면? DuckDB는 마샴으로 변신하여 과중한 분석을 위해 외부 데이터베이스에 매끄럽게 연결할 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nDuckDB를 설치하기 쉽고 휴대용이며 오픈 소스입니다. SQL 방언 측면에서 기능이 풍부하고 CSV, Parquet 및 JSON과 같은 다양한 형식을 기준으로 데이터를 가져오고 내보낼 수 있습니다. 또한 Pandas 데이터프레임과 원활하게 통합되어 데이터 조작 스크립트에서 강력한 데이터 조작 도구로 사용할 수 있습니다.\n\n다음 장에서는 DuckDB를 사용하여 Pokémon API를 활용해 데이터를 처리하는 방법을 예시로 살펴보며 강력한 기능을 보여줄 것입니다.\n\n![이미지](/assets/img/2024-05-20-GottaprocessemallDuckDBmastersyourdatalikeaPokmontrainer_1.png)\n\n## API 개요\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n포켓몬 API는 포켓몬 비디오 게임 시리즈와 관련된 JSON 데이터에 대한 RESTful API 인터페이스를 제공합니다. 이 API를 사용하면 포켓몬, 그들의 기술, 능력, 유형 등에 대한 정보를 소비할 수 있습니다.\n\n이 기사는 주로 DuckDB 기능에 초점을 맞춰야 하므로 일부 엔드포인트만 사용할 것입니다. 개요를 얻기 위해 curl과 jq를 사용하여 관련 엔드포인트를 탐색해 보겠습니다. jq를 잘 모르는 경우, 이것은 터미널에서 JSON을 필터링, 수정 또는 간단히 형식화하는 많은 기능을 가진 경량 CLI JSON 프로세서입니다. macOS를 사용하고 Homebrew를 사용 중이라면 brew install jq를 통해 jq를 설치할 수 있습니다.\n\n## 포켓몬 가져오기\n\n```js\ncurl -s https://pokeapi.co/api/v2/pokemon/ | jq .\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n{\n  \"count\": 1302,\n  \"next\": \"https://pokeapi.co/api/v2/pokemon/?offset=20\u0026limit=20\",\n  \"previous\": null,\n  \"results\": [\n    {\n      \"name\": \"bulbasaur\",\n      \"url\": \"https://pokeapi.co/api/v2/pokemon/1/\"\n    },\n    {\n      \"name\": \"ivysaur\",\n      \"url\": \"https://pokeapi.co/api/v2/pokemon/2/\"\n    },\n    ...\n```\n\n![Gotta Process Em All: DuckDB masters your data like a Pokémon trainer](/assets/img/2024-05-20-GottaprocessemallDuckDBmastersyourdatalikeaPokmontrainer_2.png)\n\n## 포켓몬 세부 정보 가져오기\n\n```js\ncurl -s https://pokeapi.co/api/v2/pokemon/bulbasaur | jq .\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```json\n{\n  \"abilities\": [\n    {\n      \"ability\": {\n        \"name\": \"overgrow\",\n        \"url\": \"https://pokeapi.co/api/v2/ability/65/\"\n      },\n      \"is_hidden\": false,\n      \"slot\": 1\n    },\n    ...\n  ],\n  \"base_experience\": 64,\n  ...\n```\n\n![Screenshot](/assets/img/2024-05-20-GottaprocessemallDuckDBmastersyourdatalikeaPokmontrainer_3.png)\n\n# 프로젝트 설정\n\n새로운 Python 프로젝트를 만들기 시작합니다. 이를 위해 새 폴더를 만듭니다. 이 폴더 내에서 내장된 venv 모듈을 사용하여 가상 환경을 생성합니다:```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nmkdir duckdb-pokemon\ncd duckdb-pokemon\npython -m venv .venv\nsource .venv/bin/activate\n```\n\n마지막 명령으로 가상 환경을 활성화했습니다. 이는 현재 터미널 세션에서는 시스템 전역 Python 대신 가상 Python을 사용한다는 의미입니다. 이것은 다음에 설치할 종속성을 프로젝트 내에서 격리시키려는 우리의 목적상 중요합니다. 다음 단계는 모든 요구 사항을 설치하는 것입니다:\n\n```js\npip install duckdb\npip install pandas\npip install requests\n```\n\n여기까지 준비가 되었습니다. 다음 장에서는 포켓몬 API를 활용한 DuckDB의 일부 기능을 살펴볼 것입니다. 이 코드를 프로젝트 내의 Python 파일로 복사하여 실행할 수 있습니다.```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 데모 1: 간단한 선택\n\n첫 번째 데모는 시작하는 방법이 얼마나 간단한지 보여줍니다. DuckDB를 pip install duckdb로 설치한 후에는 직접 가져와서 SQL 문을 실행할 수 있습니다. 복잡한 데이터베이스 설정이나 다른 요구 사항이 없습니다. 광고대로, 이것은 빠른 내장형 분석용 데이터베이스입니다.\n\n```js\nimport duckdb\n\nduckdb.sql(\"SELECT 42\").show()\n```\n\n이 코드를 실행하면 예상한 출력인 하나의 열과 하나의 행이 포함된 값 42를 가진 테이블을 얻을 수 있습니다. 이는 삶, 우주, 그리고 모든 것에 대한 궁극적인 질문의 답입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n┌───────┐\n│  42   │\n│ int32 │\n├───────┤\n│    42 │\n└───────┘\n```\n\n# 데모 2: API로부터 JSON 읽기\n\n이제 상황이 급속하게 변화할 것이니, 포켓몬볼을 준비해두세요. 일반적으로 API에서 JSON 데이터를 가져올 때, requests.get을 시작으로 클라이언트 로직을 구현하여 데이터를 데이터베이스에로드하거나 Pandas와 같은 데이터 처리 프레임워크를 사용할 수 있습니다. 다음 예제는 당신을 확실히 놀라게 할 것입니다. 우리는 데이터를 가져와 SQL을 사용하여 직접 테이블로 만들 것입니다.\n\n```js\nimport duckdb\n\nduckdb.sql(\"\"\"\n    CREATE TABLE pokemon AS\n    SELECT *\n    FROM read_json_auto('https://pokeapi.co/api/v2/pokemon?limit=1000');\n\n    SELECT * FROM pokemon;\n\"\"\").show()\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nread_json_auto를 사용하면 JSON 데이터를로드하는 가장 간단한 방법을 사용할 수 있습니다. 이는 JSON 리더를 자동으로 구성하고 데이터에서 열 유형을 파생합니다.\n\n위의 코드는 API의 해당 응답에 따라 네 개의 열이 있는 테이블을 제공합니다. 즉: count, next, previous, results이며, results는 구조체의 목록이며 각 구조체는 이름과 URL이 포함된 포켓몬으로 구성됩니다.\n\n유연성은 DuckDB가 정말 빛나는 곳입니다. DuckDB는 여러분의 신속한 피카츄이며 JSON 데이터를로드하는 것은 단지 한 가지 예입니다. CSV 파일이나 심지어 하이브 파티셔닝이 있는 Parquet 파일에서 데이터를 읽을 수도 있습니다: \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nSELECT *\nFROM read_parquet(\"some_table/*/*/*.parquet\", hive_partitioning = true);\n```\n\n또는 Pandas 데이터프레임에서 데이터를 직접 읽어보세요:\n\n```js\nimport pandas as pd\nimport duckdb\n\ndf = pd.DataFrame({\"some_values\" : [42, 7411, 4]})\nprint(duckdb.query(\"SELECT SUM(some_values) FROM df\").to_df())\n```\n\n하지만 일단은 포켓몬으로 계속해 봅시다.```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 데모 3: Unnest\n\n이전 예제에서 결과, 즉 실제 포켓몬은 모두 한 행과 열 안에 구조체 목록 형식으로 있습니다. 그러나 추가 처리를 위해 각 포켓몬 당 하나의 행을 원합니다. 이를 위해 unnest 함수를 사용할 수 있습니다.\n\n```js\nimport duckdb\n\nduckdb.sql(\"\"\"\n    CREATE TABLE pokemon AS\n    SELECT unnest(results) AS pokemon\n    FROM read_json_auto('https://pokeapi.co/api/v2/pokemon?limit=1000');\n\n    SELECT\n        pokemon.name,\n        pokemon.url\n    FROM pokemon;\n\"\"\").show()\n```\n\n포켓몬 당 한 행씩 이름 및 URL이 포함된 결과를 얻을 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n┌──────────────┬─────────────────────────────────────────┐\n│     name     │                   url                   │\n│   varchar    │                 varchar                 │\n├──────────────┼─────────────────────────────────────────┤\n│ bulbasaur    │ https://pokeapi.co/api/v2/pokemon/1/    │\n│ ivysaur      │ https://pokeapi.co/api/v2/pokemon/2/    │\n│ venusaur     │ https://pokeapi.co/api/v2/pokemon/3/    │\n│    ·         │                   ·                     │\n│    ·         │                   ·                     │\n│ baxcalibur   │ https://pokeapi.co/api/v2/pokemon/998/  │\n│ gimmighoul   │ https://pokeapi.co/api/v2/pokemon/999/  │\n│ gholdengo    │ https://pokeapi.co/api/v2/pokemon/1000/ │\n├──────────────┴─────────────────────────────────────────┤\n│ 1000 rows (20 shown)                         2 columns │\n└────────────────────────────────────────────────────────┘\n```\n\n# 데모 4: 세부 정보 가져오기를 위한 UDF\n\n피카츄를 라이츄로 진화시킬 수 있을까요? 물론 가능합니다! 이전 예제의 결과를 사용하면, url이라는 열을 가지고 있어 각 포켓몬에 대한 더 많은 세부 정보를 얻기 위해 요청해야 합니다. read_json_auto와 같은 함수는 테이블 수준 함수이기 때문에 각 행에 적용할 수 없습니다.\n\nDuckDB는 Python과 완벽하게 통합되어 있어 열에 있는 각 url 값에 대해 간단히 Python 함수를 호출할 수 있는 방법이 있습니다. 이는 다른 데이터베이스 시스템에서 알 수 있는 사용자 정의 함수(UDF)와 유사합니다.```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAPI로부터 데이터를 가져오기 위해 파이썬 함수를 정의해야 합니다:\n\n```python\nimport requests\n\ndef get(url):\n    return requests.get(url).text\n```\n\n그런 다음 DuckDB에 등록해야 합니다:\n\n```python\nfrom duckdb.typing import VARCHAR\n\nduckdb.create_function(\"get\", get, [VARCHAR], VARCHAR)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\ncreate_function을 사용할 때는 SQL 스크립트에서 UDF에 참조할 이름을 지정해야 합니다. 또한 호출할 실제 Python 함수와 매개변수 유형 및 반환 유형 목록을 전달해야 합니다.\n\n그런 다음 SQL에서 다음과 같이 사용할 수 있습니다:\n\n```js\njson(get(pokemon.url)) AS details\n```\n\n다시 말해, 우리는 포켓몬 목록에서 각 pokemon.url에 대해 Python 함수 get을 호출합니다. 우리가 얻는 것은 JSON 응답 텍스트이며, json 함수를 사용하여 적절한 유형의 결과를 얻습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음은 스스로 시도해볼 수 있는 최종 코드입니다:\n\n```js\nimport duckdb\nimport requests\nfrom duckdb.typing import VARCHAR\n\n\ndef get(url):\n    return requests.get(url).text\n\n\nduckdb.create_function(\"get\", get, [VARCHAR], VARCHAR)\nduckdb.sql(\"\"\"\n    CREATE TABLE pokemon AS\n    SELECT unnest(results) AS pokemon\n    FROM read_json_auto('https://pokeapi.co/api/v2/pokemon?limit=10');\n\n    WITH base AS (\n        SELECT\n            pokemon.name AS name,\n            json(get(pokemon.url)) AS details\n        FROM pokemon\n    )\n    SELECT *\n    FROM base;\n\"\"\").show()\n```\n\n각 포켓몬에 대해 API를 호출하므로 실행에 몇 초가 걸릴 수 있습니다. 결과는 이름과 모든 세부 정보가 JSON으로 표시된 테이블입니다.\n\n\u003cimg src=\"/assets/img/2024-05-20-GottaprocessemallDuckDBmastersyourdatalikeaPokmontrainer_5.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 데모 5: 리스트 컴프리헨션\n\n파이썬의 리스트 컴프리헨션은 제가 가장 좋아하는 기능 중 하나에요. DuckDB에서도 리스트 컴프리헨션을 사용할 수 있어요! 우리의 목표는 세부 정보를 추가 처리하여 개별 열로 추출하는 것이에요. 하지만 모든 세부 정보가 아니라, 포켓몬의 ID, 이름, 키, 그리고 무게만 추출할 거에요.\n\n또한 포켓몬이 사용할 수 있는 능력들을 능력 이름으로 이루어진 간단한 리스트로 줄이고 다른 열에 저장할 거에요.\n\nSQL을 더 읽기 쉽게 만들기 위해, 우리는 공통 테이블 표현식 (CTE)도 사용할 거예요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```python\nimport duckdb\nimport requests\nfrom duckdb.typing import VARCHAR\n\ndef get(url):\n    return requests.get(url).text\n\nduckdb.create_function(\"get\", get, [VARCHAR], VARCHAR)\nduckdb.sql(\"\"\"\n    CREATE TABLE pokemon AS\n    SELECT unnest(results) AS pokemon\n    FROM read_json_auto('https://pokeapi.co/api/v2/pokemon?limit=10');\n\n    WITH base AS (\n        SELECT\n            pokemon.name AS name,\n            json(get(pokemon.url)) AS details\n        FROM pokemon\n    ), pokemon_details AS (\n        SELECT\n            details.id,\n            name,\n            details.abilities::STRUCT(ability STRUCT(name VARCHAR, url VARCHAR), is_hidden BOOLEAN, slot INTEGER)[] AS abilities,\n            details.height,\n            details.weight\n        FROM base\n    )\n    SELECT\n        id,\n        name,\n        [x.ability.name FOR x IN abilities] AS abilities,\n        height,\n        weight\n    FROM pokemon_details;\n\"\"\").show()\n```\n\nCTE인 pokemon_details가 필요한 세부 정보를 추출합니다. 그러나 여기에는 한 가지 숨겨진 기능이 더 있습니다: 현재 details 열의 abilities가 JSON 유형이지만 리스트 표현식에는 실제 목록 유형이 필요합니다. 다음 문으로:\n\n```python\ndetails.abilities::STRUCT(ability STRUCT(name VARCHAR, url VARCHAR), is_hidden BOOLEAN, slot INTEGER)[] AS abilities,\n```\n\nabilities의 유형을 구조 목록으로 변환합니다. 각 구조에는 더 자세한 정보를 위해 능력 이름과 URL뿐만 아니라, 숨겨진 플래그와 슬롯 번호를 포함하는 또 다른 구조가 포함됩니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n지금 능력은 목록이므로 SQL에서 목록 표현을 적용할 수 있습니다. 이는 기본적으로 파이썬의 목록 표현과 동일하게 작동합니다. 따라서 다음 SQL 코드를 사용해보세요:\n\n```js\n[x.ability.name FOR x IN abilities] AS abilities,\n```\n\n이를 통해 각 포켓몬이 사용할 수 있는 각 능력의 이름만 포함된 새 목록을 만듭니다.\n\n```js\n| id   | name       | abilities               | height | weight |\n|------|------------|-------------------------|--------|--------|\n| 1    | bulbasaur  | [overgrow, chlorophyll] | 7      | 69     |\n| 2    | ivysaur    | [overgrow, chlorophyll] | 10     | 130    |\n| 3    | venusaur   | [overgrow, chlorophyll] | 20     | 1000   |\n| 4    | charmander | [blaze, solar-power]    | 6      | 85     |\n| 5    | charmeleon | [blaze, solar-power]    | 11     | 190    |\n| 6    | charizard  | [blaze, solar-power]    | 17     | 905    |\n| 7    | squirtle   | [torrent, rain-dish]    | 5      | 90     |\n| 8    | wartortle  | [torrent, rain-dish]    | 10     | 225    |\n| 9    | blastoise  | [torrent, rain-dish]    | 16     | 855    |\n| 10   | caterpie   | [shield-dust, run-away] | 3      | 29     |\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 데모 6: DuckDB에서 Pandas로 그리고 다시 되돌아 오기\n\n지금쯤이면 DuckDB가 휴대용 분석 데이터베이스뿐만 아니라 다양한 데이터 조작 도구임이 분명해졌을 것입니다.\n\nDuckDB의 핵심은 SQL 기반 작업과 Pandas와 같은 다른 데이터 처리 도구 간에 원활한 통합을 제공합니다. 이 독특한 기능은 데이터 처리 스크립트 내에서 서로 다른 기술 간에 쉽게 전환할 수 있도록 가능하게 합니다.\n\n전혀 SQL에서 데이터 처리를 하거나 Pandas나 NumPy와 같은 전형적인 라이브러리를 사용하여 Python 스크립트 내에서 데이터 정제를 완전히 구현하는 대신, 복잡한 데이터베이스 통합 설정이 필요 없이 이러한 환경 간을 전환할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n지금까지의 예제를 기반으로, Pandas를 사용하여 추가 처리를 수행하고 싶다고 가정해 봅시다. DuckDB를 사용하면 SQL 쿼리의 결과를 데이터프레임으로 쉽게 내보낼 수 있습니다. .df() 함수를 사용하면 됩니다.\n\n또한 DuckDB를 사용하면 Pandas 데이터프레임에서 직접 데이터를 쿼리할 수도 있습니다!\n\n```python\nimport duckdb\nimport requests\nfrom duckdb.typing import VARCHAR\n\ndef get(url):\n    return requests.get(url).text\n\nduckdb.create_function(\"get\", get, [VARCHAR], VARCHAR)\n\n# DuckDB에서 작업 시작\ndf = duckdb.sql(\"\"\"\n    CREATE TABLE pokemon AS\n    SELECT unnest(results) AS pokemon\n    FROM read_json_auto('https://pokeapi.co/api/v2/pokemon?limit=10');\n\n    WITH base AS (\n        SELECT\n            pokemon.name AS name,\n            json(get(pokemon.url)) AS details\n        FROM pokemon\n    ), pokemon_details AS (\n        SELECT\n            details.id,\n            name,\n            details.abilities::STRUCT(ability STRUCT(name VARCHAR, url VARCHAR), is_hidden BOOLEAN, slot INTEGER)[] AS abilities,\n            details.height,\n            details.weight\n        FROM base\n    )\n    SELECT\n        id,\n        name,\n        [x.ability.name FOR x IN abilities] AS abilities,\n        height,\n        weight\n    FROM pokemon_details;\n\"\"\").df()\n\n# Pandas에서 데이터 처리 계속\ndf_agg = df.explode(\"abilities\").groupby(\"abilities\", as_index=False).agg(count=(\"id\", \"count\"))\n\n# DuckDB로 돌아가기\nduckdb.sql(\"\"\"\n    SELECT abilities AS ability, count\n    FROM df_agg\n    ORDER BY count DESC\n    LIMIT 8;\n\"\"\").show()\n```\n\n위 코드는 다음 결과를 출력합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n┌─────────────┬───────┐\n│   능력       │ 개수  │\n│   varchar   │ int64 │\n├─────────────┼───────┤\n│ blaze       │     3 │\n│ chlorophyll │     3 │\n│ overgrow    │     3 │\n│ rain-dish   │     3 │\n│ solar-power │     3 │\n│ torrent     │     3 │\n│ run-away    │     1 │\n│ shield-dust │     1 │\n└─────────────┴───────┘\n```\n\n앞서 언급한 대로, .df()를 사용하면 SQL 결과를 Pandas 데이터프레임으로 얻을 수 있습니다. 그런 다음 다음과 같이 추가적인 변환을 적용할 수 있습니다.\n\n```js\ndf_agg = df.explode(\"abilities\").groupby(\"abilities\", as_index=False).agg(count=(\"id\", \"count\"))\n```\n\n그리고 df_agg 변수에 저장된 데이터프레임을 SQL에서 사용할 수 있습니다. 처음 보았을 때 정말 놀랐던 부분이죠.```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```sql\nSELECT abilities AS ability, count\nFROM df_agg\nORDER BY count DESC\nLIMIT 8;\n```\n\n데이터 처리 도구로 DuckDB가 좋은 도구인 이유는 어떤 접착 코드도 추가하지 않기 때문입니다.\n\n# 데모 7: 데이터 유지 및 로드\n\n매번 실행할 때마다 API를 호출하는 것은 가장 효율적인 해결책은 아닙니다. 물론 결과를 기다리는 동안 맛있는 커피 한 잔을 마실 수 있는 기회를 제공하지만, DuckDB는 데이터를 유지할 수도 있습니다. 예를 들어 데이터를 파일로 직렬화하여 파일 시스템에 저장할 수 있습니다.```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 예제를 다음 코드와 함께 확장해 봅시다:\n\n```js\n# 판다스에서 데이터 처리 계속하기\ndf_agg = df.explode(\"abilities\").groupby(\"abilities\", as_index=False).agg(count=(\"id\", \"count\"))\n\n# 데이터 유지하기\nwith duckdb.connect(database=\"pokemon.db\") as conn:\n    conn.sql(\"\"\"\n        DROP TABLE IF EXISTS pokemon_abilities;\n        CREATE TABLE pokemon_abilities AS\n        SELECT abilities AS ability, count\n        FROM df_agg\n        ORDER BY count DESC;\n    \"\"\")\n```\n\n우리는 pokemon.db라는 파일에 연결을 열고 데이터를 저장합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다른 스크립트에서 데이터를로드하고 사전 처리 된 데이터에 액세스 할 수 있습니다:\n\n```js\nimport duckdb\n\n# 데이터 로드\nwith duckdb.connect(database=\"pokemon.db\") as conn:\n    conn.sql(\"\"\"\n        SELECT * FROM pokemon_abilities;\n    \"\"\").show()\n```\n\n\u003cimg src=\"/assets/img/2024-05-20-GottaprocessemallDuckDBmastersyourdatalikeaPokmontrainer_7.png\" /\u003e\n\n# 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nDuckDB은 데이터 처리 도전에서 강력한 동료로 나타났습니다. Pandas 데이터프레임과 고급 분석 SQL 기능과의 매끄러운 통합을 제공하여 자원 제한적 환경에서 분석 작업에 적합함을 강조했습니다.\n\n[Github](https://github.com/vojay-dev/duckdb-pokemon)에서 모든 데모를 찾을 수 있어요! 🪄\n\nDuckDB가 함께하면 금방 성공적인 포켓몬 트레이너가 될 거에요!\n\n\u003cimg src=\"/assets/img/2024-05-20-GottaprocessemallDuckDBmastersyourdatalikeaPokmontrainer_8.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n경험을 공유해주시고 즐거운 독서를 즐기세요!","ogImage":{"url":"/assets/img/2024-05-20-GottaprocessemallDuckDBmastersyourdatalikeaPokmontrainer_0.png"},"coverImage":"/assets/img/2024-05-20-GottaprocessemallDuckDBmastersyourdatalikeaPokmontrainer_0.png","tag":["Tech"],"readingTime":16},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h2: \"h2\",\n    ul: \"ul\",\n    li: \"li\",\n    h1: \"h1\",\n    p: \"p\",\n    a: \"a\",\n    img: \"img\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h2, {\n      children: \"DuckDB을 데이터 처리 도구로 사용하는 실용적인 예제\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"소개\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"API 개요\", \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsx(_components.li, {\n            children: \"포켓몬 가져오기\"\n          }), \"\\n\", _jsx(_components.li, {\n            children: \"포켓몬 세부 정보 가져오기\"\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"프로젝트 설정\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"데모 1: 간단한 선택\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"데모 2: API에서 JSON 읽기\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"데모 3: Unnest\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"데모 4: 세부 정보 가져오는 UDF\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"데모 5: 목록 표현식\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"데모 6: DuckDB를 Pandas로 변환하고 다시 변환하기\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"데모 7: 데이터 유지 및 로드\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"결론\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"소개\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"캉토 지방을 탐험하여 놀라운 생물을 포획하고 훈련하는 포켓몬 트레이너가 되는 꿈을 꾸어 본 적이 있나요? 90년대에 Game Boy에서 포켓몬 레드 버전과 포켓몬 블루 버전을 즐길 때, 제가 확실히 꾸었던 꿈입니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"포켓몬 비디오 게임 시리즈가 시간이 지남에 따라 얼마나 인기 있어졌고 지금도 그랬는지 정말 놀라운 일이에요. 마치 비디오 게임 산업에서 떠오르는 별처럼 말이죠. 그 얘기를 하자면: DuckDB, 진행 중인 SQL 분석 엔진, 지난 몇 년간 데이터 엔지니어링 커뮤니티에서 떠오르는 별처럼 인기를 끌었어요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.a, {\n        href: \"/assets/img/2024-05-20-GottaprocessemallDuckDBmastersyourdatalikeaPokmontrainer_0.png\",\n        children: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"마치 포켓몬 트레이너가 전투를 위해 완벽한 팀을 선택하는 것처럼, 경험이 풍부한 데이터 엔지니어는 작업에 적합한 올바른 도구를 선택하는 중요성을 알아요. 본 문서를 통해 DuckDB가 여러분의 도구 상자에 완벽한 도구가 될 이유를 보여드리고 싶어요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"DuckDB는 큰 데이터베이스와 매끄럽게 통합되어 인메모리 및 영속적 저장 솔루션 사이의 원활한 전환을 도와줘요. 마치 어떤 도전이든 쉽게 적응하는 다재다능한 포켓몬과 같죠. 작은 데이터 세트를 빠르게 분석해야 한다면? DuckDB는 여러분의 마초크, 쉽게 과업을 수행할 준비가 돼 있어요. 더 강력한 처리가 필요한 대규모 데이터 세트와 작업하고 있다면? DuckDB는 마샴으로 변신하여 과중한 분석을 위해 외부 데이터베이스에 매끄럽게 연결할 수 있어요.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"DuckDB를 설치하기 쉽고 휴대용이며 오픈 소스입니다. SQL 방언 측면에서 기능이 풍부하고 CSV, Parquet 및 JSON과 같은 다양한 형식을 기준으로 데이터를 가져오고 내보낼 수 있습니다. 또한 Pandas 데이터프레임과 원활하게 통합되어 데이터 조작 스크립트에서 강력한 데이터 조작 도구로 사용할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다음 장에서는 DuckDB를 사용하여 Pokémon API를 활용해 데이터를 처리하는 방법을 예시로 살펴보며 강력한 기능을 보여줄 것입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-20-GottaprocessemallDuckDBmastersyourdatalikeaPokmontrainer_1.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"API 개요\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"포켓몬 API는 포켓몬 비디오 게임 시리즈와 관련된 JSON 데이터에 대한 RESTful API 인터페이스를 제공합니다. 이 API를 사용하면 포켓몬, 그들의 기술, 능력, 유형 등에 대한 정보를 소비할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 기사는 주로 DuckDB 기능에 초점을 맞춰야 하므로 일부 엔드포인트만 사용할 것입니다. 개요를 얻기 위해 curl과 jq를 사용하여 관련 엔드포인트를 탐색해 보겠습니다. jq를 잘 모르는 경우, 이것은 터미널에서 JSON을 필터링, 수정 또는 간단히 형식화하는 많은 기능을 가진 경량 CLI JSON 프로세서입니다. macOS를 사용하고 Homebrew를 사용 중이라면 brew install jq를 통해 jq를 설치할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"포켓몬 가져오기\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"curl -s \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"https\"\n        }), \":\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"//pokeapi.co/api/v2/pokemon/ | jq .\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"{\\n  \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"count\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1302\"\n        }), \",\\n  \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"next\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"https://pokeapi.co/api/v2/pokemon/?offset=20\u0026limit=20\\\"\"\n        }), \",\\n  \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"previous\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"null\"\n        }), \",\\n  \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"results\\\"\"\n        }), \": [\\n    {\\n      \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"name\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"bulbasaur\\\"\"\n        }), \",\\n      \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"url\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"https://pokeapi.co/api/v2/pokemon/1/\\\"\"\n        }), \"\\n    },\\n    {\\n      \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"name\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"ivysaur\\\"\"\n        }), \",\\n      \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"url\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"https://pokeapi.co/api/v2/pokemon/2/\\\"\"\n        }), \"\\n    },\\n    ...\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-20-GottaprocessemallDuckDBmastersyourdatalikeaPokmontrainer_2.png\",\n        alt: \"Gotta Process Em All: DuckDB masters your data like a Pokémon trainer\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"포켓몬 세부 정보 가져오기\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"curl -s \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"https\"\n        }), \":\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"//pokeapi.co/api/v2/pokemon/bulbasaur | jq .\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-json\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-punctuation\",\n          children: \"{\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"\\\"abilities\\\"\"\n        }), _jsx(_components.span, {\n          className: \"hljs-punctuation\",\n          children: \":\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-punctuation\",\n          children: \"[\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-punctuation\",\n          children: \"{\"\n        }), \"\\n      \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"\\\"ability\\\"\"\n        }), _jsx(_components.span, {\n          className: \"hljs-punctuation\",\n          children: \":\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-punctuation\",\n          children: \"{\"\n        }), \"\\n        \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"\\\"name\\\"\"\n        }), _jsx(_components.span, {\n          className: \"hljs-punctuation\",\n          children: \":\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"overgrow\\\"\"\n        }), _jsx(_components.span, {\n          className: \"hljs-punctuation\",\n          children: \",\"\n        }), \"\\n        \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"\\\"url\\\"\"\n        }), _jsx(_components.span, {\n          className: \"hljs-punctuation\",\n          children: \":\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"https://pokeapi.co/api/v2/ability/65/\\\"\"\n        }), \"\\n      \", _jsx(_components.span, {\n          className: \"hljs-punctuation\",\n          children: \"}\"\n        }), _jsx(_components.span, {\n          className: \"hljs-punctuation\",\n          children: \",\"\n        }), \"\\n      \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"\\\"is_hidden\\\"\"\n        }), _jsx(_components.span, {\n          className: \"hljs-punctuation\",\n          children: \":\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"false\"\n          })\n        }), _jsx(_components.span, {\n          className: \"hljs-punctuation\",\n          children: \",\"\n        }), \"\\n      \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"\\\"slot\\\"\"\n        }), _jsx(_components.span, {\n          className: \"hljs-punctuation\",\n          children: \":\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-punctuation\",\n          children: \"}\"\n        }), _jsx(_components.span, {\n          className: \"hljs-punctuation\",\n          children: \",\"\n        }), \"\\n    ...\\n  \", _jsx(_components.span, {\n          className: \"hljs-punctuation\",\n          children: \"]\"\n        }), _jsx(_components.span, {\n          className: \"hljs-punctuation\",\n          children: \",\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"\\\"base_experience\\\"\"\n        }), _jsx(_components.span, {\n          className: \"hljs-punctuation\",\n          children: \":\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"64\"\n        }), _jsx(_components.span, {\n          className: \"hljs-punctuation\",\n          children: \",\"\n        }), \"\\n  ...\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-20-GottaprocessemallDuckDBmastersyourdatalikeaPokmontrainer_3.png\",\n        alt: \"Screenshot\"\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"프로젝트 설정\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"새로운 Python 프로젝트를 만들기 시작합니다. 이를 위해 새 폴더를 만듭니다. 이 폴더 내에서 내장된 venv 모듈을 사용하여 가상 환경을 생성합니다:```\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"mkdir duckdb-pokemon\\ncd duckdb-pokemon\\npython -m venv .\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"venv\"\n        }), \"\\nsource .\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"venv\"\n        }), \"/bin/activate\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"마지막 명령으로 가상 환경을 활성화했습니다. 이는 현재 터미널 세션에서는 시스템 전역 Python 대신 가상 Python을 사용한다는 의미입니다. 이것은 다음에 설치할 종속성을 프로젝트 내에서 격리시키려는 우리의 목적상 중요합니다. 다음 단계는 모든 요구 사항을 설치하는 것입니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-js\",\n        children: \"pip install duckdb\\npip install pandas\\npip install requests\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"여기까지 준비가 되었습니다. 다음 장에서는 포켓몬 API를 활용한 DuckDB의 일부 기능을 살펴볼 것입니다. 이 코드를 프로젝트 내의 Python 파일로 복사하여 실행할 수 있습니다.```\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"데모 1: 간단한 선택\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"첫 번째 데모는 시작하는 방법이 얼마나 간단한지 보여줍니다. DuckDB를 pip install duckdb로 설치한 후에는 직접 가져와서 SQL 문을 실행할 수 있습니다. 복잡한 데이터베이스 설정이나 다른 요구 사항이 없습니다. 광고대로, 이것은 빠른 내장형 분석용 데이터베이스입니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" duckdb\\n\\nduckdb.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"sql\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"SELECT 42\\\"\"\n        }), \").\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"show\"\n        }), \"()\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 코드를 실행하면 예상한 출력인 하나의 열과 하나의 행이 포함된 값 42를 가진 테이블을 얻을 수 있습니다. 이는 삶, 우주, 그리고 모든 것에 대한 궁극적인 질문의 답입니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"┌───────┐\\n│  \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"42\"\n        }), \"   │\\n│ int32 │\\n├───────┤\\n│    \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"42\"\n        }), \" │\\n└───────┘\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"데모 2: API로부터 JSON 읽기\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 상황이 급속하게 변화할 것이니, 포켓몬볼을 준비해두세요. 일반적으로 API에서 JSON 데이터를 가져올 때, requests.get을 시작으로 클라이언트 로직을 구현하여 데이터를 데이터베이스에로드하거나 Pandas와 같은 데이터 처리 프레임워크를 사용할 수 있습니다. 다음 예제는 당신을 확실히 놀라게 할 것입니다. 우리는 데이터를 가져와 SQL을 사용하여 직접 테이블로 만들 것입니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" duckdb\\n\\nduckdb.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"sql\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\\\"\"\n        }), _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\\n    CREATE TABLE pokemon AS\\n    SELECT *\\n    FROM read_json_auto('https://pokeapi.co/api/v2/pokemon?limit=1000');\\n\\n    SELECT * FROM pokemon;\\n\\\"\"\n        }), _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\\\"\"\n        }), \").\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"show\"\n        }), \"()\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"read_json_auto를 사용하면 JSON 데이터를로드하는 가장 간단한 방법을 사용할 수 있습니다. 이는 JSON 리더를 자동으로 구성하고 데이터에서 열 유형을 파생합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"위의 코드는 API의 해당 응답에 따라 네 개의 열이 있는 테이블을 제공합니다. 즉: count, next, previous, results이며, results는 구조체의 목록이며 각 구조체는 이름과 URL이 포함된 포켓몬으로 구성됩니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"유연성은 DuckDB가 정말 빛나는 곳입니다. DuckDB는 여러분의 신속한 피카츄이며 JSON 데이터를로드하는 것은 단지 한 가지 예입니다. CSV 파일이나 심지어 하이브 파티셔닝이 있는 Parquet 파일에서 데이터를 읽을 수도 있습니다:\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"SELECT\"\n        }), \" *\\n\", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"FROM\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"read_parquet\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"some_table/*/*/*.parquet\\\"\"\n        }), \", hive_partitioning = \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"true\"\n        }), \");\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"또는 Pandas 데이터프레임에서 데이터를 직접 읽어보세요:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" pandas \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" pd\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" duckdb\\n\\ndf = pd.\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"DataFrame\"\n        }), \"({\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"some_values\\\"\"\n        }), \" : [\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"42\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"7411\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"4\"\n        }), \"]})\\n\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"print\"\n        }), \"(duckdb.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"query\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"SELECT SUM(some_values) FROM df\\\"\"\n        }), \").\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"to_df\"\n        }), \"())\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"하지만 일단은 포켓몬으로 계속해 봅시다.```\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"데모 3: Unnest\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이전 예제에서 결과, 즉 실제 포켓몬은 모두 한 행과 열 안에 구조체 목록 형식으로 있습니다. 그러나 추가 처리를 위해 각 포켓몬 당 하나의 행을 원합니다. 이를 위해 unnest 함수를 사용할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" duckdb\\n\\nduckdb.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"sql\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\\\"\"\n        }), _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\\n    CREATE TABLE pokemon AS\\n    SELECT unnest(results) AS pokemon\\n    FROM read_json_auto('https://pokeapi.co/api/v2/pokemon?limit=1000');\\n\\n    SELECT\\n        pokemon.name,\\n        pokemon.url\\n    FROM pokemon;\\n\\\"\"\n        }), _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\\\"\"\n        }), \").\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"show\"\n        }), \"()\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"포켓몬 당 한 행씩 이름 및 URL이 포함된 결과를 얻을 수 있습니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"┌──────────────┬─────────────────────────────────────────┐\\n│     name     │                   url                   │\\n│   varchar    │                 varchar                 │\\n├──────────────┼─────────────────────────────────────────┤\\n│ bulbasaur    │ \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"https\"\n        }), \":\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"//pokeapi.co/api/v2/pokemon/1/    │\"\n        }), \"\\n│ ivysaur      │ \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"https\"\n        }), \":\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"//pokeapi.co/api/v2/pokemon/2/    │\"\n        }), \"\\n│ venusaur     │ \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"https\"\n        }), \":\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"//pokeapi.co/api/v2/pokemon/3/    │\"\n        }), \"\\n│    ·         │                   ·                     │\\n│    ·         │                   ·                     │\\n│ baxcalibur   │ \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"https\"\n        }), \":\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"//pokeapi.co/api/v2/pokemon/998/  │\"\n        }), \"\\n│ gimmighoul   │ \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"https\"\n        }), \":\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"//pokeapi.co/api/v2/pokemon/999/  │\"\n        }), \"\\n│ gholdengo    │ \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"https\"\n        }), \":\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"//pokeapi.co/api/v2/pokemon/1000/ │\"\n        }), \"\\n├──────────────┴─────────────────────────────────────────┤\\n│ \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1000\"\n        }), \" rows (\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"20\"\n        }), \" shown)                         \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"2\"\n        }), \" columns │\\n└────────────────────────────────────────────────────────┘\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"데모 4: 세부 정보 가져오기를 위한 UDF\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"피카츄를 라이츄로 진화시킬 수 있을까요? 물론 가능합니다! 이전 예제의 결과를 사용하면, url이라는 열을 가지고 있어 각 포켓몬에 대한 더 많은 세부 정보를 얻기 위해 요청해야 합니다. read_json_auto와 같은 함수는 테이블 수준 함수이기 때문에 각 행에 적용할 수 없습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"DuckDB는 Python과 완벽하게 통합되어 있어 열에 있는 각 url 값에 대해 간단히 Python 함수를 호출할 수 있는 방법이 있습니다. 이는 다른 데이터베이스 시스템에서 알 수 있는 사용자 정의 함수(UDF)와 유사합니다.```\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"API로부터 데이터를 가져오기 위해 파이썬 함수를 정의해야 합니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-python\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" requests\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"def\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"get\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"url\"\n        }), \"):\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" requests.get(url).text\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그런 다음 DuckDB에 등록해야 합니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-python\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" duckdb.typing \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" VARCHAR\\n\\nduckdb.create_function(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"get\\\"\"\n        }), \", get, [VARCHAR], VARCHAR)\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"create_function을 사용할 때는 SQL 스크립트에서 UDF에 참조할 이름을 지정해야 합니다. 또한 호출할 실제 Python 함수와 매개변수 유형 및 반환 유형 목록을 전달해야 합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그런 다음 SQL에서 다음과 같이 사용할 수 있습니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"json\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"get\"\n        }), \"(pokemon.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"url\"\n        }), \")) \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"AS\"\n        }), \" details\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다시 말해, 우리는 포켓몬 목록에서 각 pokemon.url에 대해 Python 함수 get을 호출합니다. 우리가 얻는 것은 JSON 응답 텍스트이며, json 함수를 사용하여 적절한 유형의 결과를 얻습니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다음은 스스로 시도해볼 수 있는 최종 코드입니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" duckdb\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" requests\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" duckdb.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"typing\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"VARCHAR\"\n        }), \"\\n\\n\\ndef \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"get\"\n        }), \"(url):\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" requests.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"get\"\n        }), \"(url).\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"text\"\n        }), \"\\n\\n\\nduckdb.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"create_function\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"get\\\"\"\n        }), \", get, [\", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"VARCHAR\"\n        }), \"], \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"VARCHAR\"\n        }), \")\\nduckdb.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"sql\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\\\"\"\n        }), _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\\n    CREATE TABLE pokemon AS\\n    SELECT unnest(results) AS pokemon\\n    FROM read_json_auto('https://pokeapi.co/api/v2/pokemon?limit=10');\\n\\n    WITH base AS (\\n        SELECT\\n            pokemon.name AS name,\\n            json(get(pokemon.url)) AS details\\n        FROM pokemon\\n    )\\n    SELECT *\\n    FROM base;\\n\\\"\"\n        }), _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\\\"\"\n        }), \").\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"show\"\n        }), \"()\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"각 포켓몬에 대해 API를 호출하므로 실행에 몇 초가 걸릴 수 있습니다. 결과는 이름과 모든 세부 정보가 JSON으로 표시된 테이블입니다.\"\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/assets/img/2024-05-20-GottaprocessemallDuckDBmastersyourdatalikeaPokmontrainer_5.png\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"데모 5: 리스트 컴프리헨션\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"파이썬의 리스트 컴프리헨션은 제가 가장 좋아하는 기능 중 하나에요. DuckDB에서도 리스트 컴프리헨션을 사용할 수 있어요! 우리의 목표는 세부 정보를 추가 처리하여 개별 열로 추출하는 것이에요. 하지만 모든 세부 정보가 아니라, 포켓몬의 ID, 이름, 키, 그리고 무게만 추출할 거에요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"또한 포켓몬이 사용할 수 있는 능력들을 능력 이름으로 이루어진 간단한 리스트로 줄이고 다른 열에 저장할 거에요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"SQL을 더 읽기 쉽게 만들기 위해, 우리는 공통 테이블 표현식 (CTE)도 사용할 거예요.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-python\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" duckdb\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" requests\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" duckdb.typing \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" VARCHAR\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"def\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"get\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"url\"\n        }), \"):\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" requests.get(url).text\\n\\nduckdb.create_function(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"get\\\"\"\n        }), \", get, [VARCHAR], VARCHAR)\\nduckdb.sql(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\\\"\\\"\\n    CREATE TABLE pokemon AS\\n    SELECT unnest(results) AS pokemon\\n    FROM read_json_auto('https://pokeapi.co/api/v2/pokemon?limit=10');\\n\\n    WITH base AS (\\n        SELECT\\n            pokemon.name AS name,\\n            json(get(pokemon.url)) AS details\\n        FROM pokemon\\n    ), pokemon_details AS (\\n        SELECT\\n            details.id,\\n            name,\\n            details.abilities::STRUCT(ability STRUCT(name VARCHAR, url VARCHAR), is_hidden BOOLEAN, slot INTEGER)[] AS abilities,\\n            details.height,\\n            details.weight\\n        FROM base\\n    )\\n    SELECT\\n        id,\\n        name,\\n        [x.ability.name FOR x IN abilities] AS abilities,\\n        height,\\n        weight\\n    FROM pokemon_details;\\n\\\"\\\"\\\"\"\n        }), \").show()\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"CTE인 pokemon_details가 필요한 세부 정보를 추출합니다. 그러나 여기에는 한 가지 숨겨진 기능이 더 있습니다: 현재 details 열의 abilities가 JSON 유형이지만 리스트 표현식에는 실제 목록 유형이 필요합니다. 다음 문으로:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-python\",\n        children: \"details.abilities::STRUCT(ability STRUCT(name VARCHAR, url VARCHAR), is_hidden BOOLEAN, slot INTEGER)[] AS abilities,\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"abilities의 유형을 구조 목록으로 변환합니다. 각 구조에는 더 자세한 정보를 위해 능력 이름과 URL뿐만 아니라, 숨겨진 플래그와 슬롯 번호를 포함하는 또 다른 구조가 포함됩니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"지금 능력은 목록이므로 SQL에서 목록 표현을 적용할 수 있습니다. 이는 기본적으로 파이썬의 목록 표현과 동일하게 작동합니다. 따라서 다음 SQL 코드를 사용해보세요:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"[x.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"ability\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"name\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"FOR\"\n        }), \" x \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"IN\"\n        }), \" abilities] \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"AS\"\n        }), \" abilities,\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이를 통해 각 포켓몬이 사용할 수 있는 각 능력의 이름만 포함된 새 목록을 만듭니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"| id   | name       | abilities               | height | weight |\\n|------|------------|-------------------------|--------|--------|\\n| \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"    | bulbasaur  | [overgrow, chlorophyll] | \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"7\"\n        }), \"      | \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"69\"\n        }), \"     |\\n| \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"2\"\n        }), \"    | ivysaur    | [overgrow, chlorophyll] | \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"10\"\n        }), \"     | \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"130\"\n        }), \"    |\\n| \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"3\"\n        }), \"    | venusaur   | [overgrow, chlorophyll] | \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"20\"\n        }), \"     | \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1000\"\n        }), \"   |\\n| \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"4\"\n        }), \"    | charmander | [blaze, solar-power]    | \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"6\"\n        }), \"      | \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"85\"\n        }), \"     |\\n| \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"5\"\n        }), \"    | charmeleon | [blaze, solar-power]    | \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"11\"\n        }), \"     | \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"190\"\n        }), \"    |\\n| \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"6\"\n        }), \"    | charizard  | [blaze, solar-power]    | \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"17\"\n        }), \"     | \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"905\"\n        }), \"    |\\n| \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"7\"\n        }), \"    | squirtle   | [torrent, rain-dish]    | \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"5\"\n        }), \"      | \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"90\"\n        }), \"     |\\n| \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"8\"\n        }), \"    | wartortle  | [torrent, rain-dish]    | \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"10\"\n        }), \"     | \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"225\"\n        }), \"    |\\n| \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"9\"\n        }), \"    | blastoise  | [torrent, rain-dish]    | \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"16\"\n        }), \"     | \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"855\"\n        }), \"    |\\n| \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"10\"\n        }), \"   | caterpie   | [shield-dust, run-away] | \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"3\"\n        }), \"      | \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"29\"\n        }), \"     |\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"데모 6: DuckDB에서 Pandas로 그리고 다시 되돌아 오기\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"지금쯤이면 DuckDB가 휴대용 분석 데이터베이스뿐만 아니라 다양한 데이터 조작 도구임이 분명해졌을 것입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"DuckDB의 핵심은 SQL 기반 작업과 Pandas와 같은 다른 데이터 처리 도구 간에 원활한 통합을 제공합니다. 이 독특한 기능은 데이터 처리 스크립트 내에서 서로 다른 기술 간에 쉽게 전환할 수 있도록 가능하게 합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"전혀 SQL에서 데이터 처리를 하거나 Pandas나 NumPy와 같은 전형적인 라이브러리를 사용하여 Python 스크립트 내에서 데이터 정제를 완전히 구현하는 대신, 복잡한 데이터베이스 통합 설정이 필요 없이 이러한 환경 간을 전환할 수 있습니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"지금까지의 예제를 기반으로, Pandas를 사용하여 추가 처리를 수행하고 싶다고 가정해 봅시다. DuckDB를 사용하면 SQL 쿼리의 결과를 데이터프레임으로 쉽게 내보낼 수 있습니다. .df() 함수를 사용하면 됩니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"또한 DuckDB를 사용하면 Pandas 데이터프레임에서 직접 데이터를 쿼리할 수도 있습니다!\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-python\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" duckdb\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" requests\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" duckdb.typing \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" VARCHAR\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"def\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"get\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"url\"\n        }), \"):\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" requests.get(url).text\\n\\nduckdb.create_function(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"get\\\"\"\n        }), \", get, [VARCHAR], VARCHAR)\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"# DuckDB에서 작업 시작\"\n        }), \"\\ndf = duckdb.sql(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\\\"\\\"\\n    CREATE TABLE pokemon AS\\n    SELECT unnest(results) AS pokemon\\n    FROM read_json_auto('https://pokeapi.co/api/v2/pokemon?limit=10');\\n\\n    WITH base AS (\\n        SELECT\\n            pokemon.name AS name,\\n            json(get(pokemon.url)) AS details\\n        FROM pokemon\\n    ), pokemon_details AS (\\n        SELECT\\n            details.id,\\n            name,\\n            details.abilities::STRUCT(ability STRUCT(name VARCHAR, url VARCHAR), is_hidden BOOLEAN, slot INTEGER)[] AS abilities,\\n            details.height,\\n            details.weight\\n        FROM base\\n    )\\n    SELECT\\n        id,\\n        name,\\n        [x.ability.name FOR x IN abilities] AS abilities,\\n        height,\\n        weight\\n    FROM pokemon_details;\\n\\\"\\\"\\\"\"\n        }), \").df()\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"# Pandas에서 데이터 처리 계속\"\n        }), \"\\ndf_agg = df.explode(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"abilities\\\"\"\n        }), \").groupby(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"abilities\\\"\"\n        }), \", as_index=\", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"False\"\n        }), \").agg(count=(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"id\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"count\\\"\"\n        }), \"))\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"# DuckDB로 돌아가기\"\n        }), \"\\nduckdb.sql(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\\\"\\\"\\n    SELECT abilities AS ability, count\\n    FROM df_agg\\n    ORDER BY count DESC\\n    LIMIT 8;\\n\\\"\\\"\\\"\"\n        }), \").show()\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"위 코드는 다음 결과를 출력합니다:\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"┌─────────────┬───────┐\\n│   능력       │ 개수  │\\n│   varchar   │ int64 │\\n├─────────────┼───────┤\\n│ blaze       │     \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"3\"\n        }), \" │\\n│ chlorophyll │     \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"3\"\n        }), \" │\\n│ overgrow    │     \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"3\"\n        }), \" │\\n│ rain-dish   │     \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"3\"\n        }), \" │\\n│ solar-power │     \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"3\"\n        }), \" │\\n│ torrent     │     \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"3\"\n        }), \" │\\n│ run-away    │     \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \" │\\n│ shield-dust │     \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \" │\\n└─────────────┴───────┘\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"앞서 언급한 대로, .df()를 사용하면 SQL 결과를 Pandas 데이터프레임으로 얻을 수 있습니다. 그런 다음 다음과 같이 추가적인 변환을 적용할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"df_agg = df.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"explode\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"abilities\\\"\"\n        }), \").\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"groupby\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"abilities\\\"\"\n        }), \", as_index=\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"False\"\n        }), \").\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"agg\"\n        }), \"(count=(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"id\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"count\\\"\"\n        }), \"))\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그리고 df_agg 변수에 저장된 데이터프레임을 SQL에서 사용할 수 있습니다. 처음 보았을 때 정말 놀랐던 부분이죠.```\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-sql\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"SELECT\"\n        }), \" abilities \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"AS\"\n        }), \" ability, count\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"FROM\"\n        }), \" df_agg\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"ORDER\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"BY\"\n        }), \" count \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"DESC\"\n        }), \"\\nLIMIT \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"8\"\n        }), \";\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"데이터 처리 도구로 DuckDB가 좋은 도구인 이유는 어떤 접착 코드도 추가하지 않기 때문입니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"데모 7: 데이터 유지 및 로드\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"매번 실행할 때마다 API를 호출하는 것은 가장 효율적인 해결책은 아닙니다. 물론 결과를 기다리는 동안 맛있는 커피 한 잔을 마실 수 있는 기회를 제공하지만, DuckDB는 데이터를 유지할 수도 있습니다. 예를 들어 데이터를 파일로 직렬화하여 파일 시스템에 저장할 수 있습니다.```\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"위의 예제를 다음 코드와 함께 확장해 봅시다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"# 판다스에서 데이터 처리 계속하기\\ndf_agg = df.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"explode\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"abilities\\\"\"\n        }), \").\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"groupby\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"abilities\\\"\"\n        }), \", as_index=\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"False\"\n        }), \").\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"agg\"\n        }), \"(count=(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"id\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"count\\\"\"\n        }), \"))\\n\\n# 데이터 유지하기\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"with\"\n        }), \" duckdb.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"connect\"\n        }), \"(database=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"pokemon.db\\\"\"\n        }), \") \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"conn\"\n        }), \":\\n    conn.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"sql\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\\\"\"\n        }), _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\\n        DROP TABLE IF EXISTS pokemon_abilities;\\n        CREATE TABLE pokemon_abilities AS\\n        SELECT abilities AS ability, count\\n        FROM df_agg\\n        ORDER BY count DESC;\\n    \\\"\"\n        }), _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\\\"\"\n        }), \")\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우리는 pokemon.db라는 파일에 연결을 열고 데이터를 저장합니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다른 스크립트에서 데이터를로드하고 사전 처리 된 데이터에 액세스 할 수 있습니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" duckdb\\n\\n# 데이터 로드\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"with\"\n        }), \" duckdb.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"connect\"\n        }), \"(database=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"pokemon.db\\\"\"\n        }), \") \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"conn\"\n        }), \":\\n    conn.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"sql\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\\\"\"\n        }), _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\\n        SELECT * FROM pokemon_abilities;\\n    \\\"\"\n        }), _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\\\"\"\n        }), \").\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"show\"\n        }), \"()\\n\"]\n      })\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/assets/img/2024-05-20-GottaprocessemallDuckDBmastersyourdatalikeaPokmontrainer_7.png\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"결론\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"DuckDB은 데이터 처리 도전에서 강력한 동료로 나타났습니다. Pandas 데이터프레임과 고급 분석 SQL 기능과의 매끄러운 통합을 제공하여 자원 제한적 환경에서 분석 작업에 적합함을 강조했습니다.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.a, {\n        href: \"https://github.com/vojay-dev/duckdb-pokemon\",\n        children: \"Github\"\n      }), \"에서 모든 데모를 찾을 수 있어요! 🪄\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"DuckDB가 함께하면 금방 성공적인 포켓몬 트레이너가 될 거에요!\"\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/assets/img/2024-05-20-GottaprocessemallDuckDBmastersyourdatalikeaPokmontrainer_8.png\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"경험을 공유해주시고 즐거운 독서를 즐기세요!\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-20-GottaprocessemallDuckDBmastersyourdatalikeaPokmontrainer"},"buildId":"PgdIX9e0tvkvkdAmDT6qR","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>