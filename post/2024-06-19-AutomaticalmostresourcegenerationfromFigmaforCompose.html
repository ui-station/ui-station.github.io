<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>피그마로부터 코틀린 Compose를 위한 자동 거의 자원 생성 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-06-19-AutomaticalmostresourcegenerationfromFigmaforCompose" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="피그마로부터 코틀린 Compose를 위한 자동 거의 자원 생성 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="피그마로부터 코틀린 Compose를 위한 자동 거의 자원 생성 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-19-AutomaticalmostresourcegenerationfromFigmaforCompose_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-06-19-AutomaticalmostresourcegenerationfromFigmaforCompose" data-gatsby-head="true"/><meta name="twitter:title" content="피그마로부터 코틀린 Compose를 위한 자동 거의 자원 생성 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-19-AutomaticalmostresourcegenerationfromFigmaforCompose_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-19 13:44" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-4f7b40c1114f0d09.js" defer=""></script><script src="/_next/static/YUMR4jSyk_WlOHHc7UfOk/_buildManifest.js" defer=""></script><script src="/_next/static/YUMR4jSyk_WlOHHc7UfOk/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">피그마로부터 코틀린 Compose를 위한 자동 거의 자원 생성</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="피그마로부터 코틀린 Compose를 위한 자동 거의 자원 생성" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 19, 2024</span><span class="posts_reading_time__f7YPP">8<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-19-AutomaticalmostresourcegenerationfromFigmaforCompose&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/assets/img/2024-06-19-AutomaticalmostresourcegenerationfromFigmaforCompose_0.png" alt="image"></p>
<p>자동화에 대해 이야기해보겠습니다. 루틴적이고 시간이 많이 소요되는 프로세스를 자동화해야 할 때가 많습니다. 이전 프로젝트에서는 클라이언트를 위한 다양한 UI 사용자 정의가 포함된 단일 코드베이스 기반의 화이트 레이블 솔루션을 갖고 있었습니다. 이 게시물에서는 디자이너의 변경 사항을 찾는 데 추가 시간을 낭비하지 않고 즉시 코드 작성을 시작하는 데 도움이 된 다양한 접근 방식과 도구에 대해 이야기하겠습니다.</p>
<h1>FIGMA/WHATEVER DSM</h1>
<p>기초부터 시작해보겠습니다. 디자이너들도 DRY 원칙을 따르기 위해 노력하며 Design System Manager와 같은 훌륭한 도구를 개발합니다. 먼저, 프로젝트에서 반복될 수 있는 구성요소를 식별하고 색상 및 스타일의 구조화된 세트를 개발합니다. 따라서 한 곳에서 색상이나 스타일이 변경되면 전체 프로젝트에서 자동으로 변경됩니다. 편리하죠? Figma나 다른 도구를 사용하여 이러한 구성을 특별한 파일로 내보낼 수 있으며, 그 파일을 분석하여 이를 기반으로 코드를 생성할 수 있습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>Jetpack Compose을 사용하면 ColorScheme과 TextStyle과 같은 클래스를 알 수 있을 것입니다. Material 철학에 따라, 우리는 ColorScheme을 사용하여 색상을 설명하고 TextStyle을 사용하여 텍스트의 모양을 설명합니다. 이는 컴포넌트가 렌더링하는 데 사용되는 것입니다.</p>
<h1>코드 생성</h1>
<p>Room, Dagger2와 같은 라이브러리를 사용해 본 적이 있다면, 이미 익숙한 개념일 수 있습니다.</p>
<p>Java에서는 이 개념을 주석 처리(annotation processing)이라고 하며, Kotlin에서는 kapt 또는 ksp로 참조됩니다. 본질적으로 코드를 분석하고 추가 파일을 생성하는 컴파일러 기능입니다. 그러나 JSON 파일에 주석을 첨부할 수 없고 Kotlin 파일이 아니기 때문에, 여기에는 다른 해결책이 필요합니다. 따라서, 입력 데이터를 가져와 필요한 파일을 찾아 필요한 클래스를 생성하는 플러그인을 개발하는 방법을 배울 것입니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>Gradle 플러그인</h1>
<p>Gradle 플러그인을 만드는 방법은 main 그레이들 파일에 작업을 작성하는 것에서 buildSrc에 코드를 배치하는 것까지 다양합니다. 그러나 저희는 권장 사항을 따라 composite 빌드를 사용할 것입니다. 이 아이디어는 간단합니다: 플러그인은 애플리케이션 코드와 분리되어 유지되고, 그런 다음 모든 것이 결합됩니다. 여기에서 AGP와 함께 이 메커니즘을 사용하는 방법에 대한 많은 예를 찾을 수 있으며, 오랫동안 가지고 있던 질문에 대한 답변을 찾을 수 있습니다.</p>
<p><img src="/assets/img/2024-06-19-AutomaticalmostresourcegenerationfromFigmaforCompose_1.png" alt="이미지"></p>
<p>여기에 특별한 것은 없습니다. 차이는 플러그인이 가장 높은 수준에서 어떻게 연결되는지에 있습니다. includeBuild()를 사용하여 연결합니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>당신의 플러그인 프로젝트의 build.gradle.kts 파일에서, 플러그인이 제대로 작동하기 위해 필요한 종속성 및 기본 구성을 명시해야 합니다. 다음은 플러그인을 위한 예시 설정입니다:</p>
<h1>Gradle 플러그인 구현</h1>
<p>젯팩 콤포즈에 대한 Figma 파일 생성을 자동화하기 위한 목표를 달성하기 위해, Gradle 플러그인을 사용하여 다음 단계를 따라야 합니다:</p>
<ul>
<li>DSM 토큰의 구조를 분석하고 해당 모델을 준비합니다.</li>
<li>프로젝트에 각 클라이언트 디자인을 설명하는 토큰을 포함하는 모든 가능한 플레이버를 찾습니다.</li>
<li>이 데이터를 분석하여 필요한 파일을 생성하는 방법을 학습합니다.</li>
<li>이를 편리하게 만들고 Gradle 작업에 포장합니다.</li>
<li>...</li>
<li>코드를 작성하세요!</li>
</ul>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>파일에는 색상 설명이 포함되어 있습니다. 이 설명은 여러 논리적 수준으로 구성될 수 있으며, 마지막 수준에는 우리가 관심을 가지는 정보가 포함되어 있습니다. 일반적으로 리소스는 유사한 구조를 가지며, 타입과 값이 명시됩니다.</p>
<pre><code class="hljs language-js">{
  <span class="hljs-string">"color"</span>: {
    <span class="hljs-string">"m3"</span>: {
      <span class="hljs-string">"white"</span>: {
        <span class="hljs-string">"description"</span>: <span class="hljs-string">""</span>,
        <span class="hljs-string">"type"</span>: <span class="hljs-string">"color"</span>,
        <span class="hljs-string">"value"</span>: <span class="hljs-string">"#ffffffff"</span>,
        <span class="hljs-string">"blendMode"</span>: <span class="hljs-string">"normal"</span>
      },
      <span class="hljs-string">"black"</span>: {...},
      <span class="hljs-string">"sys"</span>: {
        <span class="hljs-string">"light"</span>: {...},
        <span class="hljs-string">"dark"</span>: {...}
      },
      <span class="hljs-string">"ref"</span>: {...},
      <span class="hljs-string">"key-colors"</span>: {...},
      <span class="hljs-string">"source"</span>: {...},
      <span class="hljs-string">"surfaces"</span>: {...},
      <span class="hljs-string">"state-layers"</span>: {...}
    }
  },
  <span class="hljs-string">"font"</span>: {...},
  <span class="hljs-string">"typography"</span>: {...}
}
</code></pre>
<p>색상에 대해서는 해당 값을 관심 있게 살펴보고 있으며, 해당 클래스에는 해당 색상의 16진수 표현이 포함됩니다.</p>
<h1>Gradle 작업</h1>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>작업 등록 중에는 주석으로 표시된 모든 필드를 설정해야 합니다. 즉, JSON 파일의 경로, 플레이버 폴더의 경로 및 생성된 파일의 최종 패키지입니다.</p>
<p>우리의 삶을 편하게 하기 위해 몇 가지를 하드코딩할 것이지만, 더 많은 유연성이 필요한 경우 gradle 확장 기능을 살펴볼 가치가 있습니다.</p>
<p>이 작업은 추상적이므로 일부 구성은 구현에 맡겨둡니다. 따라서 색상 파일을 생성할 작업의 구조는 다음과 같이 보일 것입니다.
우리의 작업을 실행할 수 있게 하려면 프로젝트에 등록해야 합니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>우선 플러그인을 사용하여 프로젝트에 존재하는 빌드 변형을 결정하고 각 유형에 대한 작업을 등록해야 합니다.</p>
<p>이제 가장 흥미로운 부분으로 넘어가 봅시다. 파일 생성이 실제로 어떻게 일어나는지요.</p>
<p>이를 위해 KotlinPoet라는 도구를 사용해야 합니다. 이 도구를 사용하면 필요한 파일을 쉽게 생성할 수 있습니다. 이 전체 매커니즘은 다양한 빌더로 구성되어 있으며, 여기에 파일 유형, 속성, 값 등을 추가합니다.</p>
<p>우리의 작업 핵심은 JSON 구문 분석, 필요한 데이터 획득 및 해당 파일에 쓰는 데 있습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>JSON 파일의 구조를 알고 있기 때문에 데이터를 수집하는 함수를 작성할 수 있어요. 결과적으로 필드 이름을 키로, 모델을 값으로 하는 맵이 만들어질 거예요.</p>
<p>모든 필드의 목록을 갖게 되면, KotlinPoet을 사용하여 파일에 생성하고 싶은 내용을 설명할 수 있어요. 그 결과, 다음과 같은 모습의 파일을 얻게 될 거예요:</p>
<p><img src="/assets/img/2024-06-19-AutomaticalmostresourcegenerationfromFigmaforCompose_2.png" alt="이미지"></p>
<p><img src="/assets/img/2024-06-19-AutomaticalmostresourcegenerationfromFigmaforCompose_3.png" alt="이미지"></p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>생성된 파일을 사용하여 테마를 설명할 수 있습니다.</p>
<p><img src="/assets/img/2024-06-19-AutomaticalmostresourcegenerationfromFigmaforCompose_4.png" alt="Image 4"></p>
<p><img src="/assets/img/2024-06-19-AutomaticalmostresourcegenerationfromFigmaforCompose_5.png" alt="Image 5"></p>
<p><img src="/assets/img/2024-06-19-AutomaticalmostresourcegenerationfromFigmaforCompose_6.png" alt="Image 6"></p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>그게 다야! 우리의 초기 작업은 완료되었습니다. 이제 파일을 프로젝트에 업로드하고 작업을 실행하여 개발에 사용할 수 있는 파일을 얻을 수 있습니다. 이전에는 수동으로 수행되어 인간 요인으로 인한 오류가 포함될 수 있었지만, 이제는 원활하게 작동하며 추가 종속성이 필요하지 않습니다(Android와 iOS 솔루션은 기존의 Node.js 모듈을 설치하여 작업을 수행하지 못했으며 여전히 개발자 개입이 필요했습니다).</p>
<h1>명백하지 않은 도전 과제</h1>
<p>플러그인 개발은 문제 해결의 절반입니다. 언제나 문제가 발생할 수 있습니다:</p>
<ul>
<li>프로젝트 복잡성으로 인해 디자이너들은 Material Design을 제대로 사용하지 않고 수십, 아니 수백 개의 사용자 정의된 이름을 가진 색상과 스타일을 만들었습니다. 이로 인해 표준 MaterialTheme을 사용할 수 없었고, 결과적으로 우리 플러그인은 사용자 정의 ColorScheme과 Typography 클래스를 생성했습니다.</li>
<li>초기 개발 및 이전 이관에 상당한 시간이 소요되었지만, Material 설정이 깨끗하고 디자이너와의 토큰 이름 문제를 해결하는 데 몇 시간을 보낼 필요가 없다면 이것은 문제가 되지 않습니다.</li>
<li>@Preview 주석은 모두 우리 사용자 정의 테마로 래핑되어야 합니다.</li>
<li>디자인 자체가 문제일 수 있습니다. 고객 중 한 명은 그라데이션을 가진 버튼을 가졌는데, 이 토큰에는 색상을 사용해야 했습니다. 이 문제는 임시 해결 방법으로 우아하게 해결되었지만, 미래에 이러한 충돌이 발생하지 않도록 디자이너에게 강력히 당부했습니다.</li>
<li>구성 복잡성 - 과정 자체는 간단하지만, 이전 문제와 같은 문제는 플러그인의 논리나 모델 구조를 크게 변경해야 할 수 있습니다.</li>
</ul>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>그거면 끝이에요. 비슷한 솔루션을 만들어 본 경험이 있거나 미리보기를 위해 매번 사용자 정의 테마를 작성하는 것을 피하는 방법을 아시는 분들은 댓글에서 공유해 주세요. 코드가 필요한 경우 전체 프로젝트는 여기에서 확인할 수 있습니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"피그마로부터 코틀린 Compose를 위한 자동 거의 자원 생성","description":"","date":"2024-06-19 13:44","slug":"2024-06-19-AutomaticalmostresourcegenerationfromFigmaforCompose","content":"\n![image](/assets/img/2024-06-19-AutomaticalmostresourcegenerationfromFigmaforCompose_0.png)\n\n자동화에 대해 이야기해보겠습니다. 루틴적이고 시간이 많이 소요되는 프로세스를 자동화해야 할 때가 많습니다. 이전 프로젝트에서는 클라이언트를 위한 다양한 UI 사용자 정의가 포함된 단일 코드베이스 기반의 화이트 레이블 솔루션을 갖고 있었습니다. 이 게시물에서는 디자이너의 변경 사항을 찾는 데 추가 시간을 낭비하지 않고 즉시 코드 작성을 시작하는 데 도움이 된 다양한 접근 방식과 도구에 대해 이야기하겠습니다.\n\n# FIGMA/WHATEVER DSM\n\n기초부터 시작해보겠습니다. 디자이너들도 DRY 원칙을 따르기 위해 노력하며 Design System Manager와 같은 훌륭한 도구를 개발합니다. 먼저, 프로젝트에서 반복될 수 있는 구성요소를 식별하고 색상 및 스타일의 구조화된 세트를 개발합니다. 따라서 한 곳에서 색상이나 스타일이 변경되면 전체 프로젝트에서 자동으로 변경됩니다. 편리하죠? Figma나 다른 도구를 사용하여 이러한 구성을 특별한 파일로 내보낼 수 있으며, 그 파일을 분석하여 이를 기반으로 코드를 생성할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nJetpack Compose을 사용하면 ColorScheme과 TextStyle과 같은 클래스를 알 수 있을 것입니다. Material 철학에 따라, 우리는 ColorScheme을 사용하여 색상을 설명하고 TextStyle을 사용하여 텍스트의 모양을 설명합니다. 이는 컴포넌트가 렌더링하는 데 사용되는 것입니다.\n\n# 코드 생성\n\nRoom, Dagger2와 같은 라이브러리를 사용해 본 적이 있다면, 이미 익숙한 개념일 수 있습니다.\n\nJava에서는 이 개념을 주석 처리(annotation processing)이라고 하며, Kotlin에서는 kapt 또는 ksp로 참조됩니다. 본질적으로 코드를 분석하고 추가 파일을 생성하는 컴파일러 기능입니다. 그러나 JSON 파일에 주석을 첨부할 수 없고 Kotlin 파일이 아니기 때문에, 여기에는 다른 해결책이 필요합니다. 따라서, 입력 데이터를 가져와 필요한 파일을 찾아 필요한 클래스를 생성하는 플러그인을 개발하는 방법을 배울 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# Gradle 플러그인\n\nGradle 플러그인을 만드는 방법은 main 그레이들 파일에 작업을 작성하는 것에서 buildSrc에 코드를 배치하는 것까지 다양합니다. 그러나 저희는 권장 사항을 따라 composite 빌드를 사용할 것입니다. 이 아이디어는 간단합니다: 플러그인은 애플리케이션 코드와 분리되어 유지되고, 그런 다음 모든 것이 결합됩니다. 여기에서 AGP와 함께 이 메커니즘을 사용하는 방법에 대한 많은 예를 찾을 수 있으며, 오랫동안 가지고 있던 질문에 대한 답변을 찾을 수 있습니다.\n\n![이미지](/assets/img/2024-06-19-AutomaticalmostresourcegenerationfromFigmaforCompose_1.png)\n\n여기에 특별한 것은 없습니다. 차이는 플러그인이 가장 높은 수준에서 어떻게 연결되는지에 있습니다. includeBuild()를 사용하여 연결합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n당신의 플러그인 프로젝트의 build.gradle.kts 파일에서, 플러그인이 제대로 작동하기 위해 필요한 종속성 및 기본 구성을 명시해야 합니다. 다음은 플러그인을 위한 예시 설정입니다:\n\n# Gradle 플러그인 구현\n\n젯팩 콤포즈에 대한 Figma 파일 생성을 자동화하기 위한 목표를 달성하기 위해, Gradle 플러그인을 사용하여 다음 단계를 따라야 합니다:\n\n- DSM 토큰의 구조를 분석하고 해당 모델을 준비합니다.\n- 프로젝트에 각 클라이언트 디자인을 설명하는 토큰을 포함하는 모든 가능한 플레이버를 찾습니다.\n- 이 데이터를 분석하여 필요한 파일을 생성하는 방법을 학습합니다.\n- 이를 편리하게 만들고 Gradle 작업에 포장합니다.\n- ...\n- 코드를 작성하세요!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n파일에는 색상 설명이 포함되어 있습니다. 이 설명은 여러 논리적 수준으로 구성될 수 있으며, 마지막 수준에는 우리가 관심을 가지는 정보가 포함되어 있습니다. 일반적으로 리소스는 유사한 구조를 가지며, 타입과 값이 명시됩니다.\n\n```js\n{\n  \"color\": {\n    \"m3\": {\n      \"white\": {\n        \"description\": \"\",\n        \"type\": \"color\",\n        \"value\": \"#ffffffff\",\n        \"blendMode\": \"normal\"\n      },\n      \"black\": {...},\n      \"sys\": {\n        \"light\": {...},\n        \"dark\": {...}\n      },\n      \"ref\": {...},\n      \"key-colors\": {...},\n      \"source\": {...},\n      \"surfaces\": {...},\n      \"state-layers\": {...}\n    }\n  },\n  \"font\": {...},\n  \"typography\": {...}\n}\n```\n\n색상에 대해서는 해당 값을 관심 있게 살펴보고 있으며, 해당 클래스에는 해당 색상의 16진수 표현이 포함됩니다.\n\n# Gradle 작업\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n작업 등록 중에는 주석으로 표시된 모든 필드를 설정해야 합니다. 즉, JSON 파일의 경로, 플레이버 폴더의 경로 및 생성된 파일의 최종 패키지입니다.\n\n우리의 삶을 편하게 하기 위해 몇 가지를 하드코딩할 것이지만, 더 많은 유연성이 필요한 경우 gradle 확장 기능을 살펴볼 가치가 있습니다.\n\n이 작업은 추상적이므로 일부 구성은 구현에 맡겨둡니다. 따라서 색상 파일을 생성할 작업의 구조는 다음과 같이 보일 것입니다.\n우리의 작업을 실행할 수 있게 하려면 프로젝트에 등록해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우선 플러그인을 사용하여 프로젝트에 존재하는 빌드 변형을 결정하고 각 유형에 대한 작업을 등록해야 합니다.\n\n이제 가장 흥미로운 부분으로 넘어가 봅시다. 파일 생성이 실제로 어떻게 일어나는지요.\n\n이를 위해 KotlinPoet라는 도구를 사용해야 합니다. 이 도구를 사용하면 필요한 파일을 쉽게 생성할 수 있습니다. 이 전체 매커니즘은 다양한 빌더로 구성되어 있으며, 여기에 파일 유형, 속성, 값 등을 추가합니다.\n\n우리의 작업 핵심은 JSON 구문 분석, 필요한 데이터 획득 및 해당 파일에 쓰는 데 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nJSON 파일의 구조를 알고 있기 때문에 데이터를 수집하는 함수를 작성할 수 있어요. 결과적으로 필드 이름을 키로, 모델을 값으로 하는 맵이 만들어질 거예요.\n\n모든 필드의 목록을 갖게 되면, KotlinPoet을 사용하여 파일에 생성하고 싶은 내용을 설명할 수 있어요. 그 결과, 다음과 같은 모습의 파일을 얻게 될 거예요:\n\n![이미지](/assets/img/2024-06-19-AutomaticalmostresourcegenerationfromFigmaforCompose_2.png)\n\n![이미지](/assets/img/2024-06-19-AutomaticalmostresourcegenerationfromFigmaforCompose_3.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n생성된 파일을 사용하여 테마를 설명할 수 있습니다.\n\n![Image 4](/assets/img/2024-06-19-AutomaticalmostresourcegenerationfromFigmaforCompose_4.png)\n\n![Image 5](/assets/img/2024-06-19-AutomaticalmostresourcegenerationfromFigmaforCompose_5.png)\n\n![Image 6](/assets/img/2024-06-19-AutomaticalmostresourcegenerationfromFigmaforCompose_6.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그게 다야! 우리의 초기 작업은 완료되었습니다. 이제 파일을 프로젝트에 업로드하고 작업을 실행하여 개발에 사용할 수 있는 파일을 얻을 수 있습니다. 이전에는 수동으로 수행되어 인간 요인으로 인한 오류가 포함될 수 있었지만, 이제는 원활하게 작동하며 추가 종속성이 필요하지 않습니다(Android와 iOS 솔루션은 기존의 Node.js 모듈을 설치하여 작업을 수행하지 못했으며 여전히 개발자 개입이 필요했습니다).\n\n# 명백하지 않은 도전 과제\n\n플러그인 개발은 문제 해결의 절반입니다. 언제나 문제가 발생할 수 있습니다:\n\n- 프로젝트 복잡성으로 인해 디자이너들은 Material Design을 제대로 사용하지 않고 수십, 아니 수백 개의 사용자 정의된 이름을 가진 색상과 스타일을 만들었습니다. 이로 인해 표준 MaterialTheme을 사용할 수 없었고, 결과적으로 우리 플러그인은 사용자 정의 ColorScheme과 Typography 클래스를 생성했습니다.\n- 초기 개발 및 이전 이관에 상당한 시간이 소요되었지만, Material 설정이 깨끗하고 디자이너와의 토큰 이름 문제를 해결하는 데 몇 시간을 보낼 필요가 없다면 이것은 문제가 되지 않습니다.\n- @Preview 주석은 모두 우리 사용자 정의 테마로 래핑되어야 합니다.\n- 디자인 자체가 문제일 수 있습니다. 고객 중 한 명은 그라데이션을 가진 버튼을 가졌는데, 이 토큰에는 색상을 사용해야 했습니다. 이 문제는 임시 해결 방법으로 우아하게 해결되었지만, 미래에 이러한 충돌이 발생하지 않도록 디자이너에게 강력히 당부했습니다.\n- 구성 복잡성 - 과정 자체는 간단하지만, 이전 문제와 같은 문제는 플러그인의 논리나 모델 구조를 크게 변경해야 할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그거면 끝이에요. 비슷한 솔루션을 만들어 본 경험이 있거나 미리보기를 위해 매번 사용자 정의 테마를 작성하는 것을 피하는 방법을 아시는 분들은 댓글에서 공유해 주세요. 코드가 필요한 경우 전체 프로젝트는 여기에서 확인할 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-06-19-AutomaticalmostresourcegenerationfromFigmaforCompose_0.png"},"coverImage":"/assets/img/2024-06-19-AutomaticalmostresourcegenerationfromFigmaforCompose_0.png","tag":["Tech"],"readingTime":8},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-AutomaticalmostresourcegenerationfromFigmaforCompose_0.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e자동화에 대해 이야기해보겠습니다. 루틴적이고 시간이 많이 소요되는 프로세스를 자동화해야 할 때가 많습니다. 이전 프로젝트에서는 클라이언트를 위한 다양한 UI 사용자 정의가 포함된 단일 코드베이스 기반의 화이트 레이블 솔루션을 갖고 있었습니다. 이 게시물에서는 디자이너의 변경 사항을 찾는 데 추가 시간을 낭비하지 않고 즉시 코드 작성을 시작하는 데 도움이 된 다양한 접근 방식과 도구에 대해 이야기하겠습니다.\u003c/p\u003e\n\u003ch1\u003eFIGMA/WHATEVER DSM\u003c/h1\u003e\n\u003cp\u003e기초부터 시작해보겠습니다. 디자이너들도 DRY 원칙을 따르기 위해 노력하며 Design System Manager와 같은 훌륭한 도구를 개발합니다. 먼저, 프로젝트에서 반복될 수 있는 구성요소를 식별하고 색상 및 스타일의 구조화된 세트를 개발합니다. 따라서 한 곳에서 색상이나 스타일이 변경되면 전체 프로젝트에서 자동으로 변경됩니다. 편리하죠? Figma나 다른 도구를 사용하여 이러한 구성을 특별한 파일로 내보낼 수 있으며, 그 파일을 분석하여 이를 기반으로 코드를 생성할 수 있습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eJetpack Compose을 사용하면 ColorScheme과 TextStyle과 같은 클래스를 알 수 있을 것입니다. Material 철학에 따라, 우리는 ColorScheme을 사용하여 색상을 설명하고 TextStyle을 사용하여 텍스트의 모양을 설명합니다. 이는 컴포넌트가 렌더링하는 데 사용되는 것입니다.\u003c/p\u003e\n\u003ch1\u003e코드 생성\u003c/h1\u003e\n\u003cp\u003eRoom, Dagger2와 같은 라이브러리를 사용해 본 적이 있다면, 이미 익숙한 개념일 수 있습니다.\u003c/p\u003e\n\u003cp\u003eJava에서는 이 개념을 주석 처리(annotation processing)이라고 하며, Kotlin에서는 kapt 또는 ksp로 참조됩니다. 본질적으로 코드를 분석하고 추가 파일을 생성하는 컴파일러 기능입니다. 그러나 JSON 파일에 주석을 첨부할 수 없고 Kotlin 파일이 아니기 때문에, 여기에는 다른 해결책이 필요합니다. 따라서, 입력 데이터를 가져와 필요한 파일을 찾아 필요한 클래스를 생성하는 플러그인을 개발하는 방법을 배울 것입니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003eGradle 플러그인\u003c/h1\u003e\n\u003cp\u003eGradle 플러그인을 만드는 방법은 main 그레이들 파일에 작업을 작성하는 것에서 buildSrc에 코드를 배치하는 것까지 다양합니다. 그러나 저희는 권장 사항을 따라 composite 빌드를 사용할 것입니다. 이 아이디어는 간단합니다: 플러그인은 애플리케이션 코드와 분리되어 유지되고, 그런 다음 모든 것이 결합됩니다. 여기에서 AGP와 함께 이 메커니즘을 사용하는 방법에 대한 많은 예를 찾을 수 있으며, 오랫동안 가지고 있던 질문에 대한 답변을 찾을 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-AutomaticalmostresourcegenerationfromFigmaforCompose_1.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e여기에 특별한 것은 없습니다. 차이는 플러그인이 가장 높은 수준에서 어떻게 연결되는지에 있습니다. includeBuild()를 사용하여 연결합니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e당신의 플러그인 프로젝트의 build.gradle.kts 파일에서, 플러그인이 제대로 작동하기 위해 필요한 종속성 및 기본 구성을 명시해야 합니다. 다음은 플러그인을 위한 예시 설정입니다:\u003c/p\u003e\n\u003ch1\u003eGradle 플러그인 구현\u003c/h1\u003e\n\u003cp\u003e젯팩 콤포즈에 대한 Figma 파일 생성을 자동화하기 위한 목표를 달성하기 위해, Gradle 플러그인을 사용하여 다음 단계를 따라야 합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDSM 토큰의 구조를 분석하고 해당 모델을 준비합니다.\u003c/li\u003e\n\u003cli\u003e프로젝트에 각 클라이언트 디자인을 설명하는 토큰을 포함하는 모든 가능한 플레이버를 찾습니다.\u003c/li\u003e\n\u003cli\u003e이 데이터를 분석하여 필요한 파일을 생성하는 방법을 학습합니다.\u003c/li\u003e\n\u003cli\u003e이를 편리하게 만들고 Gradle 작업에 포장합니다.\u003c/li\u003e\n\u003cli\u003e...\u003c/li\u003e\n\u003cli\u003e코드를 작성하세요!\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e파일에는 색상 설명이 포함되어 있습니다. 이 설명은 여러 논리적 수준으로 구성될 수 있으며, 마지막 수준에는 우리가 관심을 가지는 정보가 포함되어 있습니다. 일반적으로 리소스는 유사한 구조를 가지며, 타입과 값이 명시됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e{\n  \u003cspan class=\"hljs-string\"\u003e\"color\"\u003c/span\u003e: {\n    \u003cspan class=\"hljs-string\"\u003e\"m3\"\u003c/span\u003e: {\n      \u003cspan class=\"hljs-string\"\u003e\"white\"\u003c/span\u003e: {\n        \u003cspan class=\"hljs-string\"\u003e\"description\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e\"type\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"color\"\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e\"value\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"#ffffffff\"\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e\"blendMode\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"normal\"\u003c/span\u003e\n      },\n      \u003cspan class=\"hljs-string\"\u003e\"black\"\u003c/span\u003e: {...},\n      \u003cspan class=\"hljs-string\"\u003e\"sys\"\u003c/span\u003e: {\n        \u003cspan class=\"hljs-string\"\u003e\"light\"\u003c/span\u003e: {...},\n        \u003cspan class=\"hljs-string\"\u003e\"dark\"\u003c/span\u003e: {...}\n      },\n      \u003cspan class=\"hljs-string\"\u003e\"ref\"\u003c/span\u003e: {...},\n      \u003cspan class=\"hljs-string\"\u003e\"key-colors\"\u003c/span\u003e: {...},\n      \u003cspan class=\"hljs-string\"\u003e\"source\"\u003c/span\u003e: {...},\n      \u003cspan class=\"hljs-string\"\u003e\"surfaces\"\u003c/span\u003e: {...},\n      \u003cspan class=\"hljs-string\"\u003e\"state-layers\"\u003c/span\u003e: {...}\n    }\n  },\n  \u003cspan class=\"hljs-string\"\u003e\"font\"\u003c/span\u003e: {...},\n  \u003cspan class=\"hljs-string\"\u003e\"typography\"\u003c/span\u003e: {...}\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e색상에 대해서는 해당 값을 관심 있게 살펴보고 있으며, 해당 클래스에는 해당 색상의 16진수 표현이 포함됩니다.\u003c/p\u003e\n\u003ch1\u003eGradle 작업\u003c/h1\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e작업 등록 중에는 주석으로 표시된 모든 필드를 설정해야 합니다. 즉, JSON 파일의 경로, 플레이버 폴더의 경로 및 생성된 파일의 최종 패키지입니다.\u003c/p\u003e\n\u003cp\u003e우리의 삶을 편하게 하기 위해 몇 가지를 하드코딩할 것이지만, 더 많은 유연성이 필요한 경우 gradle 확장 기능을 살펴볼 가치가 있습니다.\u003c/p\u003e\n\u003cp\u003e이 작업은 추상적이므로 일부 구성은 구현에 맡겨둡니다. 따라서 색상 파일을 생성할 작업의 구조는 다음과 같이 보일 것입니다.\n우리의 작업을 실행할 수 있게 하려면 프로젝트에 등록해야 합니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e우선 플러그인을 사용하여 프로젝트에 존재하는 빌드 변형을 결정하고 각 유형에 대한 작업을 등록해야 합니다.\u003c/p\u003e\n\u003cp\u003e이제 가장 흥미로운 부분으로 넘어가 봅시다. 파일 생성이 실제로 어떻게 일어나는지요.\u003c/p\u003e\n\u003cp\u003e이를 위해 KotlinPoet라는 도구를 사용해야 합니다. 이 도구를 사용하면 필요한 파일을 쉽게 생성할 수 있습니다. 이 전체 매커니즘은 다양한 빌더로 구성되어 있으며, 여기에 파일 유형, 속성, 값 등을 추가합니다.\u003c/p\u003e\n\u003cp\u003e우리의 작업 핵심은 JSON 구문 분석, 필요한 데이터 획득 및 해당 파일에 쓰는 데 있습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eJSON 파일의 구조를 알고 있기 때문에 데이터를 수집하는 함수를 작성할 수 있어요. 결과적으로 필드 이름을 키로, 모델을 값으로 하는 맵이 만들어질 거예요.\u003c/p\u003e\n\u003cp\u003e모든 필드의 목록을 갖게 되면, KotlinPoet을 사용하여 파일에 생성하고 싶은 내용을 설명할 수 있어요. 그 결과, 다음과 같은 모습의 파일을 얻게 될 거예요:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-AutomaticalmostresourcegenerationfromFigmaforCompose_2.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-AutomaticalmostresourcegenerationfromFigmaforCompose_3.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e생성된 파일을 사용하여 테마를 설명할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-AutomaticalmostresourcegenerationfromFigmaforCompose_4.png\" alt=\"Image 4\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-AutomaticalmostresourcegenerationfromFigmaforCompose_5.png\" alt=\"Image 5\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-AutomaticalmostresourcegenerationfromFigmaforCompose_6.png\" alt=\"Image 6\"\u003e\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e그게 다야! 우리의 초기 작업은 완료되었습니다. 이제 파일을 프로젝트에 업로드하고 작업을 실행하여 개발에 사용할 수 있는 파일을 얻을 수 있습니다. 이전에는 수동으로 수행되어 인간 요인으로 인한 오류가 포함될 수 있었지만, 이제는 원활하게 작동하며 추가 종속성이 필요하지 않습니다(Android와 iOS 솔루션은 기존의 Node.js 모듈을 설치하여 작업을 수행하지 못했으며 여전히 개발자 개입이 필요했습니다).\u003c/p\u003e\n\u003ch1\u003e명백하지 않은 도전 과제\u003c/h1\u003e\n\u003cp\u003e플러그인 개발은 문제 해결의 절반입니다. 언제나 문제가 발생할 수 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e프로젝트 복잡성으로 인해 디자이너들은 Material Design을 제대로 사용하지 않고 수십, 아니 수백 개의 사용자 정의된 이름을 가진 색상과 스타일을 만들었습니다. 이로 인해 표준 MaterialTheme을 사용할 수 없었고, 결과적으로 우리 플러그인은 사용자 정의 ColorScheme과 Typography 클래스를 생성했습니다.\u003c/li\u003e\n\u003cli\u003e초기 개발 및 이전 이관에 상당한 시간이 소요되었지만, Material 설정이 깨끗하고 디자이너와의 토큰 이름 문제를 해결하는 데 몇 시간을 보낼 필요가 없다면 이것은 문제가 되지 않습니다.\u003c/li\u003e\n\u003cli\u003e@Preview 주석은 모두 우리 사용자 정의 테마로 래핑되어야 합니다.\u003c/li\u003e\n\u003cli\u003e디자인 자체가 문제일 수 있습니다. 고객 중 한 명은 그라데이션을 가진 버튼을 가졌는데, 이 토큰에는 색상을 사용해야 했습니다. 이 문제는 임시 해결 방법으로 우아하게 해결되었지만, 미래에 이러한 충돌이 발생하지 않도록 디자이너에게 강력히 당부했습니다.\u003c/li\u003e\n\u003cli\u003e구성 복잡성 - 과정 자체는 간단하지만, 이전 문제와 같은 문제는 플러그인의 논리나 모델 구조를 크게 변경해야 할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e그거면 끝이에요. 비슷한 솔루션을 만들어 본 경험이 있거나 미리보기를 위해 매번 사용자 정의 테마를 작성하는 것을 피하는 방법을 아시는 분들은 댓글에서 공유해 주세요. 코드가 필요한 경우 전체 프로젝트는 여기에서 확인할 수 있습니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-19-AutomaticalmostresourcegenerationfromFigmaforCompose"},"buildId":"YUMR4jSyk_WlOHHc7UfOk","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>