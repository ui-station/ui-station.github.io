<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>러스트 배우기 11부  빌더와 데이터베이스 상호작용 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-05-23-LearningRustPart11BuildersandDatabaseInteraction" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="러스트 배우기 11부  빌더와 데이터베이스 상호작용 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="러스트 배우기 11부  빌더와 데이터베이스 상호작용 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-23-LearningRustPart11BuildersandDatabaseInteraction_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-05-23-LearningRustPart11BuildersandDatabaseInteraction" data-gatsby-head="true"/><meta name="twitter:title" content="러스트 배우기 11부  빌더와 데이터베이스 상호작용 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-23-LearningRustPart11BuildersandDatabaseInteraction_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-23 14:11" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-70e5ce89f3d962ac.js" defer=""></script><script src="/_next/static/wfHLuDA3kTGBYfaM5IGXk/_buildManifest.js" defer=""></script><script src="/_next/static/wfHLuDA3kTGBYfaM5IGXk/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">러스트 배우기 11부  빌더와 데이터베이스 상호작용</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="러스트 배우기 11부  빌더와 데이터베이스 상호작용" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 23, 2024</span><span class="posts_reading_time__f7YPP">24<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-23-LearningRustPart11BuildersandDatabaseInteraction&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>다음 시리즈로 넘어가보겠습니다; 이 부분에서는 데이터 구조에 빌더 패턴을 구현하는 방법을 살펴보겠습니다. 그런 다음 sqlx와 Postgres를 사용한 데이터베이스 상호작용으로 넘어가겠습니다.</p>
<p><img src="/assets/img/2024-05-23-LearningRustPart11BuildersandDatabaseInteraction_0.png" alt="이미지"></p>
<h1>Rust 시리즈</h1>
<p>부분 1 — 기본 개념</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>Part 2 — 메모리</p>
<p>Part 3 — 흐름 제어와 함수</p>
<p>Part 4 — 옵션/결과 및 컬렉션</p>
<p>Part 5 — 트레이트, 제네릭 및 클로저</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>제 6부 — 매크로, 반복자 및 파일 처리</p>
<p>제 7부 — 스레드 공유 상태 및 채널</p>
<p>제 8부 — Cargo, 크레이트, 모듈 및 라이브러리</p>
<p>제 9부 — 명령행 인수, 워크스페이스 및 테스팅</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>제 10부 — 상자 포인터 및 웹 앱</p>
<p>제 11부 — 빌더와 데이터베이스 상호작용 (이 기사)</p>
<h1>소개</h1>
<p>이것은 러스트 학습 시리즈의 열한 번째 섹션입니다. 이번에는 러스트에서 빌더 패턴을 다룰 것입니다. 이 공통된 패턴은 구조체를 안전하고 투명하게 초기화하는 좋은 방법입니다. 다음으로, 우리는 포스트그레스와 SQLX 프레임워크를 사용하여 데이터베이스에서 CRUD 작업을 수행하는 방법을 살펴볼 것입니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>준비물</h1>
<p>이 글의 데이터베이스 부분을 위한 유일한 준비물은 Rust와 Cargo가 설치되어 있고 시스템에 Docker가 설치되어 있는 것입니다. 만약 Docker를 가지고 있지 않지만 로컬 Postgres DB가 이미 설치되어 있거나 다른 서버의 DB에 액세스할 수 있다면 Docker Postgres 설정을 건너뛰고 DB에 연결하기 위한 연결 속성만 수정하면 됩니다.</p>
<h1>빌더 패턴</h1>
<p>빌더 패턴은 복잡한 객체의 구성을 해당 표현에서 분리하는 디자인 패턴입니다. 이 패턴을 사용하면 유효성 검사를 수행하고 기본값으로 대체하며 값을 부분적으로 할당한 후에 항목을 생성할 수 있습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>Rust로 그 구현하는 방법을 살펴볼 거예요. 이것이 우리의 코드입니다.</p>
<pre><code class="hljs language-js">#[<span class="hljs-title function_">derive</span>(<span class="hljs-title class_">Debug</span>)]
struct <span class="hljs-title class_">ChargingSession</span> {
    <span class="hljs-attr">id</span>: <span class="hljs-title class_">String</span>,
    <span class="hljs-attr">watts</span>: u32,
    <span class="hljs-attr">vin</span>: <span class="hljs-title class_">String</span>,
}

struct <span class="hljs-title class_">ChargingSessionBuilder</span> {
    <span class="hljs-attr">id</span>: <span class="hljs-title class_">String</span>,
    <span class="hljs-attr">watts</span>: <span class="hljs-title class_">Option</span>&#x3C;u32>,
    <span class="hljs-attr">vin</span>: <span class="hljs-title class_">Option</span>&#x3C;<span class="hljs-title class_">String</span>>,
}

impl <span class="hljs-title class_">ChargingSessionBuilder</span> {
    fn <span class="hljs-title function_">new</span>(<span class="hljs-attr">id</span>: &#x26;str) -> <span class="hljs-title class_">ChargingSessionBuilder</span> {
        <span class="hljs-title class_">ChargingSessionBuilder</span> {
            <span class="hljs-attr">id</span>: id.<span class="hljs-title function_">to_string</span>(),
            <span class="hljs-attr">watts</span>: <span class="hljs-title class_">None</span>,
            <span class="hljs-attr">vin</span>: <span class="hljs-title class_">None</span>,
        }
    }

    fn <span class="hljs-title function_">watts</span>(mut self, <span class="hljs-attr">watts</span>: u32) -> <span class="hljs-title class_">ChargingSessionBuilder</span> {
        self.<span class="hljs-property">watts</span> = <span class="hljs-title class_">Some</span>(watts);
        self
    }

    fn <span class="hljs-title function_">vin</span>(mut self, <span class="hljs-attr">vin</span>: &#x26;str) -> <span class="hljs-title class_">ChargingSessionBuilder</span> {
        self.<span class="hljs-property">vin</span> = <span class="hljs-title class_">Some</span>(vin.<span class="hljs-title function_">to_string</span>());
        self
    }

    fn <span class="hljs-title function_">build</span>(self) -> <span class="hljs-title class_">ChargingSession</span> {
        <span class="hljs-title class_">ChargingSession</span> {
            <span class="hljs-attr">id</span>: self.<span class="hljs-property">id</span>,
            <span class="hljs-attr">watts</span>: self.<span class="hljs-property">watts</span>.<span class="hljs-title function_">unwrap_or_else</span>(|| <span class="hljs-number">0</span>),
            <span class="hljs-attr">vin</span>: self.<span class="hljs-property">vin</span>.<span class="hljs-title function_">unwrap_or_else</span>(|| <span class="hljs-string">"Unknown"</span>.<span class="hljs-title function_">to_string</span>()),
        }
    }
}

fn <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">// 이것은 ChargingSession을 생성하는 표준적인 방법입니다.</span>
    <span class="hljs-keyword">let</span> cs_old_way = <span class="hljs-title class_">ChargingSession</span> {
        <span class="hljs-attr">id</span>: <span class="hljs-title class_">String</span>::<span class="hljs-title function_">from</span>(<span class="hljs-string">"11111"</span>),
        <span class="hljs-attr">watts</span>: <span class="hljs-number">420</span>,
        <span class="hljs-attr">vin</span>: <span class="hljs-title class_">String</span>::<span class="hljs-title function_">from</span>(<span class="hljs-string">"4Y1SL65848Z411439"</span>),
    };
    println!(<span class="hljs-string">"Regular way to create struct: {:?}"</span>, cs_old_way);

    <span class="hljs-comment">// 빌더를 사용해서 생성하는 방법입니다.</span>
    <span class="hljs-keyword">let</span> cs = <span class="hljs-title class_">ChargingSessionBuilder</span>::<span class="hljs-title function_">new</span>(<span class="hljs-string">"11111"</span>)
        .<span class="hljs-title function_">watts</span>(<span class="hljs-number">420</span>)
        .<span class="hljs-title function_">vin</span>(<span class="hljs-string">"4Y1SL65848Z411439"</span>)
        .<span class="hljs-title function_">build</span>();
    println!(<span class="hljs-string">"Builder pattern to create struct: {:?}"</span>, cs);

    <span class="hljs-comment">// ID만 제공하여 생성하는 예시입니다.</span>
    <span class="hljs-keyword">let</span> cs_lean = <span class="hljs-title class_">ChargingSessionBuilder</span>::<span class="hljs-title function_">new</span>(<span class="hljs-string">"11111"</span>)
    .<span class="hljs-title function_">build</span>();
     println!(<span class="hljs-string">"Builder pattern to create struct (default values): {:?}"</span>, cs_lean);
}
</code></pre>
<p>이걸 한 번에 이해하기에 많지만, 단계적으로 진행해 봅시다.</p>
<p>먼저, 충전 세션 정보를 저장하는 구조체를 정의했습니다. 이 시리즈의 이전 예제에서 하나의 필드인 세션용 차량 ID 번호인 vin을 추가했어요.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>그러면 데이터 구조체와 동일한 필드를 가진 빌더를 위한 구조체를 정의합니다.</p>
<p>빌더는 impl 블록에서 구현되며, id 및 각 추가 필드를 설정하는 함수를 정의하는 새 함수가 있습니다. 그러나 몇 가지 중요한 사항이 있습니다.</p>
<ul>
<li>각 함수는 ChargingSessionBuilder 유형을 반환합니다. 기본적으로 self입니다.</li>
<li>추가 속성 필드에는 mut self를 첫 번째 매개변수로 사용하는 메서드가 있습니다. 이는 이러한 함수 호출의 체이닝을 허용하는 데 중요합니다. 또한 여기에 유효성 검사 논리를 코딩할 수 있습니다.</li>
<li>build 함수가 모두 통합되는 곳입니다. 존재하는 값들을 할당하고 나면 기본값을 결정하고 대상 구조체를 생성할 수 있습니다.</li>
</ul>
<p>이를 통해 빌더 패턴의 우아함과 Rust 내에서의 구현 방법을 살펴보았습니다. 이것이 앱이나 라이브러리에 코드를 구현하는 훌륭한 방법임을 알 수 있기를 바랍니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>다음 섹션인 데이터베이스로 넘어가 봅시다.</p>
<h1>데이터베이스 — sqlx</h1>
<p>이 섹션에서는 Rust 프로그램에서 sqlx를 사용하여 데이터베이스 작업을 살펴볼 것입니다. 먼저 일부 설정이 필요합니다.</p>
<h2>설정</h2>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>새 프로젝트를 시작해봅시다. db_app이라고 이름 짓고, cargo new db_app으로 생성할 수 있어요. 기본 디렉토리에 몇 개의 파일을 생성할 거에요. 첫 번째 파일은 docker-compose.yml이라고 하며 다음 내용이 있어야 합니다. Postgres와 Pgadmin이 노출되는 임의의 포트를 선택했으며, 컴퓨터에 설치된 다른 앱들과 충돌하지 않도록 했어요.</p>
<pre><code class="hljs language-js"><span class="hljs-attr">version</span>: <span class="hljs-string">'3'</span>
<span class="hljs-attr">services</span>:
  <span class="hljs-attr">postgres</span>:
    <span class="hljs-attr">image</span>: <span class="hljs-attr">postgres</span>:latest
    <span class="hljs-attr">container_name</span>: postgres
    <span class="hljs-attr">ports</span>:
      - <span class="hljs-string">'6500:5432'</span>
    <span class="hljs-attr">volumes</span>:
      - <span class="hljs-attr">postgresDB</span>:<span class="hljs-regexp">/data/</span>postgres
    <span class="hljs-attr">env_file</span>:
      - ./.<span class="hljs-property">env</span>
  <span class="hljs-attr">pgAdmin</span>:
    <span class="hljs-attr">image</span>: dpage/pgadmin4
    <span class="hljs-attr">container_name</span>: pgAdmin
    <span class="hljs-attr">env_file</span>:
      - ./.<span class="hljs-property">env</span>
    <span class="hljs-attr">ports</span>:
      - <span class="hljs-string">"5050:80"</span>
<span class="hljs-attr">volumes</span>:
  <span class="hljs-attr">postgresDB</span>:
</code></pre>
<p>.env이라는 파일이 하나 더 필요하며, 다음 내용이 있어야 해요. 이 파일은 docker-compose 파일과 나중에 Rust 애플리케이션에서 모두 사용할 거에요.</p>
<pre><code class="hljs language-js"><span class="hljs-variable constant_">POSTGRES_HOST</span>=<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>
<span class="hljs-variable constant_">POSTGRES_PORT</span>=<span class="hljs-number">6500</span>
<span class="hljs-variable constant_">POSTGRES_USER</span>=admin
<span class="hljs-variable constant_">POSTGRES_PASSWORD</span>=password123
<span class="hljs-variable constant_">POSTGRES_DB</span>=charging_session

<span class="hljs-variable constant_">DATABASE_URL</span>=<span class="hljs-attr">postgresql</span>:<span class="hljs-comment">//admin:password123@localhost:6500/charging_session?currentSchema=public</span>

<span class="hljs-variable constant_">PGADMIN_DEFAULT_EMAIL</span>=admin@admin.<span class="hljs-property">com</span>
<span class="hljs-variable constant_">PGADMIN_DEFAULT_PASSWORD</span>=password123
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>위의 내용과 함께 데이터베이스 사용자, 비밀번호, 그리고 Pgadmin에 대한 연결 정보를 제공해 드렸습니다.</p>
<p>이 두 가지 항목을 만들고 위의 내용을 사용하여 Docker Compose를 사용하여 로컬 DB 인스턴스를 시작할 수 있습니다. 처음에는 항상 전경에서 시작하는 것을 좋아합니다. 이미지 다운로드 및 기타 작업을 하기 때문에 여러분의 컴퓨터 및 네트워크 속도에 따라 시간이 소요될 수 있습니다. docker-compose.yml 및 .env 파일이 있는 디렉토리와 동일한 위치에서 다음을 실행하십시오.</p>
<pre><code class="hljs language-js">docker-compose up
</code></pre>
<p>시작된 모든 것을 확인한 후에는 언제든지 -d 스위치를 사용하여 데몬 모드로 시작할 수 있습니다. 완료되면 두 컨테이너가 시작되었는지 확인해 봅시다. 다음과 같이 명령을 실행합니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js">docker ps
</code></pre>
<p>비슷한 결과가 표시됩니다.</p>
<img src="/assets/img/2024-05-23-LearningRustPart11BuildersandDatabaseInteraction_1.png">
<p>만약 두 개의 컨테이너가 표시되지 않는다면, docker-compose를 실행한 터미널에서 에러를 확인해보세요.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>한 번 이들이 실행되면 DB에 연결해 봅시다. Pgadmin을 포트 5050에서 실행하도록 구성했으니 브라우저에서 <a href="http://localhost:5050%EC%9D%84" rel="nofollow" target="_blank">http://localhost:5050을</a> 입력하면 pgadmin의 로그인 화면이 표시됩니다. .env 파일에 구성된 자격 증명(관리자@관리자.com/비밀번호123)을 사용하여 pgadmin에 로그인할 수 있습니다. 그런데 아직 데이터베이스에 연결되지 않았습니다. 이를 위해 다음을 실행해야 합니다.</p>
<pre><code class="hljs language-js">docker inspect postgres
</code></pre>
<p>출력을 확인하여 "NetworkSettings" 섹션으로 이동하고 "IPAddress" 속성의 값을 복사합니다. 이 값은 DB에 연결하는 데 사용할 호스트(IP)입니다. 제 컴퓨터에서 이 값은 172.23.0.1 이었습니다.</p>
<p>로그인한 후 "새 서버 추가" 버튼을 클릭하고, "호스트 이름/주소"로 이전에 복사한 IP 주소를 포함한 필수 자격 증명을 제공하고 "저장" 버튼을 클릭하세요.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>서버에 로그인하면 데이터베이스 charging_session을 볼 수 있습니다.</p>
<p><img src="/assets/img/2024-05-23-LearningRustPart11BuildersandDatabaseInteraction_2.png" alt="이미지"></p>
<p>잘 했어요. 데이터베이스를 사용할 준비가 되었고 Pgadmin에서 관리할 수 있습니다.</p>
<p>이제 Rust 앱의 종속성을 구성해 봅시다. 처음에는 모두 필요하지 않지만 결국 필요하게 될 것이므로 지금 추가해 두는 것이 좋습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>Cargo.toml 파일의 종속성 부분을 다음과 같이 수정하세요.</p>
<pre><code class="hljs language-toml"><span class="hljs-section">[dependencies]</span>
<span class="hljs-attr">chrono</span> = { version = <span class="hljs-string">"0.4.31"</span>, features = [<span class="hljs-string">"serde"</span>] }
<span class="hljs-attr">dotenv</span> = <span class="hljs-string">"0.15.0"</span>
<span class="hljs-attr">env_logger</span> = <span class="hljs-string">"0.10.1"</span>
<span class="hljs-attr">log</span> = <span class="hljs-string">"0.4.20"</span>
<span class="hljs-attr">serde</span> = { version = <span class="hljs-string">"1.0.193"</span>, features = [<span class="hljs-string">"derive"</span>] }
<span class="hljs-attr">serde_json</span> = <span class="hljs-string">"1.0.108"</span>
<span class="hljs-attr">sqlx</span> = { version = <span class="hljs-string">"0.7.3"</span>, features = [<span class="hljs-string">"runtime-tokio-native-tls"</span>, <span class="hljs-string">"postgres"</span>, <span class="hljs-string">"uuid"</span>, <span class="hljs-string">"chrono"</span>] }
<span class="hljs-attr">tokio</span> = { version = <span class="hljs-string">"1.35.0"</span>, features = [<span class="hljs-string">"macros"</span>, <span class="hljs-string">"rt-multi-thread"</span>]}
<span class="hljs-attr">uuid</span> = { version = <span class="hljs-string">"1.6.1"</span>, features = [<span class="hljs-string">"serde"</span>, <span class="hljs-string">"v4"</span>] }
</code></pre>
<p>다양한 종속성에 대해 활성화된 기능을 검토하는 데도 시간을 할애하는 것이 좋습니다.</p>
<p>다음으로, 필요한 테이블을 만들기 위해 sqlx-cli 마이그레이션 기능을 사용할 것입니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>우선 명령 줄에서 다음을 실행하여 CLI를 설치해야 합니다.</p>
<pre><code class="hljs language-js">cargo install sqlx-cli --no-<span class="hljs-keyword">default</span>-features --features rustls,postgres
</code></pre>
<p>그런 다음 마이그레이션 파일을 초기화해야 합니다. 다음과 같이 실행합니다.</p>
<pre><code class="hljs language-js">sqlx migrate add initial-tables
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이 명령어는 우리가 마이그레이션 스크립트를 작성하기 위해 새 파일 migrations/<code>timestamp</code>_initial-tables.sql을 생성합니다.</p>
<p><img src="/assets/img/2024-05-23-LearningRustPart11BuildersandDatabaseInteraction_3.png" alt="이미지"></p>
<p>이 파일을 열고 아래 SQL 문을 추가하여 테이블을 생성하세요.</p>
<p>create table locations (
id bigserial primary key,
name varchar(255) unique not null
);</p>
<p>create table sessions (
id bigserial primary key,
location_id bigint not null,
watts bigint not null,
vin varchar(255) not null,
constraint fk_location foreign key (location_id) references locations(id) on delete cascade
);</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>위 예제에서 사용할 두 개의 테이블 정의입니다. 이 시리즈의 충전 세션에 대한 표준 예제를 확장하여, 충전 장치의 위치를 저장할 locations 테이블을 추가했습니다.</p>
<p>이제 다음을 실행하여 테이블을 생성하세요.</p>
<pre><code class="hljs language-js">sqlx migrate run
</code></pre>
<p>그러면 즉시 20231212235431/migrate initial-tables (타임스탬프 부분은 달라질 수 있음)과 같은 메시지가 표시됩니다. 이제 Pgadmin에 가서 테이블을 확인할 수 있습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<img src="/assets/img/2024-05-23-LearningRustPart11BuildersandDatabaseInteraction_4.png">
<p>위에서 보듯이 두 개의 테이블이 생성되었고, 문서 목적을 위해 Pgadmin 내에 ERD 다이어그램도 생성했습니다. 이제 초기 설정과 프로젝트 구성을 완료했습니다.</p>
<h1>데이터베이스 함수</h1>
<p>이 섹션에서는 데이터베이스 상호 작용의 다양한 유형과 Rust 구현을 살펴볼 것입니다. 이는 데이터베이스에 연결하는 것으로 시작됩니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>DB에 연결하기</p>
<p>데이터베이스에 연결하는 방법은 PgPoolOptions connect 함수를 통해 연결을 생성하는 것입니다. 우리의 .env 파일에서 데이터베이스 연결 문자열을 읽고 로깅을 구성하며 성공 또는 오류를 기록하는 코드 전체는 아래와 같습니다.</p>
<pre><code class="hljs language-js">use <span class="hljs-attr">sqlx</span>::{<span class="hljs-attr">postgres</span>::<span class="hljs-title class_">PgPoolOptions</span>, <span class="hljs-title class_">Pool</span>, <span class="hljs-title class_">Postgres</span>};
use <span class="hljs-attr">dotenv</span>::dotenv;
use <span class="hljs-attr">log</span>::{info, error};

#[<span class="hljs-attr">tokio</span>::main]
<span class="hljs-keyword">async</span> fn <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">if</span> <span class="hljs-attr">std</span>::<span class="hljs-attr">env</span>::<span class="hljs-title function_">var_os</span>(<span class="hljs-string">"RUST_LOG"</span>).<span class="hljs-title function_">is_none</span>(<span class="hljs-params"></span>) {
        <span class="hljs-attr">std</span>::<span class="hljs-attr">env</span>::<span class="hljs-title function_">set_var</span>(<span class="hljs-string">"RUST_LOG"</span>, <span class="hljs-string">"info"</span>);
    }
    <span class="hljs-title function_">dotenv</span>().<span class="hljs-title function_">ok</span>();
    <span class="hljs-attr">env_logger</span>::<span class="hljs-title function_">init</span>();

    <span class="hljs-keyword">let</span> database_url = <span class="hljs-attr">std</span>::<span class="hljs-attr">env</span>::<span class="hljs-title function_">var</span>(<span class="hljs-string">"DATABASE_URL"</span>).<span class="hljs-title function_">expect</span>(<span class="hljs-string">"DATABASE_URL must be set"</span>);
    <span class="hljs-keyword">let</span> pool = match <span class="hljs-title class_">PgPoolOptions</span>::<span class="hljs-title function_">new</span>()
        .<span class="hljs-title function_">max_connections</span>(<span class="hljs-number">10</span>)
        .<span class="hljs-title function_">connect</span>(&#x26;database_url)
        .<span class="hljs-property">await</span>
    {
        <span class="hljs-title class_">Ok</span>(pool) => {
            info!(<span class="hljs-string">"✅ 데이터베이스에 연결되었습니다!"</span>);
            pool
        }
        <span class="hljs-title class_">Err</span>(err) => {
            error!(<span class="hljs-string">"🔥 데이터베이스 연결에 실패했습니다: {:?}"</span>, err);
            <span class="hljs-attr">std</span>::<span class="hljs-attr">process</span>::<span class="hljs-title function_">exit</span>(<span class="hljs-number">1</span>);
        }
    };
}
</code></pre>
<p>시작 부분의 #[tokio::main] 매크로를 주목해주세요. 이는 async fn main()을 동기 fn main()로 변환하여 런타임 인스턴스를 초기화하고 async main 함수를 실행하게 합니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>위 코드를 실행하면 출력 로깅에서 다음 메시지가 표시됩니다.</p>
<p>[2023-12-13T00:16:42Z INFO db_app] ✅ 데이터베이스에 연결되었습니다!</p>
<p>우리는 데이터베이스에 연결할 수 있습니다. .env 파일에서 구성한 모든 연결 정보를 기억해 주세요. 이 정보는 docker-compose, sqlx-cli, 그리고 우리의 어플리케이션에서 공유되었습니다.</p>
<h2>Inserts</h2>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이제 연결 풀이 준비되었으니, 우리가 살펴볼 첫 번째 데이터베이스 로직은 삽입입니다. sqlx를 사용하여 삽입하는 방법은 다음과 같습니다.</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">insert_result</span> = sqlx::query_as!(
    Locations,
    <span class="hljs-string">"INSERT INTO locations (id,name) VALUES (1, 'Location A') RETURNING *"</span>
)
.<span class="hljs-title function_ invoke__">fetch_one</span>(&#x26;pool)
.<span class="hljs-keyword">await</span>;

<span class="hljs-keyword">match</span> insert_result {
    <span class="hljs-title function_ invoke__">Ok</span>(location) => {
        info!(<span class="hljs-string">"✓Inserted: {:?}"</span>, location);
    }
    <span class="hljs-title function_ invoke__">Err</span>(e) => {
        error!(<span class="hljs-string">"Error Insert: {}"</span>, e.<span class="hljs-title function_ invoke__">to_string</span>())
    }
}
</code></pre>
<p>이 코드는 하나의 레코드를 삽입할 것입니다. 물론 매개변수를 사용할 수도 있으며, 이는 업데이트를 살펴볼 때 살펴볼 것입니다.</p>
<h2>질의하기</h2>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>다음으로, 데이터베이스를 조회하는 방법을 살펴보겠습니다.</p>
<pre><code class="hljs language-js">    <span class="hljs-keyword">let</span> query_result = <span class="hljs-attr">sqlx</span>::query_as!(<span class="hljs-title class_">Locations</span>, <span class="hljs-string">"SELECT * FROM Locations"</span>)
        .<span class="hljs-title function_">fetch_all</span>(&#x26;pool)
        .<span class="hljs-property">await</span>;
    <span class="hljs-keyword">if</span> query_result.<span class="hljs-title function_">is_err</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">let</span> message = <span class="hljs-string">"모든 위치를 가져오는 동안 문제가 발생했습니다."</span>;
        error!(<span class="hljs-string">"{}{}"</span>, message, query_result.<span class="hljs-title function_">err</span>().<span class="hljs-title function_">unwrap</span>());
    } <span class="hljs-keyword">else</span> {
        info!(<span class="hljs-string">"😎 위치에 대한 쿼리 결과 {:?}"</span>, query_result.<span class="hljs-title function_">unwrap</span>());
    }
</code></pre>
<p>이것은 성공적으로 작동했다면 unwrap을 통해 결과에 접근할 수 있는 결과를 반환합니다. 쿼리 내의 이슈가 발생했다면 해당 에러에 접근할 수도 있습니다.</p>
<h2>업데이트</h2>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>다음 작업은 데이터베이스를 업데이트하는 것입니다. 이는 이전에 삽입한 것과 비슷할 것입니다.</p>
<pre><code class="hljs language-js">    <span class="hljs-keyword">let</span> update_result = <span class="hljs-attr">sqlx</span>::query_as!(
        <span class="hljs-title class_">Sessions</span>,
        <span class="hljs-string">"UPDATE sessions SET watts = 415 WHERE id = $1 RETURNING *"</span>,
        1i64,
    )
    .<span class="hljs-title function_">fetch_one</span>(&#x26;pool)
    .<span class="hljs-property">await</span>;

    match update_result {
        <span class="hljs-title class_">Ok</span>(session) => {
            info!(<span class="hljs-string">"✓Update: {:?}"</span>, session);
        }
        <span class="hljs-title class_">Err</span>(e) => {
            error!(<span class="hljs-string">"Error Update: {}"</span>, e.<span class="hljs-title function_">to_string</span>())
        }
    }
</code></pre>
<p>이 예제에서 주목할 점은 $1이라는 매개변수 자리 표시자를 사용하는 준비된 문(statement)를 사용하고 있다는 것입니다. 그런 다음 SQL 문자열 뒤에 매개변수를 전달합니다.</p>
<h2>Deletes</h2>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>마지막으로, 데이터베이스에서 레코드를 삭제하는 CRUD 작업을 완료합니다. 우리의 목적은 데이터베이스를 정리하는 데 사용할 것이며, 이렇게 하면 언제든지 응용 프로그램을 실행할 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> rows_deleted = <span class="hljs-attr">sqlx</span>::query!(<span class="hljs-string">"DELETE from sessions"</span>)
    .<span class="hljs-title function_">execute</span>(&#x26;pool)
    .<span class="hljs-property">await</span>
    .<span class="hljs-title function_">unwrap</span>()
    .<span class="hljs-title function_">rows_affected</span>();

info!(<span class="hljs-string">"✕ 세션 테이블에서 {}개의 행 삭제됨"</span>, rows_deleted);
</code></pre>
<p>여기서는 연산에서처럼 sqlx::query 대신 sqlx::query_as를 사용합니다. 또한 언랩 이후 .rows_affected를 추가하여 삭제된 행 수를 얻습니다.</p>
<h2>트랜잭션</h2>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-rust">   <span class="hljs-keyword">let</span> <span class="hljs-variable">tx</span> = pool.<span class="hljs-title function_ invoke__">begin</span>().<span class="hljs-keyword">await</span>.<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">"트랜잭션을 시작할 수 없습니다"</span>);

   <span class="hljs-comment">// 데이터베이스 작업 수행(데이터 삽입 또는 변경)</span>

   tx.<span class="hljs-title function_ invoke__">commit</span>().<span class="hljs-keyword">await</span>.<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">"트랜잭션을 커밋할 수 없습니다"</span>);
</code></pre>
<p>커밋을 호출하지 않으면 트랜잭션이 범위를 벗어나면 자동으로 롤백됩니다.</p>
<h2>완전한 응용 프로그램</h2>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>위의 코드는 우리가 이전에 논의한 모든 다양한 기능이 하나의 애플리케이션에 모두 포함된 완전한 애플리케이션입니다.</p>
<pre><code class="hljs language-js">use <span class="hljs-attr">dotenv</span>::dotenv;
use <span class="hljs-attr">log</span>::{error, info};
use <span class="hljs-attr">sqlx</span>::{<span class="hljs-attr">postgres</span>::<span class="hljs-title class_">PgPoolOptions</span>, <span class="hljs-title class_">Pool</span>, <span class="hljs-title class_">Postgres</span>};

#[<span class="hljs-title function_">derive</span>(<span class="hljs-title class_">Debug</span>)]
struct <span class="hljs-title class_">Locations</span> {
    <span class="hljs-attr">id</span>: i64,
    <span class="hljs-attr">name</span>: <span class="hljs-title class_">String</span>,
}

#[<span class="hljs-title function_">derive</span>(<span class="hljs-title class_">Debug</span>)]
struct <span class="hljs-title class_">Sessions</span> {
    <span class="hljs-attr">id</span>: i64,
    <span class="hljs-attr">location_id</span>: i64,
    <span class="hljs-attr">watts</span>: i64,
    <span class="hljs-attr">vin</span>: <span class="hljs-title class_">String</span>,
}
<span class="hljs-keyword">async</span> fn <span class="hljs-title function_">insert_into_locations</span>(<span class="hljs-params">pool: Pool&#x3C;Postgres></span>) {
    <span class="hljs-keyword">let</span> tx = pool.<span class="hljs-title function_">begin</span>().<span class="hljs-property">await</span>.<span class="hljs-title function_">expect</span>(<span class="hljs-string">"Unable to begin transaction"</span>);

    <span class="hljs-keyword">let</span> insert_result = <span class="hljs-attr">sqlx</span>::query_as!(
        <span class="hljs-title class_">Locations</span>,
        <span class="hljs-string">"INSERT INTO locations (id,name) VALUES (1, 'Location A') RETURNING *"</span>
    )
    .<span class="hljs-title function_">fetch_one</span>(&#x26;pool)
    .<span class="hljs-property">await</span>;

    match insert_result {
        <span class="hljs-title class_">Ok</span>(location) => {
            info!(<span class="hljs-string">"✓Inserted: {:?}"</span>, location);
        }
        <span class="hljs-title class_">Err</span>(e) => {
            error!(<span class="hljs-string">"Error Insert: {}"</span>, e.<span class="hljs-title function_">to_string</span>())
        }
    }
    <span class="hljs-keyword">let</span> insert_result = <span class="hljs-attr">sqlx</span>::query_as!(
        <span class="hljs-title class_">Locations</span>,
        <span class="hljs-string">"INSERT INTO locations (id,name) VALUES (2, 'Location B') RETURNING *"</span>
    )
    .<span class="hljs-title function_">fetch_one</span>(&#x26;pool)
    .<span class="hljs-property">await</span>;

    match insert_result {
        <span class="hljs-title class_">Ok</span>(location) => {
            info!(<span class="hljs-string">"✓Inserted: {:?}"</span>, location);
        }
        <span class="hljs-title class_">Err</span>(e) => {
            error!(<span class="hljs-string">"Error Insert: {}"</span>, e.<span class="hljs-title function_">to_string</span>())
        }
    }

    tx.<span class="hljs-title function_">commit</span>().<span class="hljs-property">await</span>.<span class="hljs-title function_">expect</span>(<span class="hljs-string">"Unable to commit the transaction"</span>);
}

<span class="hljs-keyword">async</span> fn <span class="hljs-title function_">insert_into_sessions</span>(<span class="hljs-params">pool: Pool&#x3C;Postgres></span>) {
    <span class="hljs-keyword">let</span> tx = pool.<span class="hljs-title function_">begin</span>().<span class="hljs-property">await</span>.<span class="hljs-title function_">expect</span>(<span class="hljs-string">"Unable to begin transaction"</span>);

    <span class="hljs-keyword">let</span> insert_result = <span class="hljs-attr">sqlx</span>::query_as!(
        <span class="hljs-title class_">Sessions</span>,
        <span class="hljs-string">"INSERT INTO sessions (id,location_id, watts, vin) VALUES (1, 1, 420, '2FMZA52286BA02033') RETURNING *"</span>
    )
    .<span class="hljs-title function_">fetch_one</span>(&#x26;pool)
    .<span class="hljs-property">await</span>;

    match insert_result {
        <span class="hljs-title class_">Ok</span>(session) => {
            info!(<span class="hljs-string">"✓Inserted: {:?}"</span>, session);
        }
        <span class="hljs-title class_">Err</span>(e) => {
            error!(<span class="hljs-string">"Error Insert: {}"</span>, e.<span class="hljs-title function_">to_string</span>())
        }
    }
    <span class="hljs-keyword">let</span> insert_result = <span class="hljs-attr">sqlx</span>::query_as!(
        <span class="hljs-title class_">Sessions</span>,
        <span class="hljs-string">"INSERT INTO sessions (id,location_id, watts, vin) VALUES (2, 2, 393, '1GMYA52286BA04055') RETURNING *"</span>
)
    .<span class="hljs-title function_">fetch_one</span>(&#x26;pool)
    .<span class="hljs-property">await</span>;

    match insert_result {
        <span class="hljs-title class_">Ok</span>(session) => {
            info!(<span class="hljs-string">"✓Inserted: {:?}"</span>, session);
        }
        <span class="hljs-title class_">Err</span>(e) => {
            error!(<span class="hljs-string">"Error Insert: {}"</span>, e.<span class="hljs-title function_">to_string</span>())
        }
    }

    tx.<span class="hljs-title function_">commit</span>().<span class="hljs-property">await</span>.<span class="hljs-title function_">expect</span>(<span class="hljs-string">"Unable to commit the transaction"</span>);
}

<span class="hljs-keyword">async</span> fn <span class="hljs-title function_">update_sessions</span>(<span class="hljs-params">pool: Pool&#x3C;Postgres></span>) {
    <span class="hljs-keyword">let</span> tx = pool.<span class="hljs-title function_">begin</span>().<span class="hljs-property">await</span>.<span class="hljs-title function_">expect</span>(<span class="hljs-string">"Unable to begin transaction"</span>);

    <span class="hljs-keyword">let</span> update_result = <span class="hljs-attr">sqlx</span>::query_as!(
        <span class="hljs-title class_">Sessions</span>,
        <span class="hljs-string">"UPDATE sessions SET watts = 415 WHERE id = $1 RETURNING *"</span>,
        1i64,
    )
    .<span class="hljs-title function_">fetch_one</span>(&#x26;pool)
    .<span class="hljs-property">await</span>;

    match update_result {
        <span class="hljs-title class_">Ok</span>(session) => {
            info!(<span class="hljs-string">"✓Update: {:?}"</span>, session);
        }
        <span class="hljs-title class_">Err</span>(e) => {
            error!(<span class="hljs-string">"Error Update: {}"</span>, e.<span class="hljs-title function_">to_string</span>())
        }
    }

    tx.<span class="hljs-title function_">commit</span>().<span class="hljs-property">await</span>.<span class="hljs-title function_">expect</span>(<span class="hljs-string">"Unable to commit the transaction"</span>);
}

<span class="hljs-keyword">async</span> fn <span class="hljs-title function_">clean_db</span>(<span class="hljs-params">pool: Pool&#x3C;Postgres></span>) {
    <span class="hljs-keyword">let</span> rows_deleted = <span class="hljs-attr">sqlx</span>::query!(<span class="hljs-string">"DELETE from sessions"</span>)
        .<span class="hljs-title function_">execute</span>(&#x26;pool)
        .<span class="hljs-property">await</span>
        .<span class="hljs-title function_">unwrap</span>()
        .<span class="hljs-title function_">rows_affected</span>();

    info!(<span class="hljs-string">"✕Deleted {} rows from sessions table"</span>, rows_deleted);

    <span class="hljs-keyword">let</span> rows_deleted = <span class="hljs-attr">sqlx</span>::query!(<span class="hljs-string">"DELETE from locations"</span>)
        .<span class="hljs-title function_">execute</span>(&#x26;pool)
        .<span class="hljs-property">await</span>
        .<span class="hljs-title function_">unwrap</span>()
        .<span class="hljs-title function_">rows_affected</span>();
    info!(<span class="hljs-string">"✕Deleted {} rows from locations table"</span>, rows_deleted);
}

<span class="hljs-keyword">async</span> fn <span class="hljs-title function_">query_locations</span>(<span class="hljs-params">pool: Pool&#x3C;Postgres></span>) {
    <span class="hljs-keyword">let</span> query_result = <span class="hljs-attr">sqlx</span>::query_as!(<span class="hljs-title class_">Locations</span>, <span class="hljs-string">"SELECT * FROM Locations"</span>)
        .<span class="hljs-title function_">fetch_all</span>(&#x26;pool)
        .<span class="hljs-property">await</span>;
    <span class="hljs-keyword">if</span> query_result.<span class="hljs-title function_">is_err</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">let</span> message = <span class="hljs-string">"Something bad happened while fetching all locations"</span>;
        error!(<span class="hljs-string">"{}"</span>, message);
    } <span class="hljs-keyword">else</span> {
        info!(<span class="hljs-string">"😎Query Result For Locations {:?}"</span>, query_result);
    }
}

<span class="hljs-keyword">async</span> fn <span class="hljs-title function_">query_sessions</span>(<span class="hljs-params">pool: Pool&#x3C;Postgres></span>) {
    <span class="hljs-keyword">let</span> query_result = <span class="hljs-attr">sqlx</span>::query_as!(<span class="hljs-title class_">Sessions</span>, <span class="hljs-string">"SELECT * FROM Sessions"</span>)
        .<span class="hljs-title function_">fetch_all</span>(&#x26;pool)
        .<span class="hljs-property">await</span>;
    <span class="hljs-keyword">if</span> query_result.<span class="hljs-title function_">is_err</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">let</span> message = <span class="hljs-string">"Something bad happened while fetching all sessions"</span>;
        error!(<span class="hljs-string">"{}"</span>, message);
    } <span class="hljs-keyword">else</span> {
        info!(<span class="hljs-string">"😎Query Result for Sessions {:?}"</span>, query_result);
    }
}

#[<span class="hljs-attr">tokio</span>::main]
<span class="hljs-keyword">async</span> fn <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">if</span> <span class="hljs-attr">std</span>::<span class="hljs-attr">env</span>::<span class="hljs-title function_">var_os</span>(<span class="hljs-string">"RUST_LOG"</span>).<span class="hljs-title function_">is_none</span>(<span class="hljs-params"></span>) {
        <span class="hljs-attr">std</span>::<span class="hljs-attr">env</span>::<span class="hljs-title function_">set_var</span>(<span class="hljs-string">"RUST_LOG"</span>, <span class="hljs-string">"info"</span>);
    }
    <span class="hljs-title function_">dotenv</span>().<span class="hljs-title function_">ok</span>();
    <span class="hljs-attr">env_logger</span>::<span class="hljs-title function_">init</span>();

    <span class="hljs-keyword">let</span> database_url = <span class="hljs-attr">std</span>::<span class="hljs-attr">env</span>::<span class="hljs-title function_">var</span>(<span class="hljs-string">"DATABASE_URL"</span>).<span class="hljs-title function_">expect</span>(<span class="hljs-string">"DATABASE_URL must be set"</span>);
    <span class="hljs-keyword">let</span> pool = match <span class="hljs-title class_">PgPoolOptions</span>::<span class="hljs-title function_">new</span>()
        .<span class="hljs-title function_">max_connections</span>(<span class="hljs-number">10</span>)
        .<span class="hljs-title function_">connect</span>(&#x26;database_url)
        .<span class="hljs-property">await</span>
    {
        <span class="hljs-title class_">Ok</span>(pool) => {
            info!(<span class="hljs-string">"✅Connection to the database is successful!"</span>);
            pool
        }
        <span class="hljs-title class_">Err</span>(err) => {
            error!(<span class="hljs-string">"🔥 Failed to connect to the database: {:?}"</span>, err);
            <span class="hljs-attr">std</span>::<span class="hljs-attr">process</span>::<span class="hljs-title function_">exit</span>(<span class="hljs-number">1</span>);
        }
    };
    <span class="hljs-title function_">clean_db</span>(pool.<span class="hljs-title function_">clone</span>()).<span class="hljs-property">await</span>;

    <span class="hljs-title function_">insert_into_locations</span>(pool.<span class="hljs-title function_">clone</span>()).<span class="hljs-property">await</span>;
    <span class="hljs-title function_">query_locations</span>(pool.<span class="hljs-title function_">clone</span>()).<span class="hljs-property">await</span>;

    <span class="hljs-title function_">insert_into_sessions</span>(pool.<span class="hljs-title function_">clone</span>()).<span class="hljs-property">await</span>;
    <span class="hljs-title function_">query_sessions</span>(pool.<span class="hljs-title function_">clone</span>()).<span class="hljs-property">await</span>;

    <span class="hljs-title function_">update_sessions</span>(pool.<span class="hljs-title function_">clone</span>()).<span class="hljs-property">await</span>;
    <span class="hljs-title function_">query_sessions</span>(pool.<span class="hljs-title function_">clone</span>()).<span class="hljs-property">await</span>;
}
</code></pre>
<p>위 애플리케이션을 실행한 결과는 다음과 같습니다.</p>
<img src="/assets/img/2024-05-23-LearningRustPart11BuildersandDatabaseInteraction_5.png">
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>위와 같이 데이터베이스 상호작용 토론을 마쳤습니다. sqlx를 사용하여 데이터베이스 작업을 수행하는 방법에 대해 좋은 개요를 제공했을 겁니다.</p>
<h1>요약</h1>
<p>저희 러스트 학습 시리즈의 이 부분을 즐기셨기를 바랍니다. 시리즈 이번 섹션에서는 먼저 러스트에서 객체 생성에 대한 매우 유용한 패턴인 빌더 패턴을 살펴보았습니다. 이는 다른 언어에서 익숙할 수 있지만, 러스트에서 어떻게 구현하는지 살펴보았습니다.</p>
<p>다음으로, 우리는 Rust를 사용하여 데이터베이스인 특히 Postgres와 상호작용하는 방법을 검토했습니다. 우리는 마이그레이션을 실행하고 데이터베이스에 연결하는 방법을 보았으며, 그 후 DB에 대해 여러 가지 CRUD 작업을 수행하는 방법을 살펴보았습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>러스트 학습 여정에 함께해줘서 고마워요.</p>
<p>좋은 여행 되세요!</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"러스트 배우기 11부  빌더와 데이터베이스 상호작용","description":"","date":"2024-05-23 14:11","slug":"2024-05-23-LearningRustPart11BuildersandDatabaseInteraction","content":"\n다음 시리즈로 넘어가보겠습니다; 이 부분에서는 데이터 구조에 빌더 패턴을 구현하는 방법을 살펴보겠습니다. 그런 다음 sqlx와 Postgres를 사용한 데이터베이스 상호작용으로 넘어가겠습니다.\n\n![이미지](/assets/img/2024-05-23-LearningRustPart11BuildersandDatabaseInteraction_0.png)\n\n# Rust 시리즈\n\n부분 1 — 기본 개념\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nPart 2 — 메모리\n\nPart 3 — 흐름 제어와 함수\n\nPart 4 — 옵션/결과 및 컬렉션\n\nPart 5 — 트레이트, 제네릭 및 클로저\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n제 6부 — 매크로, 반복자 및 파일 처리\n\n제 7부 — 스레드 공유 상태 및 채널\n\n제 8부 — Cargo, 크레이트, 모듈 및 라이브러리\n\n제 9부 — 명령행 인수, 워크스페이스 및 테스팅\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n제 10부 — 상자 포인터 및 웹 앱\n\n제 11부 — 빌더와 데이터베이스 상호작용 (이 기사)\n\n# 소개\n\n이것은 러스트 학습 시리즈의 열한 번째 섹션입니다. 이번에는 러스트에서 빌더 패턴을 다룰 것입니다. 이 공통된 패턴은 구조체를 안전하고 투명하게 초기화하는 좋은 방법입니다. 다음으로, 우리는 포스트그레스와 SQLX 프레임워크를 사용하여 데이터베이스에서 CRUD 작업을 수행하는 방법을 살펴볼 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 준비물\n\n이 글의 데이터베이스 부분을 위한 유일한 준비물은 Rust와 Cargo가 설치되어 있고 시스템에 Docker가 설치되어 있는 것입니다. 만약 Docker를 가지고 있지 않지만 로컬 Postgres DB가 이미 설치되어 있거나 다른 서버의 DB에 액세스할 수 있다면 Docker Postgres 설정을 건너뛰고 DB에 연결하기 위한 연결 속성만 수정하면 됩니다.\n\n# 빌더 패턴\n\n빌더 패턴은 복잡한 객체의 구성을 해당 표현에서 분리하는 디자인 패턴입니다. 이 패턴을 사용하면 유효성 검사를 수행하고 기본값으로 대체하며 값을 부분적으로 할당한 후에 항목을 생성할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nRust로 그 구현하는 방법을 살펴볼 거예요. 이것이 우리의 코드입니다.\n\n```js\n#[derive(Debug)]\nstruct ChargingSession {\n    id: String,\n    watts: u32,\n    vin: String,\n}\n\nstruct ChargingSessionBuilder {\n    id: String,\n    watts: Option\u003cu32\u003e,\n    vin: Option\u003cString\u003e,\n}\n\nimpl ChargingSessionBuilder {\n    fn new(id: \u0026str) -\u003e ChargingSessionBuilder {\n        ChargingSessionBuilder {\n            id: id.to_string(),\n            watts: None,\n            vin: None,\n        }\n    }\n\n    fn watts(mut self, watts: u32) -\u003e ChargingSessionBuilder {\n        self.watts = Some(watts);\n        self\n    }\n\n    fn vin(mut self, vin: \u0026str) -\u003e ChargingSessionBuilder {\n        self.vin = Some(vin.to_string());\n        self\n    }\n\n    fn build(self) -\u003e ChargingSession {\n        ChargingSession {\n            id: self.id,\n            watts: self.watts.unwrap_or_else(|| 0),\n            vin: self.vin.unwrap_or_else(|| \"Unknown\".to_string()),\n        }\n    }\n}\n\nfn main() {\n    // 이것은 ChargingSession을 생성하는 표준적인 방법입니다.\n    let cs_old_way = ChargingSession {\n        id: String::from(\"11111\"),\n        watts: 420,\n        vin: String::from(\"4Y1SL65848Z411439\"),\n    };\n    println!(\"Regular way to create struct: {:?}\", cs_old_way);\n\n    // 빌더를 사용해서 생성하는 방법입니다.\n    let cs = ChargingSessionBuilder::new(\"11111\")\n        .watts(420)\n        .vin(\"4Y1SL65848Z411439\")\n        .build();\n    println!(\"Builder pattern to create struct: {:?}\", cs);\n\n    // ID만 제공하여 생성하는 예시입니다.\n    let cs_lean = ChargingSessionBuilder::new(\"11111\")\n    .build();\n     println!(\"Builder pattern to create struct (default values): {:?}\", cs_lean);\n}\n```\n\n이걸 한 번에 이해하기에 많지만, 단계적으로 진행해 봅시다.\n\n먼저, 충전 세션 정보를 저장하는 구조체를 정의했습니다. 이 시리즈의 이전 예제에서 하나의 필드인 세션용 차량 ID 번호인 vin을 추가했어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그러면 데이터 구조체와 동일한 필드를 가진 빌더를 위한 구조체를 정의합니다.\n\n빌더는 impl 블록에서 구현되며, id 및 각 추가 필드를 설정하는 함수를 정의하는 새 함수가 있습니다. 그러나 몇 가지 중요한 사항이 있습니다.\n\n- 각 함수는 ChargingSessionBuilder 유형을 반환합니다. 기본적으로 self입니다.\n- 추가 속성 필드에는 mut self를 첫 번째 매개변수로 사용하는 메서드가 있습니다. 이는 이러한 함수 호출의 체이닝을 허용하는 데 중요합니다. 또한 여기에 유효성 검사 논리를 코딩할 수 있습니다.\n- build 함수가 모두 통합되는 곳입니다. 존재하는 값들을 할당하고 나면 기본값을 결정하고 대상 구조체를 생성할 수 있습니다.\n\n이를 통해 빌더 패턴의 우아함과 Rust 내에서의 구현 방법을 살펴보았습니다. 이것이 앱이나 라이브러리에 코드를 구현하는 훌륭한 방법임을 알 수 있기를 바랍니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음 섹션인 데이터베이스로 넘어가 봅시다.\n\n# 데이터베이스 — sqlx\n\n이 섹션에서는 Rust 프로그램에서 sqlx를 사용하여 데이터베이스 작업을 살펴볼 것입니다. 먼저 일부 설정이 필요합니다.\n\n## 설정\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n새 프로젝트를 시작해봅시다. db_app이라고 이름 짓고, cargo new db_app으로 생성할 수 있어요. 기본 디렉토리에 몇 개의 파일을 생성할 거에요. 첫 번째 파일은 docker-compose.yml이라고 하며 다음 내용이 있어야 합니다. Postgres와 Pgadmin이 노출되는 임의의 포트를 선택했으며, 컴퓨터에 설치된 다른 앱들과 충돌하지 않도록 했어요.\n\n```js\nversion: '3'\nservices:\n  postgres:\n    image: postgres:latest\n    container_name: postgres\n    ports:\n      - '6500:5432'\n    volumes:\n      - postgresDB:/data/postgres\n    env_file:\n      - ./.env\n  pgAdmin:\n    image: dpage/pgadmin4\n    container_name: pgAdmin\n    env_file:\n      - ./.env\n    ports:\n      - \"5050:80\"\nvolumes:\n  postgresDB:\n```\n\n.env이라는 파일이 하나 더 필요하며, 다음 내용이 있어야 해요. 이 파일은 docker-compose 파일과 나중에 Rust 애플리케이션에서 모두 사용할 거에요.\n\n```js\nPOSTGRES_HOST=127.0.0.1\nPOSTGRES_PORT=6500\nPOSTGRES_USER=admin\nPOSTGRES_PASSWORD=password123\nPOSTGRES_DB=charging_session\n\nDATABASE_URL=postgresql://admin:password123@localhost:6500/charging_session?currentSchema=public\n\nPGADMIN_DEFAULT_EMAIL=admin@admin.com\nPGADMIN_DEFAULT_PASSWORD=password123\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위의 내용과 함께 데이터베이스 사용자, 비밀번호, 그리고 Pgadmin에 대한 연결 정보를 제공해 드렸습니다.\n\n이 두 가지 항목을 만들고 위의 내용을 사용하여 Docker Compose를 사용하여 로컬 DB 인스턴스를 시작할 수 있습니다. 처음에는 항상 전경에서 시작하는 것을 좋아합니다. 이미지 다운로드 및 기타 작업을 하기 때문에 여러분의 컴퓨터 및 네트워크 속도에 따라 시간이 소요될 수 있습니다. docker-compose.yml 및 .env 파일이 있는 디렉토리와 동일한 위치에서 다음을 실행하십시오.\n\n```js\ndocker-compose up\n```\n\n시작된 모든 것을 확인한 후에는 언제든지 -d 스위치를 사용하여 데몬 모드로 시작할 수 있습니다. 완료되면 두 컨테이너가 시작되었는지 확인해 봅시다. 다음과 같이 명령을 실행합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\ndocker ps\n```\n\n비슷한 결과가 표시됩니다.\n\n\u003cimg src=\"/assets/img/2024-05-23-LearningRustPart11BuildersandDatabaseInteraction_1.png\" /\u003e\n\n만약 두 개의 컨테이너가 표시되지 않는다면, docker-compose를 실행한 터미널에서 에러를 확인해보세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n한 번 이들이 실행되면 DB에 연결해 봅시다. Pgadmin을 포트 5050에서 실행하도록 구성했으니 브라우저에서 http://localhost:5050을 입력하면 pgadmin의 로그인 화면이 표시됩니다. .env 파일에 구성된 자격 증명(관리자@관리자.com/비밀번호123)을 사용하여 pgadmin에 로그인할 수 있습니다. 그런데 아직 데이터베이스에 연결되지 않았습니다. 이를 위해 다음을 실행해야 합니다.\n\n```js\ndocker inspect postgres\n```\n\n출력을 확인하여 \"NetworkSettings\" 섹션으로 이동하고 \"IPAddress\" 속성의 값을 복사합니다. 이 값은 DB에 연결하는 데 사용할 호스트(IP)입니다. 제 컴퓨터에서 이 값은 172.23.0.1 이었습니다.\n\n로그인한 후 \"새 서버 추가\" 버튼을 클릭하고, \"호스트 이름/주소\"로 이전에 복사한 IP 주소를 포함한 필수 자격 증명을 제공하고 \"저장\" 버튼을 클릭하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n서버에 로그인하면 데이터베이스 charging_session을 볼 수 있습니다.\n\n![이미지](/assets/img/2024-05-23-LearningRustPart11BuildersandDatabaseInteraction_2.png)\n\n잘 했어요. 데이터베이스를 사용할 준비가 되었고 Pgadmin에서 관리할 수 있습니다.\n\n이제 Rust 앱의 종속성을 구성해 봅시다. 처음에는 모두 필요하지 않지만 결국 필요하게 될 것이므로 지금 추가해 두는 것이 좋습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nCargo.toml 파일의 종속성 부분을 다음과 같이 수정하세요.\n\n```toml\n[dependencies]\nchrono = { version = \"0.4.31\", features = [\"serde\"] }\ndotenv = \"0.15.0\"\nenv_logger = \"0.10.1\"\nlog = \"0.4.20\"\nserde = { version = \"1.0.193\", features = [\"derive\"] }\nserde_json = \"1.0.108\"\nsqlx = { version = \"0.7.3\", features = [\"runtime-tokio-native-tls\", \"postgres\", \"uuid\", \"chrono\"] }\ntokio = { version = \"1.35.0\", features = [\"macros\", \"rt-multi-thread\"]}\nuuid = { version = \"1.6.1\", features = [\"serde\", \"v4\"] }\n```\n\n다양한 종속성에 대해 활성화된 기능을 검토하는 데도 시간을 할애하는 것이 좋습니다.\n\n다음으로, 필요한 테이블을 만들기 위해 sqlx-cli 마이그레이션 기능을 사용할 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우선 명령 줄에서 다음을 실행하여 CLI를 설치해야 합니다.\n\n```js\ncargo install sqlx-cli --no-default-features --features rustls,postgres\n```\n\n그런 다음 마이그레이션 파일을 초기화해야 합니다. 다음과 같이 실행합니다.\n\n```js\nsqlx migrate add initial-tables\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 명령어는 우리가 마이그레이션 스크립트를 작성하기 위해 새 파일 migrations/`timestamp`\\_initial-tables.sql을 생성합니다.\n\n![이미지](/assets/img/2024-05-23-LearningRustPart11BuildersandDatabaseInteraction_3.png)\n\n이 파일을 열고 아래 SQL 문을 추가하여 테이블을 생성하세요.\n\ncreate table locations (\nid bigserial primary key,\nname varchar(255) unique not null\n);\n\ncreate table sessions (\nid bigserial primary key,\nlocation_id bigint not null,\nwatts bigint not null,\nvin varchar(255) not null,\nconstraint fk_location foreign key (location_id) references locations(id) on delete cascade\n);\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위 예제에서 사용할 두 개의 테이블 정의입니다. 이 시리즈의 충전 세션에 대한 표준 예제를 확장하여, 충전 장치의 위치를 저장할 locations 테이블을 추가했습니다.\n\n이제 다음을 실행하여 테이블을 생성하세요.\n\n```js\nsqlx migrate run\n```\n\n그러면 즉시 20231212235431/migrate initial-tables (타임스탬프 부분은 달라질 수 있음)과 같은 메시지가 표시됩니다. 이제 Pgadmin에 가서 테이블을 확인할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-05-23-LearningRustPart11BuildersandDatabaseInteraction_4.png\" /\u003e\n\n위에서 보듯이 두 개의 테이블이 생성되었고, 문서 목적을 위해 Pgadmin 내에 ERD 다이어그램도 생성했습니다. 이제 초기 설정과 프로젝트 구성을 완료했습니다.\n\n# 데이터베이스 함수\n\n이 섹션에서는 데이터베이스 상호 작용의 다양한 유형과 Rust 구현을 살펴볼 것입니다. 이는 데이터베이스에 연결하는 것으로 시작됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nDB에 연결하기\n\n데이터베이스에 연결하는 방법은 PgPoolOptions connect 함수를 통해 연결을 생성하는 것입니다. 우리의 .env 파일에서 데이터베이스 연결 문자열을 읽고 로깅을 구성하며 성공 또는 오류를 기록하는 코드 전체는 아래와 같습니다.\n\n```js\nuse sqlx::{postgres::PgPoolOptions, Pool, Postgres};\nuse dotenv::dotenv;\nuse log::{info, error};\n\n#[tokio::main]\nasync fn main() {\n    if std::env::var_os(\"RUST_LOG\").is_none() {\n        std::env::set_var(\"RUST_LOG\", \"info\");\n    }\n    dotenv().ok();\n    env_logger::init();\n\n    let database_url = std::env::var(\"DATABASE_URL\").expect(\"DATABASE_URL must be set\");\n    let pool = match PgPoolOptions::new()\n        .max_connections(10)\n        .connect(\u0026database_url)\n        .await\n    {\n        Ok(pool) =\u003e {\n            info!(\"✅ 데이터베이스에 연결되었습니다!\");\n            pool\n        }\n        Err(err) =\u003e {\n            error!(\"🔥 데이터베이스 연결에 실패했습니다: {:?}\", err);\n            std::process::exit(1);\n        }\n    };\n}\n```\n\n시작 부분의 #[tokio::main] 매크로를 주목해주세요. 이는 async fn main()을 동기 fn main()로 변환하여 런타임 인스턴스를 초기화하고 async main 함수를 실행하게 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위 코드를 실행하면 출력 로깅에서 다음 메시지가 표시됩니다.\n\n[2023-12-13T00:16:42Z INFO db_app] ✅ 데이터베이스에 연결되었습니다!\n\n우리는 데이터베이스에 연결할 수 있습니다. .env 파일에서 구성한 모든 연결 정보를 기억해 주세요. 이 정보는 docker-compose, sqlx-cli, 그리고 우리의 어플리케이션에서 공유되었습니다.\n\n## Inserts\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 연결 풀이 준비되었으니, 우리가 살펴볼 첫 번째 데이터베이스 로직은 삽입입니다. sqlx를 사용하여 삽입하는 방법은 다음과 같습니다.\n\n```rust\nlet insert_result = sqlx::query_as!(\n    Locations,\n    \"INSERT INTO locations (id,name) VALUES (1, 'Location A') RETURNING *\"\n)\n.fetch_one(\u0026pool)\n.await;\n\nmatch insert_result {\n    Ok(location) =\u003e {\n        info!(\"✓Inserted: {:?}\", location);\n    }\n    Err(e) =\u003e {\n        error!(\"Error Insert: {}\", e.to_string())\n    }\n}\n```\n\n이 코드는 하나의 레코드를 삽입할 것입니다. 물론 매개변수를 사용할 수도 있으며, 이는 업데이트를 살펴볼 때 살펴볼 것입니다.\n\n## 질의하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음으로, 데이터베이스를 조회하는 방법을 살펴보겠습니다.\n\n```js\n    let query_result = sqlx::query_as!(Locations, \"SELECT * FROM Locations\")\n        .fetch_all(\u0026pool)\n        .await;\n    if query_result.is_err() {\n        let message = \"모든 위치를 가져오는 동안 문제가 발생했습니다.\";\n        error!(\"{}{}\", message, query_result.err().unwrap());\n    } else {\n        info!(\"😎 위치에 대한 쿼리 결과 {:?}\", query_result.unwrap());\n    }\n```\n\n이것은 성공적으로 작동했다면 unwrap을 통해 결과에 접근할 수 있는 결과를 반환합니다. 쿼리 내의 이슈가 발생했다면 해당 에러에 접근할 수도 있습니다.\n\n## 업데이트\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음 작업은 데이터베이스를 업데이트하는 것입니다. 이는 이전에 삽입한 것과 비슷할 것입니다.\n\n```js\n    let update_result = sqlx::query_as!(\n        Sessions,\n        \"UPDATE sessions SET watts = 415 WHERE id = $1 RETURNING *\",\n        1i64,\n    )\n    .fetch_one(\u0026pool)\n    .await;\n\n    match update_result {\n        Ok(session) =\u003e {\n            info!(\"✓Update: {:?}\", session);\n        }\n        Err(e) =\u003e {\n            error!(\"Error Update: {}\", e.to_string())\n        }\n    }\n```\n\n이 예제에서 주목할 점은 $1이라는 매개변수 자리 표시자를 사용하는 준비된 문(statement)를 사용하고 있다는 것입니다. 그런 다음 SQL 문자열 뒤에 매개변수를 전달합니다.\n\n## Deletes\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n마지막으로, 데이터베이스에서 레코드를 삭제하는 CRUD 작업을 완료합니다. 우리의 목적은 데이터베이스를 정리하는 데 사용할 것이며, 이렇게 하면 언제든지 응용 프로그램을 실행할 수 있습니다.\n\n```js\nlet rows_deleted = sqlx::query!(\"DELETE from sessions\")\n    .execute(\u0026pool)\n    .await\n    .unwrap()\n    .rows_affected();\n\ninfo!(\"✕ 세션 테이블에서 {}개의 행 삭제됨\", rows_deleted);\n```\n\n여기서는 연산에서처럼 sqlx::query 대신 sqlx::query_as를 사용합니다. 또한 언랩 이후 .rows_affected를 추가하여 삭제된 행 수를 얻습니다.\n\n## 트랜잭션\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```rust\n   let tx = pool.begin().await.expect(\"트랜잭션을 시작할 수 없습니다\");\n\n   // 데이터베이스 작업 수행(데이터 삽입 또는 변경)\n\n   tx.commit().await.expect(\"트랜잭션을 커밋할 수 없습니다\");\n```\n\n커밋을 호출하지 않으면 트랜잭션이 범위를 벗어나면 자동으로 롤백됩니다.\n\n## 완전한 응용 프로그램\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위의 코드는 우리가 이전에 논의한 모든 다양한 기능이 하나의 애플리케이션에 모두 포함된 완전한 애플리케이션입니다.\n\n```js\nuse dotenv::dotenv;\nuse log::{error, info};\nuse sqlx::{postgres::PgPoolOptions, Pool, Postgres};\n\n#[derive(Debug)]\nstruct Locations {\n    id: i64,\n    name: String,\n}\n\n#[derive(Debug)]\nstruct Sessions {\n    id: i64,\n    location_id: i64,\n    watts: i64,\n    vin: String,\n}\nasync fn insert_into_locations(pool: Pool\u003cPostgres\u003e) {\n    let tx = pool.begin().await.expect(\"Unable to begin transaction\");\n\n    let insert_result = sqlx::query_as!(\n        Locations,\n        \"INSERT INTO locations (id,name) VALUES (1, 'Location A') RETURNING *\"\n    )\n    .fetch_one(\u0026pool)\n    .await;\n\n    match insert_result {\n        Ok(location) =\u003e {\n            info!(\"✓Inserted: {:?}\", location);\n        }\n        Err(e) =\u003e {\n            error!(\"Error Insert: {}\", e.to_string())\n        }\n    }\n    let insert_result = sqlx::query_as!(\n        Locations,\n        \"INSERT INTO locations (id,name) VALUES (2, 'Location B') RETURNING *\"\n    )\n    .fetch_one(\u0026pool)\n    .await;\n\n    match insert_result {\n        Ok(location) =\u003e {\n            info!(\"✓Inserted: {:?}\", location);\n        }\n        Err(e) =\u003e {\n            error!(\"Error Insert: {}\", e.to_string())\n        }\n    }\n\n    tx.commit().await.expect(\"Unable to commit the transaction\");\n}\n\nasync fn insert_into_sessions(pool: Pool\u003cPostgres\u003e) {\n    let tx = pool.begin().await.expect(\"Unable to begin transaction\");\n\n    let insert_result = sqlx::query_as!(\n        Sessions,\n        \"INSERT INTO sessions (id,location_id, watts, vin) VALUES (1, 1, 420, '2FMZA52286BA02033') RETURNING *\"\n    )\n    .fetch_one(\u0026pool)\n    .await;\n\n    match insert_result {\n        Ok(session) =\u003e {\n            info!(\"✓Inserted: {:?}\", session);\n        }\n        Err(e) =\u003e {\n            error!(\"Error Insert: {}\", e.to_string())\n        }\n    }\n    let insert_result = sqlx::query_as!(\n        Sessions,\n        \"INSERT INTO sessions (id,location_id, watts, vin) VALUES (2, 2, 393, '1GMYA52286BA04055') RETURNING *\"\n)\n    .fetch_one(\u0026pool)\n    .await;\n\n    match insert_result {\n        Ok(session) =\u003e {\n            info!(\"✓Inserted: {:?}\", session);\n        }\n        Err(e) =\u003e {\n            error!(\"Error Insert: {}\", e.to_string())\n        }\n    }\n\n    tx.commit().await.expect(\"Unable to commit the transaction\");\n}\n\nasync fn update_sessions(pool: Pool\u003cPostgres\u003e) {\n    let tx = pool.begin().await.expect(\"Unable to begin transaction\");\n\n    let update_result = sqlx::query_as!(\n        Sessions,\n        \"UPDATE sessions SET watts = 415 WHERE id = $1 RETURNING *\",\n        1i64,\n    )\n    .fetch_one(\u0026pool)\n    .await;\n\n    match update_result {\n        Ok(session) =\u003e {\n            info!(\"✓Update: {:?}\", session);\n        }\n        Err(e) =\u003e {\n            error!(\"Error Update: {}\", e.to_string())\n        }\n    }\n\n    tx.commit().await.expect(\"Unable to commit the transaction\");\n}\n\nasync fn clean_db(pool: Pool\u003cPostgres\u003e) {\n    let rows_deleted = sqlx::query!(\"DELETE from sessions\")\n        .execute(\u0026pool)\n        .await\n        .unwrap()\n        .rows_affected();\n\n    info!(\"✕Deleted {} rows from sessions table\", rows_deleted);\n\n    let rows_deleted = sqlx::query!(\"DELETE from locations\")\n        .execute(\u0026pool)\n        .await\n        .unwrap()\n        .rows_affected();\n    info!(\"✕Deleted {} rows from locations table\", rows_deleted);\n}\n\nasync fn query_locations(pool: Pool\u003cPostgres\u003e) {\n    let query_result = sqlx::query_as!(Locations, \"SELECT * FROM Locations\")\n        .fetch_all(\u0026pool)\n        .await;\n    if query_result.is_err() {\n        let message = \"Something bad happened while fetching all locations\";\n        error!(\"{}\", message);\n    } else {\n        info!(\"😎Query Result For Locations {:?}\", query_result);\n    }\n}\n\nasync fn query_sessions(pool: Pool\u003cPostgres\u003e) {\n    let query_result = sqlx::query_as!(Sessions, \"SELECT * FROM Sessions\")\n        .fetch_all(\u0026pool)\n        .await;\n    if query_result.is_err() {\n        let message = \"Something bad happened while fetching all sessions\";\n        error!(\"{}\", message);\n    } else {\n        info!(\"😎Query Result for Sessions {:?}\", query_result);\n    }\n}\n\n#[tokio::main]\nasync fn main() {\n    if std::env::var_os(\"RUST_LOG\").is_none() {\n        std::env::set_var(\"RUST_LOG\", \"info\");\n    }\n    dotenv().ok();\n    env_logger::init();\n\n    let database_url = std::env::var(\"DATABASE_URL\").expect(\"DATABASE_URL must be set\");\n    let pool = match PgPoolOptions::new()\n        .max_connections(10)\n        .connect(\u0026database_url)\n        .await\n    {\n        Ok(pool) =\u003e {\n            info!(\"✅Connection to the database is successful!\");\n            pool\n        }\n        Err(err) =\u003e {\n            error!(\"🔥 Failed to connect to the database: {:?}\", err);\n            std::process::exit(1);\n        }\n    };\n    clean_db(pool.clone()).await;\n\n    insert_into_locations(pool.clone()).await;\n    query_locations(pool.clone()).await;\n\n    insert_into_sessions(pool.clone()).await;\n    query_sessions(pool.clone()).await;\n\n    update_sessions(pool.clone()).await;\n    query_sessions(pool.clone()).await;\n}\n```\n\n위 애플리케이션을 실행한 결과는 다음과 같습니다.\n\n\u003cimg src=\"/assets/img/2024-05-23-LearningRustPart11BuildersandDatabaseInteraction_5.png\" /\u003e\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위와 같이 데이터베이스 상호작용 토론을 마쳤습니다. sqlx를 사용하여 데이터베이스 작업을 수행하는 방법에 대해 좋은 개요를 제공했을 겁니다.\n\n# 요약\n\n저희 러스트 학습 시리즈의 이 부분을 즐기셨기를 바랍니다. 시리즈 이번 섹션에서는 먼저 러스트에서 객체 생성에 대한 매우 유용한 패턴인 빌더 패턴을 살펴보았습니다. 이는 다른 언어에서 익숙할 수 있지만, 러스트에서 어떻게 구현하는지 살펴보았습니다.\n\n다음으로, 우리는 Rust를 사용하여 데이터베이스인 특히 Postgres와 상호작용하는 방법을 검토했습니다. 우리는 마이그레이션을 실행하고 데이터베이스에 연결하는 방법을 보았으며, 그 후 DB에 대해 여러 가지 CRUD 작업을 수행하는 방법을 살펴보았습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n러스트 학습 여정에 함께해줘서 고마워요.\n\n좋은 여행 되세요!\n","ogImage":{"url":"/assets/img/2024-05-23-LearningRustPart11BuildersandDatabaseInteraction_0.png"},"coverImage":"/assets/img/2024-05-23-LearningRustPart11BuildersandDatabaseInteraction_0.png","tag":["Tech"],"readingTime":24},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e다음 시리즈로 넘어가보겠습니다; 이 부분에서는 데이터 구조에 빌더 패턴을 구현하는 방법을 살펴보겠습니다. 그런 다음 sqlx와 Postgres를 사용한 데이터베이스 상호작용으로 넘어가겠습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-23-LearningRustPart11BuildersandDatabaseInteraction_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch1\u003eRust 시리즈\u003c/h1\u003e\n\u003cp\u003e부분 1 — 기본 개념\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003ePart 2 — 메모리\u003c/p\u003e\n\u003cp\u003ePart 3 — 흐름 제어와 함수\u003c/p\u003e\n\u003cp\u003ePart 4 — 옵션/결과 및 컬렉션\u003c/p\u003e\n\u003cp\u003ePart 5 — 트레이트, 제네릭 및 클로저\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e제 6부 — 매크로, 반복자 및 파일 처리\u003c/p\u003e\n\u003cp\u003e제 7부 — 스레드 공유 상태 및 채널\u003c/p\u003e\n\u003cp\u003e제 8부 — Cargo, 크레이트, 모듈 및 라이브러리\u003c/p\u003e\n\u003cp\u003e제 9부 — 명령행 인수, 워크스페이스 및 테스팅\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e제 10부 — 상자 포인터 및 웹 앱\u003c/p\u003e\n\u003cp\u003e제 11부 — 빌더와 데이터베이스 상호작용 (이 기사)\u003c/p\u003e\n\u003ch1\u003e소개\u003c/h1\u003e\n\u003cp\u003e이것은 러스트 학습 시리즈의 열한 번째 섹션입니다. 이번에는 러스트에서 빌더 패턴을 다룰 것입니다. 이 공통된 패턴은 구조체를 안전하고 투명하게 초기화하는 좋은 방법입니다. 다음으로, 우리는 포스트그레스와 SQLX 프레임워크를 사용하여 데이터베이스에서 CRUD 작업을 수행하는 방법을 살펴볼 것입니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e준비물\u003c/h1\u003e\n\u003cp\u003e이 글의 데이터베이스 부분을 위한 유일한 준비물은 Rust와 Cargo가 설치되어 있고 시스템에 Docker가 설치되어 있는 것입니다. 만약 Docker를 가지고 있지 않지만 로컬 Postgres DB가 이미 설치되어 있거나 다른 서버의 DB에 액세스할 수 있다면 Docker Postgres 설정을 건너뛰고 DB에 연결하기 위한 연결 속성만 수정하면 됩니다.\u003c/p\u003e\n\u003ch1\u003e빌더 패턴\u003c/h1\u003e\n\u003cp\u003e빌더 패턴은 복잡한 객체의 구성을 해당 표현에서 분리하는 디자인 패턴입니다. 이 패턴을 사용하면 유효성 검사를 수행하고 기본값으로 대체하며 값을 부분적으로 할당한 후에 항목을 생성할 수 있습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eRust로 그 구현하는 방법을 살펴볼 거예요. 이것이 우리의 코드입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e#[\u003cspan class=\"hljs-title function_\"\u003ederive\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eDebug\u003c/span\u003e)]\nstruct \u003cspan class=\"hljs-title class_\"\u003eChargingSession\u003c/span\u003e {\n    \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003ewatts\u003c/span\u003e: u32,\n    \u003cspan class=\"hljs-attr\"\u003evin\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e,\n}\n\nstruct \u003cspan class=\"hljs-title class_\"\u003eChargingSessionBuilder\u003c/span\u003e {\n    \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003ewatts\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eOption\u003c/span\u003e\u0026#x3C;u32\u003e,\n    \u003cspan class=\"hljs-attr\"\u003evin\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eOption\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e\u003e,\n}\n\nimpl \u003cspan class=\"hljs-title class_\"\u003eChargingSessionBuilder\u003c/span\u003e {\n    fn \u003cspan class=\"hljs-title function_\"\u003enew\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: \u0026#x26;str) -\u003e \u003cspan class=\"hljs-title class_\"\u003eChargingSessionBuilder\u003c/span\u003e {\n        \u003cspan class=\"hljs-title class_\"\u003eChargingSessionBuilder\u003c/span\u003e {\n            \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: id.\u003cspan class=\"hljs-title function_\"\u003eto_string\u003c/span\u003e(),\n            \u003cspan class=\"hljs-attr\"\u003ewatts\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e,\n            \u003cspan class=\"hljs-attr\"\u003evin\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e,\n        }\n    }\n\n    fn \u003cspan class=\"hljs-title function_\"\u003ewatts\u003c/span\u003e(mut self, \u003cspan class=\"hljs-attr\"\u003ewatts\u003c/span\u003e: u32) -\u003e \u003cspan class=\"hljs-title class_\"\u003eChargingSessionBuilder\u003c/span\u003e {\n        self.\u003cspan class=\"hljs-property\"\u003ewatts\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eSome\u003c/span\u003e(watts);\n        self\n    }\n\n    fn \u003cspan class=\"hljs-title function_\"\u003evin\u003c/span\u003e(mut self, \u003cspan class=\"hljs-attr\"\u003evin\u003c/span\u003e: \u0026#x26;str) -\u003e \u003cspan class=\"hljs-title class_\"\u003eChargingSessionBuilder\u003c/span\u003e {\n        self.\u003cspan class=\"hljs-property\"\u003evin\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eSome\u003c/span\u003e(vin.\u003cspan class=\"hljs-title function_\"\u003eto_string\u003c/span\u003e());\n        self\n    }\n\n    fn \u003cspan class=\"hljs-title function_\"\u003ebuild\u003c/span\u003e(self) -\u003e \u003cspan class=\"hljs-title class_\"\u003eChargingSession\u003c/span\u003e {\n        \u003cspan class=\"hljs-title class_\"\u003eChargingSession\u003c/span\u003e {\n            \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: self.\u003cspan class=\"hljs-property\"\u003eid\u003c/span\u003e,\n            \u003cspan class=\"hljs-attr\"\u003ewatts\u003c/span\u003e: self.\u003cspan class=\"hljs-property\"\u003ewatts\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eunwrap_or_else\u003c/span\u003e(|| \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e),\n            \u003cspan class=\"hljs-attr\"\u003evin\u003c/span\u003e: self.\u003cspan class=\"hljs-property\"\u003evin\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eunwrap_or_else\u003c/span\u003e(|| \u003cspan class=\"hljs-string\"\u003e\"Unknown\"\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eto_string\u003c/span\u003e()),\n        }\n    }\n}\n\nfn \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-comment\"\u003e// 이것은 ChargingSession을 생성하는 표준적인 방법입니다.\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e cs_old_way = \u003cspan class=\"hljs-title class_\"\u003eChargingSession\u003c/span\u003e {\n        \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003efrom\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"11111\"\u003c/span\u003e),\n        \u003cspan class=\"hljs-attr\"\u003ewatts\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e420\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003evin\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003efrom\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"4Y1SL65848Z411439\"\u003c/span\u003e),\n    };\n    println!(\u003cspan class=\"hljs-string\"\u003e\"Regular way to create struct: {:?}\"\u003c/span\u003e, cs_old_way);\n\n    \u003cspan class=\"hljs-comment\"\u003e// 빌더를 사용해서 생성하는 방법입니다.\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e cs = \u003cspan class=\"hljs-title class_\"\u003eChargingSessionBuilder\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003enew\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"11111\"\u003c/span\u003e)\n        .\u003cspan class=\"hljs-title function_\"\u003ewatts\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e420\u003c/span\u003e)\n        .\u003cspan class=\"hljs-title function_\"\u003evin\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"4Y1SL65848Z411439\"\u003c/span\u003e)\n        .\u003cspan class=\"hljs-title function_\"\u003ebuild\u003c/span\u003e();\n    println!(\u003cspan class=\"hljs-string\"\u003e\"Builder pattern to create struct: {:?}\"\u003c/span\u003e, cs);\n\n    \u003cspan class=\"hljs-comment\"\u003e// ID만 제공하여 생성하는 예시입니다.\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e cs_lean = \u003cspan class=\"hljs-title class_\"\u003eChargingSessionBuilder\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003enew\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"11111\"\u003c/span\u003e)\n    .\u003cspan class=\"hljs-title function_\"\u003ebuild\u003c/span\u003e();\n     println!(\u003cspan class=\"hljs-string\"\u003e\"Builder pattern to create struct (default values): {:?}\"\u003c/span\u003e, cs_lean);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이걸 한 번에 이해하기에 많지만, 단계적으로 진행해 봅시다.\u003c/p\u003e\n\u003cp\u003e먼저, 충전 세션 정보를 저장하는 구조체를 정의했습니다. 이 시리즈의 이전 예제에서 하나의 필드인 세션용 차량 ID 번호인 vin을 추가했어요.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e그러면 데이터 구조체와 동일한 필드를 가진 빌더를 위한 구조체를 정의합니다.\u003c/p\u003e\n\u003cp\u003e빌더는 impl 블록에서 구현되며, id 및 각 추가 필드를 설정하는 함수를 정의하는 새 함수가 있습니다. 그러나 몇 가지 중요한 사항이 있습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e각 함수는 ChargingSessionBuilder 유형을 반환합니다. 기본적으로 self입니다.\u003c/li\u003e\n\u003cli\u003e추가 속성 필드에는 mut self를 첫 번째 매개변수로 사용하는 메서드가 있습니다. 이는 이러한 함수 호출의 체이닝을 허용하는 데 중요합니다. 또한 여기에 유효성 검사 논리를 코딩할 수 있습니다.\u003c/li\u003e\n\u003cli\u003ebuild 함수가 모두 통합되는 곳입니다. 존재하는 값들을 할당하고 나면 기본값을 결정하고 대상 구조체를 생성할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이를 통해 빌더 패턴의 우아함과 Rust 내에서의 구현 방법을 살펴보았습니다. 이것이 앱이나 라이브러리에 코드를 구현하는 훌륭한 방법임을 알 수 있기를 바랍니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e다음 섹션인 데이터베이스로 넘어가 봅시다.\u003c/p\u003e\n\u003ch1\u003e데이터베이스 — sqlx\u003c/h1\u003e\n\u003cp\u003e이 섹션에서는 Rust 프로그램에서 sqlx를 사용하여 데이터베이스 작업을 살펴볼 것입니다. 먼저 일부 설정이 필요합니다.\u003c/p\u003e\n\u003ch2\u003e설정\u003c/h2\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e새 프로젝트를 시작해봅시다. db_app이라고 이름 짓고, cargo new db_app으로 생성할 수 있어요. 기본 디렉토리에 몇 개의 파일을 생성할 거에요. 첫 번째 파일은 docker-compose.yml이라고 하며 다음 내용이 있어야 합니다. Postgres와 Pgadmin이 노출되는 임의의 포트를 선택했으며, 컴퓨터에 설치된 다른 앱들과 충돌하지 않도록 했어요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-attr\"\u003eversion\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'3'\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003eservices\u003c/span\u003e:\n  \u003cspan class=\"hljs-attr\"\u003epostgres\u003c/span\u003e:\n    \u003cspan class=\"hljs-attr\"\u003eimage\u003c/span\u003e: \u003cspan class=\"hljs-attr\"\u003epostgres\u003c/span\u003e:latest\n    \u003cspan class=\"hljs-attr\"\u003econtainer_name\u003c/span\u003e: postgres\n    \u003cspan class=\"hljs-attr\"\u003eports\u003c/span\u003e:\n      - \u003cspan class=\"hljs-string\"\u003e'6500:5432'\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003evolumes\u003c/span\u003e:\n      - \u003cspan class=\"hljs-attr\"\u003epostgresDB\u003c/span\u003e:\u003cspan class=\"hljs-regexp\"\u003e/data/\u003c/span\u003epostgres\n    \u003cspan class=\"hljs-attr\"\u003eenv_file\u003c/span\u003e:\n      - ./.\u003cspan class=\"hljs-property\"\u003eenv\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003epgAdmin\u003c/span\u003e:\n    \u003cspan class=\"hljs-attr\"\u003eimage\u003c/span\u003e: dpage/pgadmin4\n    \u003cspan class=\"hljs-attr\"\u003econtainer_name\u003c/span\u003e: pgAdmin\n    \u003cspan class=\"hljs-attr\"\u003eenv_file\u003c/span\u003e:\n      - ./.\u003cspan class=\"hljs-property\"\u003eenv\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003eports\u003c/span\u003e:\n      - \u003cspan class=\"hljs-string\"\u003e\"5050:80\"\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003evolumes\u003c/span\u003e:\n  \u003cspan class=\"hljs-attr\"\u003epostgresDB\u003c/span\u003e:\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e.env이라는 파일이 하나 더 필요하며, 다음 내용이 있어야 해요. 이 파일은 docker-compose 파일과 나중에 Rust 애플리케이션에서 모두 사용할 거에요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable constant_\"\u003ePOSTGRES_HOST\u003c/span\u003e=\u003cspan class=\"hljs-number\"\u003e127.0\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.0\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.1\u003c/span\u003e\n\u003cspan class=\"hljs-variable constant_\"\u003ePOSTGRES_PORT\u003c/span\u003e=\u003cspan class=\"hljs-number\"\u003e6500\u003c/span\u003e\n\u003cspan class=\"hljs-variable constant_\"\u003ePOSTGRES_USER\u003c/span\u003e=admin\n\u003cspan class=\"hljs-variable constant_\"\u003ePOSTGRES_PASSWORD\u003c/span\u003e=password123\n\u003cspan class=\"hljs-variable constant_\"\u003ePOSTGRES_DB\u003c/span\u003e=charging_session\n\n\u003cspan class=\"hljs-variable constant_\"\u003eDATABASE_URL\u003c/span\u003e=\u003cspan class=\"hljs-attr\"\u003epostgresql\u003c/span\u003e:\u003cspan class=\"hljs-comment\"\u003e//admin:password123@localhost:6500/charging_session?currentSchema=public\u003c/span\u003e\n\n\u003cspan class=\"hljs-variable constant_\"\u003ePGADMIN_DEFAULT_EMAIL\u003c/span\u003e=admin@admin.\u003cspan class=\"hljs-property\"\u003ecom\u003c/span\u003e\n\u003cspan class=\"hljs-variable constant_\"\u003ePGADMIN_DEFAULT_PASSWORD\u003c/span\u003e=password123\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e위의 내용과 함께 데이터베이스 사용자, 비밀번호, 그리고 Pgadmin에 대한 연결 정보를 제공해 드렸습니다.\u003c/p\u003e\n\u003cp\u003e이 두 가지 항목을 만들고 위의 내용을 사용하여 Docker Compose를 사용하여 로컬 DB 인스턴스를 시작할 수 있습니다. 처음에는 항상 전경에서 시작하는 것을 좋아합니다. 이미지 다운로드 및 기타 작업을 하기 때문에 여러분의 컴퓨터 및 네트워크 속도에 따라 시간이 소요될 수 있습니다. docker-compose.yml 및 .env 파일이 있는 디렉토리와 동일한 위치에서 다음을 실행하십시오.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edocker-compose up\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e시작된 모든 것을 확인한 후에는 언제든지 -d 스위치를 사용하여 데몬 모드로 시작할 수 있습니다. 완료되면 두 컨테이너가 시작되었는지 확인해 봅시다. 다음과 같이 명령을 실행합니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edocker ps\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e비슷한 결과가 표시됩니다.\u003c/p\u003e\n\u003cimg src=\"/assets/img/2024-05-23-LearningRustPart11BuildersandDatabaseInteraction_1.png\"\u003e\n\u003cp\u003e만약 두 개의 컨테이너가 표시되지 않는다면, docker-compose를 실행한 터미널에서 에러를 확인해보세요.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e한 번 이들이 실행되면 DB에 연결해 봅시다. Pgadmin을 포트 5050에서 실행하도록 구성했으니 브라우저에서 \u003ca href=\"http://localhost:5050%EC%9D%84\" rel=\"nofollow\" target=\"_blank\"\u003ehttp://localhost:5050을\u003c/a\u003e 입력하면 pgadmin의 로그인 화면이 표시됩니다. .env 파일에 구성된 자격 증명(관리자@관리자.com/비밀번호123)을 사용하여 pgadmin에 로그인할 수 있습니다. 그런데 아직 데이터베이스에 연결되지 않았습니다. 이를 위해 다음을 실행해야 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edocker inspect postgres\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e출력을 확인하여 \"NetworkSettings\" 섹션으로 이동하고 \"IPAddress\" 속성의 값을 복사합니다. 이 값은 DB에 연결하는 데 사용할 호스트(IP)입니다. 제 컴퓨터에서 이 값은 172.23.0.1 이었습니다.\u003c/p\u003e\n\u003cp\u003e로그인한 후 \"새 서버 추가\" 버튼을 클릭하고, \"호스트 이름/주소\"로 이전에 복사한 IP 주소를 포함한 필수 자격 증명을 제공하고 \"저장\" 버튼을 클릭하세요.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e서버에 로그인하면 데이터베이스 charging_session을 볼 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-23-LearningRustPart11BuildersandDatabaseInteraction_2.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e잘 했어요. 데이터베이스를 사용할 준비가 되었고 Pgadmin에서 관리할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이제 Rust 앱의 종속성을 구성해 봅시다. 처음에는 모두 필요하지 않지만 결국 필요하게 될 것이므로 지금 추가해 두는 것이 좋습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eCargo.toml 파일의 종속성 부분을 다음과 같이 수정하세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-toml\"\u003e\u003cspan class=\"hljs-section\"\u003e[dependencies]\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003echrono\u003c/span\u003e = { version = \u003cspan class=\"hljs-string\"\u003e\"0.4.31\"\u003c/span\u003e, features = [\u003cspan class=\"hljs-string\"\u003e\"serde\"\u003c/span\u003e] }\n\u003cspan class=\"hljs-attr\"\u003edotenv\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\"0.15.0\"\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003eenv_logger\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\"0.10.1\"\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003elog\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\"0.4.20\"\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003eserde\u003c/span\u003e = { version = \u003cspan class=\"hljs-string\"\u003e\"1.0.193\"\u003c/span\u003e, features = [\u003cspan class=\"hljs-string\"\u003e\"derive\"\u003c/span\u003e] }\n\u003cspan class=\"hljs-attr\"\u003eserde_json\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\"1.0.108\"\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003esqlx\u003c/span\u003e = { version = \u003cspan class=\"hljs-string\"\u003e\"0.7.3\"\u003c/span\u003e, features = [\u003cspan class=\"hljs-string\"\u003e\"runtime-tokio-native-tls\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"postgres\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"uuid\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"chrono\"\u003c/span\u003e] }\n\u003cspan class=\"hljs-attr\"\u003etokio\u003c/span\u003e = { version = \u003cspan class=\"hljs-string\"\u003e\"1.35.0\"\u003c/span\u003e, features = [\u003cspan class=\"hljs-string\"\u003e\"macros\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"rt-multi-thread\"\u003c/span\u003e]}\n\u003cspan class=\"hljs-attr\"\u003euuid\u003c/span\u003e = { version = \u003cspan class=\"hljs-string\"\u003e\"1.6.1\"\u003c/span\u003e, features = [\u003cspan class=\"hljs-string\"\u003e\"serde\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"v4\"\u003c/span\u003e] }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다양한 종속성에 대해 활성화된 기능을 검토하는 데도 시간을 할애하는 것이 좋습니다.\u003c/p\u003e\n\u003cp\u003e다음으로, 필요한 테이블을 만들기 위해 sqlx-cli 마이그레이션 기능을 사용할 것입니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e우선 명령 줄에서 다음을 실행하여 CLI를 설치해야 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ecargo install sqlx-cli --no-\u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e-features --features rustls,postgres\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그런 다음 마이그레이션 파일을 초기화해야 합니다. 다음과 같이 실행합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003esqlx migrate add initial-tables\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이 명령어는 우리가 마이그레이션 스크립트를 작성하기 위해 새 파일 migrations/\u003ccode\u003etimestamp\u003c/code\u003e_initial-tables.sql을 생성합니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-23-LearningRustPart11BuildersandDatabaseInteraction_3.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e이 파일을 열고 아래 SQL 문을 추가하여 테이블을 생성하세요.\u003c/p\u003e\n\u003cp\u003ecreate table locations (\nid bigserial primary key,\nname varchar(255) unique not null\n);\u003c/p\u003e\n\u003cp\u003ecreate table sessions (\nid bigserial primary key,\nlocation_id bigint not null,\nwatts bigint not null,\nvin varchar(255) not null,\nconstraint fk_location foreign key (location_id) references locations(id) on delete cascade\n);\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e위 예제에서 사용할 두 개의 테이블 정의입니다. 이 시리즈의 충전 세션에 대한 표준 예제를 확장하여, 충전 장치의 위치를 저장할 locations 테이블을 추가했습니다.\u003c/p\u003e\n\u003cp\u003e이제 다음을 실행하여 테이블을 생성하세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003esqlx migrate run\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그러면 즉시 20231212235431/migrate initial-tables (타임스탬프 부분은 달라질 수 있음)과 같은 메시지가 표시됩니다. 이제 Pgadmin에 가서 테이블을 확인할 수 있습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cimg src=\"/assets/img/2024-05-23-LearningRustPart11BuildersandDatabaseInteraction_4.png\"\u003e\n\u003cp\u003e위에서 보듯이 두 개의 테이블이 생성되었고, 문서 목적을 위해 Pgadmin 내에 ERD 다이어그램도 생성했습니다. 이제 초기 설정과 프로젝트 구성을 완료했습니다.\u003c/p\u003e\n\u003ch1\u003e데이터베이스 함수\u003c/h1\u003e\n\u003cp\u003e이 섹션에서는 데이터베이스 상호 작용의 다양한 유형과 Rust 구현을 살펴볼 것입니다. 이는 데이터베이스에 연결하는 것으로 시작됩니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eDB에 연결하기\u003c/p\u003e\n\u003cp\u003e데이터베이스에 연결하는 방법은 PgPoolOptions connect 함수를 통해 연결을 생성하는 것입니다. 우리의 .env 파일에서 데이터베이스 연결 문자열을 읽고 로깅을 구성하며 성공 또는 오류를 기록하는 코드 전체는 아래와 같습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003euse \u003cspan class=\"hljs-attr\"\u003esqlx\u003c/span\u003e::{\u003cspan class=\"hljs-attr\"\u003epostgres\u003c/span\u003e::\u003cspan class=\"hljs-title class_\"\u003ePgPoolOptions\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003ePool\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003ePostgres\u003c/span\u003e};\nuse \u003cspan class=\"hljs-attr\"\u003edotenv\u003c/span\u003e::dotenv;\nuse \u003cspan class=\"hljs-attr\"\u003elog\u003c/span\u003e::{info, error};\n\n#[\u003cspan class=\"hljs-attr\"\u003etokio\u003c/span\u003e::main]\n\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e fn \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003estd\u003c/span\u003e::\u003cspan class=\"hljs-attr\"\u003eenv\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003evar_os\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"RUST_LOG\"\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003eis_none\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n        \u003cspan class=\"hljs-attr\"\u003estd\u003c/span\u003e::\u003cspan class=\"hljs-attr\"\u003eenv\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003eset_var\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"RUST_LOG\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"info\"\u003c/span\u003e);\n    }\n    \u003cspan class=\"hljs-title function_\"\u003edotenv\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003eok\u003c/span\u003e();\n    \u003cspan class=\"hljs-attr\"\u003eenv_logger\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003einit\u003c/span\u003e();\n\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e database_url = \u003cspan class=\"hljs-attr\"\u003estd\u003c/span\u003e::\u003cspan class=\"hljs-attr\"\u003eenv\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003evar\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"DATABASE_URL\"\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003eexpect\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"DATABASE_URL must be set\"\u003c/span\u003e);\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e pool = match \u003cspan class=\"hljs-title class_\"\u003ePgPoolOptions\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003enew\u003c/span\u003e()\n        .\u003cspan class=\"hljs-title function_\"\u003emax_connections\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e)\n        .\u003cspan class=\"hljs-title function_\"\u003econnect\u003c/span\u003e(\u0026#x26;database_url)\n        .\u003cspan class=\"hljs-property\"\u003eawait\u003c/span\u003e\n    {\n        \u003cspan class=\"hljs-title class_\"\u003eOk\u003c/span\u003e(pool) =\u003e {\n            info!(\u003cspan class=\"hljs-string\"\u003e\"✅ 데이터베이스에 연결되었습니다!\"\u003c/span\u003e);\n            pool\n        }\n        \u003cspan class=\"hljs-title class_\"\u003eErr\u003c/span\u003e(err) =\u003e {\n            error!(\u003cspan class=\"hljs-string\"\u003e\"🔥 데이터베이스 연결에 실패했습니다: {:?}\"\u003c/span\u003e, err);\n            \u003cspan class=\"hljs-attr\"\u003estd\u003c/span\u003e::\u003cspan class=\"hljs-attr\"\u003eprocess\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003eexit\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\n        }\n    };\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e시작 부분의 #[tokio::main] 매크로를 주목해주세요. 이는 async fn main()을 동기 fn main()로 변환하여 런타임 인스턴스를 초기화하고 async main 함수를 실행하게 합니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e위 코드를 실행하면 출력 로깅에서 다음 메시지가 표시됩니다.\u003c/p\u003e\n\u003cp\u003e[2023-12-13T00:16:42Z INFO db_app] ✅ 데이터베이스에 연결되었습니다!\u003c/p\u003e\n\u003cp\u003e우리는 데이터베이스에 연결할 수 있습니다. .env 파일에서 구성한 모든 연결 정보를 기억해 주세요. 이 정보는 docker-compose, sqlx-cli, 그리고 우리의 어플리케이션에서 공유되었습니다.\u003c/p\u003e\n\u003ch2\u003eInserts\u003c/h2\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이제 연결 풀이 준비되었으니, 우리가 살펴볼 첫 번째 데이터베이스 로직은 삽입입니다. sqlx를 사용하여 삽입하는 방법은 다음과 같습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003einsert_result\u003c/span\u003e = sqlx::query_as!(\n    Locations,\n    \u003cspan class=\"hljs-string\"\u003e\"INSERT INTO locations (id,name) VALUES (1, 'Location A') RETURNING *\"\u003c/span\u003e\n)\n.\u003cspan class=\"hljs-title function_ invoke__\"\u003efetch_one\u003c/span\u003e(\u0026#x26;pool)\n.\u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003ematch\u003c/span\u003e insert_result {\n    \u003cspan class=\"hljs-title function_ invoke__\"\u003eOk\u003c/span\u003e(location) =\u003e {\n        info!(\u003cspan class=\"hljs-string\"\u003e\"✓Inserted: {:?}\"\u003c/span\u003e, location);\n    }\n    \u003cspan class=\"hljs-title function_ invoke__\"\u003eErr\u003c/span\u003e(e) =\u003e {\n        error!(\u003cspan class=\"hljs-string\"\u003e\"Error Insert: {}\"\u003c/span\u003e, e.\u003cspan class=\"hljs-title function_ invoke__\"\u003eto_string\u003c/span\u003e())\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 코드는 하나의 레코드를 삽입할 것입니다. 물론 매개변수를 사용할 수도 있으며, 이는 업데이트를 살펴볼 때 살펴볼 것입니다.\u003c/p\u003e\n\u003ch2\u003e질의하기\u003c/h2\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e다음으로, 데이터베이스를 조회하는 방법을 살펴보겠습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e query_result = \u003cspan class=\"hljs-attr\"\u003esqlx\u003c/span\u003e::query_as!(\u003cspan class=\"hljs-title class_\"\u003eLocations\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"SELECT * FROM Locations\"\u003c/span\u003e)\n        .\u003cspan class=\"hljs-title function_\"\u003efetch_all\u003c/span\u003e(\u0026#x26;pool)\n        .\u003cspan class=\"hljs-property\"\u003eawait\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e query_result.\u003cspan class=\"hljs-title function_\"\u003eis_err\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n        \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e message = \u003cspan class=\"hljs-string\"\u003e\"모든 위치를 가져오는 동안 문제가 발생했습니다.\"\u003c/span\u003e;\n        error!(\u003cspan class=\"hljs-string\"\u003e\"{}{}\"\u003c/span\u003e, message, query_result.\u003cspan class=\"hljs-title function_\"\u003eerr\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003eunwrap\u003c/span\u003e());\n    } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n        info!(\u003cspan class=\"hljs-string\"\u003e\"😎 위치에 대한 쿼리 결과 {:?}\"\u003c/span\u003e, query_result.\u003cspan class=\"hljs-title function_\"\u003eunwrap\u003c/span\u003e());\n    }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이것은 성공적으로 작동했다면 unwrap을 통해 결과에 접근할 수 있는 결과를 반환합니다. 쿼리 내의 이슈가 발생했다면 해당 에러에 접근할 수도 있습니다.\u003c/p\u003e\n\u003ch2\u003e업데이트\u003c/h2\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e다음 작업은 데이터베이스를 업데이트하는 것입니다. 이는 이전에 삽입한 것과 비슷할 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e update_result = \u003cspan class=\"hljs-attr\"\u003esqlx\u003c/span\u003e::query_as!(\n        \u003cspan class=\"hljs-title class_\"\u003eSessions\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e\"UPDATE sessions SET watts = 415 WHERE id = $1 RETURNING *\"\u003c/span\u003e,\n        1i64,\n    )\n    .\u003cspan class=\"hljs-title function_\"\u003efetch_one\u003c/span\u003e(\u0026#x26;pool)\n    .\u003cspan class=\"hljs-property\"\u003eawait\u003c/span\u003e;\n\n    match update_result {\n        \u003cspan class=\"hljs-title class_\"\u003eOk\u003c/span\u003e(session) =\u003e {\n            info!(\u003cspan class=\"hljs-string\"\u003e\"✓Update: {:?}\"\u003c/span\u003e, session);\n        }\n        \u003cspan class=\"hljs-title class_\"\u003eErr\u003c/span\u003e(e) =\u003e {\n            error!(\u003cspan class=\"hljs-string\"\u003e\"Error Update: {}\"\u003c/span\u003e, e.\u003cspan class=\"hljs-title function_\"\u003eto_string\u003c/span\u003e())\n        }\n    }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 예제에서 주목할 점은 $1이라는 매개변수 자리 표시자를 사용하는 준비된 문(statement)를 사용하고 있다는 것입니다. 그런 다음 SQL 문자열 뒤에 매개변수를 전달합니다.\u003c/p\u003e\n\u003ch2\u003eDeletes\u003c/h2\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e마지막으로, 데이터베이스에서 레코드를 삭제하는 CRUD 작업을 완료합니다. 우리의 목적은 데이터베이스를 정리하는 데 사용할 것이며, 이렇게 하면 언제든지 응용 프로그램을 실행할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e rows_deleted = \u003cspan class=\"hljs-attr\"\u003esqlx\u003c/span\u003e::query!(\u003cspan class=\"hljs-string\"\u003e\"DELETE from sessions\"\u003c/span\u003e)\n    .\u003cspan class=\"hljs-title function_\"\u003eexecute\u003c/span\u003e(\u0026#x26;pool)\n    .\u003cspan class=\"hljs-property\"\u003eawait\u003c/span\u003e\n    .\u003cspan class=\"hljs-title function_\"\u003eunwrap\u003c/span\u003e()\n    .\u003cspan class=\"hljs-title function_\"\u003erows_affected\u003c/span\u003e();\n\ninfo!(\u003cspan class=\"hljs-string\"\u003e\"✕ 세션 테이블에서 {}개의 행 삭제됨\"\u003c/span\u003e, rows_deleted);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서는 연산에서처럼 sqlx::query 대신 sqlx::query_as를 사용합니다. 또한 언랩 이후 .rows_affected를 추가하여 삭제된 행 수를 얻습니다.\u003c/p\u003e\n\u003ch2\u003e트랜잭션\u003c/h2\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e   \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003etx\u003c/span\u003e = pool.\u003cspan class=\"hljs-title function_ invoke__\"\u003ebegin\u003c/span\u003e().\u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e.\u003cspan class=\"hljs-title function_ invoke__\"\u003eexpect\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"트랜잭션을 시작할 수 없습니다\"\u003c/span\u003e);\n\n   \u003cspan class=\"hljs-comment\"\u003e// 데이터베이스 작업 수행(데이터 삽입 또는 변경)\u003c/span\u003e\n\n   tx.\u003cspan class=\"hljs-title function_ invoke__\"\u003ecommit\u003c/span\u003e().\u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e.\u003cspan class=\"hljs-title function_ invoke__\"\u003eexpect\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"트랜잭션을 커밋할 수 없습니다\"\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e커밋을 호출하지 않으면 트랜잭션이 범위를 벗어나면 자동으로 롤백됩니다.\u003c/p\u003e\n\u003ch2\u003e완전한 응용 프로그램\u003c/h2\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e위의 코드는 우리가 이전에 논의한 모든 다양한 기능이 하나의 애플리케이션에 모두 포함된 완전한 애플리케이션입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003euse \u003cspan class=\"hljs-attr\"\u003edotenv\u003c/span\u003e::dotenv;\nuse \u003cspan class=\"hljs-attr\"\u003elog\u003c/span\u003e::{error, info};\nuse \u003cspan class=\"hljs-attr\"\u003esqlx\u003c/span\u003e::{\u003cspan class=\"hljs-attr\"\u003epostgres\u003c/span\u003e::\u003cspan class=\"hljs-title class_\"\u003ePgPoolOptions\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003ePool\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003ePostgres\u003c/span\u003e};\n\n#[\u003cspan class=\"hljs-title function_\"\u003ederive\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eDebug\u003c/span\u003e)]\nstruct \u003cspan class=\"hljs-title class_\"\u003eLocations\u003c/span\u003e {\n    \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: i64,\n    \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e,\n}\n\n#[\u003cspan class=\"hljs-title function_\"\u003ederive\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eDebug\u003c/span\u003e)]\nstruct \u003cspan class=\"hljs-title class_\"\u003eSessions\u003c/span\u003e {\n    \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: i64,\n    \u003cspan class=\"hljs-attr\"\u003elocation_id\u003c/span\u003e: i64,\n    \u003cspan class=\"hljs-attr\"\u003ewatts\u003c/span\u003e: i64,\n    \u003cspan class=\"hljs-attr\"\u003evin\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e,\n}\n\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e fn \u003cspan class=\"hljs-title function_\"\u003einsert_into_locations\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003epool: Pool\u0026#x3C;Postgres\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e tx = pool.\u003cspan class=\"hljs-title function_\"\u003ebegin\u003c/span\u003e().\u003cspan class=\"hljs-property\"\u003eawait\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eexpect\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Unable to begin transaction\"\u003c/span\u003e);\n\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e insert_result = \u003cspan class=\"hljs-attr\"\u003esqlx\u003c/span\u003e::query_as!(\n        \u003cspan class=\"hljs-title class_\"\u003eLocations\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e\"INSERT INTO locations (id,name) VALUES (1, 'Location A') RETURNING *\"\u003c/span\u003e\n    )\n    .\u003cspan class=\"hljs-title function_\"\u003efetch_one\u003c/span\u003e(\u0026#x26;pool)\n    .\u003cspan class=\"hljs-property\"\u003eawait\u003c/span\u003e;\n\n    match insert_result {\n        \u003cspan class=\"hljs-title class_\"\u003eOk\u003c/span\u003e(location) =\u003e {\n            info!(\u003cspan class=\"hljs-string\"\u003e\"✓Inserted: {:?}\"\u003c/span\u003e, location);\n        }\n        \u003cspan class=\"hljs-title class_\"\u003eErr\u003c/span\u003e(e) =\u003e {\n            error!(\u003cspan class=\"hljs-string\"\u003e\"Error Insert: {}\"\u003c/span\u003e, e.\u003cspan class=\"hljs-title function_\"\u003eto_string\u003c/span\u003e())\n        }\n    }\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e insert_result = \u003cspan class=\"hljs-attr\"\u003esqlx\u003c/span\u003e::query_as!(\n        \u003cspan class=\"hljs-title class_\"\u003eLocations\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e\"INSERT INTO locations (id,name) VALUES (2, 'Location B') RETURNING *\"\u003c/span\u003e\n    )\n    .\u003cspan class=\"hljs-title function_\"\u003efetch_one\u003c/span\u003e(\u0026#x26;pool)\n    .\u003cspan class=\"hljs-property\"\u003eawait\u003c/span\u003e;\n\n    match insert_result {\n        \u003cspan class=\"hljs-title class_\"\u003eOk\u003c/span\u003e(location) =\u003e {\n            info!(\u003cspan class=\"hljs-string\"\u003e\"✓Inserted: {:?}\"\u003c/span\u003e, location);\n        }\n        \u003cspan class=\"hljs-title class_\"\u003eErr\u003c/span\u003e(e) =\u003e {\n            error!(\u003cspan class=\"hljs-string\"\u003e\"Error Insert: {}\"\u003c/span\u003e, e.\u003cspan class=\"hljs-title function_\"\u003eto_string\u003c/span\u003e())\n        }\n    }\n\n    tx.\u003cspan class=\"hljs-title function_\"\u003ecommit\u003c/span\u003e().\u003cspan class=\"hljs-property\"\u003eawait\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eexpect\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Unable to commit the transaction\"\u003c/span\u003e);\n}\n\n\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e fn \u003cspan class=\"hljs-title function_\"\u003einsert_into_sessions\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003epool: Pool\u0026#x3C;Postgres\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e tx = pool.\u003cspan class=\"hljs-title function_\"\u003ebegin\u003c/span\u003e().\u003cspan class=\"hljs-property\"\u003eawait\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eexpect\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Unable to begin transaction\"\u003c/span\u003e);\n\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e insert_result = \u003cspan class=\"hljs-attr\"\u003esqlx\u003c/span\u003e::query_as!(\n        \u003cspan class=\"hljs-title class_\"\u003eSessions\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e\"INSERT INTO sessions (id,location_id, watts, vin) VALUES (1, 1, 420, '2FMZA52286BA02033') RETURNING *\"\u003c/span\u003e\n    )\n    .\u003cspan class=\"hljs-title function_\"\u003efetch_one\u003c/span\u003e(\u0026#x26;pool)\n    .\u003cspan class=\"hljs-property\"\u003eawait\u003c/span\u003e;\n\n    match insert_result {\n        \u003cspan class=\"hljs-title class_\"\u003eOk\u003c/span\u003e(session) =\u003e {\n            info!(\u003cspan class=\"hljs-string\"\u003e\"✓Inserted: {:?}\"\u003c/span\u003e, session);\n        }\n        \u003cspan class=\"hljs-title class_\"\u003eErr\u003c/span\u003e(e) =\u003e {\n            error!(\u003cspan class=\"hljs-string\"\u003e\"Error Insert: {}\"\u003c/span\u003e, e.\u003cspan class=\"hljs-title function_\"\u003eto_string\u003c/span\u003e())\n        }\n    }\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e insert_result = \u003cspan class=\"hljs-attr\"\u003esqlx\u003c/span\u003e::query_as!(\n        \u003cspan class=\"hljs-title class_\"\u003eSessions\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e\"INSERT INTO sessions (id,location_id, watts, vin) VALUES (2, 2, 393, '1GMYA52286BA04055') RETURNING *\"\u003c/span\u003e\n)\n    .\u003cspan class=\"hljs-title function_\"\u003efetch_one\u003c/span\u003e(\u0026#x26;pool)\n    .\u003cspan class=\"hljs-property\"\u003eawait\u003c/span\u003e;\n\n    match insert_result {\n        \u003cspan class=\"hljs-title class_\"\u003eOk\u003c/span\u003e(session) =\u003e {\n            info!(\u003cspan class=\"hljs-string\"\u003e\"✓Inserted: {:?}\"\u003c/span\u003e, session);\n        }\n        \u003cspan class=\"hljs-title class_\"\u003eErr\u003c/span\u003e(e) =\u003e {\n            error!(\u003cspan class=\"hljs-string\"\u003e\"Error Insert: {}\"\u003c/span\u003e, e.\u003cspan class=\"hljs-title function_\"\u003eto_string\u003c/span\u003e())\n        }\n    }\n\n    tx.\u003cspan class=\"hljs-title function_\"\u003ecommit\u003c/span\u003e().\u003cspan class=\"hljs-property\"\u003eawait\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eexpect\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Unable to commit the transaction\"\u003c/span\u003e);\n}\n\n\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e fn \u003cspan class=\"hljs-title function_\"\u003eupdate_sessions\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003epool: Pool\u0026#x3C;Postgres\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e tx = pool.\u003cspan class=\"hljs-title function_\"\u003ebegin\u003c/span\u003e().\u003cspan class=\"hljs-property\"\u003eawait\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eexpect\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Unable to begin transaction\"\u003c/span\u003e);\n\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e update_result = \u003cspan class=\"hljs-attr\"\u003esqlx\u003c/span\u003e::query_as!(\n        \u003cspan class=\"hljs-title class_\"\u003eSessions\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e\"UPDATE sessions SET watts = 415 WHERE id = $1 RETURNING *\"\u003c/span\u003e,\n        1i64,\n    )\n    .\u003cspan class=\"hljs-title function_\"\u003efetch_one\u003c/span\u003e(\u0026#x26;pool)\n    .\u003cspan class=\"hljs-property\"\u003eawait\u003c/span\u003e;\n\n    match update_result {\n        \u003cspan class=\"hljs-title class_\"\u003eOk\u003c/span\u003e(session) =\u003e {\n            info!(\u003cspan class=\"hljs-string\"\u003e\"✓Update: {:?}\"\u003c/span\u003e, session);\n        }\n        \u003cspan class=\"hljs-title class_\"\u003eErr\u003c/span\u003e(e) =\u003e {\n            error!(\u003cspan class=\"hljs-string\"\u003e\"Error Update: {}\"\u003c/span\u003e, e.\u003cspan class=\"hljs-title function_\"\u003eto_string\u003c/span\u003e())\n        }\n    }\n\n    tx.\u003cspan class=\"hljs-title function_\"\u003ecommit\u003c/span\u003e().\u003cspan class=\"hljs-property\"\u003eawait\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eexpect\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Unable to commit the transaction\"\u003c/span\u003e);\n}\n\n\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e fn \u003cspan class=\"hljs-title function_\"\u003eclean_db\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003epool: Pool\u0026#x3C;Postgres\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e rows_deleted = \u003cspan class=\"hljs-attr\"\u003esqlx\u003c/span\u003e::query!(\u003cspan class=\"hljs-string\"\u003e\"DELETE from sessions\"\u003c/span\u003e)\n        .\u003cspan class=\"hljs-title function_\"\u003eexecute\u003c/span\u003e(\u0026#x26;pool)\n        .\u003cspan class=\"hljs-property\"\u003eawait\u003c/span\u003e\n        .\u003cspan class=\"hljs-title function_\"\u003eunwrap\u003c/span\u003e()\n        .\u003cspan class=\"hljs-title function_\"\u003erows_affected\u003c/span\u003e();\n\n    info!(\u003cspan class=\"hljs-string\"\u003e\"✕Deleted {} rows from sessions table\"\u003c/span\u003e, rows_deleted);\n\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e rows_deleted = \u003cspan class=\"hljs-attr\"\u003esqlx\u003c/span\u003e::query!(\u003cspan class=\"hljs-string\"\u003e\"DELETE from locations\"\u003c/span\u003e)\n        .\u003cspan class=\"hljs-title function_\"\u003eexecute\u003c/span\u003e(\u0026#x26;pool)\n        .\u003cspan class=\"hljs-property\"\u003eawait\u003c/span\u003e\n        .\u003cspan class=\"hljs-title function_\"\u003eunwrap\u003c/span\u003e()\n        .\u003cspan class=\"hljs-title function_\"\u003erows_affected\u003c/span\u003e();\n    info!(\u003cspan class=\"hljs-string\"\u003e\"✕Deleted {} rows from locations table\"\u003c/span\u003e, rows_deleted);\n}\n\n\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e fn \u003cspan class=\"hljs-title function_\"\u003equery_locations\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003epool: Pool\u0026#x3C;Postgres\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e query_result = \u003cspan class=\"hljs-attr\"\u003esqlx\u003c/span\u003e::query_as!(\u003cspan class=\"hljs-title class_\"\u003eLocations\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"SELECT * FROM Locations\"\u003c/span\u003e)\n        .\u003cspan class=\"hljs-title function_\"\u003efetch_all\u003c/span\u003e(\u0026#x26;pool)\n        .\u003cspan class=\"hljs-property\"\u003eawait\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e query_result.\u003cspan class=\"hljs-title function_\"\u003eis_err\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n        \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e message = \u003cspan class=\"hljs-string\"\u003e\"Something bad happened while fetching all locations\"\u003c/span\u003e;\n        error!(\u003cspan class=\"hljs-string\"\u003e\"{}\"\u003c/span\u003e, message);\n    } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n        info!(\u003cspan class=\"hljs-string\"\u003e\"😎Query Result For Locations {:?}\"\u003c/span\u003e, query_result);\n    }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e fn \u003cspan class=\"hljs-title function_\"\u003equery_sessions\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003epool: Pool\u0026#x3C;Postgres\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e query_result = \u003cspan class=\"hljs-attr\"\u003esqlx\u003c/span\u003e::query_as!(\u003cspan class=\"hljs-title class_\"\u003eSessions\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"SELECT * FROM Sessions\"\u003c/span\u003e)\n        .\u003cspan class=\"hljs-title function_\"\u003efetch_all\u003c/span\u003e(\u0026#x26;pool)\n        .\u003cspan class=\"hljs-property\"\u003eawait\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e query_result.\u003cspan class=\"hljs-title function_\"\u003eis_err\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n        \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e message = \u003cspan class=\"hljs-string\"\u003e\"Something bad happened while fetching all sessions\"\u003c/span\u003e;\n        error!(\u003cspan class=\"hljs-string\"\u003e\"{}\"\u003c/span\u003e, message);\n    } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n        info!(\u003cspan class=\"hljs-string\"\u003e\"😎Query Result for Sessions {:?}\"\u003c/span\u003e, query_result);\n    }\n}\n\n#[\u003cspan class=\"hljs-attr\"\u003etokio\u003c/span\u003e::main]\n\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e fn \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003estd\u003c/span\u003e::\u003cspan class=\"hljs-attr\"\u003eenv\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003evar_os\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"RUST_LOG\"\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003eis_none\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n        \u003cspan class=\"hljs-attr\"\u003estd\u003c/span\u003e::\u003cspan class=\"hljs-attr\"\u003eenv\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003eset_var\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"RUST_LOG\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"info\"\u003c/span\u003e);\n    }\n    \u003cspan class=\"hljs-title function_\"\u003edotenv\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003eok\u003c/span\u003e();\n    \u003cspan class=\"hljs-attr\"\u003eenv_logger\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003einit\u003c/span\u003e();\n\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e database_url = \u003cspan class=\"hljs-attr\"\u003estd\u003c/span\u003e::\u003cspan class=\"hljs-attr\"\u003eenv\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003evar\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"DATABASE_URL\"\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003eexpect\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"DATABASE_URL must be set\"\u003c/span\u003e);\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e pool = match \u003cspan class=\"hljs-title class_\"\u003ePgPoolOptions\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003enew\u003c/span\u003e()\n        .\u003cspan class=\"hljs-title function_\"\u003emax_connections\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e)\n        .\u003cspan class=\"hljs-title function_\"\u003econnect\u003c/span\u003e(\u0026#x26;database_url)\n        .\u003cspan class=\"hljs-property\"\u003eawait\u003c/span\u003e\n    {\n        \u003cspan class=\"hljs-title class_\"\u003eOk\u003c/span\u003e(pool) =\u003e {\n            info!(\u003cspan class=\"hljs-string\"\u003e\"✅Connection to the database is successful!\"\u003c/span\u003e);\n            pool\n        }\n        \u003cspan class=\"hljs-title class_\"\u003eErr\u003c/span\u003e(err) =\u003e {\n            error!(\u003cspan class=\"hljs-string\"\u003e\"🔥 Failed to connect to the database: {:?}\"\u003c/span\u003e, err);\n            \u003cspan class=\"hljs-attr\"\u003estd\u003c/span\u003e::\u003cspan class=\"hljs-attr\"\u003eprocess\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003eexit\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\n        }\n    };\n    \u003cspan class=\"hljs-title function_\"\u003eclean_db\u003c/span\u003e(pool.\u003cspan class=\"hljs-title function_\"\u003eclone\u003c/span\u003e()).\u003cspan class=\"hljs-property\"\u003eawait\u003c/span\u003e;\n\n    \u003cspan class=\"hljs-title function_\"\u003einsert_into_locations\u003c/span\u003e(pool.\u003cspan class=\"hljs-title function_\"\u003eclone\u003c/span\u003e()).\u003cspan class=\"hljs-property\"\u003eawait\u003c/span\u003e;\n    \u003cspan class=\"hljs-title function_\"\u003equery_locations\u003c/span\u003e(pool.\u003cspan class=\"hljs-title function_\"\u003eclone\u003c/span\u003e()).\u003cspan class=\"hljs-property\"\u003eawait\u003c/span\u003e;\n\n    \u003cspan class=\"hljs-title function_\"\u003einsert_into_sessions\u003c/span\u003e(pool.\u003cspan class=\"hljs-title function_\"\u003eclone\u003c/span\u003e()).\u003cspan class=\"hljs-property\"\u003eawait\u003c/span\u003e;\n    \u003cspan class=\"hljs-title function_\"\u003equery_sessions\u003c/span\u003e(pool.\u003cspan class=\"hljs-title function_\"\u003eclone\u003c/span\u003e()).\u003cspan class=\"hljs-property\"\u003eawait\u003c/span\u003e;\n\n    \u003cspan class=\"hljs-title function_\"\u003eupdate_sessions\u003c/span\u003e(pool.\u003cspan class=\"hljs-title function_\"\u003eclone\u003c/span\u003e()).\u003cspan class=\"hljs-property\"\u003eawait\u003c/span\u003e;\n    \u003cspan class=\"hljs-title function_\"\u003equery_sessions\u003c/span\u003e(pool.\u003cspan class=\"hljs-title function_\"\u003eclone\u003c/span\u003e()).\u003cspan class=\"hljs-property\"\u003eawait\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 애플리케이션을 실행한 결과는 다음과 같습니다.\u003c/p\u003e\n\u003cimg src=\"/assets/img/2024-05-23-LearningRustPart11BuildersandDatabaseInteraction_5.png\"\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e위와 같이 데이터베이스 상호작용 토론을 마쳤습니다. sqlx를 사용하여 데이터베이스 작업을 수행하는 방법에 대해 좋은 개요를 제공했을 겁니다.\u003c/p\u003e\n\u003ch1\u003e요약\u003c/h1\u003e\n\u003cp\u003e저희 러스트 학습 시리즈의 이 부분을 즐기셨기를 바랍니다. 시리즈 이번 섹션에서는 먼저 러스트에서 객체 생성에 대한 매우 유용한 패턴인 빌더 패턴을 살펴보았습니다. 이는 다른 언어에서 익숙할 수 있지만, 러스트에서 어떻게 구현하는지 살펴보았습니다.\u003c/p\u003e\n\u003cp\u003e다음으로, 우리는 Rust를 사용하여 데이터베이스인 특히 Postgres와 상호작용하는 방법을 검토했습니다. 우리는 마이그레이션을 실행하고 데이터베이스에 연결하는 방법을 보았으며, 그 후 DB에 대해 여러 가지 CRUD 작업을 수행하는 방법을 살펴보았습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e러스트 학습 여정에 함께해줘서 고마워요.\u003c/p\u003e\n\u003cp\u003e좋은 여행 되세요!\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-23-LearningRustPart11BuildersandDatabaseInteraction"},"buildId":"wfHLuDA3kTGBYfaM5IGXk","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>