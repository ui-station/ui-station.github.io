<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>서버리스 EventBridge Pipes로 이벤트 처리하는 방법 최신 2024 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-06-23-ServerlessEventBridgePipes" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="서버리스 EventBridge Pipes로 이벤트 처리하는 방법 최신 2024 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="서버리스 EventBridge Pipes로 이벤트 처리하는 방법 최신 2024 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-23-ServerlessEventBridgePipes_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-06-23-ServerlessEventBridgePipes" data-gatsby-head="true"/><meta name="twitter:title" content="서버리스 EventBridge Pipes로 이벤트 처리하는 방법 최신 2024 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-23-ServerlessEventBridgePipes_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-23 22:26" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-4f7b40c1114f0d09.js" defer=""></script><script src="/_next/static/-dPCbnM2yhdKNgXe92VJV/_buildManifest.js" defer=""></script><script src="/_next/static/-dPCbnM2yhdKNgXe92VJV/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">서버리스 EventBridge Pipes로 이벤트 처리하는 방법 최신 2024</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="서버리스 EventBridge Pipes로 이벤트 처리하는 방법 최신 2024" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 23, 2024</span><span class="posts_reading_time__f7YPP">16<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-23-ServerlessEventBridgePipes&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<img src="/assets/img/2024-06-23-ServerlessEventBridgePipes_0.png">
<h2>안내</h2>
<p>✔️ Amazon EventBridge Pipes 및 그들이 무엇인지에 대해 논의합니다.
✔️ Python 및 AWS CDK를 사용한 예제를 통해 안내합니다.</p>
<h1>소개 👋🏽</h1>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이 기사에서는 AWS CDK와 Python을 사용하여 구축된 허구의 치과 앱을 만들어가면서 Amazon EventBridge Pipes에 대해 다뤄볼 것입니다.</p>
<p><img src="/assets/img/2024-06-23-ServerlessEventBridgePipes_1.png" alt="이미지"></p>
<p>'LJ 치과 의사' 앱은 사람들이 가장 가까운 치과 의사와 예약을 잡을 수 있는 기능을 제공합니다.</p>
<p><img src="/assets/img/2024-06-23-ServerlessEventBridgePipes_2.png" alt="이미지"></p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>그들이 이미 방문한 적이 있는 경우에는 이메일, SMS 또는 통신 없음을 보내기 전에 선호하는 연락 방법을 확인합니다. 이 모두는 Amazon EventBridge Pipes를 사용하여 처리됩니다.</p>
<p><img src="/assets/img/2024-06-23-ServerlessEventBridgePipes_3.png" alt="이미지"></p>
<p>이 기사의 전체 코드 예제는 여기에서 확인할 수 있습니다:</p>
<h1>우리가 무엇을 만들고 있나요? 🛠️</h1>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>환자들이 온라인으로 진료 예약을 할 수 있도록 다음 아키텍처를 사용할 예정입니다:</p>
<p><img src="/assets/img/2024-06-23-ServerlessEventBridgePipes_4.png" alt="아키텍처"></p>
<p>환자들이 다음을 사용하여 진료를 예약할 수 있습니다:</p>
<ul>
<li>Amazon API Gateway REST API를 사용하여 온라인으로 진료 예약을 합니다.</li>
<li>Lambda 함수가 진료 상세 내용을 DynamoDB 테이블에 기록합니다.</li>
<li>우리는 DynamoDB 스트림을 사용하여 테이블의 변경 사항을 감지하고 레코드가 생성되었을 경우에만 필터링하여 Amazon EventBridge Pipes를 통해 해당 스트림을 소스로 사용합니다.</li>
<li>일치하는 레코드가 연락처 선호도 테이블에 있는지 확인하는 Lambda 함수를 호출하여 스트림 레코드에 선호도를 추가합니다.</li>
<li>마지막으로, Amazon EventBridge Pipes의 대상은 SQS로 설정되어 진료를 처리하기 위해 준비된 예약을 저장합니다.</li>
</ul>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>👇 더 진전하기 전에 — 향후 블로그 게시물과 서버리스 뉴스를 만나보기 위해 LinkedIn에 연락해 주세요 <a href="https://www.linkedin.com/in/lee-james-gilmore/" rel="nofollow" target="_blank">https://www.linkedin.com/in/lee-james-gilmore/</a></p>
<p><img src="/assets/img/2024-06-23-ServerlessEventBridgePipes_5.png" alt="ServerlessEventBridgePipes_5"></p>
<h1>Amazon EventBridge Pipes란 무엇인가요?</h1>
<p>Amazon EventBridge Pipes는 옵션 변환, 필터 및 풍부한 단계를 통해 이벤트 생성자와 소비자 간의 포인트 투 포인트 통합을 생성하는 데 도움을 줍니다. EventBridge Pipes를 사용하면 이벤트 중심 애플리케이션을 구축할 때 필요한 통합 코드 양을 줄이고 유지할 수 있습니다. 아래 다이어그램은 우리 예시를 위해 이를 보여줍니다:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>위 다이어그램에서 알 수 있듯이 다음이 있습니다:</p>
<ul>
<li>소스로 DynamoDB 스트림을 사용합니다.</li>
<li>새로 삽입된 레코드만 받도록 추가 필터링을 수행합니다(예: 삭제 또는 업데이트 제외).</li>
<li>별도의 데이터베이스에서 연락처 정보를 읽는 enrichment Lambda 함수를 통해 스트림에서 약속 데이터를 추가 정보로 향상시킵니다.</li>
<li>최종적으로 약속 레코드를 더 처리하기 위해 SQS 대기열로 설정된 대상이 있습니다.</li>
</ul>
<p>참고로 아래에 표시된 다양한 서비스와 구성을 사용할 수 있습니다:</p>
<p><img src="/assets/img/2024-06-23-ServerlessEventBridgePipes_6.png" alt="이미지"></p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>주요 코드 설명하기 👨‍💻</h1>
<p>이제 몇 가지 주요 코드에 대해 이야기해봅시다.</p>
<p>아래에서 볼 수 있는대로 CDK 애플리케이션을 상태(Stateful) 및 상태 없음(Stateless) 리소스(스택)로 분리하기 시작합니다:</p>
<pre><code class="hljs language-js">#!<span class="hljs-regexp">/usr/</span>bin/env python3
<span class="hljs-keyword">import</span> os

<span class="hljs-keyword">import</span> aws_cdk <span class="hljs-keyword">as</span> cdk
<span class="hljs-keyword">from</span> stateful.<span class="hljs-property">stateful</span> <span class="hljs-keyword">import</span> <span class="hljs-title class_">DentistsStatefulStack</span>
<span class="hljs-keyword">from</span> stateless.<span class="hljs-property">stateless</span> <span class="hljs-keyword">import</span> <span class="hljs-title class_">DentistsStatelessStack</span>

app = cdk.<span class="hljs-title class_">App</span>()

# 앱을 상태(<span class="hljs-title class_">Stateful</span>) 및 상태 없음(<span class="hljs-title class_">Stateless</span>) 리소스로 분리합니다
<span class="hljs-title class_">DentistsStatefulStack</span>(app, <span class="hljs-string">"DentistsStatefulStack"</span>)
<span class="hljs-title class_">DentistsStatelessStack</span>(app, <span class="hljs-string">"DentistsStatelessStack"</span>)

app.<span class="hljs-title function_">synth</span>()
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>Stateful 스택을 먼저 살펴 보면, 두 개의 DynamoDB 테이블을 설정했음을 알 수 있습니다. 하나는 약속을, 다른 하나는 선호하는 연락처 세부 정보를 저장하는 테이블입니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">from</span> aws_cdk <span class="hljs-keyword">import</span> <span class="hljs-title class_">CfnOutput</span>, <span class="hljs-title class_">RemovalPolicy</span>, <span class="hljs-title class_">Stack</span>
<span class="hljs-keyword">from</span> aws_cdk <span class="hljs-keyword">import</span> aws_dynamodb <span class="hljs-keyword">as</span> dynamodb
<span class="hljs-keyword">from</span> constructs <span class="hljs-keyword">import</span> <span class="hljs-title class_">Construct</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">DentistsStatefulStack</span>(<span class="hljs-title class_">Stack</span>):

    def <span class="hljs-title function_">__init__</span>(self, <span class="hljs-attr">scope</span>: <span class="hljs-title class_">Construct</span>, <span class="hljs-attr">construct_id</span>: str, **kwargs) -> <span class="hljs-title class_">None</span>:
        <span class="hljs-variable language_">super</span>().<span class="hljs-title function_">__init__</span>(scope, construct_id, **kwargs)

        # 약속을 저장하는 <span class="hljs-title class_">DynamoDB</span> 테이블 추가 및 스트림 활성화
        table = dynamodb.<span class="hljs-title class_">Table</span>(
            self, <span class="hljs-string">'DentistTable'</span>,
            billing_mode=dynamodb.<span class="hljs-property">BillingMode</span>.<span class="hljs-property">PAY_PER_REQUEST</span>,
            table_name=<span class="hljs-string">'DentistTable'</span>,
            stream=dynamodb.<span class="hljs-property">StreamViewType</span>.<span class="hljs-property">NEW_IMAGE</span>,
            removal_policy=<span class="hljs-title class_">RemovalPolicy</span>.<span class="hljs-property">DESTROY</span>,
            partition_key=dynamodb.<span class="hljs-title class_">Attribute</span>(
                name=<span class="hljs-string">'id'</span>,
                type=dynamodb.<span class="hljs-property">AttributeType</span>.<span class="hljs-property">STRING</span>
            )
        )

        # 이메일 주소를 기반으로 하는 연락 선호도 <span class="hljs-title class_">DynamoDB</span> 테이블 추가
        contact_table = dynamodb.<span class="hljs-title class_">Table</span>(
            self, <span class="hljs-string">'DentistContactsTable'</span>,
            billing_mode=dynamodb.<span class="hljs-property">BillingMode</span>.<span class="hljs-property">PAY_PER_REQUEST</span>,
            table_name=<span class="hljs-string">'DentistContactsTable'</span>,
            removal_policy=<span class="hljs-title class_">RemovalPolicy</span>.<span class="hljs-property">DESTROY</span>,
            partition_key=dynamodb.<span class="hljs-title class_">Attribute</span>(
                name=<span class="hljs-string">'id'</span>,
                type=dynamodb.<span class="hljs-property">AttributeType</span>.<span class="hljs-property">STRING</span>
            )
        )

        # 테이블 이름을 위한 스택 출력 추가
        <span class="hljs-title class_">CfnOutput</span>(
            self, <span class="hljs-string">'DentistDynamoDBTableName'</span>,
            value=table.<span class="hljs-property">table_name</span>,
            description=<span class="hljs-string">'DynamoDB 테이블 이름'</span>,
            export_name=<span class="hljs-string">'DentistDynamoDBTableName'</span>
        )

        # 연락처 테이블 이름을 위한 스택 출력 추가
        <span class="hljs-title class_">CfnOutput</span>(
            self, <span class="hljs-string">'DentistContactDynamoDBTableName'</span>,
            value=contact_table.<span class="hljs-property">table_name</span>,
            description=<span class="hljs-string">'연락 선호도 DynamoDB 테이블 이름'</span>,
            export_name=<span class="hljs-string">'DentistContactDynamoDBTableName'</span>
        )

        # 약속 테이블의 테이블 스트림 <span class="hljs-variable constant_">ARN</span>을 위한 스택 출력 추가
        <span class="hljs-title class_">CfnOutput</span>(
            self, <span class="hljs-string">'DentistDynamoDBTableStreamArn'</span>,
            value=table.<span class="hljs-property">table_stream_arn</span>,
            description=<span class="hljs-string">'DynamoDB 테이블 스트림 ARN'</span>,
            export_name=<span class="hljs-string">'DentistDynamoDBTableStreamArn'</span>
        )
</code></pre>
<p>이제 Stateful 리소스가 설정됐으므로, Stateless 스택에서 먼저 약속을 생성하는 람다 함수를 생성합니다:</p>
<pre><code class="hljs language-js"># 약속을 생성하는 람다 함수 생성
create_appointment_lambda = aws_lambda.<span class="hljs-title class_">Function</span>(
    self, <span class="hljs-string">'CreateAppointment'</span>,
    runtime=aws_lambda.<span class="hljs-property">Runtime</span>.<span class="hljs-property">PYTHON_3_12</span>,
    handler=<span class="hljs-string">'create_appointment.handler'</span>,
    code=aws_lambda.<span class="hljs-property">Code</span>.<span class="hljs-title function_">from_asset</span>(os.<span class="hljs-property">path</span>.<span class="hljs-title function_">join</span>(<span class="hljs-variable constant_">DIRNAME</span>, <span class="hljs-string">'src'</span>)),
    function_name=<span class="hljs-string">'CreateAppointment'</span>,
    environment={
        <span class="hljs-string">'dynamodb_table'</span>: dynamodb_table_name,
    },
)
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>Lambda 함수에 추가적으로 두 번째 Lambda 함수를 추가합니다. 이 함수는 DynamoDB 스트림이 제공하는 데이터를 풍부하게 하는 데 사용될 것입니다:</p>
<pre><code class="hljs language-js"># 연락처 세부 정보를 검색하는 람다 함수 생성
get_contact_details = aws_lambda.<span class="hljs-title class_">Function</span>(
    self, <span class="hljs-string">'GetContactDetails'</span>,
    runtime=aws_lambda.<span class="hljs-property">Runtime</span>.<span class="hljs-property">PYTHON_3_12</span>,
    handler=<span class="hljs-string">'get_contact_details.handler'</span>,
    code=aws_lambda.<span class="hljs-property">Code</span>.<span class="hljs-title function_">from_asset</span>(os.<span class="hljs-property">path</span>.<span class="hljs-title function_">join</span>(<span class="hljs-variable constant_">DIRNAME</span>, <span class="hljs-string">'src'</span>)),
    function_name=<span class="hljs-string">'GetContactDetails'</span>,
    environment={
        <span class="hljs-string">'contacts_dynamodb_table'</span>: contacts_dynamodb_table_name,
    },
)
</code></pre>
<p>다음으로, 우리의 파이프 대상이 될 Amazon SQS 대기열을 추가합니다:</p>
<pre><code class="hljs language-js"># <span class="hljs-title class_">AppointmentsQueue</span>로 메시지를 보낼 <span class="hljs-variable constant_">SQS</span> 대기열 생성
sqs_queue = sqs.<span class="hljs-title class_">Queue</span>(
    self, <span class="hljs-string">'AppointmentsQueue'</span>,
    queue_name=<span class="hljs-string">'AppointmentsQueue'</span>,
    removal_policy=<span class="hljs-title class_">RemovalPolicy</span>.<span class="hljs-property">DESTROY</span>
)
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>그럼 Amazon EventBridge 파이프 자체에 대한 IAM 정책을 만들어서 원본, 보강 및 대상 자원과 연결할 수 있도록합니다.</p>
<pre><code class="hljs language-js"># 파이프 원본(다이나모<span class="hljs-variable constant_">DB</span> 스트림)용 파이프 정책과 역할 생성
pipe_source_policy = iam.<span class="hljs-title class_">PolicyStatement</span>(
    actions=[
        <span class="hljs-string">'dynamodb:DescribeStream'</span>,
        <span class="hljs-string">'dynamodb:GetRecords'</span>,
        <span class="hljs-string">'dynamodb:GetShardIterator'</span>,
        <span class="hljs-string">'dynamodb:ListStreams'</span>
    ],
    resources=[stream_arn],
    effect=iam.<span class="hljs-property">Effect</span>.<span class="hljs-property">ALLOW</span>
)

# 파이프 대상(<span class="hljs-variable constant_">SQS</span>)으로 메시지를 게시하는 것을 허용하는 대상 정책 작성
pipe_target_policy = iam.<span class="hljs-title class_">PolicyStatement</span>(
    actions=[<span class="hljs-string">'sqs:SendMessage'</span>],
    resources=[sqs_queue.<span class="hljs-property">queue_arn</span>],
    effect=iam.<span class="hljs-property">Effect</span>.<span class="hljs-property">ALLOW</span>
)

# 파이프가 람다 기능을 호출할 수 있도록 하는 보강 정책 생성
pipe_enrichment_policy = iam.<span class="hljs-title class_">PolicyStatement</span>(
    actions=[<span class="hljs-string">'lambda:InvokeFunction'</span>],
    resources=[get_contact_details.<span class="hljs-property">function_arn</span>],
    effect=iam.<span class="hljs-property">Effect</span>.<span class="hljs-property">ALLOW</span>
)

# 파이프 역할 생성
pipe_role = iam.<span class="hljs-title class_">Role</span>(self, <span class="hljs-string">'PipeRole'</span>,
    assumed_by=iam.<span class="hljs-title class_">ServicePrincipal</span>(<span class="hljs-string">'pipes.amazonaws.com'</span>),
)

# 역할에 세 가지 정책 추가
pipe_role.<span class="hljs-title function_">add_to_policy</span>(pipe_source_policy)
pipe_role.<span class="hljs-title function_">add_to_policy</span>(pipe_target_policy)
pipe_role.<span class="hljs-title function_">add_to_policy</span>(pipe_enrichment_policy)
</code></pre>
<p>이제 다음과 같은 코드를 사용하여 파이프를 생성할 수 있습니다:</p>
<pre><code class="hljs language-js"># 다이나모<span class="hljs-variable constant_">DB</span>의 새 항목에 대한 필터가 있는 이벤트브릿지 파이프 생성
pipe = pipes.<span class="hljs-title class_">CfnPipe</span>(self, <span class="hljs-string">'Pipe'</span>,
    role_arn=pipe_role.<span class="hljs-property">role_arn</span>,
    source=stream_arn,
    log_configuration=pipes.<span class="hljs-property">CfnPipe</span>.<span class="hljs-title class_">PipeLogConfigurationProperty</span>(
        cloudwatch_logs_log_destination=pipes.<span class="hljs-property">CfnPipe</span>.<span class="hljs-title class_">CloudwatchLogsLogDestinationProperty</span>(
            log_group_arn=log_group.<span class="hljs-property">log_group_arn</span>
        ),
        level=<span class="hljs-string">'INFO'</span>,
    ),
    name=<span class="hljs-string">'DentistPipe'</span>,
    source_parameters=pipes.<span class="hljs-property">CfnPipe</span>.<span class="hljs-title class_">PipeSourceParametersProperty</span>(
        dynamo_db_stream_parameters=pipes.<span class="hljs-property">CfnPipe</span>.<span class="hljs-title class_">PipeSourceDynamoDBStreamParametersProperty</span>(
            starting_position=<span class="hljs-string">'LATEST'</span>,
        ),
        filter_criteria=pipes.<span class="hljs-property">CfnPipe</span>.<span class="hljs-title class_">FilterCriteriaProperty</span>(
            filters=[pipes.<span class="hljs-property">CfnPipe</span>.<span class="hljs-title class_">FilterProperty</span>(
                pattern=json.<span class="hljs-title function_">dumps</span>({<span class="hljs-string">'eventName'</span>: [{ <span class="hljs-string">'prefix'</span>: <span class="hljs-string">'INSERT'</span> }])
            )]
        ),
    ),
    enrichment=get_contact_details.<span class="hljs-property">function_arn</span>,
    target=sqs_queue.<span class="hljs-property">queue_arn</span>,
)
pipe.<span class="hljs-title function_">apply_removal_policy</span>(<span class="hljs-title class_">RemovalPolicy</span>.<span class="hljs-property">DESTROY</span>)
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>현재 인프라가 모두 설정되어 있지만 'create_appointment.py' 파일을 시작으로 Lambda 함수 코드를 간단히 살펴보겠습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> json
<span class="hljs-keyword">import</span> os
<span class="hljs-keyword">import</span> uuid
<span class="hljs-keyword">from</span> http <span class="hljs-keyword">import</span> <span class="hljs-title class_">HTTPStatus</span>

<span class="hljs-keyword">import</span> boto3
<span class="hljs-keyword">from</span> boto3.<span class="hljs-property">dynamodb</span>.<span class="hljs-property">types</span> <span class="hljs-keyword">import</span> <span class="hljs-title class_">TypeSerializer</span>

dynamodb_table = os.<span class="hljs-title function_">getenv</span>(<span class="hljs-string">'dynamodb_table'</span>)
dynamodb_client = boto3.<span class="hljs-title function_">client</span>(<span class="hljs-string">'dynamodb'</span>)
serializer = <span class="hljs-title class_">TypeSerializer</span>()

def <span class="hljs-title function_">handler</span>(event, context):
    <span class="hljs-attr">try</span>:
        # 이벤트에서 요청 데이터를 구문 분석하고 본문을 가져옵니다.
        request_data = json.<span class="hljs-title function_">loads</span>(event[<span class="hljs-string">'body'</span>])

        # uuidv4를 사용하여 새로운 약속 <span class="hljs-variable constant_">ID</span>를 추가합니다.
        request_data[<span class="hljs-string">'id'</span>] = <span class="hljs-title function_">str</span>(uuid.<span class="hljs-title function_">uuid4</span>())

        # 페이로드를 dynamodb 형식으로 직렬화합니다.
        appointment_data = {<span class="hljs-attr">k</span>: serializer.<span class="hljs-title function_">serialize</span>(v) <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> request_data.<span class="hljs-title function_">items</span>()}

        # 항목을 dynamodb 테이블에 추가합니다.
        dynamodb_client.<span class="hljs-title function_">put_item</span>(<span class="hljs-title class_">TableName</span>=dynamodb_table, <span class="hljs-title class_">Item</span>=appointment_data)

        body = {
            <span class="hljs-string">'message'</span>: request_data,
            <span class="hljs-string">'statusCode'</span>: <span class="hljs-title class_">HTTPStatus</span>.<span class="hljs-property">CREATED</span>,
        }

        # 응답을 올바른 형식으로 <span class="hljs-variable constant_">API</span> <span class="hljs-title class_">Gateway</span>로 전송합니다.
        response = {
            <span class="hljs-string">'statusCode'</span>: <span class="hljs-title class_">HTTPStatus</span>.<span class="hljs-property">CREATED</span>,
            <span class="hljs-string">'body'</span>: json.<span class="hljs-title function_">dumps</span>(body, indent=<span class="hljs-number">2</span>),
            <span class="hljs-string">'headers'</span>: {
                <span class="hljs-string">'content-type'</span>: <span class="hljs-string">'application/json'</span>,
            },
        }

    except <span class="hljs-title class_">Exception</span> <span class="hljs-keyword">as</span> <span class="hljs-attr">e</span>:
        response = {
            <span class="hljs-string">'statusCode'</span>: <span class="hljs-title class_">HTTPStatus</span>.<span class="hljs-property">INTERNAL_SERVER_ERROR</span>.<span class="hljs-property">value</span>,
            <span class="hljs-string">'body'</span>: f<span class="hljs-string">'Exception={e}'</span>,
        }

    <span class="hljs-keyword">return</span> response
</code></pre>
<p>위 코드에서 볼 수 있듯, API Gateway 이벤트에서 약속을 가져와 새로운 고유 ID(uuid)를 추가하고 레코드를 약속 테이블에 기록하는 기본 함수를 생성합니다.</p>
<p>테이블에 레코드가 추가되면 스트림이 호출되어 모든 레코드 변경에 대해 파이프가 변경 사항을 소스로 가져올 것입니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>그 다음으로, 파이프의 일부로 호출되는 Enrichment 람다 함수를 살펴보겠습니다:</p>
<p>위 코드에서 볼 수 있듯이, 스트림 레코드에서 email_address 속성을 가져와 우리가 선호하는 연락처 DynamoDB 테이블에서 조회합니다. 레코드가 존재하면, 선호하는 방법을 가져와 약속 레코드에 추가합니다. 일치하는 레코드가 없으면, preferredMethod를 'none'으로 추가합니다.</p>
<p>엔드 투 엔드로 테스트하려면, 애플리케이션을 배포하고 Contacts DynamoDb 테이블에 다음 항목을 추가하면 preferredMethod를 추가할 수 있습니다:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"id"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"john.doe@example.com"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"preferredMethod"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"email"</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p>만약 레코드가 존재하지 않는다면 이전에 언급한 대로 'none'으로 기본 설정됩니다.</p>
<h1>결론</h1>
<p>Amazon EventBridge 파이프를 사용하는 실제 예시로 서버리스 솔루션에서의 사용법을 보여드려 유용하게 찾으셨기를 희망합니다. 파이프를 사용하면 이전에 사용해야 했던 람다 접착 코드를 제거할 수 있고 소스에서 데이터를 추출하여 해당 데이터를 타깃으로 전달하는 훌륭한 방법을 제공합니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>마무리 👋🏽</h1>
<p>이 글을 즐겁게 보았으면 공유하고 피드백을 남겨주세요!</p>
<p>비슷한 콘텐츠를 더 보시려면 제 YouTube 채널을 구독해주세요!</p>
<img src="/assets/img/2024-06-23-ServerlessEventBridgePipes_7.png">
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>당신과 어느 하나라도 다음에서도 연결하고 싶어요:</p>
<ul>
<li><a href="https://www.linkedin.com/in/lee-james-gilmore/" rel="nofollow" target="_blank">LinkedIn</a></li>
<li><a href="https://twitter.com/LeeJamesGilmore" rel="nofollow" target="_blank">Twitter</a></li>
</ul>
<p>포스트를 즐겼다면 추가로 포스트/시리즈를 보기 위해 내 프로필 Lee James Gilmore를 팔로우해주세요. 그리고 인사를 건네고 싶다면 절대 잊지 말고 연락해주세요 👋</p>
<p>좋았다면 포스트 하단에 있는 '박수' 기능을 사용해주세요! (한 번 이상 박수를 칠 수 있어요!!)</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>제 소개</h1>
<p>안녕하세요, 저는 영국에 거주하고 있는 AWS 커뮤니티 빌더이자 블로거인 Lee입니다. AWS 인증 클라우드 아키텍트이며 City Electrical Factors (UK) 및 City Electric Supply (US)에서 글로벌 기술 및 아키텍처 책임자로 일하고 있습니다. 지난 6년간 주로 AWS에서 풀스택 JavaScript를 사용해 왔습니다.</p>
<p>저는 서버리스를 지지하는 사람으로, AWS, 혁신, 소프트웨어 아키텍처, 기술에 대한 애정이 있습니다.</p>
<p><strong>_ 제공된 정보는 제 개인적인 견해이며 해당 정보 사용에 대한 책임을 지지 않습니다. _</strong></p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>아래 내용도 참고하시면 좋을 것 같아요:</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"서버리스 EventBridge Pipes로 이벤트 처리하는 방법 최신 2024","description":"","date":"2024-06-23 22:26","slug":"2024-06-23-ServerlessEventBridgePipes","content":"\n\u003cimg src=\"/assets/img/2024-06-23-ServerlessEventBridgePipes_0.png\" /\u003e\n\n## 안내\n\n✔️ Amazon EventBridge Pipes 및 그들이 무엇인지에 대해 논의합니다.\n✔️ Python 및 AWS CDK를 사용한 예제를 통해 안내합니다.\n\n# 소개 👋🏽\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 기사에서는 AWS CDK와 Python을 사용하여 구축된 허구의 치과 앱을 만들어가면서 Amazon EventBridge Pipes에 대해 다뤄볼 것입니다.\n\n![이미지](/assets/img/2024-06-23-ServerlessEventBridgePipes_1.png)\n\n'LJ 치과 의사' 앱은 사람들이 가장 가까운 치과 의사와 예약을 잡을 수 있는 기능을 제공합니다.\n\n![이미지](/assets/img/2024-06-23-ServerlessEventBridgePipes_2.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그들이 이미 방문한 적이 있는 경우에는 이메일, SMS 또는 통신 없음을 보내기 전에 선호하는 연락 방법을 확인합니다. 이 모두는 Amazon EventBridge Pipes를 사용하여 처리됩니다.\n\n![이미지](/assets/img/2024-06-23-ServerlessEventBridgePipes_3.png)\n\n이 기사의 전체 코드 예제는 여기에서 확인할 수 있습니다:\n\n# 우리가 무엇을 만들고 있나요? 🛠️\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n환자들이 온라인으로 진료 예약을 할 수 있도록 다음 아키텍처를 사용할 예정입니다:\n\n![아키텍처](/assets/img/2024-06-23-ServerlessEventBridgePipes_4.png)\n\n환자들이 다음을 사용하여 진료를 예약할 수 있습니다:\n\n- Amazon API Gateway REST API를 사용하여 온라인으로 진료 예약을 합니다.\n- Lambda 함수가 진료 상세 내용을 DynamoDB 테이블에 기록합니다.\n- 우리는 DynamoDB 스트림을 사용하여 테이블의 변경 사항을 감지하고 레코드가 생성되었을 경우에만 필터링하여 Amazon EventBridge Pipes를 통해 해당 스트림을 소스로 사용합니다.\n- 일치하는 레코드가 연락처 선호도 테이블에 있는지 확인하는 Lambda 함수를 호출하여 스트림 레코드에 선호도를 추가합니다.\n- 마지막으로, Amazon EventBridge Pipes의 대상은 SQS로 설정되어 진료를 처리하기 위해 준비된 예약을 저장합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n👇 더 진전하기 전에 — 향후 블로그 게시물과 서버리스 뉴스를 만나보기 위해 LinkedIn에 연락해 주세요 https://www.linkedin.com/in/lee-james-gilmore/\n\n![ServerlessEventBridgePipes_5](/assets/img/2024-06-23-ServerlessEventBridgePipes_5.png)\n\n# Amazon EventBridge Pipes란 무엇인가요?\n\nAmazon EventBridge Pipes는 옵션 변환, 필터 및 풍부한 단계를 통해 이벤트 생성자와 소비자 간의 포인트 투 포인트 통합을 생성하는 데 도움을 줍니다. EventBridge Pipes를 사용하면 이벤트 중심 애플리케이션을 구축할 때 필요한 통합 코드 양을 줄이고 유지할 수 있습니다. 아래 다이어그램은 우리 예시를 위해 이를 보여줍니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위 다이어그램에서 알 수 있듯이 다음이 있습니다:\n\n- 소스로 DynamoDB 스트림을 사용합니다.\n- 새로 삽입된 레코드만 받도록 추가 필터링을 수행합니다(예: 삭제 또는 업데이트 제외).\n- 별도의 데이터베이스에서 연락처 정보를 읽는 enrichment Lambda 함수를 통해 스트림에서 약속 데이터를 추가 정보로 향상시킵니다.\n- 최종적으로 약속 레코드를 더 처리하기 위해 SQS 대기열로 설정된 대상이 있습니다.\n\n참고로 아래에 표시된 다양한 서비스와 구성을 사용할 수 있습니다:\n\n![이미지](/assets/img/2024-06-23-ServerlessEventBridgePipes_6.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 주요 코드 설명하기 👨‍💻\n\n이제 몇 가지 주요 코드에 대해 이야기해봅시다.\n\n아래에서 볼 수 있는대로 CDK 애플리케이션을 상태(Stateful) 및 상태 없음(Stateless) 리소스(스택)로 분리하기 시작합니다:\n\n```js\n#!/usr/bin/env python3\nimport os\n\nimport aws_cdk as cdk\nfrom stateful.stateful import DentistsStatefulStack\nfrom stateless.stateless import DentistsStatelessStack\n\napp = cdk.App()\n\n# 앱을 상태(Stateful) 및 상태 없음(Stateless) 리소스로 분리합니다\nDentistsStatefulStack(app, \"DentistsStatefulStack\")\nDentistsStatelessStack(app, \"DentistsStatelessStack\")\n\napp.synth()\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nStateful 스택을 먼저 살펴 보면, 두 개의 DynamoDB 테이블을 설정했음을 알 수 있습니다. 하나는 약속을, 다른 하나는 선호하는 연락처 세부 정보를 저장하는 테이블입니다:\n\n```js\nfrom aws_cdk import CfnOutput, RemovalPolicy, Stack\nfrom aws_cdk import aws_dynamodb as dynamodb\nfrom constructs import Construct\n\nclass DentistsStatefulStack(Stack):\n\n    def __init__(self, scope: Construct, construct_id: str, **kwargs) -\u003e None:\n        super().__init__(scope, construct_id, **kwargs)\n\n        # 약속을 저장하는 DynamoDB 테이블 추가 및 스트림 활성화\n        table = dynamodb.Table(\n            self, 'DentistTable',\n            billing_mode=dynamodb.BillingMode.PAY_PER_REQUEST,\n            table_name='DentistTable',\n            stream=dynamodb.StreamViewType.NEW_IMAGE,\n            removal_policy=RemovalPolicy.DESTROY,\n            partition_key=dynamodb.Attribute(\n                name='id',\n                type=dynamodb.AttributeType.STRING\n            )\n        )\n\n        # 이메일 주소를 기반으로 하는 연락 선호도 DynamoDB 테이블 추가\n        contact_table = dynamodb.Table(\n            self, 'DentistContactsTable',\n            billing_mode=dynamodb.BillingMode.PAY_PER_REQUEST,\n            table_name='DentistContactsTable',\n            removal_policy=RemovalPolicy.DESTROY,\n            partition_key=dynamodb.Attribute(\n                name='id',\n                type=dynamodb.AttributeType.STRING\n            )\n        )\n\n        # 테이블 이름을 위한 스택 출력 추가\n        CfnOutput(\n            self, 'DentistDynamoDBTableName',\n            value=table.table_name,\n            description='DynamoDB 테이블 이름',\n            export_name='DentistDynamoDBTableName'\n        )\n\n        # 연락처 테이블 이름을 위한 스택 출력 추가\n        CfnOutput(\n            self, 'DentistContactDynamoDBTableName',\n            value=contact_table.table_name,\n            description='연락 선호도 DynamoDB 테이블 이름',\n            export_name='DentistContactDynamoDBTableName'\n        )\n\n        # 약속 테이블의 테이블 스트림 ARN을 위한 스택 출력 추가\n        CfnOutput(\n            self, 'DentistDynamoDBTableStreamArn',\n            value=table.table_stream_arn,\n            description='DynamoDB 테이블 스트림 ARN',\n            export_name='DentistDynamoDBTableStreamArn'\n        )\n```\n\n이제 Stateful 리소스가 설정됐으므로, Stateless 스택에서 먼저 약속을 생성하는 람다 함수를 생성합니다:\n\n```js\n# 약속을 생성하는 람다 함수 생성\ncreate_appointment_lambda = aws_lambda.Function(\n    self, 'CreateAppointment',\n    runtime=aws_lambda.Runtime.PYTHON_3_12,\n    handler='create_appointment.handler',\n    code=aws_lambda.Code.from_asset(os.path.join(DIRNAME, 'src')),\n    function_name='CreateAppointment',\n    environment={\n        'dynamodb_table': dynamodb_table_name,\n    },\n)\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nLambda 함수에 추가적으로 두 번째 Lambda 함수를 추가합니다. 이 함수는 DynamoDB 스트림이 제공하는 데이터를 풍부하게 하는 데 사용될 것입니다:\n\n```js\n# 연락처 세부 정보를 검색하는 람다 함수 생성\nget_contact_details = aws_lambda.Function(\n    self, 'GetContactDetails',\n    runtime=aws_lambda.Runtime.PYTHON_3_12,\n    handler='get_contact_details.handler',\n    code=aws_lambda.Code.from_asset(os.path.join(DIRNAME, 'src')),\n    function_name='GetContactDetails',\n    environment={\n        'contacts_dynamodb_table': contacts_dynamodb_table_name,\n    },\n)\n```\n\n다음으로, 우리의 파이프 대상이 될 Amazon SQS 대기열을 추가합니다:\n\n```js\n# AppointmentsQueue로 메시지를 보낼 SQS 대기열 생성\nsqs_queue = sqs.Queue(\n    self, 'AppointmentsQueue',\n    queue_name='AppointmentsQueue',\n    removal_policy=RemovalPolicy.DESTROY\n)\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그럼 Amazon EventBridge 파이프 자체에 대한 IAM 정책을 만들어서 원본, 보강 및 대상 자원과 연결할 수 있도록합니다.\n\n```js\n# 파이프 원본(다이나모DB 스트림)용 파이프 정책과 역할 생성\npipe_source_policy = iam.PolicyStatement(\n    actions=[\n        'dynamodb:DescribeStream',\n        'dynamodb:GetRecords',\n        'dynamodb:GetShardIterator',\n        'dynamodb:ListStreams'\n    ],\n    resources=[stream_arn],\n    effect=iam.Effect.ALLOW\n)\n\n# 파이프 대상(SQS)으로 메시지를 게시하는 것을 허용하는 대상 정책 작성\npipe_target_policy = iam.PolicyStatement(\n    actions=['sqs:SendMessage'],\n    resources=[sqs_queue.queue_arn],\n    effect=iam.Effect.ALLOW\n)\n\n# 파이프가 람다 기능을 호출할 수 있도록 하는 보강 정책 생성\npipe_enrichment_policy = iam.PolicyStatement(\n    actions=['lambda:InvokeFunction'],\n    resources=[get_contact_details.function_arn],\n    effect=iam.Effect.ALLOW\n)\n\n# 파이프 역할 생성\npipe_role = iam.Role(self, 'PipeRole',\n    assumed_by=iam.ServicePrincipal('pipes.amazonaws.com'),\n)\n\n# 역할에 세 가지 정책 추가\npipe_role.add_to_policy(pipe_source_policy)\npipe_role.add_to_policy(pipe_target_policy)\npipe_role.add_to_policy(pipe_enrichment_policy)\n```\n\n이제 다음과 같은 코드를 사용하여 파이프를 생성할 수 있습니다:\n\n```js\n# 다이나모DB의 새 항목에 대한 필터가 있는 이벤트브릿지 파이프 생성\npipe = pipes.CfnPipe(self, 'Pipe',\n    role_arn=pipe_role.role_arn,\n    source=stream_arn,\n    log_configuration=pipes.CfnPipe.PipeLogConfigurationProperty(\n        cloudwatch_logs_log_destination=pipes.CfnPipe.CloudwatchLogsLogDestinationProperty(\n            log_group_arn=log_group.log_group_arn\n        ),\n        level='INFO',\n    ),\n    name='DentistPipe',\n    source_parameters=pipes.CfnPipe.PipeSourceParametersProperty(\n        dynamo_db_stream_parameters=pipes.CfnPipe.PipeSourceDynamoDBStreamParametersProperty(\n            starting_position='LATEST',\n        ),\n        filter_criteria=pipes.CfnPipe.FilterCriteriaProperty(\n            filters=[pipes.CfnPipe.FilterProperty(\n                pattern=json.dumps({'eventName': [{ 'prefix': 'INSERT' }])\n            )]\n        ),\n    ),\n    enrichment=get_contact_details.function_arn,\n    target=sqs_queue.queue_arn,\n)\npipe.apply_removal_policy(RemovalPolicy.DESTROY)\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n현재 인프라가 모두 설정되어 있지만 'create_appointment.py' 파일을 시작으로 Lambda 함수 코드를 간단히 살펴보겠습니다.\n\n```js\nimport json\nimport os\nimport uuid\nfrom http import HTTPStatus\n\nimport boto3\nfrom boto3.dynamodb.types import TypeSerializer\n\ndynamodb_table = os.getenv('dynamodb_table')\ndynamodb_client = boto3.client('dynamodb')\nserializer = TypeSerializer()\n\ndef handler(event, context):\n    try:\n        # 이벤트에서 요청 데이터를 구문 분석하고 본문을 가져옵니다.\n        request_data = json.loads(event['body'])\n\n        # uuidv4를 사용하여 새로운 약속 ID를 추가합니다.\n        request_data['id'] = str(uuid.uuid4())\n\n        # 페이로드를 dynamodb 형식으로 직렬화합니다.\n        appointment_data = {k: serializer.serialize(v) for k, v in request_data.items()}\n\n        # 항목을 dynamodb 테이블에 추가합니다.\n        dynamodb_client.put_item(TableName=dynamodb_table, Item=appointment_data)\n\n        body = {\n            'message': request_data,\n            'statusCode': HTTPStatus.CREATED,\n        }\n\n        # 응답을 올바른 형식으로 API Gateway로 전송합니다.\n        response = {\n            'statusCode': HTTPStatus.CREATED,\n            'body': json.dumps(body, indent=2),\n            'headers': {\n                'content-type': 'application/json',\n            },\n        }\n\n    except Exception as e:\n        response = {\n            'statusCode': HTTPStatus.INTERNAL_SERVER_ERROR.value,\n            'body': f'Exception={e}',\n        }\n\n    return response\n```\n\n위 코드에서 볼 수 있듯, API Gateway 이벤트에서 약속을 가져와 새로운 고유 ID(uuid)를 추가하고 레코드를 약속 테이블에 기록하는 기본 함수를 생성합니다.\n\n테이블에 레코드가 추가되면 스트림이 호출되어 모든 레코드 변경에 대해 파이프가 변경 사항을 소스로 가져올 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그 다음으로, 파이프의 일부로 호출되는 Enrichment 람다 함수를 살펴보겠습니다:\n\n위 코드에서 볼 수 있듯이, 스트림 레코드에서 email_address 속성을 가져와 우리가 선호하는 연락처 DynamoDB 테이블에서 조회합니다. 레코드가 존재하면, 선호하는 방법을 가져와 약속 레코드에 추가합니다. 일치하는 레코드가 없으면, preferredMethod를 'none'으로 추가합니다.\n\n엔드 투 엔드로 테스트하려면, 애플리케이션을 배포하고 Contacts DynamoDb 테이블에 다음 항목을 추가하면 preferredMethod를 추가할 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```json\n{\n  \"id\": \"john.doe@example.com\",\n  \"preferredMethod\": \"email\"\n}\n```\n\n만약 레코드가 존재하지 않는다면 이전에 언급한 대로 'none'으로 기본 설정됩니다.\n\n# 결론\n\nAmazon EventBridge 파이프를 사용하는 실제 예시로 서버리스 솔루션에서의 사용법을 보여드려 유용하게 찾으셨기를 희망합니다. 파이프를 사용하면 이전에 사용해야 했던 람다 접착 코드를 제거할 수 있고 소스에서 데이터를 추출하여 해당 데이터를 타깃으로 전달하는 훌륭한 방법을 제공합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 마무리 👋🏽\n\n이 글을 즐겁게 보았으면 공유하고 피드백을 남겨주세요!\n\n비슷한 콘텐츠를 더 보시려면 제 YouTube 채널을 구독해주세요!\n\n\u003cimg src=\"/assets/img/2024-06-23-ServerlessEventBridgePipes_7.png\" /\u003e\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n당신과 어느 하나라도 다음에서도 연결하고 싶어요:\n\n- [LinkedIn](https://www.linkedin.com/in/lee-james-gilmore/)\n- [Twitter](https://twitter.com/LeeJamesGilmore)\n\n포스트를 즐겼다면 추가로 포스트/시리즈를 보기 위해 내 프로필 Lee James Gilmore를 팔로우해주세요. 그리고 인사를 건네고 싶다면 절대 잊지 말고 연락해주세요 👋\n\n좋았다면 포스트 하단에 있는 '박수' 기능을 사용해주세요! (한 번 이상 박수를 칠 수 있어요!!)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 제 소개\n\n안녕하세요, 저는 영국에 거주하고 있는 AWS 커뮤니티 빌더이자 블로거인 Lee입니다. AWS 인증 클라우드 아키텍트이며 City Electrical Factors (UK) 및 City Electric Supply (US)에서 글로벌 기술 및 아키텍처 책임자로 일하고 있습니다. 지난 6년간 주로 AWS에서 풀스택 JavaScript를 사용해 왔습니다.\n\n저는 서버리스를 지지하는 사람으로, AWS, 혁신, 소프트웨어 아키텍처, 기술에 대한 애정이 있습니다.\n\n**_ 제공된 정보는 제 개인적인 견해이며 해당 정보 사용에 대한 책임을 지지 않습니다. _**\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래 내용도 참고하시면 좋을 것 같아요:\n","ogImage":{"url":"/assets/img/2024-06-23-ServerlessEventBridgePipes_0.png"},"coverImage":"/assets/img/2024-06-23-ServerlessEventBridgePipes_0.png","tag":["Tech"],"readingTime":16},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cimg src=\"/assets/img/2024-06-23-ServerlessEventBridgePipes_0.png\"\u003e\n\u003ch2\u003e안내\u003c/h2\u003e\n\u003cp\u003e✔️ Amazon EventBridge Pipes 및 그들이 무엇인지에 대해 논의합니다.\n✔️ Python 및 AWS CDK를 사용한 예제를 통해 안내합니다.\u003c/p\u003e\n\u003ch1\u003e소개 👋🏽\u003c/h1\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이 기사에서는 AWS CDK와 Python을 사용하여 구축된 허구의 치과 앱을 만들어가면서 Amazon EventBridge Pipes에 대해 다뤄볼 것입니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-ServerlessEventBridgePipes_1.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e'LJ 치과 의사' 앱은 사람들이 가장 가까운 치과 의사와 예약을 잡을 수 있는 기능을 제공합니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-ServerlessEventBridgePipes_2.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e그들이 이미 방문한 적이 있는 경우에는 이메일, SMS 또는 통신 없음을 보내기 전에 선호하는 연락 방법을 확인합니다. 이 모두는 Amazon EventBridge Pipes를 사용하여 처리됩니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-ServerlessEventBridgePipes_3.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e이 기사의 전체 코드 예제는 여기에서 확인할 수 있습니다:\u003c/p\u003e\n\u003ch1\u003e우리가 무엇을 만들고 있나요? 🛠️\u003c/h1\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e환자들이 온라인으로 진료 예약을 할 수 있도록 다음 아키텍처를 사용할 예정입니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-ServerlessEventBridgePipes_4.png\" alt=\"아키텍처\"\u003e\u003c/p\u003e\n\u003cp\u003e환자들이 다음을 사용하여 진료를 예약할 수 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eAmazon API Gateway REST API를 사용하여 온라인으로 진료 예약을 합니다.\u003c/li\u003e\n\u003cli\u003eLambda 함수가 진료 상세 내용을 DynamoDB 테이블에 기록합니다.\u003c/li\u003e\n\u003cli\u003e우리는 DynamoDB 스트림을 사용하여 테이블의 변경 사항을 감지하고 레코드가 생성되었을 경우에만 필터링하여 Amazon EventBridge Pipes를 통해 해당 스트림을 소스로 사용합니다.\u003c/li\u003e\n\u003cli\u003e일치하는 레코드가 연락처 선호도 테이블에 있는지 확인하는 Lambda 함수를 호출하여 스트림 레코드에 선호도를 추가합니다.\u003c/li\u003e\n\u003cli\u003e마지막으로, Amazon EventBridge Pipes의 대상은 SQS로 설정되어 진료를 처리하기 위해 준비된 예약을 저장합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e👇 더 진전하기 전에 — 향후 블로그 게시물과 서버리스 뉴스를 만나보기 위해 LinkedIn에 연락해 주세요 \u003ca href=\"https://www.linkedin.com/in/lee-james-gilmore/\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://www.linkedin.com/in/lee-james-gilmore/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-ServerlessEventBridgePipes_5.png\" alt=\"ServerlessEventBridgePipes_5\"\u003e\u003c/p\u003e\n\u003ch1\u003eAmazon EventBridge Pipes란 무엇인가요?\u003c/h1\u003e\n\u003cp\u003eAmazon EventBridge Pipes는 옵션 변환, 필터 및 풍부한 단계를 통해 이벤트 생성자와 소비자 간의 포인트 투 포인트 통합을 생성하는 데 도움을 줍니다. EventBridge Pipes를 사용하면 이벤트 중심 애플리케이션을 구축할 때 필요한 통합 코드 양을 줄이고 유지할 수 있습니다. 아래 다이어그램은 우리 예시를 위해 이를 보여줍니다:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e위 다이어그램에서 알 수 있듯이 다음이 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e소스로 DynamoDB 스트림을 사용합니다.\u003c/li\u003e\n\u003cli\u003e새로 삽입된 레코드만 받도록 추가 필터링을 수행합니다(예: 삭제 또는 업데이트 제외).\u003c/li\u003e\n\u003cli\u003e별도의 데이터베이스에서 연락처 정보를 읽는 enrichment Lambda 함수를 통해 스트림에서 약속 데이터를 추가 정보로 향상시킵니다.\u003c/li\u003e\n\u003cli\u003e최종적으로 약속 레코드를 더 처리하기 위해 SQS 대기열로 설정된 대상이 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e참고로 아래에 표시된 다양한 서비스와 구성을 사용할 수 있습니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-ServerlessEventBridgePipes_6.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e주요 코드 설명하기 👨‍💻\u003c/h1\u003e\n\u003cp\u003e이제 몇 가지 주요 코드에 대해 이야기해봅시다.\u003c/p\u003e\n\u003cp\u003e아래에서 볼 수 있는대로 CDK 애플리케이션을 상태(Stateful) 및 상태 없음(Stateless) 리소스(스택)로 분리하기 시작합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e#!\u003cspan class=\"hljs-regexp\"\u003e/usr/\u003c/span\u003ebin/env python3\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e os\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e aws_cdk \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e cdk\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e stateful.\u003cspan class=\"hljs-property\"\u003estateful\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDentistsStatefulStack\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e stateless.\u003cspan class=\"hljs-property\"\u003estateless\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDentistsStatelessStack\u003c/span\u003e\n\napp = cdk.\u003cspan class=\"hljs-title class_\"\u003eApp\u003c/span\u003e()\n\n# 앱을 상태(\u003cspan class=\"hljs-title class_\"\u003eStateful\u003c/span\u003e) 및 상태 없음(\u003cspan class=\"hljs-title class_\"\u003eStateless\u003c/span\u003e) 리소스로 분리합니다\n\u003cspan class=\"hljs-title class_\"\u003eDentistsStatefulStack\u003c/span\u003e(app, \u003cspan class=\"hljs-string\"\u003e\"DentistsStatefulStack\"\u003c/span\u003e)\n\u003cspan class=\"hljs-title class_\"\u003eDentistsStatelessStack\u003c/span\u003e(app, \u003cspan class=\"hljs-string\"\u003e\"DentistsStatelessStack\"\u003c/span\u003e)\n\napp.\u003cspan class=\"hljs-title function_\"\u003esynth\u003c/span\u003e()\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eStateful 스택을 먼저 살펴 보면, 두 개의 DynamoDB 테이블을 설정했음을 알 수 있습니다. 하나는 약속을, 다른 하나는 선호하는 연락처 세부 정보를 저장하는 테이블입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e aws_cdk \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eCfnOutput\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eRemovalPolicy\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eStack\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e aws_cdk \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e aws_dynamodb \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e dynamodb\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e constructs \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eConstruct\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDentistsStatefulStack\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eStack\u003c/span\u003e):\n\n    def \u003cspan class=\"hljs-title function_\"\u003e__init__\u003c/span\u003e(self, \u003cspan class=\"hljs-attr\"\u003escope\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eConstruct\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003econstruct_id\u003c/span\u003e: str, **kwargs) -\u003e \u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e:\n        \u003cspan class=\"hljs-variable language_\"\u003esuper\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003e__init__\u003c/span\u003e(scope, construct_id, **kwargs)\n\n        # 약속을 저장하는 \u003cspan class=\"hljs-title class_\"\u003eDynamoDB\u003c/span\u003e 테이블 추가 및 스트림 활성화\n        table = dynamodb.\u003cspan class=\"hljs-title class_\"\u003eTable\u003c/span\u003e(\n            self, \u003cspan class=\"hljs-string\"\u003e'DentistTable'\u003c/span\u003e,\n            billing_mode=dynamodb.\u003cspan class=\"hljs-property\"\u003eBillingMode\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ePAY_PER_REQUEST\u003c/span\u003e,\n            table_name=\u003cspan class=\"hljs-string\"\u003e'DentistTable'\u003c/span\u003e,\n            stream=dynamodb.\u003cspan class=\"hljs-property\"\u003eStreamViewType\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eNEW_IMAGE\u003c/span\u003e,\n            removal_policy=\u003cspan class=\"hljs-title class_\"\u003eRemovalPolicy\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eDESTROY\u003c/span\u003e,\n            partition_key=dynamodb.\u003cspan class=\"hljs-title class_\"\u003eAttribute\u003c/span\u003e(\n                name=\u003cspan class=\"hljs-string\"\u003e'id'\u003c/span\u003e,\n                type=dynamodb.\u003cspan class=\"hljs-property\"\u003eAttributeType\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eSTRING\u003c/span\u003e\n            )\n        )\n\n        # 이메일 주소를 기반으로 하는 연락 선호도 \u003cspan class=\"hljs-title class_\"\u003eDynamoDB\u003c/span\u003e 테이블 추가\n        contact_table = dynamodb.\u003cspan class=\"hljs-title class_\"\u003eTable\u003c/span\u003e(\n            self, \u003cspan class=\"hljs-string\"\u003e'DentistContactsTable'\u003c/span\u003e,\n            billing_mode=dynamodb.\u003cspan class=\"hljs-property\"\u003eBillingMode\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ePAY_PER_REQUEST\u003c/span\u003e,\n            table_name=\u003cspan class=\"hljs-string\"\u003e'DentistContactsTable'\u003c/span\u003e,\n            removal_policy=\u003cspan class=\"hljs-title class_\"\u003eRemovalPolicy\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eDESTROY\u003c/span\u003e,\n            partition_key=dynamodb.\u003cspan class=\"hljs-title class_\"\u003eAttribute\u003c/span\u003e(\n                name=\u003cspan class=\"hljs-string\"\u003e'id'\u003c/span\u003e,\n                type=dynamodb.\u003cspan class=\"hljs-property\"\u003eAttributeType\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eSTRING\u003c/span\u003e\n            )\n        )\n\n        # 테이블 이름을 위한 스택 출력 추가\n        \u003cspan class=\"hljs-title class_\"\u003eCfnOutput\u003c/span\u003e(\n            self, \u003cspan class=\"hljs-string\"\u003e'DentistDynamoDBTableName'\u003c/span\u003e,\n            value=table.\u003cspan class=\"hljs-property\"\u003etable_name\u003c/span\u003e,\n            description=\u003cspan class=\"hljs-string\"\u003e'DynamoDB 테이블 이름'\u003c/span\u003e,\n            export_name=\u003cspan class=\"hljs-string\"\u003e'DentistDynamoDBTableName'\u003c/span\u003e\n        )\n\n        # 연락처 테이블 이름을 위한 스택 출력 추가\n        \u003cspan class=\"hljs-title class_\"\u003eCfnOutput\u003c/span\u003e(\n            self, \u003cspan class=\"hljs-string\"\u003e'DentistContactDynamoDBTableName'\u003c/span\u003e,\n            value=contact_table.\u003cspan class=\"hljs-property\"\u003etable_name\u003c/span\u003e,\n            description=\u003cspan class=\"hljs-string\"\u003e'연락 선호도 DynamoDB 테이블 이름'\u003c/span\u003e,\n            export_name=\u003cspan class=\"hljs-string\"\u003e'DentistContactDynamoDBTableName'\u003c/span\u003e\n        )\n\n        # 약속 테이블의 테이블 스트림 \u003cspan class=\"hljs-variable constant_\"\u003eARN\u003c/span\u003e을 위한 스택 출력 추가\n        \u003cspan class=\"hljs-title class_\"\u003eCfnOutput\u003c/span\u003e(\n            self, \u003cspan class=\"hljs-string\"\u003e'DentistDynamoDBTableStreamArn'\u003c/span\u003e,\n            value=table.\u003cspan class=\"hljs-property\"\u003etable_stream_arn\u003c/span\u003e,\n            description=\u003cspan class=\"hljs-string\"\u003e'DynamoDB 테이블 스트림 ARN'\u003c/span\u003e,\n            export_name=\u003cspan class=\"hljs-string\"\u003e'DentistDynamoDBTableStreamArn'\u003c/span\u003e\n        )\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 Stateful 리소스가 설정됐으므로, Stateless 스택에서 먼저 약속을 생성하는 람다 함수를 생성합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 약속을 생성하는 람다 함수 생성\ncreate_appointment_lambda = aws_lambda.\u003cspan class=\"hljs-title class_\"\u003eFunction\u003c/span\u003e(\n    self, \u003cspan class=\"hljs-string\"\u003e'CreateAppointment'\u003c/span\u003e,\n    runtime=aws_lambda.\u003cspan class=\"hljs-property\"\u003eRuntime\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ePYTHON_3_12\u003c/span\u003e,\n    handler=\u003cspan class=\"hljs-string\"\u003e'create_appointment.handler'\u003c/span\u003e,\n    code=aws_lambda.\u003cspan class=\"hljs-property\"\u003eCode\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efrom_asset\u003c/span\u003e(os.\u003cspan class=\"hljs-property\"\u003epath\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ejoin\u003c/span\u003e(\u003cspan class=\"hljs-variable constant_\"\u003eDIRNAME\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'src'\u003c/span\u003e)),\n    function_name=\u003cspan class=\"hljs-string\"\u003e'CreateAppointment'\u003c/span\u003e,\n    environment={\n        \u003cspan class=\"hljs-string\"\u003e'dynamodb_table'\u003c/span\u003e: dynamodb_table_name,\n    },\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eLambda 함수에 추가적으로 두 번째 Lambda 함수를 추가합니다. 이 함수는 DynamoDB 스트림이 제공하는 데이터를 풍부하게 하는 데 사용될 것입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 연락처 세부 정보를 검색하는 람다 함수 생성\nget_contact_details = aws_lambda.\u003cspan class=\"hljs-title class_\"\u003eFunction\u003c/span\u003e(\n    self, \u003cspan class=\"hljs-string\"\u003e'GetContactDetails'\u003c/span\u003e,\n    runtime=aws_lambda.\u003cspan class=\"hljs-property\"\u003eRuntime\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ePYTHON_3_12\u003c/span\u003e,\n    handler=\u003cspan class=\"hljs-string\"\u003e'get_contact_details.handler'\u003c/span\u003e,\n    code=aws_lambda.\u003cspan class=\"hljs-property\"\u003eCode\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efrom_asset\u003c/span\u003e(os.\u003cspan class=\"hljs-property\"\u003epath\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ejoin\u003c/span\u003e(\u003cspan class=\"hljs-variable constant_\"\u003eDIRNAME\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'src'\u003c/span\u003e)),\n    function_name=\u003cspan class=\"hljs-string\"\u003e'GetContactDetails'\u003c/span\u003e,\n    environment={\n        \u003cspan class=\"hljs-string\"\u003e'contacts_dynamodb_table'\u003c/span\u003e: contacts_dynamodb_table_name,\n    },\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다음으로, 우리의 파이프 대상이 될 Amazon SQS 대기열을 추가합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# \u003cspan class=\"hljs-title class_\"\u003eAppointmentsQueue\u003c/span\u003e로 메시지를 보낼 \u003cspan class=\"hljs-variable constant_\"\u003eSQS\u003c/span\u003e 대기열 생성\nsqs_queue = sqs.\u003cspan class=\"hljs-title class_\"\u003eQueue\u003c/span\u003e(\n    self, \u003cspan class=\"hljs-string\"\u003e'AppointmentsQueue'\u003c/span\u003e,\n    queue_name=\u003cspan class=\"hljs-string\"\u003e'AppointmentsQueue'\u003c/span\u003e,\n    removal_policy=\u003cspan class=\"hljs-title class_\"\u003eRemovalPolicy\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eDESTROY\u003c/span\u003e\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e그럼 Amazon EventBridge 파이프 자체에 대한 IAM 정책을 만들어서 원본, 보강 및 대상 자원과 연결할 수 있도록합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 파이프 원본(다이나모\u003cspan class=\"hljs-variable constant_\"\u003eDB\u003c/span\u003e 스트림)용 파이프 정책과 역할 생성\npipe_source_policy = iam.\u003cspan class=\"hljs-title class_\"\u003ePolicyStatement\u003c/span\u003e(\n    actions=[\n        \u003cspan class=\"hljs-string\"\u003e'dynamodb:DescribeStream'\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e'dynamodb:GetRecords'\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e'dynamodb:GetShardIterator'\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e'dynamodb:ListStreams'\u003c/span\u003e\n    ],\n    resources=[stream_arn],\n    effect=iam.\u003cspan class=\"hljs-property\"\u003eEffect\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eALLOW\u003c/span\u003e\n)\n\n# 파이프 대상(\u003cspan class=\"hljs-variable constant_\"\u003eSQS\u003c/span\u003e)으로 메시지를 게시하는 것을 허용하는 대상 정책 작성\npipe_target_policy = iam.\u003cspan class=\"hljs-title class_\"\u003ePolicyStatement\u003c/span\u003e(\n    actions=[\u003cspan class=\"hljs-string\"\u003e'sqs:SendMessage'\u003c/span\u003e],\n    resources=[sqs_queue.\u003cspan class=\"hljs-property\"\u003equeue_arn\u003c/span\u003e],\n    effect=iam.\u003cspan class=\"hljs-property\"\u003eEffect\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eALLOW\u003c/span\u003e\n)\n\n# 파이프가 람다 기능을 호출할 수 있도록 하는 보강 정책 생성\npipe_enrichment_policy = iam.\u003cspan class=\"hljs-title class_\"\u003ePolicyStatement\u003c/span\u003e(\n    actions=[\u003cspan class=\"hljs-string\"\u003e'lambda:InvokeFunction'\u003c/span\u003e],\n    resources=[get_contact_details.\u003cspan class=\"hljs-property\"\u003efunction_arn\u003c/span\u003e],\n    effect=iam.\u003cspan class=\"hljs-property\"\u003eEffect\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eALLOW\u003c/span\u003e\n)\n\n# 파이프 역할 생성\npipe_role = iam.\u003cspan class=\"hljs-title class_\"\u003eRole\u003c/span\u003e(self, \u003cspan class=\"hljs-string\"\u003e'PipeRole'\u003c/span\u003e,\n    assumed_by=iam.\u003cspan class=\"hljs-title class_\"\u003eServicePrincipal\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'pipes.amazonaws.com'\u003c/span\u003e),\n)\n\n# 역할에 세 가지 정책 추가\npipe_role.\u003cspan class=\"hljs-title function_\"\u003eadd_to_policy\u003c/span\u003e(pipe_source_policy)\npipe_role.\u003cspan class=\"hljs-title function_\"\u003eadd_to_policy\u003c/span\u003e(pipe_target_policy)\npipe_role.\u003cspan class=\"hljs-title function_\"\u003eadd_to_policy\u003c/span\u003e(pipe_enrichment_policy)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 다음과 같은 코드를 사용하여 파이프를 생성할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 다이나모\u003cspan class=\"hljs-variable constant_\"\u003eDB\u003c/span\u003e의 새 항목에 대한 필터가 있는 이벤트브릿지 파이프 생성\npipe = pipes.\u003cspan class=\"hljs-title class_\"\u003eCfnPipe\u003c/span\u003e(self, \u003cspan class=\"hljs-string\"\u003e'Pipe'\u003c/span\u003e,\n    role_arn=pipe_role.\u003cspan class=\"hljs-property\"\u003erole_arn\u003c/span\u003e,\n    source=stream_arn,\n    log_configuration=pipes.\u003cspan class=\"hljs-property\"\u003eCfnPipe\u003c/span\u003e.\u003cspan class=\"hljs-title class_\"\u003ePipeLogConfigurationProperty\u003c/span\u003e(\n        cloudwatch_logs_log_destination=pipes.\u003cspan class=\"hljs-property\"\u003eCfnPipe\u003c/span\u003e.\u003cspan class=\"hljs-title class_\"\u003eCloudwatchLogsLogDestinationProperty\u003c/span\u003e(\n            log_group_arn=log_group.\u003cspan class=\"hljs-property\"\u003elog_group_arn\u003c/span\u003e\n        ),\n        level=\u003cspan class=\"hljs-string\"\u003e'INFO'\u003c/span\u003e,\n    ),\n    name=\u003cspan class=\"hljs-string\"\u003e'DentistPipe'\u003c/span\u003e,\n    source_parameters=pipes.\u003cspan class=\"hljs-property\"\u003eCfnPipe\u003c/span\u003e.\u003cspan class=\"hljs-title class_\"\u003ePipeSourceParametersProperty\u003c/span\u003e(\n        dynamo_db_stream_parameters=pipes.\u003cspan class=\"hljs-property\"\u003eCfnPipe\u003c/span\u003e.\u003cspan class=\"hljs-title class_\"\u003ePipeSourceDynamoDBStreamParametersProperty\u003c/span\u003e(\n            starting_position=\u003cspan class=\"hljs-string\"\u003e'LATEST'\u003c/span\u003e,\n        ),\n        filter_criteria=pipes.\u003cspan class=\"hljs-property\"\u003eCfnPipe\u003c/span\u003e.\u003cspan class=\"hljs-title class_\"\u003eFilterCriteriaProperty\u003c/span\u003e(\n            filters=[pipes.\u003cspan class=\"hljs-property\"\u003eCfnPipe\u003c/span\u003e.\u003cspan class=\"hljs-title class_\"\u003eFilterProperty\u003c/span\u003e(\n                pattern=json.\u003cspan class=\"hljs-title function_\"\u003edumps\u003c/span\u003e({\u003cspan class=\"hljs-string\"\u003e'eventName'\u003c/span\u003e: [{ \u003cspan class=\"hljs-string\"\u003e'prefix'\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'INSERT'\u003c/span\u003e }])\n            )]\n        ),\n    ),\n    enrichment=get_contact_details.\u003cspan class=\"hljs-property\"\u003efunction_arn\u003c/span\u003e,\n    target=sqs_queue.\u003cspan class=\"hljs-property\"\u003equeue_arn\u003c/span\u003e,\n)\npipe.\u003cspan class=\"hljs-title function_\"\u003eapply_removal_policy\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eRemovalPolicy\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eDESTROY\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e현재 인프라가 모두 설정되어 있지만 'create_appointment.py' 파일을 시작으로 Lambda 함수 코드를 간단히 살펴보겠습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e json\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e os\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e uuid\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e http \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eHTTPStatus\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e boto3\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e boto3.\u003cspan class=\"hljs-property\"\u003edynamodb\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003etypes\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTypeSerializer\u003c/span\u003e\n\ndynamodb_table = os.\u003cspan class=\"hljs-title function_\"\u003egetenv\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'dynamodb_table'\u003c/span\u003e)\ndynamodb_client = boto3.\u003cspan class=\"hljs-title function_\"\u003eclient\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'dynamodb'\u003c/span\u003e)\nserializer = \u003cspan class=\"hljs-title class_\"\u003eTypeSerializer\u003c/span\u003e()\n\ndef \u003cspan class=\"hljs-title function_\"\u003ehandler\u003c/span\u003e(event, context):\n    \u003cspan class=\"hljs-attr\"\u003etry\u003c/span\u003e:\n        # 이벤트에서 요청 데이터를 구문 분석하고 본문을 가져옵니다.\n        request_data = json.\u003cspan class=\"hljs-title function_\"\u003eloads\u003c/span\u003e(event[\u003cspan class=\"hljs-string\"\u003e'body'\u003c/span\u003e])\n\n        # uuidv4를 사용하여 새로운 약속 \u003cspan class=\"hljs-variable constant_\"\u003eID\u003c/span\u003e를 추가합니다.\n        request_data[\u003cspan class=\"hljs-string\"\u003e'id'\u003c/span\u003e] = \u003cspan class=\"hljs-title function_\"\u003estr\u003c/span\u003e(uuid.\u003cspan class=\"hljs-title function_\"\u003euuid4\u003c/span\u003e())\n\n        # 페이로드를 dynamodb 형식으로 직렬화합니다.\n        appointment_data = {\u003cspan class=\"hljs-attr\"\u003ek\u003c/span\u003e: serializer.\u003cspan class=\"hljs-title function_\"\u003eserialize\u003c/span\u003e(v) \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e k, v \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e request_data.\u003cspan class=\"hljs-title function_\"\u003eitems\u003c/span\u003e()}\n\n        # 항목을 dynamodb 테이블에 추가합니다.\n        dynamodb_client.\u003cspan class=\"hljs-title function_\"\u003eput_item\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eTableName\u003c/span\u003e=dynamodb_table, \u003cspan class=\"hljs-title class_\"\u003eItem\u003c/span\u003e=appointment_data)\n\n        body = {\n            \u003cspan class=\"hljs-string\"\u003e'message'\u003c/span\u003e: request_data,\n            \u003cspan class=\"hljs-string\"\u003e'statusCode'\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eHTTPStatus\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eCREATED\u003c/span\u003e,\n        }\n\n        # 응답을 올바른 형식으로 \u003cspan class=\"hljs-variable constant_\"\u003eAPI\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eGateway\u003c/span\u003e로 전송합니다.\n        response = {\n            \u003cspan class=\"hljs-string\"\u003e'statusCode'\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eHTTPStatus\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eCREATED\u003c/span\u003e,\n            \u003cspan class=\"hljs-string\"\u003e'body'\u003c/span\u003e: json.\u003cspan class=\"hljs-title function_\"\u003edumps\u003c/span\u003e(body, indent=\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e),\n            \u003cspan class=\"hljs-string\"\u003e'headers'\u003c/span\u003e: {\n                \u003cspan class=\"hljs-string\"\u003e'content-type'\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'application/json'\u003c/span\u003e,\n            },\n        }\n\n    except \u003cspan class=\"hljs-title class_\"\u003eException\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ee\u003c/span\u003e:\n        response = {\n            \u003cspan class=\"hljs-string\"\u003e'statusCode'\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eHTTPStatus\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eINTERNAL_SERVER_ERROR\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e,\n            \u003cspan class=\"hljs-string\"\u003e'body'\u003c/span\u003e: f\u003cspan class=\"hljs-string\"\u003e'Exception={e}'\u003c/span\u003e,\n        }\n\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e response\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 코드에서 볼 수 있듯, API Gateway 이벤트에서 약속을 가져와 새로운 고유 ID(uuid)를 추가하고 레코드를 약속 테이블에 기록하는 기본 함수를 생성합니다.\u003c/p\u003e\n\u003cp\u003e테이블에 레코드가 추가되면 스트림이 호출되어 모든 레코드 변경에 대해 파이프가 변경 사항을 소스로 가져올 것입니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e그 다음으로, 파이프의 일부로 호출되는 Enrichment 람다 함수를 살펴보겠습니다:\u003c/p\u003e\n\u003cp\u003e위 코드에서 볼 수 있듯이, 스트림 레코드에서 email_address 속성을 가져와 우리가 선호하는 연락처 DynamoDB 테이블에서 조회합니다. 레코드가 존재하면, 선호하는 방법을 가져와 약속 레코드에 추가합니다. 일치하는 레코드가 없으면, preferredMethod를 'none'으로 추가합니다.\u003c/p\u003e\n\u003cp\u003e엔드 투 엔드로 테스트하려면, 애플리케이션을 배포하고 Contacts DynamoDb 테이블에 다음 항목을 추가하면 preferredMethod를 추가할 수 있습니다:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-json\"\u003e\u003cspan class=\"hljs-punctuation\"\u003e{\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003e\"id\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"john.doe@example.com\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003e\"preferredMethod\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"email\"\u003c/span\u003e\n\u003cspan class=\"hljs-punctuation\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e만약 레코드가 존재하지 않는다면 이전에 언급한 대로 'none'으로 기본 설정됩니다.\u003c/p\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003eAmazon EventBridge 파이프를 사용하는 실제 예시로 서버리스 솔루션에서의 사용법을 보여드려 유용하게 찾으셨기를 희망합니다. 파이프를 사용하면 이전에 사용해야 했던 람다 접착 코드를 제거할 수 있고 소스에서 데이터를 추출하여 해당 데이터를 타깃으로 전달하는 훌륭한 방법을 제공합니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e마무리 👋🏽\u003c/h1\u003e\n\u003cp\u003e이 글을 즐겁게 보았으면 공유하고 피드백을 남겨주세요!\u003c/p\u003e\n\u003cp\u003e비슷한 콘텐츠를 더 보시려면 제 YouTube 채널을 구독해주세요!\u003c/p\u003e\n\u003cimg src=\"/assets/img/2024-06-23-ServerlessEventBridgePipes_7.png\"\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e당신과 어느 하나라도 다음에서도 연결하고 싶어요:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.linkedin.com/in/lee-james-gilmore/\" rel=\"nofollow\" target=\"_blank\"\u003eLinkedIn\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://twitter.com/LeeJamesGilmore\" rel=\"nofollow\" target=\"_blank\"\u003eTwitter\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e포스트를 즐겼다면 추가로 포스트/시리즈를 보기 위해 내 프로필 Lee James Gilmore를 팔로우해주세요. 그리고 인사를 건네고 싶다면 절대 잊지 말고 연락해주세요 👋\u003c/p\u003e\n\u003cp\u003e좋았다면 포스트 하단에 있는 '박수' 기능을 사용해주세요! (한 번 이상 박수를 칠 수 있어요!!)\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e제 소개\u003c/h1\u003e\n\u003cp\u003e안녕하세요, 저는 영국에 거주하고 있는 AWS 커뮤니티 빌더이자 블로거인 Lee입니다. AWS 인증 클라우드 아키텍트이며 City Electrical Factors (UK) 및 City Electric Supply (US)에서 글로벌 기술 및 아키텍처 책임자로 일하고 있습니다. 지난 6년간 주로 AWS에서 풀스택 JavaScript를 사용해 왔습니다.\u003c/p\u003e\n\u003cp\u003e저는 서버리스를 지지하는 사람으로, AWS, 혁신, 소프트웨어 아키텍처, 기술에 대한 애정이 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e_ 제공된 정보는 제 개인적인 견해이며 해당 정보 사용에 대한 책임을 지지 않습니다. _\u003c/strong\u003e\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e아래 내용도 참고하시면 좋을 것 같아요:\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-23-ServerlessEventBridgePipes"},"buildId":"-dPCbnM2yhdKNgXe92VJV","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>