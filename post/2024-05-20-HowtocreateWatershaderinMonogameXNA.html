<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>모노게임 XNA에서 물 쉐이더를 만드는 방법 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-05-20-HowtocreateWatershaderinMonogameXNA" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="모노게임 XNA에서 물 쉐이더를 만드는 방법 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="모노게임 XNA에서 물 쉐이더를 만드는 방법 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-20-HowtocreateWatershaderinMonogameXNA_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-05-20-HowtocreateWatershaderinMonogameXNA" data-gatsby-head="true"/><meta name="twitter:title" content="모노게임 XNA에서 물 쉐이더를 만드는 방법 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-20-HowtocreateWatershaderinMonogameXNA_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-20 16:37" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-V5DKFTZ6BX"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-V5DKFTZ6BX');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/cd012fc8787133d0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cd012fc8787133d0.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/551-3069cf29fe274aab.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-561ae49ab5aab7f5.js" defer=""></script><script src="/_next/static/PgdIX9e0tvkvkdAmDT6qR/_buildManifest.js" defer=""></script><script src="/_next/static/PgdIX9e0tvkvkdAmDT6qR/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">모노게임 XNA에서 물 쉐이더를 만드는 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="모노게임 XNA에서 물 쉐이더를 만드는 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 20, 2024</span><span class="posts_reading_time__f7YPP">19<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-20-HowtocreateWatershaderinMonogameXNA&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><h1>소개</h1>
<p>이 기사에서는 Monogame/XNA에서 간단한 물 쉐이더를 만드는 기본 개념을 다룰 것입니다. 이 쉐이더는 플레이너 반사, 굴절, 프레넬 효과 및 반사 하이라이트를 사용할 것입니다. 작성 시점에서 Monogame 버전 3.8.1로 진행되었습니다. 자세히 살펴보고 싶다면 여기 소스 코드가 있습니다.</p>
<h1>기본 사항</h1>
<p>우리 쉐이더가 어떻게 작동하는지 더 잘 이해하기 위해 여러 단계로 나눠 설명하겠습니다:</p>
<div class="content-ad"></div>
<ul>
<li>쿼드/플랫 표면 추가하기</li>
<li>반사 및 굴절 텍스처 추가하기 (프레넬 효과를 사용하여 둘 사이의 러핑)</li>
<li>왜곡 맵을 사용하여 작은 파도 시뮬레이션하기</li>
<li>광택을 위한 노말 맵 추가하기</li>
</ul>
<h1>그리기</h1>
<p>그려지는 순서는 다음과 같습니다:</p>
<ul>
<li>굴절 그리기</li>
<li>반사 그리기</li>
<li>물 그리기</li>
<li>장면에서 다른 개체 그리기</li>
</ul>
<div class="content-ad"></div>
<p>이 순서는 원하는 시각적 효과를 달성하기 위해 각 구성 요소가 올바른 순서로 렌더링되도록합니다.</p>
<h1>코드 설정</h1>
<p>우리의 워터 쉐이더 기술을 올바르게 구현하기 위해 코드에서 몇 가지 설정을 해야합니다. 설명을 간단히하기 위해 이미 정의된 QuadPrimitive 클래스를 사용할 것입니다. 이 클래스는 정점 버퍼(법선과 텍스처 좌표에 대한 정보를 보냄)와 인덱스 버퍼를 가집니다. 또한 FreeCamera 클래스를 사용하여 카메라 이동을 처리할 것이지만 이 튜토리얼의 주요 내용은 아니기 때문에 자세히 다루지 않겠습니다.</p>
<p>먼저 우리는 우리의 쿼드, 그의 월드 매트릭스, 높이 및 파도 속도를 생성할 것입니다. 나중에는 쉐이더 매개변수에서 파도 속도를 사용할 것입니다. 또한 이 높이는 반사와 굴절을 계산하는 중요한 요소가 될 것입니다. 게다가 우리는 쉐이더를 선언할 것입니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-csharp"><span class="hljs-comment">// 카메라</span>
<span class="hljs-keyword">private</span> FreeCamera _freeCamera;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> Vector3 _cameraInitialPosition = <span class="hljs-keyword">new</span>(<span class="hljs-number">0f</span>, <span class="hljs-number">50f</span>, <span class="hljs-number">300f</span>);

<span class="hljs-comment">// 물</span>
<span class="hljs-keyword">private</span> QuadPrimitive _quad;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">float</span> QuadHeight = <span class="hljs-number">0f</span>;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">float</span> WaveSpeed = <span class="hljs-number">0.05f</span>;
<span class="hljs-keyword">private</span> Matrix _quadWorld;
<span class="hljs-keyword">private</span> Effect _waterShader;
</code></pre>
<p>아울 Initialize 메소드는 다음과 같이 보여야 합니다:</p>
<pre><code class="hljs language-csharp"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Initialize</span>()</span>
{
  _graphicsDeviceManager.PreferredBackBufferWidth = GraphicsAdapter.DefaultAdapter.CurrentDisplayMode.Width - <span class="hljs-number">100</span>;
  _graphicsDeviceManager.PreferredBackBufferHeight = GraphicsAdapter.DefaultAdapter.CurrentDisplayMode.Height - <span class="hljs-number">100</span>;
  _graphicsDeviceManager.ApplyChanges();

  <span class="hljs-comment">// 카메라</span>
  _freeCamera = <span class="hljs-keyword">new</span> FreeCamera(GraphicsDevice.Viewport.AspectRatio, _cameraInitialPosition);

  <span class="hljs-comment">// 물</span>
  _quad = <span class="hljs-keyword">new</span> QuadPrimitive(GraphicsDevice);
  <span class="hljs-keyword">var</span> quadPosition = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">0f</span>, QuadHeight, <span class="hljs-number">0f</span>);
  _quadWorld = Matrix.CreateScale(<span class="hljs-number">3000f</span>, <span class="hljs-number">0f</span>, <span class="hljs-number">3000f</span>) * Matrix.CreateTranslation(quadPosition);

  <span class="hljs-keyword">base</span>.Initialize();
}
</code></pre>
<h1>평면 반사</h1>
<div class="content-ad"></div>
<p>코드를 진행하기 전에 우리는 평면 반사가 어떻게 작동하는지 이해해야 합니다. 평면 반사의 예시를 살펴보겠습니다:</p>
<p><img src="/assets/img/2024-05-20-HowtocreateWatershaderinMonogameXNA_0.png" alt="Planar Reflection"/></p>
<p>이 예시에서 우리는 반사면, 카메라, 그리고 어떤 객체가 주어졌을 때 반사가 이렇게 보일 것이라는 것을 볼 수 있습니다. 이것을 코드로 나중에 변환하기 위해, 반사 카메라의 시각에서 새로운 뷰 매트릭스를 계산해야 합니다.</p>
<h2>반사 카메라 위치</h2>
<div class="content-ad"></div>
<p>먼저, 반사 카메라 위치를 계산하겠습니다. 이미 카메라 위치, 평면 위치 및 평면 법선을 알고 있으므로 카메라 위치에서 평면 위치를 빼면 뷰 방향 벡터를 얻을 수 있습니다:</p>
<p>뷰 방향 = 카메라 위치 - 평면 위치</p>
<p><img src="/assets/img/2024-05-20-HowtocreateWatershaderinMonogameXNA_1.png" alt="image"/></p>
<p>또한 투영 벡터를 추가했는데 이것은 다음과 같습니다. 그런 다음 해당 투영의 길이를 사용하여 평면상의 해당 지점까지의 거리를 찾을 수 있습니다.
이제 우리는 직각 삼각형을 가지고 있습니다. 투영 길이는 다음과 같아야 합니다:</p>
<div class="content-ad"></div>
<p>투영 길이 = 시야 방향 * cos(각도)</p>
<p>각도는 평면 법선과 시야 방향 사이의 각도를 의미합니다.</p>
<p>간단하게 표현하면 다음과 같이 다시 쓸 수 있습니다:</p>
<p>투영 길이 = 내적(평면 법선, 시야 방향)</p>
<div class="content-ad"></div>
<p>좋아요, 이제 우리에게는 프로젝션 길이가 있습니다. 이것을 사용하여 반사 카메라 위치를 얻을 수 있습니다:</p>
<p>반사 카메라 위치 = 카메라 위치 — 2 * 평면 법선 * 프로젝션 길이</p>
<h2>반사 카메라 뷰 매트릭스</h2>
<p>반사 카메라 뷰 매트릭스를 얻으려면 반사 카메라 포워드를 계산해야 합니다. 함수 Reflect(vector, normal)를 사용하여 특정 법선을 갖는 표면에서 벡터의 반사를 얻을 수 있습니다.</p>
<div class="content-ad"></div>
<p>카메라 반사 벡터를 계산한 후, Reflection Camera Up을 계산하는 다음 단계입니다. 카메라의 위쪽 벡터를 반사면의 법선을 기준으로 반사하는 Vector3.Reflect 함수를 다시 사용할 것입니다.</p>
<p>Reflection Camera Up = Vector3.Reflect(Camera Up, Plane Normal)</p>
<p>Reflection Camera Position, Reflection Camera Forward 및 Reflection Camera Up 벡터가 모두 계산되었으므로 이제 Reflection Camera View Matrix를 구성하는 데 필요한 모든 구성 요소를 갖추게 되었습니다.</p>
<div class="content-ad"></div>
<p>리플렉션 카메라 뷰 = Matrix.CreateLookAt(리플렉션 카메라 위치, 리플렉션 카메라 위치 + 리플렉션 카메라 전방, 리플렉션 카메라 위치)</p>
<h1>리플렉션 그리기</h1>
<p>이제 리플렉션 카메라 뷰 행렬의 필요 구성 요소를 계산했으므로, 일반적으로 RenderTarget2D와 같은 텍스처에 리플렉션을 그릴 수 있습니다. 이를 위해 코드에서 이전에 계산한 값을 렌더링 프로세스에 통합할 수 있습니다. 다음 코드 조각은 이를 어떻게 달성할 수 있는지 보여줍니다:</p>
<pre><code class="hljs language-js">private <span class="hljs-keyword">void</span> <span class="hljs-title class_">DrawReflection</span>(<span class="hljs-title class_">Matrix</span> world, <span class="hljs-title class_">Matrix</span> view, <span class="hljs-title class_">Matrix</span> projection, <span class="hljs-title class_">GameTime</span> gameTime)
{
    <span class="hljs-comment">// 렌더 타겟을 리플렉션 텍스처로 설정</span>
    <span class="hljs-title class_">GraphicsDevice</span>.<span class="hljs-title class_">SetRenderTarget</span>(_reflectionRenderTarget);
    <span class="hljs-title class_">GraphicsDevice</span>.<span class="hljs-title class_">Clear</span>(<span class="hljs-title class_">ClearOptions</span>.<span class="hljs-property">Target</span> | 
    <span class="hljs-title class_">ClearOptions</span>.<span class="hljs-property">DepthBuffer</span>, <span class="hljs-title class_">Color</span>.<span class="hljs-property">CornflowerBlue</span>, 1f, <span class="hljs-number">0</span>);
            
    <span class="hljs-keyword">var</span> quadNormal = <span class="hljs-title class_">Vector3</span>.<span class="hljs-property">Up</span>;         
    <span class="hljs-keyword">var</span> viewDirection = _freeCamera.<span class="hljs-property">Position</span> - _quadWorld.<span class="hljs-property">Translation</span>;       
    <span class="hljs-keyword">var</span> projLength = <span class="hljs-title class_">Vector3</span>.<span class="hljs-title class_">Dot</span>(quadNormal, viewDirection);
    <span class="hljs-keyword">var</span> reflectionCamPos = _freeCamera.<span class="hljs-property">Position</span> - <span class="hljs-number">2</span> * quadNormal * projLength;
    <span class="hljs-keyword">var</span> reflectionCamForward = <span class="hljs-title class_">Vector3</span>.<span class="hljs-title class_">Reflect</span>(_freeCamera.<span class="hljs-property">FrontDirection</span>, 
    quadNormal);
    <span class="hljs-keyword">var</span> reflectionCamUp = <span class="hljs-title class_">Vector3</span>.<span class="hljs-title class_">Reflect</span>(_freeCamera.<span class="hljs-property">UpDirection</span>, quadNormal);  
    <span class="hljs-keyword">var</span> reflectionCamView = <span class="hljs-title class_">Matrix</span>.<span class="hljs-title class_">CreateLookAt</span>(reflectionCamPos, 
                reflectionCamPos + reflectionCamForward, reflectionCamUp);
    
    <span class="hljs-comment">// 리플렉션 카메라 시점에서 씬 그리기</span>
    <span class="hljs-title class_">DrawScene</span>(reflectionCamView, projection, reflectionCamPos, 
    _reflectionClippingPlane);
    
    <span class="hljs-comment">// 렌더 타겟을 기본(화면)으로 재설정</span>
    <span class="hljs-title class_">GraphicsDevice</span>.<span class="hljs-title class_">SetRenderTarget</span>(<span class="hljs-literal">null</span>);
         
    <span class="hljs-comment">// 물 그리기</span>
    <span class="hljs-title class_">DrawWater</span>(world, view, projection, reflectionCamView, gameTime);
}
</code></pre>
<div class="content-ad"></div>
<p>DrawWater 메서드에서는 필요한 매개변수를 전달할 것이며, 이에 대해 나중에 자세히 다룰 것입니다.</p>
<h2>클리핑 평면</h2>
<p>클리핑 평면 _reflectionClippingPlane이 아직 설명되지 않았다는 것을 눈치채셨나요? 그 목적에 대해 자세히 살펴보겠습니다. 이 클리핑 평면은 수면 위에 있는 객체만 그릴 때 사용됩니다. 이를 통해 객체의 상단 반만이 물에 반사되어 실제 반사에서 관찰되는 것과 동일하게 됩니다. 다음과 같이 선언할 수 있습니다:</p>
<pre><code class="hljs language-js">private readonly <span class="hljs-title class_">Vector4</span> _reflectionClippingPlane = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vector4</span>(0f, 1f, 0f, -<span class="hljs-title class_">QuadHeight</span>);
</code></pre>
<div class="content-ad"></div>
<p>이 평면은 수학적 방정식 (Ax + By + Cz + D = 0)으로 정의됩니다. 여기서 (A, B, C)는 평면에 수직인 법선 벡터를 나타내고, D는 해당 법선 벡터를 따라 원점으로부터의 거리를 나타냅니다.</p>
<p>우리의 경우, 물 표면은 XZ 평면과 평행한 평면으로 작용하며, 그 법선 벡터는 직접 위쪽을 가리킵니다 (0, 1, 0).</p>
<p>우리는 물 속 객체를 다루는 셰이더를 위해 반사 클리핑 평면 방정식에 -QuadHeight 값을 활용합니다. 이 값은 나중에 픽셀 셰이더에서 clip 함수를 사용하여 Reflection Plane 아래의 픽셀을 클리핑할 때 사용됩니다. 다음은 예시입니다:</p>
<p><em>Uniforms</em></p>
<pre><code class="hljs language-js">float4 <span class="hljs-title class_">ClippingPlane</span>;

struct <span class="hljs-title class_">VertexShaderInput</span>
{
    float4 <span class="hljs-title class_">Position</span> : <span class="hljs-title class_">POSITION0</span>;
    float4 <span class="hljs-title class_">Normal</span> : <span class="hljs-variable constant_">NORMAL</span>;
};
 
struct <span class="hljs-title class_">VertexShaderOutput</span>
{
    float4 <span class="hljs-title class_">Position</span> : <span class="hljs-title class_">POSITION0</span>;
    float3 <span class="hljs-title class_">WorldPosition</span> : <span class="hljs-title class_">TEXCOORD0</span>;
    float3 <span class="hljs-title class_">Normal</span> : <span class="hljs-title class_">TEXCOORD1</span>;
    float4 <span class="hljs-title class_">Clipping</span> : <span class="hljs-title class_">TEXCOORD2</span>;
};

<span class="hljs-title class_">VertexShaderOutput</span> <span class="hljs-title class_">MainVS</span>(<span class="hljs-title class_">VertexShaderInput</span> input)
{
    <span class="hljs-title class_">VertexShaderOutput</span> output = (<span class="hljs-title class_">VertexShaderOutput</span>) <span class="hljs-number">0</span>;
 
    float4 worldPosition = <span class="hljs-title function_">mul</span>(input.<span class="hljs-property">Position</span>, <span class="hljs-title class_">World</span>);
    float4 viewPosition = <span class="hljs-title function_">mul</span>(worldPosition, <span class="hljs-title class_">View</span>);
    output.<span class="hljs-property">Position</span> = <span class="hljs-title function_">mul</span>(viewPosition, <span class="hljs-title class_">Projection</span>);
    output.<span class="hljs-property">WorldPosition</span> = worldPosition;
    output.<span class="hljs-property">Normal</span> = <span class="hljs-title function_">mul</span>(input.<span class="hljs-property">Normal</span>, <span class="hljs-title class_">InverseTransposeWorld</span>);
    <span class="hljs-comment">/*
    dot product를 사용하여 정점에서 클리핑 평면까지의 거리 계산
    이 결과 거리는 해당 픽셀을 픽셀 셰이더에서 버릴지 여부를 결정하는 데 사용됩니다
    */</span>
    output.<span class="hljs-property">Clipping</span> = <span class="hljs-title function_">dot</span>(worldPosition, <span class="hljs-title class_">ClippingPlane</span>);
 
    <span class="hljs-keyword">return</span> output;
}

float4 <span class="hljs-title class_">MainPS</span>(<span class="hljs-title class_">VertexShaderOutput</span> input) : <span class="hljs-title class_">COLOR0</span>
{
    <span class="hljs-title function_">clip</span>(input.<span class="hljs-property">Clipping</span>);
    
    <span class="hljs-comment">// 픽셀 셰이더의 나머지 부분</span>
}
</code></pre>
<div class="content-ad"></div>
<p>클립 함수는 지정된 조건에 따라 픽셀을 삭제하는 기능을 담당합니다. 셰이더에서 -QuadHeight를 활용하여 물 표면 아래에 있는 물체를 나타내는 픽셀들이 렌더링 중에 삭제되어 최종 반사 이미지에서 클리핑되는 효과가 있습니다.</p>
<p>또한, 위쪽의 물 위에 있는 픽셀을 삭제하려는 경우에도 이 방법이 작동합니다. 이 경우 굴절을 위해 다음과 같이 설정할 수 있습니다:</p>
<pre><code class="hljs language-js">private readonly <span class="hljs-title class_">Vector4</span> _refractionClippingPlane = <span class="hljs-title function_">new</span>(0f, -1f, 0f, <span class="hljs-title class_">QuadHeight</span>);
</code></pre>
<h1>굴절</h1>
<div class="content-ad"></div>
<p>리프렉션을 렌더 대상에 그리는 것은 반사를 렌더링하는 것과 비교할 때 간단한 프로세스입니다. 이 작업은 카메라의 관점에서 장면을 렌더링하면서 _refractionClippingPlane을 사용하여 수면 위의 픽셀을 버립니다.</p>
<pre><code class="hljs language-js">private <span class="hljs-keyword">void</span> <span class="hljs-title class_">DrawRefraction</span>()
{
    <span class="hljs-comment">// Refraction Texture을 렌더 타겟으로 설정</span>
    <span class="hljs-title class_">GraphicsDevice</span>.<span class="hljs-title class_">SetRenderTarget</span>(_refractionRenderTarget);
    <span class="hljs-title class_">GraphicsDevice</span>.<span class="hljs-title class_">Clear</span>(<span class="hljs-title class_">ClearOptions</span>.<span class="hljs-property">Target</span> | <span class="hljs-title class_">ClearOptions</span>.<span class="hljs-property">DepthBuffer</span>, <span class="hljs-title class_">Color</span>.<span class="hljs-property">CornflowerBlue</span>, 1f, <span class="hljs-number">0</span>);
            
    <span class="hljs-comment">// 수면 위에 있는 객체를 자르면서 장면을 일반적으로 그립니다</span>
    <span class="hljs-title class_">DrawScene</span>(_freeCamera.<span class="hljs-property">View</span>, _freeCamera.<span class="hljs-property">Projection</span>, _freeCamera.<span class="hljs-property">Position</span>, _refractionClippingPlane);
            
    <span class="hljs-comment">// 렌더 타겟을 기본값(화면)으로 재설정</span>
    <span class="hljs-title class_">GraphicsDevice</span>.<span class="hljs-title class_">SetRenderTarget</span>(<span class="hljs-literal">null</span>);
}
</code></pre>
<p>좋아요, 이제 실제 수 쉐이더로 진행하여 이 모든 내용이 어떻게 결합되는지 살펴봅시다.</p>
<h1>수 쉐이더</h1>
<div class="content-ad"></div>
<p>먼저, 우리의 물 쉐이더에 필요한 균일 및 텍스처를 선언할 것입니다. 이에는 조명, 카메라 위치, 물의 움직임 및 사용할 다양한 맵에 대한 텍스처 샘플러를 위한 매개변수가 포함됩니다:</p>
<pre><code class="hljs language-js">float <span class="hljs-title class_">KSpecular</span>;
float <span class="hljs-title class_">Shininess</span>;
float3 <span class="hljs-title class_">LightPosition</span>;
float3 <span class="hljs-title class_">LightColor</span>;
float3 <span class="hljs-title class_">CameraPosition</span>;

float <span class="hljs-title class_">MoveFactor</span>;
float2 <span class="hljs-title class_">Tiling</span>;
float <span class="hljs-title class_">WaveStrength</span>;

float4x4 <span class="hljs-title class_">ReflectionView</span>;
float4x4 <span class="hljs-title class_">Projection</span>;
float4x4 <span class="hljs-title class_">WorldViewProjection</span>;
float4x4 <span class="hljs-title class_">World</span>;

texture <span class="hljs-title class_">RefractionTexture</span>;
sampler2D refractionSampler = sampler_state
{
    <span class="hljs-title class_">Texture</span> = (<span class="hljs-title class_">RefractionTexture</span>);
    <span class="hljs-variable constant_">ADDRESSU</span> = <span class="hljs-title class_">Clamp</span>;
    <span class="hljs-variable constant_">ADDRESSV</span> = <span class="hljs-title class_">Clamp</span>;
    <span class="hljs-variable constant_">MINFILTER</span> = <span class="hljs-title class_">Linear</span>;
    <span class="hljs-variable constant_">MAGFILTER</span> = <span class="hljs-title class_">Linear</span>;
    <span class="hljs-variable constant_">MIPFILTER</span> = <span class="hljs-title class_">Linear</span>;
};

texture <span class="hljs-title class_">ReflectionTexture</span>;
sampler2D reflectionSampler = sampler_state
{
    <span class="hljs-title class_">Texture</span> = (<span class="hljs-title class_">ReflectionTexture</span>);
    <span class="hljs-variable constant_">ADDRESSU</span> = <span class="hljs-title class_">Clamp</span>;
    <span class="hljs-variable constant_">ADDRESSV</span> = <span class="hljs-title class_">Clamp</span>;
    <span class="hljs-variable constant_">MINFILTER</span> = <span class="hljs-title class_">Linear</span>;
    <span class="hljs-variable constant_">MAGFILTER</span> = <span class="hljs-title class_">Linear</span>;
    <span class="hljs-variable constant_">MIPFILTER</span> = <span class="hljs-title class_">Linear</span>;
};

texture <span class="hljs-title class_">DistortionMap</span>;
sampler2D distortionSampler = sampler_state
{
    <span class="hljs-title class_">Texture</span> = (<span class="hljs-title class_">DistortionMap</span>);
    <span class="hljs-variable constant_">ADDRESSU</span> = <span class="hljs-variable constant_">WRAP</span>;
    <span class="hljs-variable constant_">ADDRESSV</span> = <span class="hljs-variable constant_">WRAP</span>;
    <span class="hljs-variable constant_">MINFILTER</span> = <span class="hljs-title class_">Linear</span>;
    <span class="hljs-variable constant_">MAGFILTER</span> = <span class="hljs-title class_">Linear</span>;
    <span class="hljs-variable constant_">MIPFILTER</span> = <span class="hljs-title class_">Linear</span>;
};

texture <span class="hljs-title class_">NormalMap</span>;
sampler2D normalMapSampler = sampler_state
{
    <span class="hljs-title class_">Texture</span> = (<span class="hljs-title class_">NormalMap</span>);
    <span class="hljs-variable constant_">ADDRESSU</span> = <span class="hljs-variable constant_">WRAP</span>;
    <span class="hljs-variable constant_">ADDRESSV</span> = <span class="hljs-variable constant_">WRAP</span>;
    <span class="hljs-variable constant_">MINFILTER</span> = <span class="hljs-title class_">Linear</span>;
    <span class="hljs-variable constant_">MAGFILTER</span> = <span class="hljs-title class_">Linear</span>;
    <span class="hljs-variable constant_">MIPFILTER</span> = <span class="hljs-title class_">Linear</span>;
};
</code></pre>
<p>이 쉐이더에서 KSpecular, Shininess, LightPosition, LightColor, CameraPosition과 같은 균일은 조명 및 시각화 매개변수를 정의합니다. MoveFactor, Tiling, WaveStrength는 물의 움직임과 외관을 제어합니다. ReflectionView, Projection, WorldViewProjection, World와 같은 행렬은 좌표를 변환하는 데 사용됩니다. refractionSampler, reflectionSampler, distortionSampler, normalMapSampler와 같은 텍스처 샘플러는 물 표면을 렌더링하는 데 필요한 해당 텍스처를 샘플링하는 데 사용됩니다.</p>
<p>왜곡 맵에는 다음과 같은 모양의 텍스처를 사용할 것입니다:</p>
<div class="content-ad"></div>
<p><img src="/assets/img/2024-05-20-HowtocreateWatershaderinMonogameXNA_2.png" alt="이미지"/></p>
<p>이 텍스처를 사용하여 텍스처 좌표를 왜곡시켜 물 표면에 작은 파도 효과를 만들 수 있습니다. 이 왜곡은 물의 동적이고 현실적인 외관을 모방하는 데 도움이 됩니다.</p>
<p>Normal Map으로는 다른 텍스처를 사용할 것입니다. 여기 예시가 있습니다:</p>
<p><img src="/assets/img/2024-05-20-HowtocreateWatershaderinMonogameXNA_3.png" alt="이미지"/></p>
<div class="content-ad"></div>
<p>이 지도에는 물과 빛이 상호 작용하는 방식을 시뮬레이션하기 위해 필수적인 표면 법선에 대한 정보가 포함되어 있습니다. 왜곡 맵이 텍스처 좌표를 조작하는 데 사용되는 반면, 법선 맵은 빛 관련 계산에 사용됩니다.</p>
<h2>버텍스 셰이더</h2>
<p>우리의 버텍스 셰이더에서는 버텍스 데이터를 픽셀 셰이더에 대비하여 준비하기 위해 변환합니다. 이 과정을 자세히 살펴보겠습니다:</p>
<pre><code class="hljs language-js">struct <span class="hljs-title class_">VertexShaderInput</span>
{
    float4 <span class="hljs-title class_">Position</span> : <span class="hljs-title class_">POSITION0</span>;
    float4 <span class="hljs-title class_">Normal</span> : <span class="hljs-variable constant_">NORMAL</span>;
    float2 <span class="hljs-title class_">TextureCoordinates</span> : <span class="hljs-title class_">TEXCOORD0</span>;
};

struct <span class="hljs-title class_">VertexShaderOutput</span>
{
    float4 <span class="hljs-title class_">Position</span> : <span class="hljs-variable constant_">SV_POSITION</span>;
    float2 <span class="hljs-title class_">TextureCoordinates</span> : <span class="hljs-title class_">TEXCOORD0</span>;
    float4 <span class="hljs-title class_">WorldPosition</span> : <span class="hljs-title class_">TEXCOORD1</span>;
    float4 <span class="hljs-title class_">Normal</span> : <span class="hljs-title class_">TEXCOORD2</span>;
    float4 <span class="hljs-title class_">ReflectionPosition</span> : <span class="hljs-title class_">TEXCOORD3</span>;
    float4 <span class="hljs-title class_">RefractionPosition</span> : <span class="hljs-title class_">TEXCOORD4</span>;
};

<span class="hljs-title class_">VertexShaderOutput</span> <span class="hljs-title class_">MainVS</span>(<span class="hljs-keyword">in</span> <span class="hljs-title class_">VertexShaderInput</span> input)
{
    <span class="hljs-title class_">VertexShaderOutput</span> output = (<span class="hljs-title class_">VertexShaderOutput</span>) <span class="hljs-number">0</span>;

    <span class="hljs-comment">// 버텍스 위치를 클립 공간에 변환합니다</span>
    output.<span class="hljs-property">Position</span> = <span class="hljs-title function_">mul</span>(input.<span class="hljs-property">Position</span>, <span class="hljs-title class_">WorldViewProjection</span>);
    
    <span class="hljs-comment">// 버텍스 위치를 월드 공간으로 변환합니다</span>
    output.<span class="hljs-property">WorldPosition</span> = <span class="hljs-title function_">mul</span>(input.<span class="hljs-property">Position</span>, <span class="hljs-title class_">World</span>);
    
    <span class="hljs-comment">// 어떤 변경도 없이 버텍스 법선을 전달합니다</span>
    output.<span class="hljs-property">Normal</span> = input.<span class="hljs-property">Normal</span>;
    
    <span class="hljs-comment">// 타일링 요소로 텍스처 좌표를 조정합니다</span>
    output.<span class="hljs-property">TextureCoordinates</span> = input.<span class="hljs-property">TextureCoordinates</span> * <span class="hljs-title class_">Tiling</span>;
    
    <span class="hljs-comment">// 반사 위치와 월드 매트릭스를 계산합니다</span>
    float4x4 reflectProjectWorld = <span class="hljs-title function_">mul</span>(<span class="hljs-title class_">ReflectionView</span>, <span class="hljs-title class_">Projection</span>);
    reflectProjectWorld = <span class="hljs-title function_">mul</span>(<span class="hljs-title class_">World</span>, reflectProjectWorld);
    output.<span class="hljs-property">ReflectionPosition</span> = <span class="hljs-title function_">mul</span>(input.<span class="hljs-property">Position</span>, reflectProjectWorld);
    
    <span class="hljs-comment">// 굴절 위치는 클립 공간 위치와 동일합니다</span>
    output.<span class="hljs-property">RefractionPosition</span> = output.<span class="hljs-property">Position</span>;
    
    <span class="hljs-keyword">return</span> output;
}
</code></pre>
<div class="content-ad"></div>
<p>좋아요, 이제 정점 셰이더 부분을 완료했으니 픽셀 셰이더로 넘어갈 수 있겠네요.</p>
<h1>픽셀 셰이더</h1>
<h2>프로젝티브 텍스처 매핑</h2>
<p>먼저, 프로젝티브 굴절 텍스처 좌표를 정규화 장치 좌표 (NDC) 공간으로 변환합니다. 그런 다음, DirectX (DX) 텍스처를 정확히 샘플링할 수 있도록 xy 좌표를 적절하게 조정하여 크기를 조절하고 오프셋을 적용합니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-csharp"><span class="hljs-function">float4 <span class="hljs-title">MainPS</span>(<span class="hljs-params">VertexShaderOutput input</span>) : COLOR</span>
{
    <span class="hljs-comment">// 굴절</span>

    float4 refractionTexCoord;
    refractionTexCoord = input.RefractionPosition;
    
    <span class="hljs-comment">// 화면 위치 좌표</span>
    refractionTexCoord.xyz /= refractionTexCoord.w;
    
    <span class="hljs-comment">// 오프셋 조정</span>
    refractionTexCoord.x = <span class="hljs-number">0.5f</span> * refractionTexCoord.x + <span class="hljs-number">0.5f</span>;
    refractionTexCoord.y = <span class="hljs-number">-0.5f</span> * refractionTexCoord.y + <span class="hljs-number">0.5f</span>;
    
    <span class="hljs-comment">// 카메라로부터의 거리에 따라 굴절 더하기</span>
    refractionTexCoord.z = <span class="hljs-number">0.001f</span> / refractionTexCoord.z;
    float2 refractionTex = refractionTexCoord.xy - refractionTexCoord.z;
    
    <span class="hljs-comment">// 반사</span>

    float4 reflectionTexCoord;
    reflectionTexCoord = input.ReflectionPosition;
    
    <span class="hljs-comment">// 화면 위치 좌표</span>
    reflectionTexCoord.xyz /= reflectionTexCoord.w;
    
    <span class="hljs-comment">// 오프셋 조정</span>
    reflectionTexCoord.x = <span class="hljs-number">0.5f</span> * reflectionTexCoord.x + <span class="hljs-number">0.5f</span>;
    reflectionTexCoord.y = <span class="hljs-number">-0.5f</span> * reflectionTexCoord.y + <span class="hljs-number">0.5f</span>;
    
    <span class="hljs-comment">// 카메라로부터의 거리에 따라 반사 더하기</span>
    reflectionTexCoord.z = <span class="hljs-number">0.001f</span> / reflectionTexCoord.z;
    float2 reflectionTex = reflectionTexCoord.xy + reflectionTexCoord.z;

    <span class="hljs-comment">// 셰이더의 나머지 부분</span>
}
</code></pre>
<p>굴절에 대해서는 카메라로부터의 거리에 따라 텍스처 좌표를 조정하여 굴절 효과를 향상시킵니다. 이 조정을 통해 카메라로부터 더 멀리 있는 객체가 더 많이 굴절되어 물 속 장면을 더 현실적으로 렌더링할 수 있습니다.</p>
<p>반사에 대해서도 반사 텍스처 좌표를 NDC 공간으로 변환하고 카메라로부터의 거리에 따라 조정합니다. 이것은 더 뚜렷한 반사 효과를 만들어냄과 동시에, 카메라로부터 더 멀리 있는 객체가 더 강렬하게 반사되도록 도와줍니다.</p>
<h2>왜곡 맵 / DuDv 맵</h2>
<div class="content-ad"></div>
<p>이제 위에 표시된 왜곡 맵을 사용하여 반사 및 굴절 텍스처를 샘플링할 예정입니다.</p>
<p>이 맵은 빨간색과 녹색으로 이뤄진, 기본적으로 float2로 이루어져 있습니다. 그러나 이 값들은 항상 이 왜곡 맵에서 양수일 것이므로, 왜곡은 항상 양수일 것이고, 값은 (0.0, 0.0)에서 (1.0, 1.0) 사이입니다. 이 전체적인 리얼리티를 위해 양수와 음수 왜곡을 가질 수 있으면 좋을 것 같습니다.</p>
<p>이 값을 (-1.0, -1.0)에서 (1.0, 1.0) 사이로 변환하기 위해 단순히 2를 곱하고 1을 뺍니다. 그런 다음 이 값을 사용하여 간단히 반사 및 굴절 텍스처 좌표를 왜곡시킵니다.</p>
<pre><code class="hljs language-js">float2 distortion = (<span class="hljs-title function_">tex2D</span>(distortionSampler, <span class="hljs-title class_">Input</span>.<span class="hljs-property">TextureCoordinates</span>)).<span class="hljs-property">rg</span> 
                    * <span class="hljs-number">2.0</span> - <span class="hljs-number">1.0</span>) * <span class="hljs-title class_">WaveStrength</span>;

reflectionTex += distortion;
refractionTex += distortion;
</code></pre>
<div class="content-ad"></div>
<p>이 왜곡은 기본 설정에서 조금 강할 수 있습니다. 그래서 우리는 이 왜곡을 약간 낮추기 위해 이전에 선언한 WaveStrength로 사용할 것입니다.</p>
<h2>파도 이동하기</h2>
<p>물이 움직이는 것처럼 보이게 하는 방법은 Distortion Map을 샘플링하는 위치에 오프셋을 사용하는 것입니다. 이미 이를 선언했는데, 그것이 MoveFactor이며 이 오프셋을 시간이 지남에 따라 변경할 것입니다.</p>
<p>이 효과를 얻기 위해 MoveFactor를 텍스처 좌표의 X 구성 요소에 추가하고 왜곡 맵을 샘플링합니다. 그 후 Y 구성 요소를 위해 두 번째 샘플링을 수행하여 다른 방향으로 추가 왜곡을 적용합니다. 이 프로세스는 왜곡 효과의 현실성을 강화하여 보다 동적인 외관을 만듭니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js">float2 distortedTexCoords = <span class="hljs-title function_">tex2D</span>(distortionSampler, <span class="hljs-title function_">float2</span>(input.<span class="hljs-property">TextureCoordinates</span>.<span class="hljs-property">x</span> + <span class="hljs-title class_">MoveFactor</span>, input.<span class="hljs-property">TextureCoordinates</span>.<span class="hljs-property">y</span>)) * <span class="hljs-number">0.01</span>;
distortedTexCoords = input.<span class="hljs-property">TextureCoordinates</span> + <span class="hljs-title function_">float2</span>(distortedTexCoords.<span class="hljs-property">x</span>, distortedTexCoords.<span class="hljs-property">y</span> + <span class="hljs-title class_">MoveFactor</span>);
float2 totalDistortion = (<span class="hljs-title function_">tex2D</span>(distortionSampler, distortedTexCoords).<span class="hljs-property">rg</span> * <span class="hljs-number">2.0</span> - <span class="hljs-number">1.0</span>) * <span class="hljs-title class_">WaveStrength</span>;

reflectionTex += totalDistortion;
refractionTex += totalDistortion;

<span class="hljs-comment">// Sample both texture using the distorted texture coordinates</span>
float4 reflectionColor = <span class="hljs-title function_">tex2D</span>(reflectionSampler, reflectionTex);
float4 refractionColor = <span class="hljs-title function_">tex2D</span>(refractionSampler, refractionTex);
</code></pre>
<p>첫 번째 줄에서 0.01을 곱하여 초기 샘플에 적용된 왜곡의 강도를 약간 조정했습니다.</p>
<h2>프레넬</h2>
<p>프레넬 효과가 무엇인지 모르겠다면, Dorian의 아주 좋은 설명을 보여드리겠습니다.```</p>
<div class="content-ad"></div>
<p>이 효과를 구현하려면 다음과 같이 물에서부터의 뷰 방향과 법선을 사용해야 합니다:</p>
<pre><code class="hljs language-js">float3 viewDirection = <span class="hljs-title function_">normalize</span>(<span class="hljs-title class_">CameraPosition</span> - input.<span class="hljs-property">WorldPosition</span>.<span class="hljs-property">xyz</span>);
float refractiveFactor = <span class="hljs-title function_">dot</span>(viewDirection, <span class="hljs-title function_">normalize</span>(input.<span class="hljs-property">Normal</span>.<span class="hljs-property">xyz</span>));
</code></pre>
<p>그리고 결과물은 이전에 계산한 refractiveFactor 값을 사용하여 reflectionColor와 refractionColor 사이의 선형 보간값이 될 것입니다.</p>
<pre><code class="hljs language-js">float4 finalColor = <span class="hljs-title function_">lerp</span>(reflectionColor, refractionColor, refractiveFactor);
</code></pre>
<div class="content-ad"></div>
<p>하지만 아직 끝나지 않았어요! 마지막으로 추가해야 할 것은 노멀 맵과 조명입니다.</p>
<h2>노멀 맵</h2>
<p>노멀 맵을 사용하여 물 표면의 다른 지점에서의 노멀을 나타낼 수 있습니다. 노멀 맵의 어떤 지점의 픽셀 색상은 그 지점에서의 물의 3D 노멀 벡터를 나타낼 수 있습니다. (R, G, B) -` (X, Y, Z). 저는 위에 보여드린 노멀 맵이 대부분 파란색인 이유는 파란 값이 위쪽 축을 나타내며, 우리의 경우에는 Y 축이기 때문입니다.</p>
<p>따라서, 우리는 노멀 맵 색의 파란 구성 요소를 노멀 벡터의 Y 구성 요소로 사용할 것이고, 노멀 맵의 빨간색과 초록색 구성 요소를 노멀 벡터의 X 및 Z 구성 요소로 사용할 수 있습니다. (R, G, B) -` (R, B, G).</p>
<div class="content-ad"></div>
<p>여기서 유일한 문제는 절대 음수 색상을 가질 수 없기 때문에 법선 벡터의 구성 요소도 양수여야한다는 것입니다. Y 구성 요소에 대해서는 문제가 되지 않습니다. 왜냐하면 표면 법선이 어느 정도로든 위로 향하도록 항상 원하기 때문입니다. 그러나 법선이 항상 양의 X 및 Z 방향을 가리키도록 하길 바라는 것은 아닙니다. 법선은 음의 X 및 Z 방향을 가리키도록도 할 수 있어야 합니다.</p>
<p>이를 위해 왜곡 맵에 사용한 것과 동일한 변환을 사용할 것입니다. 2를 곱하고 1을 빼는 것입니다. 그리고 이런 식으로 법선 맵에서 법선 벡터를 추출할 수 있습니다:</p>
<pre><code class="hljs language-js">float4 normalMapColor = <span class="hljs-title function_">tex2D</span>(normalMapSampler, distortedTexCoords);
float3 normal = <span class="hljs-title function_">float3</span>(normalMapColor.<span class="hljs-property">r</span> * <span class="hljs-number">2.0</span> - <span class="hljs-number">1.0</span>, normalMapColor.<span class="hljs-property">b</span>, normalMapColor.<span class="hljs-property">g</span> * <span class="hljs-number">2.0</span> - <span class="hljs-number">1.0</span>);
normal = <span class="hljs-title function_">normalize</span>(normal);
</code></pre>
<p>이 추출된 법선 벡터를 활용하여 조명 효과를 계산할 것입니다.</p>
<div class="content-ad"></div>
<h2>조명</h2>
<p>우리가 사용할 조명 기법은 기본적으로 Blinn Phong 모델입니다. 이에 대해 더 알고 싶다면 여기를 클릭해주세요. 여기서 사용되는 유니폼은 KSpecular, Shininess, LightPosition 및 LightColor 입니다.</p>
<p>먼저, 빛의 방향과 하프 벡터를 구하기 위해 빛 위치와 빛 및 보기 방향의 합을 나타내는 벡터를 정규화합니다.</p>
<pre><code class="hljs language-js">float3 lightDirection = <span class="hljs-title function_">normalize</span>(<span class="hljs-title class_">LightPosition</span> - input.<span class="hljs-property">WorldPosition</span>.<span class="hljs-property">xyz</span>);
float3 halfVector = <span class="hljs-title function_">normalize</span>(lightDirection + viewDirection);
</code></pre>
<div class="content-ad"></div>
<p>이 벡터들을 사용하여, 우리는 NdotL과 NdotH라는 닷 프로덕트를 계산합니다. 이는 각각 노멀 벡터와 라이트 방향, 그리고 노멀 벡터와 하프 벡터 사이의 각도를 나타냅니다.</p>
<pre><code class="hljs language-js">float <span class="hljs-title class_">NdotL</span> = <span class="hljs-title function_">saturate</span>(<span class="hljs-title function_">dot</span>(normal, lightDirection));
float <span class="hljs-title class_">NdotH</span> = <span class="hljs-title function_">saturate</span>(<span class="hljs-title function_">dot</span>(normal, halfVector));
</code></pre>
<p>이 닷 프로덕트를 이용하여, 우리는 Phong 반사 모델 방정식을 적용하여 스펙큘러 광원 기여도를 계산합니다.</p>
<pre><code class="hljs language-js">float3 specularLight = <span class="hljs-title function_">sign</span>(<span class="hljs-title class_">NdotL</span>) * <span class="hljs-title class_">KSpecular</span> * <span class="hljs-title class_">LightColor</span> * <span class="hljs-title function_">pow</span>(<span class="hljs-title class_">NdotH</span>, <span class="hljs-title class_">Shininess</span>);
</code></pre>
<div class="content-ad"></div>
<p>마지막으로 반사광을 미리 계산된 반사 및 굴절 색과 결합하여 최종 색상 출력을 결정합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 최종 계산</span>
float4 finalColor = <span class="hljs-title function_">lerp</span>(reflectionColor, refractionColor, refractiveFactor) + <span class="hljs-title function_">float4</span>(specularLight, <span class="hljs-number">0.0</span>);
</code></pre>
<p>그게 다에요! 우리는 물 셰이더를 완전히 성공적으로 만들었습니다! 원하는 대로 매개변수를 조절할 수 있어요. 저는 이렇게 했어요:</p>
<pre><code class="hljs language-js">private <span class="hljs-keyword">void</span> <span class="hljs-title class_">DrawWater</span>(<span class="hljs-title class_">Matrix</span> world, <span class="hljs-title class_">Matrix</span> view, <span class="hljs-title class_">Matrix</span> projection, <span class="hljs-title class_">Matrix</span> reflectionView, <span class="hljs-title class_">GameTime</span> gameTime)
{
    _waterShader.<span class="hljs-property">CurrentTechnique</span> = _waterShader.<span class="hljs-property">Techniques</span>[<span class="hljs-string">&quot;Water&quot;</span>];

    _waterShader.<span class="hljs-property">Parameters</span>[<span class="hljs-string">&quot;World&quot;</span>].<span class="hljs-title class_">SetValue</span>(world);
    _waterShader.<span class="hljs-property">Parameters</span>[<span class="hljs-string">&quot;WorldViewProjection&quot;</span>].<span class="hljs-title class_">SetValue</span>(world * view * projection);
    _waterShader.<span class="hljs-property">Parameters</span>[<span class="hljs-string">&quot;ReflectionView&quot;</span>].<span class="hljs-title class_">SetValue</span>(reflectionView);
    _waterShader.<span class="hljs-property">Parameters</span>[<span class="hljs-string">&quot;Projection&quot;</span>].<span class="hljs-title class_">SetValue</span>(projection);
            
    _waterShader.<span class="hljs-property">Parameters</span>[<span class="hljs-string">&quot;ReflectionTexture&quot;</span>].<span class="hljs-title class_">SetValue</span>(_reflectionRenderTarget);
    _waterShader.<span class="hljs-property">Parameters</span>[<span class="hljs-string">&quot;RefractionTexture&quot;</span>].<span class="hljs-title class_">SetValue</span>(_refractionRenderTarget);
    _waterShader.<span class="hljs-property">Parameters</span>[<span class="hljs-string">&quot;DistortionMap&quot;</span>].<span class="hljs-title class_">SetValue</span>(_distortionMap);
    _waterShader.<span class="hljs-property">Parameters</span>[<span class="hljs-string">&quot;NormalMap&quot;</span>].<span class="hljs-title class_">SetValue</span>(_normalMap);
    _waterShader.<span class="hljs-property">Parameters</span>[<span class="hljs-string">&quot;Tiling&quot;</span>].<span class="hljs-title class_">SetValue</span>(<span class="hljs-title class_">Vector2</span>.<span class="hljs-property">One</span> * 20f);
            
    _waterShader.<span class="hljs-property">Parameters</span>[<span class="hljs-string">&quot;MoveFactor&quot;</span>].<span class="hljs-title class_">SetValue</span>(<span class="hljs-title class_">WaveSpeed</span> * (float)gameTime.<span class="hljs-property">TotalGameTime</span>.<span class="hljs-property">TotalSeconds</span>);
    _waterShader.<span class="hljs-property">Parameters</span>[<span class="hljs-string">&quot;WaveStrength&quot;</span>].<span class="hljs-title class_">SetValue</span>(<span class="hljs-number">0.</span>01f);
            
    _waterShader.<span class="hljs-property">Parameters</span>[<span class="hljs-string">&quot;CameraPosition&quot;</span>].<span class="hljs-title class_">SetValue</span>(_freeCamera.<span class="hljs-property">Position</span>);
    _waterShader.<span class="hljs-property">Parameters</span>[<span class="hljs-string">&quot;LightPosition&quot;</span>].<span class="hljs-title class_">SetValue</span>(_lightPosition);
    _waterShader.<span class="hljs-property">Parameters</span>[<span class="hljs-string">&quot;LightColor&quot;</span>].<span class="hljs-title class_">SetValue</span>(<span class="hljs-title class_">Color</span>.<span class="hljs-property">White</span>.<span class="hljs-title class_">ToVector3</span>());
    _waterShader.<span class="hljs-property">Parameters</span>[<span class="hljs-string">&quot;Shininess&quot;</span>].<span class="hljs-title class_">SetValue</span>(25f);
    _waterShader.<span class="hljs-property">Parameters</span>[<span class="hljs-string">&quot;KSpecular&quot;</span>].<span class="hljs-title class_">SetValue</span>(<span class="hljs-number">0.</span>3f);
            
    _quad.<span class="hljs-title class_">Draw</span>(_waterShader);
}
</code></pre>
<div class="content-ad"></div>
<p>그리고 제 경우에는 다음과 같이 보입니다:</p>
<p><img src="/assets/img/2024-05-20-HowtocreateWatershaderinMonogameXNA_4.png" alt="image"/></p>
<p>이 글이 모노게임 그래픽 애플리케이션에서 이 효과를 이해하고 구현하는 데 도움이 되었으면 좋겠어요.</p></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"모노게임 XNA에서 물 쉐이더를 만드는 방법","description":"","date":"2024-05-20 16:37","slug":"2024-05-20-HowtocreateWatershaderinMonogameXNA","content":"\n\n# 소개\n\n이 기사에서는 Monogame/XNA에서 간단한 물 쉐이더를 만드는 기본 개념을 다룰 것입니다. 이 쉐이더는 플레이너 반사, 굴절, 프레넬 효과 및 반사 하이라이트를 사용할 것입니다. 작성 시점에서 Monogame 버전 3.8.1로 진행되었습니다. 자세히 살펴보고 싶다면 여기 소스 코드가 있습니다.\n\n# 기본 사항\n\n우리 쉐이더가 어떻게 작동하는지 더 잘 이해하기 위해 여러 단계로 나눠 설명하겠습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 쿼드/플랫 표면 추가하기\n- 반사 및 굴절 텍스처 추가하기 (프레넬 효과를 사용하여 둘 사이의 러핑)\n- 왜곡 맵을 사용하여 작은 파도 시뮬레이션하기\n- 광택을 위한 노말 맵 추가하기\n\n# 그리기\n\n그려지는 순서는 다음과 같습니다:\n\n- 굴절 그리기\n- 반사 그리기\n- 물 그리기\n- 장면에서 다른 개체 그리기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 순서는 원하는 시각적 효과를 달성하기 위해 각 구성 요소가 올바른 순서로 렌더링되도록합니다.\n\n# 코드 설정\n\n우리의 워터 쉐이더 기술을 올바르게 구현하기 위해 코드에서 몇 가지 설정을 해야합니다. 설명을 간단히하기 위해 이미 정의된 QuadPrimitive 클래스를 사용할 것입니다. 이 클래스는 정점 버퍼(법선과 텍스처 좌표에 대한 정보를 보냄)와 인덱스 버퍼를 가집니다. 또한 FreeCamera 클래스를 사용하여 카메라 이동을 처리할 것이지만 이 튜토리얼의 주요 내용은 아니기 때문에 자세히 다루지 않겠습니다.\n\n먼저 우리는 우리의 쿼드, 그의 월드 매트릭스, 높이 및 파도 속도를 생성할 것입니다. 나중에는 쉐이더 매개변수에서 파도 속도를 사용할 것입니다. 또한 이 높이는 반사와 굴절을 계산하는 중요한 요소가 될 것입니다. 게다가 우리는 쉐이더를 선언할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```csharp\n// 카메라\nprivate FreeCamera _freeCamera;\nprivate readonly Vector3 _cameraInitialPosition = new(0f, 50f, 300f);\n\n// 물\nprivate QuadPrimitive _quad;\nprivate const float QuadHeight = 0f;\nprivate const float WaveSpeed = 0.05f;\nprivate Matrix _quadWorld;\nprivate Effect _waterShader;\n```\n\n아울 Initialize 메소드는 다음과 같이 보여야 합니다:\n\n```csharp\nprotected override void Initialize()\n{\n  _graphicsDeviceManager.PreferredBackBufferWidth = GraphicsAdapter.DefaultAdapter.CurrentDisplayMode.Width - 100;\n  _graphicsDeviceManager.PreferredBackBufferHeight = GraphicsAdapter.DefaultAdapter.CurrentDisplayMode.Height - 100;\n  _graphicsDeviceManager.ApplyChanges();\n\n  // 카메라\n  _freeCamera = new FreeCamera(GraphicsDevice.Viewport.AspectRatio, _cameraInitialPosition);\n\n  // 물\n  _quad = new QuadPrimitive(GraphicsDevice);\n  var quadPosition = new Vector3(0f, QuadHeight, 0f);\n  _quadWorld = Matrix.CreateScale(3000f, 0f, 3000f) * Matrix.CreateTranslation(quadPosition);\n\n  base.Initialize();\n}\n```\n\n# 평면 반사\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n코드를 진행하기 전에 우리는 평면 반사가 어떻게 작동하는지 이해해야 합니다. 평면 반사의 예시를 살펴보겠습니다:\n\n![Planar Reflection](/assets/img/2024-05-20-HowtocreateWatershaderinMonogameXNA_0.png)\n\n이 예시에서 우리는 반사면, 카메라, 그리고 어떤 객체가 주어졌을 때 반사가 이렇게 보일 것이라는 것을 볼 수 있습니다. 이것을 코드로 나중에 변환하기 위해, 반사 카메라의 시각에서 새로운 뷰 매트릭스를 계산해야 합니다.\n\n## 반사 카메라 위치\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n먼저, 반사 카메라 위치를 계산하겠습니다. 이미 카메라 위치, 평면 위치 및 평면 법선을 알고 있으므로 카메라 위치에서 평면 위치를 빼면 뷰 방향 벡터를 얻을 수 있습니다:\n\n뷰 방향 = 카메라 위치 - 평면 위치\n\n![image](/assets/img/2024-05-20-HowtocreateWatershaderinMonogameXNA_1.png)\n\n또한 투영 벡터를 추가했는데 이것은 다음과 같습니다. 그런 다음 해당 투영의 길이를 사용하여 평면상의 해당 지점까지의 거리를 찾을 수 있습니다.\n이제 우리는 직각 삼각형을 가지고 있습니다. 투영 길이는 다음과 같아야 합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n투영 길이 = 시야 방향 * cos(각도)\n\n각도는 평면 법선과 시야 방향 사이의 각도를 의미합니다.\n\n간단하게 표현하면 다음과 같이 다시 쓸 수 있습니다:\n\n투영 길이 = 내적(평면 법선, 시야 방향)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n좋아요, 이제 우리에게는 프로젝션 길이가 있습니다. 이것을 사용하여 반사 카메라 위치를 얻을 수 있습니다:\n\n반사 카메라 위치 = 카메라 위치 — 2 * 평면 법선 * 프로젝션 길이\n\n## 반사 카메라 뷰 매트릭스\n\n반사 카메라 뷰 매트릭스를 얻으려면 반사 카메라 포워드를 계산해야 합니다. 함수 Reflect(vector, normal)를 사용하여 특정 법선을 갖는 표면에서 벡터의 반사를 얻을 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n카메라 반사 벡터를 계산한 후, Reflection Camera Up을 계산하는 다음 단계입니다. 카메라의 위쪽 벡터를 반사면의 법선을 기준으로 반사하는 Vector3.Reflect 함수를 다시 사용할 것입니다.\n\nReflection Camera Up = Vector3.Reflect(Camera Up, Plane Normal)\n\nReflection Camera Position, Reflection Camera Forward 및 Reflection Camera Up 벡터가 모두 계산되었으므로 이제 Reflection Camera View Matrix를 구성하는 데 필요한 모든 구성 요소를 갖추게 되었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n리플렉션 카메라 뷰 = Matrix.CreateLookAt(리플렉션 카메라 위치, 리플렉션 카메라 위치 + 리플렉션 카메라 전방, 리플렉션 카메라 위치)\n\n# 리플렉션 그리기\n\n이제 리플렉션 카메라 뷰 행렬의 필요 구성 요소를 계산했으므로, 일반적으로 RenderTarget2D와 같은 텍스처에 리플렉션을 그릴 수 있습니다. 이를 위해 코드에서 이전에 계산한 값을 렌더링 프로세스에 통합할 수 있습니다. 다음 코드 조각은 이를 어떻게 달성할 수 있는지 보여줍니다:\n\n```js\nprivate void DrawReflection(Matrix world, Matrix view, Matrix projection, GameTime gameTime)\n{\n    // 렌더 타겟을 리플렉션 텍스처로 설정\n    GraphicsDevice.SetRenderTarget(_reflectionRenderTarget);\n    GraphicsDevice.Clear(ClearOptions.Target | \n    ClearOptions.DepthBuffer, Color.CornflowerBlue, 1f, 0);\n            \n    var quadNormal = Vector3.Up;         \n    var viewDirection = _freeCamera.Position - _quadWorld.Translation;       \n    var projLength = Vector3.Dot(quadNormal, viewDirection);\n    var reflectionCamPos = _freeCamera.Position - 2 * quadNormal * projLength;\n    var reflectionCamForward = Vector3.Reflect(_freeCamera.FrontDirection, \n    quadNormal);\n    var reflectionCamUp = Vector3.Reflect(_freeCamera.UpDirection, quadNormal);  \n    var reflectionCamView = Matrix.CreateLookAt(reflectionCamPos, \n                reflectionCamPos + reflectionCamForward, reflectionCamUp);\n    \n    // 리플렉션 카메라 시점에서 씬 그리기\n    DrawScene(reflectionCamView, projection, reflectionCamPos, \n    _reflectionClippingPlane);\n    \n    // 렌더 타겟을 기본(화면)으로 재설정\n    GraphicsDevice.SetRenderTarget(null);\n         \n    // 물 그리기\n    DrawWater(world, view, projection, reflectionCamView, gameTime);\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nDrawWater 메서드에서는 필요한 매개변수를 전달할 것이며, 이에 대해 나중에 자세히 다룰 것입니다.\n\n## 클리핑 평면\n\n클리핑 평면 _reflectionClippingPlane이 아직 설명되지 않았다는 것을 눈치채셨나요? 그 목적에 대해 자세히 살펴보겠습니다. 이 클리핑 평면은 수면 위에 있는 객체만 그릴 때 사용됩니다. 이를 통해 객체의 상단 반만이 물에 반사되어 실제 반사에서 관찰되는 것과 동일하게 됩니다. 다음과 같이 선언할 수 있습니다:\n\n```js\nprivate readonly Vector4 _reflectionClippingPlane = new Vector4(0f, 1f, 0f, -QuadHeight);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 평면은 수학적 방정식 (Ax + By + Cz + D = 0)으로 정의됩니다. 여기서 (A, B, C)는 평면에 수직인 법선 벡터를 나타내고, D는 해당 법선 벡터를 따라 원점으로부터의 거리를 나타냅니다.\n\n우리의 경우, 물 표면은 XZ 평면과 평행한 평면으로 작용하며, 그 법선 벡터는 직접 위쪽을 가리킵니다 (0, 1, 0).\n\n우리는 물 속 객체를 다루는 셰이더를 위해 반사 클리핑 평면 방정식에 -QuadHeight 값을 활용합니다. 이 값은 나중에 픽셀 셰이더에서 clip 함수를 사용하여 Reflection Plane 아래의 픽셀을 클리핑할 때 사용됩니다. 다음은 예시입니다:\n\n*Uniforms*\n```js\nfloat4 ClippingPlane;\n\nstruct VertexShaderInput\n{\n    float4 Position : POSITION0;\n    float4 Normal : NORMAL;\n};\n \nstruct VertexShaderOutput\n{\n    float4 Position : POSITION0;\n    float3 WorldPosition : TEXCOORD0;\n    float3 Normal : TEXCOORD1;\n    float4 Clipping : TEXCOORD2;\n};\n\nVertexShaderOutput MainVS(VertexShaderInput input)\n{\n    VertexShaderOutput output = (VertexShaderOutput) 0;\n \n    float4 worldPosition = mul(input.Position, World);\n    float4 viewPosition = mul(worldPosition, View);\n    output.Position = mul(viewPosition, Projection);\n    output.WorldPosition = worldPosition;\n    output.Normal = mul(input.Normal, InverseTransposeWorld);\n    /*\n    dot product를 사용하여 정점에서 클리핑 평면까지의 거리 계산\n    이 결과 거리는 해당 픽셀을 픽셀 셰이더에서 버릴지 여부를 결정하는 데 사용됩니다\n    */\n    output.Clipping = dot(worldPosition, ClippingPlane);\n \n    return output;\n}\n\nfloat4 MainPS(VertexShaderOutput input) : COLOR0\n{\n    clip(input.Clipping);\n    \n    // 픽셀 셰이더의 나머지 부분\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n클립 함수는 지정된 조건에 따라 픽셀을 삭제하는 기능을 담당합니다. 셰이더에서 -QuadHeight를 활용하여 물 표면 아래에 있는 물체를 나타내는 픽셀들이 렌더링 중에 삭제되어 최종 반사 이미지에서 클리핑되는 효과가 있습니다.\n\n또한, 위쪽의 물 위에 있는 픽셀을 삭제하려는 경우에도 이 방법이 작동합니다. 이 경우 굴절을 위해 다음과 같이 설정할 수 있습니다:\n\n```js\nprivate readonly Vector4 _refractionClippingPlane = new(0f, -1f, 0f, QuadHeight);\n```\n\n# 굴절\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n리프렉션을 렌더 대상에 그리는 것은 반사를 렌더링하는 것과 비교할 때 간단한 프로세스입니다. 이 작업은 카메라의 관점에서 장면을 렌더링하면서 _refractionClippingPlane을 사용하여 수면 위의 픽셀을 버립니다.\n\n```js\nprivate void DrawRefraction()\n{\n    // Refraction Texture을 렌더 타겟으로 설정\n    GraphicsDevice.SetRenderTarget(_refractionRenderTarget);\n    GraphicsDevice.Clear(ClearOptions.Target | ClearOptions.DepthBuffer, Color.CornflowerBlue, 1f, 0);\n            \n    // 수면 위에 있는 객체를 자르면서 장면을 일반적으로 그립니다\n    DrawScene(_freeCamera.View, _freeCamera.Projection, _freeCamera.Position, _refractionClippingPlane);\n            \n    // 렌더 타겟을 기본값(화면)으로 재설정\n    GraphicsDevice.SetRenderTarget(null);\n}\n```\n\n좋아요, 이제 실제 수 쉐이더로 진행하여 이 모든 내용이 어떻게 결합되는지 살펴봅시다.\n\n# 수 쉐이더\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n먼저, 우리의 물 쉐이더에 필요한 균일 및 텍스처를 선언할 것입니다. 이에는 조명, 카메라 위치, 물의 움직임 및 사용할 다양한 맵에 대한 텍스처 샘플러를 위한 매개변수가 포함됩니다:\n\n```js\nfloat KSpecular;\nfloat Shininess;\nfloat3 LightPosition;\nfloat3 LightColor;\nfloat3 CameraPosition;\n\nfloat MoveFactor;\nfloat2 Tiling;\nfloat WaveStrength;\n\nfloat4x4 ReflectionView;\nfloat4x4 Projection;\nfloat4x4 WorldViewProjection;\nfloat4x4 World;\n\ntexture RefractionTexture;\nsampler2D refractionSampler = sampler_state\n{\n    Texture = (RefractionTexture);\n    ADDRESSU = Clamp;\n    ADDRESSV = Clamp;\n    MINFILTER = Linear;\n    MAGFILTER = Linear;\n    MIPFILTER = Linear;\n};\n\ntexture ReflectionTexture;\nsampler2D reflectionSampler = sampler_state\n{\n    Texture = (ReflectionTexture);\n    ADDRESSU = Clamp;\n    ADDRESSV = Clamp;\n    MINFILTER = Linear;\n    MAGFILTER = Linear;\n    MIPFILTER = Linear;\n};\n\ntexture DistortionMap;\nsampler2D distortionSampler = sampler_state\n{\n    Texture = (DistortionMap);\n    ADDRESSU = WRAP;\n    ADDRESSV = WRAP;\n    MINFILTER = Linear;\n    MAGFILTER = Linear;\n    MIPFILTER = Linear;\n};\n\ntexture NormalMap;\nsampler2D normalMapSampler = sampler_state\n{\n    Texture = (NormalMap);\n    ADDRESSU = WRAP;\n    ADDRESSV = WRAP;\n    MINFILTER = Linear;\n    MAGFILTER = Linear;\n    MIPFILTER = Linear;\n};\n```\n\n이 쉐이더에서 KSpecular, Shininess, LightPosition, LightColor, CameraPosition과 같은 균일은 조명 및 시각화 매개변수를 정의합니다. MoveFactor, Tiling, WaveStrength는 물의 움직임과 외관을 제어합니다. ReflectionView, Projection, WorldViewProjection, World와 같은 행렬은 좌표를 변환하는 데 사용됩니다. refractionSampler, reflectionSampler, distortionSampler, normalMapSampler와 같은 텍스처 샘플러는 물 표면을 렌더링하는 데 필요한 해당 텍스처를 샘플링하는 데 사용됩니다.\n\n왜곡 맵에는 다음과 같은 모양의 텍스처를 사용할 것입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![이미지](/assets/img/2024-05-20-HowtocreateWatershaderinMonogameXNA_2.png)\n\n이 텍스처를 사용하여 텍스처 좌표를 왜곡시켜 물 표면에 작은 파도 효과를 만들 수 있습니다. 이 왜곡은 물의 동적이고 현실적인 외관을 모방하는 데 도움이 됩니다.\n\nNormal Map으로는 다른 텍스처를 사용할 것입니다. 여기 예시가 있습니다:\n\n![이미지](/assets/img/2024-05-20-HowtocreateWatershaderinMonogameXNA_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 지도에는 물과 빛이 상호 작용하는 방식을 시뮬레이션하기 위해 필수적인 표면 법선에 대한 정보가 포함되어 있습니다. 왜곡 맵이 텍스처 좌표를 조작하는 데 사용되는 반면, 법선 맵은 빛 관련 계산에 사용됩니다.\n\n## 버텍스 셰이더\n\n우리의 버텍스 셰이더에서는 버텍스 데이터를 픽셀 셰이더에 대비하여 준비하기 위해 변환합니다. 이 과정을 자세히 살펴보겠습니다:\n\n```js\nstruct VertexShaderInput\n{\n    float4 Position : POSITION0;\n    float4 Normal : NORMAL;\n    float2 TextureCoordinates : TEXCOORD0;\n};\n\nstruct VertexShaderOutput\n{\n    float4 Position : SV_POSITION;\n    float2 TextureCoordinates : TEXCOORD0;\n    float4 WorldPosition : TEXCOORD1;\n    float4 Normal : TEXCOORD2;\n    float4 ReflectionPosition : TEXCOORD3;\n    float4 RefractionPosition : TEXCOORD4;\n};\n\nVertexShaderOutput MainVS(in VertexShaderInput input)\n{\n    VertexShaderOutput output = (VertexShaderOutput) 0;\n\n    // 버텍스 위치를 클립 공간에 변환합니다\n    output.Position = mul(input.Position, WorldViewProjection);\n    \n    // 버텍스 위치를 월드 공간으로 변환합니다\n    output.WorldPosition = mul(input.Position, World);\n    \n    // 어떤 변경도 없이 버텍스 법선을 전달합니다\n    output.Normal = input.Normal;\n    \n    // 타일링 요소로 텍스처 좌표를 조정합니다\n    output.TextureCoordinates = input.TextureCoordinates * Tiling;\n    \n    // 반사 위치와 월드 매트릭스를 계산합니다\n    float4x4 reflectProjectWorld = mul(ReflectionView, Projection);\n    reflectProjectWorld = mul(World, reflectProjectWorld);\n    output.ReflectionPosition = mul(input.Position, reflectProjectWorld);\n    \n    // 굴절 위치는 클립 공간 위치와 동일합니다\n    output.RefractionPosition = output.Position;\n    \n    return output;\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n좋아요, 이제 정점 셰이더 부분을 완료했으니 픽셀 셰이더로 넘어갈 수 있겠네요.\n\n# 픽셀 셰이더\n\n## 프로젝티브 텍스처 매핑\n\n먼저, 프로젝티브 굴절 텍스처 좌표를 정규화 장치 좌표 (NDC) 공간으로 변환합니다. 그런 다음, DirectX (DX) 텍스처를 정확히 샘플링할 수 있도록 xy 좌표를 적절하게 조정하여 크기를 조절하고 오프셋을 적용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```csharp\nfloat4 MainPS(VertexShaderOutput input) : COLOR\n{\n    // 굴절\n\n    float4 refractionTexCoord;\n    refractionTexCoord = input.RefractionPosition;\n    \n    // 화면 위치 좌표\n    refractionTexCoord.xyz /= refractionTexCoord.w;\n    \n    // 오프셋 조정\n    refractionTexCoord.x = 0.5f * refractionTexCoord.x + 0.5f;\n    refractionTexCoord.y = -0.5f * refractionTexCoord.y + 0.5f;\n    \n    // 카메라로부터의 거리에 따라 굴절 더하기\n    refractionTexCoord.z = 0.001f / refractionTexCoord.z;\n    float2 refractionTex = refractionTexCoord.xy - refractionTexCoord.z;\n    \n    // 반사\n\n    float4 reflectionTexCoord;\n    reflectionTexCoord = input.ReflectionPosition;\n    \n    // 화면 위치 좌표\n    reflectionTexCoord.xyz /= reflectionTexCoord.w;\n    \n    // 오프셋 조정\n    reflectionTexCoord.x = 0.5f * reflectionTexCoord.x + 0.5f;\n    reflectionTexCoord.y = -0.5f * reflectionTexCoord.y + 0.5f;\n    \n    // 카메라로부터의 거리에 따라 반사 더하기\n    reflectionTexCoord.z = 0.001f / reflectionTexCoord.z;\n    float2 reflectionTex = reflectionTexCoord.xy + reflectionTexCoord.z;\n\n    // 셰이더의 나머지 부분\n}\n```\n\n굴절에 대해서는 카메라로부터의 거리에 따라 텍스처 좌표를 조정하여 굴절 효과를 향상시킵니다. 이 조정을 통해 카메라로부터 더 멀리 있는 객체가 더 많이 굴절되어 물 속 장면을 더 현실적으로 렌더링할 수 있습니다.\n\n반사에 대해서도 반사 텍스처 좌표를 NDC 공간으로 변환하고 카메라로부터의 거리에 따라 조정합니다. 이것은 더 뚜렷한 반사 효과를 만들어냄과 동시에, 카메라로부터 더 멀리 있는 객체가 더 강렬하게 반사되도록 도와줍니다.\n\n## 왜곡 맵 / DuDv 맵\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 위에 표시된 왜곡 맵을 사용하여 반사 및 굴절 텍스처를 샘플링할 예정입니다.\n\n이 맵은 빨간색과 녹색으로 이뤄진, 기본적으로 float2로 이루어져 있습니다. 그러나 이 값들은 항상 이 왜곡 맵에서 양수일 것이므로, 왜곡은 항상 양수일 것이고, 값은 (0.0, 0.0)에서 (1.0, 1.0) 사이입니다. 이 전체적인 리얼리티를 위해 양수와 음수 왜곡을 가질 수 있으면 좋을 것 같습니다.\n\n이 값을 (-1.0, -1.0)에서 (1.0, 1.0) 사이로 변환하기 위해 단순히 2를 곱하고 1을 뺍니다. 그런 다음 이 값을 사용하여 간단히 반사 및 굴절 텍스처 좌표를 왜곡시킵니다.\n\n```js\nfloat2 distortion = (tex2D(distortionSampler, Input.TextureCoordinates)).rg \n                    * 2.0 - 1.0) * WaveStrength;\n\nreflectionTex += distortion;\nrefractionTex += distortion;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 왜곡은 기본 설정에서 조금 강할 수 있습니다. 그래서 우리는 이 왜곡을 약간 낮추기 위해 이전에 선언한 WaveStrength로 사용할 것입니다.\n\n## 파도 이동하기\n\n물이 움직이는 것처럼 보이게 하는 방법은 Distortion Map을 샘플링하는 위치에 오프셋을 사용하는 것입니다. 이미 이를 선언했는데, 그것이 MoveFactor이며 이 오프셋을 시간이 지남에 따라 변경할 것입니다.\n\n이 효과를 얻기 위해 MoveFactor를 텍스처 좌표의 X 구성 요소에 추가하고 왜곡 맵을 샘플링합니다. 그 후 Y 구성 요소를 위해 두 번째 샘플링을 수행하여 다른 방향으로 추가 왜곡을 적용합니다. 이 프로세스는 왜곡 효과의 현실성을 강화하여 보다 동적인 외관을 만듭니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n```js\nfloat2 distortedTexCoords = tex2D(distortionSampler, float2(input.TextureCoordinates.x + MoveFactor, input.TextureCoordinates.y)) * 0.01;\ndistortedTexCoords = input.TextureCoordinates + float2(distortedTexCoords.x, distortedTexCoords.y + MoveFactor);\nfloat2 totalDistortion = (tex2D(distortionSampler, distortedTexCoords).rg * 2.0 - 1.0) * WaveStrength;\n\nreflectionTex += totalDistortion;\nrefractionTex += totalDistortion;\n\n// Sample both texture using the distorted texture coordinates\nfloat4 reflectionColor = tex2D(reflectionSampler, reflectionTex);\nfloat4 refractionColor = tex2D(refractionSampler, refractionTex);\n```\n\n첫 번째 줄에서 0.01을 곱하여 초기 샘플에 적용된 왜곡의 강도를 약간 조정했습니다.\n\n## 프레넬\n\n프레넬 효과가 무엇인지 모르겠다면, Dorian의 아주 좋은 설명을 보여드리겠습니다.```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 효과를 구현하려면 다음과 같이 물에서부터의 뷰 방향과 법선을 사용해야 합니다:\n\n```js\nfloat3 viewDirection = normalize(CameraPosition - input.WorldPosition.xyz);\nfloat refractiveFactor = dot(viewDirection, normalize(input.Normal.xyz));\n```\n\n그리고 결과물은 이전에 계산한 refractiveFactor 값을 사용하여 reflectionColor와 refractionColor 사이의 선형 보간값이 될 것입니다.\n\n```js\nfloat4 finalColor = lerp(reflectionColor, refractionColor, refractiveFactor);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만 아직 끝나지 않았어요! 마지막으로 추가해야 할 것은 노멀 맵과 조명입니다.\n\n## 노멀 맵\n\n노멀 맵을 사용하여 물 표면의 다른 지점에서의 노멀을 나타낼 수 있습니다. 노멀 맵의 어떤 지점의 픽셀 색상은 그 지점에서의 물의 3D 노멀 벡터를 나타낼 수 있습니다. (R, G, B) -` (X, Y, Z). 저는 위에 보여드린 노멀 맵이 대부분 파란색인 이유는 파란 값이 위쪽 축을 나타내며, 우리의 경우에는 Y 축이기 때문입니다.\n\n따라서, 우리는 노멀 맵 색의 파란 구성 요소를 노멀 벡터의 Y 구성 요소로 사용할 것이고, 노멀 맵의 빨간색과 초록색 구성 요소를 노멀 벡터의 X 및 Z 구성 요소로 사용할 수 있습니다. (R, G, B) -` (R, B, G).\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기서 유일한 문제는 절대 음수 색상을 가질 수 없기 때문에 법선 벡터의 구성 요소도 양수여야한다는 것입니다. Y 구성 요소에 대해서는 문제가 되지 않습니다. 왜냐하면 표면 법선이 어느 정도로든 위로 향하도록 항상 원하기 때문입니다. 그러나 법선이 항상 양의 X 및 Z 방향을 가리키도록 하길 바라는 것은 아닙니다. 법선은 음의 X 및 Z 방향을 가리키도록도 할 수 있어야 합니다.\n\n이를 위해 왜곡 맵에 사용한 것과 동일한 변환을 사용할 것입니다. 2를 곱하고 1을 빼는 것입니다. 그리고 이런 식으로 법선 맵에서 법선 벡터를 추출할 수 있습니다:\n\n```js\nfloat4 normalMapColor = tex2D(normalMapSampler, distortedTexCoords);\nfloat3 normal = float3(normalMapColor.r * 2.0 - 1.0, normalMapColor.b, normalMapColor.g * 2.0 - 1.0);\nnormal = normalize(normal);\n```\n\n이 추출된 법선 벡터를 활용하여 조명 효과를 계산할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 조명\n\n우리가 사용할 조명 기법은 기본적으로 Blinn Phong 모델입니다. 이에 대해 더 알고 싶다면 여기를 클릭해주세요. 여기서 사용되는 유니폼은 KSpecular, Shininess, LightPosition 및 LightColor 입니다.\n\n먼저, 빛의 방향과 하프 벡터를 구하기 위해 빛 위치와 빛 및 보기 방향의 합을 나타내는 벡터를 정규화합니다.\n\n```js\nfloat3 lightDirection = normalize(LightPosition - input.WorldPosition.xyz);\nfloat3 halfVector = normalize(lightDirection + viewDirection);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 벡터들을 사용하여, 우리는 NdotL과 NdotH라는 닷 프로덕트를 계산합니다. 이는 각각 노멀 벡터와 라이트 방향, 그리고 노멀 벡터와 하프 벡터 사이의 각도를 나타냅니다.\n\n```js\nfloat NdotL = saturate(dot(normal, lightDirection));\nfloat NdotH = saturate(dot(normal, halfVector));\n```\n\n이 닷 프로덕트를 이용하여, 우리는 Phong 반사 모델 방정식을 적용하여 스펙큘러 광원 기여도를 계산합니다.\n\n```js\nfloat3 specularLight = sign(NdotL) * KSpecular * LightColor * pow(NdotH, Shininess);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마지막으로 반사광을 미리 계산된 반사 및 굴절 색과 결합하여 최종 색상 출력을 결정합니다.\n\n```js\n// 최종 계산\nfloat4 finalColor = lerp(reflectionColor, refractionColor, refractiveFactor) + float4(specularLight, 0.0);\n```\n\n그게 다에요! 우리는 물 셰이더를 완전히 성공적으로 만들었습니다! 원하는 대로 매개변수를 조절할 수 있어요. 저는 이렇게 했어요:\n\n```js\nprivate void DrawWater(Matrix world, Matrix view, Matrix projection, Matrix reflectionView, GameTime gameTime)\n{\n    _waterShader.CurrentTechnique = _waterShader.Techniques[\"Water\"];\n\n    _waterShader.Parameters[\"World\"].SetValue(world);\n    _waterShader.Parameters[\"WorldViewProjection\"].SetValue(world * view * projection);\n    _waterShader.Parameters[\"ReflectionView\"].SetValue(reflectionView);\n    _waterShader.Parameters[\"Projection\"].SetValue(projection);\n            \n    _waterShader.Parameters[\"ReflectionTexture\"].SetValue(_reflectionRenderTarget);\n    _waterShader.Parameters[\"RefractionTexture\"].SetValue(_refractionRenderTarget);\n    _waterShader.Parameters[\"DistortionMap\"].SetValue(_distortionMap);\n    _waterShader.Parameters[\"NormalMap\"].SetValue(_normalMap);\n    _waterShader.Parameters[\"Tiling\"].SetValue(Vector2.One * 20f);\n            \n    _waterShader.Parameters[\"MoveFactor\"].SetValue(WaveSpeed * (float)gameTime.TotalGameTime.TotalSeconds);\n    _waterShader.Parameters[\"WaveStrength\"].SetValue(0.01f);\n            \n    _waterShader.Parameters[\"CameraPosition\"].SetValue(_freeCamera.Position);\n    _waterShader.Parameters[\"LightPosition\"].SetValue(_lightPosition);\n    _waterShader.Parameters[\"LightColor\"].SetValue(Color.White.ToVector3());\n    _waterShader.Parameters[\"Shininess\"].SetValue(25f);\n    _waterShader.Parameters[\"KSpecular\"].SetValue(0.3f);\n            \n    _quad.Draw(_waterShader);\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그리고 제 경우에는 다음과 같이 보입니다:\n\n![image](/assets/img/2024-05-20-HowtocreateWatershaderinMonogameXNA_4.png)\n\n이 글이 모노게임 그래픽 애플리케이션에서 이 효과를 이해하고 구현하는 데 도움이 되었으면 좋겠어요.","ogImage":{"url":"/assets/img/2024-05-20-HowtocreateWatershaderinMonogameXNA_0.png"},"coverImage":"/assets/img/2024-05-20-HowtocreateWatershaderinMonogameXNA_0.png","tag":["Tech"],"readingTime":19},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h1: \"h1\",\n    p: \"p\",\n    ul: \"ul\",\n    li: \"li\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\",\n    img: \"img\",\n    h2: \"h2\",\n    em: \"em\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h1, {\n      children: \"소개\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 기사에서는 Monogame/XNA에서 간단한 물 쉐이더를 만드는 기본 개념을 다룰 것입니다. 이 쉐이더는 플레이너 반사, 굴절, 프레넬 효과 및 반사 하이라이트를 사용할 것입니다. 작성 시점에서 Monogame 버전 3.8.1로 진행되었습니다. 자세히 살펴보고 싶다면 여기 소스 코드가 있습니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"기본 사항\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우리 쉐이더가 어떻게 작동하는지 더 잘 이해하기 위해 여러 단계로 나눠 설명하겠습니다:\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"쿼드/플랫 표면 추가하기\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"반사 및 굴절 텍스처 추가하기 (프레넬 효과를 사용하여 둘 사이의 러핑)\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"왜곡 맵을 사용하여 작은 파도 시뮬레이션하기\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"광택을 위한 노말 맵 추가하기\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"그리기\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그려지는 순서는 다음과 같습니다:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"굴절 그리기\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"반사 그리기\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"물 그리기\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"장면에서 다른 개체 그리기\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 순서는 원하는 시각적 효과를 달성하기 위해 각 구성 요소가 올바른 순서로 렌더링되도록합니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"코드 설정\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우리의 워터 쉐이더 기술을 올바르게 구현하기 위해 코드에서 몇 가지 설정을 해야합니다. 설명을 간단히하기 위해 이미 정의된 QuadPrimitive 클래스를 사용할 것입니다. 이 클래스는 정점 버퍼(법선과 텍스처 좌표에 대한 정보를 보냄)와 인덱스 버퍼를 가집니다. 또한 FreeCamera 클래스를 사용하여 카메라 이동을 처리할 것이지만 이 튜토리얼의 주요 내용은 아니기 때문에 자세히 다루지 않겠습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"먼저 우리는 우리의 쿼드, 그의 월드 매트릭스, 높이 및 파도 속도를 생성할 것입니다. 나중에는 쉐이더 매개변수에서 파도 속도를 사용할 것입니다. 또한 이 높이는 반사와 굴절을 계산하는 중요한 요소가 될 것입니다. 게다가 우리는 쉐이더를 선언할 것입니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-csharp\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 카메라\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"private\"\n        }), \" FreeCamera _freeCamera;\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"private\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"readonly\"\n        }), \" Vector3 _cameraInitialPosition = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"new\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0f\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"50f\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"300f\"\n        }), \");\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 물\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"private\"\n        }), \" QuadPrimitive _quad;\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"private\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"float\"\n        }), \" QuadHeight = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0f\"\n        }), \";\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"private\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"float\"\n        }), \" WaveSpeed = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.05f\"\n        }), \";\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"private\"\n        }), \" Matrix _quadWorld;\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"private\"\n        }), \" Effect _waterShader;\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"아울 Initialize 메소드는 다음과 같이 보여야 합니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-csharp\",\n        children: [_jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"protected\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"override\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"void\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"Initialize\"\n          }), \"()\"]\n        }), \"\\n{\\n  _graphicsDeviceManager.PreferredBackBufferWidth = GraphicsAdapter.DefaultAdapter.CurrentDisplayMode.Width - \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"100\"\n        }), \";\\n  _graphicsDeviceManager.PreferredBackBufferHeight = GraphicsAdapter.DefaultAdapter.CurrentDisplayMode.Height - \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"100\"\n        }), \";\\n  _graphicsDeviceManager.ApplyChanges();\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 카메라\"\n        }), \"\\n  _freeCamera = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"new\"\n        }), \" FreeCamera(GraphicsDevice.Viewport.AspectRatio, _cameraInitialPosition);\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 물\"\n        }), \"\\n  _quad = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"new\"\n        }), \" QuadPrimitive(GraphicsDevice);\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"var\"\n        }), \" quadPosition = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"new\"\n        }), \" Vector3(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0f\"\n        }), \", QuadHeight, \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0f\"\n        }), \");\\n  _quadWorld = Matrix.CreateScale(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"3000f\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0f\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"3000f\"\n        }), \") * Matrix.CreateTranslation(quadPosition);\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"base\"\n        }), \".Initialize();\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"평면 반사\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"코드를 진행하기 전에 우리는 평면 반사가 어떻게 작동하는지 이해해야 합니다. 평면 반사의 예시를 살펴보겠습니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-20-HowtocreateWatershaderinMonogameXNA_0.png\",\n        alt: \"Planar Reflection\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 예시에서 우리는 반사면, 카메라, 그리고 어떤 객체가 주어졌을 때 반사가 이렇게 보일 것이라는 것을 볼 수 있습니다. 이것을 코드로 나중에 변환하기 위해, 반사 카메라의 시각에서 새로운 뷰 매트릭스를 계산해야 합니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"반사 카메라 위치\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"먼저, 반사 카메라 위치를 계산하겠습니다. 이미 카메라 위치, 평면 위치 및 평면 법선을 알고 있으므로 카메라 위치에서 평면 위치를 빼면 뷰 방향 벡터를 얻을 수 있습니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"뷰 방향 = 카메라 위치 - 평면 위치\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-20-HowtocreateWatershaderinMonogameXNA_1.png\",\n        alt: \"image\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"또한 투영 벡터를 추가했는데 이것은 다음과 같습니다. 그런 다음 해당 투영의 길이를 사용하여 평면상의 해당 지점까지의 거리를 찾을 수 있습니다.\\n이제 우리는 직각 삼각형을 가지고 있습니다. 투영 길이는 다음과 같아야 합니다:\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"투영 길이 = 시야 방향 * cos(각도)\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"각도는 평면 법선과 시야 방향 사이의 각도를 의미합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"간단하게 표현하면 다음과 같이 다시 쓸 수 있습니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"투영 길이 = 내적(평면 법선, 시야 방향)\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"좋아요, 이제 우리에게는 프로젝션 길이가 있습니다. 이것을 사용하여 반사 카메라 위치를 얻을 수 있습니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"반사 카메라 위치 = 카메라 위치 — 2 * 평면 법선 * 프로젝션 길이\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"반사 카메라 뷰 매트릭스\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"반사 카메라 뷰 매트릭스를 얻으려면 반사 카메라 포워드를 계산해야 합니다. 함수 Reflect(vector, normal)를 사용하여 특정 법선을 갖는 표면에서 벡터의 반사를 얻을 수 있습니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"카메라 반사 벡터를 계산한 후, Reflection Camera Up을 계산하는 다음 단계입니다. 카메라의 위쪽 벡터를 반사면의 법선을 기준으로 반사하는 Vector3.Reflect 함수를 다시 사용할 것입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Reflection Camera Up = Vector3.Reflect(Camera Up, Plane Normal)\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Reflection Camera Position, Reflection Camera Forward 및 Reflection Camera Up 벡터가 모두 계산되었으므로 이제 Reflection Camera View Matrix를 구성하는 데 필요한 모든 구성 요소를 갖추게 되었습니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"리플렉션 카메라 뷰 = Matrix.CreateLookAt(리플렉션 카메라 위치, 리플렉션 카메라 위치 + 리플렉션 카메라 전방, 리플렉션 카메라 위치)\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"리플렉션 그리기\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 리플렉션 카메라 뷰 행렬의 필요 구성 요소를 계산했으므로, 일반적으로 RenderTarget2D와 같은 텍스처에 리플렉션을 그릴 수 있습니다. 이를 위해 코드에서 이전에 계산한 값을 렌더링 프로세스에 통합할 수 있습니다. 다음 코드 조각은 이를 어떻게 달성할 수 있는지 보여줍니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"private \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"void\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"DrawReflection\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Matrix\"\n        }), \" world, \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Matrix\"\n        }), \" view, \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Matrix\"\n        }), \" projection, \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"GameTime\"\n        }), \" gameTime)\\n{\\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 렌더 타겟을 리플렉션 텍스처로 설정\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"GraphicsDevice\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"SetRenderTarget\"\n        }), \"(_reflectionRenderTarget);\\n    \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"GraphicsDevice\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Clear\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ClearOptions\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"Target\"\n        }), \" | \\n    \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ClearOptions\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"DepthBuffer\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Color\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"CornflowerBlue\"\n        }), \", 1f, \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \");\\n            \\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"var\"\n        }), \" quadNormal = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Vector3\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"Up\"\n        }), \";         \\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"var\"\n        }), \" viewDirection = _freeCamera.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"Position\"\n        }), \" - _quadWorld.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"Translation\"\n        }), \";       \\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"var\"\n        }), \" projLength = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Vector3\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Dot\"\n        }), \"(quadNormal, viewDirection);\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"var\"\n        }), \" reflectionCamPos = _freeCamera.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"Position\"\n        }), \" - \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"2\"\n        }), \" * quadNormal * projLength;\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"var\"\n        }), \" reflectionCamForward = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Vector3\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Reflect\"\n        }), \"(_freeCamera.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"FrontDirection\"\n        }), \", \\n    quadNormal);\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"var\"\n        }), \" reflectionCamUp = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Vector3\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Reflect\"\n        }), \"(_freeCamera.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"UpDirection\"\n        }), \", quadNormal);  \\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"var\"\n        }), \" reflectionCamView = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Matrix\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"CreateLookAt\"\n        }), \"(reflectionCamPos, \\n                reflectionCamPos + reflectionCamForward, reflectionCamUp);\\n    \\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 리플렉션 카메라 시점에서 씬 그리기\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"DrawScene\"\n        }), \"(reflectionCamView, projection, reflectionCamPos, \\n    _reflectionClippingPlane);\\n    \\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 렌더 타겟을 기본(화면)으로 재설정\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"GraphicsDevice\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"SetRenderTarget\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"null\"\n        }), \");\\n         \\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 물 그리기\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"DrawWater\"\n        }), \"(world, view, projection, reflectionCamView, gameTime);\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"DrawWater 메서드에서는 필요한 매개변수를 전달할 것이며, 이에 대해 나중에 자세히 다룰 것입니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"클리핑 평면\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"클리핑 평면 _reflectionClippingPlane이 아직 설명되지 않았다는 것을 눈치채셨나요? 그 목적에 대해 자세히 살펴보겠습니다. 이 클리핑 평면은 수면 위에 있는 객체만 그릴 때 사용됩니다. 이를 통해 객체의 상단 반만이 물에 반사되어 실제 반사에서 관찰되는 것과 동일하게 됩니다. 다음과 같이 선언할 수 있습니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"private readonly \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Vector4\"\n        }), \" _reflectionClippingPlane = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"new\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Vector4\"\n        }), \"(0f, 1f, 0f, -\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"QuadHeight\"\n        }), \");\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 평면은 수학적 방정식 (Ax + By + Cz + D = 0)으로 정의됩니다. 여기서 (A, B, C)는 평면에 수직인 법선 벡터를 나타내고, D는 해당 법선 벡터를 따라 원점으로부터의 거리를 나타냅니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우리의 경우, 물 표면은 XZ 평면과 평행한 평면으로 작용하며, 그 법선 벡터는 직접 위쪽을 가리킵니다 (0, 1, 0).\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우리는 물 속 객체를 다루는 셰이더를 위해 반사 클리핑 평면 방정식에 -QuadHeight 값을 활용합니다. 이 값은 나중에 픽셀 셰이더에서 clip 함수를 사용하여 Reflection Plane 아래의 픽셀을 클리핑할 때 사용됩니다. 다음은 예시입니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.em, {\n        children: \"Uniforms\"\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"float4 \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ClippingPlane\"\n        }), \";\\n\\nstruct \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"VertexShaderInput\"\n        }), \"\\n{\\n    float4 \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Position\"\n        }), \" : \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"POSITION0\"\n        }), \";\\n    float4 \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Normal\"\n        }), \" : \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"NORMAL\"\n        }), \";\\n};\\n \\nstruct \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"VertexShaderOutput\"\n        }), \"\\n{\\n    float4 \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Position\"\n        }), \" : \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"POSITION0\"\n        }), \";\\n    float3 \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"WorldPosition\"\n        }), \" : \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"TEXCOORD0\"\n        }), \";\\n    float3 \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Normal\"\n        }), \" : \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"TEXCOORD1\"\n        }), \";\\n    float4 \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Clipping\"\n        }), \" : \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"TEXCOORD2\"\n        }), \";\\n};\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"VertexShaderOutput\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"MainVS\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"VertexShaderInput\"\n        }), \" input)\\n{\\n    \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"VertexShaderOutput\"\n        }), \" output = (\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"VertexShaderOutput\"\n        }), \") \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \";\\n \\n    float4 worldPosition = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"mul\"\n        }), \"(input.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"Position\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"World\"\n        }), \");\\n    float4 viewPosition = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"mul\"\n        }), \"(worldPosition, \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"View\"\n        }), \");\\n    output.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"Position\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"mul\"\n        }), \"(viewPosition, \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Projection\"\n        }), \");\\n    output.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"WorldPosition\"\n        }), \" = worldPosition;\\n    output.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"Normal\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"mul\"\n        }), \"(input.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"Normal\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"InverseTransposeWorld\"\n        }), \");\\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"/*\\n    dot product를 사용하여 정점에서 클리핑 평면까지의 거리 계산\\n    이 결과 거리는 해당 픽셀을 픽셀 셰이더에서 버릴지 여부를 결정하는 데 사용됩니다\\n    */\"\n        }), \"\\n    output.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"Clipping\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"dot\"\n        }), \"(worldPosition, \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ClippingPlane\"\n        }), \");\\n \\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" output;\\n}\\n\\nfloat4 \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"MainPS\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"VertexShaderOutput\"\n        }), \" input) : \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"COLOR0\"\n        }), \"\\n{\\n    \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"clip\"\n        }), \"(input.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"Clipping\"\n        }), \");\\n    \\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 픽셀 셰이더의 나머지 부분\"\n        }), \"\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"클립 함수는 지정된 조건에 따라 픽셀을 삭제하는 기능을 담당합니다. 셰이더에서 -QuadHeight를 활용하여 물 표면 아래에 있는 물체를 나타내는 픽셀들이 렌더링 중에 삭제되어 최종 반사 이미지에서 클리핑되는 효과가 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"또한, 위쪽의 물 위에 있는 픽셀을 삭제하려는 경우에도 이 방법이 작동합니다. 이 경우 굴절을 위해 다음과 같이 설정할 수 있습니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"private readonly \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Vector4\"\n        }), \" _refractionClippingPlane = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"new\"\n        }), \"(0f, -1f, 0f, \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"QuadHeight\"\n        }), \");\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"굴절\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"리프렉션을 렌더 대상에 그리는 것은 반사를 렌더링하는 것과 비교할 때 간단한 프로세스입니다. 이 작업은 카메라의 관점에서 장면을 렌더링하면서 _refractionClippingPlane을 사용하여 수면 위의 픽셀을 버립니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"private \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"void\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"DrawRefraction\"\n        }), \"()\\n{\\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// Refraction Texture을 렌더 타겟으로 설정\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"GraphicsDevice\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"SetRenderTarget\"\n        }), \"(_refractionRenderTarget);\\n    \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"GraphicsDevice\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Clear\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ClearOptions\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"Target\"\n        }), \" | \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ClearOptions\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"DepthBuffer\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Color\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"CornflowerBlue\"\n        }), \", 1f, \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \");\\n            \\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 수면 위에 있는 객체를 자르면서 장면을 일반적으로 그립니다\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"DrawScene\"\n        }), \"(_freeCamera.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"View\"\n        }), \", _freeCamera.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"Projection\"\n        }), \", _freeCamera.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"Position\"\n        }), \", _refractionClippingPlane);\\n            \\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 렌더 타겟을 기본값(화면)으로 재설정\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"GraphicsDevice\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"SetRenderTarget\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"null\"\n        }), \");\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"좋아요, 이제 실제 수 쉐이더로 진행하여 이 모든 내용이 어떻게 결합되는지 살펴봅시다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"수 쉐이더\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"먼저, 우리의 물 쉐이더에 필요한 균일 및 텍스처를 선언할 것입니다. 이에는 조명, 카메라 위치, 물의 움직임 및 사용할 다양한 맵에 대한 텍스처 샘플러를 위한 매개변수가 포함됩니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"float \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"KSpecular\"\n        }), \";\\nfloat \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Shininess\"\n        }), \";\\nfloat3 \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"LightPosition\"\n        }), \";\\nfloat3 \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"LightColor\"\n        }), \";\\nfloat3 \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"CameraPosition\"\n        }), \";\\n\\nfloat \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"MoveFactor\"\n        }), \";\\nfloat2 \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Tiling\"\n        }), \";\\nfloat \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"WaveStrength\"\n        }), \";\\n\\nfloat4x4 \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ReflectionView\"\n        }), \";\\nfloat4x4 \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Projection\"\n        }), \";\\nfloat4x4 \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"WorldViewProjection\"\n        }), \";\\nfloat4x4 \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"World\"\n        }), \";\\n\\ntexture \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"RefractionTexture\"\n        }), \";\\nsampler2D refractionSampler = sampler_state\\n{\\n    \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Texture\"\n        }), \" = (\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"RefractionTexture\"\n        }), \");\\n    \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"ADDRESSU\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Clamp\"\n        }), \";\\n    \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"ADDRESSV\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Clamp\"\n        }), \";\\n    \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"MINFILTER\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Linear\"\n        }), \";\\n    \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"MAGFILTER\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Linear\"\n        }), \";\\n    \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"MIPFILTER\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Linear\"\n        }), \";\\n};\\n\\ntexture \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ReflectionTexture\"\n        }), \";\\nsampler2D reflectionSampler = sampler_state\\n{\\n    \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Texture\"\n        }), \" = (\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ReflectionTexture\"\n        }), \");\\n    \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"ADDRESSU\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Clamp\"\n        }), \";\\n    \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"ADDRESSV\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Clamp\"\n        }), \";\\n    \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"MINFILTER\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Linear\"\n        }), \";\\n    \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"MAGFILTER\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Linear\"\n        }), \";\\n    \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"MIPFILTER\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Linear\"\n        }), \";\\n};\\n\\ntexture \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"DistortionMap\"\n        }), \";\\nsampler2D distortionSampler = sampler_state\\n{\\n    \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Texture\"\n        }), \" = (\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"DistortionMap\"\n        }), \");\\n    \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"ADDRESSU\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"WRAP\"\n        }), \";\\n    \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"ADDRESSV\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"WRAP\"\n        }), \";\\n    \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"MINFILTER\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Linear\"\n        }), \";\\n    \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"MAGFILTER\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Linear\"\n        }), \";\\n    \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"MIPFILTER\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Linear\"\n        }), \";\\n};\\n\\ntexture \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"NormalMap\"\n        }), \";\\nsampler2D normalMapSampler = sampler_state\\n{\\n    \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Texture\"\n        }), \" = (\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"NormalMap\"\n        }), \");\\n    \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"ADDRESSU\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"WRAP\"\n        }), \";\\n    \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"ADDRESSV\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"WRAP\"\n        }), \";\\n    \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"MINFILTER\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Linear\"\n        }), \";\\n    \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"MAGFILTER\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Linear\"\n        }), \";\\n    \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"MIPFILTER\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Linear\"\n        }), \";\\n};\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 쉐이더에서 KSpecular, Shininess, LightPosition, LightColor, CameraPosition과 같은 균일은 조명 및 시각화 매개변수를 정의합니다. MoveFactor, Tiling, WaveStrength는 물의 움직임과 외관을 제어합니다. ReflectionView, Projection, WorldViewProjection, World와 같은 행렬은 좌표를 변환하는 데 사용됩니다. refractionSampler, reflectionSampler, distortionSampler, normalMapSampler와 같은 텍스처 샘플러는 물 표면을 렌더링하는 데 필요한 해당 텍스처를 샘플링하는 데 사용됩니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"왜곡 맵에는 다음과 같은 모양의 텍스처를 사용할 것입니다:\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-20-HowtocreateWatershaderinMonogameXNA_2.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 텍스처를 사용하여 텍스처 좌표를 왜곡시켜 물 표면에 작은 파도 효과를 만들 수 있습니다. 이 왜곡은 물의 동적이고 현실적인 외관을 모방하는 데 도움이 됩니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Normal Map으로는 다른 텍스처를 사용할 것입니다. 여기 예시가 있습니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-20-HowtocreateWatershaderinMonogameXNA_3.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 지도에는 물과 빛이 상호 작용하는 방식을 시뮬레이션하기 위해 필수적인 표면 법선에 대한 정보가 포함되어 있습니다. 왜곡 맵이 텍스처 좌표를 조작하는 데 사용되는 반면, 법선 맵은 빛 관련 계산에 사용됩니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"버텍스 셰이더\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우리의 버텍스 셰이더에서는 버텍스 데이터를 픽셀 셰이더에 대비하여 준비하기 위해 변환합니다. 이 과정을 자세히 살펴보겠습니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"struct \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"VertexShaderInput\"\n        }), \"\\n{\\n    float4 \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Position\"\n        }), \" : \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"POSITION0\"\n        }), \";\\n    float4 \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Normal\"\n        }), \" : \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"NORMAL\"\n        }), \";\\n    float2 \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"TextureCoordinates\"\n        }), \" : \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"TEXCOORD0\"\n        }), \";\\n};\\n\\nstruct \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"VertexShaderOutput\"\n        }), \"\\n{\\n    float4 \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Position\"\n        }), \" : \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"SV_POSITION\"\n        }), \";\\n    float2 \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"TextureCoordinates\"\n        }), \" : \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"TEXCOORD0\"\n        }), \";\\n    float4 \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"WorldPosition\"\n        }), \" : \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"TEXCOORD1\"\n        }), \";\\n    float4 \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Normal\"\n        }), \" : \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"TEXCOORD2\"\n        }), \";\\n    float4 \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ReflectionPosition\"\n        }), \" : \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"TEXCOORD3\"\n        }), \";\\n    float4 \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"RefractionPosition\"\n        }), \" : \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"TEXCOORD4\"\n        }), \";\\n};\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"VertexShaderOutput\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"MainVS\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"VertexShaderInput\"\n        }), \" input)\\n{\\n    \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"VertexShaderOutput\"\n        }), \" output = (\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"VertexShaderOutput\"\n        }), \") \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \";\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 버텍스 위치를 클립 공간에 변환합니다\"\n        }), \"\\n    output.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"Position\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"mul\"\n        }), \"(input.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"Position\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"WorldViewProjection\"\n        }), \");\\n    \\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 버텍스 위치를 월드 공간으로 변환합니다\"\n        }), \"\\n    output.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"WorldPosition\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"mul\"\n        }), \"(input.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"Position\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"World\"\n        }), \");\\n    \\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 어떤 변경도 없이 버텍스 법선을 전달합니다\"\n        }), \"\\n    output.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"Normal\"\n        }), \" = input.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"Normal\"\n        }), \";\\n    \\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 타일링 요소로 텍스처 좌표를 조정합니다\"\n        }), \"\\n    output.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"TextureCoordinates\"\n        }), \" = input.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"TextureCoordinates\"\n        }), \" * \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Tiling\"\n        }), \";\\n    \\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 반사 위치와 월드 매트릭스를 계산합니다\"\n        }), \"\\n    float4x4 reflectProjectWorld = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"mul\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ReflectionView\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Projection\"\n        }), \");\\n    reflectProjectWorld = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"mul\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"World\"\n        }), \", reflectProjectWorld);\\n    output.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"ReflectionPosition\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"mul\"\n        }), \"(input.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"Position\"\n        }), \", reflectProjectWorld);\\n    \\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 굴절 위치는 클립 공간 위치와 동일합니다\"\n        }), \"\\n    output.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"RefractionPosition\"\n        }), \" = output.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"Position\"\n        }), \";\\n    \\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" output;\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"좋아요, 이제 정점 셰이더 부분을 완료했으니 픽셀 셰이더로 넘어갈 수 있겠네요.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"픽셀 셰이더\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"프로젝티브 텍스처 매핑\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"먼저, 프로젝티브 굴절 텍스처 좌표를 정규화 장치 좌표 (NDC) 공간으로 변환합니다. 그런 다음, DirectX (DX) 텍스처를 정확히 샘플링할 수 있도록 xy 좌표를 적절하게 조정하여 크기를 조절하고 오프셋을 적용합니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-csharp\",\n        children: [_jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [\"float4 \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"MainPS\"\n          }), \"(\", _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"VertexShaderOutput input\"\n          }), \") : COLOR\"]\n        }), \"\\n{\\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 굴절\"\n        }), \"\\n\\n    float4 refractionTexCoord;\\n    refractionTexCoord = input.RefractionPosition;\\n    \\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 화면 위치 좌표\"\n        }), \"\\n    refractionTexCoord.xyz /= refractionTexCoord.w;\\n    \\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 오프셋 조정\"\n        }), \"\\n    refractionTexCoord.x = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.5f\"\n        }), \" * refractionTexCoord.x + \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.5f\"\n        }), \";\\n    refractionTexCoord.y = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"-0.5f\"\n        }), \" * refractionTexCoord.y + \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.5f\"\n        }), \";\\n    \\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 카메라로부터의 거리에 따라 굴절 더하기\"\n        }), \"\\n    refractionTexCoord.z = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.001f\"\n        }), \" / refractionTexCoord.z;\\n    float2 refractionTex = refractionTexCoord.xy - refractionTexCoord.z;\\n    \\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 반사\"\n        }), \"\\n\\n    float4 reflectionTexCoord;\\n    reflectionTexCoord = input.ReflectionPosition;\\n    \\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 화면 위치 좌표\"\n        }), \"\\n    reflectionTexCoord.xyz /= reflectionTexCoord.w;\\n    \\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 오프셋 조정\"\n        }), \"\\n    reflectionTexCoord.x = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.5f\"\n        }), \" * reflectionTexCoord.x + \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.5f\"\n        }), \";\\n    reflectionTexCoord.y = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"-0.5f\"\n        }), \" * reflectionTexCoord.y + \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.5f\"\n        }), \";\\n    \\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 카메라로부터의 거리에 따라 반사 더하기\"\n        }), \"\\n    reflectionTexCoord.z = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.001f\"\n        }), \" / reflectionTexCoord.z;\\n    float2 reflectionTex = reflectionTexCoord.xy + reflectionTexCoord.z;\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 셰이더의 나머지 부분\"\n        }), \"\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"굴절에 대해서는 카메라로부터의 거리에 따라 텍스처 좌표를 조정하여 굴절 효과를 향상시킵니다. 이 조정을 통해 카메라로부터 더 멀리 있는 객체가 더 많이 굴절되어 물 속 장면을 더 현실적으로 렌더링할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"반사에 대해서도 반사 텍스처 좌표를 NDC 공간으로 변환하고 카메라로부터의 거리에 따라 조정합니다. 이것은 더 뚜렷한 반사 효과를 만들어냄과 동시에, 카메라로부터 더 멀리 있는 객체가 더 강렬하게 반사되도록 도와줍니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"왜곡 맵 / DuDv 맵\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 위에 표시된 왜곡 맵을 사용하여 반사 및 굴절 텍스처를 샘플링할 예정입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 맵은 빨간색과 녹색으로 이뤄진, 기본적으로 float2로 이루어져 있습니다. 그러나 이 값들은 항상 이 왜곡 맵에서 양수일 것이므로, 왜곡은 항상 양수일 것이고, 값은 (0.0, 0.0)에서 (1.0, 1.0) 사이입니다. 이 전체적인 리얼리티를 위해 양수와 음수 왜곡을 가질 수 있으면 좋을 것 같습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 값을 (-1.0, -1.0)에서 (1.0, 1.0) 사이로 변환하기 위해 단순히 2를 곱하고 1을 뺍니다. 그런 다음 이 값을 사용하여 간단히 반사 및 굴절 텍스처 좌표를 왜곡시킵니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"float2 distortion = (\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"tex2D\"\n        }), \"(distortionSampler, \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Input\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"TextureCoordinates\"\n        }), \")).\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"rg\"\n        }), \" \\n                    * \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"2.0\"\n        }), \" - \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1.0\"\n        }), \") * \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"WaveStrength\"\n        }), \";\\n\\nreflectionTex += distortion;\\nrefractionTex += distortion;\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 왜곡은 기본 설정에서 조금 강할 수 있습니다. 그래서 우리는 이 왜곡을 약간 낮추기 위해 이전에 선언한 WaveStrength로 사용할 것입니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"파도 이동하기\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"물이 움직이는 것처럼 보이게 하는 방법은 Distortion Map을 샘플링하는 위치에 오프셋을 사용하는 것입니다. 이미 이를 선언했는데, 그것이 MoveFactor이며 이 오프셋을 시간이 지남에 따라 변경할 것입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 효과를 얻기 위해 MoveFactor를 텍스처 좌표의 X 구성 요소에 추가하고 왜곡 맵을 샘플링합니다. 그 후 Y 구성 요소를 위해 두 번째 샘플링을 수행하여 다른 방향으로 추가 왜곡을 적용합니다. 이 프로세스는 왜곡 효과의 현실성을 강화하여 보다 동적인 외관을 만듭니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"float2 distortedTexCoords = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"tex2D\"\n        }), \"(distortionSampler, \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"float2\"\n        }), \"(input.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"TextureCoordinates\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"x\"\n        }), \" + \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"MoveFactor\"\n        }), \", input.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"TextureCoordinates\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"y\"\n        }), \")) * \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.01\"\n        }), \";\\ndistortedTexCoords = input.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"TextureCoordinates\"\n        }), \" + \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"float2\"\n        }), \"(distortedTexCoords.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"x\"\n        }), \", distortedTexCoords.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"y\"\n        }), \" + \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"MoveFactor\"\n        }), \");\\nfloat2 totalDistortion = (\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"tex2D\"\n        }), \"(distortionSampler, distortedTexCoords).\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"rg\"\n        }), \" * \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"2.0\"\n        }), \" - \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1.0\"\n        }), \") * \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"WaveStrength\"\n        }), \";\\n\\nreflectionTex += totalDistortion;\\nrefractionTex += totalDistortion;\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// Sample both texture using the distorted texture coordinates\"\n        }), \"\\nfloat4 reflectionColor = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"tex2D\"\n        }), \"(reflectionSampler, reflectionTex);\\nfloat4 refractionColor = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"tex2D\"\n        }), \"(refractionSampler, refractionTex);\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"첫 번째 줄에서 0.01을 곱하여 초기 샘플에 적용된 왜곡의 강도를 약간 조정했습니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"프레넬\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"프레넬 효과가 무엇인지 모르겠다면, Dorian의 아주 좋은 설명을 보여드리겠습니다.```\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 효과를 구현하려면 다음과 같이 물에서부터의 뷰 방향과 법선을 사용해야 합니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"float3 viewDirection = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"normalize\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"CameraPosition\"\n        }), \" - input.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"WorldPosition\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"xyz\"\n        }), \");\\nfloat refractiveFactor = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"dot\"\n        }), \"(viewDirection, \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"normalize\"\n        }), \"(input.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"Normal\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"xyz\"\n        }), \"));\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그리고 결과물은 이전에 계산한 refractiveFactor 값을 사용하여 reflectionColor와 refractionColor 사이의 선형 보간값이 될 것입니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"float4 finalColor = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"lerp\"\n        }), \"(reflectionColor, refractionColor, refractiveFactor);\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"하지만 아직 끝나지 않았어요! 마지막으로 추가해야 할 것은 노멀 맵과 조명입니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"노멀 맵\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"노멀 맵을 사용하여 물 표면의 다른 지점에서의 노멀을 나타낼 수 있습니다. 노멀 맵의 어떤 지점의 픽셀 색상은 그 지점에서의 물의 3D 노멀 벡터를 나타낼 수 있습니다. (R, G, B) -` (X, Y, Z). 저는 위에 보여드린 노멀 맵이 대부분 파란색인 이유는 파란 값이 위쪽 축을 나타내며, 우리의 경우에는 Y 축이기 때문입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"따라서, 우리는 노멀 맵 색의 파란 구성 요소를 노멀 벡터의 Y 구성 요소로 사용할 것이고, 노멀 맵의 빨간색과 초록색 구성 요소를 노멀 벡터의 X 및 Z 구성 요소로 사용할 수 있습니다. (R, G, B) -` (R, B, G).\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"여기서 유일한 문제는 절대 음수 색상을 가질 수 없기 때문에 법선 벡터의 구성 요소도 양수여야한다는 것입니다. Y 구성 요소에 대해서는 문제가 되지 않습니다. 왜냐하면 표면 법선이 어느 정도로든 위로 향하도록 항상 원하기 때문입니다. 그러나 법선이 항상 양의 X 및 Z 방향을 가리키도록 하길 바라는 것은 아닙니다. 법선은 음의 X 및 Z 방향을 가리키도록도 할 수 있어야 합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이를 위해 왜곡 맵에 사용한 것과 동일한 변환을 사용할 것입니다. 2를 곱하고 1을 빼는 것입니다. 그리고 이런 식으로 법선 맵에서 법선 벡터를 추출할 수 있습니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"float4 normalMapColor = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"tex2D\"\n        }), \"(normalMapSampler, distortedTexCoords);\\nfloat3 normal = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"float3\"\n        }), \"(normalMapColor.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"r\"\n        }), \" * \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"2.0\"\n        }), \" - \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1.0\"\n        }), \", normalMapColor.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"b\"\n        }), \", normalMapColor.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"g\"\n        }), \" * \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"2.0\"\n        }), \" - \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1.0\"\n        }), \");\\nnormal = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"normalize\"\n        }), \"(normal);\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 추출된 법선 벡터를 활용하여 조명 효과를 계산할 것입니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"조명\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우리가 사용할 조명 기법은 기본적으로 Blinn Phong 모델입니다. 이에 대해 더 알고 싶다면 여기를 클릭해주세요. 여기서 사용되는 유니폼은 KSpecular, Shininess, LightPosition 및 LightColor 입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"먼저, 빛의 방향과 하프 벡터를 구하기 위해 빛 위치와 빛 및 보기 방향의 합을 나타내는 벡터를 정규화합니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"float3 lightDirection = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"normalize\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"LightPosition\"\n        }), \" - input.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"WorldPosition\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"xyz\"\n        }), \");\\nfloat3 halfVector = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"normalize\"\n        }), \"(lightDirection + viewDirection);\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 벡터들을 사용하여, 우리는 NdotL과 NdotH라는 닷 프로덕트를 계산합니다. 이는 각각 노멀 벡터와 라이트 방향, 그리고 노멀 벡터와 하프 벡터 사이의 각도를 나타냅니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"float \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"NdotL\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"saturate\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"dot\"\n        }), \"(normal, lightDirection));\\nfloat \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"NdotH\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"saturate\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"dot\"\n        }), \"(normal, halfVector));\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 닷 프로덕트를 이용하여, 우리는 Phong 반사 모델 방정식을 적용하여 스펙큘러 광원 기여도를 계산합니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"float3 specularLight = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"sign\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"NdotL\"\n        }), \") * \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"KSpecular\"\n        }), \" * \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"LightColor\"\n        }), \" * \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"pow\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"NdotH\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Shininess\"\n        }), \");\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"마지막으로 반사광을 미리 계산된 반사 및 굴절 색과 결합하여 최종 색상 출력을 결정합니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 최종 계산\"\n        }), \"\\nfloat4 finalColor = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"lerp\"\n        }), \"(reflectionColor, refractionColor, refractiveFactor) + \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"float4\"\n        }), \"(specularLight, \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.0\"\n        }), \");\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그게 다에요! 우리는 물 셰이더를 완전히 성공적으로 만들었습니다! 원하는 대로 매개변수를 조절할 수 있어요. 저는 이렇게 했어요:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"private \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"void\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"DrawWater\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Matrix\"\n        }), \" world, \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Matrix\"\n        }), \" view, \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Matrix\"\n        }), \" projection, \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Matrix\"\n        }), \" reflectionView, \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"GameTime\"\n        }), \" gameTime)\\n{\\n    _waterShader.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"CurrentTechnique\"\n        }), \" = _waterShader.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"Techniques\"\n        }), \"[\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Water\\\"\"\n        }), \"];\\n\\n    _waterShader.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"Parameters\"\n        }), \"[\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"World\\\"\"\n        }), \"].\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"SetValue\"\n        }), \"(world);\\n    _waterShader.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"Parameters\"\n        }), \"[\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"WorldViewProjection\\\"\"\n        }), \"].\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"SetValue\"\n        }), \"(world * view * projection);\\n    _waterShader.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"Parameters\"\n        }), \"[\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"ReflectionView\\\"\"\n        }), \"].\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"SetValue\"\n        }), \"(reflectionView);\\n    _waterShader.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"Parameters\"\n        }), \"[\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Projection\\\"\"\n        }), \"].\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"SetValue\"\n        }), \"(projection);\\n            \\n    _waterShader.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"Parameters\"\n        }), \"[\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"ReflectionTexture\\\"\"\n        }), \"].\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"SetValue\"\n        }), \"(_reflectionRenderTarget);\\n    _waterShader.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"Parameters\"\n        }), \"[\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"RefractionTexture\\\"\"\n        }), \"].\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"SetValue\"\n        }), \"(_refractionRenderTarget);\\n    _waterShader.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"Parameters\"\n        }), \"[\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"DistortionMap\\\"\"\n        }), \"].\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"SetValue\"\n        }), \"(_distortionMap);\\n    _waterShader.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"Parameters\"\n        }), \"[\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"NormalMap\\\"\"\n        }), \"].\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"SetValue\"\n        }), \"(_normalMap);\\n    _waterShader.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"Parameters\"\n        }), \"[\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Tiling\\\"\"\n        }), \"].\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"SetValue\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Vector2\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"One\"\n        }), \" * 20f);\\n            \\n    _waterShader.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"Parameters\"\n        }), \"[\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"MoveFactor\\\"\"\n        }), \"].\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"SetValue\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"WaveSpeed\"\n        }), \" * (float)gameTime.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"TotalGameTime\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"TotalSeconds\"\n        }), \");\\n    _waterShader.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"Parameters\"\n        }), \"[\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"WaveStrength\\\"\"\n        }), \"].\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"SetValue\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.\"\n        }), \"01f);\\n            \\n    _waterShader.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"Parameters\"\n        }), \"[\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"CameraPosition\\\"\"\n        }), \"].\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"SetValue\"\n        }), \"(_freeCamera.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"Position\"\n        }), \");\\n    _waterShader.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"Parameters\"\n        }), \"[\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"LightPosition\\\"\"\n        }), \"].\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"SetValue\"\n        }), \"(_lightPosition);\\n    _waterShader.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"Parameters\"\n        }), \"[\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"LightColor\\\"\"\n        }), \"].\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"SetValue\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Color\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"White\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ToVector3\"\n        }), \"());\\n    _waterShader.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"Parameters\"\n        }), \"[\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Shininess\\\"\"\n        }), \"].\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"SetValue\"\n        }), \"(25f);\\n    _waterShader.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"Parameters\"\n        }), \"[\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"KSpecular\\\"\"\n        }), \"].\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"SetValue\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.\"\n        }), \"3f);\\n            \\n    _quad.\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Draw\"\n        }), \"(_waterShader);\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그리고 제 경우에는 다음과 같이 보입니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-20-HowtocreateWatershaderinMonogameXNA_4.png\",\n        alt: \"image\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 글이 모노게임 그래픽 애플리케이션에서 이 효과를 이해하고 구현하는 데 도움이 되었으면 좋겠어요.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-20-HowtocreateWatershaderinMonogameXNA"},"buildId":"PgdIX9e0tvkvkdAmDT6qR","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>