<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>모노게임 XNA에서 물 쉐이더를 만드는 방법 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-05-20-HowtocreateWatershaderinMonogameXNA" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="모노게임 XNA에서 물 쉐이더를 만드는 방법 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="모노게임 XNA에서 물 쉐이더를 만드는 방법 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-20-HowtocreateWatershaderinMonogameXNA_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-05-20-HowtocreateWatershaderinMonogameXNA" data-gatsby-head="true"/><meta name="twitter:title" content="모노게임 XNA에서 물 쉐이더를 만드는 방법 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-20-HowtocreateWatershaderinMonogameXNA_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-20 16:37" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-70e5ce89f3d962ac.js" defer=""></script><script src="/_next/static/GsgRekSb--BvxYwv9FPn6/_buildManifest.js" defer=""></script><script src="/_next/static/GsgRekSb--BvxYwv9FPn6/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">모노게임 XNA에서 물 쉐이더를 만드는 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="모노게임 XNA에서 물 쉐이더를 만드는 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 20, 2024</span><span class="posts_reading_time__f7YPP">26<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-20-HowtocreateWatershaderinMonogameXNA&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h1>소개</h1>
<p>이 기사에서는 Monogame/XNA에서 간단한 물 쉐이더를 만드는 기본 개념을 다룰 것입니다. 이 쉐이더는 플레이너 반사, 굴절, 프레넬 효과 및 반사 하이라이트를 사용할 것입니다. 작성 시점에서 Monogame 버전 3.8.1로 진행되었습니다. 자세히 살펴보고 싶다면 여기 소스 코드가 있습니다.</p>
<h1>기본 사항</h1>
<p>우리 쉐이더가 어떻게 작동하는지 더 잘 이해하기 위해 여러 단계로 나눠 설명하겠습니다:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>쿼드/플랫 표면 추가하기</li>
<li>반사 및 굴절 텍스처 추가하기 (프레넬 효과를 사용하여 둘 사이의 러핑)</li>
<li>왜곡 맵을 사용하여 작은 파도 시뮬레이션하기</li>
<li>광택을 위한 노말 맵 추가하기</li>
</ul>
<h1>그리기</h1>
<p>그려지는 순서는 다음과 같습니다:</p>
<ul>
<li>굴절 그리기</li>
<li>반사 그리기</li>
<li>물 그리기</li>
<li>장면에서 다른 개체 그리기</li>
</ul>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이 순서는 원하는 시각적 효과를 달성하기 위해 각 구성 요소가 올바른 순서로 렌더링되도록합니다.</p>
<h1>코드 설정</h1>
<p>우리의 워터 쉐이더 기술을 올바르게 구현하기 위해 코드에서 몇 가지 설정을 해야합니다. 설명을 간단히하기 위해 이미 정의된 QuadPrimitive 클래스를 사용할 것입니다. 이 클래스는 정점 버퍼(법선과 텍스처 좌표에 대한 정보를 보냄)와 인덱스 버퍼를 가집니다. 또한 FreeCamera 클래스를 사용하여 카메라 이동을 처리할 것이지만 이 튜토리얼의 주요 내용은 아니기 때문에 자세히 다루지 않겠습니다.</p>
<p>먼저 우리는 우리의 쿼드, 그의 월드 매트릭스, 높이 및 파도 속도를 생성할 것입니다. 나중에는 쉐이더 매개변수에서 파도 속도를 사용할 것입니다. 또한 이 높이는 반사와 굴절을 계산하는 중요한 요소가 될 것입니다. 게다가 우리는 쉐이더를 선언할 것입니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-csharp"><span class="hljs-comment">// 카메라</span>
<span class="hljs-keyword">private</span> FreeCamera _freeCamera;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> Vector3 _cameraInitialPosition = <span class="hljs-keyword">new</span>(<span class="hljs-number">0f</span>, <span class="hljs-number">50f</span>, <span class="hljs-number">300f</span>);

<span class="hljs-comment">// 물</span>
<span class="hljs-keyword">private</span> QuadPrimitive _quad;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">float</span> QuadHeight = <span class="hljs-number">0f</span>;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">float</span> WaveSpeed = <span class="hljs-number">0.05f</span>;
<span class="hljs-keyword">private</span> Matrix _quadWorld;
<span class="hljs-keyword">private</span> Effect _waterShader;
</code></pre>
<p>아울 Initialize 메소드는 다음과 같이 보여야 합니다:</p>
<pre><code class="hljs language-csharp"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Initialize</span>()</span>
{
  _graphicsDeviceManager.PreferredBackBufferWidth = GraphicsAdapter.DefaultAdapter.CurrentDisplayMode.Width - <span class="hljs-number">100</span>;
  _graphicsDeviceManager.PreferredBackBufferHeight = GraphicsAdapter.DefaultAdapter.CurrentDisplayMode.Height - <span class="hljs-number">100</span>;
  _graphicsDeviceManager.ApplyChanges();

  <span class="hljs-comment">// 카메라</span>
  _freeCamera = <span class="hljs-keyword">new</span> FreeCamera(GraphicsDevice.Viewport.AspectRatio, _cameraInitialPosition);

  <span class="hljs-comment">// 물</span>
  _quad = <span class="hljs-keyword">new</span> QuadPrimitive(GraphicsDevice);
  <span class="hljs-keyword">var</span> quadPosition = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">0f</span>, QuadHeight, <span class="hljs-number">0f</span>);
  _quadWorld = Matrix.CreateScale(<span class="hljs-number">3000f</span>, <span class="hljs-number">0f</span>, <span class="hljs-number">3000f</span>) * Matrix.CreateTranslation(quadPosition);

  <span class="hljs-keyword">base</span>.Initialize();
}
</code></pre>
<h1>평면 반사</h1>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>코드를 진행하기 전에 우리는 평면 반사가 어떻게 작동하는지 이해해야 합니다. 평면 반사의 예시를 살펴보겠습니다:</p>
<p><img src="/assets/img/2024-05-20-HowtocreateWatershaderinMonogameXNA_0.png" alt="Planar Reflection"></p>
<p>이 예시에서 우리는 반사면, 카메라, 그리고 어떤 객체가 주어졌을 때 반사가 이렇게 보일 것이라는 것을 볼 수 있습니다. 이것을 코드로 나중에 변환하기 위해, 반사 카메라의 시각에서 새로운 뷰 매트릭스를 계산해야 합니다.</p>
<h2>반사 카메라 위치</h2>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>먼저, 반사 카메라 위치를 계산하겠습니다. 이미 카메라 위치, 평면 위치 및 평면 법선을 알고 있으므로 카메라 위치에서 평면 위치를 빼면 뷰 방향 벡터를 얻을 수 있습니다:</p>
<p>뷰 방향 = 카메라 위치 - 평면 위치</p>
<p><img src="/assets/img/2024-05-20-HowtocreateWatershaderinMonogameXNA_1.png" alt="image"></p>
<p>또한 투영 벡터를 추가했는데 이것은 다음과 같습니다. 그런 다음 해당 투영의 길이를 사용하여 평면상의 해당 지점까지의 거리를 찾을 수 있습니다.
이제 우리는 직각 삼각형을 가지고 있습니다. 투영 길이는 다음과 같아야 합니다:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>투영 길이 = 시야 방향 * cos(각도)</p>
<p>각도는 평면 법선과 시야 방향 사이의 각도를 의미합니다.</p>
<p>간단하게 표현하면 다음과 같이 다시 쓸 수 있습니다:</p>
<p>투영 길이 = 내적(평면 법선, 시야 방향)</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>좋아요, 이제 우리에게는 프로젝션 길이가 있습니다. 이것을 사용하여 반사 카메라 위치를 얻을 수 있습니다:</p>
<p>반사 카메라 위치 = 카메라 위치 — 2 _ 평면 법선 _ 프로젝션 길이</p>
<h2>반사 카메라 뷰 매트릭스</h2>
<p>반사 카메라 뷰 매트릭스를 얻으려면 반사 카메라 포워드를 계산해야 합니다. 함수 Reflect(vector, normal)를 사용하여 특정 법선을 갖는 표면에서 벡터의 반사를 얻을 수 있습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>카메라 반사 벡터를 계산한 후, Reflection Camera Up을 계산하는 다음 단계입니다. 카메라의 위쪽 벡터를 반사면의 법선을 기준으로 반사하는 Vector3.Reflect 함수를 다시 사용할 것입니다.</p>
<p>Reflection Camera Up = Vector3.Reflect(Camera Up, Plane Normal)</p>
<p>Reflection Camera Position, Reflection Camera Forward 및 Reflection Camera Up 벡터가 모두 계산되었으므로 이제 Reflection Camera View Matrix를 구성하는 데 필요한 모든 구성 요소를 갖추게 되었습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>리플렉션 카메라 뷰 = Matrix.CreateLookAt(리플렉션 카메라 위치, 리플렉션 카메라 위치 + 리플렉션 카메라 전방, 리플렉션 카메라 위치)</p>
<h1>리플렉션 그리기</h1>
<p>이제 리플렉션 카메라 뷰 행렬의 필요 구성 요소를 계산했으므로, 일반적으로 RenderTarget2D와 같은 텍스처에 리플렉션을 그릴 수 있습니다. 이를 위해 코드에서 이전에 계산한 값을 렌더링 프로세스에 통합할 수 있습니다. 다음 코드 조각은 이를 어떻게 달성할 수 있는지 보여줍니다:</p>
<pre><code class="hljs language-js">private <span class="hljs-keyword">void</span> <span class="hljs-title class_">DrawReflection</span>(<span class="hljs-title class_">Matrix</span> world, <span class="hljs-title class_">Matrix</span> view, <span class="hljs-title class_">Matrix</span> projection, <span class="hljs-title class_">GameTime</span> gameTime)
{
    <span class="hljs-comment">// 렌더 타겟을 리플렉션 텍스처로 설정</span>
    <span class="hljs-title class_">GraphicsDevice</span>.<span class="hljs-title class_">SetRenderTarget</span>(_reflectionRenderTarget);
    <span class="hljs-title class_">GraphicsDevice</span>.<span class="hljs-title class_">Clear</span>(<span class="hljs-title class_">ClearOptions</span>.<span class="hljs-property">Target</span> |
    <span class="hljs-title class_">ClearOptions</span>.<span class="hljs-property">DepthBuffer</span>, <span class="hljs-title class_">Color</span>.<span class="hljs-property">CornflowerBlue</span>, 1f, <span class="hljs-number">0</span>);

    <span class="hljs-keyword">var</span> quadNormal = <span class="hljs-title class_">Vector3</span>.<span class="hljs-property">Up</span>;
    <span class="hljs-keyword">var</span> viewDirection = _freeCamera.<span class="hljs-property">Position</span> - _quadWorld.<span class="hljs-property">Translation</span>;
    <span class="hljs-keyword">var</span> projLength = <span class="hljs-title class_">Vector3</span>.<span class="hljs-title class_">Dot</span>(quadNormal, viewDirection);
    <span class="hljs-keyword">var</span> reflectionCamPos = _freeCamera.<span class="hljs-property">Position</span> - <span class="hljs-number">2</span> * quadNormal * projLength;
    <span class="hljs-keyword">var</span> reflectionCamForward = <span class="hljs-title class_">Vector3</span>.<span class="hljs-title class_">Reflect</span>(_freeCamera.<span class="hljs-property">FrontDirection</span>,
    quadNormal);
    <span class="hljs-keyword">var</span> reflectionCamUp = <span class="hljs-title class_">Vector3</span>.<span class="hljs-title class_">Reflect</span>(_freeCamera.<span class="hljs-property">UpDirection</span>, quadNormal);
    <span class="hljs-keyword">var</span> reflectionCamView = <span class="hljs-title class_">Matrix</span>.<span class="hljs-title class_">CreateLookAt</span>(reflectionCamPos,
                reflectionCamPos + reflectionCamForward, reflectionCamUp);

    <span class="hljs-comment">// 리플렉션 카메라 시점에서 씬 그리기</span>
    <span class="hljs-title class_">DrawScene</span>(reflectionCamView, projection, reflectionCamPos,
    _reflectionClippingPlane);

    <span class="hljs-comment">// 렌더 타겟을 기본(화면)으로 재설정</span>
    <span class="hljs-title class_">GraphicsDevice</span>.<span class="hljs-title class_">SetRenderTarget</span>(<span class="hljs-literal">null</span>);

    <span class="hljs-comment">// 물 그리기</span>
    <span class="hljs-title class_">DrawWater</span>(world, view, projection, reflectionCamView, gameTime);
}
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>DrawWater 메서드에서는 필요한 매개변수를 전달할 것이며, 이에 대해 나중에 자세히 다룰 것입니다.</p>
<h2>클리핑 평면</h2>
<p>클리핑 평면 _reflectionClippingPlane이 아직 설명되지 않았다는 것을 눈치채셨나요? 그 목적에 대해 자세히 살펴보겠습니다. 이 클리핑 평면은 수면 위에 있는 객체만 그릴 때 사용됩니다. 이를 통해 객체의 상단 반만이 물에 반사되어 실제 반사에서 관찰되는 것과 동일하게 됩니다. 다음과 같이 선언할 수 있습니다:</p>
<pre><code class="hljs language-js">private readonly <span class="hljs-title class_">Vector4</span> _reflectionClippingPlane = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vector4</span>(0f, 1f, 0f, -<span class="hljs-title class_">QuadHeight</span>);
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이 평면은 수학적 방정식 (Ax + By + Cz + D = 0)으로 정의됩니다. 여기서 (A, B, C)는 평면에 수직인 법선 벡터를 나타내고, D는 해당 법선 벡터를 따라 원점으로부터의 거리를 나타냅니다.</p>
<p>우리의 경우, 물 표면은 XZ 평면과 평행한 평면으로 작용하며, 그 법선 벡터는 직접 위쪽을 가리킵니다 (0, 1, 0).</p>
<p>우리는 물 속 객체를 다루는 셰이더를 위해 반사 클리핑 평면 방정식에 -QuadHeight 값을 활용합니다. 이 값은 나중에 픽셀 셰이더에서 clip 함수를 사용하여 Reflection Plane 아래의 픽셀을 클리핑할 때 사용됩니다. 다음은 예시입니다:</p>
<p><em>Uniforms</em></p>
<pre><code class="hljs language-js">float4 <span class="hljs-title class_">ClippingPlane</span>;

struct <span class="hljs-title class_">VertexShaderInput</span>
{
    float4 <span class="hljs-title class_">Position</span> : <span class="hljs-title class_">POSITION0</span>;
    float4 <span class="hljs-title class_">Normal</span> : <span class="hljs-variable constant_">NORMAL</span>;
};

struct <span class="hljs-title class_">VertexShaderOutput</span>
{
    float4 <span class="hljs-title class_">Position</span> : <span class="hljs-title class_">POSITION0</span>;
    float3 <span class="hljs-title class_">WorldPosition</span> : <span class="hljs-title class_">TEXCOORD0</span>;
    float3 <span class="hljs-title class_">Normal</span> : <span class="hljs-title class_">TEXCOORD1</span>;
    float4 <span class="hljs-title class_">Clipping</span> : <span class="hljs-title class_">TEXCOORD2</span>;
};

<span class="hljs-title class_">VertexShaderOutput</span> <span class="hljs-title class_">MainVS</span>(<span class="hljs-title class_">VertexShaderInput</span> input)
{
    <span class="hljs-title class_">VertexShaderOutput</span> output = (<span class="hljs-title class_">VertexShaderOutput</span>) <span class="hljs-number">0</span>;

    float4 worldPosition = <span class="hljs-title function_">mul</span>(input.<span class="hljs-property">Position</span>, <span class="hljs-title class_">World</span>);
    float4 viewPosition = <span class="hljs-title function_">mul</span>(worldPosition, <span class="hljs-title class_">View</span>);
    output.<span class="hljs-property">Position</span> = <span class="hljs-title function_">mul</span>(viewPosition, <span class="hljs-title class_">Projection</span>);
    output.<span class="hljs-property">WorldPosition</span> = worldPosition;
    output.<span class="hljs-property">Normal</span> = <span class="hljs-title function_">mul</span>(input.<span class="hljs-property">Normal</span>, <span class="hljs-title class_">InverseTransposeWorld</span>);
    <span class="hljs-comment">/*
    dot product를 사용하여 정점에서 클리핑 평면까지의 거리 계산
    이 결과 거리는 해당 픽셀을 픽셀 셰이더에서 버릴지 여부를 결정하는 데 사용됩니다
    */</span>
    output.<span class="hljs-property">Clipping</span> = <span class="hljs-title function_">dot</span>(worldPosition, <span class="hljs-title class_">ClippingPlane</span>);

    <span class="hljs-keyword">return</span> output;
}

float4 <span class="hljs-title class_">MainPS</span>(<span class="hljs-title class_">VertexShaderOutput</span> input) : <span class="hljs-title class_">COLOR0</span>
{
    <span class="hljs-title function_">clip</span>(input.<span class="hljs-property">Clipping</span>);

    <span class="hljs-comment">// 픽셀 셰이더의 나머지 부분</span>
}
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>클립 함수는 지정된 조건에 따라 픽셀을 삭제하는 기능을 담당합니다. 셰이더에서 -QuadHeight를 활용하여 물 표면 아래에 있는 물체를 나타내는 픽셀들이 렌더링 중에 삭제되어 최종 반사 이미지에서 클리핑되는 효과가 있습니다.</p>
<p>또한, 위쪽의 물 위에 있는 픽셀을 삭제하려는 경우에도 이 방법이 작동합니다. 이 경우 굴절을 위해 다음과 같이 설정할 수 있습니다:</p>
<pre><code class="hljs language-js">private readonly <span class="hljs-title class_">Vector4</span> _refractionClippingPlane = <span class="hljs-title function_">new</span>(0f, -1f, 0f, <span class="hljs-title class_">QuadHeight</span>);
</code></pre>
<h1>굴절</h1>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>리프렉션을 렌더 대상에 그리는 것은 반사를 렌더링하는 것과 비교할 때 간단한 프로세스입니다. 이 작업은 카메라의 관점에서 장면을 렌더링하면서 _refractionClippingPlane을 사용하여 수면 위의 픽셀을 버립니다.</p>
<pre><code class="hljs language-js">private <span class="hljs-keyword">void</span> <span class="hljs-title class_">DrawRefraction</span>()
{
    <span class="hljs-comment">// Refraction Texture을 렌더 타겟으로 설정</span>
    <span class="hljs-title class_">GraphicsDevice</span>.<span class="hljs-title class_">SetRenderTarget</span>(_refractionRenderTarget);
    <span class="hljs-title class_">GraphicsDevice</span>.<span class="hljs-title class_">Clear</span>(<span class="hljs-title class_">ClearOptions</span>.<span class="hljs-property">Target</span> | <span class="hljs-title class_">ClearOptions</span>.<span class="hljs-property">DepthBuffer</span>, <span class="hljs-title class_">Color</span>.<span class="hljs-property">CornflowerBlue</span>, 1f, <span class="hljs-number">0</span>);

    <span class="hljs-comment">// 수면 위에 있는 객체를 자르면서 장면을 일반적으로 그립니다</span>
    <span class="hljs-title class_">DrawScene</span>(_freeCamera.<span class="hljs-property">View</span>, _freeCamera.<span class="hljs-property">Projection</span>, _freeCamera.<span class="hljs-property">Position</span>, _refractionClippingPlane);

    <span class="hljs-comment">// 렌더 타겟을 기본값(화면)으로 재설정</span>
    <span class="hljs-title class_">GraphicsDevice</span>.<span class="hljs-title class_">SetRenderTarget</span>(<span class="hljs-literal">null</span>);
}
</code></pre>
<p>좋아요, 이제 실제 수 쉐이더로 진행하여 이 모든 내용이 어떻게 결합되는지 살펴봅시다.</p>
<h1>수 쉐이더</h1>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>먼저, 우리의 물 쉐이더에 필요한 균일 및 텍스처를 선언할 것입니다. 이에는 조명, 카메라 위치, 물의 움직임 및 사용할 다양한 맵에 대한 텍스처 샘플러를 위한 매개변수가 포함됩니다:</p>
<pre><code class="hljs language-js">float <span class="hljs-title class_">KSpecular</span>;
float <span class="hljs-title class_">Shininess</span>;
float3 <span class="hljs-title class_">LightPosition</span>;
float3 <span class="hljs-title class_">LightColor</span>;
float3 <span class="hljs-title class_">CameraPosition</span>;

float <span class="hljs-title class_">MoveFactor</span>;
float2 <span class="hljs-title class_">Tiling</span>;
float <span class="hljs-title class_">WaveStrength</span>;

float4x4 <span class="hljs-title class_">ReflectionView</span>;
float4x4 <span class="hljs-title class_">Projection</span>;
float4x4 <span class="hljs-title class_">WorldViewProjection</span>;
float4x4 <span class="hljs-title class_">World</span>;

texture <span class="hljs-title class_">RefractionTexture</span>;
sampler2D refractionSampler = sampler_state
{
    <span class="hljs-title class_">Texture</span> = (<span class="hljs-title class_">RefractionTexture</span>);
    <span class="hljs-variable constant_">ADDRESSU</span> = <span class="hljs-title class_">Clamp</span>;
    <span class="hljs-variable constant_">ADDRESSV</span> = <span class="hljs-title class_">Clamp</span>;
    <span class="hljs-variable constant_">MINFILTER</span> = <span class="hljs-title class_">Linear</span>;
    <span class="hljs-variable constant_">MAGFILTER</span> = <span class="hljs-title class_">Linear</span>;
    <span class="hljs-variable constant_">MIPFILTER</span> = <span class="hljs-title class_">Linear</span>;
};

texture <span class="hljs-title class_">ReflectionTexture</span>;
sampler2D reflectionSampler = sampler_state
{
    <span class="hljs-title class_">Texture</span> = (<span class="hljs-title class_">ReflectionTexture</span>);
    <span class="hljs-variable constant_">ADDRESSU</span> = <span class="hljs-title class_">Clamp</span>;
    <span class="hljs-variable constant_">ADDRESSV</span> = <span class="hljs-title class_">Clamp</span>;
    <span class="hljs-variable constant_">MINFILTER</span> = <span class="hljs-title class_">Linear</span>;
    <span class="hljs-variable constant_">MAGFILTER</span> = <span class="hljs-title class_">Linear</span>;
    <span class="hljs-variable constant_">MIPFILTER</span> = <span class="hljs-title class_">Linear</span>;
};

texture <span class="hljs-title class_">DistortionMap</span>;
sampler2D distortionSampler = sampler_state
{
    <span class="hljs-title class_">Texture</span> = (<span class="hljs-title class_">DistortionMap</span>);
    <span class="hljs-variable constant_">ADDRESSU</span> = <span class="hljs-variable constant_">WRAP</span>;
    <span class="hljs-variable constant_">ADDRESSV</span> = <span class="hljs-variable constant_">WRAP</span>;
    <span class="hljs-variable constant_">MINFILTER</span> = <span class="hljs-title class_">Linear</span>;
    <span class="hljs-variable constant_">MAGFILTER</span> = <span class="hljs-title class_">Linear</span>;
    <span class="hljs-variable constant_">MIPFILTER</span> = <span class="hljs-title class_">Linear</span>;
};

texture <span class="hljs-title class_">NormalMap</span>;
sampler2D normalMapSampler = sampler_state
{
    <span class="hljs-title class_">Texture</span> = (<span class="hljs-title class_">NormalMap</span>);
    <span class="hljs-variable constant_">ADDRESSU</span> = <span class="hljs-variable constant_">WRAP</span>;
    <span class="hljs-variable constant_">ADDRESSV</span> = <span class="hljs-variable constant_">WRAP</span>;
    <span class="hljs-variable constant_">MINFILTER</span> = <span class="hljs-title class_">Linear</span>;
    <span class="hljs-variable constant_">MAGFILTER</span> = <span class="hljs-title class_">Linear</span>;
    <span class="hljs-variable constant_">MIPFILTER</span> = <span class="hljs-title class_">Linear</span>;
};
</code></pre>
<p>이 쉐이더에서 KSpecular, Shininess, LightPosition, LightColor, CameraPosition과 같은 균일은 조명 및 시각화 매개변수를 정의합니다. MoveFactor, Tiling, WaveStrength는 물의 움직임과 외관을 제어합니다. ReflectionView, Projection, WorldViewProjection, World와 같은 행렬은 좌표를 변환하는 데 사용됩니다. refractionSampler, reflectionSampler, distortionSampler, normalMapSampler와 같은 텍스처 샘플러는 물 표면을 렌더링하는 데 필요한 해당 텍스처를 샘플링하는 데 사용됩니다.</p>
<p>왜곡 맵에는 다음과 같은 모양의 텍스처를 사용할 것입니다:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p><img src="/assets/img/2024-05-20-HowtocreateWatershaderinMonogameXNA_2.png" alt="이미지"></p>
<p>이 텍스처를 사용하여 텍스처 좌표를 왜곡시켜 물 표면에 작은 파도 효과를 만들 수 있습니다. 이 왜곡은 물의 동적이고 현실적인 외관을 모방하는 데 도움이 됩니다.</p>
<p>Normal Map으로는 다른 텍스처를 사용할 것입니다. 여기 예시가 있습니다:</p>
<p><img src="/assets/img/2024-05-20-HowtocreateWatershaderinMonogameXNA_3.png" alt="이미지"></p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이 지도에는 물과 빛이 상호 작용하는 방식을 시뮬레이션하기 위해 필수적인 표면 법선에 대한 정보가 포함되어 있습니다. 왜곡 맵이 텍스처 좌표를 조작하는 데 사용되는 반면, 법선 맵은 빛 관련 계산에 사용됩니다.</p>
<h2>버텍스 셰이더</h2>
<p>우리의 버텍스 셰이더에서는 버텍스 데이터를 픽셀 셰이더에 대비하여 준비하기 위해 변환합니다. 이 과정을 자세히 살펴보겠습니다:</p>
<pre><code class="hljs language-js">struct <span class="hljs-title class_">VertexShaderInput</span>
{
    float4 <span class="hljs-title class_">Position</span> : <span class="hljs-title class_">POSITION0</span>;
    float4 <span class="hljs-title class_">Normal</span> : <span class="hljs-variable constant_">NORMAL</span>;
    float2 <span class="hljs-title class_">TextureCoordinates</span> : <span class="hljs-title class_">TEXCOORD0</span>;
};

struct <span class="hljs-title class_">VertexShaderOutput</span>
{
    float4 <span class="hljs-title class_">Position</span> : <span class="hljs-variable constant_">SV_POSITION</span>;
    float2 <span class="hljs-title class_">TextureCoordinates</span> : <span class="hljs-title class_">TEXCOORD0</span>;
    float4 <span class="hljs-title class_">WorldPosition</span> : <span class="hljs-title class_">TEXCOORD1</span>;
    float4 <span class="hljs-title class_">Normal</span> : <span class="hljs-title class_">TEXCOORD2</span>;
    float4 <span class="hljs-title class_">ReflectionPosition</span> : <span class="hljs-title class_">TEXCOORD3</span>;
    float4 <span class="hljs-title class_">RefractionPosition</span> : <span class="hljs-title class_">TEXCOORD4</span>;
};

<span class="hljs-title class_">VertexShaderOutput</span> <span class="hljs-title class_">MainVS</span>(<span class="hljs-keyword">in</span> <span class="hljs-title class_">VertexShaderInput</span> input)
{
    <span class="hljs-title class_">VertexShaderOutput</span> output = (<span class="hljs-title class_">VertexShaderOutput</span>) <span class="hljs-number">0</span>;

    <span class="hljs-comment">// 버텍스 위치를 클립 공간에 변환합니다</span>
    output.<span class="hljs-property">Position</span> = <span class="hljs-title function_">mul</span>(input.<span class="hljs-property">Position</span>, <span class="hljs-title class_">WorldViewProjection</span>);

    <span class="hljs-comment">// 버텍스 위치를 월드 공간으로 변환합니다</span>
    output.<span class="hljs-property">WorldPosition</span> = <span class="hljs-title function_">mul</span>(input.<span class="hljs-property">Position</span>, <span class="hljs-title class_">World</span>);

    <span class="hljs-comment">// 어떤 변경도 없이 버텍스 법선을 전달합니다</span>
    output.<span class="hljs-property">Normal</span> = input.<span class="hljs-property">Normal</span>;

    <span class="hljs-comment">// 타일링 요소로 텍스처 좌표를 조정합니다</span>
    output.<span class="hljs-property">TextureCoordinates</span> = input.<span class="hljs-property">TextureCoordinates</span> * <span class="hljs-title class_">Tiling</span>;

    <span class="hljs-comment">// 반사 위치와 월드 매트릭스를 계산합니다</span>
    float4x4 reflectProjectWorld = <span class="hljs-title function_">mul</span>(<span class="hljs-title class_">ReflectionView</span>, <span class="hljs-title class_">Projection</span>);
    reflectProjectWorld = <span class="hljs-title function_">mul</span>(<span class="hljs-title class_">World</span>, reflectProjectWorld);
    output.<span class="hljs-property">ReflectionPosition</span> = <span class="hljs-title function_">mul</span>(input.<span class="hljs-property">Position</span>, reflectProjectWorld);

    <span class="hljs-comment">// 굴절 위치는 클립 공간 위치와 동일합니다</span>
    output.<span class="hljs-property">RefractionPosition</span> = output.<span class="hljs-property">Position</span>;

    <span class="hljs-keyword">return</span> output;
}
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>좋아요, 이제 정점 셰이더 부분을 완료했으니 픽셀 셰이더로 넘어갈 수 있겠네요.</p>
<h1>픽셀 셰이더</h1>
<h2>프로젝티브 텍스처 매핑</h2>
<p>먼저, 프로젝티브 굴절 텍스처 좌표를 정규화 장치 좌표 (NDC) 공간으로 변환합니다. 그런 다음, DirectX (DX) 텍스처를 정확히 샘플링할 수 있도록 xy 좌표를 적절하게 조정하여 크기를 조절하고 오프셋을 적용합니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-csharp"><span class="hljs-function">float4 <span class="hljs-title">MainPS</span>(<span class="hljs-params">VertexShaderOutput input</span>) : COLOR</span>
{
    <span class="hljs-comment">// 굴절</span>

    float4 refractionTexCoord;
    refractionTexCoord = input.RefractionPosition;

    <span class="hljs-comment">// 화면 위치 좌표</span>
    refractionTexCoord.xyz /= refractionTexCoord.w;

    <span class="hljs-comment">// 오프셋 조정</span>
    refractionTexCoord.x = <span class="hljs-number">0.5f</span> * refractionTexCoord.x + <span class="hljs-number">0.5f</span>;
    refractionTexCoord.y = <span class="hljs-number">-0.5f</span> * refractionTexCoord.y + <span class="hljs-number">0.5f</span>;

    <span class="hljs-comment">// 카메라로부터의 거리에 따라 굴절 더하기</span>
    refractionTexCoord.z = <span class="hljs-number">0.001f</span> / refractionTexCoord.z;
    float2 refractionTex = refractionTexCoord.xy - refractionTexCoord.z;

    <span class="hljs-comment">// 반사</span>

    float4 reflectionTexCoord;
    reflectionTexCoord = input.ReflectionPosition;

    <span class="hljs-comment">// 화면 위치 좌표</span>
    reflectionTexCoord.xyz /= reflectionTexCoord.w;

    <span class="hljs-comment">// 오프셋 조정</span>
    reflectionTexCoord.x = <span class="hljs-number">0.5f</span> * reflectionTexCoord.x + <span class="hljs-number">0.5f</span>;
    reflectionTexCoord.y = <span class="hljs-number">-0.5f</span> * reflectionTexCoord.y + <span class="hljs-number">0.5f</span>;

    <span class="hljs-comment">// 카메라로부터의 거리에 따라 반사 더하기</span>
    reflectionTexCoord.z = <span class="hljs-number">0.001f</span> / reflectionTexCoord.z;
    float2 reflectionTex = reflectionTexCoord.xy + reflectionTexCoord.z;

    <span class="hljs-comment">// 셰이더의 나머지 부분</span>
}
</code></pre>
<p>굴절에 대해서는 카메라로부터의 거리에 따라 텍스처 좌표를 조정하여 굴절 효과를 향상시킵니다. 이 조정을 통해 카메라로부터 더 멀리 있는 객체가 더 많이 굴절되어 물 속 장면을 더 현실적으로 렌더링할 수 있습니다.</p>
<p>반사에 대해서도 반사 텍스처 좌표를 NDC 공간으로 변환하고 카메라로부터의 거리에 따라 조정합니다. 이것은 더 뚜렷한 반사 효과를 만들어냄과 동시에, 카메라로부터 더 멀리 있는 객체가 더 강렬하게 반사되도록 도와줍니다.</p>
<h2>왜곡 맵 / DuDv 맵</h2>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이제 위에 표시된 왜곡 맵을 사용하여 반사 및 굴절 텍스처를 샘플링할 예정입니다.</p>
<p>이 맵은 빨간색과 녹색으로 이뤄진, 기본적으로 float2로 이루어져 있습니다. 그러나 이 값들은 항상 이 왜곡 맵에서 양수일 것이므로, 왜곡은 항상 양수일 것이고, 값은 (0.0, 0.0)에서 (1.0, 1.0) 사이입니다. 이 전체적인 리얼리티를 위해 양수와 음수 왜곡을 가질 수 있으면 좋을 것 같습니다.</p>
<p>이 값을 (-1.0, -1.0)에서 (1.0, 1.0) 사이로 변환하기 위해 단순히 2를 곱하고 1을 뺍니다. 그런 다음 이 값을 사용하여 간단히 반사 및 굴절 텍스처 좌표를 왜곡시킵니다.</p>
<pre><code class="hljs language-js">float2 distortion = (<span class="hljs-title function_">tex2D</span>(distortionSampler, <span class="hljs-title class_">Input</span>.<span class="hljs-property">TextureCoordinates</span>)).<span class="hljs-property">rg</span>
                    * <span class="hljs-number">2.0</span> - <span class="hljs-number">1.0</span>) * <span class="hljs-title class_">WaveStrength</span>;

reflectionTex += distortion;
refractionTex += distortion;
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이 왜곡은 기본 설정에서 조금 강할 수 있습니다. 그래서 우리는 이 왜곡을 약간 낮추기 위해 이전에 선언한 WaveStrength로 사용할 것입니다.</p>
<h2>파도 이동하기</h2>
<p>물이 움직이는 것처럼 보이게 하는 방법은 Distortion Map을 샘플링하는 위치에 오프셋을 사용하는 것입니다. 이미 이를 선언했는데, 그것이 MoveFactor이며 이 오프셋을 시간이 지남에 따라 변경할 것입니다.</p>
<p>이 효과를 얻기 위해 MoveFactor를 텍스처 좌표의 X 구성 요소에 추가하고 왜곡 맵을 샘플링합니다. 그 후 Y 구성 요소를 위해 두 번째 샘플링을 수행하여 다른 방향으로 추가 왜곡을 적용합니다. 이 프로세스는 왜곡 효과의 현실성을 강화하여 보다 동적인 외관을 만듭니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js">float2 distortedTexCoords = <span class="hljs-title function_">tex2D</span>(distortionSampler, <span class="hljs-title function_">float2</span>(input.<span class="hljs-property">TextureCoordinates</span>.<span class="hljs-property">x</span> + <span class="hljs-title class_">MoveFactor</span>, input.<span class="hljs-property">TextureCoordinates</span>.<span class="hljs-property">y</span>)) * <span class="hljs-number">0.01</span>;
distortedTexCoords = input.<span class="hljs-property">TextureCoordinates</span> + <span class="hljs-title function_">float2</span>(distortedTexCoords.<span class="hljs-property">x</span>, distortedTexCoords.<span class="hljs-property">y</span> + <span class="hljs-title class_">MoveFactor</span>);
float2 totalDistortion = (<span class="hljs-title function_">tex2D</span>(distortionSampler, distortedTexCoords).<span class="hljs-property">rg</span> * <span class="hljs-number">2.0</span> - <span class="hljs-number">1.0</span>) * <span class="hljs-title class_">WaveStrength</span>;

reflectionTex += totalDistortion;
refractionTex += totalDistortion;

<span class="hljs-comment">// Sample both texture using the distorted texture coordinates</span>
float4 reflectionColor = <span class="hljs-title function_">tex2D</span>(reflectionSampler, reflectionTex);
float4 refractionColor = <span class="hljs-title function_">tex2D</span>(refractionSampler, refractionTex);
</code></pre>
<p>첫 번째 줄에서 0.01을 곱하여 초기 샘플에 적용된 왜곡의 강도를 약간 조정했습니다.</p>
<h2>프레넬</h2>
<p>프레넬 효과가 무엇인지 모르겠다면, Dorian의 아주 좋은 설명을 보여드리겠습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이 효과를 구현하려면 다음과 같이 물에서부터의 뷰 방향과 법선을 사용해야 합니다:</p>
<pre><code class="hljs language-js">float3 viewDirection = <span class="hljs-title function_">normalize</span>(<span class="hljs-title class_">CameraPosition</span> - input.<span class="hljs-property">WorldPosition</span>.<span class="hljs-property">xyz</span>);
float refractiveFactor = <span class="hljs-title function_">dot</span>(viewDirection, <span class="hljs-title function_">normalize</span>(input.<span class="hljs-property">Normal</span>.<span class="hljs-property">xyz</span>));
</code></pre>
<p>그리고 결과물은 이전에 계산한 refractiveFactor 값을 사용하여 reflectionColor와 refractionColor 사이의 선형 보간값이 될 것입니다.</p>
<pre><code class="hljs language-js">float4 finalColor = <span class="hljs-title function_">lerp</span>(reflectionColor, refractionColor, refractiveFactor);
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>하지만 아직 끝나지 않았어요! 마지막으로 추가해야 할 것은 노멀 맵과 조명입니다.</p>
<h2>노멀 맵</h2>
<p>노멀 맵을 사용하여 물 표면의 다른 지점에서의 노멀을 나타낼 수 있습니다. 노멀 맵의 어떤 지점의 픽셀 색상은 그 지점에서의 물의 3D 노멀 벡터를 나타낼 수 있습니다. (R, G, B) -` (X, Y, Z). 저는 위에 보여드린 노멀 맵이 대부분 파란색인 이유는 파란 값이 위쪽 축을 나타내며, 우리의 경우에는 Y 축이기 때문입니다.</p>
<p>따라서, 우리는 노멀 맵 색의 파란 구성 요소를 노멀 벡터의 Y 구성 요소로 사용할 것이고, 노멀 맵의 빨간색과 초록색 구성 요소를 노멀 벡터의 X 및 Z 구성 요소로 사용할 수 있습니다. (R, G, B) -` (R, B, G).</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>여기서 유일한 문제는 절대 음수 색상을 가질 수 없기 때문에 법선 벡터의 구성 요소도 양수여야한다는 것입니다. Y 구성 요소에 대해서는 문제가 되지 않습니다. 왜냐하면 표면 법선이 어느 정도로든 위로 향하도록 항상 원하기 때문입니다. 그러나 법선이 항상 양의 X 및 Z 방향을 가리키도록 하길 바라는 것은 아닙니다. 법선은 음의 X 및 Z 방향을 가리키도록도 할 수 있어야 합니다.</p>
<p>이를 위해 왜곡 맵에 사용한 것과 동일한 변환을 사용할 것입니다. 2를 곱하고 1을 빼는 것입니다. 그리고 이런 식으로 법선 맵에서 법선 벡터를 추출할 수 있습니다:</p>
<pre><code class="hljs language-js">float4 normalMapColor = <span class="hljs-title function_">tex2D</span>(normalMapSampler, distortedTexCoords);
float3 normal = <span class="hljs-title function_">float3</span>(normalMapColor.<span class="hljs-property">r</span> * <span class="hljs-number">2.0</span> - <span class="hljs-number">1.0</span>, normalMapColor.<span class="hljs-property">b</span>, normalMapColor.<span class="hljs-property">g</span> * <span class="hljs-number">2.0</span> - <span class="hljs-number">1.0</span>);
normal = <span class="hljs-title function_">normalize</span>(normal);
</code></pre>
<p>이 추출된 법선 벡터를 활용하여 조명 효과를 계산할 것입니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>조명</h2>
<p>우리가 사용할 조명 기법은 기본적으로 Blinn Phong 모델입니다. 이에 대해 더 알고 싶다면 여기를 클릭해주세요. 여기서 사용되는 유니폼은 KSpecular, Shininess, LightPosition 및 LightColor 입니다.</p>
<p>먼저, 빛의 방향과 하프 벡터를 구하기 위해 빛 위치와 빛 및 보기 방향의 합을 나타내는 벡터를 정규화합니다.</p>
<pre><code class="hljs language-js">float3 lightDirection = <span class="hljs-title function_">normalize</span>(<span class="hljs-title class_">LightPosition</span> - input.<span class="hljs-property">WorldPosition</span>.<span class="hljs-property">xyz</span>);
float3 halfVector = <span class="hljs-title function_">normalize</span>(lightDirection + viewDirection);
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이 벡터들을 사용하여, 우리는 NdotL과 NdotH라는 닷 프로덕트를 계산합니다. 이는 각각 노멀 벡터와 라이트 방향, 그리고 노멀 벡터와 하프 벡터 사이의 각도를 나타냅니다.</p>
<pre><code class="hljs language-js">float <span class="hljs-title class_">NdotL</span> = <span class="hljs-title function_">saturate</span>(<span class="hljs-title function_">dot</span>(normal, lightDirection));
float <span class="hljs-title class_">NdotH</span> = <span class="hljs-title function_">saturate</span>(<span class="hljs-title function_">dot</span>(normal, halfVector));
</code></pre>
<p>이 닷 프로덕트를 이용하여, 우리는 Phong 반사 모델 방정식을 적용하여 스펙큘러 광원 기여도를 계산합니다.</p>
<pre><code class="hljs language-js">float3 specularLight = <span class="hljs-title function_">sign</span>(<span class="hljs-title class_">NdotL</span>) * <span class="hljs-title class_">KSpecular</span> * <span class="hljs-title class_">LightColor</span> * <span class="hljs-title function_">pow</span>(<span class="hljs-title class_">NdotH</span>, <span class="hljs-title class_">Shininess</span>);
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>마지막으로 반사광을 미리 계산된 반사 및 굴절 색과 결합하여 최종 색상 출력을 결정합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 최종 계산</span>
float4 finalColor = <span class="hljs-title function_">lerp</span>(reflectionColor, refractionColor, refractiveFactor) + <span class="hljs-title function_">float4</span>(specularLight, <span class="hljs-number">0.0</span>);
</code></pre>
<p>그게 다에요! 우리는 물 셰이더를 완전히 성공적으로 만들었습니다! 원하는 대로 매개변수를 조절할 수 있어요. 저는 이렇게 했어요:</p>
<pre><code class="hljs language-js">private <span class="hljs-keyword">void</span> <span class="hljs-title class_">DrawWater</span>(<span class="hljs-title class_">Matrix</span> world, <span class="hljs-title class_">Matrix</span> view, <span class="hljs-title class_">Matrix</span> projection, <span class="hljs-title class_">Matrix</span> reflectionView, <span class="hljs-title class_">GameTime</span> gameTime)
{
    _waterShader.<span class="hljs-property">CurrentTechnique</span> = _waterShader.<span class="hljs-property">Techniques</span>[<span class="hljs-string">"Water"</span>];

    _waterShader.<span class="hljs-property">Parameters</span>[<span class="hljs-string">"World"</span>].<span class="hljs-title class_">SetValue</span>(world);
    _waterShader.<span class="hljs-property">Parameters</span>[<span class="hljs-string">"WorldViewProjection"</span>].<span class="hljs-title class_">SetValue</span>(world * view * projection);
    _waterShader.<span class="hljs-property">Parameters</span>[<span class="hljs-string">"ReflectionView"</span>].<span class="hljs-title class_">SetValue</span>(reflectionView);
    _waterShader.<span class="hljs-property">Parameters</span>[<span class="hljs-string">"Projection"</span>].<span class="hljs-title class_">SetValue</span>(projection);

    _waterShader.<span class="hljs-property">Parameters</span>[<span class="hljs-string">"ReflectionTexture"</span>].<span class="hljs-title class_">SetValue</span>(_reflectionRenderTarget);
    _waterShader.<span class="hljs-property">Parameters</span>[<span class="hljs-string">"RefractionTexture"</span>].<span class="hljs-title class_">SetValue</span>(_refractionRenderTarget);
    _waterShader.<span class="hljs-property">Parameters</span>[<span class="hljs-string">"DistortionMap"</span>].<span class="hljs-title class_">SetValue</span>(_distortionMap);
    _waterShader.<span class="hljs-property">Parameters</span>[<span class="hljs-string">"NormalMap"</span>].<span class="hljs-title class_">SetValue</span>(_normalMap);
    _waterShader.<span class="hljs-property">Parameters</span>[<span class="hljs-string">"Tiling"</span>].<span class="hljs-title class_">SetValue</span>(<span class="hljs-title class_">Vector2</span>.<span class="hljs-property">One</span> * 20f);

    _waterShader.<span class="hljs-property">Parameters</span>[<span class="hljs-string">"MoveFactor"</span>].<span class="hljs-title class_">SetValue</span>(<span class="hljs-title class_">WaveSpeed</span> * (float)gameTime.<span class="hljs-property">TotalGameTime</span>.<span class="hljs-property">TotalSeconds</span>);
    _waterShader.<span class="hljs-property">Parameters</span>[<span class="hljs-string">"WaveStrength"</span>].<span class="hljs-title class_">SetValue</span>(<span class="hljs-number">0.</span>01f);

    _waterShader.<span class="hljs-property">Parameters</span>[<span class="hljs-string">"CameraPosition"</span>].<span class="hljs-title class_">SetValue</span>(_freeCamera.<span class="hljs-property">Position</span>);
    _waterShader.<span class="hljs-property">Parameters</span>[<span class="hljs-string">"LightPosition"</span>].<span class="hljs-title class_">SetValue</span>(_lightPosition);
    _waterShader.<span class="hljs-property">Parameters</span>[<span class="hljs-string">"LightColor"</span>].<span class="hljs-title class_">SetValue</span>(<span class="hljs-title class_">Color</span>.<span class="hljs-property">White</span>.<span class="hljs-title class_">ToVector3</span>());
    _waterShader.<span class="hljs-property">Parameters</span>[<span class="hljs-string">"Shininess"</span>].<span class="hljs-title class_">SetValue</span>(25f);
    _waterShader.<span class="hljs-property">Parameters</span>[<span class="hljs-string">"KSpecular"</span>].<span class="hljs-title class_">SetValue</span>(<span class="hljs-number">0.</span>3f);

    _quad.<span class="hljs-title class_">Draw</span>(_waterShader);
}
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>그리고 제 경우에는 다음과 같이 보입니다:</p>
<p><img src="/assets/img/2024-05-20-HowtocreateWatershaderinMonogameXNA_4.png" alt="image"></p>
<p>이 글이 모노게임 그래픽 애플리케이션에서 이 효과를 이해하고 구현하는 데 도움이 되었으면 좋겠어요.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"모노게임 XNA에서 물 쉐이더를 만드는 방법","description":"","date":"2024-05-20 16:37","slug":"2024-05-20-HowtocreateWatershaderinMonogameXNA","content":"\n# 소개\n\n이 기사에서는 Monogame/XNA에서 간단한 물 쉐이더를 만드는 기본 개념을 다룰 것입니다. 이 쉐이더는 플레이너 반사, 굴절, 프레넬 효과 및 반사 하이라이트를 사용할 것입니다. 작성 시점에서 Monogame 버전 3.8.1로 진행되었습니다. 자세히 살펴보고 싶다면 여기 소스 코드가 있습니다.\n\n# 기본 사항\n\n우리 쉐이더가 어떻게 작동하는지 더 잘 이해하기 위해 여러 단계로 나눠 설명하겠습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 쿼드/플랫 표면 추가하기\n- 반사 및 굴절 텍스처 추가하기 (프레넬 효과를 사용하여 둘 사이의 러핑)\n- 왜곡 맵을 사용하여 작은 파도 시뮬레이션하기\n- 광택을 위한 노말 맵 추가하기\n\n# 그리기\n\n그려지는 순서는 다음과 같습니다:\n\n- 굴절 그리기\n- 반사 그리기\n- 물 그리기\n- 장면에서 다른 개체 그리기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 순서는 원하는 시각적 효과를 달성하기 위해 각 구성 요소가 올바른 순서로 렌더링되도록합니다.\n\n# 코드 설정\n\n우리의 워터 쉐이더 기술을 올바르게 구현하기 위해 코드에서 몇 가지 설정을 해야합니다. 설명을 간단히하기 위해 이미 정의된 QuadPrimitive 클래스를 사용할 것입니다. 이 클래스는 정점 버퍼(법선과 텍스처 좌표에 대한 정보를 보냄)와 인덱스 버퍼를 가집니다. 또한 FreeCamera 클래스를 사용하여 카메라 이동을 처리할 것이지만 이 튜토리얼의 주요 내용은 아니기 때문에 자세히 다루지 않겠습니다.\n\n먼저 우리는 우리의 쿼드, 그의 월드 매트릭스, 높이 및 파도 속도를 생성할 것입니다. 나중에는 쉐이더 매개변수에서 파도 속도를 사용할 것입니다. 또한 이 높이는 반사와 굴절을 계산하는 중요한 요소가 될 것입니다. 게다가 우리는 쉐이더를 선언할 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```csharp\n// 카메라\nprivate FreeCamera _freeCamera;\nprivate readonly Vector3 _cameraInitialPosition = new(0f, 50f, 300f);\n\n// 물\nprivate QuadPrimitive _quad;\nprivate const float QuadHeight = 0f;\nprivate const float WaveSpeed = 0.05f;\nprivate Matrix _quadWorld;\nprivate Effect _waterShader;\n```\n\n아울 Initialize 메소드는 다음과 같이 보여야 합니다:\n\n```csharp\nprotected override void Initialize()\n{\n  _graphicsDeviceManager.PreferredBackBufferWidth = GraphicsAdapter.DefaultAdapter.CurrentDisplayMode.Width - 100;\n  _graphicsDeviceManager.PreferredBackBufferHeight = GraphicsAdapter.DefaultAdapter.CurrentDisplayMode.Height - 100;\n  _graphicsDeviceManager.ApplyChanges();\n\n  // 카메라\n  _freeCamera = new FreeCamera(GraphicsDevice.Viewport.AspectRatio, _cameraInitialPosition);\n\n  // 물\n  _quad = new QuadPrimitive(GraphicsDevice);\n  var quadPosition = new Vector3(0f, QuadHeight, 0f);\n  _quadWorld = Matrix.CreateScale(3000f, 0f, 3000f) * Matrix.CreateTranslation(quadPosition);\n\n  base.Initialize();\n}\n```\n\n# 평면 반사\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n코드를 진행하기 전에 우리는 평면 반사가 어떻게 작동하는지 이해해야 합니다. 평면 반사의 예시를 살펴보겠습니다:\n\n![Planar Reflection](/assets/img/2024-05-20-HowtocreateWatershaderinMonogameXNA_0.png)\n\n이 예시에서 우리는 반사면, 카메라, 그리고 어떤 객체가 주어졌을 때 반사가 이렇게 보일 것이라는 것을 볼 수 있습니다. 이것을 코드로 나중에 변환하기 위해, 반사 카메라의 시각에서 새로운 뷰 매트릭스를 계산해야 합니다.\n\n## 반사 카메라 위치\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n먼저, 반사 카메라 위치를 계산하겠습니다. 이미 카메라 위치, 평면 위치 및 평면 법선을 알고 있으므로 카메라 위치에서 평면 위치를 빼면 뷰 방향 벡터를 얻을 수 있습니다:\n\n뷰 방향 = 카메라 위치 - 평면 위치\n\n![image](/assets/img/2024-05-20-HowtocreateWatershaderinMonogameXNA_1.png)\n\n또한 투영 벡터를 추가했는데 이것은 다음과 같습니다. 그런 다음 해당 투영의 길이를 사용하여 평면상의 해당 지점까지의 거리를 찾을 수 있습니다.\n이제 우리는 직각 삼각형을 가지고 있습니다. 투영 길이는 다음과 같아야 합니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n투영 길이 = 시야 방향 \\* cos(각도)\n\n각도는 평면 법선과 시야 방향 사이의 각도를 의미합니다.\n\n간단하게 표현하면 다음과 같이 다시 쓸 수 있습니다:\n\n투영 길이 = 내적(평면 법선, 시야 방향)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n좋아요, 이제 우리에게는 프로젝션 길이가 있습니다. 이것을 사용하여 반사 카메라 위치를 얻을 수 있습니다:\n\n반사 카메라 위치 = 카메라 위치 — 2 _ 평면 법선 _ 프로젝션 길이\n\n## 반사 카메라 뷰 매트릭스\n\n반사 카메라 뷰 매트릭스를 얻으려면 반사 카메라 포워드를 계산해야 합니다. 함수 Reflect(vector, normal)를 사용하여 특정 법선을 갖는 표면에서 벡터의 반사를 얻을 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n카메라 반사 벡터를 계산한 후, Reflection Camera Up을 계산하는 다음 단계입니다. 카메라의 위쪽 벡터를 반사면의 법선을 기준으로 반사하는 Vector3.Reflect 함수를 다시 사용할 것입니다.\n\nReflection Camera Up = Vector3.Reflect(Camera Up, Plane Normal)\n\nReflection Camera Position, Reflection Camera Forward 및 Reflection Camera Up 벡터가 모두 계산되었으므로 이제 Reflection Camera View Matrix를 구성하는 데 필요한 모든 구성 요소를 갖추게 되었습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n리플렉션 카메라 뷰 = Matrix.CreateLookAt(리플렉션 카메라 위치, 리플렉션 카메라 위치 + 리플렉션 카메라 전방, 리플렉션 카메라 위치)\n\n# 리플렉션 그리기\n\n이제 리플렉션 카메라 뷰 행렬의 필요 구성 요소를 계산했으므로, 일반적으로 RenderTarget2D와 같은 텍스처에 리플렉션을 그릴 수 있습니다. 이를 위해 코드에서 이전에 계산한 값을 렌더링 프로세스에 통합할 수 있습니다. 다음 코드 조각은 이를 어떻게 달성할 수 있는지 보여줍니다:\n\n```js\nprivate void DrawReflection(Matrix world, Matrix view, Matrix projection, GameTime gameTime)\n{\n    // 렌더 타겟을 리플렉션 텍스처로 설정\n    GraphicsDevice.SetRenderTarget(_reflectionRenderTarget);\n    GraphicsDevice.Clear(ClearOptions.Target |\n    ClearOptions.DepthBuffer, Color.CornflowerBlue, 1f, 0);\n\n    var quadNormal = Vector3.Up;\n    var viewDirection = _freeCamera.Position - _quadWorld.Translation;\n    var projLength = Vector3.Dot(quadNormal, viewDirection);\n    var reflectionCamPos = _freeCamera.Position - 2 * quadNormal * projLength;\n    var reflectionCamForward = Vector3.Reflect(_freeCamera.FrontDirection,\n    quadNormal);\n    var reflectionCamUp = Vector3.Reflect(_freeCamera.UpDirection, quadNormal);\n    var reflectionCamView = Matrix.CreateLookAt(reflectionCamPos,\n                reflectionCamPos + reflectionCamForward, reflectionCamUp);\n\n    // 리플렉션 카메라 시점에서 씬 그리기\n    DrawScene(reflectionCamView, projection, reflectionCamPos,\n    _reflectionClippingPlane);\n\n    // 렌더 타겟을 기본(화면)으로 재설정\n    GraphicsDevice.SetRenderTarget(null);\n\n    // 물 그리기\n    DrawWater(world, view, projection, reflectionCamView, gameTime);\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nDrawWater 메서드에서는 필요한 매개변수를 전달할 것이며, 이에 대해 나중에 자세히 다룰 것입니다.\n\n## 클리핑 평면\n\n클리핑 평면 \\_reflectionClippingPlane이 아직 설명되지 않았다는 것을 눈치채셨나요? 그 목적에 대해 자세히 살펴보겠습니다. 이 클리핑 평면은 수면 위에 있는 객체만 그릴 때 사용됩니다. 이를 통해 객체의 상단 반만이 물에 반사되어 실제 반사에서 관찰되는 것과 동일하게 됩니다. 다음과 같이 선언할 수 있습니다:\n\n```js\nprivate readonly Vector4 _reflectionClippingPlane = new Vector4(0f, 1f, 0f, -QuadHeight);\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 평면은 수학적 방정식 (Ax + By + Cz + D = 0)으로 정의됩니다. 여기서 (A, B, C)는 평면에 수직인 법선 벡터를 나타내고, D는 해당 법선 벡터를 따라 원점으로부터의 거리를 나타냅니다.\n\n우리의 경우, 물 표면은 XZ 평면과 평행한 평면으로 작용하며, 그 법선 벡터는 직접 위쪽을 가리킵니다 (0, 1, 0).\n\n우리는 물 속 객체를 다루는 셰이더를 위해 반사 클리핑 평면 방정식에 -QuadHeight 값을 활용합니다. 이 값은 나중에 픽셀 셰이더에서 clip 함수를 사용하여 Reflection Plane 아래의 픽셀을 클리핑할 때 사용됩니다. 다음은 예시입니다:\n\n_Uniforms_\n\n```js\nfloat4 ClippingPlane;\n\nstruct VertexShaderInput\n{\n    float4 Position : POSITION0;\n    float4 Normal : NORMAL;\n};\n\nstruct VertexShaderOutput\n{\n    float4 Position : POSITION0;\n    float3 WorldPosition : TEXCOORD0;\n    float3 Normal : TEXCOORD1;\n    float4 Clipping : TEXCOORD2;\n};\n\nVertexShaderOutput MainVS(VertexShaderInput input)\n{\n    VertexShaderOutput output = (VertexShaderOutput) 0;\n\n    float4 worldPosition = mul(input.Position, World);\n    float4 viewPosition = mul(worldPosition, View);\n    output.Position = mul(viewPosition, Projection);\n    output.WorldPosition = worldPosition;\n    output.Normal = mul(input.Normal, InverseTransposeWorld);\n    /*\n    dot product를 사용하여 정점에서 클리핑 평면까지의 거리 계산\n    이 결과 거리는 해당 픽셀을 픽셀 셰이더에서 버릴지 여부를 결정하는 데 사용됩니다\n    */\n    output.Clipping = dot(worldPosition, ClippingPlane);\n\n    return output;\n}\n\nfloat4 MainPS(VertexShaderOutput input) : COLOR0\n{\n    clip(input.Clipping);\n\n    // 픽셀 셰이더의 나머지 부분\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n클립 함수는 지정된 조건에 따라 픽셀을 삭제하는 기능을 담당합니다. 셰이더에서 -QuadHeight를 활용하여 물 표면 아래에 있는 물체를 나타내는 픽셀들이 렌더링 중에 삭제되어 최종 반사 이미지에서 클리핑되는 효과가 있습니다.\n\n또한, 위쪽의 물 위에 있는 픽셀을 삭제하려는 경우에도 이 방법이 작동합니다. 이 경우 굴절을 위해 다음과 같이 설정할 수 있습니다:\n\n```js\nprivate readonly Vector4 _refractionClippingPlane = new(0f, -1f, 0f, QuadHeight);\n```\n\n# 굴절\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n리프렉션을 렌더 대상에 그리는 것은 반사를 렌더링하는 것과 비교할 때 간단한 프로세스입니다. 이 작업은 카메라의 관점에서 장면을 렌더링하면서 \\_refractionClippingPlane을 사용하여 수면 위의 픽셀을 버립니다.\n\n```js\nprivate void DrawRefraction()\n{\n    // Refraction Texture을 렌더 타겟으로 설정\n    GraphicsDevice.SetRenderTarget(_refractionRenderTarget);\n    GraphicsDevice.Clear(ClearOptions.Target | ClearOptions.DepthBuffer, Color.CornflowerBlue, 1f, 0);\n\n    // 수면 위에 있는 객체를 자르면서 장면을 일반적으로 그립니다\n    DrawScene(_freeCamera.View, _freeCamera.Projection, _freeCamera.Position, _refractionClippingPlane);\n\n    // 렌더 타겟을 기본값(화면)으로 재설정\n    GraphicsDevice.SetRenderTarget(null);\n}\n```\n\n좋아요, 이제 실제 수 쉐이더로 진행하여 이 모든 내용이 어떻게 결합되는지 살펴봅시다.\n\n# 수 쉐이더\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n먼저, 우리의 물 쉐이더에 필요한 균일 및 텍스처를 선언할 것입니다. 이에는 조명, 카메라 위치, 물의 움직임 및 사용할 다양한 맵에 대한 텍스처 샘플러를 위한 매개변수가 포함됩니다:\n\n```js\nfloat KSpecular;\nfloat Shininess;\nfloat3 LightPosition;\nfloat3 LightColor;\nfloat3 CameraPosition;\n\nfloat MoveFactor;\nfloat2 Tiling;\nfloat WaveStrength;\n\nfloat4x4 ReflectionView;\nfloat4x4 Projection;\nfloat4x4 WorldViewProjection;\nfloat4x4 World;\n\ntexture RefractionTexture;\nsampler2D refractionSampler = sampler_state\n{\n    Texture = (RefractionTexture);\n    ADDRESSU = Clamp;\n    ADDRESSV = Clamp;\n    MINFILTER = Linear;\n    MAGFILTER = Linear;\n    MIPFILTER = Linear;\n};\n\ntexture ReflectionTexture;\nsampler2D reflectionSampler = sampler_state\n{\n    Texture = (ReflectionTexture);\n    ADDRESSU = Clamp;\n    ADDRESSV = Clamp;\n    MINFILTER = Linear;\n    MAGFILTER = Linear;\n    MIPFILTER = Linear;\n};\n\ntexture DistortionMap;\nsampler2D distortionSampler = sampler_state\n{\n    Texture = (DistortionMap);\n    ADDRESSU = WRAP;\n    ADDRESSV = WRAP;\n    MINFILTER = Linear;\n    MAGFILTER = Linear;\n    MIPFILTER = Linear;\n};\n\ntexture NormalMap;\nsampler2D normalMapSampler = sampler_state\n{\n    Texture = (NormalMap);\n    ADDRESSU = WRAP;\n    ADDRESSV = WRAP;\n    MINFILTER = Linear;\n    MAGFILTER = Linear;\n    MIPFILTER = Linear;\n};\n```\n\n이 쉐이더에서 KSpecular, Shininess, LightPosition, LightColor, CameraPosition과 같은 균일은 조명 및 시각화 매개변수를 정의합니다. MoveFactor, Tiling, WaveStrength는 물의 움직임과 외관을 제어합니다. ReflectionView, Projection, WorldViewProjection, World와 같은 행렬은 좌표를 변환하는 데 사용됩니다. refractionSampler, reflectionSampler, distortionSampler, normalMapSampler와 같은 텍스처 샘플러는 물 표면을 렌더링하는 데 필요한 해당 텍스처를 샘플링하는 데 사용됩니다.\n\n왜곡 맵에는 다음과 같은 모양의 텍스처를 사용할 것입니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/assets/img/2024-05-20-HowtocreateWatershaderinMonogameXNA_2.png)\n\n이 텍스처를 사용하여 텍스처 좌표를 왜곡시켜 물 표면에 작은 파도 효과를 만들 수 있습니다. 이 왜곡은 물의 동적이고 현실적인 외관을 모방하는 데 도움이 됩니다.\n\nNormal Map으로는 다른 텍스처를 사용할 것입니다. 여기 예시가 있습니다:\n\n![이미지](/assets/img/2024-05-20-HowtocreateWatershaderinMonogameXNA_3.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 지도에는 물과 빛이 상호 작용하는 방식을 시뮬레이션하기 위해 필수적인 표면 법선에 대한 정보가 포함되어 있습니다. 왜곡 맵이 텍스처 좌표를 조작하는 데 사용되는 반면, 법선 맵은 빛 관련 계산에 사용됩니다.\n\n## 버텍스 셰이더\n\n우리의 버텍스 셰이더에서는 버텍스 데이터를 픽셀 셰이더에 대비하여 준비하기 위해 변환합니다. 이 과정을 자세히 살펴보겠습니다:\n\n```js\nstruct VertexShaderInput\n{\n    float4 Position : POSITION0;\n    float4 Normal : NORMAL;\n    float2 TextureCoordinates : TEXCOORD0;\n};\n\nstruct VertexShaderOutput\n{\n    float4 Position : SV_POSITION;\n    float2 TextureCoordinates : TEXCOORD0;\n    float4 WorldPosition : TEXCOORD1;\n    float4 Normal : TEXCOORD2;\n    float4 ReflectionPosition : TEXCOORD3;\n    float4 RefractionPosition : TEXCOORD4;\n};\n\nVertexShaderOutput MainVS(in VertexShaderInput input)\n{\n    VertexShaderOutput output = (VertexShaderOutput) 0;\n\n    // 버텍스 위치를 클립 공간에 변환합니다\n    output.Position = mul(input.Position, WorldViewProjection);\n\n    // 버텍스 위치를 월드 공간으로 변환합니다\n    output.WorldPosition = mul(input.Position, World);\n\n    // 어떤 변경도 없이 버텍스 법선을 전달합니다\n    output.Normal = input.Normal;\n\n    // 타일링 요소로 텍스처 좌표를 조정합니다\n    output.TextureCoordinates = input.TextureCoordinates * Tiling;\n\n    // 반사 위치와 월드 매트릭스를 계산합니다\n    float4x4 reflectProjectWorld = mul(ReflectionView, Projection);\n    reflectProjectWorld = mul(World, reflectProjectWorld);\n    output.ReflectionPosition = mul(input.Position, reflectProjectWorld);\n\n    // 굴절 위치는 클립 공간 위치와 동일합니다\n    output.RefractionPosition = output.Position;\n\n    return output;\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n좋아요, 이제 정점 셰이더 부분을 완료했으니 픽셀 셰이더로 넘어갈 수 있겠네요.\n\n# 픽셀 셰이더\n\n## 프로젝티브 텍스처 매핑\n\n먼저, 프로젝티브 굴절 텍스처 좌표를 정규화 장치 좌표 (NDC) 공간으로 변환합니다. 그런 다음, DirectX (DX) 텍스처를 정확히 샘플링할 수 있도록 xy 좌표를 적절하게 조정하여 크기를 조절하고 오프셋을 적용합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```csharp\nfloat4 MainPS(VertexShaderOutput input) : COLOR\n{\n    // 굴절\n\n    float4 refractionTexCoord;\n    refractionTexCoord = input.RefractionPosition;\n\n    // 화면 위치 좌표\n    refractionTexCoord.xyz /= refractionTexCoord.w;\n\n    // 오프셋 조정\n    refractionTexCoord.x = 0.5f * refractionTexCoord.x + 0.5f;\n    refractionTexCoord.y = -0.5f * refractionTexCoord.y + 0.5f;\n\n    // 카메라로부터의 거리에 따라 굴절 더하기\n    refractionTexCoord.z = 0.001f / refractionTexCoord.z;\n    float2 refractionTex = refractionTexCoord.xy - refractionTexCoord.z;\n\n    // 반사\n\n    float4 reflectionTexCoord;\n    reflectionTexCoord = input.ReflectionPosition;\n\n    // 화면 위치 좌표\n    reflectionTexCoord.xyz /= reflectionTexCoord.w;\n\n    // 오프셋 조정\n    reflectionTexCoord.x = 0.5f * reflectionTexCoord.x + 0.5f;\n    reflectionTexCoord.y = -0.5f * reflectionTexCoord.y + 0.5f;\n\n    // 카메라로부터의 거리에 따라 반사 더하기\n    reflectionTexCoord.z = 0.001f / reflectionTexCoord.z;\n    float2 reflectionTex = reflectionTexCoord.xy + reflectionTexCoord.z;\n\n    // 셰이더의 나머지 부분\n}\n```\n\n굴절에 대해서는 카메라로부터의 거리에 따라 텍스처 좌표를 조정하여 굴절 효과를 향상시킵니다. 이 조정을 통해 카메라로부터 더 멀리 있는 객체가 더 많이 굴절되어 물 속 장면을 더 현실적으로 렌더링할 수 있습니다.\n\n반사에 대해서도 반사 텍스처 좌표를 NDC 공간으로 변환하고 카메라로부터의 거리에 따라 조정합니다. 이것은 더 뚜렷한 반사 효과를 만들어냄과 동시에, 카메라로부터 더 멀리 있는 객체가 더 강렬하게 반사되도록 도와줍니다.\n\n## 왜곡 맵 / DuDv 맵\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 위에 표시된 왜곡 맵을 사용하여 반사 및 굴절 텍스처를 샘플링할 예정입니다.\n\n이 맵은 빨간색과 녹색으로 이뤄진, 기본적으로 float2로 이루어져 있습니다. 그러나 이 값들은 항상 이 왜곡 맵에서 양수일 것이므로, 왜곡은 항상 양수일 것이고, 값은 (0.0, 0.0)에서 (1.0, 1.0) 사이입니다. 이 전체적인 리얼리티를 위해 양수와 음수 왜곡을 가질 수 있으면 좋을 것 같습니다.\n\n이 값을 (-1.0, -1.0)에서 (1.0, 1.0) 사이로 변환하기 위해 단순히 2를 곱하고 1을 뺍니다. 그런 다음 이 값을 사용하여 간단히 반사 및 굴절 텍스처 좌표를 왜곡시킵니다.\n\n```js\nfloat2 distortion = (tex2D(distortionSampler, Input.TextureCoordinates)).rg\n                    * 2.0 - 1.0) * WaveStrength;\n\nreflectionTex += distortion;\nrefractionTex += distortion;\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 왜곡은 기본 설정에서 조금 강할 수 있습니다. 그래서 우리는 이 왜곡을 약간 낮추기 위해 이전에 선언한 WaveStrength로 사용할 것입니다.\n\n## 파도 이동하기\n\n물이 움직이는 것처럼 보이게 하는 방법은 Distortion Map을 샘플링하는 위치에 오프셋을 사용하는 것입니다. 이미 이를 선언했는데, 그것이 MoveFactor이며 이 오프셋을 시간이 지남에 따라 변경할 것입니다.\n\n이 효과를 얻기 위해 MoveFactor를 텍스처 좌표의 X 구성 요소에 추가하고 왜곡 맵을 샘플링합니다. 그 후 Y 구성 요소를 위해 두 번째 샘플링을 수행하여 다른 방향으로 추가 왜곡을 적용합니다. 이 프로세스는 왜곡 효과의 현실성을 강화하여 보다 동적인 외관을 만듭니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nfloat2 distortedTexCoords = tex2D(distortionSampler, float2(input.TextureCoordinates.x + MoveFactor, input.TextureCoordinates.y)) * 0.01;\ndistortedTexCoords = input.TextureCoordinates + float2(distortedTexCoords.x, distortedTexCoords.y + MoveFactor);\nfloat2 totalDistortion = (tex2D(distortionSampler, distortedTexCoords).rg * 2.0 - 1.0) * WaveStrength;\n\nreflectionTex += totalDistortion;\nrefractionTex += totalDistortion;\n\n// Sample both texture using the distorted texture coordinates\nfloat4 reflectionColor = tex2D(reflectionSampler, reflectionTex);\nfloat4 refractionColor = tex2D(refractionSampler, refractionTex);\n```\n\n첫 번째 줄에서 0.01을 곱하여 초기 샘플에 적용된 왜곡의 강도를 약간 조정했습니다.\n\n## 프레넬\n\n프레넬 효과가 무엇인지 모르겠다면, Dorian의 아주 좋은 설명을 보여드리겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 효과를 구현하려면 다음과 같이 물에서부터의 뷰 방향과 법선을 사용해야 합니다:\n\n```js\nfloat3 viewDirection = normalize(CameraPosition - input.WorldPosition.xyz);\nfloat refractiveFactor = dot(viewDirection, normalize(input.Normal.xyz));\n```\n\n그리고 결과물은 이전에 계산한 refractiveFactor 값을 사용하여 reflectionColor와 refractionColor 사이의 선형 보간값이 될 것입니다.\n\n```js\nfloat4 finalColor = lerp(reflectionColor, refractionColor, refractiveFactor);\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n하지만 아직 끝나지 않았어요! 마지막으로 추가해야 할 것은 노멀 맵과 조명입니다.\n\n## 노멀 맵\n\n노멀 맵을 사용하여 물 표면의 다른 지점에서의 노멀을 나타낼 수 있습니다. 노멀 맵의 어떤 지점의 픽셀 색상은 그 지점에서의 물의 3D 노멀 벡터를 나타낼 수 있습니다. (R, G, B) -` (X, Y, Z). 저는 위에 보여드린 노멀 맵이 대부분 파란색인 이유는 파란 값이 위쪽 축을 나타내며, 우리의 경우에는 Y 축이기 때문입니다.\n\n따라서, 우리는 노멀 맵 색의 파란 구성 요소를 노멀 벡터의 Y 구성 요소로 사용할 것이고, 노멀 맵의 빨간색과 초록색 구성 요소를 노멀 벡터의 X 및 Z 구성 요소로 사용할 수 있습니다. (R, G, B) -` (R, B, G).\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기서 유일한 문제는 절대 음수 색상을 가질 수 없기 때문에 법선 벡터의 구성 요소도 양수여야한다는 것입니다. Y 구성 요소에 대해서는 문제가 되지 않습니다. 왜냐하면 표면 법선이 어느 정도로든 위로 향하도록 항상 원하기 때문입니다. 그러나 법선이 항상 양의 X 및 Z 방향을 가리키도록 하길 바라는 것은 아닙니다. 법선은 음의 X 및 Z 방향을 가리키도록도 할 수 있어야 합니다.\n\n이를 위해 왜곡 맵에 사용한 것과 동일한 변환을 사용할 것입니다. 2를 곱하고 1을 빼는 것입니다. 그리고 이런 식으로 법선 맵에서 법선 벡터를 추출할 수 있습니다:\n\n```js\nfloat4 normalMapColor = tex2D(normalMapSampler, distortedTexCoords);\nfloat3 normal = float3(normalMapColor.r * 2.0 - 1.0, normalMapColor.b, normalMapColor.g * 2.0 - 1.0);\nnormal = normalize(normal);\n```\n\n이 추출된 법선 벡터를 활용하여 조명 효과를 계산할 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 조명\n\n우리가 사용할 조명 기법은 기본적으로 Blinn Phong 모델입니다. 이에 대해 더 알고 싶다면 여기를 클릭해주세요. 여기서 사용되는 유니폼은 KSpecular, Shininess, LightPosition 및 LightColor 입니다.\n\n먼저, 빛의 방향과 하프 벡터를 구하기 위해 빛 위치와 빛 및 보기 방향의 합을 나타내는 벡터를 정규화합니다.\n\n```js\nfloat3 lightDirection = normalize(LightPosition - input.WorldPosition.xyz);\nfloat3 halfVector = normalize(lightDirection + viewDirection);\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 벡터들을 사용하여, 우리는 NdotL과 NdotH라는 닷 프로덕트를 계산합니다. 이는 각각 노멀 벡터와 라이트 방향, 그리고 노멀 벡터와 하프 벡터 사이의 각도를 나타냅니다.\n\n```js\nfloat NdotL = saturate(dot(normal, lightDirection));\nfloat NdotH = saturate(dot(normal, halfVector));\n```\n\n이 닷 프로덕트를 이용하여, 우리는 Phong 반사 모델 방정식을 적용하여 스펙큘러 광원 기여도를 계산합니다.\n\n```js\nfloat3 specularLight = sign(NdotL) * KSpecular * LightColor * pow(NdotH, Shininess);\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n마지막으로 반사광을 미리 계산된 반사 및 굴절 색과 결합하여 최종 색상 출력을 결정합니다.\n\n```js\n// 최종 계산\nfloat4 finalColor = lerp(reflectionColor, refractionColor, refractiveFactor) + float4(specularLight, 0.0);\n```\n\n그게 다에요! 우리는 물 셰이더를 완전히 성공적으로 만들었습니다! 원하는 대로 매개변수를 조절할 수 있어요. 저는 이렇게 했어요:\n\n```js\nprivate void DrawWater(Matrix world, Matrix view, Matrix projection, Matrix reflectionView, GameTime gameTime)\n{\n    _waterShader.CurrentTechnique = _waterShader.Techniques[\"Water\"];\n\n    _waterShader.Parameters[\"World\"].SetValue(world);\n    _waterShader.Parameters[\"WorldViewProjection\"].SetValue(world * view * projection);\n    _waterShader.Parameters[\"ReflectionView\"].SetValue(reflectionView);\n    _waterShader.Parameters[\"Projection\"].SetValue(projection);\n\n    _waterShader.Parameters[\"ReflectionTexture\"].SetValue(_reflectionRenderTarget);\n    _waterShader.Parameters[\"RefractionTexture\"].SetValue(_refractionRenderTarget);\n    _waterShader.Parameters[\"DistortionMap\"].SetValue(_distortionMap);\n    _waterShader.Parameters[\"NormalMap\"].SetValue(_normalMap);\n    _waterShader.Parameters[\"Tiling\"].SetValue(Vector2.One * 20f);\n\n    _waterShader.Parameters[\"MoveFactor\"].SetValue(WaveSpeed * (float)gameTime.TotalGameTime.TotalSeconds);\n    _waterShader.Parameters[\"WaveStrength\"].SetValue(0.01f);\n\n    _waterShader.Parameters[\"CameraPosition\"].SetValue(_freeCamera.Position);\n    _waterShader.Parameters[\"LightPosition\"].SetValue(_lightPosition);\n    _waterShader.Parameters[\"LightColor\"].SetValue(Color.White.ToVector3());\n    _waterShader.Parameters[\"Shininess\"].SetValue(25f);\n    _waterShader.Parameters[\"KSpecular\"].SetValue(0.3f);\n\n    _quad.Draw(_waterShader);\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그리고 제 경우에는 다음과 같이 보입니다:\n\n![image](/assets/img/2024-05-20-HowtocreateWatershaderinMonogameXNA_4.png)\n\n이 글이 모노게임 그래픽 애플리케이션에서 이 효과를 이해하고 구현하는 데 도움이 되었으면 좋겠어요.\n","ogImage":{"url":"/assets/img/2024-05-20-HowtocreateWatershaderinMonogameXNA_0.png"},"coverImage":"/assets/img/2024-05-20-HowtocreateWatershaderinMonogameXNA_0.png","tag":["Tech"],"readingTime":26},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch1\u003e소개\u003c/h1\u003e\n\u003cp\u003e이 기사에서는 Monogame/XNA에서 간단한 물 쉐이더를 만드는 기본 개념을 다룰 것입니다. 이 쉐이더는 플레이너 반사, 굴절, 프레넬 효과 및 반사 하이라이트를 사용할 것입니다. 작성 시점에서 Monogame 버전 3.8.1로 진행되었습니다. 자세히 살펴보고 싶다면 여기 소스 코드가 있습니다.\u003c/p\u003e\n\u003ch1\u003e기본 사항\u003c/h1\u003e\n\u003cp\u003e우리 쉐이더가 어떻게 작동하는지 더 잘 이해하기 위해 여러 단계로 나눠 설명하겠습니다:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003e쿼드/플랫 표면 추가하기\u003c/li\u003e\n\u003cli\u003e반사 및 굴절 텍스처 추가하기 (프레넬 효과를 사용하여 둘 사이의 러핑)\u003c/li\u003e\n\u003cli\u003e왜곡 맵을 사용하여 작은 파도 시뮬레이션하기\u003c/li\u003e\n\u003cli\u003e광택을 위한 노말 맵 추가하기\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e그리기\u003c/h1\u003e\n\u003cp\u003e그려지는 순서는 다음과 같습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e굴절 그리기\u003c/li\u003e\n\u003cli\u003e반사 그리기\u003c/li\u003e\n\u003cli\u003e물 그리기\u003c/li\u003e\n\u003cli\u003e장면에서 다른 개체 그리기\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이 순서는 원하는 시각적 효과를 달성하기 위해 각 구성 요소가 올바른 순서로 렌더링되도록합니다.\u003c/p\u003e\n\u003ch1\u003e코드 설정\u003c/h1\u003e\n\u003cp\u003e우리의 워터 쉐이더 기술을 올바르게 구현하기 위해 코드에서 몇 가지 설정을 해야합니다. 설명을 간단히하기 위해 이미 정의된 QuadPrimitive 클래스를 사용할 것입니다. 이 클래스는 정점 버퍼(법선과 텍스처 좌표에 대한 정보를 보냄)와 인덱스 버퍼를 가집니다. 또한 FreeCamera 클래스를 사용하여 카메라 이동을 처리할 것이지만 이 튜토리얼의 주요 내용은 아니기 때문에 자세히 다루지 않겠습니다.\u003c/p\u003e\n\u003cp\u003e먼저 우리는 우리의 쿼드, 그의 월드 매트릭스, 높이 및 파도 속도를 생성할 것입니다. 나중에는 쉐이더 매개변수에서 파도 속도를 사용할 것입니다. 또한 이 높이는 반사와 굴절을 계산하는 중요한 요소가 될 것입니다. 게다가 우리는 쉐이더를 선언할 것입니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-csharp\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 카메라\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e FreeCamera _freeCamera;\n\u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ereadonly\u003c/span\u003e Vector3 _cameraInitialPosition = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0f\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e50f\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e300f\u003c/span\u003e);\n\n\u003cspan class=\"hljs-comment\"\u003e// 물\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e QuadPrimitive _quad;\n\u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003efloat\u003c/span\u003e QuadHeight = \u003cspan class=\"hljs-number\"\u003e0f\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003efloat\u003c/span\u003e WaveSpeed = \u003cspan class=\"hljs-number\"\u003e0.05f\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e Matrix _quadWorld;\n\u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e Effect _waterShader;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e아울 Initialize 메소드는 다음과 같이 보여야 합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-csharp\"\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003eprotected\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eoverride\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eInitialize\u003c/span\u003e()\u003c/span\u003e\n{\n  _graphicsDeviceManager.PreferredBackBufferWidth = GraphicsAdapter.DefaultAdapter.CurrentDisplayMode.Width - \u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e;\n  _graphicsDeviceManager.PreferredBackBufferHeight = GraphicsAdapter.DefaultAdapter.CurrentDisplayMode.Height - \u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e;\n  _graphicsDeviceManager.ApplyChanges();\n\n  \u003cspan class=\"hljs-comment\"\u003e// 카메라\u003c/span\u003e\n  _freeCamera = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e FreeCamera(GraphicsDevice.Viewport.AspectRatio, _cameraInitialPosition);\n\n  \u003cspan class=\"hljs-comment\"\u003e// 물\u003c/span\u003e\n  _quad = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e QuadPrimitive(GraphicsDevice);\n  \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e quadPosition = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e Vector3(\u003cspan class=\"hljs-number\"\u003e0f\u003c/span\u003e, QuadHeight, \u003cspan class=\"hljs-number\"\u003e0f\u003c/span\u003e);\n  _quadWorld = Matrix.CreateScale(\u003cspan class=\"hljs-number\"\u003e3000f\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0f\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3000f\u003c/span\u003e) * Matrix.CreateTranslation(quadPosition);\n\n  \u003cspan class=\"hljs-keyword\"\u003ebase\u003c/span\u003e.Initialize();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e평면 반사\u003c/h1\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e코드를 진행하기 전에 우리는 평면 반사가 어떻게 작동하는지 이해해야 합니다. 평면 반사의 예시를 살펴보겠습니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-20-HowtocreateWatershaderinMonogameXNA_0.png\" alt=\"Planar Reflection\"\u003e\u003c/p\u003e\n\u003cp\u003e이 예시에서 우리는 반사면, 카메라, 그리고 어떤 객체가 주어졌을 때 반사가 이렇게 보일 것이라는 것을 볼 수 있습니다. 이것을 코드로 나중에 변환하기 위해, 반사 카메라의 시각에서 새로운 뷰 매트릭스를 계산해야 합니다.\u003c/p\u003e\n\u003ch2\u003e반사 카메라 위치\u003c/h2\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e먼저, 반사 카메라 위치를 계산하겠습니다. 이미 카메라 위치, 평면 위치 및 평면 법선을 알고 있으므로 카메라 위치에서 평면 위치를 빼면 뷰 방향 벡터를 얻을 수 있습니다:\u003c/p\u003e\n\u003cp\u003e뷰 방향 = 카메라 위치 - 평면 위치\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-20-HowtocreateWatershaderinMonogameXNA_1.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e또한 투영 벡터를 추가했는데 이것은 다음과 같습니다. 그런 다음 해당 투영의 길이를 사용하여 평면상의 해당 지점까지의 거리를 찾을 수 있습니다.\n이제 우리는 직각 삼각형을 가지고 있습니다. 투영 길이는 다음과 같아야 합니다:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e투영 길이 = 시야 방향 * cos(각도)\u003c/p\u003e\n\u003cp\u003e각도는 평면 법선과 시야 방향 사이의 각도를 의미합니다.\u003c/p\u003e\n\u003cp\u003e간단하게 표현하면 다음과 같이 다시 쓸 수 있습니다:\u003c/p\u003e\n\u003cp\u003e투영 길이 = 내적(평면 법선, 시야 방향)\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e좋아요, 이제 우리에게는 프로젝션 길이가 있습니다. 이것을 사용하여 반사 카메라 위치를 얻을 수 있습니다:\u003c/p\u003e\n\u003cp\u003e반사 카메라 위치 = 카메라 위치 — 2 _ 평면 법선 _ 프로젝션 길이\u003c/p\u003e\n\u003ch2\u003e반사 카메라 뷰 매트릭스\u003c/h2\u003e\n\u003cp\u003e반사 카메라 뷰 매트릭스를 얻으려면 반사 카메라 포워드를 계산해야 합니다. 함수 Reflect(vector, normal)를 사용하여 특정 법선을 갖는 표면에서 벡터의 반사를 얻을 수 있습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e카메라 반사 벡터를 계산한 후, Reflection Camera Up을 계산하는 다음 단계입니다. 카메라의 위쪽 벡터를 반사면의 법선을 기준으로 반사하는 Vector3.Reflect 함수를 다시 사용할 것입니다.\u003c/p\u003e\n\u003cp\u003eReflection Camera Up = Vector3.Reflect(Camera Up, Plane Normal)\u003c/p\u003e\n\u003cp\u003eReflection Camera Position, Reflection Camera Forward 및 Reflection Camera Up 벡터가 모두 계산되었으므로 이제 Reflection Camera View Matrix를 구성하는 데 필요한 모든 구성 요소를 갖추게 되었습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e리플렉션 카메라 뷰 = Matrix.CreateLookAt(리플렉션 카메라 위치, 리플렉션 카메라 위치 + 리플렉션 카메라 전방, 리플렉션 카메라 위치)\u003c/p\u003e\n\u003ch1\u003e리플렉션 그리기\u003c/h1\u003e\n\u003cp\u003e이제 리플렉션 카메라 뷰 행렬의 필요 구성 요소를 계산했으므로, 일반적으로 RenderTarget2D와 같은 텍스처에 리플렉션을 그릴 수 있습니다. 이를 위해 코드에서 이전에 계산한 값을 렌더링 프로세스에 통합할 수 있습니다. 다음 코드 조각은 이를 어떻게 달성할 수 있는지 보여줍니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eprivate \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDrawReflection\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eMatrix\u003c/span\u003e world, \u003cspan class=\"hljs-title class_\"\u003eMatrix\u003c/span\u003e view, \u003cspan class=\"hljs-title class_\"\u003eMatrix\u003c/span\u003e projection, \u003cspan class=\"hljs-title class_\"\u003eGameTime\u003c/span\u003e gameTime)\n{\n    \u003cspan class=\"hljs-comment\"\u003e// 렌더 타겟을 리플렉션 텍스처로 설정\u003c/span\u003e\n    \u003cspan class=\"hljs-title class_\"\u003eGraphicsDevice\u003c/span\u003e.\u003cspan class=\"hljs-title class_\"\u003eSetRenderTarget\u003c/span\u003e(_reflectionRenderTarget);\n    \u003cspan class=\"hljs-title class_\"\u003eGraphicsDevice\u003c/span\u003e.\u003cspan class=\"hljs-title class_\"\u003eClear\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eClearOptions\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eTarget\u003c/span\u003e |\n    \u003cspan class=\"hljs-title class_\"\u003eClearOptions\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eDepthBuffer\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eColor\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eCornflowerBlue\u003c/span\u003e, 1f, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e);\n\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e quadNormal = \u003cspan class=\"hljs-title class_\"\u003eVector3\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eUp\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e viewDirection = _freeCamera.\u003cspan class=\"hljs-property\"\u003ePosition\u003c/span\u003e - _quadWorld.\u003cspan class=\"hljs-property\"\u003eTranslation\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e projLength = \u003cspan class=\"hljs-title class_\"\u003eVector3\u003c/span\u003e.\u003cspan class=\"hljs-title class_\"\u003eDot\u003c/span\u003e(quadNormal, viewDirection);\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e reflectionCamPos = _freeCamera.\u003cspan class=\"hljs-property\"\u003ePosition\u003c/span\u003e - \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e * quadNormal * projLength;\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e reflectionCamForward = \u003cspan class=\"hljs-title class_\"\u003eVector3\u003c/span\u003e.\u003cspan class=\"hljs-title class_\"\u003eReflect\u003c/span\u003e(_freeCamera.\u003cspan class=\"hljs-property\"\u003eFrontDirection\u003c/span\u003e,\n    quadNormal);\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e reflectionCamUp = \u003cspan class=\"hljs-title class_\"\u003eVector3\u003c/span\u003e.\u003cspan class=\"hljs-title class_\"\u003eReflect\u003c/span\u003e(_freeCamera.\u003cspan class=\"hljs-property\"\u003eUpDirection\u003c/span\u003e, quadNormal);\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e reflectionCamView = \u003cspan class=\"hljs-title class_\"\u003eMatrix\u003c/span\u003e.\u003cspan class=\"hljs-title class_\"\u003eCreateLookAt\u003c/span\u003e(reflectionCamPos,\n                reflectionCamPos + reflectionCamForward, reflectionCamUp);\n\n    \u003cspan class=\"hljs-comment\"\u003e// 리플렉션 카메라 시점에서 씬 그리기\u003c/span\u003e\n    \u003cspan class=\"hljs-title class_\"\u003eDrawScene\u003c/span\u003e(reflectionCamView, projection, reflectionCamPos,\n    _reflectionClippingPlane);\n\n    \u003cspan class=\"hljs-comment\"\u003e// 렌더 타겟을 기본(화면)으로 재설정\u003c/span\u003e\n    \u003cspan class=\"hljs-title class_\"\u003eGraphicsDevice\u003c/span\u003e.\u003cspan class=\"hljs-title class_\"\u003eSetRenderTarget\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e);\n\n    \u003cspan class=\"hljs-comment\"\u003e// 물 그리기\u003c/span\u003e\n    \u003cspan class=\"hljs-title class_\"\u003eDrawWater\u003c/span\u003e(world, view, projection, reflectionCamView, gameTime);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eDrawWater 메서드에서는 필요한 매개변수를 전달할 것이며, 이에 대해 나중에 자세히 다룰 것입니다.\u003c/p\u003e\n\u003ch2\u003e클리핑 평면\u003c/h2\u003e\n\u003cp\u003e클리핑 평면 _reflectionClippingPlane이 아직 설명되지 않았다는 것을 눈치채셨나요? 그 목적에 대해 자세히 살펴보겠습니다. 이 클리핑 평면은 수면 위에 있는 객체만 그릴 때 사용됩니다. 이를 통해 객체의 상단 반만이 물에 반사되어 실제 반사에서 관찰되는 것과 동일하게 됩니다. 다음과 같이 선언할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eprivate readonly \u003cspan class=\"hljs-title class_\"\u003eVector4\u003c/span\u003e _reflectionClippingPlane = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eVector4\u003c/span\u003e(0f, 1f, 0f, -\u003cspan class=\"hljs-title class_\"\u003eQuadHeight\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이 평면은 수학적 방정식 (Ax + By + Cz + D = 0)으로 정의됩니다. 여기서 (A, B, C)는 평면에 수직인 법선 벡터를 나타내고, D는 해당 법선 벡터를 따라 원점으로부터의 거리를 나타냅니다.\u003c/p\u003e\n\u003cp\u003e우리의 경우, 물 표면은 XZ 평면과 평행한 평면으로 작용하며, 그 법선 벡터는 직접 위쪽을 가리킵니다 (0, 1, 0).\u003c/p\u003e\n\u003cp\u003e우리는 물 속 객체를 다루는 셰이더를 위해 반사 클리핑 평면 방정식에 -QuadHeight 값을 활용합니다. 이 값은 나중에 픽셀 셰이더에서 clip 함수를 사용하여 Reflection Plane 아래의 픽셀을 클리핑할 때 사용됩니다. 다음은 예시입니다:\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eUniforms\u003c/em\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003efloat4 \u003cspan class=\"hljs-title class_\"\u003eClippingPlane\u003c/span\u003e;\n\nstruct \u003cspan class=\"hljs-title class_\"\u003eVertexShaderInput\u003c/span\u003e\n{\n    float4 \u003cspan class=\"hljs-title class_\"\u003ePosition\u003c/span\u003e : \u003cspan class=\"hljs-title class_\"\u003ePOSITION0\u003c/span\u003e;\n    float4 \u003cspan class=\"hljs-title class_\"\u003eNormal\u003c/span\u003e : \u003cspan class=\"hljs-variable constant_\"\u003eNORMAL\u003c/span\u003e;\n};\n\nstruct \u003cspan class=\"hljs-title class_\"\u003eVertexShaderOutput\u003c/span\u003e\n{\n    float4 \u003cspan class=\"hljs-title class_\"\u003ePosition\u003c/span\u003e : \u003cspan class=\"hljs-title class_\"\u003ePOSITION0\u003c/span\u003e;\n    float3 \u003cspan class=\"hljs-title class_\"\u003eWorldPosition\u003c/span\u003e : \u003cspan class=\"hljs-title class_\"\u003eTEXCOORD0\u003c/span\u003e;\n    float3 \u003cspan class=\"hljs-title class_\"\u003eNormal\u003c/span\u003e : \u003cspan class=\"hljs-title class_\"\u003eTEXCOORD1\u003c/span\u003e;\n    float4 \u003cspan class=\"hljs-title class_\"\u003eClipping\u003c/span\u003e : \u003cspan class=\"hljs-title class_\"\u003eTEXCOORD2\u003c/span\u003e;\n};\n\n\u003cspan class=\"hljs-title class_\"\u003eVertexShaderOutput\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMainVS\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eVertexShaderInput\u003c/span\u003e input)\n{\n    \u003cspan class=\"hljs-title class_\"\u003eVertexShaderOutput\u003c/span\u003e output = (\u003cspan class=\"hljs-title class_\"\u003eVertexShaderOutput\u003c/span\u003e) \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n\n    float4 worldPosition = \u003cspan class=\"hljs-title function_\"\u003emul\u003c/span\u003e(input.\u003cspan class=\"hljs-property\"\u003ePosition\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eWorld\u003c/span\u003e);\n    float4 viewPosition = \u003cspan class=\"hljs-title function_\"\u003emul\u003c/span\u003e(worldPosition, \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e);\n    output.\u003cspan class=\"hljs-property\"\u003ePosition\u003c/span\u003e = \u003cspan class=\"hljs-title function_\"\u003emul\u003c/span\u003e(viewPosition, \u003cspan class=\"hljs-title class_\"\u003eProjection\u003c/span\u003e);\n    output.\u003cspan class=\"hljs-property\"\u003eWorldPosition\u003c/span\u003e = worldPosition;\n    output.\u003cspan class=\"hljs-property\"\u003eNormal\u003c/span\u003e = \u003cspan class=\"hljs-title function_\"\u003emul\u003c/span\u003e(input.\u003cspan class=\"hljs-property\"\u003eNormal\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eInverseTransposeWorld\u003c/span\u003e);\n    \u003cspan class=\"hljs-comment\"\u003e/*\n    dot product를 사용하여 정점에서 클리핑 평면까지의 거리 계산\n    이 결과 거리는 해당 픽셀을 픽셀 셰이더에서 버릴지 여부를 결정하는 데 사용됩니다\n    */\u003c/span\u003e\n    output.\u003cspan class=\"hljs-property\"\u003eClipping\u003c/span\u003e = \u003cspan class=\"hljs-title function_\"\u003edot\u003c/span\u003e(worldPosition, \u003cspan class=\"hljs-title class_\"\u003eClippingPlane\u003c/span\u003e);\n\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e output;\n}\n\nfloat4 \u003cspan class=\"hljs-title class_\"\u003eMainPS\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eVertexShaderOutput\u003c/span\u003e input) : \u003cspan class=\"hljs-title class_\"\u003eCOLOR0\u003c/span\u003e\n{\n    \u003cspan class=\"hljs-title function_\"\u003eclip\u003c/span\u003e(input.\u003cspan class=\"hljs-property\"\u003eClipping\u003c/span\u003e);\n\n    \u003cspan class=\"hljs-comment\"\u003e// 픽셀 셰이더의 나머지 부분\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e클립 함수는 지정된 조건에 따라 픽셀을 삭제하는 기능을 담당합니다. 셰이더에서 -QuadHeight를 활용하여 물 표면 아래에 있는 물체를 나타내는 픽셀들이 렌더링 중에 삭제되어 최종 반사 이미지에서 클리핑되는 효과가 있습니다.\u003c/p\u003e\n\u003cp\u003e또한, 위쪽의 물 위에 있는 픽셀을 삭제하려는 경우에도 이 방법이 작동합니다. 이 경우 굴절을 위해 다음과 같이 설정할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eprivate readonly \u003cspan class=\"hljs-title class_\"\u003eVector4\u003c/span\u003e _refractionClippingPlane = \u003cspan class=\"hljs-title function_\"\u003enew\u003c/span\u003e(0f, -1f, 0f, \u003cspan class=\"hljs-title class_\"\u003eQuadHeight\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e굴절\u003c/h1\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e리프렉션을 렌더 대상에 그리는 것은 반사를 렌더링하는 것과 비교할 때 간단한 프로세스입니다. 이 작업은 카메라의 관점에서 장면을 렌더링하면서 _refractionClippingPlane을 사용하여 수면 위의 픽셀을 버립니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eprivate \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDrawRefraction\u003c/span\u003e()\n{\n    \u003cspan class=\"hljs-comment\"\u003e// Refraction Texture을 렌더 타겟으로 설정\u003c/span\u003e\n    \u003cspan class=\"hljs-title class_\"\u003eGraphicsDevice\u003c/span\u003e.\u003cspan class=\"hljs-title class_\"\u003eSetRenderTarget\u003c/span\u003e(_refractionRenderTarget);\n    \u003cspan class=\"hljs-title class_\"\u003eGraphicsDevice\u003c/span\u003e.\u003cspan class=\"hljs-title class_\"\u003eClear\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eClearOptions\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eTarget\u003c/span\u003e | \u003cspan class=\"hljs-title class_\"\u003eClearOptions\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eDepthBuffer\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eColor\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eCornflowerBlue\u003c/span\u003e, 1f, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e);\n\n    \u003cspan class=\"hljs-comment\"\u003e// 수면 위에 있는 객체를 자르면서 장면을 일반적으로 그립니다\u003c/span\u003e\n    \u003cspan class=\"hljs-title class_\"\u003eDrawScene\u003c/span\u003e(_freeCamera.\u003cspan class=\"hljs-property\"\u003eView\u003c/span\u003e, _freeCamera.\u003cspan class=\"hljs-property\"\u003eProjection\u003c/span\u003e, _freeCamera.\u003cspan class=\"hljs-property\"\u003ePosition\u003c/span\u003e, _refractionClippingPlane);\n\n    \u003cspan class=\"hljs-comment\"\u003e// 렌더 타겟을 기본값(화면)으로 재설정\u003c/span\u003e\n    \u003cspan class=\"hljs-title class_\"\u003eGraphicsDevice\u003c/span\u003e.\u003cspan class=\"hljs-title class_\"\u003eSetRenderTarget\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e좋아요, 이제 실제 수 쉐이더로 진행하여 이 모든 내용이 어떻게 결합되는지 살펴봅시다.\u003c/p\u003e\n\u003ch1\u003e수 쉐이더\u003c/h1\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e먼저, 우리의 물 쉐이더에 필요한 균일 및 텍스처를 선언할 것입니다. 이에는 조명, 카메라 위치, 물의 움직임 및 사용할 다양한 맵에 대한 텍스처 샘플러를 위한 매개변수가 포함됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003efloat \u003cspan class=\"hljs-title class_\"\u003eKSpecular\u003c/span\u003e;\nfloat \u003cspan class=\"hljs-title class_\"\u003eShininess\u003c/span\u003e;\nfloat3 \u003cspan class=\"hljs-title class_\"\u003eLightPosition\u003c/span\u003e;\nfloat3 \u003cspan class=\"hljs-title class_\"\u003eLightColor\u003c/span\u003e;\nfloat3 \u003cspan class=\"hljs-title class_\"\u003eCameraPosition\u003c/span\u003e;\n\nfloat \u003cspan class=\"hljs-title class_\"\u003eMoveFactor\u003c/span\u003e;\nfloat2 \u003cspan class=\"hljs-title class_\"\u003eTiling\u003c/span\u003e;\nfloat \u003cspan class=\"hljs-title class_\"\u003eWaveStrength\u003c/span\u003e;\n\nfloat4x4 \u003cspan class=\"hljs-title class_\"\u003eReflectionView\u003c/span\u003e;\nfloat4x4 \u003cspan class=\"hljs-title class_\"\u003eProjection\u003c/span\u003e;\nfloat4x4 \u003cspan class=\"hljs-title class_\"\u003eWorldViewProjection\u003c/span\u003e;\nfloat4x4 \u003cspan class=\"hljs-title class_\"\u003eWorld\u003c/span\u003e;\n\ntexture \u003cspan class=\"hljs-title class_\"\u003eRefractionTexture\u003c/span\u003e;\nsampler2D refractionSampler = sampler_state\n{\n    \u003cspan class=\"hljs-title class_\"\u003eTexture\u003c/span\u003e = (\u003cspan class=\"hljs-title class_\"\u003eRefractionTexture\u003c/span\u003e);\n    \u003cspan class=\"hljs-variable constant_\"\u003eADDRESSU\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eClamp\u003c/span\u003e;\n    \u003cspan class=\"hljs-variable constant_\"\u003eADDRESSV\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eClamp\u003c/span\u003e;\n    \u003cspan class=\"hljs-variable constant_\"\u003eMINFILTER\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eLinear\u003c/span\u003e;\n    \u003cspan class=\"hljs-variable constant_\"\u003eMAGFILTER\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eLinear\u003c/span\u003e;\n    \u003cspan class=\"hljs-variable constant_\"\u003eMIPFILTER\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eLinear\u003c/span\u003e;\n};\n\ntexture \u003cspan class=\"hljs-title class_\"\u003eReflectionTexture\u003c/span\u003e;\nsampler2D reflectionSampler = sampler_state\n{\n    \u003cspan class=\"hljs-title class_\"\u003eTexture\u003c/span\u003e = (\u003cspan class=\"hljs-title class_\"\u003eReflectionTexture\u003c/span\u003e);\n    \u003cspan class=\"hljs-variable constant_\"\u003eADDRESSU\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eClamp\u003c/span\u003e;\n    \u003cspan class=\"hljs-variable constant_\"\u003eADDRESSV\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eClamp\u003c/span\u003e;\n    \u003cspan class=\"hljs-variable constant_\"\u003eMINFILTER\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eLinear\u003c/span\u003e;\n    \u003cspan class=\"hljs-variable constant_\"\u003eMAGFILTER\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eLinear\u003c/span\u003e;\n    \u003cspan class=\"hljs-variable constant_\"\u003eMIPFILTER\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eLinear\u003c/span\u003e;\n};\n\ntexture \u003cspan class=\"hljs-title class_\"\u003eDistortionMap\u003c/span\u003e;\nsampler2D distortionSampler = sampler_state\n{\n    \u003cspan class=\"hljs-title class_\"\u003eTexture\u003c/span\u003e = (\u003cspan class=\"hljs-title class_\"\u003eDistortionMap\u003c/span\u003e);\n    \u003cspan class=\"hljs-variable constant_\"\u003eADDRESSU\u003c/span\u003e = \u003cspan class=\"hljs-variable constant_\"\u003eWRAP\u003c/span\u003e;\n    \u003cspan class=\"hljs-variable constant_\"\u003eADDRESSV\u003c/span\u003e = \u003cspan class=\"hljs-variable constant_\"\u003eWRAP\u003c/span\u003e;\n    \u003cspan class=\"hljs-variable constant_\"\u003eMINFILTER\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eLinear\u003c/span\u003e;\n    \u003cspan class=\"hljs-variable constant_\"\u003eMAGFILTER\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eLinear\u003c/span\u003e;\n    \u003cspan class=\"hljs-variable constant_\"\u003eMIPFILTER\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eLinear\u003c/span\u003e;\n};\n\ntexture \u003cspan class=\"hljs-title class_\"\u003eNormalMap\u003c/span\u003e;\nsampler2D normalMapSampler = sampler_state\n{\n    \u003cspan class=\"hljs-title class_\"\u003eTexture\u003c/span\u003e = (\u003cspan class=\"hljs-title class_\"\u003eNormalMap\u003c/span\u003e);\n    \u003cspan class=\"hljs-variable constant_\"\u003eADDRESSU\u003c/span\u003e = \u003cspan class=\"hljs-variable constant_\"\u003eWRAP\u003c/span\u003e;\n    \u003cspan class=\"hljs-variable constant_\"\u003eADDRESSV\u003c/span\u003e = \u003cspan class=\"hljs-variable constant_\"\u003eWRAP\u003c/span\u003e;\n    \u003cspan class=\"hljs-variable constant_\"\u003eMINFILTER\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eLinear\u003c/span\u003e;\n    \u003cspan class=\"hljs-variable constant_\"\u003eMAGFILTER\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eLinear\u003c/span\u003e;\n    \u003cspan class=\"hljs-variable constant_\"\u003eMIPFILTER\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eLinear\u003c/span\u003e;\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 쉐이더에서 KSpecular, Shininess, LightPosition, LightColor, CameraPosition과 같은 균일은 조명 및 시각화 매개변수를 정의합니다. MoveFactor, Tiling, WaveStrength는 물의 움직임과 외관을 제어합니다. ReflectionView, Projection, WorldViewProjection, World와 같은 행렬은 좌표를 변환하는 데 사용됩니다. refractionSampler, reflectionSampler, distortionSampler, normalMapSampler와 같은 텍스처 샘플러는 물 표면을 렌더링하는 데 필요한 해당 텍스처를 샘플링하는 데 사용됩니다.\u003c/p\u003e\n\u003cp\u003e왜곡 맵에는 다음과 같은 모양의 텍스처를 사용할 것입니다:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-20-HowtocreateWatershaderinMonogameXNA_2.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e이 텍스처를 사용하여 텍스처 좌표를 왜곡시켜 물 표면에 작은 파도 효과를 만들 수 있습니다. 이 왜곡은 물의 동적이고 현실적인 외관을 모방하는 데 도움이 됩니다.\u003c/p\u003e\n\u003cp\u003eNormal Map으로는 다른 텍스처를 사용할 것입니다. 여기 예시가 있습니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-20-HowtocreateWatershaderinMonogameXNA_3.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이 지도에는 물과 빛이 상호 작용하는 방식을 시뮬레이션하기 위해 필수적인 표면 법선에 대한 정보가 포함되어 있습니다. 왜곡 맵이 텍스처 좌표를 조작하는 데 사용되는 반면, 법선 맵은 빛 관련 계산에 사용됩니다.\u003c/p\u003e\n\u003ch2\u003e버텍스 셰이더\u003c/h2\u003e\n\u003cp\u003e우리의 버텍스 셰이더에서는 버텍스 데이터를 픽셀 셰이더에 대비하여 준비하기 위해 변환합니다. 이 과정을 자세히 살펴보겠습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003estruct \u003cspan class=\"hljs-title class_\"\u003eVertexShaderInput\u003c/span\u003e\n{\n    float4 \u003cspan class=\"hljs-title class_\"\u003ePosition\u003c/span\u003e : \u003cspan class=\"hljs-title class_\"\u003ePOSITION0\u003c/span\u003e;\n    float4 \u003cspan class=\"hljs-title class_\"\u003eNormal\u003c/span\u003e : \u003cspan class=\"hljs-variable constant_\"\u003eNORMAL\u003c/span\u003e;\n    float2 \u003cspan class=\"hljs-title class_\"\u003eTextureCoordinates\u003c/span\u003e : \u003cspan class=\"hljs-title class_\"\u003eTEXCOORD0\u003c/span\u003e;\n};\n\nstruct \u003cspan class=\"hljs-title class_\"\u003eVertexShaderOutput\u003c/span\u003e\n{\n    float4 \u003cspan class=\"hljs-title class_\"\u003ePosition\u003c/span\u003e : \u003cspan class=\"hljs-variable constant_\"\u003eSV_POSITION\u003c/span\u003e;\n    float2 \u003cspan class=\"hljs-title class_\"\u003eTextureCoordinates\u003c/span\u003e : \u003cspan class=\"hljs-title class_\"\u003eTEXCOORD0\u003c/span\u003e;\n    float4 \u003cspan class=\"hljs-title class_\"\u003eWorldPosition\u003c/span\u003e : \u003cspan class=\"hljs-title class_\"\u003eTEXCOORD1\u003c/span\u003e;\n    float4 \u003cspan class=\"hljs-title class_\"\u003eNormal\u003c/span\u003e : \u003cspan class=\"hljs-title class_\"\u003eTEXCOORD2\u003c/span\u003e;\n    float4 \u003cspan class=\"hljs-title class_\"\u003eReflectionPosition\u003c/span\u003e : \u003cspan class=\"hljs-title class_\"\u003eTEXCOORD3\u003c/span\u003e;\n    float4 \u003cspan class=\"hljs-title class_\"\u003eRefractionPosition\u003c/span\u003e : \u003cspan class=\"hljs-title class_\"\u003eTEXCOORD4\u003c/span\u003e;\n};\n\n\u003cspan class=\"hljs-title class_\"\u003eVertexShaderOutput\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMainVS\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eVertexShaderInput\u003c/span\u003e input)\n{\n    \u003cspan class=\"hljs-title class_\"\u003eVertexShaderOutput\u003c/span\u003e output = (\u003cspan class=\"hljs-title class_\"\u003eVertexShaderOutput\u003c/span\u003e) \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n\n    \u003cspan class=\"hljs-comment\"\u003e// 버텍스 위치를 클립 공간에 변환합니다\u003c/span\u003e\n    output.\u003cspan class=\"hljs-property\"\u003ePosition\u003c/span\u003e = \u003cspan class=\"hljs-title function_\"\u003emul\u003c/span\u003e(input.\u003cspan class=\"hljs-property\"\u003ePosition\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eWorldViewProjection\u003c/span\u003e);\n\n    \u003cspan class=\"hljs-comment\"\u003e// 버텍스 위치를 월드 공간으로 변환합니다\u003c/span\u003e\n    output.\u003cspan class=\"hljs-property\"\u003eWorldPosition\u003c/span\u003e = \u003cspan class=\"hljs-title function_\"\u003emul\u003c/span\u003e(input.\u003cspan class=\"hljs-property\"\u003ePosition\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eWorld\u003c/span\u003e);\n\n    \u003cspan class=\"hljs-comment\"\u003e// 어떤 변경도 없이 버텍스 법선을 전달합니다\u003c/span\u003e\n    output.\u003cspan class=\"hljs-property\"\u003eNormal\u003c/span\u003e = input.\u003cspan class=\"hljs-property\"\u003eNormal\u003c/span\u003e;\n\n    \u003cspan class=\"hljs-comment\"\u003e// 타일링 요소로 텍스처 좌표를 조정합니다\u003c/span\u003e\n    output.\u003cspan class=\"hljs-property\"\u003eTextureCoordinates\u003c/span\u003e = input.\u003cspan class=\"hljs-property\"\u003eTextureCoordinates\u003c/span\u003e * \u003cspan class=\"hljs-title class_\"\u003eTiling\u003c/span\u003e;\n\n    \u003cspan class=\"hljs-comment\"\u003e// 반사 위치와 월드 매트릭스를 계산합니다\u003c/span\u003e\n    float4x4 reflectProjectWorld = \u003cspan class=\"hljs-title function_\"\u003emul\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eReflectionView\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eProjection\u003c/span\u003e);\n    reflectProjectWorld = \u003cspan class=\"hljs-title function_\"\u003emul\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eWorld\u003c/span\u003e, reflectProjectWorld);\n    output.\u003cspan class=\"hljs-property\"\u003eReflectionPosition\u003c/span\u003e = \u003cspan class=\"hljs-title function_\"\u003emul\u003c/span\u003e(input.\u003cspan class=\"hljs-property\"\u003ePosition\u003c/span\u003e, reflectProjectWorld);\n\n    \u003cspan class=\"hljs-comment\"\u003e// 굴절 위치는 클립 공간 위치와 동일합니다\u003c/span\u003e\n    output.\u003cspan class=\"hljs-property\"\u003eRefractionPosition\u003c/span\u003e = output.\u003cspan class=\"hljs-property\"\u003ePosition\u003c/span\u003e;\n\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e output;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e좋아요, 이제 정점 셰이더 부분을 완료했으니 픽셀 셰이더로 넘어갈 수 있겠네요.\u003c/p\u003e\n\u003ch1\u003e픽셀 셰이더\u003c/h1\u003e\n\u003ch2\u003e프로젝티브 텍스처 매핑\u003c/h2\u003e\n\u003cp\u003e먼저, 프로젝티브 굴절 텍스처 좌표를 정규화 장치 좌표 (NDC) 공간으로 변환합니다. 그런 다음, DirectX (DX) 텍스처를 정확히 샘플링할 수 있도록 xy 좌표를 적절하게 조정하여 크기를 조절하고 오프셋을 적용합니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-csharp\"\u003e\u003cspan class=\"hljs-function\"\u003efloat4 \u003cspan class=\"hljs-title\"\u003eMainPS\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eVertexShaderOutput input\u003c/span\u003e) : COLOR\u003c/span\u003e\n{\n    \u003cspan class=\"hljs-comment\"\u003e// 굴절\u003c/span\u003e\n\n    float4 refractionTexCoord;\n    refractionTexCoord = input.RefractionPosition;\n\n    \u003cspan class=\"hljs-comment\"\u003e// 화면 위치 좌표\u003c/span\u003e\n    refractionTexCoord.xyz /= refractionTexCoord.w;\n\n    \u003cspan class=\"hljs-comment\"\u003e// 오프셋 조정\u003c/span\u003e\n    refractionTexCoord.x = \u003cspan class=\"hljs-number\"\u003e0.5f\u003c/span\u003e * refractionTexCoord.x + \u003cspan class=\"hljs-number\"\u003e0.5f\u003c/span\u003e;\n    refractionTexCoord.y = \u003cspan class=\"hljs-number\"\u003e-0.5f\u003c/span\u003e * refractionTexCoord.y + \u003cspan class=\"hljs-number\"\u003e0.5f\u003c/span\u003e;\n\n    \u003cspan class=\"hljs-comment\"\u003e// 카메라로부터의 거리에 따라 굴절 더하기\u003c/span\u003e\n    refractionTexCoord.z = \u003cspan class=\"hljs-number\"\u003e0.001f\u003c/span\u003e / refractionTexCoord.z;\n    float2 refractionTex = refractionTexCoord.xy - refractionTexCoord.z;\n\n    \u003cspan class=\"hljs-comment\"\u003e// 반사\u003c/span\u003e\n\n    float4 reflectionTexCoord;\n    reflectionTexCoord = input.ReflectionPosition;\n\n    \u003cspan class=\"hljs-comment\"\u003e// 화면 위치 좌표\u003c/span\u003e\n    reflectionTexCoord.xyz /= reflectionTexCoord.w;\n\n    \u003cspan class=\"hljs-comment\"\u003e// 오프셋 조정\u003c/span\u003e\n    reflectionTexCoord.x = \u003cspan class=\"hljs-number\"\u003e0.5f\u003c/span\u003e * reflectionTexCoord.x + \u003cspan class=\"hljs-number\"\u003e0.5f\u003c/span\u003e;\n    reflectionTexCoord.y = \u003cspan class=\"hljs-number\"\u003e-0.5f\u003c/span\u003e * reflectionTexCoord.y + \u003cspan class=\"hljs-number\"\u003e0.5f\u003c/span\u003e;\n\n    \u003cspan class=\"hljs-comment\"\u003e// 카메라로부터의 거리에 따라 반사 더하기\u003c/span\u003e\n    reflectionTexCoord.z = \u003cspan class=\"hljs-number\"\u003e0.001f\u003c/span\u003e / reflectionTexCoord.z;\n    float2 reflectionTex = reflectionTexCoord.xy + reflectionTexCoord.z;\n\n    \u003cspan class=\"hljs-comment\"\u003e// 셰이더의 나머지 부분\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e굴절에 대해서는 카메라로부터의 거리에 따라 텍스처 좌표를 조정하여 굴절 효과를 향상시킵니다. 이 조정을 통해 카메라로부터 더 멀리 있는 객체가 더 많이 굴절되어 물 속 장면을 더 현실적으로 렌더링할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e반사에 대해서도 반사 텍스처 좌표를 NDC 공간으로 변환하고 카메라로부터의 거리에 따라 조정합니다. 이것은 더 뚜렷한 반사 효과를 만들어냄과 동시에, 카메라로부터 더 멀리 있는 객체가 더 강렬하게 반사되도록 도와줍니다.\u003c/p\u003e\n\u003ch2\u003e왜곡 맵 / DuDv 맵\u003c/h2\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이제 위에 표시된 왜곡 맵을 사용하여 반사 및 굴절 텍스처를 샘플링할 예정입니다.\u003c/p\u003e\n\u003cp\u003e이 맵은 빨간색과 녹색으로 이뤄진, 기본적으로 float2로 이루어져 있습니다. 그러나 이 값들은 항상 이 왜곡 맵에서 양수일 것이므로, 왜곡은 항상 양수일 것이고, 값은 (0.0, 0.0)에서 (1.0, 1.0) 사이입니다. 이 전체적인 리얼리티를 위해 양수와 음수 왜곡을 가질 수 있으면 좋을 것 같습니다.\u003c/p\u003e\n\u003cp\u003e이 값을 (-1.0, -1.0)에서 (1.0, 1.0) 사이로 변환하기 위해 단순히 2를 곱하고 1을 뺍니다. 그런 다음 이 값을 사용하여 간단히 반사 및 굴절 텍스처 좌표를 왜곡시킵니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003efloat2 distortion = (\u003cspan class=\"hljs-title function_\"\u003etex2D\u003c/span\u003e(distortionSampler, \u003cspan class=\"hljs-title class_\"\u003eInput\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eTextureCoordinates\u003c/span\u003e)).\u003cspan class=\"hljs-property\"\u003erg\u003c/span\u003e\n                    * \u003cspan class=\"hljs-number\"\u003e2.0\u003c/span\u003e - \u003cspan class=\"hljs-number\"\u003e1.0\u003c/span\u003e) * \u003cspan class=\"hljs-title class_\"\u003eWaveStrength\u003c/span\u003e;\n\nreflectionTex += distortion;\nrefractionTex += distortion;\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이 왜곡은 기본 설정에서 조금 강할 수 있습니다. 그래서 우리는 이 왜곡을 약간 낮추기 위해 이전에 선언한 WaveStrength로 사용할 것입니다.\u003c/p\u003e\n\u003ch2\u003e파도 이동하기\u003c/h2\u003e\n\u003cp\u003e물이 움직이는 것처럼 보이게 하는 방법은 Distortion Map을 샘플링하는 위치에 오프셋을 사용하는 것입니다. 이미 이를 선언했는데, 그것이 MoveFactor이며 이 오프셋을 시간이 지남에 따라 변경할 것입니다.\u003c/p\u003e\n\u003cp\u003e이 효과를 얻기 위해 MoveFactor를 텍스처 좌표의 X 구성 요소에 추가하고 왜곡 맵을 샘플링합니다. 그 후 Y 구성 요소를 위해 두 번째 샘플링을 수행하여 다른 방향으로 추가 왜곡을 적용합니다. 이 프로세스는 왜곡 효과의 현실성을 강화하여 보다 동적인 외관을 만듭니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003efloat2 distortedTexCoords = \u003cspan class=\"hljs-title function_\"\u003etex2D\u003c/span\u003e(distortionSampler, \u003cspan class=\"hljs-title function_\"\u003efloat2\u003c/span\u003e(input.\u003cspan class=\"hljs-property\"\u003eTextureCoordinates\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ex\u003c/span\u003e + \u003cspan class=\"hljs-title class_\"\u003eMoveFactor\u003c/span\u003e, input.\u003cspan class=\"hljs-property\"\u003eTextureCoordinates\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ey\u003c/span\u003e)) * \u003cspan class=\"hljs-number\"\u003e0.01\u003c/span\u003e;\ndistortedTexCoords = input.\u003cspan class=\"hljs-property\"\u003eTextureCoordinates\u003c/span\u003e + \u003cspan class=\"hljs-title function_\"\u003efloat2\u003c/span\u003e(distortedTexCoords.\u003cspan class=\"hljs-property\"\u003ex\u003c/span\u003e, distortedTexCoords.\u003cspan class=\"hljs-property\"\u003ey\u003c/span\u003e + \u003cspan class=\"hljs-title class_\"\u003eMoveFactor\u003c/span\u003e);\nfloat2 totalDistortion = (\u003cspan class=\"hljs-title function_\"\u003etex2D\u003c/span\u003e(distortionSampler, distortedTexCoords).\u003cspan class=\"hljs-property\"\u003erg\u003c/span\u003e * \u003cspan class=\"hljs-number\"\u003e2.0\u003c/span\u003e - \u003cspan class=\"hljs-number\"\u003e1.0\u003c/span\u003e) * \u003cspan class=\"hljs-title class_\"\u003eWaveStrength\u003c/span\u003e;\n\nreflectionTex += totalDistortion;\nrefractionTex += totalDistortion;\n\n\u003cspan class=\"hljs-comment\"\u003e// Sample both texture using the distorted texture coordinates\u003c/span\u003e\nfloat4 reflectionColor = \u003cspan class=\"hljs-title function_\"\u003etex2D\u003c/span\u003e(reflectionSampler, reflectionTex);\nfloat4 refractionColor = \u003cspan class=\"hljs-title function_\"\u003etex2D\u003c/span\u003e(refractionSampler, refractionTex);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e첫 번째 줄에서 0.01을 곱하여 초기 샘플에 적용된 왜곡의 강도를 약간 조정했습니다.\u003c/p\u003e\n\u003ch2\u003e프레넬\u003c/h2\u003e\n\u003cp\u003e프레넬 효과가 무엇인지 모르겠다면, Dorian의 아주 좋은 설명을 보여드리겠습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이 효과를 구현하려면 다음과 같이 물에서부터의 뷰 방향과 법선을 사용해야 합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003efloat3 viewDirection = \u003cspan class=\"hljs-title function_\"\u003enormalize\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eCameraPosition\u003c/span\u003e - input.\u003cspan class=\"hljs-property\"\u003eWorldPosition\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003exyz\u003c/span\u003e);\nfloat refractiveFactor = \u003cspan class=\"hljs-title function_\"\u003edot\u003c/span\u003e(viewDirection, \u003cspan class=\"hljs-title function_\"\u003enormalize\u003c/span\u003e(input.\u003cspan class=\"hljs-property\"\u003eNormal\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003exyz\u003c/span\u003e));\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그리고 결과물은 이전에 계산한 refractiveFactor 값을 사용하여 reflectionColor와 refractionColor 사이의 선형 보간값이 될 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003efloat4 finalColor = \u003cspan class=\"hljs-title function_\"\u003elerp\u003c/span\u003e(reflectionColor, refractionColor, refractiveFactor);\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e하지만 아직 끝나지 않았어요! 마지막으로 추가해야 할 것은 노멀 맵과 조명입니다.\u003c/p\u003e\n\u003ch2\u003e노멀 맵\u003c/h2\u003e\n\u003cp\u003e노멀 맵을 사용하여 물 표면의 다른 지점에서의 노멀을 나타낼 수 있습니다. 노멀 맵의 어떤 지점의 픽셀 색상은 그 지점에서의 물의 3D 노멀 벡터를 나타낼 수 있습니다. (R, G, B) -` (X, Y, Z). 저는 위에 보여드린 노멀 맵이 대부분 파란색인 이유는 파란 값이 위쪽 축을 나타내며, 우리의 경우에는 Y 축이기 때문입니다.\u003c/p\u003e\n\u003cp\u003e따라서, 우리는 노멀 맵 색의 파란 구성 요소를 노멀 벡터의 Y 구성 요소로 사용할 것이고, 노멀 맵의 빨간색과 초록색 구성 요소를 노멀 벡터의 X 및 Z 구성 요소로 사용할 수 있습니다. (R, G, B) -` (R, B, G).\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e여기서 유일한 문제는 절대 음수 색상을 가질 수 없기 때문에 법선 벡터의 구성 요소도 양수여야한다는 것입니다. Y 구성 요소에 대해서는 문제가 되지 않습니다. 왜냐하면 표면 법선이 어느 정도로든 위로 향하도록 항상 원하기 때문입니다. 그러나 법선이 항상 양의 X 및 Z 방향을 가리키도록 하길 바라는 것은 아닙니다. 법선은 음의 X 및 Z 방향을 가리키도록도 할 수 있어야 합니다.\u003c/p\u003e\n\u003cp\u003e이를 위해 왜곡 맵에 사용한 것과 동일한 변환을 사용할 것입니다. 2를 곱하고 1을 빼는 것입니다. 그리고 이런 식으로 법선 맵에서 법선 벡터를 추출할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003efloat4 normalMapColor = \u003cspan class=\"hljs-title function_\"\u003etex2D\u003c/span\u003e(normalMapSampler, distortedTexCoords);\nfloat3 normal = \u003cspan class=\"hljs-title function_\"\u003efloat3\u003c/span\u003e(normalMapColor.\u003cspan class=\"hljs-property\"\u003er\u003c/span\u003e * \u003cspan class=\"hljs-number\"\u003e2.0\u003c/span\u003e - \u003cspan class=\"hljs-number\"\u003e1.0\u003c/span\u003e, normalMapColor.\u003cspan class=\"hljs-property\"\u003eb\u003c/span\u003e, normalMapColor.\u003cspan class=\"hljs-property\"\u003eg\u003c/span\u003e * \u003cspan class=\"hljs-number\"\u003e2.0\u003c/span\u003e - \u003cspan class=\"hljs-number\"\u003e1.0\u003c/span\u003e);\nnormal = \u003cspan class=\"hljs-title function_\"\u003enormalize\u003c/span\u003e(normal);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 추출된 법선 벡터를 활용하여 조명 효과를 계산할 것입니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003e조명\u003c/h2\u003e\n\u003cp\u003e우리가 사용할 조명 기법은 기본적으로 Blinn Phong 모델입니다. 이에 대해 더 알고 싶다면 여기를 클릭해주세요. 여기서 사용되는 유니폼은 KSpecular, Shininess, LightPosition 및 LightColor 입니다.\u003c/p\u003e\n\u003cp\u003e먼저, 빛의 방향과 하프 벡터를 구하기 위해 빛 위치와 빛 및 보기 방향의 합을 나타내는 벡터를 정규화합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003efloat3 lightDirection = \u003cspan class=\"hljs-title function_\"\u003enormalize\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eLightPosition\u003c/span\u003e - input.\u003cspan class=\"hljs-property\"\u003eWorldPosition\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003exyz\u003c/span\u003e);\nfloat3 halfVector = \u003cspan class=\"hljs-title function_\"\u003enormalize\u003c/span\u003e(lightDirection + viewDirection);\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이 벡터들을 사용하여, 우리는 NdotL과 NdotH라는 닷 프로덕트를 계산합니다. 이는 각각 노멀 벡터와 라이트 방향, 그리고 노멀 벡터와 하프 벡터 사이의 각도를 나타냅니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003efloat \u003cspan class=\"hljs-title class_\"\u003eNdotL\u003c/span\u003e = \u003cspan class=\"hljs-title function_\"\u003esaturate\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003edot\u003c/span\u003e(normal, lightDirection));\nfloat \u003cspan class=\"hljs-title class_\"\u003eNdotH\u003c/span\u003e = \u003cspan class=\"hljs-title function_\"\u003esaturate\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003edot\u003c/span\u003e(normal, halfVector));\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 닷 프로덕트를 이용하여, 우리는 Phong 반사 모델 방정식을 적용하여 스펙큘러 광원 기여도를 계산합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003efloat3 specularLight = \u003cspan class=\"hljs-title function_\"\u003esign\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eNdotL\u003c/span\u003e) * \u003cspan class=\"hljs-title class_\"\u003eKSpecular\u003c/span\u003e * \u003cspan class=\"hljs-title class_\"\u003eLightColor\u003c/span\u003e * \u003cspan class=\"hljs-title function_\"\u003epow\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eNdotH\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eShininess\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e마지막으로 반사광을 미리 계산된 반사 및 굴절 색과 결합하여 최종 색상 출력을 결정합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 최종 계산\u003c/span\u003e\nfloat4 finalColor = \u003cspan class=\"hljs-title function_\"\u003elerp\u003c/span\u003e(reflectionColor, refractionColor, refractiveFactor) + \u003cspan class=\"hljs-title function_\"\u003efloat4\u003c/span\u003e(specularLight, \u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그게 다에요! 우리는 물 셰이더를 완전히 성공적으로 만들었습니다! 원하는 대로 매개변수를 조절할 수 있어요. 저는 이렇게 했어요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eprivate \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDrawWater\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eMatrix\u003c/span\u003e world, \u003cspan class=\"hljs-title class_\"\u003eMatrix\u003c/span\u003e view, \u003cspan class=\"hljs-title class_\"\u003eMatrix\u003c/span\u003e projection, \u003cspan class=\"hljs-title class_\"\u003eMatrix\u003c/span\u003e reflectionView, \u003cspan class=\"hljs-title class_\"\u003eGameTime\u003c/span\u003e gameTime)\n{\n    _waterShader.\u003cspan class=\"hljs-property\"\u003eCurrentTechnique\u003c/span\u003e = _waterShader.\u003cspan class=\"hljs-property\"\u003eTechniques\u003c/span\u003e[\u003cspan class=\"hljs-string\"\u003e\"Water\"\u003c/span\u003e];\n\n    _waterShader.\u003cspan class=\"hljs-property\"\u003eParameters\u003c/span\u003e[\u003cspan class=\"hljs-string\"\u003e\"World\"\u003c/span\u003e].\u003cspan class=\"hljs-title class_\"\u003eSetValue\u003c/span\u003e(world);\n    _waterShader.\u003cspan class=\"hljs-property\"\u003eParameters\u003c/span\u003e[\u003cspan class=\"hljs-string\"\u003e\"WorldViewProjection\"\u003c/span\u003e].\u003cspan class=\"hljs-title class_\"\u003eSetValue\u003c/span\u003e(world * view * projection);\n    _waterShader.\u003cspan class=\"hljs-property\"\u003eParameters\u003c/span\u003e[\u003cspan class=\"hljs-string\"\u003e\"ReflectionView\"\u003c/span\u003e].\u003cspan class=\"hljs-title class_\"\u003eSetValue\u003c/span\u003e(reflectionView);\n    _waterShader.\u003cspan class=\"hljs-property\"\u003eParameters\u003c/span\u003e[\u003cspan class=\"hljs-string\"\u003e\"Projection\"\u003c/span\u003e].\u003cspan class=\"hljs-title class_\"\u003eSetValue\u003c/span\u003e(projection);\n\n    _waterShader.\u003cspan class=\"hljs-property\"\u003eParameters\u003c/span\u003e[\u003cspan class=\"hljs-string\"\u003e\"ReflectionTexture\"\u003c/span\u003e].\u003cspan class=\"hljs-title class_\"\u003eSetValue\u003c/span\u003e(_reflectionRenderTarget);\n    _waterShader.\u003cspan class=\"hljs-property\"\u003eParameters\u003c/span\u003e[\u003cspan class=\"hljs-string\"\u003e\"RefractionTexture\"\u003c/span\u003e].\u003cspan class=\"hljs-title class_\"\u003eSetValue\u003c/span\u003e(_refractionRenderTarget);\n    _waterShader.\u003cspan class=\"hljs-property\"\u003eParameters\u003c/span\u003e[\u003cspan class=\"hljs-string\"\u003e\"DistortionMap\"\u003c/span\u003e].\u003cspan class=\"hljs-title class_\"\u003eSetValue\u003c/span\u003e(_distortionMap);\n    _waterShader.\u003cspan class=\"hljs-property\"\u003eParameters\u003c/span\u003e[\u003cspan class=\"hljs-string\"\u003e\"NormalMap\"\u003c/span\u003e].\u003cspan class=\"hljs-title class_\"\u003eSetValue\u003c/span\u003e(_normalMap);\n    _waterShader.\u003cspan class=\"hljs-property\"\u003eParameters\u003c/span\u003e[\u003cspan class=\"hljs-string\"\u003e\"Tiling\"\u003c/span\u003e].\u003cspan class=\"hljs-title class_\"\u003eSetValue\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eVector2\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eOne\u003c/span\u003e * 20f);\n\n    _waterShader.\u003cspan class=\"hljs-property\"\u003eParameters\u003c/span\u003e[\u003cspan class=\"hljs-string\"\u003e\"MoveFactor\"\u003c/span\u003e].\u003cspan class=\"hljs-title class_\"\u003eSetValue\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eWaveSpeed\u003c/span\u003e * (float)gameTime.\u003cspan class=\"hljs-property\"\u003eTotalGameTime\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eTotalSeconds\u003c/span\u003e);\n    _waterShader.\u003cspan class=\"hljs-property\"\u003eParameters\u003c/span\u003e[\u003cspan class=\"hljs-string\"\u003e\"WaveStrength\"\u003c/span\u003e].\u003cspan class=\"hljs-title class_\"\u003eSetValue\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0.\u003c/span\u003e01f);\n\n    _waterShader.\u003cspan class=\"hljs-property\"\u003eParameters\u003c/span\u003e[\u003cspan class=\"hljs-string\"\u003e\"CameraPosition\"\u003c/span\u003e].\u003cspan class=\"hljs-title class_\"\u003eSetValue\u003c/span\u003e(_freeCamera.\u003cspan class=\"hljs-property\"\u003ePosition\u003c/span\u003e);\n    _waterShader.\u003cspan class=\"hljs-property\"\u003eParameters\u003c/span\u003e[\u003cspan class=\"hljs-string\"\u003e\"LightPosition\"\u003c/span\u003e].\u003cspan class=\"hljs-title class_\"\u003eSetValue\u003c/span\u003e(_lightPosition);\n    _waterShader.\u003cspan class=\"hljs-property\"\u003eParameters\u003c/span\u003e[\u003cspan class=\"hljs-string\"\u003e\"LightColor\"\u003c/span\u003e].\u003cspan class=\"hljs-title class_\"\u003eSetValue\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eColor\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eWhite\u003c/span\u003e.\u003cspan class=\"hljs-title class_\"\u003eToVector3\u003c/span\u003e());\n    _waterShader.\u003cspan class=\"hljs-property\"\u003eParameters\u003c/span\u003e[\u003cspan class=\"hljs-string\"\u003e\"Shininess\"\u003c/span\u003e].\u003cspan class=\"hljs-title class_\"\u003eSetValue\u003c/span\u003e(25f);\n    _waterShader.\u003cspan class=\"hljs-property\"\u003eParameters\u003c/span\u003e[\u003cspan class=\"hljs-string\"\u003e\"KSpecular\"\u003c/span\u003e].\u003cspan class=\"hljs-title class_\"\u003eSetValue\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0.\u003c/span\u003e3f);\n\n    _quad.\u003cspan class=\"hljs-title class_\"\u003eDraw\u003c/span\u003e(_waterShader);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e그리고 제 경우에는 다음과 같이 보입니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-20-HowtocreateWatershaderinMonogameXNA_4.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e이 글이 모노게임 그래픽 애플리케이션에서 이 효과를 이해하고 구현하는 데 도움이 되었으면 좋겠어요.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-20-HowtocreateWatershaderinMonogameXNA"},"buildId":"GsgRekSb--BvxYwv9FPn6","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>