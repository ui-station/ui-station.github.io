<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Rails 크론 잡 - Rails에서 작업 스케줄링 하는 방법 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-06-22-RailsCronJobsTaskSchedulingInRails" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Rails 크론 잡 - Rails에서 작업 스케줄링 하는 방법 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="Rails 크론 잡 - Rails에서 작업 스케줄링 하는 방법 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-22-RailsCronJobsTaskSchedulingInRails_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-06-22-RailsCronJobsTaskSchedulingInRails" data-gatsby-head="true"/><meta name="twitter:title" content="Rails 크론 잡 - Rails에서 작업 스케줄링 하는 방법 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-22-RailsCronJobsTaskSchedulingInRails_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-22 22:26" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-70e5ce89f3d962ac.js" defer=""></script><script src="/_next/static/JlBEgQDLGRx6DYlBnT8eD/_buildManifest.js" defer=""></script><script src="/_next/static/JlBEgQDLGRx6DYlBnT8eD/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Rails 크론 잡 - Rails에서 작업 스케줄링 하는 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Rails 크론 잡 - Rails에서 작업 스케줄링 하는 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 22, 2024</span><span class="posts_reading_time__f7YPP">9<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-22-RailsCronJobsTaskSchedulingInRails&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/assets/img/2024-06-22-RailsCronJobsTaskSchedulingInRails_0.png" alt="image"></p>
<p>언젠가 자동으로 작업을 예약해야 하는 상황에 처했던 적이 있나요? 매일 이메일을 보내거나 외부 API와 정기적으로 데이터를 동기화하는 것과 같은 작업들이 될 수 있습니다. 여기서 Cron 작업이 유용하게 사용됩니다. 이를 통해 이러한 작업들을 쉽게 자동화할 수 있습니다. 이 블로그에서는 예약된 작업을 실행하는 데 사용되는 Unix/Linux 시스템에 통합된 기본 소프트웨어인 Cron을 소개할 것입니다. 또한 Ruby Whenever Gem을 사용하여 특히 Rails 애플리케이션에서 Cron 작업을 쉽게 배포하는 빠른 가이드도 제공할 예정입니다.</p>
<h1>Cron 작업이란?</h1>
<p>Whenever Gem을 사용한 Rails에서 Cron 작업을 사용하는 방법에 대해 설명하기 전에, cron 작업이 무엇인지 간단히 설명해 드리겠습니다. (이 주제에 대해 자세한 기사를 곧 쓸 것입니다)</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>간단히 말해서, Cron은 특정 시간에 반복적으로 작업을 예약하고 실행할 수 있게 해주는 명령줄 도구입니다. 이러한 작업들을 'cron jobs'라고 합니다. Cron은 Linux/Unix 시스템에 내장되어 있기 때문에 추가적인 종속성을 설치할 필요가 없습니다. 일반적으로 cron jobs는 'crontab'이라는 파일에 작성됩니다. 'crontab'은 Cron Table의 약자입니다. crontab 작업/cron job의 구문은 다섯 개의 숫자로 구성되어 있으며 각각은 작업을 실행해야 하는 시간을 나타내며 그 뒤에 실행할 스크립트가 따릅니다. 구문은 다음과 같아야 합니다:</p>
<pre><code class="hljs language-js"># ┌───────────── 분 (<span class="hljs-number">0</span> - <span class="hljs-number">59</span>)
# │ ┌───────────── 시간 (<span class="hljs-number">0</span> - <span class="hljs-number">23</span>)
# │ │ ┌───────────── 일 (<span class="hljs-number">1</span> - <span class="hljs-number">31</span>)
# │ │ │ ┌───────────── 월 (<span class="hljs-number">1</span> - <span class="hljs-number">12</span>)
# │ │ │ │ ┌───────────── 요일 (<span class="hljs-number">0</span> - <span class="hljs-number">6</span>) (일요일부터 토요일까지;
# │ │ │ │ │ <span class="hljs-number">7</span>는 일요일일 수도 있음)
# │ │ │ │ │
# │ │ │ │ │
# * * * * * 실행할 명령어
</code></pre>
<p>아래 다이어그램은 구문을 잘 설명하고 있습니다:</p>
<img src="/assets/img/2024-06-22-RailsCronJobsTaskSchedulingInRails_1.png">
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>레일즈 작업을 예약하는 데는 crontab을 사용할 수 있지만, 낡고 복잡하게 느껴질 수 있습니다. 이 프로세스는 다음 명령어를 사용하는 것을 포함합니다:</p>
<pre><code class="hljs language-js"><span class="hljs-number">0</span> * * * * <span class="hljs-string">'cd path/to/project &#x26;&#x26; bundle exec some_task'</span>
</code></pre>
<h1>Whenever 젬</h1>
<p>이제 레일즈에서 cron 작업을 다루는 더 나은 방법에 대해 설명해 드리겠습니다. 전통적이고 다소 난잡한 crontab을 다루는 대신, 일정을 잡는 것이 훨씬 간편하고 우아한 루비 젬이 있습니다. 이 용도로 가장 많이 사용되는 젬은 Whenever입니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>'Whenever'은 크론 작업을 설정하는 과정을 간소화하는 젬입니다. 크론탭을 수동으로 편집하는 대신 Whenever을 사용하여 루비 코드로 크론 작업을 작성할 수 있습니다. 이 젬은 크론탭을 자동으로 업데이트해줍니다.</p>
<h1>Whenever 젬 설정하기</h1>
<p>이제 어플리케이션에 해당 젬을 설정하고 사용해봅시다. 먼저 젬을 설치해야 합니다. 아래와 같이 Gemfile에 젬을 포함시키고 bundle install을 실행하세요.</p>
<pre><code class="hljs language-js">gem <span class="hljs-string">'whenever'</span>, <span class="hljs-attr">require</span>: <span class="hljs-literal">false</span>
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이제 젬을 초기화하기 위해 아래 명령을 실행해보세요.</p>
<pre><code class="hljs language-js">bundle exec .<span class="hljs-property">wheneverize</span>
</code></pre>
<p><code>.wheneverize</code> 명령을 실행하면 config 디렉토리, 구체적으로는 config/schedule.rb에 schedule.rb라는 이름의 파일이 생성됩니다. 이 파일은 작업 실행 시간을 정의하고 실행할 Rake 작업을 지정하는 역할을 합니다.</p>
<p>이제 젬을 설정한 후 작업을 실제로 예약해 보겠습니다. 이를 위해서 Rake 작업을 만들어 시작하면 됩니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js">레일즈 g task batch send_messages
</code></pre>
<p>레일즈의 rake 태스크를 생성했다면, 해당 태스크 파일은 lib/tasks/sample.rb에 있을 거에요. 이제 이곳에 이메일을 보내는 기능을 추가해 보겠습니다.</p>
<pre><code class="hljs language-js"># lib/tasks/send_messages.<span class="hljs-property">rake</span>

namespace :messages <span class="hljs-keyword">do</span>
  desc <span class="hljs-string">"사용자에게 메시지 보내기"</span>
  task <span class="hljs-attr">send</span>: :environment <span class="hljs-keyword">do</span>
    <span class="hljs-title class_">User</span>.<span class="hljs-property">all</span>.<span class="hljs-property">each</span> <span class="hljs-keyword">do</span> |user|
      <span class="hljs-title class_">MessageMailer</span>.<span class="hljs-title function_">send_message</span>(user.<span class="hljs-property">email</span>).<span class="hljs-property">deliver_now</span>
      puts <span class="hljs-string">"#{user.email}님에게 메시지를 보냈습니다."</span>
    end
  end
end
</code></pre>
<p>Rake 태스크에 로직을 추가했다면, schedular.rb 파일에 등록해 보세요. 여기서는 예시로 1분 간격으로 설정하겠습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js">매 분마다
    rake <span class="hljs-string">'messages:send'</span>
end
</code></pre>
<p>그런 다음 crontab을 업데이트하고 해당 작업을 추가할 것입니다. 아래 명령을 실행하여 작업을 추가하실 수 있습니다.</p>
<pre><code class="hljs language-js">whenever --update-crontab
</code></pre>
<p>Cron Job을 성공적으로 설정했습니다. 특정 시간에 실행되도록 예약되었습니다. 또한 whenever --clear-crontab 명령을 사용하여 crontab을 지울 수 있고, crontab을 보려면 crontab -l을 사용할 수 있습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>Sidekiq-Cron Gem</h1>
<p>Sidekiq-cron은 작업 처리 라이브러리인 Sidekiq의 애드온입니다. Sidekiq-cron을 사용하면 특정 시간이나 간격에 작업을 예약할 수 있습니다. Sidekiq-cron은 Sidekiq에서 제공하는 공식 젬이 아님을 유의해야 합니다.</p>
<p>Sidekiq에서 작업을 예약하는 것은 일반적으로 엔터프라이즈 수준의 기능으로 간주되어 유료 라이선스가 필요할 수 있습니다. 그러나 엔터프라이즈 버전에 돈을 쓰고 싶지 않다면 Sidekiq-cron은 여러분에게 적합한 대안입니다.</p>
<p>간단히 말하면, Sidekiq-cron은 공식 엔터프라이즈 버전을 지불하지 않고도 Sidekiq 내에서 작업을 예약할 수 있게 해주는 도구입니다. 비슷한 예약 기능을 제공하여 작업이 언제와 얼마나 자주 실행되어야 하는지 지정할 수 있습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>Sidekiq-Cron Gem 설정하기</h1>
<p>이제 우리의 애플리케이션에 Sidekiq-Cron 젬을 설정해 봅시다. 먼저 젬을 설치해야 합니다. Gemfile에 아래와 같이 젬을 추가하고 bundle install을 실행해주세요.</p>
<pre><code class="hljs language-js">gem <span class="hljs-string">'sidekiq-cron'</span>
</code></pre>
<p>그런 다음 config/ 디렉토리에 schedule.yml 파일을 생성하세요. Whenever 젬의 경우처럼 파일을 초기화하는 기능은 제공되지 않지만, 다행히 Sidekiq-Cron은 파일을 초기화하는 기능을 제공하지 않습니다. 또한 config/initializers 디렉토리에 sidekiq.rb라는 이름의 파일을 생성하여 아래 내용을 추가해 주세요.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js">schedule_file = <span class="hljs-string">"config/schedule.yml"</span>
<span class="hljs-keyword">if</span> <span class="hljs-title class_">File</span>.<span class="hljs-property">exist</span>?(schedule_file) &#x26;&#x26; <span class="hljs-title class_">Sidekiq</span>.<span class="hljs-property">server</span>?
   <span class="hljs-title class_">Sidekiq</span>::<span class="hljs-title class_">Cron</span>::<span class="hljs-title class_">Job</span>.<span class="hljs-property">load_from_hash</span> <span class="hljs-variable constant_">YAML</span>.<span class="hljs-title function_">load_file</span>(schedule_file)
end
</code></pre>
<p>우리의 초기 설정이 완료되었습니다. 이제 실제 작업을 생성할 차례입니다. 터미널로 이동하여 다음 명령을 입력하세요.</p>
<pre><code class="hljs language-js">rails generate job send_bulk_emails
</code></pre>
<p>그리고 이 코드에 일부 기능을 추가하세요.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>참고: 레일즈 백그라운드 작업/워커를 설정, 생성 및 사용하는 방법에 대한 자세한 튜토리얼이 필요하시다면 이 기사를 참조해주세요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SendBulkEmailJob</span> &#x3C; <span class="hljs-title class_">ApplicationJob</span>
  queue_as :<span class="hljs-keyword">default</span>

def <span class="hljs-title function_">perform</span>(emails)
    begin
      <span class="hljs-title class_">BulkEmailService</span>.<span class="hljs-title function_">send_emails</span>(emails)
    rescue <span class="hljs-title class_">StandardError</span> => e
      <span class="hljs-title class_">Rails</span>.<span class="hljs-property">logger</span>.<span class="hljs-property">error</span> <span class="hljs-string">"Error sending bulk emails: #{e.message}"</span>
      raise e
    end
  end
end
</code></pre>
<p>작업을 만든 후, 터미널에 sidekiq을 입력하여 실행하고 다음과 같이 스케줄러 파일에 작업을 추가하세요:</p>
<pre><code class="hljs language-js"><span class="hljs-attr">email_job</span>:
   <span class="hljs-attr">cron</span>: <span class="hljs-string">"*/5 * * * *"</span>
   <span class="hljs-attr">class</span>: <span class="hljs-string">"SendBulkEmailJob"</span>
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>워커를 실행하려면 터미널에서 새 탭을 열어주세요. 앱이 활성화된 상태에서도 워커가 계속 실행되어야 하는 점을 주의해 주세요. 레일즈 서버를 시작하거나 기타 작업을 실행해야 하는 경우 다른 탭으로 전환해야 합니다.</p>
<p>모두입니다! 첫 번째 Sidekiq-cron 작업을 생성한 것을 축하드립니다!</p>
<h1>결론</h1>
<p>요약하면, 크론 작업은 Unix/Linux 시스템에서 반복적인 작업을 자동화하는 데 필수적입니다. Whenever 젬은 루비 코드로 작성하고 크론 작업을 예약하는 레일즈 애플리케이션에서 간단하게 사용할 수 있도록 하며 crontab을 자동으로 업데이트합니다. Sidekiq-Cron은 Sidekiq에서 작업을 예약하는 데 유용한 젬입니다. 두 젬은 크론 작업을 관리하고 실행하는 과정을 간소화하여 애플리케이션의 자동화와 효율성을 향상시킵니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>앞으로의 기사에서는 Rails가 어떻게 작동하는지에 대해 더 알아볼 것입니다. 그러니 계속해서 주의 깊게 지켜보고 배우세요!</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Rails 크론 잡 - Rails에서 작업 스케줄링 하는 방법","description":"","date":"2024-06-22 22:26","slug":"2024-06-22-RailsCronJobsTaskSchedulingInRails","content":"\n![image](/assets/img/2024-06-22-RailsCronJobsTaskSchedulingInRails_0.png)\n\n언젠가 자동으로 작업을 예약해야 하는 상황에 처했던 적이 있나요? 매일 이메일을 보내거나 외부 API와 정기적으로 데이터를 동기화하는 것과 같은 작업들이 될 수 있습니다. 여기서 Cron 작업이 유용하게 사용됩니다. 이를 통해 이러한 작업들을 쉽게 자동화할 수 있습니다. 이 블로그에서는 예약된 작업을 실행하는 데 사용되는 Unix/Linux 시스템에 통합된 기본 소프트웨어인 Cron을 소개할 것입니다. 또한 Ruby Whenever Gem을 사용하여 특히 Rails 애플리케이션에서 Cron 작업을 쉽게 배포하는 빠른 가이드도 제공할 예정입니다.\n\n# Cron 작업이란?\n\nWhenever Gem을 사용한 Rails에서 Cron 작업을 사용하는 방법에 대해 설명하기 전에, cron 작업이 무엇인지 간단히 설명해 드리겠습니다. (이 주제에 대해 자세한 기사를 곧 쓸 것입니다)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n간단히 말해서, Cron은 특정 시간에 반복적으로 작업을 예약하고 실행할 수 있게 해주는 명령줄 도구입니다. 이러한 작업들을 'cron jobs'라고 합니다. Cron은 Linux/Unix 시스템에 내장되어 있기 때문에 추가적인 종속성을 설치할 필요가 없습니다. 일반적으로 cron jobs는 'crontab'이라는 파일에 작성됩니다. 'crontab'은 Cron Table의 약자입니다. crontab 작업/cron job의 구문은 다섯 개의 숫자로 구성되어 있으며 각각은 작업을 실행해야 하는 시간을 나타내며 그 뒤에 실행할 스크립트가 따릅니다. 구문은 다음과 같아야 합니다:\n\n```js\n# ┌───────────── 분 (0 - 59)\n# │ ┌───────────── 시간 (0 - 23)\n# │ │ ┌───────────── 일 (1 - 31)\n# │ │ │ ┌───────────── 월 (1 - 12)\n# │ │ │ │ ┌───────────── 요일 (0 - 6) (일요일부터 토요일까지;\n# │ │ │ │ │ 7는 일요일일 수도 있음)\n# │ │ │ │ │\n# │ │ │ │ │\n# * * * * * 실행할 명령어\n```\n\n아래 다이어그램은 구문을 잘 설명하고 있습니다:\n\n\u003cimg src=\"/assets/img/2024-06-22-RailsCronJobsTaskSchedulingInRails_1.png\" /\u003e\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n레일즈 작업을 예약하는 데는 crontab을 사용할 수 있지만, 낡고 복잡하게 느껴질 수 있습니다. 이 프로세스는 다음 명령어를 사용하는 것을 포함합니다:\n\n```js\n0 * * * * 'cd path/to/project \u0026\u0026 bundle exec some_task'\n```\n\n# Whenever 젬\n\n이제 레일즈에서 cron 작업을 다루는 더 나은 방법에 대해 설명해 드리겠습니다. 전통적이고 다소 난잡한 crontab을 다루는 대신, 일정을 잡는 것이 훨씬 간편하고 우아한 루비 젬이 있습니다. 이 용도로 가장 많이 사용되는 젬은 Whenever입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n'Whenever'은 크론 작업을 설정하는 과정을 간소화하는 젬입니다. 크론탭을 수동으로 편집하는 대신 Whenever을 사용하여 루비 코드로 크론 작업을 작성할 수 있습니다. 이 젬은 크론탭을 자동으로 업데이트해줍니다.\n\n# Whenever 젬 설정하기\n\n이제 어플리케이션에 해당 젬을 설정하고 사용해봅시다. 먼저 젬을 설치해야 합니다. 아래와 같이 Gemfile에 젬을 포함시키고 bundle install을 실행하세요.\n\n```js\ngem 'whenever', require: false\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 젬을 초기화하기 위해 아래 명령을 실행해보세요.\n\n```js\nbundle exec .wheneverize\n```\n\n`.wheneverize` 명령을 실행하면 config 디렉토리, 구체적으로는 config/schedule.rb에 schedule.rb라는 이름의 파일이 생성됩니다. 이 파일은 작업 실행 시간을 정의하고 실행할 Rake 작업을 지정하는 역할을 합니다.\n\n이제 젬을 설정한 후 작업을 실제로 예약해 보겠습니다. 이를 위해서 Rake 작업을 만들어 시작하면 됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n레일즈 g task batch send_messages\n```\n\n레일즈의 rake 태스크를 생성했다면, 해당 태스크 파일은 lib/tasks/sample.rb에 있을 거에요. 이제 이곳에 이메일을 보내는 기능을 추가해 보겠습니다.\n\n```js\n# lib/tasks/send_messages.rake\n\nnamespace :messages do\n  desc \"사용자에게 메시지 보내기\"\n  task send: :environment do\n    User.all.each do |user|\n      MessageMailer.send_message(user.email).deliver_now\n      puts \"#{user.email}님에게 메시지를 보냈습니다.\"\n    end\n  end\nend\n```\n\nRake 태스크에 로직을 추가했다면, schedular.rb 파일에 등록해 보세요. 여기서는 예시로 1분 간격으로 설정하겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n매 분마다\n    rake 'messages:send'\nend\n```\n\n그런 다음 crontab을 업데이트하고 해당 작업을 추가할 것입니다. 아래 명령을 실행하여 작업을 추가하실 수 있습니다.\n\n```js\nwhenever --update-crontab\n```\n\nCron Job을 성공적으로 설정했습니다. 특정 시간에 실행되도록 예약되었습니다. 또한 whenever --clear-crontab 명령을 사용하여 crontab을 지울 수 있고, crontab을 보려면 crontab -l을 사용할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# Sidekiq-Cron Gem\n\nSidekiq-cron은 작업 처리 라이브러리인 Sidekiq의 애드온입니다. Sidekiq-cron을 사용하면 특정 시간이나 간격에 작업을 예약할 수 있습니다. Sidekiq-cron은 Sidekiq에서 제공하는 공식 젬이 아님을 유의해야 합니다.\n\nSidekiq에서 작업을 예약하는 것은 일반적으로 엔터프라이즈 수준의 기능으로 간주되어 유료 라이선스가 필요할 수 있습니다. 그러나 엔터프라이즈 버전에 돈을 쓰고 싶지 않다면 Sidekiq-cron은 여러분에게 적합한 대안입니다.\n\n간단히 말하면, Sidekiq-cron은 공식 엔터프라이즈 버전을 지불하지 않고도 Sidekiq 내에서 작업을 예약할 수 있게 해주는 도구입니다. 비슷한 예약 기능을 제공하여 작업이 언제와 얼마나 자주 실행되어야 하는지 지정할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# Sidekiq-Cron Gem 설정하기\n\n이제 우리의 애플리케이션에 Sidekiq-Cron 젬을 설정해 봅시다. 먼저 젬을 설치해야 합니다. Gemfile에 아래와 같이 젬을 추가하고 bundle install을 실행해주세요.\n\n```js\ngem 'sidekiq-cron'\n```\n\n그런 다음 config/ 디렉토리에 schedule.yml 파일을 생성하세요. Whenever 젬의 경우처럼 파일을 초기화하는 기능은 제공되지 않지만, 다행히 Sidekiq-Cron은 파일을 초기화하는 기능을 제공하지 않습니다. 또한 config/initializers 디렉토리에 sidekiq.rb라는 이름의 파일을 생성하여 아래 내용을 추가해 주세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nschedule_file = \"config/schedule.yml\"\nif File.exist?(schedule_file) \u0026\u0026 Sidekiq.server?\n   Sidekiq::Cron::Job.load_from_hash YAML.load_file(schedule_file)\nend\n```\n\n우리의 초기 설정이 완료되었습니다. 이제 실제 작업을 생성할 차례입니다. 터미널로 이동하여 다음 명령을 입력하세요.\n\n```js\nrails generate job send_bulk_emails\n```\n\n그리고 이 코드에 일부 기능을 추가하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n참고: 레일즈 백그라운드 작업/워커를 설정, 생성 및 사용하는 방법에 대한 자세한 튜토리얼이 필요하시다면 이 기사를 참조해주세요.\n\n```js\nclass SendBulkEmailJob \u003c ApplicationJob\n  queue_as :default\n\ndef perform(emails)\n    begin\n      BulkEmailService.send_emails(emails)\n    rescue StandardError =\u003e e\n      Rails.logger.error \"Error sending bulk emails: #{e.message}\"\n      raise e\n    end\n  end\nend\n```\n\n작업을 만든 후, 터미널에 sidekiq을 입력하여 실행하고 다음과 같이 스케줄러 파일에 작업을 추가하세요:\n\n```js\nemail_job:\n   cron: \"*/5 * * * *\"\n   class: \"SendBulkEmailJob\"\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n워커를 실행하려면 터미널에서 새 탭을 열어주세요. 앱이 활성화된 상태에서도 워커가 계속 실행되어야 하는 점을 주의해 주세요. 레일즈 서버를 시작하거나 기타 작업을 실행해야 하는 경우 다른 탭으로 전환해야 합니다.\n\n모두입니다! 첫 번째 Sidekiq-cron 작업을 생성한 것을 축하드립니다!\n\n# 결론\n\n요약하면, 크론 작업은 Unix/Linux 시스템에서 반복적인 작업을 자동화하는 데 필수적입니다. Whenever 젬은 루비 코드로 작성하고 크론 작업을 예약하는 레일즈 애플리케이션에서 간단하게 사용할 수 있도록 하며 crontab을 자동으로 업데이트합니다. Sidekiq-Cron은 Sidekiq에서 작업을 예약하는 데 유용한 젬입니다. 두 젬은 크론 작업을 관리하고 실행하는 과정을 간소화하여 애플리케이션의 자동화와 효율성을 향상시킵니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n앞으로의 기사에서는 Rails가 어떻게 작동하는지에 대해 더 알아볼 것입니다. 그러니 계속해서 주의 깊게 지켜보고 배우세요!\n","ogImage":{"url":"/assets/img/2024-06-22-RailsCronJobsTaskSchedulingInRails_0.png"},"coverImage":"/assets/img/2024-06-22-RailsCronJobsTaskSchedulingInRails_0.png","tag":["Tech"],"readingTime":9},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-RailsCronJobsTaskSchedulingInRails_0.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e언젠가 자동으로 작업을 예약해야 하는 상황에 처했던 적이 있나요? 매일 이메일을 보내거나 외부 API와 정기적으로 데이터를 동기화하는 것과 같은 작업들이 될 수 있습니다. 여기서 Cron 작업이 유용하게 사용됩니다. 이를 통해 이러한 작업들을 쉽게 자동화할 수 있습니다. 이 블로그에서는 예약된 작업을 실행하는 데 사용되는 Unix/Linux 시스템에 통합된 기본 소프트웨어인 Cron을 소개할 것입니다. 또한 Ruby Whenever Gem을 사용하여 특히 Rails 애플리케이션에서 Cron 작업을 쉽게 배포하는 빠른 가이드도 제공할 예정입니다.\u003c/p\u003e\n\u003ch1\u003eCron 작업이란?\u003c/h1\u003e\n\u003cp\u003eWhenever Gem을 사용한 Rails에서 Cron 작업을 사용하는 방법에 대해 설명하기 전에, cron 작업이 무엇인지 간단히 설명해 드리겠습니다. (이 주제에 대해 자세한 기사를 곧 쓸 것입니다)\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e간단히 말해서, Cron은 특정 시간에 반복적으로 작업을 예약하고 실행할 수 있게 해주는 명령줄 도구입니다. 이러한 작업들을 'cron jobs'라고 합니다. Cron은 Linux/Unix 시스템에 내장되어 있기 때문에 추가적인 종속성을 설치할 필요가 없습니다. 일반적으로 cron jobs는 'crontab'이라는 파일에 작성됩니다. 'crontab'은 Cron Table의 약자입니다. crontab 작업/cron job의 구문은 다섯 개의 숫자로 구성되어 있으며 각각은 작업을 실행해야 하는 시간을 나타내며 그 뒤에 실행할 스크립트가 따릅니다. 구문은 다음과 같아야 합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# ┌───────────── 분 (\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e - \u003cspan class=\"hljs-number\"\u003e59\u003c/span\u003e)\n# │ ┌───────────── 시간 (\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e - \u003cspan class=\"hljs-number\"\u003e23\u003c/span\u003e)\n# │ │ ┌───────────── 일 (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e - \u003cspan class=\"hljs-number\"\u003e31\u003c/span\u003e)\n# │ │ │ ┌───────────── 월 (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e - \u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e)\n# │ │ │ │ ┌───────────── 요일 (\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e - \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e) (일요일부터 토요일까지;\n# │ │ │ │ │ \u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e는 일요일일 수도 있음)\n# │ │ │ │ │\n# │ │ │ │ │\n# * * * * * 실행할 명령어\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e아래 다이어그램은 구문을 잘 설명하고 있습니다:\u003c/p\u003e\n\u003cimg src=\"/assets/img/2024-06-22-RailsCronJobsTaskSchedulingInRails_1.png\"\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e레일즈 작업을 예약하는 데는 crontab을 사용할 수 있지만, 낡고 복잡하게 느껴질 수 있습니다. 이 프로세스는 다음 명령어를 사용하는 것을 포함합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e * * * * \u003cspan class=\"hljs-string\"\u003e'cd path/to/project \u0026#x26;\u0026#x26; bundle exec some_task'\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003eWhenever 젬\u003c/h1\u003e\n\u003cp\u003e이제 레일즈에서 cron 작업을 다루는 더 나은 방법에 대해 설명해 드리겠습니다. 전통적이고 다소 난잡한 crontab을 다루는 대신, 일정을 잡는 것이 훨씬 간편하고 우아한 루비 젬이 있습니다. 이 용도로 가장 많이 사용되는 젬은 Whenever입니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e'Whenever'은 크론 작업을 설정하는 과정을 간소화하는 젬입니다. 크론탭을 수동으로 편집하는 대신 Whenever을 사용하여 루비 코드로 크론 작업을 작성할 수 있습니다. 이 젬은 크론탭을 자동으로 업데이트해줍니다.\u003c/p\u003e\n\u003ch1\u003eWhenever 젬 설정하기\u003c/h1\u003e\n\u003cp\u003e이제 어플리케이션에 해당 젬을 설정하고 사용해봅시다. 먼저 젬을 설치해야 합니다. 아래와 같이 Gemfile에 젬을 포함시키고 bundle install을 실행하세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003egem \u003cspan class=\"hljs-string\"\u003e'whenever'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003erequire\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이제 젬을 초기화하기 위해 아래 명령을 실행해보세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ebundle exec .\u003cspan class=\"hljs-property\"\u003ewheneverize\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003e.wheneverize\u003c/code\u003e 명령을 실행하면 config 디렉토리, 구체적으로는 config/schedule.rb에 schedule.rb라는 이름의 파일이 생성됩니다. 이 파일은 작업 실행 시간을 정의하고 실행할 Rake 작업을 지정하는 역할을 합니다.\u003c/p\u003e\n\u003cp\u003e이제 젬을 설정한 후 작업을 실제로 예약해 보겠습니다. 이를 위해서 Rake 작업을 만들어 시작하면 됩니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e레일즈 g task batch send_messages\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e레일즈의 rake 태스크를 생성했다면, 해당 태스크 파일은 lib/tasks/sample.rb에 있을 거에요. 이제 이곳에 이메일을 보내는 기능을 추가해 보겠습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# lib/tasks/send_messages.\u003cspan class=\"hljs-property\"\u003erake\u003c/span\u003e\n\nnamespace :messages \u003cspan class=\"hljs-keyword\"\u003edo\u003c/span\u003e\n  desc \u003cspan class=\"hljs-string\"\u003e\"사용자에게 메시지 보내기\"\u003c/span\u003e\n  task \u003cspan class=\"hljs-attr\"\u003esend\u003c/span\u003e: :environment \u003cspan class=\"hljs-keyword\"\u003edo\u003c/span\u003e\n    \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eall\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eeach\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edo\u003c/span\u003e |user|\n      \u003cspan class=\"hljs-title class_\"\u003eMessageMailer\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003esend_message\u003c/span\u003e(user.\u003cspan class=\"hljs-property\"\u003eemail\u003c/span\u003e).\u003cspan class=\"hljs-property\"\u003edeliver_now\u003c/span\u003e\n      puts \u003cspan class=\"hljs-string\"\u003e\"#{user.email}님에게 메시지를 보냈습니다.\"\u003c/span\u003e\n    end\n  end\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eRake 태스크에 로직을 추가했다면, schedular.rb 파일에 등록해 보세요. 여기서는 예시로 1분 간격으로 설정하겠습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e매 분마다\n    rake \u003cspan class=\"hljs-string\"\u003e'messages:send'\u003c/span\u003e\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그런 다음 crontab을 업데이트하고 해당 작업을 추가할 것입니다. 아래 명령을 실행하여 작업을 추가하실 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ewhenever --update-crontab\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eCron Job을 성공적으로 설정했습니다. 특정 시간에 실행되도록 예약되었습니다. 또한 whenever --clear-crontab 명령을 사용하여 crontab을 지울 수 있고, crontab을 보려면 crontab -l을 사용할 수 있습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003eSidekiq-Cron Gem\u003c/h1\u003e\n\u003cp\u003eSidekiq-cron은 작업 처리 라이브러리인 Sidekiq의 애드온입니다. Sidekiq-cron을 사용하면 특정 시간이나 간격에 작업을 예약할 수 있습니다. Sidekiq-cron은 Sidekiq에서 제공하는 공식 젬이 아님을 유의해야 합니다.\u003c/p\u003e\n\u003cp\u003eSidekiq에서 작업을 예약하는 것은 일반적으로 엔터프라이즈 수준의 기능으로 간주되어 유료 라이선스가 필요할 수 있습니다. 그러나 엔터프라이즈 버전에 돈을 쓰고 싶지 않다면 Sidekiq-cron은 여러분에게 적합한 대안입니다.\u003c/p\u003e\n\u003cp\u003e간단히 말하면, Sidekiq-cron은 공식 엔터프라이즈 버전을 지불하지 않고도 Sidekiq 내에서 작업을 예약할 수 있게 해주는 도구입니다. 비슷한 예약 기능을 제공하여 작업이 언제와 얼마나 자주 실행되어야 하는지 지정할 수 있습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003eSidekiq-Cron Gem 설정하기\u003c/h1\u003e\n\u003cp\u003e이제 우리의 애플리케이션에 Sidekiq-Cron 젬을 설정해 봅시다. 먼저 젬을 설치해야 합니다. Gemfile에 아래와 같이 젬을 추가하고 bundle install을 실행해주세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003egem \u003cspan class=\"hljs-string\"\u003e'sidekiq-cron'\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그런 다음 config/ 디렉토리에 schedule.yml 파일을 생성하세요. Whenever 젬의 경우처럼 파일을 초기화하는 기능은 제공되지 않지만, 다행히 Sidekiq-Cron은 파일을 초기화하는 기능을 제공하지 않습니다. 또한 config/initializers 디렉토리에 sidekiq.rb라는 이름의 파일을 생성하여 아래 내용을 추가해 주세요.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eschedule_file = \u003cspan class=\"hljs-string\"\u003e\"config/schedule.yml\"\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFile\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eexist\u003c/span\u003e?(schedule_file) \u0026#x26;\u0026#x26; \u003cspan class=\"hljs-title class_\"\u003eSidekiq\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eserver\u003c/span\u003e?\n   \u003cspan class=\"hljs-title class_\"\u003eSidekiq\u003c/span\u003e::\u003cspan class=\"hljs-title class_\"\u003eCron\u003c/span\u003e::\u003cspan class=\"hljs-title class_\"\u003eJob\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eload_from_hash\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eYAML\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eload_file\u003c/span\u003e(schedule_file)\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e우리의 초기 설정이 완료되었습니다. 이제 실제 작업을 생성할 차례입니다. 터미널로 이동하여 다음 명령을 입력하세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003erails generate job send_bulk_emails\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그리고 이 코드에 일부 기능을 추가하세요.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e참고: 레일즈 백그라운드 작업/워커를 설정, 생성 및 사용하는 방법에 대한 자세한 튜토리얼이 필요하시다면 이 기사를 참조해주세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSendBulkEmailJob\u003c/span\u003e \u0026#x3C; \u003cspan class=\"hljs-title class_\"\u003eApplicationJob\u003c/span\u003e\n  queue_as :\u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e\n\ndef \u003cspan class=\"hljs-title function_\"\u003eperform\u003c/span\u003e(emails)\n    begin\n      \u003cspan class=\"hljs-title class_\"\u003eBulkEmailService\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003esend_emails\u003c/span\u003e(emails)\n    rescue \u003cspan class=\"hljs-title class_\"\u003eStandardError\u003c/span\u003e =\u003e e\n      \u003cspan class=\"hljs-title class_\"\u003eRails\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003elogger\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eerror\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"Error sending bulk emails: #{e.message}\"\u003c/span\u003e\n      raise e\n    end\n  end\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e작업을 만든 후, 터미널에 sidekiq을 입력하여 실행하고 다음과 같이 스케줄러 파일에 작업을 추가하세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-attr\"\u003eemail_job\u003c/span\u003e:\n   \u003cspan class=\"hljs-attr\"\u003ecron\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"*/5 * * * *\"\u003c/span\u003e\n   \u003cspan class=\"hljs-attr\"\u003eclass\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"SendBulkEmailJob\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e워커를 실행하려면 터미널에서 새 탭을 열어주세요. 앱이 활성화된 상태에서도 워커가 계속 실행되어야 하는 점을 주의해 주세요. 레일즈 서버를 시작하거나 기타 작업을 실행해야 하는 경우 다른 탭으로 전환해야 합니다.\u003c/p\u003e\n\u003cp\u003e모두입니다! 첫 번째 Sidekiq-cron 작업을 생성한 것을 축하드립니다!\u003c/p\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003e요약하면, 크론 작업은 Unix/Linux 시스템에서 반복적인 작업을 자동화하는 데 필수적입니다. Whenever 젬은 루비 코드로 작성하고 크론 작업을 예약하는 레일즈 애플리케이션에서 간단하게 사용할 수 있도록 하며 crontab을 자동으로 업데이트합니다. Sidekiq-Cron은 Sidekiq에서 작업을 예약하는 데 유용한 젬입니다. 두 젬은 크론 작업을 관리하고 실행하는 과정을 간소화하여 애플리케이션의 자동화와 효율성을 향상시킵니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e앞으로의 기사에서는 Rails가 어떻게 작동하는지에 대해 더 알아볼 것입니다. 그러니 계속해서 주의 깊게 지켜보고 배우세요!\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-22-RailsCronJobsTaskSchedulingInRails"},"buildId":"JlBEgQDLGRx6DYlBnT8eD","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>