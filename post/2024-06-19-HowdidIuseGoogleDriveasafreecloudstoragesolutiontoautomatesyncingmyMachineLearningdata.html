<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>구글 드라이브를 무료 클라우드 저장 공간 솔루션으로 활용하여 머신 러닝 데이터 동기화를 자동화하는 방법 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-06-19-HowdidIuseGoogleDriveasafreecloudstoragesolutiontoautomatesyncingmyMachineLearningdata" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="구글 드라이브를 무료 클라우드 저장 공간 솔루션으로 활용하여 머신 러닝 데이터 동기화를 자동화하는 방법 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="구글 드라이브를 무료 클라우드 저장 공간 솔루션으로 활용하여 머신 러닝 데이터 동기화를 자동화하는 방법 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-19-HowdidIuseGoogleDriveasafreecloudstoragesolutiontoautomatesyncingmyMachineLearningdata_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-06-19-HowdidIuseGoogleDriveasafreecloudstoragesolutiontoautomatesyncingmyMachineLearningdata" data-gatsby-head="true"/><meta name="twitter:title" content="구글 드라이브를 무료 클라우드 저장 공간 솔루션으로 활용하여 머신 러닝 데이터 동기화를 자동화하는 방법 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-19-HowdidIuseGoogleDriveasafreecloudstoragesolutiontoautomatesyncingmyMachineLearningdata_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-19 11:59" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-4f7b40c1114f0d09.js" defer=""></script><script src="/_next/static/-dPCbnM2yhdKNgXe92VJV/_buildManifest.js" defer=""></script><script src="/_next/static/-dPCbnM2yhdKNgXe92VJV/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">구글 드라이브를 무료 클라우드 저장 공간 솔루션으로 활용하여 머신 러닝 데이터 동기화를 자동화하는 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="구글 드라이브를 무료 클라우드 저장 공간 솔루션으로 활용하여 머신 러닝 데이터 동기화를 자동화하는 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 19, 2024</span><span class="posts_reading_time__f7YPP">7<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-19-HowdidIuseGoogleDriveasafreecloudstoragesolutiontoautomatesyncingmyMachineLearningdata&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>Google Drive은 문서와 미디어를 저장하는 데 탁월한 도구이지만, 상상해보세요: 어떻게 하면 앱의 데이터를 저장하는 데 사용할 수 있을까요? 네, 저도 구름에 멀티플레이어 게임 데이터를 안전하고 무료로 저장하는 방법을 고민하고 있었습니다. 이 기사에서는 기계 학습을 위해 게임 데이터를 Google Drive에 저장한 방법에 대해 설명하겠습니다.</p>
<p><img src="/assets/img/2024-06-19-HowdidIuseGoogleDriveasafreecloudstoragesolutiontoautomatesyncingmyMachineLearningdata_0.png" alt="이미지가 여기에 표시됩니다."></p>
<p>📢 안녕하세요, 이 기사에서 언급된 서비스 중 어느 것도 스폰서로서 제작되지 않았습니다. 제가 애플리케이션에서 직접 사용해보며 개발자로서의 경험을 공유하고자 합니다.</p>
<p>📢 이 기사는 구글 서비스와의 인증을 위해 서비스 계정을 사용하는 데 어느 정도 익숙한 것으로 가정합니다. 서비스 계정 및 해당 링크를 통해 어떻게 생성하는지에 대해 더 알아볼 수 있습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>🤔 왜 구글 드라이브를 사용하게 된 걸까요?</h1>
<p>"The Strategists"의 승자를 예측하기 위한 머신 러닝 모델을 개발하는 도중, 모든 게임 데이터를 로컬 머신에 저장했습니다. 그 당시에는 그 방식이 합리적으로 느껴졌지만, 도커를 사용하여 게임을 컨테이너화하고 클라우드에 배포하기 시작하면서 몇 가지 의문이 생겼습니다.</p>
<p>훈련된 모델을 도커 이미지에 포함해야 할까요? 게임을 한 번씩 진행할 때마다 모델을 다시 훈련하기 때문에 게임 데이터를 도커 이미지에 포함해야 할까요? 게임 데이터를 도커 이미지에 저장하는 것이 안전한 일일까요? 이러한 질문들을 고민하면서, 보안 위험이 있기 때문에 모델과 게임 데이터를 함께 도커 이미지에 포함시키지 말아야겠다는 결론에 도달했습니다.</p>
<p>그래도 "The Strategists"를 배포할 때, 모든 게임 데이터와 예측 모델을 백엔드 도커 이미지에 포장해서 배포했습니다. 배포된 컨테이너에서 주기적으로 새로운 게임 데이터를 추출하는 아이디어도 고안했었죠. 이미 알 수 있겠지만, 이는 확장 가능한 해결책이 아니었습니다. 배포 단계에서 모델을 포장하지 않고 프로그래밍적으로 게임 데이터를 다운로드하고 업로드하며 훈련된 모델을 내보내야 한다는 것을 알았습니다. 그렇다면 어떻게 해야 할까요?</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이번 사용 사례에서는 Amazon S3 및 Google Cloud Storage와 같은 서비스를 탐색해 보았어요. 이전 글을 읽은 분들은 저의 의도를 알 거예요. 요금을 청구하지 않는 서비스를 찾았고, 호기심 많은 개발자로서 Google Drive를 사용하기로 결정했어요. Google Drive API를 사용해보고 싶었는데, 이는 Google Drive를 애플리케이션의 데이터 저장소로 사용하기 위한 기능을 프로토타입화하는 완벽한 기회였어요.</p>
<p>Google Drive를 사용하여 프로덕션에 준비된 애플리케이션을 개발하는 것은 표준 산업 관행이 아니라는 점을 강조해야 해요. Amazon S3와 같은 서비스는 오브젝트 잠금 및 ID 및 액세스 관리를 포함한 더 넓은 범위의 기능을 제공해요. 게다가, Google Drive의 무료 계층은 15GB의 저장 공간으로 제한되어 있어요.</p>
<h1>🛠️ 게임 데이터 동기화 구현은 어떻게 이루어졌을까요?</h1>
<p>우선, 제가 어떻게 게임 데이터를 동기화하는지에 대해 이야기해볼게요. 제 로컬 설정에서는 The Strategists의 머신 러닝 워크플로를 설명해서 서버 시작 시 모델을 훈련시킨 다음, SpringBoot 기반의 백엔드 서비스는 각 게임 세션 후에 다시 훈련시켰어요. 이 훈련은 플레이어 투자 패턴을 CSV 파일로 내보낸 다음, 예측 모델 디렉토리에 게임 상태를 내보낸 후에 발생했어요.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>데이터 내보내기 디렉토리에는 내보낸 CSV 파일이 모두 저장되어 있었기 때문에 훈련 스크립트는 이 데이터를 모두 로드하고 해당 데이터를 사용하여 모델을 훈련했습니다. 첫 번째 과제는 서버가 시작될 때 이 디렉토리를 채우는 것이었습니다. 훈련 스크립트가 예측 모델을 내보내기 위한 작업이 가능하도록 하려면 구글 드라이브 폴더에 있는 기존 CSV 파일을 업로드했습니다. 이 "Downloads" 폴더는 이제 게임 서버에서 사용 가능한 게임 데이터를 찾기 위해 참조되는 진실의 원천으로 제공됩니다.</p>
<p>이 과제에 대처하기 위해 "Downloads" 폴더에서 이 CSV 파일들을 다운로드하는 Python 유틸리티를 아래 스니펫처럼 작성했습니다. 실제 코드는 여기에서 확인할 수 있습니다.</p>
<pre><code class="hljs language-js"># <span class="hljs-title class_">Google</span> 서비스에 연결하기 위한 서버 자격 증명 생성
credentials = <span class="hljs-title class_">Credentials</span>.<span class="hljs-title function_">from_service_account_file</span>(filename=<span class="hljs-string">"&#x3C;SERVICE_ACCOUNT_FILE의_경로>"</span>)

# <span class="hljs-title class_">Google</span> 드라이브 서비스 초기화
service = discovery.<span class="hljs-title function_">build</span>(<span class="hljs-string">"drive"</span>, <span class="hljs-string">"v3"</span>, credentials=credentials)

# <span class="hljs-string">"Downloads"</span> 폴더에 있는 모든 <span class="hljs-variable constant_">CSV</span> 파일 나열
all_csv_files, page_token = [], <span class="hljs-title class_">None</span>
<span class="hljs-keyword">while</span> <span class="hljs-title class_">True</span>:

  # 현재 페이지 토큰에 대해 csv 파일 나열
  response = (
    service.<span class="hljs-title function_">files</span>().<span class="hljs-title function_">list</span>(
      q=f<span class="hljs-string">"(mimeType='text/csv') and ('&#x3C;DOWNLOADS_폴더_ID>' in parents)"</span>,
      spaces=<span class="hljs-string">"drive"</span>,
      fields=<span class="hljs-string">"nextPageToken, files(id, name)"</span>,
      pageToken=page_token
    ).<span class="hljs-title function_">execute</span>()
  )

  # 리스트에 csv 파일 추가
  csv_files, page_token = response.<span class="hljs-title function_">get</span>(<span class="hljs-string">"files"</span>, []), response.<span class="hljs-title function_">get</span>(<span class="hljs-string">"nextPageToken"</span>, <span class="hljs-title class_">None</span>)
  all_csv_files.<span class="hljs-title function_">extend</span>(csv_files)

  # 더 많은 csv 파일이 있는지 확인
  <span class="hljs-keyword">if</span> page_token is <span class="hljs-title class_">None</span>:
    <span class="hljs-keyword">break</span>

# 나열된 모든 csv 파일 다운로드
<span class="hljs-keyword">for</span> i, csv_file <span class="hljs-keyword">in</span> <span class="hljs-title function_">enumerate</span>(all_csv_files):

  # csv 파일 메타데이터 가져오기
  csv_file_id, csv_file_name = csv_file.<span class="hljs-title function_">get</span>(<span class="hljs-string">"id"</span>), csv_file.<span class="hljs-title function_">get</span>(<span class="hljs-string">"name"</span>)

  # csv 파일 바이트 가져오기
  csv_bytes = io.<span class="hljs-title class_">BytesIO</span>()
  downloader = <span class="hljs-title class_">MediaIoBaseDownload</span>(file, request)
  downloaded = <span class="hljs-title class_">False</span>
  <span class="hljs-keyword">while</span> downloaded is <span class="hljs-title class_">False</span>:
    status, downloaded = downloader.<span class="hljs-title function_">next_chunk</span>()

  # 파일 내용 저장
  export_file_path = os.<span class="hljs-property">path</span>.<span class="hljs-title function_">join</span>(<span class="hljs-string">"&#x3C;데이터_디렉토리>"</span>, csv_file_name)
  <span class="hljs-keyword">with</span> <span class="hljs-title function_">open</span>(export_file_path, <span class="hljs-string">"wb"</span>) <span class="hljs-keyword">as</span> <span class="hljs-attr">csv</span>:
    csv.<span class="hljs-title function_">write</span>(csv_bytes.<span class="hljs-title function_">getvalue</span>())
</code></pre>
<p>구글 서비스 계정의 이메일 주소가 최소한 "뷰어" 권한으로 이 CSV 파일에 액세스할 수 있도록 이 "Downloads" 폴더를 공유하도록 반드시 확인해주세요.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>데이터 다운로드 문제를 해결했으니, 이제 새 CSV 파일을 Google 드라이브에 업로드하는 방법을 구현하기 시작했습니다. 이를 위해 "Uploads"라는 폴더를 만들었고, CSV 파일의 다운로드와 업로드를 위해 별도의 폴더를 유지했습니다. 새 CSV 파일이 다운로드 폴더로 이동하기 전에 먼저 제가 확인할 수 있도록 했습니다.</p>
<p>다음 코드 조각은 이 "Upload" 폴더로 CSV 파일을 업로드한 방법입니다. 실제 코드는 여기에서 확인하실 수 있습니다.</p>
<pre><code class="hljs language-js"># 모든 로컬 csv 파일 나열
local_csv_files = []
<span class="hljs-keyword">for</span> file_name <span class="hljs-keyword">in</span> os.<span class="hljs-title function_">listdir</span>(<span class="hljs-string">"&#x3C;DATA_DIRECTORY>"</span>):
  <span class="hljs-keyword">if</span> file_name.<span class="hljs-title function_">endswith</span>(<span class="hljs-string">".csv"</span>):
    local_csv_files.<span class="hljs-title function_">append</span>(file_name)

# 나열된 모든 로컬 csv 파일 다운로드
<span class="hljs-keyword">for</span> i, local_csv_file <span class="hljs-keyword">in</span> <span class="hljs-title function_">enumerate</span>(local_csv_files):

  # 업로드할 <span class="hljs-variable constant_">CSV</span> 파일을 업로드 폴더에 업로드
  local_csv_file_path = os.<span class="hljs-property">path</span>.<span class="hljs-title function_">join</span>(<span class="hljs-string">"&#x3C;DATA_DIRECTORY>"</span>, local_csv_file)
  mimeType = <span class="hljs-string">"text/csv"</span>

  body = {
    <span class="hljs-string">"name"</span>: local_csv_file,
    <span class="hljs-string">"mimeType"</span>: mimeType,
    <span class="hljs-string">"parents"</span>: [<span class="hljs-string">"&#x3C;UPLOADS_FOLDER_ID>"</span>]
  }
  media = <span class="hljs-title class_">MediaFileUpload</span>(local_csv_file_path, mimetype=mimeType)
  file = service.<span class="hljs-title function_">files</span>().<span class="hljs-title function_">create</span>(body=body, media_body=media, fields=<span class="hljs-string">"id"</span>)
</code></pre>
<p>스크립트가 새 CSV 파일을 업로드할 수 있도록 Google 서비스 계정 이메일 주소에 적어도 "편집자" 권한으로 이 "Uploads" 폴더를 공유해야 합니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>실제 코드 구현에서는 서버 데이터 디렉토리에 있는 CSV 파일만 다운로드했습니다. 업로드에 대해선 "다운로드" 또는 "업로드" 구글 드라이브 폴더에 이미 존재하지 않은 CSV 파일만 업로드했습니다.</p>
<p>이 기사가 여러분이 응용 프로그램의 무료 클라우드 저장소로 Google 드라이브를 어떻게 사용하는지 이해하는 데 도움이 되었으면 좋겠습니다. The Strategists의 개발을 계속 따르고 싶다면 제 블로그를 구독해보세요. 프로젝트에 기여하는 것을 고려해주시고, 다음 링크를 통해 GitHub의 프로젝트 저장소에 액세스할 수 있습니다.</p>
<p>제 포트폴리오를 확인해보세요. 시간 내어 이 기사를 읽어주셔서 감사합니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"구글 드라이브를 무료 클라우드 저장 공간 솔루션으로 활용하여 머신 러닝 데이터 동기화를 자동화하는 방법","description":"","date":"2024-06-19 11:59","slug":"2024-06-19-HowdidIuseGoogleDriveasafreecloudstoragesolutiontoautomatesyncingmyMachineLearningdata","content":"\nGoogle Drive은 문서와 미디어를 저장하는 데 탁월한 도구이지만, 상상해보세요: 어떻게 하면 앱의 데이터를 저장하는 데 사용할 수 있을까요? 네, 저도 구름에 멀티플레이어 게임 데이터를 안전하고 무료로 저장하는 방법을 고민하고 있었습니다. 이 기사에서는 기계 학습을 위해 게임 데이터를 Google Drive에 저장한 방법에 대해 설명하겠습니다.\n\n![이미지가 여기에 표시됩니다.](/assets/img/2024-06-19-HowdidIuseGoogleDriveasafreecloudstoragesolutiontoautomatesyncingmyMachineLearningdata_0.png)\n\n📢 안녕하세요, 이 기사에서 언급된 서비스 중 어느 것도 스폰서로서 제작되지 않았습니다. 제가 애플리케이션에서 직접 사용해보며 개발자로서의 경험을 공유하고자 합니다.\n\n📢 이 기사는 구글 서비스와의 인증을 위해 서비스 계정을 사용하는 데 어느 정도 익숙한 것으로 가정합니다. 서비스 계정 및 해당 링크를 통해 어떻게 생성하는지에 대해 더 알아볼 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 🤔 왜 구글 드라이브를 사용하게 된 걸까요?\n\n\"The Strategists\"의 승자를 예측하기 위한 머신 러닝 모델을 개발하는 도중, 모든 게임 데이터를 로컬 머신에 저장했습니다. 그 당시에는 그 방식이 합리적으로 느껴졌지만, 도커를 사용하여 게임을 컨테이너화하고 클라우드에 배포하기 시작하면서 몇 가지 의문이 생겼습니다.\n\n훈련된 모델을 도커 이미지에 포함해야 할까요? 게임을 한 번씩 진행할 때마다 모델을 다시 훈련하기 때문에 게임 데이터를 도커 이미지에 포함해야 할까요? 게임 데이터를 도커 이미지에 저장하는 것이 안전한 일일까요? 이러한 질문들을 고민하면서, 보안 위험이 있기 때문에 모델과 게임 데이터를 함께 도커 이미지에 포함시키지 말아야겠다는 결론에 도달했습니다.\n\n그래도 \"The Strategists\"를 배포할 때, 모든 게임 데이터와 예측 모델을 백엔드 도커 이미지에 포장해서 배포했습니다. 배포된 컨테이너에서 주기적으로 새로운 게임 데이터를 추출하는 아이디어도 고안했었죠. 이미 알 수 있겠지만, 이는 확장 가능한 해결책이 아니었습니다. 배포 단계에서 모델을 포장하지 않고 프로그래밍적으로 게임 데이터를 다운로드하고 업로드하며 훈련된 모델을 내보내야 한다는 것을 알았습니다. 그렇다면 어떻게 해야 할까요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이번 사용 사례에서는 Amazon S3 및 Google Cloud Storage와 같은 서비스를 탐색해 보았어요. 이전 글을 읽은 분들은 저의 의도를 알 거예요. 요금을 청구하지 않는 서비스를 찾았고, 호기심 많은 개발자로서 Google Drive를 사용하기로 결정했어요. Google Drive API를 사용해보고 싶었는데, 이는 Google Drive를 애플리케이션의 데이터 저장소로 사용하기 위한 기능을 프로토타입화하는 완벽한 기회였어요.\n\nGoogle Drive를 사용하여 프로덕션에 준비된 애플리케이션을 개발하는 것은 표준 산업 관행이 아니라는 점을 강조해야 해요. Amazon S3와 같은 서비스는 오브젝트 잠금 및 ID 및 액세스 관리를 포함한 더 넓은 범위의 기능을 제공해요. 게다가, Google Drive의 무료 계층은 15GB의 저장 공간으로 제한되어 있어요.\n\n# 🛠️ 게임 데이터 동기화 구현은 어떻게 이루어졌을까요?\n\n우선, 제가 어떻게 게임 데이터를 동기화하는지에 대해 이야기해볼게요. 제 로컬 설정에서는 The Strategists의 머신 러닝 워크플로를 설명해서 서버 시작 시 모델을 훈련시킨 다음, SpringBoot 기반의 백엔드 서비스는 각 게임 세션 후에 다시 훈련시켰어요. 이 훈련은 플레이어 투자 패턴을 CSV 파일로 내보낸 다음, 예측 모델 디렉토리에 게임 상태를 내보낸 후에 발생했어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n데이터 내보내기 디렉토리에는 내보낸 CSV 파일이 모두 저장되어 있었기 때문에 훈련 스크립트는 이 데이터를 모두 로드하고 해당 데이터를 사용하여 모델을 훈련했습니다. 첫 번째 과제는 서버가 시작될 때 이 디렉토리를 채우는 것이었습니다. 훈련 스크립트가 예측 모델을 내보내기 위한 작업이 가능하도록 하려면 구글 드라이브 폴더에 있는 기존 CSV 파일을 업로드했습니다. 이 \"Downloads\" 폴더는 이제 게임 서버에서 사용 가능한 게임 데이터를 찾기 위해 참조되는 진실의 원천으로 제공됩니다.\n\n이 과제에 대처하기 위해 \"Downloads\" 폴더에서 이 CSV 파일들을 다운로드하는 Python 유틸리티를 아래 스니펫처럼 작성했습니다. 실제 코드는 여기에서 확인할 수 있습니다.\n\n```js\n# Google 서비스에 연결하기 위한 서버 자격 증명 생성\ncredentials = Credentials.from_service_account_file(filename=\"\u003cSERVICE_ACCOUNT_FILE의_경로\u003e\")\n\n# Google 드라이브 서비스 초기화\nservice = discovery.build(\"drive\", \"v3\", credentials=credentials)\n\n# \"Downloads\" 폴더에 있는 모든 CSV 파일 나열\nall_csv_files, page_token = [], None\nwhile True:\n\n  # 현재 페이지 토큰에 대해 csv 파일 나열\n  response = (\n    service.files().list(\n      q=f\"(mimeType='text/csv') and ('\u003cDOWNLOADS_폴더_ID\u003e' in parents)\",\n      spaces=\"drive\",\n      fields=\"nextPageToken, files(id, name)\",\n      pageToken=page_token\n    ).execute()\n  )\n\n  # 리스트에 csv 파일 추가\n  csv_files, page_token = response.get(\"files\", []), response.get(\"nextPageToken\", None)\n  all_csv_files.extend(csv_files)\n\n  # 더 많은 csv 파일이 있는지 확인\n  if page_token is None:\n    break\n\n# 나열된 모든 csv 파일 다운로드\nfor i, csv_file in enumerate(all_csv_files):\n\n  # csv 파일 메타데이터 가져오기\n  csv_file_id, csv_file_name = csv_file.get(\"id\"), csv_file.get(\"name\")\n\n  # csv 파일 바이트 가져오기\n  csv_bytes = io.BytesIO()\n  downloader = MediaIoBaseDownload(file, request)\n  downloaded = False\n  while downloaded is False:\n    status, downloaded = downloader.next_chunk()\n\n  # 파일 내용 저장\n  export_file_path = os.path.join(\"\u003c데이터_디렉토리\u003e\", csv_file_name)\n  with open(export_file_path, \"wb\") as csv:\n    csv.write(csv_bytes.getvalue())\n```\n\n구글 서비스 계정의 이메일 주소가 최소한 \"뷰어\" 권한으로 이 CSV 파일에 액세스할 수 있도록 이 \"Downloads\" 폴더를 공유하도록 반드시 확인해주세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n데이터 다운로드 문제를 해결했으니, 이제 새 CSV 파일을 Google 드라이브에 업로드하는 방법을 구현하기 시작했습니다. 이를 위해 \"Uploads\"라는 폴더를 만들었고, CSV 파일의 다운로드와 업로드를 위해 별도의 폴더를 유지했습니다. 새 CSV 파일이 다운로드 폴더로 이동하기 전에 먼저 제가 확인할 수 있도록 했습니다.\n\n다음 코드 조각은 이 \"Upload\" 폴더로 CSV 파일을 업로드한 방법입니다. 실제 코드는 여기에서 확인하실 수 있습니다.\n\n```js\n# 모든 로컬 csv 파일 나열\nlocal_csv_files = []\nfor file_name in os.listdir(\"\u003cDATA_DIRECTORY\u003e\"):\n  if file_name.endswith(\".csv\"):\n    local_csv_files.append(file_name)\n\n# 나열된 모든 로컬 csv 파일 다운로드\nfor i, local_csv_file in enumerate(local_csv_files):\n\n  # 업로드할 CSV 파일을 업로드 폴더에 업로드\n  local_csv_file_path = os.path.join(\"\u003cDATA_DIRECTORY\u003e\", local_csv_file)\n  mimeType = \"text/csv\"\n\n  body = {\n    \"name\": local_csv_file,\n    \"mimeType\": mimeType,\n    \"parents\": [\"\u003cUPLOADS_FOLDER_ID\u003e\"]\n  }\n  media = MediaFileUpload(local_csv_file_path, mimetype=mimeType)\n  file = service.files().create(body=body, media_body=media, fields=\"id\")\n```\n\n스크립트가 새 CSV 파일을 업로드할 수 있도록 Google 서비스 계정 이메일 주소에 적어도 \"편집자\" 권한으로 이 \"Uploads\" 폴더를 공유해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n실제 코드 구현에서는 서버 데이터 디렉토리에 있는 CSV 파일만 다운로드했습니다. 업로드에 대해선 \"다운로드\" 또는 \"업로드\" 구글 드라이브 폴더에 이미 존재하지 않은 CSV 파일만 업로드했습니다.\n\n이 기사가 여러분이 응용 프로그램의 무료 클라우드 저장소로 Google 드라이브를 어떻게 사용하는지 이해하는 데 도움이 되었으면 좋겠습니다. The Strategists의 개발을 계속 따르고 싶다면 제 블로그를 구독해보세요. 프로젝트에 기여하는 것을 고려해주시고, 다음 링크를 통해 GitHub의 프로젝트 저장소에 액세스할 수 있습니다.\n\n제 포트폴리오를 확인해보세요. 시간 내어 이 기사를 읽어주셔서 감사합니다.\n","ogImage":{"url":"/assets/img/2024-06-19-HowdidIuseGoogleDriveasafreecloudstoragesolutiontoautomatesyncingmyMachineLearningdata_0.png"},"coverImage":"/assets/img/2024-06-19-HowdidIuseGoogleDriveasafreecloudstoragesolutiontoautomatesyncingmyMachineLearningdata_0.png","tag":["Tech"],"readingTime":7},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003eGoogle Drive은 문서와 미디어를 저장하는 데 탁월한 도구이지만, 상상해보세요: 어떻게 하면 앱의 데이터를 저장하는 데 사용할 수 있을까요? 네, 저도 구름에 멀티플레이어 게임 데이터를 안전하고 무료로 저장하는 방법을 고민하고 있었습니다. 이 기사에서는 기계 학습을 위해 게임 데이터를 Google Drive에 저장한 방법에 대해 설명하겠습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-HowdidIuseGoogleDriveasafreecloudstoragesolutiontoautomatesyncingmyMachineLearningdata_0.png\" alt=\"이미지가 여기에 표시됩니다.\"\u003e\u003c/p\u003e\n\u003cp\u003e📢 안녕하세요, 이 기사에서 언급된 서비스 중 어느 것도 스폰서로서 제작되지 않았습니다. 제가 애플리케이션에서 직접 사용해보며 개발자로서의 경험을 공유하고자 합니다.\u003c/p\u003e\n\u003cp\u003e📢 이 기사는 구글 서비스와의 인증을 위해 서비스 계정을 사용하는 데 어느 정도 익숙한 것으로 가정합니다. 서비스 계정 및 해당 링크를 통해 어떻게 생성하는지에 대해 더 알아볼 수 있습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e🤔 왜 구글 드라이브를 사용하게 된 걸까요?\u003c/h1\u003e\n\u003cp\u003e\"The Strategists\"의 승자를 예측하기 위한 머신 러닝 모델을 개발하는 도중, 모든 게임 데이터를 로컬 머신에 저장했습니다. 그 당시에는 그 방식이 합리적으로 느껴졌지만, 도커를 사용하여 게임을 컨테이너화하고 클라우드에 배포하기 시작하면서 몇 가지 의문이 생겼습니다.\u003c/p\u003e\n\u003cp\u003e훈련된 모델을 도커 이미지에 포함해야 할까요? 게임을 한 번씩 진행할 때마다 모델을 다시 훈련하기 때문에 게임 데이터를 도커 이미지에 포함해야 할까요? 게임 데이터를 도커 이미지에 저장하는 것이 안전한 일일까요? 이러한 질문들을 고민하면서, 보안 위험이 있기 때문에 모델과 게임 데이터를 함께 도커 이미지에 포함시키지 말아야겠다는 결론에 도달했습니다.\u003c/p\u003e\n\u003cp\u003e그래도 \"The Strategists\"를 배포할 때, 모든 게임 데이터와 예측 모델을 백엔드 도커 이미지에 포장해서 배포했습니다. 배포된 컨테이너에서 주기적으로 새로운 게임 데이터를 추출하는 아이디어도 고안했었죠. 이미 알 수 있겠지만, 이는 확장 가능한 해결책이 아니었습니다. 배포 단계에서 모델을 포장하지 않고 프로그래밍적으로 게임 데이터를 다운로드하고 업로드하며 훈련된 모델을 내보내야 한다는 것을 알았습니다. 그렇다면 어떻게 해야 할까요?\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이번 사용 사례에서는 Amazon S3 및 Google Cloud Storage와 같은 서비스를 탐색해 보았어요. 이전 글을 읽은 분들은 저의 의도를 알 거예요. 요금을 청구하지 않는 서비스를 찾았고, 호기심 많은 개발자로서 Google Drive를 사용하기로 결정했어요. Google Drive API를 사용해보고 싶었는데, 이는 Google Drive를 애플리케이션의 데이터 저장소로 사용하기 위한 기능을 프로토타입화하는 완벽한 기회였어요.\u003c/p\u003e\n\u003cp\u003eGoogle Drive를 사용하여 프로덕션에 준비된 애플리케이션을 개발하는 것은 표준 산업 관행이 아니라는 점을 강조해야 해요. Amazon S3와 같은 서비스는 오브젝트 잠금 및 ID 및 액세스 관리를 포함한 더 넓은 범위의 기능을 제공해요. 게다가, Google Drive의 무료 계층은 15GB의 저장 공간으로 제한되어 있어요.\u003c/p\u003e\n\u003ch1\u003e🛠️ 게임 데이터 동기화 구현은 어떻게 이루어졌을까요?\u003c/h1\u003e\n\u003cp\u003e우선, 제가 어떻게 게임 데이터를 동기화하는지에 대해 이야기해볼게요. 제 로컬 설정에서는 The Strategists의 머신 러닝 워크플로를 설명해서 서버 시작 시 모델을 훈련시킨 다음, SpringBoot 기반의 백엔드 서비스는 각 게임 세션 후에 다시 훈련시켰어요. 이 훈련은 플레이어 투자 패턴을 CSV 파일로 내보낸 다음, 예측 모델 디렉토리에 게임 상태를 내보낸 후에 발생했어요.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e데이터 내보내기 디렉토리에는 내보낸 CSV 파일이 모두 저장되어 있었기 때문에 훈련 스크립트는 이 데이터를 모두 로드하고 해당 데이터를 사용하여 모델을 훈련했습니다. 첫 번째 과제는 서버가 시작될 때 이 디렉토리를 채우는 것이었습니다. 훈련 스크립트가 예측 모델을 내보내기 위한 작업이 가능하도록 하려면 구글 드라이브 폴더에 있는 기존 CSV 파일을 업로드했습니다. 이 \"Downloads\" 폴더는 이제 게임 서버에서 사용 가능한 게임 데이터를 찾기 위해 참조되는 진실의 원천으로 제공됩니다.\u003c/p\u003e\n\u003cp\u003e이 과제에 대처하기 위해 \"Downloads\" 폴더에서 이 CSV 파일들을 다운로드하는 Python 유틸리티를 아래 스니펫처럼 작성했습니다. 실제 코드는 여기에서 확인할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# \u003cspan class=\"hljs-title class_\"\u003eGoogle\u003c/span\u003e 서비스에 연결하기 위한 서버 자격 증명 생성\ncredentials = \u003cspan class=\"hljs-title class_\"\u003eCredentials\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efrom_service_account_file\u003c/span\u003e(filename=\u003cspan class=\"hljs-string\"\u003e\"\u0026#x3C;SERVICE_ACCOUNT_FILE의_경로\u003e\"\u003c/span\u003e)\n\n# \u003cspan class=\"hljs-title class_\"\u003eGoogle\u003c/span\u003e 드라이브 서비스 초기화\nservice = discovery.\u003cspan class=\"hljs-title function_\"\u003ebuild\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"drive\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"v3\"\u003c/span\u003e, credentials=credentials)\n\n# \u003cspan class=\"hljs-string\"\u003e\"Downloads\"\u003c/span\u003e 폴더에 있는 모든 \u003cspan class=\"hljs-variable constant_\"\u003eCSV\u003c/span\u003e 파일 나열\nall_csv_files, page_token = [], \u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e:\n\n  # 현재 페이지 토큰에 대해 csv 파일 나열\n  response = (\n    service.\u003cspan class=\"hljs-title function_\"\u003efiles\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003elist\u003c/span\u003e(\n      q=f\u003cspan class=\"hljs-string\"\u003e\"(mimeType='text/csv') and ('\u0026#x3C;DOWNLOADS_폴더_ID\u003e' in parents)\"\u003c/span\u003e,\n      spaces=\u003cspan class=\"hljs-string\"\u003e\"drive\"\u003c/span\u003e,\n      fields=\u003cspan class=\"hljs-string\"\u003e\"nextPageToken, files(id, name)\"\u003c/span\u003e,\n      pageToken=page_token\n    ).\u003cspan class=\"hljs-title function_\"\u003eexecute\u003c/span\u003e()\n  )\n\n  # 리스트에 csv 파일 추가\n  csv_files, page_token = response.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"files\"\u003c/span\u003e, []), response.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"nextPageToken\"\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e)\n  all_csv_files.\u003cspan class=\"hljs-title function_\"\u003eextend\u003c/span\u003e(csv_files)\n\n  # 더 많은 csv 파일이 있는지 확인\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e page_token is \u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e:\n    \u003cspan class=\"hljs-keyword\"\u003ebreak\u003c/span\u003e\n\n# 나열된 모든 csv 파일 다운로드\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e i, csv_file \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eenumerate\u003c/span\u003e(all_csv_files):\n\n  # csv 파일 메타데이터 가져오기\n  csv_file_id, csv_file_name = csv_file.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"id\"\u003c/span\u003e), csv_file.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"name\"\u003c/span\u003e)\n\n  # csv 파일 바이트 가져오기\n  csv_bytes = io.\u003cspan class=\"hljs-title class_\"\u003eBytesIO\u003c/span\u003e()\n  downloader = \u003cspan class=\"hljs-title class_\"\u003eMediaIoBaseDownload\u003c/span\u003e(file, request)\n  downloaded = \u003cspan class=\"hljs-title class_\"\u003eFalse\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e downloaded is \u003cspan class=\"hljs-title class_\"\u003eFalse\u003c/span\u003e:\n    status, downloaded = downloader.\u003cspan class=\"hljs-title function_\"\u003enext_chunk\u003c/span\u003e()\n\n  # 파일 내용 저장\n  export_file_path = os.\u003cspan class=\"hljs-property\"\u003epath\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ejoin\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"\u0026#x3C;데이터_디렉토리\u003e\"\u003c/span\u003e, csv_file_name)\n  \u003cspan class=\"hljs-keyword\"\u003ewith\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eopen\u003c/span\u003e(export_file_path, \u003cspan class=\"hljs-string\"\u003e\"wb\"\u003c/span\u003e) \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ecsv\u003c/span\u003e:\n    csv.\u003cspan class=\"hljs-title function_\"\u003ewrite\u003c/span\u003e(csv_bytes.\u003cspan class=\"hljs-title function_\"\u003egetvalue\u003c/span\u003e())\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e구글 서비스 계정의 이메일 주소가 최소한 \"뷰어\" 권한으로 이 CSV 파일에 액세스할 수 있도록 이 \"Downloads\" 폴더를 공유하도록 반드시 확인해주세요.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e데이터 다운로드 문제를 해결했으니, 이제 새 CSV 파일을 Google 드라이브에 업로드하는 방법을 구현하기 시작했습니다. 이를 위해 \"Uploads\"라는 폴더를 만들었고, CSV 파일의 다운로드와 업로드를 위해 별도의 폴더를 유지했습니다. 새 CSV 파일이 다운로드 폴더로 이동하기 전에 먼저 제가 확인할 수 있도록 했습니다.\u003c/p\u003e\n\u003cp\u003e다음 코드 조각은 이 \"Upload\" 폴더로 CSV 파일을 업로드한 방법입니다. 실제 코드는 여기에서 확인하실 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 모든 로컬 csv 파일 나열\nlocal_csv_files = []\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e file_name \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e os.\u003cspan class=\"hljs-title function_\"\u003elistdir\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"\u0026#x3C;DATA_DIRECTORY\u003e\"\u003c/span\u003e):\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e file_name.\u003cspan class=\"hljs-title function_\"\u003eendswith\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\".csv\"\u003c/span\u003e):\n    local_csv_files.\u003cspan class=\"hljs-title function_\"\u003eappend\u003c/span\u003e(file_name)\n\n# 나열된 모든 로컬 csv 파일 다운로드\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e i, local_csv_file \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eenumerate\u003c/span\u003e(local_csv_files):\n\n  # 업로드할 \u003cspan class=\"hljs-variable constant_\"\u003eCSV\u003c/span\u003e 파일을 업로드 폴더에 업로드\n  local_csv_file_path = os.\u003cspan class=\"hljs-property\"\u003epath\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ejoin\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"\u0026#x3C;DATA_DIRECTORY\u003e\"\u003c/span\u003e, local_csv_file)\n  mimeType = \u003cspan class=\"hljs-string\"\u003e\"text/csv\"\u003c/span\u003e\n\n  body = {\n    \u003cspan class=\"hljs-string\"\u003e\"name\"\u003c/span\u003e: local_csv_file,\n    \u003cspan class=\"hljs-string\"\u003e\"mimeType\"\u003c/span\u003e: mimeType,\n    \u003cspan class=\"hljs-string\"\u003e\"parents\"\u003c/span\u003e: [\u003cspan class=\"hljs-string\"\u003e\"\u0026#x3C;UPLOADS_FOLDER_ID\u003e\"\u003c/span\u003e]\n  }\n  media = \u003cspan class=\"hljs-title class_\"\u003eMediaFileUpload\u003c/span\u003e(local_csv_file_path, mimetype=mimeType)\n  file = service.\u003cspan class=\"hljs-title function_\"\u003efiles\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003ecreate\u003c/span\u003e(body=body, media_body=media, fields=\u003cspan class=\"hljs-string\"\u003e\"id\"\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e스크립트가 새 CSV 파일을 업로드할 수 있도록 Google 서비스 계정 이메일 주소에 적어도 \"편집자\" 권한으로 이 \"Uploads\" 폴더를 공유해야 합니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e실제 코드 구현에서는 서버 데이터 디렉토리에 있는 CSV 파일만 다운로드했습니다. 업로드에 대해선 \"다운로드\" 또는 \"업로드\" 구글 드라이브 폴더에 이미 존재하지 않은 CSV 파일만 업로드했습니다.\u003c/p\u003e\n\u003cp\u003e이 기사가 여러분이 응용 프로그램의 무료 클라우드 저장소로 Google 드라이브를 어떻게 사용하는지 이해하는 데 도움이 되었으면 좋겠습니다. The Strategists의 개발을 계속 따르고 싶다면 제 블로그를 구독해보세요. 프로젝트에 기여하는 것을 고려해주시고, 다음 링크를 통해 GitHub의 프로젝트 저장소에 액세스할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e제 포트폴리오를 확인해보세요. 시간 내어 이 기사를 읽어주셔서 감사합니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-19-HowdidIuseGoogleDriveasafreecloudstoragesolutiontoautomatesyncingmyMachineLearningdata"},"buildId":"-dPCbnM2yhdKNgXe92VJV","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>