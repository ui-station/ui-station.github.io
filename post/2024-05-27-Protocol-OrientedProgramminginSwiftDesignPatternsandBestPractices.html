<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>스위프트에서의 프로토콜 지향 프로그래밍 디자인 패턴과 최선의 광고 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-05-27-Protocol-OrientedProgramminginSwiftDesignPatternsandBestPractices" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="스위프트에서의 프로토콜 지향 프로그래밍 디자인 패턴과 최선의 광고 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="스위프트에서의 프로토콜 지향 프로그래밍 디자인 패턴과 최선의 광고 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-27-Protocol-OrientedProgramminginSwiftDesignPatternsandBestPractices_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-05-27-Protocol-OrientedProgramminginSwiftDesignPatternsandBestPractices" data-gatsby-head="true"/><meta name="twitter:title" content="스위프트에서의 프로토콜 지향 프로그래밍 디자인 패턴과 최선의 광고 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-27-Protocol-OrientedProgramminginSwiftDesignPatternsandBestPractices_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-27 16:27" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-70e5ce89f3d962ac.js" defer=""></script><script src="/_next/static/wfHLuDA3kTGBYfaM5IGXk/_buildManifest.js" defer=""></script><script src="/_next/static/wfHLuDA3kTGBYfaM5IGXk/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">스위프트에서의 프로토콜 지향 프로그래밍 디자인 패턴과 최선의 광고</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="스위프트에서의 프로토콜 지향 프로그래밍 디자인 패턴과 최선의 광고" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 27, 2024</span><span class="posts_reading_time__f7YPP">8<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-27-Protocol-OrientedProgramminginSwiftDesignPatternsandBestPractices&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<img src="/assets/img/2024-05-27-Protocol-OrientedProgramminginSwiftDesignPatternsandBestPractices_0.png">
<p>소개</p>
<p>프로토콜 지향 프로그래밍(POP)은 스위프트 개발에서 핵심 패러다임 중 하나로 자리 잡았으며, 전통적인 객체지향 프로그래밍에 강력한 대안을 제공합니다. 프로토콜에 주목함으로써, 스위프트는 개발자들이 유연하고 재사용 가능하며 테스트 가능한 코드를 작성할 수 있게 해줍니다. 이 글에서는 프로토콜 지향 프로그래밍의 원칙을 탐구하고, 일반적인 디자인 패턴을 살펴보며, 스위프트에서 프로토콜을 통해 견고한 애플리케이션을 구축하는 데 가장 좋은 방법을 논의할 것입니다.</p>
<p>왜 프로토콜 지향 프로그래밍을 해야 할까요?</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>POP은 작업이나 기능에 대한 청사진을 정의하는 데 프로토콜 사용을 장려합니다. 이 접근 방식은 여러 가지 이점을 제공합니다:</p>
<ul>
<li>유연성: 프로토콜을 사용하면 타입이 여러 프로토콜을 준수하도록 하여 보다 유연한 아키텍처를 구축할 수 있습니다.</li>
<li>재사용성: 공통 기능은 프로토콜에 정의하고 다양한 타입 간에 재사용할 수 있습니다.</li>
<li>테스트 용이성: 프로토콜은 의존성 주입을 용이하게 하여 단위 테스트에서 의존성을 가짜로 대체하기 쉽습니다.</li>
<li>결합도 낮추기: 프로토콜은 인터페이스를 정의함으로써 코드를 결합도 낮추며 구체적인 구현 대신 인터페이스를 정의합니다. 역할 분리를 촉진합니다.</li>
</ul>
<p>프로토콜을 활용하기
기본 프로토콜 정의</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js">프로토콜 <span class="hljs-title class_">Drivable</span> {
    <span class="hljs-keyword">var</span> <span class="hljs-attr">speed</span>: <span class="hljs-title class_">Double</span> { get }
    func <span class="hljs-title function_">drive</span>()
}

구조체 <span class="hljs-title class_">Car</span>: <span class="hljs-title class_">Drivable</span> {
    <span class="hljs-keyword">var</span> <span class="hljs-attr">speed</span>: <span class="hljs-title class_">Double</span>

    func <span class="hljs-title function_">drive</span>(<span class="hljs-params"></span>) {
        <span class="hljs-title function_">print</span>(<span class="hljs-string">"속도: \(speed) km/h로 주행 중"</span>)
    }
}

<span class="hljs-keyword">let</span> car = <span class="hljs-title class_">Car</span>(<span class="hljs-attr">speed</span>: <span class="hljs-number">120</span>)
car.<span class="hljs-title function_">drive</span>()  <span class="hljs-comment">// 출력: 속도: 120.0 km/h로 주행 중</span>
</code></pre>
<p>이 예제에서는 speed 속성과 drive 메서드가 있는 Drivable 프로토콜을 정의합니다. Car 구조체는 Drivable 프로토콜을 준수하며 필요한 속성과 메서드를 구현합니다.</p>
<p>프로토콜 익스텐션</p>
<p>프로토콜 익스텐션을 사용하여 프로토콜 메서드에 대한 기본 구현을 제공할 수 있으며 주어진 유형의 기능을 확장할 수 있습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>프로토콜 확장 예제</p>
<pre><code class="hljs language-swift"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Drivable</span> {
    <span class="hljs-keyword">var</span> speed: <span class="hljs-type">Double</span> { <span class="hljs-keyword">get</span> }
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">drive</span>()
}

<span class="hljs-keyword">extension</span> <span class="hljs-title class_">Drivable</span> {
    <span class="hljs-keyword">func</span> <span class="hljs-title function_">drive</span>() {
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"Driving at <span class="hljs-subst">\(speed)</span> km/h"</span>)
    }

    <span class="hljs-keyword">func</span> <span class="hljs-title function_">stop</span>() {
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"Stopped."</span>)
    }
}

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Car</span>: <span class="hljs-title class_">Drivable</span> {
    <span class="hljs-keyword">var</span> speed: <span class="hljs-type">Double</span>
}

<span class="hljs-keyword">let</span> car <span class="hljs-operator">=</span> <span class="hljs-type">Car</span>(speed: <span class="hljs-number">120</span>)
car.drive()  <span class="hljs-comment">// 출력: 120.0 km/h로 주행 중</span>
car.stop()   <span class="hljs-comment">// 출력: 정지됨</span>
</code></pre>
<p>여기에는 프로토콜 확장 내에서 drive 메서드에 대한 기본 구현이 있습니다. 또한 모든 준수하는 타입이 추가 구현없이 사용할 수 있는 새로운 stop 메서드가 도입되었습니다.</p>
<p>프로토콜 조합</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>스위프트를 사용하면 여러 프로토콜을 조합하여 타입이 조합된 프로토콜을 준수할 수 있습니다.</p>
<p>프로토콜 조합 예시</p>
<pre><code class="hljs language-js">protocol <span class="hljs-title class_">Drivable</span> {
    <span class="hljs-keyword">var</span> <span class="hljs-attr">speed</span>: <span class="hljs-title class_">Double</span> { get }
    func <span class="hljs-title function_">drive</span>()
}

protocol <span class="hljs-title class_">Flyable</span> {
    <span class="hljs-keyword">var</span> <span class="hljs-attr">altitude</span>: <span class="hljs-title class_">Double</span> { get }
    func <span class="hljs-title function_">fly</span>()
}

struct <span class="hljs-title class_">FlyingCar</span>: <span class="hljs-title class_">Drivable</span>, <span class="hljs-title class_">Flyable</span> {
    <span class="hljs-keyword">var</span> <span class="hljs-attr">speed</span>: <span class="hljs-title class_">Double</span>
    <span class="hljs-keyword">var</span> <span class="hljs-attr">altitude</span>: <span class="hljs-title class_">Double</span>

    func <span class="hljs-title function_">drive</span>(<span class="hljs-params"></span>) {
        <span class="hljs-title function_">print</span>(<span class="hljs-string">"Driving at \(speed) km/h"</span>)
    }

    func <span class="hljs-title function_">fly</span>(<span class="hljs-params"></span>) {
        <span class="hljs-title function_">print</span>(<span class="hljs-string">"Flying at \(altitude) meters"</span>)
    }
}

<span class="hljs-keyword">let</span> flyingCar = <span class="hljs-title class_">FlyingCar</span>(<span class="hljs-attr">speed</span>: <span class="hljs-number">120</span>, <span class="hljs-attr">altitude</span>: <span class="hljs-number">1000</span>)
flyingCar.<span class="hljs-title function_">drive</span>()  <span class="hljs-comment">// 출력: Driving at 120.0 km/h</span>
flyingCar.<span class="hljs-title function_">fly</span>()    <span class="hljs-comment">// 출력: Flying at 1000.0 meters</span>
</code></pre>
<p>이 예시에서 FlyingCar 구조체는 Drivable 및 Flyable 프로토콜을 모두 준수하며, 프로토콜 조합이 복잡한 기능을 가능하게 함을 보여줍니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>프로토콜 중심의 디자인 패턴</p>
<ol>
<li>전략 패턴</li>
</ol>
<p>전략 패턴은 알고리즘들의 집합을 정의하고 각각을 캡슐화하여 교환 가능하게 만듭니다. Swift에서 이 패턴을 구현하는 데는 프로토콜이 이상적입니다.</p>
<p>전략 패턴 예시</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js">프로토콜 <span class="hljs-title class_">PaymentStrategy</span> {
    func <span class="hljs-title function_">pay</span>(<span class="hljs-attr">amount</span>: <span class="hljs-title class_">Double</span>)
}

구조체 <span class="hljs-title class_">CreditCardPayment</span>: <span class="hljs-title class_">PaymentStrategy</span> {
    func <span class="hljs-title function_">pay</span>(<span class="hljs-params">amount: Double</span>) {
        <span class="hljs-title function_">print</span>(<span class="hljs-string">"\(amount) 금액으로 신용카드를 사용해 결제했습니다"</span>)
    }
}

구조체 <span class="hljs-title class_">PayPalPayment</span>: <span class="hljs-title class_">PaymentStrategy</span> {
    func <span class="hljs-title function_">pay</span>(<span class="hljs-params">amount: Double</span>) {
        <span class="hljs-title function_">print</span>(<span class="hljs-string">"\(amount) 금액으로 PayPal을 사용해 결제했습니다"</span>)
    }
}

구조체 <span class="hljs-title class_">ShoppingCart</span> {
    <span class="hljs-keyword">var</span> <span class="hljs-attr">paymentStrategy</span>: <span class="hljs-title class_">PaymentStrategy</span>

    func <span class="hljs-title function_">checkout</span>(<span class="hljs-params">amount: Double</span>) {
        paymentStrategy.<span class="hljs-title function_">pay</span>(<span class="hljs-attr">amount</span>: amount)
    }
}

<span class="hljs-keyword">let</span> creditCardPayment = <span class="hljs-title class_">CreditCardPayment</span>()
<span class="hljs-keyword">let</span> payPalPayment = <span class="hljs-title class_">PayPalPayment</span>()

<span class="hljs-keyword">var</span> cart = <span class="hljs-title class_">ShoppingCart</span>(<span class="hljs-attr">paymentStrategy</span>: creditCardPayment)
cart.<span class="hljs-title function_">checkout</span>(<span class="hljs-attr">amount</span>: <span class="hljs-number">100</span>)  <span class="hljs-comment">// 결과: 100.0 금액으로 신용카드를 사용해 결제했습니다</span>
cart.<span class="hljs-property">paymentStrategy</span> = payPalPayment
cart.<span class="hljs-title function_">checkout</span>(<span class="hljs-attr">amount</span>: <span class="hljs-number">200</span>)  <span class="hljs-comment">// 결과: 200.0 금액으로 PayPal을 사용해 결제했습니다</span>
</code></pre>
<p>여기서 PaymentStrategy 프로토콜은 결제를 위한 메서드를 정의합니다. 다양한 결제 전략(CreditCardPayment과 PayPalPayment)이 이 프로토콜을 준수합니다. ShoppingCart은 전략을 사용하여 결제를 수행하며, 결제 방법을 동적으로 전환할 수 있습니다.</p>
<ol start="2">
<li>의존성 주입</li>
</ol>
<p>의존성 주입(Dependency Injection, DI)은 IoC(제어의 역전)를 구현하는 데 사용되는 디자인 패턴으로, 클래스가 내부적으로 생성하는 대신 외부 소스에서 의존성을 받을 수 있도록 합니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>의존성 주입을 사용한 예제</p>
<pre><code class="hljs language-js">protocol <span class="hljs-title class_">DataService</span> {
    func <span class="hljs-title function_">fetchData</span>() -> <span class="hljs-title class_">String</span>
}
</code></pre>
<pre><code class="hljs language-js">struct <span class="hljs-title class_">APIService</span>: <span class="hljs-title class_">DataService</span> {
    func <span class="hljs-title function_">fetchData</span>() -> <span class="hljs-title class_">String</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-string">"API에서 데이터를 가져왔습니다"</span>
    }
}
struct <span class="hljs-title class_">MockService</span>: <span class="hljs-title class_">DataService</span> {
    func <span class="hljs-title function_">fetchData</span>() -> <span class="hljs-title class_">String</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-string">"모의 데이터입니다"</span>
    }
}
struct <span class="hljs-title class_">DataManager</span> {
    <span class="hljs-keyword">var</span> <span class="hljs-attr">service</span>: <span class="hljs-title class_">DataService</span>
    func <span class="hljs-title function_">getData</span>() -> <span class="hljs-title class_">String</span> {
        <span class="hljs-keyword">return</span> service.<span class="hljs-title function_">fetchData</span>()
    }
}
<span class="hljs-keyword">let</span> apiService = <span class="hljs-title class_">APIService</span>()
<span class="hljs-keyword">let</span> mockService = <span class="hljs-title class_">MockService</span>()
<span class="hljs-keyword">let</span> dataManager = <span class="hljs-title class_">DataManager</span>(<span class="hljs-attr">service</span>: apiService)
<span class="hljs-title function_">print</span>(dataManager.<span class="hljs-title function_">getData</span>())  <span class="hljs-comment">// 출력: API에서 데이터를 가져왔습니다</span>
<span class="hljs-keyword">let</span> testManager = <span class="hljs-title class_">DataManager</span>(<span class="hljs-attr">service</span>: mockService)
<span class="hljs-title function_">print</span>(testManager.<span class="hljs-title function_">getData</span>())  <span class="hljs-comment">// 출력: 모의 데이터입니다</span>
</code></pre>
<p>이 예제에서는 DataService 프로토콜이 데이터를 가져오는 메서드를 정의합니다. APIService와 MockService 구조체는 이 프로토콜을 준수하여 다른 구현을 제공합니다. DataManager는 데이터를 가져오기 위해 DataService에 의존하며, 실제 서비스와 테스트를 위한 모의 서비스를 쉽게 변경할 수 있습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>프로토콜 지향 프로그래밍의 Best Practices</p>
<ul>
<li>상속 대신 구성 사용: 클래스 상속에 의존하는 대신 프로토콜을 사용하여 함께 조합할 수 있는 재사용 가능한 동작을 정의하세요.</li>
<li>작고 집중된 프로토콜 정의: 프로토콜을 단일 책임 원칙(SRP)을 준수하며 집중시켜 작고 집중된 상태로 유지하세요. 이렇게 하면 이해하고 구현하기 쉬워집니다.</li>
<li>프로토콜 익스텐션 올바르게 활용: 프로토콜 익스텐션에서 일반적인 동작에 대한 기본 구현을 제공하지만 오버라이드할 필요가 있는 로직을 너무 많이 포함하지 않도록 주의하세요.</li>
<li>프로토콜 조합 활용: 여러 프로토콜을 결합하여 유연하고 모듈식 설계를 만드세요.</li>
<li>프로토콜 및 익스텐션 문서화: 프로토콜과 그 익스텐션의 의도된 사용 및 요구 사항을 명확히 문서화하여 올바르게 사용되도록 하세요.</li>
</ul>
<p>결론</p>
<p>Swift에서의 프로토콜 지향 프로그래밍은 유연하고 재사용 가능하며 테스트 가능한 코드를 작성하는 강력한 방법을 제공합니다. 프로토콜 및 그 조합에 집중함으로써 관심사 분리를 촉진하고 유지보수성을 향상시키는 견고한 아키텍처를 만들 수 있습니다. Strategy 및 Dependency Injection과 같은 디자인 패턴을 구현하거나 프로토콜 익스텐션을 사용하여 기본 동작을 활용하는 경우, 프로토콜 지향 프로그래밍을 도입하면 Swift 개발 기술을 크게 향상시킬 수 있습니다. 프로토콜의 힘을 받아 코드를 더 높은 수준으로 발전시키세요. 즐거운 코딩 되세요!</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"스위프트에서의 프로토콜 지향 프로그래밍 디자인 패턴과 최선의 광고","description":"","date":"2024-05-27 16:27","slug":"2024-05-27-Protocol-OrientedProgramminginSwiftDesignPatternsandBestPractices","content":"\n\u003cimg src=\"/assets/img/2024-05-27-Protocol-OrientedProgramminginSwiftDesignPatternsandBestPractices_0.png\" /\u003e\n\n소개\n\n프로토콜 지향 프로그래밍(POP)은 스위프트 개발에서 핵심 패러다임 중 하나로 자리 잡았으며, 전통적인 객체지향 프로그래밍에 강력한 대안을 제공합니다. 프로토콜에 주목함으로써, 스위프트는 개발자들이 유연하고 재사용 가능하며 테스트 가능한 코드를 작성할 수 있게 해줍니다. 이 글에서는 프로토콜 지향 프로그래밍의 원칙을 탐구하고, 일반적인 디자인 패턴을 살펴보며, 스위프트에서 프로토콜을 통해 견고한 애플리케이션을 구축하는 데 가장 좋은 방법을 논의할 것입니다.\n\n왜 프로토콜 지향 프로그래밍을 해야 할까요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nPOP은 작업이나 기능에 대한 청사진을 정의하는 데 프로토콜 사용을 장려합니다. 이 접근 방식은 여러 가지 이점을 제공합니다:\n\n- 유연성: 프로토콜을 사용하면 타입이 여러 프로토콜을 준수하도록 하여 보다 유연한 아키텍처를 구축할 수 있습니다.\n- 재사용성: 공통 기능은 프로토콜에 정의하고 다양한 타입 간에 재사용할 수 있습니다.\n- 테스트 용이성: 프로토콜은 의존성 주입을 용이하게 하여 단위 테스트에서 의존성을 가짜로 대체하기 쉽습니다.\n- 결합도 낮추기: 프로토콜은 인터페이스를 정의함으로써 코드를 결합도 낮추며 구체적인 구현 대신 인터페이스를 정의합니다. 역할 분리를 촉진합니다.\n\n프로토콜을 활용하기\n기본 프로토콜 정의\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n프로토콜 Drivable {\n    var speed: Double { get }\n    func drive()\n}\n\n구조체 Car: Drivable {\n    var speed: Double\n\n    func drive() {\n        print(\"속도: \\(speed) km/h로 주행 중\")\n    }\n}\n\nlet car = Car(speed: 120)\ncar.drive()  // 출력: 속도: 120.0 km/h로 주행 중\n```\n\n이 예제에서는 speed 속성과 drive 메서드가 있는 Drivable 프로토콜을 정의합니다. Car 구조체는 Drivable 프로토콜을 준수하며 필요한 속성과 메서드를 구현합니다.\n\n프로토콜 익스텐션\n\n프로토콜 익스텐션을 사용하여 프로토콜 메서드에 대한 기본 구현을 제공할 수 있으며 주어진 유형의 기능을 확장할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n프로토콜 확장 예제\n\n```swift\nprotocol Drivable {\n    var speed: Double { get }\n    func drive()\n}\n\nextension Drivable {\n    func drive() {\n        print(\"Driving at \\(speed) km/h\")\n    }\n\n    func stop() {\n        print(\"Stopped.\")\n    }\n}\n\nstruct Car: Drivable {\n    var speed: Double\n}\n\nlet car = Car(speed: 120)\ncar.drive()  // 출력: 120.0 km/h로 주행 중\ncar.stop()   // 출력: 정지됨\n```\n\n여기에는 프로토콜 확장 내에서 drive 메서드에 대한 기본 구현이 있습니다. 또한 모든 준수하는 타입이 추가 구현없이 사용할 수 있는 새로운 stop 메서드가 도입되었습니다.\n\n프로토콜 조합\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n스위프트를 사용하면 여러 프로토콜을 조합하여 타입이 조합된 프로토콜을 준수할 수 있습니다.\n\n프로토콜 조합 예시\n\n```js\nprotocol Drivable {\n    var speed: Double { get }\n    func drive()\n}\n\nprotocol Flyable {\n    var altitude: Double { get }\n    func fly()\n}\n\nstruct FlyingCar: Drivable, Flyable {\n    var speed: Double\n    var altitude: Double\n\n    func drive() {\n        print(\"Driving at \\(speed) km/h\")\n    }\n\n    func fly() {\n        print(\"Flying at \\(altitude) meters\")\n    }\n}\n\nlet flyingCar = FlyingCar(speed: 120, altitude: 1000)\nflyingCar.drive()  // 출력: Driving at 120.0 km/h\nflyingCar.fly()    // 출력: Flying at 1000.0 meters\n```\n\n이 예시에서 FlyingCar 구조체는 Drivable 및 Flyable 프로토콜을 모두 준수하며, 프로토콜 조합이 복잡한 기능을 가능하게 함을 보여줍니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n프로토콜 중심의 디자인 패턴\n\n1. 전략 패턴\n\n전략 패턴은 알고리즘들의 집합을 정의하고 각각을 캡슐화하여 교환 가능하게 만듭니다. Swift에서 이 패턴을 구현하는 데는 프로토콜이 이상적입니다.\n\n전략 패턴 예시\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n프로토콜 PaymentStrategy {\n    func pay(amount: Double)\n}\n\n구조체 CreditCardPayment: PaymentStrategy {\n    func pay(amount: Double) {\n        print(\"\\(amount) 금액으로 신용카드를 사용해 결제했습니다\")\n    }\n}\n\n구조체 PayPalPayment: PaymentStrategy {\n    func pay(amount: Double) {\n        print(\"\\(amount) 금액으로 PayPal을 사용해 결제했습니다\")\n    }\n}\n\n구조체 ShoppingCart {\n    var paymentStrategy: PaymentStrategy\n\n    func checkout(amount: Double) {\n        paymentStrategy.pay(amount: amount)\n    }\n}\n\nlet creditCardPayment = CreditCardPayment()\nlet payPalPayment = PayPalPayment()\n\nvar cart = ShoppingCart(paymentStrategy: creditCardPayment)\ncart.checkout(amount: 100)  // 결과: 100.0 금액으로 신용카드를 사용해 결제했습니다\ncart.paymentStrategy = payPalPayment\ncart.checkout(amount: 200)  // 결과: 200.0 금액으로 PayPal을 사용해 결제했습니다\n```\n\n여기서 PaymentStrategy 프로토콜은 결제를 위한 메서드를 정의합니다. 다양한 결제 전략(CreditCardPayment과 PayPalPayment)이 이 프로토콜을 준수합니다. ShoppingCart은 전략을 사용하여 결제를 수행하며, 결제 방법을 동적으로 전환할 수 있습니다.\n\n2. 의존성 주입\n\n의존성 주입(Dependency Injection, DI)은 IoC(제어의 역전)를 구현하는 데 사용되는 디자인 패턴으로, 클래스가 내부적으로 생성하는 대신 외부 소스에서 의존성을 받을 수 있도록 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n의존성 주입을 사용한 예제\n\n```js\nprotocol DataService {\n    func fetchData() -\u003e String\n}\n```\n\n```js\nstruct APIService: DataService {\n    func fetchData() -\u003e String {\n        return \"API에서 데이터를 가져왔습니다\"\n    }\n}\nstruct MockService: DataService {\n    func fetchData() -\u003e String {\n        return \"모의 데이터입니다\"\n    }\n}\nstruct DataManager {\n    var service: DataService\n    func getData() -\u003e String {\n        return service.fetchData()\n    }\n}\nlet apiService = APIService()\nlet mockService = MockService()\nlet dataManager = DataManager(service: apiService)\nprint(dataManager.getData())  // 출력: API에서 데이터를 가져왔습니다\nlet testManager = DataManager(service: mockService)\nprint(testManager.getData())  // 출력: 모의 데이터입니다\n```\n\n이 예제에서는 DataService 프로토콜이 데이터를 가져오는 메서드를 정의합니다. APIService와 MockService 구조체는 이 프로토콜을 준수하여 다른 구현을 제공합니다. DataManager는 데이터를 가져오기 위해 DataService에 의존하며, 실제 서비스와 테스트를 위한 모의 서비스를 쉽게 변경할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n프로토콜 지향 프로그래밍의 Best Practices\n\n- 상속 대신 구성 사용: 클래스 상속에 의존하는 대신 프로토콜을 사용하여 함께 조합할 수 있는 재사용 가능한 동작을 정의하세요.\n- 작고 집중된 프로토콜 정의: 프로토콜을 단일 책임 원칙(SRP)을 준수하며 집중시켜 작고 집중된 상태로 유지하세요. 이렇게 하면 이해하고 구현하기 쉬워집니다.\n- 프로토콜 익스텐션 올바르게 활용: 프로토콜 익스텐션에서 일반적인 동작에 대한 기본 구현을 제공하지만 오버라이드할 필요가 있는 로직을 너무 많이 포함하지 않도록 주의하세요.\n- 프로토콜 조합 활용: 여러 프로토콜을 결합하여 유연하고 모듈식 설계를 만드세요.\n- 프로토콜 및 익스텐션 문서화: 프로토콜과 그 익스텐션의 의도된 사용 및 요구 사항을 명확히 문서화하여 올바르게 사용되도록 하세요.\n\n결론\n\nSwift에서의 프로토콜 지향 프로그래밍은 유연하고 재사용 가능하며 테스트 가능한 코드를 작성하는 강력한 방법을 제공합니다. 프로토콜 및 그 조합에 집중함으로써 관심사 분리를 촉진하고 유지보수성을 향상시키는 견고한 아키텍처를 만들 수 있습니다. Strategy 및 Dependency Injection과 같은 디자인 패턴을 구현하거나 프로토콜 익스텐션을 사용하여 기본 동작을 활용하는 경우, 프로토콜 지향 프로그래밍을 도입하면 Swift 개발 기술을 크게 향상시킬 수 있습니다. 프로토콜의 힘을 받아 코드를 더 높은 수준으로 발전시키세요. 즐거운 코딩 되세요!\n","ogImage":{"url":"/assets/img/2024-05-27-Protocol-OrientedProgramminginSwiftDesignPatternsandBestPractices_0.png"},"coverImage":"/assets/img/2024-05-27-Protocol-OrientedProgramminginSwiftDesignPatternsandBestPractices_0.png","tag":["Tech"],"readingTime":8},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cimg src=\"/assets/img/2024-05-27-Protocol-OrientedProgramminginSwiftDesignPatternsandBestPractices_0.png\"\u003e\n\u003cp\u003e소개\u003c/p\u003e\n\u003cp\u003e프로토콜 지향 프로그래밍(POP)은 스위프트 개발에서 핵심 패러다임 중 하나로 자리 잡았으며, 전통적인 객체지향 프로그래밍에 강력한 대안을 제공합니다. 프로토콜에 주목함으로써, 스위프트는 개발자들이 유연하고 재사용 가능하며 테스트 가능한 코드를 작성할 수 있게 해줍니다. 이 글에서는 프로토콜 지향 프로그래밍의 원칙을 탐구하고, 일반적인 디자인 패턴을 살펴보며, 스위프트에서 프로토콜을 통해 견고한 애플리케이션을 구축하는 데 가장 좋은 방법을 논의할 것입니다.\u003c/p\u003e\n\u003cp\u003e왜 프로토콜 지향 프로그래밍을 해야 할까요?\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003ePOP은 작업이나 기능에 대한 청사진을 정의하는 데 프로토콜 사용을 장려합니다. 이 접근 방식은 여러 가지 이점을 제공합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e유연성: 프로토콜을 사용하면 타입이 여러 프로토콜을 준수하도록 하여 보다 유연한 아키텍처를 구축할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e재사용성: 공통 기능은 프로토콜에 정의하고 다양한 타입 간에 재사용할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e테스트 용이성: 프로토콜은 의존성 주입을 용이하게 하여 단위 테스트에서 의존성을 가짜로 대체하기 쉽습니다.\u003c/li\u003e\n\u003cli\u003e결합도 낮추기: 프로토콜은 인터페이스를 정의함으로써 코드를 결합도 낮추며 구체적인 구현 대신 인터페이스를 정의합니다. 역할 분리를 촉진합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e프로토콜을 활용하기\n기본 프로토콜 정의\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e프로토콜 \u003cspan class=\"hljs-title class_\"\u003eDrivable\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003espeed\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eDouble\u003c/span\u003e { get }\n    func \u003cspan class=\"hljs-title function_\"\u003edrive\u003c/span\u003e()\n}\n\n구조체 \u003cspan class=\"hljs-title class_\"\u003eCar\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eDrivable\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003espeed\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eDouble\u003c/span\u003e\n\n    func \u003cspan class=\"hljs-title function_\"\u003edrive\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n        \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"속도: \\(speed) km/h로 주행 중\"\u003c/span\u003e)\n    }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e car = \u003cspan class=\"hljs-title class_\"\u003eCar\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003espeed\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e120\u003c/span\u003e)\ncar.\u003cspan class=\"hljs-title function_\"\u003edrive\u003c/span\u003e()  \u003cspan class=\"hljs-comment\"\u003e// 출력: 속도: 120.0 km/h로 주행 중\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 예제에서는 speed 속성과 drive 메서드가 있는 Drivable 프로토콜을 정의합니다. Car 구조체는 Drivable 프로토콜을 준수하며 필요한 속성과 메서드를 구현합니다.\u003c/p\u003e\n\u003cp\u003e프로토콜 익스텐션\u003c/p\u003e\n\u003cp\u003e프로토콜 익스텐션을 사용하여 프로토콜 메서드에 대한 기본 구현을 제공할 수 있으며 주어진 유형의 기능을 확장할 수 있습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e프로토콜 확장 예제\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-swift\"\u003e\u003cspan class=\"hljs-keyword\"\u003eprotocol\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDrivable\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e speed: \u003cspan class=\"hljs-type\"\u003eDouble\u003c/span\u003e { \u003cspan class=\"hljs-keyword\"\u003eget\u003c/span\u003e }\n    \u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edrive\u003c/span\u003e()\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eextension\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDrivable\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edrive\u003c/span\u003e() {\n        \u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Driving at \u003cspan class=\"hljs-subst\"\u003e\\(speed)\u003c/span\u003e km/h\"\u003c/span\u003e)\n    }\n\n    \u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003estop\u003c/span\u003e() {\n        \u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Stopped.\"\u003c/span\u003e)\n    }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003estruct\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eCar\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eDrivable\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e speed: \u003cspan class=\"hljs-type\"\u003eDouble\u003c/span\u003e\n}\n\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e car \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eCar\u003c/span\u003e(speed: \u003cspan class=\"hljs-number\"\u003e120\u003c/span\u003e)\ncar.drive()  \u003cspan class=\"hljs-comment\"\u003e// 출력: 120.0 km/h로 주행 중\u003c/span\u003e\ncar.stop()   \u003cspan class=\"hljs-comment\"\u003e// 출력: 정지됨\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기에는 프로토콜 확장 내에서 drive 메서드에 대한 기본 구현이 있습니다. 또한 모든 준수하는 타입이 추가 구현없이 사용할 수 있는 새로운 stop 메서드가 도입되었습니다.\u003c/p\u003e\n\u003cp\u003e프로토콜 조합\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e스위프트를 사용하면 여러 프로토콜을 조합하여 타입이 조합된 프로토콜을 준수할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e프로토콜 조합 예시\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eprotocol \u003cspan class=\"hljs-title class_\"\u003eDrivable\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003espeed\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eDouble\u003c/span\u003e { get }\n    func \u003cspan class=\"hljs-title function_\"\u003edrive\u003c/span\u003e()\n}\n\nprotocol \u003cspan class=\"hljs-title class_\"\u003eFlyable\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ealtitude\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eDouble\u003c/span\u003e { get }\n    func \u003cspan class=\"hljs-title function_\"\u003efly\u003c/span\u003e()\n}\n\nstruct \u003cspan class=\"hljs-title class_\"\u003eFlyingCar\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eDrivable\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eFlyable\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003espeed\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eDouble\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ealtitude\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eDouble\u003c/span\u003e\n\n    func \u003cspan class=\"hljs-title function_\"\u003edrive\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n        \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Driving at \\(speed) km/h\"\u003c/span\u003e)\n    }\n\n    func \u003cspan class=\"hljs-title function_\"\u003efly\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n        \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Flying at \\(altitude) meters\"\u003c/span\u003e)\n    }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e flyingCar = \u003cspan class=\"hljs-title class_\"\u003eFlyingCar\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003espeed\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e120\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003ealtitude\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e)\nflyingCar.\u003cspan class=\"hljs-title function_\"\u003edrive\u003c/span\u003e()  \u003cspan class=\"hljs-comment\"\u003e// 출력: Driving at 120.0 km/h\u003c/span\u003e\nflyingCar.\u003cspan class=\"hljs-title function_\"\u003efly\u003c/span\u003e()    \u003cspan class=\"hljs-comment\"\u003e// 출력: Flying at 1000.0 meters\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 예시에서 FlyingCar 구조체는 Drivable 및 Flyable 프로토콜을 모두 준수하며, 프로토콜 조합이 복잡한 기능을 가능하게 함을 보여줍니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e프로토콜 중심의 디자인 패턴\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e전략 패턴\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e전략 패턴은 알고리즘들의 집합을 정의하고 각각을 캡슐화하여 교환 가능하게 만듭니다. Swift에서 이 패턴을 구현하는 데는 프로토콜이 이상적입니다.\u003c/p\u003e\n\u003cp\u003e전략 패턴 예시\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e프로토콜 \u003cspan class=\"hljs-title class_\"\u003ePaymentStrategy\u003c/span\u003e {\n    func \u003cspan class=\"hljs-title function_\"\u003epay\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eamount\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eDouble\u003c/span\u003e)\n}\n\n구조체 \u003cspan class=\"hljs-title class_\"\u003eCreditCardPayment\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003ePaymentStrategy\u003c/span\u003e {\n    func \u003cspan class=\"hljs-title function_\"\u003epay\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eamount: Double\u003c/span\u003e) {\n        \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"\\(amount) 금액으로 신용카드를 사용해 결제했습니다\"\u003c/span\u003e)\n    }\n}\n\n구조체 \u003cspan class=\"hljs-title class_\"\u003ePayPalPayment\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003ePaymentStrategy\u003c/span\u003e {\n    func \u003cspan class=\"hljs-title function_\"\u003epay\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eamount: Double\u003c/span\u003e) {\n        \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"\\(amount) 금액으로 PayPal을 사용해 결제했습니다\"\u003c/span\u003e)\n    }\n}\n\n구조체 \u003cspan class=\"hljs-title class_\"\u003eShoppingCart\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003epaymentStrategy\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003ePaymentStrategy\u003c/span\u003e\n\n    func \u003cspan class=\"hljs-title function_\"\u003echeckout\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eamount: Double\u003c/span\u003e) {\n        paymentStrategy.\u003cspan class=\"hljs-title function_\"\u003epay\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eamount\u003c/span\u003e: amount)\n    }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e creditCardPayment = \u003cspan class=\"hljs-title class_\"\u003eCreditCardPayment\u003c/span\u003e()\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e payPalPayment = \u003cspan class=\"hljs-title class_\"\u003ePayPalPayment\u003c/span\u003e()\n\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e cart = \u003cspan class=\"hljs-title class_\"\u003eShoppingCart\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003epaymentStrategy\u003c/span\u003e: creditCardPayment)\ncart.\u003cspan class=\"hljs-title function_\"\u003echeckout\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eamount\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e)  \u003cspan class=\"hljs-comment\"\u003e// 결과: 100.0 금액으로 신용카드를 사용해 결제했습니다\u003c/span\u003e\ncart.\u003cspan class=\"hljs-property\"\u003epaymentStrategy\u003c/span\u003e = payPalPayment\ncart.\u003cspan class=\"hljs-title function_\"\u003echeckout\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eamount\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e200\u003c/span\u003e)  \u003cspan class=\"hljs-comment\"\u003e// 결과: 200.0 금액으로 PayPal을 사용해 결제했습니다\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 PaymentStrategy 프로토콜은 결제를 위한 메서드를 정의합니다. 다양한 결제 전략(CreditCardPayment과 PayPalPayment)이 이 프로토콜을 준수합니다. ShoppingCart은 전략을 사용하여 결제를 수행하며, 결제 방법을 동적으로 전환할 수 있습니다.\u003c/p\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e의존성 주입\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e의존성 주입(Dependency Injection, DI)은 IoC(제어의 역전)를 구현하는 데 사용되는 디자인 패턴으로, 클래스가 내부적으로 생성하는 대신 외부 소스에서 의존성을 받을 수 있도록 합니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e의존성 주입을 사용한 예제\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eprotocol \u003cspan class=\"hljs-title class_\"\u003eDataService\u003c/span\u003e {\n    func \u003cspan class=\"hljs-title function_\"\u003efetchData\u003c/span\u003e() -\u003e \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003estruct \u003cspan class=\"hljs-title class_\"\u003eAPIService\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eDataService\u003c/span\u003e {\n    func \u003cspan class=\"hljs-title function_\"\u003efetchData\u003c/span\u003e() -\u003e \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"API에서 데이터를 가져왔습니다\"\u003c/span\u003e\n    }\n}\nstruct \u003cspan class=\"hljs-title class_\"\u003eMockService\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eDataService\u003c/span\u003e {\n    func \u003cspan class=\"hljs-title function_\"\u003efetchData\u003c/span\u003e() -\u003e \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"모의 데이터입니다\"\u003c/span\u003e\n    }\n}\nstruct \u003cspan class=\"hljs-title class_\"\u003eDataManager\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eservice\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eDataService\u003c/span\u003e\n    func \u003cspan class=\"hljs-title function_\"\u003egetData\u003c/span\u003e() -\u003e \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e service.\u003cspan class=\"hljs-title function_\"\u003efetchData\u003c/span\u003e()\n    }\n}\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e apiService = \u003cspan class=\"hljs-title class_\"\u003eAPIService\u003c/span\u003e()\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e mockService = \u003cspan class=\"hljs-title class_\"\u003eMockService\u003c/span\u003e()\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e dataManager = \u003cspan class=\"hljs-title class_\"\u003eDataManager\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eservice\u003c/span\u003e: apiService)\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(dataManager.\u003cspan class=\"hljs-title function_\"\u003egetData\u003c/span\u003e())  \u003cspan class=\"hljs-comment\"\u003e// 출력: API에서 데이터를 가져왔습니다\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e testManager = \u003cspan class=\"hljs-title class_\"\u003eDataManager\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eservice\u003c/span\u003e: mockService)\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(testManager.\u003cspan class=\"hljs-title function_\"\u003egetData\u003c/span\u003e())  \u003cspan class=\"hljs-comment\"\u003e// 출력: 모의 데이터입니다\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 예제에서는 DataService 프로토콜이 데이터를 가져오는 메서드를 정의합니다. APIService와 MockService 구조체는 이 프로토콜을 준수하여 다른 구현을 제공합니다. DataManager는 데이터를 가져오기 위해 DataService에 의존하며, 실제 서비스와 테스트를 위한 모의 서비스를 쉽게 변경할 수 있습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e프로토콜 지향 프로그래밍의 Best Practices\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e상속 대신 구성 사용: 클래스 상속에 의존하는 대신 프로토콜을 사용하여 함께 조합할 수 있는 재사용 가능한 동작을 정의하세요.\u003c/li\u003e\n\u003cli\u003e작고 집중된 프로토콜 정의: 프로토콜을 단일 책임 원칙(SRP)을 준수하며 집중시켜 작고 집중된 상태로 유지하세요. 이렇게 하면 이해하고 구현하기 쉬워집니다.\u003c/li\u003e\n\u003cli\u003e프로토콜 익스텐션 올바르게 활용: 프로토콜 익스텐션에서 일반적인 동작에 대한 기본 구현을 제공하지만 오버라이드할 필요가 있는 로직을 너무 많이 포함하지 않도록 주의하세요.\u003c/li\u003e\n\u003cli\u003e프로토콜 조합 활용: 여러 프로토콜을 결합하여 유연하고 모듈식 설계를 만드세요.\u003c/li\u003e\n\u003cli\u003e프로토콜 및 익스텐션 문서화: 프로토콜과 그 익스텐션의 의도된 사용 및 요구 사항을 명확히 문서화하여 올바르게 사용되도록 하세요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e결론\u003c/p\u003e\n\u003cp\u003eSwift에서의 프로토콜 지향 프로그래밍은 유연하고 재사용 가능하며 테스트 가능한 코드를 작성하는 강력한 방법을 제공합니다. 프로토콜 및 그 조합에 집중함으로써 관심사 분리를 촉진하고 유지보수성을 향상시키는 견고한 아키텍처를 만들 수 있습니다. Strategy 및 Dependency Injection과 같은 디자인 패턴을 구현하거나 프로토콜 익스텐션을 사용하여 기본 동작을 활용하는 경우, 프로토콜 지향 프로그래밍을 도입하면 Swift 개발 기술을 크게 향상시킬 수 있습니다. 프로토콜의 힘을 받아 코드를 더 높은 수준으로 발전시키세요. 즐거운 코딩 되세요!\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-27-Protocol-OrientedProgramminginSwiftDesignPatternsandBestPractices"},"buildId":"wfHLuDA3kTGBYfaM5IGXk","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>