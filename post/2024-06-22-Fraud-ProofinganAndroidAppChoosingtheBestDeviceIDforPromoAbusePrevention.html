<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>안드로이드 앱 부정 방지 프로모션 남용을 막기 위한 최적의 디바이스 ID 선택 방법 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-06-22-Fraud-ProofinganAndroidAppChoosingtheBestDeviceIDforPromoAbusePrevention" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="안드로이드 앱 부정 방지 프로모션 남용을 막기 위한 최적의 디바이스 ID 선택 방법 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="안드로이드 앱 부정 방지 프로모션 남용을 막기 위한 최적의 디바이스 ID 선택 방법 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-22-Fraud-ProofinganAndroidAppChoosingtheBestDeviceIDforPromoAbusePrevention_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-06-22-Fraud-ProofinganAndroidAppChoosingtheBestDeviceIDforPromoAbusePrevention" data-gatsby-head="true"/><meta name="twitter:title" content="안드로이드 앱 부정 방지 프로모션 남용을 막기 위한 최적의 디바이스 ID 선택 방법 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-22-Fraud-ProofinganAndroidAppChoosingtheBestDeviceIDforPromoAbusePrevention_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-22 23:17" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-70e5ce89f3d962ac.js" defer=""></script><script src="/_next/static/T_Nz0g9U1yttYMSEma95P/_buildManifest.js" defer=""></script><script src="/_next/static/T_Nz0g9U1yttYMSEma95P/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">안드로이드 앱 부정 방지 프로모션 남용을 막기 위한 최적의 디바이스 ID 선택 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="안드로이드 앱 부정 방지 프로모션 남용을 막기 위한 최적의 디바이스 ID 선택 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 22, 2024</span><span class="posts_reading_time__f7YPP">15<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-22-Fraud-ProofinganAndroidAppChoosingtheBestDeviceIDforPromoAbusePrevention&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>⚡주요 요점:</p>
<ul>
<li>프로모션 남용은 비즈니스의 가입 보너스, 추천, 쿠폰 또는 프로모션을 악용하는 사기 유형입니다.</li>
<li>가능한 경우에는 MediaDRM을 디바이스 지문보다 선호해야 합니다.</li>
<li>우리의 연구 결과, 블록리스트에 가장 적합한 최고의 디바이스 ID는 MediaDRM+디바이스 모델의 결합입니다.</li>
<li>모바일 앱 백엔드 API를 보호하는 AppiCrypt(앱 보호), RASP(앱 쉴딩) 및 KYC 솔루션(고객 신원 확인)과 같은 여러 보안 계층을 항상 포함해야 합니다.</li>
<li>특정 시나리오에 따라 다른 접근 방식이 필요할 수 있다는 것을 염두에 두세요. <a href="mailto:info@talsec.app">info@talsec.app</a>으로 메시지를 남기면 Talsec 보안 전문가가 도와드릴 것입니다.</li>
</ul>
<h1>사용자 파악 방법?</h1>
<p>최근에 모바일 디바이스 식별에서 어려움에 부딪혔습니다 - 사용자 개인정보를 침해하지 않으면서 사기적인 디바이스를 식별하고 블록리스트에 올리는 방법은 무엇일까요. 이 문제는 결제 회피 또는 다양한 보너스를 악용하는 사용자들과 빈번히 대면하는 모바일 애플리케이션 소유자에게 특히 중요합니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>초기 가입 시 사용자들을 유혹하는 매력적인 보너스로 사용자를 유치하는 것은 흔한 일이지만, 이 전략은 내재적인 위험을 안고 있으며 남용될 수 있다는 점을 인지하는 것이 중요합니다. 이 악의적인 사용자들은 앱을 여러 번 다시 설치하여 계속해서 가입 보너스를 얻으려는 행위를 하는데, 이를 "멀티 인스턴싱"이라고 부릅니다.</p>
<p>안드로이드는 각 앱 인스턴스마다 일부 디바이스 ID를 변경하므로, 동일한 악의적 사용자의 디바이스를 차단하기가 어려워집니다. 이는 효과적인 해결책을 찾기 위한 우리의 노력이 복잡함을 강조합니다.</p>
<p><img src="/assets/img/2024-06-22-Fraud-ProofinganAndroidAppChoosingtheBestDeviceIDforPromoAbusePrevention_0.png" alt="이미지"></p>
<h1>좋은 ID는 고유하며 충돌 방지, 지속적이고 개인정보 친화적이어야 합니다. 그리고 위조할 수 없어야 합니다.</h1>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>과거에는 특별한 권한을 요청하지 않고 MAC 주소나 IMEI를 통해 기기를 식별할 수 있었어요. 오늘날 안드로이드 개인 정보 보호를 위한 다양한 변경 사항 이후, Android 기기에서 AndroidID, MediaDRM, GSF ID, FID 및 InstanceID와 같은 여러 반영구적 ID가 사용 가능해졌어요. 물론, 사용자에게 상승된 액세스 및 잠재적 보안 문제를 가진 권한을 요청하는 것은 현실적이지 않아요.</p>
<p>각 ID에는 장단점이 있어 다양한 시나리오에서 유용하게 사용될 수 있어요. 아래 예시 테이블을 참고하세요. Android 문서에서 ID에 대한 추가 정보를 찾을 수 있어요.</p>
<p>또 다른 방법으로는 다양한 디바이스 지문 라이브러리(예: fingerprintjs-android)를 사용하여 여러 기기 ID, 기기 상태, OS 지문 또는 설치된 앱을 기반으로 ID를 생성할 수 있어요.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이 ID들을 더 자세히 살펴보겠습니다.</p>
<h1>AndroidID, GSF ID, FID, InstanceID, Google 광고 ID</h1>
<p>이러한 식별 방법은 다른 맥락에서는 잘 작동할 수 있지만, 우리의 시나리오에서는 부정한 다중 인스턴싱에 견딜 수 있는 견고함이 부족합니다. 이러한 ID들은 비교적 쉽게 변경할 수 있으므로 각각에 대한 단점에 대해 간단한 설명만 제공하겠습니다.</p>
<ul>
<li>AndroidID는 다시 패키징되거나 기기의 다른 사용자로 설치되는 경우 변경됩니다.</li>
<li>GSF ID (Google Play 서비스 프레임워크 ID)는 Google 기기에만 제한되며 XPrivacyLua에 의해 상대적으로 쉽게 위조될 수 있습니다. 또한 다른 사용자에 대해 변경됩니다.</li>
<li>FID (Firebase 설치 ID)는 재설치를 견뎌내지 못합니다.</li>
<li>InstanceID (GUID, UUID.randomUUID().toString())는 사용자 정의 생성 및 내부 저장 ID입니다만, 재설치를 견딜 수 없습니다.</li>
<li>Google 광고 ID는 전혀 적합하지 않습니다.</li>
</ul>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>요약하면, 우리의 시나리오에서 나쁜 행위자를 식별하는 데 충분히 견고한 ID는 없습니다.</p>
<h1>fingerprintjs-android 라이브러리 기반의 지문 ID</h1>
<p>참고: 전체 분석에서 우리는 상태 없는 오프라인 지문 ID를 위해 종합적인 신호 목록을 사용하는 fingerprintjs-android 라이브러리를 사용했습니다. 다른 지문 ID 라이브러리의 결과는 다를 수 있습니다. 이는 그들의 데이터 인사이트, 지리 위치, IP 위치, TEE 및 다른 요소에 기반한 더 많은 신호와 휴리스틱을 포함할 수 있습니다. Talsec는 fingerprintjs-android V3 및 StabilityLevel.OPTIMAL을 수집합니다. 안정성 수준 (STABLE — OPTIMAL — UNIQUE) 사이의 차이점은 여기에서 찾을 수 있습니다.</p>
<p>위의 표를 다시 한 번 살펴보세요. 첫눈에는 하드웨어 지문 (위의 표 참조)가 최선의 선택일 수 있습니다. 이것은 인스턴트 앱 이벤트를 제외하고는 무엇이든 견딜 수 있습니다. 그러나 이 ID에는 한 가지 심각한 단점이 있습니다 — 충돌입니다. 이 충돌은 ID가 계산되는 방식에 의해 발생합니다. ID는 디바이스의 하드웨어에만 기반하기 때문에 발생합니다. 예를 들어, 조립 라인에서 직접 나오는 모든 삼성 갤럭시 Z 플립이 동일한 ID를 갖게 될 것입니다. 이 유형의 지문은 STABLE 지문이라고 불립니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p><img src="/assets/img/2024-06-22-Fraud-ProofinganAndroidAppChoosingtheBestDeviceIDforPromoAbusePrevention_2.png" alt="2024-06-22-Fraud-ProofinganAndroidAppChoosingtheBestDeviceIDforPromoAbusePrevention_2.png"></p>
<p>한편, 고유한 지문(fingerprint)이 있습니다. 이것은 기기의 ID를 계산하기 위해 상당량의 신호를 사용합니다. 이 방식으로 생성된 ID는 하나의 사용자에게만 매칭될 가능성이 높습니다(충돌이 적음), 그러나 신호가 많기 때문에 ID가 자주 변경될 수 있습니다(예: 설정 변경시). 따라서 하나의 사용자에게 많은 ID가 생길 수 있어 우리의 사용 사례에는 유용하지 않습니다. 예: 설치된 앱이 변경되거나 데이터 로밍이 활성화/비활성화될 때 ID가 변경될 수 있습니다.</p>
<p>세 번째 유형의 지문은 STABLE과 UNIQUE 지문 사이의 절충안인 OPTIMAL 지문입니다. 이 지문은 STABLE 지문보다는 덜 안정적이지만 더 고유하며 Talsec SDK에 의해 수집됩니다. 그러나 이 유형의 지문조차 이 기사에서 나중에 보여줄 것처럼 최적적이지 않습니다. 예: 사용자가 12시 및 24시간 형식으로 전환하거나 개발자 설정 또는 ADB가 활성화/비활성화될 때 ID가 변경될 수 있습니다.</p>
<p>지문 예시: <code>f37fc958dc6d566a8f4bf1e0fd25b510</code></p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>MediaDRM</h1>
<p>MediaDrm은 프리미엄 콘텐츠 재생을 위해 암호화 키를 안전하게 제공하는 안드로이드 API입니다. Google의 Widevine 및 Microsoft의 PlayReady와 같은 DRM 공급자를 사용합니다. 초기 DRM 사용 중에는 장치 프로비저닝을 통해 장치의 DRM 서비스에 저장된 고유한 인증서를 획득합니다.</p>
<p>이 API에서 제공되는 MediaDRM은 장치 상의 모든 사용자에게 동일하지만, 저희 상황에서는 위조하기 어렵고 많은 공격에도 견딜 수 있습니다. 이 ID를 얻으려면 권한이 필요하지 않습니다.</p>
<p>하지만 여전히 제한 사항이 있습니다. MediaDrm을 지원하지 않는 장치에서는 사용할 수 없을 수 있습니다. 또한 동일한 제조업체의 장치 간에는 충돌이 많이 발생할 수 있습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>MediaDRM 예시: <code>e3af1aa4dacb6b6637846488b511e7643c6ac20b65c95baad164b122ecb036b6</code></p>
<h1>MediaDRM vs 지문 ID?</h1>
<p>우리는 다섯 대의 기기와 에뮬레이터를 여러 개의 다중 인스턴싱 시나리오에서 테스트하고 ID가 변경되었는지 여부를 확인했습니다. 가장 흥미로운 부분은 MediaDRM과 Fingerprint (V3 &#x26; V5 Optimal)입니다. 그래서 우리는 특히 이 부분에 주의를 기울였습니다.</p>
<p>다중 인스턴싱 시나리오:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>앱의 첫 설치</li>
<li>앱 재설치</li>
<li>작업 프로필에 설치</li>
<li>Island 앱을 사용하여 앱의 복제</li>
<li>Parallel Space를 사용하여 앱의 복제</li>
<li>병렬 애플리케이션을 사용하여 앱의 복제</li>
<li>두 번째 공간(Xiaomi)을 사용하여 앱의 복제</li>
<li>손님 프로필에 설치</li>
<li>공장 초기화</li>
<li>안드로이드 에뮬레이터 대 실제 기기</li>
</ul>
<p>이 지루한 작업은 훌륭한 지문 OSS 데모 도구 덕분에 더 쉽게 진행되었습니다.</p>
<img src="/assets/img/2024-06-22-Fraud-ProofinganAndroidAppChoosingtheBestDeviceIDforPromoAbusePrevention_3.png">
<p>가장 중요한 관찰 결과를 여기에 나열하였습니다. 모든 테스트를 항상 수행할 수는 없었기 때문에 사소한 부분들은 모두 다시 시도했습니다 - 이는 공격자들이 시도할 것이기 때문입니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>유지한 것 (= 좋은):</p>
<ul>
<li>미디어 DRM은 처음 설치 시 OnePlus 8 Pro의 Island App에서 동일하게 유지되었습니다.</li>
<li>미디어 DRM은 Redmi Note 10 Pro의 두 번째 공간에서 동일하게 유지되었습니다.</li>
<li>미디어 DRM은 OnePlus 8 Pro에서 공장 초기화 후에도 동일하게 유지되었습니다.</li>
<li>미디어 DRM은 OnePlus 8T에서 처음 설치, 작업 프로필 및 여러 사용자에 대해 동일하게 유지되었습니다.</li>
<li>첫 설치 및 병렬 공간에서의 OnePlus 8T의 Fingerprint V5 Optimal이 동일하게 유지되었습니다.</li>
<li>Redmi Note 10 Pro에서 다시 설치 후에도 미디어 DRM 및 Fingerprint V3 및 V5 Optimal이 동일하게 유지되었습니다.</li>
<li>OnePlus 8T의 첫 설치, 작업 프로필 및 병렬 공간에서 Fingerprint V5 Optimal이 다시 설치 후에도 동일하게 유지되었습니다.</li>
</ul>
<p>변경된 것 (= 나쁜):</p>
<ul>
<li>처음 설치 및 Island App에서 Fingerprint V5 Optimal이 변경되었습니다.</li>
<li>OnePlus 8 Pro에서 공장 초기화 후 Fingerprint V5 Optimal이 변경되었습니다.</li>
<li>Redmi Note 10 Pro의 두 번째 공간에서 Fingerprint V5 Optimal이 변경되었습니다.</li>
<li>OnePlus 8T의 병렬 공간에서 미디어 DRM이 변경되었습니다.</li>
<li>OnePlus 8T의 작업 프로필 및 게스트 사용자에서 Fingerprint V5 Optimal이 변경되었습니다.</li>
</ul>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>다른:</p>
<ul>
<li>에뮬레이터에서 FingerprintV3 Optimal이 Fingerprint V5 Optimal보다 성능이 더 좋았습니다.</li>
<li>Emulator 1과 Emulator 2에서 MediaDRM이 다르게 동작했는데 둘 다 동일한 Windows 기계에서 실행되었습니다.</li>
</ul>
<p>이러한 관찰을 바탕으로 Fingerprint V3과 V5 Optimal은 MediaDRM과 비교했을 때 많은 다중 인스턴스 사기 시나리오에서 실패했습니다. 이러한 테스트에서 우리는 MediaDRM이 더 나은 것으로 결론지었습니다.</p>
<h1>원시 데이터 분석</h1>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>결과를 양적으로 파악하기 위해 우리는 데이터를 살펴보고 해당 ID들의 행동을 평가하여 데이터를 기반으로 가장 적합한 ID를 찾아냈습니다. 사용자 기반의 기기와 비교하여 우리의 데이터가 왜곡되어 있고 대표적이지 않을 수 있다는 점을 기억해 주세요.</p>
<h2>2주간의 데이터 수집</h2>
<p>우리는 2주 동안 freeRASP 데이터를 수집하여 분석했습니다. 이 기간이 비교적 짧기 때문에 다시 설치하는 경우가 많지 않다고 가정합니다. 다시 한 번 강조하지만, 특정 응용프로그램의 카테고리/사용 사례에 따라 실제 재설치 비율이 달라질 수 있으므로 이 창을 선택하는 데 실제 재설치 비율에 대한 연구가 없다는 점을 유의해 주세요.</p>
<p>아래에서 각 ID의 고유 값 수와 이 데이터에서 캡처된 고유 디바이스 모델 수를 확인할 수 있습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>AndroidID: 13 402 601</p>
<p>FingerprintV3: 22 525 265</p>
<p>MediaDRM: 13 285 081</p>
<p>InstanceId: 13 740 706</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>다양한 기기 모델: 14,175 (예: Pixel 4, SM-G973N, ONEPLUS A5000, LG-H930, ...)</p>
<p>처음에 봤을 때 다른 ID들의 수보다 훨씬 높은 FingerprintV3의 수를 알아차렸어요. 이것은 사용자가 32가지 관측된 지문 신호 중 일부를 변경할 때마다 변하는 FingerprintV3의 행동에 의한 것일 수 있어요.</p>
<h2>ID들은 어떻게 관련이 있을까요?</h2>
<p>그 후, 우리는 ID들 간의 동시 발생을 살펴보았습니다. 이를 통해 그들 간의 관련성을 파악해 보았어요.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>아래 테이블을 읽는 방법입니다. 하나의 AndroidID에는 1.00557개의 고유한 MediaDRM이 있으며, 고유한 AndroidID 중 0.54%가 하나 이상의 MediaDRM을 가지고 있습니다.</p>
<h2>ID 충돌: 같은 ID지만 다른 기기</h2>
<p>데이터에 따르면, 우리는 여전히 "최적" 식별자를 찾고 있기 때문에 "다른 기기"가 무엇인지 말할 수 없습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>아이디 당 평균 모델 수를 살펴봐요. ID마다 모델이 하나만 있는 것이 이상적입니다 — 서로 다른 디바이스에 동일한 ID가 있는 충돌이 최소화되기를 바랍니다. 아래 표를 빠르게 살펴보면 진정한 불일치가 있음을 알 수 있어요.</p>
<p><img src="/assets/img/2024-06-22-Fraud-ProofinganAndroidAppChoosingtheBestDeviceIDforPromoAbusePrevention_5.png" alt="표"></p>
<h2>결과</h2>
<p>데이터 분석 결과, 다음과 같이 진술할 수 있어요:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>FingerprintV3는 다른 ID들에 비해 값이 너무 많아서 우리 시나리오에서는 덜 유용합니다.</li>
<li>하나의 AndroidID/MediaDRM/InstanceID에는 보통 여러 개의 FingerprintV3가 있습니다.</li>
<li>AndroidId와 MediaDRM은 대략 1:1 관계이며, 일부 MediaDRM 인스턴스에는 AndroidID보다 더 많은 AndroidID (AndroidId보다 더 많은 MediaDRM을 가지고 있는 경우도 있습니다).</li>
<li>경우에 따라 하나의 AndroidID에는 여러 개의 InstanceID (MediaDRM보다 더 자주 발생), MediaDRM과 InstanceID 사이의 관계와 유사합니다.</li>
<li>InstanceID는 MediaDRM보다 AndroidID와 더 밀접한 관계에 있습니다.</li>
<li>AndroidID는 하나의 모델만 가지고 있습니다 (이상치의 양은 극히 적음).</li>
<li>MediaDRM은 일반적으로 하나의 모델을 가지나, 몇 가지 충돌이 있을 수 있습니다 (AndroidID의 경우보다 더 많음).</li>
<li>InstanceId는 이 두 모델 사이 어딘가에 위치합니다.</li>
</ul>
<p>총평으로, 이러한 식별자 중에서 AndroidID가 가장 우수해 보이며, MediaDRM이 그 뒤를 이어갑니다. InstanceId도 유용할 수 있지만 AndroidID만큼은 아닙니다. FingerprintV3은 우리 시나리오에서는 쓸모 없습니다. AndroidID는 다시 설치 후 변경되고 상대적으로 쉽게 위조될 수 있기 때문에 사기 탐지에는 MediaDRM이 가장 적합해 보입니다.</p>
<p>다만, MediaDRM은 충돌이 꽤 많이 발생하는 것 같습니다 (모델 분석을 기반으로 확인한 결과). 같은 제조업체의 기기끼리(즉, 동일 제조업체의 기기일수록 다른 제조업체의 기기보다 더 같은 MediaDRM을 가질 가능성이 훨씬 높음) 충돌이 가장 자주 발생하는 것으로 밝혀졌습니다. 여기에 전반적인 개요를 제공해 드리겠습니다:</p>
<ul>
<li>MediaDRM 중 0.005%가 여러 제조업체를 가지고 있음</li>
<li>MediaDRM 중 0.55%가 같은 제조업체의 여러 모델을 가지고 있음</li>
<li>한 MediaDRM 당 평균 제조업체 수: 1.000085</li>
<li>한 제조업체 당 MediaDRM의 평균 모델 수: 1.006362</li>
</ul>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>MediaDRM를 개선할 수 있을까요?</h2>
<p>우리는 많은 시도(자세히 설명하지는 않겠습니다) 끝에 MediaDRM+모델의 조합을 잠재적 ID로 실험해 보았습니다.</p>
<p>구글 Pixel 4의 MediaDRM+모델의 결합 예시: e3af1aa4dacb6b6637846488b511e7643c6ac20b65c95baad164b122ecb036b6+Pixel 4</p>
<p>아래는 위와 동일한 공현 테이블이며, 이제 MediaDRM+모델과의 관계를 포함하고 있습니다:</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p><img src="/assets/img/2024-06-22-Fraud-ProofinganAndroidAppChoosingtheBestDeviceIDforPromoAbusePrevention_6.png" alt="Image"></p>
<p>우리는 MediaDRM+ 모델이 원래의 MediaDRM보다 더 나은 성능을 보여준다는 것을 확인할 수 있습니다. 각 MediaDRM+ 모델에는 연관된 다른 ID의 수가 더 적습니다. 이는 몇 가지 충돌을 피했다는 것을 의미합니다 (정확한 숫자를 측정하기는 어렵지만, 최소한의 경계는 MediaDRM과 MediaDRM+ 모델의 숫자로 추정됩니다).</p>
<p>두 가지 특성의 조합으로 ID를 만들 때, 한 기기가 더 많은 ID를 가지는 문제가 발생할 수 있습니다. 그러나 MediaDRM+ 모델에서는 이런 경우가 발생하지 않아야 합니다. 한 기기에는 하나의 모델만 연결되어야 하기 때문에 (즉, 구글 픽셀 4 전화기의 물리적 단위는 항상 "Pixel 4" 모델 이름만을 가져야 함).</p>
<p>그러므로 데이터를 기반으로, 사기 탐지 사례를 검토할 때 MediaDRM과 기기 모델의 간단한 조합을 ID로 사용하는 것을 제안합니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>요약</h1>
<p>저희는 모바일 기기 식별에 대한 도전에 직면하고 있습니다 — 사용자 개인 정보를 침해하지 않고 사기꾼 기기를 차단하는 방법에 대해 고민하고 있습니다. 모바일 앱 소유자들은 사용자들이 결제를 회피하거나 보너스를 악용하는 문제에 직면하고 있는데, 이는 여러 번 앱을 재설치함으로써 이루어지는 다중 인스턴스화로 인한 문제입니다. 신뢰할 수 없는 기기 ID로 인해 꾸준한 악의적인 사용자를 식별하는 것이 어려워지고 있습니다. 저희의 연구 결과는 효과적인 차단을 위해 미디어 DRM을 기기 지문보다 우선시하는 것을 권장하며 (또는 더 나아가 미디어 DRM과 기기 모델 조합을 권장합니다). 또한 AppiCrypt, RASP 및 KYC 솔루션과 같은 추가적인 보안층으로 보호 강화를 잊지 마세요. 모든 시나리오는 유니크합니다. 맞춤형 조언이 필요하시면 <a href="mailto:info@talsec.app">info@talsec.app</a> 으로 Talsec 보안 전문가에게 문의하세요.</p>
<p>저자: Dáša Pawlasová, Matúš Šikyňa, Tomáš Soukal</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"안드로이드 앱 부정 방지 프로모션 남용을 막기 위한 최적의 디바이스 ID 선택 방법","description":"","date":"2024-06-22 23:17","slug":"2024-06-22-Fraud-ProofinganAndroidAppChoosingtheBestDeviceIDforPromoAbusePrevention","content":"\n⚡주요 요점:\n\n- 프로모션 남용은 비즈니스의 가입 보너스, 추천, 쿠폰 또는 프로모션을 악용하는 사기 유형입니다.\n- 가능한 경우에는 MediaDRM을 디바이스 지문보다 선호해야 합니다.\n- 우리의 연구 결과, 블록리스트에 가장 적합한 최고의 디바이스 ID는 MediaDRM+디바이스 모델의 결합입니다.\n- 모바일 앱 백엔드 API를 보호하는 AppiCrypt(앱 보호), RASP(앱 쉴딩) 및 KYC 솔루션(고객 신원 확인)과 같은 여러 보안 계층을 항상 포함해야 합니다.\n- 특정 시나리오에 따라 다른 접근 방식이 필요할 수 있다는 것을 염두에 두세요. info@talsec.app으로 메시지를 남기면 Talsec 보안 전문가가 도와드릴 것입니다.\n\n# 사용자 파악 방법?\n\n최근에 모바일 디바이스 식별에서 어려움에 부딪혔습니다 - 사용자 개인정보를 침해하지 않으면서 사기적인 디바이스를 식별하고 블록리스트에 올리는 방법은 무엇일까요. 이 문제는 결제 회피 또는 다양한 보너스를 악용하는 사용자들과 빈번히 대면하는 모바일 애플리케이션 소유자에게 특히 중요합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n초기 가입 시 사용자들을 유혹하는 매력적인 보너스로 사용자를 유치하는 것은 흔한 일이지만, 이 전략은 내재적인 위험을 안고 있으며 남용될 수 있다는 점을 인지하는 것이 중요합니다. 이 악의적인 사용자들은 앱을 여러 번 다시 설치하여 계속해서 가입 보너스를 얻으려는 행위를 하는데, 이를 \"멀티 인스턴싱\"이라고 부릅니다.\n\n안드로이드는 각 앱 인스턴스마다 일부 디바이스 ID를 변경하므로, 동일한 악의적 사용자의 디바이스를 차단하기가 어려워집니다. 이는 효과적인 해결책을 찾기 위한 우리의 노력이 복잡함을 강조합니다.\n\n![이미지](/assets/img/2024-06-22-Fraud-ProofinganAndroidAppChoosingtheBestDeviceIDforPromoAbusePrevention_0.png)\n\n# 좋은 ID는 고유하며 충돌 방지, 지속적이고 개인정보 친화적이어야 합니다. 그리고 위조할 수 없어야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n과거에는 특별한 권한을 요청하지 않고 MAC 주소나 IMEI를 통해 기기를 식별할 수 있었어요. 오늘날 안드로이드 개인 정보 보호를 위한 다양한 변경 사항 이후, Android 기기에서 AndroidID, MediaDRM, GSF ID, FID 및 InstanceID와 같은 여러 반영구적 ID가 사용 가능해졌어요. 물론, 사용자에게 상승된 액세스 및 잠재적 보안 문제를 가진 권한을 요청하는 것은 현실적이지 않아요.\n\n각 ID에는 장단점이 있어 다양한 시나리오에서 유용하게 사용될 수 있어요. 아래 예시 테이블을 참고하세요. Android 문서에서 ID에 대한 추가 정보를 찾을 수 있어요.\n\n또 다른 방법으로는 다양한 디바이스 지문 라이브러리(예: fingerprintjs-android)를 사용하여 여러 기기 ID, 기기 상태, OS 지문 또는 설치된 앱을 기반으로 ID를 생성할 수 있어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 ID들을 더 자세히 살펴보겠습니다.\n\n# AndroidID, GSF ID, FID, InstanceID, Google 광고 ID\n\n이러한 식별 방법은 다른 맥락에서는 잘 작동할 수 있지만, 우리의 시나리오에서는 부정한 다중 인스턴싱에 견딜 수 있는 견고함이 부족합니다. 이러한 ID들은 비교적 쉽게 변경할 수 있으므로 각각에 대한 단점에 대해 간단한 설명만 제공하겠습니다.\n\n- AndroidID는 다시 패키징되거나 기기의 다른 사용자로 설치되는 경우 변경됩니다.\n- GSF ID (Google Play 서비스 프레임워크 ID)는 Google 기기에만 제한되며 XPrivacyLua에 의해 상대적으로 쉽게 위조될 수 있습니다. 또한 다른 사용자에 대해 변경됩니다.\n- FID (Firebase 설치 ID)는 재설치를 견뎌내지 못합니다.\n- InstanceID (GUID, UUID.randomUUID().toString())는 사용자 정의 생성 및 내부 저장 ID입니다만, 재설치를 견딜 수 없습니다.\n- Google 광고 ID는 전혀 적합하지 않습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n요약하면, 우리의 시나리오에서 나쁜 행위자를 식별하는 데 충분히 견고한 ID는 없습니다.\n\n# fingerprintjs-android 라이브러리 기반의 지문 ID\n\n참고: 전체 분석에서 우리는 상태 없는 오프라인 지문 ID를 위해 종합적인 신호 목록을 사용하는 fingerprintjs-android 라이브러리를 사용했습니다. 다른 지문 ID 라이브러리의 결과는 다를 수 있습니다. 이는 그들의 데이터 인사이트, 지리 위치, IP 위치, TEE 및 다른 요소에 기반한 더 많은 신호와 휴리스틱을 포함할 수 있습니다. Talsec는 fingerprintjs-android V3 및 StabilityLevel.OPTIMAL을 수집합니다. 안정성 수준 (STABLE — OPTIMAL — UNIQUE) 사이의 차이점은 여기에서 찾을 수 있습니다.\n\n위의 표를 다시 한 번 살펴보세요. 첫눈에는 하드웨어 지문 (위의 표 참조)가 최선의 선택일 수 있습니다. 이것은 인스턴트 앱 이벤트를 제외하고는 무엇이든 견딜 수 있습니다. 그러나 이 ID에는 한 가지 심각한 단점이 있습니다 — 충돌입니다. 이 충돌은 ID가 계산되는 방식에 의해 발생합니다. ID는 디바이스의 하드웨어에만 기반하기 때문에 발생합니다. 예를 들어, 조립 라인에서 직접 나오는 모든 삼성 갤럭시 Z 플립이 동일한 ID를 갖게 될 것입니다. 이 유형의 지문은 STABLE 지문이라고 불립니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![2024-06-22-Fraud-ProofinganAndroidAppChoosingtheBestDeviceIDforPromoAbusePrevention_2.png](/assets/img/2024-06-22-Fraud-ProofinganAndroidAppChoosingtheBestDeviceIDforPromoAbusePrevention_2.png)\n\n한편, 고유한 지문(fingerprint)이 있습니다. 이것은 기기의 ID를 계산하기 위해 상당량의 신호를 사용합니다. 이 방식으로 생성된 ID는 하나의 사용자에게만 매칭될 가능성이 높습니다(충돌이 적음), 그러나 신호가 많기 때문에 ID가 자주 변경될 수 있습니다(예: 설정 변경시). 따라서 하나의 사용자에게 많은 ID가 생길 수 있어 우리의 사용 사례에는 유용하지 않습니다. 예: 설치된 앱이 변경되거나 데이터 로밍이 활성화/비활성화될 때 ID가 변경될 수 있습니다.\n\n세 번째 유형의 지문은 STABLE과 UNIQUE 지문 사이의 절충안인 OPTIMAL 지문입니다. 이 지문은 STABLE 지문보다는 덜 안정적이지만 더 고유하며 Talsec SDK에 의해 수집됩니다. 그러나 이 유형의 지문조차 이 기사에서 나중에 보여줄 것처럼 최적적이지 않습니다. 예: 사용자가 12시 및 24시간 형식으로 전환하거나 개발자 설정 또는 ADB가 활성화/비활성화될 때 ID가 변경될 수 있습니다.\n\n지문 예시: `f37fc958dc6d566a8f4bf1e0fd25b510`\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# MediaDRM\n\nMediaDrm은 프리미엄 콘텐츠 재생을 위해 암호화 키를 안전하게 제공하는 안드로이드 API입니다. Google의 Widevine 및 Microsoft의 PlayReady와 같은 DRM 공급자를 사용합니다. 초기 DRM 사용 중에는 장치 프로비저닝을 통해 장치의 DRM 서비스에 저장된 고유한 인증서를 획득합니다.\n\n이 API에서 제공되는 MediaDRM은 장치 상의 모든 사용자에게 동일하지만, 저희 상황에서는 위조하기 어렵고 많은 공격에도 견딜 수 있습니다. 이 ID를 얻으려면 권한이 필요하지 않습니다.\n\n하지만 여전히 제한 사항이 있습니다. MediaDrm을 지원하지 않는 장치에서는 사용할 수 없을 수 있습니다. 또한 동일한 제조업체의 장치 간에는 충돌이 많이 발생할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nMediaDRM 예시: `e3af1aa4dacb6b6637846488b511e7643c6ac20b65c95baad164b122ecb036b6`\n\n# MediaDRM vs 지문 ID?\n\n우리는 다섯 대의 기기와 에뮬레이터를 여러 개의 다중 인스턴싱 시나리오에서 테스트하고 ID가 변경되었는지 여부를 확인했습니다. 가장 흥미로운 부분은 MediaDRM과 Fingerprint (V3 \u0026 V5 Optimal)입니다. 그래서 우리는 특히 이 부분에 주의를 기울였습니다.\n\n다중 인스턴싱 시나리오:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 앱의 첫 설치\n- 앱 재설치\n- 작업 프로필에 설치\n- Island 앱을 사용하여 앱의 복제\n- Parallel Space를 사용하여 앱의 복제\n- 병렬 애플리케이션을 사용하여 앱의 복제\n- 두 번째 공간(Xiaomi)을 사용하여 앱의 복제\n- 손님 프로필에 설치\n- 공장 초기화\n- 안드로이드 에뮬레이터 대 실제 기기\n\n이 지루한 작업은 훌륭한 지문 OSS 데모 도구 덕분에 더 쉽게 진행되었습니다.\n\n\u003cimg src=\"/assets/img/2024-06-22-Fraud-ProofinganAndroidAppChoosingtheBestDeviceIDforPromoAbusePrevention_3.png\" /\u003e\n\n가장 중요한 관찰 결과를 여기에 나열하였습니다. 모든 테스트를 항상 수행할 수는 없었기 때문에 사소한 부분들은 모두 다시 시도했습니다 - 이는 공격자들이 시도할 것이기 때문입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n유지한 것 (= 좋은):\n\n- 미디어 DRM은 처음 설치 시 OnePlus 8 Pro의 Island App에서 동일하게 유지되었습니다.\n- 미디어 DRM은 Redmi Note 10 Pro의 두 번째 공간에서 동일하게 유지되었습니다.\n- 미디어 DRM은 OnePlus 8 Pro에서 공장 초기화 후에도 동일하게 유지되었습니다.\n- 미디어 DRM은 OnePlus 8T에서 처음 설치, 작업 프로필 및 여러 사용자에 대해 동일하게 유지되었습니다.\n- 첫 설치 및 병렬 공간에서의 OnePlus 8T의 Fingerprint V5 Optimal이 동일하게 유지되었습니다.\n- Redmi Note 10 Pro에서 다시 설치 후에도 미디어 DRM 및 Fingerprint V3 및 V5 Optimal이 동일하게 유지되었습니다.\n- OnePlus 8T의 첫 설치, 작업 프로필 및 병렬 공간에서 Fingerprint V5 Optimal이 다시 설치 후에도 동일하게 유지되었습니다.\n\n변경된 것 (= 나쁜):\n\n- 처음 설치 및 Island App에서 Fingerprint V5 Optimal이 변경되었습니다.\n- OnePlus 8 Pro에서 공장 초기화 후 Fingerprint V5 Optimal이 변경되었습니다.\n- Redmi Note 10 Pro의 두 번째 공간에서 Fingerprint V5 Optimal이 변경되었습니다.\n- OnePlus 8T의 병렬 공간에서 미디어 DRM이 변경되었습니다.\n- OnePlus 8T의 작업 프로필 및 게스트 사용자에서 Fingerprint V5 Optimal이 변경되었습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다른:\n\n- 에뮬레이터에서 FingerprintV3 Optimal이 Fingerprint V5 Optimal보다 성능이 더 좋았습니다.\n- Emulator 1과 Emulator 2에서 MediaDRM이 다르게 동작했는데 둘 다 동일한 Windows 기계에서 실행되었습니다.\n\n이러한 관찰을 바탕으로 Fingerprint V3과 V5 Optimal은 MediaDRM과 비교했을 때 많은 다중 인스턴스 사기 시나리오에서 실패했습니다. 이러한 테스트에서 우리는 MediaDRM이 더 나은 것으로 결론지었습니다.\n\n# 원시 데이터 분석\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n결과를 양적으로 파악하기 위해 우리는 데이터를 살펴보고 해당 ID들의 행동을 평가하여 데이터를 기반으로 가장 적합한 ID를 찾아냈습니다. 사용자 기반의 기기와 비교하여 우리의 데이터가 왜곡되어 있고 대표적이지 않을 수 있다는 점을 기억해 주세요.\n\n## 2주간의 데이터 수집\n\n우리는 2주 동안 freeRASP 데이터를 수집하여 분석했습니다. 이 기간이 비교적 짧기 때문에 다시 설치하는 경우가 많지 않다고 가정합니다. 다시 한 번 강조하지만, 특정 응용프로그램의 카테고리/사용 사례에 따라 실제 재설치 비율이 달라질 수 있으므로 이 창을 선택하는 데 실제 재설치 비율에 대한 연구가 없다는 점을 유의해 주세요.\n\n아래에서 각 ID의 고유 값 수와 이 데이터에서 캡처된 고유 디바이스 모델 수를 확인할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nAndroidID: 13 402 601\n\nFingerprintV3: 22 525 265\n\nMediaDRM: 13 285 081\n\nInstanceId: 13 740 706\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다양한 기기 모델: 14,175 (예: Pixel 4, SM-G973N, ONEPLUS A5000, LG-H930, ...)\n\n처음에 봤을 때 다른 ID들의 수보다 훨씬 높은 FingerprintV3의 수를 알아차렸어요. 이것은 사용자가 32가지 관측된 지문 신호 중 일부를 변경할 때마다 변하는 FingerprintV3의 행동에 의한 것일 수 있어요.\n\n## ID들은 어떻게 관련이 있을까요?\n\n그 후, 우리는 ID들 간의 동시 발생을 살펴보았습니다. 이를 통해 그들 간의 관련성을 파악해 보았어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래 테이블을 읽는 방법입니다. 하나의 AndroidID에는 1.00557개의 고유한 MediaDRM이 있으며, 고유한 AndroidID 중 0.54%가 하나 이상의 MediaDRM을 가지고 있습니다.\n\n## ID 충돌: 같은 ID지만 다른 기기\n\n데이터에 따르면, 우리는 여전히 \"최적\" 식별자를 찾고 있기 때문에 \"다른 기기\"가 무엇인지 말할 수 없습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아이디 당 평균 모델 수를 살펴봐요. ID마다 모델이 하나만 있는 것이 이상적입니다 — 서로 다른 디바이스에 동일한 ID가 있는 충돌이 최소화되기를 바랍니다. 아래 표를 빠르게 살펴보면 진정한 불일치가 있음을 알 수 있어요.\n\n![표](/assets/img/2024-06-22-Fraud-ProofinganAndroidAppChoosingtheBestDeviceIDforPromoAbusePrevention_5.png)\n\n## 결과\n\n데이터 분석 결과, 다음과 같이 진술할 수 있어요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- FingerprintV3는 다른 ID들에 비해 값이 너무 많아서 우리 시나리오에서는 덜 유용합니다.\n- 하나의 AndroidID/MediaDRM/InstanceID에는 보통 여러 개의 FingerprintV3가 있습니다.\n- AndroidId와 MediaDRM은 대략 1:1 관계이며, 일부 MediaDRM 인스턴스에는 AndroidID보다 더 많은 AndroidID (AndroidId보다 더 많은 MediaDRM을 가지고 있는 경우도 있습니다).\n- 경우에 따라 하나의 AndroidID에는 여러 개의 InstanceID (MediaDRM보다 더 자주 발생), MediaDRM과 InstanceID 사이의 관계와 유사합니다.\n- InstanceID는 MediaDRM보다 AndroidID와 더 밀접한 관계에 있습니다.\n- AndroidID는 하나의 모델만 가지고 있습니다 (이상치의 양은 극히 적음).\n- MediaDRM은 일반적으로 하나의 모델을 가지나, 몇 가지 충돌이 있을 수 있습니다 (AndroidID의 경우보다 더 많음).\n- InstanceId는 이 두 모델 사이 어딘가에 위치합니다.\n\n총평으로, 이러한 식별자 중에서 AndroidID가 가장 우수해 보이며, MediaDRM이 그 뒤를 이어갑니다. InstanceId도 유용할 수 있지만 AndroidID만큼은 아닙니다. FingerprintV3은 우리 시나리오에서는 쓸모 없습니다. AndroidID는 다시 설치 후 변경되고 상대적으로 쉽게 위조될 수 있기 때문에 사기 탐지에는 MediaDRM이 가장 적합해 보입니다.\n\n다만, MediaDRM은 충돌이 꽤 많이 발생하는 것 같습니다 (모델 분석을 기반으로 확인한 결과). 같은 제조업체의 기기끼리(즉, 동일 제조업체의 기기일수록 다른 제조업체의 기기보다 더 같은 MediaDRM을 가질 가능성이 훨씬 높음) 충돌이 가장 자주 발생하는 것으로 밝혀졌습니다. 여기에 전반적인 개요를 제공해 드리겠습니다:\n\n- MediaDRM 중 0.005%가 여러 제조업체를 가지고 있음\n- MediaDRM 중 0.55%가 같은 제조업체의 여러 모델을 가지고 있음\n- 한 MediaDRM 당 평균 제조업체 수: 1.000085\n- 한 제조업체 당 MediaDRM의 평균 모델 수: 1.006362\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## MediaDRM를 개선할 수 있을까요?\n\n우리는 많은 시도(자세히 설명하지는 않겠습니다) 끝에 MediaDRM+모델의 조합을 잠재적 ID로 실험해 보았습니다.\n\n구글 Pixel 4의 MediaDRM+모델의 결합 예시: e3af1aa4dacb6b6637846488b511e7643c6ac20b65c95baad164b122ecb036b6+Pixel 4\n\n아래는 위와 동일한 공현 테이블이며, 이제 MediaDRM+모델과의 관계를 포함하고 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Image](/assets/img/2024-06-22-Fraud-ProofinganAndroidAppChoosingtheBestDeviceIDforPromoAbusePrevention_6.png)\n\n우리는 MediaDRM+ 모델이 원래의 MediaDRM보다 더 나은 성능을 보여준다는 것을 확인할 수 있습니다. 각 MediaDRM+ 모델에는 연관된 다른 ID의 수가 더 적습니다. 이는 몇 가지 충돌을 피했다는 것을 의미합니다 (정확한 숫자를 측정하기는 어렵지만, 최소한의 경계는 MediaDRM과 MediaDRM+ 모델의 숫자로 추정됩니다).\n\n두 가지 특성의 조합으로 ID를 만들 때, 한 기기가 더 많은 ID를 가지는 문제가 발생할 수 있습니다. 그러나 MediaDRM+ 모델에서는 이런 경우가 발생하지 않아야 합니다. 한 기기에는 하나의 모델만 연결되어야 하기 때문에 (즉, 구글 픽셀 4 전화기의 물리적 단위는 항상 \"Pixel 4\" 모델 이름만을 가져야 함).\n\n그러므로 데이터를 기반으로, 사기 탐지 사례를 검토할 때 MediaDRM과 기기 모델의 간단한 조합을 ID로 사용하는 것을 제안합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 요약\n\n저희는 모바일 기기 식별에 대한 도전에 직면하고 있습니다 — 사용자 개인 정보를 침해하지 않고 사기꾼 기기를 차단하는 방법에 대해 고민하고 있습니다. 모바일 앱 소유자들은 사용자들이 결제를 회피하거나 보너스를 악용하는 문제에 직면하고 있는데, 이는 여러 번 앱을 재설치함으로써 이루어지는 다중 인스턴스화로 인한 문제입니다. 신뢰할 수 없는 기기 ID로 인해 꾸준한 악의적인 사용자를 식별하는 것이 어려워지고 있습니다. 저희의 연구 결과는 효과적인 차단을 위해 미디어 DRM을 기기 지문보다 우선시하는 것을 권장하며 (또는 더 나아가 미디어 DRM과 기기 모델 조합을 권장합니다). 또한 AppiCrypt, RASP 및 KYC 솔루션과 같은 추가적인 보안층으로 보호 강화를 잊지 마세요. 모든 시나리오는 유니크합니다. 맞춤형 조언이 필요하시면 info@talsec.app 으로 Talsec 보안 전문가에게 문의하세요.\n\n저자: Dáša Pawlasová, Matúš Šikyňa, Tomáš Soukal\n","ogImage":{"url":"/assets/img/2024-06-22-Fraud-ProofinganAndroidAppChoosingtheBestDeviceIDforPromoAbusePrevention_0.png"},"coverImage":"/assets/img/2024-06-22-Fraud-ProofinganAndroidAppChoosingtheBestDeviceIDforPromoAbusePrevention_0.png","tag":["Tech"],"readingTime":15},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e⚡주요 요점:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e프로모션 남용은 비즈니스의 가입 보너스, 추천, 쿠폰 또는 프로모션을 악용하는 사기 유형입니다.\u003c/li\u003e\n\u003cli\u003e가능한 경우에는 MediaDRM을 디바이스 지문보다 선호해야 합니다.\u003c/li\u003e\n\u003cli\u003e우리의 연구 결과, 블록리스트에 가장 적합한 최고의 디바이스 ID는 MediaDRM+디바이스 모델의 결합입니다.\u003c/li\u003e\n\u003cli\u003e모바일 앱 백엔드 API를 보호하는 AppiCrypt(앱 보호), RASP(앱 쉴딩) 및 KYC 솔루션(고객 신원 확인)과 같은 여러 보안 계층을 항상 포함해야 합니다.\u003c/li\u003e\n\u003cli\u003e특정 시나리오에 따라 다른 접근 방식이 필요할 수 있다는 것을 염두에 두세요. \u003ca href=\"mailto:info@talsec.app\"\u003einfo@talsec.app\u003c/a\u003e으로 메시지를 남기면 Talsec 보안 전문가가 도와드릴 것입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e사용자 파악 방법?\u003c/h1\u003e\n\u003cp\u003e최근에 모바일 디바이스 식별에서 어려움에 부딪혔습니다 - 사용자 개인정보를 침해하지 않으면서 사기적인 디바이스를 식별하고 블록리스트에 올리는 방법은 무엇일까요. 이 문제는 결제 회피 또는 다양한 보너스를 악용하는 사용자들과 빈번히 대면하는 모바일 애플리케이션 소유자에게 특히 중요합니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e초기 가입 시 사용자들을 유혹하는 매력적인 보너스로 사용자를 유치하는 것은 흔한 일이지만, 이 전략은 내재적인 위험을 안고 있으며 남용될 수 있다는 점을 인지하는 것이 중요합니다. 이 악의적인 사용자들은 앱을 여러 번 다시 설치하여 계속해서 가입 보너스를 얻으려는 행위를 하는데, 이를 \"멀티 인스턴싱\"이라고 부릅니다.\u003c/p\u003e\n\u003cp\u003e안드로이드는 각 앱 인스턴스마다 일부 디바이스 ID를 변경하므로, 동일한 악의적 사용자의 디바이스를 차단하기가 어려워집니다. 이는 효과적인 해결책을 찾기 위한 우리의 노력이 복잡함을 강조합니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-Fraud-ProofinganAndroidAppChoosingtheBestDeviceIDforPromoAbusePrevention_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch1\u003e좋은 ID는 고유하며 충돌 방지, 지속적이고 개인정보 친화적이어야 합니다. 그리고 위조할 수 없어야 합니다.\u003c/h1\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e과거에는 특별한 권한을 요청하지 않고 MAC 주소나 IMEI를 통해 기기를 식별할 수 있었어요. 오늘날 안드로이드 개인 정보 보호를 위한 다양한 변경 사항 이후, Android 기기에서 AndroidID, MediaDRM, GSF ID, FID 및 InstanceID와 같은 여러 반영구적 ID가 사용 가능해졌어요. 물론, 사용자에게 상승된 액세스 및 잠재적 보안 문제를 가진 권한을 요청하는 것은 현실적이지 않아요.\u003c/p\u003e\n\u003cp\u003e각 ID에는 장단점이 있어 다양한 시나리오에서 유용하게 사용될 수 있어요. 아래 예시 테이블을 참고하세요. Android 문서에서 ID에 대한 추가 정보를 찾을 수 있어요.\u003c/p\u003e\n\u003cp\u003e또 다른 방법으로는 다양한 디바이스 지문 라이브러리(예: fingerprintjs-android)를 사용하여 여러 기기 ID, 기기 상태, OS 지문 또는 설치된 앱을 기반으로 ID를 생성할 수 있어요.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이 ID들을 더 자세히 살펴보겠습니다.\u003c/p\u003e\n\u003ch1\u003eAndroidID, GSF ID, FID, InstanceID, Google 광고 ID\u003c/h1\u003e\n\u003cp\u003e이러한 식별 방법은 다른 맥락에서는 잘 작동할 수 있지만, 우리의 시나리오에서는 부정한 다중 인스턴싱에 견딜 수 있는 견고함이 부족합니다. 이러한 ID들은 비교적 쉽게 변경할 수 있으므로 각각에 대한 단점에 대해 간단한 설명만 제공하겠습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eAndroidID는 다시 패키징되거나 기기의 다른 사용자로 설치되는 경우 변경됩니다.\u003c/li\u003e\n\u003cli\u003eGSF ID (Google Play 서비스 프레임워크 ID)는 Google 기기에만 제한되며 XPrivacyLua에 의해 상대적으로 쉽게 위조될 수 있습니다. 또한 다른 사용자에 대해 변경됩니다.\u003c/li\u003e\n\u003cli\u003eFID (Firebase 설치 ID)는 재설치를 견뎌내지 못합니다.\u003c/li\u003e\n\u003cli\u003eInstanceID (GUID, UUID.randomUUID().toString())는 사용자 정의 생성 및 내부 저장 ID입니다만, 재설치를 견딜 수 없습니다.\u003c/li\u003e\n\u003cli\u003eGoogle 광고 ID는 전혀 적합하지 않습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e요약하면, 우리의 시나리오에서 나쁜 행위자를 식별하는 데 충분히 견고한 ID는 없습니다.\u003c/p\u003e\n\u003ch1\u003efingerprintjs-android 라이브러리 기반의 지문 ID\u003c/h1\u003e\n\u003cp\u003e참고: 전체 분석에서 우리는 상태 없는 오프라인 지문 ID를 위해 종합적인 신호 목록을 사용하는 fingerprintjs-android 라이브러리를 사용했습니다. 다른 지문 ID 라이브러리의 결과는 다를 수 있습니다. 이는 그들의 데이터 인사이트, 지리 위치, IP 위치, TEE 및 다른 요소에 기반한 더 많은 신호와 휴리스틱을 포함할 수 있습니다. Talsec는 fingerprintjs-android V3 및 StabilityLevel.OPTIMAL을 수집합니다. 안정성 수준 (STABLE — OPTIMAL — UNIQUE) 사이의 차이점은 여기에서 찾을 수 있습니다.\u003c/p\u003e\n\u003cp\u003e위의 표를 다시 한 번 살펴보세요. 첫눈에는 하드웨어 지문 (위의 표 참조)가 최선의 선택일 수 있습니다. 이것은 인스턴트 앱 이벤트를 제외하고는 무엇이든 견딜 수 있습니다. 그러나 이 ID에는 한 가지 심각한 단점이 있습니다 — 충돌입니다. 이 충돌은 ID가 계산되는 방식에 의해 발생합니다. ID는 디바이스의 하드웨어에만 기반하기 때문에 발생합니다. 예를 들어, 조립 라인에서 직접 나오는 모든 삼성 갤럭시 Z 플립이 동일한 ID를 갖게 될 것입니다. 이 유형의 지문은 STABLE 지문이라고 불립니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-Fraud-ProofinganAndroidAppChoosingtheBestDeviceIDforPromoAbusePrevention_2.png\" alt=\"2024-06-22-Fraud-ProofinganAndroidAppChoosingtheBestDeviceIDforPromoAbusePrevention_2.png\"\u003e\u003c/p\u003e\n\u003cp\u003e한편, 고유한 지문(fingerprint)이 있습니다. 이것은 기기의 ID를 계산하기 위해 상당량의 신호를 사용합니다. 이 방식으로 생성된 ID는 하나의 사용자에게만 매칭될 가능성이 높습니다(충돌이 적음), 그러나 신호가 많기 때문에 ID가 자주 변경될 수 있습니다(예: 설정 변경시). 따라서 하나의 사용자에게 많은 ID가 생길 수 있어 우리의 사용 사례에는 유용하지 않습니다. 예: 설치된 앱이 변경되거나 데이터 로밍이 활성화/비활성화될 때 ID가 변경될 수 있습니다.\u003c/p\u003e\n\u003cp\u003e세 번째 유형의 지문은 STABLE과 UNIQUE 지문 사이의 절충안인 OPTIMAL 지문입니다. 이 지문은 STABLE 지문보다는 덜 안정적이지만 더 고유하며 Talsec SDK에 의해 수집됩니다. 그러나 이 유형의 지문조차 이 기사에서 나중에 보여줄 것처럼 최적적이지 않습니다. 예: 사용자가 12시 및 24시간 형식으로 전환하거나 개발자 설정 또는 ADB가 활성화/비활성화될 때 ID가 변경될 수 있습니다.\u003c/p\u003e\n\u003cp\u003e지문 예시: \u003ccode\u003ef37fc958dc6d566a8f4bf1e0fd25b510\u003c/code\u003e\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003eMediaDRM\u003c/h1\u003e\n\u003cp\u003eMediaDrm은 프리미엄 콘텐츠 재생을 위해 암호화 키를 안전하게 제공하는 안드로이드 API입니다. Google의 Widevine 및 Microsoft의 PlayReady와 같은 DRM 공급자를 사용합니다. 초기 DRM 사용 중에는 장치 프로비저닝을 통해 장치의 DRM 서비스에 저장된 고유한 인증서를 획득합니다.\u003c/p\u003e\n\u003cp\u003e이 API에서 제공되는 MediaDRM은 장치 상의 모든 사용자에게 동일하지만, 저희 상황에서는 위조하기 어렵고 많은 공격에도 견딜 수 있습니다. 이 ID를 얻으려면 권한이 필요하지 않습니다.\u003c/p\u003e\n\u003cp\u003e하지만 여전히 제한 사항이 있습니다. MediaDrm을 지원하지 않는 장치에서는 사용할 수 없을 수 있습니다. 또한 동일한 제조업체의 장치 간에는 충돌이 많이 발생할 수 있습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eMediaDRM 예시: \u003ccode\u003ee3af1aa4dacb6b6637846488b511e7643c6ac20b65c95baad164b122ecb036b6\u003c/code\u003e\u003c/p\u003e\n\u003ch1\u003eMediaDRM vs 지문 ID?\u003c/h1\u003e\n\u003cp\u003e우리는 다섯 대의 기기와 에뮬레이터를 여러 개의 다중 인스턴싱 시나리오에서 테스트하고 ID가 변경되었는지 여부를 확인했습니다. 가장 흥미로운 부분은 MediaDRM과 Fingerprint (V3 \u0026#x26; V5 Optimal)입니다. 그래서 우리는 특히 이 부분에 주의를 기울였습니다.\u003c/p\u003e\n\u003cp\u003e다중 인스턴싱 시나리오:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003e앱의 첫 설치\u003c/li\u003e\n\u003cli\u003e앱 재설치\u003c/li\u003e\n\u003cli\u003e작업 프로필에 설치\u003c/li\u003e\n\u003cli\u003eIsland 앱을 사용하여 앱의 복제\u003c/li\u003e\n\u003cli\u003eParallel Space를 사용하여 앱의 복제\u003c/li\u003e\n\u003cli\u003e병렬 애플리케이션을 사용하여 앱의 복제\u003c/li\u003e\n\u003cli\u003e두 번째 공간(Xiaomi)을 사용하여 앱의 복제\u003c/li\u003e\n\u003cli\u003e손님 프로필에 설치\u003c/li\u003e\n\u003cli\u003e공장 초기화\u003c/li\u003e\n\u003cli\u003e안드로이드 에뮬레이터 대 실제 기기\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이 지루한 작업은 훌륭한 지문 OSS 데모 도구 덕분에 더 쉽게 진행되었습니다.\u003c/p\u003e\n\u003cimg src=\"/assets/img/2024-06-22-Fraud-ProofinganAndroidAppChoosingtheBestDeviceIDforPromoAbusePrevention_3.png\"\u003e\n\u003cp\u003e가장 중요한 관찰 결과를 여기에 나열하였습니다. 모든 테스트를 항상 수행할 수는 없었기 때문에 사소한 부분들은 모두 다시 시도했습니다 - 이는 공격자들이 시도할 것이기 때문입니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e유지한 것 (= 좋은):\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e미디어 DRM은 처음 설치 시 OnePlus 8 Pro의 Island App에서 동일하게 유지되었습니다.\u003c/li\u003e\n\u003cli\u003e미디어 DRM은 Redmi Note 10 Pro의 두 번째 공간에서 동일하게 유지되었습니다.\u003c/li\u003e\n\u003cli\u003e미디어 DRM은 OnePlus 8 Pro에서 공장 초기화 후에도 동일하게 유지되었습니다.\u003c/li\u003e\n\u003cli\u003e미디어 DRM은 OnePlus 8T에서 처음 설치, 작업 프로필 및 여러 사용자에 대해 동일하게 유지되었습니다.\u003c/li\u003e\n\u003cli\u003e첫 설치 및 병렬 공간에서의 OnePlus 8T의 Fingerprint V5 Optimal이 동일하게 유지되었습니다.\u003c/li\u003e\n\u003cli\u003eRedmi Note 10 Pro에서 다시 설치 후에도 미디어 DRM 및 Fingerprint V3 및 V5 Optimal이 동일하게 유지되었습니다.\u003c/li\u003e\n\u003cli\u003eOnePlus 8T의 첫 설치, 작업 프로필 및 병렬 공간에서 Fingerprint V5 Optimal이 다시 설치 후에도 동일하게 유지되었습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e변경된 것 (= 나쁜):\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e처음 설치 및 Island App에서 Fingerprint V5 Optimal이 변경되었습니다.\u003c/li\u003e\n\u003cli\u003eOnePlus 8 Pro에서 공장 초기화 후 Fingerprint V5 Optimal이 변경되었습니다.\u003c/li\u003e\n\u003cli\u003eRedmi Note 10 Pro의 두 번째 공간에서 Fingerprint V5 Optimal이 변경되었습니다.\u003c/li\u003e\n\u003cli\u003eOnePlus 8T의 병렬 공간에서 미디어 DRM이 변경되었습니다.\u003c/li\u003e\n\u003cli\u003eOnePlus 8T의 작업 프로필 및 게스트 사용자에서 Fingerprint V5 Optimal이 변경되었습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e다른:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e에뮬레이터에서 FingerprintV3 Optimal이 Fingerprint V5 Optimal보다 성능이 더 좋았습니다.\u003c/li\u003e\n\u003cli\u003eEmulator 1과 Emulator 2에서 MediaDRM이 다르게 동작했는데 둘 다 동일한 Windows 기계에서 실행되었습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이러한 관찰을 바탕으로 Fingerprint V3과 V5 Optimal은 MediaDRM과 비교했을 때 많은 다중 인스턴스 사기 시나리오에서 실패했습니다. 이러한 테스트에서 우리는 MediaDRM이 더 나은 것으로 결론지었습니다.\u003c/p\u003e\n\u003ch1\u003e원시 데이터 분석\u003c/h1\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e결과를 양적으로 파악하기 위해 우리는 데이터를 살펴보고 해당 ID들의 행동을 평가하여 데이터를 기반으로 가장 적합한 ID를 찾아냈습니다. 사용자 기반의 기기와 비교하여 우리의 데이터가 왜곡되어 있고 대표적이지 않을 수 있다는 점을 기억해 주세요.\u003c/p\u003e\n\u003ch2\u003e2주간의 데이터 수집\u003c/h2\u003e\n\u003cp\u003e우리는 2주 동안 freeRASP 데이터를 수집하여 분석했습니다. 이 기간이 비교적 짧기 때문에 다시 설치하는 경우가 많지 않다고 가정합니다. 다시 한 번 강조하지만, 특정 응용프로그램의 카테고리/사용 사례에 따라 실제 재설치 비율이 달라질 수 있으므로 이 창을 선택하는 데 실제 재설치 비율에 대한 연구가 없다는 점을 유의해 주세요.\u003c/p\u003e\n\u003cp\u003e아래에서 각 ID의 고유 값 수와 이 데이터에서 캡처된 고유 디바이스 모델 수를 확인할 수 있습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eAndroidID: 13 402 601\u003c/p\u003e\n\u003cp\u003eFingerprintV3: 22 525 265\u003c/p\u003e\n\u003cp\u003eMediaDRM: 13 285 081\u003c/p\u003e\n\u003cp\u003eInstanceId: 13 740 706\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e다양한 기기 모델: 14,175 (예: Pixel 4, SM-G973N, ONEPLUS A5000, LG-H930, ...)\u003c/p\u003e\n\u003cp\u003e처음에 봤을 때 다른 ID들의 수보다 훨씬 높은 FingerprintV3의 수를 알아차렸어요. 이것은 사용자가 32가지 관측된 지문 신호 중 일부를 변경할 때마다 변하는 FingerprintV3의 행동에 의한 것일 수 있어요.\u003c/p\u003e\n\u003ch2\u003eID들은 어떻게 관련이 있을까요?\u003c/h2\u003e\n\u003cp\u003e그 후, 우리는 ID들 간의 동시 발생을 살펴보았습니다. 이를 통해 그들 간의 관련성을 파악해 보았어요.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e아래 테이블을 읽는 방법입니다. 하나의 AndroidID에는 1.00557개의 고유한 MediaDRM이 있으며, 고유한 AndroidID 중 0.54%가 하나 이상의 MediaDRM을 가지고 있습니다.\u003c/p\u003e\n\u003ch2\u003eID 충돌: 같은 ID지만 다른 기기\u003c/h2\u003e\n\u003cp\u003e데이터에 따르면, 우리는 여전히 \"최적\" 식별자를 찾고 있기 때문에 \"다른 기기\"가 무엇인지 말할 수 없습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e아이디 당 평균 모델 수를 살펴봐요. ID마다 모델이 하나만 있는 것이 이상적입니다 — 서로 다른 디바이스에 동일한 ID가 있는 충돌이 최소화되기를 바랍니다. 아래 표를 빠르게 살펴보면 진정한 불일치가 있음을 알 수 있어요.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-Fraud-ProofinganAndroidAppChoosingtheBestDeviceIDforPromoAbusePrevention_5.png\" alt=\"표\"\u003e\u003c/p\u003e\n\u003ch2\u003e결과\u003c/h2\u003e\n\u003cp\u003e데이터 분석 결과, 다음과 같이 진술할 수 있어요:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003eFingerprintV3는 다른 ID들에 비해 값이 너무 많아서 우리 시나리오에서는 덜 유용합니다.\u003c/li\u003e\n\u003cli\u003e하나의 AndroidID/MediaDRM/InstanceID에는 보통 여러 개의 FingerprintV3가 있습니다.\u003c/li\u003e\n\u003cli\u003eAndroidId와 MediaDRM은 대략 1:1 관계이며, 일부 MediaDRM 인스턴스에는 AndroidID보다 더 많은 AndroidID (AndroidId보다 더 많은 MediaDRM을 가지고 있는 경우도 있습니다).\u003c/li\u003e\n\u003cli\u003e경우에 따라 하나의 AndroidID에는 여러 개의 InstanceID (MediaDRM보다 더 자주 발생), MediaDRM과 InstanceID 사이의 관계와 유사합니다.\u003c/li\u003e\n\u003cli\u003eInstanceID는 MediaDRM보다 AndroidID와 더 밀접한 관계에 있습니다.\u003c/li\u003e\n\u003cli\u003eAndroidID는 하나의 모델만 가지고 있습니다 (이상치의 양은 극히 적음).\u003c/li\u003e\n\u003cli\u003eMediaDRM은 일반적으로 하나의 모델을 가지나, 몇 가지 충돌이 있을 수 있습니다 (AndroidID의 경우보다 더 많음).\u003c/li\u003e\n\u003cli\u003eInstanceId는 이 두 모델 사이 어딘가에 위치합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e총평으로, 이러한 식별자 중에서 AndroidID가 가장 우수해 보이며, MediaDRM이 그 뒤를 이어갑니다. InstanceId도 유용할 수 있지만 AndroidID만큼은 아닙니다. FingerprintV3은 우리 시나리오에서는 쓸모 없습니다. AndroidID는 다시 설치 후 변경되고 상대적으로 쉽게 위조될 수 있기 때문에 사기 탐지에는 MediaDRM이 가장 적합해 보입니다.\u003c/p\u003e\n\u003cp\u003e다만, MediaDRM은 충돌이 꽤 많이 발생하는 것 같습니다 (모델 분석을 기반으로 확인한 결과). 같은 제조업체의 기기끼리(즉, 동일 제조업체의 기기일수록 다른 제조업체의 기기보다 더 같은 MediaDRM을 가질 가능성이 훨씬 높음) 충돌이 가장 자주 발생하는 것으로 밝혀졌습니다. 여기에 전반적인 개요를 제공해 드리겠습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eMediaDRM 중 0.005%가 여러 제조업체를 가지고 있음\u003c/li\u003e\n\u003cli\u003eMediaDRM 중 0.55%가 같은 제조업체의 여러 모델을 가지고 있음\u003c/li\u003e\n\u003cli\u003e한 MediaDRM 당 평균 제조업체 수: 1.000085\u003c/li\u003e\n\u003cli\u003e한 제조업체 당 MediaDRM의 평균 모델 수: 1.006362\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003eMediaDRM를 개선할 수 있을까요?\u003c/h2\u003e\n\u003cp\u003e우리는 많은 시도(자세히 설명하지는 않겠습니다) 끝에 MediaDRM+모델의 조합을 잠재적 ID로 실험해 보았습니다.\u003c/p\u003e\n\u003cp\u003e구글 Pixel 4의 MediaDRM+모델의 결합 예시: e3af1aa4dacb6b6637846488b511e7643c6ac20b65c95baad164b122ecb036b6+Pixel 4\u003c/p\u003e\n\u003cp\u003e아래는 위와 동일한 공현 테이블이며, 이제 MediaDRM+모델과의 관계를 포함하고 있습니다:\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-Fraud-ProofinganAndroidAppChoosingtheBestDeviceIDforPromoAbusePrevention_6.png\" alt=\"Image\"\u003e\u003c/p\u003e\n\u003cp\u003e우리는 MediaDRM+ 모델이 원래의 MediaDRM보다 더 나은 성능을 보여준다는 것을 확인할 수 있습니다. 각 MediaDRM+ 모델에는 연관된 다른 ID의 수가 더 적습니다. 이는 몇 가지 충돌을 피했다는 것을 의미합니다 (정확한 숫자를 측정하기는 어렵지만, 최소한의 경계는 MediaDRM과 MediaDRM+ 모델의 숫자로 추정됩니다).\u003c/p\u003e\n\u003cp\u003e두 가지 특성의 조합으로 ID를 만들 때, 한 기기가 더 많은 ID를 가지는 문제가 발생할 수 있습니다. 그러나 MediaDRM+ 모델에서는 이런 경우가 발생하지 않아야 합니다. 한 기기에는 하나의 모델만 연결되어야 하기 때문에 (즉, 구글 픽셀 4 전화기의 물리적 단위는 항상 \"Pixel 4\" 모델 이름만을 가져야 함).\u003c/p\u003e\n\u003cp\u003e그러므로 데이터를 기반으로, 사기 탐지 사례를 검토할 때 MediaDRM과 기기 모델의 간단한 조합을 ID로 사용하는 것을 제안합니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e요약\u003c/h1\u003e\n\u003cp\u003e저희는 모바일 기기 식별에 대한 도전에 직면하고 있습니다 — 사용자 개인 정보를 침해하지 않고 사기꾼 기기를 차단하는 방법에 대해 고민하고 있습니다. 모바일 앱 소유자들은 사용자들이 결제를 회피하거나 보너스를 악용하는 문제에 직면하고 있는데, 이는 여러 번 앱을 재설치함으로써 이루어지는 다중 인스턴스화로 인한 문제입니다. 신뢰할 수 없는 기기 ID로 인해 꾸준한 악의적인 사용자를 식별하는 것이 어려워지고 있습니다. 저희의 연구 결과는 효과적인 차단을 위해 미디어 DRM을 기기 지문보다 우선시하는 것을 권장하며 (또는 더 나아가 미디어 DRM과 기기 모델 조합을 권장합니다). 또한 AppiCrypt, RASP 및 KYC 솔루션과 같은 추가적인 보안층으로 보호 강화를 잊지 마세요. 모든 시나리오는 유니크합니다. 맞춤형 조언이 필요하시면 \u003ca href=\"mailto:info@talsec.app\"\u003einfo@talsec.app\u003c/a\u003e 으로 Talsec 보안 전문가에게 문의하세요.\u003c/p\u003e\n\u003cp\u003e저자: Dáša Pawlasová, Matúš Šikyňa, Tomáš Soukal\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-22-Fraud-ProofinganAndroidAppChoosingtheBestDeviceIDforPromoAbusePrevention"},"buildId":"T_Nz0g9U1yttYMSEma95P","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>