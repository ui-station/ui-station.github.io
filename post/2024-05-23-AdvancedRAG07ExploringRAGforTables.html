<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>고급 RAG 07 테이블을 위한 RAG 탐색 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-05-23-AdvancedRAG07ExploringRAGforTables" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="고급 RAG 07 테이블을 위한 RAG 탐색 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="고급 RAG 07 테이블을 위한 RAG 탐색 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-23-AdvancedRAG07ExploringRAGforTables_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-05-23-AdvancedRAG07ExploringRAGforTables" data-gatsby-head="true"/><meta name="twitter:title" content="고급 RAG 07 테이블을 위한 RAG 탐색 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-23-AdvancedRAG07ExploringRAGforTables_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-23 18:13" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-V5DKFTZ6BX"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-V5DKFTZ6BX');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/cd012fc8787133d0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cd012fc8787133d0.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/551-3069cf29fe274aab.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-561ae49ab5aab7f5.js" defer=""></script><script src="/_next/static/PgdIX9e0tvkvkdAmDT6qR/_buildManifest.js" defer=""></script><script src="/_next/static/PgdIX9e0tvkvkdAmDT6qR/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">고급 RAG 07 테이블을 위한 RAG 탐색</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="고급 RAG 07 테이블을 위한 RAG 탐색" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 23, 2024</span><span class="posts_reading_time__f7YPP">19<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-23-AdvancedRAG07ExploringRAGforTables&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><p>RAG를 구현하는 것은 도전적인 과제를 제공하는데, 특히 비구조화된 문서의 테이블을 효과적으로 구문 분석하고 이해하는 부분이 그 중요한 부분입니다. 특히 스캔된 문서나 이미지 형식의 문서에서는 이 작업이 특히 어려울 수 있습니다. 이러한 도전 과제에는 적어도 다음 세 가지 측면이 있습니다:</p>
<ul>
<li>스캔된 문서 또는 이미지 문서의 복잡성, 다양한 구조, 비텍스트 요소의 포함 및 필기 및 인쇄된 내용의 결합과 같은 특징들은 테이블 정보를 정확하게 자동 추출하는 데 도전을 제공합니다. 부정확한 구문 분석은 테이블 구조를 손상시킬 수 있으며, 불완전한 테이블을 포함하는 것은 테이블의 의미 정보를 포착하지 못할 뿐만 아니라 RAG 결과를 손상시킬 수 있습니다.</li>
<li>테이블 캡션을 추출하고 해당 테이블에 효과적으로 연결하는 방법.</li>
<li>테이블의 의미 정보를 효과적으로 저장하기 위한 색인 구조를 설계하는 방법.</li>
</ul>
<p>이 기사는 RAG 내에서 테이블을 관리하는 주요 기술을 소개한 후 일부 기존 오픈 소스 솔루션을 검토한 다음 새로운 솔루션을 제안하고 구현하는 방법을 제시합니다.</p>
<h1>주요 기술</h1>
<div class="content-ad"></div>
<h2>테이블 구문 분석</h2>
<p>이 모듈의 주요 기능은 정형화되지 않은 문서나 이미지에서 테이블 구조를 정확하게 추출하는 것입니다.</p>
<p>추가 기능: 해당하는 테이블 캡션을 추출하고, 개발자가 해당 테이블 캡션을 테이블과 관련 짓기 편리하도록 하는 것이 가장 좋습니다.</p>
<p>제 현재 이해에 따르면, Figure 1에 나타난 것처럼 여러 가지 방법이 있습니다:</p>
<div class="content-ad"></div>
<p><img src="/assets/img/2024-05-23-AdvancedRAG07ExploringRAGforTables_0.png" alt="이미지"/></p>
<p>(a). 다중 모달 LLM(예: GPT-4V)을 활용하여 각 PDF 페이지에서 표를 식별하고 정보를 추출합니다.</p>
<ul>
<li>입력: 이미지 형식의 PDF 페이지</li>
<li>출력: JSON 또는 다른 형식의 표. 다중 모달 LLM이 표 데이터를 추출하지 못하는 경우 이미지를 요약하고 요약본을 반환해야 합니다.</li>
</ul>
<p>(b). Table Transformer와 같은 전문적인 표 감지 모델을 활용하여 표 구조를 식별합니다.</p>
<div class="content-ad"></div>
<ul>
<li>입력: 이미지로 된 PDF 페이지</li>
<li>출력: 이미지로 된 테이블</li>
</ul>
<p>(c). 오픈 소스 프레임워크인 unstructured 등을 사용하여 객체 검출 모델을 활용하세요(unstructured의 테이블 검출 과정은 이 기사에 자세히 기재되어 있습니다). 이러한 프레임워크를 사용하면 전체 문서의 철저한 구문 분석과 구문 분석 결과로부터 테이블 관련 콘텐츠의 추출이 가능합니다.</p>
<ul>
<li>입력: PDF 또는 이미지 형식의 문서</li>
<li>출력: 문서 전체의 구문 분석 결과로부터 얻은 테이블을 일반 텍스트 또는 HTML 형식으로</li>
</ul>
<p>(d). Nougat, Donut 등의 end-to-end 모델을 사용하여 전체 문서를 구문 분석하고 테이블 관련 콘텐츠를 추출하세요. 이 접근 방식은 OCR 모델을 필요로하지 않습니다.</p>
<div class="content-ad"></div>
<ul>
<li>입력: PDF 또는 이미지 형식의 문서</li>
<li>출력: 전체 문서의 구문 분석 결과를 통해 얻은 LaTeX 또는 JSON 형식의 표</li>
</ul>
<p>언급할 가치가 있는 것은 표 정보를 추출하는 방법에 관계없이 표 캡션을 포함해야 합니다. 대부분의 경우 표 캡션은 문서나 논문 작성자가 표에 대해 간단히 설명한 것으로, 전체 표를 크게 요약할 수 있습니다.</p>
<p>위에서 언급한 네 가지 방법 중 (d) 방법은 표 캡션을 쉽게 검색할 수 있습니다. 개발자에게는 이 방법이 유용한데, 표 캡션을 표와 연관시킬 수 있도록 해주기 때문입니다. 이 내용은 다음 실험에서 자세히 설명될 것입니다.</p>
<h2>색인 구조</h2>
<div class="content-ad"></div>
<p>색인 구조에 따라 해결책은 대략 다음 카테고리로 나뉩니다:</p>
<p>(e). 이미지 형식의 색인 표만 있는 경우.</p>
<p>(f). 일반 텍스트 또는 JSON 형식의 색인 표만 있는 경우.</p>
<p>(g). LaTeX 형식의 색인 표만 있는 경우.</p>
<div class="content-ad"></div>
<h3>(h). 테이블 요약만 색인화합니다.</h3>
<h3>(i). 작은 부터 큰 또는 문서 요약 색인 구조, Figure 2에 나와 있는 것처럼.</h3>
<ul>
<li>작은 청크의 내용은 테이블의 각 행 정보 또는 테이블 요약일 수 있습니다.</li>
<li>큰 청크의 내용은 이미지 형식, 일반 텍스트 형식 또는 LaTeX 형식의 테이블일 수 있습니다.</li>
</ul>
<p><img src="/assets/img/2024-05-23-AdvancedRAG07ExploringRAGforTables_1.png" alt="Figure 2"/></p>
<div class="content-ad"></div>
<p>위에서 논의한 대로 Table summary는 일반적으로 LLM을 사용하여 생성됩니다:</p>
<ul>
<li>입력: 이미지 형식, 텍스트 형식 또는 LaTeX 형식의 테이블</li>
<li>출력: 테이블 요약</li>
</ul>
<h2>Table Parsing, Indexing 또는 RAG가 필요하지 않은 algorithms</h2>
<p>일부 알고리즘은 테이블 파싱이 필요하지 않습니다.</p>
<div class="content-ad"></div>
<p>(j). 관련 이미지(PDF 페이지)와 사용자 쿼리를 VQA 모델(예: DAN 등)이나 멀티모달 LLM에 보내고 답변을 받습니다.</p>
<ul>
<li>색인할 내용: 이미지 형식의 문서</li>
<li>VQA 모델이나 멀티모달 LLM에 전송되는 내용: 쿼리 + 해당 이미지 페이지</li>
</ul>
<p>(k). 관련 텍스트 형식의 PDF 페이지와 사용자 쿼리를 LLM에 보내고, 그런 다음 답변을 받습니다.</p>
<ul>
<li>색인할 내용: 텍스트 형식의 문서</li>
<li>LLM에 전송되는 내용: 쿼리 + 해당 텍스트 형식의 페이지</li>
</ul>
<div class="content-ad"></div>
<p>(l) 사용자의 쿼리와 관련 이미지(PDF 페이지), 텍스트 청크를 다중 모달 LLM(예: GPT-4V 등)에 보내고 답변을 직접 반환합니다.</p>
<ul>
<li>색인할 콘텐츠: 이미지 형식의 문서 및 텍스트 형식의 문서 청크</li>
<li>다중 모달 LLM에 보내는 콘텐츠: 쿼리 + 문서의 이미지 형식 + 해당하는 텍스트 청크</li>
</ul>
<p>또한, 다음은 색인이 필요하지 않은 몇 가지 방법입니다. 그림 3과 그림 4에서 보듯이:</p>
<p><img src="/assets/img/2024-05-23-AdvancedRAG07ExploringRAGforTables_2.png" alt="image"/></p>
<div class="content-ad"></div>
<p>(m). 먼저, 문서의 모든 표를 이미지 형태로 변환하기 위해 (a)부터 (d) 범주 중 하나의 방법을 적용하세요. 그런 다음 모든 표 이미지와 사용자 질의를 멀티모달 LLM(예: GPT-4V 등)에 직접 전송하여 답변을 받아보세요.</p>
<ul>
<li>색인할 내용: 없음</li>
<li>멀티모달 LLM에 전송될 내용: 질의 + 모든 변환된 표(이미지 형태)</li>
</ul>
<p><img src="/assets/img/2024-05-23-AdvancedRAG07ExploringRAGforTables_3.png" alt="표 이미지"/></p>
<p>(n). (m)에서 추출된 이미지 형식의 표를 사용하여 OCR 모델을 이용해 표 안의 모든 텍스트를 인식한 후, 표 안의 모든 텍스트와 사용자 질의를 LLM에 직접 전송하여 답변을 받아보세요.</p>
<div class="content-ad"></div>
<ul>
<li>색인할 콘텐츠: 없음</li>
<li>LLM에 보내지는 콘텐츠: 사용자 쿼리 + 모든 테이블 내용(텍스트 형식)</li>
</ul>
<p>익명의 사실을 공유하자면, 일부 방법은 RAG 프로세스에 의존하지 않습니다:</p>
<ul>
<li>첫 번째 방법은 LLM을 사용하지 않으며, 특정 데이터세트에서 학습하며 모델(예: BERT와 유사한 트랜스포머)이 TAPAS와 같은 테이블 이해 작업을 더 잘 지원하도록 합니다.</li>
<li>두 번째 방법은 LLM을 사용하며, 사전 학습, 파인 튜닝 방법 또는 프롬프트를 사용하여 LLM이 GPT4Table과 같은 테이블 이해 작업을 수행할 수 있도록 합니다.</li>
</ul>
<h1>기존 오픈 소스 솔루션</h1>
<div class="content-ad"></div>
<p>이전 섹션에서는 RAG의 테이블에 대한 주요 기술을 요약하고 분류했습니다. 이 글이 구현하는 해결책을 제안하기 전에 오픈 소스 솔루션 중 일부를 탐색해보겠습니다.</p>
<p>LlamaIndex는 네 가지 방법을 제안했는데, 처음 세 가지는 다중 모달 모델을 사용합니다.</p>
<ul>
<li>관련 이미지(PDF 페이지)를 검색하여 이를 GPT-4V에 보내 쿼리에 대답하도록 합니다.</li>
<li>각 PDF 페이지를 이미지로 간주하고, 각 페이지에 대해 이미지 추론을 수행하도록 GPT-4V에게 맡깁니다. 이미지 추론을 위한 텍스트 벡터 저장소 인덱스를 작성합니다. 이미지 추론 벡터 저장소에 대한 답변을 쿼리로 가져옵니다.</li>
<li>테이블 트랜스포머를 사용하여 검색된 이미지에서 테이블 정보를 잘라내고, 이러한 잘린 이미지를 GPT-4V에 보내 쿼리 응답을 받습니다.</li>
<li>잘려진 테이블 이미지에 OCR을 적용하고 데이터를 GPT4/GPT-3.5로 보내어 쿼리에 답변을 받습니다.</li>
</ul>
<p>이 글의 분류에 따르면:</p>
<div class="content-ad"></div>
<ul>
<li>이 기사에서의 (j) 항목과 유사한 첫 번째 방법은 테이블 구문 분석이 필요하지 않습니다. 그러나 결과는 이미지에 정답이 있더라도 올바른 답을 내놓지 못하는 것을 보여줍니다.</li>
<li>두 번째 방법은 테이블 구문 분석을 포함하며 (a) 항목과 일치합니다. 색인된 콘텐츠는 GPT-4V의 결과에 따라 테이블 콘텐츠 또는 요약이며, 이는 (f) 또는 (h)에 해당할 수 있습니다. 이 방법의 단점은 GPT-4V가 이미지에서 테이블을 식별하고 내용을 추출하는 능력이 불안정하다는 것이며, PDF 형식에서 발생하는 테이블, 텍스트 및 다른 이미지가 혼합된 경우에 특히 해당됩니다.</li>
<li>세 번째 방법은 (m) 항목과 유사하며 색인이 필요하지 않습니다.</li>
<li>네 번째 방법은 (n) 항목과 유사하며 또한 색인이 필요하지 않습니다. 결과는 이미지에서 테이블 정보를 추출하는 능력이 없어 잘못된 답변이 생성된다고 나타냅니다.</li>
</ul>
<p>테스트 결과, 세 번째 방법이 전반적으로 가장 효과적인 것으로 나타났습니다. 그러나 제 테스트에 따르면 세 번째 방법은 테이블을 감지하는 데 어려움을 겪고, 특히 테이블 제목을 올바르게 병합하는 것조차 어렵다는 것을 보여줍니다.</p>
<p>Langchain은 일부 솔루션을 제안했습니다. Semi-structured RAG의 주요 기술은 다음과 같습니다:</p>
<ul>
<li>테이블 구문 분석은 비구조적을 사용하며, 이는 (c) 항목에 해당합니다.</li>
<li>색인 방법은 문서 요약 색인이며, 이는 (i) 항목에 해당합니다. 작은 청크 콘텐츠: 테이블 요약, 큰 청크 콘텐츠: 원시 테이블 콘텐츠(텍스트 형식).</li>
</ul>
<div class="content-ad"></div>
<p>아래 그림 5에 나타난 대로:</p>
<p><img src="/assets/img/2024-05-23-AdvancedRAG07ExploringRAGforTables_4.png" alt="Figure 5"/></p>
<p>반구조화 및 멀티 모달 RAG는 세 가지 해결책을 제안하며, 아키텍처는 아래 그림 6에 나와 있습니다.</p>
<p><img src="/assets/img/2024-05-23-AdvancedRAG07ExploringRAGforTables_5.png" alt="Figure 6"/></p>
<div class="content-ad"></div>
<p>옵션 1은 이 기사의 (l) 범주와 유사합니다. 멀티모달 임베딩(예: CLIP)을 사용하여 이미지와 텍스트를 임베드하고 유사성 검색을 통해 둘 다 검색하며, 생 이미지 및 청크를 멀티모달 LLM에게 전달하여 답변 합성을 수행합니다.</p>
<p>옵션 2은 이미지로부터 텍스트 요약을 생성하는 멀티모달 LLM(예: GPT-4V, LLaVA, 또는 FUYU-8b)을 활용합니다. 그런 다음 텍스트를 임베드하고 검색하여 텍스트 청크를 LLM에게 전달하여 답변 합성을 합니다.</p>
<ul>
<li>테이블 파싱은 구조화되지 않은 것을 사용합니다. 이는 범주 (d)입니다.</li>
<li>색인 구조는 문서 요약 인덱스(범주 (i))이며, 작은 청크 내용: 테이블 요약, 큰 청크 내용: 텍스트 형식의 테이블</li>
</ul>
<p>옵션 3은 이미지로부터 텍스트 요약을 생성하기 위해 멀티모달 LLM(예: GPT-4V, LLaVA, 또는 FUYU-8b)를 사용합니다. 그런 다음 이미지 요약을 임베드하고 검색하여 원본 이미지에 대한 이미지 요약과 함께 반환하고, 원본 이미지 및 텍스트 청크를 멀티모달 LLM에게 전달하여 답변 합성을 수행합니다.</p>
<div class="content-ad"></div>
<h1>제안된 솔루션</h1>
<p>이 글은 주요 기술 및 기존 솔루션을 요약, 분류 및 논의하였습니다. 이를 기반으로 다음과 같은 솔루션을 제안합니다. 간단히 말해서 Re-ranking 및 query rewriting과 같은 RAG 모듈은 생략되었습니다.</p>
<p><img src="/assets/img/2024-05-23-AdvancedRAG07ExploringRAGforTables_6.png" alt="Figure 7"/></p>
<ul>
<li>테이블 파싱: Nougat(catogery (d))를 사용합니다. 제 테스트에 따르면, 이는 테이블 감지가 unstructured(catogery (c))보다 더 효과적입니다. 게다가 Nougat은 테이블 캡션을 잘 추출하여 테이블과 연결하는 데 매우 편리합니다.</li>
<li>문서 요약 인덱스 구조(catogery (i)): 작은 청크의 내용에는 테이블 요약이, 큰 청크의 내용에는 LaTeX 형식의 해당 테이블과 텍스트 형식의 테이블 캡션이 포함됩니다. 이를 다중 벡터 검색기를 사용하여 구현합니다.</li>
<li>테이블 요약 획득 방법: 테이블과 테이블 캡션을 LLM에 보내 요약을 받습니다.</li>
</ul>
<div class="content-ad"></div>
<p>이 방법의 장점은 테이블을 효율적으로 구문 분석하면서 테이블 요약과 테이블 간의 관계를 포괄적으로 고려한다는 것입니다. 또한, 멀티모달 LLM이 필요하지 않아 비용을 절감할 수 있습니다.</p>
<h2>Nougat의 원칙</h2>
<p>Nougat은 도넛 아키텍처를 바탕으로 개발되었습니다. Figure 8에서 보여지듯이 OCR 관련 입력이나 모듈이 필요하지 않고 네트워크를 통해 텍스트를 인식합니다.</p>
<p><img src="/assets/img/2024-05-23-AdvancedRAG07ExploringRAGforTables_7.png" alt="Nougat Principle"/></p>
<div class="content-ad"></div>
<p>누가(Nougat)가 수식을 분석하는 능력이 인상적이에요. 테이블 분석에도 능숙해요. 더불어, 테이블 캡션을 연결하여 보여줄 수 있어 편하지요. 그림 9에서 보여졌듯이요:</p>
<p><img src="/assets/img/2024-05-23-AdvancedRAG07ExploringRAGforTables_8.png" alt="Figure 9"/></p>
<p>수많은 논문을 테스트한 결과, 테이블 캡션이 항상 테이블 다음 줄에 고정되어 있는 것을 발견했어요. 이 일관성은 우연이 아님을 시사하며, 그래서 누가(Nougat)가 이 효과를 달성하는 방법에 관심이 있어요.</p>
<p>중간 결과가 없는 엔드 투 엔드 모델이므로, 훈련 데이터에 많이 의존할 것으로 예상됩니다.</p>
<div class="content-ad"></div>
<p>테이블 태그를 Markdown 형식으로 변경하세요.</p>
<div class="content-ad"></div>
<ul>
<li>누가(Nougat)는 이전 파싱 도구에서 어려웠던 부분인 수식 및 표와 같은 부분을 정확하게 LaTeX 소스 코드로 파싱할 수 있습니다.</li>
<li>누가(Nougat)의 파싱 결과는 마크다운과 유사한 반구조화된 문서입니다.</li>
<li>쉽게 표 제목을 얻고 해당 표와 편리하게 연결할 수 있습니다.</li>
</ul>
<p>단점:</p>
<ul>
<li>누가(Nougat)의 파싱 속도가 느리기 때문에 대규모 배포에 도전이 될 수 있습니다.</li>
<li>누가(Nougat)는 과학 논문을 기반으로 학습되었기 때문에 비슷한 구조의 문서에서 뛰어난 성능을 발휘합니다. 그러나 비라틴 문자 텍스트 문서에서는 성능이 떨어집니다.</li>
<li>누가(Nougat) 모델은 한 번에 한 페이지의 과학 논문만을 학습하며, 다른 페이지에 대한 지식이 부족합니다. 이로 인해 파싱된 콘텐츠에 일관성이 없을 수 있습니다. 따라서, 인식 효과가 좋지 않다면 PDF를 개별 페이지로 나누고 하나씩 파싱하는 것을 고려해야 합니다.</li>
<li>이중 칼럼 논문에서의 표 파싱은 단일 칼럼 논문과 같이 효과적이지 않을 수 있습니다.</li>
</ul>
<h2>코드 구현</h2>
<div class="content-ad"></div>
<p>먼저 관련 Python 패키지를 설치해주세요.</p>
<pre><code class="hljs language-js">pip install langchain
pip install chromadb
pip install nougat-ocr
</code></pre>
<p>설치를 완료한 후, Python 패키지의 버전을 확인할 수 있습니다.</p>
<pre><code class="hljs language-js">langchain                                <span class="hljs-number">0.1</span><span class="hljs-number">.12</span>
langchain-community                      <span class="hljs-number">0.0</span><span class="hljs-number">.28</span>
langchain-core                           <span class="hljs-number">0.1</span><span class="hljs-number">.31</span>
langchain-openai                         <span class="hljs-number">0.0</span><span class="hljs-number">.8</span>
langchain-text-splitters                 <span class="hljs-number">0.0</span><span class="hljs-number">.1</span>

chroma-hnswlib                           <span class="hljs-number">0.7</span><span class="hljs-number">.3</span>
chromadb                                 <span class="hljs-number">0.4</span><span class="hljs-number">.24</span>

nougat-ocr                               <span class="hljs-number">0.1</span><span class="hljs-number">.17</span>
</code></pre>
<div class="content-ad"></div>
<p>환경을 설정하고 라이브러리를 가져와주세요:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> os
os.<span class="hljs-property">environ</span>[<span class="hljs-string">&quot;OPENAI_API_KEY&quot;</span>] = <span class="hljs-string">&quot;YOUR_OPEN_AI_KEY&quot;</span>

<span class="hljs-keyword">import</span> subprocess
<span class="hljs-keyword">import</span> uuid

<span class="hljs-keyword">from</span> langchain_core.<span class="hljs-property">output_parsers</span> <span class="hljs-keyword">import</span> <span class="hljs-title class_">StrOutputParser</span>
<span class="hljs-keyword">from</span> langchain_core.<span class="hljs-property">prompts</span> <span class="hljs-keyword">import</span> <span class="hljs-title class_">ChatPromptTemplate</span>
<span class="hljs-keyword">from</span> langchain_openai <span class="hljs-keyword">import</span> <span class="hljs-title class_">ChatOpenAI</span>
<span class="hljs-keyword">from</span> langchain.<span class="hljs-property">retrievers</span>.<span class="hljs-property">multi_vector</span> <span class="hljs-keyword">import</span> <span class="hljs-title class_">MultiVectorRetriever</span>
<span class="hljs-keyword">from</span> langchain.<span class="hljs-property">storage</span> <span class="hljs-keyword">import</span> <span class="hljs-title class_">InMemoryStore</span>
<span class="hljs-keyword">from</span> langchain_community.<span class="hljs-property">vectorstores</span> <span class="hljs-keyword">import</span> <span class="hljs-title class_">Chroma</span>
<span class="hljs-keyword">from</span> langchain_core.<span class="hljs-property">documents</span> <span class="hljs-keyword">import</span> <span class="hljs-title class_">Document</span>
<span class="hljs-keyword">from</span> langchain_openai <span class="hljs-keyword">import</span> <span class="hljs-title class_">OpenAIEmbeddings</span>
<span class="hljs-keyword">from</span> langchain_core.<span class="hljs-property">runnables</span> <span class="hljs-keyword">import</span> <span class="hljs-title class_">RunnablePassthrough</span>
</code></pre>
<p>Attention Is All You Need 논문을 YOUR_PDF_PATH로 다운로드하고, nougat을 실행하여 PDF 파일을 구문 분석하고 해당 결과로부터 LaTex 형식의 표 및 텍스트 형식의 표 캡션을 얻어주세요. 첫 실행 시 필요한 모델 파일이 다운로드됩니다.</p>
<pre><code class="hljs language-js">def <span class="hljs-title function_">june_run_nougat</span>(file_path, output_dir):
    # nougat을 실행하고 결과를 <span class="hljs-title class_">Mathpix</span> <span class="hljs-title class_">Markdown</span>으로 저장합니다.
    cmd = [<span class="hljs-string">&quot;nougat&quot;</span>, file_path, <span class="hljs-string">&quot;-o&quot;</span>, output_dir, <span class="hljs-string">&quot;-m&quot;</span>, <span class="hljs-string">&quot;0.1.0-base&quot;</span>, <span class="hljs-string">&quot;--no-skipping&quot;</span>]
    res = subprocess.<span class="hljs-title function_">run</span>(cmd)
    <span class="hljs-keyword">if</span> res.<span class="hljs-property">returncode</span> != <span class="hljs-number">0</span>:
        <span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;nougat 실행 중 오류가 발생했습니다.&quot;</span>)
        <span class="hljs-keyword">return</span> res.<span class="hljs-property">returncode</span>
    <span class="hljs-attr">else</span>:
        <span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;작업 완료!&quot;</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>

def <span class="hljs-title function_">june_get_tables_from_mmd</span>(mmd_path):
    f = <span class="hljs-title function_">open</span>(mmd_path)
    lines = f.<span class="hljs-title function_">readlines</span>()
    res = []
    tmp = []
    flag = <span class="hljs-string">&quot;&quot;</span>
    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> <span class="hljs-attr">lines</span>:
        <span class="hljs-keyword">if</span> line == <span class="hljs-string">&quot;\\begin{table}\n&quot;</span>:
            flag = <span class="hljs-string">&quot;BEGINTABLE&quot;</span>
        elif line == <span class="hljs-string">&quot;\\end{table}\n&quot;</span>:
            flag = <span class="hljs-string">&quot;ENDTABLE&quot;</span>

        <span class="hljs-keyword">if</span> flag == <span class="hljs-string">&quot;BEGINTABLE&quot;</span>:
            tmp.<span class="hljs-title function_">append</span>(line)
        elif flag == <span class="hljs-string">&quot;ENDTABLE&quot;</span>:
            tmp.<span class="hljs-title function_">append</span>(line)
            flag = <span class="hljs-string">&quot;CAPTION&quot;</span>
        elif flag == <span class="hljs-string">&quot;CAPTION&quot;</span>:
            tmp.<span class="hljs-title function_">append</span>(line)
            flag = <span class="hljs-string">&quot;MARKDOWN&quot;</span>
            <span class="hljs-title function_">print</span>(<span class="hljs-string">&#x27;-&#x27;</span> * <span class="hljs-number">100</span>)
            <span class="hljs-title function_">print</span>(<span class="hljs-string">&#x27;&#x27;</span>.<span class="hljs-title function_">join</span>(tmp))
            res.<span class="hljs-title function_">append</span>(<span class="hljs-string">&#x27;&#x27;</span>.<span class="hljs-title function_">join</span>(tmp))
            tmp = []

    <span class="hljs-keyword">return</span> res

file_path = <span class="hljs-string">&quot;YOUR_PDF_PATH&quot;</span>
output_dir = <span class="hljs-string">&quot;YOUR_OUTPUT_DIR_PATH&quot;</span>

<span class="hljs-keyword">if</span> <span class="hljs-title function_">june_run_nougat</span>(file_path, output_dir) == <span class="hljs-number">1</span>:
    <span class="hljs-keyword">import</span> sys
    sys.<span class="hljs-title function_">exit</span>(<span class="hljs-number">1</span>)

mmd_path = output_dir + <span class="hljs-string">&#x27;/&#x27;</span> + os.<span class="hljs-property">path</span>.<span class="hljs-title function_">splitext</span>(file_path)[<span class="hljs-number">0</span>].<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;/&#x27;</span>)[-<span class="hljs-number">1</span>] + <span class="hljs-string">&quot;.mmd&quot;</span>
tables = <span class="hljs-title function_">june_get_tables_from_mmd</span>(mmd_path)
</code></pre>
<div class="content-ad"></div>
<p>함수 june_get_tables_from_mmd은 Figure 10에 표시된 mmd 파일에서 &#x27;table&#x27;부터 &#x27;table&#x27;까지의 모든 내용 및 &#x27;table&#x27; 다음 줄을 추출하는 데 사용됩니다.</p>
<p><img src="/assets/img/2024-05-23-AdvancedRAG07ExploringRAGforTables_9.png" alt="이미지"/></p>
<p>표 캡션을 표 아래에 배치해야 하거나 표가 &#x27;table&#x27;로 시작하고 &#x27;end&#x27;로 끝나야 한다는 것을 명시하는 공식 문서가 발견되지 않았다는 점을 유의하십시오. 따라서 june_get_tables_from_mmd는 휴리스틱입니다.</p>
<p>PDF에서 표를 구문 분석한 결과는 다음과 같습니다:</p>
<div class="content-ad"></div>
<p>표 1: 다양한 레이어 유형에 대한 최대 경로 길이, 레이어당 복잡성 및 최소 순차 작업 수가 표시됩니다.</p>
<p>표 2: Transformer가 영어-독일어 및 영어-프랑스어 newstest2014 테스트에서 이전 최신 모델보다 더 우수한 BLEU 점수를 달성하며 훈련 비용이 줄어드는 것을 보여줍니다.</p>
<p>표 3: Transformer 아키텍처의 변형이 나열되어 있으며, 기본 모델 정보와 영어-독일어 번역 개발 세트 newstest2013에서의 모든 메트릭스가 제공됩니다.</p>
<p>표 4: Transformer가 영어 구성 구문 분석에 잘 일반화되며, WSJ 23 섹션의 결과가 제시됩니다.</p>
<div class="content-ad"></div>
<img src="/assets/img/2024-05-23-AdvancedRAG07ExploringRAGforTables_10.png"/>
<p>다중 벡터 리트리버를 사용하여 문서 요약 색인 구조를 구축해보세요.</p>
<pre><code class="hljs language-js"># 자식 청크를 색인화하는 데 사용할 벡터스토어
vectorstore = <span class="hljs-title class_">Chroma</span>(collection_name = <span class="hljs-string">&quot;summaries&quot;</span>, embedding_function = <span class="hljs-title class_">OpenAIEmbeddings</span>())

# 상위 문서를 위한 저장소 레이어
store = <span class="hljs-title class_">InMemoryStore</span>()
id_key = <span class="hljs-string">&quot;doc_id&quot;</span>

# 리트리버 (시작할 때는 빈 상태)
retriever = <span class="hljs-title class_">MultiVectorRetriever</span>(
    vectorstore = vectorstore,
    docstore = store,
    id_key = id_key,
    search_kwargs={<span class="hljs-string">&quot;k&quot;</span>: <span class="hljs-number">1</span>} # 요청된 결과의 수가 색인 요소보다 큰 <span class="hljs-number">4</span>이므로, n_results = <span class="hljs-number">1</span>로 업데이트하겠습니다
)

# 테이블 추가
table_ids = [<span class="hljs-title function_">str</span>(uuid.<span class="hljs-title function_">uuid4</span>()) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> tables]
summary_tables = [
    <span class="hljs-title class_">Document</span>(page_content = s, metadata = {<span class="hljs-attr">id_key</span>: table_ids[i]})
    <span class="hljs-keyword">for</span> i, s <span class="hljs-keyword">in</span> <span class="hljs-title function_">enumerate</span>(table_summaries)
]
retriever.<span class="hljs-property">vectorstore</span>.<span class="hljs-title function_">add_documents</span>(summary_tables)
retriever.<span class="hljs-property">docstore</span>.<span class="hljs-title function_">mset</span>(<span class="hljs-title function_">list</span>(<span class="hljs-title function_">zip</span>(table_ids, tables)))
</code></pre>
<p>모든 준비가 되었습니다. 간단한 RAG 파이프라인을 구축하고 쿼리를 수행해보세요:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"># 프롬프트 템플릿
템플릿 = <span class="hljs-string">&quot;&quot;</span><span class="hljs-string">&quot;다음 콘텍스트를 기반으로 질문에 답하세요. 이는 텍스트와 테이블을 포함할 수 있으며 LaTeX 형식의 테이블과 일반 텍스트 형식의 테이블 캡션을 포함합니다:
{context}
질문: {question}
&quot;</span><span class="hljs-string">&quot;&quot;</span>
프롬프트 = <span class="hljs-title class_">ChatPromptTemplate</span>.<span class="hljs-title function_">from_template</span>(템플릿)

# <span class="hljs-variable constant_">LLM</span>
모델 = <span class="hljs-title class_">ChatOpenAI</span>(temperature = <span class="hljs-number">0</span>, model = <span class="hljs-string">&quot;gpt-3.5-turbo&quot;</span>)


# 간단한 <span class="hljs-variable constant_">RAG</span> 파이프라인
체인 = (
    {<span class="hljs-string">&quot;context&quot;</span>: retriever, <span class="hljs-string">&quot;question&quot;</span>: <span class="hljs-title class_">RunnablePassthrough</span>()}
    | 프롬프트
    | 모델
    | <span class="hljs-title class_">StrOutputParser</span>()
)


<span class="hljs-title function_">print</span>(체인.<span class="hljs-title function_">invoke</span>(<span class="hljs-string">&quot;when layer type is Self-Attention, what is the Complexity per Layer?&quot;</span>))  # 테이블 <span class="hljs-number">1</span>에 관한 쿼리

<span class="hljs-title function_">print</span>(체인.<span class="hljs-title function_">invoke</span>(<span class="hljs-string">&quot;Which parser performs worst for BLEU EN-DE&quot;</span>))  # 테이블 <span class="hljs-number">2</span>에 관한 쿼리

<span class="hljs-title function_">print</span>(체인.<span class="hljs-title function_">invoke</span>(<span class="hljs-string">&quot;Which parser performs best for WSJ 23 F1&quot;</span>))  # 테이블 <span class="hljs-number">4</span>에 관한 쿼리
</code></pre>
<p>아래는 실행 결과입니다. 여러 질문이 정확히 답변되었음을 보여주는데, 이는 도표 12에 나와 있습니다:</p>
<img src="/assets/img/2024-05-23-AdvancedRAG07ExploringRAGforTables_11.png"/>
<p>전체 코드는 아래와 같습니다:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-python"><span class="hljs-keyword">import</span> os
os.environ[<span class="hljs-string">&quot;OPENAI_API_KEY&quot;</span>] = <span class="hljs-string">&quot;YOUR_OPEN_AI_KEY&quot;</span>

<span class="hljs-keyword">import</span> subprocess
<span class="hljs-keyword">import</span> uuid

<span class="hljs-keyword">from</span> langchain_core.output_parsers <span class="hljs-keyword">import</span> StrOutputParser
<span class="hljs-keyword">from</span> langchain_core.prompts <span class="hljs-keyword">import</span> ChatPromptTemplate
<span class="hljs-keyword">from</span> langchain_openai <span class="hljs-keyword">import</span> ChatOpenAI
<span class="hljs-keyword">from</span> langchain.retrievers.multi_vector <span class="hljs-keyword">import</span> MultiVectorRetriever
<span class="hljs-keyword">from</span> langchain.storage <span class="hljs-keyword">import</span> InMemoryStore
<span class="hljs-keyword">from</span> langchain_community.vectorstores <span class="hljs-keyword">import</span> Chroma
<span class="hljs-keyword">from</span> langchain_core.documents <span class="hljs-keyword">import</span> Document
<span class="hljs-keyword">from</span> langchain_openai <span class="hljs-keyword">import</span> OpenAIEmbeddings
<span class="hljs-keyword">from</span> langchain_core.runnables <span class="hljs-keyword">import</span> RunnablePassthrough


<span class="hljs-keyword">def</span> <span class="hljs-title function_">june_run_nougat</span>(<span class="hljs-params">file_path, output_dir</span>):
    <span class="hljs-comment"># Run Nougat and store results as Mathpix Markdown</span>
    cmd = [<span class="hljs-string">&quot;nougat&quot;</span>, file_path, <span class="hljs-string">&quot;-o&quot;</span>, output_dir, <span class="hljs-string">&quot;-m&quot;</span>, <span class="hljs-string">&quot;0.1.0-base&quot;</span>, <span class="hljs-string">&quot;--no-skipping&quot;</span>]
    res = subprocess.run(cmd)
    <span class="hljs-keyword">if</span> res.returncode != <span class="hljs-number">0</span>:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Error when running nougat.&quot;</span>)
        <span class="hljs-keyword">return</span> res.returncode
    <span class="hljs-keyword">else</span>:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Operation Completed!&quot;</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">june_get_tables_from_mmd</span>(<span class="hljs-params">mmd_path</span>):
    f = <span class="hljs-built_in">open</span>(mmd_path)
    lines = f.readlines()
    res = []
    tmp = []
    flag = <span class="hljs-string">&quot;&quot;</span>
    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> lines:
        <span class="hljs-keyword">if</span> line == <span class="hljs-string">&quot;\\begin{table}\n&quot;</span>:
            flag = <span class="hljs-string">&quot;BEGINTABLE&quot;</span>
        <span class="hljs-keyword">elif</span> line == <span class="hljs-string">&quot;\\end{table}\n&quot;</span>:
            flag = <span class="hljs-string">&quot;ENDTABLE&quot;</span>

        <span class="hljs-keyword">if</span> flag == <span class="hljs-string">&quot;BEGINTABLE&quot;</span>:
            tmp.append(line)
        <span class="hljs-keyword">elif</span> flag == <span class="hljs-string">&quot;ENDTABLE&quot;</span>:
            tmp.append(line)
            flag = <span class="hljs-string">&quot;CAPTION&quot;</span>
        <span class="hljs-keyword">elif</span> flag == <span class="hljs-string">&quot;CAPTION&quot;</span>:
            tmp.append(line)
            flag = <span class="hljs-string">&quot;MARKDOWN&quot;</span>
            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;-&#x27;</span> * <span class="hljs-number">100</span>)
            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#x27;</span>.join(tmp))
            res.append(<span class="hljs-string">&#x27;&#x27;</span>.join(tmp))
            tmp = []

    <span class="hljs-keyword">return</span> res

file_path = <span class="hljs-string">&quot;YOUR_PDF_PATH&quot;</span>
output_dir = <span class="hljs-string">&quot;YOUR_OUTPUT_DIR_PATH&quot;</span>

<span class="hljs-keyword">if</span> june_run_nougat(file_path, output_dir) == <span class="hljs-number">1</span>:
    <span class="hljs-keyword">import</span> sys
    sys.exit(<span class="hljs-number">1</span>)

mmd_path = output_dir + <span class="hljs-string">&#x27;/&#x27;</span> + os.path.splitext(file_path)[<span class="hljs-number">0</span>].split(<span class="hljs-string">&#x27;/&#x27;</span>)[-<span class="hljs-number">1</span>] + <span class="hljs-string">&quot;.mmd&quot;</span>
tables = june_get_tables_from_mmd(mmd_path)


<span class="hljs-comment"># Prompt</span>
prompt_text = <span class="hljs-string">&quot;&quot;&quot;You are an assistant tasked with summarizing tables and text. \
Give a concise summary of the table or text. The table is formatted in LaTeX, and its caption is in plain text format: {element}  &quot;&quot;&quot;</span>
prompt = ChatPromptTemplate.from_template(prompt_text)

<span class="hljs-comment"># Summary chain</span>
model = ChatOpenAI(temperature = <span class="hljs-number">0</span>, model = <span class="hljs-string">&quot;gpt-3.5-turbo&quot;</span>)
summarize_chain = {<span class="hljs-string">&quot;element&quot;</span>: <span class="hljs-keyword">lambda</span> x: x} | prompt | model | StrOutputParser()
<span class="hljs-comment"># Get table summaries</span>
table_summaries = summarize_chain.batch(tables, {<span class="hljs-string">&quot;max_concurrency&quot;</span>: <span class="hljs-number">5</span>})
<span class="hljs-built_in">print</span>(table_summaries)

<span class="hljs-comment"># The vectorstore to use to index the child chunks</span>
vectorstore = Chroma(collection_name = <span class="hljs-string">&quot;summaries&quot;</span>, embedding_function = OpenAIEmbeddings())

<span class="hljs-comment"># The storage layer for the parent documents</span>
store = InMemoryStore()
id_key = <span class="hljs-string">&quot;doc_id&quot;</span>

<span class="hljs-comment"># The retriever (empty to start)</span>
retriever = MultiVectorRetriever(
    vectorstore = vectorstore,
    docstore = store,
    id_key = id_key,
    search_kwargs={<span class="hljs-string">&quot;k&quot;</span>: <span class="hljs-number">1</span>} <span class="hljs-comment"># Solving Number of requested results 4 is greater than number of elements in index..., updating n_results = 1</span>
)

<span class="hljs-comment"># Add tables</span>
table_ids = [<span class="hljs-built_in">str</span>(uuid.uuid4()) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> tables]
summary_tables = [
    Document(page_content = s, metadata = {id_key: table_ids[i]})
    <span class="hljs-keyword">for</span> i, s <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(table_summaries)
]
retriever.vectorstore.add_documents(summary_tables)
retriever.docstore.mset(<span class="hljs-built_in">list</span>(<span class="hljs-built_in">zip</span>(table_ids, tables)))


<span class="hljs-comment"># Prompt template</span>
template = <span class="hljs-string">&quot;&quot;&quot;Answer the question based only on the following context, which can include text and tables, there is a table in LaTeX format and a table caption in plain text format:
{context}
Question: {question}
&quot;&quot;&quot;</span>
prompt = ChatPromptTemplate.from_template(template)

<span class="hljs-comment"># LLM</span>
model = ChatOpenAI(temperature = <span class="hljs-number">0</span>, model = <span class="hljs-string">&quot;gpt-3.5-turbo&quot;</span>)

<span class="hljs-comment"># Simple RAG pipeline</span>
chain = (
    {<span class="hljs-string">&quot;context&quot;</span>: retriever, <span class="hljs-string">&quot;question&quot;</span>: RunnablePassthrough()}
    | prompt
    | model
    | StrOutputParser()
)

<span class="hljs-built_in">print</span>(chain.invoke(<span class="hljs-string">&quot;when layer type is Self-Attention, what is the Complexity per Layer?&quot;</span>))  <span class="hljs-comment"># Query about table 1</span>

<span class="hljs-built_in">print</span>(chain.invoke(<span class="hljs-string">&quot;Which parser performs worst for BLEU EN-DE&quot;</span>))  <span class="hljs-comment"># Query about table 2</span>

<span class="hljs-built_in">print</span>(chain.invoke(<span class="hljs-string">&quot;Which parser performs best for WSJ 23 F1&quot;</span>))  <span class="hljs-comment"># Query about table 4</span>
</code></pre>
<h1>결론</h1>
<p>이 글에서는 RAG 프로세스 중 표 처리를 위한 주요 기술과 기존 솔루션을 논의하고 구현과 함께 해결책을 제안합니다.</p>
<p>이 문서에서는 표를 파싱하는 데 nougat을 사용합니다. 그러나 더 빠르고 효과적인 파싱 도구가 있다면 nougat을 대체 고려할 것입니다. 우리의 도구에 대한 태도는 먼저 올바른 아이디어를 가지고, 그런 다음 도구를 찾아 실현하는 것에 있으며, 특정 도구에 의존하는 대신입니다.</p>
<div class="content-ad"></div>
<p>이 기사에서는 모든 테이블 콘텐츠를 LLM에 입력합니다. 그러나 실제 시나리오에서는 표가 LLM 콘텍스트 길이를 초과하는 경우를 고려해야 합니다. 이 문제를 효과적인 청킹 방법을 사용하여 해결할 수 있습니다.</p>
<p>RAG 기술에 관심이 있다면, 다른 기사들도 확인해보세요.</p>
<p>그리고 최신 AI 관련 콘텐츠는 제 뉴스레터에서 찾을 수 있습니다.</p>
<p>마지막으로, 이 기사에 오류나 누락된 내용이 있다면, 또는 궁금한 점이 있으면 댓글 섹션에서 언급해 주세요.</p>
<div class="content-ad"></div>
<h1>친근한 어조로 번역한 내용 🚀</h1>
<p>In Plain English 커뮤니티에 참여해 주셔서 감사합니다! 그 전에:</p>
<ul>
<li>저희 작가를 박수로 응원하고 팔로우해 주세요️👏️</li>
<li>저희를 팔로우하세요: X | LinkedIn | YouTube | Discord | Newsletter</li>
<li>다른 플랫폼도 방문해 보세요: Stackademic | CoFeed | Venture | Cubed</li>
<li>더 많은 콘텐츠를 만나실 수 있습니다: PlainEnglish.io</li>
</ul></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"고급 RAG 07 테이블을 위한 RAG 탐색","description":"","date":"2024-05-23 18:13","slug":"2024-05-23-AdvancedRAG07ExploringRAGforTables","content":"\nRAG를 구현하는 것은 도전적인 과제를 제공하는데, 특히 비구조화된 문서의 테이블을 효과적으로 구문 분석하고 이해하는 부분이 그 중요한 부분입니다. 특히 스캔된 문서나 이미지 형식의 문서에서는 이 작업이 특히 어려울 수 있습니다. 이러한 도전 과제에는 적어도 다음 세 가지 측면이 있습니다:\n\n- 스캔된 문서 또는 이미지 문서의 복잡성, 다양한 구조, 비텍스트 요소의 포함 및 필기 및 인쇄된 내용의 결합과 같은 특징들은 테이블 정보를 정확하게 자동 추출하는 데 도전을 제공합니다. 부정확한 구문 분석은 테이블 구조를 손상시킬 수 있으며, 불완전한 테이블을 포함하는 것은 테이블의 의미 정보를 포착하지 못할 뿐만 아니라 RAG 결과를 손상시킬 수 있습니다.\n- 테이블 캡션을 추출하고 해당 테이블에 효과적으로 연결하는 방법.\n- 테이블의 의미 정보를 효과적으로 저장하기 위한 색인 구조를 설계하는 방법.\n\n이 기사는 RAG 내에서 테이블을 관리하는 주요 기술을 소개한 후 일부 기존 오픈 소스 솔루션을 검토한 다음 새로운 솔루션을 제안하고 구현하는 방법을 제시합니다.\n\n# 주요 기술\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 테이블 구문 분석\n\n이 모듈의 주요 기능은 정형화되지 않은 문서나 이미지에서 테이블 구조를 정확하게 추출하는 것입니다.\n\n추가 기능: 해당하는 테이블 캡션을 추출하고, 개발자가 해당 테이블 캡션을 테이블과 관련 짓기 편리하도록 하는 것이 가장 좋습니다.\n\n제 현재 이해에 따르면, Figure 1에 나타난 것처럼 여러 가지 방법이 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-05-23-AdvancedRAG07ExploringRAGforTables_0.png)\n\n(a). 다중 모달 LLM(예: GPT-4V)을 활용하여 각 PDF 페이지에서 표를 식별하고 정보를 추출합니다.\n\n- 입력: 이미지 형식의 PDF 페이지\n- 출력: JSON 또는 다른 형식의 표. 다중 모달 LLM이 표 데이터를 추출하지 못하는 경우 이미지를 요약하고 요약본을 반환해야 합니다.\n\n(b). Table Transformer와 같은 전문적인 표 감지 모델을 활용하여 표 구조를 식별합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 입력: 이미지로 된 PDF 페이지\n- 출력: 이미지로 된 테이블\n\n(c). 오픈 소스 프레임워크인 unstructured 등을 사용하여 객체 검출 모델을 활용하세요(unstructured의 테이블 검출 과정은 이 기사에 자세히 기재되어 있습니다). 이러한 프레임워크를 사용하면 전체 문서의 철저한 구문 분석과 구문 분석 결과로부터 테이블 관련 콘텐츠의 추출이 가능합니다.\n\n- 입력: PDF 또는 이미지 형식의 문서\n- 출력: 문서 전체의 구문 분석 결과로부터 얻은 테이블을 일반 텍스트 또는 HTML 형식으로\n\n(d). Nougat, Donut 등의 end-to-end 모델을 사용하여 전체 문서를 구문 분석하고 테이블 관련 콘텐츠를 추출하세요. 이 접근 방식은 OCR 모델을 필요로하지 않습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 입력: PDF 또는 이미지 형식의 문서\n- 출력: 전체 문서의 구문 분석 결과를 통해 얻은 LaTeX 또는 JSON 형식의 표\n\n언급할 가치가 있는 것은 표 정보를 추출하는 방법에 관계없이 표 캡션을 포함해야 합니다. 대부분의 경우 표 캡션은 문서나 논문 작성자가 표에 대해 간단히 설명한 것으로, 전체 표를 크게 요약할 수 있습니다.\n\n위에서 언급한 네 가지 방법 중 (d) 방법은 표 캡션을 쉽게 검색할 수 있습니다. 개발자에게는 이 방법이 유용한데, 표 캡션을 표와 연관시킬 수 있도록 해주기 때문입니다. 이 내용은 다음 실험에서 자세히 설명될 것입니다.\n\n## 색인 구조\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n색인 구조에 따라 해결책은 대략 다음 카테고리로 나뉩니다:\n\n(e). 이미지 형식의 색인 표만 있는 경우.\n\n(f). 일반 텍스트 또는 JSON 형식의 색인 표만 있는 경우.\n\n(g). LaTeX 형식의 색인 표만 있는 경우.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n### (h). 테이블 요약만 색인화합니다.\n\n### (i). 작은 부터 큰 또는 문서 요약 색인 구조, Figure 2에 나와 있는 것처럼.\n\n- 작은 청크의 내용은 테이블의 각 행 정보 또는 테이블 요약일 수 있습니다.\n- 큰 청크의 내용은 이미지 형식, 일반 텍스트 형식 또는 LaTeX 형식의 테이블일 수 있습니다.\n\n![Figure 2](/assets/img/2024-05-23-AdvancedRAG07ExploringRAGforTables_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위에서 논의한 대로 Table summary는 일반적으로 LLM을 사용하여 생성됩니다:\n\n- 입력: 이미지 형식, 텍스트 형식 또는 LaTeX 형식의 테이블\n- 출력: 테이블 요약\n\n## Table Parsing, Indexing 또는 RAG가 필요하지 않은 algorithms\n\n일부 알고리즘은 테이블 파싱이 필요하지 않습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n(j). 관련 이미지(PDF 페이지)와 사용자 쿼리를 VQA 모델(예: DAN 등)이나 멀티모달 LLM에 보내고 답변을 받습니다.\n\n- 색인할 내용: 이미지 형식의 문서\n- VQA 모델이나 멀티모달 LLM에 전송되는 내용: 쿼리 + 해당 이미지 페이지\n\n(k). 관련 텍스트 형식의 PDF 페이지와 사용자 쿼리를 LLM에 보내고, 그런 다음 답변을 받습니다.\n\n- 색인할 내용: 텍스트 형식의 문서\n- LLM에 전송되는 내용: 쿼리 + 해당 텍스트 형식의 페이지\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n(l) 사용자의 쿼리와 관련 이미지(PDF 페이지), 텍스트 청크를 다중 모달 LLM(예: GPT-4V 등)에 보내고 답변을 직접 반환합니다.\n\n- 색인할 콘텐츠: 이미지 형식의 문서 및 텍스트 형식의 문서 청크\n- 다중 모달 LLM에 보내는 콘텐츠: 쿼리 + 문서의 이미지 형식 + 해당하는 텍스트 청크\n\n또한, 다음은 색인이 필요하지 않은 몇 가지 방법입니다. 그림 3과 그림 4에서 보듯이:\n\n![image](/assets/img/2024-05-23-AdvancedRAG07ExploringRAGforTables_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n(m). 먼저, 문서의 모든 표를 이미지 형태로 변환하기 위해 (a)부터 (d) 범주 중 하나의 방법을 적용하세요. 그런 다음 모든 표 이미지와 사용자 질의를 멀티모달 LLM(예: GPT-4V 등)에 직접 전송하여 답변을 받아보세요.\n\n- 색인할 내용: 없음\n- 멀티모달 LLM에 전송될 내용: 질의 + 모든 변환된 표(이미지 형태)\n\n![표 이미지](/assets/img/2024-05-23-AdvancedRAG07ExploringRAGforTables_3.png)\n\n(n). (m)에서 추출된 이미지 형식의 표를 사용하여 OCR 모델을 이용해 표 안의 모든 텍스트를 인식한 후, 표 안의 모든 텍스트와 사용자 질의를 LLM에 직접 전송하여 답변을 받아보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 색인할 콘텐츠: 없음\n- LLM에 보내지는 콘텐츠: 사용자 쿼리 + 모든 테이블 내용(텍스트 형식)\n\n익명의 사실을 공유하자면, 일부 방법은 RAG 프로세스에 의존하지 않습니다:\n\n- 첫 번째 방법은 LLM을 사용하지 않으며, 특정 데이터세트에서 학습하며 모델(예: BERT와 유사한 트랜스포머)이 TAPAS와 같은 테이블 이해 작업을 더 잘 지원하도록 합니다.\n- 두 번째 방법은 LLM을 사용하며, 사전 학습, 파인 튜닝 방법 또는 프롬프트를 사용하여 LLM이 GPT4Table과 같은 테이블 이해 작업을 수행할 수 있도록 합니다.\n\n# 기존 오픈 소스 솔루션\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이전 섹션에서는 RAG의 테이블에 대한 주요 기술을 요약하고 분류했습니다. 이 글이 구현하는 해결책을 제안하기 전에 오픈 소스 솔루션 중 일부를 탐색해보겠습니다.\n\nLlamaIndex는 네 가지 방법을 제안했는데, 처음 세 가지는 다중 모달 모델을 사용합니다.\n\n- 관련 이미지(PDF 페이지)를 검색하여 이를 GPT-4V에 보내 쿼리에 대답하도록 합니다.\n- 각 PDF 페이지를 이미지로 간주하고, 각 페이지에 대해 이미지 추론을 수행하도록 GPT-4V에게 맡깁니다. 이미지 추론을 위한 텍스트 벡터 저장소 인덱스를 작성합니다. 이미지 추론 벡터 저장소에 대한 답변을 쿼리로 가져옵니다.\n- 테이블 트랜스포머를 사용하여 검색된 이미지에서 테이블 정보를 잘라내고, 이러한 잘린 이미지를 GPT-4V에 보내 쿼리 응답을 받습니다.\n- 잘려진 테이블 이미지에 OCR을 적용하고 데이터를 GPT4/GPT-3.5로 보내어 쿼리에 답변을 받습니다.\n\n이 글의 분류에 따르면:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 이 기사에서의 (j) 항목과 유사한 첫 번째 방법은 테이블 구문 분석이 필요하지 않습니다. 그러나 결과는 이미지에 정답이 있더라도 올바른 답을 내놓지 못하는 것을 보여줍니다.\n- 두 번째 방법은 테이블 구문 분석을 포함하며 (a) 항목과 일치합니다. 색인된 콘텐츠는 GPT-4V의 결과에 따라 테이블 콘텐츠 또는 요약이며, 이는 (f) 또는 (h)에 해당할 수 있습니다. 이 방법의 단점은 GPT-4V가 이미지에서 테이블을 식별하고 내용을 추출하는 능력이 불안정하다는 것이며, PDF 형식에서 발생하는 테이블, 텍스트 및 다른 이미지가 혼합된 경우에 특히 해당됩니다.\n- 세 번째 방법은 (m) 항목과 유사하며 색인이 필요하지 않습니다.\n- 네 번째 방법은 (n) 항목과 유사하며 또한 색인이 필요하지 않습니다. 결과는 이미지에서 테이블 정보를 추출하는 능력이 없어 잘못된 답변이 생성된다고 나타냅니다.\n\n테스트 결과, 세 번째 방법이 전반적으로 가장 효과적인 것으로 나타났습니다. 그러나 제 테스트에 따르면 세 번째 방법은 테이블을 감지하는 데 어려움을 겪고, 특히 테이블 제목을 올바르게 병합하는 것조차 어렵다는 것을 보여줍니다.\n\nLangchain은 일부 솔루션을 제안했습니다. Semi-structured RAG의 주요 기술은 다음과 같습니다:\n\n- 테이블 구문 분석은 비구조적을 사용하며, 이는 (c) 항목에 해당합니다.\n- 색인 방법은 문서 요약 색인이며, 이는 (i) 항목에 해당합니다. 작은 청크 콘텐츠: 테이블 요약, 큰 청크 콘텐츠: 원시 테이블 콘텐츠(텍스트 형식).\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래 그림 5에 나타난 대로:\n\n![Figure 5](/assets/img/2024-05-23-AdvancedRAG07ExploringRAGforTables_4.png)\n\n반구조화 및 멀티 모달 RAG는 세 가지 해결책을 제안하며, 아키텍처는 아래 그림 6에 나와 있습니다.\n\n![Figure 6](/assets/img/2024-05-23-AdvancedRAG07ExploringRAGforTables_5.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n옵션 1은 이 기사의 (l) 범주와 유사합니다. 멀티모달 임베딩(예: CLIP)을 사용하여 이미지와 텍스트를 임베드하고 유사성 검색을 통해 둘 다 검색하며, 생 이미지 및 청크를 멀티모달 LLM에게 전달하여 답변 합성을 수행합니다.\n\n옵션 2은 이미지로부터 텍스트 요약을 생성하는 멀티모달 LLM(예: GPT-4V, LLaVA, 또는 FUYU-8b)을 활용합니다. 그런 다음 텍스트를 임베드하고 검색하여 텍스트 청크를 LLM에게 전달하여 답변 합성을 합니다.\n\n- 테이블 파싱은 구조화되지 않은 것을 사용합니다. 이는 범주 (d)입니다.\n- 색인 구조는 문서 요약 인덱스(범주 (i))이며, 작은 청크 내용: 테이블 요약, 큰 청크 내용: 텍스트 형식의 테이블\n\n옵션 3은 이미지로부터 텍스트 요약을 생성하기 위해 멀티모달 LLM(예: GPT-4V, LLaVA, 또는 FUYU-8b)를 사용합니다. 그런 다음 이미지 요약을 임베드하고 검색하여 원본 이미지에 대한 이미지 요약과 함께 반환하고, 원본 이미지 및 텍스트 청크를 멀티모달 LLM에게 전달하여 답변 합성을 수행합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 제안된 솔루션\n\n이 글은 주요 기술 및 기존 솔루션을 요약, 분류 및 논의하였습니다. 이를 기반으로 다음과 같은 솔루션을 제안합니다. 간단히 말해서 Re-ranking 및 query rewriting과 같은 RAG 모듈은 생략되었습니다.\n\n![Figure 7](/assets/img/2024-05-23-AdvancedRAG07ExploringRAGforTables_6.png)\n\n- 테이블 파싱: Nougat(catogery (d))를 사용합니다. 제 테스트에 따르면, 이는 테이블 감지가 unstructured(catogery (c))보다 더 효과적입니다. 게다가 Nougat은 테이블 캡션을 잘 추출하여 테이블과 연결하는 데 매우 편리합니다.\n- 문서 요약 인덱스 구조(catogery (i)): 작은 청크의 내용에는 테이블 요약이, 큰 청크의 내용에는 LaTeX 형식의 해당 테이블과 텍스트 형식의 테이블 캡션이 포함됩니다. 이를 다중 벡터 검색기를 사용하여 구현합니다.\n- 테이블 요약 획득 방법: 테이블과 테이블 캡션을 LLM에 보내 요약을 받습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 방법의 장점은 테이블을 효율적으로 구문 분석하면서 테이블 요약과 테이블 간의 관계를 포괄적으로 고려한다는 것입니다. 또한, 멀티모달 LLM이 필요하지 않아 비용을 절감할 수 있습니다.\n\n## Nougat의 원칙\n\nNougat은 도넛 아키텍처를 바탕으로 개발되었습니다. Figure 8에서 보여지듯이 OCR 관련 입력이나 모듈이 필요하지 않고 네트워크를 통해 텍스트를 인식합니다.\n\n![Nougat Principle](/assets/img/2024-05-23-AdvancedRAG07ExploringRAGforTables_7.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n누가(Nougat)가 수식을 분석하는 능력이 인상적이에요. 테이블 분석에도 능숙해요. 더불어, 테이블 캡션을 연결하여 보여줄 수 있어 편하지요. 그림 9에서 보여졌듯이요:\n\n![Figure 9](/assets/img/2024-05-23-AdvancedRAG07ExploringRAGforTables_8.png)\n\n수많은 논문을 테스트한 결과, 테이블 캡션이 항상 테이블 다음 줄에 고정되어 있는 것을 발견했어요. 이 일관성은 우연이 아님을 시사하며, 그래서 누가(Nougat)가 이 효과를 달성하는 방법에 관심이 있어요.\n\n중간 결과가 없는 엔드 투 엔드 모델이므로, 훈련 데이터에 많이 의존할 것으로 예상됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테이블 태그를 Markdown 형식으로 변경하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 누가(Nougat)는 이전 파싱 도구에서 어려웠던 부분인 수식 및 표와 같은 부분을 정확하게 LaTeX 소스 코드로 파싱할 수 있습니다.\n- 누가(Nougat)의 파싱 결과는 마크다운과 유사한 반구조화된 문서입니다.\n- 쉽게 표 제목을 얻고 해당 표와 편리하게 연결할 수 있습니다.\n\n단점:\n\n- 누가(Nougat)의 파싱 속도가 느리기 때문에 대규모 배포에 도전이 될 수 있습니다.\n- 누가(Nougat)는 과학 논문을 기반으로 학습되었기 때문에 비슷한 구조의 문서에서 뛰어난 성능을 발휘합니다. 그러나 비라틴 문자 텍스트 문서에서는 성능이 떨어집니다.\n- 누가(Nougat) 모델은 한 번에 한 페이지의 과학 논문만을 학습하며, 다른 페이지에 대한 지식이 부족합니다. 이로 인해 파싱된 콘텐츠에 일관성이 없을 수 있습니다. 따라서, 인식 효과가 좋지 않다면 PDF를 개별 페이지로 나누고 하나씩 파싱하는 것을 고려해야 합니다.\n- 이중 칼럼 논문에서의 표 파싱은 단일 칼럼 논문과 같이 효과적이지 않을 수 있습니다.\n\n## 코드 구현\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n먼저 관련 Python 패키지를 설치해주세요.\n\n```js\npip install langchain\npip install chromadb\npip install nougat-ocr\n```\n\n설치를 완료한 후, Python 패키지의 버전을 확인할 수 있습니다.\n\n```js\nlangchain                                0.1.12\nlangchain-community                      0.0.28\nlangchain-core                           0.1.31\nlangchain-openai                         0.0.8\nlangchain-text-splitters                 0.0.1\n\nchroma-hnswlib                           0.7.3\nchromadb                                 0.4.24\n\nnougat-ocr                               0.1.17\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n환경을 설정하고 라이브러리를 가져와주세요:\n\n```js\nimport os\nos.environ[\"OPENAI_API_KEY\"] = \"YOUR_OPEN_AI_KEY\"\n\nimport subprocess\nimport uuid\n\nfrom langchain_core.output_parsers import StrOutputParser\nfrom langchain_core.prompts import ChatPromptTemplate\nfrom langchain_openai import ChatOpenAI\nfrom langchain.retrievers.multi_vector import MultiVectorRetriever\nfrom langchain.storage import InMemoryStore\nfrom langchain_community.vectorstores import Chroma\nfrom langchain_core.documents import Document\nfrom langchain_openai import OpenAIEmbeddings\nfrom langchain_core.runnables import RunnablePassthrough\n```\n\nAttention Is All You Need 논문을 YOUR_PDF_PATH로 다운로드하고, nougat을 실행하여 PDF 파일을 구문 분석하고 해당 결과로부터 LaTex 형식의 표 및 텍스트 형식의 표 캡션을 얻어주세요. 첫 실행 시 필요한 모델 파일이 다운로드됩니다.\n\n```js\ndef june_run_nougat(file_path, output_dir):\n    # nougat을 실행하고 결과를 Mathpix Markdown으로 저장합니다.\n    cmd = [\"nougat\", file_path, \"-o\", output_dir, \"-m\", \"0.1.0-base\", \"--no-skipping\"]\n    res = subprocess.run(cmd)\n    if res.returncode != 0:\n        print(\"nougat 실행 중 오류가 발생했습니다.\")\n        return res.returncode\n    else:\n        print(\"작업 완료!\")\n        return 0\n\ndef june_get_tables_from_mmd(mmd_path):\n    f = open(mmd_path)\n    lines = f.readlines()\n    res = []\n    tmp = []\n    flag = \"\"\n    for line in lines:\n        if line == \"\\\\begin{table}\\n\":\n            flag = \"BEGINTABLE\"\n        elif line == \"\\\\end{table}\\n\":\n            flag = \"ENDTABLE\"\n\n        if flag == \"BEGINTABLE\":\n            tmp.append(line)\n        elif flag == \"ENDTABLE\":\n            tmp.append(line)\n            flag = \"CAPTION\"\n        elif flag == \"CAPTION\":\n            tmp.append(line)\n            flag = \"MARKDOWN\"\n            print('-' * 100)\n            print(''.join(tmp))\n            res.append(''.join(tmp))\n            tmp = []\n\n    return res\n\nfile_path = \"YOUR_PDF_PATH\"\noutput_dir = \"YOUR_OUTPUT_DIR_PATH\"\n\nif june_run_nougat(file_path, output_dir) == 1:\n    import sys\n    sys.exit(1)\n\nmmd_path = output_dir + '/' + os.path.splitext(file_path)[0].split('/')[-1] + \".mmd\"\ntables = june_get_tables_from_mmd(mmd_path)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n함수 june_get_tables_from_mmd은 Figure 10에 표시된 mmd 파일에서 'table'부터 'table'까지의 모든 내용 및 'table' 다음 줄을 추출하는 데 사용됩니다.\n\n![이미지](/assets/img/2024-05-23-AdvancedRAG07ExploringRAGforTables_9.png)\n\n표 캡션을 표 아래에 배치해야 하거나 표가 'table'로 시작하고 'end'로 끝나야 한다는 것을 명시하는 공식 문서가 발견되지 않았다는 점을 유의하십시오. 따라서 june_get_tables_from_mmd는 휴리스틱입니다.\n\nPDF에서 표를 구문 분석한 결과는 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n표 1: 다양한 레이어 유형에 대한 최대 경로 길이, 레이어당 복잡성 및 최소 순차 작업 수가 표시됩니다.\n\n표 2: Transformer가 영어-독일어 및 영어-프랑스어 newstest2014 테스트에서 이전 최신 모델보다 더 우수한 BLEU 점수를 달성하며 훈련 비용이 줄어드는 것을 보여줍니다.\n\n표 3: Transformer 아키텍처의 변형이 나열되어 있으며, 기본 모델 정보와 영어-독일어 번역 개발 세트 newstest2013에서의 모든 메트릭스가 제공됩니다.\n\n표 4: Transformer가 영어 구성 구문 분석에 잘 일반화되며, WSJ 23 섹션의 결과가 제시됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-05-23-AdvancedRAG07ExploringRAGforTables_10.png\" /\u003e\n\n다중 벡터 리트리버를 사용하여 문서 요약 색인 구조를 구축해보세요.\n\n```js\n# 자식 청크를 색인화하는 데 사용할 벡터스토어\nvectorstore = Chroma(collection_name = \"summaries\", embedding_function = OpenAIEmbeddings())\n\n# 상위 문서를 위한 저장소 레이어\nstore = InMemoryStore()\nid_key = \"doc_id\"\n\n# 리트리버 (시작할 때는 빈 상태)\nretriever = MultiVectorRetriever(\n    vectorstore = vectorstore,\n    docstore = store,\n    id_key = id_key,\n    search_kwargs={\"k\": 1} # 요청된 결과의 수가 색인 요소보다 큰 4이므로, n_results = 1로 업데이트하겠습니다\n)\n\n# 테이블 추가\ntable_ids = [str(uuid.uuid4()) for _ in tables]\nsummary_tables = [\n    Document(page_content = s, metadata = {id_key: table_ids[i]})\n    for i, s in enumerate(table_summaries)\n]\nretriever.vectorstore.add_documents(summary_tables)\nretriever.docstore.mset(list(zip(table_ids, tables)))\n```\n\n모든 준비가 되었습니다. 간단한 RAG 파이프라인을 구축하고 쿼리를 수행해보세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# 프롬프트 템플릿\n템플릿 = \"\"\"다음 콘텍스트를 기반으로 질문에 답하세요. 이는 텍스트와 테이블을 포함할 수 있으며 LaTeX 형식의 테이블과 일반 텍스트 형식의 테이블 캡션을 포함합니다:\n{context}\n질문: {question}\n\"\"\"\n프롬프트 = ChatPromptTemplate.from_template(템플릿)\n\n# LLM\n모델 = ChatOpenAI(temperature = 0, model = \"gpt-3.5-turbo\")\n\n\n# 간단한 RAG 파이프라인\n체인 = (\n    {\"context\": retriever, \"question\": RunnablePassthrough()}\n    | 프롬프트\n    | 모델\n    | StrOutputParser()\n)\n\n\nprint(체인.invoke(\"when layer type is Self-Attention, what is the Complexity per Layer?\"))  # 테이블 1에 관한 쿼리\n\nprint(체인.invoke(\"Which parser performs worst for BLEU EN-DE\"))  # 테이블 2에 관한 쿼리\n\nprint(체인.invoke(\"Which parser performs best for WSJ 23 F1\"))  # 테이블 4에 관한 쿼리\n```\n\n아래는 실행 결과입니다. 여러 질문이 정확히 답변되었음을 보여주는데, 이는 도표 12에 나와 있습니다:\n\n\u003cimg src=\"/assets/img/2024-05-23-AdvancedRAG07ExploringRAGforTables_11.png\" /\u003e\n\n전체 코드는 아래와 같습니다:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```python\nimport os\nos.environ[\"OPENAI_API_KEY\"] = \"YOUR_OPEN_AI_KEY\"\n\nimport subprocess\nimport uuid\n\nfrom langchain_core.output_parsers import StrOutputParser\nfrom langchain_core.prompts import ChatPromptTemplate\nfrom langchain_openai import ChatOpenAI\nfrom langchain.retrievers.multi_vector import MultiVectorRetriever\nfrom langchain.storage import InMemoryStore\nfrom langchain_community.vectorstores import Chroma\nfrom langchain_core.documents import Document\nfrom langchain_openai import OpenAIEmbeddings\nfrom langchain_core.runnables import RunnablePassthrough\n\n\ndef june_run_nougat(file_path, output_dir):\n    # Run Nougat and store results as Mathpix Markdown\n    cmd = [\"nougat\", file_path, \"-o\", output_dir, \"-m\", \"0.1.0-base\", \"--no-skipping\"]\n    res = subprocess.run(cmd)\n    if res.returncode != 0:\n        print(\"Error when running nougat.\")\n        return res.returncode\n    else:\n        print(\"Operation Completed!\")\n        return 0\n\ndef june_get_tables_from_mmd(mmd_path):\n    f = open(mmd_path)\n    lines = f.readlines()\n    res = []\n    tmp = []\n    flag = \"\"\n    for line in lines:\n        if line == \"\\\\begin{table}\\n\":\n            flag = \"BEGINTABLE\"\n        elif line == \"\\\\end{table}\\n\":\n            flag = \"ENDTABLE\"\n\n        if flag == \"BEGINTABLE\":\n            tmp.append(line)\n        elif flag == \"ENDTABLE\":\n            tmp.append(line)\n            flag = \"CAPTION\"\n        elif flag == \"CAPTION\":\n            tmp.append(line)\n            flag = \"MARKDOWN\"\n            print('-' * 100)\n            print(''.join(tmp))\n            res.append(''.join(tmp))\n            tmp = []\n\n    return res\n\nfile_path = \"YOUR_PDF_PATH\"\noutput_dir = \"YOUR_OUTPUT_DIR_PATH\"\n\nif june_run_nougat(file_path, output_dir) == 1:\n    import sys\n    sys.exit(1)\n\nmmd_path = output_dir + '/' + os.path.splitext(file_path)[0].split('/')[-1] + \".mmd\"\ntables = june_get_tables_from_mmd(mmd_path)\n\n\n# Prompt\nprompt_text = \"\"\"You are an assistant tasked with summarizing tables and text. \\\nGive a concise summary of the table or text. The table is formatted in LaTeX, and its caption is in plain text format: {element}  \"\"\"\nprompt = ChatPromptTemplate.from_template(prompt_text)\n\n# Summary chain\nmodel = ChatOpenAI(temperature = 0, model = \"gpt-3.5-turbo\")\nsummarize_chain = {\"element\": lambda x: x} | prompt | model | StrOutputParser()\n# Get table summaries\ntable_summaries = summarize_chain.batch(tables, {\"max_concurrency\": 5})\nprint(table_summaries)\n\n# The vectorstore to use to index the child chunks\nvectorstore = Chroma(collection_name = \"summaries\", embedding_function = OpenAIEmbeddings())\n\n# The storage layer for the parent documents\nstore = InMemoryStore()\nid_key = \"doc_id\"\n\n# The retriever (empty to start)\nretriever = MultiVectorRetriever(\n    vectorstore = vectorstore,\n    docstore = store,\n    id_key = id_key,\n    search_kwargs={\"k\": 1} # Solving Number of requested results 4 is greater than number of elements in index..., updating n_results = 1\n)\n\n# Add tables\ntable_ids = [str(uuid.uuid4()) for _ in tables]\nsummary_tables = [\n    Document(page_content = s, metadata = {id_key: table_ids[i]})\n    for i, s in enumerate(table_summaries)\n]\nretriever.vectorstore.add_documents(summary_tables)\nretriever.docstore.mset(list(zip(table_ids, tables)))\n\n\n# Prompt template\ntemplate = \"\"\"Answer the question based only on the following context, which can include text and tables, there is a table in LaTeX format and a table caption in plain text format:\n{context}\nQuestion: {question}\n\"\"\"\nprompt = ChatPromptTemplate.from_template(template)\n\n# LLM\nmodel = ChatOpenAI(temperature = 0, model = \"gpt-3.5-turbo\")\n\n# Simple RAG pipeline\nchain = (\n    {\"context\": retriever, \"question\": RunnablePassthrough()}\n    | prompt\n    | model\n    | StrOutputParser()\n)\n\nprint(chain.invoke(\"when layer type is Self-Attention, what is the Complexity per Layer?\"))  # Query about table 1\n\nprint(chain.invoke(\"Which parser performs worst for BLEU EN-DE\"))  # Query about table 2\n\nprint(chain.invoke(\"Which parser performs best for WSJ 23 F1\"))  # Query about table 4\n```\n\n# 결론\n\n이 글에서는 RAG 프로세스 중 표 처리를 위한 주요 기술과 기존 솔루션을 논의하고 구현과 함께 해결책을 제안합니다.\n\n이 문서에서는 표를 파싱하는 데 nougat을 사용합니다. 그러나 더 빠르고 효과적인 파싱 도구가 있다면 nougat을 대체 고려할 것입니다. 우리의 도구에 대한 태도는 먼저 올바른 아이디어를 가지고, 그런 다음 도구를 찾아 실현하는 것에 있으며, 특정 도구에 의존하는 대신입니다.\n\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 기사에서는 모든 테이블 콘텐츠를 LLM에 입력합니다. 그러나 실제 시나리오에서는 표가 LLM 콘텍스트 길이를 초과하는 경우를 고려해야 합니다. 이 문제를 효과적인 청킹 방법을 사용하여 해결할 수 있습니다.\n\nRAG 기술에 관심이 있다면, 다른 기사들도 확인해보세요.\n\n그리고 최신 AI 관련 콘텐츠는 제 뉴스레터에서 찾을 수 있습니다.\n\n마지막으로, 이 기사에 오류나 누락된 내용이 있다면, 또는 궁금한 점이 있으면 댓글 섹션에서 언급해 주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 친근한 어조로 번역한 내용 🚀\n\nIn Plain English 커뮤니티에 참여해 주셔서 감사합니다! 그 전에:\n\n- 저희 작가를 박수로 응원하고 팔로우해 주세요️👏️\n- 저희를 팔로우하세요: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼도 방문해 보세요: Stackademic | CoFeed | Venture | Cubed\n- 더 많은 콘텐츠를 만나실 수 있습니다: PlainEnglish.io\n","ogImage":{"url":"/assets/img/2024-05-23-AdvancedRAG07ExploringRAGforTables_0.png"},"coverImage":"/assets/img/2024-05-23-AdvancedRAG07ExploringRAGforTables_0.png","tag":["Tech"],"readingTime":19},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    ul: \"ul\",\n    li: \"li\",\n    h1: \"h1\",\n    h2: \"h2\",\n    img: \"img\",\n    h3: \"h3\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"RAG를 구현하는 것은 도전적인 과제를 제공하는데, 특히 비구조화된 문서의 테이블을 효과적으로 구문 분석하고 이해하는 부분이 그 중요한 부분입니다. 특히 스캔된 문서나 이미지 형식의 문서에서는 이 작업이 특히 어려울 수 있습니다. 이러한 도전 과제에는 적어도 다음 세 가지 측면이 있습니다:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"스캔된 문서 또는 이미지 문서의 복잡성, 다양한 구조, 비텍스트 요소의 포함 및 필기 및 인쇄된 내용의 결합과 같은 특징들은 테이블 정보를 정확하게 자동 추출하는 데 도전을 제공합니다. 부정확한 구문 분석은 테이블 구조를 손상시킬 수 있으며, 불완전한 테이블을 포함하는 것은 테이블의 의미 정보를 포착하지 못할 뿐만 아니라 RAG 결과를 손상시킬 수 있습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"테이블 캡션을 추출하고 해당 테이블에 효과적으로 연결하는 방법.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"테이블의 의미 정보를 효과적으로 저장하기 위한 색인 구조를 설계하는 방법.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 기사는 RAG 내에서 테이블을 관리하는 주요 기술을 소개한 후 일부 기존 오픈 소스 솔루션을 검토한 다음 새로운 솔루션을 제안하고 구현하는 방법을 제시합니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"주요 기술\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"테이블 구문 분석\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 모듈의 주요 기능은 정형화되지 않은 문서나 이미지에서 테이블 구조를 정확하게 추출하는 것입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"추가 기능: 해당하는 테이블 캡션을 추출하고, 개발자가 해당 테이블 캡션을 테이블과 관련 짓기 편리하도록 하는 것이 가장 좋습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"제 현재 이해에 따르면, Figure 1에 나타난 것처럼 여러 가지 방법이 있습니다:\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-23-AdvancedRAG07ExploringRAGforTables_0.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"(a). 다중 모달 LLM(예: GPT-4V)을 활용하여 각 PDF 페이지에서 표를 식별하고 정보를 추출합니다.\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"입력: 이미지 형식의 PDF 페이지\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"출력: JSON 또는 다른 형식의 표. 다중 모달 LLM이 표 데이터를 추출하지 못하는 경우 이미지를 요약하고 요약본을 반환해야 합니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"(b). Table Transformer와 같은 전문적인 표 감지 모델을 활용하여 표 구조를 식별합니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"입력: 이미지로 된 PDF 페이지\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"출력: 이미지로 된 테이블\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"(c). 오픈 소스 프레임워크인 unstructured 등을 사용하여 객체 검출 모델을 활용하세요(unstructured의 테이블 검출 과정은 이 기사에 자세히 기재되어 있습니다). 이러한 프레임워크를 사용하면 전체 문서의 철저한 구문 분석과 구문 분석 결과로부터 테이블 관련 콘텐츠의 추출이 가능합니다.\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"입력: PDF 또는 이미지 형식의 문서\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"출력: 문서 전체의 구문 분석 결과로부터 얻은 테이블을 일반 텍스트 또는 HTML 형식으로\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"(d). Nougat, Donut 등의 end-to-end 모델을 사용하여 전체 문서를 구문 분석하고 테이블 관련 콘텐츠를 추출하세요. 이 접근 방식은 OCR 모델을 필요로하지 않습니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"입력: PDF 또는 이미지 형식의 문서\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"출력: 전체 문서의 구문 분석 결과를 통해 얻은 LaTeX 또는 JSON 형식의 표\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"언급할 가치가 있는 것은 표 정보를 추출하는 방법에 관계없이 표 캡션을 포함해야 합니다. 대부분의 경우 표 캡션은 문서나 논문 작성자가 표에 대해 간단히 설명한 것으로, 전체 표를 크게 요약할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"위에서 언급한 네 가지 방법 중 (d) 방법은 표 캡션을 쉽게 검색할 수 있습니다. 개발자에게는 이 방법이 유용한데, 표 캡션을 표와 연관시킬 수 있도록 해주기 때문입니다. 이 내용은 다음 실험에서 자세히 설명될 것입니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"색인 구조\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"색인 구조에 따라 해결책은 대략 다음 카테고리로 나뉩니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"(e). 이미지 형식의 색인 표만 있는 경우.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"(f). 일반 텍스트 또는 JSON 형식의 색인 표만 있는 경우.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"(g). LaTeX 형식의 색인 표만 있는 경우.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"(h). 테이블 요약만 색인화합니다.\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"(i). 작은 부터 큰 또는 문서 요약 색인 구조, Figure 2에 나와 있는 것처럼.\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"작은 청크의 내용은 테이블의 각 행 정보 또는 테이블 요약일 수 있습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"큰 청크의 내용은 이미지 형식, 일반 텍스트 형식 또는 LaTeX 형식의 테이블일 수 있습니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-23-AdvancedRAG07ExploringRAGforTables_1.png\",\n        alt: \"Figure 2\"\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"위에서 논의한 대로 Table summary는 일반적으로 LLM을 사용하여 생성됩니다:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"입력: 이미지 형식, 텍스트 형식 또는 LaTeX 형식의 테이블\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"출력: 테이블 요약\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Table Parsing, Indexing 또는 RAG가 필요하지 않은 algorithms\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"일부 알고리즘은 테이블 파싱이 필요하지 않습니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"(j). 관련 이미지(PDF 페이지)와 사용자 쿼리를 VQA 모델(예: DAN 등)이나 멀티모달 LLM에 보내고 답변을 받습니다.\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"색인할 내용: 이미지 형식의 문서\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"VQA 모델이나 멀티모달 LLM에 전송되는 내용: 쿼리 + 해당 이미지 페이지\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"(k). 관련 텍스트 형식의 PDF 페이지와 사용자 쿼리를 LLM에 보내고, 그런 다음 답변을 받습니다.\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"색인할 내용: 텍스트 형식의 문서\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"LLM에 전송되는 내용: 쿼리 + 해당 텍스트 형식의 페이지\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"(l) 사용자의 쿼리와 관련 이미지(PDF 페이지), 텍스트 청크를 다중 모달 LLM(예: GPT-4V 등)에 보내고 답변을 직접 반환합니다.\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"색인할 콘텐츠: 이미지 형식의 문서 및 텍스트 형식의 문서 청크\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"다중 모달 LLM에 보내는 콘텐츠: 쿼리 + 문서의 이미지 형식 + 해당하는 텍스트 청크\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"또한, 다음은 색인이 필요하지 않은 몇 가지 방법입니다. 그림 3과 그림 4에서 보듯이:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-23-AdvancedRAG07ExploringRAGforTables_2.png\",\n        alt: \"image\"\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"(m). 먼저, 문서의 모든 표를 이미지 형태로 변환하기 위해 (a)부터 (d) 범주 중 하나의 방법을 적용하세요. 그런 다음 모든 표 이미지와 사용자 질의를 멀티모달 LLM(예: GPT-4V 등)에 직접 전송하여 답변을 받아보세요.\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"색인할 내용: 없음\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"멀티모달 LLM에 전송될 내용: 질의 + 모든 변환된 표(이미지 형태)\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-23-AdvancedRAG07ExploringRAGforTables_3.png\",\n        alt: \"표 이미지\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"(n). (m)에서 추출된 이미지 형식의 표를 사용하여 OCR 모델을 이용해 표 안의 모든 텍스트를 인식한 후, 표 안의 모든 텍스트와 사용자 질의를 LLM에 직접 전송하여 답변을 받아보세요.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"색인할 콘텐츠: 없음\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"LLM에 보내지는 콘텐츠: 사용자 쿼리 + 모든 테이블 내용(텍스트 형식)\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"익명의 사실을 공유하자면, 일부 방법은 RAG 프로세스에 의존하지 않습니다:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"첫 번째 방법은 LLM을 사용하지 않으며, 특정 데이터세트에서 학습하며 모델(예: BERT와 유사한 트랜스포머)이 TAPAS와 같은 테이블 이해 작업을 더 잘 지원하도록 합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"두 번째 방법은 LLM을 사용하며, 사전 학습, 파인 튜닝 방법 또는 프롬프트를 사용하여 LLM이 GPT4Table과 같은 테이블 이해 작업을 수행할 수 있도록 합니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"기존 오픈 소스 솔루션\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이전 섹션에서는 RAG의 테이블에 대한 주요 기술을 요약하고 분류했습니다. 이 글이 구현하는 해결책을 제안하기 전에 오픈 소스 솔루션 중 일부를 탐색해보겠습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"LlamaIndex는 네 가지 방법을 제안했는데, 처음 세 가지는 다중 모달 모델을 사용합니다.\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"관련 이미지(PDF 페이지)를 검색하여 이를 GPT-4V에 보내 쿼리에 대답하도록 합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"각 PDF 페이지를 이미지로 간주하고, 각 페이지에 대해 이미지 추론을 수행하도록 GPT-4V에게 맡깁니다. 이미지 추론을 위한 텍스트 벡터 저장소 인덱스를 작성합니다. 이미지 추론 벡터 저장소에 대한 답변을 쿼리로 가져옵니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"테이블 트랜스포머를 사용하여 검색된 이미지에서 테이블 정보를 잘라내고, 이러한 잘린 이미지를 GPT-4V에 보내 쿼리 응답을 받습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"잘려진 테이블 이미지에 OCR을 적용하고 데이터를 GPT4/GPT-3.5로 보내어 쿼리에 답변을 받습니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 글의 분류에 따르면:\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"이 기사에서의 (j) 항목과 유사한 첫 번째 방법은 테이블 구문 분석이 필요하지 않습니다. 그러나 결과는 이미지에 정답이 있더라도 올바른 답을 내놓지 못하는 것을 보여줍니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"두 번째 방법은 테이블 구문 분석을 포함하며 (a) 항목과 일치합니다. 색인된 콘텐츠는 GPT-4V의 결과에 따라 테이블 콘텐츠 또는 요약이며, 이는 (f) 또는 (h)에 해당할 수 있습니다. 이 방법의 단점은 GPT-4V가 이미지에서 테이블을 식별하고 내용을 추출하는 능력이 불안정하다는 것이며, PDF 형식에서 발생하는 테이블, 텍스트 및 다른 이미지가 혼합된 경우에 특히 해당됩니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"세 번째 방법은 (m) 항목과 유사하며 색인이 필요하지 않습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"네 번째 방법은 (n) 항목과 유사하며 또한 색인이 필요하지 않습니다. 결과는 이미지에서 테이블 정보를 추출하는 능력이 없어 잘못된 답변이 생성된다고 나타냅니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"테스트 결과, 세 번째 방법이 전반적으로 가장 효과적인 것으로 나타났습니다. 그러나 제 테스트에 따르면 세 번째 방법은 테이블을 감지하는 데 어려움을 겪고, 특히 테이블 제목을 올바르게 병합하는 것조차 어렵다는 것을 보여줍니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Langchain은 일부 솔루션을 제안했습니다. Semi-structured RAG의 주요 기술은 다음과 같습니다:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"테이블 구문 분석은 비구조적을 사용하며, 이는 (c) 항목에 해당합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"색인 방법은 문서 요약 색인이며, 이는 (i) 항목에 해당합니다. 작은 청크 콘텐츠: 테이블 요약, 큰 청크 콘텐츠: 원시 테이블 콘텐츠(텍스트 형식).\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"아래 그림 5에 나타난 대로:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-23-AdvancedRAG07ExploringRAGforTables_4.png\",\n        alt: \"Figure 5\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"반구조화 및 멀티 모달 RAG는 세 가지 해결책을 제안하며, 아키텍처는 아래 그림 6에 나와 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-23-AdvancedRAG07ExploringRAGforTables_5.png\",\n        alt: \"Figure 6\"\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"옵션 1은 이 기사의 (l) 범주와 유사합니다. 멀티모달 임베딩(예: CLIP)을 사용하여 이미지와 텍스트를 임베드하고 유사성 검색을 통해 둘 다 검색하며, 생 이미지 및 청크를 멀티모달 LLM에게 전달하여 답변 합성을 수행합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"옵션 2은 이미지로부터 텍스트 요약을 생성하는 멀티모달 LLM(예: GPT-4V, LLaVA, 또는 FUYU-8b)을 활용합니다. 그런 다음 텍스트를 임베드하고 검색하여 텍스트 청크를 LLM에게 전달하여 답변 합성을 합니다.\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"테이블 파싱은 구조화되지 않은 것을 사용합니다. 이는 범주 (d)입니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"색인 구조는 문서 요약 인덱스(범주 (i))이며, 작은 청크 내용: 테이블 요약, 큰 청크 내용: 텍스트 형식의 테이블\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"옵션 3은 이미지로부터 텍스트 요약을 생성하기 위해 멀티모달 LLM(예: GPT-4V, LLaVA, 또는 FUYU-8b)를 사용합니다. 그런 다음 이미지 요약을 임베드하고 검색하여 원본 이미지에 대한 이미지 요약과 함께 반환하고, 원본 이미지 및 텍스트 청크를 멀티모달 LLM에게 전달하여 답변 합성을 수행합니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"제안된 솔루션\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 글은 주요 기술 및 기존 솔루션을 요약, 분류 및 논의하였습니다. 이를 기반으로 다음과 같은 솔루션을 제안합니다. 간단히 말해서 Re-ranking 및 query rewriting과 같은 RAG 모듈은 생략되었습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-23-AdvancedRAG07ExploringRAGforTables_6.png\",\n        alt: \"Figure 7\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"테이블 파싱: Nougat(catogery (d))를 사용합니다. 제 테스트에 따르면, 이는 테이블 감지가 unstructured(catogery (c))보다 더 효과적입니다. 게다가 Nougat은 테이블 캡션을 잘 추출하여 테이블과 연결하는 데 매우 편리합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"문서 요약 인덱스 구조(catogery (i)): 작은 청크의 내용에는 테이블 요약이, 큰 청크의 내용에는 LaTeX 형식의 해당 테이블과 텍스트 형식의 테이블 캡션이 포함됩니다. 이를 다중 벡터 검색기를 사용하여 구현합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"테이블 요약 획득 방법: 테이블과 테이블 캡션을 LLM에 보내 요약을 받습니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 방법의 장점은 테이블을 효율적으로 구문 분석하면서 테이블 요약과 테이블 간의 관계를 포괄적으로 고려한다는 것입니다. 또한, 멀티모달 LLM이 필요하지 않아 비용을 절감할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Nougat의 원칙\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Nougat은 도넛 아키텍처를 바탕으로 개발되었습니다. Figure 8에서 보여지듯이 OCR 관련 입력이나 모듈이 필요하지 않고 네트워크를 통해 텍스트를 인식합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-23-AdvancedRAG07ExploringRAGforTables_7.png\",\n        alt: \"Nougat Principle\"\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"누가(Nougat)가 수식을 분석하는 능력이 인상적이에요. 테이블 분석에도 능숙해요. 더불어, 테이블 캡션을 연결하여 보여줄 수 있어 편하지요. 그림 9에서 보여졌듯이요:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-23-AdvancedRAG07ExploringRAGforTables_8.png\",\n        alt: \"Figure 9\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"수많은 논문을 테스트한 결과, 테이블 캡션이 항상 테이블 다음 줄에 고정되어 있는 것을 발견했어요. 이 일관성은 우연이 아님을 시사하며, 그래서 누가(Nougat)가 이 효과를 달성하는 방법에 관심이 있어요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"중간 결과가 없는 엔드 투 엔드 모델이므로, 훈련 데이터에 많이 의존할 것으로 예상됩니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"테이블 태그를 Markdown 형식으로 변경하세요.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"누가(Nougat)는 이전 파싱 도구에서 어려웠던 부분인 수식 및 표와 같은 부분을 정확하게 LaTeX 소스 코드로 파싱할 수 있습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"누가(Nougat)의 파싱 결과는 마크다운과 유사한 반구조화된 문서입니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"쉽게 표 제목을 얻고 해당 표와 편리하게 연결할 수 있습니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"단점:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"누가(Nougat)의 파싱 속도가 느리기 때문에 대규모 배포에 도전이 될 수 있습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"누가(Nougat)는 과학 논문을 기반으로 학습되었기 때문에 비슷한 구조의 문서에서 뛰어난 성능을 발휘합니다. 그러나 비라틴 문자 텍스트 문서에서는 성능이 떨어집니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"누가(Nougat) 모델은 한 번에 한 페이지의 과학 논문만을 학습하며, 다른 페이지에 대한 지식이 부족합니다. 이로 인해 파싱된 콘텐츠에 일관성이 없을 수 있습니다. 따라서, 인식 효과가 좋지 않다면 PDF를 개별 페이지로 나누고 하나씩 파싱하는 것을 고려해야 합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"이중 칼럼 논문에서의 표 파싱은 단일 칼럼 논문과 같이 효과적이지 않을 수 있습니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"코드 구현\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"먼저 관련 Python 패키지를 설치해주세요.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-js\",\n        children: \"pip install langchain\\npip install chromadb\\npip install nougat-ocr\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"설치를 완료한 후, Python 패키지의 버전을 확인할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"langchain                                \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.1\"\n        }), _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \".12\"\n        }), \"\\nlangchain-community                      \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.0\"\n        }), _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \".28\"\n        }), \"\\nlangchain-core                           \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.1\"\n        }), _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \".31\"\n        }), \"\\nlangchain-openai                         \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.0\"\n        }), _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \".8\"\n        }), \"\\nlangchain-text-splitters                 \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.0\"\n        }), _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \".1\"\n        }), \"\\n\\nchroma-hnswlib                           \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.7\"\n        }), _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \".3\"\n        }), \"\\nchromadb                                 \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.4\"\n        }), _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \".24\"\n        }), \"\\n\\nnougat-ocr                               \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.1\"\n        }), _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \".17\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"환경을 설정하고 라이브러리를 가져와주세요:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" os\\nos.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"environ\"\n        }), \"[\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"OPENAI_API_KEY\\\"\"\n        }), \"] = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"YOUR_OPEN_AI_KEY\\\"\"\n        }), \"\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" subprocess\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" uuid\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" langchain_core.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"output_parsers\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"StrOutputParser\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" langchain_core.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"prompts\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ChatPromptTemplate\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" langchain_openai \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ChatOpenAI\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" langchain.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"retrievers\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"multi_vector\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"MultiVectorRetriever\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" langchain.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"storage\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"InMemoryStore\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" langchain_community.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"vectorstores\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Chroma\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" langchain_core.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"documents\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Document\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" langchain_openai \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"OpenAIEmbeddings\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" langchain_core.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"runnables\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"RunnablePassthrough\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Attention Is All You Need 논문을 YOUR_PDF_PATH로 다운로드하고, nougat을 실행하여 PDF 파일을 구문 분석하고 해당 결과로부터 LaTex 형식의 표 및 텍스트 형식의 표 캡션을 얻어주세요. 첫 실행 시 필요한 모델 파일이 다운로드됩니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"def \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"june_run_nougat\"\n        }), \"(file_path, output_dir):\\n    # nougat을 실행하고 결과를 \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Mathpix\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Markdown\"\n        }), \"으로 저장합니다.\\n    cmd = [\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"nougat\\\"\"\n        }), \", file_path, \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"-o\\\"\"\n        }), \", output_dir, \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"-m\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"0.1.0-base\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"--no-skipping\\\"\"\n        }), \"]\\n    res = subprocess.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"run\"\n        }), \"(cmd)\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" res.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"returncode\"\n        }), \" != \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \":\\n        \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"print\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"nougat 실행 중 오류가 발생했습니다.\\\"\"\n        }), \")\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" res.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"returncode\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"else\"\n        }), \":\\n        \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"print\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"작업 완료!\\\"\"\n        }), \")\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"\\n\\ndef \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"june_get_tables_from_mmd\"\n        }), \"(mmd_path):\\n    f = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"open\"\n        }), \"(mmd_path)\\n    lines = f.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"readlines\"\n        }), \"()\\n    res = []\\n    tmp = []\\n    flag = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\\\"\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" line \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"lines\"\n        }), \":\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" line == \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\\\\\\\\begin{table}\\\\n\\\"\"\n        }), \":\\n            flag = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"BEGINTABLE\\\"\"\n        }), \"\\n        elif line == \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\\\\\\\\end{table}\\\\n\\\"\"\n        }), \":\\n            flag = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"ENDTABLE\\\"\"\n        }), \"\\n\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" flag == \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"BEGINTABLE\\\"\"\n        }), \":\\n            tmp.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"append\"\n        }), \"(line)\\n        elif flag == \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"ENDTABLE\\\"\"\n        }), \":\\n            tmp.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"append\"\n        }), \"(line)\\n            flag = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"CAPTION\\\"\"\n        }), \"\\n        elif flag == \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"CAPTION\\\"\"\n        }), \":\\n            tmp.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"append\"\n        }), \"(line)\\n            flag = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"MARKDOWN\\\"\"\n        }), \"\\n            \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"print\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'-'\"\n        }), \" * \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"100\"\n        }), \")\\n            \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"print\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"''\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"join\"\n        }), \"(tmp))\\n            res.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"append\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"''\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"join\"\n        }), \"(tmp))\\n            tmp = []\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" res\\n\\nfile_path = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"YOUR_PDF_PATH\\\"\"\n        }), \"\\noutput_dir = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"YOUR_OUTPUT_DIR_PATH\\\"\"\n        }), \"\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"june_run_nougat\"\n        }), \"(file_path, output_dir) == \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \":\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" sys\\n    sys.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"exit\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \")\\n\\nmmd_path = output_dir + \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'/'\"\n        }), \" + os.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"path\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"splitext\"\n        }), \"(file_path)[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"].\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"split\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'/'\"\n        }), \")[-\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"] + \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\".mmd\\\"\"\n        }), \"\\ntables = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"june_get_tables_from_mmd\"\n        }), \"(mmd_path)\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"함수 june_get_tables_from_mmd은 Figure 10에 표시된 mmd 파일에서 'table'부터 'table'까지의 모든 내용 및 'table' 다음 줄을 추출하는 데 사용됩니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-23-AdvancedRAG07ExploringRAGforTables_9.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"표 캡션을 표 아래에 배치해야 하거나 표가 'table'로 시작하고 'end'로 끝나야 한다는 것을 명시하는 공식 문서가 발견되지 않았다는 점을 유의하십시오. 따라서 june_get_tables_from_mmd는 휴리스틱입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"PDF에서 표를 구문 분석한 결과는 다음과 같습니다:\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"표 1: 다양한 레이어 유형에 대한 최대 경로 길이, 레이어당 복잡성 및 최소 순차 작업 수가 표시됩니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"표 2: Transformer가 영어-독일어 및 영어-프랑스어 newstest2014 테스트에서 이전 최신 모델보다 더 우수한 BLEU 점수를 달성하며 훈련 비용이 줄어드는 것을 보여줍니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"표 3: Transformer 아키텍처의 변형이 나열되어 있으며, 기본 모델 정보와 영어-독일어 번역 개발 세트 newstest2013에서의 모든 메트릭스가 제공됩니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"표 4: Transformer가 영어 구성 구문 분석에 잘 일반화되며, WSJ 23 섹션의 결과가 제시됩니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/assets/img/2024-05-23-AdvancedRAG07ExploringRAGforTables_10.png\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다중 벡터 리트리버를 사용하여 문서 요약 색인 구조를 구축해보세요.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"# 자식 청크를 색인화하는 데 사용할 벡터스토어\\nvectorstore = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Chroma\"\n        }), \"(collection_name = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"summaries\\\"\"\n        }), \", embedding_function = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"OpenAIEmbeddings\"\n        }), \"())\\n\\n# 상위 문서를 위한 저장소 레이어\\nstore = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"InMemoryStore\"\n        }), \"()\\nid_key = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"doc_id\\\"\"\n        }), \"\\n\\n# 리트리버 (시작할 때는 빈 상태)\\nretriever = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"MultiVectorRetriever\"\n        }), \"(\\n    vectorstore = vectorstore,\\n    docstore = store,\\n    id_key = id_key,\\n    search_kwargs={\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"k\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"} # 요청된 결과의 수가 색인 요소보다 큰 \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"4\"\n        }), \"이므로, n_results = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"로 업데이트하겠습니다\\n)\\n\\n# 테이블 추가\\ntable_ids = [\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"str\"\n        }), \"(uuid.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"uuid4\"\n        }), \"()) \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" _ \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" tables]\\nsummary_tables = [\\n    \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Document\"\n        }), \"(page_content = s, metadata = {\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"id_key\"\n        }), \": table_ids[i]})\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" i, s \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"enumerate\"\n        }), \"(table_summaries)\\n]\\nretriever.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"vectorstore\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"add_documents\"\n        }), \"(summary_tables)\\nretriever.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"docstore\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"mset\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"list\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"zip\"\n        }), \"(table_ids, tables)))\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"모든 준비가 되었습니다. 간단한 RAG 파이프라인을 구축하고 쿼리를 수행해보세요:\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"# 프롬프트 템플릿\\n템플릿 = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\\\"\"\n        }), _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"다음 콘텍스트를 기반으로 질문에 답하세요. 이는 텍스트와 테이블을 포함할 수 있으며 LaTeX 형식의 테이블과 일반 텍스트 형식의 테이블 캡션을 포함합니다:\\n{context}\\n질문: {question}\\n\\\"\"\n        }), _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\\\"\"\n        }), \"\\n프롬프트 = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ChatPromptTemplate\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"from_template\"\n        }), \"(템플릿)\\n\\n# \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"LLM\"\n        }), \"\\n모델 = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ChatOpenAI\"\n        }), \"(temperature = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", model = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"gpt-3.5-turbo\\\"\"\n        }), \")\\n\\n\\n# 간단한 \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"RAG\"\n        }), \" 파이프라인\\n체인 = (\\n    {\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"context\\\"\"\n        }), \": retriever, \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"question\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"RunnablePassthrough\"\n        }), \"()}\\n    | 프롬프트\\n    | 모델\\n    | \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"StrOutputParser\"\n        }), \"()\\n)\\n\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"print\"\n        }), \"(체인.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"invoke\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"when layer type is Self-Attention, what is the Complexity per Layer?\\\"\"\n        }), \"))  # 테이블 \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"에 관한 쿼리\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"print\"\n        }), \"(체인.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"invoke\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Which parser performs worst for BLEU EN-DE\\\"\"\n        }), \"))  # 테이블 \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"2\"\n        }), \"에 관한 쿼리\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"print\"\n        }), \"(체인.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"invoke\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Which parser performs best for WSJ 23 F1\\\"\"\n        }), \"))  # 테이블 \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"4\"\n        }), \"에 관한 쿼리\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"아래는 실행 결과입니다. 여러 질문이 정확히 답변되었음을 보여주는데, 이는 도표 12에 나와 있습니다:\"\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/assets/img/2024-05-23-AdvancedRAG07ExploringRAGforTables_11.png\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"전체 코드는 아래와 같습니다:\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-python\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" os\\nos.environ[\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"OPENAI_API_KEY\\\"\"\n        }), \"] = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"YOUR_OPEN_AI_KEY\\\"\"\n        }), \"\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" subprocess\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" uuid\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" langchain_core.output_parsers \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" StrOutputParser\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" langchain_core.prompts \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" ChatPromptTemplate\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" langchain_openai \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" ChatOpenAI\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" langchain.retrievers.multi_vector \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" MultiVectorRetriever\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" langchain.storage \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" InMemoryStore\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" langchain_community.vectorstores \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" Chroma\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" langchain_core.documents \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" Document\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" langchain_openai \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" OpenAIEmbeddings\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" langchain_core.runnables \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" RunnablePassthrough\\n\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"def\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"june_run_nougat\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"file_path, output_dir\"\n        }), \"):\\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"# Run Nougat and store results as Mathpix Markdown\"\n        }), \"\\n    cmd = [\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"nougat\\\"\"\n        }), \", file_path, \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"-o\\\"\"\n        }), \", output_dir, \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"-m\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"0.1.0-base\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"--no-skipping\\\"\"\n        }), \"]\\n    res = subprocess.run(cmd)\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" res.returncode != \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \":\\n        \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"print\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Error when running nougat.\\\"\"\n        }), \")\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" res.returncode\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"else\"\n        }), \":\\n        \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"print\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Operation Completed!\\\"\"\n        }), \")\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"def\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"june_get_tables_from_mmd\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"mmd_path\"\n        }), \"):\\n    f = \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"open\"\n        }), \"(mmd_path)\\n    lines = f.readlines()\\n    res = []\\n    tmp = []\\n    flag = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\\\"\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" line \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" lines:\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" line == \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\\\\\\\\begin{table}\\\\n\\\"\"\n        }), \":\\n            flag = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"BEGINTABLE\\\"\"\n        }), \"\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"elif\"\n        }), \" line == \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\\\\\\\\end{table}\\\\n\\\"\"\n        }), \":\\n            flag = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"ENDTABLE\\\"\"\n        }), \"\\n\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" flag == \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"BEGINTABLE\\\"\"\n        }), \":\\n            tmp.append(line)\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"elif\"\n        }), \" flag == \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"ENDTABLE\\\"\"\n        }), \":\\n            tmp.append(line)\\n            flag = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"CAPTION\\\"\"\n        }), \"\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"elif\"\n        }), \" flag == \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"CAPTION\\\"\"\n        }), \":\\n            tmp.append(line)\\n            flag = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"MARKDOWN\\\"\"\n        }), \"\\n            \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"print\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'-'\"\n        }), \" * \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"100\"\n        }), \")\\n            \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"print\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"''\"\n        }), \".join(tmp))\\n            res.append(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"''\"\n        }), \".join(tmp))\\n            tmp = []\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" res\\n\\nfile_path = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"YOUR_PDF_PATH\\\"\"\n        }), \"\\noutput_dir = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"YOUR_OUTPUT_DIR_PATH\\\"\"\n        }), \"\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" june_run_nougat(file_path, output_dir) == \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \":\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" sys\\n    sys.exit(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \")\\n\\nmmd_path = output_dir + \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'/'\"\n        }), \" + os.path.splitext(file_path)[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"].split(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'/'\"\n        }), \")[-\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"] + \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\".mmd\\\"\"\n        }), \"\\ntables = june_get_tables_from_mmd(mmd_path)\\n\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"# Prompt\"\n        }), \"\\nprompt_text = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\\\"\\\"You are an assistant tasked with summarizing tables and text. \\\\\\nGive a concise summary of the table or text. The table is formatted in LaTeX, and its caption is in plain text format: {element}  \\\"\\\"\\\"\"\n        }), \"\\nprompt = ChatPromptTemplate.from_template(prompt_text)\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"# Summary chain\"\n        }), \"\\nmodel = ChatOpenAI(temperature = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", model = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"gpt-3.5-turbo\\\"\"\n        }), \")\\nsummarize_chain = {\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"element\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"lambda\"\n        }), \" x: x} | prompt | model | StrOutputParser()\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"# Get table summaries\"\n        }), \"\\ntable_summaries = summarize_chain.batch(tables, {\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"max_concurrency\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"5\"\n        }), \"})\\n\", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"print\"\n        }), \"(table_summaries)\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"# The vectorstore to use to index the child chunks\"\n        }), \"\\nvectorstore = Chroma(collection_name = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"summaries\\\"\"\n        }), \", embedding_function = OpenAIEmbeddings())\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"# The storage layer for the parent documents\"\n        }), \"\\nstore = InMemoryStore()\\nid_key = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"doc_id\\\"\"\n        }), \"\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"# The retriever (empty to start)\"\n        }), \"\\nretriever = MultiVectorRetriever(\\n    vectorstore = vectorstore,\\n    docstore = store,\\n    id_key = id_key,\\n    search_kwargs={\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"k\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"} \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"# Solving Number of requested results 4 is greater than number of elements in index..., updating n_results = 1\"\n        }), \"\\n)\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"# Add tables\"\n        }), \"\\ntable_ids = [\", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"str\"\n        }), \"(uuid.uuid4()) \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" _ \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" tables]\\nsummary_tables = [\\n    Document(page_content = s, metadata = {id_key: table_ids[i]})\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" i, s \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"enumerate\"\n        }), \"(table_summaries)\\n]\\nretriever.vectorstore.add_documents(summary_tables)\\nretriever.docstore.mset(\", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"list\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"zip\"\n        }), \"(table_ids, tables)))\\n\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"# Prompt template\"\n        }), \"\\ntemplate = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\\\"\\\"Answer the question based only on the following context, which can include text and tables, there is a table in LaTeX format and a table caption in plain text format:\\n{context}\\nQuestion: {question}\\n\\\"\\\"\\\"\"\n        }), \"\\nprompt = ChatPromptTemplate.from_template(template)\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"# LLM\"\n        }), \"\\nmodel = ChatOpenAI(temperature = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", model = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"gpt-3.5-turbo\\\"\"\n        }), \")\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"# Simple RAG pipeline\"\n        }), \"\\nchain = (\\n    {\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"context\\\"\"\n        }), \": retriever, \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"question\\\"\"\n        }), \": RunnablePassthrough()}\\n    | prompt\\n    | model\\n    | StrOutputParser()\\n)\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"print\"\n        }), \"(chain.invoke(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"when layer type is Self-Attention, what is the Complexity per Layer?\\\"\"\n        }), \"))  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"# Query about table 1\"\n        }), \"\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"print\"\n        }), \"(chain.invoke(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Which parser performs worst for BLEU EN-DE\\\"\"\n        }), \"))  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"# Query about table 2\"\n        }), \"\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"print\"\n        }), \"(chain.invoke(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Which parser performs best for WSJ 23 F1\\\"\"\n        }), \"))  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"# Query about table 4\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"결론\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 글에서는 RAG 프로세스 중 표 처리를 위한 주요 기술과 기존 솔루션을 논의하고 구현과 함께 해결책을 제안합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 문서에서는 표를 파싱하는 데 nougat을 사용합니다. 그러나 더 빠르고 효과적인 파싱 도구가 있다면 nougat을 대체 고려할 것입니다. 우리의 도구에 대한 태도는 먼저 올바른 아이디어를 가지고, 그런 다음 도구를 찾아 실현하는 것에 있으며, 특정 도구에 의존하는 대신입니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 기사에서는 모든 테이블 콘텐츠를 LLM에 입력합니다. 그러나 실제 시나리오에서는 표가 LLM 콘텍스트 길이를 초과하는 경우를 고려해야 합니다. 이 문제를 효과적인 청킹 방법을 사용하여 해결할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"RAG 기술에 관심이 있다면, 다른 기사들도 확인해보세요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그리고 최신 AI 관련 콘텐츠는 제 뉴스레터에서 찾을 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"마지막으로, 이 기사에 오류나 누락된 내용이 있다면, 또는 궁금한 점이 있으면 댓글 섹션에서 언급해 주세요.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"친근한 어조로 번역한 내용 🚀\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"In Plain English 커뮤니티에 참여해 주셔서 감사합니다! 그 전에:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"저희 작가를 박수로 응원하고 팔로우해 주세요️👏️\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"저희를 팔로우하세요: X | LinkedIn | YouTube | Discord | Newsletter\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"다른 플랫폼도 방문해 보세요: Stackademic | CoFeed | Venture | Cubed\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"더 많은 콘텐츠를 만나실 수 있습니다: PlainEnglish.io\"\n      }), \"\\n\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-23-AdvancedRAG07ExploringRAGforTables"},"buildId":"PgdIX9e0tvkvkdAmDT6qR","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>