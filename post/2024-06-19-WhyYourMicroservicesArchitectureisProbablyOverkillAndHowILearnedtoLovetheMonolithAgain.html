<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>왜 당신의 마이크로서비스 아키텍처가 아마도 지나치게 복잡한 지에 대해 그리고 어떻게 다시 단일체를 사랑하게 되었는지 알아보겠습니다 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-06-19-WhyYourMicroservicesArchitectureisProbablyOverkillAndHowILearnedtoLovetheMonolithAgain" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="왜 당신의 마이크로서비스 아키텍처가 아마도 지나치게 복잡한 지에 대해 그리고 어떻게 다시 단일체를 사랑하게 되었는지 알아보겠습니다 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="왜 당신의 마이크로서비스 아키텍처가 아마도 지나치게 복잡한 지에 대해 그리고 어떻게 다시 단일체를 사랑하게 되었는지 알아보겠습니다 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-19-WhyYourMicroservicesArchitectureisProbablyOverkillAndHowILearnedtoLovetheMonolithAgain_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-06-19-WhyYourMicroservicesArchitectureisProbablyOverkillAndHowILearnedtoLovetheMonolithAgain" data-gatsby-head="true"/><meta name="twitter:title" content="왜 당신의 마이크로서비스 아키텍처가 아마도 지나치게 복잡한 지에 대해 그리고 어떻게 다시 단일체를 사랑하게 되었는지 알아보겠습니다 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-19-WhyYourMicroservicesArchitectureisProbablyOverkillAndHowILearnedtoLovetheMonolithAgain_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-19 12:09" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-4f7b40c1114f0d09.js" defer=""></script><script src="/_next/static/-dPCbnM2yhdKNgXe92VJV/_buildManifest.js" defer=""></script><script src="/_next/static/-dPCbnM2yhdKNgXe92VJV/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">왜 당신의 마이크로서비스 아키텍처가 아마도 지나치게 복잡한 지에 대해 그리고 어떻게 다시 단일체를 사랑하게 되었는지 알아보겠습니다</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="왜 당신의 마이크로서비스 아키텍처가 아마도 지나치게 복잡한 지에 대해 그리고 어떻게 다시 단일체를 사랑하게 되었는지 알아보겠습니다" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 19, 2024</span><span class="posts_reading_time__f7YPP">5<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-19-WhyYourMicroservicesArchitectureisProbablyOverkillAndHowILearnedtoLovetheMonolithAgain&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>작은 독립적인 서비스들이 각각 완벽하게 자신의 일을 하는 것, 개발자의 낙원 같지 않아요? 하지만 알아요? 가끔, 이건 정말 엄청난 고통일 수 있어요.</p>
<p>저는 이 허세에 홀렸었어요.</p>
<p>우리는 새 시스템을 구축하고 있었는데, '올바른' 방식으로 하겠다고 다짐했어요. 익숙한 거대한 단일체는 밖으로, 작은 마이크로서비스 떼가 들어왔어요. 처음에는 놀랍게 느껴졌어요 — 너무 깨끗하고, 너무 모듈화됐잖아요!</p>
<p>하지만 현실이 닥쳤어요.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>결과는, 복잡성이 사라지지 않았습니다; 단지 변했습니다. 이것이 마이크로서비스가 당신의 영혼을 죽일 수 있는 이유입니다:</p>
<h1>수다스러운 캐시 문제</h1>
<p>이전에는 동일한 코드베이스에서 함수를 호출할 수 있었던 것을 기억하시나요? 이제 여러분의 절반 서비스는 네트워크 상에서 수다 떨고 있습니다. 그 중 하나가 성을 내면? 그 난장판을 디버깅하는 데는 행운이 필요할 겁니다.</p>
<p>한 번은 간단했던 함수 호출이 교차 서비스 요청의 끝없는 사가로 변모하고 있습니다. 지연과 관련된 머리 아픔, 네트워크 어딘가에서 뭔가가 고장날까 두려워하는 늘스런 공포의 상태로 변해가고 있습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>일렇게 REST API와 메시지 큐를 사용하여 처리할 수 있을 것이라 생각할 수도 있지만, 사실은 그 소중한 밀리초가 누적됩니다. 작은 데이터 조각을 가져와야 하나요? 그것은 네트워크 호출입니다. 간단한 작업을 처리해야 하나요? 또 다른 호출이 필요합니다. 여러분의 시스템은 실제 일을 하는 대신 수다에 더 많은 시간을 낭비합니다.</p>
<p>그런 다음, 불가피한 일이 벌어집니다. 여러분의 서비스 중 하나가 오동작하면 네트워크 타임아웃을 발생시키거나 엉망으로 된 데이터를 뱉어 냅니다. 그 속을 해체하는 과정을 즐기세요. 분산 디버깅은 분실된 양말을 찾는 것처럼 쉽지 않습니다. 각 네트워크 호프는 또 다른 용의자, 여러분의 비통의 근원이 될 수 있는 복잡성의 또 다른 층입니다.</p>
<h1>배포 지옥</h1>
<p>코드를 배포했을 때 직업을 바꾸어 야만한 일이 되려고 하거나 라마 농부가 되고 싶어졌던 기억을 여전히 갖고 계시나요? 네, 그런 날들은 이미 멀리 떠났습니다. 마이크로서비스로, 관리 가능한 프로세스였던 것이 불길한 기분을 내뿜는 다두와 여러 머리를 지닌 괴물로 변모했습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>갑자기 어플리케이션 하나가 아니라 십여 개의 작은 괴물을 다루게 되었네요. 각각이 자체 빌드 프로세스, 테스트 슈트 및 신중한 조율이 필요해요. CI/CD 파이프라인은 이렇게 엄청난, 꼬인 루브 골드버그 장치가 되어 새롭고 흥미로운 실패로 매번 고장나는 것처럼 보여요. 잘못된 구성 하나, 맞지 않는 종속성 하나로 모든 것이 터져버릴 수 있어요. 배포 오류와 싸우면서 실제 기능 개발은 멈춰있게 되네요. 코드 복잡성을 운영 복잡성과 바꾸었군요.</p>
<h1>관찰성 부담</h1>
<p>과거 몇몇 전략적으로 배치된 로그 라인으로 무엇이 문제인지 알 수 있던 시절을 기억하시나요? 마이크로서비스로, 그런 시기는 이미 멀리 사라진 기억이 됐어요. 이제는 시스템을 이해하는 데 상당한 투자가 필요할 거예요.</p>
<p>서비스 사이를 건너는 요청을 추적하려면 분산 추적 솔루션이 필요할 건데요. 서비스가 생성하는 로그의 해일을 해석하려면 로그 집계 도구가 기다리고 있어요. 그리고 멋진 대시보드와 경보 시스템을 잊지 마세요.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>갑자기 예산과 엔지니어링 시간이 시스템이 제대로 작동하는지 확인하는 데 사용되는 것으로 바뀌었네요. 모순적인 점은, 이 모든 복잡성을 더한 결과물로 인해 문제의 근본 원인을 찾기가 이전보다 더 어려워졌다는 느낌을 자주 받습니다. 당신은 가시성의 환상에 큰 대가를 지불하고 있는 것 같습니다.</p>
<h1>그들은 그리 독립적이지 않아요</h1>
<p>마이크로서비스의 전체 약속은 느슨하게 결합되고 서로 교환 가능한 조각들의 아름다운 비전인데, 사실은 종종 많은 허세였던 것으로 밝혀졌어요. 실제로 "독립적"인 서비스들이 의외로 얽혀있는 방식으로 복잡해 집니다.</p>
<p>한 서비스의 API를 조정하면 어떤 결과도 없을 것이라고 생각하시나요? 한 번 더 생각해보세요. 숨겨진 가정, 문서화되지 않은 의존성, 그리고 행동의 미묘한 변화들이 불량한 음식 중독과 같이 시스템 전반을 퍼져나갈 수 있습니다. 당신이 알게 모르게, 여러 팀에 걸쳐 다시 작업에 뛰어들어서 왜 이러한 열광을 사들인 걸까 궁금해할 수도 있어요. 민첩성에 대한 약속에 대해 말할 수 없다 — 이제 당신은 아무것도 바꾸기를 두려워할 정도로 두려워하게 되었습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>단일체만큼 좋은 경우도 있어요</h1>
<p>잠시 동안 독단적인 견해를 내려 놓아 보죠. 구성 요소들이 본질적으로 연결되어 있는 작은 프로젝트, 팀 또는 시스템의 경우, 단일체는 생명보호병이 될 수도 있어요. 이는 단순함을 추구하여 유행성을 포기하는 것과도 같아요.</p>
<p>생각해 보세요: 네트워크 지연 문제가 없고, 디버깅이 간단하며 울고 싶지 않게 배포할 수 있는 장점이 있어요. 확실히 성장하면 조금 엉망일 수 있지만, 코드베이스 내 신중한 모듈화로 그것을 완화할 수 있어요. 그리고 솔직히 말하자면, 잘못 설계된 마이크로서비스 시스템이 보잘것없이 퍼져나가는 모습은 그다지 즐겁지 않아요.</p>
<p>나쁜 말 안 하겠습니다. 마이크로서비스가 나쁜 것은 아니에요. 그것들은 대규모 시스템에서 빛을 발하거나, 구성 요소 간에 완전한 독립성이 필요한 경우에 유용해요. 하지만 맹목적으로 트렌드를 따라가서 모든 것을 마이크로서비스로 분리하는 것은 정말로 무분별한 복잡성과 개발자의 탈진으로 이어지는 결과를 초래할 수도 있어요.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>가끔 "옛날 방식"의 단일체가 더 현명한 선택일 수 있습니다. 인프라와 무쟁하기보다는 가치 전달에 집중할 수 있게 해줍니다.</p>
<p>나는 반드시 마이크로서비스를 비판하는 것은 아닙니다. 특히 확장성이 중요한 대규모 복잡한 시스템에서 유용할 수 있습니다. 그러나 기술 세계는 항상 최신 유행을 지나치게 홍보하여 검증된 솔루션을 낡은 것으로 여기게 만드는 나쁜 버릇이 있습니다.</p>
<p>쿨한 것을 하고 있는 친구들이 그렇게 하고 있다고 해서 우리도 모든 애플리케이션을 마이크로서비스로 나누는 것을 맹목적으로 따라갈 필요는 없습니다. 한 발 물러나서 프로젝트의 필요를 정직하게 평가하고, 복잡성 대비가 정말 그만한지 고려해보세요. 잘 설계된 단일체가 작업 부담이 적게 더해도 동일한 기능을 제공할 수 있는 경우에는 왜 그것을 선택하지 않을까요?</p>
<p>마이크로서비스가 디폴트일 필요는 없습니다; 이는 의도적인 결정이어야 합니다. 독단적인 사고를 버리고 더 실용적인 접근 방식을 채택합시다 — 적합한 도구가 승리하는 아키텍처. 가장 유행하는 것이 아니더라도. 아니, 혹시 서면이 잘 갖춰진 단일체의 간결함에 대한 새로운 감사함을 발견할지도 모릅니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"왜 당신의 마이크로서비스 아키텍처가 아마도 지나치게 복잡한 지에 대해 그리고 어떻게 다시 단일체를 사랑하게 되었는지 알아보겠습니다","description":"","date":"2024-06-19 12:09","slug":"2024-06-19-WhyYourMicroservicesArchitectureisProbablyOverkillAndHowILearnedtoLovetheMonolithAgain","content":"\n작은 독립적인 서비스들이 각각 완벽하게 자신의 일을 하는 것, 개발자의 낙원 같지 않아요? 하지만 알아요? 가끔, 이건 정말 엄청난 고통일 수 있어요.\n\n저는 이 허세에 홀렸었어요.\n\n우리는 새 시스템을 구축하고 있었는데, '올바른' 방식으로 하겠다고 다짐했어요. 익숙한 거대한 단일체는 밖으로, 작은 마이크로서비스 떼가 들어왔어요. 처음에는 놀랍게 느껴졌어요 — 너무 깨끗하고, 너무 모듈화됐잖아요!\n\n하지만 현실이 닥쳤어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n결과는, 복잡성이 사라지지 않았습니다; 단지 변했습니다. 이것이 마이크로서비스가 당신의 영혼을 죽일 수 있는 이유입니다:\n\n# 수다스러운 캐시 문제\n\n이전에는 동일한 코드베이스에서 함수를 호출할 수 있었던 것을 기억하시나요? 이제 여러분의 절반 서비스는 네트워크 상에서 수다 떨고 있습니다. 그 중 하나가 성을 내면? 그 난장판을 디버깅하는 데는 행운이 필요할 겁니다.\n\n한 번은 간단했던 함수 호출이 교차 서비스 요청의 끝없는 사가로 변모하고 있습니다. 지연과 관련된 머리 아픔, 네트워크 어딘가에서 뭔가가 고장날까 두려워하는 늘스런 공포의 상태로 변해가고 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n일렇게 REST API와 메시지 큐를 사용하여 처리할 수 있을 것이라 생각할 수도 있지만, 사실은 그 소중한 밀리초가 누적됩니다. 작은 데이터 조각을 가져와야 하나요? 그것은 네트워크 호출입니다. 간단한 작업을 처리해야 하나요? 또 다른 호출이 필요합니다. 여러분의 시스템은 실제 일을 하는 대신 수다에 더 많은 시간을 낭비합니다.\n\n그런 다음, 불가피한 일이 벌어집니다. 여러분의 서비스 중 하나가 오동작하면 네트워크 타임아웃을 발생시키거나 엉망으로 된 데이터를 뱉어 냅니다. 그 속을 해체하는 과정을 즐기세요. 분산 디버깅은 분실된 양말을 찾는 것처럼 쉽지 않습니다. 각 네트워크 호프는 또 다른 용의자, 여러분의 비통의 근원이 될 수 있는 복잡성의 또 다른 층입니다.\n\n# 배포 지옥\n\n코드를 배포했을 때 직업을 바꾸어 야만한 일이 되려고 하거나 라마 농부가 되고 싶어졌던 기억을 여전히 갖고 계시나요? 네, 그런 날들은 이미 멀리 떠났습니다. 마이크로서비스로, 관리 가능한 프로세스였던 것이 불길한 기분을 내뿜는 다두와 여러 머리를 지닌 괴물로 변모했습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n갑자기 어플리케이션 하나가 아니라 십여 개의 작은 괴물을 다루게 되었네요. 각각이 자체 빌드 프로세스, 테스트 슈트 및 신중한 조율이 필요해요. CI/CD 파이프라인은 이렇게 엄청난, 꼬인 루브 골드버그 장치가 되어 새롭고 흥미로운 실패로 매번 고장나는 것처럼 보여요. 잘못된 구성 하나, 맞지 않는 종속성 하나로 모든 것이 터져버릴 수 있어요. 배포 오류와 싸우면서 실제 기능 개발은 멈춰있게 되네요. 코드 복잡성을 운영 복잡성과 바꾸었군요.\n\n# 관찰성 부담\n\n과거 몇몇 전략적으로 배치된 로그 라인으로 무엇이 문제인지 알 수 있던 시절을 기억하시나요? 마이크로서비스로, 그런 시기는 이미 멀리 사라진 기억이 됐어요. 이제는 시스템을 이해하는 데 상당한 투자가 필요할 거예요.\n\n서비스 사이를 건너는 요청을 추적하려면 분산 추적 솔루션이 필요할 건데요. 서비스가 생성하는 로그의 해일을 해석하려면 로그 집계 도구가 기다리고 있어요. 그리고 멋진 대시보드와 경보 시스템을 잊지 마세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n갑자기 예산과 엔지니어링 시간이 시스템이 제대로 작동하는지 확인하는 데 사용되는 것으로 바뀌었네요. 모순적인 점은, 이 모든 복잡성을 더한 결과물로 인해 문제의 근본 원인을 찾기가 이전보다 더 어려워졌다는 느낌을 자주 받습니다. 당신은 가시성의 환상에 큰 대가를 지불하고 있는 것 같습니다.\n\n# 그들은 그리 독립적이지 않아요\n\n마이크로서비스의 전체 약속은 느슨하게 결합되고 서로 교환 가능한 조각들의 아름다운 비전인데, 사실은 종종 많은 허세였던 것으로 밝혀졌어요. 실제로 \"독립적\"인 서비스들이 의외로 얽혀있는 방식으로 복잡해 집니다.\n\n한 서비스의 API를 조정하면 어떤 결과도 없을 것이라고 생각하시나요? 한 번 더 생각해보세요. 숨겨진 가정, 문서화되지 않은 의존성, 그리고 행동의 미묘한 변화들이 불량한 음식 중독과 같이 시스템 전반을 퍼져나갈 수 있습니다. 당신이 알게 모르게, 여러 팀에 걸쳐 다시 작업에 뛰어들어서 왜 이러한 열광을 사들인 걸까 궁금해할 수도 있어요. 민첩성에 대한 약속에 대해 말할 수 없다 — 이제 당신은 아무것도 바꾸기를 두려워할 정도로 두려워하게 되었습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 단일체만큼 좋은 경우도 있어요\n\n잠시 동안 독단적인 견해를 내려 놓아 보죠. 구성 요소들이 본질적으로 연결되어 있는 작은 프로젝트, 팀 또는 시스템의 경우, 단일체는 생명보호병이 될 수도 있어요. 이는 단순함을 추구하여 유행성을 포기하는 것과도 같아요.\n\n생각해 보세요: 네트워크 지연 문제가 없고, 디버깅이 간단하며 울고 싶지 않게 배포할 수 있는 장점이 있어요. 확실히 성장하면 조금 엉망일 수 있지만, 코드베이스 내 신중한 모듈화로 그것을 완화할 수 있어요. 그리고 솔직히 말하자면, 잘못 설계된 마이크로서비스 시스템이 보잘것없이 퍼져나가는 모습은 그다지 즐겁지 않아요.\n\n나쁜 말 안 하겠습니다. 마이크로서비스가 나쁜 것은 아니에요. 그것들은 대규모 시스템에서 빛을 발하거나, 구성 요소 간에 완전한 독립성이 필요한 경우에 유용해요. 하지만 맹목적으로 트렌드를 따라가서 모든 것을 마이크로서비스로 분리하는 것은 정말로 무분별한 복잡성과 개발자의 탈진으로 이어지는 결과를 초래할 수도 있어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n가끔 \"옛날 방식\"의 단일체가 더 현명한 선택일 수 있습니다. 인프라와 무쟁하기보다는 가치 전달에 집중할 수 있게 해줍니다.\n\n나는 반드시 마이크로서비스를 비판하는 것은 아닙니다. 특히 확장성이 중요한 대규모 복잡한 시스템에서 유용할 수 있습니다. 그러나 기술 세계는 항상 최신 유행을 지나치게 홍보하여 검증된 솔루션을 낡은 것으로 여기게 만드는 나쁜 버릇이 있습니다.\n\n쿨한 것을 하고 있는 친구들이 그렇게 하고 있다고 해서 우리도 모든 애플리케이션을 마이크로서비스로 나누는 것을 맹목적으로 따라갈 필요는 없습니다. 한 발 물러나서 프로젝트의 필요를 정직하게 평가하고, 복잡성 대비가 정말 그만한지 고려해보세요. 잘 설계된 단일체가 작업 부담이 적게 더해도 동일한 기능을 제공할 수 있는 경우에는 왜 그것을 선택하지 않을까요?\n\n마이크로서비스가 디폴트일 필요는 없습니다; 이는 의도적인 결정이어야 합니다. 독단적인 사고를 버리고 더 실용적인 접근 방식을 채택합시다 — 적합한 도구가 승리하는 아키텍처. 가장 유행하는 것이 아니더라도. 아니, 혹시 서면이 잘 갖춰진 단일체의 간결함에 대한 새로운 감사함을 발견할지도 모릅니다.\n","ogImage":{"url":"/assets/img/2024-06-19-WhyYourMicroservicesArchitectureisProbablyOverkillAndHowILearnedtoLovetheMonolithAgain_0.png"},"coverImage":"/assets/img/2024-06-19-WhyYourMicroservicesArchitectureisProbablyOverkillAndHowILearnedtoLovetheMonolithAgain_0.png","tag":["Tech"],"readingTime":5},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e작은 독립적인 서비스들이 각각 완벽하게 자신의 일을 하는 것, 개발자의 낙원 같지 않아요? 하지만 알아요? 가끔, 이건 정말 엄청난 고통일 수 있어요.\u003c/p\u003e\n\u003cp\u003e저는 이 허세에 홀렸었어요.\u003c/p\u003e\n\u003cp\u003e우리는 새 시스템을 구축하고 있었는데, '올바른' 방식으로 하겠다고 다짐했어요. 익숙한 거대한 단일체는 밖으로, 작은 마이크로서비스 떼가 들어왔어요. 처음에는 놀랍게 느껴졌어요 — 너무 깨끗하고, 너무 모듈화됐잖아요!\u003c/p\u003e\n\u003cp\u003e하지만 현실이 닥쳤어요.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e결과는, 복잡성이 사라지지 않았습니다; 단지 변했습니다. 이것이 마이크로서비스가 당신의 영혼을 죽일 수 있는 이유입니다:\u003c/p\u003e\n\u003ch1\u003e수다스러운 캐시 문제\u003c/h1\u003e\n\u003cp\u003e이전에는 동일한 코드베이스에서 함수를 호출할 수 있었던 것을 기억하시나요? 이제 여러분의 절반 서비스는 네트워크 상에서 수다 떨고 있습니다. 그 중 하나가 성을 내면? 그 난장판을 디버깅하는 데는 행운이 필요할 겁니다.\u003c/p\u003e\n\u003cp\u003e한 번은 간단했던 함수 호출이 교차 서비스 요청의 끝없는 사가로 변모하고 있습니다. 지연과 관련된 머리 아픔, 네트워크 어딘가에서 뭔가가 고장날까 두려워하는 늘스런 공포의 상태로 변해가고 있습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e일렇게 REST API와 메시지 큐를 사용하여 처리할 수 있을 것이라 생각할 수도 있지만, 사실은 그 소중한 밀리초가 누적됩니다. 작은 데이터 조각을 가져와야 하나요? 그것은 네트워크 호출입니다. 간단한 작업을 처리해야 하나요? 또 다른 호출이 필요합니다. 여러분의 시스템은 실제 일을 하는 대신 수다에 더 많은 시간을 낭비합니다.\u003c/p\u003e\n\u003cp\u003e그런 다음, 불가피한 일이 벌어집니다. 여러분의 서비스 중 하나가 오동작하면 네트워크 타임아웃을 발생시키거나 엉망으로 된 데이터를 뱉어 냅니다. 그 속을 해체하는 과정을 즐기세요. 분산 디버깅은 분실된 양말을 찾는 것처럼 쉽지 않습니다. 각 네트워크 호프는 또 다른 용의자, 여러분의 비통의 근원이 될 수 있는 복잡성의 또 다른 층입니다.\u003c/p\u003e\n\u003ch1\u003e배포 지옥\u003c/h1\u003e\n\u003cp\u003e코드를 배포했을 때 직업을 바꾸어 야만한 일이 되려고 하거나 라마 농부가 되고 싶어졌던 기억을 여전히 갖고 계시나요? 네, 그런 날들은 이미 멀리 떠났습니다. 마이크로서비스로, 관리 가능한 프로세스였던 것이 불길한 기분을 내뿜는 다두와 여러 머리를 지닌 괴물로 변모했습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e갑자기 어플리케이션 하나가 아니라 십여 개의 작은 괴물을 다루게 되었네요. 각각이 자체 빌드 프로세스, 테스트 슈트 및 신중한 조율이 필요해요. CI/CD 파이프라인은 이렇게 엄청난, 꼬인 루브 골드버그 장치가 되어 새롭고 흥미로운 실패로 매번 고장나는 것처럼 보여요. 잘못된 구성 하나, 맞지 않는 종속성 하나로 모든 것이 터져버릴 수 있어요. 배포 오류와 싸우면서 실제 기능 개발은 멈춰있게 되네요. 코드 복잡성을 운영 복잡성과 바꾸었군요.\u003c/p\u003e\n\u003ch1\u003e관찰성 부담\u003c/h1\u003e\n\u003cp\u003e과거 몇몇 전략적으로 배치된 로그 라인으로 무엇이 문제인지 알 수 있던 시절을 기억하시나요? 마이크로서비스로, 그런 시기는 이미 멀리 사라진 기억이 됐어요. 이제는 시스템을 이해하는 데 상당한 투자가 필요할 거예요.\u003c/p\u003e\n\u003cp\u003e서비스 사이를 건너는 요청을 추적하려면 분산 추적 솔루션이 필요할 건데요. 서비스가 생성하는 로그의 해일을 해석하려면 로그 집계 도구가 기다리고 있어요. 그리고 멋진 대시보드와 경보 시스템을 잊지 마세요.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e갑자기 예산과 엔지니어링 시간이 시스템이 제대로 작동하는지 확인하는 데 사용되는 것으로 바뀌었네요. 모순적인 점은, 이 모든 복잡성을 더한 결과물로 인해 문제의 근본 원인을 찾기가 이전보다 더 어려워졌다는 느낌을 자주 받습니다. 당신은 가시성의 환상에 큰 대가를 지불하고 있는 것 같습니다.\u003c/p\u003e\n\u003ch1\u003e그들은 그리 독립적이지 않아요\u003c/h1\u003e\n\u003cp\u003e마이크로서비스의 전체 약속은 느슨하게 결합되고 서로 교환 가능한 조각들의 아름다운 비전인데, 사실은 종종 많은 허세였던 것으로 밝혀졌어요. 실제로 \"독립적\"인 서비스들이 의외로 얽혀있는 방식으로 복잡해 집니다.\u003c/p\u003e\n\u003cp\u003e한 서비스의 API를 조정하면 어떤 결과도 없을 것이라고 생각하시나요? 한 번 더 생각해보세요. 숨겨진 가정, 문서화되지 않은 의존성, 그리고 행동의 미묘한 변화들이 불량한 음식 중독과 같이 시스템 전반을 퍼져나갈 수 있습니다. 당신이 알게 모르게, 여러 팀에 걸쳐 다시 작업에 뛰어들어서 왜 이러한 열광을 사들인 걸까 궁금해할 수도 있어요. 민첩성에 대한 약속에 대해 말할 수 없다 — 이제 당신은 아무것도 바꾸기를 두려워할 정도로 두려워하게 되었습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e단일체만큼 좋은 경우도 있어요\u003c/h1\u003e\n\u003cp\u003e잠시 동안 독단적인 견해를 내려 놓아 보죠. 구성 요소들이 본질적으로 연결되어 있는 작은 프로젝트, 팀 또는 시스템의 경우, 단일체는 생명보호병이 될 수도 있어요. 이는 단순함을 추구하여 유행성을 포기하는 것과도 같아요.\u003c/p\u003e\n\u003cp\u003e생각해 보세요: 네트워크 지연 문제가 없고, 디버깅이 간단하며 울고 싶지 않게 배포할 수 있는 장점이 있어요. 확실히 성장하면 조금 엉망일 수 있지만, 코드베이스 내 신중한 모듈화로 그것을 완화할 수 있어요. 그리고 솔직히 말하자면, 잘못 설계된 마이크로서비스 시스템이 보잘것없이 퍼져나가는 모습은 그다지 즐겁지 않아요.\u003c/p\u003e\n\u003cp\u003e나쁜 말 안 하겠습니다. 마이크로서비스가 나쁜 것은 아니에요. 그것들은 대규모 시스템에서 빛을 발하거나, 구성 요소 간에 완전한 독립성이 필요한 경우에 유용해요. 하지만 맹목적으로 트렌드를 따라가서 모든 것을 마이크로서비스로 분리하는 것은 정말로 무분별한 복잡성과 개발자의 탈진으로 이어지는 결과를 초래할 수도 있어요.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e가끔 \"옛날 방식\"의 단일체가 더 현명한 선택일 수 있습니다. 인프라와 무쟁하기보다는 가치 전달에 집중할 수 있게 해줍니다.\u003c/p\u003e\n\u003cp\u003e나는 반드시 마이크로서비스를 비판하는 것은 아닙니다. 특히 확장성이 중요한 대규모 복잡한 시스템에서 유용할 수 있습니다. 그러나 기술 세계는 항상 최신 유행을 지나치게 홍보하여 검증된 솔루션을 낡은 것으로 여기게 만드는 나쁜 버릇이 있습니다.\u003c/p\u003e\n\u003cp\u003e쿨한 것을 하고 있는 친구들이 그렇게 하고 있다고 해서 우리도 모든 애플리케이션을 마이크로서비스로 나누는 것을 맹목적으로 따라갈 필요는 없습니다. 한 발 물러나서 프로젝트의 필요를 정직하게 평가하고, 복잡성 대비가 정말 그만한지 고려해보세요. 잘 설계된 단일체가 작업 부담이 적게 더해도 동일한 기능을 제공할 수 있는 경우에는 왜 그것을 선택하지 않을까요?\u003c/p\u003e\n\u003cp\u003e마이크로서비스가 디폴트일 필요는 없습니다; 이는 의도적인 결정이어야 합니다. 독단적인 사고를 버리고 더 실용적인 접근 방식을 채택합시다 — 적합한 도구가 승리하는 아키텍처. 가장 유행하는 것이 아니더라도. 아니, 혹시 서면이 잘 갖춰진 단일체의 간결함에 대한 새로운 감사함을 발견할지도 모릅니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-19-WhyYourMicroservicesArchitectureisProbablyOverkillAndHowILearnedtoLovetheMonolithAgain"},"buildId":"-dPCbnM2yhdKNgXe92VJV","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>