<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>AWS에서 이벤트 기반 아키텍처에 분산 회로 차단기 적용 방법 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-06-23-DistributedCircuitBreakersinEvent-DrivenArchitecturesonAWS" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="AWS에서 이벤트 기반 아키텍처에 분산 회로 차단기 적용 방법 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="AWS에서 이벤트 기반 아키텍처에 분산 회로 차단기 적용 방법 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-23-DistributedCircuitBreakersinEvent-DrivenArchitecturesonAWS_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-06-23-DistributedCircuitBreakersinEvent-DrivenArchitecturesonAWS" data-gatsby-head="true"/><meta name="twitter:title" content="AWS에서 이벤트 기반 아키텍처에 분산 회로 차단기 적용 방법 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-23-DistributedCircuitBreakersinEvent-DrivenArchitecturesonAWS_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-23 00:26" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-4f7b40c1114f0d09.js" defer=""></script><script src="/_next/static/bb_yO9GbCvdfc_n71SfUf/_buildManifest.js" defer=""></script><script src="/_next/static/bb_yO9GbCvdfc_n71SfUf/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">AWS에서 이벤트 기반 아키텍처에 분산 회로 차단기 적용 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="AWS에서 이벤트 기반 아키텍처에 분산 회로 차단기 적용 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 23, 2024</span><span class="posts_reading_time__f7YPP">15<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-23-DistributedCircuitBreakersinEvent-DrivenArchitecturesonAWS&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="%22https://miro.medium.com/v2/resize:fit:1280/1*gGh7HhACzjtw6wplLPUyQQ.gif%22" alt="image"></p>
<h1>소개</h1>
<p>저는 이벤트 기반 아키텍처에서 이벤트 실패를 처리하는 방법에 대해 발표 자료를 준비하고 있었습니다. 어느 순간에 이를 설명할 때 회로 차단기가 필요한 이유에 대해 깊이 들어가게 되었습니다. 제 프로젝트에서 Elasticache를 기반으로 한 사용자 정의 구현을 사용했다는 것을 깨달았습니다. 그들을 설정하는 더 "가벼운" 방법에 대해 고민하기 시작했을 때, 서버리스 아키텍처에서 회로 차단기를 설정하는 메커니즘이 없다는 것을 깨달았습니다. 좀 더 연구해보고 이 주제에 대한 제 생각을 공유하려고 합니다.</p>
<h2>왜 서버리스가 특별한가요?</h2>
<p></p>
<p>서킷 브레이커는 상태를 가지고 있습니다. 호출하기 전에 해당 상태를 확인하고 모든 요청을 추적해야 합니다. 왜냐하면 서킷 브레이커를 단일 호출 기반이 아니라 실패율(RATE) 기준으로 열기 때문입니다.</p>
<p>우리는 람다 인스턴스 전체에 분산된 상태 대신 단일 위치에 상태를 추적해야 합니다. 다시 처음으로 돌아가 봅시다.</p>
<h1>왜 서킷 브레이커가 필요한가요?</h1>
<h2>시나리오</h2>
<p></p>
<p>이벤트 처리를 상상해보세요. 여기서는 대기열에서 작업을 가져와서 제3자로부터 데이터를 로드한 다음 데이터에 대해 "무언가"를 수행합니다. 이제 이 데이터를 DynamoDB 테이블에 지속시키기로 했다고 가정해 봅시다.</p>
<p><img src="/assets/img/2024-06-23-DistributedCircuitBreakersinEvent-DrivenArchitecturesonAWS_0.png" alt="이미지"></p>
<h2>모든 것이 실패할 때</h2>
<p>어느 날, 우리의 3rd 파티가 좋지 않은 날을 보내서 실패하기 시작할 수도 있습니다. 그 순간, 그것은 완벽할 것이고 모두가 우리가 예의 바르게 3rd 파티 시스템을 사용하는 데 존경을 기울이면 좋을 것입니다. 우리는 그들이 많은 압박을 받고 있다는 것을 알았으므로 그들에게 계속해서 요청을 보내지 않는 것이 좋을 것입니다. 돈과 자원, 그리고 SRE 팀 멤버들의 신경을 아끼게 되겠죠.</p>
<p></p>
<p><img src="https://miro.medium.com/v2/resize:fit:1280/1*d6R2_OewGnnrbMdLNLht8A.gif" alt="image"></p>
<h2>그럼 우리가 할 수 있는 것은 무엇일까요? 백오프 아이디어</h2>
<p>첫 번째 떠오르는 아이디어는 소비자들에게 백오프 전략을 적용하는 것입니다. 받은 메시지와 실패한 메시지의 가시성 제한 시간을 변경할 수 있습니다. 여기 명심해야 할 몇 가지 중요한 점이 있습니다:</p>
<ul>
<li>최대 지연 시간 값을 설정하는 것,</li>
<li>그리고 지터를 적용하는 것입니다.</li>
</ul>
<p></p>
<p>아래와 같은 메시지를 받았다고 가정하고 있다면, ChangeMessageVisibility API를 사용하여 간단히 처리할 수 있습니다.</p>
<p><img src="/assets/img/2024-06-23-DistributedCircuitBreakersinEvent-DrivenArchitecturesonAWS_1.png" alt="이미지"></p>
<p>우리는 메시지의 처리 시도 횟수에 대한 정보를 포함하고 있는 ApproximateReceiveCount 값을 추출하고, 이를 기반으로 백오프와 지터를 계산할 수 있습니다. 아래 스니펫과 같이요.</p>
<p>다음으로, 각 레코드의 receiptHandle을 사용하여 AWS SQS SDK를 이용해 시각성 제한 시간을 변경해야 합니다. 아래 코드 스니펫처럼요.</p>
<p></p>
<h2>결과</h2>
<p>백오프는 메시지를 확장된 간격으로 다시 시도합니다. 이를 통해 루프에서 항상 같은 메시지를 처리하지 않고, 제3자 시스템에 호흡 공간을 줄 수 있어서 그 사이에 좋아질 것을 희망할 수 있습니다. 또한, 최대 재시도가 제한된 경우 죽은 편지 대기열을 저장할 수 있습니다.</p>
<p>자랑스럽게 여겨질 수 있고, 자신을 칭찬할 수 있지만, 우리는 크게 변하지 않았습니다. 심각한 중단이 있을 경우 AWS는 SQS 소비자 호출을 제한할 수 있지만, 고 처리량 시스템의 경우 3rd party 시스템 관점에서는 여전히 같은 상황에 있습니다.</p>
<p>더 심각한 문제는 이 모든 람다 호출에 돈을 쓰고 있으며, 우리의 제3자 시스템이 다운된 경우 호출은 우리의 타임아웃만큼 느려져 많은 비용이 발생할 수 있습니다. 이를 어떻게 방지할 수 있을까요?</p>
<p></p>
<h2>회로 차단기 이용하기</h2>
<p>회로 차단기는 전기 회로의 회로 차단기처럼 작동합니다. 문제를 감지하면 차단이 되어 더 이상 요청이 전달되지 않습니다. 서드 파티 시스템이 다시 온라인 상태가 되면 회로를 닫고 싶습니다.</p>
<p>그 현지 조사는 "정찰" 요청을 보내면서 반 열린 상태로 수행됩니다. 이 요청은 회로 차단기 뒤에 있는 시스템이 여전히 다운된 상태인지 확인하는 작은 그룹으로, 시스템이 다운된 경우 회로는 열린 상태를 유지하고 다시 작동하면 회로를 닫고 평상시로 돌아갑니다.</p>
<p>아래 애니메이션을 살펴보시면 더 이해하기 쉬울 것입니다.</p>
<p></p>
<p>아래의 다이어그램을 확인하면 프로세스에 대해 여전히 헷갈리는 부분이 있을 수 있습니다.</p>
<p><img src="/assets/img/2024-06-23-DistributedCircuitBreakersinEvent-DrivenArchitecturesonAWS_2.png" alt="다이어그램"></p>
<h1>게임의 서버리스 상태</h1>
<p></p>
<p>서버에서는 크게 문제가 되지 않습니다. 회로 차단 장치 구현 중 하나를 사용할 수 있으니 걱정 마세요. 서버에 상태를 로컬로 저장합니다. 물론 모든 인스턴스가 동기화되지는 않겠지만, 보통 큰 문제가 되지는 않습니다. 서버리스의 경우 상황은 매우 다릅니다. 많은 인스턴스가 있고, 각 작은 인스턴스 간에 상태를 전달할 수 없습니다.</p>
<p>이곳에서 주요 고려 사항은 무엇인가요?</p>
<ul>
<li>솔루션의 복잡성</li>
<li>읽기 작업 전에 상태를 검사해야 하므로 솔루션 비용</li>
<li>작업 후 호출 결과를 지속</li>
</ul>
<p>서버리스 공간에서 대다수 사용자에게 쉽게 작동할 수 있는 솔루션을 고민 중입니다. 일반적으로 저는 Circuit Breaker 상태를 Elasticache에 저장합니다. 왜냐하면 존재하고, 속도가 매우 빠르며 – 사용자 정의 구현 외에 – 사용하기 쉽기 때문입니다. 반면에 모든 서버리스 시스템이 VPC에서 실행되고 심한 부하를 겪지는 않는다는 것을 이해하고 있습니다. 그렇지만 여기서 가장 흥미로운 부분이 "고부하"입니다.</p>
<p></p>
<p>인터넷에서 발견된 구현 방법들과 제가 생각해낸 것에 대해 살펴보겠습니다.</p>
<h1>일반적인 옵션: Jeremy Daly의 클래식</h1>
<p>서킷 브레이커에 관한 거의 모든 기사가 Jeremy Daly의 기사를 언급합니다... 그러니 시작해보죠.</p>
<p><img src="/assets/img/2024-06-23-DistributedCircuitBreakersinEvent-DrivenArchitecturesonAWS_3.png" alt="이미지"></p>
<p></p>
<p>저는 사용 중이고 방금 말한 패턴입니다. 중앙 집중식 저장소에 상태를 가진 클래식 회로 차단기일 뿐입니다. 훌륭하게 작동하며 실전 검증을 받았습니다. 분산 시스템에서 회로 차단기를 설정하는 가장 좋은 방법이라고 믿습니다. 다음을 제공합니다:</p>
<ul>
<li>여러 CB를 지원하는 매우 세분화된 솔루션</li>
<li>로직이 코드에 있기 때문에 대체값을 반환할 수 있습니다.</li>
<li>어떤 이벤트 소스 매핑 및 호출 유형과도 사용할 수 있습니다.</li>
</ul>
<p>이 패턴은 Elasticache를 필요로 하므로 일반적으로 VPC도 필요합니다. VPC에서 솔루션을 구축하고 싶지 않다면 어떻게 할까요?</p>
<h2>비-VPC 변형</h2>
<p></p>
<p>DynamoDB 고려 사항
저자는 비-VPC 람다와 함께 DynamoDB를 사용할 수도 있다고 언급합니다. 고수준 시스템에서 이 옵션을 고려할 가치가 있을까요? 물론, 이것은 귀하의 규모에 달려 있습니다. 왜냐하면:</p>
<ul>
<li>파티션당 1000 WCU 제한 - 따라서 1000 RPS 이상의 회로 차단기 상태를 유지하는 데 꼼수를 사용해야 합니다 (Tycko Franklin에게 그것을 지적해 준 것을 칭찬합니다)</li>
<li>회로 차단기 유지의 비용은 고처럼 높을 수 있습니다.</li>
</ul>
<p><img src="/assets/img/2024-06-23-DistributedCircuitBreakersinEvent-DrivenArchitecturesonAWS_4.png" alt="이미지"></p>
<p>대안적 접근 방식? Momento!</p>
<p></p>
<p>Momento를 사용하면 람다 함수를 VPC에 넣을 필요가 없고 동시에 비용을 절약할 수 있습니다. 또한 매우 확장 가능하고 저지연 솔루션이기도 합니다.</p>
<p><img src="/assets/img/2024-06-23-DistributedCircuitBreakersinEvent-DrivenArchitecturesonAWS_5.png" alt="2024-06-23-DistributedCircuitBreakersinEvent-DrivenArchitecturesonAWS_5.png"></p>
<h2>주의할 점</h2>
<p>잘못된 구현
인터넷을 뒤져본 결과 잘못된 구현이 많은 것 같습니다. 제가 잘못된 부분이 있다면 지적해주세요. 가장 인기 있는 구현조차도 분산 시스템에서 단일 인스턴스의 상태를 덮어씌우기 때문에 많은 문제를 야기할 수 있습니다.</p>
<p></p>
<p>구현: <a href="https://github.com/gunnargrosch/circuitbreaker-lambda" rel="nofollow" target="_blank">https://github.com/gunnargrosch/circuitbreaker-lambda</a></p>
<p>잘못된 정보 소스입니다
SSM 및 헬스 체크 상태를 사용하라는 제안을 봤는데, 해당 구현에 들어가기 전 꼭 모든 호출 전에 SSM을 확인하지 말아주세요. 비용이 많이 발생할 수 있어요. 그러나 어떤 해결책은 있습니다. 아래 링크된 스레드를 살펴보세요.</p>
<h1>ESM Circuit Breaker Patterns</h1>
<p>일부 회로 차단 방식은 이전 패턴만큼 범용적이지 않으며 ESM (이벤트 소스 매핑)으로 실행되는 이벤트 컨슈머에 특화되어 있습니다.</p>
<p></p>
<h2>Christoph Gerkens의 전문화된 ESM 회로 차단기</h2>
<p>이 문서는 흥미로운 아이디어를 다루고 있습니다. 계획은 SQS Consumer ESM을 회로 차단기로 사용하는 것입니다. 우리는 ESM 상태를 활성화/비활성화하여 회로를 열고 닫을 수 있습니다.</p>
<p><img src="/assets/img/2024-06-23-DistributedCircuitBreakersinEvent-DrivenArchitecturesonAWS_6.png" alt="이미지"></p>
<p>"Half Open" 상태와 "스카웃 요청"을 보낼 때, 작성자는 "Trial Message Poller"라는 추가 람다를 사용하는 것을 제안합니다. 이 람다는 큐에서 메시지 중 하나를 읽어 SQS Consumer 람다로 보냅니다. 결과에 따라 회로를 닫을지 열어둘지 결정하게 됩니다.</p>
<p></p>
<p>이 방법은 우리의 람다에서 아무것도 할 필요가 없으며, 그것은 완전히 그 로직에서 분리되어 있다는 점에서 훌륭합니다.</p>
<p>비용
상점이 없으므로 저렴해야 할 텐데요, 맞죠? 저자는 고해상도 메트릭 사용을 권장합니다. 미처리 드리프트가 몇 분 동안 지속되는 차단기 문제를 피하려면 꼭 필요합니다. 동의합니다만, 여기서는 고처리량 처리 렌즈를 통해 보는 것이기도 합니다.</p>
<p>이 경우 많은 메트릭을 수집하면 비용이 많이 들 수 있고, 이러한 메트릭을 저장하는 것은 신중하게 처리해야 합니다. PutMetricData API는 1000번의 호출당 0.01달러로 상당히 비싸니, EMF로 전환하는 것을 고려해볼 수 있습니다. 그 가격표와 매 호출 후 이벤트 추적을 고려하면 상태 저장과 함께 적절한 차단기를 사용하는 것이 더 저렴할 수 있다. 미리 계산해보세요.</p>
<p>복잡성
"시험 메시지 폴러"은 추가 복잡성을 도입하며 저는 유지하고 싶어하는 것이 아닙니다. 이것은 전체 솔루션과 결합돼 있어야 하며 다른 유형의 트리거와 재사용할 수 없습니다. SQS에서도 시각 제한 또는 부분 실패로 인한 잠재적인 문제가 있다고 상상할 수 있습니다.</p>
<p></p>
<p>잠재적인 메시지 손실
메시지가 대기열에서로드되지 않고 장기적이고 심각한 서드파티 오류의 경우, 우리는 메시지를 잃을 수 있습니다. 네, 메시지가 maxReceiveCount에 도달하지 않고 rententionPeriod가 경과하면 메시지가 데드 레터 대기열로 이동되지 않습니다.</p>
<h2>간소화된 ESM 회로 차단기</h2>
<p>Christoph Gerken의 논문에서 영감을 받아, 저는 그 구조적 패턴을 간소화하는 것을 고려했습니다.</p>
<p>이 원리는 전체 회로 차단기 상태를 CloudWatch 경보 상태에 반영하고 이를 회로의 상태로 사용하는 것에 기반합니다.</p>
<p></p>
<p><img src="/assets/img/2024-06-23-DistributedCircuitBreakersinEvent-DrivenArchitecturesonAWS_7.png" alt="Screenshot"></p>
<p>원본 글에 정의된 메트릭(호출 및 오류를 사용하여 실패율을 계산)은 기본적으로 무료로 고해상도로 제공되므로 우리는 이를 사용하여 실패율을 추적하고 10초 간격으로 경보를 정의할 수 있습니다. (이 솔루션은 여러분의 요구에 따라 어떤 경보라도 기반으로 작동할 수 있으며, ESM 관리자는 다양한 경보의 변경 사항을 듣고 있어야 합니다.)</p>
<p>Half-open 상태는 Step Functions를 통해 관리할 필요가 없습니다. CloudWatch 경보의 INSUFFICIENT_DATA 상태를 사용할 수 있습니다. 여기에는 한 가지 단점이 있습니다 — half-open 기간은 큐에서 가져온 단일 메시지 대신 SQS 소비자가 사용한 메시지의 제한된 샘플을 기반으로 합니다. 또한, TreatMissingData: missing을 사용하는 것이 중요합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">FailureRateAlarm</span>:
  <span class="hljs-title class_">Type</span>: <span class="hljs-attr">AWS</span>::<span class="hljs-title class_">CloudWatch</span>::<span class="hljs-title class_">Alarm</span>
  <span class="hljs-title class_">Properties</span>:
    <span class="hljs-title class_">Metrics</span>:
      - <span class="hljs-title class_">Expression</span>: <span class="hljs-string">"100 * errors / MAX([errors, invocations])"</span>
        <span class="hljs-title class_">Id</span>: <span class="hljs-string">"failureRate"</span>
        <span class="hljs-title class_">Label</span>: <span class="hljs-string">"failureRate"</span>
        <span class="hljs-title class_">ReturnData</span>: <span class="hljs-literal">true</span>
      - <span class="hljs-title class_">Id</span>: <span class="hljs-string">"errors"</span>
        <span class="hljs-title class_">MetricStat</span>:
          <span class="hljs-title class_">Metric</span>:
            <span class="hljs-title class_">MetricName</span>: <span class="hljs-title class_">Errors</span>
            <span class="hljs-title class_">Namespace</span>: <span class="hljs-variable constant_">AWS</span>/<span class="hljs-title class_">Lambda</span>
            <span class="hljs-title class_">Dimensions</span>:
              - <span class="hljs-title class_">Name</span>: <span class="hljs-title class_">FunctionName</span>
                <span class="hljs-title class_">Value</span>: !<span class="hljs-title class_">Ref</span> <span class="hljs-title class_">YourFunction</span>
          <span class="hljs-title class_">Period</span>: <span class="hljs-number">10</span>
          <span class="hljs-title class_">Stat</span>: <span class="hljs-title class_">Sum</span>
        <span class="hljs-title class_">ReturnData</span>: <span class="hljs-literal">false</span>
      - <span class="hljs-title class_">Id</span>: <span class="hljs-string">"invocations"</span>
        <span class="hljs-title class_">MetricStat</span>:
          <span class="hljs-title class_">Metric</span>:
            <span class="hljs-title class_">MetricName</span>: <span class="hljs-title class_">Invocations</span>
            <span class="hljs-title class_">Namespace</span>: <span class="hljs-variable constant_">AWS</span>/<span class="hljs-title class_">Lambda</span>
            <span class="hljs-title class_">Dimensions</span>:
              - <span class="hljs-title class_">Name</span>: <span class="hljs-title class_">FunctionName</span>
                <span class="hljs-title class_">Value</span>: !<span class="hljs-title class_">Ref</span> <span class="hljs-title class_">YourFunction</span>
          <span class="hljs-title class_">Period</span>: <span class="hljs-number">10</span>
          <span class="hljs-title class_">Stat</span>: <span class="hljs-title class_">Sum</span>
        <span class="hljs-title class_">ReturnData</span>: <span class="hljs-literal">false</span>
    <span class="hljs-title class_">EvaluationPeriods</span>: <span class="hljs-number">5</span>
    <span class="hljs-title class_">DatapointsToAlarm</span>: <span class="hljs-number">3</span>
    <span class="hljs-title class_">TreatMissingData</span>: missing
    <span class="hljs-title class_">Threshold</span>: <span class="hljs-number">80</span>
    <span class="hljs-title class_">ComparisonOperator</span>: <span class="hljs-title class_">GreaterThanOrEqualToThreshold</span>
</code></pre>
<p></p>
<p>상태 관리
알람이 트리거되면 회로가 열리며 람다 호출이 발생하지 않습니다. 그럼 알람은 INSUFFICIENT_DATA 상태로 전환됩니다. 그 후에는 큐의 제한된 동시성 처리를 통해 "스카웃 요청"을 보낼 수 있으며, 실패한 후에는 처리가 성공적으로 이루어진 후에 서킷을 열거나 닫을 수 있습니다.</p>
<p><img src="/assets/img/2024-06-23-DistributedCircuitBreakersinEvent-DrivenArchitecturesonAWS_8.png" alt="image"></p>
<p>기본 AWS 람다 메트릭을 사용할 경우, 새로운 접근 방식을 절약할 수 있지만, 이전 옵션에서의 "메시지 손실 가능성" 문제에 여전히 취약합니다.</p>
<p>구현
ESM을 활성화하고 비활성화하는 것은 쉽습니다. 유일하게 누락된 것은 ESM에 메타데이터를 추가할 수 있는 옵션이었습니다. 해당 기능이 누락되었으므로 스택에 매개변수로 추가해야 합니다.</p>
<p></p>
<p>내 구현은 go로 작성되었고 일부 사용자 지정 instrumentation 및 OTEL 통합이 되어 있어요. 하지만 여기 스니펫에서처럼 간단한 것을 사용할 수도 있어요.</p>
<p>내 구현은 SQS를 기반으로 하고 있지만 모든 다양한 이벤트 주도형 ESMs 구성에 적응시킬 수 있어요. 작은 사용자 정의 후처리 후 반-열린 상태로 커스터마이즈된 구성을 이용해요.</p>
<p>테스트
해당 솔루션은 여러 다른 알람 구성을 이용해 FIS로 테스트했어요. 아래에서는 예제 알람 상태 전이의 동작을 확인할 수 있어요.</p>
<p>이 접근 방식은 반-열린 상태로 이동하는 빈도를 제어하는 유연성이 부족하지만, 코드에 액세스할 수 없거나 람다 핸들러에 복잡성을 추가하고 싶지 않은 경우에는 좋아요.</p>
<p></p>
<h1>요약</h1>
<p>분산 시스템에서 서킷 브레이커를 올바르게 구현하는 것은 매우 어려울 수 있으며 고려해야 할 다양한 트레이드오프와 접근 방식이 많이 있습니다. 경우에 따라 분산된 서킷 브레이커가 전혀 필요하지 않을 수도 있습니다. 예를 들어, 작은 람다 소비자 풀의 경우에는 서킷 상태 메모리가 충분할 수도 있습니다.</p>
<p>만약 당신의 케이스에 해당하지 않는다면, 이 글이 당신에게 결정을 도와주거나 구현 중 고려해야 할 사항에 대한 아이디어를 제공해 줄 수 있기를 바랍니다. 아래에서는 당신을 위한 결정 트리를 만들어 보았습니다. 전통적인 접근 방식이 여전히 최선이라고 믿지만 ESM 기반 서킷 브레이커의 사용 사례도 볼 수 있습니다.</p>
<p>해당 주제에 대해 토의하고 싶다면, #believeinserverless 커뮤니티에 가입하여 이곳에서 커뮤니티와 논의할 수 있습니다.</p>
<p></p>
<p>시간 내어 주셔서 감사합니다! 이 주제에 대한 여러분의 생각을 듣고 싶습니다! 연락을 주세요:</p>
<h2>부가 설명</h2>
<p>또 다른 접근법
이곳에서 읽을 수 있는 Sheen Brisals가 시도한 Circuit Breakers with retries 및 archiving events에 대한 접근법: <a href="https://sbrisals.medium.com/amazon-eventbridge-archive-replay-events-in-tandem-with-a-circuit-breaker-c049a4c6857f" rel="nofollow" target="_blank">https://sbrisals.medium.com/amazon-eventbridge-archive-replay-events-in-tandem-with-a-circuit-breaker-c049a4c6857f</a> 또는 여기서 저자가 아이디어를 제시하는 동영상을 시청하세요(멋진 이야기입니다):</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"AWS에서 이벤트 기반 아키텍처에 분산 회로 차단기 적용 방법","description":"","date":"2024-06-23 00:26","slug":"2024-06-23-DistributedCircuitBreakersinEvent-DrivenArchitecturesonAWS","content":"\n![image](\"https://miro.medium.com/v2/resize:fit:1280/1*gGh7HhACzjtw6wplLPUyQQ.gif\")\n\n# 소개\n\n저는 이벤트 기반 아키텍처에서 이벤트 실패를 처리하는 방법에 대해 발표 자료를 준비하고 있었습니다. 어느 순간에 이를 설명할 때 회로 차단기가 필요한 이유에 대해 깊이 들어가게 되었습니다. 제 프로젝트에서 Elasticache를 기반으로 한 사용자 정의 구현을 사용했다는 것을 깨달았습니다. 그들을 설정하는 더 \"가벼운\" 방법에 대해 고민하기 시작했을 때, 서버리스 아키텍처에서 회로 차단기를 설정하는 메커니즘이 없다는 것을 깨달았습니다. 좀 더 연구해보고 이 주제에 대한 제 생각을 공유하려고 합니다.\n\n## 왜 서버리스가 특별한가요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n서킷 브레이커는 상태를 가지고 있습니다. 호출하기 전에 해당 상태를 확인하고 모든 요청을 추적해야 합니다. 왜냐하면 서킷 브레이커를 단일 호출 기반이 아니라 실패율(RATE) 기준으로 열기 때문입니다.\n\n우리는 람다 인스턴스 전체에 분산된 상태 대신 단일 위치에 상태를 추적해야 합니다. 다시 처음으로 돌아가 봅시다.\n\n# 왜 서킷 브레이커가 필요한가요?\n\n## 시나리오\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이벤트 처리를 상상해보세요. 여기서는 대기열에서 작업을 가져와서 제3자로부터 데이터를 로드한 다음 데이터에 대해 \"무언가\"를 수행합니다. 이제 이 데이터를 DynamoDB 테이블에 지속시키기로 했다고 가정해 봅시다.\n\n![이미지](/assets/img/2024-06-23-DistributedCircuitBreakersinEvent-DrivenArchitecturesonAWS_0.png)\n\n## 모든 것이 실패할 때\n\n어느 날, 우리의 3rd 파티가 좋지 않은 날을 보내서 실패하기 시작할 수도 있습니다. 그 순간, 그것은 완벽할 것이고 모두가 우리가 예의 바르게 3rd 파티 시스템을 사용하는 데 존경을 기울이면 좋을 것입니다. 우리는 그들이 많은 압박을 받고 있다는 것을 알았으므로 그들에게 계속해서 요청을 보내지 않는 것이 좋을 것입니다. 돈과 자원, 그리고 SRE 팀 멤버들의 신경을 아끼게 되겠죠.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](https://miro.medium.com/v2/resize:fit:1280/1*d6R2_OewGnnrbMdLNLht8A.gif)\n\n## 그럼 우리가 할 수 있는 것은 무엇일까요? 백오프 아이디어\n\n첫 번째 떠오르는 아이디어는 소비자들에게 백오프 전략을 적용하는 것입니다. 받은 메시지와 실패한 메시지의 가시성 제한 시간을 변경할 수 있습니다. 여기 명심해야 할 몇 가지 중요한 점이 있습니다:\n\n- 최대 지연 시간 값을 설정하는 것,\n- 그리고 지터를 적용하는 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래와 같은 메시지를 받았다고 가정하고 있다면, ChangeMessageVisibility API를 사용하여 간단히 처리할 수 있습니다.\n\n![이미지](/assets/img/2024-06-23-DistributedCircuitBreakersinEvent-DrivenArchitecturesonAWS_1.png)\n\n우리는 메시지의 처리 시도 횟수에 대한 정보를 포함하고 있는 ApproximateReceiveCount 값을 추출하고, 이를 기반으로 백오프와 지터를 계산할 수 있습니다. 아래 스니펫과 같이요.\n\n다음으로, 각 레코드의 receiptHandle을 사용하여 AWS SQS SDK를 이용해 시각성 제한 시간을 변경해야 합니다. 아래 코드 스니펫처럼요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 결과\n\n백오프는 메시지를 확장된 간격으로 다시 시도합니다. 이를 통해 루프에서 항상 같은 메시지를 처리하지 않고, 제3자 시스템에 호흡 공간을 줄 수 있어서 그 사이에 좋아질 것을 희망할 수 있습니다. 또한, 최대 재시도가 제한된 경우 죽은 편지 대기열을 저장할 수 있습니다.\n\n자랑스럽게 여겨질 수 있고, 자신을 칭찬할 수 있지만, 우리는 크게 변하지 않았습니다. 심각한 중단이 있을 경우 AWS는 SQS 소비자 호출을 제한할 수 있지만, 고 처리량 시스템의 경우 3rd party 시스템 관점에서는 여전히 같은 상황에 있습니다.\n\n더 심각한 문제는 이 모든 람다 호출에 돈을 쓰고 있으며, 우리의 제3자 시스템이 다운된 경우 호출은 우리의 타임아웃만큼 느려져 많은 비용이 발생할 수 있습니다. 이를 어떻게 방지할 수 있을까요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 회로 차단기 이용하기\n\n회로 차단기는 전기 회로의 회로 차단기처럼 작동합니다. 문제를 감지하면 차단이 되어 더 이상 요청이 전달되지 않습니다. 서드 파티 시스템이 다시 온라인 상태가 되면 회로를 닫고 싶습니다.\n\n그 현지 조사는 \"정찰\" 요청을 보내면서 반 열린 상태로 수행됩니다. 이 요청은 회로 차단기 뒤에 있는 시스템이 여전히 다운된 상태인지 확인하는 작은 그룹으로, 시스템이 다운된 경우 회로는 열린 상태를 유지하고 다시 작동하면 회로를 닫고 평상시로 돌아갑니다.\n\n아래 애니메이션을 살펴보시면 더 이해하기 쉬울 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래의 다이어그램을 확인하면 프로세스에 대해 여전히 헷갈리는 부분이 있을 수 있습니다.\n\n![다이어그램](/assets/img/2024-06-23-DistributedCircuitBreakersinEvent-DrivenArchitecturesonAWS_2.png)\n\n# 게임의 서버리스 상태\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n서버에서는 크게 문제가 되지 않습니다. 회로 차단 장치 구현 중 하나를 사용할 수 있으니 걱정 마세요. 서버에 상태를 로컬로 저장합니다. 물론 모든 인스턴스가 동기화되지는 않겠지만, 보통 큰 문제가 되지는 않습니다. 서버리스의 경우 상황은 매우 다릅니다. 많은 인스턴스가 있고, 각 작은 인스턴스 간에 상태를 전달할 수 없습니다.\n\n이곳에서 주요 고려 사항은 무엇인가요?\n\n- 솔루션의 복잡성\n- 읽기 작업 전에 상태를 검사해야 하므로 솔루션 비용\n- 작업 후 호출 결과를 지속\n\n서버리스 공간에서 대다수 사용자에게 쉽게 작동할 수 있는 솔루션을 고민 중입니다. 일반적으로 저는 Circuit Breaker 상태를 Elasticache에 저장합니다. 왜냐하면 존재하고, 속도가 매우 빠르며 – 사용자 정의 구현 외에 – 사용하기 쉽기 때문입니다. 반면에 모든 서버리스 시스템이 VPC에서 실행되고 심한 부하를 겪지는 않는다는 것을 이해하고 있습니다. 그렇지만 여기서 가장 흥미로운 부분이 \"고부하\"입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n인터넷에서 발견된 구현 방법들과 제가 생각해낸 것에 대해 살펴보겠습니다.\n\n# 일반적인 옵션: Jeremy Daly의 클래식\n\n서킷 브레이커에 관한 거의 모든 기사가 Jeremy Daly의 기사를 언급합니다... 그러니 시작해보죠.\n\n![이미지](/assets/img/2024-06-23-DistributedCircuitBreakersinEvent-DrivenArchitecturesonAWS_3.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n저는 사용 중이고 방금 말한 패턴입니다. 중앙 집중식 저장소에 상태를 가진 클래식 회로 차단기일 뿐입니다. 훌륭하게 작동하며 실전 검증을 받았습니다. 분산 시스템에서 회로 차단기를 설정하는 가장 좋은 방법이라고 믿습니다. 다음을 제공합니다:\n\n- 여러 CB를 지원하는 매우 세분화된 솔루션\n- 로직이 코드에 있기 때문에 대체값을 반환할 수 있습니다.\n- 어떤 이벤트 소스 매핑 및 호출 유형과도 사용할 수 있습니다.\n\n이 패턴은 Elasticache를 필요로 하므로 일반적으로 VPC도 필요합니다. VPC에서 솔루션을 구축하고 싶지 않다면 어떻게 할까요?\n\n## 비-VPC 변형\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nDynamoDB 고려 사항\n저자는 비-VPC 람다와 함께 DynamoDB를 사용할 수도 있다고 언급합니다. 고수준 시스템에서 이 옵션을 고려할 가치가 있을까요? 물론, 이것은 귀하의 규모에 달려 있습니다. 왜냐하면:\n\n- 파티션당 1000 WCU 제한 - 따라서 1000 RPS 이상의 회로 차단기 상태를 유지하는 데 꼼수를 사용해야 합니다 (Tycko Franklin에게 그것을 지적해 준 것을 칭찬합니다)\n- 회로 차단기 유지의 비용은 고처럼 높을 수 있습니다.\n\n![이미지](/assets/img/2024-06-23-DistributedCircuitBreakersinEvent-DrivenArchitecturesonAWS_4.png)\n\n대안적 접근 방식? Momento!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nMomento를 사용하면 람다 함수를 VPC에 넣을 필요가 없고 동시에 비용을 절약할 수 있습니다. 또한 매우 확장 가능하고 저지연 솔루션이기도 합니다.\n\n![2024-06-23-DistributedCircuitBreakersinEvent-DrivenArchitecturesonAWS_5.png](/assets/img/2024-06-23-DistributedCircuitBreakersinEvent-DrivenArchitecturesonAWS_5.png)\n\n## 주의할 점\n\n잘못된 구현\n인터넷을 뒤져본 결과 잘못된 구현이 많은 것 같습니다. 제가 잘못된 부분이 있다면 지적해주세요. 가장 인기 있는 구현조차도 분산 시스템에서 단일 인스턴스의 상태를 덮어씌우기 때문에 많은 문제를 야기할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n구현: https://github.com/gunnargrosch/circuitbreaker-lambda\n\n잘못된 정보 소스입니다\nSSM 및 헬스 체크 상태를 사용하라는 제안을 봤는데, 해당 구현에 들어가기 전 꼭 모든 호출 전에 SSM을 확인하지 말아주세요. 비용이 많이 발생할 수 있어요. 그러나 어떤 해결책은 있습니다. 아래 링크된 스레드를 살펴보세요.\n\n# ESM Circuit Breaker Patterns\n\n일부 회로 차단 방식은 이전 패턴만큼 범용적이지 않으며 ESM (이벤트 소스 매핑)으로 실행되는 이벤트 컨슈머에 특화되어 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## Christoph Gerkens의 전문화된 ESM 회로 차단기\n\n이 문서는 흥미로운 아이디어를 다루고 있습니다. 계획은 SQS Consumer ESM을 회로 차단기로 사용하는 것입니다. 우리는 ESM 상태를 활성화/비활성화하여 회로를 열고 닫을 수 있습니다.\n\n![이미지](/assets/img/2024-06-23-DistributedCircuitBreakersinEvent-DrivenArchitecturesonAWS_6.png)\n\n\"Half Open\" 상태와 \"스카웃 요청\"을 보낼 때, 작성자는 \"Trial Message Poller\"라는 추가 람다를 사용하는 것을 제안합니다. 이 람다는 큐에서 메시지 중 하나를 읽어 SQS Consumer 람다로 보냅니다. 결과에 따라 회로를 닫을지 열어둘지 결정하게 됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 방법은 우리의 람다에서 아무것도 할 필요가 없으며, 그것은 완전히 그 로직에서 분리되어 있다는 점에서 훌륭합니다.\n\n비용\n상점이 없으므로 저렴해야 할 텐데요, 맞죠? 저자는 고해상도 메트릭 사용을 권장합니다. 미처리 드리프트가 몇 분 동안 지속되는 차단기 문제를 피하려면 꼭 필요합니다. 동의합니다만, 여기서는 고처리량 처리 렌즈를 통해 보는 것이기도 합니다.\n\n이 경우 많은 메트릭을 수집하면 비용이 많이 들 수 있고, 이러한 메트릭을 저장하는 것은 신중하게 처리해야 합니다. PutMetricData API는 1000번의 호출당 0.01달러로 상당히 비싸니, EMF로 전환하는 것을 고려해볼 수 있습니다. 그 가격표와 매 호출 후 이벤트 추적을 고려하면 상태 저장과 함께 적절한 차단기를 사용하는 것이 더 저렴할 수 있다. 미리 계산해보세요.\n\n복잡성\n\"시험 메시지 폴러\"은 추가 복잡성을 도입하며 저는 유지하고 싶어하는 것이 아닙니다. 이것은 전체 솔루션과 결합돼 있어야 하며 다른 유형의 트리거와 재사용할 수 없습니다. SQS에서도 시각 제한 또는 부분 실패로 인한 잠재적인 문제가 있다고 상상할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n잠재적인 메시지 손실\n메시지가 대기열에서로드되지 않고 장기적이고 심각한 서드파티 오류의 경우, 우리는 메시지를 잃을 수 있습니다. 네, 메시지가 maxReceiveCount에 도달하지 않고 rententionPeriod가 경과하면 메시지가 데드 레터 대기열로 이동되지 않습니다.\n\n## 간소화된 ESM 회로 차단기\n\nChristoph Gerken의 논문에서 영감을 받아, 저는 그 구조적 패턴을 간소화하는 것을 고려했습니다.\n\n이 원리는 전체 회로 차단기 상태를 CloudWatch 경보 상태에 반영하고 이를 회로의 상태로 사용하는 것에 기반합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Screenshot](/assets/img/2024-06-23-DistributedCircuitBreakersinEvent-DrivenArchitecturesonAWS_7.png)\n\n원본 글에 정의된 메트릭(호출 및 오류를 사용하여 실패율을 계산)은 기본적으로 무료로 고해상도로 제공되므로 우리는 이를 사용하여 실패율을 추적하고 10초 간격으로 경보를 정의할 수 있습니다. (이 솔루션은 여러분의 요구에 따라 어떤 경보라도 기반으로 작동할 수 있으며, ESM 관리자는 다양한 경보의 변경 사항을 듣고 있어야 합니다.)\n\nHalf-open 상태는 Step Functions를 통해 관리할 필요가 없습니다. CloudWatch 경보의 INSUFFICIENT_DATA 상태를 사용할 수 있습니다. 여기에는 한 가지 단점이 있습니다 — half-open 기간은 큐에서 가져온 단일 메시지 대신 SQS 소비자가 사용한 메시지의 제한된 샘플을 기반으로 합니다. 또한, TreatMissingData: missing을 사용하는 것이 중요합니다.\n\n```js\nFailureRateAlarm:\n  Type: AWS::CloudWatch::Alarm\n  Properties:\n    Metrics:\n      - Expression: \"100 * errors / MAX([errors, invocations])\"\n        Id: \"failureRate\"\n        Label: \"failureRate\"\n        ReturnData: true\n      - Id: \"errors\"\n        MetricStat:\n          Metric:\n            MetricName: Errors\n            Namespace: AWS/Lambda\n            Dimensions:\n              - Name: FunctionName\n                Value: !Ref YourFunction\n          Period: 10\n          Stat: Sum\n        ReturnData: false\n      - Id: \"invocations\"\n        MetricStat:\n          Metric:\n            MetricName: Invocations\n            Namespace: AWS/Lambda\n            Dimensions:\n              - Name: FunctionName\n                Value: !Ref YourFunction\n          Period: 10\n          Stat: Sum\n        ReturnData: false\n    EvaluationPeriods: 5\n    DatapointsToAlarm: 3\n    TreatMissingData: missing\n    Threshold: 80\n    ComparisonOperator: GreaterThanOrEqualToThreshold\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n상태 관리\n알람이 트리거되면 회로가 열리며 람다 호출이 발생하지 않습니다. 그럼 알람은 INSUFFICIENT_DATA 상태로 전환됩니다. 그 후에는 큐의 제한된 동시성 처리를 통해 \"스카웃 요청\"을 보낼 수 있으며, 실패한 후에는 처리가 성공적으로 이루어진 후에 서킷을 열거나 닫을 수 있습니다.\n\n![image](/assets/img/2024-06-23-DistributedCircuitBreakersinEvent-DrivenArchitecturesonAWS_8.png)\n\n기본 AWS 람다 메트릭을 사용할 경우, 새로운 접근 방식을 절약할 수 있지만, 이전 옵션에서의 \"메시지 손실 가능성\" 문제에 여전히 취약합니다.\n\n구현\nESM을 활성화하고 비활성화하는 것은 쉽습니다. 유일하게 누락된 것은 ESM에 메타데이터를 추가할 수 있는 옵션이었습니다. 해당 기능이 누락되었으므로 스택에 매개변수로 추가해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n내 구현은 go로 작성되었고 일부 사용자 지정 instrumentation 및 OTEL 통합이 되어 있어요. 하지만 여기 스니펫에서처럼 간단한 것을 사용할 수도 있어요.\n\n내 구현은 SQS를 기반으로 하고 있지만 모든 다양한 이벤트 주도형 ESMs 구성에 적응시킬 수 있어요. 작은 사용자 정의 후처리 후 반-열린 상태로 커스터마이즈된 구성을 이용해요.\n\n테스트\n해당 솔루션은 여러 다른 알람 구성을 이용해 FIS로 테스트했어요. 아래에서는 예제 알람 상태 전이의 동작을 확인할 수 있어요.\n\n이 접근 방식은 반-열린 상태로 이동하는 빈도를 제어하는 유연성이 부족하지만, 코드에 액세스할 수 없거나 람다 핸들러에 복잡성을 추가하고 싶지 않은 경우에는 좋아요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 요약\n\n분산 시스템에서 서킷 브레이커를 올바르게 구현하는 것은 매우 어려울 수 있으며 고려해야 할 다양한 트레이드오프와 접근 방식이 많이 있습니다. 경우에 따라 분산된 서킷 브레이커가 전혀 필요하지 않을 수도 있습니다. 예를 들어, 작은 람다 소비자 풀의 경우에는 서킷 상태 메모리가 충분할 수도 있습니다.\n\n만약 당신의 케이스에 해당하지 않는다면, 이 글이 당신에게 결정을 도와주거나 구현 중 고려해야 할 사항에 대한 아이디어를 제공해 줄 수 있기를 바랍니다. 아래에서는 당신을 위한 결정 트리를 만들어 보았습니다. 전통적인 접근 방식이 여전히 최선이라고 믿지만 ESM 기반 서킷 브레이커의 사용 사례도 볼 수 있습니다.\n\n해당 주제에 대해 토의하고 싶다면, #believeinserverless 커뮤니티에 가입하여 이곳에서 커뮤니티와 논의할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n시간 내어 주셔서 감사합니다! 이 주제에 대한 여러분의 생각을 듣고 싶습니다! 연락을 주세요:\n\n## 부가 설명\n\n또 다른 접근법\n이곳에서 읽을 수 있는 Sheen Brisals가 시도한 Circuit Breakers with retries 및 archiving events에 대한 접근법: [https://sbrisals.medium.com/amazon-eventbridge-archive-replay-events-in-tandem-with-a-circuit-breaker-c049a4c6857f](https://sbrisals.medium.com/amazon-eventbridge-archive-replay-events-in-tandem-with-a-circuit-breaker-c049a4c6857f) 또는 여기서 저자가 아이디어를 제시하는 동영상을 시청하세요(멋진 이야기입니다):\n","ogImage":{"url":"/assets/img/2024-06-23-DistributedCircuitBreakersinEvent-DrivenArchitecturesonAWS_0.png"},"coverImage":"/assets/img/2024-06-23-DistributedCircuitBreakersinEvent-DrivenArchitecturesonAWS_0.png","tag":["Tech"],"readingTime":15},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"%22https://miro.medium.com/v2/resize:fit:1280/1*gGh7HhACzjtw6wplLPUyQQ.gif%22\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ch1\u003e소개\u003c/h1\u003e\n\u003cp\u003e저는 이벤트 기반 아키텍처에서 이벤트 실패를 처리하는 방법에 대해 발표 자료를 준비하고 있었습니다. 어느 순간에 이를 설명할 때 회로 차단기가 필요한 이유에 대해 깊이 들어가게 되었습니다. 제 프로젝트에서 Elasticache를 기반으로 한 사용자 정의 구현을 사용했다는 것을 깨달았습니다. 그들을 설정하는 더 \"가벼운\" 방법에 대해 고민하기 시작했을 때, 서버리스 아키텍처에서 회로 차단기를 설정하는 메커니즘이 없다는 것을 깨달았습니다. 좀 더 연구해보고 이 주제에 대한 제 생각을 공유하려고 합니다.\u003c/p\u003e\n\u003ch2\u003e왜 서버리스가 특별한가요?\u003c/h2\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e서킷 브레이커는 상태를 가지고 있습니다. 호출하기 전에 해당 상태를 확인하고 모든 요청을 추적해야 합니다. 왜냐하면 서킷 브레이커를 단일 호출 기반이 아니라 실패율(RATE) 기준으로 열기 때문입니다.\u003c/p\u003e\n\u003cp\u003e우리는 람다 인스턴스 전체에 분산된 상태 대신 단일 위치에 상태를 추적해야 합니다. 다시 처음으로 돌아가 봅시다.\u003c/p\u003e\n\u003ch1\u003e왜 서킷 브레이커가 필요한가요?\u003c/h1\u003e\n\u003ch2\u003e시나리오\u003c/h2\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e이벤트 처리를 상상해보세요. 여기서는 대기열에서 작업을 가져와서 제3자로부터 데이터를 로드한 다음 데이터에 대해 \"무언가\"를 수행합니다. 이제 이 데이터를 DynamoDB 테이블에 지속시키기로 했다고 가정해 봅시다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-DistributedCircuitBreakersinEvent-DrivenArchitecturesonAWS_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch2\u003e모든 것이 실패할 때\u003c/h2\u003e\n\u003cp\u003e어느 날, 우리의 3rd 파티가 좋지 않은 날을 보내서 실패하기 시작할 수도 있습니다. 그 순간, 그것은 완벽할 것이고 모두가 우리가 예의 바르게 3rd 파티 시스템을 사용하는 데 존경을 기울이면 좋을 것입니다. 우리는 그들이 많은 압박을 받고 있다는 것을 알았으므로 그들에게 계속해서 요청을 보내지 않는 것이 좋을 것입니다. 돈과 자원, 그리고 SRE 팀 멤버들의 신경을 아끼게 되겠죠.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1280/1*d6R2_OewGnnrbMdLNLht8A.gif\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ch2\u003e그럼 우리가 할 수 있는 것은 무엇일까요? 백오프 아이디어\u003c/h2\u003e\n\u003cp\u003e첫 번째 떠오르는 아이디어는 소비자들에게 백오프 전략을 적용하는 것입니다. 받은 메시지와 실패한 메시지의 가시성 제한 시간을 변경할 수 있습니다. 여기 명심해야 할 몇 가지 중요한 점이 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e최대 지연 시간 값을 설정하는 것,\u003c/li\u003e\n\u003cli\u003e그리고 지터를 적용하는 것입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e아래와 같은 메시지를 받았다고 가정하고 있다면, ChangeMessageVisibility API를 사용하여 간단히 처리할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-DistributedCircuitBreakersinEvent-DrivenArchitecturesonAWS_1.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e우리는 메시지의 처리 시도 횟수에 대한 정보를 포함하고 있는 ApproximateReceiveCount 값을 추출하고, 이를 기반으로 백오프와 지터를 계산할 수 있습니다. 아래 스니펫과 같이요.\u003c/p\u003e\n\u003cp\u003e다음으로, 각 레코드의 receiptHandle을 사용하여 AWS SQS SDK를 이용해 시각성 제한 시간을 변경해야 합니다. 아래 코드 스니펫처럼요.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003ch2\u003e결과\u003c/h2\u003e\n\u003cp\u003e백오프는 메시지를 확장된 간격으로 다시 시도합니다. 이를 통해 루프에서 항상 같은 메시지를 처리하지 않고, 제3자 시스템에 호흡 공간을 줄 수 있어서 그 사이에 좋아질 것을 희망할 수 있습니다. 또한, 최대 재시도가 제한된 경우 죽은 편지 대기열을 저장할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e자랑스럽게 여겨질 수 있고, 자신을 칭찬할 수 있지만, 우리는 크게 변하지 않았습니다. 심각한 중단이 있을 경우 AWS는 SQS 소비자 호출을 제한할 수 있지만, 고 처리량 시스템의 경우 3rd party 시스템 관점에서는 여전히 같은 상황에 있습니다.\u003c/p\u003e\n\u003cp\u003e더 심각한 문제는 이 모든 람다 호출에 돈을 쓰고 있으며, 우리의 제3자 시스템이 다운된 경우 호출은 우리의 타임아웃만큼 느려져 많은 비용이 발생할 수 있습니다. 이를 어떻게 방지할 수 있을까요?\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003ch2\u003e회로 차단기 이용하기\u003c/h2\u003e\n\u003cp\u003e회로 차단기는 전기 회로의 회로 차단기처럼 작동합니다. 문제를 감지하면 차단이 되어 더 이상 요청이 전달되지 않습니다. 서드 파티 시스템이 다시 온라인 상태가 되면 회로를 닫고 싶습니다.\u003c/p\u003e\n\u003cp\u003e그 현지 조사는 \"정찰\" 요청을 보내면서 반 열린 상태로 수행됩니다. 이 요청은 회로 차단기 뒤에 있는 시스템이 여전히 다운된 상태인지 확인하는 작은 그룹으로, 시스템이 다운된 경우 회로는 열린 상태를 유지하고 다시 작동하면 회로를 닫고 평상시로 돌아갑니다.\u003c/p\u003e\n\u003cp\u003e아래 애니메이션을 살펴보시면 더 이해하기 쉬울 것입니다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e아래의 다이어그램을 확인하면 프로세스에 대해 여전히 헷갈리는 부분이 있을 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-DistributedCircuitBreakersinEvent-DrivenArchitecturesonAWS_2.png\" alt=\"다이어그램\"\u003e\u003c/p\u003e\n\u003ch1\u003e게임의 서버리스 상태\u003c/h1\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e서버에서는 크게 문제가 되지 않습니다. 회로 차단 장치 구현 중 하나를 사용할 수 있으니 걱정 마세요. 서버에 상태를 로컬로 저장합니다. 물론 모든 인스턴스가 동기화되지는 않겠지만, 보통 큰 문제가 되지는 않습니다. 서버리스의 경우 상황은 매우 다릅니다. 많은 인스턴스가 있고, 각 작은 인스턴스 간에 상태를 전달할 수 없습니다.\u003c/p\u003e\n\u003cp\u003e이곳에서 주요 고려 사항은 무엇인가요?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e솔루션의 복잡성\u003c/li\u003e\n\u003cli\u003e읽기 작업 전에 상태를 검사해야 하므로 솔루션 비용\u003c/li\u003e\n\u003cli\u003e작업 후 호출 결과를 지속\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e서버리스 공간에서 대다수 사용자에게 쉽게 작동할 수 있는 솔루션을 고민 중입니다. 일반적으로 저는 Circuit Breaker 상태를 Elasticache에 저장합니다. 왜냐하면 존재하고, 속도가 매우 빠르며 – 사용자 정의 구현 외에 – 사용하기 쉽기 때문입니다. 반면에 모든 서버리스 시스템이 VPC에서 실행되고 심한 부하를 겪지는 않는다는 것을 이해하고 있습니다. 그렇지만 여기서 가장 흥미로운 부분이 \"고부하\"입니다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e인터넷에서 발견된 구현 방법들과 제가 생각해낸 것에 대해 살펴보겠습니다.\u003c/p\u003e\n\u003ch1\u003e일반적인 옵션: Jeremy Daly의 클래식\u003c/h1\u003e\n\u003cp\u003e서킷 브레이커에 관한 거의 모든 기사가 Jeremy Daly의 기사를 언급합니다... 그러니 시작해보죠.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-DistributedCircuitBreakersinEvent-DrivenArchitecturesonAWS_3.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e저는 사용 중이고 방금 말한 패턴입니다. 중앙 집중식 저장소에 상태를 가진 클래식 회로 차단기일 뿐입니다. 훌륭하게 작동하며 실전 검증을 받았습니다. 분산 시스템에서 회로 차단기를 설정하는 가장 좋은 방법이라고 믿습니다. 다음을 제공합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e여러 CB를 지원하는 매우 세분화된 솔루션\u003c/li\u003e\n\u003cli\u003e로직이 코드에 있기 때문에 대체값을 반환할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e어떤 이벤트 소스 매핑 및 호출 유형과도 사용할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이 패턴은 Elasticache를 필요로 하므로 일반적으로 VPC도 필요합니다. VPC에서 솔루션을 구축하고 싶지 않다면 어떻게 할까요?\u003c/p\u003e\n\u003ch2\u003e비-VPC 변형\u003c/h2\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003eDynamoDB 고려 사항\n저자는 비-VPC 람다와 함께 DynamoDB를 사용할 수도 있다고 언급합니다. 고수준 시스템에서 이 옵션을 고려할 가치가 있을까요? 물론, 이것은 귀하의 규모에 달려 있습니다. 왜냐하면:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e파티션당 1000 WCU 제한 - 따라서 1000 RPS 이상의 회로 차단기 상태를 유지하는 데 꼼수를 사용해야 합니다 (Tycko Franklin에게 그것을 지적해 준 것을 칭찬합니다)\u003c/li\u003e\n\u003cli\u003e회로 차단기 유지의 비용은 고처럼 높을 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-DistributedCircuitBreakersinEvent-DrivenArchitecturesonAWS_4.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e대안적 접근 방식? Momento!\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003eMomento를 사용하면 람다 함수를 VPC에 넣을 필요가 없고 동시에 비용을 절약할 수 있습니다. 또한 매우 확장 가능하고 저지연 솔루션이기도 합니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-DistributedCircuitBreakersinEvent-DrivenArchitecturesonAWS_5.png\" alt=\"2024-06-23-DistributedCircuitBreakersinEvent-DrivenArchitecturesonAWS_5.png\"\u003e\u003c/p\u003e\n\u003ch2\u003e주의할 점\u003c/h2\u003e\n\u003cp\u003e잘못된 구현\n인터넷을 뒤져본 결과 잘못된 구현이 많은 것 같습니다. 제가 잘못된 부분이 있다면 지적해주세요. 가장 인기 있는 구현조차도 분산 시스템에서 단일 인스턴스의 상태를 덮어씌우기 때문에 많은 문제를 야기할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e구현: \u003ca href=\"https://github.com/gunnargrosch/circuitbreaker-lambda\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://github.com/gunnargrosch/circuitbreaker-lambda\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e잘못된 정보 소스입니다\nSSM 및 헬스 체크 상태를 사용하라는 제안을 봤는데, 해당 구현에 들어가기 전 꼭 모든 호출 전에 SSM을 확인하지 말아주세요. 비용이 많이 발생할 수 있어요. 그러나 어떤 해결책은 있습니다. 아래 링크된 스레드를 살펴보세요.\u003c/p\u003e\n\u003ch1\u003eESM Circuit Breaker Patterns\u003c/h1\u003e\n\u003cp\u003e일부 회로 차단 방식은 이전 패턴만큼 범용적이지 않으며 ESM (이벤트 소스 매핑)으로 실행되는 이벤트 컨슈머에 특화되어 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003ch2\u003eChristoph Gerkens의 전문화된 ESM 회로 차단기\u003c/h2\u003e\n\u003cp\u003e이 문서는 흥미로운 아이디어를 다루고 있습니다. 계획은 SQS Consumer ESM을 회로 차단기로 사용하는 것입니다. 우리는 ESM 상태를 활성화/비활성화하여 회로를 열고 닫을 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-DistributedCircuitBreakersinEvent-DrivenArchitecturesonAWS_6.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e\"Half Open\" 상태와 \"스카웃 요청\"을 보낼 때, 작성자는 \"Trial Message Poller\"라는 추가 람다를 사용하는 것을 제안합니다. 이 람다는 큐에서 메시지 중 하나를 읽어 SQS Consumer 람다로 보냅니다. 결과에 따라 회로를 닫을지 열어둘지 결정하게 됩니다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e이 방법은 우리의 람다에서 아무것도 할 필요가 없으며, 그것은 완전히 그 로직에서 분리되어 있다는 점에서 훌륭합니다.\u003c/p\u003e\n\u003cp\u003e비용\n상점이 없으므로 저렴해야 할 텐데요, 맞죠? 저자는 고해상도 메트릭 사용을 권장합니다. 미처리 드리프트가 몇 분 동안 지속되는 차단기 문제를 피하려면 꼭 필요합니다. 동의합니다만, 여기서는 고처리량 처리 렌즈를 통해 보는 것이기도 합니다.\u003c/p\u003e\n\u003cp\u003e이 경우 많은 메트릭을 수집하면 비용이 많이 들 수 있고, 이러한 메트릭을 저장하는 것은 신중하게 처리해야 합니다. PutMetricData API는 1000번의 호출당 0.01달러로 상당히 비싸니, EMF로 전환하는 것을 고려해볼 수 있습니다. 그 가격표와 매 호출 후 이벤트 추적을 고려하면 상태 저장과 함께 적절한 차단기를 사용하는 것이 더 저렴할 수 있다. 미리 계산해보세요.\u003c/p\u003e\n\u003cp\u003e복잡성\n\"시험 메시지 폴러\"은 추가 복잡성을 도입하며 저는 유지하고 싶어하는 것이 아닙니다. 이것은 전체 솔루션과 결합돼 있어야 하며 다른 유형의 트리거와 재사용할 수 없습니다. SQS에서도 시각 제한 또는 부분 실패로 인한 잠재적인 문제가 있다고 상상할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e잠재적인 메시지 손실\n메시지가 대기열에서로드되지 않고 장기적이고 심각한 서드파티 오류의 경우, 우리는 메시지를 잃을 수 있습니다. 네, 메시지가 maxReceiveCount에 도달하지 않고 rententionPeriod가 경과하면 메시지가 데드 레터 대기열로 이동되지 않습니다.\u003c/p\u003e\n\u003ch2\u003e간소화된 ESM 회로 차단기\u003c/h2\u003e\n\u003cp\u003eChristoph Gerken의 논문에서 영감을 받아, 저는 그 구조적 패턴을 간소화하는 것을 고려했습니다.\u003c/p\u003e\n\u003cp\u003e이 원리는 전체 회로 차단기 상태를 CloudWatch 경보 상태에 반영하고 이를 회로의 상태로 사용하는 것에 기반합니다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-DistributedCircuitBreakersinEvent-DrivenArchitecturesonAWS_7.png\" alt=\"Screenshot\"\u003e\u003c/p\u003e\n\u003cp\u003e원본 글에 정의된 메트릭(호출 및 오류를 사용하여 실패율을 계산)은 기본적으로 무료로 고해상도로 제공되므로 우리는 이를 사용하여 실패율을 추적하고 10초 간격으로 경보를 정의할 수 있습니다. (이 솔루션은 여러분의 요구에 따라 어떤 경보라도 기반으로 작동할 수 있으며, ESM 관리자는 다양한 경보의 변경 사항을 듣고 있어야 합니다.)\u003c/p\u003e\n\u003cp\u003eHalf-open 상태는 Step Functions를 통해 관리할 필요가 없습니다. CloudWatch 경보의 INSUFFICIENT_DATA 상태를 사용할 수 있습니다. 여기에는 한 가지 단점이 있습니다 — half-open 기간은 큐에서 가져온 단일 메시지 대신 SQS 소비자가 사용한 메시지의 제한된 샘플을 기반으로 합니다. 또한, TreatMissingData: missing을 사용하는 것이 중요합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eFailureRateAlarm\u003c/span\u003e:\n  \u003cspan class=\"hljs-title class_\"\u003eType\u003c/span\u003e: \u003cspan class=\"hljs-attr\"\u003eAWS\u003c/span\u003e::\u003cspan class=\"hljs-title class_\"\u003eCloudWatch\u003c/span\u003e::\u003cspan class=\"hljs-title class_\"\u003eAlarm\u003c/span\u003e\n  \u003cspan class=\"hljs-title class_\"\u003eProperties\u003c/span\u003e:\n    \u003cspan class=\"hljs-title class_\"\u003eMetrics\u003c/span\u003e:\n      - \u003cspan class=\"hljs-title class_\"\u003eExpression\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"100 * errors / MAX([errors, invocations])\"\u003c/span\u003e\n        \u003cspan class=\"hljs-title class_\"\u003eId\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"failureRate\"\u003c/span\u003e\n        \u003cspan class=\"hljs-title class_\"\u003eLabel\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"failureRate\"\u003c/span\u003e\n        \u003cspan class=\"hljs-title class_\"\u003eReturnData\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e\n      - \u003cspan class=\"hljs-title class_\"\u003eId\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"errors\"\u003c/span\u003e\n        \u003cspan class=\"hljs-title class_\"\u003eMetricStat\u003c/span\u003e:\n          \u003cspan class=\"hljs-title class_\"\u003eMetric\u003c/span\u003e:\n            \u003cspan class=\"hljs-title class_\"\u003eMetricName\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eErrors\u003c/span\u003e\n            \u003cspan class=\"hljs-title class_\"\u003eNamespace\u003c/span\u003e: \u003cspan class=\"hljs-variable constant_\"\u003eAWS\u003c/span\u003e/\u003cspan class=\"hljs-title class_\"\u003eLambda\u003c/span\u003e\n            \u003cspan class=\"hljs-title class_\"\u003eDimensions\u003c/span\u003e:\n              - \u003cspan class=\"hljs-title class_\"\u003eName\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eFunctionName\u003c/span\u003e\n                \u003cspan class=\"hljs-title class_\"\u003eValue\u003c/span\u003e: !\u003cspan class=\"hljs-title class_\"\u003eRef\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eYourFunction\u003c/span\u003e\n          \u003cspan class=\"hljs-title class_\"\u003ePeriod\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e\n          \u003cspan class=\"hljs-title class_\"\u003eStat\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eSum\u003c/span\u003e\n        \u003cspan class=\"hljs-title class_\"\u003eReturnData\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e\n      - \u003cspan class=\"hljs-title class_\"\u003eId\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"invocations\"\u003c/span\u003e\n        \u003cspan class=\"hljs-title class_\"\u003eMetricStat\u003c/span\u003e:\n          \u003cspan class=\"hljs-title class_\"\u003eMetric\u003c/span\u003e:\n            \u003cspan class=\"hljs-title class_\"\u003eMetricName\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eInvocations\u003c/span\u003e\n            \u003cspan class=\"hljs-title class_\"\u003eNamespace\u003c/span\u003e: \u003cspan class=\"hljs-variable constant_\"\u003eAWS\u003c/span\u003e/\u003cspan class=\"hljs-title class_\"\u003eLambda\u003c/span\u003e\n            \u003cspan class=\"hljs-title class_\"\u003eDimensions\u003c/span\u003e:\n              - \u003cspan class=\"hljs-title class_\"\u003eName\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eFunctionName\u003c/span\u003e\n                \u003cspan class=\"hljs-title class_\"\u003eValue\u003c/span\u003e: !\u003cspan class=\"hljs-title class_\"\u003eRef\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eYourFunction\u003c/span\u003e\n          \u003cspan class=\"hljs-title class_\"\u003ePeriod\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e\n          \u003cspan class=\"hljs-title class_\"\u003eStat\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eSum\u003c/span\u003e\n        \u003cspan class=\"hljs-title class_\"\u003eReturnData\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e\n    \u003cspan class=\"hljs-title class_\"\u003eEvaluationPeriods\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e\n    \u003cspan class=\"hljs-title class_\"\u003eDatapointsToAlarm\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e\n    \u003cspan class=\"hljs-title class_\"\u003eTreatMissingData\u003c/span\u003e: missing\n    \u003cspan class=\"hljs-title class_\"\u003eThreshold\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e80\u003c/span\u003e\n    \u003cspan class=\"hljs-title class_\"\u003eComparisonOperator\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eGreaterThanOrEqualToThreshold\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e상태 관리\n알람이 트리거되면 회로가 열리며 람다 호출이 발생하지 않습니다. 그럼 알람은 INSUFFICIENT_DATA 상태로 전환됩니다. 그 후에는 큐의 제한된 동시성 처리를 통해 \"스카웃 요청\"을 보낼 수 있으며, 실패한 후에는 처리가 성공적으로 이루어진 후에 서킷을 열거나 닫을 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-DistributedCircuitBreakersinEvent-DrivenArchitecturesonAWS_8.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e기본 AWS 람다 메트릭을 사용할 경우, 새로운 접근 방식을 절약할 수 있지만, 이전 옵션에서의 \"메시지 손실 가능성\" 문제에 여전히 취약합니다.\u003c/p\u003e\n\u003cp\u003e구현\nESM을 활성화하고 비활성화하는 것은 쉽습니다. 유일하게 누락된 것은 ESM에 메타데이터를 추가할 수 있는 옵션이었습니다. 해당 기능이 누락되었으므로 스택에 매개변수로 추가해야 합니다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e내 구현은 go로 작성되었고 일부 사용자 지정 instrumentation 및 OTEL 통합이 되어 있어요. 하지만 여기 스니펫에서처럼 간단한 것을 사용할 수도 있어요.\u003c/p\u003e\n\u003cp\u003e내 구현은 SQS를 기반으로 하고 있지만 모든 다양한 이벤트 주도형 ESMs 구성에 적응시킬 수 있어요. 작은 사용자 정의 후처리 후 반-열린 상태로 커스터마이즈된 구성을 이용해요.\u003c/p\u003e\n\u003cp\u003e테스트\n해당 솔루션은 여러 다른 알람 구성을 이용해 FIS로 테스트했어요. 아래에서는 예제 알람 상태 전이의 동작을 확인할 수 있어요.\u003c/p\u003e\n\u003cp\u003e이 접근 방식은 반-열린 상태로 이동하는 빈도를 제어하는 유연성이 부족하지만, 코드에 액세스할 수 없거나 람다 핸들러에 복잡성을 추가하고 싶지 않은 경우에는 좋아요.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003ch1\u003e요약\u003c/h1\u003e\n\u003cp\u003e분산 시스템에서 서킷 브레이커를 올바르게 구현하는 것은 매우 어려울 수 있으며 고려해야 할 다양한 트레이드오프와 접근 방식이 많이 있습니다. 경우에 따라 분산된 서킷 브레이커가 전혀 필요하지 않을 수도 있습니다. 예를 들어, 작은 람다 소비자 풀의 경우에는 서킷 상태 메모리가 충분할 수도 있습니다.\u003c/p\u003e\n\u003cp\u003e만약 당신의 케이스에 해당하지 않는다면, 이 글이 당신에게 결정을 도와주거나 구현 중 고려해야 할 사항에 대한 아이디어를 제공해 줄 수 있기를 바랍니다. 아래에서는 당신을 위한 결정 트리를 만들어 보았습니다. 전통적인 접근 방식이 여전히 최선이라고 믿지만 ESM 기반 서킷 브레이커의 사용 사례도 볼 수 있습니다.\u003c/p\u003e\n\u003cp\u003e해당 주제에 대해 토의하고 싶다면, #believeinserverless 커뮤니티에 가입하여 이곳에서 커뮤니티와 논의할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e시간 내어 주셔서 감사합니다! 이 주제에 대한 여러분의 생각을 듣고 싶습니다! 연락을 주세요:\u003c/p\u003e\n\u003ch2\u003e부가 설명\u003c/h2\u003e\n\u003cp\u003e또 다른 접근법\n이곳에서 읽을 수 있는 Sheen Brisals가 시도한 Circuit Breakers with retries 및 archiving events에 대한 접근법: \u003ca href=\"https://sbrisals.medium.com/amazon-eventbridge-archive-replay-events-in-tandem-with-a-circuit-breaker-c049a4c6857f\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://sbrisals.medium.com/amazon-eventbridge-archive-replay-events-in-tandem-with-a-circuit-breaker-c049a4c6857f\u003c/a\u003e 또는 여기서 저자가 아이디어를 제시하는 동영상을 시청하세요(멋진 이야기입니다):\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-23-DistributedCircuitBreakersinEvent-DrivenArchitecturesonAWS"},"buildId":"bb_yO9GbCvdfc_n71SfUf","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>