<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Delta 테이블을 REST API를 통해 노출하는 방법 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-05-18-HowtoExposeDeltaTablesviaRESTAPIs" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Delta 테이블을 REST API를 통해 노출하는 방법 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="Delta 테이블을 REST API를 통해 노출하는 방법 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-18-HowtoExposeDeltaTablesviaRESTAPIs_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-05-18-HowtoExposeDeltaTablesviaRESTAPIs" data-gatsby-head="true"/><meta name="twitter:title" content="Delta 테이블을 REST API를 통해 노출하는 방법 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-18-HowtoExposeDeltaTablesviaRESTAPIs_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-18 18:06" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/acd99c507555fdc6.css" as="style"/><link rel="stylesheet" href="/_next/static/css/acd99c507555fdc6.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-4f7b40c1114f0d09.js" defer=""></script><script src="/_next/static/RZIEBQ2aNAp_DXFVTV6eL/_buildManifest.js" defer=""></script><script src="/_next/static/RZIEBQ2aNAp_DXFVTV6eL/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Delta 테이블을 REST API를 통해 노출하는 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Delta 테이블을 REST API를 통해 노출하는 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 18, 2024</span><span class="posts_reading_time__f7YPP">7<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-18-HowtoExposeDeltaTablesviaRESTAPIs&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h2>델타 테이블을 제공하기 위해 토론 및 테스트된 세 가지 아키텍처</h2>
<p><img src="/assets/img/2024-05-18-HowtoExposeDeltaTablesviaRESTAPIs_0.png" alt="이미지"></p>
<h1>1. 소개</h1>
<p>메달리온 아키텍처 내의 델타 테이블은 일반적으로 데이터 제품을 생성하는 데 사용됩니다. 이러한 데이터 제품은 데이터 과학, 데이터 분석 및 보고를 위해 사용됩니다. 그러나 데이터 제품을 REST API를 통해 노출하는 것도 일반적인 문제입니다. 이 아이디어는 이러한 API를 더 엄격한 성능 요구 사항을 갖춘 웹 앱에 내장하는 것입니다. 중요한 질문은 다음과 같습니다:</p>
<p>데팔타 테이블에서 데이터를 읽는 것이 웹 애플리케이션에 빠르게 서비스할 수 있을까요?
솔루션을 확장할 수 있는 컴퓨팅 레이어가 필요할까요?
엄격한 성능 요구 사항을 충족시키기 위한 스토리지 레이어가 필요할까요?</p>
<p>이러한 질문에 대해 심층적으로 다루기 위해 세 가지 아키텍처가 다음과 같이 평가됩니다: 아키텍처 A — API의 라이브러리, 아키텍처 B — 컴퓨팅 레이어 및 아키텍처 C — 스토리지 레이어. 아래 이미지 참조하세요.</p>
<p><img src="/assets/img/2024-05-18-HowtoExposeDeltaTablesviaRESTAPIs_1.png" alt="image"></p>
<p>블로그 글의 나머지 부분에서 세 가지 아키텍처에 대한 설명을 제공하고, 배포 및 테스트를 수행한 후 결과를 도출합니다.</p>
<h1>2. 아키텍처 설명</h1>
<h2>2.1 아키텍처 A: DuckDB와 PyArrow를 사용한 API 내 라이브러리</h2>
<p>이 아키텍처에서는 API가 직접 델타 테이블에 연결되어 있으며 중간에 계산 레이어가 없습니다. 이는 데이터가 API 자체의 메모리와 계산을 사용하여 분석된다는 것을 의미합니다. 성능을 향상시키기 위해 내장 데이터베이스 DuckDB와 PyArrow의 Python 라이브러리를 사용합니다. 이러한 라이브러리는 API에서 필요한 열만로드되도록 보장합니다.</p>
<p><img src="/assets/img/2024-05-18-HowtoExposeDeltaTablesviaRESTAPIs_2.png" alt="이미지"></p>
<p>이 아키텍처의 장점은 데이터를 중복으로 만들 필요가 없으며 API와 델탔 테이블 사이에 필요한 레이어가 없다는 것입니다. 이는 구성 요소가 적다는 것을 의미합니다.</p>
<p>이 아키텍처의 단점은 확장하기 어렵고 모든 작업을 API의 컴퓨팅 및 메모리에서 처리해야 한다는 것입니다. 특히 많은 양의 데이터를 분석해야 하는 경우에는 특히 도전적입니다. 이는 많은 레코드, 큰 컬럼 또는 많은 동시 요청에서 나올 수 있습니다.</p>
<h2>2.2 아키텍처 B: Synapse, Databricks 또는 Fabric을 사용하는 컴퓨팅 레이어</h2>
<p>이 아키텍처에서 API는 컴퓨팅 레이어에 연결되고 델탔 테이블에 직접 연결되지 않습니다. 이 컴퓨팅 레이어는 델타 테이블에서 데이터를 가져와 데이터를 분석합니다. 컴퓨팅 레이어는 Azure Synapse, Azure Databricks 또는 Microsoft Fabric일 수 있으며 일반적으로 잘 확장됩니다. 데이터는 컴퓨팅 레이어로 중복되지 않지만 컴퓨팅 레이어에서 캐싱을 적용할 수 있습니다. 이 블로그의 남은 부분에서는 Synapse Serverless로 테스트 되었습니다.</p>
<p><img src="/assets/img/2024-05-18-HowtoExposeDeltaTablesviaRESTAPIs_3.png" alt="image"></p>
<p>이 아키텍처의 장점은 데이터를 중복하여 저장할 필요가 없으며 아키텍처가 잘 확장된다는 것입니다. 또한 대규모 데이터 세트를 처리하는 데 사용할 수 있습니다.</p>
<p>이 아키텍처의 단점은 API와 델타 테이블 사이에 추가적인 레이어가 필요하다는 것입니다. 이는 더 많은 이동 부품을 유지 및 보안해야 한다는 의미입니다.</p>
<h2>2.3 아키텍처 C: Azure SQL이나 Cosmos DB를 사용한 최적화된 저장 레이어</h2>
<p>이 아키텍처에서 API는 델타 테이블에 직접 연결되지 않고, 델타 테이블이 복제된 다른 저장 계층에 연결됩니다. 다른 저장 계층은 Azure SQL 또는 Cosmos DB일 수 있습니다. 이 저장 계층은 데이터를 빠르게 검색하기 위해 최적화될 수 있습니다. 이 블로그의 나머지 부분에서는 Azure SQL을 사용하여 테스트를 진행합니다.</p>
<p><img src="/assets/img/2024-05-18-HowtoExposeDeltaTablesviaRESTAPIs_4.png" alt="이미지"></p>
<p>이 아키텍처의 장점은 저장 계층이 인덱스, 파티셔닝 및 머티얼라이즈드 뷰를 사용하여 데이터를 빠르게 읽을 수 있도록 최적화될 수 있다는 것입니다. 이는 주로 요청-응답 웹 앱 시나리오에서 요구 사항입니다.</p>
<p>이 아키텍처의 단점은 데이터가 중복되어야 하며 API와 델타 테이블 사이에 추가적인 계층이 필요하다는 것입니다. 이는 더 많은 구성 요소를 유지보수하고 보안해야 한다는 의미입니다.</p>
<p>블로그의 나머지 부분에서 아키텍처를 배포하고 테스트합니다.</p>
<h1>3. 아키텍처 배포 및 테스트</h1>
<h2>3.1 아키텍처 배포</h2>
<p>아키텍처를 배포하기 위해 이전 장에서 논의한 세 가지 솔루션을 배포하는 GitHub 프로젝트가 생성되었습니다. 해당 프로젝트는 아래 링크에서 확인할 수 있습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-attr">https</span>:<span class="hljs-comment">//github.com/rebremer/expose-deltatable-via-restapi</span>
</code></pre>
<p>다음은 GitHub 프로젝트를 실행할 때 배포될 내용입니다:</p>
<ul>
<li>표준 테스트 데이터 세트 WideWorldImporterdDW full에서 시작한 델타 테이블. 테스트 데이터 세트는 50백만 건의 레코드와 22개 열로 구성되어 있으며 1개의 큰 설명 열이 있습니다.</li>
<li>모든 아키텍처: API로 작용하는 Azure Function.</li>
<li>아키텍처 B: 컴퓨팅 계층으로 작용하는 Synapse Serverless.</li>
<li>아키텍처 C: 최적화된 저장 계층으로 작용하는 Azure SQL.</li>
</ul>
<p>배포된 후 테스트를 실행할 수 있습니다. 다음 단락에서 테스트에 대해 설명하겠습니다.```</p>
<h2>3.2 테스트 아키텍처</h2>
<p>아키텍처를 테스트하기 위해 다양한 유형의 쿼리 및 다른 스케일링을 적용할 것입니다. 다양한 유형의 쿼리는 다음과 같이 설명할 수 있습니다:</p>
<ul>
<li>11개의 작은 열(char, integer, datetime)을 포함하는 20개 레코드를 조회합니다.</li>
<li>각 필드당 500자 이상을 포함하는 큰 설명 열이 포함된 2개 열을 사용하여 20개 레코드를 조회합니다.</li>
<li>그룹별 데이터 집계, having, max, average를 사용한 데이터 집계.</li>
</ul>
<p>아래에서 쿼리를 설명합니다.</p>
<pre><code class="hljs language-sql"><span class="hljs-comment">-- 쿼리 1: 대형 텍스트 없이 11개 열의 포인트 조회</span>
<span class="hljs-keyword">SELECT</span> SaleKey, TaxAmount, CityKey, CustomerKey, BillToCustomerKey, SalespersonKey, DeliveryDateKey, Package 
<span class="hljs-keyword">FROM</span> silver_fact_sale
<span class="hljs-keyword">WHERE</span> CityKey<span class="hljs-operator">=</span><span class="hljs-number">41749</span> <span class="hljs-keyword">and</span> SalespersonKey<span class="hljs-operator">=</span><span class="hljs-number">40</span> <span class="hljs-keyword">and</span> CustomerKey<span class="hljs-operator">=</span><span class="hljs-number">397</span> <span class="hljs-keyword">and</span> TaxAmount <span class="hljs-operator">></span> <span class="hljs-number">20</span>
<span class="hljs-comment">-- 쿼리 2: 500자 이상의 Description 열</span>
<span class="hljs-keyword">SELECT</span> SaleKey, Description 
<span class="hljs-keyword">FROM</span> silver_fact_sale
<span class="hljs-keyword">WHERE</span> CityKey<span class="hljs-operator">=</span><span class="hljs-number">41749</span> <span class="hljs-keyword">and</span> SalespersonKey<span class="hljs-operator">=</span><span class="hljs-number">40</span> <span class="hljs-keyword">and</span> CustomerKey<span class="hljs-operator">=</span><span class="hljs-number">397</span> <span class="hljs-keyword">and</span> TaxAmount <span class="hljs-operator">></span> <span class="hljs-number">20</span>
<span class="hljs-comment">-- 쿼리 3: 집계</span>
<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MAX</span>(DeliveryDateKey), CityKey, <span class="hljs-built_in">AVG</span>(TaxAmount)
<span class="hljs-keyword">FROM</span> silver_fact_sale
<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> CityKey
<span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">COUNT</span>(CityKey) <span class="hljs-operator">></span> <span class="hljs-number">10</span>
</code></pre>
<p>다음과 같이 스케일링이 가능합니다:</p>
<ul>
<li>아키텍처 A의 경우, 데이터 처리는 API 자체에서 수행됩니다. 이는 API의 컴퓨트 및 메모리가 앱 서비스 플랜을 통해 사용된다는 것을 의미합니다. SKU Basic(1코어 및 1.75GB 메모리) 및 SKU P1V3 SKU(2코어, 8GB 메모리)로 테스트될 것입니다. 아키텍처 B 및 C의 경우에는 처리가 다른 곳에서 이루어지기 때문에 이러한 정보는 해당하지 않습니다.</li>
<li>아키텍처 B의 경우, Synapse Serverless가 사용됩니다. 스케일링은 자동으로 이루어집니다.</li>
<li>아키텍처 C의 경우, 표준 티어의 Azure SQL 데이터베이스가 125 DTU로 사용됩니다. CityKey에 인덱스가 없는 상태와 CityKey에 인덱스가 있는 상태에서 테스트될 것입니다.</li>
</ul>
<p>다음 단락에서 결과가 설명됩니다.</p>
<h2>3.3 결과</h2>
<p>아키텍처를 배포하고 테스트한 후에는 결과를 얻을 수 있습니다. 다음은 결과 요약입니다:</p>
<p><img src="/assets/img/2024-05-18-HowtoExposeDeltaTablesviaRESTAPIs_5.png" alt="Results"></p>
<p>아키텍처 A는 SKU B1로 배포할 수 없습니다. 만약 SKU P1V3가 사용된다면, 컬럼 크기가 크지 않다면 결과는 15초 이내에 계산될 수 있습니다. 모든 데이터를 API 앱 서비스 계획에서 분석한다는 점을 유의하십시오. 너무 많은 데이터가로드되면(많은 행, 큰 컬럼 및/또는 많은 동시 요청으로),이 아키텍처는 확장하기 어려울 수 있습니다.</p>
<p>아키텍처 B는 Synapse Serverless를 사용하여 10-15초 내에 작동합니다. 계산은 데이터를 가져와 분석하기 위해 자동으로 조정되는 Synapse Serverless에서 이루어집니다. 성능은 세 가지 유형의 쿼리에 대해 일관되게 유지됩니다.</p>
<p>아키텍처 C는 Azure SQL을 사용할 때 인덱스가 생성되면 가장 잘 작동합니다. 조회 쿼리 1과 2의 경우 API는 대략 1초 내에 응답합니다. 쿼리 3은 전체 테이블 스캔이 필요하며 성능은 다른 솔루션과 거의 동일합니다.</p>
<h1>3. 결론</h1>
<p>중재 아키텍처의 Delta 테이블은 일반적으로 데이터 제품을 생성하는 데 사용됩니다. 이러한 데이터 제품은 데이터 과학, 데이터 분석 및 보고서 작성에 사용됩니다. 그러나 일반적으로 Delta 테이블을 REST API를 통해 노출하는 것도 자주 묻는 질문 중 하나입니다. 이 블로그 포스트에서는 이와 같은 장단점을 갖는 세 가지 아키텍처가 설명되어 있습니다.</p>
<p>Architecture A: DuckDB 및 PyArrow를 사용하여 API 내 라이브러리를 활용하는 아키텍처입니다.
이 아키텍처에서는 API가 직접 델타 테이블에 연결되어 중간 계층이 없습니다. 이는 모든 데이터가 메모리에서 분석되고 Azure Function의 연산을 함께 함을 의미합니다.</p>
<ul>
<li>이 아키텍처의 장점은 추가 리소스가 필요하지 않다는 것입니다. 이는 유지 및 보안해야 하는 부분이 적기 때문에 이점으로 작용합니다.</li>
<li>이 아키텍처의 단점은 API 자체에서 모든 데이터를 분석해야 하기 때문에 확장성이 떨어진다는 것입니다. 따라서 소량의 데이터에만 사용해야 합니다.</li>
</ul>
<p>Architecture B: Synapse, Databricks 또는 Fabric을 사용한 컴퓨팅 레이어.
이 아키텍처에서는 API가 컴퓨팅 레이어에 연결됩니다. 이 컴퓨팅 레이어는 델타 테이블에서 데이터를 가져와 분석합니다.</p>
<ul>
<li>이 아키텍처의 장점은 확장성이 좋고 데이터가 중복되지 않습니다. 집계를 수행하며 대량의 데이터를 분석하는 쿼리에 적합합니다.</li>
<li>이 아키텍처의 단점은 조회 쿼리에 일관되게 5초 이내의 응답을 받는 것이 불가능하다는 것입니다. 또한 추가 리소스를 보안 및 유지해야 합니다.</li>
</ul>
<p>아키텍처 C: Azure SQL 또는 Cosmos DB를 사용한 최적화된 저장 계층입니다.</p>
<p>이 아키텍처에서는 API가 최적화된 저장 계층에 연결됩니다. 델타 테이블이 미리 이 저장 계층으로 복제되며 데이터를 검색하고 분석하는 데 사용됩니다.</p>
<ul>
<li>이 아키텍처의 장점은 인덱스, 파티셔닝, 머티얼라이즈드 뷰를 사용하여 룩업의 빠른 쿼리를 위해 최적화될 수 있다는 것입니다. 이것은 종종 요청-응답 웹 앱에 필요한 요구사항입니다.</li>
<li>이 아키텍처의 단점은 데이터가 다른 저장 계층으로 중복되어 동기화가 유지되어야 한다는 것입니다. 또한 추가 자원을 보안하고 유지해야 합니다.</li>
</ul>
<p>안타깝게도, 완벽한 해결책은 없습니다. 이 글은 REST API를 통해 델타 테이블을 노출하는 데 가장 적합한 아키텍처를 선택하는 데 도움을 주기 위한 가이드를 제시했습니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Delta 테이블을 REST API를 통해 노출하는 방법","description":"","date":"2024-05-18 18:06","slug":"2024-05-18-HowtoExposeDeltaTablesviaRESTAPIs","content":"\n\n## 델타 테이블을 제공하기 위해 토론 및 테스트된 세 가지 아키텍처\n\n![이미지](/assets/img/2024-05-18-HowtoExposeDeltaTablesviaRESTAPIs_0.png)\n\n# 1. 소개\n\n메달리온 아키텍처 내의 델타 테이블은 일반적으로 데이터 제품을 생성하는 데 사용됩니다. 이러한 데이터 제품은 데이터 과학, 데이터 분석 및 보고를 위해 사용됩니다. 그러나 데이터 제품을 REST API를 통해 노출하는 것도 일반적인 문제입니다. 이 아이디어는 이러한 API를 더 엄격한 성능 요구 사항을 갖춘 웹 앱에 내장하는 것입니다. 중요한 질문은 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n데팔타 테이블에서 데이터를 읽는 것이 웹 애플리케이션에 빠르게 서비스할 수 있을까요?\n솔루션을 확장할 수 있는 컴퓨팅 레이어가 필요할까요?\n엄격한 성능 요구 사항을 충족시키기 위한 스토리지 레이어가 필요할까요?\n\n이러한 질문에 대해 심층적으로 다루기 위해 세 가지 아키텍처가 다음과 같이 평가됩니다: 아키텍처 A — API의 라이브러리, 아키텍처 B — 컴퓨팅 레이어 및 아키텍처 C — 스토리지 레이어. 아래 이미지 참조하세요.\n\n![image](/assets/img/2024-05-18-HowtoExposeDeltaTablesviaRESTAPIs_1.png)\n\n블로그 글의 나머지 부분에서 세 가지 아키텍처에 대한 설명을 제공하고, 배포 및 테스트를 수행한 후 결과를 도출합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 2. 아키텍처 설명\n\n## 2.1 아키텍처 A: DuckDB와 PyArrow를 사용한 API 내 라이브러리\n\n이 아키텍처에서는 API가 직접 델타 테이블에 연결되어 있으며 중간에 계산 레이어가 없습니다. 이는 데이터가 API 자체의 메모리와 계산을 사용하여 분석된다는 것을 의미합니다. 성능을 향상시키기 위해 내장 데이터베이스 DuckDB와 PyArrow의 Python 라이브러리를 사용합니다. 이러한 라이브러리는 API에서 필요한 열만로드되도록 보장합니다.\n\n![이미지](/assets/img/2024-05-18-HowtoExposeDeltaTablesviaRESTAPIs_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 아키텍처의 장점은 데이터를 중복으로 만들 필요가 없으며 API와 델탔 테이블 사이에 필요한 레이어가 없다는 것입니다. 이는 구성 요소가 적다는 것을 의미합니다.\n\n이 아키텍처의 단점은 확장하기 어렵고 모든 작업을 API의 컴퓨팅 및 메모리에서 처리해야 한다는 것입니다. 특히 많은 양의 데이터를 분석해야 하는 경우에는 특히 도전적입니다. 이는 많은 레코드, 큰 컬럼 또는 많은 동시 요청에서 나올 수 있습니다.\n\n## 2.2 아키텍처 B: Synapse, Databricks 또는 Fabric을 사용하는 컴퓨팅 레이어\n\n이 아키텍처에서 API는 컴퓨팅 레이어에 연결되고 델탔 테이블에 직접 연결되지 않습니다. 이 컴퓨팅 레이어는 델타 테이블에서 데이터를 가져와 데이터를 분석합니다. 컴퓨팅 레이어는 Azure Synapse, Azure Databricks 또는 Microsoft Fabric일 수 있으며 일반적으로 잘 확장됩니다. 데이터는 컴퓨팅 레이어로 중복되지 않지만 컴퓨팅 레이어에서 캐싱을 적용할 수 있습니다. 이 블로그의 남은 부분에서는 Synapse Serverless로 테스트 되었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![image](/assets/img/2024-05-18-HowtoExposeDeltaTablesviaRESTAPIs_3.png)\n\n이 아키텍처의 장점은 데이터를 중복하여 저장할 필요가 없으며 아키텍처가 잘 확장된다는 것입니다. 또한 대규모 데이터 세트를 처리하는 데 사용할 수 있습니다.\n\n이 아키텍처의 단점은 API와 델타 테이블 사이에 추가적인 레이어가 필요하다는 것입니다. 이는 더 많은 이동 부품을 유지 및 보안해야 한다는 의미입니다.\n\n## 2.3 아키텍처 C: Azure SQL이나 Cosmos DB를 사용한 최적화된 저장 레이어\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 아키텍처에서 API는 델타 테이블에 직접 연결되지 않고, 델타 테이블이 복제된 다른 저장 계층에 연결됩니다. 다른 저장 계층은 Azure SQL 또는 Cosmos DB일 수 있습니다. 이 저장 계층은 데이터를 빠르게 검색하기 위해 최적화될 수 있습니다. 이 블로그의 나머지 부분에서는 Azure SQL을 사용하여 테스트를 진행합니다.\n\n![이미지](/assets/img/2024-05-18-HowtoExposeDeltaTablesviaRESTAPIs_4.png)\n\n이 아키텍처의 장점은 저장 계층이 인덱스, 파티셔닝 및 머티얼라이즈드 뷰를 사용하여 데이터를 빠르게 읽을 수 있도록 최적화될 수 있다는 것입니다. 이는 주로 요청-응답 웹 앱 시나리오에서 요구 사항입니다.\n\n이 아키텍처의 단점은 데이터가 중복되어야 하며 API와 델타 테이블 사이에 추가적인 계층이 필요하다는 것입니다. 이는 더 많은 구성 요소를 유지보수하고 보안해야 한다는 의미입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n블로그의 나머지 부분에서 아키텍처를 배포하고 테스트합니다.\n\n# 3. 아키텍처 배포 및 테스트\n\n## 3.1 아키텍처 배포\n\n아키텍처를 배포하기 위해 이전 장에서 논의한 세 가지 솔루션을 배포하는 GitHub 프로젝트가 생성되었습니다. 해당 프로젝트는 아래 링크에서 확인할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nhttps://github.com/rebremer/expose-deltatable-via-restapi\n```\n\n다음은 GitHub 프로젝트를 실행할 때 배포될 내용입니다:\n\n- 표준 테스트 데이터 세트 WideWorldImporterdDW full에서 시작한 델타 테이블. 테스트 데이터 세트는 50백만 건의 레코드와 22개 열로 구성되어 있으며 1개의 큰 설명 열이 있습니다.\n- 모든 아키텍처: API로 작용하는 Azure Function.\n- 아키텍처 B: 컴퓨팅 계층으로 작용하는 Synapse Serverless.\n- 아키텍처 C: 최적화된 저장 계층으로 작용하는 Azure SQL.\n\n배포된 후 테스트를 실행할 수 있습니다. 다음 단락에서 테스트에 대해 설명하겠습니다.```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 3.2 테스트 아키텍처\n\n아키텍처를 테스트하기 위해 다양한 유형의 쿼리 및 다른 스케일링을 적용할 것입니다. 다양한 유형의 쿼리는 다음과 같이 설명할 수 있습니다:\n\n- 11개의 작은 열(char, integer, datetime)을 포함하는 20개 레코드를 조회합니다.\n- 각 필드당 500자 이상을 포함하는 큰 설명 열이 포함된 2개 열을 사용하여 20개 레코드를 조회합니다.\n- 그룹별 데이터 집계, having, max, average를 사용한 데이터 집계.\n\n아래에서 쿼리를 설명합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```sql\n-- 쿼리 1: 대형 텍스트 없이 11개 열의 포인트 조회\nSELECT SaleKey, TaxAmount, CityKey, CustomerKey, BillToCustomerKey, SalespersonKey, DeliveryDateKey, Package \nFROM silver_fact_sale\nWHERE CityKey=41749 and SalespersonKey=40 and CustomerKey=397 and TaxAmount \u003e 20\n-- 쿼리 2: 500자 이상의 Description 열\nSELECT SaleKey, Description \nFROM silver_fact_sale\nWHERE CityKey=41749 and SalespersonKey=40 and CustomerKey=397 and TaxAmount \u003e 20\n-- 쿼리 3: 집계\nSELECT MAX(DeliveryDateKey), CityKey, AVG(TaxAmount)\nFROM silver_fact_sale\nGROUP BY CityKey\nHAVING COUNT(CityKey) \u003e 10\n```\n\n다음과 같이 스케일링이 가능합니다:\n\n- 아키텍처 A의 경우, 데이터 처리는 API 자체에서 수행됩니다. 이는 API의 컴퓨트 및 메모리가 앱 서비스 플랜을 통해 사용된다는 것을 의미합니다. SKU Basic(1코어 및 1.75GB 메모리) 및 SKU P1V3 SKU(2코어, 8GB 메모리)로 테스트될 것입니다. 아키텍처 B 및 C의 경우에는 처리가 다른 곳에서 이루어지기 때문에 이러한 정보는 해당하지 않습니다.\n- 아키텍처 B의 경우, Synapse Serverless가 사용됩니다. 스케일링은 자동으로 이루어집니다.\n- 아키텍처 C의 경우, 표준 티어의 Azure SQL 데이터베이스가 125 DTU로 사용됩니다. CityKey에 인덱스가 없는 상태와 CityKey에 인덱스가 있는 상태에서 테스트될 것입니다.\n\n다음 단락에서 결과가 설명됩니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 3.3 결과\n\n아키텍처를 배포하고 테스트한 후에는 결과를 얻을 수 있습니다. 다음은 결과 요약입니다:\n\n![Results](/assets/img/2024-05-18-HowtoExposeDeltaTablesviaRESTAPIs_5.png)\n\n아키텍처 A는 SKU B1로 배포할 수 없습니다. 만약 SKU P1V3가 사용된다면, 컬럼 크기가 크지 않다면 결과는 15초 이내에 계산될 수 있습니다. 모든 데이터를 API 앱 서비스 계획에서 분석한다는 점을 유의하십시오. 너무 많은 데이터가로드되면(많은 행, 큰 컬럼 및/또는 많은 동시 요청으로),이 아키텍처는 확장하기 어려울 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아키텍처 B는 Synapse Serverless를 사용하여 10-15초 내에 작동합니다. 계산은 데이터를 가져와 분석하기 위해 자동으로 조정되는 Synapse Serverless에서 이루어집니다. 성능은 세 가지 유형의 쿼리에 대해 일관되게 유지됩니다.\n\n아키텍처 C는 Azure SQL을 사용할 때 인덱스가 생성되면 가장 잘 작동합니다. 조회 쿼리 1과 2의 경우 API는 대략 1초 내에 응답합니다. 쿼리 3은 전체 테이블 스캔이 필요하며 성능은 다른 솔루션과 거의 동일합니다.\n\n# 3. 결론\n\n중재 아키텍처의 Delta 테이블은 일반적으로 데이터 제품을 생성하는 데 사용됩니다. 이러한 데이터 제품은 데이터 과학, 데이터 분석 및 보고서 작성에 사용됩니다. 그러나 일반적으로 Delta 테이블을 REST API를 통해 노출하는 것도 자주 묻는 질문 중 하나입니다. 이 블로그 포스트에서는 이와 같은 장단점을 갖는 세 가지 아키텍처가 설명되어 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nArchitecture A: DuckDB 및 PyArrow를 사용하여 API 내 라이브러리를 활용하는 아키텍처입니다.\n이 아키텍처에서는 API가 직접 델타 테이블에 연결되어 중간 계층이 없습니다. 이는 모든 데이터가 메모리에서 분석되고 Azure Function의 연산을 함께 함을 의미합니다.\n\n- 이 아키텍처의 장점은 추가 리소스가 필요하지 않다는 것입니다. 이는 유지 및 보안해야 하는 부분이 적기 때문에 이점으로 작용합니다.\n- 이 아키텍처의 단점은 API 자체에서 모든 데이터를 분석해야 하기 때문에 확장성이 떨어진다는 것입니다. 따라서 소량의 데이터에만 사용해야 합니다.\n\nArchitecture B: Synapse, Databricks 또는 Fabric을 사용한 컴퓨팅 레이어.\n이 아키텍처에서는 API가 컴퓨팅 레이어에 연결됩니다. 이 컴퓨팅 레이어는 델타 테이블에서 데이터를 가져와 분석합니다.\n\n- 이 아키텍처의 장점은 확장성이 좋고 데이터가 중복되지 않습니다. 집계를 수행하며 대량의 데이터를 분석하는 쿼리에 적합합니다.\n- 이 아키텍처의 단점은 조회 쿼리에 일관되게 5초 이내의 응답을 받는 것이 불가능하다는 것입니다. 또한 추가 리소스를 보안 및 유지해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아키텍처 C: Azure SQL 또는 Cosmos DB를 사용한 최적화된 저장 계층입니다. \n\n이 아키텍처에서는 API가 최적화된 저장 계층에 연결됩니다. 델타 테이블이 미리 이 저장 계층으로 복제되며 데이터를 검색하고 분석하는 데 사용됩니다.\n\n- 이 아키텍처의 장점은 인덱스, 파티셔닝, 머티얼라이즈드 뷰를 사용하여 룩업의 빠른 쿼리를 위해 최적화될 수 있다는 것입니다. 이것은 종종 요청-응답 웹 앱에 필요한 요구사항입니다.\n- 이 아키텍처의 단점은 데이터가 다른 저장 계층으로 중복되어 동기화가 유지되어야 한다는 것입니다. 또한 추가 자원을 보안하고 유지해야 합니다.\n\n안타깝게도, 완벽한 해결책은 없습니다. 이 글은 REST API를 통해 델타 테이블을 노출하는 데 가장 적합한 아키텍처를 선택하는 데 도움을 주기 위한 가이드를 제시했습니다.","ogImage":{"url":"/assets/img/2024-05-18-HowtoExposeDeltaTablesviaRESTAPIs_0.png"},"coverImage":"/assets/img/2024-05-18-HowtoExposeDeltaTablesviaRESTAPIs_0.png","tag":["Tech"],"readingTime":7},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch2\u003e델타 테이블을 제공하기 위해 토론 및 테스트된 세 가지 아키텍처\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-18-HowtoExposeDeltaTablesviaRESTAPIs_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch1\u003e1. 소개\u003c/h1\u003e\n\u003cp\u003e메달리온 아키텍처 내의 델타 테이블은 일반적으로 데이터 제품을 생성하는 데 사용됩니다. 이러한 데이터 제품은 데이터 과학, 데이터 분석 및 보고를 위해 사용됩니다. 그러나 데이터 제품을 REST API를 통해 노출하는 것도 일반적인 문제입니다. 이 아이디어는 이러한 API를 더 엄격한 성능 요구 사항을 갖춘 웹 앱에 내장하는 것입니다. 중요한 질문은 다음과 같습니다:\u003c/p\u003e\n\u003cp\u003e데팔타 테이블에서 데이터를 읽는 것이 웹 애플리케이션에 빠르게 서비스할 수 있을까요?\n솔루션을 확장할 수 있는 컴퓨팅 레이어가 필요할까요?\n엄격한 성능 요구 사항을 충족시키기 위한 스토리지 레이어가 필요할까요?\u003c/p\u003e\n\u003cp\u003e이러한 질문에 대해 심층적으로 다루기 위해 세 가지 아키텍처가 다음과 같이 평가됩니다: 아키텍처 A — API의 라이브러리, 아키텍처 B — 컴퓨팅 레이어 및 아키텍처 C — 스토리지 레이어. 아래 이미지 참조하세요.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-18-HowtoExposeDeltaTablesviaRESTAPIs_1.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e블로그 글의 나머지 부분에서 세 가지 아키텍처에 대한 설명을 제공하고, 배포 및 테스트를 수행한 후 결과를 도출합니다.\u003c/p\u003e\n\u003ch1\u003e2. 아키텍처 설명\u003c/h1\u003e\n\u003ch2\u003e2.1 아키텍처 A: DuckDB와 PyArrow를 사용한 API 내 라이브러리\u003c/h2\u003e\n\u003cp\u003e이 아키텍처에서는 API가 직접 델타 테이블에 연결되어 있으며 중간에 계산 레이어가 없습니다. 이는 데이터가 API 자체의 메모리와 계산을 사용하여 분석된다는 것을 의미합니다. 성능을 향상시키기 위해 내장 데이터베이스 DuckDB와 PyArrow의 Python 라이브러리를 사용합니다. 이러한 라이브러리는 API에서 필요한 열만로드되도록 보장합니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-18-HowtoExposeDeltaTablesviaRESTAPIs_2.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e이 아키텍처의 장점은 데이터를 중복으로 만들 필요가 없으며 API와 델탔 테이블 사이에 필요한 레이어가 없다는 것입니다. 이는 구성 요소가 적다는 것을 의미합니다.\u003c/p\u003e\n\u003cp\u003e이 아키텍처의 단점은 확장하기 어렵고 모든 작업을 API의 컴퓨팅 및 메모리에서 처리해야 한다는 것입니다. 특히 많은 양의 데이터를 분석해야 하는 경우에는 특히 도전적입니다. 이는 많은 레코드, 큰 컬럼 또는 많은 동시 요청에서 나올 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e2.2 아키텍처 B: Synapse, Databricks 또는 Fabric을 사용하는 컴퓨팅 레이어\u003c/h2\u003e\n\u003cp\u003e이 아키텍처에서 API는 컴퓨팅 레이어에 연결되고 델탔 테이블에 직접 연결되지 않습니다. 이 컴퓨팅 레이어는 델타 테이블에서 데이터를 가져와 데이터를 분석합니다. 컴퓨팅 레이어는 Azure Synapse, Azure Databricks 또는 Microsoft Fabric일 수 있으며 일반적으로 잘 확장됩니다. 데이터는 컴퓨팅 레이어로 중복되지 않지만 컴퓨팅 레이어에서 캐싱을 적용할 수 있습니다. 이 블로그의 남은 부분에서는 Synapse Serverless로 테스트 되었습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-18-HowtoExposeDeltaTablesviaRESTAPIs_3.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e이 아키텍처의 장점은 데이터를 중복하여 저장할 필요가 없으며 아키텍처가 잘 확장된다는 것입니다. 또한 대규모 데이터 세트를 처리하는 데 사용할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이 아키텍처의 단점은 API와 델타 테이블 사이에 추가적인 레이어가 필요하다는 것입니다. 이는 더 많은 이동 부품을 유지 및 보안해야 한다는 의미입니다.\u003c/p\u003e\n\u003ch2\u003e2.3 아키텍처 C: Azure SQL이나 Cosmos DB를 사용한 최적화된 저장 레이어\u003c/h2\u003e\n\u003cp\u003e이 아키텍처에서 API는 델타 테이블에 직접 연결되지 않고, 델타 테이블이 복제된 다른 저장 계층에 연결됩니다. 다른 저장 계층은 Azure SQL 또는 Cosmos DB일 수 있습니다. 이 저장 계층은 데이터를 빠르게 검색하기 위해 최적화될 수 있습니다. 이 블로그의 나머지 부분에서는 Azure SQL을 사용하여 테스트를 진행합니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-18-HowtoExposeDeltaTablesviaRESTAPIs_4.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e이 아키텍처의 장점은 저장 계층이 인덱스, 파티셔닝 및 머티얼라이즈드 뷰를 사용하여 데이터를 빠르게 읽을 수 있도록 최적화될 수 있다는 것입니다. 이는 주로 요청-응답 웹 앱 시나리오에서 요구 사항입니다.\u003c/p\u003e\n\u003cp\u003e이 아키텍처의 단점은 데이터가 중복되어야 하며 API와 델타 테이블 사이에 추가적인 계층이 필요하다는 것입니다. 이는 더 많은 구성 요소를 유지보수하고 보안해야 한다는 의미입니다.\u003c/p\u003e\n\u003cp\u003e블로그의 나머지 부분에서 아키텍처를 배포하고 테스트합니다.\u003c/p\u003e\n\u003ch1\u003e3. 아키텍처 배포 및 테스트\u003c/h1\u003e\n\u003ch2\u003e3.1 아키텍처 배포\u003c/h2\u003e\n\u003cp\u003e아키텍처를 배포하기 위해 이전 장에서 논의한 세 가지 솔루션을 배포하는 GitHub 프로젝트가 생성되었습니다. 해당 프로젝트는 아래 링크에서 확인할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-attr\"\u003ehttps\u003c/span\u003e:\u003cspan class=\"hljs-comment\"\u003e//github.com/rebremer/expose-deltatable-via-restapi\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다음은 GitHub 프로젝트를 실행할 때 배포될 내용입니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e표준 테스트 데이터 세트 WideWorldImporterdDW full에서 시작한 델타 테이블. 테스트 데이터 세트는 50백만 건의 레코드와 22개 열로 구성되어 있으며 1개의 큰 설명 열이 있습니다.\u003c/li\u003e\n\u003cli\u003e모든 아키텍처: API로 작용하는 Azure Function.\u003c/li\u003e\n\u003cli\u003e아키텍처 B: 컴퓨팅 계층으로 작용하는 Synapse Serverless.\u003c/li\u003e\n\u003cli\u003e아키텍처 C: 최적화된 저장 계층으로 작용하는 Azure SQL.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e배포된 후 테스트를 실행할 수 있습니다. 다음 단락에서 테스트에 대해 설명하겠습니다.```\u003c/p\u003e\n\u003ch2\u003e3.2 테스트 아키텍처\u003c/h2\u003e\n\u003cp\u003e아키텍처를 테스트하기 위해 다양한 유형의 쿼리 및 다른 스케일링을 적용할 것입니다. 다양한 유형의 쿼리는 다음과 같이 설명할 수 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e11개의 작은 열(char, integer, datetime)을 포함하는 20개 레코드를 조회합니다.\u003c/li\u003e\n\u003cli\u003e각 필드당 500자 이상을 포함하는 큰 설명 열이 포함된 2개 열을 사용하여 20개 레코드를 조회합니다.\u003c/li\u003e\n\u003cli\u003e그룹별 데이터 집계, having, max, average를 사용한 데이터 집계.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e아래에서 쿼리를 설명합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-sql\"\u003e\u003cspan class=\"hljs-comment\"\u003e-- 쿼리 1: 대형 텍스트 없이 11개 열의 포인트 조회\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eSELECT\u003c/span\u003e SaleKey, TaxAmount, CityKey, CustomerKey, BillToCustomerKey, SalespersonKey, DeliveryDateKey, Package \n\u003cspan class=\"hljs-keyword\"\u003eFROM\u003c/span\u003e silver_fact_sale\n\u003cspan class=\"hljs-keyword\"\u003eWHERE\u003c/span\u003e CityKey\u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e41749\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eand\u003c/span\u003e SalespersonKey\u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e40\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eand\u003c/span\u003e CustomerKey\u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e397\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eand\u003c/span\u003e TaxAmount \u003cspan class=\"hljs-operator\"\u003e\u003e\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e20\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e-- 쿼리 2: 500자 이상의 Description 열\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eSELECT\u003c/span\u003e SaleKey, Description \n\u003cspan class=\"hljs-keyword\"\u003eFROM\u003c/span\u003e silver_fact_sale\n\u003cspan class=\"hljs-keyword\"\u003eWHERE\u003c/span\u003e CityKey\u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e41749\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eand\u003c/span\u003e SalespersonKey\u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e40\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eand\u003c/span\u003e CustomerKey\u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e397\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eand\u003c/span\u003e TaxAmount \u003cspan class=\"hljs-operator\"\u003e\u003e\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e20\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e-- 쿼리 3: 집계\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eSELECT\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eMAX\u003c/span\u003e(DeliveryDateKey), CityKey, \u003cspan class=\"hljs-built_in\"\u003eAVG\u003c/span\u003e(TaxAmount)\n\u003cspan class=\"hljs-keyword\"\u003eFROM\u003c/span\u003e silver_fact_sale\n\u003cspan class=\"hljs-keyword\"\u003eGROUP\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eBY\u003c/span\u003e CityKey\n\u003cspan class=\"hljs-keyword\"\u003eHAVING\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eCOUNT\u003c/span\u003e(CityKey) \u003cspan class=\"hljs-operator\"\u003e\u003e\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다음과 같이 스케일링이 가능합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e아키텍처 A의 경우, 데이터 처리는 API 자체에서 수행됩니다. 이는 API의 컴퓨트 및 메모리가 앱 서비스 플랜을 통해 사용된다는 것을 의미합니다. SKU Basic(1코어 및 1.75GB 메모리) 및 SKU P1V3 SKU(2코어, 8GB 메모리)로 테스트될 것입니다. 아키텍처 B 및 C의 경우에는 처리가 다른 곳에서 이루어지기 때문에 이러한 정보는 해당하지 않습니다.\u003c/li\u003e\n\u003cli\u003e아키텍처 B의 경우, Synapse Serverless가 사용됩니다. 스케일링은 자동으로 이루어집니다.\u003c/li\u003e\n\u003cli\u003e아키텍처 C의 경우, 표준 티어의 Azure SQL 데이터베이스가 125 DTU로 사용됩니다. CityKey에 인덱스가 없는 상태와 CityKey에 인덱스가 있는 상태에서 테스트될 것입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e다음 단락에서 결과가 설명됩니다.\u003c/p\u003e\n\u003ch2\u003e3.3 결과\u003c/h2\u003e\n\u003cp\u003e아키텍처를 배포하고 테스트한 후에는 결과를 얻을 수 있습니다. 다음은 결과 요약입니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-18-HowtoExposeDeltaTablesviaRESTAPIs_5.png\" alt=\"Results\"\u003e\u003c/p\u003e\n\u003cp\u003e아키텍처 A는 SKU B1로 배포할 수 없습니다. 만약 SKU P1V3가 사용된다면, 컬럼 크기가 크지 않다면 결과는 15초 이내에 계산될 수 있습니다. 모든 데이터를 API 앱 서비스 계획에서 분석한다는 점을 유의하십시오. 너무 많은 데이터가로드되면(많은 행, 큰 컬럼 및/또는 많은 동시 요청으로),이 아키텍처는 확장하기 어려울 수 있습니다.\u003c/p\u003e\n\u003cp\u003e아키텍처 B는 Synapse Serverless를 사용하여 10-15초 내에 작동합니다. 계산은 데이터를 가져와 분석하기 위해 자동으로 조정되는 Synapse Serverless에서 이루어집니다. 성능은 세 가지 유형의 쿼리에 대해 일관되게 유지됩니다.\u003c/p\u003e\n\u003cp\u003e아키텍처 C는 Azure SQL을 사용할 때 인덱스가 생성되면 가장 잘 작동합니다. 조회 쿼리 1과 2의 경우 API는 대략 1초 내에 응답합니다. 쿼리 3은 전체 테이블 스캔이 필요하며 성능은 다른 솔루션과 거의 동일합니다.\u003c/p\u003e\n\u003ch1\u003e3. 결론\u003c/h1\u003e\n\u003cp\u003e중재 아키텍처의 Delta 테이블은 일반적으로 데이터 제품을 생성하는 데 사용됩니다. 이러한 데이터 제품은 데이터 과학, 데이터 분석 및 보고서 작성에 사용됩니다. 그러나 일반적으로 Delta 테이블을 REST API를 통해 노출하는 것도 자주 묻는 질문 중 하나입니다. 이 블로그 포스트에서는 이와 같은 장단점을 갖는 세 가지 아키텍처가 설명되어 있습니다.\u003c/p\u003e\n\u003cp\u003eArchitecture A: DuckDB 및 PyArrow를 사용하여 API 내 라이브러리를 활용하는 아키텍처입니다.\n이 아키텍처에서는 API가 직접 델타 테이블에 연결되어 중간 계층이 없습니다. 이는 모든 데이터가 메모리에서 분석되고 Azure Function의 연산을 함께 함을 의미합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e이 아키텍처의 장점은 추가 리소스가 필요하지 않다는 것입니다. 이는 유지 및 보안해야 하는 부분이 적기 때문에 이점으로 작용합니다.\u003c/li\u003e\n\u003cli\u003e이 아키텍처의 단점은 API 자체에서 모든 데이터를 분석해야 하기 때문에 확장성이 떨어진다는 것입니다. 따라서 소량의 데이터에만 사용해야 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eArchitecture B: Synapse, Databricks 또는 Fabric을 사용한 컴퓨팅 레이어.\n이 아키텍처에서는 API가 컴퓨팅 레이어에 연결됩니다. 이 컴퓨팅 레이어는 델타 테이블에서 데이터를 가져와 분석합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e이 아키텍처의 장점은 확장성이 좋고 데이터가 중복되지 않습니다. 집계를 수행하며 대량의 데이터를 분석하는 쿼리에 적합합니다.\u003c/li\u003e\n\u003cli\u003e이 아키텍처의 단점은 조회 쿼리에 일관되게 5초 이내의 응답을 받는 것이 불가능하다는 것입니다. 또한 추가 리소스를 보안 및 유지해야 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e아키텍처 C: Azure SQL 또는 Cosmos DB를 사용한 최적화된 저장 계층입니다.\u003c/p\u003e\n\u003cp\u003e이 아키텍처에서는 API가 최적화된 저장 계층에 연결됩니다. 델타 테이블이 미리 이 저장 계층으로 복제되며 데이터를 검색하고 분석하는 데 사용됩니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e이 아키텍처의 장점은 인덱스, 파티셔닝, 머티얼라이즈드 뷰를 사용하여 룩업의 빠른 쿼리를 위해 최적화될 수 있다는 것입니다. 이것은 종종 요청-응답 웹 앱에 필요한 요구사항입니다.\u003c/li\u003e\n\u003cli\u003e이 아키텍처의 단점은 데이터가 다른 저장 계층으로 중복되어 동기화가 유지되어야 한다는 것입니다. 또한 추가 자원을 보안하고 유지해야 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e안타깝게도, 완벽한 해결책은 없습니다. 이 글은 REST API를 통해 델타 테이블을 노출하는 데 가장 적합한 아키텍처를 선택하는 데 도움을 주기 위한 가이드를 제시했습니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-18-HowtoExposeDeltaTablesviaRESTAPIs"},"buildId":"RZIEBQ2aNAp_DXFVTV6eL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>