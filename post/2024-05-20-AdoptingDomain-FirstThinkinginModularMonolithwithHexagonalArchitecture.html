<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>도메인을 최우선으로 하는 생각을 Hexagonal Architecture를 활용한 모듈식 단일체에 도입하기 | ui-station</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///post/2024-05-20-AdoptingDomain-FirstThinkinginModularMonolithwithHexagonalArchitecture" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="도메인을 최우선으로 하는 생각을 Hexagonal Architecture를 활용한 모듈식 단일체에 도입하기 | ui-station" data-gatsby-head="true"/><meta property="og:title" content="도메인을 최우선으로 하는 생각을 Hexagonal Architecture를 활용한 모듈식 단일체에 도입하기 | ui-station" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-20-AdoptingDomain-FirstThinkinginModularMonolithwithHexagonalArchitecture_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///post/2024-05-20-AdoptingDomain-FirstThinkinginModularMonolithwithHexagonalArchitecture" data-gatsby-head="true"/><meta name="twitter:title" content="도메인을 최우선으로 하는 생각을 Hexagonal Architecture를 활용한 모듈식 단일체에 도입하기 | ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-20-AdoptingDomain-FirstThinkinginModularMonolithwithHexagonalArchitecture_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-20 15:36" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-70e5ce89f3d962ac.js" defer=""></script><script src="/_next/static/JlBEgQDLGRx6DYlBnT8eD/_buildManifest.js" defer=""></script><script src="/_next/static/JlBEgQDLGRx6DYlBnT8eD/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">도메인을 최우선으로 하는 생각을 Hexagonal Architecture를 활용한 모듈식 단일체에 도입하기</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="도메인을 최우선으로 하는 생각을 Hexagonal Architecture를 활용한 모듈식 단일체에 도입하기" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UI STATION</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 20, 2024</span><span class="posts_reading_time__f7YPP">21<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-20-AdoptingDomain-FirstThinkinginModularMonolithwithHexagonalArchitecture&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/assets/img/2024-05-20-AdoptingDomain-FirstThinkinginModularMonolithwithHexagonalArchitecture_0.png" alt="Image"></p>
<p>Part 1:</p>
<p>Part 2:</p>
<p>In the first blog, we explored the concept of Modular Monolith, what is a module and how DDD strategy patterns can be used to create modular applications.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>두 번째 블로그에서는 Spring Modulith가 모듈 모노리스 응용 프로그램에서 아키텍처 유효성 검사, 독립 모듈의 테스팅 및 이벤트 기반 통합을 어떻게 용이하게 하는지 살펴보았어요.</p>
<p>이 블로그에서는 단일 모듈을 자세히 살펴보고 헥사고날 아키텍처가 핵심 비즈니스 로직의 유지보수성 및 테스트를 어떻게 향상시키는지 이해할 거에요. 또한 헥사고날 아키텍처가 DDD 및 모듈 모노리스 응용 프로그램의 맥락 속에 어떻게 맞는지도 이해할 거에요.</p>
<p>헥사고날 아키텍처를 배우는 데 한 가지 어려움은 용어로 오인될 수 있다는 것이에요. 헥사곤 모양이나 숫자 여섯과는 아무런 상관이 없답니다. "포트"와 "어댑터"라는 용어가 과부하되어 있어서 여러분은 무엇을 의미하는지 배우기 전에 스스로의 해석을 잊어야 해요. 아키텍처의 층이 없다는 점(바깥쪽과 안쪽 이외에)과 의견이 분분하지 않은 아키텍처의 특성으로 인해 누구나 자신의 방식대로 구현할 수 있어요.</p>
<p>나는 헥사고날 아키텍처를 이해하고 Java와 Spring Boot 응용 프로그램에서 적용하는 방법에 대해 시도했을 때, 헥사고날을 사용하지 않고 응용 프로그램을 작성한 후 문제를 겪고 하나씩 해결하여 어떤 것이 헥사고날인지 알아냈어요. 하지만 그것은 몇 년이 걸릴 수 있어요! 이 블로그(시리즈)에서는 이 과정을 더 짧은 시간 안에 기록하고 싶어요.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>기업 문제를 해결하기 위한 애플리케이션을 개발하는 업무를 맡았습니다. 해당 애플리케이션은 웹을 통해 접속되며, 일부 비즈니스 로직을 구현하고 데이터를 데이터베이스에 저장할 것입니다 (당연히). 애플리케이션을 설계하는 과정에서 어떤 생각을 가지게 되시나요?</p>
<ul>
<li>웹 애플리케이션이어야 하므로, 최신하면서 반짝이는 자바스크립트 프레임워크(React?)를 사용하여 JSON을 제공하는 REST API 및 멋진 UI를 구축할 것입니다.</li>
<li>비즈니스 요구 사항이 NoSQL DB를 필요로 하지 않는 한 관계형 데이터베이스를 사용할 것입니다.</li>
<li>비즈니스 요구 사항을 바탕으로 여러 엔티티를 식별하고 ERD에 매핑할 것입니다.</li>
</ul>
<p>이런 내용이 익숙하시나요?</p>
<p>3번 항목에 집중해 봅시다. ERD 여부와 상관없이, 데이터 모델을 도출하기 위해 여러 엔티티를 식별하고 그것을 시간이 흘러도 발전시킬 수 있는 것은 모든 웹 백엔드 엔지니어가 해야 하는 일이며 시작점이 될 수도 있습니다! 저는 이를 여러 차례 경험해 보았습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이 방법은 (의식적인 아키텍처가 적용되지 않을 때 기본으로 사용되는) 계층화된/N계층 아키텍처로 구성된 애플리케이션을 만들게 됩니다. 데이터 모델은 JPA 엔티티로 구성되며, Repositories를 통해 영속화되고, 비즈니스 로직은 Services에 구현됩니다.</p>
<p>이러한 구현의 핵심 특성 중 하나는 비즈니스 로직(Services)이 데이터 모델에서 작동하며 데이터베이스에 의존하는 것입니다. 특히 JPA/JDBC가 실제 데이터베이스 기술을 추상화하고 있기 때문에 바로 알아차리기 어렵습니다. 하지만 데이터베이스 구현(테이블 구조, 외래 키 관계, 인덱스 등)이 비즈니스 로직 구현을 주도하는 것이 아니라 그 반대로 작용하고 있습니다. 아래 그림에서 보듯이, 애플리케이션 서비스는 Spring과 JPA/Hibernate와 같은 기술과 강하게 결합됩니다.</p>
<p><img src="/assets/img/2024-05-20-AdoptingDomain-FirstThinkinginModularMonolithwithHexagonalArchitecture_1.png" alt="이미지"></p>
<h2>의존성 역전</h2>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>자, 이제 우리는 다르게 생각하고 문제에 접근해 보겠습니다. 데이터 모델에 초점을 맞추는 대신, 비즈니스 로직과 제약 조건을 포착하는 여러 클래스를 만들어 보겠습니다. 이를 도메인 모델이라고 부르겠습니다.</p>
<p>이 접근 방식에서는, 서비스가 스프링 데이터 리포지토리를 직접 사용하는 대신, 의존성을 반전시키기 위해 인터페이스를 도입하여 서비스가 필요로 하는 동작을 정의하고 이것이 어떻게 구현되었는지 신경쓰지 않습니다. 실은 스프링 데이터 리포지토리는 Java 인터페이스로 정의되어 있지만, 다이내믹 프록시를 통해 구현을 결합하는 인터페이스는 아닙니다.</p>
<p>의존성을 반전시키기 위해 사용된 인터페이스를 포트(port)로, 인터페이스의 구현은 어댑터(adapter)로 부릅니다. 이들은 도메인 모델에 의해 주도(들어온)되므로 주도 또는 보조(secondary)로 알려져 있습니다. 이는 헥사고날 아키텍처에서 사용되는 용어입니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>한편, 유스 케이스를 구현하는 데 사용되는 Application 서비스도 포트입니다. 차이점은 Java 인터페이스가 아니라 일반 클래스임을 의미합니다. 또한 해당 어댑터와 함께 사용됩니다. 이 어댑터는 기술을 접근하여 우리의 사용 사례에 연결합니다(REST API, GraphQL, 람다 등). 이러한 포트와 어댑터는 도메인 모델을 사용하므로 드라이버 또는 주요 요소로 알려져 있습니다. 이들은 우리 모델의 사용을 이끌어냅니다.</p>
<p><img src="/assets/img/2024-05-20-AdoptingDomain-FirstThinkinginModularMonolithwithHexagonalArchitecture_3.png" alt="그림 안내"></p>
<p>기본 및 보조 포트와 어댑터를 결합하면 헥사고날(또는 포트 및 어댑터) 아키텍처로 이어집니다.</p>
<p>새로운 접근 방법을 적용하는 데 도움이 되도록 몇 가지 제약 조건을 소개해 보겠습니다. 우리는 프레임워크/구현이 우리의 생각을 이끌도록 허용하지 않겠습니다. 이는 데이터베이스 라이브러리 (JPA/JDBC), 이벤트 프레임워크 (Apache Kafka) 및 애플리케이션 프레임워크 (Spring)를 배제한다는 것을 의미합니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>남은 것은 순수한 자바 (또는 응용 프로그램을 개발하는 언어)와 해당 비즈니스 로직 구현의 단위 테스트입니다.</p>
<p>잠시 후에 기존 응용 프로그램을 위의 과정을 따르도록 리팩터링할 것입니다. 하지만, 이것을 왜 신경 써야 할까요? 어떤 이점이 있을까요?</p>
<h2>핵심 비즈니스 로직은 구현 세부 정보에서 자유롭습니다</h2>
<p>비즈니스 로직을 반영하는 도메인 모델(도메인 또는 내부라고 부르겠습니다)은 구현 세부 정보(인프라스트럭처 또는 외부라고 부르겠습니다)에 영향을 받지 않습니다. 새로운 기능 요청을 구축해야 하나요? 도메인 모델에서 구현하고 단위 테스트로 유효성을 검사하세요. Spring Boot나 Hibernate를 업데이트해야 하나요? 걱정 마세요, 도메인 모델은 영향을 받지 않습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>도메인 모델이 구현을 주도합니다</h2>
<p>도메인 모델은 아키텍처의 핵심에 있습니다. 다른 모든 것은 도메인 모델에서 출발합니다. 비즈니스 로직의 구현을 주도합니다. 이전에 구현을 주도했던 데이터 모델은 이제 영속성에만 관련된 사소한 세부사항입니다. REST API가 필요하다면, 스케줄러가 필요하다면 밤에 실행되는 확인 작업을 주도해야 한다면, AWS 람다를 트리거해야 한다면 — 이 모든 것은 도메인 모델과는 상관이 없습니다.</p>
<h2>지연된 결정</h2>
<p>어떤 사용 사례에 관계형 데이터베이스를 사용해야 할지 아직 확실하지 않나요? 아키텍트가 REST 대 GraphQL 사용에 대한 궁금증에 대답하지 않았나요? 그런 결정들이 비즈니스 로직의 구현을 막아선 안됩니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>좋아요, 이제 새로운 사고 방식으로 비즈니스 로직을 작성하여 도서관 사용 사례를 구현하는 방법을 살펴볼까요?</p>
<h2>대여 Bounded Context (헥사고날 아키텍처로 구현)</h2>
<p>아래의 패키지 구조로 대여 모듈을 구성할 것입니다. 응용 프로그램 및 도메인 패키지는 헥사곤의 "내부"를 나타내고 인프라스트럭처 패키지는 "외부"를 나타냅니다.</p>
<pre><code class="hljs language-js">src/main/java
└── example
    ├── borrow
    │   ├── application
    │   │   └── ...
    │   ├── domain
    │   │   └── ...
    │   └── infrastructure
    │       └── ...
    └── <span class="hljs-title class_">LibraryApplication</span>
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>아래 규칙을 패키지에 대해 따를 것입니다 (모두에게 해당되는 보편적인 규칙이 아니고, 우리가 직접 정한 것입니다). 이 구현의 복잡성과 아키텍처 원칙을 엄격하게 준수하는 현실적인 접근 사이의 적절한 균형을 유지하고 있다고 생각합니다.</p>
<ul>
<li>도메인 패키지에는 도메인 모델(Aggregates, Entities, Value Objects) 및 인프라스트럭처가 구현할 인터페이스를 제공하는 Secondary / Driven 포트가 포함됩니다. 우리는 표준 자바, Lombok(많은 코드를 줄이기 위한) 및 JMolecules(스테레오타입을 문서화하기 위해) 라이브러리만 사용할 것입니다.</li>
<li>애플리케이션 패키지에는 애플리케이션의 유스케이스를 구현하는 Primary / Driver 포트가 포함됩니다. 우리는 Spring의 @Transactional 및 Modulith의 @ApplicationModuleListener 주석을 사용할 수 있습니다.</li>
<li>인프라스트럭처 패키지에는 REST API 및 JPA 어댑터를 빌드하는 코드가 포함됩니다. 이것은 야생 서부입니다. 제한 사항이 없으며, 모든 라이브러리를 자유롭게 사용할 수 있습니다.</li>
</ul>
<p>책을 대출하는 사용 사례를 살펴보겠습니다. 사용자는 이용 가능한 책에 예약을 할 수 있습니다. 아래는 사용 사례를 구현하는 주요 포트의 Java 예시입니다. @PrimaryPort 주석이 어디서 온 것인지 궁금하다면 계속 읽어보세요!</p>
<pre><code class="hljs language-java"><span class="hljs-meta">@PrimaryPort</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CirculationDesk</span> {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BookRepository books;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> HoldRepository holds;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> HoldEventPublisher eventPublisher;

    <span class="hljs-meta">@Transactional</span>
    <span class="hljs-keyword">public</span> HoldDto <span class="hljs-title function_">placeHold</span><span class="hljs-params">(PlaceHold command)</span> {
        books.findAvailableBook(command.inventoryNumber())
                .orElseThrow(() -> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">"Book not found"</span>));

        <span class="hljs-keyword">return</span> Hold.placeHold(command)
                .then(holds::save)
                .then(eventPublisher::holdPlaced)
                .to(HoldDto::from);
    }

    <span class="hljs-keyword">record</span> <span class="hljs-title class_">PlaceHold</span><span class="hljs-params">(Barcode inventoryNumber,
                     String patronId,
                     LocalDate dateOfHold)</span> {
    }
}
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>의존성을 역전시키기 위해, 모든 집합체를 위한 Repository 인터페이스를 도입했습니다 (Spring Data와는 혼동하지 마세요).</p>
<pre><code class="hljs language-js">@<span class="hljs-title class_">SecondaryPort</span>
인터페이스 <span class="hljs-title class_">BookRepository</span> {

    <span class="hljs-title class_">Optional</span>&#x3C;<span class="hljs-title class_">Book</span>> <span class="hljs-title function_">findAvailableBook</span>(<span class="hljs-title class_">Book</span>.<span class="hljs-property">Barcode</span> inventoryNumber);

    <span class="hljs-title class_">Optional</span>&#x3C;<span class="hljs-title class_">Book</span>> <span class="hljs-title function_">findOnHoldBook</span>(<span class="hljs-title class_">Book</span>.<span class="hljs-property">Barcode</span> inventoryNumber);

    <span class="hljs-title class_">Book</span> <span class="hljs-title function_">save</span>(<span class="hljs-title class_">Book</span> book);

    <span class="hljs-title class_">Optional</span>&#x3C;<span class="hljs-title class_">Book</span>> <span class="hljs-title function_">findByBarcode</span>(<span class="hljs-title class_">String</span> barcode);
}

@<span class="hljs-title class_">SecondaryPort</span>
인터페이스 <span class="hljs-title class_">HoldRepository</span> {

    <span class="hljs-title class_">Hold</span> <span class="hljs-title function_">save</span>(<span class="hljs-title class_">Hold</span> hold);

    <span class="hljs-title class_">Optional</span>&#x3C;<span class="hljs-title class_">Hold</span>> <span class="hljs-title function_">findById</span>(<span class="hljs-title class_">Hold</span>.<span class="hljs-property">HoldId</span> id);

    <span class="hljs-title class_">List</span>&#x3C;<span class="hljs-title class_">Hold</span>> <span class="hljs-title function_">activeHolds</span>();
}
</code></pre>
<p>CirculationDesk 응용 프로그램 서비스는 위의 리포지터리 인터페이스를 사용합니다. 이를 통해 구현 기술(Spring Data, JPA, JDBC 등)과 독립시켰습니다.</p>
<h2>집합체로부터 도메인 이벤트 트리거하기</h2>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>하나의 사용 사례 결과는 Aggregate의 업데이트된 상태를 지속시키는 것입니다. 또 다른 결과는 도메인 이벤트를 발생시켜 모노리스의 다른 모듈 (또는 동일 모듈 내의 다른 Aggregate)에서 대응할 수 있도록 하는 것일 수 있습니다.</p>
<p>Aggregate를 지속시키는 것 (Repository 사용)과 이벤트를 발생시키는 것 (Event Publisher 사용)은 헥사고날 아키텍처에서 이차/드라이븐 포트입니다. 구현은 비즈니스 로직과 관련이 없습니다.</p>
<p>사용 사례 실행 후에는 BookPlacedOnHold 이벤트가 발생합니다. 이 이벤트는 Book Aggregate에서 도서 상태를 데이터베이스에서 업데이트하기 위해 사용됩니다. 이벤트 처리는 비즈니스 로직의 중요한 부분이므로 주/드라이버 포트의 책임입니다.</p>
<pre><code class="hljs language-java"><span class="hljs-comment">// 실제로 이벤트가 발행되는 방법에 대한 구현에 대한 이해가 없는</span>
<span class="hljs-comment">// 이벤트 퍼블리셔 인터페이스</span>
<span class="hljs-meta">@SecondaryPort</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">HoldEventPublisher</span> {

    <span class="hljs-keyword">void</span> <span class="hljs-title function_">holdPlaced</span><span class="hljs-params">(BookPlacedOnHold event)</span>;

    <span class="hljs-keyword">default</span> Hold <span class="hljs-title function_">holdPlaced</span><span class="hljs-params">(Hold hold)</span> {
        <span class="hljs-type">BookPlacedOnHold</span> <span class="hljs-variable">event</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BookPlacedOnHold</span>(hold.getId().id(), hold.getOnBook().barcode(), hold.getDateOfHold());
        <span class="hljs-built_in">this</span>.holdPlaced(event);
        <span class="hljs-keyword">return</span> hold;
    }
}

<span class="hljs-comment">// 이벤트 핸들러는 Spring Modulith 리스너를 사용하여</span>
<span class="hljs-comment">// 이벤트에 신뢰성있게 대응합니다.</span>
<span class="hljs-meta">@PrimaryPort</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">CirculationDeskEventHandler</span> {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BookRepository books;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> HoldEventPublisher eventPublisher;

    <span class="hljs-meta">@ApplicationModuleListener</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">(BookPlacedOnHold event)</span> {
        books.findAvailableBook(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>.Barcode(event.inventoryNumber()))
                .map(Book::markOnHold)
                .map(books::save)
                .orElseThrow(() -> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">"중복 예약?"</span>));
    }
}
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>육각형 구조의 "내부" (비즈니스 로직) 단위 테스트</h2>
<p><img src="/assets/img/2024-05-20-AdoptingDomain-FirstThinkinginModularMonolithwithHexagonalArchitecture_4.png" alt="이미지"></p>
<p>프레임워크 종속성 없이 비즈니스 로직을 구현하는 큰 장점은 통합 테스트가 필요하지 않고 코드를 단위 테스트할 수 있다는 것입니다. Repository 포트의 인메모리 구현을 사용하여 placeHold 유스케이스를 유효성 검사하는 단위 테스트의 예시가 여기 있습니다(CirculationDeskTest.java 참조).</p>
<pre><code class="hljs language-java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CirculationDeskTest</span> {

    CirculationDesk circulationDesk; <span class="hljs-comment">// 애플리케이션 서비스</span>

    BookRepository bookRepository; <span class="hljs-comment">// 보조 포트</span>

    HoldRepository holdRepository; <span class="hljs-comment">// 보조 포트</span>

    <span class="hljs-meta">@BeforeEach</span>
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUp</span><span class="hljs-params">()</span> {
        bookRepository = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InMemoryBooks</span>();
        holdRepository = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InMemoryHolds</span>();
        circulationDesk = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CirculationDesk</span>(bookRepository, holdRepository, <span class="hljs-keyword">new</span> <span class="hljs-title class_">InMemoryHoldsEventPublisher</span>());
    }

    <span class="hljs-meta">@Test</span>
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">patronCanPlaceHold</span><span class="hljs-params">()</span> {
        <span class="hljs-type">var</span> <span class="hljs-variable">command</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hold</span>.PlaceHold(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>.Barcode(<span class="hljs-string">"12345"</span>), LocalDate.now());
        <span class="hljs-type">var</span> <span class="hljs-variable">holdDto</span> <span class="hljs-operator">=</span> circulationDesk.placeHold(command);
        assertThat(holdDto.getBookBarcode()).isEqualTo(<span class="hljs-string">"12345"</span>);
        assertThat(holdDto.getDateOfHold()).isNotNull();
    }

    <span class="hljs-meta">@Test</span>
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">bookStatusUpdatedWhenPlacedOnHold</span><span class="hljs-params">()</span> {
        <span class="hljs-type">var</span> <span class="hljs-variable">command</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hold</span>.PlaceHold(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>.Barcode(<span class="hljs-string">"12345"</span>), LocalDate.now());
        <span class="hljs-type">var</span> <span class="hljs-variable">hold</span> <span class="hljs-operator">=</span> Hold.placeHold(command);
        circulationDesk.handle(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BookPlacedOnHold</span>(hold.getId().id(), hold.getOnBook().barcode(), hold.getDateOfHold()));
        <span class="hljs-comment">//noinspection OptionalGetWithoutIsPresent</span>
        <span class="hljs-type">var</span> <span class="hljs-variable">book</span> <span class="hljs-operator">=</span> bookRepository.findByBarcode(<span class="hljs-string">"12345"</span>).get();
        assertThat(book.getStatus()).isEqualTo(ON_HOLD);
    }
}

<span class="hljs-comment">// 테스트 픽처 (보조 포트를 구현하는 보조 어댑터 역할)</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">InMemoryBooks</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BookRepository</span> {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&#x3C;String, Book> books = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&#x3C;>();

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">InMemoryBooks</span><span class="hljs-params">()</span> {
        <span class="hljs-type">var</span> <span class="hljs-variable">booksToAdd</span> <span class="hljs-operator">=</span> List.of(
                Book.addBook(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>.AddBook(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>.Barcode(<span class="hljs-string">"12345"</span>), <span class="hljs-string">"A famous book"</span>, <span class="hljs-string">"92972947199"</span>)),
                Book.addBook(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>.AddBook(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>.Barcode(<span class="hljs-string">"98765"</span>), <span class="hljs-string">"Another famous book"</span>, <span class="hljs-string">"98137674132"</span>))
        );
        booksToAdd.forEach(book -> books.put(book.getInventoryNumber().barcode(), book));
    }

    ...
}

<span class="hljs-comment">// 테스트 픽처 (보조 포트를 구현하는 보조 어댑터 역할)</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">InMemoryHolds</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HoldRepository</span> {
  <span class="hljs-comment">// InMemoryBooks와 유사한 구현</span>
  ...
}
</code></pre>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>도메인 모델이 집계를 지속하거나 이벤트를 트리거하기 위해 인터페이스에 의존하고 있는 점을 감안할 때, 유닛 테스트는 이 인터페이스 메서드를 실행할 수 있도록 테스트 픽스처가 필요합니다. 유당 테스트가 작동하려면 모든 보조/드라이븐 포트에 대한 구현이 필요합니다.</p>
<p>전체 코드는 아래 GitHub 저장소에서 확인할 수 있습니다.</p>
<h2>아키텍처 규칙 테스트하기</h2>
<p>Spring Modulith 및 jMolecules 라이브러리는 ArchUnit과 함께 사용되어 우리의 솔루션에서 적용된 아키텍처와 Modular Monolith 애플리케이션의 모듈 간 상호 작용을 테스트할 수 있게 합니다. 이는 새로운 개발자들이 작업을 시작함에 따라 우리의 애플리케이션이 선택한 아키텍처에서 벗어나지 않도록 하는 데 중요합니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>저희 모듈형 모놀리스 응용 프로그램에는 이제 Catalog 및 Borrow 두 개의 모듈이 있습니다. Catalog 모듈은 Layered/N-tier 아키텍처를 사용하고 Borrow 모듈은 Hexagonal 아키텍처를 사용하고 있어요. 다음과 같이 테스트할 수 있어요 (BorrowJMoleculesTests 및 CatalogJMoleculesTests 참고).</p>
<pre><code class="hljs language-js">@<span class="hljs-title class_">AnalyzeClasses</span>(packages = <span class="hljs-string">"example.catalog"</span>)
public <span class="hljs-keyword">class</span> <span class="hljs-title class_">CatalogJMoleculesTests</span> {

    @<span class="hljs-title class_">ArchTest</span>
    <span class="hljs-title class_">ArchRule</span> dddRules = <span class="hljs-title class_">JMoleculesDddRules</span>.<span class="hljs-title function_">all</span>();

    @<span class="hljs-title class_">ArchTest</span>
    <span class="hljs-title class_">ArchRule</span> layering = <span class="hljs-title class_">JMoleculesArchitectureRules</span>.<span class="hljs-title function_">ensureLayering</span>();
}

@<span class="hljs-title class_">AnalyzeClasses</span>(packages = <span class="hljs-string">"example.borrow"</span>)
public <span class="hljs-keyword">class</span> <span class="hljs-title class_">BorrowJMoleculesTests</span> {

    @<span class="hljs-title class_">ArchTest</span>
    <span class="hljs-title class_">ArchRule</span> dddRules = <span class="hljs-title class_">JMoleculesDddRules</span>.<span class="hljs-title function_">all</span>();

    @<span class="hljs-title class_">ArchTest</span>
    <span class="hljs-title class_">ArchRule</span> hexagonal = <span class="hljs-title class_">JMoleculesArchitectureRules</span>.<span class="hljs-title function_">ensureHexagonal</span>();
}
</code></pre>
<p>@AnalyzeClasses 주석을 사용하여 테스트할 모듈을 선택할 수 있어요.</p>
<h2>Hexagonal 아키텍처의 "외부"를 통합 테스트하기</h2>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>기술이 도메인 모델과 상호 작용하는 외부 부분은 동작을 확인하기 위해 통합 테스트로 테스트해야 합니다. 여기에 예제가 있습니다 (영속성인 CirculationDeskIT.java 및 REST인 CirculationDeskControllerIT.java):</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// from CirculationDeskIT</span>
@<span class="hljs-title class_">Test</span>
<span class="hljs-keyword">void</span> <span class="hljs-title function_">patronCanPlaceHold</span>(<span class="hljs-params">Scenario scenario</span>) {
    <span class="hljs-keyword">var</span> command = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hold</span>.<span class="hljs-title class_">PlaceHold</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>.<span class="hljs-title class_">Barcode</span>(<span class="hljs-string">"13268510"</span>), <span class="hljs-title class_">LocalDate</span>.<span class="hljs-title function_">now</span>());
    scenario.<span class="hljs-title function_">stimulate</span>(() -> circulationDesk.<span class="hljs-title function_">placeHold</span>(command))
            .<span class="hljs-title function_">andWaitForEventOfType</span>(<span class="hljs-title class_">BookPlacedOnHold</span>.<span class="hljs-property">class</span>)
            .<span class="hljs-title function_">toArriveAndVerify</span>((event, dto) -> {
                <span class="hljs-title function_">assertThat</span>(event.<span class="hljs-title function_">inventoryNumber</span>()).<span class="hljs-title function_">isEqualTo</span>(<span class="hljs-string">"13268510"</span>);
            });
}

<span class="hljs-comment">// from CirculationDeskControllerIT</span>
@<span class="hljs-title class_">Test</span>
<span class="hljs-keyword">void</span> <span class="hljs-title function_">placeHoldRestCall</span>() throws <span class="hljs-title class_">Exception</span> {
    mockMvc.<span class="hljs-title function_">perform</span>(<span class="hljs-title function_">post</span>(<span class="hljs-string">"/borrow/holds"</span>)
                    .<span class="hljs-title function_">contentType</span>(<span class="hljs-title class_">MediaType</span>.<span class="hljs-property">APPLICATION_JSON</span>)
                    .<span class="hljs-title function_">content</span>(<span class="hljs-string">""</span><span class="hljs-string">"
                            {
                              "</span>barcode<span class="hljs-string">": "</span><span class="hljs-number">64321704</span><span class="hljs-string">",
                              "</span>patronId<span class="hljs-string">": 5
                            }
                            "</span><span class="hljs-string">""</span>))
            .<span class="hljs-title function_">andExpect</span>(<span class="hljs-title function_">status</span>().<span class="hljs-title function_">isOk</span>());
}
</code></pre>
<h2>jMolecules로 클래스 스테레오타입 시각화</h2>
<p>이전 블로그 시리즈에서 언급했듯이 jMolecules Intellij 플러그인을 사용하여 다양한 스테레오타입을 시각화할 수 있습니다. 그러나 jMolecules 라이브러리가 헥사고날 아키텍처에 대한 주석을 지원하더라도 플러그인은 해당 주석을 지원하지 않습니다. 저는 관련 주석을 추가하여 플러그인을 수정했습니다. 플러그인을 활성화하고 관련 주석을 추가한 후 대여 모듈 내부 클래스가 어떻게 보이는지 확인하세요.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p><img src="/assets/img/2024-05-20-AdoptingDomain-FirstThinkinginModularMonolithwithHexagonalArchitecture_5.png" alt=""></p>
<p>주요 포트 및 어댑터 클래스를 쉽게 식별할 수 있습니다.</p>
<h2>헥사고날 아키텍처에 헌신해야 할까요?</h2>
<p>모듈형 단일체 애플리케이션을 구축할 때, 모든 모듈에 대해 헥사고날 아키텍처를 사용해야 할지에 대해 고려해야 합니다. 만약 모듈이 자체 비즈니스 규칙을 갖고 있거나 (또는 나중에 갖게 될 것으로 예상된다면), 헥사고날 아키텍처가 좋은 아이디어일 수 있습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>하지만 해결책에 더 많은 클래스와 장황성을 추가합니다. Layered 아키텍처에는 보조 포트와 어댑터가 없습니다. Spring Data 리포지토리 인터페이스는 Service 클래스에 직접 의존성을 추가하는 대가로 보조 포트와 어댑터의 역할을 취합니다.</p>
<p>결국, 헥사고날 아키텍처를 채택하는 이점이 비용을 크게 상회합니다. 최소한 코드베이스에서 불필요한 결합을 줄이기 위해 의존성 역전의 원칙을 적용할 수 있는지 항상 확인해야 합니다.</p>
<h2>헥사고날 아키텍처를 구현하는 데 DDD가 필요한가요?</h2>
<p>아니요. 도메인 주도 설계(DDD)는 도메인이 모델링되는 방식에만 관련이 있습니다. 아키텍처와는 관련이 없습니다(헥사고날이든 그 외). DDD를 사용해야 하는가요? 클래스와 필드를 명명할 때 항상 모든 지식의 언어를 사용하는 것을 추천합니다. 도메인 전문가가 사용하는 용어와 동일한 용어를 사용하는 코드는 항상 이해하기 쉽습니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>DDD의 Aggregate 및 기타 전략적 패턴을 사용하는 것은 애플리케이션의 필요성과 복잡성에 따라 다릅니다. 정당화되지 않은 경우에는 트랜잭션 스크립트나 액티브 레코드를 대신 사용할 수 있습니다.</p>
<h2>헥사고날 아키텍처의 순수 구현 회피</h2>
<p>헥사곤의 내부는 핵심 비즈니스 로직의 구현이며, 헥사곤 외부에서 사용된 프레임워크와 기술로부터 자유롭게 유지해야 합니다. 몇몇 구현이 이 규칙을 신앙적으로 따라 코드를 복잡하게 만드는 것을 본 적이 있습니다.</p>
<p>예를 들어, 애플리케이션 서비스 코드는 트랜잭션 내에서 실행되어야 합니다. Spring의 @Transactional을 사용하면 쉽게 달성할 수 있습니다. 그러나 이를 피하려면 애플리케이션 서비스를 Spring으로부터 자유롭게 유지하기 위해 사용자 정의 어노테이션과 AOP를 도입해야 합니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>헥사곤 안의 내부는 Application과 Domain으로 구성되어 있습니다. 도메인은 이상적으로는 프레임워크 없이 유지되어야 하지만, Application은 Spring을 사용할 수 있습니다. 이 질문을 Vaughn Vernon에게 던졌고, 그는 좋은 설명을 제공했습니다.</p>
<p><img src="/assets/img/2024-05-20-AdoptingDomain-FirstThinkinginModularMonolithwithHexagonalArchitecture_6.png" alt="이미지"></p>
<h2>도메인 모델로부터 만들어진 분리된 JPA 엔티티를 병합하기</h2>
<p>아래 코드 스니펫을 확인하여 Hold를 배치하세요.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js">public <span class="hljs-title class_">HoldDto</span> <span class="hljs-title function_">placeHold</span>(<span class="hljs-params">Hold.PlaceHold command</span>) {
    ...

    <span class="hljs-title class_">Hold</span>.<span class="hljs-title function_">placeHold</span>(command) <span class="hljs-comment">// Hold 도메인 모델 객체 생성</span>
            .<span class="hljs-title function_">then</span>(<span class="hljs-attr">holds</span>::save) <span class="hljs-comment">// JPA 엔티티로 변환하여 데이터베이스에 저장</span>
            .<span class="hljs-title function_">then</span>(<span class="hljs-attr">eventPublisher</span>::holdPlaced) <span class="hljs-comment">// HoldPlaced 이벤트를 트리거</span>

    ...
  );
}
</code></pre>
<p>holds::save는 Secondary 포트 인터페이스에서의 호출로, Secondary 어댑터 구현을 트리거합니다:</p>
<pre><code class="hljs language-js">public <span class="hljs-title class_">Hold</span> <span class="hljs-title function_">save</span>(<span class="hljs-params">Hold hold</span>) {
    holds.<span class="hljs-title function_">save</span>(<span class="hljs-title class_">HoldEntity</span>.<span class="hljs-title function_">fromDomain</span>(hold));
    <span class="hljs-keyword">return</span> hold;
}

<span class="hljs-comment">// HoldEntity 클래스에서</span>
public <span class="hljs-keyword">static</span> <span class="hljs-title class_">HoldEntity</span> <span class="hljs-title function_">fromDomain</span>(<span class="hljs-params">Hold hold</span>) {
    <span class="hljs-keyword">var</span> entity = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HoldEntity</span>();
    entity.<span class="hljs-property">id</span> = hold.<span class="hljs-title function_">getId</span>().<span class="hljs-title function_">id</span>(); <span class="hljs-comment">// 도메인 모델 식별자와 JPA 엔티티 PK가 동일합니다!</span>
    entity.<span class="hljs-property">book</span> = hold.<span class="hljs-title function_">getOnBook</span>();
    entity.<span class="hljs-property">dateOfHold</span> = hold.<span class="hljs-title function_">getDateOfHold</span>();
    entity.<span class="hljs-property">status</span> = <span class="hljs-title class_">HoldStatus</span>.<span class="hljs-property">HOLDING</span>;
    entity.<span class="hljs-property">version</span> = 0L;
    <span class="hljs-keyword">return</span> entity;
}
</code></pre>
<p>Hold 도메인 모델은 영속화되기 전에 분리된 HoldEntity JPA 엔티티로 변환되어야 합니다. 엔티티 생성에는 기본 키 ID를 알아야 합니다. 도메인 모델이 PK를 따로 저장하거나 모델 식별자로 사용해야 합니다. 저의 예시에서는 후자를 선택했지만, 이 문제를 어떻게 해결할지 궁금합니다.</p>
<!-- ui-station 사각형 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="7249294152" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>결론</h2>
<p>이 블로그에서는 계층 구조 대신 헥사고날 아키텍처를 사용하여 대출 모듈을 다시 구현했습니다. 이 과정에서 동일한 단일 코드 베이스의 일부임에도 불구하고 카탈로그 모듈에는 절대적으로 변경이 필요하지 않았음을 보여주었습니다. 이는 이벤트 기반 통합 덕분에 느슨한 결합이 활성화되었음을 확인했습니다.</p>
<p>헥사고날에 대한 여러분의 경험은 어떠한가요? 댓글에서 공유해 주시면 감사하겠습니다.</p>
<p>아래에서 업데이트된 코드를 확인할 수 있습니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"도메인을 최우선으로 하는 생각을 Hexagonal Architecture를 활용한 모듈식 단일체에 도입하기","description":"","date":"2024-05-20 15:36","slug":"2024-05-20-AdoptingDomain-FirstThinkinginModularMonolithwithHexagonalArchitecture","content":"\n![Image](/assets/img/2024-05-20-AdoptingDomain-FirstThinkinginModularMonolithwithHexagonalArchitecture_0.png)\n\nPart 1:\n\nPart 2:\n\nIn the first blog, we explored the concept of Modular Monolith, what is a module and how DDD strategy patterns can be used to create modular applications.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n두 번째 블로그에서는 Spring Modulith가 모듈 모노리스 응용 프로그램에서 아키텍처 유효성 검사, 독립 모듈의 테스팅 및 이벤트 기반 통합을 어떻게 용이하게 하는지 살펴보았어요.\n\n이 블로그에서는 단일 모듈을 자세히 살펴보고 헥사고날 아키텍처가 핵심 비즈니스 로직의 유지보수성 및 테스트를 어떻게 향상시키는지 이해할 거에요. 또한 헥사고날 아키텍처가 DDD 및 모듈 모노리스 응용 프로그램의 맥락 속에 어떻게 맞는지도 이해할 거에요.\n\n헥사고날 아키텍처를 배우는 데 한 가지 어려움은 용어로 오인될 수 있다는 것이에요. 헥사곤 모양이나 숫자 여섯과는 아무런 상관이 없답니다. \"포트\"와 \"어댑터\"라는 용어가 과부하되어 있어서 여러분은 무엇을 의미하는지 배우기 전에 스스로의 해석을 잊어야 해요. 아키텍처의 층이 없다는 점(바깥쪽과 안쪽 이외에)과 의견이 분분하지 않은 아키텍처의 특성으로 인해 누구나 자신의 방식대로 구현할 수 있어요.\n\n나는 헥사고날 아키텍처를 이해하고 Java와 Spring Boot 응용 프로그램에서 적용하는 방법에 대해 시도했을 때, 헥사고날을 사용하지 않고 응용 프로그램을 작성한 후 문제를 겪고 하나씩 해결하여 어떤 것이 헥사고날인지 알아냈어요. 하지만 그것은 몇 년이 걸릴 수 있어요! 이 블로그(시리즈)에서는 이 과정을 더 짧은 시간 안에 기록하고 싶어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n기업 문제를 해결하기 위한 애플리케이션을 개발하는 업무를 맡았습니다. 해당 애플리케이션은 웹을 통해 접속되며, 일부 비즈니스 로직을 구현하고 데이터를 데이터베이스에 저장할 것입니다 (당연히). 애플리케이션을 설계하는 과정에서 어떤 생각을 가지게 되시나요?\n\n- 웹 애플리케이션이어야 하므로, 최신하면서 반짝이는 자바스크립트 프레임워크(React?)를 사용하여 JSON을 제공하는 REST API 및 멋진 UI를 구축할 것입니다.\n- 비즈니스 요구 사항이 NoSQL DB를 필요로 하지 않는 한 관계형 데이터베이스를 사용할 것입니다.\n- 비즈니스 요구 사항을 바탕으로 여러 엔티티를 식별하고 ERD에 매핑할 것입니다.\n\n이런 내용이 익숙하시나요?\n\n3번 항목에 집중해 봅시다. ERD 여부와 상관없이, 데이터 모델을 도출하기 위해 여러 엔티티를 식별하고 그것을 시간이 흘러도 발전시킬 수 있는 것은 모든 웹 백엔드 엔지니어가 해야 하는 일이며 시작점이 될 수도 있습니다! 저는 이를 여러 차례 경험해 보았습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 방법은 (의식적인 아키텍처가 적용되지 않을 때 기본으로 사용되는) 계층화된/N계층 아키텍처로 구성된 애플리케이션을 만들게 됩니다. 데이터 모델은 JPA 엔티티로 구성되며, Repositories를 통해 영속화되고, 비즈니스 로직은 Services에 구현됩니다.\n\n이러한 구현의 핵심 특성 중 하나는 비즈니스 로직(Services)이 데이터 모델에서 작동하며 데이터베이스에 의존하는 것입니다. 특히 JPA/JDBC가 실제 데이터베이스 기술을 추상화하고 있기 때문에 바로 알아차리기 어렵습니다. 하지만 데이터베이스 구현(테이블 구조, 외래 키 관계, 인덱스 등)이 비즈니스 로직 구현을 주도하는 것이 아니라 그 반대로 작용하고 있습니다. 아래 그림에서 보듯이, 애플리케이션 서비스는 Spring과 JPA/Hibernate와 같은 기술과 강하게 결합됩니다.\n\n![이미지](/assets/img/2024-05-20-AdoptingDomain-FirstThinkinginModularMonolithwithHexagonalArchitecture_1.png)\n\n## 의존성 역전\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n자, 이제 우리는 다르게 생각하고 문제에 접근해 보겠습니다. 데이터 모델에 초점을 맞추는 대신, 비즈니스 로직과 제약 조건을 포착하는 여러 클래스를 만들어 보겠습니다. 이를 도메인 모델이라고 부르겠습니다.\n\n이 접근 방식에서는, 서비스가 스프링 데이터 리포지토리를 직접 사용하는 대신, 의존성을 반전시키기 위해 인터페이스를 도입하여 서비스가 필요로 하는 동작을 정의하고 이것이 어떻게 구현되었는지 신경쓰지 않습니다. 실은 스프링 데이터 리포지토리는 Java 인터페이스로 정의되어 있지만, 다이내믹 프록시를 통해 구현을 결합하는 인터페이스는 아닙니다.\n\n의존성을 반전시키기 위해 사용된 인터페이스를 포트(port)로, 인터페이스의 구현은 어댑터(adapter)로 부릅니다. 이들은 도메인 모델에 의해 주도(들어온)되므로 주도 또는 보조(secondary)로 알려져 있습니다. 이는 헥사고날 아키텍처에서 사용되는 용어입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n한편, 유스 케이스를 구현하는 데 사용되는 Application 서비스도 포트입니다. 차이점은 Java 인터페이스가 아니라 일반 클래스임을 의미합니다. 또한 해당 어댑터와 함께 사용됩니다. 이 어댑터는 기술을 접근하여 우리의 사용 사례에 연결합니다(REST API, GraphQL, 람다 등). 이러한 포트와 어댑터는 도메인 모델을 사용하므로 드라이버 또는 주요 요소로 알려져 있습니다. 이들은 우리 모델의 사용을 이끌어냅니다.\n\n![그림 안내](/assets/img/2024-05-20-AdoptingDomain-FirstThinkinginModularMonolithwithHexagonalArchitecture_3.png)\n\n기본 및 보조 포트와 어댑터를 결합하면 헥사고날(또는 포트 및 어댑터) 아키텍처로 이어집니다.\n\n새로운 접근 방법을 적용하는 데 도움이 되도록 몇 가지 제약 조건을 소개해 보겠습니다. 우리는 프레임워크/구현이 우리의 생각을 이끌도록 허용하지 않겠습니다. 이는 데이터베이스 라이브러리 (JPA/JDBC), 이벤트 프레임워크 (Apache Kafka) 및 애플리케이션 프레임워크 (Spring)를 배제한다는 것을 의미합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n남은 것은 순수한 자바 (또는 응용 프로그램을 개발하는 언어)와 해당 비즈니스 로직 구현의 단위 테스트입니다.\n\n잠시 후에 기존 응용 프로그램을 위의 과정을 따르도록 리팩터링할 것입니다. 하지만, 이것을 왜 신경 써야 할까요? 어떤 이점이 있을까요?\n\n## 핵심 비즈니스 로직은 구현 세부 정보에서 자유롭습니다\n\n비즈니스 로직을 반영하는 도메인 모델(도메인 또는 내부라고 부르겠습니다)은 구현 세부 정보(인프라스트럭처 또는 외부라고 부르겠습니다)에 영향을 받지 않습니다. 새로운 기능 요청을 구축해야 하나요? 도메인 모델에서 구현하고 단위 테스트로 유효성을 검사하세요. Spring Boot나 Hibernate를 업데이트해야 하나요? 걱정 마세요, 도메인 모델은 영향을 받지 않습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 도메인 모델이 구현을 주도합니다\n\n도메인 모델은 아키텍처의 핵심에 있습니다. 다른 모든 것은 도메인 모델에서 출발합니다. 비즈니스 로직의 구현을 주도합니다. 이전에 구현을 주도했던 데이터 모델은 이제 영속성에만 관련된 사소한 세부사항입니다. REST API가 필요하다면, 스케줄러가 필요하다면 밤에 실행되는 확인 작업을 주도해야 한다면, AWS 람다를 트리거해야 한다면 — 이 모든 것은 도메인 모델과는 상관이 없습니다.\n\n## 지연된 결정\n\n어떤 사용 사례에 관계형 데이터베이스를 사용해야 할지 아직 확실하지 않나요? 아키텍트가 REST 대 GraphQL 사용에 대한 궁금증에 대답하지 않았나요? 그런 결정들이 비즈니스 로직의 구현을 막아선 안됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n좋아요, 이제 새로운 사고 방식으로 비즈니스 로직을 작성하여 도서관 사용 사례를 구현하는 방법을 살펴볼까요?\n\n## 대여 Bounded Context (헥사고날 아키텍처로 구현)\n\n아래의 패키지 구조로 대여 모듈을 구성할 것입니다. 응용 프로그램 및 도메인 패키지는 헥사곤의 \"내부\"를 나타내고 인프라스트럭처 패키지는 \"외부\"를 나타냅니다.\n\n```js\nsrc/main/java\n└── example\n    ├── borrow\n    │   ├── application\n    │   │   └── ...\n    │   ├── domain\n    │   │   └── ...\n    │   └── infrastructure\n    │       └── ...\n    └── LibraryApplication\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래 규칙을 패키지에 대해 따를 것입니다 (모두에게 해당되는 보편적인 규칙이 아니고, 우리가 직접 정한 것입니다). 이 구현의 복잡성과 아키텍처 원칙을 엄격하게 준수하는 현실적인 접근 사이의 적절한 균형을 유지하고 있다고 생각합니다.\n\n- 도메인 패키지에는 도메인 모델(Aggregates, Entities, Value Objects) 및 인프라스트럭처가 구현할 인터페이스를 제공하는 Secondary / Driven 포트가 포함됩니다. 우리는 표준 자바, Lombok(많은 코드를 줄이기 위한) 및 JMolecules(스테레오타입을 문서화하기 위해) 라이브러리만 사용할 것입니다.\n- 애플리케이션 패키지에는 애플리케이션의 유스케이스를 구현하는 Primary / Driver 포트가 포함됩니다. 우리는 Spring의 @Transactional 및 Modulith의 @ApplicationModuleListener 주석을 사용할 수 있습니다.\n- 인프라스트럭처 패키지에는 REST API 및 JPA 어댑터를 빌드하는 코드가 포함됩니다. 이것은 야생 서부입니다. 제한 사항이 없으며, 모든 라이브러리를 자유롭게 사용할 수 있습니다.\n\n책을 대출하는 사용 사례를 살펴보겠습니다. 사용자는 이용 가능한 책에 예약을 할 수 있습니다. 아래는 사용 사례를 구현하는 주요 포트의 Java 예시입니다. @PrimaryPort 주석이 어디서 온 것인지 궁금하다면 계속 읽어보세요!\n\n```java\n@PrimaryPort\npublic class CirculationDesk {\n\n    private final BookRepository books;\n    private final HoldRepository holds;\n    private final HoldEventPublisher eventPublisher;\n\n    @Transactional\n    public HoldDto placeHold(PlaceHold command) {\n        books.findAvailableBook(command.inventoryNumber())\n                .orElseThrow(() -\u003e new IllegalArgumentException(\"Book not found\"));\n\n        return Hold.placeHold(command)\n                .then(holds::save)\n                .then(eventPublisher::holdPlaced)\n                .to(HoldDto::from);\n    }\n\n    record PlaceHold(Barcode inventoryNumber,\n                     String patronId,\n                     LocalDate dateOfHold) {\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n의존성을 역전시키기 위해, 모든 집합체를 위한 Repository 인터페이스를 도입했습니다 (Spring Data와는 혼동하지 마세요).\n\n```js\n@SecondaryPort\n인터페이스 BookRepository {\n\n    Optional\u003cBook\u003e findAvailableBook(Book.Barcode inventoryNumber);\n\n    Optional\u003cBook\u003e findOnHoldBook(Book.Barcode inventoryNumber);\n\n    Book save(Book book);\n\n    Optional\u003cBook\u003e findByBarcode(String barcode);\n}\n\n@SecondaryPort\n인터페이스 HoldRepository {\n\n    Hold save(Hold hold);\n\n    Optional\u003cHold\u003e findById(Hold.HoldId id);\n\n    List\u003cHold\u003e activeHolds();\n}\n```\n\nCirculationDesk 응용 프로그램 서비스는 위의 리포지터리 인터페이스를 사용합니다. 이를 통해 구현 기술(Spring Data, JPA, JDBC 등)과 독립시켰습니다.\n\n## 집합체로부터 도메인 이벤트 트리거하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n하나의 사용 사례 결과는 Aggregate의 업데이트된 상태를 지속시키는 것입니다. 또 다른 결과는 도메인 이벤트를 발생시켜 모노리스의 다른 모듈 (또는 동일 모듈 내의 다른 Aggregate)에서 대응할 수 있도록 하는 것일 수 있습니다.\n\nAggregate를 지속시키는 것 (Repository 사용)과 이벤트를 발생시키는 것 (Event Publisher 사용)은 헥사고날 아키텍처에서 이차/드라이븐 포트입니다. 구현은 비즈니스 로직과 관련이 없습니다.\n\n사용 사례 실행 후에는 BookPlacedOnHold 이벤트가 발생합니다. 이 이벤트는 Book Aggregate에서 도서 상태를 데이터베이스에서 업데이트하기 위해 사용됩니다. 이벤트 처리는 비즈니스 로직의 중요한 부분이므로 주/드라이버 포트의 책임입니다.\n\n```java\n// 실제로 이벤트가 발행되는 방법에 대한 구현에 대한 이해가 없는\n// 이벤트 퍼블리셔 인터페이스\n@SecondaryPort\npublic interface HoldEventPublisher {\n\n    void holdPlaced(BookPlacedOnHold event);\n\n    default Hold holdPlaced(Hold hold) {\n        BookPlacedOnHold event = new BookPlacedOnHold(hold.getId().id(), hold.getOnBook().barcode(), hold.getDateOfHold());\n        this.holdPlaced(event);\n        return hold;\n    }\n}\n\n// 이벤트 핸들러는 Spring Modulith 리스너를 사용하여\n// 이벤트에 신뢰성있게 대응합니다.\n@PrimaryPort\nclass CirculationDeskEventHandler {\n\n    private final BookRepository books;\n    private final HoldEventPublisher eventPublisher;\n\n    @ApplicationModuleListener\n    public void handle(BookPlacedOnHold event) {\n        books.findAvailableBook(new Book.Barcode(event.inventoryNumber()))\n                .map(Book::markOnHold)\n                .map(books::save)\n                .orElseThrow(() -\u003e new IllegalArgumentException(\"중복 예약?\"));\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 육각형 구조의 \"내부\" (비즈니스 로직) 단위 테스트\n\n![이미지](/assets/img/2024-05-20-AdoptingDomain-FirstThinkinginModularMonolithwithHexagonalArchitecture_4.png)\n\n프레임워크 종속성 없이 비즈니스 로직을 구현하는 큰 장점은 통합 테스트가 필요하지 않고 코드를 단위 테스트할 수 있다는 것입니다. Repository 포트의 인메모리 구현을 사용하여 placeHold 유스케이스를 유효성 검사하는 단위 테스트의 예시가 여기 있습니다(CirculationDeskTest.java 참조).\n\n```java\nclass CirculationDeskTest {\n\n    CirculationDesk circulationDesk; // 애플리케이션 서비스\n\n    BookRepository bookRepository; // 보조 포트\n\n    HoldRepository holdRepository; // 보조 포트\n\n    @BeforeEach\n    void setUp() {\n        bookRepository = new InMemoryBooks();\n        holdRepository = new InMemoryHolds();\n        circulationDesk = new CirculationDesk(bookRepository, holdRepository, new InMemoryHoldsEventPublisher());\n    }\n\n    @Test\n    void patronCanPlaceHold() {\n        var command = new Hold.PlaceHold(new Book.Barcode(\"12345\"), LocalDate.now());\n        var holdDto = circulationDesk.placeHold(command);\n        assertThat(holdDto.getBookBarcode()).isEqualTo(\"12345\");\n        assertThat(holdDto.getDateOfHold()).isNotNull();\n    }\n\n    @Test\n    void bookStatusUpdatedWhenPlacedOnHold() {\n        var command = new Hold.PlaceHold(new Book.Barcode(\"12345\"), LocalDate.now());\n        var hold = Hold.placeHold(command);\n        circulationDesk.handle(new BookPlacedOnHold(hold.getId().id(), hold.getOnBook().barcode(), hold.getDateOfHold()));\n        //noinspection OptionalGetWithoutIsPresent\n        var book = bookRepository.findByBarcode(\"12345\").get();\n        assertThat(book.getStatus()).isEqualTo(ON_HOLD);\n    }\n}\n\n// 테스트 픽처 (보조 포트를 구현하는 보조 어댑터 역할)\nclass InMemoryBooks implements BookRepository {\n\n    private final Map\u003cString, Book\u003e books = new HashMap\u003c\u003e();\n\n    public InMemoryBooks() {\n        var booksToAdd = List.of(\n                Book.addBook(new Book.AddBook(new Book.Barcode(\"12345\"), \"A famous book\", \"92972947199\")),\n                Book.addBook(new Book.AddBook(new Book.Barcode(\"98765\"), \"Another famous book\", \"98137674132\"))\n        );\n        booksToAdd.forEach(book -\u003e books.put(book.getInventoryNumber().barcode(), book));\n    }\n\n    ...\n}\n\n// 테스트 픽처 (보조 포트를 구현하는 보조 어댑터 역할)\nclass InMemoryHolds implements HoldRepository {\n  // InMemoryBooks와 유사한 구현\n  ...\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n도메인 모델이 집계를 지속하거나 이벤트를 트리거하기 위해 인터페이스에 의존하고 있는 점을 감안할 때, 유닛 테스트는 이 인터페이스 메서드를 실행할 수 있도록 테스트 픽스처가 필요합니다. 유당 테스트가 작동하려면 모든 보조/드라이븐 포트에 대한 구현이 필요합니다.\n\n전체 코드는 아래 GitHub 저장소에서 확인할 수 있습니다.\n\n## 아키텍처 규칙 테스트하기\n\nSpring Modulith 및 jMolecules 라이브러리는 ArchUnit과 함께 사용되어 우리의 솔루션에서 적용된 아키텍처와 Modular Monolith 애플리케이션의 모듈 간 상호 작용을 테스트할 수 있게 합니다. 이는 새로운 개발자들이 작업을 시작함에 따라 우리의 애플리케이션이 선택한 아키텍처에서 벗어나지 않도록 하는 데 중요합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n저희 모듈형 모놀리스 응용 프로그램에는 이제 Catalog 및 Borrow 두 개의 모듈이 있습니다. Catalog 모듈은 Layered/N-tier 아키텍처를 사용하고 Borrow 모듈은 Hexagonal 아키텍처를 사용하고 있어요. 다음과 같이 테스트할 수 있어요 (BorrowJMoleculesTests 및 CatalogJMoleculesTests 참고).\n\n```js\n@AnalyzeClasses(packages = \"example.catalog\")\npublic class CatalogJMoleculesTests {\n\n    @ArchTest\n    ArchRule dddRules = JMoleculesDddRules.all();\n\n    @ArchTest\n    ArchRule layering = JMoleculesArchitectureRules.ensureLayering();\n}\n\n@AnalyzeClasses(packages = \"example.borrow\")\npublic class BorrowJMoleculesTests {\n\n    @ArchTest\n    ArchRule dddRules = JMoleculesDddRules.all();\n\n    @ArchTest\n    ArchRule hexagonal = JMoleculesArchitectureRules.ensureHexagonal();\n}\n```\n\n@AnalyzeClasses 주석을 사용하여 테스트할 모듈을 선택할 수 있어요.\n\n## Hexagonal 아키텍처의 \"외부\"를 통합 테스트하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n기술이 도메인 모델과 상호 작용하는 외부 부분은 동작을 확인하기 위해 통합 테스트로 테스트해야 합니다. 여기에 예제가 있습니다 (영속성인 CirculationDeskIT.java 및 REST인 CirculationDeskControllerIT.java):\n\n```js\n// from CirculationDeskIT\n@Test\nvoid patronCanPlaceHold(Scenario scenario) {\n    var command = new Hold.PlaceHold(new Book.Barcode(\"13268510\"), LocalDate.now());\n    scenario.stimulate(() -\u003e circulationDesk.placeHold(command))\n            .andWaitForEventOfType(BookPlacedOnHold.class)\n            .toArriveAndVerify((event, dto) -\u003e {\n                assertThat(event.inventoryNumber()).isEqualTo(\"13268510\");\n            });\n}\n\n// from CirculationDeskControllerIT\n@Test\nvoid placeHoldRestCall() throws Exception {\n    mockMvc.perform(post(\"/borrow/holds\")\n                    .contentType(MediaType.APPLICATION_JSON)\n                    .content(\"\"\"\n                            {\n                              \"barcode\": \"64321704\",\n                              \"patronId\": 5\n                            }\n                            \"\"\"))\n            .andExpect(status().isOk());\n}\n```\n\n## jMolecules로 클래스 스테레오타입 시각화\n\n이전 블로그 시리즈에서 언급했듯이 jMolecules Intellij 플러그인을 사용하여 다양한 스테레오타입을 시각화할 수 있습니다. 그러나 jMolecules 라이브러리가 헥사고날 아키텍처에 대한 주석을 지원하더라도 플러그인은 해당 주석을 지원하지 않습니다. 저는 관련 주석을 추가하여 플러그인을 수정했습니다. 플러그인을 활성화하고 관련 주석을 추가한 후 대여 모듈 내부 클래스가 어떻게 보이는지 확인하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![](/assets/img/2024-05-20-AdoptingDomain-FirstThinkinginModularMonolithwithHexagonalArchitecture_5.png)\n\n주요 포트 및 어댑터 클래스를 쉽게 식별할 수 있습니다.\n\n## 헥사고날 아키텍처에 헌신해야 할까요?\n\n모듈형 단일체 애플리케이션을 구축할 때, 모든 모듈에 대해 헥사고날 아키텍처를 사용해야 할지에 대해 고려해야 합니다. 만약 모듈이 자체 비즈니스 규칙을 갖고 있거나 (또는 나중에 갖게 될 것으로 예상된다면), 헥사고날 아키텍처가 좋은 아이디어일 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n하지만 해결책에 더 많은 클래스와 장황성을 추가합니다. Layered 아키텍처에는 보조 포트와 어댑터가 없습니다. Spring Data 리포지토리 인터페이스는 Service 클래스에 직접 의존성을 추가하는 대가로 보조 포트와 어댑터의 역할을 취합니다.\n\n결국, 헥사고날 아키텍처를 채택하는 이점이 비용을 크게 상회합니다. 최소한 코드베이스에서 불필요한 결합을 줄이기 위해 의존성 역전의 원칙을 적용할 수 있는지 항상 확인해야 합니다.\n\n## 헥사고날 아키텍처를 구현하는 데 DDD가 필요한가요?\n\n아니요. 도메인 주도 설계(DDD)는 도메인이 모델링되는 방식에만 관련이 있습니다. 아키텍처와는 관련이 없습니다(헥사고날이든 그 외). DDD를 사용해야 하는가요? 클래스와 필드를 명명할 때 항상 모든 지식의 언어를 사용하는 것을 추천합니다. 도메인 전문가가 사용하는 용어와 동일한 용어를 사용하는 코드는 항상 이해하기 쉽습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nDDD의 Aggregate 및 기타 전략적 패턴을 사용하는 것은 애플리케이션의 필요성과 복잡성에 따라 다릅니다. 정당화되지 않은 경우에는 트랜잭션 스크립트나 액티브 레코드를 대신 사용할 수 있습니다.\n\n## 헥사고날 아키텍처의 순수 구현 회피\n\n헥사곤의 내부는 핵심 비즈니스 로직의 구현이며, 헥사곤 외부에서 사용된 프레임워크와 기술로부터 자유롭게 유지해야 합니다. 몇몇 구현이 이 규칙을 신앙적으로 따라 코드를 복잡하게 만드는 것을 본 적이 있습니다.\n\n예를 들어, 애플리케이션 서비스 코드는 트랜잭션 내에서 실행되어야 합니다. Spring의 @Transactional을 사용하면 쉽게 달성할 수 있습니다. 그러나 이를 피하려면 애플리케이션 서비스를 Spring으로부터 자유롭게 유지하기 위해 사용자 정의 어노테이션과 AOP를 도입해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n헥사곤 안의 내부는 Application과 Domain으로 구성되어 있습니다. 도메인은 이상적으로는 프레임워크 없이 유지되어야 하지만, Application은 Spring을 사용할 수 있습니다. 이 질문을 Vaughn Vernon에게 던졌고, 그는 좋은 설명을 제공했습니다.\n\n![이미지](/assets/img/2024-05-20-AdoptingDomain-FirstThinkinginModularMonolithwithHexagonalArchitecture_6.png)\n\n## 도메인 모델로부터 만들어진 분리된 JPA 엔티티를 병합하기\n\n아래 코드 스니펫을 확인하여 Hold를 배치하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\npublic HoldDto placeHold(Hold.PlaceHold command) {\n    ...\n\n    Hold.placeHold(command) // Hold 도메인 모델 객체 생성\n            .then(holds::save) // JPA 엔티티로 변환하여 데이터베이스에 저장\n            .then(eventPublisher::holdPlaced) // HoldPlaced 이벤트를 트리거\n\n    ...\n  );\n}\n```\n\nholds::save는 Secondary 포트 인터페이스에서의 호출로, Secondary 어댑터 구현을 트리거합니다:\n\n```js\npublic Hold save(Hold hold) {\n    holds.save(HoldEntity.fromDomain(hold));\n    return hold;\n}\n\n// HoldEntity 클래스에서\npublic static HoldEntity fromDomain(Hold hold) {\n    var entity = new HoldEntity();\n    entity.id = hold.getId().id(); // 도메인 모델 식별자와 JPA 엔티티 PK가 동일합니다!\n    entity.book = hold.getOnBook();\n    entity.dateOfHold = hold.getDateOfHold();\n    entity.status = HoldStatus.HOLDING;\n    entity.version = 0L;\n    return entity;\n}\n```\n\nHold 도메인 모델은 영속화되기 전에 분리된 HoldEntity JPA 엔티티로 변환되어야 합니다. 엔티티 생성에는 기본 키 ID를 알아야 합니다. 도메인 모델이 PK를 따로 저장하거나 모델 식별자로 사용해야 합니다. 저의 예시에서는 후자를 선택했지만, 이 문제를 어떻게 해결할지 궁금합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 결론\n\n이 블로그에서는 계층 구조 대신 헥사고날 아키텍처를 사용하여 대출 모듈을 다시 구현했습니다. 이 과정에서 동일한 단일 코드 베이스의 일부임에도 불구하고 카탈로그 모듈에는 절대적으로 변경이 필요하지 않았음을 보여주었습니다. 이는 이벤트 기반 통합 덕분에 느슨한 결합이 활성화되었음을 확인했습니다.\n\n헥사고날에 대한 여러분의 경험은 어떠한가요? 댓글에서 공유해 주시면 감사하겠습니다.\n\n아래에서 업데이트된 코드를 확인할 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-05-20-AdoptingDomain-FirstThinkinginModularMonolithwithHexagonalArchitecture_0.png"},"coverImage":"/assets/img/2024-05-20-AdoptingDomain-FirstThinkinginModularMonolithwithHexagonalArchitecture_0.png","tag":["Tech"],"readingTime":21},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-20-AdoptingDomain-FirstThinkinginModularMonolithwithHexagonalArchitecture_0.png\" alt=\"Image\"\u003e\u003c/p\u003e\n\u003cp\u003ePart 1:\u003c/p\u003e\n\u003cp\u003ePart 2:\u003c/p\u003e\n\u003cp\u003eIn the first blog, we explored the concept of Modular Monolith, what is a module and how DDD strategy patterns can be used to create modular applications.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e두 번째 블로그에서는 Spring Modulith가 모듈 모노리스 응용 프로그램에서 아키텍처 유효성 검사, 독립 모듈의 테스팅 및 이벤트 기반 통합을 어떻게 용이하게 하는지 살펴보았어요.\u003c/p\u003e\n\u003cp\u003e이 블로그에서는 단일 모듈을 자세히 살펴보고 헥사고날 아키텍처가 핵심 비즈니스 로직의 유지보수성 및 테스트를 어떻게 향상시키는지 이해할 거에요. 또한 헥사고날 아키텍처가 DDD 및 모듈 모노리스 응용 프로그램의 맥락 속에 어떻게 맞는지도 이해할 거에요.\u003c/p\u003e\n\u003cp\u003e헥사고날 아키텍처를 배우는 데 한 가지 어려움은 용어로 오인될 수 있다는 것이에요. 헥사곤 모양이나 숫자 여섯과는 아무런 상관이 없답니다. \"포트\"와 \"어댑터\"라는 용어가 과부하되어 있어서 여러분은 무엇을 의미하는지 배우기 전에 스스로의 해석을 잊어야 해요. 아키텍처의 층이 없다는 점(바깥쪽과 안쪽 이외에)과 의견이 분분하지 않은 아키텍처의 특성으로 인해 누구나 자신의 방식대로 구현할 수 있어요.\u003c/p\u003e\n\u003cp\u003e나는 헥사고날 아키텍처를 이해하고 Java와 Spring Boot 응용 프로그램에서 적용하는 방법에 대해 시도했을 때, 헥사고날을 사용하지 않고 응용 프로그램을 작성한 후 문제를 겪고 하나씩 해결하여 어떤 것이 헥사고날인지 알아냈어요. 하지만 그것은 몇 년이 걸릴 수 있어요! 이 블로그(시리즈)에서는 이 과정을 더 짧은 시간 안에 기록하고 싶어요.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e기업 문제를 해결하기 위한 애플리케이션을 개발하는 업무를 맡았습니다. 해당 애플리케이션은 웹을 통해 접속되며, 일부 비즈니스 로직을 구현하고 데이터를 데이터베이스에 저장할 것입니다 (당연히). 애플리케이션을 설계하는 과정에서 어떤 생각을 가지게 되시나요?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e웹 애플리케이션이어야 하므로, 최신하면서 반짝이는 자바스크립트 프레임워크(React?)를 사용하여 JSON을 제공하는 REST API 및 멋진 UI를 구축할 것입니다.\u003c/li\u003e\n\u003cli\u003e비즈니스 요구 사항이 NoSQL DB를 필요로 하지 않는 한 관계형 데이터베이스를 사용할 것입니다.\u003c/li\u003e\n\u003cli\u003e비즈니스 요구 사항을 바탕으로 여러 엔티티를 식별하고 ERD에 매핑할 것입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이런 내용이 익숙하시나요?\u003c/p\u003e\n\u003cp\u003e3번 항목에 집중해 봅시다. ERD 여부와 상관없이, 데이터 모델을 도출하기 위해 여러 엔티티를 식별하고 그것을 시간이 흘러도 발전시킬 수 있는 것은 모든 웹 백엔드 엔지니어가 해야 하는 일이며 시작점이 될 수도 있습니다! 저는 이를 여러 차례 경험해 보았습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이 방법은 (의식적인 아키텍처가 적용되지 않을 때 기본으로 사용되는) 계층화된/N계층 아키텍처로 구성된 애플리케이션을 만들게 됩니다. 데이터 모델은 JPA 엔티티로 구성되며, Repositories를 통해 영속화되고, 비즈니스 로직은 Services에 구현됩니다.\u003c/p\u003e\n\u003cp\u003e이러한 구현의 핵심 특성 중 하나는 비즈니스 로직(Services)이 데이터 모델에서 작동하며 데이터베이스에 의존하는 것입니다. 특히 JPA/JDBC가 실제 데이터베이스 기술을 추상화하고 있기 때문에 바로 알아차리기 어렵습니다. 하지만 데이터베이스 구현(테이블 구조, 외래 키 관계, 인덱스 등)이 비즈니스 로직 구현을 주도하는 것이 아니라 그 반대로 작용하고 있습니다. 아래 그림에서 보듯이, 애플리케이션 서비스는 Spring과 JPA/Hibernate와 같은 기술과 강하게 결합됩니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-20-AdoptingDomain-FirstThinkinginModularMonolithwithHexagonalArchitecture_1.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch2\u003e의존성 역전\u003c/h2\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e자, 이제 우리는 다르게 생각하고 문제에 접근해 보겠습니다. 데이터 모델에 초점을 맞추는 대신, 비즈니스 로직과 제약 조건을 포착하는 여러 클래스를 만들어 보겠습니다. 이를 도메인 모델이라고 부르겠습니다.\u003c/p\u003e\n\u003cp\u003e이 접근 방식에서는, 서비스가 스프링 데이터 리포지토리를 직접 사용하는 대신, 의존성을 반전시키기 위해 인터페이스를 도입하여 서비스가 필요로 하는 동작을 정의하고 이것이 어떻게 구현되었는지 신경쓰지 않습니다. 실은 스프링 데이터 리포지토리는 Java 인터페이스로 정의되어 있지만, 다이내믹 프록시를 통해 구현을 결합하는 인터페이스는 아닙니다.\u003c/p\u003e\n\u003cp\u003e의존성을 반전시키기 위해 사용된 인터페이스를 포트(port)로, 인터페이스의 구현은 어댑터(adapter)로 부릅니다. 이들은 도메인 모델에 의해 주도(들어온)되므로 주도 또는 보조(secondary)로 알려져 있습니다. 이는 헥사고날 아키텍처에서 사용되는 용어입니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e한편, 유스 케이스를 구현하는 데 사용되는 Application 서비스도 포트입니다. 차이점은 Java 인터페이스가 아니라 일반 클래스임을 의미합니다. 또한 해당 어댑터와 함께 사용됩니다. 이 어댑터는 기술을 접근하여 우리의 사용 사례에 연결합니다(REST API, GraphQL, 람다 등). 이러한 포트와 어댑터는 도메인 모델을 사용하므로 드라이버 또는 주요 요소로 알려져 있습니다. 이들은 우리 모델의 사용을 이끌어냅니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-20-AdoptingDomain-FirstThinkinginModularMonolithwithHexagonalArchitecture_3.png\" alt=\"그림 안내\"\u003e\u003c/p\u003e\n\u003cp\u003e기본 및 보조 포트와 어댑터를 결합하면 헥사고날(또는 포트 및 어댑터) 아키텍처로 이어집니다.\u003c/p\u003e\n\u003cp\u003e새로운 접근 방법을 적용하는 데 도움이 되도록 몇 가지 제약 조건을 소개해 보겠습니다. 우리는 프레임워크/구현이 우리의 생각을 이끌도록 허용하지 않겠습니다. 이는 데이터베이스 라이브러리 (JPA/JDBC), 이벤트 프레임워크 (Apache Kafka) 및 애플리케이션 프레임워크 (Spring)를 배제한다는 것을 의미합니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e남은 것은 순수한 자바 (또는 응용 프로그램을 개발하는 언어)와 해당 비즈니스 로직 구현의 단위 테스트입니다.\u003c/p\u003e\n\u003cp\u003e잠시 후에 기존 응용 프로그램을 위의 과정을 따르도록 리팩터링할 것입니다. 하지만, 이것을 왜 신경 써야 할까요? 어떤 이점이 있을까요?\u003c/p\u003e\n\u003ch2\u003e핵심 비즈니스 로직은 구현 세부 정보에서 자유롭습니다\u003c/h2\u003e\n\u003cp\u003e비즈니스 로직을 반영하는 도메인 모델(도메인 또는 내부라고 부르겠습니다)은 구현 세부 정보(인프라스트럭처 또는 외부라고 부르겠습니다)에 영향을 받지 않습니다. 새로운 기능 요청을 구축해야 하나요? 도메인 모델에서 구현하고 단위 테스트로 유효성을 검사하세요. Spring Boot나 Hibernate를 업데이트해야 하나요? 걱정 마세요, 도메인 모델은 영향을 받지 않습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003e도메인 모델이 구현을 주도합니다\u003c/h2\u003e\n\u003cp\u003e도메인 모델은 아키텍처의 핵심에 있습니다. 다른 모든 것은 도메인 모델에서 출발합니다. 비즈니스 로직의 구현을 주도합니다. 이전에 구현을 주도했던 데이터 모델은 이제 영속성에만 관련된 사소한 세부사항입니다. REST API가 필요하다면, 스케줄러가 필요하다면 밤에 실행되는 확인 작업을 주도해야 한다면, AWS 람다를 트리거해야 한다면 — 이 모든 것은 도메인 모델과는 상관이 없습니다.\u003c/p\u003e\n\u003ch2\u003e지연된 결정\u003c/h2\u003e\n\u003cp\u003e어떤 사용 사례에 관계형 데이터베이스를 사용해야 할지 아직 확실하지 않나요? 아키텍트가 REST 대 GraphQL 사용에 대한 궁금증에 대답하지 않았나요? 그런 결정들이 비즈니스 로직의 구현을 막아선 안됩니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e좋아요, 이제 새로운 사고 방식으로 비즈니스 로직을 작성하여 도서관 사용 사례를 구현하는 방법을 살펴볼까요?\u003c/p\u003e\n\u003ch2\u003e대여 Bounded Context (헥사고날 아키텍처로 구현)\u003c/h2\u003e\n\u003cp\u003e아래의 패키지 구조로 대여 모듈을 구성할 것입니다. 응용 프로그램 및 도메인 패키지는 헥사곤의 \"내부\"를 나타내고 인프라스트럭처 패키지는 \"외부\"를 나타냅니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003esrc/main/java\n└── example\n    ├── borrow\n    │   ├── application\n    │   │   └── ...\n    │   ├── domain\n    │   │   └── ...\n    │   └── infrastructure\n    │       └── ...\n    └── \u003cspan class=\"hljs-title class_\"\u003eLibraryApplication\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e아래 규칙을 패키지에 대해 따를 것입니다 (모두에게 해당되는 보편적인 규칙이 아니고, 우리가 직접 정한 것입니다). 이 구현의 복잡성과 아키텍처 원칙을 엄격하게 준수하는 현실적인 접근 사이의 적절한 균형을 유지하고 있다고 생각합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e도메인 패키지에는 도메인 모델(Aggregates, Entities, Value Objects) 및 인프라스트럭처가 구현할 인터페이스를 제공하는 Secondary / Driven 포트가 포함됩니다. 우리는 표준 자바, Lombok(많은 코드를 줄이기 위한) 및 JMolecules(스테레오타입을 문서화하기 위해) 라이브러리만 사용할 것입니다.\u003c/li\u003e\n\u003cli\u003e애플리케이션 패키지에는 애플리케이션의 유스케이스를 구현하는 Primary / Driver 포트가 포함됩니다. 우리는 Spring의 @Transactional 및 Modulith의 @ApplicationModuleListener 주석을 사용할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e인프라스트럭처 패키지에는 REST API 및 JPA 어댑터를 빌드하는 코드가 포함됩니다. 이것은 야생 서부입니다. 제한 사항이 없으며, 모든 라이브러리를 자유롭게 사용할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e책을 대출하는 사용 사례를 살펴보겠습니다. 사용자는 이용 가능한 책에 예약을 할 수 있습니다. 아래는 사용 사례를 구현하는 주요 포트의 Java 예시입니다. @PrimaryPort 주석이 어디서 온 것인지 궁금하다면 계속 읽어보세요!\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-meta\"\u003e@PrimaryPort\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eCirculationDesk\u003c/span\u003e {\n\n    \u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efinal\u003c/span\u003e BookRepository books;\n    \u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efinal\u003c/span\u003e HoldRepository holds;\n    \u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efinal\u003c/span\u003e HoldEventPublisher eventPublisher;\n\n    \u003cspan class=\"hljs-meta\"\u003e@Transactional\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e HoldDto \u003cspan class=\"hljs-title function_\"\u003eplaceHold\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(PlaceHold command)\u003c/span\u003e {\n        books.findAvailableBook(command.inventoryNumber())\n                .orElseThrow(() -\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eIllegalArgumentException\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Book not found\"\u003c/span\u003e));\n\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e Hold.placeHold(command)\n                .then(holds::save)\n                .then(eventPublisher::holdPlaced)\n                .to(HoldDto::from);\n    }\n\n    \u003cspan class=\"hljs-keyword\"\u003erecord\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePlaceHold\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(Barcode inventoryNumber,\n                     String patronId,\n                     LocalDate dateOfHold)\u003c/span\u003e {\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e의존성을 역전시키기 위해, 모든 집합체를 위한 Repository 인터페이스를 도입했습니다 (Spring Data와는 혼동하지 마세요).\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e@\u003cspan class=\"hljs-title class_\"\u003eSecondaryPort\u003c/span\u003e\n인터페이스 \u003cspan class=\"hljs-title class_\"\u003eBookRepository\u003c/span\u003e {\n\n    \u003cspan class=\"hljs-title class_\"\u003eOptional\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eBook\u003c/span\u003e\u003e \u003cspan class=\"hljs-title function_\"\u003efindAvailableBook\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eBook\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eBarcode\u003c/span\u003e inventoryNumber);\n\n    \u003cspan class=\"hljs-title class_\"\u003eOptional\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eBook\u003c/span\u003e\u003e \u003cspan class=\"hljs-title function_\"\u003efindOnHoldBook\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eBook\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eBarcode\u003c/span\u003e inventoryNumber);\n\n    \u003cspan class=\"hljs-title class_\"\u003eBook\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003esave\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eBook\u003c/span\u003e book);\n\n    \u003cspan class=\"hljs-title class_\"\u003eOptional\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eBook\u003c/span\u003e\u003e \u003cspan class=\"hljs-title function_\"\u003efindByBarcode\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e barcode);\n}\n\n@\u003cspan class=\"hljs-title class_\"\u003eSecondaryPort\u003c/span\u003e\n인터페이스 \u003cspan class=\"hljs-title class_\"\u003eHoldRepository\u003c/span\u003e {\n\n    \u003cspan class=\"hljs-title class_\"\u003eHold\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003esave\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eHold\u003c/span\u003e hold);\n\n    \u003cspan class=\"hljs-title class_\"\u003eOptional\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eHold\u003c/span\u003e\u003e \u003cspan class=\"hljs-title function_\"\u003efindById\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eHold\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eHoldId\u003c/span\u003e id);\n\n    \u003cspan class=\"hljs-title class_\"\u003eList\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eHold\u003c/span\u003e\u003e \u003cspan class=\"hljs-title function_\"\u003eactiveHolds\u003c/span\u003e();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eCirculationDesk 응용 프로그램 서비스는 위의 리포지터리 인터페이스를 사용합니다. 이를 통해 구현 기술(Spring Data, JPA, JDBC 등)과 독립시켰습니다.\u003c/p\u003e\n\u003ch2\u003e집합체로부터 도메인 이벤트 트리거하기\u003c/h2\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e하나의 사용 사례 결과는 Aggregate의 업데이트된 상태를 지속시키는 것입니다. 또 다른 결과는 도메인 이벤트를 발생시켜 모노리스의 다른 모듈 (또는 동일 모듈 내의 다른 Aggregate)에서 대응할 수 있도록 하는 것일 수 있습니다.\u003c/p\u003e\n\u003cp\u003eAggregate를 지속시키는 것 (Repository 사용)과 이벤트를 발생시키는 것 (Event Publisher 사용)은 헥사고날 아키텍처에서 이차/드라이븐 포트입니다. 구현은 비즈니스 로직과 관련이 없습니다.\u003c/p\u003e\n\u003cp\u003e사용 사례 실행 후에는 BookPlacedOnHold 이벤트가 발생합니다. 이 이벤트는 Book Aggregate에서 도서 상태를 데이터베이스에서 업데이트하기 위해 사용됩니다. 이벤트 처리는 비즈니스 로직의 중요한 부분이므로 주/드라이버 포트의 책임입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 실제로 이벤트가 발행되는 방법에 대한 구현에 대한 이해가 없는\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 이벤트 퍼블리셔 인터페이스\u003c/span\u003e\n\u003cspan class=\"hljs-meta\"\u003e@SecondaryPort\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003einterface\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eHoldEventPublisher\u003c/span\u003e {\n\n    \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eholdPlaced\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(BookPlacedOnHold event)\u003c/span\u003e;\n\n    \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e Hold \u003cspan class=\"hljs-title function_\"\u003eholdPlaced\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(Hold hold)\u003c/span\u003e {\n        \u003cspan class=\"hljs-type\"\u003eBookPlacedOnHold\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003eevent\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eBookPlacedOnHold\u003c/span\u003e(hold.getId().id(), hold.getOnBook().barcode(), hold.getDateOfHold());\n        \u003cspan class=\"hljs-built_in\"\u003ethis\u003c/span\u003e.holdPlaced(event);\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e hold;\n    }\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// 이벤트 핸들러는 Spring Modulith 리스너를 사용하여\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 이벤트에 신뢰성있게 대응합니다.\u003c/span\u003e\n\u003cspan class=\"hljs-meta\"\u003e@PrimaryPort\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eCirculationDeskEventHandler\u003c/span\u003e {\n\n    \u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efinal\u003c/span\u003e BookRepository books;\n    \u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efinal\u003c/span\u003e HoldEventPublisher eventPublisher;\n\n    \u003cspan class=\"hljs-meta\"\u003e@ApplicationModuleListener\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ehandle\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(BookPlacedOnHold event)\u003c/span\u003e {\n        books.findAvailableBook(\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eBook\u003c/span\u003e.Barcode(event.inventoryNumber()))\n                .map(Book::markOnHold)\n                .map(books::save)\n                .orElseThrow(() -\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eIllegalArgumentException\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"중복 예약?\"\u003c/span\u003e));\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003e육각형 구조의 \"내부\" (비즈니스 로직) 단위 테스트\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-20-AdoptingDomain-FirstThinkinginModularMonolithwithHexagonalArchitecture_4.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e프레임워크 종속성 없이 비즈니스 로직을 구현하는 큰 장점은 통합 테스트가 필요하지 않고 코드를 단위 테스트할 수 있다는 것입니다. Repository 포트의 인메모리 구현을 사용하여 placeHold 유스케이스를 유효성 검사하는 단위 테스트의 예시가 여기 있습니다(CirculationDeskTest.java 참조).\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eCirculationDeskTest\u003c/span\u003e {\n\n    CirculationDesk circulationDesk; \u003cspan class=\"hljs-comment\"\u003e// 애플리케이션 서비스\u003c/span\u003e\n\n    BookRepository bookRepository; \u003cspan class=\"hljs-comment\"\u003e// 보조 포트\u003c/span\u003e\n\n    HoldRepository holdRepository; \u003cspan class=\"hljs-comment\"\u003e// 보조 포트\u003c/span\u003e\n\n    \u003cspan class=\"hljs-meta\"\u003e@BeforeEach\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003esetUp\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e {\n        bookRepository = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eInMemoryBooks\u003c/span\u003e();\n        holdRepository = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eInMemoryHolds\u003c/span\u003e();\n        circulationDesk = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eCirculationDesk\u003c/span\u003e(bookRepository, holdRepository, \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eInMemoryHoldsEventPublisher\u003c/span\u003e());\n    }\n\n    \u003cspan class=\"hljs-meta\"\u003e@Test\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003epatronCanPlaceHold\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e {\n        \u003cspan class=\"hljs-type\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003ecommand\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eHold\u003c/span\u003e.PlaceHold(\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eBook\u003c/span\u003e.Barcode(\u003cspan class=\"hljs-string\"\u003e\"12345\"\u003c/span\u003e), LocalDate.now());\n        \u003cspan class=\"hljs-type\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003eholdDto\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e circulationDesk.placeHold(command);\n        assertThat(holdDto.getBookBarcode()).isEqualTo(\u003cspan class=\"hljs-string\"\u003e\"12345\"\u003c/span\u003e);\n        assertThat(holdDto.getDateOfHold()).isNotNull();\n    }\n\n    \u003cspan class=\"hljs-meta\"\u003e@Test\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ebookStatusUpdatedWhenPlacedOnHold\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e {\n        \u003cspan class=\"hljs-type\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003ecommand\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eHold\u003c/span\u003e.PlaceHold(\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eBook\u003c/span\u003e.Barcode(\u003cspan class=\"hljs-string\"\u003e\"12345\"\u003c/span\u003e), LocalDate.now());\n        \u003cspan class=\"hljs-type\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003ehold\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e Hold.placeHold(command);\n        circulationDesk.handle(\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eBookPlacedOnHold\u003c/span\u003e(hold.getId().id(), hold.getOnBook().barcode(), hold.getDateOfHold()));\n        \u003cspan class=\"hljs-comment\"\u003e//noinspection OptionalGetWithoutIsPresent\u003c/span\u003e\n        \u003cspan class=\"hljs-type\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003ebook\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e bookRepository.findByBarcode(\u003cspan class=\"hljs-string\"\u003e\"12345\"\u003c/span\u003e).get();\n        assertThat(book.getStatus()).isEqualTo(ON_HOLD);\n    }\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// 테스트 픽처 (보조 포트를 구현하는 보조 어댑터 역할)\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eInMemoryBooks\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimplements\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eBookRepository\u003c/span\u003e {\n\n    \u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efinal\u003c/span\u003e Map\u0026#x3C;String, Book\u003e books = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eHashMap\u003c/span\u003e\u0026#x3C;\u003e();\n\n    \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eInMemoryBooks\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e {\n        \u003cspan class=\"hljs-type\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003ebooksToAdd\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e List.of(\n                Book.addBook(\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eBook\u003c/span\u003e.AddBook(\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eBook\u003c/span\u003e.Barcode(\u003cspan class=\"hljs-string\"\u003e\"12345\"\u003c/span\u003e), \u003cspan class=\"hljs-string\"\u003e\"A famous book\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"92972947199\"\u003c/span\u003e)),\n                Book.addBook(\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eBook\u003c/span\u003e.AddBook(\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eBook\u003c/span\u003e.Barcode(\u003cspan class=\"hljs-string\"\u003e\"98765\"\u003c/span\u003e), \u003cspan class=\"hljs-string\"\u003e\"Another famous book\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"98137674132\"\u003c/span\u003e))\n        );\n        booksToAdd.forEach(book -\u003e books.put(book.getInventoryNumber().barcode(), book));\n    }\n\n    ...\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// 테스트 픽처 (보조 포트를 구현하는 보조 어댑터 역할)\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eInMemoryHolds\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimplements\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eHoldRepository\u003c/span\u003e {\n  \u003cspan class=\"hljs-comment\"\u003e// InMemoryBooks와 유사한 구현\u003c/span\u003e\n  ...\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e도메인 모델이 집계를 지속하거나 이벤트를 트리거하기 위해 인터페이스에 의존하고 있는 점을 감안할 때, 유닛 테스트는 이 인터페이스 메서드를 실행할 수 있도록 테스트 픽스처가 필요합니다. 유당 테스트가 작동하려면 모든 보조/드라이븐 포트에 대한 구현이 필요합니다.\u003c/p\u003e\n\u003cp\u003e전체 코드는 아래 GitHub 저장소에서 확인할 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e아키텍처 규칙 테스트하기\u003c/h2\u003e\n\u003cp\u003eSpring Modulith 및 jMolecules 라이브러리는 ArchUnit과 함께 사용되어 우리의 솔루션에서 적용된 아키텍처와 Modular Monolith 애플리케이션의 모듈 간 상호 작용을 테스트할 수 있게 합니다. 이는 새로운 개발자들이 작업을 시작함에 따라 우리의 애플리케이션이 선택한 아키텍처에서 벗어나지 않도록 하는 데 중요합니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e저희 모듈형 모놀리스 응용 프로그램에는 이제 Catalog 및 Borrow 두 개의 모듈이 있습니다. Catalog 모듈은 Layered/N-tier 아키텍처를 사용하고 Borrow 모듈은 Hexagonal 아키텍처를 사용하고 있어요. 다음과 같이 테스트할 수 있어요 (BorrowJMoleculesTests 및 CatalogJMoleculesTests 참고).\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e@\u003cspan class=\"hljs-title class_\"\u003eAnalyzeClasses\u003c/span\u003e(packages = \u003cspan class=\"hljs-string\"\u003e\"example.catalog\"\u003c/span\u003e)\npublic \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eCatalogJMoleculesTests\u003c/span\u003e {\n\n    @\u003cspan class=\"hljs-title class_\"\u003eArchTest\u003c/span\u003e\n    \u003cspan class=\"hljs-title class_\"\u003eArchRule\u003c/span\u003e dddRules = \u003cspan class=\"hljs-title class_\"\u003eJMoleculesDddRules\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eall\u003c/span\u003e();\n\n    @\u003cspan class=\"hljs-title class_\"\u003eArchTest\u003c/span\u003e\n    \u003cspan class=\"hljs-title class_\"\u003eArchRule\u003c/span\u003e layering = \u003cspan class=\"hljs-title class_\"\u003eJMoleculesArchitectureRules\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eensureLayering\u003c/span\u003e();\n}\n\n@\u003cspan class=\"hljs-title class_\"\u003eAnalyzeClasses\u003c/span\u003e(packages = \u003cspan class=\"hljs-string\"\u003e\"example.borrow\"\u003c/span\u003e)\npublic \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eBorrowJMoleculesTests\u003c/span\u003e {\n\n    @\u003cspan class=\"hljs-title class_\"\u003eArchTest\u003c/span\u003e\n    \u003cspan class=\"hljs-title class_\"\u003eArchRule\u003c/span\u003e dddRules = \u003cspan class=\"hljs-title class_\"\u003eJMoleculesDddRules\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eall\u003c/span\u003e();\n\n    @\u003cspan class=\"hljs-title class_\"\u003eArchTest\u003c/span\u003e\n    \u003cspan class=\"hljs-title class_\"\u003eArchRule\u003c/span\u003e hexagonal = \u003cspan class=\"hljs-title class_\"\u003eJMoleculesArchitectureRules\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eensureHexagonal\u003c/span\u003e();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e@AnalyzeClasses 주석을 사용하여 테스트할 모듈을 선택할 수 있어요.\u003c/p\u003e\n\u003ch2\u003eHexagonal 아키텍처의 \"외부\"를 통합 테스트하기\u003c/h2\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e기술이 도메인 모델과 상호 작용하는 외부 부분은 동작을 확인하기 위해 통합 테스트로 테스트해야 합니다. 여기에 예제가 있습니다 (영속성인 CirculationDeskIT.java 및 REST인 CirculationDeskControllerIT.java):\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// from CirculationDeskIT\u003c/span\u003e\n@\u003cspan class=\"hljs-title class_\"\u003eTest\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003epatronCanPlaceHold\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eScenario scenario\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e command = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eHold\u003c/span\u003e.\u003cspan class=\"hljs-title class_\"\u003ePlaceHold\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eBook\u003c/span\u003e.\u003cspan class=\"hljs-title class_\"\u003eBarcode\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"13268510\"\u003c/span\u003e), \u003cspan class=\"hljs-title class_\"\u003eLocalDate\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003enow\u003c/span\u003e());\n    scenario.\u003cspan class=\"hljs-title function_\"\u003estimulate\u003c/span\u003e(() -\u003e circulationDesk.\u003cspan class=\"hljs-title function_\"\u003eplaceHold\u003c/span\u003e(command))\n            .\u003cspan class=\"hljs-title function_\"\u003eandWaitForEventOfType\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eBookPlacedOnHold\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eclass\u003c/span\u003e)\n            .\u003cspan class=\"hljs-title function_\"\u003etoArriveAndVerify\u003c/span\u003e((event, dto) -\u003e {\n                \u003cspan class=\"hljs-title function_\"\u003eassertThat\u003c/span\u003e(event.\u003cspan class=\"hljs-title function_\"\u003einventoryNumber\u003c/span\u003e()).\u003cspan class=\"hljs-title function_\"\u003eisEqualTo\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"13268510\"\u003c/span\u003e);\n            });\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// from CirculationDeskControllerIT\u003c/span\u003e\n@\u003cspan class=\"hljs-title class_\"\u003eTest\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eplaceHoldRestCall\u003c/span\u003e() throws \u003cspan class=\"hljs-title class_\"\u003eException\u003c/span\u003e {\n    mockMvc.\u003cspan class=\"hljs-title function_\"\u003eperform\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003epost\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"/borrow/holds\"\u003c/span\u003e)\n                    .\u003cspan class=\"hljs-title function_\"\u003econtentType\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eMediaType\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eAPPLICATION_JSON\u003c/span\u003e)\n                    .\u003cspan class=\"hljs-title function_\"\u003econtent\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\n                            {\n                              \"\u003c/span\u003ebarcode\u003cspan class=\"hljs-string\"\u003e\": \"\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e64321704\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\",\n                              \"\u003c/span\u003epatronId\u003cspan class=\"hljs-string\"\u003e\": 5\n                            }\n                            \"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e))\n            .\u003cspan class=\"hljs-title function_\"\u003eandExpect\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003estatus\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003eisOk\u003c/span\u003e());\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003ejMolecules로 클래스 스테레오타입 시각화\u003c/h2\u003e\n\u003cp\u003e이전 블로그 시리즈에서 언급했듯이 jMolecules Intellij 플러그인을 사용하여 다양한 스테레오타입을 시각화할 수 있습니다. 그러나 jMolecules 라이브러리가 헥사고날 아키텍처에 대한 주석을 지원하더라도 플러그인은 해당 주석을 지원하지 않습니다. 저는 관련 주석을 추가하여 플러그인을 수정했습니다. 플러그인을 활성화하고 관련 주석을 추가한 후 대여 모듈 내부 클래스가 어떻게 보이는지 확인하세요.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-20-AdoptingDomain-FirstThinkinginModularMonolithwithHexagonalArchitecture_5.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e주요 포트 및 어댑터 클래스를 쉽게 식별할 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e헥사고날 아키텍처에 헌신해야 할까요?\u003c/h2\u003e\n\u003cp\u003e모듈형 단일체 애플리케이션을 구축할 때, 모든 모듈에 대해 헥사고날 아키텍처를 사용해야 할지에 대해 고려해야 합니다. 만약 모듈이 자체 비즈니스 규칙을 갖고 있거나 (또는 나중에 갖게 될 것으로 예상된다면), 헥사고날 아키텍처가 좋은 아이디어일 수 있습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e하지만 해결책에 더 많은 클래스와 장황성을 추가합니다. Layered 아키텍처에는 보조 포트와 어댑터가 없습니다. Spring Data 리포지토리 인터페이스는 Service 클래스에 직접 의존성을 추가하는 대가로 보조 포트와 어댑터의 역할을 취합니다.\u003c/p\u003e\n\u003cp\u003e결국, 헥사고날 아키텍처를 채택하는 이점이 비용을 크게 상회합니다. 최소한 코드베이스에서 불필요한 결합을 줄이기 위해 의존성 역전의 원칙을 적용할 수 있는지 항상 확인해야 합니다.\u003c/p\u003e\n\u003ch2\u003e헥사고날 아키텍처를 구현하는 데 DDD가 필요한가요?\u003c/h2\u003e\n\u003cp\u003e아니요. 도메인 주도 설계(DDD)는 도메인이 모델링되는 방식에만 관련이 있습니다. 아키텍처와는 관련이 없습니다(헥사고날이든 그 외). DDD를 사용해야 하는가요? 클래스와 필드를 명명할 때 항상 모든 지식의 언어를 사용하는 것을 추천합니다. 도메인 전문가가 사용하는 용어와 동일한 용어를 사용하는 코드는 항상 이해하기 쉽습니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eDDD의 Aggregate 및 기타 전략적 패턴을 사용하는 것은 애플리케이션의 필요성과 복잡성에 따라 다릅니다. 정당화되지 않은 경우에는 트랜잭션 스크립트나 액티브 레코드를 대신 사용할 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e헥사고날 아키텍처의 순수 구현 회피\u003c/h2\u003e\n\u003cp\u003e헥사곤의 내부는 핵심 비즈니스 로직의 구현이며, 헥사곤 외부에서 사용된 프레임워크와 기술로부터 자유롭게 유지해야 합니다. 몇몇 구현이 이 규칙을 신앙적으로 따라 코드를 복잡하게 만드는 것을 본 적이 있습니다.\u003c/p\u003e\n\u003cp\u003e예를 들어, 애플리케이션 서비스 코드는 트랜잭션 내에서 실행되어야 합니다. Spring의 @Transactional을 사용하면 쉽게 달성할 수 있습니다. 그러나 이를 피하려면 애플리케이션 서비스를 Spring으로부터 자유롭게 유지하기 위해 사용자 정의 어노테이션과 AOP를 도입해야 합니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e헥사곤 안의 내부는 Application과 Domain으로 구성되어 있습니다. 도메인은 이상적으로는 프레임워크 없이 유지되어야 하지만, Application은 Spring을 사용할 수 있습니다. 이 질문을 Vaughn Vernon에게 던졌고, 그는 좋은 설명을 제공했습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-20-AdoptingDomain-FirstThinkinginModularMonolithwithHexagonalArchitecture_6.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch2\u003e도메인 모델로부터 만들어진 분리된 JPA 엔티티를 병합하기\u003c/h2\u003e\n\u003cp\u003e아래 코드 스니펫을 확인하여 Hold를 배치하세요.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003epublic \u003cspan class=\"hljs-title class_\"\u003eHoldDto\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eplaceHold\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eHold.PlaceHold command\u003c/span\u003e) {\n    ...\n\n    \u003cspan class=\"hljs-title class_\"\u003eHold\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eplaceHold\u003c/span\u003e(command) \u003cspan class=\"hljs-comment\"\u003e// Hold 도메인 모델 객체 생성\u003c/span\u003e\n            .\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eholds\u003c/span\u003e::save) \u003cspan class=\"hljs-comment\"\u003e// JPA 엔티티로 변환하여 데이터베이스에 저장\u003c/span\u003e\n            .\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eeventPublisher\u003c/span\u003e::holdPlaced) \u003cspan class=\"hljs-comment\"\u003e// HoldPlaced 이벤트를 트리거\u003c/span\u003e\n\n    ...\n  );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eholds::save는 Secondary 포트 인터페이스에서의 호출로, Secondary 어댑터 구현을 트리거합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003epublic \u003cspan class=\"hljs-title class_\"\u003eHold\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003esave\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eHold hold\u003c/span\u003e) {\n    holds.\u003cspan class=\"hljs-title function_\"\u003esave\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eHoldEntity\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efromDomain\u003c/span\u003e(hold));\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e hold;\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// HoldEntity 클래스에서\u003c/span\u003e\npublic \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eHoldEntity\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efromDomain\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eHold hold\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e entity = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eHoldEntity\u003c/span\u003e();\n    entity.\u003cspan class=\"hljs-property\"\u003eid\u003c/span\u003e = hold.\u003cspan class=\"hljs-title function_\"\u003egetId\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003eid\u003c/span\u003e(); \u003cspan class=\"hljs-comment\"\u003e// 도메인 모델 식별자와 JPA 엔티티 PK가 동일합니다!\u003c/span\u003e\n    entity.\u003cspan class=\"hljs-property\"\u003ebook\u003c/span\u003e = hold.\u003cspan class=\"hljs-title function_\"\u003egetOnBook\u003c/span\u003e();\n    entity.\u003cspan class=\"hljs-property\"\u003edateOfHold\u003c/span\u003e = hold.\u003cspan class=\"hljs-title function_\"\u003egetDateOfHold\u003c/span\u003e();\n    entity.\u003cspan class=\"hljs-property\"\u003estatus\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eHoldStatus\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eHOLDING\u003c/span\u003e;\n    entity.\u003cspan class=\"hljs-property\"\u003eversion\u003c/span\u003e = 0L;\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e entity;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHold 도메인 모델은 영속화되기 전에 분리된 HoldEntity JPA 엔티티로 변환되어야 합니다. 엔티티 생성에는 기본 키 ID를 알아야 합니다. 도메인 모델이 PK를 따로 저장하거나 모델 식별자로 사용해야 합니다. 저의 예시에서는 후자를 선택했지만, 이 문제를 어떻게 해결할지 궁금합니다.\u003c/p\u003e\n\u003c!-- ui-station 사각형 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003e결론\u003c/h2\u003e\n\u003cp\u003e이 블로그에서는 계층 구조 대신 헥사고날 아키텍처를 사용하여 대출 모듈을 다시 구현했습니다. 이 과정에서 동일한 단일 코드 베이스의 일부임에도 불구하고 카탈로그 모듈에는 절대적으로 변경이 필요하지 않았음을 보여주었습니다. 이는 이벤트 기반 통합 덕분에 느슨한 결합이 활성화되었음을 확인했습니다.\u003c/p\u003e\n\u003cp\u003e헥사고날에 대한 여러분의 경험은 어떠한가요? 댓글에서 공유해 주시면 감사하겠습니다.\u003c/p\u003e\n\u003cp\u003e아래에서 업데이트된 코드를 확인할 수 있습니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-20-AdoptingDomain-FirstThinkinginModularMonolithwithHexagonalArchitecture"},"buildId":"JlBEgQDLGRx6DYlBnT8eD","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>